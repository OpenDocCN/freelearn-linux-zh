- en: Chapter 8. Introducing Device Drivers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。介绍设备驱动程序
- en: Kernel device drivers are the mechanism through which the underlying hardware
    is exposed to the rest of the system. As a developer of embedded systems, you
    need to know how device drivers fit into the overall architecture and how to access
    them from user space programs. Your system will probably have some novel pieces
    of hardware and you will have to work out a way of accessing them. In many cases,
    you will find that there are device drivers provided for you and you can achieve
    everything you want without writing any kernel code. For example, you can manipulate
    GPIO pins and LEDs using files in `sysfs`, and there are libraries to access serial
    buses, including SPI and I2C.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 内核设备驱动程序是将底层硬件暴露给系统其余部分的机制。作为嵌入式系统的开发人员，您需要了解设备驱动程序如何适应整体架构以及如何从用户空间程序中访问它们。您的系统可能会有一些新颖的硬件部件，您将不得不找出一种访问它们的方法。在许多情况下，您会发现已经为您提供了设备驱动程序，您可以在不编写任何内核代码的情况下实现您想要的一切。例如，您可以使用`sysfs`中的文件来操作GPIO引脚和LED，并且有库可以访问串行总线，包括SPI和I2C。
- en: There are many places to find out how to write a device driver, but few to tell
    you why you would want to and the choices you have in doing so. That is what I
    want to cover here. However, remember that this is not a book dedicated to writing
    kernel device drivers and that the information given here is to help you navigate
    the territory but not necessarily to set up home there. There are many good books
    and articles that will help you to write device drivers, some of which are listed
    at the end of this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多地方可以找到如何编写设备驱动程序的信息，但很少有地方告诉你为什么要这样做以及在这样做时的选择。这就是我想在这里介绍的内容。但是，请记住，这不是一本专门写内核设备驱动程序的书，这里提供的信息是为了帮助您在这个领域中导航，而不一定是为了在那里设置家。有很多好书和文章可以帮助您编写设备驱动程序，其中一些列在本章末尾。
- en: The role of device drivers
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备驱动程序的作用
- en: 'As mentioned in [Chapter 4](ch04.html "Chapter 4. Porting and Configuring the
    Kernel"), *Porting and Configuring the Kernel*, one of the functions of the kernel
    is to encapsulate the many hardware interfaces of a computer system and present
    them in a consistent manner to user-space programs. There are frameworks designed
    to make it easy to write the interface logic for a device in the kernel and you
    can integrate it with the kernel: this is a device driver, the piece of code that
    mediates between the kernel above it and the hardware below. A device driver is
    a piece of software that controls physical devices such as a UART or an MMC controller,
    or virtual devices such as the null device (`/dev/null`) or a ramdisk. One driver
    may control multiple devices of the same kind.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第4章](ch04.html "第4章。移植和配置内核")中所述，*移植和配置内核*，内核的功能之一是封装计算机系统的许多硬件接口，并以一致的方式呈现给用户空间程序。有设计的框架使得在内核中编写设备的接口逻辑变得容易，并且可以将其集成到内核中：这就是设备驱动程序，它是介于其上方的内核和其下方的硬件之间的代码片段。设备驱动程序是控制物理设备（如UART或MMC控制器）或虚拟设备（如空设备(`/dev/null`)或ramdisk）的软件。一个驱动程序可以控制多个相同类型的设备。
- en: Kernel device driver code runs at a high privilege level, as does the rest of
    the kernel. It has full access to the processor address space and hardware registers.
    It can handle interrupts and DMA transfers. It can make use of the sophisticated
    kernel infrastructure for synchronization and memory management. There is a downside
    to this, which is that if something goes wrong in a buggy driver, it can go really
    wrong and bring the system down. Consequently, there is a principle that device
    drivers should be as simple as possible, just providing information to applications
    where the real decisions are made. You often hear this being expressed as *no
    policy in the kernel*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 内核设备驱动程序代码以高特权级别运行，就像内核的其余部分一样。它可以完全访问处理器地址空间和硬件寄存器。它可以处理中断和DMA传输。它可以利用复杂的内核基础设施进行同步和内存管理。这也有一个缺点，即如果有错误的驱动程序出现问题，它可能会导致系统崩溃。因此，有一个原则是设备驱动程序应尽可能简单，只提供信息给应用程序，真正的决策是在应用程序中做出的。你经常听到这被表达为*内核中没有策略*。
- en: 'In Linux, there are three main types of device driver:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，有三种主要类型的设备驱动程序：
- en: '**character**: This is for unbuffered I/O with a rich range of functions and
    a thin layer between the application code and the driver. It is the first choice
    when implementing custom device drivers.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符**：这是用于具有丰富功能范围和应用程序代码与驱动程序之间薄层的无缓冲I/O。在实现自定义设备驱动程序时，这是首选。'
- en: '**block**: This has an interface tailored for block I/O to and from mass storage
    devices. There is a thick layer of buffering designed to make disk reads and writes
    as fast as possible, which makes it unsuitable for anything else.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块**：这具有专门针对从大容量存储设备进行块I/O的接口。有一个厚的缓冲层，旨在使磁盘读取和写入尽可能快，这使其不适用于其他用途。'
- en: '**network**: This is similar to a block device but is used for transmitting
    and receiving network packets rather than disk blocks.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：这类似于块设备，但用于传输和接收网络数据包，而不是磁盘块。'
- en: There is also a fourth type that presents itself as a group of files in one
    of the pseudo filesystems. For example, you might access the GPIO driver through
    a group of files in `/sys/class/gpio`, as I will describe later on in this chapter.
    Let's begin by looking in more detail at the three basic device types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第四种类型，它表现为伪文件系统中的一组文件。例如，您可以通过`/sys/class/gpio`中的一组文件访问GPIO驱动程序，我将在本章后面描述。让我们首先更详细地看一下三种基本设备类型。
- en: Character devices
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符设备
- en: 'These devices are identified in user space by a filename: if you want to read
    from a UART, you open the device node, for example, the first serial port on the
    ARM Versatile Express would be `/dev/ttyAMA0`. The driver is identified differently
    in the kernel, using the major number which, in the example given, is `204`. Since
    the UART driver can handle more than one UART, there is a second number, called
    the minor number, which identifies a specific interface, 64, in this case:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备在用户空间通过文件名进行标识：如果你想从UART读取数据，你需要打开设备节点，例如，在ARM Versatile Express上的第一个串行端口将是`/dev/ttyAMA0`。驱动程序在内核中以不同的方式进行标识，使用的是主设备号，在给定的示例中是`204`。由于UART驱动程序可以处理多个UART，还有第二个号码，称为次设备号，用于标识特定的接口，例如在这种情况下是64。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The list of standard major and minor numbers can be found in the kernel documentation,
    in `Documentation/devices.txt`. The list does not get updated very often and does
    not include the `ttyAMA` device described in the preceding paragraph. Nevertheless,
    if you look at the source code in `drivers/tty/serial/amba-pl011.c`, you will
    see that the major and minor numbers are declared:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 标准主设备号和次设备号的列表可以在内核文档中找到，位于`Documentation/devices.txt`中。该列表不经常更新，也不包括前面段落中描述的`ttyAMA`设备。然而，如果你查看`drivers/tty/serial/amba-pl011.c`中的源代码，你会看到主设备号和次设备号是如何声明的。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Where there is more than one instance of a device, the naming convention for
    the device nodes is `<base name><interface number>`, for example, `ttyAMA0`, `ttyAMA1`,
    and so on.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个设备有多个实例时，设备节点的命名约定为`<基本名称><接口号>`，例如，`ttyAMA0`，`ttyAMA1`等。
- en: 'As I mentioned in [Chapter 5](ch05.html "Chapter 5. Building a Root Filesystem"),
    *Building a Root Filesystem*, the device nodes can be created in several ways:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在[第5章](ch05.html "第5章。构建根文件系统")中提到的，*构建根文件系统*，设备节点可以通过多种方式创建：
- en: '`devtmpfs`: The node that is created when the device driver registers a new
    device interface using a base name supplied by the driver (`ttyAMA`) and an instance
    number.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devtmpfs`：当设备驱动程序使用驱动程序提供的基本名称（`ttyAMA`）和实例号注册新的设备接口时创建的节点。'
- en: '`udev` or `mdev` (without `devtmpfs`): Essentially the same as with `devtmpfs`,
    except that a user-space daemon program has to extract the device name from `sysfs`
    and create the node. I will talk about `sysfs` later.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`udev`或`mdev`（没有`devtmpfs`）：与`devtmpfs`基本相同，只是需要一个用户空间守护程序从`sysfs`中提取设备名称并创建节点。我稍后会谈到`sysfs`。'
- en: '`mknod`: If you are using static device nodes, they are created manually using
    `mknod`.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mknod`：如果你使用静态设备节点，可以使用`mknod`手动创建它们。'
- en: You may have the impression from the numbers I have used above that both major
    and minor numbers are 8-bit numbers in the range 0 to 255\. In fact, from Linux
    2.6 onwards, the major number is 12 bits long, which gives valid numbers from
    1 to 4,095, and the minor number is 20 bits, from 0 to 1,048,575.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会从上面我使用的数字中得到这样的印象，即主设备号和次设备号都是8位数字，范围在0到255之间。实际上，从Linux 2.6开始，主设备号有12位长，有效数字范围为1到4095，次设备号有20位，范围为0到1048575。
- en: When you open a device node, the kernel checks to see whether the major and
    minor numbers fall into a range registered by a device driver of that type (a
    character or block). If so, it passes the call to the driver, otherwise the open
    call fails. The device driver can extract the minor number to find out which hardware
    interface to use. If the minor number is out of range, it returns an error.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开一个设备节点时，内核会检查主设备号和次设备号是否落在该类型设备驱动程序注册的范围内（字符或块）。如果是，它会将调用传递给驱动程序，否则打开调用失败。设备驱动程序可以提取次设备号以找出要使用的硬件接口。如果次设备号超出范围，它会返回错误。
- en: 'To write a program that accesses a device driver, you have to have some knowledge
    of how it works. In other words, a device driver is not the same as a file: the
    things you do with it change the state of the device. A simple example is the
    pseudo random number generator, `urandom`, which returns bytes of random data
    every time you read it. Here is a program that does just that:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个访问设备驱动程序的程序，你必须对其工作原理有一定了解。换句话说，设备驱动程序与文件不同：你对它所做的事情会改变设备的状态。一个简单的例子是伪随机数生成器`urandom`，每次读取它都会返回随机数据的字节。下面是一个执行此操作的程序：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The nice thing about the Unix driver model is that, once we know that there
    is a device named `urandom` and that every time we read from it, it returns a
    fresh set of pseudo random data, we don't need to know anything else about it.
    We can just use normal functions such as `open(2)`, `read(2)`, and `close(2)`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Unix驱动程序模型的好处在于，一旦我们知道有一个名为`urandom`的设备，并且每次从中读取数据时，它都会返回一组新的伪随机数据，我们就不需要再了解其他任何信息。我们可以直接使用诸如`open(2)`、`read(2)`和`close(2)`等普通函数。
- en: We could use the stream I/O functions `fopen(3)`, `fread(3)`, and `fclose(3)`
    instead, but the buffering implicit in these functions often causes unexpected
    behavior. For example, `fwrite(3)` usually only writes to the user-space buffer,
    not to the device. We would need to call `fflush(3)` to force the buffer to be
    written out.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用流I/O函数`fopen(3)`、`fread(3)`和`fclose(3)`，但是这些函数隐含的缓冲区通常会导致意外的行为。例如，`fwrite(3)`通常只写入用户空间缓冲区，而不是设备。我们需要调用`fflush(3)`来强制刷新缓冲区。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't use stream I/O functions such as `fread(3)` and `fwrite(3)` when calling
    device drivers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在调用设备驱动程序时使用流I/O函数，比如`fread(3)`和`fwrite(3)`。
- en: Block devices
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块设备
- en: Block devices are also associated with a device node, which also has major and
    minor numbers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 块设备也与设备节点相关联，同样具有主设备号和次设备号。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Although character and block devices are identified using major and minor numbers,
    they are in different namespaces. A character driver with a major number 4 is
    in no way related to a block driver with a major number 4.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管字符设备和块设备使用主设备号和次设备号进行标识，但它们位于不同的命名空间。主设备号为4的字符驱动程序与主设备号为4的块驱动程序没有任何关联。
- en: 'With block devices, the major number is used to identify the device driver
    and the minor number is used to identify the partition. Let''s look at the MMC
    driver as an example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于块设备，主编号用于标识设备驱动程序，次编号用于标识分区。让我们以MMC驱动程序为例：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The major number is 179 (look it up in `devices.txt`!). The minor numbers are
    used in ranges to identify different `mmc` devices and the partitions of the storage
    medium on that device. In the case of the mmcblk driver, the ranges are eight
    minor numbers per device: the minor numbers from 0 to 7 are for the first device,
    the numbers from 8 to 15 are for the second, and so on. Within each range, the
    first minor number represents the entire device as raw sectors, and the others
    represent up to seven partitions.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 主编号为179（在`devices.txt`中查找！）。次编号用于标识不同的`mmc`设备和该设备上存储介质的分区。对于mmcblk驱动程序，每个设备有八个次编号范围：从0到7的次编号用于第一个设备，从8到15的次编号用于第二个设备，依此类推。在每个范围内，第一个次编号代表整个设备的原始扇区，其他次编号代表最多七个分区。
- en: You are probably aware of the SCSI disk driver, known as sd, which is used to
    control a range of disks that use the SCSI command set, which includes SCSI, SATA,
    USB mass storage, and **UFS** (**universal flash storage**). It has the major
    number eight and ranges of 16 minor numbers per interface (or disk). The minor
    numbers from 0 to 15 are for the first interface, with device nodes named `sda`
    up to `sda15`, the numbers from 16 to 31 are for the second disk with device nodes
    `sdb` up to `sdb15`, and so on. This continues up to the sixteenth disk from 240
    to 255, with the node name `sdp`. There are other major numbers reserved for them
    because SCSI disks are so popular, but we needn't worry about that here.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经了解到SCSI磁盘驱动程序，称为sd，用于控制使用SCSI命令集的一系列磁盘，其中包括SCSI、SATA、USB大容量存储和UFS（通用闪存存储）。它的主编号为8，每个接口（或磁盘）有16个次编号。从0到15的次编号用于第一个接口，设备节点的名称为`sda`到`sda15`，从16到31的编号用于第二个磁盘，设备节点为`sdb`到`sdb15`，依此类推。这一直持续到第16个磁盘，从240到255，节点名称为`sdp`。由于SCSI磁盘非常受欢迎，还有其他为它们保留的主编号，但我们不需要在这里担心这些。
- en: 'The partitions are created using utilities such as `fdisk`, `sfidsk`, or `parted`.
    An exception is raw flash memory: the partition information for the MTD driver
    is part of the kernel command line or in the device tree, or one of the other
    methods described in [Chapter 7](ch07.html "Chapter 7. Creating a Storage Strategy"),
    *Creating a Storage Strategy*.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 分区是使用诸如`fdisk`、`sfidsk`或`parted`之类的实用程序创建的。一个例外是原始闪存：MTD驱动程序的分区信息是内核命令行或设备树中的一部分，或者是[第7章](ch07.html
    "第7章。创建存储策略")中描述的其他方法之一，*创建存储策略*。
- en: A user-space program can open and interact directly with a block device through
    the device node. This is not a common thing to do, and is usually for performing
    administrative operations such as partitioning, formatting with a filesystem,
    and mounting. Once the filesystem is mounted, you interact with the block device
    indirectly through the files in that filesystem.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间程序可以通过设备节点直接打开和与块设备交互。这不是常见的操作，通常用于执行分区、格式化文件系统和挂载等管理操作。一旦文件系统被挂载，您将通过该文件系统中的文件间接与块设备交互。
- en: Network devices
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络设备
- en: 'Network devices are not accessed through device nodes and they do not have
    major and minor numbers. Instead, a network device is allocated a name by the
    kernel, based on a string and an instance number. Here is an example of the way
    a network driver registers an interface:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 网络设备不是通过设备节点访问的，也没有主次编号。相反，内核会根据字符串和实例号为网络设备分配一个名称。以下是网络驱动程序注册接口的示例方式：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This creates a network device named `net0` the first time it is called, `net1`
    the second, and so on. More common names are `lo`, `eth0`, and `wlan0`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`net0`的网络设备，第一次调用时为`net1`，依此类推。更常见的名称是`lo`、`eth0`和`wlan0`。
- en: Note that this is the name it starts off with; device managers, such as `udev`,
    may change to something different later on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是它起始的名称；设备管理器（如`udev`）可能会在以后更改为其他名称。
- en: Usually, the network interface name is only used when configuring the network
    using utilities such as `ip` and `ifconfig` to establish a network address and
    route. Thereafter, you interact with the network driver indirectly by opening
    sockets, and let the network layer decide how to route them to the right interface.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，网络接口名称仅在使用诸如`ip`和`ifconfig`之类的实用程序配置网络以建立网络地址和路由时使用。此后，您通过打开套接字间接与网络驱动程序交互，并让网络层决定如何将它们路由到正确的接口。
- en: 'However, it is possible to access network devices directly from user space
    by creating a socket and using the `ioctl` commands listed in `include/linux/sockios.h`.
    For example, this program uses `SIOCGIFHWADDR` to query the driver for the hardware
    (MAC) address:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，可以通过创建套接字并使用`include/linux/sockios.h`中列出的`ioctl`命令直接从用户空间访问网络设备。例如，此程序使用`SIOCGIFHWADDR`查询驱动程序的硬件（MAC）地址：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a standard device, `ioctl`, which is handled by the network layer on
    the driver's behalf, but it is possible to define your own `ioctl` numbers and
    handle them in a custom network driver.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准设备`ioctl`，由网络层代表驱动程序处理，但是可以定义自己的`ioctl`编号并在自定义网络驱动程序中处理它们。
- en: Finding out about drivers at runtime
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时了解驱动程序
- en: Once you have a running Linux system, it is useful to know which device drivers
    are loaded and what state they are in. You can find out a lot by reading the files
    in `/proc` and `/sys`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您运行了Linux系统，了解加载的设备驱动程序及其状态是很有用的。您可以通过阅读`/proc`和`/sys`中的文件来了解很多信息。
- en: 'First of all, you can list the character and block device drivers currently
    loaded and active by reading `/proc/devices`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以通过读取`/proc/devices`来列出当前加载和活动的字符和块设备驱动程序：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For each driver, you can see the major number and the base name. However, this
    does not tell you how many devices each driver is attached to. It only shows `ttyAMA`
    but gives you no clue that it is attached to four real UARTS. I will come back
    to that later when I look at `sysfs`. If you are using a device manager such as
    `mdev`, `udev`, or `devtmpfs`, you can list the character and block device interfaces
    by looking in `/dev`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个驱动程序，您可以看到主要编号和基本名称。但是，这并不能告诉您每个驱动程序连接到了多少设备。它只显示了`ttyAMA`，但并没有提示它连接了四个真实的UART。我稍后会回到这一点，当我查看`sysfs`时。如果您正在使用诸如`mdev`、`udev`或`devtmpfs`之类的设备管理器，您可以通过查看`/dev`中的字符和块设备接口来列出它们。
- en: 'You can also list network interfaces using `ifconfig` or `ip`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`ifconfig`或`ip`列出网络接口：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can also find out about devices attached to USB or PCI buses using the well-known
    commands `lsusb` and `lspci`. There is information about them in the respective
    manuals and plenty of online guides, so I will not describe them any further here.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用众所周知的命令`lsusb`和`lspci`来查找连接到USB或PCI总线的设备。关于它们的信息在各自的手册和大量的在线指南中都有，所以我在这里不再详细描述它们。
- en: The really interesting information is in `sysfs`, which is the next topic.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 真正有趣的信息在`sysfs`中，这是下一个主题。
- en: Getting information from sysfs
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从sysfs获取信息
- en: You can define `sysfs` in a pedantic way as a representation of kernel objects,
    attributes and relationships. A kernel object is a directory, an attribute is
    a file, and a relationship is a symbolic link from one object to another.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以一种迂腐的方式定义`sysfs`，即内核对象、属性和关系的表示。内核对象是一个目录，属性是一个文件，关系是从一个对象到另一个对象的符号链接。
- en: 'From a more practical point of view, since the Linux device driver model, which
    was introduced in version 2.6, represents all devices and drivers as kernel objects.
    You can see the kernel''s view of the system laid out before you by looking in
    `/sys`, as shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从更实际的角度来看，自Linux设备驱动程序模型在2.6版本中引入以来，它将所有设备和驱动程序表示为内核对象。您可以通过查看`/sys`来看到系统的内核视图，如下所示：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the context of discovering information about devices and drivers, I will
    look at three of the directories: `devices`, `class`, and `block`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在发现有关设备和驱动程序的信息方面，我将查看三个目录：`devices`、`class`和`block`。
- en: 'The devices: /sys/devices'
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备：/sys/devices
- en: 'This is the kernel''s view of the devices discovered since boot and how they
    are connected to each other. It is organized at the top level by the system bus,
    so what you see varies from one system to another. This is the QEMU emulation
    of the Versatile Express:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是内核对自启动以来发现的设备及其相互连接的视图。它是按系统总线在顶层组织的，因此您看到的内容因系统而异。这是Versatile Express的QEMU仿真：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are three directories that are present on all systems:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有系统上都存在三个目录：
- en: '`system`: This contains devices at the heart of the system, including CPUs
    and clocks.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`系统`：这包含了系统核心的设备，包括CPU和时钟。'
- en: '`virtual`: This contains devices that are memory-based. You will find the memory
    devices that appear as `/dev/null`, `/dev/random`, and `/dev/zero` in `virtual/mem`.
    You will find the loopback device, `lo`, in `virtual/net`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`虚拟`：这包含基于内存的设备。您将在`virtual/mem`中找到出现为`/dev/null`、`/dev/random`和`/dev/zero`的内存设备。您将在`virtual/net`中找到环回设备`lo`。'
- en: '`platform`: This is a catch-all for devices that are not connected via a conventional
    hardware bus. This may be almost everything on an embedded device.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`平台`：这是一个通用术语，用于指代通过传统硬件总线连接的设备。这几乎可以是嵌入式设备上的任何东西。'
- en: The other devices appear in directories that correspond to actual system buses.
    For example, the PCI root bus, if there is one, appears as `pci0000:00`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其他设备出现在与实际系统总线对应的目录中。例如，PCI根总线（如果有）显示为`pci0000:00`。
- en: Navigating this hierarchy is quite hard because it requires some knowledge of
    the topology of your system and the pathnames become quite long and hard to remember.
    To make life easier, `/sys/class` and `/sys/block` offer two different views of
    the devices.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览这个层次结构相当困难，因为它需要对系统的拓扑结构有一定的了解，而且路径名变得相当长，很难记住。为了让生活变得更容易，`/sys/class`和`/sys/block`提供了设备的两种不同视图。
- en: 'The drivers: /sys/class'
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 驱动程序：/sys/class
- en: This is a view of the device drivers presented by their type, in other words,
    it is a software view rather than a hardware view. Each of the subdirectories
    represents a class of driver and is implemented by a component of the driver framework.
    For example, UART devices are managed by the `tty` layer and you will find them
    in `/sys/class/tty`. Likewise, you will find network devices in `/sys/class/net`,
    input devices such as the keyboard, the touchscreen, and the mouse in `/sys/class/input`,
    and so on.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设备驱动程序的视图，按其类型呈现，换句话说，这是一种软件视图而不是硬件视图。每个子目录代表一个驱动程序类，并由驱动程序框架的一个组件实现。例如，UART设备由`tty`层管理，您将在`/sys/class/tty`中找到它们。同样，您将在`/sys/class/net`中找到网络设备，在`/sys/class/input`中找到输入设备，如键盘、触摸屏和鼠标，依此类推。
- en: There is a symbolic link in each subdirectory for each instance of that type
    of device pointing to its representation in `/sys/device`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '每个子目录中都有一个符号链接，指向该类型设备的每个实例在`/sys/device`中的表示。 '
- en: 'To take a concrete example, let''s look at `/sys/class/tty/ttyAMA0`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 举个具体的例子，让我们看一下`/sys/class/tty/ttyAMA0`：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The link `device` references the hardware node for the device and `subsystem`
    points back to `/sys/class/tty`. The others are attributes of the device. Some
    are specific to a UART, such as `xmit_fifo_size` and others apply to many types
    of device such as the interrupt number, `irq`, and the device number `dev`. Some
    attribute files are writable and allow you to tune parameters in the driver at
    runtime.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 链接`设备`引用了设备的硬件节点，`子系统`指向`/sys/class/tty`。其他属性是设备的属性。有些属性是特定于UART的，比如`xmit_fifo_size`，而其他属性适用于许多类型的设备，比如中断号`irq`和设备号`dev`。一些属性文件是可写的，允许您在运行时调整驱动程序的参数。
- en: 'The `dev` attribute is particularly interesting. If you look at its value,
    you will find the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`dev`属性特别有趣。如果您查看它的值，您会发现以下内容：'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: These are the major and minor numbers of this device. This attribute is created
    when the driver registered this interface and it is from this file that `udev`
    and `mdev` read that information if they are being used without the help of `devtmpfs`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设备的主要和次要编号。当驱动程序注册了这个接口时，就会创建这个属性，如果没有`devtmpfs`的帮助，`udev`和`mdev`就会从这个文件中读取这些信息。
- en: 'The block drivers: /sys/block'
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 块驱动程序：/sys/block
- en: 'There is one more view of the device model that is important: the block driver
    view that you will find in `/sys/block`. There is a subdirectory for each block
    device. This example is taken from a BeagleBone Black:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 设备模型的另一个重要视图是块驱动程序视图，你可以在`/sys/block`中找到。每个块设备都有一个子目录。这个例子来自BeagleBone Black：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you look into `mmcblk1`, which is the eMMC chip on this board, you can see
    the attributes of the interface and the partitions within it:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这块板上的eMMC芯片`mmcblk1`，你可以看到接口的属性和其中的分区：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The conclusion, then, is that you can learn a lot about the devices (the hardware)
    and the drivers (the software) that are present on a system by reading `sysfs`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过阅读`sysfs`，你可以了解系统上存在的设备（硬件）和驱动程序（软件）。
- en: Finding the right device driver
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找合适的设备驱动程序
- en: A typical embedded board is based on a reference design from the manufacturer
    with changes to make it suitable for a particular application. It may have a temperature
    sensor attached via I2C, lights and buttons connected via GPIO pins, an external
    Ethernet MAC, a display panel via a MIPI interface, or many other things. Your
    job is to create a custom kernel to control all of that, so where do you start?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的嵌入式板是基于制造商的参考设计，经过更改以适合特定应用。它可能通过I2C连接温度传感器，通过GPIO引脚连接灯和按钮，通过外部以太网MAC连接，通过MIPI接口连接显示面板，或者其他许多东西。你的工作是创建一个自定义内核来控制所有这些，那么你从哪里开始呢？
- en: Some things are so simple that you can write user space code to handle them.
    GPIOs and simple peripherals connected via I2C or SPI are easy to control from
    user space, as I will explain later.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有些东西非常简单，你可以编写用户空间代码来处理它们。通过I2C或SPI连接的GPIO和简单外围设备很容易从用户空间控制，我稍后会解释。
- en: Other things need a kernel driver so you need to know how to find one and incorporate
    it into your build. There is no simple answer, but here are some places to look.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 其他东西需要内核驱动程序，因此你需要知道如何找到一个并将其整合到你的构建中。没有简单的答案，但这里有一些地方可以找到。
- en: The most obvious place to look is the driver support page on the manufacturer's
    website, or you could ask them directly. In my experience, this seldom gets the
    result you want; hardware manufacturers are not are not particularly Linux-savvy
    and they often give you misleading information. They may have proprietary drivers
    as binary blobs or they may have source code, but for a different version of the
    kernel than the one you have. So, by all means try this route. I will always try
    to find an open source driver for the task in hand.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的地方是制造商网站上的驱动程序支持页面，或者你可以直接问他们。根据我的经验，这很少能得到你想要的结果；硬件制造商通常不太懂Linux，他们经常给出误导性的信息。他们可能有二进制的专有驱动程序，也可能有源代码，但是适用于与你拥有的内核版本不同的版本。所以，尽管可以尝试这种途径。我总是会尽力寻找适合手头任务的开源驱动程序。
- en: 'There may be support in your kernel already: there are many thousands of drivers
    in mainline Linux and there are many vendor-specific drivers in the vendor kernels.
    Begin by running `make menuconfig` (or `xconfig`) and search for the product name
    or number. If you do not find an exact match, try more generic searches, allowing
    for the fact that most drivers handle a range of products from the same family.
    Next, try searching through the code in the drivers directory (`grep` is you friend
    here). Always make sure you are running the latest kernel for your board: later
    kernels generally have more device drivers.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你的内核可能已经支持：主线Linux中有成千上万的驱动程序，供应商内核中也有许多特定于供应商的驱动程序。首先运行`make menuconfig`（或`xconfig`），搜索产品名称或编号。如果找不到完全匹配的，尝试更通用的搜索，考虑到大多数驱动程序处理同一系列产品。接下来，尝试在驱动程序目录中搜索代码（这里用`grep`）。始终确保你正在运行适合你的板的最新内核：较新的内核通常有更多的设备驱动程序。
- en: If you still don't have a driver, you can try searching online and asking in
    the relevant forums to see if there is a driver for a different version of Linux.
    If you find one, you will have to backport it to your kernel. If the kernel versions
    are similar, it may be easy, but if they are more than 12 to 18 months apart,
    the chances are that the interfaces will have changed to the extent that you will
    have to rewrite a chunk of the driver to integrate it with your kernel. You may
    want to outsource this work. If all of the above fails, you will have to find
    a solution yourself.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有驱动程序，可以尝试在线搜索并在相关论坛上询问，看看是否有适用于不同Linux版本的驱动程序。如果找到了，你就需要将其移植到你的内核中。如果内核版本相似，可能会很容易，但如果相隔12到18个月以上，接口很可能已经发生了变化，你将不得不重写驱动程序的一部分，以使其与你的内核集成。你可能需要外包这项工作。如果所有上述方法都失败了，你就得自己找解决方案。
- en: Device drivers in user-space
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户空间的设备驱动程序
- en: Before you start writing a device driver, pause for a moment to consider whether
    it is really necessary. There are generic device drivers for many common types
    of device that allow you to interact with hardware directly from user space without
    having to write a line of kernel code. User space code is certainly easier to
    write and debug. It is also not covered by the GPL, although I don't feel that
    is a good reason in itself to do it this way.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编写设备驱动程序之前，暂停一下，考虑一下是否真的有必要。对于许多常见类型的设备，有通用的设备驱动程序，允许你直接从用户空间与硬件交互，而不必编写一行内核代码。用户空间代码肯定更容易编写和调试。它也不受GPL的限制，尽管我不认为这本身是一个好理由。
- en: 'They fall into two broad categories: those that you control through files in
    `sysfs`, including GPIO and LEDs, and serial buses that expose a generic interface
    through a device node, such as I2C.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以分为两大类：通过`sysfs`中的文件进行控制的设备，包括GPIO和LED，以及通过设备节点公开通用接口的串行总线，比如I2C。
- en: GPIO
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPIO
- en: '**General Purpose Input/Output** (**GPIO**) is the simplest form of digital
    interface since it gives you direct access to individual hardware pins, each of
    which can be configured as input or output. GPIO can even be used to create higher
    level interfaces such as I2C or SPI by manipulating each bit in the software,
    a technique that is called bit banging. The main limitation is the speed and accuracy
    of the software loops and the number of CPU cycles you want to dedicate to them.
    Generally speaking, it is hard to achieve timer accuracy better than a millisecond
    with kernels compiled with `CONFIG_PREEMPT`, and 100 microseconds with `RT_PREEMPT`,
    as we shall see in [Chapter 14](ch14.html "Chapter 14. Real-time Programming"),
    *Real-time Programming*. More common use cases for GPIO are for reading push buttons
    and digital sensors and controlling LEDs, motors, and relays.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用输入/输出**（**GPIO**）是数字接口的最简单形式，因为它可以直接访问单个硬件引脚，每个引脚可以配置为输入或输出。 GPIO甚至可以用于通过在软件中操作每个位来创建更高级的接口，例如I2C或SPI，这种技术称为位操作。主要限制是软件循环的速度和准确性以及您想要为它们分配的CPU周期数。一般来说，使用`CONFIG_PREEMPT`编译的内核很难实现比毫秒更好的定时器精度，使用`RT_PREEMPT`编译的内核很难实现比100微秒更好的定时器精度，我们将在[第14章](ch14.html
    "第14章。实时编程")中看到，*实时编程*。 GPIO的更常见用途是读取按钮和数字传感器以及控制LED、电机和继电器。'
- en: Most SoCs have a lot of GPIO bits which are grouped together in GPIO registers,
    usually 32 bits per register. On-chip GPIO bits are routed through to GPIO pins
    on the chip package via a multiplexer, known as a pin mux, which I will describe
    later. There may be additional GPIO bits available off-chip in the power management
    chip, and in dedicated GPIO extenders, connected through I2C or SPI buses. All
    this diversity is handled by a kernel subsystem known as `gpiolib`, which is not
    actually a library but the infrastructure GPIO drivers use to expose IO in a consistent
    way.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数SoC有很多GPIO位，这些位被分组在GPIO寄存器中，通常每个寄存器有32位。芯片上的GPIO位通过多路复用器（称为引脚复用器）路由到芯片封装上的GPIO引脚，我稍后会描述。在电源管理芯片和专用GPIO扩展器中可能有额外的GPIO位，通过I2C或SPI总线连接。所有这些多样性都由一个名为`gpiolib`的内核子系统处理，它实际上不是一个库，而是GPIO驱动程序用来以一致的方式公开IO的基础设施。
- en: There are details about the implementation of `gpiolib` in the kernel source
    in `Documentation/gpio` and the drivers themselves are in `drivers/gpio`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`gpiolib`实现的详细信息在内核源中的`Documentation/gpio`中，驱动程序本身在`drivers/gpio`中。
- en: 'Applications can interact with `gpiolib` through files in the `/sys/class/gpio`
    directory. Here is an example of what you will see in there on a typical embedded
    board (a BeagleBone Black):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以通过`/sys/class/gpio`目录中的文件与`gpiolib`进行交互。以下是在典型嵌入式板（BeagleBone Black）上看到的内容的示例：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `gpiochip0` to `gpiochip96` directories represent four GPIO registers,
    each with 32 GPIO bits. If you look in one of the `gpiochip` directories, you
    will see the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpiochip0`到`gpiochip96`目录代表了四个GPIO寄存器，每个寄存器有32个GPIO位。如果你查看其中一个`gpiochip`目录，你会看到以下内容：'
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The file `base` contains the number of the first GPIO pin in the register and
    `ngpio` contains the number of bits in the register. In this case, `gpiochip96/base`
    is 96 and `gpiochip96/ngpio` is 32, which tells you that it contains GPIO bits
    96 to 127\. It is possible for there to be a gap between the last GPIO in one
    register and the first GPIO in the next.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`base`包含寄存器中第一个GPIO引脚的编号，`ngpio`包含寄存器中位的数量。在这种情况下，`gpiochip96/base`是96，`gpiochip96/ngpio`是32，这告诉您它包含GPIO位96到127。寄存器中最后一个GPIO和下一个寄存器中第一个GPIO之间可能存在间隙。
- en: 'To control a GPIO bit from user space, you first have to export it from kernel
    space, which you do by writing the GPIO number to `/sys/class/gpio/export`. This
    example shows the process for GPIO 48:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要从用户空间控制GPIO位，您首先必须从内核空间导出它，方法是将GPIO编号写入`/sys/class/gpio/export`。此示例显示了GPIO
    48的过程：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now there is a new directory, `gpio48`, which contains the files you need to
    control the pin. Note that if the GPIO bit is already claimed by the kernel, you
    will not be able to export it in this way.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个新目录`gpio48`，其中包含了控制引脚所需的文件。请注意，如果GPIO位已被内核占用，您将无法以这种方式导出它。
- en: 'The directory `gpio48` contains these files:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 目录`gpio48`包含这些文件：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The pin begins as an input. To change it to an output, write `out` to the `direction`
    file. The file `value` contains the current state of the pin, which is 0 for low
    and 1 for high. If it is an output, you can change the state by writing 0 or 1
    to `value`. Sometimes, the meaning of low and high is reversed in hardware (hardware
    engineers enjoy doing that sort of thing), so writing 1 to `active_low` inverts
    the meaning so that a low voltage is reported as 1 in `value` and a high voltage
    as 0.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚最初是输入的。要将其更改为输出，请将`out`写入`direction`文件。文件`value`包含引脚的当前状态，低电平为0，高电平为1。如果它是输出，您可以通过向`value`写入0或1来更改状态。有时，在硬件中低电平和高电平的含义是相反的（硬件工程师喜欢做这种事情），因此将1写入`active_low`会反转含义，以便在`value`中将低电压报告为1，高电压为0。
- en: You can remove a GPIO from user space control by writing the GPIO number to
    `/sys/class/gpio/unexport`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将GPIO编号写入`/sys/class/gpio/unexport`来从用户空间控制中删除GPIO。
- en: Handling interrupts from GPIO
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从GPIO处理中断
- en: 'In many cases, a GPIO input can be configured to generate an interrupt when
    it changes state, which allows you to wait for the interrupt rather than polling
    in an inefficient software loop. If the GPIO bit can generate interrupts, the
    file `edge` exists. Initially, it has the value `none`, meaning that it does not
    generate interrupts. To enable interrupts, you can set it to one of these values:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，可以将GPIO输入配置为在状态更改时生成中断，这允许您等待中断而不是在低效的软件循环中轮询。如果GPIO位可以生成中断，则文件`edge`存在。最初，它的值为`none`，表示它不会生成中断。要启用中断，您可以将其设置为以下值之一：
- en: '**rising**: Interrupt on rising edge'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rising**：上升沿中断'
- en: '**falling**: Interrupt on falling edge'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**falling**：下降沿中断'
- en: '**both**: Interrupt on both rising and falling edges'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**both**：上升沿和下降沿中断'
- en: '**none**: No interrupts (default)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**none**：无中断（默认）'
- en: 'You can wait for an interrupt using the `poll()` function with `POLLPRI` as
    the event. If you want to wait for a rising edge on GPIO 48, you first enable
    interrupts:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`poll（）`函数等待中断，事件为`POLLPRI`。如果要等待GPIO 48上的上升沿，首先要启用中断：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, you use `poll()` to wait for the change, as shown in this code example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用`poll（）`等待更改，如此代码示例所示：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: LEDs
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LED
- en: LEDs are often controlled though a GPIO pin, but there is another kernel subsystem
    that offers more specialized control specific to the purpose. The `leds` kernel
    subsystem adds the ability to set brightness, should the LED have that ability,
    and can handle LEDs connected in other ways than a simple GPIO pin. It can be
    configured to trigger the LED on an event such as block device access or just
    a heartbeat to show that the device is working. There is more information in `Documentation/leds/`
    and the drivers are in `drivers/leds/`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: LED通常是通过GPIO引脚控制的，但是还有另一个内核子系统，提供了更专门的控制，用于特定目的。 `leds`内核子系统增加了设置亮度的功能，如果LED具有该功能，并且可以处理连接方式不同于简单GPIO引脚的LED。它可以配置为在事件上触发LED，例如块设备访问或只是心跳以显示设备正在工作。在`Documentation/leds/`中有更多信息，驱动程序位于`drivers/leds/`中。
- en: 'As with GPIOs, LEDs are controlled through an interface in `sysfs`, in `/sys/class/leds`.
    The LEDs have names in the form `devicename:colour:function`, as shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与GPIO一样，LED通过`sysfs`中的接口进行控制，在`/sys/class/leds`中。LED的名称采用`devicename:colour:function`的形式，如下所示：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This shows one individual LED:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了一个单独的LED：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `brightness` file controls the brightness of the LED and can be a number
    between 0 (off) and `max_brightness` (fully on). If the LED doesn''t support intermediate
    brightness, any non-zero value turns it on and zero turns it off. The file `trigger`
    lists the events that trigger the LED to turn on. The list of triggers is implementation-dependent.
    Here is an example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`brightness`文件控制LED的亮度，可以是0（关闭）到`max_brightness`（完全打开）之间的数字。如果LED不支持中间亮度，则任何非零值都会打开它，零会关闭它。文件`trigger`列出了触发LED打开的事件。触发器列表因实现而异。这是一个例子：'
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The trigger currently selected is shown in square brackets. You can change
    it by writing one of the other triggers to the file. If you want to control the
    LED entirely through `brightness`, select `none`. If you set the trigger to `timer`,
    two extra files appear that allow you to set the on and off times in milliseconds:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当前选择的触发器显示在方括号中。您可以通过将其他触发器之一写入文件来更改它。如果您想完全通过“亮度”控制LED，请选择“none”。如果将触发器设置为“timer”，则会出现两个额外的文件，允许您以毫秒为单位设置开启和关闭时间：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the LED has on-chip timer hardware, the blinking takes place without interrupting
    the CPU.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果LED具有片上定时器硬件，则闪烁会在不中断CPU的情况下进行。
- en: I2C
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I2C
- en: I2C is a simple low speed 2-wire bus that is common on embedded boards, typically
    used to access peripherals which are not on the SoC board such as display controllers,
    camera sensors, GPIO extenders, and the like. There is a related standard known
    as SMBus (system management bus) that is found on PCs, that is used to access
    temperature and voltage sensors. SMBus is a subset of I2C.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: I2C是一种简单的低速2线总线，通常用于访问SoC板上没有的外围设备，例如显示控制器、摄像头传感器、GPIO扩展器等。还有一个相关的标准称为SMBus（系统管理总线），它在PC上发现，用于访问温度和电压传感器。SMBus是I2C的子集。
- en: I2C is a master-slave protocol, with the master being one or more host controllers
    on the SoC. Slaves have a 7-bit address assigned by the manufacturer – read the
    data sheet – allowing up to 128 nodes per bus, but 16 are reserved, so only 112
    nodes are allowed in practice. The bus speed is 100 KHz in standard mode, or up
    to 400 KHz in fast mode. The protocol allows read and write transactions between
    the master and slave of up to 32 bytes. Frequently, the first byte is used to
    specify a register on the peripheral and the remaining bytes are the data read
    from or written to that register.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: I2C是一种主从协议，主要是SoC上的一个或多个主控制器。从设备由制造商分配的7位地址 - 请阅读数据表 - 允许每个总线上最多128个节点，但保留了16个，因此实际上只允许112个节点。总线速度为标准模式下的100
    KHz，或者快速模式下的最高400 KHz。该协议允许主设备和从设备之间的读写事务最多达32个字节。通常，第一个字节用于指定外围设备上的寄存器，其余字节是从该寄存器读取或写入的数据。
- en: 'There is one device node for each host controller, for example, this SoC has
    four:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主控制器都有一个设备节点，例如，这个SoC有四个：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The device interface provides a series of `ioctl` commands that query the host
    controller and send `read` and `write` commands to I2C slaves. There is a package
    named `i2c-tools` which uses this interface to provide basic command-line tools
    to interact with I2C devices. The tools are as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 设备接口提供了一系列`ioctl`命令，用于查询主控制器并向I2C从设备发送`read`和`write`命令。有一个名为`i2c-tools`的软件包，它使用此接口提供基本的命令行工具来与I2C设备交互。工具如下：
- en: '`i2cdetect`: This lists the I2C adapters and probes the bus'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i2cdetect`：这会列出I2C适配器并探测总线'
- en: '`i2cdump`: This dumps data from all the registers of an I2C peripheral'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i2cdump`：这会从I2C外设的所有寄存器中转储数据'
- en: '`i2cget`: This reads data from an I2C slave'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i2cget`：这会从I2C从设备读取数据'
- en: '`i2cset`: This writes data to an I2C slave'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i2cset`：这将数据写入I2C从设备'
- en: 'The `i2c-tools` package is available in Buildroot and the Yocto Project, as
    well as most mainstream distributions. So long as you know the address and protocol
    of the slave, writing a user space program to talk to the device is straightforward:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2c-tools`软件包在Buildroot和Yocto Project中可用，以及大多数主流发行版。只要您知道从设备的地址和协议，编写一个用户空间程序来与设备通信就很简单： '
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that the header `i2c-dev.h` is the one from the `i2c-tools` package, not
    the one from the Linux kernel headers. The `i2c_smbus_read_word_data()` function
    is written inline in `i2c-dev.h`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，标头“i2c-dev.h”是来自“i2c-tools”软件包的标头，而不是来自Linux内核标头的标头。 `i2c_smbus_read_word_data（）`函数是在`i2c-dev.h`中内联编写的。
- en: There is more information about the Linux implementation of I2C in `Documentation/i2c/dev-interface`.
    The host controller drivers are in `drivers/i2c/busses`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有关I2C在`Documentation/i2c/dev-interface`中的Linux实现的更多信息。主控制器驱动程序位于`drivers/i2c/busses`中。
- en: SPI
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SPI
- en: The serial peripheral interface bus is similar to I2C, but is a lot faster,
    up to the low MHz. The interface uses four wires with separate send and receive
    lines which allows it to operate in full duplex. Each chip on the bus is selected
    with a dedicated chip select line. It is commonly used to connect to touchscreen
    sensors, display controllers, and serial NOR flash devices.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 串行外围接口总线类似于I2C，但速度更快，高达低MHz。该接口使用四根线，具有独立的发送和接收线，这使得它可以全双工操作。总线上的每个芯片都使用专用的芯片选择线进行选择。它通常用于连接触摸屏传感器、显示控制器和串行NOR闪存设备。
- en: 'As with I2C, it is a master-slave protocol, with most SoCs implementing one
    or more master host controllers. There is a generic SPI device driver which you
    can enable through the kernel configuration `CONFIG_SPI_SPIDEV`. It creates a
    device node for each SPI controller which allows you to access SPI chips from
    user space. The device nodes are named `spidev[bus].[chip select]`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与I2C一样，它是一种主从协议，大多数SoC实现了一个或多个主机控制器。有一个通用的SPI设备驱动程序，您可以通过内核配置`CONFIG_SPI_SPIDEV`启用它。它为每个SPI控制器创建一个设备节点，允许您从用户空间访问SPI芯片。设备节点的名称为`spidev[bus].[chip
    select]`。
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For examples of using the `spidev` interface, refer to the example code in `Documentation/spi`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用`spidev`接口的示例，请参考`Documentation/spi`中的示例代码。
- en: Writing a kernel device driver
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写内核设备驱动程序
- en: Eventually, when you have exhausted all the user-space options above, you will
    find yourself having to write a device driver to access a piece of hardware attached
    to your device. While this is not the time or place to delve into details, it
    is worth considering the options. Character drivers are the most flexible and
    should cover 90% of all your needs; network devices apply if you are working with
    a network interface, and block devices are for mass storage. The task of writing
    a kernel driver is complex and beyond the scope of this book. There are some references
    at the end that will help you on your way. In this section, I want to outline
    the options available for interacting with a driver—a topic not normally covered—and
    show you the basic bones of a driver.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，当您耗尽了上述所有用户空间选项时，您会发现自己不得不编写一个设备驱动程序来访问连接到您的设备的硬件。虽然现在不是深入细节的时候，但值得考虑一下选择。字符驱动程序是最灵活的，应该可以满足90%的需求；如果您正在使用网络接口，网络设备也适用；块设备用于大容量存储。编写内核驱动程序的任务是复杂的，超出了本书的范围。在本节末尾有一些参考资料，可以帮助您一路前行。在本节中，我想概述与驱动程序交互的可用选项——这通常不是涵盖的主题——并向您展示驱动程序的基本结构。
- en: Designing a character device interface
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计字符设备接口
- en: 'The main character device interface is based on a stream of bytes, as you would
    have with a serial port. However, many devices don''t fit this description: a
    controller for a robot arm needs functions to move and rotate each joint, for
    example. Luckily, there are other ways to communicate with device drivers that
    just `read(2)` and `write(2)`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的字符设备接口基于字节流，就像串口一样。然而，许多设备并不符合这个描述：例如，机器人手臂的控制器需要移动和旋转每个关节的功能。幸运的是，与设备驱动程序进行通信的其他方法不仅仅是`read(2)`和`write(2)`。
- en: '`ioctl`: The `ioctl` function allows you to pass two arguments to your driver
    which can have any meaning you like. By convention, the first argument is a command
    which selects one of several functions in your driver, and the second is a pointer
    to a structure which serves as a container for the input and output parameters.
    This is a blank canvas that allows you to design any program interface you like
    and it is pretty common when the driver and application are closely linked and
    written by the same team. However, `ioctl` is deprecated in the kernel and you
    will find it hard to get any drivers with new uses of `ioctl` accepted upstream.
    The kernel maintainers dislike `ioctl` because it makes kernel code and application
    code too interdependent, and it is hard to keep both of them in step across kernel
    versions and architectures.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ioctl`：`ioctl`函数允许您向驱动程序传递两个参数，这两个参数可以有任何您喜欢的含义。按照惯例，第一个参数是一个命令，用于选择驱动程序中的几个函数中的一个，第二个参数是一个指向结构体的指针，该结构体用作输入和输出参数的容器。这是一个空白画布，允许您设计任何您喜欢的程序接口，当驱动程序和应用程序紧密链接并由同一团队编写时，这是非常常见的。然而，在内核中，`ioctl`已经被弃用，您会发现很难让任何具有新`ioctl`用法的驱动程序被上游接受。内核维护人员不喜欢`ioctl`，因为它使内核代码和应用程序代码过于相互依赖，并且很难在内核版本和架构之间保持两者同步。'
- en: '`sysfs`: This is the preferred way now, a good example being the GPIO interface
    described earlier. The advantages are that it is self-documenting, so long as
    you choose descriptive names for the files. It is also scriptable because the
    file contents are ASCII strings. On the other hand, the requirement for each file
    to contain a single value makes it hard to achieve atomicity if you need to change
    more than one value at a time. For example, if you want to set two values and
    then initiate an action, you would need to write to three files: two for the inputs
    and a third to trigger the action. Even then, there is no guarantee that the other
    two files have not been changed by someone else. Conversely, `ioctl` passes all
    its arguments in a structure in a single function call.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sysfs`：这是现在的首选方式，一个很好的例子是之前描述的GPIO接口。其优点是它是自我记录的，只要您为文件选择描述性名称。它也是可脚本化的，因为文件内容是ASCII字符串。另一方面，每个文件要求包含一个单一值，这使得如果您需要同时更改多个值，就很难实现原子性。例如，如果您想设置两个值然后启动一个操作，您需要写入三个文件：两个用于输入，第三个用于触发操作。即使这样，也不能保证其他两个文件没有被其他人更改。相反，`ioctl`通过单个函数调用中的结构传递所有参数。'
- en: '`mmap`: You can get direct access to kernel buffers and hardware registers
    by mapping kernel memory into user-space, bypassing the kernel. You may still
    need some kernel code to handle interrupts and DMA. There is a subsystem that
    encapsulates this idea, known as `uio`, short for user I/O. There is more documentation
    in `Documentation/DocBook/uio-howto`, and there are example drivers in `drivers/uio`.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mmap`：您可以通过将内核内存映射到用户空间来直接访问内核缓冲区和硬件寄存器，绕过内核。您可能仍然需要一些内核代码来处理中断和DMA。有一个封装这个想法的子系统，称为`uio`，即用户I/O。在`Documentation/DocBook/uio-howto`中有更多文档，`drivers/uio`中有示例驱动程序。'
- en: '`sigio`: You can send a signal from a driver using the kernel function `kill_fasync()`
    to notify applications of an event such as input becoming ready or an interrupt
    being received. By convention, signal SIGIO is used, but it could be anyone. You
    can see some examples in the UIO driver, `drivers/uio/uio.c`, and in the RTC driver,
    `drivers/char/rtc.c`. The main problem is that it is difficult to write reliable
    signal handlers and so it remains a little-used facility.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sigio`：您可以使用内核函数`kill_fasync()`从驱动程序发送信号，以通知应用程序事件，例如输入准备就绪或接收到中断。按照惯例，使用信号SIGIO，但它可以是任何人。您可以在UIO驱动程序`drivers/uio/uio.c`和RTC驱动程序`drivers/char/rtc.c`中看到一些示例。主要问题是编写可靠的信号处理程序很困难，因此它仍然是一个很少使用的设施。'
- en: '`debugfs`: This is another pseudo filesystem that represents kernel data as
    files and directories, similar to `proc` and `sysfs`. The main distinction is
    that `debugfs` must not contain information that is needed for the normal operation
    of the system; it is for debug and trace information only. It is mounted as `mount
    -t debugfs debug /sys/kernel/debug`.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debugfs`：这是另一个伪文件系统，它将内核数据表示为文件和目录，类似于`proc`和`sysfs`。主要区别在于`debugfs`不得包含系统正常操作所需的信息；它仅用于调试和跟踪信息。它被挂载为`mount
    -t debugfs debug /sys/kernel/debug`。'
- en: There is a good description of `debugfs` in the kernel documentation, `Documentation/filesystems/debugfs.txt`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 内核文档中有关`debugfs`的良好描述，`Documentation/filesystems/debugfs.txt`。
- en: '`proc`: The `proc` filesystem is deprecated for all new code unless it relates
    to processes, which was the original intended purpose for the filesystem. However,
    the you can use `proc` to publish any information you choose. And, unlike `sysfs`
    and `debugfs`, it is available to non-GPL modules.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proc`：`proc`文件系统已被弃用，除非它与进程有关，这是文件系统的最初预期目的。但是，您可以使用`proc`发布您选择的任何信息。并且，与`sysfs`和`debugfs`不同，它可用于非GPL模块。'
- en: '`netlink`: This is a socket protocol family. `AF_NETLINK` creates a socket
    that links kernel space to user-space. It was originally created so that network
    tools could communicate with the Linux network code to access the routing tables
    and other details. It is also used by udev to pass events from the kernel to the
    udev daemon. It is very rarely used in general device drivers.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`netlink`：这是一个套接字协议族。`AF_NETLINK`创建一个将内核空间链接到用户空间的套接字。最初创建它是为了使网络工具能够与Linux网络代码通信，以访问路由表和其他详细信息。udev也使用它将事件从内核传递给udev守护程序。一般设备驱动程序中很少使用它。'
- en: There are many examples of all of the preceding filesystem in the kernel source
    code and you can design really interesting interfaces to your driver code. The
    only universal rule is the *principle of least astonishment*. In other words,
    application writers using your driver should find that everything works in a logical
    way with no quirks or oddities.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 内核源代码中有许多先前文件系统的示例，您可以为驱动程序代码设计非常有趣的接口。唯一的普遍规则是*最少惊讶原则*。换句话说，使用您的驱动程序的应用程序编写人员应该发现一切都以逻辑方式工作，没有怪癖或奇怪之处。
- en: Anatomy of a device driver
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备驱动程序的解剖
- en: It's time to draw some threads together by looking at the code for a simple
    device driver.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过查看简单设备驱动程序的代码来汇总一些线索了。
- en: 'The source code is provided for a device driver named `dummy` which creates
    four devices that are accessed through `/dev/dummy0` to `/dev/dummy3`. This is
    the complete code for the driver:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了名为`dummy`的设备驱动程序的源代码，该驱动程序创建了四个通过`/dev/dummy0`到`/dev/dummy3`访问的设备。这是驱动程序的完整代码：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: At the end of the code, the macros `module_init` and `module_exit` specify the
    functions to be called when the module is loaded and unloaded. The other three
    add some basic information about the module which can be retrieved from the compiled
    kernel module using the `modinfo` command.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 代码末尾的宏`module_init`和`module_exit`指定了在加载和卸载模块时要调用的函数。其他三个添加了有关模块的一些基本信息，可以使用`modinfo`命令从编译的内核模块中检索。
- en: When the module is loaded, the `dummy_init()` function is called.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 模块加载时，将调用`dummy_init()`函数。
- en: You can see the point at which it becomes a character device by calling `register_chrdev`,
    passing a pointer to `struct file_operations` containing pointers to the four
    functions that the driver implements. While `register_chrdev` tells the kernel
    that there is a driver with a major number of 42, it doesn't say anything about
    the type of driver, and so it will not create an entry in `/sys/class`. Without
    an entry in `/sys/class`, the device manager cannot create device nodes. So, the
    next few lines of code create a device class, `dummy`, and four devices of that
    class called `dummy0` to `dummy3`. The result is the `/sys/class/dummy` directory,
    containing the `dummy0` to `dummy3` subdirectories, each containing a file, `dev`,
    with the major and minor numbers of the device. This is all that a device manager
    needs to create device nodes, `/dev/dummy0` to `/dev/dummy3`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`register_chrdev`可以看到它何时成为一个字符设备，传递一个指向包含驱动程序实现的四个函数指针的`struct file_operations`指针。虽然`register_chrdev`告诉内核有一个主编号为42的驱动程序，但它并没有说明驱动程序的类型，因此它不会在`/sys/class`中创建条目。没有在`/sys/class`中的条目，设备管理器无法创建设备节点。因此，代码的下几行创建了一个设备类`dummy`，以及该类的四个名为`dummy0`到`dummy3`的设备。结果是`/sys/class/dummy`目录，其中包含`dummy0`到`dummy3`子目录，每个子目录中都包含一个名为`dev`的文件，其中包含设备的主要和次要编号。这就是设备管理器创建设备节点`/dev/dummy0`到`/dev/dummy3`所需的全部内容。
- en: The `exit` function has to release the resources claimed by the `init` function
    which, here, means freeing up the device class and major number.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit`函数必须释放`init`函数声明的资源，这里指的是释放设备类和主要编号。'
- en: 'The file operation for this driver are implemented by `dummy_open()`, `dummy_read()`,
    `dummy_write()`, and `dummy_release()`, and are called when a user space program
    calls `open(2)`, `read(2)`, `write(2)`, and `close(2)`. They just print a kernel
    message so that you can see that they were called. You can demonstrate this from
    the command line using the `echo` command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该驱动程序的文件操作由`dummy_open()`，`dummy_read()`，`dummy_write()`和`dummy_release()`实现，并在用户空间程序调用`open(2)`，`read(2)`，`write(2)`和`close(2)`时调用。
    它们只是打印内核消息，以便您可以看到它们被调用。 您可以使用`echo`命令从命令行演示这一点：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this case, the messages appear because I was logged on to the console, and
    kernel messages are printed to the console by default.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，消息出现是因为我已登录到控制台，默认情况下内核消息会打印到控制台。
- en: The full source code for this driver is less than 100 lines, but it is enough
    to illustrate how the linkage between a device node and driver code works, how
    the device class is created, allowing a device manager to create device nodes
    automatically when the driver is loaded, and how data is moved between user and
    kernel spaces. Next, you need to build it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 该驱动程序的完整源代码不到100行，但足以说明设备节点和驱动程序代码之间的链接方式，说明设备类是如何创建的，允许设备管理器在加载驱动程序时自动创建设备节点，以及数据如何在用户空间和内核空间之间移动。
    接下来，您需要构建它。
- en: Compile and load
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译和加载
- en: At this point you have some driver code that you want to compile and test on
    your target system. You can copy it into the kernel source tree and modify makefiles
    to build it, or you can compile it as a module out of tree. Let's start by building
    out of tree.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您有一些驱动程序代码，希望在目标系统上进行编译和测试。 您可以将其复制到内核源树中并修改makefile以构建它，或者您可以将其编译为树外模块。
    让我们首先从树外构建开始。
- en: 'You need a simple makefile which uses the kernel build system to do the hard
    work:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个简单的makefile，该makefile使用内核构建系统来完成艰苦的工作：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Set `LINUXDIR` to the directory of the kernel for your target device that you
    will be running the module on. The code `obj-m := dummy.o` will invoke the kernel
    build rule to take the source file, `dummy.c` and create kernel module, `dummy.ko`.
    Note that kernel modules are not binary compatible between kernel releases and
    configurations, the module will only load on the kernel it was compiled with.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将`LINUXDIR`设置为您将在目标设备上运行模块的内核目录。 代码`obj-m：= dummy.o`将调用内核构建规则，以获取源文件`dummy.c`并创建内核模块`dummy.ko`。
    请注意，内核模块在内核发布和配置之间不具有二进制兼容性，该模块只能在其编译的内核上加载。
- en: The end result of the build is the kernel `dummy.ko` which you can copy to the
    target and load as shown in the next section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的最终结果是内核`dummy.ko`，您可以将其复制到目标并按照下一节中所示加载。
- en: 'If you want to build a driver in the kernel source tree, the procedure is quite
    simple. Choose a directory appropriate to the type of driver you have. The driver
    is a basic character device, so I would put `dummy.c` in `drivers/char`. Then,
    edit the makefile in that directory and add a line to build the driver unconditionally
    as a module, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在内核源树中构建驱动程序，该过程非常简单。 选择适合您的驱动程序类型的目录。 该驱动程序是基本字符设备，因此我将`dummy.c`放在`drivers/char`中。
    然后，编辑该目录中的makefile，并添加一行以无条件地构建驱动程序作为模块，如下所示：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Or add the following line this to build it unconditionally as a built-in:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 或者将以下行添加到无条件构建为内置：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you want to make the driver optional, you can add a menu option to the `Kconfig`
    file and make the compilation conditional on the configuration option, as I described
    in [Chapter 4](ch04.html "Chapter 4. Porting and Configuring the Kernel"), *Porting
    and Configuring the Kernel*, when describing the kernel configuration.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使驱动程序可选，可以在`Kconfig`文件中添加菜单选项，并根据配置选项进行条件编译，就像我在[第4章](ch04.html "第4章。移植和配置内核")中描述的那样，*移植和配置内核*，描述内核配置时。
- en: Loading kernel modules
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载内核模块
- en: 'You can load, unload and list modules using the simple `insmod`, `lsmod`, and
    `rmmod` commands. Here they are shown loading the dummy driver:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用简单的`insmod`，`lsmod`和`rmmod`命令加载，卸载和列出模块。 这里显示了加载虚拟驱动程序：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If the module is placed in a subdirectory in `/lib/modules/<kernel release>`,
    as in the example, you can create a modules dependency database using the command
    `depmod`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块放置在`/lib/modules/<kernel release>`中的子目录中，例如示例中，可以使用`depmod`命令创建模块依赖数据库：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The information in the `module.*` files is used by the command `modprobe` to
    locate a module by name rather than the full path. `modprobe` has many other features
    which are described in the manual.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`module.*`文件中的信息由`modprobe`命令使用，以按名称而不是完整路径定位模块。 `modprobe`还具有许多其他功能，这些功能在手册中有描述。'
- en: The module dependency information is also used by device managers, `udev` in
    particular. When new hardware is detected, for example a new USB device, the `udevd`
    daemon is alerted and passed the vendor, and product IDs are read from the hardware.
    `udevd` scans the module dependency files looking for a module that has registered
    those IDs. If one is found, it is loaded using `modprobe`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 模块依赖信息也被设备管理器使用，特别是`udev`。 例如，当检测到新硬件时，例如新的USB设备，`udevd`守护程序会被警报，并从硬件中读取供应商和产品ID。
    `udevd`扫描模块依赖文件，寻找已注册这些ID的模块。 如果找到一个，它将使用`modprobe`加载。
- en: Discovering hardware configuration
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现硬件配置
- en: The dummy driver demonstrates the structure of a device driver, but it lacks
    interaction with real hardware since it only manipulates memory structures. Device
    drivers are usually written to interact with hardware and part of that is being
    able to discover the hardware in the first place, bearing in mind that it may
    be at different addresses in different configurations.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟驱动程序演示了设备驱动程序的结构，但它缺乏与真实硬件的交互，因为它只操作内存结构。 设备驱动程序通常用于与硬件交互，其中的一部分是能够首先发现硬件，要记住的是在不同配置中它可能位于不同的地址。
- en: In some cases, the hardware provides the information itself. Devices on a discoverable
    bus such as PCI or USB have a query mode which returns resource requirements and
    a unique identifier. The kernel matches the identifier and possibly other characteristics
    with the device drivers, and marries them up.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，硬件本身提供信息。可发现总线上的设备（如PCI或USB）具有查询模式，该模式返回资源需求和唯一标识符。内核将标识符和可能的其他特征与设备驱动程序进行匹配，并将它们配对。
- en: However, most of the hardware blocks on an SoC do not have such identifiers.
    You have to provide the information yourself in the form of a device tree or as
    C structures known as platform data.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数SoC上的硬件块都没有这样的标识符。您必须以设备树或称为平台数据的C结构的形式提供信息。
- en: 'In the standard driver model for Linux, device drivers register themselves
    with the appropriate subsystem: PCI, USB, open firmware (device tree), platform
    device, and so on. The registration includes an identifier and a callback function
    called a probe function that is called if there is a match between the ID of the
    hardware and the ID of the driver. For PCI and USB, the ID is based on the vendor
    and the product IDs of the devices, for device tree and platform devices, it is
    a name (an ASCII string).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux的标准驱动程序模型中，设备驱动程序会向适当的子系统注册自己：PCI、USB、开放固件（设备树）、平台设备等。注册包括标识符和称为探测函数的回调函数，如果硬件的ID与驱动程序的ID匹配，则会调用该函数。对于PCI和USB，ID基于设备的供应商和产品ID，对于设备树和平台设备，它是一个名称（ASCII字符串）。
- en: Device trees
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备树
- en: I gave you an introduction to device trees in [Chapter 3](ch03.html "Chapter 3. All
    About Bootloaders"), *All About Bootloaders*. Here, I want to show you how the
    Linux device drivers hook up with that information.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第3章](ch03.html "第3章。关于引导程序的一切")中向您介绍了设备树，*关于引导程序的一切*。在这里，我想向您展示Linux设备驱动程序如何与这些信息连接。
- en: 'As an example, I will use the ARM Versatile board, `arch/arm/boot/dts/versatile-ab.dts`,
    for which the Ethernet adapter is defined here:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我将使用ARM Versatile板，`arch/arm/boot/dts/versatile-ab.dts`，其中以太网适配器在此处定义：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Platform data
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台数据
- en: In the absence of device tree support, there is a fallback method of describing
    hardware using C structures, known as platform data.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有设备树支持的情况下，还有一种使用C结构描述硬件的备用方法，称为平台数据。
- en: 'Each piece of hardware is described by `struct platform_device`, which has
    a name and a pointer to an array of resources. The type of the resource is determined
    by flags, which include the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 每个硬件都由`struct platform_device`描述，其中包含名称和资源数组的指针。资源的类型由标志确定，其中包括以下内容：
- en: '`IORESOURCE_MEM`: The physical address of a region of memory'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IORESOURCE_MEM`：内存区域的物理地址'
- en: '`IORESOURCE_IO`: The physical address or port number of IO registers'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IORESOURCE_IO`：IO寄存器的物理地址或端口号'
- en: '`IORESOURCE_IRQ`: The interrupt number'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IORESOURCE_IRQ`：中断号'
- en: 'Here is an example of the platform data for an Ethernet controller taken from
    `arch/arm/mach-versatile/core.c`, which has been edited for clarity:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`arch/arm/mach-versatile/core.c`中获取的以太网控制器的平台数据示例，已经编辑以提高清晰度：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It has a memory area of 64 KiB and an interrupt. The platform data has to be
    registered with the kernel, usually when the board is initialized:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个64 KiB的内存区域和一个中断。平台数据必须在初始化板时向内核注册：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Linking hardware with device drivers
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将硬件与设备驱动程序连接起来
- en: 'You have seen in the preceding section how an Ethernet adapter is described
    using a device tree and using platform data. The corresponding driver code is
    in `drivers/net/ethernet/smsc/smc91x.c` and it works with both the device tree
    and platform data. Here is the initialization code, once again edited for clarity:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，您已经看到了以设备树和平台数据描述以太网适配器的方式。相应的驱动程序代码位于`drivers/net/ethernet/smsc/smc91x.c`中，它可以与设备树和平台数据一起使用。以下是初始化代码，再次编辑以提高清晰度：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When the driver is initialized, it calls `platform_driver_register()`, pointing
    to `struct platform_driver`, in which there is a callback to a probe function,
    a driver name, `smc91x,` and a pointer to `struct of_device_id`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当驱动程序初始化时，它调用`platform_driver_register()`，指向`struct platform_driver`，其中包含对探测函数的回调，驱动程序名称`smc91x`，以及对`struct
    of_device_id`的指针。
- en: If this driver has been configured by the device tree, the kernel will look
    for a match between the `compatible` property in the device tree node and the
    string pointed to by the compatible structure element. For each match, it calls
    the `probe` function.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此驱动程序已由设备树配置，内核将在设备树节点中的`compatible`属性和兼容结构元素指向的字符串之间寻找匹配项。对于每个匹配项，它都会调用`probe`函数。
- en: On the other hand, if it was configured through platform data, the `probe` function
    will be called for each match on the string pointed to by `driver.name`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果通过平台数据配置，`probe`函数将针对`driver.name`指向的每个匹配项进行调用。
- en: 'The `probe` function extracts information about the interface:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`probe`函数提取有关接口的信息：'
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The calls t`o platform_get_resource()` extract the memory and `irq` information
    from either the device tree or the platform data. It is up to the driver to map
    the memory and install the interrupt handler. The third parameter, which is zero
    in both of the previous cases, comes into play if there is more than one resource
    of that particular type.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`platform_get_resource()`从设备树或平台数据中提取内存和`irq`信息。驱动程序负责映射内存并安装中断处理程序。第三个参数在前面两种情况下都是零，如果有多个特定类型的资源，则会起作用。
- en: 'Device trees allow you to configure more than just basic memory ranges and
    interrupts, however. There is a section of code in the `probe` function that extracts
    optional parameters from the device tree. In this snippet, it gets the `register-io-width`
    property:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树允许您配置的不仅仅是基本内存范围和中断。在`probe`函数中有一段代码，用于从设备树中提取可选参数。在这个片段中，它获取了`register-io-width`属性：
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For most drivers, specific bindings are documented in `Documentation/devicetree/bindings`.
    For this particular driver, the information is in `Documentation/devicetree/bindings/net/smsc911x.txt`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数驱动程序，特定的绑定都记录在`Documentation/devicetree/bindings`中。对于这个特定的驱动程序，信息在`Documentation/devicetree/bindings/net/smsc911x.txt`中。
- en: The main thing to remember here is that drivers should register a `probe` function
    and enough information for the kernel to call the `probe` as it finds matches
    with the hardware it knows about. The linkage between the hardware described by
    the device tree and the device driver is through the `compatible` property. The
    linkage between platform data and a driver is through the name.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要记住的主要事情是，驱动程序应该注册一个`probe`函数和足够的信息，以便内核在找到与其了解的硬件匹配时调用`probe`。设备树描述的硬件与设备驱动程序之间的链接是通过`compatible`属性实现的。平台数据与驱动程序之间的链接是通过名称实现的。
- en: Additional reading
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外阅读
- en: 'The following resources have further information about the topics introduced
    in this chapter:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源提供了关于本章介绍的主题的更多信息：
- en: '*Linux Device Drivers, 4th edition*, by *Jessica McKellar*, *Alessandro Rubini*,
    *Jonathan Corbet*, and *Greg Kroah-Hartman*. This is not published at the time
    of writing, but if it is as good as the predecessor, it will be a good choice.
    However, the 3rd edition is too out of date to recommend.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux Device Drivers, 4th edition*，作者*Jessica McKellar*，*Alessandro Rubini*，*Jonathan
    Corbet*和*Greg Kroah-Hartman*。在撰写本文时尚未出版，但如果它像前作一样好，那将是一个不错的选择。但是，第三版已经过时，不建议阅读。'
- en: '*Linux Kernel Development, 3rd edition* by *Robert Love*, *Addison-Wesley*
    Professional; (July 2, 2010) ISBN-10: 0672329468'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux Kernel Development, 3rd edition*，作者*Robert Love*，*Addison-Wesley* Professional;
    (July 2, 2010) ISBN-10: 0672329468'
- en: '*Linux Weekly News*, [www.lwn.net](https://www.lwn.net).'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux Weekly News*，[www.lwn.net](https://www.lwn.net)。'
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Device drivers have the job of handling devices, usually physical hardware
    but sometimes virtual interfaces, and presenting it to higher levels in a consistent
    and useful way. Linux device drivers fall into three broad categories: the character,
    the block, and the network. Of the three, the character driver interface is the
    most flexible and therefore, the most common. Linux drivers fit into a framework
    known as the driver model, which is exposed through `sysfs`. Pretty much the entire
    state of the devices and drivers is visible in `/sys`.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序的工作是处理设备，通常是物理硬件，但有时也是虚拟接口，并以一种一致和有用的方式呈现给更高级别。Linux设备驱动程序分为三大类：字符、块和网络。在这三种中，字符驱动程序接口是最灵活的，因此也是最常见的。Linux驱动程序适用于一个称为驱动模型的框架，通过`sysfs`公开。几乎所有设备和驱动程序的状态都可以在`/sys`中看到。
- en: Each embedded system has its own unique set of hardware interfaces and requirements.
    Linux provides drivers for most standard interfaces, and by selecting the right
    kernel configuration, you can get the device operational very quickly. That leaves
    you with the non-standard components for which you will have to add your own device
    support.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 每个嵌入式系统都有自己独特的硬件接口和要求。Linux为大多数标准接口提供了驱动程序，通过选择正确的内核配置，您可以使设备非常快速地运行起来。这样，您就可以处理非标准组件，需要添加自己的设备支持。
- en: In some cases, you can sidestep the issue by using generic drivers for GPIO,
    I2C, and so on, and write user space code to do the work. I recommend this as
    a starting point as it gives you the chance to get familiar with the hardware
    without writing kernel code. Writing kernel drivers is not particularly difficult
    but, if you do, you need to code carefully so as to not compromise the stability
    of the system.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可以通过使用通用的GPIO、I2C等驱动程序并编写用户空间代码来避开问题。我建议这作为一个起点，因为这样可以让您有机会熟悉硬件，而不必编写内核代码。编写内核驱动程序并不特别困难，但是如果您这样做，需要小心编码，以免影响系统的稳定性。
- en: 'I have talked about writing kernel driver code: if you go down that route,
    you will inevitably want to know how to check whether or not it is working correctly
    and detect any bugs. I will cover that topic in [Chapter 12](ch12.html "Chapter 12. Debugging
    with GDB"), *Debugging with GDB*.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经谈到了编写内核驱动程序代码：如果您选择这条路线，您将不可避免地想知道如何检查它是否正常工作并检测任何错误。我将在[第12章](ch12.html
    "Chapter 12. Debugging with GDB")中涵盖这个主题，*使用GDB进行调试*。
- en: The next chapter is all about user space initialization and the different options
    you have for the `init` program, from the simple BusyBox to the complex systemd.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将全面介绍用户空间初始化以及`init`程序的不同选项，从简单的BusyBox到复杂的systemd。
