["```\nstatic struct platform_driver mypdrv = { \n    .probe    = my_pdrv_probe, \n    .remove   = my_pdrv_remove, \n    .driver   = { \n    .name     = \"my_platform_driver\", \n    .owner    = THIS_MODULE, \n    }, \n}; \n```", "```\nstatic int my_pdrv_probe(struct platform_device *pdev) \n```", "```\nstatic int my_pdrv_remove(struct platform_device *pdev) \n```", "```\nret = platform_driver_probe(&mypdrv, my_pdrv_probe); \n```", "```\n#include <linux/module.h> \n#include <linux/kernel.h> \n#include <linux/init.h> \n#include <linux/platform_device.h> \n\nstatic int my_pdrv_probe (struct platform_device *pdev){ \n    pr_info(\"Hello! device probed!\\n\"); \n    return 0; \n} \n\nstatic void my_pdrv_remove(struct platform_device *pdev){ \n    pr_info(\"good bye reader!\\n\"); \n} \n\nstatic struct platform_driver mypdrv = { \n    .probe          = my_pdrv_probe, \n    .remove         = my_pdrv_remove, \n    .driver = { \n            .name  = KBUILD_MODNAME, \n            .owner = THIS_MODULE, \n    }, \n}; \n\nstatic int __init my_drv_init(void) \n{ \n    pr_info(\"Hello Guy\\n\"); \n\n    /* Registering with Kernel */ \n    platform_driver_register(&mypdrv); \n    return 0; \n} \n\nstatic void __exit my_pdrv_remove (void) \n{ \n    Pr_info(\"Good bye Guy\\n\"); \n\n    /* Unregistering from Kernel */ \n    platform_driver_unregister(&my_driver); \n} \n\nmodule_init(my_drv_init); \nmodule_exit(my_pdrv_remove); \n\nMODULE_LICENSE(\n\n\"GPL\n\n\");\n\nMODULE_AUTHOR(\n\n\"John Madieu\n\n\");\n\nMODULE_DESCRIPTION(\n\n\"My platform Hello World module\n\n\");\n\n```", "```\n/* \n * module_platform_driver() - Helper macro for drivers that don't \n * do anything special in module init/exit. This eliminates a lot \n * of boilerplate.  Each module may only use this macro once, and \n * calling it replaces module_init() and module_exit() \n */ \n#define module_platform_driver(__platform_driver) \\ \nmodule_driver(__platform_driver, platform_driver_register, \\ \nplatform_driver_unregister) \n```", "```\n\n[...] \nstatic int my_driver_probe (struct platform_device *pdev){ \n    [...] \n} \n\nstatic void my_driver_remove(struct platform_device *pdev){ \n    [...] \n} \n\nstatic struct platform_drivermy_driver = { \n    [...] \n}; \nmodule_platform_driver(my_driver); \n```", "```\nstruct platform_device { \n   const char *name; \n   u32 id; \n   struct device dev; \n   u32 num_resources; \n   struct resource *resource; \n}; \n```", "```\n#define IORESOURCE_IO  0x00000100  /* PCI/ISA I/O ports */ \n#define IORESOURCE_MEM 0x00000200  /* Memory regions */ \n#define IORESOURCE_REG 0x00000300  /* Register offsets */ \n#define IORESOURCE_IRQ 0x00000400  /* IRQ line */ \n#define IORESOURCE_DMA 0x00000800  /* DMA channels */ \n#define IORESOURCE_BUS 0x00001000  /* Bus */ \n```", "```\nstruct resource { \n        resource_size_t start; \n        resource_size_t end; \n        const char *name; \n        unsigned long flags; \n    }; \n```", "```\nint probe(struct platform_device *pdev); \n```", "```\nstruct resource *platform_get_resource(structplatform_device *dev, \n                    unsigned int type, unsigned int num); \n```", "```\nstatic int my_driver_probe(struct platform_device *pdev) \n{ \nstruct my_gpios *my_gpio_pdata = \n                   (struct my_gpios*)dev_get_platdata(&pdev->dev); \n\n    int rgpio = my_gpio_pdata->reset_gpio; \n    int lgpio = my_gpio_pdata->led_gpio; \n\n    struct resource *res1, *res2; \n    void *reg1, *reg2; \n    int irqnum; \n\n    res1 = platform_get_resource(pdev, IORESSOURCE_MEM, 0); \n    if((!res1)){ \n        pr_err(\" First Resource not available\"); \n        return -1; \n    } \n    res2 = platform_get_resource(pdev, IORESSOURCE_MEM, 1); \n    if((!res2)){ \n        pr_err(\" Second Resource not available\"); \n        return -1; \n    } \n\n    /* extract the irq */ \n    irqnum = platform_get_irq(pdev, 0); \n    Pr_info(\"\\n IRQ number of Device: %d\\n\", irqnum); \n\n    /* \n     * At this step, we can use gpio_request, on gpio, \n     * request_irq on irqnum and ioremap() on reg1 and reg2\\. \n     * ioremap() is discussed in chapter 11, Kernel Memory Management  \n     */ \n    [...] \n    return 0; \n} \n```", "```\n/* \n * Other data than irq or memory must be embedded in a structure \n * and passed to \"platform_device.device.platform_data\" \n */ \nstruct my_gpios { \n    int reset_gpio; \n    int led_gpio; \n}; \n\n/*our platform data*/ \nstatic struct my_gpiosneeded_gpios = { \n    .reset_gpio = 47, \n    .led_gpio   = 41, \n}; \n\n/* Our resource array */ \nstatic struct resource needed_resources[] = { \n   [0] = { /* The first memory region */ \n         .start = JZ4740_UDC_BASE_ADDR, \n         .end   = JZ4740_UDC_BASE_ADDR + 0x10000 - 1, \n         .flags = IORESOURCE_MEM, \n         .name  = \"mem1\", \n   }, \n   [1] = { \n         .start = JZ4740_UDC_BASE_ADDR2, \n         .end   = JZ4740_UDC_BASE_ADDR2 + 0x10000 -1, \n         .flags = IORESOURCE_MEM, \n         .name  = \"mem2\", \n   }, \n   [2] = { \n         .start = JZ4740_IRQ_UDC, \n         .end   = JZ4740_IRQ_UDC, \n         .flags = IORESOURCE_IRQ, \n         .name  = \"mc\", \n   }, \n}; \n\nstatic struct platform_devicemy_device = { \n    .name = \"my-platform-device\", \n    .id   = 0, \n    .dev  = { \n        .platform_data      = &needed_gpios, \n    }, \n    .resource              = needed_resources, \n    .num_resources = ARRY_SIZE(needed_resources), \n}; \nplatform_device_register(&my_device); \n```", "```\nvoid *dev_get_platdata(const struct device *dev) \nstruct my_gpios *picked_gpios = dev_get_platdata(&pdev->dev); \n```", "```\nstatic struct platform_device my_device = { \n        .name                   = \"my_drv_name\", \n        .id                     = 0, \n        .dev.platform_data      = &my_device_pdata, \n        .resource              = jz4740_udc_resources, \n        .num_resources         = ARRY_SIZE(jz4740_udc_resources), \n}; \nplatform_device_register(&my_device); \n\n```", "```\n#define MODULE_DEVICE_TABLE(type, name) \n```", "```\nstatic int platform_match(struct device *dev, struct device_driver *drv) \n{ \n   struct platform_device *pdev = to_platform_device(dev); \n   struct platform_driver *pdrv = to_platform_driver(drv); \n\n   /* When driver_override is set, only bind to the matching driver */ \n   if (pdev->driver_override) \n         return !strcmp(pdev->driver_override, drv->name); \n\n   /* Attempt an OF style match first */ \n   if (of_driver_match_device(dev, drv)) \n         return 1; \n\n   /* Then try ACPI style match */ \n   if (acpi_driver_match_device(dev, drv)) \n         return 1; \n\n   /* Then try to match against the id table */ \n   if (pdrv->id_table) \n         return platform_match_id(pdrv->id_table, pdev) != NULL; \n\n   /* fall-back to driver name match */ \n   return (strcmp(pdev->name, drv->name) == 0); \n} \n```", "```\nstatic const struct platform_device_id *platform_match_id( \n                        const struct platform_device_id *id, \n                        struct platform_device *pdev) \n{ \n        while (id->name[0]) { \n                if (strcmp(pdev->name, id->name) == 0) { \n                        pdev->id_entry = id; \n                        return id; \n                } \n                id++; \n        } \n        return NULL; \n} \n```", "```\nstruct device_driver { \n        const char *name; \n        [...] \n        const struct of_device_id       *of_match_table; \n        const struct acpi_device_id     *acpi_match_table; \n}; \n```", "```\nstruct platform_device_id { \n   char name[PLATFORM_NAME_SIZE]; \n   kernel_ulong_t driver_data; \n}; \n```", "```\nstatic const struct platform_device_id imx_uart_devtype[] = { \n        { \n              .name = \"imx1-uart\", \n              .driver_data = (kernel_ulong_t) &imx_uart_devdata[IMX1_UART], \n        }, { \n              .name = \"imx21-uart\", \n              .driver_data = (kernel_ulong_t) &imx_uart_devdata[IMX21_UART], \n        }, { \n              .name = \"imx6q-uart\", \n              .driver_data = (kernel_ulong_t) &imx_uart_devdata[IMX6Q_UART], \n        }, { \n                /* sentinel */ \n        } \n}; \n```", "```\nstatic const struct platform_device_id *platform_match_id( \n        const struct platform_device_id *id, \n        struct platform_device *pdev) \n{ \n    while (id->name[0]) { \n        if (strcmp(pdev->name, id->name) == 0) { \n            pdev->id_entry = id; \n            return id; \n        } \n        id++; \n    } \n    return NULL; \n} \n```", "```\nstatic void serial_imx_probe_pdata(struct imx_port *sport, \n         struct platform_device *pdev) \n{ \n   struct imxuart_platform_data *pdata = dev_get_platdata(&pdev->dev); \n\n   sport->port.line = pdev->id; \n   sport->devdata = (structimx_uart_data *) pdev->id_entry->driver_data; \n\n   if (!pdata) \n         return; \n   [...] \n} \n```", "```\nenum abx80x_chip { \n    AB0801, \n    AB0803, \n    AB0804, \n    AB0805, \n    AB1801, \n    AB1803, \n    AB1804, \n    AB1805, \n    ABX80X \n}; \n```", "```\nstruct abx80x_cap { \n    u16 pn; \nboolhas_tc; \n}; \n```", "```\nstatic struct abx80x_cap abx80x_caps[] = { \n    [AB0801] = {.pn = 0x0801}, \n    [AB0803] = {.pn = 0x0803}, \n    [AB0804] = {.pn = 0x0804, .has_tc = true}, \n    [AB0805] = {.pn = 0x0805, .has_tc = true}, \n    [AB1801] = {.pn = 0x1801}, \n    [AB1803] = {.pn = 0x1803}, \n    [AB1804] = {.pn = 0x1804, .has_tc = true}, \n    [AB1805] = {.pn = 0x1805, .has_tc = true}, \n    [ABX80X] = {.pn = 0} \n}; \n```", "```\nstatic const struct i2c_device_id abx80x_id[] = { \n    { \"abx80x\", ABX80X }, \n    { \"ab0801\", AB0801 }, \n    { \"ab0803\", AB0803 }, \n    { \"ab0804\", AB0804 }, \n    { \"ab0805\", AB0805 }, \n    { \"ab1801\", AB1801 }, \n    { \"ab1803\", AB1803 }, \n    { \"ab1804\", AB1804 }, \n    { \"ab1805\", AB1805 }, \n    { \"rv1805\", AB1805 }, \n    { } \n}; \n```", "```\nstatic int rs5c372_probe(struct i2c_client *client, \nconst struct i2c_device_id *id) \n{ \n    [...] \n\n    /* We pick the index corresponding to our device */ \nint index = id->driver_data; \n\n    /* \n     * And then, we can access the per device data \n     * since it is stored in abx80x_caps[index] \n     */ \n} \n```", "```\nstatic struct platform_driver imx_ssi_driver = { \n   .probe = imx_ssi_probe, \n   .remove = imx_ssi_remove, \n\n    /* As you can see here, only the 'name' field is filled */ \n   .driver = { \n         .name = \"imx-ssi\", \n   }, \n}; \n\nmodule_platform_driver(imx_ssi_driver); \n```"]