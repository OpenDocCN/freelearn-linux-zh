- en: Chapter 2. Cross-compiling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。交叉编译
- en: In this chapter, you will learn about toolchains, how to use and customize them,
    and how code standards apply to them. A toolchain contains a myriad of tools,
    such as compilers, linkers, assemblers, debuggers, and a variety of miscellaneous
    utilities that help to manipulate the resulting application binaries. In this
    chapter, you will learn how to use the GNU toolchain and become familiar with
    its features. You will be presented with examples that will involve manual configurations,
    and at the same time, these examples will be moved to the Yocto Project environment.
    At the end of the chapter, an analysis will be made to identify the similarities
    and differences between manual and automatic deployment of a toolchain, and the
    various usage scenarios available for it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解工具链，如何使用和自定义它们，以及代码标准如何适用于它们。工具链包含了许多工具，如编译器、链接器、汇编器、调试器和各种杂项实用程序，帮助操纵生成的应用程序二进制文件。在本章中，您将学习如何使用GNU工具链，并熟悉其特性。您将看到涉及手动配置的示例，并同时将这些示例移至Yocto项目环境。在本章结束时，将进行分析，以确定手动部署工具链和自动部署工具链之间的相似性和差异，以及可用于它的各种使用场景。
- en: Introducing toolchains
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍工具链
- en: A toolchain represents a compiler and its associated utilities that are used
    with the purpose of producing kernels, drivers, and applications necessary for
    a specific target. A toolchain usually contains a set of tools that are usually
    linked to each other. It consists of `gcc`, `glibc`, `binutils`, or other optional
    tools, such as a debugger optional compiler, which is used for specific programming
    languages, such as C++, Ada, Java, Fortran, or Objective-C.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链代表了一个编译器及其相关实用程序，用于生成特定目标所需的内核、驱动程序和应用程序。工具链通常包含一组通常相互链接的工具。它包括`gcc`、`glibc`、`binutils`或其他可选工具，如用于特定编程语言（如C++、Ada、Java、Fortran或Objective-C）的调试器可选编译器。
- en: Usually a toolchain, which is available on a traditional desktop or server,
    executes on these machines and produces executables and libraries that are available
    and can run on the same system. A toolchain that is normally used for an embedded
    development environment is called is a cross toolchain. In this case, programs,
    such as gcc, run on the host system for a specific target architecture, for which
    it produces a binary code. This whole process is referred to as cross-compilation,
    and it is the most common way to build sources for embedded development.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个可用于传统桌面或服务器的工具链在这些机器上执行，并生成可在同一系统上运行的可执行文件和库。通常用于嵌入式开发环境的工具链称为交叉工具链。在这种情况下，诸如gcc之类的程序在主机系统上运行，用于特定目标架构生成二进制代码。整个过程称为交叉编译，这是构建嵌入式开发源代码的最常见方式。
- en: '![Introducing toolchains](img/image00303.jpeg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![介绍工具链](img/image00303.jpeg)'
- en: 'In a toolchain environment, three different machines are available:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具链环境中，有三台不同的机器：
- en: The build machine that represents the machine on which the toolchain was created
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表创建工具链的机器的构建机器
- en: The host machine that represents the machine on which the toolchain is executed
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表执行工具链的主机机器
- en: The target machine that represents the machine that the toolchain produces a
    binary code for
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表工具链生成二进制代码的目标机器
- en: 'These three machine are used to generate four different toolchain build procedures:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这三台机器用于生成四种不同的工具链构建过程：
- en: '**A native toolchain**: This is usually available on a normal Linux distribution
    or on your normal desktop system. This is usually compiled and run, and generates
    code for the same architecture.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地工具链**：这通常在普通Linux发行版或您的普通桌面系统上可用。通常编译和运行，并为相同的架构生成代码。'
- en: '**A cross-native toolchain**: This represents a toolchain built on one system,
    though it runs and produces a binary code for the target system. A normal use
    case is when a native `gcc` is needed on the target system without building it
    on the target platform.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交叉本地工具链**：这代表了在一个系统上构建的工具链，尽管在目标系统上运行并生成二进制代码。一个常见的用例是在目标平台上需要本地`gcc`而无需在目标平台上构建它。'
- en: '**A cross-compilation toolchain**: This is the most widespread toolchain type
    used for embedded development. It is compiled and run on an architecture type,
    usually x86, and produces a binary code for the target architecture.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交叉编译工具链**：这是用于嵌入式开发的最常见的工具链类型。它在一个架构类型上编译和运行，通常是x86，并为目标架构生成二进制代码。'
- en: '**A cross-canadian build**: This represents a process that involves building
    a toolchain on system A. This toolchain is then run on another system, such as
    B, which produces a binary code for a third system, called C. This is one of the
    most underused build processes.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交叉加拿大构建**：这代表了一个涉及在系统A上构建工具链的过程。然后在另一个系统上运行该工具链，例如B，生成第三个系统C的二进制代码。这是最不常用的构建过程之一。'
- en: 'The three machines that generate four different toolchain build procedures
    is described in the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 生成四种不同的工具链构建过程的三台机器在下图中描述：
- en: '![Introducing toolchains](img/image00304.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![介绍工具链](img/image00304.jpeg)'
- en: Toolchains represent a list of tools that make the existence of most of great
    projects available today possible. This includes open source projects as well.
    This diversity would not have been possible without the existence of a corresponding
    toolchain. This also happens in the embedded world where newly available hardware
    needs the components and support of a corresponding toolchain for its **Board
    Support Package** (**BSP**).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链代表了使今天大多数伟大项目的存在成为可能的工具列表。这包括开源项目。没有相应的工具链，这种多样性是不可能的。这也发生在嵌入式世界中，新的可用硬件需要相应工具链的组件和支持**板支持包**（**BSP**）。
- en: Toolchain configuration is no easy process. Before starting the search for a
    prebuilt toolchain, or even building one yourself, the best solution would be
    to check for a target specific BSP; each development platform usually offers one.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链配置并不是一个简单的过程。在寻找预构建的工具链，甚至自己构建工具链之前，最好的解决方案是检查特定目标BSP；每个开发平台通常都提供一个。
- en: Components of toolchains
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具链的组成部分
- en: The GNU toolchain is a term used for a collection of programming tools under
    the **GNU Project umbrella**. This suite of tools is what is normally called a
    **toolchain**, and is used for the development of applications and operating systems.
    It plays an important role in the development of embedded systems and Linux systems,
    in particular.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: GNU工具链是GNU项目下的一组编程工具的术语。这套工具通常被称为**工具链**，用于应用程序和操作系统的开发。它在嵌入式系统和Linux系统的开发中起着重要作用。
- en: 'The following projects are included in the GNU toolchain:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下项目包含在GNU工具链中：
- en: '**GNU make**: This represents an automation tool used for compilation and build'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU make：这代表了用于编译和构建的自动化工具
- en: '**GNU Compiler Collection (GCC)**: This represents a compiler''s suite that
    is used for a number of available programming languages'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU编译器套件（GCC）：这代表了用于多种可用编程语言的编译器套件
- en: '**GNU Binutils**: This contains tools, such as linkers, assemblers, and so
    on - these tools are able to manipulate binaries'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU Binutils：这包含了链接器、汇编器等工具 - 这些工具能够操作二进制文件
- en: '**GNU Bison**: This is a parser generator'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU Bison：这是一个解析器生成器
- en: '**GNU Debugger (GDB)**: This is a code debugging tool'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU调试器（GDB）：这是一个代码调试工具
- en: '**GNU m4**: This is an m4 macro processor'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU m4：这是一个m4宏处理器
- en: '**GNU build system (autotools)**: This consists of the following:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU构建系统（autotools）：包括以下内容：
- en: Autoconf
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autoconf
- en: Autoheaders
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autoheaders
- en: Automake
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Automake
- en: Libtool
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Libtool
- en: 'The projects included in the toolchain is described in the following diagram:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链中包含的项目如下图所示：
- en: '![Components of toolchains](img/image00305.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![工具链的组成部分](img/image00305.jpeg)'
- en: An embedded development environment needs more than a cross-compilation toolchain.
    It needs libraries and it should target system-specific packages, such as programs,
    libraries, and utilities, and host specific debuggers, editors, and utilities.
    In some cases, usually when talking about a company's environment, a number of
    servers host target devices, and an certain hardware probes are connected to the
    host through Ethernet or other methods. This emphasizes the fact that an embedded
    distribution includes a great number of tools, and, usually, a number of these
    tools require customization. Presenting each of these will take up more than a
    chapter in a book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式开发环境需要的不仅仅是交叉编译工具链。它还需要库，并且应该针对特定系统的软件包，如程序、库和实用程序，以及特定主机的调试器、编辑器和实用程序。在某些情况下，通常是在谈论公司的环境时，一些服务器托管目标设备，并且某些硬件探针通过以太网或其他方法连接到主机。这强调了嵌入式发行版包括大量工具的事实，通常情况下，其中一些工具需要定制。介绍这些工具中的每一个将占用书中的一个章节以上。
- en: 'In this book, however, we will cover only the toolchain building components.
    These include the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本书中，我们只会涵盖工具链构建组件。这些包括以下内容：
- en: '`binutils`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`binutils`'
- en: '`gcc`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcc`'
- en: '`glibc` (C libraries)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glibc`（C库）'
- en: kernel headers
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核头文件
- en: 'I will start by the introducing the first item on this list, the **GNU Binutils
    package**. Developed under the GNU GPL license, it represents a set of tools that
    are used to create and manage binary files, object code, assembly files, and profile
    data for a given architecture. Here is a list with the functionalities and names
    of the available tools for GNU Binutils package:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从介绍列表中的第一项开始，即**GNU Binutils软件包**。根据GNU GPL许可证开发，它代表了一组工具，用于创建和管理给定架构的二进制文件、目标代码、汇编文件和配置数据。以下是GNU
    Binutils软件包可用工具的功能和名称列表：
- en: The GNU linker, that is `ld`
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU链接器，即`ld`
- en: The GNU assembler, that is `as`
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU汇编器，即`as`
- en: A utility that converts addresses into filenames and line numbers, that is `addr2line`
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将地址转换为文件名和行号的实用程序，即`addr2line`
- en: A utility to create, extract, and modify archives, that is `ar`
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、提取和修改存档的实用程序，即`ar`
- en: A tool used to listing the symbols available inside object files, that is `nm`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于列出对象文件中可用符号的工具，即`nm`
- en: Copying and translating object files, that is `objcopy`
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制和翻译对象文件，即`objcopy`
- en: Displaying information from object files, that is `objdump`
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示来自对象文件的信息，即`objdump`
- en: Generating an index to for the contents of an archive, that is `ranlib`
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为存档内容生成索引的工具，即`ranlib`
- en: Displaying information from any ELF format object file, that is `readelf`
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示任何ELF格式对象文件的信息，即`readelf`
- en: Listing the section sizes of an object or archive file, that is `size`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出对象或存档文件的段大小，即`size`
- en: Listing printable strings from files, that is `strings`
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件中列出可打印的字符串，即`strings`
- en: Discarding the symbols utility that is `strip`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丢弃符号实用程序，即`strip`
- en: Filtering or demangle encoded C++ symbols, that is `c++filt`
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤或解码编码的C++符号，即`c++filt`
- en: Creating files that build use DLLs, that is `dlltool`
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建使用DLL的文件，即`dlltool`
- en: A new, faster, ELF-only linker, which is still in beta testing, that is `gold`
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种新的、更快的、仅支持ELF的链接器，目前仍处于测试阶段，即`gold`
- en: Displaying the profiling information tool, that is `gprof`
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示分析信息工具，即`gprof`
- en: Converting an object code into an NLM, that is `nlmconv`
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将目标代码转换为NLM的实用程序，即`nlmconv`
- en: A Windows-compatible message compiler, that is `windmc`
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个兼容Windows的消息编译器，即`windmc`
- en: A compiler for Windows resource files, that is `windres`
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于Windows资源文件的编译器，即`windres`
- en: The majority of these tools use the **Binary File Descriptor** (**BFD**) library
    for low-level data manipulation, and also, many of them use the `opcode` library
    to assemble and disassemble operations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具中的大多数使用**二进制文件描述符**（**BFD**）库进行低级数据操作，而且其中许多使用`opcode`库来组装和反汇编操作。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Useful information about `binutils` can be found at [http://www.gnu.org/software/binutils/](http://www.gnu.org/software/binutils/).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`binutils`的有用信息可以在[http://www.gnu.org/software/binutils/](http://www.gnu.org/software/binutils/)找到。
- en: In the toolchain generation process, the next item on the list is represented
    by kernel headers, and are needed by the C library for interaction with the kernel.
    Before compiling the corresponding C library, the kernel headers need to be supplied
    so that they can offer access to the available system calls, data structures,
    and constants definitions. Of course, any C library defines sets of specifications
    that are specific to each hardware architecture; here, I am referring to **application
    binary interface** (**ABI**).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在工具链生成过程中，列表上的下一项是内核头文件，它们被C库所需，用于与内核交互。在编译相应的C库之前，需要提供内核头文件，以便它们可以访问可用的系统调用、数据结构和常量定义。当然，任何C库都定义了针对每个硬件架构特定的规范集；在这里，我指的是**应用二进制接口**（**ABI**）。
- en: An application binary interface (ABI) represents the interface between two modules.
    It gives information on how functions are called and the kind of information that
    should be passed between components or to the operating system. Referring to a
    book, such as *The Linux Kernel Primer*, will do you good, and in my opinion,
    is a complete guide for what the ABI offers. I will try to reproduce this definition
    for you.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 应用二进制接口（ABI）代表两个模块之间的接口。它提供了有关函数调用方式以及应该在组件之间或操作系统之间传递的信息的信息。参考一本书，比如*The Linux
    Kernel Primer*，会对你有好处，而且在我看来，它是ABI提供的完整指南。我将尝试为你复制这个定义。
- en: An ABI can be seen as a set of rules similar to a protocol or an agreement that
    offers the possibility for a linker to put together compiled modules into one
    component without the need of recompilation. At the same time, an ABI describes
    the binary interface between these components. Having this sort of convention
    and conforming to an ABI offers the benefits of linking object files that could
    have been compiled with different compilers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ABI可以被视为类似于协议或协议的一组规则，它提供了链接器将编译模块组合成一个组件的可能性，而无需重新编译的可能性。同时，ABI描述了这些组件之间的二进制接口。遵守ABI的这种约定并符合ABI的好处是可以链接使用不同编译器编译的目标文件。
- en: It can be easily seen from both of these definitions that an ABI is dependent
    on the type of platform, which can include physical hardware, some kind of virtual
    machine, and so on. It may also be dependent on the programming language that
    is used and the compiler, but most of it depends on the platform.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易从这两个定义中看出，ABI取决于平台的类型，这可能包括物理硬件、某种虚拟机等。它也可能取决于所使用的编程语言和编译器，但大部分取决于平台。
- en: The ABI presents how the generated codes operate. The code generation process
    must also be aware of the ABI, but when coding in a high-level language, attention
    given to the ABI is rarely a problem. This information could be considered as
    necessary knowledge to specify some ABI related options.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ABI展示了生成的代码如何运行。代码生成过程也必须了解ABI，但在高级语言中编码时，对ABI的关注很少是一个问题。这些信息可以被视为指定一些与ABI相关选项的必要知识。
- en: As a general rule, ABI must be respected for its interaction with external components.
    However, with regard to interaction with its internal modules, the user is free
    to do whatever he or she wants. Basically, they are able to reinvent the ABI and
    form their own dependence on the limitations of the machine. The simple example
    here is related to various citizens who belong to their own country or region,
    because they learned and know the language of that region since they were born.
    Hence, they are able to understand one another and communicate without problems.
    For an external citizen to be able to communicate, he or she will need to know
    the language of a region, and being in this community seems natural, so it will
    not constitute a problem. Compilers are also able to design their own custom calling
    conventions where they know the limitations of functions that are called within
    a module. This exercise is typically done for optimization reasons. However, this
    can be considered an abuse of the ABI term.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一般规则是，ABI必须尊重其与外部组件的交互。但是，就其与内部模块的交互而言，用户可以自由做任何他或她想做的事情。基本上，他们能够重新发明ABI，并形成自己对机器限制的依赖。这里的简单例子与属于自己国家或地区的各种公民有关，因为他们从出生开始就学会并了解该地区的语言。因此，他们能够互相理解并无障碍地交流。对于外部公民来说，要能够交流，他或她需要了解一个地区的语言，并且在这个社区中似乎是很自然的，因此这不会构成问题。编译器也能够设计自己的自定义调用约定，其中他们了解在模块内调用的函数的限制。这通常是出于优化的原因而进行的。然而，这可能被视为ABI术语的滥用。
- en: The kernel in reference to a user space ABI is backward compatible, and it makes
    sure that binaries are generated using older kernel header versions, rather than
    the ones available on the running kernel, will work best. The disadvantages of
    this are represented by the fact that new system calls, data structures, and binaries
    generated with a toolchain that use newer kernel headers, might not work for newer
    features. The need for the latest kernel headers can be justified by the need
    to have access to the latest kernel features.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 与用户空间ABI相关的内核是向后兼容的，并确保使用旧内核头版本生成的二进制文件比在运行内核上可用的版本更好地工作。这样做的缺点在于，使用较新内核头的工具链生成的新系统调用、数据结构和二进制文件可能无法使用较新功能。需要最新内核头的原因可以通过需要访问最新内核功能来证明。
- en: The GNU Compiler Collection, also known as GCC, represents a compiler system
    that constitutes the key component of the GNU toolchain. Although it was originally
    named the GNU C Compiler, due to the fact that it only handled the C programming
    language, it soon begun to represent a collection of languages, such as C, C++,
    Objective C, Fortran, Java, Ada, and Go, as well as the libraries for other languages
    (such as `libstdc++`, `libgcj`, and so on).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: GNU编译器集合，也称为GCC，代表了GNU工具链的关键组件。尽管最初被命名为GNU C编译器，因为它只处理C编程语言，但很快开始代表一系列语言，如C、C++、Objective
    C、Fortran、Java、Ada和Go，以及其他语言的库（如`libstdc++`、`libgcj`等）。
- en: It was originally written as the compiler for the GNU operating system and developed
    as a 100 percent free software. It is distributed under the GNU GPL. This helped
    it extend to its functionalities across a wide variety of architectures, and it
    played an important role in the growth of open source software.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它最初是作为GNU操作系统的编译器编写的，并作为100％自由软件开发。它在GNU GPL下分发。这有助于它在各种体系结构上扩展其功能，并在开源软件的增长中发挥了重要作用。
- en: The development of GCC started with the effort put in by Richard Stallman to
    bootstrap the GNU operating system. This quest led Stallman to write his own compiler
    from scratch. It was released in 1987, with Stallman as the author and other as
    contributors to it. By 1991, it had already reached a stable phase, but it was
    unable to include improvements due to its architectural limitations. This meant
    that the starting point for work on GCC version 2 had begun, but it did not take
    long until the need for development of new language interfaces started to appear
    in it as well, and developers started doing their own forks of the compiler source
    code. This fork initiative proved to be very inefficient, and because of the difficulty
    of accepting the code procedure, working on it became really frustrating.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: GCC的开发始于Richard Stallman为引导GNU操作系统所付出的努力。这个任务导致Stallman从头开始编写自己的编译器。它于1987年发布，Stallman是作者，其他人是贡献者。到1991年，它已经达到了稳定阶段，但由于其架构限制，无法包含改进。这意味着开始了对GCC版本2的工作，但不久之后，对它进行新语言接口开发的需求也开始出现，并且开发人员开始对编译器源代码进行自己的分支。这种分支倡议被证明是非常低效的，由于接受代码程序的困难，对它的工作变得非常沮丧。
- en: This changed in 1997, when a group of developers gathered as the **Experimental/Enhanced
    GNU Compiler System** (**EGCS**) workgroup started merging several forks in one
    project. They had so much success in this venture, and gathered so many features,
    that they made **Free Software Foundation** (**FSF**) halt their development of
    GCC version 2 and appointed EGCS the official GCC version and maintainers by April
    1999\. They united with each other with the release of GCC 2.95\. More information
    on the history and release history of the GNU Compiler Collection can be found
    at [https://www.gnu.org/software/gcc/releases.html](https://www.gnu.org/software/gcc/releases.html)
    and [http://en.wikipedia.org/wiki/GNU_Compiler_Collection#Revision_history](http://en.wikipedia.org/wiki/GNU_Compiler_Collection#Revision_history).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这在1997年发生了变化，当时一群开发人员聚集在**实验/增强GNU编译系统**（**EGCS**）工作组，开始将几个分支合并为一个项目。他们在这个冒险中取得了巨大成功，并收集了许多功能，以至于他们使**自由软件基金会**（**FSF**）停止了他们对GCC版本2的开发，并于1999年4月任命EGCS为官方GCC版本和维护者。他们在发布GCC
    2.95时合并在一起。有关GNU编译器集合的历史和发布历史的更多信息，请访问[https://www.gnu.org/software/gcc/releases.html](https://www.gnu.org/software/gcc/releases.html)和[http://en.wikipedia.org/wiki/GNU_Compiler_Collection#Revision_history](http://en.wikipedia.org/wiki/GNU_Compiler_Collection#Revision_history)。
- en: The GCC interface is similar to the Unix convention, where users call a language-specific
    driver, which interprets arguments and calls a compiler. It then runs an assembler
    on the resulting outputs and, if necessary, runs a linker to obtain the final
    executable. For each language compiler, there is a separate program that performs
    the source code read.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: GCC接口类似于Unix约定，用户调用特定于语言的驱动程序，解释参数并调用编译器。然后运行汇编程序生成输出，必要时运行链接器以获得最终可执行文件。对于每种语言编译器，都有一个执行源代码读取的单独程序。
- en: The process of obtaining an executable from source code has some execution steps.
    After the first step, an abstract syntax tree is generated and, in this stage,
    compiler optimization and static code analysis can be applied. The optimizations
    and static code analysis can be both applied on architecture-independent **GIMPLE**
    or its superset GENERIC representation, and also on architecture-dependent **Register
    Transfer Language** (**RTL**) representation, which is similar to the LISP language.
    The machine code is generated using pattern-matching algorithm, which was written
    by Jack Davidson and Christopher Fraser.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码获取可执行文件的过程有一些执行步骤。在第一步之后，生成抽象语法树，在这个阶段，可以应用编译器优化和静态代码分析。优化和静态代码分析可以同时应用于与体系结构无关的**GIMPLE**或其超集GENERIC表示，也可以应用于与体系结构相关的**寄存器传输语言**（**RTL**）表示，它类似于LISP语言。使用由Jack
    Davidson和Christopher Fraser编写的模式匹配算法生成机器代码。
- en: GCC was initially written almost entirely in C language, although the Ada frontend
    is written mostly in Ada language. However, in 2012, the GCC committee announced
    the use of C++ as an implementation language. The GCC library could not be considered
    finished as an implementation language, even though its main activities include
    adding new languages support, optimizations, improved runtime libraries, and increased
    speed for debugging applications.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: GCC最初几乎完全用C语言编写，尽管Ada前端主要用Ada语言编写。然而，2012年，GCC委员会宣布采用C++作为实现语言。尽管GCC库的主要活动包括添加新语言支持、优化、改进的运行时库和增加调试应用程序的速度，但它不能被认为是一个完成的实现语言。
- en: Each available frontend generated a tree from the given source code. Using this
    abstract tree form, different languages can share the same backend. Initially,
    GCC used **Look-Ahead LR** (**LALR)** parsers, which were generated using Bison,
    but over time, it moved on to recursive-descendent parsers for C, C++, and Objective-C
    in 2006\. Today, all available frontends use handwritten recursive-descendent
    parsers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可用的前端都从给定的源代码生成一个树。使用这种抽象树形式，不同的语言可以共享相同的后端。最初，GCC使用由Bison生成的**Look-Ahead
    LR**（**LALR**）解析器，但随着时间的推移，它在2006年转向了递归下降解析器，用于C、C++和Objective-C。今天，所有可用的前端都使用手写的递归下降解析器。
- en: Until recently, the syntax tree abstraction of a program was not independent
    of a target processor, because the meaning of the tree was different from one
    language frontend to the other, and each provided its own tree syntax. All this
    changed with the introduction of GENERIC and GIMPLE architecture-independent representations,
    which were introduced with the GCC 4.0 version.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，程序的语法树抽象与目标处理器不独立，因为树的含义在不同的语言前端之间是不同的，每个前端都提供自己的树语法。所有这些都随着GCC 4.0版本引入的GENERIC和GIMPLE架构无关表示的引入而发生了变化。
- en: GENERIC is a more complex intermediate representation, while GIMPLE is a simplified
    GENERIC and targets all the frontends of GCC. Languages, such as C, C++ or Java
    frontends, directly produce GENERIC tree representations in the frontend. Others
    use different intermediate representations that are then parsed and converted
    to GENERIC representations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: GENERIC是一个更复杂的中间表示，而GIMPLE是一个简化的GENERIC，目标是GCC的所有前端。诸如C、C++或Java前端的语言直接在前端生成GENERIC树表示。其他使用不同的中间表示，然后被解析和转换为GENERIC表示。
- en: The GIMPLE transformation represents complex expressions that are split into
    a three address code using temporary variables. The GIMPLE representation was
    inspired by the SIMPLE representation used on the McCAT compiler for simplifying
    the analysis and optimization of programs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: GIMPLE转换表示复杂表达式，这些表达式使用临时变量分割成三地址代码。GIMPLE表示受到了McCAT编译器上使用的SIMPLE表示的启发，用于简化程序的分析和优化。
- en: The middle stage representation of GCC involves code analysis and optimization,
    and works independently in terms of a compiled language and the target architecture.
    It starts from the GENERIC representation and continues to the **Register Transfer
    Language** (**RTL**) representation. The optimization mostly involves jump threading,
    instruction scheduling, loop optimization, sub expression elimination, and so
    on. The RTL optimizations are less important than the ones done through GIMPLE
    representations. However, they include dead code elimination, global value numbering,
    partial redundancy elimination, sparse conditional constant propagation, scalar
    replacement of aggregates, and even automatic vectorization or automatic parallelization.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: GCC的中间阶段表示涉及代码分析和优化，并且在编译语言和目标架构方面是独立的。它从GENERIC表示开始，继续到**寄存器传输语言**（**RTL**）表示。优化主要涉及跳转线程、指令调度、循环优化、子表达式消除等。RTL优化不如通过GIMPLE表示进行的优化重要。但是，它们包括死代码消除、全局值编号、部分冗余消除、稀疏条件常量传播、聚合标量替换，甚至自动矢量化或自动并行化。
- en: The GCC backend is mainly represented by preprocessor macros and specific target
    architecture functions, such as endianness definitions, calling conventions, or
    word sizes. The initial stage of the backend uses these representations to generate
    the RTL; this suggests that although GCC's RTL representation is nominally processor-independent,
    the initial processing of abstract instructions is adapted for each specific target.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: GCC后端主要由预处理宏和特定目标架构函数表示，例如大小端定义，调用约定或字大小。后端的初始阶段使用这些表示来生成RTL；这表明，尽管GCC的RTL表示在名义上是处理器无关的，但抽象指令的初始处理是针对每个特定目标进行调整的。
- en: A machine-specific description file contains RTL patterns, also code snippets,
    or operand constraints that form a final assembly. In the process of RTL generation,
    the constraints of the target architecture are verified. To generate an RTL snippet,
    it must match one or a number RTL patterns from the machine description file,
    and at the same time also satisfy the limitations for these patterns. If this
    is not done, the process of conversion for the final RTL into machine code would
    be impossible. Toward the end of compilation, the RTL representation becomes a
    strict form. Its representation contains a real machine register correspondence
    and a template from the target's machine description file for each instruction
    reference.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 机器特定的描述文件包含RTL模式，还包括最终汇编的代码片段或操作数约束。在RTL生成过程中，验证目标架构的约束。要生成一个RTL片段，它必须与机器描述文件中的一个或多个RTL模式匹配，并且同时满足这些模式的限制。如果不这样做，最终RTL转换为机器代码的过程将是不可能的。在编译的最后阶段，RTL表示变得严格。它的表示包含了真实的机器寄存器对应关系，以及每个指令引用的目标机器描述文件的模板。
- en: As a result, the machine code is obtained by calling small snippets of code,
    which are associated with corresponding patterns. In this way, instructions are
    generated from target instruction sets. This process involves the usage of registers,
    offsets, and addresses from the reload phase.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过调用与相应模式相关联的小代码片段来获得机器代码。这样，指令就从目标指令集生成。这个过程涉及从重新加载阶段使用寄存器、偏移和地址。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about a GCC compiler can be found at [http://gcc.gnu.org/](http://gcc.gnu.org/)
    or [http://en.wikipedia.org/wiki/GNU_Compiler_Collection](http://en.wikipedia.org/wiki/GNU_Compiler_Collection).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有关GCC编译器的更多信息，请访问[http://gcc.gnu.org/](http://gcc.gnu.org/)或[http://en.wikipedia.org/wiki/GNU_Compiler_Collection](http://en.wikipedia.org/wiki/GNU_Compiler_Collection)。
- en: 'The last element that needs to be introduced here is the C library. It represents
    the interface between a Linux kernel and applications used on a Linux system.
    At the same time, it offers aid for the easier development of applications. There
    are a couple of C libraries available in this community:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在这里介绍的最后一个元素是C库。它代表了Linux内核和Linux系统上使用的应用程序之间的接口。同时，它还为应用程序的更轻松开发提供了帮助。在这个社区中有几个C库可用：
- en: '`glibc`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glibc`'
- en: '`eglibc`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eglibc`'
- en: '`Newlib`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Newlib`'
- en: '`bionic`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bionic`'
- en: '`musl`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`musl`'
- en: '`uClibc`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uClibc`'
- en: '`dietlibc`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dietlibc`'
- en: '`Klibc`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Klibc`'
- en: The choice of the C library used by the GCC compiler will be executed in the
    toolchain generation phase, and it will be influenced not only by the size and
    application support offered by the libraries, but also by compliance of standards,
    completeness, and personal preference.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: GCC编译器使用的C库的选择将在工具链生成阶段执行，并且不仅受到库提供的大小和应用程序支持的影响，还受到标准的符合性、完整性和个人偏好的影响。
- en: Delving into C libraries
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入研究C库
- en: The first library that we'll discuss here is the `glibc` library, which is designed
    for performance, compliance of standards, and portability. It was developed by
    the Free Software Foundation for the GNU/Linux operating system and is still present
    today on all GNU/Linux host systems that are actively maintained. It was released
    under the GNU Lesser General Public License.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里讨论的第一个库是`glibc`库，它旨在提高性能、符合标准和可移植性。它是由自由软件基金会为GNU/Linux操作系统开发的，至今仍然存在于所有积极维护的GNU/Linux主机系统上。它是根据GNU
    Lesser General Public License发布的。
- en: The `glibc` library was initially written by Roland McGrath in the 1980s and
    it continued to grow until the 1990s when the Linux kernel forked `glibc`, calling
    it `Linux libc`. It was maintained separately until January 1997 when the Free
    Software Foundation released `glibc 2.0`. The `glibc 2.0` contained so many features
    that it did not make any sense to continue the development of `Linux libc`, so
    they discontinued their fork and returned to using `glibc`. There are changes
    that are made in `Linux libc` that were not merged into `glibc` because of problems
    with the authorship of the code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`glibc`库最初是由Roland McGrath在20世纪80年代编写的，直到20世纪90年代才继续发展，当时Linux内核分叉了`glibc`，称其为`Linux
    libc`。它在1997年1月之前是分开维护的，当时自由软件基金会发布了`glibc 2.0`。`glibc 2.0`包含了很多功能，使得继续开发`Linux
    libc`毫无意义，因此他们停止了分支并回到了使用`glibc`。在`Linux libc`中进行的更改没有合并到`glibc`中，因为代码的作者身份存在问题。'
- en: The `glibc` library is quite large in terms of its dimensions and isn't a suitable
    fit for small embedded systems, but it provides the functionality required by
    the **Single UNIX Specification** (**SUS**), POSIX, ISO C11, ISO C99, Berkeley
    Unix interfaces, System V Interface Definition, and the X/Open Portability Guide,
    Issue 4.2, with all its extensions common with X/Open System Interface compliant
    systems along with X/Open UNIX extensions. In addition to this, GLIBC also provides
    extensions that have been deemed useful or necessary while developing GNU.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`glibc`库在尺寸上相当大，不适合小型嵌入式系统，但它提供了**单一UNIX规范**（**SUS**）、POSIX、ISO C11、ISO C99、伯克利Unix接口、System
    V接口定义和X/Open可移植性指南4.2版的功能，以及与X/Open系统接口兼容系统以及X/Open UNIX扩展的所有扩展。此外，GLIBC还提供了在开发GNU时被认为有用或必要的扩展。'
- en: The next C library that I'm going to discuss here is the one that resides as
    the main C library used by the Yocto Project until version 1.7\. Here, I'm referring
    to the `eglibc` library. This is a version of `glibc` optimized for the usage
    of embedded devices and is, at the same time, able to preserve the compatibility
    standards.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里讨论的下一个C库是Yocto项目在1.7版本之前使用的主要C库。这里，我指的是`eglibc`库。这是`glibc`的一个版本，经过优化，用于嵌入式设备的使用，并且同时能够保持兼容性标准。
- en: Since 2009, Debian and a number of its derivations chose to move from the GNU
    C Library to `eglibc`. This might be because there is a difference in licensing
    between GNU LGPL and `eglibc`, and this permits them to accept patches that `glibc`
    developers my reject. Since 2014, the official `eglibc` homepage states that the
    development of `eglibc` was discontinued because `glibc` had also moved to the
    same licensing, and also, the release of Debian Jessie meant that it had moved
    back to `glibc`. This also happened in the case of Yocto support when they also
    decided to make `glibc` their primary library support option.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 自2009年以来，Debian及其一些派生版本选择从GNU C库转移到`eglibc`。这可能是因为GNU LGPL和`eglibc`之间的许可证存在差异，这使他们能够接受`glibc`开发人员可能拒绝的补丁。自2014年以来，官方`eglibc`主页声明`eglibc`的开发已经停止，因为`glibc`也已经转移到相同的许可证，而且Debian
    Jessie的发布意味着它已经回到了`glibc`。在Yocto支持的情况下，他们也决定将`glibc`作为他们的主要库支持选项。
- en: The `newlib` library is another C library developed with the intention of being
    used in embedded systems. It is a conglomerate of library components under free
    software licenses. Developed by Cygnus Support and maintained by Red Hat, it is
    one of the preferred versions of the C library used for non-Linux embedded systems.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`newlib`库是另一个旨在用于嵌入式系统的C库。它是由Cygnus Support开发并由Red Hat维护的一组自由软件许可证下的库组件。它是用于非Linux嵌入式系统的首选C库版本之一。'
- en: The `newlib` system calls describe the usage of the C library across multiple
    operation systems, and also on embedded systems that do not require an operating
    system. It is included in commercial GCC distributions, such as Red Hat, CodeSourcery,
    Attolic, KPIT and others. It also supported by architecture vendors that include
    ARM, Renesas, or Unix-like environments, such as Cygwin, and even proprietary
    operating systems of the Amiga personal computer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`newlib`系统调用描述了C库在多个操作系统上的使用，以及在不需要操作系统的嵌入式系统上的使用。它包含在商业GCC发行版中，如Red Hat、CodeSourcery、Attolic、KPIT等。它还受到包括ARM、Renesas在内的架构供应商的支持，或者类Unix环境，如Cygwin，甚至Amiga个人电脑的专有操作系统的支持。'
- en: By 2007, it also got support from the toolchain maintainers of Nintendo DS,
    PlayStation, portable SDK Game Boy Advance systems, Wii, and GameCube development
    platforms. Another addition was made to this list in 2013 when Google Native Client
    SDK included `newlib` as their primary C library.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到2007年，它还得到了任天堂DS、PlayStation、便携式SDK Game Boy Advance系统、Wii和GameCube开发平台的工具链维护者的支持。2013年，谷歌原生客户端SDK将“newlib”作为其主要C库包含在此列表中。
- en: 'Bionic is a derivate of the BSD C library developed by Google for Android based
    on the Linux kernel. Its development is independent of Android code development.
    It is licensed as 3-clause BSD license and its goals are publically available.
    These include the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Bionic是由Google为基于Linux内核的Android开发的BSD C库的派生版本。它的开发独立于Android代码开发。它的许可证是3条款BSD许可证，其目标是公开可用的。这些目标包括：
- en: '**Small size**: Bionic is smaller in size compared to `glibc`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小尺寸**：与“glibc”相比，Bionic尺寸更小'
- en: '**Speed**: This has designed CPUs that work at low frequencies'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：这些CPU设计为在低频率下工作'
- en: '**BSD license**: Google wished to isolate Android apps from GPL and LGPL licenses,
    and this is the reason it moved to a non-copyleft license which are as follows:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BSD许可证**：谷歌希望将Android应用程序与GPL和LGPL许可证隔离开来，这就是它转向非版权许可证的原因，具体如下：'
- en: Android is based on a Linux kernel which is based on a GPLv2 license
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android基于GPLv2许可证的Linux内核
- en: '`glibc` is based on LGPL, which permits the linking of dynamic proprietary
    libraries but not with static linking'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glibc`基于LGPL，允许链接动态专有库，但不允许静态链接'
- en: 'It also has a list of restrictions compared to `glibc`, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与“glibc”相比，它还有一系列限制，如下：
- en: It does not include C++ exception handling, mainly because most the code used
    for Android is written in Java.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不包括C++异常处理，主要是因为Android大多数代码都是用Java编写的。
- en: It does not have wide character support.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不支持宽字符。
- en: It does not include a Standard Template library, although it can be included
    manually.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不包括标准模板库，尽管可以手动包含。
- en: It functions within Bionic POSIX and even system call headers are wrappers or
    stubs for Android -specific functions. This may lead to odd behavior sometimes.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在Bionic POSIX中运行，甚至系统调用头文件都是Android特定函数的包装器或存根。这有时可能会导致奇怪的行为。
- en: When Android 4.2 released, it included support for `glibc` `FORTIFY_SOURCE`
    features. These features are very often used in Yocto, and embedded systems in
    general, but are only present in the `gcc` version for Android devices with ARM
    processors.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Android 4.2发布时，它包括对“glibc”“FORTIFY_SOURCE”功能的支持。这些功能在Yocto和嵌入式系统中经常使用，但只存在于带有ARM处理器的Android设备的“gcc”版本中。
- en: The next C library that will be discussed is `musl`. It is a C library intended
    for use with Linux operating systems for embedded and mobile systems. It has a
    MIT license and was developed with the idea of having a clean, standard-compliant
    `libc`, which is time efficient, since it's been developed from scratch. As a
    C library, it is optimized for the linking of static libraries. It is compatible
    with C99 standard and POSIX 2008, and implements Linux, `glibc`, and BSD non-standard
    functions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要讨论的C库是“musl”。它是一个用于嵌入式和移动系统的Linux操作系统的C库。它具有MIT许可证，并且是根据从头开始开发的干净、符合标准的`libc`的想法而开发的。作为一个C库，它被优化用于静态库的链接。它与C99标准和POSIX
    2008兼容，并实现了Linux、`glibc`和BSD非标准函数。
- en: 'Next, we''ll discuss `uClibc`, which is a C standard library designed for Linux
    embedded systems and mobile devices. Although initially developed for μClinux
    and designed for microcontrollers, it gathered track and became the weapon of
    choice for anyone who''s has limited space on their device. This has become popular
    due to the following reasons:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论`uClibc`，这是为Linux嵌入式系统和移动设备设计的C标准库。尽管最初是为μClinux开发并设计用于微控制器，但它获得了追踪，并成为任何在设备上有限空间的人的首选。这是因为它变得受欢迎的原因：
- en: It focuses on size rather than performance
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它侧重于尺寸而不是性能
- en: It has a GNU Lesser General Public License (LGPL) free license
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它具有GNU Lesser General Public License（LGPL）免费许可证
- en: It is much smaller the glibc and reduces compilation time
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它比glibc小得多，减少了编译时间
- en: It has high configurability due to the fact that many of its features can be
    enabled using a `menuconfig` interface similar to the one available on packages,
    such as Linux kernel, U-Boot, or even BusyBox
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于许多功能可以使用类似于Linux内核、U-Boot甚至BusyBox等软件包上可用的“menuconfig”界面进行启用，因此它具有很高的可配置性。
- en: The `uClibc` library also has another quality that makes it quite useful. It
    introduces a new ideology and, because of this, the C library does not try to
    support as many standards as possible. However, it focuses on embedded Linux and
    consists of the features necessary for developers who face the limitation of available
    space. Due to this reason, this library was written from scratch, and even though
    it has its fair share of limitations, `uClibc` is an important alternative to
    `glibc`. If we take into consideration the fact that most of the features used
    from C libraries are present in it, the final size is four times smaller, and
    WindRiver, MontaVista, and TimeSys are active maintainers of it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`uClibc`库还具有另一个使其非常有用的特性。它引入了一种新的思想，因此C库不试图支持尽可能多的标准。然而，它专注于嵌入式Linux，并包括对面临可用空间限制的开发人员必要的功能。出于这个原因，这个库是从头开始编写的，尽管它有其自身的局限性，但`uClibc`是`glibc`的一个重要替代品。如果我们考虑到大多数C库使用的功能都包含在其中，最终尺寸要小四倍，WindRiver、MontaVista和TimeSys都是其活跃的维护者。'
- en: 'The `dietlibc` library is a standard C library that was developed by Felix
    von Leitner and released under the GNU GPL v2 license. Although it also contains
    some commercial licensed components, its design was based on the same idea as
    `uClibc`: the possibility of compiling and linking software while having the smallest
    size possible. It has another resemblance to `uClibc`; it was developed from scratch
    and has only implemented the most used and known standard functions. Its primary
    usage is mainly in the embedded devices market.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`dietlibc`库是由Felix von Leitner开发的标准C库，并在GNU GPL v2许可下发布。尽管它也包含一些商业许可的组件，但其设计基于与`uClibc`相同的思想：在尽可能小的尺寸下编译和链接软件。它与`uClibc`还有另一个相似之处；它是从头开始开发的，并且只实现了最常用和已知的标准函数。它的主要用途主要是在嵌入式设备市场。'
- en: The last in the C libraries list is the `klibc` standard C library. It was developed
    by H. Peter Anvin and it was developed to be used as part of the early user space
    during the Linux startup process. It is used by the components that run the the
    kernel startup process but aren't used in the kernel mode and, hence, they do
    not have access to the standard C library.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: C库列表中的最后一个是`klibc`标准C库。它是由H. Peter Anvin开发的，并且被开发用作Linux启动过程中早期用户空间的一部分。它被用于运行内核启动过程的组件，但不用于内核模式，因此它们无法访问标准C库。
- en: 'The development of `klibc` started in 2002 as an initiative to remove the Linux
    initialization code outside a kernel. Its design makes it suitable for usage in
    embedded devices. It also has another advantage: it is optimized for small size
    and correctness of data. The `klibc` library is loaded during the Linux startup
    process from **initramfs** (a temporary Ram filesystem) and is incorporated by
    default into initramfs using the `mkinitramfs` script for Debian and Ubuntu-based
    filesystems. It also has access to a small set of utilities, such as `mount`,
    `mkdir`, `dash`, `mknod`, `fstype`, `nfsmount`, `run-init` and so on, which are
    very useful in the early init stage.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`klibc`的开发始于2002年，旨在将Linux初始化代码移出内核。其设计使其适用于嵌入式设备。它还有另一个优势：它针对小尺寸和数据正确性进行了优化。`klibc`库在Linux启动过程中从**initramfs**（临时Ram文件系统）中加载，并且默认情况下使用`mkinitramfs`脚本将其合并到基于Debian和Ubuntu的文件系统中。它还可以访问一小组实用程序，如`mount`，`mkdir`，`dash`，`mknod`，`fstype`，`nfsmount`，`run-init`等，在早期初始化阶段非常有用。'
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information on initramfs can be found using the kernel documentation at
    [https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt](https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有关initramfs的更多信息可以在内核文档中找到：[https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt](https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt)。
- en: The `klibc` library is licensed under GNU GPL since it uses some components
    from the Linux kernel, so, as a whole, it is visible as a GPL licensed software,
    limiting its applicability in commercial embedded software. However, most of the
    source code of libraries is written under the BSD license.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`klibc`库根据GNU GPL许可，因为它使用了一些来自Linux内核的组件，因此作为整体，它被视为GPL许可的软件，限制了其在商业嵌入式软件中的适用性。然而，大多数库的源代码都是根据BSD许可编写的。'
- en: Working with toolchains
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用工具链
- en: When generating a toolchain, the first thing that needs to be done is the establishment
    of an ABI used to generate binaries. This means that the kernel needs to understand
    this ABI and, at the same time, all the binaries in the system need to be compiled
    with the same ABI.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成工具链时，需要做的第一件事是建立用于生成二进制文件的ABI。这意味着内核需要理解这个ABI，同时系统中的所有二进制文件都需要使用相同的ABI进行编译。
- en: 'When working with the GNU toolchain, a good source of gathering information
    and understanding the ways in which work is done with these tools is to consult
    the GNU coding standards. The coding standard''s purposes are very simple: to
    make sure that the work with the GNU ecosystem is performed in a clean, easy,
    and consistent manner. This is a guideline that needs to be used by people interested
    in working with GNU tools to write reliable, solid, and portable software. The
    main focus of the GNU toolchain is represented by the C language, but the rules
    applied here are also very useful for any programming languages. The purpose of
    each rule is explained by making sure that the logic behind the given information
    is passed to the reader.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用GNU工具链时，收集信息并了解使用这些工具的方式的一个很好的来源是查阅GNU编码标准。编码标准的目的非常简单：确保在GNU生态系统中以清晰、简单和一致的方式执行工作。这是一个需要被有兴趣使用GNU工具编写可靠、稳固和可移植软件的人使用的指南。GNU工具链的主要重点是C语言，但这里应用的规则对于任何编程语言也非常有用。通过确保将给定信息背后的逻辑传递给读者来解释每条规则的目的。
- en: The main language that we will be focusing on will also be the C programming
    language. With regard to the GNU coding standard compatibility regarding libraries
    for GNU, exceptions or utilities and their compatibility should be very good when
    compared with standards, such as the ones from Berkeley Unix, Standard C, or POSIX.
    In case of conflicts in compatibility, it is very useful to have compatibility
    modes for that programming language.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主要关注的语言也将是C编程语言。关于GNU编码标准与GNU库、异常或实用程序的兼容性，以及它们与Berkeley Unix、标准C或POSIX等标准的比较应该非常好。在兼容性冲突的情况下，为该编程语言拥有兼容模式非常有用。
- en: Standards, such as POSIX and C, have a number of limitations regarding the support
    for extensions - however, these extensions could still be used by including a
    `—posix`, `—ansi`, or `—compatible` option to disable them. In case the extension
    offers a high probability of breaking a program or script by being incompatible,
    a redesign of its interface should be made to ensure compatibility.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 标准，如POSIX和C，对于支持扩展有许多限制 - 然而，这些扩展仍然可以通过包括`—posix`，`—ansi`或`—compatible`选项来禁用它们。如果扩展提供了破坏程序或脚本的高概率，因为不兼容，应重新设计其接口以确保兼容性。
- en: A large number of GNU programs suppress the extensions that are known to cause
    conflict with POSIX if the `POSIXLY_CORRECT` environment variable is defined.
    The usage of user defined features offers the possibility for interchanging GNU
    features with other ones totally different, better, or even use a compatible feature.
    Additional useful features are always welcomed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的GNU程序抑制了已知会与POSIX冲突的扩展，如果定义了`POSIXLY_CORRECT`环境变量。用户定义功能的使用为交换GNU功能与其他完全不同、更好甚至兼容功能提供了可能性。额外的有用功能总是受欢迎的。
- en: 'If we take a quick look at the GNU Standard documentation, some useful information
    can be learned from it:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们快速浏览GNU标准文档，可以从中学到一些有用的信息：
- en: It is better to use the `int` type, although you might consider defining a narrower
    data type. There are, of course, a number of special cases where this could be
    hard to use. One such example is the `dev_t` system type, because it is shorter
    than `int` on some machines and wider on others. The only way to offer support
    for non-standard C types involves checking the width of `dev_t` using `Autoconf`
    and, after this, choosing the argument type accordingly. However, it may not worth
    the trouble.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用`int`类型，尽管您可能考虑定义一个更窄的数据类型。当然，也有一些特殊情况可能很难使用。一个例子是`dev_t`系统类型，因为在某些机器上它比`int`短，在其他机器上则更宽。支持非标准C类型的唯一方法是使用`Autoconf`检查`dev_t`的宽度，然后相应地选择参数类型。然而，这可能不值得麻烦。
- en: For the GNU Project, the implementation of an organization's standard specifications
    is optional, and this can be done only if it helps the system by making it better
    overall. In most situations, following published standards fits well within a
    users needs because their programs or scripts could be considered more portable.
    One such example is represented by the GCC, which implements almost all the features
    of Standard C, as the standard requires. This offers a great advantage for the
    developers of the C program. This also applies to GNU utilities that follow POSIX.2
    specifications.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于GNU项目来说，实施组织标准规范是可选的，只有在帮助系统整体变得更好的情况下才能实现。在大多数情况下，遵循已发布的标准符合用户需求，因为他们的程序或脚本可能被认为更具可移植性。一个例子是GCC，它几乎实现了标准C的所有特性，正如标准要求的那样。这为C程序的开发人员提供了巨大的优势。这也适用于遵循POSIX.2规范的GNU实用程序。
- en: There are also specific points in the specifications that are not followed,
    but this happens with the sole reason of making the GNU system better for users.
    One such example would be the fact that the Standard C program does not permit
    extensions to C, but, GCC implements many of them, some being later embraced by
    the standard. For developers interested in outputting an error message as *required*
    by the standard, the `--pedantic` argument can be used. It is implemented with
    a view to making sure that GCC fully implements the standard.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些规范中没有遵循的具体要点，但这是为了使GNU系统更好地为用户服务。一个例子是标准C程序不允许对C进行扩展，但是GCC实现了其中的许多扩展，其中一些后来被标准所采纳。对于希望按照标准输出错误消息的开发人员，可以使用`--pedantic`参数。这是为了确保GCC完全实现了标准。
- en: The POSIX.2 standard mentions that commands, such as `du` and `df`, should output
    sizes in units of 512 bytes. However, users want units of 1KB and this default
    behavior is implemented. If someone is interested in having the behavior requested
    by POSIX standard, they would need to set the `POSIXLY_CORRECT` environment variable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX.2标准提到，诸如`du`和`df`之类的命令应该以512字节为单位输出大小。然而，用户希望以1KB为单位，因此实现了这种默认行为。如果有人希望具有POSIX标准要求的行为，他们需要设置`POSIXLY_CORRECT`环境变量。
- en: Another such example is represented by the GNU utilities, which don't always
    respect the POSIX.2 standard specifications when referring to support for long
    named command-line options or intermingling of options with arguments. This incompatibility
    with the POSIX standard is very useful in practice for developers. The main idea
    here is not to reject any new feature or remove an older one, although a certain
    standard mentions it as deprecated or forbidden.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是GNU实用程序，当涉及到长命令行选项的支持或选项与参数的混合时，并不总是遵循POSIX.2标准规范。这种与POSIX标准的不兼容在实践中对开发人员非常有用。这里的主要思想不是拒绝任何新功能或删除旧功能，尽管某个标准将其视为已弃用或禁止。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information regarding the GNU Coding Standards, refer to [https://www.gnu.org/prep/standards/html_node/](https://www.gnu.org/prep/standards/html_node/).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有关GNU编码标准的更多信息，请参阅[https://www.gnu.org/prep/standards/html_node/](https://www.gnu.org/prep/standards/html_node/)。
- en: Advice on robust programming
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 健壮编程的建议
- en: To make sure that you write robust code, a number of guidelines should be mentioned.
    The first one refers to the fact that limitations should not be used for any data
    structure, including files, file names, lines, and symbols, and especially arbitrary
    limitations. All data structures should be dynamically allocated. One of the reasons
    for this is represented by the fact that most Unix utilities silently truncate
    long lines; GNU utilities do not do these kind of things.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保编写健壮的代码，应该提到一些指导方针。第一个指导方针是不应该对任何数据结构使用限制，包括文件、文件名、行和符号，尤其是任意限制。所有数据结构都应该是动态分配的。其中一个原因是大多数Unix实用程序会悄悄地截断长行；GNU实用程序不会这样做。
- en: Utilities that are used to read files should avoid dropping `null` characters
    or nonprinting characters. The exception here is when these utilities, that are
    intended for interfacing with certain types of printers or terminals, are unable
    to handle the previously mentioned characters. The advice that I'd give in this
    case would be to try and make programs work with a UTF-8 character set, or other
    sequences of bytes used to represent multibyte characters.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 用于读取文件的实用程序应避免删除`null`字符或不可打印字符。这里的例外是，当这些旨在与某些类型的打印机或终端进行接口的实用程序无法处理先前提到的字符时。在这种情况下，我会建议尝试使用UTF-8字符集或其他用于表示多字节字符的字节序列使程序正常工作。
- en: Make sure that you check system calls for error return values; the exception
    here is when a developer wishes to ignore the errors. It would be a good idea
    to include the system error text from `strerror`, `perror`, or equivalent error
    handling functions, in error messages that result from a crashed on system call,
    adding the name of the source code file, and also the name of the utility. This
    is done to make sure that the error message is easy to read and understand by
    anyone involved in the interaction with the source code or the program.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 确保检查系统调用的错误返回值；例外情况是开发人员希望忽略错误。最好在由系统调用崩溃导致的错误消息中包括`strerror`、`perror`或等效错误处理函数的系统错误文本，还要添加源代码文件的名称和实用程序的名称。这样做是为了确保错误消息易于被与源代码或程序交互的任何人阅读和理解。
- en: Check the return value for `malloc` or `realloc` to verify if they've returned
    zero. In case `realloc` is used in order to make a block smaller in systems that
    approximate block dimensions to powers of 2, `realloc` may have a different behavior
    and get a different block. In Unix, when `realloc` has a bug, it destroys the
    storage block for a zero return value. For GNU, this bug does not occur, and when
    it fails, the original block remains unchanged. If you want to run the same program
    on Unix and do not want to lose data, you could check if the bug was resolved
    on the Unix system or use the `malloc` GNU.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`malloc`或`realloc`的返回值，以验证它们是否返回了零。如果在系统中使用`realloc`使块变小，系统将近似块尺寸为2的幂，则`realloc`可能会有不同的行为并获得不同的块。在Unix中，当`realloc`存在错误时，它会破坏零返回值的存储块。对于GNU，这个错误不会发生，当它失败时，原始块保持不变。如果要在Unix上运行相同的程序并且不想丢失数据，可以检查Unix系统上的错误是否已解决，或者使用GNU的`malloc`。
- en: The content of the block that was freed is not accessible to alter or for any
    other interactions from the user. This can be done before calling free.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 释放的块的内容不可访问以进行更改或进行任何其他用户交互。这可以在调用free之前完成。
- en: When a `malloc` command fails in a noninteractive program, we face a fatal error.
    In case the same situation is repeated, but, this time, an interactive program
    is involved, it would be better to abort the command and return to the read loop.
    This offers the possibility to free up virtual memory, kill other processes, and
    retry the command.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当`malloc`命令在非交互式程序中失败时，我们面临致命错误。如果发生相同的情况，但这次涉及交互式程序，最好中止命令并返回读取循环。这提供了释放虚拟内存、终止其他进程并重试命令的可能性。
- en: To decode arguments, the `getopt_long` option can be used.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要解码参数，可以使用`getopt_long`选项。
- en: When writing static storage during program execution, use C code for its initialization.
    However, for data that will not be changed, reserve C initialized declarations.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行期间写入静态存储时，使用C代码进行初始化。但是，对于不会更改的数据，请保留C初始化声明。
- en: Try to keep away from low-level interfaces to unknown Unix data structures -
    this could happen when the data structure do not work in a compatible fashion.
    For example, to find all the files inside a directory, a developer could use the
    `readdir` function, or any high-level interface available function, since these
    do not have compatibility problems.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量远离对未知Unix数据结构的低级接口——当数据结构无法以兼容的方式工作时，可能会发生这种情况。例如，要查找目录中的所有文件，开发人员可以使用`readdir`函数或任何高级接口可用函数，因为这些函数没有兼容性问题。
- en: For signal handling, use the BSD variant of `signal` and the POSIX `sigaction`
    function. The USG `signal` interface is not the best alternative in this case.
    Using POSIX signal functions is nowadays considered the easiest way to develop
    a portable program. However, the use of one function over another is completely
    up to the developer.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于信号处理，使用BSD变体的`signal`和POSIX的`sigaction`函数。在这种情况下，USG的`signal`接口不是最佳选择。如今，使用POSIX信号函数被认为是开发可移植程序的最简单方法。但是，使用一个函数而不是另一个完全取决于开发人员。
- en: For error checks that identify impossible situations, just abort the program,
    since there is no need to print any messages. These type of checks bear witness
    to the existence of bugs. To fix these bugs, a developer will have to inspect
    the available source code and even start a debugger. The best approach to solve
    this problem would be to describe the bugs and problems using comments inside
    the source code. The relevant information could be found inside variables after
    examining them accordingly with a debugger.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于识别不可能情况的错误检查，只需中止程序，因为无需打印任何消息。这种类型的检查证明了错误的存在。要修复这些错误，开发人员将不得不检查可用的源代码，甚至启动调试器。解决这个问题的最佳方法是在源代码中使用注释描述错误和问题。在使用调试器相应地检查变量后，可以找到相关信息。
- en: Do not use a count of the encountered errors in a program as an exit status.
    This practice is not the best, mostly because the values for an exit status are
    limited to 8 bits only, and an execution of the executable might have more than
    255 errors. For example, if you try to return exit status 256 for a process, the
    parent process will see a status of zero and consider that the program finished
    successfully.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将程序中遇到的错误数量作为退出状态。这种做法并不是最佳的，主要是因为退出状态的值仅限于8位，可执行文件的执行可能有超过255个错误。例如，如果尝试返回进程的退出状态256，父进程将看到状态为零，并认为程序成功完成。
- en: 'If temporary files are created, checking that the `TMPDIR` environment variable
    would be a good idea. If the variable is defined, it would be wise to use the
    `/tmp` directory instead. The use of temporary files should be done with caution
    because there is the possibility of security breaches occurring when creating
    them in world-writable directories. For C language, this can be avoided by creating
    temporary files in the following manner:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建了临时文件，请检查`TMPDIR`环境变量是个好主意。如果定义了该变量，最好使用`/tmp`目录。应谨慎使用临时文件，因为在可写入世界的目录中创建它们可能会导致安全漏洞。对于C语言，可以通过以下方式避免在临时文件中创建临时文件：
- en: '[PRE0]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This can also be done using the `mkstemps` function, which is made available
    by `Gnulib`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以使用`mkstemps`函数来完成，该函数由`Gnulib`提供。
- en: For a bash environment, use the `noclobber` environment variable, or the `set
    -C` short version, to avoid the previously mentioned problem. Furthermore, the
    `mktemp` available utility is altogether a better solution for making a temporary
    file a shell environment; this utility is available in the GNU Coreutils package.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于bash环境，使用`noclobber`环境变量，或`set -C`的简短版本，以避免前面提到的问题。此外，`mktemp`可用实用程序是在GNU
    Coreutils软件包中的制作临时文件的更好解决方案。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about GNU C Standards can be found at [https://www.gnu.org/prep/standards/standards.html](https://www.gnu.org/prep/standards/standards.html).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有关GNU C标准的更多信息，请访问[https://www.gnu.org/prep/standards/standards.html](https://www.gnu.org/prep/standards/standards.html)。
- en: Generating the toolchain
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成工具链
- en: After the introduction of the packages that comprise a toolchain, this section
    will introduce the steps needed to obtain a custom toolchain. The toolchain that
    will be generated will contain the same sources as the ones available inside the
    Poky dizzy branch. Here, I am referring to the `gcc` version 4.9, `binutils` version
    2.24, and `glibc` version 2.20\. For Ubuntu systems, there are also shortcuts
    available. A generic toolchain can be installed using the available package manager,
    and there are also alternatives, such as downloading custom toolchains available
    inside Board Support Packages, or even from third parties, including CodeSourcery
    and Linaro. More information on toolchains can be found at [http://elinux.org/Toolchains](http://elinux.org/Toolchains).
    The architecture that will be used as a demo is an ARM architecture.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍组成工具链的软件包之后，本节将介绍获取自定义工具链所需的步骤。将生成的工具链包含与Poky dizzy分支中可用的相同源。在这里，我指的是`gcc`版本4.9，`binutils`版本2.24和`glibc`版本2.20。对于Ubuntu系统，也有快捷方式可用。可以使用可用的软件包管理器安装通用工具链，还有其他选择，例如从Board
    Support Packages中下载可用的自定义工具链，甚至从CodeSourcery和Linaro等第三方下载。有关工具链的更多信息，请访问[http://elinux.org/Toolchains](http://elinux.org/Toolchains)。将用作演示的架构是ARM架构。
- en: 'The toolchain build process has eight steps. I will only outline the activities
    required for each one of them, but I must mention that they are all automatized
    inside the Yocto Project recipes. Inside the Yocto Project section, the toolchain
    is generated without notice. For interaction with the generated toolchain, the
    simplest task would be to call **meta-ide-support**, but this will be presented
    in the appropriate section as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链构建过程有八个步骤。我只会概述每个步骤所需的活动，但必须提到它们都在Yocto项目配方中自动化。在Yocto项目部分，工具链是在不知不觉中生成的。与生成的工具链交互的最简单任务是调用**meta-ide-support**，但这将在适当的部分中介绍如下：
- en: '**The setup**: This represents the step in which top-level build directories
    and source subdirectories are created. In this step, variables such as `TARGET`,
    `SYSROOT`, `ARCH`, `COMPILER`, `PATH`, and others are defined.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置**：这代表了创建顶级构建目录和源子目录的步骤。在此步骤中，定义了诸如`TARGET`，`SYSROOT`，`ARCH`，`COMPILER`，`PATH`等变量。'
- en: '**Geting the sources**: This represents the step in which packages, such as
    `binutils`, `gcc`, `glibc`, `linux kernel` headers, and various patches are made
    available for use in later steps.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取源代码**：这代表了在后续步骤中可用的软件包，如`binutils`，`gcc`，`glibc`，`Linux内核`头文件和各种补丁。'
- en: '**GNU Binutils setup** - This represents the steps in which the interaction
    with the `binutils` package is done, as shown here:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GNU Binutils设置** - 这代表了与`binutils`软件包交互的步骤，如下所示：'
- en: Unzip the sources available from the corresponding release
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解压相应版本的源代码
- en: Patch the sources accordingly, if this applies
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果适用，相应地对源代码进行打补丁
- en: Configure, the package accordingly
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相应地配置软件包
- en: Compile the sources
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译源代码
- en: Install the sources in the corresponding location
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将源代码安装在相应的位置
- en: '**Linux kernel headers setup**: This represents the steps in which the interaction
    with the Linux kernel sources is presented, as shown here:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux内核头文件设置**：这代表了与Linux内核源交互的步骤，如下所示：'
- en: Unzip the kernel sources.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解压内核源代码。
- en: Patch the kernel sources, if this applies.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果适用，对内核源代码进行打补丁。
- en: Configure the kernel for the selected architecture. In this step, the corresponding
    kernel config file is generated. More information about Linux kernel will be presented
    in [Chapter 4](part0031.xhtml#aid-TI1E1 "Chapter 4. Linux Kernel"), *Linux Kernel*.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所选的架构配置内核。在此步骤中，将生成相应的内核配置文件。有关Linux内核的更多信息将在[第4章](part0031.xhtml#aid-TI1E1
    "Chapter 4. Linux Kernel")中介绍，*Linux Kernel*。
- en: Compile the Linux kernel headers and copy them in the corresponding location.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译Linux内核头文件并将其复制到相应的位置。
- en: Install the headers in the corresponding locations.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将头文件安装在相应的位置。
- en: '**Glibc headers setup**: This represents the steps used to setting the `glibc`
    build area and installation headers, as shown here:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Glibc头文件设置**：这代表了设置`glibc`构建区域和安装头文件的步骤，如下所示：'
- en: Unzip the glibc archive and headers files
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解压glibc存档和头文件
- en: Patch the sources, if this applies
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果适用，对源代码进行打补丁
- en: Configure the sources accordingly enabling the `-with-headers` variable to link
    the libraries to the corresponding Linux kernel headers
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置源代码，启用`-with-headers`变量以将库链接到相应的Linux内核头文件
- en: Compile the glibc headers files
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译`glibc`头文件
- en: Install the headers accordingly
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相应地安装头文件
- en: '**GCC first stage setup**: This represents the step in which the C runtime
    files, such as `crti.o` and `crtn.o`, are generated:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GCC第一阶段设置**：这代表了生成C运行时文件（如`crti.o`和`crtn.o`）的步骤：'
- en: Unzip the gcc archive
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解压gcc存档
- en: Patch the gcc sources if necessary
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如有必要，对`gcc`源代码进行修补
- en: Configure the sources enabling the needed features
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置源代码，启用所需的功能
- en: Compile the C runtime components
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译C运行时组件
- en: Install the sources accordingly
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相应地安装源代码
- en: '**Build the glibc sources**: This represents the step in which the `glibc`
    sources are built and the necessary ABI setup is done, as shown here:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建`glibc`源代码**：这代表了构建`glibc`源代码并进行必要的ABI设置的步骤，如下所示：'
- en: Configure the `glibc` library by setting the `mabi` and `march` variables accordingly
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过相应地设置`mabi`和`march`变量来配置`glibc`库
- en: Compile the sources
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译源代码
- en: Install the `glibc` accordingly
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相应地安装`glibc`
- en: '**GCC second stage setup**: This represents the final setup phase in which
    the toolchain configuration is finished, as shown here:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GCC第二阶段设置**：这代表了工具链配置完成的最终设置阶段，如下所示：'
- en: Configure the `gcc` sources
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置`gcc`源代码
- en: Compile the sources
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译源代码
- en: Install the binaries in the corresponding location
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在相应位置安装二进制文件
- en: After these steps are performed, a toolchain will be available for the developer
    to use. The same strategy and build procedure steps is followed inside the Yocto
    Project.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些步骤后，开发人员将可以使用工具链。在Yocto项目中遵循相同的策略和构建过程步骤。
- en: The Yocto Project reference
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Yocto项目参考
- en: As I have mentioned, the major advantage and available feature of the Yocto
    Project environment is represented by the fact that a Yocto Project build does
    not use the host available packages, but builds and uses its own packages. This
    is done to make sure that a change in the host environment does not influence
    its available packages and that builds are made to generate a custom Linux system.
    A toolchain is one of the components because almost all packages that are constituents
    of a Linux distribution need the usage of toolchain components.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所提到的，Yocto项目环境的主要优势和可用功能在于Yocto项目构建不使用主机可用的软件包，而是构建和使用自己的软件包。这是为了确保主机环境的更改不会影响其可用的软件包，并且构建是为了生成自定义Linux系统。工具链是其中的一个组件，因为几乎所有构成Linux发行版的软件包都需要使用工具链组件。
- en: 'The first step for the Yocto Project is to identify the exact sources and packages
    that will be combined to generate the toolchain that will be used by later built
    packages, such as U-Boot bootloader, kernel, BusyBox and others. In this book,
    the sources that will be discussed are the ones available inside the dizzy branch,
    the latest poky 12.0 version, and the Yocto Project version 1.7\. The sources
    can be gathered using the following command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto项目的第一步是确定将组合生成工具链的确切源和软件包，该工具链将被后续构建的软件包使用，如U-Boot引导程序、内核、BusyBox等。在本书中，将讨论的源代码位于dizzy分支、最新的poky
    12.0版本和Yocto项目版本1.7中。可以使用以下命令收集源代码：
- en: '[PRE1]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Gathering the sources and investigating the source code, we identified a part
    of the packages mentioned and presented in the preceding headings, as shown here:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 收集源代码并调查源代码，我们确定了前面标题中提到的部分软件包，并按照以下方式呈现：
- en: '[PRE2]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The GNU CC and GCC C compiler package, which consists of all the preceding
    packages, is split into multiple fractions, each one with its purpose. This is
    mainly because each one has its purpose and is used with different scopes, such
    as `sdk` components. However, as I mentioned in the introduction of this chapter,
    there are multiple toolchain build procedures that need to be assured and automated
    with the same source code. The available support inside Yocto is for gcc 4.8 and
    4.9 versions. A quick look at the `gcc` available recipes shows the available
    information:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: GNU CC和GCC C编译器软件包包括所有前面的软件包，分为多个部分，每个部分都有其目的。这主要是因为每个部分都有其目的，并且用于不同的范围，如`sdk`组件。然而，正如我在本章开头提到的，有多个需要确保并使用相同源代码自动化的工具链构建过程。Yocto中支持gcc
    4.8和4.9版本。快速查看`gcc`可用的配方显示了可用的信息：
- en: '[PRE3]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The GNU Binutils package represents the binary tools collection, such as GNU
    Linker, GNU Assembler, `addr2line`, `ar`, `nm`, `objcopy`, `objdump`, and other
    tools and related libraries. The Yocto Project offers support for the Binutils
    version 2.24, and is also dependent on the available toolchain build procedures,
    as it can be viewed from the inspection of the source code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: GNU Binutils软件包代表了二进制工具集合，如GNU链接器、GNU汇编器、`addr2line`、`ar`、`nm`、`objcopy`、`objdump`和其他工具及相关库。Yocto项目支持Binutils版本2.24，并且还依赖于可用的工具链构建过程，可以从源代码检查中看到：
- en: '[PRE4]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The last components is represented by C libraries that are present as components
    inside the Poky dizzy branch. There are two C libraries available that can be
    used by developers. The first one is represented by the GNU C library, also known
    as `glibc`, which is the most used C library in Linux systems. The sources for
    `glibc` package can be viewed here:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的组件由C库组成，这些库作为Poky dizzy分支中的组件存在。有两个可供开发人员使用的C库。第一个是GNU C库，也称为`glibc`，是Linux系统中最常用的C库。`glibc`软件包的源代码可以在这里查看：
- en: '[PRE5]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'From these sources, the same location also includes tools, such as `ldconfig`,
    a standalone native dynamic linker for runtime dependencies and a binding and
    cross locale generation tool. In the other C library, called `uClibc`, as previously
    mentioned, a library designed for embedded systems has fewer recipes, as it can
    be viewed from the Poky source code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些源中，相同的位置还包括工具，如`ldconfig`，用于运行时依赖关系的独立本地动态链接器和绑定和交叉语言环境生成工具。在另一个名为`uClibc`的C库中，如前所述，这是为嵌入式系统设计的库，具有较少的配方，可以从Poky源代码中查看：
- en: '[PRE6]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The uClibc is used as an alternative to `glibc` C library because it generates
    smaller executable footprints. At the same time, `uClibc` is the only package
    from the ones presented in the preceding list that has a `bbappend` applied to
    it, since it extends the support for two machines, `genericx86-64` and `genericx86`.
    The change between `glibc` and `uClibc` can be done by changing the `TCLIBC` variable
    to the corresponding variable in this way: `TCLIBC = "uclibc"`.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: uClibc被用作`glibc` C库的替代方案，因为它生成较小的可执行文件占用空间。同时，`uClibc`是前面列表中所呈现的唯一一个应用了`bbappend`的软件包，因为它扩展了对两台机器`genericx86-64`和`genericx86`的支持。可以通过将`TCLIBC`变量更改为相应的变量来在`glibc`和`uClibc`之间进行更改：`TCLIBC
    = "uclibc"`。
- en: 'As mentioned previously, the toolchain generation process for the Yocto Project
    is simpler. It is the first task that is executed before any recipe is built using
    the Yocto Project. To generate the cross-toolchain inside using Bitbake, first,
    the `bitbake meta-ide-support` task is executed. The task can be executed for
    the `qemuarm` architecture, for example, but it can, of course, be generated in
    a similar method for any given hardware architecture. After the task finishes
    the execution process, the toolchain is generated and it populates the build directory.
    It can be used after this by sourcing the `environment-setup` script available
    in the `tmp` directory:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Yocto Project的工具链生成过程更简单。这是在使用Yocto Project构建任何配方之前执行的第一个任务。要在Bitbake中生成交叉工具链，首先执行`bitbake
    meta-ide-support`任务。例如，可以为`qemuarm`架构执行该任务，但当然也可以以类似的方法为任何给定的硬件架构生成。任务完成执行过程后，工具链将生成并填充构建目录。在此之后，可以通过在`tmp`目录中使用`environment-setup`脚本来使用它：
- en: '[PRE7]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Set the `MACHINE` variable to the value `qemuarm` accordingly inside the `conf/local.conf`
    file:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地在`conf/local.conf`文件中将`MACHINE`变量设置为值`qemuarm`：
- en: '[PRE8]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The default C library used for the generation of the toolchain is `glibc`, but
    it can be changed according to the developer's need. As seen from the presentation
    in the previous section, the toolchain generation process inside the Yocto Project
    is very simple and straightforward. It also avoids all the trouble and problems
    involved in the manual toolchain generation process, making it very easy to reconfigure
    also.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 用于生成工具链的默认C库是`glibc`，但可以根据开发人员的需要进行更改。从前一节的介绍中可以看出，Yocto Project中的工具链生成过程非常简单直接。它还避免了手动工具链生成过程中涉及的所有麻烦和问题，使得重新配置也非常容易。
- en: Summary
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you were presented with the necessary information needed to
    understand the constituent components of a Linux toolchain, and the steps undertaken
    by developers to work or configure a Linux toolchain that is specific for a board
    or architecture. You were also presented information on the packages available
    inside the Yocto Project sources, and how the processes defined inside the Yocto
    Project are very similar to the ones already used outside of the Yocto Project
    context.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将获得理解Linux工具链组成部分所需的必要信息，以及开发人员为工作或配置特定于板或架构的Linux工具链所采取的步骤。您还将获得有关Yocto
    Project源中可用软件包的信息，以及Yocto Project中定义的过程与Yocto Project上下文之外已经使用的过程非常相似。
- en: In the next chapter, we will breeze through information on bootloaders, with
    special emphasis given to U-Boot bootloader. You will also be given information
    on a boot sequence and a board's configurations inside the U-Boot sources.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将快速浏览有关引导加载程序的信息，特别强调U-Boot引导加载程序。您还将获得有关引导顺序和U-Boot源中板的配置的信息。
