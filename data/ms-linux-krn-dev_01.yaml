- en: Comprehending Processes, Address Space, and Threads
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解进程、地址空间和线程
- en: 'When kernel services are invoked in the current process context, its layout
    throws open the right path for exploring kernels in more detail. Our effort in
    this chapter is centered around comprehending processes and the underlying ecosystem
    the kernel provides for them. We will explore the following concepts in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当内核服务在当前进程上下文中被调用时，它的布局为更详细地探索内核打开了正确的路径。本章中的努力集中在理解进程和内核为它们提供的基础生态系统上。我们将在本章中探讨以下概念：
- en: Program to process
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序到进程
- en: Process layout
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程布局
- en: Virtual address spaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟地址空间
- en: Kernel and user space
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核和用户空间
- en: Process APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程API
- en: Process descriptors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程描述符
- en: Kernel stack management
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核堆栈管理
- en: Threads
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程
- en: Linux thread API
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux线程API
- en: Data structures
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构
- en: Namespace and cgroups
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间和cgroups
- en: Processes
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程
- en: Quintessentially, computing systems are designed, developed, and often tweaked
    for running user applications efficiently. Every element that goes into a computing
    platform is intended to enable effective and efficient ways for running applications.
    In other words, computing systems exist to run diverse application programs. Applications
    can run either as firmware in dedicated devices or as a "process" in systems driven
    by system software (operating systems).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，计算系统被设计、开发并经常进行调整，以便有效地运行用户应用程序。计算平台中的每个元素都旨在实现有效和高效地运行应用程序的方式。换句话说，计算系统存在是为了运行各种应用程序。应用程序可以作为专用设备中的固件运行，也可以作为系统软件（操作系统）驱动的系统中的“进程”运行。
- en: At its core, a process is a running instance of a program in memory. The transformation
    from a program to a process happens when the program (on disk) is fetched into
    memory for execution.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，进程是内存中程序的运行实例。当程序（在磁盘上）被获取到内存中执行时，程序到进程的转换发生。
- en: A program’s binary image carries **code** (with all its binary instructions)
    and **data** (with all global data), which are mapped to distinct regions of memory
    with appropriate access permissions (read, write, and execute). Apart from code
    and data, a process is assigned additional memory regions called **stack** (for
    allocation of function call frames with auto variables and function arguments)
    and *heap* for dynamic allocations at runtime.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的二进制映像包含**代码**（带有所有二进制指令）和**数据**（带有所有全局数据），这些数据被映射到具有适当访问权限（读、写和执行）的内存区域。除了代码和数据，进程还被分配了额外的内存区域，称为**堆栈**（用于分配带有自动变量和函数参数的函数调用帧）和*堆*（用于运行时的动态分配）。
- en: Multiple instances of the same program can exist with their respective memory
    allocations. For instance, for a web browser with multiple open tabs (running
    simultaneous browsing sessions), each tab is considered a process instance by
    the kernel, with unique memory allocations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 同一程序的多个实例可以存在，它们具有各自的内存分配。例如，对于具有多个打开标签页的网络浏览器（同时运行浏览会话），内核将每个标签页视为一个进程实例，并分配唯一的内存。
- en: 'The following figure represents the layout of processes in memory:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了内存中进程的布局：
- en: '![](img/00005.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00005.jpeg)'
- en: The illusion called address space
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 被称为地址空间的幻觉
- en: Modern-day computing platforms are expected to handle a plethora of processes
    efficiently. Operating systems thus must deal with allocating unique memory to
    all contending processes within the physical memory (often finite) and also ensure
    their reliable execution. With multiple processes contending and executing simultaneously
    (*multi-tasking*), the operating system must ensure that the memory allocation
    of every process is protected from accidental access by another process.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算平台预期能够有效地处理大量进程。因此，操作系统必须处理为所有竞争进程在物理内存中分配唯一内存，并确保它们可靠地执行。随着多个进程同时竞争和执行（*多任务处理*），操作系统必须确保每个进程的内存分配受到另一个进程的意外访问的保护。
- en: To address this issue, the kernel provides a level of abstraction between the
    process and the physical memory called *virtual* *address space*. Virtual address
    space is the process' view of memory; it is how the running program views the
    memory.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，内核在进程和物理内存之间提供了一层抽象，称为*虚拟* *地址空间*。虚拟地址空间是进程对内存的视图；这是运行程序查看内存的方式。
- en: Virtual address space creates an illusion that every process exclusively owns
    the whole memory while executing. This abstracted view of memory is called *virtual
    memory* and is achieved by the kernel's memory manager in coordination with the
    CPU's MMU. Each process is given a contiguous 32 or 64-bit address space, bound
    by the architecture and unique to that process. With each process caged into its
    virtual address space by the MMU, any attempt by a process to access an address
    region outside its boundaries will trigger a hardware fault, making it possible
    for the memory manger to detect and terminate violating processes, thus ensuring
    protection.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟地址空间创建了一个幻觉，即每个进程在执行时独占整个内存。这种内存的抽象视图称为*虚拟内存*，是由内核的内存管理器与CPU的MMU协调实现的。每个进程都被赋予一个连续的32位或64位地址空间，由体系结构限制并且对该进程唯一。通过MMU将每个进程限制在其虚拟地址空间中，任何进程试图访问其边界之外的地址区域的尝试都将触发硬件故障，使得内存管理器能够检测和终止违规进程，从而确保保护。
- en: 'The following figure depicts the illusion of address space created for every
    contending process:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图描述了为每个竞争进程创建的地址空间的幻觉：
- en: '![](img/00006.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00006.jpeg)'
- en: Kernel and user space
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核和用户空间
- en: Modern operating systems not only prevent one process from accessing another
    but also prevent processes from accidentally accessing or manipulating kernel
    data and services (as the kernel is shared by all the processes).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现代操作系统不仅防止一个进程访问另一个进程，还防止进程意外访问或操纵内核数据和服务（因为内核被所有进程共享）。
- en: Operating systems achieve this protection by segmenting the whole memory into
    two logical halves, the user and kernel space. This bifurcation ensures that all
    processes that are assigned address spaces are mapped to the user space section
    of memory and kernel data and services run in kernel space. The kernel achieves
    this protection in coordination with the hardware. While an application process
    is executing instructions from its code segment, the CPU is operating in user
    mode. When a process intends to invoke a kernel service, it needs to switch the
    CPU into privileged mode (kernel mode), which is achieved through special functions
    called APIs (application programming interfaces). These APIs enable user processes
    to switch into the kernel space using special CPU instructions and then execute
    the required services through *system calls*. On completion of the requested service,
    the kernel executes another mode switch, this time back from kernel mode to user
    mode, using another set of CPU instructions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统通过将整个内存分成两个逻辑部分，用户空间和内核空间，来实现这种保护。这种分割确保了所有被分配地址空间的进程都映射到内存的用户空间部分，而内核数据和服务则在内核空间中运行。内核通过与硬件协调实现了这种保护。当应用进程从其代码段执行指令时，CPU处于用户模式。当一个进程打算调用内核服务时，它需要将CPU切换到特权模式（内核模式），这是通过称为API（应用程序编程接口）的特殊函数实现的。这些API使用户进程可以使用特殊的CPU指令切换到内核空间，然后通过*系统调用*执行所需的服务。在完成所请求的服务后，内核执行另一个模式切换，这次是从内核模式切换回用户模式，使用另一组CPU指令。
- en: System calls are the kernel's interfaces to expose its services to application
    processes; they are also called *kernel entry points*. As system calls are implemented
    in kernel space, the respective handlers are provided through APIs in the user
    space. API abstraction also makes it easier and convenient to invoke related system
    calls.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用是内核向应用进程公开其服务的接口；它们也被称为*内核入口点*。由于系统调用是在内核空间中实现的，相应的处理程序通过用户空间中的API提供。API抽象还使调用相关系统调用更容易和方便。
- en: 'The following figure depicts a virtualized memory view:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了虚拟化内存视图：
- en: '![](img/00007.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00007.jpeg)'
- en: Process context
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程上下文
- en: When a process requests a kernel service through a system call, the kernel will
    execute on behalf of the caller process. The kernel is now said to be executing
    in *process context*. Similarly, the kernel also responds to *interrupts* raised
    by other hardware entities; here, the kernel executes in *interrupt context*.
    When in interrupt context, the kernel is not running on behalf of any process.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程通过系统调用请求内核服务时，内核将代表调用进程执行。此时内核被称为处于*进程上下文*中执行。同样，内核也会响应其他硬件实体引发的*中断*；在这里，内核在*中断上下文*中执行。在中断上下文中，内核不是代表任何进程运行。
- en: Process descriptors
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程描述符
- en: Right from the time a process is born until it exits, it’s the kernel's process
    management subsystem that carries out various operations, ranging from process
    creation, allocating CPU time, and event notifications to destruction of the process
    upon termination.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个进程诞生到退出，都是内核的进程管理子系统执行各种操作，包括进程创建、分配CPU时间、事件通知以及进程终止时的销毁。
- en: 'Apart from the address space, a process in memory is also assigned a data structure
    called the *process descriptor*, which the kernel uses to identify, manage, and
    schedule the process. The following figure depicts process address spaces with
    their respective process descriptors in the kernel:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了地址空间外，内存中的一个进程还被分配了一个称为*进程描述符*的数据结构，内核用它来识别、管理和调度进程。下图描述了内核中进程地址空间及其相应的进程描述符：
- en: '![](img/00008.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00008.jpeg)'
- en: In Linux, a process descriptor is an instance of type `struct task_struct` defined
    in `<linux/sched.h>`, it is one of the central data structures, and contains all
    the attributes, identification details, and resource allocation entries that a
    process holds. Looking at `struct task_struct` is like a peek into the window
    of what the kernel sees or works with to manage and schedule a process.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，进程描述符是在`<linux/sched.h>`中定义的`struct task_struct`类型的实例，它是一个中心数据结构，包含了进程持有的所有属性、标识细节和资源分配条目。查看`struct
    task_struct`就像窥视内核看到或处理进程的窗口。
- en: Since the task structure contains a wide set of data elements, which are related
    to the functionality of various kernel subsystems, it would be out of context
    to discuss the purpose and scope of all the elements in this chapter. We shall
    consider a few important elements that are related to process management.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任务结构包含了与各种内核子系统功能相关的广泛数据元素，本章讨论所有元素的目的和范围将超出上下文。我们将考虑一些与进程管理相关的重要元素。
- en: Process attributes - key elements
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程属性-关键元素
- en: Process attributes define all the key and fundamental characteristics of a process.
    These elements contain the process's state and identifications along with other
    key values of importance.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 进程属性定义了进程的所有关键和基本特征。这些元素包含了进程的状态和标识以及其他重要的关键值。
- en: state
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态
- en: 'A process right from the time it is spawned until it exits may exist in various
    states, referred to as *process states*--they define the process’s current state:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程从产生到退出可能存在于各种状态，称为*进程状态*，它们定义了进程的当前状态：
- en: '**TASK_RUNNING** (0): The task is either executing or contending for CPU in
    the scheduler run-queue.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TASK_RUNNING** (0)：任务正在执行或在调度器运行队列中争夺CPU。'
- en: '**TASK_INTERRUPTIBLE** (1): The task is in an interruptible wait state; it
    remains in wait until an awaited condition becomes true, such as the availability
    of mutual exclusion locks, device ready for I/O, lapse of sleep time, or an exclusive
    wake-up call. While in this wait state, any signals generated for the process
    are delivered, causing it to wake up before the wait condition is met.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TASK_INTERRUPTIBLE**（1）：任务处于可中断的等待状态；它会一直等待，直到等待条件变为真，比如互斥锁的可用性、设备准备好进行I/O、休眠时间已过或者独占唤醒调用。在这种等待状态下，为进程生成的任何信号都会被传递，导致它在等待条件满足之前被唤醒。'
- en: '**TASK_KILLABLE**: This is similar to **TASK_INTERRUPTIBLE**, with the exception
    that interruptions can only occur on fatal signals, which makes it a better alternative
    to **TASK_INTERRUPTIBLE**.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TASK_KILLABLE**：这类似于**TASK_INTERRUPTIBLE**，唯一的区别是中断只能发生在致命信号上，这使得它成为**TASK_INTERRUPTIBLE**的更好替代品。'
- en: '**TASK_UNINTERRUTPIBLE** (2): The task is in uninterruptible wait state similar
    to **TASK_INTERRUPTIBLE**, except that generated signals to the sleeping process
    do not cause wake-up. When the event occurs for which it is waiting, the process
    transitions to **TASK_RUNNING**. This process state is rarely used.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TASK_UNINTERRUTPIBLE**（2）：任务处于不可中断的等待状态，类似于**TASK_INTERRUPTIBLE**，只是对于正在睡眠的进程生成的信号不会导致唤醒。当等待的事件发生时，进程转换为**TASK_RUNNING**。这种进程状态很少被使用。'
- en: '**TASK_ STOPPED** (4): The task has received a STOP signal. It will be back
    to running on receiving the continue signal (SIGCONT).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TASK_STOPPED**（4）：任务已收到STOP信号。在收到继续信号（SIGCONT）后将恢复运行。'
- en: '**TASK_TRACED** (8): A process is said to be in traced state when it is being
    combed, probably by a debugger.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TASK_TRACED**（8）：当进程正在被梳理时，它被称为处于被跟踪状态，可能是由调试器进行的。'
- en: '**EXIT_ZOMBIE** (32): The process is terminated, but its resources are not
    yet reclaimed.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EXIT_ZOMBIE**（32）：进程已终止，但其资源尚未被回收。'
- en: '**EXIT_DEAD** (16): The child is terminated and all the resources held by it
    freed, after the parent collects the exit status of the child using *wait*.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EXIT_DEAD**（16）：子进程已终止，并且在父进程使用*wait*收集子进程的退出状态后，所有其持有的资源都被释放。'
- en: 'The following figure depicts process states:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了进程状态：
- en: '![](img/00009.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00009.jpeg)'
- en: pid
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pid
- en: This field contains a unique process identifier referred to as **PID**. PIDs
    in Linux are of the type `pid_t` (integer). Though a PID is an integer, the default
    maximum number PIDs is 32,768 specified through the `/proc/sys/kernel/pid_max`
    interface. The value in this file can be set to any value up to 2^(22) (`PID_MAX_LIMIT`,
    approximately 4 million).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段包含一个称为**PID**的唯一进程标识符。在Linux中，PID的类型为`pid_t`（整数）。尽管PID是一个整数，但默认的最大PID数量是32,768，通过`/proc/sys/kernel/pid_max`接口指定。该文件中的值可以设置为最多2^(22)（`PID_MAX_LIMIT`，约400万）的任何值。
- en: To manage PIDs, the kernel uses a bitmap. This bitmap allows the kernel to keep
    track of PIDs in use and assign a unique PID for new processes. Each PID is identified
    by a bit in the PID bitmap; the value of a PID is determined from the position
    of its corresponding bit. Bits with value 1 in the bitmap indicate that the corresponding
    PIDs are in *use*, and those with value 0 indicate free PIDs. Whenever the kernel
    needs to assign a unique PID, it looks for the first unset bit and sets it to
    1, and conversely to free a PID, it toggles the corresponding bit from 1 to 0.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理PID，内核使用位图。该位图允许内核跟踪正在使用的PID并为新进程分配唯一的PID。每个PID在PID位图中由一个位标识；PID的值是根据其对应位的位置确定的。位图中值为1的位表示对应的PID正在*使用*，值为0的位表示空闲的PID。每当内核需要分配一个唯一的PID时，它会寻找第一个未设置的位并将其设置为1，反之，要释放一个PID，它会将对应的位从1切换为0。
- en: tgid
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: tgid
- en: This field contains the thread group id. For easy understanding, let's say when
    a new process is created, its PID and TGID are the same, as the process happens
    to be the only thread. When the process spawns a new thread, the new child gets
    a unique PID but inherits the TGID from the parent, as it belongs to the same
    thread group. The TGID is primarily used to support multi-threaded process. We
    will delve into further details in the threads section of this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段包含线程组ID。为了便于理解，可以这样说，当创建一个新进程时，其PID和TGID是相同的，因为该进程恰好是唯一的线程。当进程生成一个新线程时，新的子线程会获得一个唯一的PID，但会继承父线程的TGID，因为它属于同一线程组。TGID主要用于支持多线程进程。我们将在本章的线程部分详细介绍。
- en: thread info
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程信息
- en: This field holds processor-specific state information, and is a critical element
    of the task structure. Later sections of this chapter contain details about the
    importance of `thread_info`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段包含特定于处理器的状态信息，是任务结构的关键要素。本章的后续部分将详细介绍`thread_info`的重要性。
- en: flags
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标志
- en: 'The flags field records various attributes corresponding to a process. Each
    bit in the field corresponds to various stages in the lifetime of a process. Per-process
    flags are defined in `<linux/sched.h>`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 标志字段记录与进程对应的各种属性。字段中的每个位对应进程生命周期中的各个阶段。每个进程的标志在`<linux/sched.h>`中定义：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: exit_code and exit_signal
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: exit_code和exit_signal
- en: These fields contain the exit value of the task and details of the signal that
    caused the termination. These fields are to be accessed by the parent process
    through `wait()` on termination of the child.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段包含任务的退出值和导致终止的信号的详细信息。这些字段在子进程终止时通过`wait()`由父进程访问。
- en: comm
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: comm
- en: This field holds the name of the binary executable used to start the process.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段保存了用于启动进程的可执行二进制文件的名称。
- en: ptrace
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ptrace
- en: This field is enabled and set when the process is put into trace mode using
    the `ptrace()` system call.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段在使用`ptrace()`系统调用将进程置于跟踪模式时启用并设置。
- en: Process relations - key elements
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程关系-关键要素
- en: Every process can be related to a parent process, establishing a parent-child
    relationship. Similarly, multiple processes spawned by the same process are called
    *siblings*. These fields establish how the current process relates to another
    process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都可以与父进程建立父子关系。同样，由同一进程生成的多个进程被称为*兄弟进程*。这些字段建立了当前进程与另一个进程的关系。
- en: real_parent and parent
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: real_parent和parent
- en: These are pointers to the parent's task structure. For a normal process, both
    these pointers refer to the same `task_struct`*;* they only differ for multi-thread
    processes, implemented using `posix` threads. For such cases, `real_parent` refers
    to the parent thread task structure and parent refers the process task structure
    to which SIGCHLD is delivered.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是指向父任务结构的指针。对于正常进程，这两个指针都指向相同的`task_struct`*；*它们只在使用`posix`线程实现的多线程进程中有所不同。对于这种情况，`real_parent`指的是父线程任务结构，而`parent`指的是将SIGCHLD传递给的进程任务结构。
- en: children
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子进程
- en: This is a pointer to a list of child task structures.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是子任务结构列表的指针。
- en: sibling
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 兄弟
- en: This is a pointer to a list of sibling task structures.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是兄弟任务结构列表的指针。
- en: group_leader
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: group_leader
- en: This is a pointer to the task structure of the process group leader.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是指向进程组领导者的任务结构的指针。
- en: Scheduling attributes - key elements
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度属性 - 关键元素
- en: All contending processes must be given fair CPU time, and this calls for scheduling
    based on time slices and process priorities. These attributes contain necessary
    information that the scheduler uses when deciding on which process gets priority
    when contending.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所有竞争进程必须获得公平的CPU时间，因此需要基于时间片和进程优先级进行调度。这些属性包含调度程序在决定哪个进程获得优先级时使用的必要信息。
- en: prio and static_prio
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: prio和static_prio
- en: '`prio` helps determine the priority of the process for scheduling. This field
    holds static priority of the process within the range `1` to `99` (as specified
    by `sched_setscheduler()`) if the process is assigned a real-time scheduling policy.
    For normal processes, this field holds a dynamic priority derived from the nice
    value.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`prio`有助于确定进程的调度优先级。如果进程被分配了实时调度策略，则此字段在`1`到`99`的范围内保存进程的静态优先级（由`sched_setscheduler()`指定）。对于正常进程，此字段保存从nice值派生的动态优先级。'
- en: se, rt, and dl
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: se、rt和dl
- en: Every task belongs to a scheduling entity (group of tasks), as scheduling is
    done at a per-entity level. `se` is for all normal processes, `rt` is for real-time
    processes, and `dl` is for deadline processes. We will discuss more on these attributes
    in the next chapter on scheduling.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务都属于调度实体（任务组），因为调度是在每个实体级别上进行的。`se`用于所有正常进程，`rt`用于实时进程，`dl`用于截止进程。我们将在下一章中更多地讨论这些属性。
- en: policy
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略
- en: This field contains information about the scheduling policy of the process,
    which helps in determining its priority.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段包含有关进程调度策略的信息，有助于确定其优先级。
- en: cpus_allowed
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cpus_allowed
- en: This field specifies the CPU mask for the process, that is, on which CPU(s)
    the process is eligible to be scheduled in a multi-processor system.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段指定进程的CPU掩码，即进程在多处理器系统中有资格被调度到哪个CPU。
- en: rt_priority
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rt_priority
- en: This field specifies the priority to be applied by real-time scheduling policies.
    For non-real-time processes, this field is unused.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段指定实时调度策略应用的优先级。对于非实时进程，此字段未使用。
- en: Process limits - key elements
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程限制 - 关键元素
- en: The kernel imposes resource limits to ensure fair allocation of system resources
    among contending processes. These limits guarantee that a random process does
    not monopolize ownership of resources. There are 16 different types of resource
    limits, and the `task structure` points to an array of type `struct rlimit`*,*
    in which each offset holds the current and maximum values for a specific resource.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 内核强加资源限制，以确保系统资源在竞争进程之间公平分配。这些限制保证随机进程不会垄断资源的所有权。有16种不同类型的资源限制，`task structure`指向`struct
    rlimit`*类型的数组，其中每个偏移量保存特定资源的当前值和最大值。
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: File descriptor table - key elements
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件描述符表 - 关键元素
- en: During the lifetime of a process, it may access various resource files to get
    its task done. This results in the process opening, closing, reading, and writing
    to these files. The system must keep track of these activities; file descriptor
    elements help the system know which files the process holds.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程的生命周期中，它可能访问各种资源文件以完成其任务。这导致进程打开、关闭、读取和写入这些文件。系统必须跟踪这些活动；文件描述符元素帮助系统知道进程持有哪些文件。
- en: fs
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs
- en: Filesystem information is stored in this field.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统信息存储在此字段中。
- en: files
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件
- en: The file descriptor table contains pointers to all the files that a process
    opens to perform various operations. The files field contains a pointer, which
    points to this file descriptor table.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符表包含指向进程打开以执行各种操作的所有文件的指针。文件字段包含一个指针，指向此文件描述符表。
- en: Signal descriptor - key elements
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号描述符 - 关键元素
- en: For processes to handle signals, the *task structure* has various elements that
    determine how the signals must be handled.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理信号，*任务结构*具有各种元素，确定信号的处理方式。
- en: signal
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号
- en: This is of type `struct signal_struct`*,* which contains information on all
    the signals associated with the process.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`struct signal_struct`*的类型，其中包含与进程关联的所有信号的信息。
- en: sighand
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sighand
- en: This is of type `struct sighand_struct`*,* which contains all signal handlers
    associated with the process.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`struct sighand_struct`*的类型，其中包含与进程关联的所有信号处理程序。
- en: sigset_t blocked, real_blocked
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sigset_t blocked, real_blocked
- en: These elements identify signals that are currently masked or blocked by the
    process.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元素标识当前由进程屏蔽或阻塞的信号。
- en: pending
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 待处理
- en: This is of type `struct sigpending`*,* which identifies signals which are generated
    but not yet delivered.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`struct sigpending`*的类型，用于标识生成但尚未传递的信号。
- en: sas_ss_sp
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sas_ss_sp
- en: This field contains a pointer to an alternate stack, which facilitates signal
    handling.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段包含指向备用堆栈的指针，用于信号处理。
- en: sas_ss_size
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sas_ss_size
- en: This filed shows the size of the alternate stack, used for signal handling.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此字段显示备用堆栈的大小，用于信号处理。
- en: Kernel stack
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核堆栈
- en: With current-generation computing platforms powered by multi-core hardware capable
    of running simultaneous applications, the possibility of multiple processes concurrently
    initiating kernel mode switch when requesting for the same process is built in.
    To be able to handle such situations, kernel services are designed to be re-entrant,
    allowing multiple processes to step in and engage the required services. This
    mandated the requesting process to maintain its own private kernel stack to keep
    track of the kernel function call sequence, store local data of the kernel functions,
    and so on.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 随着当前一代计算平台由能够运行同时应用程序的多核硬件驱动，当请求相同进程时，多个进程同时启动内核模式切换的可能性已经内置。为了能够处理这种情况，内核服务被设计为可重入，允许多个进程参与并使用所需的服务。这要求请求进程维护自己的私有内核栈，以跟踪内核函数调用序列，存储内核函数的本地数据等。
- en: The kernel stack is directly mapped to the physical memory, mandating the arrangement
    to be physically in a contiguous region. The kernel stack by default is 8kb for
    x86-32 and most other 32-bit systems (with an option of 4k kernel stack to be
    configured during kernel build), and 16kb on an x86-64 system.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 内核栈直接映射到物理内存，要求布局在一个连续的区域内。默认情况下，x86-32和大多数其他32位系统的内核栈为8kb（在内核构建期间可以配置为4k内核栈），在x86-64系统上为16kb。
- en: 'When kernel services are invoked in the current process context, they need
    to validate the process’s prerogative before it commits to any relevant operations.
    To perform such validations, the kernel services must gain access to the task
    structure of the current process and look through the relevant fields. Similarly,
    kernel routines might need to have access to the current `task structure` for
    modifying various resource structures such as signal handler tables, looking for
    pending signals, file descriptor table, and memory descriptor among others. To
    enable accessing the `task structure` at runtime, the address of the current `task
    structure` is loaded into a processor register (register chosen is architecture
    specific) and made available through a kernel global macro called `current` (defined
    in architecture-specific kernel header `asm/current.h` ):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当内核服务在当前进程上下文中被调用时，它们需要在承诺任何相关操作之前验证进程的特权。为了执行这样的验证，内核服务必须访问当前进程的任务结构并查看相关字段。同样，内核例程可能需要访问当前的“任务结构”来修改各种资源结构，例如信号处理程序表，寻找未决信号，文件描述符表和内存描述符等。为了在运行时访问“任务结构”，当前“任务结构”的地址被加载到处理器寄存器中（所选择的寄存器是特定于架构的），并通过内核全局宏`current`（在特定于架构的内核头文件`asm/current.h`中定义）提供：
- en: '[PRE2]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: However, in register-constricted architectures, where there are few registers
    to spare, reserving a register to hold the address of the current task structure
    is not viable. On such platforms, the `task structure` of the current process
    is directly made available at the top of the kernel stack that it owns. This approach
    renders a significant advantage with respect to locating the `task structure`,
    by just masking the least significant bits of the stack pointer.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在寄存器受限的架构中，如果寄存器很少，那么保留一个寄存器来保存当前任务结构的地址是不可行的。在这样的平台上，当前进程的“任务结构”直接放置在它拥有的内核栈的顶部。这种方法在定位“任务结构”方面具有显著优势，只需屏蔽栈指针的最低有效位即可。
- en: With the evolution of the kernel, the `task structure` grew and became too large
    to be contained in the kernel stack, which is already restricted in physical memory
    (8Kb). As a result, the `task structure` was moved out of the kernel stack, barring
    a few key fields that define the process's CPU state and other low-level processor-specific
    information. These fields were then wrapped in a newly created structure called
    `struct thread_info`*.* This structure is contained on top of the kernel stack
    and provides a pointer that refers to the current `task structure`, which can
    be used by kernel services.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 随着内核的演变，`任务结构`变得越来越大，无法包含在内核栈中，而内核栈在物理内存中已经受限（8Kb）。因此，`任务结构`被移出内核栈，除了定义进程的CPU状态和其他低级处理器特定信息的一些关键字段之外。然后，这些字段被包装在一个新创建的结构体`struct
    thread_info`中。这个结构体位于内核栈的顶部，并提供一个指针，指向可以被内核服务使用的当前`任务结构`。
- en: '[PRE3]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With `thread_info` containing process-related information, apart from `task
    structure`, the kernel has multiple viewpoints to the current process structure:
    `struct task_struct`, an architecture-independent information block, and `thread_info`,
    an architecture-specific one. The following figure depicts **thread_info** and
    **task_struct**:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`thread_info`包含与进程相关的信息，除了`任务结构`之外，内核对当前进程结构有多个视图：`struct task_struct`，一个与架构无关的信息块，以及`thread_info`，一个特定于架构的信息块。以下图示了`thread_info`和`task_struct`：
- en: '![](img/00010.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00010.jpeg)'
- en: 'For architectures that engage `thread_info`*,* the current macro''s implementation
    is modified to look into the top of kernel stack to obtain a reference to the
    current `thread_info` and through it the `current task structure`. The following
    code snippet shows the implementation of current for an x86-64 platform:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用`thread_info`的架构，当前宏的实现被修改为查看内核栈顶部以获取对当前`thread_info`和通过它对`当前任务结构`的引用。以下代码片段显示了x86-64平台的当前实现：
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**[PRE6]'
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The issue of stack overflow
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈溢出问题
- en: Unlike user mode, the kernel mode stack lives in directly mapped memory. When
    a process invokes a kernel service, which may internally be deeply nested, chances
    are that it may overrun into immediate memory range. The worst part of it is the
    kernel will be oblivious to such occurrences. Kernel programmers usually engage
    various debug options to track stack usage and detect overruns, but these methods
    are not handy to prevent stack breaches on production systems. Conventional protection
    through the use of *guard pages* is also ruled out here (as it wastes an actual
    memory page).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与用户模式不同，内核模式堆栈存在于直接映射的内存中。当一个进程调用内核服务时，可能会出现内部嵌套深的情况，有可能会超出立即内存范围。最糟糕的是内核对这种情况毫不知情。内核程序员通常会使用各种调试选项来跟踪堆栈使用情况并检测溢出，但这些方法并不方便在生产系统上防止堆栈溢出。通过使用*守护页面*进行传统保护在这里也被排除了（因为这会浪费一个实际的内存页面）。
- en: Kernel programmers tend to follow coding standards--minimizing the use of local
    data, avoiding recursion, and avoiding deep nesting among others--to cut down
    the probability of a stack breach. However, implementation of feature-rich and
    deeply layered kernel subsystems may pose various design challenges and complications,
    especially with the storage subsystem where filesystems, storage drivers, and
    networking code can be stacked up in several layers, resulting in deeply nested
    function calls.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 内核程序员倾向于遵循编码标准--最小化使用本地数据，避免递归，避免深度嵌套等--以降低堆栈溢出的概率。然而，实现功能丰富且深度分层的内核子系统可能会带来各种设计挑战和复杂性，特别是在存储子系统中，文件系统、存储驱动程序和网络代码可以堆叠在几个层中，导致深度嵌套的函数调用。
- en: The Linux kernel community has been pondering over preventing such breaches
    for quite long, and toward that end, the decision was made to expand the kernel
    stack to 16kb (x86-64, since kernel 3.15). Expansion of the kernel stack might
    prevent some breaches, but at the cost of engaging much of the directly mapped
    kernel memory for the per-process kernel stack. However, for reliable functioning
    of the system, it is expected of the kernel to elegantly handle stack breaches
    when they show up on production systems.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核社区一直在思考如何防止这种溢出，为此，决定将内核堆栈扩展到16kb（x86-64，自内核3.15以来）。扩展内核堆栈可能会防止一些溢出，但会占用大量直接映射的内核内存用于每个进程的内核堆栈。然而，为了系统的可靠运行，期望内核能够优雅地处理在生产系统上出现的堆栈溢出。
- en: With the 4.9 release, the kernel has come with a new system to set up virtually
    mapped kernel stacks. Since virtual addresses are currently in use to map even
    a directly mapped page, principally the kernel stack does not actually require
    physically contiguous pages. The kernel reserves a separate range of addresses
    for virtually mapped memory, and addresses from this range are allocated when
    a call to `vmalloc()` is made. This range of memory is referred as the **vmalloc
    range**. Primarily this range is used when programs require huge chunks of memory
    which are virtually contiguous but physically scattered. Using this, the kernel
    stack can now be allotted as individual pages, mapped to the vmalloc range. Virtual
    mapping also enables protection from overruns as a no-access guard page can be
    allocated with a page table entry (without wasting an actual page). Guard pages
    would prompt the kernel to pop an oops message on memory overrun and initiate
    a kill against overrunning process.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在4.9版本中，内核引入了一种新的系统来设置虚拟映射内核堆栈。由于虚拟地址目前用于映射甚至是直接映射的页面，因此内核堆栈实际上并不需要物理上连续的页面。内核为虚拟映射内存保留了一个单独的地址范围，当调用`vmalloc()`时，这个范围内的地址被分配。这段内存范围被称为**vmalloc范围**。主要用于当程序需要大块虚拟连续但物理分散的内存时。使用这种方法，内核堆栈现在可以分配为单独的页面，映射到vmalloc范围。虚拟映射还可以防止溢出，因为可以分配一个无访问守护页面，并且可以通过页表项（而不浪费实际页面）来分配。守护页面将促使内核在内存溢出时弹出一个oops消息，并对溢出的进程发起kill。
- en: Virtually mapped kernel stacks with guard pages are currently available only
    for the x86-64 architecture (support for other architectures seemingly to follow).
    This can be enabled by choosing the `HAVE_ARCH_VMAP_STACK` or `CONFIG_VMAP_STACK`
    build-time options.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，带有守护页面的虚拟映射内核堆栈仅适用于x86-64架构（对其他架构的支持似乎将会跟进）。这可以通过选择`HAVE_ARCH_VMAP_STACK`或`CONFIG_VMAP_STACK`构建时选项来启用。
- en: Process creation
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程创建
- en: During kernel boot, a kernel thread called `init is` spawned, which in turn
    is configured to initialize the first user-mode process (with the same name).
    The `init` (pid 1) process is then configured to carry out various initialization
    operations specified through configuration files, creating multiple processes.
    Every child process further created (which may in turn create its own child process(es))
    are all descendants of the *init* process. Processes thus created end up in a
    tree-like structure or a single hierarchy model. The `shell`, which is one such
    process, becomes the interface for users to create user processes, when programs
    are called for execution.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核引导期间，会生成一个名为`init`的内核线程，该线程被配置为初始化第一个用户模式进程（具有相同的名称）。然后，`init`（pid 1）进程被配置为执行通过配置文件指定的各种初始化操作，创建多个进程。进一步创建的每个子进程（可能会创建自己的子进程）都是*init*进程的后代。因此，这些进程最终形成了一个类似树状结构或单一层次模型的结构。`shell`，就是这样一个进程，当调用程序执行时，它成为用户创建用户进程的接口。
- en: Fork, vfork, exec, clone, wait and exit are the core kernel interfaces for the
    creation and control of new process. These operations are invoked through corresponding
    user-mode APIs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Fork、vfork、exec、clone、wait和exit是用于创建和控制新进程的核心内核接口。这些操作是通过相应的用户模式API调用的。
- en: fork()
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fork()
- en: '`Fork()` is one of the core "Unix thread APIs" available across *nix systems
    since the inception of legacy Unix releases. Aptly named, it forks a new process
    from a running process. When `fork()` succeeds, the new process is created (referred
    to as `child`) by duplicating the caller''s `address space` and `task structure`.
    On return from `fork()`, both caller (parent) and new process (child) resume executing
    instructions from the same code segment which was duplicated under copy-on-write.
    `Fork()` is perhaps the only API that enters kernel mode in the context of caller
    process, and on success returns to user mode in the context of both caller and
    child (new process).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fork()`是自* nix系统的核心“Unix线程API”之一，自古老的Unix版本问世以来一直可用。恰如其名，它从运行中的进程中分叉出一个新进程。当`fork()`成功时，通过复制调用者的`地址空间`和`任务结构`创建新进程（称为`子进程`）。从`fork()`返回时，调用者（父进程）和新进程（子进程）都从同一代码段中执行指令，该代码段在写时复制下被复制。`Fork()`也许是唯一一个以调用者进程的上下文进入内核模式的API，并在成功时返回到调用者和子进程（新进程）的用户模式上下文。'
- en: Most resource entries of the parent's `task structure` such as memory descriptor,
    file descriptor table, signal descriptors, and scheduling attributes are inherited
    by the child, except for a few attributes such as memory locks, pending signals,
    active timers, and file record locks (for the full list of exceptions, refer to
    the fork(2) man page). A child process is assigned a unique `pid` and will refer
    to its parent's `pid` through the `ppid` field of its `task structure`*;* the
    child’s resource utilization and processor usage entries are reset to zero.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程的`任务结构`的大多数资源条目，如内存描述符、文件描述符表、信号描述符和调度属性，都被子进程继承，除了一些属性，如内存锁、未决信号、活动定时器和文件记录锁（有关例外的完整列表，请参阅fork(2)手册页）。子进程被分配一个唯一的`pid`，并通过其`任务结构`的`ppid`字段引用其父进程的`pid`；子进程的资源利用和处理器使用条目被重置为零。
- en: The parent process updates itself about the child’s state using the `wait()`
    system call and normally waits for the termination of the child process. Failing
    to call `wait()`*,* the child may terminate and be pushed into a zombie state.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程使用`wait()`系统调用更新自己关于子进程状态的信息，并通常等待子进程的终止。如果没有调用`wait()`，子进程可能会终止并进入僵尸状态。
- en: Copy-on-write (COW)
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写时复制（COW）
- en: Duplication of parent process to create a child needs cloning of the user mode
    address space (`stack`, `data`, `code`, and `heap` segments) and task structure
    of the parent for the child; this would result in execution overhead that leads
    to un-deterministic process-creation time. To make matters worse, this process
    of cloning would be rendered useless if neither parent nor child did not initiate
    any state-change operations on cloned resources.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程的复制以创建子进程需要克隆用户模式地址空间（`堆栈`、`数据`、`代码`和`堆`段）和父进程的任务结构，这将导致执行开销，从而导致不确定的进程创建时间。更糟糕的是，如果父进程和子进程都没有对克隆资源进行任何状态更改操作，这种克隆过程将变得毫无意义。
- en: As per COW, when a child is created, it is allocated a unique `task structure`
    with all resource entries (including page tables) referring to the parent's `task
    structure`, with read-only access for both parent and child. Resources are truly
    duplicated when either of the processes initiates a state change operation, hence
    the name *copy-on-write* (`write` in COW implies a state change). COW does bring
    effectiveness and optimization to the fore, by deferring the need for duplicating
    process data until write, and in cases where only read happens, it avoids it altogether.
    This on-demand copying also reduces the number of swap pages needed, cuts down
    the time spent on swapping, and might help reduce demand paging.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 根据COW，当创建子进程时，它被分配一个唯一的`任务结构`，其中所有资源条目（包括页表）都指向父进程的`任务结构`，父子进程都具有只读访问权限。当任一进程启动状态更改操作时，资源才会真正复制，因此称为*写时复制*（COW中的`写`意味着状态更改）。COW确实带来了效率和优化，通过推迟复制进程数据的需求，以及在只读发生时，完全避免复制。这种按需复制还减少了所需的交换页面数量，减少了交换所需的时间，并可能有助于减少需求分页。
- en: exec
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: exec
- en: 'At times creating a child process might not be useful, unless it runs a new
    program altogether: the `exec` family of calls serves precisely this purpose.
    `exec` replaces the existing program in a process with a new executable binary:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时创建子进程可能没有用，除非它运行一个全新的程序：`exec`系列调用正好满足这一目的。`exec`用新的可执行二进制文件替换进程中的现有程序。
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `execve` is the system call that executes the program binary file, passed
    as the first argument to it. The second and third arguments are null-terminated
    arrays of arguments and environment strings, to be passed to a new program as
    command-line arguments. This system call can also be invoked through various `glibc`
    (library) wrappers, which are found to be more convenient and flexible:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`execve`是执行作为其第一个参数传递的程序二进制文件的系统调用。第二和第三个参数是以空字符结尾的参数和环境字符串数组，将作为命令行参数传递给新程序。这个系统调用也可以通过各种`glibc`（库）包装器调用，这些包装器被发现更加方便和灵活。'
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Command-line user-interface programs such as `shell` use the `exec` interface
    to launch user-requested program binaries.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行用户界面程序如`shell`使用`exec`接口启动用户请求的程序二进制文件。
- en: vfork()
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: vfork()
- en: Unlike `fork()`, `vfork()` creates a child process and blocks the parent, which
    means that the child runs as a single thread and does not allow concurrency; in
    other words, the parent process is temporarily suspended until the child exits
    or call `exec()`. The child shares the data of the parent.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 与`fork()`不同，`vfork()`创建一个子进程并阻塞父进程，这意味着子进程作为单个线程运行，不允许并发；换句话说，父进程暂时挂起，直到子进程退出或调用`exec()`。子进程共享父进程的数据。
- en: Linux support for threads
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux对线程的支持
- en: The flow of execution in a process is referred to as a **thread**, which implies
    that every process will at least have one thread of execution. Multi-threaded
    means the existence of multiple flows of execution contexts in a process. With
    modern many-core architectures, multiple flows of execution in a process can be
    truly concurrent, achieving fair multitasking.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 进程中的执行流被称为**线程**，这意味着每个进程至少会有一个执行线程。多线程意味着进程中存在多个执行上下文的流。在现代的多核架构中，进程中的多个执行流可以真正并发，实现公平的多任务处理。
- en: Threads are normally enumerated as pure user-level entities within a process
    that are scheduled for execution; they share parent's virtual address space and
    system resources. Each thread maintains its code, stack, and thread local storage.
    Threads are scheduled and managed by the thread library, which uses a structure
    referred to as a thread object to hold a unique thread identifier, for scheduling
    attributes and to save the thread context. User-level thread applications are
    generally lighter on memory, and are the preferred model of concurrency for event-driven
    applications. On the flip side, such user-level thread model is not suitable for
    parallel computing, since they are tied onto the same processor core to which
    their parent process is bound.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 线程通常被枚举为进程中纯粹的用户级实体，它们被调度执行；它们共享父进程的虚拟地址空间和系统资源。每个线程都维护其代码、堆栈和线程本地存储。线程由线程库调度和管理，它使用一个称为线程对象的结构来保存唯一的线程标识符，用于调度属性和保存线程上下文。用户级线程应用通常在内存上更轻，是事件驱动应用程序的首选并发模型。另一方面，这种用户级线程模型不适合并行计算，因为它们被绑定到其父进程绑定的同一处理器核心上。
- en: Linux doesn’t support user-level threads directly; it instead proposes an alternate
    API to enumerate a special process, called **l****ight weight process** (**LWP**),
    that can share a set of configured resources such as dynamic memory allocations,
    global data, open files, signal handlers, and other extensive resources with the
    parent process. Each LWP is identified by a unique PID and task structure, and
    is treated by the kernel as an independent execution context. In Linux, the term
    thread invariably refers to LWP, since each thread initialized by the thread library
    (`Pthreads`) is enumerated as an LWP by the kernel.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Linux不直接支持用户级线程；相反，它提出了一个替代的API来枚举一个特殊的进程，称为轻量级进程（LWP），它可以与父进程共享一组配置好的资源，如动态内存分配、全局数据、打开的文件、信号处理程序和其他广泛的资源。每个LWP都由唯一的PID和任务结构标识，并且被内核视为独立的执行上下文。在Linux中，术语线程不可避免地指的是LWP，因为由线程库（Pthreads）初始化的每个线程都被内核枚举为LWP。
- en: clone()
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: clone()
- en: '`clone()` is a Linux-specific system call to create a new process; it is considered
    a generic version of the `fork()` system call, offering finer controls to customize
    its functionality through the `flags` argument:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`clone()`是一个Linux特定的系统调用，用于创建一个新的进程；它被认为是`fork()`系统调用的通用版本，通过`flags`参数提供更精细的控制来自定义其功能：'
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It provides more than twenty different `CLONE_*` flags that control various
    aspects of the `clone` operation, including whether the parent and child process
    share resources such as virtual memory, open file descriptors, and signal dispositions.
    The child is created with the appropriate memory address (passed as the second
    argument) to be used as the `stack` (for storing the child's local data). The
    child process starts its execution with its start function (passed as the first
    argument to the clone call).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了超过二十个不同的`CLONE_*`标志，用于控制`clone`操作的各个方面，包括父进程和子进程是否共享虚拟内存、打开文件描述符和信号处理程序。子进程使用适当的内存地址（作为第二个参数传递）作为`堆栈`（用于存储子进程的本地数据）进行创建。子进程使用其启动函数（作为克隆调用的第一个参数）开始执行。
- en: 'When a process attempts to create a thread through the `pthread` library, `clone()`
    is invoked with the following flags:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程尝试通过`pthread`库创建一个线程时，将使用以下标志调用`clone()`：
- en: '[PRE11]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](img/00011.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00011.jpeg)'
- en: 'The `clone()` can also be used to create a regular child process that is normally
    spawned using `fork()` and `vfork()`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`clone()`也可以用于创建一个通常使用`fork()`和`vfork()`生成的常规子进程：'
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Kernel threads
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核线程
- en: To augment the need for running background operations, the kernel spawns threads
    (similar to processes). These kernel threads are similar to regular processes,
    in that they are represented by a task structure and assigned a PID. Unlike user
    processes, they do not have any address space mapped, and run exclusively in kernel
    mode, which makes them non-interactive. Various kernel subsystems use `kthreads`
    to run periodic and asynchronous operations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加运行后台操作的需求，内核生成线程（类似于进程）。这些内核线程类似于常规进程，它们由任务结构表示，并分配一个PID。与用户进程不同，它们没有任何映射的地址空间，并且完全在内核模式下运行，这使它们不可交互。各种内核子系统使用`kthreads`来运行周期性和异步操作。
- en: 'All kernel threads are descendants of `kthreadd (pid 2)`, which is spawned
    by the `kernel (pid 0)` during boot. The `kthreadd` enumerates other kernel threads;
    it provides interface routines through which other kernel threads can be dynamically
    spawned at runtime by kernel services. Kernel threads can be viewed from the command
    line with the `ps -ef` command--they are shown in [square brackets]:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内核线程都是`kthreadd（pid 2）`的后代，它是在引导期间由`kernel（pid 0）`生成的。`kthreadd`枚举其他内核线程；它通过接口例程提供内核服务动态生成其他内核线程的能力。可以使用`ps
    -ef`命令从命令行查看内核线程--它们显示在[方括号]中：
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The previous code shows the kernel boot routine `rest_init()` invoking the `kernel_thread()`
    routine with appropriate arguments to spawn both the `kernel_init` thread (which
    then goes on to start the user-mode `init` process) and `kthreadd`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了内核引导例程`rest_init()`调用`kernel_thread()`例程，并使用适当的参数来生成`kernel_init`线程（然后继续启动用户模式的`init`进程）和`kthreadd`。
- en: 'The `kthread` is a perpetually running thread that looks into a list called
    `kthread_create_list` for data on new `kthreads` to be created:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`kthread`是一个永久运行的线程，它查看一个名为`kthread_create_list`的列表，以获取要创建的新`kthreads`的数据：'
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`kthread_create_on_node()` instantiates details (received as arguments) of
    `kthread` to be created into a structure of type `kthread_create_info` and queues
    it at the tail of `kthread_create_list`. It then wakes up `kthreadd` and waits
    for thread creation to complete:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`kthread_create_on_node()` 将要创建的 `kthread` 的详细信息（作为参数接收）实例化为 `kthread_create_info`
    类型的结构，并将其排队到 `kthread_create_list` 的末尾。然后唤醒 `kthreadd` 并等待线程创建完成：'
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Recall that `kthreadd` invokes the `create_thread()` routine to start kernel
    threads as per data queued into the list. This routine creates the thread and
    signals completion:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`kthreadd` 调用 `create_thread()` 例程来根据排队到列表中的数据启动内核线程。这个例程创建线程并发出完成信号：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: do_fork() and copy_process()
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: do_fork() 和 copy_process()
- en: 'All of the process/thread creation calls discussed so far invoke different
    system calls (except `create_thread`) to step into kernel mode. All of those system
    calls in turn converge into the common kernel `function _do_fork()`, which is
    invoked with distinct `CLONE_*` flags. `do_fork()` internally falls back on `copy_process()`
    to complete the task. The following figure sums up the call sequence for process
    creation:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的所有进程/线程创建调用都会调用不同的系统调用（除了 `create_thread`）进入内核模式。所有这些系统调用最终汇聚到通用内核 `function
    _do_fork()` 中，该函数以不同的 `CLONE_*` 标志调用。`do_fork()` 在内部回退到 `copy_process()` 完成任务。以下图表总结了进程创建的调用顺序：
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](img/00012.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00012.jpeg)'
- en: Process status and termination
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程状态和终止
- en: During the lifetime of a process, it traverses through many states before it
    ultimately terminates. Users must have proper mechanisms to be updated with all
    that happens to a process during its lifetime. Linux provides a set of functions
    for this purpose.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程的生命周期中，它在最终终止之前会遍历许多状态。用户必须具有适当的机制来了解进程在其生命周期中发生的一切。Linux 为此提供了一组函数。
- en: wait
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待
- en: 'For processes and threads created by a parent, it might be functionally useful
    for the parent to know the execution status of the child process/thread. This
    can be achieved using the `wait` family of system calls:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于由父进程创建的进程和线程，父进程知道子进程/线程的执行状态可能是有用的。可以使用 `wait` 系列系统调用来实现这一点：
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'These system calls update the calling process with the state change events
    of a child. The following state change events are notified:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统调用会更新调用进程的状态，以便通知子进程的状态变化事件。
- en: Termination of child
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子进程的终止
- en: Stopped by a signal
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被信号停止
- en: Resumed by a signal
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被信号恢复
- en: In addition to reporting the status, these APIs allow the parent process to
    reap a terminated child. A process on termination is put into zombie state until
    the immediate parent engages the `wait` call to reap it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 除了报告状态，这些 API 还允许父进程收集终止的子进程。进程在终止时被放入僵尸状态，直到其直接父进程调用 `wait` 来收集它。
- en: exit
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 退出
- en: Every process must end. Process termination is done either by the process calling
    `exit()` or when the main function returns. A process may also be terminated abruptly
    on receiving a signal or exception that forces it to terminate, such as the `KILL`
    command, which sends a signal to kill the process, or when an exception is raised.
    Upon termination, the process is put into exit state until the immediate parent
    reaps it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都必须结束。进程的终止是通过进程调用 `exit()` 或主函数返回来完成的。进程也可能在接收到强制其终止的信号或异常时被突然终止，例如发送终止进程的
    `KILL` 命令，或引发异常。在终止时，进程被放入退出状态，直到其直接父进程收集它。
- en: 'The `exit` calls the `sys_exit` system call, which internally calls the `do_exit`
    routine. The `do_exit` primarily performs the following tasks (`do_exit` sets
    many values and makes multiple calls to related kernel routines to complete its
    task):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit` 调用 `sys_exit` 系统调用，该系统调用内部调用 `do_exit` 例程。 `do_exit` 主要执行以下任务（`do_exit`
    设置许多值，并多次调用相关内核例程以完成其任务）：'
- en: Takes the exit code returned by the child to the parent.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取子进程返回给父进程的退出码。
- en: Sets the `PF_EXITING` flag, indicating process exiting.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 `PF_EXITING` 标志，表示进程正在退出。
- en: Cleans up and reclaims the resources held by the process. This includes releasing
    `mm_struct`, removal from the queue if it is waiting for an IPC semaphore, release
    of filesystem data and files, if any, and calling `schedule()` as the process
    is no longer executable.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理和回收进程持有的资源。这包括释放 `mm_struct`，如果进程正在等待 IPC 信号量，则从队列中移除，释放文件系统数据和文件（如果有的话），并在进程不再可执行时调用
    `schedule()`。
- en: After `do_exit`, the process remains in zombie state and the process descriptor
    is still intact for the parent to collect the status, after which the resources
    are reclaimed by the system.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `do_exit` 之后，进程保持僵尸状态，进程描述符仍然完整，父进程可以收集状态，之后系统会回收资源。
- en: Namespaces and cgroups
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间和 cgroups
- en: Users logged into a Linux system have a transparent view of various system entities
    such as global resources, processes, kernel, and users. For instance, a valid
    user can access PIDs of all running processes on the system (irrespective of the
    user to which they belong). Users can observe the presence of other users on the
    system, and they can run commands to view the state of global system global resources
    such as memory, filesystem mounts, and devices. Such operations are not deemed
    as intrusions or considered security breaches, as it is always guaranteed that
    one user/process can never intrude into other user/process.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到 Linux 系统的用户可以透明地查看各种系统实体，如全局资源、进程、内核和用户。例如，有效用户可以访问系统上所有运行进程的 PID（无论它们属于哪个用户）。用户可以观察系统上其他用户的存在，并运行命令查看全局系统资源的状态，如内存、文件系统挂载和设备。这些操作不被视为侵入或被视为安全漏洞，因为始终保证一个用户/进程永远不会侵入其他用户/进程。
- en: However, such transparency is unwarranted on a few server platforms. For instance,
    consider cloud service providers offering **PaaS** (**platform as a service**).
    They offer an environment to host and deploy custom client applications. They
    manage runtime, storage, operating system, middleware, and networking services,
    leaving customers to manage their applications and data. PaaS services are used
    by various e-commerce, financial, online gaming, and other related enterprises.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在一些服务器平台上，这种透明性是不受欢迎的。例如，考虑云服务提供商提供**PaaS**（**平台即服务**）。他们提供一个环境来托管和部署自定义客户端应用程序。他们管理运行时、存储、操作系统、中间件和网络服务，让客户端管理他们的应用程序和数据。各种电子商务、金融、在线游戏和其他相关企业使用PaaS服务。
- en: For efficient and effective isolation and resource management for clients, PaaS
    service providers use various tools. They virtualize the system environment for
    each client to achieve security, reliability, and robustness. The Linux kernel
    provides low-level mechanisms in the form of cgroups and namespaces for building
    various lightweight tools that can virtualize the system environment. Docker is
    one such framework that builds on cgroups and namespaces.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了客户端的高效隔离和资源管理，PaaS服务提供商使用各种工具。他们为每个客户端虚拟化系统环境，以实现安全性、可靠性和健壮性。Linux内核提供了低级机制，以cgroups和命名空间的形式构建各种轻量级工具，可以虚拟化系统环境。Docker就是一个建立在cgroups和命名空间之上的框架。
- en: Namespaces fundamentally are mechanisms to abstract, isolate, and limit the
    visibility that a group of processes has over various system entities such as
    process trees, network interfaces, user IDs, and filesystem mounts. Namespaces
    are categorized into several groups, which we will now see.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间基本上是一种机制，用于抽象、隔离和限制一组进程对诸如进程树、网络接口、用户ID和文件系统挂载等各种系统实体的可见性。命名空间分为几个组，我们现在将看到。
- en: Mount namespaces
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂载命名空间
- en: Traditionally, mount and unmount operations will change the filesystem view
    as seen by all processes in the system; in other words, there is one global mount
    namespace seen by all processes. The mount namespaces confine the set of filesystem
    mount points visible within a process namespace, enabling one process group in
    a mount namespace to have an exclusive view of the filesystem list compared to
    another process.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，挂载和卸载操作会改变系统中所有进程所看到的文件系统视图；换句话说，所有进程都能看到一个全局挂载命名空间。挂载命名空间限制了进程命名空间内可见的文件系统挂载点集合，使得一个挂载命名空间中的一个进程组可以对文件系统列表有独占的视图，与另一个进程相比。
- en: UTS namespaces
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UTS命名空间
- en: These enable isolating the system's host and domain name within a uts namespace.
    This makes initialization and configuration scripts able to be guided based on
    the respective namespaces.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这些使得在uts命名空间中隔离系统的主机和域名成为可能。这使得初始化和配置脚本能够根据各自的命名空间进行引导。
- en: IPC namespaces
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPC命名空间
- en: These demarcate processes from using System V and POSIX message queues. This
    prevents one process from an ipc namespace accessing the resources of another.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将进程从使用System V和POSIX消息队列中分隔出来。这样可以防止一个ipc命名空间内的进程访问另一个ipc命名空间的资源。
- en: PID namespaces
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PID命名空间
- en: Traditionally, *nix kernels (including Linux) spawn the `init` process with
    PID 1 during system boot, which in turn starts other user-mode processes and is
    considered the root of the process tree (all the other processes start below this
    process in the tree). The PID namespace allows a process to spin off a new tree
    of processes under it with its own root process (PID 1 process). PID namespaces
    isolate process ID numbers, and allow duplication of PID numbers across different
    PID namespaces, which means that processes in different PID namespaces can have
    the same process ID. The process IDs within a PID namespace are unique, and are
    assigned sequentially starting with PID 1.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，*nix内核（包括Linux）在系统启动期间使用PID 1生成`init`进程，然后启动其他用户模式进程，并被认为是进程树的根（所有其他进程在树中的这个进程下方启动）。PID命名空间允许进程在其下方产生一个新的进程树，具有自己的根进程（PID
    1进程）。PID命名空间隔离进程ID号，并允许在不同的PID命名空间中复制PID号，这意味着不同PID命名空间中的进程可以具有相同的进程ID。PID命名空间内的进程ID是唯一的，并且从PID
    1开始按顺序分配。
- en: PID namespaces are used in containers (lightweight virtualization solution)
    to migrate a container with a process tree, onto a different host system without
    any changes to PIDs.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: PID命名空间在容器（轻量级虚拟化解决方案）中用于迁移具有进程树的容器到不同的主机系统，而无需更改PID。
- en: Network namespaces
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络命名空间
- en: 'This type of namespace provides abstraction and virtualization of network protocol
    services and interfaces. Each network namespace will have its own network device
    instances that can be configured with individual network addresses. Isolation
    is enabled for other network services: routing table, port number, and so on.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的命名空间提供了网络协议服务和接口的抽象和虚拟化。每个网络命名空间都有自己的网络设备实例，可以配置具有独立网络地址。其他网络服务的隔离也得以实现：路由表、端口号等。
- en: User namespaces
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户命名空间
- en: User namespaces allow a process to use unique user and group IDs within and
    outside a namespace. This means that a process can use privileged user and group
    IDs (zero) within a user namespace and continue with non-zero user and group IDs
    outside the namespace.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 用户命名空间允许进程在命名空间内外使用唯一的用户和组ID。这意味着进程可以在用户命名空间内使用特权用户和组ID（零），并在命名空间外继续使用非零用户和组ID。
- en: Cgroup namespaces
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cgroup命名空间
- en: A cgroup namespace virtualizes the contents of the `/proc/self/cgroup` file.
    Processes inside a cgroup namespace are only able to view paths relative to their
    namespace root.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Cgroup命名空间虚拟化了`/proc/self/cgroup`文件的内容。在cgroup命名空间内的进程只能查看相对于其命名空间根的路径。
- en: Control groups (cgroups)
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制组（cgroups）
- en: Cgroups are kernel mechanisms to restrict and measure resource allocations to
    each process group. Using cgroups, you can allocate resources such as CPU time,
    network, and memory.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Cgroups是内核机制，用于限制和测量每个进程组的资源分配。使用cgroups，可以分配CPU时间、网络和内存等资源。
- en: Similar to the process model in Linux, where each process is a child to a parent
    and relatively descends from the `init` process thus forming a single-tree like
    structure, cgroups are hierarchical, where child cgroups inherit the attributes
    of the parent, but what makes is different is that multiple cgroup hierarchies
    can exist within a single system, with each having distinct resource prerogatives.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与Linux中的进程模型类似，每个进程都是父进程的子进程，并相对于`init`进程而言形成单树结构，cgroups是分层的，子cgroups继承父级的属性，但不同之处在于在单个系统中可以存在多个cgroup层次结构，每个层次结构都具有不同的资源特权。
- en: Applying cgroups on namespaces results in isolation of processes into `containers`
    within a system, where resources are managed distinctly. Each *container* is a
    lightweight virtual machine, all of which run as individual entities and are oblivious
    of other entities within the same system.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 将cgroups应用于命名空间会将进程隔离到系统中的“容器”中，资源得到独立管理。每个“容器”都是一个轻量级虚拟机，所有这些虚拟机都作为独立实体运行，并且对系统中的其他实体毫不知情。
- en: 'The following are namespace APIs described in the Linux man page for `namespaces`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Linux man页面中描述的命名空间API：
- en: '[PRE21]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We understood one of the principal abstractions of Linux called the process*,*
    and the whole ecosystem that facilitates this abstraction. The challenge now remains
    in running the scores of processes by providing fair CPU time. With many-core
    systems imposing a multitude of processes with diverse policies and priorities,
    the need for deterministic scheduling is paramount.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了Linux的一个主要抽象称为进程，并且整个生态系统都在促进这种抽象。现在的挑战在于通过提供公平的CPU时间来运行大量的进程。随着多核系统施加了多种策略和优先级的进程，确定性调度的需求变得至关重要。
- en: In our next chapter, we will delve into process scheduling, another critical
    aspect of process management, and comprehend how the Linux scheduler is designed
    to handle this diversity.**
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一章中，我们将深入研究进程调度，这是进程管理的另一个关键方面，并了解Linux调度程序是如何设计来处理这种多样性的。
