- en: Chapter 8. Put on the Monitor's Cap
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。戴上监视器的帽子
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Disk usage hacks
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘使用技巧
- en: Calculating the execution time for a command
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算命令的执行时间
- en: Information about logged users, boot logs, failure boots
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关已登录用户、启动日志、启动失败的信息
- en: Printing the 10 most frequently-used commands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印最常用的10个命令
- en: Listing the top 10 CPU consuming process in 1 hour
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出1小时内CPU消耗最多的前10个进程
- en: Monitoring command outputs with watch
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用watch监视命令输出
- en: Logging access to files and directories
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录对文件和目录的访问
- en: Logfile management with logrotate
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用logrotate管理日志文件
- en: Logging with syslog
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用syslog记录
- en: Monitoring user logins to find intruders
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视用户登录以查找入侵者
- en: Remote disk usage health monitoring
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程磁盘使用健康监控
- en: Finding out active user hours on a system
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找系统上活跃用户的小时数
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: An operating system consists of a collection of system software, designed for
    different purposes, serving different task sets. Each of these programs requires
    to be monitored by the operating system or the system administrator in order to
    know whether it is working properly or not. We will also use a technique called
    logging by which important information is written to a file while the application
    is running. By reading this file, we can understand the timeline of the operations
    that are taking place with a particular software or a daemon. If an application
    or a service crashes, this information helps to debug the issue and enables us
    to fix any issues. Logging and monitoring also helps to gather information from
    a pool of data. Logging and monitoring are important tasks for ensuring security
    in the operating system and for debugging purposes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统由一系列系统软件组成，设计用于不同的目的，为不同的任务集提供服务。这些程序中的每一个都需要被操作系统或系统管理员监视，以了解它是否正常工作。我们还将使用一种称为日志记录的技术，通过该技术在应用程序运行时将重要信息写入文件。通过阅读这个文件，我们可以了解正在进行的特定软件或守护进程的操作时间线。如果应用程序或服务崩溃，这些信息有助于调试问题，并使我们能够解决任何问题。日志记录和监视还有助于从数据池中收集信息。日志记录和监视是确保操作系统安全和调试的重要任务。
- en: This chapter deals with different commands that can be used to monitor different
    activities. It also goes through logging techniques and their usages.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了可以用于监视不同活动的不同命令。它还介绍了日志记录技术及其用途。
- en: Disk usage hacks
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 磁盘使用技巧
- en: Disk space is a limited resource. We frequently perform disk usage calculation
    on hard disks or any storage media to find out the free space available on the
    disk. When free space becomes scarce, we will need to find out large-sized files
    that are to be deleted or moved in order to create free space. Disk usage manipulations
    are commonly used in shell scripting contexts. This recipe will illustrate various
    commands used for disk manipulations and problems where disk usages can be calculated
    with a variety of options.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘空间是有限的资源。我们经常对硬盘或任何存储介质进行磁盘使用计算，以找出磁盘上可用的空闲空间。当空闲空间变得稀缺时，我们需要找出需要删除或移动的大文件，以便创建空闲空间。磁盘使用操作通常在shell脚本环境中使用。本文将说明用于磁盘操作的各种命令，以及可以使用各种选项计算磁盘使用情况的问题。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: '`df` and `du` are the two significant commands that are used for calculating
    disk usage in Linux. The command `df` stands for disk free and `du` stands for
    disk usage. Let''s see how we can use them to perform various tasks that involve
    disk usage calculation.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`df`和`du`是用于计算Linux磁盘使用的两个重要命令。命令`df`代表磁盘空闲，`du`代表磁盘使用。让我们看看如何使用它们执行涉及磁盘使用计算的各种任务。'
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To find the disk space used by a file (or files), use:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找文件（或文件）使用的磁盘空间，请使用：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In order to obtain the disk usage for all files inside a directory along with
    the individual disk usage for each file showed in each line, use:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取目录中所有文件的磁盘使用情况，以及在每行中显示每个文件的个别磁盘使用情况，请使用：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`-a` outputs results for all files in the specified directory or directories
    recursively.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: -a在指定的目录或递归目录中输出所有文件的结果。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Running `du DIRECTORY` will output a similar result, but it will show only the
    size consumed by subdirectories. However, they do not show the disk usage for
    each of the files. For printing the disk usage by files, `-a` is mandatory.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`du DIRECTORY`将输出类似的结果，但它只会显示子目录消耗的大小。然而，它们不显示每个文件的磁盘使用情况。要打印文件的磁盘使用情况，-a是必需的。
- en: 'For example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'An example of using `du DIRECTORY` is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`du DIRECTORY`的示例如下：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's more...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's go through additional usage practices for the `du` command.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`du`命令的其他用法。
- en: Displaying disk usage in KB, MB, or Blocks
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以KB、MB或块显示磁盘使用情况
- en: 'By default, the disk usage command displays the total bytes used by a file.
    A more human-readable format is when disk usage is expressed in standard units
    KB, MB, or GB. In order to print the disk usage in a display-friendly format,
    use `–h` as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，磁盘使用命令显示文件使用的总字节数。当以标准单位KB、MB或GB表示磁盘使用时，更易读的格式。为了以友好的格式打印磁盘使用情况，请使用`-h`如下：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Or:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Displaying the grand total sum of disk usage
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示磁盘使用的总和
- en: 'Suppose we need to calculate the total size taken by all the files or directories,
    displaying individual file sizes won''t help. `du` has an option `-c` such that
    it will output the total disk usage of all files and directories given as an argument.
    It appends a line SIZE total with the result. The syntax is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要计算所有文件或目录占用的总大小，显示个别文件大小将不会有帮助。`du`有一个选项`-c`，它将输出作为参数给出的所有文件和目录的总磁盘使用情况。它附加了一行SIZE总和结果。语法如下：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For example:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Or:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`-c` can be used along with other options like `-a` and `-h`. It gives the
    same output as without using `-c`. The only difference is that it appends an extra
    line containing the total size.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: -c可以与其他选项一起使用，如-a和-h。它提供与不使用-c相同的输出。唯一的区别是它附加了一个包含总大小的额外行。
- en: 'There is another option `–s` (summarize), which will print only the grand total
    as the output. It will print the total sum, and flag `-h` can be used along with
    it to print in human readable format. This command has frequent use in practice.
    The syntax is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个选项`-s`（汇总），它将只打印总和作为输出。它将打印总和，并且可以与`-h`标志一起使用以以人类可读的格式打印。这个命令在实践中经常使用。语法如下：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Printing files in specified units
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以指定单位打印文件
- en: 'We can force `du` to print the disk usage in specified units. For example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以强制`du`以指定的单位打印磁盘使用量。例如：
- en: 'Print size in bytes (by default) by using:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用以下方式以字节（默认）打印大小：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Print the size in kilobytes by using:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用以下方式以千字节为单位打印大小：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Print the size in megabytes by using:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用以下方式打印以兆字节为单位的大小：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Print size in given BLOCK size specified by using:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用指定的BLOCK大小打印大小：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `BLOCK_SIZE` is specified in bytes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`BLOCK_SIZE`以字节为单位指定。
- en: 'An example consisting of all the commands is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含所有命令的示例如下：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Excluding files from disk usage calculation
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排除磁盘使用量计算中的文件
- en: 'There are circumstances when we need to exclude certain files from disk usage
    calculation. Such excluded files can be specified in two ways:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要从磁盘使用量计算中排除某些文件。这些被排除的文件可以通过两种方式指定：
- en: '**Wildcards**'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**通配符**'
- en: 'We can specify a wildcard as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用通配符指定如下：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Exclude list**'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**排除列表**'
- en: 'We can specify a list of files to be excluded from a file as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定要从文件中排除的文件列表如下：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There are also some other handy options available with `du` to restrict the
    disk usage calculation. We can specify the maximum depth of the hierarchy that
    the `du` should traverse as a whole by calculating disk usage with the `--max-depth`
    parameter. Specifying a depth of `1` calculates the sizes of files in the current
    directory. Depth `2` will calculate files in the current directory and the next
    subdirectory and stop traversal at that second subdirectory.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`du`还提供了一些其他方便的选项，以限制磁盘使用量的计算。我们可以通过使用`--max-depth`参数指定`du`应该遍历的层次结构的最大深度来计算整个磁盘使用量。指定深度为`1`计算当前目录中文件的大小。深度`2`将计算当前目录中的文件和下一个子目录的文件，并在第二个子目录处停止遍历。'
- en: 'For example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`du` can be restricted to traverse only a single file system by using the `-x`
    argument. Suppose `du DIRECTORY` is run, it will traverse through every possible
    subdirectory of `DIRECTORY` recursively. A subdirectory in the directory hierarchy
    may be a mount point (for example, `/mnt/sda1` is a subdirectory of `/mnt` and
    it is a mount point for the device `/dev/sda1`). `du` will traverse that mount
    point and calculate the sum of disk usage for that device filesystem also. In
    order to prevent `du` from traversing and to calculate from other mount points
    or filesystems, use the `-x` flag along with other `du` options. `du –x /` will
    exclude all mount points in `/mnt/` for disk usage calculation.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`du`可以通过使用`-x`参数限制只遍历单个文件系统。假设运行`du DIRECTORY`，它将递归地遍历`DIRECTORY`的每个可能的子目录。目录层次结构中的一个子目录可能是一个挂载点（例如，`/mnt/sda1`是`/mnt`的子目录，它是设备`/dev/sda1`的挂载点）。`du`将遍历该挂载点，并计算该设备文件系统的磁盘使用总和。为了防止`du`遍历和计算其他挂载点或文件系统，可以在其他`du`选项中使用`-x`标志。`du
    -x /`将排除`/mnt/`中的所有挂载点进行磁盘使用量计算。'
- en: While using `du` make sure that the directories or files it traverses have the
    proper read permissions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`du`时，请确保它遍历的目录或文件具有适当的读取权限。
- en: Finding the 10 largest size files from a given directory
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从给定目录中查找最大的10个文件大小
- en: 'Finding large-size files is a regular task we come across. We regularly require
    to delete those huge size files or move them. We can easily find out large-size
    files using `du` and `sort` commands. The following one-line script can achieve
    this task:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 查找大尺寸文件是我们经常遇到的一个常规任务。我们经常需要删除这些巨大的文件或移动它们。我们可以使用`du`和`sort`命令轻松找到大尺寸文件。以下一行脚本可以完成这项任务：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here `-a` specifies all directories and files. Hence `du` traverses the `SOURCE_DIR`
    and calculates the size of all files. The first column of the output contains
    the size in Kilobytes since `-k` is specified and the second column contains the
    file or folder name.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`-a`指定所有目录和文件。因此，`du`遍历`SOURCE_DIR`并计算所有文件的大小。输出的第一列包含以千字节为单位的大小，因为指定了`-k`，第二列包含文件或文件夹名称。
- en: '`sort` is used to perform numerical sort with column 1 and reverse it. `head`
    is used to parse the first 10 lines from the output.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`用于对第1列进行数字排序并将其反转。`head`用于从输出中解析前10行。'
- en: 'For example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'One of the drawbacks of the above one-liner is that it includes directories
    in the result. However, when we need to find only the largest files and not directories
    we can improve the one-liner to output only the large-size files as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上述一行命令的一个缺点是它包括目录在结果中。然而，当我们只需要找到最大的文件而不是目录时，我们可以改进一行命令，只输出大尺寸的文件，如下所示：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We used `find` to filter only files to `du` rather than allow `du` to traverse
    recursively by itself.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`find`来过滤`du`而不是允许`du`自行递归遍历。
- en: Disk free information
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 磁盘空闲信息
- en: The `du` command provides information about the usage, whereas `df` provides
    information about free disk space. It can be used with and without `-h`. When
    `-h` is issued with `df` it prints the disk space in human readable format.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`du`命令提供有关使用情况的信息，而`df`提供有关可用磁盘空间的信息。它可以与`-h`一起使用，也可以不使用。当`df`与`-h`一起使用时，它以人类可读的格式打印磁盘空间。'
- en: 'For example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Calculating execution time for a command
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算命令的执行时间
- en: While testing an application or comparing different algorithms for a given problem,
    execution time taken by a program is very critical. A good algorithm should execute
    in minimum amount of time. There are several situations in which we need to monitor
    the time taken for execution by a program. For example, while learning about sorting
    algorithms, how do you practically state which algorithm is faster? The answer
    to this is to calculate the execution time for the same data set. Let's see how
    to do it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试应用程序或比较给定问题的不同算法时，程序所花费的执行时间非常关键。一个好的算法应该在最短的时间内执行。有几种情况下，我们需要监视程序执行所花费的时间。例如，在学习排序算法时，如何实际陈述哪个算法更快？答案是计算相同数据集的执行时间。让我们看看如何做到这一点。
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: '`time` is a command that is available with any UNIX-like operating systems.
    You can prefix `time` with the command you want to calculate execution time, for
    example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`是任何类UNIX操作系统中都可用的命令。您可以在要计算执行时间的命令前加上`time`，例如：'
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The command will execute and its output will be shown. Along with output, the
    `time` command appends the time taken in `stderr`. An example is as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将被执行并显示其输出。除了输出之外，`time`命令还会在`stderr`中附加所用的时间。例如：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It will show real, user, and system times for execution. The three different
    times can be defined as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 它将显示执行的实际、用户和系统时间。三种不同的时间可以定义如下：
- en: '**Real** is wall clock time—the time from start to finish of the call. This
    is all elapsed time including time slices used by other processes and the time
    that the process spends when blocked (for example, if it is waiting for I/O to
    complete).'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Real**是挂钟时间——从调用开始到结束的时间。这是包括其他进程使用的时间片和进程被阻塞时花费的时间（例如，如果它正在等待I/O完成）的所有经过的时间。'
- en: '**User** is the amount of CPU time spent in user-mode code (outside the kernel)
    within the process. This is only the actual CPU time used in executing the process.
    Other processes and the time that the process spends when blocked do not count
    towards this figure.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**User**是进程内用户模式代码（内核之外）中花费的CPU时间。这只是执行进程时实际使用的CPU时间。其他进程和进程被阻塞时花费的时间不计入这个数字。'
- en: '**Sys** is the amount of CPU time spent in the kernel within the process. This
    means executing the CPU time spent in system calls within the kernel, as opposed
    to library code, which is still running in the user space. Like ''user time'',
    this is only the CPU time used by the process.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sys**是进程内核中花费的CPU时间。这意味着内核中系统调用中执行的CPU时间，而不是仍在用户空间中运行的库代码。与“用户时间”一样，这只是进程使用的CPU时间。'
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An executable binary of the `time` command is available at `/usr/bin/time` as
    well as a shell built-in named `time` exists. When we run `time`, it calls the
    shell built-in by default. The shell built-in time has limited options. Hence,
    we should use an absolute path for the executable (`/usr/bin/time`) for performing
    additional functionalities.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`命令的可执行二进制文件位于`/usr/bin/time`，还有一个名为`time`的shell内置命令。当我们运行`time`时，默认情况下会调用shell内置命令。shell内置的time选项有限。因此，我们应该使用可执行文件（`/usr/bin/time`）的绝对路径来执行其他功能。'
- en: 'We can write this time statistics to a file using the `-o filename` option
    as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-o filename`选项将时间统计信息写入文件，如下所示：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The filename should always appear after the `–o` flag.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名应该始终出现在`-o`标志之后。
- en: 'In order to append the time statistics to a file without overwriting, use the
    `-a` flag along with the `-o` option as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将时间统计信息附加到文件而不覆盖，使用`-a`标志以及`-o`选项如下：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can also format the time outputs using format strings with the `-f` option.
    A format string consists of parameters corresponding to specific options prefixed
    with `%`. The format strings for real time, user time, and sys time are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`-f`选项使用格式字符串格式化时间输出。格式字符串由与特定选项对应的参数组成，前缀为`%`。实际时间、用户时间和系统时间的格式字符串如下：
- en: Real time - `%e`
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际时间 - `%e`
- en: User - `%U`
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户 - `%U`
- en: sys - `%S`
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: sys - `%S`
- en: 'By combining parameter strings, we can create formatted output as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合参数字符串，我们可以创建格式化的输出，如下所示：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here `%U` is the parameter for user time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`%U`是用户时间的参数。
- en: 'When formatted output is produced, the formatted output of the command is written
    to the standard output and the output of the `COMMAND`, which is timed, is written
    to standard error. We can redirect the formatted output using a redirection operator
    (`>`) and redirect the time information output using the (`2>`) error redirection
    operator. For example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 生成格式化输出时，命令的格式化输出被写入标准输出，而被计时的`COMMAND`的输出被写入标准错误。我们可以使用重定向运算符（`>`）重定向格式化输出，并使用（`2>`）错误重定向运算符重定向时间信息输出。例如：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Many details regarding a process can be collected using the `time` command.
    The important details include, exit status, number of signals received, number
    of context switches made, and so on. Each parameter can be displayed by using
    a suitable format string.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`time`命令可以收集有关进程的许多细节。重要的细节包括退出状态、接收的信号数、进行的上下文切换次数等。可以使用适当的格式字符串显示每个参数。
- en: 'The following table shows some of the interesting parameters that can be used:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了一些有趣的参数：
- en: '| Parameter | Description |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `%C` | Name and command-line arguments of the command being timed. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `%C` | 被计时命令的名称和命令行参数。 |'
- en: '| `%D` | Average size of the process''s unshared data area, in kilobytes. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `%D` | 进程的未共享数据区的平均大小，以千字节为单位。 |'
- en: '| `%E` | Elapsed real (wall clock) time used by the process in [hours:]minutes:seconds.
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `%E` | 进程使用的实际经过的时间（挂钟时间）[小时:]分钟:秒。 |'
- en: '| `%x` | Exit status of the command. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `%x` | 命令的退出状态。 |'
- en: '| `%k` | Number of signals delivered to the process. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `%k` | 传递给进程的信号数。 |'
- en: '| `%W` | Number of times the process was swapped out of the main memory. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `%W` | 进程被交换出主内存的次数。 |'
- en: '| `%Z` | System''s page size in bytes. This is a per-system constant, but varies
    between systems. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '|`％Z`|系统的页面大小（以字节为单位）。这是一个每系统常量，但在系统之间有所不同。|'
- en: '| `%P` | Percentage of the CPU that this job got. This is just user + system
    times divided by the total running time. It also prints a percentage sign. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|`％P`|此作业获得的CPU百分比。这只是用户+系统时间除以总运行时间。它还打印一个百分号。|'
- en: '| `%K` | Average total (data + stack + text) memory usage of the process, in
    kilobytes. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|`％K`|进程的平均总（数据+堆栈+文本）内存使用量，以千字节为单位。|'
- en: '| `%w` | Number of times that the program was context-switched voluntarily,
    for instance while waiting for an I/O operation to complete. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|`％w`|程序自愿上下文切换的次数，例如在等待I/O操作完成时。|'
- en: '| `%c` | Number of times the process was context-switched involuntarily (because
    the time slice expired). |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|`％c`|进程被非自愿上下文切换的次数（因为时间片到期）。|'
- en: 'For example, the page size can be displayed using the `%Z` parameters as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以使用`％Z`参数显示页面大小如下：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here the output of the timed command is not required and hence the standard
    output is directed to the `/dev/null` device in order to prevent it from writing
    to the terminal.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不需要`timed`命令的输出，因此将标准输出重定向到`/dev/null`设备，以防止它写入终端。
- en: More format strings parameters are available. Read `man time` for more details.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多的格式字符串参数可用。阅读`man time`以获取更多详细信息。
- en: Information about logged users, boot logs, and failure boot
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有关登录用户、引导日志和引导失败的信息
- en: Collecting information about the operating environment, logged in users, the
    time for which the computer has been powered on, and any boot failures are very
    helpful. This recipe will go through a few commands used to gather information
    about a live machine.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 收集有关操作环境、登录用户、计算机已经运行的时间以及任何引导失败的信息非常有帮助。这个教程将介绍一些用于收集有关活动机器信息的命令。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will introduce the commands `who`, `w`, `users`, `uptime`, `last`,
    and `lastb`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将介绍`who`、`w`、`users`、`uptime`、`last`和`lastb`命令。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To obtain information about users currently logged in to the machine use:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关当前登录到计算机的用户的信息，请使用：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Or:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It will provide information about logged in users, the pseudo TTY used by the
    users, the command that is currently executing from the pseudo terminal, and the
    IP address from which the users have logged in. If it is localhost, it will show
    the hostname. `who` and `w` format outputs with slight difference. The `w` command
    provides more detail than `who` .
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 它将提供有关登录用户、用户使用的伪TTY、当前从伪终端执行的命令以及用户登录的IP地址的信息。如果是本地主机，它将显示主机名。`who`和`w`的格式输出略有不同。`w`命令提供的详细信息比`who`更多。
- en: TTY is the device file associated with a text terminal. When a terminal is newly
    spawned by the user, a corresponding device is created in `/dev/` (for example,
    `/dev/pts/3`). The device path for the current terminal can be found out by typing
    and executing the command `tty`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: TTY是与文本终端相关联的设备文件。当用户新生成终端时，将在`/dev/`中创建相应的设备（例如`/dev/pts/3`）。可以通过键入和执行`tty`命令来找出当前终端的设备路径。
- en: 'In order to list the users currently logged in to the machine, use:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出当前登录到计算机的用户，请使用：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If a user has opened multiple pseudo terminals, it will show that many entries
    for the same user. In the above output, the user `slynux` has opened three pseudo
    terminals. The easiest way to print unique users is to use `sort` and `uniq` to
    filter as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已经打开了多个伪终端，将显示相同用户的多个条目。在上面的输出中，用户`slynux`已经打开了三个伪终端。打印唯一用户的最简单方法是使用`sort`和`uniq`进行过滤，如下所示：
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We have used `tr` to replace `' '` with `'\n'`. Then combination of `sort` and
    `uniq` will produce unique entries for each user.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`tr`将`' '`替换为`'\n'`。然后`sort`和`uniq`的组合将为每个用户生成唯一的条目。
- en: 'In order to see how long the system has been powered on, use:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看系统已经运行了多长时间，请使用：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The time that follows the word `up` indicates the time for which the system
    has been powered on. We can write a simple one-liner to extract the uptime only.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 跟在单词`up`后面的时间表示系统已经运行的时间。我们可以编写一个简单的一行代码来提取仅运行时间。
- en: 'Load average in uptime''s output is a parameter that indicates system load.
    This is explained in more detail in the chapter, *Administration Calls!*. In order
    to get information about previous boot and user logged sessions, use:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`uptime`输出中的平均负载是指系统负载的一个参数。这在章节*Administration Calls!*中有更详细的解释。为了获取有关以前的引导和用户登录会话的信息，请使用：'
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `last` command will provide information about logged in sessions. It is
    actually a log of system logins that consists of information such as `tty` from
    which it has logged in, login time, status, and so on.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`last`命令将提供有关登录会话的信息。实际上，它是一个系统登录的日志，其中包含`tty`从中登录的信息、登录时间、状态等。'
- en: 'The `last` command uses the log file `/var/log/wtmp` for input log data. It
    is also possible to explicitly specify the log file for the last command using
    the `–f` option. For example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`last`命令使用日志文件`/var/log/wtmp`作为输入日志数据。还可以使用`-f`选项明确指定`last`命令的日志文件。例如：'
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In order to obtain info about login sessions for a single user, use:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取单个用户的登录会话信息，请使用：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Get information about reboot sessions as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 获取有关重新启动会话的信息如下：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In order to get information about failed user login sessions use:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取有关失败的用户登录会话的信息，请使用：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You should run `lastb` as the root user.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该以root用户身份运行`lastb`。
- en: Printing the 10 most frequently-used commands
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印最常用的10个命令
- en: Terminal is the tool used to access the shell prompt where we type and execute
    commands. Users run many commands in the shell. Many of them are frequently used.
    A user's nature can be identified easily by looking at the commands he frequently
    uses. This recipe is a small exercise to find out 10 most frequently-used commands.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 终端是用于访问shell提示符的工具，在那里我们输入和执行命令。用户在shell中运行许多命令。其中许多是经常使用的。通过查看他经常使用的命令，可以很容易地识别用户的性质。这个教程是一个小练习，用于找出最常用的10个命令。
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Bash keeps track of previously typed commands by the user and stores in the
    file `~/.bash_history`. But it only keeps a specific number (say 500) of the recently
    executed commands. The history of commands can be viewed by using the command
    history or `cat ~/.bash_history`. We will use this for finding out frequently-used
    commands.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Bash通过用户之前输入的命令并存储在文件`~/.bash_history`中来跟踪先前输入的命令。但它只保留最近执行的一定数量（比如500）的命令。可以使用`history`命令或`cat
    ~/.bash_history`命令查看命令的历史记录。我们将使用这个来查找经常使用的命令。
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We can get the list of commands from `~/.bash_history`, take only the command
    excluding the arguments, count the occurrence of each command, and find out the
    10 commands with the highest count.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`~/.bash_history`获取命令列表，仅获取不包括参数的命令，计算每个命令的出现次数，并找出出现次数最高的10个命令。
- en: 'The following script can be used to find out frequently-used commands:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本可用于查找经常使用的命令：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A sample output is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 示例输出如下：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the above script, the history file `~/.bash_history` is the source file used.
    The source input is passed to `awk` through a pipe. Inside `awk`, we have an associative
    array list. This array can use command names as index and it stores the count
    of the commands in array locations. Hence for each arrival or occurrence of a
    command it will increment by one (`list[$1]++`). `$1` is used as the index. `$1`
    is the first word of text in a line input. If `$0` were used it would contain
    all the arguments for the command also. For example, if `ssh 192.168.0.4` is a
    line from `.bash_history`, `$0` equals to `ssh 192.168.0.4` and `$1` equals to
    `ssh`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述脚本中，历史文件`~/.bash_history`是使用的源文件。源输入通过管道传递给`awk`。在`awk`中，我们有一个关联数组列表。这个数组可以使用命令名称作为索引，并将命令的计数存储在数组位置中。因此，对于每个命令的到达或出现，它将递增一个（`list[$1]++`）。`$1`被用作索引。`$1`是输入行中文本的第一个单词。如果使用`$0`，它将包含命令的所有参数。例如，如果`ssh
    192.168.0.4`是来自`.bash_history`的一行，`$0`等于`ssh 192.168.0.4`，`$1`等于`ssh`。
- en: Once all the lines of the history files are traversed, we will have the array
    with command names as indexes and their count as the value. Hence command names
    with maximum count values will be the commands most frequently used. Hence in
    the `END{}` block of `awk`, we traverse through the indexes of commands and print
    all command names and their counts. `sort -nrk 2` will perform a numeric sort
    based on the second column (`COUNT`) and reverse it. Hence we use the `head` command
    to extract only the first 10 commands from the list. You can customize the top
    10 to top 5 or any other number by using the argument `head -n NUMBER`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦历史文件的所有行都被遍历，我们将得到一个带有命令名称作为索引和它们计数作为值的数组。因此，具有最大计数值的命令名称将是最常用的命令。因此，在`awk`的`END{}`块中，我们遍历命令的索引并打印所有命令名称和它们的计数。`sort
    -nrk 2`将根据第二列（`COUNT`）执行数值排序并反转它。因此，我们使用`head`命令从列表中提取前10个命令。您可以使用参数`head -n NUMBER`将前10个自定义为前5个或任何其他数字。
- en: Listing the top 10 CPU consuming process in a hour
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出一个小时内消耗前10个CPU的进程
- en: CPU time is a major resource and sometimes we require to keep track of the processes
    that consume the most CPU cycles in a period of time. In regular desktops or laptops,
    it might not be an issue that the CPU is heavily consumed. However, for a server
    that handles numerous requests, CPU is a critical resource. By monitoring the
    CPU usage for a certain period we can identify the processes that keep the CPU
    busy all the time and optimize them to efficiently use the CPU or to debug them
    due to any other issues. This recipe is a practice with process monitoring and
    logging.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: CPU时间是一个重要的资源，有时我们需要跟踪在一段时间内消耗最多CPU周期的进程。在常规的台式机或笔记本电脑上，CPU被大量消耗可能不是一个问题。然而，对于处理大量请求的服务器来说，CPU是一个关键资源。通过监视一定时间内的CPU使用情况，我们可以识别一直占用CPU的进程，并优化它们以有效地使用CPU或者由于其他问题对它们进行调试。这个配方是一个处理监视和记录进程的实践。
- en: Getting ready
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: '`ps` is a command used for collecting details about the processes running on
    the system. It can be used to gather details such as CPU usage, commands under
    execution, memory usage, status of process, and so on. Processes that consume
    the CPU for one hour can be logged, and the top 10 can be determined by proper
    usage of `ps` and text processing. For more details on the `ps` command, see the
    chapter: *Administration Calls!*.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps`是一个用于收集有关系统上运行的进程的详细信息的命令。它可以用于收集诸如CPU使用情况、正在执行的命令、内存使用情况、进程状态等的详细信息。可以记录一个小时内消耗CPU的进程，并通过适当使用`ps`和文本处理来确定前10个进程。有关`ps`命令的更多详细信息，请参阅章节：*管理调用*。'
- en: How to do it...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s go through the following shell script for monitoring and calculating
    CPU usages in one hour:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下shell脚本来监视和计算一个小时内的CPU使用情况：
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A sample output is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 示例输出如下：
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the above script, the major input source is `ps -eocomm, pcpu`. `comm` stands
    for command name and `pcpu` stands for the CPU usage in percent. It will output
    all the process names and the CPU usage in percent. For each process there exists
    a line in the output. Since we need to monitor the CPU usage for one hour, we
    repeatedly take usage statistics using `ps -eo comm,pcpu` `| tail -n +2` and append
    to a file `/tmp/cpu_usage.$$` running inside a `for` loop with 60 seconds wait
    in each iteration. This wait is provided by `sleep 60`. It will execute `ps` once
    in each minute.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述脚本中，主要的输入来源是`ps -eocomm, pcpu`。`comm`代表命令名称，`pcpu`代表CPU使用率百分比。它将输出所有进程名称和CPU使用率百分比。对于输出中的每个进程都存在一行。由于我们需要监视一个小时的CPU使用情况，我们会使用`ps
    -eo comm,pcpu` `| tail -n +2`重复地获取使用统计信息，并将其附加到一个文件`/tmp/cpu_usage.$$`中，该文件在`for`循环中运行，每次迭代都等待60秒。这个等待是由`sleep
    60`提供的。它将每分钟执行一次`ps`。
- en: '`tail -n +2` is used to strip off the header and `COMMAND %CPU` in the `ps`
    output.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail -n +2`用于剥离`ps`输出中的标题和`COMMAND %CPU`。'
- en: '`$$` in `cpu_usage.$$` signifies that it is the process ID of the current script.
    Suppose PID is 1345, during execution it will be replaced as `/tmp/cpu_usage.1345`.
    We place this file in `/tmp` since it is a temporary file.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`$$`在`cpu_usage.$$`中表示它是当前脚本的进程ID。假设PID为1345，在执行期间它将被替换为`/tmp/cpu_usage.1345`。我们将这个文件放在`/tmp`中，因为它是一个临时文件。'
- en: The statistics file will be ready after one hour and will contain 60 entries
    corresponding to the process status for each minute. Then `awk` is used to sum
    the total CPU usage for each process. An associative array process is used for
    the summation of CPU usages. It uses the process name as an array index. Finally,
    it sorts the result with a numeric reverse sort according to the total CPU usage
    and pass through head to obtain top 10 usage entries.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 统计文件将在一小时后准备好，并包含60个条目，对应于每分钟的进程状态。然后使用`awk`来对每个进程的总CPU使用情况进行求和。一个关联数组进程用于CPU使用情况的求和。它使用进程名称作为数组索引。最后，它根据总CPU使用情况进行数字逆排序，并通过head获取前10个使用情况条目。
- en: See also
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Basic awk primer* of[Chapter 4](ch04.html "Chapter 4. Texting and Driving"),
    explains the awk command'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第4章的基本awk入门*，解释了awk命令'
- en: '*head and tail - printing the last or first ten lines* of[Chapter 3](ch03.html
    "Chapter 3. File In, File Out"), explains the tail command'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*head和tail - 打印[第3章](ch03.html "第3章。文件输入，文件输出")的最后或前十行*，解释了tail命令'
- en: Monitoring command outputs with watch
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用watch监视命令输出
- en: We might need to continuously watch the output of a command for a period of
    time in equal intervals. For example, for a large file copy, we need to watch
    the growing file size. In order to do that, newbies repeatedly type commands and
    press return a number of times. Instead we can use the watch command to view output
    repeatedly. This recipe explains how to do that.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要在相等的时间间隔内持续观察命令的输出一段时间。例如，对于大文件复制，我们需要观察文件大小的增长。为了做到这一点，新手们反复输入命令并按回车键多次。相反，我们可以使用watch命令重复查看输出。本教程解释了如何做到这一点。
- en: How to do it...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `watch` command can be used to monitor the output of a command on the terminal
    at regular intervals. The syntax of the `watch` command is as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`watch`命令可用于定期监视终端上命令的输出。`watch`命令的语法如下：'
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Or:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'For example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This command will update the output at a default interval of two seconds.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将以默认间隔两秒更新输出。
- en: 'We can also specify the time interval at which the output needs to be updated,
    by using `-n SECONDS`. For example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用`-n SECONDS`来指定输出需要更新的时间间隔。例如：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There's more
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: Let's explore an additional feature of the `watch` command.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索`watch`命令的一个附加功能。
- en: Highlighting the differences in watch output
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 突出显示watch输出中的差异
- en: 'In `watch`, there is an option for updating the differences that occur during
    the execution of the command at an update interval to be highlighted using colors.
    Difference highlighting can be enabled by using the `-d` option as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在`watch`中，有一个选项可以在执行命令期间更新的差异以突出显示，并使用颜色进行标记。可以通过使用`-d`选项启用差异突出显示，如下所示：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Logging access to files and directories
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录对文件和目录的访问
- en: Logging of file and directory access is very helpful to keep track of changes
    that are happening to files and folders. This recipe will describe how to log
    user accesses.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 记录文件和目录访问对于跟踪文件和文件夹发生的变化非常有帮助。本教程将描述如何记录用户访问。
- en: Getting ready
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The `inotifywait` command can be used to gather information about file accesses.
    It doesn't come by default with every Linux distro. You have to install the `inotify-tools`
    package by using a package manager. It also requires the Linux kernel to be compiled
    with inotify support. Most of the new GNU/Linux distributions come with inotify
    enabled in the kernel.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`inotifywait`命令可用于收集有关文件访问的信息。它不会默认随每个Linux发行版一起提供。您必须使用软件包管理器安装`inotify-tools`软件包。它还需要Linux内核编译时启用inotify支持。大多数新的GNU/Linux发行版都启用了内核中的inotify。'
- en: How to do it...
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s walk through the shell script to monitor the directory access:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们走一遍监视目录访问的shell脚本：
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'A sample output is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 示例输出如下：
- en: '[PRE57]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The previous script will log events create, move, and delete files and folders
    from the given path. The `-m` option is given for monitoring the changes continuously
    rather than going to exit after an event happens. `-r` is given for enabling a
    recursive watch the directories. `-e` specifies the list of events to be watched.
    `-q` is to reduce the verbose messages and print only required ones. This output
    can be redirected to a log file.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的脚本将记录从给定路径创建、移动和删除文件和文件夹的事件。给出`-m`选项以持续监视更改，而不是在事件发生后退出。给出`-r`以启用递归监视目录。`-e`指定要监视的事件列表。`-q`是为了减少冗长的消息并只打印所需的消息。此输出可以重定向到日志文件。
- en: 'We can add or remove the event list. Important events available are as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加或删除事件列表。可用的重要事件如下：
- en: '| Event | Description |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 事件 | 描述 |'
- en: '| --- | --- |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `access` | When some read happens to a file. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `access` | 当文件发生读取时。 |'
- en: '| `modify` | When file contents are modified. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `modify` | 当文件内容被修改时。 |'
- en: '| `attrib` | When metadata is changed. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `attrib` | 当元数据被更改时。 |'
- en: '| `move` | When a file undergoes move operation. |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `move` | 当文件进行移动操作时。 |'
- en: '| `create` | When a new file is created. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `create` | 当创建新文件时。 |'
- en: '| `open` | When a file undergoes open operation. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `open` | 当文件进行打开操作时。 |'
- en: '| `close` | When a file undergoes close operation. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `close` | 当文件进行关闭操作时。 |'
- en: '| `delete` | When a file is removed. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `delete` | 当文件被删除时。 |'
- en: Logfile management with logrotate
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用logrotate进行日志文件管理
- en: Logfiles are essential components of a Linux system's maintenance. Logfiles
    help to keep track of events happening on different services on the system. This
    helps the sysadmin to debug issues and also provides statistics on events happening
    on the live machine. Management of logfiles is required because as time passes
    the size of a logfile gets bigger and bigger. Therefore, we use a technique called
    rotation to limit the size of the logfile and if the logfile reaches a size beyond
    the limit, it will strip the logfile and store the older entries from the logfile
    in an archive. Hence older logs can be stored and kept for future reference. Let's
    see how to rotate logs and store them.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件是Linux系统维护的重要组成部分。日志文件有助于跟踪系统上不同服务发生的事件。这有助于系统管理员调试问题，还提供了有关实时机器上发生的事件的统计信息。需要管理日志文件，因为随着时间的推移，日志文件的大小会变得越来越大。因此，我们使用一种称为轮换的技术来限制日志文件的大小，如果日志文件达到了限制之外的大小，它将剥离日志文件并将日志文件的旧条目存储在归档中。因此，旧日志可以被存储和保留以供将来参考。让我们看看如何轮换日志并存储它们。
- en: Getting ready
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: '`logrotate` is a command every Linux system admin should know. It helps to
    restrict the size of logfile to the given SIZE. In a logfile, the logger appends
    information to the log file. Hence the recent information appears at the bottom
    of the log file. `logrotate` will scan specific logfiles according to the configuration
    file. It will keep the last 100 kilobytes (for example, specified SIZE = 100k)
    from the logfile and move rest of the data (older log data) to a new file `logfile_name.1`
    with older entries. When more entries occur in the logfile (`logfile_name.1`)
    and it exceeds the SIZE, it updates the logfile with recent entries and creates
    `logfile_name.2` with older logs. This process can easily be configured with `logrotate`.
    `logrotate` can also compress the older logs as `logfile_name.1.gz`, `logfile_name2.gz`,
    and so on. The option for whether older log files are to be compressed or not
    is available with the `logrotate` configuration.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`logrotate`是每个Linux系统管理员都应该了解的命令。它有助于限制日志文件的大小。在日志文件中，记录器将信息追加到日志文件中。因此，最近的信息出现在日志文件的底部。`logrotate`将根据配置文件扫描特定的日志文件。它将保留日志文件的最后100千字节（例如，指定SIZE
    = 100k），并将其余数据（旧的日志数据）移动到一个新文件`logfile_name.1`中。当日志文件（`logfile_name.1`）中出现更多条目并且超过了SIZE时，它将使用最新的条目更新日志文件，并创建带有旧日志的`logfile_name.2`。这个过程可以很容易地通过`logrotate`进行配置。`logrotate`还可以将旧日志压缩为`logfile_name.1.gz`、`logfile_name2.gz`等。是否压缩旧日志文件的选项在`logrotate`配置中可用。'
- en: How to do it...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: '`logrotate` has the configuration directory at `/etc/logrotate.d`. If you look
    at this directory by listing contents, many other logfile configurations can be
    found.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`logrotate`的配置目录位于`/etc/logrotate.d`。如果列出该目录的内容，可以找到许多其他日志文件的配置。'
- en: 'We can write our custom configuration for our logfile (say `/var/log/program.log`)
    as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为我们的日志文件编写自定义配置（比如`/var/log/program.log`）如下：
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now the configuration is complete. `/var/log/program.log` in the configuration
    specifies the logfile path. It will archive old logs in the same directory path.
    Let''s see what each of these parameters are:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在配置已经完成。配置中的`/var/log/program.log`指定了日志文件路径。它将在相同的目录路径中归档旧日志。让我们看看这些参数各是什么：
- en: '| Parameter | Description |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `missingok` | Ignore if the logfile is missing and return without rotating
    the log. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `missingok` | 如果日志文件丢失，则忽略并返回而不进行日志轮换。 |'
- en: '| `notifempty` | Only rotate the log if the source logfile is not empty. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `notifempty` | 只有在源日志文件不为空时才进行日志轮换。 |'
- en: '| `size 30k` | Limit the size of the logfile for which the rotation is to be
    made. It can be 1M for 1MB. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `size 30k` | 限制要进行轮换的日志文件的大小。可以是1M表示1MB。 |'
- en: '| `compress` | Enable compression with gzip for older logs. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `compress` | 启用gzip对较旧的日志进行压缩。 |'
- en: '| `weekly` | Specify the interval at which the rotation is to be performed.
    It can be weekly, yearly, or daily. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `weekly` | 指定进行轮换的时间间隔。可以是每周、每年或每天。 |'
- en: '| `rotate 5` | It is the number of older copies of logfile archives to be kept.
    Since 5 is specified, there will be `program.log.1.gz`, `program.log.2.gz`, and
    so on till `program.log.5.gz`. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `rotate 5` | 要保留的旧日志文件归档副本的数量。由于指定了5，将会有`program.log.1.gz`、`program.log.2.gz`，以此类推，直到`program.log.5.gz`。
    |'
- en: '| `create 0600 root root` | Specify the mode, user, and the group of the logfile
    archive to be created. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `create 0600 root root` | 指定要创建的日志文件归档的模式、用户和组。 |'
- en: The options specified in the table are optional; we can specify the required
    options only in the `logrotate` configuration file. There are numerous options
    available with `logrotate`. Please refer to the man pages ([http://linux.die.net/man/8/logrotate](http://linux.die.net/man/8/logrotate))
    for more information on `logrotate`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 表中指定的选项是可选的；我们可以在`logrotate`配置文件中只指定所需的选项。`logrotate`有许多可用的选项。请参考man页面（[http://linux.die.net/man/8/logrotate](http://linux.die.net/man/8/logrotate)）获取有关`logrotate`的更多信息。
- en: Logging with syslog
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用syslog记录
- en: Logfiles are an important component of applications that provide services to
    the users. An applications writes status information to its logfile while it is
    running. If any crash occurs or we need to enquire some information about the
    service, we look into the logfile. You can find lots of logfiles related to different
    daemons and applications in the `/var/log` directory. It is the common directory
    for storing log files. If you read through a few lines of the logfiles, you can
    see that lines in the log are in a common format. In Linux, creating and writing
    log information to logfiles at `/var/log` are handled by a protocol called syslog.
    It is handled by the `syslogd` daemon. Every standard application makes use of
    syslog for logging information. In this recipe, we will discuss how to make use
    of `syslogd` for logging information from a shell script.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件是为向用户提供服务的应用程序的重要组成部分。应用程序在运行时将状态信息写入其日志文件。如果发生任何崩溃或者我们需要查询有关服务的一些信息，我们会查看日志文件。您可以在`/var/log`目录中找到与不同守护程序和应用程序相关的许多日志文件。这是存储日志文件的常见目录。如果您阅读日志文件的几行，您会发现日志中的行是以常见格式编写的。在Linux中，创建和将日志信息写入`/var/log`日志文件由一种称为syslog的协议处理。它由`syslogd`守护程序处理。每个标准应用程序都使用syslog来记录信息。在本教程中，我们将讨论如何使用`syslogd`从shell脚本记录信息。
- en: Getting ready
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Logfiles are useful for helping you deduce what is going wrong with a system.
    Hence while writing critical applications, it is always a good practice to log
    the progress of application with messages into a logfile. We will learn the command
    logger to log into log files with `syslogd`. Before getting to know how to write
    into logfiles, let''s go through a list of important logfiles used in Linux:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件对帮助您推断系统出现了什么问题非常有用。因此，在编写关键应用程序时，始终将应用程序的进度记录到日志文件中是一种良好的做法。我们将学习命令记录器以使用`syslogd`记录到日志文件。在了解如何写入日志文件之前，让我们先浏览一下Linux中使用的重要日志文件列表：
- en: '| Log file | Description |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 日志文件 | 描述 |'
- en: '| --- | --- |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `/var/log/boot.log` | Boot log information. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `/var/log/boot.log` | 启动日志信息。 |'
- en: '| `/var/log/httpd` | Apache web server log. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `/var/log/httpd` | Apache Web服务器日志。 |'
- en: '| `/var/log/messages` | Post boot kernel information. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `/var/log/messages` | 启动后内核信息。 |'
- en: '| `/var/log/auth.log` | User authentication log. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `/var/log/auth.log` | 用户认证日志。 |'
- en: '| `/var/log/dmesg` | System boot up messages. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `/var/log/dmesg` | 系统启动消息。 |'
- en: '| `/var/log/mail.log` | Mail server log. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `/var/log/mail.log` | 邮件服务器日志。 |'
- en: '| `/var/log/Xorg.0.log` | X Server log. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `/var/log/Xorg.0.log` | X服务器日志。 |'
- en: How to do it...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In order to log to the syslog file `/var/log/messages` use:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记录到syslog文件`/var/log/messages`，请使用：
- en: '[PRE59]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'For example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE60]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The logfile `/var/log/messages` is a general purpose logfile. When the `logger`
    command is used, it logs to `/var/log/messages` by default. In order to log to
    the syslog with a specified tag, use:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件`/var/log/messages`是一个通用目的的日志文件。当使用`logger`命令时，默认情况下会记录到`/var/log/messages`。为了记录到具有指定标记的syslog中，请使用：
- en: '[PRE61]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: syslog handles a number of logfiles in `/var/log`. However, while logger sends
    a message, it uses the tag string to determine in which logfile it needs to be
    logged. `syslogd` decides to which file the log should be made by using the `TAG`
    associated with the log. You can see the tag strings and associated logfiles from
    the configuration files located in the `/etc/rsyslog.d/` directory.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: syslog处理`/var/log`中的许多日志文件。但是，当记录器发送消息时，它使用标记字符串来确定需要记录到哪个日志文件中。`syslogd`通过使用与日志相关的`TAG`来决定应将日志记录到哪个文件中。您可以从位于`/etc/rsyslog.d/`目录中的配置文件中查看标记字符串和相关的日志文件。
- en: 'In order to log to the system log with the last line from another logfile use:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将另一个日志文件的最后一行记录到系统日志中，请使用：
- en: '[PRE62]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: See also
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: '*head and tail - printing the last or first 10 lines* of[Chapter 3](ch03.html
    "Chapter 3. File In, File Out"), explains the head and tail commands'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*head和tail - 打印最后或前10行* [第3章](ch03.html "第3章。文件输入，文件输出") ，解释head和tail命令'
- en: Monitoring user logins to find intruders
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视用户登录以查找入侵者
- en: 'Logfiles can be used to gather details about the state of the system. Here
    is an interesting scripting problem statement:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件可用于收集有关系统状态的详细信息。以下是一个有趣的脚本编写问题陈述：
- en: 'We have a system connected to the Internet with SSH enabled. Many attackers
    are trying to log in to the system. We need to design an intrusion detection system
    by writing a shell script. Intruders are defined as users who are trying to log
    in with multiple attempts for more than two minutes and whose attempts are all
    failing. Such users are to be detected and a report should be generated with the
    following details:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个连接到启用SSH的互联网的系统。许多攻击者试图登录系统。我们需要编写一个shell脚本来设计入侵检测系统。入侵者被定义为尝试在两分钟以上进行多次尝试并且所有尝试都失败的用户。应检测此类用户并生成报告，其中包括以下详细信息：
- en: User account to which a login is attempted
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试登录的用户帐户
- en: Number of attempts
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试次数
- en: IP address of the attacker
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击者的IP地址
- en: Host mapping for IP address
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP地址的主机映射
- en: Time range for which login attempts are performed.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试登录的时间范围。
- en: Getting started
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: We can write a shell script that can scan through the logfiles and gather the
    required information from them. Here, we are dealing with SSH login failures.
    The user authentication session log is written to the log file `/var/log/auth.log`.
    The script should scan the log file to detect the failure login attempts and perform
    different checks on the log to infer the data. We can use the `host` command to
    find out the host mapping from the IP address.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个shell脚本，可以扫描日志文件并从中收集所需的信息。在这里，我们正在处理SSH登录失败。用户认证会话日志被写入日志文件`/var/log/auth.log`。脚本应扫描日志文件以检测失败的登录尝试，并对日志执行不同的检查以推断数据。我们可以使用`host`命令从IP地址找出主机映射。
- en: How to do it…
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s write an intruder detection script that can generate a report of intruders
    by using the authentication logfile as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个入侵者检测脚本，该脚本可以使用认证日志文件生成入侵者报告，如下所示：
- en: '[PRE63]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'A sample output is as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 示例输出如下：
- en: '![How to do it…](img/3760_08_01.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/3760_08_01.jpg)'
- en: How it works…
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the `intruder_detect.sh` script, we use the `auth.log` file as input. We
    can either provide a log file as input to the script by using a command-line argument
    to the script or, by default, it reads the `/var/log/auth.log` file. We need to
    log details about login attempts for valid user names only. When a login attempt
    for an invalid user occurs, a log similar to `Failed password for invalid user
    bob from 203.83.248.32 port 7016 ssh2` is logged to `auth.log`. Hence, we need
    to exclude all lines in the log file having the word "invalid". The `grep` command
    with the invert option (`-v`) is used to remove all logs corresponding to invalid
    users. The next step is to find out the list of users for which login attempts
    occurred and failed. The SSH will log lines similar to `sshd[21197]: Failed password
    for bob1 from 203.83.248.32 port 50035 ssh2` for a failed password.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '在`intruder_detect.sh`脚本中，我们使用`auth.log`文件作为输入。我们可以通过使用命令行参数将日志文件作为输入提供给脚本，或者默认情况下，它读取`/var/log/auth.log`文件。我们只需要记录关于有效用户名的登录尝试的详细信息。当发生无效用户的登录尝试时，类似于`Failed
    password for invalid user bob from 203.83.248.32 port 7016 ssh2`的日志将被记录到`auth.log`。因此，我们需要排除日志文件中所有包含“invalid”单词的行。使用带有反转选项（`-v`）的`grep`命令来删除所有与无效用户对应的日志。下一步是找出发生登录尝试并失败的用户列表。SSH将记录类似于`sshd[21197]:
    Failed password for bob1 from 203.83.248.32 port 50035 ssh2`的日志行，表示密码错误。'
- en: Hence we should find all the lines with words "failed password". Now all the
    unique IP addresses are to be found out for extracting all the log lines corresponding
    to each IP address. The list of IP address is extracted by using a regular expression
    for IP address and the `egrep` command. A `for` loop is used to iterate through
    IP address and the corresponding log lines are found using `grep` and are written
    to a temporary file. The sixth word from the last word in the log line is the
    user name (for example, bob1 ). The `awk` command is used to extract the sixth
    word from the last word. `NF` returns the column number of the last word. Therefore,
    `NF-5` gives the column number of the sixth word from the last word. We use `sort`
    and `uniq` commands to produce a list of users without duplication.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该找到所有包含“failed password”单词的行。现在需要找出所有唯一的IP地址，以提取与每个IP地址对应的所有日志行。可以使用IP地址的正则表达式和`egrep`命令来提取IP地址的列表。使用`for`循环来迭代IP地址，并使用`grep`找到相应的日志行，并将其写入临时文件。日志行中倒数第六个单词是用户名（例如，bob1）。使用`awk`命令从最后一个单词中提取第六个单词。`NF`返回最后一个单词的列数。因此，`NF-5`给出了倒数第六个单词的列数。我们使用`sort`和`uniq`命令来生成一个不重复的用户列表。
- en: Now we should collect the failed login log lines containing the name of each
    users. A `for` loop is used for reading the lines corresponding to each user and
    the lines are written to a temporary file. The first 16 characters in each of
    the log lines is the timestamp. The `cut` command is used to extract the timestamp.
    Once we have all the timestamps for failed login attempts for a user, we should
    check the difference in time between the first attempt and the last attempt. The
    first log line corresponds to the first attempt and last log line corresponds
    to last attempt. We have used `head -1` to extract the first line and `tail -1`
    to extract the last line. Now we have a time stamp for first (`tstart`) and last
    attempt (`tends`) in string format. Using the `date` command, we can convert the
    date in string representation to total seconds in UNIX Epoch time (the recipe,
    *Getting, setting dates, and delays* of [Chapter 1](ch01.html "Chapter 1. Shell
    Something Out"), explains Epoch time).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该收集包含每个用户名称的失败登录日志行。使用`for`循环来读取与每个用户对应的行，并将这些行写入临时文件。每个日志行中的前16个字符是时间戳。使用`cut`命令来提取时间戳。一旦我们获得了用户的所有失败登录尝试的时间戳，我们应该检查第一次尝试和最后一次尝试之间的时间差。第一条日志行对应于第一次尝试，最后一条日志行对应于最后一次尝试。我们使用`head
    -1`提取第一行和`tail -1`提取最后一行。现在我们有第一次（`tstart`）和最后一次尝试（`tends`）的时间戳的字符串格式。使用`date`命令，我们可以将字符串表示的日期转换为UNIX
    Epoch时间的总秒数（第1章的*获取、设置日期和延迟*中的配方解释了Epoch时间）。
- en: The variables start and end have a time in seconds corresponding to the start
    and end timestamps in the date string. Now, take the difference between them and
    check whether it exceeds two minutes (120 seconds). Thus, the particular user
    is termed as an intruder and the corresponding entry with details are to be produced
    as a log. IP addresses can be extracted from the log by using a regular expression
    for IP address and the `egrep` command. The number of attempts is the number of
    log lines for the user. The number of lines can be found out by using the `wc`
    command. The host name mapping can be extracted from the output of the host command
    by running with IP address as argument. The time range can be printed using the
    timestamp we extracted. Finally, the temporary files used in the script are removed.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 变量start和end具有与日期字符串中的开始和结束时间戳对应的秒数。现在，取它们之间的差异，并检查是否超过两分钟（120秒）。因此，特定用户被称为入侵者，并且相应的带有详细信息的条目将被生成为日志。可以使用IP地址的正则表达式和`egrep`命令从日志中提取IP地址。尝试次数是用户的日志行数。可以使用`wc`命令找出行数。主机名映射可以通过使用IP地址作为参数运行host命令的输出来提取。时间范围可以使用我们提取的时间戳来打印。最后，脚本中使用的临时文件将被删除。
- en: The above script is aimed only at illustrating a model for scanning the log
    and producing a report from it. It has tried to make the script smaller and simpler
    to leave out the complexity. Hence it has few bugs. You can improve the script
    by using better logic.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本旨在说明从日志中扫描并生成报告的模型。它试图使脚本更小更简单，以排除复杂性。因此它有一些错误。您可以通过使用更好的逻辑来改进脚本。
- en: Remote disk usage health monitor
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程磁盘使用健康监视器
- en: A network consists of several machines with different users. The network requires
    centralized monitoring of disk usage of remote machines. The system administrator
    of the network needs to log the disk usage of all the machines in the network
    every day. Each log line should contain details such as the date, IP address of
    the machine, device, capacity of the device, used space, free space, percentage
    usage, and health status. If the disk usage of any of the partitions in any remote
    machine exceeds 80 percent, the health status should be set to ALERT, else it
    should be set to SAFE. This recipe will illustrate how to write a monitoring script
    that can collect details from remote machines in a network.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网络由几台具有不同用户的机器组成。网络需要对远程机器的磁盘使用情况进行集中监控。网络的系统管理员需要每天记录网络中所有机器的磁盘使用情况。每条日志行应包含日期、机器的IP地址、设备、设备容量、已使用空间、剩余空间、使用百分比和健康状态等详细信息。如果任何远程机器中任何分区的磁盘使用率超过80％，健康状态应设置为警报，否则应设置为安全。本示例将说明如何编写一个监控脚本，可以从网络中的远程机器收集详细信息。
- en: Getting ready
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to collect the disk usage statistics from each machine on the network,
    individually, and write a log file in the central machine. A script that collects
    the details and writes the log can be scheduled to run everyday at a particular
    time. The SSH can be used to log in to remote systems to collect disk usage data.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从网络中的每台机器单独收集磁盘使用统计信息，并在中央机器中编写日志文件。可以安排每天在特定时间运行收集详细信息并写入日志的脚本。可以使用SSH登录到远程系统来收集磁盘使用数据。
- en: How to do it…
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'First we have to set up a common user account on all the remote machines in
    the network. It is for the disklog program to log in to the system. We should
    configure auto-login with SSH for that particular user (the recipe, *Password-less
    auto-login with SSH* in[Chapter 7](ch07.html "Chapter 7. The Old-boy Network"),
    explains configuration of auto-login). We assume that there is a user called test
    in all remote machines configured with auto-login. Let''s go through the shell
    script:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须在网络中的所有远程机器上设置一个公共用户帐户。这是为了让disklog程序登录到系统中。我们应该为该特定用户配置SSH自动登录（在[第7章](ch07.html
    "第7章。老男孩网络")的*使用SSH进行无密码自动登录*一节中，解释了自动登录的配置）。我们假设所有远程机器中都有一个名为test的用户，配置了自动登录。让我们来看一下shell脚本：
- en: '[PRE64]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can schedule using the cron utility to run the script at regular intervals.
    For example, to run the script everyday at 10 am, write the following entry in
    the `crontab`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用cron实用程序安排定期运行脚本。例如，要在每天上午10点运行脚本，可以在`crontab`中写入以下条目：
- en: '[PRE65]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Run the command `crontab –e`. Add the above line and save the text editor.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令`crontab -e`。添加上述行并保存文本编辑器。
- en: 'You can run the script manually as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以手动运行脚本，如下所示：
- en: '[PRE66]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'A sample output log for the above script is as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本的示例输出日志如下：
- en: '![How to do it…](img/3760_08_02.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/3760_08_02.jpg)'
- en: How it works…
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In the `disklog.sh` script, we can provide the logfile path as a command-line
    argument or else it will use the default logfile. If the logfile does not exists,
    it will write the logfile header text into the new file. `–e $logfile` is used
    to check whether the file exists or not. The list of IP addresses of remote machines
    are stored in the variable `IP_LIST` delimited with spaces. It should be made
    sure that all the remote systems listed in the `IP_LIST` have a common user `test`
    with auto-login with SSH configured. A `for` loop is used to iterate through each
    of the IP addresses. A remote command `df –H` is executed to get the disk free
    usage data using the `ssh` command. It is stored in a temporary file. A `while`
    loop is used to read the file line by line. Data is extracted using `awk` and
    is printed. The date is also printed. The percentage usage is extracted using
    the `egrep` command and `%` is replaced with `none` to get the numeric value of
    percent. It is checked whether the percentage value exceeds 80\. If it is less
    than 80, the status is set as SAFE and if greater than or equal to 80, the status
    is set as ALERT. The entire printed data should be redirected to the logfile.
    Hence the portion of code is enclosed in a subshell `()` and the standard output
    is redirected to the logfile.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在`disklog.sh`脚本中，我们可以将日志文件路径作为命令行参数提供，否则它将使用默认日志文件。如果日志文件不存在，它将把日志文件头文本写入新文件中。使用`-e
    $logfile`来检查文件是否存在。远程机器的IP地址列表存储在变量`IP_LIST`中，用空格分隔。必须确保`IP_LIST`中列出的所有远程系统都有一个名为`test`的公共用户，并配置了SSH自动登录。使用`for`循环来迭代每个IP地址。执行远程命令`df
    -H`来使用`ssh`命令获取磁盘空闲使用数据。它被存储在一个临时文件中。使用`while`循环逐行读取文件。使用`awk`提取数据并打印。还打印日期。使用`egrep`命令提取百分比使用率，并用`none`替换`%`以获得百分比的数值。检查百分比值是否超过80。如果小于80，则状态设置为安全，如果大于或等于80，则状态设置为警报。整个打印数据应重定向到日志文件。因此，代码部分被封装在子shell`()`中，并且标准输出被重定向到日志文件。
- en: See also
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Scheduling with cron* of[Chapter 9](ch09.html "Chapter 9. Administration Calls"),
    explains the crontab command'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用cron进行调度*在[第9章](ch09.html "第9章。管理调用")中，解释了crontab命令'
- en: Finding out active user hours on a system
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找系统上活跃用户的小时数
- en: Consider a web server with shared hosting. Many users log in to and log out
    of the server every day. The user activity gets logged in the server's system
    log. This recipe is a practice task to make use of the system logs and to find
    out how many hours each of the users have spent on the server and rank them according
    to the total usage hours. A report should be generated with the details, such
    as the rank, user, first logged in date, last logged in date, number of times
    logged in, and total usage hours. Let's see how we can approach this problem.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个具有共享托管的Web服务器。每天有许多用户登录和退出服务器。用户活动记录在服务器的系统日志中。这个示例是一个实践任务，利用系统日志，找出每个用户在服务器上花了多少小时，并根据总使用小时数对它们进行排名。应该生成一个报告，包括排名、用户、第一次登录日期、最后登录日期、登录次数和总使用小时数等详细信息。让我们看看如何解决这个问题。
- en: Getting ready
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `last` command is used to list the details about the login sessions of the
    users in a system. The log data is stored in the `/var/log/wtmp` file. By individually
    adding the session hours for each user we can find out the total usage hours.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`last`命令用于列出系统中用户的登录会话的详细信息。日志数据存储在`/var/log/wtmp`文件中。通过为每个用户单独添加会话小时数，我们可以找出总使用小时数。'
- en: How to do it…
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s go through the script to find out active users and generate the report:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过脚本找出活跃用户并生成报告。
- en: '[PRE67]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'A sample output is as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例输出如下：
- en: '[PRE68]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How it works…
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `active_users.sh` script, we can either provide the `wtmp` log file as
    a command-line argument or it will use the `defaulwtmp` log file. The `last –f`
    command is used to print the logfile contents. The first column in the logfile
    is the user name. By using `cut` we extract the first column from the logfile.
    Then the unique users are found out by using the `sort` and `uniq` commands. Now
    for each user, the log lines corresponding to their login sessions are found out
    using `grep` and are written to a temporary file. The last column in the last
    log is the duration for which the user logged a session. Hence in order to find
    out the total usage hours for a user, the session durations are to be added. The
    usage duration is in `(HOUR:SEC)` format and it is to be converted into seconds
    using the date command.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在`active_users.sh`脚本中，我们可以将`wtmp`日志文件作为命令行参数提供，或者它将使用`defaulwtmp`日志文件。使用`last
    -f`命令来打印日志文件内容。日志文件中的第一列是用户名。通过使用`cut`命令，我们从日志文件中提取第一列。然后使用`sort`和`uniq`命令找出唯一的用户。现在对于每个用户，使用`grep`找出对应其登录会话的日志行，并将其写入临时文件。最后一条日志中的最后一列是用户登录会话的持续时间。因此，为了找出用户的总使用小时数，需要将会话持续时间相加。使用时间命令将使用持续时间转换为秒。
- en: In order to extract the session hours for the users, we have used the `awk`
    command. For removing the parenthesis, `tr –d` is used. The list of usage hour
    string is passed to the standard input for the `while` loop using the `<( COMMANDS
    )` operator. It acts as a file input. Each hour string, by using the `date` command,
    is converted into seconds and added to the variable `seconds`. The first login
    time for a user is in the last line and it is extracted. The number of login attempts
    is the number of log lines. In order to calculate the rank of each user according
    to the total usage hours, the data record is to be sorted in the descending order
    with usage hours as the key. For specifying the number reverse sort `-nr` option
    is used along with the `sort` command. `–k4` is used to specify the key column
    (usage hour). Finally, the output of the sort is passed to `awk`. The `awk` command
    prefixes a line number to each of the lines, which becomes the rank for each user.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取用户的会话小时数，我们使用了`awk`命令。为了去掉括号，使用了`tr -d`命令。使用`<( COMMANDS )`操作符将使用小时字符串列表传递给`while`循环的标准输入。它充当文件输入。通过使用`date`命令，将每个小时字符串转换为秒，并添加到变量`seconds`中。用户的第一次登录时间在最后一行，并且被提取出来。登录尝试次数是日志行数。为了根据总使用小时数计算每个用户的排名，数据记录需要按照使用小时作为关键字进行降序排序。为了指定反向排序的数量，使用`-nr`选项以及`sort`命令。`-k4`用于指定关键列（使用小时）。最后，排序的输出被传递给`awk`。`awk`命令为每行添加了行号，这成为每个用户的排名。
