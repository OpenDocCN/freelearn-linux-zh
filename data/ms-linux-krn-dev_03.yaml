- en: Signal Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号管理
- en: 'Signals provide a fundamental infrastructure in which any process can be notified
    of a system event asynchronously. They can also be engaged as communication mechanisms
    between processes. Understanding how the kernel provides and manages smooth throughput
    of the entire signal-handling mechanism lets us gain more grounding on the kernel.
    In this chapter, we shall pile on our understanding of signals, right from how
    processes can usher them to how the kernel deftly manages the routines to ensure
    signal events tick. We shall look at the following topics in great detail:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 信号提供了一个基本的基础设施，任何进程都可以异步地被通知系统事件。它们也可以作为进程之间的通信机制。了解内核如何提供和管理整个信号处理机制的平稳吞吐量，让我们对内核有更深入的了解。在本章中，我们将从进程如何引导信号到内核如何巧妙地管理例程以确保信号事件的发生，深入研究以下主题：
- en: Overview of signals and their types
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号概述及其类型
- en: Process-level signal-management calls
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程级别的信号管理调用
- en: Signal data structures in process descriptors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程描述符中的信号数据结构
- en: Kernel's signal generation and delivery mechanisms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核的信号生成和传递机制
- en: Signals
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号
- en: '**Signals** are short messages delivered to a process or a process group. The
    kernel uses signals to notify processes about the occurrence of a system event;
    signals are also used for communication between processes. Linux categorizes signals
    into two groups, namely general-purpose POSIX (classic Unix signals) and real-time
    signals. Each group consists of 32 distinct signals, identified by a unique ID:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**信号**是传递给进程或进程组的短消息。内核使用信号通知进程系统事件的发生；信号也用于进程之间的通信。Linux将信号分为两组，即通用 POSIX（经典
    Unix 信号）和实时信号。每个组包含 32 个不同的信号，由唯一的 ID 标识：'
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Signals in the general-purpose category are bound to a specific system event
    and are named appropriately through macros. Those in the real-time category aren''t
    bound to a specific event, and are free for applications to engage for process
    communication; the kernel refers to them with generic names: `SIGRTMIN` and `SIGRTMAX`.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通用 POSIX 类别中的信号与特定系统事件绑定，并通过宏适当命名。实时类别中的信号不与特定事件绑定，可以自由用于进程通信；内核用通用名称引用它们：`SIGRTMIN`
    和 `SIGRTMAX`。
- en: Upon generation of a signal, the kernel delivers the signal event to the destination
    process, which in turn can respond to the signal as per the configured action,
    called **signal disposition**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成信号时，内核将信号事件传递给目标进程，目标进程可以根据配置的操作（称为**信号处理方式**）对信号做出响应。
- en: The following is the list of actions that a process can set up as its signal
    disposition. A process can set up any one of the actions as its signal disposition
    at a point in time, but it can switch between these actions any number of times
    without any restrictions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是进程可以设置为其信号处理方式的操作列表。进程可以在某个时间点设置任何一个操作为其信号处理方式，但可以在没有任何限制的情况下在这些操作之间任意切换任意次数。
- en: '**Kernel handler**: The kernel implements a default handler for each signal.
    These handlers are available to a process through the signal handler table of
    its task structure. Upon reception of a signal, a process can request execution
    of the appropriate signal handler. This is the default disposition.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核处理程序**: 内核为每个信号实现了默认处理程序。这些处理程序通过任务结构的信号处理程序表对进程可用。收到信号后，进程可以请求执行适当的信号处理程序。这是默认的处理方式。'
- en: '**Process defined handler:** A process is allowed to implement its own signal
    handlers, and set them up to be executed in response to a signal event. This is
    made possible through the appropriate system call interface, which allows the
    process to bind its handler routine with a signal. On occurrence of a signal,
    the process handler would be invoked asynchronously.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程定义的处理程序:** 进程允许实现自己的信号处理程序，并设置它们以响应信号事件的执行。这是通过适当的系统调用接口实现的，允许进程将其处理程序例程与信号绑定。在发生信号时，进程处理程序将被异步调用。'
- en: '**Ignore:** A process is also allowed to ignore the occurrence of a signal,
    but it needs to announce its intent to ignore by invoking the appropriate system
    call.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**忽略:** 进程也可以忽略信号的发生，但需要通过调用适当的系统调用宣布其忽略意图。'
- en: 'Kernel-defined default handler routines can execute any of the following actions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 内核定义的默认处理程序例程可以执行以下任何操作：
- en: '**Ignore**: Nothing happens.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ignore**: 什么都不会发生。'
- en: '**Terminate**: Kill the process, that is, all threads in the group (similar
    to `exit_group`). The group leader (only) reports the `WIFSIGNALED` status to
    its parent.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终止**: 终止进程，即组中的所有线程（类似于 `exit_group`）。组长（仅）向其父进程报告 `WIFSIGNALED` 状态。'
- en: '**Coredump**: Write a core dump file describing all threads using the same
    `mm` and then kill all those threads'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Coredump**: 写入描述使用相同 `mm` 的所有线程的核心转储文件，然后终止所有这些线程'
- en: '**Stop**: Stop all the threads in the group, that is, the `TASK_STOPPED` state.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止**: 停止组中的所有线程，即 `TASK_STOPPED` 状态。'
- en: 'Following is the summarized table that lists out actions executed by default
    handlers:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是总结表，列出了默认处理程序执行的操作：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Signal-management APIs
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号管理 API
- en: 'Applications are provided with various APIs for managing signals; we shall
    take a look at few of the important ones:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序提供了各种 API 用于管理信号；我们将看一下其中一些重要的 API：
- en: '`Sigaction()`: User-mode processes use the POSIX API `sigaction()` to examine
    or change the disposition of a signal. This API provides a variety of attribute
    flags that can further define the behavior of a signal:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Sigaction()`: 用户模式进程使用 POSIX API `sigaction()` 来检查或更改信号的处理方式。该 API 提供了各种属性标志，可以进一步定义信号的行为：'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`int signum` is the identifier number of a recognized `signal`. `sigaction()`
    examines and sets the action to be associated with this signal.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int signum` 是已识别的 `signal` 的标识号。`sigaction()` 检查并设置与该信号关联的操作。'
- en: '`const struct sigaction *act` can be assigned with the address of a `struct
    sigaction` instance. The action specified in this structure becomes the new action
    bound to the signal. When the *act* pointer is left uninitialized (NULL), the
    current disposition is left unchanged.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const struct sigaction *act`可以被赋予一个`struct sigaction`实例的地址。在此结构中指定的操作成为与信号绑定的新操作。当*act*指针未初始化（NULL）时，当前的处理方式不会改变。'
- en: '`struct sigaction *oldact` is an outparam and needs to be initialized with
    the address of an uninitialized `sigaction` instance; `sigaction()` returns the
    action currently associated with the signal through this argument.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct sigaction *oldact`是一个outparam，需要用未初始化的`sigaction`实例的地址进行初始化；`sigaction()`通过此参数返回当前与信号关联的操作。'
- en: 'Following are the various `flag` options:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是各种`flag`选项：
- en: '`SA_NOCLDSTOP`: This flag is relevant only while binding the handler for `SIGCHLD`.
    It''s used to disable `SIGCHLD` notifications for stop (`SIGSTP`) and resume (`SIGCONT`)
    events on the child process.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SA_NOCLDSTOP`：此标志仅在绑定`SIGCHLD`的处理程序时相关。它用于禁用对子进程停止（`SIGSTP`）和恢复（`SIGCONT`）事件的`SIGCHLD`通知。'
- en: '`SA_NOCLDWAIT`: This flag is relevant only while binding the handler for the
    `SIGCHLD` or setting its disposition to `SIG_DFL`. Setting this flag causes the
    child process to be instantly destroyed on termination rather than having it in
    a *zombie* state.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SA_NOCLDWAIT`：此标志仅在绑定`SIGCHLD`的处理程序或将其设置为`SIG_DFL`时相关。设置此标志会导致子进程在终止时立即被销毁，而不是处于*僵尸*状态。'
- en: '`SA_NODEFER`: Setting this flag causes the generated signal to be delivered
    even if the corresponding handler is in execution.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SA_NODEFER`：设置此标志会导致生成的信号即使相应的处理程序正在执行也会被传递。'
- en: '`SA_ONSTACK`: This flag is relevant only while binding a signal handler. Setting
    this flag causes the signal handler to use an alternate stack; the alternate stack
    must be set up by the caller process through the `sigaltstack()` API. In the absence
    of an alternate stack, the handler will be invoked on the current stack.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SA_ONSTACK`：此标志仅在绑定信号处理程序时相关。设置此标志会导致信号处理程序使用备用堆栈；备用堆栈必须由调用进程通过`sigaltstack()`API设置。如果没有备用堆栈，处理程序将在当前堆栈上被调用。'
- en: '`SA_RESETHAND`: When this flag is applied with `sigaction()`, it makes the
    signal handler one-shot, that is, the action for the specified signal is reset
    to `SIG_DFL` for subsequent occurrences of this signal.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SA_RESETHAND`：当与`sigaction()`一起应用此标志时，它使信号处理程序成为一次性的，也就是说，指定信号的操作对于该信号的后续发生被重置为`SIG_DFL`。'
- en: '`SA_RESTART`: This flag enables the re-entry of system call operations, interrupted
    by the current signal handler.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SA_RESTART`：此标志使系统调用操作被当前信号处理程序中断后重新进入。'
- en: '`SA_SIGINFO`: This flag is used to indicate to the system that the signal handler
    is assigned--the `sa_sigaction` pointer of the `sigaction` structure instead of
    `sa_handler`. Handlers assigned to `sa_sigaction` receive two additional arguments:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SA_SIGINFO`：此标志用于向系统指示信号处理程序已分配--`sigaction`结构的`sa_sigaction`指针而不是`sa_handler`。分配给`sa_sigaction`的处理程序接收两个额外的参数：'
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The first argument is `signum`, to which the handler is bound. The second argument
    is an outparam that is a pointer to an object of type `siginfo_t`, which provides
    additional information about the source of the signal. Following is the full definition
    of `siginfo_t`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是`signum`，处理程序绑定的信号。第二个参数是一个outparam，是指向`siginfo_t`类型对象的指针，提供有关信号来源的附加信息。以下是`siginfo_t`的完整定义：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Sigprocmask()`: Apart from changing the signal disposition, which specifies
    the action to be executed on receipt of a signal, applications are also allowed
    to block or unblock signal delivery. Applications might need to carry out such
    operations while executing critical code blocks without preemption by an asynchronous
    signal handler. For instance, a network communication application might not want
    to handle signals while entering a code block that initiates a connection with
    its peers:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Sigprocmask()`：除了改变信号处理程序外，该处理程序还允许阻止或解除阻止信号传递。应用程序可能需要在执行关键代码块时进行这些操作，以防止被异步信号处理程序抢占。例如，网络通信应用程序可能不希望在进入启动与其对等体连接的代码块时处理信号：'
- en: '`sigprocmask()` is a POSIX API, used to examine, block, and unblock signals.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sigprocmask()`是一个POSIX API，用于检查、阻塞和解除阻塞信号。'
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Any occurrence of blocked signals is queued in a per-process pending signals
    list. The pending queue is designed to hold one occurrence of a blocked general-purpose
    signal while it queues every occurrence of a real-time signal. User-mode processes
    can probe for pending signals using the `sigpending()` and `rt_sigpending()` APIs.
    These routines return a list of pending signals into an instance pointed to by
    the `sigset_t` pointer.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 任何被阻止的信号发生都会排队在每个进程的挂起信号列表中。挂起队列设计用于保存一个被阻止的通用信号的发生，同时排队每个实时信号的发生。用户模式进程可以使用`sigpending()`和`rt_sigpending()`API来查询挂起信号。这些例程将挂起信号的列表返回到由`sigset_t`指针指向的实例中。
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The operations are applicable for all signals except `SIGKILL` and `SIGSTOP`;
    in other words, processes are not allowed to alter the default disposition or
    block `SIGSTOP` and `SIGKILL` signals.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作适用于除了`SIGKILL`和`SIGSTOP`之外的所有信号；换句话说，进程不允许改变默认的处理方式或阻止`SIGSTOP`和`SIGKILL`信号。
- en: Raising signals from a program
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从程序中引发信号
- en: '`kill()` and `sigqueue()` are POSIX APIs through which a process can raise
    a signal for another process or process group. These APIs facilitate utilization
    of signals as **process-communication** mechanisms:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`kill()`和`sigqueue()`是POSIX API，通过它们，一个进程可以为另一个进程或进程组引发信号。这些API促进了信号作为**进程通信**机制的利用：'
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'While both APIs provide arguments to specify the receiver `PID` and `signum`
    to be raised, `sigqueue()` provides an additional argument (union signal) through
    which *data* can be sent to the receiver process along with the signal. The destination
    process can access the data through `struct siginfo_t` (`si_value`) instances.
    Linux extends these functions with native APIs that can queue the signal to a
    thread group, or even to a lightweight process (LWP) in a thread group:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个API都提供了参数来指定接收者的`PID`和要提升的`signum`，`sigqueue()`通过一个额外的参数（联合信号）提供了*数据*可以与信号一起发送到接收进程。目标进程可以通过`struct
    siginfo_t`（`si_value`）实例访问数据。Linux通过本机API扩展了这些函数，可以将信号排队到线程组，甚至到线程组中的轻量级进程（LWP）：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Waiting for queued signals
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待排队信号
- en: 'When applying signals for process communication, it might be more appropriate
    for a process to suspend itself until the occurrence of a specific signal, and
    resume execution on the arrival of a signal from another process. The POSIX calls
    `sigsuspend()`, `sigwaitinfo()`, and `sigtimedwait()` provide this functionality:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用信号进行进程通信时，对于进程来说，暂停自身直到发生特定信号，然后在来自另一个进程的信号到达时恢复执行可能更合适。POSIX调用`sigsuspend()`、`sigwaitinfo()`和`sigtimedwait()`提供了这种功能：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'While all of these APIs allow a process to wait for a specified signal to occur,
    `sigwaitinfo()` provides additional data about the signal through the `siginfo_t`
    instance returned through the `info` pointer. `sigtimedwait()` extends the functionality
    by providing an additional argument that allows the operation to time out, making
    it a bounded wait call. The Linux kernel provides an alternate API that allows
    the process to be notified about the occurrence of a signal through a special
    file descriptor called `signalfd()`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有这些API允许进程等待指定的信号发生，`sigwaitinfo()`通过`info`指针返回的`siginfo_t`实例提供有关信号的附加数据。`sigtimedwait()`通过提供一个额外的参数扩展了功能，允许操作超时，使其成为一个有界等待调用。Linux内核提供了一个替代API，允许进程通过名为`signalfd()`的特殊文件描述符被通知信号的发生：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: On success, `signalfd()` returns a file descriptor, on which the process needs
    to invoke `read()`, which blocks until any of the signals specified in the mask
    occur.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，`signalfd()`返回一个文件描述符，进程需要调用`read()`来阻塞，直到掩码中指定的任何信号发生。
- en: Signal data structures
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号数据结构
- en: 'The kernel maintains per-process signal data structures to keep track of, *signal
    disposition,* *blocked signals*, and *pending signal queues*. The process task
    structure contains appropriate references to these data structures:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 内核维护每个进程的信号数据结构，以跟踪*信号处理*、*阻塞信号*和*待处理信号队列*。进程任务结构包含对这些数据结构的适当引用：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Signal descriptors
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号描述符
- en: Recall from our earlier discussions in the first chapter that Linux supports
    multi-threaded applications through lightweight processes. All LWPs of a threaded
    application are part of a *process group* and share signal handlers; each LWP
    (thread) maintains its own pending, and blocked signal queues.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下我们在第一章的早期讨论中提到的，Linux通过轻量级进程支持多线程应用程序。线程应用程序的所有LWP都是*进程组*的一部分，并共享信号处理程序；每个LWP（线程）维护自己的待处理和阻塞信号队列。
- en: The **signal** pointer of the task structure refers to the instance of type
    `signal_struct`, which is the signal descriptor. This structure is shared by all
    LWPs of a thread group and maintains elements such as a shared pending signal
    queue (for signals queued to a thread group), which is common to all threads in
    a process group.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 任务结构的**signal**指针指向`signal_struct`类型的实例，这是信号描述符。这个结构被线程组的所有LWP共享，并维护诸如共享待处理信号队列（对于排队到线程组的信号）之类的元素，这对进程组中的所有线程都是共同的。
- en: 'The following figure represents the data structures involved in maintaining
    shared pending signals:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示维护共享待处理信号所涉及的数据结构：
- en: '![](img/00014.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.jpeg)'
- en: 'Following are a few important fields of `signal_struct`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`signal_struct`的一些重要字段：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Blocked and pending queues
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻塞和待处理队列
- en: '`blocked` and `real_blocked` instances in the task structure are bit masks
    of blocked signals; these queues are per-process. Each LWP in a thread group thus
    has its own blocked signal mask. The `pending` instance of the task structure
    is used to queue private pending signals; all signals queued to a normal process
    and a specific LWP in a thread group are queued into this list:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 任务结构中的`blocked`和`real_blocked`实例是被阻塞信号的位掩码；这些队列是每个进程的。线程组中的每个LWP都有自己的阻塞信号掩码。任务结构的`pending`实例用于排队私有待处理信号；所有排队到普通进程和线程组中特定LWP的信号都排队到这个列表中：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following figure represents the data structures involved in maintaining
    private pending signals:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示维护私有待处理信号所涉及的数据结构：
- en: '![](img/00015.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: Signal handler descriptor
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号处理程序描述符
- en: 'The `sighand` pointer of the task structure refers to an instance of the struct
    `sighand_struct`, which is the signal handler descriptor shared by all processes
    in a thread group. This structure is also shared by all processes created using
    `clone()` with the `CLONE_SIGHAND` flag. This structure holds an array of `k_sigaction`
    instances, each wrapping an instance of `sigaction` that describes the current
    disposition of each signal:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 任务结构的`sighand`指针指向`struct sighand_struct`的一个实例，这是线程组中所有进程共享的信号处理程序描述符。这个结构也被所有使用`clone()`和`CLONE_SIGHAND`标志创建的进程共享。这个结构包含一个`k_sigaction`实例的数组，每个实例包装一个`sigaction`的实例，描述了每个信号的当前处理方式：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following figure represents the signal handler descriptor:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示信号处理程序描述符：
- en: '![](img/00016.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.jpeg)'
- en: Signal generation and delivery
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号生成和传递
- en: A signal is said to be **generated** when its occurrence is enqueued, to list
    of pending signals in the task structure of the receiver process or processes.
    The signal is generated (on a process or a group) upon request from a user-mode
    process, kernel, or any of the kernel services. A signal is considered to be **delivered**
    when the receiver process or processes are made aware of its occurrence and are
    forced to execute the appropriate response handler; in other words, signal delivery
    is equal to initialization of the corresponding handler. Ideally, every signal
    generated is assumed to be instantly delivered; however, there is a possibility
    of delay between signal generation, and it eventual delivery. To facilitate possible
    deferred delivery, the kernel provides separate functions for signal generation
    and delivery.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生信号时，将其加入到接收进程或进程的任务结构中的挂起信号列表中。信号是在用户模式进程、内核或任何内核服务的请求下生成的（对于进程或组）。当接收进程或进程意识到其发生并被强制执行适当的响应处理程序时，信号被认为是**已传递**；换句话说，信号传递等同于相应处理程序的初始化。理想情况下，每个生成的信号都被假定立即传递；然而，存在信号生成和最终传递之间的延迟可能性。为了便于可能的延迟传递，内核为信号生成和传递提供了单独的函数。
- en: Signal-generation calls
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号生成调用
- en: 'The kernel provides two separate group of functions for signal generation:
    one set for generating signals on individual process and another for process thread
    groups.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 内核为信号生成提供了两组不同的函数：一组用于在单个进程上生成信号，另一组用于进程线程组。
- en: 'Following is the list of important functions to generate signals on a process:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是生成进程信号的重要函数列表：
- en: '`send_sig()`: Generates a specified signal on a process; this function is used
    widely by kernel services'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_sig()`: 在进程上生成指定信号；这个函数被内核服务广泛使用'
- en: '`end_sig_info()`: Extends `send_sig()` with additional `siginfo_t` instances'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end_sig_info()`: 用额外的`siginfo_t`实例扩展`send_sig()`'
- en: '`force_sig()`: Used to generate priority non-maskable signals which cannot
    be ignored or blocked'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`force_sig()`: 用于生成无法被忽略或阻止的优先级非可屏蔽信号'
- en: '`force_sig_info()`: Extends `force_sig()` with additional `siginfo_t` instances.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`force_sig_info()`: 用额外的`siginfo_t`实例扩展`force_sig()`'
- en: All of these routines eventually invoke the core kernel function `send_signal()`
    which is programmed to generate a specified signal.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些例程最终调用核心内核函数`send_signal()`，该函数被设计用于生成指定的信号。
- en: 'Following is the list of important functions to generate signals on a process
    group:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是生成进程组信号的重要函数列表：
- en: '`kill_pgrp()`: Generates the specified signal on all thread groups in a process
    group'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kill_pgrp()`: 在进程组中的所有线程组上生成指定信号'
- en: '`kill_pid()`: Generates the specified signal to a thread group identified by
    a PID'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kill_pid()`: 向由PID标识的线程组生成指定信号'
- en: '`kill_pid_info()`: Extends `kill_pid()` with additional *`siginfo_t`* instances'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kill_pid_info()`: 用额外的`siginfo_t`实例扩展`kill_pid()`'
- en: All of these routines invoke a function `group_send_sig_info()` which eventually
    invokes `send_signal()` with appropriate parameters.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些例程调用一个名为`group_send_sig_info()`的函数，最终使用适当的参数调用`send_signal()`。
- en: 'The `send_signal()` function is the core signal-generation function; it invokes
    the `__send_signal()` routine with appropriate arguments:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_signal()`函数是核心信号生成函数；它使用适当的参数调用`__send_signal()`例程：'
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Following are important steps executed by `__send_signal()`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`__send_signal()`执行的重要步骤：
- en: 'Check for the source of the signal from the `info` argument. If signal generation
    was initiated by the kernel for non-maskable `SIGKILL` or `SIGSTOP`, it immediately
    sets the appropriate bit of the sigpending bitmask, sets the `TIF_SIGPENDING`
    flag, and initiates the delivery process by waking up the target thread:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`info`参数中检查信号的来源。如果信号生成是由内核发起的，对于不可屏蔽的`SIGKILL`或`SIGSTOP`，它立即设置适当的sigpending位，设置`TIF_SIGPENDING`标志，并通过唤醒目标线程启动传递过程：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Invoke the `__sigqeueue_alloc()` function, which checks if the number of pending
    signals for the receiver process is less than the resource limit. If true, it
    increments the pending signal counter and returns the address of the `struct sigqueue`
    instance:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`__sigqeueue_alloc()`函数，检查接收进程的挂起信号数量是否小于资源限制。如果是，则增加挂起信号计数器并返回`struct sigqueue`实例的地址：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Enqueue the `sigqueue` instance into the pending list and fill out the signal
    information into `siginfo_t`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`sigqueue`实例加入到挂起列表中，并将信号信息填入`siginfo_t`：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Set the appropriate signal bit in the pending signal''s bitmask, and attempt
    signal delivery by invoking `complete_signal(),` which in turn sets the `TIF_SIGPENDING`
    flag:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在挂起信号的位掩码中设置适当的信号位，并通过调用`complete_signal()`尝试信号传递，进而设置`TIF_SIGPENDING`标志：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Signal delivery
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号传递
- en: After a signal is **generated** by updating appropriate entries in the receiver's
    task structure, through any of the previously mentioned signal-generation calls,
    the kernel moves into delivery mode. The signal is instantly delivered if the
    receiver process was on CPU and has not blocked the specified signal. Priority
    signals `SIGSTOP` and `SIGKILL` are delivered even if the receiver is not on CPU
    by waking up the process; however, for the rest of the signals, **delivery** is
    deferred until the process is ready to receive signals. To facilitate deferred
    delivery, the kernel checks for nonblocked pending signals of a process on return
    from **interrupt** and **system calls** before allowing a process to resume user-mode
    execution. When the process scheduler (invoked on return from interrupt and exceptions)
    finds the `TIF_SIGPENDING` flag set, it invokes the kernel function `do_signal()`
    to initiate delivery of the pending signal before resuming the user-mode context
    of the process.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 信号通过更新接收器任务结构中的适当条目生成后，内核进入传递模式。如果接收进程在CPU上并且未阻止指定的信号，则立即传递信号。即使接收方不在CPU上，也会传递优先级信号`SIGSTOP`和`SIGKILL`，通过唤醒进程；然而，对于其余的信号，传递将推迟直到进程准备好接收信号。为了便于推迟传递，内核在从中断和系统调用返回时检查进程的非阻塞挂起信号，然后允许进程恢复用户模式执行。当进程调度程序（在从中断和异常返回时调用）发现`TIF_SIGPENDING`标志设置时，它调用内核函数`do_signal()`来启动挂起信号的传递，然后恢复进程的用户模式上下文。
- en: 'Upon entry into kernel mode, the user-mode register state of the process is
    stored in the process kernel stack in a structure called `pt_regs` (architecture
    specific):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 进入内核模式时，进程的用户模式寄存器状态存储在称为`pt_regs`的进程内核堆栈中（特定于体系结构）：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `do_signal()` routine is invoked with the address of `pt_regs` in the kernel
    stack. Though `do_signal()` is meant to deliver nonblocked pending signals, its
    implementation is architecture specific.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`do_signal()`例程在内核堆栈中使用`pt_regs`的地址调用。虽然`do_signal()`旨在传递非阻塞的挂起信号，但其实现是特定于体系结构的。'
- en: 'Following is the x86 version of `do_signal()`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`do_signal()`的x86版本：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`do_signal()` invokes the `get_signal()` function with the address of an instance
    of type `struct ksignal` (we shall briefly consider important steps of this routine,
    skipping other details). This function contains a loop that invokes `dequeue_signal()`
    until all non-blocked pending signals from both private and shared pending lists
    are dequeued. It begins with lookup into the private pending signal queue, starting
    from the lowest-numbered signal, and follows into pending signals in the shared
    queue, and then updates the data structures to indicate that the signal is no
    longer pending and returns its number:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`do_signal()`使用`struct ksignal`类型实例的地址调用`get_signal()`函数（我们将简要考虑此例程的重要步骤，跳过其他细节）。此函数包含一个循环，它调用`dequeue_signal()`直到从私有和共享挂起列表中取出所有非阻塞的挂起信号。它从最低编号的信号开始查找私有挂起信号队列，然后进入共享队列中的挂起信号，然后更新数据结构以指示该信号不再挂起并返回其编号：'
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For each pending signal returned by `dequeue_signal())`, `get_signal()` retrieves
    the current signal disposition through a pointer of type `struct ksigaction *ka`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`dequeue_signal()`返回的每个挂起信号，`get_signal()`通过`struct ksigaction *ka`类型的指针检索当前的信号处理方式：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If signal disposition is set to `SIG_IGN`, it silently ignores the current
    signal and continues iteration to retrieve another pending signal:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果信号处理方式设置为`SIG_IGN`，则静默忽略当前信号并继续迭代以检索另一个挂起信号：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If disposition is not equal to `SIG_DFL`, it retrieves the address of **sigaction**
    and initializes it into arguments `ksig->ka` for further execution of the user-mode
    handler. It further checks for the `SA_ONESHOT (SA_RESETHAND)` flag in the user's
    **sigaction** and, if set, resets the signal disposition to `SIG_DFL`, breaks
    out of the loop, and returns to the caller. `do_signal()` now invokes the `handle_signal()`
    routine to execute the user-mode handler (we shall discuss this in detail in the
    next section).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理方式不等于`SIG_DFL`，则检索**sigaction**的地址并将其初始化为参数`ksig->ka`，以便进一步执行用户模式处理程序。它进一步检查用户的**sigaction**中的`SA_ONESHOT
    (SA_RESETHAND)`标志，如果设置，则将信号处理方式重置为`SIG_DFL`，跳出循环并返回给调用者。`do_signal()`现在调用`handle_signal()`例程来执行用户模式处理程序（我们将在下一节详细讨论这个）。
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If disposition is set to `SIG_DFL`, it invokes a set of macros to check for
    the **default action** of the kernel handler. Possible default actions are:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理方式设置为`SIG_DFL`，则调用一组宏来检查内核处理程序的默认操作。可能的默认操作是：
- en: '**Term**: Default action is to terminate the process'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Term**：默认操作是终止进程'
- en: '**Ign**: Default action is to ignore the signal'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ign**：默认操作是忽略信号'
- en: '**Core**: Default action is to terminate the process and dump core'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Core**：默认操作是终止进程并转储核心'
- en: '**Stop**: Default action is to stop the process'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Stop**：默认操作是停止进程'
- en: '**Cont**: Default action is to continue the process if it is currently stopped'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cont**：默认操作是如果当前停止则继续进程'
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: First, the macro `sig_kernel_ignore` checks for the default action ignore. If
    true, it continues loop iteration to look for the next pending signal. The second
    macro `sig_kernel_stop` checks for the default action stop; if true, it invokes
    the `do_signal_stop()` routine, which puts each thread in the process group into
    the `TASK_STOPPED`state. The third macro `sig_kernel_coredump` checks for the
    default action dump; if true, it invokes the `do_coredump()` routine, which generates
    the coredump binary file and terminates all the processes in the thread group.
    Next, for signals with default action terminate, all threads in the group are
    killed by invoking the `do_group_exit()` routine.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，宏`sig_kernel_ignore`检查默认操作是否为忽略。如果为真，则继续循环迭代以查找下一个挂起信号。第二个宏`sig_kernel_stop`检查默认操作是否为停止；如果为真，则调用`do_signal_stop()`例程，将进程组中的每个线程置于`TASK_STOPPED`状态。第三个宏`sig_kernel_coredump`检查默认操作是否为转储；如果为真，则调用`do_coredump()`例程，生成转储二进制文件并终止线程组中的所有进程。接下来，对于默认操作为终止的信号，通过调用`do_group_exit()`例程杀死组中的所有线程。
- en: Executing user-mode handlers
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行用户模式处理程序
- en: Recall from our discussion in the previous section that `do_signal()` invokes
    the `handle_signal()` routine for delivery of pending signals whose disposition
    is set to user handler. The user-mode signal handler resides in the process code
    segment and requires access to the user-mode stack of the process; therefore,
    the kernel needs to switch to the user-mode stack for executing the signal handler.
    Successful return from the signal handler requires a switch back to the kernel
    stack to restore the user context for normal user-mode execution, but such an
    operation would fail since the kernel stack would no longer contain the user context
    (`struct pt_regs`) since it is emptied on each entry of the process from user
    to kernel mode.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们在上一节中的讨论，`do_signal()` 调用 `handle_signal()` 例程以传递处于用户处理程序状态的挂起信号。用户模式信号处理程序驻留在进程代码段中，并需要访问进程的用户模式堆栈；因此，内核需要切换到用户模式堆栈以执行信号处理程序。成功从信号处理程序返回需要切换回内核堆栈以恢复用户上下文以进行正常的用户模式执行，但这样的操作将失败，因为内核堆栈不再包含用户上下文（`struct
    pt_regs`），因为在每次进程从用户模式进入内核模式时都会清空它。
- en: To ensure smooth transition of the process for its normal execution in user
    mode (on return from the signal handler), `handle_signal()` moves the user-mode
    hardware context (`struct pt_regs`) in the kernel stack into the user-mode stack
    (`struct ucontext`) and sets up the handler frame to invoke the `_kernel_rt_sigreturn()`
    routine during return; this function copies the hardware context back into the
    kernel stack and restores the user-mode context for resuming normal execution
    of the current process.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保进程在用户模式下正常执行时的平稳过渡（从信号处理程序返回），`handle_signal()` 将内核堆栈中的用户模式硬件上下文（`struct
    pt_regs`）移动到用户模式堆栈（`struct ucontext`）中，并设置处理程序帧以在返回时调用 `_kernel_rt_sigreturn()`
    例程；此函数将硬件上下文复制回内核堆栈，并恢复当前进程的用户模式上下文以恢复正常执行。
- en: 'The following figure depicts the execution of a user-mode signal handler:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了用户模式信号处理程序的执行：
- en: '![](img/00017.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00017.jpeg)'
- en: Setting up user-mode handler frames
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置用户模式处理程序帧
- en: To set up a stack frame for a user-mode handler, `handle_signal()` invokes `setup_rt_frame()`
    with the address of the instance of `ksignal`, which contains the `k_sigaction`
    associated with the signal and the pointer to `struct pt_regs` in the kernel stack
    of the current process.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为用户模式处理程序设置堆栈帧，`handle_signal()` 使用 `ksignal` 实例的地址调用 `setup_rt_frame()`，其中包含与信号相关的
    `k_sigaction` 和当前进程内核堆栈中 `struct pt_regs` 的指针。
- en: 'Following is x86 implementation of `setup_rt_frame()`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `setup_rt_frame()` 的 x86 实现：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It checks for the specific variant of x86 and invokes the appropriate frame
    setup routine. For further discussion, we shall focus on `__setup_rt_frame()`,
    which applies for x86-64\. This function populates an instance of a structure
    called `struct rt_sigframe` with information needed to handle the signal, sets
    up a return path (through the `_kernel_rt_sigreturn()` function), and pushes it
    into the user-mode stack:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它检查 x86 的特定变体，并调用适当的帧设置例程。在进一步讨论中，我们将专注于适用于 x86-64 的 `__setup_rt_frame()`。此函数使用一个名为
    `struct rt_sigframe` 的结构的实例填充了处理信号所需的信息，设置了一个返回路径（通过 `_kernel_rt_sigreturn()`
    函数），并将其推送到用户模式堆栈中。
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `*pretcode` field of the `rt_sigframe` structure is assigned the return
    address of the signal-handler function, which is the `_kernel_rt_sigreturn()`
    routine. `struct ucontext uc` is initialized with `sigcontext`, which contains
    the user-mode context copied from `pt_regs` of the kernel stack, bit array of
    regular blocked signals, and floating point state. After setting up and pushing
    the `frame` instance to the user-mode stack, `__setup_rt_frame()` alters `pt_regs`
    of the process in the kernel stack to hand over control to the signal handler
    when the current process resumes execution. The **instruction pointer (ip)** is
    set to the base address of the signal handler and the **stack** **pointer (sp)**
    is set to the top address of the frame pushed earlier; these changes cause the
    signal handler to execute.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`rt_sigframe` 结构的 `*pretcode` 字段被分配为信号处理程序函数的返回地址，该函数是 `_kernel_rt_sigreturn()`
    例程。 `struct ucontext uc` 用 `sigcontext` 初始化，其中包含从内核堆栈的 `pt_regs` 复制的用户模式上下文，常规阻塞信号的位数组和浮点状态。在设置并将
    `frame` 实例推送到用户模式堆栈后，`__setup_rt_frame()` 改变了进程的内核堆栈中的 `pt_regs`，以便在当前进程恢复执行时将控制权交给信号处理程序。**指令指针（ip）**设置为信号处理程序的基地址，**堆栈指针（sp）**设置为先前推送的帧的顶部地址；这些更改导致信号处理程序执行。'
- en: Restarting interrupted system calls
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新启动中断的系统调用
- en: We understood in [Chapter 1](part0020.html#J2B80-7300e3ede2f245b0b80e1b18d02a323f),
    *Comprehending Processes, Address Space, and Threads* that user-mode processes
    invoke *system calls* to switch into kernel mode for executing kernel services.
    When a process enters a kernel service routine, there is a possibility of the
    routine being blocked for availability of resources (for example, wait on exclusion
    lock) or occurrence of an event (such as interrupts). Such blocking operations
    require the caller process to be put into the `TASK_INTERRUPTIBLE,` `TASK_UNINTERRUPTIBLE`,
    *or* `TASK_KILLABLE` state. The specific state effected depends on the choice
    of blocking call invoked in the system calls.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](part0020.html#J2B80-7300e3ede2f245b0b80e1b18d02a323f)中了解到，用户模式进程调用
    *系统调用* 以切换到内核模式执行内核服务。当进程进入内核服务例程时，有可能例程被阻塞以等待资源的可用性（例如，等待排他锁）或事件的发生（例如中断）。这些阻塞操作要求调用进程处于
    `TASK_INTERRUPTIBLE`、`TASK_UNINTERRUPTIBLE` 或 `TASK_KILLABLE` 状态。所采取的具体状态取决于在系统调用中调用的阻塞调用的选择。
- en: If the caller task is put into the `TASK_UNINTERRUPTIBLE` state, occurrences
    of signals on that task are generated, causing them to enter the pending list,
    and are delivered to the process only after completion of the service routine
    (on its return path to user mode). However, if the task was put into the `TASK_INTERRUPTIBLE`
    state, occurrences of signals on that task are generated and an immediate delivery
    is attempted by altering its state to `TASK_RUNNING`, which causes the task to
    wake up on a blocked system call even before the system call is completed (resulting
    in the system call operation to fail). Such interruptions are indicated by returning
    the appropriate failure code. The effect of signals on a task in the `TASK_KILLABLE`
    state is similar to `TASK_INTERRUPTIBLE`, except that wake-up is only effected
    on occurrence of the fatal `SIGKILL` signal.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用者任务被置于`TASK_UNINTERRUPTIBLE`状态，那么在该任务上发生的信号会导致它们进入挂起列表，并且仅在服务例程完成后（返回到用户模式时）才会传递给进程。然而，如果任务被置于`TASK_INTERRUPTIBLE`状态，那么在该任务上发生的信号会导致其状态被改变为`TASK_RUNNING`，从而导致任务在阻塞的系统调用上被唤醒，甚至在系统调用完成之前就被唤醒（导致系统调用操作失败）。这种中断通过返回适当的失败代码来指示。在`TASK_KILLABLE`状态下，信号对任务的影响与`TASK_INTERRUPTIBLE`类似，只是在发生致命的`SIGKILL`信号时才会唤醒。
- en: '`EINTR`*,* `ERESTARTNOHAND`*,* `ERESTART_RESTARTBLOCK`*,* `ERESTARTSYS`, or
    `ERESTARTNOINTR` are various kernel-defined failure codes; system calls are programmed
    to return appropriate error flags on failure. Choice of error code determines
    whether failed system call operations are restarted after the interrupting signal
    is handled:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`EINTR`、`ERESTARTNOHAND`、`ERESTART_RESTARTBLOCK`、`ERESTARTSYS`或`ERESTARTNOINTR`是各种内核定义的失败代码；系统调用被编程为在失败时返回适当的错误标志。错误代码的选择决定了在处理中断信号后是否重新启动失败的系统调用操作：'
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'On return from an interrupted system call, the user-mode API always returns
    the `EINTR` error code, irrespective of the specific error code returned by the
    underlying kernel service routine. The remaining error codes are used by the signal-delivery
    routines of the kernel to determine whether interrupted system calls can be restarted
    on return from the signal handler.The following table shows the error codes for
    when system call execution gets interrupted and the effect it has for various
    signal dispositions:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从中断的系统调用返回时，用户模式API始终返回`EINTR`错误代码，而不管底层内核服务例程返回的具体错误代码是什么。其余的错误代码由内核的信号传递例程使用，以确定从信号处理程序返回时是否可以重新启动中断的系统调用。以下表格显示了系统调用执行被中断时的错误代码以及对各种信号处理的影响：
- en: '![](img/00018.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpeg)'
- en: 'This is what they mean:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它们的含义：
- en: '**No Restart**: The system call will not be restarted. The process will resume
    execution in user mode from the instruction that follows the system call (int
    $0x80 or sysenter).'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不重新启动**：系统调用不会被重新启动。进程将从跟随系统调用的指令（int $0x80或sysenter）中的用户模式恢复执行。'
- en: '**Auto Restart**: The kernel forces the user process to re-initiate the system
    call operation by loading the corresponding syscall identifier into *eax* and
    executing the syscall instruction (int $0x80 or sysenter).'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动重启**：内核强制用户进程通过将相应的系统调用标识符加载到*eax*中并执行系统调用指令（int $0x80或sysenter）来重新启动系统调用操作。'
- en: '**Explicit Restart**: The system call is restarted only if the process has
    enabled the `SA_RESTART` flag while setting up the handler (through sigaction)
    for the interrupting signal.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式重启**：只有在进程设置中断信号的处理程序（通过sigaction）时启用了`SA_RESTART`标志，系统调用才会被重新启动。'
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Signals, though a rudimentary form of communication engaged by processes and
    kernel services, provide an easy and effective way to get asynchronous responses
    from a running process on occurrence of various events. By understanding all core
    aspects of signal usage, their representation, data structures and kernel routines
    for signal generation and delivery, we are now more kernel aware and also better
    prepared to look at more sophisticated means of communication between processes,
    in a later part of this book. After having spent the first three chapters on processes
    and their related aspects, we shall now delve into other subsystems of the kernel
    to notch up our visibility. In the next chapter, we will build our understanding
    of one of the core aspects of the kernel, the memory subsystem.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 信号，虽然是进程和内核服务之间进行的一种基本形式的通信，但它们提供了一种简单有效的方式，以便在发生各种事件时从运行中的进程获得异步响应。通过理解信号使用的所有核心方面，它们的表示、数据结构和内核例程用于信号生成和传递，我们现在对内核更加了解，也更有准备在本书的后面部分更深入地研究进程之间更复杂的通信方式。在前三章中讨论了进程及其相关方面之后，我们现在将深入研究内核的其他子系统，以提高我们的可见性。在下一章中，我们将建立对内核的核心方面之一——内存子系统的理解。
- en: Throughout the next chapter, we will go through comprehending step by step many
    critical aspects of memory management such as memory initialization, paging and
    protection, and kernel memory allocation algorithms, among others.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的一章中，我们将逐步理解许多关键的内存管理方面，如内存初始化、分页和保护，以及内核内存分配算法等。
