- en: '*Chapter 10*: Visual Studio Code and Containers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：Visual Studio Code和容器'
- en: In [*Chapter 9*](B16412_09_Final_JC_ePub.xhtml#_idTextAnchor111), *Visual Studio
    Code and WSL*, we saw how the Visual Studio Code editor allows the user interface
    to be separated from other functionality that interacts with our code and runs
    it. With WSL, this allows us to keep the familiar Windows-based user interface
    while running all the key parts of our project in Linux. In addition to allowing
    the code interactions to run in a server component in WSL, Visual Studio Code
    also allows us to connect to the code server via SSH or to run it in a container.
    The ability to run in a container is provided by the **Remote-Containers** extension,
    and this chapter will focus on how we can use this functionality. We will see
    how we can use these development containers (or **dev container**) to encapsulate
    our project dependencies. By doing this, we make it easier to onboard people to
    our projects and gain an elegant way to isolate potentially conflicting toolsets
    between projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B16412_09_Final_JC_ePub.xhtml#_idTextAnchor111)，*Visual Studio Code和WSL*中，我们看到Visual
    Studio Code编辑器允许将用户界面与与我们的代码交互和运行代码的其他功能分离。通过WSL，这使我们可以在运行我们项目的所有关键部分的Linux中保持熟悉的基于Windows的用户界面。除了允许代码交互在WSL中的服务器组件中运行外，Visual
    Studio Code还允许我们通过SSH连接到代码服务器或在容器中运行它。能够在容器中运行是由**Remote-Containers**扩展提供的，本章将重点介绍如何使用此功能。我们将看到如何使用这些开发容器（或**dev
    container**）来封装我们的项目依赖项。通过这样做，我们可以更容易地将人们引入我们的项目，并获得一种优雅的方式来隔离可能发生冲突的工具集。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要内容：
- en: Introducing Visual Studio Code Remote-Containers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Visual Studio Code Remote-Containers
- en: Installing Remote-Containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Remote-Containers
- en: Creating a dev container
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个dev容器
- en: Working with a containerized app in dev containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发容器中使用容器化应用程序
- en: Working with Kubernetes in dev containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在开发容器中使用Kubernetes
- en: Tips for working with dev containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用开发容器的技巧
- en: For this chapter, you will need to have Visual Studio Code installed – see [*Chapter
    9*](B16412_09_Final_JC_ePub.xhtml#_idTextAnchor111), *Visual Studio Code and WSL*,
    the *Introducing Visual Studio Code* section for more details. We'll start the
    chapter by introducing the Remote-Containers extension for Visual Studio Code
    and getting it installed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您需要安装Visual Studio Code - 请参阅[*第9章*](B16412_09_Final_JC_ePub.xhtml#_idTextAnchor111)，*Visual
    Studio Code和WSL*，*介绍Visual Studio Code*部分了解更多详细信息。我们将通过介绍Visual Studio Code的Remote-Containers扩展并将其安装来开始本章。
- en: Introducing Visual Studio Code Remote-Containers
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Visual Studio Code Remote-Containers
- en: The Remote-Containers extension for Visual Studio Code sits as part of the Remote-Development
    extension pack alongside **Remote-WSL** and **Remote-SSH**. All of these extensions
    allow you to separate the user interface aspects from the code interactions, such
    as loading, running, and debugging your code. With Remote-Containers, we instruct
    Visual Studio Code to run these code interactions inside a container that we define
    in a **Dockerfile** (see [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082),
    *Working with Containers in WSL*, the *Introducing Dockerfiles* section).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code的Remote-Containers扩展作为Remote-Development扩展包的一部分，与**Remote-WSL**和**Remote-SSH**一起。所有这些扩展都允许您将用户界面方面与代码交互分离，例如加载、运行和调试代码。通过Remote-Containers，我们指示Visual
    Studio Code在我们在**Dockerfile**中定义的容器内运行这些代码交互（请参阅[*第7章*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082)，*在WSL中使用容器*，*介绍Dockerfiles*部分）。
- en: 'When Visual Studio Code loads our project in a dev container, it goes through
    the following steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当Visual Studio Code在开发容器中加载我们的项目时，它经过以下步骤：
- en: Builds the container image from the Dockerfile
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Dockerfile构建容器镜像
- en: Runs a container using the resulting image, mounting the source code in the
    container
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用生成的镜像运行容器，将源代码挂载到容器中。
- en: Installs the VS code server in the container for the user interface to connect
    to
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器中为用户界面安装VS代码服务器
- en: Through these steps, we get a container image that contains the dependencies
    described by our Dockerfile. By mounting the code inside the container, it is
    made available inside the container, but there is only a single copy of the code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们得到一个包含我们的Dockerfile描述的依赖项的容器镜像。通过将代码挂载到容器内部，代码可以在容器内部使用，但只有一份代码的副本。
- en: On development projects, it is common to have a list of tools or prerequisites
    that need to be installed to prepare your environment for working with the project
    in the project documentation. If you're really lucky, the list will even be up
    to date! By using *dev containers*, we can replace the list of tools in the documentation
    with a set of steps in a Dockerfile that perform the steps for us. Because these
    images can be rebuilt, the standard way to install a tool now becomes the Dockerfile.
    Since this is part of source control, these changes in required tools will be
    shared with other developers who can simply rebuild their dev container image
    from the Dockerfile to update their set of tools.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发项目中，通常会有一份工具或先决条件列表，需要安装这些工具以准备好与项目一起工作。如果你很幸运，这个列表甚至会是最新的！通过使用*dev containers*，我们可以用Dockerfile中的一系列步骤替换文档中的工具列表来执行这些步骤。由于这些镜像可以重新构建，安装工具的标准方式现在变成了Dockerfile。由于这是源代码控制的一部分，所以这些所需工具的更改将与其他开发人员共享，他们只需从Dockerfile重新构建他们的dev容器镜像即可更新他们的工具集。
- en: Another benefit of dev containers is that the dependencies are installed in
    containers and so are isolated. This allows us to create containers for different
    projects with different versions of the same tools (for example, Python or Java)
    without conflicts. This isolation also allows us to update the versions of tools
    independently between projects.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 开发容器的另一个好处是依赖项安装在容器中，因此是隔离的。这使我们能够为不同项目创建具有相同工具的不同版本的容器（例如Python或Java），而不会发生冲突。这种隔离还允许我们在项目之间独立更新工具的版本。
- en: Let's look at getting the Remote-Containers extension installed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看如何安装Remote-Containers扩展。
- en: Installing Remote-Containers
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Remote-Containers
- en: 'To use the Remote-Containers extension, you will need it installed, and you
    will also need to have Docker installed and accessible in WSL. See [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082),
    *Working with Containers in WSL*, the *Installing and using Docker with WSL* section
    for how to configure this. If you already have Docker Desktop installed, ensure
    that it is configured to use the **WSL 2-based engine**. The WSL 2 engine uses
    a Docker daemon running in WSL 2, so your code files (from WSL 2) can be mounted
    directly in your containers, without going through the Linux-to-Windows file share.
    This direct mounting gives you better performance, ensures that file events are
    handled correctly, and uses the same file cache (see this blog post for more details:
    [https://www.docker.com/blog/docker-desktop-wsl-2-best-practices/)](https://www.docker.com/blog/docker-desktop-wsl-2-best-practices/)).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Remote-Containers扩展，您需要安装它，并且还需要在WSL中安装和访问Docker。请参阅[*第7章*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082)，*在WSL中使用容器*，*使用WSL安装和使用Docker*部分以了解如何配置。如果您已经安装了Docker
    Desktop，请确保将其配置为使用**基于WSL 2的引擎**。WSL 2引擎使用在WSL 2中运行的Docker守护程序，因此您的代码文件（来自WSL
    2）可以直接挂载到容器中，而无需经过Linux到Windows文件共享。这种直接挂载可以提供更好的性能，确保文件事件被正确处理，并使用相同的文件缓存（有关更多详细信息，请参阅此博文：[https://www.docker.com/blog/docker-desktop-wsl-2-best-practices/)](https://www.docker.com/blog/docker-desktop-wsl-2-best-practices/)）。
- en: Once you have Docker configured, the next step is to install the Remote-Containers
    extension. You can do this by searching for `Remote-Containers` in the **EXTENSIONS**
    view in Visual Studio Code, or from [https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您配置好了Docker，下一步是安装Remote-Containers扩展。您可以在Visual Studio Code的**EXTENSIONS**视图中搜索`Remote-Containers`来完成此操作，或者访问[https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers)。
- en: With the extension installed, let's look at how to create a dev container.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了扩展后，让我们看看如何创建开发容器。
- en: Creating a dev container
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建开发容器
- en: 'To add a dev container to a project, we need to create a `.devcontainer` folder
    with two files:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要将开发容器添加到项目中，我们需要创建一个包含两个文件的`.devcontainer`文件夹：
- en: '`Dockerfile` to describe the container image to build and run'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dockerfile`用于描述要构建和运行的容器映像'
- en: '`devcontainer.json` to add additional configuration'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devcontainer.json`以添加其他配置'
- en: This combination of files will give us a single-container configuration. Remote-Containers
    also supports a multi-container configuration using **Docker Compose** (see [https://code.visualstudio.com/docs/remote/create-dev-container#_using-docker-compose](https://code.visualstudio.com/docs/remote/create-dev-container#_using-docker-compose))
    but we will focus on the single-container scenario for this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件的组合将为我们提供一个单容器配置。Remote-Containers还支持使用**Docker Compose**的多容器配置（参见[https://code.visualstudio.com/docs/remote/create-dev-container#_using-docker-compose](https://code.visualstudio.com/docs/remote/create-dev-container#_using-docker-compose)），但在本章中，我们将重点关注单容器场景。
- en: The accompanying code for the book contains a sample project that we will use
    to explore dev containers. Ensure that you clone the code from [https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques](https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques)
    in a Linux distribution. Once the code is cloned, open the `chapter-10/01-web-app`
    folder in Visual Studio Code (there is also a `chapter-10/02-web-app-completed`
    folder with all of the steps from this section applied as a reference). This sample
    code doesn't yet have a dev container definition, so let's look at how to add
    it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本书附带的代码包含一个示例项目，我们将使用它来探索开发容器。请确保从[https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques](https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques)在Linux发行版中克隆代码。克隆代码后，在Visual
    Studio Code中打开`chapter-10/01-web-app`文件夹（还有一个`chapter-10/02-web-app-completed`文件夹，其中包含了本节中的所有步骤作为参考）。这个示例代码还没有开发容器定义，所以让我们看看如何添加它。
- en: Adding and opening a dev container definition
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和打开开发容器定义
- en: 'The first step for dev containers is to create the **dev container definition**,
    and the Remote-Containers extension gives us some assistance here. With the sample
    project open in Visual Studio Code, select **Remote-Containers: Add Development
    Container Configuration Files…** from the command palette and you will be prompted
    to choose a configuration:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '开发容器的第一步是创建**开发容器定义**，Remote-Containers扩展在这方面为我们提供了一些帮助。在Visual Studio Code中打开示例项目后，从命令面板中选择**Remote-Containers:
    Add Development Container Configuration Files…**，然后您将被提示选择一个配置：'
- en: '![Figure 10.1 – A screenshot showing the list of dev container configurations'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1-显示开发容器配置列表的屏幕截图'
- en: '](img/Figure_10.1_B16412.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.1_B16412.jpg)'
- en: Figure 10.1 – A screenshot showing the list of dev container configurations
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1-显示开发容器配置列表的屏幕截图
- en: 'As shown in this screenshot, there is a range of predefined dev container configurations
    that we can start from. For the sample project, choose `.devcontainer` folder
    with `devcontainer.json` and `Dockerfile` configured for working with Python 3\.
    Once these files have been added, you should see the following prompt:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如此屏幕截图所示，我们可以从一系列预定义的开发容器配置中选择。对于示例项目，请选择`.devcontainer`文件夹，并配置`devcontainer.json`和`Dockerfile`以使用Python
    3。添加这些文件后，您应该会看到以下提示：
- en: '![Figure 10.2 – A screenshot showing the Reopen in Container prompt'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2-显示重新在容器中打开提示的屏幕截图'
- en: '](img/Figure_10.2_B16412.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.2_B16412.jpg)'
- en: Figure 10.2 – A screenshot showing the Reopen in Container prompt
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2-显示重新在容器中打开提示的屏幕截图
- en: 'This prompt appears when Visual Studio Code detects that you have a folder
    open with a dev container definition. Click on **Reopen in Container** to open
    the folder in a dev container. If you miss the prompt, you can use the **Remote-Containers:
    Reopen in Container** command from the command palette to achieve the same thing.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '当Visual Studio Code检测到您打开了一个带有开发容器定义的文件夹时，会出现此提示。点击**在容器中重新打开**以在开发容器中打开文件夹。如果您错过了提示，可以使用命令面板中的**Remote-Containers:
    Reopen in Container**命令来实现相同的功能。'
- en: 'After choosing to reopen the folder in a container, Visual Studio Code will
    restart and begin building the container image to run the code server in. You
    will see a notification:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 选择重新在容器中打开文件夹后，Visual Studio Code将重新启动并开始构建容器镜像以运行代码服务器。您将看到一个通知：
- en: '![Figure 10.3 – A screenshot showing the Starting with Dev Container notification'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.3 – A screenshot showing the Starting with Dev Container notification'
- en: '](img/Figure_10.3_B16412.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.3_B16412.jpg)'
- en: Figure 10.3 – A screenshot showing the Starting with Dev Container notification
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 10.3 – A screenshot showing the Starting with Dev Container notification
- en: This screenshot shows the notification that the dev container is starting. If
    you click on the notification, you will be taken to the **Dev Containers** pane
    in the **TERMINAL** view. showing the commands and output from building and running
    the container. As you start customizing your dev container definitions, this window
    is useful for debugging scenarios such as when your container image fails to build.
    Now that we have the project open in a dev container, let's start exploring it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此截图显示了开发容器正在启动的通知。如果您点击通知，将会进入**TERMINAL**视图中的**Dev Containers**窗格，显示构建和运行容器的命令和输出。当您开始自定义开发容器定义时，此窗口对于调试场景非常有用，例如当您的容器镜像无法构建时。现在我们已经在开发容器中打开了项目，让我们开始探索它吧。
- en: Working in the dev container
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开发容器中工作
- en: 'Once the dev container has been built and started, you will see the contents
    of the sample code in the `name` property in `devcontainer.json`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开发容器构建和启动完成，您将在`devcontainer.json`文件的`name`属性中看到示例代码的内容：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this snippet from `devcontainer.json`, the dev container name has been changed
    to `chapter-10-01-web-app`. This change will take effect the next time the dev
    container is built and loaded. Setting the name to be meaningful is particularly
    helpful if you sometimes have more than one dev container loaded at any time as
    it shows in the Window title.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`devcontainer.json`的这个片段中，开发容器的名称已更改为`chapter-10-01-web-app`。此更改将在下次构建和加载开发容器时生效。如果您有时同时加载多个开发容器，将名称设置得有意义尤为有帮助，因为它会显示在窗口标题中。
- en: 'Next, let''s open the `app.py` file, which contains the application code for
    the sample:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们打开包含示例应用程序代码的`app.py`文件：
- en: '![Figure 10.4 – A screenshot showing an import error in app.py'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.4 – A screenshot showing an import error in app.py'
- en: '](img/Figure_10.4_B16412.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.4_B16412.jpg)'
- en: Figure 10.4 – A screenshot showing an import error in app.py
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 10.4 – A screenshot showing an import error in app.py
- en: In this screenshot, you can see the red underline beneath the line importing
    the Flask package, which shows once the Python extension has loaded and processed
    the file. This error indicates that Python cannot find the Flask package. Hopefully,
    this makes sense – all the tooling runs in a container that has Python installed,
    but nothing else. Let's quickly fix this. Open the integrated terminal using *Ctrl*
    + *`* (backtick) or `pip3 install -r requirements.txt` to install the requirements
    listed in `requirements.txt` (which includes Flask). With the requirements installed,
    the Python language server will eventually update to remove the red underline
    warning.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在此截图中，您可以看到导入Flask包的行下面的红色下划线，这在Python扩展加载和处理文件后显示。此错误表示Python无法找到Flask包。希望这是有意义的-所有的工具都在一个只安装了Python的容器中运行，没有其他东西。让我们快速修复这个问题。使用*Ctrl*
    + *`*（反引号）打开集成终端，或者使用`pip3 install -r requirements.txt`安装`requirements.txt`中列出的要求（包括Flask）。安装了要求后，Python语言服务器最终会更新以删除红色下划线警告。
- en: Later in the chapter, we will look at how to automatically install the requirements
    when the container is built to give a smoother experience; but now that we have
    everything in place, let's run the code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我们将介绍如何在构建容器时自动安装所需的内容，以提供更流畅的体验；但是现在我们已经准备好了，让我们运行代码吧。
- en: Running the code
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码
- en: The sample code includes a `.vscode/launch.json` file describing how to launch
    our code. This file allows us to configure things such as the command-line arguments
    passed to the process and the environment variables that should be set. For an
    introduction to `launch.json` and creating one from scratch, see [*Chapter 9*](B16412_09_Final_JC_ePub.xhtml#_idTextAnchor111),
    *Visual Studio Code and WSL*, the *Debugging our app* section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码包括一个描述如何启动我们的代码的`.vscode/launch.json`文件。该文件允许我们配置传递给进程的命令行参数和应设置的环境变量等内容。有关`launch.json`的介绍和从头开始创建它的内容，请参见[*第9章*](B16412_09_Final_JC_ePub.xhtml#_idTextAnchor111)，*Visual
    Studio Code和WSL*，*调试我们的应用程序*部分。
- en: With `launch.json`, we can simply press *F5* to launch our application under
    the debugger. If you want to see the interactive debugger in action, use *F9*
    to place a breakpoint (the `return` statement in the `get_os_info` function is
    a good place).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`launch.json`，我们只需按下*F5*即可在调试器下启动我们的应用程序。如果您想看到交互式调试器的效果，请使用*F9*设置断点（`get_os_info`函数中的`return`语句是一个好的位置）。
- en: 'After launching, you will see the debugger commands executed in the **TERMINAL**
    view and the corresponding output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 启动后，您将在**TERMINAL**视图中看到调试器命令的执行和相应的输出：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this output, you can see the app starting up and showing the address and
    port that it is listening on (`http://127.0.0.1:5000`). As you hover over this
    address with the mouse, you will see a popup showing that you can use *Ctrl* +
    Click to open the link. Doing this will launch your default Windows browser at
    that address, and if you set a breakpoint, you will find that the code has paused
    at that point for you to inspect the variables and so on. Once you''ve finished
    exploring the debugger, press *F5* to continue execution and you will see the
    rendered response in your browser:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，你可以看到应用程序启动并显示了它正在监听的地址和端口（`http://127.0.0.1:5000`）。当你用鼠标悬停在这个地址上时，你会看到一个弹出窗口，显示你可以使用*Ctrl*
    + 单击来打开链接。这样做将会在你的默认Windows浏览器中打开该地址，并且如果你设置了断点，你会发现代码已经在那个点暂停，以便你检查变量等。一旦你完成了对调试器的探索，按下*F5*继续执行，你将在浏览器中看到渲染后的响应：
- en: '![Figure 10.5 – A screenshot showing the web page from the Python app in the
    Windows browser'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 10.5 – 一个截图显示了Python应用在Windows浏览器中的网页'
- en: '](img/Figure_10.5_B16412.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.5_B16412.jpg)'
- en: Figure 10.5 – A screenshot showing the web page from the Python app in the Windows
    browser
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 10.5 – 一个截图显示了Python应用在Windows浏览器中的网页
- en: This screenshot shows the browser with the web page loaded from our Python app.
    Notice the hostname (`831c04e3574c` in the screenshot, but you will see a different
    ID as it changes for each container), which is the short container ID that is
    set as the hostname in the instance of the container where the app is running.
    We are able to load the web page from Windows because the Remote-Containers extension
    automatically set up port forwarding for us. This port forwarding listens on port
    `5000` on Windows and forwards the traffic to port `5000` in the container where
    our Python app is listening and responding.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个截图显示了浏览器加载了我们的Python应用的网页。请注意主机名（在截图中为`831c04e3574c`，但是你会看到一个不同的ID，因为每个容器都会改变），这是短容器ID，它被设置为容器实例中运行应用程序的主机名。我们能够从Windows加载网页，是因为Remote-Containers扩展自动为我们设置了端口转发。这个端口转发在Windows上监听端口`5000`，并将流量转发到我们的Python应用程序所在的容器中的端口`5000`，以进行监听和响应。
- en: At this point, we have a container running in Docker in WSL with all of our
    developer tooling running (including Python and the Visual Studio Code server)
    and we are able to work with the code in the rich, interactive way that we have
    come to expect. We can easily launch the code in a debugger to step through the
    code and inspect the variables, and then interact with our web app from Windows.
    All of this runs as smoothly as if the code was running on the host, but we have
    all the advantages of isolation and automation of our development environment
    that dev containers bring us.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们在WSL中的Docker中运行了一个容器，其中包含了我们的所有开发工具（包括Python和Visual Studio Code服务器），我们能够以我们期望的丰富、交互式的方式与代码一起工作。我们可以轻松地在调试器中启动代码，逐步执行代码并检查变量，然后从Windows与我们的Web应用程序进行交互。所有这些都像在主机上运行代码一样顺利，但我们拥有开发容器带来的隔离和自动化开发环境的所有优势。
- en: Next, we'll explore how to customize the dev container definition as we explore
    packaging and working with our application as a container in the dev container.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探索如何自定义开发容器定义，同时将我们的应用程序作为容器在开发容器中打包和运行。
- en: Working with a containerized app in dev containers
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在开发容器中使用容器化应用程序
- en: So far, we've seen how to use a dev container to develop an application, but
    what if we want to develop an application that will itself be packaged and run
    in a container, possibly in Kubernetes? In this section, we will focus on that
    scenario, looking at how to both build and run a container image for our application
    from inside the dev container.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使用开发容器来开发应用程序，但是如果我们想要开发一个将自身打包并在容器中运行的应用程序，可能是在Kubernetes中呢？在本节中，我们将专注于这种情况，看看如何从开发容器内部构建和运行我们应用程序的容器镜像。
- en: We will again use the accompanying code for the book as a starting point for
    this section. Ensure that you clone the code from [https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques](https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques)
    in a Linux distro. Once the code is cloned, open the `chapter-10/03-web-app-kind`
    folder in Visual Studio Code (there is also a `chapter-10/04-web-app-kind-completed`
    folder with all of the steps from this section applied as a reference). The `03-web-app-kind`
    folder contains a web app very similar to the one we've just been working with,
    but with a few extra files added to help us integrate the application into Kubernetes
    later in the chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用本书的附带代码作为本节的起点。确保你在Linux发行版中从[https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques](https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques)克隆代码。代码克隆完成后，用Visual
    Studio Code打开`chapter-10/03-web-app-kind`文件夹（还有一个`chapter-10/04-web-app-kind-completed`文件夹，其中包含了本节中所有步骤的参考）。`03-web-app-kind`文件夹包含一个与我们刚刚使用的Web应用程序非常相似的Web应用程序，但是添加了一些额外的文件，以帮助我们在本章后面将应用程序集成到Kubernetes中。
- en: 'To enable us to work with the app in Docker, we need to go through a few steps
    similar to those we went through in [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082),
    *Working with Containers in WSL*, in the *Building and running a web application
    in Docker* section except that this time, we will be working within our dev container:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在Docker中使用该应用程序，我们需要经历一些类似于我们在[*第7章*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082)中所经历的步骤，即在WSL中使用容器的*构建和运行Web应用程序*部分，只是这一次，我们将在我们的开发容器中进行操作：
- en: Set up Docker in the dev container.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发容器中设置Docker。
- en: Build the application Docker image.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建应用程序Docker镜像。
- en: Run the application container.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序容器。
- en: Let's start by looking at how to set up the dev container to allow us to build
    our application container image.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看如何设置开发容器，以允许我们构建应用程序容器镜像。
- en: Setting up Docker in the dev container
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开发容器中设置Docker
- en: 'The first step we will take to enable building Docker images is to install
    the `docker` `.devcontainer/Dockerfile` in Visual Studio Code and add the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 启用构建Docker镜像的第一步是在Visual Studio Code中安装`docker` `.devcontainer/Dockerfile`并添加以下内容：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this snippet, notice the lines between `# Install docker` and `# Install
    docker (END)`. These lines have been added to follow the steps from the Docker
    documentation to add the `apt` repository, and then use that repository to `apt-get
    install` the `docker-ce-cli` package. At this point, rebuilding and opening the
    dev container would give you an environment with the `docker` CLI, but no daemon
    for it to communicate with.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，请注意`# Install docker`和`# Install docker (END)`之间的行。这些行已添加以遵循Docker文档中的步骤，以添加`apt`存储库，然后使用该存储库来`apt-get
    install` `docker-ce-cli`软件包。此时，重新构建和打开开发容器将为您提供一个带有`docker` CLI的环境，但没有守护程序与其通信。
- en: 'We have set up Docker on the host machine, and Visual Studio Code uses the
    Docker daemon this provides to build and run the dev container that we use for
    development. To build and run Docker images inside your container, you may consider
    installing Docker inside the dev container. This is possible but can get quite
    complex and add performance issues. Instead, we will reuse the Docker daemon from
    the host within the dev container. On Linux, the default communication with Docker
    is via the `/var/run/docker.sock` socket. When running containers using the `docker`
    CLI, you can mount sockets using the `--mounts` switch ([https://docs.docker.com/storage/bind-mounts/](https://docs.docker.com/storage/bind-mounts/)).
    For the dev container, we can specify this using the `mounts` property in `.devcontainer/devcontainer.json`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在主机上设置了Docker，并且Visual Studio Code使用此提供的Docker守护程序来构建和运行我们用于开发的开发容器。要在容器内构建和运行Docker镜像，您可以考虑在开发容器内安装Docker。这是可能的，但可能会变得非常复杂并且会增加性能问题。相反，我们将在开发容器内重用主机上的Docker守护程序。在Linux上，默认与Docker的通信是通过`/var/run/docker.sock`套接字进行的。使用`docker`
    CLI运行容器时，可以使用`--mounts`开关挂载套接字（[https://docs.docker.com/storage/bind-mounts/](https://docs.docker.com/storage/bind-mounts/)）。对于开发容器，我们可以在`.devcontainer/devcontainer.json`中使用`mounts`属性指定此内容：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This snippet shows the `mounts` property in `devcontainer.json`, which specifies
    the mounts that Visual Studio Code will use when it runs our dev container. This
    property is an array of mount strings, and here we have specified that we want
    a `bind` mount (that is, a mount from the host) that mounts `/var/run/docker.sock`
    on the host to the same value inside the dev container. The effect of this is
    to make the socket for the Docker daemon on the host available inside the dev
    container.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码段显示了`devcontainer.json`中的`mounts`属性，该属性指定Visual Studio Code在运行我们的开发容器时要使用的挂载点。此属性是一个挂载字符串的数组，在这里我们指定了我们想要一个`bind`挂载（即从主机挂载），将主机上的`/var/run/docker.sock`挂载到开发容器内的相同值。这样做的效果是使主机上的Docker守护程序的套接字在开发容器内可用。
- en: 'At this point, using the `docker` CLI installed ready for you to use in the
    terminal. Any `docker` commands that you run will be executed against the Docker
    Desktop daemon; so, for example, running `docker ps` to list containers will include
    the dev container in its output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，在终端中已经安装了`docker` CLI供您使用。您运行的任何`docker`命令都将针对Docker Desktop守护程序执行；因此，例如运行`docker
    ps`以列出容器将包括开发容器在其输出中：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This output from `docker ps` executed in the terminal in the dev container includes
    the dev container itself, confirming that the Docker commands are connecting to
    the host Docker daemon.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发容器中终端中执行的`docker ps`命令的输出包括开发容器本身，确认Docker命令正在连接到主机Docker守护程序。
- en: Tip
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you had already opened the dev container before updating the Dockerfile
    and `devcontainer.json` (or any time you modify these files), you can run the
    **Remote-Containers: Rebuild and reopen in Container** command. This command will
    rerun the build process for the dev container and then reopen it, applying your
    changes to the dev container.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您在更新Dockerfile和`devcontainer.json`之前已经打开了开发容器（或者在修改这些文件的任何时间），您可以运行**Remote-Containers:
    Rebuild and reopen in Container**命令。此命令将重新运行开发容器的构建过程，然后重新打开它，将您对开发容器的更改应用到其中。'
- en: Now that we have Docker installed and configured, let's build the container
    image for our application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装和配置了Docker，让我们来构建我们应用程序的容器镜像。
- en: Building the application Docker image
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建应用程序的Docker镜像
- en: To build the Docker image for our application, we can run the `docker build`
    command. Since the Docker CLI is configured to talk to the host Docker daemon,
    any images we build from within the dev container are actually built on the host.
    This removes some of the isolation that you might expect from dev containers,
    but we can work around this by ensuring that the image names we use are unique
    to avoid name collisions with other projects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建我们应用程序的Docker镜像，我们可以运行`docker build`命令。由于Docker CLI配置为与主机Docker守护程序通信，我们从开发容器内构建的任何镜像实际上都是在主机上构建的。这消除了您可能期望从开发容器中获得的一些隔离性，但我们可以通过确保我们使用的镜像名称是唯一的来解决这个问题，以避免与其他项目发生名称冲突。
- en: The sample code already has a Dockerfile in the root folder that we will use
    to build the application's Docker image (not to be confused with `.devcontainer/Dockerfile`,
    which is used to build the dev container). The Dockerfile builds on a `python`
    base image before copying in our source code and configuring the startup command.
    For more details on the Dockerfile, refer [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082),
    *Working with Containers in WSL*, the *Introducing Dockerfiles* section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码的根文件夹中已经有一个Dockerfile，我们将使用它来构建应用程序的Docker镜像（不要与`.devcontainer/Dockerfile`混淆，该文件用于构建开发容器）。Dockerfile在`python`基础镜像上构建，然后复制我们的源代码并配置启动命令。有关Dockerfile的更多详细信息，请参考[*第7章*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082)，*在WSL中使用容器*，*介绍Dockerfiles*部分。
- en: 'To build the application image, open the integrated terminal as we did earlier
    in the chapter and run the following command to build the container image:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建应用程序镜像，请像在本章前面所做的那样打开集成终端，并运行以下命令来构建容器镜像：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command will pull the Python image (if not present) and run each of the
    steps in the Dockerfile before outputting `Successfully tagged simple-python-app-2:v1`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将拉取Python镜像（如果不存在），并在输出`Successfully tagged simple-python-app-2:v1`之前运行Dockerfile中的每个步骤。
- en: Now that we have built the application image, let's run it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了应用程序镜像，让我们运行它。
- en: Running the application container
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行应用程序容器
- en: 'To run our image, we will use the `docker run` command. From the integrated
    terminal in Visual Studio Code, run the following command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们的镜像，我们将使用`docker run`命令。从Visual Studio Code的集成终端中运行以下命令：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this output, you can see that we are running a container named `chapter-10-example`
    using the `simple-python-app-2:v1` image we built previously. We have specified
    --`network=container:$HOSTNAME`, which puts the newly created container on the
    same Docker network as the dev container. Note that we''re using `$HOSTNAME` to
    specify the ID of the dev container since the container ID is used as the machine
    name in running container (as we saw in [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082)*,
    Working with Containers in WSL, in the Building and running* *a web application
    in Docker* section). For more information on the `--network` switch see [https://docs.docker.com/engine/reference/run/#network-settings](https://docs.docker.com/engine/reference/run/#network-settings).
    We can confirm that we are able to access the web app in the running container
    by running `curl` from the integrated terminal:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在此输出中，您可以看到我们正在运行一个名为`chapter-10-example`的容器，使用我们之前构建的`simple-python-app-2:v1`镜像。我们指定了`--network=container:$HOSTNAME`，这将新创建的容器放在与开发容器相同的Docker网络中。请注意，我们使用`$HOSTNAME`来指定开发容器的ID，因为容器ID用作运行容器中的机器名称（正如我们在[*第7章*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082)*中看到的，在WSL中使用容器的构建和运行*
    *Docker*部分）。有关`--network`开关的更多信息，请参阅[https://docs.docker.com/engine/reference/run/#network-settings](https://docs.docker.com/engine/reference/run/#network-settings)。我们可以通过从集成终端运行`curl`来确认我们能够访问运行容器中的Web应用程序：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this output, you can see the HTML response from the web app in response to
    the `curl` command. This confirms that we can access the application from inside
    the dev container.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在此输出中，您可以看到Web应用程序对`curl`命令的HTML响应。这证实了我们可以从开发容器内部访问该应用程序。
- en: If you try to access the web application from a browser in Windows, it won't
    be able to connect. This is because the container port from the web application
    has been mapped into the Docker network for the dev container. Fortunately, Remote-Containers
    provides a `5000`, we enable the web browser in Windows to also access the web
    app running in the container.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试从Windows浏览器访问Web应用程序，它将无法连接。这是因为Web应用程序的容器端口已映射到开发容器的Docker网络中。幸运的是，Remote-Containers提供了一个`5000`，我们可以使Windows中的Web浏览器也能访问运行在容器中的Web应用程序。
- en: 'For dev container ports that you regularly want to access on the host in this
    way, it is convenient to update `devcontainer.json`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您希望以这种方式在主机上定期访问的开发容器端口，更新`devcontainer.json`非常方便：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this snippet, you can see the `forwardPorts` property. This is an array of
    ports that you can configure to be automatically forwarded when running your dev
    container to save the manual step of forwarding them each time.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，您可以看到`forwardPorts`属性。这是一个端口数组，您可以配置它们在运行开发容器时自动转发，以节省每次手动转发的步骤。
- en: '**Note**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: 'As an alternative to running the web application container using the `--network`
    switch, we can instead configure the dev container to use host networking (using
    `--network=host` as shown in the next section). With this approach, the dev contaienr
    re-uses the same network stack as the host, so we can run our web application
    container using the following command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用`--network`开关运行Web应用程序容器的替代方法，我们可以配置开发容器使用主机网络（使用`--network=host`，如下一节所示）。使用这种方法，开发容器重用与主机相同的网络堆栈，因此我们可以使用以下命令运行Web应用程序容器：
- en: '`docker run -d -p 5000:5000 --name chapter-10-example simple-python-app-2:v1`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run -d -p 5000:5000 --name chapter-10-example simple-python-app-2:v1`'
- en: In this command,we have used `-p 5000:5000` to expose the web application port
    5000 to the host as we saw in [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082)*,
    Working with Containers in WSL,* in the Building and running a web application
    in Docker section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令中，我们使用了`-p 5000:5000`来将Web应用程序端口5000暴露给主机，正如我们在[*第7章*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082)*中看到的，在WSL中使用容器的构建和运行*
    *Docker*部分。
- en: At this point, we have set up our dev container to connect to Docker on our
    host and reuse it for building and running images using the Docker CLI we installed
    in the dev container. Now that we have tested building a container image for our
    web app and checked that it runs correctly, let's look at running it in Kubernetes
    while working from our dev container.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设置好了开发容器，使其连接到我们主机上的Docker，并重用它来使用我们在开发容器中安装的Docker CLI进行构建和运行镜像。现在我们已经测试了为我们的Web应用程序构建容器镜像，并检查了它是否正确运行，让我们看看在从开发容器中工作时如何在Kubernetes中运行它。
- en: Working with Kubernetes in dev containers
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在开发容器中使用Kubernetes
- en: Now that we have a container image for our web app that we can build from inside
    our dev container, we will look at the steps needed to be able to run our app
    in Kubernetes. This section is fairly advanced (especially if you're not familiar
    with Kubernetes), so feel free to skip ahead to the *Tips for working with dev
    containers* section and come back to this later.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可以从开发容器内部构建的Web应用程序的容器镜像，我们将看一下运行应用程序所需的步骤，以便能够在Kubernetes中运行我们的应用程序。这一部分相当高级（特别是如果您对Kubernetes不熟悉），所以可以跳到*与开发容器一起工作的提示*部分，稍后再回来阅读。
- en: Let's start by looking at how to set up the dev container for working with Kubernetes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看如何设置用于与Kubernetes一起工作的开发容器。
- en: Options for Kubernetes with dev containers
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes与开发容器的选项
- en: 'There are many options for working with Kubernetes in WSL. The common options
    are outlined in [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082),
    *Working with Containers in WSL*, in the *Setting up Kubernetes in WSL* section.
    In that chapter, we used the Kubernetes integration in Docker Desktop, which is
    a low-friction way to set up Kubernetes. This approach can also be used with dev
    containers with a couple of steps (assuming you have enabled the Docker Desktop
    integration):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在WSL中使用Kubernetes的选项有很多。常见的选项在[*第7章*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082)中的*在WSL中设置Kubernetes*部分中进行了概述。在该章节中，我们使用了Docker桌面中的Kubernetes集成，这是一种低摩擦的设置Kubernetes的方式。这种方法也可以用于开发容器，只需完成几个步骤（假设您已启用了Docker桌面集成）：
- en: Mount a volume to map the `~/.kube` folder from WSL into the dev container as
    `/root/.kube` to share the configuration for connecting to the Kubernetes API.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挂载一个卷，将WSL中的`~/.kube`文件夹映射到开发容器中的`/root/.kube`，以共享连接到Kubernetes API的配置。
- en: Install the `kubectl` CLI for working with Kubernetes as a step in the dev container
    Dockerfile.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开发容器的Dockerfile中作为一步安装`kubectl` CLI以便与Kubernetes一起使用。
- en: The first step uses the mounts in `devcontainer.json`, as we saw in the previous
    section (the standard practice to refer to your user home folder is to use environment
    variables – for example, `${env:HOME}${env:USERPROFILE}/.kube`). We will cover
    the second step of installing `kubectl` in a moment. We will be exploring a different
    approach for Kubernetes in this chapter, but there is a `chapter10/05-web-app-desktop-k8s`
    folder in the code accompanying the book that has a dev container with both of
    these steps completed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步使用`devcontainer.json`中的挂载，就像我们在前一节中看到的一样（引用用户主文件夹的标准做法是使用环境变量 - 例如`${env:HOME}${env:USERPROFILE}/.kube`）。我们将在稍后介绍安装`kubectl`的第二步。在本章中，我们将探索一种不同的Kubernetes方法，但是在附带书籍的代码中有一个`chapter10/05-web-app-desktop-k8s`文件夹，其中包含已完成这两个步骤的开发容器。
- en: While the Docker Desktop Kubernetes integration is convenient, it adds an extra
    requirement to the host configuration. By default, a dev container only requires
    that you have Visual Studio Code with Remote-Containers installed and a Docker
    daemon running, with the rest of the project requirements satisfied by the contents
    of the dev container. Requiring the Kubernetes integration in Docker Desktop reduces
    the dev container portability slightly. Another consideration is that using the
    Docker Desktop integration means that you are using a *Kubernetes cluster* that
    is shared across your machine. This loss of isolation can be particularly relevant
    when your project involves creating Kubernetes integrations such as operators
    or other components that might apply policies. The `kind` project ([https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/))
    offers an alternative approach, allowing us to easily create and manage Kubernetes
    clusters from within the dev container using *Docker* (in fact, *kind* stands
    for *K*ubernetes *in* *D*ocker). This approach also works well if you plan to
    reuse your dev container in `kind` in the dev container.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Docker桌面的Kubernetes集成很方便，但它增加了对主机配置的额外要求。默认情况下，开发容器只需要您安装了带有Remote-Containers的Visual
    Studio Code和正在运行的Docker守护程序，并且通过开发容器的内容满足了其余的项目要求。在Docker桌面中需要Kubernetes集成会稍微降低开发容器的可移植性。另一个考虑因素是使用Docker桌面集成意味着您正在使用在整个计算机上共享的Kubernetes集群。当您的项目涉及创建Kubernetes集成（如运算符或其他可能应用策略的组件）时，这种隔离的丧失可能特别重要。`kind`项目（[https://kind.sigs.k8s.io/](https://kind.sigs.k8s.io/)）提供了一种替代方法，允许我们使用Docker在开发容器内轻松创建和管理Kubernetes集群（实际上，kind代表Kubernetes
    in Docker）。如果您计划在开发容器中重用kind，则这种方法也很有效。
- en: Setting up kind in a dev container
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在开发容器中设置kind
- en: 'In this section, we will walk through the steps to install `kind` (and `kubectl`)
    in a dev container. This will allow us to create Kubernetes clusters with the
    `kind` CLI from within the dev container, and then access them using `kubectl`.
    To do this, we need to do the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将逐步介绍在开发容器中安装`kind`（和`kubectl`）的步骤。这将允许我们使用`kind` CLI在开发容器内创建Kubernetes集群，然后使用`kubectl`访问它们。为此，我们需要执行以下操作：
- en: Add steps to install `kind` and `kubectl` in the dev container Dockerfile.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在dev容器的Dockerfile中添加安装kind和kubectl的步骤。
- en: Update `devcontainer.json` to enable connecting to the `kind` clusters.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`devcontainer.json`以启用连接到kind集群。
- en: 'To install `kind`, open the `.devcontainer/Dockerfile` and add the following
    `RUN` command (after the `RUN` command that starts with `apt-get update`):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`kind`，打开`.devcontainer/Dockerfile`并添加以下`RUN`命令（在以`apt-get update`开头的`RUN`命令之后）。
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `RUN` command in this snippet follows the documentation for installing `kind`
    ([https://kind.sigs.k8s.io/docs/user/quick-start/#installation](https://kind.sigs.k8s.io/docs/user/quick-start/#installation))
    and uses `curl` to download the release binary for `kind`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此片段中的`RUN`命令遵循安装kind的文档（[https://kind.sigs.k8s.io/docs/user/quick-start/#installation](https://kind.sigs.k8s.io/docs/user/quick-start/#installation)），并使用`curl`下载kind的发布二进制文件。
- en: 'Place the following `RUN` command after the previous one to install `kubectl`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个命令之后添加以下`RUN`命令以安装`kubectl`：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This `RUN` step installs `kubectl` based on the documentation ([https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)).
    The first of these commands uses `curl` to download the release binary (version
    `1.19.0` in this case). The second command makes the downloaded binary executable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`RUN`步骤根据文档（[https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)）安装`kubectl`。这些命令中的第一个使用`curl`下载发布二进制文件（在本例中为版本`1.19.0`）。第二个命令使下载的二进制文件可执行。
- en: 'Now that we have the installation configured for `kind` and `kubectl`, we need
    to make some changes to `.devcontainer/devcontainer.json`. The first of these
    is to add a volume for the `.kube` folder in the dev container:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置好了`kind`和`kubectl`的安装，我们需要对`.devcontainer/devcontainer.json`进行一些更改。首先是在开发容器中添加一个`.kube`文件夹的卷：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This snippet shows the `mounts` property that we previously used to bind the
    host's Docker socket with a new mount configured to create a volume that targets
    the `/root/.kube` folder in the dev container. When we run `kind` to create a
    Kubernetes cluster, it will save the configuration for communicating with the
    cluster in this folder. By adding a volume, we ensure that the contents of that
    folder persist across instances (and rebuilds) of the dev container so that we
    can still connect to the Kubernetes cluster.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段显示了我们之前使用的`mounts`属性，用于将主机的Docker套接字与新配置的挂载绑定，以创建一个以`/root/.kube`文件夹为目标的卷。当我们运行`kind`创建一个Kubernetes集群时，它将把与集群通信的配置保存在这个文件夹中。通过添加一个卷，我们确保该文件夹的内容在开发容器的实例（和重建）之间持久存在，以便我们仍然可以连接到Kubernetes集群。
- en: 'As mentioned earlier, `kind` generates lists the Kubernetes API endpoint as
    `127.0.0.1` (local IP address). This refers to the host, but the dev container
    is on an isolated Docker network by default. To enable the dev container to access
    the Kubernetes API using the configuration that `kind` generates, we can put the
    dev container into host networking mode by updating `.devcontainer/devcontainer.json`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`kind`将Kubernetes API端点列为`127.0.0.1`（本地IP地址）。这指的是主机，但是开发容器默认情况下位于一个隔离的Docker网络中。为了使开发容器能够使用`kind`生成的配置访问Kubernetes
    API，我们可以通过更新`.devcontainer/devcontainer.json`将开发容器放入主机网络模式中：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this snippet, you can see the `runArgs` property. This allows us to configure
    additional arguments that Remote-Containers passes to the `docker run` command
    when it starts our dev container. Here, we set the `--network=host` option, which
    runs the container in the same network space as the host (see [https://docs.docker.com/engine/reference/run/#network-settings](https://docs.docker.com/engine/reference/run/#network-settings)
    for more details).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，您可以看到`runArgs`属性。这允许我们配置附加参数，当Remote-Containers启动我们的开发容器时，它会将这些参数传递给`docker
    run`命令。在这里，我们设置了`--network=host`选项，它将在与主机相同的网络空间中运行容器（有关更多详细信息，请参见[https://docs.docker.com/engine/reference/run/#network-settings](https://docs.docker.com/engine/reference/run/#network-settings)）。
- en: With these changes, we can rebuild and reopen the dev container and we're ready
    to create a Kubernetes cluster and run our app in it!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，我们可以重新构建和重新打开开发容器，然后准备创建一个Kubernetes集群并在其中运行我们的应用程序！
- en: Running our app in a Kubernetes cluster with kind
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用kind在Kubernetes集群中运行我们的应用程序
- en: 'We now have all the pieces in place to create a Kubernetes cluster from within
    our dev container. To create a cluster, we will use the `kind` CLI from the integrated
    terminal:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好从开发容器内部创建一个Kubernetes集群了。要创建一个集群，我们将使用集成终端中的`kind` CLI：
- en: '![Figure 10.6 – A screenshot showing kind cluster creation'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.6 - 显示kind集群创建的屏幕截图'
- en: '](img/Figure_10.6_B16412.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.6_B16412.jpg)'
- en: Figure 10.6 – A screenshot showing kind cluster creation
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 - 显示kind集群创建的屏幕截图
- en: Here, you can see the output from running `kind create cluster --name chapter-10-03`.
    The `kind` CLI takes care of pulling the container image for the nodes if not
    already present, and then updates the output as it progresses through the steps
    to set up a cluster. By default, `kind` creates a single-node cluster, but there
    is a range of configuration options that include setting up multi-node clusters
    (see [https://kind.sigs.k8s.io/docs/user/configuration/](https://kind.sigs.k8s.io/docs/user/configuration/)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到运行`kind create cluster --name chapter-10-03`的输出。如果节点上没有容器镜像，`kind`
    CLI会负责拉取容器镜像，然后在设置集群的步骤中更新输出。默认情况下，`kind`创建一个单节点集群，但是有一系列的配置选项，包括设置多节点集群（参见[https://kind.sigs.k8s.io/docs/user/configuration/](https://kind.sigs.k8s.io/docs/user/configuration/)）。
- en: Now, we can use this cluster to run our application (assuming you have built
    the container image in the previous section; if not, run `docker build -t simple-python-app-2:v1
    -f Dockerfile.`).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个集群来运行我们的应用程序（假设您已经在前一节中构建了容器镜像；如果没有，请运行`docker build -t simple-python-app-2:v1
    -f Dockerfile.`）。
- en: 'To make the container image for our application available in the `kind` cluster,
    we need to run `kind load` (see [https://kind.sigs.k8s.io/docs/user/quick-start/#loading-an-image-into-your-cluster](https://kind.sigs.k8s.io/docs/user/quick-start/#loading-an-image-into-your-cluster)):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序的容器镜像在`kind`集群中可用，我们需要运行`kind load`（参见[https://kind.sigs.k8s.io/docs/user/quick-start/#loading-an-image-into-your-cluster](https://kind.sigs.k8s.io/docs/user/quick-start/#loading-an-image-into-your-cluster)）：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we are using the `kind load` command to load the `simple-python-app-2:v1`
    image into the `chapter-10-03` cluster we created. This loads the image onto all
    the nodes in the cluster so that it is available for us to use when creating deployments
    in Kubernetes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`kind load`命令将`simple-python-app-2:v1`镜像加载到我们创建的`chapter-10-03`集群中。这将在集群中的所有节点上加载镜像，以便我们在Kubernetes中创建部署时可以使用它。
- en: 'The `manifests` folder in the sample app contains the definitions for configuring
    the app in Kubernetes. Refer to [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082),
    *Working with Containers in WSL*, the *Running a web application in Kubernetes*
    section, which has a walkthrough and explanation of the deployment files for a
    very similar application. We can deploy the application to Kubernetes with `kubectl`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序中的`manifests`文件夹包含了在Kubernetes中配置应用程序的定义。请参考[*第7章*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082)，*在WSL中使用容器*，*在Kubernetes中运行Web应用程序*部分，其中有一个非常相似的应用程序的部署文件的演示和解释。我们可以使用`kubectl`将应用程序部署到Kubernetes中：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we use `kubectl apply` with the `-f` switch to pass it a path to load
    the manifests from. In this case, we specify the `manifests` folder so that `kubectl`
    will apply all the files in the folder.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`kubectl apply`命令和`-f`开关来传递要加载清单的路径。在这种情况下，我们指定`manifests`文件夹，以便`kubectl`将应用于文件夹中的所有文件。
- en: 'Our web app is now running on a node in the `kind` cluster and the configuration
    we just applied created a Kubernetes service in front to expose port `5000`. This
    service is only available within the `kind` cluster, so we need to run `kubectl
    port-forward` to forward a local port to the service:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Web应用现在在`kind`集群中的一个节点上运行，并且我们刚刚应用的配置创建了一个Kubernetes服务来公开端口`5000`。这个服务只在`kind`集群内部可用，所以我们需要运行`kubectl
    port-forward`来将本地端口转发到该服务：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the output, you can see the `kubectl port-forward` command used to specify
    the `service/chapter-10-03-example` service as the target, and `5000` as the port
    we want to forward. This sets up port forwarding from the local port `5000` in
    the dev container to port `5000` on the service for our application running in
    `kind`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，您可以看到`kubectl port-forward`命令用于指定`service/chapter-10-03-example`服务作为目标，并将`5000`作为我们要转发的端口。这将设置从开发容器中的本地端口`5000`到在`kind`中运行的应用的服务的端口`5000`的端口转发。
- en: 'If you create a new integrated terminal (by clicking on the plus sign at the
    top right of the integrated terminal), you can use it to run a `curl` command
    to verify that the service is running:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您创建一个新的集成终端（通过点击集成终端右上角的加号符号），您可以使用它来运行`curl`命令来验证服务是否正在运行：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This output shows `curl localhost:5000` run from inside the dev container and
    accessing the web app deployed in the `kind` cluster using the `kubectl` port
    forwarding.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示了从开发容器内部运行的`curl localhost:5000`命令，并使用`kubectl`端口转发访问在`kind`集群中部署的Web应用。
- en: 'When we were working with the app using Docker earlier in the chapter, we configured
    the `forwardPorts` property in `devcontainer.json` to forward port `5000`. This
    means that Visual Studio Code is already set up to forward port `5000` on Windows
    to port `5000` in our dev container. Any traffic sent to port `5000` in the dev
    container will be handled by the `kubectl` port-forwarding command we just ran
    and will be forwarded to port `5000` on the Kubernetes service. This means that
    we can open up `http://localhost:5000` in a browser in Windows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章早些时候使用Docker处理应用程序时，我们在`devcontainer.json`中配置了`forwardPorts`属性来转发端口`5000`。这意味着Visual
    Studio Code已经设置好了将Windows上的端口`5000`转发到开发容器中的端口`5000`。任何发送到开发容器中端口`5000`的流量都将由我们刚刚运行的`kubectl`端口转发命令处理，并转发到Kubernetes服务上的端口`5000`。这意味着我们可以在Windows的浏览器中打开`http://localhost:5000`：
- en: '![Figure 10.7 – A screenshot with the Windows browser showing the app in Kubernetes'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7 - Windows浏览器显示Kubernetes中的应用的截图'
- en: '](img/Figure_10.7_B16412.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.7_B16412.jpg)'
- en: Figure 10.7 – A screenshot with the Windows browser showing the app in Kubernetes
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 - Windows浏览器显示Kubernetes中的应用的截图
- en: In this screenshot, we can see the Windows browser accessing our app in Kubernetes
    via `http://localhost:5000`. This works because Visual Studio Code forwards the
    Windows port `5000` to port `5000` inside the dev container, which is handled
    by `kubectl port-forward` and forwarded to the Kubernetes service we deployed
    for our app.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个截图中，我们可以看到Windows浏览器通过`http://localhost:5000`访问我们在Kubernetes中的应用。这是因为Visual
    Studio Code将Windows端口`5000`转发到开发容器内部的端口`5000`，这由`kubectl port-forward`处理，并转发到我们为应用部署的Kubernetes服务。
- en: In this section, we used *Visual Studio Code*, *Remote-Containers*, and *Docker*
    to create a containerized development environment for working with a web app.
    We saw how we can use this to build and run container images for our web app,
    and then create a Kubernetes cluster and deploy and test our app in the cluster,
    including how to access the web application running in Kubernetes from a browser
    on the host Windows machine. We achieved all of this without adding any further
    requirements to the host machine, making this a portable solution that is quick
    for anyone with Visual Studio Code and Docker to get up and running on their machine.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用了*Visual Studio Code*，*Remote-Containers*和*Docker*来创建一个容器化的开发环境，用于处理Web应用。我们看到了如何使用它来构建和运行我们的Web应用的容器镜像，然后创建一个Kubernetes集群，并在集群中部署和测试我们的应用，包括如何从主机Windows机器上的浏览器访问在Kubernetes中运行的Web应用。我们实现了所有这些，而不需要向主机机器添加任何其他要求，使得这个可移植的解决方案对于任何拥有Visual
    Studio Code和Docker的人来说都是快速上手的。
- en: In the final section of this chapter, we will cover a few productivity tips
    for working with dev containers.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一节中，我们将介绍一些与开发容器一起工作的生产力技巧。
- en: Tips for working with dev containers
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与开发容器一起工作的提示
- en: In this section, we will look at a few tips that we can use to fine-tune the
    experience of working with dev containers. Let's start by looking at how we can
    automate steps inside the dev container after it has been built.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些可以用来优化与开发容器一起工作体验的技巧。让我们从在构建完成后自动化开发容器内部的步骤开始。
- en: postCreateCommand and automating pip install
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: postCreateCommand和自动化pip安装
- en: 'In the early examples in this chapter examples earlier in the chapter, we had
    to run `pip install` after building the dev container, and this is required each
    time you rebuild the dev container after making changes to its configuration.
    To avoid this, it might be tempting to add a `RUN` step to the dev container Dockerfile
    to perform `pip install`, but I prefer not to put application packages into the
    dev container image. Application package dependencies tend to evolve over time,
    and building them into the image (and rebuilding the image to install) feels a
    little heavyweight. Over time, when working with dev containers, my rule of thumb
    has become to install tools in the dev container image and install application
    packages inside the dev container once running. Fortunately, dev containers provide
    us with a `postCreateCommand` option to configure in `devcontainer.json`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早些示例中，我们在构建开发容器后需要运行`pip install`，并且每次在更改其配置后重新构建开发容器时都需要运行此命令。为了避免这种情况，可能会诱惑将`RUN`步骤添加到开发容器的Dockerfile中以执行`pip
    install`，但我更倾向于不将应用程序包放入开发容器镜像中。应用程序包依赖关系往往会随着时间的推移而发展，并且将它们构建到镜像中（并重新构建镜像以进行安装）会感觉有点笨重。随着时间的推移，在使用开发容器时，我的经验法则是在开发容器镜像中安装工具，并在运行时在开发容器内安装应用程序包。幸运的是，开发容器为我们提供了在`devcontainer.json`中配置`postCreateCommand`选项的功能：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This snippet shows `postCreateCommand` configured to run the `pip install` step.
    Visual Studio Code will automatically run `postCreateCommand` when it starts up
    the dev container after rebuilding the image.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段显示了将`postCreateCommand`配置为运行`pip install`步骤。在重新构建镜像后，Visual Studio Code将在启动开发容器时自动运行`postCreateCommand`。
- en: If you want to run multiple commands, you can combine them as `command1 && command2`,
    or put them in a script file and run the script from `postCreateCommand`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要运行多个命令，可以将它们组合为`command1 && command2`，或将它们放在一个脚本文件中，并从`postCreateCommand`运行该脚本。
- en: While we're looking at settings that automate dev container tasks, let's take
    another look at port forwarding.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看自动化开发容器任务的设置时，让我们再次关注端口转发。
- en: Port forwarding
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端口转发
- en: 'Earlier in this chapter, we made use of the port forwarding in Visual Studio
    Code to forward selected traffic from the Windows host into the dev container
    – for example, to allow the Windows browser to connect to the web app running
    in the dev container. One way to set up port forwarding is to use the `devcontainer.json`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早些时候，我们利用了Visual Studio Code中的端口转发功能，将选定的流量从Windows主机转发到开发容器中，例如允许Windows浏览器连接到运行在开发容器中的Web应用程序。设置端口转发的一种方法是使用`devcontainer.json`文件：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this snippet, we have specified ports `5000` and `5001` in the `forwardPorts`
    property. Visual Studio Code will automatically start forwarding these ports for
    us when it launches the dev container, helping to smooth out our workflow.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们在`forwardPorts`属性中指定了端口`5000`和`5001`。当Visual Studio Code启动开发容器时，它将自动开始转发这些端口，帮助我们平滑地进行工作流程。
- en: 'To see what ports are being forwarded, switch to the **REMOTE EXPLORER** view
    (for example, by running the **Remote Explorer: Focus on Forwarded Ports View**
    command):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '要查看正在转发的端口，请切换到**REMOTE EXPLORER**视图（例如，通过运行**Remote Explorer: Focus on Forwarded
    Ports View**命令）：'
- en: '![Figure 10.8 – A screenshot showing the forwarded ports view'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.8 - 显示转发端口视图的屏幕截图'
- en: '](img/Figure_10.8_B16412.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.8_B16412.jpg)'
- en: Figure 10.8 – A screenshot showing the forwarded ports view
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 - 显示转发端口视图的屏幕截图
- en: In this screenshot, you can see the list of forwarded ports currently configured.
    Hovering over a port will bring up the globe and cross icons you can see in the
    screenshot. Clicking the globe will open that port in the default Windows browser
    and clicking the cross will stop sharing that port.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕截图中，您可以看到当前配置的转发端口列表。将鼠标悬停在端口上将显示屏幕截图中看到的地球和叉图标。单击地球将在默认的Windows浏览器中打开该端口，单击叉将停止共享该端口。
- en: '`forwardPorts` configuration boosts productivity.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`forwardPorts`配置提高了生产力。'
- en: Next, we'll revisit the topic of volume mounting and look at some more examples.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重新讨论卷挂载的主题，并查看一些更多的示例。
- en: Mounting volumes and Bash history
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载卷和Bash历史记录
- en: 'We''ve seen several examples of configuring mounts in this chapter and they
    fall into two different categories:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了几个配置挂载的示例，它们分为两个不同的类别：
- en: Mounting a folder or file from the host into the container
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将主机中的文件夹或文件挂载到容器中
- en: Mounting a volume into the container to persist data between container instances
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将卷挂载到容器中以在容器实例之间保留数据
- en: The first of these categories, mounting a host volume into the container, is
    what we used to mount the host Docker socket (`/var/run/docker.sock`) into the
    dev container. This can also be used to mount folders such as `~/.azure` from
    the host to bring your Azure CLI authentication data into the dev container to
    avoid having to sign in again inside the dev container.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类别中的第一个是将主机卷挂载到容器中，这是我们用来将主机Docker套接字（`/var/run/docker.sock`）挂载到开发容器中的方法。这也可以用于挂载诸如`~/.azure`之类的文件夹，从主机中将Azure
    CLI身份验证数据带入开发容器中，以避免在开发容器内再次登录。
- en: 'The second category of mount creates a Docker volume that is mounted each time
    the dev container runs. This provides a folder inside the dev container whose
    contents are preserved across container rebuilds. This can be useful, for example,
    with package cache folders if you have large files that you want to avoid repeatedly
    downloading. Another really useful example of this is to preserve your Bash history
    in the dev container. To do this, we can configure the `bash history` location
    in the Dockerfile:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第二类挂载创建了一个Docker卷，每次运行开发容器时都会挂载该卷。这在开发容器内提供了一个文件夹，其内容在容器重新构建时得以保留。这在处理包缓存文件时非常有用，如果您有大文件，您可以避免重复下载。另一个非常有用的例子是在开发容器中保留Bash历史记录。为此，我们可以在Dockerfile中配置`bash
    history`的位置：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This snippet adds configuration to the `.bashrc` file (which is run when Bash
    starts) to configure the location of the `.bash_history` file to be in the `/commandhistory`
    folder. By itself, this doesn't achieve much, but if you combine it with making
    the `/commandhistory` folder a mounted volume, the result is to preserve your
    Bash history across instances of your dev container. In fact, this configuration
    has an added bonus. Without dev containers, all projects share the same Bash history
    on the host, so if you don't work with a project for a few days, it can mean that
    the commands related to that project have been pushed out of your history. With
    this configuration for dev containers, the Bash history is specific to the container,
    so loading up the dev container brings back your Bash history regardless of what
    commands you have run on the host in the meantime (make sure you put a project-specific
    name for the volume).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段将配置添加到`.bashrc`文件（在Bash启动时运行），以配置`.bash_history`文件的位置为`/commandhistory`文件夹。单独使用它并没有太大作用，但如果将`/commandhistory`文件夹设置为挂载卷，结果就是在开发容器的实例之间保留Bash历史记录。实际上，这个配置还有一个额外的好处。如果没有开发容器，所有项目在主机上共享相同的Bash历史记录，因此如果您在几天内不使用某个项目，可能意味着与该项目相关的命令已从您的历史记录中删除。使用开发容器的这个配置，Bash历史记录是特定于容器的，因此加载开发容器会恢复您的Bash历史记录，而不管您在主机上同时运行了哪些命令（确保为卷指定一个特定于项目的名称）。
- en: 'Here is a configuration illustrating the examples discussed:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个说明所讨论的示例的配置：
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This snippet shows various mounts that we discussed in this section:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段显示了我们在本节中讨论的各种挂载方式：
- en: Mounting the host `/var/run/docker.sock` to expose the host Docker socket in
    the dev container.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将主机的`/var/run/docker.sock`挂载到开发容器中以公开主机Docker套接字。
- en: Mounting the `.azure` folder from the host to bring cached Azure CLI authentication
    into the dev container. Note the environment variable substitution used to locate
    the user folder in the source.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将主机的`.azure`文件夹挂载到开发容器中，以将缓存的Azure CLI身份验证带入开发容器。请注意，使用环境变量替换来定位源中的用户文件夹。
- en: Mounting a volume to persist the Bash history across dev container instances.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载卷以在开发容器实例之间保留Bash历史记录。
- en: '**Volume mounting** is a useful tool when working with dev containers and can
    boost productivity considerably by allowing us to bring across host folders to
    reuse Azure CLI authentication. It can also provide a durable file store across
    dev container instances – for example, to preserve Bash history or to enable a
    package cache.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**挂载卷**是在使用开发容器时非常有用的工具，它可以通过允许我们将主机文件夹带入开发容器来大大提高生产力，以重用Azure CLI身份验证。它还可以在开发容器实例之间提供持久的文件存储，例如保留Bash历史记录或启用软件包缓存。'
- en: The final tip we will look at is ensuring the repeatability of building the
    dev container image.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一下确保构建开发容器镜像的可重复性的最后一个提示。
- en: Using pinned versions for tools
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用固定版本的工具
- en: 'When configuring a dev container, it is easy (and tempting) to use commands
    that install the latest version of tools. The starting dev container definitions
    that are used when running the **Remote-Containers: Add Development Container
    Configuration Files…** command often use commands that install the latest versions
    of tools, and lots of installation documentation for tools guide you to commands
    that do the same.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '在配置开发容器时，很容易（也很诱人）使用安装最新版本工具的命令。运行**Remote-Containers: Add Development Container
    Configuration Files…**命令时使用的起始开发容器定义通常使用安装最新版本工具的命令，而且很多工具的安装文档都指导您使用相同的命令。'
- en: If the commands in your dev container Dockerfile install the latest version
    of tools, then different people on your team might have different versions of
    tools in their dev container depending on when they built the dev container and
    what the latest versions of the tools were at that time. Additionally, you might
    add a new tool and rebuild your dev container and pick up newer versions of other
    tools. Generally, tools keep a reasonable level of compatibility between versions,
    but occasionally, their behavior changes between versions. This can lead to strange
    scenarios where the dev container tools seem to work for one developer but not
    for another, or the tools worked fine until you rebuilt the dev container (for
    example, to add a new tool), but then inadvertently picked up new versions of
    other tools. This can be disruptive to your workflow, and I generally prefer to
    pin the tools to specific versions (such as for `kind` and `kubectl` in this chapter),
    and then explicitly update their versions at a convenient time or when the need
    arises.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的开发容器Dockerfile中的命令安装最新版本的工具，那么您团队中的不同成员在其开发容器中可能会有不同版本的工具，这取决于他们构建开发容器的时间以及那时工具的最新版本是什么。此外，您可能会添加一个新工具并重新构建开发容器，并获取其他工具的更新版本。通常，工具在版本之间保持合理的兼容性水平，但偶尔会在版本之间更改其行为。这可能导致奇怪的情况，其中开发容器工具对一个开发人员有效，但对另一个开发人员无效，或者工具在重新构建开发容器（例如，添加新工具）之前工作正常，但然后无意中获取了其他工具的新版本。这可能会干扰您的工作流程，我通常更喜欢将工具固定到特定版本（例如本章中的`kind`和`kubectl`），然后在方便的时间或需要时明确更新它们的版本。
- en: Always Installed Extensions and dotfiles
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 始终安装的扩展和dotfiles
- en: 'When setting up a dev container, you can specify extensions to install when
    the dev container is created. To do this, you can add the following to `devcontainer.json`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置开发容器时，您可以指定在创建开发容器时要安装的扩展。为此，您可以将以下内容添加到`devcontainer.json`中：
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, you can see the `extensions` property in the JSON, which specifies an
    array of extension IDs. To find the ID of an extension, search for the extension
    in the **EXTENSIONS** view in Visual Studio Code and open it. You will see the
    following details:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以在JSON中看到`extensions`属性，它指定了一个扩展ID的数组。要找到扩展的ID，请在Visual Studio Code的**EXTENSIONS**视图中搜索扩展并打开它。您将看到以下详细信息：
- en: '![Figure 10.9 – A screenshot showing extension information in Visual Studio
    Code'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.9 - 在Visual Studio Code中显示扩展信息的屏幕截图'
- en: '](img/Figure_10.9_B16412.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.9_B16412.jpg)'
- en: Figure 10.9 – A screenshot showing extension information in Visual Studio Code
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 - 显示Visual Studio Code中扩展信息的屏幕截图
- en: In this screenshot, you can see the information for an extension with the extension
    ID (`ms-vsliveshare.vsliveshare`) highlighted. By adding extensions here, you
    can ensure that anyone who uses the dev container will have the relevant extensions
    installed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕截图中，您可以看到扩展ID（`ms-vsliveshare.vsliveshare`）的信息被突出显示。通过在此处添加扩展，您可以确保任何使用开发容器的人都会安装相关的扩展。
- en: 'The Remote-Containers extension also has a feature called **Always Installed
    Extensions** (or **Default Extensions**). This feature allows you to configure
    a list of extensions that you always want to be installed in a dev container.
    To enable this, open the settings JSON by choosing **Preferences: Open user settings
    (JSON)** from the command palette and add the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'Remote-Containers扩展还具有一个名为**Always Installed Extensions**（或**Default Extensions**）的功能。此功能允许您配置一个在开发容器中始终要安装的扩展列表。要启用此功能，请选择**Preferences:
    Open user settings (JSON)**命令面板中的选项以打开设置JSON文件，并添加以下内容：'
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this snippet of the settings file, you can see the `remote.containers.defaultExtensions`
    property. This is an array of extension IDs just like the `extensions` property
    in `devcontainer.json`, but the extensions listed here will always be installed
    in the dev containers you build on your machine.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置文件的这个片段中，您可以看到`remote.containers.defaultExtensions`属性。这是一个扩展ID数组，就像`devcontainer.json`中的`extensions`属性一样，但是在此处列出的扩展将始终安装在您在计算机上构建的开发容器中。
- en: A related feature that the Remote-Containers extension supports is `.bash_rc`
    and `.gitconfig`). To find out more about dotfiles, [https://dotfiles.github.io/](https://dotfiles.github.io/)
    is a good starting point.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Remote-Containers扩展支持的一个相关功能是`.bash_rc`和`.gitconfig`。要了解有关dotfiles的更多信息，请访问[https://dotfiles.github.io/](https://dotfiles.github.io/)。
- en: 'The dotfile support in Remote-Containers allows you to specify the URL for
    a Git repository containing your dotfiles, the location they should be cloned
    to in the dev container, and the command to run after cloning the repository.
    These can be configured in the settings JSON:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Remote-Containers中的dotfile支持允许您指定包含dotfiles的Git存储库的URL，它们应该在开发容器中克隆到的位置以及克隆存储库后要运行的命令。这些可以在设置JSON中配置：
- en: '[PRE23]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we can see the three JSON properties corresponding to the settings we
    just described. Note that the `remote.containers.dotfiles.repository` value can
    be a full URL, such as [https://github.com/stuartleeks/dotfiles.git](https://github.com/stuartleeks/dotfiles.git)
    or simply `stuartleeks/dotfiles`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到与我们刚刚描述的设置相对应的三个JSON属性。请注意，`remote.containers.dotfiles.repository`的值可以是完整的URL，例如[https://github.com/stuartleeks/dotfiles.git](https://github.com/stuartleeks/dotfiles.git)，也可以是`stuartleeks/dotfiles`。
- en: One thing I like to use this dotfiles feature to set up is Bash aliases. A lot
    of my early time with computers was spent with MS-DOS, and I still find that I
    type commands such as `cls` and `md` more readily than their equivalents, `clear`
    and `mkdir`. Using dotfiles for this configuration helps boost my productivity
    across dev containers, but this configuration isn't something that other users
    of the dev containers are likely to need or want.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢使用dotfiles功能来设置Bash别名。我在计算机上的早期时间大部分都是在MS-DOS上度过的，我仍然发现我更容易输入`cls`和`md`这样的命令，而不是它们的等效命令`clear`和`mkdir`。使用dotfiles进行此配置有助于提高我在开发容器中的生产力，但是其他开发容器用户可能不需要或不想要这个配置。
- en: 'With dotfiles and the **Always Installed Extensions** features, there is now
    a decision to make: should configuration and extensions be set in the dev container
    definition, or using dotfiles and **Always Installed Extensions**? To answer this,
    we can ask ourselves whether the extension or setting is something that is central
    to the functioning of the dev container or personal preference. If the answer
    is personal preference, then I put it in dotfiles or **Always Installed Extensions**.
    For functionality that is directly related to the purpose of the dev container,
    I include it in the dev container definition.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有了dotfiles和**Always Installed Extensions**功能，现在需要做出一个决定：配置和扩展应该在开发容器定义中设置，还是使用dotfiles和**Always
    Installed Extensions**？为了回答这个问题，我们可以问自己扩展或设置是否是开发容器功能的核心部分或个人偏好。如果答案是个人偏好，那么我会将其放在dotfiles或**Always
    Installed Extensions**中。对于与开发容器的目的直接相关的功能，我会将其包含在开发容器定义中。
- en: As an example, if I'm working with a dev container for Python development, then
    I would include the Python extension in the dev container definition. Similarly,
    for a project using Kubernetes, I would include `kubectl` in the Dockerfile for
    the dev container and configure Bash completion for it. I would also include the
    RedHat YAML extension to get completion assistance for Kubernetes YAML files (see
    [https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml](https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml)).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我正在使用用于Python开发的开发容器，那么我会在开发容器定义中包含Python扩展。同样，对于使用Kubernetes的项目，我会在开发容器的Dockerfile中包含`kubectl`并为其配置Bash完成。我还会包含RedHat
    YAML扩展，以获得Kubernetes YAML文件的完成帮助（请参阅[https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml](https://marketplace.visualstudio.com/items?itemName=redhat.vscode-yaml)）。
- en: Both dotfiles and **Always Installed Extensions** can be a great way to ensure
    that your environments and your dev container experience are familiar and productive.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是dotfiles还是**Always Installed Extensions**都可以是确保您的环境和开发容器体验熟悉和高效的好方法。
- en: This section has looked at tips to help increase your productivity with dev
    containers, such as removing repeated tasks by automatically running commands
    after the dev container has been rebuilt and automatically forwarding ports when
    the dev container starts up.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了一些有助于提高开发容器生产力的提示，例如在重新构建开发容器后自动运行命令以及在开发容器启动时自动转发端口。
- en: To learn more about options for configuring dev containers, see [https://code.visualstudio.com/docs/remote/containers](https://code.visualstudio.com/docs/remote/containers).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关配置开发容器的选项的更多信息，请参阅[https://code.visualstudio.com/docs/remote/containers](https://code.visualstudio.com/docs/remote/containers)。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you've seen how the Visual Studio Code Remote-Containers extension
    allows us to use the standard Dockerfile to define a container to do our development
    work while keeping the rich, interactive environment of Visual Studio Code. These
    dev containers allow us to build isolated development environments to package
    tools and dependencies specific to a project, removing the need to coordinate
    the update of tools across projects at the same time that is often seen in teams.
    Additionally, by including the dev container definition in source control, it
    is easy for team members to easily create (and update) a development environment.
    When working with web applications, you saw how to forward ports to the application
    running in the container to allow you to browse a web app in your Windows browser
    while interactively debugging it in the container.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经看到了Visual Studio Code Remote-Containers扩展如何允许我们使用标准的Dockerfile来定义一个容器来进行开发工作，同时保持Visual
    Studio Code的丰富交互环境。这些开发容器允许我们构建隔离的开发环境，以打包特定于项目的工具和依赖项，消除了通常在团队中同时协调工具更新的需要。此外，通过将开发容器定义包含在源代码控制中，团队成员可以轻松创建（和更新）开发环境。在处理Web应用程序时，您了解了如何将端口转发到在容器中运行的应用程序，以便您可以在Windows浏览器中浏览Web应用程序，同时在容器中进行交互式调试。
- en: You also saw how we can build and work with a containerized application inside
    the dev container by sharing the host Docker daemon. The chapter considered different
    options for working with Kubernetes from a dev container, and you saw how to configure
    `kind` in a dev container to provide a Kubernetes environment with minimal requirements
    on the host machine.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您还看到了如何通过共享主机Docker守护程序在开发容器中构建和使用容器化应用程序。本章考虑了从开发容器中使用Kubernetes的不同选项，并且您了解了如何在开发容器中配置`kind`以在主机机器上满足最低要求的Kubernetes环境。
- en: Finally, the chapter finished with a handful of tips for working with dev containers.
    You saw how to automate steps after dev container creation and how to automatically
    forward ports when the dev container starts up. You also saw how to mount folders
    or files from the host, and how to create volumes that persist files across dev
    container instances (for example, to persist Bash history or other generated data).
    All of these approaches provide ways to streamline your development flow with
    dev containers to help you stay focused on the code you want to write.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，本章提供了一些有关使用开发容器的技巧。您了解了如何在创建开发容器后自动化步骤，以及如何在开发容器启动时自动转发端口。您还了解了如何从主机挂载文件夹或文件，以及如何创建持久化文件的卷，跨开发容器实例保留文件（例如，保留Bash历史记录或其他生成的数据）。所有这些方法都提供了使用开发容器简化开发流程的方式，帮助您专注于想要编写的代码。
- en: Working with Remote-Containers can require a little extra thought about setting
    up the development environment for a project, but it offers some compelling advantages
    for isolation and repeatable development environments, both for an individual
    and across a team.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Remote-Containers可能需要一些额外的思考来设置项目的开发环境，但它为个人和团队提供了一些引人注目的优势，包括隔离和可重复使用的开发环境。
- en: In the next chapter, we will return to WSL and look at a variety of tips for
    working with command-line tools in WSL.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将返回WSL，并查看在WSL中使用命令行工具的各种技巧。
