- en: Chapter 4. Texting and Driving
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。发短信和开车
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖：
- en: A basic regular expression primer
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本正则表达式入门
- en: Searching and mining "text" inside a file with grep
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用grep在文件中搜索和挖掘“文本”
- en: Column-wise cutting of a file with cut
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用cut按列切割文件
- en: Determining the frequency of words used in a given file
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定给定文件中使用的单词频率
- en: A basic sed primer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本sed入门
- en: A basic awk primer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本awk入门
- en: Replacing strings from a text or file
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文本或文件中替换字符串
- en: Compressing or decompressing JavaScript
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩或解压JavaScript
- en: Iterating through lines, words, and characters in a file
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件中迭代行、单词和字符
- en: Merging multiple files as columns
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个文件合并为列
- en: Printing the nth word or column in a file or line
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件或行中打印第n个单词或列
- en: Printing text between line numbers or patterns
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印行号或模式之间的文本
- en: Checking palindrome strings with a script
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脚本检查回文字符串
- en: Printing lines in the reverse order
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以相反的顺序打印行
- en: Parsing e-mail address and URLs from text
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文本中解析电子邮件地址和URL
- en: Printing a set number of lines before or after a pattern in a file
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件中打印模式之前或之后的一组行
- en: Removing a sentence in a file containing a word
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件中删除包含特定单词的句子
- en: Implementing head, tail, and tac with awk
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用awk实现head、tail和tac
- en: Text slicing and parameter operations
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本切片和参数操作
- en: Introduction
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: The Shell Scripting language is packed with essential problem-solving components
    for UNIX/Linux systems. Bash can always provide some quick solutions to the problems
    in a UNIX environment. Text processing is one of the key areas where shell scripting
    is used. It comes with beautiful utilities such as sed, awk, grep, cut, and so
    on, which can be combined to solve text processing related problems. Most of the
    programming languages are designed to be generic, and hence it takes a lot of
    effort to write programs that can process text and produce the desired output.
    Since Bash is a language that is designed by also keeping text processing in mind,
    it has a lot of functionalities.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Shell脚本语言中包含了UNIX/Linux系统的基本问题解决组件。Bash总是可以为UNIX环境中的问题提供一些快速解决方案。文本处理是Shell脚本使用的关键领域之一。它带有诸如sed、awk、grep、cut等美丽的实用程序，可以组合使用以解决与文本处理相关的问题。大多数编程语言都设计为通用的，因此编写能够处理文本并产生所需输出的程序需要付出很大的努力。由于Bash是一种考虑到文本处理的语言，它具有许多功能。
- en: Various utilities help to process a file in fine detail as a character, line,
    word, column, row, and so on. Hence we can manipulate a text file in many ways.
    Regular expressions are the core of pattern matching techniques. Most of the text
    processing utilities come with regular expression support. By using suitable regular
    expression strings, we can produce the desired output such as filtering, stripping,
    replacing, searching, and much more.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 各种实用程序帮助以字符、行、单词、列、行等细节处理文件。因此我们可以以多种方式操纵文本文件。正则表达式是模式匹配技术的核心。大多数文本处理实用程序都带有正则表达式支持。通过使用合适的正则表达式字符串，我们可以产生所需的输出，如过滤、剥离、替换、搜索等。
- en: This chapter includes a collection of recipes, which walks through many contexts
    of problems based on text processing that will be helpful in writing real scripts.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括了一系列配方，涵盖了基于文本处理的许多问题背景，这将有助于编写真实脚本。
- en: Basic regular expression primer
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本正则表达式入门
- en: Regular expressions are the heart of the pattern-matching based text-processing
    techniques. For fluency in writing text-processing tools, one must have basic
    understanding of regular expressions. Regular expressions are a form of tiny,
    highly-specialized programming language used to match text. Using wild card techniques,
    the scope of matching text with patterns is very limited. This recipe is a walk
    through of basic regular expressions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是基于模式匹配的文本处理技术的核心。要流利地编写文本处理工具，必须对正则表达式有基本的理解。正则表达式是一种微型、高度专门化的编程语言，用于匹配文本。使用通配符技术，使用模式匹配文本的范围非常有限。这个配方是基本正则表达式的介绍。
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Regular expressions are the language used in most text processing utilities.
    Hence you will use the techniques learned in this recipe in many other recipes.
    `[a-z0-9_]+@[a-z0-9]+\.[a-z]+` is an example of regular expression for matching
    an e-mail address.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是大多数文本处理实用程序中使用的语言。因此，您将在许多其他配方中使用在本配方中学到的技术。`[a-z0-9_]+@[a-z0-9]+\.[a-z]+`
    是一个用于匹配电子邮件地址的正则表达式的示例。
- en: Does this seem weird? Don't worry, it is really simple once you understand the
    concepts.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来奇怪吗？别担心，一旦你理解了概念，它就真的很简单。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this section, we will go through regex, the POSIX character class, and meta
    characters.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍正则表达式、POSIX字符类和元字符。
- en: Let's first go through the basic components of regular expressions (regex).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解正则表达式（regex）的基本组件。
- en: '| regex | Description | Example |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| regex | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `^` | The start of the line marker. | `^tux` matches a string that starts
    the line with `tux`. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 行首标记。 | `^tux` 匹配以`tux`开头的行的字符串。 |'
- en: '| `$` | The end of the line marker. | `tux$` matches strings of a line that
    ends with `tux`. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 行尾标记。 | `tux$` 匹配以`tux`结尾的行的字符串。 |'
- en: '| `.` | Matches any one character. | `Hack.` matches `Hack1`, `Hacki` but not
    `Hack12`, `Hackil`, only one additional character matches. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 匹配任何一个字符。 | `Hack.` 匹配 `Hack1`，`Hacki` 但不匹配 `Hack12`，`Hackil`，只有一个额外的字符匹配。
    |'
- en: '| `[]` | Matches any one of the characters enclosed in `[chars]`. | `coo[kl]`
    matches `cook` or `cool`. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `[]` | 匹配`[chars]`中包含的任何一个字符。 | `coo[kl]` 匹配 `cook` 或 `cool`。 |'
- en: '| `[^]` | Matches any one of the characters EXCEPT those that are enclosed
    in `[^chars]`. | `9[^01]` matches `92`, `93` but not `91` or `90`. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `[^]` | 匹配除了`[^chars]`中包含的字符之外的任何一个字符。 | `9[^01]` 匹配 `92`，`93` 但不匹配 `91`
    或 `90`。 |'
- en: '| `[-]` | Matches any character within the range specified in `[]`. | `[1-5]`
    matches any digits from `1` to `5`. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `[-]` | 匹配`[]`中指定范围内的任何字符。 | `[1-5]` 匹配从 `1` 到 `5` 的任何数字。 |'
- en: '| `?` | The preceding item must match one or zero times. | `colou?r` matches
    `color` or `colour` but not `colouur`. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 前面的项目必须匹配一次或零次。 | `colou?r`匹配`color`或`colour`但不匹配`colouur`。 |'
- en: '| `+` | The preceding item must match one or more times. | `Rollno-9+` matches
    `Rollno-99`, `Rollno-9` but not `Rollno-`. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 前面的项目必须匹配一次或多次。 | `Rollno-9+`匹配`Rollno-99`，`Rollno-9`但不匹配`Rollno-`。
    |'
- en: '| `*` | The preceding item must match zero or more times. | `co*l` matches
    `cl`, `col`, `coool`. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 前面的项目必须匹配零次或多次。 | `co*l`匹配`cl`，`col`，`coool`。 |'
- en: '| `()` | Creates a substring from the regex match. | `ma(tri)?x` matches `max`
    or `matrix`. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `()` | 从正则表达式匹配中创建一个子字符串。 | `ma(tri)?x`匹配`max`或`matrix`。 |'
- en: '| `{n}` | The preceding item must match n times. | `[0-9]{3}` matches any three-digit
    number. `[0-9]{3}` can be expanded as:`[0-9][0-9][0-9]`. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `{n}` | 前面的项目必须匹配n次。 | `[0-9]{3}`匹配任意三位数。`[0-9]{3}`可以扩展为:`[0-9][0-9][0-9]`。
    |'
- en: '| `{n,}` | Minimum number of times that the preceding item should match. |
    `[0-9]{2,}` matches any number, that is, two digits or more. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `{n,}` | 前面的项目应该至少匹配的次数。 | `[0-9]{2,}`匹配任何数字，即两位数或更多。 |'
- en: '| `{n, m}` | Specifies the minimum and maximum number of times the preceding
    item should match. | `[0-9]{2,5}` matches any number that is having two digits
    to five digits. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `{n, m}` | 指定前面的项目应该匹配的最小和最大次数。 | `[0-9]{2,5}`匹配任何有两到五位数字的数字。 |'
- en: '| `&#124;` | Alternation—one of the items on either of sides of &#124; should
    match. | `Oct (1st &#124; 2nd)` matches `Oct 1st` or `Oct 2nd`. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 交替-&#124;两侧的项目之一应该匹配。 | `Oct (1st &#124; 2nd)`匹配`Oct 1st`或`Oct
    2nd`。 |'
- en: '| `\` | The escape character for escaping any of the special characters mentioned
    above. | `a\.b` matches `a.b` but not `ajb`. It ignores special meaning of `.`by
    prefexing `\`. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `\` | 用于转义上述任何特殊字符的转义字符。 | `a\.b`匹配`a.b`但不匹配`ajb`。它通过前缀`\`忽略`.`的特殊含义。 |'
- en: 'A POSIX character class is a special meta sequence of the form `[:...:]` that
    can be used to match a range of specified characters. The POSIX classes are as
    follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX字符类是一种特殊的元序列，形式为`[:...:]`，可用于匹配指定字符范围。POSIX类如下：
- en: '| Regex | Description | Example |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 正则表达式 | 描述 | 例子 |'
- en: '| --- | --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `[:alnum:]` | Alphanumeric character | `[[:alnum:]]+` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `[:alnum:]` | 字母数字字符 | `[[:alnum:]]+` |'
- en: '| `[:alpha:]` | Alphabet character (lowercase and uppercase) | `[[:alpha:]]{4}`
    |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `[:alpha:]` | 字母字符（小写和大写） | `[[:alpha:]]{4}` |'
- en: '| `[:blank:]` | Space and tab | `[[:blank:]]*` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `[:blank:]` | 空格和制表符 | `[[:blank:]]*` |'
- en: '| `[:digit:]` | Digit | `[[:digit:]]?` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `[:digit:]` | 数字 | `[[:digit:]]?` |'
- en: '| `[:lower:]` | Lowercase alphabet | `[[:lower:]]{5,}` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `[:lower:]` | 小写字母 | `[[:lower:]]{5,}` |'
- en: '| `[:upper:]` | Uppercase alphabet | `([[:upper:]]+)?` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `[:upper:]` | 大写字母 | `([[:upper:]]+)?` |'
- en: '| `[:punct:]` | Punctuation | `[[:punct:]]` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `[:punct:]` | 标点符号 | `[[:punct:]]` |'
- en: '| `[:space:]` | All whitespace characters including newline, carriage return,
    and so on. | `[[:space:]]+` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `[:space:]` | 包括换行符、回车符等所有空白字符。 | `[[:space:]]+` |'
- en: Meta characters are a type of Perl-style regular expression that is supported
    by a subset of text processing utilities. Not all of the utilities will support
    the following notations. But the above character classes and regular expression
    are universally accepted.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 元字符是一种Perl风格的正则表达式，它受到一些文本处理实用程序的支持。并非所有实用程序都支持以下符号。但上述字符类和正则表达式是被普遍接受的。
- en: '| Regex | Description | Example |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 正则表达式 | 描述 | 例子 |'
- en: '| --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `\b` | Word boundary | `\bcool\b` matches only `cool` not `coolant`. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 单词边界 | `\bcool\b`只匹配`cool`而不匹配`coolant`。 |'
- en: '| `\B` | Non-word boundary | `cool\B` matches `coolant` and not `cool`. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `\B` | 非单词边界 | `cool\B`匹配`coolant`而不是`cool`。 |'
- en: '| `\d` | Single digit character | `b\db` matches `b2b` not `bcb`. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 单个数字字符 | `b\db`匹配`b2b`而不是`bcb`。 |'
- en: '| `\D` | Single non-digit | `b\Db` matches `bcb` not `b2b`. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `\D` | 单个非数字 | `b\Db`匹配`bcb`而不是`b2b`。 |'
- en: '| `\w` | Single word character(alnum and _) | `\w` matches `1` or a not `&`.
    |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 单个单词字符（字母数字和_） | `\w`匹配`1`或`a`而不是`&`。 |'
- en: '| `\W` | Single non-word character | `\w` matches `&` not `1` or `a`. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `\W` | 单个非单词字符 | `\w`匹配`&`而不是`1`或`a`。 |'
- en: '| `\n` | Newline | `\n` Matches a new line. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行符 | `\n`匹配一个换行符。 |'
- en: '| `\s` | Single whitespace | `x\sx` matches `xx` not `xx`. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 单个空格 | `x\sx`匹配`xx`而不是`xx`。 |'
- en: '| `\S` | Single non-space | `x\Sx` matches `xkx` not `xx`. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `\S` | 单个非空格 | `x\Sx`匹配`xkx`而不是`xx`。 |'
- en: '| `\r` | Carriage return | `\r` matches carriage return. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | 回车 | `\r`匹配回车。 |'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The tables seen in the previous section are the key element tables for regular
    expressions. By using the suitable keys from the tables, we can construct any
    suitable regular expression string to match text according to the context. regex
    is a generic language to match text. Therefore, we are not introducing any tools
    in this recipe. However, it follows in the other recipes in this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中看到的表格是正则表达式的关键元素表。通过使用表中的合适键，我们可以构建任何适当的正则表达式字符串来根据上下文匹配文本。正则表达式是一种通用语言，用于匹配文本。因此，在本教程中我们不会介绍任何工具。但是，它遵循本章中的其他教程。
- en: 'Let''s see a few examples of text matching:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些文本匹配的例子：
- en: 'In order to match all words in a given text, we can write the regex as:'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了匹配给定文本中的所有单词，我们可以将正则表达式写成：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '"?" is the notation for optional space that precedes and follows a word. The
    `[a-zA-Z]+` notation represents one or more alphabet characters (a-z and A-Z).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '"?"是在单词前后表示可选空格的符号。`[a-zA-Z]+`表示一个或多个字母字符（a-z和A-Z）。'
- en: 'To match an IP address, we can write the regex as:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了匹配IP地址，我们可以将正则表达式写成：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: or
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We know that an IP address is in the form 192.168.0.2\. It is in the form of
    four integers (each from 0-255) separated by dots (for example, 192.168.0.2).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道IP地址的格式是192.168.0.2\. 它是由四个整数（每个从0-255）用点分隔的形式（例如，192.168.0.2）。
- en: '`[0-9]`or`[:digit:]` represents a match for digits 0-9\. `{1,3}` matches one
    to three digits and `\.`matches ".".'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`[0-9]`或`[:digit:]`表示匹配数字0-9。`{1,3}`匹配一到三个数字，`\.`匹配“.”。'
- en: There's more...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's see how the special meanings of certain characters are specified in the
    regular expressions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看正则表达式中特定字符的特殊含义是如何指定的。
- en: Treatment of special characters
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊字符的处理
- en: Regular expressions use some characters such as `$`, `^`, `.`, `*`, `+`, `{`,
    and `}` as special characters. But what if we want to use these characters as
    non-special characters (a normal text character)? Let's see an example.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式使用一些特殊字符，如`$`、`^`、`.`、`*`、`+`、`{`和`}`。但如果我们想将这些字符用作非特殊字符（普通文本字符）呢？让我们看一个例子。
- en: 'regex: `[a-z]*.[0-9]`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式：`[a-z]*.[0-9]`
- en: How is this interpreted?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何解释的？
- en: It can be zero or more [a-z] `([a-z]*)`, then any one character (`.`), and then
    one character in the set`[0-9]` such that it matches `abcdeO9`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以是零个或多个[a-z] `([a-z]*)`，然后是任意一个字符（`.`），然后是集合`[0-9]`中的一个字符，使其匹配`abcdeO9`。
- en: It can also be interpreted as one of `[a-z]`, then a character `*`, then a character
    `.` (period), and a digit such that it matches `x*.8`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以被解释为`[a-z]`之一，然后是一个字符`*`，然后是一个字符`.`（句号），然后是一个数字，使其匹配`x*.8`。
- en: In order to overcome this problem, we precede the character with a forward slash
    "\" (doing this is called "escaping the character"). Characters such as * that
    have multiple meanings are prefixed with "\" to make them into a special meaning
    or to make them non special. Whether special characters or non-special characters
    are to be escaped varies depending on the tool that you are using.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这个问题，我们在字符前加上反斜杠“\”（这样做称为“转义字符”）。具有多重含义的字符，如*，前缀为“\”，使其成为特殊含义或使其成为非特殊含义。是否转义特殊字符或非特殊字符取决于您正在使用的工具。
- en: Searching and mining "text" inside a file with grep
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用grep在文件中搜索和挖掘“文本”
- en: Searching inside a file is an important use case in text processing. We may
    need to search through thousands of lines in a file to find out some required
    data by using certain specifications. This recipe will help you learn how to locate
    data items of a given specification from a pool of data.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中搜索是文本处理中的一个重要用例。我们可能需要通过文件中的数千行进行搜索，以便通过使用某些规范找出一些所需的数据。这个示例将帮助您学习如何从数据池中定位给定规范的数据项。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: The `grep` command is the master UNIX utility for searching in the text. It
    accepts regular expressions and wild cards. We can produce output in various formats
    using the numerous interesting options that come with `grep`. Let's see how to
    do it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`命令是在文本中搜索的主要UNIX实用程序。它接受正则表达式和通配符。我们可以使用`grep`提供的许多有趣选项以各种格式生成输出。让我们看看如何做到这一点。'
- en: How to do it...
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Search in a file for a word as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中搜索单词如下：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It will return lines of text that contain the given `match_pattern`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回包含给定“match_pattern”的文本行。
- en: 'We can also read from `stdin` as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以按如下方式从`stdin`读取：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Perform a search in multiple files using a single `grep` invocation as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个`grep`调用在多个文件中执行搜索如下：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can highlight the word in the line by using the `--color` option as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`--color`选项在行中突出显示单词如下：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Usually, the `grep` command considers `match_text` as a wildcard. To use regular
    expressions as input arguments, the `-E` option should be added—which means extended
    regular expression. Or we can a use regular expression enabled `grep` command,
    `egrep`. For example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`grep`命令将`match_text`视为通配符。要将正则表达式用作输入参数，应添加`-E`选项，这意味着扩展的正则表达式。或者我们可以使用启用正则表达式的`grep`命令，`egrep`。例如：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Or:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In order to output only the matching portion of text in a file, use the `–o`
    option as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了仅输出文件中文本的匹配部分，请使用`-o`选项如下：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Or:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In order to print all of the lines, except the line containing `match_pattern`,
    use:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印除包含`match_pattern`的行之外的所有行，请使用：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `–v` option added to `grep` inverts the match results.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`grep`中添加`-v`选项可以反转匹配结果。
- en: 'Count the number of lines in which a matching string or regex match appears
    in a file or text as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 计算文件或文本中出现匹配字符串或正则表达式的行数如下：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It should be noted that `-c` counts only the number of matching lines, not
    the number of times a match is made. For example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，`-c`仅计算匹配行的数量，而不是匹配的次数。例如：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Even though there are 6 matching items, it prints `2` since there are only `2`
    matching lines. Multiple matches in a single line are counted only once.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有6个匹配项，但它打印出“2”，因为只有“2”个匹配行。单行中的多个匹配只计算一次。
- en: 'In order to count the number of matching items in a file, use the following
    hack:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算文件中匹配项的数量，请使用以下技巧：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Print the line number of the match string as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 打印匹配字符串的行号如下：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Or:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If multiple files are used, it will also print the filename with the result
    as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用多个文件，它还将打印带有结果的文件名如下：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Print the character or byte offset at which a pattern matches as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 打印模式匹配的字符或字节偏移如下：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The character offset for a string in a line is a counter from 0 starting with
    the first character. In the above example, "not" is at the seventh offset position
    (that is, `not` starts from the seventh character in the line (`gnu is not unix`).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 行中字符串的字符偏移是从0开始的计数器。在上面的例子中，“not”位于第七个偏移位置（即`not`从行中的第七个字符开始（`gnu is not unix`）。
- en: The `–b` option is always used with `–o`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`-b`选项始终与`-o`一起使用。'
- en: 'To search over many files and find out in which of the files a certain text
    matches use:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要在许多文件中搜索并找出某个文本匹配的文件，请使用：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The inverse of the `–l` argument is `–L`. The `-L` argument returns a list of
    non-matching files.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`-l`参数的反义词是`-L`。`-L`参数返回一个非匹配文件的列表。'
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We have used the basic usage examples for the `grep` command. But the `grep`
    command comes with rich features. Let's go through the different options available
    along with `grep`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了`grep`命令的基本用法示例。但是`grep`命令具有丰富的功能。让我们看看`grep`提供的不同选项。
- en: Recursively search many files
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归搜索多个文件
- en: 'To recursively search for a text over many directories of descendants use:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要在许多后代目录中递归搜索文本，请使用：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this command `"."` specifies the current directory.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令中，“.”指定当前目录。
- en: 'For example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`test_function()` exists in line number 16 of `miscutils/test.c`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_function()`存在于`miscutils/test.c`的第16行。'
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is one of the most frequently used commands by developers. It is used to
    find the file of source code in which a certain text exists.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是开发人员最常用的命令之一。它用于查找源代码文件中是否存在某个文本。
- en: Ignoring case of pattern
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 忽略模式的大小写
- en: 'The `–i` argument helps match patterns to be evaluated without considering
    if the characters are uppercase or lowercase. For example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i`参数有助于匹配模式在不考虑字符是大写还是小写的情况下进行评估。例如：'
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: grep by matching multiple patterns
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过匹配多个模式进行grep
- en: 'Usually, we can specify single pattern for matching. However, we can use an
    argument `-e` to specify multiple patterns for matching as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以指定单个模式进行匹配。但是，我们可以使用`-e`参数指定多个模式进行匹配，如下所示：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'There is also another way to specify multiple patterns. We can use a pattern
    file for reading patterns. Write patterns to match line by line and execute `grep`
    with a `-f` argument as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种指定多个模式的方法。我们可以使用一个模式文件来读取模式。按行编写模式以匹配并执行`grep`，并使用`-f`参数如下：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Include and exclude files (wild card pattern) in grep search
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在grep搜索中包括和排除文件（通配符模式）
- en: '`grep` can include or exclude files in which to search. We can specify include
    files or exclude files using wild card patterns.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`可以包括或排除要搜索的文件。我们可以使用通配符模式指定包含文件或排除文件。'
- en: 'To search only `.c` and `.cpp` files recursively in a directory by excluding
    all other file types, use:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要递归地仅在目录中搜索`.c`和`.cpp`文件，并排除所有其他文件类型，请使用：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that `some{string1,string2,string3}` expands as `somestring1 somestring2
    somestring3`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`some{string1,string2,string3}`扩展为`somestring1 somestring2 somestring3`。
- en: 'Exclude all README files in the search as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 排除搜索中的所有README文件如下：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To exclude directories use the `--exclude-dir` option.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要排除目录，请使用`--exclude-dir`选项。
- en: To read a list of files to exclude from a file use `--exclude-from FILE`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文件中读取要排除的文件列表，请使用`--exclude-from FILE`。
- en: Using grep with xargs with zero-byte suffix
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用带有零字节后缀的xargs的grep
- en: The `xargs` command is often used to provide a list of file names as a command-line
    argument to another command. When filenames are used as command-line arguments,
    it is recommended to use a zero-byte terminator for the file names instead of
    a space terminator. Some of the file names can contain a space character and it
    will be misinterpreted as a terminator and a single file name may be broken into
    two file names (for example, `New file.txt` can be interpreted as two filenames
    `New` and `file.txt`). This problem can be avoided by using a zero-byte suffix.
    We use `xargs` so as to accept `stdin` text from commands like `grep`, `find`,
    and so on. Such commands can output text to the `stdout` with a zero-byte suffix.
    In order to specify that the input terminator for filenames is zero byte (`\0`),
    we should use `–0` with `xargs.`
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`命令通常用于将文件名列表作为命令行参数提供给另一个命令。当文件名用作命令行参数时，建议使用零字节终止符而不是空格终止符。一些文件名可能包含空格字符，它将被误解为终止符，并且一个文件名可能会被分成两个文件名（例如，`New
    file.txt`可能被解释为两个文件名`New`和`file.txt`）。通过使用零字节后缀可以避免这个问题。我们使用`xargs`来接受来自`grep`、`find`等命令的`stdin`文本。这些命令可以输出带有零字节后缀的文本到`stdout`。为了指定文件名的输入终止符是零字节（`\0`），我们应该在`xargs`中使用`-0`。'
- en: 'Create some test files as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一些测试文件如下：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the following command sequence, `grep` outputs filenames with a zero byte
    terminator (`\0`). It is specified by using the `–Z` option with `grep`. `xargs
    -0` reads the input and separates file names with a zero byte terminator:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下命令序列中，`grep`输出带有零字节终止符（`\0`）的文件名。通过使用`grep`的`-Z`选项来指定。`xargs -0`读取输入并使用零字节终止符分隔文件名：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Usually, `-Z` is used along with `-l`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`-Z`与`-l`一起使用。
- en: Silent output for grep
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: grep的静默输出
- en: The previously mentioned usages of `grep` return output in different formats.
    There are some cases when we need to know whether a file contains the specified
    text or not. We have to perform a test condition that returns true or false. It
    can be performed using the quiet condition (`-q`). In quiet mode, the `grep` command
    does not write any output to the standard output. Instead it runs the command
    and returns exit status based on success or failure.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`的先前提到的用法以不同的格式返回输出。有些情况下，我们需要知道文件是否包含指定的文本。我们必须执行一个返回true或false的测试条件。可以使用安静条件（`-q`）来执行。在安静模式下，`grep`命令不会将任何输出写入标准输出。相反，它运行命令并根据成功或失败返回退出状态。'
- en: We know that a command returns 0 if success and non-zero if failure.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，如果成功，命令返回0，如果失败，则返回非零。
- en: Let's go through a script that makes uses of `grep` in quiet mode for testing
    whether a match text appears in a file or not.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个脚本，以安静模式使用`grep`来测试文件中是否出现匹配文本。
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `silent_grep.sh` script can be run as follows by providing a match word
    (`Student`) and a filename (`student_data.txt`) as the command argument:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过提供匹配单词（`Student`）和文件名（`student_data.txt`）作为命令参数来运行`silent_grep.sh`脚本：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Print lines before and after text matches
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打印文本匹配之前和之后的行
- en: Context-based printing is a one of the nice features of `grep`. Suppose a matching
    line for a given match text is found, `grep` usually prints only the matching
    lines. But we may need "n" lines after the matching lines or "n" lines before
    the matching line or both. It can be performed using context line control in `grep`.
    Let's see how to do it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 基于上下文的打印是`grep`的一个很好的特性。假设找到了给定匹配文本的匹配行，`grep`通常只打印匹配行。但是我们可能需要在匹配行之后的“n”行或匹配行之前的“n”行或两者之间。可以使用`grep`中的上下文行控制来执行。让我们看看如何做到这一点。
- en: 'In order to print three lines after a match, use the `-A` option:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在匹配后打印三行，请使用`-A`选项：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In order to print three lines before the match, use the `-B` option:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在匹配之前打印三行，请使用`-B`选项：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Print three lines after and before the match, use the `-C` option as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要在匹配项之后和之前打印三行，请使用`-C`选项如下：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If there are multiple matches, each section is delimited by a line "--":'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个匹配项，每个部分由一行“--”分隔：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Column-wise cutting of a file with cut
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cut按列切割文件
- en: We may need to cut text by column rather than row. Let's assume that we have
    a text file containing student reports with columns, such as `No`, `Name`, `Mark`,
    and `Percentage`. We need to extract only the name of students to another file
    or any n-th column in the file or extract two or more columns. This recipe will
    illustrate how to perform this task.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要按列而不是按行切割文本。假设我们有一个包含学生报告的文本文件，其中包含`编号`、`姓名`、`成绩`和`百分比`等列。我们需要提取学生的姓名到另一个文件或文件中的任何第n列，或提取两列或更多列。本教程将说明如何执行此任务。
- en: Getting ready
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: '`cut` is a small utility that often comes to our help for cutting in column
    fashion. It can also specify the delimiter that separates each column. In `cut`
    terminology, each column is known as a field.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`cut`是一个小型实用程序，通常用于按列切割。它还可以指定分隔每一列的分隔符。在`cut`术语中，每一列被称为一个字段。'
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In order to extract the first field or column, use the following syntax:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取第一个字段或列，使用以下语法：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`FIELD_LIST` is a list of columns that are to be displayed. The list consists
    of column numbers delimited by commas. For example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`FIELD_LIST`是要显示的列的列表。该列表由逗号分隔的列号组成。例如：'
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, the second and the third columns are displayed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了第二列和第三列。
- en: '`cut` can also read input text from `stdin`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`cut`还可以从`stdin`中读取输入文本。'
- en: 'Tab is the default delimiter for fields or columns. If lines without delimiters
    are found, they are also printed. To avoid printing lines that do not have delimiter
    characters, attach the `-s` option along with `cut`. An example of using the `cut`
    command for columns is as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 制表符是字段或列的默认分隔符。如果找到没有分隔符的行，它们也会被打印。为了避免打印没有分隔符字符的行，请在`cut`后面加上`-s`选项。以下是使用`cut`命令进行列处理的示例：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Extract multiple fields as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 提取多个字段如下：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: To print multiple columns, provide a list of column numbers separated by commas
    as argument to `-f`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印多个列，请将由逗号分隔的列号列表作为`-f`的参数。
- en: 'We can also complement the extracted fields using the `--complement` option.
    Suppose you have many fields and you want to print all the columns except the
    third column, use:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`--complement`选项来补充提取的字段。假设您有许多字段，想要打印除第三列之外的所有列，请使用：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To specify the delimiter character for the fields, use the `-d` option as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定字段的分隔符字符，请使用`-d`选项如下：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There's more...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `cut` command has more options to specify the character sequences to be
    displayed as columns. Let's go through the additional options available with `cut`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`cut` 命令有更多选项来指定要显示为列的字符序列。让我们看看`cut`提供的其他选项。'
- en: Specifying range of characters or bytes as fields
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定字符或字节范围作为字段
- en: Suppose that we don't rely on delimiters, but we need to extract fields such
    that we need to define a range of characters (counting from 0 as start of line)
    as a field, such extractions are possible with `cut`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们不依赖分隔符，但需要提取字段，以便定义一系列字符（从0开始计算为行的开头）作为字段，这样的提取可以使用`cut`来实现。
- en: 'Let''s see what notations are possible:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看有哪些可能的符号：
- en: '| N- | from N-th byte, character or field, to end of line |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| N- | 从第N个字节、字符或字段到行尾 |'
- en: '| N-M | from N-th to M-th (included) byte, character or field |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| N-M | 从第N到第M（包括）个字节、字符或字段 |'
- en: '| -M | from first to M-th (included) byte, character or field |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| -M | 从第一个到第M个（包括）字节、字符或字段 |'
- en: 'We use the above notations to specify fields as range of bytes or characters
    with the following options:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用上述符号来指定字段作为字节或字符的范围，具有以下选项：
- en: '`-b` for bytes'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-b` 用于字节'
- en: '`-c` for characters'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c` 用于字符'
- en: '`-f` for defining fields'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f` 用于定义字段'
- en: 'For example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can print the first to fifth characters as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式打印前五个字符：
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The first two characters can be printed as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个字符可以打印如下：
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Replace `-c` with `-b` to count in bytes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 将`-c`替换为`-b`以按字节计数。
- en: 'We can specify output delimiter while using with `-c`, `-f` and `-b` as:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`-c`、`-f`和`-b`时，可以指定输出分隔符如下：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When multiple fields are extracted with `-b` or `-c`, `--output-delimiter`
    is a must. Else, you cannot distinguish between fields if it is not provided.
    For example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-b`或`-c`提取多个字段时，`--output-delimiter`是必须的。否则，如果未提供它，您无法区分字段。例如：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Frequency of words used in a given file
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给定文件中使用的单词频率
- en: Finding the frequency of words used in a file is an interesting exercise to
    apply the text processing skills. It can be done in many different ways. Let's
    see how to do it.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 查找文件中使用的单词频率是一个有趣的练习，可以应用文本处理技能。有很多不同的方法可以做到这一点。让我们看看如何做到这一点。
- en: Getting ready
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: We can use associative arrays, awk, sed, grep, and so on to solve this problem
    in different ways.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用关联数组、awk、sed、grep等不同的方式来解决这个问题。
- en: How to do it...
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Words are alphabetic characters delimited by space and dot. First we should
    parse all the words in the given file. Hence the count of each word needs to be
    found out. Words can be parsed by using regex with any of the tools such as sed,
    awk, or grep.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 单词是由空格和句点分隔的字母字符。首先，我们应该解析给定文件中的所有单词。因此，需要找出每个单词的计数。可以使用正则表达式和诸如sed、awk或grep之类的工具来解析单词。
- en: To find out the count of each word, we can have a different approach. One way
    of doing it is to loop through each word, and then use another loop to go through
    the words and check if they are equal. If they are equal, increment a count and
    print it at the end of file. This is an inefficient method. In an associative
    array, we use the word as the array index and count as the array value. We will
    only need one loop to achieve this by looping through each word. `array[word]
    = array[word] + 1` while initially its value is set `0`. Hence we can get an array
    containing the counts for each word.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出每个单词的计数，我们可以采用不同的方法。一种方法是循环遍历每个单词，然后使用另一个循环遍历单词并检查它们是否相等。如果它们相等，增加一个计数并在文件末尾打印它。这是一种低效的方法。在关联数组中，我们使用单词作为数组索引，计数作为数组值。我们只需要一个循环就可以通过循环遍历每个单词来实现这一点。`array[word]
    = array[word] + 1`，而最初它的值被设置为`0`。因此，我们可以得到一个包含每个单词计数的数组。
- en: 'Now let''s do it. Create the shell script as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来做吧。创建如下的shell脚本：
- en: '[PRE49]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'A sample output is as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例输出如下：
- en: '[PRE50]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here `egrep -o "\b[[:alpha:]]+\b" $filename` is used to output only words. The
    `-o` option will print the matching character sequence delimited by a newline
    character. Hence we receive words in each line.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用`egrep -o "\b[[:alpha:]]+\b" $filename`来仅输出单词。`-o`选项将打印由换行字符分隔的匹配字符序列。因此我们在每行收到单词。
- en: '`\b` is the word boundary character. `[:alpha:]` is a character class for alphabets.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`\b`是单词边界字符。`[:alpha:]`是字母的字符类。'
- en: The `awk` command is used to avoid the iteration through each word. Since `awk`,
    by default, executes the statements in the `{ }` block for each row, we don't
    need a specific loop for doing that. Hence the count is incremented as `count[$0]++`
    using the associative array. Finally, in the `END{}` block, we print the words
    and their count by iterating through the words.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`命令用于避免对每个单词进行迭代。由于`awk`默认情况下执行`{}`块中的语句对每一行，我们不需要特定的循环来执行。因此，使用关联数组递增计数为`count[$0]++`。最后，在`END{}`块中，我们通过迭代单词来打印单词及其计数。'
- en: See also
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Arrays and associative arrays* of[Chapter 1](ch01.html "Chapter 1. Shell Something
    Out"), explains the arrays in Bash'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数组和关联数组*[第1章](ch01.html "第1章。外壳的某些东西")，解释了Bash中的数组'
- en: '*Basic awk primer*, explains the awk command'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本的awk入门*，解释了awk命令'
- en: Basic sed primer
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的sed入门
- en: sed stands for stream editor. It is a very essential tool for text processing.
    It is a marvelous utility that can play around regular expressions. A well-known
    usage of the `sed` command is for text replacement. This recipe will cover most
    of the frequently used `sed` techniques.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: sed代表流编辑器。这是文本处理的一个非常重要的工具。它是一个可以玩弄正则表达式的神奇实用程序。`sed`命令的一个众所周知的用法是文本替换。本教程将涵盖大多数经常使用的`sed`技术。
- en: How to do it…
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: '`sed` can be used to replace occurrences of a string with another string in
    a given text. It can be matched using regular expressions.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`可以用于在给定文本中用另一个字符串替换字符串的出现。它可以使用正则表达式进行匹配。'
- en: '[PRE51]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: or
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE52]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This command reads from `stdin`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令从`stdin`中读取。
- en: 'To save the changes along with the substitutions to the same file, use the
    -i option. Most of the users follow multiple redirections to save the file after
    making a replacement as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要将更改与替换保存到同一文件中，请使用-i选项。大多数用户在进行替换后使用多个重定向来保存文件，如下所示：
- en: '[PRE53]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'However, it can be done in just one line, for example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它可以在一行内完成，例如：
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The previously seen `sed` commands will replace the first occurrence of the
    pattern in each line. But in order to replace every occurrence, we need to add
    the `g` parameter at the end as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 先前看到的`sed`命令将替换每行中模式的第一个出现。但是为了替换每个出现，我们需要在末尾添加`g`参数，如下所示：
- en: '[PRE55]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `/g` suffix means that it will substitute every occurrence. However, sometimes
    we need not replace the first "N" occurrences, but only the rest of them. There
    is a built-in option to ignore the first "N" occurrences and replace from the"N+1th"occurrence
    onwards.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`/g`后缀表示它将替换每个出现。然而，有时我们不需要替换前N个出现，而只需要其余的。有一个内置选项可以忽略前N个出现并从第"N+1"次出现开始替换。'
- en: 'Have a look at the following commands:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下命令：
- en: '[PRE56]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Place `/Ng` when it needs to start the replacement from the N-th occurrence.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要从第N次出现开始替换时，放置`/Ng`。
- en: '`/` in `sed` is a delimiter character. We can use any delimiter characters
    as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`/`在`sed`中是一个分隔符字符。我们可以使用任何分隔符字符，如下所示：'
- en: '[PRE57]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'When the delimiter character appears inside the pattern, we have to escape
    it using `\` prefix as:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 当分隔符字符出现在模式内部时，我们必须使用`\`前缀进行转义，如下所示：
- en: '[PRE58]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`\|` is a delimiter appearing in the pattern replaced with escape.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`\|`是出现在替换中的分隔符。'
- en: There's more...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `sed` command comes with numerous options for text manipulation. By combining
    the options available with `sed` in logical sequences, many complex problems can
    be solved in one line. Let's see some different options available with `sed`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`命令具有许多用于文本处理的选项。通过将`sed`中可用的选项与逻辑序列结合，可以在一行中解决许多复杂的问题。让我们看看`sed`可用的一些不同选项。'
- en: Removing blank lines
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除空白行
- en: 'Removing blank lines is a simple technique using `sed` to remove blank lines.
    Blanks can be matched with regular expression `^$`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sed`删除空白行是一种简单的技术。空白可以与正则表达式`^$`匹配：
- en: '[PRE59]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`/pattern/d` will remove lines matching the pattern.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`/pattern/d`将删除匹配模式的行。'
- en: For blank lines, the line end marker appears next to the line start marker.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于空白行，行结束标记出现在行开始标记旁边。
- en: Matched string notation (&)
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配字符串符号（&）
- en: In `sed` we can use `&` as the matched string for the substitution pattern such
    that we can use the matched string in replacement string.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sed`中，我们可以使用`&`作为替换模式的匹配字符串，以便我们可以在替换字符串中使用匹配的字符串。
- en: 'For example:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE60]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here the regex `\w\+` matches every word. Then we replace it with `[&]`. `&`
    corresponds to the word that is matched.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的正则表达式`\w\+`匹配每个单词。然后我们用`[&]`替换它。`&`对应于匹配的单词。
- en: Substring match notation (\1)
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子字符串匹配符号（\1）
- en: '& is a string which corresponds to match string for the given pattern. But
    we can also match the substrings of the given pattern. Let''s see how to do it.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '&是一个字符串，对应于给定模式的匹配字符串。但我们也可以匹配给定模式的子字符串。让我们看看如何做到这一点。'
- en: '[PRE61]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It replaces `digit 7` with `7`. The substring matched is `7`. `\(pattern\)`is
    used to match the substring. The pattern is enclosed in `()` and is escaped with
    slashes. For the first substring match, the corresponding notation is `\1`, for
    the second it is `\2`, and so on. Go through the following example with multiple
    matches:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 它用`\(pattern\)`替换`digit 7`为`7`。匹配的子字符串是`7`。`()`中的模式用斜杠转义。对于第一个子字符串匹配，相应的表示是`\1`，对于第二个是`\2`，依此类推。看下面的多次匹配示例：
- en: '[PRE62]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`([a-z]\+\)` matches the first word and `\([A-Z]\+\)`matches the second word.
    `\1` and `\2` are used for referencing them. This type of referencing is called
    back referencing. In the replacement part, their order is changed as `\2 \1` and
    hence it appears in reverse order.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`([a-z]\+\)`匹配第一个单词，`\([A-Z]\+\)`匹配第二个单词。`\1`和`\2`用于引用它们。这种引用方式称为回溯引用。在替换部分，它们的顺序被改变为`\2
    \1`，因此它们以相反的顺序出现。'
- en: Combination of multiple expressions
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个表达式的组合
- en: 'The combination of multiple `sed` using a pipe can be replaced as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管道替换多个`sed`的组合如下：
- en: '[PRE63]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Which is equivalent to:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 相当于：
- en: '[PRE64]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Quoting
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用
- en: Usually, it is seen that the `sed` expression is quoted using single quotes.
    But double-quotes can also be used. Double-quotes expand the expression by evaluating
    it. Using double-quotes is useful when we want to use some variable string in
    a `sed` expression.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，`sed`表达式使用单引号引起来。但也可以使用双引号。双引号通过评估来扩展表达式。当我们想在`sed`表达式中使用某个变量字符串时，使用双引号是有用的。
- en: 'For example:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE65]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`$text` is evaluated as "hello".'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`$text`被评估为"hello"。'
- en: Basic awk primer
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本awk入门
- en: '`awk` is a tool designed to work with data streams. It is very interesting
    as it can operate on columns and rows. It supports many inbuilt functionalities
    such as arrays, functions, and so on, as in the C programming language. Flexibility
    is the greatest advantage of it.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`是一种设计用于处理数据流的工具。它非常有趣，因为它可以操作列和行。它支持许多内置功能，如数组、函数等，就像C编程语言一样。灵活性是它的最大优势。'
- en: How to do it…
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The structure of an `awk` script looks like this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`脚本的结构如下：'
- en: '[PRE66]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `awk` command can read from `stdin` also.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`命令也可以从`stdin`读取。'
- en: 'An `awk` script usually consists of three parts: `BEGIN`, `END`, and a common
    statements block with the pattern match option. The three of them are optional
    and any of them can be absent in the script. The script is usually enclosed in
    single-quotes or double-quotes as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`脚本通常由三部分组成：`BEGIN`、`END`和带有模式匹配选项的常用语句块。它们三者都是可选的，脚本中任何一个都可以不存在。脚本通常用单引号或双引号括起来，如下所示：'
- en: '[PRE67]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Or, alternately, use:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也可以使用：
- en: '[PRE68]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'For example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE69]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Or:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE70]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How it works…
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `awk` command works in the following manner:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`命令的工作方式如下：'
- en: Execute the statements in the `BEGIN { commands }`block.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`BEGIN { commands }`块中的语句。
- en: Read one line from the file or `stdin`, and execute `pattern { commands }`.
    Repeat this step until the end of the file is reached.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件或`stdin`读取一行，并执行`pattern { commands }`。重复此步骤，直到到达文件的末尾。
- en: When the end of the input stream is reached, execute the `END { commands }`
    block.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当到达输入流的末尾时，执行`END { commands }`块。
- en: The `BEGIN` block is executed before `awk` starts reading lines from the input
    stream. It is an optional block. The statements such as variable initialization,
    printing the output header for an output table, and so on are common statements
    that are written in the `BEGIN` block.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`BEGIN`块在`awk`开始从输入流中读取行之前执行。这是一个可选块。在`BEGIN`块中编写的常见语句包括变量初始化、为输出表打印输出标题等。'
- en: The `END` block is similar to the `BEGIN` block. The `END` block gets executed
    when `awk` has completed reading all the lines from the input stream. The statements
    like printing results after analyzing all the values calculated for all the lines
    or printing the conclusion are the commonly-used statements in the `END` block
    (for example, after comparing all the lines, print the maximum number from a file).
    This is an optional block.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`END`块类似于`BEGIN`块。当`awk`完成从输入流中读取所有行时，`END`块会被执行。在`END`块中，打印所有行的计算值后进行分析或打印结论等语句是常用的语句（例如，在比较所有行后，打印文件中的最大数）。这是一个可选块。'
- en: The most important block is the common commands with the pattern block. This
    block is also optional. If this block is not provided, by default `{ print }`
    gets executed so as to print each of the lines read. This block gets executed
    for each line read by `awk`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的块是带有模式块的常用命令。这个块也是可选的。如果没有提供这个块，默认情况下会执行`{ print }`以打印读取的每一行。这个块对`awk`读取的每一行都会执行。
- en: It is like a while loop for line read with provided statements inside the body
    of the loop.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 它就像一个while循环，用提供的语句在循环体内读取行。
- en: When a line is read, it checks whether the provided pattern matches the line.
    The pattern can be a regular expression match, conditions, range of lines match,
    and so on. If the current read line matches with the pattern, it executes the
    statements enclosed in `{ }`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 读取一行，检查提供的模式是否与该行匹配。模式可以是正则表达式匹配、条件、行范围匹配等。如果当前读取的行与模式匹配，它会执行`{ }`中的语句。
- en: The pattern is optional. If pattern is not used, all the lines are matched and
    statements inside `{ }` are executed.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 模式是可选的。如果不使用模式，所有行都会匹配，并且执行`{ }`内的语句。
- en: 'Let''s go through the following example:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE71]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: When `print` is used without an argument, it will print the current line. There
    are two important things to be kept in mind about `print`. When the arguments
    of the print are separated by commas, they are printed with a space delimiter.
    Double-quotes are used as the concatenation operator in the context of `print`
    in `awk`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`print`而没有参数时，它将打印当前行。关于`print`有两件重要的事情需要记住。当print的参数用逗号分隔时，它们将以空格分隔打印。双引号在`awk`的`print`上下文中用作连接运算符。
- en: 'For example:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE72]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The above statement will print the values of the variables as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句将打印变量的值如下：
- en: '[PRE73]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `echo` command writes a single line into the standard output. Hence the
    statements in the `{ }` block of `awk` are executed once. If standard input to
    `awk` contains multiple lines, the commands in `awk` will be executed multiple
    times.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo`命令将一行写入标准输出。因此，`awk`的`{ }`块中的语句将执行一次。如果`awk`的标准输入包含多行，则`awk`中的命令将执行多次。'
- en: 'Concatenation can be used as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 连接可以如下使用：
- en: '[PRE74]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The output will be:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：
- en: '[PRE75]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`{ }` is like a block in a loop iterating through each line of a file.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`{ }`就像循环中的块，遍历文件的每一行。'
- en: Tip
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Usually, we place initial variable assignments, such as `var=0;` and statements
    to print the file header in the `BEGIN` block. In the `END{}` block, we place
    statements such as printing results and so on.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将初始变量赋值，比如`var=0;`和打印文件头的语句放在`BEGIN`块中。在`END{}`块中，我们放置打印结果等语句。
- en: There's more…
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The `awk` command comes with lot of rich features. In order to master the art
    of awk programming you should be familiar with the important `awk` options and
    functionalities. Let's go through the essential functionalities of `awk`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`命令具有许多丰富的功能。为了掌握awk编程的艺术，您应该熟悉重要的`awk`选项和功能。让我们了解`awk`的基本功能。'
- en: Special variables
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊变量
- en: 'Some special variables that can be used with `awk` are as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用的一些特殊变量与`awk`一起使用如下：
- en: '`NR`: It stands for number of records and corresponds to current line number
    under execution.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NR`：它代表记录数，并对应于当前执行的行号。'
- en: '`NF`: It stands for number of fields and corresponds to number of fields in
    the current line under execution (Fields are delimited by space).'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NF`：它代表字段数，并对应于当前执行行下的字段数（字段由空格分隔）。'
- en: '`$0`: It is a variable that contain the text content of current line under
    execution.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$0`：它是一个变量，包含当前执行行的文本内容。'
- en: '`$1`: It is a variable that holds the text of the first field.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$1`：它是一个变量，保存第一个字段的文本。'
- en: '`$2`: It is the variable that holds the test of the second field text.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$2`：它是保存第二个字段文本的变量。'
- en: 'For example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE76]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We can print last field of a line as `print $NF`, last but second as `$(NF-1)`and
    so on.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一行的最后一个字段打印为`print $NF`，倒数第二个字段为`$(NF-1)`等等。
- en: '`awk` provides the `printf()`function with same syntax as in C. We can also
    use that instead of print.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`提供了与C中相同语法的`printf()`函数。我们也可以使用它来代替print。'
- en: Let's see some basic `awk` usage examples.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些基本的`awk`使用示例。
- en: 'Print the second and third field of every line as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式打印每一行的第二个和第三个字段：
- en: '[PRE77]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In order to count the number of lines in a file, use the following command:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算文件中的行数，使用以下命令：
- en: '[PRE78]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Here we only use the `END` block. `NR` will be updated on entering each line
    by `awk` with its line number. When it reaches the end line it will have the value
    of last line number. Hence, in the `END` block `NR` will have the value of last
    line number.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们只使用`END`块。`NR`将在进入每一行时由`awk`更新其行号。当它到达最后一行时，它将具有最后一行号的值。因此，在`END`块中，`NR`将具有最后一行号的值。
- en: 'You can sum up all the numbers from each line of field 1 as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将字段1的每一行的所有数字相加如下：
- en: '[PRE79]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Passing a variable value from outside to awk
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将变量值从外部传递给awk
- en: 'By using the `-v` argument, we can pass external values (other than from `stdin`)
    to `awk` as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`-v`参数，我们可以将外部值（而不是来自`stdin`）传递给`awk`如下：
- en: '[PRE80]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'There is a flexible alternate method to pass many variable values from outside
    `awk`. For example:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种灵活的替代方法可以从外部传递多个变量值给`awk`。例如：
- en: '[PRE81]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'When input is given through a file rather than standard input, use:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入是通过文件而不是标准输入给出时，使用：
- en: '[PRE82]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In the above method, variables are specified as key-value pairs separated by
    space (`v1=$var1 v2=$var2`) as command arguments to awk soon after the BEGIN,
    { } and END blocks.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述方法中，变量被指定为键值对，由空格分隔（`v1=$var1 v2=$var2`）作为命令参数传递给`awk`的BEGIN、{ }和END块之后。
- en: Reading a line explicitly using getline
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用getline显式读取一行
- en: Usually, `grep` reads all lines in a file by default. If you want to read one
    specific line, you can use the `getline` function. Sometimes we may need to read
    the first line from the `BEGIN` block.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`grep`默认读取文件中的所有行。如果要读取特定行，可以使用`getline`函数。有时我们可能需要从`BEGIN`块中读取第一行。
- en: 'The syntax is: `getline var`'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 语法是：`getline var`
- en: The variable `var` will contain the content for the line.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`var`将包含该行的内容。
- en: If the `getline` is called without an argument, we can access the content of
    the line by using `$0`, `$1`, and `$2`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`getline`没有参数调用，我们可以使用`$0`，`$1`和`$2`来访问行的内容。
- en: 'For example:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE83]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Filtering lines processed by awk with filter patterns
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用过滤模式过滤由awk处理的行
- en: 'We can specify some conditions for lines to be processed. For example:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为要处理的行指定一些条件。例如：
- en: '[PRE84]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Setting delimiter for fields
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置字段的分隔符
- en: 'By default, the delimiter for fields is space. We can explicitly specify a
    delimiter using `-F "delimiter"`:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，字段的分隔符是空格。我们可以使用`-F "delimiter"`来明确指定分隔符：
- en: '[PRE85]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Or:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE86]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We can set the output fields separator by setting `OFS="delimiter"` in the `BEGIN`
    block.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`BEGIN`块中设置`OFS="delimiter"`来设置输出字段分隔符。
- en: Reading command output from awk
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从awk读取命令输出
- en: 'In the following code, `echo` will produces a single blank line. The `cmdout`
    variable will contain output of command `grep root /etc/passwd` and it will print
    the line containing `root`:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`echo`将产生一行空行。`cmdout`变量将包含`grep root /etc/passwd`命令的输出，并打印包含`root`的行：
- en: 'The syntax for reading out of the ''command'' in a variable ''output'' is as
    follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量'output'中读取'command'的语法如下：
- en: '[PRE87]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'For example:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE88]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: By using `getline` we can read the output of external shell commands in a variable
    called `cmdout`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`getline`，我们可以将外部shell命令的输出读入名为`cmdout`的变量中。
- en: '`awk` supports associative arrays, which can use text as the index.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`支持关联数组，可以使用文本作为索引。'
- en: Using loop inside awk
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在awk中使用循环
- en: 'A `for` loop is available in `awk`. It has the format:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`中有一个`for`循环。它的格式是：'
- en: '[PRE89]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Or:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE90]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '`awk` comes with many built-in string manipulation functions. Let''s have a
    look at a few of them:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`带有许多内置的字符串操作函数。让我们来看看其中的一些：'
- en: '`length(string)`: It returns the string length.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length(string)`: 它返回字符串的长度。'
- en: '`index(string, search_string)`: It returns the position at which the `search_string`
    is found in the string.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index(string, search_string)`: 它返回`search_string`在字符串中的位置。'
- en: '`split(string, array, delimiter)`: It stores the list of strings generated
    by using the delimiter in the array.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`split(string, array, delimiter)`: 它将使用分隔符生成的字符串列表存储在数组中。'
- en: '`substr(string, start-position, end-position)`: It returns the substring created
    from the string by using start and end character offets.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`substr(string, start-position, end-position)`: 它返回通过使用起始和结束字符偏移创建的子字符串。'
- en: '`sub(regex, replacement_str, string)`: It replaces the first occurring regular
    expression match from the string with `replacment_str`.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sub(regex, replacement_str, string)`: 它用`replacment_str`替换字符串中第一次出现的正则表达式匹配。'
- en: '`gsub(regex, replacment_str, string`: It is similar to `sub()`. But it replaces
    every regular expression match.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gsub(regex, replacment_str, string)`: 它类似于`sub()`。但它替换每一个正则表达式匹配。'
- en: '`match(regex, string)`: It returns the result of whether a regular expression
    (regex) match is found in the string or not. It returns non-zero if match is found,
    else it returns zero. Two special variables are associated with `match()`. They
    are `RSTART` and `RLENGTH`. The `RSTART` variable contains the position at which
    the regular expression match starts. The `RLENGTH` variable contains the length
    of the string matched by the regular expression.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match(regex, string)`: 它返回正则表达式（regex）是否在字符串中找到匹配的结果。如果找到匹配，则返回非零，否则返回零。`match()`关联有两个特殊变量。它们是`RSTART`和`RLENGTH`。`RSTART`变量包含正则表达式匹配开始的位置。`RLENGTH`变量包含正则表达式匹配的字符串的长度。'
- en: Replacing strings from a text or file
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文本或文件中替换字符串
- en: String replacement is a frequently-used text-processing task. It can be done
    easily with regular expressions by matching the required text.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串替换是一个经常使用的文本处理任务。通过匹配所需的文本，可以很容易地使用正则表达式来完成。
- en: Getting ready
  id: totrans-418
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: When we hear the term 'replace', every system admin will recall sed. `sed` is
    the universal tool under UNIX-like systems to make replacements in text or in
    a file. Let's see how to do it.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们听到“替换”这个术语时，每个系统管理员都会想起sed。 `sed`是UNIX-like系统下进行文本或文件替换的通用工具。让我们看看如何做到这一点。
- en: How to do it...
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The `sed` primer recipe contains most of the usages of `sed`. You can replace
    a string or pattern as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`入门配方包含了大部分`sed`的用法。您可以按以下方式替换字符串或模式：'
- en: '[PRE91]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Or:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE92]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We can also use double quote (") instead of single quote (''). When double
    quote (") is used, we can specify variables inside the `sed` pattern and replacement
    strings. For example:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用双引号（"）而不是单引号（'）。当使用双引号（"）时，我们可以在`sed`模式和替换字符串中指定变量。例如：
- en: '[PRE93]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We can also use it without `g` in `sed`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在`sed`中不使用`g`。
- en: '[PRE94]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Then it will replace the occurrence of `PATTERN` first time it appears only.
    `/g` stands for global. That means, it will replace every occurrence of `PATTERN`
    in the file.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它将只替换`PATTERN`第一次出现的情况。`/g`代表全局。这意味着它将替换文件中`PATTERN`的每一个出现。
- en: There's more...
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We have seen basic text replacement with `sed`. Let's see how to save the replaced
    text in the source file itself.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了使用`sed`进行基本文本替换。让我们看看如何将替换后的文本保存在源文件中。
- en: Making replacement saved in the file
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将替换保存在文件中
- en: 'When a filename is passed to `sed`, it''s output will be available to `stdout`.
    Instead of sending the output stream into `stdout`, to make changes saved in the
    file, use the `–i` option as follows:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 当将文件名传递给`sed`时，它的输出将可用于`stdout`。为了将更改保存在文件中，而不是将输出流发送到`stdout`，请使用以下`-i`选项：
- en: '[PRE95]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'For example, replace all three-digit numbers with another specified number
    in a file as follows:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用以下方法在文件中替换所有三位数为另一个指定的数字：
- en: '[PRE96]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The above one-liner replaces three-digit numbers only.`\b[0-9]\{3\}\b` is the
    regular expression used to match three-digit numbers. [0-9] is the range of digits,
    that is, from 0 to 9\. {3} is used for matching the preceding character thrice.
    `\` in `\{3\}` is used to give a special meaning for `{` and `}`. `\b` is the
    word boundary marker.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的一行只替换三位数。`\b[0-9]\{3\}\b`是用于匹配三位数的正则表达式。[0-9]是数字的范围，即从0到9。{3}用于匹配前面的字符三次。`\`在`\{3\}`中用于给`{`和`}`赋予特殊含义。`\b`是单词边界标记。
- en: See also
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Basic sed primer*, explains the sed command'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本的sed入门*，解释了sed命令'
- en: Compressing or decompressing JavaScript
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压缩或解压JavaScript
- en: JavaScript is widely used in designing websites. While writing JavaScript code,
    we use several white spaces, comments, and tabs for readability and maintenance
    of code. But the use of a lot of white spaces and tabs in JavaScript causes the
    file size to increase. As the file size increases, it increases page load times.
    Hence most of the professional websites use compressed JavaScripts for fast loading.
    Compression is mostly squeezing white spaces and newline characters. Once JavaScript
    is compressed, it can be decompressed by adding enough white space and newline
    characters, which makes it readable. Usually, obfuscated code also can be made
    readable by inserting white space and newlines. This recipe is an attempt to hack
    similar capabilities in the shell.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在设计网站时被广泛使用。在编写JavaScript代码时，我们使用多个空格、注释和制表符来提高代码的可读性和维护性。但是在JavaScript中使用大量空格和制表符会导致文件大小增加。随着文件大小的增加，页面加载时间也会增加。因此，大多数专业网站都使用压缩的JavaScript来实现快速加载。压缩主要是挤压空格和换行字符。一旦JavaScript被压缩，可以通过添加足够的空格和换行字符来解压缩，从而使其可读。通常，混淆的代码也可以通过插入空格和换行符来实现可读。这个方法是在shell中尝试窃取类似功能的一种尝试。
- en: Getting ready
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are going to write a JavaScript compressor or obfuscation tool. Also a decompressing
    tool can be designed. We are going to get our hands dirty using text and character
    replacement tools `tr` and `sed`. Let's see how to do it.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个JavaScript压缩器或混淆工具。也可以设计一个解压工具。我们将使用文本和字符替换工具`tr`和`sed`。让我们看看如何做到这一点。
- en: How to do it...
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's go through the logical sequences and the code required for compressing
    and decompressing the JavaScript.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照逻辑顺序和所需的代码来压缩和解压JavaScript。
- en: '[PRE97]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The following are the tasks we need to perform for compressing the JavaScript:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行以下任务来压缩JavaScript：
- en: Remove newline and tab characters.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除换行符和制表符。
- en: Squeeze spaces.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挤压空格。
- en: Replace comments /* content */.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换注释/*内容*/。
- en: 'Replace the following with substitutions:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用替换替换以下内容：
- en: '"{ " with "{"'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将"{ "替换为"{"
- en: '" }" with "}"'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '" }"替换为"}"'
- en: '" (" with "("'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '" ("替换为"("'
- en: '") " with ")"'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '") "替换为")"'
- en: '", " with ","'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '", "替换为","'
- en: '" ; " with ";" (we need to remove all extra spaces)'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '" ; "替换为";"（我们需要删除所有额外的空格）'
- en: 'To decompress or to make the JavaScript more readable, we can use the following
    tasks:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 要解压缩或使JavaScript更易读，我们可以使用以下任务：
- en: Replace ";" with ";\n".
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将";"替换为";\n"。
- en: Replace "{" with "{\n" and "}" with "\n}".
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将"{"替换为"{\n"，将"}"替换为"\n}"。
- en: How it works...
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s compress the JavaScript by performing these tasks:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过执行以下任务来压缩JavaScript：
- en: 'Remove the''\n'' and ''\t'' characters:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除'\n'和'\t'字符：
- en: '[PRE98]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Remove extra spaces:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除额外的空格：
- en: '[PRE99]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Remove comments:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除注释：
- en: '[PRE100]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '`:` is used as a sed delimiter to avoid the need of escaping `/` since we need
    to use `/*` and `*/`'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:`被用作sed分隔符，以避免需要转义`/`，因为我们需要使用`/*`和`*/`'
- en: '`*` in the sed is escaped as `\*`'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在sed中，`*`被转义为`\*`
- en: '`.*` is used to match all text in between `/*` and `*/`'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.*`用于匹配`/*`和`*/`之间的所有文本'
- en: Remove all spaces preceding and suffixing the `{`,`}`,`(`,`)`,`;`,`:`, and comma.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有在`{`、`}`、`(`、`)`、`;`、`:`和逗号之前和之后的空格。
- en: '[PRE101]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The above `sed` statement can be parsed as follows:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`sed`语句可以解析如下：
- en: '`/ \?\([{}();,:]\) \?/` in the `sed` code is the match part and `/\1 /g` is
    the replacement part.'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/ \?\([{}();,:]\) \?/`在`sed`代码中是匹配部分，`/\1 /g`是替换部分。'
- en: '`\([{}();,:]\)` is used to match any one character in the set `[ { }( ) ; ,
    : ]` (inserted spaces for readability). `\(` and `\)` are group operators used
    to memorize the match and back reference in the replacement part. `(` and `)`
    are escaped to give them a special meaning as a group operator. `\?` precedes
    and follows the group operators. It is to match the space character that may precede
    or follow any of the characters in the set.'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\([{}();,:]\)`用于匹配集合`[ { }( ) ; , : ]`中的任意一个字符（为了可读性插入了空格）。`\(`和`\)`是用于在替换部分中记忆匹配和回溯引用的组操作符。`(`和`)`被转义以赋予它们作为组操作符的特殊含义。`\?`在组操作符之前和之后。它是为了匹配可能在集合中的任何字符之前或之后的空格字符。'
- en: In the replacement part, the match string (that is, the combination of `:` a
    space (optional), a character from the set, and again optional space) is replaced
    with the character matched. It uses a back reference to the character matched
    and memorized using the group operator `()`. Back-referenced characters refer
    to a group match by using the `\1` symbol.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在替换部分，匹配字符串（即`:`一个空格（可选）、来自集合的字符，再次是可选空格）被替换为匹配的字符。它使用了一个回溯引用来匹配和记忆使用组操作符`()`的字符。通过使用`\1`符号，回溯引用的字符指的是组匹配。
- en: 'Combine the above tasks using a pipe as follows:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 使用管道结合上述任务如下：
- en: '[PRE102]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The output is as follows:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE103]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Let''s write a decompression script for making obfuscated code readable as
    follows:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个解压缩脚本，使混淆的代码可读，如下所示：
- en: '[PRE104]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Or:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE105]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'In the previous command:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个命令中：
- en: '`s/;/;\n/g` replaces `;` with `\n;`'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s/;/;\n/g`将`;`替换为`\n;`'
- en: '`s/{/{\n\n/g` replaces `{` with `{\n\n`'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s/{/{\n\n/g`将`{`替换为`{\n\n`'
- en: '`s/}/\n\n}/g` replaces `}` with `\n\n}`'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s/}/\n\n}/g`将`}`替换为`\n\n}`'
- en: See also
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Translating with tr* of[Chapter 2](ch02.html "Chapter 2. Have a Good Command"),
    explains the tr command'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用tr进行翻译* [第2章](ch02.html "第2章。掌握好命令") ，解释了tr命令'
- en: '*Basic sed primer*, explains the sed command'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本sed入门*，解释了sed命令'
- en: Iterating through lines, words, and characters in a file
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在文件中迭代行、单词和字符
- en: Iterating through character, word, and lines in a file is a frequently required
    script element while writing different text processing and file operation scripts.
    Even though it is simple to perform, we make simple mistakes and it gets erroneous
    without getting the expected output. This recipe will help you out to learn how
    to do it.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写不同的文本处理和文件操作脚本时，经常需要对文件中的字符、单词和行进行迭代。尽管这很简单，但我们会犯一些错误，而且没有得到预期的输出。这个方法将帮助你学会如何做到这一点。
- en: Getting ready
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Iteration with a simple loop and redirection from `stdin` or file are basic
    components of performing the mentioned tasks.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单循环和从`stdin`或文件重定向进行迭代是执行上述任务的基本组件。
- en: How to do it...
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe we discuss about performing three tasks of iterating through
    line, word, and characters. Let's see how each of these tasks can be performed.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们讨论了执行遍历行、单词和字符的三个任务。让我们看看如何执行这些任务中的每一个。
- en: '**Iterate through each line in a file:**'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**遍历文件中的每一行：**'
- en: We can use a `while` loop to read from standard input. Hence it will read a
    line in each iteration.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`while`循环从标准输入中读取。因此，它将在每次迭代中读取一行。
- en: 'Use file redirection to `stdin` as follows:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件重定向到`stdin`如下：
- en: '[PRE106]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Use subshell as follows:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如下使用子shell：
- en: '[PRE107]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Here `cat file.txt` can be replaced with the output of any command sequence.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`cat file.txt`可以替换为任何命令序列的输出。
- en: '**Iterate through each word in a line**'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**遍历每个单词中的每个单词**'
- en: 'We can use a `while` loop to iterate through words in a line as follows:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`while`循环来遍历行中的单词，如下所示：
- en: '[PRE108]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '**Iterate through each character in a word**'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**遍历单词中的每个字符**'
- en: We can use a `for` loop to iterate a variable `i` from `0` to the length of
    string. A character can be extracted from the string in each iteration using the
    special notation `${string:start_position:No_of_characters}`.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`for`循环来迭代变量`i`从`0`到字符串的长度。在每次迭代中，可以使用特殊符号`${string:start_position:No_of_characters}`从字符串中提取一个字符。
- en: '[PRE109]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: How it works...
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Reading lines of a file and reading words in a line are direct ways. But reading
    a character of a word is a little hack. We use the substring extraction technique.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文件的行和读取行中的单词是直接的方法。但是读取单词的字符有点技巧。我们使用子字符串提取技术。
- en: '`${word:start_position:no_of_characters}` returns a substring of a string held
    in variable `word`.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`${word:start_position:no_of_characters}`返回变量`word`中字符串的子字符串。'
- en: '`${#word}` returns the length of the variable `word`.'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '`${#word}`返回变量`word`的长度。'
- en: See also
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Field separators and iterators* of[Chapter 1](ch01.html "Chapter 1. Shell
    Something Out"), explains different loops in Bash.'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*字段分隔符和迭代器* [第1章](ch01.html "第1章。外壳的某些东西")，解释Bash中的不同循环。'
- en: '*Text slicing and parameter operations*, explains extracting characters from
    a string.'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文本切片和参数操作*，解释从字符串中提取字符。'
- en: Merging multiple files as columns
  id: totrans-519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并多个文件作为列
- en: There are different cases when we require to concatenate files in columns. We
    may need each file's content to appear in separate columns. Usually, the `cat`
    command concatenates in a line- or row-wise fashion.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的情况需要我们在列中连接文件。我们可能需要使每个文件的内容出现在单独的列中。通常，`cat`命令以行或行的方式连接。
- en: How to do it...
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: '`paste` is the command that can be used for column-wise concatenation. The
    `paste` command can be used with the following syntax:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`paste`是可用于按列连接的命令。`paste`命令可使用以下语法：'
- en: '`$ paste file1 file2 file3 …`'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ paste file1 file2 file3 …`'
- en: 'Let''s try an example as follows:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试以下示例：
- en: '[PRE110]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The default delimiter is Tab. We can also explicitly specify the delimiter
    using `–d`. For example:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 默认分隔符是制表符。我们也可以使用`-d`显式指定分隔符。例如：
- en: '[PRE111]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: See also
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Column-wise cutting of a file with cut*, explains extracting data from text
    files'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用cut按列切割文件*，解释从文本文件中提取数据'
- en: Printing the nth word or column in a file or line
  id: totrans-530
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在文件或行中打印第n个单词或列
- en: We may get a file having a number of columns and only a few will actually be
    useful. In order to print only relevant columns or fields, we filter it.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会得到一个具有许多列的文件，实际上只有少数列是有用的。为了仅打印相关列或字段，我们对其进行过滤。
- en: Getting ready
  id: totrans-532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The most widely-used method is to use `awk` for doing this task. It can be also
    done using `cut`.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 最广泛使用的方法是使用`awk`来执行此任务。也可以使用`cut`来完成。
- en: How to do it...
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To print the fifth column use the following command:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印第五列，请使用以下命令：
- en: '[PRE112]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: We can also print multiple columns and we can insert our custom string in between
    columns.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以打印多个列，并且可以在列之间插入自定义字符串。
- en: 'For example, to print the permission and filename of each file in the current
    directory, use:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要打印当前目录中每个文件的权限和文件名，请使用：
- en: '[PRE113]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: See also
  id: totrans-540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Basic awk primer*, explains the awk command'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本awk入门*，解释awk命令'
- en: '*Column-wise cutting of a file with cut*, explains extracting data from text
    files'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用cut按列切割文件*，解释从文本文件中提取数据'
- en: Printing text between line numbers or patterns
  id: totrans-543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印行号或模式之间的文本
- en: We may require to print certain section of text lines based on conditions such
    as a range of line numbers, range matched by start and end pattern and so on.
    Let's see how to do it.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要根据条件打印文本行的某些部分，例如行号范围，开始和结束模式匹配的范围等。让我们看看如何做到这一点。
- en: Getting ready
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We can use utilities such as awk, grep, and sed to perform the printing of a
    section based on conditions. Still I found `awk` to be the simplest one to understand.
    Let's do it using `awk`.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用诸如awk、grep和sed之类的实用程序根据条件执行部分打印。但我发现`awk`是最容易理解的。让我们使用`awk`来做。
- en: How to do it...
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In order to print lines of text in a range of line numbers, M to N, use the
    following syntax:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印文本行的行号范围，从M到N，使用以下语法：
- en: '[PRE114]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Or, it can take `stdin` input as follows:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它可以接受`stdin`输入如下：
- en: '[PRE115]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Replace `M` and `N` with numbers as follows:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 将`M`和`N`替换为以下数字：
- en: '[PRE116]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'To print lines of text in a section with `start_pattern` and `end_pattern`,
    use the following syntax:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印文本部分的行，使用以下语法：`start_pattern`和`end_pattern`。
- en: '[PRE117]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'For example:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE118]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The patterns used in `awk` are regular expressions.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`中使用的模式是正则表达式。'
- en: See also
  id: totrans-559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Basic awk primer*, explains the awk command'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本awk入门*，解释awk命令'
- en: Checking palindrome strings with a script
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用脚本检查回文字符串
- en: Checking whether a string is palindrome is one of the first lab exercises in
    a C programming course. However, here we have included this recipe to give you
    an idea of how to solve similar problems in which pattern matching can be extended
    in a way that previously occurring patterns repeat in the text.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 检查字符串是否回文是C编程课程中的第一个实验。但是，在这里，我们包含了这个配方，以便让您了解如何解决类似的问题，其中模式匹配可以扩展为以前出现的模式在文本中重复。
- en: Getting ready
  id: totrans-563
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `sed` command has the capability to remember a previously-matched sub pattern.
    It is called back referencing. We can solve palindrome problems by using back
    referencing. We can solve this using multiple ways in Bash.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`命令具有记住先前匹配的子模式的能力。这被称为反向引用。我们可以通过使用反向引用来解决回文问题。我们可以在Bash中使用多种方法来解决这个问题。'
- en: How to do it...
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: '`sed` can remember previously matched regular expression patterns, thereby
    we can identify whether duplicates of a character exists in a string. This capability
    to remember and reference previously matched patterns is called back-reference.'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`可以记住先前匹配的正则表达式模式，因此我们可以确定字符串中是否存在字符的重复。这种记住和引用先前匹配模式的能力称为反向引用。'
- en: 'Let''s see how we can apply back-referencing in a simpler manner to solve the
    problem. For example:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何以更简单的方式应用反向引用来解决问题。例如：
- en: '[PRE119]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '`\(.\)` corresponds to memorize the one sub string inside ( ). Here it is .
    (period) which is also sed''s single character wildcard character.'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`\(.\)`对应于记住( )内的一个子字符串。这里是 . (句号)，它也是`sed`的单个字符通配符。'
- en: '`\1` corresponds to the memory of the first match inside (). `\2` corresponds
    to the second match. Hence we can memorize many blocks enclosed in `()`. `()`
    appears as `\( \)` to give `(` and `)` special meaning rather than just a character.'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '`\1`对应于`()`内的第一个匹配的记忆。`\2`对应于第二个匹配。因此，我们可以记住许多被`()`包围的块。`()`显示为`\( \)`，以赋予`(`和`)`特殊含义，而不仅仅是一个字符。'
- en: The previous `sed` statement will print any pattern matching two exactly the
    same.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`sed`语句将打印任何匹配两个完全相同的模式。
- en: 'The structure of all palindrome words is as follows:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 所有回文单词的结构如下：
- en: Even number of characters and a sequence of characters concatenated with same
    characters in reverse order
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偶数个字符和一个字符序列，与其反向序列连接
- en: Odd number of characters with a sequence of characters concatenated with reverse
    of same characters, but a common character in between the first sequence and its
    reverse
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奇数个字符，带有字符序列，与相同字符的反向连接，但在第一个序列和其反向之间有一个公共字符
- en: Therefore, for matching both, we can keep an optional character in between while
    writing the regular expression.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了匹配两者，我们可以在写正则表达式时在中间保留一个可选字符。
- en: 'A `sed` regex matching a three-letter palindrome word will look like the following:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配三个字母回文单词的`sed`正则表达式将如下所示：
- en: '[PRE120]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: We can place an extra character (`.`) in between the character sequence and
    its reverse sequence.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在字符序列和其反向序列之间放置一个额外的字符(`.`)。
- en: 'Let''s write a script that can match a palindrome string of any length as follows:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个可以匹配任意长度的回文字符串的脚本，如下所示：
- en: '[PRE121]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Use the dictionary file as the input file to get a list of palindrome words
    of a given string length. For example:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典文件作为输入文件，以获取给定字符串长度的回文单词列表。例如：
- en: '[PRE122]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: How it works...
  id: totrans-583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The working of the above script is simple. Most of the work is done to generate
    the `sed` script for a regular expression and a back-reference string generation.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本的工作很简单。大部分工作是为正则表达式和反向引用字符串生成`sed`脚本。
- en: Let's go through its working with the help of some worked out examples.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些示例来看看它的工作原理。
- en: 'If you want to match the character and back-reference it, we use `\(.\)` to
    match one character and `\1` to reference it. Hence, in order match a two letter
    palindrome and print it, we use:'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要匹配字符并进行反向引用，我们使用`\(.\)`来匹配一个字符，`\1`来引用它。因此，为了匹配并打印两个字母的回文，我们使用：
- en: '[PRE123]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Now, to specify that match string from the beginning of the line, we add line-begin
    market ^ so that it will become `sed'/^\(.\)\1/p'`. `/p` is used to print the
    match.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了指定从行的开头匹配字符串，我们添加行开始标记^，这样它将变成`sed'/^\(.\)\1/p'`。`/p`用于打印匹配。
- en: 'If we want to match four character palindrome, we use:'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想匹配四个字符的回文，我们使用：
- en: '[PRE124]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: We have used two `\(.\)` to match two characters and remember them. Anything
    enclosed within `\(` and `\)` will be remembered by `sed` and can be back-referenced.
    `\2\1` is used to back-reference in the reverse order of the matched characters.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了两个`\(.\)`来匹配两个字符并记住它们。任何在`\(`和`\)`之间的内容都将被`sed`记住并可以被反向引用。`\2\1`用于以匹配字符的相反顺序进行反向引用。
- en: In the above script, we have a variable called `basepattern`, which contains
    the `sed` script.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的脚本中，我们有一个名为`basepattern`的变量，其中包含`sed`脚本。
- en: The pattern is generated using a `for` loop based on the number of characters
    in the palindrome string.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式是根据回文字符串中的字符数使用`for`循环生成的。
- en: Initially, basepattern is initialized as `basepattern='/^\(.\)'`, which corresponds
    to a one-character match. A `for` loop is used to concatenate `\(.\)` with `basepattern`
    for half the number of times of the length of palindrome string. Again a `for`
    loop is used to concatenate back-references in the reverse order (like `'\4\3\2\1'`)
    half the number of times the length of palindrome string. Finally, in order to
    support palindrome strings with odd length an optional character (`.`) is enclosed
    between match regex and back-references.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`basepattern`被初始化为`basepattern='/^\(.\)'`，它对应于一个字符匹配。使用`for`循环将`\(.\)`与`basepattern`连接起来，连接次数为回文字符串长度的一半。再次使用`for`循环以与回文字符串长度的一半相同的次数连接反向引用。最后，为了支持奇数长度的回文字符串，在匹配正则表达式和反向引用之间加入了一个可选字符(`.`)。
- en: Thus the `sed` palindrome match pattern is crafted. This crafted string is used
    to find out the palindrome strings from the dictionary file.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`sed`回文匹配模式是精心制作的。这个精心制作的字符串用于从字典文件中找出回文字符串。
- en: 'In the above script, we have used `sed` pattern generation using `for` loops.
    Actually there is no need to generate pattern separately. The `sed` command has
    its own loop implementation using labels and goto. `sed` is a vast language. Palindrome
    check can be done in a single line using a complex `sed` script. It is hard to
    explain it from scratch. Just try out the following script:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的脚本中，我们使用了`for`循环生成`sed`模式。实际上没有必要单独生成模式。`sed`命令有自己的循环实现，使用标签和goto。`sed`是一种广泛的语言。可以使用复杂的`sed`脚本在一行中进行回文检查。很难从头开始解释它。只需尝试以下脚本：
- en: '[PRE125]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'If you are interested in deep scripting with `sed`, refer to the complete `sed`
    and `awk` reference book: *sed & awk*, Second Edition by Dale Dougherty and Arnold
    Robbins.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对使用`sed`进行深入脚本编写感兴趣，请参考完整的`sed`和`awk`参考书：*sed & awk*，作者Dale Dougherty和Arnold
    Robbins的第二版。
- en: Try to parse the above one-line `sed` script to test the palindrome using the
    book.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试解析上面的一行`sed`脚本以测试回文是否使用该书。
- en: There's more...
  id: totrans-600
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now let's see some other options, or possibly some pieces of general information
    that are relevant to this task.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看其他选项，或者可能与此任务相关的一些一般信息片段。
- en: Simplest and direct method
  id: totrans-602
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最简单直接的方法
- en: The simplest method to check whether a string is a palindrome is by using the
    rev command.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 检查字符串是否是回文的最简单方法是使用rev命令。
- en: The `rev` command takes a file or `stdin` as input and prints the reversed string
    of every line.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '`rev`命令接受文件或`stdin`作为输入，并打印每行的反转字符串。'
- en: 'Let''s do it:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来做一下：
- en: '[PRE126]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The `rev` command can be used along with other commands to solve different
    problems. Let''s look at an interesting example to reverse the words in a sentence:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '`rev`命令可以与其他命令一起使用来解决不同的问题。让我们看一个有趣的例子，将句子中的单词反转：'
- en: '[PRE127]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The output is as follows:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE128]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: In the above one-liner, the characters are reversed first using the `rev` command.
    Then the words are separated into a word per line by replacing space with the
    `\n` character by using the `tr` command. Now the lines are reversed in order
    using the `tac` command. Again, lines are merged into a line using `tr`. Now `rev`
    is again applied so that a line with words is in the reverse order.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的一行代码中，首先使用`rev`命令反转字符。然后通过使用`tr`命令将空格替换为`\n`字符，将单词分隔成每行一个单词。现在使用`tac`命令按顺序反转行。再次使用`tr`将行合并为一行。现在再次应用`rev`，使得带有单词的行以相反的顺序排列。
- en: See also
  id: totrans-612
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Basic sed primer*, explains the sed command'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本的sed入门*，解释了sed命令'
- en: '*Comparisons and tests* of [Chapter 1](ch01.html "Chapter 1. Shell Something
    Out"), explains the string comparison operators'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*比较和测试* [第1章](ch01.html "第1章。Shell Something Out")的[比较和测试]，解释了字符串比较运算符'
- en: Printing lines in the reverse order
  id: totrans-615
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以相反的顺序打印行
- en: This is a simple recipe. It may not seem very useful but it can be used to emulate
    the stack data structure in Bash. This is something interesting. Let's print the
    lines of text in a file in reverse order.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的方法。它可能看起来并不是很有用，但它可以用来模拟Bash中的堆栈数据结构。这是一些有趣的东西。让我们以相反的顺序打印文件中的文本行。
- en: Getting ready
  id: totrans-617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A little hack with `awk` can do the task. However, there is a direct command
    `tac` to do the same as well. `tac` is the reverse of `cat`.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`awk`的小技巧可以完成任务。但是，也有一个直接的命令`tac`可以做同样的事情。`tac`是`cat`的反向。
- en: How to do it...
  id: totrans-619
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s do it with `tac` first. The syntax is as follows:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们用`tac`来做。语法如下：
- en: '[PRE129]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'It can also read from `stdin` as follows:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以按以下方式从`stdin`读取：
- en: '[PRE130]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: In `tac`, `\n` is the line separator. But we can also specify our own separator
    by using the `-s` "separator" option.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tac`中，`\n`是行分隔符。但我们也可以使用`-s` "separator"选项指定自己的分隔符。
- en: 'Let''s do it in `awk` as follows:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`awk`来做：
- en: '[PRE131]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '`\` in the shell script is used to conveniently break a single line command
    sequence into multiple lines.'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell脚本中，`\`用于方便地将单行命令序列分解为多行。
- en: How it works...
  id: totrans-628
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `awk` script is very simple. We store each of the lines into an associative
    array with the line number as array index (NR gives line number). In the end,
    `awk` executes the `END` block. In order to get last line number `lno=NR` is used
    in the { } block. Hence it iterates from the last line number to `0` and prints
    the lines stored in the array in reverse order.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`脚本非常简单。我们将每行存储到一个关联数组中，行号作为数组索引（NR给出行号）。最后，`awk`执行`END`块。为了获得最后一行行号，`lno=NR`在{
    }块中使用。因此，它从最后一行号迭代到`0`，并以相反的顺序打印数组中存储的行。'
- en: See also
  id: totrans-630
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Implementing head, tail, and tac with awk*, explains writing tac using awk'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用awk实现head、tail和tac*，解释了使用awk编写tac'
- en: Parsing e-mail addresses and URLs from text
  id: totrans-632
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文本中解析电子邮件地址和URL
- en: Parsing required text from a given file is a common task that we encounter in
    text processing. Items such as e-mail, URL, and so on can be found out with the
    help of correct regex sequences. Mostly, we need to parse e-mail addresses from
    a contact list of a e-mail client which is composed of many unwanted characters
    and words or from a HTML web page.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 从给定文件中解析所需的文本是我们在文本处理中经常遇到的常见任务。通过正确的正则表达式序列可以找到诸如电子邮件、URL等项目。大多数情况下，我们需要从由许多不需要的字符和单词组成的电子邮件客户端的联系人列表或HTML网页中解析电子邮件地址。
- en: Getting ready
  id: totrans-634
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This problem can be solved with utilities egrep.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题可以用egrep工具解决。
- en: How to do it...
  id: totrans-636
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The regular expression pattern to match an e-mail address is:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配电子邮件地址的正则表达式模式是：
- en: egrep regex:`[A-Za-z0-9.]+@[A-Za-z0-9.]+\.[a-zA-Z]{2,4}`
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: egrep正则表达式：`[A-Za-z0-9.]+@[A-Za-z0-9.]+\.[a-zA-Z]{2,4}`
- en: 'For example:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE132]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The `egrep regex` pattern for an HTTP URL is:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 用于HTTP URL的`egrep regex`模式是：
- en: '[PRE133]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'For example:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE134]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: How it works...
  id: totrans-645
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The regular expressions are really easy to design part by part. In the e-mail
    regex, we all know that an e-mail address takes the form `name@domain.some_2-4_letter`.
    Here the same is written in regex language as follows:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 设计正则表达式真的很容易。在电子邮件正则表达式中，我们都知道电子邮件地址的形式是`name@domain.some_2-4_letter`。在这里，相同的内容以正则表达式语言写成如下：
- en: '[PRE135]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '`[A-Za-z0-9.]+` means that some combination of characters in the `[]` block
    should appear one or more times (that is the meaning of `+`) before a literal
    `@` character appears. Then `[A-Za-z0-9.]` also should appear one or more times
    (`+`). The pattern `\.`means that a literal period should appear and finally the
    last part should be of length 2 to 4 alphabetic characters.'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: '`[A-Za-z0-9.]+`表示在`[]`块中的一些字符组合应该在字面`@`字符出现之前出现一次或多次（这是`+`的含义）。然后`[A-Za-z0-9.]`也应该出现一次或多次（`+`）。模式`\.`表示应该出现一个字面上的句号，最后一部分应该是长度为2到4个字母字符。'
- en: The case of an HTTP URL is similar to that of an e-mail address but without
    the `name@` match part of e-mail regex.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP URL的情况类似于电子邮件地址，但没有电子邮件正则表达式的`name@`匹配部分。
- en: '[PRE136]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: See also
  id: totrans-651
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Basic sed primer*, explains the sed command'
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本sed入门*，解释了sed命令'
- en: '*Basic regular expression primer*, explains how to use regular expressions'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本正则表达式入门*，解释了如何使用正则表达式'
- en: Printing n lines before or after a pattern in a file
  id: totrans-654
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在文件中打印模式之前或之后的n行
- en: Printing a section of text by pattern matching is frequently used in text processing.
    Sometimes we may need the lines of text before a pattern or after a pattern appears
    in a text. For example, consider that there is a file containing the rating of
    film actors where each line corresponds to a film actor's details, and we need
    to find out the rating of an actor along with the details of actors who are nearest
    to them in rating. Let's see how to do it.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 通过模式匹配打印文本部分在文本处理中经常使用。有时，我们可能需要在文本中出现模式之前或之后的文本行。例如，考虑一个包含电影演员评分的文件，其中每行对应于电影演员的详细信息，我们需要找出演员的评分以及评分最接近他们的演员的详细信息。让我们看看如何做到这一点。
- en: Getting ready
  id: totrans-656
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: '`grep` is the best tool for searching and finding text in a file. Usually,
    `grep` prints a matching line or matching text for a given pattern. But the context
    line control options in `grep` enables it to print before, after, and before-after
    lines around the line of pattern match.'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`是在文件中搜索和查找文本的最佳工具。通常，`grep`打印给定模式的匹配行或匹配文本。但是`grep`中的上下文行控制选项使其能够打印模式匹配行周围的行之前，之后和之前后。'
- en: How to do it...
  id: totrans-658
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'This technique can be better explained with a film actor list. For example:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可以通过电影演员列表更好地解释。例如：
- en: '[PRE137]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'In order to print three lines after the match "Cameron Diaz" along with the
    matching line, use the following command:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印匹配“卡梅隆·迪亚兹”之后的三行文本以及匹配行，请使用以下命令：
- en: '[PRE138]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'In order to print the matched line and the preceding three lines, use the following
    command:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印匹配的行和前面的三行，请使用以下命令：
- en: '[PRE139]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Print the matched line and the two lines before and after the matched line
    as follows:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 打印匹配的行以及匹配行之前和之后的两行如下：
- en: '[PRE140]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Are you wondering where I got this ranking from?
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 你想知道我从哪里得到这个排名吗？
- en: 'I parsed a website having full of images and HTML content just using basic
    sed, awk, and grep commands. See the chapter: *Tangled Web? Not at all*.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用基本的sed，awk和grep命令解析了一个充满图像和HTML内容的网站。请参阅章节：*纷乱的网络？一点也不。*
- en: See also
  id: totrans-669
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Searching and mining "text" inside a file with grep*, explains the grep command.'
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用grep在文件中搜索和挖掘“文本”解释了grep命令。
- en: Removing a sentence in a file containing a word
  id: totrans-671
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从包含单词的文件中删除句子
- en: Removing a sentence containing a word is a simple task when a correct regular
    expression is identified. This is just an exercise on solving similar problems.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 当确定了正确的正则表达式时，删除包含单词的句子是一个简单的任务。这只是解决类似问题的练习。
- en: Getting ready
  id: totrans-673
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: '`sed` is the best utility for making substitutions. Hence let''s use `sed`
    to replace the matched sentence with a blank.'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`是进行替换的最佳实用工具。因此让我们使用`sed`将匹配的句子替换为空白。'
- en: How to do it...
  id: totrans-675
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s create a file with some text to carry out the substitutions. For example:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个带有一些文本的文件进行替换。例如：
- en: '[PRE141]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'We will remove the sentence containing the words "mobile phones". Use the following
    `sed` expression for this task:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将删除包含“移动电话”一词的句子。使用以下`sed`表达式执行此任务：
- en: '[PRE142]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: How it works...
  id: totrans-680
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's evaluate the `sed` regex`'s/ [^.]*mobile phones[^.]*\.//g'`.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们评估`sed`正则表达式`'s/ [^.]*mobile phones[^.]*\.//g'`。
- en: It has the format `'s/substitution_pattern/replacement_string/g`.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 它的格式是`s/替换模式/替换字符串/g`。
- en: It replaces every occurrence of `substitution_pattern` with the replacement
    string.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 它用替换字符串替换每个`替换模式`的出现。
- en: Here the substitution pattern is the regex for a sentence. Every sentence is
    delimited by "." and the first character is a space. Therefore, we need to match
    the text that is in the format "space" some text MATCH_STRING some text "dot".
    A sentence may contain any characters except a "dot", which is the delimiter.
    Hence we have used [^.]. [^.]* matches a combination of any characters except
    dot. In between the text match string "mobile phones" is placed. Every match sentence
    is replaced by `//` (nothing).
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 这里替换模式是句子的正则表达式。每个句子由“。”分隔，第一个字符是空格。因此，我们需要匹配格式为“空格”一些文本MATCH_STRING一些文本“点”的文本。句子可以包含除“点”之外的任何字符，这是分隔符。因此，我们使用了[^.]。[^.]*匹配除点之外的任何字符的组合。在文本匹配字符串“移动电话”之间放置。每个匹配句子都被替换为`//`（无）。
- en: See also
  id: totrans-685
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Basic sed primer*, explains the sed command'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本sed入门*，解释了sed命令'
- en: '*Basic regular expression primer*, explains how to use regular expressions'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本正则表达式入门*，解释了如何使用正则表达式'
- en: Implementing head, tail, and tac with awk
  id: totrans-688
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用awk实现head，tail和tac
- en: Mastering text-processing operations comes with practice. This recipe will help
    us practice incorporating some of the commands that we have just learned with
    some that we already know.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握文本处理操作需要实践。这个配方将帮助我们练习结合我们刚刚学到的一些命令和我们已经知道的一些命令。
- en: Getting ready
  id: totrans-690
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The commands `head`, `tail`, `uniq`, and `tac` operate line by line. Whenever
    we need line by line processing, we can always use `awk`. Let's emulate these
    commands with `awk`.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 命令`head`，`tail`，`uniq`和`tac`逐行操作。每当我们需要逐行处理时，我们总是可以使用`awk`。让我们用`awk`模拟这些命令。
- en: How to do it...
  id: totrans-692
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's see how different commands can be emulated with different basic text processing
    commands, such as head, tail, and tac.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何用不同的基本文本处理命令来模拟不同的命令，比如head、tail和tac。
- en: 'The `head` command reads the first ten lines of a file and prints them out:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '`head`命令读取文件的前十行并将它们打印出来：'
- en: '[PRE143]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The `tail` command prints the last ten lines of a file:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail`命令打印文件的最后十行：'
- en: '[PRE144]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The `tac` command prints the lines of input file in reverse order:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '`tac`命令以相反的顺序打印输入文件的行：'
- en: '[PRE145]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: How it works...
  id: totrans-700
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the implementation of `head` using `awk`, we print the lines in the input
    stream having a line number less than or equal to `10`. The line number is available
    using the special variable `NR`.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`awk`实现`head`时，我们打印输入流中行号小于或等于`10`的行。行号可以使用特殊变量`NR`获得。
- en: In the implementation of the `tail` command a hashing technique is used. The
    buffer array index is determined by a hashing function `NR % 10`, where `NR` is
    the variable that contains the Linux number of current execution. `$0` is the
    line in the text variable. Hence `%` maps all the lines having the same remainder
    in the hash function to a particular index of an array. In the `END{}` block,
    it can iterate through ten index values of an array and print the lines stored
    in a buffer.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tail`命令的实现中使用了一种哈希技术。缓冲区数组索引由哈希函数`NR % 10`确定，其中`NR`是包含当前执行的Linux编号的变量。`$0`是文本变量中的行。因此`%`将哈希函数中具有相同余数的所有行映射到数组的特定索引。在`END{}`块中，它可以遍历数组的十个索引值并打印缓冲区中存储的行。
- en: In the `tac` command emulation, it simply stores all the lines in an array.
    When it appears in the `END{}` block, `NR` will be holding the line number of
    the last line. Then it is decremented in a `for` loop until it reaches `1` and
    it prints the lines stored in each iteration statement.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tac`命令的模拟中，它简单地将所有行存储在一个数组中。当它出现在`END{}`块中时，`NR`将保存最后一行的行号。然后它在`for`循环中递减，直到达到`1`，然后打印每个迭代语句中存储的行。
- en: See also
  id: totrans-704
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Basic awk primer*, explains the awk command'
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本awk入门*，解释了awk命令'
- en: '*head and tail - printing the last or first 10 lines* of[Chapter 3](ch03.html
    "Chapter 3. File In, File Out"), explains the commands head and tail'
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*head和tail - 打印最后或前10行* of[第3章](ch03.html "第3章。文件输入，文件输出")，解释了head和tail命令'
- en: '*Sorting, unique and duplicates* of [Chapter 2](ch02.html "Chapter 2. Have
    a Good Command"), explains the uniq command'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*排序、唯一和重复* of [第2章](ch02.html "第2章。有一个好命令"), 解释了uniq命令'
- en: '*Printing lines in reverse order*, explains the tac command'
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*以相反的顺序打印行*，解释了tac命令'
- en: Text slicing and parameter operations
  id: totrans-709
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本切片和参数操作
- en: This recipe walks through some of the simple text replacement techniques and
    parameter expansion short hands available in Bash. A few simple techniques can
    often help us avoid having to write multiple lines of code.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程介绍了Bash中一些简单的文本替换技术和参数扩展简写。一些简单的技巧通常可以帮助我们避免编写多行代码。
- en: How to do it...
  id: totrans-711
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's get into the tasks.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始任务吧。
- en: 'Replacing some text from a variable can be done as follows:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 从变量中替换一些文本可以这样做：
- en: '[PRE146]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '`line` is replaced with `REPLACED`.'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '`line`被替换为`REPLACED`。'
- en: 'We can produce a sub-string by specifying the start position and string length,
    by using the following syntax:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定起始位置和字符串长度来生成子字符串，使用以下语法：
- en: '[PRE147]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'To print from the fifth character onward use the following command:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 要从第五个字符开始打印，请使用以下命令：
- en: '[PRE148]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'To print eight characters starting from the fifth character, use:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 要从第五个字符开始打印八个字符，请使用：
- en: '[PRE149]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The index is specified by counting the start letter as `0`. We can also specify
    counting from last letter as `-1`. It is but used inside a parenthesis. `(-1)`
    is the index for the last letter.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 索引是通过将起始字母计为`0`来指定的。我们也可以指定从最后一个字母开始计数为`-1`。但它是在括号内使用的。`(-1)`是最后一个字母的索引。
- en: '[PRE150]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: See also
  id: totrans-724
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Iterating through lines, words, and characters in a file*, explains slicing
    of a character from a word'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在文件中迭代行、单词和字符*，解释了从单词中切片一个字符'
