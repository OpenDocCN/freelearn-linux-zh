- en: Variables and User Input
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和用户输入
- en: 'In this chapter, we''ll begin by describing what variables are, and why we
    want and need them. We''ll explain the difference between variables and constants.
    Next, we''ll provide some possibilities with regard to variable naming and introduce
    some best practices on naming conventions. Finally, we''ll discuss user input
    and how to properly deal with it: either with positional arguments or with interactive
    scripts. We''ll end the chapter with an introduction to `if-then` constructs and
    exit codes, which we''ll use to combine positional arguments and interactive prompts.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先描述变量是什么，以及我们为什么需要它们。我们将解释变量和常量之间的区别。接下来，我们将提供一些关于变量命名的可能性，并介绍一些关于命名约定的最佳实践。最后，我们将讨论用户输入以及如何正确处理它：无论是使用位置参数还是交互式脚本。我们将以介绍`if-then`结构和退出代码结束本章，我们将使用它们来结合位置参数和交互提示。
- en: 'The following commands will be introduced in this chapter: `read`, `test`,
    and `if`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下命令：`read`，`test`和`if`。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is a variable?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是变量？
- en: Variable naming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量命名
- en: Dealing with user input
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理用户输入
- en: Interactive versus non-interactive scripts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式与非交互式脚本
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Other than the Ubuntu virtual machine with files from the previous chapters,
    no other resources are needed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除了具有来自前几章的文件的Ubuntu虚拟机外，不需要其他资源。
- en: 'All scripts for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter08](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter08).
    For the name-improved.sh script only the final version is found online. Be sure
    to verify the script version in the header before executing it on your system.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有脚本都可以在GitHub上找到：[https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter08](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter08)。对于 `name-improved.sh` 脚本，只能在网上找到最终版本。在执行脚本之前，请务必验证头部中的脚本版本。
- en: What is a variable?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是变量？
- en: Variables are a standard building block used in many (if not all) programming
    and scripting languages. Variables allow us to store information, so we can reference
    and use it later, often multiple times. We can, for example, use the `textvariable` variable
    to store the sentence `This text is contained in the variable`. In this case,
    the variable name of `textvariable` is referred to as the key, and the content
    of the variable (the text) is referred to as the value, in the key-value pair
    that makes up the variable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是许多（如果不是所有）编程和脚本语言中使用的标准构建块。变量允许我们存储信息，以便稍后可以引用和使用它，通常是多次。例如，我们可以使用`textvariable`变量来存储句子`This
    text is contained in the variable`。在这种情况下，`textvariable`的变量名称被称为键，变量的内容（文本）被称为值，构成了变量的键值对。
- en: In our program, we always reference the `textvariable` variable when we need
    the text. This might be a bit abstract now, but we're confident that after seeing
    the examples in the rest of the chapter, the usefulness of variables will become
    clear.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序中，当我们需要文本时，我们总是引用`textvariable`变量。现在可能有点抽象，但我们相信在本章的其余部分看到示例之后，变量的用处将变得清晰起来。
- en: 'We''ve actually already seen Bash variables in use. Remember, in [Chapter 4](5c0848c2-4c8b-4f52-bcc8-2e670faa6a82.xhtml),
    *The Linux Filesystem*, we looked at both the `BASH_VERSION` and `PATH` variables.
    Let''s see how we can use variables in shell scripting. We''ll take our `hello-world-improved.sh`
    script, and instead of using the `Hello world` text directly, we''ll first put
    it in a variable and reference it:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们已经看到了Bash变量的使用。还记得在[第4章](5c0848c2-4c8b-4f52-bcc8-2e670faa6a82.xhtml) *Linux文件系统*中，我们看过`BASH_VERSION`和`PATH`变量。让我们看看如何在shell脚本中使用变量。我们将使用我们的`hello-world-improved.sh`脚本，而不是直接使用`Hello
    world`文本，我们将首先将其放入一个变量中并引用它：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First, we copy the `hello-world-improved.sh` script from the `chapter_07` directory
    into the newly created `chapter_08` directory, with the name `hello-world-variable.sh`.
    Then, we use `vim` to edit it. Give it the following contents:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`hello-world-improved.sh`脚本从`chapter_07`目录复制到新创建的`chapter_08`目录中，并命名为`hello-world-variable.sh`。然后，我们使用`vim`进行编辑。给它以下内容：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Congratulations, you've just used your first variable in a script! As you can
    see, you can use the content of a variable by wrapping its name inside the `${...}`
    syntax. Technically, just putting `$` in front of the name is enough (for example,
    `echo $hello_text`). However, in that situation, it is hard to differentiate where
    the variable name ends and the rest of the program begins—if you use the variable
    in the middle of a sentence, for example (or, even better, in the middle of a
    word!). If you use `${..}`, it's clear that the variable name ends at `}`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您刚刚在脚本中使用了您的第一个变量！正如您所看到的，您可以通过在`${...}`语法中包装其名称来使用变量的内容。从技术上讲，只需在名称前面放置`$`就足够了（例如，`echo
    $hello_text`）。但是，在那种情况下，很难区分变量名称何时结束以及程序的其余部分开始——例如，如果您在句子中间使用变量（或者更好的是，在单词中间！）。如果使用`${..}`，那么变量名称在`}`处结束是清晰的。
- en: 'At runtime, the variable we defined will be replaced with the actual content
    instead of the variable name: this process is called *variable interpolation*
    and is used in all scripting/programming languages. We''ll never see or directly
    use the value of a variable within a script, since in most cases the value is
    dependent on runtime configurations.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，我们定义的变量将被实际内容替换，而不是变量名称：这个过程称为*变量插值*，并且在所有脚本/编程语言中都会使用。我们永远不会在脚本中看到或直接使用变量的值，因为在大多数情况下，值取决于运行时配置。
- en: You will also see that we edited the information in the header. While it's easy
    to forget it, if a header does not contain correct information, you reduce readability.
    Always make sure you have an up-to-date header!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将看到我们编辑了头部中的信息。虽然很容易忘记，但如果头部不包含正确的信息，就会降低可读性。请务必确保您的头部是最新的！
- en: If we further dissect the script, you can see the `hello_text` variable is the
    first functional line after the header. We call this **assigning a value to a
    variable**. In some programming/scripting languages, you first have to *declare*
    a variable before you can *assign* it (most of the time, these languages have
    shorthand in which you can declare and assign as a single action).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们进一步解剖这个脚本，你会看到`hello_text`变量是标题之后的第一行功能性代码。我们称这个为**给变量赋值**。在一些编程/脚本语言中，你首先必须在*分配*之前*声明*一个变量（大多数情况下，这些语言有简写形式，你可以一次性声明和分配）。
- en: The need for declaration comes from the fact that some languages are *statically
    typed* (the variable type—for example, string or integer—should be declared before
    a value is assigned, and the compiler will check that you're doing it correctly—for
    example, not assigning a string to an integer typed variable), while other languages
    are *dynamically typed*. For dynamically typed languages, the language just assumes
    the type of the variable from what is assigned to it. If it is assigned a number,
    it will be an integer; if it is assigned text, it will be a string, and so on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 声明的需要来自于一些语言是*静态类型*的事实（变量类型——例如字符串或整数——应该在分配值之前声明，并且编译器将检查你是否正确地进行了赋值——例如不将字符串赋值给整数类型的变量），而其他语言是*动态类型*的。对于动态类型的语言，语言只是假定变量的类型是从分配给它的内容中得到的。如果它被分配了一个数字，它将是一个整数；如果它被分配了文本，它将是一个字符串，依此类推。
- en: Basically, variables can be **assigned** a value, **declared**, or **initialized**.
    While, technically, these are different things, you will often see the terms being
    used interchangeably. Do not get too hung up on this; the most important thing
    to remember is you're *creating the variable and its content*!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，变量可以被**赋值**一个值，**声明**或**初始化**。尽管从技术上讲，这些是不同的事情，但你经常会看到这些术语被互换使用。不要太过纠结于此；最重要的是记住你正在*创建变量及其内容*！
- en: 'Bash does not *really* follow either approach. Bash''s simple variables (excluding
    arrays, which we will explain later) are always considered strings, unless the
    operation explicitly specifies that we should be doing arithmetic. Look at the
    following script and result (we omitted the header for brevity):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Bash并没有真正遵循任何一种方法。Bash的简单变量（不包括数组，我们稍后会解释）始终被视为字符串，除非操作明确指定我们应该进行算术运算。看一下下面的脚本和结果（我们为了简洁起见省略了标题）：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You might have expected that we would get the number 2 printed. However, as
    stated, Bash considers everything a string; it just prints the value of the variable,
    followed by the space, the plus sign, another space, and the number 1\. If we
    want to have the actual arithmetic performed, we need a specialized syntax so
    that Bash knows that it is dealing with numbers:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期望我们打印出数字2。然而，正如所述，Bash认为一切都是字符串；它只是打印出变量的值，然后是空格、加号、另一个空格和数字1。如果我们想要进行实际的算术运算，我们需要一种专门的语法，以便Bash知道它正在处理数字：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By including the `variable + 1` inside `$((...))`, we tell Bash to evaluate
    it as arithmetic.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`$((...))`中包含`variable + 1`，我们告诉Bash将其作为算术表达式进行评估。
- en: Why do we need variables?
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么需要变量？
- en: 'Hopefully, you understand how to use variables now. However, you might not
    yet grasp why we would *want* or *need* to use variables. It might just seem like
    extra work for a small payoff, right? Consider the next example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你现在明白了如何使用变量。然而，你可能还没有完全理解为什么我们会*想要*或*需要*使用变量。这可能只是为了小小的回报而额外工作，对吧？考虑下一个例子：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, we used the `name` variable not once, but three times. If we
    did not have the variable in place, and we needed to edit the name, we would need
    to search for every place in the text that the name was used.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们不止一次使用了`name`变量，而是三次。如果我们没有这个变量，而我们需要编辑这个名字，我们就需要在文本中搜索每个使用了这个名字的地方。
- en: 'Furthermore, if we made a spelling mistake in one of the places, writing *Sebastian*
    instead of *Sebastiaan* (which, if you''re interested, happens *a lot*), both
    reading the text and editing it would take much more effort. Moreover, this was
    a simple example: often, variables are used many times (many more than three times
    at least).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们在某个地方拼写错误，写成*Sebastian*而不是*Sebastiaan*（如果你感兴趣，这种情况*经常*发生），那么阅读文本和编辑文本都需要更多的努力。此外，这只是一个简单的例子：通常，变量会被多次使用（至少比三次多得多）。
- en: Furthermore, variables are often used to store the *state* of a program. For
    a Bash script, you could imagine creating a temporary directory in which you'll
    perform some operations. We can store the location of this temporary directory
    in a variable, and anything we need to do in the temporary directory will make
    use of the variable to find the location. After the program finishes, the temporary
    directory should be cleaned up and the variable will no longer be needed. For
    every run of the program, the temporary directory will be named differently, so
    the content of the variable will be different, or *variable*, as well.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，变量通常用于存储程序的*状态*。对于Bash脚本，你可以想象创建一个临时目录，在其中执行一些操作。我们可以将这个临时目录的位置存储在一个变量中，任何需要在临时目录中进行的操作都将使用这个变量来找到位置。程序完成后，临时目录应该被清理，变量也将不再需要。对于每次运行程序，临时目录的名称将不同，因此变量的内容也将不同，或者*可变*。
- en: Another advantage of variables is that they have a name. Because of this, if
    we create a descriptive name, we can make the application easier to read and easier
    to use. We've determined that readability is always a must-have for shell scripting,
    and the use of properly named variables helps us with this.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的另一个优点是它们有一个名称。因此，如果我们创建一个描述性的名称，我们可以使应用程序更容易阅读和使用。我们已经确定可读性对于shell脚本来说总是必不可少的，而使用适当命名的变量可以帮助我们实现这一点。
- en: Variables or constants?
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量还是常量？
- en: In the examples up to now, we have actually used variables as **constants**.
    The term variable implies that it can change, whereas our examples have always
    assigned a variable at the start of the script, and used it throughout. While
    that has merits of its own (as stated before, for consistency or easier editing),
    it does not yet utilize the full power of variables.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的例子中，我们实际上使用的是**常量**作为变量。变量这个术语意味着它可以改变，而我们的例子总是在脚本开始时分配一个变量，并在整个过程中使用它。虽然这有其优点（如前面所述，为了一致性或更容易编辑），但它还没有充分利用变量的全部功能。
- en: A constant is a variable, but a special type. Simply put, a constant is *a variable
    defined at the start of the script that is not affected by user input and does
    not change value during execution.*
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 常量是变量，但是一种特殊类型。简单来说，常量是*在脚本开始时定义的变量，不受用户输入的影响，在执行过程中不改变值*。
- en: Later in this chapter, when we discuss dealing with user input, we'll see true
    variables. There, the content of the variables is supplied by the caller of the
    script, which means the output of the script will be different, or *varied*, each
    time the script is called. Later in the book, when we describe conditional testing,
    we will even change the value of a variable during the script itself, according
    to logic in that same script.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，当我们讨论处理用户输入时，我们将看到真正的变量。在那里，变量的内容由脚本的调用者提供，这意味着脚本的输出每次调用时都会不同，或者*多样化*。在本书后面，当我们描述条件测试时，我们甚至会根据脚本本身的逻辑在脚本执行过程中改变变量的值。
- en: Variable naming
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量命名
- en: 'On to the subject of naming. You might have noticed something about the variables
    we''ve seen up to now: the Bash variables `PATH` and `BASH_VERSION` are written
    fully uppercase, but in our examples we used lowercase, with words separated by
    an underscore (`hello_text`). Consider the following example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是命名的问题。你可能已经注意到到目前为止我们看到的变量有些什么：Bash变量`PATH`和`BASH_VERSION`都是完全大写的，但在我们的例子中，我们使用小写，用下划线分隔单词（`hello_text`）。考虑以下例子：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we run this, we get a nice little story:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个，我们会得到一个不错的小故事：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, our variables are working great! Technically, everything we did in this
    example was fine. However, they look a mess. We used four different naming conventions:
    lowercase_with_underscores, UPPERCASE, _lowercase, and finally camelCase. While
    these are technically valid, remember that readability counts: it''s best to pick
    one way of naming your variables, and stick with this.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的变量运行得很好！从技术上讲，我们在这个例子中所做的一切都是正确的。然而，它们看起来很混乱。我们使用了四种不同的命名约定：用下划线分隔的小写、大写、_小写，最后是驼峰命名法。虽然这些在技术上是有效的，但要记住可读性很重要：最好选择一种命名变量的方式，并坚持下去。
- en: 'As you might expect, there are many opinions about this (probably as many as
    in the tabs versus spaces debate!). Obviously, we also have an opinion, which
    we would like to share: use **lowercase_separated_by_underscores** for regular
    variables, and **UPPERCASE** for constants. From now on, you''ll see this practice
    in all further scripts.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的，对此有很多不同的意见（可能和制表符与空格的辩论一样多！）。显然，我们也有自己的意见，我们想要分享：对于普通变量，使用**用下划线分隔的小写**，对于常量使用**大写**。从现在开始，你将在所有后续脚本中看到这种做法。
- en: 'The previous example would look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子会是这样的：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We hope you agree this looks *much better*. Later in this chapter, when we introduce
    user input, we will be working with normal variables as well, as opposed to the
    constants we've been using so far.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你同意这看起来*好多了*。在本章后面，当我们介绍用户输入时，我们将使用普通变量，而不是到目前为止一直在使用的常量。
- en: 'Whatever you decide upon when naming your variables, there is only one thing
    in the end that really matters: consistency. Whether you prefer lowercase, camelCase,
    or UPPERCASE, it has no impact on the script itself (except for certain readability
    pros and cons, as discussed). However, using multiple naming conventions at the
    same time greatly confuses things. Always make sure to pick a convention wisely,
    and then **stick to it!**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你在命名变量时决定了什么，最终只有一件事情真正重要：一致性。无论你喜欢小写、驼峰命名法还是大写，它对脚本本身没有影响（除了某些可读性的利弊，如前所述）。然而，同时使用多种命名约定会极大地混淆事情。一定要确保明智地选择一个约定，然后**坚持下去！**
- en: 'To keep things clean, we generally avoid using UPPERCASE variables, except
    for constants. The main reason for this is that (almost) all *environment variables*
    in Bash are written in uppercase. If you do use uppercase variables in your scripts,
    there is one important thing to keep in mind: **make sure the names you choose
    do not conflict with pre-existing Bash variables**. These include `PATH`, `USER`,
    `LANG`, `SHELL`, `HOME`, and so on. Should you use the same names in your script,
    you might get some unexpected behavior.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持清洁，我们通常避免使用大写变量，除了常量。这样做的主要原因是（几乎）Bash中的所有*环境变量*都是用大写字母写的。如果你在脚本中使用大写变量，有一件重要的事情要记住：**确保你选择的名称不会与预先存在的Bash变量发生冲突**。这些包括`PATH`、`USER`、`LANG`、`SHELL`、`HOME`等等。如果你在脚本中使用相同的名称，可能会得到一些意想不到的行为。
- en: It is a much better idea to avoid these conflicts and choose unique names for
    your variables. You could, for example, choose the `SCRIPT_PATH` variable instead
    of `PATH`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最好避免这些冲突，并为你的变量选择唯一的名称。例如，你可以选择`SCRIPT_PATH`变量，而不是`PATH`。
- en: Dealing with user input
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户输入
- en: 'So far, we''ve been dealing with really static scripts. While it''s fun to
    have a story available for everyone to print out, it hardly qualifies as a functional
    shell script. At the very least, it''s not something you are going to use often!
    So, we''d like to introduce a very important concept in shell scripting: **user
    input**.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理非常静态的脚本。虽然为每个人准备一个可打印的故事很有趣，但它几乎不能算作一个功能性的shell脚本。至少，你不会经常使用它！因此，我们想要介绍shell脚本中非常重要的一个概念：**用户输入**。
- en: Basic input
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本输入
- en: 'At a very basic level, everything that you put on the command line right after
    calling the script can be used as input. However, it is up to the script to use
    it! For example, consider the following situation:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常基本的层面上，调用脚本后在命令行上输入的所有内容都可以作为输入使用。然而，这取决于脚本如何使用它！例如，考虑以下情况：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we called `name.sh` the first time, we used the originally intended functionality.
    The second time we called it, we supplied an extra argument: `Sanne`. However,
    because the script does not parse user input at all, the output we saw was exactly
    the same.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次调用`name.sh`时，我们使用了最初预期的功能。第二次调用时，我们提供了额外的参数：`Sanne`。然而，因为脚本根本不解析用户输入，我们看到的输出完全相同。
- en: 'Let''s revise the `name.sh` script so that it actually uses the extra input
    we specify when calling the script:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改`name.sh`脚本，以便在调用脚本时实际使用我们指定的额外输入：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, that looks much better! The script now accepts user input; specifically,
    the name of the person. It does this by using the `$1` construct: this is the
    *first positional argument*. We call these arguments positional because the position
    matters: the first one will always be written to `$1`, the second to `$2`, and
    so on. There is no way for us to swap these around. Only once we start looking
    into making our script compatible with flags will we get more flexibility. If
    we provide even more arguments to the script, we can grab them using `$3`, `$4`,
    and so on.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来好多了！脚本现在接受用户输入；具体来说，是人的名字。它通过使用`$1`构造来实现这一点：这是*第一个位置参数*。我们称这些参数为位置参数，因为位置很重要：第一个参数将始终被写入`$1`，第二个参数将被写入`$2`，依此类推。我们无法交换它们。只有当我们开始考虑使我们的脚本与标志兼容时，我们才会获得更多的灵活性。如果我们向脚本提供更多的参数，我们可以使用`$3`、`$4`等来获取它们。
- en: There is a limit to the number of arguments you can provide. However, it is
    sufficiently high that you never have to really worry about it. If you get to
    that point, your script will be unwieldy enough that no one will ever use it anyway!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以提供的参数数量是有限制的。然而，这个限制足够高，以至于你永远不必真正担心它。如果你达到了这一点，你的脚本将变得非常笨重，以至于没有人会使用它！
- en: 'You might want to pass a sentence to a Bash script, as **one** argument. In
    this case, you need to enclose the entire sentence in single or double quotes
    if you want to have it interpreted as a *single positional argument*. If you do
    not, Bash will consider each space in your sentence the delimiter between the
    arguments; passing the sentence **This Is Cool** will result in three arguments
    to the script: This, Is, and Cool.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想将一个句子作为**一个**参数传递给一个Bash脚本。在这种情况下，如果你希望将其解释为*单个位置参数*，你需要用单引号或双引号将整个句子括起来。如果不这样做，Bash将认为句子中的每个空格是参数之间的分隔符；传递句子**This
    Is Cool**将导致脚本有三个参数：This、Is和Cool。
- en: 'Notice how, again, we updated the header to include the new input under *Usage*.
    Functionally, however, the script isn''t that great; we used male pronouns with
    a female name! Let''s fix that real quick and find out what happens if we now
    *omit the user input*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们再次更新了标题，包括*Usage*下的新输入。然而，从功能上讲，脚本并不是那么好；我们用男性代词来指代一个女性名字！让我们快速修复一下，看看如果我们现在*省略用户输入*会发生什么：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, we've made the text a little more unisex. However, when we called the script
    without providing a name as an argument, we messed up the output. In the next
    chapter we'll dive deeper into error checking and input validation, but for now
    remember that Bash **will not provide an error if variables are missing/empty**;
    you are fully responsible for handling this. We will discuss this further in the
    next chapter, as this is another very important topic in shell scripting.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经使文本更加中性化。然而，当我们在没有提供名字作为参数的情况下调用脚本时，我们搞砸了输出。在下一章中，我们将更深入地讨论错误检查和输入验证，但现在请记住，如果变量缺失/为空，Bash**不会提供错误**；你完全有责任处理这个问题。我们将在下一章中进一步讨论这个问题，因为这是Shell脚本中的另一个非常重要的主题。
- en: Parameters and arguments
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数和参数
- en: We need to take a small step back and discuss some terminology—parameters and
    arguments. It's not terribly complicated, but it can be a bit confusing, and they
    are sometimes used incorrectly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要退一步，讨论一些术语——参数和参数。这并不是非常复杂，但可能有点令人困惑，有时会被错误使用。
- en: 'Basically, an argument is something you pass to a script*.* What you define
    in the script is considered the parameter*.* Look at the following example to
    see how this works:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，参数是你传递给脚本的东西。在脚本中定义的内容被视为参数。看看下面的例子，看看它是如何工作的：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Variables we use in this manner are called parameters inside the scripts, but
    are referred to as arguments when passing them to the script. In our `name-improved.sh`
    script, the parameter is the `name` variable. This is static and bound to the
    script version. The argument, however, is different each time the script is run:
    it can be `Sebastiaan`, or `Sanne`, or any other name.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在脚本中以这种方式使用的变量称为参数，但在传递给脚本时被称为参数。在我们的`name-improved.sh`脚本中，参数是`name`变量。这是静态的，与脚本版本绑定。然而，参数每次脚本运行时都不同：可以是`Sebastiaan`，也可以是`Sanne`，或者其他任何名字。
- en: Remember, when we are talking about an argument, you can read that as a *runtime
    argument*; something that can be different each run. If we're talking about a
    parameter of the script, we're referring to the static piece of information expected
    by a script (which is often provided by a runtime argument, or some logic in the
    script).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们谈论参数时，你可以将其视为*运行时参数*；每次运行都可能不同的东西。如果我们谈论脚本的参数，我们指的是脚本期望的静态信息（通常由运行时参数提供，或者脚本中的一些逻辑提供）。
- en: Interactive versus non-interactive scripts
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式与非交互式脚本
- en: The script we have created so far uses user input, but it can't really be called
    interactive. As soon as the script is fired off, with or without arguments to
    the parameters, the script runs and completes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的脚本使用了用户输入，但实际上并不能称之为交互式。一旦脚本启动，无论是否有参数传递给参数，脚本都会运行并完成。
- en: But what if we do not want to use a long list of arguments, instead prompting
    the user for the information that is needed?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们不想使用一长串参数，而是提示用户提供所需的信息呢？
- en: 'Enter the `read` command. The basic usage of `read` looks at input from the
    command line, and stores it in the `REPLY` variable. Try it out yourself:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`read`命令。`read`的基本用法是查看来自命令行的输入，并将其存储在`REPLY`变量中。自己试一试：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After you start the `read` command, your terminal will go down a line and allow
    you to type anything you want. As soon as you hit *Enter* (or, actually, until
    Bash encounters the *newline* key), the input will be saved into the `REPLY` variable.
    You can then echo this variable to verify it has actually stored your text.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动`read`命令后，您的终端将换行并允许您输入任何内容。一旦您按下*Enter*（或者实际上，直到Bash遇到*换行*键），输入将保存到`REPLY`变量中。然后，您可以echo此变量以验证它是否实际存储了您的文本。
- en: '`read` has a few interesting flags which make it more usable in shell scripting.
    We can use the `-p` flag with an argument (the text to display, surrounded by
    quotes) to present the user with a prompt, and we can supply the name of the variable
    in which we want to store the response as the last argument:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`有一些有趣的标志，使其在shell脚本中更易用。我们可以使用`-p`标志和一个参数（用引号括起来的要显示的文本）来向用户显示提示，并且我们可以将要存储响应的变量的名称作为最后一个参数提供：'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous example, we first used `read -p` without specifying a variable
    where we want to save our response. In this case, `read`'s default behavior places
    it in the `REPLY` variable. A line later, we ended the `read` command with the
    text `day_of_week`. In this case, the full response is saved into a variable with
    this name, as can be seen in the `echo ${day_of_week}` right after.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们首先使用了`read -p`，而没有指定要保存响应的变量。在这种情况下，`read`的默认行为将其放在`REPLY`变量中。一行后，我们用`day_of_week`结束了`read`命令。在这种情况下，完整的响应保存在一个名为此名称的变量中，如紧随其后的`echo
    ${day_of_week}`中所示。
- en: 'Let''s use `read` in an actual script now. We''ll first create the script using
    `read`, and then using positional arguments as we have up to now:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在实际脚本中使用`read`。我们将首先使用`read`创建脚本，然后使用到目前为止使用的位置参数：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That worked out pretty well. The user could just call the script without looking
    at how to use it, and is further prompted for information. Now, let''s copy and
    edit this script and use positional arguments to supply the information:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做得相当不错。用户只需调用脚本，而无需查看如何使用它，并且进一步提示提供信息。现在，让我们复制和编辑此脚本，并使用位置参数提供信息：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First, we copied the `interactive.sh` script to `interactive-arguments.sh`.
    We edited this script to no longer use `read`, but instead to grab the values
    from the arguments passed to the script. We edited the header with *the new name
    and the new usage*, and we ran it by supplying another set of arguments. Once
    again, we were presented with a nice little story.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`interactive.sh`脚本复制到`interactive-arguments.sh`。我们编辑了此脚本，不再使用`read`，而是从传递给脚本的参数中获取值。我们编辑了标题，使用*新名称和新用法*，并通过提供另一组参数来运行它。再次，我们看到了一个不错的小故事。
- en: 'So, you might be wondering, when should you use which method? Both methods
    ended with the same result. However, as far as we''re concerned, both scripts
    aren''t equally readable or simple to use. Look at the following table for pros
    and cons for each method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可能会想知道，何时应该使用哪种方法？两种方法最终都得到了相同的结果。但就我们而言，这两个脚本都不够可读或简单易用。请查看以下表格，了解每种方法的优缺点：
- en: '|  | **Pros** | **Cons** |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|  | **优点** | **缺点** |'
- en: '| Read |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 读取 |'
- en: User does not need to be aware of arguments to supply; they can just run the
    script and be prompted for any information needed
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户无需了解要提供的参数；他们只需运行脚本，并提示提供所需的任何信息
- en: It is not possibly to forget to supply information
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可能忘记提供信息
- en: '|'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: If you want to repeat the script multiple times, you need to type the responses
    every time
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要多次重复运行脚本，则需要每次输入响应
- en: Cannot be run non-interactively; for example, in a scheduled job
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法以非交互方式运行；例如，在计划任务中
- en: '|'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Arguments |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 参数 |'
- en: Can be repeated easily
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以轻松重复
- en: Can be run non-interactively as well
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 也可以以非交互方式运行
- en: '|'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: User needs to be aware of arguments to supply **before** attempting to run the
    script
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户需要在尝试运行脚本**之前**了解要提供的参数
- en: It is much easier to forget to supply part of the information needed
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很容易忘记提供所需的部分信息
- en: '|'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Basically, the pros for one method are the cons for the other, and vice-versa.
    It seems as though we can't win by using either method. So, how would we create
    a robust interactive script that we can also run non-interactively?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，一种方法的优点是另一种方法的缺点，反之亦然。似乎我们无法通过使用任一方法来取胜。那么，我们如何创建一个健壮的交互式脚本，也可以以非交互方式运行呢？
- en: Combining positional arguments and read
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合位置参数和read
- en: By combining both methods, of course! Before we start executing the actual functionality
    of the script, we need to verify whether  all necessary information has been supplied.
    If it has not, we can then prompt the user for the missing information.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合两种方法，当然可以！在我们开始执行脚本的实际功能之前，我们需要验证是否已提供了所有必要的信息。如果没有，我们可以提示用户提供缺失的信息。
- en: We're going to look ahead slightly to [Chapter 11](05e9179f-31c1-4f5f-903a-5a6b9f2c80d5.xhtml),
    *Conditional Testing and Scripting Loops*, and explain the basic use of `if-then`
    logic. We'll combine this with the `test` command, which we can use to check if
    a variable contains a value or is empty. *If* that is the case, *then* we can
    prompt the user with `read` to supply the missing information.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将稍微提前查看[第11章](05e9179f-31c1-4f5f-903a-5a6b9f2c80d5.xhtml)，*条件测试和脚本循环*，并解释`if-then`逻辑的基本用法。我们将结合`test`命令，该命令可用于检查变量是否包含值或为空。*如果*是这种情况，*那么*我们可以使用`read`提示用户提供缺失的信息。
- en: At its heart, `if-then` logic is nothing more than saying `if <something>, then
    do <something>`. In our example, `if` the variable of `character_name` is empty,
    `then` use `read` to prompt for this information. We'll do this for all three
    parameters in our script.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，`if-then`逻辑只不过是说`if <某事>，then 做 <某事>`。在我们的例子中，`if`角色名的变量为空，`then`使用`read`提示输入这个信息。我们将在我们的脚本中为所有三个参数执行此操作。
- en: Because the arguments we're supplying are positional, we cannot supply the first
    and the third only; the script would interpret that as the first and second argument,
    with a missing third argument. With our current knowledge, we're limited by this.
    In [Chapter 15](fe4b95bc-7c5e-4602-a102-a46e1c4934dc.xhtml), *Parsing Bash Script
    Arguments with getopts*, we'll explore how to supply information using flags.
    In this case, we can supply all information separately, without worrying about
    the order. For now, however, we'll have to live with the limitation!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们提供的参数是位置参数，我们不能只提供第一个和第三个参数；脚本会将其解释为第一个和第二个参数，第三个参数缺失。根据我们目前的知识，我们受到了这个限制。在[第15章](fe4b95bc-7c5e-4602-a102-a46e1c4934dc.xhtml)中，*使用getopts解析Bash脚本参数*，我们将探讨如何使用标志提供信息。在这种情况下，我们可以分别提供所有信息，而不必担心顺序。然而，现在我们只能接受这种限制！
- en: Before we can explain the `test` command, we need to go back a little bit and
    explain **exit codes**. Basically, every program that runs and exits returns a
    code to the parent process that originally started it. Normally, if a process
    is done and execution was successful, it exits with **code 0**. If execution of
    the program was not successful, it exits with *any other code*; however, this
    is usually **code 1**. While there are conventions for exit codes, often you will
    just encounter 0 for good exits and 1 for bad exits.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解释`test`命令之前，我们需要回顾一下**退出代码**。基本上，每个运行并退出的程序都会返回一个代码给最初启动它的父进程。通常，如果一个进程完成并且执行成功，它会以**代码0**退出。如果程序的执行不成功，它会以*任何其他代码*退出；然而，这通常是**代码1**。虽然有关于退出代码的约定，通常你会遇到0表示良好退出，1表示不良退出。
- en: 'When we use the `test` command, it generates exit codes conforming to the guidelines
    as well: if the test is successful, we see exit code 0\. If it is not, we see
    another code (probably 1). You can see the exit code of the previous command with
    the `echo $?` command.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`test`命令时，它也会生成符合指南的退出代码：如果测试成功，我们会看到退出代码0。如果不成功，我们会看到另一个代码（可能是1）。你可以使用`echo
    $?`命令查看上一个命令的退出代码。
- en: 'Let''s look at an example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A lot happened in the previous example. First, we tried to create a directory
    that was already present. Since we can't have two directories with the same name
    (in the same location), the `mkdir` command failed. When we printed the exit code
    using `$?`, we were returned `1`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中发生了很多事情。首先，我们试图创建一个已经存在的目录。由于在同一位置不能有两个同名目录，所以`mkdir`命令失败了。当我们使用`$?`打印退出代码时，返回了`1`。
- en: 'Moving on, we successfully created a new directory, `testdir`. When we printed
    the exit code after that command, we saw the number for success: `0`. After successfully
    removing the empty `testdir`, we saw an exit code of `0` again. When we tried
    to remove the not-empty `scripts` directory with `rmdir` (which isn''t allowed),
    we got an error message and saw that the exit code was again `1`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们成功创建了一个新目录`testdir`。在执行该命令后，我们打印了退出代码，看到了成功的数字：`0`。成功删除空的`testdir`后，我们再次看到了退出代码`0`。当我们尝试使用`rmdir`删除非空的`scripts`目录（这是不允许的）时，我们收到了一个错误消息，并看到退出代码再次是`1`。
- en: 'Let''s get back to `test`. What we need to do is verify whether a variable
    is empty. If it is, we want to start a `read` prompt to have it filled by user
    input. First we''ll try this on the `${PATH}` variable (which will never be empty),
    and then on the `empty_variable`, which will be indeed empty. To test whether
    a variable is empty, we use `test -z <variable name>`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`test`。我们需要做的是验证一个变量是否为空。如果是，我们希望启动一个`read`提示，让用户输入。首先我们将在`${PATH}`变量上尝试这个（它永远不会为空），然后在`empty_variable`上尝试（它确实为空）。要测试一个变量是否为空，我们使用`test
    -z <变量名>`：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: While this might seem like the wrong way around at first, think about it. We're
    testing whether a variable **is empty**. Since `$PATH` is not empty, the test
    fails and produces an exit code of 1\. For `${empty_variable}` (which we have
    never created), we are sure it is indeed empty, and an exit code of 0 confirms
    this.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这乍看起来似乎是错误的，但想一想。我们正在测试一个变量是否**为空**。由于`$PATH`不为空，测试失败并产生了退出代码1。对于`${empty_variable}`（我们从未创建过），我们确信它确实为空，退出代码0证实了这一点。
- en: If we want to combine the Bash `if` with `test`, we need to know that `if` expects
    a test that ends in an exit code of 0\. So, if the test is successful, we can
    do something. This fits our example perfectly, since we're testing for empty variables.
    If you wanted to test it the other way around, you'd need to test for a non-zero
    length variable, which is the `-n` flag for `test`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将Bash的`if`与`test`结合起来，我们需要知道`if`期望一个以退出代码0结束的测试。因此，如果测试成功，我们可以做一些事情。这与我们的例子完全吻合，因为我们正在测试空变量。如果你想测试另一种情况，你需要测试一个非零长度的变量，这是`test`的`-n`标志。
- en: 'Let''s look at the `if` syntax first. In essence, it looks like this: `if <exit
    code 0>; then <do something>; fi`. You can choose to have this on multiple lines,
    but using ; on a line terminates it as well. Let''s see whether we can manipulate
    this for our needs:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看一下`if`语法。实质上，它看起来像这样：`if <退出代码0>; then <做某事>; fi`。你可以选择将其放在多行上，但在一行上使用;也会终止它。让我们看看我们是否可以为我们的需求进行操作：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'First, we used our constructed `if-then` clause on the `PATH` variable. Since
    it is not empty, we did not expect a prompt: a good thing we did not get one!
    We used the same construct, but now with the `empty_variable`. Behold, since the
    `test -z` returned exit code 0, the `then` part of the `if-then` clause was executed
    and prompted us for a value. After inputting the value, we could echo it out.
    Running the `if-then` clause again did not give us the `read` prompt, because
    at that point the variable `empty_variable` was no longer empty!'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在“PATH”变量上使用了我们构建的“if-then”子句。由于它不是空的，我们不希望出现提示：幸好我们没有得到！我们使用了相同的结构，但现在是使用“empty_variable”。看哪，由于“test
    -z”返回了退出码0，所以“if-then”子句的“then”部分被执行，并提示我们输入一个值。在输入值之后，我们可以将其输出。再次运行“if-then”子句不会给我们“read”提示，因为此时变量“empty_variable”不再为空！
- en: 'Finally, let''s incorporate this `if-then` logic into our `new interactive-ultimate.sh`
    script:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将这种“if-then”逻辑融入到我们的“new interactive-ultimate.sh”脚本中：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Success! We were prompted for `location` and `food`, but `character_name` was
    successfully resolved from the argument that we passed. We've created a script
    that we can use both fully interactive, without supplying arguments, but also
    non-interactive with arguments.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们被提示输入“location”和“food”，但“character_name”成功地从我们传递的参数中解析出来。我们创建了一个脚本，可以完全交互使用，而无需提供参数，但也可以使用参数进行非交互操作。
- en: While this script is informative, it is not really efficient. It would be better
    to combine the `test` looking directly at the passed arguments (`$1`, `$2`, `$3`),
    so we only need one line. Later on in the book, we will start using such optimizations,
    but for now it is more important to write things out in full, so you can more
    easily understand them!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个脚本很有信息量，但效率并不是很高。最好是将`test`直接与传递的参数（`$1`，`$2`，`$3`）结合起来，这样我们只需要一行。在本书的后面，我们将开始使用这样的优化，但现在更重要的是将事情写得详细一些，这样您就可以更容易地理解它们！
- en: Summary
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'At the start of this chapter, we explained what a variable was: a standard
    building block that allows us to store information, which we can reference later.
    We prefer to use variables for a number of reasons: we can store a value once
    and reference it multiple times, and if we need to change the value, we only have
    to change it once and the new value will be used everywhere.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始时，我们解释了什么是变量：它是一个标准的构建块，允许我们存储信息，以便以后引用。我们更喜欢使用变量有很多原因：我们可以存储一个值一次并多次引用它，如果需要更改值，我们只需更改一次，新值将在所有地方使用。
- en: 'We explained that a constant is a special type of variable: it is defined only
    once in the beginning of a script, it is not affected by user input, and it does
    not change during the course of the script execution.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解释了常量是一种特殊类型的变量：它只在脚本开始时定义一次，不受用户输入的影响，在脚本执行过程中不会改变。
- en: 'We continued with some notes on variable naming. We demonstrated that Bash
    is very flexible with regard to variables: it allows many different styles of
    variable naming. However, we explained that readability suffers if you use multiple
    different naming conventions in the same script, or between multiple scripts.
    The best idea is to choose one way of naming variables, and stick with it. We
    recommended using UPPERCASE for constants, and lowercase_separated_by_underscores
    for all other variables. This will lessen the chance of conflicts between local
    and environment variables.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续讨论了一些关于变量命名的注意事项。我们演示了Bash在变量命名方面非常灵活：它允许许多不同风格的变量命名。但是，我们解释了如果在同一个脚本或多个脚本之间使用多种不同的命名约定，可读性会受到影响。最好的方法是选择一种变量命名方式，并坚持下去。我们建议使用大写字母表示常量，使用小写字母和下划线分隔其他变量。这将减少本地变量和环境变量之间冲突的机会。
- en: 'Next, we explored user input and how to deal with it. We gave users of our
    scripts the ability to alter the outcome of our scripts, a function that is almost
    mandatory for most real-life functional scripts. We described two different methods
    of user interaction: basic input using positional arguments, and interactive input
    using the `read` construct.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了用户输入以及如何处理它。我们赋予我们脚本的用户改变脚本结果的能力，这几乎是大多数现实生活中功能脚本的必备功能。我们描述了两种不同的用户交互方法：使用位置参数的基本输入，以及使用“read”构造的交互式输入。
- en: We ended the chapter with a brief introduction to if**–**then logic and the
    `test` command. We used these concepts to create a robust way to handle user input,
    combining positional arguments with a `read` prompt for missing information, after
    presenting the pros and cons of each method used alone. This created a script
    that could be used both interactively and non-interactively, depending on the
    use case.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章结束时简要介绍了if-then逻辑和`test`命令。我们使用这些概念创建了一种处理用户输入的强大方式，将位置参数与`read`提示结合起来处理缺少的信息，同时介绍了单独使用每种方法的利弊。这样创建了一个脚本，可以根据使用情况进行交互和非交互操作。
- en: The following commands were introduced in this chapter: `read`, `test`, and `if`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了以下命令：“read”、“test”和“if”。
- en: Questions
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a variable?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是变量？
- en: Why do we need variables?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么需要变量？
- en: What is a constant?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是常量？
- en: Why are naming conventions especially important for variables?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么变量的命名约定特别重要？
- en: What are positional arguments?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是位置参数？
- en: What is the difference between a parameter and an argument?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参数和参数之间有什么区别？
- en: How can we make a script interactive?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使脚本交互式？
- en: How can we create a script that we can use both non-interactively and interactively?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何创建一个既可以进行非交互操作又可以进行交互操作的脚本？
- en: Further reading
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following resources might be interesting if you''d like to go deeper into
    the subjects of this chapter:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更深入地了解本章主题，以下资源可能会很有趣：
- en: '**Bash variables**: [https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php](https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bash变量**：[https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php](https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php)'
- en: '**Google Shell Style Guide**: [https://google.github.io/styleguide/shell.xml](https://google.github.io/styleguide/shell.xml)'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌Shell风格指南：[https://google.github.io/styleguide/shell.xml](https://google.github.io/styleguide/shell.xml)
