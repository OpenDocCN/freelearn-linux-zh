- en: Using Pipes and Redirection in Scripts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在脚本中使用管道和重定向
- en: 'In this chapter, we''ll explain a very important aspect of Bash: *redirection*.
    We''ll start by describing the different types of input and output redirections,
    and how they are related to Linux file descriptors. After the basics of redirection
    are covered, we will continue with some advanced uses.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释Bash的一个非常重要的方面：*重定向*。我们将从描述不同类型的输入和输出重定向开始，以及它们如何与Linux文件描述符相关联。在涵盖了重定向的基础知识之后，我们将继续介绍一些高级用法。
- en: Next up are *pipes*, which is a concept used heavily within shell scripting.
    We present a few practical examples of pipes. Finally, we show how *here documents*
    work, which also have some great uses.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是*管道*，这是Shell脚本中广泛使用的一个概念。我们将介绍一些管道的实际示例。最后，我们将展示*here documents*的工作原理，这也有一些很好的用途。
- en: 'The following commands will be introduced in this chapter: `diff`, `gcc`, `fallocate`,
    `tr`, `chpasswd`, `tee`, and `bc`.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下命令：`diff`、`gcc`、`fallocate`、`tr`、`chpasswd`、`tee`和`bc`。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Input/output redirection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入/输出重定向
- en: Pipes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道
- en: Here documents
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Here documents
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All scripts for this chapter can be found on GitHub at the following link:
    [https://github.com/tammert/learn-linux-shell-scripting/tree/master/chapter_12](https://github.com/tammert/learn-linux-shell-scripting/tree/master/chapter_12).
    For all other exercises, your Ubuntu 18.04 virtual machine is still your best
    friend.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有脚本都可以在GitHub上找到，链接如下：[https://github.com/tammert/learn-linux-shell-scripting/tree/master/chapter_12](https://github.com/tammert/learn-linux-shell-scripting/tree/master/chapter_12)。对于所有其他练习，你的Ubuntu
    18.04虚拟机仍然是你最好的朋友。
- en: Input/output redirection
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入/输出重定向
- en: In this chapter, we will discuss redirection in Linux in detail.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细讨论Linux中的重定向。
- en: 'Simply put, redirection is pretty much exactly as the word implies: the redirecting
    of *something* to *something else*. For example, we''ve already seen that we can
    use the output of one command as the input for the next command, using pipes.
    Pipes are implemented in Linux using the `|` sign.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，重定向几乎完全就像字面意思一样：将*某物*重定向到*其他某物*。例如，我们已经看到我们可以使用一个命令的输出作为下一个命令的输入，使用管道。在Linux中，管道是使用`|`符号实现的。
- en: 'However, that might raise the question: how does Linux deal with input and
    output in the first place? We''ll begin our journey into redirection with some
    theory on **file descriptors**, which are what make all redirection possible!'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可能会引发一个问题：Linux如何处理输入和输出？我们将从一些关于**文件描述符**的理论开始我们的重定向之旅，这是使所有重定向成为可能的原因！
- en: File descriptors
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件描述符
- en: 'You might be tired of hearing it, but it is still no less true: in Linux, everything
    is a file. We''ve seen that a file is a file, a directory is a file, even hard
    disks are files; but now, we''ll take this one step further: your keyboard, which
    you use for *input*, is also a file!'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经厌倦了听到这一点，但它仍然是真的：在Linux中，一切都是一个文件。我们已经看到一个文件是一个文件，一个目录是一个文件，甚至硬盘也是文件；但现在，我们将再进一步：你用于*输入*的键盘也是一个文件！
- en: 'Complementary to that, your Terminal, which commands use as *output*, is, guess
    what: a file.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相辅相成的是，你的终端，命令使用它作为*输出*，猜猜看：就是一个文件。
- en: 'You can find these files, as with most special files, within your Linux filesystem
    tree. Let''s check our virtual machine:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Linux文件系统树中找到这些文件，就像大多数特殊文件一样。让我们检查一下我们的虚拟机：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Out of the four files we find here, three are important: `/dev/fd/0`, `/dev/fd/1`,
    and `/dev/fd/2`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里找到的四个文件中，有三个很重要：`/dev/fd/0`、`/dev/fd/1`和`/dev/fd/2`。
- en: 'As you might suspect from the heading of this text, **fd** stands for **f**ile
    **d**escriptor. These file descriptors are used internally to bind input and output
    from and to the user to a Terminal. You can actually see how this is done with
    the file descriptors: they are symbolically linked to `/dev/pts/0`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段文字的标题中，你可能会怀疑**fd**代表**f**ile **d**escriptor。这些文件描述符在内部用于将用户的输入和输出与终端绑定在一起。你实际上可以看到文件描述符是如何做到这一点的：它们被符号链接到`/dev/pts/0`。
- en: 'In this instance, **pts** stands for **pseudo Terminal slave**, which is the
    definition given to SSH connections. Look at what happens when we look at `/dev/fd`
    from three different locations:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**pts**代表**伪终端从属**，这是对SSH连接的定义。看看当我们从三个不同的位置查看`/dev/fd`时会发生什么：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each of these connections has their own `/dev/` mount (which is of `udev` type,
    stored in memory), which is why we do not see output from one connection into
    the other one.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每个连接都有自己的`/dev/`挂载（存储在内存中的`udev`类型），这就是为什么我们看不到一个连接的输出进入另一个连接的原因。
- en: 'Now, we''ve been talking about input and output. But, as you have no doubt
    seen, there are three file descriptors allocated in the preceding examples. In
    a Linux (or Unix/Unix-like system), there are three default **streams** which
    are exposed by default through file descriptors:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们一直在谈论输入和输出。但是，正如你无疑所见，前面的例子中分配了三个文件描述符。在Linux（或类Unix系统）中，默认通过文件描述符公开的三个默认**流**：
- en: The *standard input* stream, `stdin`, by default bound to `/dev/fd/0`
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标准输入*流`stdin`默认绑定到`/dev/fd/0`'
- en: The *standard output* stream, `stdout`, by default bound to `/dev/fd/1`
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标准输出*流`stdout`默认绑定到`/dev/fd/1`'
- en: The *standard error* stream, `stderr`, by default bound to `/dev/fd/2`
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*标准错误*流`stderr`默认绑定到`/dev/fd/2`'
- en: 'As far as these three streams go, `stdin` and `stdout` should be rather straightforward:
    input and output. However, as you might have deduced, output is actually split
    into *normal* output and *error* output. Normal output is sent to the `stdout`
    file descriptor, while error output is often sent to `stderr`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就这三个流而言，`stdin`和`stdout`应该相当直接：输入和输出。然而，正如你可能已经推断出的那样，输出实际上被分成*正常*输出和*错误*输出。正常输出被发送到`stdout`文件描述符，而错误输出通常被发送到`stderr`。
- en: Since both of these are symbolically linked to the Terminal, you will see them
    there no matter what. However, as we will see later on in this chapter, as soon
    as we start redirecting, this difference becomes important.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两者都是符号链接到终端，所以无论如何你都会在那里看到它们。然而，正如我们将在本章后面看到的，一旦我们开始重定向，这种差异就变得重要起来。
- en: You might see some other file descriptors, such as the 255 in the first example.
    Besides their use in supplying input and output to the Terminal, file descriptors
    are also used when Linux opens a file in the filesystem. This other use of file
    descriptors is outside of the scope for this book; we have, however, included
    a link in the *Further reading* section for those interested.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到一些其他文件描述符，比如第一个示例中的255。除了在终端提供输入和输出时使用它们，文件描述符还在Linux打开文件系统中的文件时使用。文件描述符的这种其他用途超出了本书的范围；然而，我们在*进一步阅读*部分包含了一个链接，供感兴趣的读者参考。
- en: 'In a normal interaction, text you type in a Terminal gets written to `stdin`
    on `/dev/fd/0`, which a command can read. Using that input, the command usually
    does something (otherwise, we wouldn''t need the command!) and writes the output
    to `stdout` or `stderr`. where it will be read by the Terminal for display to
    you. So in short:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常交互中，你在终端中输入的文本被写入到`/dev/fd/0`上的`stdin`，一个命令可以读取。使用该输入，命令通常会执行某些操作（否则，我们就不需要这个命令！）并将输出写入`stdout`或`stderr`。然后终端会读取这些输出并显示给你。简而言之：
- en: A *Terminal* **writes** to `stdin` and **reads** from `stdout` or `stderr`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*终端* **写入** `stdin`，**读取** `stdout`或`stderr`
- en: A *command* **reads** from `stdin` and **writes** to `stdout` or `stderr`
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*命令* **从** `stdin` **读取**，**写入** `stdout` 或 `stderr`
- en: Besides the file descriptors Linux uses internally, there are also a few file
    descriptors reserved for when you want to create really advanced scripts; these
    are 3 through 9\. Any others *might* be used by the system, but these are guaranteed
    free for your use. As this is, as stated, very advanced and not used too often,
    we will not go into detail. However, we've found some further reading which might
    be interesting, which is included at the end of this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Linux内部使用的文件描述符之外，还有一些保留用于创建真正高级脚本的文件描述符；这些是3到9。任何其他的*可能*被系统使用，但这些保证可以自由使用。正如所述，这是非常高级的，不太经常使用，我们不会详细介绍。然而，我们找到了一些可能有趣的进一步阅读材料，这些材料包含在本章的末尾。
- en: Redirecting output
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向输出
- en: Now that the theory on input, output, and file descriptors should be clear,
    we're going to see how we can use these techniques in our command-line and scripting
    adventures.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输入、输出和文件描述符的理论应该是清楚的，我们将看到如何在命令行和脚本冒险中使用这些技术。
- en: It is in fact pretty hard to write shell scripts without using redirection;
    we've actually used redirection a couple of times in the book before this chapter,
    because we really needed it to get our stuff done at that time (`file-create.sh`
    in [Chapter 8](41d3c327-f6d6-4ec5-8ec9-127e493bdd05.xhtml), *Variables and User
    Input*, for example).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在没有使用重定向的情况下编写shell脚本是相当困难的；在本章之前的书中，我们实际上已经使用了几次重定向，因为我们当时真的需要它来完成我们的工作（例如[第8章](41d3c327-f6d6-4ec5-8ec9-127e493bdd05.xhtml)中的`file-create.sh`，*变量和用户输入*）。
- en: Now, let's get some real experience with redirection out of the way!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们先来体验一下重定向！
- en: stdout
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: stdout
- en: 'Most output from commands will be *standard output*, written to `stdout` on
    `/dev/fd/1`. By using the `>` symbol, we can redirect this out with the following
    syntax:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数命令的输出将是*标准输出*，写入`/dev/fd/1`上的`stdout`。通过使用`>`符号，我们可以使用以下语法重定向输出：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A redirect will always be made to a file (however, as we know, not all files
    are equal, so after the regular examples, we'll show you some Bash magic where
    non-regular files are concerned). If the file does not exist, it will be created.
    If it does exist, it will be **overwritten**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向将始终指向一个文件（然而，正如我们所知，不是所有文件都是相等的，因此在常规示例之后，我们将向您展示一些Bash魔法，涉及非常规文件）。如果文件不存在，它将被创建。如果存在，它将被**覆盖**。
- en: 'In its simplest form, everything that would normally be printed to your Terminal
    can be redirected to a file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，通常会打印到终端的所有内容都可以重定向到文件：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you know, `cat` prints the whole file content to your Terminal. In reality,
    it actually sends the whole content to `stdout`, which is bound to `/dev/fd/1`,
    which is bound to your Terminal; this is why you see it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，`cat`将整个文件内容打印到你的终端。实际上，它实际上将整个内容发送到`stdout`，它绑定到`/dev/fd/1`，它绑定到你的终端；这就是为什么你看到它。
- en: 'Now, if we redirect the content of the file back to another file, we''ve essentially
    made a great effort to... copy a file! From the file sizes you can see that it
    is actually the same file. If you''re unsure, you can use the `diff` command to
    see if the files are the same:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们将文件的内容重定向回另一个文件，我们实际上已经做出了很大的努力...复制一个文件！从文件大小可以看出，实际上是相同的文件。如果你不确定，你可以使用`diff`命令来查看文件是否相同：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If `diff` does not return any output, and it has an exit code of `0`, there
    are no differences in the file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`diff`没有返回任何输出，并且它的退出代码为`0`，则文件没有差异。
- en: 'Back to the redirection example. We used `>` to redirect the output to the
    file. In reality, `>` is shorthand for `1>`. You might recognize this `1`: it
    refers to the file descriptor `/dev/fd/1`. As we''ll see when we''re dealing with
    `stderr`, which is on `/dev/fd/2`, we will use `2>` instead of `1>` or `>`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 回到重定向示例。我们使用`>`将输出重定向到文件。实际上，`>`是`1>`的简写。你可能会认出这个`1`：它指的是文件描述符`/dev/fd/1`。正如我们将在处理`stderr`时看到的，它位于`/dev/fd/2`上，我们将使用`2>`而不是`1>`或`>`。
- en: 'First, however, let''s build a simple script to illustrate this a little bit
    further:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们构建一个简单的脚本来进一步说明这一点：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, when we run this, `read` will prompt us to input some text. This will be
    saved in the `user_input` variable. Then, we'll use `echo` to send the content
    of the `user_input` variable to `stdout`. But, instead of it reaching the Terminal
    on `/dev/pts/0` via `/dev/fd/1`, we redirect it to the `redirect-to-file.txt` file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行这个脚本时，`read`会提示我们输入一些文本。这将保存在`user_input`变量中。然后，我们将使用`echo`将`user_input`变量的内容发送到`stdout`。但是，它不会通过`/dev/fd/1`到达终端上的`/dev/pts/0`，而是重定向到`redirect-to-file.txt`文件中。
- en: 'All in all, it looks something like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，它看起来像这样：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, this works as advertised. However, if we run it again, we see two things
    that can go wrong with this script:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个脚本按照预期工作。然而，如果我们再次运行它，我们会看到这个脚本可能出现的两个问题：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first thing that goes wrong, which we've warned about before, is that relative
    paths might mess up where the file is written.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一件出错的事情，正如我们之前警告过的，是相对路径可能会搞乱文件的写入位置。
- en: You might have envisioned that the file was created right next to the script;
    this will only happen if your *current working directory* is in the directory
    where the script is. Because we call it from lower in the tree, the output is
    written there (since that is the current working directory).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经设想到文件是在脚本旁边创建的；只有当你的*当前工作目录*在脚本所在的目录中时，才会发生这种情况。因为我们是从树的较低位置调用它，所以输出被写入那里（因为那是当前工作目录）。
- en: The other problem is that each time we type something in, we remove the old
    content of the file! After we type `Hello`, we see that the file is six bytes
    (one byte for each character, plus a newline), and after we typed `Bye`, we now
    see that the file is only four bytes (three characters plus the newline).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，每次我们输入内容时，都会删除文件的旧内容！在我们输入`Hello`后，我们看到文件有六个字节（每个字符一个字节，加上一个换行符），在我们输入`Bye`后，我们现在看到文件只有四个字节（三个字符加上换行符）。
- en: This might be the desired behavior, but more often than not it is much nicer
    if the output is *appended* to the file, instead of replacing it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是期望的行为，但更多时候，如果输出*追加*到文件中，而不是替换它，会更好。
- en: 'Let''s solve both issues in a new version of the script:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在脚本的新版本中解决这两个问题：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, if we run it (from wherever), we''ll see that new text gets appended to
    the first sentence, `I like dogs! And cats. Maybe a gecko?` in the `/home/reader/chapter_12/redirect-to-file.txt` file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行它（无论在哪里），我们会看到新的文本被追加到第一句话，“我喜欢狗！还有猫。也许是壁虎？”在`/home/reader/chapter_12/redirect-to-file.txt`文件中：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, `cd $(dirname $0)` helped us with our relative paths, and a `>>` instead
    of `>` ensured appending instead of overwriting. As you might expect, `>>` is
    again short for `1>>`, as we will see when we start redirecting `stderr` streams
    in a bit.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，`cd $(dirname $0)` 帮助我们处理相对路径，`>>` 而不是 `>` 确保追加而不是覆盖。正如你所期望的那样，`>>` 再次代表
    `1>>`，当我们开始稍后重定向 `stderr` 流时，我们会看到这一点。
- en: 'A little while back, we promised you some Bash magic. While not exactly magic,
    it might hurt your head just a little:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 不久前，我们向你承诺了一些Bash魔法。虽然不完全是魔法，但可能会让你的头有点疼：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, we've managed to print our file using `cat` a total of four times. We could
    have done that with `for` as well, you might be thinking, but the lesson is not
    the amount of times we printed the message, but how we did it!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们成功地使用`cat`四次打印了我们的文件。你可能会想，我们也可以用`for`来做，但是这个教训不是我们打印消息的次数，而是我们是如何做到的！
- en: First, we just used `cat`; nothing special there. Next, we used `cat` in combination
    with a redirection of `stdout` to `/dev/pts/0`, our Terminal. Again, the message
    is printed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们只是使用了`cat`；没有什么特别的。接下来，我们将`cat`与将`stdout`重定向到`/dev/pts/0`，也就是我们的终端，结合使用。同样，消息被打印出来。
- en: The third and fourth times, we sent the redirected `stdout` of `cat` to `/dev/fd/1`
    and `/dev/fd/2`. Since these are symlinked to `/dev/pts/0`, it's not really surprising
    that these also end up on our Terminal.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第三和第四次，我们将`cat`的重定向`stdout`发送到`/dev/fd/1`和`/dev/fd/2`。由于这些是符号链接到`/dev/pts/0`，这也不奇怪，这些也最终出现在我们的终端上。
- en: How then do we actually differentiate between `stdout` and `stderr`?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何实际区分 `stdout` 和 `stderr` 呢？
- en: stderr
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: stderr
- en: If you were confused by the preceding example, that was probably because you
    misunderstood the flow that `stderr` messages take (and we don't blame you, we
    confused ourselves there!). While we sent the output of the `cat` command to `/dev/fd/2`,
    we used `>`, which sends `stdout` and not `stderr`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对前面的例子感到困惑，那可能是因为你误解了`stderr`消息的流向（我们不怪你，我们自己也搞混了！）。虽然我们将`cat`命令的输出发送到`/dev/fd/2`，但我们使用了`>`，这会发送`stdout`而不是`stderr`。
- en: So in our example, we just abused the `stderr` file descriptor to print to the
    Terminal; bad practice. We promise not to do it again. Now then, how can we *actually*
    work with `stderr` messages?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的示例中，我们滥用了 `stderr` 文件描述符来打印到终端；这是不好的做法。我们保证不会再这样做了。那么，我们如何*实际*处理 `stderr`
    消息呢？
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This interaction should illustrate some things. First, when `cat /root/` throws
    a `Permission denied` error, it sends it to `stderr` instead of `stdout`. We can
    see this, because when we do the same command but we try to redirect the *standard*
    *output* with `1> error-file`, we still see the output *in the Terminal* and we
    also see that `error-file` is empty.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种交互应该说明一些事情。首先，当`cat /root/`抛出`Permission denied`错误时，它将其发送到`stderr`而不是`stdout`。我们可以看到这一点，因为当我们执行相同的命令，但尝试用`1>
    error-file`重定向*标准* *输出*时，我们仍然在终端上看到输出，并且我们还看到`error-file`是空的。
- en: When instead we use `2> error-file`, which redirects `stderr` instead of regular
    `stdout`, we do not see the error message in our Terminal anymore.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`2> error-file`时，它重定向`stderr`而不是常规的`stdout`，我们不再在终端上看到错误消息。
- en: Even better, we now see that `error-file` has 31 bytes of content, and when
    we print it with `cat`, we once again see our redirected error message! As mentioned
    before, and in the same spirit as `1>>`, if you'd like to *append* instead of
    *overwrite* the `stderr` stream to a file, use `2>>`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，我们现在看到`error-file`有31个字节的内容，当我们用`cat`打印它时，我们再次看到了我们重定向的错误消息！如前所述，并且与`1>>`的精神一样，如果你想*追加*而不是*覆盖*`stderr`流到一个文件，使用`2>>`。
- en: 'Now, because it is hard to find a command that prints both `stdout` and `stderr`
    in the same command, we''ll create our own: a very simple C program which prints
    two lines of text, one to `stdout` and one to `stderr`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为很难找到一个命令来在同一个命令中打印`stdout`和`stderr`，我们将创建我们自己的命令：一个非常简单的C程序，它打印两行文本，一行到`stdout`，一行到`stderr`。
- en: 'As a sneak preview into programming and compiling, look at this (don''t worry
    if you don''t fully understand this):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对编程和编译的预览，请看这个（如果你不完全理解这个，不要担心）：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `gcc stderr.c -o stderr` command compiles the source code found in `stderr.c`
    to the binary `stderr`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcc stderr.c -o stderr`命令将在`stderr.c`中找到的源代码编译为二进制文件`stderr`。'
- en: '`gcc` is the GNU Compiler Collection, and is not always installed by default.
    If you want to follow along with this example and you''re getting an error about
    not being able to find `gcc`, install it using `sudo apt install gcc -y`.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcc`是GNU编译器集合，并不总是默认安装的。如果你想跟着这个例子并且收到关于找不到`gcc`的错误，请使用`sudo apt install gcc
    -y`来安装它。'
- en: 'If we run our program, we get two lines of output. Because this is not a Bash
    script, we cannot execute it with `bash stderr`. We need to make the binary executable
    with `chmod`, and run it with `./stderr`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行我们的程序，我们会得到两行输出。因为这不是一个Bash脚本，我们不能用`bash stderr`来执行它。我们需要用`chmod`使二进制文件可执行，并用`./stderr`来运行它：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s see what happens when we start redirecting part of this output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们开始重定向部分输出时会发生什么：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Because we only redirected `stdout` (last reminder: `>` equals `1>`) to the
    fully-qualified file `/tmp/stdout`, the `stderr` message was still printed to
    the Terminal.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们只重定向了`stdout`（最后提醒：`>`等于`1>`）到完全限定的文件`/tmp/stdout`，`stderr`消息仍然被打印到终端上。
- en: 'The other way around gives similar results:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式会得到类似的结果：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, when we only redirect `stderr` using `2> /tmp/stderr`, we see the `stdout`
    message appear in our Terminal and the `stderr` is correctly redirected to the `/tmp/stderr` file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们只使用`2> /tmp/stderr`来重定向`stderr`时，我们会看到`stdout`消息出现在我们的终端上，而`stderr`被正确地重定向到`/tmp/stderr`文件中。
- en: 'I''m sure you''re asking yourself this question right now: how can we redirect
    **all output**, both `stdout` and `stderr`, to a file? If this was a book about
    Bash 3.x, we''d be having a difficult conversation. That conversation would entail
    us redirecting `stderr` to `stdout`, after which we could use `>` to send all
    output (because we already diverted `stderr` to `stdout` in the first place) to
    a single file.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你现在正在问自己这个问题：我们如何重定向**所有输出**，包括`stdout`和`stderr`，到一个文件？如果这是一本关于Bash 3.x的书，我们将会有一个困难的对话。这个对话将包括我们将`stderr`重定向到`stdout`，之后我们可以使用`>`将所有输出（因为我们已经将`stderr`重定向到`stdout`）发送到一个单独的文件。
- en: 'Even though that is the logical way to do it, the redirection of `stderr` to
    `stdout` is actually present at the end of the command. The command ends up like
    this: `./stderr > /tmp/output 2>&1`. Not *too complex*, but hard enough that you
    never really remember it in one go (you can trust us on this).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是逻辑上的做法，将`stderr`重定向到`stdout`实际上是在命令的末尾。命令最终变成这样：`./stderr > /tmp/output
    2>&1`。并不是*太复杂*，但足够难以一次记住（你可以相信我们）。
- en: 'Fortunately, in Bash 4.x we have a new redirection command available to us
    that can do the same thing, but in a much more understandable fashion: `&>`.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在Bash 4.x中，我们有一个新的重定向命令可供我们使用，可以以更易理解的方式完成相同的事情：`&>`。
- en: Redirect all output
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向所有输出
- en: In most situations, output that is sent to `stderr` instead of `stdout` will
    contain words that make it clear you're dealing with an error. This will include
    examples such as `permission denied`, `cannot execute binary file`, `syntax error
    near unexpected token`, and so on.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，发送到`stderr`而不是`stdout`的输出将包含明显表明你正在处理错误的单词。这将包括诸如`permission denied`、`cannot
    execute binary file`、`syntax error near unexpected token`等示例。
- en: Because of this, it is often not really necessary to split output into `stdout`
    and `stderr` (but, obviously, sometimes it will be great functionality). In these
    cases, the addition to Bash 4.x that allows us to redirect both `stdout` and `stderr`
    with a single command is perfect. This redirection, which you can use with the
    syntax `&>`, does not work differently to the earlier examples we have seen.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常并不真的需要将输出分成`stdout`和`stderr`（但显然，有时会是很好的功能）。在这些情况下，Bash 4.x的新增功能允许我们用单个命令重定向`stdout`和`stderr`是完美的。这种重定向，你可以使用`&>`语法，与我们之前看到的例子没有不同。
- en: 'Let''s review our previous example and see how this makes our lives easier:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们之前的例子，看看这是如何让我们的生活变得更容易的：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Excellent! With this syntax, we no longer have to worry about the different
    output streams. This is especially practical when working with commands that are
    new to you; in this case, you might miss interesting error messages because they
    got lost when the `stderr` stream is not saved.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！有了这个语法，我们就不再需要担心不同的输出流。当你使用新命令时，这是特别实用的；在这种情况下，你可能会错过一些有趣的错误消息，因为`stderr`流没有被保存。
- en: 'At the risk of sounding repetitive, the syntax for appending both `stdout`
    and `stderr` to a file is again an extra `>`: `&>>`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 冒昧地说一下，将`stdout`和`stderr`都追加到文件的语法再次是额外的`>`：`&>>`。
- en: Go ahead and try it out with the previous example. We won't print it here, because
    it should be obvious by now how this works.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 继续尝试之前的例子。我们不会在这里打印它，因为现在应该很明显这是如何工作的。
- en: 'Unsure about whether to redirect all output, or just `stdout` or `stderr`?
    Our advice: start with redirecting **both** to the same file. If in your use case
    this gives too much noise (either masking errors or normal log messages), you
    could always decide to redirect either of them to a file, and get the other printed
    in your Terminal. Often, in practice, `stderr` messages need the context provided
    by `stdout` messages to make sense of the error anyway, so you may as well have
    them conveniently located in the same file!'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 不确定是重定向所有输出，还是只重定向`stdout`或`stderr`？我们的建议：从将**两者**重定向到同一个文件开始。如果在您的用例中这会产生太多噪音（掩盖错误或正常日志消息），您可以决定将它们中的任何一个重定向到文件，并在终端中打印另一个。实际上，`stderr`消息通常需要`stdout`消息提供的上下文来理解错误，因此最好将它们方便地放在同一个文件中！
- en: Special output redirection
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊的输出重定向
- en: 'While sending all output is often a nice thing to do, another thing you will
    find yourself doing on a regular basis is redirecting errors (which you expect
    on some commands) to a special device: `/dev/null`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管发送所有输出通常是一件好事，但您经常会发现自己要做的另一件事是将错误（您期望在某些命令上出现）重定向到一个特殊的设备：`/dev/null`。
- en: 'The `null` kind of gives away the functionality: it''s somewhere between a
    trash can and a black hole.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`类型透露了功能：它介于垃圾桶和黑洞之间。'
- en: /dev/null
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: /dev/null
- en: In reality, all data sent (actually, written) to `/dev/null` will be discarded,
    but nonetheless generate a *write operation succeeded* back to the calling command.
    In this case, that would be the redirection.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，所有发送（实际上是写入）到`/dev/null`的数据都将被丢弃，但仍会生成一个*写操作成功*的返回给调用命令。在这种情况下，那将是重定向。
- en: 'This is important, because look what happens when a redirection is unable to
    complete successfully:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为当重定向无法成功完成时会发生什么：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This operation fails (because the `reader` user obviously can't write in the
    home directory of the `root` superuser).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作失败了（因为`reader`用户显然无法在`root`超级用户的主目录中写入）。
- en: 'Look at what happens when we try the same thing with `/dev/null`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 看看当我们尝试使用`/dev/null`做同样的事情时会发生什么：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That's all there is to it. All the output is gone (both `stdout` and `stderr`,
    because of the `&>` redirection), but the command still reports the desirable
    exit status of `0`. When we make sure that the data is gone, we use `cat /dev/null`,
    which results in nothing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。所有的输出都消失了（因为`&>`重定向了`stdout`和`stderr`），但命令仍然报告了期望的退出状态`0`。当我们确保数据已经消失时，我们使用`cat
    /dev/null`，结果什么也没有。
- en: 'We''ll show you a practical example that you will no doubt find yourself using
    often in your scripting:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向您展示一个实际示例，您在脚本中经常会使用到：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This script contains only constructs we've introduced before, apart from the
    `/dev/null` redirection of `stderr`. While this `find.sh` script is in fact nothing
    more than a simple wrapper around the `find` command, it makes a big difference.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本只包含我们之前介绍过的结构，除了对`stderr`进行`/dev/null`重定向。虽然这个`find.sh`脚本实际上只是`find`命令的一个简单包装器，但它确实有很大的区别。
- en: 'Look at what happens when we use `find` to look for the file `find.sh` file
    (because why not!):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 看看当我们使用`find`查找文件`find.sh`时会发生什么（因为为什么不呢！）：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We've cut out about 95% of the output, since you would probably agree there
    isn't much merit in five pages of `Permission denied` errors. Because we're running
    `find` as a normal user, we do not have access to many parts of the system. These
    errors reflect this.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们删掉了大约95%的输出，因为您可能会同意，五页的`Permission denied`错误没有多少价值。因为我们是以普通用户身份运行`find`，所以我们无法访问系统的许多部分。这些错误反映了这一点。
- en: We did actually locate our script, as highlighted earlier, but it could take
    a few minutes of scrolling before you encounter it. This is exactly what we meant
    about error output drowning relevant output.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实找到了我们的脚本，正如之前所强调的，但在遇到它之前可能需要滚动几分钟。这正是我们所说的错误输出淹没相关输出的情况。
- en: 'Now, let''s look for the same file with our wrapper script:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用我们的包装脚本寻找同一个文件：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There we go! Same result, but without all those pesky errors confusing us. Since
    the `Permission denied` errors are sent to the `stderr` stream, we *deleted* them
    using `2> /dev/null` after the `find` command.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们走了！相同的结果，但没有那些让我们困惑的烦人错误。由于`Permission denied`错误被发送到`stderr`流，我们在`find`命令之后使用`2>
    /dev/null` *删除*了它们。
- en: 'This actually brings us to another point: you can use redirection to silence
    commands as well. We''ve seen many commands that incorporate a `--quiet` or `-q`
    flag. Some commands, though, such as `find`, do not have this flag.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上带我们到另一个观点：您也可以使用重定向来使命令静音。我们已经看到许多命令都包含`--quiet`或`-q`标志。但是，有些命令，比如`find`，却没有这个标志。
- en: You could argue that it would be weird for `find` to have this flag (why search
    for files when you don't want to know where it is, right?), but there might be
    other commands in which exit codes present enough information, but do not have
    a `--quiet` flag; those are great candidates for redirection of everything to
    `/dev/null`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为`find`有这个标志会很奇怪（为什么要搜索文件，当你不想知道它在哪里时，对吧？），但可能有其他命令的退出代码提供了足够的信息，但没有`--quiet`标志；这些都是将所有内容重定向到`/dev/null`的绝佳候选者。
- en: All commands are different. While most have an available `--quiet` flag by now,
    there will always be cases in which this does not work for you. Perhaps the `--quiet`
    flag only silences `stdout` and not `stderr`, or perhaps it only reduces output.
    In any case, knowledge about redirecting all output to `/dev/null` when you're
    really not interested in that output (only in the exit status) is a very good
    thing to have!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的命令都是不同的。虽然现在大多数命令都有一个可用的`--quiet`标志，但总会有一些情况不适用。也许`--quiet`标志只静音`stdout`而不是`stderr`，或者它只减少输出。无论如何，当您真的对输出不感兴趣（只对退出状态感兴趣）时，了解将所有输出重定向到`/dev/null`是一件非常好的事情！
- en: /dev/zero
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: /dev/zero
- en: 'Another special device we can use is `/dev/zero`. When we redirect output to
    `/dev/zero`, it does exactly the same as `/dev/null`: the data disappears. However,
    in practice, `/dev/null` is most often used for this purpose.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的另一个特殊设备是`/dev/zero`。当我们将输出重定向到`/dev/zero`时，它与`/dev/null`完全相同：数据消失。但是，在实践中，`/dev/null`最常用于此目的。
- en: 'So, why have this special device then? Because `/dev/zero` can also be used
    to read null bytes. Out of all possible 256 bytes, the null byte is the first:
    the hexadecimal `00`. A null byte is often used to signify the termination of
    a command, for example.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么有这个特殊的设备呢？因为`/dev/zero`也可以用来读取空字节。在所有可能的256个字节中，空字节是第一个：十六进制`00`。空字节通常用于表示命令的终止，例如。
- en: 'Now, we can also use these empty bytes to allocate bytes to the disk:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还可以使用这些空字节来为磁盘分配字节：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By using `head -c 1024`, we specify we want the *first 1024 characters from*
    `/dev/zero`. Because `/dev/zero` only supplies null bytes, these will all be the
    same, but we know for sure that there will be `1024` of them.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`head -c 1024`，我们指定要从`/dev/zero`中获取*前1024个字符*。因为`/dev/zero`只提供空字节，这些字节都将是相同的，但我们确切知道会有`1024`个。
- en: 'We redirect those to a file using `stdout` redirection, and we then see a file
    with a size of 1024 bytes (how surprising). Now, if we `cat` this file, we see
    nothing! Again, this should not be a surprise, because null bytes are exactly
    that: empty, void, null. The Terminal has no way of representing them, so it does
    not.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`stdout`重定向将它们重定向到文件，然后我们看到一个大小为1024字节的文件（多么令人惊讶）。现在，如果我们`cat`这个文件，我们什么也看不到！同样，这不应该是一个惊喜，因为空字节就是这样：空的，无效的，空的。终端无法表示它们，因此它不会显示。
- en: 'Should you ever need to do this in a script, there is another option for you:
    `fallocate`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在脚本中需要执行此操作，还有另一个选项：`fallocate`：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see from the preceding output, this command does exactly what we
    already accomplished with our `/dev/zero` read and redirection (we wouldn't be
    surprised if `fallocate` was actually a fancy wrapper around reading from `/dev/zero`,
    but we can't say this for sure).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看出，这个命令与我们已经通过`/dev/zero`读取和重定向实现的功能完全相同（如果`fallocate`实际上是从`/dev/zero`读取的一个花哨的包装器，我们不会感到惊讶，但我们不能确定）。
- en: Input redirection
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入重定向
- en: 'Two other famous special devices, `/dev/random` and `/dev/urandom`, are best
    discussed in tandem with the next bit of redirection: *input redirection*.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个著名的特殊设备`/dev/random`和`/dev/urandom`最好与*输入重定向*一起讨论。
- en: 'Input normally comes from your keyboard, passed through by the Terminal to
    the command. The easiest example for this is the `read` command: it reads from
    `stdin` until it encounters a newline (when the *Enter* key is pressed) and then
    saves the input to the `REPLY` variable (or anything custom, should you have given
    that argument). It looks a bit like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 输入通常来自您的键盘，通过终端传递给命令。最简单的例子是`read`命令：它从`stdin`读取，直到遇到换行符（按下*Enter*键时），然后将输入保存到`REPLY`变量（或者如果您提供了该参数，则保存到任何自定义变量）。它看起来有点像这样：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Easy. Now, let's say we run this command non-interactively, which means we cannot
    use a keyboard and Terminal to supply the information (not a real use case for
    `read`, but this makes for a nice example).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 简单。现在，假设我们以非交互方式运行此命令，这意味着我们无法使用键盘和终端提供信息（对于`read`来说不是真正的用例，但这是一个很好的例子）。
- en: In this case, we can use input redirection (of `stdin`) to supply the input
    to `read`. This is achieved with the `<` character, which is shorthand for `<0`.
    Remember that the `stdin` file descriptor was `/dev/fd/0`? Not a coincidence.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用输入重定向（`stdin`）来提供`read`的输入。这是通过`<`字符实现的，它是`<0`的简写。记住`stdin`文件描述符是`/dev/fd/0`？这不是巧合。
- en: 'Let''s use `read` in a non-interactive manner by redirecting `stdin` to read
    from a file, instead of the Terminal:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将`stdin`重定向到文件而不是终端，以非交互方式使用`read`：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To show that we're not cheating and reusing the already stored answer in the
    `${answer}` variable, we've renamed the variable in which the reply for `read`
    is stored to `${new_answer}`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表明我们没有作弊并重复使用`${answer}`变量中已经存储的答案，我们已经将`read`中的回复重命名为`${new_answer}`。
- en: Now, at the end of the command we redirected `stdin` from the `answer-file` file,
    which we created first using `echo` + redirection of `stdout`. This was as simple
    as adding `< answer-file` after the command.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在命令的末尾，我们将`stdin`从`answer-file`文件重定向，我们首先使用`echo` + `stdout`重定向创建了这个文件。这就像在命令之后添加`<
    answer-file`一样简单。
- en: This redirection makes `read` read from the file until a newline is encountered
    (which is conveniently what `echo` always ends a string with).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重定向使`read`从文件中读取，直到遇到换行符（这恰好是`echo`总是以字符串结尾的地方）。
- en: 'Now that the basics of input redirection should be clear, let''s get back to
    our special devices: `/dev/random` and `/dev/urandom`. These two special files
    are pseudo-random number generators, which is a complicated word for something
    that generates *almost* random data.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基本的输入重定向应该是清楚的了，让我们回到我们的特殊设备：`/dev/random`和`/dev/urandom`。这两个特殊文件是伪随机数生成器，这是一个复杂的词，用于生成*几乎*随机的数据。
- en: In the case of these special devices, they gather *entropy* (a complicated word
    for something like randomness) from things like device drivers, mouse movements,
    and other things that are mostly random.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些特殊设备的情况下，它们从设备驱动程序、鼠标移动和其他大部分是随机的东西中收集*熵*（一个类似随机性的复杂词）。
- en: 'There is a slight difference between `/dev/random` and `/dev/urandom`: when
    there is not enough entropy in the system, `/dev/random` stops generating random
    output, while `/dev/urandom` keeps going.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/random`和`/dev/urandom`之间有一个细微的区别：当系统中的熵不足时，`/dev/random`停止生成随机输出，而`/dev/urandom`则继续生成。'
- en: If you really need full entropy, `/dev/random` might be the better choice (in
    all honesty, you're probably taking other measures in that situation anyway), but
    most often, `/dev/urandom` is the better choice in your scripting, since blocking
    can create incredible wait times. This comes from first-hand experience and can
    be very inconvenient!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的需要完全的熵，`/dev/random`可能是更好的选择（老实说，在这种情况下，您可能会采取其他措施），但通常情况下，在您的脚本中，`/dev/urandom`是更好的选择，因为阻塞可能会导致不可思议的等待时间。这来自第一手经验，可能非常不方便！
- en: For our examples, we'll only show `/dev/urandom`; output from `/dev/random`
    is similar.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们只会展示`/dev/urandom`；`/dev/random`的输出类似。
- en: In practice, `/dev/urandom` spits out bytes *randomly*. While some bytes are
    in the printable ASCII character range (1-9, a-z, A-Z), others are used for whitespaces
    (0x20) or newlines (0x0A).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，`/dev/urandom`会*随机*地产生字节。虽然有些字节在可打印的ASCII字符范围内（1-9，a-z，A-Z），但其他字节用于空格（0x20）或换行符（0x0A）。
- en: 'You can see the randomness by using `head -1` to grab ''the first line'' from
    `/dev/urandom`. Since a line is terminated by a newline, the command `head -1
    /dev/urandom` will print everything until the first newline: this can be a few
    or a lot of characters:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`head -1`从`/dev/urandom`中抓取'第一行'来查看随机性。由于一行以换行符结尾，命令`head -1 /dev/urandom`将打印直到第一个换行符之前的所有内容：这可能是少量或大量字符：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first instance we ran printed a lot more characters (not all of them readable)
    than the second time around; this can be directly linked to the randomness of
    the bytes generated. The second time we ran `head -1 /dev/urandom`, we encountered
    the newline byte, 0x0A, faster than the first iteration.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们第一次运行时打印了更多的字符（并非所有字符都可读）比第二次运行时；这可以直接与生成的字节的随机性联系起来。第二次我们运行`head -1 /dev/urandom`时，我们比第一次迭代更快地遇到了换行字节0x0A。
- en: Generating a password
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成密码
- en: Now, you might be wondering what use random characters might have. A prime example
    is generating passwords. Long, random passwords are always good; they're resistant
    to brute-force attacks, cannot be guessed, and, if not reused, are **very** secure.
    And let's be honest, how cool is it to generate a random password using the entropy
    from your own Linux system?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能会想知道随机字符可能有什么用。一个主要的例子是生成密码。长而随机的密码总是很好；它们抵抗暴力破解攻击，无法被猜测，并且如果不重复使用，非常安全。而且坦率地说，使用您自己的Linux系统的熵来生成随机密码有多酷呢？
- en: 'Even better, we can use input redirection from `/dev/urandom` to accomplish
    this, together with the `tr` command. A simple script would look like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，我们可以使用来自`/dev/urandom`的输入重定向来完成这个任务，再加上`tr`命令。一个简单的脚本看起来是这样的：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The header and input checks, even the one with the regular expression checking
    for a digit, should be clear by now.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 标题和输入检查，甚至包括使用正则表达式检查数字的检查，现在应该是清楚的。
- en: Next, we use the `tr` command with redirected input from `/dev/urandom` to grab
    readable characters in our set of a-z, A-Z, and 0-9\. These are *piped* to `head`
    (more on pipes later in this chapter), which causes the first *x* characters for
    be printed to the user (as specified in the argument to the script).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`tr`命令从`/dev/urandom`重定向输入，以获取我们的a-z、A-Z和0-9字符集中的可读字符。这些被*管道*到`head`（本章后面将更多地介绍管道），这会导致前*x*个字符被打印给用户（如脚本参数中指定的那样）。
- en: To make sure the Terminal formatting is correct, we throw in a quick `echo`
    without an argument; this just prints a newline. And just like this, we've built
    our own *private*, *secure*, and *offline* password generator. Using input redirection,
    even!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保终端格式正确，我们在没有参数的情况下添加了一个快速的`echo`；这只是打印一个换行符。就像这样，我们建立了我们自己的*私人*、*安全*和*离线*密码生成器。甚至使用输入重定向！
- en: Advanced redirecting
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级重定向
- en: We've now seen both input and output redirection, and some practical uses for
    both. We have not, however, combined both forms of redirection yet, and this is
    very much possible!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了输入和输出重定向，以及两者的一些实际用途。但是，我们还没有结合这两种重定向形式，这是完全可能的！
- en: You will probably not use this too often, though; most commands accept the input
    as an argument, and often supply a flag that allows you to specify a file to output
    to. But knowledge is power, and if you ever come across a command that does not
    have these arguments, you know you can solve this yourself.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不会经常使用这个功能；大多数命令接受输入作为参数，并经常提供一个标志，允许您指定要输出到的文件。但知识就是力量，如果您遇到一个没有这些参数的命令，您知道您可以自己解决这个问题。
- en: 'Try the following on your command line, and try to understand why you get the
    results that you see:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上尝试以下操作，并尝试理解为什么会得到您看到的结果：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, we can use both `<` and `>` on the same line to redirect both
    the input and output. First, we use `grep` with input redirection in the `grep
    'stderr' < stderr.c` command (which is technically what `grep 'stderr' stderr.c`
    does as well). We see the output in our Terminal.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们可以在同一行上使用`<`和`>`来重定向输入和输出。首先，我们在`grep 'stderr' < stderr.c`命令中使用了输入重定向的`grep`（这在技术上也是`grep
    'stderr' stderr.c`所做的）。我们在终端中看到了输出。
- en: Next, we add `> /tmp/grep-file` right behind that command, which means we'll
    redirect our `stdout` to that `/tmp/grep-file` file. We no longer see the output
    in the Terminal, but when we `cat` the file we get it back, so it was successfully
    written to the file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在该命令的后面添加了`> /tmp/grep-file`，这意味着我们将把我们的`stdout`重定向到`/tmp/grep-file`文件。我们不再在终端中看到输出，但当我们`cat`文件时，我们会得到它，所以它成功地写入了文件。
- en: 'Since we''re in the advanced part of this chapter, we will demonstrate that
    it actually doesn''t matter where the input redirection is placed:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在处于本章的高级部分，我们将演示输入重定向放在哪里实际上并不重要：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we specified the input redirection at the beginning of our command. For
    us, this feels like the more logical approach when you consider the flow, but
    this causes the actual command (`grep`) to appear roughly halfway through the
    command, which messes up the readability.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在命令的开头指定了输入重定向。对我们来说，当考虑流程时，这似乎是更合乎逻辑的方法，但这会导致实际命令（`grep`）出现在命令的大致中间，这会破坏可读性。
- en: This is mostly a moot point because, in practice, we have found very little
    use for both input and output redirection; even in this example, we would just
    write the command as `grep 'stdout' stderr.c > /tmp/grep-file-stdout` and the
    confusing construction is gone.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这在实践中基本上是一个无用的观点，因为我们发现很少有用于输入和输出重定向；即使在这个例子中，我们也只需将命令写成`grep 'stdout' stderr.c
    > /tmp/grep-file-stdout`，混乱的构造就消失了。
- en: But really understanding what is going on with input and output, and how some
    commands do some of the heavy lifting for you, is worth your time! These are exactly
    the kind of issues you're going to encounter in more complex scripts, and fully
    understanding this will save you a lot of troubleshooting time.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但真正理解输入和输出的运作方式，以及一些命令如何为你做一些繁重的工作，是值得你花时间去理解的！这些正是你在更复杂的脚本中会遇到的问题，充分理解这一点将为你节省大量的故障排除时间。
- en: Redirecting redirections
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向重定向
- en: We already gave you a sneak preview of the process of redirecting redirections.
    The most famous example, which was mostly used before Bash 4.x, is redirecting
    the `stderr` stream to the `stdout` stream. By doing this, you can redirect *all*
    output with just the `>` syntax.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经给你一个重定向重定向过程的概览。最著名的例子是在Bash 4.x之前大多数情况下使用的，即将`stderr`流重定向到`stdout`流。通过这样做，你可以只用`>`语法重定向*所有*输出。
- en: 'You can achieve it like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样实现：
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Remember, you no longer need this syntax with Bash 4.x, but if you ever want
    to use your own custom file descriptors as input/output streams, this will be
    useful knowledge. By ending the command with `2>&1`, we're writing all `stderr`
    output (`2>`) to the `stdout` descriptor (`&1`).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，你不再需要在Bash 4.x中使用这种语法，但是如果你想要使用自定义的文件描述符作为输入/输出流，这将是有用的知识。通过以`2>&1`结束命令，我们将所有`stderr`输出（`2>`）写入`stdout`描述符（`&1`）。
- en: 'We can also do it the other way around:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以反过来做：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: So now, we're redirecting the `stderr` stream to the `passwd` file. However,
    the `head -1 /etc/passwd` command only delivers an `stdout` stream; we're seeing
    it printed to the Terminal instead of to the file.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在，我们将`stderr`流重定向到`passwd`文件。然而，`head -1 /etc/passwd`命令只提供了一个`stdout`流；我们看到它被打印到终端而不是文件中。
- en: When we use `1>&2` (which could also be written as `>&2`) we're redirecting
    `stdout` to `stderr`. Now it is written to the file and we can `cat` it there!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`1>&2`（也可以写成`>&2`）时，我们将`stdout`重定向到`stderr`。现在它被写入文件，我们可以在那里使用`cat`命令！
- en: Remember, this is advanced information, which is mostly useful for your theoretical
    understanding and when you start working with your own custom file descriptors.
    For all other output redirections, play it safe and use the `&>` syntax as we
    discussed earlier.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这是高级信息，主要用于你的理论理解以及当你开始使用自定义文件描述符时。对于所有其他输出重定向，还是安全地使用我们之前讨论过的`&>`语法。
- en: Command substitution
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令替换
- en: 'While not strictly redirection in the Linux sense, *command substitution* in
    our eyes is a form of functional redirection: you use the output of a command
    as an argument to another command. If we needed to use output as input for the
    next command, we''d use a pipe (as we''ll see in a few pages), but sometimes we
    just need that output at a very specific location in our command.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在Linux意义上并不严格属于重定向，但在我们看来，*命令替换*是一种功能性重定向的形式：你使用一个命令的输出作为另一个命令的参数。如果我们需要使用输出作为下一个命令的输入，我们会使用管道（正如我们将在几页后看到的），但有时我们只需要将输出放在我们命令中的一个非常特定的位置。
- en: 'This is where command substitution is used. We''ve already seen command substitution
    in some of our scripts: `cd $(dirname $0)`. Simply put, this does something like
    `cd` to the result of `dirname $0`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是命令替换的用途。我们已经在一些脚本中看到了命令替换：`cd $(dirname $0)`。简单地说，这做的事情类似于`cd`到`dirname $0`的结果。
- en: '`dirname $0` gives back the directory where the script is located (since `$0`
    is the fully-qualified path of the script), so when we use this with scripts,
    we''ll make sure all operations are always carried out relative to the directory
    where the script is located.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`dirname $0`返回脚本所在的目录（因为`$0`是脚本的完全限定路径），所以当我们在脚本中使用它时，我们将确保所有操作都相对于脚本所在的目录进行。'
- en: 'If we did not have command substitution, we''d need to store the output somewhere
    before we could use it again:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有命令替换，我们需要在再次使用它之前将输出存储在某个地方：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'While this *sometimes* works, there are some pitfalls here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这有时会起作用，但这里有一些陷阱：
- en: You need to write a file somewhere where you have write permissions
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要在你有写权限的地方写一个文件
- en: You need to clean up the file after the `cd`
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`cd`之后你需要清理文件
- en: You need to make sure the file does not conflict with other scripts
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要确保文件不会与其他脚本冲突
- en: To cut a long story short, this is a far from ideal solution, and best avoided.
    And since Bash supplies command substitution, there is no real drawback to using
    it. As we've seen, the command substitution in `cd $(dirname $0)` handles this
    for us, without the need for us to track files or variables or any other complicated
    constructions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 长话短说，这远非理想的解决方案，最好避免使用。而且由于Bash提供了命令替换，使用它并没有真正的缺点。正如我们所见，`cd $(dirname $0)`中的命令替换为我们处理了这个问题，而不需要我们跟踪文件或变量或任何其他复杂的构造。
- en: 'Command substitution is actually used quite a lot in Bash scripting. Take a
    look at the following example, in which we use command substitution to instantiate
    and populate a variable:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 命令替换实际上在Bash脚本中经常使用。看看以下的例子，我们在其中使用命令替换来实例化和填充一个变量：
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: For this example, we reused the logic in our earlier `password-generator.sh`
    script. This time, we do not give the user the option to supply a length; we keep
    it simple and assume a length of 20 (which is, at least in 2018, a pretty good
    length for a password).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们重用了我们之前的`password-generator.sh`脚本中的逻辑。这一次，我们不给用户提供输入长度的选项；我们保持简单，假设长度为20（至少在2018年，这是一个相当好的密码长度）。
- en: We use command substitution to write the result (the random password) to a variable,
    which we then `echo` to the user.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用命令替换将结果（随机密码）写入一个变量，然后将其`echo`给用户。
- en: 'We actually could have done this in a single line:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上我们可以在一行中完成这个操作：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: However, as we have discussed many times by now, *readability counts* (still!).
    We feel that first writing to a variable with a descriptive name, before we actually
    use it, increases the readability of the script.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们现在已经讨论了很多次，*可读性很重要*（仍然！）。我们认为在实际使用之前首先将其写入具有描述性名称的变量，可以增加脚本的可读性。
- en: Furthermore, if we wanted to use the same random value more than once, we need
    a variable anyway. So in this case, the extra verbosity in our script helps us
    and is desirable.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们想要多次使用相同的随机值，我们无论如何都需要一个变量。因此，在这种情况下，脚本中的额外冗长帮助我们并且是可取的。
- en: The predecessor to `$(..)` was the use of backticks, which is the [PRE35]
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(..)`的前身是使用反引号，即[PRE35]'
- en: <(command)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <(command)
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: reader@ubuntu:~/scripts/chapter_12$ diff <(ls /tmp/) <(ls /home/)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ diff <(ls /tmp/) <(ls /home/)
- en: 1,11c1
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 1,11c1
- en: < directory-file
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: < directory-file
- en: < grep-file
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: < grep-file
- en: < grep-file-stdout
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: < grep-file-stdout
- en: < passwd
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: < passwd
- en: < shadow
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: < shadow
- en: '---'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '---'
- en: reader
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: reader
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: reader@ubuntu:/tmp$ echo 'Fly into the distance' > file
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:/tmp$ echo '飞向远方' > file
- en: reader@ubuntu:/tmp$ grep 'distance' < file
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:/tmp$ grep 'distance' < file
- en: Fly into the distance reader@ubuntu:/tmp$ echo 'Fly into the distance' | grep
    'distance'Fly into the distance
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 飞向远方 reader@ubuntu:/tmp$ echo '飞向远方' | grep 'distance'飞向远方
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: command-with-output | command-using-input
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: command-with-output | command-using-input
- en: '[PRE39]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: reader@ubuntu:~/scripts/chapter_12$ cat /etc/shadow | grep 'denied'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ cat /etc/shadow | grep 'denied'
- en: 'cat: /etc/shadow: Permission denied'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 'cat: /etc/shadow: 权限被拒绝'
- en: reader@ubuntu:~/scripts/chapter_12$ cat /etc/shadow | grep 'denied' > /tmp/empty-file
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ cat /etc/shadow | grep 'denied' > /tmp/empty-file
- en: 'cat: /etc/shadow: Permission denied #Printed to stderr on terminal.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 'cat: /etc/shadow: 权限被拒绝 #在终端上打印到stderr。'
- en: reader@ubuntu:~/scripts/chapter_12$ cat /etc/shadow | grep 'denied' 2> /tmp/error-file
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ cat /etc/shadow | grep 'denied' 2> /tmp/error-file
- en: 'cat: /etc/shadow: Permission denied #Printed to stderr on terminal.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 'cat: /etc/shadow: 权限被拒绝 #在终端上打印到stderr。'
- en: reader@ubuntu:~/scripts/chapter_12$ cat /tmp/empty-file
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ cat /tmp/empty-file
- en: reader@ubuntu:~/scripts/chapter_12$ cat /tmp/error-file
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ cat /tmp/error-file
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: reader@ubuntu:~/scripts/chapter_12$ cat /etc/shadow |& grep 'denied'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ cat /etc/shadow |& grep 'denied'
- en: 'cat: /etc/shadow: Permission denied'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'cat: /etc/shadow: 权限被拒绝'
- en: reader@ubuntu:~/scripts/chapter_12$ cat /etc/shadow |& grep 'denied' > /tmp/error-file
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ cat /etc/shadow |& grep 'denied' > /tmp/error-file
- en: reader@ubuntu:~/scripts/chapter_12$ cat /tmp/error-file
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ cat /tmp/error-file
- en: 'cat: /etc/shadow: Permission denied'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'cat: /etc/shadow: 权限被拒绝'
- en: reader@ubuntu:~/scripts/chapter_12$ cat /etc/shadow |& grep 'denied' 2> /tmp/error-file
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ cat /etc/shadow |& grep 'denied' 2> /tmp/error-file
- en: 'cat: /etc/shadow: Permission denied'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'cat: /etc/shadow: 权限被拒绝'
- en: reader@ubuntu:~/scripts/chapter_12$ cat /tmp/error-file
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ cat /tmp/error-file
- en: '[PRE41]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: reader@ubuntu:~/scripts/chapter_12$ vim piped-passwords.sh
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ vim piped-passwords.sh
- en: reader@ubuntu:~/scripts/chapter_12$ cat piped-passwords.sh
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ cat piped-passwords.sh
- en: '#!/bin/bash'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '#!/bin/bash'
- en: '#####################################'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '#####################################'
- en: 'Author: Sebastiaan Tammer'
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作者：Sebastiaan Tammer
- en: 'Version: v1.0.0'
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本：v1.0.0
- en: 'Date: 2018-11-10'
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期：2018-11-10
- en: 'Description: Generate a password, using only pipes.'
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述：仅使用管道生成密码。
- en: 'Usage: ./piped-passwords.sh'
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用法：./piped-passwords.sh
- en: '#####################################'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '#####################################'
- en: password=$(head /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c20)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: password=$(head /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c20)
- en: 'echo "Your random password is: ${password}"'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: echo "您的随机密码是：${password}"
- en: '[PRE42]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: reader@ubuntu:~/scripts/chapter_12$ vim password-setter.sh
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ vim password-setter.sh
- en: reader@ubuntu:~/scripts/chapter_12$ cat password-setter.sh
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ cat password-setter.sh
- en: '#!/bin/bash'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '#!/bin/bash'
- en: '#####################################'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '#####################################'
- en: 'Author: Sebastiaan Tammer'
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作者：Sebastiaan Tammer
- en: 'Version: v1.0.0'
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本：v1.0.0
- en: 'Date: 2018-11-10'
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期：2018-11-10
- en: 'Description: Set a password using chpasswd.'
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述：使用chpasswd设置密码。
- en: 'Usage: ./password-setter.sh'
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用法：./password-setter.sh
- en: '#####################################'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '#####################################'
- en: NEW_USER_NAME=bob
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: NEW_USER_NAME=bob
- en: Verify this script is run with root privileges.
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证此脚本是否以root权限运行。
- en: if [[ $(id -u) -ne 0 ]]; then
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: if [[ $(id -u) -ne 0 ]]; then
- en: echo "Please run as root or with sudo!"
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: echo "请以root或sudo身份运行！"
- en: exit 1
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: exit 1
- en: fi
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: fi
- en: We only need exit status, send all output to /dev/null.
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们只需要退出状态，将所有输出发送到/dev/null。
- en: id ${NEW_USER_NAME} &> /dev/null
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: id ${NEW_USER_NAME} &> /dev/null
- en: Check if we need to create the user.
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查是否需要创建用户。
- en: if [[ $? -ne 0 ]]; then
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: if [[ $? -ne 0 ]]; then
- en: User does not exist, create the user.
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户不存在，创建用户。
- en: useradd -m ${NEW_USER_NAME}
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: useradd -m ${NEW_USER_NAME}
- en: fi
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: fi
- en: Set the password for the user.
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为用户设置密码。
- en: echo "${NEW_USER_NAME}:password" | chpasswd
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: echo "${NEW_USER_NAME}:password" | chpasswd
- en: '[PRE43]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: sudo apt upgrade -y | tee /tmp/upgrade.log
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: sudo apt upgrade -y | tee /tmp/upgrade.log
- en: '[PRE44]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: sudo apt upgrade -y |& tee /tmp/upgrade.log
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: sudo apt upgrade -y |& tee /tmp/upgrade.log
- en: '[PRE45]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: reader@ubuntu:~/scripts/chapter_12$ sudo apt upgrade -y |& tee /tmp/upgrade.log
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ sudo apt upgrade -y |& tee /tmp/upgrade.log
- en: 'WARNING: apt does not have a stable CLI interface. Use with caution in scripts.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：apt没有稳定的CLI界面。在脚本中谨慎使用。
- en: Reading package lists...
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 读取软件包列表...
- en: <SNIPPED>
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: <SNIPPED>
- en: 0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 0升级，0新安装，0删除，0未升级。
- en: reader@ubuntu:~/scripts/chapter_12$ cat /tmp/upgrade.log
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ cat /tmp/upgrade.log
- en: 'WARNING: apt does not have a stable CLI interface. Use with caution in scripts.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：apt没有稳定的CLI界面。在脚本中谨慎使用。
- en: Reading package lists...
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 读取软件包列表...
- en: <SNIPPED>
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: <SNIPPED>
- en: 0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 0升级，0新安装，0删除，0未升级。
- en: '[PRE46]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: cat << EOF
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: cat << EOF
- en: input
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 输入
- en: more input
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 更多输入
- en: the last input
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个输入
- en: EOF
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: EOF
- en: '[PRE47]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: reader@ubuntu:~/scripts/chapter_12$ cat << EOF
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ cat << EOF
- en: input
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输入
- en: more input
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更多输入
- en: the last input
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最后一个输入
- en: EOF
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: EOF
- en: input
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 输入
- en: more input
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 更多输入
- en: the last input
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个输入
- en: '[PRE48]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: reader@ubuntu:~/scripts/chapter_12$ cat << end-of-file
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ cat << end-of-file
- en: The delimiting identifier is end-of-file
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 定界符标识符是文件结束
- en: But it only stops when end-of-file is the only thing on the line
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但只有当文件结束符是行上唯一的东西时才会停止
- en: end-of-file does not work, since it has text after it
  id: totrans-315
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 文件结束符不起作用，因为它后面有文本
- en: end-of-file
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 文件结束符
- en: The delimiting identifier is end-of-file
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔标识符是文件结束符
- en: But it only stops when end-of-file is the only thing on the line
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 但只有当文件结束符是行上唯一的东西时才会停止
- en: end-of-file does not work, since it has text behind it
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 文件结束符不起作用，因为它后面有文本
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: reader@ubuntu:~/scripts/chapter_12$ wall << EOF
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ wall << EOF
- en: Hi guys, we're rebooting soon, please save your work!
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 嗨，伙计们，我们很快就要重新启动，请保存你的工作！
- en: It would be a shame if you lost valuable time...
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你浪费了宝贵的时间会很遗憾...
- en: EOF
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: EOF
- en: 'Broadcast message from reader@ubuntu (pts/0) (Sat Nov 10 16:21:15 2018):'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 来自reader@ubuntu (pts/0) (2018年11月10日16:21:15)的广播消息：
- en: Hi guys, we're rebooting soon, please save your work!
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 嗨，伙计们，我们很快就要重新启动，请保存你的工作！
- en: It would be a shame if you lost valuable time...
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你浪费了宝贵的时间会很遗憾...
- en: '[PRE50]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: reader@ubuntu:~/scripts/chapter_12$ cat << EOF
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ cat << EOF
- en: Hi, this is $USER!
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 嗨，这是$USER！
- en: EOF
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: EOF
- en: Hi, this is reader!
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 嗨，这是reader！
- en: '[PRE51]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: reader@ubuntu:~/scripts/chapter_12$ cat << 'EOF'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:~/scripts/chapter_12$ cat << 'EOF'
- en: Hi, this is $USER!
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 嗨，这是$USER！
- en: EOF
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: EOF
- en: Hi, this is $USER!
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 嗨，这是$USER！
- en: '[PRE52]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: reader@ubuntu:/tmp$ head /home/reader/scripts/chapter_11/while-interactive.sh
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:/tmp$ head /home/reader/scripts/chapter_11/while-interactive.sh
- en: '#!/bin/bash'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '#!/bin/bash'
- en: '#####################################'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '#####################################'
- en: 'Author: Sebastiaan Tammer'
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作者：Sebastiaan Tammer
- en: 'Version: v1.1.0'
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本：v1.1.0
- en: 'Date: 2018-10-28'
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期：2018-10-28
- en: 'Description: A simple riddle in a while loop.'
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述：一个简单的谜语在一个while循环中。
- en: 'Usage: ./while-interactive.sh'
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用法：./while-interactive.sh
- en: '#####################################'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '#####################################'
- en: reader@ubuntu:/tmp$ bash /home/reader/scripts/chapter_11/while-interactive.sh
    << EOF
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:/tmp$ bash /home/reader/scripts/chapter_11/while-interactive.sh
    << EOF
- en: 'a mouse  #Try 1.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '一个鼠标  #尝试1。'
- en: 'the sun  #Try 2.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '太阳  #尝试2。'
- en: 'keyboard #Try 3.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '键盘  #尝试3。'
- en: EOF
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: EOF
- en: 'Incorrect, please try again. #Try 1.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '不正确，请再试一次。 #尝试1。'
- en: 'Incorrect, please try again. #Try 2.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '不正确，请再试一次。 #尝试2。'
- en: 'Correct, congratulations!    #Try 3.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '正确，恭喜！    #尝试3。'
- en: Now we can continue after the while loop is done, awesome!
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在while循环完成后继续，太棒了！
- en: '[PRE53]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: reader@ubuntu:/tmp$ echo "2^8" | bc
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:/tmp$ echo "2^8" | bc
- en: '256'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '256'
- en: reader@ubuntu:/tmp$ echo "4*4" > math
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:/tmp$ echo "4*4" > math
- en: reader@ubuntu:/tmp$ bc math
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:/tmp$ bc math
- en: bc 1.07.1
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: bc 1.07.1
- en: Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006, 2008, 2012-2017 Free Software
    Foundation, Inc.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 版权所有1991-1994, 1997, 1998, 2000, 2004, 2006, 2008, 2012-2017自由软件基金会。
- en: This is free software with ABSOLUTELY NO WARRANTY.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这是绝对没有保修的免费软件。
- en: For details type `warranty'.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 有关详细信息，请键入`warranty'。
- en: '16'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '16'
- en: ^C
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: ^C
- en: (interrupt) use quit to exit.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: （中断）使用quit退出。
- en: quit
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 退出
- en: '[PRE54]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: reader@ubuntu:/tmp$ bc <<< 2^8
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: reader@ubuntu:/tmp$ bc <<< 2^8
- en: '256'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '256'
- en: '```'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: There we go. Just a simple here string as input (which is sent to `stdin` of
    the command), and we get the same functionality as an `echo` with a pipe. However,
    now it is just a single command, instead of a chain. Simple but effective, just
    the way we like it!
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。只是一个简单的输入字符串（发送到命令的`stdin`），我们得到了与使用管道的`echo`相同的功能。但是，现在只是一个命令，而不是一个链。简单但有效，正是我们喜欢的方式！
- en: Summary
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter explained almost everything there is to know about *redirection*
    on Linux. We began with a general description of what redirection is, and how
    *file descriptors* are used to facilitate redirections. We learned that file descriptors
    0, 1, and 2 are used for `stdin`, `stdout`, and `stderr`, respectively.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章几乎解释了关于Linux上*重定向*的所有知识。我们从对重定向的一般描述开始，以及如何使用*文件描述符*来促进重定向。我们了解到文件描述符0、1和2分别用于`stdin`、`stdout`和`stderr`。
- en: We then got acquainted with the syntax for redirections. This included `>`,
    `2>`, `&>`, and `<`, and their appending syntaxes, `>>`, `2>>`, `&>>`, and `<<`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们熟悉了重定向的语法。这包括`>`、`2>`、`&>`和`<`，以及它们的追加语法，`>>`、`2>>`、`&>>`和`<<`。
- en: We discussed a few special Linux devices, `/dev/null`, `/dev/zero`, and `/dev/urandom`.
    We showed examples of how we could use these devices to remove output, generate
    null bytes, and generate random data. In the advanced redirecting section, we
    showed that we could bind `stdout` to `stderr` and vice versa.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了一些特殊的Linux设备，`/dev/null`、`/dev/zero`和`/dev/urandom`。我们展示了如何使用这些设备来删除输出、生成空字节和生成随机数据的示例。在高级重定向部分，我们展示了我们可以将`stdout`绑定到`stderr`，反之亦然。
- en: Furthermore, we learned about *command substitution* and *process substitution*,
    which allows us to use the result of a command in an argument to another command,
    or as a file.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们了解了*命令替换*和*进程替换*，它允许我们在另一个命令的参数中使用命令的结果，或者作为文件。
- en: Next up were *pipes*. Pipes are simple, but very powerful, Bash constructs,
    which are used to connect the `stdout` (and possibly `stderr`) of one command
    to the `stdin` of another. This allows us to chain commands, manipulating the
    data streams further as we go, through as many commands as we want.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是*管道*。管道是简单但非常强大的Bash结构，用于将一个命令的`stdout`（可能还有`stderr`）连接到另一个命令的`stdin`。这使我们能够链接命令，通过尽可能多的命令来进一步操作数据流。
- en: We also introduced `tee`, which allows us to send a stream to both our Terminal
    and a file, a construction often used for log files.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了`tee`，它允许我们将流发送到我们的终端和一个文件，这种结构通常用于日志文件。
- en: Finally, we explained *here documents* and *here strings*. These concepts allow
    us to send multiline and single-line input directly from the Terminal into the
    `stdin` of other commands, something that would otherwise require an `echo` or
    `cat`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们解释了*文档*和*字符串*。这些概念允许我们将多行和单行输入直接从终端发送到其他命令的`stdin`，否则需要`echo`或`cat`。
- en: 'The following commands were introduced in this chapter: `diff`, `gcc`, `fallocate`,
    `tr`, `chpasswd`, `tee`, and `bc`.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了以下命令：`diff`、`gcc`、`fallocate`、`tr`、`chpasswd`、`tee`和`bc`。
- en: Questions
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are file descriptors?
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件描述符是什么？
- en: What do the terms `stdin`, `stdout`, and `stderr` mean?
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 术语`stdin`、`stdout`和`stderr`是什么意思？
- en: How do `stdin`, `stdout`, and `stderr` map to the default file descriptors?
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`stdin`、`stdout`和`stderr`如何映射到默认文件描述符？'
- en: What is the difference between the output redirections `>`, `1>`, and `2>`?
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`>`、`1>`和`2>`之间的输出重定向有什么区别？'
- en: What is the difference between `>` and `>>`?
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`>`和`>>`之间有什么区别？'
- en: How can both `stdout` and `stderr` be redirected at the same time?
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何同时重定向`stdout`和`stderr`？
- en: Which special devices can be used to act as a black hole for output?
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些特殊设备可以用作输出的黑洞？
- en: What does a pipe do, with regards to redirections?
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管道在重定向方面有什么作用？
- en: How can we send output to both the Terminal and a log file?
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何将输出发送到终端和日志文件？
- en: What is a typical use case for a here string?
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: here string 的典型用例是什么？
- en: Further reading
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Read more about file descriptors at the following link**: [https://linuxmeerkat.wordpress.com/2011/12/02/file-descriptors-explained/](https://linuxmeerkat.wordpress.com/2011/12/02/file-descriptors-explained/).'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请点击以下链接了解有关文件描述符的更多信息：[https://linuxmeerkat.wordpress.com/2011/12/02/file-descriptors-explained/](https://linuxmeerkat.wordpress.com/2011/12/02/file-descriptors-explained/)。
- en: '**Find information about advanced scripts with file descriptors at the following
    link**: [https://bash.cyberciti.biz/guide/Reads_from_the_file_descriptor_(fd)](https://bash.cyberciti.biz/guide/Reads_from_the_file_descriptor_(fd)).'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请点击以下链接了解有关使用文件描述符的高级脚本的信息：[https://bash.cyberciti.biz/guide/Reads_from_the_file_descriptor_(fd)](https://bash.cyberciti.biz/guide/Reads_from_the_file_descriptor_(fd))。
- en: '**Read more about command substitution at the following link**: [http://www.tldp.org/LDP/abs/html/commandsub.html](http://www.tldp.org/LDP/abs/html/commandsub.html).'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请点击以下链接了解有关命令替换的更多信息：[http://www.tldp.org/LDP/abs/html/commandsub.html](http://www.tldp.org/LDP/abs/html/commandsub.html)。
- en: '**Find information about here documents at the following link**: [https://www.tldp.org/LDP/abs/html/here-docs.html](https://www.tldp.org/LDP/abs/html/here-docs.html).'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请点击以下链接了解有关 here documents 的信息：[https://www.tldp.org/LDP/abs/html/here-docs.html](https://www.tldp.org/LDP/abs/html/here-docs.html)。
