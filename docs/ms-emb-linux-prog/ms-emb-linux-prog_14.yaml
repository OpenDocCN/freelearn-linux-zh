- en: Chapter 14. Real-time Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。实时编程
- en: 'Much of the interaction between a computer system and the real world happens
    in real-time and so this is an important topic for developers of embedded systems.
    I have touched on real-time programming in several places so far: in [Chapter
    10](ch10.html "Chapter 10. Learning About Processes and Threads"), *Learning About
    Processes and Threads*, I looked at scheduling policies and priority inversion,
    and in [Chapter 11](ch11.html "Chapter 11. Managing Memory"), *Managing Memory*,
    I described the problems with page faults and the need for memory locking. Now,
    it is time to bring these topics together and look at real-time programming in
    some depth.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机系统与现实世界之间的许多交互都是实时进行的，因此这对于嵌入式系统的开发人员来说是一个重要的主题。到目前为止，我已经在几个地方提到了实时编程：在[第10章](ch10.html
    "第10章。了解进程和线程")中，*了解进程和线程*，我研究了调度策略和优先级反转，在[第11章](ch11.html "第11章。管理内存")中，*管理内存*，我描述了页面错误的问题和内存锁定的需求。现在，是时候把这些主题联系在一起，深入研究实时编程了。
- en: 'In this chapter, I will begin with a discussion about the characteristics of
    real-time systems and then consider the implications for system design, both at
    the application and kernel levels. I will describe the real-time kernel patch,
    `PREEMPT_RT`, and show how to get it and apply it to a mainline kernel. The last
    sections will describe how to characterize system latencies using two tools: `cyclictest`
    and `Ftrace`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将首先讨论实时系统的特性，然后考虑应用程序和内核级别的系统设计的影响。我将描述实时内核补丁`PREEMPT_RT`，并展示如何获取它并将其应用于主线内核。最后几节将描述如何使用两个工具`cyclictest`和`Ftrace`来表征系统延迟。
- en: There are other ways to achieve real-time behavior on an embedded Linux device,
    for instance, using a dedicated micro-controller or a separate real-time kernel
    alongside the Linux kernel in the way that Xenomai and RTAI do. I am not going
    to discuss these here because the focus of this book is on using Linux as the
    core for embedded systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式Linux设备实现实时行为的其他方法，例如，使用专用微控制器或在Linux内核旁边使用单独的实时内核，就像Xenomai和RTAI所做的那样。我不打算在这里讨论这些，因为本书的重点是将Linux用作嵌入式系统的核心。
- en: What is real-time?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是实时？
- en: The nature of real-time programming is one of the subjects that software engineers
    love to discuss at length, often giving a range of contradictory definitions.
    I will begin by setting out what I think is important about real-time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 实时编程的性质是软件工程师喜欢长时间讨论的主题之一，通常给出一系列矛盾的定义。我将从阐明我认为实时重要的内容开始。
- en: A task is a real-time task if it has to complete before a certain point in time,
    known as the deadline. The distinction between real-time and non real-time tasks
    is shown by considering what happens when you play an audio stream on your computer
    while compiling the Linux kernel.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个任务必须在某个时间点之前完成，这个时间点被称为截止日期，那么这个任务就是实时任务。通过考虑在编译Linux内核时在计算机上播放音频流时会发生什么，可以看出实时任务和非实时任务之间的区别。
- en: The first is a real-time task because there is a constant stream of data arriving
    at the audio driver and blocks of audio samples have to be written to the audio
    interface at the playback rate. Meanwhile, the compilation is not real-time because
    there is no deadline. You simply want it to complete as soon as possible; whether
    it takes 10 seconds or 10 minutes does not affect the quality of the kernel.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是实时任务，因为音频驱动程序不断接收数据流，并且必须以播放速率将音频样本块写入音频接口。同时，编译不是实时的，因为没有截止日期。您只是希望它尽快完成；无论它花费10秒还是10分钟，都不会影响内核的质量。
- en: 'The other important thing to consider is the consequence of missing the deadline,
    which can range from mild annoyance through to system failure and death. Here
    are some examples:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情要考虑的是错过截止日期的后果，这可能从轻微的烦恼到系统故障和死亡。以下是一些例子：
- en: '**Playing an audio stream**: There is a deadline in the order of tens of milliseconds.
    If the audio buffer under-runs you will hear a click, which is annoying, but you
    will get over it.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**播放音频流**：截止日期在几十毫秒的范围内。如果音频缓冲区不足，你会听到点击声，这很烦人，但你会克服它。'
- en: '**Moving and clicking a mouse**: The deadline is also in the order of tens
    of milliseconds. If it is missed, the mouse moves erratically and button clicks
    will be lost. If the problem persists, the system will become unusable.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动和点击鼠标**：截止日期也在几十毫秒的范围内。如果错过了，鼠标会移动不稳定，按钮点击将丢失。如果问题持续存在，系统将变得无法使用。'
- en: '**Printing a piece of paper**: The deadlines for the paper feed are in the
    millisecond range, which, if missed, may cause the printer to jam and somebody
    will have to go and fix it. Occasional jams are acceptable but nobody is going
    to buy a printer that keeps on jamming.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印一张纸**：纸张进纸的截止日期在毫秒级范围内，如果错过了，可能会导致打印机卡住，有人必须去修理。偶尔卡纸是可以接受的，但没有人会购买一台不断卡纸的打印机。'
- en: '**Printing sell-by dates on bottles on a production line**: If one bottle is
    not printed the whole production line has to be halted, the bottle removed and
    the line restarted, which is expensive.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在生产线上的瓶子上打印保质期**：如果一个瓶子没有被打印，整个生产线必须停止，瓶子被移除，然后重新启动生产线，这是昂贵的。'
- en: '**Baking a cake**: There is a deadline of 30 minutes or so. If you miss it
    by a few minutes, the cake might be ruined. If you miss it by a large amount,
    the house will burn down.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**烘烤蛋糕**：有大约30分钟的截止日期。如果你迟到了几分钟，蛋糕可能会被毁掉。如果你迟到了很长时间，房子就会烧毁。'
- en: '**A power surge detection system**: If the system detects a surge, a circuit
    breaker has to be triggered within 2 milliseconds. Failing to do so causes damage
    to the equipment and may injure or kill personnel.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电力浪涌检测系统**：如果系统检测到浪涌，必须在2毫秒内触发断路器。未能这样做会损坏设备，并可能伤害或杀死人员。'
- en: 'In other words, there are many consequences to missed deadlines. We often talk
    about these different categories:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，错过截止日期会有许多后果。我们经常谈论这些不同的类别：
- en: '**soft real-time**: The deadline is desirable but is sometimes missed without
    the system being considered a failure. First two examples are like this.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软实时：截止日期是可取的，但有时会错过而系统不被视为失败。前两个例子就是这样。
- en: '**hard real-time**: Here, missing a deadline has a serious effect. We can further
    subdivide hard real-time into mission-critical systems in which there is a cost
    to missing the deadline, such as the fourth example, and safety critical-systems
    in which there is a danger to life and limb, such as the last two examples. I
    put in the banking example to show that not all hard real-time systems have deadlines
    measured in microseconds.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬实时：在这里，错过截止日期会产生严重影响。我们可以进一步将硬实时细分为在错过截止日期会产生成本的关键任务系统，比如第四个例子，以及在错过截止日期会对生命和肢体造成危险的安全关键系统，比如最后两个例子。我提出银行的例子是为了表明，并非所有硬实时系统的截止日期都是以微秒计量的。
- en: Software written for safety-critical systems has to conform to various standards
    that seek to ensure that it is capable of performing reliably. It is very difficult
    for a complex operating system such as Linux to meet those requirements.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为安全关键系统编写的软件必须符合各种标准，以确保其能够可靠地执行。对于像Linux这样复杂的操作系统来说，要满足这些要求非常困难。
- en: When it comes to mission-critical systems, it is possible, and common, for Linux
    to be used for a wide range of control systems. The requirements of the software
    depend on the combination of the deadline and the confidence level, which can
    usually be determined through extensive testing.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在关键任务系统中，Linux通常可以用于各种控制系统，这是可能的，也是常见的。软件的要求取决于截止日期和置信水平的组合，这通常可以通过广泛的测试来确定。
- en: Therefore, to say that a system is real-time, you have to measure its response
    times under the maximum anticipated load, and show that it meets the deadline
    for an agreed proportion of the time. As a rule of thumb, a well configured Linux
    system using a mainline kernel is good for soft real-time tasks with deadlines
    down to tens of milliseconds and a kernel with the `PREEMPT_RT` patch is good
    for soft and hard real-time mission-critical systems with deadlines down to several
    hundreds of microseconds.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要说一个系统是实时的，你必须在最大预期负载下测量其响应时间，并证明它在约定时间内满足截止日期的比例。作为一个经验法则，使用主线内核的良好配置的Linux系统适用于截止日期为几十毫秒的软实时任务，而使用`PREEMPT_RT`补丁的内核适用于截止日期为几百微秒的软实时和硬实时的关键任务系统。
- en: The key to creating a real-time system is to reduce the variability in response
    times so that you have greater confidence that they will not be missed; in other
    words, you need to make the system more deterministic. Often, this is done at
    the expense of performance. For example, caches make systems run faster by making
    the average time to access an item of data shorter, but the maximum time is longer
    in the case of a cache miss. Caches make a system faster but less deterministic,
    which is the opposite of what we want.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建实时系统的关键是减少响应时间的变化，以便更有信心地确保它们不会被错过；换句话说，你需要使系统更确定性。通常情况下，这是以性能为代价的。例如，缓存通过缩短访问数据项的平均时间来使系统运行得更快，但在缓存未命中的情况下，最大时间更长。缓存使系统更快但不太确定，这与我们想要的相反。
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is a myth of real-time computing that it is fast. This is not so, the more
    deterministic a system is, the lower the maximum throughput.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 实时计算的神话是它很快。事实并非如此，系统越确定性越高，最大吞吐量就越低。
- en: The remainder of this chapter is concerned with identifying the causes of latency
    and the things you can do to reduce it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分关注识别延迟的原因以及您可以采取的措施来减少延迟。
- en: Identifying the sources of non-determinism
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别非确定性的来源
- en: 'Fundamentally, real-time programming is about making sure that the threads
    controlling the output in real-time are scheduled when needed and so can complete
    the job before the deadline. Anything that prevents this is a problem. Here are
    some problem areas:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上说，实时编程是确保实时控制输出的线程在需要时被调度，从而能够在截止日期之前完成工作。任何阻碍这一点的都是问题。以下是一些问题领域：
- en: '**Scheduling**: Real-time threads must be scheduled before others so they must
    have a real-time policy, `SCHED_FIFO`, or `SCHED_RR`. Additionally they should
    have priorities assigned in descending order starting with the one with the shortest
    deadline, according to the theory of Rate Monotonic Analysis that I described
    in [Chapter 10](ch10.html "Chapter 10. Learning About Processes and Threads"),
    *Learning About Processes and Threads*.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度：实时线程必须在其他线程之前被调度，因此它们必须具有实时策略，`SCHED_FIFO`或`SCHED_RR`。此外，它们应该按照我在[第10章](ch10.html
    "第10章。了解进程和线程")中描述的速率单调分析理论，按照截止日期最短的顺序分配优先级。
- en: '**Scheduling latency**: The kernel must be able to reschedule as soon as an
    event such as an interrupt or timer occurs, and not be subject to unbounded delays.
    Reducing scheduling latency is a key topic later on in this chapter.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度延迟：内核必须能够在事件（如中断或定时器）发生时立即重新调度，并且不会受到无限延迟的影响。减少调度延迟是本章后面的一个关键主题。
- en: '**Priority inversion**: This is a consequence of priority-based scheduling,
    which leads to unbounded delays when a high priority thread is blocked on a mutex
    held by a low priority thread, as I described in [Chapter 10](ch10.html "Chapter 10. Learning
    About Processes and Threads"), *Learning About Processes and Threads*. User space
    has priority inheritance and priority ceiling mutexes; in kernel space we have
    rt-mutexes which implement priority inheritance and which I will talk about in
    the section on the real-time kernel.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先级反转：这是基于优先级的调度的结果，当高优先级线程在低优先级线程持有的互斥锁上被阻塞时，会导致无限延迟，正如我在[第10章](ch10.html "第10章。了解进程和线程")中所描述的，*了解进程和线程*。用户空间具有优先级继承和优先级屏障互斥锁；在内核空间中，我们有实时互斥锁，它实现了优先级继承，我将在实时内核部分讨论它。
- en: '**Accurate timers**: If you want to manage deadlines in the region of low milliseconds
    or microseconds, you need timers that match. High resolution timers are crucial
    and are a configuration option on almost all kernels.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准确的定时器：如果你想要管理毫秒或微秒级别的截止期限，你需要匹配的定时器。高分辨率定时器至关重要，并且几乎所有内核都有配置选项。
- en: '**Page faults**: A page fault while executing a critical section of code will
    upset all timing estimates. You can avoid them by locking memory, as I describe
    later on.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页面错误**：在执行关键代码部分时发生页面错误会破坏所有时间估计。您可以通过锁定内存来避免它们，我稍后会详细描述。'
- en: '**Interrupts**: They occur at unpredictable times and can result in unexpected
    processing overhead if there is a sudden flood of them. There are two ways to
    avoid this. One is to run interrupts as kernel threads, and the other, on multi-core
    devices, is to shield one or more CPUs from interrupt handling. I will discuss
    both possibilities later.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中断**：它们在不可预测的时间发生，并且如果突然出现大量中断，可能会导致意外的处理开销。有两种方法可以避免这种情况。一种是将中断作为内核线程运行，另一种是在多核设备上，将一个或多个CPU屏蔽免受中断处理的影响。我稍后会讨论这两种可能性。'
- en: '**Processor caches**: Provide a buffer between the CPU and the main memory
    and, like all caches, are a source of non-determinism, especially on multi-core
    devices. Unfortunately, this is beyond the scope of this book but, refer to the
    references at the end of the chapter.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器缓存：提供了CPU和主内存之间的缓冲区，并且像所有缓存一样，是非确定性的来源，特别是在多核设备上。不幸的是，这超出了本书的范围，但是可以参考本章末尾的参考资料。
- en: '**Memory bus contention**: When peripherals access memory directly through
    a DMA channel they use up a slice of memory bus bandwidth, which slows down access
    from the CPU core (or cores) and so contributes to non-deterministic execution
    of the program. However, this is a hardware issue and is also beyond the scope
    of this book.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存总线争用**：当外围设备通过DMA通道直接访问内存时，它们会占用一部分内存总线带宽，从而减慢CPU核心（或核心）的访问速度，因此有助于程序的非确定性执行。然而，这是一个硬件问题，也超出了本书的范围。'
- en: I will expand on the important problems and see what can be done about them
    in the next sections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在接下来的章节中扩展重要问题并看看可以采取什么措施。
- en: One item missing from the list is power management. The needs of real-time and
    power management pull in opposite directions. Power management often leads to
    high latencies when switching between sleep states, since setting up power regulators
    and waking up processors all takes time, as does changing the core clock frequency
    because the clocks take time to settle. But, surely you wouldn't expect a device
    to respond immediately to an interrupt from suspend state? I know I can't get
    going in the morning until after at least one cup of coffee.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中缺少的一项是电源管理。实时和电源管理的需求方向相反。在睡眠状态之间切换时，电源管理通常会导致高延迟，因为设置电源调节器和唤醒处理器都需要时间，改变核心时钟频率也需要时间，因为时钟需要时间稳定。但是，你肯定不会期望设备立即从挂起状态响应中断吧？我知道在至少喝一杯咖啡之后我才能开始一天。
- en: Understanding scheduling latency
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解调度延迟
- en: 'Real-time threads need to be scheduled as soon as they have something to do.
    However, even if there are no other threads of the same or higher priority, there
    is always a delay from the point at which the wake up event occurs – an interrupt
    or system timer – to the time that the thread starts to run. This is called scheduling
    latency. It can be broken down into several components, as shown in the following
    diagram:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 实时线程需要在有任务要做时立即调度。然而，即使没有其他相同或更高优先级的线程，从唤醒事件发生的时间点（中断或系统定时器）到线程开始运行的时间总会有延迟。这称为调度延迟。它可以分解为几个组件，如下图所示：
- en: '![Understanding scheduling latency](img/B03982_14_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![理解调度延迟](img/B03982_14_01.jpg)'
- en: Firstly, there is the hardware interrupt latency from the point at which an
    interrupt is asserted until the **ISR** (**interrupt service routine**) begins
    to run. A small part of this is the delay in the interrupt hardware itself but
    the biggest problem is interrupts disabled in the software. Minimizing this *IRQ
    off time* is important.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，硬件中断延迟是指从中断被断言直到**ISR**（中断服务例程）开始运行的时间。其中一小部分是中断硬件本身的延迟，但最大的问题是软件中禁用的中断。最小化这种*IRQ关闭时间*很重要。
- en: The next is interrupt latency, which is the length of time until the ISR has
    serviced the interrupt and woken up any threads waiting on this event. It is mostly
    dependent on the way the ISR was written. Normally it should take only a short
    time, measured in micro-seconds.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是中断延迟，即ISR服务中断并唤醒任何等待此事件的线程所需的时间。这主要取决于ISR的编写方式。通常应该只需要很短的时间，以微秒为单位。
- en: The final delay is the preemption latency, which is the time from the point
    that the kernel is notified that a thread is ready to run to that at which the
    scheduler actually runs the thread. It is determined by whether the kernel can
    be preempted or not. If it is running code in a critical section then the reschedule
    will have to wait. The length of the delay is dependent on the configuration of
    kernel preemption.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个延迟是抢占延迟，即内核被通知线程准备运行的时间点到调度器实际运行线程的时间点。这取决于内核是否可以被抢占。如果它正在运行关键部分的代码，那么重新调度将不得不等待。延迟的长度取决于内核抢占的配置。
- en: Kernel preemption
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核抢占
- en: 'The preemption latency occurs because it is not always safe or desirable to
    preempt the current thread of execution and call the scheduler. Mainline Linux
    has three settings for preemption, selected via the **Kernel Features** | **Preemption
    Model** menu:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 抢占延迟是因为并不总是安全或者希望抢占当前的执行线程并调用调度器。主线Linux有三种抢占设置，通过**内核特性** | **抢占模型**菜单选择：
- en: '`CONFIG_PREEMPT_NONE`: no preemption'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_PREEMPT_NONE`：无抢占'
- en: '`CONFIG_PREEMPT_VOLUNTARY`: enables additional checks for requests for preemption'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_PREEMPT_VOLUNTARY`：启用额外的检查以请求抢占'
- en: '`CONFIG_PREEMPT`: allows the kernel to be preempted'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_PREEMPT`：允许内核被抢占'
- en: With preemption set to `none`, kernel code will continue without rescheduling
    until it either returns via a `syscall` back to user space, where preemption is
    always allowed, or it encounters a sleeping wait which stops the current thread.
    Since it reduces the number of transitions between the kernel and user space and
    may reduce the total number of context switches, this option results in the highest
    throughput at the expense of large preemption latencies. It is the default for
    servers and some desktop kernels where throughput is more important than responsiveness.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 设置为“none”时，内核代码将继续执行，直到通过“syscall”返回到用户空间，其中始终允许抢占，或者遇到停止当前线程的睡眠等待。由于它减少了内核和用户空间之间的转换次数，并可能减少了上下文切换的总数，这个选项以牺牲大的抢占延迟为代价，实现了最高的吞吐量。这是服务器和一些桌面内核的默认设置，其中吞吐量比响应性更重要。
- en: The second option enables more explicit preemption points where the scheduler
    is called if the `need_resched` flag is set, which reduces the worst case preemption
    latencies at the expense of slightly lower throughput. Some distributions set
    this option on desktops.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项启用了更明确的抢占点，如果设置了`need_resched`标志，则调用调度程序，这会以略微降低吞吐量的代价减少最坏情况的抢占延迟。一些发行版在桌面上设置了这个选项。
- en: The third option makes the kernel preemptible, meaning that an interrupt can
    result in an immediate reschedule so long as the kernel is not executing in an
    atomic context, which I will describe in the following section. This reduces worst
    case preemption latencies and, therefore, overall scheduling latencies, to something
    in the order of a few milliseconds on typical embedded hardware. This is often
    described as a soft real-time option and most embedded kernels are configured
    in this way. Of course, there is a small reduction in overall throughput but that
    is usually less important than having more deterministic scheduling for embedded
    devices.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项使内核可抢占，这意味着中断可以导致立即重新调度，只要内核不在原子上下文中执行，我将在下一节中描述。这减少了最坏情况的抢占延迟，因此，总体调度延迟在典型嵌入式硬件上大约为几毫秒。这通常被描述为软实时选项，大多数嵌入式内核都是以这种方式配置的。当然，总体吞吐量会有所减少，但这通常不如对嵌入式设备具有更确定的调度重要。
- en: The real-time Linux kernel (PREEMPT_RT)
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时Linux内核（PREEMPT_RT）
- en: There is a long-standing effort to reduce latencies still further which goes
    by the name of the kernel configuration option for these features, `PREEMPT_RT`.
    The project was started by Ingo Molnar, Thomas Gleixner, and Steven Rostedt and
    has had contributions from many more developers over the years. The kernel patches
    are at [https://www.kernel.org/pub/linux/kernel/projects/rt](https://www.kernel.org/pub/linux/kernel/projects/rt)
    and there is a wiki, including an FAQ (slightly out of date), at [https://rt.wiki.kernel.org](https://rt.wiki.kernel.org).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来一直在努力进一步减少延迟，这个努力被称为内核配置选项的名称为这些功能，`PREEMPT_RT`。该项目由Ingo Molnar、Thomas Gleixner和Steven
    Rostedt发起，并多年来得到了许多其他开发人员的贡献。内核补丁位于[https://www.kernel.org/pub/linux/kernel/projects/rt](https://www.kernel.org/pub/linux/kernel/projects/rt)，并且有一个维基，包括一个FAQ（略有过时），位于[https://rt.wiki.kernel.org](https://rt.wiki.kernel.org)。
- en: Many parts of the project have been incorporated into mainline Linux over the
    years, including high resolution timers, kernel mutexes, and threaded interrupt
    handlers. However, the core patches remain outside of the mainline because they
    are rather intrusive and (some claim) only benefit a small percentage of the total
    Linux user base. Maybe, one day, the whole patch set will be merged upstream.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，项目的许多部分已经并入了主线Linux，包括高分辨率定时器、内核互斥锁和线程中断处理程序。然而，核心补丁仍然留在主线之外，因为它们相当具有侵入性，而且（有人声称）只有很小一部分Linux用户受益。也许，有一天，整个补丁集将被合并到上游。
- en: 'The central plan is to reduce the amount of time the kernel spends running
    in an atomic context, which is where it is not safe to call the scheduler and
    switch to a different thread. Typical atomic contexts are when the kernel:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 中央计划是减少内核在原子上下文中运行的时间，这是不安全调用调度程序并切换到不同线程的地方。典型的原子上下文是内核：
- en: is running an interrupt or trap handler
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在运行中断或陷阱处理程序
- en: is holding a spin lock or in an RCU critical section. Spin lock and RCU are
    kernel locking primitives, the details of which are not relevant here
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持有自旋锁或处于RCU临界区。自旋锁和RCU是内核锁原语，这里的细节并不相关
- en: is between calls to `preempt_disable()` and `preempt_enable()`
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用`preempt_disable()`和`preempt_enable()`之间
- en: hardware interrupts are disabled
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件中断被禁用
- en: 'The changes that are part of `PREEMPT_RT` fall into two main areas: one is
    to reduce the impact of interrupt handlers by turning them into kernel threads
    and the other is to make locks preemptible so that a thread can sleep while holding
    one. It is obvious that there is a large overhead in these changes, which makes
    average case interrupt handling slower but much more deterministic, which is what
    we are striving for.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`PREEMPT_RT`的更改分为两个主要领域：一个是通过将中断处理程序转换为内核线程来减少中断处理程序的影响，另一个是使锁可抢占，以便线程在持有锁的同时可以休眠。很明显，这些更改会带来很大的开销，这使得平均情况下中断处理变慢，但更加确定，这正是我们所追求的。'
- en: Threaded interrupt handlers
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程中断处理程序
- en: 'Not all interrupts are triggers for the real-time tasks but all interrupts
    steal cycles from the real-time task. Threaded interrupt handlers allow a priority
    to be associated with the interrupt and for it to be scheduled at an appropriate
    time as shown in the following diagram:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有中断都是实时任务的触发器，但所有中断都会从实时任务中窃取周期。线程中断处理程序允许将优先级与中断关联，并在适当的时间进行调度，如下图所示：
- en: '![Threaded interrupt handlers](img/B03982_14_02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![线程中断处理程序](img/B03982_14_02.jpg)'
- en: 'If the interrupt handler code is run as a kernel thread there is no reason
    why it cannot be preempted by a user space thread of higher priority, and so the
    interrupt handler does not contribute towards scheduling latency of the user space
    thread. Threaded interrupt handlers have been a feature of mainline Linux since
    2.6.30\. You can request that an individual interrupt handler is threaded by registering
    it with `request_threaded_irq()` in place of the normal `request_irq()`. You can
    make threaded IRQs the default by configuring the kernel with `CONFIG_IRQ_FORCED_THREADING=y`
    which makes all handlers into threads unless they have explicitly prevented this
    by setting the `IRQF_NO_THREAD` flag. When you apply the `PREEMPT_RT` patches,
    interrupts are, by default, configured as threads in this way. Here is an example
    of what you might see:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果中断处理程序代码作为内核线程运行，那么它就没有理由不被优先级更高的用户空间线程抢占，因此中断处理程序不会增加用户空间线程的调度延迟。自2.6.30版起，分线程中断处理程序已成为主线Linux的特性。您可以通过使用`request_threaded_irq()`注册单个中断处理程序来请求将其作为线程化，而不是使用普通的`request_irq()`。您可以通过配置内核使所有处理程序成为线程，将分线程中断设置为默认值`CONFIG_IRQ_FORCED_THREADING=y`，除非它们通过设置`IRQF_NO_THREAD`标志明确阻止了这一点。当您应用`PREEMPT_RT`补丁时，默认情况下会将中断配置为线程。以下是您可能看到的示例：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this case, a BeagleBone running `linux-yocto-rt`, only the `gp_timer` interrupt
    was not threaded. It is normal that the timer interrupt handler be run in-line.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，运行`linux-yocto-rt`的BeagleBone只有`gp_timer`中断没有被线程化。定时器中断处理程序以内联方式运行是正常的。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the interrupt threads have all been given the default policy `SCHED_FIFO`
    and a priority of `50`. It doesn't make sense to leave them with the defaults,
    however; now is your chance to assign priorities according to the importance of
    the interrupts compared to real-time user space threads.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，中断线程都已被赋予默认策略`SCHED_FIFO`和优先级`50`。然而，将它们保留为默认值是没有意义的；现在是您根据中断的重要性与实时用户空间线程相比分配优先级的机会。
- en: 'Here is a suggested order of descending thread priorities:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是建议的降序线程优先级顺序：
- en: The POSIX timers thread, `posixcputmr`, should always have the highest priority.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX计时器线程`posixcputmr`应始终具有最高优先级。
- en: Hardware interrupts associated with the highest priority real-time thread.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与最高优先级实时线程相关的硬件中断。
- en: The highest priority real-time thread.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最高优先级的实时线程。
- en: Hardware interrupts for the progressively lower priority real-time threads followed
    by the thread itself.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐渐降低优先级的实时线程的硬件中断，然后是线程本身。
- en: Hardware interrupts for non-real-time interfaces.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非实时接口的硬件中断。
- en: The soft IRQ daemon, `ksoftirqd`, which on RT kernels is responsible for running
    delayed interrupt routines and, prior to Linux 3.6, was responsible for running
    the network stack, the block I/O layer, and other things. You may need to experiment
    with different priority levels to get a balance.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软中断守护程序`ksoftirqd`，在RT内核上负责运行延迟中断例程，并且在Linux 3.6之前负责运行网络堆栈、块I/O层和其他内容。您可能需要尝试不同的优先级级别以获得平衡。
- en: 'You can change the priorities using the `chrt` command as part of the boot
    script, using a command like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`chrt`命令作为引导脚本的一部分来更改优先级，使用类似以下的命令：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `pgrep` command is part of the `procps` package.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`pgrep`命令是`procps`软件包的一部分。'
- en: Preemptible kernel locks
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可抢占内核锁
- en: Making the majority of kernel locks preemptible is the most intrusive change
    that `PREEMPT_RT` makes and this code remains outside of the mainline kernel.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使大多数内核锁可抢占是`PREEMPT_RT`所做的最具侵入性的更改，这段代码仍然在主线内核之外。
- en: 'The problem occurs with spinlocks, which are used for much of the kernel locking.
    A spinlock is a busy-wait mutex which does not require a context switch in the
    contended case and so is very efficient as long as the lock is held for a short
    time. Ideally, they should be locked for less than the time it would take to reschedule
    twice. The following diagram shows threads running on two different CPUs contending
    the same spinlock. **CPU0** gets it first, forcing **CPU1** to spin, waiting until
    it is unlocked:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出现在自旋锁上，它们用于大部分内核锁定。自旋锁是一种忙等待互斥锁，在争用情况下不需要上下文切换，因此只要锁定时间很短，它就非常高效。理想情况下，它们应该被锁定的时间少于两次重新调度所需的时间。以下图表显示了在两个不同CPU上运行的线程争用相同自旋锁的情况。**CPU0**首先获得它，迫使**CPU1**自旋，等待直到它被解锁：
- en: '![Preemptible kernel locks](img/B03982_14_03.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![可抢占内核锁](img/B03982_14_03.jpg)'
- en: The thread that holds the spinlock cannot be preempted since doing so may make
    the new thread enter the same code and deadlock when it tries to lock the same
    spinlock. Consequently, in mainline Linux, locking a spinlock disables kernel
    preemption, creating an atomic context. This means that a low priority thread
    that holds a spinlock can prevent a high priority thread from being scheduled.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 持有自旋锁的线程不能被抢占，因为这样做可能会使新线程进入相同的代码并在尝试锁定相同自旋锁时发生死锁。因此，在主线Linux中，锁定自旋锁会禁用内核抢占，创建原子上下文。这意味着持有自旋锁的低优先级线程可以阻止高优先级线程被调度。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The solution adopted by `PREEMPT_RT` is to replace almost all spinlocks with
    rt-mutexes. A mutex is slower than a spinlock but it is fully preemptible. Not
    only that, but rt-mutexes implement priority inheritance and so are not susceptible
    to priority inversion.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`PREEMPT_RT`采用的解决方案是用rt-mutexes几乎替换所有自旋锁。互斥锁比自旋锁慢，但是完全可抢占。不仅如此，rt-mutexes实现了优先级继承，因此不容易发生优先级反转。'
- en: Getting the PREEMPT_RT patches
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取PREEMPT_RT补丁
- en: 'The RT developers do not create patch sets for every kernel version because
    of the amount of effort involved. On average, they create patches for every other
    kernel. The most recent kernels that are supported at the time of writing are
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: RT开发人员不会为每个内核版本创建补丁集，因为这需要大量的工作。平均而言，他们为每个其他内核创建补丁。在撰写本文时支持的最新内核版本如下：
- en: 4.1-rt
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.1-rt
- en: 4.0-rt
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.0-rt
- en: 3.18-rt
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3.18-rt
- en: 3.14-rt
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3.14-rt
- en: 3.12-rt
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3.12-rt
- en: 3.10-rt
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3.10-rt
- en: The patches are available at [https://www.kernel.org/pub/linux/kernel/projects/rt](https://www.kernel.org/pub/linux/kernel/projects/rt).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些补丁可以在[https://www.kernel.org/pub/linux/kernel/projects/rt](https://www.kernel.org/pub/linux/kernel/projects/rt)上找到。
- en: 'If you are using the Yocto Project, there is an `rt` version of the kernel
    already. Otherwise, it is possible that the place you got your kernel from already
    has the `PREEMPT_RT` patch applied. Otherwise, you will have to apply the patch
    yourself. Firstly, make sure that the `PREEMPT_RT` patch version and your kernel
    version match exactly, otherwise you will not be able to apply the patches cleanly.
    Then you apply it in the normal way, as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Yocto项目，那么内核已经有了`rt`版本。否则，您获取内核的地方可能已经应用了`PREEMPT_RT`补丁。否则，您将不得不自己应用补丁。首先确保`PREEMPT_RT`补丁版本与您的内核版本完全匹配，否则您将无法干净地应用补丁。然后按照正常方式应用，如下所示：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will then be able to configure the kernel with `CONFIG_PREEMPT_RT_FULL`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将能够使用`CONFIG_PREEMPT_RT_FULL`配置内核。
- en: There is a problem in the last paragraph. The RT patch will only apply if you
    are using a compatible mainline kernel. You are probably not because that is the
    nature of embedded Linux kernels and so you will have to spend some time looking
    at failed patches and fixing them, and then analyzing the board support for your
    target and adding any real-time support that is missing. These details are, once
    again, outside the scope of this book. If you are not sure what to do, you should
    inquire of the developers of the kernel you are using and on kernel developer's
    forums.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一段有一个问题。RT补丁只有在使用兼容的主线内核时才会应用。您可能不会使用兼容的内核，因为这是嵌入式Linux内核的特性，因此您将不得不花一些时间查看失败的补丁并修复它们，然后分析您的目标的板支持并添加任何缺失的实时支持。这些细节再次超出了本书的范围。如果您不确定该怎么做，您应该向您正在使用的内核的开发人员和内核开发人员论坛咨询。
- en: The Yocto Project and PREEMPT_RT
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Yocto项目和PREEMPT_RT
- en: 'The Yocto Project supplies two standard kernel recipes: `linux-yocto` and `linux-yoco-rt`,
    the latter having the real-time patches already applied. Assuming that your target
    is supported by these kernels, then you just need to select `linux-yocto-rt` as
    your preferred kernel and declare that your machine is compatible, for example,
    by adding lines similar to these to your `conf/local.conf`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto项目提供了两个标准的内核配方：`linux-yocto`和`linux-yoco-rt`，后者已经应用了实时补丁。假设您的目标受到这些内核的支持，那么您只需要选择`linux-yocto-rt`作为首选内核，并声明您的设备兼容，例如，通过向您的`conf/local.conf`添加类似以下的行：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: High resolution timers
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高分辨率定时器
- en: Timer resolution is important if you have precise timing requirements which
    is typical for real-time applications. The default timer in Linux is a clock that
    runs at a configurable rate, typically 100 Hz for embedded systems and 250 Hz
    for servers and desktops. The interval between two timer ticks is known as a **jiffy**
    and, in the examples given above, is 10 milliseconds on an embedded SoC and four
    milliseconds on a server.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有精确的定时要求，这在实时应用程序中很典型，那么定时器分辨率就很重要。Linux中的默认定时器是以可配置速率运行的时钟，嵌入式系统通常为100赫兹，服务器和台式机通常为250赫兹。两个定时器滴答之间的间隔称为**jiffy**，在上面的示例中，嵌入式SoC上为10毫秒，服务器上为4毫秒。
- en: Linux gained more accurate timers from the real-time kernel project in version
    2.6.18 and now they are available on all platforms, providing that there is a
    high resolution timer source and device driver for it – which is almost always
    the case. You need to configure the kernel with `CONFIG_HIGH_RES_TIMERS=y`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Linux在2.6.18版本中从实时内核项目中获得了更精确的定时器，现在它们在所有平台上都可用，只要有高分辨率定时器源和设备驱动程序——这几乎总是如此。您需要使用`CONFIG_HIGH_RES_TIMERS=y`配置内核。
- en: 'With this enabled, all the kernel and user space clocks will be accurate down
    to the granularity of the underlying hardware. Finding the actual clock granularity
    is difficult. The obvious answer is the value provided by `clock_getres(2)` but
    that always claims a resolution of one nanosecond. The `cyclictest` tool that
    I will describe later has an option to analyze the times reported by the clock
    to guess the resolution:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此功能后，所有内核和用户空间时钟都将准确到基础硬件的粒度。找到实际的时钟粒度很困难。显而易见的答案是`clock_getres(2)`提供的值，但它总是声称分辨率为一纳秒。我将在后面描述的`cyclictest`工具有一个选项，用于分析时钟报告的时间以猜测分辨率：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The two methods give rather different numbers, for which I have no good explanation
    but, since both are below one microsecond, I am happy.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法给出了不同的数字，我无法给出一个好的解释，但由于两者都低于一微秒，我很满意。
- en: Avoiding page faults in a real-time application
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在实时应用程序中避免页面错误
- en: A page fault occurs when an application reads or writes memory that is not committed
    to physical memory. It is impossible (or very hard) to predict when a page fault
    will happen so they are another source of non-determinism in computers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序读取或写入未提交到物理内存的内存时，会发生页面错误。不可能（或者非常困难）预测何时会发生页面错误，因此它们是计算机中另一个非确定性的来源。
- en: 'Fortunately, there is a function that allows you to commit all memory for a
    process and lock it down so that it cannot cause a page fault. It is `mlockall(2)`.
    These are its two flags:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个函数可以让您为进程提交所有内存并将其锁定，以便它不会引起页面错误。这就是`mlockall(2)`。这是它的两个标志：
- en: '`MCL_CURRENT`: locks all pages currently mapped'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MCL_CURRENT`：锁定当前映射的所有页面'
- en: '`MCL_FUTURE`: locks pages that are mapped in later'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MCL_FUTURE`：锁定稍后映射的页面'
- en: You usually call `mlockall(2)` during the start up of the application with both
    flags set to lock all current and future memory mappings.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在应用程序启动时调用`mlockall(2)`，同时设置两个标志以锁定所有当前和未来的内存映射。
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that `MCL_FUTURE` is not magic in that there will still be non-deterministic
    delay when allocating or freeing heap memory using `malloc()/free()` or `mmap()`.
    Such operations are best done at start up and not in the main control loops.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`MCL_FUTURE`并不是魔法，使用`malloc()/free()`或`mmap()`分配或释放堆内存时仍会存在非确定性延迟。这些操作最好在启动时完成，而不是在主控循环中完成。
- en: 'Memory allocated on the stack is trickier because it is done automatically
    and if you call a function that makes the stack deeper than before, you will encounter
    more memory management delays. A simple fix is to grow the stack to a size larger
    than you think you will ever need at start up. The code would look like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆栈上分配的内存更加棘手，因为它是自动完成的，如果您调用一个使堆栈比以前更深的函数，您将遇到更多的内存管理延迟。一个简单的解决方法是在启动时将堆栈增大到比您预期需要的更大的尺寸。代码看起来像这样：
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `stack_grow()` function allocates a large variable on the stack and then
    zeroes it to force those pages of memory to be committed to this process.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`stack_grow()`函数在堆栈上分配一个大变量，然后将其清零，以强制将这些内存页分配给该进程。'
- en: Interrupt shielding
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断屏蔽
- en: Using threaded interrupt handlers helps mitigate interrupt overhead by running
    some threads at a higher priority than interrupt handlers that do not impact the
    real-time tasks. If you are using a multi-core processor, you can take a different
    approach and shield one or more cores from processing interrupts completely, allowing
    them to be dedicated to real-time tasks instead. This works either with a normal
    Linux kernel or a `PREEMPT_RT` kernel.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程化中断处理程序有助于通过以比不影响实时任务的中断处理程序更高的优先级运行一些线程来减轻中断开销。如果您使用多核处理器，您可以采取不同的方法，完全屏蔽一个或多个核心的处理中断，从而使它们专用于实时任务。这适用于普通的Linux内核或`PREEMPT_RT`内核。
- en: Achieving this is a question of pinning the real-time threads to one CPU and
    the interrupt handlers to a different one. You can set the CPU affinity off a
    thread or process using the command line tool `taskset`, or you can use the `sched_setaffinity(2)`
    and `pthread_setaffinity_np(3)` functions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的关键是将实时线程固定到一个CPU，将中断处理程序固定到另一个CPU。您可以使用命令行工具`taskset`设置线程或进程的CPU亲和性，也可以使用`sched_setaffinity(2)`和`pthread_setaffinity_np(3)`函数。
- en: To set the affinity of an interrupt, first note that there is a subdirectory
    for each interrupt number in `/proc/irq/<IRQ number>`. The control files for the
    interrupt are in there, including a CPU mask in `smp_affinity`. Write a bitmask
    to that file with a bit set for each CPU that is allowed to handle that IRQ.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置中断的亲和性，首先注意`/proc/irq/<IRQ number>`中有每个中断号的子目录。其中包括中断的控制文件，包括`smp_affinity`中的CPU掩码。向该文件写入一个位掩码，其中每个允许处理该IRQ的CPU都设置了一个位。
- en: Measuring scheduling latencies
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测量调度延迟
- en: 'All the configuration and tuning you may do will be pointless if you cannot
    show that your device meets the deadlines. You will need your own benchmarks for
    the final testing but I will describe here two important measurement tools: `cyclictest`
    and `Ftrace`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能进行的所有配置和调整都将是无意义的，如果您不能证明您的设备满足截止日期。最终测试需要您自己的基准测试，但我将在这里描述两个重要的测量工具：`cyclictest`和`Ftrace`。
- en: cyclictest
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cyclictest
- en: '`cyclictest` was originally written by Thomas Gleixner and is now available
    on most platforms in a package named `rt-tests`. If you are using the Yocto Project,
    you can create a target image that includes `rt-tests` by building the real-time
    image recipe like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`cyclictest` 最初由Thomas Gleixner编写，现在在大多数平台上都可以在名为`rt-tests`的软件包中使用。如果您使用Yocto
    Project，可以通过构建实时镜像配方来创建包含`rt-tests`的目标镜像，方法如下：'
- en: '[PRE6]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you are using Buildroot, you need to add the package, `BR2_PACKAGE_RT_TESTS`
    in the menu **Target packages** | **Debugging, profiling and benchmark** | **rt-tests**.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Buildroot，您需要在菜单**目标软件包** | **调试、性能分析和基准测试** | **rt-tests**中添加软件包`BR2_PACKAGE_RT_TESTS`。
- en: '`cyclictest` measures scheduling latencies by comparing the actual time taken
    for a sleep to the requested time. If there was no latency they would be the same
    and the reported latency would be zero. `cyclictest` assumes a timer resolution
    of less than one microsecond.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`cyclictest` 通过比较实际休眠所需的时间和请求的时间来测量调度延迟。如果没有延迟，它们将是相同的，报告的延迟将为零。`cyclictest`
    假设定时器分辨率小于一微秒。'
- en: 'It has a large number of command-line options. To start with, you might try
    running this command as root on the target:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 它有大量的命令行选项。首先，您可以尝试在目标上以root身份运行此命令：
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The options selected are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所选的选项如下：
- en: '`-l N`: loop N times: the default is unlimited'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-l N`: 循环N次：默认为无限'
- en: '`-m`: lock memory with mlockall'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-m`: 使用mlockall锁定内存'
- en: '`-n`: use `clock_nanosleep(2)` instead of `nanosleep(2)`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-n`: 使用`clock_nanosleep(2)`而不是`nanosleep(2)`'
- en: '`-p N`: use the real-time priority `N`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p N`: 使用实时优先级`N`'
- en: 'The result line shows the following, reading from left to right:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 结果行从左到右显示以下内容：
- en: '`T: 0`: this was thread 0, the only thread in this run. You can set the number
    of threads with parameter `-t`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T: 0`: 这是线程0，这次运行中唯一的线程。您可以使用参数`-t`设置线程数。'
- en: '`(320)`: this was PID 320.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(320)`: 这是PID 320。'
- en: '`P:99`: the priority was 99.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P:99`: 优先级为99。'
- en: '`I:1000`: the interval between loops was 1,000 microseconds. You can set the
    interval with parameter `-i N`.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`I:1000`: 循环之间的间隔为1,000微秒。您可以使用参数`-i N`设置间隔。'
- en: '`C:100000`: the final loop count for this thread was 100,000.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C:100000`: 该线程的最终循环计数为100,000。'
- en: '`Min: 9`: the minimum latency was 9 microseconds.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Min: 9`: 最小延迟为9微秒。'
- en: '`Act:13`: the actual latency was 13 microseconds. The actual latency is the
    most recent latency measurement, which only makes sense if you are watching `cyclictest`
    run.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Act:13`: 实际延迟为13微秒。实际延迟是最近的延迟测量，只有在观察`cyclictest`运行时才有意义。'
- en: '`Avg:15`: the average latency was 15 microseconds.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Avg:15`: 平均延迟为15微秒。'
- en: '`Max:134`: the maximum latency was 134 microseconds.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Max:134`: 最大延迟为134微秒。'
- en: This was obtained on an idle system running an unmodified `linux-yocto` kernel
    as a quick demonstration of the tool. To be of real use, you would run tests over
    a 24 hour period or more while running a load representative of the maximum you
    expect.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在运行未修改的`linux-yocto`内核的空闲系统上获得的，作为该工具的快速演示。要真正有用，您需要在运行负载代表您期望的最大负载的同时，进行24小时或更长时间的测试。
- en: 'Of the numbers produced by `cyclictest`, the maximum latency is the most interesting,
    but it would be nice to get an idea of the spread of the values. You can get that
    by adding `-h <N>` to obtain a histogram of samples that are up to `N` microseconds
    late. Using this technique, I obtained three traces for the same target board
    running kernels with no preemption, with standard preemption, and with RT preemption
    while being loaded with Ethernet traffic from a flood ping. The command line was
    as shown here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`cyclictest`生成的数字中，最大延迟是最有趣的，但了解值的分布也很重要。您可以通过添加`-h <N>`来获得最多迟到`N`微秒的样本的直方图。使用这种技术，我在相同的目标板上运行了没有抢占、标准抢占和RT抢占的内核，同时通过洪水ping加载以太网流量，获得了三个跟踪。命令行如下所示：'
- en: '[PRE8]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the output generated with no preemption:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是没有抢占生成的输出：
- en: '![cyclictest](img/B03982_14_04.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![cyclictest](img/B03982_14_04.jpg)'
- en: Without preemption, most samples are within 100 microseconds of the deadline,
    but there are some outliers of up to 500 microseconds, which is pretty much what
    you would expect.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 没有抢占时，大多数样本在截止日期之前100微秒内，但有一些离群值高达500微秒，这基本上是您所期望的。
- en: 'This is the output generated with standard preemption:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用标准抢占生成的输出：
- en: '![cyclictest](img/B03982_14_05.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![cyclictest](img/B03982_14_05.jpg)'
- en: With preemption, the samples are spread out at the lower end but there is nothing
    beyond 120 microseconds.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有抢占时，样本在较低端分布，但没有超过120微秒的情况。
- en: 'Here is the output generated with RT preemption:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用RT抢占生成的输出：
- en: '![cyclictest](img/B03982_14_06.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![cyclictest](img/B03982_14_06.jpg)'
- en: The RT kernel is a clear winner because everything is tightly bunched around
    the 20 microsecond mark and there is nothing later than 35 microseconds.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: RT内核是明显的赢家，因为一切都紧密地集中在20微秒左右，没有超过35微秒的情况。
- en: '`cyclictest`, then, is a standard metric for scheduling latencies. However,
    it cannot help you identify and resolve specific problems with kernel latency.
    To do that, you need `Ftrace`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`cyclictest`是调度延迟的标准度量。但它无法帮助您识别和解决内核延迟的特定问题。为此，您需要`Ftrace`。
- en: Using Ftrace
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ftrace
- en: 'The kernel function tracer has tracers to help track down kernel latencies—that
    is what it was originally written for, after all. These tracers capture the trace
    for the worst case latency detected during a run, showing the functions that caused
    the delay. The tracers of interest, together with the kernel configuration parameters,
    are as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 内核函数跟踪器有跟踪器可帮助跟踪内核延迟，这也是它最初编写的目的。这些跟踪器捕获了在运行过程中检测到的最坏情况延迟的跟踪，显示导致延迟的函数。感兴趣的跟踪器以及内核配置参数如下：
- en: '`irqsoff`: `CONFIG_IRQSOFF_TRACER` traces code that disables interrupts, recording
    the worst case'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irqsoff`：`CONFIG_IRQSOFF_TRACER`跟踪禁用中断的代码，记录最坏情况'
- en: '`preemptoff`: `CONFIG_PREEMPT_TRACER` is similar to `irqsoff`, but traces the
    longest time that kernel preemeption is disabled (only available on preemptible
    kernels)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preemptoff`：`CONFIG_PREEMPT_TRACER`类似于`irqsoff`，但跟踪内核抢占被禁用的最长时间（仅适用于可抢占内核）'
- en: '`preemptirqsoff`: it combines the previous two traces to record the largest
    time either `irqs` and/or preemption is disabled'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preemptirqsoff`：它结合了前两个跟踪，记录了禁用`irqs`和/或抢占的最长时间'
- en: '`wakeup`: traces and records the maximum latency that it takes for the highest
    priority task to get scheduled after it has been woken up'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wakeup`：跟踪并记录唤醒后最高优先级任务被调度所需的最大延迟'
- en: '`wakeup_rt`: the same as wake up but only for real-time threads with the `SCHED_FIFO`,
    `SCHED_RR`, or `SCHED_DEADLINE` policies'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wakeup_rt`：与唤醒相同，但仅适用于具有`SCHED_FIFO`、`SCHED_RR`或`SCHED_DEADLINE`策略的实时线程'
- en: '`wakeup_dl`: the same but only for deadline-scheduled threads with the `SCHED_DEADLINE`
    policy'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wakeup_dl`：与唤醒相同，但仅适用于具有`SCHED_DEADLINE`策略的截止线程'
- en: Be aware that running `Ftrace` adds a lot of latency, in the order of tens of
    milliseconds, every time it captures a new maximum which `Ftrace` itself can ignore.
    However, it skews the results of user-space tracers such as `cyclictest`. In other
    words, ignore the results of `cyclictest` if you run it while capturing traces.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，运行`Ftrace`会增加大量延迟，每次捕获新的最大值时，`Ftrace`本身可以忽略。但是，它会扭曲用户空间跟踪器（如`cyclictest`）的结果。换句话说，如果您在捕获跟踪时运行`cyclictest`，请忽略其结果。
- en: 'Selecting the tracer is the same as for the function tracer we looked at in
    [Chapter 13](ch13.html "Chapter 13. Profiling and Tracing"), *Profiling and Tracing*.
    Here is an example of capturing a trace for the maximum period with preemption
    disabled for a period of 60 seconds:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 选择跟踪器与我们在[第13章](ch13.html "第13章。性能分析和跟踪")中看到的函数跟踪器相同，*性能分析和跟踪*。以下是捕获禁用抢占的最长时间的跟踪60秒的示例：
- en: '[PRE9]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The resulting trace, heavily edited, looks like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的跟踪，经过大量编辑，看起来像这样：
- en: '[PRE10]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, you can see that the longest period with kernel preemption disabled while
    running the trace was 1,160 microseconds. This simple fact is available by reading
    `/sys/kernel/debug/tracing/tracing_max_latency`, but the trace above goes further
    and gives you the sequence of kernel function calls that lead up to that measurement.
    The column marked `delay` shows the point on the trail where each function was
    called, ending with the call to `trace_preempt_on()` at `1162us`, at which point
    kernel preemption is once again enabled. With this information, you can look back
    through the call chain and (hopefully) work out if this is a problem or not.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到在运行跟踪时禁用内核抢占的最长时间为1,160微秒。通过阅读`/sys/kernel/debug/tracing/tracing_max_latency`，可以获得这个简单的事实，但上面的跟踪进一步提供了导致该测量的内核函数调用序列。标记为`delay`的列显示了每个函数被调用的时间，最后一次调用是在`1162us`时的`trace_preempt_on()`，在这一点上内核抢占再次被启用。有了这些信息，您可以回顾调用链，并（希望）弄清楚这是否是一个问题。
- en: The other tracers mentioned work in the same way.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 提到的其他跟踪器工作方式相同。
- en: Combining cyclictest and Ftrace
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合cyclictest和Ftrace
- en: If `cyclictest` reports unexpectedly long latencies you can use the `breaktrace`
    option to abort the program and trigger `Ftrace` to obtain more information.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`cyclictest`报告出现意外长的延迟，您可以使用`breaktrace`选项中止程序并触发`Ftrace`以获取更多信息。
- en: 'You invoke breaktrace using `-b<N>` or `--breaktrace=<N>` where `N` is the
    number of microseconds of latency that will trigger the trace. You select the
    `Ftrace` tracer using `-T[tracer name]` or one of the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`-b<N>`或`--breaktrace=<N>`来调用breaktrace，其中`N`是将触发跟踪的延迟的微秒数。您可以使用`-T[tracer
    name]`或以下之一选择`Ftrace`跟踪器：
- en: '`-C`: context switch'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-C`：上下文切换'
- en: '`-E`: event'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-E`：事件'
- en: '-`f`: function'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -`f`：函数
- en: '`-w`: wakeup'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-w`：唤醒'
- en: '`-W`: wakeup-rt'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-W`：唤醒-rt'
- en: 'For example, this will trigger the `Ftrace` function tracer when a latency
    greater than 100 microseconds is measured:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当测量到大于100微秒的延迟时，这将触发`Ftrace`函数跟踪器：
- en: '[PRE11]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Further reading
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following resources have further information about the topics introduced
    in this chapter:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源提供了有关本章介绍的主题的更多信息：
- en: '*Hard Real-Time Computing Systems: Predictable Scheduling Algorithms and Applications*
    by *Buttazzo*, *Giorgio*, *Springer*, 2011'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*硬实时计算系统：可预测的调度算法和应用*，作者*Buttazzo*，*Giorgio*，*Springer*，2011'
- en: '*Multicore Application Programming* by *Darryl Gove*, *Addison Wesley*, 2011'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多核应用程序编程*，作者*Darryl Gove*，*Addison Wesley*，2011'
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The term real-time is meaningless unless you qualify it with a deadline and
    an acceptable miss rate. When you know that you can determine whether or not Linux
    is a suitable candidate for the operating system and, if so, begin to tune your
    system to meet the requirements. Tuning Linux and your application to handle real-time
    events means making it more deterministic so that it can process data reliably
    inside deadlines. Determinism usually comes at the price of total throughput so
    a real-time system is not going to be able to process as much data as a non-real-time
    system.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 实时这个术语是没有意义的，除非您用截止日期和可接受的错过率来限定它。当您知道这一点时，您可以确定Linux是否适合作为操作系统的候选，并且开始调整系统以满足要求。调整Linux和您的应用程序以处理实时事件意味着使其更具确定性，以便它可以在截止日期内可靠地处理数据。确定性通常是以总吞吐量为代价的，因此实时系统无法处理与非实时系统一样多的数据。
- en: It is not possible to provide mathematical proof that a complex operating system
    like Linux will always meet a given deadline, so the only approach is through
    extensive testing using tools such as `cyclictest` and `Ftrace`, and, more importantly,
    using your own benchmarks for your own application.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能提供数学证明，证明像Linux这样的复杂操作系统总是能满足给定的截止日期，因此唯一的方法是通过使用`cyclictest`和`Ftrace`等工具进行广泛测试，更重要的是使用您自己的应用程序的基准测试。
- en: To improve determinism, you need to consider both the application and the kernel.
    When writing real-time applications, you should follow the guidelines given in
    this chapter about scheduling, locking, and memory.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高确定性，您需要考虑应用程序和内核。在编写实时应用程序时，您应该遵循本章关于调度、锁定和内存的指导方针。
- en: The kernel has a large impact on the determinism of your system. Thankfully,
    there has been a lot of work on this over the years. Enabling kernel preemption
    is a good first step. If you still find that it is missing deadlines more often
    than you would like, then you might want to consider the `PREEMPT_RT` kernel patches.
    They can certainly produce low latencies but the fact that they are not in mainline
    yet means that you may have problems integrating them with the vendor kernel for
    your particular board. You may instead, or in addition, need to embark on the
    exercise of finding the cause of the latencies using `Ftrace` and similar tools.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 内核对系统的确定性有很大影响。幸运的是，多年来已经进行了大量工作。启用内核抢占是一个很好的第一步。如果您发现它错过截止日期的频率比您想要的要高，那么您可能需要考虑`PREEMPT_RT`内核补丁。它们确实可以产生低延迟，但它们尚未纳入主线内核，这意味着您可能在将它们与特定板子的供应商内核集成时遇到问题。您可能需要使用`Ftrace`和类似工具来找出延迟的原因。
- en: That brings me to the end of this dissection of embedded Linux. Being an engineer
    of embedded systems requires a very wide range of skills, which range from a low
    level knowledge of hardware, how the system bootstrap works and how the kernel
    interacts with it, to being an excellent system engineer who is able to configure
    user applications and tune them to work in an efficient manner. All of this has
    to be done with hardware that is, almost always, only just capable of the task.
    There is a quotation that sums this up, *An engineer can do for a dollar what
    anyone else can do for two*. I hope that you will be able to achieve that with
    the information I have presented during the course of this book.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我对嵌入式Linux的剖析的结束。作为嵌入式系统工程师需要具备广泛的技能，从对硬件的低级了解，系统引导程序的工作原理以及内核与其交互的方式，到成为一个能够配置用户应用程序并调整其以高效方式运行的优秀系统工程师。所有这些都必须在几乎总是只能胜任任务的硬件上完成。有一句话概括了这一切，“一个工程师可以用一美元做到别人用两美元才能做到的事情”。我希望您能够通过我在本书中提供的信息实现这一点。
