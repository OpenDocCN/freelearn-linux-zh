- en: Chapter 3. File In, File Out
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。文件输入，文件输出
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Generating files of any size
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成任意大小的文件
- en: Intersection and set difference (A-B) on text files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本文件上的交集和集差（A-B）
- en: Finding and deleting duplicate files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找和删除重复文件
- en: Making directories for a long path
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为长路径创建目录
- en: File permissions, ownership and sticky bit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件权限、所有权和粘性位
- en: Making files immutable
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使文件不可变
- en: Generating blank files in bulk
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量生成空白文件
- en: Finding symbolic links and its target
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找符号链接及其目标
- en: Enumerating file type statistics
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列举文件类型统计
- en: Loopback files and mounting
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回环文件和挂载
- en: Creating ISO files, Hybrid ISO
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建ISO文件，混合ISO
- en: Finding difference between files, patching
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找文件之间的差异，打补丁
- en: head and tail - printing the last or first 10 lines
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头和尾-打印最后或前10行
- en: Listing only directories - alternative methods
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅列出目录-替代方法
- en: Fast command line directory navigation using pushd and popd
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pushd和popd进行快速命令行目录导航
- en: Counting the number of lines, words, and characters in a file
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算文件中的行数、单词数和字符数
- en: Printing directory tree
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印目录树
- en: Introduction
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: UNIX treats every object in the operating system as a file. We can find the
    files associated with every action performed and can make use of them for different
    system- or process-related manipulations. For example, the command terminal that
    we use is associated with a device file. We can write to the terminal by writing
    to the corresponding device file for that specific terminal. Files take different
    forms such as directories, regular files, block devices, character special devices,
    symbolic links, sockets, named pipes, and so on. Filename, size, file type, modification
    time, access time, change time, inode, links associated, and the filesystem the
    file is on are all attributes and properties that files can have. This chapter
    deals with recipes that handle any of the operations or properties related to
    files.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX将操作系统中的每个对象都视为文件。我们可以找到与执行的每个操作相关联的文件，并可以利用它们进行不同的系统或进程相关的操作。例如，我们使用的命令终端与设备文件相关联。我们可以通过向特定终端的相应设备文件写入来写入终端。文件可以采用不同的形式，如目录、常规文件、块设备、字符特殊设备、符号链接、套接字、命名管道等。文件名、大小、文件类型、修改时间、访问时间、更改时间、inode、关联的链接以及文件所在的文件系统都是文件可能具有的属性和属性。本章涉及处理与文件相关的任何操作或属性的配方。
- en: Generating files of any size
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成任意大小的文件
- en: For various reasons, you may need to generate a file filled with random data.
    It may be for creating a test file to perform tests, such as an application efficiency
    test that uses a large file as input, or to test the splitting of files into many,
    or to create loopback filesystems (loopback files are files that can contain a
    filesystem itself and these files can be mounted similar to a physical device
    using the `mount` command). It is hard to create such files by writing specific
    programs. So we use general utilities.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 出于各种原因，您可能需要生成一个填充有随机数据的文件。这可能是为了创建一个用于执行测试的测试文件，例如使用大文件作为输入的应用程序效率测试，或者测试将文件拆分成多个文件，或者创建回环文件系统（回环文件是可以包含文件系统本身的文件，这些文件可以类似于使用`mount`命令挂载物理设备）。通过编写特定的程序来创建这样的文件是很困难的。因此，我们使用通用实用程序。
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The easiest way to create a large sized file with a given size is to use the
    `dd` command. The `dd` command clones the given input and writes an exact copy
    to the output. Input can be `stdin`, a device file, a regular file, or so on.
    Output can be `stdout`, a device file, a regular file, and so on. An example of
    the `dd` command is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dd`命令创建指定大小的大文件是最简单的方法。`dd`命令克隆给定的输入并将精确的副本写入输出。输入可以是`stdin`、设备文件、常规文件等。输出可以是`stdout`、设备文件、常规文件等。`dd`命令的示例如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The above command will create a file called `junk.data` that is exactly 1MB
    in size. Let''s go through the parameters: `if` stands for `– input` file, `of`
    stands for `– output` file, `bs` stands for BYTES for a block, and `count` stands
    for the number of blocks of `bs` specified to be copied.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将创建一个名为`junk.data`的文件，其大小正好为1MB。让我们来看看参数：`if`代表`- 输入`文件，`of`代表`- 输出`文件，`bs`代表块的字节数，`count`代表要复制的`bs`块数。
- en: Here we are only creating a file 1MB in size by specifying `bs` as 1MB with
    a count of 1\. If `bs` was set to `2M` and a count to 2, the total file size would
    be 4MB.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只通过将`bs`设置为1MB并将计数设置为1来创建一个大小为1MB的文件。如果`bs`设置为`2M`，计数设置为2，则总文件大小将为4MB。
- en: 'We can use various units for **Block** **Size** (**BS**) as follows. Append
    any of the following characters to the number to specify the size in bytes:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下各种单位来指定**块** **大小**（**BS**）。将以下任何字符附加到数字后，以指定以字节为单位的大小：
- en: '| Unit size | Code |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|单位大小|代码|'
- en: '| --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Byte (1B) | `c` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|字节（1B）| `c` |'
- en: '| Word (2B) | `w` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|字（2B）| `w` |'
- en: '| Block (512B) | `b` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '|块（512B）| `b` |'
- en: '| Kilo Byte (1024B) | `k` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '|千字节（1024B）| `k` |'
- en: '| Mega Byte (1024 KB) | `M` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|兆字节（1024 KB）| `M` |'
- en: '| Giga Byte (1024 MB) | `G` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| Giga Byte（1024 MB）| `G` |'
- en: We can generate a file of any size using this. Instead of MB we can use any
    other unit notations such as the ones mentioned in the previous table.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个来生成任意大小的文件。我们可以使用前面表中提到的其他单位符号，而不是MB。
- en: '`/dev/zero` is a character special device, which infinitely returns the zero
    byte (`\0`).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/zero`是一个字符特殊设备，它无限返回零字节（`\0`）。'
- en: If the input parameter (`if`) is not specified, it will read the input from
    `stdin` by default. Similarly, if the output parameter (`of`) is not specified,
    it will use `stdout` as the default output sink.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定输入参数（`if`），它将默认从`stdin`读取输入。同样，如果未指定输出参数（`of`），它将使用`stdout`作为默认输出接收器。
- en: The `dd` command can also be used to measure the speed of memory operations
    by transferring a large quantity of data and checking the command output (for
    example, `1048576 bytes (1.0 MB) copied, 0.00767266 s, 137 MB/s` as seen the previous
    example).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`dd`命令还可用于通过传输大量数据并检查命令输出（例如，`1048576字节（1.0 MB）已复制，0.00767266秒，137 MB/s`，如前面的示例所示）来测量内存操作的速度。'
- en: Intersection and set difference (A-B) on text files
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交集和集合差异（A-B）的文本文件
- en: Intersection and set difference operations are commonly used in mathematical
    classes on set theory. However, similar operations on text are also very helpful
    in some scenarios.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 交集和集合差异操作在集合论数学课上通常被使用。然而，在文本上进行类似的操作在某些情况下也非常有帮助。
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `comm` command is a utility to perform comparison between the two files.
    It has many nice options to arrange the output in such a way that we can perform
    intersection, difference, and set difference operations.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`comm`命令是一个用于比较两个文件的实用程序。它有许多很好的选项，可以安排输出，以便我们可以执行交集、差异和集合差异操作。'
- en: '**Intersection**: The intersection operation will print the lines that the
    specified files have in common with one another.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交集**：交集操作将打印指定文件彼此之间共有的行。'
- en: '**Difference**: The difference operation will print the lines that the specified
    files contain and that are not the same in all of those files.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**差异**：差异操作将打印指定文件包含的行，而这些行在所有这些文件中都不相同。'
- en: '**Set difference**: The set difference operation will print the lines in file
    "A" that do not match those in all of the set of files specified ("B" plus "C"
    for example).'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合差异**：集合差异操作将打印文件“A”中与指定的所有文件集合（例如“B”加“C”）中不匹配的行。'
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Note that `comm` takes sorted files as input. Take a look at the following
    example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`comm`接受排序后的文件作为输入。看一下以下示例：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first column of the output contains lines that are in `A.txt` excluding
    common lines in two files. The second column contains lines that are in `B.txt`
    excluding common lines. The third column contains the common lines from `A.txt`
    and `B.txt`. Each of the columns are delimited by using the tab (`\t`) character.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一列包含了在`A.txt`中的行，不包括两个文件中的共同行。第二列包含了在`B.txt`中的行，不包括共同行。第三列包含了来自`A.txt`和`B.txt`的共同行。每一列都是用制表符（`\t`）分隔的。
- en: 'Some options are available to format the output as per our requirement. For
    example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些选项可用于根据我们的要求格式化输出。例如：
- en: '`-1` removes first column from output'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-1`从输出中删除第一列'
- en: '`-2` removes the second column'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-2`删除第二列'
- en: '`-3` removes the third column'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-3`删除第三列'
- en: 'In order to print the intersection of two files, we need to remove the first
    and second columns and print the third column only as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印两个文件的交集，我们需要删除第一列和第二列，只打印第三列，如下所示：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Print lines that are uncommon in two files as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 打印在两个文件中不常见的行，如下所示：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using the `-3` argument in the `comm` command removes the third column from
    the output. But, it writes column-1 and column-2 to the output. The column-1 contains
    the lines in `A.txt` excluding the lines in `B.txt`. Similarly, column-2 has the
    lines from `B.txt` excluding the lines in `A.txt`. As the output is a two-column
    output, it is not that useful. Columns have their fields blank for each of the
    unique lines. Hence both columns will not have the content on the same line. Either
    one of the two columns will have the content. In order to make it in a usable
    output text format, we need to remove the blank fields and make two columns into
    a single column output as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在`comm`命令中使用`-3`参数可以从输出中删除第三列。但是，它会将第一列和第二列写入输出。第一列包含了`A.txt`中不包括`B.txt`中的行。同样，第二列包含了`B.txt`中不包括`A.txt`中的行。由于输出是双列输出，因此并不是很有用。每个唯一行的列都有空白字段。因此，两列都不会在同一行上有内容。两列中的其中一列将会有内容。为了使其成为可用的输出文本格式，我们需要删除空白字段，并将两列合并为单列输出，如下所示：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In order to produce such an output, we need to remove the `\t` character at
    the beginning of the lines. We can remove the `\t` character from the start of
    each line and unify the columns into one as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了产生这样的输出，我们需要删除行开头的`\t`字符。我们可以删除每行开头的`\t`字符，并将列统一为一列，如下所示：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `sed` command is piped to the `comm` output. The `sed` removes the `\t`
    character at the beginning of the lines. The `s` in the `sed` script stands for
    substitute. `/^\t/` matches the `\t` at the beginning of the lines (`^` is the
    start of the line marker). `//` (no character) is the replacement string for every
    `\t` at the beginning of the line. Hence every `\t` at the start of the line gets
    removed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`命令被连接到`comm`输出。`sed`删除了行开头的`\t`字符。`sed`脚本中的`s`代表替换。`/^\t/`匹配行开头的`\t`（`^`是行开始标记）。`//`（没有字符）是每个行开头的`\t`的替换字符串。因此，每个行开头的`\t`都被删除了。'
- en: A set difference operation on two files can be performed as explained in the
    following paragraphs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按照以下段落中的说明执行两个文件的集合差异操作。
- en: The set difference operation enables you to compare two files and print all
    the lines that are in the file `A.txt` or `B.txt` excluding the common lines in
    `A.txt` and `B.txt`. When `A.txt` and `B.txt` are given as arguments to the `comm`
    command, the output will contain column-1 with the set difference for `A.txt`
    with respect to `B.txt` and column-2 will contain the set difference for `B.txt`
    with respect to `A.txt`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 集合差异操作使您能够比较两个文件，并打印出所有在文件`A.txt`或`B.txt`中的行，不包括在`A.txt`和`B.txt`中共同的行。当`A.txt`和`B.txt`作为`comm`命令的参数给出时，输出将包含第一列，其中包含了相对于`B.txt`的集合差异，第二列将包含相对于`A.txt`的集合差异。
- en: 'By removing the unnecessary columns, we can produce the set difference for
    `A.txt` and `B.txt` as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通过删除不必要的列，我们可以产生`A.txt`和`B.txt`的集合差异，如下所示：
- en: '**Set difference for A.txt**:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A.txt的集合差异**：'
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`-2 -3` removes the second and third columns.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`-2 -3`删除第二列和第三列。'
- en: '**Set difference for B.txt**:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**B.txt的集合差异**：'
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`-2 -3` removes the second and third columns.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`-2 -3`删除第二列和第三列。'
- en: Finding and deleting duplicate files
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找和删除重复文件
- en: Duplicate files are copies of the same files. In some circumstances, we may
    need to remove duplicate files and keep a single copy of them. Identification
    of duplicate files by looking at the file content is an interesting task. It can
    be done using a combination of shell utilities. This recipe deals with finding
    out duplicate files and performing operations based on the result.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重复文件是相同文件的副本。在某些情况下，我们可能需要删除重复文件并保留其中的一个副本。通过查看文件内容来识别重复文件是一项有趣的任务。可以使用一组shell实用程序来完成。本文介绍了查找重复文件并根据结果执行操作的方法。
- en: Getting ready
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Duplicate files are files with different names but same data. We can identify
    the duplicate files by comparing the file content. Checksums are calculated by
    looking at the file contents. Since files with exactly the same content will produce
    duplicate checksum values, we can use this to remove duplicate lines.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 重复文件是具有不同名称但相同数据的文件。我们可以通过比较文件内容来识别重复文件。校验和是通过查看文件内容计算的。由于具有完全相同内容的文件将产生重复的校验和值，我们可以使用这一点来删除重复的行。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Generate some test files as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一些测试文件如下：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code for the script to remove the duplicate files is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 用于删除重复文件的脚本的代码如下：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run it as:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 运行如下：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The commands above will find the copies of same file in a directory and remove
    all except one copy of the file. Let's go through the code and see how it works.
    `ls -lS` will list the details of the files sorted by file size in the current
    directory. `awk` will read the output of `ls -lS` and perform comparisons on columns
    and rows of the input text to find out the duplicate files.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将在目录中查找相同文件的副本，并删除除文件的一个副本之外的所有副本。让我们看看代码如何工作。`ls -lS`将列出当前目录中按文件大小排序的文件的详细信息。`awk`将读取`ls
    -lS`的输出，并对输入文本的列和行进行比较，以找出重复文件。
- en: 'The logic behind the previous code is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的逻辑如下：
- en: We list the files sorted by file size so that the similarly sized files will
    be grouped together. The files having the same file size are identified as a first
    step to finding files that are the same. Next, we calculate the checksum of the
    files. If the checksums match, then the files are duplicates and one set of the
    duplicates are removed.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们按文件大小排序列出文件，以便大小相似的文件将被分组在一起。首先识别具有相同文件大小的文件，以找到相同的文件。接下来，我们计算文件的校验和。如果校验和匹配，则文件是重复的，重复文件组的一组将被删除。
- en: 'The `BEGIN{}` block of `awk` is executed first before lines are read from the
    file. Reading of lines takes place in the `{}` block and after the end of reading
    and processing all lines, the`END{}` block statements are executed. The output
    of `ls -lS` is:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awk`的`BEGIN{}`块在从文件中读取行之前首先执行。行的读取发生在`{}`块中，在读取和处理所有行结束后，执行`END{}`块中的语句。`ls
    -lS`的输出是：'
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The output of the first line tells us the total number of files, which in this
    case is not useful. We use `getline` to read the first line and then dump it.
    We need to compare each of the lines and the next line for sizes. For that we
    read the first line explicitly using `getline` and store name and size (which
    are the eighth and fifth columns). Hence a line is read ahead using `getline`.
    Now, when `awk` enters the `{}` block (in which the rest of the lines are read)
    that block is executed for every read offline. It compares size obtained from
    the current line and the previously stored size kept in the `size` variable. If
    they are equal, it means two files are duplicates by size. Hence they are to be
    further checked by `md5sum`.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行的输出告诉我们文件的总数，这在这种情况下是没有用的。我们使用`getline`读取第一行，然后将其丢弃。我们需要比较每一行和下一行的大小。为此，我们使用`getline`显式地读取第一行，并存储名称和大小（它们是第八列和第五列）。因此，使用`getline`提前读取一行。现在，当`awk`进入`{}`块（其中其余的行被读取）时，该块对每次离线读取都执行。它比较当前行获取的大小和存储在`size`变量中的先前存储的大小。如果它们相等，这意味着两个文件的大小相同。因此，它们需要进一步通过`md5sum`进行检查。
- en: We have played some tricky ways to reach the solution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经采取了一些巧妙的方法来解决这个问题。
- en: 'The external command output can be read inside `awk` as:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`awk`中可以读取外部命令的输出：
- en: '`"cmd"| getline`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`"cmd"| getline`'
- en: Then we receive the output in line `$0` and each column output can be received
    in `$1,$2,..$n`, and so on. Here we read the md5sum of files in the `csum1` and
    `csum2` variables. Variables `name1` and `name2` are used to store consecutive
    file names. If the checksums of two files are the same, they are confirmed to
    be duplicates and are printed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在行`$0`中接收输出，每列输出可以在`$1,$2,..$n`中接收，依此类推。在这里，我们读取`csum1`和`csum2`变量中文件的md5sum。变量`name1`和`name2`用于存储连续的文件名。如果两个文件的校验和相同，则确认它们是重复的，并打印出来。
- en: We need to find a file each from the group of duplicates so that we can remove
    all other duplicates except one. We calculate the `md5sum` of the duplicates and
    print one file from each group of duplicates by finding unique lines by comparing
    `md5sum` only from each line using `-w 32` (the first 32 characters in the `md5sum`
    output; usually, `md5sum` output consists of a 32 character hash followed by the
    filename). Therefore, one sample from each group of duplicates is written in `duplicate_sample`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到一组重复文件中的一个文件，以便我们可以删除除一个之外的所有其他重复文件。我们计算重复文件的`md5sum`并通过仅比较每行的`md5sum`（使用`-w
    32`，`md5sum`输出的前32个字符；通常，`md5sum`输出由32个字符的哈希后跟文件名组成）找到重复文件组中的一个文件。因此，每个重复文件组中的一个样本被写入`duplicate_sample`。
- en: Now, we need to remove all the files listed in `duplicate_files`, excluding
    the files listed in `duplicate_sample`. The `comm` command prints files in `duplicate_files`
    but not in `duplicate_sample`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要删除`duplicate_files`中列出的所有文件，但不包括`duplicate_sample`中列出的文件。`comm`命令打印`duplicate_files`中的文件，但不在`duplicate_sample`中。
- en: For that, we use a set difference operation (refer to the intersection, difference,
    and set difference recipes).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们使用了一个集合差异操作（参考交集、差异和集合差异的用法）。
- en: '`comm` always accepts files that are sorted. Therefore, `sort -u` is used as
    a filter before redirecting to `duplicate_files` and `duplicate_sample`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`comm` 始终接受排序后的文件。因此，在重定向到 `duplicate_files` 和 `duplicate_sample` 之前，使用 `sort
    -u` 作为过滤器。'
- en: Here the `tee` command is used to perform a trick so that it can pass filenames
    to the `rm` command as well as `print`. `tee` writes lines that appear as `stdin`
    to a file and sends them to `stdout`. We can also print text to the terminal by
    redirecting to `stderr`. `/dev/stderr` is the device corresponding to `stderr`
    (standard error). By redirecting to a `stderr` device file, text that appears
    through `stdin` will be printed in the terminal as standard error.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用 `tee` 命令执行一个技巧，以便它可以将文件名传递给 `rm` 命令以及 `print`。`tee` 将出现在 `stdin` 中的行写入文件并将它们发送到
    `stdout`。我们还可以通过重定向到 `stderr` 将文本打印到终端。`/dev/stderr` 是对应于 `stderr`（标准错误）的设备。通过重定向到
    `stderr` 设备文件，通过 `stdin` 出现的文本将被打印到终端作为标准错误。
- en: See also
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Basic awk primer* of [Chapter 4](ch04.html "Chapter 4. Texting and Driving")
    explains the awk command.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本 awk 入门* [第4章](ch04.html "第4章。发短信和驾驶") 解释了 awk 命令。'
- en: '*Checksum and verification* of [Chapter 2](ch02.html "Chapter 2. Have a Good
    Command") explains the md5sum command.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*校验和验证* [第2章](ch02.html "第2章。好命令") 解释了 md5sum 命令。'
- en: Making directories for a long path
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为长路径创建目录
- en: There are circumstances when we are required to make a tree of empty directories.
    If some intermediate directories exist in the given path, it will also have to
    incorporate checks to see whether the directory exists or not. It will make the
    code larger and inefficient. Let's see the use case and the recipe to solve the
    issue.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要创建一个空目录树。如果给定路径中存在一些中间目录，还必须包含检查目录是否存在的检查。这将使代码变得更大且低效。让我们看看使用情况和解决问题的示例。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: '`mkdir` is the command for creating directories. For example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkdir` 是创建目录的命令。例如：'
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the directory already exists, it will return a "File exists" error message,
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目录已经存在，它将返回一个 "文件已存在" 的错误消息，如下所示：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You are given a directory path (`/home/slynux/test/hello/child`). The directory
    `/home/slynux` already exist. We need to create rest of the directories `(/home/slynux/test`,
    `/home/slynux/test/hello`, and `/home/slynux/test/hello`) in the path.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个目录路径（`/home/slynux/test/hello/child`）。目录 `/home/slynux` 已经存在。我们需要在路径中创建其余的目录（`/home/slynux/test`，`/home/slynux/test/hello`
    和 `/home/slynux/test/hello`）。
- en: 'The following code is used to figure out whether each directory in a path exists:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于确定路径中的每个目录是否存在：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: -e is a parameter used in the condition construct `[ ]`, to determine whether
    a file exists. In UNIX-like systems, directory is also a type of file. `[ -e FILE_PATH
    ]` returns true if the file exists.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: -e 是在条件构造 `[ ]` 中使用的参数，用于确定文件是否存在。在类 UNIX 系统中，目录也是一种文件类型。`[ -e FILE_PATH ]`
    如果文件存在，则返回 true。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following sequence of code needs to be executed to create directories in
    a tree in several levels:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 需要执行以下代码序列来在树中创建多层级的目录：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If an error, such as "Directory exists", is encountered, it is ignored and
    the error message is dumped to the `/dev/null` device using the `2>` redirection.
    But this is lengthy and non-standard. The standard one-liner to perform this action
    is:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到错误，比如 "目录已存在"，它会被忽略，并且错误消息会被使用 `2>` 重定向转储到 `/dev/null` 设备。但这很冗长且非标准。执行此操作的标准单行命令是：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This single command takes the place of the five different commands listed above.
    It ignores if any level of directory exists and creates the missing directories.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单一命令代替了上面列出的五个不同的命令。它会忽略任何级别的目录是否存在，并创建缺失的目录。
- en: File permissions, ownership, and sticky bit
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件权限、所有权和粘滞位
- en: File permissions and ownership are one of the distinguishing features of UNIX/Linux
    file systems such as extended (ext FS). In many circumstances while working on
    UNIX/Linux platforms, we come across issues related to permissions and ownership.
    This recipe is a walk through different use cases of permissions and ownership.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 文件权限和所有权是 UNIX/Linux 文件系统的一个显著特征，如扩展（ext FS）。在许多情况下，在 UNIX/Linux 平台上工作时，我们会遇到与权限和所有权相关的问题。这个示例是权限和所有权的不同用例的演练。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In Linux systems, each file is associated with many types of permissions. Out
    of these permissions, three set of permissions (user, group, and others) are commonly
    manipulated.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统中，每个文件都与许多类型的权限相关联。在这些权限中，三组权限（用户、组和其他人）通常被操纵。
- en: The **user** is the owner of the file. The group is the collection of users
    (as defined by the system) that are permitted some access to the file. Others
    are any entity other than the user or group owner of the file.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户** 是文件的所有者。组是允许对文件进行一些访问的用户集合（由系统定义）。其他是除了文件的用户或组所有者之外的任何实体。'
- en: 'Permissions of a file can be listed by using the `ls -l` command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `ls -l` 命令列出文件的权限：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first column of output specifies the following. The first letter corresponds
    to:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一列指定了以下内容。第一个字母对应于：
- en: '"-"—if it is a regular file.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"-"——如果是一个普通文件。'
- en: '"d"—if it is a directory'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"d"——如果是一个目录'
- en: '"c"—for a character device'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"c"——对于字符设备'
- en: '"b"—for a block device'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"b"——对于块设备'
- en: '"l"—if it is a symbolic link'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"l"——如果是一个符号链接'
- en: '"s"—for a socket'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"s"——对于套接字'
- en: '"p"—for a pipe'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"p"——对于管道'
- en: The rest of the portions can be divided into three groups of three letters each
    (`------`). The first `---` three characters correspond the permissions of the
    user (owner), the second set of three characters correspond to the permissions
    of the group, and the third set of three characters correspond to the permissions
    of others. Each character in the nine character sequence (nine permissions) specifies
    whether a permission is set or unset. If the permission is set, a character appears
    in the corresponding position, else a '-' character appears in that position,
    which means that the corresponding permission is unset (unavailable).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 其余部分可以分为三组三个字母（`------`）。前三个`---`字符对应用户（所有者）的权限，第二组三个字符对应组的权限，第三组三个字符对应其他人的权限。九个字符序列中的每个字符（九个权限）指定了权限是设置还是未设置。如果权限被设置，字符将出现在相应的位置，否则在该位置出现'-'字符，这意味着相应的权限未设置（不可用）。
- en: Let's take a look at what each of these three character set means for the user,
    group, and others.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这三个字符集对用户、组和其他人分别意味着什么。
- en: '**User:**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户：**'
- en: 'Permission string: `rwx------`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 权限字符串：`rwx------`
- en: The first letter in the three letters specifies whether the user has read permission
    for the file. If the read permission is set for the user, the character `r` will
    appear as the first character. Similarly, the second character specifies write
    (modify) permission (`w`) and the third character specifies whether the user has
    execute (`x`) permission (the permission to run the file). The execute permission
    is usually set for executable files. User has one more special permission called
    setuid (`S`), which appears in the position of execute (`x`). The setuid permission
    enables an executable file to be executed effectively as its owner, even when
    the executable is run by another user.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 三个字母中的第一个字母指定用户是否对文件具有读取权限。如果用户的读取权限被设置，字符`r`将出现在第一个位置。类似地，第二个字符指定写入（修改）权限（`w`），第三个字符指定用户是否具有执行（`x`）权限（运行文件的权限）。执行权限通常设置为可执行文件。用户还有一个称为setuid（`S`）的特殊权限，它出现在执行（`x`）的位置。setuid权限使可执行文件在由另一个用户运行时有效地作为其所有者执行。
- en: 'An example for a file with setuid permission set is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 具有setuid权限的文件的示例如下：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The read, write, and execute permissions are also applied to the directories.
    However, the interpretation of read, write, and execute permissions are slightly
    different in the context of directories as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 读取、写入和执行权限也适用于目录。但是，在目录的上下文中，读取、写入和执行权限的解释略有不同，如下所示：
- en: Read permission (`r`) for the directories enables to read the list of files
    and sub-directories in the directory
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录的读取权限（`r`）使得能够读取目录中文件和子目录的列表
- en: Write permission (`w`) for a directory enables to create or remove files and
    directories from a directory
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录的写入权限（`w`）使得能够在目录中创建或删除文件和子目录
- en: Execute permission (`x`) specifies whether the access to the files and directories
    in a directory is possible or not
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行权限（`x`）指定是否可以访问目录中的文件和子目录
- en: '**Group**:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**组：**'
- en: 'Permission string: `---rwx---`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 权限字符串：`---rwx---`
- en: 'The second set of three characters specifies the group permissions. The interpretation
    of permissions `rwx` is the same as the permissions for user. Instead of setuid,
    the group has a setgid (`S`) bit. It enables to run an executable file with an
    effective group as the owner group. But the group, which initiates the command,
    may be different. An example of group permission is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组三个字符指定组的权限。权限`rwx`的解释与用户的权限相同。组具有一个称为setgid（`S`）的位，而不是setuid。它使得能够以所有者组的有效组运行可执行文件。但是，启动命令的组可能不同。组权限的示例如下：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Others:**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他人：**'
- en: 'Permission string: `------rwx`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 权限字符串：`------rwx`
- en: Other permissions appear as the last three character set in the permission string.
    Others have the same read, write, and execute permissions as the user and group.
    But it does not have permission `S` (like setuid and setgid).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其他权限出现在权限字符串的最后三个字符集中。其他人拥有与用户和组相同的读取、写入和执行权限。但它没有`S`权限（比如setuid和setgid）。
- en: Directories have a special permission called sticky bit. When a sticky bit is
    set for a directory, the user who created the directory can only delete the files
    in the directory even if group and others have write permissions. The sticky bit
    appears in the position of execute character (`x`) in the others permission set.
    It is represented as character `t` or `T`. `t` appears in the position of `x`
    if the execute permission is unset and the sticky bit is set. If the sticky bit
    and the execute permission is set, character `T` appears in the position of `x`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 目录具有一种称为粘滞位的特殊权限。当为目录设置了粘滞位时，创建目录的用户即使组和其他人具有写权限，也只能删除目录中的文件。粘滞位出现在其他人权限集的执行字符（`x`）的位置。它表示为字符`t`或`T`。如果执行权限未设置且设置了粘滞位，则`t`出现在`x`的位置。如果设置了粘滞位和执行权限，则`T`出现在`x`的位置。
- en: 'For example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '`------`rwt , `------`rwT'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`------`rwt，`------`rwT'
- en: A typical example of a directory with sticky bit turned on by default is `/tmp`.
    The sticky bit is a type of write-protection.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，具有粘滞位的目录的典型示例是`/tmp`。粘滞位是一种写保护。
- en: In each of the `ls -l` output line, the string `slynux slynux` corresponds to
    the owned user and owned group. Here the first 'slynux' is the user and the second
    'slynux' is the group owner.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个`ls -l`输出行中，字符串`slynux slynux`对应于所拥有的用户和所拥有的组。这里的第一个'slynux'是用户，第二个'slynux'是组所有者。
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: In order to set permissions for files, we use the `chmod` command.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置文件的权限，我们使用`chmod`命令。
- en: 'Assume that we need to set permission: `rwx rw- r--`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要设置权限：`rwx rw- r--`
- en: 'This could be set using chmod as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用chmod设置如下：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里：
- en: '`u =` specifies user permissions'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u =`指定用户权限'
- en: '`g =` specifies group permissions'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g =`指定组权限'
- en: '`o =` specifies others permissions'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`o =`指定其他人的权限'
- en: 'In order to add additional permissions on the current file, use + to add permission
    to user, group or others and use – to remove the permissions. Add the executable
    permission to a file, which is already having the permission `rwx rw- r--` as
    follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在当前文件上添加额外的权限，使用 + 为用户、组或其他添加权限，使用 - 删除权限。为已经具有权限 `rwx rw- r--` 的文件添加可执行权限如下：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This command adds the `x` permission for others.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令为其他用户添加了 `x` 权限。
- en: 'Add the executable permission to all permission categories that is, for user,
    group, and others as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为所有权限类别（用户、组和其他）添加可执行权限如下：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here `a` means all.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `a` 表示所有。
- en: 'In order to remove any permission, use -. For example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除任何权限，使用 -。例如：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Permissions can also be set using octal numbers. Permissions are denoted by
    three-digit octal numbers in which each of the digit corresponds to user, group,
    and other in the order.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 权限也可以使用八进制数设置。权限用三位数的八进制数表示，其中每个数字对应用户、组和其他。
- en: 'Read, write, and execute permissions have unique octal numbers as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 读、写和执行权限具有以下唯一的八进制数：
- en: '`r--` = 4'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r--` = 4'
- en: '`-w-` = 2'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-w-` = 2'
- en: '`--x` = 1'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--x` = 1'
- en: 'We can get the required combination of permissions by adding the octal values
    for the required permission sets. For example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加所需权限集的八进制值来获得所需的权限组合。例如：
- en: '`rw-` = 4 + 2 = 6'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rw-` = 4 + 2 = 6'
- en: '`r-x` = 4 + 1 = 5'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r-x` = 4 + 1 = 5'
- en: 'The permission `rwx rw- r--` in numeric method is as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 数字方法中的权限 `rwx rw- r--` 如下：
- en: '`rwx` = 4 + 2 + 1 = 7'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rwx` = 4 + 2 + 1 = 7'
- en: '`rw-` = 4 + 2 = 6'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rw-` = 4 + 2 = 6'
- en: '`r--` = 4'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r--` = 4'
- en: 'Therefore, `rwx rw- r--` is equal to 764, and the command for setting the permissions
    using octal values is:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`rwx rw- r--` 等于 764，使用八进制值设置权限的命令是：
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There's more...
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's go through some additional tasks that can be performed for files and directories.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看可以为文件和目录执行的一些额外任务。
- en: Changing ownership
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改所有权
- en: 'In order to change ownership of files, use the `chown` command as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更改文件的所有权，使用 `chown` 命令如下：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, `slynux` is the user as well as the group.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`slynux` 是用户和组。
- en: Setting the sticky bit
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置粘滞位
- en: The sticky bit is an interesting type of permission applied to directories.
    By setting the sticky bit, it restricts only the user owning it to delete the
    files even though group and others have sufficient permissions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 粘滞位是应用于目录的一种有趣的权限类型。通过设置粘滞位，它限制只有拥有它的用户才能删除文件，即使组和其他人有足够的权限。
- en: 'In order to set the sticky bit, `+t` is applied on a directory with `chmod`
    as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置粘滞位，在目录上使用 `chmod` 如下应用 `+t`：
- en: '[PRE27]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Applying permissions recursively to files
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对文件递归应用权限
- en: 'Sometimes it may be required to recursively change the permissions of all the
    files and directories inside the current directory. This can be done as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有时可能需要递归更改当前目录中所有文件和目录的权限。可以按以下方式完成：
- en: '[PRE28]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `-R` option specifies to apply change permission recursively.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`-R` 选项指定递归应用更改权限。'
- en: 'We have used "." to specify the path as the current working directory. It is
    equivalent to:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用“.” 指定路径为当前工作目录。它相当于：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Applying ownership recursively
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归应用所有权
- en: 'We can apply the ownership recursively by using the `-R` flag with the `chown`
    command as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `chown` 命令的 `-R` 标志递归应用所有权，如下所示：
- en: '[PRE30]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Running an executable as a different user (setuid)
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以不同用户身份运行可执行文件（setuid）
- en: Some executables need to be executed as a different user (other than the current
    user that initiates the execution of the file), effectively, whenever they are
    executed, by using the file path, such as `./executable_name`. A special permission
    attribute for files called `setuid` permission enables to effectively execute
    as the file owner when any other user runs the program.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有些可执行文件需要以不同的用户（而不是启动文件执行的当前用户）的身份有效执行，例如通过文件路径 `./executable_name`。文件的一种特殊权限属性称为
    `setuid` 权限，使得在其他用户运行程序时有效地以文件所有者的身份执行。
- en: 'First change the ownership to the user to which it needs to be executed every
    time and login as the owner user. Then, run the following command:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将所有权更改为需要每次执行的用户，并登录为所有者用户。然后，运行以下命令：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now it executes effectively as the root user every time.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每次以 root 用户的身份有效执行。
- en: '`setuid` is restricted such that `setuid` won''t work for scripts, but only
    for Linux ELF binaries. This is a fix for ensuring security.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuid` 受限制，因此 `setuid` 对脚本无效，但对于 Linux ELF 二进制文件有效。这是确保安全性的修复。'
- en: Making files immutable
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使文件不可变
- en: Files on extended type file systems, which are common in Linux (for example,
    ext2, ext3, ext4, and so on) can be made immutable. Certain type of file attributes
    help to set the immutable attribute to the file. When a file is made immutable,
    any user or super user cannot remove the file until the immutable attribute is
    removed from the file. We can easily find out the file system type of any mounted
    partition by looking at the `/etc/mtab` file. The first column of the file specifies
    the partition device path (for example, `/dev/sda5`) and the third column specifies
    the file system type (for example, ext3). Let's see how to make files immutable.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中常见的扩展类型文件系统上（例如 ext2、ext3、ext4 等），可以使文件不可变。某些类型的文件属性帮助设置文件的不可变属性。当文件被设置为不可变时，任何用户或超级用户都无法删除文件，直到从文件中删除不可变属性为止。我们可以通过查看
    `/etc/mtab` 文件轻松找到任何挂载分区的文件系统类型。文件的第一列指定分区设备路径（例如 `/dev/sda5`），第三列指定文件系统类型（例如
    ext3）。让我们看看如何使文件不可变。
- en: Getting ready
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: '`chattr` can be used for to make files immutable. However, it is not the only
    extended attribute that can be changed by chattr.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`chattr` 可用于使文件不可变。但是，它不是唯一可以通过 `chattr` 更改的扩展属性。'
- en: Making a file immutable is one of the methods for securing files from modification.
    The best known example is in the case of the `/etc/shadow` file. The shadow file
    consists of encrypted passwords of every user in the current system. By injecting
    encrypted passwords, we can login into the system. Users can, usually, change
    their password by using the `passwd` command. When you execute the `passwd` command,
    it actually modifies the `/etc/shadow` file. We can make the shadow file immutable
    so that no user is able to change the password. Let's see how to do it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使文件不可变是保护文件免受修改的方法之一。最著名的例子是`/etc/shadow`文件。shadow文件包含当前系统中每个用户的加密密码。通过注入加密密码，我们可以登录到系统。用户通常可以使用`passwd`命令更改密码。当您执行`passwd`命令时，它实际上修改了`/etc/shadow`文件。我们可以使shadow文件不可变，以便任何用户都无法更改密码。让我们看看如何做到这一点。
- en: How to do it...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'A file can be made immutable as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按照以下方式使文件不可变：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Or:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The file is therefore made immutable. Now try the following command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此文件被设置为不可变。现在尝试以下命令：
- en: '[PRE34]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In order to make it writable, remove the immutable attribute as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其可写，按照以下方式移除不可变属性：
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Generating blank files in bulk
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批量生成空文件
- en: Sometimes we many need to generate test cases. We may use programs that operate
    on 1000s of files. But how are test files generated?
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能需要生成测试用例。我们可能会使用操作数千个文件的程序。但是测试文件是如何生成的呢？
- en: Getting ready
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: '`touch` is a command that can create blank files or modify the timestamp of
    files if they already exist. Let''s take a look at how to use them.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`touch`是一个可以创建空文件或修改文件时间戳的命令。让我们看看如何使用它们。'
- en: How to do it...
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'A blank file with the name `filename` will be created using the following command:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将创建一个名为`filename`的空文件：
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Generate bulk files with a different name pattern as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式生成具有不同名称模式的批量文件：
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the above code `{1..100}` will be expanded as a string "1, 2, 3, 4, 5, 6,
    7...100". Instead of `{1..100}.txt`, we can use various shorthand patterns such
    as `test{1..200}.c`, `test{a..z}.txt`, and so on.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`{1..100}`将被扩展为字符串"1, 2, 3, 4, 5, 6, 7...100"。我们可以使用各种简写模式，如`test{1..200}.c`，`test{a..z}.txt`等，而不是`{1..100}.txt`。
- en: 'If a file already exists, then the `touch` command changes all timestamps associated
    with the file to the current time. However, if we want to specify that only certain
    stamps are to be modified, we use the following options:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件已经存在，则`touch`命令会将与文件相关的所有时间戳更改为当前时间。但是，如果我们想要指定只修改某些时间戳，我们可以使用以下选项：
- en: '`touch -a` modifies only the access time'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touch -a`仅修改访问时间'
- en: '`touch -m` modifies only the modification time'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touch -m`仅修改修改时间'
- en: 'Instead of using the current time for the timestamp, we can specify the time
    and date with which to stamp the file as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式指定时间和日期来为文件盖上时间戳，而不是使用当前时间：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The date string that is used with `–d` need not always be in the same format.
    It will accept any standard date formats. We can omit time from the string and
    provide handy date formats like "Jan 20 2010".
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与`-d`一起使用的日期字符串不一定总是以相同的格式。它将接受任何标准日期格式。我们可以从字符串中省略时间，并提供方便的日期格式，如“Jan 20 2010”。
- en: Finding a symbolic link and its target
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找符号链接及其目标
- en: Symbolic links are common with UNIX-like systems. We may come across various
    manipulations based on symbolic links. This recipe may not be having any practical
    purpose, but it gives practice of handling symbolic links that may be helpful
    in writing shell scripts for other purposes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接在类UNIX系统中很常见。我们可能会遇到基于符号链接的各种操作。这个示例可能没有任何实际目的，但它可以练习处理符号链接，这可能有助于编写其他目的的shell脚本。
- en: Getting ready
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Symbolic links are just pointers to other files. They are similar in function
    to aliases in Mac OS X or shortcuts in Windows. When symbolic links are removed,
    they will not cause any harm to the original file.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 符号链接只是指向其他文件的指针。它们在功能上类似于Mac OS X中的别名或Windows中的快捷方式。删除符号链接时，不会对原始文件造成任何伤害。
- en: How to do it...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We can create a symbolic link as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式创建符号链接：
- en: '[PRE39]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This creates a symbolic link (called "web") in the logged in user''s home directory.
    The link points to `/var/www/`. This is seen in the output of the following command:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这在登录用户的主目录中创建了一个名为“web”的符号链接。该链接指向`/var/www/`。这可以在以下命令的输出中看到：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`web -> /var/www` specifies that `web` points to `/var/www`.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`web -> /var/www`指定`web`指向`/var/www`。'
- en: For every symbolic link, the permission notation block (`lrwxrwxrwx`) starts
    with letter "l", which represents a symlink.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个符号链接，权限表示块（`lrwxrwxrwx`）以字母“l”开头，表示符号链接。
- en: 'So, in order to print symbolic links in the current directory, use the following
    command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了打印当前目录中的符号链接，请使用以下命令：
- en: '[PRE42]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`grep` will filter the lines from the `ls -l` output such that it displays
    only lines starting with l. `^` is the start marker for the string. `awk` is used
    to print the eighth column. Hence it prints the eighth column, which is the filename.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`将过滤`ls -l`输出的行，以便仅显示以l开头的行。`^`是字符串的起始标记。`awk`用于打印第八列。因此它打印第八列，也就是文件名。'
- en: 'Another way to print symbolic links is to use `find` as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 打印符号链接的另一种方法是使用`find`，如下所示：
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the above command, in the `find` argument `type` we have specified "l", which
    will instruct the `find` command to search only for symbolic link files. The `–print`
    option is used to print the list of symbolic links to the standard output (`stdout`).
    The path from which the file search should begin is given as '.', which means
    it is the current directory.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，在`find`参数`type`中，我们指定了“l”，这将指示`find`命令仅搜索符号链接文件。`-print`选项用于将符号链接列表打印到标准输出（`stdout`）。文件搜索应该从当前目录开始，给出为'.'。
- en: 'In order to print the target of a symbolic link use the following command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印符号链接的目标，请使用以下命令：
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `ls –l` command lists many details with each of the line corresponding to
    the details of a file. `ls –l web` lists the details for the file called `web`,
    which is a symbolic link. The tenth column in the output of `ls –l` contains the
    link to which the file points to (if the file is a symbolic link). Hence in order
    to find the target associated with a symbolic link, we can use `awk` to print
    the tenth column from the file details listing (the output from `ls –l`).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls –l`命令列出每行对应文件的许多细节。`ls –l web`列出名为`web`的文件的细节，这是一个符号链接。`ls –l`输出的第十列包含文件指向的链接（如果文件是符号链接）。因此，为了找到与符号链接关联的目标，我们可以使用`awk`从文件详细列表（从`ls
    –l`的输出）中打印第十列。'
- en: 'Or, alternately, we can use the standard way of reading the target path for
    a given symbolic link using the command `readlink`. It is the most preferred method
    and can be used as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用标准方法来读取给定符号链接的目标路径，使用`readlink`命令。这是最常用的方法，可以如下使用：
- en: '[PRE45]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Enumerating file type statistics
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举文件类型统计
- en: There are many file types. It will be an interesting exercise to write a script
    that can enumerate through all the files inside a directory, its descendants,
    and print a report that provides details on types of files (files with different
    file types) and the count of each file type present. This recipe is an exercise
    on how to write scripts that can enumerate through a bulk of files and collecting
    details.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多文件类型。编写一个脚本来枚举目录内所有文件及其后代，并打印提供文件类型（不同文件类型的文件）和每种文件类型的数量的报告将是一个有趣的练习。这个配方是一个关于如何编写脚本来枚举大量文件并收集详细信息的练习。
- en: Getting ready
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: The file command can be used to find out the type of the file by looking at
    the contents of the file. In UNIX/Linux systems, file types are not determined
    based on the extension of the file (like the Microsoft Windows platform does).
    This recipe aims at collecting file type statistics of a number of files. For
    storing the count of files of the same type, we can use an associative array and
    the `file` command can be used to fetch the file type details from each of the
    files.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 文件命令可用于通过查看文件的内容来查找文件的类型。在UNIX/Linux系统中，文件类型不是基于文件的扩展名确定的（就像Microsoft Windows平台那样）。这个配方旨在收集一些文件的文件类型统计信息。为了存储相同类型文件的计数，我们可以使用一个关联数组，`file`命令可以用于从每个文件中获取文件类型的详细信息。
- en: How to do it...
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In order to print the file type of a file use the following command:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印文件的文件类型，使用以下命令：
- en: '[PRE46]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Print the file type only by excluding the filename as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过排除文件名打印文件类型如下：
- en: '[PRE47]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The script for files statistics is as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 文件统计脚本如下：
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The usage is as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 用法如下：
- en: '[PRE49]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'A sample output is shown below:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 下面显示了一个示例输出：
- en: '[PRE50]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How it works...
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Here an associative array named `statarray` is declared so that it can take
    file type as file indices and store the count of each file type in the array.
    `let` is used to increment the count each time when a file type is encountered.
    The `find` command is used to get the list of file paths recursively. A `while`
    loop is used to iterate line by line through the `find` command''s output. The
    input line `ftype=`file -b "$line"`` in the previous script is used to find out
    the file type using the `file` command. The `–b` option specifies file command
    to print only file type (without filename in the output). The file type output
    consists of more details, such as image encoding used and resolution (in the case
    of an image file). But we are not interested in more details, we need only the
    basic information. Details are comma separated as in the following example:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，声明了一个名为`statarray`的关联数组，以便它可以将文件类型作为文件索引并将每种文件类型的计数存储在数组中。每次遇到文件类型时，使用`let`来增加计数。使用`find`命令递归获取文件路径列表。使用`while`循环逐行迭代`find`命令的输出。在前一个脚本中，使用输入行`ftype=`file
    -b "$line"``来使用`file`命令找出文件类型。`–b`选项指定文件命令仅打印文件类型（在输出中不包括文件名）。文件类型输出包括更多细节，例如图像编码和分辨率（在图像文件的情况下）。但我们对更多细节不感兴趣，我们只需要基本信息。详细信息以逗号分隔，如下例所示：
- en: '[PRE51]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We need to extract only the "ELF 32-bit LSB executable" from the above details.
    Hence we use `cut –d, -f1`, which specifies to use "`,`" as the delimiter and
    print only the first field.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要仅从上述细节中提取"ELF 32位LSB可执行文件"。因此，我们使用`cut –d, -f1`，它指定使用"`,`"作为分隔符，并仅打印第一个字段。
- en: '`done< <(find $path –type f –print);` is an important bit of code. The logic
    is as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`完成< <(find $path –type f –print);`是一段重要的代码。逻辑如下：'
- en: '`while` read line;'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`当`读取行;'
- en: '`do` something'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`做`某事'
- en: '`done<` filename'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`完成<`文件名'
- en: Instead of the filename we used the output of `find`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`find`的输出而不是文件名。
- en: '`<(find $path -type f -print)` is equivalent to a filename. But it substitutes
    filename with subprocess output. Note that there is an additional `<`.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`<(find $path -type f -print)`相当于一个文件名。但它用子进程输出替换了文件名。请注意，这里有一个额外的`<`。'
- en: '`${!statarray[@]}` is used to return the list of array indexes.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`${!statarray[@]}`用于返回数组索引的列表。'
- en: Loopback files and mounting
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回环文件和挂载
- en: Loopback filesystems are very interesting components of Linux like systems.
    We usually create filesystems on devices (for example, disk drive partitions).
    These storage devices are available as device files like `/dev/device_name`. In
    order to use the storage device filesystem, we need to mount it at some directory
    called a mount point. Loopback filesystems are those that we create in files rather
    than a physical device. We can mount those files as devices at a mount point.
    Let's see how to do it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 回环文件系统是Linux系统中非常有趣的组件。我们通常在设备上创建文件系统（例如，磁盘驱动器分区）。这些存储设备可用作设备文件，如`/dev/device_name`。为了使用存储设备文件系统，我们需要将其挂载到某个目录，称为挂载点。回环文件系统是我们在文件中创建的文件系统，而不是物理设备。我们可以将这些文件挂载为设备到挂载点。让我们看看如何做到这一点。
- en: Getting ready
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: Loopback filesystems reside on a file. We mount these files by attaching it
    to a device file. An example of a loopback filesystem is the initial ramdisk file,
    which you would see at `boot/initrd.img`. It stores an initial filesystem for
    the kernel in a file.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 回环文件系统驻留在一个文件上。我们通过将这些文件附加到设备文件来挂载这些文件。回环文件系统的一个示例是初始ramdisk文件，您可以在`boot/initrd.img`中看到。它在一个文件中存储了内核的初始文件系统。
- en: Let's see how to create an ext4 filesystem on a file of size 1GB.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在大小为1GB的文件上创建ext4文件系统。
- en: How to do it...
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The following command will create a file that is 1 GB in size.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将创建一个大小为1GB的文件。
- en: '[PRE52]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You can see that the size of the created file exceeds 1GB. This is because the
    hard disk is a block device and hence storage is allocated by integral multiples
    of blocks size.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到所创建文件的大小超过了1GB。这是因为硬盘是一个块设备，因此存储是按块大小的整数倍分配的。
- en: 'Now format the 1GB file using the `mkfs` command as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用`mkfs`命令格式化1GB文件如下：
- en: '[PRE53]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This command formats it to ext4\. Check the file type using the following command:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将其格式化为ext4。使用以下命令检查文件类型：
- en: '[PRE54]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now you can mount the loopback file as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以按以下方式挂载回环文件：
- en: '[PRE55]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `-o loop` additional option is used to mount any loopback file systems.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`-o loop`附加选项用于挂载任何回环文件系统。'
- en: This is the shortcut method. We do not attach it to any devices. But internally
    it attaches to a device called `/dev/loop1` or `loop2`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这是快捷方法。我们不将其附加到任何设备上。但在内部，它会附加到一个名为`/dev/loop1`或`loop2`的设备上。
- en: 'We can do it manually as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动执行如下操作：
- en: '[PRE56]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The first method cannot be used in all circumstances. Suppose we want to create
    a hard disk file, and then want to partition it and mount a sub partition, we
    cannot use `mount -o loop`. We have to use the second method. Partition a zeros
    dumped file as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法并非在所有情况下都适用。假设我们想要创建一个硬盘文件，然后想要对其进行分区并挂载一个子分区，我们不能使用`mount -o loop`。我们必须使用第二种方法。按以下方式对零转储文件进行分区：
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create partitions in `loopback.img` in order to mount the first partition as
    follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loopback.img`中创建分区，以便按以下方式挂载第一个分区：
- en: '[PRE58]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now `/dev/loop2` represents first partition.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`/dev/loop2`代表第一个分区。
- en: '`-o` is the offset flag. `32256` bytes are for a DOS partition scheme. The
    first partition starts after an offset of 32256 bytes from the start of the hard
    disk.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`-o`是偏移标志。`32256`字节用于DOS分区方案。第一个分区从硬盘的起始位置偏移32256字节后开始。'
- en: We can set up the second partition by specifying the required offset. After
    mounting we can perform all regular operations as we can on physical devices.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过指定所需的偏移量来设置第二个分区。挂载后，我们可以执行所有常规操作，就像在物理设备上一样。
- en: 'In order to `umount`, use the following syntax:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为了`umount`，使用以下语法：
- en: '[PRE59]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'For example:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE60]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Or, alternately, we can use device file path as an argument to the `umount`
    command as:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用设备文件路径作为`umount`命令的参数，如：
- en: '[PRE61]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note that `umount` command should be executed as a root user since it is a privileged
    command.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`umount`命令应以root用户身份执行，因为它是一个特权命令。
- en: There's more...
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's explore more about additional mount options.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更多地了解附加挂载选项。
- en: Mounting ISO files as loopback
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为回环挂载挂载ISO文件
- en: An ISO file is an archive of any optical media. We can mount ISO files in the
    same way that we mount physical discs by using loopback mounting.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ISO文件是任何光学介质的存档。我们可以通过回环挂载的方式挂载ISO文件，就像我们挂载物理光盘一样。
- en: 'A mount point is just a directory, which is used as access path to contents
    of a device through a filesystem. We can even use a non-empty directory as the
    mount path. Then the mount path will contain data from the devices rather than
    original contents until the device is unmounted. For example:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载点只是一个目录，用作通过文件系统访问设备内容的访问路径。我们甚至可以使用非空目录作为挂载路径。然后，挂载路径将包含来自设备的数据，而不是原始内容，直到设备被卸载。例如：
- en: '[PRE62]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now perform operations using files from `/mnt/iso`. ISO is a read-only filesystem.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用`/mnt/iso`中的文件执行操作。ISO是一个只读文件系统。
- en: Flush changes immediately with sync
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用sync立即刷新更改
- en: 'While making changes on a mounted device, they are not immediately written
    to the physical devices. They are only written when the buffer is full. But we
    can force writing of changes immediately by using the `sync` command as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在挂载设备上进行更改时，更改不会立即写入物理设备。只有当缓冲区满时才会写入。但是我们可以使用`sync`命令强制立即写入更改，如下所示：
- en: '`# sync`'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`# sync`'
- en: You should execute the `sync` command as root.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该以root身份执行`sync`命令。
- en: Creating ISO files, Hybrid ISO
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ISO文件，混合ISO
- en: An ISO image is an archive format that stores the exact storage images of optical
    disks like CD ROMs, DVD ROMs, and so on. It is a common use case that we burn
    ISO images to optical disks. But what if you want to create an image of an optical
    disk? For that we need to create an ISO image from an optical disk. Many people
    rely on third-party utilities to create an ISO image from an optical disk. However,
    using the command line, it's just a single line job.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ISO映像是一种存储光盘的确切存储映像的存档格式，如CD-ROM、DVD-ROM等。我们通常将ISO映像刻录到光盘上。但是，如果您想要创建光盘的映像，该怎么办？为此，我们需要从光盘创建ISO映像。许多人依赖第三方实用程序从光盘创建ISO映像。但是，使用命令行，这只是一个单行工作。
- en: Also, many people don't distinguish between bootable and non-bootable optical
    disks. Bootable disks are capable of booting from themselves and also running
    an operating system or another product. Non-bootable ISOs cannot do that. The
    practice that people usually follow is to copy files from a bootable CD-ROM and
    paste it to another location for keeping the copy. After that, they use the copied
    directory to burn a CD ROM. But then, it will lose its bootable nature. To preserve
    the bootable nature, it should be copied as a disk image or an ISO file.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，许多人不区分可引导和不可引导的光盘。可引导光盘能够从自身引导，并运行操作系统或其他产品。不可引导的ISO无法做到这一点。人们通常遵循的做法是从可引导CD-ROM复制文件并将其粘贴到另一个位置以保留副本。之后，他们使用复制的目录来刻录CD-ROM。但是，这样做将失去其可引导性质。为了保持可引导性质，应将其复制为磁盘映像或ISO文件。
- en: Nowadays, most people use devices such as flash drives or hard disks as a replacement
    for optical disks. When we write a bootable ISO to a flash drive it will no longer
    be bootable unless we use a special hybrid ISO image designed specifically for
    the purpose.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大多数人使用闪存驱动器或硬盘等设备来替代光盘。当我们将可引导的ISO写入闪存驱动器时，除非使用专门为此目的设计的特殊混合ISO映像，否则它将不再是可引导的。
- en: This recipe will give you an insight on ISO images and manipulations.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将让您深入了解ISO映像和操作。
- en: Getting ready
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: As we described many times in this book, UNIX handles everything as files. Every
    device is a file. Hence what if we want to copy an exact image of a device? We
    need to read all data from it and write to another file, right?
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书中多次描述的那样，UNIX将所有内容都视为文件。每个设备都是一个文件。因此，如果我们想要复制设备的精确映像，该怎么办？我们需要从中读取所有数据并写入另一个文件，对吧？
- en: As we know, the `cat` command can be used to read any data and redirection can
    be used to write to a file.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，`cat`命令可以用于读取任何数据，并且可以使用重定向将其写入文件。
- en: How to do it...
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In order to create an ISO image from `/dev/cdrom` use the following command:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`/dev/cdrom`创建ISO映像，请使用以下命令：
- en: '[PRE63]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This will work, it will read all the bytes from the device and write an ISO
    image.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这将起作用，它将读取设备的所有字节并写入ISO映像。
- en: Using the `cat` command for creating an ISO image is a tricky way to do it.
    But the most preferred way to create an ISO image is to use the `dd` utility.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cat`命令创建ISO映像是一种棘手的方法。但创建ISO映像的最佳方式是使用`dd`实用程序。
- en: '[PRE64]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`mkisofs` is a command used to create ISO system. The output file of `mkisofs`
    can be written to CD ROM or DVD ROM using utilities like `cdrecord`. We can use
    `mkisofs` to create an ISO file using a directory containing all the required
    files that should appear as contents of an ISO file as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkisofs`是用于创建ISO系统的命令。`mkisofs`的输出文件可以使用诸如`cdrecord`之类的实用程序写入CD ROM或DVD ROM。我们可以使用`mkisofs`创建一个包含所有所需文件的目录的ISO文件，这些文件应该出现为ISO文件的内容，如下所示：'
- en: '[PRE65]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `–o` option in the `mkisofs` command specifies the ISO file path. The `source_dir`
    is the path of the directory that should be used as source content for the ISO
    and the `–V` option specifies the label that should be used for the ISO file.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkisofs`命令中的`-o`选项指定ISO文件路径。`source_dir`是应用作ISO源内容的目录路径，`-V`选项指定应用于ISO文件的标签。'
- en: There's more...
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's learn more commands and techniques related to ISO files.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习更多与ISO文件相关的命令和技术。
- en: Hybrid ISO that boots off flash drive or hard disk
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从闪存驱动器或硬盘引导的混合ISO
- en: Usually, bootable ISO files cannot be transferred or written to a USB storage
    device and boot the OS from the USB key. But special type of ISO files called
    hybrid ISOs can be flashed and they are capable of booting from such devices.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，可引导的ISO文件无法传输或写入USB存储设备，并从USB键引导操作系统。但是称为混合ISO的特殊类型的ISO文件可以被刷写，并且能够从这些设备引导。
- en: 'We can convert standard ISO files into hybrid ISOs with the `isohybrid` command.
    The `isohybrid` command is a new utility and most Linux distros don''t include
    this by default. You can download the syslinux package from: [http://syslinux.zytor.com](http://syslinux.zytor.com).'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`isohybrid`命令将标准ISO文件转换为混合ISO。`isohybrid`命令是一个新的实用程序，大多数Linux发行版默认情况下不包括此命令。您可以从以下网址下载syslinux软件包：[http://syslinux.zytor.com](http://syslinux.zytor.com)。
- en: 'Have a look at the following command:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下命令：
- en: '[PRE66]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Using this command, we will have a hybrid ISO with the file name `image.iso`
    and it can be written to USB storage devices.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令，我们将获得一个名为`image.iso`的混合ISO，并且可以将其写入USB存储设备。
- en: 'Write the ISO to a USB storage by using the following command:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将ISO写入USB存储：
- en: '[PRE67]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Use the appropriate device instead of `sdb1`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适当的设备替代`sdb1`。
- en: 'Or, you can use `cat` as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用以下命令：
- en: '[PRE68]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Burning an ISO from command line
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从命令行刻录ISO
- en: 'The `cdrecord` command is used to burn an ISO file into a CD ROM or DVD ROM.
    It can be used to burn the image to the CD ROM as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdrecord`命令用于将ISO文件刻录到CD ROM或DVD ROM中。可以使用以下命令将图像刻录到CD ROM中：'
- en: '[PRE69]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Some extra options are as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 一些额外的选项如下：
- en: 'We can specify the burning speed with the `–speed` option as follows:'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`-speed`选项指定刻录速度，如下所示：
- en: '[PRE70]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'For example:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE71]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The speed is 8x, which is specified as 8.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 速度为8x，指定为8。
- en: 'A CD ROM can be burned in multisessions such that we can burn data multiple
    times on a disk. Multisession burning can be performed using the `–multi` option
    as follows:'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CD ROM可以进行多会话刻录，这样我们可以多次在一张光盘上刻录数据。可以使用`-multi`选项执行多会话刻录，如下所示：
- en: '[PRE72]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Playing with CD Rom tray
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩转CD ROM托盘
- en: 'Try the following commands and have fun:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下命令并玩得开心：
- en: '**$ eject**'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$ eject**'
- en: This command is used to eject the tray.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令用于弹出托盘。
- en: '**$ eject -t**'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$ eject -t**'
- en: This command is used to close the tray.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令用于关闭托盘。
- en: Try to write a loop that opens the tray and closes the tray for "N" number of
    times.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编写一个循环，打开托盘并关闭托盘“N”次。
- en: Finding difference between files, patching
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找文件之间的差异，打补丁
- en: When multiple versions of a file are available, it is very useful when we can
    find the differences between files being highlighted rather than comparing two
    files manually by looking through them. If the files are of 1000s of lines, they
    are practically very difficult and time consuming to compare. This recipe illustrates
    how to generate differences between files highlighted with line numbers. When
    working on large files by multiple developers, when one of them has made changes
    and these changes need to be shown to the other, sending the entire source code
    to other developers is costly in consumption of space and time to manually check
    the changes. Sending a different file is helpful. It consists of only lines that
    are changed, added, or removed and line numbers are attached with it. This difference
    file is called a patch file. We can add the changes specified in the patch file
    to the original source code by using the patch command. We can also revert the
    changes by patching again. Let's see how to do this.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件有多个版本可用时，将文件之间的差异突出显示比手动比较两个文件更有用。如果文件有1000多行，手动比较实际上非常困难和耗时。本教程说明了如何生成带有行号的文件之间的差异。在多个开发人员处理大文件时，当其中一个人进行了更改并且需要向其他人显示这些更改时，将整个源代码发送给其他开发人员在空间和时间上都是昂贵的，手动检查更改。发送一个不同的文件是有帮助的。它只包含已更改、添加或删除的行，并附有行号。这个差异文件称为补丁文件。我们可以使用补丁命令将补丁文件中指定的更改添加到原始源代码中。我们也可以通过再次打补丁来还原更改。让我们看看如何做到这一点。
- en: How to do it...
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The `diff` command utility is used to generate difference files.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '`diff`命令实用程序用于生成差异文件。'
- en: 'In order to generate difference information, create the following files:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成差异信息，创建以下文件：
- en: 'File 1: `version1.txt`'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件1：`version1.txt`
- en: '[PRE73]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'File 2: `version2.txt`'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件2：`version2.txt`
- en: '[PRE74]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Non-unified `diff` output (without the `–u` flag) will be as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 非统一的`diff`输出（不带`-u`标志）将如下所示：
- en: '[PRE75]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The unified `diff` output will be as follows::'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 统一的`diff`输出将如下所示：
- en: '[PRE76]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `-u` option is used to produce unified output. Everyone prefers unified
    output, as the unified output is more readable and because it is easier to interpret
    the difference that is being made between two files.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`-u`选项用于生成统一的输出。每个人都更喜欢统一的输出，因为统一的输出更易读，而且更容易解释两个文件之间所做的差异。'
- en: In unified `diff`, the lines starting with `+` are the newly added lines and
    the lines starting with `–` are the removed lines.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在统一的`diff`中，以`+`开头的行是新添加的行，以`-`开头的行是被删除的行。
- en: 'A patch file can be generated by redirecting the `diff` output to a file, as
    follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将`diff`输出重定向到文件来生成补丁文件，如下所示：
- en: '[PRE77]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Now using the patch command we can apply changes to any of the two files. When
    applied to `version1.txt`, we get `version2.txt` file. When applied to `version2.txt`,
    we receive `version1.txt`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用补丁命令，我们可以将更改应用到任何两个文件中。当应用到`version1.txt`时，我们得到`version2.txt`文件。当应用到`version2.txt`时，我们得到`version1.txt`。
- en: 'Apply the patch by using the following command:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令应用补丁：
- en: '[PRE78]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We now have `version1.txt` with the same contents as that of `version2.txt`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了与`version2.txt`内容相同的`version1.txt`。
- en: 'In order to revert the changes back, use the following command:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将更改还原，使用以下命令：
- en: '[PRE79]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Revert the changes without prompting the user with `y/n` by using the `–R` option
    along with the patch command.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-R`选项以及补丁命令来在不提示用户输入`y/n`的情况下还原更改。
- en: There's more...
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's go through additional features available with `diff`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`diff`提供的其他功能。
- en: Generating diff against directories
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对目录生成差异
- en: The `diff` command can also act recursively against directories. It will generate
    a difference output for all the descendant files in the directories.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`diff`命令也可以递归地针对目录进行操作。它将为目录中所有后代文件生成差异输出。'
- en: 'Use the following command:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令：
- en: '[PRE80]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The interpretation of each of the above options is as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 上述每个选项的解释如下：
- en: '`-N` is for treating absent files as empty'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-N`是用于将缺失的文件视为空文件'
- en: '`-a` is to consider all files as text files'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-a`是为了将所有文件视为文本文件'
- en: '`-u` is to produce unified output'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-u`是为了生成统一的输出'
- en: '`-r` is to recursively traverse through the files in the directories'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-r`是为了递归遍历目录中的文件'
- en: head and tail – printing the last or first 10 lines
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: head和tail - 打印最后或前10行
- en: When looking into a large file, which consists of thousands of lines, we will
    not use a command like `cat` to print the entire file contents. Instead we look
    for a sample (for example, the first 10 lines of the file or the last 10 lines
    of the file). We may also need to print the first n lines or last n lines. Also
    we may need to print all the lines except the last "n" lines or all lines except
    first "n" lines.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看一个包含成千上万行的大文件时，我们不会使用`cat`命令来打印整个文件内容。相反，我们寻找一个样本（例如，文件的前10行或最后10行）。我们可能还需要打印前n行或最后n行。还可能需要打印除了最后的“n”行之外的所有行或除了前面的“n”行之外的所有行。
- en: Another use case is to print lines from n-th to m-th lines.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用例是打印从第n行到第m行的行。
- en: The commands `head` and `tail` can help us do this.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`head`和`tail`命令可以帮助我们做到这一点。'
- en: How to do it...
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The `head` command always reads the header portion of the input file.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`head`命令总是读取输入文件的头部部分。'
- en: 'Print first 10 lines as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示打印前10行：
- en: '[PRE81]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Read the data from stdin as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 从stdin读取数据如下：
- en: '[PRE82]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Specify the number of first lines to be printed as follows:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 指定要打印的前几行的数量如下：
- en: '[PRE83]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This command prints four lines.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令打印四行。
- en: 'Print all lines excluding the last `N` lines as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示打印除了最后的`N`行之外的所有行：
- en: '[PRE84]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Note that it is negative N.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这是负N。
- en: 'For example, to print all the lines except the last 5 lines use the following
    code:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要打印除了最后5行之外的所有行，请使用以下代码：
- en: '[PRE85]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The following command will, however, print from 1 to 5:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下命令将从1打印到5：
- en: '[PRE86]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Printing by excluding the last lines is a very important usage of `head`. But
    people always look at some other complex methods to do the same.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 通过排除最后几行进行打印是`head`的一个非常重要的用法。但是人们总是寻找其他复杂的方法来做同样的事情。
- en: 'Print the last 10 lines of a file as follows:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 打印文件的最后10行如下：
- en: '[PRE87]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In order to read from `stdin`, you can use the following code:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从`stdin`读取，您可以使用以下代码：
- en: '[PRE88]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Print the last 5 lines as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 打印最后5行如下：
- en: '[PRE89]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In order to print all lines excluding first N lines, use the following code:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印除了前N行之外的所有行，请使用以下代码：
- en: '[PRE90]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'For example, to print all lines except the first 5 lines, N + 1 = 6, therefore
    the command will be as follows:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要打印除了前5行之外的所有行，N + 1 = 6，因此命令将如下所示：
- en: '[PRE91]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This will print from 6 to 100.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印从6到100。
- en: 'One of the important usages of `tail` is to read a constantly growing file.
    Since new lines are constantly appended to the end of the file, `tail` can be
    used to display all new lines as they are written to the file. When we run `tail`
    simply, it will read the last 10 lines and exit. However, by that time, new lines
    would have been appended to the file by some process. In order to constantly monitor
    the growth of file, `tail` has a special option `-f` or `--follow`, which enables
    `tail` to follow the appended lines and keep being updated with the data growth:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail`的一个重要用途是读取不断增长的文件。由于新行不断附加到文件的末尾，`tail`可以用来显示随着写入文件而不断增加的所有新行。当我们简单运行`tail`时，它将读取最后10行并退出。然而，到那时，某个进程可能已经向文件附加了新行。为了不断监视文件的增长，`tail`有一个特殊选项`-f`或`--follow`，它使`tail`能够跟踪附加的行并保持与数据增长的更新：'
- en: '[PRE92]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'An example of such growing files are logfiles. The command to monitor the growth
    of the files would be:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这种增长文件的一个例子是日志文件。监视文件增长的命令将是：
- en: '[PRE93]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: or
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE94]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We frequently run `dmesg` to look at kernel ring buffer messages either to debug
    the USB devices or to look at the `sdX` (`X` is the minor number for the `sd`
    device). The `tail -f` can also add a sleep interval `-s`, so that we can set
    the interval during which the file updates are monitored.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常运行`dmesg`来查看内核环形缓冲区消息，无论是调试USB设备还是查看`sdX`（`X`是`sd`设备的次要编号）。`tail -f`还可以添加一个睡眠间隔`-s`，这样我们就可以设置在监视文件更新的时间间隔。
- en: '`tail` has the interesting property that allows it to terminate after a given
    process ID dies.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail`具有一个有趣的属性，允许它在给定的进程ID死亡后终止。'
- en: Suppose we are reading a growing file, and a process `Foo` is appending data
    to the file, `tail -f` should be executed until process `Foo` dies.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在读取一个增长的文件，并且一个进程`Foo`正在向文件附加数据，应该执行`tail -f`直到进程`Foo`死亡。
- en: '[PRE95]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: When the process `Foo` terminates, `tail` also terminates.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程`Foo`终止时，`tail`也会终止。
- en: Let's work on an example.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。
- en: Create a new file `file.txt` and open the file in gedit (You can use any text
    editor).
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何文本编辑器创建一个新文件`file.txt`并打开文件。
- en: Add new lines to the file and make frequent file saves in gedit.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在gedit中向文件添加新行并频繁保存文件。
- en: 'Now run:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行：
- en: '[PRE96]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: When you make frequent changes to the file, it will be written to the terminal
    by the tail command. When you close the `gedit`, the `tail` command will get terminated.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 当您频繁更改文件时，`tail`命令将将其写入终端。当您关闭`gedit`时，`tail`命令将被终止。
- en: Listing only directories – alternative methods
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅列出目录-替代方法
- en: Though listing only directories seems to be a simple task, many would not be
    able to do it. I have seen this often, even when asked to people who are good
    at shell scripting. This recipe is worth knowing since it introduces multiple
    ways of listing only directories with various tricky techniques.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管只列出目录似乎是一个简单的任务，但许多人可能无法做到。我经常看到这种情况，即使是问擅长shell脚本的人也是如此。这个技巧很值得知道，因为它介绍了多种只列出目录的技巧和技术。
- en: Getting ready
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: There are multiple ways of listing directories only. When you ask people about
    these techniques, the first answer that they would probably give is `dir`. But,
    it is wrong. The `dir` command is just another command like `ls` with fewer options
    than `ls`. Let's see how to list directories.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种只列出目录的方法。当您询问人们这些技术时，他们可能会给出的第一个答案可能是`dir`。但是，这是错误的。`dir`命令只是另一个像`ls`一样的命令，比`ls`的选项少。让我们看看如何列出目录。
- en: How to do it...
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'There are four ways in which directories in the current path can be displayed.
    They are:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 当前路径中目录可以显示的四种方式。它们是：
- en: '**$ ls -d */**'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$ ls -d */**'
- en: Only the above combination with `-d` will print directories.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 只有与`-d`结合使用的组合才会打印目录。
- en: '**$ ls -F | grep "/$"**'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$ ls -F | grep "/$"**'
- en: When the `-F` parameter is used, all entries are appended with some type of
    file character such as `@`, `*`, `|`, and so on. For directories, entries are
    appended with the `/` character. We use `grep` to filter only entries ending with
    the `/$` end of line indicator.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`-F`参数时，所有条目都附加有某种文件字符，如`@`、`*`、`|`等。对于目录，条目都附加有`/`字符。我们使用`grep`来过滤只以`/$`结尾的条目。
- en: '**$ ls -l | grep "^d"**'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$ ls -l | grep "^d"**'
- en: The first character of `ls -d` output lines of each file entries is the type
    of file character. For directory, the type of file character is `"d"`. Hence we
    use `grep` to filter lines starting with `"d"`. `^` is the start of line indicator.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls -d`输出每个文件条目的行的第一个字符是文件类型字符。对于目录，文件类型字符是`"d"`。因此我们使用`grep`来过滤以`"d"`开头的行。`^`是行起始指示符。'
- en: '**$ find . -type d -maxdepth 1 -print**'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**$ find . -type d -maxdepth 1 -print**'
- en: The `find` command can take the parameter `type` as directory and `maxdepth`
    is set to `1` since it should not search the directories of descendants.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`命令可以使用参数`type`作为目录，并且`maxdepth`设置为`1`，因为它不应搜索后代目录。'
- en: Fast command-line navigation using pushd and popd
  id: totrans-487
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pushd和popd进行快速命令行导航
- en: When dealing with multiple locations on a terminal or shell prompt, our common
    practice is to copy and paste the paths. Copy-paste is only effective when mouse
    is used. When there is only command-line access without a GUI, it is hard to deal
    with navigation through multiple paths. For example, if we are dealing with locations
    `/var/www`, `/home/slynux`, and `/usr/src`, when we need to navigate these locations
    one by one, it is really difficult to type the path every time when we need to
    switch between the paths. Hence the command-line interface (CLI) based navigation
    techniques such as pushd and popd are used. Let's see how to practice them.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端或shell提示符上处理多个位置时，我们的常见做法是复制和粘贴路径。只有在使用鼠标时，复制粘贴才有效。当只有命令行访问而没有GUI时，很难通过多个路径进行导航。例如，如果我们正在处理位置`/var/www`、`/home/slynux`和`/usr/src`，当我们需要逐个导航到这些位置时，每次需要在路径之间切换时键入路径是非常困难的。因此，基于命令行界面（CLI）的导航技术，如pushd和popd被使用。让我们看看如何练习它们。
- en: Getting ready
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: '`pushd` and `popd` are used to switch between multiple directories without
    the copy-paste of directory paths. `pushd` and `popd` operate on a stack. We know
    that stack is a **Last** **In** **First** **Out** (**LIFO**) data structure. It
    will store the directory paths in a stack and switch between them using push and
    pop operations.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushd`和`popd`用于在多个目录之间切换，而无需复制粘贴目录路径。`pushd`和`popd`在堆栈上操作。我们知道堆栈是**后进先出**（LIFO）的数据结构。它将在堆栈中存储目录路径，并使用推送和弹出操作在它们之间切换。'
- en: How to do it...
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: We omit the use of the `cd` command while using `pushd` and `popd`.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`pushd`和`popd`时，我们省略了`cd`命令的使用。
- en: 'In order to push and change directory to a path use:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 为了推送并更改目录到一个路径使用：
- en: '[PRE97]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Now the stack contains `/var/www ~` and the current directory is changed to
    `/var/www`.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 现在堆栈包含`/var/www ~`，当前目录更改为`/var/www`。
- en: 'Now again push the next directory path as follows:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次按以下方式推送下一个目录路径：
- en: '[PRE98]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Now the stack contains `/usr/src /var/www ~` and the current directory is `/usr/src`.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 现在堆栈包含`/usr/src /var/www ~`，当前目录是`/usr/src`。
- en: You can similarly push as many directory paths as needed.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以类似地推送所需的许多目录路径。
- en: 'View the stack contents by using the following command:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令查看堆栈内容：
- en: '[PRE99]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'When you want to switch to any path in the list, number each path from `0`
    to `n,` then use the path number for which we need to switch, for example:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要切换到列表中的任何路径时，从`0`到`n`为每个路径编号，然后使用需要切换的路径编号，例如：
- en: '[PRE100]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: It will rotate the stack and switch to the directory `/usr/share`.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 它将旋转堆栈并切换到目录`/usr/share`。
- en: '`pushd` will always add paths to the stack, to remove paths from the stack
    use `popd`.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushd`将始终将路径添加到堆栈中，要从堆栈中删除路径，请使用`popd`。'
- en: 'Remove a last pushed path and change directory to the next directory by using:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用以下方法删除最后推送的路径并更改目录到下一个目录：
- en: '[PRE101]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Suppose the stack is `/usr/src /var/www ~ /usr/share /etc` such that the current
    directory is `/usr/src`, `popd` will change the stack to `/var/www ~ /usr/share
    /etc` and change the directory to `/var/www`.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 假设堆栈是`/usr/src /var/www ~ /usr/share /etc`，当前目录是`/usr/src`，`popd`将把堆栈更改为`/var/www
    ~ /usr/share /etc`并将目录更改为`/var/www`。
- en: In order to remove a specific path from the list, use `popd +no`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从列表中删除特定路径，使用`popd +no`。
- en: The `no` is counted as `0` to `n` from left to right.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`no`从左到右被计为`0`到`n`。'
- en: There's more...
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's go through essential directory navigation practices.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看基本的目录导航实践。
- en: Most frequently used directory switching
  id: totrans-513
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最常用的目录切换
- en: '`pushd` and `popd` can be used when there are more than three directory paths
    are used. But when you use only two locations, there is an alternative and easier
    way. That is `cd -`.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用三个以上的目录路径时，可以使用`pushd`和`popd`。但是当您只使用两个位置时，有一种替代和更简单的方法。那就是`cd -`。
- en: 'If the current path is `/var/www`, perform the following:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当前路径是`/var/www`，执行以下操作：
- en: '[PRE102]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now to switch back to `/var/www`, you don''t have to type it out again, but
    just execute:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要切换回`/var/www`，您不必再次输入，只需执行：
- en: '[PRE103]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Now you can switch to `/usr/src` as follows:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以按以下方式切换到`/usr/src`：
- en: '[PRE104]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Counting number of lines, words, and characters in a file
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算文件中的行数、单词数和字符数
- en: Counting the number of lines, words, and characters from a text or file are
    very useful for text manipulations. In several cases, count of words or characters
    are used in indirect ways to perform some hacks to produce required output patterns
    and results. This book includes some of such tricky examples in other chapters.
    **Counting** **LOC** (**Lines of Code**) is an important application for developers.
    We may need to count special types of files excluding unnecessary files. A combination
    of `wc` with other commands help to perform that.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 对文本或文件中的行数、单词数和字符数进行计数对于文本操作非常有用。在几种情况下，单词或字符的计数以间接方式用于执行一些技巧，以产生所需的输出模式和结果。本书在其他章节中包括了一些这样棘手的例子。**计数**
    **LOC**（**代码行数**）对于开发人员来说是一个重要的应用。我们可能需要计算特定类型的文件，而排除不必要的文件。`wc`与其他命令的组合有助于执行这项工作。
- en: Getting ready
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: '`wc` is the utility used for counting. It stands for **Word Count (wc)**. Let''s
    see how to use `wc` to count lines, words, and characters.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`wc`是用于计数的实用程序。它代表**Word Count (wc)**。让我们看看如何使用`wc`来计算行数、单词数和字符数。'
- en: How to do it...
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Count number of lines as follows:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式计算行数：
- en: '[PRE105]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'In order to use `stdin` as input, use the following command:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`stdin`作为输入，使用以下命令：
- en: '[PRE106]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Count the number of words as follows:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下方式计算单词数：
- en: '[PRE107]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'In order to count number of characters, use:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算字符数，请使用：
- en: '[PRE108]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'For example, we can count the characters in a text as follows:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以按以下方式计算文本中的字符数：
- en: '[PRE109]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '`-n` is used to avoid an extra newline character.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`-n`用于避免额外的换行符。'
- en: 'When `wc` is executed without any options as:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 当`wc`没有任何选项执行时：
- en: '[PRE110]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: it will print number of lines, words, and characters delimited by tabs.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打印由制表符分隔的行数、单词数和字符数。
- en: There's more...
  id: totrans-540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's go through additional options available with `wc` command.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`wc`命令的其他可用选项。
- en: Print length of longest length line
  id: totrans-542
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打印最长行的长度
- en: '`wc` can be also used to print the length of longest line using the `–L` option:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '`wc`也可以使用`-L`选项打印最长行的长度：'
- en: '[PRE111]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Printing directory tree
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印目录树
- en: Graphically representing directories and filesystem as tree hierarchy is quite
    useful when preparing tutorials and documents. Also they are sometimes useful
    in writing certain monitoring scripts that helps to look at the filesystem using
    easy-to-read tree representations. Let's see how to do it.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 以图形方式表示目录和文件系统的树层次结构在准备教程和文档时非常有用。有时，在编写某些监控脚本时，使用易于阅读的树形表示来查看文件系统也是很有用的。让我们看看如何做到这一点。
- en: Getting ready
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `tree` command is the hero that helps to print graphical trees of files
    and directories. Usually, `tree` does not come with Linux distributions. You need
    to install it using the package manager.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '`tree`命令是帮助打印文件和目录的图形树的英雄。通常，`tree`不随Linux发行版一起提供。您需要使用软件包管理器安装它。'
- en: How to do it...
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following is a sample UNIX file system tree to show an example:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例UNIX文件系统树：
- en: '[PRE112]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '`The tree` command comes with many interesting options, let us look at few
    of them.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '`tree`命令带有许多有趣的选项，让我们看看其中的一些。'
- en: 'Highlight only files matched by pattern as follows:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 仅突出显示与模式匹配的文件，如下所示：
- en: '[PRE113]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'For example:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE114]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Highlight only files excluding the match pattern by using:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过使用排除匹配模式来突出显示文件：
- en: '[PRE115]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'In order to print size along with files and directories use the `-h` option
    as follows:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印大小以及文件和目录，使用`-h`选项如下：
- en: '[PRE116]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: There's more...
  id: totrans-561
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's see an interesting option that is available with the `tree` command.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`tree`命令提供的一个有趣选项。
- en: HTML output for tree
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 树的HTML输出
- en: It is possible to generate HTML output from the `tree` command. For example,
    use the following command to create an HTML file with tree output.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从`tree`命令生成HTML输出。例如，使用以下命令创建一个带有树输出的HTML文件。
- en: '[PRE117]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Replace `http://localhost` with the URL where you would like to host the file.
    Replace PATH with a real path for the base directory. For the current directory
    use '.' as the PATH.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 将`http://localhost`替换为您想要托管文件的URL。将PATH替换为基本目录的真实路径。对于当前目录，请使用'.'作为路径。
- en: 'The web page generated from the directory listing will look as follows:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 从目录列表生成的网页将如下所示：
- en: '![HTML output for tree](img/3760_03_01.jpg)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![树的HTML输出](img/3760_03_01.jpg)'
