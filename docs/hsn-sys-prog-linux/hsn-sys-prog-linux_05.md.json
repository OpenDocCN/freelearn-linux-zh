["```\n$ make\ngcc -Wall -c ../common.c -o common.o\ngcc -Wall -c membugs.c -o membugs.o\nmembugs.c: In function \u2018uar\u2019:\nmembugs.c:143:9: warning: function returns address of local variable [-Wreturn-local-addr]\n return name;\n ^~~~\n [...]\n\ngcc -Wall -o membugs membugs.o common.o\n\n[...]\nclang -g -ggdb -gdwarf-4 -O0 -Wall -Wextra -fsanitize=address -c membugs.c -o membugs_dbg_asan.o\nmembugs.c:143:9: warning: address of stack memory associated with local variable 'name' returned [-Wreturn-stack-address]\n return name;\n ^~~~\n\ngcc -g -ggdb -gdwarf-4 -O0 -Wall -Wextra -o membugs_dbg membugs_dbg.o common_dbg.o\n[...]\n$ \n```", "```\n$ ./membugs --help\n\nUsage: ./membugs test_case [ -h | --help]\n test case  1 : uninitialized var test case\n test case  2 : out-of-bounds : write overflow [on compile-time memory]\n test case  3 : out-of-bounds : write overflow [on dynamic memory]\n test case  4 : out-of-bounds : write underflow\n test case  5 : out-of-bounds : read overflow [on compile-time memory]\n test case  6 : out-of-bounds : read overflow [on dynamic memory]\n test case  7 : out-of-bounds : read underflow\n test case  8 : UAF (use-after-free) test case\n test case  9 : UAR (use-after-return) test case\n test case 10 : double-free test case\n test case 11 : memory leak test case 1: simple leak\n test case 12 : memory leak test case 2: leak more (in a loop)\n test case 13 : memory leak test case 3: \"lib\" API leak\n-h | --help : show this help screen\n$ \n```", "```\n/* test case 1 : uninitialized var test case */\nstatic void uninit_var()\n{\n   int x; /* static mem */\n\n    if (x)\n        printf(\"true case: x=%d\\n\", x);\n    else\n        printf(\"false case\\n\");\n}\n```", "```\n$ ./membugs 1\ntrue case: x=32604\n$ ./membugs 1\ntrue case: x=32611\n$ ./membugs 1\ntrue case: x=32627\n$ ./membugs 1\ntrue case: x=32709\n$ \n```", "```\n$ make \n[...]\ngcc -Wall -c membugs.c -o membugs.o\n[...]\nmembugs.c: In function \u2018uninit_var\u2019:\nmembugs.c:272:5: warning: \u2018x\u2019 is used uninitialized in this function [-Wuninitialized]\n if (x) \n ^ \n\n[...]\nclang -g -ggdb -gdwarf-4 -O0 -Wall -Wextra -fsanitize=address -c membugs.c -o membugs_dbg_asan.o\n[...]\nmembugs.c:272:6: warning: variable 'x' is uninitialized when used here [-Wuninitialized]\n if (x)\n ^\nmembugs.c:270:7: note: initialize the variable 'x' to silence this warning\n int x; /* static mem */\n ^\n = 0\n[...]\n```", "```\n/* test case 2 : out-of-bounds : write overflow [on compile-time memory] */\nstatic void write_overflow_compilemem(void)\n{\n    int i, arr[5], tmp[8];\n    for (i=0; i<=5; i++) {\n       arr[i] = 100;  /* Bug: 'arr' overflows on i==5,\n                         overwriting part of the 'tmp' variable\n                         - a stack overflow! */\n    }\n}\n```", "```\n$ ./membugs 2\n$ ./membugs_dbg 2\n$ \n```", "```\n for (i = 0; i <= 50; i++) {\n    arr[i] = 100;\n}\n```", "```\n$ ./membugs 2\n*** stack smashing detected ***: <unknown> terminated\nAborted\n$ \n```", "```\n/* test case 3 : out-of-bounds : write overflow [on dynamic memory] */\nstatic void write_overflow_dynmem(void)\n{\n    char *dest, src[] = \"abcd56789\";\n\n    dest = malloc(8);\n    if (!dest) \n\n    FATAL(\"malloc failed\\n\");\n\n    strcpy(dest, src); /* Bug: write overflow */\n    free(dest);\n}\n```", "```\n$ ./membugs 3\n$ ./membugs 3           *<< try once more >>*\n$ \n```", "```\n/* test case 4 : out-of-bounds : write underflow */\nstatic void write_underflow(void)\n{\n    char *p = malloc(8);\n    if (!p)\n        FATAL(\"malloc failed\\n\");\n    p--;\n    strncpy(p, \"abcd5678\", 8); /* Bug: write underflow */\n    free(++p);\n}\n```", "```\n$ ./membugs 4\ndouble free or corruption (out)\nAborted\n$\n```", "```\n/* test case 5 : out-of-bounds : read overflow [on compile-time memory] */\nstatic void read_overflow_compilemem(void)\n{\n    char arr[5], tmp[8];\n\n    memset(arr, 'a', 5);\n    memset(tmp, 't', 8);\n    tmp[7] = '\\0';\n\n    printf(\"arr = %s\\n\", arr); /* Bug: read buffer overflow */\n}\n```", "```\n$ ./membugs 2>&1 | grep -w 5\n option =  5 : out-of-bounds : read overflow [on compile-time memory]\n$ ./membugs 5\narr = aaaaattttttt\n$ \n```", "```\n$ ./membugs 5\narr = aaaaa0<5=\ufffd\n$ ./membugs 5\narr = aaaaa\ufffd:\ufffd\ufffd\n$ \n```", "```\n/* test case 6 : out-of-bounds : read overflow [on dynamic memory] */\nstatic void read_overflow_dynmem(void)\n{\n    char *arr;\n\n    arr = malloc(5);\n    if (!arr)\n        FATAL(\"malloc failed\\n\",);\n    memset(arr, 'a', 5);\n\n    /* Bug 1: Steal secrets via a buffer overread.\n     * Ensure the next few bytes are _not_ NULL.\n     * Ideally, this should be caught as a bug by the compiler,\n     * but isn't! (Tools do; seen later).\n     */\n    arr[5] = 'S'; arr[6] = 'e'; arr[7] = 'c';\n    arr[8] = 'r'; arr[9] = 'e'; arr[10] = 'T';\n    printf(\"arr = %s\\n\", arr);\n\n    /* Bug 2, 3: more read buffer overflows */\n    printf(\"*(arr+100)=%d\\n\", *(arr+100));\n    printf(\"*(arr+10000)=%d\\n\", *(arr+10000));\n\n    free(arr);\n}\n```", "```\n$ ./membugs 2>&1 |grep -w 6\n option =  6 : out-of-bounds : read overflow [on dynamic memory]\n$ ./membugs 6\narr = aaaaaSecreT\n*(arr+100)=0\n*(arr+10000)=0\n$  \n```", "```\n/* test case 7 : out-of-bounds : read underflow */\nstatic void read_underflow(int cond)\n{\n    char *dest, src[] = \"abcd56789\", *orig;\n\n    printf(\"%s(): cond %d\\n\", __FUNCTION__, cond);\n    dest = malloc(25);\n    if (!dest)\n        FATAL(\"malloc failed\\n\",);\n    orig = dest;\n\n    strncpy(dest, src, strlen(src));\n    if (cond) {\n *(orig-1) = 'x';\n dest --;\n }\n    printf(\" dest: %s\\n\", dest);\n\n    free(orig);\n}\n```", "```\n case 7:\n     read_underflow(0);\n     read_underflow(1);\n     break;\n```", "```\n$ ./membugs 7\nread_underflow(): cond 0\n dest: abcd56789\nread_underflow(): cond 1\n dest: xabcd56789\ndouble free or corruption (out)\nAborted (core dumped)\n$ \n```", "```\n/* test case 8 : UAF (use-after-free) test case */\nstatic void uaf(void)\n{\n    char *arr, *next;\n    char name[]=\"Hands-on Linux Sys Prg\";\n    int n=512;\n\n    arr = malloc(n);\n    if (!arr)\n        FATAL(\"malloc failed\\n\");\n    memset(arr, 'a', n);\n    arr[n-1]='\\0';\n    printf(\"%s():%d: arr = %p:%.*s\\n\", __FUNCTION__, __LINE__, arr,\n                32, arr);\n\n    next = malloc(n);\n    if (!next) {\n        free(arr);\n        FATAL(\"malloc failed\\n\");\n    }\n    free(arr);\n    strncpy(arr, name, strlen(name));  /* Bug: UAF */ \n    printf(\"%s():%d: arr = %p:%.*s\\n\", __FUNCTION__, __LINE__, arr,\n                32, arr);\n    free(next);\n}\n```", "```\n$ ./membugs 2>&1 |grep -w 8\n option =  8 : UAF (use-after-free) test case\n$ ./membugs 8\nuaf():158: arr = 0x558012280260:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nuaf():166: arr = 0x558012280260:Hands-on Linux Sys Prgaaaaaaaaaa\n$  \n```", "```\n/* test case 9 : UAR (use-after-return) test case */\nstatic void * uar(void)\n{\n    char name[32];\n\n    memset(name, 0, 32);\n    strncpy(name, \"Hands-on Linux Sys Prg\", 22);\n\n    return name;\n}\n```", "```\n[...]\n    case 9:\n            res = uar();\n            printf(\"res: %s\\n\", (char *)res);\n            break;\n[...]\n```", "```\n$ ./membugs 2>&1 |grep -w 9\n option = 9 : UAR (use-after-return) test case\n$ ./membugs 9\nres: (null)\n$ \n```", "```\n$ make membugs\ngcc -Wall -c membugs.c -o membugs.o\nmembugs.c: In function \u2018uar\u2019:\nmembugs.c:143:9: warning: function returns address of local variable [-Wreturn-local-addr]\n return name;\n ^~~~\n[...]\n```", "```\n/* test case 10 : double-free test case */\nstatic void doublefree(int cond)\n{\n    char *ptr;\n    char name[]=\"Hands-on Linux Sys Prg\";\n    int n=512;\n\n    printf(\"%s(): cond %d\\n\", __FUNCTION__, cond);\n    ptr = malloc(n);\n    if (!ptr)\n        FATAL(\"malloc failed\\n\");\n    strncpy(ptr, name, strlen(name));\n    free(ptr);\n\n    if (cond) {\n        bogus = malloc(-1UL); /* will fail! */\n        if (!bogus) {\n            fprintf(stderr, \"%s:%s:%d: malloc failed\\n\",\n                       __FILE__, __FUNCTION__, __LINE__);\n            free(ptr); /* Bug: double-free */\n            exit(EXIT_FAILURE);\n        }\n    }\n}\n```", "```\n$ ./membugs 10\ndoublefree(): cond 0\ndoublefree(): cond 1\nmembugs.c:doublefree:56: malloc failed\n$ \n```", "```\n$ make\n[...]\nmembugs.c: In function \u2018doublefree\u2019:\nmembugs.c:125:9: warning: argument 1 value \u201818446744073709551615\u2019 exceeds maximum object size 9223372036854775807 [-Walloc-size-larger-than=]\n bogus = malloc(-1UL); /* will fail! */\n ~~~~~~^~~~~~~~~~~~~~\nIn file included from membugs.c:18:0:\n/usr/include/stdlib.h:539:14: note: in a call to allocation function \u2018malloc\u2019 declared here\n extern void *malloc (size_t __size) __THROW __attribute_malloc__ __wur;\n ^~~~~~\n[...]\n```", "```\nstatic const size_t BLK_1MB = 1024*1024;\n[...]\nstatic void amleaky(size_t mem)\n{\n    char *ptr;\n\n    ptr = malloc(mem);\n    if (!ptr)\n        FATAL(\"malloc(%zu) failed\\n\", mem);\n\n    /* Do something with the memory region; else, the compiler\n     * might just optimize the whole thing away!\n     * ... and we won't 'see' the leak.\n     */\n    memset(ptr, 0, mem);\n\n    /* Bug: no free, leakage */\n}\n\n[...]\n/* test case 11 : memory leak test case 1: simple leak */\nstatic void leakage_case1(size_t size)\n{\n printf(\"%s(): will now leak %zu bytes (%ld MB)\\n\",\n     __FUNCTION__, size, size/(1024*1024));\n amleaky(size);\n}\n\n[...]\n\n case 11:\n     leakage_case1(32);\n     leakage_case1(BLK_1MB);\n     break;\n[...]\n```", "```\n$ ./membugs 2>&1 | grep \"memory leak\"\n option = 11 : memory leak test case 1: simple leak\n option = 12 : memory leak test case 2: leak more (in a loop)\n option = 13 : memory leak test case 3: lib API leak\n$ ./membugs 11\nleakage_case1(): will now leak 32 bytes (0 MB)\nleakage_case1(): will now leak 1048576 bytes (1 MB)\n$ \n```", "```\n[...]\n\n/* test case 12 : memory leak test case 2: leak in a loop */\nstatic void leakage_case2(size_t size, unsigned int reps)\n{\n    unsigned int i, threshold = 3*BLK_1MB;\n    double mem_leaked;\n\n    if (reps == 0)\n        reps = 1;\n    mem_leaked = size * reps;\n    printf(\"%s(): will now leak a total of %.0f bytes (%.2f MB)\"\n            \" [%zu bytes * %u loops]\\n\",\n            __FUNCTION__, mem_leaked, mem_leaked/(1024*1024),\n            size, reps);\n\n    if (mem_leaked >= threshold)\n        system(\"free|grep \\\"^Mem:\\\"\");\n\n    for (i=0; i<reps; i++) {\n        if (i%10000 == 0)\n            printf(\"%s():%6d:malloc(%zu)\\n\", __FUNCTION__, i, size);\n        amleaky(size);\n    }\n\n    if (mem_leaked >= threshold)\n       system(\"free|grep \\\"^Mem:\\\"\"); printf(\"\\n\");\n}\n\n[...]\n\n  case 12:\n leakage_case2(32, 100000);\n leakage_case2(BLK_1MB, 12);\n break;\n[...]\n```", "```\n$ free\n total     used       free    shared   buff/cache  available\nMem:  16305508   5906672   348744   1171944   10050092   10248116\nSwap:  8000508         0  8000508\n$ \n```", "```\n$ free | grep \"^Mem:\"\nMem:  16305508   5922772   336436   1165960   10046300   10237452\n$ \n```", "```\nif (mem_leaked >= threshold) system(\"free|grep \\\"^Mem:\\\");\n```", "```\n$ ./membugs 12\nleakage_case2(): will now leak a total of 3200000 bytes (3.05 MB) \n [32 bytes * 100000 loops]\nMem:   16305508     5982408   297708   1149648   10025392   10194628\nleakage_case2():     0:malloc(32)\nleakage_case2(): 10000:malloc(32)\nleakage_case2(): 20000:malloc(32)\nleakage_case2(): 30000:malloc(32)\nleakage_case2(): 40000:malloc(32)\nleakage_case2(): 50000:malloc(32)\nleakage_case2(): 60000:malloc(32)\nleakage_case2(): 70000:malloc(32)\nleakage_case2(): 80000:malloc(32)\nleakage_case2(): 90000:malloc(32)\nMem:   16305508     5986996   293120   1149648   10025392   10190040\n\nleakage_case2(): will now leak a total of 12582912 bytes (12.00 MB) \n [1048576 bytes * 12 loops]\nMem:   16305508     5987500   292616   1149648   10025392   10189536\nleakage_case2():     0:malloc(1048576)\nMem:   16305508     5999124   280992   1149648   10025392   10177912\n$ \n```", "```\n/* \n * A demo: this function allocates memory internally; the caller\n * is responsible for freeing it!\n */\nstatic void silly_getpath(char **ptr)\n{\n#include <linux/limits.h>\n    *ptr = malloc(PATH_MAX);\n    if (!ptr)\n        FATAL(\"malloc failed\\n\");\n\n    strcpy(*ptr, getenv(\"PATH\"));\n    if (!*ptr)\n        FATAL(\"getenv failed\\n\");\n}\n\n/* test case 13 : memory leak test case 3: \"lib\" API leak */\nstatic void leakage_case3(int cond)\n{\n    char *mypath=NULL;\n\n    printf(\"\\n## Leakage test: case 3: \\\"lib\\\" API\"\n        \": runtime cond = %d\\n\", cond);\n\n    /* Use C's illusory 'pass-by-reference' model */\n    silly_getpath(&mypath);\n    printf(\"mypath = %s\\n\", mypath);\n\n    if (cond) /* Bug: if cond==0 then we have a leak! */\n        free(mypath);\n}\n```", "```\n[...]\ncase 13:\n     leakage_case3(0);\n     leakage_case3(1);\n     break;\n```", "```\n$ ./membugs 13\n\n## Leakage test: case 3: \"lib\" API: runtime cond = 0\nmypath = /usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/sbin:/usr/sbin:/usr/local/sbin:/home/kai/MentorGraphics/Sourcery_CodeBench_Lite_for_ARM_GNU_Linux/bin/:/mnt/big/scratchpad/buildroot-2017.08.1/output/host/bin/:/sbin:/usr/sbin:/usr/local/sbin\n\n## Leakage test: case 3: \"lib\" API: runtime cond = 1\nmypath = /usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/sbin:/usr/sbin:/usr/local/sbin:/home/kai/MentorGraphics/Sourcery_CodeBench_Lite_for_ARM_GNU_Linux/bin/:/mnt/big/scratchpad/buildroot-2017.08.1/output/host/bin/:/sbin:/usr/sbin:/usr/local/sbin\n$ \n```", "```\n#include <Xm/Xm.h>\nXmString XmStringCreateLocalized(char *text);\n```", "```\n[...]\n\nThe function will allocate space to hold the returned compound string. The application is responsible for managing the allocated space. The application can recover the allocated space by calling XmStringFree. \n[...]\n```", "```\nunsigned long *uptr; \n[...] \n    my_awesome_func(uptr); // bug! value to be returned in 'uptr'\n[...]\n```", "```\nunsigned long *uptr; \n[...]\n    uptr = malloc(sizeof(unsigned long));\n    if (!uptr) {\n        [...handle the error...]\n    }\n    my_awesome_func(uptr); // value returned in 'uptr'\n    [...]\n    free(uptr);\n```", "```\nunsigned long uptr; // compile-time allocated memory\n[...] \n    my_awesome_func(&uptr); // value returned in 'uptr'\n[...]\n```"]