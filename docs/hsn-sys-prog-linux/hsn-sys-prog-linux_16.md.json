["```\nstatic char *gbuf = NULL;\n\nstatic void testit(FILE * wrstrm, FILE * rdstrm, int numio)\n{\n  int i, syscalls = NREAD*numio/getpagesize();\n  size_t fnr=0;\n\n  if (syscalls <= 0)\n      syscalls = 1;\n  VPRINT(\"numio=%d total rdwr=%u expected # rw syscalls=%d\\n\",\n                 numio, NREAD*numio, NREAD*numio/getpagesize());\n\n  for (i = 0; i < numio; i++) {\n     fnr = fread(gbuf, 1, NREAD, rdstrm);\n     if (!fnr)\n         FATAL(\"fread on /dev/urandom failed\\n\");\n\n     if (!fwrite(gbuf, 1, fnr, wrstrm)) {\n         free(gbuf);\n         if (feof(wrstrm))\n             return;\n         if (ferror(wrstrm))\n             FATAL(\"fwrite on our file failed\\n\");\n     }\n  }\n}\n```", "```\n...\n  gbuf = malloc(NREAD);\n  if (!gbuf)\n      FATAL(\"malloc %zu failed!\\n\", NREAD);\n...\n```", "```\nstatic void testit_mt_mtx(FILE * wrstrm, FILE * rdstrm, int numio,\n                             int thrdnum)\n{\n ...\n  for (i = 0; i < numio; i++) {\n LOCK_MTX(&mylock);\n      fnr = fread(gbuf, 1, NREAD, rdstrm);\n      UNLOCK_MTX(&mylock);\n      if (!fnr)\n          FATAL(\"fread on /dev/urandom failed\\n\");\n\n LOCK_MTX(&mylock);\n      if (!fwrite(gbuf, 1, fnr, wrstrm)) {\n          free(gbuf);\n UNLOCK_MTX(&mylock);\n          if (feof(wrstrm))\n              return;\n          if (ferror(wrstrm))\n              FATAL(\"fwrite on our file failed\\n\");\n      }\n UNLOCK_MTX(&mylock);\n   }\n}\n```", "```\n$ ./mt_iobuf_mtx 10000\n./mt_iobuf_mtx: using default stdio IO RW buffers of size 4096 bytes; # IOs=10000\nmt_iobuf_mtx.c:testit_mt_mtx:62: [Thread #0]: numio=10000   total rdwr=5120000   expected # rw syscalls=1250\nmt_iobuf_mtx.c:testit_mt_mtx:66: gbuf = 0x23e2670\nmt_iobuf_mtx.c:testit_mt_mtx:62: [Thread #1]: numio=10000   total rdwr=5120000   expected # rw syscalls=1250\nmt_iobuf_mtx.c:testit_mt_mtx:66: gbuf = 0x23e2670\n Thread #0 successfully joined; it terminated with status=0\n Thread #1 successfully joined; it terminated with status=0\n$ \n```", "```\n$ ./mt_iobuf_rfct 10000\n./mt_iobuf_rfct: using default stdio IO RW buffers of size 4096 bytes; # IOs=10000\nmt_iobuf_rfct.c:testit_mt_refactored:51: [Thread #0]: numio=10000   total rdwr=5120000   expected # rw syscalls=1250\n iobuf = 0x7f283c000b20\nmt_iobuf_rfct.c:testit_mt_refactored:51: [Thread #1]: numio=10000   total rdwr=5120000   expected # rw syscalls=1250\n iobuf = 0x7f2834000b20\n Thread #0 successfully joined; it terminated with status=0\n Thread #1 successfully joined; it terminated with status=0\n$ \n```", "```\nstruct stToThread {\n    FILE *wrstrm, *rdstrm;\n    int thrdnum, numio;\n char *iobuf;\n};\nstatic struct stToThread *ToThread[NTHREADS];\nstatic void * wrapper_testit_mt_refactored(void *msg)\n{\n  struct stToThread *pstToThread = (struct stToThread *)msg;\n  assert (pstToThread);\n\n  /* Allocate the per-thread IO buffer here, thus avoiding the global\n * heap buffer completely! */\n pstToThread->iobuf = malloc(NREAD);\n  ...\n  testit_mt_refactored(pstToThread->wrstrm, pstToThread->rdstrm,\n           pstToThread->numio, pstToThread->thrdnum,\n           pstToThread->iobuf);\n\n  free(pstToThread->iobuf);\n  pthread_exit((void *)0);\n}\n```", "```\nstatic void testit_mt_refactored(FILE * wrstrm, FILE * rdstrm, int numio, int thrdnum, char *iobuf)\n{\n...\n  for (i = 0; i < numio; i++) {\n      fnr = fread(iobuf, 1, NREAD, rdstrm);\n      if (!fnr)\n          FATAL(\"fread on /dev/urandom failed\\n\");\n      if (!fwrite(iobuf, 1, fnr, wrstrm)) {\n      ...\n  }\n```", "```\ninclude <time.h>\nchar *ctime(const time_t *timep);\n```", "```\nchar *ctime_r(const time_t *timep, char *buf);\n```", "```\n// Thread Routine here\nstruct timespec tm;\nchar * mybuf = malloc(32);\n...\nclock_gettime(CLOCK_REALTIME, &tm); /* get the current 'UNIX' timestamp*/\nctime_r(&tm.tv_sec, mybuf); /* put the human-readable ver into 'mybuf'*/\n...\nfree(mybuf);\n```", "```\n__thread long l;\nextern __thread struct MyStruct s1;\nstatic __thread int safe;\n```", "```\nstatic __thread char iobuf[NREAD];     // our TLS variable\n\nstatic void testit_mt_tls(FILE * wrstrm, FILE * rdstrm, int numio, int thrdnum)\n{\n  int i, syscalls = NREAD*numio/getpagesize();\n  size_t fnr=0;\n\n  if (syscalls <= 0)\n    syscalls = 1;\n  VPRINT(\"[Thread #%d]: numio=%d total rdwr=%u expected # rw \n          syscalls=%d\\n\"\n         \" iobuf = %p\\n\", thrdnum, numio, NREAD*numio, syscalls, iobuf);\n...\n```", "```\n$ ./mt_iobuf_tls 12500\n./mt_iobuf_tls: using default stdio IO RW buffers of size 4096 bytes; # IOs=12500\nmt_iobuf_tls.c:testit_mt_tls:48: [Thread #0]: numio=12500 total rdwr=6400000 expected # rw syscalls=1562\n iobuf = 0x7f23df1af500\nmt_iobuf_tls.c:testit_mt_tls:48: [Thread #1]: numio=12500 total rdwr=6400000 expected # rw syscalls=1562\n iobuf = 0x7f23de9ae500\n Thread #0 successfully joined; it terminated with status=0\n Thread #1 successfully joined; it terminated with status=0\n$ \n```", "```\nint main(void)\n{\n...  \n  // Lets send a cancel request to thread A (the first worker thread)\n  ret = pthread_cancel(tid[0]);\n  if (ret)\n      FATAL(\"pthread_cancel(thread 0) failed! [%d]\\n\", ret);\n\n  // Thread join loop\n  for (i = 0; i < NTHREADS; i++) {\n      printf(\"main: joining (waiting) upon thread #%ld ...\\n\", i);\n      ret = pthread_join(tid[i], (void **)&stat);\n      ...\n          printf(\"Thread #%ld successfully joined; it terminated with\"\n                 \"status=%ld\\n\", i, stat);\n          if ((void *)stat == PTHREAD_CANCELED)\n              printf(\" *** Was CANCELLED ***\\n\");\n      }\n  }\n```", "```\nvoid * worker(void *data)\n{\n  long datum = (long)data;\n  int slptm=8, ret=0;\n\n  if (datum == 0) { /* \"Thread A\"; lets keep it in a 'critical' state,\n           non-cancellable, for a short while, then enable\n           cancellation upon it. */\n      printf(\" worker #%ld: disabling Cancellation:\"\n      \" will 'work' now...\\n\", datum);\n      if ((ret = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL)))\n          FATAL(\"pthread_setcancelstate failed 0 [%d]\\n\", ret);\n      DELAY_LOOP(datum+48, 100);   // the 'work'\n      printf(\"\\n worker #%ld: enabling Cancellation\\n\", datum);\n      if ((ret = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL)))\n          FATAL(\"pthread_setcancelstate failed 1 [%d]\\n\", ret);\n  }\n\n  printf(\" worker #%ld: will sleep for %ds now ...\\n\", datum, slptm);\n sleep(slptm); // sleep() is a 'cancellation point'\n  printf(\" worker #%ld: work (eyeroll) done, exiting now\\n\", datum);\n\n  /* Terminate with success: status value 0.\n   * The join will pick this up. */\n  pthread_exit((void *)0);\n}\n```", "```\n$ ./cancelit_dbg \nmain: creating thread #0 ...\nmain: creating thread #1 ...\n worker #0: disabling Cancellation: will 'work' now...\n0 worker #1: will sleep for 8s now ...\nmain: joining (waiting) upon thread #0 ...\n000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n worker #0: enabling Cancellation\n worker #0: will sleep for 8s now ...\nThread #0 successfully joined; it terminated with status=-1\n *** Was CANCELLED ***\nmain: joining (waiting) upon thread #1 ...\n worker #1: work (eyeroll) done, exiting now\nThread #1 successfully joined; it terminated with status=0\n\nmain: now dying... <Dramatic!> Farewell!\n$ \n```", "```\nvoid pthread_cleanup_push(void (*routine)(void *), void *arg);\n```", "```\nstatic void cleanup_handler(void *arg)\n{\n    printf(\"+++ In %s +++\\n\" \" free-ing buffer %p\\n\", __func__, arg);\n free(arg);\n}\n...\nstatic void *wrapper_testit_mt_refactored(void *msg)\n{\n  struct stToThread *pstToThread = (struct stToThread *)msg;\n  ...\n  /* Allocate the per-thread IO buffer here, thus avoiding the global\n   * heap buffer completely! */\n pstToThread->iobuf = malloc(NREAD);\n  ...\n /* Install a 'cleanup handler' routine */\n pthread_cleanup_push(cleanup_handler, pstToThread->iobuf);\n\n  testit_mt_refactored(pstToThread->wrstrm, pstToThread->rdstrm,\n           pstToThread->numio, pstToThread->thrdnum,\n           pstToThread->iobuf);\n\n/* *Must* invoke the 'push's counterpart: the cleanup 'pop' routine;\n * passing 0 as parameter just registers it, it does not actually pop\n * off and execute the handler. Why not? Because that's precisely what\n * the next API, the pthread_exit(3) will implicitly do!\n */\n pthread_cleanup_pop(0);\n  free(pstToThread->iobuf);\n\n // Required for pop-ping the cleanup handler!\n pthread_exit((void *)0);\n}\n```", "```\n...\n  if (atoi(argv[2]) == 1) {\n    /* Lets send a cancel request to thread A */\n    ret = pthread_cancel(tid[0]);\n  ...\n```", "```\n$ ./cleanup_hdlr 23114 1\n./cleanup_hdlr: using default stdio IO RW buffers of size 4096 bytes; # IOs=23114\nmain: sending CANCEL REQUEST to worker thread 0 ...\ncleanup_hdlr.c:testit_mt_refactored:52: [Thread #0]: numio=23114 total rdwr=11834368 expected # rw syscalls=2889\n iobuf = 0x7f2364000b20\ncleanup_hdlr.c:testit_mt_refactored:52: [Thread #1]: numio=23114 total rdwr=11834368 expected # rw syscalls=2889\n iobuf = 0x7f235c000b20\n+++ In cleanup_handler +++\n free-ing buffer 0x7f2364000b20\n Thread #0 successfully joined; it terminated with status=-1\n : was CANCELED\n Thread #1 successfully joined; it terminated with status=0\n$ \n```", "```\n// ... in main:\n/* Block *all* signals here in the main thread.\n * Now all subsequently created threads also block all signals. */\n  sigfillset(&sigset);\n  if (pthread_sigmask(SIG_BLOCK, &sigset, NULL))\n      FATAL(\"main: pthread_sigmask failed\");\n...\n  /*--- Create the dedicated signal handling thread ---*/\n  ret = pthread_create(&pthrd[t], &attr, signal_handler, NULL);\n  if (ret)\n      FATAL(\"pthread_create %ld failed [%d]\\n\", t, ret);\n...\n```", "```\nstatic void *signal_handler(void *arg)\n{\n  sigset_t sigset;\n  int sig;\n\n  printf(\"Dedicated signal_handler() thread alive..\\n\");\n  while (1) {\n      /* Wait for any/all signals */\n      if (sigfillset(&sigset) == -1)\n          FATAL(\"sigfillset failed\");\n      if (sigwait(&sigset, &sig) < 0)\n          FATAL(\"sigwait failed\");\n\n  /* Note on sigwait():\n   * sigwait suspends the calling thread until one of (any of) the  \n   * signals in set is delivered to the calling thread. It then stores \n   * the number of the signal received in the location pointed to by \n   * \"sig\" and returns. The signals in set must be blocked and not \n   * ignored on entrance to sigwait. If the delivered signal has a \n   * signal handler function attached, that function is *not* called.\n   */\n switch (sig) {\n    case SIGINT:\n        // Perform signal handling for SIGINT here\n        printf(\"+++ signal_handler(): caught signal #%d +++\\n\", sig);\n        break;\n    case SIGQUIT:\n        // Perform signal handling for SIGQUIT here\n        printf(\"+++ signal_handler(): caught signal #%d +++\\n\", sig);\n        break;\n    case SIGIO:\n        // Perform signal handling for SIGIO here\n        printf(\"+++ signal_handler(): caught signal #%d +++\\n\", sig);\n        break;\n    default:\n        // Signal <whichever> caught\n        printf(\"*** signal_handler(): caught signal #%2d [unhandled] ***\\n\", sig);\n        break;\n    }\n  }\n  return (void *)0;\n}\n```", "```\n(gdb) info threads\n Id     Target  Id              Frame\n<thr#>  Thread  <addr> (LWP ...) in <function> [at <srcfile>]\n```", "```\n(gdb) thread find . Thread 1 has target name 'tsig_dbg'\nThread 1 has target id 'Thread 0x7ffff7fc9740 (LWP 24943)'\nThread 2 has target name 'tsig_dbg'\nThread 2 has target id 'Thread 0x7ffff77f7700 (LWP 25010)'\nThread 3 has target name 'tsig_dbg'\nThread 3 has target id 'Thread 0x7ffff6ff6700 (LWP 25194)' (gdb) thread apply all bt\n\nThread 3 (Thread 0x7fffeffff700 (LWP 21236)):\n#0 testit_mt_refactored (wrstrm=0x603670, rdstrm=0x6038a0, numio=10, thrdnum=1, iobuf=0x7fffe8000b20 \"\")\n    at mt_iobuf_rfct.c:44\n#1 0x00000000004010e9 in wrapper_testit_mt_refactored (msg=0x603c20) at mt_iobuf_rfct.c:88\n#2 0x00007ffff7bbe594 in start_thread () from /lib64/libpthread.so.0\n#3 0x00007ffff78f1e6f in clone () from /lib64/libc.so.6\n\nThread 2 (Thread 0x7ffff77f7700 (LWP 21235)):\n#0 testit_mt_refactored (wrstrm=0x603670, rdstrm=0x6038a0, numio=10, thrdnum=0, iobuf=0x7ffff0000b20 \"\")\n    at mt_iobuf_rfct.c:44\n#1 0x00000000004010e9 in wrapper_testit_mt_refactored (msg=0x603ad0) at mt_iobuf_rfct.c:88\n#2 0x00007ffff7bbe594 in start_thread () from /lib64/libpthread.so.0\n#3 0x00007ffff78f1e6f in clone () from /lib64/libc.so.6\n\nThread 1 (Thread 0x7ffff7fc9740 (LWP 21203)):\n#0 0x00007ffff7bbfa2d in __pthread_timedjoin_ex () from /lib64/libpthread.so.0\n#1 0x00000000004013ec in main (argc=2, argv=0x7fffffffcd88) at mt_iobuf_rfct.c:150\n(gdb) \n```"]