["```\n$ readelf -l test\n\nElf file type is EXEC (Executable file)\nEntry point 0x400520\nThere are 9 program headers, starting at offset 64\n\nProgram Headers:\n  Type           Offset             VirtAddr           PhysAddr\n                 FileSiz            MemSiz              Flags  Align\n  PHDR           0x0000000000000040 0x0000000000400040 0x0000000000400040\n                 0x00000000000001f8 0x00000000000001f8  R E    8\n  INTERP         0x0000000000000238 0x0000000000400238 0x0000000000400238\n                 0x000000000000001c 0x000000000000001c  R      1\n      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]\n  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000\n                 0x00000000000008e4 0x00000000000008e4  R E    200000\n  LOAD           0x0000000000000e10 0x0000000000600e10 0x0000000000600e10\n                 0x0000000000000248 0x0000000000000250  RW     200000\n  DYNAMIC        0x0000000000000e28 0x0000000000600e28 0x0000000000600e28\n                 0x00000000000001d0 0x00000000000001d0  RW     8\n  NOTE           0x0000000000000254 0x0000000000400254 0x0000000000400254\n                 0x0000000000000044 0x0000000000000044  R      4\n  GNU_EH_FRAME   0x0000000000000744 0x0000000000400744 0x0000000000400744\n                 0x000000000000004c 0x000000000000004c  R      4\n  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000\n                 0x0000000000000000 0x0000000000000000  RW     10\n  GNU_RELRO      0x0000000000000e10 0x0000000000600e10 0x0000000000600e10\n                 0x00000000000001f0 0x00000000000001f0  R      1\n```", "```\n$ ./elfpack test\n$ readelf -l test\nElf file type is EXEC (Executable file)\nEntry point 0xa01136\nThere are 5 program headers, starting at offset 64\n\nProgram Headers:\n  Type           Offset             VirtAddr           PhysAddr\n                 FileSiz            MemSiz              Flags  Align\n  LOAD           0x0000000000000000 0x0000000000a00000 0x0000000000a00000\n                 0x0000000000002470 0x0000000000002470  R E    1000\n  LOAD           0x0000000000003000 0x0000000000c03000 0x0000000000c03000\n                 0x000000000003a23f 0x000000000003b4df  RW     1000\n```", "```\n    PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0x400000)); . = SEGMENT_START(\"text-segment\", 0x400000) + SIZEOF_HEADERS;\n    ```", "```\n    PROVIDE (__executable_start = SEGMENT_START(\"text-segment\", 0xa00000)); . = SEGMENT_START(\"text-segment\", 0xa00000) + SIZEOF_HEADERS;\n    ```", "```\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/mman.h>\n\n/*\n * This shellcode does execve(\"/bin/sh\", \u2026)\n /\nchar shellcode[] = \"\\xeb\\x1d\\x5b\\x31\\xc0\\x67\\x89\\x43\\x07\\x67\\x89\\x5b\\x08\\x67\\x89\\x43\\\"\n\"x0c\\x31\\xc0\\xb0\\x0b\\x67\\x8d\\x4b\\x08\\x67\\x8d\\x53\\x0c\\xcd\\x80\\xe8\"\n\"\\xde\\xff\"\\xff\\xff\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x4e\\x41\\x41\\x41\\x41\"\n\"\\x42\\x42\";\n\n/*\n * This function is vulnerable to a buffer overflow. Our goal is to\n * overwrite the return address with 0x41414141 which is the addresses\n * that we mmap() and store our shellcode in.\n */\nint vuln(char *s)\n{\n        char buf[32];\n        int i;\n\n        for (i = 0; i < strlen(s); i++) {\n                buf[i] = *s;\n                s++;\n        }\n}\n\nint main(int argc, char **argv)\n{\n        if (argc < 2)\n        {\n                printf(\"Please supply a string\\n\");\n                exit(0);\n        }\n        int i;\n        char *mem = mmap((void *)(0x41414141 & ~4095),\n                                 4096,\n                                 PROT_READ|PROT_WRITE|PROT_EXEC,\n                                 MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,\n                                -1,\n                                 0);\n\n        memcpy((char *)(mem + 0x141), (void *)&shellcode, 46);\n        vuln(argv[1]);\n        exit(0);\n\n}\n```", "```\n$ gcc -fno-stack-protector vuln.c -o vuln\n$ sudo chmod u+s vuln\n$ ./vuln AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n# whoami\nroot\n#\n```", "```\n $ ./maya -l2 -cse vuln\n\n[MODE] Layer 2: Anti-debugging/anti-code-injection, runtime function level protection, and outter layer of encryption on code/data\n[MODE] CFLOW ROP protection, and anti-exploitation\n[+] Extracting information for RO Relocations\n[+] Generating control flow data\n[+] Function level decryption layer knowledge information:\n[+] Applying function level code encryption:simple stream cipher S\n[+] Applying host executable/data sections: SALSA20 streamcipher (2nd layer protection)\n[+] Maya's Mind-- injection address: 0x3c9000\n[+] Encrypting knowledge: 111892 bytes\n[+] Extracting information for RO Relocations\n[+] Successfully protected binary, output file is named vuln.maya\n\n$ ./vuln.maya AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n[MAYA CONTROL FLOW] Detected an illegal return to 0x41414141, possible exploitation attempt!\nSegmentation fault\n$\n```"]