- en: '*Chapter 17*: Managing Containers with Podman, Buildah, and Skopeo'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章：使用Podman、Buildah和Skopeo管理容器
- en: In this chapter, we'll learn to use **Podman** and **Red Hat Universal Base
    Image**, also called **UBI**. Together, Podman and UBI provide users with the
    software they need to run, build, and share enterprise-quality containers on **Red
    Hat Enterprise Linux** (**RHEL**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Podman和Red Hat Universal Base Image（UBI）。Podman和UBI共同为用户提供了在**Red
    Hat Enterprise Linux**（RHEL）上运行、构建和共享企业级容器所需的软件。
- en: In recent years, understanding and using containers has become a key requirement
    for Red Hat systems administrators. In this chapter, we'll review the basics of
    containers, how containers work, and the standard tasks for managing containers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，理解和使用容器已成为Red Hat系统管理员的关键要求。在本章中，我们将回顾容器的基础知识，容器的工作原理以及管理容器的标准任务。
- en: You will learn how to run containers with simple commands, build enterprise-quality
    container images, and deploy them on a production system. You will also learn
    when to use more advanced tools such as **Buildah** and **Skopeo**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习如何使用简单命令运行容器，构建企业级容器镜像，并在生产系统上部署它们。您还将学习何时使用更高级的工具，如Buildah和Skopeo。
- en: 'These are the topics that will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器简介
- en: Running a container using Podman and UBI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Podman和UBI在本地RHEL 8系统上运行容器
- en: When to use Buildah and Skopeo
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用Buildah和Skopeo
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will review the basic usage of Podman, Buildah, and Skopeo,
    as well as how to build and run containers using Red Hat UBI.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾Podman、Buildah和Skopeo的基本用法，以及如何使用Red Hat UBI构建和运行容器。
- en: We will create and run containers on the local RHEL 8 system, as we deployed
    in [*Chapter 1*](B16799_01_Final_SK_ePub.xhtml#_idTextAnchor014), *Installing
    RHEL8*. You will need to have the `container-tools:rhel8` **Application Stream**
    installed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本地RHEL 8系统上创建和运行容器，就像我们在[*第1章*](B16799_01_Final_SK_ePub.xhtml#_idTextAnchor014)中部署的那样，*安装RHEL8*。您需要安装`container-tools:rhel8`
    **应用流**。
- en: Introduction to containers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器简介
- en: 'Containers provide users with a new way to run software on Linux systems. Containers
    provide all the dependencies related to a given piece of software, in a consistent
    redistributable manner. While containers were first made popular by Docker, Google,
    Red Hat, and many others joined Docker to create a set of open standards called
    the **Open Container Initiative** (**OCI**). The popularity of the OCI standards
    has facilitated a large ecosystem of tools where users don''t have to worry about
    compatibility between popular container images, registries, and tools. Containers
    have become standardized in recent years and most major tools follow three standards
    governed by the OCI, outlined here:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 容器为用户提供了在Linux系统上运行软件的新方式。容器以一种一致的可再分发方式提供了与给定软件相关的所有依赖关系。虽然最初是由Docker、Google、Red
    Hat等推广的，但许多其他公司加入Docker创建了一组名为**Open Container Initiative**（OCI）的开放标准。OCI标准的流行促进了一个大型的工具生态系统，用户不必担心流行的容器镜像、注册表和工具之间的兼容性。近年来，容器已经标准化，大多数主要工具遵循OCI规范，如下所述：
- en: '**Image specification**: Governs how container images are saved on disk'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像规范：规定了容器镜像在磁盘上的保存方式
- en: '**Runtime specification**: Specifies how containers are started by communicating
    with the operating system (in particular, the Linux kernel)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时规范：指定了如何通过与操作系统（特别是Linux内核）通信来启动容器
- en: '**Distribution specification**: Governs how images are pushed and pulled from
    registry servers'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发规范：规定了如何从注册表服务器推送和拉取镜像
- en: You can learn more about this at https://opencontainers.org/.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在https://opencontainers.org/了解更多信息。
- en: 'All container tools (Docker, Podman, Kubernetes, and so on) need an operating
    system to run the container, and each operating system can choose different sets
    of technology to secure containers, as long as they comply with the OCI standards.
    RHEL uses the following operating system capabilities to securely store and run
    the containers:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有容器工具（Docker、Podman、Kubernetes等）都需要一个操作系统来运行容器，每个操作系统可以选择不同的技术集来保护容器，只要它们符合OCI标准。RHEL使用以下操作系统功能来安全存储和运行容器：
- en: '**Namespaces**: These are a technology in the Linux kernel that helps isolate
    processes from one another. Namespaces prevent containerized processes from having
    visibility of other processes on the host operating system (including other containers).
    Namespaces are what make a container feel like a **virtual machine** (**VM**).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间：这是Linux内核中的一种技术，有助于将进程相互隔离。命名空间防止容器化进程看到主机操作系统上的其他进程（包括其他容器）。命名空间是使容器感觉像**虚拟机**（VM）的技术。
- en: '**Control groups (Cgroups)**: These limit the amount of **central processing
    unit** (**CPU**), memory, disk **input/output** (**I/O**), and/or network I/O
    available to a given process/container. This prevents the *noisy neighbor* problem.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制组（Cgroups）：这些限制了给定进程/容器可用的中央处理单元（CPU）、内存、磁盘输入/输出（I/O）和/或网络I/O的数量。这可以防止“吵闹的邻居”问题。
- en: '**Security-Enhanced Linux (SELinux)**: As described in [*Chapter 10*](B16799_10_Final_SK_ePub.xhtml#_idTextAnchor143),
    *Keeping Your System Hardened with SELinux*, this provides an extra layer of operating
    system security that can limit the damage caused by security exploits. SELinux
    is nearly transparent when used in conjunction with containers and provides mitigation
    of security breakouts, even when there are vulnerabilities in tools such as Podman,
    Docker, or Runc.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全增强型Linux（SELinux）：如[*第10章*](B16799_10_Final_SK_ePub.xhtml#_idTextAnchor143)中所述，使用SELinux可以提供额外的操作系统安全层，可以限制安全漏洞造成的损害。当与容器一起使用时，SELinux几乎是透明的，并且可以在工具（如Podman、Docker或Runc）存在漏洞时提供安全突破的缓解。
- en: Many systems administrators use VMs to isolate applications and their dependencies
    (libraries, and so on). Containers provide the same level of isolation but reduce
    the overhead of virtualization. Since containers are simple processes, they do
    not need a **virtual CPU** (**vCPU**) with all of the overhead of translation.
    Containers are also smaller than VMs, which simplifies management and automation.
    This is particularly useful for **continuous integration/continuous delivery**
    (**CI/CD**).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 许多系统管理员使用虚拟机来隔离应用程序及其依赖项（库等）。容器提供了相同级别的隔离，但减少了虚拟化的开销。由于容器是简单的进程，它们不需要具有所有翻译开销的**虚拟CPU**（**vCPU**）。容器也比虚拟机小，这简化了管理和自动化。这对于**持续集成/持续交付**（**CI/CD**）特别有用。
- en: 'RHEL provides users with container tools and images that are compatible with
    all OCI standards. This means they work in a way that is very familiar to anyone
    who has used Docker. For those unfamiliar with these tools and images, the following
    concepts are important:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: RHEL为用户提供了与所有OCI标准兼容的容器工具和镜像。这意味着它们的工作方式对于使用过Docker的人来说非常熟悉。对于不熟悉这些工具和镜像的人，以下概念很重要：
- en: '**Layers**: Container images are constructed as a set of layers. New containers
    are created by adding new layers (even to delete things) that reuse existing lower
    layers. The ability to use existing prepackaged containers is convenient for developers
    who simply want to make changes to their applications and test them in a reproducible
    way.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层**：容器镜像是作为一组层构建的。通过添加新层（甚至删除内容）来创建新容器，这些新层重用现有的较低层。使用现有的预打包容器的能力对于只想对其应用程序进行更改并以可重现的方式进行测试的开发人员非常方便。'
- en: '**Distribution and deployments**: Since containers provide all the dependencies
    coupled with an application, they are easy to deploy and redistribute. Combining
    them with container registries makes it easy to share container images, and collaboration,
    deployments, and rollbacks are much quicker and easier.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分发和部署**：由于容器提供了与应用程序耦合的所有依赖项，因此它们易于部署和重新分发。将它们与容器注册表结合使用，可以轻松共享容器镜像，并且协作、部署和回滚都更快更容易。'
- en: The container tools provided with RHEL make it easy to deploy containers at
    a small scale, even for production workloads. But to manage containers at scale
    and with reliability, container orchestration such as Kubernetes is a much better
    fit. Red Hat, following the lessons learned from building Linux distributions,
    has created a Kubernetes distribution called **OpenShift**. If you need to deploy
    containers at scale, we recommend you take a look at this platform. The container
    tools and images provided in RHEL, and introduced in this chapter, will provide
    a solid foundation for later deploying to Kubernetes/OpenShift if and when you
    are ready for it. The tools introduced in this chapter are built in a way that
    will prepare your applications to be deployed in Kubernetes when you are ready
    for it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: RHEL提供的容器工具使得在小规模上部署容器变得容易，即使是用于生产工作负载。但是，要以可靠的方式大规模管理容器，容器编排（如Kubernetes）是更好的选择。红帽公司根据构建Linux发行版的经验，创建了一个名为**OpenShift**的Kubernetes发行版。如果您需要大规模部署容器，我们建议您看看这个平台。RHEL提供的容器工具和镜像，以及本章介绍的内容，将为以后准备好部署到Kubernetes/OpenShift提供坚实的基础。本章介绍的工具将为您的应用程序在准备好时部署到Kubernetes做好准备。
- en: Installing container tools
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装容器工具
- en: There are two Application Streams for **container tools** provided in RHEL 8\.
    The first is a fast-moving stream that is updated every 12 weeks. The second is
    a stable stream that is released once a year and supported for 24 months.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: RHEL 8提供了两个**容器工具**的应用流。第一个是每12周更新一次的快速移动流。第二个是每年发布一次并支持24个月的稳定流。
- en: 'Before we install the container tools, let''s take a look at which ones are
    available, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装容器工具之前，让我们看一下有哪些可用的，如下所示：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s take a look at the main tools that we have listed, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下我们列出的主要工具，如下所示：
- en: '`podman`: This is the command to run containers. You may use it in every case
    in which you find the use of the `docker` command in the examples you will discover
    on the internet. It is the command we will use in this chapter to run our own
    containers.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podman`：这是运行容器的命令。您可以在任何情况下使用它，就像您在互联网上发现的示例中使用`docker`命令一样。这是我们在本章中用来运行我们自己的容器的命令。'
- en: '`buildah`: This is a tool specific to create container images. It uses the
    same Dockerfile definitions as Docker but without the need for a daemon.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buildah`：这是一个用于创建容器镜像的特定工具。它使用与Docker相同的Dockerfile定义，但不需要守护进程。'
- en: '`skopeo`: A tool to introspect containers and check the different layers so
    that we can review whether they contain any non-compliant issues.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skopeo`：这是一个用于审查容器并检查不同层的工具，以便我们可以查看它们是否包含任何不符合规范的问题。'
- en: 'We will install the fast-moving stream to get access to the latest versions
    of Podman, Skopeo, and Buildah, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装快速移动流，以便访问Podman、Skopeo和Buildah的最新版本，如下所示：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You now have a machine installed with all of the tools you need to build, run,
    and manage containers on an RHEL 8 system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了所有在RHEL 8系统上构建、运行和管理容器所需的工具。
- en: Running a container using Podman and UBI
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Podman和UBI运行容器
- en: 'Now you have the container tools'' Application Stream installed, let''s run
    a simple container based on Red Hat UBI that is a set of official container images
    and extra software based on RHEL. To run a UBI image, it only takes a single command,
    as illustrated in the following code snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了容器工具的应用流，让我们运行一个基于红帽UBI的简单容器，这是一组基于RHEL的官方容器镜像和额外软件。要运行UBI镜像，只需要一个命令，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: These tutorials run commands as root, but one of the benefits of Podman is that
    it can run containers as a regular user without special permissions or a running
    daemon in the system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些教程以root身份运行命令，但Podman的一个好处是它可以以普通用户身份运行容器，无需特殊权限或在系统中运行守护程序。
- en: You now have a fully isolated environment to execute whatever you want. You
    can run any commands you'd like in this container. It's isolated from the host
    and from other containers that might be running, and you can even install software
    on it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有一个完全隔离的环境，可以在其中执行任何您想要的操作。您可以在此容器中运行任何命令。它与主机和可能正在运行的其他容器隔离，并且甚至可以在其中安装软件。
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Red Hat UBI is based on software and packages from RHEL. This is the official
    image for use with RHEL and provides a rock solid, enterprise-ready base for your
    containers. UBI is used throughout this chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Red Hat UBI基于RHEL的软件和软件包。这是用于RHEL的官方镜像，并为您的容器提供了一个坚实、企业级的基础。UBI在本章中被广泛使用。
- en: Running a one-off container such as this is useful for testing new configuration
    changes and new pieces of software without interfering with software directly
    on the host.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这样的一次性容器对于测试新的配置更改和新的软件部件而不干扰主机上的软件非常有用。
- en: 'Let''s take a look at the processes running in the container, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看容器中正在运行的进程，如下所示：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the only processes running are the shell we are using and the
    command we have just run. It is a completely isolated environment.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，唯一正在运行的进程是我们正在使用的shell和我们刚刚运行的命令。这是一个完全隔离的环境。
- en: 'Now, exit the container by running the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过运行以下命令退出容器：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now we have a working set of container tools and a UBI container image cached
    locally, we're going to move on to some more basic commands.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地缓存了一组可工作的容器工具和UBI容器镜像，我们将继续进行一些更基本的命令。
- en: Basic container management – pull, run, stop, and remove
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本容器管理-拉取、运行、停止和移除
- en: 'In this section, we''ll run some basic commands to get familiar with using
    containers. First, let''s pull some more images, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将运行一些基本命令，以熟悉使用容器。首先，让我们拉取一些更多的镜像，如下所示：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We now have several different images cached locally. Let''s take a look at
    these here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在本地缓存了几个不同的镜像。让我们在这里看看它们：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice that we have four images cached locally. The Red Hat UBI actually comes
    in multiple flavors, as outlined here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们本地缓存了四个镜像。Red Hat UBI实际上有多种不同的版本，如下所述：
- en: "`ubi8/ubi`): An RHEL-based container base image with **YellowDog Updater Modified**\
    \ (**YUM**)/**Dandified YUM** (**DNF**) in the image. It can be used in a similar\
    \ way to any other Linux base image. This image is targeted \Lat 80% of people's\
    \ use cases and can easily be consumed from within a Dockerfile \Lor Containerfile.\
    \ The trade-off with this image is that it is larger than some of the other images."
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ubi8/ubi`): 这是一个基于RHEL的容器基础镜像，镜像中包含了**YellowDog Updater Modified** (**YUM**)/**Dandified
    YUM** (**DNF**)。它可以像任何其他Linux基础镜像一样使用。这个镜像针对80%的用户使用情况，并且可以轻松地在Dockerfile或Containerfile中使用。这个镜像的折衷之处在于它比其他一些镜像更大。'
- en: '`ubi8/ubi-minimal`): This base image minimizes the size by using a small package
    manager called `microdnf` that is written in C instead of Python, like for standard
    YUM/DNF. This C implementation makes it smaller and pulls fewer dependencies into
    a container image. This base image can be used in any Dockerfile or Containerfile
    simply by using the `microdnf` command instead of `yum`. This image saves about
    80 **megabytes** (**MB**) in memory.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ubi8/ubi-minimal`): 这个基础镜像通过使用一个名为`microdnf`的小型包管理器来最小化尺寸，该包管理器是用C编写的，而不是像标准的YUM/DNF那样使用Python。这个C实现使它更小，并且在容器镜像中拉取更少的依赖项。这个基础镜像可以在任何Dockerfile或Containerfile中使用，只需使用`microdnf`命令而不是`yum`。这个镜像在内存中节省了大约80兆字节（MB）。'
- en: '`ubi8/ubi-micro`): This base image is built without a package manager. It cannot
    be used with a standard Dockerfile or Containerfile. Users instead add software
    to this image using the Buildah tool on the container host. This image is the
    smallest base image provided in RHEL.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ubi8/ubi-micro`): 这个基础镜像没有包管理器。它不能与标准的Dockerfile或Containerfile一起使用。用户可以使用容器主机上的Buildah工具向这个镜像添加软件。这个镜像是RHEL提供的最小的基础镜像。'
- en: '`ubi8/ubi-init`): Based on the RHEL standard image, this image also supports
    the use of `systemd` in the container. This makes it easy to install a few pieces
    of software, start them with `systemd`, and treat the container in a similar way
    to a VM. This image is best for users who don''t mind slightly larger images and
    just want ease of use.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ubi8/ubi-init`): 基于RHEL标准镜像，这个镜像也支持在容器中使用`systemd`。这使得安装一些软件、使用`systemd`启动它们并将容器视为VM变得很容易。这个镜像最适合那些不介意略大一些镜像，只想要使用方便的用户。'
- en: 'Now that you understand the basics of the four types of base images, let''s
    start a container in the background so that we can inspect it while it''s running.
    Start it in the background with the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了四种基础镜像的基础知识，让我们在后台启动一个容器，以便在其运行时进行检查。使用以下命令在后台启动它：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that when we start the container, the shell returns to normal and we
    can't type commands in the container. Our terminal doesn't enter a shell in the
    container. The `-d` option specified that the container should run in the background.
    This is how most server-based software such as web servers runs on a Linux system.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们启动容器时，shell返回正常状态，我们无法在容器中输入命令。我们的终端不会进入容器中的shell。`-d`选项指定容器应在后台运行。这就是大多数基于服务器的软件（如Web服务器）在Linux系统上运行的方式。
- en: 'We can still connect our shell to a container running in the background if
    we need to troubleshoot one, but we have to determine which container we want
    to connect to. To do this, list all of the containers that are running with the
    following command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们仍然可以将我们的shell连接到后台运行的容器，但是我们必须确定要连接到哪个容器。为此，请使用以下命令列出所有正在运行的容器：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We could reference the container using the CONTAINER ID value, but we have
    started the container with the name background to make it easier to reference.
    We can enter the container and see what is going on inside it with the exec subcommand,
    as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用容器ID值引用容器，但我们已经使用名称background启动了容器，以便更容易引用。我们可以使用exec子命令进入容器并查看其中发生的情况，如下所示：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After you type a few commands, exit the container by running the following
    command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入一些命令后，通过运行以下命令退出容器：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s stop the containerized process by running the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过运行以下命令停止容器化进程：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Check to make sure it''s really stopped by running the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令确保它确实已停止：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice the state is `Exited`. This means the process has been stopped and is
    no longer in memory, but the storage is still available on disk. The container
    could be restarted, or we can delete it permanently with the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意状态是`Exited`。这意味着进程已停止并且不再在内存中，但存储仍然可用在磁盘上。容器可以重新启动，或者我们可以使用以下命令永久删除它：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This deleted the storage and the container has now gone forever. Verify this
    by running the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除存储，容器现在已经永远消失。通过运行以下命令来验证：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This section taught you some basic commands, but let's now move on to attaching
    storage.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本节向您介绍了一些基本命令，但现在让我们转向附加存储。
- en: Attaching persistent storage to a container
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将持久存储附加到容器
- en: 'Remember that the storage in a container is ephemeral. Once the `podman rm`
    command is executed, the storage is deleted. If you have data that you need to
    save after the container is removed, you need to use a volume. To run a container
    with a volume, execute the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，容器中的存储是临时的。一旦执行了`podman rm`命令，存储就会被删除。如果您有需要在容器被删除后保存的数据，您需要使用卷。要使用卷运行容器，请执行以下命令：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding command has mounted `/mnt` into the container, and the `Z` option
    has told it to appropriately change the SELinux labels so that data can be written
    to it. The `--rm` option ensures that the container is removed as soon as you
    exit the shell. You can now save data on this volume, and it won''t be removed
    when you exit the container. Add some data by running the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令已将`/mnt`挂载到容器中，并且`Z`选项已告诉它适当地更改SELinux标签，以便可以向其写入数据。`--rm`选项确保一旦退出shell，容器就会被删除。您现在可以在此卷上保存数据，并且在退出容器时不会被删除。通过运行以下命令添加一些数据：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, inspect the test file you created by running the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过运行以下命令检查您创建的测试文件：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice the file is still on the system although the container has been removed,
    and its internal storage has been deleted.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管容器已被删除并且其内部存储已被删除，但文件仍然存在于系统上。
- en: Deploying a container on a production system with systemd
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在生产系统上使用`systemd`部署容器
- en: 'Since Podman is not a daemon, it relies on `systemd` to start a container when
    the system boots. Podman makes it easy to start a container with `systemd` by
    creating a `systemd` `systemd` looks like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Podman不是守护程序，它依赖于`systemd`在系统启动时启动容器。Podman通过创建一个`systemd`来轻松启动一个`systemd`容器，`systemd`看起来像这样：
- en: Run a container with Podman exactly how you want it to run in production.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Podman以与生产环境完全相同的方式运行容器。
- en: Export a `systemd` unit file.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导出一个`systemd`单元文件。
- en: Configure `systemd` to use this unit file.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`systemd`以使用此单元文件。
- en: 'First, let''s run an example container, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们运行一个示例容器，如下所示：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s export the `systemd` unit file that we''ll use to start this container,
    as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们导出我们将用于启动此容器的`systemd`单元文件，如下所示：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Enable and start the service by running the following command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令启用并启动服务：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Test that the container is running by executing the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令测试容器是否正在运行：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, check that the container is running by using the `podman` command, as
    follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`podman`命令检查容器是否正在运行，如下所示：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This container will now start every time the system boots; even if you kill
    the container with Podman, `systemd` will always make sure this container is running.
    Podman and `systemd` make it easy to run containers in production. Now, let''s
    stop the container with `systemctl` and disable it, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器现在将在系统启动时启动；即使您使用Podman杀死容器，`systemd`也会始终确保此容器正在运行。Podman和`systemd`使得在生产环境中运行容器变得容易。现在，让我们使用`systemctl`停止容器并禁用它，如下所示：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Building a container image using a Dockerfile or Containerfile
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Dockerfile或Containerfile构建容器镜像
- en: 'Now we know how to run containers, let''s learn how to build our own container
    images. Container images are commonly built with a file that serves as a blueprint
    for how to build it the same way every time. A `Containerfile` with the following
    content:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何运行容器，让我们学习如何构建自己的容器镜像。容器镜像通常是使用作为每次构建它的蓝图的文件构建的。具有以下内容的`Containerfile`：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This simple Containerfile pulls the UBI standard base image and applies all
    of the latest updates to it. Now, let''s build a container image by running the
    following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的`Containerfile`拉取了UBI标准基础镜像，并对其应用了所有最新的更新。现在，通过运行以下命令构建一个容器镜像：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You now have a new image called `test-build` that has a new layer with all
    of the updated packages from the Red Hat UBI repositories, as illustrated in the
    following code snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有一个名为`test-build`的新镜像，其中包含来自Red Hat UBI存储库的所有更新包的新层，如下面的代码片段所示：
- en: '[PRE26]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The workflow for building images from a Dockerfile or Containerfile is nearly
    identical to how Docker was in RHEL 7 or any other operating system. This makes
    it easy for system administrators and developers to move to Podman.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从Dockerfile或Containerfile构建图像的工作流程几乎与RHEL 7中的Docker或任何其他操作系统中的工作流程相同。这使得系统管理员和开发人员可以轻松地转移到Podman。
- en: Configuring Podman to search registry servers
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Podman以搜索注册表服务器
- en: '**Container registries** are like file servers for container images. They allow
    users to build and share container images, resulting in better collaboration.
    Often, it''s useful to pull container images from public registry servers that
    are located on the internet, but in many instances, corporations have private
    registries that are not public. Podman makes it easy to search multiple registries,
    including private registries, on your company''s network.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器注册表**就像容器镜像的文件服务器。它们允许用户构建和共享容器镜像，从而实现更好的协作。通常，从位于互联网上的公共注册表服务器中拉取容器镜像是很有用的，但在许多情况下，公司有私有注册表，这些注册表不是公开的。Podman可以轻松地搜索多个注册表，包括公司网络上的私有注册表。'
- en: Podman comes with a configuration file that allows users and administrators
    to select which registries are searched by default. This makes it easy for users
    to find the container images that administrators want them to find.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Podman带有一个配置文件，允许用户和管理员选择默认搜索哪些注册表。这使得用户可以轻松找到管理员希望他们找到的容器镜像。
- en: 'A set of default registries to search are defined in `/etc/containers/registries.conf`.
    Let''s take a quick look at this file by filtering all the comments in it, as
    follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一组默认的注册表搜索在`/etc/containers/registries.conf`中定义。让我们通过过滤其中的所有注释来快速查看这个文件，如下所示：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, we have the `registries.search` section for secure registries
    that includes the two main Red Hat registries, `registry.access.redhat.com` and
    `registry.redhat.io`, as well as the `docker.io` Docker registry. All of these
    registries are secured with `registries.insecure` section.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在`registries.search`部分中为安全注册表定义了两个主要的Red Hat注册表，`registry.access.redhat.com`和`registry.redhat.io`，以及`docker.io`
    Docker注册表。所有这些注册表都在`registries.insecure`部分中进行了安全配置。
- en: Separately from TLS, all images provided by Red Hat are signed and provide a
    signature store that can be used to verify them. This is not configured by default
    and is beyond the scope of this chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了TLS之外，Red Hat提供的所有镜像都经过签名，并提供一个签名存储库，可用于验证它们。这不是默认配置，并且超出了本章的范围。
- en: 'To verify that Podman is using and searching the proper registries, run the
    following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证Podman是否正在使用和搜索正确的注册表，请运行以下命令：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you want to publish your own images, you can do this in the service that
    Red Hat offers to do so: [https://quay.io](https://quay.io). You can also configure
    `registries.conf` to search `quay.io` for images you store there.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想发布自己的镜像，可以在Red Hat提供的服务中这样做：[https://quay.io](https://quay.io)。您还可以配置`registries.conf`来搜索您在那里存储的镜像的`quay.io`。
- en: Summary of Podman options
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Podman选项摘要
- en: 'Let''s review the options used with Podman in this chapter, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来回顾一下本章中与Podman一起使用的选项，如下所示：
- en: '![](img/Table_1.1.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_1.1.jpg)'
- en: As you can see while reviewing the table, Podman includes options to manage
    the full container life cycle. Most Podman commands are compatible with `docker`.
    Podman even provides a package (`podman-docker`) that supplies an alias from `podman`
    to `docker` so that users can continue to type a command they are familiar with.
    While Podman and Docker feel quite similar to use, Podman can be run as a regular
    user and does not require a daemon to be continuously running. Let's move on to
    the next section to explore some advanced use cases.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看表格，您可以看到Podman包括管理完整容器生命周期的选项。大多数Podman命令与`docker`兼容。Podman甚至提供了一个包（`podman-docker`），它提供了从`podman`到`docker`的别名，以便用户可以继续输入他们熟悉的命令。虽然Podman和Docker在使用上感觉相似，但Podman可以作为普通用户运行，不需要持续运行的守护进程。让我们继续下一节，探索一些高级用例。
- en: When to use Buildah and Skopeo
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用Buildah和Skopeo
- en: Podman is a general-purpose container tool and should solve 95% of a user's
    needs. Podman leverages Buildah and Skopeo as libraries and pulls these tools
    together under one interface. That said, there are edge cases when a user may
    want to leverage Buildah or Skopeo separately. We will explore two such use cases.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Podman是一个通用的容器工具，应该能够解决用户95%的需求。Podman利用Buildah和Skopeo作为库，并将这些工具集成到一个界面下。也就是说，有一些边缘情况，用户可能希望单独利用Buildah或Skopeo。我们将探讨两种这样的用例。
- en: Building container images with Buildah
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Buildah构建容器镜像
- en: 'Building from a Dockerfile or Containerfile is quite easy, but it does come
    with some trade-offs. For example, Buildah is good in the following situations:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从Dockerfile或Containerfile构建非常容易，但也伴随着一些权衡。例如，Buildah在以下情况下很好用：
- en: When you need granular control over committing image layers. This can be necessary
    when you want two or three commands to run, and then commit a single layer.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您需要对提交的镜像层进行细粒度控制时。当您希望运行两到三个命令，然后提交一个单独的层时，这可能是必要的。
- en: When you have difficult-to-install software—for example, some third-party software
    comes with standardized installers that don't understand they are being run in
    a Dockerfile. Many of these `install.sh` installers assume they have access to
    the entire filesystem.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您有难以安装的软件时——例如，一些第三方软件带有标准化的安装程序，这些安装程序不知道它们正在Dockerfile中运行。许多这些`install.sh`安装程序假定它们可以访问整个文件系统。
- en: When a container image does not provide a package manager. UBI Micro builds
    very small images because it does not have a Linux package manager installed,
    nor any of the dependencies of a package manager.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个容器镜像没有提供包管理器时。UBI Micro构建非常小的镜像，因为它没有安装Linux包管理器，也没有任何包管理器的依赖项。
- en: 'For this example, let''s build on top of UBI Micro to demonstrate why Buildah
    is such a great tool. First, create a new container to work with, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，让我们在UBI Micro的基础上构建，以演示为什么Buildah是一个如此好用的工具。首先，创建一个新的容器来使用，如下所示：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding command created a reference to a new container called `ubi-micro-working-container`.
    Once Buildah creates this reference, you can build upon it. To make it easier,
    let''s start over and save the reference in a shell variable, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的命令创建了一个对名为`ubi-micro-working-container`的新容器的引用。一旦Buildah创建了这个引用，您就可以在其基础上构建。为了更方便，让我们重新开始并将引用保存在一个shell变量中，如下所示：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can then mount the new container as a volume. This lets you modify the
    container image by changing files in a directory. Run the following command to
    do this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以将新容器挂载为一个卷。这样可以通过更改目录中的文件来修改容器镜像。运行以下命令来执行此操作：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once the container storage is mounted, you can modify it in any way you would
    like. These changes will eventually be saved as a new layer in the container image.
    This is where you could run an installer (`install.sh`), but in the following
    example, we will use the package manager on the host to install packages in UBI
    Micro:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦容器存储被挂载，您可以以任何您想要的方式修改它。这些更改最终将被保存为容器镜像中的一个新层。这就是您可以运行一个安装程序（`install.sh`）的地方，但在下面的示例中，我们将使用主机上的软件包管理器在UBI
    Micro中安装软件包：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When the package installation completes, we will unmount the storage and commit
    the new image layer as a new container image called `ubi-micro-httpd`, as illustrated
    in the following code snippet:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当软件包安装完成后，我们将卸载存储并将新的镜像层提交为一个名为`ubi-micro-httpd`的新容器镜像，如下面的代码片段所示：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You now have a new container image with `httpd` installed, built on UBI Micro.
    Only a minimal set of dependencies have been pulled in. Look here at how small
    the image is:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在有一个安装了`httpd`的新容器镜像，构建在UBI Micro上。只引入了一组最小的依赖关系。看看这个镜像有多小：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Buildah is a wonderful tool that gives you a lot of control over how builds
    are done. Now, we will move on to Skopeo.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Buildah是一个很棒的工具，可以让您对构建方式有很多控制。现在，我们将转向Skopeo。
- en: Inspecting a remote container with Skopeo
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Skopeo检查远程容器
- en: 'Skopeo is specifically designed and built to work on remote container repositories.
    With the following command, you can easily remotely inspect the available tags
    for an image:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Skopeo专门设计和构建用于远程容器存储库。使用以下命令，您可以轻松地远程检查图像的可用标签：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Remote inspection is useful to determine if you want to pull an image, and if
    so, with which tag. Skopeo can also be used to copy between two remote registry
    servers without caching a copy in the local storage. For more information, see
    the `skopeo` man pages.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 远程检查对于确定是否要拉取图像以及使用哪个标签非常有用。Skopeo还可以用于在两个远程注册服务器之间进行复制，而不在本地存储中缓存副本。有关更多信息，请参阅`skopeo`手册页。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have reviewed the basics of how to run, build, and share
    containers on RHEL 8\. You are prepared to create your own containers, run them,
    manage them, and even use `systemd` to ensure they're always running in a production
    environment.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经回顾了在RHEL 8上运行、构建和共享容器的基础知识。您已经准备好创建自己的容器，运行它们，管理它们，甚至使用`systemd`来确保它们在生产环境中始终运行。
- en: You are now ready to leverage the functionality and ease of deployment that
    containers provide. While a deep dive into all of the intricacies of migrating
    software into containers is outside the scope of this book, containers simplify
    packaging and delivery of applications ready to be executed with all of their
    dependencies.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经准备好利用容器提供的功能和部署便利性。虽然深入研究将软件迁移到容器中的所有复杂性超出了本书的范围，但容器简化了应用程序的打包和交付，使其准备好以其所有依赖项一起执行。
- en: Containers are now a strong focus within the **Information Technology** (**IT**)
    industry. Containers alone simplify the packaging and delivery of applications,
    but orchestration platforms such as OpenShift (based on Kubernetes) make it easier
    to deploy, upgrade, and manage containerized applications at scale.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 容器现在是信息技术（IT）行业的一个重点关注领域。容器本身简化了应用程序的打包和交付，但基于Kubernetes的OpenShift等编排平台使得在规模上部署、升级和管理容器化应用程序变得更加容易。
- en: Congratulations—you have come to the end of this chapter! It's now time to move
    to the next chapter and take a self-assessment to ensure you've absorbed the material
    and to practice your skills. There are two more chapters to go.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您——您已经完成了本章的学习！现在是时候转到下一章，进行自我评估，确保您已经掌握了材料并练习了您的技能。还有两章要学习。
