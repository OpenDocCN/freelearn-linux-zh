- en: Chapter 7. Advanced Procmail
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。高级Procmail
- en: Now that we have got the basics of Procmail under our belt, we can move on and
    start putting together a more complete mail-handling system. The advanced techniques
    in this chapter are required only if you need a very specialized handling for
    your mail and are not needed for setting up a basic e-mail server. You may wish
    to skip this chapter and return to it once your server is fully configured and
    operational.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了Procmail的基础知识，我们可以继续开始组建一个更完整的邮件处理系统。本章中的高级技术只有在您需要非常专业的邮件处理时才需要，并且不需要为设置基本电子邮件服务器而需要。您可能希望跳过本章，在服务器完全配置和运行后再返回。
- en: 'We will be using a number of more advanced Procmail capabilities in this chapter.
    This chapter will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一些更高级的Procmail功能。本章将涵盖：
- en: The differences between delivering and non-delivering recipes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投递和非投递配方之间的区别
- en: The usage of variables, substitutions, and pseudo-variables in advanced recipes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在高级配方中使用变量、替换和伪变量
- en: Locking and the use of various flags to control execution
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定和使用各种标志来控制执行
- en: How conditions can be applied to test various parts of a message
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何应用条件来测试消息的各个部分
- en: Advanced actions to forward, save, or pass a message on to an external program
    for processing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级操作，将消息转发、保存或传递给外部程序进行处理
- en: An introduction to regular expressions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式简介
- en: Using Procmail macros to simplify e-mail header analysis
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Procmail宏简化电子邮件头部分析
- en: Detailed analysis of some advanced recipes with a number of example recipes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细分析一些高级配方，包括一些示例配方
- en: By the end of this chapter, you should have a useful tool chest of routines
    for putting together your own set of Procmail recipes and getting your mail under
    control.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该具有一套有用的例程工具箱，用于组合您自己的一套Procmail配方，并控制您的邮件。
- en: Delivering and non-delivering recipes
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投递和非投递配方
- en: 'So far we have covered only those recipes that either do a final delivery of
    the mail to a program or a file, or forward a message to another mail user. There
    is another option available, and to quote from the Procmail documentation:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只涵盖了那些要么最终将邮件传递给程序或文件，要么将消息转发给另一个邮件用户的配方。还有另一个选项可用，引用Procmail文档：
- en: There are two kinds of recipes—delivering and non-delivering recipes. If a delivering
    recipe is found to match, Procmail considers the mail (you guessed it) delivered
    and will cease processing the `.procmailrc` file after having successfully executed
    the action line of the recipe. If a non-delivering recipe is found to match, processing
    of the `.procmailrc` file will continue after the action line of this recipe has
    been executed.
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有两种类型的配方——投递和非投递配方。如果找到匹配的投递配方，Procmail会认为邮件（你猜对了）已经投递，并在成功执行配方的动作行后停止处理`.procmailrc`文件。如果找到匹配的非投递配方，此配方的动作行执行后，`.procmailrc`文件的处理将继续。
- en: Non-delivering example
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非投递示例
- en: We introduced an example in the previous chapter that was intended to make backups
    of mail items, in case a recipe that is being tested deletes all mails. This is
    a very useful non-delivering recipe example and may be found in the Procmail manual
    page `procmailex`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中介绍了一个示例，旨在备份邮件项，以防正在测试的配方删除所有邮件。这是一个非常有用的非投递配方示例，可以在Procmail手册页`procmailex`中找到。
- en: 'If you are fairly new to Procmail and plan to experiment a little, it often
    helps to have a safety net of some sort. Inserting the two recipes mentioned before,
    all other recipes will make sure that the last 32 arriving mail messages will
    always be preserved. In order to make this work as intended, we have to create
    a directory named `backup` in `$MAILDIR` prior to inserting these two recipes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对Procmail相当陌生，并计划进行一些实验，通常有某种安全网会有所帮助。在插入前面提到的两个配方之前，所有其他配方将确保最后到达的32封邮件始终被保留。为了使其按预期工作，我们必须在插入这两个配方之前在`$MAILDIR`中创建一个名为`backup`的目录：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The second recipe uses several features of Procmail, which we will be exploring
    in more detail in later sections of this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个配方使用了Procmail的几个特性，我们将在本章的后续部分中更详细地探讨。
- en: If we work step by step through this recipe, we will end up with a useful archive
    utility that records the last 32 mail items to be received and allows us to manually
    recover mail if we ever create a recipe that ends up destroying mail rather than
    storing it. On a busy mail server, it might be prudent to increase this number
    to keep a larger archive of messages.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按照这个配方一步一步地工作，最终会得到一个有用的存档实用程序，记录最后接收的32封邮件，并允许我们手动恢复邮件，如果我们创建了一个最终销毁邮件而不是存储它的配方。在繁忙的邮件服务器上，增加这个数字可能是明智的，以保留更大的消息存档。
- en: 'The first recipe performs a simple backup operation by delivering a copy or
    clone of the mail into the `backup` directory:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个配方通过将邮件的副本或克隆传递到`backup`目录来执行简单的备份操作：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Before adding the second recipe, create the above recipe in the `.procmailrc`
    file and send a couple of mail messages to yourself. We can see that each mail
    item is stored in the backup directory (provided it exists and has the correct
    permissions).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加第二个配方之前，在`.procmailrc`文件中创建上述配方，并给自己发送几封邮件。我们可以看到每个邮件项都存储在备份目录中（前提是它存在并具有正确的权限）。
- en: The second recipe is just as simple, but uses some more complex features of
    Linux system commands to delete all but the mail items in the `backup` directory,
    except the most recent 32 items.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个配方同样简单，但使用了Linux系统命令的一些更复杂的特性，以删除除`backup`目录中最近的32个邮件项之外的所有邮件项。
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s look at how this recipe works. Firstly, we will see the rule flags and
    their meanings:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个配方是如何工作的。首先，我们将看到规则标志及其含义：
- en: '| Flag | Meaning |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 含义 |'
- en: '| --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `i` | Ignore the return code of the subsequent pipeline command |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `i` | 忽略后续管道命令的返回代码 |'
- en: '| `c` | Clone or copy the incoming data so that the original data is not affected
    |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `c` | 克隆或复制传入数据，以便不影响原始数据 |'
- en: The `|` instructs Procmail to pass the data matched to the following pipeline
    command. Each of these commands performs a specific action.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`|`指示Procmail将匹配的数据传递给以下管道命令。每个命令执行特定的动作。'
- en: '| Command | Action |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 动作 |'
- en: '| --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `cd backup` | Moves to the `backup` directory. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `cd backup` | 进入`backup`目录。 |'
- en: '| `ls -t msg.*` | Obtains a list of files beginning with `msg` and sorts them
    in to time order. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `ls -t msg.*` | 获取以`msg`开头的文件列表，并按时间顺序排序。 |'
- en: '| `sed -e 1,32d` | Deletes all but the last 32 lines—that is, the 32 most recent
    mail items. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `sed -e 1,32d` | 删除除最后32行之外的所有内容，即最近的32封邮件。 |'
- en: '| `rm -f dummy...` | The parameter `dummy` is to stop error messages in case
    there are no files to be deleted, and then the `rm` command continues to remove
    the files listed by the `sed` filter. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `rm -f dummy...` | 参数`dummy`是为了防止出现没有要删除的文件时的错误消息，然后`rm`命令继续删除`sed`过滤器列出的文件。
    |'
- en: These two recipes are examples of unconditional recipes that are run on every
    incoming mail message. The fact that there are no conditional lines, that is,
    the lines beginning with an asterisk symbol (*), infers that the recipes are unconditional.
    As both the recipes include a `c` flag in the recipe, they are also defined as
    non-delivering recipes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个配方是无条件配方的例子，它们在每封传入的邮件消息上运行。没有条件行，即以星号（*）开头的行，这意味着这些配方是无条件的。由于这两个配方都包括配方中的`c`标志，它们也被定义为非投递配方。
- en: Once we have collected a number of Procmail recipes, we will find that the order
    in which the recipes are processed can be important. By setting the order of processing
    correctly, we can improve performance and reduce the time taken to process incoming
    mails. We can also make sure that more critical rules are applied to important
    messages before the more general rules that are intended to act on bulk messages.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们收集了一些Procmail配方，我们会发现处理配方的顺序可能很重要。通过正确设置处理顺序，我们可以提高性能，减少处理传入邮件所需的时间。我们还可以确保更重要的消息适用于重要消息，而不是适用于用于批量消息的更一般的规则。
- en: 'A typical scenario could be to apply rules in the following order:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的情景可能是按以下顺序应用规则：
- en: Process daemon or server messages first.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先处理守护程序或服务器消息。
- en: Mailing lists should be handled as early as possible, but after the server messages,
    as we want our services handled first.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 邮件列表应尽早处理，但在服务器消息之后，因为我们希望我们的服务首先得到处理。
- en: Apply `kill file` to block any known spammers.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用`kill file`来阻止任何已知的垃圾邮件发送者。
- en: Do not send vacation replies before we have handled mailing lists to prevent
    annoying vacation replies to mailing lists.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们处理邮件列表之前，请不要发送度假回复，以防止向邮件列表发送令人讨厌的度假回复。
- en: Save private messages.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存私人消息。
- en: Check for **Unsolicited Bulk E-Mail** (**UBE**)—spam. This avoids the high overhead
    of processing spam checks on known valid e-mail.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查**未经请求的大量电子邮件**（**UBE**）-垃圾邮件。这避免了在已知有效的电子邮件上处理垃圾邮件检查的高开销。
- en: Formail
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Formail
- en: '**Formail** is an external utility program (from Procmail) that is nearly always
    available on systems where Procmail is installed. Its function is to process mail
    messages and extract information from within the headers of the messages. It acts
    as a filter that can be used to force mail into a format suitable for storing
    in a Linux mail system. It can also perform a number of other useful functions
    such as ''From'' escaping, generating auto-replying headers, simple header extracting,
    or splitting up a mailbox/digest/articles file.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**Formail**是一个外部实用程序（来自Procmail），几乎总是在安装了Procmail的系统上可用。它的功能是处理邮件消息并从消息头中提取信息。它充当过滤器，可用于强制将邮件格式化为适合存储在Linux邮件系统中的格式。它还可以执行许多其他有用的功能，如''From''转义、生成自动回复头、简单的头提取或拆分邮箱/摘要/文章文件。'
- en: The input data mail/mailbox/article contents need to be provided using the standard
    input. Therefore, `formail` is ideally suited for use in pipeline command chains.
    Output data is provided on the standard output.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用标准输入提供输入数据邮件/邮箱/文章内容。因此，`formail`非常适合在管道命令链中使用。输出数据在标准输出上提供。
- en: We are not going to go into the subtleties of `formail` in this chapter, but
    as it is a useful tool, we will make reference to some of its functionality in
    some of our examples. More information can be obtained from the system manual
    pages.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不打算深入讨论`formail`的微妙之处，但由于它是一个有用的工具，我们将在一些示例中提到它的一些功能。更多信息可以从系统手册页面中获得。
- en: Advanced recipe analysis
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级配方分析
- en: Here we have a much more complicated recipe that implements a form of vacation
    service to inform senders that you are away and unable to reply to e-mails. At
    first thought this could be a simple non-delivering recipe to send a message back
    to all messages received. However, this is not ideal as some people may end up
    receiving multiple delivery confirmation messages and you may also end up sending
    messages back to system utilities that have no way of understanding your well-meant
    reply.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个更复杂的配方，实现了一种度假服务，通知发件人你不在，无法回复电子邮件。乍一看，这可能是一个简单的非投递配方，向所有收到的消息发送一条消息。然而，这并不理想，因为有些人可能最终会收到多个投递确认消息，而你也可能会向无法理解你善意回复的系统实用程序发送消息。
- en: The example is based on the "vacation example" from the Procmail `procmailex`
    manual page.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例基于Procmail `procmailex`手册页面上的“度假示例”。
- en: The `vacation.cache` file is maintained by Formail. It maintains a vacation
    database by extracting the name of the sender and inserting it in the `vacation.cache`
    file. This ensures that it always contains the most recent names. The size of
    the file is limited to a maximum of approximately 8192 bytes. If the name of the
    sender is new, an auto reply will be sent.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`vacation.cache`文件由Formail维护。它通过提取发件人的姓名并将其插入`vacation.cache`文件来维护度假数据库。这确保它始终包含最新的名称。文件的大小限制为最大约8192字节。如果发件人的姓名是新的，将发送自动回复。'
- en: 'The following recipe implements a vacation auto reply:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下配方实现了度假自动回复：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will come back to this recipe at the end of this section and work through
    creating a slightly updated version using some of the things we have learned about
    Procmail. For now, the example will help as a reference to understand some of
    the concepts we explore in the following breakdown of a general recipe structure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节末尾回到这个配方，并通过使用我们在Procmail中学到的一些东西，创建一个稍微更新的版本。目前，这个示例将作为一个参考，以便理解我们在下面对一般配方结构进行分解时探讨的一些概念。
- en: Adding comments
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加注释
- en: Documentation or adding comments to our rules and recipes is always an important
    task. All comments begin with a `#` character and continue till the end of the
    line. In most cases, it is useful to place comments at the beginning of a line
    or with one or two tabs after a single line that we wish to document.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们的规则和配方进行文档编写或添加注释始终是一项重要任务。所有注释都以`#`字符开头，并持续到行尾。在大多数情况下，将注释放在行首或在我们希望记录的单行之后的一两个制表符处是有用的。
- en: However, there is one section of the rule file where comments *must* be included
    on their own lines and that is in the *Conditions* section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个规则文件的部分，注释*必须*单独占一行，那就是*条件*部分。
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Assigning variables
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量赋值
- en: In order to keep track of settings, results from tests, default values, and
    so on, we can store this information in variables. The assignment operation is
    simple and follows the same format as other Linux scripting languages. The basic
    format is `VARIABLENAME=VALUE.`
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪设置、测试结果、默认值等信息，我们可以将这些信息存储在变量中。赋值操作很简单，遵循与其他Linux脚本语言相同的格式。基本格式是`VARIABLENAME=VALUE。`
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There must be no spaces within the variable name. If there are spaces within
    the value being assigned, the whole of the variable should be stored between double
    quotes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名称中不能有空格。如果在分配的值中有空格，则整个变量应存储在双引号之间。
- en: 'The correct way to access a variable is by enclosing the `VARIABLENAME` within
    braces `{}`, and prefixing it all with a dollar ($) sign. It is quite acceptable
    to use variables within other assignments. Some examples are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 访问变量的正确方式是将`VARIABLENAME`括在大括号`{}`中，并在所有内容前加上美元（$）符号。在其他赋值中使用变量是完全可以接受的。以下是一些示例：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice in the previous example that `${HOME}` takes the value of the shell environment
    setting as it was set when the process was started.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在前面的示例中，`${HOME}`获取了shell环境设置的值，就像在启动进程时设置的那样。
- en: Careful use of variables and their naming can make a recipe much easier to read
    and also to maintain.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎使用变量及其命名可以使配方更容易阅读和维护。
- en: Performing substitutions
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行替换
- en: Sometimes it will be necessary or useful to be able to replace a literal element
    with a variable that can be calculated or evaluated only at run time. Procmail
    allows the author to replace most literal elements with variable substitutions
    or command substitutions in most places. The simplest way to use a variable is
    to make use of the `$varname` format, which is common to a number of scripting
    languages.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将文字元素替换为仅在运行时可以计算或评估的变量将是必要或有用的。Procmail允许作者在大多数地方用变量替换或命令替换替换大多数文字元素。使用变量的最简单方式是使用`$varname`格式，这是许多脚本语言共有的。
- en: '| Variable/Command | Substitution |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 变量/命令 | 替换 |'
- en: '| --- | --- |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `$VAR` | Wherever `$VAR` occurs in the recipe, replace it with the value
    held by this variable. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `$VAR` | 在配方中，无论何时出现`$VAR`，都用该变量持有的值替换它。 |'
- en: '| `${VAR}iable *` | When we need to concatenate a variable with literal text,
    use `{}` to enforce the fact that the name is `${VAR}` and not `$VARiable`. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `${VAR}iable *` | 当我们需要将变量与文字连接在一起时，使用`{}`来强制指定名称为`${VAR}`而不是`$VARiable`。
    |'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If it is necessary to combine variables with fixed text or values, the `{}`
    elements allow absolute definition of the variable name to be established. Notice
    that this will not happen in condition lines unless we include the `$` modifier.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要将变量与固定文本或值组合，`{}`元素允许绝对定义变量名称。请注意，除非包含`$`修饰符，否则这不会发生在条件行中。
- en: Assigning variable with default values
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用默认值赋值变量
- en: Procmail borrows some standard shell syntax for variable initialization.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Procmail借用了一些标准的shell语法来初始化变量。
- en: If we wish to be able to assign a default value to a variable to be used in
    cases where the variable has not been set or could not be calculated for some
    reason, it is possible to use the or `:-` separator. If we wish to apply an alternative
    value where the variable has been set or is non null, use the `+` or `:+` separator.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望能够为变量分配默认值，以便在变量未设置或由于某种原因无法计算时使用，可以使用或`:-`分隔符。如果希望在变量已设置或非空时应用替代值，则使用`+`或`:+`分隔符。
- en: '| Separator | Action |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 分隔符 | 操作 |'
- en: '| --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `${VAR:-value}` | If `VAR` is unset or null, the expansion of `value` is
    substituted; otherwise, the value of `VAR` is substituted. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `${VAR:-value}` | 如果`VAR`未设置或为空，则替换为`value`的扩展；否则，替换为`VAR`的值。 |'
- en: '| `${VAR-value}` | If `VAR` is unset, the expansion of `value` is substituted;
    otherwise, the value of `VAR` is substituted. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `${VAR-value}` | 如果`VAR`未设置，则替换为`value`的扩展；否则，替换为`VAR`的值。 |'
- en: '| `${VAR:+value}` | If `VAR` is set or non-null, the expansion of `value` is
    substituted; otherwise, the value of `VAR` is substituted. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `${VAR:+value}` | 如果`VAR`已设置或非空，则替换为`value`的扩展；否则，替换为`VAR`的值。 |'
- en: '| `${VAR+value}` | If `VAR` is set, the expansion of `value` is substituted;
    otherwise, the value of `VAR` is substituted. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `${VAR+value}` | 如果`VAR`已设置，则替换为`value`的扩展；否则，替换为`VAR`的值。 |'
- en: 'Some examples are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Assigning command output to variables
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将命令输出赋值给变量
- en: It is possible to assign the output of a command to a variable by use of the
    (back tick) ` operator—the back tick (`) is ASCII value 96 and not a normal apostrophe
    ('), which has the ASCII value 39.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用（反引号）`操作符将命令的输出赋值给变量——反引号（`）是ASCII值96，而不是普通的撇号（'），其ASCII值为39。
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This example will assign the output from the pipeline between the two back ticks
    to the variable or inline in the code as applicable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将将两个反引号之间的管道输出分配给相应的变量或内联到代码中。
- en: Pseudo-variables
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 伪变量
- en: There are a number of special variables or pseudo-variables assigned directly
    by Procmail. Changing some of these values can actually change the way Procmail
    operates.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多特殊变量或伪变量直接由Procmail分配。更改其中一些值实际上可以改变Procmail的操作方式。
- en: Mailbox variables
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 邮箱变量
- en: The following variables are used by Procmail to determine where it will store
    any delivered mail.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下变量由Procmail用于确定它将存储任何已交付邮件的位置。
- en: '| Name | Action |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 操作 |'
- en: '| --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `MAILDIR` | The default value for `MAILDIR` is taken from the value of the
    `$HOME` environment variable. It is also the value used for the current working
    directory for Procmail during execution. Unless the output file names include
    a path component, they will be created in this default directory. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `MAILDIR` | `MAILDIR`的默认值取自`$HOME`环境变量的值。它也是Procmail在执行期间的当前工作目录的值。除非输出文件名包括路径组件，否则它们将被创建在这个默认目录中。
    |'
- en: '| `MSGPREFIX` | This option is used when we want files to be written sequentially
    to a directory. The `MSGPREFIX` is prefixed to the name of the file created using
    this option. The default prefix is `msg.`, so the file will be named `msg.xyz`.
    The option is not used when delivering to a `maildir` or an `MH` directory. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `MSGPREFIX` | 当我们希望将文件按顺序写入目录时使用此选项。`MSGPREFIX`将作为前缀添加到使用此选项创建的文件的名称中。默认前缀是`msg.`，因此文件将被命名为`msg.xyz`。将文件传递到`maildir`或`MH`目录时不使用此选项。
    |'
- en: '| `DEFAULT` | This is the location of the default mail storage area on our
    system. Normally we would not modify this variable. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `DEFAULT` | 这是系统上默认邮件存储区的位置。通常情况下，我们不会修改这个变量。 |'
- en: '| `ORGMAIL` | This is used as a disaster recovery location for cases where
    `DEFAULT` is unavailable for any reason. This should definitely not be modified.
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `ORGMAIL` | 这用作`DEFAULT`无法使用的情况下的灾难恢复位置。这绝对不应该被修改。 |'
- en: Program variables
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 程序变量
- en: Procmail has reasonable defaults written in at the compile time. Mostly these
    do not need to be changed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Procmail在编译时有合理的默认值。大多数情况下，这些值不需要更改。
- en: '| Name | Action |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 操作 |'
- en: '| --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SHELL` | This is a standard environment variable that specifies the shell
    environment within which Procmail needs to invoke sub-processes. The value assigned
    to it should be Bourne shell-compatible such as `/bin/sh`. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `SHELL` | 这是一个标准的环境变量，指定了Procmail需要调用子进程的shell环境。分配给它的值应该是与Bourne shell兼容的，例如`/bin/sh`。
    |'
- en: '| `SHELLFLAGS` | This specifies any optional flags that should be passed to
    the `SHELL` when starting it. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `SHELLFLAGS` | 这指定了在启动`SHELL`时应传递的任何可选标志。 |'
- en: '| `SENDMAIL` | This instructs Procmail where to find the `sendmail` program
    used for sending mail on to other users. (Usually not to be fiddled with). |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `SENDMAIL` | 这指示Procmail在哪里找到用于将邮件发送给其他用户的`sendmail`程序。（通常不应该被玩弄）。 |'
- en: '| `SENDMAILFLAGS` | Like `SHELLFLAGS`, this specifies any flags or command-line
    arguments that should be passed to the `SENDMAIL` program when it is executed.
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `SENDMAILFLAGS` | 与`SHELLFLAGS`一样，指定在执行`SENDMAIL`程序时应传递的任何标志或命令行参数。 |'
- en: System interaction variables
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 系统交互变量
- en: During the execution of recipes, Procmail may need to run external commands,
    handle errors, or create files. These variables control how Procmail interacts
    with the shell.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行食谱期间，Procmail可能需要运行外部命令，处理错误或创建文件。这些变量控制了Procmail与shell的交互方式。
- en: '| Name | Action |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 操作 |'
- en: '| --- | --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `UMASK` | This gives the file permissions mode used when creating any files.
    See `man umask` for details. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `UMASK` | 创建任何文件时使用的文件权限模式。有关详细信息，请参阅`man umask`。 |'
- en: '| `SHELLMETAS` | The shell pipeline is compared with the contents of `SHELLMETAS`
    before execution. If any characters from `SHELLMETAS` are found in the pipeline
    command, the command is considered too complicated for Procmail to manage itself
    and a sub-shell process is spawned. If we know that a particular pipeline will
    always be simple enough for Procmail to manage itself but contains characters
    held in `SHELLMETAS`, we can temporarily assign an empty string to `SHELLMETAS`
    while processing the pipeline and then restore `SHELLMETAS`. This will avoid the
    overhead of spawning a sub‑shell. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `SHELLMETAS` | 在执行之前，shell管道将与`SHELLMETAS`的内容进行比较。如果在管道命令中找到了来自`SHELLMETAS`的任何字符，则认为该命令对于Procmail来说太复杂，无法自行管理，并且会生成一个子shell进程。如果我们知道特定的管道始终对Procmail来说足够简单，但包含在`SHELLMETAS`中的字符，我们可以在处理管道时临时将空字符串分配给`SHELLMETAS`，然后恢复`SHELLMETAS`。这将避免生成子shell的开销。
    |'
- en: '| `TRAP` | Here we can assign a code segment to be executed at the end of execution
    of Procmail. A use of it, for example, could be to delete temporary files created
    during execution of the recipes.`TEMPORARY=$HOME/tmp/pmail.$$``TRAP="/bin/rm -f
    $TEMPORARY"` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `TRAP` | 在Procmail执行结束时，我们可以分配一个代码段来执行。例如，可以用它来删除在执行食谱期间创建的临时文件。`TEMPORARY=$HOME/tmp/pmail.$$``TRAP="/bin/rm
    -f $TEMPORARY"` |'
- en: '| `EXITCODE` | This value is given back to the process that started Procmail,
    when Procmail exits. Typically the value of `0` is returned for success and non-zero
    values indicate some form of failure. By modifying the `EXITCODE` value, we can
    return specific information about the processing performed.The exit code of a
    program started by Procmail is stored in the variable `$?` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `EXITCODE` | 当Procmail退出时，此值将返回给启动Procmail的进程。通常，成功返回值为`0`，非零值表示某种形式的失败。通过修改`EXITCODE`值，我们可以返回有关执行的特定信息。由Procmail启动的程序的退出代码存储在变量`$?`中。
    |'
- en: Logging variables
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 日志变量
- en: 'The verbosity and location of any log output required during recipe execution
    is controlled by the following variables:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在食谱执行期间，任何日志输出的冗长和位置由以下变量控制：
- en: '| Name | Action |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 操作 |'
- en: '| --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `LOGFILE` | This specifies the location to which Procmail should write all
    its logging and debugging information. If this value is empty, output is sent
    to the **standard error output**, which means it will be lost unless the program
    is running interactively or `stderr` is redirected somewhere. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `LOGFILE` | 这指定了Procmail应将其所有日志和调试信息写入的位置。如果此值为空，则输出将发送到**标准错误输出**，这意味着除非程序以交互方式运行或`stderr`被重定向到其他位置，否则它将丢失。
    |'
- en: '| `LOG` | If we wish to write something directly to the log file ourselves,
    we can assign a value to the `LOG` variable, and it will be appended to `LOGFILE`.
    If we want to format the output and include a blank line after our log message,
    we must remember to include a blank line in the message that is output.`LOG="Procmail
    is great"` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `LOG` | 如果我们希望直接写入日志文件，我们可以为`LOG`变量分配一个值，并且它将附加到`LOGFILE`。如果我们想要格式化输出并在我们的日志消息之后包括一个空行，我们必须记得在输出的消息中包含一个空行。`LOG="Procmail
    is great"` |'
- en: '| `VERBOSE` | This allows the output to be the basic default or provide detailed
    information. Setting `VERBOSE=1` will include detailed logging information that
    will aid in debugging our recipes. To reduce the amount of output information,
    remember to set `VERBOSE=0` after the recipe has been run. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `VERBOSE` | 这允许输出为基本默认或提供详细信息。设置`VERBOSE=1`将包括详细的日志信息，有助于调试我们的配方。为了减少输出信息的数量，请记得在配方运行后设置`VERBOSE=0`。
    |'
- en: '| `LOGABSTRACT` | If `LOGABSTRACT` is set to `all`, all the deliveries will
    have information regarding the sender, subject, and size of the mail delivered.
    If you wish to stop this logging, set `LOGABSTRACT=no`. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `LOGABSTRACT` | 如果`LOGABSTRACT`设置为`all`，所有投递将包含有关发送者、主题和投递邮件大小的信息。如果您希望停止此日志记录，请将`LOGABSTRACT=no`。
    |'
- en: '| `COMSAT` | If set to `yes`, Procmail will generate comsat/biff notifications.
    For more information, see the `comsat` and `biff` manual pages. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `COMSAT` | 如果设置为`yes`，Procmail将生成comsat/biff通知。有关更多信息，请参阅`comsat`和`biff`手册页。
    |'
- en: Procmail's state variables
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Procmail的状态变量
- en: 'During the processing of a recipe, Procmail updates the following variables
    with the current state of the recipe:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理配方时，Procmail使用当前配方的当前状态更新以下变量：
- en: '| Name | Action |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 操作 |'
- en: '| --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `PROCMAIL_OVERFLOW` | If Procmail finds any lines in the Procmail recipe
    file that are longer than the buffer size while reading the file at startup, it
    will set the value of `PROCMAIL_OVERFLOW` as `yes`. If the line being read is
    a condition or action line, the action will be considered to have failed. However,
    if it is a variable assignment or recipe start, Procmail will stop reading the
    file and exit with an abnormal termination. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `PROCMAIL_OVERFLOW` | 如果Procmail在启动时在Procmail配方文件中发现任何行长于缓冲区大小，它将将`PROCMAIL_OVERFLOW`的值设置为`yes`。如果正在读取的行是条件或操作行，则操作将被视为失败。但是，如果它是变量赋值或配方开始，Procmail将停止读取文件并以异常终止退出。
    |'
- en: '| `HOST` | This holds the name of the host on which the process is running.
    |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `HOST` | 这保存了进程正在运行的主机的名称。 |'
- en: '| `DELIVERED` | If the mail message was delivered successfully, this is set
    to `yes` and the calling process will be informed by Procmail. If we manually
    set this to `yes` *and* the message is not delivered, it will be lost without
    trace but the calling process will still believe that it was successfully delivered.
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `DELIVERED` | 如果邮件成功投递，这将设置为`yes`，并且Procmail将通知调用进程。如果我们手动将其设置为`yes` *并且*消息未被投递，它将无迹可寻地丢失，但调用进程仍将认为它已成功投递。
    |'
- en: '| `LASTFOLDER` | This gives the name of the last file or directory to which
    a message was written. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `LASTFOLDER` | 这给出了最后一个写入消息的文件或目录的名称。 |'
- en: '| `MATCH` | This holds the information extracted by the last regular expression
    operation. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `MATCH` | 这保存了上一个正则表达式操作提取的信息。 |'
- en: '| `$=` | This holds the result of the latest scoring recipe. See the*procmailsc*
    manual page for more information. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `$=` | 这保存了最新评分配方的结果。有关更多信息，请参阅*procmailsc*手册页。 |'
- en: '| `$1, $2, ...; $@; $#` | Just like the standard shell, this specifies the
    command-line arguments that Procmail was started with.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '| `$1，$2，...; $@; $#` | 就像标准shell一样，这指定了Procmail启动时使用的命令行参数。'
- en: '`$1` is the first command-line argument, and so on.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$1`是第一个命令行参数，依此类推。'
- en: '`$@` contains all arguments.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$@`包含所有参数。'
- en: '`$#` contains the number of arguments.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$#`包含参数的数量。'
- en: Also see the `SHIFT` pseudo-variable. |
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅`SHIFT`伪变量。 |
- en: '| `$$` | This holds the current process ID. This can be useful for creating
    temporary files unique to the process. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `$$` | 这保存了当前进程ID。这对于创建与进程唯一相关的临时文件非常有用。 |'
- en: '| `$?` | This holds the exit code of the previous shell command. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `$?` | 这保存了上一个shell命令的退出代码。 |'
- en: '| `$_` | This holds the name of the current Procmail file that is being processed.
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `$_` | 这保存了当前正在处理的Procmail文件的名称。 |'
- en: '| `$-` | This is an alias for `LASTFOLDER`.`$=` and `$@` can''t be used directly;
    we have to assign the value to another variable before it can be used for anything
    useful. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `$-` | 这是`LASTFOLDER`的别名。`$=`和`$@`不能直接使用；在可以用于任何有用的东西之前，我们必须将值分配给另一个变量。 |'
- en: Message content variables
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 消息内容变量
- en: The main use for these variables is to access data held in the appropriate section
    but where the recipe has a flag that restricts the processing to the other part
    of the message. By using `HB`, we can access information across the whole of the
    message.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量的主要用途是访问保存在适当部分中的数据，但是当配方具有限制处理到消息的另一部分的标志时。通过使用`HB`，我们可以访问整个消息的信息。
- en: '| Name | Action |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 操作 |'
- en: '| --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `H` | This holds the header information for the message being currently processed.
    |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `H` | 这保存了当前正在处理的消息的头信息。 |'
- en: '| `B` | This holds the body of the message being currently processed. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `B` | 这保存当前正在处理的消息的正文。 |'
- en: Locking variables
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 锁定变量
- en: Each of the variables in the following table control the names of any lock files
    and how long the recipe should wait for a lock to become free.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表中的每个变量控制任何锁定文件的名称以及配方应等待锁定变为自由的时间。
- en: '| Name | Action |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 行动 |'
- en: '| --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `LOCKFILE` | Assigning a value to this variable creates a global lock file
    that remains until `LOCKFILE` is assigned another value. This value may be either
    the name of another lock file to create or a null value to remove any lock. |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `LOCKFILE` | 为此变量分配一个值会创建一个全局锁定文件，直到为`LOCKFILE`分配另一个值为止。此值可以是要创建的另一个锁定文件的名称，也可以是一个空值，以删除任何锁定。
    |'
- en: '| `LOCKEXT` | Assigning a value to this allows us to override the extension
    used as part of the lock filename. This can be useful in identifying the process
    that has created the lock file. |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `LOCKEXT` | 为此分配一个值允许我们覆盖作为锁定文件名一部分使用的扩展名。这在识别创建锁定文件的进程方面可能很有用。 |'
- en: '| `LOCKSLEEP` | If Procmail wants to create a lock on a file that is already
    locked by another process, it will go into a `retry` loop. The `LOCKSLEEP` variable
    specifies the number of seconds to sleep and wait before retrying to obtain the
    lock. |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `LOCKSLEEP` | 如果Procmail想要在另一个进程已经锁定的文件上创建一个锁定，它将进入`retry`循环。`LOCKSLEEP`变量指定在重试获取锁之前睡眠和等待的秒数。
    |'
- en: '| `LOCKTIMEOUT` | This specifies an age in seconds that the lock file must
    be of before it will be assumed that the lock file is invalid and will be overridden.
    If the value is `0` then the lock file will never be overridden. The default value
    is `1024` seconds. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `LOCKTIMEOUT` | 这指定了锁定文件必须达到的秒龄，然后假定锁定文件无效并将被覆盖。如果值为`0`，则永远不会覆盖锁定文件。默认值为`1024`秒。
    |'
- en: Error-handling variables
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 错误处理变量
- en: In the event of an error in our recipe, we can decide what action to take by
    using any of these variables.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的配方中出现错误时，我们可以使用这些变量中的任何一个来决定采取什么行动。
- en: '| Name | Action |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 行动 |'
- en: '| --- | --- |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `TIMEOUT` | This specifies how long to wait for a child before telling the
    child process to terminate. The default is `960` seconds. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `TIMEOUT` | 这指定了在告知子进程终止之前等待子进程的时间。默认值为`960`秒。 |'
- en: '| `SUSPEND` | This specifies how long to wait between `NORESRETRY` retries.
    Default is `16` seconds. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `SUSPEND` | 这指定了在`NORESRETRY`重试之间等待的时间。默认值为`16`秒。 |'
- en: '| `NORESRETRY` | The number of times Procmail will retry before giving up when
    a serious system resource shortage occurs, such as out of disk space or the system
    has reached the maximum number of processes. The default value is `4` and, if
    the number is negative, Procmail will retry forever. If the resources do not become
    available during the retry period, the message will be discarded and classified
    as undeliverable. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `NORESRETRY` | 当发生严重的系统资源短缺时（例如磁盘空间不足或系统已达到最大进程数），Procmail将重试的次数。默认值为`4`，如果数字为负数，Procmail将永远重试。如果在重试期间资源仍然不可用，消息将被丢弃并被分类为不可投递。
    |'
- en: Miscellaneous variables
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 杂项变量
- en: 'The following table contains information about various Procmail variables that
    may be of use within our recipes:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格包含有关可能在我们的配方中有用的各种Procmail变量的信息：
- en: '| Name | Action |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 行动 |'
- en: '| --- | --- |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `LINEBUF` | This sets a limit for the length of recipe lines that Procmail
    is ready to cope with. If we need to process very large regular expressions or
    store lots of data into `MATCH`, increase this value. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `LINEBUF` | 这为Procmail准备处理的配方行的长度设置了一个限制。如果我们需要处理非常大的正则表达式或将大量数据存储到`MATCH`中，增加此值。
    |'
- en: '| `SHIFT` | This is similar to the `shift` feature in normal shell processing.
    Assigning a positive number to this variable moves down Procmail''s command-line
    arguments. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `SHIFT` | 这类似于正常shell处理中的`shift`功能。将正数分配给此变量会使Procmail的命令行参数下移。 |'
- en: '| `INCLUDERC` | This instructs Procmail to load another file containing Procmail
    recipes. This new file is loaded and processed before Procmail continues processing
    the current file. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `INCLUDERC` | 这指示Procmail加载另一个包含Procmail配方的文件。在Procmail继续处理当前文件之前，将加载和处理这个新文件。
    |'
- en: '| `DROPPRIVS` | This ensures that no root privileges are available when Procmail
    is executing as `setuid` or `setgid`. Setting this value to `yes` will make Procmail
    drop all its special privileges. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `DROPPRIVS` | 这确保了在Procmail以`setuid`或`setgid`执行时不会有根特权可用。将此值设置为`yes`将使Procmail放弃所有特权。|'
- en: Printing Procmail variables
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 打印Procmail变量
- en: The following example will print most of the environment settings in response
    and will provide some information that could be helpful while trying to debug
    problems with Procmail. It is not expected that this is included in any production
    files, otherwise our log file could grow to be extremely large very quickly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将打印大部分环境设置的响应，并提供一些在尝试调试Procmail问题时可能有用的信息。不希望将其包含在任何生产文件中，否则我们的日志文件可能会迅速变得非常庞大。
- en: 'Create a file called `rc.dump` in the same directory as the other Procmail
    recipe files and place the following lines in the file:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在与其他Procmail配方文件相同的目录中创建一个名为`rc.dump`的文件，并将以下行放入文件中：
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that the quotes (") that appear at the start and end of the next
    example are required to ensure that the recipe operates correctly.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，下一个示例开头和结尾的引号（"）是必需的，以确保配方正常运行。
- en: '[PRE8]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE9]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will create the following output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建以下输出：
- en: '[PRE10]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Recipes
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配方
- en: Procmail recipes follow a simple format. However, there are a number of ways
    that Procmail can be instructed to interpret or implement the instructions in
    the rules based on a number of flags and the way that the rules and recipes are
    written.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Procmail配方遵循简单的格式。但是，有许多方法可以指示Procmail根据许多标志以及规则和配方的编写方式来解释或实施规则中的指令。
- en: Colon line
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 冒号行
- en: As we have already discovered, all rules so far have started with a `:0` followed
    by one or more flags and instructions. Historically a number followed the colon
    (`:`) to specify the number of conditions that were present in the rule. Current
    versions of Procmail determine the number of conditions automatically, and hence
    the value `0` is always used.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经发现的，到目前为止，所有规则都以`:0`开头，后面跟着一个或多个标志和指令。历史上，冒号（`:`）后面跟着一个数字，用来指定规则中存在的条件数量。当前版本的Procmail会自动确定条件的数量，因此始终使用值`0`。
- en: Locking
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 锁定
- en: We have already discussed that we need to use a locking mechanism in order to
    stop more than one process trying to write to the same file at the same time.
    Of course this requirement varies with the type of process that the filter is
    attempting to invoke. For example, a filter that merely changes or assigns a value
    has no affect on any physical file and so no locking is required. Similarly, a
    filter that merely forwards the data on to another process or another recipient
    inherently does not need a lock to be applied. In most cases, automatic locking
    will be applied when Procmail realizes that it is writing to a file and will provide
    locking of the file itself. In some cases, it may be necessary to explicitly lock
    a resource.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过，为了阻止多个进程同时尝试写入同一文件，我们需要使用锁定机制。当然，这个要求随着过滤器试图调用的进程类型而变化。例如，仅仅更改或分配值的过滤器对任何物理文件都没有影响，因此不需要锁定。同样，仅仅将数据转发到另一个进程或另一个接收者的过滤器本质上不需要应用锁定。在大多数情况下，当Procmail意识到它正在写入文件并提供文件本身的锁定时，将自动应用锁定。在某些情况下，可能需要显式锁定资源。
- en: To give some insight into when locking is applied automatically, not required
    at all, or requires manual locking to be enforced, here are some examples.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例，以便了解何时自动应用锁定，根本不需要，或需要强制手动锁定。
- en: Automatic locking
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 自动锁定
- en: Any rule that begins with `:0:` will apply automatic file locking. In this case,
    Procmail will automatically determine the name of the file that the mail is being
    delivered to and create a lock file. If the lock file already exists, it will
    wait for a period of time and retry to create the lock. When it finally creates
    the lock file, it will continue with processing. If it is unable to create the
    lock file, it will report an error and continue with the next rule.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 任何以`:0:`开头的规则都将应用自动文件锁定。在这种情况下，Procmail将自动确定邮件被传递到的文件的名称，并创建一个锁定文件。如果锁定文件已经存在，它将等待一段时间并重试创建锁定。当它最终创建了锁定文件，它将继续处理。如果无法创建锁定文件，它将报告错误并继续下一个规则。
- en: 'The following rule uses automatic locking:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下规则使用自动锁定：
- en: '[PRE11]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Enforced locking
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 强制锁定
- en: 'There may be a time, especially when processing mail by an external script,
    where enforced locking is required. In most cases, Procmail will determine the
    name of the file that the ultimate data is being written to by examining the process
    command line and looking where output is directed to. However, if the script takes
    care of choosing the output location itself, or if it relies on a file that may
    be altered by another Procmail process, a lock file must be specifically requested
    as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有一段时间，特别是在通过外部脚本处理邮件时，需要强制锁定。在大多数情况下，Procmail将通过检查进程命令行并查看输出的位置来确定最终数据被写入的文件的名称。然而，如果脚本负责选择输出位置本身，或者依赖于可能被另一个Procmail进程更改的文件，必须明确请求锁定文件如下：
- en: '[PRE12]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You are unlikely to need to enforce locking in most of the scripts you write.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您不太可能需要在编写的大多数脚本中强制锁定。
- en: No locking
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 无锁定
- en: 'When forwarding to a pipeline that performs its own file or record-locking
    processes, such as storing a problem report in a database, no record locking is
    required. Similarly if the message is being forwarded to another user, the final
    delivery will take care of the record locking. The simple rule definition is:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当转发到执行自己的文件或记录锁定过程的管道时，例如将问题报告存储在数据库中，不需要记录锁定。同样，如果消息被转发给另一个用户，最终交付将处理记录锁定。简单的规则定义是：
- en: '[PRE13]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Flags
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 标志
- en: In the examples we have looked at so far, we have allowed the default settings
    of Procmail to take effect. However, there are a number of flags that may be set
    to control how Procmail works.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止看过的例子中，我们已经允许Procmail的默认设置生效。然而，有许多标志可以设置以控制Procmail的工作方式。
- en: '![Flags](img/8648_07_01.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![标志](img/8648_07_01.jpg)'
- en: Default flags
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 默认标志
- en: If no flags are stated on the colon line of the recipe, Procmail will assume
    that the following flags (`H, hb`) have been used as default values.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在食谱的冒号行上没有声明标志，Procmail将假定以下标志（`H，hb`）已被用作默认值。
- en: '| Flag | Action |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 动作 |'
- en: '| --- | --- |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `H` | Only mail headers are scanned. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `H` | 仅扫描邮件标题。 |'
- en: '| `hb` | Action line is passed both, headers and body of the mail data. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `hb` | 动作行同时传递邮件数据的标题和正文。 |'
- en: 'Scope of matching: HB'
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 匹配范围：HB
- en: Normally, matching will take place across the whole of the mail package including
    both, the headers and the body of the mail. If the mail body could potentially
    be large and we know that we require the matches to be made against just the headers,
    it would be sensible to use the `H` flag to restrict the scope of the matching
    action to be across the headers only.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，匹配将在整个邮件包括标题和邮件正文之间进行。如果邮件正文可能很大，并且我们知道我们需要对标题进行匹配，那么使用`H`标志限制匹配范围仅限于标题是明智的。
- en: Conversely, it may sometimes be that we are looking for items of information,
    perhaps a repeated footer or signature that appears only in the body of the document,
    in which case we can use the `B` flag to restrict matching to the body only.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，有时我们可能正在寻找信息项，例如文档正文中仅出现的重复页脚或签名，这种情况下我们可以使用`B`标志将匹配限制为仅限于正文。
- en: '| Flag | Action |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 动作 |'
- en: '| --- | --- |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `H` | Performs matching only across the mail headers. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `H` | 仅在邮件标题中进行匹配。 |'
- en: '| `B` | Performs matching only across the mail body. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `B` | 仅在邮件正文中进行匹配。 |'
- en: '| `HB` | Performs matching across the whole of the mail item including headers
    and body. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `HB` | 在整个邮件项目中包括标题和正文进行匹配。 |'
- en: 'Scope of action: hb'
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 操作范围：hb
- en: By default, the action line processes the whole e-mail item including the headers
    and body. If it is required to process only one part of the mail data, it is possible
    to specify which part is passed to the action line.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，操作行处理整个电子邮件项目，包括标题和正文。如果需要仅处理邮件数据的一部分，则可以指定将哪一部分传递给操作行。
- en: '| Flag | Action |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 旗帜 | 行动 |'
- en: '| --- | --- |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `h` | Pass only the headers to the action line for processing. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `h` | 仅将标题传递给操作行进行处理。 |'
- en: '| `b` | Pass only the body of the message to the action line for processing.
    |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `b` | 仅将消息正文传递给操作行进行处理。 |'
- en: '| `hb` | Pass both, the headers and the message body, for processing. This
    is the default scope. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `hb` | 仅将标题和消息正文传递给操作行进行处理。这是默认范围。 |'
- en: Note
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to notice the difference between "scope of matching" and "scope
    of action". The value of the flag in the first case determines which part of the
    mail—header, body, or the entire mail—has to be scanned for matching. The value
    of the flag in the second case determines which part of the mail needs to be processed.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在“匹配范围”和“操作范围”之间的区别很重要。在第一种情况下，标志的值确定必须扫描邮件的哪一部分（标题、正文或整个邮件）以进行匹配。在第二种情况下，标志的值确定必须处理邮件的哪一部分。
- en: 'Flow control: aAeEc'
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 流程控制：aAeEc
- en: 'This is probably the most complex set of flags to understand of all the Procmail
    flags. Examples later in the chapter will explain various ways of using these
    flags. Briefly the following may be assumed about each of the flags:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是所有Procmail标志中最复杂的一组标志。本章后面的示例将解释使用这些标志的各种方式。简而言之，可以假定每个标志的以下内容：
- en: '| Flag | Action |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 旗帜 | 行动 |'
- en: '| --- | --- |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `A` | The recipe will be processed only if the conditions of the previous
    recipe were met. |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| `A` | 只有前一个配方的条件得到满足时，才会处理该配方。 |'
- en: '| `a` | The recipe will be processed if the previous recipe''s conditions were
    met and the operation was completed without error. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| `a` | 如果前一个配方的条件得到满足，并且操作已经完成而没有错误，则将处理该配方。 |'
- en: '| `E` | This is the opposite of `A`. The recipe will be processed if the previous
    recipe conditions were not met. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| `E` | 这是`A`的相反。如果前一个配方的条件未满足，则将处理该配方。 |'
- en: '| `e` | The recipe will be processed if the previous recipe conditions were
    met but the processing did not complete successfully. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `e` | 如果前一个配方的条件得到满足，但处理未能成功完成，将处理该配方。 |'
- en: '| `c` | This instructs the recipe to create a copy or clone of the original
    message and process this copy with any actions in a subprocess. The parent process
    continues processing the original copy of the message. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `c` | 这指示配方创建原始消息的副本或克隆，并使用任何操作在子进程中处理此副本。父进程继续处理消息的原始副本。 |'
- en: The `c` flag should be read as `Clone` or `Copy`. It is a common misconception
    that this flag should be interpreted as `Continue`. The `Clone` or `Copy` operation
    creates a separate copy of the data and a separate flow of execution is created
    to process that data, sometimes as a totally separate child process. When this
    clone recipe is complete, the parent continues execution with the original data
    intact.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`c`标志应该被理解为`克隆`或`复制`。普遍的误解是该标志应该被解释为`继续`。`克隆`或`复制`操作创建数据的单独副本，并创建一个单独的执行流程来处理该数据，有时作为完全独立的子进程。当此克隆配方完成时，父进程将继续执行，并保持原始数据不变。'
- en: 'Case sensitivity: D'
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 区分大小写：D
- en: Diehard Linux users are very much aware of case sensitivity and always view
    `Capitals` as being entirely different to `capitals`. However, the default operation
    of Procmail is to be case insensitive when matching strings. This means, for Procmail
    `Capitals` and `capitals` are identical, unless it is told that case sensitivity
    should be applied by means of the `D` flag.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 顽固的Linux用户非常了解区分大小写，并始终将`大写`视为与`小写`完全不同。然而，Procmail的默认操作是在匹配字符串时不区分大小写。这意味着对于Procmail来说，`大写`和`小写`是相同的，除非告知应用`D`标志应用区分大小写。
- en: 'Execution mode: fwWir'
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行模式：fwWir
- en: We can instruct Procmail how to process or execute the recipe and what actions
    to take if errors are encountered during the processing. Errors might not occur
    for smaller mail messages when the processing takes place only on the first few
    lines of data. However, for larger messages, the Linux shell may believe there
    is an error when the pipeline has read only a part of the available data.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指示Procmail如何处理或执行配方，以及在处理过程中遇到错误时要采取的操作。当处理仅在数据的前几行上进行时，较小的邮件消息可能不会出现错误。然而，对于较大的消息，当管道仅读取可用数据的一部分时，Linux
    shell可能会认为存在错误。
- en: 'The **Filtering Mode** of execution is important to understand. This terminology
    could be confusing as all that Procmail is designed to do is to filter mail. Think
    of the execution mode "filter" in the following way: The mail message we are processing
    would be piped through whatever is on the action line before it is actually piped
    on to Procmail (or at least the rest of our recipe). Another way of viewing the
    filter mode is as a conversion mode where the data is modified in some way and
    returned back to the controlling Procmail recipe for further execution.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 执行模式的**过滤模式**很重要。这个术语可能会让人困惑，因为Procmail的设计目的只是过滤邮件。以以下方式考虑执行模式“过滤”：我们正在处理的邮件消息将在实际传递到Procmail（或至少我们配方的其余部分）之前通过操作行上的任何内容进行管道传输。查看过滤模式的另一种方式是将其视为一种转换模式，在这种模式下，数据以某种方式进行修改，然后返回到控制Procmail配方以进行进一步执行。
- en: '| Flag | Action |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 旗帜 | 行动 |'
- en: '| --- | --- |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `f` | Pass the message contents through the recipe to an external pipeline
    process for processing and then take the output of the process line ready to replace
    the original message contents. |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `f` | 将消息内容通过配方传递给外部管道进程进行处理，然后获取处理过程的输出行，准备替换原始消息内容。 |'
- en: '| `i` | If a Linux pipeline process reads only part of its input and then terminates,
    the shell will send a `SIGPIPE` error signal to the Procmail program—the `i` flag
    instructs Procmail to ignore this signal. This should be used where it is expected
    that the pipeline process will return after processing only a part of the message.
    |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `i` | 如果Linux管道进程只读取其输入的一部分，然后终止，shell将向Procmail程序发送`SIGPIPE`错误信号——`i`标志指示Procmail忽略此信号。这应该在预期管道进程只处理部分消息后返回时使用。'
- en: '| `r` | The data passed to the pipeline process should be passed just as it
    is without any modifications. |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `r` | 传递给管道进程的数据应该原样传递，不做任何修改。 |'
- en: '| `w` | By default, the Procmail process will spawn off a subprocess and continue
    its own processing. The `w` flag instructs Procmail to wait for the subprocess
    pipeline to complete before continuing with its own processing. |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `w` | 默认情况下，Procmail进程将生成一个子进程并继续自己的处理。`w`标志指示Procmail等待子进程管道完成后再继续自己的处理。'
- en: '| `W` | This works the same as `w`, but also hides any error or other output
    messages from the pipeline process. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `W` | 这与`w`的工作方式相同，但也隐藏了管道进程的任何错误或其他输出消息。 |'
- en: Conditions
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件
- en: There are a number of condition types that could be applied to decide if a given
    recipe applies to a particular mail item. The idea of applying conditions correctly
    is to reduce the amount of unnecessary processing that is performed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多条件类型可以应用于决定给定配方是否适用于特定的邮件项。正确应用条件的想法是减少执行的不必要处理量。
- en: Condition lines always begin with an asterisk (*) character followed by one
    or more spaces. It is possible to apply multiple condition lines within a recipe,
    but they must all be grouped together on consecutive lines. The logical operation
    of the grouping is to perform an `AND` operation such that all the conditions
    must be applied before the action is executed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 条件行始终以星号（*）字符开头，后面跟着一个或多个空格。可以在一个配方内应用多个条件行，但它们必须全部分组在连续的行上。分组的逻辑操作是执行`AND`操作，以便在执行动作之前必须应用所有条件。
- en: '[PRE14]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Applying a rule unconditionally
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无条件应用规则
- en: It may be required that a rule has to be applied to all messages regardless
    of any conditions. Such a rule could, for example, make a backup copy of the mail
    message to a mail folder or archive all mail for legal or corporate policy reasons.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要应用规则到所有消息，而不考虑任何条件。例如，这样的规则可以备份邮件消息到邮件文件夹，或者出于法律或公司政策原因归档所有邮件。
- en: The unconditional rule is implied by the lack of a conditional line. That is,
    the rule will always match.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 无条件规则是由缺少条件行而暗示的。也就是说，规则总是匹配的。
- en: '[PRE15]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The unconditional rule is often used at the end of a nested chain of recipes
    to perform a final default action if the recipe has not delivered the mail. Remember
    that processing stops once a message has been delivered.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 无条件规则经常用于嵌套配方链的末尾，以执行最终的默认操作，如果配方未传递邮件。请记住，一旦邮件被传递，处理就会停止。
- en: Tests with regular expressions
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用正则表达式进行测试
- en: Those of us that are familiar with simple pattern-matching operations such as
    `?` or `*` used commonly in matching of files in a file listing operation, may
    wonder if it is possible to create similar tests to match parts of a mail header
    or body. The good news is that there is an excellent feature known as **regular
    expressions** or **regex** for short. These provide a mechanism for very complex
    pattern-matching operations to be performed. In general, this feature matches
    very closely with the `egrep` command-line regular expressions. However, there
    are some important differences that experienced `regex` users should definitely
    be aware of, in order to understand how to write expressions tailored for Procmail
    operation. There is a complete section on writing `regex` later in this chapter.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的一些人熟悉简单的模式匹配操作，比如在文件列表操作中常用的`?`或`*`，可能会想知道是否可以创建类似的测试来匹配邮件头部或正文的部分。好消息是，有一个称为**正则表达式**或**regex**的优秀功能。这些提供了一个执行非常复杂的模式匹配操作的机制。总的来说，这个功能与`egrep`命令行正则表达式非常相似。然而，有一些重要的区别，有经验的`regex`用户一定要了解，以便了解如何编写适用于Procmail操作的表达式。本章后面有一个完整的关于编写`regex`的部分。
- en: Regular expressions may be run against the data portion of the mail message
    (header, body, or both) as defined by the flags or may be used to test a previously
    assigned variable.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式可以针对邮件消息的数据部分（标题、正文或两者）运行，如标志所定义，也可以用于测试先前分配的变量。
- en: '| Condition | Action |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 条件 | 动作 |'
- en: '| --- | --- |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `* regex` | Tests the part of the message passed according to the flags against
    the regular expression. Normally this will process just the headers unless a `B`
    flag is given to indicate that the scope of matching was to process the body of
    the message. |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `* 正则表达式` | 根据标志测试消息的部分与正则表达式。通常这只会处理标题，除非给出`B`标志以指示匹配范围是处理消息的正文。|'
- en: '| `* variable ?? regex` | This is to compare the assigned variable against
    the `regex` for comparison. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `* 变量 ?? 正则表达式` | 这是为了将分配的变量与`正则表达式`进行比较。 |'
- en: Various pseudo-variables were listed earlier in the chapter and represent ways
    to access information that is contained within the Procmail application. These
    pseudo-variables can be compared in the same way as normal variables.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前面列出了各种伪变量，代表了访问Procmail应用程序中包含的信息的方式。这些伪变量可以与普通变量相同方式进行比较。
- en: The following example will make a copy of all the mail items that contain a
    key phrase in the message body.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将复制所有包含关键短语的邮件项的副本。
- en: '[PRE16]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is a quick explanation of the operation of the previous example:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面示例操作的快速解释：
- en: We specify `:0cB:` to make sure that we search only through the body, and to
    make a copy so we still get the original message processed.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们指定`:0cB:`以确保我们只搜索邮件正文，并进行复制，以便我们仍然可以得到原始邮件的处理。
- en: If anywhere in the body there is a phrase that has one or more numbers followed
    by a`<SPACE>Linux Rules<SPACE>` followed by either `o, k`, or `!`, then a copy
    will be stored in the `linuxrules` folder.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果消息正文中有一个短语，该短语有一个或多个数字，后面跟着`<SPACE>Linux Rules<SPACE>`，然后是`o, k`或`!`，则会将副本存储在`linuxrules`文件夹中。
- en: Setting and unsetting the `VERBOSE` option before a rule is processed allows
    just that rule to be displayed in the log in more detail, which means less log
    file to search through while debugging.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理规则之前设置和取消设置`VERBOSE`选项允许在日志中更详细地显示该规则，这意味着在调试时需要搜索的日志文件更少。
- en: Testing the size of a message part
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试消息部分的大小
- en: In some cases, we may not want large messages to be processed by a recipe. In
    this situation, we can set a limit that the recipe will not match messages over
    a certain size. If we have users that use a slow data connection, perhaps using
    connectivity over a mobile phone connection, it can be useful to move all large
    items of mail into a separate folder for retrieval when the users are back at
    a better Internet connection.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能不希望处理大型消息的配方。在这种情况下，我们可以设置一个限制，使得配方不匹配超过一定大小的消息。如果我们有使用缓慢数据连接的用户，也许使用手机连接的连接，将所有大型邮件项目移动到一个单独的文件夹中以便在用户回到更好的互联网连接时检索，这可能是有用的。
- en: '| Condition | Action |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 条件 | 操作 |'
- en: '| --- | --- |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `* > number` | Will return `true` if the message size is larger than the
    given number of bytes. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `* > number` | 如果消息大小大于给定的字节数，则返回`true`。 |'
- en: '| `* < number` | Will return `true` if the message size is smaller than the
    given number of bytes. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `* < number` | 如果消息大小小于给定的字节数，则返回`true`。 |'
- en: Testing the exit code of an external program
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试外部程序的退出代码
- en: If an external program is run to provide a part of the processing, the exit
    code may need to be checked to make sure that the process completed correctly
    or to perform a secondary operation to complete the overall processing.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行外部程序来提供处理的一部分，则可能需要检查退出代码，以确保进程正确完成或执行次要操作以完成整体处理。
- en: '[PRE17]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `?` instructs Procmail to pass the current message data to the Linux command
    line as standard input. The condition is successfully met if the command line
    exits with a zero exit code. While the command line is a pipeline of several processes,
    the exit code returned is that of the last program in the pipeline.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`?`指示Procmail将当前消息数据作为标准输入传递到Linux命令行。如果命令行以零退出代码退出，则条件成功满足。虽然命令行是几个进程的管道，但返回的退出代码是管道中最后一个程序的退出代码。'
- en: Any output printed to standard error by the pipeline is displayed in the log.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 管道打印到标准错误的任何输出都会显示在日志中。
- en: In this example, the body of the message is passed to the command pipeline and,
    if the phrase is found in exactly the third line (exit code 0), the message is
    filed in the folder.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，消息的主体被传递到命令管道中，如果短语确切地在第三行中找到（退出代码为0），则消息将被存储在文件夹中。
- en: The action of lines between the `VERBOSE=1` and the `VERBOSE=0` will be logged,
    but all lines outside this range will not be logged. This allows us to control
    the amount of logging taking place, and hence makes it easier to follow the log
    file activity.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在`VERBOSE=1`和`VERBOSE=0`之间的行的操作将被记录，但此范围之外的所有行将不被记录。这使我们能够控制正在进行的日志记录量，因此更容易跟踪日志文件活动。
- en: '[PRE18]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Negation
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 否定
- en: Sometimes it is useful to be able to check if a particular condition does not
    exist in order to continue processing in a certain way. The **Exclamation** (!),
    or **Bang** as it is sometimes referred to, is used to reverse the value of the
    condition so that false becomes true and vice versa.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，检查特定条件是否不存在以便以某种方式继续处理是有用的。**感叹号**（!）或有时称为**Bang**，用于颠倒条件的值，使得假变为真，反之亦然。
- en: '[PRE19]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This tests for a negative result in the condition and returns `true` if the
    condition is not met.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这测试条件中的负结果，并且如果条件不满足则返回`true`。
- en: Here we are looking for any item that was not sent directly to us and will be
    stored in a folder for later viewing.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在寻找任何未直接发送给我们的项目，并将其存储在一个文件夹中以供以后查看。
- en: '[PRE20]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Variable substitution in conditions
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 条件中的变量替换
- en: Multiple `$` flags may be used to force multiple substitution passes to be applied.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 多个`$`标志可以用于强制应用多个替换传递。
- en: '[PRE21]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `$` instructs Procmail to process the condition with the normal `sh` rules
    to perform variable and back tick substitution before actually evaluating the
    condition. The substitution process will resolve variables (`$VAR`) into their
    values rather than processing them as literals. Any quoted strings will have their
    quotes removed and all other shell meta characters will also be evaluated. To
    have any of these characters passed through this substitution process, they should
    be escaped using the standard backslash (\) escape mechanism.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`指示Procmail使用正常的`sh`规则处理条件，以执行变量和反引号替换，然后再实际评估条件。替换过程将解析变量（`$VAR`）为它们的值，而不是将它们作为文字处理。任何带引号的字符串都将删除其引号，所有其他shell元字符也将被评估。要使这些字符通过此替换过程，它们应该使用标准的反斜杠（\）转义机制进行转义。'
- en: 'The following example is taken from the *procmailex* manual page, and even
    there it is described as being rather exotic, but it does serve as an example.
    Suppose you have a file in your home directory called `.urgent`, and the (one)
    person named in that file is the sender of an incoming mail. You would like that
    mail to be stored in `$MAILDIR/urgent` instead of in any of the normal mail folders
    it would have been sorted in. Then this is what you could do (beware, the file
    length of `$HOME/.urgent` should be well below `$LINEBUF`; increase `LINEBUF`
    if necessary):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子摘自*procmailex*手册页，即使在那里也被描述为相当奇异，但它确实作为一个例子。假设您的主目录中有一个名为`.urgent`的文件，并且该文件中列出的（一个）人是传入邮件的发件人。您希望该邮件存储在`$MAILDIR/urgent`中，而不是存储在任何正常的邮件文件夹中。那么您可以这样做（注意，`$HOME/.urgent`的文件长度应远低于`$LINEBUF`；如有必要，增加`LINEBUF`）：
- en: '[PRE22]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Action line
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作行
- en: This is the line that does all of the processing activity. In most cases, this
    will mean writing to a physical file or folder. But it can also include forwarding
    mail to other users, passing data to a command or pipeline of commands or, in
    some cases, a number of successive actions to be performed as part of a compound
    recipe. If you want to perform more than one action, you can't just stack them
    one after the other—you need multiple recipes (possibly unconditional, and/or
    grouped in a pair of braces) and a colon line (and optionally conditions, of course)
    for each.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行所有处理活动的行。在大多数情况下，这意味着写入物理文件或文件夹。但它也可以包括将邮件转发给其他用户，将数据传递给命令或一系列命令的管道，或者在某些情况下，作为复合食谱的一部分执行一系列连续的操作。如果要执行多个操作，不能只是将它们堆叠在一起
    - 您需要多个食谱（可能是无条件的，和/或分组在一对大括号中）和每个冒号行（当然还可以是条件）。
- en: Also note that flags that affect the action line are not actually taking effect
    until the action is actually attempted. In particular, a `c` flag doesn't generate
    a clone of the message until its conditions have all been met.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，影响操作行的标志实际上直到尝试执行操作时才会生效。特别是，`c`标志直到其所有条件都得到满足之前才生成消息的克隆。
- en: Forwarding to other addresses
  id: totrans-304
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 转发到其他地址
- en: Global forwarding of all messages for a user account to another user account
    is a process that can be handled much more efficiently by Postfix itself. However,
    if some logic needs to be applied to decide what or where to send the message,
    then Procmail can assist.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户帐户的所有消息全局转发到另一个用户帐户是由Postfix本身处理效率要高得多的过程。但是，如果需要应用一些逻辑来决定发送消息的内容或位置，那么Procmail可以提供帮助。
- en: Most mail transports will allow us to pass multiple e-mail addresses for onward
    transmission.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数邮件传输都允许我们传递多个电子邮件地址以进行进一步传输。
- en: '[PRE23]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The above action is functionally the same as passing the message to the following
    pipeline:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 上述操作在功能上与将消息传递到以下管道相同：
- en: '[PRE24]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is a special case for forwarding mail and instructs Procmail to extract
    the list of recipients from the original message''s actual headers:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这是转发邮件的特殊情况，并指示Procmail从原始消息的实际标头中提取收件人列表：
- en: '[PRE25]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here we will forward mail to our support team rather than handle it ourselves.
    The mail includes the phrase **support** in the subject line.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将邮件转发给我们的支持团队，而不是自己处理。邮件的主题行包含短语**support**。
- en: '[PRE26]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Feeding to a shell or command pipeline
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 喂给shell或命令管道
- en: Procmail allows a virtually unlimited amount of freedom in what can be done
    to an e‑mail. One of the more powerful features of working with Procmail is its
    ability to forward an e-mail based on given criteria to an application program
    or script. A possible example would be to track support requests and have the
    entries stored directly into a database system where they can be tracked within
    a dedicated application.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Procmail允许在电子邮件中做几乎无限的事情。与Procmail一起工作的更强大的功能之一是其能够根据给定的条件将电子邮件转发到应用程序或脚本。一个可能的例子是跟踪支持请求，并将条目直接存储到数据库系统中，以便在专用应用程序中进行跟踪。
- en: The pipeline process is responsible for saving its output. The recipe's flags
    are able to tell Procmail to expect something else. By using the`>>` syntax, Procmail
    can determine a lock file to use. It is important to always use locking when writing
    to a file so as to avoid two operations writing to the same file at the same time
    and corrupting each other's data.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 管道过程负责保存其输出。食谱的标志能够告诉Procmail期望其他内容。通过使用`>>`语法，Procmail可以确定要使用的锁定文件。在写入文件时始终使用锁定非常重要，以避免两个操作同时写入同一个文件并损坏彼此的数据。
- en: '[PRE27]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It is possible to have the output of the command pipeline stored in a variable.
    This, by its own action, makes the recipe a non-delivering recipe.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将命令管道的输出存储在变量中。这本身使得食谱成为非交付食谱。
- en: '[PRE28]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Please note that this syntax is allowed only on the action line. For the same
    result in a plain assignment, we could use back tick (`) operator.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此语法仅允许在操作行上使用。要在普通赋值中获得相同的结果，我们可以使用反引号（`）运算符。
- en: '[PRE29]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Saving to a folder
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 保存到文件夹
- en: This saves the output to a plain file. If only a filename is provided, the file
    will be created in the directory specified in the `MAILDIR` setting. Always make
    sure that you use some form of locking when writing to a plain file.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出保存到普通文件中。如果只提供文件名，文件将在`MAILDIR`设置中指定的目录中创建。在写入普通文件时，一定要确保使用某种形式的锁定。
- en: '[PRE30]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When saving to a directory, files will be created with sequentially numbered
    files within the directory.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 保存到目录时，文件将在目录中创建具有顺序编号的文件。
- en: Using a trailing (/) slash at the end of the path name instructs Procmail to
    store the item in a `maildir` formatted folder. The subfolders, `cur, new`, and
    `tmp` are created automatically.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径名的末尾使用尾部（/）斜杠指示Procmail将项目存储在`maildir`格式的文件夹中。子文件夹`cur, new`和`tmp`将自动创建。
- en: '[PRE31]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Using `/`. at the end of the path name instructs Procmail to store the item
    in an `MH` formatted folder.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在路径名的末尾使用`/`指示Procmail将项目存储在`MH`格式的文件夹中。
- en: '[PRE32]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If we want to store the data into several `MH` or `maildir` folders, we can
    list them all at the same time. The result will be that only one file will actually
    be written, the rest will be created as hard links.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将数据存储到多个`MH`或`maildir`文件夹中，可以同时列出它们。结果将是实际只写入一个文件，其余将作为硬链接创建。
- en: Compound recipes
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复合食谱
- en: If we want to perform a number of conditional processes or actions on a matched
    item, then instead of a single action line we can specify a block of recipes to
    be used using the `{` and `}` characters. There must be at least one space after
    the `{` and before the `}` characters.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想对匹配项执行一系列条件进程或操作，那么我们可以使用`{`和`}`字符指定要使用的一组食谱块，而不是单个操作行。`{`和`}`字符后必须至少有一个空格。
- en: '[PRE33]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The code between the braces can be any valid Procmail construct.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号之间的代码可以是任何有效的Procmail结构。
- en: Note
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that an action that is a variable assignment always has to go inside a
    set of braces: `{ VAR=value }`. Using just `VAR=value` without the braces would
    result in the data being saved to a folder named `VAR=value`.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，变量赋值的操作必须始终放在一组大括号内：`{ VAR=value }`。如果只使用`VAR=value`而不使用大括号，数据将保存在名为`VAR=value`的文件夹中。
- en: If we want a recipe that does not actually do any processing, perhaps as part
    of an `if…else` operation, we can use an empty set of `{ }`, but the rules regarding
    the whitespace still apply and we need to ensure that there is at least one whitespace
    character between the two braces.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个实际上不进行任何处理的配方，也许作为`if…else`操作的一部分，我们可以使用一个空的`{ }`，但是空格的规则仍然适用，我们需要确保两个大括号之间至少有一个空格字符。
- en: 'The following example takes the previous example and modifies it slightly so
    that only one test is performed and then a series of unconditional tests are run
    if the test passes:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子是基于前面的例子稍作修改，以便只执行一个测试，然后如果测试通过，则运行一系列无条件的测试：
- en: '[PRE34]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Regular expressions
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Procmail implements a form of regular expressions that operates slightly differently
    than other UNIX utilities. Here we cover the basic differences and guide the new
    user into the powerful world of regular expressions, their meanings, implementations,
    and uses.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: Procmail实现了一种与其他UNIX实用程序略有不同的正则表达式形式。在这里，我们将介绍基本的区别，并引导新用户进入正则表达式的强大世界，它们的含义、实现和用途。
- en: We have already seen that Procmail matches are case insensitive unless the `D`
    flag is used. This is also true for regular expressions. Procmail also uses multiline
    matches by default.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，Procmail的匹配是不区分大小写的，除非使用了`D`标志。对于正则表达式也是如此。Procmail还默认使用多行匹配。
- en: Introduction to regular expressions
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式简介
- en: New users to the world of Linux and programming in general, may not be aware
    of the powerful features that regular expressions bring to processing data. In
    its simplest form, regular expressions can be understood as searching for a phrase
    or pattern anywhere in a body of data. The following simple example shows how
    we can match all mail items where the header and/or body contains the phrase `mystical
    monsters` and place the mail in a relevant folder.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux和编程的新用户来说，可能不清楚正则表达式为处理数据带来的强大功能。在其最简单的形式中，正则表达式可以理解为在一组数据中搜索短语或模式。以下简单的例子展示了如何匹配所有邮件项目，其中标题和/或正文包含短语`mystical
    monsters`，并将邮件放在相关文件夹中。
- en: '[PRE35]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'However, this filter would not match items that contained the phrase `mystical
    monster` or `mystical-monsters`, for example. So, the real power of regular expressions
    can be seen in the ability to describe text or data patterns in a simplified format
    and then search for matches to those patterns in a body of data. However, you
    should be careful not to be misled by the word *simplified*. The majority of regular
    expressions that you will come across in real life may well be anything but simple
    to read if written in the native format. Take the following example, which is
    intended to determine if a mail item is MIME encoded and store it in a suitable
    folder if it is:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个过滤器将无法匹配包含短语`mystical monster`或`mystical-monsters`的项目，例如。因此，正则表达式的真正威力在于能够以简化的格式描述文本或数据模式，然后在一组数据中搜索与这些模式匹配的内容。但是，你应该小心不要被“简化”这个词所误导。在现实生活中，你遇到的大多数正则表达式可能并不简单，如果用原生格式编写的话。以下面的例子为例，它的目的是确定邮件项目是否是MIME编码，并在适当的文件夹中存储它：
- en: '[PRE36]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The characters `., [, ^, ;, ], +, ?, \, /`, and`"` are special instructions
    rather than the literal ASCII character they normally portray. To understand these
    characters and their meanings, we will take a whirlwind tour through the most
    important examples.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 字符`., [, ^, ;, ], +, ?, \, /`和`"`是特殊指令，而不是它们通常表示的字面ASCII字符。为了理解这些字符及其含义，我们将快速浏览一下最重要的例子。
- en: The dot
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 句点
- en: 'This is the simplest and most common form of regular expression and simply
    means match any single character, (excluding a newline character, which is considered
    a special case). Consider the following expression:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单和最常见的正则表达式形式，简单地意味着匹配任何单个字符（不包括换行符，换行符被视为特殊情况）。考虑以下表达式：
- en: '[PRE37]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This would match any of the following phrases:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配以下任何短语：
- en: '[PRE38]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In fact, it will match any phrase with a three-character word between `Dragons`
    and `mystical`. If we wanted to match any length of word with three or more characters
    between `Dragons` and `mystical`, we could use the `?` or quantifier operation.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它将匹配`Dragons`和`mystical`之间有一个三个字符的单词的任何短语。如果我们想匹配`Dragons`和`mystical`之间长度为三个或更多字符的任何单词，我们可以使用`?`或量词操作。
- en: In case we want to match a literal '.' or more than one '.', we can escape any
    character that has special significance to a regular expression string by preceding
    it by a backslash '\' so that '\.' will literally match a '.' (period) and '\\'
    will literally match a '\' (backslash) character.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想匹配一个字面上的'.'或多个'.'，我们可以通过在特殊意义的字符前加上反斜杠'\'来转义正则表达式字符串，使得'\.'可以字面上匹配'.'（句号），'\\'可以字面上匹配'\'（反斜杠）字符。
- en: Quantifier operation
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 量词操作
- en: 'The question mark indicates that the preceding character should be matched
    zero times or one time only. So, the following lines of code will meet our requirements:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 问号表示前面的字符应该匹配零次或一次。因此，以下代码行将满足我们的要求：
- en: '[PRE39]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This expression could be read as, "Match any word consisting of three or more
    characters followed by nothing or any one character".
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式可以理解为，“匹配由三个或更多字符组成的任何单词，后面跟着空白或任何一个字符”。
- en: 'The character preceding the `?` may also be a simple ASCII character in which
    case the expression would match as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`?`前面的字符也可以是一个简单的ASCII字符，这样表达式将匹配如下：'
- en: '[PRE40]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This could be read as, "Any two characters followed by either nothing or a letter
    `d.`" Therefore this would match both `an` and `and` but not `are.`
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以理解为，“任意两个字符后面跟着空白或字母`d.`”因此，这将匹配`an`和`and`，但不会匹配`are.`
- en: The asterisk
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 星号
- en: The asterisk modifier works in a way similar to the quantifier operator, but
    means match zero or more of the preceding character except, of course, a newline.
    The `.*` is a very common sequence that you will find in a large number of recipes.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 星号修饰符的工作方式类似于量词运算符，但意思是匹配前面的字符的零个或多个实例，当然不包括换行符。`.*`是一个非常常见的序列，你会在很多配方中找到它。
- en: The following example will match all the messages that include the word `choose`
    followed by some other words followed by the word `online:`
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将匹配所有包含单词`choose`后跟其他单词再跟单词`online`的消息：
- en: '[PRE41]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The next example will look for "anything" (.*) followed by two or more exclamation
    marks (!!) and (!*):'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子将寻找“任何东西”（.*）后跟两个或更多感叹号（!!）和（!*）：
- en: '[PRE42]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The plus sign
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加号
- en: The plus sign is very similar to the `*` except that it requires that there
    must be at least one instance of the character preceding the `+` in the regular
    expression.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 加号与`*`非常相似，只是它要求正则表达式中`+`之前必须至少有一个字符的实例。
- en: If we consider our previous example, the next example will look for "anything"
    `.*` followed by two `!!` and at least one more (!+) exclamation marks.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑我们之前的例子，下一个例子将寻找“任何东西”`.*`后跟两个`!!`和至少一个以上的`!`感叹号。
- en: '[PRE43]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This would now give us a more restricted output where at least three `!` in
    a row would be required.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个更受限制的输出，至少需要三个`!`连续出现。
- en: '[PRE44]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Restrictive matches using parentheses
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用括号进行限制匹配
- en: So far, the matching patterns that we have been able to create are powerful
    but work in a rather unfocused way. For example, we can easily write a rule to
    find any three-letter word ending in `t` but cannot limit the matches to only
    a given set of words ending in `t`. To overcome this, we can replace the`.` or
    single character with a group of characters or sets of groups of characters in
    a list and then apply the quantifier operations to say exactly how many times
    these can be applied.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们能够创建的匹配模式功能强大，但工作方式不够集中。例如，我们可以轻松地编写一个规则来查找以`t`结尾的任何三个字母的单词，但无法将匹配限制为仅包含一组给定的以`t`结尾的单词。为了克服这一点，我们可以用一组字符或字符组的集合替换`.`或单个字符，然后应用量词操作来准确说明这些字符可以应用多少次。
- en: By careful use of the parentheses `( )`, we can create groups of strings that
    we will use in the pattern matching rules. For instance, let us assume we are
    trying to split e-mails that are sent by a system script on a frequent basis.
    The script formats the subject line to have one of the following phrases in the
    subject line.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 通过小括号`( )`的谨慎使用，我们可以创建字符串组，这些组将用于模式匹配规则。例如，假设我们试图拆分由系统脚本频繁发送的电子邮件。脚本格式化主题行，使其包含以下短语之一。
- en: '[PRE45]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The following regular expression will match the specific string we are looking
    for by matching any string that has one or more occurrences of the phrase `is
    only one` between `there` and `problem`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的正则表达式将匹配我们要查找的特定字符串，方法是匹配任何字符串，该字符串在`there`和`problem`之间有一个或多个`is only one`短语的出现。
- en: '[PRE46]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If we wanted to filter a list of words or phrases, we would need to use the
    **Alternation** feature.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要过滤一个词或短语列表，我们需要使用**Alternation**功能。
- en: '[PRE47]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `|` character separates lists of words that could be used to match against
    the pattern.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`|`字符分隔了可以用来匹配模式的单词列表。'
- en: The following simple spam filter uses the alternation feature to search for
    text substitutions regularly used in a bid to avoid the simple word-based filters.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简单的垃圾邮件过滤器使用了**Alternation**功能，以搜索常用的文本替换，以避免简单的基于单词的过滤器。
- en: Creating a simple spam filter
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个简单的垃圾邮件过滤器
- en: With the growing number of spam messages that we receive every day, I am sure
    that some of you reading so far will have figured out that we could start to filter
    some of the regular messages that we receive on a daily basis. There are a number
    of specific spam filters that are designed to work closely with Procmail and offer
    a far larger set of tests and coverage for spam filtering. One such application,
    SpamAssassin, is covered in [Chapter 8](ch08.html "Chapter 8. Busting Spam with
    SpamAssassin").
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们每天收到的垃圾邮件数量不断增加，我相信到目前为止阅读到这里的一些人已经想出了我们可以开始过滤我们每天收到的一些常规消息的方法。有许多专门设计用于与Procmail紧密配合并为垃圾邮件过滤提供更多测试和覆盖范围的特定垃圾邮件过滤器。其中一个应用程序SpamAssassin，在[第8章](ch08.html
    "第8章。使用SpamAssassin消灭垃圾邮件")中有介绍。
- en: Take for example online casinos—a popular subject for spammers who encourage
    us to explore them. It is something that we are not usually interested in, and
    so we feel happy to filter all messages that contain the words "Online" and "Casinos"
    into a separate folder.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 以在线赌场为例——这是垃圾邮件发送者鼓励我们探索的热门主题。这不是我们通常感兴趣的东西，所以我们很高兴地将所有包含“在线”和“赌场”这两个词的消息过滤到一个单独的文件夹中。
- en: '[PRE48]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Part of the challenge for spammers is to write subject lines that we can read
    while spam filters find difficult to process. A simple way of doing this is to
    substitute commonly mistyped characters such as Zero (`0`) for letter `O` or letter
    `o, 1` for `L` or `l`, and `4` for `A` or `a`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾邮件发送者面临的挑战之一是编写我们可以阅读而垃圾邮件过滤器难以处理的主题行。一个简单的方法是用常见的打字错误字符替换，比如数字零（`0`）替换字母`O`或`o`，数字`1`替换`L`或`l`，数字`4`替换`A`或`a`。
- en: 'So we could progress and write the rule as:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以继续编写规则：
- en: '[PRE49]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The final iteration of this recipe is shown next where we are specifically looking
    for subject lines that contain both the words "online" and "casino" but to include
    the occasions where the word may be in different order each word is tested separately.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个迭代将具体显示这个配方，我们特别寻找包含“在线”和“赌场”这两个词的主题行，但要包括单词可能以不同顺序出现的情况，每个单词都会分别测试。
- en: '[PRE50]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: While this would work quite well, it is not really efficient to have rules that
    work in this way and, as this sort of substitution is a common requirement for
    regular expressions, there is a special way of expressing these terms in the **Character
    classes**.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做效果不错，但是以这种方式工作的规则并不是真正高效的，因为这种替换是正则表达式的常见需求，所以有一种特殊的方式来表达这些术语，即**字符类**。
- en: Character classes
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符类
- en: Any sequence of characters contained in square brackets `[ ]` indicates that
    the listed characters are each to be checked in the expression. For common occurrences
    of sequences of characters such as the letters of the alphabet or a range of numbers,
    it is possible to use `[a-z]` or `[0-9]:`
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号`[ ]`中包含的任何字符序列表示要在表达式中检查每个列出的字符。对于字母表中的字母或数字范围等常见字符序列，可以使用`[a-z]`或`[0-9]`：
- en: '`[a-e]` means match all the letters `a, b, c, d, e` inclusive.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[a-e]` 意味着匹配所有字母`a, b, c, d, e`。'
- en: '`[1,3,5-9]` means match any of the numbers `1, 3, 5, 6, 7, 8`, or `9`.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[1,3,5-9]` 意味着匹配数字`1, 3, 5, 6, 7, 8`或`9`中的任何一个。'
- en: The following example will find messages that embed numbers `0` and `1` within
    text strings so that they look like `O` and `L` or `I`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将查找在文本字符串中嵌入数字`0`和`1`的消息，以便它们看起来像`O`和`L`或`I`。
- en: '[PRE51]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Start of line
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行首
- en: If we want to match all of a wide range of characters and not match a small
    number of ranges, it is easier to specify the negative match using the `^` character.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想匹配所有范围广泛的字符而不匹配少量范围，那么使用`^`字符指定负匹配会更容易。
- en: '[PRE52]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This means to match any string that begins with anything that is not a number
    between `0` and `9`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着匹配任何以不是`0`到`9`之间的数字开头的字符串。
- en: 'It is useful to add a start of line anchor to patterns we are searching for
    when we know that the pattern should start the line. For example, all headers
    must start on the beginning of the line, so searching for the following phrase:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们知道模式应该从行首开始时，将行首锚添加到我们正在搜索的模式中是很有用的。例如，所有标题必须从行首开始，因此搜索以下短语：
- en: '[PRE53]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'would also match headers that begin with a phrase such as:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 也将匹配以短语开头的标题，例如：
- en: '[PRE54]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To stop this, we can add the **Start of Line Anchor character** (^) and change
    the regular expression to:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 为了停止这个，我们可以添加**行首锚字符**（^）并将正则表达式更改为：
- en: '[PRE55]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: End of Line
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行尾
- en: 'When we are planning to match strings that we know we should terminate, we
    can add the **End of Line Anchor character**, `$`, to the pattern to ensure that
    we match right to the end of the string as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们计划匹配我们知道应该终止的字符串时，我们可以将**行尾锚字符**（$）添加到模式中，以确保我们匹配到字符串的末尾，如下所示：
- en: '[PRE56]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This will match any subject line that ends in the word `now`.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配任何以单词`now`结尾的主题行。
- en: Further reading
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Regular expressions are an enormous subject, but well worth learning as they
    are used by a large number of Linux tools and applications. There are many online
    resources related to regular expressions. Here are a few links to get started:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一个庞大的主题，但是非常值得学习，因为它们被许多Linux工具和应用程序使用。有许多与正则表达式相关的在线资源。以下是一些入门链接：
- en: '[http://www.regular-expressions.info/](http://www.regular-expressions.info/)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.regular-expressions.info/](http://www.regular-expressions.info/)'
- en: '[http://en.wikipedia.org/wiki/Regular_expression](http://en.wikipedia.org/wiki/Regular_expression)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/Regular_expression](http://en.wikipedia.org/wiki/Regular_expression)'
- en: As we briefly covered in the previous chapter, Procmail has a number of useful
    "pre-prepared" regular expressions or macros that provide a range of matches that
    are commonly used in Procmail recipes.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中简要介绍的那样，Procmail有许多有用的“预先准备好的”正则表达式或宏，提供了一系列在Procmail配方中常用的匹配。
- en: ^TO and ^TO_
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ^TO和^TO_
- en: '`^TO` was the original Procmail macro for handling "To" addresses. This has
    been superseded by the newer `^TO_` macro that was introduced in Procmail version
    3.11pre4.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`^TO`是处理“To”地址的原始Procmail宏。这已经被新的`^TO_`宏所取代，该宏是在Procmail版本3.11pre4中引入的。'
- en: This catchall includes most headers that can include your address in them, such
    as `To:, Apparently-To:, Cc:, Resent-To:`, and so on.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这个万能匹配包括大多数标题，这些标题中可能包含您的地址，例如`To:, Apparently-To:, Cc:, Resent-To:`等等。
- en: In most cases, you should use the `^TO_` option as it has much better coverage.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您应该使用`^TO_`选项，因为它的覆盖范围要好得多。
- en: Note
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although it would seem logical to have a similar macro to cover the source address
    details, note that there is *no* corresponding `^FROM` or `^FROM_` macro.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管似乎有逻辑地有一个类似的宏来覆盖源地址详细信息，但请注意，*没有*相应的`^FROM`或`^FROM_`宏。
- en: 'Here is the regular expression string from the Procmail source code:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自Procmail源代码的正则表达式字符串：
- en: '[PRE57]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ^FROM_MAILER
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ^FROM_MAILER
- en: This macro recognizes a wide range of mail generation programs and is a useful
    catchall. However, new programs are being created all the time, so additional
    filters will nearly always be required.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏识别了广泛的邮件生成程序，并且是一个有用的万能匹配。但是，新程序一直在被创建，因此几乎总是需要额外的过滤器。
- en: Procmail expands this short macro into the following regular expression as taken
    from the Procmail source code.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: Procmail将这个简短的宏扩展为从Procmail源代码中获取的以下正则表达式。
- en: '[PRE58]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ^FROM_DAEMON
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ^FROM_DAEMON
- en: This takes a similar approach to the `^FROM_MAILER` but is intended to identify
    messages from the more common Linux daemons and system processes.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这采用了与`^FROM_MAILER`类似的方法，但旨在识别更常见的Linux守护程序和系统进程的消息。
- en: 'Regular expression string from Procmail source code is given as:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 给出了来自Procmail源代码的正则表达式字符串：
- en: '[PRE59]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The following example will store the daemon messages received in a folder that
    includes the year and month as part of the path. These variables `${YY}` and `${MM}`
    are assigned previously in the Procmail file and the necessary directories are
    also created.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将存储接收到的守护程序消息在包含年份和月份作为路径的文件夹中。这些变量`${YY}`和`${MM}`在Procmail文件中之前分配，并且必要的目录也已创建。
- en: '[PRE60]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Advanced recipes
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级配方
- en: Here we are going to assemble the various items of Procmail capability into
    a few useful recipes that we can use as the basis for tools within our own organization.
    The first example is based on the traditional `Vacation` recipe that informs senders
    of the e-mail that may not be read by the recipient for some time. The second
    shows how to create the support to automatically file messages based on the date
    and the possible time of being processed. Finally, we will complete the rule started
    in the previous chapter to inform the user of large mail items that have been
    filtered into a separate folder.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将把Procmail的各种功能组合成几个有用的食谱，作为我们自己组织中工具的基础。第一个例子是基于传统的`度假`食谱，通知发件人可能需要一段时间才能被收件人阅读的电子邮件。第二个示例展示了如何创建支持，根据日期和可能的处理时间自动归档消息。最后，我们将完成上一章开始的规则，通知用户已被过滤到单独文件夹中的大型邮件项目。
- en: Creating a vacation auto reply
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建度假自动回复
- en: This example is based upon the vacation example given in `man procmailex` and
    referred to briefly earlier in this chapter.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是基于`man procmailex`中给出的度假示例，并在本章中稍作提及。
- en: As we have already discussed, blindly and automatically responding to an e-mail
    is a very bad idea and has significant ramifications. First we must decide whether
    to send an auto reply. To do this, we need to make sure that conditions make sense
    and are satisfied. If so, headers (signified by the `h` flag) of the current message
    are fed to `formail`, a utility program that is part of the Procmail suite of
    utilities. `formail` then checks the `vacation.cache` file to find out if the
    sender has already received an auto reply. This is to make sure we are not sending
    multiple reports to a user. While this part of the processing is going on, our
    recipe will create a lock as `vacation.lock`.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的那样，盲目自动回复电子邮件是一个非常糟糕的主意，并且具有重大影响。首先，我们必须决定是否发送自动回复。为此，我们需要确保条件是合理且满足的。如果是这样，当前消息的标题（由`h`标志表示）被提供给`formail`，这是Procmail工具套件的一部分。然后，`formail`检查`vacation.cache`文件，以查看发件人是否已经收到自动回复。这是为了确保我们不会向用户发送多个报告。在进行这部分处理的同时，我们的食谱将创建一个名为`vacation.lock`的锁。
- en: The main reason for this is to avoid clashes when updating the cache, which
    could result in corruption of the cache information.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的主要原因是为了避免在更新缓存时发生冲突，这可能导致缓存信息损坏。
- en: The recipe actually comprises two individual recipes. The first one provides
    the checks and recording of replies sent to ensure that we don't send duplicate
    or repetitive replies.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱实际上包括两个单独的食谱。第一个提供了检查和记录已发送的回复，以确保我们不发送重复的回复。
- en: This recipe `W`, waits for a return from `formail`. Without the `c`, Procmail
    would stop processing after completing this recipe because it is a delivery recipe.
    It delivers headers to `formail`.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱`W`，等待`formail`的返回。没有`c`，Procmail在完成这个食谱后会停止处理，因为它是一个投递食谱。它将标题传递给`formail`。
- en: There is more to the `TO_` and `^FROM_DAEMON` conditions than what meets the
    eye.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`TO_`和`^FROM_DAEMON`条件的含义远不止表面上看到的那样。'
- en: '`TO_ $<logname>` is satisfied if the user''s login name appears in any recipient
    header **To:, Cc:, Bcc:**. This avoids sending auto replies to messages that were
    addressed to an alias or mail list, but not explicitly to our user.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户的登录名出现在任何接收者标题**To:, Cc:, Bcc:**中，`TO_ $<logname>`就会被满足。这样可以避免向地址为别名或邮件列表的消息发送自动回复，而不是明确发送给我们的用户。
- en: '`!^FROM_DAEMON` makes sure we do not auto reply to messages from any of the
    wide variety of daemons.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`!^FROM_DAEMON`确保我们不会自动回复来自各种守护程序的消息。'
- en: '`!^X-Loop: $RECIPIENT` avoids replying to our own auto reply; notice that this
    `X-Loop` header is inserted into the auto replies we send out.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`!^X-Loop: $RECIPIENT`避免回复我们自己的自动回复；请注意，我们发送的自动回复中插入了这个`X-Loop`标题。'
- en: '[PRE61]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The second part of the recipe takes place if the first one did not find a match
    in the cache. There are two reasons that the address may not have been found—either
    it has never been seen and so no reply has been sent, or it was seen so long ago
    that the entry has been forced out of the cache. In either case, a copy of the
    vacation message will be sent. The sender will never receive an automatic reply
    for every single message that they send—something that can really upset a prolific
    mail writer.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个食谱在缓存中找不到匹配项，那么食谱的第二部分就会执行。地址找不到的原因有两个——要么从未见过，因此没有发送过回复，要么是很久以前见过，以至于条目已经被强制从缓存中移除。在任何一种情况下，都会发送一份度假消息的副本。发件人永远不会收到他们发送的每一条消息的自动回复——这可能会让频繁发送邮件的人感到不安。
- en: '[PRE62]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Due to `e`, the previous recipe is executed if the preceding one returns an
    error status. In this case, it is not really an error, it is just the signal from
    `formail` that the address didn't exist in the cache file and we can go ahead
    with the auto reply. Notice that if in the preceding recipe the conditions are
    not met causing the `formail` cache check to be skipped, Procmail is clever enough
    to skip this recipe.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`e`，如果前一个食谱返回错误状态，就会执行前一个食谱。在这种情况下，这并不是真正的错误，只是来自`formail`的信号，表示地址在缓存文件中不存在，我们可以继续发送自动回复。请注意，如果在前一个食谱中条件不满足导致跳过`formail`缓存检查，Procmail足够聪明，会跳过这个食谱。
- en: The headers of the current message are fed to the `formail` in this recipe,
    in order to construct the headers for the auto reply.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 当前消息的标题被提供给这个食谱中的`formail`，以便构建自动回复的标题。
- en: The `c` in this recipe causes the entire current message to be processed after
    this recipe. Typically, this means that it will be processed with no further recipes
    and that is how we get a copy in our mailbox. There is no need for a lock while
    executing this recipe, so none is used.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱中的`c`导致在这个食谱之后处理整个当前消息。通常，这意味着它将在没有进一步食谱的情况下被处理，这就是我们在邮箱中得到一份副本的方式。在执行这个食谱时不需要锁，因此没有使用锁。
- en: All that is required to send back to the sender of the original message is a
    copy of the message, and that is held in the file `.vacation_message` in the user's
    home directory.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 向原始消息的发送者发送回复所需的只是消息的副本，该副本保存在用户的主目录中的`.vacation_message`文件中。
- en: Storing the message information outside the Procmail recipe makes it easy to
    allow your system users to easily update the message that they send out without
    risk of them breaking the actual recipe itself.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在Procmail配方之外存储消息信息使得系统用户可以轻松更新他们发送的消息，而不会破坏实际的配方本身。
- en: Organizing mail by date
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按日期组织邮件
- en: You may not want to delete mail that you feel may be useful one day. This can
    easily lead to gigabytes of data being stored in a variety of locations. It is
    possible to filter some or all of our incoming mails into folders based on a combination
    of the year, month, and topic so that they can be tracked down easily.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不想删除您认为将来可能有用的邮件。这很容易导致大量数据存储在各种位置。可以根据年份、月份和主题的组合将我们的一些或所有传入邮件过滤到文件夹中，以便轻松追踪。
- en: A generic rule that is applied to every mail process ensures that the necessary
    directory structure exists.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于每个邮件过程的通用规则确保必要的目录结构存在。
- en: '[PRE63]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If you would prefer slightly more control over the output format or location,
    you may use these rules instead:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢对输出格式或位置有更多控制，可以使用以下规则：
- en: '[PRE64]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Informing users about large mail
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通知用户有关大型邮件
- en: In the previous chapter, we introduced a very simple rule that stored all incoming
    mail over 100 KB in size in a `largemail` folder. This was useful in keeping the
    size of individual incoming mail folders from growing too large, but meant that
    a special check had to be made regularly to see if any mail had been filtered.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了一个非常简单的规则，将所有大小超过100KB的传入邮件存储在`largemail`文件夹中。这对于保持单个传入邮件文件夹的大小不会变得太大很有用，但意味着需要定期进行特殊检查，以查看是否已过滤任何邮件。
- en: In this rule, we will now extract the headers and subject line, plus the first
    few lines of the original large e-mail message, and create a new message with
    a modified subject line. This modified message will be stored in the user's inbox
    at the same time as filtering the large original item into its separate `largemail`
    folder.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个规则中，我们现在将提取标题和主题行，以及原始大型电子邮件消息的前几行，并创建一个带有修改主题行的新消息。这个修改后的消息将与将大型原始项目过滤到其单独的`largemail`文件夹中同时存储在用户的收件箱中。
- en: 'The main part of the test will be applied only if the size of the message is
    over 100,000 bytes in size, so we will need a structure similar to the following
    recipe to do the initial testing and decide if this is a large item or not:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的主要部分仅在消息大小超过100,000字节时才会应用，因此我们需要类似以下配方的结构来进行初始测试，并决定这是否是一个大项目：
- en: '[PRE65]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Assuming that we do have a large item, we need to make a copy of the message
    using the `c` flag and store this copy in the `largemail` folder:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们确实有一个大项目，我们需要使用`c`标志复制消息，并将此副本存储在`largemail`文件夹中：
- en: '[PRE66]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Extracting the first part of the body of the message comes next and this can
    be done using a variety of options. In this case, we are going to strip off the
    first 1024 bytes of the message by waiting for the results of passing only the
    body of the message only to the system head command and telling it to return only
    the first 1024 bytes. The flags used here tell Procmail to wait for the results
    of the command-line process and to ignore any pipeline errors as the head command
    will only read part of the data being offered to it.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是提取消息正文的第一部分，可以使用各种选项来完成。在这种情况下，我们将通过等待传递消息正文的结果来剥离消息的前1024字节，只告诉系统头命令返回前1024字节。这里使用的标志告诉Procmail等待命令行进程的结果，并忽略任何管道错误，因为头命令只会读取提供给它的数据的一部分。
- en: '[PRE67]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now we need to rewrite the subject line, which is done using the `formail` program.
    This time, we pass just the headers to the command line and wait for the response.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要重写主题行，这是使用`formail`程序完成的。这一次，我们只传递标题到命令行，并等待响应。
- en: In this case though, we need to obtain the current subject line so that we can
    pass it to the `formail` program as part of the modified subject line. We do this
    by doing a simple match on the subject contents and then passing the `$MATCH`
    variable, which now holds the subject line contents as an argument to the `formail`
    program. For neatness, we add the `{* -BIG- *}` wording before the original subject
    line to make it easy to sort and identify these messages.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在这种情况下，我们需要获取当前的主题行，以便将其作为修改后的主题行的一部分传递给`formail`程序。我们通过对主题内容进行简单匹配，然后将`$MATCH`变量（现在保存主题行内容）作为`formail`程序的参数传递。为了整洁起见，我们在原始主题行之前添加`{*
    -BIG- *}`的措辞，以便轻松排序和识别这些消息。
- en: '[PRE68]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Normal delivery of the message will then take place and the new shorter message
    will be stored in the inbox.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将进行消息的正常传递，并将新的较短消息存储在收件箱中。
- en: If we put all of this together, we end up with the following complete recipe.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将所有这些放在一起，我们最终得到以下完整的配方。
- en: '[PRE69]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Procmail Module Library
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Procmail模块库
- en: 'As part of a community effort to avoid reinventing the wheel, the Procmail
    Module Library provides a collection of useful recipes contributed by Procmail
    users. The following introduction from the Procmail Module Library [http://freshmeat.net/projects/procmail-lib](http://freshmeat.net/projects/procmail-lib)
    describes the package as:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个避免重复造轮子的社区努力的一部分，Procmail模块库提供了一系列由Procmail用户贡献的有用配方。来自Procmail模块库的以下介绍[http://freshmeat.net/projects/procmail-lib](http://freshmeat.net/projects/procmail-lib)描述了该软件包：
- en: Procmail Module Library is a collection of many plug-in modules for the Procmail
    mail processing utility. The modules allow common tasks like parsing dates, times,
    MIME, and email addresses, forwarding mail, dealing with POP3, spam shielding,
    running email cron jobs, handling daemon messages, and more.
  id: totrans-481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Procmail模块库是Procmail邮件处理实用程序的许多插件模块的集合。这些模块允许常见任务，如解析日期、时间、MIME和电子邮件地址，转发邮件，处理POP3，垃圾邮件屏蔽，运行电子邮件cron作业，处理守护程序消息等。
- en: Each of the modules, or Procmail included files, are comprehensively documented
    and show example usage. They can be used as supplied, with various configurable
    options or used as a basis of your own recipes. Many of the techniques we have
    illustrated in this chapter are used in the library along with some more sophisticated
    filtering methods based on the type of content within a message.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块或Procmail包含的文件都有全面的文档和示例用法。它们可以按原样使用，也可以使用各种可配置选项，或者作为您自己食谱的基础。我们在本章中演示的许多技术都在库中使用，还有一些基于消息内容类型的更复杂的过滤方法。
- en: Putting it all together
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把所有东西整合起来
- en: We have covered a wide range of topics in this chapter, which we can now pull
    together. The following examples use each of the techniques shown in this chapter
    and are commonly used for e-mail processing. I hope that you find it useful in
    creating your own mail filtering strategy.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了各种主题，现在我们可以把它们整合起来。以下示例使用了本章中展示的每种技术，并且通常用于电子邮件处理。我希望你能在创建自己的邮件过滤策略时找到它有用。
- en: Creating a structure to base your own rules upon
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个基于您自己规则的结构
- en: Grouping related aspects of the Procmail rules and configuration will make your
    installation easier to maintain and less likely to create problems when making
    changes.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 将Procmail规则和配置的相关方面分组将使您的安装更容易维护，并在进行更改时更不太可能出现问题。
- en: Within the main Procmail directory, create individual files following a consistent
    naming convention such as `rc.main, rc.spam, rc.lists`, and so on. Then include
    each of these into your main `.procmailrc` file as follows.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在主Procmail目录中，创建遵循一致命名约定的单独文件，例如`rc.main, rc.spam, rc.lists`等。然后将这些文件包含到您的主`.procmailrc`文件中，如下所示。
- en: '[PRE70]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Now for each of the listed `include` files, create the file as named and include
    the rules related to the container in that file. It then becomes a matter of commenting
    an `INCLUDERC` reference for temporarily isolating a section of processing for
    incoming mail. Be careful not to blindly cut and paste these examples without
    checking if each recipe performs as expected, especially in a production environment.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于列出的每个“include”文件，创建与该文件相关的规则，并将其包含在该文件中。然后，暂时隔离用于处理传入邮件的部分的`INCLUDERC`引用就成了问题。在生产环境中，要小心不要盲目地剪切和粘贴这些示例，而不检查每个食谱是否按预期执行。
- en: Rc.system
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rc.system
- en: 'File informational system and daemon messages in a dated folder structure can
    be given as:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 将信息系统和守护程序消息存档在一个带日期的文件夹结构中，可以给出如下：
- en: '[PRE71]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Rc.lists
  id: totrans-493
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rc.lists
- en: Save all our subscribed mailing lists in dated folders for reading later.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有订阅的邮件列表存档在带日期的文件夹中以供以后阅读。
- en: '[PRE72]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Rc.killspam
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rc.killspam
- en: Delete any mail from senders that match an address in our kill file.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 删除来自与我们的屏蔽文件中地址匹配的发件人的任何邮件。
- en: '[PRE73]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Rc.vacation
  id: totrans-499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rc.vacation
- en: 'Our holiday auto reply recipe:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的假期自动回复食谱：
- en: '[PRE74]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Rc.largefiles
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rc.largefiles
- en: To avoid clogging up our inbox with large messages, we file the large message
    in a folder and send ourselves a notification that we have received an oversized
    message.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免用大量消息堵塞我们的收件箱，我们将大消息存档在一个文件夹中，并发送通知给自己，告知我们收到了一条超大消息。
- en: '[PRE75]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Rc.viruses
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rc.viruses
- en: Anything with an e-mail header indicating the message as a virus, file in a
    folder.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 任何带有表明该消息为病毒的电子邮件标题的内容，都放在一个文件夹中。
- en: '[PRE76]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Rc.spamfilter
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rc.spamfilter
- en: Anything with an e-mail header indicating the message is spam, file in a folder.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 任何带有表明该消息为垃圾邮件的电子邮件标题的内容，都放在一个文件夹中。
- en: '[PRE77]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Summary
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have explored Procmail to discover a large number of services
    and a large amount of functionality that it can provide to help with getting our
    mail under control. Using the advanced features of Procmail we have discovered:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了Procmail，发现了大量的服务和大量的功能，它可以提供帮助我们控制邮件。使用Procmail的高级功能，我们发现了：
- en: The differences between delivering and non-delivering recipes
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交付和非交付食谱之间的区别
- en: How to order each recipe to avoid slow delivery times
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何订购每个食谱以避免交货时间过长
- en: The use of Procmail variables and condition flags to control delivery
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Procmail变量和条件标志来控制交付
- en: Using regular expressions for sophisticated pattern matching
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式进行复杂的模式匹配
- en: The large number of available Procmail macros and their usage
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的大量Procmail宏及其用法
- en: And finally, a number of example recipes to manage our mail effectively
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，一些示例食谱来有效管理我们的邮件
- en: While we have covered a lot, there is still a lot to be learned and there are
    a large number of resources available on the Web dedicated to this one particular
    application.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经涵盖了很多内容，但仍有很多东西有待学习，网上有大量资源专门致力于这一特定应用程序。
- en: Hopefully you will now have a strong grasp of the core functionality of Procmail,
    how to implement it, and also how to go about exploring your real-life needs,
    and creating recipe sets that you can combine to create your own unique mail filtering
    strategy.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 希望现在您已经对Procmail的核心功能有了深刻的理解，知道如何实施它，以及如何探索您的现实需求，并创建食谱集，以便组合成您自己独特的邮件过滤策略。
