- en: The Linux Command Line
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux命令行
- en: In this chapter, we will introduce you to the most fundamental concepts when
    starting to work with the Linux command line. It is a very powerful and efficient
    tool with which you can execute the various actions that you'll generally require
    when using Linux. A plethora of shortcuts and tricks will help you to navigate
    the command line more efficiently.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您介绍开始使用Linux命令行时最基本的概念。这是一个非常强大和高效的工具，您可以使用它执行在Linux中通常需要的各种操作。大量的快捷方式和技巧将帮助您更有效地导航命令行。
- en: 'In this chapter, we''ll walk you through the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将带您了解以下内容：
- en: Shell globbing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell通配符
- en: Redirecting and piping
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向和管道
- en: The `grep`, `sed`, and `awk` commands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep`、`sed`和`awk`命令'
- en: Navigating files and folders in a Linux system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux系统中导航文件和文件夹
- en: Introducing the command line
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍命令行
- en: In this section, you'll learn how to run Linux command-line programs and what
    the basic structure of the command line is. You will also learn what program options
    and arguments are and why they are important for customizing your commands.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何运行Linux命令行程序以及命令行的基本结构是什么。您还将了解程序选项和参数以及它们对自定义命令的重要性。
- en: When we say the Linux command line, what we really mean is the **shell**. It's
    important to know that the shell is not the same as a terminal emulator. A Terminal
    is a screen or window that lets you access a Linux server's input and output.
    A shell is just a program that runs on the server as does any other command and
    which awaits, interprets, processes, executes, and responds to commands typed
    in by the user.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说Linux命令行时，我们真正指的是**shell**。重要的是要知道shell不同于终端仿真器。终端是一个屏幕或窗口，让您访问Linux服务器的输入和输出。shell只是在服务器上运行的一个程序，就像任何其他命令一样，它等待、解释、处理、执行和响应用户输入的命令。
- en: 'First, open up a new terminal emulator and log in to your CentOS 7 server by
    using SSH, as we learned in the [Chapter 1](16d0169d-0972-43c0-b5e4-228d9b8956ad.xhtml),
    *Introduction to Linux*. Log in using your normal user account, which you set
    up during installation, because, as we have said before, never work with the root
    user unless you have to. In my example, the username is `olip`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开一个新的终端仿真器，并使用SSH登录到您的CentOS 7服务器，就像我们在[第1章](16d0169d-0972-43c0-b5e4-228d9b8956ad.xhtml)中学到的那样，*Linux简介*。使用您在安装过程中设置的普通用户账户登录，因为正如我们之前所说的，除非必须，永远不要使用root用户。在我的示例中，用户名是`olip`：
- en: '![](img/3973123b-3647-47cd-963a-91fd8ea28937.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3973123b-3647-47cd-963a-91fd8ea28937.png)'
- en: After successfully logging in to your server, an important program has been
    started automatically, which is called the shell, and which have been using this
    whole time. In fact, when we talk about the Linux Terminal, what we are really
    speaking of is the shell. There exist several shell variants; on CentOS 7 we are
    using **Bash**, or the **Bourne Again Shell**, by default. When the shell is started,
    the first thing you will notice is the line ending with the dollar sign ($), which
    is called the shell prompt.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 成功登录到服务器后，一个重要的程序已经自动启动，这个程序叫做shell，我们一直在使用它。事实上，当我们谈论Linux终端时，我们真正说的是shell。存在几种shell变体；在CentOS
    7上，默认使用**Bash**，或者**Bourne Again Shell**。当shell启动时，您会注意到以美元符号($)结尾的行，这被称为shell提示符。
- en: 'In our example, it gives us some useful information: the login username and
    the current directory we''re on. The tilde is a special character and it means
    home directory, which is the default directory when logging in. After the shell
    prompt comes the cursor, which is the underscore character, and this is where
    the user can type in the text that then gets processed and executed by the shell.
    But user input will only get processed and executed by the shell when the input
    has been ended with the *Enter* key. If you make any type of mistake, just hit
    the backspace key to delete the last character. The first useful command we will
    learn in this chapter is how to log out of the system.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，它为我们提供了一些有用的信息：登录用户名和当前所在的目录。波浪号是一个特殊字符，表示家目录，这是登录时的默认目录。在shell提示符之后是光标，即下划线字符，这是用户可以输入文本的地方，然后由shell处理和执行。但是只有当输入以*Enter*键结束时，用户输入才会被shell处理和执行。如果出现任何错误，只需按下退格键删除最后一个字符。我们将在本章学习的第一个有用的命令是如何退出系统。
- en: 'On the Linux Terminal, this command logs out the current user and goes back
    to the login screen:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux终端上，这个命令注销当前用户并返回到登录屏幕：
- en: Open the Linux Terminal and type the `logout` command and after that press the
    *Enter* key.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Linux终端，输入`logout`命令，然后按*Enter*键。
- en: However, if you perform the same operation while using an SSH connection, it
    has the same effect as the `exit` command that we learned about in the previous
    chapter.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，如果您在使用SSH连接时执行相同的操作，它的效果与我们在上一章学到的`exit`命令相同。
- en: Let's try to log in again to the CentOS server.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次尝试登录到CentOS服务器。
- en: 'Let''s try out a simple command; type `date` and press the *Enter* key. This
    is a command that prints out the current date-time value:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一个简单的命令；输入`date`并按下*Enter*键。这是一个打印当前日期时间值的命令：
- en: '![](img/997fd978-1da6-461b-a240-4087ce52aff9.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/997fd978-1da6-461b-a240-4087ce52aff9.png)'
- en: As you can see, if the shell has finished executing a specific command and is
    ready to accept new input by the user, a new shell prompt will appear in a new
    line marking its readiness. Now, type `cal` and press *Enter*. This command prints
    out a nice table view of the current month.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，如果shell已经执行完特定命令并准备接受用户的新输入，新的shell提示符将出现在新行中标志着它的准备就绪。现在，输入`cal`并按*Enter*。这个命令打印出当前月份的一个漂亮的表格视图。
- en: If the first character of any command types is prepended in the shell with the
    hash key, the command will not be executed when pressing the *Enter* key.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何命令类型的第一个字符在shell中以井号键前置，当按下*Enter*键时，该命令将不会被执行。
- en: A typical Linux system such as CentOS 7 contains hundreds of different commands
    included in the default installation. If you could only type in the pure commands
    and nothing more, our work in the shell would be very limited and static and you
    would not be able to work properly at all. So, we need a way to customize our
    commands or change the default behavior during execution, feeding them further
    information. But how can we do that?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的Linux系统，比如CentOS 7，包含了默认安装的数百个不同的命令。如果你只能输入纯命令而没有其他东西，我们在shell中的工作将非常有限和静态，你将无法正常工作。因此，我们需要一种方法来自定义我们的命令或在执行过程中改变默认行为，提供更多的信息。但是我们该如何做呢？
- en: 'Enter the power of command-line options and arguments. First, we need to discuss
    the general structure of a command in the shell, which in its most simple form
    is `COMMANDNAME OPTIONS ARGUMENTS`. The command name is the name of the command
    to be started. Be careful, in Linux command names are case sensitive. Type `whoami`
    and then press *Enter*. This command will print out the name of the current user
    working in the shell. As Linux is case sensitive, this command cannot be started
    using uppercase letters, such as each version refers to a different command. Here,
    we will also see why the shell is such a useful program. It not only listens and
    interprets commands, but it also shows you helpful error messages when something
    goes wrong, such as a command cannot be found in the system. Normally, on Linux
    all standard Bash script commands are written in lowercase. To get a list of some
    of the available commands, type `ls /bin`. Now, let''s move on to one of the most
    fundamental commands available in the shell. Type `ls` and press the *Enter* key.
    This command lists files in a directory. If no further information is given, it
    prints out all the visible files in the directory that we are currently in at
    the moment:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 进入命令行选项和参数的力量。首先，我们需要讨论shell中命令的一般结构，它最简单的形式是`COMMANDNAME OPTIONS ARGUMENTS`。命令名称是要启动的命令的名称。注意，在Linux中命令名称是区分大小写的。输入`whoami`然后按*Enter*。这个命令将打印出在shell中工作的当前用户的名称。由于Linux是区分大小写的，这个命令不能使用大写字母启动，比如每个版本都指代不同的命令。在这里，我们也将看到为什么shell是一个如此有用的程序。它不仅听取和解释命令，而且在出现问题时还会显示有用的错误消息，比如系统中找不到一个命令。通常，在Linux上所有标准的Bash脚本命令都是用小写字母编写的。要获取一些可用命令的列表，输入`ls
    /bin`。现在，让我们继续讨论shell中可用的最基本的命令之一。输入`ls`并按*Enter*键。这个命令列出目录中的文件。如果没有提供更多的信息，它将打印出我们当前所在目录中所有可见的文件：
- en: '![](img/df3b85c2-095a-4ffe-97cb-0be15e3cad29.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df3b85c2-095a-4ffe-97cb-0be15e3cad29.png)'
- en: As you can see, a shell command can also contain options and arguments that
    are appended to the command name and separated from it using spaces. This means
    if you want to provide at least one option or argument, then we need at least
    one space after the command name. First, let's talk about command-line options.
    Their aim is to influence the behavior of a command. They are also called **switches**
    or **flags**. There is no obligatory standard, but normally any single-character
    command-line option starts with a single dash, whereas longer option names have
    two dash symbols. Also, if you want to provide multiple single-character command-line
    options, for most standard Linux commands you can just write them in series. It
    is good to know that single-character command-line options are often abbreviations
    describing their meaning: `-d` could stand for directory, `-x` for exclude, and
    so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，一个shell命令也可以包含附加到命令名称的选项和参数，并且用空格分隔开。这意味着如果你想提供至少一个选项或参数，那么在命令名称后至少需要一个空格。首先，让我们谈谈命令行选项。它们的目的是影响命令的行为。它们也被称为**开关**或**标志**。没有强制性的标准，但通常任何单字符命令行选项以单破折号开头，而较长的选项名称有两个破折号符号。此外，如果你想提供多个单字符命令行选项，对于大多数标准的Linux命令，你可以直接连续写它们。值得知道的是，单字符命令行选项通常是描述它们含义的缩写：`-d`可能代表目录，`-x`代表排除，等等。
- en: 'We already know that the `ls` command without any further options gives us
    a list of all the files in the current directory. If you type `ls -a` and press
    *Enter*, you just run your first command with the command-line option. The `a`
    switch stands for all and this influences the default behavior `ls` by giving
    you a list of all files, including the hidden ones, which in Linux start with
    the leading dash in the current directory. Now, let''s type `ls -alth` and press
    the *Enter* key to see the result:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道，`ls`命令没有任何其他选项时会给我们当前目录中所有文件的列表。如果你输入`ls -a`并按*Enter*，你就运行了你的第一个带命令行选项的命令。`a`开关代表所有，这通过给你一个包括隐藏文件在内的所有文件的列表来影响`ls`的默认行为，这些文件在Linux中以当前目录中的前导破折号开头。现在，让我们输入`ls
    -alth`并按*Enter*键来看结果：
- en: '![](img/7794f997-1e4a-49d5-b10a-3d1e7ef60280.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7794f997-1e4a-49d5-b10a-3d1e7ef60280.png)'
- en: This influences the command's default behavior even more by using the `-a` flag
    that we just discussed, and also using the `-l` switch, which stands for **list**,
    and it prints all the files in a list format, including more detailed information,
    such as the creation date. The `-t` switch stands for **time** and it sorts the
    file list by modification date with the newest entries appearing first, and `-h`
    stands for **human readable** and it will print out the file size in a more readable
    form using **MB** instead of bytes for the file size.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过使用我们刚刚讨论的`-a`标志更进一步影响了命令的默认行为，并且还使用了`-l`开关，代表**列表**，它以列表格式打印出所有文件，包括更详细的信息，比如创建日期。`-t`开关代表**时间**，它按修改日期对文件列表进行排序，最新的条目首先出现，`-h`代表**人类可读**，它将以更易读的形式打印出文件大小，使用**MB**而不是字节来表示文件大小。
- en: Often, command-line options can have arguments bound to them. In addition to
    options, we have command-line arguments, which are also called **parameters**.
    This is any dynamic or free-text piece of information that is not an option, and
    which gets fed into the command when it starts. Typical examples are filenames
    or directories that the command wants to process during execution. Arguments are
    also divided by *spaces*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，命令行选项可以有与之绑定的参数。除了选项，我们还有命令行参数，也称为**参数**。这是在命令启动时输入的任何动态或自由文本信息，它不是选项，并在执行期间被传递给命令。典型的例子是命令在执行期间想要处理的文件名或目录。参数也由*空格*分隔。
- en: 'Type `echo Hello` and press *Enter*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 键入`echo Hello`并按*Enter*键：
- en: '![](img/d5263ce5-9a0b-4a9f-b0c1-1a1565fec613.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5263ce5-9a0b-4a9f-b0c1-1a1565fec613.png)'
- en: 'In the previous command, `Hello` is an argument for the `echo` command and
    not an option. The `echo` command is one of the most fundamental shell commands.
    It just prints the arguments given to it back to the command line. As we will
    see, this is ideal for testing shell features such as **globbing**, which we will
    learn more about later in this section. Now let''s type `ls -al /boot /var` in
    the Terminal and press *Enter* to see a result similar to the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个命令中，`Hello`是`echo`命令的参数，而不是选项。`echo`命令是最基本的shell命令之一。它只是将给定的参数打印回命令行。正如我们将看到的，这对于测试shell功能非常理想，比如**通配符**，我们稍后将在本节中学到更多关于它的知识。现在让我们在终端中键入`ls
    -al /boot /var`并按*Enter*键，以查看类似以下的结果：
- en: '![](img/1f8ccccd-1e52-4272-afeb-d3155c28a548.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f8ccccd-1e52-4272-afeb-d3155c28a548.png)'
- en: In this example, for the first time we used command-line options and arguments.
    The command `ls` is executed with the `a` and `l` options, and the arguments are
    `/boot` and `/var`. This will print out all the files, including hidden ones,
    in a detailed list view in the `/boot` and `/var` directories. As mentioned before,
    oftentimes arguments are bound to specific options, for example, the `tar` command,
    which we will discuss later. When you need to process an input file, you have
    to specify directly after the `-f` option and nowhere else or, in short, the input
    file argument is bound to the `-f` option. This approach is incorrect and will
    produce errors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们第一次使用了命令行选项和参数。`ls`命令使用`a`和`l`选项执行，并且参数是`/boot`和`/var`。这将打印出`/boot`和`/var`目录中的所有文件，包括隐藏文件，以详细列表视图显示。如前所述，通常情况下参数与特定选项绑定，例如`tar`命令，我们稍后会讨论。当您需要处理输入文件时，您必须直接在`-f`选项之后指定，而不是其他地方，或者简而言之，输入文件参数与`-f`选项绑定。这种方法是不正确的，会产生错误。
- en: File globbing
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件通配符
- en: In this section, you will learn how shell expansion works and how we can use
    file globbing to make our lives easier when using commands that deal with a lot
    of input files. We will discuss all existing and available shell globbing character
    classes and show you important use cases and examples for each of them. When working
    with commands that use file or directory names as arguments, such as the `ls`
    command, it is very helpful to learn about file and directory globbing. These
    are special characters typed in the shell that behave differently than regular
    characters. All globbing characters are going to be replaced by the shell with
    a list of files matching the characters' pattern right before any command can
    use them as parameters. It's a notation to simplify working with files, especially
    when dealing with a large number of files that you need to type and process. Using
    file globbing can save you a lot of time, by not doing repetitive work, because
    multiple files can be addressed by a single-character. The concept of replacing
    such special characters with a group list of files by the shell is also called
    **shell expansion**. There are several globbing characters available and we can
    use them to create very sophisticated file list selections.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您将学习shell扩展的工作原理，以及我们如何使用文件通配符来使我们在使用处理大量输入文件的命令时更加轻松。我们将讨论所有现有和可用的shell通配符字符类，并为每个字符类展示重要的用例和示例。在处理将文件或目录名称作为参数的命令时，比如`ls`命令，学习文件和目录通配符非常有帮助。这些是在shell中键入的特殊字符，其行为与普通字符不同。所有通配符字符都将在任何命令使用它们作为参数之前被shell替换为与字符模式匹配的文件列表。这是一种简化处理文件的表示法，特别是在处理大量需要输入和处理的文件时。使用文件通配符可以节省大量时间，因为多个文件可以由一个字符表示。将这些特殊字符替换为文件组列表的概念也称为**shell扩展**。有几个可用的通配符字符，我们可以使用它们来创建非常复杂的文件列表选择。
- en: Globbing characters are the wildcard, the question mark, the exclamation mark,
    the square brackets, and the dash. Although they look and behave very similarly,
    shell globbing and regular expressions are not the same, and both concepts are
    not interchangeable. This means you cannot apply regular expressions for globbing
    files and vice versa. We will learn more about regular expressions in an upcoming
    section in this chapter. The most important globbing character is the wildcard
    character. It will match any number of any character filename available in a specific
    directory, with one exception, it does not match files beginning with a dot, which
    you may have already noticed when looking at hidden files in Linux. What happens
    if you use the wildcard character with a file beginning with a dot and press *Enter*?
    Let's look at an example. As we showed before, we can use the `echo` command to
    print out random text in the Terminal.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符字符是通配符、问号、感叹号、方括号和破折号。尽管它们看起来行为非常相似，但shell通配符和正则表达式并不相同，这两个概念也不可互换。这意味着您不能将正则表达式应用于通配文件，反之亦然。我们将在本章的后续部分中学习更多关于正则表达式的知识。最重要的通配符字符是通配符字符。它将匹配特定目录中任意数量的任何字符文件名，有一个例外，它不匹配以点开头的文件，这一点您可能已经注意到了在Linux中查看隐藏文件时。如果您使用通配符字符与以点开头的文件并按*Enter*键会发生什么？让我们看一个例子。正如我们之前展示的，我们可以使用`echo`命令在终端中打印出随机文本。
- en: 'Let''s first change to a different directory. Type `cd /etc` and press *Enter*.
    Now, type `echo *` and press *Enter*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先切换到另一个目录。输入`cd /etc`并按*Enter*。现在，输入`echo *`并按*Enter*：
- en: '![](img/f1dc0322-b8d6-41ba-8e8c-ae951eb1e8f7.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1dc0322-b8d6-41ba-8e8c-ae951eb1e8f7.png)'
- en: 'In the previous command, in the first step, the shell replaces the wildcard
    character with a list of files in the current directory and prints them separated
    by whitespace that follows the rule, and then shows all files and directories
    that contain any character, but it doesn''t show files that start with a dot.
    Using `echo` is the perfect way to test whether your globbing patterns match exactly
    what you want before applying them as real command-line arguments. You can mix
    the wildcard character with any other static character to make a file filter more
    stringent. Type `echo pa*` and press *Enter*. This will match all files starting
    with a lowercase `p` followed by `a`, followed by any other character. Or type
    `echo *.d` and press *Enter*. This example finds all files that have the `.d` filename
    extension:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个命令中，在第一步中，shell将通配符替换为当前目录中的文件列表，并按照规则用空格分隔打印出来，然后显示包含任何字符的所有文件和目录，但不显示以点开头的文件。使用`echo`是测试您的通配模式是否完全匹配您想要的内容的完美方式，然后将其应用为真实的命令行参数。您可以将通配符与任何其他静态字符混合使用，使文件过滤更严格。输入`echo
    pa*`并按*Enter*。这将匹配所有以小写`p`开头，后跟`a`，后跟任何其他字符的文件。或者输入`echo *.d`并按*Enter*。这个例子找到所有具有`.d`文件扩展名的文件：
- en: '![](img/3edc1a0f-159c-4235-9b08-eb72bf4c4b43.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3edc1a0f-159c-4235-9b08-eb72bf4c4b43.png)'
- en: You can even define a more stringent pattern, for example, by typing `echo li*.conf`
    and pressing *Enter*. This globbing pattern will match all files in your current
    directory starting with a lowercase `l`, followed by `i`, followed by any other
    character, but only those that have a `.conf` filename extension. We can use file
    globbing with any command that accepts an option list of files as arguments, such
    as the `ls` command.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以定义一个更严格的模式，例如，输入`echo li*.conf`并按*Enter*。这个通配模式将匹配当前目录中以小写`l`开头，后跟`i`，后跟任何其他字符的所有文件，但只有那些具有`.conf`文件扩展名的文件。我们可以在接受文件选项列表作为参数的任何命令中使用文件通配，比如`ls`命令。
- en: For example, using the globbing pattern, `li *.conf`, as a command-line argument
    for the `ls` command, gives us a detailed list of all the files matched by this
    pattern. Again, it's important to understand that we are not feeding the globbing
    pattern into the `ls` command and `ls` is not expanding files internally during
    the execution of the program. The truth is that a shell in the first step expands
    the wildcard character to a list of files and then feeds this list as arguments
    to the `ls` command.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用通配模式`li *.conf`作为`ls`命令的命令行参数，会给我们一个详细的列表，列出了这个模式匹配的所有文件。同样，重要的是要理解，我们并没有将通配模式输入`ls`命令，`ls`在程序执行期间也不会内部扩展文件。事实上，shell在第一步中将通配符扩展为文件列表，然后将此列表作为`ls`命令的参数。
- en: We will use the `ls -d` option to not show directory content, which it does
    by default; this is because shell globbing doesn't differentiate between files
    and directories.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ls -d`选项来不显示目录内容，默认情况下会显示；这是因为shell通配不区分文件和目录。
- en: 'Type `ls -d rc?.d` in the Terminal. This will get you a list of all the files
    that have only a random character as the third character. Next, type in the `ls
    -d krb5.conf??` command, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中输入`ls -d rc?.d`。这将为您列出所有只有一个随机字符作为第三个字符的文件。接下来，按照以下方式输入`ls -d krb5.conf??`命令：
- en: '![](img/c7c97ed5-ae3a-47ee-bf3a-1ec2eb4c6d25.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7c97ed5-ae3a-47ee-bf3a-1ec2eb4c6d25.png)'
- en: 'As you can see, the question mark can also be used multiple times. This will
    get all files that have two random characters at the extension and only these
    files. The final globbing characters that we will learn about are the square brackets,
    which define ranges of allowed characters at a specific position, for example,
    type `ls -l sub[ug]id`. This will expand to a list of all the files starting with
    `sub` and having either `u` or `g` as the fourth character, followed by the word
    `id`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，问号也可以多次使用。这将获取所有具有扩展名的两个随机字符的文件，只有这些文件。我们将要学习的最后一种通配符是方括号，它定义了特定位置上允许字符的范围，例如，输入`ls
    -l sub[ug]id`。这将扩展为以`sub`开头并且第四个字符为`u`或`g`，后跟`id`的所有文件列表：
- en: '![](img/5dce98d6-f011-4606-99a5-9e0e4e1effdf.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5dce98d6-f011-4606-99a5-9e0e4e1effdf.png)'
- en: 'As we will learn next, we can mix the brackets with other globbing characters.
    Type the following `ls` command argument:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下面学到的，我们可以将括号与其他通配符字符混合使用。输入以下`ls`命令参数：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This expands to a list of all the mail programs in the `bin` directory with
    and without capitalization. We will learn more about the `bin` directory later.
    You can also use numbers for ranges; type the `ls -d rc[01234].d` command in the
    Terminal:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将扩展为`bin`目录中所有邮件程序的列表，包括大小写。我们稍后将学习更多关于`bin`目录的知识。您还可以使用数字来表示范围；在终端中输入`ls -d
    rc[01234].d`命令：
- en: '![](img/91788f1c-35a5-43be-9bcb-aaa224664a62.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91788f1c-35a5-43be-9bcb-aaa224664a62.png)'
- en: In our example, this would be expanded to `rc0.d`, `rc1.d`, and so on. If you
    have consecutive ranges of numbers or letters, as in the last example, you can
    also use the minus symbol to shorten your globbing expression even more. For example,
    type `ls /bin/m[a-z] [a-z]`. This would give us all the three-letter command names
    in the `bin` directory starting with `m`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，这将扩展为`rc0.d`，`rc1.d`等。如果您有连续的数字或字母范围，就像在最后一个例子中一样，您还可以使用减号来进一步缩短您的通配表达式。例如，输入`ls
    /bin/m[a-z] [a-z]`。这将给我们`bin`目录中以`m`开头的所有三个字母命令名称。
- en: 'There''s another helpful globbing character, which is the exclamation mark,
    and it can be used in brackets to define something that must not be in expansion
    results, for example, `ls -d rc[!256].d`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个有用的通配符，即感叹号，它可以在括号中使用，定义在扩展结果中不得出现的内容，例如，`ls -d rc[!256].d`：
- en: '![](img/485cd3dd-c149-4cfb-b3fc-1700138933a5.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/485cd3dd-c149-4cfb-b3fc-1700138933a5.png)'
- en: This says that we don't want to expand files that have a `2`, `5`, or `6` as
    the third character. This also works for consecutive ranges within brackets, for
    example, `ls -d rc[!3-6].d`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示我们不希望扩展第三个字符为`2`、`5`或`6`的文件。这也适用于括号内的连续范围，例如，`ls -d rc[!3-6].d`。
- en: 'You have already learned three things about hidden files in Linux. They start
    with a dot in the filename, the wildcard globbing character ignores them, and
    `ls`, by default, doesn''t show them; therefore, they''re named hidden. To show
    all hidden files in your home directory, we use the `-a` option with the `ls`
    command. You see that there are several hidden files in your home directory, for
    example, the `.bashrc` file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学到了关于Linux中隐藏文件的三件事。它们的文件名以点开头，通配符通配字符会忽略它们，`ls`默认情况下不显示它们；因此，它们被称为隐藏。要显示主目录中的所有隐藏文件，我们使用`ls`命令的`-a`选项。您会看到主目录中有几个隐藏文件，例如`.bashrc`文件：
- en: '![](img/873ee66e-2631-4a6b-909f-71cd386f56a8.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/873ee66e-2631-4a6b-909f-71cd386f56a8.png)'
- en: 'But there are also two other special files in your directory with the name
    [`.`] and [`..`], we will learn what these two special files are later on this
    chapter. What do you need to type if you want to display only the hidden files
    in the current directory without those two dot files? With all the knowledge you
    now have, this should be easy to accomplish, and the next line should now make
    sense to you. So, type `ls .[!.]*`. But this will also list directory contents.
    To not list directory contents, use the `ls -d` flag, so the command will be `ls
    -d .[!.]*`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在您的目录中还有两个特殊文件，名为[`.`]和[`..`]，我们将在本章后面学习这两个特殊文件是什么。如果您只想显示当前目录中的隐藏文件而不包括这两个点文件，您需要输入什么？有了您现在拥有的所有知识，这应该很容易实现，下一行现在应该对您有意义。因此，输入`ls
    .[!.]*`。但这也会列出目录内容。为了不列出目录内容，使用`ls -d`标志，因此命令将是`ls -d .[!.]*`：
- en: '![](img/40f6e6de-d304-4168-ba3d-de3df85e21d7.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/40f6e6de-d304-4168-ba3d-de3df85e21d7.png)'
- en: 'In this section, we discussed everything there is to know about Linux shell
    globbing. Remember, the wildcard character matches every filename character in
    any position. It''s very important that there is one exception to this rule: it
    does not match filenames starting with a dot, which are called hidden files in
    Linux. The question mark does the same, but only in a single position; it also
    doesn''t match filenames with the leading dot. The brackets match specific characters
    in a single position defined between the brackets. When having consecutive permitted
    characters, you can also use the dash symbol. To match everything except a set
    of characters at a specific position, use the exclamation mark in brackets.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了关于Linux shell通配符的一切。请记住，通配符字符匹配任何位置的每个文件名字符。对于这个规则有一个例外是非常重要的：它不匹配以点开头的文件名，这在Linux中称为隐藏文件。问号也是如此，但只在单个位置上；它也不匹配以点开头的文件名。括号在括号之间定义的单个位置匹配特定字符。当具有连续允许字符时，您还可以使用破折号符号。要匹配特定位置上除了一组字符之外的所有内容，请在括号中使用感叹号。
- en: Quoting commands
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用命令
- en: 'As we learned in the previous section, the shell has a list of special characters
    that have a special meaning in the shell and trigger some functionality, such
    as using the wildcard character as filenames. But there are even more special
    characters than the ones we showed you before. If you want to work with such special
    characters, for example, using filenames that contain question mark symbols, which
    are valid filenames, you have a problem, as the shell always first tries to apply
    special actions to special characters, so they will not work as normal filename
    characters. The solution here is to disable all special meanings of such characters
    using various approaches, such as quoting, so that we can treat them as any other
    normal literal character. As you now know, in the Linux Bash shell, there are
    some special characters, such as `* # [ ] . ~ ! $ { } < > | ? & - / , "` which
    have special meaning to the shell and get treated differently than normal characters.
    But what if you want to use a filename or directory as an argument that has one
    such special character in its name? Also, how do you treat filenames with spaces
    in the name, which can also be seen as special characters?'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们在前一节中学到的，shell有一系列特殊字符，在shell中具有特殊含义并触发某些功能，例如使用通配符字符作为文件名。但是，特殊字符比我们之前向您展示的还要多。如果您想使用包含问号符号的文件名等特殊字符，您将遇到问题，因为shell总是首先尝试对特殊字符应用特殊操作，因此它们不会像正常的文件名字符一样工作。解决方案是使用各种方法禁用这些字符的所有特殊含义，例如引用，以便我们可以将它们视为任何其他普通的文字字符。正如您现在所知，在Linux
    Bash shell中有一些特殊字符，例如`* # [ ] . ~ ! $ { } < > | ? & - / , "`，它们对shell具有特殊含义，并且与普通字符不同。但是，如果您想要使用包含其中一个特殊字符的文件名或目录作为参数，该怎么办？另外，如何处理名称中带有空格的文件名，这也可以被视为特殊字符？'
- en: 'For example, if you have a file in your directory called `My private Documents.txt`,
    how can you use it as a command-line argument? If you use it with the `ls` command,
    since the space is the command-line argument delimiter, the shell is not able
    to see it as one distinct file. Rather, it thinks you provided three different
    files called `My`, `private`, and `Documents.txt`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您的目录中有一个名为`My private Documents.txt`的文件，您如何将其用作命令行参数？如果您将其与`ls`命令一起使用，由于空格是命令行参数分隔符，shell
    无法将其视为一个独立的文件。相反，它认为您提供了三个名为`My`、`private`和`Documents.txt`的不同文件：
- en: '![](img/a27557b4-d315-4bc3-a904-ec2d1f82c080.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a27557b4-d315-4bc3-a904-ec2d1f82c080.png)'
- en: 'Also, what happens if you want to use a file containing special characters
    such as the exclamation mark, for example, if you''ve got a file called `!super!file!.txt`,
    which is a valid filename in Linux? If we try to use this filename as a command-line
    argument parameter, it cannot find the file by this name because it contains special
    characters that are treated in a different way by the shell. Or what happens if
    you want to `echo` some text with more than one whitespace between the words?
    As we have learned, the space is also a special shell character that delimits
    command-line arguments:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果你想使用包含特殊字符的文件，比如感叹号，例如，如果你有一个名为`!super!file!.txt`的文件，在Linux中这是一个有效的文件名？如果我们尝试将这个文件名作为命令行参数使用，它无法找到这个名称的文件，因为它包含特殊字符，而shell以不同的方式处理它们。或者如果你想要`echo`一些文本，单词之间有多个空格？正如我们所学到的，空格也是一个特殊的shell字符，用于分隔命令行参数。
- en: '![](img/9d5efe93-75b1-4979-a3a8-c157d1b5f47f.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d5efe93-75b1-4979-a3a8-c157d1b5f47f.png)'
- en: In the examples just shown, we need to find a way to disable shell expansion
    and to stop the shell from processing special characters. There are two easy ways
    to disable shell expansion in arguments, and these are quoting and escaping. Putting
    special characters and space into single quotes will prevent shell expansion and
    treat all possible chars, including the special ones, as normal alphanumeric characters.
    In single quotes, nothing ever gets shell expanded; for most special characters,
    this also works in double quotes with a few exceptions to this rule.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '在刚才展示的示例中，我们需要找到一种方法来禁用shell扩展并停止shell处理特殊字符。在参数中禁用shell扩展有两种简单的方法，即引用和转义。将特殊字符和空格放入单引号中将防止shell扩展并将所有可能的字符，包括特殊字符，视为普通的字母数字字符。在单引号中，任何东西都不会被shell扩展；对于大多数特殊字符，这也适用于双引号，但有一些例外。 '
- en: 'In the following screenshot, two examples work, but others don''t and they
    get special treatment:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，两个示例有效，但其他示例不起作用，它们会得到特殊处理：
- en: '![](img/0bbdb7b6-ba43-4bd5-aa7e-292f3ef3694c.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0bbdb7b6-ba43-4bd5-aa7e-292f3ef3694c.png)'
- en: 'Also, as shown in previous screenshot, the dollar sign stays special as well,
    and this is often used if you need to shell expand environment variables while
    quoting. As said before, single quotes will disable all special characters. You
    can do the same by using the backslash key, which, in the shell, is also called
    the **escape character **and which does almost exactly the same as quotes, but
    will only disable shell expansion and every special meaning for the next, and
    only the next, immediate character after the backslash key:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如前面的截图所示，美元符号也保持特殊，这经常用于在引用时需要shell扩展环境变量。如前所述，单引号将禁用所有特殊字符。你可以通过使用反斜杠键来做到同样的效果，在shell中，它也被称为**转义字符**，几乎与引号完全相同，但它只会禁用shell扩展和下一个特殊含义，只有在反斜杠键之后的下一个字符：
- en: '![](img/cbb41cd7-c4ec-4108-adc7-56267743bd0e.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbb41cd7-c4ec-4108-adc7-56267743bd0e.png)'
- en: As you can see, it's basically the same. Often, the escape character is used
    to create clear multi-line command-line calls by escaping or disabling the new
    line character in each line. Another use case for the backslash character is to
    use it when working with arguments such as files starting with the dash, as this
    often confuses the shell because it interprets any dash symbol as an option.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，基本上是一样的。通常，转义字符用于通过在每一行中转义或禁用换行字符来创建清晰的多行命令行调用。反斜杠字符的另一个用例是在处理以破折号开头的文件等参数时使用它，因为这经常会让shell感到困惑，因为它会将任何破折号符号解释为选项。
- en: For example, if we want to create an empty file named `-dashy.txt`, this will
    not work, as the command line is confused and thinks the filename is a list of
    single-character options. Here, we can use the escape character to get rid of
    the special meaning of the dash symbol. For arguments starting with the dash,
    some commands, such as `ls` or `touch`, also have another great feature, the double
    dash, which marks the end of the option list. So, to treat your dashy file as
    an argument instead of an option, we can also type the `nano -dashy.txt` or `touch
    '-dashy.txt'` command.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想创建一个名为`-dashy.txt`的空文件，这是行不通的，因为命令行混淆了并认为文件名是一个单字符选项列表。在这里，我们可以使用转义字符来摆脱破折号符号的特殊含义。对于以破折号开头的参数，一些命令，如`ls`或`touch`，还有另一个很棒的功能，双破折号，它标志着选项列表的结束。因此，为了将您的dashy文件作为参数而不是选项进行处理，我们还可以输入`nano
    -dashy.txt`或`touch '-dashy.txt'`命令。
- en: As you have learned, there exists a number of special characters in the shell
    that have a special meaning, for example, the shell globbing characters or the
    exclamation mark. What if you want to use these characters, not to shell expand
    the list of files, but in a filename or other literal command argument? You need
    to disable them. Using single quotes will disable all special characters and is
    the preferred way when working in the shell; it works for almost all everyday
    quoting use cases. When using double quotes, most special characters get disabled,
    but not all, such as the shell expansion of environment variables. So, this approach
    is very useful for text creation that contains normal characters and values of
    environment variables. The backslash or escaping character will disable any special
    meaning of the following character only.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经学到的，shell中存在许多特殊字符，例如shell通配符字符或感叹号。如果你想使用这些字符，而不是扩展文件列表，而是在文件名或其他文字命令参数中使用它们，该怎么办？你需要禁用它们。使用单引号将禁用所有特殊字符，并且在shell中工作时是首选的方式；它适用于几乎所有日常引用用例。在使用双引号时，大多数特殊字符会被禁用，但不是全部，比如环境变量的shell扩展。因此，这种方法对包含普通字符和环境变量值的文本创建非常有用。反斜杠或转义字符将仅禁用接下来的字符的任何特殊含义。
- en: Getting help
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取帮助
- en: Before we can start teaching you how to get help using the various forms of
    documentation available for Linux commands, we first have to learn how to read
    the default command syntax documentation. Most of the provided standard shell
    commands in Linux follow a uniform format describing their usage. Afterward, we
    will show you how to get help.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始教您如何使用Linux命令的各种文档形式获取帮助之前，我们首先必须学习如何阅读默认命令语法文档。Linux中提供的大多数标准shell命令都遵循描述其用法的统一格式。之后，我们将向您展示如何获取帮助。
- en: When working with the Linux command line, getting help and looking up information
    and documentation is very important because the command line can be very complex
    and nobody knows and can remember everything. On every Linux system, there are
    several ways available to get help, depending on the kind of level of information
    you need to know. In this section, we will tap into the different sources of documentation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Linux命令行时，获取帮助并查找信息和文档非常重要，因为命令行可能非常复杂，没有人知道并且能记住一切。在每个Linux系统上，有几种可用的方式可以获取帮助，具体取决于您需要了解的信息级别。在本节中，我们将利用不同的文档来源。
- en: In a previous section, you already learned the general structure of Bash shell
    commands and everything you need to know about command options and parameters
    in general, but oftentimes this is not enough. For a lot of shell commands, the
    specific structure of options and arguments are very complex. A post can be bound
    to a specific position, and some of them can be mandatory or optional. Also, options
    and arguments can be interdependent. In Linux, a description of a command's command-line
    format, including arguments and options, is called **command usage** or **syntax
    of a command**. Learning to read a command's usage is one of the most essential
    skills that a Linux beginner needs to learn when starting. The standard way to
    describe command usage in Linux is the command name, square brackets that contain
    text, dots, and text, for example, `CommandName [XXX]... TEXT`. Square brackets
    mean that the content within is optional. Three dots mean that the expression
    right before the dots can be repeated multiple times or only once. Any word without
    square brackets is mandatory.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，您已经学习了Bash shell命令的一般结构以及您需要了解的关于命令选项和参数的一切，但通常这是不够的。对于许多shell命令，选项和参数的特定结构非常复杂。一个命令可以绑定到特定位置，其中一些可能是强制性的或可选的。此外，选项和参数可以相互依赖。在Linux中，命令的命令行格式描述，包括参数和选项，称为**命令用法**或**命令的语法**。学习阅读命令用法是Linux初学者在开始时需要学习的最基本的技能之一。在Linux中描述命令用法的标准方式是命令名称，包含文本的方括号，点和文本，例如，`CommandName
    [XXX]... TEXT`。方括号表示其中的内容是可选的。三个点表示点之前的表达式可以重复多次或仅一次。没有方括号的任何单词都是强制性的。
- en: 'Take, for example, the general syntax for the `ls` command, which you already
    know how to work with. From the official `ls` manual, it can be read as `ls [OPTION]...
    [FILE]...`; this means that the command to list files has the following usage.
    It starts with the `ls` command name, everything else is in brackets, so all the
    options and arguments are optional, which means you can also execute `ls` without
    providing any further information, just by pressing the *Enter* key. But you can
    also provide multiple options or only one. Also, we can see that the arguments
    are of the `FILE` type, which means a file or directory is needed here at this
    position. You can also provide multiple files or directories, or only one or zero,
    as shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`ls`命令的一般语法，您已经知道如何使用。从官方`ls`手册中，可以读取为`ls [OPTION]... [FILE]...`；这意味着列出文件的命令具有以下用法。它以`ls`命令名称开头，其他所有内容都在括号中，因此所有选项和参数都是可选的，这意味着您也可以只通过按*Enter*键来执行`ls`而不提供任何其他信息。但您也可以提供多个选项或仅一个。此外，我们可以看到参数是`FILE`类型，这意味着在这个位置需要一个文件或目录。您还可以提供多个文件或目录，或者只有一个或零个，如下面的屏幕截图所示：
- en: '![](img/254bdc69-e724-4e5b-a1ce-877a01332fd6.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/254bdc69-e724-4e5b-a1ce-877a01332fd6.png)'
- en: 'As another example, the `copy` command can be run by using the `cp` command
    name followed by zero or multiple options. The syntax of the `cp` command is `cp
    [OPTION]... SOURCE... DEST_DIR`. You can completely skip option, but at least
    one or more source directory and exactly one destination directory are mandatory
    and denoted by the three dots, and you cannot run the command without them. For
    example, running just `cp` without at least two arguments produces the following
    error. Correct usage would be with all options:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是`copy`命令可以通过使用`cp`命令名称后跟零个或多个选项来运行。`cp`命令的语法是`cp [OPTION]... SOURCE...
    DEST_DIR`。您可以完全跳过选项，但至少一个或多个源目录和一个目标目录是强制性的，并由三个点表示，没有它们您无法运行该命令。例如，仅运行`cp`而不提供至少两个参数会产生以下错误。正确的用法应该包括所有选项：
- en: '![](img/1054ecf2-c917-41b4-841b-6e4bfcdb8b17.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1054ecf2-c917-41b4-841b-6e4bfcdb8b17.png)'
- en: Now that we know how to read any standard command syntax or usage, how can we
    actually get help? As we said before, there are several ways available, which
    are command help options, man pages, and full program documentation. Normally,
    all of these three types of help are installed together with the command line
    or program, so it's a very good habit to first try to get help for shell commands
    locally on the same machine where the commands live. This is usually the most
    accurate, reliable, and up-to-date information for every command and should be
    favored before doing internet research or using documentation from another computer
    with a different Linux version or system.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何阅读任何标准命令语法或用法，那么我们如何实际获取帮助呢？正如我们之前所说，有几种可用的方式，即命令帮助选项、man页面和完整的程序文档。通常，所有这三种类型的帮助都与命令行或程序一起安装，因此首先尝试在相同的机器上本地获取shell命令的帮助是一个非常好的习惯。这通常是每个命令的最准确、可靠和最新的信息，并且应该优先于在互联网上进行研究或使用来自具有不同Linux版本或系统的其他计算机的文档。
- en: Often internet solutions found in blogs or forums are too unspecific or plain
    wrong for your specific Linux installation, and should always be used with caution.
    Don't ever blindly copy and paste command snippets from the internet.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在博客或论坛中找到的互联网解决方案对于您特定的Linux安装来说太不具体或纯属错误，应始终谨慎使用。永远不要盲目地从互联网上复制和粘贴命令片段。
- en: Command parameters, options, and features can change over time depending on
    the version and implementation, and they can be very dangerous if applied incorrectly.
    There are hundreds of commands available on Linux and every one of them has a
    different syntax. No one can memorize everything, so first let's start with the
    easiest and fastest way to get quick help for any standard Linux program that
    you already know the name of. In fact, most programs do have a special command-line
    switch that prints out a quick summary of the usage of its options and arguments
    on screen, which in most cases is all you need to know. However, the help or usage
    flag is not standardized on Linux and some commands don't even have this flag
    at all, but most tool developers follow the rule to use the one-character flag
    `-h`, or the long option flag `--help`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 命令参数、选项和功能可能会随着版本和实现的变化而发生变化，如果错误应用，可能会非常危险。Linux上有数百个可用的命令，每个命令都有不同的语法。没有人可以记住所有内容，所以让我们首先从获取任何标准Linux程序的快速帮助的最简单和最快的方法开始。实际上，大多数程序都有一个特殊的命令行开关，可以在屏幕上打印出其选项和参数的快速摘要，这在大多数情况下就是您需要了解的全部内容。但是，在Linux上，帮助或使用标志并不是标准化的，有些命令甚至根本没有这个标志，但大多数工具开发人员遵循使用单字符标志`-h`或长选项标志`--help`的规则。
- en: Not all shell commands have a help option, especially those very easy ones.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有shell命令都有帮助选项，特别是那些非常简单的命令。
- en: Now, if you need more help, you can check out the commands manual, which is
    often called **man pages** by Linux users. Most programs have such documentation.
    For the next few examples, you need to install some additional software using
    your root account's password, which you set up during installation. Man pages
    use lesser navigation, which we will talk about later when we learn how to view
    text files.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您需要更多帮助，您可以查看命令手册，Linux用户通常称之为**man页面**。大多数程序都有这样的文档。对于接下来的几个示例，您需要使用您在安装过程中设置的root帐户密码安装一些额外的软件。man页面使用较少的导航，我们将在学习如何查看文本文件时稍后讨论。
- en: 'The following steps will help you to navigate the manual of any command in
    the Linux Terminal:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您在Linux终端中导航到任何命令的手册：
- en: Open the Terminal and type `man cp` for the `copy` command.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，输入`man cp`以查看`copy`命令的手册。
- en: Use the *Page Up* and *Page Down* keys to scroll the document up and down, and
    slash (*/)* can be used to search text; put any keywords after the slash to search
    for, and then press *Enter*. For example, `/backup`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Page Up*和*Page Down*键向上和向下滚动文档，斜杠（*/*）可用于搜索文本；在斜杠后面放置任何关键字进行搜索，然后按*Enter*。例如，`/backup`。
- en: Press the *End* key to search for the next entry in the man page.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*End*键搜索man页面中的下一个条目。
- en: To quit the search option, use the *Esc* key.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出搜索选项，请使用*Esc*键。
- en: Using lowercase *g*, you can scroll to the top of the page, whereas uppercase
    *G* scrolls to the bottom of the page.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用小写字母*g*，您可以滚动到页面顶部，而大写字母*G*则可以滚动到页面底部。
- en: You can press lowercase *q* to quit the man page.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以按小写字母*q*退出man页面。
- en: 'When you go back to the top of the page, the man page of the `cp` command is
    divided into different topics and headings, as shown in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当您返回页面顶部时，`cp`命令的man页面被分成不同的主题和标题，如下面的截图所示：
- en: '![](img/a16d1618-56c7-43fa-ad49-b81e6ee9cf5f.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a16d1618-56c7-43fa-ad49-b81e6ee9cf5f.png)'
- en: 'Most standard Linux commands follow this type of structure. Also, you can see
    here that some commands can have different usage formats depending on the options
    and arguments given. Now, quit using the *q* key. The `man` command has a very
    useful option, type `man -k` and put any definition of interests as an argument
    afterward. This will search all man pages installed on your system for a certain
    keyword. For example, this is very useful if you forgot a specific command name
    or need general help with the topic or command to use or where to look first.
    If you type the `man -k copy` command, this will print out all the man pages for
    the commands that have something to do with copying:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数标准的Linux命令都遵循这种结构。此外，您可以在这里看到，一些命令可以根据给定的选项和参数具有不同的使用格式。现在，使用*q*键退出。`man`命令有一个非常有用的选项，输入`man
    -k`，然后在参数后面放置任何感兴趣的定义。这将搜索系统上安装的所有man页面，以查找特定关键字。例如，如果您忘记了特定的命令名称，或者需要关于主题或要使用的命令的一般帮助，或者首先查找的位置，这将非常有用。如果您键入`man
    -k copy`命令，这将打印出所有与复制有关的命令的man页面：
- en: '![](img/ad0c03ec-3196-4227-9505-5a66403941ef.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad0c03ec-3196-4227-9505-5a66403941ef.png)'
- en: 'While using the `-k` flag, you also see that the search result writes some
    numbers in the brackets after the man name; these are man page sections, which
    is another very useful concept we need to know. A Linux shell definition, such
    as `printf`, can describe more than only a command-line program, and man pages
    not only describe command-line tools. In our example, `printf` is not only a command-line
    tool that can be started by the shell user, but also the name for a library function
    in the programming language C, which is used by this system. `man` now defines
    a system of section numbers for the type a specific man name is from. Typing `man
    man` will display the manual documentation for the `man` command, and search for
    the keyboard sections, as shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`-k`标志时，您还会看到搜索结果在man名称后面写了一些数字；这些是man页面部分，这是另一个非常有用的概念，我们需要了解。Linux shell定义，例如`printf`，可以描述的不仅仅是命令行程序，man页面不仅仅描述命令行工具。在我们的例子中，`printf`不仅是一个可以由shell用户启动的命令行工具，还是C编程语言中使用的库函数的名称。`man`现在为特定man名称的类型定义了一套部分编号系统。键入`man
    man`将显示`man`命令的手册文档，并搜索键盘部分，如下所示：
- en: '![](img/e1609794-341f-41c7-b07b-b02aa13663cb.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1609794-341f-41c7-b07b-b02aa13663cb.png)'
- en: As we can see in the previous screenshot, the man page of the man command has
    nine sections. The first one is the most important one for us in this section,
    as we are most likely the shell command users. But, as you can see, the third
    section is a library call. Type `man printf`, which prints the usage of the `printf`
    command. On the other hand, if you type `man 3 printf`, it will print the Linux
    programmers' manual for the C language.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的截图中看到的，man命令的man页面有九个部分。第一个对我们来说是最重要的，因为我们很可能是shell命令的用户。但是，正如你所看到的，第三部分是一个库调用。输入`man
    printf`，它会打印`printf`命令的用法。另一方面，如果你输入`man 3 printf`，它将打印C语言的Linux程序员手册。
- en: Let's jump to the eighth section, which is the manual for the `xfs_copy` command
    written for the system administrators. Besides manual pages, a lot of commands
    that can be installed on Linux or that come right out of the box with the system,
    do have additional and advanced documentation available in a specific folder location
    in the filesystem on your hard disk. For some programs, additional documentation
    can also be installed using a special installation package, as we will learn later
    in this section. Sometimes, this additional documentation contains precious usage
    examples on how to use the program; information about the internal algorithms
    or approaches used; change log and license information; author contact information;
    history; a list of errors or limitations; or sample configuration files, which
    we will talk about later.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们跳到第八部分，这是为系统管理员编写的`xfs_copy`命令的手册。除了手册页面外，许多可以在Linux上安装或者与系统一起提供的命令，在文件系统中的特定文件夹位置都有额外和高级的文档。对于一些程序，还可以使用特殊的安装包安装额外的文档，我们将在本节后面学习。有时，这些额外的文档包含了如何使用程序的宝贵用法示例；关于内部算法或方法的信息；更改日志和许可信息；作者联系信息；历史记录；错误或限制列表；或者样本配置文件，我们稍后会谈到。
- en: 'If you get stuck with the manual or it is just not enough for you, try to check
    out if a documentation folder exists for your command of interest in your CentOS
    7 standard documentation path. Type, for example, the `postfix` documentation
    folder lives in. This is a good example. If you go into the directory, you will
    find a lot of additional documentation in text file format. Refer to the following
    screenshot for more information:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在手册中遇到困难，或者手册对你来说不够，尝试查看你的CentOS 7标准文档路径中是否存在你感兴趣的命令的文档文件夹。例如，输入`postfix`文档文件夹所在的位置。这是一个很好的例子。如果你进入该目录，你会发现很多文本文件格式的额外文档。更多信息请参考以下截图：
- en: '![](img/353c36f2-8d79-4fe1-a1d8-8766fee5dd81.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/353c36f2-8d79-4fe1-a1d8-8766fee5dd81.png)'
- en: Use the less program to read the files. Use the same keyboard shortcuts to navigate
    the files as with the man pages, for example, type *q* to exit.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用less程序来阅读文件。使用与man页面相同的键盘快捷键来浏览文件，例如，输入*q*退出。
- en: If you need more or advanced documentation, look into the `/usr/share/doc` folder
    and see if there's something available for you.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多或高级文档，请查看`/usr/share/doc`文件夹，看看是否有适合你的内容。
- en: Working with the Linux shell
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Linux shell
- en: In this section, we will learn how to work in the shell efficiently. We will
    introduce some important practices and techniques that will improve your productivity
    and make you a faster shell command hacker. This can make you a happier person
    because, eventually, you will be able to advance to feeling very comfortable working
    in the shell. Please note, in this section, we will show you a lot of keyboard
    shortcuts. Learning keyboard shortcuts is like learning any other craft, you begin
    slowly and gradually, because learning too many new skills at once can leave you
    overwhelmed and make you forget more quickly than learning in smaller chunks.
    My tip is to start by learning the first three to four command editing shortcuts
    and then incorporate more from day to day or week to week. We will start with
    the command editing shortcuts. Now, if you don't know any command editing shortcuts
    at all, let's recap what you probably know so far on how to type and edit text
    in the command line.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何在shell中高效工作。我们将介绍一些重要的实践和技术，这将提高你的生产力，使你成为一个更快的shell命令黑客。这可以让你成为一个更快乐的人，因为最终，你将能够感到非常舒适地在shell中工作。请注意，在本节中，我们将向你展示很多键盘快捷键。学习键盘快捷键就像学习任何其他技能一样，你要慢慢开始，因为一次学习太多新技能会让你感到不知所措，比学习小块的知识更容易忘记。我的建议是从学习前三到四个命令编辑快捷键开始，然后逐日或逐周增加更多。我们将从命令编辑快捷键开始。现在，如果你根本不知道任何命令编辑快捷键，让我们回顾一下你可能已经知道的如何在命令行中输入和编辑文本。
- en: The first shortcut for moving the position of the cursor is that you can use
    the left and the right arrow keys, which are helpful to edit the text you wrote
    to insert or delete characters at a specific position. But if this were all that
    one could do in the shell, working in the shell would be very inefficient, because
    single-character cursor movement is very slow. Also, every time a command gets
    executed with a typo or the command needs to be rerun with a small difference,
    such as changing one option, the complete command needs to be retyped from beginning
    to end.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 移动光标位置的第一个快捷键是使用左右箭头键，这有助于编辑你输入的文本，在特定位置插入或删除字符。但如果这是在shell中所能做的一切，那么在shell中工作将会非常低效，因为单个字符的光标移动非常缓慢。此外，每当使用有错别字的命令或者需要以稍有不同的方式重新运行命令时，例如更改一个选项，就需要从头到尾重新输入完整的命令。
- en: 'To be a lot more efficient, let''s introduce some very important command editing
    shortcuts for your everyday work with Linux:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更高效，让我们介绍一些非常重要的命令编辑快捷键，用于你在Linux中的日常工作：
- en: To move the cursor to the end of the line, use *Ctrl* + *E*.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将光标移动到行尾，使用*Ctrl* + *E*。
- en: To go back to the beginning, press *Ctrl* + *A*, *Ctrl* + *E*, *Ctrl* + *A* respectively.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要返回到开头，分别按下*Ctrl* + *A*，*Ctrl* + *E*，*Ctrl* + *A*。
- en: To move the cursor to the next word, which is defined by a space or special
    characters such as dot, semicolon, or point, use *Ctrl* and the right arrow key
    to move forward.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将光标移动到下一个单词，该单词由空格或特殊字符（如句点、分号或点）定义，使用*Ctrl*和右箭头键向前移动。
- en: To move backward one word, use the left arrow key while holding the *Ctrl* key.
    You can also use *meta* + *F* and *meta* + *B* to do the same.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要向后移动一个单词，请按住*Ctrl*键并使用左箭头键。您还可以使用*meta* + *F*和*meta* + *B*来执行相同的操作。
- en: On most systems, like any normal PC keyboard, there is no meta key, so the meta
    key is mapped to the *Esc* or *Alt* key.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数系统上，就像任何普通PC键盘一样，没有元键，因此元键映射到*Esc*或*Alt*键。
- en: Using the *Alt* key in some terminal emulators such as the Xfce4 Terminal is
    reserved for menu accessibility. So, you first have to disable the *Alt* key as
    a menu shortcut in the preferences before you can use it as a shortcut.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些终端仿真器（如Xfce4终端）中使用*Alt*键保留用于菜单可访问性。因此，在使用它作为快捷键之前，您必须在首选项中禁用*Alt*键作为菜单快捷键。
- en: To toggle between the current position and the beginning of the line, press *Ctrl*
    + *XX* twice.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在当前位置和行的开头之间切换，请两次按*Ctrl* + *XX*。
- en: Press *Ctrl* + *K* to delete the text from the cursor to the end of the command
    line.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按*Ctrl* + *K*删除光标到命令行末尾的文本。
- en: To delete the text from the cursor to the start of the command line, press *Ctrl*
    + *U*. Use *Alt* + *D* to delete to the end of the word.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要删除光标到命令行开头的文本，请按*Ctrl* + *U*。使用*Alt* + *D*删除到单词的末尾。
- en: All of the command editing keyboard shortcuts we just discussed here are only
    the most important and efficient ones for your everyday daily use, and there are
    many, many more.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论的所有命令编辑键盘快捷键都是您日常使用中最重要和高效的快捷键，还有很多很多。
- en: 'In order to get a full list of all of the Bash keyboard shortcuts, do the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有Bash键盘快捷键的完整列表，请执行以下操作：
- en: Type `man bash` and then search for the section commands for moving
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入`man bash`，然后搜索移动命令的部分
- en: In this man page, search for `Killing`
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此手册页中搜索“Killing”
- en: In this man page, the *C* key is the *Ctrl* key, the *M* key is the meta key,
    and the dash means to combine or press and hold two keys, as we have shown you
    using the *Ctrl* + *A* shortcut earlier
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此手册页中，*C*键是*Ctrl*键，*M*键是元键，破折号表示组合或按住两个键，就像我们之前使用*Ctrl* + *A*快捷键所示的那样
- en: For example, `C-k` stands for **kill-line**, which kills the text from the point
    to the end of the line. *Alt* + *T* is used to swap words, `M-u` to make words
    uppercase, and `M-l` to make words lowercase.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`C-k`代表**kill-line**，它会删除从光标到行尾的文本。*Alt* + *T*用于交换单词，`M-u`用于将单词大写，`M-l`用于将单词小写。
- en: Now, let's move on to the command completion shortcuts. The most important command
    completion shortcut is the *Tab* key on your keyboard. It tries to guess and autocomplete
    the command you are about to type. It is very useful and speeds up typing commands
    tremendously, but don't overdo it when using this key, it can only print the full
    unique command name if there are no alternatives available. Type `pass` and press
    the *Tab* key; it will autocomplete the name `passwd` as there are no other programs
    with this full name available. Type `pa` and press the *Tab* key; this will give
    you several results as no unique name can be found. Type `yp` and press the *Tab*
    key; this will autocomplete to a long name as this is the only `variant` available.
    The *Tab* short key autocompletes commands by default; to autocomplete other things,
    such as filenames, use the *Alt* + */* key. More can be found in the corresponding
    section in the Bash man page.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论命令完成快捷键。最重要的命令完成快捷键是键盘上的*Tab*键。它会尝试猜测并自动完成您即将输入的命令。这非常有用，可以大大加快输入命令的速度，但是在使用此键时不要过度使用，如果没有可用的替代方案，它只能打印完整的唯一命令名称。输入`pass`并按*Tab*键；它将自动完成名称`passwd`，因为没有其他具有完整名称的程序。输入`pa`并按*Tab*键；这将给出几个结果，因为找不到唯一的名称。输入`yp`并按*Tab*键；这将自动完成为长名称，因为这是唯一的`variant`。*Tab*快捷键默认情况下自动完成命令；要自动完成其他内容，如文件名，请使用*Alt*
    + */*键。在Bash手册中的相应部分中可以找到更多信息。
- en: 'Now, let''s look at to the command recall shortcuts. The Linux shell has a
    very nice feature available, which is the `history` command. This is a system
    for storing and retrieving all the commands typed into the shell. By default,
    on a CentOS 7 system, the last thousand commands are stored. This number can also
    be changed. The command-line history is a very useful feature to save time, by
    not doing repetitive typing, or to see how a specific command has been executed
    some time ago. To print out the current history, type `history` and press *Enter*.
    If you want to re-execute a command from this list use the exclamation mark and
    the corresponding number. Two exclamation marks run the last command from the
    history. Another exclamation mark notation can be used to extract specific arguments
    from history commands. This will extract the third argument from the `history`
    command, `166`, as shown in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下命令回调快捷键。Linux shell具有一个非常好的功能，即`history`命令。这是一个用于存储和检索输入到shell中的所有命令的系统。在CentOS
    7系统上，默认情况下会存储最近的一千个命令。这个数字也可以更改。命令行历史记录是一个非常有用的功能，可以节省时间，不用重复输入，或者查看一段时间前如何执行特定命令。要打印当前历史记录，请输入`history`并按*Enter*。如果要从此列表重新执行命令，请使用感叹号和相应的数字。两个感叹号运行历史记录中的最后一个命令。另一种感叹号符号表示可以从历史命令中提取特定参数。这将从`history`命令中提取第三个参数`166`，如下图所示：
- en: '![](img/8a19d06c-e425-49dd-8361-beb6320793cd.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a19d06c-e425-49dd-8361-beb6320793cd.png)'
- en: 'Another very useful history feature is to recall the last command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的历史功能是回调上一个命令：
- en: To go through the previous history commands you executed, press the Up arrow
    key on your keyboard.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要浏览以前执行的历史命令，请按键盘上的上箭头键。
- en: To go back to the next history commands, use the Down arrow key.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要返回到下一个历史命令，请使用下箭头键。
- en: To search through the history for a command, press *Ctrl* + *R* and then enter
    the search keyword.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在历史记录中搜索命令，请按 *Ctrl* + *R*，然后输入搜索关键字。
- en: To cycle through the results, press *Ctrl* + *R* again.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要循环浏览结果，请再次按下 *Ctrl* + *R*。
- en: To run a specific command that you have found, press the *Enter* key.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要运行找到的特定命令，请按 *Enter* 键。
- en: To quickly insert the last argument of the previous command, use *Alt* + dot.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要快速插入上一个命令的最后一个参数，请使用 *Alt* + 点。
- en: Another very useful feature is to shell expand a line manually without actually
    having to execute the line, which can be useful to find out errors and boxes.
    This can be done using *Ctrl* + *Alt* + *E*.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个非常有用的功能是手动扩展一行而不实际执行该行，这对于查找错误和框很有用。这可以使用 *Ctrl* + *Alt* + *E* 来完成。
- en: Next, we need to know how to work with programs and processes. First, we will
    discuss how to abort any running program. This is important if you need to quit
    a command because it is unresponsive or you've made a mistake and want to stop
    it. For example, let's type the `cat` command, which will just run forever. Let's
    ignore what this command is doing at the moment. This leaves the shell unresponsive
    because `cat` never finishes running in the forefront of our shell and runs forever.
    To get back to the shell prompt so we can type in new commands and work again,
    we need to exit the command while it is running. To do so in the shell, we can
    use a special key combination that exits the current foreground process. Press
    *Ctrl* + *C*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要知道如何使用程序和进程。首先，我们将讨论如何中止任何正在运行的程序。如果需要退出命令，因为它没有响应或者您犯了一个错误并希望停止它，这一点非常重要。例如，让我们输入
    `cat` 命令，它将永远运行。让我们暂时忽略此命令目前正在做什么。这会使shell无响应，因为 `cat` 永远不会在我们的shell前台完成运行并永远运行。为了回到shell提示符，以便我们可以再次输入新命令并继续工作，我们需要在其运行时退出命令。在shell中，我们可以使用一个特殊的组合键来退出当前前台进程。按下
    *Ctrl* + *C*。
- en: This is a very important key shortcut and it should be memorized: *Ctrl* + *C*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常重要的快捷键，应该记住：*Ctrl* + *C*。
- en: 'You can also suspend a program, which is like pausing its processing and putting
    it into the background so you can work in the shell again. This can be done as
    follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以暂停一个程序，就像暂停其处理并将其放入后台，这样您就可以再次在shell中工作。可以按照以下步骤完成：
- en: Press *Ctrl* + *Z*. If you later want to continue the program running in the
    foreground, type `fg` and press *Enter*.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *Ctrl* + *Z*。如果以后想要继续在前台运行程序，输入 `fg` 然后按 *Enter*。
- en: You can also put it in the background using the `bg` command while it is suspended.
    Now the program runs in the background and you can work in the foreground.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以在暂停时使用 `bg` 命令将其放入后台。现在程序在后台运行，您可以在前台工作。
- en: The easiest way to exit this program running in the background is to put it
    into the foreground and then use *Ctrl* + *C* to abort it.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出后台运行的程序的最简单方法是将其放到前台，然后使用 *Ctrl* + *C* 中止它。
- en: The next very useful command is to press *Ctrl* + *L*, which clears the screen
    and has the same effect as the `clear` command.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个非常有用的命令是按下 *Ctrl* + *L*，这将清除屏幕，与 `clear` 命令具有相同的效果。
- en: The very last useful command we will learn here is to press *Ctrl* + *D*, which
    closes the Bash shell. This is similar to typing the `exit` command.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在这里学习的最后一个非常有用的命令是按下 *Ctrl* + *D*，这将关闭Bash shell。这类似于输入 `exit` 命令。
- en: Understanding standard streams
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解标准流
- en: In this section, you will learn why every command can use three standard streams
    for accessing its input and output. Also, you will learn how to work with those
    input and output streams and how to use redirection. Finally, we will learn how
    to use pipes and why they are so important. One philosophy of the Linux operating
    system is that every command has exactly one functionality in the system, nothing
    more, and nothing less. For example, there's one command to list files, another
    to sort text, and one to print the file's content, and so on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将了解为什么每个命令都可以使用三个标准流来访问其输入和输出。此外，您还将学习如何使用这些输入和输出流以及如何使用重定向。最后，我们将学习如何使用管道以及它们为何如此重要。Linux操作系统的一个理念是，每个命令在系统中都有确切的功能，没有多余的，也没有不足的。例如，有一个命令用于列出文件，另一个用于对文本进行排序，还有一个用于打印文件的内容，等等。
- en: Now, one of the most important features of the shell is to connect different
    commands to create custom tailored solutions and tools for all kinds of problems
    and workflows. But before we can show you how to concatenate different commands
    together to build something powerful, we first need to know how a command uses
    its input and output and what input and output redirection is. Most Linux commands
    follow a similar pattern when processing data. Most of the commands we are using
    do get some kind of input, for example, they read the content of a file and then
    they process this information, and afterward almost all of them do output some
    kind of results on the computer screen. Because every command uses some kind of
    input and returns some kind of output on Linux, three standard channels are defined
    and are available for every command. They are used for communication between the
    operating system and the command during execution. They are called **standard
    input** or `stdin`, **standard output** or `stdout`, and **standard error** or
    `stderr`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，shell的最重要功能之一是连接不同的命令，以创建定制的解决方案和工具来解决各种问题和工作流程。但在我们展示如何将不同的命令连接在一起构建强大的东西之前，我们首先需要知道命令如何使用其输入和输出，以及输入和输出重定向是什么。大多数Linux命令在处理数据时遵循类似的模式。我们使用的大多数命令都会获得某种输入，例如，它们读取文件的内容，然后处理这些信息，之后几乎所有命令都会在计算机屏幕上输出某种结果。因为每个命令在Linux上都会使用某种输入并返回某种输出，所以为每个命令定义了三个标准通道，并且这些通道对于每个命令都是可用的。它们用于在执行期间操作系统和命令之间的通信。它们被称为**标准输入**或
    `stdin`，**标准输出**或 `stdout`，以及**标准错误**或 `stderr`。
- en: Normal program output goes to the `stdout` channel, while `stderr` is also an
    output stream and it can be used for showing and processing any kind of error
    messages occurring while a command is executing. These are also called **standard
    streams**. They are called streams because the data is flowing continuously through
    a specific channel and gets processed or generated consecutively by the command,
    although they have an open end, which means the command working with them cannot
    predict when this flow of data will stop or finish. Now, we can change the `stdin`
    and `stdout` locations using certain files; this is called **redirection**.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 正常程序输出进入`stdout`通道，而`stderr`也是一个输出流，可以用于显示和处理在执行命令时发生的任何错误消息。这些也被称为**标准流**。它们被称为流，是因为数据通过特定通道持续流动，并由命令连续处理或生成，尽管它们有一个开放的末端，这意味着使用它们的命令无法预测数据流何时会停止或结束。现在，我们可以使用特定文件更改`stdin`和`stdout`的位置；这称为**重定向**。
- en: Here, in this section, we will also explain the concept of pipes, which is one
    of the most fundamental concepts and major features of the Linux shell, and how
    to work with them. For example, if you type `ls /var/lib/system/`, the result
    random-seed will be printed to the screen because it is defined as an `stdout`
    device by default for every Linux command. But if you type `cat /var/log/messages`,
    an error message is printed to the same screen as both `stdout` and `stderr` are
    connected to the same output device, the screen.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们还将解释管道的概念，这是Linux shell最基本的概念和主要特性之一，以及如何使用它们。例如，如果您键入`ls /var/lib/system/`，结果random-seed将被打印到屏幕上，因为它默认为每个Linux命令的`stdout`设备。但是，如果您键入`cat
    /var/log/messages`，错误消息将打印到同一屏幕上，因为`stdout`和`stderr`都连接到同一输出设备，即屏幕。
- en: On Linux, your physical input and output devices, such as your keyboard or screen,
    like any other hardware devices, are abstracted and represented by special system
    files. All of these special files reside in a system directory called `/dev`,
    which is also called the **system devices directory**. But what can we do with
    a system like that? Its beauty is that we can redirect the input and output of
    a command to another location other than the default keyboard and screen source
    or destinations, which also must be of the filetype. This is also very useful
    to separate `stdout` and `stderr` to two different locations, which especially
    helps to keep the overview of a command running if it produces a lot of output.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，您的物理输入和输出设备，如键盘或屏幕，与其他硬件设备一样，都是通过特殊的系统文件进行抽象和表示的。所有这些特殊文件都驻留在一个名为`/dev`的系统目录中，也称为**系统设备目录**。但是我们可以用这样的系统做什么呢？它的美妙之处在于我们可以将命令的输入和输出重定向到除默认键盘和屏幕源或目的地之外的其他位置，这些位置也必须是文件类型。这对将`stdout`和`stderr`分开到两个不同的位置也非常有用，特别是在命令产生大量输出时有助于保持概览。
- en: For output channel redirection, we use the greater than sign (*>*), for input
    redirection we use the smaller than sign (*<*). To address a specific channel,
    such as `stdin`, `stdout`, and `stderr`, we use the corresponding numbers `0`,
    `1`, and `2`. When using output redirection, the `stdout` channel is expected,
    so we don't have to write it explicitly. For 99% of all cases you only redirect
    `stdout` and `stderr`, so let's focus on those examples.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于输出通道重定向，我们使用大于号（*>*），对于输入重定向，我们使用小于号（*<*）。要处理特定通道，如`stdin`、`stdout`和`stderr`，我们使用相应的数字`0`、`1`和`2`。在使用输出重定向时，期望`stdout`通道，因此我们不必明确写出它。在99%的情况下，您只需要重定向`stdout`和`stderr`，因此让我们专注于这些示例。
- en: 'To redirect the `stdout` stream output of a command to a file, use the greater
    than sign. As said before, the `stdout` channel is expected, so the last command
    can also be typed as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要将命令的`stdout`流输出重定向到文件，请使用大于号。如前所述，期望`stdout`通道，因此最后一个命令也可以输入如下：
- en: '[PRE1]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use the `card` command to print out the content of the file that we just created
    with the redirection to `stdout`. To redirect the `stderr` channel, use number
    `2` as the standard stream descriptor. The following screenshot shows the output
    of the previous commands:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`card`命令打印出刚刚通过重定向到`stdout`创建的文件的内容。要重定向`stderr`通道，请使用数字`2`作为标准流描述符。以下截图显示了先前命令的输出：
- en: '![](img/7b04e011-9e42-422d-9fa8-43cc7e64a47e.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b04e011-9e42-422d-9fa8-43cc7e64a47e.png)'
- en: 'As you can see, the error message has been redirected to a file. To redirect
    `stdout` and `stderr` to two different files, type the commands shown in the following
    screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，错误消息已被重定向到一个文件中。要将`stdout`和`stderr`重定向到两个不同的文件中，请输入以下截图中显示的命令：
- en: '![](img/7a3bd9a4-0228-48af-9ca0-c832a49f06f2.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a3bd9a4-0228-48af-9ca0-c832a49f06f2.png)'
- en: 'Another notation, using the *ampersand* char allows the redirecting of one
    channel another one. To redirect `stderr` to the `stdout` channel, type the commands
    shown in the following screenshot:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种表示法，使用*和符号*允许将一个通道重定向到另一个通道。要将`stderr`重定向到`stdout`通道，请输入以下截图中显示的命令：
- en: '![](img/5754adbc-5759-4200-8c37-19fcac394707.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5754adbc-5759-4200-8c37-19fcac394707.png)'
- en: 'Sometimes, you are only interested in one output stream, therefore a special
    device file exists in any Linux system, which is called the `null` device, and
    it consumes and vanishes any kind of streaming data that gets redirected to it
    into the void. If you don''t want any output at all for any command, for example,
    you can use the command shown in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您只对一个输出流感兴趣，因此在任何Linux系统中都存在一个特殊的设备文件，称为`null`设备，它会消耗并消失任何被重定向到它的流数据。如果您不希望对任何命令输出任何输出，例如，您可以使用以下截图中显示的命令：
- en: '![](img/11f2e005-80c4-41aa-a86b-3a34ca25356a.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11f2e005-80c4-41aa-a86b-3a34ca25356a.png)'
- en: Finally, to redirect `stdin`, you use the smaller than sign [`<`]. For example,
    this can be very useful because some of the available shell commands can directly
    read a file's content as `stdin`, such as the `grep` command, which we will learn
    about later.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要重定向`stdin`，您可以使用小于号[`<`]。例如，这可能非常有用，因为一些可用的shell命令可以直接读取文件的内容作为`stdin`，比如`grep`命令，我们稍后会学习。
- en: Now, let's discuss pipes. Besides redirecting a command's default input and
    output streams, `stdin`, `stdout`, and `stderr`, to files, we can also use the
    concept of shell pipes to get one command output as the input for another command.
    There are no limits to this system and it's very easy to build multi-command chains
    to answer very complex questions for you. As mentioned previously, this shell
    feature lets you create very powerful command pipelines and workflows for creating
    custom tailored solutions for all kinds of Linux command-line work, and to answer
    very complex questions for you.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论管道。除了将命令的默认输入和输出流`stdin`、`stdout`和`stderr`重定向到文件之外，我们还可以使用shell管道的概念，将一个命令的输出作为另一个命令的输入。这个系统没有限制，非常容易构建多命令链，为您回答非常复杂的问题。正如之前提到的，这个shell功能可以让您创建非常强大的命令管道和工作流程，为各种Linux命令行工作创建定制解决方案，并为您回答非常复杂的问题。
- en: 'To chain commands together, which means to use `stdout` from the first command
    as `stdin` to the next command, we use the vertical bar symbol [`|`] on our keyboard,
    which in Linux is called the **pipe** symbol. For example, if you''ve got a very
    long directory content list that you want to read without scrolling through the
    Terminal window forever, you can use the pipe to output the directory content
    from the `ls` command, not on the screen, but directly as input for the file viewer,
    as we learned before. Often, pipes are used to avoid intermediate result files
    and are more efficient without them. The use cases for this are endless, for example,
    if we got a file with unsorted names of people in it, we could sort them using
    `cat names.txt | sort`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要将命令链接在一起，也就是将第一个命令的`stdout`作为下一个命令的`stdin`使用，我们使用键盘上的竖线符号[`|`]，在Linux中称为**管道**符号。例如，如果您有一个非常长的目录内容列表，您希望在终端窗口中不断滚动地阅读，您可以使用管道将`ls`命令的目录内容输出到屏幕上，而不是直接作为文件查看器的输入，就像我们之前学到的那样。通常，管道用于避免中间结果文件，并且没有它们更有效率。这种用法的用例是无穷无尽的，例如，如果我们有一个包含未排序人名的文件，我们可以使用`cat
    names.txt | sort`进行排序：
- en: '![](img/06f54597-854a-4347-bc93-2c6b62fa8f2b.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06f54597-854a-4347-bc93-2c6b62fa8f2b.png)'
- en: 'You can also get a list of all the unique names in this file. We will use the
    unique command to do so, which only works on a sorted list. So, we need to sort
    using `cat names.text | sort | uniq`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以获得此文件中所有唯一名称的列表。我们将使用唯一命令来执行此操作，该命令仅适用于已排序的列表。因此，我们需要使用`cat names.text |
    sort | uniq`进行排序：
- en: '![](img/729cab59-0336-4c7a-a106-a3cd9c908b25.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/729cab59-0336-4c7a-a106-a3cd9c908b25.png)'
- en: 'You can also count the number of unique lines using the word count command-line
    tool using `cat names.text | sort | uniq | wc`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用单词计数命令行工具来计算唯一行的数量，使用`cat names.text | sort | uniq | wc`：
- en: '![](img/ef883ce1-f0bb-4d18-ba83-41772fec0efe.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef883ce1-f0bb-4d18-ba83-41772fec0efe.png)'
- en: 'There are quite a few unique names in this file. The sky''s the limit when
    it comes to pipe examples, and there are just too many examples. Ideally, this
    should be run with the `root` user account. Please ignore the errors. The following
    screenshot shows the core summary of the filesystem:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件中有相当多的唯一名称。在管道示例方面，天马行空，例子太多。理想情况下，应该使用`root`用户帐户运行。请忽略错误。以下屏幕截图显示了文件系统的核心摘要：
- en: '![](img/72686415-4aae-4ceb-ac5d-9819e377693e.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72686415-4aae-4ceb-ac5d-9819e377693e.png)'
- en: 'Also, another useful pipe command is to print out the used files in a directory.
    If you are using a Windows system, you may know of a utility called ZIP, which
    compresses files. On Linux, you can do something very similar, but here we need
    two tools to work together. For compression, we use the `gzip` tool. Because `gzip`
    can only work on single files, we first need to create an archive that will concatenate
    multiple files to a single file. For archiving, we use the `tar` command. So,
    to create a compressed archive of your home directory in the `/tmp` directory,
    first create an archive of your home directory using the `tar` command: `tar -cv
    /home/olip/ | gzip`. The archive will be output to the `stdout` stream, so we
    pipe it into the `gzip` command as `stdin`. As gzip itself outputs the compressed
    file to `stdout`, we will redirect it to a file. The result of the compression
    versus the uncompressed data amount is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的管道命令是打印目录中使用的文件。如果您使用的是Windows系统，您可能知道一个称为ZIP的实用程序，它可以压缩文件。在Linux上，您可以做类似的事情，但是这里我们需要两个工具一起工作。对于压缩，我们使用`gzip`工具。因为`gzip`只能处理单个文件，所以我们首先需要创建一个将多个文件连接到单个文件的存档。对于存档，我们使用`tar`命令。因此，要在`/tmp`目录中创建您的主目录的压缩存档，请首先使用`tar`命令创建您的主目录的存档：`tar
    -cv /home/olip/ | gzip`。存档将输出到`stdout`流，因此我们将其作为`stdin`管道到`gzip`命令。因为gzip本身将压缩文件输出到`stdout`，所以我们将其重定向到文件。压缩与未压缩数据量的结果如下：
- en: '![](img/4fd858d0-e6f0-4260-bf40-0183ec1aa613.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fd858d0-e6f0-4260-bf40-0183ec1aa613.png)'
- en: 'A lot more piping examples will be shown throughout this book. If you redirect
    `stdout` or `stderr` into a file, normally the file will be erased if it already
    exists, or a new file will be created before any content is written to it. So
    as not to delete a file, but append the content instead, use the greater than
    sign. For example, to create a new output file, execute the command shown in the
    following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将展示更多的管道示例。如果将`stdout`或`stderr`重定向到文件，通常情况下，如果文件已经存在，它将被删除，或者在写入任何内容之前将创建一个新文件。为了不删除文件，而是追加内容，使用大于号。例如，要创建一个新的输出文件，请执行以下屏幕截图中显示的命令：
- en: '![](img/47b8f3be-2e24-459d-a657-e025a89885db.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47b8f3be-2e24-459d-a657-e025a89885db.png)'
- en: Now, to append the string, `Hello World`, to the output file, we will use the
    greater than sign. This will not delete the file's content when we start to redirect
    content to it. Instead, it will append the content to the end of the file. As
    said before, pipes are one of the most important concepts of the shell and it
    is so much fun working with them.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要将字符串`Hello World`附加到输出文件，我们将使用大于号。这不会在我们开始将内容重定向到文件时删除文件的内容。相反，它将在文件末尾附加内容。如前所述，管道是shell中最重要的概念之一，与它们一起工作非常有趣。
- en: Understanding regular expressions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解正则表达式
- en: In this section, we will introduce the wonderful art of regular expressions.
    You will learn what they are and why they are so powerful. There are a lot of
    different regular expression characters available, and here we will introduce
    the most important ones. Afterward, you will learn how to apply regular expressions
    with the `grep` command to find, extract, and filter useful information out of
    text files. **Regular expressions**, or **regexps** for short, are a very powerful
    concept used to search through text using special patterns, describing the structure
    of the search term instead of a constant string of characters, which is also called
    **literal text search** in this context. Using regular expressions can save you
    a lot of time, by not doing repetitive work, and Linux system administrators use
    them quite heavily in their everyday work.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍正则表达式的奇妙艺术。您将了解它们是什么，以及它们为何如此强大。有许多不同的正则表达式字符可用，在这里我们将介绍最重要的字符。之后，您将学习如何使用`grep`命令应用正则表达式来查找、提取和过滤文本文件中的有用信息。**正则表达式**，简称**regexps**，是一种非常强大的概念，用于使用特殊模式搜索文本，描述搜索项的结构，而不是在这种情况下称为**文字文本搜索**的常量字符字符串。使用正则表达式可以节省大量时间，不需要重复工作，Linux系统管理员在日常工作中广泛使用它们。
- en: In the *File globbing* section, we learned a very similar concept when we used
    globbing characters to find patterns to address multiple filenames with some special
    characters. Regular expressions are an even more powerful tool; they contain a
    very broad set of all kinds of special characters for matching even the most complex
    text fragments completely or partially. In the Linux shell, we use regular expressions
    not for shell expansion or to group filenames, but rather to work on the content
    of text files or strings of text lines to parse and analyze their content or extract
    text features out of it. As said before, regular expressions are a very complex
    topic and we can only give you an overview here. Please note that there are several
    styles of regular expressions available, such as Perl regular expressions. In
    our examples, we'll use the POSIX, basic, and extended regular expressions, as
    used by most of the shell tools, such as `greb`, `sed`, and `awk`. There are a
    lot of different regular expression characters available, which are also called
    **meta characters**.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在*文件globbing*部分，当我们使用globbing字符查找模式以寻址具有一些特殊字符的多个文件名时，我们学习了一个非常相似的概念。正则表达式是一个更强大的工具；它们包含了一组非常广泛的特殊字符，用于完全或部分匹配甚至最复杂的文本片段。在Linux
    shell中，我们使用正则表达式不是为了shell扩展或对文件名进行分组，而是为了处理文本文件或文本行的内容，以解析和分析其内容或从中提取文本特征。如前所述，正则表达式是一个非常复杂的主题，我们只能在这里给您一个概述。请注意，有几种风格的正则表达式可用，例如Perl正则表达式。在我们的示例中，我们将使用大多数shell工具使用的POSIX、基本和扩展正则表达式。有许多不同的正则表达式字符可用，也称为**元字符**。
- en: As some of these meta characters are extended POSIX characters, we need to start
    our regular expression processing commands in the extended mode.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一些元字符是扩展的POSIX字符，我们需要在扩展模式下启动我们的正则表达式处理命令。
- en: 'Some of the extended expressions are as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一些扩展表达式如下：
- en: '`n` is used to match the end of the line.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`用于匹配行的末尾。'
- en: '`t` matches space at the top.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t` 匹配顶部的空格。'
- en: The caret `^` symbol matches the beginning of the line.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入符`^`符号匹配行的开头。
- en: The dollar `$` symbol matches the end of the line.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美元符号`$`匹配行的末尾。
- en: '`[x]` is very similar to globbing brackets, which you have learned about before.
    This describes classes of characters to match within the brackets at a specific
    position. You can also define ranges of characters here.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[x]`与globbing括号非常相似，您之前已经学过。这描述了在特定位置的括号内匹配的字符类。您还可以在这里定义字符范围。'
- en: '`[^x]` matches all characters that are not defined in the brackets.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[^x]`匹配在括号中未定义的所有字符。'
- en: Parentheses are used for grouping; this will save the text within the parentheses
    for further referencing afterward.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号用于分组；这将保存括号内的文本以便以后引用。
- en: '`1` for number is used for back referencing. This will get number *n* of the
    reference extracted from the parenthesis, which we showed you before.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字`1`用于反向引用。这将从括号中提取引用的数字*n*。
- en: '`a|b` means that at this position *a* or *b* are allowed.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a|b` 表示在此位置允许*a*或*b*。'
- en: '`x*` means to match zero or multiple occurrences of an *x* character at this
    position.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x*` 表示匹配在此位置的零个或多个*x*字符。'
- en: '`y+` means to match one or more multiple occurrences of an *y* character at
    this position.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y+` 表示匹配在此位置的一个或多个*y*字符的多个出现。'
- en: Dot means to match any character at a specific position.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点表示匹配特定位置的任何字符。
- en: It's also very important to know that a lot of tools working with regular expressions,
    such as `sed` and `awk`, expect that the regular expressions are surrounded by
    slashes. Also, the scripting language Perl has adopted this style. In other tools
    such as `grep`, you don't need to use the slash notation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 还非常重要的是，许多使用正则表达式的工具，如`sed`和`awk`，期望正则表达式被斜杠包围。另外，脚本语言Perl也采用了这种风格。在`grep`等其他工具中，您不需要使用斜杠表示法。
- en: Let's first experiment with our new regular expression concept using the command
    `grep`. We start grep in the extended mode using the `egrep` command-line tool.
    Instead of running the command `egrep`, you can also run the command `grep` with
    the capital `-E` option, which has the same effect. `grep` is a command that goes
    through a text file or input stream, line by line, and tries to match the search
    pattern argument given to it to every line. If a specific line matches the pattern,
    it will print out the complete line. This is very useful for all kinds of text
    extraction, and `grep` is one of the most important command-line tools available
    on Linux. In fact, I cannot remember a day working in the shell when I did not
    use it at all. Oftentimes, `grep` is used as a filter as part of a greater pipe
    command workflow to reduce huge output text that you want to process further.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先用`grep`命令来实验一下我们的新正则表达式概念。我们使用`egrep`命令行工具启动扩展模式的grep。你也可以用大写的`-E`选项来运行`grep`命令，效果是一样的。`grep`是一个命令，它逐行遍历文本文件或输入流，并尝试将给定的搜索模式参数与每一行进行匹配。如果特定行匹配模式，它将打印出完整的行。这对于各种文本提取非常有用，`grep`是Linux上最重要的命令行工具之一。事实上，我在shell中工作的一天中，几乎没有不使用它的。很多时候，`grep`被用作管道命令工作流的一部分，以减少你想进一步处理的大量输出文本。
- en: First things first, as said before, we will use the POSIX `regex`. There exists
    a lot of different regular expression terms, too many to memorize, so every time
    you need to look up the syntax, type `man 7 regex`. In this manual, you will find
    everything you need to know about regular expressions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正如前面所说，我们将使用POSIX `regex`。有很多不同的正则表达式术语，太多了，无法记住，所以每次需要查找语法时，输入`man 7 regex`。在这个手册中，你会找到关于正则表达式的所有你需要知道的东西。
- en: Let's start extracting various information out of files. We will start by using
    the `grep` command without a regular expression, but rather searching for simple
    text literals, `grep root /etc/passwd`. This returns all lines in the `passwd`
    file that contain the word `root`. Any line in the output gives us information
    that groups the `root` user it belongs to. As you can see, grep goes through the
    complete file and finds all lines that contain the string `root` at any position.
    A very useful `grep` option is `-i`. This can be used to ignore case sensitiveness
    for the search term. For example, execute `grep -I root /etc/services`. This will
    find all occurrences of the word `root`, while ignoring the case. This will find
    all the other case permutations of the word `root` as well. When working with
    regular expressions as arguments for commands such as `grep`, `sed`, or `awk`,
    it is recommended to quote your meta characters with *single quotes*. This is
    because some of the regular expression characters are the same characters as the
    shell globbing characters, such as the wildcard character, and this would be bad.
    Shell expansion always takes place before any argument gets fed into any command,
    so using the correct command without a disabled wild card character would search
    for a string containing all the filenames in the specific file that you want to
    search for.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始从文件中提取各种信息。我们将首先使用`grep`命令，而不是使用正则表达式，而是搜索简单的文本字面量，`grep root /etc/passwd`。这将返回`passwd`文件中包含单词`root`的所有行。输出中的任何行都会给我们提供属于`root`用户的信息。正如你所看到的，grep会遍历整个文件，并找到包含字符串`root`的所有行。一个非常有用的`grep`选项是`-i`。这可以用于忽略搜索项的大小写敏感性。例如，执行`grep
    -I root /etc/services`。这将找到单词`root`的所有出现，同时忽略大小写。这也将找到单词`root`的所有其他大小写排列。当使用正则表达式作为`grep`、`sed`或`awk`等命令的参数时，建议用*单引号*引用你的元字符。这是因为一些正则表达式字符与shell通配符字符相同，比如通配符字符，这是不好的。在任何参数被输入任何命令之前，shell扩展总是发生的，所以使用正确的命令而没有禁用通配符字符会搜索包含你想要搜索的特定文件中所有文件名的字符串。
- en: 'Instead, always put your regular expression meta characters in single quotes.
    Also, if you want to search for a literal special character in the file that is
    the same as the regular expression meta character, you need to escape the character,
    which is similar to what we learned in the *File globbing* section using the backslash
    key. The following screenshot illustrates one example for every meta character
    mentioned at the start of this section:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，总是将你的正则表达式元字符放在单引号中。另外，如果你想在文件中搜索与正则表达式元字符相同的特殊字符，你需要转义该字符，这与我们在*文件通配符*部分学到的使用反斜杠键类似。以下截图说明了本节开头提到的每个元字符的一个例子：
- en: '![](img/42eee779-0e46-4aed-92b0-61cbec2cfdf6.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42eee779-0e46-4aed-92b0-61cbec2cfdf6.png)'
- en: 'The dollar sign matches at the end of the line, so this will print out all
    the files ending with data in the services file. Similarly, we use the caret `^`
    symbol to match at the beginning of the line. The following command here matches
    all the lines starting with the word `day`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 美元符号匹配行尾，因此这将打印出在services文件中以data结尾的所有文件。类似地，我们使用插入符`^`符号来匹配行首。以下命令在这里匹配所有以单词`day`开头的行：
- en: '![](img/f06d6723-c123-4b1a-9b61-c158f5d503cb.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f06d6723-c123-4b1a-9b61-c158f5d503cb.png)'
- en: A bracket expression is a list of characters enclosed in square brackets. It
    normally matches any single-character from the list at a specific position. You
    can also define ranges in square brackets using the dash symbol similar to the
    ones we have shown in the *File globbing* section. If the list in the brackets
    begins with the caret symbol, it matches any single-character not from the rest
    of this list. Normal brackets can be used to save a reference of the match within
    it. To back reference, we use `/number` of the bracket expression so that the
    regular expression matches all the lines starting with the first letter, for example,
    `egrep 't(ac)1*s' /etc/services`. The pipe symbol stands for *or*, so the next
    expression matches all the lines containing either **domain** or **gopher**. Dot
    matches any character at a specific position. Plus means to match zero or multiple
    occurrences of the character before, so that this regular expression matches all
    the lines containing `at-`, but not at the end of the line. The star meta character
    matches one or more occurrences of the character before, so that the `egrep 'aa+'
    /etc/services` expression here matches all the lines that contain at least two
    `aa` or more. The plus character matches one or multiple occurrences of the character
    before, so that this regular expression here matches all the lines.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 括号表达式是括在方括号中的字符列表。它通常匹配列表中特定位置的任何单个字符。您还可以使用破折号符号在方括号中定义范围，类似于我们在*文件通配符*部分中展示的那些。如果括号中的列表以插入符号开头，它匹配不属于此列表其余部分的任何单个字符。普通括号可用于保存其中的匹配的引用。要进行反向引用，我们使用括号表达式的`/number`，以便正则表达式匹配所有以第一个字母开头的行，例如，`egrep
    't(ac)1*s' /etc/services`。管道符号代表*或*，因此下一个表达式匹配所有包含**domain**或**gopher**的行。点匹配特定位置的任何字符。加号表示匹配字符之前的零个或多个出现，因此这个正则表达式匹配所有包含`at-`的行，但不是在行末。星号元字符匹配字符之前的一个或多个出现，因此这里的`egrep
    'aa+' /etc/services`表达式匹配所有包含至少两个`aa`或更多的行。加号字符匹配字符之前的一个或多个出现，因此这个正则表达式在这里匹配所有的行。
- en: 'As said before, the dot matches every character at a specific position, so
    that the regular expression matches all the lines containing exactly the number
    of characters corresponding to the number of dots in the expression. `grep` has
    a lot of useful options, for example, `-v` reverses the search match, which means
    print all the lines that do not contain the search pattern at all. I often use
    this option to remove all empty lines and command lines in a lot of configuration
    files that start with the hashtag in shell script files. For example, execute
    the command shown in the following screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，点匹配表达式中特定位置的每个字符，因此正则表达式匹配所有包含与表达式中的点数相对应的字符数的行。`grep`有许多有用的选项，例如，`-v`反转搜索匹配，这意味着打印出所有不包含搜索模式的行。我经常使用这个选项来删除所有以井号开头的空行和命令行在许多配置文件中的shell脚本文件。例如，执行以下截图中显示的命令：
- en: '![](img/43c20227-c279-46f3-a1f7-9f1422d30d33.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43c20227-c279-46f3-a1f7-9f1422d30d33.png)'
- en: The manual contains a lot of command lines that start with the hashtag and empty
    lines. To filter out all these un-needed lines, use the `grep -v` option. Another
    useful feature is the `grep -o` option, which only prints the matched pattern
    and not a complete line. So, for example, `egrep 'netbios-...' /etc/services`
    prints out the full line, while the `-o` option only prints the pure NetBIOS name
    from the pattern.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 手册包含许多以井号和空行开头的命令行。要过滤掉所有这些不需要的行，可以使用`grep -v`选项。另一个有用的功能是`grep -o`选项，它只打印匹配的模式，而不是完整的行。因此，例如，`egrep
    'netbios-...' /etc/services`会打印出完整的行，而`-o`选项只会打印出模式中的纯NetBIOS名称。
- en: Working with sed
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sed进行工作
- en: 'In this section, we will learn about the `sed` command, the powerful stream
    editor. We will give you a brief introduction on how `sed` works and we''ll be
    showing you the substitution mode for automatically replacing text and files,
    which is one of the most important modes available. Next, we will learn about
    the `sed` command. Let''s first examine its syntax:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习关于`sed`命令，这个强大的流编辑器。我们将为您简要介绍`sed`的工作原理，并向您展示自动替换文本和文件的替换模式，这是最重要的可用模式之一。接下来，我们将学习关于`sed`命令。让我们首先检查它的语法：
- en: '[PRE2]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`sed` stands for **stream editor** and this command can edit files automatically
    without any user interaction. It processes input files on a line-by-line basis.
    Oftentimes, `sed` is used in shell scripts to transform any command''s output
    to a desired form for further processing. Most everyday use cases for `sed` follow
    a similar pattern, which, in its most simple form, is first used with a regular
    expression or other pattern to define which lines to change in an input file or
    stream, and then provide a rule on how to change or transform the matched line.
    Similar to the `grep` command, always use single quotes when working with `sed`,
    unless you need to work with environment variables within the `sed` expressions,
    then you should use double quotes instead. Normally `sed` reads from `stdin`,
    processes the stream internally, and outputs the transformed version of the text
    to `stdout`. So, it''s ideally being used in a `pipe` command, therefore it is
    often part of pipelines. `sed` can be used for a lot of different use cases.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`代表**流编辑器**，这个命令可以在没有任何用户交互的情况下自动编辑文件。它逐行处理输入文件。通常情况下，`sed`用于shell脚本中，将任何命令的输出转换为进一步处理所需的形式。大多数`sed`的日常用例都遵循类似的模式，最简单的形式是首先使用正则表达式或其他模式来定义要在输入文件或流中更改的行，然后提供一个规则来更改或转换匹配的行。与`grep`命令类似，使用`sed`时总是使用单引号，除非您需要在`sed`表达式中使用环境变量，那么您应该改用双引号。通常情况下，`sed`从`stdin`读取，内部处理流，并将文本的转换版本输出到`stdout`。因此，它最好用在`pipe`命令中，因此它经常是管道的一部分。`sed`可以用于许多不同的用例。'
- en: A very easy example using address ranges would be the `d` option, to delete,
    which also helps you understand how `sed` does its processing on input and output
    streams. So again, `cat /etc/services | sed '20,50 d'` pipes the `etc/services`
    file stream using `cat` into `sed`. `sed` processes the input stream line by line,
    and, here, all the lines that are not between line number 20 to 50 get handled
    directly over to the `stdout` channel, while lines number 20 to 50 get suppressed
    completely. You can also use regular expressions with the `d` option. Remember
    to put any regular expressions in slashes when working with `sed`. The `sed` command
    ignores all the lines starting with the hash symbol, but it prints out all the
    others to `stdout`. There are a lot of different options and modes that can work,
    but there are too many to mention here.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用地址范围的一个非常简单的示例是`d`选项，用于删除，这也有助于您了解`sed`如何在输入和输出流上进行处理。因此，再次，`cat /etc/services
    | sed '20,50 d'`将`etc/services`文件流使用`cat`管道传输到`sed`。`sed`逐行处理输入流，在这里，所有不在20到50行之间的行直接处理到`stdout`通道，而20到50行的行完全被抑制。您还可以在`d`选项中使用正则表达式。请记住，在使用`sed`时将任何正则表达式放在斜杠中。`sed`命令会忽略以井号符号开头的所有行，但会将所有其他行打印到`stdout`。有许多不同的选项和模式可以工作，但这里提及的太多了。
- en: 'The most important usage for `sed` is definitely the substitution mode, which
    can be used to automate file or text editing without any user interaction. Its
    general syntax is: `sed ''s/search_for_text/replace_with_text/'' FILENAME`. This
    will search for the pattern between the first slashes, which can be a regular
    or literal expression, in the file filename, and if and only if this pattern matches
    the text somewhere in the line in this file, will it be replaced by the text to
    be found between the other slash. This only works for the first occurrence in
    the file. If you need to replace all occurrences of the search text in the file,
    you have to use the `g` option at the end of the slash expression. For example,
    to replace the word `root` in the `passwd` file with the word `King_of_the_Jungle`,
    for every occurrence, execute the command shown in the following screenshot:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`的最重要用法肯定是替换模式，它可以用于自动化文件或文本编辑，无需任何用户交互。其一般语法是：`sed ''s/search_for_text/replace_with_text/''
    FILENAME`。这将在文件filename中搜索第一个斜杠之间的模式，该模式可以是正则表达式或文字表达式，并且仅当此模式在文件中的某行中的文本与之匹配时，才会被另一个斜杠之间的文本替换。这仅适用于文件中的第一次出现。如果您需要替换文件中搜索文本的所有出现，必须在斜杠表达式的末尾使用`g`选项。例如，要替换`passwd`文件中的单词`root`为单词`King_of_the_Jungle`，并且要替换每次出现，执行以下屏幕截图中显示的命令：'
- en: '![](img/5a46e9cd-26af-4ed3-a86b-9dc62120a57c.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a46e9cd-26af-4ed3-a86b-9dc62120a57c.png)'
- en: If you are searching for anything that contains slashes, you can escape the
    regular substitution usage using a different pattern delimiter, because otherwise
    you would need to escape the slash character that you want to search for or replace,
    which can look very complicated and unstructured. This can also be written as
    `sed 's:XX:YY:g' FILENAME`, or any other character of your choice. So for example,
    if you want to replace single slashes with double slashes in a file, instead of
    using `sed 's//////g' FILENAME`, it's cleaner to use `sed 's:/://:g' FILENAME`,
    or `sed 's#/#//#g' FILENAME`. Using the substitution mode without any `sed` option
    will always print the transformed text to `stdout`. Sometimes, it is useful to
    directly change the text in the input file. This can be done using the `sed -i`
    option, or inline option.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在搜索包含斜杠的任何内容，可以使用不同的模式分隔符来转义常规替换用法，否则您将需要转义要搜索或替换的斜杠字符，这看起来可能非常复杂和无结构。这也可以写成`sed
    's:XX:YY:g' FILENAME`，或者您选择的任何其他字符。例如，如果您想在文件中用双斜杠替换单斜杠，而不是使用`sed 's//////g' FILENAME`，最好使用`sed
    's:/://:g' FILENAME`或`sed 's#/#//#g' FILENAME`。在不带任何`sed`选项的替换模式下，将始终将转换后的文本打印到`stdout`。有时，直接更改输入文件中的文本是有用的。这可以使用`sed
    -i`选项或内联选项来完成。
- en: 'In the following example, we will work on a copy of the `passwd` file to show
    you how to do in-place editing. In order to do so, perform the following steps:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将处理`passwd`文件的副本，以向您展示如何进行原地编辑。为此，请执行以下步骤：
- en: 'Create a copy of the `passwd` file in the `/tmp` directory, as shown in the
    following screenshot:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/tmp`目录中创建`passwd`文件的副本，如下屏幕截图所示：
- en: '![](img/140e3682-1a00-4c39-acce-e0199bc574f8.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/140e3682-1a00-4c39-acce-e0199bc574f8.png)'
- en: Let's first show all the lines containing the word `root`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先显示所有包含单词`root`的行。
- en: 'Next, replace the word `root` in the file with random text on `stdout` only.
    Execute the following command:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在文件中用随机文本替换`root`一词，仅在`stdout`上执行以下命令：
- en: '[PRE3]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now to in-place edit the file, use the `-i` option:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在要进行原地编辑文件，请使用`-i`选项：
- en: '[PRE4]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The file has been permanently changed. Please take care when using this option,
    because if you have not tested your substitution before and you have made a mistake,
    you cannot revert your changes. It is better to create a backup copy of the original
    file before applying in-place editing, which you can do using the `sed -i` option,
    for example, `sed -i.bak ''s/root/RULER_OF_THE_WORLD/g'' /tmp/test-passwd`. If
    you write a new extension such as `.bak` behind the `-i` option, it will create
    a backup copy with the extension `bak` before applying the regular expression
    to the original file. When working with these regular expressions in the substitution
    mode, the grouping and back referencing feature that we showed you before makes
    substitutions very powerful, because this gives you real control of the changes
    needed to be made for your input text, for example, the `passwd` file contains
    colons as field delimiters, one colon to separate one field. Using sed when back
    referencing, we can replace one colon with four:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 文件已经永久更改。在使用此选项时请小心，因为如果您在进行替换之前没有测试过，并且犯了一个错误，您将无法恢复更改。在应用原地编辑之前最好创建原始文件的备份副本，您可以使用`sed
    -i`选项来执行此操作，例如，`sed -i.bak 's/root/RULER_OF_THE_WORLD/g' /tmp/test-passwd`。如果在`-i`选项后面写入新的扩展名，例如`.bak`，它将在将正则表达式应用于原始文件之前创建一个带有扩展名`bak`的备份副本。在使用这些正则表达式进行替换模式时，我们之前向您展示的分组和反向引用功能使替换非常强大，因为这使您真正控制了需要对输入文本进行的更改，例如，`passwd`文件包含冒号作为字段分隔符，一个冒号用于分隔一个字段。使用sed进行反向引用时，我们可以用四个冒号替换一个冒号：
- en: '![](img/cd6696d5-77cc-4f47-b11a-8b0eb26bafee.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd6696d5-77cc-4f47-b11a-8b0eb26bafee.png)'
- en: POSIX extended regular expressions as used by `grep`, `sed`, and `awk` also
    define a number of very useful special character classes in brackets, which can
    be very useful in pattern matching. The general syntax is `grep '[:digit:], [:space:],
    [:blank:]'`. The digit bracket character class matches all digits at a specific
    position. Space matches all the spaces, and blank matches all the whitespaces,
    such as the *Tab* space, and blank matches all the whitespaces. To match all the
    lines containing digits in the `etc/passwd` file, use `grep '[[:digit:]]' /etc/passwd`.
    For a list of all special character classes, use the `man 7 regex` manual.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由`grep`、`sed`和`awk`使用的POSIX扩展正则表达式还在括号中定义了许多非常有用的特殊字符类，这在模式匹配中非常有用。一般的语法是`grep
    '[:digit:], [:space:], [:blank:]'`。数字括号字符类匹配特定位置的所有数字。空格匹配所有空格，空白匹配所有空格，例如*Tab*空格，空白匹配所有空格。要匹配`etc/passwd`文件中包含数字的所有行，请使用`grep
    '[[:digit:]]' /etc/passwd`。要查看所有特殊字符类的列表，请使用`man 7 regex`手册。
- en: Working with awk
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用awk
- en: 'In this section, we will show you what the command `awk` is all about and why
    it can be important for us. We will also show you how to use it for text file
    manipulation and processing. `awk` is another very important tool for text processing
    and manipulation. It can be used as a complete scripting language to work on text
    files or streams. It contains some very powerful programming constructs, including
    variables: *if...else*, *while*, *do while* and *for* loops; arrays; functions;
    and mathematical operations. `awk` also works on a line-by-line basis, as `sed`
    does. One of the key features of `awk` and the main difference to `sed` is that
    it splits input lines into fields automatically. But how does it work and why
    is it so helpful?'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示`awk`命令的全部内容以及它对我们而言的重要性。我们还将向您展示如何将其用于文本文件操作和处理。`awk`是另一个非常重要的文本处理和操作工具。它可以作为一个完整的脚本语言来处理文本文件或流。它包含一些非常强大的编程结构，包括变量：*if...else*、*while*、*do
    while*和*for*循环；数组；函数；和数学运算。`awk`也像`sed`一样逐行处理。`awk`的一个关键特点，也是与`sed`的主要区别之一，是它会自动将输入行拆分为字段。但它是如何工作的，为什么它如此有用呢？
- en: '`awk` enables you to create rule and action pairs, and, for each record that
    matches this rule or condition, the action will fire. The rules are also called
    **patterns** and are fairly powerful and can use **extended regular expressions**.
    The language for the actions is similar to the programming language C. Using the `awk`
    symbol paradigm to find a pattern in the input and then applying some kind of
    action often reduces complex and tedious data manipulation tasks to just a few
    lines of code, or even one-liners. `awk` also lets you create and execute powerful
    `awk` script files for automating challenging text transformation tasks but, in
    this section, we will only focus on using `awk` options and arguments on the command
    line. Please note that, as `awk` is a complete scripting language with a lot of
    features and options, we can only show you the most important use cases and examples
    here.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk`使您能够创建规则和动作对，对于每个匹配此规则或条件的记录，动作将触发。规则也称为**模式**，非常强大，并且可以使用**扩展正则表达式**。动作的语言类似于编程语言C。使用`awk`符号范例在输入中查找模式，然后应用某种动作通常将复杂和繁琐的数据操作任务减少到几行代码，甚至一行代码。`awk`还允许您创建和执行强大的`awk`脚本文件，以自动化具有挑战性的文本转换任务，但在本节中，我们将仅专注于在命令行上使用`awk`选项和参数。请注意，由于`awk`是一个具有许多功能和选项的完整脚本语言，因此我们只能在这里向您展示最重要的用例和示例。'
- en: 'This is the basic structure of any `awk` command: `awk [pattern] { action }...INPUTFILE`.
    It''s important to note that the actions must be surrounded by curly brackets.
    This can also be read as: go through the input file line by line and try to apply
    the pattern to each line. If, and only if, the pattern matches or the rule can
    be applied to the line and is true, the action between the curly brackets will
    be performed.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是任何`awk`命令的基本结构：`awk [pattern] { action }...INPUTFILE`。重要的是要注意，动作必须用花括号括起来。这也可以理解为：逐行浏览输入文件，并尝试将模式应用于每一行。如果且仅当模式匹配或规则可以应用于该行并且为真时，花括号之间的动作将被执行。
- en: 'The simplest way to learn and understand the `awk` tool is to use it without
    any rule or pattern and just define a simple action. Without giving it a pattern,
    the action will be applied to any line of input. As said before, `awk` completely
    splits each input line into fields so we can directly access those fields in the
    action argument using the following notation. As always, actions and patterns
    should be put into single quotes:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 学习和理解`awk`工具的最简单方法是在没有任何规则或模式的情况下使用它，并定义一个简单的操作。不给定模式，操作将应用于任何输入行。如前所述，`awk`完全将每个输入行拆分为字段，因此我们可以在操作参数中直接访问这些字段，使用以下表示法。与往常一样，操作和模式应放入单引号中：
- en: '[PRE5]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will print out field `1` of all the lines of the `etc/networks` file.
    As you can see, the action must be surrounded by curly brackets. `$number` is
    the number of the field and `$0` is the complete line. As you will probably know
    now, `awk` splits on every whitespace position by default. You can use the `-f`
    option to change the field separator. For example, to split the `passwd` file
    correctly, which has colons as field separator, you would specify the field separator
    `-f` using colon. This will print out field one of the `etc/passwd` file and the
    username: `awk -F: ''{ print $1 }'' /etc/passwd`. You can also use the awk `printf`
    function, which prints out the text formatted, as you may know from other programming
    languages: `awk -F: ''{ print "user: %stgroup: %sn", S1, S3 }'' /etc/passwd`.
    The `%s` will be substituted by the field numbers. `t` makes a *Tab* character
    and `n` makes a new line character.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '这将打印出`etc/networks`文件的所有行的字段`1`。正如您现在可能已经知道的那样，`awk`默认在每个空格位置拆分。您可以使用`-f`选项来更改字段分隔符。例如，要正确拆分具有冒号作为字段分隔符的`passwd`文件，您将使用冒号指定字段分隔符`-f`。这将打印出`etc/passwd`文件和用户名的第一个字段：`awk
    -F: ''{ print $1 }'' /etc/passwd`。您还可以使用awk的`printf`函数，它会按照您从其他编程语言中了解的方式打印出格式化的文本：`awk
    -F: ''{ print "user: %stgroup: %sn", S1, S3 }'' /etc/passwd`。`%s`将被字段号替换。`t`表示*Tab*字符，`n`表示换行字符。'
- en: Now, it's time to test some patterns. As we've said before, if you define a
    pattern or rule that can also be an extended regular expression, it will be applied
    through every input line and only for those matching the rule will the action
    be executed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候测试一些模式了。如前所述，如果您定义的模式或规则也可以是扩展的正则表达式，它将应用于每个输入行，只有符合规则的行才会执行操作。
- en: 'The following command will print out field one of all the lines, and only the
    lines, starting with small `t` in the `etc/services` file. Here we will pipe it
    into the `head` command to reduce the output to only the first 10 lines:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将打印出所有以小写`t`开头的行的第一个字段，并且只有这些行，位于`etc/services`文件中。在这里，我们将其传输到`head`命令中，以将输出减少到前10行：
- en: '![](img/a70171b9-8dff-44d3-af97-5cdd635d5fd9.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a70171b9-8dff-44d3-af97-5cdd635d5fd9.png)'
- en: 'Please remember to put any regular expressions into slashes when working with
    the `awk` command. One of the greatest features of awk is that the pattern can
    also be more than a simple regular expression. For example, you can also use string
    and mathematical comparison operators here. This will help you answer very complex
    text manipulation questions with just a few tiny expressions:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在使用`awk`命令时，将任何正则表达式放入斜杠中。awk的最大特点之一是模式也可以不仅仅是简单的正则表达式。例如，您还可以在此处使用字符串和数学比较运算符。这将帮助您仅使用几个小表达式回答非常复杂的文本操作问题：
- en: '![](img/fc95c7e7-31df-4995-a9b3-17085cc0422c.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc95c7e7-31df-4995-a9b3-17085cc0422c.png)'
- en: 'In the previous example, `awk` only outputs lines from users in the `etc/passwd`
    file, which have a group ID greater than `500`. The greater than sign is the operator.
    There are lots of other operators available, but there are too many to mention
    here. For example, to match a regular expression, use `awk ''$1 ~ /netrjs/ {print
    $0}'' /etc/services`. The tilde is the regular expression match operator. To match
    string literals, use the equal sign twice instead, `awk ''$1 == "netrjs-4" {print
    $0}'' /etc/services`. To get a list of all the awk operators, search for operators
    in the man page. Also, `awk` has two special patterns, which are called **BEGIN**
    and **END**. As any other pattern, you can define an action for the begin and
    for the end pattern, and this will fire only once, at the beginning or at the
    end of the file. We can use this to print out the total number of bytes in a directory:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`awk`仅输出`etc/passwd`文件中组ID大于`500`的用户行。大于号是操作符。还有许多其他可用的操作符，但这里无法一一列举。例如，要匹配正则表达式，请使用`awk
    '$1 ~ /netrjs/ {print $0}' /etc/services`。波浪号是正则表达式匹配操作符。要匹配字符串文字，请使用两个等号，例如`awk
    '$1 == "netrjs-4" {print $0}' /etc/services`。要获取所有awk操作符的列表，请在man页面中搜索操作符。此外，`awk`还有两个特殊模式，称为**BEGIN**和**END**。与任何其他模式一样，您可以为开始和结束模式定义一个操作，这将在文件的开头或结尾处仅触发一次。我们可以使用这个功能来打印出目录中的总字节数：
- en: '![](img/fafc9ee2-d1d3-422c-92db-9bf188441ca1.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fafc9ee2-d1d3-422c-92db-9bf188441ca1.png)'
- en: 'This `awk` command works this way: first it uses a variable called `SUM` that
    acts like a container for our number counting. The `+=` is a mathematical operator
    that adds field number `5` to our container `SUM`, so that this action counts
    the number of total bytes from the single byte number in field `5` on each line.
    Also, on each line we print out the whole line content, and, once we reach the
    end of the file, the end pattern will fired, which will print out the content
    of our `SUM` variable, which holds the total number of bytes in this directory.
    As you just saw, we can define custom variables to hold values that we want to
    have and work with. There are also a number of predefined variable names available
    in awk, which contain very useful information. For example, the `NR` variable
    name contains the current line number. This can be useful in the following `awk`
    command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`awk`命令的工作方式是：首先它使用一个名为`SUM`的变量，它充当我们计数数字的容器。`+=`是一个数学运算符，它将字段号`5`添加到我们的容器`SUM`中，因此，此操作计算每行中字段`5`的单字节数字的总字节数。此外，在每行上，我们打印出整行内容，并且一旦到达文件末尾，将触发结束模式，它将打印出我们的`SUM`变量的内容，其中包含此目录中的总字节数。正如您刚才看到的，我们可以定义自定义变量来保存我们想要拥有和处理的值。awk中还有许多预定义的变量名称，其中包含非常有用的信息。例如，`NR`变量名称包含当前行号。这在以下`awk`命令中可能很有用：
- en: '[PRE6]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will prepend the line number to each line of the output using the `NR`
    variable, which contains the current line number in each line. For a list of all
    the special awk built-in variables, use the manual and search for variables.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用`NR`变量在输出的每一行前添加行号，该变量包含每一行中的当前行号。要获取所有特殊的awk内置变量列表，请使用手册并搜索变量。
- en: awk contains a number of very useful predefined functions to use, such as the
    `print` or `printf` functions that we already know from the action statements.
    To execute more than one function in one action block you can use the semicolon.
    For example, awk contains a number of very useful string manipulation functions,
    such as the `toupper (argument)` function. Functions in awk work like functions
    in most other programming languages. You call it using the function name and then,
    in brackets, you add the argument or arguments. For example, we use this with
    the `print` and `printf` function in the awk action. For example, in awk there
    exists a string function called `toupper`, which converts every string argument
    to uppercase letters.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: awk包含许多非常有用的预定义函数，例如我们已经从操作语句中了解的`print`或`printf`函数。要在一个动作块中执行多个函数，可以使用分号。例如，awk包含许多非常有用的字符串操作函数，例如`toupper(argument)`函数。awk中的函数与大多数其他编程语言中的函数一样。您可以使用函数名称调用它，然后在括号中添加参数或参数。例如，我们在awk动作中使用`print`和`printf`函数。例如，在awk中存在一个名为`toupper`的字符串函数，它将每个字符串参数转换为大写字母。
- en: 'The following is a complete `awk` command-line example that uses the `toupper`
    function:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个完整的使用`toupper`函数的`awk`命令行示例：
- en: '![](img/5addac74-524f-4f61-b729-45e5bfd8e3eb.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5addac74-524f-4f61-b729-45e5bfd8e3eb.png)'
- en: 'This prints out the first field in the `passwd` file normally, and then again
    with all letters in uppercase. Our final example will show you how to execute
    more than one expression or function in one action statement using the semicolon
    as an expression delimiter:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这将正常打印出`passwd`文件中的第一个字段，然后再次打印出所有字母大写的字段。我们的最终示例将向您展示如何在一个动作语句中使用分号作为表达式分隔符执行多个表达式或函数：
- en: '![](img/91e0abde-a7b5-4de3-be0e-d2bfdbd88dec.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91e0abde-a7b5-4de3-be0e-d2bfdbd88dec.png)'
- en: Also, you can see here that you can assign the return value of any function
    to a variable name, and then reference this variable name later, so that this
    example is very similar to the example before by first printing out the uppercase
    version, and then the normal lowercase version, and then the normal field value
    version. For all the available awk functions, we use the manual and search for
    functions, numeric functions, string functions, time functions, and so on.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以在此处看到，您可以将任何函数的返回值分配给变量名称，然后稍后引用此变量名称，因此，这个示例与之前的示例非常相似，首先打印出大写版本，然后是普通的小写版本，然后是普通的字段值版本。对于所有可用的awk函数，我们使用手册并搜索函数、数字函数、字符串函数、时间函数等。
- en: Navigating the Linux filesystem
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航Linux文件系统
- en: 'In this section, you will learn how to navigate the Linux filesystem. You will
    also learn how the Linux filesystem is structured. If we print out the folder
    structure of the top-level directories beneath the root directory by executing
    the `tree -d -L 1 /` command, you will see a list of strange-sounding directory
    names. These directory names are the same on any Linux distribution and they follow
    a standard called the **filesystem hierarchy standard** (**FHS**). Each of these
    standard directories in the Linux filesystem has a specific purpose, and the user
    can expect certain files in certain locations, and it also means that a program
    can predict where the files are located, and it also means that any program working
    with those system directories can predict where the files are located. The following
    are the directories:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何导航Linux文件系统。您还将了解Linux文件系统的结构。如果我们通过执行`tree -d -L 1 /`命令打印出根目录下顶级目录的文件夹结构，您将看到一系列听起来奇怪的目录名称。这些目录名称在任何Linux发行版上都是相同的，并且遵循一种称为**文件系统层次结构标准**（**FHS**）的标准。Linux文件系统中的每个标准目录都有特定的目的，用户可以期望在特定位置找到某些文件，这也意味着程序可以预测文件的位置，也意味着任何使用这些系统目录的程序都可以预测文件的位置。以下是这些目录：
- en: The `/` slash is the primary hierarchy root.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`斜杠是主要的层次结构根。'
- en: '`/bin` contains essential commands needed for the system, for example, so that
    a user can work in recovery mode of the system when something breaks or, for example,
    executables needed when a user boots into recovery mode.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bin`包含系统所需的基本命令，例如，当系统出现故障时，用户可以在恢复模式下使用，或者例如，当用户启动到恢复模式时需要的可执行文件。'
- en: '`/boot` contains files needed for booting, such as the kernel files.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/boot`包含用于引导的文件，例如内核文件。'
- en: '`/dev` contains the device files of the system, for example `/dev/null`, which
    we have used before. This directory is very important and you will use it a lot
    when you are working as a system administrator. It contains the system-wide configuration
    files of all your applications that you have installed on your system.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev` 包含了系统的设备文件，例如 `/dev/null`，我们之前使用过。这个目录非常重要，在你担任系统管理员时会经常用到。它包含了你在系统上安装的所有应用程序的系统范围配置文件。'
- en: '`/home` contains the user''s home directories, as we have learned in this section.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/home` 包含了用户的主目录，就像我们在本节中学到的那样。'
- en: '`/lib` contains the libraries essential for the binaries in `/bin` and `/sbin`,
    as we will see next. `/lib64` contains alternate format essential libraries for
    the 64-bit architecture.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/lib` 包含了对 `/bin` 和 `/sbin` 中的二进制文件至关重要的库，接下来我们会看到。`/lib64` 包含了64位架构的必要的备用格式库。'
- en: '`/media` contains the mount points for removable media such as CD-ROMs.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/media` 包含了可移动介质的挂载点，比如CD-ROM。'
- en: '`/mnt` contains temporarily mounted filesystems.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/mnt` 包含了临时挂载的文件系统。'
- en: '`/opt` contains optional application software packages.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/opt` 包含了可选的应用软件包。'
- en: '`/proc` contains the virtual filesystem providing process and kernel information
    as files, for example, this is where all the environment variables of the current
    sessions are stored.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc` 包含了提供进程和内核信息的虚拟文件系统，例如，当前会话的所有环境变量都存储在这里。'
- en: '`/root` contains the home directory for the `root` user. The root user''s home
    directory is not in `/home`.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/root` 包含了 `root` 用户的主目录。`root` 用户的主目录不在 `/home` 中。'
- en: '`/run` contains runtime variable data; this is information about the running
    system since last boot.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/run` 包含了运行时变量数据；这是关于系统自上次启动以来运行情况的信息。'
- en: '`/sbin` contains essential system binaries.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sbin` 包含了必要的系统二进制文件。'
- en: '`/srv` contains all the data that should be served by the system, for example,
    data and scripts for web servers or data offered by FTP servers that are running
    as services on the system.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/srv` 包含了系统应该提供的所有数据，例如，用于网页服务器的数据和脚本，或者在系统上作为服务运行的FTP服务器提供的数据。'
- en: '`/sys` contains information about the devices connected to the system.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys` 包含了连接到系统的设备的信息。'
- en: '`/tmp` contains temporary files. Every user has full access to this directory.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/tmp` 包含了临时文件。每个用户都对这个目录有完全访问权限。'
- en: '`/usr` contains the majority of all the user utilities and applications, for
    example, all the applications installed by a user go in here. It''s also called
    a **secondary hierarchy** for read-only user data; because it has a similar structure
    as the root directories, top-level directories. For example, you also have a `/usr/bin`
    directory, a /`usr/lib` directory, a `/usr/sbin` directory, and so on.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr` 包含了大部分用户实用程序和应用程序，例如，用户安装的所有应用程序都在这里。它也被称为**次要层次结构**，用于只读用户数据；因为它有与根目录相似的结构，顶级目录。例如，你也有一个
    `/usr/bin` 目录，一个 `/usr/lib` 目录，一个 `/usr/sbin` 目录，等等。'
- en: '`/var` directory is for all the files that are expected to continually change
    during normal operation of the system, for example, log files, spool files, and
    temporary email files.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var` 目录用于系统正常运行期间预计会不断变化的所有文件，例如日志文件、溢出文件和临时电子邮件文件。'
- en: First, let's introduce the concept of Linux home directories. Every user known
    to a Linux system has their own private place in the filesystem, where they can
    manage their own data and have full access to everything, for example, creating
    directories or new files, deleting things, or changing permissions. For security
    reasons, most places in the Linux filesystem, with a few exceptions, such as the
    system `/tmp` directory, are restricted in one way or the other, and normally
    a logged-in user does not have full access to it only the `root` user has full
    access to everything. Every logged in user has the property of a current directory,
    which is the directory you're currently at. When a user logs in to the Linux system,
    their specific home directory will be set as the current directory by default,
    so they will start in this directory.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们介绍Linux主目录的概念。Linux系统中的每个用户都有自己在文件系统中的私人空间，他们可以在其中管理自己的数据，并且拥有对所有内容的完全访问权限，例如，创建目录或新文件，删除东西，或更改权限。出于安全原因，Linux文件系统中的大多数地方，除了一些例外，例如系统的
    `/tmp` 目录，都在某种程度上受到限制，通常登录的用户没有对其的完全访问权限，只有 `root` 用户对所有内容有完全访问权限。每个登录的用户都有一个当前目录的属性，这是你当前所在的目录。当用户登录到Linux系统时，默认情况下，他们特定的主目录将被设置为当前目录，因此他们将从这个目录开始。
- en: To display the name of your current directory, which means where you are at
    the moment, type `pwd`, and then press the *Enter* key. pwd stands for **print
    working directory**. This is a very useful command because when you are browsing
    directories, it is easy to get lost. A directory is a concept to structure data.
    Often, it is used to categorize all files belonging to the same project or of
    the same type, such as all configuration files. As you can see, the output of
    the `pwd` command contains a string containing slash symbols that are used to
    separate directory names, and this is also called the **directory separator symbol**.
    The leftmost slash has a special name and it is also called **root directory**.
    The last directory name of the current directory can also be seen at the shell
    prompt. In a Linux filesystem, every directory can have files in it and can contain
    further directories that are then called subdirectories. These subdirectories
    can also include files and folders and so on. The directory containing a subdirectory
    is also called the parent directory, while the subdirectory is called the **child
    directory**. Here, in our example, the home directory is the parent of the `olip`
    directory, which is also called the child directory. These type of files and folders
    can be visualized using a tree-like structure, and also this can be called a hierarchical
    filesystem because every directory in this structure has a specific position and
    some are higher in the hierarchy and others are lower. The highest directory is
    the `/` directory, or `root` directory. We need to remember to visualize this
    hierarchical tree structure. We can use the `tree` command, which we need to install,
    because it is not available in the standard installation. To install it, use your
    `root` password that you set up during installation.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示当前目录的名称，也就是你当前所在的位置，输入`pwd`，然后按*Enter*键。pwd代表**打印工作目录**。这是一个非常有用的命令，因为当你浏览目录时，很容易迷失方向。目录是一种用于组织数据的概念。通常用于对属于同一项目或相同类型的所有文件进行分类，例如所有配置文件。正如你所看到的，`pwd`命令的输出包含一个包含斜杠符号的字符串，用于分隔目录名称，这也被称为**目录分隔符号**。最左边的斜杠有一个特殊的名称，也被称为**根目录**。当前目录的最后一个目录名称也可以在shell提示符中看到。在Linux文件系统中，每个目录都可以包含文件，并且可以包含进一步的子目录，然后称为子目录。这些子目录也可以包括文件和文件夹等。包含子目录的目录也被称为父目录，而子目录被称为**子目录**。在我们的例子中，主目录是`olip`目录的父目录，也被称为子目录。这种类型的文件和文件夹可以使用类似树状结构的方式进行可视化，也可以称为分层文件系统，因为该结构中的每个目录都有特定的位置，有些在层次结构中更高，而其他的更低。最高的目录是`/`目录，或`root`目录。我们需要记住可视化这种分层树结构。我们可以使用`tree`命令，但需要安装，因为它不在标准安装中。要安装它，使用你在安装过程中设置的`root`密码。
- en: After installing, you can use the `tree` command to get a first overview of
    your system. At the top level we have the `/` directory, which is the highest
    directory in the tree. Directly beneath it we have a number of system directories.
    When we customize the `tree` command to show us two levels of directories in the
    tree by executing `tree -d -L 2 / | less`, we can see where the home directory
    in the tree is and how we can get to it from the root directory, which is the
    parent of all the other directories. Now, to create a new directory in your home
    directory, you can use the `mkdir` command. The `mkdir` command takes the name
    of the folder you want to create as an argument. To remove an empty directory,
    use the `mrdir` command. To create a new empty file, use the `touch` command.
    To remove a file, use the `rm` command.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，可以使用`tree`命令来首次概览系统。在顶层，我们有`/`目录，这是树中最高的目录。直接在其下有许多系统目录。当我们定制`tree`命令以显示树中两级目录时，可以看到主目录在树中的位置，以及如何从根目录到达它，根目录是所有其他目录的父目录。现在，要在主目录中创建一个新目录，可以使用`mkdir`命令。`mkdir`命令以要创建的文件夹的名称作为参数。要删除一个空目录，使用`mrdir`命令。要创建一个新的空文件，使用`touch`命令。要删除一个文件，使用`rm`命令。
- en: 'Now, let''s recreate the folder and the filename again. To change to a directory,
    you can use the `cd` command, which stands for **change directory**. The change
    directory command will change your current directory to the new directory, which
    you used as an argument for the `cd` command. Use `pwd` to test this again. The
    following screenshot illustrates this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新创建文件夹和文件名。要切换到一个目录，可以使用`cd`命令，它代表**改变目录**。改变目录命令将当前目录更改为`cd`命令的参数所指定的新目录。使用`pwd`再次测试这一点。以下截图说明了这一点：
- en: '![](img/6a6673ed-e287-4ee1-b983-90c48f5d9f2a.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a6673ed-e287-4ee1-b983-90c48f5d9f2a.png)'
- en: 'In Linux, when we say to go to a directory, what we really mean is to make
    another directory our current one by using the `cd` command. As mentioned before,
    every directory contains two special shorthand links that you can''t change and
    you can''t remove, the `.` and the `..`, which is the name of the directory we
    are currently in. Every directory contains the name `..`, which is the name of
    the unique parent directory of the directory in which we are currently in. Also,
    every subdirectory contains exactly one parent directory, while one parent directory
    can contain multiple subdirectories. These dots are very useful for traveling
    through directories fast. To go back to the preceding directory, which in our
    case is the home directory, we can use the `..` notation. To create a subdirectory
    in a subdirectory in a subdirectory, we can use the following approach:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，当我们说要进入一个目录时，我们真正的意思是通过使用`cd`命令将另一个目录设为当前目录。如前所述，每个目录都包含两个特殊的快捷链接，你无法更改也无法删除，即`.`和`..`，它是我们当前所在目录的名称。每个目录都包含名称为`..`的链接，它是我们当前所在目录的唯一父目录的名称。此外，每个子目录都只包含一个父目录，而一个父目录可以包含多个子目录。这些点对于快速浏览目录非常有用。要返回到上一个目录，也就是我们的主目录，我们可以使用`..`符号。要在子目录中创建子目录，可以使用以下方法：
- en: '![](img/488b4c86-b24f-4c5d-b8dc-7122f94ed5d0.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/488b4c86-b24f-4c5d-b8dc-7122f94ed5d0.png)'
- en: To view the folder structure that we have just created, we can use the `pwd`
    command again. To go up one directory level, we can use `cd..`. To go back down,
    use `cd FolderD`. Now, to go up two levels of directories, you can use the folder
    separator slash symbol-`cd ../ ../`. To go back two levels in our subdirectory
    structure, we can also use the folder separator slash symbol as well. When traversing
    directories there are always many ways to do this. To go back to the home directory
    quickly, we can use several different ways. To go back to the home directory first,
    you can use some shortcuts. As we have mentioned before, the tilde symbol stands
    for the home directory, so we can easily go back to the home directory `cd ~`.
    The tilde symbol works from everywhere, so you can go back to your home directory
    from any directory you are at. Also, a very helpful shortcut is `cd -`, which
    lets you toggle between the current directory and the directory you were at before.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们刚刚创建的文件夹结构，我们可以再次使用`pwd`命令。要上升一个目录级别，我们可以使用`cd..`。要返回，使用`cd FolderD`。现在，要上升两个目录级别，你可以使用目录分隔符斜杠符号-`cd
    ../ ../`。要返回我们子目录结构的两个级别，我们也可以使用目录分隔符斜杠符号。在遍历目录时，总是有很多方法可以做到这一点。要快速返回主目录，我们可以使用几种不同的方法。首先要返回主目录，你可以使用一些快捷方式。正如我们之前提到的，波浪号符号代表主目录，所以我们可以轻松返回主目录`cd
    ~`。波浪号符号可以从任何地方使用，所以你可以从任何目录返回到你的主目录。另一个非常有用的快捷方式是`cd -`，它可以让你在当前目录和之前所在的目录之间切换。
- en: There even exists a shorter way to go back to your home directory from every
    location, using only the `cd` command without any arguments. Another way to go
    to your home directory from every location is to use the path outputted from the
    `pwd` command directly. In order to delete a directory structure that contains
    subdirectories or files, you cannot use the `rmdir` command. To delete a directory
    subtree that contains files and directories, instead, we need to use the `rm -rf`
    option, but please use it with caution as this will delete everything without
    asking, which is completely irreversible.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至存在一种更短的方法，可以在任何位置只使用`cd`命令而不带任何参数就返回到你的主目录。从任何位置进入你的主目录的另一种方法是直接使用`pwd`命令输出的路径。为了删除包含子目录或文件的目录结构，你不能使用`rmdir`命令。相反，为了删除包含文件和目录的目录子树，我们需要使用`rm
    -rf`选项，但请谨慎使用，因为这将无需询问地删除所有内容，这是完全不可逆的。
- en: To recreate the same subdirectory structure, as we showed you before in a much
    simpler form we can use the directory separator symbol with the `mkdir -p` option.
    So far, all our operations and actions on files and folders, such as `ls`, `mkdir`,
    or `mrdir`, were always in relation to the current directory, which means the
    description on how to go to the directory or file of choice was always in relation
    to the current directory. For example, we used commands to work with files and
    directories that are within our current directory. For referencing files and folders
    outside of our current directory, we use the `..` and a slash directory separator.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重新创建相同的子目录结构，我们可以使用目录分隔符符号和`mkdir -p`选项，这样我们可以以更简单的形式展示。到目前为止，我们对文件和文件夹的所有操作和动作，比如`ls`、`mkdir`或`mrdir`，都是相对于当前目录的，这意味着如何进入所选目录或文件的描述总是相对于当前目录的。例如，我们使用命令来处理位于当前目录内的文件和目录。要引用当前目录之外的文件和文件夹，我们使用`..`和斜杠目录分隔符。
- en: 'If we wanted to work on files and directories in the same directory, we just
    need the name of the resource. If we want to access a resource outside of our
    current directory, we can do this using the directory separator and the `..` notation
    to travel to the right file or directory. Now, let''s again execute the `pwd`
    command. The output of the `pwd` command is called **absolute** or **full path**.
    An absolute path is easily recognized from the leading forward slash, which is
    called the root directory, as you now know. The slash symbol means that you start
    at the top-level directory, or root directory, and continue down. An absolute
    path is literally a path of names throughout the hierarchy. A pathname specifies
    and describes how to traverse or navigate the hierarchical directory names in
    the filesystem to reach some destination object starting from the highest root
    directory, which can be a file or directory. The full path always contains complete
    information on how to go from the root directory to any destination in the filesystem.
    In other words, to go to the current directory, which is called `/home/olip/FolderA`,
    you have to traverse, from the `/root` directory, to the `home` directory, to
    the `olip` directory, and to the `FolderA` directory. To visualize this in a tree-like
    structure, use the `tree` command with the subdirectory **L 3**:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在同一目录中处理文件和目录，我们只需要资源的名称。如果我们想要访问当前目录之外的资源，我们可以使用目录分隔符和`..`符号来访问正确的文件或目录。现在，让我们再次执行`pwd`命令。`pwd`命令的输出被称为**绝对**或**完整路径**。绝对路径很容易从前导斜杠识别出来，这被称为根目录，正如你现在所知道的。斜杠符号意味着你从顶层目录，或根目录开始，然后继续向下。绝对路径实际上是一个沿着层次结构的路径。路径名指定并描述了如何遍历或导航文件系统中的分层目录名称，以达到从最高根目录开始的某个目标对象的目的。完整路径始终包含了如何从根目录到文件系统中的任何目的地的完整信息。换句话说，要进入当前目录，也就是`/home/olip/FolderA`，你必须从`/root`目录遍历到`home`目录，然后到`olip`目录，最后到`FolderA`目录。要以类似树状结构的方式可视化这一点，使用带有子目录**L
    3**的`tree`命令：
- en: '![](img/6e2770f4-c1a2-495b-9fcc-06529fc4a948.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e2770f4-c1a2-495b-9fcc-06529fc4a948.png)'
- en: It's important to remember that the absolute path works from everywhere. A relative
    path doesn't have a preceding slash. Using a relative path, for example, changing
    to `FolderA`, is always dependent on where you are at the moment in the filesystem.
    So, `cd FolderA` only works in your current position. If you re-execute the command
    somewhere else, it doesn't work. When using any Linux command that works with
    files or directories, you always have the option to either use a local path relative
    to your current directory, or to use the full and absolute path relative to the
    root directory. Oftentimes, the relative path is faster to use and often it is
    also convenient to change to the directory of the files you want to work with
    directly. But the absolute path is important for scripts or if a command needs
    to work from every directory.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，绝对路径可以从任何地方起作用。相对路径没有前导斜杠。例如，使用相对路径切换到`FolderA`，始终取决于您当前在文件系统中的位置。因此，`cd
    FolderA`仅在当前位置起作用。如果您在其他地方重新执行命令，它将无效。在使用任何与文件或目录相关的Linux命令时，您始终可以选择使用相对于当前目录的本地路径，或者使用相对于根目录的完整绝对路径。通常情况下，相对路径更快且直接切换到要直接处理的文件目录也更方便。但绝对路径对于脚本或需要从任何目录起作用的命令很重要。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started off with an introduction to the command line, file
    globbing, and quoting commands. We progressed towards practical execution by working
    with the shell, standard streams, and regular expressions. We also covered functionalities
    of `sed`, `awk`, and the Linux filesystem.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从介绍命令行、文件通配符和引用命令开始。我们通过使用shell、标准流和正则表达式来进行实际执行。我们还涵盖了`sed`、`awk`和Linux文件系统的功能。
- en: In the next chapter, we'll cover concepts pertaining to files.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涵盖与文件相关的概念。
