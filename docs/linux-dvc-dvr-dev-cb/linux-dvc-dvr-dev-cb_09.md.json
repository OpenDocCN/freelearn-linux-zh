["```\n        serial0: serial@11100 {\n            compatible = \"fsl,mpc5125-psc-uart\", \"fsl,mpc5125-psc\";\n            reg = <0x11100 0x100>;\n            interrupt-parent = <&ipic>;\n            interrupts = <40 0x8>; \n            fsl,rx-fifo-size = <16>;\n            fsl,tx-fifo-size = <16>;\n            clocks = <&clks 47>, <&clks 34>; \n            clock-names = \"ipg\", \"mclk\";\n        };\n    };\n};\n```", "```\n[label:] property-name = value;\n```", "```\ninterrupts = /bits/ 8 <17 0xc>;\nclock-frequency = /bits/ 64 <0x0000000100000000>;\n```", "```\n[label:] node-name[@unit-address] {\n    [properties definitions]\n    [child nodes]\n};\n```", "```\n    clks: clock@f00 {\n        ...\n    };\n\n    serial0: serial@11100 {\n        compatible = \"fsl,mpc5125-psc-uart\", \"fsl,mpc5125-psc\";\n        ....     \n        clocks = <&clks 47>, <&clks 34>;\n        clock-names = \"ipg\", \"mclk\";\n    };\n\n```", "```\n    aliases {\n        tty0 = &serial0;\n    };\n```", "```\n    aliases {\n        tty0 = \"/soc@80000000/serial@11100\";\n    }\n```", "```\n        ipic: interrupt-controller@c00 {\n            compatible = \"fsl,mpc5121-ipic\", \"fsl,ipic\";\n            ...\n        };\n\n        clks: clock@f00 {\n            compatible = \"fsl,mpc5121-clock\";\n            ...\n        };\n\n        serial0: serial@11100 {\n            compatible = \"fsl,mpc5125-psc-uart\", \"fsl,mpc5125-psc\";\n            ...\n            interrupt-parent = <&ipic>;\n            ...\n            clocks = <&clks 47>, <&clks 34>; \n            ...\n        };\n```", "```\n        interrupt-controller@c00 {\n            compatible = \"fsl,mpc5121-ipic\", \"fsl,ipic\";\n            ...\n            phandle = <0x2>;\n        };\n\n        clock@f00 {\n            compatible = \"fsl,mpc5121-clock\";\n            ...\n            phandle = <0x3>;\n        };\n\n        serial@11100 {\n            compatible = \"fsl,mpc5125-psc-uart\", \"fsl,mpc5125-psc\";\n            ...\n            interrupt-parent = <0x2>;\n            ...\n            clocks = <0x3 0x2f 0x3 0x22>;\n            ...\n        };\n```", "```\n# tree /proc/device-tree/proc/device-tree/\n|-- #address-cells\n|-- #size-cells\n|-- aliases\n|   |-- name\n|   |-- serial0\n|   `-- serial1\n|-- chosen\n|   |-- bootargs\n|   |-- name\n|   `-- stdout-path\n|-- compatible\n|-- cpus\n|   |-- #address-cells\n|   |-- #size-cells\n|   |-- cpu@0\n|   |   |-- clocks\n|   |   |-- compatible\n|   |   |-- device_type\n|   |   |-- enable-method\n|   |   |-- name\n|   |   `-- reg\n...\n```", "```\n# cat /proc/device-tree/compatible ; echo\nglobalscale,espressobinmarvell,armada3720marvell,armada3710\n# cat /proc/device-tree/cpus/cpu\\@0/compatible ; echo \narm,cortex-a53arm,armv8\n```", "```\n# cat /proc/device-tree/#size-cells | od -tx4\n0000000 02000000\n0000004\n# cat /proc/device-tree/cpus/cpu\\@1/reg | od -tx4\n0000000 01000000\n0000004\n```", "```\n# dtc -I fs -o espressobin-reverted.dts /proc/device-tree/\n```", "```\n# head -20 espressobin-reverted.dts\n/dts-v1/;\n\n/ {\n    #address-cells = <0x2>;\n    model = \"Globalscale Marvell ESPRESSOBin Board\";\n    #size-cells = <0x2>;\n    interrupt-parent = <0x1>;\n    compatible = \"globalscale,espressobin\", \"marvell,armada3720\", \"marvell,armada3710\";\n\n    memory@0 {\n        device_type = \"memory\";\n        reg = <0x0 0x0 0x0 0x80000000 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0>;\n    };\n\n    regulator {\n        regulator-max-microvolt = <0x325aa0>;\n        gpios-states = <0x0>;\n        regulator-boot-on;\n        enable-active-high;\n        regulator-min-microvolt = <0x1b7740>;\n..\n```", "```\n$ dpkg -L device-tree-compiler | grep '/usr/bin'\n/usr/bin\n/usr/bin/convert-dtsv0\n/usr/bin/dtc\n/usr/bin/dtdiff\n/usr/bin/fdtdump\n/usr/bin/fdtget\n/usr/bin/fdtoverlay\n/usr/bin/fdtput\n```", "```\n$ fdtdump simple_platform.dtb | head -23\n\n**** fdtdump is a low-level debugging tool, not meant for general use.\n**** If you want to decompile a dtb, you probably want\n**** dtc -I dtb -O dts <filename>\n\n/dts-v1/;\n// magic: 0xd00dfeed\n// totalsize: 0x642 (1602)\n...\n\n/ {\n    model = \"fsl,mpc8572ds\";\n    compatible = \"fsl,mpc8572ds\";\n    #address-cells = <0x00000001>;\n    #size-cells = <0x00000001>;\n    interrupt-parent = <0x00000001>;\n    chosen {\n        bootargs = \"root=/dev/sda2\";\n    };\n    aliases {\n        tty0 = \"/soc@80000000/serial@11100\";\n    };\n```", "```\n$ fdtget simple_platform.dtb /chosen bootargs\nroot=/dev/sda2\n```", "```\n$ fdtput -ts simple_platform.dtb /chosen bootargs 'root=/dev/sda1 rw'\n$ fdtget simple_platform.dtb /chosen bootargs\nroot=/dev/sda1 rw\n```", "```\n$ fdtget -l simple_platform.dtb /cpus /soc@80000000\ncpu@0\ncpu@1\ninterrupt-controller@c00\nclock@f00\nserial@11100\n```", "```\n$ fdtget -p simple_platform.dtb /cpus /soc@80000000\n#address-cells\n#size-cells\ncompatible\n#address-cells\n#size-cells\ndevice_type\nranges\nreg\nbus-frequency\n```", "```\nstruct device_node *of_find_node_by_path(const char *path);\n```", "```\nint of_property_read_u8(const struct device_node *np,\n                        const char *propname,\n                        u8 *out_value);\nint of_property_read_u16(const struct device_node *np,\n                         const char *propname,\n                         u16 *out_value);\nint of_property_read_u32(const struct device_node *np,\n                         const char *propname,\n                         u32 *out_value);\n...\n```", "```\n#define for_each_property_of_node(dn, pp) \\\n        for (pp = dn->properties; pp != NULL; pp = pp->next)\n```", "```\n#define for_each_child_of_node(parent, child) \\\n        for (child = of_get_next_child(parent, NULL); child != NULL; \\\n             child = of_get_next_child(parent, child))\n```", "```\nstatic const struct of_device_id of_chrdev_req_match[] = {\n    {\n        .compatible = \"ldddc,chrdev\",\n    },\n    {\n        .compatible = \"ldddc,chrdev-fixed\",\n        .data = &chrdev_fd,\n    },\n    {\n        .compatible = \"ldddc,chrdev-fixed_read-only\",\n        .data = &chrdev_fd_ro,\n    },\n    { /* sentinel */ }\n};\nMODULE_DEVICE_TABLE(of, of_chrdev_req_match);\n```", "```\nstatic const struct chrdev_fixed_data chrdev_fd = {\n    .label = \"cdev-fixed\",\n};\n\nstatic const struct chrdev_fixed_data chrdev_fd_ro = {\n    .label = \"cdev-fixedro\",\n    .read_only = 1, \n};\n```", "```\n--- a/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts\n+++ b/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts\n@@ -41,6 +41,10 @@\n             3300000 0x0>;\n         enable-active-high;\n     };\n+\n+    chrdev {\n+        compatible = \"ldddc,chrdev-fixed_read-only\";\n+    };\n };\n\n /* J9 */\n```", "```\nstatic int chrdev_req_probe(struct platform_device *pdev)\n{\n    struct device *dev = &pdev->dev;\n    struct device_node *np = dev->of_node;\n    const struct chrdev_fixed_data *data = of_device_get_match_data(dev);\n    struct fwnode_handle *child;\n    struct module *owner = THIS_MODULE;\n    int count, ret;\n\n    /* Check the chrdev device type */\n    if (of_device_is_compatible(np, \"ldddc,chrdev-fixed\") ||\n        of_device_is_compatible(np, \"ldddc,chrdev-fixed_read-only\")) {\n        ret = chrdev_device_register(data->label, 0,\n                         data->read_only, owner, dev);\n        if (ret)\n            dev_err(dev, \"unable to register fixed\");\n\n        return ret;\n    }\n\n    /* If we are not registering a fixed chrdev device then get\n     * the number of chrdev devices from DTS\n     */\n    count = device_get_child_node_count(dev);\n    if (count == 0)\n        return -ENODEV;\n    if (count > MAX_DEVICES)\n        return -ENOMEM;\n\n    device_for_each_child_node(dev, child) {\n        const char *label; \n        unsigned int id, ro; \n...\n```", "```\n# insmod chrdev.ko \nchrdev:chrdev_init: got major 239\n# insmod chrdev-req.ko \nchrdev cdev-fixedro@0: chrdev cdev-fixedro with id 0 added\n# ls -l /dev/cdev-fixedro\\@0 \ncrw------- 1 root root 239, 0 Feb 28 15:23 /dev/cdev-fixedro@0\n```", "```\n# ls /sys/class/chrdev/\ncdev-eeprom@2 cdev-rom@4\n```", "```\n# ls -l /sys/class/chrdev/cdev-eeprom\\@2/\ntotal 0\n-r--r--r-- 1 root root 4096 Feb 28 10:51 dev\nlrwxrwxrwx 1 root root 0 Feb 28 10:51 device -> ../../../chrdev\ndrwxr-xr-x 2 root root 0 Feb 28 10:51 power\nlrwxrwxrwx 1 root root 0 Feb 27 19:53 subsystem -> ../../../../../class/chrdev\n-rw-r--r-- 1 root root 4096 Feb 27 19:53 uevent\n```", "```\n# cat /sys/class/chrdev/cdev-eeprom\\@2/dev\n239:2\n```", "```\n--- a/chapter_4/chrdev/chrdev.c\n+++ b/chapter_4/chrdev/chrdev.c\n@@ -216,6 +288,7 @@ static int __init chrdev_init(void)\n        pr_err(\"chrdev: failed to allocate class\\n\");\n        return -ENOMEM;\n    }\n+   chrdev_class->dev_groups = chrdev_groups;\n\n    /* Allocate a region for character devices */\n    ret = alloc_chrdev_region(&chrdev_devt, 0, MAX_DEVICES, \"chrdev\");\n```", "```\nstatic struct attribute *chrdev_attrs[] = {\n    &dev_attr_id.attr,\n    &dev_attr_reset_to.attr,\n    &dev_attr_read_only.attr,\n    NULL,\n};\n\nstatic const struct attribute_group chrdev_group = {\n    .attrs = chrdev_attrs,\n};\n\nstatic const struct attribute_group *chrdev_groups[] = {\n    &chrdev_group,\n    NULL,\n};\n```", "```\nstatic ssize_t id_show(struct device *dev,\n                struct device_attribute *attr, char *buf)\n{\n    struct chrdev_device *chrdev = dev_get_drvdata(dev);\n\n    return sprintf(buf, \"%d\\n\", chrdev->id);\n}\nstatic DEVICE_ATTR_RO(id);\n```", "```\nstatic ssize_t reset_to_store(struct device *dev,\n                struct device_attribute *attr,\n                const char *buf, size_t count)\n{\n    struct chrdev_device *chrdev = dev_get_drvdata(dev);\n\n    if (count > BUF_LEN)\n        count = BUF_LEN;\n    memcpy(chrdev->buf, buf, count);\n\n    return count;\n}\nstatic DEVICE_ATTR_WO(reset_to);\n```", "```\nstatic ssize_t read_only_show(struct device *dev,\n                struct device_attribute *attr, char *buf)\n{\n    struct chrdev_device *chrdev = dev_get_drvdata(dev);\n\n    return sprintf(buf, \"%d\\n\", chrdev->read_only);\n}\n\nstatic ssize_t read_only_store(struct device *dev,\n                struct device_attribute *attr,\n                const char *buf, size_t count)\n{\n    struct chrdev_device *chrdev = dev_get_drvdata(dev);\n    int data, ret;\n\n    ret = sscanf(buf, \"%d\", &data);\n    if (ret != 1)\n        return -EINVAL;\n\n    chrdev->read_only = !!data;\n\n    return count;\n}\nstatic DEVICE_ATTR_RW(read_only);\n```", "```\n# ls -l /sys/class/chrdev/cdev-eeprom\\@2/\ntotal 0\n-r--r--r-- 1 root root 4096 Feb 28 13:45 dev\nlrwxrwxrwx 1 root root 0 Feb 28 13:45 device -> ../../../chrdev\n-r--r--r-- 1 root root 4096 Feb 28 13:45 id\ndrwxr-xr-x 2 root root 0 Feb 28 13:45 power\n-rw-r--r-- 1 root root 4096 Feb 28 13:45 read_only\n--w------- 1 root root 4096 Feb 28 13:45 reset_to\nlrwxrwxrwx 1 root root 0 Feb 28 13:45 subsystem -> ../../../../../class/chrdev\n-rw-r--r-- 1 root root 4096 Feb 28 13:45 uevent\n```", "```\n# cat /sys/class/chrdev/cdev-eeprom\\@2/id \n2\n# cat /sys/class/chrdev/cdev-eeprom\\@2/read_only \n0\n# cat /sys/class/chrdev/cdev-eeprom\\@2/reset_to \ncat: /sys/class/chrdev/cdev-eeprom@2/reset_to: Permission denied\n```", "```\n# cat /sys/class/chrdev/cdev-rom\\@4/id \n4\n# cat /sys/class/chrdev/cdev-rom\\@4/read_only \n1\n```", "```\n# echo \"THIS IS A READ ONLY DEVICE!\" > /sys/class/chrdev/cdev-rom\\@4/reset_to \n```", "```\n# cat /dev/cdev-rom\\@4\nTHIS IS A READ ONLY DEVICE!\n```", "```\n# echo 0 > /sys/class/chrdev/cdev-rom\\@4/read_only\n```", "```\nroot@espressobin:~# echo \"TEST STRING\" > /dev/cdev-rom\\@4 \nchrdev cdev-rom@4: chrdev (id=4) opened\nchrdev cdev-rom@4: should write 12 bytes (*ppos=0)\nchrdev cdev-rom@4: got 12 bytes (*ppos=12)\nchrdev cdev-rom@4: chrdev (id=4) released\n```", "```\n   pinctrl_nb: pinctrl@13800 {\n        compatible = \"marvell,armada3710-nb-pinctrl\",\n                 \"syscon\", \"simple-mfd\";\n        reg = <0x13800 0x100>, <0x13C00 0x20>;\n        /* MPP1[19:0] */\n        gpionb: gpio {\n            #gpio-cells = <2>;\n            gpio-ranges = <&pinctrl_nb 0 0 36>;\n            gpio-controller;\n            interrupt-controller;\n            #interrupt-cells = <2>;\n            interrupts =\n            <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>,\n            <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>,\n            <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>,\n            <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>,\n            <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>,\n            <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>,\n            <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>,\n            <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>,\n            <GIC_SPI 152 IRQ_TYPE_LEVEL_HIGH>,\n            <GIC_SPI 153 IRQ_TYPE_LEVEL_HIGH>,\n            <GIC_SPI 154 IRQ_TYPE_LEVEL_HIGH>,\n            <GIC_SPI 155 IRQ_TYPE_LEVEL_HIGH>;\n        };\n\n        xtalclk: xtal-clk {\n            compatible = \"marvell,armada-3700-xtal-clock\";\n            clock-output-names = \"xtal\"; \n            #clock-cells = <0>;\n        };\n\n        spi_quad_pins: spi-quad-pins {\n            groups = \"spi_quad\";\n            function = \"spi\";\n        };\n...\n```", "```\nstatic struct armada_37xx_pin_group armada_37xx_nb_groups[] = {\n    PIN_GRP_GPIO(\"jtag\", 20, 5, BIT(0), \"jtag\"),\n    PIN_GRP_GPIO(\"sdio0\", 8, 3, BIT(1), \"sdio\"),\n    PIN_GRP_GPIO(\"emmc_nb\", 27, 9, BIT(2), \"emmc\"),\n    PIN_GRP_GPIO(\"pwm0\", 11, 1, BIT(3), \"pwm\"),\n    PIN_GRP_GPIO(\"pwm1\", 12, 1, BIT(4), \"pwm\"),\n    PIN_GRP_GPIO(\"pwm2\", 13, 1, BIT(5), \"pwm\"),\n    PIN_GRP_GPIO(\"pwm3\", 14, 1, BIT(6), \"pwm\"),\n    PIN_GRP_GPIO(\"pmic1\", 17, 1, BIT(7), \"pmic\"),\n    PIN_GRP_GPIO(\"pmic0\", 16, 1, BIT(8), \"pmic\"),\n    PIN_GRP_GPIO(\"i2c2\", 2, 2, BIT(9), \"i2c\"),\n    PIN_GRP_GPIO(\"i2c1\", 0, 2, BIT(10), \"i2c\"),\n    PIN_GRP_GPIO(\"spi_cs1\", 17, 1, BIT(12), \"spi\"),\n    PIN_GRP_GPIO_2(\"spi_cs2\", 18, 1, BIT(13) | BIT(19), 0, BIT(13), \"spi\"),\n    PIN_GRP_GPIO_2(\"spi_cs3\", 19, 1, BIT(14) | BIT(19), 0, BIT(14), \"spi\"),\n    PIN_GRP_GPIO(\"onewire\", 4, 1, BIT(16), \"onewire\"),\n    PIN_GRP_GPIO(\"uart1\", 25, 2, BIT(17), \"uart\"),\n    PIN_GRP_GPIO(\"spi_quad\", 15, 2, BIT(18), \"spi\"),\n    PIN_GRP_EXTRA(\"uart2\", 9, 2, BIT(1) | BIT(13) | BIT(14) | BIT(19),\n              BIT(1) | BIT(13) | BIT(14), BIT(1) | BIT(19),\n              18, 2, \"gpio\", \"uart\"),\n    PIN_GRP_GPIO(\"led0_od\", 11, 1, BIT(20), \"led\"),\n    PIN_GRP_GPIO(\"led1_od\", 12, 1, BIT(21), \"led\"),\n    PIN_GRP_GPIO(\"led2_od\", 13, 1, BIT(22), \"led\"),\n    PIN_GRP_GPIO(\"led3_od\", 14, 1, BIT(23), \"led\"),\n\n};\n```", "```\n/* Exported on the micro USB connector J5 through an FTDI */\n&uart0 {\n    pinctrl-names = \"default\";\n    pinctrl-0 = <&uart1_pins>;\n    status = \"okay\";\n};\n```", "```\n    iomuxc_lpsr: iomuxc-lpsr@302c0000 {\n        compatible = \"fsl,imx7d-iomuxc-lpsr\";\n        reg = <0x302c0000 0x10000>;\n        fsl,input-sel = <&iomuxc>;\n    };\n\n    iomuxc: iomuxc@30330000 {\n        compatible = \"fsl,imx7d-iomuxc\";\n        reg = <0x30330000 0x10000>;\n    };\n```", "```\nenum imx7d_lpsr_pads {\n    MX7D_PAD_GPIO1_IO00 = 0,\n    MX7D_PAD_GPIO1_IO01 = 1,\n    MX7D_PAD_GPIO1_IO02 = 2,\n    MX7D_PAD_GPIO1_IO03 = 3,\n    MX7D_PAD_GPIO1_IO04 = 4,\n    MX7D_PAD_GPIO1_IO05 = 5,\n    MX7D_PAD_GPIO1_IO06 = 6,\n    MX7D_PAD_GPIO1_IO07 = 7,\n};\n```", "```\n...\n    panel {\n        compatible = \"innolux,at043tn24\";\n        pinctrl-0 = <&pinctrl_backlight>;\n        enable-gpios = <&gpio1 1 GPIO_ACTIVE_HIGH>;\n        power-supply = <&reg_lcd_3v3>;\n\n        port {\n            panel_in: endpoint {\n                remote-endpoint = <&display_out>; \n            };\n        };\n    };\n};\n...\n&wdog1 {\n    pinctrl-names = \"default\";\n    pinctrl-0 = <&pinctrl_wdog>;\n    fsl,ext-reset-output;\n};\n...\n&iomuxc_lpsr {\n    pinctrl_wdog: wdoggrp {\n        fsl,pins = <\n            MX7D_PAD_LPSR_GPIO1_IO00__WDOG1_WDOG_B 0x74\n        >;\n    };\n\n    pinctrl_backlight: backlightgrp {\n        fsl,pins = <\n            MX7D_PAD_LPSR_GPIO1_IO01__GPIO1_IO1 0x110b0\n        >;\n    };\n};\n```", "```\n    pinctrl@fffff200 {\n        #address-cells = <1>;\n        #size-cells = <1>;\n        compatible = \"atmel,sama5d3-pinctrl\", \"atmel,at91sam9x5-pinctrl\", \"simple-bus\";\n        ranges = <0xfffff200 0xfffff200 0xa00>;\n        atmel,mux-mask = <\n            /* A B C */\n            0xffffffff 0xc0fc0000 0xc0ff0000 /* pioA */\n            0xffffffff 0x0ff8ffff 0x00000000 /* pioB */\n            0xffffffff 0xbc00f1ff 0x7c00fc00 /* pioC */\n            0xffffffff 0xc001c0e0 0x0001c1e0 /* pioD */\n            0xffffffff 0xbf9f8000 0x18000000 /* pioE */\n            >;\n\n        /* shared pinctrl settings */\n        adc0 {\n            pinctrl_adc0_adtrg: adc0_adtrg {\n                atmel,pins =\n                    <AT91_PIOD 19 AT91_PERIPH_A AT91_PINCTRL_NONE>; /* PD19 periph A ADTRG */\n            };\n            pinctrl_adc0_ad0: adc0_ad0 {\n                atmel,pins =\n                    <AT91_PIOD 20 AT91_PERIPH_A AT91_PINCTRL_NONE>; /* PD20 periph A AD0 */\n            };\n...\n            pinctrl_adc0_ad7: adc0_ad7 {\n                atmel,pins =\n                    <AT91_PIOD 27 AT91_PERIPH_A AT91_PINCTRL_NONE>; /* PD27 periph A AD7 */\n...\n```", "```\n    adc0: adc@f8018000 {\n        atmel,adc-vref = <3300>; \n        atmel,adc-channels-used = <0xfe>; \n        pinctrl-0 = <\n            &pinctrl_adc0_adtrg\n            &pinctrl_adc0_ad1\n            &pinctrl_adc0_ad2\n            &pinctrl_adc0_ad3\n            &pinctrl_adc0_ad4\n            &pinctrl_adc0_ad5\n            &pinctrl_adc0_ad6\n            &pinctrl_adc0_ad7\n            >;\n        status = \"okay\"; \n    };\n```", "```\n$ make KERNEL_DIR=../../../linux\nmake -C ../../../linux \\\n            ARCH=arm64 \\\n            CROSS_COMPILE=aarch64-linux-gnu- \\\n            SUBDIRS=/home/giometti/Projects/ldddc/github/chapter_4/chrdev modules\nmake[1]: Entering directory '/home/giometti/Projects/ldddc/linux'\n  CC [M] /home/giometti/Projects/ldddc/github/chapter_4/chrdev/chrdev.o\n  CC [M] /home/giometti/Projects/ldddc/github/chapter_4/chrdev/chrdev-req.o\n...\n  LD [M] /home/giometti/Projects/ldddc/github/chapter_4/chrdev/chrdev.ko\nmake[1]: Leaving directory '/home/giometti/Projects/ldddc/linux'\n```", "```\n# insmod chrdev.ko\nchrdev: loading out-of-tree module taints kernel.\nchrdev:chrdev_init: got major 239\n```", "```\n# insmod chrdev-req.ko \nchrdev cdev-eeprom@2: chrdev cdev-eeprom with id 2 added\nchrdev cdev-rom@4: chrdev cdev-rom with id 4 added\n```", "```\n# ls -l /dev/cdev*\ncrw------- 1 root root 239, 2 Feb 27 18:35 /dev/cdev-eeprom@2\ncrw------- 1 root root 239, 4 Feb 27 18:35 /dev/cdev-rom@4\n```", "```\n# echo \"TEST STRING\" > /dev/cdev-eeprom\\@2 \n# cat /dev/cdev-eeprom\\@2\nTEST STRING\n```", "```\nchrdev cdev-eeprom@2: chrdev (id=2) opened\nchrdev cdev-eeprom@2: should write 12 bytes (*ppos=0)\nchrdev cdev-eeprom@2: got 12 bytes (*ppos=12)\nchrdev cdev-eeprom@2: chrdev (id=2) released\nchrdev cdev-eeprom@2: chrdev (id=2) opened\nchrdev cdev-eeprom@2: should read 131072 bytes (*ppos=0)\nchrdev cdev-eeprom@2: return 300 bytes (*ppos=300)\nchrdev cdev-eeprom@2: should read 131072 bytes (*ppos=300)\nchrdev cdev-eeprom@2: return 0 bytes (*ppos=300)\nchrdev cdev-eeprom@2: chrdev (id=2) released\n```", "```\n# echo \"TEST STRING\" > /dev/cdev-rom\\@4 \n-bash: echo: write error: Invalid argument\n# cat /dev/cdev-rom\\@4 \n```", "```\n# od -tx1 -N 16 /dev/cdev-rom\\@4 \n0000000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n0000020\n```", "```\nchrdev cdev-rom@4: chrdev (id=4) opened\nchrdev cdev-rom@4: should write 12 bytes (*ppos=0)\nchrdev cdev-rom@4: chrdev (id=4) released\nchrdev cdev-rom@4: chrdev (id=4) opened\nchrdev cdev-rom@4: should read 131072 bytes (*ppos=0)\nchrdev cdev-rom@4: return 300 bytes (*ppos=300)\nchrdev cdev-rom@4: should read 131072 bytes (*ppos=300)\nchrdev cdev-rom@4: return 0 bytes (*ppos=300)\nchrdev cdev-rom@4: chrdev (id=4) released\nchrdev cdev-rom@4: chrdev (id=4) opened\nchrdev cdev-rom@4: should read 16 bytes (*ppos=0)\nchrdev cdev-rom@4: return 16 bytes (*ppos=16)\nchrdev cdev-rom@4: chrdev (id=4) released\n```"]