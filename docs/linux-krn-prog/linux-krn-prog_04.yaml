- en: Building the 5.x Linux Kernel from Source - Part 2
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码构建5.x Linux内核 - 第2部分
- en: This chapter continues where the previous chapter left off. In the previous
    chapter, in the *Steps to build the kernel from source *section*,* we covered
    the first three steps of building our kernel. There, you learned how to download
    and extract the kernel source tree or even `git clone` one (*steps 1* and *2*).
    We then proceeded to understand the kernel source tree layout, and, very importantly,
    the various approaches to correctly arrive at a starting point to configure the
    kernel (*step 3*). We even added a custom menu item to the kernel config menu.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章继续上一章的内容。在上一章中，在“从源代码构建内核的步骤”部分，我们涵盖了构建内核的前三个步骤。在那里，您学会了如何下载和提取内核源树，甚至是`git
    clone`（*步骤1*和*2*）。然后，我们继续了解内核源树布局，以及正确到达配置内核起始点的各种方法（*步骤3*）。我们甚至在内核配置菜单中添加了自定义菜单项。
- en: In this chapter, we continue our quest to build the kernel, by, well, covering
    the remaining four steps to actually build it. First, of course, we build it (*step
    4*). You will then see how to properly install the kernel modules that get generated
    as part of the build (*step 5*). Next, we run a simple command that sets up the
    GRUB bootloader and generates the `initramfs` (or `initrd`) image (*step 6*).
    The motivation for using an `initramfs` image and how it's used are discussed
    as well. Some details on configuring the GRUB bootloader (for x86) are then covered
    (*step 7*).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续我们的内核构建任务，覆盖了剩下的四个步骤来实际构建它。首先，当然，我们要构建它（*步骤4*）。然后您将看到如何正确安装作为构建的一部分生成的内核模块（*步骤5*）。接下来，我们运行一个简单的命令来设置GRUB引导加载程序并生成`initramfs`（或`initrd`）镜像（*步骤6*）。还讨论了使用`initramfs`镜像的动机以及它的使用方式。然后介绍了一些有关配置GRUB引导加载程序（对于x86）的细节（*步骤7*）。
- en: By the end of the chapter, we'll boot the system with our new kernel image and
    verify that it's built as expected. We'll then finish off by learning how to *cross-compile*
    a Linux kernel for a foreign architecture (that is, ARM, the board in question
    being the well-known Raspberry Pi).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，我们将使用新的内核镜像引导系统，并验证它是否按预期构建。然后，我们将学习如何为外部架构（即ARM，所讨论的板子是著名的树莓派）*交叉编译*
    Linux内核。
- en: 'Briefly, these are the areas covered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，涵盖的领域如下：
- en: Step 4 – building the kernel image and modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4步 - 构建内核镜像和模块
- en: Step 5 – installing the kernel modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第5步 - 安装内核模块
- en: Step 6 – generating the initramfs image and bootloader setup
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第6步 - 生成initramfs镜像和引导加载程序设置
- en: Understanding the initramfs framework
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解initramfs框架
- en: Step 7 – customizing the GRUB bootloader
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第7步 - 自定义GRUB引导加载程序
- en: Verifying our new kernel's configuration
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证我们新内核的配置
- en: Kernel build for the Raspberry Pi
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派的内核构建
- en: Miscellaneous tips on the kernel build
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核构建的其他提示
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before we begin, I assume that you have downloaded, extracted (if required),
    and configured the kernel, thus having a `.config` file ready. If you haven't
    already, please refer to the previous chapter for the details on how exactly this
    is done. We can now proceed to build it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我假设您已经下载、提取（如果需要）并配置了内核，因此有一个`.config`文件准备好了。如果您还没有，请参考上一章，了解如何确切地完成这些步骤。现在我们可以继续构建它了。
- en: Step 4 – building the kernel image and modules
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4步 - 构建内核镜像和模块
- en: Performing the build from the end user point of view is actually quite simple.
    In its simplest form, just ensure you're in the root of the configured kernel
    source tree and type `make`. That's it – the kernel image and any kernel modules
    (and, on an embedded system, possibly a **Device Tree Blob** (**DTB**) binary)
    will get built. Grab a coffee! The first time around, it could take a while.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从最终用户的角度来看，执行构建实际上非常简单。在最简单的形式中，只需确保您在配置的内核源树的根目录中，并键入`make`。就是这样 - 内核镜像和任何内核模块（在嵌入式系统上可能还有**设备树二进制**（**DTB**））将被构建。喝杯咖啡吧！第一次可能需要一段时间。
- en: 'Of course, there are various `Makefile` targets we can pass to `make`. A quick
    `make help` command issued on the command line reveals quite a bit. Remember,
    we used this earlier, in fact, to see all possible configuration targets. Here,
    we use it to see what gets built by default with the `all` target:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以向`make`传递各种`Makefile`目标。在命令行上快速发出`make help`命令会显示相当多的信息。请记住，实际上我们之前就用过这个命令，事实上，以查看所有可能的配置目标。在这里，我们用它来查看`all`目标默认构建了什么：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Okay, so performing `make all` will get us the preceding three targets, the
    ones prefixed with `*`; what do they mean?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，执行`make all`将得到前面三个带有`*`前缀的目标；它们代表什么意思呢？
- en: '`vmlinux` actually matches the name of the uncompressed kernel image.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vmlinux`实际上与未压缩的内核镜像的名称相匹配。'
- en: The `modules` target implies that all kernel config options marked as `m` (for
    module) will be built as kernel modules (`.ko` files) within the kernel source
    tree (details on what exactly a kernel module is and how to program one are the
    subject matter of the following two chapters).
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modules`目标意味着所有标记为`m`（用于模块）的内核配置选项将作为内核模块（`.ko`文件）构建在内核源树中（有关内核模块的具体内容以及如何编程的细节将在接下来的两章中讨论）。'
- en: '`bzImage` is architecture-specific. On an x86[-64] system, this is the name
    of the compressed kernel image – the one the bootloader will actually load into
    RAM, uncompress in memory, and boot into; in effect, the kernel image file.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bzImage`是特定于架构的。在x86[-64]系统上，这是压缩内核镜像的名称 - 引导加载程序实际加载到RAM中并在内存中解压缩并引导的镜像文件。'
- en: 'So, an FAQ: if `bzImage` is the actual kernel that we use to boot and initialize
    the system, then what''s `vmlinux` for? Notice that `vmlinux` is the uncompressed
    kernel image. It can be large (even very large, in the presence of kernel symbols
    generated during a debug build). While we never boot via `vmlinux`, it''s nevertheless
    important. Do keep it around for kernel debugging purposes (which are unfortunately
    beyond the scope of this book).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，一个常见问题：如果`bzImage`是我们用来引导和初始化系统的实际内核，那么`vmlinux`是用来做什么的？请注意，`vmlinux`是未压缩的内核映像。它可能很大（甚至在调试构建期间生成的内核符号存在时非常大）。虽然我们从不通过`vmlinux`引导，但它仍然很重要。出于内核调试目的，请保留它（不幸的是，这超出了本书的范围）。
- en: With the kbuild system, just running a `make` command equates to `make all`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用kbuild系统，只需运行`make`命令就相当于`make all`。
- en: 'The kernel code base is enormous. Current estimates are in the region of 20
    million **source lines of code** (**SLOC**), thus, building the kernel is indeed
    *a very memory- and CPU-intensive job.* Indeed, some folks use the kernel build
    as a stress test! The modern `make(1)` utility is powerful and multi-process capable.
    We can request it to spawn multiple processes to handle different (unrelated)
    parts of the build in parallel, leading to higher throughput and thus shorter
    build times. The relevant option is `-j''n''`, where `n` is the upper limit on
    the number of tasks to spawn and run in parallel. A heuristic (rule of thumb)
    used to determine this is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 内核代码库非常庞大。目前的估计在2000万**源代码行**（**SLOC**）左右，因此，构建内核确实是*一个非常占用内存和CPU的工作*。事实上，有些人使用内核构建作为压力测试！现代的`make(1)`实用程序功能强大，能够处理多个进程。我们可以要求它生成多个进程来并行处理构建的不同（无关）部分，从而提高吞吐量，缩短构建时间。相关选项是`-j'n'`，其中`n`是并行运行的任务数量的上限。用于确定这一点的启发式（经验法则）如下：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `factor` is 2 (or 1.5 on very high-end systems with hundreds of CPU cores).
    Also, technically, we require the cores to be internally "threaded" or using **Simultaneous
    Multi-Threading** (**SMT**) – what Intel calls *Hyper-Threading* – for this heuristic
    to be useful.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`factor`是2（或者在具有数百个CPU核心的高端系统上为1.5）。从技术上讲，我们需要内部的核心是“线程化”的或者使用**同时多线程**（**SMT**）-这是英特尔所称的*超线程*，这样启发式才有用。
- en: More details on parallelized `make` and how it works can be found in the man
    page of `make(1)` (invoked with `man 1 make`) in the `PARALLEL MAKE AND THE JOBSERVER` section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有关并行化`make`及其工作原理的更多详细信息可以在`make(1)`的man页面中找到（使用`man 1 make`调用），在`PARALLEL MAKE
    AND THE JOBSERVER`部分。
- en: 'Another FAQ: how many CPU cores *are* there on your system? There are several
    ways to determine this, an easy one being to use the `nproc(1)` utility:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见问题：您的系统上有多少CPU核心？有几种方法可以确定这一点，其中一种简单的方法是使用`nproc(1)`实用程序：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A quick word regarding `nproc(1)` and related utilities:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`nproc(1)`和相关实用程序的一点说明：
- en: a) Performing `strace(1)` on `nproc(1)` reveals that it works by essentially
    using the `sched_getaffinity(2)` system call. We shall mention more on this and
    related system calls in [Chapter 9](5391e3c1-30ad-4c75-a106-301259064881.xhtml),
    *The CPU Scheduler – Part 1*, and [Chapter 10](d6e5ebd3-1f04-40e8-a240-2607c58b1299.xhtml),
    *The CPU Scheduler – Part 2*, on CPU scheduling.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: a) 对`nproc(1)`执行`strace(1)`会发现它基本上是使用`sched_getaffinity(2)`系统调用。我们将在[第9章](5391e3c1-30ad-4c75-a106-301259064881.xhtml)
    *CPU调度器-第1部分*和[第10章](d6e5ebd3-1f04-40e8-a240-2607c58b1299.xhtml) *CPU调度器-第2部分*中提到更多关于这个和相关系统调用的内容。
- en: b) FYI, the `lscpu(1)` utility yields the number of cores as well as additional
    useful CPU info. For example, it shows whether it's running on a **Virtual Machine**
    (**VM**) (as does the `virt-what` script). Try it out on your Linux system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: b) FYI，`lscpu(1)`实用程序提供核心数以及其他有用的CPU信息。例如，它显示是否在**虚拟机**（**VM**）上运行（`virt-what`脚本也是如此）。在Linux系统上试一下。
- en: Clearly, our guest VM has been configured with two CPU cores, so let's keep
    `n=2*2=4`. So, off we go and build the kernel. The following output is from our
    trusty x86_64 Ubuntu 18.04 LTS guest system configured to have 2 GB of RAM and
    two CPU cores.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们的客户机虚拟机已配置为具有两个CPU核心，因此让`n=2*2=4`。所以，我们开始构建内核。以下输出来自我们可靠的x86_64 Ubuntu
    18.04 LTS客户机系统，配置为具有2GB的RAM和两个CPU核心。
- en: Remember, the kernel must first be *configured. *For details, refer to [Chapter
    2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building the 5.x Linux Kernel
    from Source – Part 1*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，内核必须首先*配置。*有关详细信息，请参阅[第2章](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml) *从源代码构建5.x
    Linux内核-第1部分*。
- en: 'Again, when you begin, it''s entirely possible that the kernel build emits
    a warning, although non-fatal in this case:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，当您开始时，内核构建可能会发出警告，尽管在这种情况下不是致命的：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, to address this, we break off the build with *Ctrl* + *C*, then follow
    the output''s advice and install the `libelf-dev` package. On our Ubuntu box,
    `sudo apt install libelf-dev` is sufficient. If you followed the detailed setup
    in [Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml), *Kernel Workspace
    Setup*, this will not happen. Retry, and it now works! To give you a feel of this,
    we''ve show the following tiny snippets of the build output. Really though, it''s
    best to just try it out yourself:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了解决这个问题，我们中断构建，使用*Ctrl* + *C*，然后按照输出的建议安装`libelf-dev`软件包。在我们的Ubuntu系统上，`sudo
    apt install libelf-dev`就足够了。如果您按照[第1章](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml)
    *内核工作区设置*中的详细设置进行操作，这种情况就不会发生。重试，现在它可以工作了！为了让您感受一下，我们展示了构建输出的一些小片段。但是，最好还是自己尝试一下：
- en: Precisely because the kernel build is very CPU- and RAM-intensive, carrying
    this out on a guest VM is going to be a lot slower than on a native Linux system.
    It helps to conserve RAM by at least booting your guest at run-level 3 (multiuser
    with networking, no GUI): [https://www.if-not-true-then-false.com/2012/howto-change-runlevel-on-grub2/](https://www.if-not-true-then-false.com/2012/howto-change-runlevel-on-grub2/).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正因为内核构建非常依赖CPU和RAM，因此在虚拟机上进行这项工作要比在本机Linux系统上慢得多。通过至少将客户机引导到运行级别3（多用户网络，无GUI）来节省RAM是有帮助的：[https://www.if-not-true-then-false.com/2012/howto-change-runlevel-on-grub2/](https://www.if-not-true-then-false.com/2012/howto-change-runlevel-on-grub2/)。
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Okay, the kernel image (here, it''s called `bzImage`) and the `vmlinux` file
    have successfully been built by stitching together the various object files generated,
    as can be seen in the preceding output – the last line in the preceding block
    confirms this fact. But hang on, the build isn''t done yet. The kbuild system
    now proceeds to finish building all kernel modules; the last portion of the output
    is shown as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，内核映像（在这里称为`bzImage`）和`vmlinux`文件已经成功地通过拼接生成的各种目标文件构建，正如在先前的输出中所见 - 先前块的最后一行确认了这一事实。但是，请稍等，构建还没有完成。kbuild系统现在继续完成所有内核模块的构建；输出的最后部分如下所示：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The entire process seems to have taken a total of around 17.5 minutes. The `time(1)`
    utility gives us a (very) coarse-grained idea of the time taken by the command
    that follows it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程似乎总共花了大约17.5分钟。`time(1)`实用程序给出了一个（非常）粗略的时间概念，即后面的命令所花费的时间。
- en: If you'd like accurate CPU profiling, learn to use the powerful `perf(1)` utility.
    Here, you can try it out with the `perf stat make -j4` command. I suggest you
    try this out on a distro kernel as otherwise, `perf` itself will have to be manually
    built for your custom kernel.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要准确的CPU分析，请学会使用强大的`perf(1)`实用程序。在这里，您可以尝试使用`perf stat make -j4`命令。我建议您在发行版内核上尝试此操作，否则，`perf`本身将必须为您的自定义内核手动构建。
- en: 'Also, in the previous output, `Kernel: arch/x86/boot/bzImage is ready (#1)`,
    `#1` implies it''s the very first build of this kernel. This number will auto-increment
    on subsequent builds and show up when you boot into the new kernel and then execute `uname
    -a`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，在先前的输出中，`Kernel: arch/x86/boot/bzImage is ready (#1)`，`#1`意味着这是内核的第一个构建。此数字将在后续构建中自动递增，并在您引导到新内核然后执行`uname
    -a`时显示。'
- en: As we're doing a parallelized build (via `make -j4`, implying four processes
    performing the build in parallel), all the build processes still write to the
    same `stdout` location – the terminal window. Hence, it can happen that the output
    is out of order or mixed up.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在进行并行构建（通过`make -j4`，意味着四个进程并行执行构建），所有构建过程仍然写入相同的`stdout`位置 - 终端窗口。因此，输出可能是无序或混乱的。
- en: The build should run cleanly, without any errors or warnings. Well, at times
    compiler warnings are seen, but we shall blithely ignore them. What if you encounter
    compiler errors and thus a failed build during this step? How can we put this
    politely? Oh well, we cannot – it's very likely your fault, not the kernel community's.
    Please check and re-check every step, redoing it from scratch with a `make mrproper` command
    if all else fails! Very often, a failure to build the kernel implies either kernel
    configuration errors (randomly selected configs that might conflict), outdated
    versions of the toolchain, or incorrect patching, among other things.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应该干净地运行，没有任何错误或警告。嗯，有时会看到编译器警告，但我们将轻松地忽略它们。如果在此步骤中遇到编译器错误，从而导致构建失败，怎么办？我们怎么委婉地表达这？哦，好吧，我们不能
    - 这很可能是您的问题，而不是内核社区的问题。请检查并重新检查每一步，如果一切都失败了，请使用`make mrproper`命令从头开始重做！很多时候，内核构建失败意味着内核配置错误（可能会冲突的随机选择的配置）、工具链的过时版本或不正确的打补丁，等等。
- en: Assuming it goes off well, as indeed it should, by the time this step terminates,
    three key files (among many) have been generated by the kbuild system.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一切顺利，正如它应该的那样，在此步骤终止时，kbuild系统已生成了三个关键文件（其中有许多）。
- en: 'In the root of the kernel source tree, we have the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核源树的根目录中，我们有以下内容：
- en: The uncompressed kernel image file, `vmlinux` (only for debugging)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未压缩的内核映像文件`vmlinux`（仅用于调试）
- en: The symbol-address mapping file, `System.map`
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号地址映射文件`System.map`
- en: The compressed bootable kernel image file, `bzImage` (see the following output)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩的可引导内核映像文件`bzImage`（请参阅以下输出）
- en: 'Let''s check them out! We make the output (specifically the file size) more
    human-readable by passing the `-h` option to `ls(1)`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看它们！通过向`ls(1)`传递`-h`选项，我们使输出（特别是文件大小）更易于阅读：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, the `vmlinux` file is pretty huge. This is because it contains
    all the kernel symbols as well as extra debug information encoded into it. (FYI,
    the `vmlinux` and `System.map` files are used in the kernel debug context; keep
    them around.) The useful `file(1)` utility shows us more detail regarding this
    image file. The actual kernel image file that the bootloader loads up and boots
    into will always be in the generic location of `arch/<arch>/boot/`; hence, for
    the x86 architecture, we have the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`vmlinux`文件非常庞大。这是因为它包含了所有内核符号以及额外的调试信息编码进去。（顺便说一句，`vmlinux`和`System.map`文件在内核调试上下文中使用；保留它们。）有用的`file(1)`实用程序向我们展示了有关此映像文件的更多细节。引导加载程序加载并引导的实际内核映像文件将始终位于`arch/<arch>/boot/`的通用位置；因此，对于x86架构，我们有以下内容：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The compressed kernel image version `5.4.0-llkd01` for the x86_64 is a little
    over 8 MB in size. The `file(1)` utility again clearly reveals that indeed it
    is a Linux kernel boot image for the x86 architecture.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: x86_64架构的压缩内核映像版本`5.4.0-llkd01`大小略大于8MB。`file(1)`实用程序再次清楚地显示它确实是用于x86架构的Linux内核引导映像。
- en: The kernel documents several tweaks and switches that can be performed during
    the kernel build by setting various environment variables. This documentation
    can be found within the kernel source tree at `Documentation/kbuild/kbuild.rst`. We
    shall in fact use the `INSTALL_MOD_PATH`,  `ARCH`, and `CROSS_COMPILE` environment
    variables in the material that follows.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 内核文档记录了在内核构建过程中可以通过设置各种环境变量执行的几个调整和开关。此文档可以在内核源树中的`Documentation/kbuild/kbuild.rst`找到。实际上，我们将在接下来的材料中使用`INSTALL_MOD_PATH`、`ARCH`和`CROSS_COMPILE`环境变量。
- en: Great! Our kernel image and modules are ready! Read on as we install the kernel
    modules as part of our next step.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们的内核映像和模块已经准备就绪！继续阅读，因为我们将在下一步中安装内核模块。
- en: Step 5 – installing the kernel modules
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5步 - 安装内核模块
- en: 'In the previous step, all the kernel config options that were marked as `m` have
    actually now been built. As you shall learn, that''s not quite enough: they must
    now be installed into a known location on the system. This section covers these
    details.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一步中，所有标记为`m`的内核配置选项实际上现在都已经构建完成。正如你将了解的那样，这还不够：它们现在必须被安装到系统上已知的位置。本节涵盖了这些细节。
- en: Locating the kernel modules within the kernel source
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在内核源代码中定位内核模块
- en: 'To see the kernel modules just generated by the previous step – the kernel
    build – let''s perform a quick `find(1)` command within the kernel source folder.
    Understand the naming convention used, where kernel module filenames end in `.ko`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看前一步生成的内核模块 - 内核构建 - 让我们在内核源文件夹中执行一个快速的`find(1)`命令。了解所使用的命名约定，其中内核模块文件名以`.ko`结尾。
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see from the preceding output that, in this particular build, a total
    of 59 kernel modules have happened to be built (the actual `find` output is truncated
    in the preceding block for brevity).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前面的输出中看到，在这个特定的构建中，总共构建了59个内核模块（为了简洁起见，实际的`find`输出在前面的块中被截断）。
- en: 'Now, recall the exercise I asked you to work on in [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building
    the 5.x Linux Kernel from Source – Part 1*, in the *Sample usage of the make menuconfig
    UI* section. There, in *Table 2.4*, the last column specifies the type of change
    we made. Look for the `n -> m` (or `y -> m`) changes, implying we are configuring
    that particular feature to be built as a kernel module. There, we can see that
    this includes the following features:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回想一下我在[第2章](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml)中要求你进行的练习，*从源代码构建5.x
    Linux内核 - 第1部分*，在*使用make menuconfig UI的示例*部分。在那里，在*表2.4*中，最后一列指定了我们所做更改的类型。寻找`n
    -> m`（或`y -> m`）的更改，这意味着我们正在配置该特定功能以构建为内核模块。在那里，我们可以看到这包括以下功能：
- en: VirtualBox support, `n -> m`
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VirtualBox支持，`n -> m`
- en: '**Userspace I/O** (**UIO**) drivers, `n -> m`; and a UIO platform driver with
    generic IRQ handling, `n -> m`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户空间I/O**（**UIO**）驱动程序，`n -> m`；以及具有通用中断处理的UIO平台驱动程序，`n -> m`'
- en: MS-DOS filesystem support, `n -> m`
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MS-DOS文件系统支持，`n -> m`
- en: 'As these features have been asked to be built as modules, they will not be
    encoded within the `vmlinux` or `bzImage` kernel image files. No, they will exist
    as standalone (well, kind of) *kernel modules*. Let''s hunt for the kernel modules
    for the preceding features within the kernel source tree (showing their pathname
    and sizes with a bit of scripting foo):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些功能被要求构建为模块，它们不会被编码到`vmlinux`或`bzImage`内核映像文件中。不，它们将作为独立的（嗯，有点）*内核模块*存在。让我们在内核源树中寻找前面功能的内核模块（显示它们的路径名和大小，使用一些脚本技巧）：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Okay, great, the binary kernel modules have indeed been generated within the
    kernel source tree. But this alone is not enough. Why? They need to be *installed* into
    a well-known location within the root filesystem so that, at boot, the system
    *can actually find and load them* into kernel memory. This is why we need to *install*
    the kernel modules. The "well-known location within the root filesystem" is **`/lib/modules/$(uname
    -r)/`**, where `$(uname -r)` yields the kernel version number, of course.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，很好，二进制内核模块确实已经在内核源树中生成。但这还不够。为什么？它们需要被*安装*到根文件系统中的一个众所周知的位置，以便在引导时，系统*实际上可以找到并加载它们*到内核内存中。这就是为什么我们需要*安装*内核模块。根文件系统中的“众所周知的位置”是**`/lib/modules/$(uname
    -r)/`**，其中`$(uname -r)`产生内核版本号，当然。
- en: Getting the kernel modules installed
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装内核模块
- en: 'Performing the kernel module installation is simple; (after the build step) just
    invoke the `modules_install` Makefile target. Let''s do so:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 执行内核模块安装很简单；（在构建步骤之后）只需调用`modules_install` Makefile目标。让我们这样做：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice that we use `sudo(8)` to perform the installation *as root* (superuser).
    This is required as the default install location (under `/lib/modules/`) is only
    root-writeable. Once the kernel modules have been prepared and copied across (the
    work that shows up in the preceding output block as `INSTALL`), the kbuild system
    runs a utility called `depmod(8)`. Its job essentially is to resolve dependencies
    between kernel modules and encode them (if they exist) into some metafiles (refer
    to the man page on `depmod(8)` for more details: [https://linux.die.net/man/8/depmod](https://linux.die.net/man/8/depmod)).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`sudo(8)`以*root*（超级用户）身份执行安装。这是因为默认的安装位置（在`/lib/modules/`下）只有root可写。一旦内核模块准备好并复制过去（在前面的输出块中显示为`INSTALL`的工作），kbuild系统运行一个名为`depmod(8)`的实用程序。它的工作基本上是解决内核模块之间的依赖关系，并将它们（如果存在）编码到一些元文件中（有关`depmod(8)`的更多详细信息，请参阅[https://linux.die.net/man/8/depmod](https://linux.die.net/man/8/depmod)上的man页面）。
- en: 'Now let''s see the result of the module installation step:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看模块安装步骤的结果：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, we can see that for each (Linux) kernel we can boot
    the system into, there is a folder under `/lib/modules/`, whose name is the kernel
    release, as expected. Let''s look within the folder of interest – our new kernel''s
    (`5.4.0-llkd01`). There, under the `kernel/` sub-directory – within various directories
    – live the just-installed kernel modules:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到对于每个（Linux）内核，我们可以将系统引导到的文件夹在`/lib/modules/`下，其名称是内核版本，正如预期的那样。让我们查看感兴趣的文件夹
    - 我们新内核的（`5.4.0-llkd01`）。在那里，在`kernel/`子目录下 - 在各种目录中 - 存放着刚安装的内核模块：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Incidentally, the `/lib/modules/<kernel-ver>/modules.builtin` file has the list
    of all installed kernel modules (under `/lib/modules/<kernel-ver>/kernel/`).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，`/lib/modules/<kernel-ver>/modules.builtin`文件中列出了所有已安装的内核模块（在`/lib/modules/<kernel-ver>/kernel/`下）。
- en: 'Let''s search here for the kernel modules that we mentioned earlier:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里搜索我们之前提到的内核模块：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: They all show up. Excellent!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都显示出来了。太棒了！
- en: 'A final key point: during the kernel build, we can install the kernel modules
    into a location that *we* specify, overriding the (default) `/lib/modules/<kernel-ver>`
    location. This is done by setting the environment variable of `INSTALL_MOD_PATH` to
    the required location; for example, doing the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个关键点：在内核构建过程中，我们可以将内核模块安装到*我们*指定的位置，覆盖（默认的）`/lib/modules/<kernel-ver>`位置。这是通过将环境变量`INSTALL_MOD_PATH`设置为所需的位置来完成的；例如，执行以下操作：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this, we have all our kernel modules installed into the `${STG_MYKMODS}/` folder. Note
    how, perhaps, `sudo` is not required if `INSTALL_MOD_PATH` refers to a location
    that does not require *root *for writing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们所有的内核模块都安装到了`${STG_MYKMODS}/`文件夹中。请注意，如果`INSTALL_MOD_PATH`指向不需要*root*写入的位置，也许就不需要`sudo`。
- en: This technique – overriding the *kernel modules' install location* – can be
    especially useful when building a Linux kernel and kernel modules for an embedded
    target. Clearly, we must definitely *not* overwrite the host system's kernel modules
    with that of the embedded target's; that could be disastrous!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术 - 覆盖*内核模块的安装位置* - 在为嵌入式目标构建Linux内核和内核模块时特别有用。显然，我们绝对*不*应该用嵌入式目标的内核模块覆盖主机系统的内核模块；那可能是灾难性的！
- en: The next step is to generate the so-called `initramfs` (or `initrd`) image and
    set up the bootloader. We also need to clearly understand what exactly this `initramfs`
    image is and the motivation behind using it. The section after the following one
    delves into these details.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是生成所谓的`initramfs`（或`initrd`）镜像并设置引导加载程序。我们还需要清楚地了解这个`initramfs`镜像到底是什么，以及使用它的动机。接下来的部分将深入探讨这些细节。
- en: Step 6 – generating the initramfs image and bootloader setup
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6步 - 生成`initramfs`镜像和引导加载程序设置
- en: 'Firstly, please note that this discussion is highly biased toward the x86[_64]
    architecture. For the typical x86 desktop or server kernel build procedure, this
    step is internally divided into two distinct parts:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，这个讨论非常偏向于x86[_64]架构。对于典型的x86桌面或服务器内核构建过程，这一步被内部分成了两个不同的部分：
- en: Generating the `initramfs` (formerly called `initrd`) image
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成`initramfs`（以前称为`initrd`）镜像
- en: (GRUB) bootloader setup for the new kernel image
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （GRUB）引导加载程序设置为新的内核镜像
- en: The reason it's encapsulated into a single step in this recipe for the kernel
    build process here is that, on the x86 architecture, convenience scripts perform
    both tasks, giving the appearance of a single step.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，将它封装成一个单一步骤的原因是，在x86架构上，方便的脚本执行这两个任务，看起来就像是一个单一步骤。
- en: Wondering what exactly this `initramfs` (or `initrd`) image file is? Please
    see the following *Understanding the initramfs framework* section for details.
    We'll get there soon.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 想知道这个`initramfs`（或`initrd`）镜像文件到底是什么？请参阅下面的*了解initramfs框架*部分以获取详细信息。我们很快就会到那里。
- en: 'For now, let''s just go ahead and generate the **initramfs **(short for **initial
    ram filesystem**) image file as well as update the bootloader. Performing this
    on x86[_64] Ubuntu is easily done in one simple step:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续并生成**initramfs**（即**初始RAM文件系统**）镜像文件，并更新引导加载程序。在x86[_64] Ubuntu上执行这个操作非常简单，只需一步即可完成：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that, again, we prefix the `make install` command with `sudo(8)`. Quite
    obviously, this is as we require *root* permission to write the concerned files
    and folders.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，再次，我们在`make install`命令前加上了`sudo(8)`。显然，这是因为我们需要*root*权限来写入相关的文件和文件夹。
- en: 'So that''s it, we are done: a brand new 5.4 kernel, along with all requested
    kernel modules and the `initramfs` image, have been generated, and the (GRUB)
    bootloader has been updated. All that remains is to reboot the system, select
    the new kernel image on boot (from the bootloader menu screen), boot up, log in,
    and verify that all is okay.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，我们完成了：一个全新的5.4内核，以及所有请求的内核模块和`initramfs`镜像，都已经生成，并且（GRUB）引导加载程序已经更新。剩下的就是重新启动系统，在引导加载程序菜单屏幕上选择新的内核镜像，启动，登录，并验证一切是否正常。
- en: Generating the initramfs image on Fedora 30 and above
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Fedora 30及以上版本上生成`initramfs`镜像
- en: 'Unfortunately, on Fedora 30 and above, generating the `initramfs` image does
    not appear to work as easily as with Ubuntu in the preceding section. Some folks
    suggest explicitly specifying the architecture via the `ARCH` environment variable.
    Take a look:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在Fedora 30及以上版本中，生成`initramfs`镜像似乎并不像在前面的部分中使用Ubuntu那样容易。一些人建议通过`ARCH`环境变量明确指定架构。看一下：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It fails! Want to know why? I won''t go into the details here, but this link
    should help you out: [https://discussion.fedoraproject.org/t/installing-manually-builded-kernel-in-system-with-grub2/1895](https://discussion.fedoraproject.org/t/installing-manually-builded-kernel-in-system-with-grub2/1895).
    To help set this situation right, here''s what I did on my Fedora 31 VM (and,
    yes, it worked!):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 失败了！想知道为什么吗？我不会在这里详细介绍，但这个链接应该会帮到你：[https://discussion.fedoraproject.org/t/installing-manually-builded-kernel-in-system-with-grub2/1895](https://discussion.fedoraproject.org/t/installing-manually-builded-kernel-in-system-with-grub2/1895)。为了解决这个问题，以下是我在我的Fedora
    31 VM上所做的（是的，它成功了！）：
- en: 'Manually create the `initramfs` image:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动创建`initramfs`镜像：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Ensure that the `grubby` package is installed:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保安装了`grubby`软件包：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Pressing the *Tab* key twice after typing `grubby-` results in the full package
    name being auto-completed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入`grubby-`后按两次*Tab*键会自动完成完整的软件包名称。
- en: '(Re)run the `make install` command:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行`make install`命令：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Though the `make install` command appears to fail, it has sufficiently succeeded.
    Let''s peek at the content of the `/boot` directory to verify this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`make install`命令似乎失败了，但它已经足够成功了。让我们偷看一下`/boot`目录的内容来验证一下：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Indeed, the `initramfs` image, the `System.map` file, and `vmlinuz` (along with
    the required symbolic links) seem to be set up! Reboot, select the new kernel
    from the GRUB menu, and verify that it works.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，`initramfs`镜像、`System.map`文件和`vmlinuz`（以及所需的符号链接）似乎已经设置好了！重新启动，从GRUB菜单中选择新的内核，并验证它是否正常工作。
- en: In this step, we generated the `initramfs` image. The question is, what did
    the *kbuild* system perform under the hood when we did this? Read on to find out.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们生成了`initramfs`镜像。问题是，在我们执行此操作时，*kbuild*系统在幕后执行了什么？继续阅读以了解详情。
- en: Generating the initramfs image – under the hood
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成initramfs镜像-在幕后
- en: 'Recall from the previous section what you will first see when the `sudo make
    install` command executes (reproduced as follows for your convenience):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请回想一下前一节中，当`sudo make install`命令执行时，您将首先看到什么（以下是为了您的方便而重现的）：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Clearly, it''s (`install.sh`) a script being executed. Internally, as part
    of its work, it copies the following files into the `/boot` folder, with the name
    format typically being `<filename>-$(uname -r)`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，(`install.sh`)是一个正在执行的脚本。在其工作的一部分内部，它将以下文件复制到`/boot`文件夹中，名称格式通常为`<filename>-$(uname
    -r)`：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `initramfs` image is built as well. A shell script named `update-initramfs`
    performs this task (which is itself a convenience wrapper over another script
    called `mkinitramfs(8)` that performs the actual work). Once built, the `initramfs`
    image is also copied into the `/boot` directory, seen as `initrd.img-5.4.0-llkd01`
    in the preceding output snippet.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`initramfs`镜像也被构建。一个名为`update-initramfs`的shell脚本执行此任务（它本身是另一个名为`mkinitramfs(8)`的脚本的方便包装，该脚本执行实际工作）。构建后，`initramfs`镜像也被复制到`/boot`目录中，在前面的输出片段中被视为`initrd.img-5.4.0-llkd01`。'
- en: If at all a file being copied into `/boot` already exists, it is backed up as
    `<filename>-$(uname -r).old`. The file named `vmlinuz-<kernel-ver>` is a copy
    of the `arch/x86/boot/bzImage` file. In other words, it is the compressed kernel
    image – the image file that the bootloader will be configured to load into RAM,
    uncompress, and jump to its entry point, thus handing over control to the kernel!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要复制到`/boot`的文件已经存在，则将其备份为`<filename>-$(uname -r).old`。名为`vmlinuz-<kernel-ver>`的文件是`arch/x86/boot/bzImage`文件的副本。换句话说，它是压缩的内核镜像-引导加载程序将被配置为将其加载到RAM中，解压缩并跳转到其入口点，从而将控制权交给内核！
- en: 'Why the names `vmlinux` (recall, this is the uncompressed kernel image file
    stored in the root of the kernel source tree) and `vmlinuz`? It''s an old Unix
    convention that the Linux OS is quite happy to follow: on many Unix flavors, the
    kernel was called `vmunix`, so Linux calls it `vmlinux` and the compressed one
    `vmlinuz`; the `z` in `vmlinuz` is to hint at the (by default) `gzip(1)` compression.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么叫`vmlinux`（回想一下，这是存储在内核源树根目录中的未压缩内核镜像文件）和`vmlinuz`？这是一个古老的Unix惯例，Linux OS非常乐意遵循：在许多Unix版本中，内核被称为`vmunix`，因此Linux将其称为`vmlinux`，压缩的内核被称为`vmlinuz`；`vmlinuz`中的`z`是为了暗示（默认情况下）`gzip(1)`压缩。
- en: As well, the GRUB bootloader configuration file located at `/boot/grub/grub.cfg` is
    updated to reflect the fact that a new kernel is now available for boot.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，位于`/boot/grub/grub.cfg`的GRUB引导加载程序配置文件将被更新，以反映新的内核现在可用于引导。
- en: Again, it's worth emphasizing the fact that all this is *very architecture-specific*.
    The preceding discussion is with respect to building the kernel on an Ubuntu Linux
    x86[-64] system. While conceptually similar, the details of the kernel image filenames,
    their locations, and especially the bootloader, vary on different architectures.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 同样值得强调的是，所有这些都是*非常特定于架构*的。前面的讨论是关于在Ubuntu Linux x86[-64]系统上构建内核的。虽然在概念上类似，但内核镜像文件名、它们的位置，特别是引导加载程序，在不同的架构上有所不同。
- en: You can skip ahead to the *Customizing the GRUB bootloader* section if you wish*.* If
    you are curious (I'm hoping so), read on. In the following section, we describe
    in some more detail the *hows* and *whys* of the `initramfs`*/*`inird` framework.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以直接跳到*自定义GRUB引导加载程序*部分。如果您感兴趣（我希望如此），请继续阅读。在下一节中，我们将更详细地描述`initramfs`*/*`inird`框架的*如何*和*为什么*。
- en: Understanding the initramfs framework
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解initramfs框架
- en: A bit of a mystery remains! What exactly *is *this `initramfs` or `initrd` image
    for? Why is it there?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个谜团！这个`initramfs`或`initrd`镜像到底是干什么的？它为什么存在？
- en: Firstly, using this feature is a choice – the config directive is called `CONFIG_BLK_DEV_INITRD`.
    It's on and hence set to `y` by default. In brief, for systems that either do
    not know in advance certain things such as the boot disk host adapter or controller
    type (SCSI, RAID, and so on), the exact filesystem type that the root filesystem
    is formatted as (is it `ext2`, `ext3`, `ext4`, `btrfs`, `reiserfs`, `f2fs`, or
    another?), or for those systems where these functionalities are always built as
    kernel modules, we require the `initramfs` capability. Why exactly will become
    clear in a moment. Also, as mentioned earlier, `initrd` is now considered an older
    term. Nowadays, we more often use the term `initramfs` in its place.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用此功能是一个选择-配置指令称为`CONFIG_BLK_DEV_INITRD`。默认情况下为`y`。简而言之，对于那些事先不知道某些事情的系统，比如引导磁盘主机适配器或控制器类型（SCSI，RAID等），根文件系统格式化为确切的文件系统类型（是`ext2`，`ext3`，`ext4`，`btrfs`，`reiserfs`，`f2fs`还是其他？），或者对于那些这些功能总是作为内核模块构建的系统，我们需要`initramfs`功能。为什么确切的原因一会儿就会变得清楚。另外，正如前面提到的，`initrd`现在被认为是一个较旧的术语。如今，我们更经常使用`initramfs`这个术语。
- en: Why the initramfs framework?
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要使用initramfs框架？
- en: The `initramfs` framework is essentially a kind of middle-man between the early
    kernel boot and usermode. It allows us to run user space applications (or scripts)
    before the actual root filesystem has been mounted. This is useful in many circumstances,
    a couple of which are detailed in the following list. The key point is that `initramfs`
    allows us to run user mode apps that the kernel cannot normally run during boot
    time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`initramfs`框架本质上是早期内核引导和用户模式之间的一种中间人。它允许我们在实际根文件系统被挂载之前运行用户空间应用程序（或脚本）。这在许多情况下都很有用，以下列表详细说明了其中的一些情况。关键点是，`initramfs`允许我们在内核在引导时通常无法运行的用户模式应用程序。'
- en: 'Practically speaking, among various uses, this framework allows us to do things
    including the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在各种用途中，这个框架使我们能够做一些事情，包括以下内容：
- en: Set up a console font.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置控制台字体。
- en: Customize keyboard layout settings.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义键盘布局设置。
- en: Print a custom welcome message on the console device.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制台设备上打印自定义欢迎消息。
- en: Accept a password (for encrypted disks).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受密码（用于加密磁盘）。
- en: Load up kernel modules as required.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要加载内核模块。
- en: Spawn a "rescue" shell if something fails.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果出现故障，生成“救援”shell。
- en: And many more!
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有更多！
- en: Imagine for a moment that you are in the business of building and maintaining
    a new Linux distribution. Now, at installation time, the end user of your distribution
    might decide to format their SCSI disk with the `reiserfs` filesystem (FYI, it's
    the earliest general-purpose journaled filesystem in the kernel). The thing is,
    you cannot know in advance what choice exactly the end user will make – it could
    be one of any number of filesystems. So, you decide to pre-build and supply a
    large variety of kernel modules that will fulfill almost every possibility. Fine,
    when the installation is complete and the user's system boots up, the kernel will,
    in this scenario, require the `reiserfs.ko` kernel module in order to successfully
    mount the root filesystem and thus proceed with system boot-up.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在从事构建和维护新Linux发行版的业务。现在，在安装时，你的发行版的最终用户可能会决定用`reiserfs`文件系统格式化他们的SCSI磁盘（FYI，这是内核中最早的通用日志文件系统）。问题是，你无法预先知道最终用户会做出什么选择
    - 它可能是任何一种文件系统。因此，你决定预先构建和提供大量的内核模块，几乎可以满足所有可能性。好吧，当安装完成并且用户的系统启动时，在这种情况下，内核将需要`reiserfs.ko`内核模块才能成功挂载根文件系统，从而继续系统启动。
- en: '![](img/bafffd2d-09c5-4054-899f-5d44b6e34c76.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bafffd2d-09c5-4054-899f-5d44b6e34c76.png)'
- en: Figure 3.1 – The root filesystem's on the disk and yet to be mounted, kernel
    image is in RAM
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 - 磁盘上的根文件系统尚未挂载，内核映像在RAM中
- en: 'But wait, think about this, we now have a classic *chicken-and-egg problem*:
    in order for the kernel to mount the root filesystem, it requires the `reiserfs.ko`
    kernel module file to be loaded into RAM (as it contains the necessary code to
    be able to work with the filesystem). *But*, that file is itself embedded inside
    the `reiserfs` root filesystem; to be precise, within the `/lib/modules/<kernel-ver>/kernel/fs/reiserfs/`
    directory! (see Figure 3.1). One of the primary purposes of the `initramfs` framework
    is to solve this chicken-and-egg problem.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请等一下，想想这个，我们现在有一个经典的*鸡和蛋问题*：为了使内核挂载根文件系统，它需要将`reiserfs.ko`内核模块文件加载到RAM中（因为它包含必要的代码，能够与文件系统一起工作）。*但是*，该文件本身嵌入在`reiserfs`根文件系统中；准确地说，在`/lib/modules/<kernel-ver>/kernel/fs/reiserfs/`目录中！（见图3.1）。`initramfs`框架的主要目的之一是解决这个*鸡和蛋问题*。
- en: The `initramfs` image file is a compressed `cpio` archive (`cpio` is a flat
    file format used by `tar(1)`). As we saw in the previous section, the `update-initramfs`
    script internally invokes the `mkinitramfs` script (on Ubuntu at least, this is
    the case). These scripts build a minimal root filesystem containing the kernel
    modules as well as supporting infrastructure such as the `/etc` and `/lib` folders
    in a simple `cpio` file format, which is then usually gzip-compressed. This now
    forms the so-called `initramfs` (or `initrd`) image file and as we saw earlier,
    it will be placed in `/boot/initrd.img-<kernel-ver>`. Well, so how does that help?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`initramfs`镜像文件是一个压缩的`cpio`存档（`cpio`是`tar(1)`使用的平面文件格式）。正如我们在前一节中看到的，`update-initramfs`脚本在内部调用`mkinitramfs`脚本（至少在Ubuntu上是这样）。这些脚本构建一个包含内核模块以及支持基础设施（如`/etc`和`/lib`文件夹）的最小根文件系统，以简单的`cpio`文件格式，然后通常进行gzip压缩。现在形成了所谓的`initramfs`（或`initrd`）镜像文件，正如我们之前看到的，它将被放置在`/boot/initrd.img-<kernel-ver>`中。那么这有什么帮助呢？'
- en: 'At boot, if we are using the `initramfs` feature, the bootloader will, as part
    of its work, load the `initramfs` image file in RAM. Next, when the kernel itself
    runs on the system, it detects the presence of an `initramfs` image, uncompresses
    it, and using its content (via scripts), loads up the required kernel modules
    into RAM (Figure 3.2):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在引导时，如果我们使用`initramfs`功能，引导加载程序将在其工作的一部分中将`initramfs`镜像文件加载到RAM中。接下来，当内核本身在系统上运行时，它会检测到`initramfs`镜像的存在，解压缩它，并使用其内容（通过脚本）将所需的内核模块加载到RAM中（图3.2）：
- en: '![](img/dcdd1dc0-1a4f-443d-bd55-47620fdc281e.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcdd1dc0-1a4f-443d-bd55-47620fdc281e.png)'
- en: Figure 3.2 – The initramfs image serves as a middle-man between early kernel
    and actual root filesystem availability
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 - initramfs镜像充当早期内核和实际根文件系统可用性之间的中间人
- en: Some more details on both the boot process (on x86) and the initramfs image
    can be found in the following sections.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 关于x86引导过程和initramfs镜像的更多细节可以在以下部分找到。
- en: Understanding the basics of the boot process on the x86
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解x86上的引导过程的基础知识
- en: 'In the following list, we provide a brief overview of the typical boot process
    on an x86[_64] desktop (or laptop), workstation, or server:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，我们提供了关于x86[_64]桌面（或笔记本电脑）、工作站或服务器上典型引导过程的简要概述：
- en: Early boot, POST, BIOS initialization – the **BIOS** *(*short for **Basic Input
    Output System**; essentially, the *firmware* on the x86) loads up the first sector
    of the first bootable disk into RAM and jumps to its entry point. This forms what
    is often referred to as the *stage one* bootloader, whose main job is to load
    the *stage two (larger) bootloader* code into memory and jump to it.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 早期引导，POST，BIOS初始化 - **BIOS**（即x86上的*固件*，简称**基本输入输出系统**）将第一个可引导磁盘的第一个扇区加载到RAM中，并跳转到其入口点。这形成了通常被称为*第一阶段*引导加载程序的东西，其主要工作是将*第二阶段（更大）引导加载程序*代码加载到内存并跳转到它。
- en: Now the stage two bootloader code takes control. Its main job is to *load the
    actual (stage three) GRUB bootloader* into memory and jump to its entry point
    (GRUB is typically the bootloader employed on x86[-64] systems)
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在第二阶段引导加载程序代码接管了控制。它的主要工作是将实际（第三阶段）GRUB引导加载程序*加载到内存并跳转到其入口点（GRUB通常是x86[-64]系统上使用的引导加载程序）
- en: 'The (GRUB) bootloader will be passed both the compressed kernel image file
    (`/boot/vmlinuz-<kernel-ver>`) as well as the compressed `initramfs` image file
    (`/boot/initrd.img-<kernel-ver>`) as parameters. The bootloader will (simplistically)
    do the following:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引导加载程序将传递压缩的内核图像文件（`/boot/vmlinuz-<kernel-ver>`）以及压缩的`initramfs`图像文件（`/boot/initrd.img-<kernel-ver>`）作为参数。引导加载程序将（简单地）执行以下操作：
- en: Perform low-level hardware initialization.
  id: totrans-153
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行低级硬件初始化。
- en: Load these images into RAM, uncompressing the kernel image to a certain extent.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些图像加载到RAM中，对内核图像进行一定程度的解压缩。
- en: It will *jump to the kernel entry point.*
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将*跳转到内核入口点*。
- en: The Linux kernel, now having control of the machine, will initialize the hardware
    and software environment. It makes no assumptions regarding the earlier work performed
    by the bootloader.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linux内核现在控制着机器，将初始化硬件和软件环境。它不会对引导加载程序之前执行的工作做任何假设。
- en: Upon completing the majority of hardware and software initialization, it notices
    that the `initramfs` feature is turned on (`CONFIG_BLK_DEV_INITRD=y`). It will
    thus locate (and if required, uncompress) the `initramfs` (`initrd`) image in
    RAM (see Figure 3.2).
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完成大部分硬件和软件初始化后，它注意到`initramfs`功能已经打开（`CONFIG_BLK_DEV_INITRD=y`）。因此，它将在RAM中定位（并且如果需要，解压缩）`initramfs`（`initrd`）图像（参见图3.2）。
- en: It will then *mount it* as a temporary root filesystem in RAM itself, within
    a `RAMdisk`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将*将其*作为RAM中的临时根文件系统*挂载*。
- en: We now have a base, minimal root filesystem set up in memory. Thus, the `initrd`
    startup scripts now run, performing, among other tasks, the loading of the required
    kernel modules into RAM (in effect, loading the root filesystem drivers, including,
    in our scenario, the `reiserfs.ko` kernel module; again, see Figure 3.2).
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在在内存中设置了一个基本的最小根文件系统。因此，`initrd`启动脚本现在运行，执行加载所需的内核模块到RAM中的任务（实际上是加载根文件系统驱动程序，包括在我们的场景中的`reiserfs.ko`内核模块；再次参见图3.2）。
- en: The kernel then performs a *pivot-root,* *un-mounting* the temporary `initrd`
    root filesystem, freeing its memory, and *mounting the real root filesystem;*
    it's now possible because the kernel module providing that filesystem support
    is indeed available.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，内核执行*pivot-root*，*卸载*临时的`initrd`根文件系统，释放其内存，并*挂载真正的根文件系统*；现在这是可能的，因为提供该文件系统支持的内核模块确实可用。
- en: Once the (actual) root filesystem is successfully mounted, system initialization
    can proceed. The kernel continues, ultimately invoking the first user space process,
    typically `/sbin/init` PID `1`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦（实际的）根文件系统成功挂载，系统初始化就可以继续进行。内核继续，最终调用第一个用户空间进程，通常是`/sbin/init` PID `1`。
- en: The *SysV **init *framework now proceeds to initialize the system, bringing
    up system services as configured.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*SysV **init*框架现在继续初始化系统，按照配置的方式启动系统服务。'
- en: 'A couple of things to note:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几点：
- en: '(a) On modern Linux systems, the traditional (read: old) SysV *init* framework
    has largely been replaced with a modern optimized framework called **systemd**.
    Thus, on many (if not most) modern Linux systems, including embedded ones, the
    traditional `/sbin/init` has been replaced with `systemd` (or is a symbolic link
    to its executable file). Find out more about *systemd* in the *Further reading*
    section at the end of this chapter.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 在现代Linux系统上，传统的（即：旧的）SysV *init*框架已经大部分被一个名为**systemd**的现代优化框架所取代。因此，在许多（如果不是大多数）现代Linux系统上，包括嵌入式系统，传统的`/sbin/init`已被`systemd`取代（或者是其可执行文件的符号链接）。在本章末尾的*进一步阅读*部分了解更多关于*systemd*的信息。
- en: (b) FYI, the generation of the root filesystem itself is not covered in this
    book; as one simple example, I suggest you look at the code of the SEALS project
    (at [https://github.com/kaiwan/seals](https://github.com/kaiwan/seals)) that I
    mentioned in [Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml), *Kernel
    Workspace Setup*; it has script that generates a very minimal, or "skeleton",
    root filesystem from scratch.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 顺便说一句，本书不涵盖根文件系统本身的生成；作为一个简单的例子，我建议您查看我在[第1章](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml)中提到的SEALS项目的代码（在[https://github.com/kaiwan/seals](https://github.com/kaiwan/seals)）；它有一个脚本，可以从头开始生成一个非常简单或“骨架”根文件系统。
- en: Now that you understand the motivation behind `initrd`/`initramfs`, we'll complete
    this section by providing a bit of a deeper look into `initramfs` in the following
    section. Do read on!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了`initrd`/`initramfs`背后的动机，我们将在下一节中深入了解`initramfs`。请继续阅读！
- en: More on the initramfs framework
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于initramfs框架的更多信息
- en: 'Another place where the `initramfs` framework helps is in bringing up computers
    whose disks are *encrypted*. Quite early in the boot process, the kernel will
    have to query the user for the password, and if correct, proceed with mounting
    the disks, and so on. But, think about this: how can we run a C program executable
    that is, say, requesting a password without having a C runtime environment in
    place – a root filesystem containing libraries, the loader program, required kernel
    modules (for the crypto support perhaps), and so on?'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`initramfs`框架帮助的另一个地方是启动磁盘*加密*的计算机。在引导过程的早期阶段，内核将不得不询问用户密码，如果正确，就会继续挂载磁盘等。但是，请考虑一下：如果没有建立C运行时环境，即包含库、加载程序、所需的内核模块（可能是加密支持的内核模块）等的根文件系统，我们如何运行一个请求密码的C程序可执行文件？'
- en: Remember, the kernel *itself* hasn't yet completed initialization; how can user
    space apps run? Again, the `initramfs` framework solves this issue by indeed setting
    up a temporary user space runtime environment complete with the required root
    filesystem containing libraries, the loader, kernel modules, and so on, in memory.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，内核*本身*尚未完成初始化；用户空间应用程序如何运行？再次，`initramfs`框架通过确实在内存中设置一个临时用户空间运行环境来解决这个问题，其中包含所需的根文件系统，包含库、加载程序、内核模块等。
- en: 'Can we verify this? Yes we can! Let''s take a peek into the `initramfs` image
    file. The `lsinitramfs(8)` script on Ubuntu serves exactly this purpose (on Fedora
    the equivalent is called `lsinitrd` instead):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证吗？可以！让我们来看看`initramfs`映像文件。在Ubuntu上，`lsinitramfs(8)`脚本正好用于此目的（在Fedora上，相当应的脚本称为`lsinitrd`）：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There''s quite a bit in there: we truncate the output to show a few select
    snippets. Clearly, we can see a *minimal* root filesystem with support for the
    required runtime libraries, kernel modules, `/etc`, `/bin`, and `/sbin` directories,
    along with their utilities.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 里面有相当多的内容：我们截断输出以显示一些精选片段。显然，我们可以看到一个*最小*的根文件系统，支持所需的运行时库、内核模块、`/etc`、`/bin`和`/sbin`目录，以及它们的实用程序。
- en: The details of constructing the `initramfs` (or `initrd`) image goes beyond
    what we wish to cover here. I suggest you peek into these scripts to reveal their
    inner workings (on Ubuntu): `/usr/sbin/update-initramfs`, a wrapper script over
    the `/usr/sbin/mkinitramfs` shell script. Do see the *Further reading *section
    for more.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 构建`initramfs`（或`initrd`）映像的细节超出了我们希望在这里涵盖的范围。我建议您查看这些脚本以揭示它们的内部工作（在Ubuntu上）：`/usr/sbin/update-initramfs`，这是`/usr/sbin/mkinitramfs`
    shell脚本的包装脚本。有关更多信息，请参阅*进一步阅读*部分。
- en: 'Also, modern systems feature what is sometimes referred to as hybrid `initramfs`:
    an `initramfs` image that consists of an early `ramfs` image prepended to the
    regular or main `ramfs` image. The reality is that we require special tools to
    unpack/pack (uncompress/compress) these images. Ubuntu provides the `unmkinitramfs(8)`
    and `mkinitramfs(8)` scripts, respectively, to perform these operations.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现代系统通常具有所谓的混合`initramfs`：一个由早期`ramfs`映像和常规或主`ramfs`映像组成的`initramfs`映像。事实上，我们需要特殊的工具来解包/打包（解压缩/压缩）这些映像。Ubuntu分别提供了`unmkinitramfs(8)`和`mkinitramfs(8)`脚本来执行这些操作。
- en: 'As a quick experiment, let''s unpack our brand-new `initramfs` image (the one
    generated in the previous section) into a temporary directory. Again, this has
    been performed on our Ubuntu 18.04 LTS guest VM. View its output truncated for
    readability with `tree(1)`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速实验，让我们将我们全新的`initramfs`映像（在上一节中生成的映像）解压到一个临时目录中。同样，这是在我们的Ubuntu 18.04
    LTS虚拟机上执行的。使用`tree(1)`查看其输出以便阅读：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This concludes our (rather lengthy!) discussion on the `initramfs` framework
    and the basics of the boot process on the x86\. The good news is that now, armed
    with this knowledge, you can further customize your product by tweaking the `initramfs`
    image as required – an important skill!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对x86上`initramfs`框架和引导过程基础的（相当冗长的）讨论。好消息是，现在，掌握了这些知识，您可以通过根据需要调整`initramfs`映像来进一步定制产品-这是一项重要的技能！
- en: As an example (and as mentioned earlier), with *security* being a key factor
    on modern systems, being able to encrypt a disk at the block level is a powerful
    security feature; doing this very much involves tweaking the `initramfs` image.
    (Again, as this goes beyond the scope of this book, do refer to the *Further reading*
    section at the end of this chapter for useful links to articles on this and other
    aspects.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 例如（正如前面提到的），在现代系统中，*安全性*是一个关键因素，能够在块级别对磁盘进行加密是一个强大的安全功能；这在很大程度上涉及调整`initramfs`映像。
    （再次强调，由于这超出了本书的范围，请参阅本章末尾的*进一步阅读*部分，以获取有关此内容和其他方面的有用链接。）
- en: Now let's complete the kernel build with some simple customization of the (x86)
    GRUB bootloader's boot script.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过对（x86）GRUB引导加载程序的引导脚本进行一些简单的定制来完成内核构建。
- en: Step 7 – customizing the GRUB bootloader
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7步-定制GRUB引导加载程序
- en: We have now completed *steps 1* to *6* as outlined in [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building
    the 5.x Linux Kernel from Source – Part 1*, in the *Steps to build the* *kernel
    from source* section). We can reboot the system; of course, do first close all
    your apps and files. By default, though, the modern **GRUB** (**GRand Unified**
    **Bootloader**) bootloader does not even show us any menu on reboot; it will by
    default boot into the newly built kernel (do remember that here, we're describing
    this process *only* for x86[_64] systems running Ubuntu).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了[第2章](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml)中概述的*步骤1*至*6*，*从源代码构建5.x
    Linux内核-第1部分*，在*从源代码构建内核的步骤*部分。我们可以重新启动系统；当然，首先关闭所有应用程序和文件。默认情况下，现代**GRUB**（**GRand
    Unified** **Bootloader**）引导加载程序甚至在重新启动时都不会显示任何菜单；它将默认引导到新构建的内核（请记住，在这里，我们仅描述了x86[_64]系统运行Ubuntu的这个过程）。
- en: On x86[_64] you can always get to the GRUB menu during early system boot. Just
    ensure you keep the *Shift* key pressed down during boot.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86[_64]上，您可以在系统早期启动期间始终进入GRUB菜单。只需确保在启动过程中按住*Shift*键。
- en: What if we would like to see and customize the GRUB menu every time we boot
    the system, thus allowing us to possibly select an alternate kernel/OS to boot
    from? This is often very useful during development, so let's find out how we can
    do this.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望每次启动系统时都看到并定制GRUB菜单，从而可能选择要引导的备用内核/操作系统，该怎么办？在开发过程中，这通常非常有用，因此让我们看看如何做到这一点。
- en: Customizing GRUB – the basics
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定制GRUB-基础知识
- en: 'Customizing GRUB is quite easy to do. Do note the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 定制GRUB非常容易。请注意以下内容：
- en: The following steps are to be carried out on the "target" system itself (not
    on the host); in our case, the Ubuntu 18.04 guest VM.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下步骤是在“目标”系统本身上执行的（而不是在主机上）；在我们的情况下，是Ubuntu 18.04虚拟机。
- en: This has been tested and verified on our Ubuntu 18.04 LTS guest system only.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这已在我们的Ubuntu 18.04 LTS客户系统上进行了测试和验证。
- en: 'Here''s a quick series of steps for our customization:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们定制的一系列快速步骤：
- en: 'Let''s be safe and keep a backup copy of the GRUB bootloader config file:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们安全起见，保留GRUB引导加载程序配置文件的备份副本：
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `/etc/default/grub` file is the user-configuration file in question. Before
    editing it, we make a backup to be safe. This is always a good idea.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/default/grub`文件是涉及的用户配置文件。在编辑之前，为了安全起见，我们进行备份。这总是一个好主意。'
- en: 'Edit it. You can use `vi(1)` or your editor of choice:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑它。您可以使用`vi(1)`或您选择的编辑器：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To always show the GRUB prompt at boot, insert this line:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要始终在启动时显示GRUB提示符，请插入此行：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: On some Linux distros, you might instead have the `GRUB_TIMEOUT_STYLE=hidden`
    directive; simply change it to `GRUB_TIMEOUT_STYLE=menu` to achieve the same effect.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些Linux发行版上，您可能会有`GRUB_TIMEOUT_STYLE=hidden`指令；只需将其更改为`GRUB_TIMEOUT_STYLE=menu`即可实现相同的效果。
- en: 'Set the timeout to boot the default OS (in seconds) as required; the default
    is `10` seconds; see the following example:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要设置启动默认操作系统的超时时间（以秒为单位）；默认为`10`秒；请参阅以下示例：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Setting the preceding timeout value to the following values will produce the
    following outcomes:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述超时值设置为以下值将产生以下结果：
- en: '`0`: Boot the system immediately without displaying the menu.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：立即启动系统，不显示菜单。'
- en: '`-1`: Wait indefinitely.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-1`：无限等待。'
- en: 'Furthermore, if a `GRUB_HIDDEN_TIMEOUT` directive is present, just comment
    it out:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果存在`GRUB_HIDDEN_TIMEOUT`指令，只需将其注释掉：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, run the `update-grub(8)` program as *root* to have your changes take
    effect:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，以*root*身份运行`update-grub(8)`程序，使您的更改生效：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding command will typically cause the `initramfs` image to be refreshed
    (regenerated). Once done, you're ready to reboot the system. Hang on a second
    though! The following section shows you how you can modify GRUB's configuration
    to boot by default into a kernel of your choice.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令通常会导致`initramfs`镜像被刷新（重新生成）。完成后，您可以准备重新启动系统。不过等一下！接下来的部分将向您展示如何修改GRUB的配置，以便默认启动您选择的内核。
- en: Selecting the default kernel to boot into
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择默认要启动的内核
- en: 'The GRUB default kernel is preset to be the number zero (via the `GRUB_DEFAULT=0` directive).
    This will ensure that the "first kernel" – the most recently added one – boots
    by default (upon timeout). This may not be what we want; as a real example, on
    our Ubuntu 18.04.3 LTS guest VM, we set it to the default Ubuntu *distro kernel*
    by, as earlier, editing the `/etc/default/grub` file (as root, of course) like
    so:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: GRUB默认内核预设为数字零（通过`GRUB_DEFAULT=0`指令）。这将确保“第一个内核” - 最近添加的内核 - 默认启动（超时后）。这可能不是我们想要的；例如，在我们的Ubuntu
    18.04.3 LTS虚拟机上，我们将其设置为默认的Ubuntu *发行版内核*，就像之前一样，通过编辑`/etc/default/grub`文件（当然是作为root用户）：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Of course, this implies that if your distro is updated or upgraded, you must
    again manually change the preceding line to reflect the new distro kernel that
    you wish to boot into by default, and then run `sudo update-grub`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这意味着如果您的发行版被更新或升级，您必须再次手动更改上述行，以反映您希望默认启动的新发行版内核，然后运行`sudo update-grub`。
- en: 'Right, our freshly edited GRUB configuration file is shown as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们新编辑的GRUB配置文件如下所示：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As in the previous section, don''t forget: if you make any changes here, run
    the `sudo update-grub` command to have your changes take effect.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一部分一样，不要忘记：如果您在这里进行任何更改，请运行`sudo update-grub`命令使更改生效。
- en: 'Additional points to note:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的其他事项：
- en: a) In addition, you can add "pretty" tweaks, such as changing the background
    image (or color) via the `BACKGROUND_IMAGE="<img_file>"` directive.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: a) 此外，您可以添加“漂亮”的调整，比如通过`BACKGROUND_IMAGE="<img_file>"`指令来更改背景图片（或颜色）。
- en: 'b) On Fedora, the GRUB bootloader config file is a bit different; run this
    command to show the GRUB menu at every boot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: b) 在Fedora上，GRUB引导程序配置文件有点不同；运行此命令以在每次启动时显示GRUB菜单：
- en: '`sudo grub2-editenv - unset menu_auto_hide` The details can be found in the *Fedora
    wiki: Changes/HiddenGrubMenu*: [https://fedoraproject.org/wiki/Changes/HiddenGrubMenu](https://fedoraproject.org/wiki/Changes/HiddenGrubMenu).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo grub2-editenv - unset menu_auto_hide` 详细信息可以在*Fedora wiki: Changes/HiddenGrubMenu*中找到：[https://fedoraproject.org/wiki/Changes/HiddenGrubMenu](https://fedoraproject.org/wiki/Changes/HiddenGrubMenu)。'
- en: c) Unfortunately, GRUB2 (the latest version is now 2) seems to be implemented
    differently on pretty much every Linux distro, leading to incompatibilities when
    trying to tune it in one given manner.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: c) 不幸的是，GRUB2（最新版本现在是2）似乎在几乎每个Linux发行版上都有不同的实现方式，导致在尝试以一种特定的方式进行调整时出现不兼容性。
- en: Now let's reboot the guest system, get into the GRUB menu, and boot our new
    kernel.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们重新启动虚拟机系统，进入GRUB菜单，并启动我们的新内核。
- en: 'All done! Let''s (finally!) reboot the system:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 全部完成！让我们（终于！）重新启动系统：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Once the system completes its shutdown procedure and reboots, you should soon
    see the GRUB bootloader menu (the following section shows several screenshots
    too). Be sure to interrupt it by pressing any keyboard key!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦系统完成关机程序并重新启动，您应该很快就会看到GRUB引导程序菜单（下一部分还显示了几个屏幕截图）。一定要通过按任意键来中断它！
- en: 'Though always possible, I recommend you don''t delete the original distro kernel
    image(s) (and associated `initrd`, `System.map` files, and so on). What if your
    brand-new kernel fails to boot? (*If it can happen to the Titanic...*) By keeping
    our original images, we thus have a fallback option: boot from the original distro
    kernel, fix our issue(s), and retry.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然总是可能的，但我建议您不要删除原始的发行版内核镜像（以及相关的`initrd`、`System.map`文件等）。如果您全新的内核无法启动呢？（*如果泰坦尼克号都会发生...*）通过保留我们的原始镜像，我们就有了备用选项：从原始发行版内核启动，解决我们的问题，并重试。
- en: As a worst-case scenario, what if all other kernels/`initrd` images have been
    deleted and your single new kernel fails to boot successfully? Well, you can always
    boot into a *recovery mode* Linux via a USB pen drive; a bit of googling regarding
    this will yield many links and video tutorials.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最坏的情况，如果所有其他内核/`initrd`镜像都已被删除，您的单个新内核无法成功启动呢？好吧，您总是可以通过USB闪存驱动器引导到*恢复模式*的Linux；关于这方面的一些搜索将产生许多链接和视频教程。
- en: Booting our VM via the GNU GRUB bootloader
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过GNU GRUB引导程序引导我们的虚拟机
- en: 'Now our guest VM (using the *Oracle VirtualBox hypervisor*) is about to come
    up; once its (emulated) BIOS routines are done, the GNU GRUB bootloader screen
    shows up first. This happens because we quite intentionally changed the `GRUB_HIDDEN_TIMEOUT_QUIET`
    GRUB configuration directive to the value of `false`. See the following screenshot
    (Figure 3.3). The particular styling seen in the screenshot is how it''s customized
    to appear by the Ubuntu distro:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的虚拟机客人（使用*Oracle VirtualBox hypervisor*）即将启动； 一旦它（模拟的）BIOS例程完成，GNU GRUB引导加载程序屏幕首先显示出来。
    这是因为我们故意将`GRUB_HIDDEN_TIMEOUT_QUIET` GRUB配置指令更改为`false`。 请参阅以下截图（图3.3）。 截图中看到的特定样式是Ubuntu发行版自定义的样式：
- en: '![](img/913f5b6d-b473-4b43-a0c7-0ae382644d81.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/913f5b6d-b473-4b43-a0c7-0ae382644d81.png)'
- en: Figure 3.3 – The GRUB2 bootloader – paused on system startup
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 - GRUB2引导加载程序 - 在系统启动时暂停
- en: 'Now let''s go straight into booting our VM:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们直接引导我们的虚拟机：
- en: Press any keyboard key (besides *Enter)* to ensure the default kernel is not
    booted once the timeout (recall, we set it to 3 seconds) expires.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下任何键盘键（除了*Enter*）以确保默认内核在超时（回想一下，我们将其设置为3秒）到期后不会引导。
- en: If not already there, scroll to the `Advanced options for Ubuntu` menu, highlighting
    it, and press *Enter.*
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还没有到达那里，请滚动到`Ubuntu的高级选项`菜单，将其突出显示，然后按*Enter*。
- en: 'Now you''ll see a menu similar, but likely not identical, to the following
    screenshot (Figure 3.4). For each kernel that GRUB has detected and can boot into,
    there are two lines shown – one for the kernel itself and one for the special
    recovery mode boot option into the same kernel:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你会看到一个类似的菜单，但可能不完全相同，如下截图（图3.4）。 对于GRUB检测到并可以引导的每个内核，都显示了两行 - 一个是内核本身，另一个是进入相同内核的特殊恢复模式引导选项：
- en: '![](img/f422bfa0-21b2-4f03-84d9-7891f9f3a522.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f422bfa0-21b2-4f03-84d9-7891f9f3a522.png)'
- en: Figure 3.4 – The GRUB2 bootloader showing available kernels to boot from
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 - GRUB2引导加载程序显示可引导的内核
- en: Notice how the kernel that will boot by default – in our case, the `5.0.0-36-generic` kernel
    – is highlighted by default with an asterisk (`*`).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意默认引导的内核 - 在我们的情况下，默认高亮显示了`5.0.0-36-generic`内核，带有一个星号（`*`）。
- en: The preceding screenshot shows a few "extra" line items. This is because, at
    the time of taking this screenshot, I had updated the VM and hence a few newer
    kernels were installed as well. We can spot the `5.0.0-37-generic` and `5.3.0-26-generic`
    kernels. No matter; we ignore them here.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了一些“额外”的行项目。 这是因为在拍摄这张截图时，我已经更新了虚拟机，因此还安装了一些更新的内核。 我们可以看到`5.0.0-37-generic`和`5.3.0-26-generic`内核。
    没关系； 我们在这里忽略它们。
- en: Whatever the case, simply scroll to the entry of interest, that is, the `5.4.0-llkd01`
    kernel entry. Here, it's the very first line of the GRUB menu (as it's the most
    recent addition to the GRUB menu of bootable OSes): `Ubuntu, with Linux 5.4.0-llkd01`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论如何，只需滚动到感兴趣的条目，也就是`5.4.0-llkd01`内核条目。 在这里，它是GRUB菜单的第一行（因为它是可引导操作系统的GRUB菜单的最新添加）：`Ubuntu,
    with Linux 5.4.0-llkd01`。
- en: Once you have highlighted the preceding menu item, press *Enter *and voilà!
    The bootloader will proceed to do its job, uncompressing and loading the kernel
    image and `initrd` image into RAM, and jumping to the Linux kernel's entry point,
    thus handing over control to Linux!
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你突出显示了前面的菜单项，按*Enter*，完成！ 引导加载程序将继续执行它的工作，将内核映像和`initrd`映像解压缩并加载到RAM中，并跳转到Linux内核的入口点，从而将控制权交给Linux！
- en: Right, if all goes well, as it should, you will have booted into your brand-new
    freshly built 5.4.0 Linux kernel! Congratulations on a task well done. Then again,
    you could always do more – the following section shows you how you can further
    edit and customize GRUB's config at runtime (boot time). Again, this skill comes
    in handy every now and then – for example, *forgot the root password?* Yes indeed,
    you can actually *bypass it* using this technique! Read on to find out how.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，如果一切顺利，就像应该的那样，你将成功引导到全新构建的5.4.0 Linux内核！ 祝贺你完成了一项出色的任务。 再说一遍，你可以做得更多 - 以下部分将向你展示如何在运行时（引导时）进一步编辑和自定义GRUB的配置。
    再次，这种技能偶尔会派上用场 - 例如，*忘记了root密码？* 是的，确实，你实际上可以使用这种技术*绕过它*！ 继续阅读以了解详情。
- en: Experimenting with the GRUB prompt
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试使用GRUB提示
- en: 'You could experiment further; instead of merely pressing *Enter* while on the
    `Ubuntu, with Linux 5.4.0-llkd01` kernel''s menu entry, ensure that this line
    is highlighted and press the `e` key (for edit). We shall now enter GRUB''s *edit
    screen*, wherein we are free to change any value we like. Here''s a screenshot
    after pressing the *e* key:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进一步进行实验； 而不仅仅是在`Ubuntu, with Linux 5.4.0-llkd01`内核的菜单条目上按*Enter*，确保突出显示此行并按`e`键（进行编辑）。
    现在我们将进入GRUB的*编辑屏幕*，在这里我们可以自由更改任何值。 这是按下*e*键后的截图：
- en: '![](img/80e582a1-ba49-492a-93b3-b708e8a0cb57.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80e582a1-ba49-492a-93b3-b708e8a0cb57.png)'
- en: Figure 3.5 – The GRUB2 bootloader – detail on the custom 5.4.0-llkd01 kernel
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 - GRUB2引导加载程序 - 自定义5.4.0-llkd01内核的详细信息
- en: The screenshot has been taken after scrolling down a few lines; look carefully,
    you can spot the cursor (an underscore-like one, "**`_`**") at the very beginning
    of the third line from the bottom of the edit box. This is the crucial line; it
    starts with the suitably indented keyword `linux`. It specifies the list of *kernel
    parameters* being passed via the GRUB bootloader to the Linux kernel.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个截图是在向下滚动几行后拍摄的； 仔细看，你可以在编辑框底部的第三行的开头处看到光标（一个下划线状的， "**`_`**"）。 这是关键的一行； 它以适当缩进的关键字`linux`开头。
    它指定通过GRUB引导加载程序传递给Linux内核的*内核参数*列表。
- en: Try experimenting a bit here. As a simple example, delete the words `quiet`
    and `splash` from this entry, then press *Ctrl* + *X* or *F10* to boot. This time,
    the pretty Ubuntu splash screen does not appear; you are directly in the console
    seeing all kernel messages as they flash past.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在这里做一些实验。 举个简单的例子，从这个条目中删除单词“quiet”和“splash”，然后按*Ctrl* + *X*或*F10*进行引导。 这一次，漂亮的Ubuntu启动画面不会出现；
    你直接在控制台中看到所有内核消息闪过。
- en: 'A common question: what if we forget our password and thus cannot log in? Well,
    there are several approaches to tackle this. One is via the bootloader: boot into
    the GRUB menu as we have done, go to the relevant menu entry, press *e* to edit
    it, scroll down to the line beginning with the word `linux`, and append the word
    `single` (or just the number `1`) at the end of this entry, such that it looks
    like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的问题：如果我们忘记了密码，因此无法登录怎么办？有几种方法可以解决这个问题。其中一种是通过引导加载程序：像我们一样进入GRUB菜单，转到相关的菜单项，按*e*进行编辑，滚动到以单词`linux`开头的行，并在此条目的末尾添加单词`single`（或只是数字`1`），使其看起来像这样：
- en: '[PRE34]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, when you boot, the kernel boots into single-user mode and gives you, the
    eternally grateful user, *a shell with root access*. Just run the `passwd <username>`
    command to change your password.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您启动时，内核将以单用户模式启动，并为您，永远感激的用户，提供具有root访问权限的shell。只需运行`passwd <username>`命令来更改您的密码。
- en: The precise procedure to boot into single-user mode varies with the distro.
    Exactly what to edit in the GRUB2 menu is a bit different on Red Hat/Fedora/CentOS.
    See the *Further reading* section for a link on how to set it for these systems.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 进入单用户模式的确切过程因发行版而异。在Red Hat/Fedora/CentOS上编辑GRUB2菜单的确切内容与其他发行版有些不同。请参阅*进一步阅读*部分，了解如何为这些系统设置的链接。
- en: This teaches us something regarding *security*, doesn't it? A system is considered
    insecure when access to the bootloader menu (and even to the BIOS) is possible
    without a password! In fact, in highly secured environments, even physical access
    to the console device must be restricted.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这教会了我们一些关于*安全*的东西，不是吗？当可以在没有密码的情况下访问引导加载程序菜单（甚至是BIOS）时，系统被认为是不安全的！事实上，在高度安全的环境中，甚至必须限制对控制台设备的物理访问。
- en: Now you have learned how to customize the GRUB bootloader, and, I expect, have
    booted into your fresh 5.4 Linux kernel! Let's not just assume things; let's verify
    that the kernel is indeed configured as per our plan.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何自定义GRUB引导加载程序，并且我期望您已经启动到了新的5.4 Linux内核！让我们不要假设，让我们验证内核是否确实按照我们的计划配置。
- en: Verifying our new kernel's configuration
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证我们新内核的配置
- en: 'Okay, so back to our discussion: we have now booted into our newly built kernel.
    But hang on, let''s not blindly assume things, let''s actually verify that all
    has gone according to plan. The *empirical approach* is always best:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，回到我们的讨论：我们现在已经启动到我们新构建的内核中。但是等等，让我们不要盲目地假设，让我们实际验证一下是否一切都按计划进行。*经验主义方法*总是最好的：
- en: '[PRE35]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Indeed, we are now running Ubuntu 18.04.3 LTS on our just-built **5.4.0** Linux
    kernel!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们现在正在我们刚构建的**5.4.0** Linux内核上运行Ubuntu 18.04.3 LTS！
- en: 'Recall our table of kernel configs to edit from [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml),
    *Building the 5.x Linux Kernel from Source – Part 1*, in *Table 2.4*. We should
    check row by row that each configuration we have changed has actually taken effect.
    Let''s list some of them, starting with the concerned `CONFIG_''FOO''` name, as
    follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在[第2章](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml)中编辑的内核配置表，*从源代码构建5.x
    Linux内核-第1部分*，在*表2.4*中。我们应该逐行检查我们已经更改的每个配置是否实际生效。让我们列出其中一些，从关注的`CONFIG_'FOO'`名称开始，如下所示：
- en: '`CONFIG_LOCALVERSION`: The preceding output of `uname -r` clearly shows the
    `localversion` (or `-EXTRAVERSION`) part of the kernel version has been set to
    what we wanted: the `-llkd01` string.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_LOCALVERSION`：`uname -r`的前面输出清楚地显示了内核版本的`localversion`（或`-EXTRAVERSION`）部分已经设置为我们想要的`-llkd01`字符串。'
- en: '`CONFIG_IKCONFIG`: Allows us to see the current kernel configuration details.
    Let''s check. Recall that you are to set the `LLKD_KSRC` environment variable to
    the root location of your 5.4 kernel source tree directory:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_IKCONFIG`：允许我们查看当前内核配置的详细信息。让我们检查一下。请记住，您需要将`LLKD_KSRC`环境变量设置为您的5.4内核源代码树目录的根位置：'
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It works! We can see the entire kernel configuration via the `scripts/extract-ikconfig` script. We
    shall use this very script to `grep(1)` the remainder of the config directives
    that we changed in the aforementioned *Table 2.4*:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 它奏效了！我们可以通过`scripts/extract-ikconfig`脚本看到整个内核配置。我们将使用这个脚本来`grep(1)`我们在上述*表2.4*中更改的其余配置指令：
- en: '[PRE37]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Carefully looking through the preceding output, we can see that we got precisely
    what we wanted. Our new kernel's configuration settings match precisely the settings
    expected in [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building
    the 5.x Linux Kernel from Source – Part 1*, *Table 2.4*; perfect.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看前面的输出，我们可以看到我们确实得到了我们想要的结果。我们的新内核配置设置与[第2章](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml)中*从源代码构建5.x
    Linux内核-第1部分*，*表2.4*中预期的设置完全匹配；完美。
- en: 'Alternatively, as we have enabled the `CONFIG_IKCONFIG_PROC` option, we could
    have achieved the same verification by looking up the kernel config via the (compressed)
    `proc` filesystem entry, `/proc/config.gz`, like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，由于我们启用了`CONFIG_IKCONFIG_PROC`选项，我们可以通过查找（压缩的）`proc`文件系统条目`/proc/config.gz`来实现相同的验证，就像这样：
- en: '[PRE38]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So, the kernel build is done! Fantastic. I urge you to refer back to [Chapter
    2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building the 5.x Linux Kernel
    from Source – Part 1*, in the* Steps to build the kernel from source* section*,* to
    again see the high-level overview of steps for the entire process. We round off
    this chapter with an interesting *cross-compile* of the Raspberry Pi device kernel
    and a few remaining tips.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，内核构建完成了！太棒了。我建议您回到[第2章](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml)，*从源代码构建5.x
    Linux内核-第1部分*，在*从源代码构建内核的步骤*部分，再次查看整个过程的高级概述。我们将以树莓派设备内核的有趣*交叉编译*和一些剩余的提示结束本章。
- en: Kernel build for the Raspberry Pi
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树莓派的内核构建
- en: 'A popular and relatively inexpensive **Single-Board Computer** (**SBC**) to
    experiment and prototype with is the ARM-based Raspberry Pi. Hobbyists and tinkerers
    find it very useful to try out and learn how to work with embedded Linux, especially
    as it has a strong community backing (with many Q&A forums) and good support:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一个受欢迎且相对便宜的**单板计算机**（**SBC**）用于实验和原型设计是基于ARM的树莓派。爱好者和改装者发现它非常有用，可以尝试并学习如何使用嵌入式Linux，特别是因为它有强大的社区支持（有许多问答论坛）和良好的支持：
- en: '![](img/4dbca72e-6589-4a88-98cc-318889ef8367.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4dbca72e-6589-4a88-98cc-318889ef8367.png)'
- en: Figure 3.6 – A Raspberry Pi 3 Model B+ device (note that the USB-to-serial cable
    seen in the photo does not come with it)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6-树莓派3型B+设备（请注意，照片中看到的USB转串口电缆不随设备一起提供）
- en: 'There are two ways in which you can build a kernel for the target device:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以为目标设备构建内核：
- en: Build the kernel on a powerful host system, typically an Intel/AMD x86_64 (or
    Mac) desktop or laptop running a Linux distro.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在功能强大的主机系统上构建内核，通常是运行Linux发行版的Intel/AMD x86_64（或Mac）台式机或笔记本电脑。
- en: Perform the build on the target device itself.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目标设备本身上进行构建。
- en: We shall follow the first method – it's a lot faster and is considered the right
    way to perform embedded Linux development.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循第一种方法-它更快，被认为是执行嵌入式Linux开发的正确方法。
- en: We shall assume (as usual) that we are running on our Ubuntu 18.04 LTS guest
    VM. So, think about it; now, the host system is actually the guest Linux VM! Also,
    we're targeting building the kernel for ARM 32-bit architecture, not 64-bit.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设（像往常一样）我们正在运行我们的Ubuntu 18.04 LTS虚拟机。所以，想想看；现在，主机系统实际上是嵌入式Linux虚拟机！此外，我们的目标是为ARM
    32位架构构建内核，而不是64位。
- en: Performing large downloads and kernel build operations on a guest VM isn't really
    ideal. Depending on the power and RAM of the host and guest, it will take a while.
    It could end up being twice as slow as building on a native Linux box. Nevertheless,
    assuming you have set aside sufficient disk space in the guest (and of course
    the host actually has this space available), this procedure works.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟机上执行大型下载和内核构建操作并不是理想的。根据主机和客户端的功率和RAM，这将需要一段时间。它可能会比在本机Linux框上构建慢两倍。尽管如此，假设您在客户端设置了足够的磁盘空间（当然主机实际上有这个空间可用），这个过程是有效的。
- en: We will have to use an *x86_64-to-ARM (32-bit) cross-compiler* to build the
    kernel, or any component for that matter, for the Raspberry Pi target. This implies
    installing an appropriate **cross-toolchain** as well to perform the build.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不使用*x86_64到ARM（32位）交叉编译器*来构建内核，或者为树莓派目标构建任何组件。这意味着还需要安装适当的**交叉工具链**来执行构建。
- en: 'In the following few sections, we divide the work up into three discrete steps:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个部分中，我们将工作分为三个离散的步骤：
- en: Getting ourselves a kernel source tree appropriate for the device
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为设备获取适当的内核源树
- en: Learning how to install an appropriate cross toolchain
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习如何安装适当的交叉工具链
- en: Configuring and building the kernel
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置和构建内核
- en: So let's begin!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 那么让我们开始吧！
- en: Step 1 – cloning the kernel source tree
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1步-克隆内核源树
- en: 'We arbitrarily select a *staging folder* (the place where the build happens)
    for the kernel source tree and the cross-toolchain, and assign it to an environment
    variable (so as to avoid hard-coding it):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们任意选择一个*暂存文件夹*（构建发生的地方）用于内核源树和交叉工具链，并将其分配给一个环境变量（以避免硬编码）：
- en: 'Set up your workspace. We set an environment variable as `RPI_STG` (it''s not
    required to use exactly this name for the environment variable; just pick a reasonable-sounding
    name and stick to it) to the staging folder''s location – the place where we shall
    perform the work. Feel free to use a value appropriate to your system:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置您的工作空间。我们将一个环境变量设置为`RPI_STG`（不需要使用这个环境变量的确切名称；只需选择一个合理的名称并坚持使用）到暂存文件夹的位置-我们将在那里进行工作。随时使用适合您系统的值：
- en: '[PRE39]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Do ensure you have sufficient disk space available: the kernel source tree
    takes approximately 900 MB, and the toolchain around 1.5 GB. You''ll require at
    least another gigabyte for working space.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您有足够的磁盘空间可用：内核源树大约占用900 MB，工具链大约占用1.5 GB。您至少需要另外一千兆字节的工作空间。
- en: 'Download the Raspberry Pi kernel source tree (we clone it from the official
    source, the Raspberry Pi GitHub repository for the kernel tree, here: [https://github.com/raspberrypi/linux/](https://github.com/raspberrypi/linux/)):'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载树莓派内核源树（我们从官方源克隆，树莓派GitHub内核树库，链接：[https://github.com/raspberrypi/linux/](https://github.com/raspberrypi/linux/)）：
- en: '[PRE40]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The kernel source tree gets cloned under a directory called `linux/` (that
    is, under `${RPI_WORK}/kernel_rpi/linux`). Notice how, in the preceding code,
    we have the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 内核源树被克隆到一个名为`linux/`的目录下（即`${RPI_WORK}/kernel_rpi/linux`）。请注意，在前面的代码中，我们有以下内容：
- en: The particular Raspberry Pi kernel tree branch we have selected is *not* the
    very latest one (at the time of writing, the very latest is the 5.11 series),
    it's the 5.4 kernel; that's perfectly okay (it's an LTS kernel and matches our
    x86 one as well!).
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们选择的特定树莓派内核树分支*不是*最新的（在撰写本文时，最新的是5.11系列），它是5.4内核；这完全没问题（它是LTS内核，也与我们的x86内核匹配！）。
- en: We pass the `--depth` parameter set to `1` to `git clone` to reduce the download
    and uncompress loads.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`--depth`参数设置为`1`传递给`git clone`以减少下载和解压负载。
- en: 'Now the Raspberry Pi kernel source is installed. Let''s briefly verify this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在树莓派内核源已安装。让我们简要验证一下：
- en: '[PRE41]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Okay, it's the 5.4.51 Raspberry Pi kernel port (the kernel version we use on
    the x86_64 is the 5.4.0 one; the slight variation is fine).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是5.4.51树莓派内核端口（我们在x86_64上使用的内核版本是5.4.0；轻微的变化没问题）。
- en: Step 2 – installing a cross-toolchain
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2步-安装交叉工具链
- en: Now it's time to install a *cross-toolchain* on your host system that's appropriate
    for performing the actual build. The thing is, there are several working toolchains
    available... Here, I shall show two ways of obtaining and installing a toolchain.
    The first is the simplest and typically sufficient, while the second way installs
    a more elaborate version.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在您的主机系统上安装适用于执行实际构建的*交叉工具链*。事实上，有几个可用的工作工具链...在这里，我将展示两种获取和安装工具链的方法。第一种是最简单的，通常足够了，而第二种方法安装了一个更复杂的版本。
- en: First method – package install via apt
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一种方法-通过apt包安装
- en: 'This is really simple and works well; do use this method routinely:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单且效果很好；通常使用这种方法：
- en: '[PRE42]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The tools are typically installed under `/usr/bin/` and are therefore already
    part of your `PATH`; you can simply use them. For example, check out the ARM-32
    `gcc` compiler''s location and version as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 工具通常安装在`/usr/bin/`下，因此已经包含在您的`PATH`中；您可以直接使用它们。例如，检查ARM-32 `gcc`编译器的位置和版本如下：
- en: '[PRE43]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Also, do keep in mind: this toolchain is appropriate for building the kernel
    for ARM 32-bit architecture, not for 64-bit. If that''s your intention (building
    for 64-bit, which we don''t cover here), you will need to install a x86_64-to-ARM64
    toolchain with `sudo apt install ​crossbuild-essential-arm64`.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住：此工具链适用于构建ARM 32位架构的内核，而不适用于64位架构。如果您的意图是构建64位架构（这里我们不涉及），您将需要安装一个x86_64到ARM64的工具链，使用`sudo
    apt install crossbuild-essential-arm64`。
- en: Second method – installation via the source repo
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二种方法-通过源代码库安装
- en: 'This is a more elaborate method. Here, we clone the toolchain from the Raspberry
    Pi''s GitHub repo:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种更复杂的方法。在这里，我们从树莓派的GitHub存储库克隆工具链：
- en: 'Download the toolchain. Let''s place it under the folder called `rpi_tools` within
    our Raspberry Pi staging directory:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载工具链。让我们将其放在名为`rpi_tools`的文件夹中，放在我们的树莓派分期目录中：
- en: '[PRE44]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Update the `PATH` environment variable so that it contains the toolchain binaries:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`PATH`环境变量，使其包含工具链二进制文件：
- en: '[PRE45]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Setting the `PATH` environment variable (as shown in the preceding code) is
    required. However, it's only valid for the current shell session. Make it permanent
    by putting the preceding line into a startup script (typically your `${HOME}/.bashrc` file
    or equivalent).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`PATH`环境变量（如前面的代码所示）是必需的。但是，它只对当前的shell会话有效。通过将前面的行放入启动脚本（通常是您的`${HOME}/.bashrc`文件或等效文件）使其永久化。
- en: As mentioned earlier, alternate toolchains can be used as well. For example, several
    toolchains for ARM development (for A-profile processors) are available on the
    ARM developer site at [https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，也可以使用其他工具链。例如，ARM开发（A型处理器）的几个工具链可在ARM开发者网站上找到。
- en: Step 3 – configuring and building the kernel
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3步-配置和构建内核
- en: 'Let''s configure the kernel (for the Raspberry Pi 2, Pi 3, and Pi 3[B]+). Before
    we begin, it''s *very important* to keep the following in mind:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置内核（适用于树莓派2、3和3[B]+）。在开始之前，*非常重要*要记住以下内容：
- en: The **`ARCH`** environment variable is to be set to the CPU (architecture) for
    which the software is to be cross-compiled (that is, the compiled code will run
    on that CPU). The value to set `ARCH` to is the name of the directory under the `arch/` directory
    in the kernel source tree. For example, set `ARCH` to `arm` for ARM32, to `arm64`
    for the  ARM64, to `powerpc` for the PowerPC, and to `openrisc` for the OpenRISC
    processor.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`ARCH`**环境变量应设置为要进行交叉编译的CPU（架构），即编译后的代码将在该CPU上运行。要设置`ARCH`的值，是内核源树中`arch/`目录下的目录名称。例如，将`ARCH`设置为`arm`用于ARM32，`arm64`用于ARM64，`powerpc`用于PowerPC，`openrisc`用于OpenRISC处理器。'
- en: The **`CROSS_COMPILE`** environment variable is to be set to the cross compiler
    (toolchain) prefix. Essentially, it's the first few common letters that precede
    every utility in the toolchain. In our following example, all the toolchain utilities
    (the C compiler `gcc`, linker, C++, `objdump`, and so on) begin with `arm-linux-gnueabihf-`,
    so that's what we set `CROSS_COMPILE` to. The `Makefile` will always invoke the
    utilities as `${CROSS_COMPILE}<utility>`, hence invoking the correct toolchain
    executable. This does imply that the toolchain directory should be within the `PATH` variable
    (as we mentioned in the preceding section).
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`CROSS_COMPILE`**环境变量应设置为交叉编译器（工具链）的前缀。基本上，它是在工具链中每个实用程序之前的前几个常见字母。在我们的下面的示例中，所有工具链实用程序（C编译器`gcc`，链接器，C++，`objdump`等）都以`arm-linux-gnueabihf-`开头，因此我们将`CROSS_COMPILE`设置为这个。`Makefile`将始终调用实用程序为`${CROSS_COMPILE}<utility>`，因此调用正确的工具链可执行文件。这意味着工具链目录应该在`PATH`变量中（正如我们在前面的部分中提到的）。'
- en: 'Okay, let''s build the kernel:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们构建内核：
- en: '[PRE46]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A quick explanation regarding the configuration target,`bcm2709_defconfig`:
    this key point was mentioned in [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml),
    *Building the 5.x Linux Kernel from Source – Part 1*. We must ensure that we use
    an appropriate board-specific kernel config file as a starting point. Here, this
    is the correct kernel config file for the Broadcom SoC on the Raspberry Pi 2,
    Pi 3, Pi 3+ and Compute Module 3 devices. The `bcm2709_defconfig` config target
    specified results in parsing in the content of the `arch/arm/configs/bcm2709_defconfig`
    file. (The Raspberry Pi website documents this as `bcm2709_defconfig` for Raspberry
    Pi 2, Pi 3, Pi 3+, and Compute Module 3 default build configuration. Important:
    if you are building the kernel for another type of Raspberry Pi device, please
    see [https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md).)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 关于配置目标`bcm2709_defconfig`的简要说明：这一关键点在[第2章](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml)中提到，*从源代码构建5.x
    Linux内核-第1部分*。我们必须确保使用适当的特定于板的内核配置文件作为起点。在这里，这是树莓派2、树莓派3、树莓派3+和计算模块3设备上Broadcom
    SoC的正确内核配置文件。指定的`bcm2709_defconfig`配置目标会解析`arch/arm/configs/bcm2709_defconfig`文件的内容。（树莓派网站将其文档化为适用于树莓派2、树莓派3、树莓派3+和计算模块3默认构建配置的`bcm2709_defconfig`。重要提示：如果您为其他类型的树莓派设备构建内核，请参阅[https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md)。）
- en: FYI, the `kernel7` value is as such because the processor is ARMv7-based (actually,
    from the Raspberry Pi 3 onward, the SoC is a 64-bit ARMv8, which is compatible
    with running in 32-bit ARMv7 mode; here, as we're building a 32-bit kernel for
    ARM32 (AArch32), we specify `KERNEL=kernel7`).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，`kernel7`的值是这样的，因为处理器是基于ARMv7的（实际上，从树莓派3开始，SoC是64位ARMv8，兼容在32位ARMv7模式下运行；在这里，因为我们正在为ARM32（AArch32）构建32位内核，我们指定`KERNEL=kernel7`）。
- en: 'The variety of SoCs, their packaging, and their resulting naming creates a
    good deal of confusion; this link might help: [https://raspberrypi.stackexchange.com/questions/840/why-is-the-cpu-sometimes-referred-to-as-bcm2708-sometimes-bcm2835](https://raspberrypi.stackexchange.com/questions/840/why-is-the-cpu-sometimes-referred-to-as-bcm2708-sometimes-bcm2835).'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: SoCs的种类、它们的封装以及它们的命名方式造成了很多混乱；这个链接可能会有所帮助：[https://raspberrypi.stackexchange.com/questions/840/why-is-the-cpu-sometimes-referred-to-as-bcm2708-sometimes-bcm2835](https://raspberrypi.stackexchange.com/questions/840/why-is-the-cpu-sometimes-referred-to-as-bcm2708-sometimes-bcm2835)。
- en: 'If any further customization of the kernel config is required, you could always
    do so with the following:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要对内核配置进行任何进一步的定制，您可以使用以下方法：
- en: '[PRE47]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If not, just skip this step and proceed. Build (cross-compile) the kernel,
    the kernel modules, and the DTBs with the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要，可以跳过此步骤并继续。使用以下方法构建（交叉编译）内核、内核模块和DTB：
- en: '[PRE48]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '(Adjust the `-jn` appropriately for your build host). Once the build is successfully
    completed, we can see the following files have been generated:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: （根据您的构建主机适当调整`-jn`）。一旦构建成功完成，我们可以看到生成了以下文件：
- en: '[PRE49]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, our purpose is just to show how a Linux kernel can be configured and built
    for an architecture other than the host system it's compiled upon, or in other
    words, cross-compiled. The gory details of placing the kernel image (and DTB file)
    on the microSD card and so on are not delved into. I refer you to the complete
    documentation for the Raspberry Pi kernel build, which can be found here: [https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的目的只是展示Linux内核如何配置和构建为不同于编译主机的架构，或者换句话说，进行交叉编译。关于将内核映像（和DTB文件）放在microSD卡上等细节不在此讨论范围内。我建议您查阅树莓派内核构建的完整文档，可以在这里找到：[https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md)。
- en: 'Nevertheless, here''s a quick tip to try out your new kernel on the Raspberry
    Pi 3[B+]:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这里有一个快速提示，可以在树莓派3[B+]上尝试新内核：
- en: Mount the microSD card. It will typically have a Raspbian distro on it and two
    partitions, `boot` and `rootfs`, corresponding to the `mmcblk0p1` and `mmcblk0p2` partitions respectively.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挂载microSD卡。通常会有一个Raspbian发行版和两个分区，`boot`和`rootfs`，分别对应`mmcblk0p1`和`mmcblk0p2`分区。
- en: '**The bootloader and associated binaries**: It''s key to get the low-level
    startup binaries, which includes the bootloader itself, onto the SD card''s boot
    partition; this includes the `bootcode.bin` (the actual bootloader), `fixup*.dat`,
    and `start*.elf` binaries; the content of the `/boot` folder is explained here: [https://www.raspberrypi.org/documentation/configuration/boot_folder.md](https://www.raspberrypi.org/documentation/configuration/boot_folder.md).
    (If you''re unsure of how to get these binaries, it''s perhaps easiest to simply
    install a stock version of Raspberry Pi OS onto an SD card; these binaries will
    get installed within its boot partition. The stock Raspberry Pi OS images can
    be obtained from [https://www.raspberrypi.org/downloads/](https://www.raspberrypi.org/downloads/);
    also, FYI, the newer Raspberry Pi Imager app (for Windows, macOS, Linux) makes
    it really easy to perform the first-time installation).'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**引导加载程序和相关二进制文件**：关键是将低级启动二进制文件，包括引导加载程序本身，放到SD卡的引导分区上；这包括`bootcode.bin`（实际的引导加载程序）、`fixup*.dat`和`start*.elf`二进制文件；`/boot`文件夹的内容在这里解释：[https://www.raspberrypi.org/documentation/configuration/boot_folder.md](https://www.raspberrypi.org/documentation/configuration/boot_folder.md)。（如果您不确定如何获取这些二进制文件，最简单的方法可能是在SD卡上安装一个标准版本的树莓派OS；这些二进制文件将被安装在其引导分区内。标准的树莓派OS镜像可以从[https://www.raspberrypi.org/downloads/](https://www.raspberrypi.org/downloads)获取；另外，新的Raspberry
    Pi Imager应用程序（适用于Windows、macOS、Linux）使得首次安装变得非常容易）。'
- en: If it exists, back up and then replace the `kernel7.img` file within the `/boot` partition
    on the microSD card with the `zImage` file that we just built, naming it `kernel7.img`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在，备份并用我们刚刚构建的`zImage`文件替换microSD卡上`/boot`分区内的`kernel7.img`文件，命名为`kernel7.img`。
- en: 'Install the just-built kernel modules; ensure you specify the location as the
    microSD card''s root filesystem with the `INSTALL_MOD_PATH` environment variable!
    (Failing to do so means it might overwrite your host''s modules, which would be
    disastrous!) Here, we imagine that the microSD card''s second partition (which
    contains the root filesystem) is mounted under `/media/${USER}/rootfs`; then,
    do the following (all in one line):'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装刚构建的内核模块；确保您将位置指定为microSD卡的根文件系统，使用`INSTALL_MOD_PATH`环境变量！（未这样做可能会覆盖主机的模块，这将是灾难性的！）在这里，我们假设microSD卡的第二个分区（其中包含根文件系统）被挂载在`/media/${USER}/rootfs`下；然后，执行以下操作（一行内全部执行）：
- en: '[PRE50]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Install the DTBs (and overlays) that we just generated on the SD card as well:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在SD卡上安装刚生成的DTB（和叠加）：
- en: '[PRE51]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Unmount the SD card, re-insert it into the device, and try it out.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卸载SD卡，重新插入设备，然后尝试。
- en: Again, to ensure it works, please refer to the official documentation (available
    at [https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md)).
    We have not covered the details regarding the generation and copying of kernel
    modules and DTBs to the microSD card.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，为了确保它能正常工作，请参考官方文档（可在[https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md)找到）。我们没有涵盖有关生成和复制内核模块和DTB到microSD卡的详细信息。
- en: Also, FYI, we again discuss kernel configuration and build for the Raspberry
    Pi in [Chapter 11](d6e5ebd3-1f04-40e8-a240-2607c58b1299.xhtml), *The CPU Scheduler
    – Part 2*.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，值得一提的是，我们在[第11章](d6e5ebd3-1f04-40e8-a240-2607c58b1299.xhtml)中再次讨论了树莓派的内核配置和构建，*CPU调度器-第2部分*。
- en: This completes our brief coverage on experimenting with a kernel cross-compilation
    for the Raspberry Pi. We'll end this chapter with a few miscellaneous but nevertheless
    useful tips.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对树莓派内核交叉编译的简要介绍。我们将以一些杂项但仍然有用的提示结束本章。
- en: Miscellaneous tips on the kernel build
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核构建的杂项提示
- en: We complete this chapter on building the Linux kernel from source with a few
    tips. Each of the following subsections encapsulates a tip for you to take note
    of.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一些提示结束了从源代码构建Linux内核的本章。以下各小节都包含了您需要注意的提示。
- en: 'Often a point of confusion for folks new to this: once we configure, build,
    and boot from a new Linux kernel, we notice that the root filesystem and any other
    mounted filesystems remain identical to what was on the original (distro or custom)
    system. Only the kernel itself has changed. This is entirely intentional, due
    to the Unix paradigm of having *a loose coupling* between the kernel and the root
    filesystem. Since it''s the root filesystem that holds all the applications, system
    tools, and utilities, including libraries, in effect, we can have several kernels,
    to suit different product flavors perhaps, for the same base system.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新手来说，经常会感到困惑的一点是：一旦我们配置、构建并从新的Linux内核引导，我们会注意到根文件系统和任何其他挂载的文件系统仍然与原始（发行版或自定义）系统上的相同。只有内核本身发生了变化。这是完全有意的，因为Unix范式要求内核和根文件系统之间*松散耦合*。由于根文件系统包含所有应用程序、系统工具和实用程序，包括库，实际上，我们可以为相同的基本系统拥有几个内核，以适应不同的产品风格。
- en: Minimum version requirements
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最低版本要求
- en: To successfully build the kernel, you have to ensure that your build system
    has the documented *bare minimum *versions of the various software pieces of the
    toolchain (and other miscellaneous tools and utilities). This very information
    is clearly within the kernel documentation in the *Minimal requirements to compile
    the kernel* section, available at[ ](https://github.com/torvalds/linux/blob/master/Documentation/process/changes.rst#minimal-requirements-to-compile-the-kernel)[https://github.com/torvalds/linux/blob/master/Documentation/process/changes.rst#minimal-requirements-to-compile-the-kernel](https://github.com/torvalds/linux/blob/master/Documentation/process/changes.rst#minimal-requirements-to-compile-the-kernel).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功构建内核，您必须确保您的构建系统具有工具链（和其他杂项工具和实用程序）的文档化的*最低版本*。这些信息清楚地在内核文档的*编译内核的最低要求*部分中，可在[ ](https://github.com/torvalds/linux/blob/master/Documentation/process/changes.rst#minimal-requirements-to-compile-the-kernel)[https://github.com/torvalds/linux/blob/master/Documentation/process/changes.rst#minimal-requirements-to-compile-the-kernel](https://github.com/torvalds/linux/blob/master/Documentation/process/changes.rst#minimal-requirements-to-compile-the-kernel)找到。
- en: For example, as of the time of writing, the recommended minimum version of `gcc`
    is 4.9 and that of `make` is 3.81.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在撰写本文时，推荐的`gcc`最低版本为4.9，`make`的最低版本为3.81。
- en: Building a kernel for another site
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为其他站点构建内核
- en: 'In our kernel build walk-through in this book, we built a Linux kernel on a
    certain system (here, it was an x86_64 guest) and booted the newly built kernel
    off the very same system. What if this isn''t the case, as will often happen when
    you are building a kernel for another site or customer premises? While it''s always
    possible to manually put the pieces in place on the remote system, there''s a
    far easier and more correct way to do it – build the kernel and associated meta-work
    bundled along with it (the `initrd` image, the kernel modules collection, the
    kernel headers, and so on) into a well-known **package format** (Debian''s `deb`,
    Red Hat''s `rpm`, and so on)! A quick `help` command on the kernel''s top-level
    `Makefile` reveals these package targets:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的内核构建步骤中，我们在某个系统上（这里是一个x86_64客户机）构建了Linux内核，并从同一系统上引导了新构建的内核。如果情况不是这样，比如当您为另一个站点或客户现场构建内核时，经常会发生什么？虽然始终可以在远程系统上手动放置这些部件，但有一种更简单和更正确的方法——将内核和相关的元工作（`initrd`镜像、内核模块集合、内核头文件等）打包成一个众所周知的**软件包格式**（Debian的`deb`、Red
    Hat的`rpm`等）！在内核的顶层`Makefile`上快速输入`help`命令，就会显示这些软件包目标：
- en: '[PRE52]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'So, for example, to build the kernel and its associated files as Debian packages,
    simply do the following:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，要构建内核及其关联文件作为Debian软件包，只需执行以下操作：
- en: '[PRE53]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The actual packages are written into the directory immediately above the kernel
    source directory. For example, from the command we just ran, here are the `deb`
    packages that were generated:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的软件包被写入到紧挨着内核源目录的目录中。例如，从我们刚刚运行的命令中，这里是生成的`deb`软件包：
- en: '[PRE54]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is indeed very convenient! Now, you can literally install the packages
    on any other matching (in terms of CPU and Linux flavor) system with a simple
    `dpkg -i <package-name>` command.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实非常方便！现在，你可以在任何其他匹配的（在CPU和Linux版本方面）系统上直接安装软件包，只需使用简单的`dpkg -i <package-name>`命令。
- en: Watching the kernel build run
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观看内核构建运行
- en: 'To see details (the `gcc(1)` compiler flags, and so on) while the kernel build
    runs, pass the **`V=1`** verbose option switch to `make(1)`. The following is
    a bit of sample output when building the Raspberry Pi 3 kernel with the verbose
    switch set to *on*:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核构建运行时查看详细信息（`gcc(1)`编译器标志等），将**`V=1`**详细选项开关传递给`make(1)`。以下是在设置为*on*的详细开关下构建Raspberry
    Pi 3内核时的一些示例输出：
- en: '[PRE55]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note that we have made the preceding output a bit more human-readable by inserting
    new lines and highlighting some switches. This level of detail can help debug
    situations where the build fails.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过插入新行和突出显示一些开关，使前面的输出更加易读。这种细节可以帮助调试构建失败的情况。
- en: A shortcut shell syntax to the build procedure
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建过程的快捷shell语法
- en: 'A shortcut shell (Bash, typically) syntax to the build procedure (assuming
    the kernel configuration step is done) could be something like the following example,
    to be used in non-interactive build scripts, perhaps:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快捷的shell（通常是Bash）语法到构建过程（假设内核配置步骤已完成）可能是以下示例，用于非交互式构建脚本：
- en: '[PRE56]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the preceding code, the **`&&`** and **`||`** elements are the shell''s
    (Bash''s) convenience conditional list syntax:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，**`&&`**和**`||`**元素是shell（Bash）的便利条件列表语法：
- en: '`cmd1 && cmd2` implies : run `cmd2` only if `cmd1` succeeds.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd1 && cmd2`意味着：只有在`cmd1`成功运行时才运行`cmd2`。'
- en: '`cmd1 || cmd2` implies : run `cmd2` only if `cmd1` fails.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd1 || cmd2`意味着：只有在`cmd1`失败时才运行`cmd2`。'
- en: Dealing with compiler switch issues
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理编译器开关问题
- en: 'A while back, in October 2016, when attempting to build an (older 3.x) kernel
    for the x86_64, I got the following error:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，2016年10月，当尝试为x86_64构建一个（较旧的3.x）内核时，我遇到了以下错误：
- en: '[PRE57]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'It turns out that it’s not a kernel issue at all. Rather, it''s a compiler
    switch issue on Ubuntu 16.10: `gcc(1)` insists on using the `-fPIE` (where **PIE** is
    short for **Position Independent Executable**) flag by default. In the Makefile
    of older kernels, we need to turn this off. It''s been fixed since.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，这根本不是内核问题。相反，这是Ubuntu 16.10上的编译器开关问题：`gcc(1)`默认坚持使用`-fPIE`（其中**PIE**缩写为**Position
    Independent Executable**）标志。在较旧的内核的Makefile中，我们需要关闭这个选项。这个问题已经解决了。
- en: This Q&A on the *AskUbuntu* website, on the topic of *Kernel doesn't support
    PIC mode for compiling?,* describes how this can be done: [https://askubuntu.com/questions/851433/kernel-doesnt-support-pic-mode-for-compiling](https://askubuntu.com/questions/851433/kernel-doesnt-support-pic-mode-for-compiling).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关于*AskUbuntu*网站上的Q&A，关于*Kernel doesn't support PIC mode for compiling?*，描述了如何做到这一点：[https://askubuntu.com/questions/851433/kernel-doesnt-support-pic-mode-for-compiling](https://askubuntu.com/questions/851433/kernel-doesnt-support-pic-mode-for-compiling)。
- en: (Interestingly, in the preceding *Watching the kernel build run* section, with
    a recent kernel, notice how the build does use the **`-fno-PIE`** compiler switch.)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: （有趣的是，在前面的*Watching the kernel build run*部分，使用最近的内核时，构建确实使用了**`-fno-PIE`**编译器开关。）
- en: Dealing with missing OpenSSL development headers
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理缺少的OpenSSL开发头文件
- en: 'In one instance, the kernel build on x86_64 on an Ubuntu box failed with the
    following error:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 有一次，在Ubuntu上的x86_64内核构建失败，出现了以下错误：
- en: '[PRE58]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is just a case of missing OpenSSL development headers; this is clearly
    mentioned in the *Minimal requirements to compile the kernel* document here: [https://github.com/torvalds/linux/blob/master/Documentation/process/changes.rst#openssl](https://github.com/torvalds/linux/blob/master/Documentation/process/changes.rst#openssl).
    Specifically, it mentions that from v4.3 and higher, the `openssl` development
    packages are required.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '这只是缺少OpenSSL开发头文件的情况；这在这里的*Minimal requirements to compile the kernel*文档中清楚地提到：[https://github.com/torvalds/linux/blob/master/Documentation/process/changes.rst#openssl](https://github.com/torvalds/linux/blob/master/Documentation/process/changes.rst#openssl)。具体来说，它提到从v4.3及更高版本开始，需要`openssl`开发包。 '
- en: FYI, this Q&A too shows how the installation of the `openssl-devel` package
    (or equivalent; for example, on the Raspberry Pi, the `libssl-dev` package needs
    to be installed) solves the issue: *OpenSSL missing during ./configure. How to
    fix?*, available at [https://superuser.com/questions/371901/openssl-missing-during-configure-how-to-fix](https://superuser.com/questions/371901/openssl-missing-during-configure-how-to-fix).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: FYI，这个Q&A也展示了如何安装`openssl-devel`软件包（或等效的；例如，在Raspberry Pi上，需要安装`libssl-dev`软件包）来解决这个问题：*OpenSSL
    missing during ./configure. How to fix?*，可在[https://superuser.com/questions/371901/openssl-missing-during-configure-how-to-fix](https://superuser.com/questions/371901/openssl-missing-during-configure-how-to-fix)找到。
- en: 'In fact, exactly this error occurred on a vanilla x86_64 *Fedora 29* distro
    as well:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在一个纯净的x86_64 *Fedora 29*发行版上也发生了完全相同的错误：
- en: '[PRE59]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The fix here is as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法如下：
- en: '[PRE60]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, remember an almost guaranteed way to succeed: when you get those build
    and/or boot errors that you *just cannot fix*: copy the exact error message into
    the clipboard, go to Google (or another search engine), and type something akin
    to `linux kernel build <ver ...> fails with <paste-your-error-message-here>`.
    You might be surprised at how often this helps. If not, diligently do your research,
    and if you really cannot find any relevant/correct answers, do post your (well-thought-out)
    question on an appropriate forum.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请记住一个几乎可以保证成功的方法：当你遇到那些你*无法解决*的构建和/或引导错误时：将确切的错误消息复制到剪贴板中，转到Google（或其他搜索引擎），并输入类似于`linux
    kernel build <ver ...> fails with <paste-your-error-message-here>`。你可能会惊讶地发现这有多么有帮助。如果没有，要认真地进行研究，如果你真的找不到任何相关/正确的答案，就在适当的论坛上发布你的（深思熟虑的）问题。
- en: Several Linux "builder" projects exist, which are elaborate frameworks for building
    a Linux system or distribution in its entirety (typically used for embedded Linux
    projects). As of the time of writing, ***Yocto*** ([https://www.yoctoproject.org/](https://www.yoctoproject.org/))
    is considered the industry standard Linux-builder project, with ***Buildroot***
    ([https://buildroot.org/](https://buildroot.org/)) being an older but very much
    supported one; they are indeed well worth checking out.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 存在几个Linux“构建器”项目，这些项目是用于构建整个Linux系统或发行版的复杂框架（通常用于嵌入式Linux项目）。截至撰写本文时，***Yocto***（[https://www.yoctoproject.org/](https://www.yoctoproject.org/)）被认为是行业标准的Linux构建器项目，而***Buildroot***（[https://buildroot.org/](https://buildroot.org/)）是一个更老但得到很好支持的项目；它们确实值得一看。
- en: Summary
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter, along with the previous one, covered in a lot of detail how to
    build the Linux kernel from source. We began with the actual kernel (and kernel
    modules') build process. Once built, we showed how the kernel modules are to be
    installed onto the system. We then moved on to both the practicalities of generating
    the `initramfs` (or `initrd`) image and went on to explain the motivation behind
    it. The final step in the kernel build was the (simple) customization of the bootloader
    (here, we focused only on x86 GRUB). We then showed how to boot the system via
    the newly baked kernel and verify that its configuration is as we expect. As a
    useful add-on, we then showed (the basics) of how we can even cross-compile the
    Linux kernel for another processor (ARM, in this instance). Finally, we shared
    some additional tips to help you with the kernel build.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以及前一章详细介绍了如何从源代码构建Linux内核。我们从实际的内核（和内核模块）构建过程开始。构建完成后，我们展示了如何将内核模块安装到系统上。然后我们继续讨论了生成`initramfs`（或`initrd`）镜像的实际操作，并解释了背后的动机。内核构建的最后一步是（简单的）自定义引导加载程序（这里，我们只关注x86
    GRUB）。然后我们展示了如何通过新构建的内核引导系统，并验证其配置是否符合预期。作为一个有用的附加功能，我们还展示了如何为另一个处理器（在这种情况下是ARM）交叉编译Linux内核的基础知识。最后，我们分享了一些额外的提示，以帮助你进行内核构建。
- en: Again, if you haven't done so already, we urge you to carefully review and try
    out the procedures mentioned here and build your own custom Linux kernel.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果你还没有这样做，我们建议你仔细审查并尝试这里提到的程序，并构建自己的定制Linux内核。
- en: So, congratulations on completing a Linux kernel build from scratch! You might
    well find that on an actual project (or product), you may *not* have to actually
    carry out each and every step of the kernel build procedure as we have tried hard
    to carefully show. Why? Well, one reason is that there might be a separate BSP
    team that works on this aspect; another reason – increasingly likely, especially
    on embedded Linux projects – is that a Linux-builder framework such as *Yocto* (or
    *Buildroot*) is being used. Yocto will typically take care of the mechanical aspects
    of the build. *However,* it is really important for you to be able to *configure*
    the kernel as required by the project; that still requires the knowledge and understanding
    gained here.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，恭喜你成功地从头开始构建了一个Linux内核！你可能会发现，在实际项目（或产品）中，你可能*不需要*像我们努力地仔细展示的那样执行内核构建过程的每一步。为什么呢？原因之一是可能会有一个单独的BSP团队负责这个方面；另一个原因
    - 在嵌入式Linux项目中尤其可能，是正在使用像*Yocto*（或*Buildroot*）这样的Linux构建框架。Yocto通常会处理构建的机械方面。*然而*，你真的需要能够根据项目要求*配置*内核；这仍然需要在这里获得的知识和理解。
- en: The next two chapters will take you squarely into the world of Linux kernel
    development, showing you how to write your first kernel module.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两章将带你深入了解Linux内核开发世界，向你展示如何编写你的第一个内核模块。
- en: Questions
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions).
    You will find some of the questions answered in the book''s GitHub repo: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn).'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一些问题供你测试对本章材料的了解：[https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions)。你会发现其中一些问题的答案在本书的GitHub存储库中：[https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn)。
- en: Further reading
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To help you delve deeper into the subject with useful materials, we provide
    a rather detailed list of online references and links (and at times, even books)
    in a Further reading document in this book's GitHub repository. The *Further reading*
    document is available here: [https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md](https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你深入学习这个主题，我们在本书的GitHub存储库中提供了一个相当详细的在线参考和链接列表（有时甚至包括书籍）的Further reading文档。*Further
    reading*文档在这里可用：[https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md](https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md)。
