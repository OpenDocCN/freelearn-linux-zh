- en: Chapter 3. Bootloaders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。引导加载程序
- en: In this chapter, you will be presented with one of the most important components
    necessary for using a Linux system in an embedded environment. Here, I am referring
    to the bootloader, a piece of software that offers the possibility of initializing
    a platform and making it ready to boot a Linux operating system. In this chapter,
    the benefits and roles of bootloaders will be presented. This chapter mainly focuses
    on the U-Boot bootloaders, but readers are encouraged to have a look at others,
    such as Barebox, RedBoot, and so on. All these bootloaders have their respective
    features and there isn't one in particular that suits every need; therefore, experimentation
    and curiosity are welcome when this chapter. You have already been introduced
    to the the Yocto Project reference in the last chapter; hence, you will now be
    able to understand how this development environment works with various bootloaders,
    and especially the ones available inside a **Board Support Package** (**BSP**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将介绍在嵌入式环境中使用Linux系统所必需的最重要的组件之一。我指的是引导加载程序，它是一种软件，可以初始化平台并使其准备好引导Linux操作系统。本章将介绍引导加载程序的好处和作用。本章主要关注U-Boot引导加载程序，但鼓励读者也了解其他引导加载程序，如Barebox、RedBoot等。所有这些引导加载程序都有各自的特点，没有一种特别适合所有需求；因此，在本章中欢迎进行实验和探索。
- en: The main purpose of this chapter is to present the main properties of embedded
    bootloaders and firmware, their booting mechanisms, and the problems that appear
    when firmware is updated or modified. We will also discuss the problems related
    to safety, installation, or fault tolerance. With regard to bootloader and firmware
    notions, we have multiple definitions available and a number of them refer to
    traditional desktop systems, which we are not interested in.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目的是介绍嵌入式引导加载程序和固件的主要属性，它们的引导机制，以及在固件更新或修改时出现的问题。我们还将讨论与安全、安装或容错相关的问题。关于引导加载程序和固件的概念，我们有多个定义可用，其中一些是指传统的桌面系统，而我们对此不感兴趣。
- en: 'A firmware usually represents a fixed and small program that is used on a system
    to control hardware. It performs low-level operations and is usually stored on
    flash, ROM, EPROM, and so on. It is not changed very often. Since there have been
    situations where this term has confused people and was sometimes used only to
    define hardware devices or represent data and its instructions, it was avoided
    altogether. It represents a combination of the two: computer data and information,
    along with the hardware device combined in a read-only piece of software available
    on the device.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 固件通常代表一个固定且小型的程序，用于控制硬件系统。它执行低级操作，通常存储在闪存、只读存储器、可擦写只读存储器等上。它不经常更改。由于有时会有人对这个术语感到困惑，并且有时仅用于定义硬件设备或表示数据及其指令，因此完全避免使用。它代表两者的结合：计算机数据和信息，以及与硬件设备结合在一起的只读软件，可用于设备上。
- en: The bootloader represents the piece of software that is first executed during
    system initialization. It is used to load, decompress, and execute one or more
    binary applications, such as a Linux kernel or a root filesystem. Its role involves
    adding the system in a state where it can execute its primary functions. This
    is done after loading and starting the correct binary applications that it receives
    or has already saved on the internal memory. Upon initializing, the hardware bootloader
    may need to initialize the **phase-locked loop** (**PLL**), set the clocks, or
    enable access to the RAM memory and other peripherals. However, these initializations
    are done on a basic level; the rest are done by kernels drivers and other applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序代表系统初始化时首先执行的软件部分。它用于加载、解压缩和执行一个或多个二进制应用程序，比如Linux内核或根文件系统。它的作用是将系统添加到可以执行其主要功能的状态。这是在加载和启动它接收到的或已经保存在内部存储器上的正确二进制应用程序之后完成的。在初始化时，硬件引导加载程序可能需要初始化锁相环（PLL）、设置时钟，或者启用对RAM存储器和其他外围设备的访问。然而，这些初始化是在基本级别上完成的；其余的由内核驱动程序和其他应用程序完成。
- en: Today, a number of bootloaders are available. Due to limited space available
    for this topic, and also the fact that their number is high, we will only discuss
    the most popular ones. U-Boot is one of the most popular bootloaders available
    for architectures, such as PowerPC, ARM, MIPS, and others. It will constitute
    the primary focus of this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 今天有许多引导加载程序可用。由于本主题的空间有限，而且它们的数量很多，我们只讨论最流行的几种。U-Boot是PowerPC、ARM、MIPS等架构中最流行的引导加载程序之一，它将成为本章的主要焦点。
- en: The role of the bootloader
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导加载程序的作用
- en: The first time that electricity runs into a development board processor, a great
    number of hardware components need to be prepared before running a program. For
    each architecture, hardware manufacturer, and even processor, this initialization
    process is different. In most cases, it involves a set of configurations and actions
    are different for a variety of processors and ends up fetching the bootstrap code
    from a storage device available in the proximity of the processor. This storage
    device is usually a flash memory and the bootstrap code is the first stage of
    the bootloader, and the one that initializes the processor and relevant hardware
    peripherals.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次电流进入开发板处理器时，运行程序之前需要准备大量的硬件组件。对于每种架构、硬件制造商，甚至处理器来说，初始化过程都是不同的。在大多数情况下，它涉及一组配置和操作，对于各种处理器来说都是不同的，并最终从处理器附近的存储设备中获取引导代码。这个存储设备通常是闪存存储器，引导代码是引导加载程序的第一阶段，它初始化处理器和相关硬件外围设备。
- en: The majority of the available processors when power is applied to them go to
    a default address location, and after finding the first bytes of binary data,
    start executing them. Based on this information, the hardware designers define
    the layout for the flash memory and the address ranges that could later be used
    to load and boot the Linux operating system from predictable addresses.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数可用的处理器在通电时会转到默认地址位置，并在找到二进制数据的第一个字节后开始执行它们。基于这些信息，硬件设计师定义了闪存内存的布局和后续可以用于从可预测地址加载和引导Linux操作系统的地址范围。
- en: In the first stage of initialization, the board init is done, usually in the
    assembler language specific to the processor and after this is finished, the entire
    ecosystem is prepared for the operating system booting process. The bootloader
    is responsible for this; it is the component that offers the possibility to load,
    locate, and execute primary components of the operating system. Additionally,
    it can contain other advanced features, such as the capability to upgrade the
    OS image, validate an OS image, choose between several OS images, and even the
    possibility to upgrade itself. The difference between the traditional PC BIOS
    and an embedded bootloader is the fact that in an embedded environment, the bootloader
    is overwritten after the Linux kernel starts execution. It, in fact, ceases to
    exist after it offers control to the OS image.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化的第一阶段，通常使用特定于处理器的汇编语言进行板子初始化，完成后，整个生态系统就准备好进行操作系统引导过程。引导程序负责这一切；它是提供加载、定位和执行操作系统的主要组件的可能性。此外，它还可以包含其他高级功能，比如升级OS映像、验证OS映像、在几个OS映像之间进行选择，甚至升级自身的可能性。传统PC
    BIOS和嵌入式引导程序之间的区别在于，在嵌入式环境中，引导程序在Linux内核开始执行后被覆盖。事实上，在它将控制权交给OS映像后，它就不复存在了。
- en: Bootloaders need to carefully initialize peripherals, such as flash or DRAM,
    before they are used. This is not an easy task to do. For example, the DRAM chips
    cannot be read or written in a direct method - each chip has a controller that
    needs to be enabled for read and write operations. At the same time, the DRAM
    needs to be continually refreshed because the data will be lost otherwise. The
    refresh operation, in fact, represents the reading of each DRAM location within
    the time frame mentioned by the hardware manufacturer. All these operations are
    the DRAM controller's responsibility, and it can generate a lot of frustration
    for the embedded developer because it requires specific knowledge about the architecture
    design and DRAM chip.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用外围设备之前，引导程序需要仔细初始化外围设备，比如闪存或DRAM。这并不是一件容易的事情。例如，DRAM芯片不能以直接的方式读取或写入 - 每个芯片都有一个需要启用读写操作的控制器。同时，DRAM需要不断刷新，否则数据将丢失。事实上，刷新操作代表了在硬件制造商规定的时间范围内读取每个DRAM位置。所有这些操作都是DRAM控制器的责任，它可能会给嵌入式开发人员带来很多挫折，因为它需要对架构设计和DRAM芯片有特定的了解。
- en: A bootloader does not have the infrastructure that a normal application has.
    It does not have the possibility to only be called by its name and start executing.
    After being switched on when it gains control, it creates its own context by initializing
    the processor and necessary hardware, such as DRAM, moves itself in the DRAM for
    faster execution, if necessary and finally, starts the actual execution of code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 引导程序没有普通应用程序的基础设施。它没有只能通过名称调用并开始执行的可能性。在获得控制权后，它通过初始化处理器和必要的硬件（如DRAM）创建自己的上下文，如果需要，将自己移动到DRAM中以加快执行速度，最后开始实际的代码执行。
- en: The first element that poses as a complexity is the compatibility of the start
    up code with the processor's boot sequence. The first executable instructions
    need to be at a predefined location in the flash memory, which is dependent of
    the processor and even hardware architecture. There is also the possibility for
    a number of processors to seek for those first executable instructions in several
    locations based on the hardware signals that are received.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个复杂性因素是启动代码与处理器的引导顺序的兼容性。第一个可执行指令需要位于闪存内存中的预定义位置，这取决于处理器甚至硬件架构。此外，有可能有多个处理器根据接收到的硬件信号在几个位置寻找这些第一个可执行指令。
- en: 'Another possibility is to have the same structure on many of the newly available
    development boards, such as the Atmel SAMA5D3-Xplained:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是在许多新的开发板上具有相同的结构，比如Atmel SAMA5D3-Xplained：
- en: '![The role of the bootloader](img/image00306.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![引导程序的作用](img/image00306.jpeg)'
- en: For the Atmel SAMA5D3-Xplained board and others similar to it, the booting starts
    from an integrated boot code available in the ROM memory called BootROM on AT91
    CPUs, which loads the first stage bootloader called AT91Bootstrap on SRAM and
    starts it. The first stage bootloader initializes the DRAM memory and starts the
    second stage bootloader, which is U-Boot in this case. More information on boot
    sequence possibilities can be found in the boot sequence header available, which
    you'll read about shortly.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Atmel SAMA5D3-Xplained板和其他类似的板，引导过程是从ROM内存中的集成引导代码BootROM开始的，该代码在AT91 CPU上加载第一阶段引导程序AT91Bootstrap到SRAM并启动它。第一阶段引导程序初始化DRAM内存并启动第二阶段引导程序，这种情况下是U-Boot。有关引导序列可能性的更多信息可以在即将介绍的引导序列头部中找到。
- en: The lack of an execution context represents another complexity. Having to write
    even a simple `"Hello World"` in a system without a memory and, therefore, without
    a stack on which to allocate information, would look very different from the well-known
    "Hello World" example. This is the reason why the bootloader initializes the RAM
    memory to have a stack available and is able to run higher-level programs or languages,
    such as C.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏执行上下文代表另一个复杂性。即使在一个没有内存，因此没有堆栈来分配信息的系统中编写一个简单的“Hello World”也会与众不同，这就是引导程序初始化RAM内存以便有一个可用的堆栈，并能够运行更高级的程序或语言，比如C的原因。
- en: Comparing various bootloaders
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较各种引导加载程序
- en: 'As we read earlier, a number of bootloaders are available for embedded systems.
    The ones that will be presented here are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所读到的，嵌入式系统有许多引导加载程序可用。这里将介绍以下引导加载程序：
- en: '**U-Boot**: This is also called the Universal Bootloader and is available mostly
    for PowerPC and ARM architectures for embedded Linux systems'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: U-Boot：也称为通用引导加载程序，主要适用于嵌入式Linux系统的PowerPC和ARM架构
- en: '**Barebox**: This was initially known as U-Boot v2 and was started in 2007
    with the scope to solve the limitations of U-Boot; it changed its name over time
    because the design goals and community changed'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Barebox：最初被称为U-Boot v2，于2007年开始，旨在解决U-Boot的局限性；随着设计目标和社区的变化，它随时间改变了名称
- en: '**RedBoot**: This is a RedHat bootloader derived from eCos, an open-source
    real-time operating system that is portable and devised for embedded systems'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RedBoot：这是一个源自eCos的RedHat引导加载程序，eCos是一种便携式的开源实时操作系统，专为嵌入式系统设计
- en: '**rrload**: This is a bootloader for ARM and is based on embedded Linux systems'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: rrload：这是一个基于嵌入式Linux系统的ARM引导加载程序
- en: '**PPCBOOT**: This is a bootloader for PowerPC and is based on embedded Linux
    systems'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PPCBOOT：这是用于PowerPC的引导加载程序，基于嵌入式Linux系统
- en: '**CLR/OHH**: This represents a flash bootloader for embedded Linux systems
    based on an ARM architecture'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLR/OHH：这代表基于ARM架构的嵌入式Linux系统的闪存引导加载程序
- en: '**Alios**: This is a bootloader that is written mostly in assembler, does ROM
    and RAM initializations, and tries to completely remove the need for firmware
    on embedded systems'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alios：这是一个主要用汇编语言编写的引导加载程序，进行ROM和RAM初始化，并试图完全消除嵌入式系统上固件的需求
- en: There are a number of bootloaders available and this is a natural outcome of
    the fact that there are a huge number of different architectures and devices,
    so many, in fact, that it is almost near impossible to have one that would be
    good for all systems. The variety of bootloaders is high; the differentiator factors
    are represented by the board types and structure, SOC differences and even CPUs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '有许多可用的引导加载程序，这是因为存在大量不同的架构和设备，实际上有很多，几乎不可能有一个适用于所有系统的引导加载程序。引导加载程序的种类很多；区分因素包括板类型和结构、SOC差异甚至CPU。 '
- en: Delving into the bootloader cycle
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入研究引导加载程序循环
- en: As mentioned previously, the bootloader is the component that is first run after
    initializing the system, and prepares the entire ecosystem for the operating system
    boot process. This process differs from one architecture to the other. For example,
    for the x86 architecture, the processor has access to BIOS, a piece of software
    available in a nonvolatile memory, which is usually a ROM. Its role starts out
    after resetting the system when it is executed and initializes the hardware components
    that will later be used by the first stage bootloader. It also executes the first
    stage of the bootloader.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，引导加载程序是在初始化系统后首先运行的组件，并为操作系统引导过程准备整个生态系统。这个过程因架构而异。例如，对于x86架构，处理器可以访问BIOS，这是一个可用于非易失性存储器的软件，通常是ROM。它的作用是在系统重置后开始执行并初始化硬件组件，这些组件稍后将被第一阶段引导加载程序使用。它还执行引导加载程序的第一阶段。
- en: The first stage bootloader is very small in terms of dimensions - in general,
    it is only 512 bytes and resides on a volatile memory. It performs the initialization
    for the full bootloader during the second stage. The second stage bootloaders
    usually reside next to the first stage ones, they contain the most number of features
    and do most of the work. They also know how to interpret various filesystem formats,
    mostly because the kernel is loaded from a filesystem.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段引导加载程序在尺寸上非常小 - 通常只有512字节，并驻留在易失性存储器中。它在第二阶段执行完整的引导加载程序初始化。第二阶段引导加载程序通常驻留在第一阶段引导加载程序旁边，它们包含最多的功能并完成大部分工作。它们还知道如何解释各种文件系统格式，主要是因为内核是从文件系统加载的。
- en: 'For x86 processors, there are more bootloader solutions that are available:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于x86处理器，还有更多可用的引导加载程序解决方案：
- en: '**GRUB**: The Grand Unified Bootloader is the most used and powerful bootloader
    available for Linux systems from desktop PC platforms. It is a component of the
    GNU Project and is one of the most potent bootloaders available for x86 architecture
    systems. This is because it is able to understand a large variety of filesystems
    and kernel images formats. It is able to change the the boot configuration during
    boot time. GRUB also has support for a network boot and command-line interface.
    It has a configuration file that is processed at boot time and can be modified.
    More information about it can be found at [http://www.gnu.org/software/grub/](http://www.gnu.org/software/grub/).'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GRUB：Grand Unified Bootloader是Linux系统中最常用和功能强大的引导加载程序，适用于台式PC平台。它是GNU项目的一部分，也是x86架构系统中最强大的引导加载程序之一。这是因为它能够理解各种文件系统和内核映像格式。它能够在引导时更改引导配置。GRUB还支持网络引导和命令行界面。它有一个在引导时处理并可修改的配置文件。有关更多信息，请访问[http://www.gnu.org/software/grub/](http://www.gnu.org/software/grub/)。
- en: '**Lilo**: The Linux Loader a bootloader mostly used in commercial Linux distributions.
    Similar to the previous point, it is available for desktop PC platforms. It has
    more than one component, the first component for historical reasons is available
    on the first sector of a disk drive; it is the bootstrap component. Due to the
    same historical reasons, it is limited to the 512 bytes dimension and it loads
    and offers control to the second stage bootloader that does most of the bootloader''s
    work. Lilo has a configuration utility that is mainly used as a source of information
    for the Linux kernel booting process. More information about it can be found at
    [http://www.tldp.org/HOWTO/LILO.html](http://www.tldp.org/HOWTO/LILO.html).'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Lilo**：Linux Loader是商业Linux发行版中经常使用的引导加载程序。与前面的情况类似，它适用于台式PC平台。它有多个组件，第一个组件出于历史原因位于磁盘驱动器的第一个扇区上；它是引导组件。出于同样的历史原因，它受限于512字节的尺寸，并且加载并提供控制给第二阶段引导加载程序，后者完成大部分引导加载程序的工作。Lilo有一个配置实用程序，主要用作Linux内核引导过程的信息来源。有关更多信息，请访问[http://www.tldp.org/HOWTO/LILO.html](http://www.tldp.org/HOWTO/LILO.html)。'
- en: '**Syslinux**: It is used for removable media or network booting. Syslinux is
    a Linux operating system bootloader that runs on MS-DOS or Windows FAT filesystems
    and is mainly used for rescue and first time installations of Linux. More information
    on it can be found at [http://www.kernel.org/pub/linux/utils/boot/syslinux/](http://www.kernel.org/pub/linux/utils/boot/syslinux/).'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Syslinux**：用于可移动媒体或网络引导。Syslinux是一个在MS-DOS或Windows FAT文件系统上运行的Linux操作系统引导加载程序，主要用于Linux的救援和首次安装。有关更多信息，请访问[http://www.kernel.org/pub/linux/utils/boot/syslinux/](http://www.kernel.org/pub/linux/utils/boot/syslinux/)。'
- en: For most embedded systems, this booting process does not apply, although there
    are some that replicate this behavior. There are two types of situations that
    will be presented next. The first one is a situation where the code execution
    starts from a fixed address location, and the second one refers to a situation
    where the CPU has a code available in the ROM memory that is called.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数嵌入式系统，这种引导过程并不适用，尽管有一些系统会复制这种行为。接下来将介绍两种情况。第一种情况是代码执行从固定地址位置开始，第二种情况是CPU在ROM存储器中有可调用的代码。
- en: '![Delving into the bootloader cycle](img/image00307.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![深入了解引导加载程序周期](img/image00307.jpeg)'
- en: The right-hand side of the image is presented as the previously mentioned booting
    mechanism. In this case, the hardware requires a NOR flash memory chip, available
    at the start address to assure the start of the code execution.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的右侧呈现为先前提到的引导机制。在这种情况下，硬件需要一个NOR闪存存储器芯片，该芯片位于起始地址，以确保代码执行的开始。
- en: A NOR memory is preferred over the NAND one because it allows random address
    access. It is the place where the first stage bootloader is programmed to start
    the execution, and this doesn't make it the most practical mechanism of booting.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: NOR存储器优于NAND存储器，因为它允许随机地址访问。这是第一阶段引导加载程序编程开始执行的地方，这并不使它成为最实用的引导机制。
- en: Although it is not the most practical method used for the bootloader boot process,
    it is still available. However, it somehow becomes usable only on boards that
    are not suitable for more potent booting options.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它并不是用于引导加载程序引导过程的最实用方法，但它仍然可用。然而，它在只适用于不适合更强大引导选项的板卡上才能使用。
- en: The U-Boot bootloader
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: U-Boot引导加载程序
- en: There are many open source bootloaders available today. Almost all of them have
    features to load and execute a program, which usually involves the operating system,
    and its features are used for serial interface communication. However, not all
    of them have the possibility to communicate over Ethernet or update themselves.
    Another important factor is represented by the widespread use of the bootloader.
    It is very common for organizations and companies to choose only one bootloader
    for the diversity of boards, processors, and architectures that they support.
    A similar thing happened with the Yocto Project when a bootloader was chosen to
    represent the official supported bootloader. They, and other similar companies,
    chose U-Boot bootloader, which is quite well known in the Linux community.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 今天有许多开源引导加载程序可用。几乎所有这些引导加载程序都具有加载和执行程序的功能，通常涉及操作系统，并且它们的功能用于串行接口通信。然而，并非所有引导加载程序都具有通过以太网通信或自我更新的可能性。另一个重要因素是引导加载程序的广泛使用。组织和公司通常会选择一种引导加载程序，以支持它们所支持的多样化的板卡、处理器和架构。类似的情况也发生在Yocto项目中，当选择一个引导加载程序来代表官方支持的引导加载程序时。他们和其他类似的公司选择了U-Boot引导加载程序，在Linux社区中相当知名。
- en: The U-Boot bootloader, or Das U-Boot as its official name, is developed and
    maintained by Wolfgang Denx with the support of the community behind it. It is
    licensed under GPLv2, its source code is freely available inside a `git` repository,
    as shown in the first chapter, and it has a two month intervals between releases.
    The release version name is shown as `U-boot vYYYY.MM`. The information about
    U-Boot loader is available at [http://www.denx.de/wiki/U-Boot/ReleaseCycle](http://www.denx.de/wiki/U-Boot/ReleaseCycle).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot引导加载程序，或其官方名称Das U-Boot，由Wolfgang Denx开发和维护，得到社区的支持。它在GPLv2许可下，其源代码在`git`存储库中免费提供，如第一章所示，每两个月发布一次。发布版本名称显示为`U-boot
    vYYYY.MM`。有关U-Boot加载程序的信息可在[http://www.denx.de/wiki/U-Boot/ReleaseCycle](http://www.denx.de/wiki/U-Boot/ReleaseCycle)找到。
- en: 'The U-Boot source code has a very well defined directory structure. This can
    be easily seen with this console command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot源代码具有非常明确定义的目录结构。可以通过以下控制台命令轻松看到这一点：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `arch` directory contains architecture-specific files and directories-specific
    to each architecture, CPU or development board. An `api` contains external applications
    that are independent of a machine or architecture type. A `board` contains inside
    boards with specific names of directories for all board-specific files. A common
    is a place where `misc` functions are located. A `disk` contains disk drive handling
    functions, and documentation is available inside the `doc` directory. Drivers
    are available in the `drivers` directory. The filesystem-specific functionality
    is available inside the `fs` directory. There are still some directories that
    would need mentioning here, such as the `include` directory, which contains the
    header files; the `lib` directory contains generic libraries with support for
    various utilities, such as the flatten device tree, various decompressions, a
    `post` (Power On Self-Test) and others, but I will let them be discovered by the
    reader's curiosity, one small hint would be to inspect the `README` file in the
    `Directory Hierachy` section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`arch`目录包含特定架构文件和每个架构、CPU或开发板特定目录。`api`包含独立于机器或架构类型的外部应用程序。`board`包含具有特定目录名称的所有特定板卡文件。`common`是`misc`函数的位置。`disk`包含磁盘驱动处理函数，文档可在`doc`目录中找到。驱动程序位于`drivers`目录中。文件系统特定功能位于`fs`目录中。还有一些目录需要在这里提到，比如`include`目录，其中包含头文件；`lib`目录包含对各种实用程序的通用库支持，例如扁平设备树、各种解压缩、`post`（自检）等，但我会让读者的好奇心去发现它们，一个小提示是检查`Directory
    Hierachy`部分的`README`文件。'
- en: 'Moving through the U-Boot sources, which were downloaded in the previous chapter
    inside the `./include/configs` file, configuration files can be found for each
    supported board. These configuration file is an `.h` file that contains a number
    of `CONFIG_` files and defines information on memory mapping, peripherals and
    their setup, command line output, such as the boot default addresses used for
    booting a Linux system, and so on. More information on the configuration files
    could be found inside the `README` file in the *Configuration Options,* section
    or in a board specific configuration file. For Atmel SAMA5D3-Xplained, the configuration
    file is `include/configs/sama5d3_xplained.h`. Also, there are two configurations
    available for this board in the `configs` directory, which are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在U-Boot源代码中，可以找到每个支持的板卡的配置文件，这些文件在前一章节中下载到`./include/configs`文件夹中。这些配置文件是`.h`文件，包含了一些`CONFIG_`文件和有关内存映射、外围设备及其设置、命令行输出等信息，例如用于引导Linux系统的默认引导地址等。有关配置文件的更多信息可以在*Configuration
    Options*部分的`README`文件中或特定板卡配置文件中找到。对于Atmel SAMA5D3-Xplained，配置文件是`include/configs/sama5d3_xplained.h`。此外，在`configs`目录中为该板卡提供了两种配置，分别是：
- en: '`configs/sama5d3_xplained_mmc_defconfig`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configs/sama5d3_xplained_mmc_defconfig`'
- en: '`configs/sama5d3_xplained_nandflash_defconfig`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configs/sama5d3_xplained_nandflash_defconfig`'
- en: 'These configurations are used to define the board **Secondary Program Loader**
    (**SPL**) initialization method. SPL represents a small binary built from the
    U-Boot source code that is placed on the SRAM memory and is used to load the U-Boot
    into the RAM memory. Usually, it has less than 4 KB of memory, and this is how
    the booting sequence looks:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置用于定义板卡**Secondary Program Loader**（**SPL**）初始化方法。SPL代表从U-Boot源代码构建的一个小型二进制文件，放置在SRAM内存中，用于将U-Boot加载到RAM内存中。通常，它的内存小于4KB，这就是引导序列的样子：
- en: '![The U-Boot bootloader](img/image00308.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![U-Boot引导程序](img/image00308.jpeg)'
- en: Before actually starting the build for the U-Boot source code for a specific
    board, the board configuration must be specified. For the Atmel SAMA5_Xplained
    development board, as presented in the preceding image, there are two available
    configurations that could be done. The configuration is done with the make `ARCH=arm
    CROSS_COMPILE=${CC} sama5d3_xplained_nandflash_defconfig` command. Behind this
    command, the `include/config.h` file is created. This header include definitions
    that are specific for the chosen board, architecture, CPU, and also board-specific
    header includes. The defined `CONFIG_*` variable read from the `include/config.h`
    file includes determining the compilation process. After the configuration is
    completed, the build can be started for the U-Boot.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际开始为特定板卡构建U-Boot源代码之前，必须指定板卡配置。对于Atmel SAMA5_Xplained开发板，如前图所示，有两种可用的配置。配置是通过使用`make
    ARCH=arm CROSS_COMPILE=${CC} sama5d3_xplained_nandflash_defconfig`命令完成的。在这个命令后面，将创建`include/config.h`文件。这个头文件包含了针对所选板卡、架构、CPU以及特定板卡头文件的定义。从`include/config.h`文件中读取的`CONFIG_*`变量包括了编译过程的确定。配置完成后，可以开始为U-Boot进行构建。
- en: 'Another example that can be very useful when inspected relates to the other
    scenario of booting an embedded system, one that requires the use of a NOR memory.
    In this situation, we can take a look at a particular example. This is also well
    described inside the *Embedded Linux Primer* by Christopher Hallinan, where a
    processor of the AMCC PowerPC 405GP is discussed. The hardcoded address for this
    processor is 0xFFFFFFFC and is visible using `.resetvec` , the reset vector placement.
    There also specifies the fact that the rest of this section is completed with
    only the value `1` until the end of the 0xFFFFFFFF stack; this implies that an
    empty flash memory array is completed only with values of `1`. The information
    about this section is available in `resetvec.S` file, which is located at `arch/powerpc/cpu/ppc4xx/resetvec.S`.
    The contents of `resetvec.S` file is as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能非常有用的示例涉及引导嵌入式系统的另一种情况，即需要使用NOR存储器。在这种情况下，我们可以看一个特定的示例。这也在Christopher Hallinan的《嵌入式Linux入门》中有很好的描述，其中讨论了AMCC
    PowerPC 405GP的处理器。该处理器的硬编码地址为0xFFFFFFFC，并且可以使用`.resetvec`，重置向量位置来查看。还指定了这一部分的其余部分只有值`1`直到0xFFFFFFFF堆栈的末尾；这意味着空的闪存存储器数组只包含值`1`。有关此部分的信息可在`resetvec.S`文件中找到，该文件位于`arch/powerpc/cpu/ppc4xx/resetvec.S`。`resetvec.S`文件的内容如下：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On inspection of this file's source code, it can be seen that only an instruction
    is defined in this section independently of the available configuration options.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 检查此文件的源代码，可以看到在这一部分中只定义了一条指令，而不管可用的配置选项如何。
- en: 'The configuration for the U-Boot is done through two types of configuration
    variables. The first one is `CONFIG_*`, and it makes references to configuration
    options that can be configured by a user to enable various operational features.
    The other option is called `CFG_*` and this is used for configuration settings
    and to make references to hardware-specific details. The `CFG_*` variable usually
    requires good knowledge of a hardware platform, peripherals and processors in
    general. The configure file for the SAMA5D3 Xplained hardware platform is available
    inside the `include/config.h` header file, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot的配置通过两种类型的配置变量完成。第一种是`CONFIG_*`，它引用了用户可以配置以启用各种操作功能的配置选项。另一个选项称为`CFG_*`，用于配置设置和引用硬件特定的细节。`CFG_*`变量通常需要对硬件平台、外围设备和处理器有很好的了解。SAMA5D3
    Xplained硬件平台的配置文件位于`include/config.h`头文件中，如下所示：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The configuration variables available here represent the corresponding configurations
    for the SAMA5D3 Xplained board. A part of these configurations refer to a number
    of standard commands available for user interactions with the bootloader. These
    commands can be added or removed for the purpose of extending or subtracting commands
    from the available command line interface.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此处提供的配置变量代表SAMA5D3 Xplained板的相应配置。这些配置的一部分涉及用户与引导加载程序的交互的一些标准命令。这些命令可以根据需要添加或删除，以扩展或减少可用命令行界面的命令。
- en: More information on the U-Boot configurable command interface can be found at
    [http://www.denx.de/wiki/view/DULG/UBootCommandLineInterface](http://www.denx.de/wiki/view/DULG/UBootCommandLineInterface).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有关U-Boot可配置命令界面的更多信息，请参阅[http://www.denx.de/wiki/view/DULG/UBootCommandLineInterface](http://www.denx.de/wiki/view/DULG/UBootCommandLineInterface)。
- en: Booting the U-Boot options
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导U-Boot选项
- en: In an industrial environment, interaction with the U-Boot is mainly done through
    the Ethernet interface. Not only does an Ethernet interface enable the faster
    transfer of operating system images, but it is also less prone to errors than
    a serial connection.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在工业环境中，与U-Boot的交互主要通过以太网接口完成。以太网接口不仅能够更快地传输操作系统映像，而且比串行连接更不容易出错。
- en: One of the most important features available inside a bootloader is related
    to the support for **Dynamic Host Control Protocol** (**DHCP**), **Trivial File
    Transfer Protocol** (**TFTP**), and even **Bootstrap Protocol** (**BOOTP**). BOOTP
    and DHPC enable an Ethernet connection to configure itself and acquire an IP address
    from a specialized server. TFTP enables the download of files through a TFTP server.
    The messages passed between a target device and the DHCP/BOOTP servers are represented
    in the following image in a more generic manner. Initially, the hardware platform
    sends a broadcast message that arrives at all the DHCP/BOOTP servers available.
    Each server sends back its offer, which also contains an IP address, and the client
    accepts the one that suits its purposes the best and declines the other ones.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序内部的一个最重要的功能与对动态主机控制协议（DHCP）、简单文件传输协议（TFTP）甚至引导协议（BOOTP）的支持有关。BOOTP和DHPC使以太网连接能够自行配置并从专用服务器获取IP地址。TFTP使得通过TFTP服务器下载文件成为可能。目标设备与DHCP/BOOTP服务器之间传递的消息在下图中以更通用的方式表示。最初，硬件平台发送一个广播消息，到达所有可用的DHCP/BOOTP服务器。每个服务器都会发送其提供的IP地址，客户端接受最适合其目的的那个，并拒绝其他的。
- en: '![Booting the U-Boot options](img/image00309.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![引导U-Boot选项](img/image00309.jpeg)'
- en: After the target device has finished communication with DHCP/BOOTP, it remains
    with a configuration that is specific to the target and contains information,
    such as the hostname, target IP and hardware Ethernet address (MAC address), netmask,
    tftp server IP address and even a TFTP filename. This information is bound to
    the Ethernet port and is used later in the booting process.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 目标设备与DHCP/BOOTP通信完成后，它将保留一个特定于目标的配置，其中包含主机名、目标IP和硬件以太网地址（MAC地址）、子网掩码、tftp服务器IP地址甚至是TFTP文件名。这些信息绑定到以太网端口，并在引导过程中后续使用。
- en: To boot images, U-Boot offers a number of capabilities that refer to the support
    of storage subsystems. These options include the RAM boot, MMC boot, NAND boot,
    NFS boot and so on. The support for these options is not always easy and could
    imply both hardware and software complexity.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于引导映像，U-Boot提供了许多与存储子系统支持相关的功能。这些选项包括RAM引导、MMC引导、NAND引导、NFS引导等等。对这些选项的支持并不总是容易的，可能涉及硬件和软件的复杂性。
- en: Porting U-Boot
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移植U-Boot
- en: I've mentioned previously that U-Boot is one of the most used and known bootloaders
    available. This is also due to the fact that its architecture enables the porting
    of new development platforms and processors in a very easy manner. At the same
    time, there are a huge number of development platforms available that could be
    used as references. The first thing that any developer who is interested in porting
    a new platform should do is to inspect the `board` and `arch` directories to establish
    their baselines, and, at the same time, also identify their similarities with
    other CPUs and available boards.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，U-Boot是最常用和知名的引导加载程序之一。这也是因为它的架构使得在新的开发平台和处理器上进行移植变得非常容易。同时，还有大量可用的开发平台可以作为参考。任何有兴趣移植新平台的开发人员首先应该做的事情是检查`board`和`arch`目录，以建立它们的基线，并同时识别它们与其他CPU和可用板子的相似之处。
- en: 'The `board.cfg` file is the starting point to register a new platform. Here,
    the following information should be added as a table line:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`board.cfg`文件是注册新平台的起点。在这里，应该添加以下信息作为表格行：'
- en: Status
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: Architecture
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构
- en: CPU
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU
- en: SOC
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOC
- en: Vendor
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应商
- en: Board name
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 板子名称
- en: Target
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标
- en: Options
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项
- en: Maintainers
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护者
- en: To port a machine similar to SAMA5D3 Xplained, one of the directories that could
    be consulted is the `arch` directory. It contains files, such as `board.c`, with
    information related to the initialization process for boards and SOCs. The most
    notable processes are `board_init_r()`, which does the setup and probing for board
    and peripherals after its relocation in the RAM, `board_init_f()`, which identifies
    the stack size and reserved address before its relocation in the RAM, and `init_sequence[]`,
    which is called inside the `board_init_f` for the setup of peripherals. Other
    important files inside the same locations are the `bootm.c` and `interrupts.c`
    files. The former has the main responsibility of the boot from memory of the operating
    system, and the latter is responsible for implementation of generic interrupts.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要移植类似于SAMA5D3 Xplained的机器，可以查阅的目录之一是`arch`目录。它包含了一些文件，比如`board.c`，其中包含了与板子和SOC的初始化过程相关的信息。最值得注意的过程是`board_init_r()`，它在RAM中重新定位后对板子和外设进行设置和探测，`board_init_f()`，它在RAM中重新定位之前识别堆栈大小和保留地址，以及`init_sequence[]`，它在`board_init_f`内部用于外设的设置。在相同位置内的其他重要文件还有`bootm.c`和`interrupts.c`文件。前者主要负责从内存中引导操作系统，后者负责实现通用中断。
- en: The `board` directory also has some interesting files and functions that need
    to be mentioned here, such as the `board/atmel/sama5d3_xplained/sama5d3_xplained.c`
    file. It contains functions, such as `board_init(), dram_init()`, `board_eth_init()`,
    `board_mmc_init`, `spl_board_ init()`, and `mem_init()` that are used for initialization,
    and some of them called by the `arch/arm/lib/board.c` file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`board`目录还有一些有趣的文件和函数需要在这里提到，比如`board/atmel/sama5d3_xplained/sama5d3_xplained.c`文件。它包含了一些函数，比如`board_init()`、`dram_init()`、`board_eth_init()`、`board_mmc_init()`、`spl_board_init()`和`mem_init()`，用于初始化，其中一些被`arch/arm/lib/board.c`文件调用。'
- en: 'Here are some other relevant directories:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些其他相关的目录：
- en: '`common`: This holds information about user commands, middleware, APIs that
    perform the interfacing between the middleware and user commands, and other functions
    and functionalities used by all available boards.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`common`：这包含了用户命令、中间件、用于中间件和用户命令之间的接口的API，以及所有可用板子使用的其他函数和功能。'
- en: '`drivers`: This contains drivers for various device drivers and middleware
    APIs, such as `drivers/mmc/mmc.c, drivers/pci/pci.c`, `drivers/watchdog/at91sam9_wdt.c`
    and so on.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drivers`：这包含了各种设备驱动程序和中间件API的驱动程序，比如`drivers/mmc/mmc.c`、`drivers/pci/pci.c`、`drivers/watchdog/at91sam9_wdt.c`等。'
- en: '`fs`: Various supported filesystems, such as USB, SD Card, Ext2 FAT, and so
    on are available here.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs`：各种支持的文件系统，如USB、SD卡、Ext2 FAT等都可以在这里找到。'
- en: '`include`: This represents the location where all the headers necessary for
    most of the boards are present. SOCs and other software is also available. Inside
    include/configs, board-specific configurations are available, and include the
    headers imported from Linux; these could be used for various device drivers, porting,
    or other byte operations.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`：这代表了大多数板子所需的所有头文件的位置。SOC和其他软件也可用。在include/configs中，可以找到特定于板子的配置，并包括从Linux导入的头文件；这些可以用于各种设备驱动程序、移植或其他字节操作。'
- en: '`tools`: This is the place where tools, such as `checkpatch.pl`, a patch examination
    tool used as a coding style check, are used before sending it to the mailing list
    or the `mkimage.c` tool. This is also used for the U-Boot generic header generation
    that makes Linux binaries, and assures that they are able to be booted using U-Boot.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tools`：这是工具的位置，比如`checkpatch.pl`，这是一个用于发送到邮件列表之前用作编码风格检查的补丁检查工具，或者`mkimage.c`工具。这也用于U-Boot通用头文件的生成，以便制作Linux二进制文件，并确保它们能够使用U-Boot引导。'
- en: More information about the SAMA5D3 Xplained board can be found by inspecting
    the corresponding doc directory and `README` files, such as `README.at91`, `README.at91-soc`,
    `README.atmel_mci`, `README.atmel_pmecc`, `README.ARM-memory-map`, and so on.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有关SAMA5D3 Xplained板的更多信息可以在相应的doc目录和`README`文件中找到，例如`README.at91`、`README.at91-soc`、`README.atmel_mci`、`README.atmel_pmecc`、`README.ARM-memory-map`等。
- en: For people interested in committing to the changes they made while porting a
    new development board, CPU, or SOC to U-Boot, a few rules should be followed.
    All of these are related to the `git` interaction and help you to ensure the proper
    maintenance of your branches.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有兴趣提交对U-Boot进行新开发板、CPU或SOC移植时所做的更改的人，应遵循一些规则。所有这些都与`git`交互有关，并帮助您确保正确维护您的分支。
- en: 'The first thing that a developer should do is to track the upstream branch
    that corresponds to a local branch. Another piece of advice would be to forget
    about `git` `merge` and instead use `git` `rebase`. Keeping in contact with the
    upstream repository can be done using the `git fetch` command. To work with patches,
    some general rules need to be followed, and patches need to have only one logical
    change, which can be any one of these:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员应该做的第一件事是跟踪对应于本地分支的上游分支。另一个建议是忘记`git` `merge`，而是使用`git` `rebase`。使用`git
    fetch`命令可以与上游存储库保持联系。要使用补丁，需要遵循一些一般规则，并且补丁只能有一个逻辑更改，可以是以下任何一个：
- en: Changes should not contain unrelated or different modifications; only one patch
    is available and acceptable per changeset
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改不应包含无关或不同的修改；每个更改集只有一个补丁可用和可接受
- en: Commits should make the use of `git-bisect` where possible while detecting bugs
    in sources, when necessary
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交应尽可能使用`git-bisect`来检测源代码中的错误时进行调试
- en: If multiple files are impacted by a set of modifications, all of them should
    be submitted in the same patch
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一组修改影响了多个文件，则所有这些文件都应在同一个补丁中提交
- en: Patches need to have review, and a very thorough one at that
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补丁需要进行审查，而且非常彻底
- en: 'Let''s take a look at following diagram, which illustrates the git rebase operation:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的图表，它说明了git rebase操作：
- en: '![Porting U-Boot](img/image00310.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![移植U-Boot](img/image00310.jpeg)'
- en: As shown in both the preceding and following diagram, the **git rebase** operation
    has recreated the work from one branch onto another. Every commit from one branch
    is made available on the succeeding one, just after the last commit from it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面和后面的图表所示，**git rebase**操作已将工作从一个分支重新创建到另一个分支。来自一个分支的每个提交都可以在后续的一个分支上使用，就在它的最后一个提交之后。
- en: '![Porting U-Boot](img/image00311.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![移植U-Boot](img/image00311.jpeg)'
- en: 'The `git merge` operation, on the other hand, is a new commit that has two
    parents: the branch from which it was ported, and the new branch on which it was
    merged. In fact, it gathers a series of commits into one branch with a different
    commit ID, which is why they are difficult to manage.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`git merge`操作是一个具有两个父级的新提交：从中进行移植的分支和进行合并的新分支。实际上，它将一系列提交收集到一个具有不同提交ID的分支中，这就是为什么它们难以管理。
- en: '![Porting U-Boot](img/image00312.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![移植U-Boot](img/image00312.jpeg)'
- en: More information related to `git` interactions can be found at [http://git-scm.com/documentation](http://git-scm.com/documentation)
    or [http://www.denx.de/wiki/U-Boot/Patches](http://www.denx.de/wiki/U-Boot/Patches).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`git`交互的更多信息可以在[http://git-scm.com/documentation](http://git-scm.com/documentation)或[http://www.denx.de/wiki/U-Boot/Patches](http://www.denx.de/wiki/U-Boot/Patches)找到。
- en: 'Almost always when porting a new feature in U-Boot, debugging is involved.
    For a U-Boot debugger, there are two different situations that can occur:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是在U-Boot中移植新功能时，都涉及调试。对于U-Boot调试器，可能会出现两种不同的情况：
- en: The first situation is when `lowlevel_init` was not executed
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种情况是`lowlevel_init`未被执行
- en: The second situation is when the `lowlevel_init` was executed; this is the most
    well known scenario
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种情况是`lowlevel_init`被执行；这是最为人所知的情况。
- en: 'In the next few lines, the second situation will be considered: the baseline
    enabling a debugging session for U-Boot. To make sure that debugging is possible,
    the `elf` file needs to be executed. Also, it cannot be manipulated directly because
    the linking address will be relocated. For this, a few tricks should be used:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几行中，将考虑第二种情况：为U-Boot启用调试会话的基线。为了确保可以进行调试，需要执行`elf`文件。此外，它不能直接操作，因为链接地址将被重定位。为此，应该使用一些技巧：
- en: 'The first step is to make sure that the environment is clean and that old objects
    are not available any more: `make clean`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一步是确保环境干净，旧对象不再可用：`make clean`
- en: 'The next step would be to make sure the dependencies are cleaned: `find ./
    | grep depend | xargs rm`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一步是确保依赖项已清理：`find ./ | grep depend | xargs rm`
- en: 'After the cleaning is finished, the target build can start and the output can
    be redirected inside a log file: `make sama5d3_xplained 2>&1 > make.log`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理完成后，目标构建可以开始，并且输出可以重定向到日志文件中：`make sama5d3_xplained 2>&1 > make.log`
- en: 'The generated output should be renamed to avoid debugging problems for multiple
    boards: `mv u-boot.bin u-boot_sama5d3_xplained.bin`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的输出应重命名以避免多个板的调试问题：`mv u-boot.bin u-boot_sama5d3_xplained.bin`
- en: It is important to enable DEBUG in the board configuration file; inside `include/configs/
    sama5d3_xplained.h`, add the `#define` DEBUG line
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在板配置文件中启用DEBUG很重要；在`include/configs/ sama5d3_xplained.h`中，添加`#define` DEBUG行
- en: 'An early development platform can be set up after relocation takes place and
    the proper breakpoint should be set after the relocation has ended. A symbol needs
    to be reloaded for U-Boot because the relocation will move the linking address.
    For all of these tasks, a `gdb` script is indicated as `gdb gdb-script.sh`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重定位发生后可以设置早期开发平台，并且应在重定位结束后设置适当的断点。需要重新加载U-Boot的符号，因为重定位将移动链接地址。对于所有这些任务，`gdb`脚本被指定为`gdb
    gdb-script.sh`：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information on relocation can be found at `doc/README.arm-relocation`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有关重定位的更多信息可以在`doc/README.arm-relocation`中找到。
- en: The Yocto Project
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Yocto项目
- en: The Yocto Project uses various recipes to define interactions to each of the
    supported bootloaders. Since there are multiple stages of booting, there are also
    multiple recipes and packages required inside the BSP. The recipes available for
    various bootloaders are not different from any other recipes available in the
    Yocto world. However, they have some details that make them unique.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto Project使用各种配方来定义与每个支持的引导加载程序的交互。由于引导启动有多个阶段，BSP内也需要多个配方和包。用于各种引导加载程序的配方与Yocto世界中的任何其他配方并无不同。然而，它们有一些使它们独特的细节。
- en: The board that we will focus on here is the `sama5d3_xplained` development board,
    and it is available inside the `meta-atmel` layer. Inside this layer, the corresponding
    recipes for the first and second stage bootloaders can be found inside the `recipes-bsp`
    directory. Here, I am referring to the `at91bootstrap` and `u-boot` recipes. There
    are some misconceptions about first stage and second stage bootloaders. They might
    be referred to as second level and third level bootloaders, because the boot ROM
    code may or may not be taken into account during a discussion. In this book, we
    prefer to call them as first stage and second stage bootloaders.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里关注的板子是`sama5d3_xplained`开发板，它位于`meta-atmel`层内。在这个层内，第一阶段和第二阶段引导加载程序的相应配方可以在`recipes-bsp`目录中找到。在这里，我指的是`at91bootstrap`和`u-boot`配方。关于第一阶段和第二阶段引导加载程序有一些误解。它们可能被称为第二级和第三级引导加载程序，因为在讨论中可能会考虑引导ROM代码。在本书中，我们更愿意称它们为第一阶段和第二阶段引导加载程序。
- en: The `AT91bootstrap` package represents the first-stage bootloader from Atmel
    available for their SOCs. It manages hardware initialization and also executes
    the second stage bootloader download from a boot media inside the memory; it starts
    it at the end. In the `meta-atmel` layer, the second stage bootloader is `u-boot`,
    and it is later used for the Linux operating system boot.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`AT91bootstrap`包代表了Atmel公司为其SOC提供的第一阶段引导加载程序。它管理硬件初始化，并执行从内存中的引导介质下载第二阶段引导加载程序；它在最后启动它。在`meta-atmel`层中，第二阶段引导加载程序是`u-boot`，它稍后用于Linux操作系统的引导。'
- en: Usually, inside a BSP layer, the support for multiple development boards is
    offered, and this means that multiple versions and bootloader packages are offered
    as well. The distinction between them, however, is on the basis of machine configurations.
    For the SAMA5D3 Xplained development board, the machine configuration is available
    inside the `conf/machine/sama5d3_xplained` file. In this file, the preferred bootloader
    versions, providers, and configurations are defined. If these configurations are
    not `MACHINE` specific, they could very well be performed inside the `package`
    recipe.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在BSP层内，支持多个开发板，这意味着也提供了多个版本和引导加载程序包。然而，它们之间的区别在于机器配置。对于SAMA5D3 Xplained开发板，机器配置可在`conf/machine/sama5d3_xplained`文件中找到。在这个文件中，定义了首选的引导加载程序版本、提供者和配置。如果这些配置不是`MACHINE`特定的，它们也可以在`package`配方中执行。
- en: 'This is one example of the configurations available for the `sama5d3_xplained`
    development board:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`sama5d3_xplained`开发板可用的配置之一：
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Summary
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you were presented with information on bootloaders, with particular
    focus on the U-Boot bootloader. We also discussed topics related to U-Boot interaction,
    porting, debugging, general information on bootloaders, U-Boot alternatives and
    a boot sequence inside an embedded environment. There was also a section related
    to the Yocto Project, where you were introduced to the mechanism used to support
    various bootloaders available inside BSP. A number of exercises were presented
    across the chapter, and they offered more clarity on this subject.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解引导加载程序的信息，特别关注U-Boot引导加载程序。我们还讨论了与U-Boot交互、移植、调试、引导加载程序的一般信息、U-Boot替代方案以及嵌入式环境中的引导序列相关的主题。还有一个与Yocto
    Project相关的部分，介绍了用于支持BSP内各种引导加载程序的机制。本章中提出了一些练习，它们为这个主题提供了更多的清晰度。
- en: In the next chapter, we will discuss the Linux kernel, its features and source
    code, modules and drivers, and, in general, most of the information needed to
    interact with the Linux kernel. As you have already been introduced to it, we
    will also concentrate on the Yocto Project and how it is able to work with various
    kernel versions for a number of boards and exercises. This should ease the understanding
    of the information presented to you.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Linux内核，其特性和源代码、模块和驱动程序，以及一般来说，与Linux内核交互所需的大部分信息。由于您已经对此有所了解，我们还将集中讨论Yocto
    Project以及它如何能够与多个板子和练习的各种内核版本一起工作。这应该有助于您理解所呈现的信息。
