["```\n$ uname -r\n4.15.0-23-generic\n$ ls -l /boot/config-4.15.0-23-generic \n-rw-r--r-- 1 root root 216807 May 23 22:24 /boot/config-4.15.0-23-generic\n$ stat /boot/config-4.15.0-23-generic \n File: /boot/config-4.15.0-23-generic\n Size: 216807 Blocks: 424 IO Block: 4096 regular file\nDevice: 801h/2049d Inode: 398628 Links: 1\nAccess: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root)\nAccess: 2018-07-30 12:42:09.789005000 +0530\nModify: 2018-05-23 22:24:55.000000000 +0530\nChange: 2018-06-17 12:36:34.259614987 +0530\n Birth: -\n$ \n```", "```\n#include <fcntl.h>\nint posix_fadvise(int fd, off_t offset, off_t len, int advice);\n```", "```\ninclude <fcntl.h>\nssize_t readahead(int fd, off64_t offset, size_t count);\n```", "```\n#include <unistd.h>\nssize_t pread(int fd, void *buf, size_t count, off_t offset);\nssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);\n```", "```\n+------+-----------+---------+-----------+------+-----------+\n|      | ... A ... |         | ... B ... |      | ... C ... |\n+------+-----------+---------+-----------+------+-----------+\n|A_HOLE|   A_LEN   | B_HOLE  |   B_LEN   |C_HOLE|  C_LEN    |\n+------+-----------+---------+-----------+------+-----------+\n       ^                     ^                  ^\n       A_START_OFF           B_START_OFF        C_START_OFF\n```", "```\n#define A_HOLE_LEN  10\n#define A_START_OFF A_HOLE_LEN\n#define A_LEN       20\n\n#define B_HOLE_LEN  100\n#define B_START_OFF (A_HOLE_LEN+A_LEN+B_HOLE_LEN)\n#define B_LEN        30\n\n#define C_HOLE_LEN  20\n#define C_START_OFF (A_HOLE_LEN+A_LEN+B_HOLE_LEN+B_LEN+C_HOLE_LEN)\n#define C_LEN       42\n...\nstatic int wr_discontig_the_normal_way(int fd)\n{ ...\n    /* A: {seek_to A_START_OFF, write gbufA for A_LEN bytes} */\n    if (lseek(fd, A_START_OFF, SEEK_SET) < 0)\n        FATAL(\"lseek A failed\\n\");\n    if (write(fd, gbufA, A_LEN) < 0)\n        FATAL(\"write A failed\\n\");\n\n    /* B: {seek_to B_START_OFF, write gbufB for B_LEN bytes} */\n    if (lseek(fd, B_START_OFF, SEEK_SET) < 0)\n        FATAL(\"lseek B failed\\n\");\n    if (write(fd, gbufB, B_LEN) < 0)\n        FATAL(\"write B failed\\n\");\n\n    /* C: {seek_to C_START_OFF, write gbufC for C_LEN bytes} */\n    if (lseek(fd, C_START_OFF, SEEK_SET) < 0)\n        FATAL(\"lseek C failed\\n\");\n    if (write(fd, gbufC, C_LEN) < 0)\n        FATAL(\"write C failed\\n\");\n    return 0;\n}\n```", "```\n$ ./sgio_simple \nUsage: ./sgio_simple use-method-option\n 0 = traditional lseek/write method\n 1 = better SG IO method\n$ ./sgio_simple 0\nIn setup_buffers_goto()\nIn wr_discontig_the_normal_way()\n$ ls -l tmptest \n-rw-rw-r--. 1 kai kai 222 Oct 16 08:45 tmptest\n$ hexdump -x tmptest \n0000000 0000 0000 0000 0000 0000 4141 4141 4141\n0000010 4141 4141 4141 4141 4141 4141 4141 0000\n0000020 0000 0000 0000 0000 0000 0000 0000 0000\n*\n0000080 0000 4242 4242 4242 4242 4242 4242 4242\n0000090 4242 4242 4242 4242 4242 4242 4242 4242\n00000a0 0000 0000 0000 0000 0000 0000 0000 0000\n00000b0 0000 0000 4343 4343 4343 4343 4343 4343\n00000c0 4343 4343 4343 4343 4343 4343 4343 4343\n00000d0 4343 4343 4343 4343 4343 4343 4343 \n00000de\n$ \n```", "```\n#include <sys/uio.h>\nssize_t readv(int fd, const struct iovec *iov, int iovcnt);\nssize_t writev(int fd, const struct iovec *iov, int iovcnt);\n```", "```\nstruct iovec {\n    void *iov_base; /* Starting address */\n    size_t iov_len; /* Number of bytes to transfer */\n};\n```", "```\nstatic int wr_discontig_the_better_SGIO_way(int fd)\n{\n  struct iovec iov[6];\n  int i=0;\n\n  /* We don't want to call lseek of course; so we emulate the seek\n   * by introducing segments that are just \"holes\" in the file. */\n\n  /* A: {seek_to A_START_OFF, write gbufA for A_LEN bytes} */\n  iov[i].iov_base = gbuf_hole;\n  iov[i].iov_len = A_HOLE_LEN;\n  i ++;\n  iov[i].iov_base = gbufA;\n  iov[i].iov_len = A_LEN;\n\n  /* B: {seek_to B_START_OFF, write gbufB for B_LEN bytes} */\n  i ++;\n  iov[i].iov_base = gbuf_hole;\n  iov[i].iov_len = B_HOLE_LEN;\n  i ++;\n  iov[i].iov_base = gbufB;\n  iov[i].iov_len = B_LEN;\n\n  /* C: {seek_to C_START_OFF, write gbufC for C_LEN bytes} */\n  i ++;\n  iov[i].iov_base = gbuf_hole;\n  iov[i].iov_len = C_HOLE_LEN;\n  i ++;\n  iov[i].iov_base = gbufC;\n  iov[i].iov_len = C_LEN;\n  i ++;\n\n  /* Perform all six discontiguous writes in order and atomically! */\n  if (writev(fd, iov, i) < 0)\n    return -1;\n/* Do note! As mentioned in Ch 19:\n   * \"the return value from readv(2) or writev(2) is the actual number\n   * of bytes read or written, and -1 on failure. It's always possible\n   * that an I/O operation performs less than the amount requested; this\n   * is not a failure, and it's up to the developer to check.\"\n   * Above, we have _not_ checked; we leave it as an exercise to the\n   * interested reader to modify this code to check for and read/write\n   * any remaining bytes (similar to this example: ch7/simpcp2.c).\n   */\n  return 0;\n}\n```", "```\n#include <sys/uio.h>\nssize_t preadv(int fd, const struct iovec *iov, int iovcnt,\n                      off_t offset);\nssize_t pwritev(int fd, const struct iovec *iov, int iovcnt,\n                       off_t offset);\n```", "```\n#include <sys/mman.h>\nvoid *mmap(void *addr, size_t length, int prot, int flags,\n           int fd, off_t offset);\n```", "```\n$ strace -e trace=openat,mmap ls > /dev/null\n...\nopenat(AT_FDCWD, \"/lib/x86_64-linux-gnu/libc.so.6\", O_RDONLY|O_CLOEXEC) = 3 \nmmap(NULL, 4131552, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f963d8a5000\nmmap(0x7f963dc8c000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7f963dc8c000\n...\n```", "```\n$ cat /sys/block/sda/queue/scheduler \nnoop deadline [cfq] \n$ \n```", "```\n$ cat /sys/block/sda/queue/scheduler \nmq-deadline [bfq] none\n$ \n```", "```\n# echo mq-deadline > /sys/block/sda/queue/scheduler \n# cat /sys/block/sda/queue/scheduler \n[mq-deadline] bfq none\n# \n```", "```\n#include <fcntl.h>\nint posix_fallocate(int fd, off_t offset, off_t len);\n```"]