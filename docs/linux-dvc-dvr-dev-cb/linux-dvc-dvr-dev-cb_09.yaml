- en: 'Additional Information: Using the Device Tree'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加信息：使用设备树
- en: Device tree internals
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备树内部
- en: A device tree is a tree data structure with nodes that tell you which devices
    are currently present in a system along with their configuration settings. Every
    node has property/value pairs that describe the attributes of the device being
    represented. Every node has exactly one parent but the root node has no parent.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树是一种树形数据结构，其中的节点告诉您系统中当前存在哪些设备以及它们的配置设置。每个节点都有描述所代表设备属性/值对。每个节点只有一个父节点，但根节点没有父节点。
- en: The next code shows an example representation of a simple device tree that is
    nearly complete enough to boot a simple operating system, with the platform type,
    CPU, memory, and a single **universal synchronous and asynchronous receiver-transmitter**
    (**UART**) described with its clocks and interrupt lines. Device nodes are shown
    with properties and values inside each node.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码显示了一个简单设备树的示例表示，该示例几乎足够完整以引导一个简单的操作系统，其中包括平台类型、CPU、内存和一个**通用同步和异步收发器**（UART），并描述了其时钟和中断线。设备节点显示为每个节点内的属性和值。
- en: 'The device tree syntax is quasi self-explanatory; however, we''re going to
    explain it in detail in this paragraph by taking a look at the `simple_platform.dts` file from
    the GitHub repository related to Chapter 4\. So, let''s start by taking a look
    at the end of the file:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树语法几乎是自解释的；但是，我们将通过查看与第4章相关的GitHub存储库中的`simple_platform.dts`文件来详细解释它。因此，让我们从文件末尾开始查看：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First of all, we should notice that property definitions are name/value pairs
    in the following form:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该注意，属性定义是以下形式的名称/值对：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is true except for properties with an empty (zero length) value, which
    have the following form:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是真实的，除了具有空（零长度）值的属性，其形式如下：
- en: '`[label:] property-name;`'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`[label:] property-name;`'
- en: For instance, in the preceeding example, we have the `compatible` properties of `serial@11100` node (labeled
    as `serial0`) set to a list composed by two strings `"fsl,mpc5125-psc-uart"` and `"fsl,mpc5125-psc"`,
    while the `fsl,rx-fifo-size` property is set to the number `16`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面的例子中，我们有`serial@11100`节点（标记为`serial0`）的`compatible`属性设置为由两个字符串`"fsl,mpc5125-psc-uart"`和`"fsl,mpc5125-psc"`组成的列表，而`fsl,rx-fifo-size`属性设置为数字`16`。
- en: 'Property values may be defined as an array of 8, 16, 32, or 64-bit integer
    elements, as NULL-terminated strings, as byte strings, or a combination of these.
    The storage size of an element can be changed using the `/bits/` prefix as follows,
    which defines property `interrupts` as an array of bytes and `clock-frequency`
    as a 64-bit number:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 属性值可以定义为8、16、32或64位整数元素的数组，作为以NULL结尾的字符串，作为字节字符串，或者这些的组合。元素的存储大小可以使用`/bits/`前缀进行更改，如下所示，它将属性`interrupts`定义为字节数组，`clock-frequency`定义为64位数字：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `/bits/` prefix allows for the creation of 8, 16, 32, and 64-bit elements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`/bits/`前缀允许创建8、16、32和64位元素。'
- en: Each node in the device tree is named according to the following `node-name@unit-address` convention, where
    the `node-name` component specifies the name of the node (usually it describes
    the general class of device), while the `unit-address` component of the name is
    specific to the bus type on which the node sits. For instance, in the preceding
    example, we have `serial@11100`, which means we have a serial port at address
    with offset `0x11100` from the `soc` node's base address, which is `0x80000000`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树中的每个节点都根据以下`node-name@unit-address`约定命名，其中`node-name`组件指定节点的名称（通常描述设备的一般类别），而名称的`unit-address`组件是特定于节点所在总线类型的。例如，在前面的例子中，我们有`serial@11100`，这意味着我们在地址`0x11100`处有一个串行端口，偏移量为`soc`节点的基地址`0x80000000`。
- en: 'Looking at the preceding example, it is quite clear that each node is then
    defined by a node name and unit address, with braces marking the start and end
    of the node definition (they may be preceded by a label) as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 看前面的例子，很明显每个节点都是由节点名称和单元地址定义的，用大括号标记节点定义的开始和结束（它们可能由标签前导），如下所示：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each node in the device tree has properties that describe the characteristics
    of the node; there exist standard properties that have a well-defined and standardized
    functionality, but we can also use our own properties to specify custom values.
    Properties consist of a name and a value, and for the example of our serial port,
    we set the `interrupts` property to the `<40 0x8>`array, while the `compatible` property is
    set to a list of strings and `fsl,rx-fifo-size` is set to a number.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树中的每个节点都有描述节点特征的属性；存在具有明确定义和标准化功能的标准属性，但我们也可以使用自己的属性来指定自定义值。属性由名称和值组成，对于我们串行端口的示例，我们将`interrupts`属性设置为`<40
    0x8>`数组，而`compatible`属性设置为字符串列表，`fsl,rx-fifo-size`设置为数字。
- en: 'A node in the device tree can be uniquely identified by clearly stating the
    full path from the root node, through all descendant nodes, to the desired node.
    The convention for specifying a device path is similar to the path names we usually
    use for a file in the filesystem; for example, in the preceding definition, the
    device path to our serial port is `/soc@80000000/serial@11100`, while the path
    to the root node is, obviously, `/`. This scenario is where labels come to play;
    in fact, they can be used in place of the full path to a node, that is, the clock
    used by serial port can be easily addressed using the `clks` labels as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树中的节点可以通过清楚地说明从根节点到所需节点的所有后代节点的完整路径来唯一标识。指定设备路径的约定类似于我们通常用于文件系统中的文件的路径名称；例如，在前面的定义中，我们串行端口的设备路径是`/soc@80000000/serial@11100`，而根节点的路径显然是`/`。这种情况是标签发挥作用的地方；实际上，它们可以用来代替节点的完整路径，即串行端口使用`clks`标签可以轻松寻址，如下所示：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also notice that `serial0` is defined as an alias of `tty0`. This syntax
    gives the developer another way to reference a node using a label instead of using
    its full pathname:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以注意到`serial0`被定义为`tty0`的别名。这种语法为开发人员提供了另一种使用标签而不是使用完整路径名引用节点的方式：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding definition is equivalent to the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的定义等同于以下内容：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It's quite clear now that a label can be used in a device tree source file as
    either a property handle (the label usually named as phandle) value or a path,
    depending on the context. In fact, the `&` character only refers to a phandle
    if it is inside an array; otherwise (if outside an array), it refers to a path!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很明显，标签可以在设备树源文件中作为属性句柄（标签通常被命名为phandle）值或路径使用，具体取决于上下文。实际上，如果`&`字符在数组内部，则它只引用phandle；否则（如果在数组外部），它引用路径！
- en: Aliases are not used directly in the device tree source, but they are, instead,
    dereferenced by the Linux kernel. In fact, when we ask the kernel to find a node
    by its path (we will see soon, in this chapter, the usage of such functions such
    as `of_find_node_by_path()`) if the path does not begin with the `/` character then
    the first element of the path must be a property name in the `/aliases` node.
    That element is replaced with the full path from the alias.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 别名不直接在设备树源中使用，而是由Linux内核进行解引用。实际上，当我们要求内核通过路径找到一个节点时（我们将很快在本章中看到这样的函数的用法，比如`of_find_node_by_path()`），如果路径不以`/`字符开头，那么路径的第一个元素必须是`/aliases`节点中的属性名称。该元素将被别名的完整路径替换。
- en: Another device tree's important entity to understand among nodes, labels, and
    aliases are phandles. The official definition tells us that the phandle property
    specifies a numerical identifier for a node that is unique within the device tree.
    In fact, this property value is used by other nodes that need to refer to the
    node associated with the property, so it's really just a hack to get around the
    fact that a device tree does not have a pointer data type.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点、标签和别名中，另一个设备树的重要实体是phandles。官方定义告诉我们，phandle属性指定了设备树中唯一的节点的数值标识符。实际上，其他需要引用与该属性关联的节点的节点使用了该属性值，因此这实际上只是一个绕过设备树没有指针数据类型的方法。
- en: 'In the preceding example, the `serial@11100` node is a way to specify which
    node is the interrupt controller and which one is the node with clock definitions
    used by phandles. However, in that example, they are not explicitly defined because
    the `dtc` compiler kindly creates phandles from labels. So, in the preceding example,
    we have the following syntax (where information that is not needed has been removed
    for better readability):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`serial@11100`节点是指定哪个节点是中断控制器，哪个节点是phandles使用的时钟定义的一种方式。然而，在该示例中，它们没有被显式定义，因为`dtc`编译器会从标签中创建phandles。因此，在上面的例子中，我们有以下语法（已删除不需要的信息以便更好地阅读）：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `dtc` compiler is the device tree compiler, which will be introduced in
    [Chapter 4](5f22a69e-e8b7-402e-8e67-72938d00c914.xhtml), *Using the Device Tree*,
    using the device tree compiler and utilities.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`dtc`编译器是设备树编译器，在[第4章](5f22a69e-e8b7-402e-8e67-72938d00c914.xhtml)中将介绍*使用设备树*，使用设备树编译器和实用程序。'
- en: 'This is equivalent to the next syntax in which phandles are made explicit:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于下一个语法，其中phandles被显式地制作出来：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Simply speaking, the `&` character tells `dtc` that the following string is
    a phandle referencing the label matching the string; it will then create a unique `u32` value
    for each label that is used for a phandle reference.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`&`字符告诉`dtc`后面的字符串是引用与该字符串匹配的标签的phandle；然后它将为每个用于phandle引用的标签创建一个唯一的`u32`值。
- en: Of course, you can define your own phandle property in one node and specify
    a label on a different node's name. Then, `dtc` will be aware of any phandle values
    explicitly stated and will not use those values when creating phandle values for
    labeled nodes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以在一个节点中定义自己的phandle属性，并在不同节点的名称上指定一个标签。然后，`dtc`将意识到任何明确声明的phandle值，并在为带标签的节点创建phandle值时不使用这些值。
- en: There is a lot to say about device tree syntax. However, we've covered what
    is sufficient to understand how to use a device tree during the device drivers
    development.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设备树语法有很多要说的。然而，我们已经涵盖了足够理解如何在设备驱动程序开发过程中使用设备树的内容。
- en: For complete documentation about this topic, you can read the device tree specifications
    at [https://www.devicetree.org/specifications/](https://www.devicetree.org/specifications/).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的完整文档，请阅读[https://www.devicetree.org/specifications/](https://www.devicetree.org/specifications/)上的设备树规范。
- en: Using the device tree compiler and utilities
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用设备树编译器和实用程序
- en: Here are some notes about some interesting usages of the `dtc` and its utilities
    which can be really useful during device drivers development and kernel configuration.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于`dtc`及其实用程序的一些有趣用法的注释，这些用法在设备驱动程序开发和内核配置过程中可能非常有用。
- en: Obtaining a source form of a running device tree
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取运行设备树的源代码形式
- en: '`dtc` can also be used to convert a running device tree into a human-readable
    form too! Let''s suppose we wish to know how our ESPRESSObin has been configured;
    the first thing to do is to take a look at ESPRESSObin''s DTS file in the kernel
    sources. However, suppose we don''t have it. In this situation, we can ask `dtc` to
    revert to the corresponding DTB file, as seen in the preceding section, but suppose
    we still don''t have it. What we can do? Well, `dtc` can help us again by reverting
    data stored in the `/proc/device-tree` directory, which holds a filesystem representation
    of the running device tree.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`dtc`也可以用来将运行中的设备树转换为人类可读的形式！假设我们想知道我们的ESPRESSObin是如何配置的；首先要做的事情是查看内核源代码中ESPRESSObin的DTS文件。但是，假设我们没有它。在这种情况下，我们可以要求`dtc`回退到相应的DTB文件，就像前面的部分所示，但是假设我们仍然没有它。我们能做什么？嗯，`dtc`可以通过回退存储在`/proc/device-tree`目录中的数据再次帮助我们，该目录保存了运行设备树的文件系统表示。'
- en: 'In fact, we can inspect the `/proc/device-tree` directory by using the `tree` command, as
    seen in the following (this output is just a snippet of the whole directory content):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以使用`tree`命令检查`/proc/device-tree`目录，就像下面所示的那样（这个输出只是整个目录内容的一部分）：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If not present, the `tree` command can be installed as usual with the `apt install
    tree` command.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在，可以像通常一样使用`apt install tree`命令安装`tree`命令。
- en: 'Then we can read string data inside each file as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以按以下方式读取每个文件中的字符串数据：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The last `echo` commands have just been used to add a new line character after
    the `cat` output to have more readable output.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`echo`命令只是用于在`cat`输出后添加一个新行字符，以获得更可读的输出。
- en: 'Numbers must be read as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 数字必须按以下方式读取：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, by using `dtc`, we can achieve better results. In fact, if we use
    the next command line, we ask `dtc` to convert all the DTB data into human-readable
    form:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，通过使用`dtc`，我们可以获得更好的结果。实际上，如果我们使用下一个命令行，我们要求`dtc`将所有DTB数据转换为人类可读的形式：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Of course, we must also install the `dtc` program into our ESPRESSObin with
    the `apt install device-tree-compiler` command.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还必须使用`apt install device-tree-compiler`命令将`dtc`程序安装到我们的ESPRESSObin中。
- en: 'Now, from the `espressobin-reverted.dts` file, we can easily read the device
    tree data:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从`espressobin-reverted.dts`文件中，我们可以轻松读取设备树数据：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notes on the device tree utilities
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备树实用程序的注意事项
- en: 'If we take a look at programs in the `device-tree-compiler` package that we
    installed previously, we can see that there are more programs than `dtc`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看之前安装的`device-tree-compiler`软件包中的程序，我们会发现除了`dtc`之外还有更多的程序：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These other programs are usually called **device tree utilities** and can be
    used to inspect or manipulate a device tree in its binary form (DTB).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些其他程序通常称为**设备树实用程序**，可用于检查或操作设备树的二进制形式（DTB）。
- en: 'For example, we can easily dump a DTB file using the `fdtdump` utility:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用`fdtdump`实用程序轻松转储DTB文件：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A careful reader will notice that the `fdtdump` utility itself tells us that
    it's only a low-level debugging tool and then to use `dtc` instead of decompiling,
    (or revert to DTS) a DTB file!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 细心的读者会注意到`fdtdump`实用程序本身告诉我们它只是一个低级调试工具，然后使用`dtc`而不是反编译（或恢复为DTS）DTB文件！
- en: 'Another two useful commands are `fdtget` and `fdtput`, which can be used to
    read and write data into our DTB file. The following are commands we can use to
    read the `bootargs` entry for the preceding DTB file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个有用的命令是`fdtget`和`fdtput`，可以用来读取和写入数据到我们的DTB文件中。以下是我们可以用来读取前述DTB文件的`bootargs`条目的命令：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we can change it with the next command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用下一个命令进行更改：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that we have had to use the `-ts` option argument to tell `fdtput` which
    type of data ours is, otherwise, the wrong values can be written!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须使用`-ts`选项参数告诉`fdtput`我们的数据类型，否则可能会写入错误的值！
- en: 'Not only that, we can also ask `fdtget` to list all the subnodes for each supplied
    node:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，我们还可以要求`fdtget`列出每个提供节点的所有子节点：
- en: '[PRE18]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Additionally, we can ask it to list all the properties for each node too:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以要求它列出每个节点的所有属性：
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Getting application-specific data from a device tree
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从设备树获取特定应用程序数据
- en: 'By using the functions from the `linux/drivers/of` directory, we''ll be able
    to extract all the information we need for our driver from a device tree. For
    instance, by using the  `of_find_node_by_path()` function, we can get a node pointer
    by its pathname:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`linux/drivers/of`目录中的函数，我们将能够从设备树中提取我们的驱动程序所需的所有信息。例如，通过使用`of_find_node_by_path()`函数，我们可以通过其路径名获取节点指针：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, once we have a pointer to a device tree node, we can use it to extract
    the needed information by using the `of_property_read_*()` functions, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦我们有了指向设备树节点的指针，我们可以使用它来通过使用`of_property_read_*()`函数提取所需的信息，如下所示：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that there are a lot of other functions we can use to extract information
    from a device tree, so you may take a look at the `linux/include/linux/of.h` file for
    a complete list.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以使用许多其他函数从设备树中提取信息，因此您可以查看`linux/include/linux/of.h`文件以获取完整列表。
- en: 'In case we wish to parse each property of a node, we can iterate them using
    the `for_each_property_of_node()` macro, which is defined as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望解析节点的每个属性，我们可以使用`for_each_property_of_node()`宏来迭代它们，其定义如下：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, if our node has more than one child (or subnode), we can iterate them
    by using the `for_each_child_of_node()` macro, which is defined as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们的节点有多个子节点，我们可以使用`for_each_child_of_node()`宏来迭代它们，其定义如下：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Using a device tree to describe a character driver
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用设备树描述字符驱动程序
- en: We have seen that by using a device tree, we can specify different driver settings
    and then modify the driver's functionalities. However, our possibilities do not
    finish here! In fact, we can use the same code for different driver's releases
    or a different types of the same device.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，通过使用设备树，我们可以指定不同的驱动程序设置，然后修改驱动程序的功能。但是，我们的可能性并不止于此！实际上，我们可以将相同的代码用于不同的驱动程序发布版本或相同设备的不同类型。
- en: How to manage different device types
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何管理不同的设备类型
- en: Let's suppose our `chrdev` has two other implementations (plus the current one)
    in which the hardware is done in such a way that most parameters are fixed (and
    well known) and not selectable by the developer; in this case, we can still use
    node properties to specify them, but doing this is error prone and it forces the
    user to know these constraints. For example, if in these two implementations,
    the hardware can work in read-only or read/write modes only (that is, the user
    is not free to specify the `read-only` property), we can call these special cases `"chrdev-fixed"` for
    the read/write version and `"chrdev-fixed_read-only"` for the read-only one.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的`chrdev`有另外两个实现（加上当前的实现），在这两个实现中，硬件的大部分参数都是固定的（并且是众所周知的），开发人员无法选择；在这种情况下，我们仍然可以使用节点属性来指定它们，但这样做容易出错，并且迫使用户了解这些约束。例如，如果在这两个实现中，硬件只能以只读或读/写模式工作（即用户无法自由指定`read-only`属性），我们可以将这些特殊情况称为`"chrdev-fixed"`用于读/写版本，`"chrdev-fixed_read-only"`用于只读版本。
- en: 'At this point, we can specify that the driver is now compatible with two other
    devices by modifying the `of_chrdev_req_match` array, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以指定驱动程序现在与其他两个设备兼容，方法是修改`of_chrdev_req_match`数组，如下所示：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We simply added two items with proper `compatible` strings and two special
    data entries, as defined in the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需添加两个具有适当`compatible`字符串和两个特殊数据条目，如下所定义：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this manner, we tell the driver that these devices can have one instance
    only and that they can work in read/write or read-only mode. By doing this, the
    user can use our devices by simply specifying a device tree as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们告诉驱动程序这些设备只能有一个实例，并且它们可以以读/写或只读模式工作。通过这样做，用户可以通过简单地指定设备树来使用我们的设备，如下所示：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Again, as before, you must modify the ESPRESSObin's DTS file and then recompile
    and reinstall the kernel.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您必须修改ESPRESSObin的DTS文件，然后重新编译和重新安装内核。
- en: By using this solution, the user doesn't need to know hardware internals since
    they are encapsulated into the driver by the driver developers (which are us,
    in this situation).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种解决方案，用户不需要了解硬件内部情况，因为驱动程序开发人员（在这种情况下是我们）已将其封装到驱动程序中。
- en: 'This compatible attribute can be evaluated for the driver by using `of_device_is_compatible()`
    function, as shown in the following example, where we''ve modified the `chrdev_req_probe()`
    function to support our `chrdev` special versions:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`of_device_is_compatible()`函数为驱动程序评估此兼容属性，如下例所示，我们已修改`chrdev_req_probe()`函数以支持我们的`chrdev`特殊版本：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As we can see, before scanning the node's children, we simply verify which is
    the currently installed `chrdev` device version for our system; in this case,
    we have one of the two new devices so we register a new `chrdev` device accordingly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，在扫描节点的子项之前，我们只需验证当前已安装的系统的`chrdev`设备版本；在这种情况下，我们有两个新设备中的一个，因此我们相应地注册一个新的`chrdev`设备。
- en: 'All these modifications can be done using the  `add_fixed_chrdev_devices.``patch` file with
    the following command line:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些修改都可以使用`add_fixed_chrdev_devices.patch`文件和以下命令行进行：
- en: '**`$ patch -p3 < add_fixed_chrdev_devices.patch`**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**`$ patch -p3 < add_fixed_chrdev_devices.patch`**'
- en: 'Now we can try the code by recompiling our `chrdev` driver and reinserting
    it (actually two modules) into ESPRESSObin as shown in the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过重新编译我们的`chrdev`驱动程序并将其重新插入（实际上是两个模块）到ESPRESSObin中来尝试代码，如下所示：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we can see, the driver has correctly recognized that a special version of
    the `chrdev` device (the read-only one) has been defined in the device tree.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，驱动程序正确地识别出设备树中已定义了`chrdev`设备的特殊版本（只读版本）。
- en: How to add sysfs properties to devices
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何向设备添加sysfs属性
- en: 'In a previous section, we briefly talked about the `/sys/class/chrdev` directory.
    We said that it''s related to the device classes (which can be defined in the
    system) and to kernel devices. In fact, when we call the `device_create()` function,
    we must specify the first argument that the device class pointer we allocated
    for the `chrdev_init()`, function and this action creates the  `/sys/class/chrdev` directory
    for which each `chrdev` device is reported as shown as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们简要讨论了`/sys/class/chrdev`目录。我们说它与设备类（可以在系统中定义）和内核设备有关。实际上，当我们调用`device_create()`函数时，我们必须指定第一个参数，即为`chrdev_init()`函数分配的设备类指针，此操作将为每个`chrdev`设备创建`/sys/class/chrdev`目录，如下所示：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So, a device class groups all devices with common characteristics, but which
    characteristics are we talking about? Well, simply speaking, these characteristics
    or attributes (shortly we'll see what they are exactly called) are a set of common
    information regarding our devices.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，设备类将所有具有共同特征的设备分组在一起，但我们在谈论哪些特征？简单地说，这些特征或属性（我们将很快看到它们确切的名称）是关于我们设备的一组共同信息。
- en: 'Each time we add a new device to the system, the kernel creates default attributes
    that can be seen from the user space as files under the sysfs, as shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 每次向系统添加新设备时，内核都会创建默认属性，可以在用户空间中看到这些属性，如下所示：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Well, in the preceding list, something is a file and something else is a directory
    or a symbolic link; however, here, the important thing is that, for each device,
    we have some attributes describing it. For instance, if we take a look at the `dev` attribute,
    we get the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，有些是文件，有些是目录或符号链接；然而，在这里，重要的是，对于每个设备，我们都有一些描述它的属性。例如，如果我们查看`dev`属性，我们会得到以下内容：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Which is exactly the major and minor number pair for our device? Now the question
    is, can we have more (and custom) attributes? Of course, the answer is yes, so
    let's see how to do this.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设备的主次编号是多少？现在的问题是，我们可以有更多（和自定义）属性吗？当然，答案是肯定的，所以让我们看看如何做到这一点。
- en: 'First, we have to modify the `chrdev.c`  file, adding a line to `chrdev_init()` as
    follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须修改`chrdev.c`文件，向`chrdev_init()`添加一行，如下所示：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This modification just set the `dev_groups` field of the struct pointed by `chrdev_class` equal
    to the `chrdev_groups` structure, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此修改只是将指向`chrdev_class`的结构的`dev_groups`字段设置为`chrdev_groups`结构，如下所示：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'All the modifications in this paragraph can be done by using patch file `add_sysfs_attrs_chrdev.patch`,
    with the following command line:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 本段中的所有修改都可以使用`add_sysfs_attrs_chrdev.patch`文件和以下命令行进行：
- en: '**`$ patch -p3 < add_sysfs_attrs_chrdev.patch`**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**`$ patch -p3 < add_sysfs_attrs_chrdev.patch`**'
- en: 'The preceding code is a complicated way of adding a group of attributes to
    our chrdev devices. To be more specific, the code just adds a single group of
    attributes named `id`, `reset_to`, and `read_only`. All of these attribute names
    are still defined in the modified `chrdev.c` file, as in the following snippet.
    Here is the read-only attribute:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是向我们的chrdev设备添加一组属性的复杂方式。更具体地说，该代码只是向名为`id`、`reset_to`和`read_only`的一组属性添加了单个组。所有这些属性名称仍然在修改后的`chrdev.c`文件中定义，如下摘录所示。这是只读属性：
- en: '[PRE34]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, the write-only attribute is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只写属性如下：
- en: '[PRE35]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, the read/write attribute is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，读/写属性如下：
- en: '[PRE36]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: By using `DEVICE_ATTR_RW()`, `DEVICE_ATTR_WO()`, and `DEVICE_ATTR_RO()`, we
    declare read/write, write-only, and read-only attributes, which are connected
    to entries in the array named `chrdev_attrs`, which is defined as the `struct
    attribute` type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`DEVICE_ATTR_RW()`，`DEVICE_ATTR_WO()`和`DEVICE_ATTR_RO()`，我们声明读/写、只写和只读属性，这些属性与名为`chrdev_attrs`的数组中的条目相关联，该数组被定义为`struct
    attribute`类型。
- en: When we use `DEVICE_ATTR_RW(read_only)`, then we must define two functions named `read_only_show()` and `read_only_store()` (the
    variable's name is `read_only` with the postfixes, `_show` and `_store`), so that
    the kernel invokes each time a user space process executes a `read()` or `write()` system
    call on the attribute file. Of course, the `DEVICE_ATTR_RO()` and `DEVICE_ATTR_WO()` variants
    require only the `_show` and `_store` functions, respectively.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用DEVICE_ATTR_RW(read_only)时，我们必须定义两个名为read_only_show()和read_only_store()的函数（变量名为read_only，带有后缀_show和_store），这样内核在用户空间进程在属性文件上执行read()或write()系统调用时会调用每个函数。当然，DEVICE_ATTR_RO()和DEVICE_ATTR_WO()变体只需要_show和_store函数，分别。
- en: To better understand how data is exchanged, let's take a closer look at these
    functions. By looking at the `read_only_show()` function, we can see that the
    data to be written is pointed by `buf`, while by using `dev_get_drvdata()`, we
    can obtain a pointer to our `struct chrdev_device` holding all the necessary information
    related to our custom implementation. For example, function `read_only_show()` function will
    return the value stored into the  `read_only` variable, which states the read-only
    property of our device. Note that `read_only_show()` must return a positive value
    representing how many bytes are returned, or a negative value if there is any
    error.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解数据是如何交换的，让我们更仔细地看看这些函数。通过查看read_only_show()函数，我们可以看到要写入的数据由buf指向，而通过使用dev_get_drvdata()，我们可以获得指向我们的struct
    chrdev_device的指针，其中包含与我们自定义实现相关的所有必要信息。例如，read_only_show()函数将返回存储在read_only变量中的值，该值表示设备的只读属性。请注意，read_only_show()必须返回一个表示返回多少字节的正值，或者如果有任何错误则返回一个负值。
- en: In a similar manner, the  `read_only_store()` function gives us data to be written
    into the `buf` buffer and `count` while we can use the same technique to get a
    pointer to the `struct chrdev_device`. The `read_only_store()` function reads
    a number in human-readable form (that is, ASCII representation) and then sets
    the `read_only` properties to 0 if we read value 0 or 1 otherwise.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，`read_only_store()`函数为我们提供要写入`buf`缓冲区和`count`的数据，同时我们可以使用相同的技术来获得指向`struct
    chrdev_device`的指针。`read_only_store()`函数以人类可读形式（即ASCII表示）读取一个数字，然后如果我们读取值为0，则将`read_only`属性设置为0，否则设置为1。
- en: Other attributes, `id` and `reset_to`, are used respectively to show the device's `id` or
    to force the internal buffer to the desired status independently of the fact the
    device itself was defined as read-only or not.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 其他属性id和reset_to分别用于显示设备的id或强制内部缓冲区达到所需状态，而不管设备本身是否被定义为只读。
- en: 'To test the code, we have to modify the `chrdev.c` file as described earlier,
    and then we have to recompile the code and move the resulting kernel modules to
    the ESPRESSObin. Now, if we insert the modules, we should get almost the same
    kernel messages as before, but now the content of the `/sys/class/chrdev` subdirectories
    should have changed. In fact, now we have the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试代码，我们必须像之前描述的那样修改chrdev.c文件，然后重新编译代码并将生成的内核模块移动到ESPRESSObin。现在，如果我们插入模块，我们应该得到几乎与之前相同的内核消息，但是现在/sys/class/chrdev子目录的内容应该已经改变。实际上，现在我们有以下内容：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As expected, we have three new attributes, as defined in our code. Then, we
    can try to read from them:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们在代码中定义了三个新属性。然后，我们可以尝试从中读取：
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'All answers are as expected; in fact, the `cdev-eeprom` device has `id` equal
    to 2, and is not read-only, while the  `reset_to` attributes are write-only, and
    not readable. A similar output can be obtained from `cdev-rom`, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所有答案都如预期；实际上，cdev-eeprom设备的id等于2，并且不是只读的，而reset_to属性是只写的，不可读。类似的输出也可以从cdev-rom中获得，如下所示：
- en: '[PRE39]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'These attributes are useful to inspect current device status but they can also
    be used to modify its behavior. In fact, we can set an initial value of the read-only
     `cdev-rom` device by using the  `reset_to` attributes as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性对于检查当前设备状态很有用，但也可以用于修改其行为。实际上，我们可以使用reset_to属性来为只读cdev-rom设备设置初始值，如下所示：
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now the `/dev/cdev-rom@4` device is still read-only, but it''s not filled by
    all zeros any more:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在/dev/cdev-rom@4设备仍然是只读的，但不再被全部零填充：
- en: '[PRE41]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Or, we can remove the read-only property from the `/dev/cdev-rom@4` device:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以从/dev/cdev-rom@4设备中移除只读属性：
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, if we retry writing data into it, we succeed (the kernel messages below
    the `echo` command are reported from the serial console):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试再次向其中写入数据，我们会成功（echo命令下方的内核消息是从串行控制台报告的）：
- en: '[PRE43]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Note that this works, but with an unexpected side effect of reading; we can
    write into the device, but the new TEST STRING is overwritten onto the new (longer) `reset_to` string
    we just set up (that is, THIS IS A READ-ONLY DEVICE) so that a subsequent read
    will give:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这样做是有效的，但会产生意外的副作用；我们可以写入设备，但新的TEST STRING会覆盖我们刚刚设置的新（更长的）reset_to字符串（即THIS
    IS A READ-ONLY DEVICE），因此随后的读取将会得到：
- en: '`# cat /dev/cdev-rom\@4`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ＃cat /dev/cdev-rom\@4
- en: '`TEST STRING`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 测试字符串
- en: '`AD ONLY DEVICE!`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 只读设备！
- en: However, this is an example and we can safely accept this behavior.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只是一个例子，我们可以安全地接受这种行为。
- en: Configuring the CPU pins for specific peripherals
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为特定外围设备配置CPU引脚
- en: Even if the ESPRESSObin is the reference platform of this book, in this paragraph,
    we'll explain how a kernel developer can modify the pins settings for different
    platforms due to the fact this task may vary across different implementations.
    In fact, even if all of these implementations are device tree-based, they have
    some differences among each other that must be outlined.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 即使ESPRESSObin是本书的参考平台，在本段中，我们将解释内核开发人员如何修改不同平台的引脚设置，因为这个任务可能因不同的实现而有所不同。实际上，即使所有这些实现都是基于设备树的，它们之间存在一些必须概述的差异。
- en: Current CPUs are very complex systems — so complex that most of them are given
    the acronym **SoC**, which means **System-On-Chip**; in fact, in a single chip,
    we may find not only the **Central Processing Unit** (**CPU**) but also a lot
    of peripherals, which the CPU can use to communicate with the external environment.
    So, we can have the display controller, the keyboard controller, a USB host or
    device controller, disks, and network controllers all together inside one chip.
    Not only that, but modern SoCs have several copies of them! All these peripherals
    have their own signals and each of them are routed over a dedicated physical line
    and each of these lines needs a pin to communicate with the external environment;
    however, it may happen that CPU pins are not enough to route all these lines to
    the outside, which is why most of them are multiplexed. This means that, for instance,
    a CPU may have six serial ports and two Ethernet ports but they cannot be used
    at the same time. Here is where the **pinctrl subsystem** comes into play.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的CPU是非常复杂的系统——复杂到大多数CPU都被赋予了缩写**SoC**，意思是**片上系统**；事实上，在一个芯片上，我们可能不仅可以找到**中央处理单元**（**CPU**），还有很多外围设备，CPU可以用来与外部环境进行通信。因此，我们可以在一个芯片内找到显示控制器、键盘控制器、USB主机或设备控制器、磁盘和网络控制器。不仅如此，现代SoC还有几个副本！所有这些外围设备都有自己的信号，每个信号都通过专用的物理线路进行路由，每条线路都需要一个引脚与外部环境进行通信；然而，可能会出现CPU引脚不足以将所有这些线路路由到外部的情况，这就是为什么大多数引脚都是多路复用的原因。这意味着，例如，CPU可能有六个串行端口和两个以太网端口，但它们不能同时使用。这就是**pinctrl子系统**发挥作用的地方。
- en: 'Linux''s pinctrl subsystem deals with enumerating, naming, and multiplexing
    controllable pins, such as software-controlled biasing and driving-mode-specific
    pins, such as pull-up/down, open-drain, load-capacitance, and more. All these
    settings can be done thanks to a **pin controller**, which is a piece of hardware
    (usually a set of registers) that can control CPU pins and it may be able to multiplex,
    bias, set load capacitance, or set drive strength for individual pins or groups
    of pins:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的pinctrl子系统处理枚举、命名和多路可控引脚，例如软件控制的偏置和驱动模式特定的引脚，例如上拉/下拉、开漏、负载电容等。所有这些设置都可以通过**引脚控制器**来完成，这是一种硬件（通常是一组寄存器），可以控制CPU引脚，可能能够对单个引脚或引脚组进行多路复用、偏置、设置负载电容或设置驱动强度。
- en: '![](img/3d784abe-8a03-493a-b9e2-2f8e780c1db8.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d784abe-8a03-493a-b9e2-2f8e780c1db8.png)'
- en: Unsigned integers ranging from 0 to maximum pin number are used to denote the
    packaging input or output lines we want to control.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号整数从0到最大引脚编号用于表示我们想要控制的封装输入或输出线路。
- en: This number space is local to each pin controller, so there may be several such
    number spaces in a system; each time a pin controller is instantiated it will
    register a descriptor containing an array of pin descriptors describing the pins
    handled by this specific pin controller.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字空间是每个引脚控制器本地的，因此在系统中可能有几个这样的数字空间；每次实例化引脚控制器时，它都会注册一个包含一组引脚描述符的描述符，描述这个特定引脚控制器处理的引脚。
- en: In this book, we're not going to explain how we can define a pin controller
    within the kernel, since it's out of the scope of this book (and it's also quite
    a complex task), but we'll try to give to the reader the ability to configure
    each CPU pin in order for it to be used with the driver they are developing by
    using, for example, three of the most used CPUs in the industry of embedded systems.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们不打算解释如何在内核中定义引脚控制器，因为这超出了本书的范围（而且也是一个相当复杂的任务），但我们将尝试为读者提供配置每个CPU引脚的能力，以便它们可以与他们正在开发的驱动程序一起使用，例如，在嵌入式系统行业中使用的三种最常用的CPU。
- en: The Armada 3720
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Armada 3720
- en: ESPRESSObin's CPU is the Armada 3720 from Marvell and we can have an idea about
    its internal peripherals by taking a look at the `linux/arch/arm64/boot/dts/marvell/armada-37xx.dtsi `file.
    This file defines the memory map of internal peripherals (which is how and where
    each peripheral is mapped within the CPU's memory) and all the CPU pins grouped
    by pin controllers and pin functionalities.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ESPRESSObin的CPU是Marvell的Armada 3720，我们可以通过查看`linux/arch/arm64/boot/dts/marvell/armada-37xx.dtsi`文件来了解其内部外围设备的情况。该文件定义了内部外围设备的内存映射（即每个外围设备在CPU内存中的映射方式和位置），以及按引脚控制器和引脚功能分组的所有CPU引脚。
- en: 'For example, the following snippet defines a pin controller named `pinctrl@13800`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码段定义了一个名为`pinctrl@13800`的引脚控制器：
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We should remember that this notation means that it's mapped at offset `0x13800` from
    the beginning of the parent node named `internal-regs@d0000000` and mapped at `0xd0000000`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该记住，这个表示法意味着它从名为`internal-regs@d0000000`的父节点的开头偏移`0x13800`处进行映射，并映射到`0xd0000000`处。
- en: 'Properties of the `compatible` states, which is the driver of this pin controller
    (stored into the `linux/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c `file), while
    each sub-node describes the functionality of a pin. We can see a GPIO controller
    with a clock device and a set of pin definitions (starting from `spi_quad_pins`),
    which the pins controller are defined in the following reported code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`compatible`属性表示这个引脚控制器的驱动程序（存储在`linux/drivers/pinctrl/mvebu/pinctrl-armada-37xx.c`文件中），而每个子节点描述了引脚的功能。我们可以看到一个带有时钟设备和一组引脚定义的GPIO控制器（从`spi_quad_pins`开始），这些引脚控制器在以下报告的代码中进行了定义。'
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `PIN_GRP_GPIO()` and `PIN_GRP_GPIO_2()` macros are used to specify the
    fact that a pin''s group can be used by an internal peripheral or just as normal
    GPIO lines. So, when we use the following code in the ESPRESSObin''s DTS file
    (code from `linux/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts` file)
    we ask the pin''s controller to reserve the `uart1_pins` group for the `uart0` device:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`PIN_GRP_GPIO()`和`PIN_GRP_GPIO_2()`宏用于指定引脚组可以被内部外围设备使用，或者只能作为普通的GPIO线路使用。因此，当我们在ESPRESSObin的DTS文件中使用以下代码（来自`linux/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts`文件）时，我们要求引脚控制器为`uart0`设备保留`uart1_pins`组。'
- en: '[PRE46]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that the line, `status = "okay"`, is needed because each device is normally
    disabled and if it is not specified, the device won't work.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`status = "okay"` 这一行是必需的，因为每个设备通常都是禁用的，如果不指定，设备将无法工作。
- en: Note that, this time, we have used the `pinctrl-0` property to declare peripheral's
    pins.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次我们使用了 `pinctrl-0` 属性来声明外围设备的引脚。
- en: The usage of the  `pinctrl-0` and `pinctrl-names` properties is strictly related
    to multiple pin's configuration states, which are not reported in this book due
    to limited space. However, curious readers can take a look at `https://www.kernel.org/doc/Documentation/devicetree/bindings/pinctrl/pinctrl-bindings.txt` for
    further information.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`pinctrl-0` 和 `pinctrl-names` 属性的使用与多引脚配置状态密切相关，由于空间有限，本书未对其进行报告。然而，有兴趣的读者可以查看
    `https://www.kernel.org/doc/Documentation/devicetree/bindings/pinctrl/pinctrl-bindings.txt`
    以获取更多信息。'
- en: The i.MX7Dual
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: i.MX7Dual
- en: 'Another quite famous CPU is the **i.MX7Dual from Freescale**, which is described
    in the  `linux/arch/arm/boot/dts/imx7s.dtsi` device tree file. Inside this file,
    we can see a definition of its two pin controllers as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相当著名的 CPU 是来自 Freescale 的 **i.MX7Dual**，它在 `linux/arch/arm/boot/dts/imx7s.dtsi`
    设备树文件中有描述。在该文件中，我们可以看到其两个引脚控制器的定义如下：
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'By using the `compatiblle` properties, we can discover that the pin controller''s
    driver is stored in the `linux/drivers/pinctrl/freescale/pinctrl-imx7d.c` file, where
    we can find the list of all CPU''s pin pads as follows (for space reasons only
    pin pads of second pin;s controller have been reported):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `compatible` 属性，我们可以发现引脚控制器的驱动程序存储在文件 `linux/drivers/pinctrl/freescale/pinctrl-imx7d.c`
    中，我们可以在其中找到所有 CPU 引脚的列表，如下所示（由于空间原因，仅报告了第二个引脚控制器的引脚）：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, all peripherals that need pins just have to declare them, as in the following
    example below taken from the DTS file of the **i.MX 7Dual SABRE board** again
    from Freescale:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，所有需要引脚的外围设备只需声明它们，就像从 Freescale 的 **i.MX 7Dual SABRE board** 的 DTS 文件中取出的以下示例一样：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding example, the `panel` node asks for the `pinctrl_backlight` pins
    groups, while `wdog1` asks for the `pinctrl_wdog` pins group; all these groups
    require pins from the `lpsr` pad.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`panel` 节点要求 `pinctrl_backlight` 引脚组，而 `wdog1` 要求 `pinctrl_wdog` 引脚组；所有这些组都需要来自
    `lpsr` 垫的引脚。
- en: Note that pins defines in the DTS can be found into file `linux/arch/arm/boot/dts/imx7d-pinfunc.h`.
    Also, the following numbers are specific pin settings, which are explained in
    the CPU's user manual, so refer to it for further information about these magic
    numbers.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，DTS 中定义的引脚可以在文件 `linux/arch/arm/boot/dts/imx7d-pinfunc.h` 中找到。此外，以下数字是特定的引脚设置，这些设置在
    CPU 的用户手册中有解释，因此请参考手册以获取有关这些神奇数字的更多信息。
- en: Again, the  `pinctrl-0` property has been used to address default pins configurations.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`pinctrl-0` 属性已用于寻址默认引脚配置。
- en: The SAMA5D3
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SAMA5D3
- en: 'The last example is about the CPU named `SAMA5D3 from Microchip`, which is
    described in the `linux/arch/arm/boot/dts/sama5d3.dtsi` file. The pins definitions
    schema is quite similar to the preceding one, in which we have a pins controller
    driver stored in the `linux/drivers/pinctrl/pinctrl-at91.c` file, and where all
    pins features are managed according to definitions in the device tree, as reported
    in the following example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例是关于名为 **SAMA5D3 from Microchip** 的 CPU，在 `linux/arch/arm/boot/dts/sama5d3.dtsi`
    文件中有描述。引脚定义模式与前面的相似，其中引脚控制器驱动程序存储在 `linux/drivers/pinctrl/pinctrl-at91.c` 文件中，并且所有引脚特性都根据设备树中的定义进行管理，如下例所示：
- en: '[PRE50]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Again, when a peripheral needs one more group of pins, it simply declares them,
    as in the following code taken from the DTS file of the **SAMA5D3 Xplained board** from
    the Microchip Technology:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当外围设备需要一个以上的引脚组时，它只需声明它们，就像从 Microchip Technology 的 **SAMA5D3 Xplained board**
    的 DTS 文件中取出的以下代码一样：
- en: '[PRE51]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding example, the `adc0` node asks for several pins groups to be
    able to manage its internal ADC peripherals.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`adc0` 节点要求多个引脚组，以便能够管理其内部 ADC 外围设备。
- en: The DTS schema of SAMA5D3 CPU still uses the `pinctrl-0` property to address
    the default pins configurations.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: SAMA5D3 CPU 的 DTS 模式仍然使用 `pinctrl-0` 属性来寻址默认引脚配置。
- en: Using a device tree to describe a character driver
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用设备树描述字符驱动程序
- en: 'To test the code presented in the recipe in the chapter and to show how everything works,
    we have to compile it before any further steps are taken:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试在本章中呈现的代码，并展示一切是如何工作的，我们必须在采取任何进一步步骤之前对其进行编译：
- en: '[PRE52]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, we have to move the `chrdev.ko` and `chrdev-req.ko` files to the ESPRESSObin.
    Now, if we insert the first module, we get exactly the same output we have seen
    before on the serial console (or in the kernel messages):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将 `chrdev.ko` 和 `chrdev-req.ko` 文件移动到 ESPRESSObin。现在，如果我们插入第一个模块，我们将在串行控制台上（或内核消息中）看到与之前完全相同的输出：
- en: '[PRE53]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The differences will appear when we insert the second module:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们插入第二个模块时，差异将会出现：
- en: '[PRE54]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Great! Now two new devices have been created. By doing this, the following
    two character files have been automatically created into the `/dev` directory:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在已经创建了两个新设备。通过这样做，以下两个字符文件已自动创建到 `/dev` 目录中：
- en: '[PRE55]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In reality, there is nothing magic here, but it's the `udev` program that does
    it for us and this will be explained a bit more in depth in the next section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这里没有什么神奇之处，而是由 `udev` 程序为我们完成的，这将在下一节中更深入地解释。
- en: The new devices have been named according to the labels specified in the device
    tree (as discussed previously) with minor numbers corresponding to the values
    used for each `reg` property.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 新设备的名称根据设备树中指定的标签进行命名（如前所述），次要编号对应于每个 `reg` 属性使用的值。
- en: 'Note that the  `cdev-eeprom@2` and `cdev-rom@4` names are created by the  `device_create()` function when
    we specified the printf-like format as in the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们指定 printf 格式时，`cdev-eeprom@2` 和 `cdev-rom@4` 名称是由 `device_create()` 函数创建的：
- en: '`device_create(... , "%s@%d", label, id);`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`device_create(... , "%s@%d", label, id);`'
- en: 'Now we can try to read and write data into our newly created devices. According
    to our definition in the device tree, the device labeled `cdev-eeprom` should
    be a read/write device, while the one labeled `cdev-rom` is a read-only device.
    So, let''s try some simple read/write commands on the `/dev/cdev-eeprom@2` character
    device:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试在我们新创建的设备中读取和写入数据。根据设备树中的定义，标记为`cdev-eeprom`的设备应该是读/写设备，而标记为`cdev-rom`的设备是只读设备。因此，让我们在`/dev/cdev-eeprom@2`字符设备上尝试一些简单的读/写命令：
- en: '[PRE56]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note the backslash (`\`) character before `@ ` otherwise, BASH will generate
    an error.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在`@`之前的反斜杠（`\`）字符，否则，BASH会生成错误。
- en: 'To verify that everything works as before, the related kernel messages are
    reported as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证一切是否与以前一样，相关的内核消息报告如下：
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We can see that, by the first command, we call an `open()` system call and that
    the driver recognizes the device `id` equal to 2 then, we write 12 bytes (that
    is, the `TEST STRING` plus the termination character); after that, we close the
    device. Using the `cat` command instead, we still open the device, but after that,
    we do the first read of 131,072 bytes (and the driver correctly returns 300 bytes
    only) followed by another read of the same number of bytes, which achieves the
    answer 0, meaning an end-of-file condition; so, the `cat` command closes the device
    and prints the received data (or, at least, all the printable bytes) before exiting.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，通过第一个命令，我们调用了`open()`系统调用，驱动程序识别出设备`id`等于2，然后我们写入了12个字节（即`TEST STRING`加上终止字符）；之后，我们关闭了设备。相反，使用`cat`命令，我们仍然打开了设备，但之后，我们进行了131,072字节的第一次读取（驱动程序只正确返回了300字节），然后进行了相同数量的字节的另一次读取，得到了答案0，表示文件结束；因此，`cat`命令关闭了设备并打印了接收到的数据（或者至少是所有可打印的字节），然后退出。
- en: 'Now we can try the same commands on the other `/dev/cdev-rom@4` device. The
    output is as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试在另一个`/dev/cdev-rom@4`设备上执行相同的命令。输出如下：
- en: '[PRE58]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The first command failed as expected, while the second seemed to return nothing;
    however, this is because all the read data is 0 and to verify this, we can use
    the `od` command as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令如预期般失败，而第二个似乎没有返回任何内容；然而，这是因为所有读取的数据都是0，为了验证这一点，我们可以使用`od`命令如下：
- en: '[PRE59]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This demonstrates that no data has been written into the `/dev/cdev-rom@4` device, which
    has been defined as read-only in the device tree.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明没有数据被写入`/dev/cdev-rom@4`设备，该设备在设备树中被定义为只读。
- en: 'As in the preceding code, we can take another look at the kernel messages to
    verify that everything works well (the following are reported kernel messages
    relative to the `od` command):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的代码一样，我们可以再次查看内核消息，以验证一切是否正常（以下是与`od`命令相关的报告的内核消息）：
- en: '[PRE60]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the preceding output, we can see that we first open the device (this time,
    the device with `id` equal to four) and then we use the `write()` system call,
    which obviously fails so the device is simply closed. The two following readings
    then work in exactly the same way as the preceding ones.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到我们首先打开了设备（这次是设备id等于四的设备），然后我们使用了`write()`系统调用，显然失败了，所以设备被简单地关闭了。接下来的两次读取与前面的读取完全相同。
- en: Now we should try to modify the device tree to define different chrdev devices
    or, better still, should try to modify the driver to add more functionalities.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该尝试修改设备树以定义不同的chrdev设备，或者更好的是，应该尝试修改驱动程序以添加更多功能。
