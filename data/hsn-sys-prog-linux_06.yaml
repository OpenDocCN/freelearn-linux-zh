- en: Debugging Tools for Memory Issues
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存问题调试工具
- en: We humans (we assume a human is reading this book and not some form of AI, though,
    who knows nowadays) are good at many intricate, complex tasks; but, we're also
    terrible at many mundane ones. That's why we invented computers—with the software
    to drive them!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们人类（我们假设是人类在阅读这本书，而不是某种形式的人工智能，尽管，谁知道现在）擅长许多复杂的任务；但是，我们也擅长许多平凡的任务。这就是为什么我们发明了计算机——配备了驱动它们的软件！
- en: 'Well. We''re not really great at spotting details buried deep inside C (or
    assembly) code—memory bugs are a prime example of cases where we humans can use
    help. So, guess what: we''ve invented software tools to help us—they do the mundane,
    boring job of instrumenting and checking millions and billions of lines of our
    code and binaries, and are getting really effective at catching our bugs. Of course,
    when all is said and done, the best tool is still your brain, but nevertheless
    one might well ask: Who and what will debug the tools that one uses for debugging? The
    answer, of course, is more tools, and you, the human programmer.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯。我们并不擅长发现深藏在C（或汇编）代码中的细节——内存错误是我们人类可以使用帮助的典型案例。所以，猜猜看：我们发明了软件工具来帮助我们——它们做乏味的工作，检查我们数以百万计甚至数十亿行代码和二进制代码，并且在捕捉我们的错误方面非常有效。当然，说到底，最好的工具仍然是你的大脑，但是人们可能会问：谁和什么来调试我们用于调试的工具？答案当然是更多的工具，以及你，作为人类程序员。
- en: 'In this chapter, the reader will learn to use two of the best-in-class memory
    debug tools:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，读者将学习如何使用两种最佳的内存调试工具：
- en: Valgrind's Memcheck
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Valgrind的Memcheck
- en: Sanitizer tools (ASan)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sanitizer工具（ASan）
- en: Useful tables summarizing and comparing their features are provided. Also, glibc's
    malloc tuning via `mallopt(3)` is seen.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了有用的表格，总结和比较它们的特性。还可以看到通过`mallopt(3)`调整glibc的malloc。
- en: This particular chapter has no source code of it's own; instead, we use the
    source code from the preceding chapter, [Chapter 5](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml), *Linux
    Memory Issues. *Our `membugs` program test cases will be tried and tested under
    both Valgrind and ASan to see if they can catch the memory bugs that our *memugs* program's
    test cases work hard to provide. Thus, we definitely suggest you look over the
    previous chapter, and the `membugs.c` source code, to regain familiarity with
    the test cases we will be running.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章没有自己的源代码；相反，我们使用了上一章的源代码，即[第5章](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml)，*Linux内存问题*。我们的`membugs`程序测试案例将在Valgrind和ASan下进行测试，以查看它们是否能捕捉到我们的*memugs*程序的测试案例努力提供的内存错误。因此，我们强烈建议您复习前一章和`membugs.c`源代码，以重新熟悉我们将要运行的测试案例。
- en: Tool types
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具类型
- en: 'Broadly speaking, within the scope of these areas, there are two kinds of tools:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，在这些领域范围内，有两种工具：
- en: Dynamic analysis tools
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态分析工具
- en: Static analysis tools
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态分析工具
- en: Dynamic analysis tools work essentially by instrumenting the runtime process.
    Thus, to gain the most out of them, a lot of attention must be devoted to ensuring
    that the tools actually run over all possible code paths; done by carefully and
    painstakingly writing test cases to ensure complete code coverage*.* This is a
    key point and will be mentioned again (Importantly, [Chapter 19](b6b41870-c02e-4379-af86-b5e501799c31.xhtml),
    *Troubleshooting and Best Practices*, covers such points). While very powerful,
    dynamic analysis tools usually result in a significant runtime performance hit
    and more memory usage.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 动态分析工具基本上通过对运行时进程进行仪器化来工作。因此，为了充分利用它们，必须要花费大量精力来确保工具实际上覆盖了所有可能的代码路径；通过仔细而费力地编写测试案例来确保完整的代码覆盖。这是一个关键点，将在后面提到（重要的是，[第19章](b6b41870-c02e-4379-af86-b5e501799c31.xhtml)，*故障排除和最佳实践*，涵盖了这些要点）。虽然非常强大，但动态分析工具通常会导致显著的运行时性能损失和更多的内存使用。
- en: Static analysis tools, on the other hand, work upon source code; in this sense,
    they are similar to the compiler. They often go well beyond the typical compiler,
    aiding the developer in uncovering all kinds of potential bugs. Perhaps the original
    Unix *lint* program could be considered the precursor to today's powerful static
    analyzers. Nowadays, very powerful commercial static analyzers (with fancy GUI
    frontends) exist, and are worth the money and time one spends on them. The downside
    is that these tools might raise a lot of false positives; the better ones let
    the programmer perform useful filtering. We won't cover static analyzers in this
    text (see the *Further reading* section on the GitHub repository, for a list of
    static analyzers for C/C++).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，静态分析工具是针对源代码进行工作的；在这个意义上，它们类似于编译器。它们通常远远超出了典型的编译器，帮助开发人员发现各种潜在的错误。也许最初的Unix
    *lint*程序可以被认为是今天强大的静态分析器的前身。如今，存在着非常强大的商业静态分析器（带有花哨的图形用户界面），并且值得花费在它们上的金钱和时间。缺点是这些工具可能会引发许多错误的警报；更好的工具可以让程序员执行有用的过滤。我们不会在本文中涵盖静态分析器（请参阅GitHub存储库上的*进一步阅读*部分，了解C/C++的静态分析器列表）。
- en: Now, let's check out some modern-day memory debug tools; they all fall into
    the dynamic analysis tools class. Do learn how to use them effectively—they're
    a necessary weapon against all kinds of **Undefined Behavior** (**UB**).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看一些现代内存调试工具；它们都属于动态分析工具类。确实要学会如何有效地使用它们——它们是对各种**未定义行为**（**UB**）的必要武器。
- en: Valgrind
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Valgrind
- en: 'Valgrind (pronounced as *val-grinned*) is an instrumentation framework for
    a suite of powerful tools. It is **open source software** (**OSS**), released
    under the terms of the GNU GPL ver. 2; it was originally developed by Julian Seward.
    Valgrind is an award-winning suite of tools for memory debugging and profiling.
    It has evolved to become a framework for creating dynamic analysis tools. In fact,
    it''s really a virtual machine; Valgrind uses a technology called **dynamic binary
    instrumentation** (DBI) to instrument code. Read more on its homepage: [http://valgrind.org/](http://valgrind.org/).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind（发音为*val-grinned*）是一套强大工具的仪器化框架。它是**开源软件**（OSS），根据GNU GPL ver. 2的条款发布；它最初由Julian
    Seward开发。Valgrind是一套用于内存调试和性能分析的获奖工具。它已经发展成为创建动态分析工具的框架。事实上，它实际上是一个虚拟机；Valgrind使用一种称为**动态二进制仪器化**（DBI）的技术来对代码进行检测。在其主页上阅读更多信息：[http://valgrind.org/](http://valgrind.org/)。
- en: 'The tremendous upside of Valgrind is its tool suite—primarily the **Memory
    Checker** tool ( **Memcheck**). There are several other checker and profiling
    tools as well, enumerated in the following table (in alphabetical order):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind的巨大优势在于其工具套件，主要是**Memory Checker**工具（**Memcheck**）。还有其他几个检查器和性能分析工具，按字母顺序列在下表中：
- en: '| **Valgrind tool name** | **Purpose** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **Valgrind工具名称** | **目的** |'
- en: '| cachegrind | CPU cache profiler. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| cachegrind | CPU缓存性能分析器。'
- en: '| callgrind | Extension to cachegrind; provides more callgraph info. KCachegrind
    is a good GUI visualizer for cachegrind/callgrind. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| callgrind | cachegrind的扩展；提供更多的调用图信息。KCachegrind是cachegrind/callgrind的良好GUI可视化工具。'
- en: '| drd | Pthreads bug detector. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| drd | Pthreads错误检测器。'
- en: '| helgrind | Data Race detector for multithreaded applications (mostly Pthreads).
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| helgrind | 多线程应用程序（主要是Pthreads）的数据竞争检测器。'
- en: '| massif | Heap profiler (heap usage graphing, max allocations tracking). |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| massif | 堆分析器（堆使用情况图表，最大分配跟踪）。'
- en: '| Memcheck | Memory bugs detector; includes **out-of-bounds** (**OOB**) accesses
    (read&#124;write under&#124;overflow), uninitialized data accesses, UAF, UAR,
    memory leakage, double free, and overlapping memory region bugs. This is the default
    tool. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| Memcheck | 内存错误检测器；包括**越界**（**OOB**）访问（读取|写入|溢出），未初始化数据访问，UAF，UAR，内存泄漏，双重释放和重叠内存区域错误。这是默认工具。'
- en: Note that some of the lesser used tools (such as lackey, nulgrind, none), and
    some of the experimental tools (exp-bbv, exp-dhat, exp-sgcheck) have not been
    shown in the table.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一些较少使用的工具（如lackey、nulgrind、none）和一些实验性工具（exp-bbv、exp-dhat、exp-sgcheck）没有在表中显示。
- en: Select a tool for Valgrind to run via the `--tool=` option (giving any of the
    preceding as the parameter). In this book, we focus on Valgrind's Memcheck tool
    only.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`--tool=`选项选择Valgrind要运行的工具（将前述任何一个作为参数）。在本书中，我们只关注Valgrind的Memcheck工具。
- en: Using Valgrind's Memcheck tool
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Valgrind的Memcheck工具
- en: Memcheck is Valgrind's default tool; you do not need to pass it explicitly,
    but can do so with the `valgrind --tool=memcheck <program-to-execute with params>`
    syntax.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Memcheck是Valgrind的默认工具；你不需要显式传递它，但可以使用`valgrind --tool=memcheck <要执行的程序及参数>`语法来执行。
- en: 'As a trivial example, let''s run Valgrind on the `df(1)` utility (on an Ubuntu
    box):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个简单的例子，让我们在Ubuntu上运行Valgrind对`df(1)`实用程序进行检测：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Valgrind literally takes over and runs the `df` process within it, instrumenting
    all dynamic memory accesses. It then prints its report. In the preceding code,
    the lines are prefixed with `==1577==`; that's just the PID of the `df` process.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind实际上接管并在其中运行`df`进程，对所有动态内存访问进行检测。然后打印出其报告。在前面的代码中，这些行都以`==1577==`为前缀；那只是`df`进程的PID而已。
- en: 'As no runtime memory bugs were found, no output appears (you will see the difference
    soon when we run our `membugs` program under Valgrind''s control). In terms of
    memory leakage, the report states:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 没有发现运行时内存错误，因此没有输出（当我们在Valgrind的控制下运行我们的`membugs`程序时，很快你就会看到差异）。就内存泄漏而言，报告指出：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All these are zero values, so it's fine. If the values under `definitely lost`
    were positive, then this would indeed indicate a memory leakage bug that must
    be further investigated and fixed. The other labels—`indirectly`/`possibly lost`,
    `still reachable`—are often due to complex or indirect memory handling within
    the code base (in effect, they are usually false positives one can ignore).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是零值，所以没问题。如果`definitely lost`下的值为正数，那么这确实会表明存在必须进一步调查和修复的内存泄漏错误。其他标签——`indirectly`/`possibly
    lost`，`still reachable`——通常是由于代码库中复杂或间接的内存处理而产生的（实际上，它们通常是可以忽略的假阳性）。
- en: 'The `still reachable` usually signifies that, at process exit, some memory
    blocks were not explicitly freed by the application (but got implicitly freed
    when the process died). The following statements show this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`still reachable`通常表示在进程退出时，一些内存块未被应用程序显式释放（但在进程死亡时被隐式释放）。以下语句显示了这一点：'
- en: '**In use at exit**: 3,577 bytes in 213 blocks'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退出时使用**：213个块中的3,577字节'
- en: '**Total heap usage**: 447 allocs, 234 frees, 25,483 bytes'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总堆使用情况**：447次分配，234次释放，25,483字节'
- en: Out of a total of 447 allocs, only 234 frees were done, leaving 447 - 234 =
    213 blocks left unfreed.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在总共的447次分配中，只有234次释放，剩下了447 - 234 = 213个未释放的块。
- en: 'Okay, now for the interesting bit: let''s run our `membugs` program test cases
    (from the preceding [Chapter 5](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml), *Linux
    Memory Issues*) under Valgrind and see if it catches the memory bugs that the
    test cases work hard to provide.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在来看有趣的部分：让我们运行我们的`membugs`程序测试用例（来自前面的[第5章](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml)，*Linux内存问题*）在Valgrind下运行，并看看它是否能捕捉到测试用例努力提供的内存错误。
- en: We definitely suggest you look over the previous chapter, and the `membugs.c`
    source code, to regain familiarity with the test cases we will be running.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您回顾前一章和`membugs.c`源代码，以便重新熟悉我们将要运行的测试用例。
- en: The membugs program has a total of 13 test cases; we shall not attempt to display
    the output of all of them within the book; we leave it as an exercise to the reader
    to try running the program with all test cases under Valgrind and deciphering
    its output report.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: membugs程序共有13个测试用例；我们不打算在书中展示所有测试用例的输出；我们把这留给读者作为一个练习，尝试在Valgrind下运行程序并解密其输出报告。
- en: It would be of interest to most readers to see the summary table at the end
    of this section, showing the result of running Valgrind on each of the test cases.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数读者可能会对本节末尾的摘要表感兴趣，该表显示了在每个测试用例上运行Valgrind的结果。
- en: '**Test case #1: Uninitialized memory access**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例＃1：未初始化内存访问**'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For readability, we remove parts of the output shown as follows and truncate
    the program pathname.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，我们删除了以下显示的部分并截断了程序路径名。
- en: 'Now under Valgrind''s control:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在处于Valgrind的控制之下：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Clearly, Valgrind has caught the uninitialized memory access bug! The text highlighted
    in bold clearly reveals the case.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Valgrind捕捉到了未初始化的内存访问错误！粗体突出显示的文本清楚地揭示了这种情况。
- en: 'However, notice that though Valgrind can show us the call stack—including the
    process pathname—it seems to be unable to show us the line number in the source
    code where the offending bug is present. Hang on, though. We can achieve precisely
    this by running Valgrind with the debug-enabled version of the program:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，尽管Valgrind可以向我们显示调用堆栈（包括进程路径名），但似乎无法向我们显示源代码中存在错误的行号。不过，我们可以通过使用程序的启用调试版本来精确地实现这一点：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Common GCC flags used for debugging
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 用于调试的常见GCC标志
- en: 'See the `gcc(1)` man page for details. Briefly:`-g`: Produce sufficient debugging
    information such that a tool such as the **GNU Debugger** (**GDB**) has to debug
    symbolic information to work with (modern Linux would typically use the DWARF
    format).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有关详细信息，请参阅`gcc(1)`的man页面。简而言之：`-g`：生成足够的调试信息，使得诸如**GNU调试器**（GDB）之类的工具必须使用符号信息来进行调试（现代Linux通常会使用DWARF格式）。
- en: '`-ggdb`: Use the most expressive format possible for the OS.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`-ggdb`：使用操作系统可能的最表达格式。'
- en: '`-gdwarf-4`: Debug info is in the DWARF-<version> format (ver. 4 is appropriate).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`-gdwarf-4`：调试信息以DWARF-<version>格式（版本4适用）。'
- en: '`-O0` : Optimization level `0`; good for debugging.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`-O0`：优化级别`0`；用于调试。'
- en: 'In the following code, we retry running Valgrind with the debug-enabled version
    of our binary executable, `membugs_dbg`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们重试了使用启用调试版本的二进制可执行文件`membugs_dbg`运行Valgrind：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As usual, read the call stack in a bottom-up fashion and it will make sense!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，以自下而上的方式阅读调用堆栈，它就会有意义！
- en: 'Important: Please note that, unfortunately, it''s quite possible that the precise
    line numbers shown in the output as follows may not precisely match the line number
    in the latest version of the source file in the book''s GitHub repository.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：请注意，不幸的是，输出中显示的精确行号可能与书中GitHub存储库中最新版本的源文件中的行号不完全匹配。
- en: 'Here is the the source code (the `nl` utility is used here to show the code
    with all lines numbered):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是源代码（此处使用`nl`实用程序显示所有行编号的代码）：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can now see that Valgrind has indeed perfectly captured the buggy case.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到Valgrind确实完美地捕捉到了错误的情况。
- en: '**Test case #5:** read overflow on compile-time memory:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例＃5：** 编译时内存读取溢出：'
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Would you look at that!? Valgrind fails to catch the read overflow memory bug.
    Why? It''s a limitation: Valgrind can only instrument, and therefore catch, UB
    (bugs) on dynamically allocated memory. The preceding test case used static compile-time
    allocated memory.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 看看！Valgrind未能捕捉到读取溢出内存错误。为什么？这是一个限制：Valgrind只能对动态分配的内存进行插装和捕捉UB（错误）。前面的测试用例使用了静态编译时分配的内存。
- en: 'So, let''s try the same test, but this time using dynamically allocated memory;
    that''s precisely what test case #6 is designed to do.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们尝试相同的测试，但这次使用动态分配的内存；这正是测试用例＃6的设计目的。
- en: '**Test case #6:** read overflow on dynamic memory (for readability, we truncated
    some of the output):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例＃6：** 动态内存上的读取溢出（为了便于阅读，我们截断了部分输出）：'
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Well, this time, plenty of errors were caught with precise call stack locations
    revealing the exact point in the source (as we have compiled with `-g`).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，大量的错误被捕捉到，显示了源代码中的确切位置（因为我们使用了`-g`进行编译）。
- en: '**Test case #8:** **UAF** (**use-after-free**):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例＃8：** **UAF**（释放后使用）：'
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](img/8edb68da-2b47-4a7d-884a-5184c6a8bbe9.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8edb68da-2b47-4a7d-884a-5184c6a8bbe9.png)'
- en: A (partial) screenshot of the action when Valgrind catches the UAF bugs
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当Valgrind捕捉到UAF错误时的（部分）屏幕截图
- en: Valgrind does catch the UAF!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind确实捕捉到了UAF！
- en: '**Test case #8:** **UAR** (**use-after-return**):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例＃8：** **UAR**（返回后使用）：'
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Whoops! Valgrind does not catch the UAR bug!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！Valgrind没有捕捉到UAR错误！
- en: '**Test Case #13:** Memory leak case #3—lib API leak. We run the memory leak
    test case #3 by selecting 13 as the parameter to *membugs*. It''s useful to note
    that only when run with the `--leak-check=full` option does Valgrind display the
    origin of the leak (via the displayed call stack):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例＃13：** 内存泄漏案例＃3—lib API泄漏。我们通过选择13作为*membugs*的参数来运行内存泄漏测试用例＃3。值得注意的是，只有在使用`--leak-check=full`选项运行时，Valgrind才会显示泄漏的来源（通过显示的调用堆栈）：'
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Valgrind man page recommends setting `--leak-resolution=high` and `--num-callers=` 
    to 40 or higher.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind的man页面建议设置`--leak-resolution=high`和`--num-callers=`为40或更高。
- en: The man page on `valgrind(1)` covers the many options it provides (such as logging
    and tool (Memcheck) options); take a look to gain a deeper understanding of this
    tool's usage.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`valgrind(1)`的man页面涵盖了它提供的许多选项（如日志和工具（Memcheck）选项）；请查看以更深入地了解此工具的用法。'
- en: Valgrind summary table
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Valgrind摘要表
- en: 'With respect to our test cases (incorporated into our `membugs` program), here
    is Valgrind''s report card and memory bugs given as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的测试用例（并入我们的`membugs`程序），以下是Valgrind的报告卡和内存错误如下：
- en: '| **Test case #** | **Test case** | **Detected by Valgrind?** |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **测试用例＃** | **测试用例** | **Valgrind检测到了吗？** |'
- en: '| 1 | **Uninitialized memory read** (**UMR**) | Yes |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **未初始化内存读取**（UMR） | 是 |'
- en: '| 2 | **Out-of-bounds **(**OOB**): write overflow [on compile-time memory]
    | No |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **越界**（**OOB**）：写入溢出[在编译时内存上] | 否 |'
- en: '| 3 | OOB: write overflow [on dynamic memory] | Yes |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 3 | OOB：写入溢出[在动态内存上] | 是 |'
- en: '| 4 | OOB: write underflow [on dynamic memory] | Yes |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 4 | OOB：写入下溢[在动态内存上] | 是 |'
- en: '| 5 | OOB: read overflow [on compile-time memory] | No |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 5 | OOB：读取溢出[在编译时内存上] | 否 |'
- en: '| 6 | OOB: read overflow [on dynamic memory] | Yes |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 6 | OOB：读取溢出[在动态内存上] | 是 |'
- en: '| 7 | OOB: read underflow [on dynamic memory] | Yes |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 7 | OOB：读取下溢[在动态内存上] | 是 |'
- en: '| 8 | UAF, also known as dangling pointer | Yes |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 8 | UAF，也称为悬空指针 | 是 |'
- en: '| 9 | UAR, also known as **use-after-scope **(**UAS**) | No |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 9 | UAR，也称为**use-after-scope**(**UAS**) | 否 |'
- en: '| 10 | Double free | Yes |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 重复释放 | 是 |'
- en: '| 11 | Memory leak test case 1: simple leak | Yes |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 内存泄漏测试案例1：简单泄漏 | 是 |'
- en: '| 12 | Memory leak test case 1: leak more (in a loop) | Yes |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 内存泄漏测试案例1：泄漏更多（循环中） | 是 |'
- en: '| 13 | Memory leak test case 1: lib API leak | Yes |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 内存泄漏测试案例1：库API泄漏 | 是 |'
- en: 'Valgrind pros and cons : a quick summary'
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Valgrind优点和缺点：快速总结
- en: Valgrind pros*:*
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind优点*：*
- en: Catches common memory bugs (UB) on dynamically allocated memory regions
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获动态分配内存区域上的常见内存错误（UB）
- en: Using uninitialized variables
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未初始化的变量
- en: Out-of-bounds memory accesses (read/write underflow/overflow bugs)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 越界内存访问（读取/写入下溢/溢出错误）
- en: Use-after-free / use-after-return (out-of-scope) bugs
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放后使用/返回后使用（超出范围）错误
- en: Double free
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复释放
- en: Leakage
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泄漏
- en: No modification to source code required
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需修改源代码
- en: No recompile required
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需重新编译
- en: No special compiler flags required
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需特殊的编译器标志
- en: 'Valgrind cons:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind缺点：
- en: 'Performance: target software may run up to 10 to 30 times slower when run under
    Valgrind.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能：在Valgrind下运行目标软件可能会慢10到30倍。
- en: 'Memory footprint: each allocation within the target program requires Valgrind
    to make a memory allocation as well (making running Valgrind on highly-resource-constrained
    embedded Linux systems difficult).'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存占用：目标程序中的每个分配都需要Valgrind进行内存分配（在高资源约束的嵌入式Linux系统上运行Valgrind变得困难）。
- en: Cannot catch bugs on statically (compile-time) allocated memory regions.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法捕获静态（编译时）分配的内存区域上的错误。
- en: In order to see the call stack with line-number information, a recompile/build
    with the `-g` flag is required.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了查看带有行号信息的调用堆栈，需要使用`-g`标志重新编译/构建。
- en: The fact is, Valgrind remains a powerful weapon in one's armory against bugs.
    There are many real-world projects that use Valgrind; check out the long list
    at [http://valgrind.org/gallery/users.html](http://valgrind.org/gallery/users.html)*.*
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Valgrind仍然是对抗错误的有力武器。有许多真实世界的项目使用Valgrind；在[http://valgrind.org/gallery/users.html](http://valgrind.org/gallery/users.html)上查看长列表*.*
- en: 'There is always more to learn and explore: Valgrind provides a  GDB monitor
    mode allowing you to do advanced debugging on your program via the **GNU debugger**
    (**GDB**). This is particularly useful for using Valgrind on programs that never
    terminate (daemons being the classic case).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有更多可以学习和探索的：Valgrind提供了GDB监视器模式，允许您通过**GNU调试器**（**GDB**）对程序进行高级调试。这对于在从不终止的程序上使用Valgrind特别有用（守护进程是典型案例）。
- en: The third chapter of Valgrind's manual is very helpful in this regard: [http://valgrind.org/docs/manual/manual-core-adv.html](http://valgrind.org/docs/manual/manual-core-adv.html)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind手册的第三章在这方面非常有帮助：[http://valgrind.org/docs/manual/manual-core-adv.html](http://valgrind.org/docs/manual/manual-core-adv.html)
- en: Sanitizer tools
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sanitizer工具
- en: 'Sanitizers are a suite of open source tools from Google; like other memory
    debug tools, they tackle the usual common memory bugs and UB issues, including
    OOB (out-of-bounds accesses: read/write under/over-flow), UAF, UAR, double free,
    and memory leakage. One of the tools also handles data races in C/C++ code.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Sanitizer是来自Google的一套开源工具；与其他内存调试工具一样，它们解决了通常的常见内存错误和UB问题，包括OOB（越界访问：读取/写入下溢/溢出）、UAF、UAR、重复释放和内存泄漏。其中一个工具还处理C/C++代码中的数据竞争。
- en: A key difference is that the sanitizer tools introduce instrumentation into
    the code via the compiler. They use a technology called **Compile-time instrumentation**
    (CTI) as well as shadow memory techniques. As of this writing, ASan is a part
    of and supports GCC ver 4.8 and LLVM (Clang) ver. 3.1 and above.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键区别是，Sanitizer工具通过编译器向代码引入了插装。它们使用一种称为**编译时插装**（CTI）的技术以及影子内存技术。截至目前，ASan是GCC
    ver 4.8和LLVM（Clang）ver. 3.1及以上的一部分并支持它。
- en: Sanitizer toolset
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sanitizer工具集
- en: 'To use a given tool, compile the program with the flag(s) shown in the Usage column:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用给定的工具，需要使用Usage列中显示的标志编译程序：
- en: '| **Sanitizer tool (short name)** | **Purpose** | **Usage (compiler flags)**
    | **Linux platforms [+comments]** |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| **Sanitizer工具（简称）** | **目的** | **使用（编译器标志）** | **Linux平台[+注释]** |'
- en: '| **AddressSanitizer** (**ASan**) | Detecting generic memory errors [heap&#124;stack&#124;global
    buffer over&#124;under-flow, UAF, UAR, init order bugs] | `-fsanitize=address`
    | x86, x86_64, ARM, Aarch64, MIPS, MIPS64, PPC64\. [Cannot combine with TSan]
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| **AddressSanitizer** (**ASan**) | 检测通用内存错误[堆栈全局缓冲区溢出、UAF、UAR、初始化顺序错误] | `-fsanitize=address`
    | x86、x86_64、ARM、Aarch64、MIPS、MIPS64、PPC64\. [不能与TSan组合] |'
- en: '| **Kernel AddressSanitizer** (**KASAN**) | ASan for Linux kernel-space | `-fsanitize=kernel-address`
    | x86_64 [kernel ver >=4.0], Aarch64 [kernel ver >= 4.4] |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **Kernel AddressSanitizer** (**KASAN**) | 用于Linux内核空间的ASan | `-fsanitize=kernel-address`
    | x86_64 [内核版本>=4.0]，Aarch64 [内核版本>= 4.4] |'
- en: '| **MemorySanitizer** (**MSan**) | UMR detector | `-fsanitize=memory -fPIE
    -pie [-fno-omit-frame-pointer]`  | Linux x86_64 only |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **MemorySanitizer** (**MSan**) | UMR检测器 | `-fsanitize=memory -fPIE -pie [-fno-omit-frame-pointer]`  |
    仅适用于Linux x86_64 |'
- en: '| **ThreadSanitizer** (**TSan**) | Data Races detector | `-fsanitize=thread`
    | Linux x86_64 only. [Cannot combine with ASan or LSan flags] |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **ThreadSanitizer** (**TSan**) | 数据竞争检测器 | `-fsanitize=thread` | 仅适用于Linux
    x86_64。[不能与ASan或LSan标志组合] |'
- en: '| **LeakSanitizer** (**LSan**) (a subset of ASan) | Memory leakage detector
    | `-fsanitize=leak` | Linux x86_64 and OS X [cannot combine with TSan] |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| **LeakSanitizer** (**LSan**)（ASan的子集） | 内存泄漏检测器 | `-fsanitize=leak` | Linux
    x86_64和OS X [不能与TSan组合] |'
- en: '| **UndefinedBehaviorSanitizer** (**UBSan**) | UB detector | `-fsanitize=undefined`
    | x86, x86_64, ARM, Aarch64, PPC64, MIPS, MIPS64 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **UndefinedBehaviorSanitizer** (**UBSan**) | UB检测器 | `-fsanitize=undefined`
    | x86, x86_64, ARM, Aarch64, PPC64, MIPS, MIPS64 |'
- en: 'Additional DocumentationGoogle maintains a GitHub page with documentation for
    the sanitizer tools:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的文档Google维护着一个GitHub页面，其中包含有关sanitizer工具的文档：
- en: '[https://github.com/google/sanitizers](https://github.com/google/sanitizers)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/google/sanitizers](https://github.com/google/sanitizers)'
- en: '[https://github.com/google/sanitizers/wiki](https://github.com/google/sanitizers/wiki)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/google/sanitizers/wiki](https://github.com/google/sanitizers/wiki)'
- en: '[https://github.com/google/sanitizers/wiki/SanitizerCommonFlags](https://github.com/google/sanitizers/wiki/SanitizerCommonFlags)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/google/sanitizers/wiki/SanitizerCommonFlags](https://github.com/google/sanitizers/wiki/SanitizerCommonFlags)'
- en: There are links leading to each of the tool's individual wiki (documentation)
    pages. It's recommended you read them in detail when using a tool (for example,
    each tool might have specific flags and/or environment variables that the user
    can make use of).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工具的个别wiki（文档）页面都有链接。建议您在使用工具时仔细阅读它们（例如，每个工具可能具有用户可以利用的特定标志和/或环境变量）。
- en: The man page on `gcc(1)` is a rich source of information on the intricacies
    of the `-fsanitize=` sanitizer tool gcc options. Interestingly, most of the sanitizer
    tools are supported on the Android (>=4.1) platform as well.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcc(1)`的man页面是关于`-fsanitize=`sanitizer工具gcc选项的复杂信息的丰富来源。有趣的是，大多数sanitizer工具也支持Android（>=4.1）平台。'
- en: 'The Clang documentation also documents the use of the sanitizer tools: [https://clang.llvm.org/docs/index.html](https://clang.llvm.org/docs/index.html).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Clang文档还记录了使用sanitizer工具的方法：[https://clang.llvm.org/docs/index.html](https://clang.llvm.org/docs/index.html)。
- en: In this chapter, we focus on using the ASan tool.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于使用ASan工具。
- en: Building programs for use with ASan
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为ASan构建程序
- en: As the preceding table shows, we need to compile our target application membugs with
    the appropriate compiler flag(s). Also, instead of using `gcc` as the compiler,
    it's recommended we use `clang`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前表所示，我们需要使用适当的编译器标志来编译我们的目标应用程序membugs。此外，建议使用`clang`而不是`gcc`作为编译器。
- en: '`clang` is considered a compiler frontend for several programming languages,
    including C and C++; the backend is the LLVM compiler infrastructure project.
    More information on Clang is available on its Wikipedia page.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`clang`被认为是几种编程语言的编译器前端，包括C和C++；后端是LLVM编译器基础设施项目。关于Clang的更多信息可以在其维基百科页面上找到。'
- en: You will need to ensure that the Clang package is installed on your Linux box;
    using your distribution's package manager (`apt-get`, `dnf`, `rpm`) would be the
    easiest way.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保在您的Linux系统上安装了Clang软件包；使用您的发行版的软件包管理器（`apt-get`，`dnf`，`rpm`）是最简单的方法。
- en: 'This snippet from our Makefile shows how we use `clang` to compile the membugs
    sanitizer targets:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Makefile片段显示了我们如何使用`clang`来编译membugs sanitizer目标：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Running the test cases with ASan
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ASan运行测试用例
- en: 'To refresh our memory, here is the help screen from our membugs program:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提醒我们，这是我们的membugs程序的帮助屏幕：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The membugs program has a total of 13 test cases; we shall not attempt to display
    the output of all of them in this book; we leave it as an exercise to the reader
    to try out building and running the program with all test cases under ASan and
    deciphering its output report. It would be of interest to readers to see the summary
    table at the end of this section, showing the result of running ASan on each of
    the test cases.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: membugs程序共有13个测试用例；我们不打算在本书中显示所有这些测试用例的输出；我们把它留给读者来尝试使用ASan构建和运行所有测试用例的程序，并解密其输出报告。读者有兴趣看到本节末尾的摘要表，显示在每个测试用例上运行ASan的结果。
- en: '**Test case #1:** UMR'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例＃1：** UMR'
- en: 'Let''s try the very first one—the uninitialized variable read test case:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试第一个——未初始化变量读取测试用例：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It did not catch the bug! Yes, we have hit upon ASan''s limitation: AddressSanitizer
    cannot catch UMR on statically (compile-time) allocated memory. Valgrind did.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有捕获到错误！是的，我们已经发现了ASan的限制：AddressSanitizer无法捕获静态（编译时）分配的内存上的UMR。Valgrind可以。
- en: 'Well, that''s taken care of by the MSan tool; its specific job is to catch
    UMR bugs. The documentation states that MSan can only catch UMR on dynamically
    allocated memory. We found that it even caught a UMR bug on statically allocated
    memory, which our simple test case uses:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: MSan工具已经处理了这个问题；它的具体工作是捕获UMR错误。文档说明MSan只能捕获动态分配的内存上的UMR。我们发现它甚至捕获了一个在静态分配的内存上的UMR错误，而我们的简单测试用例使用了：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It has caught the bug; however, this time, though we have used a debug binary
    executable, built with the `-g -ggdb` flags, the usual `filename:line_number`
    information is missing in the stack trace. Actually, a method to obtain this is
    demonstrated in the next test case.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它已经捕获了错误；然而，这一次，尽管我们使用了带有`-g -ggdb`标志构建的调试二进制可执行文件，但在堆栈跟踪中缺少通常的`filename:line_number`信息。实际上，下一个测试用例中演示了一种获得这种信息的方法。
- en: 'For now, no matter: this gives us a chance to learn another useful debug technique:
    `objdump(1)` is one of the toolchain utilities that can greatly help here (we
    can achieve similar results with tools such as `readelf(1)` or `gdb(1)`). We''ll
    disassemble the binary executable with `objdump(1)` (`-d` switch, and, with source
    via the `-S` switch), and look within its output for the address where the UMR
    occurs:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不管怎样：这给了我们一个学习另一种有用的调试技术的机会：`objdump(1)`是可以极大帮助的工具链实用程序之一（我们可以使用诸如`readelf(1)`或`gdb(1)`之类的工具获得类似的结果）。我们将使用`objdump(1)`（`-d`开关，并通过`-S`开关提供源代码），并在其输出中查找UMR发生的地址：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As the output of `objdump` is quite large, we truncate it showing only the
    relevant portion:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`objdump`的输出非常庞大，我们截断它，只显示相关部分：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The closest match in the `objdump` output to the address provided by MSan as
    the `0x496eb8` error point is `0x496eb4`. That''s fine: just look at the preceding
    for the first source line of code; it''s the following line:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`objdump`输出中与MSan提供的`0x496eb8`错误点最接近的是`0x496eb4`。没问题：只需查看代码的第一行之前的内容；它是以下一行：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Perfect. That's exactly where the UMR occurred!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。这正是UMR发生的地方！
- en: '**Test Case #2: **write overflow [on compile-time memory]'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试案例＃2：**写溢出[在编译时内存上]'
- en: We run the `membugs` program, both under Valgrind and ASan, only invoking the `write_overflow_compilemem()`
    function to test the out-of-bounds write overflow memory errors on a compile-time
    allocated piece of memory.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行`membugs`程序，同时在Valgrind和ASan下运行，只调用`write_overflow_compilemem()`函数来测试编译时分配的内存的越界写溢出错误。
- en: '**Case 1:** Using Valgrind'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**案例1：**使用Valgrind'
- en: 'Notice how Valgrind does not catch the out-of-bounds memory bug:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Valgrind没有捕获越界内存错误：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is because Valgrind is limited to working with only dynamically allocated
    memory; it cannot instrument and work with compile time allocated memory.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Valgrind仅限于处理动态分配的内存；它无法插装和处理编译时分配的内存。
- en: '**Case 2**: Address Sanitizer'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**案例2：**地址消毒剂'
- en: 'ASan does catch the bug:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ASan确实捕获了bug：
- en: '![](img/073b0391-40f5-447a-b292-fab3db12592d.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/073b0391-40f5-447a-b292-fab3db12592d.png)'
- en: AddressSanitizer (ASan) catches the OOB write-overflow bug
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: AddressSanitizer（ASan）捕获了OOB写溢出bug
- en: 'A similar textual version is shown as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个类似的文本版本：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice, however, that within the stack backtrace, there is no `filename:line#
    information`. That's disappointing. Can we obtain it?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，在堆栈回溯中，没有`filename:line#信息`。这令人失望。我们能获取它吗？
- en: 'Yes indeed—the trick lies in ensuring a few things:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 确实—诀窍在于确保几件事情：
- en: Compile the application with the `-g` switch (to include debug symbolic info;
    we do this for all the *_dbg versions).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-g`开关编译应用程序（包括调试符号信息；我们对所有*_dbg版本都这样做）。
- en: Besides the Clang compiler, a tool called `llvm-symbolizer` must be installed
    as well. Once installed, you must figure out its exact location on the disk and
    add that directory to the path.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了Clang编译器，还必须安装一个名为`llvm-symbolizer`的工具。安装后，您必须找出它在磁盘上的确切位置，并将该目录添加到路径中。
- en: At runtime, the `ASAN_OPTIONS` environment variable must be set to the `symbolize=1` value.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时，必须将`ASAN_OPTIONS`环境变量设置为`symbolize=1`值。
- en: 'Here, we rerun the buggy case with `llvm-symbolizer` in play:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`llvm-symbolizer`重新运行有bug的案例：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now the `filename:line# information` shows up!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`filename:line#信息`显示出来了！
- en: Clearly, ASan can and does instrument compile-time allocated as well as dynamically
    allocated memory regions, and thus catches both memory-type bugs.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，ASan可以并且确实插装编译时分配的内存以及动态分配的内存区域，从而捕获内存类型的错误。
- en: 'Also, as we saw, it displays a call stack (read it from bottom to top of course).
    We can see the call chain is:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，正如我们所看到的，它显示了一个调用堆栈（当然是从底部到顶部）。我们可以看到调用链是：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The AddressSanitizer also displays, "Shadow bytes around the buggy address:";
    here, we do not attempt to explain the memory-shadowing technique used to catch
    such bugs; if interested, please see the *Further reading* section on the GitHub
    repository.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: AddressSanitizer还显示了“在有bug的地址周围的影子字节”；在这里，我们不试图解释用于捕获此类错误的内存阴影技术；如果感兴趣，请参阅GitHub存储库上的*进一步阅读*部分。
- en: '**Test case #3:** write overflow (on dynamic memory)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试案例＃3：**写溢出（在动态内存上）'
- en: 'As expected, ASan catches the bug:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，ASan捕获了bug：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With `llvm-symbolizer` in the path, the `filename:line# information` again shows
    up.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`llvm-symbolizer`在路径中，`filename:line#信息`再次显示出来。
- en: 'Attempting to compile for sanitizer instrumentation (via the `-fsanitize=`
    GCC switches) and trying to run the binary executable over Valgrind is not supported;
    when we try this, Valgrind reports the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试为消毒剂插装编译（通过`-fsanitize=`GCC开关）并尝试在Valgrind上运行二进制可执行文件是不受支持的；当我们尝试这样做时，Valgrind报告如下：
- en: '[PRE24]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**Test Case #8: **UAF (use-after-free). Take a look at the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试案例＃8：**UAF（释放后使用）。看看以下代码：'
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Super. ASan not only reports the UAF bug, it even reports exactly where the
    buffer was allocated and freed! Powerful stuff.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。ASan不仅报告了UAF bug，甚至还报告了缓冲区的确切分配和释放位置！强大的东西。
- en: '**Test case #9:** UAR'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试案例＃9：**UAR'
- en: 'For the purpose of this example, let''s say we compile the `membugs` program
    in the usual manner, using `gcc`. Run the test case:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例，假设我们以通常的方式使用`gcc`编译`membugs`程序。运行测试案例：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ASan, as such, does not catch this dangerous UAR bug! As we saw earlier, neither
    does Valgrind. But, the compiler does emit a warning!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ASan本身并没有捕获这个危险的UAR bug！正如我们之前看到的，Valgrind也没有。但是，编译器确实发出了警告！
- en: 'Hang on, though: the Sanitizers documentation mentions that ASan can indeed
    catch this UAR bug, if:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，消毒剂文档提到，如果：
- en: '`clang` (ver r191186 onward) is used to compile the code (not gcc)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clang`（版本从r191186开始）用于编译代码（而不是gcc）'
- en: A special flag, `detect_stack_use_after_return` is set to `1`
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置了一个特殊标志`detect_stack_use_after_return`为`1`
- en: 'So, we recompile the executable via Clang (again, we assume the Clang package
    is installed). In reality, our Makefile does make use of `clang` for all the `membugs_dbg_*`
    builds. So, ensure we rebuild with Clang as the compiler and retry:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通过Clang重新编译可执行文件（再次，我们假设已安装Clang软件包）。实际上，我们的Makefile确实对所有`membugs_dbg_*`构建使用了`clang`。因此，请确保我们使用Clang重新构建编译器并重试：
- en: '[PRE27]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It does work. As we showed in *Test case #1: UMR*, one can further make use
    of `objdump(1)` to tease out the exact place where the bug hits. We leave this
    as an exercise for the reader.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实有效。正如我们在*测试案例＃1：UMR*中所展示的，可以进一步利用`objdump(1)`来找出bug发生的确切位置。我们把这留给读者作为一个练习。
- en: More information on how ASan detects stack UAR can be found at [https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn](https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有关ASan如何检测堆栈UAR的更多信息，请访问[https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn](https://github.com/google/sanitizers/wiki/AddressSanitizerUseAfterReturn)。
- en: '**Test case #10:** double free'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试案例＃10：**双重释放'
- en: 'The test case for this bug is kind of interesting (refer to the `membugs.c` source);
    we perform `malloc`, `free` the pointer, then perform another `malloc` with such
    a large value (`-1UL`, which becomes unsigned and thus too big) that it''s guaranteed
    to fail. In the error-handling code, we (deliberately) free the pointer we already
    freed earlier, thus generating the double free test case. In simpler pseudocode:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误的测试用例有点有趣（参考`membugs.c`源代码）；我们执行`malloc`，释放指针，然后用一个如此大的值（`-1UL`，它变成了无符号，因此太大）执行另一个`malloc`，这是保证会失败的。在错误处理代码中，我们（故意）释放了之前已经释放过的指针，从而生成了双重释放的测试用例。在更简单的伪代码中：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Importantly, this kind of coding reveals another really crucial lesson: developers
    often do not pay sufficient attention to error-handling code paths; they may or
    may not write negative test cases to test them thoroughly. This could result in
    serious bugs!'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，这种编码揭示了另一个非常关键的教训：开发人员通常不够重视错误处理代码路径；他们可能或可能不编写负面测试用例来彻底测试它们。这可能导致严重的错误！
- en: 'Running this via ASan instrumentation does not, at first, have the desired
    effect: you will see that because of the glaringly enormous `malloc` failure,
    ASan actually aborts process-execution; hence, it does not detect the real bug
    we''re after—the double free:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过ASan的插装运行，一开始并没有产生预期的效果：你会看到由于明显巨大的`malloc`失败，ASan实际上中止了进程执行；因此，它没有检测到我们真正想要的双重释放的真正错误：
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Yes, but, notice the preceding line of output that says:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，但是，请注意前一行输出，它说：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'How do we tell ASan this? An environment variable, `ASAN_OPTIONS`, makes it
    possible to pass runtime options; looking them up (recall we have provided the
    documentation links to the sanitizer toolset), we use it like so (one can pass
    more than one option simultaneously, separating options with a `:`; for fun, we
    also turn on the verbosity option, but trim the output):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何告诉ASan呢？一个环境变量`ASAN_OPTIONS`使得可以传递运行时选项；查找它们（回想一下我们已经提供了卫生器工具集的文档链接），我们像这样使用它（可以同时传递多个选项，用`:`分隔选项；为了好玩，我们还打开了冗长选项，但修剪了输出）：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This time, ASan continues even though it hits an allocation failure, and thus
    finds the real bug—the double free.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，即使遇到分配失败，ASan也会继续运行，因此找到了真正的错误-双重释放。
- en: '**Test case #11:** memory leak test case 1—simple leak. Refer to the following
    code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例＃11：**内存泄漏测试用例1-简单泄漏。参考以下代码：'
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It does find the leak, and pinpoints it. Also notice that LeakSanitizer (LSan)
    is effectively a subset of ASan.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实找到了泄漏，并指出了它。还要注意，LeakSanitizer（LSan）实际上是ASan的一个子集。
- en: '**Test case #13****:** memory leak test case 3—libAPI leak'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例＃13****：**内存泄漏测试用例3- libAPI泄漏'
- en: 'Here is a screenshot showcasing the action when ASan (under the hood, LSan)
    catches the leak:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个截图，展示了ASan（在幕后，LSan）捕获泄漏时的操作：
- en: '![](img/80eaeb0d-0528-4af7-90d0-e96605c81481.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80eaeb0d-0528-4af7-90d0-e96605c81481.png)'
- en: Well caught!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 很好地抓住了！
- en: AddressSanitizer (ASan) summary table
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AddressSanitizer（ASan）摘要表
- en: 'With respect to our test cases (incorporated into our `membugs` program), here
    is ASan''s report card:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们的测试用例（并入我们的`membugs`程序），这是ASan的报告卡：
- en: '| **Test case #** | **Test case** | **Detected by Address Sanitizer?** |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| **测试用例＃** | **测试用例** | **由Address Sanitizer检测到？** |'
- en: '| 1 | UMR  | No[1] |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 1 | UMR | 否[1] |'
- en: '| 2 | OOB (out-of-bounds): write overflow [on compile-time memory] | Yes |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 2 | OOB（越界）：写入溢出[在编译时内存] | 是 |'
- en: '| 3 | OOB (out-of-bounds): write overflow [on dynamic memory] | Yes |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 3 | OOB（越界）：写入溢出[在动态内存上] | 是 |'
- en: '| 4 | OOB (out-of-bounds): write underflow [on dynamic memory] | Yes |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 4 | OOB（越界）：写入下溢[在动态内存上] | 是 |'
- en: '| 5 | OOB (out-of-bounds): read overflow [on compile-time memory] | Yes |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 5 | OOB（越界）：读取溢出[在编译时内存] | 是 |'
- en: '| 6 | OOB (out-of-bounds): read overflow [on dynamic memory] | Yes |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 6 | OOB（越界）：读取溢出[在动态内存上] | 是 |'
- en: '| 7 | OOB (out-of-bounds): read underflow [on dynamic memory] | Yes |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 7 | OOB（越界）：读取下溢[在动态内存上] | 是 |'
- en: '| 8 | UAF (use-after-free) also known as dangling pointer | Yes |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 8 | UAF（释放后使用）也称为悬空指针 | 是 |'
- en: '| 9 | UAR also known as UAS (use-after-scope) | Yes[2] |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 9 | UAR也称为UAS（返回后使用） | 是[2] |'
- en: '| 10 | Double free | Yes |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 双重释放 | 是 |'
- en: '| 11 | Memory leak test case 1: simple leak | Yes |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 内存泄漏测试用例1：简单泄漏 | 是 |'
- en: '| 12 | Memory leak test case 1: leak more (in a loop) | Yes |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 内存泄漏测试用例1：泄漏更多（循环中） | 是 |'
- en: '| 13 | Memory leak test case 1: lib API leak | Yes |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 内存泄漏测试用例1：lib API泄漏 | 是 |'
- en: 'Table 4: AddressSanitizer and Memory Bugs'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 表4：AddressSanitizer和内存错误
- en: '[1]The **MemorySanitizer** (**MSan**) fulfills exactly this purpose - it does
    detect UMR.However, there are two things to notice:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[1] **MemorySanitizer**（**MSan**）正好实现了这个目的-它确实检测到UMR。但是，有两件事需要注意：'
- en: UMR is detected by MSan only on dynamically allocated memory
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UMR只能由MSan在动态分配的内存上检测到
- en: Using MSan successfully necessitates using the Clang compiler (it did not work
    with GCC)
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功使用MSan需要使用Clang编译器（它不能与GCC一起工作）
- en: '[2]This works with the caveat that the code is compiled with Clang and the
    `detect_stack_use_after_return=1` flag is passed via `ASAN_OPTIONS`.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[2]这适用的前提是代码使用Clang编译，并通过`ASAN_OPTIONS`传递`detect_stack_use_after_return=1`标志。'
- en: AddressSanitizer pros and cons – a quick summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AddressSanitizer的优缺点-快速总结
- en: 'ASan pros:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ASan的优点：
- en: Catches common memory bugs (UB) on both statically (compile-time) and dynamically
    allocated memory regions
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获常见的内存错误（UB）在静态（编译时）和动态分配的内存区域上
- en: Out-of-bounds (OOB) memory accesses (read/write underflow/overflow bugs)
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 越界（OOB）内存访问（读/写下溢/溢出错误）
- en: Use-after-free (UAF) bugs
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放后使用（UAF）错误
- en: Use-after-return (UAR) bugs
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回后使用（UAR）错误
- en: Double free
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双重释放
- en: Leakage
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泄漏
- en: Performance is far superior to other tools (such as Valgrind); the worst case
    performance drop seems to be a factor 2x
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能远远优于其他工具（如Valgrind）；最坏情况下性能下降似乎是2倍
- en: No modification to source code required
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要修改源代码
- en: Fully supports multithreaded applications
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全支持多线程应用程序
- en: 'ASan cons:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ASan的缺点：
- en: 'ASan cannot detect some types of bugs:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASan无法检测到某些类型的错误：
- en: UMR (as mentioned earlier, with some caveats, MSan can)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UMR（如前所述，带有一些警告，MSan可以）
- en: Does not detect all UAF bugs
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法检测所有UAF错误
- en: IOF (Integer Underflow/Overflow) bugs
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IOF（整数下溢/上溢）错误
- en: Using a certain tool at a time; cannot always combine multiple sanitizer tools
    (see the preceding table); this implies that often, separate test cases must be
    written for ASan, TSan, LSan
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次只能使用一个特定的工具；不能总是组合多个消毒剂工具（参见前表）；这意味着通常必须为ASan、TSan、LSan编写单独的测试用例
- en: 'Compiler:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器：
- en: Often, the program is required to be recompiled with the LLVM frontend Clang
    and appropriate compiler flags.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，需要使用LLVM前端Clang和适当的编译器标志重新编译程序。
- en: In order to see the call stack with line number information, a recompile/build
    with the `-g` flag is required.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了查看带有行号信息的调用堆栈，需要使用`-g`标志重新编译/构建。
- en: 'Here, we''ve combined the preceding two tables. Refer to the following table,
    memory bugs - a quick comparison between Valgrind and Address Sanitizer:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经合并了前面的两个表。请参考以下表格，内存错误 - Valgrind和地址消毒剂之间的快速比较：
- en: '| **Test case #** | **Test case** | **Detected by Valgrind?** | **Detected
    by Address Sanitizer?** |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '**测试用例＃** | **测试用例** | **Valgrind检测到？** | **地址消毒剂检测到？**'
- en: '| 1 | UMR | Yes | No[1] |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 1 | UMR | 是 | 否[1]'
- en: '| 2 | OOB (out-of-bounds): write overflow [on compile-time memory] | No | Yes
    |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 2 | OOB（越界）：写入溢出[在编译时内存上] | 否 | 是'
- en: '| 3 | OOB (out-of-bounds): write overflow [on dynamic memory] | Yes | Yes |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 3 | OOB（越界）：写入溢出[在动态内存上] | 是 | 是'
- en: '| 4 | OOB (out-of-bounds): write underflow [on dynamic memory] | Yes | Yes
    |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 4 | OOB（越界）：写入下溢[在动态内存上] | 是 | 是'
- en: '| 5 | OOB (out-of-bounds): read overflow [on compile-time memory] | No | Yes
    |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 5 | OOB（越界）：读取溢出[在编译时内存上] | 否 | 是'
- en: '| 6 | OOB (out-of-bounds): read overflow [on dynamic memory] | Yes | Yes |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: 6 | OOB（越界）：读取溢出[在动态内存上] | 是 | 是
- en: '| 7 | OOB (out-of-bounds): read underflow [on dynamic memory] | Yes | Yes |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 7 | OOB（越界）：读取下溢[在动态内存上] | 是 | 是'
- en: '| 8 | UAF (use-after-free) also known as dangling pointer | Yes | Yes |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 8 | UAF（释放后使用）也称为悬空指针 | 是 | 是'
- en: '| 9 | UAR (use-after-return) also known as UAS (use-after-scope) | No | Yes[2]
    |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 9 | UAR（返回后使用）也称为UAS（作用域后使用） | 否 | 是[2]'
- en: '| 10 | Double free | Yes | Yes |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 重复释放 | 是 | 是'
- en: '| 11 | Memory leak test case 1: simple leak | Yes | Yes |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 内存泄漏测试用例1：简单泄漏 | 是 | 是'
- en: '| 12 | Memory leak test case 1: leak more (in a loop) | Yes | Yes |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 内存泄漏测试用例1：泄漏更多（循环中） | 是 | 是'
- en: '| 13 | Memory leak test case 1: lib API leak | Yes | Yes |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 内存泄漏测试用例1：lib API泄漏 | 是 | 是'
- en: '[1]MSan fulfills exactly this purpose—it does detect UMR (also see caveats).'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[1]MSan正好实现了这个目的-它确实检测UMR（也请参见警告）。'
- en: It works with the caveats that the code is compiled with Clang and the `detect_stack_use_after_return=1`
    flag is passed via `ASAN_OPTIONS`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 它与警告一起使用，即代码使用Clang编译，并通过`ASAN_OPTIONS`传递了`detect_stack_use_after_return=1`标志。
- en: Glibc mallopt
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Glibc mallopt
- en: 'Sometimes useful to programmers, glibc provides a means to change the malloc
    engine''s defaults thanks to its ability to pass some specific parameters. The
    API is `mallopt(3)` :'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对程序员有时很有用，glibc提供了一种通过传递一些特定参数来更改malloc引擎默认值的方法。API是`mallopt(3)`：
- en: '[PRE33]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Please refer to the man page on `mallopt(3)` for all the gory details (available
    at [http://man7.org/linux/man-pages/man3/mallopt.3.html](http://man7.org/linux/man-pages/man3/mallopt.3.html)).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅`mallopt(3)`的man页面，了解所有可怕的细节（可在[http://man7.org/linux/man-pages/man3/mallopt.3.html](http://man7.org/linux/man-pages/man3/mallopt.3.html)上找到）。
- en: As an interesting example, one of the parameters that can be tweaked is **`M_MMAP_THRESHOLD`**;
    recall, in the earlier [Chapter 5](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml),
    *Linux Memory Issues*, we covered the fact that on modern glibc, malloc does not
    always get memory blocks from the heap segment. If the size of the allocation
    request is above or equal to `MMAP_THRESHOLD`, the request is serviced under the
    hood via the powerful `mmap(2)` system call (which sets up  an arbitrary region
    of virtual address space of the size requested). The default value of `MMAP_THRESHOLD`
    is 128 KB; this can be changed via the `M_MMAP_THRESHOLD` parameter using `mallopt(3)`!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个有趣的例子，可以调整的参数之一是**`M_MMAP_THRESHOLD`**；回想一下，在之前的[第5章](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml)中，*Linux内存问题*，我们已经讨论过在现代glibc上，malloc并不总是从堆段获取内存块。如果分配请求的大小大于或等于`MMAP_THRESHOLD`，则在底层通过强大的`mmap(2)`系统调用（设置请求大小的任意虚拟地址空间区域）来服务请求。`MMAP_THRESHOLD`的默认值为128
    KB；可以通过使用`mallopt(3)`的`M_MMAP_THRESHOLD`参数进行更改！
- en: Again, this does not imply you should change it; only that you could. The default
    value is carefully arrived at and probably best suited to most application workloads.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这并不意味着您应该更改它；只是您可以。默认值经过精心设计，可能最适合大多数应用程序工作负载。
- en: Another useful parameter is `M_CHECK_ACTION`; this parameter determines how
    glibc reacts when memory errors are detected (say, a write overflow or a double
    free). Also note that the implementation does *not* detect all types of memory
    errors (leakage goes unnoticed, for example).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的参数是`M_CHECK_ACTION`；此参数确定在检测到内存错误时glibc的反应（例如，写入溢出或重复释放）。还要注意，该实现*不*检测所有类型的内存错误（例如，泄漏不会被注意到）。
- en: 'At runtime, glibc interprets these three **least significant bits** (**LSB**)
    of the parameter''s value to determine how to react:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，glibc解释参数值的最低三位（LSB）以确定如何做出反应：
- en: '**Bit 0**: If set, print a one-line error message to `stderr` providing detailed
    information regarding the cause; the error-line format is:'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位0**：如果设置，将在`stderr`上打印一行错误消息，提供有关原因的详细信息；错误行格式为：'
- en: '[PRE34]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Bit 1**: If set, after printing the error message, `abort(3)` is invoked
    causing the process to terminate. Depending on the version of the library, the
    stack trace and the relevant portion of the process memory map (via proc) may
    also be printed.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位1**：如果设置了，在打印错误消息后，将调用`abort(3)`导致进程终止。根据库的版本，还可能打印堆栈跟踪和进程内存映射的相关部分（通过proc）。'
- en: '**Bit 2**: If set, and if bit 0 set, simplify the error message format.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位2**：如果设置，并且设置了位0，则简化错误消息格式。'
- en: From glibc ver. 2.3.4, the `M_CHECK_ACTION` default value is 3 (implying binary
    011; earlier it was 1).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 从glibc ver。2.3.4开始，`M_CHECK_ACTION`的默认值为3（意味着二进制011；之前是1）。
- en: Setting `M_CHECK_ACTION` to a nonzero value can be very useful as it will cause
    a buggy process to crash at the point the bug is hit, and display useful diagnostics.
    If it were zero, the process would probably enter an undefined state (UB) and
    crash at some arbitrary point in the future, making debugging a lot harder.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 将`M_CHECK_ACTION`设置为非零值非常有用，因为它将导致出现错误的进程在命中错误时崩溃，并显示有用的诊断信息。如果值为零，进程可能会进入未定义状态（UB），并在将来的某个任意点崩溃，这将使调试变得更加困难。
- en: 'As a quick reckoner, here are some useful values for `M_CHECK_ACTION` and their
    meaning:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速的参考者，这里有一些有用的`M_CHECK_ACTION`值及其含义：
- en: '1 (001b): Print a detailed error message but continue execution (process is
    now in UB!).'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 (001b)：打印详细的错误消息，但继续执行（进程现在处于UB状态！）。
- en: '3 (011b): Print a detailed error message, call stack, memory mappings, and
    abort execution [default].'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 (011b)：打印详细的错误消息、调用堆栈、内存映射，并中止执行[默认]。
- en: '5 (101b): Print a simple error message and continue execution (process is now
    in UB!).'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5 (101b)：打印简单的错误消息并继续执行（进程现在处于UB状态！）。
- en: '7 (111b): Print a simple error message, call stack, memory mappings, and abort
    execution.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7 (111b)：打印简单的错误消息、调用堆栈、内存映射，并中止执行。
- en: The man page on `mallopt(3)` helpfully provides a C program example of using
    `M_CHECK_ACTION`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`mallopt(3)`的man页面提供了一个使用`M_CHECK_ACTION`的C程序示例。'
- en: Malloc options via the environment
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过环境设置Malloc选项
- en: 'A useful feature: instead of programmatically using the `mallopt(3)` API, the
    system allows us to tune some allocation parameters conveniently via environment
    variables. Most useful, perhaps, from the viewpoint of debug and testing, the
    `MALLOC_CHECK_` variable is the environment variable corresponding to the `M_CHECK_ACTION`
    parameter described earlier; thus, we can just set the value, run our application,
    and see the result for ourselves!'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的功能：系统允许我们通过环境变量方便地调整一些分配参数，而不是通过编程方式使用`mallopt(3)` API。也许最有用的是，从调试和测试的角度来看，`MALLOC_CHECK_`变量是与先前描述的`M_CHECK_ACTION`参数对应的环境变量；因此，我们只需设置值，运行我们的应用程序，然后亲自查看结果！
- en: 'A few examples follow, using our usual membugs application to check out some
    test cases:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例，使用我们通常的membugs应用程序来检查一些测试用例：
- en: '**Test case # 10:** double free with `MALLOC_CHECK_` set:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例＃10：**在设置`MALLOC_CHECK_`的情况下，使用`double free`：'
- en: '[PRE35]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice how, with the value of `MALLOC_CHECK_` being 1, the error message, is
    printed but the process is not aborted; this is what happens when the value of
    the environment variable is set to `3`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当`MALLOC_CHECK_`的值为1时，错误消息被打印，但进程没有中止；这就是当环境变量的值设置为`3`时发生的情况。
- en: '**Test case # 7:** out-of-bounds (read underflow) with `MALLOC_CHECK_` set:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例＃7：**在设置`MALLOC_CHECK_`的情况下，进行越界（读取下溢）：'
- en: '[PRE36]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Test c****ase # 11:** memory leak test case 1—simple leak with `MALLOC_CHECK_`
    set:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例＃11：**内存泄漏测试用例1——在设置`MALLOC_CHECK_`的情况下，进行简单泄漏：'
- en: '[PRE37]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice how a leakage bug test case is not detected.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意泄漏错误测试用例未被检测到。
- en: The preceding examples were executed on an Ubuntu 17.10 x86_64 box; for some
    reason, interpretation of `MALLOC_CHECK_` on a Fedora 27 box did not seem to work
    as advertised.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例是在Ubuntu 17.10 x86_64上执行的；由于某种原因，在Fedora 27上对`MALLOC_CHECK_`的解释似乎并不像广告中描述的那样有效。
- en: Some key points
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些关键点
- en: We've covered some powerful memory debug tools and techniques, but at the end
    of the day, by itself these tools are not enough. Today's developer must keep
    alert—there are some remaining key points to mention briefly, which will serve
    to round off this chapter.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了一些强大的内存调试工具和技术，但归根结底，这些工具本身是不够的。今天的开发人员必须保持警惕——还有一些关键点需要简要提及，这将为本章画上一个圆满的句号。
- en: Code coverage while testing
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试时的代码覆盖率
- en: A key point to remember using dynamic analysis tools (we covered using Valgrind's
    Memcheck tool and ASan/MSan) is that it only really helps the effort if complete
    code coverage is achieved when running the tool(s) over the test cases!
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住使用动态分析工具（我们介绍了使用Valgrind的Memcheck工具和ASan/MSan）的一个关键点是，只有在运行工具时实现了完整的代码覆盖率，它才真正有助于我们的工作！
- en: This point cannot be stressed enough. What use is running a fantastic tool or
    compiler instrumentation, such as the Sanitizers, over your program if the buggy
    part of the code does not actually run! The bugs remain dormant, uncaught. As
    developers and testers, we have to discipline ourselves to write rigorous test
    cases that actually perform complete code coverage, such that all code—including
    project code in libraries—is actually tested via these powerful tools.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点无法强调得足够。如果代码的错误部分实际上没有运行，那么运行一个奇妙的工具或编译器插装（例如Sanitizers）有什么用呢！错误仍然潜伏，未被捕获。作为开发人员和测试人员，我们必须自律地编写严格的测试用例，确保实际上执行了完整的代码覆盖，以便通过这些强大的工具测试所有代码，包括库中的项目代码。
- en: 'This is not easy: remember, anything worth doing is worth doing well.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不容易：记住，任何值得做的事情都值得做好。
- en: What is the modern C/C++ developer to do?
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代C/C++开发人员该怎么办？
- en: In the face of so much UB potential in complex software projects written on
    C/C++, the concerned developer might well ask, What are we to do?
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 面对C/C++复杂软件项目中潜在的UB问题，关注的开发人员可能会问，我们该怎么办？
- en: 'Source: [https://blog.regehr.org/archives/1520](https://blog.regehr.org/archives/1520).
    Here is a snippet from the excellent blog article, Undefined Behavior in 2017,
    by Cuoq and Regehr.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[https://blog.regehr.org/archives/1520](https://blog.regehr.org/archives/1520)。这是一篇来自优秀博客文章《2017年的未定义行为》的摘录，作者是Cuoq和Regehr。
- en: '**What is the modern C or C++ developer to do?**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**现代C或C++开发人员该怎么办？**'
- en: Be comfortable with the easy UB tools—the ones that can usually be enabled just
    by adjusting a makefile, such as compiler warnings and ASan and UBSan. Use these
    early and often, and (crucially) act upon their findings.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉一些易于使用的UB工具——通常可以通过调整makefile来启用的工具，例如编译器警告和ASan和UBSan。尽早并经常使用这些工具，并（至关重要）根据它们的发现采取行动。
- en: Be familiar with the hard UB tools—those such as TIS Interpreter that typically
    require more effort to run—and use them when appropriate.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉一些难以使用的UB工具——例如TIS Interpreter通常需要更多的努力来运行——并在适当的时候使用它们。
- en: Invest in broad-based testing (track code coverage, use fuzzers) in order to
    get maximum benefit out of dynamic UB detection tools.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行广泛的测试（跟踪代码覆盖率，使用模糊器）以便充分利用动态UB检测工具。
- en: 'Perform UB-aware code reviews: build a culture where we collectively diagnose
    potentially dangerous patches and get them fixed before they land.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行UB意识的代码审查：建立一个文化，我们共同诊断潜在危险的补丁并在其落地之前修复它们。
- en: Be knowledgeable about what’s actually in the C and C++ standards since these
    are what compiler writers are going by. Avoid repeating tired maxims such as C
    is a portable assembly language and trust the programmer.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解C和C++标准中实际包含的内容，因为这是编译器编写者所遵循的。避免重复的陈词滥调，比如C是一种可移植的汇编语言，相信程序员。
- en: A mention of the malloc API helpers
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提到了malloc API辅助程序
- en: There are plenty of `malloc `API helper routines. These can be useful when debugging
    a difficult scenario; it's a good idea to be aware of what's available.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多`malloc`API辅助程序。在调试困难的情况下，这些可能会很有用；了解有哪些可用的是个好主意。
- en: 'On an Ubuntu Linux system, we check with man for a match to the keyword `malloc`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu Linux系统中，我们通过man检查与关键字`malloc`匹配的内容：
- en: '[PRE38]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Quite a few of these `malloc` APIs (reminder: the number three within parentheses,(3),
    implies it''s a library routine) deal with the concept of malloc hooks. The essential
    idea: one can replace the library `malloc(3)`, `realloc(3)`, `memalign(3)` and
    `free(3)` APIs with one''s own `hook` function, which will be invoked when the
    application calls the API.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`malloc`API中有相当多的（提醒：括号内的数字三（3）表示这是一个库例程）与malloc挂钩的概念有关。基本思想是：可以用自己的`hook`函数替换库的`malloc(3)`、`realloc(3)`、`memalign(3)`和`free(3)`API，当应用程序调用API时将调用该函数。
- en: 'However, we will not be delving further into this area; why not? Recent versions
    of glibc document the fact that these hook functions are:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会进一步深入这个领域；为什么呢？glibc的最新版本记录了这样一个事实，即这些挂钩函数是：
- en: Not MT-Safe (covered in [Chapter 16](4df10c19-b400-4805-8e6e-51a8f43dcfa4.xhtml),
     *Multithreading with Pthreads Part III*)
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不是MT-Safe（在[第16章](4df10c19-b400-4805-8e6e-51a8f43dcfa4.xhtml)中有介绍，*使用Pthreads进行多线程编程第三部分*）
- en: Deprecated from glibc ver. 2.24 onward
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从glibc ver. 2.24开始弃用
- en: 'Finally, it might be obvious, but we would prefer to call this out explicitly:
    one must realize that using these tools serves a purpose only in testing environments;
    they are not meant to be used in production! Some studies have revealed security
    vulnerabilities that can be exploited when running ASan in production; see the *Further
    reading *section on the GitHub repository.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这可能是显而易见的，但我们更愿意明确指出：必须意识到，使用这些工具只在测试环境中有意义；它们不应该在生产中使用！一些研究已经揭示了在生产中运行ASan时可能会被利用的安全漏洞；请参阅GitHub存储库上的*进一步阅读*部分。
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have attempted to show the reader several key points, tools
    and techniques; among them:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们试图向读者展示几个关键点、工具和技术；其中包括：
- en: Humans will make mistakes; this is especially true with memory unmanaged languages
    (C, C++).
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人会犯错误；这在内存未受管理的语言（C、C++）中尤其如此。
- en: There is a real need for powerful memory debug tools on nontrivial codebases.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在非平凡的代码库中，确实需要强大的内存调试工具。
- en: 'We covered two of these best in class dynamic analysis tools in detail:'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们详细介绍了这两种最佳动态分析工具中的两种：
- en: Valgrind's Memcheck
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Valgrind的Memcheck
- en: Sanitizers (primarily ASan)
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消毒剂（主要是ASan）
- en: Glibc allows some tuning of malloc via the `mallopt(3)` API, as well as via
    environment variables.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`mallopt(3)`API和环境变量，glibc允许对`malloc`进行一些调整。
- en: Ensuring complete code coverage when building test cases is absolutely crucial
    to the success of a project.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建测试用例时确保完整的代码覆盖率对项目的成功至关重要。
- en: The next chapter is related to the essentials aspects of file I/O which is essential
    for a component reader to know. It introduces you to performing efficient file
    I/O on the Linux platform. We would request the readers to go through this chapter
    which is available here: [https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf](https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf).
    We highly recoomend the readers to read Open at the system call layer, The file
    descriptor and I/O – the read/write system calls which can help in easy understanding
    the next chapter that is, [Chapter 7](7b84d41f-dfff-439b-a751-46880cfe4651.xhtml), *Process
    Credentials*.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章与文件I/O的基本方面有关，这对于组件读者来说是必不可少的。它向您介绍了如何在Linux平台上执行高效的文件I/O。我们请求读者阅读这一章，可在此处找到：[https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf](https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf)。我们强烈建议读者阅读系统调用层的Open，文件描述符和I/O
    - 读/写系统调用，这有助于更容易理解下一章，即[第7章](7b84d41f-dfff-439b-a751-46880cfe4651.xhtml)，*进程凭证*。
