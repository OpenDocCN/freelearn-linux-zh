- en: '*Chapter 5*: Linux to Windows Interoperability'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：Linux到Windows的互操作性'
- en: In [*Chapter 1*](B16412_01_Final_JC_ePub.xhtml#_idTextAnchor017), *Introduction
    to the Windows Subsystem for Linux*, we compared the WSL experience to running
    Linux in a virtual machine and mentioned the WSL capabilities for interoperability.
    In [*Chapter 4*](B16412_04_Final_JC_ePub.xhtml#_idTextAnchor047), *Windows to
    Linux Interoperability*, we saw how to begin leveraging these interoperability
    features from the Windows side. In this chapter, we will continue exploring the
    interoperability features, but this time from the Linux side. This will allow
    you to bring the capabilities of Windows commands and tools into WSL environments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B16412_01_Final_JC_ePub.xhtml#_idTextAnchor017)中，*介绍Windows子系统Linux*，我们将WSL体验与在虚拟机中运行Linux进行了比较，并提到了WSL的互操作性能力。在[*第4章*](B16412_04_Final_JC_ePub.xhtml#_idTextAnchor047)中，*Windows到Linux的互操作性*，我们看到了如何开始利用这些互操作性功能。在本章中，我们将继续探索互操作性功能，但这次是从Linux端进行。这将使您能够将Windows命令和工具的功能带入WSL环境中。
- en: We will start by looking at how to interact with Windows applications and files
    from within the WSL environment. Next up, we will look at how to work with scripts
    across Linux and Windows, including how to pass input between them. We will finish
    up with a number of interoperability tips and tricks to boost your productivity,
    from making Windows commands feel more natural by aliasing them, to sharing your
    **Secure Shell** (**SSH**) keys between Windows and Linux for ease of use and
    maintenance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看一下如何在WSL环境中与Windows应用程序和文件进行交互。接下来，我们将介绍如何在Linux和Windows之间处理脚本，包括如何在它们之间传递输入。最后，我们将提供一些互操作性技巧和窍门，以提高您的生产力，从通过别名使Windows命令更加自然，到在Windows和Linux之间共享**安全外壳**（**SSH**）密钥以便于使用和维护。
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Accessing Windows files from Linux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Linux访问Windows文件
- en: Calling Windows apps from Linux
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Linux调用Windows应用程序
- en: Calling Windows scripts from Linux
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Linux调用Windows脚本
- en: Interoperability tips and tricks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互操作性技巧和窍门
- en: Let's get started with the first topic!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个主题开始！
- en: Accessing Windows files from Linux
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Linux访问Windows文件
- en: 'By default, WSL automatically mounts your Windows drives inside WSL `/mnt`;
    for example, your `C:` drive is mounted as `/mnt/c`. To try this out, create a
    folder called `wsl-book` on your `C:` drive and place an `example.txt` file in
    it (the contents of the text file don''t particularly matter). Now, fire up a
    terminal in WSL and run `ls /mnt/c/wsl-book`, and you will see the file you created
    listed in the Bash output:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，WSL会自动将Windows驱动器挂载到WSL的`/mnt`目录下；例如，您的`C:`驱动器会被挂载为`/mnt/c`。要尝试这个功能，请在`C:`驱动器上创建一个名为`wsl-book`的文件夹，并在其中放置一个`example.txt`文件（文本文件的内容并不重要）。现在，在WSL中打开一个终端并运行`ls
    /mnt/c/wsl-book`，您将在Bash输出中看到您创建的文件：
- en: '![Figure 5.1 – A screenshot showing listing folder contents from Windows and
    WSL'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 - 屏幕截图显示了从Windows和WSL列出文件夹内容'
- en: '](img/Figure_5.1_B16412.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B16412.jpg)'
- en: Figure 5.1 – A screenshot showing listing folder contents from Windows and WSL
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 - 屏幕截图显示了从Windows和WSL列出文件夹内容
- en: This screenshot includes the directory listing from Windows showing `example.txt`
    in `/mnt/c` path in a WSL distro on the right.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此屏幕截图显示了Windows中的目录列表，右侧是WSL发行版中`/mnt/c`路径下的`example.txt`。
- en: 'You can interact with the mounted files as you would any other file; for example,
    you can `cat` the file to see its contents:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像与任何其他文件一样与挂载的文件进行交互；例如，您可以使用`cat`命令查看文件的内容：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or, you can redirect content to a file in the Windows file system:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以将内容重定向到Windows文件系统中的文件：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or, you can edit files in `vi` (or whatever your favorite terminal text editor
    is):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在`vi`（或您喜欢的其他终端文本编辑器）中编辑文件：
- en: '![Figure 5.2 – A screenshot showing editing a Windows file in vi under WSL'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 - 屏幕截图显示了在WSL下使用vi编辑Windows文件'
- en: '](img/Figure_5.2_B16413.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.2_B16413.jpg)'
- en: Figure 5.2 – A screenshot showing editing a Windows file in vi under WSL
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 - 屏幕截图显示了在WSL下使用vi编辑Windows文件
- en: In this screenshot, you can see the file from the Windows file system being
    edited in `vi` from a WSL distro after running `vi /mnt/c/wsl-book/wsl.txt`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕截图中，您可以看到从Windows文件系统中的文件在WSL发行版中的`vi`中进行编辑，之前运行了`vi /mnt/c/wsl-book/wsl.txt`命令。
- en: Important note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Under Windows, file systems are generally case-insensitive; that is, Windows
    treats `SomeFile` as the same as `somefile`. Under Linux, file systems are case-*sensitive*
    so those would be viewed as two separate files.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows下，文件系统通常是不区分大小写的；也就是说，Windows将`SomeFile`视为与`somefile`相同。在Linux下，文件系统是区分大小写的，因此它们将被视为两个不同的文件。
- en: When accessing the Windows file system from the WSL mounts, the files are treated
    in a case-sensitive manner on the Linux side, so attempting to read from `/mnt/c/wsl-book/EXAMPLE.txt`
    would fail.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当从WSL挂载访问Windows文件系统时，Linux端对文件进行区分大小写处理，因此尝试从`/mnt/c/wsl-book/EXAMPLE.txt`读取将失败。
- en: Although the Linux side treats the file system as case-sensitive, the underlying
    Windows file system is still case-insensitive and it is important to keep this
    in mind. For example, while Linux would consider `/mnt/c/wsl-book/wsl.txt` and
    `/mnt/c/wsl-book/WSL.txt` to be separate files, writing to `/mnt/c/wsl-book/WSL.txt`
    from Linux would actually overwrite the contents of the previously created `wsl.txt`
    file because Windows treats the names as case-insensitive.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Linux端将文件系统视为区分大小写，但底层的Windows文件系统仍然是不区分大小写的，这一点很重要。例如，虽然Linux会将`/mnt/c/wsl-book/wsl.txt`和`/mnt/c/wsl-book/WSL.txt`视为不同的文件，但从Linux写入`/mnt/c/wsl-book/WSL.txt`实际上会覆盖先前创建的`wsl.txt`文件的内容，因为Windows将名称视为不区分大小写。
- en: As you have seen in this section, the automatically created mounts (`/mnt/…`)
    make it really easy to access Windows files from within your Linux distros with
    WSL (if you want to disable this mounting or change where the mounts are created,
    you can use `wsl.conf`, as shown in [*Chapter 2*](B16412_02_Final_JC_ePub.xhtml#_idTextAnchor023),
    *Installing and Configuring the Windows Subsystem for Linux*). The next section
    will cover calling Windows applications from Linux.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在本节中所看到的，自动创建的挂载点（`/mnt/...`）使得通过WSL非常容易访问Windows文件（如果您想禁用此挂载或更改挂载点的位置，可以使用`wsl.conf`，如[*第2章*](B16412_02_Final_JC_ePub.xhtml#_idTextAnchor023)所示，*安装和配置Windows子系统用于Linux*）。下一节将介绍如何从Linux调用Windows应用程序。
- en: Calling Windows apps from Linux
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Linux调用Windows应用程序
- en: In [*Chapter 4*](B16412_04_Final_JC_ePub.xhtml#_idTextAnchor047), *Windows to
    Linux Interoperability*, we saw how we can use the `wsl` command to call Linux
    applications from Windows. Going the other way (calling Windows applications from
    Linux) is even easier! To see this in action, fire up a terminal in your WSL distro
    and run `/mnt/c/Windows/System32/calc.exe` to launch the Windows Calculator app
    directly from Linux. If Windows is not installed in `C:\Windows`, then update
    the path to match. In this way, you can launch any Windows application from a
    terminal in your WSL distros.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B16412_04_Final_JC_ePub.xhtml#_idTextAnchor047)中，我们看到了如何使用`wsl`命令从Windows调用Linux应用程序。而从Linux调用Windows应用程序则更加简单！为了看到这一点，启动WSL发行版中的终端，并运行`/mnt/c/Windows/System32/calc.exe`来直接从Linux启动Windows计算器应用程序。如果Windows没有安装在`C:\Windows`中，则更新路径以匹配。通过这种方式，您可以从WSL发行版的终端启动任何Windows应用程序。
- en: 'In the case of Windows Calculator (and many other applications), WSL actually
    makes it even easier. This time, type `calc.exe` in your terminal and Windows
    Calculator will still run. The reason this works is that `calc.exe` is in your
    Windows path and (by default) WSL will map your Windows path to the Linux path
    in your WSL distros. To demonstrate this, run `echo $PATH` in the terminal:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows计算器（以及许多其他应用程序）的情况下，WSL实际上使得这更容易。这次，在终端中键入`calc.exe`，Windows计算器仍然会运行。之所以能够运行，是因为`calc.exe`在Windows路径中，并且（默认情况下）WSL将映射Windows路径到WSL发行版中的Linux路径。为了证明这一点，在终端中运行`echo
    $PATH`：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see from this, the `PATH` variable in Linux contains not only the
    usual paths, such as `/home/stuart/bin`, but also values from the Windows `PATH`
    variable that have been translated to use the WSL mounts, such as `/mnt/c/WINDOWS/System32`.
    The result of this is that any application that you are used to being able to
    run in Windows without specifying the path can also be run in WSL without specifying
    the path. One difference is that in Windows, we don't need to specify the file
    extension (for example, we can run `calc` in PowerShell) but in WSL we do.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中可以看出，Linux中的`PATH`变量不仅包含常见的路径，如`/home/stuart/bin`，还包含已经转换为使用WSL挂载的Windows
    `PATH`变量的值，例如`/mnt/c/WINDOWS/System32`。由此产生的结果是，您习惯于在Windows中无需指定路径即可运行的任何应用程序也可以在WSL中无需指定路径运行。一个区别是在Windows中，我们不需要指定文件扩展名（例如，我们可以在PowerShell中运行`calc`），但在WSL中我们需要。
- en: In the previous section, we created a text file in Windows (`c:\wsl-book\wsl.txt`)
    and opened it in Linux using `vi`, but what if we want to open the file in a Windows
    app? If you try running `notepad.exe c:\wsl-book\wsl.txt` from Linux, Notepad
    will give an error that it cannot find the file. To fix this, you can either put
    the path in quotes (`notepad.exe "c:\wsl-book\wsl.txt"`) or escape the backslashes
    (`notepad.exe c:\\wsl-book\\wsl.txt`). With either of these fixes in place, the
    command will launch Notepad with the specified file open.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们在Windows中创建了一个文本文件（`c:\wsl-book\wsl.txt`），并使用`vi`在Linux中打开了它，但是如果我们想在Windows应用程序中打开该文件怎么办？如果您尝试从Linux运行`notepad.exe
    c:\wsl-book\wsl.txt`，记事本将显示找不到该文件的错误。要解决此问题，您可以将路径放在引号中（`notepad.exe "c:\wsl-book\wsl.txt"`）或转义反斜杠（`notepad.exe
    c:\\wsl-book\\wsl.txt`）。使用这两种修复方法之一，该命令将启动记事本并打开指定的文件。
- en: In reality, when you're working in the terminal in a WSL distro, you will be
    spending a lot of time working with files in the Linux file system and you will
    want to open *those* files in an editor. If you have the sample code for the book
    (you can find it at [https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques](https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques)),
    navigate to the `chapter-05` folder in your terminal, where there is an `example.txt`
    file (if you haven't got the sample, you can run `echo "Hello from WSL!" > example.txt`
    to create a test file). In the terminal, try running `notepad.exe example.txt`
    – this will launch Notepad with the `example.txt` file from the WSL file system
    loaded. This is very handy as it allows you to easily launch Windows GUI editors
    to work with files in your WSL distros.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当您在WSL发行版的终端中工作时，您将花费大量时间在Linux文件系统中处理文件，并且您将希望在编辑器中打开*这些*文件。如果您有本书的示例代码（您可以在[https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques](https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques)找到它），请在终端中导航到`chapter-05`文件夹，其中有一个`example.txt`文件（如果您没有示例，请运行`echo
    "Hello from WSL!" > example.txt`创建一个测试文件）。在终端中，尝试运行`notepad.exe example.txt` -
    这将使用WSL文件系统加载`example.txt`文件启动记事本。这非常方便，因为它允许您轻松启动Windows GUI编辑器来处理WSL发行版中的文件。
- en: In this section, we've seen how easily we can call Windows GUI applications
    from WSL and pass paths as parameters. In the next section, we'll take a look
    at calling Windows scripts from WSL, and how to explicitly translate paths when
    we need to.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经看到了如何轻松地从WSL调用Windows GUI应用程序并将路径作为参数传递。在下一节中，我们将看看如何从WSL调用Windows脚本，以及在需要时如何明确转换路径。
- en: Calling Windows scripts from Linux
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Linux调用Windows脚本
- en: 'If you''re used to running PowerShell in Windows, then you will also be used
    to being able to directly call PowerShell cmdlets and scripts. When you are running
    PowerShell scripts in WSL, you have two options: install PowerShell for Linux
    or call PowerShell in Windows to run the script. If you are interested in PowerShell
    for Linux, the install documentation can be found at [https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux?view=powershell-7](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux?view=powershell-7).
    However, since this chapter is focused on calling Windows from WSL, we will look
    at the latter option.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯在Windows中运行PowerShell，那么你也习惯于能够直接调用PowerShell cmdlet和脚本。当你在WSL中运行PowerShell脚本时，有两个选择：在Linux上安装PowerShell或调用Windows上的PowerShell运行脚本。如果你对Linux上的PowerShell感兴趣，安装文档可以在[https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux?view=powershell-7](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux?view=powershell-7)找到。然而，由于本章重点是从WSL调用Windows，我们将看看后者选项。
- en: 'PowerShell is a Windows application and is in the Windows path, so we can call
    it using `powershell.exe` from Linux, as we saw in the last section. To run a
    command with PowerShell, we can use the `-C` switch (short for `-Command`):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell是一个Windows应用程序，并且在Windows路径中，所以我们可以在Linux中使用`powershell.exe`来调用它，就像我们在上一节中看到的那样。要使用PowerShell运行命令，我们可以使用`-C`开关（缩写为`-Command`）：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, here we are using the `-C` switch to run the PowerShell `Get-ItemProperty`
    cmdlet to retrieve values from the Windows registry.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在这里我们使用了`-C`开关来运行PowerShell的`Get-ItemProperty` cmdlet来从Windows注册表中检索值。
- en: 'In addition to being able to call PowerShell cmdlets, you can call PowerShell
    scripts from Linux. The accompanying code for this book contains an example `wsl.ps1`
    script. This script prints a greeting to the user (using the `Name` parameter
    passed in), prints out the current working directory, and then outputs some entries
    from the Windows event log. From a Bash prompt, with the working folder set to
    the `chapter-05` folder, we can run the script:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够调用PowerShell cmdlet外，你还可以从Linux调用PowerShell脚本。本书的附带代码包含一个名为`wsl.ps1`的示例脚本。该脚本向用户打印问候语（使用传入的`Name`参数），打印出当前工作目录，然后输出一些来自Windows事件日志的条目。从Bash提示符下，将工作文件夹设置为`chapter-05`文件夹，我们可以运行该脚本：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding output shows the result of running the script we just described:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示了运行我们刚刚描述的脚本的结果：
- en: 'We can see the `Hello from WSL: Stuart` output, which includes `Stuart` (the
    value we passed as the `Name` parameter).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们可以看到`Hello from WSL: Stuart`的输出，其中包括`Stuart`（我们作为`Name`参数传递的值）。'
- en: The current directory is output (`Microsoft.PowerShell.Core\FileSystem::\\wsl$\Ubuntu-20.04\home\stuart\wsl-book\chapter-05`).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前目录的输出为（`Microsoft.PowerShell.Core\FileSystem::\\wsl$\Ubuntu-20.04\home\stuart\wsl-book\chapter-05`）。
- en: Entries from the Windows event log from calling the `Get-EventLog` PowerShell
    cmdlet.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`Get-EventLog` PowerShell cmdlet时的Windows事件日志条目。
- en: This example shows getting Windows event log entries, but since it's running
    PowerShell in Windows, you have access to any of the Windows PowerShell cmdlets
    to retrieve Windows data or manipulate Windows.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了获取Windows事件日志条目，但由于它在Windows中运行PowerShell，你可以访问任何Windows PowerShell cmdlet来检索Windows数据或操作Windows。
- en: Being able to call PowerShell commands and scripts as you've seen here provides
    an easy way to get information from Windows when you need to. The example also
    shows passing a parameter (`Name`) from WSL to the PowerShell script, and next,
    we will explore this further to see how we can combine PowerShell and Bash commands.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，能够像这里展示的那样调用PowerShell命令和脚本提供了一种从Windows获取信息的简单方法。这个例子还展示了从WSL传递参数（`Name`）到PowerShell脚本，接下来，我们将进一步探讨如何结合使用PowerShell和Bash命令。
- en: Passing data between PowerShell and Bash
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在PowerShell和Bash之间传递数据
- en: 'Sometimes, calling a PowerShell command or script is sufficient, but other
    times, you will want to work with the output from that command in Bash. Processing
    the output from a PowerShell script in WSL works in a natural manner:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，调用PowerShell命令或脚本就足够了，但有时你会希望在Bash中处理该命令的输出。在WSL中处理PowerShell脚本的输出的方式很自然：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, this command demonstrates taking the output from executing some
    PowerShell and piping it into `wc -l`, which counts the number of lines in the
    input (`10`, in this example).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个命令演示了将执行一些PowerShell的输出通过管道传递到`wc -l`中，它计算输入中的行数（在这个例子中为`10`）。
- en: 'As you write scripts, it is also possible that you will want to pass values
    *into* a PowerShell script. In simple cases, we can use Bash variables, as shown
    here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写脚本时，你可能还希望将值传递给PowerShell脚本。在简单的情况下，我们可以使用Bash变量，如下所示：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we created a `MESSAGE` variable in Bash, and then used it in the command
    we passed to PowerShell. This approach uses variable substitution in Bash – the
    command that is passed to PowerShell is actually `Write-Host Hello`. This technique
    works for some scenarios, but sometimes you actually need to pipe input into PowerShell.
    This is a little less intuitive and uses the special `$input` variable in PowerShell:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在Bash中创建了一个`MESSAGE`变量，然后在传递给PowerShell的命令中使用它。这种方法使用了Bash中的变量替换-传递给PowerShell的实际命令是`Write-Host
    Hello`。这种技术适用于某些场景，但有时你实际上需要将输入传递给PowerShell。这种方法不太直观，使用了PowerShell中的特殊`$input`变量：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, you can see the output from `echo "Stuart"` being passed into
    PowerShell, which uses the `$input` variable to retrieve the input. This example
    has been kept deliberately simple to help show the technique for passing input.
    More often, the input could be the contents of a file or the output from another
    Bash command, and the PowerShell command could be a script that performs richer
    processing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到从`echo "Stuart"`输出的结果被传递到PowerShell中，PowerShell使用`$input`变量来检索输入。这个例子被故意保持简单，以帮助展示传递输入的技巧。更常见的情况是，输入可以是文件的内容或另一个Bash命令的输出，而PowerShell命令可以是执行更丰富处理的脚本。
- en: In this section, you've seen how to call Windows applications from WSL, including
    how to open WSL files in GUI applications. You've also seen how to call PowerShell
    scripts, as well as how to pass data between PowerShell and Bash to create scripts
    that span both environments to give you more options for how to write your scripts.
    In the next section, we'll explore some tips and tricks for making the integration
    even tighter to further boost your productivity.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经了解了如何从WSL调用Windows应用程序，包括如何在GUI应用程序中打开WSL文件。您还了解了如何调用PowerShell脚本，以及如何在PowerShell和Bash之间传递数据，以创建跨两个环境的脚本，为您提供更多编写脚本的选项。在下一节中，我们将探索一些技巧和诀窍，使集成更加紧密，进一步提高您的生产力。
- en: Interoperability tips and tricks
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互操作性技巧和诀窍
- en: In this section, we will look at some tips that you can use to boost your productivity
    when working between Windows and WSL. We will see how to use aliases to avoid
    specifying the extension when executing Windows commands to make them feel more
    natural. We'll also see how to copy text from Linux to the Windows clipboard and
    how to make Windows folders fit in more naturally in a WSL distro. After that,
    we'll see how to open files in the default Windows application from Linux. From
    there, we will look at how Windows applications are able to work with WSL paths
    when we pass them as parameters, as well as how to take control of mapping paths
    when the default behavior doesn't work. Finally, we'll look at how to share SSH
    keys from Windows into WSL distros for easy key maintenance.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些技巧，可以在Windows和WSL之间工作时提高您的生产力。我们将看到如何使用别名来避免在执行Windows命令时指定扩展名，使其更加自然。我们还将看到如何将文本从Linux复制到Windows剪贴板，以及如何使Windows文件夹在WSL发行版中更加自然。之后，我们将看到如何从Linux中的默认Windows应用程序打开文件。从那里开始，我们将看到当我们将WSL路径作为参数传递给它们时，Windows应用程序如何能够与WSL路径一起工作，以及在默认行为不起作用时如何控制映射路径。最后，我们将看到如何将Windows中的SSH密钥共享到WSL发行版中，以便轻松进行密钥维护。
- en: Let's get started with aliases.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用别名。
- en: Creating aliases for Windows applications
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Windows应用程序的别名
- en: As was noted earlier in the chapter, when calling Windows applications from
    WSL, we need to include the file extension. For example, we need to use `notepad.exe`
    to launch Notepad, whereas in Windows, we can just use `notepad`. If you are used
    to not including the file extension, then including it can take a bit of getting
    used to.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面提到的，当从WSL调用Windows应用程序时，我们需要包括文件扩展名。例如，我们需要使用`notepad.exe`来启动记事本，而在Windows中，我们只需使用`notepad`。如果您习惯于不包括文件扩展名，那么包括它可能需要一点时间来适应。
- en: As an alternative to trying to retrain yourself, you can retrain Bash! Aliases
    in Bash allow you to create an alias, or an alternative name, for a command. As
    an example, running `alias notepad=notepad.exe` will create an alias of `notepad`
    for `notepad.exe`. This means that when you run `notepad hello.txt`, Bash will
    interpret it as `notepad.exe hello.txt`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为重新训练自己的替代方法，您可以重新训练Bash！Bash中的别名允许您为命令创建别名或替代名称。例如，运行`alias notepad=notepad.exe`将为`notepad.exe`创建一个名为`notepad`的别名。这意味着当您运行`notepad
    hello.txt`时，Bash将将其解释为`notepad.exe hello.txt`。
- en: Running the `alias` command interactively in the terminal only sets the alias
    for the current instance of the shell. To add the alias permanently, copy the
    `alias` command into your `.bashrc` (or `.bash_aliases`) file so that the shell
    automatically sets it each time it starts.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中以交互方式运行`alias`命令只会为当前shell实例设置别名。要永久添加别名，请将`alias`命令复制到您的`.bashrc`（或`.bash_aliases`）文件中，以便每次启动shell时自动设置它。
- en: Next, we'll look at a handy Windows utility that is a good candidate for an
    alias.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下一个方便的Windows实用程序，它是一个很好的别名候选者。
- en: Copying output to the Windows clipboard
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将输出复制到Windows剪贴板
- en: Windows has had the `clip.exe` utility for a long time. The help text for `clip.exe`
    states that it *redirects output of command line tools to the Windows clipboard*,
    which is a good description. As we saw earlier in the chapter, we can pipe output
    from WSL to Windows applications, and we can use this with `clip.exe` to put items
    on the Windows clipboard.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Windows已经有了`clip.exe`实用程序很长时间了。`clip.exe`的帮助文本指出它*将命令行工具的输出重定向到Windows剪贴板*，这是一个很好的描述。正如我们在本章前面看到的，我们可以将WSL的输出导入到Windows应用程序中，并且我们可以使用`clip.exe`将其放入Windows剪贴板中。
- en: For example, running `echo $PWD > clip.exe` will pipe the current working directory
    in the terminal (the value of `$PWD`) to `clip.exe`. In other words, you can copy
    the current working directory in WSL to the Windows clipboard.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，运行`echo $PWD > clip.exe`将当前工作目录在终端中（即`$PWD`的值）传输到`clip.exe`。换句话说，您可以将当前工作目录从WSL复制到Windows剪贴板中。
- en: You can also combine this with an alias (`alias clip=clip.exe`) to simplify
    it to `echo $PWD > clip`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将其与别名（`alias clip=clip.exe`）结合使用，简化为`echo $PWD > clip`。
- en: I find myself using `clip.exe` a lot – for example, to copy the output of a
    command into my code editor or an email – and it saves having to select and copy
    text in the terminal.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常使用`clip.exe` - 例如，将命令的输出复制到我的代码编辑器或电子邮件中 - 这样可以避免在终端中选择和复制文本。
- en: Let's continue with the tips by taking a look at a way to make Windows paths
    more at home in WSL.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用一些技巧，看看如何使Windows路径在WSL中更加自然。
- en: Using symlinks to make Windows paths easier to access
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用符号链接使Windows路径更易访问
- en: As we saw earlier, we can access Windows paths via the `/mnt/c/…` mapping. But
    there are some paths that you may find you access frequently, and would prefer
    to have even easier access to. For me, one of these paths is my Windows `Downloads`
    folder – each time I discover a Linux tool that I want to install in WSL and need
    to download a package to install, my browser defaults to downloading it to the
    `Downloads` folder in Windows. While I can access this via `/mnt/c/Users/stuart/Downloads`,
    I like having access to this as `~/Downloads` in WSL.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，我们可以通过`/mnt/c/…`映射访问Windows路径。但是，您可能会发现有一些路径您经常访问，并且希望更方便地访问它们。对我来说，其中一个路径是我的Windows
    `Downloads`文件夹 - 每当我发现一个我想要在WSL中安装的Linux工具并需要下载一个安装包时，我的浏览器默认将其下载到Windows的`Downloads`文件夹中。虽然我可以通过`/mnt/c/Users/stuart/Downloads`访问它，但我更喜欢在WSL中将其访问为`~/Downloads`。
- en: 'To achieve this, we can use the `ln` utility to create a `~/Downloads` that
    targets the Windows `Downloads` folder:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以使用`ln`实用程序创建一个以Windows `Downloads`文件夹为目标的`~/Downloads`：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this output, you can see the `ln -s /mnt/c/Users/stuart/Downloads/ ~/Downloads`
    command being used to create the symlink (you will need to change the first path
    to match your Windows `Downloads` folder). After that, you can see the output
    of listing the contents of the new symlinked location in WSL.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在此输出中，您可以看到使用`ln -s /mnt/c/Users/stuart/Downloads/ ~/Downloads`命令创建符号链接（您需要更改第一个路径以匹配您的Windows
    `Downloads`文件夹）。之后，您可以看到在WSL中列出新的符号链接位置的内容输出。
- en: While there is nothing special in WSL in terms of symlinks, being able to create
    symlinks to Windows folders allows you to customize your WSL environment even
    further. As you use WSL, you will likely find your own folders that you want to
    symlink to.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在WSL中没有特殊的符号链接功能，但能够创建指向Windows文件夹的符号链接使您能够进一步自定义WSL环境。当您使用WSL时，您可能会发现自己想要创建符号链接的文件夹。
- en: Next, we'll take a look at opening WSL files in the default Windows editor for
    their file types.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一下如何在默认的Windows编辑器中打开WSL文件。
- en: Using wslview to launch default Windows applications
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用wslview启动默认的Windows应用程序
- en: In this chapter, we've seen how we can call specific Windows applications from
    WSL. Another feature that Windows has is being able to launch *a file* and have
    Windows determine which application should actually be launched to open it. For
    example, at a PowerShell prompt, executing `example.txt` will open the default
    text editor (likely Notepad), whereas executing `example.jpg` will open your default
    image viewer.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了如何从WSL调用特定的Windows应用程序。Windows还具有另一个功能，即能够启动*一个文件*并让Windows确定应该启动哪个应用程序来打开它。例如，在PowerShell提示符下执行`example.txt`将打开默认的文本编辑器（通常是记事本），而执行`example.jpg`将打开默认的图像查看器。
- en: Fortunately, help is at hand, and `wslview` from `wslutilities` allows us to
    do the same thing from Linux. Recent versions of Ubuntu in the Microsoft Store
    come with `wslutilities` preinstalled, but installation instructions for other
    distros can be found at [https://github.com/wslutilities/wslu](https://github.com/wslutilities/wslu).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有帮助可得，`wslutilities`中的`wslview`允许我们从Linux中执行相同的操作。在Microsoft Store中的最新版本的Ubuntu预装了`wslutilities`，但其他发行版的安装说明可以在[https://github.com/wslutilities/wslu](https://github.com/wslutilities/wslu)找到。
- en: 'With `wslutilities` installed, you can run `wslview` in your WSL terminal:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了`wslutilities`后，您可以在WSL终端中运行`wslview`：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These commands show several examples of using `wslview`. The first two examples
    show the launching of the default Windows application for a file, based on its
    extension. The first example launches the default Windows text editor (typically
    Notepad) and the second example launches the Windows application associated with
    JPEG files. In the third example, we passed a URL, and this will open that URL
    in the default Windows browser.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令展示了使用`wslview`的几个示例。前两个示例展示了根据文件扩展名启动默认的Windows应用程序。第一个示例启动默认的Windows文本编辑器（通常是记事本），第二个示例启动与JPEG文件关联的Windows应用程序。在第三个示例中，我们传递了一个URL，这将在默认的Windows浏览器中打开该URL。
- en: This utility is a really handy way to bridge from the console in WSL to graphical
    applications in Windows.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实用程序是从WSL控制台到Windows图形应用程序的一种非常方便的桥梁。
- en: At the time of writing, there are some limitations to the paths that can be
    used with `wslview`; for example, `wslview ~/my-text-file.txt` will fail with
    an error as `The system cannot find the file specified`. In the next section,
    we will look at how to convert paths between Windows and Linux to overcome this.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`wslview`可以使用的路径存在一些限制；例如，`wslview ~/my-text-file.txt`将失败并显示错误`系统找不到指定的文件`。在下一节中，我们将介绍如何在Windows和Linux之间转换路径以解决这个问题。
- en: Mapping paths between Windows and WSL
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Windows和WSL之间映射路径
- en: 'Earlier in the chapter, we were running commands from WSL such as `notepad.exe
    example.txt`, which resulted in Notepad opening with the text file we specified.
    At first glance, it might seem like WSL translated the path for us when we ran
    the command, but the following screenshot shows Notepad in Task Manager (with
    the **Command line** column added):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面部分，我们在WSL中运行了诸如`notepad.exe example.txt`之类的命令，结果记事本打开了我们指定的文本文件。乍一看，似乎WSL在我们运行命令时为我们转换了路径，但下面的屏幕截图显示了任务管理器中的记事本（添加了**命令行**列）：
- en: '![Figure 5.3 – A screenshot showing notepad.exe running in Task Manager'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 - 显示任务管理器中运行的notepad.exe的屏幕截图'
- en: '](img/Figure_5.3_B16412.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.3_B16412.jpg)'
- en: Figure 5.3 – A screenshot showing notepad.exe running in Task Manager
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 - 显示任务管理器中运行的notepad.exe的屏幕截图
- en: 'In this screenshot, you can see Notepad with three different arguments:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕截图中，您可以看到记事本使用了三个不同的参数：
- en: '`notepad.exe example.txt`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notepad.exe example.txt`'
- en: '`notepad.exe ../chapter-05/example.txt`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notepad.exe ../chapter-05/example.txt`'
- en: '`notepad.exe /home/stuart/wsl-book/chapter-05/example.txt`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notepad.exe /home/stuart/wsl-book/chapter-05/example.txt`'
- en: For each of the examples listed, I made sure I was in a directory where the
    path resolved to a file in WSL, and Notepad launched with the example file open
    each time, even though the argument was passed directly to Notepad without translation
    (as shown in the *Figure 5.3* screenshot).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列出的每个示例，我确保我在一个目录中，该目录解析为WSL中的一个文件，并且每次Notepad启动时，示例文件都会被打开，即使参数直接传递给Notepad而不进行转换（如*图5.3*中的截图所示）。
- en: 'The fact that this works is very helpful to us as WSL users, but while this
    *just works* in this scenario, and most others, understanding why it works is
    useful for the occasions when it doesn''t. That way, you know when you might want
    to change the behavior – for example, when calling Windows scripts from WSL. So,
    if the paths aren''t being converted when the command is invoked, how did Notepad
    find `example.txt` in WSL? The first part of the answer is that when Notepad is
    launched by WSL, it has its working directory set to the `\\wsl$\...` path that
    corresponds to the current working directory for the terminal in WSL. We can confirm
    this behavior by running `powershell.exe ls`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作方式对于我们作为WSL用户非常有帮助，但是虽然在这种情况下它可以正常工作，以及大多数其他情况下，了解它为什么可以正常工作对于它无法正常工作的情况也是有用的。这样，您就知道何时可能需要更改行为，例如在从WSL调用Windows脚本时。那么，如果在调用命令时路径没有被转换，记事本是如何在WSL中找到`example.txt`的呢？答案的第一部分是，当WSL启动记事本时，它的工作目录被设置为与WSL终端的当前工作目录相对应的`\\wsl$\...`路径。我们可以通过运行`powershell.exe
    ls`来确认这种行为：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this output, you can see PowerShell launched from WSL listing the contents
    of its current working directory. The WSL shell has a working directory of `/home/stuart/wsl-book/chapter-05`
    and when PowerShell is launched, it gets the Windows equivalent, which is `\\wsl$\Ubuntu-20.04\home\stuart\wsl-book\chapter-05`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，您可以看到从WSL启动的PowerShell列出了其当前工作目录的内容。WSL shell的工作目录是`/home/stuart/wsl-book/chapter-05`，当启动PowerShell时，它会得到Windows的等效路径，即`\\wsl$\Ubuntu-20.04\home\stuart\wsl-book\chapter-05`。
- en: Now that we know that Notepad starts with its working directory based on the
    WSL working directory, we can see that in the first two of our examples (`notepad.exe
    example.txt` and `notepad.exe ../chapter-05/example.txt`), Notepad has treated
    the paths as relative paths and resolved them against its working directory to
    find the file.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道记事本的工作目录是基于WSL工作目录的，我们可以看到在我们的前两个示例（`notepad.exe example.txt`和`notepad.exe
    ../chapter-05/example.txt`）中，记事本将路径视为相对路径，并根据其工作目录解析它们以找到文件。
- en: The last example (`notepad.exe /home/stuart/wsl-book/chapter-05/example.txt`)
    is slightly different. In this case, Notepad resolves the path as a root-relative
    path. If Notepad had a working directory of `C:\some\folder`, then it would resolve
    the path as relative to the root of its working directory (`C:\`) and result in
    the path `C:\home\stuart\wsl-book\chapter-05\example.txt`. However, since we launched
    Notepad from WSL, it has a working directory of `\\wsl$\Ubuntu-20.04\home\stuart\wsl-book\chapter-05`,
    which is a UNC path, and so the root is considered to be `\\wsl$\Ubuntu-20.04`.
    This works out very well as that maps to the root of the `Ubuntu-20.04` distro's
    file system so adding the Linux absolute path to it generates the intended path!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例（`notepad.exe /home/stuart/wsl-book/chapter-05/example.txt`）略有不同。在这种情况下，记事本将路径解析为根相对路径。如果记事本的工作目录是`C:\some\folder`，那么它将将路径解析为相对于其工作目录的根目录（`C:\`），并生成路径`C:\home\stuart\wsl-book\chapter-05\example.txt`。然而，由于我们是从WSL启动记事本的，它的工作目录是`\\wsl$\Ubuntu-20.04\home\stuart\wsl-book\chapter-05`，这是一个UNC路径，因此根被认为是`\\wsl$\Ubuntu-20.04`。这非常好，因为它映射到`Ubuntu-20.04`发行版文件系统的根目录，所以将Linux绝对路径添加到它上面生成了预期的路径！
- en: This mapping is very productive and works most of the time, but in the previous
    section, we saw that `wslview ~/my-text-file.txt` doesn't work. We have another
    utility that we can use when we need to control the path mapping ourselves, and
    we will look at that next.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种映射非常高效，大部分情况下都能正常工作，但在前面的部分中，我们看到`wslview ~/my-text-file.txt`无法正常工作。当我们需要自己控制路径映射时，我们有另一个工具可以使用，接下来我们将看看它。
- en: Introducing wslpath
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍wslpath
- en: 'The `wslpath` utility can be used to translate between Windows paths and Linux
    paths. For example, to convert from a WSL path to a Windows path, we can run the
    following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`wslpath`实用程序可用于在Windows路径和Linux路径之间进行转换。例如，要将WSL路径转换为Windows路径，我们可以运行以下命令：'
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This output shows that `wslpath` returned the `\\wsl$\...` path for the WSL
    path we passed as an argument.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示`wslpath`返回了我们作为参数传递的WSL路径的`\\wsl$\...`路径。
- en: 'We can also use `wslpath` to convert paths in the opposite direction:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`wslpath`将路径转换为相反的方向：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we can see that the `\\wsl$\...` path has been translated back to the
    WSL path.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`\\wsl$\...`路径已经被转换回WSL路径。
- en: Important note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When specifying Windows paths in Bash, you must either escape them or surround
    the path with single quotes to avoid the need to escape them. The same applies
    to the dollar sign in `\\wsl$\...` paths.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bash中指定Windows路径时，您必须对它们进行转义或用单引号括起来，以避免需要转义。对于`\\wsl$\...`路径中的美元符号也是如此。
- en: 'In the preceding examples, we were working with paths to files in the WSL file
    system, but `wslpath` works just as well with paths from the Windows file system:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用的是WSL文件系统中的文件路径，但`wslpath`同样适用于Windows文件系统中的路径：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this output, you can see `wslpath` translating a path in the Windows file
    system to the `/mnt/…` path and back again.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个输出中，您可以看到`wslpath`将Windows文件系统中的路径转换为`/mnt/...`路径，然后再转换回来。
- en: Now that we've seen how `wslpath` works, let's look at a couple of examples
    of using it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了`wslpath`的工作原理，让我们来看几个使用它的示例。
- en: wslpath in action
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: wslpath的使用
- en: 'Earlier in the chapter, we saw the handy `wslview` utility, but observed that
    it only handles relative WSL paths, so we can''t use `wslview /home/stuart/my-text-file.txt`.
    But `wslview` does work with Windows paths, and we can use `wslpath` to take advantage
    of this. For example, `wslview $(wslpath -w /home/stuart/my-text-file.txt)` will
    use `wslpath` to convert the path into the corresponding Windows path, and then
    call `wslview` with that value. We can wrap all that into a function for ease
    of use:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早些时候，我们看到了方便的`wslview`实用程序，但观察到它只处理相对的WSL路径，因此我们不能使用`wslview /home/stuart/my-text-file.txt`。但是`wslview`可以使用Windows路径，并且我们可以利用`wslpath`来实现这一点。例如，`wslview
    $(wslpath -w /home/stuart/my-text-file.txt)`将使用`wslpath`将路径转换为相应的Windows路径，然后使用该值调用`wslview`。我们可以将所有这些封装到一个函数中以便使用：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, a `wslvieww` function is created in Bash (the extra `w` is
    for Windows), but you can pick another name if you prefer. The new function is
    then called in the same way as `wslview`, but this time performs the path mapping,
    and Windows is able to resolve the mapped path and load it in the text editor.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，使用Bash创建了一个名为`wslvieww`的函数（额外的`w`是为了Windows），但如果您愿意，可以选择其他名称。然后，以与`wslview`相同的方式调用新函数，但这次执行路径映射，Windows能够解析映射的路径并在文本编辑器中加载它。
- en: 'Another example we''ve seen where we could use `wslpath` is for creating the
    symlink to the Windows `Downloads` folder in our Linux `home` folder. The command
    given earlier in the chapter required you to edit the command to put the appropriate
    path into your Windows user profile. The following set of commands will do this
    without modification:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的另一个可以使用`wslpath`的示例是在Linux的`home`文件夹中创建指向Windows的`Downloads`文件夹的符号链接。本章前面给出的命令要求您编辑命令以将适当的路径放入Windows用户配置文件中。以下一组命令将在不修改的情况下执行此操作：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These commands show calling into Windows to get the `USERPROFILE` environment
    variable and then converting that with `wslpath` to get the `/mnt/…` path. Finally,
    that is combined with the `Downloads` folder and passed to `ln` to create the
    symlink.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令显示了调用Windows以获取`USERPROFILE`环境变量，然后使用`wslpath`将其转换为`/mnt/…`路径。最后，将其与`Downloads`文件夹组合，并传递给`ln`以创建符号链接。
- en: These are just a couple of examples of how `wslpath` can be used to get complete
    control over converting paths between Windows and WSL file systems. Most of the
    time, this isn't needed, but knowing it exists (and how to use it) can help keep
    you productively working with files in WSL.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是`wslpath`用于在Windows和WSL文件系统之间转换路径时的一些示例。大多数情况下，这是不需要的，但了解它的存在（以及如何使用它）可以帮助您在WSL中高效地处理文件。
- en: The final tip we'll look at is sharing SSH keys between Windows and WSL distros.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一下如何在Windows和WSL发行版之间共享SSH密钥的最后一个提示。
- en: SSH agent forwarding
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSH代理转发
- en: When connecting to remote machines using SSH, it is common to use SSH authentication
    keys. SSH keys can also be used to authenticate to other services – for example,
    when pushing source code changes to GitHub via `git`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用SSH连接远程机器时，通常会使用SSH身份验证密钥。SSH密钥也可以用于身份验证其他服务，例如通过`git`将源代码更改推送到GitHub。
- en: This section will walk you through configuring OpenSSH Authentication Agent
    for use in WSL distros. It is assumed that you already have SSH keys and a machine
    to connect to.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将指导您配置用于WSL发行版的OpenSSH身份验证代理。假设您已经拥有SSH密钥和一台要连接的机器。
- en: Tip
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you don''t have SSH keys, the OpenSSH docs walks through how to create them:
    [https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_keymanagement](https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_keymanagement).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有SSH密钥，可以参考OpenSSH文档中的创建方法：[https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_keymanagement](https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_keymanagement)。
- en: 'If you don''t have a machine to connect to, the Azure docs will help you create
    a virtual machine with SSH access (which you can do with a free trial): [https://docs.microsoft.com/en-us/azure/virtual-machines/linux/ssh-from-windows#provide-an-ssh-public-key-when-deploying-a-vm](https://docs.microsoft.com/en-us/azure/virtual-machines/linux/ssh-from-windows#provide-an-ssh-public-key-when-deploying-a-vm).'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有要连接的机器，Azure文档将帮助您创建具有SSH访问权限的虚拟机（您可以使用免费试用版进行操作）：[https://docs.microsoft.com/en-us/azure/virtual-machines/linux/ssh-from-windows#provide-an-ssh-public-key-when-deploying-a-vm](https://docs.microsoft.com/en-us/azure/virtual-machines/linux/ssh-from-windows#provide-an-ssh-public-key-when-deploying-a-vm)。
- en: If you are using your SSH keys in Windows and one or more WSL distros, you *could*
    copy the SSH keys each time. An alternative is to set up **OpenSSH Authentication
    Agent** in Windows and then configure the WSL distros to use that to get the keys.
    This means that you only have one place to manage your SSH keys and one place
    to enter SSH key passphrases (assuming you are using them).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows和一个或多个WSL发行版中使用SSH密钥，您可以每次复制SSH密钥。另一种选择是在Windows中设置**OpenSSH身份验证代理**，然后配置WSL发行版以使用该代理获取密钥。这意味着您只需要管理一个地方的SSH密钥，并且只需要在一个地方输入SSH密钥的密码（假设您正在使用密码）。
- en: Let's get started with the Windows OpenSSH Authentication Agent.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用Windows的OpenSSH身份验证代理。
- en: Ensuring Windows' OpenSSH Authentication Agent is running
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保Windows的OpenSSH身份验证代理正在运行
- en: 'The first step of setting this up is to ensure that Windows'' OpenSSH Authentication
    Agent is running. To do this, open the **Services** app in Windows and scroll
    down to **OpenSSH Authentication Agent**. If it is not showing as **Running**,
    then right-click and choose **Properties**. In the dialog that opens, ensure it
    has the following settings:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 设置的第一步是确保Windows的OpenSSH身份验证代理正在运行。为此，请在Windows中打开**服务**应用程序，并向下滚动到**OpenSSH身份验证代理**。如果它显示为**正在运行**，则右键单击并选择**属性**。在打开的对话框中，确保具有以下设置：
- en: '**Startup Type** is **Automatic**.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启动类型**为**自动**。'
- en: '**Service Status** is **Running** (click the **Start** button if not).'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务状态**为**正在运行**（如果没有，请点击**启动**按钮）。'
- en: Now, you can use `ssh-add` to add your keys to the agent – for example, `ssh-add
    ~/.ssh/id_rsa`. If you have a passphrase for your SSH key, you will be prompted
    to enter it. If you get an error that `ssh-add` is not found, then install the
    OpenSSH client using the instructions at [https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse](https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`ssh-add`将您的密钥添加到代理中 - 例如，`ssh-add ~/.ssh/id_rsa`。如果您的SSH密钥有密码短语，您将被提示输入密码。如果出现找不到`ssh-add`的错误，则使用以下说明安装OpenSSH客户端：[https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse](https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse)。
- en: 'To check that the key has been added correctly, try running `ssh` from Windows
    to connect to your remote machine:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查密钥是否已正确添加，请尝试从Windows运行`ssh`以连接到远程机器：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this output, you can see `ssh` running and successfully connecting to a remote
    machine.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在此输出中，您可以看到`ssh`正在运行并成功连接到远程机器。
- en: Tip
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you have configured your SSH keys to be used to authenticate with GitHub,
    you can use `ssh -T git@github.com` to test your connection. Full details for
    using SSH keys with GitHub can be found at [https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh](https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经配置了SSH密钥用于与GitHub进行身份验证，您可以使用`ssh -T git@github.com`来测试您的连接。有关在GitHub上使用SSH密钥的完整详细信息，请访问[https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh](https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh)。
- en: To tell Git to use `GIT_SSH` environment variable to `C:\Windows\System32\OpenSSH\ssh.exe`
    (or whatever path it is installed to if your Windows folder is different).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉Git使用`GIT_SSH`环境变量为`C:\Windows\System32\OpenSSH\ssh.exe`（或者如果您的Windows文件夹不同，则为安装路径）。
- en: The steps so far have configured OpenSSH Authentication Agent with our SSH keys
    in Windows. If we have passphrases for our keys, this will avoid us being prompted
    for them each time they are used. Next, we will set up access to these keys from
    WSL.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在Windows中配置了OpenSSH身份验证代理，并使用了我们的SSH密钥。如果我们的密钥有密码短语，这将避免我们每次使用它们时都被提示输入密码。接下来，我们将设置从WSL访问这些密钥。
- en: Configuring access to the Windows SSH keys from WSL
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从WSL配置访问Windows SSH密钥
- en: Now that we have the key working in Windows, we want to set up our Linux distribution
    in WSL to connect to Windows' OpenSSH Authentication Agent. The Linux `ssh` client
    has the `SSH_AUTH_SOCK` environment variable, which allows you to provide a socket
    for `ssh` to connect to when it retrieves SSH keys. The challenge is that OpenSSH
    Authentication Agent allows connections via Windows-named pipes, rather than sockets
    (not to mention being a separate machine).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在Windows中使密钥工作，我们希望在WSL中设置我们的Linux发行版以连接到Windows的OpenSSH身份验证代理。Linux `ssh`客户端具有`SSH_AUTH_SOCK`环境变量，允许您在检索SSH密钥时提供一个套接字供`ssh`连接。挑战在于OpenSSH身份验证代理允许通过Windows命名管道进行连接，而不是套接字（更不用说是一个单独的机器了）。
- en: 'To connect the Linux socket to the Windows-named pipe, we will use a couple
    of utilities: `socat` and `npiperelay`. The `socat` utility is a powerful Linux
    tool that can relay streams between different locations. We will use it to listen
    on the `SSH_AUTH_SOCK` socket and forward to a command that it executes. That
    command will be the `npiperelay` utility (written by John Starks, a developer
    on the Windows team doing cool stuff with Linux and containers), which will forward
    its input to a named pipe.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将Linux套接字连接到Windows命名管道，我们将使用两个实用程序：`socat`和`npiperelay`。`socat`实用程序是一个强大的Linux工具，可以在不同位置之间中继流。我们将使用它来监听`SSH_AUTH_SOCK`套接字并转发到一个它执行的命令。该命令将是`npiperelay`实用程序（由Windows团队的开发人员John
    Starks编写，他在Linux和容器方面做了很酷的工作），它将将其输入转发到一个命名管道。
- en: To install `npiperelay`, get the latest release from GitHub ([https://github.com/jstarks/npiperelay/releases/latest](https://github.com/jstarks/npiperelay/releases/latest))
    and extract `npiperelay.exe` to a location in your path. To install `socat`, run
    `sudo apt install socat`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`npiperelay`，请从GitHub获取最新版本（[https://github.com/jstarks/npiperelay/releases/latest](https://github.com/jstarks/npiperelay/releases/latest)）并将`npiperelay.exe`提取到您的路径中的位置。要安装`socat`，请运行`sudo
    apt install socat`。
- en: 'To start forwarding SSH key requests, run the following commands in WSL:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始转发SSH密钥请求，请在WSL中运行以下命令：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first line sets the `SSH_AUTH_SOCK` environment variable. The second line
    runs `socat` and tells it to listen on the `SSH_AUTH_SOCK` socket and relay that
    to `npiperelay`. The `npiperelay` command line tells it to listen and forward
    its input to the `//./pipe/openssh-ssh-agent` named pipe.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行设置了`SSH_AUTH_SOCK`环境变量。第二行运行`socat`并告诉它监听`SSH_AUTH_SOCK`套接字并将其中继到`npiperelay`。`npiperelay`命令行告诉它监听并将其输入转发到`//./pipe/openssh-ssh-agent`命名管道。
- en: 'With this in place, you can now run `ssh` in your WSL distribution:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，您现在可以在WSL发行版中运行`ssh`：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This output shows successfully running `ssh` in a WSL distribution. We can
    verify that the keys have been loaded from Windows by running `ssh` with the `-v`
    (verbose) switch:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示在WSL发行版中成功运行`ssh`。我们可以通过使用`-v`（详细）开关运行`ssh`来验证密钥是否已从Windows加载：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The full verbose output is rather long, but in this snippet of it, we can see
    the keys that `ssh` used to make the connection. Notice that the paths are the
    Windows paths, showing that the keys were loaded via the Windows OpenSSH agent.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的详细输出非常长，但在其中的这个片段中，我们可以看到`ssh`用于建立连接的密钥。请注意，路径是Windows路径，显示密钥是通过Windows OpenSSH代理加载的。
- en: 'The commands we ran earlier to start `socat` have enabled us to test this scenario,
    but you will likely want to have the SSH key requests forwarded automatically,
    rather than needing to run the commands with each new terminal session. To achieve
    this, add the following lines to your `.bash_profile` file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前运行的命令启动了`socat`，使我们能够测试这种情况，但您可能希望自动转发SSH密钥请求，而不需要在每个新的终端会话中运行这些命令。为了实现这一点，请将以下行添加到您的`.bash_profile`文件中：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The essence of these commands is the same as the original `socat` command, but
    adds error checking, tests whether the `socat` command is already running before
    starting it, and allows it to persist across terminal sessions.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令的本质与原始的`socat`命令相同，但增加了错误检查，在启动之前测试`socat`命令是否已经运行，并允许它在终端会话之间持久存在。
- en: With this in place, you can have one place to manage your SSH keys and passphrases
    (Window's OpenSSH Authentication Agent) and seamlessly share your SSH keys with
    your WSL distributions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，您可以有一个地方来管理您的SSH密钥和密码短语（Windows的OpenSSH身份验证代理），并无缝共享您的SSH密钥与您的WSL发行版。
- en: 'Additionally, the technique of forwarding a Linux socket to a Windows-named
    pipe can be used in other situations. Check out the `npiperelay` docs for more
    examples, including connecting to a MySQL service in Windows from Linux: [https://github.com/jstarks/npiperelay](https://github.com/jstarks/npiperelay).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将Linux套接字转发到Windows命名管道的技术可以在其他情况下使用。请查看`npiperelay`文档以获取更多示例，包括从Linux连接到Windows中的MySQL服务：[https://github.com/jstarks/npiperelay](https://github.com/jstarks/npiperelay)。
- en: In this tips-and-tricks section, you've seen a range of examples that illustrate
    techniques for bridging WSL and Windows, from creating command aliases to sharing
    SSH keys. While the examples are intended to be useful as is, the techniques behind
    them are generalizable. For example, the SSH key sharing example shows how to
    use a couple of tools to enable bridging between Linux sockets and Windows-named
    pipes, and could be used in other scenarios.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技巧和窍门的部分，您已经看到了一系列示例，说明了在WSL和Windows之间桥接的技术，从创建命令别名到共享SSH密钥。虽然这些示例的目的是直接使用，但它们背后的技术是可推广的。例如，SSH密钥共享示例展示了如何使用一些工具来实现Linux套接字和Windows命名管道之间的桥接，并可以在其他场景中使用。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have seen how to access files in the Windows file system
    from WSL distributions, and how to launch Windows applications from Linux, including
    using the `wlsview` utility to easily launch the default Windows application for
    a file. You've learned how to pipe input between Windows and Linux scripts, including
    how to map paths between the two file system schemes using `wslpath` when required.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了如何从WSL发行版访问Windows文件系统中的文件，以及如何从Linux启动Windows应用程序，包括使用`wlsview`实用程序轻松启动文件的默认Windows应用程序。您已经学会了如何在Windows和Linux脚本之间传递输入，包括在需要时如何使用`wslpath`映射两个文件系统方案之间的路径。
- en: At the end of the chapter, you saw how to map from Linux sockets to Windows-named
    pipes, and used this technique to make your Windows SSH keys available in WSL.
    This allows you to avoid copying your SSH keys into each WSL distribution and
    instead manage your SSH keys and passphrases in a single, shared place, making
    it easier to control and back up your SSH keys.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的结尾，您了解了如何将Linux套接字映射到Windows命名管道，并使用此技术使您的Windows SSH密钥在WSL中可用。这使您可以避免将SSH密钥复制到每个WSL发行版中，而是在一个共享的地方管理您的SSH密钥和密码短语，从而更容易控制和备份您的SSH密钥。
- en: All of this helps to bring Windows and Linux closer together with WSL and to
    drive greater productivity in your daily workflows.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都有助于通过WSL将Windows和Linux更紧密地联系在一起，并在您的日常工作流程中提高生产力。
- en: We've spent quite a lot of time in the terminal in this chapter. In the next
    chapter, we will revisit the Windows terminal and explore some more advanced ways
    to customize it to suit your needs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在终端上花了相当多的时间。在下一章中，我们将重新访问Windows终端，并探索一些更高级的方法来自定义它以满足您的需求。
