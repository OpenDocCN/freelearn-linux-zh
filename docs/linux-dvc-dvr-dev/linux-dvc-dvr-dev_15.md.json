["```\nstruct gpio_chip { \n  const char *label; \n  struct device *dev; \n  struct module *owner; \n\n  int (*request)(struct gpio_chip *chip, unsigned offset); \n  void (*free)(struct gpio_chip *chip, unsigned offset); \n  int (*get_direction)(struct gpio_chip *chip, unsigned offset); \n  int (*direction_input)(struct gpio_chip *chip, unsigned offset); \n  int (*direction_output)(struct gpio_chip *chip, unsigned offset, \n\n            int value); \n  int (*get)(struct gpio_chip *chip,unsigned offset); \n  void (*set)(struct gpio_chip *chip, unsigned offset, int value); \n  void (*set_multiple)(struct gpio_chip *chip, unsigned long *mask, \n            unsigned long *bits); \n  int (*set_debounce)(struct gpio_chip *chip, unsigned offset, \n            unsigned debounce); \n\n  int (*to_irq)(struct gpio_chip *chip, unsigned offset); \n\n  int base; \n  u16 ngpio; \n  const char *const *names; \n  bool can_sleep; \n  bool irq_not_threaded; \n  bool exported; \n\n#ifdef CONFIG_GPIOLIB_IRQCHIP \n  /* \n   * With CONFIG_GPIOLIB_IRQCHIP we get an irqchip \n    * inside the gpiolib to handle IRQs for most practical cases. \n   */ \n  struct irq_chip *irqchip; \n  struct irq_domain *irqdomain; \n  unsigned int irq_base; \n  irq_flow_handler_t  irq_handler; \n  unsigned int irq_default_type; \n#endif \n\n#if defined(CONFIG_OF_GPIO) \n  /* \n   * If CONFIG_OF is enabled, then all GPIO controllers described in the \n   * device tree automatically may have an OF translation \n   */ \n  struct device_node *of_node; \n  int of_gpio_n_cells; \n  int (*of_xlate)(struct gpio_chip *gc, \n      const struct of_phandle_args *gpiospec, u32 *flags); \n} \n```", "```\n static void gpio_chip_set_multiple(struct gpio_chip *chip, \n      unsigned long *mask, unsigned long *bits) \n{ \n  if (chip->set_multiple) { \n    chip->set_multiple(chip, mask, bits); \n  } else { \n    unsigned int i; \n\n    /* set outputs if the corresponding mask bit is set */ \n    for_each_set_bit(i, mask, chip->ngpio) \n      chip->set(chip, i, test_bit(i, bits)); \n  } \n} \n```", "```\n#include <linux/gpio.h>  \n```", "```\n#define GPIO_NUM 16 \nstruct mcp23016 { \n  struct i2c_client *client; \n  struct gpio_chip chip; \n}; \n\nstatic int mcp23016_probe(struct i2c_client *client, \n          const struct i2c_device_id *id) \n{ \n  struct mcp23016 *mcp; \n\n  if (!i2c_check_functionality(client->adapter, \n      I2C_FUNC_SMBUS_BYTE_DATA)) \n    return -EIO; \n\n  mcp = devm_kzalloc(&client->dev, sizeof(*mcp), GFP_KERNEL); \n  if (!mcp) \n    return -ENOMEM; \n\n  mcp->chip.label = client->name; \n  mcp->chip.base = -1; \n  mcp->chip.dev = &client->dev; \n  mcp->chip.owner = THIS_MODULE; \n  mcp->chip.ngpio = GPIO_NUM; /* 16 */ \n  mcp->chip.can_sleep = 1; /* may not be accessed from actomic context */ \n  mcp->chip.get = mcp23016_get_value; \n  mcp->chip.set = mcp23016_set_value; \n  mcp->chip.direction_output = mcp23016_direction_output; \n  mcp->chip.direction_input = mcp23016_direction_input; \n  mcp->client = client; \n  i2c_set_clientdata(client, mcp); \n\n  return gpiochip_add(&mcp->chip); \n} \n```", "```\nstruct gpio_desc *gpiochip_request_own_desc(struct gpio_desc *desc, const char *label) \nvoid gpiochip_free_own_desc(struct gpio_desc *desc) \n```", "```\nexpander_1: mcp23016@27 { \n    compatible = \"microchip,mcp23016\"; \n    interrupt-controller; \n    gpio-controller; \n    #gpio-cells = <2>; \n    interrupt-parent = <&gpio6>; \n    interrupts = <31 IRQ_TYPE_LEVEL_LOW>; \n    reg = <0x27>; \n    #interrupt-cells=<2>; \n}; \n```"]