- en: Conditional Testing and Scripting Loops
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件测试和脚本循环
- en: This chapter will begin with a recap on `if-then-else`, before presenting advanced
    uses of `if-then-else` conditionals. We will introduce scripting loops in the
    form of `while` and `for`, and we will show how we can control these loops with
    `exit`, `break`, and `continue`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将以对`if-then-else`的小结开始，然后介绍`if-then-else`条件的高级用法。我们将介绍`while`和`for`的脚本循环，并展示如何使用`exit`，`break`和`continue`来控制这些循环。
- en: 'The following commands will be introduced in this chapter: `elif`, `help`,  `while`,
    `sleep`, `for`, `basename`, `break`, and `continue`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下命令：`elif`，`help`，`while`，`sleep`，`for`，`basename`，`break`和`continue`。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Advanced `if-then-else`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级`if-then-else`
- en: The `while` loop
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: The `for` loop
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环'
- en: The `loop` control
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loop` 控制'
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All scripts for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter11](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter11).
    All other tools are still valid, both on your host machine as well as on your
    Ubuntu virtual machine. For the break-x.sh, for-globbing.sh, square-number.sh, while-interactive.sh
    scripts only the final version is found online. Be sure to verify the script version
    in the header before executing it on your system.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有脚本都可以在GitHub上找到：[https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter11](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter11)。所有其他工具仍然有效，无论是在您的主机上还是在您的Ubuntu虚拟机上。对于break-x.sh，for-globbing.sh，square-number.sh，while-interactive.sh脚本，只能在网上找到最终版本。在执行脚本之前，请务必验证头部中的脚本版本。
- en: Advanced if-then-else
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级if-then-else
- en: This chapter is dedicated to everything to do with conditional testing and scripting
    loops, which are two concepts that are often intertwined. We have already seen
    the `if-then-else` loop in [Chapter 9](125f46ad-bffc-4bf6-86e7-ae6a2ca47bb6.xhtml),
    *Error Checking and Handling*, which focused on error checking and handling. We'll
    present a small recap of the things we've described regarding `if-then-else`,
    before moving on to advanced concepts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于条件测试和脚本循环的所有内容，这两个概念经常交织在一起。我们已经在[第9章](125f46ad-bffc-4bf6-86e7-ae6a2ca47bb6.xhtml)中看到了`if-then-else`循环，*错误检查和处理*，它侧重于错误检查和处理。在继续介绍高级概念之前，我们将对我们描述的关于`if-then-else`的事情进行小结。
- en: A recap on if-then-else
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对if-then-else的小结
- en: '`If-then-else` logic does almost exactly what the name implies: **if** *something-is-the-case*,
    **then** *do-something* or **else** *do-something-else*. In practice, this could
    be **if** *the disk is full*, **then** *delete some files* or **else** *report
    that the disk space looks great*. In a script, this could look something like
    this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`If-then-else` 逻辑几乎完全符合其名称的含义：**如果** *某事是这样的*，**那么** *做某事* 或 **否则** *做其他事情*。在实践中，这可能是**如果**
    *磁盘已满*，**那么** *删除一些文件* 或 **否则** *报告磁盘空间看起来很好*。在脚本中，这可能看起来像这样：'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If a file exists, we print the contents. Otherwise (so, if the file does not
    exist), we give the user feedback in the form of the error message, then we exit
    the script with an exit status of `1`. Remember, any exit code that is not 0 signifies
    a *script failure*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件存在，我们打印内容。否则（也就是说，如果文件不存在），我们以错误消息的形式给用户反馈，然后以`1`的退出状态退出脚本。请记住，任何不为0的退出代码都表示*脚本失败*。
- en: Using regular expressions in tests
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在测试中使用正则表达式
- en: 'A chapter after introducing `if-then-else`, we learned all about regular expressions.
    That chapter, however, was mostly theoretical and only contained a single script!
    Now, as you might realize, regular expressions are mostly supporting constructs
    that are to be used with other scripting tools. In the case of the tests we have
    described, we can use both globbing and regular expressions within the `[[...]]`
    blocks! Let''s look at this in more depth, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了`if-then-else`之后的一章中，我们学到了关于正则表达式的一切。然而，那一章大部分是理论性的，只包含了一个脚本！现在，正如你可能意识到的那样，正则表达式主要是支持构造，应该与其他脚本工具一起使用。在我们描述的测试情况下，我们可以在`[[...]]`块中同时使用globbing和正则表达式！让我们更深入地看一下这一点，如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We first check if the user supplied the correct number of arguments (which is
    what we should always do). Next, we use the `=~` operator within the test `[[..]]`
    block. This allows us to **evaluate using regular expressions**. In this case,
    it simply allows us to verify that the user input is a number, and not anything
    else.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查用户是否提供了正确数量的参数（这是我们应该始终做的）。接下来，我们在测试`[[..]]`块中使用`=~`运算符。这允许我们**使用正则表达式进行评估**。在这种情况下，它简单地允许我们验证用户输入是否为数字，而不是其他任何东西。
- en: 'Now, if we call this script, we will see the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们调用这个脚本，我们会看到以下内容：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can see that both of our input checks work. If we call this script without
    exactly one argument (`$# -ne 1`), it fails. This is true for both `0` and `2`
    arguments. Next, if we call the script with a letter instead of a number, we get
    to the second check and the consequent error message: `wrong type of argument`.
    Finally, to prove that the script actually does what we want, we will try it with
    single number: `3` and `11`. The returns of `9` and `121` are the squares of these
    numbers, so it seems we achieved our goal!'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的两个输入检查都有效。如果我们调用这个脚本而不是只有一个参数(`$# -ne 1`)，它会失败。这对于`0`和`2`个参数都是正确的。接下来，如果我们用一个字母而不是一个数字来调用脚本，我们会到达第二个检查和随之而来的错误消息：`错误的参数类型`。最后，为了证明脚本确实做到了我们想要的，我们将尝试使用单个数字：`3`和`11`。`9`和`121`的返回值是这些数字的平方，所以看起来我们实现了我们的目标！
- en: 'However, not everything is always as it seems. This is a common pitfall when
    using regular expressions, as the following code should illustrate:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并不是一切都如表面所示。这是使用正则表达式时的一个常见陷阱，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'How did this happen? We checked to see if the user input was a number, did
    we not? Actually, contrary to what you might think, we actually checked if the
    user input *matched positively against a number*. To say this in simpler terms,
    if the input contains a number, the check succeeds. What we really want to check
    is if the input is a number *from the beginning to the end*. Perhaps this sounds
    familiar, but it definitely smells like line anchors! The following code applies
    this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是怎么发生的？我们检查了用户输入是否是一个数字，不是吗？实际上，与你可能认为的相反，我们实际上检查了用户输入是否“与数字匹配”。简单来说，如果输入包含一个数字，检查就会成功。我们真正想要检查的是输入是否是一个数字“从头到尾”。也许这听起来很熟悉，但它绝对有锚定行的味道！以下代码应用了这一点：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We made two changes: the search pattern we''re matching against is no longer
    just `[[:digit:]]`, but `^[[:digit:]]$`, and we updated the version number (something
    we haven''t done too much up until now). Because we are now anchoring the digit
    to both the beginning and the end of the line, we can no longer inject a letter
    in a random spot. Run the script with incorrect input to verify this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了两个改变：我们匹配的搜索模式不再只是`[[:digit:]]`，而是`^[[:digit:]]$`，并且我们更新了版本号（直到现在我们还没有做太多）。因为我们现在将数字锚定到行的开头和结尾，我们不能再在随机位置插入字母。用错误的输入运行脚本来验证这一点：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'I would love to tell you that we''re now perfectly safe. But, alas, as it often
    is with regular expressions, it''s not that simple. The script now works great
    for a single number (0–9), but if you try it with a double-digit number, it fails
    with `wrong type of argument error` (try it out!). We need one final tweak to
    make sure it does exactly what we want: we need to make sure that the digit also
    accepts multiple sequential digits. The *one or more* construct in regular expressions
    is the + sign, which we can just append to `[[:digit:]]`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我很想告诉你，我们现在完全安全了。但是，不幸的是，就像正则表达式经常出现的那样，事情并不那么简单。脚本现在对单个数字（0-9）运行得很好，但是如果你尝试使用双位数，它会出现“错误的参数类型”（试一下！）。我们需要做最后的调整来确保它完全符合我们的要求：我们需要确保数字也接受多个连续的数字。正则表达式中的“一个或多个”构造是+号，我们可以将其附加到`[[:digit:]]`上：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We changed the pattern, upped the version number, and ran the script with different
    inputs. The final pattern of `^[[:digit:]]+$` can be read as *one or more digits
    from the start to the end of the line*, which, in this case, means *a number,
    and nothing else*!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改变了模式，提高了版本号，并用不同的输入运行了脚本。最终的模式`^[[:digit:]]+$`可以解读为“从行首到行尾的一个或多个数字”，在这种情况下意味着“一个数字，没有其他东西”！
- en: The lesson here is that you really need to test your regular expressions thoroughly.
    As you know by now, search patterns are greedy, and as soon as a little bit matches,
    it considers the result a success. As seen in the previous example, this was not
    specific enough. The only way to implement (and learn!) this is by trying to break
    your own scripts. Try wrong input, weird input, very specific input, and so on.
    Unless you try a lot, you can't be sure that it will *probably* work.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是你确实需要彻底测试你的正则表达式。正如你现在所知道的，搜索模式是贪婪的，一旦有一点匹配，它就认为结果是成功的。就像前面的例子中所看到的那样，这并不够具体。实现（和学习！）的唯一方法是尝试破坏你自己的脚本。尝试错误的输入，奇怪的输入，非常具体的输入等等。除非你尝试很多次，否则你不能确定它会*可能*工作。
- en: 'You can use all regular expression search patterns in test syntax. Other examples
    that we will not flesh out, but should definitely be considered, are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在测试语法中使用所有正则表达式搜索模式。我们不会详细介绍其他例子，但应该考虑的有：
- en: The variable should start with a `/` (for a fully qualified path)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量应该以`/`开头（用于完全限定的路径）
- en: The variable cannot contain whitespace (using the `[[:blank:]]` search pattern)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量不能包含空格（使用`[[:blank:]]`搜索模式）
- en: The variable should contain only lowercase letters (achievable with the `^[[:lower:]]+$`
    pattern)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量应该只包含小写字母（可以通过`^[[:lower:]]+$`模式实现）
- en: The variable should contain a file name with an extension (can match on `[[:alnum:]]\.[[:alpha:]]`)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量应该包含一个带有扩展名的文件名（可以匹配`[[:alnum:]]\.[[:alpha:]]`）
- en: The elif condition
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: elif条件
- en: 'In the scenarios we''ve seen up until now, there was only ever the need to
    check for one *if* *condition*. But as you might expect, sometimes, there are
    multiple things that you want to check for, each with their own sets of following
    actions (*then* *block*). You could solve this by using two full `if-then-else`
    statements, but at the very least you''d have a duplicate *else* *block*. Even
    worse, if you have three or more conditions you want to check for, you''ll have
    more and more duplicate code! Luckily for us, we can solve this by using the `elif`
    command, which is part of the `if-then-else` logic. As you''ve probably guessed,
    `elif` is short for `else-if`. It allows us to do something like the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们到目前为止看到的情况中，只需要检查一个*if* *条件*。但是正如你所期望的那样，有时候有多个你想要检查的事情，每个事情都有自己的后续动作（*then*
    *block*）。你可以通过使用两个完整的`if-then-else`语句来解决这个问题，但至少你会有一个重复的*else* *block*。更糟糕的是，如果你有三个或更多的条件要检查，你将会有越来越多的重复代码！幸运的是，我们可以通过使用`elif`命令来解决这个问题，它是`if-then-else`逻辑的一部分。你可能已经猜到，`elif`是`else-if`的缩写。它允许我们做如下的事情：
- en: IF condition1, THEN do thing1, ELIF condition2, THEN do thing2, ELSE do final-thing
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件1，那么执行事情1，否则如果条件2，那么执行事情2，否则执行最终的事情
- en: 'You can chain as many `elif` commands after the initial `if` command as you
    want, but there is one important thing to consider: as soon as any condition is
    true, only that `then` statement is executed; all others are skipped.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在初始的`if`命令之后链接尽可能多的`elif`命令，但有一件重要的事情需要考虑：一旦任何条件为真，只有该`then`语句会被执行；其他所有语句都会被跳过。
- en: 'If you''re thinking of a situation in which multiple conditions can be true,
    and their `then` statements should be executed, you need to use multiple `if-then-else`
    blocks. Let''s look at a simple example that first checks if the argument given
    by the user is a file. If it is, we print the file using `cat`. If this is not
    the case, we check if it is a directory. Should this be the case, we list the
    directory with `ls`. If this is also not the case, we''ll print an error message
    and exit with a non-zero exit status. Look at the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在考虑多个条件可以为真，并且它们的`then`语句应该被执行，你需要使用多个`if-then-else`块。让我们看一个简单的例子，首先检查用户给出的参数是否是一个文件。如果是，我们使用`cat`打印文件。如果不是这种情况，我们检查它是否是一个目录。如果是这种情况，我们使用`ls`列出目录。如果也不是这种情况，我们将打印一个错误消息并以非零退出状态退出。看看以下命令：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, when we''re dealing with file input by users, we need extra
    sanitation. We make sure to set the current working directory in the script with
    `cd $(dirname $0)`, and we assume that every command can fail, so we handle these
    failures with the || construct, as explained in [Chapter 9](125f46ad-bffc-4bf6-86e7-ae6a2ca47bb6.xhtml),* Error
    Checking and Handling*. Let''s try and see if we can find most of the paths that
    this logic can take:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们处理用户输入的文件时，我们需要额外的净化。我们确保在脚本中设置当前工作目录为`cd $(dirname $0)`，并且我们假设每个命令都可能失败，因此我们使用||构造来处理这些失败，就像[第9章](125f46ad-bffc-4bf6-86e7-ae6a2ca47bb6.xhtml)中所解释的那样，*错误检查和处理*。让我们尝试看看我们是否可以找到这个逻辑可能走的大部分路径：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In order, we''ve seen the following scenarios for our script:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序，我们已经看到了我们脚本的以下场景：
- en: '**No argument**: `Incorrect usage` error'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**无参数**：`使用不正确`错误'
- en: '**File argument /etc/passwd**: File content printed'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: /etc/passwd文件参数：文件内容已打印
- en: '**File argument on non-readable file /etc/shadow**: `Cannot print file` error'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非可读文件/etc/shadow上的文件参数：`无法打印文件`错误
- en: '**Directory argument /tmp/**: List of directory printed'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: /tmp/上的目录参数：目录列表已打印
- en: '**Directory argument on non-listable directory /root/**: `Cannot list directory`
    error'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非可列出目录/root/上的目录参数：`无法列出目录`错误
- en: '**Special file (block device) argument /dev/zero**: `Path is neither a file
    nor a directory` error'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特殊文件（块设备）参数/dev/zero：`路径既不是文件也不是目录`错误
- en: These six input scenarios represent all of the possible paths our script can
    take. While you might have considered all of the error handling for a (seemingly
    simple) script a bit over the top, these arguments should validate why we actually
    need all of this error handling.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这六种输入场景代表了我们的脚本可能采取的所有可能路径。虽然你可能认为对于（看似简单的）脚本的所有错误处理有点过分，但这些参数应该验证了为什么我们实际上需要所有这些错误处理。
- en: While `elif` greatly enhances the possibilities of an `if-then-else` statement,
    too much `if-elif-elif-elif-`.......`-then-else` will make your script really
    hard to read. There is another construct (which is outside the scope of this book),
    called `case`. This deals with many different, unique conditions. Look at the
    further reading section at the end of this chapter for a good resource on `case`!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`elif`极大地增强了`if-then-else`语句的可能性，但太多的`if-elif-elif-elif-`.......`-then-else`将使你的脚本变得非常难以阅读。还有另一种构造（超出了本书的范围），叫做`case`。这处理许多不同的、独特的条件。在本章末尾的进一步阅读部分查看关于`case`的良好资源！
- en: Nesting
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套
- en: 'Another concept that is very interesting is nesting. In essence, nesting is
    really simple: it is placing another `if-then-else` statement within either the
    `then` or `else` of the *outer* `if-then-else`. This allows us to, for example,
    first determine if a file is readable, before determining what type of file it
    is. By using nested `if-then-else` statements, we can rewrite the previous code
    in such a way that we no longer need the || construct:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有趣的概念是嵌套。实质上，嵌套非常简单：就是在*外部*的`if-then-else`的`then`或`else`中放置另一个`if-then-else`语句。这使我们能够首先确定文件是否可读，然后确定文件的类型。通过使用嵌套的`if-then-else`语句，我们可以以不再需要||构造的方式重写先前的代码：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Try the preceding script with the same input as the previous example. In this
    case, you''ll see much nicer output in the error scenarios, since we now control
    those (instead of the default output of `cat: /etc/shadow: Permission denied`
    from `cat`, for example). Functionally, however, nothing has changed! We think
    that this script, which uses nesting, is more readable than the previous example,
    because we handle the error scenarios ourselves now instead of relying on the
    system commands to do it for us.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '尝试使用与前一个示例相同的输入运行上述脚本。在这种情况下，错误场景中的输出会更加友好，因为现在我们控制了这些（而不是默认输出`cat: /etc/shadow:
    Permission denied`，例如）。但从功能上讲，什么也没有改变！我们认为，这个使用嵌套的脚本比之前的例子更可读，因为我们现在自己处理错误场景，而不是依赖系统命令来为我们处理。'
- en: We've discussed indentation before, but in our opinion, scripts like this one
    are where it truly shines. By indenting the inner `if-then-else` statement, it
    is much more clear that the second `else` belongs to the outer `if-then-else`
    statement. If you're using multiple levels of indentation (because, in theory,
    you can nest as often as you'd like), it really helps everyone working on the
    script to follow this logic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过缩进，但在我们看来，像这样的脚本才是它真正发挥作用的地方。通过缩进内部的`if-then-else`语句，更清楚地表明第二个`else`属于外部的`if-then-else`语句。如果你使用多层缩进（因为理论上你可以嵌套多次），这确实有助于所有参与脚本编写的人遵循这个逻辑。
- en: Nesting is not just reserved for `if-then-else`. The two loops that we will
    introduce later in this chapter, `for` and `while`, can also be nested. And, what's
    even more practical, you can nest all of them within all of the others (from a
    technical perspective; it should make sense from a logical perspective as well,
    of course!). You will see examples of this when we explain `while` and `for` later.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套不仅仅适用于`if-then-else`。我们将在本章后面介绍的两个循环`for`和`while`也可以嵌套。而且，更实用的是，你可以将它们嵌套在其他所有循环中（从技术角度来看；当然，从逻辑角度来看也应该是有意义的！）。当我们解释`while`和`for`时，你会看到这样的例子。
- en: Getting help
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取帮助
- en: 'By now, you''re probably afraid that you''ll never remember all this. While
    we''re sure that in time, given enough practice, you most certainly will, we understand
    that it is a lot to take in when you''re not as experienced. To make this easier,
    there is another helpful command besides the `man` pages. As you might have found
    (and failed when you tried), `man if`, or `man [[`, do not work. If you check
    these commands with `type if` and `type [[`, you''ll actually see that they are
    not commands but *shell keywords*. For most of the shell builtins and shell keywords,
    you can use the `help` command to print some information on what they do and how
    to use them! Using `help` is as simple as `help if`, `help [[`, `help while`,
    and so on. For `if-then-else` statements, only `help if` works:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能害怕自己永远记不住所有这些。虽然我们确信随着时间的推移，通过足够的练习，你肯定会记住，但我们理解当你经验不足时，这是很多东西要消化的。为了让这更容易些，除了`man`页面之外还有另一个有用的命令。你可能已经发现（并且在尝试时失败了），`man
    if`或`man [[`都不起作用。如果你用`type if`和`type [[`检查这些命令，你会发现它们实际上不是命令而是*shell关键字*。对于大多数shell内置和shell关键字，你可以使用`help`命令打印一些关于它们的信息以及如何使用它们！使用`help`就像`help
    if`、`help [[`、`help while`等一样简单。对于`if-then-else`语句，只有`help if`有效：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So, overall, there are three ways to get Linux to print some helpful information
    for you:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的来说，有三种方法可以让Linux为你打印一些有用的信息：
- en: Man pages with the `man` command
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`man`命令的man页面
- en: Help information with the `help` command
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`help`命令获取帮助信息
- en: Command native help print (often as `flag -h`, `--help`, or `-help`)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令本地帮助打印（通常作为`flag -h`、`--help`或`-help`）
- en: Depending on the type of command (binary or shell builtin/keyword), you'll use
    either `man`, `help`, or the `--help` flag. Remember, by checking which type of
    command you're dealing with (so that you can make a more educated guess about
    which method of help you can try first), use `type -a <command>`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 根据命令的类型（二进制命令或shell内置/关键字），你将使用`man`、`help`或`--help`标志。记住，通过检查你正在处理的命令的类型（这样你就可以更加有根据地猜测首先尝试哪种帮助方法），使用`type
    -a <command>`。
- en: The while loop
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: 'Now that we''ve got the `if-then-else` recap and advanced usage out of the
    way, it is time to discuss the first scripting loop: `while`. Look at the following
    definition, which should seem familiar after `if-then-else`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经搞定了`if-then-else`的复习和高级用法，是时候讨论第一个脚本循环了：`while`。看一下下面的定义，在`if-then-else`之后应该看起来很熟悉：
- en: WHILE condition-is-true DO thing-to-do DONE
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件为真时执行的事情
- en: 'The biggest difference between `if` and `while` is that while will perform
    the action many times, so long as the condition specified is still true. Because
    it is often not needed to have an unending loop, the action will regularly mutate
    something related at the condition. This basically means that the action in *do*
    will eventually cause the while condition to be false instead of true. Let''s
    look at a simple example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`和`while`之间最大的区别是，`while`会执行动作多次，只要指定的条件仍然为真。因为通常不需要无休止地循环，动作将定期改变与条件相关的某些东西。这基本上意味着*do*中的动作最终会导致`while`条件变为false而不是true。让我们看一个简单的例子：'
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This example is the most basic form of while: an unending loop (because the
    condition is simply `true`) that prints a message and then sleeps for one second.
    This new command, `sleep`, is often used within loops (both `while` and `for`)
    to wait for a specified time. In this case, we run `sleep 1`, which waits a single
    second before going back to the top of the loop and printing `Hello!` again. Be
    sure to try it out and notice how it will never stop (*Ctrl* + *C* will, however,
    kill the process, since it''s interactive).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是`while`的最基本形式：一个无休止的循环（因为条件只是`true`），它打印一条消息，然后休眠一秒。这个新命令`sleep`经常在循环（`while`和`for`）中使用，等待指定的时间。在这种情况下，我们运行`sleep
    1`，它在返回循环顶部并再次打印`Hello!`之前等待一秒。一定要尝试一下，并注意它永远不会停止（*Ctrl* + *C*会杀死进程，因为它是交互式的）。
- en: 'Now we''ll create a script that will end at certain time. To do this, we''ll
    define a variable outside of the `while` loop, which we will use as a counter.
    This counter will be incremented at each run of the `while` loop, until the threshold
    defined in the condition is reached. Take a look:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个在特定时间结束的脚本。为此，我们将在`while`循环之外定义一个变量，我们将使用它作为计数器。这个计数器将在每次`while`循环运行时递增，直到达到条件中定义的阈值。看一下：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This script should be self-explanatory because of the comments we''ve added.
    `counter` is added outside the `while` loop, because otherwise every run of the
    loop would start with `counter=0`, which would reset the progress. As long as
    the counter is less than 10, we''ll keep running the loop. After 10 runs, this
    is no longer the case, and instead of going back in the loop, we''re going to
    the next instruction in the script, which is printing the goodbye message. Go
    ahead and run this script. Edit the number after sleep (hint: it also accepts
    values smaller than a second), or remove sleep altogether.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们添加了注释，这个脚本应该是不言自明的。`counter`被添加到`while`循环之外，否则每次循环运行都会以`counter=0`开始，这会重置进度。只要计数器小于10，我们就会继续运行循环。经过10次运行后，情况就不再是这样了，而是继续执行脚本中的下一条指令，即打印再见消息。继续运行这个脚本。编辑sleep后面的数字（提示：它也接受小于一秒的值），或者完全删除sleep。
- en: The until loop
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: until循环
- en: 'While has a twin: `until`. An `until` loop does exactly what while does, with
    only one difference: the loop only runs as long as the condition is **false**.
    As soon as the condition becomes **true**, the loop no longer runs. We''ll make
    some minor changes to the previous script and we''ll see how `until` works:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`有一个孪生兄弟：`until`。`until`循环与`while`做的事情完全相同，唯一的区别是：只有在条件为**false**时循环才会运行。一旦条件变为**true**，循环就不再运行。我们将对上一个脚本进行一些小修改，看看`until`是如何工作的：'
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the changes to this script are very minimal (but important,
    nonetheless). We replaced `while` with `until`, `-lt` with `-gt`, and `10` with
    `9`. Now, it reads `run the loop until the counter is greater than 9` as opposed
    to `run the loop as long as the counter is lower than 10`. Because we are using
    lower than and greater than, we have to change the number, otherwise we're going
    to experience the famous *off-by-one* error (which, in this case, means that we'll
    loop 11 times, should we not have changed the `10` to a `9`; try it!).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，对这个脚本的更改非常小（但重要，尽管如此）。我们用`until`替换了`while`，用`-gt`替换了`-lt`，用`9`替换了`10`。现在，它读作`当计数器大于9时运行循环`，而不是`只要计数器小于10时运行循环`。因为我们使用了小于和大于，我们必须改变数字，否则我们将会遇到著名的*off-by-one*错误（在这种情况下，这意味着我们将循环11次，如果我们没有将`10`改为`9`；试试看！）。
- en: 'In essence, the `while` and `until` loops are exactly the same. You will use
    a `while` loop more often than an until loop: since you can just negate the condition,
    a `while` loop will always work. However, sometimes, an `until` loop might *feel*
    more justified. In any case, use the one that is easiest to comprehend for the
    situation! When in doubt, just using `while` will hardly ever be wrong, as long
    as you get the condition right.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`while`和`until`循环是完全相同的。你会经常使用`while`循环而不是`until`循环：因为你可以简单地否定条件，`while`循环总是有效的。然而，有时，`until`循环可能更合理。无论如何，使用最容易理解的那个！如果有疑问，只使用`while`几乎永远不会错，只要你得到了正确的条件。
- en: Creating an interactive while loop
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个交互式while循环
- en: 'In reality, you will not use a `while` loop that often. In most scenarios,
    a `for` loop is better (as we will see later on in this chapter). There is, however,
    one situation where a `while` loop is excellent: dealing with user input. If you
    use the `while true` construct with an if-then-else block nesting within it, you
    can keep asking the user for input until you get the answer you''re looking for.
    The following example, which is a simple riddle, should clarify matters:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你不会经常使用`while`循环。在大多数情况下，`for`循环更好（正如我们将在本章后面看到的）。然而，有一种情况`while`循环非常适用：处理用户输入。如果你使用`while
    true`结构，并在其中嵌套if-then-else块，你可以不断地向用户询问输入，直到得到你要找的答案。下面的例子是一个简单的谜语，应该能澄清问题：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this script, we use `read -p` to ask the user a question, and we store the
    reply in the `answer` variable. We then use a nested if-then-else block to check
    if the user gave the correct answer. We use a simple regular expression if-condition,
    `${answer} =~ [Kk]eyboard`, which gives a little flexibility to the user with
    regards to capitals and perhaps the word `a` in front. For every incorrect answer,
    the *else* statement prints an error and the loop starts back at `read -p`. If
    the answer is correct, the *then* block is executed, which ends with `exit 0`
    to signify the end of the script. As long as the correct answer isn't given, the
    loop will go on forever.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们使用`read -p`来询问用户一个问题，并将回答存储在`answer`变量中。然后我们使用嵌套的if-then-else块来检查用户是否给出了正确的答案。我们使用一个简单的正则表达式if条件，`${answer}
    =~ [Kk]eyboard`，这给用户在大写字母和也许单词`a`前面有一点灵活性。对于每个不正确的答案，*else*语句打印一个错误，循环重新开始`read
    -p`。如果答案是正确的，*then*块被执行，以`exit 0`表示脚本的结束。只要没有给出正确的答案，循环将永远继续。
- en: You might see a problem with this script. If we wanted to do anything after
    the `while` loop, we'd need to *break* out of it without exiting the script. We
    will see how we can achieve this with the – wait for it – `break` keyword! But
    first, we'll check out the `for` loop.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到这个脚本有一个问题。如果我们想在`while`循环之后做任何事情，我们需要在不退出脚本的情况下*中断*它。我们将看到如何使用——等待它——`break`关键字来实现这一点！但首先，我们将看看`for`循环。
- en: The for loop
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for循环
- en: The `for` loop can be considered the more powerful loop in Bash scripting. In
    practice, `for` and `while` are interchangeable, but `for` has better shorthand
    syntax. This means that to write a loop in `for` often requires much less code
    than an equivalent `while` loop.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环可以被认为是Bash脚本中更强大的循环。在实践中，`for`和`while`是可以互换的，但`for`有更好的简写语法。这意味着在`for`中编写循环通常需要比等效的`while`循环少得多的代码。'
- en: 'The `for` loop has two different syntaxes: a C-style syntax and the `regular` Bash
    syntax. We''ll first look at the Bash syntax:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环有两种不同的语法：C风格的语法和`regular` Bash语法。我们首先看一下Bash语法：'
- en: FOR value IN list-of-values DO thing-with-value DONE
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: FOR value IN list-of-values DO thing-with-value DONE
- en: 'A `for` loop allows us to *iterate* over a list of things. Each loop will use
    a different item in that list, in a sequential order. This very simple example
    should illustrate this behavior:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环允许我们*迭代*一个事物列表。每次循环将使用列表中的不同项目，按顺序。这个非常简单的例子应该说明这种行为：'
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, `for` takes a list (in this case, a string delimited by whitespace),
    and for each value it finds it performs the `echo` action. We've added some extra
    text there so that you can see that it actually goes into the loop four times
    and does not just print the list with extra new lines. The main thing to notice
    here is that in the echo we use the `${word}` variable, which we defined as the
    second word in the `for` definition. This means that for every run of the `for`
    loop, the value of the `${word}` variable is different (which is very much using
    a variable as it is intended, with a *variable* content!). You can name this anything,
    but we prefer to give semantically logical names; since we called our list *words*,
    an item in that list would be a *word*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`for`接受一个列表（在这种情况下，是由空格分隔的字符串），对于它找到的每个值，它执行`echo`操作。我们添加了一些额外的文本，这样你就可以看到它实际上进入循环四次，而不仅仅是打印带有额外换行符的列表。这里要注意的主要事情是，在echo中我们使用`${word}`变量，我们将其定义为`for`定义中的第二个单词。这意味着对于`for`循环的每次运行，`${word}`变量的值是不同的（这非常符合使用变量的意图，具有*variable*内容！）。你可以给它取任何名字，但我们更喜欢给出语义逻辑的名称；因为我们称列表为*words*，列表中的一个项目将是一个*word*。
- en: If you want to do the same thing with `while`, things are going to get a lot
    more complicated. It's definitely possible by using a counter and a command such
    as `cut` (which allows you to cut out different parts of a string), but since
    the `for` loop does it in this simple manner, why bother?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用`while`做同样的事情，事情会变得更加复杂。通过使用计数器和`cut`这样的命令（它允许你剪切字符串的不同部分），这是完全可能的，但由于`for`循环以这种简单的方式完成，为什么要麻烦呢？
- en: 'The second syntax that we can use with for will be more recognizable for those
    experienced with other scripting programming languages. This C-style syntax uses
    a counter that increments until a certain point, not unlike the example we saw
    when we looked at `while`. The syntax is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的第二种与for一起使用的语法对于那些有其他脚本编程语言经验的人来说更加熟悉。这种C风格的语法使用一个计数器，直到某个点递增，与我们在看`while`时看到的示例类似。其语法如下：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Seems pretty similar right? Check out this example script:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很相似对吧？看看这个示例脚本：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Again, due to the nature of off-by-one errors, we have to use slightly different
    numbers. Since the counter is incremented *at the end of the loop*, we need to
    start it at 1 instead of 0 (or we could have done the same in the while loop).
    In C-style syntax, **<=** means *smaller than or equal to*, and ++ means *increment
    by 1*. So, we have a counter that starts at 1, continues until it reaches 10,
    and is incremented by 1 for each run of the loop. We find this `for` loop preferable
    to the equivalent while loop; it needs less code and is more common in other scripting/programming
    languages.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于off-by-one错误的性质，我们必须使用稍微不同的数字。由于计数器在循环结束时递增，我们需要从1开始而不是从0开始（或者我们可以在while循环中做同样的事情）。在C风格的语法中，**<=**表示*小于或等于*，++表示*递增1*。因此，我们有一个计数器，从1开始，一直持续到达10，并且每次循环运行时递增1。我们发现这个`for`循环比等效的while循环更可取；它需要更少的代码，在其他脚本/编程语言中更常见。
- en: 'Even better, there is a way to iterate over a number range (as we did for 1–10
    previously), with the for loop Bash syntax as well. Because a number range is
    nothing more than a *list of numbers*, we can use almost the same syntax as we
    did in the first example, in which we iterated over a *list of words*. Take a
    look at the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，还有一种方法可以遍历数字范围（就像我们之前对1-10做的那样），也可以使用for循环Bash语法。因为数字范围只是一个*数字列表*，所以我们可以使用几乎与我们在第一个示例中对*单词列表*进行迭代的相同语法。看看下面的代码：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So, the syntax for `<variable>` in `<list>` works with a list of `{1..10}`.
    This is called **brace expansion** and was added in Bash version 4\. The syntax
    for brace expansion is quite simple:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`<list>`中的`<variable>`语法适用于`{1..10}`的列表。这称为**大括号扩展**，并在Bash版本4中添加。大括号扩展的语法非常简单：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Brace expansion can be used in many ways, but printing lists of numbers or
    characters is the most well-known:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号扩展可以以许多方式使用，但打印数字或字符列表是最为人熟知的：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The brace expansion `{1..5}` returns the string `1 2 3 4 5`, which is a whitespace
    delimited list of values and can thus be used in the Bash-style `for` loop! Alternatively,
    `{a..f}` prints the string `a b c d e f`. The range is actually determined by
    ASCII hexadecimal codes; this allows us to do the following as well:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号扩展`{1..5}`返回字符串`1 2 3 4 5`，这是一个以空格分隔的值列表，因此可以在Bash风格的`for`循环中使用！另外，`{a..f}`打印字符串`a
    b c d e f`。范围实际上是由ASCII十六进制代码确定的；这也允许我们做以下操作：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It might seem weird that you'll see some special characters printed halfway,
    but those are in-between the uppercase and lowercase Latin alphabet characters.
    Note that this syntax is very similar to getting the value of a variable with
    `${variable}` (however, that is parameter expansion and not brace expansion).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得奇怪，因为你会看到一些特殊字符在中间打印，但这些字符是大写和小写拉丁字母字符之间的。请注意，这种语法与使用`${variable}`获取变量值非常相似（但这是参数扩展，而不是大括号扩展）。
- en: 'The brace expansion has one other interesting piece of functionality: it allows
    us to define the increment! Simply put, this allows us to tell Bash how many steps
    to skip each time we increment. The syntax for this is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号扩展还有另一个有趣的功能：它允许我们定义增量！简而言之，这允许我们告诉Bash每次递增时要跳过多少步。其语法如下：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'By default, the increment value is 1\. If this is the desired functionality,
    we can omit the increment value, as we previously saw. If we do set it, however,
    we''ll see something like the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，增量值为1。如果这是期望的功能，我们可以省略增量值，就像我们之前看到的那样。但是，如果我们设置了它，我们将看到以下内容：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, the increment is done in steps of 10\. As you can see in the previous example,
    the `<ending value>` is considered *inclusive*. This means that values that are
    *lower or equal* will be printed, but others will not. The next value in the first
    brace expansion in the preceding example. `{1..100..10}`, would have been 101;
    since this is not lower or equal to 100, the value is not printed and the expansion
    is terminated.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，增量是以10的步长进行的。正如你在前面的示例中看到的，`<ending value>`被认为是*包含的*。这意味着*低于或等于*的值将被打印，但其他值不会。在前面示例中的第一个大括号扩展中，`{1..100..10}`，下一个值将是101；因为这不是低于或等于100，该值不会被打印，扩展被终止。
- en: 'Finally, since we promised that anything we could do with `while` we could
    also do with `for`, we''d like to end this part of the chapter by showing you
    how you would create an infinite loop with `for`. This is the most common reason
    to choose `while` over `for`, because the `for` syntax is a little weird:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，因为我们承诺了我们可以用`while`做的任何事情，我们也可以用`for`做，我们想通过展示如何使用`for`创建无限循环来结束本章的部分。这是选择`while`而不是`for`的最常见原因，因为`for`的语法有点奇怪：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We use the C-style syntax, but we omit the initialization, comparison, and
    incrementing of the counter. Therefore, it reads as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用C风格的语法，但省略了计数器的初始化、比较和递增。因此，它的读法如下：
- en: for ((<nothing>;<no-comparison>;<no-increment>)); do
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: for ((<nothing>;<no-comparison>;<no-increment>)); do
- en: This ends up as `((;;));`, which only makes sense if you put it in the context
    of the normal syntax, as we did in the previous example. We could also just omit
    either the increment or the comparison to the same effect, but that would do the
    same thing with more code. Often, shorter is better, since it will be clearer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这最终变成了`((;;));`，只有将它放在正常语法的上下文中才有意义，就像我们在前面的例子中所做的那样。我们也可以省略增量或与相同效果的比较，但那样会增加更多的代码。通常情况下，更短更好，因为它会更清晰。
- en: Try to replicate the infinite `for` loop, but only by omitting a single value
    from the `for` clause. If you get that working, you'll be a step closer to understanding
    why you have now made it unending. If you need a little nudge, perhaps you'd want
    to echo the value of `counter` in the loop so that you can see what is happening.
    Or you could always run it with `bash -x`, of course!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试复制无限的`for`循环，但只是通过省略`for`子句中的一个值。如果你成功了，你将更接近理解为什么你现在让它无休止地运行。如果你需要一点点提示，也许你想要在循环中打印`counter`的值，这样你就可以看到发生了什么。当然，你也可以用`bash
    -x`来运行它！
- en: Globbing and the for loop
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通配符和for循环
- en: 'Now, let''s look at a few more practical examples. Most things you will do
    on Linux will deal with files (remember why?). Imagine that you have a bunch of
    log files sitting on the server and you''d like to perform some actions on them.
    If it is just a single action with a single command, you can most probably use
    a globbing pattern with that command (such as with `grep -i ''error'' *.log`).
    However, imagine a situation where you want to collect log files that contain
    a certain phrase, or perhaps only the lines from those files. In this case, using
    a globbing pattern in combination with a `for` loop will allow us to perform many
    commands on many files, which we can find dynamically! Let''s give it a go. Because
    this script will combine many of the lessons we''ve covered so far, we''ll begin
    simple and expand it gradually:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一些更实际的例子。在Linux上，你将会处理大部分事情都与文件有关（还记得为什么吗？）。想象一下，你有一堆日志文件放在服务器上，你想对它们执行一些操作。如果只是一个命令执行一个动作，你可以很可能使用通配符模式和命令（比如`grep
    -i 'error' *.log`）。然而，想象一种情况，你想收集包含某个短语的日志文件，或者只想要这些文件的行。在这种情况下，使用通配符模式结合`for`循环将允许我们对许多文件执行许多命令，我们可以动态地找到它们！让我们试试看。因为这个脚本将结合我们迄今为止所学的许多课程，我们将从简单开始，逐渐扩展它：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'By using the `$(ls /var/log/*.log)` construct, we can create a list of all
    files that end in `.log` that are found in the `/var/log/` directory. If you manually
    run the `ls /var/log/*.log` command, you will notice that the format is the same
    as the others we''ve seen when used in the Bash-style for syntax: single words,
    whitespace delimited. Because of this, we can now manipulate all of the files
    we found in order! Let''s see what happens if we try to grep in these files:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`$(ls /var/log/*.log)`构造，我们可以创建一个在`/var/log/`目录中找到的所有以`.log`结尾的文件的列表。如果你手动运行`ls
    /var/log/*.log`命令，你会注意到格式与我们在Bash风格的for语法中使用时所见到的其他格式相同：单词，以空格分隔。因此，我们现在可以操作我们找到的所有文件！让我们看看如果我们尝试在这些文件中进行grep会发生什么：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since we changed the content of the script, we''ve upped the version from `v1.0.0`
    to `v1.1.0`. If you run this script now, you''ll see that some of files return
    a positive match on the grep, while others do not:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们改变了脚本的内容，我们已经将版本从`v1.0.0`提升到`v1.1.0`。如果你现在运行这个脚本，你会发现一些文件在grep上返回了正匹配，而其他一些没有：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Great, so now we''ve accomplished the same thing with a complicated for loop
    that we could have also done directly with `grep`! Now, let''s get our money''s
    worth and do something with the files after we''ve determined that they contain
    the word `error`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在我们用一个复杂的for循环实现了与直接使用`grep`相同的事情！现在，让我们充分利用它，在我们确定它们包含单词`error`之后，对文件做些什么：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next version, `v1.2.0`, does a quiet `grep` (no output, since we just want
    the exit status of 0 when something is found). Directly after the `grep`, we use
    a nested `if-then` to copy the files to an archive directory that we defined at
    the beginning of the script. When we run the script now, we can see the same files
    that generated output in the previous version of the script, but now it copies
    the entire file. At this point, the `for` loop is proving its value: we''re now
    doing multiple operations on a single file that was found with the globbing pattern.
    Let''s take this one step further and remove all of the lines that do not contain
    an error from the archived files:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个版本，`v1.2.0`，执行了一个安静的`grep`（没有输出，因为我们只想要在找到东西时得到退出状态为0）。在`grep`之后，我们使用了一个嵌套的`if-then`来将文件复制到我们在脚本开头定义的存档目录中。当我们现在运行脚本时，我们可以看到在上一个版本的脚本中生成输出的相同文件，但现在它复制整个文件。此时，`for`循环证明了它的价值：我们现在对使用通配符模式找到的单个文件执行多个操作。让我们再进一步，从存档文件中删除所有不包含错误的行：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Version v1.3.0! To keep it a little readable, we have not included error checking
    on the `cp` and `mkdir` commands. However, due to the nature of this script (creating
    a subdirectory in `/tmp/` and copying files there), the chance of issues there
    is very slim. We added two new interesting things: a new variable called `file_new_location`
    with the file name of the new location and `sed`, which ensures only the error
    lines remain in the archived files.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 版本v1.3.0！为了使它稍微可读一些，我们没有在`cp`和`mkdir`命令上包含错误检查。然而，由于这个脚本的性质（在`/tmp/`中创建一个子目录并将文件复制到那里），那里出现问题的机会非常小。我们添加了两个新的有趣的东西：一个名为`file_new_location`的新变量，带有新位置的文件名和`sed`，它确保只有错误行保留在存档文件中。
- en: 'First, let''s consider `file_new_location=${ERROR_DIRECTORY}$(basename ${file})`.
    What we''re doing is pasting together two strings: first, the archive directory,
    followed by the *basename of the processed file.* The `basename` command strips
    the fully qualified path of a file, and only leaves the file name at the leaf
    of the path intact. If we were to look at the steps that Bash will undertake to
    resolve this new variable, it would probably look something like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑`file_new_location=${ERROR_DIRECTORY}$(basename ${file})`。我们正在将两个字符串拼接在一起：首先是存档目录，然后是*处理文件的基本名称*。`basename`命令会剥离文件的完全限定路径，只保留路径末端的文件名。如果我们要查看Bash将采取的步骤来解析这个新变量，它可能看起来是这样的：
- en: '`file_new_location=${ERROR_DIRECTORY}$(basename ${file})`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_new_location=${ERROR_DIRECTORY}$(basename ${file})`'
- en: '`-> resolve ${file}`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`-> 解析${file}`'
- en: '`file_new_location=${ERROR_DIRECTORY}$(basename /var/log/bootstrap.log)`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_new_location=${ERROR_DIRECTORY}$(basename /var/log/bootstrap.log)`'
- en: '`-> resolve $(basename /var/log/bootstrap.log)`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`-> 解析$(basename /var/log/bootstrap.log)`'
- en: '`file_new_location=${ERROR_DIRECTORY}bootstrap.log`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_new_location=${ERROR_DIRECTORY}bootstrap.log`'
- en: '`-> resolve ${ERROR_DIRECTORY}`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`-> 解析${ERROR_DIRECTORY}`'
- en: '`file_new_location=/tmp/error_logfiles/bootstrap.log`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file_new_location=/tmp/error_logfiles/bootstrap.log`'
- en: '`-> done, final value of variable!`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`-> 完成，变量的最终值！`'
- en: 'With that out of the way, we can now run `sed` on that new file. The `sed --quiet
    --in-place ''/[Ee]rror/p'' ${file_new_location}` command simply replaces the content
    of the file with all lines that match the regular expression search pattern of
    `[Ee]rror`, which is (almost) what we initially grepped for. Remember, we need `--quiet`
    because, by default, `sed` prints all lines. If we were to omit this, we would
    end up with all of the lines in the file, but all of the error files would be
    duplicated: once from the non-quiet output of `sed`, and once from the search
    pattern match. However, with --quiet active, `sed` only prints the matching lines
    and writes those to the files. Let''s see this in practice and verify the outcome:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些工作后，我们现在可以在这个新文件上运行`sed`。`sed --quiet --in-place '/[Ee]rror/p' ${file_new_location}`命令简单地用与正则表达式搜索模式`[Ee]rror`匹配的所有行替换文件的内容，这几乎就是我们最初使用grep搜索的内容。请记住，我们需要`--quiet`，因为默认情况下，`sed`会打印所有行。如果我们省略这一点，我们最终会得到文件中的所有行，但所有的错误文件都会被复制：一次来自`sed`的非静音输出，一次来自搜索模式匹配。然而，通过激活--quiet，`sed`只打印匹配的行并将其写入文件。让我们实际操作一下，验证结果：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, the three lines at the top of each file all contain the `error`
    or `Error` string. Actually, all of the lines in all of those files contained
    either of those strings; be sure to verify this on your own system since the content
    will undoubtedly be different.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，每个文件顶部的三行都包含`error`或`Error`字符串。实际上，所有这些文件中的所有行都包含这两个字符串中的一个；请务必在您自己的系统上验证这一点，因为内容肯定会有所不同。
- en: 'Now that we''ve finished this example, we have a few challenges for the reader,
    should you like to take them on:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了这个示例，如果你愿意接受挑战，我们为读者提供了一些挑战：
- en: Make this script accept input. This could be the archive directory, the path
    glob, the search pattern, or even all three!
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使这个脚本接受输入。这可以是存档目录、路径通配符、搜索模式，甚至是这三者的组合！
- en: Make this script more robust by adding exception handling to commands that *could*
    fail.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过为*可能*失败的命令添加异常处理，使这个脚本更加健壮。
- en: 'Invert the functionality of this script, by using the `sed ''/xxx/d''` syntax
    (hint: you''ll probably need redirection for this).'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`sed '/xxx/d'`语法来颠倒这个脚本的功能（提示：你可能需要重定向来实现这一点）。
- en: While this example should illustrate a lot of things, we realize that just searching
    on the word `error` does not actually only return errors. Actually, most of what
    we saw being returned was related to an installed package, `liberror`! In practice,
    you might be working with log files that have a predefined structure when it comes
    to errors. In this case, it is much easier to determine a search pattern that
    only logs real errors.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个示例应该说明了很多东西，但我们意识到仅仅搜索`error`这个词实际上并不只返回错误。实际上，我们看到的大部分返回的内容都与一个已安装的软件包`liberror`有关！在实践中，你可能会处理在错误方面具有预定义结构的日志文件。在这种情况下，更容易确定一个只记录真正错误的搜索模式。
- en: Loop control
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环控制
- en: 'At this point, you should feel comfortable with using `while` and `for` loops.
    There is one more, rather important, topic to discuss with regards to loops: **loop
    control**. Loop control is a generic term, for anything that you do to, well,
    control the loop! However, there are two *keywords* that we''ll need if we want
    to unleash the full power of loops: `break` and `continue`. We''ll start with
    `break`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你应该对使用`while`和`for`循环感到满意。关于循环，还有一个更重要的话题需要讨论：**循环控制**。循环控制是一个通用术语，用于控制循环的任何操作！然而，如果我们想要发挥循环的全部威力，有两个*关键字*是必须的：`break`和`continue`。我们将从`break`开始。
- en: Breaking the loop
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打破循环
- en: 'For some scripting logic, it will prove necessary to break out of the loop.
    You might imagine that, in one of your scripts, you are waiting for something
    to finish. As soon as that happens, you want to *do something*. Waiting and periodically
    checking inside a `while true` loop could be an option for this, but if you recall
    in the `while-interactive.sh` script, we exited on the successful answer to the
    riddle. On an exit, we cannot run any more commands that are outside of the `while`
    loop! This is where `break` comes into play. It allows us to exit the *loop*,
    but continue the *script*. First, let''s update `while-interactive.sh` to make
    use of this loop control keyword:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些脚本逻辑，有必要跳出循环。你可以想象，在你的某个脚本中，你正在等待某件事完成。一旦发生，你就想*做点什么*。在`while true`循环中等待并定期检查可能是一个选择，但是如果你回想一下`while-interactive.sh`脚本，我们在谜底得到成功答案时退出了。在退出时，我们不能运行任何超出`while`循环之外的命令！这就是`break`发挥作用的地方。它允许我们退出*循环*，但继续*脚本*。首先，让我们更新`while-interactive.sh`以利用这个循环控制关键字：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We made three changes:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了三个更改：
- en: Adopted a higher version number
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用了更高的版本号
- en: Replaced `exit 0` with `break`
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`exit 0`替换为`break`
- en: Added a simple `echo` after the while loop
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在while循环后添加一个简单的`echo`
- en: 'When we still had `exit 0` in place, the final `echo` would never have run
    (but don''t trust us, be sure to verify this yourself!). Now, run it with `break`
    and watch:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们仍然使用`exit 0`时，最终的`echo`将永远不会运行（但不要相信我们，一定要自己验证一下！）。现在，用`break`运行它并观察：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There we go, code execution after a broken `while` loop. Often, after an infinite
    loop, there is definitely other code that needs to be executed, and this is the
    way to do it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是，在一个中断的`while`循环之后的代码执行。通常，在一个无限循环之后，肯定有其他需要执行的代码，这就是做到的方式。
- en: 'We can use `break` not only in a `while` loop, but most certainly in a `for`
    loop. The following example shows how we can use `break` in a `for` loop:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以在`while`循环中使用`break`，而且在`for`循环中当然也可以。下面的例子显示了我们如何在`for`循环中使用`break`：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At the top of this script''s functionality, a random number between 1 and 10
    is determined (don''t worry about the syntax). Next, we iterate over the numbers
    1 through 10 and for each number, we''ll check if it''s equal to the randomly
    generated number. If it is, we print a success message *and we break the loop*.
    Otherwise, we''re going outside of the `if-then` block and printing the failure
    message. If we did not include the break statement, the output would look like
    this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本功能的顶部，确定一个1到10之间的随机数（不用担心语法）。接下来，我们遍历1到10的数字，对于每个数字，我们将检查它是否等于随机生成的数字。如果是，我们打印一个成功的消息*并且我们中断循环*。否则，我们将跳出`if-then`块并打印失败消息。如果我们没有包括中断语句，输出将如下所示：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Not only do we see the number printed as both matching and non-matching (which
    is a logical error, of course), but the script also continues checking all other
    numbers when we''re certain that those will not match. Now, if we used exit instead
    of break, the final statement will never be printed:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅看到数字被打印为匹配和不匹配（这当然是一个逻辑错误），而且当我们确定那些数字不会匹配时，脚本还会继续检查所有其他数字。现在，如果我们使用exit而不是break，最终的语句将永远不会被打印：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Only by using `break` will we get exactly the amount of output we need; nothing
    more and nothing less. You might have seen that we could have also used an `else`
    clause for the `Number does not match:` message. Still, nothing would be stopping
    the program. So even if the random number was found on the first try (which will
    happen, eventually), it will still compare all of the values in the list until
    it reaches the end of that list.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 只有使用`break`，我们才会得到我们需要的确切数量的输出；既不多也不少。你可能已经看到，我们也可以为`Number does not match:`消息使用`else`子句。但是，没有什么会阻止程序。所以即使随机数第一次就被找到（最终会发生的），它仍然会比较列表中的所有值，直到达到该列表的末尾。
- en: 'Not only is this a waste of time and resources, but imagine the output if the
    random number was somewhere between 1 and 1,000,000! Just remember: if you''re
    done with the loop, **break out of it.**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅是浪费时间和资源，而且想象一下，如果随机数在1到1,000,000之间！只要记住：如果你完成了循环，**跳出它。**
- en: The continue keyword
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续关键字
- en: 'As with most things in Bash (and life), there is a Yang to the Yin that is
    `break`: the `continue`  keyword. If you use continue, you''re telling the loop
    to stop the current loop, but *continue* with the next run. So, instead of stopping
    the entire loop, you''ll just stop the current iteration. Let''s see if another
    example can make this clear:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 和Bash（以及生活）中的大多数事情一样，`break`有一个对应的`continue`关键字。如果你使用continue，你是告诉循环停止当前循环，但*继续*下一次运行。所以，不是停止整个循环，你只是停止当前迭代。让我们看看另一个例子是否能澄清这一点：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In this example, all of the numbers that can be divided cleanly by 5 are considered
    unlucky and should not be processed. This is achieved by the `[[ $((${number}%5))
    -eq 0 ]]` condition:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有可以被5整除的数字都被认为是不幸的，不应该被处理。这是通过`[[ $((${number}%5)) -eq 0 ]]`条件实现的：
- en: '**[[** $((${number}%5)) **-eq 0 ]]** -> test syntax'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[[** $((${number}%5)) **-eq 0 ]]** -> 测试语法'
- en: '[[ **$((**${number}%5**))** -eq 0 ]] -> arithmetic syntax'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[[ **$((**${number}%5**))** -eq 0 ]] -> 算术语法'
- en: '[[ $((**${number}%5**)) -eq 0 ]] -> modulo 5 of the variable **number**'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[[ $((**${number}%5**)) -eq 0 ]] -> 变量**number**的模5'
- en: 'If the number passes this test (and is thus cleanly divisible by 5, such as
    5, 10, 15, 20, and so on), `continue` is executed. When this happens, the next
    iteration of the loop is run (and `echo` is **NOT** executed!), as can be seen
    when running this script:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数字通过了这个测试（因此可以被5整除，比如5、10、15、20等），将执行`continue`。当这发生时，循环的下一个迭代将运行（并且`echo`**不会**被执行！），当运行这个脚本时可以看到：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As the list should imply, the numbers `5`, `10`, and `15` are processed, but
    we do not see them in `echo`. We can also see everything after, which would not
    have happened with `break`. Verify if this is actually happening with `bash -x`
    (warning: loads of output!) and check what happens if you replace `continue` with
    `break` or even `exit`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '如列表所示，数字`5`、`10`和`15`被处理，但我们在`echo`中看不到它们。我们还可以看到之后的一切，这在使用`break`时是不会发生的。使用`bash
    -x`验证这是否真的发生了（警告：大量输出！），并检查如果你用`break`或甚至`exit`替换`continue`会发生什么。 '
- en: Loop control and nesting
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环控制和嵌套
- en: 'For the final part of this chapter, we''d like to show you how you can influence
    `nested` loops with loop control as well. Both break and continue will take an
    extra argument: a number that specified which loop to break out of. By default,
    if this argument is omitted, it is assumed to be `1`. So, the `break` command
    is equal to `break 1`, and `continue 1` is the same as `continue`. As stated before,
    we can theoretically nest our loops as deep as we want; you''re likely to hit
    logical issues a lot earlier than problems with the technical capabilities of
    your modern system! We''ll look at a simple example that shows us how we can use
    a `break 2` to not only break out of a `for` loop, but out of the outer `while`
    loop as well:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们想向您展示如何使用循环控制来影响`嵌套`循环。`break`和`continue`都将带有一个额外的参数：指定要中断的循环。默认情况下，如果省略了此参数，就假定为`1`。因此，`break`命令等同于`break
    1`，`continue 1`等同于`continue`。正如之前所述，我们理论上可以将我们的循环嵌套得很深；你可能会比你的现代系统的技术能力更早地遇到逻辑问题！我们将看一个简单的例子，向我们展示如何使用`break
    2`不仅可以跳出`for`循环，还可以跳出外部的`while`循环：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This first version of the script does not contain `break`. When we run this,
    we never see the final message and we get an endless repeating pattern:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本的第一个版本不包含`break`。当我们运行它时，我们永远看不到最终的消息，而且我们得到一个无休止的重复模式：
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, let''s break the inner loop when the iteration hits `2`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在迭代达到`2`时中断内部循环：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When we run the script now, we still get infinite loops, but we''re cutting
    the inner for loop short after two iterations instead of three:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行脚本时，我们仍然得到无限循环，但在三次迭代之后，我们缩短了内部for循环：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let''s instruct the inner loop to break out of the outer loop by using
    the `break 2` command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`break 2`命令指示内部循环跳出外部循环：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Behold, an inner loop breaking out of an outer loop successfully:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 看，内部循环成功地跳出了外部循环：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There we go, full control over our loops, even when we nest as many as we need
    for our scripting needs. The same theory applies to `continue` as well. If, in
    this example, we use `continue 2` instead of `break 2`, we would still get an
    infinite loop (since while true never ends). However, if your other loop was also
    a `for` or a non-infinite `while` loop (which, in our experience, is more common
    but does not make for a great simple example), `continue 2` could allow you to
    execute exactly the logic that the situation desires.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以完全控制我们的循环，即使我们需要嵌套尽可能多的循环来满足我们的脚本需求。相同的理论也适用于`continue`。在这个例子中，如果我们使用`continue
    2`而不是`break 2`，我们仍然会得到一个无限循环（因为`while true`永远不会结束）。然而，如果您的其他循环也是`for`或非无限的`while`循环（根据我们的经验，这更常见，但不适合作为一个很好的简单例子），`continue
    2`可以让您执行恰好符合情况需求的逻辑。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was dedicated to conditional testing and scripting loops. Since
    we had already discussed the `if-then-else` statements, we recapped on this information
    before going on to showing more advanced uses of the conditional testing toolkit.
    This advanced information included using regular expressions, which we learned
    about in the previous chapter, within a conditional testing scenario to allow
    for more flexible tests. We also showed you how multiple conditions can be tested
    sequentially, using `elif` (short for `else if`). We explained how multiple `if-then-else`
    statements can be nested to create advanced logic.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于条件测试和脚本循环的。由于我们已经讨论了`if-then-else`语句，所以在展示条件测试工具包的更高级用法之前，我们回顾了这些信息。这些高级信息包括在条件测试场景中使用正则表达式，我们在上一章中学习过，以实现更灵活的测试。我们还向您展示了如何使用`elif`（`else
    if`的缩写）来顺序测试多个条件。我们解释了如何嵌套多个`if-then-else`语句以创建高级逻辑。
- en: In the second part of this chapter, we introduced the `while` loop. We showed
    you how we can use this to create a script that will run indefinitely, or how
    we can use conditions to stop the loop when a certain criteria has been met. We
    presented the `until` keyword, which has the same functionality as `while` but
    allows for negative checking instead of positive for `while`. We ended the explanation
    on `while` by showing you how an interactive script can be created in an unending
    `while` loop (using our old friend `read`).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，我们介绍了`while`循环。我们向您展示了如何使用它来创建一个永远运行的脚本，或者如何使用条件来在满足某些条件时停止循环。我们介绍了`until`关键字，它与`while`具有相同的功能，但允许进行负检查，而不是`while`的正检查。我们通过向您展示如何在一个无休止的`while`循环中创建一个交互式脚本来结束对`while`的解释（使用我们的老朋友`read`）。
- en: After `while`, we introduced the more powerful `for` loop. This loop can do
    the same things `while` can, but often the shorter syntax allows us to write less
    code (and more readable code, which is still a very important aspect in scripting!).
    We showed you how `for` can iterate over a list, and how we can create a list
    of numbers using *brace expansion*. We ended our discussion on `for` loops by
    giving a practical example of combining `for` with file globbing patterns to allow
    us to dynamically find, grab, and process files.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`之后，我们介绍了更强大的`for`循环。这个循环可以做与`while`相同的事情，但通常更短的语法允许我们编写更少的代码（以及更可读的代码，这仍然是脚本编写中非常重要的一个方面！）。我们向您展示了`for`如何遍历列表，以及如何使用*大括号扩展*来创建数字列表。我们通过给出一个实际的例子，结合`for`和文件通配模式，来结束我们对`for`循环的讨论，以便我们可以动态查找、获取和处理文件。
- en: We ended this chapter by explaining loop control, which is achieved in Bash
    with the `break` and `continue` keywords. These keywords allows us to *break*
    out of a loop (even from nested loops, as far back outside as we need), and also
    allow us to stop the current iteration of the loop and *continue* to the next
    iteration.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过解释循环控制来结束了本章，Bash中使用`break`和`continue`关键字来实现。这些关键字允许我们从循环中*跳出*（甚至从嵌套循环中，直到我们需要的外部循环），并且还允许我们停止循环的当前迭代，*继续*到下一个迭代。
- en: 'The following commands/keywords were introduced in this chapter: `elif`, `help`, `while`,
    `sleep`, `for`, `basename`, `break`, and `continue`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了以下命令/关键字：`elif`、`help`、`while`、`sleep`、`for`、`basename`、`break`和`continue`。
- en: Questions
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does an `if-then`(`-else`) statement end?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`if-then`（`-else`）语句是如何结束的？'
- en: How can we use regular expression search patterns in a conditional evaluation?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在条件评估中使用正则表达式搜索模式？
- en: Why do we need the `elif` keyword?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么需要`elif`关键字？
- en: What is *nesting*?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是*嵌套*？
- en: How can we get information about how to use shell builtins and keywords?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何获取有关如何使用shell内置命令和关键字的信息？
- en: What is the opposite keyword of `while`?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`while`的相反关键字是什么？'
- en: Why would we choose the for loop over the `while` loop?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们会选择`for`循环而不是`while`循环？
- en: What is brace expansion and on which characters can we use it?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大括号扩展是什么，我们可以在哪些字符上使用它？
- en: Which two keywords allow us to have more granular control over loops?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪两个关键字允许我们对循环有更精细的控制？
- en: If we are nesting loops, how can we employ loop control to influence outer loops
    from an inner loop?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们嵌套循环，我们如何使用循环控制来影响内部循环的外部循环？
- en: Further reading
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following resources might be interesting if you''d like to go deeper into
    the subjects of this chapter:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更深入地了解本章的主题，以下资源可能会很有趣：
- en: '**The case** **statement**: [http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**case语句**: [http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html)'
- en: '**Brace expansions**: [http://wiki.bash-hackers.org/syntax/expansion/brace](http://wiki.bash-hackers.org/syntax/expansion/brace)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大括号扩展**: [http://wiki.bash-hackers.org/syntax/expansion/brace](http://wiki.bash-hackers.org/syntax/expansion/brace)'
- en: '**The Linux Documentation Project on loops**: [http://www.tldp.org/LDP/abs/html/loops1.html](http://www.tldp.org/LDP/abs/html/loops1.html)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux文档项目关于循环**: [http://www.tldp.org/LDP/abs/html/loops1.html](http://www.tldp.org/LDP/abs/html/loops1.html)'
