- en: Chapter 4. ELF Virus Technology – Linux/Unix Viruses
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 ELF病毒技术- Linux/Unix病毒
- en: The art of virus writing has been around for several decades now. In fact, it
    goes all the way back to the Elk Cloner Apple virus that was successfully launched
    in the wild in 1981 through a floppy disk video game. Since the mid '80s and through
    the '90s, there have been various secret groups and hackers who have used their
    arcane knowledge to design, release, and publish viruses in virus and hacker e-zines
    (see [http://vxheaven.org/lib/static/vdat/ezines1.htm](http://vxheaven.org/lib/static/vdat/ezines1.htm)).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 病毒编写的艺术已经存在了几十年。事实上，它可以追溯到1981年通过软盘视频游戏成功在野外发布的Elk Cloner苹果病毒。自80年代中期到90年代，有各种秘密团体和黑客利用他们的神秘知识设计、发布和发表病毒在病毒和黑客电子杂志中（见[http://vxheaven.org/lib/static/vdat/ezines1.htm](http://vxheaven.org/lib/static/vdat/ezines1.htm)）。
- en: The art of virus writing is usually of great inspiration to hackers and underground
    technical enthusiasts, not because of the destruction that they are capable of,
    but rather the challenge in designing them and the unconventional coding techniques
    that are required to succeed in programming a parasite that keeps its residency
    by hiding in other executables and processes. Also, the techniques and solutions
    that come with keeping a parasite stealthy, such as polymorphic and metamorphic
    code, present a unique challenge to programmers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 病毒编写的艺术通常会给黑客和地下技术爱好者带来很大的启发，不是因为它们能够造成的破坏，而是因为设计它们和需要成功编程的非常规编码技术所带来的挑战，这些病毒可以通过隐藏在其他可执行文件和进程中保持其驻留的寄生虫。此外，保持寄生虫隐蔽的技术和解决方案，如多态和变形代码，对程序员来说是一种独特的挑战。
- en: UNIX viruses have been around since the early '90s, but I think many would agree
    to say that the true father of the UNIX virus is Silvio Cesare ([http://vxheaven.org/lib/vsc02.html](http://vxheaven.org/lib/vsc02.html)),
    who published many papers in the late 90s on ELF virus infection methods. These
    methods are still being used today in different variations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX病毒自90年代初就存在了，但我认为许多人会同意说UNIX病毒的真正创始人是Silvio Cesare ([http://vxheaven.org/lib/vsc02.html](http://vxheaven.org/lib/vsc02.html))，他在90年代末发表了许多关于ELF病毒感染方法的论文。这些方法在今天仍在以不同的变体使用。
- en: Silvio was the first to publish some awesome techniques, such as PLT/GOT redirection,
    text segment padding infections, data segment infections, relocatable code injection,
    `/dev/kmem` patching, and kernel function hijacking. Not only that, but he personally
    played a big role in my introduction to ELF binary hacking, and I will always
    remain grateful for his influence.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Silvio是第一个发布一些令人惊叹的技术的人，比如PLT/GOT重定向，文本段填充感染，数据段感染，可重定位代码注入，`/dev/kmem`修补和内核函数劫持。不仅如此，他个人在我接触ELF二进制黑客技术方面起到了很大的作用，我会永远感激他的影响。
- en: In this chapter, we will discuss why it is important to understand ELF virus
    technology and how to design them. The technology behind an ELF virus can be utilized
    for many things other than writing viruses, such as general binary patching and
    hot patching, which can be used in security, software engineering, and reversing.
    In order to reverse-engineer a virus, it would behoove you to understand how many
    of them work. It is worth noting that I recently reverse-engineered and wrote
    a profile for a unique and exceptional ELF virus called **Retaliation**. This
    work can be found at [http://www.bitlackeys.org/#retaliation](http://www.bitlackeys.org/#retaliation).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论为什么重要理解ELF病毒技术以及如何设计它们。ELF病毒背后的技术可以用于除了编写病毒之外的许多其他事情，比如一般的二进制修补和热修补，这可以在安全、软件工程和逆向工程中使用。为了逆向工程一个病毒，了解其中许多病毒是如何工作的对你是有好处的。值得注意的是，我最近逆向工程并为一个名为**Retaliation**的独特和杰出的ELF病毒编写了一个概要。这项工作可以在[http://www.bitlackeys.org/#retaliation](http://www.bitlackeys.org/#retaliation)找到。
- en: ELF virus technology
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ELF病毒技术
- en: The world of ELF virus technology shall open up many doors to you as a hacker
    and engineer. To begin, let's discuss what an ELF virus is. Every executable program
    has a control flow, also called the path of execution. The first aim of an ELF
    virus is to hijack the control flow so that the path of execution is temporarily
    altered in order to execute the parasite code. The parasite code is usually responsible
    for setting up hooks to hijack functions and also for copying itself (the body
    of the parasite code) into another program that hasn't yet been infected by the
    virus. Once the parasite code is done running, it usually jumps to the original
    entry point or the regular path of execution. This way, the virus goes unnoticed,
    since the host program appears to be executing normally.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ELF病毒技术的世界将为你作为黑客和工程师打开许多大门。首先，让我们讨论一下什么是ELF病毒。每个可执行程序都有一个控制流，也称为执行路径。ELF病毒的第一个目标是劫持控制流，以便临时改变执行路径以执行寄生代码。寄生代码通常负责设置钩子来劫持函数，还负责将自身（寄生代码的主体）复制到尚未被病毒感染的另一个程序中。一旦寄生代码运行完毕，它通常会跳转到原始入口点或正常的执行路径。这样，病毒就不会被注意到，因为宿主程序看起来是正常执行的。
- en: '![ELF virus technology](img/00006.jpeg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![ELF病毒技术](img/00006.jpeg)'
- en: 'Figure 4.1: Generic infection to an executable'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：对可执行文件的通用感染
- en: ELF virus engineering challenges
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ELF病毒工程挑战
- en: The design phase of an ELF virus may be considered an artistic endeavor, requiring
    creative thinking and clever constructs; many passionate coders will agree with
    this. Meanwhile, it is a great engineering challenge that exceeds the regular
    conventions of programming, requiring the developer to think outside conventional
    paradigms and to manipulate the code, data, and environment into behaving a certain
    way. At one point in time, I did a security assessment at a large **antivirus**
    (**AV**) company for one of their products. While talking with the developers
    of the AV software, I was amazed that next to none of them had any real idea of
    how to engineer a virus, let alone design any real heuristics for identifying
    them (other than signatures). The truth is that virus writing is difficult, and
    requires serious skill. There are a number of challenges that come into play when
    engineering them, and before we discuss the engineering components, let's look
    at what some of these challenges are.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ELF病毒的设计阶段可能被认为是一种艺术创作，需要创造性思维和巧妙的构造；许多热情的编码人员会同意这一点。与此同时，这是一个超出常规编程约定的伟大工程挑战，需要开发人员超越常规范式思维，操纵代码、数据和环境以某种方式行为。曾经，我曾对一家大型**杀毒软件**（**AV**）公司的一款产品进行了安全评估。在与杀毒软件的开发人员交谈时，我惊讶地发现他们几乎没有任何真正的想法如何设计病毒，更不用说设计任何真正的启发式来识别它们（除了签名）。事实上，编写病毒是困难的，需要严肃的技能。在工程化时，会出现许多挑战，让我们在讨论工程化组件之前，先看看其中一些挑战是什么。
- en: Parasite code must be self-contained
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寄生体代码必须是自包含的
- en: A parasite must be able to physically exist inside another program. This means
    that it does not have the luxury of linking to outside libraries through the dynamic
    linker. The parasite must be self-contained, which means that it relies on no
    external linking, is position independent, and is able to dynamically calculate
    memory addresses within itself; this is because the addresses will change between
    each infection, since the parasite will be injected into an existing binary where
    its position will change each time. This means that if the parasite code references
    a function or a string by its address, the hardcoded address will change and the
    code will fail; instead, use IP-relative code with a function that calculates
    the address of the code/data by its offset to the instruction pointer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 寄生体必须能够实际存在于另一个程序中。这意味着它不能通过动态链接器链接到外部库。寄生体必须是自包含的，这意味着它不依赖于外部链接，是位置无关的，并且能够在自身内部动态计算内存地址；这是因为地址将在每次感染之间改变，因为寄生体将被注入到现有的二进制文件中，其位置将每次改变。这意味着如果寄生体代码通过其地址引用函数或字符串，硬编码的地址将改变，代码将失败；而是使用相对于IP的代码，使用一个函数通过指令指针的偏移量计算代码/数据的地址。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In some more complex memory viruses such as my *Saruman* virus, I allow the
    parasite to be compiled as an executable program with dynamic linking, but the
    code to launch it into a process address space is very complicated, because it
    must handle relocations and dynamic linking manually. There are also relocatable
    code injectors such as Quenya, which allow a parasite to be compiled as relocatable
    objects, but the infector must be able to support handling relocations during
    the infection phase.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些更复杂的内存病毒中，比如我的*Saruman*病毒，我允许寄生体编译为一个带有动态链接的可执行程序，但是将其启动到进程地址空间的代码非常复杂，因为它必须手动处理重定位和动态链接。还有一些可重定位代码注入器，比如Quenya，允许寄生体编译为可重定位对象，但感染者必须能够在感染阶段支持处理重定位。
- en: Solution
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Compile your initial virus executable with the `gcc` option `-nostdlib`. You
    may also compile it with `-fpic -pie` to make the executable **position-independent
    code** (**PIC**). The IP-relative addressing available on x86_64 machines is actually
    a nice feature for virus writers. Create your own common functions, such as `strcpy()`
    and `memcmp()`. When you need advanced functionality such as heap allocation with
    `malloc()`, you may instead use `sys_brk()` or `sys_mmap()` to create your own
    allocation routines. Create your own syscall wrappers, for example, a wrapper
    for the `mmap` syscall is shown here, using C and inline assembly:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`gcc`选项`-nostdlib`编译初始病毒可执行文件。您还可以使用`-fpic -pie`编译它，使可执行文件成为**位置无关代码**（**PIC**）。x86_64机器上可用的IP相对寻址实际上是病毒编写者的一个很好的功能。创建自己的常用函数，比如`strcpy()`和`memcmp()`。当您需要`malloc()`的高级功能时，您可以使用`sys_brk()`或`sys_mmap()`创建自己的分配例程。创建自己的系统调用包装器，例如，这里使用C和内联汇编展示了`mmap`系统调用的包装器：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once you have a wrapper calling the `mmap()` syscall, you can create a simple
    `malloc` routine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有一个调用`mmap()`系统调用的包装器，您就可以创建一个简单的`malloc`例程。
- en: 'The `malloc` function is used to allocate memory on the heap. Our little `malloc`
    function uses a memory-mapped segment for each allocation, which is inefficient
    but suffices for simple use cases:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc`函数用于在堆上分配内存。我们的小`malloc`函数为每个分配使用了一个内存映射段，这是低效的，但对于简单的用例足够了。'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Complications with string storage
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串存储的复杂性
- en: 'This challenge rather blends in with the last section on self-contained code.
    When handling strings in your virus code, you may have:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个挑战与上一节关于自包含代码的最后一节相融合。在处理病毒代码中的字符串时，您可能会有：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will want to tend to stay away from code such as the preceding one. This
    is because the compiler will likely store the `elfmaster` data in the `.rodata`
    section, and then reference that string by its address. The address will not be
    valid once the virus executable is injected inside another program. This problem
    is really coupled with the problem of hardcoded addresses that we discussed earlier.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您将希望避免使用类似上述的代码。这是因为编译器可能会将`elfmaster`数据存储在`.rodata`部分，然后通过其地址引用该字符串。一旦病毒可执行文件被注入到另一个程序中，该地址将不再有效。这个问题实际上与我们之前讨论的硬编码地址的问题紧密相连。
- en: Solution
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the stack to store strings so that they are dynamically allocated at runtime:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用堆栈存储字符串，以便它们在运行时动态分配：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Another neat trick that I just recently discovered during the construction
    of the Skeksi virus for 64-bit Linux is to merge the text and data segment into
    a single segment, that is, **read+write+execute** (**RWX**), by using the `-N`
    option with `gcc`. This is very nice because the global data and read-only data,
    such as the `.data` and `.rodata` sections, are all merged into a single segment.
    This allows the virus to simply inject the entire segment during the infection
    phase, which will include string literals such as those from `.rodata`. This technique
    combined with IP-relative addressing allows a virus author to use traditional
    string literals:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我最近在为64位Linux构建Skeksi病毒时发现的另一个巧妙技巧是通过使用`gcc`的`-N`选项将文本和数据段合并为单个段，即**读+写+执行**（**RWX**）。这非常好，因为全局数据和只读数据，例如`.data`和`.rodata`部分，都合并到单个段中。这允许病毒在感染阶段简单地注入整个段，其中将包括来自`.rodata`的字符串文字。这种技术结合IP相对寻址允许病毒作者使用传统的字符串文字：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This type of string can now be used in the virus code, and the method of storing
    strings on the stack can be avoided entirely. It is important to note, however,
    that keeping all of the strings stored off the stack in global data will cause
    the overall size of the virus parasite to increase, which is sometimes undesirable.
    The Skeksi virus was recently released and is available at [http://www.bitlackeys.org/#skeksi](http://www.bitlackeys.org/#skeksi).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在病毒代码中使用这种类型的字符串，并且可以完全避免在堆栈上存储字符串的方法。然而，需要注意的是，将所有字符串存储在全局数据中会导致病毒寄生体的整体大小增加，这有时是不可取的。Skeksi病毒最近发布，并可在[http://www.bitlackeys.org/#skeksi](http://www.bitlackeys.org/#skeksi)上获得。
- en: Finding legitimate space to store parasite code
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找合法空间存储寄生虫代码
- en: 'This is one of the big questions to answer when writing a virus: where will
    the payload (the body of the virus) be injected? In other words, where in the
    host binary will the parasite live? The possibilities vary from binary format
    to binary format. In the `ELF` format, there are quite a number of places to inject
    code, but they all require correct adjustment of the various different `ELF` header
    values.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是编写病毒时需要回答的一个重要问题之一：病毒的载荷（病毒的主体）将被注入到哪里？换句话说，在主机二进制文件的哪里将寄生虫存活？可能性因二进制格式而异。在`ELF`格式中，有相当多的地方可以注入代码，但它们都需要正确调整各种不同的`ELF`头值。
- en: The challenge isn't necessarily finding space but rather adjusting the `ELF`
    binary to allow you to use that space while keeping the executable file looking
    reasonably normal and staying within the `ELF` specifications closely enough so
    that it still executes properly. There are many things that must be considered
    when patching a binary and modifying its layout, such as page alignment, offset
    adjustments, and address adjustments.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战并不一定是找到空间，而是调整`ELF`二进制文件以允许您使用该空间，同时使可执行文件看起来相当正常，并且足够接近`ELF`规范，以便它仍然能够正确执行。在修补二进制文件和修改其布局时，必须考虑许多事项，例如页面对齐、偏移调整和地址调整。
- en: Solution
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: Read the `ELF` specs carefully when creating new methods of binary patching,
    and make sure that you stay within the boundaries necessary for program execution.
    In the next section, we will discuss some techniques of virus infection.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新的二进制修补方法时，仔细阅读`ELF`规范，并确保您在程序执行所需的边界内。在下一节中，我们将讨论一些病毒感染技术。
- en: Passing the execution control flow to the parasite
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将执行控制流传递给寄生虫
- en: Here is another common challenge, which is how to pass the control flow of the
    host executable to the parasite. In many cases, it will suffice to adjust the
    entry point in the `ELF` file header to point to the parasite code. This is reliable,
    but also very obvious. If the entry point has been modified to point at the parasite,
    then we can use `readelf -h` to see the entry point and immediately know the location
    of the parasite code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有另一个常见的挑战，那就是如何将主机可执行文件的控制流传递给寄生虫。在许多情况下，调整`ELF`文件头中的入口点以指向寄生虫代码就足够了。这是可靠的，但也非常明显。如果入口点已经修改为指向寄生虫，那么我们可以使用`readelf
    -h`来查看入口点，并立即知道寄生虫代码的位置。
- en: Solution
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: If you don't want to modify the entry point address, then consider finding a
    place where you can insert/modify a branch to your parasite code, such as inserting
    a `jmp` or overwriting a function pointer. One great place for this is in the
    `.ctors` or `.init_array` sections, which contain function pointers. The `.dtors`
    or `.fini_array` sections can work as well if you don't mind the parasite executing
    after the regular program code (instead of before).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想修改入口点地址，那么考虑找到一个可以插入/修改分支到寄生虫代码的地方，例如插入`jmp`或覆盖函数指针。其中一个很好的地方是`.ctors`或`.init_array`部分，其中包含函数指针。如果您不介意寄生虫在常规程序代码之后（而不是之前）执行，那么`.dtors`或`.fini_array`部分也可以起作用。
- en: ELF virus parasite infection methods
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ELF病毒寄生体感染方法
- en: There are only so many places to fit code in a binary, and for any sophisticated
    virus, the parasite is going to be at least a few thousand bytes and will require
    enlarging the size of the host executable. In `ELF` executables, there aren't
    a whole lot of code caves (such as in the PE format), so you are not likely to
    be able to shove more than just a meager amount of shellcode into existing code
    slots (such as areas that have 0s or `NOPS` for function padding).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件中只有有限的空间可以容纳代码，对于任何复杂的病毒，寄生虫至少会有几千字节，并且需要扩大主机可执行文件的大小。在`ELF`可执行文件中，没有太多的代码洞（例如PE格式），因此您不太可能能够将更多的shellcode塞入现有的代码槽中（例如具有0或`NOPS`用于函数填充的区域）。
- en: The Silvio padding infection method
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Silvio填充感染方法
- en: This infection method was conceived by Silvio Cesare in the late '90s and has
    since shown up in various Linux viruses, such as *Brundle Fly* and the POCs produced
    by Silvio himself. This method is inventive, but it limits the infection payload
    to one page size. On 32-bit Linux systems, this is 4096 bytes, but on 64-bit systems,
    the executables use large pages that measure 0x200000 bytes, which allows for
    about a 2-MB infection. The way that this infection works is by taking advantage
    of the fact that in memory, there will be one page of padding between the text
    segment and data segment, whereas on disk, the text and data segments are back
    to back, but someone can take advantage of the expected space between segments
    and utilize that as an area for the payload.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种感染方法是由Silvio Cesare在90年代后期构思的，并且此后出现在各种Linux病毒中，例如*Brundle Fly*和Silvio本人制作的POC。这种方法很有创意，但它将感染负载限制在一页大小。在32位Linux系统上，这是4096字节，但在64位系统上，可执行文件使用0x200000字节的大页，这允许大约2MB的感染。这种感染的工作原理是利用内存中文本段和数据段之间会有一页填充的事实，而在磁盘上，文本段和数据段是紧挨着的，但是某人可以利用预期的段之间的空间，并将其用作负载的区域。
- en: '![The Silvio padding infection method](img/00007.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Silvio填充感染方法](img/00007.jpeg)'
- en: 'Figure 4.2: The Silvio padding infection layout'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：Silvio填充感染布局
- en: The text padding infection created by Silvio is heavily detailed and documented
    in his VX Heaven paper *Unix ELF parasites and viruses* ([http://vxheaven.org/lib/vsc01.html](http://vxheaven.org/lib/vsc01.html)),
    so for extended reading, by all means check it out.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Silvio在他的VX Heaven论文*Unix ELF寄生体和病毒*中对文本填充感染进行了详细的描述和记录（[http://vxheaven.org/lib/vsc01.html](http://vxheaven.org/lib/vsc01.html)），因此，如果想要深入阅读，请务必查看。
- en: Algorithm for the Silvio .text infection method
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Silvio .text感染方法的算法
- en: Increase `ehdr->e_shoff` by `PAGE_SIZE` in the ELF file header.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在ELF文件头中，将`ehdr->e_shoff`的值增加`PAGE_SIZE`。
- en: 'Locate the text segment `phdr`:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位文本段`phdr`：
- en: 'Modify the entry point to the parasite location:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改寄生体位置的入口点：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Increase `phdr[TEXT].p_filesz` by the length of the parasite.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加`phdr[TEXT].p_filesz`的值，使其等于寄生体的长度。
- en: Increase `phdr[TEXT].p_memsz` by the length of the parasite.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加`phdr[TEXT].p_memsz`的值，使其等于寄生体的长度。
- en: For each `phdr` whose segment is after the parasite, increase `phdr[x].p_offset`
    by `PAGE_SIZE` bytes.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个`phdr`，其段在寄生体之后，增加`phdr[x].p_offset`的值`PAGE_SIZE`字节。
- en: Find the last `shdr` in the text segment and increase `shdr[x].sh_size` by the
    length of the parasite (because this is the section that the parasite will exist
    in).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到文本段中的最后一个`shdr`，并将`shdr[x].sh_size`的值增加寄生体的长度（因为这是寄生体存在的部分）。
- en: For every `shdr` that exists after the parasite insertion, increase `shdr[x].sh_offset`
    by `PAGE_SIZE`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个寄生体插入后存在的`shdr`，增加`shdr[x].sh_offset`的值`PAGE_SIZE`。
- en: Insert the actual parasite code into the text segment at (`file_base + phdr[TEXT].p_filesz`).
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实际寄生体代码插入文本段的位置为（`file_base + phdr[TEXT].p_filesz`）。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The original `p_filesz` value is used in the computation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`p_filesz`值用于计算。
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'It makes more sense to create a new binary that reflects all of the changes
    and then copy it over the old binary. This is what I mean by inserting the parasite
    code: rewriting a new binary that includes the parasite within it.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个反映所有更改的新二进制文件，然后将其复制到旧二进制文件上更有意义。这就是我所说的插入寄生体代码：重写一个包含寄生体的新二进制文件。
- en: A good example of this infection technique being implemented by an ELF virus
    is my *lpv* virus, which was written in 2008\. For the sake of being efficient,
    I will not paste the code here, but it can be found at [http://www.bitlackeys.org/projects/lpv.c](http://www.bitlackeys.org/projects/lpv.c).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实现了这种感染技术的ELF病毒的很好的例子是我的*lpv*病毒，它是在2008年编写的。为了高效，我不会在这里粘贴代码，但可以在[http://www.bitlackeys.org/projects/lpv.c](http://www.bitlackeys.org/projects/lpv.c)找到。
- en: An example of text segment padding infection
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本段填充感染的示例
- en: A text segment padding infection (also referred to as a Silvio infection) can
    best be demonstrated by some example code, where we see how to properly adjust
    the ELF headers before inserting the actual parasite code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 文本段填充感染（也称为Silvio感染）可以通过一些示例代码最好地进行演示，我们可以看到如何在插入实际寄生体代码之前正确调整ELF头文件。
- en: Adjusting the ELF headers
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调整ELF头文件
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Inserting the parasite code
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 插入寄生代码
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Example of using the functions above
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上述函数的使用示例
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The LPV virus
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LPV病毒
- en: The LPV virus uses the Silvio padding infection and is designed for 32-bit Linux
    systems. It is available for download at [http://www.bitlackeys.org/#lpv](http://www.bitlackeys.org/#lpv).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: LPV病毒使用Silvio填充感染，并且专为32位Linux系统设计。可在[http://www.bitlackeys.org/#lpv](http://www.bitlackeys.org/#lpv)下载。
- en: Use cases for the Silvio padding infection
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Silvio填充感染的用例
- en: The Silvio padding infection method discussed is very popular and has as such
    been used a lot. The implementation of this method on 32-bit UNIX systems is limited
    to a parasite of 4,096 bytes, as mentioned earlier. On newer systems where large
    pages are used, this infection method has a lot more potential and allows much
    larger infections (upto 0x200000 bytes). I have personally used this method for
    parasite infection and relocatable code injection, although I have ditched it
    in favor of the reverse text infection method, which we will discuss next.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论的Silvio填充感染方法非常流行，并且已经被广泛使用。在32位UNIX系统上，此方法的实现仅限于4096字节的寄生体，如前所述。在使用大页的新系统上，这种感染方法具有更大的潜力，并允许更大的感染（最多0x200000字节）。我个人使用了这种方法进行寄生体感染和可重定位代码注入，尽管我已经放弃了它，转而使用我们接下来将讨论的反向文本感染方法。
- en: The reverse text infection
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向文本感染
- en: This idea behind this infection was originally conceived and documented by Silvio
    in his UNIX viruses paper, but it did not provide a working POC. I have since
    extended this into an algorithm that I have used for a variety of ELF hacking
    projects, including my software protection product *Mayas Veil*, which is discussed
    at [http://www.bitlackeys.org/#maya](http://www.bitlackeys.org/#maya).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种感染的理念最初是由Silvio在他的UNIX病毒论文中构思和记录的，但它没有提供一个可工作的POC。我后来将其扩展为一种算法，我用于各种ELF黑客项目，包括我的软件保护产品*Mayas
    Veil*，该产品在[http://www.bitlackeys.org/#maya](http://www.bitlackeys.org/#maya)中有讨论。
- en: The premise behind this method is to extend the text segment in reverse. In
    doing this, the virtual address of the text will be reduced by `PAGE_ALIGN` (`parasite_size`).
    And since the smallest virtual mapping address allowed (as per `/proc/sys/vm/mmap_min_addr`)
    on modern Linux systems is 0x1000, the text virtual address can be extended backwards
    only that far. Fortunately, since the default text virtual address on a 64-bit
    system is usually 0x400000, this leaves room for a parasite of 0x3ff000 bytes
    (minus another `sizeof(ElfN_Ehdr)` bytes, to be exact).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的前提是以反向方式扩展文本段。通过这样做，文本的虚拟地址将减少`PAGE_ALIGN`(`parasite_size`)。由于现代Linux系统上允许的最小虚拟映射地址（根据`/proc/sys/vm/mmap_min_addr`）是0x1000，文本虚拟地址只能向后扩展到那里。幸运的是，由于64位系统上默认的文本虚拟地址通常是0x400000，这留下了0x3ff000字节的寄生空间（减去`sizeof(ElfN_Ehdr)`字节，确切地说）。
- en: 'The complete formula to calculate the maximum parasite size for a host executable
    would be this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 计算主机可执行文件的最大寄生大小的完整公式将是这样的：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'On 32-bit systems, the default text virtual address is 0x08048000, which leaves
    room for an even larger parasite than on a 64-bit system:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在32位系统上，默认的文本虚拟地址是0x08048000，这比64位系统上的寄生空间更大：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![The reverse text infection](img/00008.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![反向文本感染](img/00008.jpeg)'
- en: 'Figure 4.3: The reverse text infection layout'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：反向文本感染布局
- en: 'There are several attractive features to this `.text` infection: not only does
    it allow extremely large code injections, but it also allows for the entry point
    to remain pointing to the `.text` section. Although we must modify the entry point,
    it will still be pointing to the actual `.text` section rather than another section
    such as `.jcr` or `.eh_frame`, which would immediately look suspicious. The insertion
    spot is in the text, so it is executable (like the Silvio padding infection).
    This beats data segment infections, which allow unlimited insertion space but
    require altering the segment permissions on NX-bit enabled systems.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`.text`感染有几个吸引人的特点：它不仅允许非常大的代码注入，而且还允许入口点保持指向`.text`部分。虽然我们必须修改入口点，但它仍然指向实际的`.text`部分，而不是其他部分，比如`.jcr`或`.eh_frame`，这会立即显得可疑。插入点在文本中，因此它是可执行的（就像Silvio填充感染一样）。这打败了数据段感染，它允许无限的插入空间，但需要在启用NX位的系统上修改段权限。
- en: Algorithm for reverse text infection
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反向文本感染算法
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This makes a reference to the `PAGE_ROUND(x)` macro and rounds an integer up
    to the next PAGE aligned value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对`PAGE_ROUND(x)`宏的引用，它将整数舍入到下一个页面对齐的值。
- en: Increase `ehdr->e_shoff` by `PAGE_ROUND(parasite_len)`.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`PAGE_ROUND(parasite_len)`增加`ehdr->e_shoff`。
- en: 'Find the text segment, `phdr`, and save the original `p_vaddr`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到文本段、`phdr`，并保存原始的`p_vaddr`：
- en: Decrease `p_vaddr` by `PAGE_ROUND(parasite_len)`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`PAGE_ROUND(parasite_len)`减少`p_vaddr`。
- en: Decrease `p_paddr` by `PAGE_ROUND(parasite_len)`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`PAGE_ROUND(parasite_len)`减少`p_paddr`。
- en: Increase `p_filesz` by `PAGE_ROUND(parasite_len)`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`PAGE_ROUND(parasite_len)`增加`p_filesz`。
- en: Increase `p_memsz` by `PAGE_ROUND(parasite_len)`.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`PAGE_ROUND(parasite_len)`增加`p_memsz`。
- en: Find every `phdr` whose `p_offset` is greater than the text's `p_offset` and
    increase `p_offset` by `PAGE_ROUND(parasite_len);` this will shift them all forward,
    making room for the reverse text extension.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到每个`phdr`，其`p_offset`大于文本的`p_offset`，并通过`PAGE_ROUND(parasite_len)`增加`p_offset`；这将使它们全部向前移动，为反向文本扩展腾出空间。
- en: 'Set `ehdr->e_entry` to this:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ehdr->e_entry`设置为这个值：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Increase `ehdr->e_phoff` by `PAGE_ROUND(parasite_len)`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`PAGE_ROUND(parasite_len)`增加`ehdr->e_phoff`。
- en: Insert the actual parasite code by creating a new binary to reflect all of these
    changes and copy the new binary over the old.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个新的二进制文件来插入实际的寄生代码，以反映所有这些变化，并将新的二进制文件复制到旧的位置。
- en: A complete example of the reverse text infection method can be found on my website
    at [http://www.bitlackeys.org/projects/text-infector.tgz](http://www.bitlackeys.org/projects/text-infector.tgz).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 反向文本感染方法的完整示例可以在我的网站上找到：[http://www.bitlackeys.org/projects/text-infector.tgz](http://www.bitlackeys.org/projects/text-infector.tgz)。
- en: 'An even better example of the reverse text infection is used in the Skeksi
    virus, which can be downloaded from the link provided earlier in this chapter.
    A complete disinfection program for this type of infection is also available here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 反向文本感染的更好示例是Skeksi病毒，可以从本章前面提供的链接中下载。这种感染类型的完整消毒程序也可以在这里找到：
- en: '[http://www.bitlackeys.org/projects/skeksi_disinfect.c](http://www.bitlackeys.org/projects/skeksi_disinfect.c).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.bitlackeys.org/projects/skeksi_disinfect.c](http://www.bitlackeys.org/projects/skeksi_disinfect.c)。'
- en: Data segment infections
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据段感染
- en: On systems that do not have the NX bit set, such as 32-bit Linux systems, one
    can execute code in the data segment (even though its permissions are R+W) without
    having to change the segment permissions. This can be a really nice way to infect
    a file, because it leaves infinite room for the parasite. One can simply append
    to the data segment with the parasite code. The only caveat to this is that you
    must leave room for the `.bss` section. The `.bss` section takes up no room on
    disk but is allocated space at the end of the data segment at runtime for uninitialized
    variables. You may get the size of what the `.bss` section will be in memory by
    subtracting the data segment's `phdr->p_filesz` from its `phdr->p_memsz`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有设置NX位的系统上，例如32位Linux系统，可以在数据段中执行代码（即使其权限是R+W），而无需更改段权限。这可以是感染文件的一种非常好的方式，因为它为寄生虫留下了无限的空间。可以简单地通过寄生代码附加到数据段。唯一的注意事项是，您必须为`.bss`部分留出空间。`.bss`部分在磁盘上不占用空间，但在运行时为未初始化的变量在数据段末尾分配空间。您可以通过将数据段的`phdr->p_filesz`从`phdr->p_memsz`中减去来获得`.bss`部分在内存中的大小。
- en: '![Data segment infections](img/00009.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![数据段感染](img/00009.jpeg)'
- en: 'Figure 4.4: Data segment infection'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：数据段感染
- en: Algorithm for data segment infection
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据段感染算法
- en: Increase `ehdr->e_shoff` by the parasite size.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过寄生大小增加`ehdr->e_shoff`。
- en: 'Locate the data segment `phdr`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位数据段`phdr`：
- en: 'Modify `ehdr->e_entry` to point where parasite code will be:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`ehdr->e_entry`，指向寄生代码的位置：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Increase `phdr->p_filesz` by the parasite size.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过寄生大小增加`phdr->p_filesz`。
- en: Increase `phdr->p_memsz` by the parasite size.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过寄生大小增加`phdr->p_memsz`。
- en: Adjust the `.bss` section header so that its offset and address reflect where
    the parasite ends.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整`.bss`段头，使其偏移和地址反映寄生结束的位置。
- en: 'Set executable permissions on data segment:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据段上设置可执行权限：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Step 4 only applies to systems with the NX (non-executable pages) bit set. On
    32-bit Linux, the data segment doesn't require to be marked executable in order
    to execute code unless something like PaX ([https://pax.grsecurity.net/](https://pax.grsecurity.net/))
    is installed in the kernel.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤4仅适用于具有NX（不可执行页面）位设置的系统。在32位Linux上，数据段不需要标记为可执行以执行代码，除非内核中安装了类似PaX（[https://pax.grsecurity.net/](https://pax.grsecurity.net/)）的东西。
- en: Optionally, add a section header with a fake name to account for your parasite
    code. Otherwise, if someone runs `/usr/bin/strip <infected_program>` it will remove
    the parasite code completely if it's not accounted for by a section.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，添加一个带有虚假名称的段头，以便考虑寄生代码。否则，如果有人运行`/usr/bin/strip <infected_program>`，它将完全删除寄生代码，如果没有被一个部分考虑到。
- en: Insert the parasite by creating a new binary that reflects the changes and includes
    the parasite code.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个反映更改并包含寄生代码的新二进制文件来插入寄生虫。
- en: Data segment infections serve well for scenarios that aren't necessarily virus-specific
    as well. For instance, when writing packers, it is often useful to store the encrypted
    executable within the data segment of the stub executable.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 数据段感染对于并非特定于病毒的情况非常有用。例如，在编写打包程序时，通常有用的是将加密的可执行文件存储在存根可执行文件的数据段中。
- en: The PT_NOTE to PT_LOAD conversion infection method
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PT_NOTE到PT_LOAD转换感染方法
- en: 'This method is extremely powerful and, although easily detectable, is also
    relatively easy to implement and provides reliable code insertion. The idea is
    to convert the `PT_NOTE` segment to the `PT_LOAD` type and move its position to
    go after all of the other segments. Of course, you could also just create an entirely
    new segment by creating a `PT_LOAD phdr` entry, but since a program will still
    execute without a `PT_NOTE` segment, you might as well convert it to `PT_LOAD`.
    I have not personally implemented this technique for a virus, but I have designed
    a feature in Quenya v0.1 that allows you to add a new segment. I also did an analysis
    of the Retaliation Linux virus authored by Jpanic, which uses this method for
    infection:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常强大，尽管很容易被检测到，但实现起来也相对容易，并提供可靠的代码插入。其思想是将`PT_NOTE`段转换为`PT_LOAD`类型，并将其位置移动到所有其他段之后。当然，您也可以通过创建一个`PT_LOAD
    phdr`条目来创建一个全新的段，但由于程序仍然可以在没有`PT_NOTE`段的情况下执行，您可能会将其转换为`PT_LOAD`。我个人没有为病毒实现过这种技术，但我在Quenya
    v0.1中设计了一个允许您添加新段的功能。我还对Jpanic编写的Retaliation Linux病毒进行了分析，该病毒使用了这种感染方法：
- en: '[http://www.bitlackeys.org/#retaliation](http://www.bitlackeys.org/#retaliation).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.bitlackeys.org/#retaliation](http://www.bitlackeys.org/#retaliation)。'
- en: '![The PT_NOTE to PT_LOAD conversion infection method](img/00010.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![PT_NOTE到PT_LOAD转换感染方法](img/00010.jpeg)'
- en: 'Figure 4.5: PT_LOAD infection'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：PT_LOAD感染
- en: There are no strict rules about the `PT_LOAD` infection. As mentioned here,
    you may convert `PT_NOTE` into `PT_LOAD` or create an entirely new `PT_LOAD` `phdr`
    and segment.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`PT_LOAD`感染没有严格的规则。如此处所述，您可以将`PT_NOTE`转换为`PT_LOAD`，也可以创建一个全新的`PT_LOAD phdr`和段。
- en: Algorithm for PT_NOTE to PT_LOAD conversion infections
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PT_NOTE到PT_LOAD转换感染算法
- en: 'Locate the data segment `phdr`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位数据段`phdr`：
- en: 'Find the address where the data segment ends:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到数据段结束的地址：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Find the file offset of the end of the data segment:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到数据段结束的文件偏移量：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Get the alignment size used for the loadable segment:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用于可加载段的对齐大小：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Locate the `PT_NOTE` phdr:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位`PT_NOTE` phdr：
- en: 'Convert phdr to PT_LOAD:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将phdr转换为PT_LOAD：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Assign it this starting address:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其分配给这个起始地址：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Assign it a size to reflect the size of your parasite code:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个大小以反映寄生代码的大小：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Use `ehdr->e_shoff += parasite_size` to account for the new segment.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ehdr->e_shoff += parasite_size`来考虑新段。
- en: Insert the parasite code by writing a new binary to reflect the ELF header changes
    and new segment.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编写一个新的二进制文件来插入寄生代码，以反映ELF头更改和新段。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the section header table goes after the parasite segment, hence
    `ehdr->e_shoff += parasite_size`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，段头表在寄生段之后，因此`ehdr->e_shoff += parasite_size`。
- en: Infecting control flow
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 感染控制流
- en: 'In the previous section, we examined the methods in which parasite code can
    be introduced into a binary and then executed by modifying the entry point of
    the infected program. As far as introducing new code into a binary goes, these
    methods work excellently; in fact, they are great for binary patching, whether
    it be for legitimate engineering reasons or for a virus. Modifying the entry point
    is also quite suitable in many cases, but it is far from stealthy, and in some
    cases, you may not want your parasite code to execute at entry time. Perhaps your
    parasite code is a single function that you infected a binary with and you only
    want this function to be called as a replacement for another function within the
    binary that it infected; this is called function hijacking. When intending to
    pursue more intricate infection strategies, we must be aware of all of the possible
    infection points in an ELF program. This is where things begin to get real interesting.
    Let''s take a look at many of the common ELF binary infection points:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们研究了将寄生代码引入二进制文件并通过修改感染程序的入口点执行的方法。就引入新代码到二进制文件中而言，这些方法非常有效；实际上，它们非常适合二进制修补，无论是出于合法的工程原因还是出于病毒的目的。修改入口点在许多情况下也是相当合适的，但远非隐秘，而且在某些情况下，您可能不希望寄生代码在入口时执行。也许您的寄生代码是一个您感染了二进制文件的单个函数，您只希望这个函数作为替换其感染的二进制文件中的另一个函数被调用；这被称为函数劫持。当打算追求更复杂的感染策略时，我们必须意识到ELF程序中所有可能的感染点。这就是事情开始变得真正有趣的地方。让我们看看许多常见的ELF二进制感染点：
- en: '![Infecting control flow](img/00011.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![感染控制流](img/00011.jpeg)'
- en: 'Figure 4.6: ELF infection points'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：ELF感染点
- en: As shown in the preceding figure, there are six other primary areas in the ELF
    program that can be manipulated to modify the behavior in some way.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，ELF程序中还有其他六个主要区域可以被操纵以在某种程度上修改行为。
- en: Direct PLT infection
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接PLT感染
- en: Do not confuse this with PLT/GOT (sometimes called PLT hooks). The PLT (procedure
    linkage table) and GOT (global offset table) work closely in conjunction during
    dynamic linking and through shared library function calls. They are two separate
    sections, though. We learned about them in the *Dynamic linking* section of Chapter
    2, *The ELF Binary Format*. As a quick refresher, the PLT contains an entry for
    every shared library function. Each entry contains code that performs an indirect
    `jmp` to a destination address that is stored in the GOT. These addresses eventually
    point to their associated shared library function once the dynamic linking process
    has been completed. Usually, it is practical for an attacker to overwrite the
    GOT entry containing the address that points to his or her code. This is practical
    because it is easiest; the GOT is writable, and one must only modify its table
    of addresses to change the control flow. When discussing direct PLT infection,
    we are not referring to modifying the GOT, though. We are talking about actually
    modifying the PLT code so that it contains a different instruction to alter the
    control flow.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将其与PLT/GOT（有时称为PLT挂钩）混淆。 PLT（过程链接表）和GOT（全局偏移表）在动态链接和共享库函数调用期间密切配合工作。它们是两个单独的部分。我们在第2章*ELF二进制格式*的*动态链接*部分学习了它们。简单地说，PLT包含每个共享库函数的条目。每个条目包含执行间接`jmp`到存储在GOT中的目标地址的代码。一旦动态链接过程完成，这些地址最终指向其关联的共享库函数。通常，攻击者可以覆盖包含指向其代码的地址的GOT条目。这是可行的，因为它最容易；GOT是可写的，只需修改其地址表即可改变控制流。当讨论直接PLT感染时，我们并不是指修改GOT。我们谈论的是实际修改PLT代码，使其包含不同的指令以改变控制流。
- en: 'The following is the code for a PLT entry for the `libc fopen()` function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`libc fopen()`函数的PLT条目的代码：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice that the first instruction is an indirect jump. The instruction is six
    bytes long: this could easily be replaced with another five/six-byte instruction
    that changes the control flow to the parasite code. Consider the following instructions:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一条指令是一个间接跳转。该指令长度为六个字节：这很容易被另一个五/六字节的指令替换，以改变控制流到寄生代码。考虑以下指令：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These instructions are encoded as `\x68\x00\x00\x00\x00\xc3`, which could be
    injected into the PLT entry to hijack all `fopen()` calls with a parasite function
    (whatever that might be). Since the `.plt` section is in the text segment, it
    is read-only, so this method won't work as a technique for exploiting vulnerabilities
    (such as `.got` overwriting), but it is absolutely possible to implement with
    a virus or a memory infection.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令被编码为`\x68\x00\x00\x00\x00\xc3`，可以被注入到PLT条目中，以劫持所有`fopen()`调用并使用寄生函数（无论是什么）。由于`.plt`部分位于文本段中，它是只读的，因此这种方法不适用于利用漏洞（如`.got`覆盖）的技术，但绝对可以用病毒或内存感染来实现。
- en: Function trampolines
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数跳板
- en: 'This type of infection certainly falls into the last category of direct PLT
    infection, but to be specific with our terminology, let me describe what a traditional
    function trampoline usually refers to, which is overwriting the first five to
    seven bytes of a function''s code with some type of branch instruction that changes
    the control flow:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的感染显然属于直接PLT感染的最后一类，但为了明确我们的术语，让我描述一下传统函数跳板通常指的是什么，即用某种分支指令覆盖函数代码的前五到七个字节，以改变控制流：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The parasite function is then called instead of the intended function. If the
    parasite function needs to call the original function, which is often the case,
    then it is the job of the parasite function to replace those five to seven bytes
    in the original function with the original instructions, call it, and then copy
    the trampoline code back into place. This method can be used both by applying
    it in the actual binary itself or in memory. This technique is commonly used when
    hijacking kernel functions, although it is not very safe in multithreaded environments.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 寄生函数被调用，而不是预期的函数。如果寄生函数需要调用原始函数，这通常是情况，那么寄生函数的工作就是用原始指令替换原始函数中的五到七个字节，调用它，然后将跳板代码复制回原位。这种方法既可以应用于实际的二进制文件本身，也可以应用于内存中。这种技术通常用于劫持内核函数，尽管在多线程环境中并不是很安全。
- en: Overwriting the .ctors/.dtors function pointers
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖.ctors/.dtors函数指针
- en: 'This method was actually mentioned earlier in this chapter when discussing
    the challenges of directing the control flow of execution to the parasite code.
    For the sake of completeness, I will give a recap of it: Most executables are
    compiled by linking to `libc`, and so `gcc` includes `glibc` initialization code
    in compiled executables and shared libraries. The `.ctors` and `.dtors` sections
    (sometimes called `.init_array` and `.fini_array`) contain function pointers to
    initialization or finalization code. The `.ctors/.init_array` function pointers
    are triggered before `main()` is ever called. This means that one can transfer
    control to their virus or parasite code by overwriting one of the function pointers
    with the proper address. The `.dtors/.fini_array` function pointers are not triggered
    until after `main()`, which can be desirable in some cases. For instance, certain
    heap overflow vulnerabilities (for example, *Once upon a free*: [http://phrack.org/issues/57/9.html](http://phrack.org/issues/57/9.html))
    result in allowing the attacker to write four bytes to any location, and often
    will overwrite a `.dtors` function pointer with an address that points to shellcode.
    In the case of most virus or malware authors, the `.ctors/.init_array` function
    pointers are more commonly the target, since it is usually desirable to get the
    parasite code to run before the rest of the program.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法实际上在本章早些时候提到过，当讨论将执行控制流引导到寄生代码时。为了完整起见，我将对其进行回顾：大多数可执行文件都是通过链接到`libc`来编译的，因此`gcc`在编译的可执行文件和共享库中包含了`glibc`初始化代码。`.ctors`和`.dtors`部分（有时称为`.init_array`和`.fini_array`）包含初始化或终结代码的函数指针。`.ctors/.init_array`函数指针在调用`main()`之前触发。这意味着可以通过覆盖其中一个函数指针的正确地址来将控制转移到病毒或寄生代码。`.dtors/.fini_array`函数指针直到`main()`之后才触发，在某些情况下可能是可取的。例如，某些堆溢出漏洞（例如，*一旦释放*：[http://phrack.org/issues/57/9.html](http://phrack.org/issues/57/9.html)）会导致攻击者可以向任何位置写入四个字节，并且通常会覆盖一个指向shellcode的`.dtors`函数指针的地址。对于大多数病毒或恶意软件作者来说，`.ctors/.init_array`函数指针更常见，因为通常希望在程序的其余部分运行之前运行寄生代码。
- en: GOT – global offset table poisoning or PLT/GOT redirection
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GOT - 全局偏移表中毒或PLT/GOT重定向
- en: Also called PLT/GOT infection, GOT poisoning is probably the best way to hijack
    shared library functions. It is relatively easy and allows attackers to make good
    use of the GOT, which is a table of pointers. Since we discussed the GOT in depth
    in the dynamic linking section in [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*, I won't elaborate
    more on its purpose. This technique can be applied by infecting a binary's GOT
    directly or simply doing it in memory. There is a paper about doing this in memory
    that I wrote in 2009 called *Modern Day ELF Runtime infection via GOT poisoning*
    at [http://vxheaven.org/lib/vrn00.html](http://vxheaven.org/lib/vrn00.html), which
    explains how to do this in runtime process infection and also provides a technique
    that can be used to bypass security restrictions imposed by PaX.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: GOT中毒，也称为PLT/GOT感染，可能是劫持共享库函数的最佳方法。这相对容易，并允许攻击者充分利用GOT，这是一个指针表。由于我们在[第2章](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "第2章。ELF二进制格式")中深入讨论了GOT，*ELF二进制格式*，我不会再详细说明它的目的。这种技术可以通过直接感染二进制文件的GOT或在内存中进行。有一篇关于我在2009年写的关于在内存中进行这种操作的论文，名为*现代ELF运行时感染通过GOT中毒*，网址为[http://vxheaven.org/lib/vrn00.html](http://vxheaven.org/lib/vrn00.html)，其中解释了如何在运行时进程感染中进行这种操作，并提供了一种可以用来绕过PaX强加的安全限制的技术。
- en: Infecting data structures
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 感染数据结构
- en: 'The data segment of an executable contains global variables, function pointers,
    and structures. This opens up an attack vector that is isolated to specific executables,
    as each program has a different layout in the data segment: different variables,
    structures, function pointers, and so on. Nonetheless, if an attacker is aware
    of the layout, one can manipulate them by overwriting function pointers and other
    data to change the behavior of the executable. One good example of this is with
    data/`.bss` buffer overflow exploits. As we learned in [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*, `.bss` is allocated
    at runtime (at the end of the data segment) and contains uninitialized global
    variables. If someone were able to overflow a buffer that contained a path to
    an executable that is executed, then one could control which executable would
    be run.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件的数据段包含全局变量、函数指针和结构。这打开了一个攻击向量，只针对特定的可执行文件，因为每个程序在数据段中有不同的布局：不同的变量、结构、函数指针等。尽管如此，如果攻击者了解布局，就可以通过覆盖函数指针和其他数据来改变可执行文件的行为。一个很好的例子是数据/`.bss`缓冲区溢出利用。正如我们在[第2章](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "第2章。ELF二进制格式")中学到的，`.bss`在运行时分配（在数据段的末尾），包含未初始化的全局变量。如果有人能够溢出一个包含要执行的可执行文件路径的缓冲区，那么就可以控制要运行的可执行文件。
- en: Function pointer overwrites
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数指针覆盖
- en: This technique really falls into the last one (infecting data structures) and
    also into the one pertaining to `.ctors/.dtors` function pointer overwrites. For
    the sake of completeness, I have it listed it as its own technique, but essentially,
    these pointers are going to be in the data segment and in `.bss` (initialized/uninitialized
    static data). As we've already talked about, one can overwrite a function pointer
    to change the control flow so that it points to the parasite.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术实际上属于最后一种（感染数据结构），也属于与`.ctors/.dtors`函数指针覆写相关的技术。为了完整起见，我将其列为自己的技术，但基本上，这些指针将位于数据段和`.bss`（初始化/未初始化的静态数据）中。正如我们已经讨论过的，可以覆盖函数指针以改变控制流，使其指向寄生体。
- en: Process memory viruses and rootkits – remote code injection techniques
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程内存病毒和rootkit - 远程代码注入技术
- en: Up until now, we've covered the fundamentals of infecting ELF binaries with
    parasite code, which is enough to keep you busy for at least several months of
    coding and experimentation. This chapter would not be complete, though, without
    a thorough discussion of infecting process memory. As we've learned, a program
    in memory is not much different than it is on disk, and we can access and manipulate
    a running program with the `ptrace` system call, as shown in [Chapter 3](part0027_split_000.html#PNV61-1d4163ae11644cc2802846625b2dc985
    "Chapter 3. Linux Process Tracing"), *Linux Process Tracing*. Process infections
    are a lot more stealthy than binary infections, since they don't modify anything
    on disk. Therefore, process memory infections are usually an attempt at defeating
    forensic analysis. All of the ELF infection points that we just discussed are
    relevant to process infection, although injecting actual parasite code is done
    differently than it is with an ELF binary. Since it is in memory, we must get
    the parasite code into memory, which can be done by injecting it directly with
    `PTRACE_POKETEXT` (overwriting existing code) or, more preferably, by injecting
    shellcode that creates a new memory mapping to store the code. This is where things
    such as shared library injection come into play. Throughout the rest of this chapter,
    we will discuss some methods for remote code injection (injecting code into another
    process).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了用寄生代码感染ELF二进制文件的基础知识，这足以让你忙碌至少几个月的编码和实验。然而，本章将不完整，如果没有对感染进程内存进行彻底讨论。正如我们所了解的，内存中的程序与磁盘上的程序并没有太大的区别，我们可以通过`ptrace`系统调用来访问和操作运行中的程序，就像[第3章](part0027_split_000.html#PNV61-1d4163ae11644cc2802846625b2dc985
    "第3章. Linux进程跟踪") *Linux进程跟踪*中所示的那样。进程感染比二进制感染更加隐蔽，因为它们不会修改磁盘上的任何内容。因此，进程内存感染通常是为了对抗取证分析。我们刚刚讨论的所有ELF感染点都与进程感染相关，尽管注入实际的寄生代码与ELF二进制文件的方式不同。由于它在内存中，我们必须将寄生代码注入内存，可以通过使用`PTRACE_POKETEXT`（覆盖现有代码）直接注入，或者更好地，通过注入创建新内存映射以存储代码的shellcode。这就是共享库注入等技术发挥作用的地方。在本章的其余部分，我们将讨论一些远程代码注入的方法。
- en: Shared library injection – .so injection/ET_DYN injection
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享库注入 - .so注入/ET_DYN注入
- en: This technique can be used to inject a shared library (whether malicious or
    not) into an existing process' address space. Once the library is injected, you
    may use one of the infection points described earlier to redirect control flow
    to the shared library through PLT/GOT redirection, function trampolines, and so
    on. The challenge is getting the shared library into the process, and this can
    be done in a number of ways.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可以用来将共享库（无论是恶意的还是不恶意的）注入到现有进程的地址空间中。一旦库被注入，你可以使用前面描述的感染点之一，通过PLT/GOT重定向、函数跳板等方式将控制流重定向到共享库。挑战在于将共享库注入到进程中，这可以通过多种方式来实现。
- en: .so injection with LD_PRELOAD
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .so注入与LD_PRELOAD
- en: It is debatable whether we can actually call this method for injecting a shared
    library into a process is debatable injection, since it does not work on existing
    processes but rather the shared library is loaded upon execution of the program.
    This works by setting the `LD_PRELOAD` environment variable so that the desired
    shared library is loaded with precedence before any others. This can be a good
    way to quickly test subsequent techniques such as PLT/GOT redirection, but is
    not stealthy and does not work on existing processes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 关于将共享库注入进程的方法是否可以称为注入，存在争议，因为它不适用于现有进程，而是在程序执行时加载共享库。这是通过设置`LD_PRELOAD`环境变量，以便所需的共享库在任何其他库之前加载。这可能是一个快速测试后续技术（如PLT/GOT重定向）的好方法，但不够隐蔽，也不适用于现有进程。
- en: Illustration 4.7 – using LD_PRELOAD to inject wicked.so.1
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图4.7 - 使用LD_PRELOAD注入wicked.so.1
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, our shared library, `wicked.so.1`, is mapped into the process
    address space. Amateurs tend to use this technique to create little userland rootkits
    that hijack `glibc` functions. This is because the preloaded library will take
    precedence over any of the other shared libraries, so if you name your functions
    the same as a `glibc` function such as `open()` or `write()` (which are wrappers
    for syscalls), then your preloaded libraries' version of the functions will execute
    and not the real `open()` and `write()`. This is a cheap and dirty way to hijack
    `glibc` functions and should not be used if an attacker wishes to remain stealthy.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们的共享库`wicked.so.1`被映射到进程地址空间中。业余爱好者倾向于使用这种技术来创建小型用户空间rootkit，劫持`glibc`函数。这是因为预加载的库将优先于任何其他共享库，因此，如果你将函数命名为`glibc`函数的名称，比如`open()`或`write()`（它们是系统调用的包装器），那么你预加载的库的版本的函数将被执行，而不是真正的`open()`和`write()`。这是一种廉价而肮脏的劫持`glibc`函数的方法，如果攻击者希望保持隐蔽，就不应该使用这种方法。
- en: .so injection with open()/mmap() shellcode
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .so注入与open()/mmap() shellcode
- en: This is a way to load any file (including shared libraries) into the process
    address space by injecting shellcode (using `ptrace`) into an existing process'
    text segment and then executing it to perform `open/mmap` on a shared library
    into the process. We demonstrated this in [Chapter 3](part0027_split_000.html#PNV61-1d4163ae11644cc2802846625b2dc985
    "Chapter 3. Linux Process Tracing"), *Linux Process Tracing*, with our `code_inject.c`
    example, which loaded a very simple executable into the process. That same code
    could be used to load a shared library in as well. The problem with this technique
    is that most shared libraries that you will want to inject will require relocations.
    The `open()/mmap()` functions will only load the file into memory but won't handle
    code relocations, so mostly any shared library that you will want to load won't
    properly execute unless it's completely position-independent code. At this point,
    you could choose to manually handle the relocations by parsing the shared libraries'
    relocations and applying them in memory using `ptrace()`. Fortunately, an easier
    solution exists, which we will discuss next.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种通过将shellcode（使用`ptrace`）注入到现有进程的文本段中并执行它来将任何文件（包括共享库）加载到进程地址空间的方法。我们在[第3章](part0027_split_000.html#PNV61-1d4163ae11644cc2802846625b2dc985
    "第3章。Linux进程跟踪")，“Linux进程跟踪”中演示了这一点，我们的`code_inject.c`示例加载了一个非常简单的可执行文件到进程中。同样的代码也可以用来加载共享库。这种技术的问题是，大多数您想要注入的共享库都需要重定位。`open()/mmap()`函数只会将文件加载到内存中，但不会处理代码重定位，因此大多数您想要加载的共享库除非是完全位置无关的代码，否则不会正确执行。在这一点上，您可以选择通过解析共享库的重定位并使用`ptrace()`在内存中应用它们来手动处理重定位。幸运的是，还有一个更简单的解决方案，我们将在下面讨论。
- en: .so injection with dlopen() shellcode
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .so注入与dlopen() shellcode
- en: 'The `dlopen()` function is used to dynamically load shared libraries that an
    executable wasn''t linked with in the first place. Developers often use this as
    a way to create plugins for their applications in the form of shared libraries.
    A program can call `dlopen()` to load a shared library on the fly, and it actually
    invokes the dynamic linker to perform all of the relocations for you. There is
    a problem, though: most processes do not have `dlopen()` available to them, because
    it exists in `libdl.so.2`, and a program must be explicitly linked to `libdl.so.2`
    in order to invoke `dlopen()`. Fortunately, there is also a solution to this:
    almost every single program has `libc.so` mapped into the process address space
    by default (unless it was explicitly compiled otherwise) and `libc.so` has an
    equivalent to `dlopen()` called `__libc_dlopen_mode()`. This function is used
    almost in the exact same way, but it requires a special flag be set:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`dlopen()`函数用于动态加载可执行文件最初未链接的共享库。开发人员经常使用这种方式为其应用程序创建插件形式的共享库。程序可以调用`dlopen()`来动态加载共享库，并实际上调用动态链接器为您执行所有重定位。不过，存在一个问题：大多数进程没有`dlopen()`可用，因为它存在于`libdl.so.2`中，程序必须显式链接到`libdl.so.2`才能调用`dlopen()`。幸运的是，也有解决方案：几乎每个程序默认在进程地址空间中映射了`libc.so`（除非显式编译为其他方式），而`libc.so`具有与`dlopen()`相当的`__libc_dlopen_mode()`。这个函数几乎以完全相同的方式使用，但需要设置一个特殊的标志：'
- en: '[PRE24]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This isn't much of a hurdle. But prior to using `__libc_dlopen_mode()`, you
    must first resolve it remotely by getting the base address of `libc.so` in the
    process you want to infect, resolve the symbol for `__libc_dlopen_mode()`, and
    then add the symbol value `st_value` (refer to [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*) to the base address
    of `libc` to get the final address of `__libc_dlopen_mode()`. You can then design
    some shellcode in C or assembly that calls `__libc_dlopen_mode()` to load your
    shared library into the process, with full relocations and ready to execute. The
    `__libc_dlsym()` function can then be used to resolve symbols within your shared
    library. See the `dlopen` manpages for more details on using `dlopen()` and `dlsym()`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是什么大问题。但在使用`__libc_dlopen_mode()`之前，您必须首先通过获取要感染的进程中`libc.so`的基址，解析`__libc_dlopen_mode()`的符号，然后将符号值`st_value`（参见[第2章](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "第2章。ELF二进制格式")，“ELF二进制格式”）添加到`libc`的基址，以获取`__libc_dlopen_mode()`的最终地址。然后，您可以设计一些以C或汇编调用`__libc_dlopen_mode()`的shellcode，将您的共享库加载到进程中，具有完整的重定位并准备执行。然后可以使用`__libc_dlsym()`函数来解析共享库中的符号。有关使用`dlopen()`和`dlsym()`的更多详细信息，请参阅`dlopen`手册页。
- en: Illustration 4.8 – C code invoking __libc_dlopen_mode()
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图4.8 - 调用__libc_dlopen_mode()的C代码
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It is very much worth noting that `dlopen()` will load PIE executables too.
    This means that you can inject a complete program into a process and run it. In
    fact, you can run as many programs as you want in a single process. This is an
    incredible anti-forensics technique, and when using thread injection, you can
    run them all concurrently so that they execute at the same time. Saruman is a
    PoC software that I designed to do this. It uses two possible methods of injection:
    the `open()/mmap()` method with manual relocations or the `__libc_dlopen_mode()`
    method. This is available on my site at [http://www.bitlackeys.org/#saruman](http://www.bitlackeys.org/#saruman).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 非常值得注意的是，`dlopen()`也会加载PIE可执行文件。这意味着您可以将完整的程序注入到进程中并运行它。实际上，您可以在单个进程中运行尽可能多的程序。这是一种令人难以置信的反取证技术，当使用线程注入时，您可以同时运行它们，以便它们同时执行。Saruman是我设计的一个PoC软件，用于执行此操作。它使用两种可能的注入方法：具有手动重定位的`open()/mmap()`方法或`__libc_dlopen_mode()`方法。这在我的网站[http://www.bitlackeys.org/#saruman](http://www.bitlackeys.org/#saruman)上可用。
- en: .so injection with VDSO manipulation
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .so注入与VDSO操作
- en: This is a technique that I discussed in my paper at [http://vxheaven.org/lib/vrn00.html](http://vxheaven.org/lib/vrn00.html).
    The idea is to manipulate the **virtual dynamic shared object** (**VDSO**), which
    is mapped into every process address space in Linux since kernel version 2.6.x.
    The VDSO contains code to speed up system calls, and they can be invoked directly
    from the VDSO. The trick is to locate the code that invokes syscalls by using
    `PTRACE_SYSCALL`, which will break once it lands on this code. The attacker can
    then load `%eax/%rax` with the desired syscall number and store the arguments
    in the other registers, following the proper calling convention for Linux x86
    system calls. This is surprisingly easy and can be used to call the `open()/mmap()`
    method without having to inject any shellcode. This can be useful for bypassing
    PaX, which prevents a user from injecting code into the text segment. I recommend
    reading my paper for a complete dissertation on the technique.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在[http://vxheaven.org/lib/vrn00.html](http://vxheaven.org/lib/vrn00.html)中论文中讨论的一种技术。这个想法是操纵**虚拟动态共享对象**（**VDSO**），它自Linux内核版本2.6.x以来被映射到每个进程的地址空间中。VDSO包含用于加速系统调用的代码，并且可以直接从VDSO中调用。技巧是通过使用`PTRACE_SYSCALL`来定位调用系统调用的代码，一旦它落在这段代码上就会中断。攻击者可以加载`%eax/%rax`以获取所需的系统调用号，并将参数存储在其他寄存器中，遵循Linux
    x86系统调用的适当调用约定。这是令人惊讶地简单，可以用来调用`open()/mmap()`方法，而无需注入任何shellcode。这对于绕过防止用户将代码注入文本段的PaX非常有用。我建议阅读我的论文，以获得关于这种技术的完整论述。
- en: Text segment code injections
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文本段代码注入
- en: 'This is a simple technique and is not very useful for anything other than injecting
    shellcode, which should then quickly be replaced with the original code once the
    shellcode has finished executing. Another reason you would want to directly modify
    the text segment is to create function trampolines, which we discussed earlier
    in this chapter, or to directly modify the `.plt` code. As far as code injection
    goes, though, it is preferable to load code into the process or create a new memory
    mapping where code can be stored: otherwise, the text segment could easily be
    detected as being modified.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种简单的技术，除了注入shellcode之外，对于其他用途并不是很有用，一旦shellcode执行完毕，应该迅速替换为原始代码。您希望直接修改文本段的另一个原因是创建函数跳板，我们在本章前面讨论过，或者直接修改`.plt`代码。但就代码注入而言，最好的方法是将代码加载到进程中或创建一个新的内存映射，可以在其中存储代码：否则，文本段很容易被检测到被修改。
- en: Executable injections
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可执行文件注入
- en: As mentioned previously, `dlopen()` is capable of loading PIE executables into
    a process, and I even included a link to Saruman, which is the crafty software
    that allows you to run programs within existing processes for anti-forensics measures.
    But what about injecting `ET_EXEC` type executables? This type of executable does
    not provide any relocation information except for dynamic-linking `R_X86_64_JUMP_SLOT/R_386_JUMP_SLOT`
    relocation types. This means that injecting a regular executable into an existing
    process is ultimately going to be unreliable, especially when injecting more complex
    programs. Nevertheless, I created a PoC of this technique called **elfdemon**,
    which maps the executable to some new mappings that don't conflict with the host
    process executable mappings. It then hijacks control (unlike Saruman, which allows
    concurrent execution) and passes control back to the host process once it is done
    running. An example of this can be found at [http://www.bitlackeys.org/projects/elfdemon.tgz](http://www.bitlackeys.org/projects/elfdemon.tgz).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`dlopen()`能够将PIE可执行文件加载到进程中，我甚至还包含了一个链接到Saruman的链接，Saruman是一个巧妙的软件，允许您在现有进程中运行程序以进行反取证措施。但是，如何注入`ET_EXEC`类型的可执行文件呢？这种类型的可执行文件除了动态链接的`R_X86_64_JUMP_SLOT/R_386_JUMP_SLOT`重定位类型之外，不提供任何重定位信息。这意味着将常规可执行文件注入到现有进程中最终将是不可靠的，特别是在注入更复杂的程序时。尽管如此，我创建了一个名为**elfdemon**的这种技术的PoC，它将可执行文件映射到一些新的映射中，这些映射不会与主机进程的可执行文件映射发生冲突。然后它接管控制（与Saruman不同，Saruman允许并发执行），并在运行结束后将控制权传回给主机进程。这方面的示例可以在[http://www.bitlackeys.org/projects/elfdemon.tgz](http://www.bitlackeys.org/projects/elfdemon.tgz)中找到。
- en: Relocatable code injection – the ET_REL injection
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可重定位代码注入 - ET_REL注入
- en: This method is very similar to shared library injection but is not compatible
    with `dlopen(). ET_REL` (`.o` files) are relocatable code, much like `ET_DYN`
    (`.so` files), but they are not meant to be executed as single files; they are
    meant to link into either an executable or a shared library, as discussed in [Chapter
    2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985 "Chapter 2. The
    ELF Binary Format"), *The ELF Binary Format*. This, however, doesn't mean that
    we can't inject them, relocate them, and execute their code. This can be done
    by using any of the techniques described earlier except `dlopen()`. So, `open/mmap`
    is sufficient but requires that you manually handle the relocations, which can
    be done using `ptrace`. In [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*, we gave an example
    of the relocation code in the software that I designed, called **Quenya**. This
    demonstrates how to handle relocations in an object file when injecting it into
    an executable. The same principles can be used when injecting one into a process.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与共享库注入非常相似，但与`dlopen()`不兼容。ET_REL（.o文件）是可重定位代码，与ET_DYN（.so文件）非常相似，但它们不是作为单个文件执行的；它们是用来链接到可执行文件或共享库中的，正如[第2章](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "第2章。ELF二进制格式")中所讨论的，*ELF二进制格式*。然而，这并不意味着我们不能注入它们，重定位它们并执行它们的代码。这可以通过使用之前描述的任何技术来完成，除了`dlopen()`。因此，`open/mmap`是足够的，但需要手动处理重定位，可以使用`ptrace`来完成。在[第2章](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "第2章。ELF二进制格式")中，*ELF二进制格式*，我们给出了我设计的软件**Quenya**中的重定位代码的示例。这演示了如何在将对象文件注入可执行文件时处理重定位。当将其注入到进程中时，可以使用相同的原则。
- en: ELF anti-debugging and packing techniques
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ELF反调试和打包技术
- en: In the next chapter, *Breaking ELF Software Protection*, we will discuss the
    ins and outs of software encryption and packing with ELF executables. Viruses
    and malware are very commonly encrypted or packed with some type of protection
    mechanism, which can also include anti-debugging techniques to make analyzing
    the binary very difficult. Without giving a complete exegesis on the subject,
    here are some common anti-debugging measures taken by ELF binary protectors that
    are commonly used to wrap around malware.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章《ELF软件保护的突破》中，我们将讨论使用ELF可执行文件进行软件加密和打包的细节。病毒和恶意软件通常会使用某种类型的保护机制进行加密或打包，这也可能包括反调试技术，使得分析二进制文件变得非常困难。在不对这个主题进行完整的解释的情况下，以下是一些常见的ELF二进制保护程序采取的反调试措施，这些措施通常用于包装恶意软件。
- en: The PTRACE_TRACEME technique
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PTRACE_TRACEME技术
- en: This technique takes advantage of the fact that a program can only be traced
    by one process at a time. Almost all debuggers use `ptrace`, including GDB. The
    idea is that a program can trace itself so that no other debugger can attach.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术利用了一个程序一次只能被一个进程跟踪的事实。几乎所有调试器都使用`ptrace`，包括GDB。这个想法是一个程序可以跟踪自己，以便没有其他调试器可以附加。
- en: Illustration 4.9 – an anti-debug with PTRACE_TRACEME example
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图4.9 - 使用PTRACE_TRACEME的反调试示例
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The function in *Illustration 4.9* will kill the program (itself) if one is
    attached with a debugger; it will know because it will fail to trace itself. Otherwise,
    it will succeed in tracing itself, and no other tracers will be allowed, preventing
    debuggers.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.9*中的函数将会在调试器附加时终止程序（自身）；它会知道因为它无法跟踪自己。否则，它将成功地跟踪自己，并且不允许其他跟踪器，以防止调试器。'
- en: The SIGTRAP handler technique
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SIGTRAP处理程序技术
- en: While debugging, we often set breakpoints, and when a breakpoint is hit, it
    generates a SIGTRAP signal, which is caught by our debugger's signal handler;
    the program halts and we can inspect it. With this technique, the program sets
    up a signal handler to catch SIGTRAP signals and then deliberately issues a breakpoint
    instruction. When the program's SIGTRAP handler catches it, it will increment
    a global variable from `0` to `1`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试时，我们经常设置断点，当断点被触发时，会生成一个SIGTRAP信号，被我们的调试器信号处理程序捕获；程序会停止，我们可以检查它。通过这种技术，程序设置了一个信号处理程序来捕获SIGTRAP信号，然后故意发出一个断点指令。当程序的SIGTRAP处理程序捕获到它时，它会将一个全局变量从`0`增加到`1`。
- en: 'The program can then check to see whether the global variable is set to `1`,
    if it is, that means that our program caught the breakpoint and there is no debugger
    present; otherwise, if it is `0`, it must have been caught by a debugger. At this
    point, the program can choose to kill itself or exit in order to prevent debugging:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以检查全局变量是否设置为`1`，如果是，那意味着我们的程序捕获了断点，没有调试器存在；否则，如果是`0`，那就是被调试器捕获了。在这一点上，程序可以选择终止自身或退出以防止调试：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The /proc/self/status technique
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: /proc/self/status技术
- en: This dynamic file exists for every process and includes a lot of information,
    including whether or not the process is currently being traced.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动态文件存在于每个进程中，包括很多信息，包括进程当前是否正在被跟踪。
- en: 'An example of the layout of `/proc/self/status`, which can be parsed to detect
    tracers/debuggers, is as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`/proc/self/status`布局的示例，可以解析以检测跟踪器/调试器，如下所示：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As highlighted in the preceding output, `tracerPid: 0` means that the process
    is not being traced. All that a program must do to see whether it is being traced
    is to open `/proc/self/status` and check whether or not the value is 0\. If not,
    then it knows it is being traced and it can kill itself or exit.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '如前面的输出所示，`tracerPid: 0`表示该进程没有被跟踪。一个程序必须做的就是打开`/proc/self/status`，并检查值是否为0，以确定自己是否被跟踪。如果不是，则它知道自己正在被跟踪，可以选择终止自身或退出。'
- en: The code obfuscation technique
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码混淆技术
- en: 'Code obfuscation (also known as code transformation) is a technique where assembly-level
    code is modified to include opaque branch instructions or misaligned instructions
    that throw off the disassembler''s ability to read the bytecode correctly. Consider
    the following example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 代码混淆（也称为代码转换）是一种技术，其中汇编级别的代码被修改以包括不透明的分支指令或不对齐的指令，使得反汇编器无法正确读取字节码。考虑以下示例：
- en: '[PRE29]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When the preceding code is compiled and viewed with the `objdump` disassembler,
    it looks like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当前面的代码被编译并用`objdump`反汇编器查看时，它看起来是这样的：
- en: '[PRE30]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The code is actually doing a `mov $0x31337, %eax` operation, and functionally,
    it performs that correctly, but because there was a single `0xe9` before that,
    the disassembler perceived it as a `jmp` instruction (since `0xe9` is the prefix
    for a `jmp`).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实际上执行了`mov $0x31337, %eax`操作，从功能上讲，它执行得很正确，但因为之前有一个`0xe9`，所以反汇编器将其视为`jmp`指令（因为`0xe9`是`jmp`的前缀）。
- en: So, code transformation doesn't change the way the code functions, only how
    it looks. A smart disassembler such as IDA wouldn't be fooled by the preceding
    code snippet, because it uses control flow analysis when generating the disassembly.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，代码转换不会改变代码的功能，只会改变它的外观。像IDA这样的智能反汇编器不会被前面的代码片段所欺骗，因为它在生成反汇编时使用控制流分析。
- en: The string table transformation technique
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串表转换技术
- en: This is a technique that I conceived in 2008 and have not seen used widely,
    but I would be surprised if it hasn't been used somewhere. The idea behind this
    uses the knowledge we have gained about the ELF string tables for symbol names
    and section headers. Tools such as `objdump` and `gdb` (often used in reverse
    engineering) rely on the string table to learn the names of functions and sections
    within an ELF file. This technique scrambles the order of the name of each symbol
    and section. The result is that section headers will be all mixed up (or appear
    to be) and so will the names of functions and symbols.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在2008年构思的一种技术，我还没有看到广泛使用，但如果它没有在某处使用，我会感到惊讶。这个想法是利用我们对 ELF 字符串表和符号名称以及段头的知识。诸如
    `objdump` 和 `gdb`（经常用于逆向工程）的工具依赖于字符串表来了解 ELF 文件中函数和段的名称。这种技术会打乱每个符号和段的名称的顺序。结果是段头将被全部混合（或看起来是这样），函数和符号的名称也是如此。
- en: This technique can be very misleading to a reverse engineer; for instance, they
    might think they are looking at a function called `check_serial_number()`, when
    really they are looking at `safe_strcpy()`. I have implemented this in a tool
    called `elfscure`, available at [http://www.bitlackeys.org/projects/elfscure.c](http://www.bitlackeys.org/projects/elfscure.c).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可能会让逆向工程师产生误导；例如，他们可能会认为自己正在查看一个名为 `check_serial_number()` 的函数，而实际上他们正在查看
    `safe_strcpy()`。我已经在一个名为 `elfscure` 的工具中实现了这一点，可以在 [http://www.bitlackeys.org/projects/elfscure.c](http://www.bitlackeys.org/projects/elfscure.c)
    上找到。
- en: ELF virus detection and disinfection
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ELF 病毒检测和消毒
- en: Detecting viruses can be very complicated, let alone disinfecting them. Our
    modern day AV software is actually quite a joke and is very ineffective. Standard
    AV software uses scan strings, which are signatures, to detect a virus. In other
    words, if a known virus always had the string `h4h4.infect.1+` at a given offset
    within the binary, then the AV software would see that it is present in its database
    and flag it as infected. This is very ineffective in the long run, especially
    since viruses are constantly mutating into new strains.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 检测病毒可能非常复杂，更不用说消毒了。我们现代的杀毒软件实际上相当荒谬且效果不佳。标准的杀毒软件使用扫描字符串，即签名，来检测病毒。换句话说，如果一个已知的病毒在二进制文件的给定偏移处始终有字符串
    `h4h4.infect.1+`，那么杀毒软件会看到它存在于数据库中并标记为感染。从长远来看，这非常低效，特别是因为病毒不断变异成新的品系。
- en: Some AV products are known to use emulation for dynamic analysis that can feed
    the heuristics analyzer with information about an executable's conduct during
    runtime. Dynamic analysis can be powerful, but it is known to be slow. Some breakthroughs
    in dynamic malware unpacking and classification have been made by Silvio Cesare,
    but I am not certain whether this technology is being used in the mainstream.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一些杀毒产品已知使用模拟进行动态分析，可以向启发式分析器提供关于可执行文件在运行时的行为的信息。动态分析可能很强大，但已知速度很慢。Silvio Cesare
    在动态恶意软件解包和分类方面取得了一些突破，但我不确定这项技术是否被用于主流。
- en: 'Currently, there exists a very limited amount of software for detecting and
    disinfecting ELF binary infections. This is probably because a more mainstream
    market doesn''t exist and because a lot of these attacks are somehow still so
    underground. There is no doubt, though, that hackers are using these techniques
    to hide backdoors and maintain a stealthy residence on compromised systems. Currently,
    I am working on a project called Arcana, which can detect and disinfect many types
    of ELF binary infections, including executables, shared libraries, and kernel
    drivers, and it is also capable of using ECFS snapshots (described in [Chapter
    8](part0074_split_000.html#26I9K1-1d4163ae11644cc2802846625b2dc985 "Chapter 8. ECFS
    – Extended Core File Snapshot Technology"), *ECFS – Extended Core File Snapshot
    Technology*) which greatly improves process-memory forensics. In the meantime,
    you can read about or download one of the following projects, which are prototypes
    I designed years ago:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，存在着非常有限的软件用于检测和消毒 ELF 二进制感染。这可能是因为更主流的市场并不存在，而且很多这些攻击仍然处于地下状态。然而毫无疑问，黑客们正在使用这些技术来隐藏后门，并在受损系统上保持隐秘的存在。目前，我正在进行一个名为
    Arcana 的项目，它可以检测和消毒许多类型的 ELF 二进制感染，包括可执行文件、共享库和内核驱动程序，并且还能够使用 ECFS 快照（在[第8章](part0074_split_000.html#26I9K1-1d4163ae11644cc2802846625b2dc985
    "第8章。ECFS – 扩展核心文件快照技术")中描述，*ECFS – 扩展核心文件快照技术*），这大大改进了进程内存取证。与此同时，您可以阅读或下载我多年前设计的以下项目中的一个原型：
- en: VMA Voodoo ([http://www.bitlackeys.org/#vmavudu](http://www.bitlackeys.org/#vmavudu))
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VMA Voodoo ([http://www.bitlackeys.org/#vmavudu](http://www.bitlackeys.org/#vmavudu))
- en: '**AVU** (**Anti Virus Unix**) at [http://www.bitlackeys.org/projects/avu32.tgz](http://www.bitlackeys.org/projects/avu32.tgz)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AVU** (**Anti Virus Unix**) 在 [http://www.bitlackeys.org/projects/avu32.tgz](http://www.bitlackeys.org/projects/avu32.tgz)
    上'
- en: Most viruses in a Unix environment are implanted after a system compromise and
    used to maintain residency on the system by logging useful information (such as
    usernames/passwords) or by hooking daemons with backdoors. The software that I
    have designed in this area is most likely to be used as host intrusion detection
    software or for automated forensics analysis of binaries and process memory. Keep
    following the [http://bitlackeys.org/](http://bitlackeys.org/) site to see any
    updates pertaining to the release of *Arcana*, my latest ELF binary analysis software,
    which is going to be the first real production software that is equipped for complete
    analysis and disinfection of ELF binary infections.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 环境中的大多数病毒是在系统受损后植入的，并用于通过记录有用信息（如用户名/密码）或通过挂钩守护进程与后门来维持系统上的驻留。我在这个领域设计的软件很可能被用作主机入侵检测软件或用于对二进制文件和进程内存进行自动取证分析。继续关注
    [http://bitlackeys.org/](http://bitlackeys.org/) 网站，以查看有关 *Arcana* 发布的任何更新，这是我最新的
    ELF 二进制分析软件，将是第一个真正配备完整分析和消毒 ELF 二进制感染能力的生产软件。
- en: I have decided not to write an entire section in this chapter on heuristics
    and the detection of viruses, because we will be discussing most of these techniques
    in [Chapter 6](part0060_split_000.html#1P71O2-1d4163ae11644cc2802846625b2dc985
    "Chapter 6. ELF Binary Forensics in Linux"), *ELF Binary Forensics in Linux*,
    where will examine the methods and heuristics used in detecting binary infections.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定不在本章中写一整节关于启发式和病毒检测，因为我们将在[第6章](part0060_split_000.html#1P71O2-1d4163ae11644cc2802846625b2dc985
    "第6章。Linux中的ELF二进制取证")中讨论大部分这些技术，*Linux中的ELF二进制取证*，我们将检查用于检测二进制感染的方法和启发式。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the "need-to-know" information about virus engineering
    for ELF binaries. This knowledge is not common, and therefore this chapter hopefully
    serves as a unique introduction to this arcane art of viruses in the underground
    world of computer science. At this point, you should understand the most common
    techniques for virus infection, anti-debugging, and the challenges that are associated
    with both creating and analysing viruses for ELF. This knowledge comes to great
    use in the event of reverse engineering a virus or performing malware analysis.
    It is worth noting that many great papers can be found on [http://vxheaven.org](http://vxheaven.org)
    to help further your insights into Unix virus technology.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了有关ELF二进制病毒工程的“必须知道”信息。这些知识并不常见，因此本章有望作为计算机科学地下世界中这种神秘病毒艺术的独特介绍。在这一点上，您应该了解病毒感染、反调试的最常见技术，以及创建和分析ELF病毒所面临的挑战。这些知识在逆向工程病毒或进行恶意软件分析时非常有用。值得注意的是，可以在[http://vxheaven.org](http://vxheaven.org)上找到许多优秀的论文，以帮助进一步了解Unix病毒技术。
