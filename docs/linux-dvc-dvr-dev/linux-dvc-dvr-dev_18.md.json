["```\n#include <linux/rtc.h> \n```", "```\nstruct rtc_time { \n   int tm_sec;  /* seconds after the minute */ \n   int tm_min;  /* minutes after the hour - [0, 59] */ \n   int tm_hour; /* hours since midnight - [0, 23] */ \n   int tm_mday; /* day of the month - [1, 31] */ \n   int tm_mon;  /* months since January - [0, 11] */ \n   int tm_year; /* years since 1900 */ \n   int tm_wday; /* days since Sunday - [0, 6] */ \n   int tm_yday; /* days since January 1 - [0, 365] */ \n   int tm_isdst; /* Daylight saving time flag */ \n}; \n```", "```\nstruct rtc_device { \n   struct device dev; \n   struct module *owner; \n\n   int id; \n   char name[RTC_DEVICE_NAME_SIZE]; \n\n   const struct rtc_class_ops *ops; \n   struct mutex ops_lock; \n\n   struct cdev char_dev; \n   unsigned long flags; \n\n   unsigned long irq_data; \n   spinlock_t irq_lock; \n   wait_queue_head_t irq_queue; \n\n   struct rtc_task *irq_task; \n   spinlock_t irq_task_lock; \n   int irq_freq; \n   int max_user_freq; \n\n   struct work_struct irqwork; \n}; \n```", "```\nstruct rtc_class_ops { \n   int (*open)(struct device *); \n   void (*release)(struct device *); \n   int (*ioctl)(struct device *, unsigned int, unsigned long); \n   int (*read_time)(struct device *, struct rtc_time *); \n   int (*set_time)(struct device *, struct rtc_time *); \n   int (*read_alarm)(struct device *, struct rtc_wkalrm *); \n   int (*set_alarm)(struct device *, struct rtc_wkalrm *); \n   int (*read_callback)(struct device *, int data); \n   int (*alarm_irq_enable)(struct device *, unsigned int enabled); \n}; \n```", "```\n#define to_rtc_device(d) container_of(d, struct rtc_device, dev) \n```", "```\nstruct rtc_device *rtc_device_register(const char *name, \n\n                             struct device *dev, \n                             const struct rtc_class_ops *ops, \n                             struct module *owner) \n```", "```\nstruct rtc_device *devm_rtc_device_register(struct device *dev, \n                              const char *name, \n                              const struct rtc_class_ops *ops, \n                              struct module *owner) \n```", "```\nvoid rtc_device_unregister(struct rtc_device *rtc) \nvoid devm_rtc_device_unregister(struct device *dev,\n\n                           struct rtc_device *rtc) \n```", "```\nint rtc_valid_tm(struct rtc_time *tm);\n```", "```\nstatic int foo_rtc_read_time(struct device *dev, struct rtc_time *tm) \n{ \n   struct foo_regs regs; \n   int error; \n\n   error = foo_device_read(dev, &regs, 0, sizeof(regs)); \n   if (error) \n         return error; \n\n   tm->tm_sec = bcd2bin(regs.seconds); \n   tm->tm_min = bcd2bin(regs.minutes); \n   tm->tm_hour = bcd2bin(regs.cent_hours); \n   tm->tm_mday = bcd2bin(regs.date); \n\n   /* \n    * This device returns weekdays from 1 to 7 \n    * But rtc_time.wday expect days from 0 to 6\\. \n    * So we need to substract 1 to the value returned by the chip \n    */ \n   tm->tm_wday = bcd2bin(regs.day) - 1; \n\n    /* \n    * This device returns months from 1 to 12 \n    * But rtc_time.tm_month expect a months 0 to 11\\. \n    * So we need to substract 1 to the value returned by the chip \n    */ \n   tm->tm_mon = bcd2bin(regs.month) - 1; \n\n    /* \n    * This device's Epoch is 2000\\. \n    * But rtc_time.tm_year expect years from Epoch 1900\\. \n    * So we need to add 100 to the value returned by the chip \n    */ \n   tm->tm_year = bcd2bin(regs.years) + 100; \n\n   return rtc_valid_tm(tm); \n} \n```", "```\n#include <linux/bcd.h> \n```", "```\nstatic int foo_rtc_set_time(struct device *dev, struct rtc_time *tm) \n{ \n\n   regs.seconds = bin2bcd(tm->tm_sec); \n   regs.minutes = bin2bcd(tm->tm_min); \n   regs.cent_hours = bin2bcd(tm->tm_hour); \n\n   /* \n    * This device expects week days from 1 to 7 \n    * But rtc_time.wday contains week days from 0 to 6\\. \n    * So we need to add 1 to the value given by rtc_time.wday \n    */ \n   regs.day = bin2bcd(tm->tm_wday + 1); \n   regs.date = bin2bcd(tm->tm_mday); \n\n   /* \n    * This device expects months from 1 to 12 \n    * But rtc_time.tm_mon contains months from 0 to 11\\. \n    * So we need to add 1 to the value given by rtc_time.tm_mon \n    */ \n   regs.month = bin2bcd(tm->tm_mon + 1); \n\n   /* \n    * This device expects year since Epoch 2000 \n    * But rtc_time.tm_year contains year since Epoch 1900\\. \n    * We can just extract the year of the century with the \n    * rest of the division by 100\\. \n    */ \n   regs.cent_hours |= BQ32K_CENT; \n   regs.years = bin2bcd(tm->tm_year % 100); \n\n   return write_into_device(dev, &regs, 0, sizeof(regs)); \n} \n```", "```\n#include <linux/platform_device.h> \n#include <linux/module.h> \n#include <linux/types.h> \n#include <linux/time.h> \n#include <linux/err.h> \n#include <linux/rtc.h> \n#include <linux/of.h> \n\nstatic int fake_rtc_read_time(struct device *dev, struct rtc_time *tm) \n{ \n   /* \n    * One can update \"tm\" with fake values and then call \n    */ \n   return rtc_valid_tm(tm); \n} \n\nstatic int fake_rtc_set_time(struct device *dev, struct rtc_time *tm) \n{ \n   return 0; \n} \n\nstatic const struct rtc_class_ops fake_rtc_ops = { \n   .read_time = fake_rtc_read_time, \n   .set_time = fake_rtc_set_time \n}; \n\nstatic const struct of_device_id rtc_dt_ids[] = { \n    { .compatible = \"packt,rtc-fake\", }, \n    { /* sentinel */ } \n}; \n\nstatic int fake_rtc_probe(struct platform_device *pdev) \n{ \n   struct rtc_device *rtc; \n   rtc = rtc_device_register(pdev->name, &pdev->dev, \n                           &fake_rtc_ops, THIS_MODULE); \n\n   if (IS_ERR(rtc)) \n         return PTR_ERR(rtc); \n\n   platform_set_drvdata(pdev, rtc); \n   pr_info(\"Fake RTC module loaded\\n\"); \n\n   return 0; \n} \n\nstatic int fake_rtc_remove(struct platform_device *pdev) \n{ \n   rtc_device_unregister(platform_get_drvdata(pdev)); \n   return 0; \n} \n\nstatic struct platform_driver fake_rtc_drv = { \n   .probe = fake_rtc_probe, \n   .remove = fake_rtc_remove, \n   .driver = { \n         .name = KBUILD_MODNAME, \n         .owner = THIS_MODULE, \n         .of_match_table = of_match_ptr(rtc_dt_ids), \n   }, \n}; \nmodule_platform_driver(fake_rtc_drv); \n\nMODULE_LICENSE(\"GPL\"); \nMODULE_AUTHOR(\"John Madieu <john.madieu@gmail.com>\"); \nMODULE_DESCRIPTION(\"Fake RTC driver description\"); \n```", "```\nstruct rtc_wkalrm { \nunsigned char enabled;  /* 0 = alarm disabled, 1 = enabled */ \nunsigned char pending;  /* 0 = alarm not pending, 1 = pending */ \nstruct rtc_time time;   /* time the alarm is set to */ \n}; \n```", "```\nvoid rtc_update_irq(struct rtc_device *rtc, \n                 unsigned long num, unsigned long events) \n```", "```\n/* RTC interrupt flags */ \n#define RTC_IRQF 0x80 /* Any of the following is active */ \n#define RTC_PF 0x40  /* Periodic interrupt */ \n#define RTC_AF 0x20  /* Alarm interrupt */ \n#define RTC_UF 0x10  /* Update interrupt for 1Hz RTC */ \n```", "```\nstatic irqreturn_t foo_rtc_alarm_irq(int irq, void *data) \n{ \n   struct foo_rtc_struct * foo_device = data; \n   dev_info(foo_device ->dev, \"%s:irq(%d)\\n\", __func__, irq); \n   rtc_update_irq(foo_device ->rtc_dev, 1, RTC_IRQF | RTC_AF); \n\n   return IRQ_HANDLED; \n} \n```", "```\nint device_init_wakeup(struct device *dev, bool enable) \nint dev_pm_set_wake_irq(struct device *dev, int irq) \n```", "```\nstatic const struct rtc_class_ops foo_rtc_ops = { \n   .read_time  = foo_rtc_read_time, \n   .set_time   = foo_rtc_set_time, \n   .read_alarm = foo_rtc_read_alarm, \n   .set_alarm  = foo_rtc_set_alarm, \n   .alarm_irq_enable = foo_rtc_alarm_irq_enable, \n   .ioctl      = foo_rtc_ioctl, \n}; \n\nstatic int foo_spi_probe(struct spi_device *spi) \n{ \n   int ret; \n    /* initialise and configure the RTC chip */ \n   [...] \n\nfoo_rtc->rtc_dev = \ndevm_rtc_device_register(&spi->dev, \"foo-rtc\", \n&foo_rtc_ops, THIS_MODULE); \n   if (IS_ERR(foo_rtc->rtc_dev)) { \n         dev_err(&spi->dev, \"unable to register foo rtc\\n\"); \n         return PTR_ERR(priv->rtc); \n   } \n\n   foo_rtc->irq = spi->irq; \n\n   if (foo_rtc->irq >= 0) { \n         ret = devm_request_threaded_irq(&spi->dev, spi->irq, \n                                 NULL, foo_rtc_alarm_irq, \n                                 IRQF_ONESHOT, \"foo-rtc\", priv); \n         if (ret) { \n               foo_rtc->irq = -1; \n               dev_err(&spi->dev, \n                     \"unable to request irq for rtc foo-rtc\\n\"); \n         } else { \n               device_init_wakeup(&spi->dev, true); \n               dev_pm_set_wake_irq(&spi->dev, spi->irq); \n         } \n   } \n\n   return 0; \n} \n```", "```\nCONFIG_RTC_HCTOSYS=y \nCONFIG_RTC_HCTOSYS_DEVICE=\"rtc0\" \n```", "```\n$ cat /sys/class/rtc/rtc0/date\n\n2017-08-28\n\n```", "```\n    $ cat /sys/class/rtc/rtc0/time\n\n    14:54:20\n\n```", "```\n $ cat /sys/class/rtc/rtc0/hctosys\n    1\n\n```", "```\n $ cat /sys/class/rtc/rtc0/dev\n    251:0\n\n```", "```\n    $ cat /sys/class/rtc/rtc0/since_epoch\n\n    1503931738\n\n```", "```\n $ sudo ntpd -q    # make sure system clock is set from network time\n\n $ sudo hwclock --systohc   # set rtc from the system clock\n\n $ sudo hwclock --show      # check rtc was set\n\n Sat May 17 17:36:50 2017  -0.671045 seconds\n\n```", "```\n $ sudo date -s '2017-08-28 17:14:00' '+%s' #set system clock manually\n\n $ sudo hwclock --systohc #synchronize rtc chip on system time\n\n```", "```\n $ ls -l /dev/rtc\n lrwxrwxrwx 1 root root 4 ao\u00fbt  27 17:50 /dev/rtc -> rtc0\n\n```"]