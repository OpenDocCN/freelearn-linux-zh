- en: Chapter 8. ECFS – Extended Core File Snapshot Technology
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。ECFS – 扩展核心文件快照技术
- en: '**Extended Core File Snapshot** (**ECFS**) technology is a piece of software
    that plugs into the Linux core handler and creates specialized process memory
    snapshots specifically designed with process memory forensics in mind. Most people
    have no idea how to parse a process image, let alone how to examine one for anomalies.
    Even for experts, it can be an arduous task to look at a process image and detect
    infections or malware.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展核心文件快照**（**ECFS**）技术是一款插入Linux核心处理程序并创建专门设计用于进程内存取证的特殊进程内存快照的软件。大多数人不知道如何解析进程镜像，更不用说如何检查其中的异常。即使对于专家来说，查看进程镜像并检测感染或恶意软件可能是一项艰巨的任务。'
- en: Before ECFS, there existed no real standard for snapshotting of a process image
    other than using core files, which can be created on demand using the **gcore**
    script that comes with most Linux distributions. As briefly discussed in the previous
    chapter, regular core files are not particularly useful for process forensics
    analysis. This is why ECFS core files came into existence—to provide a file format
    that can describe every nuance of a process image so that it can be efficiently
    analyzed, easily navigated, and easily integrated with malware analysis and process
    forensics tools.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECFS之前，除了使用大多数Linux发行版附带的**gcore**脚本创建的核心文件之外，没有真正的进程镜像快照标准。如前一章简要讨论的那样，常规核心文件对于进程取证分析并不特别有用。这就是ECFS核心文件出现的原因——提供一种可以描述进程镜像的每一个细微差别的文件格式，以便可以进行高效分析、轻松导航，并且可以轻松集成到恶意软件分析和进程取证工具中。
- en: In this chapter, we will discuss the basics of ECFS and how to use ECFS core
    files and the **libecfs** API to rapidly design malware analysis and forensics
    tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论ECFS的基础知识以及如何使用ECFS核心文件和**libecfs** API来快速设计恶意软件分析和取证工具。
- en: History
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 历史
- en: In 2011, I created a software prototype titled Linux VMA Monitor ([http://www.bitlackeys.org/#vmavudu](http://www.bitlackeys.org/#vmavudu))
    for a DARPA contract. This software was designed to look at live process memory
    or raw snapshots of process memory. It was able to detect all sorts of runtime
    infections, including shared library injection, PLT/GOT hijacking, and other anomalies
    that indicate runtime malware.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年，我为DARPA合同创建了一个名为Linux VMA Monitor的软件原型([http://www.bitlackeys.org/#vmavudu](http://www.bitlackeys.org/#vmavudu))。这个软件旨在查看实时进程内存或进程内存的原始快照。它能够检测各种运行时感染，包括共享库注入、PLT/GOT劫持和其他指示运行时恶意软件的异常。
- en: In more recent times, I considered rewriting this software into a more finished
    state, and I felt that a native snapshot format for process memory would be a
    really nice feature. This was the initial inspiration for developing ECFS, and
    although I have canceled my plans of reviving the Linux VMA Monitor software for
    now, I am continuing to expand and develop the ECFS software as it is of great
    value to many other people's projects. It is even being incorporated into the
    Lotan product, which is a piece of software used to detect exploitation attempts
    by analyzing crash dumps ([http://www.leviathansecurity.com/lotan](http://www.leviathansecurity.com/lotan)).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，我考虑将这个软件重写为更完善的状态，我觉得为进程内存创建一个本地快照格式将是一个非常好的功能。这是开发ECFS的最初灵感，尽管我已经取消了重新启动Linux
    VMA Monitor软件的计划，但我仍在继续扩展和开发ECFS软件，因为它对其他许多人的项目非常有价值。它甚至被整合到了Lotan产品中，这是一款用于通过分析崩溃转储来检测利用尝试的软件([http://www.leviathansecurity.com/lotan](http://www.leviathansecurity.com/lotan))。
- en: The ECFS philosophy
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECFS的理念
- en: ECFS is all about making runtime analysis of a program easier than ever before.
    The entire process is encased within a single file, and it is organized in such
    a way that locating and accessing data and code that is critical for detecting
    anomalies and infections is achievable through orderly and efficient means. This
    is primarily done through parsing section headers to access useful data, such
    as symbol tables, dynamic linking data, and forensics-relevant structures.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 'ECFS的目标是使程序的运行时分析比以往任何时候都更容易。整个过程都封装在一个单一文件中，并且以一种有序和高效的方式组织，以便通过解析部分头来访问有用的数据，如符号表、动态链接数据和取证相关结构，从而实现定位和访问对于检测异常和感染至关重要的数据和代码。 '
- en: Getting started with ECFS
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用ECFS
- en: At the time of writing this chapter, the complete ECFS project and source code
    is available at [http://github.com/elfmaster/ecfs](http://github.com/elfmaster/ecfs).
    Once you have cloned the repository with git, you should compile and install the
    software as described in the README file.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 撰写本章时，完整的ECFS项目和源代码可在[http://github.com/elfmaster/ecfs](http://github.com/elfmaster/ecfs)上找到。一旦你用git克隆了存储库，你应该按照README文件中的说明编译和安装软件。
- en: 'Currently, ECFS has two modes of use:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，ECFS有两种使用模式：
- en: Plugging ECFS into the core handler
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将ECFS插入核心处理程序
- en: ECFS snapshots without killing the process
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECFS快照而不终止进程
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, the terms ECFS files, ECFS snapshots, and ECFS core files are
    used interchangeably.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，术语ECFS文件、ECFS快照和ECFS核心文件是可以互换使用的。
- en: Plugging ECFS into the core handler
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将ECFS插入核心处理程序
- en: The first thing is to plug the ECFS core handler into the Linux kernel. The
    `make` install will accomplish this for you, but it must be done after every reboot
    or stored in an `init` script. The manual way of setting up the ECFS core handler
    is by modifying the `/proc/sys/kernel/core_pattern` file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是将ECFS核心处理程序插入Linux内核中。`make` install会为您完成这项工作，但必须在每次重启后进行操作，或者存储在一个`init`脚本中。手动设置ECFS核心处理程序的方法是修改`/proc/sys/kernel/core_pattern`文件。
- en: 'This is the command used to activate the ECFS core handler:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是激活ECFS核心处理程序的命令：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that the `-t` option is set. This is very important for forensics and
    it should rarely be turned off. This option tells ECFS to capture the entire text
    segment for any executable or shared library mappings. In traditional core files,
    the text images are truncated to 4k. Later in this chapter, we will also examine
    the `-h` option (heuristics), which can be set to enable extended heuristics in
    order to detect shared library injection.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意设置了`-t`选项。这对取证非常重要，而且很少关闭。此选项告诉ECFS捕获任何可执行文件或共享库映射的整个文本段。在传统核心文件中，文本图像被截断为4k。在本章的后面，我们还将研究`-h`选项（启发式），它可以设置为启用扩展启发式以检测共享库注入。
- en: The `ecfs_handler` binary will invoke either `ecfs32` or `ecfs64` depending
    on whether the process is 64 bit or 32 bit. The pipe symbol (`|`) at the front
    of the line that we write into the procfs `core_pattern` entry tells the kernel
    to pipe the core files it produces into the standard input of our ECFS core handler
    process. The ECFS core handler then transforms the traditional core file into
    a highly customized and spectacular ECFS core file. Anytime if a process crashes
    or is delivered a signal that causes a core dump, such as **SIGSEGV** or **SIGABRT**,
    then the ECFS core handler will step in and instrument the core file creation
    with its own special set of procedures for creating an ECFS-style core dump.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`ecfs_handler`二进制文件将调用`ecfs32`或`ecfs64`，具体取决于进程是64位还是32位。我们写入procfs `core_pattern`条目的行前面的管道符（`|`）告诉内核将其产生的核心文件导入到我们的ECFS核心处理程序进程的标准输入中。然后ECFS核心处理程序将传统核心文件转换为高度定制和出色的ECFS核心文件。每当进程崩溃或收到导致核心转储的信号，例如**SIGSEGV**或**SIGABRT**，那么ECFS核心处理程序将介入并使用自己的一套特殊程序来创建ECFS风格的核心转储。'
- en: 'Here''s an example of capturing an ECFS snapshot of `sshd`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是捕获`sshd`的ECFS快照的示例：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Having ECFS as the default core file handler is very nice and perfectly suitable
    for everyday use. This is because ECFS cores are backwards compatible with traditional
    core files and can be used with debuggers such as GDB. However, there are times
    when a user may want to capture an ECFS snapshot without having to kill the process.
    This is where the ECFS snapshot tool comes into usefulness.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将ECFS作为默认的核心文件处理程序非常好，非常适合日常使用。这是因为ECFS核心向后兼容传统核心文件，并且可以与诸如GDB之类的调试器一起使用。但是，有时用户可能希望捕获ECFS快照而无需终止进程。这就是ECFS快照工具的用处所在。
- en: ECFS snapshots without killing the process
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在不终止进程的情况下进行ECFS快照
- en: Let's consider a scenario where there is a suspicious process running. It is
    suspicious because it is consuming a lot of CPU and it has network sockets open
    even though it is known not to be a network program of any kind. In such a scenario,
    it may be desirable to leave the process running so that a potential attacker
    is not yet alerted, but still have the capability to produce an ECFS core file.
    The `ecfs_snapshot` utility should be used in these cases.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景，有一个可疑的进程正在运行。它可疑是因为它消耗了大量的CPU，并且它打开了网络套接字，尽管已知它不是任何类型的网络程序。在这种情况下，可能希望让进程继续运行，以便潜在的攻击者尚未被警告，但仍然具有生成ECFS核心文件的能力。在这些情况下应该使用`ecfs_snapshot`实用程序。
- en: 'The `ecfs_snapshot` utility ultimately uses the ptrace system call, which means
    two things:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`ecfs_snapshot`实用程序最终使用ptrace系统调用，这意味着两件事：'
- en: It may take noticeably longer to snapshot the process
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获进程的快照可能需要更长的时间。
- en: It may be ineffective against processes that use anti-debugging techniques to
    prevent ptrace from attaching
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能对使用反调试技术防止ptrace附加的进程无效
- en: In cases where either of these issues becomes a problem, you may have to consider
    using the ECFS core handler for the job, in which case you will have to kill the
    process. In most situations, however, the `ecfs_snapshot` utility will work.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些问题中的任何一个成为问题的情况下，您可能需要考虑使用ECFS核心处理程序来处理工作，这种情况下您将不得不终止进程。然而，在大多数情况下，`ecfs_snapshot`实用程序将起作用。
- en: 'Here''s an example of capturing an ECFS snapshot with the snapshot utility:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用快照实用程序捕获ECFS快照的示例：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This snapshots the process for the program host and creates an ECFS snapshot
    called `host_snapshot`. In the following sections, we will demonstrate some actual
    use cases of ECFS and take a look at the ECFS files with a variety of utilities.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这为程序host捕获了快照，并创建了一个名为`host_snapshot`的ECFS快照。在接下来的章节中，我们将演示ECFS的一些实际用例，并使用各种实用程序查看ECFS文件。
- en: libecfs – a library for parsing ECFS files
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: libecfs - 用于解析ECFS文件的库
- en: The ECFS file format is very easy to parse with traditional ELF utilities, such
    as `readelf`, but to build parsing tools that are custom, I highly recommend that
    you use the libecfs library. This library is specifically designed for easy parsing
    of ECFS core files. It will be demonstrated with slightly more details later in
    this chapter when we look at designing advanced malware analysis tools to detect
    infected processes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ECFS文件格式非常容易使用传统的ELF工具进行解析，比如`readelf`，但是为了构建自定义的解析工具，我强烈建议您使用libecfs库。这个库是专门设计用于轻松解析ECFS核心文件的。稍后在本章中，我们将演示更多细节，当我们设计高级恶意软件分析工具来检测被感染的进程时。
- en: libecfs is also used in the ongoing development of the `readecfs` utility, which
    is a tool for parsing ECFS files, and is very similar to the commonly known `readelf`
    utility. Note that libecfs is included with the ECFS package on the GitHub repository.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: libecfs也用于正在开发的`readecfs`实用程序，这是一个用于解析ECFS文件的工具，非常类似于众所周知的`readelf`实用程序。请注意，libecfs包含在GitHub存储库上的ECFS软件包中。
- en: readecfs
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: readecfs
- en: 'The `readecfs` utility will be used throughout the rest of this chapter while
    demonstrating the different ECFS features. Here is a synopsis of the tool from
    `readecfs -h`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分中，将使用`readecfs`实用程序来演示不同的ECFS功能。以下是从`readecfs -h`中的工具的概要：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Examining an infected process using ECFS
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ECFS检查被感染的进程
- en: Before we show the effectiveness of ECFS with a real-world example, it would
    be helpful to have a little background of the method of infection that we will
    use from a hacker's perspective. It is often very useful for a hacker to be able
    to incorporate anti-forensic techniques into their workflow on compromised systems
    so that their programs, especially the ones that serve as backdoors and such,
    can remain hidden to the untrained eye.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示ECFS在真实案例中的有效性之前，了解一下我们将从黑客的角度使用的感染方法的背景将会很有帮助。对于黑客来说，能够将反取证技术纳入其在受损系统上的工作流程中是非常有用的，这样他们的程序，尤其是那些充当后门等的程序，可以对未经训练的人保持隐藏。
- en: One such technique is to perform process **cloaking**. This is the act of running
    a program inside of an existing process, ideally inside of a process that is known
    to be benign but persistent, such as ftpd or sshd. The Saruman anti-forensics
    exec ([http://www.bitlackeys.org/#saruman](http://www.bitlackeys.org/#saruman))
    allows an attacker to inject a complete, dynamically linked PIE executable into
    an existing process address space and run it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种技术是执行**伪装**进程。这是在现有进程内运行程序的行为，理想情况下是在已知是良性但持久的进程内运行，例如ftpd或sshd。Saruman反取证执行([http://www.bitlackeys.org/#saruman](http://www.bitlackeys.org/#saruman))允许攻击者将一个完整的、动态链接的PIE可执行文件注入到现有进程的地址空间并运行它。
- en: It uses a thread injection technique so that the injected program can run simultaneously
    with the host program. This particular hacker technique was something that I came
    up with and designed in 2013, but I have no doubt that other such tools have existed
    for much longer than this in the underground scene. Typically, this type of anti-forensic
    technique would go unnoticed and would be very difficult to detect.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用线程注入技术，以便注入的程序可以与主机程序同时运行。这种特定的黑客技术是我在2013年想出并设计的，但我毫不怀疑其他类似的工具在地下场景中存在的时间比这长得多。通常，这种类型的反取证技术会不被注意到，并且很难被检测到。
- en: Let's see what type of efficiency and accuracy we can achieve by analyzing such
    a process with ECFS technology.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看通过使用ECFS技术分析这样的进程可以实现什么样的效率和准确性。
- en: Infecting the host process
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 感染主机进程
- en: The host process is a benign process, and typically it would be something like
    sshd or ftpd, as already mentioned. For the sake of our example, we will use a
    simple and persistent program called host; it simply runs in an infinite loop,
    printing a message on the screen. We will then inject a remote server backdoor
    into the process using the Saruman anti-forensics exec launcher program.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 主机进程是一个良性进程，通常会是像sshd或ftpd这样的东西，就像之前提到的那样。为了举例，我们将使用一个简单而持久的名为host的程序；它只是在屏幕上打印一条消息并在无限循环中运行。然后，我们将使用Saruman反取证执行启动程序将远程服务器后门注入到该进程中。
- en: 'In terminal 1, run the host program:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端1中，运行主机程序：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In terminal 2, inject the backdoor into the process:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端2中，将后门注入到进程中：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Capturing and analyzing an ECFS snapshot
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获和分析ECFS快照
- en: Now, if we capture a snapshot of the process either by using the `ecfs_snapshot`
    utility or by signaling the process to the core dump, we can begin our examination.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们通过使用`ecfs_snapshot`实用程序捕获进程的快照，或者通过向进程发出核心转储信号，我们就可以开始我们的检查了。
- en: The symbol table analysis
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 符号表分析
- en: 'Let''s look at the symbol table analysis of the `host.16186` snapshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`host.16186`快照的符号表分析：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `readelf` command allows us to view the symbol tables. Notice that a symbol
    table exists for both the dynamic symbols in `.dynsym` and the symbols for local
    functions, which are stored in the `.symtab` symbol table. ECFS is able to reconstruct
    the dynamic symbol table by accessing the dynamic segment and finding `DT_SYMTAB`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`readelf`命令允许我们查看符号表。请注意，`.dynsym`中存在动态符号的符号表，以及存储在`.symtab`符号表中的本地函数的符号表。ECFS能够通过访问动态段并找到`DT_SYMTAB`来重建动态符号表。'
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `.symtab` symbol table is a bit trickier but extremely valuable. ECFS uses
    a special method of parsing the `PT_GNU_EH_FRAME` segment that contains frame
    description entries in a dwarf format; these are used for exception handling.
    This information is useful for gathering the location and size of every single
    function defined within the binary.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`.symtab`符号表有点棘手，但非常有价值。ECFS使用一种特殊的方法来解析包含以dwarf格式的帧描述条目的`PT_GNU_EH_FRAME`段；这些用于异常处理。这些信息对于收集二进制文件中定义的每个函数的位置和大小非常有用。'
- en: In cases such as functions being obfuscated, tools such as IDA would fail to
    identify every function defined within a binary or core file, but the ECFS technology
    will succeed. This is one of the major impacts that ECFS makes on the reverse
    engineering world—a near-foolproof method of locating and sizing every function
    and producing a symbol table. In the `host.16186` file, the symbol table is fully
    reconstructed. This is useful because it could aid us in detecting whether or
    not any PLT/GOT hooks are being used to redirect shared library functions, and
    if so, we can identify the actual names of functions that have been hijacked.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数被混淆的情况下，诸如IDA之类的工具将无法识别二进制或核心文件中定义的每个函数，但ECFS技术将成功。这是ECFS对逆向工程世界产生的主要影响之一——一种几乎无懈可击的定位和确定每个函数大小并生成符号表的方法。在`host.16186`文件中，符号表被完全重建。这很有用，因为它可以帮助我们检测是否有任何PLT/GOT钩子被用来重定向共享库函数，如果是的话，我们可以识别被劫持的函数的实际名称。
- en: The section header analysis
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 段头分析
- en: Now, let's look at the section header analysis of the `host.16186` snapshot.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下`host.16186`快照的段头分析。
- en: 'My version of `readelf` has been slightly modified so that it recognizes the
    following custom types: `SHT_INJECTED` and `SHT_PRELOADED`. Without this modification
    to readelf, it will simply show the numerical values associated with those definitions.
    Check out `include/ecfs.h` for the definitions, and add them to the `readelf`
    source code if you like:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我的`readelf`版本已经稍作修改，以便它识别以下自定义类型：`SHT_INJECTED`和`SHT_PRELOADED`。如果不对readelf进行这种修改，它将只显示与这些定义相关的数值。如果你愿意，可以查看`include/ecfs.h`中的定义，并将它们添加到`readelf`源代码中：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Section 23 is of particular interest to us; it has been marked as a suspicious
    ELF object with the injected denotation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第23节对我们来说特别重要；它被标记为一个带有注入标记的可疑ELF对象：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When the ECFS heuristics detects an ELF object as suspicious and it can''t
    find that particular object in its list of mapped shared libraries, it names the
    section in the following format:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当ECFS启发式检测到一个ELF对象可疑，并且在其映射的共享库列表中找不到该特定对象时，它会以以下格式命名该段：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The type can be one of four:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 类型可以是四种之一：
- en: '`ET_NONE`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ET_NONE`'
- en: '`ET_EXEC`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ET_EXEC`'
- en: '`ET_DYN`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ET_DYN`'
- en: '`ET_REL`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ET_REL`'
- en: In our example, it is obviously `ET_DYN`, represented as `dyn`. The count is
    simply the index of injected objects that have been found. In this case, the index
    is `0` as it is the first and only injected ELF object that was found in this
    particular process.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，它显然是`ET_DYN`，表示为`dyn`。计数只是找到的注入对象的索引。在这种情况下，索引是`0`，因为它是在这个特定进程中找到的第一个并且唯一的注入ELF对象。
- en: The type `INJECTED` obviously denotes that the section contains an ELF object
    that was determined suspicious or injected through unnatural means. In this particular
    case, the process was infected with Saruman (described earlier), which injects
    a **Position-Independent Executable** (**PIE**). A PIE executable is of type `ET_DYN`,
    similar to shared libraries, which is why ECFS has marked it as such.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`INJECTED`类型显然表示该部分包含一个被确定为可疑或通过非自然手段注入的ELF对象。在这种特殊情况下，进程被Saruman（前面描述过）感染，它注入了一个**位置无关可执行文件**（**PIE**）。PIE可执行文件的类型是`ET_DYN`，类似于共享库，这就是为什么ECFS将其标记为这种类型。'
- en: Extracting parasite code with readecfs
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用readecfs提取寄生代码
- en: 'We have spotted a section in the ECFS core file that relates to parasitic code,
    which is an injected PIE executable in this case. The next step is to investigate
    the code itself. This can be done in one of the following ways: the `objdump`
    utility or a more advanced disassembler such as IDA pro can be used to navigate
    to the section called `.elf.dyn.0`, or the `readecfs` utility can first be used
    to extract the parasitic code from the ECFS core file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在ECFS核心文件中发现了一个与寄生代码相关的部分，这是一个注入的PIE可执行文件。下一步是调查代码本身。可以通过以下方式之一来完成：使用`objdump`实用程序或更高级的反汇编器，如IDA
    pro，来导航到名为`.elf.dyn.0`的部分，或者首先使用`readecfs`实用程序从ECFS核心文件中提取寄生代码：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We now have a singular copy of the parasite code that has been extracted from
    the process image, thanks to ECFS. The task of identifying this particular malware
    and then extracting it would be an extremely tedious task without ECFS. Now we
    can examine `parasite_code.exe` as a separate file, open it up in IDA, and so
    on:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了从进程映像中提取的寄生代码的唯一副本，这要归功于ECFS。要识别这种特定的恶意软件，然后提取它，如果没有ECFS，这将是一项极其繁琐的任务。现在我们可以将`parasite_code.exe`作为一个单独的文件进行检查，在IDA中打开它等等：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that `readelf` is complaining in the preceding output. This is because
    the parasite that we extracted does not have a section header table of its own.
    In future, the `readecfs` utility will be able to reconstruct a minimal section
    header table for mapped ELF objects that are extracted from the overall ECFS core
    file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`readelf`在前面的输出中抱怨。这是因为我们提取的寄生体没有自己的段头表。将来，`readecfs`实用程序将能够为从整体ECFS核心文件中提取的映射ELF对象重建一个最小的段头表。
- en: Analyzing the Azazel userland rootkit
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析Azazel用户态rootkit
- en: As mentioned in [Chapter 7](part0069_split_000.html#21PMQ1-1d4163ae11644cc2802846625b2dc985
    "Chapter 7. Process Memory Forensics"), *Process Memory Forensics*, the Azazel
    userland rootkit is a userland rootkit that infects a process by means of `LD_PRELOAD`,
    where the Azazel shared library is linked to the process, and hijacks various
    `libc` functions. In [Chapter 7](part0069_split_000.html#21PMQ1-1d4163ae11644cc2802846625b2dc985
    "Chapter 7. Process Memory Forensics"), *Process Memory Forensics*, we used GDB
    and `readelf` to inspect a process for this particular rootkit infection. Now
    let's try the ECFS method to do this type of process introspection. The following
    is an ECFS snapshot of a process from the executable host2 that has been infected
    with the Azazel rootkit.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第7章](part0069_split_000.html#21PMQ1-1d4163ae11644cc2802846625b2dc985 "第7章。进程内存取证")中所述，*进程内存取证*，Azazel用户态rootkit是一种通过`LD_PRELOAD`感染进程的用户态rootkit，其中Azazel共享库链接到进程，并劫持各种`libc`函数。在[第7章](part0069_split_000.html#21PMQ1-1d4163ae11644cc2802846625b2dc985
    "第7章。进程内存取证")中，*进程内存取证*，我们使用GDB和`readelf`来检查这种特定的rootkit感染进程。现在让我们尝试使用ECFS方法来进行这种类型的进程内省。以下是从已感染Azazel
    rootkit的可执行文件host2中的一个进程的ECFS快照。
- en: The symbol table of the host2 process reconstructed
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重建host2进程的符号表
- en: 'Now, this is the symbol table of host2 with process reconstruction:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是host2的符号表在进程重建时：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can see from the preceding symbol table that host2 is a simple program and
    has only a few shared library calls (this is shown in the `.dynsym` symbol table):
    `unlink`, `puts`, `opendir`, and `fopen`.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的符号表中我们可以看出，host2是一个简单的程序，只有少量的共享库调用（这在`.dynsym`符号表中显示）：`unlink`，`puts`，`opendir`和`fopen`。
- en: The section header table of the host2 process reconstructed
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重建host2进程的段头表
- en: 'Let''s see what the section header table of host2 looks like with process reconstruction:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看host2的段头表在进程重建时是什么样子的：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The ELF sections 43 through 46 are all immediately suspicious because they
    are marked with the `PRELOADED` section type, which indicates that they are mappings
    from a shared library that was preloaded with the `LD_PRELOAD` environment variable:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ELF的43到46节都立即引起怀疑，因为它们标记为`PRELOADED`节类型，这表明它们是从使用`LD_PRELOAD`环境变量预加载的共享库的映射：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Various userland rootkits, such as Azazel, use `LD_PRELOAD` as their means of
    injection. The next step is to look at the PLT/GOT (global offset table) and check
    whether it contains any pointers to functions outside of the respective boundaries.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 各种用户态rootkit，如Azazel，使用`LD_PRELOAD`作为它们的注入手段。下一步是查看PLT/GOT（全局偏移表），并检查它是否包含指向各自边界之外的函数的指针。
- en: 'You might recall from previous chapters that the GOT contains a table of pointer
    values that should point to either of these:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得前面的章节中提到GOT包含一个指针值表，应该指向这两者之一：
- en: A PLT stub in the corresponding PLT entry (remember the lazy linking concepts
    from [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对应的PLT条目中的PLT存根（记住[第2章](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "第2章。ELF二进制格式")中的延迟链接概念，*ELF二进制格式*）
- en: If the particular GOT entry has already been resolved by the linker in some
    way (lazy or strict linking), then it will point to the shared library function
    denoted by the corresponding relocation entry from the `.rela.plt` section of
    the executable
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果链接器已经以某种方式（延迟或严格链接）解析了特定的GOT条目，那么它将指向可执行文件的`.rela.plt`节中相应重定位条目所表示的共享库函数
- en: Validating the PLT/GOT with ECFS
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ECFS验证PLT/GOT
- en: 'Understanding and systematically validating the integrity of the PLT/GOT is
    tedious by hand. Fortunately, there is a very easy way to do this with ECFS. If
    you prefer to write your own tool, then you should use the `libecfs` function
    that is designed specifically for this purpose:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 手动理解和系统验证PLT/GOT的完整性是很繁琐的。幸运的是，使用ECFS可以很容易地完成这项工作。如果你喜欢编写自己的工具，那么你应该使用专门为此目的设计的`libecfs`函数：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This function allocates an array of structs, each element pertaining to a single
    PLT/GOT entry.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数分配了一个结构数组，每个元素都与单个PLT/GOT条目相关。
- en: 'The C struct named `pltgot_info_t` has the following format:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 名为`pltgot_info_t`的C结构具有以下格式：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: An example of using this function can be found in `ecfs/libecfs/main/detect_plt_hooks.c`.
    This is a simple demonstrative tool for detecting shared library injection and
    PLT/GOT hooks, which is shown and commented for clarity later in this chapter.
    The `readecfs` utility also demonstrates the use of the `get_pltgot_info()` function
    when passed the `-g` flag.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '可以在`ecfs/libecfs/main/detect_plt_hooks.c`中找到使用此函数的示例。这是一个简单的演示工具，用于检测共享库注入和PLT/GOT钩子，稍后在本章中进行了展示和注释，以便清晰地理解。`readecfs`实用程序还演示了在传递`-g`标志时使用`get_pltgot_info()`函数。 '
- en: The readecfs output for PLT/GOT validation
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于PLT/GOT验证的readecfs输出
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding output is easy to parse. The `gotvalue` should have an address
    that matches either `gotshlib` or `pltval`. We can see, however, that the very
    first entry, which is for the symbol `unlink`, has an address `0x7f0a0d3c8c81`.
    This does not match with the expected shared library function or PLT value.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出很容易解析。`gotvalue`应该有一个地址，与`gotshlib`或`pltval`匹配。然而，我们可以看到，第一个条目，即符号`unlink`，其地址为`0x7f0a0d3c8c81`。这与预期的共享库函数或PLT值不匹配。
- en: More investigation would show that the address points to a function within `azazel.so`.
    From the preceding output, we can see that the only two functions that have not
    been tampered with are `puts` and `__libc_start_main`. For an even greater insight
    into the detection process, let's take a look at the source code for a tool that
    does automatic PLT/GOT validation as part of its detection capabilities. This
    tool is called `detect_plt_hooks` and was written in C. It utilizes the libecfs
    API to load and parse ECFS snapshots.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步调查将显示该地址指向`azazel.so`中的一个函数。从前面的输出中，我们可以看到，唯一没有被篡改的两个函数是`puts`和`__libc_start_main`。为了更深入地了解检测过程，让我们看一下一个工具的源代码，该工具作为其检测功能的一部分自动进行PLT/GOT验证。这个工具叫做`detect_plt_hooks`，是用C编写的。它利用libecfs
    API来加载和解析ECFS快照。
- en: Note that the following code has approximately 50 lines of source code, which
    is quite remarkable. If we were not using ECFS or libecfs, it would take approximately
    3,000 lines of C code to accurately analyze a process image for shared library
    injection and PLT/GOT hooks. I know this because I have done it, and using libecfs
    is by far the most painless way to go about coding such tools.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下代码大约有50行源代码，这相当了不起。如果我们不使用ECFS或libecfs，要准确分析共享库注入和PLT/GOT钩子的进程映像，大约需要3000行C代码。我知道这一点，因为我已经做过了，而使用libecfs是迄今为止最轻松的方法。
- en: 'Here''s a code example using `detect_plt_hooks.c`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用`detect_plt_hooks.c`的代码示例：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The ECFS reference guide
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECFS参考指南
- en: The ECFS file format is both simple and complicated! The ELF file format is
    complex in general, and ECFS inherits those complexities from a structural point
    of view. On the other side of the token, ECFS helps make navigating a process
    image quite easy if you know what specific features it has and what to look for.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ECFS文件格式既简单又复杂！总的来说，ELF文件格式本身就很复杂，ECFS从结构上继承了这些复杂性。另一方面，如果你知道它具有哪些特定特性以及要寻找什么，ECFS可以帮助你轻松地浏览进程映像。
- en: In previous sections, we gave some real-life examples of utilizing ECFS that
    demonstrated many of its primary features. However, it is also important to have
    a simple and direct reference to what those characteristics are, such as which
    custom sections exist and what exactly they mean. In this section, we will provide
    a reference for the ECFS snapshot files.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们给出了一些利用ECFS的实际例子，展示了它的许多主要特性。然而，重要的是要有一个简单直接的参考，了解这些特性是什么，比如存在哪些自定义节以及它们的确切含义。在本节中，我们将为ECFS快照文件提供一个参考。
- en: ECFS symbol table reconstruction
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ECFS符号表重建
- en: The ECFS handler uses advanced understanding of the ELF binary format and even
    the dwarf debugging format—specifically with the dynamic segment and the `GNU_EH_FRAME`
    segment—to fully reconstruct the symbol tables of the program. Even if the original
    binary has been stripped and has no section headers, the ECFS handler is intelligent
    enough to rebuild the symbol tables.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ECFS处理程序使用对ELF二进制格式甚至是dwarf调试格式的高级理解，特别是动态段和`GNU_EH_FRAME`段，来完全重建程序的符号表。即使原始二进制文件已经被剥离并且没有部分头，ECFS处理程序也足够智能，可以重建符号表。
- en: 'I have personally never encountered a situation where symbol table reconstruction
    failed completely. It usually reconstructs all or most symbol table entries. The
    symbol tables can be accessed using a utility such as `readelf` or `readecfs`.
    The libecfs API also has several functions:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人从未遇到过符号表重建完全失败的情况。它通常会重建所有或大多数符号表条目。可以使用诸如`readelf`或`readecfs`之类的实用程序访问符号表。libecfs
    API还具有几个功能：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: One function gets the dynamic symbol table and the other gets the local symbol
    table—`.dynsym` and `.symtab`, respectively.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数获取动态符号表，另一个获取本地符号表——分别是`.dynsym`和`.symtab`。
- en: 'The following is the reading symbol table with `readelf`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`readelf`读取符号表：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ECFS section headers
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ECFS部分头
- en: The ECFS handler reconstructs most of the original section headers that a program
    may have had. It also adds quite a few new sections and section types that can
    be very useful for forensic analysis. Section headers are identified by both name
    and type and contain data or code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ECFS处理程序重建了程序可能具有的大部分原始部分头。它还添加了一些非常有用的新部分和部分类型，对于取证分析非常有用。部分头由名称和类型标识，并包含数据或代码。
- en: Parsing section headers is very easy, and therefore they are very useful for
    creating a map of the process memory image. Navigating the entire process layout
    through section headers is a lot easier than having only program headers (such
    as with regular core files), which don't even have string names. The program headers
    are what describe the segments of memory, and the section headers are what give
    context to each part of a given segment. Section headers help give a much higher
    resolution to the reverse engineer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 解析部分头非常容易，因此它们对于创建进程内存映像的地图非常有用。通过部分头导航整个进程布局比仅具有程序头（例如常规核心文件）要容易得多，后者甚至没有字符串名称。程序头描述内存段，而部分头为给定段的每个部分提供上下文。部分头有助于为逆向工程师提供更高的分辨率。
- en: '| Section header | Description |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 部分头 | 描述 |'
- en: '| --- | --- |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `._TEXT` | This points to the text segment (not the `.text` section). This
    makes locating the text segment possible without having to parse the program headers.
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `._TEXT` | 这指向文本段（而不是`.text`部分）。这使得在不必解析程序头的情况下定位文本段成为可能。'
- en: '| `._DATA` | This points to the data segment (not the `.data` section). This
    makes locating the data segment possible without having to parse the program headers.
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `._DATA` | 这指向数据段（而不是`.data`部分）。这使得在不必解析程序头的情况下定位数据段成为可能。'
- en: '| `.stack` | This points to one of several possible stack segments depending
    on the number of threads. Without a section named `.stack`, it would be far more
    difficult to know where the actual stack of the process is. You would have to
    look at the value of the `%rsp` register and then see which program header segments
    contain address ranges that match the stack pointer value. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `.stack` | 这指向了几个可能的堆栈段之一，取决于线程的数量。如果没有名为`.stack`的部分，要知道进程的实际堆栈在哪里将会更加困难。您将不得不查看`%rsp`寄存器的值，然后查看哪些程序头段包含与堆栈指针值匹配的地址范围。'
- en: '| `.heap` | Similar to the `.stack` section, this points to the heap segment,
    also making identification of the heap much easier, especially on systems where
    ASLR moves the heap to random locations. On older systems, it was always extended
    from the data segment. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `.heap` | 类似于`.stack`部分，这指向堆段，也使得识别堆变得更加容易，特别是在ASLR将堆移动到随机位置的系统上。在旧系统上，它总是从数据段扩展的。'
- en: '| `.bss` | This section is not new with ECFS. The only reason it is mentioned
    here is that with an executable or shared library, the `.bss` section contains
    nothing, since uninitialized data takes up no space on disk. ECFS represents the
    memory, however, and the `.bss` section is not actually created until runtime.
    The ECFS files have a `.bss` section that actually reflects the uninitialized
    data variables being used by the process. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `.bss` | 此部分并非ECFS的新内容。之所以在这里提到它，是因为对于可执行文件或共享库，`.bss`部分不包含任何内容，因为未初始化的数据在磁盘上不占用空间。然而，ECFS表示内存，因此`.bss`部分实际上直到运行时才会被创建。ECFS文件具有一个实际反映进程使用的未初始化数据变量的`.bss`部分。'
- en: '| `.vdso` | This points to the [vdso] segment that is mapped into every Linux
    process containing code that is necessary for certain `glibc` system call wrappers
    to invoke the real system call. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `.vdso` | 这指向映射到每个Linux进程中的[vdso]段，其中包含对于某些`glibc`系统调用包装器调用真实系统调用所必需的代码。'
- en: '| `.vsyscall` | Similar to the `.vdso` code, the `.vsyscall` page contains
    code for invoking only a handful of virtual system calls. It has been kept around
    for backwards compatibility. It may prove useful to know this location during
    reverse engineering. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `.vsyscall` | 类似于`.vdso`代码，`.vsyscall`页面包含用于调用少量虚拟系统调用的代码。它已经保留了向后兼容性。在逆向工程中了解此位置可能会很有用。'
- en: '| `.procfs.tgz` | This section contains the entire directory structure and
    files for the `/proc/$pid` of the process that was captured by the ECFS handler.
    If you are an avid forensic analyst or programmer, then you probably already know
    how useful the information contained in the `proc` filesystem is. There are well
    over 300 files within `/proc/$pid` for a single process. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `.procfs.tgz` | 此部分包含由ECFS处理程序捕获的进程`/proc/$pid`的整个目录结构和文件。如果您是一位狂热的取证分析师或程序员，那么您可能已经知道`proc`文件系统中包含的信息有多么有用。对于单个进程，在`/proc/$pid`中有超过300个文件。'
- en: '| `.prstatus` | This section contains an array of struct `elf_prstatus` structures.
    Very important information pertaining to the state of the process and its registers
    is stored in these structures:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '| `.prstatus` | 此部分包含一系列`elf_prstatus`结构的数组。这些结构中存储了有关进程状态和寄存器状态的非常重要的信息：'
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `.fdinfo` | This section contains ECFS custom data that describes the file
    descriptors, sockets, and pipes being used for the processes'' open files, network
    connections, and inter-process communication. The header file, `ecfs.h`, defines
    the `fdinfo_t` type:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '| `.fdinfo` | 此部分包含描述进程打开文件、网络连接和进程间通信所使用的文件描述符、套接字和管道的ECFS自定义数据。头文件`ecfs.h`定义了`fdinfo_t`类型：'
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `readecfs` utility parses and displays the file descriptor information
    nicely, as shown when looking at an ECFS snapshot for sshd:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`readecfs`实用程序可以解析并漂亮地显示文件描述符信息，如查看sshd的ECFS快照时所示：'
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `.siginfo` | This section contains signal-specific information, such as what
    signal killed the process, or what the last signal code was before the snapshot
    was taken. The `siginfo_t struct` is stored in this section. The format of this
    struct can be seen in `/usr/include/bits/siginfo.h`. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `.siginfo` | 此部分包含特定信号的信息，例如杀死进程的信号，或者在快照被拍摄之前的最后一个信号代码。`siginfo_t struct`存储在此部分。此结构的格式可以在`/usr/include/bits/siginfo.h`中看到。|'
- en: '| `.auxvector` | This contains the actual auxiliary vector from the bottom
    of the stack (the highest memory address). The auxiliary vector is set up by the
    kernel at runtime, and it contains information that is passed to the dynamic linker
    at runtime. This information may prove valuable in a number of ways to the advanced
    forensic analyst. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `.auxvector` | 这包含来自堆栈底部（最高内存地址）的实际辅助向量。辅助向量由内核在运行时设置，它包含传递给动态链接器的运行时信息。这些信息对于高级取证分析人员可能在多种情况下都很有价值。'
- en: '| `.exepath` | This holds the string of the original executable path that was
    invoked for this process, that is, `/usr/sbin/sshd`. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `.exepath` | 这保存了为该进程调用的原始可执行路径的字符串，即`/usr/sbin/sshd`。|'
- en: '| `.personality` | This contains personality information, that is, ECFS personality
    information. An 8-byte unsigned integer can be set with any number of personality
    flags:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '| `.personality` | 这包含个性信息，即ECFS个性信息。可以使用8字节的无符号整数设置任意数量的个性标志：'
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `.arglist` | Contains the original `''char **argv''` stored as an array in
    this section. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `.arglist` | 包含存储为数组的原始`''char **argv''`。|'
- en: Using an ECFS file as a regular core file
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将ECFS文件用作常规核心文件
- en: The ECFS core file format is essentially backward compatible with regular Linux
    core files, and can therefore be used as core files for debugging with GDB in
    the traditional way.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ECFS核心文件格式基本上与常规Linux核心文件向后兼容，因此可以像传统方式一样与GDB一起用作调试核心文件。
- en: The ELF file header for ECFS files has its `e_type` (ELF type) set to `ET_NONE`
    instead of `ET_CORE`, however. This is because core files are not expected to
    have section headers but ECFS files do have section headers, and to make sure
    that they are acknowledged by certain utilities such as `objdump`, `objcopy`,
    and so on, we have to mark them as files other than CORE files. The quickest way
    to toggle the ELF type in an ECFS file is with the `et_flip` utility that comes
    with the ECFS software suite.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ECFS文件的ELF文件头将其`e_type`（ELF类型）设置为`ET_NONE`，而不是`ET_CORE`。这是因为核心文件不应该有节头，但ECFS文件确实有节头，为了确保它们被诸如`objdump`、`objcopy`等特定实用程序所承认，我们必须将它们标记为非CORE文件。在ECFS文件中切换ELF类型的最快方法是使用随ECFS软件套件一起提供的`et_flip`实用程序。
- en: 'Here''s an example of using GDB with an ECFS core file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用GDB与ECFS核心文件的示例：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, the following is an example of changing the ELF file type to `ET_CORE`
    and trying again:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，以下是将ELF文件类型更改为`ET_CORE`并重试的示例：
- en: '[PRE26]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The libecfs API and how to use it
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: libecfs API及其使用方法
- en: 'The libecfs API is the key component for integrating ECFS support into your
    malware analysis and reverse engineering tools for Linux. There is too much to
    document on this library to put into a single chapter of this book. I recommend
    that you use the manual that is still growing right alongside the project itself:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: libecfs API是将ECFS支持集成到Linux恶意软件分析和逆向工程工具中的关键组件。这个库的文档内容太多，无法放入本书的一个章节中。我建议您使用与项目本身一起不断增长的手册：
- en: '[https://github.com/elfmaster/ecfs/blob/master/Documentation/libecfs_manual.txt](https://github.com/elfmaster/ecfs/blob/master/Documentation/libecfs_manual.txt)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/elfmaster/ecfs/blob/master/Documentation/libecfs_manual.txt](https://github.com/elfmaster/ecfs/blob/master/Documentation/libecfs_manual.txt)'
- en: Process necromancy with ECFS
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ECFS进行进程复活
- en: Have you ever wanted to be able to pause and resume a process in Linux? After
    designing ECFS, it quickly became apparent that they contained enough information
    about the process and its state to relaunch them back into memory so that they
    can begin execution where they last left off. This feature has many possible use
    cases and demands more research and development.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾经想过能够在Linux中暂停和恢复进程？设计ECFS后，很快就显而易见，它们包含了足够的关于进程及其状态的信息，可以将它们重新加载到内存中，以便它们可以从上次停止的地方开始执行。这个功能有许多可能的用途，并需要更多的研究和开发。
- en: Currently, the implementation for ECFS snapshot execution is basic and can only
    handle simple processes. At the time of writing this chapter, it can restore file
    streams but not sockets or pipes, and can only handle single-threaded processes.
    The software for executing an ECFS snapshot can be found on GitHub at [https://github.com/elfmaster/ecfs_exec](https://github.com/elfmaster/ecfs_exec).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，ECFS快照执行的实现是基本的，只能处理简单的进程。在撰写本章时，它可以恢复文件流，但不能处理套接字或管道，并且只能处理单线程进程。执行ECFS快照的软件可以在GitHub上找到：[https://github.com/elfmaster/ecfs_exec](https://github.com/elfmaster/ecfs_exec)。
- en: 'Here''s an example of snapshot execution:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是快照执行的示例：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We now have the ECFS snapshot file print_passfile.6627 (Where 6627 is the process
    ID). We will use ecfs_exec to execute this snapshot, and it should begin where
    it left off:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了ECFS快照文件print_passfile.6627（其中6627是进程ID）。我们将使用ecfs_exec来执行这个快照，它应该会从离开的地方开始执行：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That is a very simple demonstration of how `ecfs_exec` works. It uses the file
    descriptor information from the `.fdinfo` section to learn the file descriptor
    number, file path, and file offset. It also uses the `.prstatus` and `.fpregset`
    sections to learn the register state so that it can resume execution from where
    it left off.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于`ecfs_exec`如何工作的非常简单的演示。它使用了来自`.fdinfo`部分的文件描述符信息来获取文件描述符号、文件路径和文件偏移量。它还使用了`.prstatus`和`.fpregset`部分来获取寄存器状态，以便可以从离开的地方恢复执行。
- en: Learning more about ECFS
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解更多关于ECFS的信息
- en: 'The extended core file snapshot technology, ECFS, is still relatively new.
    I presented on it at defcon 23 ([https://www.defcon.org/html/defcon-23/dc-23-speakers.html#O%27Neill](https://www.defcon.org/html/defcon-23/dc-23-speakers.html#O%27Neill)),
    and the word is still spreading. Hopefully, a community will evolve and more people
    will begin adopting ECFS for their daily forensics work and tools. Nonetheless,
    at this point, there are several resources for ECFS in existence:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展核心文件快照技术ECFS仍然相对较新。我在defcon 23上做了演讲（[https://www.defcon.org/html/defcon-23/dc-23-speakers.html#O%27Neill](https://www.defcon.org/html/defcon-23/dc-23-speakers.html#O%27Neill)），目前这个技术还在不断传播。希望会有一个社区的发展，更多人会开始采用ECFS进行日常取证工作和工具。尽管如此，目前已经存在一些关于ECFS的资源：
- en: 'The official GitHub page: [https://github.com/elfmaster/ecfs](https://github.com/elfmaster/ecfs)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 官方GitHub页面：[https://github.com/elfmaster/ecfs](https://github.com/elfmaster/ecfs)
- en: 'The original white paper (outdated): [http://www.leviathansecurity.com/white-papers/extending-the-elf-core-format-for-forensics-snapshots](http://www.leviathansecurity.com/white-papers/extending-the-elf-core-format-for-forensics-snapshots)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始白皮书（已过时）：[http://www.leviathansecurity.com/white-papers/extending-the-elf-core-format-for-forensics-snapshots](http://www.leviathansecurity.com/white-papers/extending-the-elf-core-format-for-forensics-snapshots)
- en: 'An article from POC || GTFO 0x7: *Innovations with core files*, [https://speakerdeck.com/ange/poc-gtfo-issue-0x07-1](https://speakerdeck.com/ange/poc-gtfo-issue-0x07-1)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POC || GTFO 0x7的一篇文章：*核心文件的创新*，[https://speakerdeck.com/ange/poc-gtfo-issue-0x07-1](https://speakerdeck.com/ange/poc-gtfo-issue-0x07-1)
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the basics of the ECFS snapshot technology and the
    snapshot format. We experimented with ECFS using several real-life forensic examples,
    and even wrote a tool that detects shared library injection and PLT/GOT hooks
    using the libecfs C library. In the next chapter, we will jump out of userland
    and explore the Linux kernel, the layout of vmlinux, and a combination of kernel
    rootkit and forensic techniques.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了ECFS快照技术和快照格式的基础知识。我们使用了几个真实的取证案例来实验ECFS，甚至编写了一个使用libecfs C库来检测共享库注入和PLT/GOT钩子的工具。在下一章中，我们将跳出用户空间，探索Linux内核、vmlinux的布局以及内核rootkit和取证技术的组合。
