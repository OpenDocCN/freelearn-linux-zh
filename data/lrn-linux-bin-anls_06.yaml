- en: Chapter 6. ELF Binary Forensics in Linux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。Linux中的ELF二进制取证
- en: The field of computer forensics is widespread and includes many facets of investigation.
    One such facet is the analysis of executable code. One of the most insidious places
    for a hacker to install some type of malicious functionality is within an executable
    file of some kind. In Linux, this is, of course, the ELF file type. We already
    explored some of the infection techniques that are being used in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*, but have spent very little time discussing the analysis
    phase. How exactly should an investigator go about exploring a binary for anomalies
    or code infections? That is what this chapter is all about.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机取证领域广泛，包括许多调查方面。其中一个方面是对可执行代码的分析。对于黑客来说，安装某种恶意功能的最阴险的地方之一就是在某种可执行文件中。在Linux中，当然是ELF文件类型。我们已经探讨了一些感染技术，这些技术正在使用[第4章](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "第4章。ELF病毒技术- Linux/Unix病毒")，*ELF病毒技术- Linux/Unix病毒*，但几乎没有讨论分析阶段。调查人员应该如何探索二进制文件中的异常或代码感染？这正是本章的主题。
- en: The motives for an attacker infecting an executable varies greatly, and it may
    be for a virus, a botnet, or a backdoor. There are, of course, many cases where
    an individual wants to patch or modify a binary to achieve totally different ends
    such as binary protection, code patching, or other experimentation. Whether malicious
    or not, the binary modification methods are all the same. The inserted code is
    what determines whether or not the binary is possessed with malicious intent.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者感染可执行文件的动机各不相同，可能是病毒、僵尸网络或后门。当然，还有许多情况下，个人想要修补或修改二进制文件以达到完全不同的目的，比如二进制保护、代码修补或其他实验。无论是恶意还是不恶意，二进制修改方法都是一样的。插入的代码决定了二进制文件是否具有恶意意图。
- en: In either case, this chapter will arm the reader with the insight necessary
    for determining whether or not a binary has been modified, and how exactly it
    has been modified. In the following pages, we will be examining several different
    types of infections and will even discuss some of my findings when performing
    a real-world analysis of the Retaliation Virus for Linux that was engineered by
    one of the world's most skilled Virus authors named JPanic. This chapter is all
    about training your eye to be able to spot anomalies within an ELF binary file,
    and with some practice it becomes quite possible to do so with ease.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，本章都将为读者提供必要的洞察力，以确定二进制文件是否已被修改，以及它究竟是如何被修改的。在接下来的页面中，我们将研究几种不同类型的感染，甚至讨论在对由世界上最有技术的病毒作者之一JPanic设计的Linux报复病毒进行实际分析时的一些发现。本章的目的是训练您的眼睛能够在ELF二进制文件中发现异常，通过一些实践，这是完全可能的。
- en: The science of detecting entry point modification
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测入口点修改的科学
- en: When a binary is modified in some way, it is generally for the purpose of adding
    code to the binary and then redirecting execution flow to that code. The redirection
    of execution flow can happen in many places within the binary. In this particular
    case, we are going to examine a very common technique used when patching binaries,
    especially for viruses. This technique is to simply modify the entry point, which
    is the `e_entry` member of the ELF file header.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当二进制文件以某种方式被修改时，通常是为了向二进制文件添加代码，然后将执行流重定向到该代码。执行流的重定向可以发生在二进制文件的许多位置。在这种特殊情况下，我们将研究一种在修补二进制文件时经常使用的非常常见的技术，特别是对于病毒。这种技术就是简单地修改入口点，即ELF文件头的`e_entry`成员。
- en: The goal is here to determine whether or not `e_entry` is holding an address
    that points to a location that signifies an abnormal modification to the binary.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是确定`e_entry`是否保存了指向表示二进制文件异常修改的位置的地址。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Abnormal means any modification that wasn't created by the linker itself `/usr/bin/ld`
    whose job it is to link ELF objects together. The linker will create a binary
    that represents normalcy, whereas an unnatural modification often appears suspicious
    to the trained eye.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 异常意味着任何不是由链接器本身`/usr/bin/ld`创建的修改，链接器的工作是将ELF对象链接在一起。链接器将创建一个代表正常状态的二进制文件，而不自然的修改通常会引起受过训练的眼睛的怀疑。
- en: 'The quickest route to being able to detect anomalies is to first know what
    is normal. Let''s take a look at two normal binaries: one dynamically linked and
    the other statically linked. Both have been compiled with `gcc` and neither has
    been tampered with in any way:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 能够快速检测异常的最快途径是首先了解什么是正常的。让我们来看看两个正常的二进制文件：一个是动态链接的，另一个是静态链接的。两者都是使用`gcc`编译的，没有经过任何修改：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So we can see that the entry point is `0x400520`. If we look at the section
    headers, we can see what section this address falls into:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到入口点是`0x400520`。如果我们查看部分头，我们可以看到这个地址属于哪个部分：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In our example, the entry point starts at the beginning of the `.text` section.
    This is not always so, and therefore grepping for the first significant hex-digits,
    as we did previously isn't a consistent approach. It is recommended that you check
    both the address and size of each section header until you find the section with
    an address range that contains the entry point.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，入口点从`.text`部分的开头开始。这并不总是这样，因此像之前那样搜索第一个重要的十六进制数字并不是一种一致的方法。建议您检查每个部分头的地址和大小，直到找到包含入口点的地址范围的部分。
- en: 'As we can see, it points right to the beginning of the `.text` section, which
    is common, but depending on how the binary was compiled and linked, this may change
    with each binary you look at. This binary was compiled so that it was linked to
    libc just like 99 percent of the binaries you will encounter are. This means that
    the entry point contains some special initialization code and it looks almost
    identical in every single libc-linked binary, so let''s take a look at it so we
    can know what to expect when analyzing the entry point code of binaries:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，它指向了`.text`段的开头，这是常见的，但根据二进制文件的编译和链接方式，每个二进制文件可能会有所不同。这个二进制文件是被编译成与libc链接的，就像你遇到的99%的二进制文件一样。这意味着入口点包含一些特殊的初始化代码，在每个libc链接的二进制文件中几乎是相同的，所以让我们来看看它，这样我们就知道在分析二进制文件的入口点代码时可以期待什么：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding assembly code is the standard glibc initialization code pointed
    to by `e_entry` of the ELF header. This code is always executed before `main()`
    and its purpose is to call the initialization routine `libc_start_main()`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的汇编代码是由ELF头部的`e_entry`指向的标准glibc初始化代码。这段代码总是在`main()`之前执行，其目的是调用初始化例程`libc_start_main()`：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function sets up the process heap segment, registers constructors and destructors,
    and initializes threading-related data. Then it calls `main()`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数设置进程堆段，注册构造函数和析构函数，并初始化与线程相关的数据。然后调用`main()`。
- en: Now that you know what the entry point code looks like on a libc-linked binary,
    you should be able to easily determine when the entry point address is suspicious,
    when it points to code that does not look like this, or when it is not even in
    the `.text` section at all!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了libc链接二进制文件的入口点代码是什么样子，你应该能够轻松地确定入口点地址是否可疑，当它指向不像这样的代码，或者根本不在`.text`段中时！
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A binary that is statically linked with libc will have initialization code in
    _start that is virtually identical to the preceding code, so the same rule applies
    for statically linked binaries as well.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与libc静态链接的二进制文件将在_start中具有与前面代码几乎相同的初始化代码，因此对于静态链接的二进制文件也适用相同的规则。
- en: 'Now let''s take a look another binary that has been infected with the Retaliation
    Virus and see what type of oddities we find with the entry point:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看另一个被Retaliation病毒感染的二进制文件，并看看入口点存在什么样的奇怪之处：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A quick examination of the section headers with `readelf -S` will prove that
    this address is not accounted for by any section header, which is extremely suspicious.
    If an executable has section headers and there is an executable area that is not
    accounted for by a section, then it is almost certainly a sign of infection or
    binary patching. For code to be executed, section headers are not necessary as
    we've already learned, but program headers are.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`readelf -S`快速检查段头部，将证明这个地址没有被任何段头部记录，这是非常可疑的。如果一个可执行文件有段头部，并且有一个未被段记录的可执行区域，那几乎肯定是感染或二进制文件被篡改的迹象。要执行代码，段头部是不必要的，因为我们已经学过，但程序头部是必要的。
- en: 'Let''s take a look and see what segment this address fits into by looking at
    the program headers with `readelf -l`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看通过使用`readelf -l`查看程序头部，这个地址属于哪个段：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This output is extremely suspicious for several reasons. Typically, we only
    see two LOAD segments with one ELF executable—one for the text and one for the
    data—although this is not a strict rule. Nevertheless, it is the norm, and this
    binary is showing three segments.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出有几个非常可疑的原因。通常，我们只会在一个ELF可执行文件中看到两个LOAD段——一个用于文本，一个用于数据——尽管这不是一个严格的规则。然而，这是正常情况，而这个二进制文件显示了三个段。
- en: Moreover, this segment is suspiciously marked RWE (read + write + execute),
    which indicates self-modifying code, commonly used with viruses that have polymorphic
    engines such as this one. The entry point, points inside this third segment, when
    it should be pointing to the first segment (the text segment), which, as we can
    see, starts at the virtual address `0x400000`, which is the typical text segment
    address for executables on Linux x86_64\. We don't even have to look at the code
    to be fairly confident that this binary has been patched.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个段可疑地标记为RWE（读+写+执行），这表明存在自修改代码，通常与具有多态引擎的病毒一起使用。入口点指向这第三个段内部，而它应该指向第一个段（文本段），我们可以看到，文本段的虚拟地址为`0x400000`，这是Linux
    x86_64可执行文件的典型文本段地址。我们甚至不需要查看代码就可以相当有信心地认为这个二进制文件已经被篡改。
- en: But for verification, especially if you are designing code that performs automated
    analysis of binaries, you can check the code at the entry point and see if it
    matches what it is expected to look like, which is the libc initialization code
    we looked at earlier.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为了验证，特别是如果你正在设计执行二进制文件自动分析的代码，你可以检查入口点的代码，看它是否与预期的样子相匹配，这就是我们之前看到的libc初始化代码。
- en: 'The following `gdb` command is displaying the disassembled instructions found
    at the entry point of the `retal_virus_sample` executable:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`gdb`命令显示了在`retal_virus_sample`可执行文件的入口点处找到的反汇编指令：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I think we can quickly agree that the preceding code does not look like the
    libc initialization code that we would expect to see in the entry point code of
    an untampered executable. You can simply compare it with the expected libc initialization
    code that we looked at from `bin1` to find this out.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为我们可以很快地达成一致，前面的代码看起来不像我们期望在未篡改的可执行文件的入口点代码中看到的libc初始化代码。你可以简单地将它与我们从`bin1`中查看的预期libc初始化代码进行比较来找出这一点。
- en: Other signs of modified entry points are when the address points to any section
    outside of the `.text` section, especially if it's a section that is the last-most
    section within the text segment (sometimes this the `.eh_frame` section). Another
    sure sign is if the address points to a location within the data segment that
    will generally be marked as executable (visible with `readelf -l`) so that it
    can execute the parasite code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 修改入口点的其他迹象是地址指向`.text`部分之外的任何部分，特别是如果它是文本段内最后一个部分（有时是`.eh_frame`部分）。另一个确定的迹象是，如果地址指向数据段内通常标记为可执行的位置（使用`readelf
    -l`可见），以便执行寄生代码。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Typically, the data segment is marked as RW, because no code is supposed to
    be executing in that segment. If you see the data marked RWX then let that serve
    as a red flag, because it is extremely suspicious.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数据段标记为RW，因为不应该在该段中执行任何代码。如果您看到数据标记为RWX，那么请将其视为一个警告信号，因为这是极其可疑的。
- en: Modifying the entry point is not the only way to create an entry point to insert
    code. It is a common way to achieve it, and being able to detect this is an important
    heuristic, especially in malware because it can reveal the start point of the
    parasite code. In the next section, we will discuss other methods used to hijack
    control flow, which is not always at the beginning of execution, but in the middle
    or even at the end.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 修改入口点并不是创建插入代码的唯一方法。这是一种常见的方法，能够检测到这一点是一种重要的启发式方法，特别是在恶意软件中，因为它可以揭示寄生代码的起始点。在下一节中，我们将讨论用于劫持控制流的其他方法，这并不总是在执行的开始，而是在中间甚至在结束时。
- en: Detecting other forms of control flow hijacking
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测其他形式的控制流劫持
- en: There are many reasons to modify a binary, and depending on the desired functionality,
    the binary control flow will be patched in different ways. In the previous example
    of the Retaliation Virus, the entry point in the ELF file header was modified.
    There are many other ways to transfer execution to the inserted code, and we will
    discuss a few of the more common approaches.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因可以修改二进制文件，根据所需的功能，二进制控制流将以不同的方式进行修补。在前面关于报复病毒的示例中，修改了ELF文件头中的入口点。还有许多其他方法可以将执行转移到插入的代码，我们将讨论一些更常见的方法。
- en: Patching the .ctors/.init_array section
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修补.ctors/.init_array部分
- en: In ELF executables and shared libraries, you will notice that there is a section
    commonly present named `.ctors` (commonly also named `.init_array`). This section
    contains an array of addresses that are function pointers called by the initialization
    code from the `.init` section. The function pointers refer to functions created
    with the constructor attribute, which are executed before `main()`. This means
    that the `.ctors` function pointer table can be patched with an address that points
    to the code that has been injected into the binary, which we refer to as the parasite
    code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在ELF可执行文件和共享库中，您会注意到通常存在一个名为`.ctors`（通常也称为`.init_array`）的部分。该部分包含一个地址数组，这些地址是由`.init`部分的初始化代码调用的函数指针。函数指针指向使用构造函数属性创建的函数，在`main()`之前执行。这意味着`.ctors`函数指针表可以使用指向已注入到二进制文件中的代码的地址进行修补，我们称之为寄生代码。
- en: It is relatively easy to check whether or not one of the addresses in the `.ctors`
    section is valid. The constructor routines should always be stored specifically
    within the `.text` section of the text segment. Remember from [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*, that the `.text`
    section is not the text segment, but rather a section that resides within the
    range of the text segment. If the `.ctors` section contains any function pointers
    that refer to locations outside of the `.text` section, then it is probably time
    to get suspicious.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`.ctors`部分中的地址是否有效相对容易。构造函数例程应始终存储在文本段的`.text`部分中。请记住来自[第2章](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "第2章。ELF二进制格式")，《ELF二进制格式》，`.text`部分不是文本段，而是驻留在文本段范围内的部分。如果`.ctors`部分包含任何指向`.text`部分之外位置的函数指针，那么可能是时候产生怀疑了。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**A side note on .ctors for anti-anti-debugging**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于.ctors用于反反调试的一点说明**'
- en: Some binaries that incorporate anti-debugging techniques will actually create
    a legal constructor function that calls `ptrace(PTRACE_TRACEME, 0);`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一些包含反调试技术的二进制文件实际上会创建一个合法的构造函数，调用`ptrace(PTRACE_TRACEME, 0);`。
- en: As discussed in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*, this technique prevents a debugger from attaching to the
    process since only one tracer can be attached at any given time. If you discover
    that a binary has a function that performs this anti-debugging trick and has a
    function pointer in `.ctors`, then it is advised to simply patch that function
    pointer with `0x00000000` or `0xffffffff` that will direct the `__libc_start_main()`
    function to ignore it, therefore effectively disabling the anti-debugging technique.
    This task could be easily accomplished in GDB with the set command, for example,
    `set {long}address = 0xffffffff`, assuming that address is the location of the
    .ctors entry you want to modify.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第4章](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985 "第4章。ELF病毒技术-
    Linux/Unix病毒")，《ELF病毒技术- Linux/Unix病毒》中所讨论的，这种技术可以防止调试器附加到进程，因为一次只能附加一个跟踪器。如果发现二进制文件具有执行此反调试技巧的函数，并且在`.ctors`中具有函数指针，则建议简单地使用`0x00000000`或`0xffffffff`对该函数指针进行修补，这将使`__libc_start_main()`函数忽略它，从而有效地禁用反调试技术。在GDB中可以轻松完成此任务，例如，`set
    {long}address = 0xffffffff`，假设address是要修改的.ctors条目的位置。
- en: Detecting PLT/GOT hooks
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测PLT/GOT挂钩
- en: This technique has been used as far back as 1998 when it was published by Silvio
    Cesare in [http://phrack.org/issues/56/7.html](http://phrack.org/issues/56/7.html),
    which discusses the techniques of shared library redirection.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术早在1998年就已经被使用，当时由Silvio Cesare在[http://phrack.org/issues/56/7.html](http://phrack.org/issues/56/7.html)上发表，其中讨论了共享库重定向的技术。
- en: In [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*, we carefully examined
    dynamic linking and I explained the inner workings of the **PLT** (**procedure
    linkage table**) and **GOT** (**global offset table**). Specifically, we looked
    at lazy linking and how the PLT contains code stubs that transfer control to addresses
    that are stored in the GOT. If a shared library function such as `printf` has
    never been called before, then the address stored in the GOT will point back to
    the PLT, which then invokes the dynamic linker, subsequently filling in the GOT
    with the address that points to the `printf` function from the libc shared library
    that is mapped into the process address space.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985 "第2章。ELF二进制格式")中，*ELF二进制格式*，我们仔细研究了动态链接，并解释了**PLT**（过程链接表）和**GOT**（全局偏移表）的内部工作原理。具体来说，我们研究了延迟链接以及PLT包含的代码存根，这些代码存根将控制转移到存储在GOT中的地址。如果共享库函数（如`printf`）以前从未被调用过，则存储在GOT中的地址将指向PLT，然后调用动态链接器，随后填充GOT，使其指向映射到进程地址空间中的libc共享库中的`printf`函数的地址。
- en: It is common for both static (at rest) and hot-patching (in memory) to modify
    one or more GOT entries so that a patched in function is called instead of the
    original. We will examine a binary that has been injected with an object file
    that contains a function that simply writes a string to `stdout`. The GOT entry
    for `puts(char *);` has been patched with an address that points to the injected
    function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 静态（静止）和热修补（内存中）通常会修改一个或多个GOT条目，以便调用一个经过修补的函数而不是原始函数。我们将检查一个已注入包含一个简单将字符串写入`stdout`的函数的目标文件的二进制文件。`puts(char
    *);`的GOT条目已被修补，指向注入函数的地址。
- en: 'The first three GOT entries are reserved and will typically not be patched
    because it will likely prevent the executable from running correctly (See [Chapter
    2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985 "Chapter 2. The
    ELF Binary Format"), *The ELF Binary Format*, section on Dynamic linking). Therefore,
    as analysts, we are interested in observing the entries starting at GOT[3]. Each
    GOT value should be an address. The address can have one of two values that would
    be considered valid:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个GOT条目是保留的，通常不会被修补，因为这可能会阻止可执行文件正确运行（请参阅[第2章](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "第2章。ELF二进制格式")，*ELF二进制格式*，动态链接部分）。因此，作为分析人员，我们对观察从GOT[3]开始的条目感兴趣。每个GOT值应该是一个地址。该地址可以有两个被认为是有效的值：
- en: Address pointer that points back into the PLT
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向PLT的地址指针
- en: Address pointer that points to a valid shared library function
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向有效共享库函数的地址指针
- en: When a binary is infected on disk (versus runtime infection), then a GOT entry
    will be patched with an address that points somewhere within the binary where
    code has been injected. Recall from [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*, that there are numerous ways to inject code into an executable
    file. In the binary sample that we will look at here, a relocatable object file
    (`ET_REL`) was inserted at the end of the text segment using the Silvio padding
    infection discussed in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当二进制文件在磁盘上被感染（而不是运行时感染）时，GOT条目将被修补，指向二进制文件中已注入代码的某个地方。请回顾[第4章](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "第4章。ELF病毒技术- Linux/Unix病毒")中讨论的内容，*ELF病毒技术- Linux/Unix病毒*，其中介绍了将代码注入可执行文件的多种方法。在我们将在这里查看的二进制文件示例中，使用了可重定位目标文件（`ET_REL`），该文件被插入到文本段的末尾，使用了[第4章](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "第4章。ELF病毒技术- Linux/Unix病毒")中讨论的Silvio填充感染。
- en: When analyzing the `.got.plt` section of a binary that has been infected, we
    must carefully validate each address from GOT[4] through GOT[N]. This is still
    easier than looking at the binary in memory because before the binary is executed,
    the GOT entries should always point only to the PLT, as no shared library functions
    have been resolved yet.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 分析已感染的二进制文件的`.got.plt`部分时，我们必须仔细验证从GOT[4]到GOT[N]的每个地址。这仍然比查看内存中的二进制文件要容易，因为在执行二进制文件之前，GOT条目应该始终只指向PLT，因为尚未解析共享库函数。
- en: Using the `readelf -S` utility and looking for the `.plt` section, we can deduce
    the PLT address range. In the case of the 32-bit binary I am looking at now, it
    is `0x8048300` - `0x8048350`. Remember this range before we look at the following
    `.got.plt` section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`readelf -S`实用程序并查找`.plt`部分，我们可以推断出PLT地址范围。在我现在查看的32位二进制文件中，它是`0x8048300`
    - `0x8048350`。在查看以下`.got.plt`部分之前，请记住这个范围。
- en: Truncated output from readelf -S command
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从readelf -S命令的截断输出
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now let''s take a look at the `.got.plt` section of a 32-bit binary and see
    if any of the relevant addresses are pointing outside of `0x8048300`–`0x8048350`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看32位二进制文件的`.got.plt`部分，看看是否有任何相关地址指向`0x8048300`–`0x8048350`之外的地方：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So let''s take these addresses out of their little endian byte ordering and
    validate that each one points within the `.plt` section as expected:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们把这些地址从它们的小端字节顺序中取出，并验证每个地址是否按预期指向`.plt`部分内：
- en: '`08048628`: This does not point to PLT!'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`08048628`：这不指向PLT！'
- en: '`08048326`: This is valid'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`08048326`：这是有效的'
- en: '`08048336`: This is valid'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`08048336`：这是有效的'
- en: '`08048346`: This is valid'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`08048346`：这是有效的'
- en: 'The GOT location `0x804a00c` contains the address `0x8048628`, which does not
    point to a valid location. We can see what shared library function `0x804a00c`
    corresponds to by looking at the relocation entries with the `readelf -r` command,
    which shows us that the infected GOT entry corresponds to the libc function `puts()`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: GOT位置`0x804a00c`包含地址`0x8048628`，它并不指向有效的位置。我们可以通过使用`readelf -r`命令查看重定位条目来查看`0x804a00c`对应的共享库函数，这会显示感染的GOT条目对应于libc函数`puts()`：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So the GOT location `0x804a00c` is the relocation unit for the `puts()` function.
    Typically, it should contain an address that points to the PLT stub for the GOT
    offset so that the dynamic linker will be invoked and resolve the runtime value
    for that symbol. In this case, the GOT entry contains the address `0x8048628`,
    which points to a suspicious bit of code at the end of the text segment:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，GOT位置`0x804a00c`是`puts()`函数的重定位单元。通常情况下，它应该包含一个指向GOT偏移的PLT存根的地址，以便动态链接器被调用并解析该符号的运行时值。在这种情况下，GOT条目包含地址`0x8048628`，它指向文本段末尾的可疑代码：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Technically, we don''t even have to know what this code does in order to know
    that the GOT was hijacked because the GOT should only contain addresses that point
    to the PLT, and this is clearly not a PLT address:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们甚至不需要知道这段代码的功能，就可以知道GOT被劫持了，因为GOT应该只包含指向PLT的地址，而这显然不是PLT地址：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A further exercise would be to disinfect this binary manually, which is something
    we do in the ELF workshop trainings I provide periodically. Disinfecting this
    binary would primarily entail patching the `.got.plt` entry that contains the
    pointer to the parasite and replacing it with a pointer to the appropriate PLT
    stub.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步的练习将是手动清除这个二进制文件，这是我定期提供的ELF研讨会培训中的一部分。清除这个二进制文件主要涉及对包含指向寄生体的`.got.plt`条目进行修补，并用指向适当PLT存根的指针替换它。
- en: Detecting function trampolines
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测函数跳板
- en: The term trampoline is used loosely but is originally referred to inline code
    patching, where the insertion of a branch instruction such as a `jmp` is placed
    over the first 5 to 7 bytes of the procedure prologue of a function. Often times,
    this trampoline is temporarily replaced with the original code bytes if the function
    that was patched needs to be called in such a way that it behaves as it originally
    did, and then the trampoline instruction is quickly placed back again. Detecting
    inline code hooks such as these is quite easy and can even be automated with some
    degree of ease provided you have a program or script that can disassemble a binary.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 术语跳板的使用比较宽泛，但最初是指内联代码修补，其中在函数的过程序言的前5到7个字节上放置了一个`jmp`等分支指令。通常情况下，如果需要以原始方式调用被修补的函数，那么这个跳板会被临时替换为原始代码字节，然后迅速放回跳板指令。检测这类内联代码钩子非常容易，甚至可以通过某种程度的程序或脚本来自动化。
- en: 'Following are two examples of trampoline code (32-bit x86 ASM):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是两个跳板代码的示例（32位x86汇编语言）：
- en: 'Type 1:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型1：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Type 2:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型2：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: A good classic paper on using function trampolines for function hijacking in
    kernel space was written by Silvio in 1999\. The same concepts can be applied
    today in userland and in the kernel; for the kernel you would have to disable
    the write protect bit in the cr0 register to make the text segment writeable,
    or directly modify a PTE to mark a given page as writeable. I personally have
    had more success with the former method. The original paper on kernel function
    trampolines can be found at [http://vxheaven.org/lib/vsc08.html](http://vxheaven.org/lib/vsc08.html).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 1999年Silvio撰写了一篇关于在内核空间中使用函数跳板进行函数劫持的经典论文。相同的概念可以应用于用户空间和内核；对于内核，您需要禁用cr0寄存器中的写保护位，使文本段可写，或者直接修改PTE以将给定页面标记为可写。我个人更喜欢前一种方法。关于内核函数跳板的原始论文可以在[http://vxheaven.org/lib/vsc08.html](http://vxheaven.org/lib/vsc08.html)找到。
- en: The quickest way to detect function trampolines is to locate the entry point
    of every single function and verify that the first 5 to 7 bytes of code do not
    translate to some type of branch instruction. It would be very easy to write a
    Python script for GDB that can do this. I have written C code to do this in the
    past fairly easily.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 检测函数跳板的最快方法是找到每个函数的入口点，并验证代码的前5到7个字节是否不是某种分支指令。编写一个可以做到这一点的GDB的Python脚本将非常容易。我以前很容易就写了C代码来做到这一点。
- en: Identifying parasite code characteristics
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别寄生代码特征
- en: We just reviewed some common methods for hijacking execution flow. If you can
    identify where the execution flow points, you can typically identify some or all
    of the parasite code. In the section *Detecting PLT/GOT hooks*, we determined
    the location of the parasite code for the hijacked `puts()` function by simply
    locating the PLT/GOT entry that had been modified and seeing where that address
    pointed to, which, in that case, was to an appended page containing parasite code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚回顾了一些劫持执行流的常见方法。如果您可以确定执行流指向的位置，通常可以识别一些或所有的寄生代码。在*检测PLT/GOT钩子*部分，我们通过简单地定位已修改的PLT/GOT条目并查看该地址指向的位置来确定劫持`puts()`函数的寄生代码的位置，而在这种情况下，它指向了一个包含寄生代码的附加页面。
- en: Parasite code can be qualified as code that is unnaturally inserted into the
    binary; in other words, it wasn't linked in by the actual ELF object linker. With
    that said, there are several characteristics that can sometimes be attributed
    to injected code, depending on the techniques used.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 寄生代码可以被定义为不自然地插入二进制文件的代码；换句话说，它不是由实际的ELF对象链接器链接进来的。话虽如此，根据使用的技术，有几个特征有时可以归因于注入的代码。
- en: '**Position independent code** (**PIC**) is often used for parasites so that
    it can be injected into any point of a binary or memory and still execute properly
    regardless of its position in memory. PIC parasites are easier to inject into
    an executable because the code can be inserted into the binary without having
    to consider handling relocations. In some cases, such as with my Linux padding
    Virus [http://www.bitlackeys.org/projects/lpv.c](http://www.bitlackeys.org/projects/lpv.c),
    the parasite is compiled as an executable with the gcc-nostdlib flag. It is not
    compiled as position independent, but it has no libc linking, and special care
    is taken within the parasite code itself to dynamically resolve memory addresses
    with instruction-pointer relative computations.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置无关代码**（**PIC**）经常用于寄生体，以便它可以被注入到二进制或内存的任何位置，并且无论其在内存中的位置如何，都可以正常执行。PIC寄生体更容易注入到可执行文件中，因为代码可以插入到二进制文件中，而无需考虑处理重定位。在某些情况下，比如我的Linux填充病毒[http://www.bitlackeys.org/projects/lpv.c](http://www.bitlackeys.org/projects/lpv.c)，寄生体被编译为一个带有gcc-nostdlib标志的可执行文件。它没有被编译为位置无关，但它没有libc链接，并且在寄生体代码本身中特别注意动态解析内存地址与指令指针相关的计算。'
- en: In many cases, the parasite code is written purely in assembly language and
    is therefore in a sense more identifiable as being a potential parasite since
    it will look different from what the compiler produces. One of the giveaways with
    parasite code written in assembly is the way in which syscalls are handled. In
    C code, typically syscalls are called through libc functions that will invoke
    the actual syscall. Therefore, syscalls look just like regular dynamically linked
    functions. In handwritten assembly code, syscalls are usually invoked directly
    using either the Intel sysenter or syscall instructions, and sometimes even `int
    0x80` (which is now considered legacy). If syscall instructions are present, we
    may consider it a red flag.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，寄生代码纯粹是用汇编语言编写的，因此在某种意义上更容易识别为潜在的寄生体，因为它看起来与编译器生成的代码不同。用汇编语言编写的寄生代码的一个特征是系统调用的处理方式。在C代码中，通常通过libc函数调用系统调用，这些函数将调用实际的系统调用。因此，系统调用看起来就像常规的动态链接函数。在手写的汇编代码中，系统调用通常是直接使用Intel
    sysenter或syscall指令调用的，有时甚至使用`int 0x80`（现在被认为是遗留的）。如果存在系统调用指令，我们可能会认为这是一个警告信号。
- en: Another red flag, especially when analyzing a remote process that may be infected,
    is to see `int3` instructions that can serve many purposes such as passing control
    back to a tracing process that is performing the infection or, even more disturbing,
    the ability to trigger some type of anti-debugging mechanism within malware or
    a binary protector.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个警告信号，特别是在分析可能被感染的远程进程时，是看到`int3`指令，它可以用于许多目的，比如将控制权传递回执行感染的跟踪进程，甚至更令人不安的是，触发恶意软件或二进制保护程序中的某种反调试机制的能力。
- en: 'The following 32-bit code memory maps a shared library into a process and then
    passes control back to the tracer with an `int3`. Notice that `int 0x80` is being
    used to invoke the syscalls. This shellcode is actually quite old; I wrote it
    in 2008\. Typically, nowadays we want to use either the sysenter or syscall instruction
    to invoke a system call in Linux, but the `int 0x80` will still work; it is just
    slower and therefore considered deprecated:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下32位代码将一个共享库映射到进程中，然后使用`int3`将控制权传递回跟踪器。请注意，`int 0x80`被用于调用系统调用。这个shellcode实际上很老了；我是在2008年写的。通常，现在我们希望在Linux中使用sysenter或syscall指令来调用系统调用，但`int
    0x80`仍然有效；只是速度较慢，因此被认为是过时的。
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you were to see this code inside an executable on disk or in memory, you
    should quickly come to the conclusion that it does not look like compiled code.
    One dead giveaway is the **call/pop technique** that is used to dynamically retrieve
    the address of `/lib/libtest.so.1.0`. The string is stored right after the `call
    A` instruction and therefore its address is pushed onto the stack, and then you
    can see that it gets popped into `ebx`, which is not conventional compiler code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在磁盘上或内存中看到这段代码，你应该很快就会得出结论，它看起来不像是编译后的代码。一个明显的特征是使用**call/pop技术**来动态检索`/lib/libtest.so.1.0`的地址。该字符串存储在`call
    A`指令之后，因此它的地址被推送到堆栈上，然后你可以看到它被弹出到`ebx`中，这不是常规的编译器代码。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Checking the dynamic segment for DLL injection traces
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查动态段以查找DLL注入痕迹
- en: Recall from [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*, that the dynamic
    segment can be found in the program header table and is of type `PT_DYNAMIC`.
    There is also a `.dynamic` section that also points to the dynamic segment.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第2章](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985 "第2章。ELF二进制格式")，*ELF二进制格式*，动态段可以在程序头表中找到，类型为`PT_DYNAMIC`。还有一个`.dynamic`部分，也指向动态段。
- en: 'The dynamic segment is an array of ElfN_Dyn structs that contains `d_tag` and
    a corresponding value that exists in a union:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 动态段是一个包含`d_tag`和相应值的ElfN_Dyn结构数组，该值存在于一个联合体中：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using `readelf` we can easily view the dynamic segment of a file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`readelf`我们可以轻松查看文件的动态段。
- en: 'Following is an example of a legitimate dynamic segment:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个合法的动态段的示例：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There are many important tag types here that are necessary for the dynamic linker
    to navigate the binary at runtime so that it can resolve relocations and load
    libraries. Notice that the tag type called `NEEDED` is highlighted in the preceding
    code. This is the dynamic entry that tells the dynamic linker which shared libraries
    it needs to load into memory. The dynamic linker will search for the named shared
    library in the paths specified by the $`LD_LIBRARY_PATH` environment variable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有许多重要的标签类型，这些标签类型对于动态链接器在运行时导航二进制文件以便解析重定位和加载库是必要的。请注意，前面的代码中突出显示了称为`NEEDED`的标签类型。这是告诉动态链接器需要加载到内存中的共享库的动态条目。动态链接器将在由$`LD_LIBRARY_PATH`环境变量指定的路径中搜索指定的共享库。
- en: It is clearly conceivable for an attacker to add a `NEEDED` entry into the binary
    that is specifying a shared library to load. This is not a very common technique
    in my experience, but it is a technique that can be used tell the dynamic linker
    to load whichever library you want. The problem for analysts is that this technique
    is difficult to detect if it is done correctly, which is to say that the inserted
    `NEEDED` entry is inserted directly after the last legitimate `NEEDED` entry.
    This can be difficult because you have to move all of the other dynamic entries
    forward to make room for your insertion.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，攻击者可以向二进制文件中添加一个指定要加载的共享库的`NEEDED`条目。在我的经验中，这不是一种非常常见的技术，但这是一种可以用来告诉动态链接器加载任何你想要的库的技术。分析人员面临的问题是，如果操作正确，这种技术很难检测，也就是说，插入的`NEEDED`条目直接放在最后一个合法的`NEEDED`条目之后。这可能很困难，因为你必须将所有其他动态条目向前移动，为你的插入腾出空间。
- en: In many cases, the attacker may do this the inexperienced way where the `NEEDED`
    entry is at the very end of all other entries, which the object linker would never
    do, so if you see a dynamic segment that looks like the following, you know something
    is up.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，攻击者可能会以经验不足的方式进行操作，其中`NEEDED`条目位于所有其他条目的最末尾，而对象链接器永远不会这样做，因此，如果你看到一个动态段看起来像下面这样，你就知道出了问题。
- en: 'The following is an example of an infected dynamic segment:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个感染的动态段的示例：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Identifying reverse text padding infections
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别反向文本填充感染
- en: This is a virus infection technique that we discussed in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*. The idea is that a virus or parasite can make room for
    its code by extending the text segment in reverse. The program header for the
    text segment will look strange if you know what you're looking for.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种我们在[第4章](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "第4章。ELF病毒技术- Linux/Unix病毒")中讨论过的病毒感染技术，*ELF病毒技术- Linux/Unix病毒*。其思想是病毒或寄生体可以通过向后扩展文本段来为其代码腾出空间。如果你知道在找什么，文本段的程序头将会看起来很奇怪。
- en: 'Let''s take a look at an ELF 64-bit binary that has been infected with a virus
    that uses this parasite infection method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个已感染病毒并使用这种寄生体感染方法的ELF 64位二进制文件：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On Linux x86_64, the default virtual address for the text segment is `0x400000`.
    This is because the default linker script used by the linker says to do so. The
    program header table (marked by PHDR, as highlighted in the preceding) is 64 bytes
    into the file and will therefore have a virtual address of `0x400040`. From looking
    at the program headers in the preceding output, we can see that the text segment
    (the first LOAD line) does not have the expected address; instead it is `0x3ff000`.
    Yet the PHDR virtual address is still at `0x400040`, which tells you that at one
    point so was the original text segment address, and that something strange is
    going on here. This is because the text segment was essentially extended backward,
    as we discussed in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux x86_64上，文本段的默认虚拟地址是`0x400000`。这是因为链接器使用的默认链接脚本规定了这样做。程序头表（在前面标有PHDR）在文件中的偏移为64字节，因此其虚拟地址为`0x400040`。从前面的输出中查看程序头，我们可以看到文本段（第一行LOAD）没有预期的地址；相反，它是`0x3ff000`。然而，PHDR虚拟地址仍然是`0x400040`，这告诉你，原始文本段地址曾经也是这样，这里发生了一些奇怪的事情。这是因为文本段基本上是向后扩展的，正如我们在[第4章](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "第4章。ELF病毒技术- Linux/Unix病毒")中讨论的那样，*ELF病毒技术- Linux/Unix病毒*。
- en: '![Identifying reverse text padding infections](img/00014.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![识别反向文本填充感染](img/00014.jpeg)'
- en: Illustration – Diagram showing a reverse-text-infected executable
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图示-显示反向文本填充感染的可执行文件
- en: 'The following is an ELF file header of reverse-text-infected executables:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是反向文本感染可执行文件的ELF文件头：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'I have highlighted everything in the ELF header that is questionable:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经突出显示了ELF头中所有可疑的内容：
- en: Entry point points into parasite area
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入口点指向寄生体区域
- en: Start of program headers should only be 64 bytes
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序头的开始应该只有64字节
- en: Section header table offset is 0, as in stripped
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 段头表偏移为0，就像被剥离的那样
- en: Identifying text segment padding infections
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别文本段填充感染
- en: This type of infection is relatively easy to detect. This type of infection
    was also discussed in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*. This technique relies on the fact that there is always
    going to be a minimum of 4,096 bytes between the text and the data segment because
    they are loaded into memory as two separate memory segments, and memory mappings
    are always page aligned.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的感染相对容易检测。这种类型的感染也在[第4章](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "第4章。ELF病毒技术- Linux/Unix病毒")中讨论过，*ELF病毒技术- Linux/Unix病毒*。这种技术依赖于文本段和数据段之间始终会有至少4096字节的事实，因为它们作为两个单独的内存段加载到内存中，并且内存映射始终是页面对齐的。
- en: On 64-bit systems, there is typically `0x200000` (2MB) free due to **PSE** (**Page
    size extension**) pages. This means that a 64-bit ELF binary can be inserted with
    a 2MB parasite, which is much larger than what is typically needed for an injection
    space. With this type of infection, like any other, you can often identify the
    parasite location by examining the control flow.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在64位系统上，通常由于**PSE**（**页面大小扩展**）页面，会有`0x200000`（2MB）的空闲空间。这意味着64位ELF二进制文件可以插入一个2MB的寄生体，这比通常需要的注入空间要大得多。像任何其他类型的感染一样，通过检查控制流，通常可以确定寄生体的位置。
- en: With the `lpv` virus which I wrote in 2008, for instance, the entry point is
    modified to start execution at the parasite that is inserted using the text segment
    padding infection. If the executable that has been infected has a section header
    table, you will see that the entry point address resides in the range of the last
    section within the text segment. Let's take a look at a 32-bit ELF executable
    that has been infected using this technique.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我在2008年编写的`lpv`病毒，入口点被修改为从使用文本段填充感染插入的寄生体开始执行。如果被感染的可执行文件有一个段头表，你会看到入口点地址位于文本段内最后一个部分的范围内。让我们来看一个使用这种技术被感染的32位ELF可执行文件。
- en: '![Identifying text segment padding infections](img/00015.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![识别文本段填充感染](img/00015.jpeg)'
- en: Illustration – Diagram showing a text segment padding infection
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 插图 - 显示文本段填充感染的图表
- en: 'The following is an ELF file header of the `lpv` infected file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`lpv`感染文件的ELF文件头：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice the entry point address, `0x80485b8`. Does this address point somewhere
    inside the `.text` section? Let's take a peek at the section header table and
    find out.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意入口地址`0x80485b8`。这个地址是否指向`.text`段的内部？让我们来看一下段头表，找出答案。
- en: 'The following is an ELF section headers of the `lpv` infected file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`lpv`感染文件的ELF段头：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The entry point address falls within the `.eh_frame` section that is the last
    section in the text segment. This is clearly not the `.text` section that is enough
    reason to become immediately suspicious, and because the `.eh_frame` section is
    the last section in the text segment (which you can verify by using `readelf -l`),
    we are able to deduce that this Virus infection is probably using a text segment
    padding infection.The following are ELF program headers of the `lpv` infected
    file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 入口地址位于`.eh_frame`部分内，这是文本段中的最后一个部分。这显然不是`.text`部分，这足以立即引起怀疑，因为`.eh_frame`部分是文本段中的最后一个部分（你可以通过使用`readelf
    -l`来验证），我们能够推断出这种病毒感染可能是使用文本段填充感染。以下是`lpv`感染文件的ELF程序头：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Based on everything highlighted in the preceding program header output, you
    can see the program entry point, the text segment (the first `LOAD` program header),
    and the fact that `.eh_frame` is the last section in the text segment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的程序头输出中突出显示的一切，你可以看到程序入口点、文本段（第一个`LOAD`程序头）以及事实上`.eh_frame`是文本段中的最后一个部分。
- en: Identifying protected binaries
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别受保护的二进制文件
- en: 'Identifying a protected binary is the first step in reverse-engineering it.
    We discussed the common anatomy of protected ELF executables in [Chapter 5](part0049_split_000.html#1ENBI1-1d4163ae11644cc2802846625b2dc985
    "Chapter 5. Linux Binary Protection"), *Linux Binary Protection*. Remember from
    what we learned that a protected binary is actually two executables that have
    been merged together: you have the stub executable (the decryptor program) and
    then the target executable.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 识别受保护的二进制文件是逆向工程的第一步。我们在[第5章](part0049_split_000.html#1ENBI1-1d4163ae11644cc2802846625b2dc985
    "第5章。Linux二进制保护")中讨论了受保护的ELF可执行文件的常见解剖结构，*Linux二进制保护*。根据我们所学到的，受保护的二进制实际上是两个合并在一起的可执行文件：你有存根可执行文件（解密程序），然后是目标可执行文件。
- en: One program is responsible for decrypting the other, and it is this program
    that is going to typically be the wrapper that wraps or contains an encrypted
    binary within it, as a payload of sorts. Identifying this outer program that we
    call a stub is typically pretty easy because of the blatant oddities you will
    see in the program header table.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序负责解密另一个程序，通常这个程序会包含一个加密的二进制文件，作为一种有效载荷。识别这个外部程序，我们称之为存根，通常是相当容易的，因为你会在程序头表中看到明显的奇怪之处。
- en: 'Let''s take a look at a 64-bit ELF binary that is protected using a protector
    I wrote in 2009 called `elfcrypt`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个使用我在2009年编写的`elfcrypt`保护的64位ELF二进制文件：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: So what are we seeing here? Or rather what are we not seeing?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们在这里看到了什么？或者更确切地说，我们没有看到什么？
- en: This almost looks like a statically compiled executable because there is no
    `PT_DYNAMIC` segment and there is no `PT_INTERP` segment. However, if we run this
    binary and check `/proc/$pid/maps,` we see that this is not a statically compiled
    binary, but is in fact dynamically linked.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎看起来像是一个静态编译的可执行文件，因为没有`PT_DYNAMIC`段，也没有`PT_INTERP`段。然而，如果我们运行这个二进制文件并检查`/proc/$pid/maps`，我们会发现这不是一个静态编译的二进制文件，而是动态链接的。
- en: 'The following is the output from `/proc/$pid/maps` in the protected binary:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是受保护二进制文件中`/proc/$pid/maps`的输出：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can clearly see that the dynamic linker is mapped into the process address
    space, and so is libc. As discussed in [Chapter 5](part0049_split_000.html#1ENBI1-1d4163ae11644cc2802846625b2dc985
    "Chapter 5. Linux Binary Protection"), *Linux Binary Protection*, this is because
    the protection stub becomes responsible for loading the dynamic linker and setting
    up the auxiliary vector.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到动态链接器被映射到进程地址空间中，libc也是如此。正如在[第5章](part0049_split_000.html#1ENBI1-1d4163ae11644cc2802846625b2dc985
    "第5章。Linux二进制保护")中讨论的那样，这是因为保护存根负责加载动态链接器并设置辅助向量。
- en: From the program header output, we can also see that the text segment address
    is `0xa00000`, which is unusual. The default linker script used for compiling
    executables in x86_64 Linux defines the text address as `0x400000`, and on 32-bit
    systems it is `0x8048000`. Having a text address other than the default does not,
    on its own, suggest anything malicious, but should immediately raise suspicion.
    In the case of a binary protector, the stub must have a virtual address that does
    not conflict with the virtual address of the self-embedded executable it is protecting.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序头输出中，我们还可以看到文本段地址是`0xa00000`，这是不寻常的。在x86_64 Linux中用于编译可执行文件的默认链接器脚本将文本地址定义为`0x400000`，在32位系统上是`0x8048000`。文本地址与默认值不同并不意味着有任何恶意行为，但应立即引起怀疑。在二进制保护程序的情况下，存根必须具有不与其保护的自嵌入可执行文件的虚拟地址冲突的虚拟地址。
- en: Analyzing a protected binary
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析受保护的二进制文件
- en: True binary protection schemes that really do a good job will not be very easy
    to circumvent, but in more cases than not you can use some intermediate reverse
    engineering efforts to get past the encryption layer. The stub is responsible
    for decrypting the self-embedded executable within it, which can therefore be
    extracted from memory. The trick is to allow the stub to run long enough to map
    the encrypted executable into memory and decrypt it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 真正有效的二进制保护方案不太容易被绕过，但在大多数情况下，您可以使用一些中间的逆向工程方法来突破加密层。存根负责解密其中的自嵌可执行文件，因此可以从内存中提取。诀窍是允许存根运行足够长的时间，以将加密的可执行文件映射到内存并解密它。
- en: A very general algorithm can be used that tends to work on simple protectors,
    especially if they do not incorporate any anti-debugging techniques.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用一个非常通用的算法，它倾向于在简单的保护程序上起作用，特别是如果它们不包含任何反调试技术。
- en: Determine the approximate number of instructions in the stub's text segment,
    represented by N.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定存根文本段中的近似指令数，表示为N。
- en: Trace the program for N instructions.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跟踪N条指令的程序。
- en: Dump the memory from the expected location of the text segment (for example,
    `0x400000`) and locate its data segment by using the program headers from the
    newly found text segment.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文本段的预期位置（例如`0x400000`）转储内存，并使用新发现的文本段的程序头找到其数据段。
- en: A good example of this simple technique can be demonstrated with Quenya, the
    32-bit ELF manipulation software that I coded in 2008.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单技术的一个很好的例子可以用我在2008年编写的32位ELF操作软件Quenya来演示。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: UPX uses no anti-debugging techniques and is therefore relatively straightforward
    to unpack.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: UPX不使用任何反调试技术，因此相对来说解包相对简单。
- en: 'The following are the program headers of a packed executable:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个打包可执行文件的程序头：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can see that the stub begins at `0xc01000`, and Quenya will presume that
    the real text segment is at the expected address for a 32-bit ELF executable:
    `0x8048000`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到存根从`0xc01000`开始，并且Quenya将假定真正的文本段位于32位ELF可执行文件的预期地址：`0x8048000`。
- en: 'Here is Quenya using its unpack feature to decompress `test.packed`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Quenya使用其解包功能来解压`test.packed`：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As we can see, the Quenya unpack feature has allegedly unpacked the UPX packed
    executable. We can verify this by simply looking at the program headers of the
    unpacked executable:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Quenya解包功能据称已解包了UPX打包的可执行文件。我们可以通过简单查看解包后的可执行文件的程序头来验证这一点。
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that the program headers are completely different from the ones we looked
    at previously when the executable was still packed. This is because we are no
    longer looking at the stub executable. We are looking at the executable that was
    compressed inside the stub. The unpacking technique we used is very generic and
    not very effective for more complicated protection schemes, but helps beginners
    gain an understanding into the process of reversing protected binaries.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，程序头与我们之前查看的程序头完全不同，当可执行文件仍然被打包时。这是因为我们不再查看存根可执行文件。我们正在查看存根内部压缩的可执行文件。我们使用的解包技术非常通用，对于更复杂的保护方案效果不是很好，但有助于初学者了解保护二进制的逆向过程。
- en: IDA Pro
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDA Pro
- en: Since this book tries to focus on the anatomy of the ELF format, and the concepts
    behind analysis and patching techniques, we are less focused on which of the fancy
    tools to use. The very famous IDA Pro software has a well-deserved reputation.
    It is hands down the best disassembler and decompiler available to the public.
    It is expensive though, and unless you can afford a license, you may have settle
    for something a little less effective, such as Hopper. IDA Pro is quite complicated
    and requires an entire book unto itself, but in order to properly understand and
    use IDA Pro for ELF binaries, it is good to first understand the concepts taught
    in this book, which can then be applied when using IDA pro to reverse-engineer
    software.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书试图专注于ELF格式的解剖和分析修补技术背后的概念，我们不太关注使用哪些花哨的工具。非常著名的IDA Pro软件享有当之无愧的声誉。它是公开可用的最好的反汇编器和反编译器。它虽然昂贵，但除非您能负担得起许可证，否则您可能需要接受一些效果稍逊的东西，比如Hopper。IDA
    Pro相当复杂，需要一本专门的书来介绍，但为了正确理解和使用IDA Pro来逆向工程软件，最好先理解本书教授的概念，然后在使用IDA Pro时应用这些概念。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned the fundamentals of ELF binary analysis. You examined
    the procedures involved in identifying various types of virus infection, function
    hijacking, and binary protection. This chapter will serve you well in the beginner
    to intermediate phases of ELF binary analysis: what to look for and how to identify
    it. In the following chapters, you will cover similar concepts, such as analyzing
    process memory for identifying anomalies such as backdoors and memory-resident
    viruses.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了ELF二进制分析的基础知识。您研究了识别各种类型的病毒感染、函数劫持和二进制保护所涉及的程序。本章将在ELF二进制分析的初学者到中级阶段为您提供帮助：要寻找什么以及如何识别它。在接下来的章节中，您将涵盖类似的概念，例如分析进程内存以识别后门和驻留内存病毒等异常。
- en: For those interested in knowing how the methods described in this chapter could
    be used in the development of an anti-virus or detection software, there do exist
    some tools I have designed that use similar heuristics to those described in this
    chapter for detecting ELF infections. One of these tools is called AVU and was
    mentioned with a download link in [Chapter 4](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "Chapter 4. ELF Virus Technology – Linux/Unix Viruses"), *ELF Virus Technology
    – Linux/Unix Viruses*. Another one is named Arcana and is still private. I have
    not personally seen any public products on the market though that use these types
    of heuristics on ELF binaries, although such tools are sorely needed to aid Linux
    binary forensics. In [Chapter 8](part0074_split_000.html#26I9K1-1d4163ae11644cc2802846625b2dc985
    "Chapter 8. ECFS – Extended Core File Snapshot Technology"), *ECFS – Extended
    Core File Snapshot Technology*, we will explore ECFS, which is a technology I
    have been working on to help improve some of the areas where forensics capabilities
    are lacking, especially as it pertains to process memory forensics.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些想了解本章描述的方法如何在反病毒或检测软件开发中使用的人，我设计了一些工具，这些工具使用了类似于本章描述的启发式方法来检测ELF感染。其中一个工具叫做AVU，在[第4章](part0040_split_000.html#164MG1-1d4163ae11644cc2802846625b2dc985
    "第4章. ELF病毒技术- Linux/Unix病毒")中提到过，并附有下载链接。另一个工具叫做Arcana，目前还是私有的。我个人还没有看到市面上有任何使用这些启发式方法来检测ELF二进制文件的公开产品，尽管这样的工具在Linux二进制取证方面是非常需要的。在[第8章](part0074_split_000.html#26I9K1-1d4163ae11644cc2802846625b2dc985
    "第8章. ECFS-扩展核心文件快照技术")中，我们将探讨ECFS，这是我一直在努力改进的技术，特别是在涉及进程内存取证方面的能力不足的领域。
