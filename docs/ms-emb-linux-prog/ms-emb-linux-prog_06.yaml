- en: Chapter 6. Selecting a Build System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 选择构建系统
- en: 'The preceding chapters covered the four elements of embedded Linux and showed
    you, step-by-step, how to build a toolchain, a bootloader, a kernel, and a root
    filesystem, and then combine them into a basic embedded Linux system. And there
    are a lot of steps! Now it is time to look at ways to simplify the process by
    automating it as much as possible. I will look at how embedded build systems can
    help, and look at two in particular: Buildroot and the Yocto Project. Both are
    complex and flexible tools which would require an entire book to adequately describe
    how they work. In this chapter, I only want to show you the general ideas behind
    build systems. I will show you how to build a simple device image to get an overall
    feel of the system and then how to make some useful changes, using the Nova board
    example from the previous chapters.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章涵盖了嵌入式Linux的四个元素，并逐步向您展示了如何构建工具链、引导加载程序、内核和根文件系统，然后将它们组合成基本的嵌入式Linux系统。而且有很多步骤！现在是时候看看如何通过尽可能自动化来简化这个过程。我将介绍嵌入式构建系统如何帮助，并特别介绍两种构建系统：Buildroot和Yocto
    Project。这两种都是复杂而灵活的工具，需要整本书来充分描述它们的工作原理。在本章中，我只想向您展示构建系统背后的一般思想。我将向您展示如何构建一个简单的设备镜像，以便对系统有一个整体感觉，然后如何进行一些有用的更改，使用前几章中的Nova板示例。
- en: No more rolling your own embedded Linux
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不再自己制作嵌入式Linux
- en: The process of creating a system manually, as described in [Chapter 5](ch05.html
    "Chapter 5. Building a Root Filesystem"), *Building a Root Filesystem,* is called
    the **roll your own** (**RYO**) process. It has the advantage that you are in
    complete control of the software and you can tailor it to do anything you like.
    If you want it to do something truly odd but innovative, or if you want to reduce
    the memory footprint to the smallest possible, RYO is the way to go. But, in the
    vast majority of situations, building manually is a waste of time and produces
    inferior, unmaintainable systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 手动创建系统的过程，如[第5章](ch05.html "第5章 构建根文件系统")中所述的*构建根文件系统*，称为**roll your own**（**RYO**）过程。它的优点是您完全控制软件，可以根据自己的喜好进行定制。如果您希望它执行一些非常奇特但创新的操作，或者如果您希望将内存占用减少到最小，RYO是一种方法。但是，在绝大多数情况下，手动构建是浪费时间并产生质量较差、难以维护的系统。
- en: They are usually built incrementally over a period of months, often undocumented
    and seldom recreated from scratch because nobody had a clue where each part came
    from.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 它们通常在几个月的时间内逐步构建，通常没有记录，很少从头开始重新创建，因为没有人知道每个部分来自哪里。
- en: Build systems
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建系统
- en: 'The idea of a build system is to automate all the steps I have described up
    to this point. A build system should be able to build, from upstream source code,
    some or all of the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 构建系统的理念是自动化我到目前为止描述的所有步骤。构建系统应该能够从上游源代码构建一些或所有以下内容：
- en: The toolchain
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工具链
- en: The bootloader
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引导加载程序
- en: The kernel
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核
- en: The root filesystem
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根文件系统
- en: Building from an upstream source is important for a number of reasons. It means
    that you have peace of mind that you can rebuild at any time, without external
    dependencies. It also means that you have the source code for debugging and that
    you can meet your license requirements to distribute that to users where necessary.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从上游源代码构建对于许多原因都很重要。这意味着您可以放心，随时可以重新构建，而无需外部依赖。这还意味着您拥有用于调试的源代码，并且可以满足分发给用户的许可要求。
- en: 'Therefore to do its job, a build system has to be able to do the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了完成其工作，构建系统必须能够执行以下操作：
- en: Download a source from upstream, either directly from the source code control
    system or as an archive, and cache it locally
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从上游下载源代码，可以直接从源代码控制系统或作为存档文件，并将其缓存在本地
- en: Apply patches to enable cross compilation, fix architecture-dependent bugs,
    apply local configuration policies, and so on
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用补丁以启用交叉编译，修复与体系结构相关的错误，应用本地配置策略等
- en: Build the various components
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建各种组件
- en: Create a staging area and assemble a root filesystem
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个暂存区并组装一个根文件系统
- en: Create image files in various formats ready to be loaded onto the target
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建各种格式的镜像文件，准备加载到目标设备上
- en: 'Other things that are useful are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有用的东西如下：
- en: Add your own packages containing, for example, applications or kernel changes
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加您自己的软件包，例如应用程序或内核更改
- en: 'Select various root filesystem profiles: large or small, with and without graphics
    or other features'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择各种根文件系统配置文件：大或小，带有或不带有图形或其他功能
- en: Create a standalone SDK that you can distribute to other developers so that
    they don't have to install the complete build system
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个独立的SDK，您可以将其分发给其他开发人员，以便他们不必安装完整的构建系统
- en: Track which open source licenses are used by the various packages you have selected
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪所选软件包使用的各种开源许可证
- en: Allow you to create updates for in-field updating
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许您为现场更新创建更新
- en: Have a user-friendly user interface
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有用户友好的用户界面
- en: In all cases, they encapsulate the components of a system into packages, some
    for the host and some for the target. Each package is defined by a set of rules
    to get the source, build it, and install the results in the correct location.
    There are dependencies between the packages and a build mechanism to resolve the
    dependencies and build the set of packages required.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，它们将系统的组件封装成包，一些用于主机，一些用于目标。每个软件包由一组规则定义，以获取源代码，构建它，并将结果安装在正确的位置。软件包之间存在依赖关系和构建机制来解决依赖关系并构建所需的软件包集。
- en: 'Open source build systems have matured considerably over the last few years.
    There are many around, including:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 开源构建系统在过去几年中已经显著成熟。有许多构建系统，包括：
- en: '**Buildroot**: An easy-to-use system using GNU `make` and `Kconfig` ([http://buildroot.org](http://buildroot.org))'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Buildroot**：使用GNU `make`和`Kconfig`的易于使用的系统（[http://buildroot.org](http://buildroot.org)）'
- en: '**EmbToolkit**: A simple system for generating root filesystems; the only one
    at the time of writing that supports LLVM/Clang out of the box ([https://www.embtoolkit.org](https://www.embtoolkit.org))'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EmbToolkit**：用于生成根文件系统的简单系统；在撰写本文时，是唯一支持LLVM/Clang的系统（[https://www.embtoolkit.org](https://www.embtoolkit.org)）'
- en: '**OpenEmbedded**: A powerful system which is also a core component of the Yocto
    Project and others ([http://openembedded.org](http://openembedded.org))'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenEmbedded**：一个强大的系统，也是Yocto项目和其他项目的核心组件（[http://openembedded.org](http://openembedded.org)）'
- en: '**OpenWrt**: A build tool oriented towards building firmware for wireless routers
    ([https://openwrt.org](https://openwrt.org))'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenWrt**：一个面向无线路由器固件构建的构建工具（[https://openwrt.org](https://openwrt.org)）'
- en: '**PTXdist**: An open source build system sponsored by Pengutronix ([http://www.pengutronix.de/software/ptxdist/index_en.html](http://www.pengutronix.de/software/ptxdist/index_en.html))'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PTXdist**：由Pengutronix赞助的开源构建系统（[http://www.pengutronix.de/software/ptxdist/index_en.html](http://www.pengutronix.de/software/ptxdist/index_en.html)）'
- en: '**Tizen**: A comprehensive system, with emphasis on mobile, media, and in-vehicle
    devices ([https://www.tizen.org](https://www.tizen.org))'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tizen**：一个全面的系统，重点放在移动、媒体和车载设备上（[https://www.tizen.org](https://www.tizen.org)）'
- en: '**The Yocto Project**: This extends the OpenEmbedded core with configuration,
    layers, tools, and documentation: probably the most popular system ([http://www.yoctoproject.org](http://www.yoctoproject.org))'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Yocto项目**：这扩展了OpenEmbedded核心的配置、层、工具和文档：可能是最受欢迎的系统（[http://www.yoctoproject.org](http://www.yoctoproject.org)）'
- en: 'I will concentrate on two of these: Buildroot and The Yocto Project. They approach
    the problem in different ways and with different objectives.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我将专注于其中两个：Buildroot和Yocto项目。它们以不同的方式和不同的目标解决问题。
- en: Buildroot has the primary aim of building root filesystem images, hence the
    name, although it can build bootloader and kernel images as well. It is easy to
    install and configure, and generates target images quickly.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot的主要目标是构建根文件系统映像，因此得名，尽管它也可以构建引导加载程序和内核映像。它易于安装和配置，并且可以快速生成目标映像。
- en: The Yocto Project, on the other hand, is more general in the way it defines
    the target system and so it can build fairly complex embedded devices. Every component
    is generated as a package in RPM, `.dpkg` or `.ipk` format (see the following
    section) and then the packages are combined together to make the filesystem image.
    Furthermore, you can install a package manager in the filesystem image, which
    allows you to update packages at runtime. In other words, when you build with
    the Yocto Project, you are, in effect, creating your own custom Linux distribution.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Yocto项目在定义目标系统的方式上更加通用，因此可以构建相当复杂的嵌入式设备。每个组件都以RPM、`.dpkg`或`.ipk`格式的软件包生成（见下一节），然后将这些软件包组合在一起以制作文件系统映像。此外，您可以在文件系统映像中安装软件包管理器，这允许您在运行时更新软件包。换句话说，当您使用Yocto项目构建时，实际上是在创建自己的定制Linux发行版。
- en: Package formats and package managers
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件包格式和软件包管理器
- en: Mainstream Linux distributions are, in most cases, constructed from collections
    of binary (precompiled) packages in either RPM or deb format. **RPM** stands for
    **Red Hat Package Manager** and is used in Red Hat, Suse, Fedora, and other distributions
    based on them. Debian-derived distributions, including Ubuntu and Mint, use the
    Debian package manager format, `deb`. In addition, there is a light-weight format
    specific to embedded devices known as the **Itsy PacKage** format, or **ipk**,
    which is based on `deb`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 主流Linux发行版在大多数情况下是由RPM或deb格式的二进制（预编译）软件包集合构建而成。**RPM**代表**Red Hat软件包管理器**，在Red
    Hat、Suse、Fedora和其他基于它们的发行版中使用。基于Debian的发行版，包括Ubuntu和Mint，使用Debian软件包管理器格式`deb`。此外，还有一种轻量级格式专门用于嵌入式设备，称为**Itsy
    PacKage**格式，或**ipk**，它基于`deb`。
- en: The ability to include a package manager on the device is one of the big differentiators
    between build systems. Once you have a package manager on the target device, you
    have an easy path to deploy new packages to it and to update existing ones. I
    will talk about the implications of this in the next chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备上包含软件包管理器的能力是构建系统之间的重要区别之一。一旦在目标设备上安装了软件包管理器，您就可以轻松地部署新软件包并更新现有软件包。我将在下一章讨论这一点的影响。
- en: Buildroot
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Buildroot
- en: The Buildroot project website is at [http://buildroot.org](http://buildroot.org).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot项目网站位于[http://buildroot.org](http://buildroot.org)。
- en: Current versions of Buildroot are capable of building a toolchain, a bootloader
    (U-Boot, Barebox, GRUB2, or Gummiboot), a kernel, and a root filesystem. It uses
    GNU `make` as the principal build tool.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的Buildroot能够构建工具链、引导加载程序（U-Boot、Barebox、GRUB2或Gummiboot）、内核和根文件系统。它使用GNU
    `make`作为主要构建工具。
- en: There is good online documentation at [http://buildroot.org/docs.html](http://buildroot.org/docs.html),
    including *The Buildroot User Manual*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://buildroot.org/docs.html](http://buildroot.org/docs.html)上有很好的在线文档，包括*Buildroot用户手册*。'
- en: Background
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: Buildroot was one of the first build systems. It began as part of the uClinux
    and uClibc projects as a way of generating a small root filesystem for testing.
    It became a separate project in late 2001 and continued to evolve through to 2006,
    after which it went into a rather dormant phase. However, since 2009, when Peter
    Korsgaard took over stewardship, it has been developing rapidly, adding support
    for `glibc`-based toolchains and the ability to build a bootloader and a kernel.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot是最早的构建系统之一。它始于uClinux和uClibc项目的一部分，作为生成用于测试的小型根文件系统的一种方式。它于2001年末成为一个独立项目，并持续发展到2006年，之后进入了一个相当休眠的阶段。然而，自2009年Peter
    Korsgaard接管以来，它一直在快速发展，增加了对基于`glibc`的工具链的支持以及构建引导加载程序和内核的能力。
- en: Buildroot is also the foundation of another popular build system, OpenWrt ([http://wiki.openwrt.org](http://wiki.openwrt.org))
    which forked from Buildroot around 2004\. The primary focus of OpenWrt is to produce
    software for wireless routers and so the package mix is oriented towards networking
    infrastructure. It also has a runtime package manager using the `.ipk` format
    so that a device can be updated or upgraded without a complete re-flash of the
    image.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot也是另一个流行的构建系统OpenWrt（[http://wiki.openwrt.org](http://wiki.openwrt.org)）的基础，它在2004年左右从Buildroot分叉出来。OpenWrt的主要重点是为无线路由器生产软件，因此软件包混合物是面向网络基础设施的。它还具有使用`.ipk`格式的运行时软件包管理器，因此可以在不完全重新刷写镜像的情况下更新或升级设备。
- en: Stable releases and support
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稳定版本和支持
- en: The Buildroot developers produce stable releases four times a year, in February,
    May, August, and November. They are marked by `git` tags of the form `<year>.02`,
    `<year>.05`, `<year>.08`, and `<year>.11`. Typically, when you start your project,
    you will be using the latest stable release. However, the stable releases are
    seldom updated after release. To get security fixes and other bug fixes you will
    have to either continually update to the next stable release as they become available
    or backport the fixes into your version.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot开发人员每年发布四次稳定版本，分别在2月、5月、8月和11月。它们以`git`标签的形式标记为`<year>.02`、`<year>.05`、`<year>.08`和`<year>.11`。通常，当您启动项目时，您将使用最新的稳定版本。但是，稳定版本发布后很少更新。要获得安全修复和其他错误修复，您将不得不在可用时不断更新到下一个稳定版本，或者将修复程序回溯到您的版本中。
- en: Installing
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'As usual, you can install Buildroot either by cloning the repository or downloading
    an archive. Here is an example of obtaining version 2015.08.1, which was the latest
    stable version at the time of writing:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您可以通过克隆存储库或下载存档来安装Buildroot。以下是获取2015.08.1版本的示例，这是我写作时的最新稳定版本：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The equivalent TAR archive is available from [http://buildroot.org/downloads](http://buildroot.org/downloads).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的TAR存档可从[http://buildroot.org/downloads](http://buildroot.org/downloads)获取。
- en: Next, you should read the section titled *System Requirement* from *The Buildroot
    User Manual*, available at [http://buildroot.org/downloads/manual/manual.html](http://buildroot.org/downloads/manual/manual.html)
    and make sure that you have installed all the packages listed there.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您应该阅读*Buildroot用户手册*中的*系统要求*部分，网址为[http://buildroot.org/downloads/manual/manual.html](http://buildroot.org/downloads/manual/manual.html)，并确保您已安装了那里列出的所有软件包。
- en: Configuring
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: Buildroot uses the `Kconfig` and `Kbuild` mechanisms as the kernel, which I
    described in the section *Understanding kernel configuration* in [Chapter 4](ch04.html
    "Chapter 4. Porting and Configuring the Kernel"), *Porting and Configuring the
    Kernel*. You can configure it from scratch directly using `make menuconfig` (or
    `xconfig` or `gconfig`), or you can choose one of the 90 or so configurations
    for various development boards and the QEMU emulator which you can find stored
    in the directory `configs/`. Typing `make help` lists all the targets including
    the default configurations.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot使用`Kconfig`和`Kbuild`机制，就像内核一样，我在[第4章](ch04.html "第4章。移植和配置内核")的*理解内核配置*部分中描述的那样，*移植和配置内核*。您可以直接使用`make
    menuconfig`（或`xconfig`或`gconfig`）从头开始配置它，或者您可以选择存储在`configs/`目录中的大约90个各种开发板和QEMU模拟器的配置之一。键入`make
    help`列出所有目标，包括默认配置。
- en: 'Let''s begin by building a default configuration that you can run on the ARM
    QEMU emulator:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建一个默认配置开始，您可以在ARM QEMU模拟器上运行：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Note that you do not tell `make` how many parallel jobs to run with a `-j`
    option: Buildroot will make optimum use of your CPUs all by itself. If you want
    to limit the number of jobs, you can run `make menuconfig` and look under **Build**
    options.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您不需要使用`-j`选项告诉`make`要运行多少个并行作业：Buildroot将自行充分利用您的CPU。如果您想限制作业的数量，可以运行`make
    menuconfig`并查看**Build**选项下的内容。
- en: 'The build will take half an hour to an hour, depending on the capabilities
    of your host system and the speed of your link to the Internet. When it is complete,
    you will find that two new directories have been created:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 构建将花费半小时到一小时的时间，这取决于您的主机系统的能力和与互联网的连接速度。完成后，您会发现已创建了两个新目录：
- en: '`dl/`: This contains archives of the upstream projects that Buildroot has built'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dl/`：这包含了Buildroot构建的上游项目的存档'
- en: '`output/`: This contains all the intermediate and final compiled resources'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output/`：这包含了所有中间和最终编译的资源'
- en: 'You will see the following in `output/`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在`output/`中看到以下内容：
- en: '`build/`: This is the build directory for each component.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build/`：这是每个组件的构建目录。'
- en: '`host/`: This contains various tools required by Buildroot that run on the
    host, including the executables of the toolchain (in `output/host/usr/bin`).'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host/`：这包含Buildroot所需的在主机上运行的各种工具，包括工具链的可执行文件（在`output/host/usr/bin`中）。'
- en: '`images/`: This is the most important of all and contains the results of the
    build. Depending on what you selected when configuring, you will find a bootloader,
    a kernel, and one or more root filesystem images.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`images/`：这是最重要的，包含构建的结果。根据您的配置选择，您将找到引导加载程序、内核和一个或多个根文件系统镜像。'
- en: '`staging/`: This is a symbolic link to the `sysroot` of the toolchain. The
    name of the link is a little confusing because it does not point to a staging
    area as I defined it in [Chapter 5](ch05.html "Chapter 5. Building a Root Filesystem"),
    *Building a Root Filesystem*.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`staging/`：这是指向工具链的`sysroot`的符号链接。链接的名称有点令人困惑，因为它并不指向我在[第5章](ch05.html "第5章。构建根文件系统")中定义的暂存区。'
- en: '`target/`: This is the staging area for the root directory. Note that you cannot
    use this as a root filesystem, as it stands, because the file ownership and permissions
    are not set correctly. Buildroot uses a device table, as described in the previous
    chapter, to set ownership and permissions when the filesystem image is created.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target/`：这是根目录的暂存区。请注意，您不能将其作为根文件系统使用，因为文件所有权和权限未正确设置。Buildroot在创建文件系统映像时使用设备表来设置所有权和权限，如前一章所述。'
- en: Running
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行
- en: Some of the sample configurations have a corresponding entry in the directory
    `boards/`, which contains custom configuration files and information about installing
    the results on the target. In the case of the system you have just built, the
    relevant file is `board/qemu/arm-vexpress/readme.txt`, which tells you how to
    start QEMU with this target.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例配置在`boards/`目录中有相应的条目，其中包含自定义配置文件和有关在目标上安装结果的信息。对于您刚刚构建的系统，相关文件是`board/qemu/arm-vexpress/readme.txt`，其中告诉您如何使用此目标启动QEMU。
- en: 'Assuming that you have already installed `qemu-system-arm` as described in
    [Chapter 1](ch01.html "Chapter 1. Starting Out"), *Starting Out*, you can run
    it using this command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经按照[第1章](ch01.html "第1章。起步")中描述的方式安装了`qemu-system-arm`，*起步*，您可以使用以下命令运行它：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should see the kernel boot messages appear in the same terminal window
    where you started QEMU, followed by a login prompt:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在启动QEMU的同一终端窗口中看到内核引导消息，然后是登录提示符：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Log in as `root`, no password.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以`root`身份登录，无需密码。
- en: You will see that QEMU launches a black window in addition to the one with the
    kernel boot messages. It is there to display the graphics frame buffer of the
    target. In this case, the target never writes to the `framebuffer`, which is why
    it appears black. To close QEMU, either type `poweroff` at the root prompt or
    just close the `framebuffer` window. This works with QEMU 2.0 (default on Ubuntu
    14.04), but fails with earlier versions including QEMU 1.0.50 (default on Ubuntu
    12.04) because of problems with the SCSI emulation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到QEMU启动一个黑色窗口，除了具有内核引导消息的窗口。它用于显示目标的图形帧缓冲区。在这种情况下，目标从不写入`framebuffer`，这就是为什么它是黑色的原因。要关闭QEMU，可以在root提示符处键入`poweroff`，或者只需关闭`framebuffer`窗口。这适用于QEMU
    2.0（Ubuntu 14.04上的默认版本），但在包括QEMU 1.0.50（Ubuntu 12.04上的默认版本）在内的早期版本中失败，因为存在SCSI仿真问题。
- en: Creating a custom BSP
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义BSP
- en: 'Next, let''s use Buildroot to create a BSP for our Nova board, using the same
    versions of U-Boot and Linux from earlier chapters. The recommended places to
    store your changes are:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用Buildroot为我们的Nova板创建BSP，使用前几章中相同版本的U-Boot和Linux。建议存储更改的位置是：
- en: '`board/<organization>/<device>`: contains any patches, binary blobs, extra
    build steps, configuration files for Linux, U-Boot, and other components'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`board/<organization>/<device>`：包含Linux、U-Boot和其他组件的补丁、二进制文件、额外的构建步骤、配置文件'
- en: '`configs/<device>_defconfig`: contains the default configuration for the board'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configs/<device>_defconfig`：包含板的默认配置'
- en: '`packages/<organization>/<package_name>`: is the place to put any additional
    packages for this board'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`packages/<organization>/<package_name>`：是放置此板的任何额外软件包的位置'
- en: 'We can use the BeagleBone configuration file as a base, since Nova is a close
    cousin:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用BeagleBone配置文件作为基础，因为Nova是近亲：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now the `.config` file is set for BeagleBone. Next, create a directory for
    the board configuration:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`.config`文件已设置为BeagleBone。接下来，为板配置创建一个目录：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: U-Boot
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: U-Boot
- en: 'In [Chapter 3](ch03.html "Chapter 3. All About Bootloaders"), *All About Bootloaders*,
    we created a custom bootloader for Nova, based on the 2015.07 of U-Boot version
    and created a patch file for it. We can configure Buildroot to select the same
    version, and apply our patch. Begin by by copying the patch file into `board/melp/nova`,
    and then use `make menuconfig` to set the U-Boot version to 2015.07, the patch
    directory to `board/melp/nova` and the board name to nova, as shown in this screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。引导程序全解")中，*引导程序全解*，我们为Nova创建了一个基于U-Boot 2015.07版本的自定义引导程序，并为其创建了一个补丁文件。我们可以配置Buildroot选择相同的版本，并应用我们的补丁。首先将补丁文件复制到`board/melp/nova`，然后使用`make
    menuconfig`将U-Boot版本设置为2015.07，补丁目录设置为`board/melp/nova`，并将板名称设置为nova，如此屏幕截图所示：
- en: '![U-Boot](img/B03982_06_01.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![U-Boot](img/B03982_06_01.jpg)'
- en: Linux
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux
- en: 'In [Chapter 4](ch04.html "Chapter 4. Porting and Configuring the Kernel"),
    *Porting and Configuring the Kernel*, we based the kernel on Linux 4.1.10 and
    supplied a new device tree, named `nova.dts`. Copy the device tree to `board/melp/nova`
    and change the Buildroot kernel configuration to use this version and the nova
    device tree as show in in this screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。移植和配置内核")中，*移植和配置内核*，我们基于Linux 4.1.10构建了内核，并提供了一个名为`nova.dts`的新设备树。将设备树复制到`board/melp/nova`，并更改Buildroot内核配置以使用此版本和nova设备树，如此屏幕截图所示：
- en: '![Linux](img/B03982_06_02.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![Linux](img/B03982_06_02.jpg)'
- en: Build
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建
- en: 'Now you can build the system for the Nova board just by typing `make`, which
    produces these files in the directory `output/images`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过键入`make`为Nova板构建系统，这将在目录`output/images`中生成这些文件：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The last step is to save a copy of the configuration so that you and others
    can use it again:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是保存配置的副本，以便您和其他人可以再次使用它：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, you have a Buildroot configuration for the Nova board.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经为Nova板创建了Buildroot配置。
- en: Adding your own code
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加您自己的代码
- en: 'Suppose that there are some programs that you have developed that you want
    to include in the build. You have two options: firstly to build them separately,
    using their own build systems, and then roll the binary into the final build as
    an overlay. Secondly you could create a Buildroot package that can be selected
    from the menu and built like any other.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您开发了一些程序，并希望将其包含在构建中。您有两个选择：首先，使用它们自己的构建系统单独构建它们，然后将二进制文件作为叠加卷入最终构建中。其次，您可以创建一个Buildroot软件包，可以从菜单中选择并像其他软件包一样构建。
- en: Overlay
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 叠加
- en: 'An overlay is simply a directory structure that is copied over the top of the
    Buildroot root filesystem at a late stage in the build process. It can contain
    executables, libraries and anything else you may want to include. Note that any
    compiled code must be compatible with the libraries deployed at runtime, which
    means that it must be compiled with the same toolchain that Buildroot uses. Using
    the Buildroot toolchain is quite easy: just add it to the path:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖只是在构建过程的后期阶段复制到Buildroot根文件系统顶部的目录结构。它可以包含可执行文件、库和任何您想要包含的其他内容。请注意，任何编译的代码必须与运行时部署的库兼容，这意味着它必须使用Buildroot使用的相同工具链进行编译。使用Buildroot工具链非常容易：只需将其添加到路径中：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The prefix for the tools is `<ARCH>-linux-`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 工具的前缀是`<ARCH>-linux-`。
- en: The overlay directory is set by `BR2_ROOTFS_OVERLAY`, which contains a list
    of directories separated by spaces, which you should overlay on the Buildroot
    root filesystem. It can be configured in `menuconfig` with the option **System
    configuration** | **Root filesystem overlay directories**.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖目录由`BR2_ROOTFS_OVERLAY`设置，其中包含一个由空格分隔的目录列表，您应该在Buildroot根文件系统上覆盖它。它可以在`menuconfig`中配置，选项为**系统配置**
    | **根文件系统覆盖目录**。
- en: 'For example, if you add a `helloworld` program to the `bin` directory, and
    a script to start it at boot time, you would create an overlay directory with
    the following contents:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果将`helloworld`程序添加到`bin`目录，并在启动时添加一个脚本，您将创建一个包含以下内容的覆盖目录：
- en: '![Overlay](img/B03982_06_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![覆盖](img/B03982_06_04.jpg)'
- en: Then you would add `board/melp/nova/overlay` to the overlay options.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将`board/melp/nova/overlay`添加到覆盖选项中。
- en: The layout of the root filesystem is controlled by the `system/skeleton` directory,
    and the permissions are set in `device_table_dev.txt` and `device_table.txt`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件系统的布局由`system/skeleton`目录控制，权限在`device_table_dev.txt`和`device_table.txt`中设置。
- en: Adding a package
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加软件包
- en: 'Buildroot packages are stored in the `package` directory, over 1,000 of them,
    each in its own subdirectory. A package consists of at least two files: `Config.in,`
    containing the snippet of `Kconfig` code required to make the package visible
    in the **configuration** menu, and a `makefile` named `<package_name>.mk`. Note
    that the package does not contain the code, just the instructions to get the code
    by downloading a tarball, doing a git pull, and so on.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot软件包存储在`package`目录中，有1000多个软件包，每个软件包都有自己的子目录。软件包至少包含两个文件：`Config.in`，其中包含使软件包在**配置**菜单中可见所需的`Kconfig`代码片段，以及名为`<package_name>.mk`的`makefile`。请注意，软件包不包含代码，只包含获取代码的指令，如下载tarball、执行git
    pull等。
- en: The `makefile` is written in a format expected by Buildroot and contains directives
    that allow Buildroot to download, configure, compile, and install the program.
    Writing a new package `makefile` is a complex operation which is covered in detail
    in the *Buildroot User Manual*. Here is an example which shows you how to create
    a package for a simple program stored locally, such as our `helloworld` program.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`makefile`以Buildroot期望的格式编写，并包含指令，允许Buildroot下载、配置、编译和安装程序。编写新软件包`makefile`是一个复杂的操作，在*Buildroot用户手册*中有详细介绍。以下是一个示例，演示了如何为存储在本地的简单程序（如我们的`helloworld`程序）创建软件包。'
- en: 'Begin by creating the subdirectory `package/helloworld` with a configuration
    file, `Config.in`, that looks like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建子目录`package/helloworld`，其中包含一个名为`Config.in`的配置文件，内容如下：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first line must be of the format `BR2_PACKAGE_<uppercase package name>`.
    That is followed by a Boolean and the package name as it will appear in the **configuration**
    menu and which will allow a user to select this package. The *Help* section is
    optional (but hopefully useful).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行必须是`BR2_PACKAGE_<大写软件包名称>`的格式。然后是一个布尔值和软件包名称，它将出现在**配置**菜单中，并允许用户选择此软件包。*帮助*部分是可选的（但希望有用）。
- en: 'Next, link the new package into the **Target Packages** menu by editing `package/Config.in`
    and sourcing the configuration file as mentioned in the preceding section. You
    could append this to an existing sub-menu but, in this case, it seems neater to
    create a new sub-menu which only contains our package:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过编辑`package/Config.in`并在前面的部分提到的源配置文件，将新软件包链接到**目标软件包**菜单中。您可以将其附加到现有子菜单中，但在这种情况下，创建一个仅包含我们软件包的新子菜单似乎更整洁：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, create a makefile, `package/helloworld/helloworld.mk`, to supply the
    data needed by Buildroot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个makefile，`package/helloworld/helloworld.mk`，以提供Buildroot所需的数据：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The location of the code is hard-coded to a local path name. In a more realistic
    case, you would get the code from a source code system or from a central server
    of some kind: there are details of how to do this in the *Buildroot User Guide*
    and plenty of examples in other packages.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的位置被硬编码为本地路径名。在更现实的情况下，您将从源代码系统或某种中央服务器获取代码：*Buildroot用户指南*中有如何执行此操作的详细信息，其他软件包中也有大量示例。
- en: License compliance
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许可合规性
- en: 'Buildroot is based on open source software, as are the packages it compiles.
    At some point during the project, you should check the licenses, which you can
    do by running:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot基于开源软件，它编译的软件包也是开源的。在项目的某个阶段，您应该检查许可证，可以通过运行以下命令来执行：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The information is gathered into `output/legal-info`. There are summaries of
    the licenses used to compile the host tools in `host-manifest.csv` and, on the
    target, in `manifest.csv`. There is more information in the `README` file and
    in the *Buildroot User Manual*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 信息被收集到`output/legal-info`中。在`host-manifest.csv`中有用于编译主机工具的许可证摘要，在目标中有`manifest.csv`。在*Buildroot用户手册*和`README`文件中有更多信息。
- en: The Yocto Project
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Yocto项目
- en: The Yocto Project is a more complex beast than Buildroot. Not only can it build
    toolchains, bootloaders, kernels, and root filesystems, as Buildroot can, but
    it can generate an entire Linux distribution for you, with binary packages that
    can be installed at runtime.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto项目比Buildroot更复杂。它不仅可以像Buildroot一样构建工具链、引导加载程序、内核和根文件系统，还可以为您生成整个Linux发行版，其中包含可以在运行时安装的二进制软件包。
- en: The Yocto Project is primarily a group of recipes, similar to Buildroot packages
    but written using a combination of Python and shell script, and a task scheduler
    called BitBake that produces whatever you have configured, from the recipes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 项目主要是一组类似于 Buildroot 包的配方，但是使用 Python 和 shell 脚本的组合编写，并使用名为 BitBake 的任务调度程序生成你配置的任何内容。
- en: There is plenty of online documentation at [https://www.yoctoproject.org/](https://www.yoctoproject.org/).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://www.yoctoproject.org/](https://www.yoctoproject.org/) 有大量在线文档。
- en: Background
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: The structure of the Yocto Project makes more sense if you look at the background
    first. Its roots are in OpenEmbedded, [http://openembedded.org/](http://openembedded.org/)
    which, in turn, grew out of a number of projects to port Linux to various hand-held
    computers, including the Sharp Zaurus and Compaq iPaq. OpenEmbedded came to life
    in 2003 as the build system for those hand-held computers but quickly expanded
    to encompass other embedded boards. It was developed and continues to be developed
    by an enthusiastic community of programmers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto 项目的结构如果你先看一下背景会更有意义。它的根源在于 OpenEmbedded，[http://openembedded.org/](http://openembedded.org/)，而
    OpenEmbedded 又源自于一些项目，用于将 Linux 移植到各种手持计算机上，包括 Sharp Zaurus 和 Compaq iPaq。OpenEmbedded
    于 2003 年诞生，作为这些手持计算机的构建系统，但很快扩展到包括其他嵌入式板。它是由一群热情的程序员开发并继续开发的。
- en: The OpenEmbedded project set out to create a set of binary packages using the
    compact `.ipk` format, which could then be combined in various ways to create
    a target system and be installed on the target at runtime. It did this by creating
    recipes for each piece of software and using BitBake as the task scheduler. It
    was, and is, very flexible. By supplying the right metadata, you can create an
    entire Linux distribution to your own specification. One that is fairly well known
    is *The Ångström Distribution*, [http://www.angstrom-distribution.org](http://www.angstrom-distribution.org),
    but there are many others.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: OpenEmbedded 项目旨在使用紧凑的 `.ipk` 格式创建一组二进制软件包，然后可以以各种方式组合这些软件包，创建目标系统，并在运行时安装在目标上。它通过为每个软件创建配方并使用
    BitBake 作为任务调度程序来实现这一点。它非常灵活。通过提供正确的元数据，你可以根据自己的规格创建整个 Linux 发行版。一个相当知名的是 *The
    Ångström Distribution*，[http://www.angstrom-distribution.org](http://www.angstrom-distribution.org)，但还有许多其他发行版。
- en: At some time in 2005 Richard Purdie, then a developer at OpenedHand, created
    a fork of OpenEmbedded which had a more conservative choice of packages and created
    releases that were stable over a period of time. He named it Poky, after the Japanese
    snack (if you are worried about these things, Poky is pronounced to rhyme with
    hockey). Although Poky was a fork, OpenEmbedded and Poky continued to run alongside
    each other, sharing updates and keeping the architectures more or less in step.
    Intel brought out OpenedHand in 2008 and they transferred Poky Linux to the Linux
    Foundation in 2010 when they formed the Yocto Project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2005 年的某个时候，当时是 OpenedHand 的开发人员 Richard Purdie 创建了 OpenEmbedded 的一个分支，选择了更保守的软件包，并创建了一段时间稳定的发布。他将其命名为
    Poky，以日本小吃命名（如果你担心这些事情，Poky 的发音与 hockey 押韵）。尽管 Poky 是一个分支，但 OpenEmbedded 和 Poky
    仍然并行运行，共享更新，并保持体系结构大致同步。英特尔在 2008 年收购了 OpenedHand，并在 2010 年他们成立 Yocto 项目时将 Poky
    Linux 转移到了 Linux 基金会。
- en: Since 2010, the common components of OpenEmbedded and Poky have been combined
    into a separate project known as OpenEmbedded core, or just oe-core.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2010 年以来，OpenEmbedded 和 Poky 的共同组件已经合并为一个名为 OpenEmbedded core 的独立项目，或者简称 oe-core。
- en: 'Therefore, the Yocto Project collects together several components, the most
    important of which are the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Yocto 项目汇集了几个组件，其中最重要的是以下内容：
- en: '**Poky**: The reference distribution'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Poky**：参考发行版'
- en: '**oe-core**: The core metadata, which is shared with OpenEmbedded'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**oe-core**：与 OpenEmbedded 共享的核心元数据'
- en: '**BitBake**: The task scheduler, which is shared with OpenEmbedded and other
    projects'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BitBake**：任务调度程序，与 OpenEmbedded 和其他项目共享'
- en: '**Documentation**: User manuals and developer''s guides for each component'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：每个组件的用户手册和开发人员指南'
- en: '**Hob**: A graphical user interface to OpenEmbedded and BitBake'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Hob**：OpenEmbedded 和 BitBake 的图形用户界面'
- en: '**Toaster**: A web-based interface to OpenEmbedded and BitBake'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Toaster**：OpenEmbedded 和 BitBake 的基于 Web 的界面'
- en: '**ADT Eclipse**: A plug-in for Eclipse that makes it easier to build projects
    using the Yocto Project SDK'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ADT Eclipse**：Eclipse 的插件，使使用 Yocto 项目 SDK 更容易构建项目'
- en: Strictly speaking, the Yocto Project is an umbrella for these sub-projects.
    It uses OpenEmbedded as its build system, and Poky as its default configuration
    and reference environment. However, people often use the term "the Yocto Project"
    to refer to the build system alone. I feel that it is too late for me to turn
    this tide, so for brevity I will do the same. I apologise in advance to the developers
    of OpenEmbedded.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，Yocto 项目是这些子项目的总称。它使用 OpenEmbedded 作为其构建系统，并使用 Poky 作为其默认配置和参考环境。然而，人们经常使用术语“Yocto
    项目”来指代仅构建系统。我觉得现在已经为时已晚，所以为了简洁起见，我也会这样做。我提前向 OpenEmbedded 的开发人员道歉。
- en: The Yocto Project provides a stable base which can be used as it is or which
    can be extended using meta layers, which I will discuss later in this chapter.
    Many SoC vendors provide board support packages for their devices in this way.
    Meta layers can also be used to create extended, or just different, build systems.
    Some are open source, such as the Angstrom Project, others are commercial, such
    as MontaVista Carrier Grade Edition, Mentor Embedded Linux, and Wind River Linux.
    The Yocto Project has a branding and compatibility testing scheme to ensure that
    there is interoperability between components. You will see statements like *Yocto
    Project Compatible 1.7* on various web pages.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto项目提供了一个稳定的基础，可以直接使用，也可以使用元层进行扩展，我将在本章后面讨论。许多SoC供应商以这种方式为其设备提供了板支持包。元层也可以用于创建扩展的或不同的构建系统。有些是开源的，比如Angstrom项目，另一些是商业的，比如MontaVista
    Carrier Grade Edition、Mentor Embedded Linux和Wind River Linux。Yocto项目有一个品牌和兼容性测试方案，以确保组件之间的互操作性。您会在各种网页上看到类似“Yocto项目兼容1.7”的声明。
- en: Consequently, you should think of the Yocto Project as the foundation of a whole
    sector of embedded Linux, as well as being a complete build system in its own
    right. You may be wondering about the name, *yocto*. A yocto is the SI prefix
    for 10-24, in the same way that micro is 10-6\. Why name the project yocto? It
    was partly to indicate that it could build very small Linux systems (although,
    to be fair, so can other build systems), but also, perhaps, to steal a march on
    the Ångström distribution which is based on OpenEmbedded. An Ångström is 10-10\.
    That's huge, compared to a yocto!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您应该将Yocto项目视为嵌入式Linux整个领域的基础，同时也是一个完整的构建系统。您可能会对*yocto*这个名字感到好奇。Yocto是10-24的国际单位制前缀，就像微是10-6一样。为什么要给项目取名为yocto呢？部分原因是为了表明它可以构建非常小的Linux系统（尽管公平地说，其他构建系统也可以），但也可能是为了在基于OpenEmbedded的Ångström发行版上取得优势。Ångström是10-10。与yocto相比，那太大了！
- en: Stable releases and support
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稳定版本和支持
- en: 'Usually, there is a release of the Yocto Project every six months, in April
    and October. They are principally known by the code name, but it is useful to
    know the version numbers of the Yocto Project and Poky as well. Here is a table
    of the four most recent releases at the time of writing:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Yocto项目每六个月发布一次，分别在4月和10月。它们主要以代号而闻名，但了解Yocto项目和Poky的版本号也是有用的。以下是我写作时最近的四个版本的表格：
- en: '| Code name | Release date | Yocto version | Poky version |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 代号 | 发布日期 | Yocto版本 | Poky版本 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `Fido` | April 2015 | 1.8 | 13 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `Fido` | 2015年4月 | 1.8 | 13 |'
- en: '| `Dizzy` | October 2014 | 1.7 | 12 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `Dizzy` | 2014年10月 | 1.7 | 12 |'
- en: '| `Daisy` | April 2014 | 1.6 | 11 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `Daisy` | 2014年4月 | 1.6 | 11 |'
- en: '| `Dora` | October 2013 | 1.5 | 10 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `Dora` | 2013年10月 | 1.5 | 10 |'
- en: The stable releases are supported with security and critical bug fixes for the
    current release cycle and the next cycle, that is approximately twelve months
    after release. No toolchain or kernel version changes are allowed for these updates.
    As with Buildroot, if you want continued support, you can update to the next stable
    release or you can backport changes to your version. You also also have the option
    of commercial support for periods of several years with the Yocto Project from
    operating system vendors such as Mentor Graphics, Wind River, and many others.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定版本在当前发布周期和下一个周期内受到安全和关键错误修复的支持，即发布后大约12个月。这些更新不允许进行工具链或内核版本更改。与Buildroot一样，如果您希望获得持续支持，可以升级到下一个稳定版本，或者可以将更改移植到您的版本。您还可以选择从操作系统供应商（如Mentor
    Graphics、Wind River等）获得长达数年的商业支持。
- en: Installing the Yocto Project
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Yocto项目
- en: 'To get a copy of the Yocto Project, you can either clone the repository, choosing
    the code name as the branch which is `fido` in this case:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取Yocto项目的副本，您可以克隆存储库，选择代码名称作为分支，本例中为`fido`：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can also download the archive from [http://downloads.yoctoproject.org/releases/yocto/yocto-1.8/poky-fido-13.0.0.tar.bz2](http://downloads.yoctoproject.org/releases/yocto/yocto-1.8/poky-fido-13.0.0.tar.bz2).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从[http://downloads.yoctoproject.org/releases/yocto/yocto-1.8/poky-fido-13.0.0.tar.bz2](http://downloads.yoctoproject.org/releases/yocto/yocto-1.8/poky-fido-13.0.0.tar.bz2)下载存档。
- en: In the first case, you will find everything in the `poky` directory, in the
    second case, `poky-fido-13.0.0/`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，您会在`poky`目录中找到所有内容，在第二种情况下，是`poky-fido-13.0.0/`。
- en: In addition, you should read the section titled *System Requirements* from the
    *Yocto Project Reference Manual* ([http://www.yoctoproject.org/docs/current/ref-manual/ref-manual.html#detailed-supported-distros](http://www.yoctoproject.org/docs/current/ref-manual/ref-manual.html#detailed-supported-distros))
    and, in particular, you should make sure that the packages listed there are installed
    on your host computer.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您应该阅读《Yocto项目参考手册》（[http://www.yoctoproject.org/docs/current/ref-manual/ref-manual.html#detailed-supported-distros](http://www.yoctoproject.org/docs/current/ref-manual/ref-manual.html#detailed-supported-distros)）中标题为“系统要求”的部分，并特别确保其中列出的软件包已安装在您的主机计算机上。
- en: Configuring
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: 'As with Buildroot, let''s begin with a build for the ARM QEMU emulator. Begin
    by sourcing a script to set up the environment:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与Buildroot一样，让我们从ARM QEMU模拟器的构建开始。首先要源化一个脚本来设置环境：
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That creates a working directory for you named `build` and makes it the current
    directory. All of the configuration, intermediate, and deployable files will be
    put in this directory. You must source this script each time you want to work
    on this project.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您创建一个名为`build`的工作目录，并将其设置为当前目录。所有的配置、中间和可部署文件都将放在这个目录中。每次您想要处理这个项目时，都必须源化这个脚本。
- en: 'You can choose a different working directory by adding it as a parameter to
    `oe-init-build-env`, for example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将其作为参数添加到`oe-init-build-env`来选择不同的工作目录，例如：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That will put you into the `build-qemuarm` directory. You can then have several
    projects on the go at the same time: you choose which one you want to work with
    through the parameter to `oe-init-build-env`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使您进入`build-qemuarm`目录。然后，您可以同时进行几个项目：通过`oe-init-build-env`的参数选择要使用的项目。
- en: 'Initially, the `build` directory contains only one subdirectory named `conf`,
    which contains the configuration files for this project:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`build`目录只包含一个名为`conf`的子目录，其中包含此项目的配置文件：
- en: '`local.conf`: Contains a specification of the device you are going to build
    and the build environment.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local.conf`：包含要构建的设备和构建环境的规范。'
- en: '`bblayers.conf`: Contains a list of the directories that contain the layers
    you are going to use. There will be more on layers later on.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bblayers.conf`：包含要使用的层的目录列表。稍后将会有更多关于层的内容。'
- en: '`templateconf.cfg`: Contains the name of a directory which contains various
    `conf` files. By default, it points to `meta-yocto/conf`.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templateconf.cfg`：包含一个包含各种`conf`文件的目录的名称。默认情况下，它指向`meta-yocto/conf`。'
- en: 'For now, we just need to set the `MACHINE` variable in `local.conf` to `qemuarm`
    by removing the comment character at the start of this line:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要在`local.conf`中将`MACHINE`变量设置为`qemuarm`，方法是删除此行开头的注释字符：
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Building
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建
- en: 'To actually perform the build, you need to run `bitbake`, telling it which
    root filesystem image you want to create. Some common images are as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际执行构建，需要运行`bitbake`，告诉它要创建哪个根文件系统镜像。一些常见的图像如下：
- en: '**core-image-minimal**: A small console-based system which is useful for tests
    and as the basis for custom images.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心图像-最小：一个小型的基于控制台的系统，对于测试和作为自定义图像的基础很有用。
- en: '**core-image-minimal-initramfs**: This is similar to core-image-minimal, but
    built as a ramdisk.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心图像-最小initramfs：类似于核心图像-最小，但构建为ramdisk。
- en: '**core-image-x11**: A basic image with support for graphics through an X11
    server and the xterminal terminal app.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心图像-x11：通过X11服务器和xterminal终端应用程序支持图形的基本图像。
- en: '**core-image-sato**: A full graphical system based on Sato, which is a mobile
    graphical environment built on X11, and GNOME. The image includes several apps
    including a terminal, an editor, and a file manager.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心图像-sato：基于Sato的完整图形系统，Sato是基于X11和GNOME构建的移动图形环境。图像包括几个应用程序，包括终端、编辑器和文件管理器。
- en: 'By giving BitBake the final target, it will work backwards and build all the
    dependencies first, beginning with the toolchain. For now, we just want to create
    a minimal image to see whether or not it works:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给BitBake最终目标，它将向后工作，并首先构建所有依赖项，从工具链开始。现在，我们只想创建一个最小的图像来查看它是否有效：
- en: '[PRE17]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The build is likely to take some time, maybe more than an hour. When it is
    complete, you will find several new directories in the build directory including
    `build/downloads`, which contains all the source downloaded for the build, and
    `build/tmp` which contains most of the build artifacts. You should see the following
    in `tmp`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 构建可能需要一些时间，可能超过一个小时。完成后，您将在构建目录中找到几个新目录，包括`build/downloads`，其中包含构建所需的所有源文件，以及`build/tmp`，其中包含大部分构建产物。您应该在`tmp`中看到以下内容：
- en: '`work`: Contains the build directory and the staging area for all components,
    including the root filesystem'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`work`：包含构建目录和所有组件的分段区域，包括根文件系统'
- en: '`deploy`: Contains the final binaries to be deployed on the target:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deploy`：包含要部署到目标上的最终二进制文件：'
- en: '`deploy/images/[machine name]`: Contains the bootloader, the kernel, and the
    root filesystem images ready to be run on the target'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deploy/images/[机器名称]`：包含引导加载程序、内核和根文件系统镜像，准备在目标上运行'
- en: '`deploy/rpm`: Contains the RPM packages that went to make up the images'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deploy/rpm`：包含组成图像的RPM软件包'
- en: '`deploy/licenses`: Contains the license files extracted from each package'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deploy/licenses`：包含从每个软件包中提取的许可文件'
- en: Running
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行
- en: When you build a QEMU target, an internal version of QEMU is generated, which
    removes the need to install the QEMU package for your distribution and thus avoids
    version dependencies. There is a wrapper script named `runqemu` for this internal
    QEMU.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建QEMU目标时，将生成一个内部版本的QEMU，从而无需安装QEMU软件包以避免版本依赖。有一个名为`runqemu`的包装脚本用于这个内部QEMU。
- en: 'To run the QEMU emulation, make sure that you have sourced `oe-init-build-env`
    and then just type:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行QEMU仿真，请确保已经源自`oe-init-build-env`，然后只需键入：
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this case, QEMU has been configured with a graphic console so that the boot
    messages and login prompt appear in the black framebuffer screen:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，QEMU已配置为具有图形控制台，因此启动消息和登录提示将显示在黑色帧缓冲屏幕上：
- en: '![Running](img/B03982_06_03.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![运行中](img/B03982_06_03.jpg)'
- en: 'You can log on as `root`, without a password. You can close down QEMU by closing
    the framebuffer window. You can launch QEMU without the graphic window by adding
    `nographic` to the command line:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以`root`身份登录，无需密码。您可以通过关闭帧缓冲窗口关闭QEMU。您可以通过在命令行中添加`nographic`来启动不带图形窗口的QEMU：
- en: '[PRE19]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, you close QEMU using the key sequence *Ctrl* + *A* + *X*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用键序*Ctrl* + *A* + *X*关闭QEMU。
- en: The `runqemu` script has many other options, type `runqemu help` for more information.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`runqemu`脚本有许多其他选项，键入`runqemu help`以获取更多信息。'
- en: Layers
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 层
- en: 'The metadata for the Yocto Project is structured into layers, by convention,
    each with a name beginning with `meta`. The core layers of the Yocto Project are
    as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto项目的元数据按层结构化，按照惯例，每个层的名称都以`meta`开头。Yocto项目的核心层如下：
- en: '**meta**: This is the OpenEmbedded core'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元：这是OpenEmbedded核心
- en: '**meta-yocto**: Metadata specific to the Yocto Project, including the Poky
    distribution'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: meta-yocto：特定于Yocto项目的元数据，包括Poky发行版
- en: '**meta-yocto-bsp**: Contains the board support packages for the reference machines
    that the Yocto Project supports'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: meta-yocto-bsp：包含Yocto项目支持的参考机器的板支持软件包
- en: The list of layers in which BitBake searches for recipes is stored in `<your
    build directory>/conf/bblayers.conf` and, by default, includes all three layers
    mentioned in the preceding list.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: BitBake搜索配方的层列表存储在`<your build directory>/conf/bblayers.conf`中，并且默认情况下包括前面列表中提到的所有三个层。
- en: 'By structuring the recipes and other configuration data in this way, it is
    very easy to extend the Yocto Project by adding new layers. Additional layers
    are available from SoC manufacturers, the Yocto Project itself, and a wide range
    of people wishing to add value to the Yocto Project and OpenEmbedded. There is
    a useful list of layers at [http://layers.openembedded.org](http://layers.openembedded.org).
    Here are some examples:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以这种方式构建配方和其他配置数据，很容易通过添加新的层来扩展Yocto项目。额外的层可以从SoC制造商、Yocto项目本身以及希望为Yocto项目和OpenEmbedded增加价值的广泛人员那里获得。在[http://layers.openembedded.org](http://layers.openembedded.org)上有一个有用的层列表。以下是一些示例：
- en: '**meta-angstrom**: The Ångström distribution'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**meta-angstrom**：Ångström发行版'
- en: '**meta-qt5**: Qt5 libraries and utilities'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**meta-qt5**：Qt5库和实用程序'
- en: '**meta-fsl-arm**: BSPs for Freescale ARM-based SoCs'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**meta-fsl-arm**：Freescale基于ARM的SoC的BSP'
- en: '**meta-fsl-ppc**: BSPs for Freescale PowerPC-based SoCs'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**meta-fsl-ppc**：Freescale基于PowerPC的SoC的BSP'
- en: '**meta-intel**: BSPs for Intel CPUs and SoCs'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**meta-intel**：Intel CPU和SoC的BSP'
- en: '**meta-ti**: BSPs for TI ARM-based SoCs'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**meta-ti**：TI基于ARM的SoC的BSP'
- en: Adding a layer is as simple as copying the meta directory into a suitable location,
    usually alongside the default meta layers, and adding it to `bblayers.conf`. Just
    make sure it is compatible with the version of the Yocto Project you are using.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个层就像将meta目录复制到合适的位置一样简单，通常是在默认的meta层旁边，并将其添加到`bblayers.conf`中。只需确保它与您正在使用的Yocto项目版本兼容即可。
- en: 'To illustrate the way layers work, let''s create a layer for our Nova board
    which we can use for the remainder of the chapter as we add features. Each meta
    layer has to have at least one configuration file, `conf/layer.conf`, and should
    also have a `README` file and a license. There is a handy helper script that does
    the basics for us:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明层的工作原理，让我们为我们的Nova板创建一个层，我们可以在本章的其余部分中使用它来添加功能。每个元层必须至少有一个配置文件`conf/layer.conf`，还应该有一个`README`文件和一个许可证。有一个方便的辅助脚本可以为我们完成基本工作：
- en: '[PRE20]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The script asks for a priority, and if you want to create sample recipes. In
    the example here, I just accepted the defaults:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本会要求设置优先级，以及是否要创建示例配方。在这个示例中，我只接受了默认值：
- en: '[PRE21]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That will create a layer named `meta-nova` with a `conf/layer.conf`, an outline
    `README` and a MIT license in `COPYING.MIT`. The `layer.conf` file looks like
    this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`meta-nova`的层，其中包含`conf/layer.conf`、概要`README`和`COPYING.MIT`中的MIT许可证。`layer.conf`文件如下所示：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It adds itself to `BBPATH` and the recipes it contains to `BBFILES`. From looking
    at the code, you can see that the recipes are found in the directories with names
    beginning `recipes-` and have file names ending in `.bb` (for normal BitBake recipes),
    or `.bbappend` (for recipes that extend existing normal recipes by adding and
    overriding instructions). This layer has the name `nova` which is added to the
    list of layers in `BBFILE_COLLECTIONS` and it has a priority of `6`. The layer
    priority is used if the same recipe appears in several layers: the one in the
    layer with the highest priority wins.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 它将自己添加到`BBPATH`，并将其包含的配方添加到`BBFILES`。通过查看代码，您可以看到配方位于以`recipes-`开头的目录中，并且文件名以`.bb`结尾（用于普通BitBake配方），或以`.bbappend`结尾（用于通过添加和覆盖指令扩展现有普通配方的配方）。此层的名称为`nova`，它被添加到`BBFILE_COLLECTIONS`中的层列表中，并且具有优先级`6`。如果相同的配方出现在几个层中，则具有最高优先级的层中的配方获胜。
- en: 'Since you are about to build a new configuration, it is best to begin by creating
    a new build directory named `build-nova`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您即将构建一个新的配置，最好从创建一个名为`build-nova`的新构建目录开始：
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now you need to add this layer to your build configuration, `conf/bblayers.conf`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要将此层添加到您的构建配置中，`conf/bblayers.conf`：
- en: '[PRE24]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can confirm that it is set up correctly by using another helper script:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用另一个辅助脚本确认它是否设置正确：
- en: '[PRE25]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There you can see the new layer. It has priority `6` which means that we could
    override recipes in the other layers, which have a lower priority.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，您可以看到新的层。它的优先级为`6`，这意味着我们可以覆盖具有较低优先级的其他层中的配方。
- en: At this point it would be a good idea to run a build, using this empty layer.
    The final target will be the Nova board but, for now, build for a BeagelBone Black
    by removing the comment before `MACHINE ?= "beaglebone"` in `conf/local.conf`.
    Then, build a small image using `bitbake core-image-minimal` as before.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此时运行一个构建，使用这个空层是一个好主意。最终目标将是Nova板，但是现在，通过在`conf/local.conf`中的`MACHINE ?= "beaglebone"`之前去掉注释，为BeagelBone
    Black构建一个小型镜像。然后，使用`bitbake core-image-minimal`构建一个小型镜像。
- en: As well as recipes, layers may contain BitBake classes, configuration files
    for machines, distributions, and more. I will look at recipes next and show you
    how to create a customized image and how to create a package.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配方，层还可以包含BitBake类、机器的配置文件、发行版等。接下来我将看一下配方，并向您展示如何创建自定义镜像以及如何创建软件包。
- en: BitBake and recipes
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BitBake和配方
- en: 'BitBake processes metadata of several different types, which include the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: BitBake处理几种不同类型的元数据，包括以下内容：
- en: '**recipes**: Files ending in `.bb`. These contain information about building
    a unit of software, including how to get a copy of the source code, the dependencies
    on other components, and how to build and install it.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**recipes**：以`.bb`结尾的文件。这些文件包含有关构建软件单元的信息，包括如何获取源代码副本、对其他组件的依赖关系以及如何构建和安装它。'
- en: '**append**: Files ending in `.bbappend`. These allow some details of a recipe
    to be overridden or extended. `A.bbappend` file simply appends its instructions
    to the end of a recipe (`.bb`) file of the same root name.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**append**：以`.bbappend`结尾的文件。这些文件允许覆盖或扩展配方的一些细节。`A.bbappend`文件只是将其指令附加到具有相同根名称的配方（`.bb`）文件的末尾。'
- en: '**include**: Files ending in `.inc`. These contain information that is common
    to several recipes, allowing information to be shared among them. The files may
    be included using the `include` or `require` keywords. The difference is that
    `require` produces an error if the file does not exist, whereas `include` does
    not.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包括**：以`.inc`结尾的文件。这些文件包含多个食谱共有的信息，允许信息在它们之间共享。可以使用`include`或`require`关键字来包含这些文件。不同之处在于，如果文件不存在，`require`会产生错误，而`include`不会。'
- en: '**classes**: Files ending in `.bbclass`. These contain common build information,
    for example how to build a kernel or how to build an `autotools` project. The
    classes are inherited and extended in recipes and other classes using the `inherit`
    key word. The class `classes/base.bbclass` is implicitly inherited in every recipe.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：以`.bbclass`结尾的文件。这些文件包含常见的构建信息，例如如何构建内核或如何构建`autotools`项目。这些类在食谱和其他类中使用`inherit`关键字进行继承和扩展。`classes/base.bbclass`类在每个食谱中都会被隐式继承。'
- en: '**configuration**: Files ending in `.conf`. They define various configuration
    variables that govern the project''s build process.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：以`.conf`结尾的文件。它们定义了管理项目构建过程的各种配置变量。'
- en: A recipe is a collection of tasks written in a combination of Python and shell
    code. The tasks have names like `do_fetch`, `do_unpack`, `do_patch`, `do_configure`,
    `do_compile`, `do_install`, and so on. You use BitBake to execute these tasks.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱是一组以Python和shell代码的组合编写的任务。任务的名称如`do_fetch`、`do_unpack`、`do_patch`、`do_configure`、`do_compile`、`do_install`等。您可以使用BitBake来执行这些任务。
- en: 'The default task is `do_build`, so that you are running the build task for
    that recipe. You can list the tasks available in a recipe by running `bitbake
    core-image-minimal` like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 默认任务是`do_build`，因此您正在运行该食谱的构建任务。您可以通过像这样运行`bitbake core-image-minimal`来列出食谱中可用的任务：
- en: '[PRE26]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `-c` option allows you to specify the task, missing off the `do_` part.
    A common use is `-c fetch` to get the code needed by a recipe:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`-c`选项允许您指定任务，省略`do_`部分。一个常见的用法是`-c fetch`来获取一个食谱所需的代码：'
- en: '[PRE27]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can also use `fetchall` to get the code for the target and all the dependencies:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`fetchall`来获取目标代码和所有依赖项的代码：
- en: '[PRE28]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The recipe files are are usually named `<package-name>_version.bb`. They may
    have dependencies on other recipes, which would allow BitBake to work out all
    the subtasks that need to be executed to complete the top level job. Unfortunately,
    I don't have the space in this book to describe the dependency mechanism, but
    you will find a full description in the Yocto Project documentation.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱文件通常被命名为`<package-name>_version.bb`。它们可能依赖于其他食谱，这将允许BitBake计算出需要执行的所有子任务，以完成顶层作业。不幸的是，我在这本书中没有空间来描述依赖机制，但您将在Yocto
    Project文档中找到完整的描述。
- en: 'As an example, to create a recipe for our `helloworld` program in `meta-nova`,
    you would create a directory structure like this:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在`meta-nova`中为我们的`helloworld`程序创建一个食谱，您可以创建以下目录结构：
- en: '[PRE29]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The recipe is `helloworld_1.0.bb` and the source is local to the recipe directory
    in the subdirectory files. The recipe contains these instructions:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 食谱是`helloworld_1.0.bb`，源代码是食谱目录中子目录文件的本地文件。食谱包含这些说明：
- en: '[PRE30]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The location of the source code is set by `SRC_URI`: in this case it will search
    directories, files, `helloworld`, and `helloworld-1.0` in the recipe directory.
    The only tasks that need to be defined are `do_compile` and `do_install`, which
    compile the one source file simply and install it into the target root filesystem:
    `${D}` expands to the staging area of the target device and `${bindir}` to the
    default binary directory, `/usr/bin`.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码的位置由`SRC_URI`设置：在这种情况下，它将在食谱目录中搜索目录、文件、`helloworld`和`helloworld-1.0`。唯一需要定义的任务是`do_compile`和`do_install`，它们简单地编译一个源文件并将其安装到目标根文件系统中：`${D}`扩展到目标设备的分段区域，`${bindir}`扩展到默认的二进制目录`/usr/bin`。
- en: Every recipe has a license, defined by `LICENSE`, which is set to `GPLv2` here.
    The file containing the text of the license and a checksum is defined by `LIC_FILES_CHKSUM`.
    BitBake will terminate the build if the checksum does not match, indicating that
    the license has changed in some way. The license file may be part of the package
    or it may point to one of the standard license texts in `meta/files/common-licenses`,
    as is the case here.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 每个食谱都有一个许可证，由`LICENSE`定义，这里设置为`GPLv2`。包含许可证文本和校验和的文件由`LIC_FILES_CHKSUM`定义。如果校验和不匹配，BitBake将终止构建，表示许可证以某种方式发生了变化。许可证文件可能是软件包的一部分，也可能指向`meta/files/common-licenses`中的标准许可证文本之一，就像这里一样。
- en: 'By default, commercial licenses are disallowed, but it is easy to enable them.
    You need to specify the license in the recipe, as shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，商业许可证是不允许的，但很容易启用它们。您需要在食谱中指定许可证，如下所示：
- en: '[PRE31]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, in your `conf/local.conf`, you would explicitly allow this license, like
    so:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您的`conf/local.conf`中，您可以明确允许此许可证，如下所示：
- en: '[PRE32]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To make sure that it compiles correctly, you can ask BitBake to build it, like
    so:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保它编译正确，您可以要求BitBake构建它，如下所示：
- en: '[PRE33]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If all goes well, you should see that it has created a working directory for
    it in `tmp/work/cortexa8hf-vfp-neon-poky-linux-gnueabi/helloworld/`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该看到它已经在`tmp/work/cortexa8hf-vfp-neon-poky-linux-gnueabi/helloworld/`中为其创建了一个工作目录。
- en: You should also see there is an RPM package for it in `tmp/deploy/rpm/cortexa8hf_vfp_neon/helloworld-1.0-r0.cortexa8hf_vfp_neon.rpm`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该看到`tmp/deploy/rpm/cortexa8hf_vfp_neon/helloworld-1.0-r0.cortexa8hf_vfp_neon.rpm`中有一个RPM软件包。
- en: 'It is not part of the target image yet, though. The list of packages to be
    installed is held in a variable named `IMAGE_INSTALL`. You can append to the end
    of that list by adding this line to your `conf/local.conf`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，它还不是目标镜像的一部分。要安装的软件包列表保存在名为`IMAGE_INSTALL`的变量中。您可以通过将此行添加到您的`conf/local.conf`中的列表末尾来追加到该列表：
- en: '[PRE34]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note that there has to be a space between the first double quote and the first
    package name. Now, the package will be added to any image that you bitbake:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一个双引号和第一个软件包名称之间必须有一个空格。现在，该软件包将被添加到您bitbake的任何镜像中：
- en: '[PRE35]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you look in `tmp/deploy/images/beaglebone/core-image-minimal-beaglebone.tar.bz2`
    you will see that `/usr/bin/helloworld` has indeed been installed.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看`tmp/deploy/images/beaglebone/core-image-minimal-beaglebone.tar.bz2`，您将看到确实已安装`/usr/bin/helloworld`。
- en: Customizing images via local.conf
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过local.conf自定义图像
- en: 'You may often want to add a package to an image during development or tweak
    it in other ways. As shown previously, you can simply append to the list of packages
    to be installed by adding a statement like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能经常希望在开发过程中向图像添加软件包或以其他方式进行微调。如前所示，您可以通过添加类似以下语句来简单地追加要安装的软件包列表：
- en: '[PRE36]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It should be no surprise that you can also do the opposite: you can remove
    a package using this syntax:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，您也可以做相反的事情：可以使用以下语法删除软件包：
- en: '[PRE37]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can make more sweeping changes via `EXTRA_IMAGE_FEATURES`. There are too
    many to list here, I recommend you look at the *Image Features* section of the
    *Yocto Project Reference Manual* and the code in `meta/classes/core-image.bbclass`.
    Here is a short list which should give you an idea of the features you can enable:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`EXTRA_IMAGE_FEATURES`进行更广泛的更改。这里列不完，我建议您查看*Yocto Project参考手册*的*图像功能*部分和`meta/classes/core-image.bbclass`中的代码。以下是一个简短的列表，应该可以让您了解可以启用的功能：
- en: '`dbg-pkgs`: installs debug symbol packages for all the packages installed in
    the image.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dbg-pkgs`：为图像中安装的所有软件包安装调试符号包。'
- en: '`debug-tweaks`: allows root logins without passwords and other changes that
    make development easier.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug-tweaks`：允许无密码进行root登录和其他使开发更容易的更改。'
- en: '`package-management`: installs package management tools and preserves the package
    manager database.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package-management`：安装软件包管理工具并保留软件包管理器数据库。'
- en: '`read-only-rootfs`: makes the root filesystem read-only. We will cover this
    in more detail in [Chapter 7](ch07.html "Chapter 7. Creating a Storage Strategy"),
    *Creating a Storage Strategy*.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read-only-rootfs`：使根文件系统只读。我们将在[第7章](ch07.html "第7章。创建存储策略")中详细介绍这一点，*创建存储策略*。'
- en: '`x11`: installs the X server.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x11`：安装X服务器。'
- en: '`x11-base`: installs the X server with a minimal environment.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x11-base`：安装带有最小环境的X服务器。'
- en: '`x11-sato`: installs the OpenedHand Sato environment.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x11-sato`：安装OpenedHand Sato环境。'
- en: Writing an image recipe
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写图像配方
- en: The problem with making changes to `local.conf` is that they are, well, local.
    If you want to create an image that is to be shared with other developers, or
    to be loaded onto a production system, then you should put the changes into an
    image recipe.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对`local.conf`进行更改的问题在于它们是本地的。如果您想创建一个要与其他开发人员共享或加载到生产系统的图像，那么您应该将更改放入图像配方中。
- en: 'An image recipe contains instructions about how to create the image files for
    a target, including the bootloader, the kernel, and the root filesystem images.
    You can get a list of the images that are available by using this command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图像配方包含有关如何为目标创建图像文件的指令，包括引导加载程序、内核和根文件系统映像。您可以使用此命令获取可用图像的列表：
- en: '[PRE38]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The recipe for `core-image-minimal` is in `meta/recipes-core/images/core-image-minimal.bb`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`core-image-minimal`的配方位于`meta/recipes-core/images/core-image-minimal.bb`中。'
- en: A simple approach is to take an existing image recipe and modify it using statements
    similar to those you used in `local.conf`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的方法是使用类似于在`local.conf`中使用的语句来获取现有的图像配方并进行修改。
- en: 'For example, imagine that you want an image that is the same as `core-image-minimal`
    but includes your `helloworld` program and the `strace` utility. You can do that
    with a two-line recipe file which includes (using the `require` keyword) the base
    image and adds the packages you want. It is conventional to put the image in a
    directory named `images`, so add the recipe `nova-image.bb` with this content
    in `meta-nova/recipes-local/images`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您想要一个与`core-image-minimal`相同的图像，但包括您的`helloworld`程序和`strace`实用程序。您可以使用一个两行的配方文件来实现这一点，该文件包括（使用`require`关键字）基本图像并添加您想要的软件包。将图像放在名为`images`的目录中是传统的做法，因此在`meta-nova/recipes-local/images`中添加具有以下内容的配方`nova-image.bb`：
- en: '[PRE39]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now you can remove the `IMAGE_INSTALL_append` line from your `local.conf` and
    build it using:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以从`local.conf`中删除`IMAGE_INSTALL_append`行，并使用以下命令构建它：
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you want to go further and take total control of the contents of the root
    filesystem, you can start from scratch with an empty `IMAGE_INSTALL` variable
    and populate it like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想进一步控制根文件系统的内容，可以从空的`IMAGE_INSTALL`变量开始，并像这样填充它：
- en: '[PRE41]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`IMAGE_LINGUAS` contains a list of `glibc` locales to be installed in the target
    image. They can take up a lot of space so, in this case, we set the list to be
    empty, which is fine so long as we do not need locale-dependent library functions.
    `IMAGE_ROOTFS_SIZE` is the size of the resulting disk image, in KiB. Most of the
    work is done by the `core-image` class which we inherit at the end.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMAGE_LINGUAS`包含要在目标图像中安装的`glibc`区域设置的列表。它们可能占用大量空间，因此在这种情况下，我们将列表设置为空，只要我们不需要区域设置相关的库函数就可以了。`IMAGE_ROOTFS_SIZE`是生成的磁盘映像的大小，以KiB为单位。大部分工作由我们在最后继承的`core-image`类完成。'
- en: Creating an SDK
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SDK
- en: 'It is very useful to be able to create a standalone toolchain that other developers
    can install, avoiding the need for everyone in the team to have a full installation
    of the Yocto Project. Ideally, you want the toolchain to include development libraries
    and header files for all the libraries installed on the target. You can do that
    for any image using the `populate_sdk` task, as shown here:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 能够创建一个其他开发人员可以安装的独立工具链非常有用，避免了团队中每个人都需要完整安装Yocto Project的需求。理想情况下，您希望工具链包括目标上安装的所有库的开发库和头文件。您可以使用`populate_sdk`任务为任何图像执行此操作，如下所示：
- en: '[PRE42]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The result is a self-installing shell script in `tmp/deploy/sdk` named:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个名为`tmp/deploy/sdk`中的自安装shell脚本：
- en: '[PRE43]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here is an example:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE44]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Note that, by default, the toolchain does not include static libraries. You
    can enable them individually by adding lines like this to your `local.conf` or
    the image recipe:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认情况下，工具链不包括静态库。您可以通过向`local.conf`或图像配方添加类似以下行来单独启用它们：
- en: '[PRE45]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can also enable them globally as shown:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以像下面这样全局启用它们：
- en: '[PRE46]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you only want a basic toolchain with just C and C++ cross compilers, the
    C library and header files, you can instead run:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想要一个基本的工具链，只需C和C++交叉编译器，C库和头文件，您可以运行：
- en: '[PRE47]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To install the SDK, just run the shell script. The default install directory
    is `/opt/poky`, but the install script allows you to change that:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装SDK，只需运行shell脚本。默认安装目录是`/opt/poky`，但安装脚本允许您更改：
- en: '[PRE48]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To make use of the toolchain, first source the environment set up script:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用工具链，首先要源环境设置脚本：
- en: '[PRE49]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Toolchains generated in this way are not configured with a valid `sysroot`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式生成的工具链未配置有效的`sysroot`：
- en: '[PRE50]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Consequently, if you try to cross compile as I have shown in previous chapters,
    it will fail like this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您尝试像我在之前的章节中所示的那样进行交叉编译，它将失败，如下所示：
- en: '[PRE51]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is because the compiler has been configured to be generic to a wide range
    of ARM processors, and the fine tuning is done when you launch it using the right
    set of `gcc` flags. So long as you use `$CC` to compile, everything should work
    fine:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为编译器已配置为通用于广泛范围的ARM处理器，当您使用正确的一组`gcc`标志启动它时，微调就完成了。只要使用`$CC`进行编译，一切都应该正常工作：
- en: '[PRE52]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: License audit
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许可审计
- en: 'The Yocto Project insists that each package has a license. A copy of the license
    is in `tmp/deploy/licenses/[packagenam.e]` for each package, as it is built. In
    addition, a summary of the packages and licenses used in an image are in the `<image
    name>-<machine name>-<date stamp>` directory. This is shown here:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto Project要求每个软件包都有许可证。每个软件包构建时，许可证的副本位于`tmp/deploy/licenses/[packagenam.e]`中。此外，图像中使用的软件包和许可证的摘要位于`<image
    name>-<machine name>-<date stamp>`目录中。如下所示：
- en: '[PRE53]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The first file lists the licenses used by each package, the second lists the
    package names only.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个文件列出了每个软件包使用的许可证，第二个文件只列出了软件包名称。
- en: Further reading
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can have look at the following documentation for more information:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看以下文档以获取更多信息：
- en: '*The Buildroot User Manual*, [http://buildroot.org/downloads/manual/manual.html](http://buildroot.org/downloads/manual/manual.html)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Buildroot用户手册》，[http://buildroot.org/downloads/manual/manual.html](http://buildroot.org/downloads/manual/manual.html)
- en: '*Yocto Project* documentation: there are nine reference guides plus a tenth
    which is a composite of the others (the so-called *Mega-manual*") at [https://www.yoctoproject.org/documentation](https://www.yoctoproject.org/documentation)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yocto Project文档：有九个参考指南，还有一个由其他指南组合而成的第十个（所谓的“Mega-manual”），网址为[https://www.yoctoproject.org/documentation](https://www.yoctoproject.org/documentation)
- en: '*Instant Buildroot*, by *Daniel Manchón Vizuete*, Packt Publishing, 2013'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《即时Buildroot》，作者Daniel Manchón Vizuete，Packt Publishing，2013
- en: '*Embedded Linux Development with Yocto Project*, by *Otavio Salvador* and *Daianne
    Angolini*, Packt Publishing, 2014'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《使用Yocto Project进行嵌入式Linux开发》，作者Otavio Salvador和Daianne Angolini，Packt Publishing，2014
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Using a build system takes the hard work out of creating an embedded Linux
    system, and it is almost always better than hand crafting a roll your own system.
    There is a range of open source build systems available these days: Buildroot
    and the Yocto Project represent two different approaches. Buildroot is simple
    and quick, making it a good choice for fairly simple single-purpose devices: traditional
    embedded Linux as I like to think of them.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构建系统可以减轻创建嵌入式Linux系统的工作量，通常比手工打造自己的系统要好得多。如今有一系列开源构建系统可用：Buildroot和Yocto Project代表了两种不同的方法。Buildroot简单快速，适用于相当简单的单用途设备：我喜欢称之为传统嵌入式Linux。
- en: 'The Yocto Project is more complex and flexible. It is package based, meaning
    that you have the option to install a package manager and perform updates of individual
    packages in the field. The meta layer structure makes it easy to extend the metadata
    and indeed there is good support throughout the community and industry for the
    Yocto Project. The downside is that there is a very steep learning curve: you
    should expect it to take several months to become proficient with it, and even
    then it will sometimes do things that you didn''t expect, or at least that is
    my experience.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto Project更加复杂和灵活。它是基于软件包的，这意味着您可以选择安装软件包管理器，并在现场对单个软件包进行更新。元层结构使得扩展元数据变得容易，社区和行业对Yocto
    Project的支持非常好。缺点是学习曲线非常陡峭：您应该期望需要几个月的时间才能熟练掌握它，即使那样，它有时也会做出您意想不到的事情，至少这是我的经验。
- en: Don't forget that any devices you create using these tools will need to be maintained
    in the field for a period of time, often many years. The Yocto Project will provide
    point releases for about one year after a release, Buildroot usually does not
    provide any point releases. In either case you will find yourself having to maintain
    your release yourself or else paying for commercial support. The third possibility,
    ignoring the problem, should not be considered an option!
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，使用这些工具创建的任何设备都需要在现场维护一段时间，通常是多年。Yocto Project将在发布后约一年提供点发布，Buildroot通常不提供任何点发布。在任何情况下，您都会发现自己必须自行维护您的发布，否则需要支付商业支持费用。第三种可能性，忽视这个问题，不应被视为一个选择！
- en: In the next chapter I will look at file storage and filesystems, and at the
    way that the choices you make there will affect the stability and maintainability
    of your embedded Linux.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将讨论文件存储和文件系统，以及您在那里做出的选择将如何影响嵌入式Linux的稳定性和可维护性。
