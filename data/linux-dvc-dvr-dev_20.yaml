- en: Regulator Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调节器框架
- en: A regulator is an electronic device that supplies power to other devices. Devices
    powered by regulators are called consumers. One said they consume power provided
    by regulators. Most regulators can enable and disable their output and some can
    also control their output voltage or current. The driver should expose those capabilities
    to consumers by means of specific functions and data structures, which we will
    discuss in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 调节器是一种为其他设备提供电源的电子设备。由调节器供电的设备称为消费者。有人说他们消耗调节器提供的电源。大多数调节器可以启用和禁用其输出，有些还可以控制其输出电压或电流。驱动程序应通过特定的函数和数据结构向消费者公开这些功能，我们将在本章讨论。
- en: 'The chip that physically provides regulators is called a **Power Management
    Integrated Circuit** (**PMIC** ):'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 物理提供调节器的芯片称为**电源管理集成电路**（**PMIC**）：
- en: '![](img/Image00042.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00042.jpg)'
- en: 'The Linux regulator framework has been designed to interface and control voltage
    and current regulators. It is divided into four separate interfaces as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Linux调节器框架已经被设计用于接口和控制电压和电流调节器。它分为四个独立的接口，如下所示：
- en: A regulator drivers interface for regulator PMIC drivers. The structure of this
    interface can be found in `include/linux/regulator/driver.h` .
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调节器驱动程序接口用于调节器PMIC驱动程序。此接口的结构可以在`include/linux/regulator/driver.h`中找到。
- en: A consumer interface for device drivers.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备驱动程序的消费者接口。
- en: A machine interface for board configuration.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于板配置的机器接口。
- en: A sysfs interface for user space.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户空间的sysfs接口。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing the PMIC/producer driver interface, driver methods and data structures
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍PMIC/生产者驱动程序接口、驱动程序方法和数据结构
- en: A case study with ISL6271A MIC driver, as well as a dummy regulator for testing
    purpose
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISL6271A MIC驱动程序的案例研究，以及用于测试目的的虚拟调节器
- en: A regulator consumer interface along with its API
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调节器消费者接口及其API
- en: Regulator (producer/consumer) binding in DT
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DT中的调节器（生产者/消费者）绑定
- en: PMIC/producer driver interface
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PMIC/生产者驱动程序接口
- en: The producer is the device generating the regulated voltage or current. The
    name of such a device is PMIC and it can be used for power sequencing, battery
    management, DC-to-DC conversion, or simple power switches (on/off). It regulates
    the output power from the input power, with the help of (and under) software control.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者是产生调节电压或电流的设备。这种设备的名称是PMIC，它可以用于电源排序、电池管理、DC-DC转换或简单的电源开关（开/关）。它通过软件控制调节输入电源的输出功率。
- en: 'It deals with regulator drivers, and especially the producer PMIC side, which
    requires a few headers:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它涉及调节器驱动程序，特别是生产者PMIC方面，需要一些头文件：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Driver data structures
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动程序数据结构
- en: We will start with a short walkthrough of data structures used by the regulator
    framework. Only the producer interface is described in this section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从调节器框架使用的数据结构的简短介绍开始。本节仅描述了生产者接口。
- en: Description structure
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述结构
- en: 'The kernel describes every regulator provided by a PMIC by means of a `struct
    regulator_desc` structure, which characterizes a regulator. By regulator, I mean
    any independent regulated output. For example, the ISL6271A from Intersil is a
    PMIC with three independent regulated outputs. There should then be three instances
    of `regulator_desc` in its driver. This structure, which contains the fixed properties
    of a regulator, looks like the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 内核通过`struct regulator_desc`结构描述了PMIC提供的每个调节器，该结构表征了调节器。通过调节器，我指的是任何独立的调节输出。例如，来自Intersil的ISL6271A是一个具有三个独立调节输出的PMIC。然后，其驱动程序中应该有三个`regulator_desc`的实例。这个结构包含调节器的固定属性，看起来像下面这样：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let us omit some fields for simplicity reasons. Full structure definition is
    available in `include/linux/regulator/driver.h` :'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 出于简单起见，我们将省略一些字段。完整的结构定义可以在`include/linux/regulator/driver.h`中找到：
- en: '`name` holds the name of the regulator.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`保存调节器的名称。'
- en: '`of_match` holds the name used to identify the regulator in DT.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of_match`保存了在DT中用于识别调节器的名称。'
- en: '`id` is a numerical identifier for the regulator.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`是调节器的数字标识符。'
- en: '`owner` represents the module providing the regulator. Set this field to `THIS_MODULE`
    .'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`owner`表示提供调节器的模块。将此字段设置为`THIS_MODULE`。'
- en: '`type` indicates if the regulator is a voltage regulator or a current regulator.
    It can either be `REGULATOR_VOLTAGE` or `REGULATOR_CURRENT` . Any other value
    will result in a regulator registering failure.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`指示调节器是电压调节器还是电流调节器。它可以是`REGULATOR_VOLTAGE`或`REGULATOR_CURRENT`。任何其他值都将导致调节器注册失败。'
- en: '`n_voltages` indicates the number of selectors available for this regulator.
    It represents the numerical value that the regulator can output. For fixed output
    voltage, `n_voltages` should be set to 1.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n_voltages`表示此调节器可用的选择器数量。它代表调节器可以输出的数值。对于固定输出电压，`n_voltages`应设置为1。'
- en: '`min_uV` indicates the minimum voltage value this regulator can provide. It
    is the voltage given by the lowest selector.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min_uV`表示此调节器可以提供的最小电压值。这是由最低选择器给出的电压。'
- en: '`uV_step` represents the voltage increase with each selector.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uV_step`表示每个选择器的电压增加。'
- en: '`ops` represents the regulator operations table. It is a structure pointing
    to a set of operation callbacks that the regulator can support. This field is
    discussed later.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ops`表示调节器操作表。它是一个指向调节器可以支持的一组操作回调的结构。此字段稍后会讨论。'
- en: '`irq` is the interrupt number of the regulator.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq`是调节器的中断号。'
- en: Constraints structure
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约束结构
- en: 'When a PMIC exposes a regulator to consumers, it has to impose some nominal
    limits for this regulator with the help of the `struct regulation_constraints`
    structure. It is a structure gathering security limit of the regulator and defines
    boundaries the consumers cannot cross. It is a kind of a contract between the
    regulator driver and the consumer driver:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当PMIC向消费者公开调节器时，它必须借助`struct regulation_constraints`结构为此调节器强加一些名义上的限制。这是一个收集调节器的安全限制并定义消费者不能越过的边界的结构。这是调节器驱动程序和消费者驱动程序之间的一种合同：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let us describe each element in the structure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述结构中的每个元素：
- en: '`min_uV` , `min_uA` , `max_uA` , and `max_uV` are the smallest voltage/current
    values that the consumers may set.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min_uV`，`min_uA`，`max_uA`和`max_uV`是消费者可以设置的最小电压/电流值。'
- en: '`uV_offset` is the offset applied to voltages from the consumer to compensate
    for voltage drops.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uV_offset` 是应用于消费者电压的补偿电压偏移量。'
- en: '`valid_modes_mask` and `valid_ops_mask` respectively are masks of modes/operations
    which may be configured/performed by consumers.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`valid_modes_mask`和`valid_ops_mask`分别是可以由消费者配置/执行的模式/操作的掩码。'
- en: '`always_on` should be set if the regulator should never be disabled.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果寄存器永远不应该被禁用，则应设置`always_on`。
- en: '`boot_on` should be set if the regulator is enabled when the system is initially
    started. If the regulator is not enabled by the hardware or bootloader then it
    will be enabled when the constraints are applied.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果寄存器在系统初始启动时已启用，则应设置`boot_on`。如果寄存器不是由硬件或引导加载程序启用的，则在应用约束时将启用它。
- en: '`name` is a descriptive name for the constraints used for display purposes.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`是用于显示目的的约束的描述性名称。'
- en: '`apply_uV` applies the voltage constraint when initializing.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply_uV`在初始化时应用电压约束。'
- en: '`input_uV` represents the input voltage for this regulator when it is supplied
    by another regulator.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`input_uV`表示由另一个寄存器供电时该寄存器的输入电压。'
- en: '`state_disk` , `state_mem` , and `state_standby` define the state for the regulator
    when the system is suspended in the disk mode, mem mode, or in standby.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state_disk`，`state_mem` 和 `state_standby` 定义了系统在磁盘模式、内存模式或待机模式下挂起时的寄存器状态。'
- en: '`initial_state` indicates the suspended state is set by default.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_state` 表示默认设置为挂起状态。'
- en: '`initial_mode` is the mode to set at startup.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initial_mode`是启动时设置的模式。'
- en: init data structure
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化数据结构
- en: 'There are two ways to pass `regulator_init_data` to a driver; this can be done
    by platform data in the board initialization file or by a node in the device tree
    using the `of_get_regulator_init_data` function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以将`regulator_init_data`传递给驱动程序；这可以通过板初始化文件中的平台数据完成，也可以通过设备树中的节点使用`of_get_regulator_init_data`函数完成：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following are the meanings of elements in the structure:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结构中各元素的含义：
- en: '`constraints` represents the regulator constraints'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constraints`表示寄存器约束'
- en: '`regulator_init` is an optional callback invoked at a given moment when the
    core registers the regulator'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regulator_init`是在核心注册寄存器时调用的可选回调'
- en: '`driver_data` represents the data passed to `regulator_init`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver_data`表示传递给`regulator_init`的数据'
- en: As one can see, the `struct constraints` structure is part of the `init data`
    . This is explained by the fact that at the initialization of the regulator, its
    constraint is directly applied to it, far before any consumer can use it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如大家所看到的，`struct constraints`结构是`init data`的一部分。这是因为在初始化寄存器时，其约束直接应用于它，远在任何消费者使用之前。
- en: Feeding init data into a board file
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将初始化数据输入到板文件中
- en: 'This method consists of filling an array of constraints, either from within
    the driver, or in the board file, and using it as part of the platform data. The
    following is the sample based on the device from the case study, the ISL6271A
    from Intersil:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法包括填充约束数组，可以从驱动程序内部或板文件中进行，并将其用作平台数据的一部分。以下是基于案例研究中的设备ISL6271A from Intersil的示例：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This method is now depreciated, though it is presented here for your information.
    The new and recommended approach is the DT, which is described in the next section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此方法现在已被弃用，但这里仍介绍了它供您参考。新的推荐方法是DT，将在下一节中介绍。
- en: Feeding init data into the DT
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将初始化数据输入DT
- en: 'In order to extract init data passed from within the DT, there is a new data
    type that we need to introduce, `struct of_regulator_match` , which looks like
    this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从DT中提取传递的初始化数据，我们需要引入一个新的数据类型`struct of_regulator_match`，它看起来像这样：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Prior to making any use of this data structure, we need to figure out how to
    achieve the regulator binding of a DT file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此数据结构之前，我们需要弄清楚如何实现DT文件的寄存器绑定。
- en: Every PMIC node in the DT should have a sub-node named `regulators` , in which
    we have to declare each of the regulators this PMIC provides as a dedicated sub-node.
    In other words, every regulator of a PMIC is defined as a sub-node of the `regulators`
    node, which in turn is a child of the PMIC node in the DT.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: DT中的每个PMIC节点都应该有一个名为`regulators`的子节点，在其中我们必须声明此PMIC提供的每个寄存器作为专用子节点。换句话说，每个PMIC的寄存器都被定义为`regulators`节点的子节点，而`regulators`节点又是DT中PMIC节点的子节点。
- en: 'There are standardized properties you can define in a regulator node:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在寄存器节点中，您可以定义标准化的属性：
- en: '`regulator-name` : This is a string used as a descriptive name for regulator
    outputs'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regulator-name`：这是用作寄存器输出的描述性名称的字符串'
- en: '`regulator-min-microvolt` : This is the smallest voltage that consumers may
    set'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regulator-min-microvolt`：这是消费者可以设置的最小电压'
- en: '`regulator-max-microvolt` : This is the largest voltage consumers may set'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regulator-max-microvolt`：这是消费者可以设置的最大电压'
- en: '`regulator-microvolt-offset` : This is the offset applied to voltages to compensate
    for voltage drops'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regulator-microvolt-offset`：这是应用于电压以补偿电压下降的偏移量'
- en: '`regulator-min-microamp` : This is the smallest current consumers may set'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regulator-min-microamp`：这是消费者可以设置的最小电流'
- en: '`regulator-max-microamp` : This is the largest current consumers may set'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regulator-max-microamp`：这是消费者可以设置的最大电流'
- en: '`regulator-always-on` : This is a Boolean value, indicated if the regulator
    should never be disabled'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regulator-always-on`：这是一个布尔值，指示寄存器是否永远不应该被禁用'
- en: '`regulator-boot-on` : This is a bootloader/firmware enabled regulator'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regulator-boot-on`：这是一个由引导加载程序/固件启用的寄存器'
- en: '`<name>-supply` : This is a phandle to the parent supply/regulator node'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<name>-supply`：这是父供电/寄存器节点的phandle'
- en: '`regulator-ramp-delay` : This is the ramp delay for the regulator (in uV/uS)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regulator-ramp-delay`：这是寄存器的斜坡延迟（以uV/uS为单位）'
- en: 'Those properties really look like fields in `struct regulator_init_data` .
    Back with the `ISL6271A` driver, its DT entry could look like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性看起来真的像是`struct regulator_init_data`中的字段。回到`ISL6271A`驱动程序，其DT条目可能如下所示：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using the kernel helper function `of_regulator_match()` , given the `regulators`
    sub-node as the parameter, the function will walk through each regulator device
    node and build a `struct init_data` structure for each of them. There is an example
    in the `probe()` function, discussed in the driver methods section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内核辅助函数`of_regulator_match()`，给定`regulators`子节点作为参数，该函数将遍历每个调节器设备节点，并为每个构建一个`struct
    init_data`结构。在驱动程序方法部分讨论的`probe()`函数中有一个示例。
- en: Configuration structure
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置结构
- en: 'Regulator devices are configured by means of the `struct regulator_config`
    structure, which holds variable elements of the regulator description. This structure
    is passed to the framework when it comes to registering a regulator with the core:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 调节器设备通过`struct regulator_config`结构进行配置，该结构保存调节器描述的可变元素。在向核心注册调节器时，将传递此结构：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`dev` represents the struct device structure the regulator belongs to.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`代表调节器所属的设备结构。'
- en: '`init_data` is the most important field of the structure, since it contains
    an element holding the regulator constraints (a machine specific structure).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init_data`是结构的最重要字段，因为它包含一个包含调节器约束（机器特定结构）的元素。'
- en: '`driver_data` holds the regulator''s private data.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver_data`保存调节器的私有数据。'
- en: '`of_node` is for DT capable drivers. It is the node to parse for DT bindings.
    It is up to the developer to set this field. It may be `NULL` also.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of_node` 用于支持DT的驱动程序。这是要解析DT绑定的节点。开发人员负责设置此字段。它也可以是`NULL`。'
- en: Device operation structure
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备操作结构
- en: 'The `struct regulator_ops` structure is a list of callbacks representing all
    operations a regulator can perform. These callbacks are helpers and are wrapped
    by generic kernel functions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct regulator_ops`结构是一个回调列表，表示调节器可以执行的所有操作。这些回调是辅助函数，并由通用内核函数包装：'
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Callback names explain quite well what they do. There are other callbacks that
    are not listed here, for which you must enable the appropriate mask in `valid_ops_mask`
    or `valid_modes_mask` of the regulator's constraints before the consumer can use
    them. Available operation mask flags are defined in `include/linux/regulator/machine.h`
    .
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 回调名称很好地解释了它们的作用。这里没有列出的其他回调，您必须在消费者使用它们之前在调节器的约束中启用适当的掩码`valid_ops_mask`或`valid_modes_mask`。可用的操作掩码标志在`include/linux/regulator/machine.h`中定义。
- en: 'Therefore, given a `struct regulator_dev` structure, one can get the ID of
    the corresponding regulator by calling the `rdev_get_id()` function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，给定一个`struct regulator_dev`结构，可以通过调用`rdev_get_id()`函数获取相应调节器的ID：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Driver methods
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动程序方法
- en: Driver methods consist of `probe()` and `remove()` functions. Please refer to
    the preceding data structure if this section seems unclear to you.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序方法包括`probe()`和`remove()`函数。如果此部分对您不清楚，请参考前面的数据结构。
- en: Probe function
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探测功能
- en: 'The `probe` function of a PMIC driver can be split into a few steps, enumerated
    as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: PMIC驱动程序的`probe`功能可以分为几个步骤，列举如下：
- en: Define an array of `struct regulator_desc` objects for all the regulators provided
    by this PMIC. In this step, you should have defined a valid `struct regulator_ops`
    to be linked to the appropriate `regulator_desc` . It could be the same `regulator_ops`
    for all, assuming they all support the same operations.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此PMIC提供的所有调节器定义一个`struct regulator_desc`对象数组。在此步骤中，您应该已经定义了一个有效的`struct regulator_ops`，以链接到适当的`regulator_desc`。假设它们都支持相同的操作，可以对所有调节器使用相同的`regulator_ops`。
- en: 'Now in the `probe` function, for each regulator:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`probe`函数中，对于每个调节器：
- en: Fetch the appropriate `struct regulator_init_data` either from the platform
    data, which must already contain a valid `struct regulation_constraints` or build
    a `struct regulation_constraints` from DT, in order to build a new `struct regulator_init_data`
    object.
  id: totrans-99
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从平台数据中获取适当的`struct regulator_init_data`，该数据必须已包含有效的`struct regulation_constraints`，或者从DT构建一个`struct
    regulation_constraints`，以构建一个新的`struct regulator_init_data`对象。
- en: Use the previous `struct regulator_init_data` to set up a `struct regulator_config`
    structure. If the driver supports DT, one can make `regulator_config.of_node`
    point to the node used to extract the regulator properties.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用先前的`struct regulator_init_data`来设置`struct regulator_config`结构。如果驱动程序支持DT，可以使`regulator_config.of_node`指向用于提取调节器属性的节点。
- en: Call `regulator_register()` (or the managed version `devm_regulator_register()`
    ) to register the regulator with the core, giving the previous `regulator_desc`
    and `regulator_config` as parameters.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`regulator_register()`（或托管版本的`devm_regulator_register()`）来使用先前的`regulator_desc`和`regulator_config`作为参数向核心注册调节器。
- en: 'A regulator is registered with the kernel using the `regulator_register()`
    function, or `devm_regulator_register()` , which is the managed version:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`regulator_register()`函数或`devm_regulator_register()`，将调节器注册到内核中：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This function returns a data type we have not discussed so far: a `struct regulator_dev`
    object, defined in `include/linux/regulator/driver.h.` That structure represents
    an instance of a regulator device from the producer side (it is different in the
    consumer side). Instances of the `struct regulator_dev` structure should not be
    used directly by anything except the regulator core and notification injection
    (which should take the mutex and not other direct access). That being said, to
    keep track of the registered regulator from within the driver, one should hold
    references for each `regulator_dev` object returned by the registering function.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数返回一个我们到目前为止尚未讨论的数据类型：`struct regulator_dev`对象，定义在`include/linux/regulator/driver.h`中。该结构表示来自生产方的调节器设备的实例（在消费方方面不同）。`struct
    regulator_dev`结构的实例不应直接被任何东西使用，除了调节器核心和通知注入（应该获取互斥锁，而不是其他直接访问）。也就是说，为了跟踪驱动程序内部注册的调节器，应该为注册函数返回的每个`regulator_dev`对象保留引用。
- en: Remove function
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除功能
- en: 'The `remove()` function is where every operation performed earlier during the
    `probe` . Therefore, the essential function you should keep in mind is `regulator_unregister()`
    , when it comes to removing a regulator from the system:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()`函数是在`probe`期间执行的每个操作的地方。因此，你应该牢记的关键函数是`regulator_unregister()`，当需要从系统中移除调节器时：'
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This function accepts a pointer to a `struct regulator_dev` structure as a
    parameter. This is another reason a reference for each registered regulator should
    be kept. The following is the `remove` function of the ISL6271A driver:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个`struct regulator_dev`结构的指针作为参数。这也是为每个注册的调节器保留引用的另一个原因。以下是ISL6271A驱动程序的`remove`函数：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Case study: Intersil ISL6271A voltage regulator'
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究：Intersil ISL6271A电压调节器
- en: 'As a recall, this PMIC provides three regulator''s devices, among which only
    one can have its output value changed. The two others provide fixed voltages:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，这个PMIC提供了三个调节器设备，其中只有一个可以改变其输出值。另外两个提供固定电压：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'First we define ops callbacks, to set up a `struct regulator_desc` :'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们定义ops回调函数，来设置`struct regulator_desc`：
- en: 'Callback to handle a `get_voltage_sel` operation:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理`get_voltage_sel`操作的回调函数：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following is the callback to handle a `set_voltage_sel` operation:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是处理`set_voltage_sel`操作的回调函数：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Since we are done with the callback definition, we can build a `struct regulator_ops`
    :'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们已经完成了回调函数的定义，我们可以构建一个`struct regulator_ops`：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can ask yourself where the `regulator_list_voltage_linear` and `regulator_list_voltage_linear`
    functions come from. As with many other regulator helper functions, they are also
    defined in `drivers/regulator/helpers.c` . The kernel provides helper functions
    for linear output regulators, as is the case for the ISL6271A.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问`regulator_list_voltage_linear`和`regulator_list_voltage_linear`函数是从哪里来的。和许多其他调节器辅助函数一样，它们也在`drivers/regulator/helpers.c`中定义。内核为线性输出调节器提供了辅助函数，就像ISL6271A一样。
- en: 'It is time to build an array of `struct regulator_desc` for all regulators:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为所有调节器构建一个`struct regulator_desc`数组了：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`LDO1` and `LDO2` have a fixed output voltage. It is why their `n_voltages`
    properties are set to 1, and their ops only provide `regulator_list_voltage_linear`
    mapping.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`LDO1`和`LDO2`具有固定的输出电压。这就是为什么它们的`n_voltages`属性被设置为1，它们的ops只提供`regulator_list_voltage_linear`映射。'
- en: 'Now we are in the `probe` function, the place where we need to build our `struct
    init_data` structures. If you remember, we will use the `struct of_regulator_match`
    introduced previously. We should declare an array of that type, in which we should
    set the `.name` property of each regulator, for which we need to fetch `init_data`
    :'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在`probe`函数中，这是我们需要构建`struct init_data`结构的地方。如果你记得，我们将使用之前介绍的`struct of_regulator_match`。我们应该声明一个该类型的数组，在其中我们应该设置每个需要获取`init_data`的调节器的`.name`属性：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Looking a bit closer, you will notice that the `.name` property is set with
    exactly the same value as the label of the regulator in the device tree. This
    is a rule you should care about and respect.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看，你会注意到`.name`属性的设置与设备树中调节器的标签完全相同。这是你应该关心和尊重的规则。
- en: 'Now let us look at the probe function. The ISL6271A provides three regulator
    outputs, which means that the `regulator_register()` function should be called
    three times:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下`probe`函数。ISL6271A提供三个调节器输出，这意味着应该调用`regulator_register()`函数三次：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`init_data` can be `NULL` for a fixed regulator. It means that for the ISL6271A,
    only the regulator whose voltage output may change may be assigned an `init_data`
    .'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于固定调节器，`init_data`可以是`NULL`。这意味着对于ISL6271A，只有可能改变电压输出的调节器可以被分配一个`init_data`。
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding driver does not fill every field of the `struct regulator_desc`
    . It greatly depends on the type of device for which we write a driver. Some drivers
    leave the whole job to the regulator core, and only provide the chip's register
    address, which the regulator core needs to work with. Such drivers use **regmap**
    API, which is a generic I2C and SPI register map library. `drivers/regulator/max8649.c`
    is an example.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的驱动程序并没有填充`struct regulator_desc`的每个字段。这在很大程度上取决于我们为其编写驱动程序的设备类型。一些驱动程序将整个工作交给了调节器核心，只提供了调节器核心需要处理的芯片寄存器地址。这样的驱动程序使用**regmap**
    API，这是一个通用的I2C和SPI寄存器映射库。`drivers/regulator/max8649.c`就是一个例子。
- en: Driver example
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动程序示例
- en: 'Let''s summarize things discussed previously in a real driver, for a dummy
    PMIC with two regulators, where the first one has a voltage range of 850000 µV
    to 1600000 µV with a step of 50000 µV, and the second regulator has a fixed voltage
    of 1300000 µV:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下之前讨论的内容，对于一个带有两个调节器的虚拟PMIC的真实驱动程序，其中第一个调节器的电压范围为850000 µV到1600000 µV，步进为50000
    µV，而第二个调节器的电压固定为1300000 µV：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once the module is loaded and the device matched, the kernel will print something
    like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模块加载并且设备匹配，内核将打印类似于这样的内容：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'One can then check what happened under the hood:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以检查底层发生了什么：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`regulator.13` and `regulator.14` have been added by our driver. Let us now
    check their properties:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`regulator.13`和`regulator.14`已经被我们的驱动程序添加。现在让我们检查它们的属性：'
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Regulators consumer interface
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调节器消费者接口
- en: 'The consumer interface only requires the driver to include one header:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者接口只需要驱动程序包含一个头文件：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A consumer can be static or dynamic. A static one requires only a fixed supply,
    whereas a dynamic one requires active management of the regulator at runtime.
    From the consumer point side, a regulator device is represented in the kernel
    as an instance of a `struct regulator` structure, defined in `drivers/regulator/internal.h`
    and shown as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者可以是静态的或动态的。静态消费者只需要一个固定的供应，而动态消费者需要在运行时主动管理调节器。从消费者的角度来看，调节器设备在内核中表示为`drivers/regulator/internal.h`中定义的`struct
    regulator`结构的实例，如下所示：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This structure is meaningful enough and does not need us to add any comments.
    To see how easy it is to consume a regulator, here is a little example of how
    a consumer acquires a regulator:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构已经足够有意义，不需要我们添加任何注释。为了看到消费者如何轻松地使用调节器，这里有一个消费者获取调节器的小例子：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Regulator device requesting
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调节器设备请求
- en: 'Prior to gaining access to a regulator, the consumer has to request the kernel
    by means of the `regulator_get()` function. It is also possible to use the managed
    version, the `devm_regulator_get()` function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得对调节器的访问之前，消费者必须通过`regulator_get()`函数向内核请求。也可以使用托管版本，即`devm_regulator_get()`函数：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'An example of using this function is:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数的一个例子是：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The consumer passes in its `struct device` pointer and power supply ID. The
    core will try to find the correct regulator by consulting the DT or a machine-specific
    lookup table. If we focus only on the device tree, `*id` should match the `<name>`
    pattern of the regulator supply in the device tree. If the lookup is successful
    then this call will return a pointer to the `struct regulator` that supplies this
    consumer.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者传递它的`struct device`指针和电源供应ID。内核将尝试通过查阅DT或特定于机器的查找表来找到正确的调节器。如果我们只关注设备树，`*id`应该与设备树中调节器供应的`<name>`模式匹配。如果查找成功，那么此调用将返回一个指向为此消费者提供电源的`struct
    regulator`的指针。
- en: 'To release the regulator, the consumer driver should call:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要释放调节器，消费者驱动程序应调用：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Prior to calling this function, the driver should ensure that all `regulator_enable()`
    calls made on this regulator source are balanced by `regulator_disable()` calls.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用此函数之前，驱动程序应确保对此调节器源进行的所有`regulator_enable()`调用都由`regulator_disable()`调用平衡。
- en: 'More than one regulator can supply a consumer, for example, codec consumers
    with analog and digital supplies:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个消费者可以由多个调节器供应，例如，带有模拟和数字供应的编解码器消费者：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Consumer `probe()` and `remove()` functions are an appropriate place to grab
    and release regulators.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者的`probe()`和`remove()`函数是抓取和释放调节器的适当位置。
- en: Controlling the regulator device
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制调节器设备
- en: Regulator control consists of enabling, disabling, and setting output values
    for a regulator.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 调节器控制包括启用、禁用和设置调节器的输出值。
- en: Regulator output enable and disable
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调节器输出启用和禁用
- en: 'A consumer can enable its power supply by calling the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者可以通过调用以下方式启用其电源：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This function returns 0 on success. The reverse operation consists of disabling
    the power supply, by calling this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数成功返回0。相反的操作是通过调用此函数来禁用电源：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To check whether a regulator is already enabled or not, the consumer should
    call this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查调节器是否已启用，消费者应调用此函数：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This function returns a value greater than 0 if the regulator is enabled. Since
    the regulator may be enabled early by the bootloader or shared with another consumer,
    one can use the `regulator_is_enabled()` function to check the regulator state.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调节器已启用，则此函数返回大于0的值。由于调节器可能会被引导加载程序提前启用或与其他消费者共享，因此可以使用`regulator_is_enabled()`函数来检查调节器状态。
- en: Here is an example,
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For a shared regulator, `regulator_disable()` will actually disable the regulator
    only when the enabled reference count is zero. That said, you can force disabling
    in case of an emergency, for example, by calling `regulator_force_disable()` :'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于共享的调节器，`regulator_disable()`只有在启用的引用计数为零时才会真正禁用调节器。也就是说，在紧急情况下，例如通过调用`regulator_force_disable()`可以强制禁用：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Each of the functions that we will discuss in the sections that follows is actually
    a wrapper around a `regulator_ops` operation. For example, `regulator_set_voltage()`
    internally calls `regulator_ops.set_voltage` after checking the corresponding
    mask allowing this operation is set, and so on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中讨论的每个函数实际上都是围绕着`regulator_ops`操作的一个包装器。例如，`regulator_set_voltage()`在检查相应的掩码允许此操作设置后，内部调用`regulator_ops.set_voltage`，依此类推。
- en: Voltage control and status
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电压控制和状态
- en: 'For consumers that need to adapt their power supplies according to their operating
    modes, the kernel provides this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要根据其操作模式调整其电源的消费者，内核提供了这个：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`min_uV` and `max_uV` are the minimum and maximum acceptable voltages in microvolts.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`min_uV`和`max_uV`是微伏的最小和最大可接受电压。'
- en: 'If called when the regulator is disabled, this function will change the voltage
    configuration so that the voltage is physically set when the regulator is next
    enabled. That said, consumers can get the regulator configured voltage output
    by calling `regulator_get_voltage()` , which will return the configured output
    voltage whether the regulator is enabled or not:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调节器禁用时调用此函数，它将更改电压配置，以便在下次启用调节器时物理设置电压。也就是说，消费者可以通过调用`regulator_get_voltage()`来获取调节器配置的电压输出，无论调节器是否启用：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here is an example,
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Current limit control and status
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电流限制控制和状态
- en: What we have discussed in the voltage section also applies here. For example,
    USB drivers may want to set the limit to 500 mA when supplying power.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在电压部分讨论的内容在这里也适用。例如，USB驱动程序可能希望在供电时将限制设置为500毫安。
- en: 'Consumers can control their supply current limit by calling:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者可以通过调用以下方式控制其供应电流限制：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`min_uA` and `max_uA` are the minimum and maximum acceptable current limits
    in microamps.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`min_uA`和`max_uA`是微安的最小和最大可接受电流限制。'
- en: 'In the same way, consumers can get the regulator configured to the current
    limit by calling `regulator_get_current_limit()` , which will return the current
    limit whether the regulator is enabled or not:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，消费者可以通过调用`regulator_get_current_limit()`来获取调节器配置的电流限制，无论调节器是否启用：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Operating mode control and status
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作模式控制和状态
- en: 'For efficient power management, some consumers may change the operating mode
    of their supply when their (consumers) operating state changes. Consumer drivers
    can request a change in their supply regulator operating mode by calling:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效的电源管理，一些消费者可能会在他们的操作状态改变时改变他们供应的工作模式。消费者驱动程序可以通过调用以下方式请求改变他们的供应调节器工作模式：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Consumers should use `regulator_set_mode()` on a regulator only when it knows
    about the regulator and does not share the regulator with other consumers. This
    is known as **direct mode** . `regulator_set_uptimum_mode()` causes the core to
    undertake some background work in order to determine what operating mode is best
    for the requested current. This is called the **indirect mode** .
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者应仅在了解调节器并且不与其他消费者共享调节器时，才能在调节器上使用`regulator_set_mode（）`。这被称为**直接模式**。`regulator_set_uptimum_mode（）`会导致核心进行一些后台工作，以确定请求电流的最佳操作模式。这被称为**间接模式**。
- en: Regulator binding
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调节器绑定
- en: This section only deals with consumer interface binding. Because PMIC binding
    consists of providing `init data` for regulators that this PMIC provides, you
    should refer to the section *Feeding init data into the DT* to understand producer
    binding.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本节仅涉及消费者接口绑定。因为PMIC绑定包括为该PMIC提供的调节器提供`init data`，所以您应该参考*将init data输入DT*部分以了解生产者绑定。
- en: 'Consumer nodes can reference one or more of its supplies/regulators using the
    following bindings:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者节点可以使用以下绑定引用其一个或多个供应/调节器：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It is the same principle as PWM consumer binding. `<name>` should be meaningful
    enough, so that the driver can easily refer to it when requesting the regulator.
    That said, `<name>` must match the `*id` parameter of the `regulator_get()` function:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这与PWM消费者绑定的原理相同。 `<name>` 应该有足够的意义，以便驱动程序在请求调节器时可以轻松地引用它。也就是说，`<name>` 必须与`regulator_get（）`函数的`*id`参数匹配：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The consumer code (which is the MMC driver) that actually requests its supplies
    could look like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者代码（即MMC驱动程序）实际请求其供应可能如下所示：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With the wide range of devices that need to be smartly and smoothly supplied,
    this chapter can be relied on to take care of their power supply management. PMIC
    devices usually sit on SPI or I2C buses. Having already dealt with these buses
    in previous chapters, you should be able to write any PMIC driver. Let's now jump
    to the next chapter, which deals with framebuffer drivers, which is a completely
    different and no less interesting topic.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要智能和平稳供电的各种设备，可以依靠本章来处理它们的电源管理。 PMIC设备通常位于SPI或I2C总线上。在之前的章节中已经处理过这些总线，因此您应该能够编写任何PMIC驱动程序。现在让我们跳到下一章，该章涉及帧缓冲驱动程序，这是一个完全不同但同样有趣的主题。
