- en: Encrypting and SSH Hardening
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密和SSH加固
- en: You may work for a super-secret government agency, or you may be just a regular
    Joe or Jane citizen. Either way, you will still have sensitive data that you need
    to protect from prying eyes. Business secrets, government secrets, personal secrets—it
    doesn't matter; it all needs protection. Locking down user's home directories
    with restrictive permissions settings, as we saw in [Chapter 2](bbe819e7-1d8f-414c-8de7-eab84959a9e6.xhtml), *Securing
    User Accounts*, is only part of the puzzle; we also need encryption.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能在一个超级秘密的政府机构工作，也可能只是一个普通的公民。 无论如何，您仍然有需要保护免受窥视的敏感数据。 商业机密、政府机密、个人机密——都需要保护。
    像我们在[第2章](bbe819e7-1d8f-414c-8de7-eab84959a9e6.xhtml)中看到的那样，通过限制权限设置来锁定用户的主目录只是问题的一部分；
    我们还需要加密。
- en: The two general types of data encryption that we'll look at in this chapter
    are meant to protect *data at rest* and *data in transit*. We'll begin with using
    file, partition, and directory encryption to protect data at rest. We'll then
    cover **Secure Shell** (**SSH**) to protect data in transit.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中查看的两种数据加密的一般类型旨在保护*静止数据*和*传输数据*。 我们将首先使用文件、分区和目录加密来保护静止数据。 然后，我们将介绍**安全外壳**（**SSH**）以保护传输数据。
- en: 'In this chapter, we''ll cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: '**GNU Privacy Guard** (**GPG**)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GNU隐私保护**（**GPG**）'
- en: Encrypting partitions with **Linux Unified Key Setup** (**LUKS**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Linux统一密钥设置**（**LUKS**）加密分区
- en: Encrypting directories with eCryptfs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用eCryptfs加密目录
- en: Using VeraCrypt for the cross-platform sharing of encrypted containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用VeraCrypt跨平台共享加密容器
- en: Ensuring that SSH protocol 1 is disabled
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保SSH协议1已禁用
- en: Creating and managing keys for password-less logins
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和管理无密码登录的密钥
- en: Disabling root user login
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用root用户登录
- en: Disabling username/password logins
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用用户名/密码登录
- en: Setting up a chroot environment for SFTP users
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为SFTP用户设置chroot环境
- en: GNU Privacy Guard
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GNU隐私保护
- en: We'll begin with **GNU Privacy Guard** (**GPG**). This is a free open source
    implementation of Phil Zimmermann's *Pretty Good Privacy*, which he created back
    in 1991\. You can use either one of them to either encrypt or cryptographically
    sign files or messages. In this section, we'll focus strictly on GPG.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从**GNU隐私保护**（**GPG**）开始。 这是Phil Zimmermann于1991年创建的*Pretty Good Privacy*的免费开源实现。
    您可以使用其中任何一个来加密或加密签名文件或消息。 在本节中，我们将严格关注GPG。
- en: 'There are some advantages of using GPG:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GPG有一些优势：
- en: It uses strong, hard-to-crack encryption algorithms.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用强大、难以破解的加密算法。
- en: It uses the private/public key scheme, which eliminates the need to transfer
    a password to a message or file recipient in a secure manner. Instead, just send
    along your public key, which is useless to anyone other than the intended recipient.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用私钥/公钥方案，消除了以安全方式将密码传输给消息或文件接收者的需要。 相反，只需发送您的公钥，对于除预期接收者之外的任何人都是无用的。
- en: You can use GPG to just encrypt your own files for your own use, the same as
    you'd use any other encryption utility.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用GPG仅加密自己的文件以供自己使用，就像您使用任何其他加密实用程序一样。
- en: It can be used to encrypt email messages, allowing you to have true end-to-end
    encryption for sensitive emails.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可用于加密电子邮件消息，允许您对敏感电子邮件进行真正的端到端加密。
- en: There are a few GUI-type frontends available to make it somewhat easier to use.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一些图形用户界面类型的前端可用，使其使用起来更加容易。
- en: 'But, as you might know, there are also some disadvantages:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可能知道，也有一些缺点：
- en: Using public keys instead of passwords is great when you work directly only
    with people who you implicitly trust. But, for anything beyond that, such as distributing
    a public key to the general population so that everyone can verify your signed
    messages, you're dependent upon a web-of-trust model that can be very hard to
    set up.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与密码相比，使用公钥在您直接与您隐含信任的人一起工作时非常好。 但是，对于任何超出此范围的事情，例如向一般人群分发公钥以便每个人都可以验证您签名的消息，您将依赖于一个非常难以建立的信任网络模型。
- en: For the end-to-end encryption of email, the recipients of your email must also
    have GPG set up on their systems, and know how to use it. That might work in a
    corporate environment, but lots of luck getting your friends to set that up. (I've
    never once succeeded in getting someone else to set up email encryption.)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于电子邮件的端到端加密，您的电子邮件接收者也必须在其系统上设置GPG，并知道如何使用它。 这可能在企业环境中起作用，但是希望您的朋友设置这个的时候好运。（我从来没有成功过让其他人设置电子邮件加密。）
- en: If you use a standalone email client, such as Mozilla Thunderbird, you can install
    a plugin that will encrypt and decrypt messages automatically. But, every time
    a new Thunderbird update is released, the plugin breaks, and it always takes a
    while before a new working version gets released.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用独立的电子邮件客户端，例如Mozilla Thunderbird，您可以安装一个插件，该插件将自动加密和解密消息。 但是，每次发布新的Thunderbird更新时，插件都会中断，而且总是需要一段时间才能发布新的可用版本。
- en: Even with its numerous weaknesses, GPG is still one of the best ways to share
    encrypted files and emails. GPG comes preinstalled on both Ubuntu Server and CentOS.
    So, you can use either of your virtual machines for these demos.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 即使GPG有许多弱点，它仍然是共享加密文件和电子邮件的最佳方式之一。 GPG预装在Ubuntu Server和CentOS上。 因此，您可以使用任一虚拟机进行这些演示。
- en: Creating your GPG keys
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的GPG密钥
- en: 'Getting started with GPG requires you to first generate your GPG keys. You''ll
    do that with:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用GPG需要您首先生成您的GPG密钥。 您将使用以下命令完成：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that, since you're setting this up for yourself, you don't need sudo privileges.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于您为自己设置这个，您不需要sudo特权。
- en: The output of this command is too long to show all at once, so I'll show relevant
    sections of it, and break down what it means.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出太长，无法一次显示所有内容，因此我将显示其中相关部分，并解释其含义。
- en: 'The first thing that this command does is to create a populated `.gnupg` directory
    in your home directory:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的第一件事是在您的主目录中创建一个填充的`.gnupg`目录：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You''ll then be asked to select which kinds of keys you want. We''ll just go
    with the default RSA and RSA. (RSA keys are stronger and harder to crack than
    the older DSA keys. Elgamal keys are good, but they may not be supported by older
    versions of GPG.):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你将被要求选择你想要的密钥类型。我们将选择默认的RSA和RSA。（RSA密钥比较强大，比旧版DSA密钥更难破解。Elgamal密钥也不错，但可能不受GPG旧版本支持。）
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For decent encryption, you''ll want to go with a key of at least 2048 bits,
    because anything smaller is now considered vulnerable. Since 2048 just happens
    to be the default, we''ll go with it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得良好的加密，你需要选择至少2048位的密钥，因为任何更小的密钥现在都被认为是容易受到攻击的。由于2048恰好是默认值，我们将选择它：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, select how long you want for the keys to remain valid before they automatically
    expire. For our purposes, we'll go with the default `key does not expire`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择密钥在自动到期之前保持有效的时间。对于我们的目的，我们将选择默认的`密钥不会过期`。
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Provide your personal information:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 提供你的个人信息：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a passphrase for your private key:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的私钥创建一个密码：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This could take a while, even when you''re doing all of the recommended things
    to create entropy. Be patient; it will eventually finish. By running a `sudo yum
    upgrade` in another window, I created enough entropy so that the process didn''t
    take too long:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要一段时间，即使你正在做所有推荐的事情来创建熵。耐心等待，它最终会完成。通过在另一个窗口运行`sudo yum upgrade`，我创建了足够的熵，以便进程不会花费太长时间：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Verify that the keys did get created:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 验证密钥是否已创建：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And, while you''re at it, take a look at the files that you created:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还有，趁机看看你创建的文件：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These files are your public and private keyrings, your own `gpg.conf` file,
    a random seed file, and a trusted users database.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件是你的公钥和私钥环，你自己的`gpg.conf`文件，一个随机种子文件和一个受信任的用户数据库。
- en: Symmetrically encrypting your own files
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对自己的文件进行对称加密
- en: You may find GPG useful for encrypting your own files, even when you never plan
    to share them with anyone else. For this, you'll use symmetric encryption, which
    involves using your own private key for encryption. Before you try this, you'll
    need to generate your keys, as I outlined in the previous section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现GPG对加密你自己的文件很有用，即使你从不打算与其他人分享。为此，你将使用对称加密，这涉及使用你自己的私钥进行加密。在尝试之前，你需要生成你的密钥，就像我在前一节中概述的那样。
- en: Symmetric key encryption is, well, just that, symmetric. It's symmetric in the
    sense that the same key that you would use to encrypt a file is the same key that
    you would use to decrypt the file. That's great for if you're just encrypting
    files for your own use. But, if you need to share an encrypted file with someone
    else, you'll need to figure out a secure way to give that person the password.
    I mean, it's not like you'd want to just send the password in a plain-text email.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对称密钥加密就是这样，对称的。这意味着用于加密文件的密钥与用于解密文件的密钥相同。如果你只是为了自己使用而加密文件，那就很好。但是，如果你需要与其他人共享加密文件，你需要想出一个安全的方法来给那个人密码。我的意思是，你肯定不想只是在明文电子邮件中发送密码。
- en: 'Let''s encrypt a super-secret file that we just can''t allow to fall into the
    wrong hands:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加密一个绝对不能落入错误手中的超级秘密文件：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the `-c` option indicates that I chose to use symmetric encryption
    with a passphrase for the file. The passphrase that you enter will be for the
    file, not for your private key.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`-c`选项表示我选择使用对称加密为文件设置密码。你输入的密码将用于文件，而不是你的私钥。
- en: 'One slight flaw with this is that GPG makes an encrypted copy of the file,
    but it also leaves the original, unencrypted file intact:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个小缺陷是，GPG会生成文件的加密副本，但也会保留原始的未加密文件：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s get rid of that unencrypted file with `shred`. We''ll use the `-u` option
    to delete the file, and the `-z` option to overwrite the deleted file with zeros:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`shred`去掉那个未加密的文件。我们将使用`-u`选项删除文件，使用`-z`选项用零覆盖已删除的文件：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It doesn''t look like anything happened, because `shred` doesn''t give you
    any output. But, an `ls -l` will prove that the file is gone. Now, if I were to
    look at the encrypted file with `less secret_squirrel_stuff.txt.gpg`, I would
    be able to see its contents, after being asked to enter my private key passphrase:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好像什么都没发生，因为`shred`不会给出任何输出。但是，`ls -l`会证明文件已经消失了。现在，如果我用`less secret_squirrel_stuff.txt.gpg`查看加密文件，我将能够看到它的内容，之后会被要求输入我的私钥密码：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As long as my private key remains loaded into my keyring, I''ll be able to
    view my encrypted file again without having to reenter the passphrase. Now, just
    to prove to you that the file really is encrypted, I''ll create a shared directory,
    and move the file there for others to access:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我的私钥仍然加载到我的密钥环中，我就能够再次查看我的加密文件，而无需重新输入密码。现在，为了向你证明文件确实是加密的，我将创建一个共享目录，并将文件移动到那里供其他人访问：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When I go into that directory to view the file with `less`, I can still see
    its contents, without having to reenter my passphrase. But now, let''s see what
    happens when Maggie tries to view the file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我进入那个目录用`less`查看文件时，我仍然可以看到它的内容，而无需重新输入密码。但现在，让我们看看当Maggie尝试查看文件时会发生什么：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And when she hits the *Y* key to see it anyway:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当她按下*Y*键查看时：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Poor Maggie really wants to see my file, but all she can see is encrypted gibberish.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可怜的Maggie真的很想看到我的文件，但她只能看到加密的胡言乱语。
- en: What I've just demonstrated is another advantage of GPG. After entering your
    private key passphrase once, you can view any of your encrypted files without
    having to manually decrypt them, and without having to reenter your passphrase.
    With other symmetric file encryption tools, such as Bcrypt, you wouldn't be able
    to view your files without manually decrypting them first.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚刚演示的是GPG的另一个优点。输入私钥密码一次后，你就可以查看任何加密文件，而无需手动解密它们，也无需重新输入密码。对于其他对称文件加密工具，比如Bcrypt，你需要先手动解密文件才能查看它们。
- en: 'But, let''s now say that you no longer need to have this file encrypted, and
    you want to decrypt it in order to let other people see it. Just use `gpg` with
    the `-d` option:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，现在假设您不再需要加密此文件，并且希望解密它以便让其他人查看。只需使用`gpg`和`-d`选项：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `WARNING` message about the message not being integrity protected means
    that I had encrypted the file, but I never signed the file. Without a digital
    signature, someone could alter the file without me knowing about it, and I wouldn't
    be able to prove that I am the originator of the file. (Have no fear, we'll talk
    about signing files in just a bit.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 关于消息未经完整保护的`警告`消息意味着我已加密该文件，但我从未签署该文件。没有数字签名，其他人可以更改文件而我不知道，我将无法证明我是文件的发起者。（不要担心，我们马上就会讨论文件签名。）
- en: Hands-on lab – combining gpg and tar for encrypted backups
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践实验-结合gpg和tar进行加密备份
- en: 'For this lab, you''ll combine `tar` and `gpg` to create an encrypted backup
    on a simulated backup device. You can perform this lab on either one of your virtual
    machines:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，您将结合`tar`和`gpg`在模拟备份设备上创建加密备份。您可以在您的任一虚拟机上执行此实验：
- en: 'Start off by creating your GPG keys. You will do that with the following command:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过以下命令创建您的GPG密钥。
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create some dummy files in your home directory, so that you''ll have something
    to back up:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的主目录中创建一些虚拟文件，这样您就有了一些备份内容：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a backup directory at the root level of the filesystem. (In real life,
    you would have the backup directory on a separate device, but for now, this works.)
    Change ownership of the directory to your own account, and set the permissions
    so that only you can access it:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件系统的根目录创建一个备份目录。（在现实生活中，您可能会将备份目录放在一个单独的设备上，但现在，这样做也可以。）更改目录的所有权为您自己的帐户，并设置权限，以便只有您可以访问它：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create an encrypted backup file of your own home directory. Compression is
    optional, but we''ll go ahead and use `xz` for the best compression. (Note that
    you''ll need to use `sudo` for this, because the `.viminfo` directory in your
    home directory is owned by the root user.):'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建您自己主目录的加密备份文件。压缩是可选的，但我们将继续使用`xz`以获得最佳压缩效果。（请注意，您需要使用`sudo`，因为您主目录中的`.viminfo`目录归根用户所有。）：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s say that either your home directory got deleted, or that you accidentally
    deleted some important files from your own home directory. Extract and decrypt
    the original home directory within the `/backup` directory:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，假设您的主目录被删除，或者您意外删除了自己主目录中的一些重要文件。在`/backup`目录中提取并解密原始主目录：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that, by combining `tar` with `gpg`, the `-C` option of `tar` to automatically
    place your home directory back within the `/home` directory won't work. So, you'll
    either need to manually copy the extracted directory back to `/home`, or move
    the encrypted backup file to `/home` before you extract it. Also, be aware that
    when you extract an encrypted archive with `gpg`, the ownership of the files will
    change to that of whoever extracted the archive. So, this probably wouldn't be
    a good choice for backing up an entire `/home` directory with home directories
    for multiple users. Finally, since this creates one huge archive file, any type
    of corruption in the archive file could cause you to lose the entire backup.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通过将`tar`与`gpg`结合使用，`tar`的`-C`选项自动将您的主目录放回`/home`目录的操作将无法进行。因此，您需要手动将提取的目录复制回`/home`，或者在提取之前将加密备份文件移动到`/home`。此外，请注意，使用`gpg`提取加密存档时，文件的所有权将更改为提取存档的人的所有权。因此，这可能不是备份整个具有多个用户主目录的`/home`目录的一个好选择。最后，由于这将创建一个巨大的存档文件，存档文件中的任何类型的损坏都可能导致您丢失整个备份。
- en: End of Lab.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实验结束。
- en: Using private and public keys for asymmetric encryption and signing
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用非对称加密和签名的私钥和公钥
- en: Symmetric encryption is great if you're just using GPG locally for your own
    stuff, but what if you want to share an encrypted file with someone, while ensuring
    that they can decrypt it? With symmetric encryption, you'd need to find a secure
    way to transmit the passphrase for the file to the file's recipient. In doing
    so, there will always be the risk that some third party could intercept the passphrase,
    and could then get into your stuff. Here's where asymmetric encryption comes to
    the rescue. To demonstrate, I'm going to create a file, encrypt it, and send it
    to my buddy Frank to decrypt.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密对于仅在本地使用GPG处理自己的东西非常有用，但是如果您想与他人分享加密文件，并确保他们可以解密该文件怎么办？使用对称加密，您需要找到一种安全的方式将文件的密码传输给文件的接收者。这样做将始终存在第三方可能拦截密码的风险，然后可以进入您的文件。这就是非对称加密发挥作用的地方。为了演示，我将创建一个文件，对其进行加密，并将其发送给我的朋友Frank进行解密。
- en: Asymmetric encryption, is, well, asymmetric. Being asymmetric means that you
    would use one key to encrypt a file, and another key to decrypt it. You would
    keep your private key to yourself and guard it with your life, but you would share
    the public key with the whole world. The beauty of this is that you can share
    encrypted files with another person, and only that person would be able to decrypt
    them. This is all done without having to share a password with the recipient.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密是非对称的。非对称意味着您将使用一个密钥加密文件，使用另一个密钥解密文件。您将保留私钥，并将其视为生命，但您将与全世界分享公钥。这样做的美妙之处在于，您可以与另一个人分享加密文件，只有该人才能解密。这一切都可以在不必与接收者分享密码的情况下完成。
- en: 'To begin, both Frank and I have to create a key set, as we''ve already shown
    you. Next, each of us needs to extract our public keys, and send them to each
    other. We''ll extract the key into an ASCII text file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我和Frank都必须创建一个密钥集，就像我们已经向您展示的那样。接下来，我们每个人都需要提取我们的公钥，并将它们发送给彼此。我们将把密钥提取到一个ASCII文本文件中：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Normally, the participants in this would either send their keys to each other
    through an email attachment, or by placing the keys in a shared directory. In
    this case, Frank and I will receive each other''s public key files, and place
    them into our respective `.gnupg` directories. Once that''s done, we''re ready
    to import each other''s keys:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，参与者要么通过电子邮件附件发送彼此的密钥，要么将密钥放在共享目录中。在这种情况下，弗兰克和我将收到彼此的公钥文件，并将它们放入我们各自的`.gnupg`目录中。一旦完成，我们就准备好导入彼此的密钥了：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now for the good stuff. I''ve created a super-secret message for Frank, and
    will asymmetrically encrypt it (`-e`) and sign it (`-s`). (Signing the message
    is the verification that the message really is from me, rather than from an impostor.):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是好东西的时候了。我为弗兰克创建了一个超级秘密的消息，并且会用非对称加密(`-e`)和签名(`-s`)来加密它。（签署消息是验证消息确实是我发出的，而不是冒名顶替者发出的。）
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So, the first thing I had to do was to enter the passphrase for my private
    key. Where it says to enter the user ID, I entered `frank`, since he''s the intended
    recipient of my message. But, look at the line after that, where it says, `There
    is no assurance this key belongs to the named user`. That''s because I still haven''t
    *trusted* Frank''s public key. We''ll get to that in a bit. The last line of the
    output again says to enter a user ID, so that we can designate multiple recipients.
    But, Frank is the only one I care about right now, so I just hit the *Enter* key
    to break out of the routine. This results in a `.gpg` version of my message to
    Frank:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我必须做的第一件事是输入我的私钥密码。在要求输入用户ID的地方，我输入了`frank`，因为他是我消息的预期接收者。但是，看看之后的那一行，那里写着`没有保证这个密钥属于指定的用户`。那是因为我还没有*信任*弗兰克的公钥。我们稍后会解决这个问题。输出的最后一行再次要求输入用户ID，这样我们就可以指定多个接收者。但是，弗兰克现在是我唯一关心的人，所以我只是按下*Enter*键来跳出例行程序。这导致了我给弗兰克的消息的`.gpg`版本：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: My final step is to send Frank his encrypted message file, by whatever means
    available.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我的最后一步是通过任何可用的方式发送Frank的加密消息文件。
- en: 'When Frank receives his message, he''ll use the `-d` option to view it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当弗兰克收到他的消息时，他将使用`-d`选项来查看它：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Frank enters the passphrase for his private key, and he sees the message. At
    the bottom, he sees the warning about how my public key isn''t trusted, and that
    there''s `no indication that the signature belongs to the owner`. Well, since
    Frank knows me personally, and he knows for a fact that the public key really
    is mine, he can add my public key to the *trusted* list:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 弗兰克输入他的私钥密码，然后他看到了消息。在底部，他看到了关于我的公钥不受信任的警告，以及`没有迹象表明签名属于所有者`。好吧，既然弗兰克认识我，他确切地知道这个公钥确实是我的，他可以将我的公钥添加到*受信任*列表中：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The last line of this output is the command prompt for the `gpg` shell. Frank
    is concerned with trust, so he''ll enter the command, `trust`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出的最后一行是`gpg` shell的命令提示符。弗兰克关心信任，所以他会输入`trust`命令：
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Frank has known me for quite a while, and he knows for a fact that I''m the
    one who sent the key. So, he chooses option `5` for ultimate trust. Once Frank
    logs out and logs back in, that trust will take effect:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 弗兰克认识我已经很长时间了，他确切地知道是我发送了这个密钥。所以，他选择了`5`号选项来获得终极信任。一旦弗兰克退出并重新登录，这种信任就会生效：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With no more warning messages, this looks much better. At my end, I'll do the
    same thing with Frank's public key.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 没有更多的警告消息，这看起来好多了。在我的端，我会用弗兰克的公钥做同样的事情。
- en: What's so very cool about this is that even though the whole world may have
    my public key, it's useless to anyone who isn't a designated recipient of my message.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这里非常酷的是，即使整个世界都有我的公钥，对于不是我消息指定接收者的人来说，它是无用的。
- en: 'On an Ubuntu machine, to get rid of the `gpg-agent is not available in this
    session` messages, and to be able to cache your passphrase in the keyring, install
    the `gnupg-agent` package:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu机器上，要摆脱`gpg-agent is not available in this session`的消息，并且能够在钥匙链中缓存您的密码，安装`gnupg-agent`软件包：
- en: '`sudo apt install gnupg-agent`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo apt install gnupg-agent`'
- en: Signing a file without encryption
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 签署文件而不加密
- en: 'If a file isn''t secret, but you still need to ensure authenticity and integrity,
    you can just sign it without encrypting it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个文件不是机密的，但你仍然需要确保真实性和完整性，你可以只对它进行签名而不加密：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Just as before, I create a `.gpg` version of the file. When Frank receives
    the file, he may try to open it with `less`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 就像以前一样，我创建了一个`.gpg`版本的文件。当弗兰克收到文件时，他可能会尝试用`less`打开它：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There''s a lot of gibberish there because of the signature, but if you look
    carefully, you''ll see the plain, unencrypted message. Frank will use `gpg` with
    the `--verify` option to verify that the signature really does belong to me:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 那里有很多无意义的东西，因为签名的缘故，但是如果你仔细看，你会看到明文，未加密的消息。弗兰克将使用`gpg`和`--verify`选项来验证签名是否真的属于我：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Encrypting partitions with Linux Unified Key Setup – LUKS
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Linux统一密钥设置（LUKS）对分区进行加密
- en: 'Being able to encrypt individual files can be handy, but it can be quite unwieldy
    for a large number of files. For that, we need something better, and we have three
    different methods:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 能够加密单个文件可能很方便，但对于大量文件来说可能会很笨拙。为此，我们需要更好的东西，我们有三种不同的方法：
- en: '**Block encryption**: We can use this for either whole-disk encryption, or
    to encrypt individual partitions'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块加密**：我们可以用它来进行整个磁盘加密，或者加密单个分区'
- en: '**File-level encryption**: We''d use this to encrypt individual directories,
    without having to encrypt the underlying partitions'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件级加密**：我们会用这个来加密单个目录，而不必加密底层分区'
- en: '**Containerized Encryption**: Using third-party software that doesn''t come
    with any Linux distribution, we can create encrypted, cross-platform containers
    that can be opened on either Linux, Mac, or Windows machines'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器化加密**：使用不随任何Linux发行版捆绑的第三方软件，我们可以创建加密的跨平台容器，可以在Linux、Mac或Windows机器上打开'
- en: The **Linux Unified Key Setup** (**LUKS**), falls into the first category. It's
    built into pretty much every Linux distribution, and directions for use are the
    same for each. For our demos, I'll use the CentOS virtual machine, since LUKS
    is now the default encryption mechanism for Red Hat Enterprise Linux 7 and CentOS
    7.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux统一密钥设置**（LUKS）属于第一类。它内置在几乎每个Linux发行版中，使用方法对每个发行版都是一样的。对于我们的演示，我将使用CentOS虚拟机，因为LUKS现在是Red
    Hat Enterprise Linux 7和CentOS 7的默认加密机制。'
- en: Disk encryption during operating system installation
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在操作系统安装期间进行磁盘加密
- en: 'When you install Red Hat Enterprise Linux 7 or one of its offspring, you have
    the option of encrypting the drive. All you have to do is to click on a checkbox:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当您安装Red Hat Enterprise Linux 7或其衍生产品之一时，您可以选择加密驱动器。您所需做的就是点击复选框：
- en: '![](img/659a6c43-4b71-4b86-8e67-8ed28938964f.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/659a6c43-4b71-4b86-8e67-8ed28938964f.png)'
- en: Other than that, I just let the installer create the default partitioning scheme,
    which means that the `/` filesystem and the `swap` partition will both be logical
    volumes. (I'll cover that in a moment.)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我只需让安装程序创建默认的分区方案，这意味着`/`文件系统和`swap`分区都将是逻辑卷。（我将在下一步中介绍。）
- en: 'Before the installation can continue, I have to create a passphrase to mount
    the encrypted disk:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装继续之前，我必须创建一个密码来挂载加密磁盘：
- en: '![](img/6a5ec4f6-0c1c-4b20-8444-cb4bf81a89ad.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6a5ec4f6-0c1c-4b20-8444-cb4bf81a89ad.png)'
- en: 'Now, whenever I reboot the system, I need to enter this passphrase:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当我重新启动系统时，我需要输入这个密码：
- en: '![](img/e665ba5e-5389-46f8-a2b0-a86b05a5247a.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e665ba5e-5389-46f8-a2b0-a86b05a5247a.png)'
- en: 'Once the machine is up and running, I can look at the list of logical volumes.
    I see both the `/` logical volume and the `swap` logical volume:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦机器启动运行，我可以查看逻辑卷的列表。我看到了`/`逻辑卷和`swap`逻辑卷：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And I can look at the list of physical volumes. (Actually, there''s only one
    physical volume in the list, and it''s listed as a `luks` physical volume.):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以查看物理卷的列表。（实际上，列表中只有一个物理卷，并且被列为`luks`物理卷。）
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This shows that the underlying physical volume is encrypted, which means that
    both the `/` and the `swap` logical volumes are also encrypted. That's a good
    thing, because leaving the swap space unencrypted—a common mistake when setting
    up disk encryption up manually—can lead to data leakage.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了底层物理卷已加密，这意味着`/`和`swap`逻辑卷也被加密。这是件好事，因为将交换空间留未加密——在手动设置磁盘加密时常见的错误——可能导致数据泄露。
- en: Adding an encrypted partition with LUKS
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LUKS添加加密分区
- en: There may be times when you'll need to either add another encrypted drive to
    an existing machine, or encrypt a portable device, such as a USB memory stick.
    This procedure works for both scenarios.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能需要向现有机器添加另一个加密驱动器，或者加密便携设备，比如USB存储设备。这个过程适用于这两种情况。
- en: 'To demonstrate, I''ll shut down my CentOS VM and add another virtual drive:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我将关闭我的CentOS虚拟机并添加另一个虚拟驱动器：
- en: '![](img/a1edaaaf-409c-4b9d-a10e-f4c9fd0deb8c.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1edaaaf-409c-4b9d-a10e-f4c9fd0deb8c.png)'
- en: 'I''ll bump the drive capacity up to 20 GB, which will give me plenty of room
    to play with:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我将把驱动器容量增加到20GB，这样我就有足够的空间可以使用：
- en: '![](img/f25a5458-d9cf-4b39-a4de-3161eca6fdca.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f25a5458-d9cf-4b39-a4de-3161eca6fdca.png)'
- en: 'After rebooting the machine, I now have a `/dev/sdb` drive to play with. My
    next step is to create a partition. It doesn''t matter whether I create a new-fangled
    GPT partition, or an old-fashioned MBR partition. I''ll create a GPT partition,
    and my preferred utility for doing that is `gdisk`, simply because it''s so similar
    to the old `fdisk` that I know and love so well. The only catch is that `gdisk`
    isn''t installed on CentOS by default:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动机器后，我现在有了一个`/dev/sdb`驱动器可以使用。我的下一步是创建一个分区。无论我创建一个新潮的GPT分区还是一个老式的MBR分区都无所谓。我将创建一个GPT分区，我偏好的工具是`gdisk`，因为它与我所熟悉和喜爱的旧`fdisk`非常相似。唯一的问题是`gdisk`在CentOS上默认未安装：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'I''ll use the entire drive for my partition, and leave the partition type set
    at the default `8300`. I now have the `/dev/sdb1` partition:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用整个驱动器进行分区，并将分区类型设置为默认的`8300`。现在我有了`/dev/sdb1`分区：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'I''ll next use `cryptsetup` to convert the partition to LUKS format. In this
    command, the `-v` signifies verbose mode, and the `-y` signifies that I''ll have
    to enter my passphrase twice in order to properly verify it. Note that when it
    says to type `yes` all in uppercase, it really does mean to type it in uppercase:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将使用`cryptsetup`将分区转换为LUKS格式。在这个命令中，`-v`表示详细模式，`-y`表示我需要两次输入密码来正确验证。请注意，当它说要全部大写输入`yes`时，它确实意味着要全部大写输入：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Although I don''t have to, I''d like to look at the information about my new
    encrypted partition:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我不必这样做，但我想查看一下我的新加密分区的信息：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There's a lot more to the output than what I can show here, but you get the
    idea.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的内容远比我能展示的要多，但您已经有了大致的了解。
- en: 'Next, I''ll map the partition to a device name. You can name the device pretty
    much whatever you want, and I''ll just name mine `secrets`. (I know, it''s a corny
    name. You probably won''t want to make it so obvious where you''re storing your
    secrets.):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将把分区映射到设备名称。您可以随意命名设备，我会把我的命名为`secrets`。（我知道，这是一个陈腐的名字。您可能不想让您存储秘密的地方显得那么明显。）：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When I look in the `/dev/mapper` directory, I see my new `secrets` device,
    listed as a symbolic link to the `dm-3` device:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我查看`/dev/mapper`目录时，我看到了我的新`secrets`设备，列为指向`dm-3`设备的符号链接：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'I''ll use `dmsetup` to look at the information about my new device:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用`dmsetup`查看有关我的新设备的信息：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The next step is to format the partition in the usual manner. I could use any
    filesystem that''s supported by Red Hat and CentOS. But, since everything else
    on my system is already formatted with XFS, that''s what I''ll go with here, as
    well:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是以通常的方式格式化分区。我可以使用Red Hat和CentOS支持的任何文件系统。但是，由于我系统上的其他所有内容都已经使用XFS格式化，所以我也会选择XFS：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'My final step is to create a mount point and to mount the encrypted partition:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我的最后一步是创建一个挂载点并挂载加密分区：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `mount` command will verify that the partition is mounted properly:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount`命令将验证分区是否正确挂载：'
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Configuring the LUKS partition to mount automatically
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置LUKS分区以自动挂载
- en: 'The only missing piece of the puzzle is to configure the system to automatically
    mount the LUKS partition upon boot-up. To do that, I''ll configure two different
    files:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 拼图中唯一缺失的部分是配置系统在启动时自动挂载LUKS分区。为此，我将配置两个不同的文件：
- en: '`/etc/crypttab`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/crypttab`'
- en: '`/etc/fstab`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/fstab`'
- en: 'Had I not chosen to encrypt the disk when I installed the operating system,
    I wouldn''t have a `crypttab` file, and I would have to create it myself. But,
    since I did choose to encrypt the drive, I already have one with information about
    that drive:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在安装操作系统时没有选择加密磁盘，我将没有`crypttab`文件，必须自己创建。但是，由于我选择加密驱动器，我已经有了一个包含有关该驱动器信息的文件：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The first two fields describe the name and location of the encrypted partition.
    The third field is for the encryption passphrase. If it's set to `none`, as it
    is here, then the passphrase will have to be manually entered upon boot-up.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个字段描述了加密分区的名称和位置。第三个字段是加密密码。如果设置为“none”，就像这里一样，那么密码将在启动时手动输入。
- en: 'In the `fstab` file, we have the entry that actually mounts the partition:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fstab`文件中，我们有实际挂载分区的条目：
- en: '[PRE47]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Well, there are actually two entries in this case, because I have two logical
    volumes, `/` and `swap`, on top of my encrypted physical volume. The `UUID` line
    is the `/boot` partition, which is the only part of the drive that isn't encrypted.
    Now, let's add our new encrypted partition so that it will mount automatically,
    as well.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，在这种情况下实际上有两个条目，因为我有两个逻辑卷，`/`和`swap`，位于我的加密物理卷之上。`UUID`行是`/boot`分区，这是驱动器中唯一未加密的部分。现在，让我们添加我们的新加密分区，以便它会自动挂载。
- en: This is where it would be extremely helpful to remotely log into your virtual
    machine from your desktop host machine. By using a GUI-type Terminal, whether
    it be the Terminal from a Linux or MacOS machine, or Cygwin from a Windows machine,
    you'll have the ability to perform copy-and-paste operations, which you won't
    have if you work directly from the virtual machine terminal. (Trust me, you don't
    want to be typing in those long UUIDs.)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个极其有用的地方，可以从桌面主机远程登录到虚拟机。通过使用GUI类型的终端，无论是来自Linux或MacOS机器的终端，还是来自Windows机器的Cygwin，您都可以执行复制和粘贴操作，而如果直接从虚拟机终端工作，则无法执行这些操作。（相信我，您不想输入那些长长的UUID。）
- en: 'The first step is to obtain the UUID of the encrypted partition:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是获取加密分区的UUID：
- en: '[PRE48]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'I''ll copy that UUID, and paste it into the `/etc/crypttab` file. (Note that
    you''ll paste it in twice. The first time, you''ll prepend it with `luks-`, and
    the second time you''ll append it with `UUID=`.):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我会复制该UUID，并将其粘贴到`/etc/crypttab`文件中。（请注意，您将粘贴两次。第一次，您将在其前面加上`luks-`，第二次您将在其后面加上`UUID=`。）
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, I''ll edit the `/etc/fstab` file, adding the last line in the file
    for my new encrypted partition. (Note that I again used `luks-`, followed by the
    UUID number.):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我将编辑`/etc/fstab`文件，为我的新加密分区添加文件的最后一行。（请注意，我再次使用了`luks-`，后跟UUID号码。）
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When editing the `fstab` file for adding normal, unencrypted partitions, I always
    like to do a `sudo mount -a` to check the `fstab` file for typos. That won't work
    with LUKS partitions though, because `mount` won't recognize the partition until
    the system reads in the `crypttab` file, and that won't happen until I reboot
    the machine. So, just be extra careful with editing `fstab` when adding LUKS partitions.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑`fstab`文件以添加普通的未加密分区时，我总是喜欢执行`sudo mount -a`来检查`fstab`文件中是否有拼写错误。但是，对于LUKS分区，这是行不通的，因为`mount`在系统读取`crypttab`文件之前不会识别分区，而这将在我重新启动机器之前不会发生。因此，在添加LUKS分区时，请务必格外小心编辑`fstab`。
- en: Now for the moment of truth. I'll reboot the machine to see if everything works.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在到了真相的时刻。我将重新启动机器，看看是否一切正常。
- en: 'Okay, the machine has rebooted, and `mount` shows that my endeavors have been
    successful:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，机器已经重新启动，`mount`显示我的努力取得了成功：
- en: '[PRE51]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Encrypting directories with eCryptfs
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用eCryptfs加密目录
- en: Encrypting entire partitions is cool, but you might, at times, just need to
    encrypt an individual directory. For that, we can use eCryptfs. We'll need to
    use our Ubuntu machines for this, because Red Hat and CentOS no longer include
    eCryptfs in version 7 of their products. (It was in Red Hat 6 and CentOS 6, but
    it's no longer even available for installation in version 7.)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 加密整个分区很酷，但有时您可能只需要加密单个目录。为此，我们可以使用eCryptfs。我们需要使用我们的Ubuntu机器进行此操作，因为Red Hat和CentOS在其产品的第7版中不再包括eCryptfs。（它在Red
    Hat 6和CentOS 6中，但在第7版中甚至不再可用于安装。）
- en: Home directory and disk encryption during Ubuntu installation
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ubuntu安装期间的家目录和磁盘加密
- en: 'When you install Ubuntu Server, you have two chances to implement encryption.
    You''ll first be given the chance to encrypt your home directory:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当您安装Ubuntu服务器时，您有两次机会实施加密。您首先有机会加密您的家目录：
- en: '![](img/1f24ca5a-c6e0-40a6-a644-e8864326a800.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1f24ca5a-c6e0-40a6-a644-e8864326a800.png)'
- en: 'Later, on the Partition disks screen, you''ll be given the chance to set up
    encrypted logical volumes for whole disk encryption:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，在分区磁盘屏幕上，您将有机会为整个磁盘加密逻辑卷：
- en: '![](img/7994a943-59c1-4a50-9365-0656f8b0419f.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7994a943-59c1-4a50-9365-0656f8b0419f.png)'
- en: 'After choosing this option, you will then be asked to enter a passphrase:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 选择此选项后，您将被要求输入密码：
- en: '![](img/ba033a01-d844-426b-9e9b-d317d48b0fab.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba033a01-d844-426b-9e9b-d317d48b0fab.png)'
- en: 'The disk encryption uses LUKS, just the same as we saw on the CentOS machine.
    To prove this, all we have to do is look for a populated `crypttab` file in the
    `/etc` directory:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘加密使用LUKS，与我们在CentOS机器上看到的一样。要证明这一点，我们只需在`/etc`目录中查找填充的`crypttab`文件：
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Unlike Red Hat and CentOS, an Ubuntu machine will always have the `/etc/crypttab`
    file, even if there are no LUKS partitions. Without LUKS partitions, the file
    will be empty.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与Red Hat和CentOS不同，Ubuntu机器将始终具有`/etc/crypttab`文件，即使没有LUKS分区。没有LUKS分区，该文件将为空。
- en: 'The home directory encryption uses eCryptfs, as evidenced by the `.ecryptfs`
    directory in the `/home` directory:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 主目录加密使用eCryptfs，如`/home`目录中的`.ecryptfs`目录所示：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: So, what we have here is encryption on top of encryption, for double protection.
    Is that really necessary? Probably not, but choosing to encrypt my home directory
    ensured that the access permissions for it got set to the more restrictive `700`
    setting, rather than the default `755` setting. Be aware though, that any user
    accounts you create now will have wide open permissions settings on their home
    directories. Unless, that is, we create user accounts with the encryption option.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们这里有一个加密叠加加密，双重保护。这真的有必要吗？可能不是，但选择加密我的主目录确保了其访问权限设置为更严格的`700`设置，而不是默认的`755`设置。但要注意，您现在创建的任何用户帐户都将在其主目录上具有完全开放的权限设置。除非我们选择创建带有加密选项的用户帐户。
- en: Encrypting a home directory for a new user account
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为新用户帐户加密主目录
- en: 'In [Chapter 2](bbe819e7-1d8f-414c-8de7-eab84959a9e6.xhtml), *Securing User
    Accounts*, I showed you how Ubuntu allows you to encrypt a user''s home directory
    as you create his or her user account. To review, let''s see the command for creating
    Goldie''s account:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](bbe819e7-1d8f-414c-8de7-eab84959a9e6.xhtml)中，*保护用户账户*，我向您展示了Ubuntu如何允许您在创建用户帐户时加密用户的主目录。让我们回顾一下，看看创建Goldie帐户的命令：
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When Goldie logs in, the first thing she''ll want to do is to `unwrap` her
    mount passphrase, write it down, and store it in a secure place. (She''ll need
    this if she ever needs to recover a corrupted directory.):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Goldie登录时，她首先要做的是`unwrap`她的挂载密码，将其写下并存放在安全的地方。（如果她需要恢复损坏的目录，她将需要这个。）
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: When you use `adduser --encrypt-home`, home directories for new users will automatically
    be set to a restrictive permissions value that will keep everyone out except for
    the owner of the directory. This happens even when you leave the `adduser.conf`
    file set with its default settings.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`adduser --encrypt-home`时，新用户的主目录将自动设置为限制权限值，除了目录所有者，其他人都无法访问。即使您保留`adduser.conf`文件的默认设置，也会发生这种情况。
- en: Creating a private directory within an existing home directory
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在现有主目录中创建私人目录
- en: Let's say that you have users who, for whatever strange reason, don't want to
    encrypt their entire home directories, and want to keep the `755` permissions
    settings on their home directories so that other people can access their files.
    But, they also want a private directory that nobody but them can access.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一些用户，出于某种奇怪的原因，不想加密其整个主目录，并且希望保留其主目录上的`755`权限设置，以便其他人可以访问其文件。但是，他们还想要一个除了他们自己以外没有人可以访问的私人目录。
- en: 'Instead of encrypting an entire home directory, any user can create an encrypted
    private directory within his or her own home directory. The first step, if it
    hasn''t already been done, is for someone with admin privileges to install the
    `ecryptfs-utils` package:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 任何用户都可以在自己的主目录中创建加密的私人目录，而不是加密整个主目录。如果尚未完成第一步，则需要具有管理员权限的人安装`ecryptfs-utils`软件包：
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To create this private directory, we''ll use the interactive `ecryptfs-setup-private`
    utility. If you have admin privileges, you can do this for other users. Users
    without admin privileges can do it for themselves. For our demo, let''s say that
    Charlie, my big Siamese/Gray tabby guy, needs his own encrypted private space.
    (Who knew that cats had secrets, right?):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建这个私人目录，我们将使用交互式的`ecryptfs-setup-private`实用程序。如果您有管理员权限，您可以为其他用户执行此操作。没有管理员权限的用户可以为自己执行此操作。对于我们的演示，假设我的大暹罗/灰色虎斑猫Charlie需要自己的加密私人空间。（谁知道猫也有秘密，对吧？）
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'For the `login` passphrase, Charlie enters his normal password or passphrase
    for logging into his user account. He could have let the system generate its own
    `mount` passphrase, but he decided to enter his own. Since he did enter his own
    mount passphrase, he didn''t need to do the `ecryptfs-unwrap-passphrase` command
    to find out what the passphrase is. But, just to show how that command works,
    let''s say that Charlie entered `TurkeyLips` as his mount passphrase:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`login`密码，Charlie输入他的正常密码或用于登录用户帐户的密码。他本可以让系统生成自己的`mount`密码，但他决定输入自己的密码。由于他输入了自己的挂载密码，他不需要执行`ecryptfs-unwrap-passphrase`命令来找出密码是什么。但是，为了展示该命令的工作原理，假设Charlie输入`TurkeyLips`作为他的挂载密码：
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Yes, it's a horribly weak passphrase, but for our demo purposes, it works.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是一个非常弱的密码，但对于我们的演示目的，它有效。
- en: 'After Charlie logs out and logs back in, he can start using his new private
    directory. Also, you can see that he has three new hidden directories within his
    home directory. All three of these new directories are only accessible by Charlie,
    even though his top-level home directory is still wide open to everybody:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Charlie注销并重新登录后，他可以开始使用他的新私人目录。此外，您可以看到他的主目录中有三个新的隐藏目录。尽管他的顶级主目录仍然向所有人开放，但这三个新目录只能由Charlie访问：
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If you do a `grep ''ecryptfs'' *` command in the `/etc/pam.d` directory, you''ll
    see that PAM is configured to automatically mount users'' encrypted directories
    whenever they log into the system:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/etc/pam.d`目录中执行`grep 'ecryptfs' *`命令，您将看到PAM配置为在用户登录系统时自动挂载其加密目录：
- en: '[PRE60]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Encrypting other directories with eCryptfs
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用eCryptfs加密其他目录
- en: Encrypting other directories is a simple matter of mounting them with the `ecryptfs`
    filesystem. For our example, let's create a `secrets` directory in the top level
    of our filesystem, and encrypt it. Note how you list the directory name twice,
    because you also need to specify a mount point. (Essentially, you're using the
    directory that you're mounting as its own mount point.)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ecryptfs`文件系统挂载其他目录非常简单。对于我们的示例，让我们在我们的文件系统的顶层创建一个`secrets`目录，并对其进行加密。请注意，您需要两次列出目录名称，因为您还需要指定挂载点。（基本上，您使用要挂载的目录作为其自己的挂载点。）
- en: '[PRE61]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The output from this command is a bit lengthy, so let's break it down.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出有点冗长，所以让我们分解一下。
- en: 'First, you''ll enter your desired passphrase, and choose the encryption algorithm
    and the key length:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将输入所需的密码，选择加密算法和密钥长度：
- en: '[PRE62]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We'll go with the default of `aes`, and 16 bytes for the key.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择默认的`aes`，并使用16字节的密钥。
- en: 'I''m going to go with the default of no for `plaintext passthrough`, and with
    yes for filename encryption:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我将选择“明文传递”的默认选项为否，并选择文件名加密为是：
- en: '[PRE63]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'I''ll go with the default `Filename Encryption Key`, and verify the mounting
    options:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我将使用默认的“文件名加密密钥”，并验证挂载选项：
- en: '[PRE64]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This warning only comes up when you mount the directory for the first time.
    For the final two questions, I''ll type `yes` in order to prevent that warning
    from coming up again:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 此警告仅在您首次挂载目录时出现。对于最后两个问题，我将输入“是”以防止再次出现该警告：
- en: '[PRE65]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Just for fun, I''ll create a file within my new encrypted `secrets` directory,
    and then unmount the directory:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了好玩，我将在我的新加密“secrets”目录中创建一个文件，然后卸载该目录：
- en: '[PRE66]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: By choosing to encrypt filenames, nobody can even tell what files you have when
    the directory is unmounted. When I'm ready to access my encrypted files again,
    I'll just remount the directory the same as I did before.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择加密文件名，当目录未挂载时，没有人甚至可以知道您有哪些文件。当我准备再次访问我的加密文件时，我只需像以前一样重新挂载目录。
- en: Encrypting the swap partition with eCryptfs
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用eCryptfs加密交换分区
- en: 'If you''re just encrypting individual directories with eCryptfs instead of
    using LUKS whole-disk encryption, you''ll need to encrypt your swap partition
    in order to prevent accidental data leakage. Fixing that problem requires just
    one simple command:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只是使用eCryptfs加密单个目录而不是使用LUKS整个磁盘加密，您需要加密交换分区以防止意外数据泄漏。修复这个问题只需要一个简单的命令：
- en: '[PRE67]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Don't mind the warning about the missing `/dev/mapper/cryptswap1` file. It will
    get created the next time you reboot the machine.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在意关于缺少“/dev/mapper/cryptswap1”文件的警告。下次重新启动机器时，它将被创建。
- en: Using VeraCrypt for cross-platform sharing of encrypted containers
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用VeraCrypt进行加密容器的跨平台共享
- en: Once upon a time, there was TrueCrypt, a cross-platform program that allowed
    the sharing of encrypted containers across different operating systems. But the
    project was always shrouded in mystery, because its developers would never reveal
    their identities. And then, right out of the blue, the developers released a cryptic
    message about how TrueCrypt was no longer secure, and shut down the project.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从前，有一个叫TrueCrypt的跨平台程序，允许在不同操作系统之间共享加密容器。但该项目一直笼罩着神秘色彩，因为其开发人员从未透露过自己的身份。然后，突然之间，开发人员发布了一条神秘的消息，称TrueCrypt不再安全，并关闭了该项目。
- en: 'VeraCrypt is the successor to TrueCrypt, and it allows the sharing of encrypted
    containers across Linux, Windows, MacOS, and FreeBSD machines. Although LUKS and
    eCryptfs are good, VeraCrypt does offer more flexibility in certain ways:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: VeraCrypt是TrueCrypt的继任者，它允许在Linux、Windows、MacOS和FreeBSD机器之间共享加密容器。尽管LUKS和eCryptfs都不错，但在某些方面VeraCrypt确实提供了更多的灵活性：
- en: As mentioned, VeraCrypt offers cross-platform sharing, whereas LUKS and eCryptfs
    don't
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提到的是，VeraCrypt提供跨平台共享，而LUKS和eCryptfs则不提供
- en: VeraCrypt allows you to encrypt either whole partitions or whole storage devices,
    or to create virtual encrypted disks
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VeraCrypt允许您加密整个分区或整个存储设备，或创建虚拟加密磁盘
- en: Not only can you create encrypted volumes with VeraCrypt, you can also hide
    them, giving you plausible deniability
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VeraCrypt不仅可以创建加密卷，还可以隐藏它们，从而具有合理的否认性
- en: VeraCrypt comes in both command-line and GUI variants, so it's appropriate for
    either server use or for the casual desktop user
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VeraCrypt有命令行和GUI两种变体，因此适用于服务器使用或休闲桌面用户
- en: Like LUKS and eCryptfs, VeraCrypt is free open source software, which means
    that it's free to use, and that the source code can be audited for either bugs
    or backdoors
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像LUKS和eCryptfs一样，VeraCrypt是免费开源软件，这意味着它可以免费使用，并且可以审核源代码以查找错误或后门
- en: Getting and installing VeraCrypt
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取并安装VeraCrypt
- en: 'The Linux version of VeraCrypt comes as a set of universal installer scripts
    that should work on any Linux distribution. Once you extract the `.tar.bz2` archive
    file, you''ll see two scripts for GUI installation, and two for console-mode installation.
    One of each of those is for 32-bit Linux, and one of each is for 64-bit Linux:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: VeraCrypt的Linux版本是一组通用安装脚本，应该适用于任何Linux发行版。在提取`.tar.bz2`存档文件后，您将看到两个用于GUI安装的脚本和两个用于控制台模式安装的脚本。其中一个用于32位Linux，另一个用于64位Linux：
- en: '[PRE68]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'For the server demo, I used `scp` to transfer the 64-bit console-mode installer
    to one of my Ubuntu virtual machines. The executable permission is already set,
    so all you have to do to install is:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于服务器演示，我使用`scp`将64位控制台模式安装程序传输到我的Ubuntu虚拟机之一。可执行权限已经设置，因此安装只需执行以下操作：
- en: '[PRE69]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: You'll need sudo privileges, but the installer will prompt you for your sudo
    password. After reading and agreeing to a rather lengthy license agreement, the
    installation only takes a few seconds.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要sudo权限，但安装程序将提示您输入sudo密码。阅读并同意相当冗长的许可协议后，安装只需要几秒钟。
- en: Creating and mounting a VeraCrypt volume in console mode
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在控制台模式下创建和挂载VeraCrypt卷
- en: I haven't been able to find any documentation for the console-mode variant of
    VeraCrypt, but you can see a list of the available commands just by typing `veracrypt`.
    For this demo, I'm creating a 2 GB encrypted volume in my own home directory.
    But you can just as easily do it elsewhere, such as on a USB memory stick.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我找不到VeraCrypt控制台模式的任何文档，但您可以通过键入“veracrypt”来查看可用命令的列表。在此演示中，我在自己的主目录中创建了一个2GB的加密卷。但您也可以在其他地方轻松完成，比如在USB存储设备上。
- en: 'To create a new encrypted volume, type:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的加密卷，请键入：
- en: '[PRE70]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This will take you into an easy-to-use, interactive utility. For the most part,
    you''ll be fine just accepting the default options:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带您进入一个易于使用的交互式实用程序。在大多数情况下，接受默认选项即可。
- en: '[PRE71]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'For the filesystem, the default option of FAT will give you the best cross-platform
    compatibility between Linux, MacOS, and Windows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文件系统，默认的FAT选项将为你提供Linux、MacOS和Windows之间最好的跨平台兼容性：
- en: '[PRE72]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You''ll then select your password and a PIM, which stands for Personal Iterations
    Multiplier. (For the PIM, I entered `8891`. High PIM values give better security,
    but they will also cause the volume to take longer to mount.) Then, type at least
    320 random characters in order to generate the encryption key. (This is where
    it would be handy to have my cats walking across my keyboard.):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你会选择你的密码和PIM，PIM代表个人迭代乘数。（对于PIM，我输入了`8891`。高PIM值可以提供更好的安全性，但也会导致卷需要更长时间来挂载。）然后，至少输入320个随机字符以生成加密密钥。（这时，如果我的猫走过我的键盘会很方便。）
- en: '[PRE73]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'After you hit *Enter*, be patient, because the final generation of your encrypted
    volume will take a few moments. Here, you see that my 2 GB `good_stuff` container
    has been successfully created:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Enter*后，请耐心等待，因为加密卷的最终生成将需要一些时间。在这里，你可以看到我的2GB的`good_stuff`容器已经成功创建：
- en: '[PRE74]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'To use this container, I have to mount it. I''ll begin by creating a mount
    point directory; the same as I would for mounting normal partitions:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个容器，我必须挂载它。我将首先创建一个挂载点目录；与挂载普通分区一样：
- en: '[PRE75]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Use the `veracrypt` utility to mount your container on this mount point:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`veracrypt`实用程序将你的容器挂载到这个挂载点上：
- en: '[PRE76]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To see what VeraCrypt volumes you have mounted, use `veracrypt -l`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你已经挂载的VeraCrypt卷，使用`veracrypt -l`：
- en: '[PRE77]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: And, that's all there is to it.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。
- en: Using VeraCrypt in GUI mode
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在GUI模式下使用VeraCrypt
- en: 'Desktop users of any of the supported operating systems can install the GUI
    variant of VeraCrypt. Be aware though, that you can''t install both the console-mode
    variant and the GUI variant on the same machine, because one will overwrite the
    other. Here, you see the GUI version running on my CentOS 7 virtual machine:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 任何受支持的操作系统的桌面用户都可以安装VeraCrypt的GUI变体。但要注意，你不能在同一台机器上安装控制台模式变体和GUI模式变体，因为其中一个会覆盖另一个。在这里，你可以看到GUI版本在我的CentOS
    7虚拟机上运行：
- en: '![](img/9a487ef8-1b8d-42f2-a74f-15208816fabc.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a487ef8-1b8d-42f2-a74f-15208816fabc.png)'
- en: Since the main focus of this book is sever security, I won't go into the details
    of the GUI version here. But, it's fairly self-explanatory, and you can view the
    full VeraCrypt documentation on their website.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的主要重点是服务器安全，我不会在这里详细介绍GUI版本。但是，它相当简单易懂，你可以在他们的网站上查看完整的VeraCrypt文档。
- en: You can get VeraCrypt from here: [https://www.veracrypt.fr/en/Home.html](https://www.veracrypt.fr/en/Home.html)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这里获取VeraCrypt：[https://www.veracrypt.fr/en/Home.html](https://www.veracrypt.fr/en/Home.html)
- en: For the rest of this chapter, we'll turn our attention to the subject of protecting
    data in transit, by locking down Secure Shell.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将把注意力转向通过锁定Secure Shell来保护传输数据的主题。
- en: Ensuring that SSH protocol 1 is disabled
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保SSH协议1已禁用
- en: By this stage in your Linux career, you should already know how to use Secure
    Shell, or SSH, to do remote logins and remote file transfers. What you may not
    know is that a default configuration of SSH is actually quite insecure.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Linux职业生涯的这个阶段，你应该已经知道如何使用安全Shell，或者SSH，进行远程登录和远程文件传输。你可能不知道的是，SSH的默认配置实际上是相当不安全的。
- en: 'SSH protocol version 1, the original SSH protocol, is severely flawed, and
    should never be used. It''s still in most Linux distributions, but fortunately,
    it''s always disabled by default. But, if you ever open your `/etc/ssh/sshd_config`
    file and see this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: SSH协议版本1，原始的SSH协议，存在严重缺陷，不应该使用。它仍然存在于大多数Linux发行版中，但幸运的是，默认情况下它总是被禁用的。但是，如果你打开`/etc/ssh/sshd_config`文件并看到这个：
- en: '[PRE78]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Or this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这样：
- en: '[PRE79]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Then you have a problem.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你会遇到问题。
- en: The Ubuntu main page for the `sshd_config` file says that protocol version 1
    is still available for use with `legacy devices`. But, if you're still running
    devices that are that old, you need to start seriously thinking about doing some
    upgrades.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu `sshd_config`文件的主页表示，协议版本1仍然可用于与`传统设备`一起使用。但是，如果你仍在使用那么老的设备，你需要开始认真考虑进行一些升级。
- en: As Linux distributions get updated, you'll see SSH protocol 1 gradually being
    completely removed, as has happened with Red Hat and CentOS 7.4.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Linux发行版的更新，你会看到SSH协议1逐渐被完全移除，就像Red Hat和CentOS 7.4一样。
- en: Creating and managing keys for password-less logins
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和管理无密码登录的密钥
- en: 'The Secure Shell Suite, or SSH, is a great set of tools that provides secure,
    encrypted communications with remote servers. You can use the SSH component to
    remotely log into the command-line of a remote machine, and you can use either
    `scp` or `sftp` to securely transfer files. The default way to use any of these
    SSH components is to use the username and password of a person''s normal Linux
    user account. So, logging into a remote machine from the terminal of my OpenSUSE
    workstation would look something like:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 安全Shell套件，或者SSH，是一套提供与远程服务器进行安全加密通信的工具。你可以使用SSH组件远程登录到远程机器的命令行，你也可以使用`scp`或`sftp`来安全地传输文件。使用任何这些SSH组件的默认方式是使用一个人的普通Linux用户帐户的用户名和密码。因此，从我的OpenSUSE工作站的终端登录到远程机器看起来是这样的：
- en: '[PRE80]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: While it's true that the username and password go across the network in an encrypted
    format, making it hard for malicious actors to intercept, it's still not the most
    secure way of doing business. The problem is that attackers have access to automated
    tools that can perform brute-force password attacks against an SSH server. Botnets,
    such as the Hail Mary Cloud, perform continuous scans across the internet to find
    internet-facing servers with SSH enabled. If a botnet finds that the servers allow
    SSH access via username and password, it will then launch a brute-force password
    attack. Sadly, such attacks have been successful quite a few times, especially
    when the server operators allow the root user to log in via SSH.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然用户名和密码以加密格式通过网络传输是真实的，这使得恶意行为者难以拦截，但这仍然不是最安全的做法。问题在于攻击者可以访问自动化工具，对SSH服务器执行暴力密码攻击。像Hail
    Mary Cloud这样的僵尸网络在互联网上进行持续扫描，以找到启用SSH的面向互联网的服务器。如果僵尸网络发现服务器允许通过用户名和密码访问SSH，它将发起暴力密码攻击。遗憾的是，这种攻击已经成功了很多次，特别是当服务器运营商允许root用户通过SSH登录时。
- en: This older article gives more details about the Hail Mary Cloud botnet: [http://futurismic.com/2009/11/16/the-hail-mary-cloud-slow-but-steady-brute-force-password-guessing-botnet/](http://futurismic.com/2009/11/16/the-hail-mary-cloud-slow-but-steady-brute-force-password-guessing-botnet/)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这篇较旧的文章详细介绍了Hail Mary Cloud僵尸网络：[http://futurismic.com/2009/11/16/the-hail-mary-cloud-slow-but-steady-brute-force-password-guessing-botnet/](http://futurismic.com/2009/11/16/the-hail-mary-cloud-slow-but-steady-brute-force-password-guessing-botnet/)
- en: 'In the next section, we''ll look at two ways to help prevent these types of
    attacks:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看两种方法来帮助防止这些类型的攻击：
- en: Enable SSH logins through an exchange of public keys
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过交换公钥启用SSH登录
- en: Disable the root user login through SSH
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用通过SSH登录的root用户
- en: Creating a user's SSH key set
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户的SSH密钥集
- en: Each user has the ability to create his or her own set of private and public
    keys. It doesn't matter whether the user's client machine is running Linux, MacOS,
    or Cygwin on Windows. In all three cases, the procedure is exactly the same. To
    demo, I'll create keys on my OpenSUSE workstation and transfer the public key
    to one of my virtual machines. It doesn't matter which virtual machine I use,
    but since I haven't shown much love to the CentOS machine lately, I'll use it.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户都有能力创建自己的私钥和公钥。无论用户的客户端机器运行Linux、MacOS还是Windows上的Cygwin，在这三种情况下，程序都是完全相同的。为了演示，我将在我的OpenSUSE工作站上创建密钥，并将公钥传输到我的一个虚拟机。我使用哪个虚拟机并不重要，但由于我最近没有给CentOS机器太多关注，所以我会使用它。
- en: 'I''ll begin by creating the keys on my OpenSUSE workstation:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从在我的OpenSUSE工作站上创建密钥开始：
- en: '[PRE81]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: There are several different types of keys that you can create, but the default
    2048-bit RSA keys are considered as plenty strong enough for the foreseeable future.
    The private and public SSH keys work the same as we saw with GPG. You'll keep
    your private keys to yourself, but you can share the public key with the world,
    if you so desire. In this case though, I'm only going to share my public key with
    just one server.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建几种不同类型的密钥，但默认的2048位RSA密钥被认为对可预见的未来足够强大。私钥和公钥SSH密钥的工作方式与我们在GPG中看到的相同。您将保留私钥，但如果愿意，可以与世界共享公钥。不过，在这种情况下，我只会与一个服务器共享我的公钥。
- en: When prompted for the location and name of the keys, I'll just hit *Enter* to
    accept the defaults. You could just leave the private key with a blank passphrase,
    but that's not a recommended practice.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当要求输入密钥的位置和名称时，我只需按*Enter*接受默认值。您可以将私钥留空密码，但这不是推荐的做法。
- en: 'Note that if you choose an alternative name for your key files, you''ll need
    to type in the entire path to make things work properly. For example, in my case,
    I would specify the path for `donnie_rsa` keys as:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您选择了密钥文件的替代名称，您需要键入整个路径才能使事情正常工作。例如，在我的情况下，我将指定`donnie_rsa`密钥的路径为：
- en: '`/home/donnie/.ssh/donnie_rsa`'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`/home/donnie/.ssh/donnie_rsa`'
- en: 'In the `.ssh` directory in my home directory, I can see the keys that I created:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的家目录的`.ssh`目录中，我可以看到我创建的密钥：
- en: '[PRE82]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The `id_rsa` key is the private key, with read and write permissions only for
    me. The `id_rsa.pub` public key has to be world-readable.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`id_rsa`密钥是私钥，只有我有读写权限。`id_rsa.pub`公钥必须是可读的。'
- en: Transferring the public key to the remote server
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将公钥传输到远程服务器
- en: 'Transferring my public key to a remote server allows the server to readily
    identify both me and my client machine. Before I can transfer the public key to
    the remote server, I need to add the private key to my session keyring. This requires
    two commands. (One command is to invoke the `ssh-agent`, and the other command
    actually adds the private key to the keyring.):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 将我的公钥传输到远程服务器可以让服务器轻松识别我和我的客户端机器。在我可以将公钥传输到远程服务器之前，我需要将私钥添加到我的会话密钥环中。这需要两个命令。（一个命令是调用`ssh-agent`，另一个命令实际上将私钥添加到密钥环中。）
- en: '[PRE83]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Finally, I can transfer my public key to my CentOS server, which is at address
    `192.168.0.101`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我可以将我的公钥传输到我的CentOS服务器，地址为`192.168.0.101`：
- en: '[PRE84]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The next time that I log in, I''ll use the key exchange, and I won''t have
    to enter a password:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 下次登录时，我将使用密钥交换，而无需输入密码：
- en: '[PRE85]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'So, now you''re wondering, "*How is that secure if I can log in without entering
    my password?*" The answer is that once you close the client machine''s terminal
    window that you used for logging in, the private key will be removed from your
    session keyring. When you open a new terminal and try to log in to the remote
    server, you''ll see this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在您可能会想：“*如果我可以在不输入密码的情况下登录，那么这样安全吗？*”答案是，一旦您关闭用于登录的客户端机器的终端窗口，私钥将从您的会话密钥环中删除。当您打开新的终端并尝试登录到远程服务器时，您将看到这个：
- en: '[PRE86]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Now, every time I log into this server, I'll need to enter the passphrase for
    my private key. (That is, unless I add it back to the session keyring with the
    two commands that I showed you in the preceding section.)
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次我登录到这台服务器时，我都需要输入私钥的密码。（除非我使用前一节中向您展示的两个命令将其添加回会话密钥环中。）
- en: Disabling root user login
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用root用户登录
- en: 'A few years ago, there was a somewhat celebrated case where malicious actors
    had managed to plant malware on quite a few Linux servers somewhere in southeast
    Asia. There were three reasons that the bad guys found this so easy to do:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，有一个相当引人注目的案例，恶意行为者设法在东南亚某地的许多Linux服务器上植入了恶意软件。坏人发现这么做很容易有三个原因：
- en: The internet-facing servers involved were set up to use username/password authentication
    for SSH
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 涉及的面向互联网的服务器设置为使用用户名/密码身份验证进行SSH登录。
- en: The root user was allowed to log in through SSH
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许root用户通过SSH登录
- en: User passwords, including the root user's password, were incredibly weak
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户密码，包括root用户的密码，都非常薄弱
- en: All this meant that it was easy for Hail Mary to brute-force its way in.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都意味着Hail Mary很容易通过暴力破解方式进入。
- en: 'Different distributions have different default settings for root user login.
    In the `/etc/ssh/sshd_config` file of your CentOS machine, you''ll see this line:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的发行版对root用户登录有不同的默认设置。在您的CentOS机器的`/etc/ssh/sshd_config`文件中，您将看到这一行：
- en: '[PRE87]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Unlike what you have in most configuration files, the commented-out lines in
    `sshd_config` define the default settings for the Secure Shell daemon. So, this
    line indicates that the root user is indeed allowed to log in through SSH. To
    change that, I''ll remove the comment symbol and change the setting to `no`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数配置文件中的情况不同，在`sshd_config`中的注释行定义了安全外壳守护程序的默认设置。因此，这一行表示确实允许root用户通过SSH登录。要更改这一点，我将删除注释符号并将设置更改为`no`：
- en: '[PRE88]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'To make the new setting take effect, I''ll restart the SSH daemon, which is
    named `sshd` on CentOS, and is named `ssh` on Ubuntu:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使新设置生效，我将重新启动SSH守护程序，在CentOS上命名为`sshd`，在Ubuntu上命名为`ssh`：
- en: '[PRE89]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'On the Ubuntu machine, the default setting looks a bit different:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu机器上，默认设置看起来有点不同：
- en: '[PRE90]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This means that the root user is allowed to log in, but only via a public key
    exchange. That's probably secure enough, if you really need to allow the root
    user to log in. But in most cases, you'll want to force admin users to log in
    with their normal user accounts, and to use `sudo` for their admin needs. So,
    in most cases, you can still change this setting to `no`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着允许root用户登录，但只能通过公钥交换。如果您确实需要允许root用户登录，那可能足够安全。但在大多数情况下，您会希望强制管理员用户使用其普通用户帐户登录，并使用`sudo`来满足其管理员需求。因此，在大多数情况下，您仍然可以将此设置更改为`no`。
- en: Be aware that if you deploy an instance of Ubuntu Server on a cloud service,
    such as Azure, Rackspace, or Vultr, the service owners will have you log into
    the virtual machine with the root user account. The first thing you'll want to
    do is to create your own normal user account, log back in with that account, disable
    the root user account, and disable the root user login in `sshd_config`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您在Azure、Rackspace或Vultr等云服务上部署Ubuntu服务器实例，服务所有者将要求您使用root用户帐户登录到虚拟机。您要做的第一件事是创建自己的普通用户帐户，使用该帐户重新登录，禁用root用户帐户，并在`sshd_config`中禁用root用户登录。
- en: Disabling username/password logins
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用用户名/密码登录
- en: This is something that you'll only want to do after you've set up the key exchange
    with your clients. Otherwise, clients will be locked out of doing remote logins.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您只想在与客户端设置密钥交换后才能做的事情。否则，客户端将无法进行远程登录。
- en: 'For both Ubuntu and CentOS machines, look for this line in the `sshd_config`
    file:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Ubuntu和CentOS机器，查找`sshd_config`文件中的此行：
- en: '[PRE91]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Remove the comment symbol, change the parameter value to `no`, and restart
    the SSH daemon. The line should now look like this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 删除注释符号，将参数值更改为`no`，并重新启动SSH守护程序。该行现在应该是这样的：
- en: '[PRE92]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Now, when the botnets scan your system, they'll see that doing a brute-force
    password attack would be useless. They'll then just go away and leave you alone.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当僵尸网络扫描您的系统时，它们会发现进行暴力破解密码攻击是无用的。然后他们会离开并让你独自一人。
- en: Setting up a chroot environment for SFTP users
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为SFTP用户设置chroot环境
- en: '**Secure File Transfer Protocol** (**SFTP**) is a great tool for performing
    secure file transfers. There is a command-line client, but users will most likely
    use a graphical client, such as Filezilla. A common use-case for SFTP is to allow
    website owners to upload web content files to the proper content directories on
    a web server. With a default SSH setup, anyone who has a user account on a Linux
    machine can log in through either SSH or SFTP, and can navigate through the server''s
    entire filesystem. What we really want for SFTP users is to prevent them from
    logging into a command-prompt via SSH, and to confine them to their own designated
    directories.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全文件传输协议**（**SFTP**）是执行安全文件传输的好工具。有一个命令行客户端，但用户最有可能使用图形客户端，如Filezilla。 SFTP的一个常见用例是允许网站所有者将网站内容文件上传到Web服务器上的适当内容目录。使用默认的SSH设置，任何在Linux机器上有用户帐户的人都可以通过SSH或SFTP登录，并可以浏览服务器的整个文件系统。我们真正希望为SFTP用户做的是防止他们通过SSH登录到命令提示符，并将其限制在其指定的目录中。'
- en: Creating a group and configuring the sshd_config file
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建组并配置sshd_config文件
- en: With the exception of the slight difference in user-creation commands, this
    procedure works the same for either CentOS or Ubuntu. So, you can use either one
    of your virtual machines to follow along. We'll begin by creating an `sftpusers`
    group.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用户创建命令略有不同之外，此过程对于CentOS或Ubuntu都是相同的。因此，您可以使用虚拟机中的任一台来跟随操作。我们将首先创建一个`sftpusers`组。
- en: '[PRE93]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Create the user accounts, and add them to the `sftpusers` group. We''ll do
    both operations in one step. On your CentOS machine, the command for creating
    Max''s account would be:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用户帐户，并将其添加到`sftpusers`组。我们将一次完成两个操作。在您的CentOS机器上，创建Max的帐户的命令将是：
- en: '[PRE94]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'On your Ubuntu machine, it would be:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Ubuntu机器上，它将是：
- en: '[PRE95]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Open the `/etc/ssh/sshd_config` file in your favorite text editor. Find the
    line that says:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在您喜欢的文本编辑器中打开`/etc/ssh/sshd_config`文件。找到这一行：
- en: '[PRE96]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Change it to:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为：
- en: '[PRE97]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This setting allows you to disable normal SSH login for certain users.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置允许您禁用某些用户的普通SSH登录。
- en: 'At the bottom of the `sshd_config` file, add a `Match Group` stanza:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sshd_config`文件的底部，添加一个`Match Group`段落：
- en: '[PRE98]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: An important consideration here is that the `ChrootDirectory` has to be owned
    by the root user, and it can't be writable by anyone other than the root user.
    When Max logs in, he'll be in the `/home` directory, and will then have to `cd`
    into his own directory. This also means that you want for all users' home directories
    to have the restrictive `700` permissions settings, in order to keep everyone
    out of everyone else's stuff.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这里一个重要的考虑因素是`ChrootDirectory`必须由root用户拥有，并且不能被除root用户之外的任何人写入。当Max登录时，他将在`/home`目录中，然后必须`cd`进入自己的目录。这也意味着您希望所有用户的主目录都具有限制性的`700`权限设置，以防止其他人进入其他人的东西。
- en: 'Save the file and restart the SSH daemon. Then, try to log on as Max through
    normal SSH, just to see what happens:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并重新启动SSH守护程序。然后，尝试以Max的身份通过普通SSH登录，只是为了看看会发生什么：
- en: '[PRE99]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Okay, so he can''t do that. Let''s now have him try to log in through SFTP,
    and verify that he is in the `/home` directory:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，他不能这样做。现在让他尝试通过SFTP登录，并验证他是否在`/home`目录中：
- en: '[PRE100]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now, let''s see him try to `cd` out of the `/home` directory:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看他是否能够在`/home`目录之外进行`cd`操作：
- en: '[PRE101]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: So, our chroot jail does indeed work.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的chroot监狱确实有效。
- en: Hands-on lab – setting up a chroot directory for sftpusers group
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实验-为sftpusers组设置chroot目录
- en: 'For this lab, you can use either the CentOS virtual machine or the Ubuntu virtual
    machine. You''ll add a group, then configure the `sshd_config` file to allow group
    members to only be able to log in via SFTP, and to confine them to their own directories.
    For the simulated client machine, you can use the terminal of your MacOS or Linux
    desktop machine, or Cygwin from your Windows machine:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实验，您可以使用CentOS虚拟机或Ubuntu虚拟机。您将添加一个组，然后配置`sshd_config`文件，以允许组成员只能通过SFTP登录，并将他们限制在自己的目录中。对于模拟的客户端机器，您可以使用您的MacOS或Linux桌面机器的终端，或者使用您的Windows机器上的Cygwin：
- en: 'Create the `sftpusers` group:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`sftpusers`组：
- en: '[PRE102]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Create a user account for Max, and add him to the `sftpusers` group. On CentOS,
    do:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Max创建一个用户账户，并将他添加到`sftpusers`组中。在CentOS上，执行以下操作：
- en: '[PRE103]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'On Ubuntu, do:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu上，执行以下操作：
- en: '[PRE104]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'For Ubuntu, ensure that the users'' home directories are all set with read,
    write, and execute permissions for only the directory''s user. If that''s not
    the case, do:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Ubuntu，请确保用户的主目录都设置为只有目录的用户具有读取、写入和执行权限。如果不是这种情况，请执行以下操作：
- en: '[PRE105]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Open the `/etc/ssh/sshd_config` file in your preferred text editor. Find the
    line that says:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您喜欢的文本编辑器中打开`/etc/ssh/sshd_config`文件。找到以下行：
- en: '[PRE106]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Change it to:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为：
- en: '[PRE107]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'At the end of the `sshd_config` file, add the following stanza:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`sshd_config`文件的末尾，添加以下段落：
- en: '[PRE108]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Restart the SSH daemon. On CentOS, do:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动SSH守护程序。在CentOS上，执行以下操作：
- en: '[PRE109]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'On Ubuntu, do:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu上，执行以下操作：
- en: '[PRE110]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Have Max try to log in through normal SSH, to see what happens:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让Max尝试通过普通SSH登录，看看会发生什么：
- en: '[PRE111]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Now, have Max log in through SFTP. Once he''s in, have him try to `cd` out
    of the `/home` directory:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让Max通过SFTP登录。一旦他登录，让他尝试从`/home`目录中进行`cd`操作：
- en: '[PRE112]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: End of Lab.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实验结束。
- en: Summary
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've seen how to work with various encryption technologies
    that can help us safeguard our secrets. We started with GNU Privacy Guard for
    encrypting individual files. We then moved on to the disk, partition, and directory
    encryption utilities. LUKS and eCryptfs are specific to Linux, but we also looked
    at VeraCrypt, which can be used on any of the major operating systems.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到如何使用各种加密技术来保护我们的秘密。我们从GNU Privacy Guard开始，用于加密单个文件。然后我们转向磁盘、分区和目录加密实用程序。LUKS和eCryptfs专门用于Linux，但我们也看了VeraCrypt，它可以在任何主要操作系统上使用。
- en: In the next chapter, we'll take an in-depth look at the subject of discretionary
    access control. I'll see you there.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入研究自主访问控制的主题。到时候见。
