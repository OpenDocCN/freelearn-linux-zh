["```\nint init_module(void)\n{\n  /* perform required setup and registration ops */\n    ...\n    ...\n    return 0;\n}\n\nvoid cleanup_module(void)\n{\n   /* perform required cleanup operations */\n   ...\n   ...\n}\n```", "```\nint myinit(void)\n{\n        ...\n        ...\n        return 0;\n}\n\nvoid myexit(void)\n{\n        ...\n        ...\n}\n\nmodule_init(myinit);\nmodule_exit(myexit);\n```", "```\nint finit_module(int fd, const char *param_values, int flags);\nint delete_module(const char *name, int flags);\n```", "```\nSYSCALL_DEFINE3(finit_module, int, fd, const char __user *, uargs, int, flags)\n{\n        struct load_info info = { };\n        loff_t size;\n        void *hdr;\n        int err;\n\n        err = may_init_module();\n        if (err)\n                return err;\n\n        pr_debug(\"finit_module: fd=%d, uargs=%p, flags=%i\\n\", fd, uargs, flags);\n\n        if (flags & ~(MODULE_INIT_IGNORE_MODVERSIONS\n                      |MODULE_INIT_IGNORE_VERMAGIC))\n                return -EINVAL;\n\n        err = kernel_read_file_from_fd(fd, &hdr, &size, INT_MAX,\n                                       READING_MODULE);\n        if (err)\n                return err;\n        info.hdr = hdr;\n        info.len = size;\n\n        return load_module(&info, uargs, flags);\n}\n```", "```\nstatic int load_module(struct load_info *info, const char __user *uargs,int flags)\n{\n        struct module *mod;\n        long err;\n        char *after_dashes;\n\n        err = module_sig_check(info, flags);\n        if (err)\n                goto free_copy;\n\n        err = elf_header_check(info);\n        if (err)\n                goto free_copy;\n\n        /* Figure out module layout, and allocate all the memory. */\n        mod = layout_and_allocate(info, flags);\n        if (IS_ERR(mod)) {\n                err = PTR_ERR(mod);\n                goto free_copy;\n        }\n\n        ....\n        ....\n        ....\n\n}\n```", "```\nSYSCALL_DEFINE2(delete_module, const char __user *, name_user,\n                unsigned int, flags)\n{\n        struct module *mod;\n        char name[MODULE_NAME_LEN];\n        int ret, forced = 0;\n\n        if (!capable(CAP_SYS_MODULE) || modules_disabled)\n                return -EPERM;\n\n        if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)\n                return -EFAULT;\n        name[MODULE_NAME_LEN-1] = '\\0';\n\n        audit_log_kern_module(name);\n\n        if (mutex_lock_interruptible(&module_mutex) != 0)\n                return -EINTR;\n\n        mod = find_module(name);\n        if (!mod) {\n                ret = -ENOENT;\n                goto out;\n        }\n\n        if (!list_empty(&mod->source_list)) {\n                /* Other modules depend on us: get rid of them first. */\n                ret = -EWOULDBLOCK;\n                goto out;\n        }\n\n        /* Doing init or already dying? */\n        if (mod->state != MODULE_STATE_LIVE) {\n                /* FIXME: if (force), slam module count damn the torpedoes */\n                pr_debug(\"%s already dying\\n\", mod->name);\n                ret = -EBUSY;\n                goto out;\n        }\n\n        /* If it has an init func, it must have an exit func to unload */\n        if (mod->init && !mod->exit) {\n                forced = try_force_unload(flags);\n                if (!forced) {\n                        /* This module can't be removed */\n                        ret = -EBUSY;\n                        goto out;\n                }\n        }\n\n        /* Stop the machine so refcounts can't move and disable module. */\n        ret = try_stop_module(mod, flags, &forced);\n        if (ret != 0)\n                goto out;\n\n        mutex_unlock(&module_mutex);\n        /* Final destruction now no one is using it. */\n        if (mod->exit != NULL)\n                mod->exit();\n        blocking_notifier_call_chain(&module_notify_list,\n                                     MODULE_STATE_GOING, mod);\n        klp_module_going(mod);\n        ftrace_release_mod(mod);\n\n        async_synchronize_full();\n\n        /* Store the name of the last unloaded module for diagnostic purposes */\n        strlcpy(last_unloaded_module, mod->name, sizeof(last_unloaded_module));\n\n        free_module(mod);\n        return 0;\nout:\n        mutex_unlock(&module_mutex);\n        return ret;\n}\n```", "```\n/* Free a module, remove from lists, etc. */\nstatic void free_module(struct module *mod)\n{\n        trace_module_free(mod);\n\n        mod_sysfs_teardown(mod);\n\n        /* We leave it in list to prevent duplicate loads, but make sure\n        * that no one uses it while it's being deconstructed. */\n        mutex_lock(&module_mutex);\n        mod->state = MODULE_STATE_UNFORMED;\n        mutex_unlock(&module_mutex);\n\n        /* Remove dynamic debug info */\n        ddebug_remove_module(mod->name);\n\n        /* Arch-specific cleanup. */\n        module_arch_cleanup(mod);\n\n        /* Module unload stuff */\n        module_unload_free(mod);\n\n        /* Free any allocated parameters. */\n        destroy_params(mod->kp, mod->num_kp);\n\n        if (is_livepatch_module(mod))\n                free_module_elf(mod);\n\n        /* Now we can delete it from the lists */\n        mutex_lock(&module_mutex);\n        /* Unlink carefully: kallsyms could be walking list. */\n        list_del_rcu(&mod->list);\n        mod_tree_remove(mod);\n        /* Remove this module from bug list, this uses list_del_rcu */\n        module_bug_cleanup(mod);\n        /* Wait for RCU-sched synchronizing before releasing mod->list and buglist. */\n        synchronize_sched();\n        mutex_unlock(&module_mutex);\n\n        /* This may be empty, but that's OK */\n        disable_ro_nx(&mod->init_layout);\n        module_arch_freeing_init(mod);\n        module_memfree(mod->init_layout.base);\n        kfree(mod->args);\n        percpu_modfree(mod);\n\n        /* Free lock-classes; relies on the preceding sync_rcu(). */\n        lockdep_free_key_range(mod->core_layout.base, mod->core_layout.size);\n\n        /* Finally, free the core (containing the module structure) */\n        disable_ro_nx(&mod->core_layout);\n        module_memfree(mod->core_layout.base);\n\n#ifdef CONFIG_MPU\n        update_protections(current->mm);\n#endif\n}\n```", "```\nstruct module {\n        enum module_state state;\n\n        /* Member of list of modules */\n        struct list_head list;\n\n        /* Unique handle for this module */\n        char name[MODULE_NAME_LEN];\n\n        /* Sysfs stuff. */\n        struct module_kobject mkobj;\n        struct module_attribute *modinfo_attrs;\n        const char *version;\n        const char *srcversion;\n        struct kobject *holders_dir;\n\n        /* Exported symbols */\n        const struct kernel_symbol *syms;\n        const s32 *crcs;\n        unsigned int num_syms;\n\n        /* Kernel parameters. */\n#ifdef CONFIG_SYSFS\n        struct mutex param_lock;\n#endif\n        struct kernel_param *kp;\n        unsigned int num_kp;\n\n        /* GPL-only exported symbols. */\n        unsigned int num_gpl_syms;\n        const struct kernel_symbol *gpl_syms;\n        const s32 *gpl_crcs;\n\n#ifdef CONFIG_UNUSED_SYMBOLS\n        /* unused exported symbols. */\n        const struct kernel_symbol *unused_syms;\n        const s32 *unused_crcs;\n        unsigned int num_unused_syms;\n\n        /* GPL-only, unused exported symbols. */\n        unsigned int num_unused_gpl_syms;\n        const struct kernel_symbol *unused_gpl_syms;\n        const s32 *unused_gpl_crcs;\n#endif\n\n#ifdef CONFIG_MODULE_SIG\n        /* Signature was verified. */\n        bool sig_ok;\n#endif\n\n        bool async_probe_requested;\n\n        /* symbols that will be GPL-only in the near future. */\n        const struct kernel_symbol *gpl_future_syms;\n        const s32 *gpl_future_crcs;\n        unsigned int num_gpl_future_syms;\n\n        /* Exception table */\n        unsigned int num_exentries;\n        struct exception_table_entry *extable;\n\n        /* Startup function. */\n        int (*init)(void);\n\n        /* Core layout: rbtree is accessed frequently, so keep together. */\n        struct module_layout core_layout __module_layout_align;\n        struct module_layout init_layout;\n\n        /* Arch-specific module values */\n        struct mod_arch_specific arch;\n\n        unsigned long taints;     /* same bits as kernel:taint_flags */\n\n#ifdef CONFIG_GENERIC_BUG\n        /* Support for BUG */\n        unsigned num_bugs;\n        struct list_head bug_list;\n        struct bug_entry *bug_table;\n#endif\n\n#ifdef CONFIG_KALLSYMS\n        /* Protected by RCU and/or module_mutex: use rcu_dereference() */\n        struct mod_kallsyms *kallsyms;\n        struct mod_kallsyms core_kallsyms;\n\n        /* Section attributes */\n        struct module_sect_attrs *sect_attrs;\n\n        /* Notes attributes */\n        struct module_notes_attrs *notes_attrs;\n#endif\n\n        /* The command line arguments (may be mangled).  People like\n          keeping pointers to this stuff */\n        char *args;\n\n#ifdef CONFIG_SMP\n        /* Per-cpu data. */\n        void __percpu *percpu;\n        unsigned int percpu_size;\n#endif\n\n#ifdef CONFIG_TRACEPOINTS\n        unsigned int num_tracepoints;\n        struct tracepoint * const *tracepoints_ptrs;\n#endif\n#ifdef HAVE_JUMP_LABEL\n        struct jump_entry *jump_entries;\n        unsigned int num_jump_entries;\n#endif\n#ifdef CONFIG_TRACING\n        unsigned int num_trace_bprintk_fmt;\n        const char **trace_bprintk_fmt_start;\n#endif\n#ifdef CONFIG_EVENT_TRACING\n        struct trace_event_call **trace_events;\n        unsigned int num_trace_events;\n        struct trace_enum_map **trace_enums;\n        unsigned int num_trace_enums;\n#endif\n#ifdef CONFIG_FTRACE_MCOUNT_RECORD\n        unsigned int num_ftrace_callsites;\n        unsigned long *ftrace_callsites;\n#endif\n\n#ifdef CONFIG_LIVEPATCH\n        bool klp; /* Is this a livepatch module? */\n        bool klp_alive;\n\n        /* Elf information */\n        struct klp_modinfo *klp_info;\n#endif\n\n#ifdef CONFIG_MODULE_UNLOAD\n        /* What modules depend on me? */\n        struct list_head source_list;\n        /* What modules do I depend on? */\n        struct list_head target_list;\n\n        /* Destruction function. */\n        void (*exit)(void);\n\n        atomic_t refcnt;\n#endif\n\n#ifdef CONFIG_CONSTRUCTORS\n        /* Constructor functions. */\n        ctor_fn_t *ctors;\n        unsigned int num_ctors;\n#endif\n} ____cacheline_aligned;\n```", "```\nenum module_state {\n        MODULE_STATE_LIVE,        /* Normal state. */\n        MODULE_STATE_COMING,      /* Full formed, running module_init. */\n        MODULE_STATE_GOING,       /* Going away. */\n        MODULE_STATE_UNFORMED,    /* Still setting it up. */\n};\n```", "```\nstruct module_layout {\n        /* The actual code + data. */\n        void *base;\n        /* Total size. */\n        unsigned int size;\n        /* The size of the executable code.  */\n        unsigned int text_size;\n        /* Size of RO section of the module (text+rodata) */\n        unsigned int ro_size;\n\n#ifdef CONFIG_MODULES_TREE_LOOKUP\n        struct mod_tree_node mtn;\n#endif\n};\n```"]