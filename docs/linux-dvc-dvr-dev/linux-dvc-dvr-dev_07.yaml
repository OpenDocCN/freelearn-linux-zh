- en: I2C Client Drivers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I2C客户端驱动程序
- en: 'I2C bus, invented by Philips (now NXP) is a two-wire: **Serial Data** (**SDA**
    ), **Serial Clock** (**SCL** ) asynchronous serial bus. It is a multi-master bus,
    though multi-master mode is not widely used. Both SDA and SCL are open drain/open
    collector, meaning that each of these can drive its output low, but none of these
    can drive its output high without having pull-up resistors. SCL is generated by
    the master in order to synchronize data (carried by SDA) transfer over the bus.
    Both slave and master can send data (not at the same time of course), thus making
    SDA a bidirectional line. That said the SCL signal is also bidirectional, since
    slave can stretch the clock by keeping the SCL line low. The bus is controlled
    by the master, which in our case is a part of the SoC. This bus is frequently
    used in embedded systems to connect serial EEPROM, RTC chips, GPIO expander, temperature
    sensors, and so on:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由飞利浦（现在是NXP）发明的I2C总线是一种双线：**串行数据**（**SDA**），**串行时钟**（**SCL**）异步串行总线。它是一个多主总线，尽管多主模式并不广泛使用。SDA和SCL都是开漏/开集电器，这意味着它们中的每一个都可以将其输出拉低，但没有一个可以在没有上拉电阻的情况下将其输出拉高。SCL由主机生成，以同步通过总线传输的数据（由SDA携带）。从机和主机都可以发送数据（当然不是同时），从而使SDA成为双向线。也就是说，SCL信号也是双向的，因为从机可以通过保持SCL线低来拉伸时钟。总线由主机控制，而在我们的情况下，主机是SoC的一部分。这种总线经常用于嵌入式系统，用于连接串行EEPROM、RTC芯片、GPIO扩展器、温度传感器等等：
- en: '![](img/Image00012.gif)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00012.gif)'
- en: I2C bus and devices
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: I2C总线和设备
- en: Clock speed varies from 10 KHz to 100 KHz, and 400 KHz to 2 MHz. We will not
    cover bus specifications or bus drivers in this book. However, it is up to the
    bus driver to manage the bus and take care of the specifications. An example of
    a bus driver for the i.MX6 chip can be found at `drivers/i2C/busses/i2c-imx.c`
    in kernel source, and I2C specifications can be found at [http://www.nxp.com/documents/user_manual/UM10204.pdf](http://www.nxp.com/documents/user_manual/UM10204.pdf)
    .
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟速度从10 KHz到100 KHz，400 KHz到2 MHz不等。我们不会在本书中涵盖总线规格或总线驱动程序。然而，总线驱动程序负责管理总线并处理规格。例如，i.MX6芯片的总线驱动程序的示例可以在内核源代码的`drivers/i2C/busses/i2c-imx.c`中找到，I2C规格可以在[http://www.nxp.com/documents/user_manual/UM10204.pdf](http://www.nxp.com/documents/user_manual/UM10204.pdf)中找到。
- en: 'In this chapter, we are interested in client drivers, in order to handle slave
    devices seated on the bus. The chapter will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对客户端驱动程序感兴趣，以处理坐在总线上的从设备。本章将涵盖以下主题：
- en: I2C client driver architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I2C客户端驱动程序架构
- en: Accessing the device, thus reading/writing data from/to device
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问设备，因此从/向设备读取/写入数据
- en: Declaring clients from DT
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从DT中声明客户端
- en: The driver architecture
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动程序架构
- en: When the device for which you write the driver takes a seat on a physical bus
    called the *bus controller* , it must rely on the driver of that bus called the
    *controller driver* , responsible for sharing bus access between devices. The
    controller driver offers an abstraction layer between your device and the bus.
    Whenever you perform a transaction (read or write) on an I2C or USB bus for example,
    the I2C/USB bus controller transparently takes care of that in the background.
    Every bus controller driver exports a set of functions to ease the development
    of drivers for devices sitting on that bus. This works for every physical bus
    (I2C, SPI, USB, PCI, SDIO, and so on).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当您为其编写驱动程序的设备坐在称为*总线控制器*的物理总线上时，它必须依赖于称为*控制器驱动程序*的总线的驱动程序，负责在设备之间共享总线访问。控制器驱动程序在您的设备和总线之间提供了一个抽象层。每当您在I2C或USB总线上执行事务（读或写）时，例如，I2C/USB总线控制器会在后台自动处理。每个总线控制器驱动程序都导出一组函数，以便为坐在该总线上的设备开发驱动程序。这适用于每个物理总线（I2C、SPI、USB、PCI、SDIO等）。
- en: An I2C driver is represented in the kernel as an instance of `struct i2c_driver`
    . The I2C client (which represents the device itself) is represented by a `struct
    i2c_client` structure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: I2C驱动程序在内核中表示为 `struct i2c_driver` 的实例。I2C客户端（代表设备本身）由 `struct i2c_client` 结构表示。
- en: The i2c_driver structure
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: i2c_driver结构
- en: 'An I2C driver is declared in kernel as an instance of `struct i2c_driver,`
    which looks as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核中，I2C驱动程序被声明为`struct i2c_driver`的实例，其外观如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `struct i2c_driver` structure contains and characterizes general access
    routines, needed to handle the devices claiming the driver, whereas `struct i2c_client`
    contains device-specific information, like its address. A `struct i2c_client`
    structure represents and characterizes an I2C device. Later in this chapter, we
    will see how to populate these structures.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct i2c_driver` 结构包含和表征了通用访问例程，需要处理声称驱动程序的设备，而 `struct i2c_client` 包含设备特定信息，比如它的地址。`struct
    i2c_client` 结构代表和表征了一个I2C设备。在本章的后面，我们将看到如何填充这些结构。'
- en: The probe() function
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: probe()函数
- en: 'The `probe()` function is a part of the `struct i2c_driver` structure, and
    is executed any time once an I2C device is instantiated. It is responsible for
    the following tasks:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`probe()`函数是`struct i2c_driver`结构的一部分，一旦实例化了一个I2C设备，它就会被执行。它负责以下任务：'
- en: Check whether the device is the one you expected
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查设备是否是您期望的设备
- en: Check whether your I2C bus controller of the SoC supports the functionality
    needed by your device, using the `i2c_check_functionality` function
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`i2c_check_functionality`函数检查SoC的I2C总线控制器是否支持设备所需的功能
- en: Initialize the device
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化设备
- en: Set up device specific data
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置设备特定数据
- en: Register the appropriate kernel framework
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册适当的内核框架
- en: 'The `probe` function''s prototype is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`probe` 函数的原型如下：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, its parameters are:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它的参数是：
- en: '`struct i2c_client` pointer: This represents the I2C device itself. This structure
    inherits from the structure device, and is provided to your `probe` function by
    the kernel. The client structure is defined in `include/linux/i2c.h` . Its definition
    is as follows:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct i2c_client` 指针：这代表I2C设备本身。这个结构继承自设备结构，并由内核提供给您的`probe`函数。客户端结构在`include/linux/i2c.h`中定义。它的定义如下：'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All fields are filled by the kernel, based on the parameter you provided to
    register the client. We will see later how to register a device to the kernel.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有字段都由内核填充，基于您提供的参数来注册客户端。我们稍后将看到如何向内核注册设备。
- en: '`struct i2c_device_id` pointer: This points to the I2C device ID entry that
    matched the device that is being probed.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct i2c_device_id`指针：这指向与正在被探测的设备匹配的I2C设备ID条目。'
- en: Per-device data
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个设备的数据
- en: 'The I2C core offers you the possibility to store a pointer to any data structure
    of your choice, as device-specific data. To store or retrieve the data, use the
    following function provided by the I2C core:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: I2C核心为您提供了将指针存储到您选择的任何数据结构中的可能性，作为特定于设备的数据。要存储或检索数据，请使用I2C核心提供的以下函数：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These functions internally call `dev_set_drvdata` and `dev_get_drvdata` to update
    or get the value of the `void *driver_data` field of the `struct device` substructure
    in the `struct i2c_client` structure.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数内部调用`dev_set_drvdata`和`dev_get_drvdata`来更新或获取`struct i2c_client`结构中`struct
    device`子结构的`void *driver_data`字段的值。
- en: This is an example of how to use extra client data; an excerpt from `drivers/gpio/gpio-mc9s08dz60.c:`
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个如何使用额外客户数据的例子；摘自`drivers/gpio/gpio-mc9s08dz60.c:`
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Actually, these functions are not really specific to I2C. They do nothing but
    get/set the `void *driver_data` pointer that is a member of the `struct device`
    , and itself is a member of `struct i2c_client` . In fact, we could have used
    `dev_get_drvdata` and `dev_set_drvdata` directly. One can see their definitions
    in `linux/include/linux/i2c.h` .
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这些函数并不真正特定于I2C。它们只是获取/设置`struct device`的`void *driver_data`指针，它本身是`struct
    i2c_client`的成员。实际上，我们可以直接使用`dev_get_drvdata`和`dev_set_drvdata`。可以在`linux/include/linux/i2c.h`中看到它们的定义。
- en: The remove() function
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`remove()`函数'
- en: 'The prototype of the `remove` function looks as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`函数的原型如下：'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `remove()` function also provides the same `struct i2c_client*` as the
    `probe()` function, so you can retrieve your private data. For example, you may
    need to process some cleaning or any other stuff, based on the private data you
    set up in the `probe` function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()`函数还提供与`probe()`函数相同的`struct i2c_client*`，因此您可以检索您的私有数据。例如，您可能需要根据您在`probe`函数中设置的私有数据进行一些清理或其他操作：'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `remove` function has the responsibility to unregister us from the subsystem
    where we have registered in the `probe()` function. In the preceding example,
    we simply remove the `gpiochip` from the kernel.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`函数负责从我们在`probe()`函数中注册的子系统中注销我们。在上面的例子中，我们只是从内核中移除`gpiochip`。'
- en: Driver initialization and registration
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动程序初始化和注册
- en: 'When one''s module gets loaded, one may need to do some initializing. Most
    of the time, just registering the driver with the I2C core will be sufficient.
    At the same time, when the module is unloaded, we will usually just need to get
    ourselves out from the I2C core. In [chapter 5](text00146.html) , *Platform Device
    Drivers* we saw that it is not worth while to bother ourselves by using init/exit
    functions, but to use `module_*_driver` functions instead. In this case, the function
    to use is:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当模块加载时，可能需要进行一些初始化。大多数情况下，只需向I2C核心注册驱动程序即可。同时，当模块被卸载时，通常只需要从I2C核心中移除自己。在[第5章](text00146.html)，*平台设备驱动程序*中，我们看到使用init/exit函数并不值得，而是使用`module_*_driver`函数。在这种情况下，要使用的函数是：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Driver and device provisioning
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动程序和设备供应
- en: As we have seen in matching mechanisms, we need to provide a `device_id` array
    in order to expose devices that our driver can manage. Since we are talking about
    I2C devices, the structure would be `i2c_device_id` . That array will inform the
    kernel about the devices that we are interested in, in the driver.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在匹配机制中看到的，我们需要提供一个`device_id`数组，以便公开我们的驱动程序可以管理的设备。由于我们谈论的是I2C设备，结构将是`i2c_device_id`。该数组将向内核通知我们对驱动程序中感兴趣的设备。
- en: 'Now back to our I2C device driver; having a look in `include/linux/mod_devicetable.h`
    , you will see how `struct i2c_device_id` is defined:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到我们的I2C设备驱动程序；在`include/linux/mod_devicetable.h`中查看，您将看到`struct i2c_device_id`的定义：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That said, the `struct i2c_device_id` must be embedded in a `struct i2c_driver`
    . In order to let the I2C core (for module auto-loading) know about devices we
    need to handle, we must use the `MODULE_DEVICE_TABLE` macro. The kernel has to
    be aware of which `probe` or `remove` function to call whenever a match occurs,
    which is why our `probe` and `remove` functions must also be embedded in the same
    `i2c_driver` structure:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，`struct i2c_device_id`必须嵌入在`struct i2c_driver`中。为了让I2C核心（用于模块自动加载）知道我们需要处理的设备，我们必须使用`MODULE_DEVICE_TABLE`宏。内核必须知道每当发生匹配时调用哪个`probe`或`remove`函数，这就是为什么我们的`probe`和`remove`函数也必须嵌入在同一个`i2c_driver`结构中：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Accessing the client
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问客户端
- en: Serial bus transactions are just a matter of accessing registers to set/get
    their content. I2C respects that principle. I2C core provides two kind of API,
    one for plain I2C communications, and another for SMBUS compatible device, which
    also works with I2C devices, but not the reverse.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 串行总线事务只是访问寄存器以设置/获取其内容。I2C遵守这一原则。I2C核心提供了两种API，一种用于普通的I2C通信，另一种用于与SMBUS兼容设备通信，它也适用于I2C设备，但反之则不然。
- en: Plain I2C communication
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 普通I2C通信
- en: 'The following are essential functions one usually deal with when talking to
    I2C devices:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是通常在与I2C设备通信时处理的基本函数：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Almost all I2C communication functions take a `struct i2c_client` as the first
    parameter. The second parameter contains the bytes to read or write and the third
    represents the number of bytes to read or write. Like any read/write function,
    the returned value is the number of bytes being read/written. One can also process
    message transfers with:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有I2C通信函数的第一个参数都是`struct i2c_client`。第二个参数包含要读取或写入的字节，第三个表示要读取或写入的字节数。与任何读/写函数一样，返回的值是读取/写入的字节数。还可以使用以下函数处理消息传输：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`i2c_transfer` sends a set of messages where each can be either a read or a
    write operation, and can be mixed in any way. Remember that there is no stop bit
    between each transaction. Looking at `include/uapi/linux/i2c.h` , a message structure
    looks as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2c_transfer`发送一组消息，每个消息可以是读取或写入操作，并且可以以任何方式混合。请记住，每个事务之间没有停止位。查看`include/uapi/linux/i2c.h`，消息结构如下：'
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `i2c_msg` structure describes and characterizes an I2C message. It must
    contain, for each message, the client address, the number of bytes of the message,
    and the message payload.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2c_msg`结构描述和表征了一个I2C消息。对于每个消息，它必须包含客户端地址、消息的字节数和消息有效载荷。'
- en: '`msg.len` is a `u16` . It means you must always be less than 2^(16) (64k) with
    your read/write buffers.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`msg.len`是`u16`。这意味着您的读/写缓冲区的长度必须始终小于2^(16)（64k）。'
- en: Let us have a look at the `read` function for the microchip I2C 24LC512eeprom
    character driver; we should understand how things really work. The full code is
    provided with the source of this book.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下微芯片I2C 24LC512eeprom字符驱动程序的`read`函数；我们应该了解事物是如何真正工作的。本书的源代码中提供了完整的代码。
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`msg.flags` should be `I2C_M_RD` for a read and `0` for a write transaction.
    Sometimes, you may not want to create `struct i2c_msg` but just process simple
    read and write.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`msg.flags`应为`I2C_M_RD`表示读取，`0`表示写入事务。有时，您可能不想创建`struct i2c_msg`，而只是进行简单的读取和写入。'
- en: System Management Bus (SMBus) compatible functions
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统管理总线（SMBus）兼容函数
- en: SMBus is a two-wire bus developed by Intel, and very similar to I2C. I2C devices
    are SMBus-compatible, but not the reverse. Therefore, it is better to use SMBus
    functions if one has a doubt about the chip one is writing the driver for.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: SMBus是由英特尔开发的双线总线，与I2C非常相似。I2C设备是SMBus兼容的，但反之则不然。因此，如果对于正在为其编写驱动程序的芯片有疑问，最好使用SMBus函数。
- en: 'The following shows some of the SMBus API:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了一些SMBus API：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Have a look in `include/linux/i2c.h` and `drivers/i2c/i2c-core.c` in the kernel
    sources for more explanation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多解释，请查看内核源代码中的`include/linux/i2c.h`和`drivers/i2c/i2c-core.c`。
- en: 'The following example shows a simple read/write operation in an I2C gpio expander:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了在I2C gpio扩展器中进行简单的读/写操作：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Instantiating I2C devices in the board configuration file (old and depreciated
    way)
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在板配置文件中实例化I2C设备（旧的和不推荐的方法）
- en: 'We must inform the kernel about which devices are physically present on the
    system. There are two ways to achieve that. In the DT, as we will see later in
    the chapter, or through the board configuration file (which is the old and depreciated
    way). Let us see how to do that in the board configuration file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须告知内核系统上物理存在哪些设备。有两种方法可以实现。在DT中，正如我们将在本章后面看到的，或者通过板配置文件（这是旧的和不推荐的方法）。让我们看看如何在板配置文件中实现这一点：
- en: '`struct i2c_board_info` is the structure used to represent an I2C device on
    our board. The structure is defined as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct i2c_board_info`是用于表示我们板上的I2C设备的结构。该结构定义如下：'
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Once again, elements not relevant for us have been removed from the structure.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们已经从结构中删除了对我们不相关的元素。
- en: 'In the preceding structure, `type` should contain the same value as defined
    in the device driver in the `i2c_driver.driver.name` field. You will then need
    to fill an array of `i2c_board_info` and pass it as a parameter to the `i2c_register_board_info`
    function in the board init routine:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述结构中，`type`应包含与设备驱动程序中的`i2c_driver.driver.name`字段中定义的相同值。然后，您需要填充一个`i2c_board_info`数组，并将其作为参数传递给板初始化例程中的`i2c_register_board_info`函数：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, `busnum` is the bus number the devices sit on. This is an old and depreciated
    method, so I'll not go further into it in this book. Feel free to have a look
    at *Documentation/i2c/instantiating-devices* in the kernel sources to see how
    things are done.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`busnum`是设备所在的总线编号。这是一种旧的和不推荐的方法，因此我不会在本书中进一步介绍。请随时查看内核源代码中的*Documentation/i2c/instantiating-devices*，以了解如何完成这些操作。
- en: I2C and the device tree
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I2C和设备树
- en: 'As we have seen in the preceding sections, in order to configure I2C devices,
    there are essentially two steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中所看到的，为了配置I2C设备，基本上有两个步骤：
- en: Define and register the I2C driver
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和注册I2C驱动程序
- en: Define and register the I2C devices
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和注册I2C设备
- en: I2C devices belong to nonmemory mapped devices family in the DT, and I2C bus
    is an addressable bus (by addressable, I mean you can address a specific device
    on the bus). In this, the `reg` property in the device node represents the device
    address on the bus.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: I2C设备属于DT中的非内存映射设备系列，而I2C总线是可寻址总线（通过可寻址，我是指您可以在总线上寻址特定设备）。在这种情况下，设备节点中的`reg`属性表示总线上的设备地址。
- en: I2C device nodes are all children of the bus node they seat on. Each device
    is assigned only an address. There is no length or range involved. Standard properties
    one needs to declare for I2C devices are `reg` , which represents the address
    of the device on the bus, and the `compatible` string, which is used to match
    the device with a driver. For more information on addressing, you can refer to
    [Chapter 6](text00162.html) , *The Concept of Device Tree* .
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: I2C设备节点都是它们所在总线节点的子节点。每个设备只分配一个地址。没有长度或范围的涉及。I2C设备需要声明的标准属性是`reg`，表示设备在总线上的地址，以及`compatible`字符串，用于将设备与驱动程序匹配。有关寻址的更多信息，可以参考[第6章](text00162.html)，*设备树的概念*。
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding sample declares an HDMI EDID chip at address 0x50, on SoC's I2C
    bus number 2, and a **real time clock** (**RTC** ), at address 0x68 on the same
    bus.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例声明了SoC的I2C总线编号2上地址为0x50的HDMI EDID芯片，以及在同一总线上地址为0x68的**实时时钟**（**RTC**）。
- en: Defining and registering the I2C driver
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和注册I2C驱动程序
- en: 'What we have seen so far does not change. The extra thing we need is to define
    a `struct of_device_id` . `Struct of_device_id` defined to match the corresponding
    node in the `.dts` file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的并没有改变。我们需要额外的是定义一个`struct of_device_id`。`Struct of_device_id`定义为匹配`.dts`文件中相应节点的结构：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we define the `i2c_driver` as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义`i2c_driver`如下：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'One can then improve the `probe` function this way:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以通过以下方式改进`probe`函数：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Remark
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备注
- en: 'For kernel versions older than 4.10, if one looks at `drivers/i2c/i2c-core.c`
    , in the `i2c_device_probe()` function (for information, it is the function the
    kernel calls every time an I2C device is registered to the I2C core), one will
    see something like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于早于4.10的内核版本，如果查看`drivers/i2c/i2c-core.c`，在`i2c_device_probe()`函数中（供参考，这是内核每次向I2C核心注册I2C设备时调用的函数），将看到类似于以下内容：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This means that even if one does not need to use the `.id_table` , it is mandatory
    in the driver. In fact, one can use the OF match style only, but cannot get rid
    of `.id_table` . Kernel developers tried to remove the need for `.id_table` and
    exclusively use `.of_match_table` for device matching. The patch is available
    at this URL: [https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=c80f52847c50109ca248c22efbf71ff10553dca4](https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=c80f52847c50109ca248c22efbf71ff10553dca4)
    .'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着即使一个人不需要使用`.id_table`，在驱动程序中也是强制性的。实际上，可以只使用OF匹配样式，但不能摆脱`.id_table`。内核开发人员试图消除对`.id_table`的需求，并专门使用`.of_match_table`进行设备匹配。补丁可以在此URL找到：[https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=c80f52847c50109ca248c22efbf71ff10553dca4](https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=c80f52847c50109ca248c22efbf71ff10553dca4)。
- en: 'Nevertheless, regressions have been found and the commit was reverted. Have
    a look here for details: [https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=661f6c1cd926c6c973e03c6b5151d161f3a666ed](https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=661f6c1cd926c6c973e03c6b5151d161f3a666ed)
    . This has been fixed since kernel version >= 4.10\. The fix looks as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，已经发现了回归问题，并且提交已被撤销。有关详细信息，请查看此处：[https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=661f6c1cd926c6c973e03c6b5151d161f3a666ed](https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=661f6c1cd926c6c973e03c6b5151d161f3a666ed)。自内核版本>=
    4.10以来，已经修复了此问题。修复如下：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In other words, one must define both `.id_table` and `.of_match_table` for the
    I2C driver, otherwise your device will not be probed for kernel version 4.10 or
    earlier.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，对于I2C驱动程序，必须同时定义`.id_table`和`.of_match_table`，否则您的设备将无法在内核版本4.10或更早版本中进行探测。
- en: Instantiating I2C devices in the device tree - the new way
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在设备树中实例化I2C设备-新方法
- en: '`struct i2c_client` is the structure used to describe the I2C device. However,
    with OF style, this structure could not be defined in the board file anymore.
    The only thing we need to do is provide the device''s information in the DT and
    the kernel will build one from it.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct i2c_client`是用于描述I2C设备的结构。但是，使用OF样式，这个结构不再能在板文件中定义。我们需要做的唯一的事情就是在DT中提供设备的信息，内核将根据此信息构建一个设备。'
- en: 'The following code shows how we can declare our I2C `foobar` device node in
    a `dts` file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何在`dts`文件中声明我们的I2C `foobar`设备节点：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Putting it all together
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容放在一起
- en: 'To summarize the steps needed to write I2C client drivers, you need to:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 总结编写I2C客户端驱动程序所需的步骤：
- en: Declare device ids supported by the driver. You can do that using `i2c_device_id`
    . If DT is supported, use `of_device_id` too.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明驱动程序支持的设备ID。您可以使用`i2c_device_id`来实现。如果支持DT，也可以使用`of_device_id`。
- en: Call `MODULE_DEVICE_TABLE(i2c, my_id_table` to register your device list with
    the I2C core. If device tree is supported, you must call `MODULE_DEVICE_TABLE(of,
    your_of_match_table)` to register your device list with the OF core.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`MODULE_DEVICE_TABLE(i2c, my_id_table)`将设备列表注册到I2C核心。如果支持设备树，必须调用`MODULE_DEVICE_TABLE(of,
    your_of_match_table)`将设备列表注册到OF核心。
- en: Write the `probe` and `remove` functions according to their respective prototypes.
    If needed, write power management functions too. The `probe` function must identify
    your device, configure it, define per-device (private) data, and register with
    the appropriate kernel framework. The driver's behavior depends on what you have
    done in the `probe` function. The `remove` function must undo everything you have
    done in the `probe` function (free memory and unregister from any framework).
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据各自的原型编写`probe`和`remove`函数。如果需要，还要编写电源管理函数。`probe`函数必须识别您的设备，配置它，定义每个设备（私有）数据，并向适当的内核框架注册。驱动程序的行为取决于您在`probe`函数中所做的事情。`remove`函数必须撤消您在`probe`函数中所做的一切（释放内存并从任何框架中注销）。
- en: Declare and fill a `struct i2c_driver` structure and set the `id_table` field
    with the array of ids you have created. Set `.probe` and `.remove` fields with
    the name of the corresponding function you have written above. In the .`driver`
    substructure, set the `.owner` field to `THIS_MODULE` , set the driver name, and
    finally, set the `.of_match_table` field with the array of `of_device_id` if DT
    is supported.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并填充`struct i2c_driver`结构，并使用您创建的id数组设置`id_table`字段。使用上面编写的相应函数的名称设置`.probe`和`.remove`字段。在`.driver`子结构中，将`.owner`字段设置为`THIS_MODULE`，设置驱动程序名称，最后，如果支持DT，则使用`of_device_id`数组设置`.of_match_table`字段。
- en: 'Call the `module_i2c_driver` function with your `i2c_driver` structure that
    you just filled above: `module_i2c_driver(serial_eeprom_i2c_driver)` in order
    to register your driver with the kernel.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用刚刚填写的`i2c_driver`结构调用`module_i2c_driver`函数：`module_i2c_driver(serial_eeprom_i2c_driver)`，以便将驱动程序注册到内核中。
- en: Summary
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We just dealt with I2C device drivers. It is time for you to pick any I2C device
    on the market and write the corresponding driver, with DT support. This chapter
    talked about the kernel I2C core and associated API, including device tree support,
    to give you the necessary skills to talk with I2C devices. You should be able
    to write efficient `probe` functions and register with the kernel I2C core. In
    the next chapter, we will use skills we learned here to develop the SPI device
    driver.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚处理了I2C设备驱动程序。现在是时候选择市场上的任何I2C设备并编写相应的驱动程序，支持DT。本章讨论了内核I2C核心和相关API，包括设备树支持，以便为您提供与I2C设备通信所需的技能。您应该能够编写高效的`probe`函数并向内核I2C核心注册。在下一章中，我们将使用在这里学到的技能来开发SPI设备驱动程序。
