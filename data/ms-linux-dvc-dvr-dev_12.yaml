- en: '*Chapter 10*: Linux Kernel Power Management'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：Linux内核功耗管理'
- en: Mobile devices are becoming increasingly complex with more and more features
    in order to follow commercial trends and satisfy consumers. While a few parts
    of such devices run proprietary or bare metal software, most of them run Linux-based
    operating systems (embedded Linux distributions, Android, to name but a few),
    and all of them are battery powered. In addition to full functionality and performance,
    consumers require the longest possible autonomy and long-lasting batteries. It
    goes without saying that full performance and autonomy (power saving) are two
    totally incompatible concepts, and that a compromise must be found at all times
    when using the device. This compromise comes with Power Management, which allows
    us to deal with the lower consumption possible and device performance without
    ignoring the time needed for the device to wake up (or to be fully operational)
    after it has been put in a low-power state.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备变得越来越复杂，具有越来越多的功能，以追随商业趋势并满足消费者的需求。虽然这些设备的一些部分运行专有或裸机软件，但它们大多数运行基于Linux的操作系统（嵌入式Linux发行版，Android等），并且全部都是由电池供电。除了完整的功能和性能外，消费者需要尽可能长的自主时间和持久的电池。毫无疑问，完整的性能和自主时间（节能）是两个完全不兼容的概念，必须在使用设备时始终找到一个折衷方案。这种折衷方案就是功耗管理，它允许我们在不忽视设备进入低功耗状态后唤醒（或完全运行）所需的时间的情况下处理尽可能低的功耗和设备性能。
- en: The Linux kernel comes with several power management capabilities, ranging from
    allowing you to save power during brief idle periods (or execution of tasks with
    lower power demands) to putting the whole system into a sleep state when it is
    not actively in use.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核配备了几种功耗管理功能，从允许您在短暂的空闲期间节省电力（或执行功耗较低的任务）到在系统不活跃使用时将整个系统置于睡眠状态。
- en: Additionally, as and when devices are added to the system, they can participate
    in this power management effort thanks to the generic Power Management APIs that
    the Linux kernel offers in order to allow device driver developers to benefit
    from power management mechanisms implemented in devices, whatever they are. This
    allows either a per-device or system-wide power parameters to be adjusted in order
    to extend not only the autonomy of the device, but also the lifetime of the battery.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着设备被添加到系统中，它们可以通过Linux内核提供的通用功耗管理API参与功耗管理工作，以便允许设备驱动程序开发人员从设备中实现的功耗管理机制中受益。这允许调整每个设备或整个系统的功耗参数，以延长设备的自主时间和电池的寿命。
- en: 'In this chapter, we will walk through the Linux kernel power management subsystem,
    leveraging its APIs and managing its options from user space. Hence, the following
    topics will be covered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入了解Linux内核功耗管理子系统，利用其API并从用户空间管理其选项。因此，将涵盖以下主题：
- en: The concept of power management on Linux-based systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于Linux的系统上的功耗管理概念
- en: Adding power management capabilities to device drivers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向设备驱动程序添加功耗管理功能
- en: Being a source of system wakeup
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为系统唤醒的源头
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For a better understanding of this chapter, you’ll require the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解本章，您需要以下内容：
- en: Basic electrical knowledge
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的电气知识
- en: Basic C programming skills
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的C编程技能
- en: Good knowledge of computer architecture
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的计算机架构知识
- en: Linux Kernel 4.19 sources available at [https://github.com/torvalds/linux](https://github.com/torvalds/linux)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核4.19源代码可在[https://github.com/torvalds/linux](https://github.com/torvalds/linux)上找到
- en: The concept of power management on Linux-based systems
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Linux的系统上的功耗管理概念
- en: '**Power management** (**PM**) entails consuming as little power as possible
    at any time. There are two types of power management that the operating system
    must handle: **Device Power Management** and **System Power Management**.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**功耗管理**（**PM**）意味着在任何时候尽可能消耗尽可能少的电力。操作系统必须处理两种类型的功耗管理：**设备功耗管理**和**系统功耗管理**。'
- en: '**Device Power Management**: This is device specific. It allows a device to
    be put in a low-power state while the system is running. This may allow, among
    other things, part of the device not currently in use to be turned off in order
    to conserve power, such as the keyboard backlight when you are not typing. Individual
    device power management may be invoked explicitly on devices regardless of the
    power management activity, or may happen automatically after a device has been
    idle for a set amount of time. Device power management is an alias for the so-called
    *Runtime Power Management*.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备功耗管理**：这是特定于设备的。它允许在系统运行时将设备置于低功耗状态。这可能允许，除其他事项外，当前未使用的设备部分关闭以节省电力，例如在不键入时关闭键盘背光。无论功耗管理活动如何，都可以显式地在设备上调用单个设备功耗管理，或者在设备空闲一定时间后自动发生。设备功耗管理是所谓的*运行时功耗管理*的别名。'
- en: '**System Power Management**, also known as *Sleep States*: This enables platforms
    to enter a system-wide low-power state. In other words, entering a sleep state
    is the process by which the entire system is placed in a low-power state. There
    are several low-power states (or sleep states) that a system may enter, depending
    on the platform, its capabilities, and the target wake up latency. This happens,
    for example, when the lid is closed on a laptop computer, when turning off the
    screen of the phone, or when some critical state has been reached (such as battery
    level). Many of these states are similar across platforms (such as freezing, which
    is purely software, and hence not device or system dependent), and will be discussed
    in detail later. The general concept is that the state of the running system is
    saved before the system is powered down (or put into a sleep state, which is different
    from a shutdown), and restored once the system has regained power. This prevents
    the system from performing an entire shutdown and startup sequence.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统电源管理**，也称为*睡眠状态*：这使平台可以进入系统范围的低功耗状态。换句话说，进入睡眠状态是将整个系统置于低功耗状态的过程。根据平台、其功能和目标唤醒延迟，系统可能进入几种低功耗状态（或睡眠状态）。例如，当笔记本电脑的盖子关闭时，当手机屏幕关闭时，或者达到某些关键状态（例如电池电量）时，就会发生这种情况。许多这些状态在各个平台上都是相似的（例如冻结，这纯粹是软件，因此不依赖于设备或系统），并且将在以后详细讨论。总体概念是在系统关闭电源之前保存运行系统的状态（或将其置于睡眠状态，这与关闭不同），并在系统重新获得电源后恢复。这可以防止系统执行整个关闭和启动序列。'
- en: Although system PM and runtime PM deals with different scenarios for idle management,
    deploying both is important to prevent wasting power for a platform. You should
    think of them as complementary, as we will see in forthcoming sections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管系统PM和运行时PM处理空闲管理的不同情景，但部署两者都很重要，以防止平台浪费电力。正如我们将在接下来的章节中看到的那样，您应该将它们视为互补的。
- en: Runtime power management
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时功耗管理
- en: This is the part of Linux PM that manages power for individual devices without
    taking the whole system into a low-power state. In this mode, actions take effect
    while the system is running, hence its name, Runtime Power Management. In order
    to adapt device power consumption, its properties are changed on the fly with
    the system still in operation, hence its other name, **dynamic power management**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Linux PM的一部分，它在不将整个系统置于低功耗状态的情况下管理单个设备的电源。在这种模式下，操作在系统运行时生效，因此被称为运行时电源管理。为了适应设备的功耗，其属性在系统仍在运行时进行了更改，因此也被称为**动态功耗管理**。
- en: A tour of some dynamic power management interfaces
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些动态功耗管理接口的介绍
- en: 'Aside from per-device power management capabilities that driver developers
    can implement in device drivers, the Linux kernel provides user space interfaces
    to add/remove/modify power policies. The most well-known of these are listed here:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了驱动程序开发人员可以在设备驱动程序中实现的每个设备的功耗管理能力之外，Linux内核还提供了用户空间接口来添加/删除/修改电源策略。其中最著名的列在这里：
- en: '**CPU Idle**: This assists in managing CPU power consumption when it has no
    task to execute.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU空闲**：这有助于在CPU没有任务可执行时管理CPU功耗。'
- en: '**CPUFreq**: This allows CPU power properties (that is, voltage and frequency,
    which are related) to be changed depending on the system load.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPUFreq**：这允许根据系统负载更改CPU功率属性（即电压和频率）。'
- en: '**Thermal**: This allows power properties to be adjusted according to temperatures
    sensed in predefined zones of the system, most of the time areas close to the
    CPU.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热量**：这允许根据系统预定义区域中感测到的温度调整功率属性，大多数情况下是靠近CPU的区域。'
- en: You may have noticed that the preceding policies deal with the CPU. This is
    because the CPU is one of the principal sources of power dissipation on mobile
    devices (or embedded systems). While only three interfaces are introduced in the
    next sections, other interfaces exist, too, such as QoS and DevFreq. Readers are
    free to explore these to satisfy their curiosity.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到前面的策略涉及CPU。这是因为CPU是移动设备（或嵌入式系统）上功耗的主要来源之一。虽然下一节只介绍了三个接口，但也存在其他接口，例如QoS和DevFreq。读者可以自由探索这些接口以满足他们的好奇心。
- en: CPU Idle
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CPU空闲
- en: Whenever a logical CPU in the system has no task to execute, it may need to
    be put in a particular state in order to save power. In this situation, most operating
    systems simply schedule a so-called *idle thread*. While executing this thread,
    the CPU is said to be idle, or in an idle state. `C0`, which is the normal CPU
    operating mode; in other words, the CPU is 100% turned on. As the C number increases,
    the CPU sleep mode becomes deeper; in other words, more circuits and signals are
    turned off and the longer the amount of time the CPU will require to return to
    `C0` mode, that is, to wake up. `C1` is the first C-state, `C2` is the second
    one, and so on. When a logical processor is idle (any C-state except `C0`), its
    frequency is typically `0`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每当系统中的逻辑CPU没有任务可执行时，可能需要将其置于特定状态以节省电力。在这种情况下，大多数操作系统简单地安排所谓的*空闲线程*。在执行此线程时，CPU被称为空闲状态。`C0`是正常的CPU工作模式；换句话说，CPU处于100%开启状态。随着C编号的增加，CPU睡眠模式变得更深；换句话说，更多的电路和信号被关闭，CPU需要返回`C0`模式的时间也更长，也就是唤醒的时间。`C1`是第一个C状态，`C2`是第二个状态，依此类推。当逻辑处理器处于空闲状态（任何C状态除`C0`之外），其频率通常为`0`。
- en: 'The next event (in time) determines how long the CPU can sleep for. Each idle
    state is described by three characteristics:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个事件（按时间顺序）决定CPU可以休眠多长时间。每个空闲状态由三个特征描述：
- en: 'An exit latency, in µS: This is the latency to get out of this state.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出延迟，单位为µS：这是退出此状态所需的延迟时间。
- en: 'A power consumption, in mW: This is not always reliable.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功耗，单位为mW：这并不总是可靠的。
- en: 'A target residency, in µS: This is the idle duration from which it becomes
    interesting to use this state.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标驻留时间，单位为µS：这是使此状态变得有趣的空闲持续时间。
- en: CPU Idle drivers are platform specific, and the Linux kernel expects CPU drivers
    to support at most 10 states (see `CPUIDLE_STATE_MAX` in the kernel source code).
    However, the real number of states depends on the underlying CPU hardware (which
    embeds built-in power-saving logic), and the majority of ARM platforms only provide
    one or two idle states. The choice of the state to enter is based on policies
    managed by governors.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: CPU空闲驱动程序是特定于平台的，Linux内核期望CPU驱动程序支持最多10个状态（请参阅内核源代码中的`CPUIDLE_STATE_MAX`）。但是，实际状态的数量取决于底层CPU硬件（其中嵌入了内置的节能逻辑），大多数ARM平台只提供一个或两个空闲状态。进入的状态选择基于由州长管理的策略。
- en: 'A governor in this context is a simple module implementing an algorithm enabling
    the best C-state choice to be made, depending on some properties. In other words,
    the governor is the one that decides the target C-state of the system. Though
    multiple governors can exist on the system, only one will be in control of a given
    CPU at any time. It is designed in a way that, if the scheduler run queue is empty
    (which means the CPU has nothing else to do) and it needs to idle the CPU, it
    will request CPU idling to the CPU idle framework. The framework will then rely
    on the currently selected governor to select the appropriate *C-state*. There
    are two CPU Idle governors: `ladder` (for periodic timer tick-based systems) and
    `menu` (for tick-less systems). While the `ladder` governor is always available,
    if `CONFIG_CPU_IDLE` is selected, the `menu` governor additionally requires `CONFIG_NO_HZ_IDLE`
    (or `CONFIG_NO_HZ` on older kernels) to be set. The governor is selected while
    configuring the kernel. Roughly speaking, which of them to use depends on the
    configuration of the kernel and, in particular, on whether or not the scheduler
    tick can be stopped by the idle loop, hence `CONFIG_NO_HZ_IDLE`. You can refer
    to `Documentation/timers/NO_HZ.txt` for further reading on this.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，州长是实现算法的简单模块，使得可以根据某些属性做出最佳的C状态选择。换句话说，州长决定系统的目标C状态。虽然系统上可能存在多个州长，但在任何时候只有一个州长控制给定的CPU。它设计成这样，如果调度程序运行队列为空（这意味着CPU没有其他事情要做）并且需要使CPU空闲，它将请求CPU空闲到CPU空闲框架。然后，框架将依赖于当前选择的州长来选择适当的*C状态*。有两个CPU空闲州长：`ladder`（用于周期性定时器基础系统）和`menu`（用于无滴答系统）。虽然`ladder`州长始终可用，但如果选择了`CONFIG_CPU_IDLE`，则`menu`州长另外需要设置`CONFIG_NO_HZ_IDLE`（或在较旧的内核上设置`CONFIG_NO_HZ`）。在配置内核时选择州长。粗略地说，使用哪个取决于内核的配置，特别是取决于调度程序滴答是否可以被空闲循环停止，因此取决于`CONFIG_NO_HZ_IDLE`。您可以参考`Documentation/timers/NO_HZ.txt`以获取更多关于此的信息。
- en: 'The governor may decide whether to continue in the current state or transition
    to a different state, in which case it will instruct the current driver to transition
    to the selected state. The current idle driver can be identified by reading the
    content of the `/sys/devices/system/cpu/cpuidle/current_driver` file, and the
    current governor from `/sys/devices/system/cpu/cpuidle/current_governor_ro`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 州长可以决定是继续保持当前状态还是转换到另一个状态，如果是后者，它将指示当前驱动程序转换到所选状态。可以通过读取`/sys/devices/system/cpu/cpuidle/current_driver`文件来识别当前空闲驱动程序，通过`/sys/devices/system/cpu/cpuidle/current_governor_ro`来获取当前的州长：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On a given system, each directory in `/sys/devices/system/cpu/cpuX/cpuidle/`
    corresponds to a C-state, and the contents of each C-state directory attribute
    files describing this C-state:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定系统上，`/sys/devices/system/cpu/cpuX/cpuidle/`中的每个目录对应一个C状态，并且每个C状态目录属性文件的内容描述了这个C状态：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On ARM platforms, idle states can be described in the device tree. You can consult
    the `Documentation/devicetree/bindings/arm/idle-states.txt` file in kernel sources
    for more reading on this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在ARM平台上，空闲状态可以在设备树中描述。您可以查阅内核源中的`Documentation/devicetree/bindings/arm/idle-states.txt`文件以获取更多关于此的信息。
- en: Important note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Unlike other power management frameworks, CPU Idle requires no user intervention
    for it to work.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他电源管理框架不同，CPU空闲不需要用户干预即可工作。
- en: 'There is a framework slightly similar to this one, that is, `CPU Hotplug`,
    which allows the dynamic enabling and disabling of CPUs at runtime without having
    to reboot the system. For example, to hotplug CPU #2 out of the system, you can
    use the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个与此略有相似的框架，即`CPU热插拔`，它允许在运行时动态启用和禁用CPU，而无需重新启动系统。例如，要从系统中热插拔CPU＃2，可以使用以下命令：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can make sure that CPU #2 is actually disabled by reading `/proc/cpuinfo`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过读取`/proc/cpuinfo`来确保CPU＃2实际上已禁用：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding confirms that CPU2 is now offline. In order to hotplug that CPU
    back into the system, we can execute the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的内容证实了CPU2现在已经离线。为了将该CPU重新插入系统，我们可以执行以下命令：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What CPU hotplugging does under the hood will depend on your particular hardware
    and drivers. It may simply result in the CPU being put into idle on some systems,
    whereas other systems may physically remove power from the specified core.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: CPU热插拔在底层会根据特定的硬件和驱动程序而有所不同。在某些系统上，它可能只是将CPU置于空闲状态，而在其他系统上，可能会从指定的核心中断电。
- en: CPUfreq or dynamic voltage and frequency scaling (DVFS)
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CPU频率或动态电压和频率缩放（DVFS）
- en: This framework allows dynamic voltage selection and frequency scaling for the
    CPU, based on constraints and requirements, user preferences, or other factors.
    Because this framework deals with frequency, it unconditionally involves a clock
    framework. This framework uses the concept of `{Frequency,voltage}` tuples.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架允许根据约束和要求、用户偏好或其他因素对CPU进行动态电压选择和频率缩放。因为该框架涉及频率，所以它无条件地涉及时钟框架。该框架使用`{频率，电压}`元组的概念。
- en: 'OPPs can be described in the device tree, and its binding documentation in
    the kernel sources can be a good starting point for more information on it: `Documentation/devicetree/bindings/opp/opp.txt`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: OPP可以在设备树中描述，并且内核源中的绑定文档可以作为更多信息的良好起点：`Documentation/devicetree/bindings/opp/opp.txt`。
- en: Important note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You’ll occasionally come across the term `ls /sys/devices/system/cpu/cpufreq/`
    on an Intel-based machine. Thus, C-states are idle power-saving states, in contrast
    to P-states, which are execution power-saving states.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您偶尔会在基于英特尔的机器上遇到术语`ls /sys/devices/system/cpu/cpufreq/`。因此，C状态是空闲节能状态，与P状态相反，后者是执行节能状态。
- en: 'CPUfreq also uses the concept of governors (which implement scaling algorithms),
    and the governors in this framework are as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: CPUfreq还使用了州长的概念（实现了缩放算法），该框架中的州长如下：
- en: '`ondemand`: This governor samples the load of the CPU and scales it up aggressively
    in order to provide the proper amount of processing power, but resets the frequency
    to the maximum when necessary.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ondemand`：这个州长对CPU的负载进行采样，并积极地将其扩展，以提供适当的处理能力，但在必要时将频率重置为最大值。'
- en: '`conservative`: This is similar to `ondemand`, but uses a less aggressive method
    of increasing the OPP. For example, it will never skip from the lowest OPP to
    the highest one even if the system suddenly requires high performance. It will
    do it progressively.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conservative`：这类似于`ondemand`，但使用了一种不那么激进的增加OPP的方法。例如，即使系统突然需要高性能，它也不会从最低的OPP跳到最高的OPP。它会逐渐增加。'
- en: '`performance`: This governor always selects the OPP with the highest frequency
    possible. This governor prioritizes performance.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`performance`：这个州长总是选择具有最高频率的OPP。这个州长优先考虑性能。'
- en: '`powersave`: In contrast to performance, this governor always selects the OPP
    with the lowest frequency possible. This governor prioritizes power saving.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`powersave`：与性能相反，这个州长总是选择具有最低频率的OPP。这个州长优先考虑节能。'
- en: '`userspace`: This governor allows the user to set the desired OPP using any
    value found within `/sys/devices/system/cpu/cpuX/cpufreq/scaling_available_frequencies`
    by echoing it into `/sys/devices/system/cpu/cpuX/cpufreq/scaling_setspeed`.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userspace`：这个州长允许用户使用在`/sys/devices/system/cpu/cpuX/cpufreq/scaling_available_frequencies`中找到的任何值来设置所需的OPP，通过将其回显到`/sys/devices/system/cpu/cpuX/cpufreq/scaling_setspeed`。'
- en: '`schedutil`: This governor is part of the scheduler, so it can access the scheduler
    data structure internally, allowing it to grab more reliable and accurate stats
    about the system load, for the purpose of better selecting the appropriate OPP.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schedutil`：这个州长是调度程序的一部分，因此它可以在内部访问调度程序数据结构，从而能够更可靠和准确地获取有关系统负载的统计信息，以更好地选择适当的OPP。'
- en: 'The `userspace` governor is the only one that allows users to select the OPP.
    For other governors, OPP change happens automatically based on the system load
    of their algorithm. That said, from `userspace`, the governors available are listed
    here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`userspace`州长是唯一允许用户选择OPP的州长。对于其他州长，根据其算法的系统负载，OPP的更改会自动发生。也就是说，从`userspace`开始，可用的州长如下所示：'
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To view the current governor, implement the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看当前的州长，执行以下命令：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To set a governor, the following command can be used:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置州长，可以使用以下命令：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To view the current OPP (frequency in kHz), implement the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看当前的OPP（频率以kHz为单位），执行以下命令：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To view supported OPPs (frequency in kHz), implement the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看支持的OPP（以kHz为单位的频率），执行以下命令：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To change the OPP, you can use the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改OPP，可以使用以下命令：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Important note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There is also the `devfreq` framework, which is a generic `Ondemand`, `performance`,
    `powersave`, and `passive`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`devfreq`框架，它是一个通用的`Ondemand`、`performance`、`powersave`和`passive`。
- en: Note that the preceding command only works when the `ondemand` governor is selected,
    as it is the only one that allows the OPP to be changed. However, in all the preceding
    commands, `cpu0` has been used only for didactic purposes. Think of it like *cpuX*,
    where *X* is the index of the CPU as seen by the system.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的命令仅在选择了`ondemand`州长时才有效，因为它是唯一允许更改OPP的州长。但是，在所有前面的命令中，`cpu0`仅用于教学目的。将其视为*cpuX*，其中*X*是系统看到的CPU的索引。
- en: Thermal
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 热
- en: This framework is dedicated to monitoring the system temperature. It has dedicated
    profiles according to temperature thresholds. Thermal sensors sense the hot points
    and report. This framework works in conjunction with cooling devices, which aid
    in power dissipation to control/limit overheating.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架致力于监控系统温度。它根据温度阈值具有专门的配置文件。热传感器感知热点并报告。该框架与冷却设备一起工作，后者有助于控制/限制过热的功耗散失。
- en: 'The thermal framework uses the following concepts:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 热框架使用以下概念：
- en: '**Thermal zones**: You can think of a thermal zone as hardware whose temperature
    needs to be monitored.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热区**：您可以将热区视为需要监视温度的硬件。'
- en: '**Thermal sensors**: These are components used to take temperature measurements.
    Thermal sensors provide temperature sensing capabilities in thermal zones.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热传感器**：这些是用于进行温度测量的组件。热传感器在热区提供温度感应能力。'
- en: '**Cooling devices**: These devices provide control in terms of power dissipation.
    Typically, there are two cooling methods: passive cooling, which consists of regulating
    device performance, in which case DVFS is used; and active cooling, which consists
    of activating special cooling devices, such as fans (GPIO-fan, PWM-fan).'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冷却设备**：这些设备在功耗控制方面提供控制。通常有两种冷却方法：被动冷却，包括调节设备性能，此时使用DVFS；和主动冷却，包括激活特殊的冷却设备，如风扇（GPIO风扇，PWM风扇）。'
- en: '**Trip points**: These describe key temperatures (actually thresholds) at which
    a cooling action is recommended. Those sets of points are chosen based on hardware
    limits.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发点**：这些描述了建议进行冷却操作的关键温度（实际上是阈值）。这些点集是基于硬件限制选择的。'
- en: '**Governors**: These comprise algorithms to choose the best cooling according
    to some criteria.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**州长们**：这些包括根据某些标准选择最佳冷却的算法。'
- en: '**Cooling maps**: These are used to describe links between trip points and
    cooling devices.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冷却映射**：这些用于描述触发点和冷却设备之间的链接。'
- en: 'The thermal framework can be divided into four parts, these being `thermal
    zone`, `thermal governor`, `thermal cooling`, and `thermal core`, which is the
    glue between the three previous parts. It can be managed in user space from within
    the `/sys/class/thermal/` directory:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 热框架可以分为四个部分，分别是`热区`，`热管理器`，`热冷却`和`热核`，它是前三个部分之间的粘合剂。它可以在用户空间中从`/sys/class/thermal/`目录中进行管理：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding, each `thermal_zoneX` file represents a thermal zone driver,
    or a thermal driver. A thermal zone driver is the driver of the thermal sensor
    associated with a thermal zone. This driver exposes trip points at which cooling
    is necessary, but also provides a list of cooling devices associated with the
    sensor. The thermal workflow is designed to obtain the temperature through the
    thermal zone driver, and then make decisions through the thermal governor, and
    finally perform temperature control by means of thermal cooling. Further reading
    on this is available in the thermal sysfs documentation in the kernel sources,
    `Documentation/thermal/sysfs- api.txt`. Moreover, thermal zone description, trip
    point definitions, and cooling device binding can be performed in the device tree,
    and its associated documentation in the sources is `Documentation/devicetree/bindings/thermal/thermal.txt`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的内容中，每个`thermal_zoneX`文件代表一个热区驱动程序，或者热驱动程序。热区驱动程序是与热区相关的热传感器的驱动程序。该驱动程序公开了需要冷却的触发点，但也提供了与传感器相关的冷却设备列表。热工作流程旨在通过热区驱动程序获取温度，然后通过热管理器做出决策，最后通过热冷却进行温度控制。有关此内容的更多信息，请参阅内核源中的热sysfs文档，`Documentation/thermal/sysfs-
    api.txt`。此外，热区描述，触发点定义和冷却设备绑定可以在设备树中执行，其相关文档在源中的`Documentation/devicetree/bindings/thermal/thermal.txt`中。
- en: System power management sleep states
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统电源管理睡眠状态
- en: System power management targets the entire system. Its aim is to put it into
    a low-power state. In this low-power state, the system is consuming a small, but
    minimal amount of power, yet maintaining a relatively low response latency to
    the user. The exact amount of power and response latency depends on how deep is
    the sleep state that the system is in. This is also referred to as Static Power
    Management because it is activated when the system is inactive for an extended
    period.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 系统电源管理针对整个系统。其目的是将其置于低功耗状态。在这种低功耗状态下，系统消耗的功率很小，但维持相对较低的响应延迟。功率和响应延迟的确切数量取决于系统所处的睡眠状态有多深。这也被称为静态电源管理，因为当系统长时间处于非活动状态时会激活它。
- en: 'The states a system can enter are dependent on the underlying platform, and
    differ across architectures and even generations or families of the same architecture.
    There are, however, four sleep states that are commonly found on most platforms.
    These are suspend to idle (also known as freeze), power-on standby (standby),
    suspend to ram (mem), and suspend to disk (hibernation). These are also occasionally
    referred to by their ACPI states: `S0`, `S1`, `S3`, and `S4`, respectively:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 系统可以进入的状态取决于底层平台，并且在不同的架构甚至同一架构的不同世代或系列之间也有所不同。然而，在大多数平台上通常可以找到四种睡眠状态。这些是挂起到空闲（也称为冻结），开机待机（待机），挂起到RAM（内存）和挂起到磁盘（休眠）。它们有时也按照它们的ACPI状态来称呼：`S0`，`S1`，`S3`和`S4`，分别是：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`CONFIG_SUSPEND` is the kernel configuration option that must be set in order
    for the system to support the system’s power management sleep state. That said,
    except for *freeze*, each sleep state is platform specific. Thus, for a platform
    to support any of the three remaining states, it must explicitly register for
    each state with the core system suspend subsystem. However, the support for hibernation
    depends on other kernel configuration options, as we will see later.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`CONFIG_SUSPEND`是必须设置的内核配置选项，以便系统支持系统的电源管理睡眠状态。也就是说，除了*冻结*之外，每个睡眠状态都是特定于平台的。因此，要支持剩下的三种状态中的任何一种，必须显式地向核心系统挂起子系统注册每种状态。然而，休眠的支持取决于其他内核配置选项，我们稍后会看到。'
- en: Important note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Because only the user knows when the system is not going to be used (or even
    user code, such as GUI), system power management actions are always initiated
    from the user space. The kernel has no idea of that. This is why most of the content
    in this section deals with `sysfs` and the command line.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因为只有用户知道系统何时不会被使用（甚至用户代码，如GUI），系统电源管理操作总是从用户空间发起的。内核对此一无所知。这就是为什么本节的大部分内容都涉及`sysfs`和命令行的原因。
- en: Suspend to idle (freeze)
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂起到空闲（冻结）
- en: 'This is the most basic and lightweight. This state is purely software driven
    and involves keeping the CPUs in their deepest idle state as much as possible.
    To achieve this, the user space is frozen (all user space tasks are) and all I/O
    devices are put into low-power states (possibly lower power than available at
    runtime) so that the processors can spend more time in their idle states. The
    following is the command that idles the system:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最基本和轻量级的。这种状态纯粹由软件驱动，并涉及尽可能使CPU保持在最深的空闲状态。为了实现这一点，用户空间被冻结（所有用户空间任务都被冻结），并且所有I/O设备都被置于低功耗状态（可能低于运行时可用的功耗），以便处理器可以在其空闲状态下花费更多时间。以下是使系统处于空闲状态的命令：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding command puts the system in an idle state. Because it is purely
    software, this state is always supported (assuming the `CONFIG_SUSPEND` kernel
    configuration option is set). This state can be used for platforms without power-on-suspend
    or suspend-to-ram support. However, as we will see later, it can be used in addition
    to suspend-to-ram to provide reduced resume latency.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令使系统处于空闲状态。因为它纯粹是软件，所以这种状态始终受支持（假设设置了`CONFIG_SUSPEND`内核配置选项）。这种状态可以用于不支持开机挂起或挂起到RAM的平台。然而，我们稍后会看到，它可以与挂起到RAM一起使用，以提供较低的恢复延迟。
- en: Important note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Suspend to idle equals frozen processes + suspended devices + idle processors
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 挂起到空闲等于冻结进程+挂起设备+空闲处理器
- en: Power-on standby (standby or power-on suspend)
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开机待机（待机或开机挂起）
- en: 'In addition to freezing the user space and putting all I/O devices into a low-power
    state, another action performed by this state is to power off all non-boot CPUs.
    The following is the command that puts the system in standby, assuming it is supported
    by the platform:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除了冻结用户空间并将所有I/O设备置于低功耗状态之外，此状态执行的另一个操作是关闭所有非引导CPU。以下是将系统置于待机状态的命令，假设平台支持：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As this state goes further than the freeze state, it also allows more energy
    to be saved relative to *Suspend-to-Idle*, but the resume latency will generally
    be greater than for the freeze state, although it is quite low.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种状态比冻结状态更进一步，因此相对于挂起到空闲状态，它也可以节省更多的能量，但是恢复延迟通常会大于冻结状态，尽管它相当低。
- en: Suspend-to-ram (suspend, or mem)
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂起到RAM（挂起或mem）
- en: 'In addition to putting everything in the system into a low-power state, this
    state goes further by powering off all CPUs and putting the memory into self-refresh
    so that its contents are not lost, although additional operations may take place
    depending on the platform’s capabilities. Response latency is higher than standby,
    yet still quite low. In this state, the system and device state is saved and kept
    in memory. This is the reason why only the RAM is fully operational, hence the
    state name:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将系统中的所有内容置于低功耗状态之外，此状态通过关闭所有CPU并将内存置于自刷新状态进一步进行，以便其内容不会丢失，尽管根据平台的能力可能会执行其他操作。响应延迟高于待机，但仍然相当低。在此状态下，系统和设备状态被保存并保留在内存中。这就是为什么只有RAM是完全可操作的原因，因此状态名称为：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding command is supposed to put the system into a Suspend-to-RAM state.
    However, the real actions performed while writing the `mem` string are controlled
    by the `/sys/power/mem_sleep` file. This file contains a list of strings where
    each string represents a mode the system can enter after `mem` has been written
    to `/sys/power/state`. Although not all are always available (it depends on the
    platform), possible modes include the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令应该将系统置于挂起到RAM状态。然而，写入`mem`字符串时执行的真正操作由`/sys/power/mem_sleep`文件控制。该文件包含一个字符串列表，其中每个字符串代表系统在将`mem`写入`/sys/power/state`后可以进入的模式。虽然并非所有模式始终可用（这取决于平台），但可能的模式包括以下内容：
- en: '`s2idle`: This is the equivalent of Suspend-to-Idle. For this reason, it is
    always available.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s2idle`：这相当于挂起到空闲。因此，它始终可用。'
- en: '`shallow`: This is equivalent to Power-On Suspend, or standby. Its availability
    depends on the platform’s support of the standby mode.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shallow`：这相当于待机挂起。其可用性取决于平台对待机模式的支持。'
- en: '`deep`: This is the real Suspend-To-RAM state and its availability depends
    on the platform.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deep`：这是真正的挂起到RAM状态，其可用性取决于平台。'
- en: 'An example of querying the content can be seen here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 查询内容的示例可以在此处看到：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The selected mode is enclosed in square brackets, `[ ]`. If a mode is not supported
    by the platform, the string that corresponds to it will still not be present in
    `/sys/power/mem_sleep`. Writing one of the other strings present in `/sys/power/mem_sleep`
    to it causes the suspend mode to be used subsequently to change to the one represented
    by that string.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所选模式用方括号`[ ]`括起来。如果某个模式不受平台支持，与之对应的字符串仍不会出现在`/sys/power/mem_sleep`中。将`/sys/power/mem_sleep`中的其他字符串之一写入其中会导致随后使用挂起模式更改为该字符串所代表的模式。
- en: When the system is booted, the default suspend mode (in other words, the one
    to be used without writing anything into `/sys/power/mem_sleep`) is either `deep`
    (if Suspend-To-RAM is supported) or `s2idle`, but it can be overridden by the
    value of the `mem_sleep_default` parameter in the kernel command line.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统启动时，默认的挂起模式（换句话说，不写入任何内容到`/sys/power/mem_sleep`）要么是`deep`（如果支持挂起到RAM），要么是`s2idle`，但可以通过内核命令行中的`mem_sleep_default`参数的值来覆盖。
- en: 'One method for testing this is to use an RTC available on the system, assuming
    it supports the `wakeup alarm` feature. You can identify available RTCs on your
    system using `ls /sys/class/rtc/`. There will be a directory for each RTC (in
    other words, `rtc0` and `rtc1`). For an `rtc` that supports the `alarm` feature,
    there will be a `wakealarm` file in that `rtc` directory, which can be used as
    follows to configure an alarm and then suspend the system to RAM:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的一种方法是使用系统上可用的RTC，假设它支持`唤醒闹钟`功能。您可以使用`ls /sys/class/rtc/`来识别系统上可用的RTC。每个RTC（换句话说，`rtc0`和`rtc1`）都会有一个目录。对于支持`alarm`功能的`rtc`，该`rtc`目录中将有一个`wakealarm`文件，可以按照以下方式使用它来配置闹钟，然后将系统挂起到RAM：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You should see no further activity on the console until wakeup.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在唤醒之前不会在控制台上看到进一步的活动。
- en: Suspend to disk (hibernation)
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂起到磁盘（休眠）
- en: 'This state gives the greatest power savings as a result of powering off as
    much of the system as possible, including the memory. Memory contents (a snapshot)
    are written to persistent media, usually a disk. After this, memory is powered
    down, along with the entire system. Upon resumption, the snapshot is read back
    into memory and the system boots from this hibernation image. However, this state
    is also the longest to resume but still quicker than performing a full (re)boot
    sequence:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这种状态由于尽可能关闭系统的大部分部分（包括内存）而实现了最大的节能。内存内容（快照）通常写入持久介质，通常是磁盘。之后，内存和整个系统都被关闭。在恢复时，快照被读回内存，并且系统从此休眠镜像引导。然而，这种状态也是最长的恢复时间，但仍然比执行完整的（重新）引导序列要快：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once the memory state is written to disk, several actions can take place. The
    action to be performed is controlled by the `/sys/power/disk` file and its contents.
    This file contains a list of strings where each string represents an action that
    can be performed once the system state is saved on persistent storage media (after
    the hibernation image has actually been saved). Possible actions include the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将内存状态写入磁盘，就可以执行多个操作。要执行的操作由`/sys/power/disk`文件及其内容控制。该文件包含一个字符串列表，其中每个字符串代表系统状态保存在持久存储介质上后可以执行的操作。可能的操作包括以下内容：
- en: '`platform`: Custom- and platform-specific, which may require firmware (BIOS)
    intervention.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`platform`：自定义和特定于平台的，可能需要固件（BIOS）干预。'
- en: '`shutdown`: Power off the system.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown`：关闭系统电源。'
- en: '`reboot`: Reboots the system (useful for diagnostics mostly).'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reboot`：重新启动系统（主要用于诊断）。'
- en: '`suspend`: Puts the system into the suspend sleep state selected through the
    `mem_sleep` file described earlier. If the system is successfully woken up from
    that state, then the hibernation image is simply discarded and everything continues.
    Otherwise, the image is used to restore the previous state of the system.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suspend`：将系统置于通过先前描述的`mem_sleep`文件选择的挂起睡眠状态。如果系统成功从该状态唤醒，那么休眠映像将被简单丢弃，一切将继续。否则，映像将用于恢复系统的先前状态。'
- en: '`test_resume`: This is for system resumption diagnostic purposes. Loads the
    image as if the system had just woken up from hibernation and the currently running
    kernel instance was a restore kernel and follows up with full system resumption.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_resume`：用于系统恢复诊断目的。加载镜像，就好像系统刚从休眠中醒来，当前运行的内核实例是一个恢复内核，并随后进行完整的系统恢复。'
- en: 'However, supported actions on a given platform depend on the content of the
    `/sys/power/disk` file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，给定平台上支持的操作取决于`/sys/power/disk`文件的内容：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The selected action is enclosed in square brackets, `[ ]`. Writing one of the
    listed strings to this file causes the option represented by it to be selected.
    Hibernation is such a complex operation that it has its own configuration option,
    `CONFIG_HIBERNATION`. This option has to be set in order to enable the hibernation
    feature. That said, this option can only be set if support for the given CPU architecture
    includes the low-level code for system resumption (refer to the `ARCH_HIBERNATION_POSSIBLE`
    kernel configuration option).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所选操作用方括号`[ ]`括起来。将列出的字符串之一写入此文件会导致选择所代表的选项。休眠是如此复杂的操作，以至于它有自己的配置选项`CONFIG_HIBERNATION`。必须设置此选项才能启用休眠功能。也就是说，只有在给定CPU架构的支持包括系统恢复的低级代码时，才能设置此选项（参考`ARCH_HIBERNATION_POSSIBLE`内核配置选项）。
- en: 'For suspend-to-disk to work, and depending on where the hibernation image should
    be stored, a dedicated partition may be required on the disk. This partition is
    also known as a swap partition. This partition is used to write memory contents
    to free swap space. In order to check whether hibernation works as expected, it
    is common to try to hibernate in `reboot` mode as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使挂起到磁盘工作，并且取决于休眠映像应存储在何处，磁盘上可能需要一个专用分区。这个分区也被称为交换分区。该分区用于将内存内容写入空闲交换空间。为了检查休眠是否按预期工作，通常尝试在`reboot`模式下进行休眠，如下所示：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first command informs the power management core of what action should be
    performed when the hibernation image has been created. In this case, it is a reboot.
    Upon reboot, the system is restored from the hibernation image and you should
    get back to the command prompt where you started the transition. The success of
    this test may show that hibernation is most likely to work correctly. That said,
    it should be done several times in order to reinforce the test.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令通知电源管理核心在创建休眠映像后应执行什么操作。在这种情况下，是重启。重启后，系统将从休眠映像中恢复，并且您应该回到您开始转换的命令提示符。这个测试的成功可能表明休眠很可能能够正确工作。也就是说，应该多次进行以加强测试。
- en: Now that we are done with sleep state management from a running system, we can
    see how to implement its support in driver code.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了从运行系统管理睡眠状态，我们可以看看如何在驱动程序代码中实现其支持。
- en: Adding power management capabilities to device drivers
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向设备驱动程序添加电源管理功能
- en: Device drivers on their own can implement a distinct power management capability,
    which is known as runtime power management. Not all devices support runtime power
    management. However, those that do must export some callbacks for controlling
    their power state depending on the user or system’s policy decisions. As we have
    seen earlier, this is device-specific. In this section, we will learn how to extend
    device driver capabilities with power management support.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序本身可以实现一个称为运行时电源管理的独特电源管理功能。并非所有设备都支持运行时电源管理。但是，那些支持的设备必须根据用户或系统的策略决定导出一些回调来控制它们的电源状态。正如我们之前所见，这是特定于设备的。在本节中，我们将学习如何通过电源管理支持扩展设备驱动程序功能。
- en: 'Though device drivers provide runtime power management callbacks, they also
    facilitate and participate in the system sleep state by providing another set
    of callbacks, where each set participates in a particular system sleep state.
    Whenever the system needs to enter or resume from a given set, the kernel will
    walk through each driver that provided callbacks for this state and then invoke
    them in a precise order. Simply speaking, device power management consists of
    a description of the state a device is in, and a mechanism for controlling those
    states. This is facilitated by the kernel providing the `struct dev_pm_ops` that
    each device driver/class/bus interested in power management must fill. This allows
    the kernel to communicate with every device in the system, regardless of the bus
    the device resides on or the class it belongs to. Let’s take a step back and remember
    what a `struct device` looks like:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管设备驱动程序提供运行时电源管理回调，但它们也通过提供另一组回调来便利和参与系统睡眠状态。每个集合都参与特定的系统睡眠状态。每当系统需要进入或从给定集合恢复时，内核将遍历为该状态提供回调的每个驱动程序，然后按照精确的顺序调用它们。简而言之，设备电源管理包括设备所处状态的描述，以及控制这些状态的机制。这是由内核提供的`struct
    dev_pm_ops`来实现的，每个对电源管理感兴趣的设备驱动程序/类/总线都必须填充。这允许内核与系统中的每个设备通信，而不管设备所在的总线或所属的类是什么。让我们退一步，记住`struct
    device`是什么样子的：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding `struct device` data structure, we can see that a device can
    be either a child (its `.parent` field points to another device) or a device parent
    (when the `.parent` field of another device points to it), can sit behind a given
    bus, or can belong to a given class, or can belong indirectly to a given subsystem.
    Moreover, we can see that a device can be part of a given power domain. The `.power`
    field is of the `struct dev_pm_info` type. It mainly saves PM-related states,
    such as the current power state, whether it can be awakened, whether it has been
    prepared, and whether it has been suspended. Since there is so much content involved,
    we will explain these in detail when we use them.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`struct device`数据结构中，我们可以看到设备可以是子设备（其`.parent`字段指向另一个设备）或设备父级（当另一个设备的`.parent`字段指向它时），可以位于给定总线后面，或者可以属于给定类，或者可以间接属于给定子系统。此外，我们可以看到设备可以是给定电源域的一部分。`.power`字段是`struct
    dev_pm_info`类型。它主要保存与电源管理相关的状态，例如当前电源状态，是否可以唤醒，是否已准备好，是否已挂起。由于涉及的内容如此之多，我们将在使用它们时详细解释这些内容。
- en: 'In order for devices to participate in power management, either at the subsystem
    level or at the device driver level, their drivers need to implement a set of
    device power management operations by defining and populating objects of the `struct
    dev_pm_ops` type defined in `include/linux/pm.h` as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使设备能够参与电源管理，无论是在子系统级别还是在设备驱动程序级别，它们的驱动程序都需要通过定义和填充`include/linux/pm.h`中定义的`struct
    dev_pm_ops`类型的对象来实现一组设备电源管理操作，如下所示：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding data structure, `*_early()` and `*_late()` callbacks have been
    removed for the sake of readability. I suggest you have a look at the full definition.
    That said, given the huge number of callbacks in there, we will describe them
    in due course in the sections of the chapter where their use will be necessary.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数据结构中，`*_early()`和`*_late()`回调已被删除以提高可读性。我建议您查看完整的定义。也就是说，鉴于其中的大量回调，我们将在本章的各个部分中逐步描述它们的使用。
- en: Important note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Device power states are sometimes referred to as *D* states, inspired by the
    PCI device and ACPI specifications. Those states range from state `D0` to `D3`,
    inclusive. Although not all device types define power states in this way, this
    representation can map to all known device types.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 设备电源状态有时被称为*D*状态，受PCI设备和ACPI规范的启发。这些状态从`D0`到`D3`，包括。尽管并非所有设备类型都以这种方式定义电源状态，但这种表示可以映射到所有已知的设备类型。
- en: Implementing runtime PM capability
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现运行时电源管理能力
- en: 'Runtime power management is a per-device power management feature allowing
    a particular device to have its states controlled when the system is running,
    regardless of the global system. For a driver to implement runtime power management,
    it should provide only a subset of the whole list of callbacks in `struct dev_pm_ops`,
    shown as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时电源管理是一种每设备的电源管理功能，允许特定设备在系统运行时控制其状态，而不受全局系统的影响。为了实现运行时电源管理，驱动程序应该只提供`struct
    dev_pm_ops`中的部分回调函数，如下所示：
- en: '[PRE23]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The kernel also provides `SET_RUNTIME_PM_OPS()`, which accepts the three callbacks
    to be populated in the structure. This macro is defined as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 内核还提供了`SET_RUNTIME_PM_OPS()`，它接受要填充到结构中的三个回调。此宏定义如下：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding callbacks are the only ones involved in runtime power management,
    and here are descriptions of what they must do:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的回调是运行时电源管理中涉及的唯一回调，以下是它们必须执行的描述：
- en: '`.runtime_suspend()` must record the device’s current state if necessary and
    put the device in a quiescent state. This method is invoked by the PM when the
    device is not used. In its simple form, this method must put the device in a state
    in which it won’t be able to communicate with the CPU(s) and RAM.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，`.runtime_suspend()`必须记录设备的当前状态并将设备置于静止状态。当设备未被使用时，PM将调用此方法。在其简单形式中，此方法必须将设备置于一种状态，使其无法与CPU和RAM通信。
- en: '`.runtime_resume()` is invoked when the device must be put in a fully functional
    state. This may be the case if the system needs to access this device. This method
    must restore power and reload any required device state.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当设备必须处于完全功能状态时，将调用`.runtime_resume()`。如果系统需要访问此设备，可能会出现这种情况。此方法必须恢复电源并重新加载任何所需的设备状态。
- en: '`.runtime_idle()` is invoked when the device is no longer used based on the
    device usage counter (actually when it reaches `0`), as well as the number of
    active children. However, the action performed by this callback is driver-specific.
    In most cases, the driver invokes `runtime_suspend()` on the device if some conditions
    are met, or invokes `pm_schedule_suspend()` (given a delay in order to set up
    a timer to submit a suspend request in future), or `pm_runtime_autosuspend()`
    (to schedule a suspend request in the future based on a delay that has already
    been set using `pm_runtime_set_autosuspend_delay()`). If the `.runtime_idle` callback
    doesn’t exist or if it returns `0`, the PM core will immediately invoke the `.runtime_suspend()`
    callback. For the PM core to do nothing, `.runtime_idle()` must return a non-zero
    value. It is common for drivers to return `-EBUSY`, or `1` in this case.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当设备不再使用时（实际上是当其达到`0`时），将调用`.runtime_idle()`，以及活动子设备的数量。但是，此回调执行的操作是特定于驱动程序的。在大多数情况下，如果满足某些条件，驱动程序会在设备上调用`runtime_suspend()`，或者调用`pm_schedule_suspend()`（给定延迟以设置定时器以在将来提交挂起请求），或者调用`pm_runtime_autosuspend()`（根据已使用`pm_runtime_set_autosuspend_delay()`设置的延迟来安排将来的挂起请求）。如果`.runtime_idle`回调不存在，或者返回`0`，PM核心将立即调用`.runtime_suspend()`回调。对于PM核心不执行任何操作，`.runtime_idle()`必须返回非零值。驱动程序通常会在这种情况下返回`-EBUSY`或`1`。
- en: 'After callbacks have been implemented, they can be fed in `struct dev_pm_ops`,
    as in the following example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了回调之后，它们可以被填充到`struct dev_pm_ops`中，如下例所示：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding is an excerpt from `drivers/iio/light/bh1780.c`, an IIO ambient
    light sensor driver. In this excerpt, we can see how `struct dev_pm_ops` is populated,
    using convenient macros. `SET_SYSTEM_SLEEP_PM_OPS` is used here to populate system
    sleep-related macros, as we will see in the next sections. `pm_runtime_force_suspend`
    and `pm_runtime_force_resume` are special helpers that the PM core exposes to
    force device suspension and resumption, respectively.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上述是来自`drivers/iio/light/bh1780.c`的摘录，这是一个IIO环境光传感器驱动程序。在这段摘录中，我们可以看到如何使用方便的宏来填充`struct
    dev_pm_ops`。在这里使用`SET_SYSTEM_SLEEP_PM_OPS`来填充与系统睡眠相关的宏，我们将在接下来的部分中看到。`pm_runtime_force_suspend`和`pm_runtime_force_resume`是PM核心公开的特殊辅助函数，用于强制设备挂起和恢复。
- en: Runtime PM anywhere in the driver
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 驱动程序中的运行时PM
- en: In fact, the PM core keeps track of the activity of each device using two counters.
    The first counter is `power.usage_count`, which counts active references to the
    device. These may be external references, such as open file handles, or other
    devices that are making use of this one, or they may be internal references used
    to keep the device active for the duration of an operation. The other counter
    is `power.child_count`, which counts the number of children that are active.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，PM核心使用两个计数器跟踪每个设备的活动情况。第一个计数器是`power.usage_count`，它计算对设备的活动引用。这些可能是外部引用，例如打开的文件句柄，或者正在使用此设备的其他设备，或者它们可能是用于在操作期间保持设备活动的内部引用。另一个计数器是`power.child_count`，它计算活动的子设备数量。
- en: These counters define the active/idle conditions of a given device from the
    PM point of view. The active/idle condition of a device is the only reliable means
    for the PM core to determine whether a device is accessible. An idle condition
    is when the device usage count is decremented until `0`, and an active condition
    (also known as a resume condition) occurs whenever the device usage count is incremented.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些计数器定义了从PM角度看给定设备的活动/空闲状态。设备的活动/空闲状态是PM核心确定设备是否可访问的唯一可靠手段。空闲状态是指设备使用计数递减至`0`，而活动状态（也称为恢复状态）发生在设备使用计数递增时。
- en: In the event of an idle condition, the PM core sends/performs an idle notification
    (that is, setting the device’s `power.idle_notification` field to `true`, invoking
    the bus type/class/device `->runtime_idle()` callback, and setting the `.idle_notification`
    field back to `false` again) in order to check whether the device can be suspended.
    If the `->runtime_idle()` callback doesn’t exist or if it returns `0`, the PM
    core will immediately invoke the `->runtime_suspend()` callback to suspend the
    device, after which the device’s `power.runtime_status` field is set to `RPM_SUSPENDED`,
    which means the device is suspended. Upon a resume condition (the device usage
    count is incremented), the PM core will carry out a resumption (under certain
    conditions only) of this device, either synchronously or asynchronously. Have
    a look at the `rpm_resume()` function and its description in `drivers/base/power/runtime.c`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在空闲状态下，PM核心发送/执行空闲通知（即将设备的`power.idle_notification`字段设置为`true`，调用总线类型/类/设备`->runtime_idle()`回调，并将`.idle_notification`字段再次设置为`false`）以检查设备是否可以挂起。如果`->runtime_idle()`回调不存在或者返回`0`，PM核心将立即调用`->runtime_suspend()`回调来挂起设备，之后设备的`power.runtime_status`字段将设置为`RPM_SUSPENDED`，这意味着设备已挂起。在恢复条件下（设备使用计数增加），PM核心将在特定条件下同步或异步地恢复此设备。请查看`drivers/base/power/runtime.c`中的`rpm_resume()`函数及其描述。
- en: Initially, the runtime PM is disabled for all devices. This means invoking most
    PM-related helpers on the device will fail until `pm_runtime_enable()` is called
    for the device, which enables a runtime PM of this device. Though the initial
    runtime PM status of all devices is suspended, it need not reflect the actual
    physical state of the device. Thus, if the device is initially active (in other
    words, it is able to process I/O), its runtime PM status must be changed to active
    with the help of `pm_runtime_set_active()` (which will set `power.runtime_status`
    to `RPM_ACTIVE`), and if possible, its usage count must be increased using `pm_runtime_get_noresume()`
    before `pm_runtime_enable()` is called for the device. Once the device is fully
    initialized, you can call `pm_runtime_put()` on it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，所有设备的运行时PM都被禁用。这意味着在为设备调用`pm_runtime_enable()`之前，对设备调用大多数与PM相关的辅助函数将失败，这将启用此设备的运行时PM。尽管所有设备的初始运行时PM状态都是挂起的，但它不需要反映设备的实际物理状态。因此，如果设备最初是活动的（换句话说，它能够处理I/O），则必须使用`pm_runtime_set_active()`（它将设置`power.runtime_status`为`RPM_ACTIVE`）来将其运行时PM状态更改为活动状态，并且如果可能的话，必须在为设备调用`pm_runtime_enable()`之前使用`pm_runtime_get_noresume()`增加其使用计数。一旦设备完全初始化，就可以对其调用`pm_runtime_put()`。
- en: The reason for invoking `pm_runtime_get_noresume()` here is that, if there is
    a call to `pm_runtime_put()`, the device usage count will come back to zero, which
    corresponds to an idle condition, and then an idle notification will be carried
    out. At this time, you’ll be able to check whether necessary conditions have been
    met and suspend the device. However, if the initial device state is *disabled*,
    there is no need to do so.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里调用`pm_runtime_get_noresume()`的原因是，如果调用了`pm_runtime_put()`，设备的使用计数将回到零，这对应于空闲状态，然后将进行空闲通知。此时，您可以检查是否满足必要条件并挂起设备。但是，如果初始设备状态为*禁用*，则无需这样做。
- en: There are also `pm_runtime_get()`, `pm_runtime_get_sync()`, `pm_runtime_put_noidle()`,
    and `pm_runtime_put_sync()` helpers. The difference between `pm_runtime_get_sync()`,
    `pm_runtime_get()`, and `pm_runtime_get_noresume()` is that the former will synchronously
    (immediately) carry out a resumption of the device if the active/resume condition
    is matched after the device usage count has been incremented, while the second
    helper will do it asynchronously (submitting a request for it). The third and
    final one will return immediately after having decremented the device usage count
    (without even checking the resume condition). The same mechanism applies to `pm_runtime_put_sync()`,
    `pm_runtime_put()`, and `pm_runtime_put_noidle()`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`pm_runtime_get()`、`pm_runtime_get_sync()`、`pm_runtime_put_noidle()`和`pm_runtime_put_sync()`辅助程序。`pm_runtime_get_sync()`、`pm_runtime_get()`和`pm_runtime_get_noresume()`之间的区别在于，前者在增加设备使用计数后，如果匹配了活动/恢复条件，将同步（立即）执行设备的恢复，而第二个辅助程序将异步执行（提交请求）。第三个和最后一个在减少设备使用计数后立即返回（甚至不检查恢复条件）。相同的机制适用于`pm_runtime_put_sync()`、`pm_runtime_put()`和`pm_runtime_put_noidle()`。
- en: The number of active children of a given device affects the usage count of this
    device. Normally, the parent is needed to access the child, so powering down the
    parent while children are active would be counterproductive. Sometimes, however,
    it might be necessary to ignore active children of a device when determining whether
    this device is idle. One good example is the I2C bus, where the bus can be reported
    as idle while devices sitting on this bus (children) are active. For such cases,
    `pm_suspend_ignore_children()` can be invoked to allow a device to report as idle
    even when it has active children(s).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 给定设备的活动子级数量会影响该设备的使用计数。通常，需要父级才能访问子级，因此在子级活动时关闭父级将是适得其反的。然而，有时可能需要忽略设备的活动子级，以确定该设备是否处于空闲状态。一个很好的例子是I2C总线，在这种情况下，总线可以在总线上的设备（子级）活动时报告为空闲。对于这种情况，可以调用`pm_suspend_ignore_children()`来允许设备在具有活动子级时报告为空闲。
- en: Runtime PM synchronous and asynchronous operations
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行时PM同步和异步操作
- en: In the previous section, we introduced the fact that the PM core could carry
    out synchronous or asynchronous PM operations. While things are straightforward
    for synchronous operations (method calls are serialized), we need to pay some
    attention to what steps are performed while invoking things asynchronously in
    a PM context.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们介绍了PM核心可以执行同步或异步PM操作的事实。对于同步操作，事情很简单（方法调用是串行的），但是在PM上下文中异步调用时，我们需要注意执行哪些步骤。
- en: 'You should keep in mind that, in asynchronous mode, a request for the action
    is submitted instead or invoking this action’s handler immediately. It works as
    follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记住，在异步模式下，提交动作的请求而不是立即调用此动作的处理程序。它的工作方式如下：
- en: The PM core sets the device’s `power.request` field (which is of the `enum rpm_request`
    type) with the type of request to be submitted (in other words, `RPM_REQ_IDLE`
    for an idle notification request, `RPM_REQ_SUSPEND` for a suspend request, or
    `RPM_REQ_AUTOSUSPEND` for an autosuspend request), which corresponds to the action
    to be performed.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PM核心将设备的`power.request`字段（类型为`enum rpm_request`）设置为要提交的请求类型（换句话说，对于空闲通知请求为`RPM_REQ_IDLE`，对于挂起请求为`RPM_REQ_SUSPEND`，对于自动挂起请求为`RPM_REQ_AUTOSUSPEND`），这对应于要执行的动作。
- en: The PM core sets the device’s `power.request_pending` field to `true`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PM核心将设备的`power.request_pending`字段设置为`true`。
- en: The PM core queues (schedules for a later execution) the device’s RPM-related
    work (`power.work`, whose work function is `pm_runtime_work()`; see `pm_runtime_init()`
    where it is initialized) in the Global PM-related work queue.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PM核心队列（计划稍后执行）设备的RPM相关工作（`power.work`，其工作函数为`pm_runtime_work()`；请参阅`pm_runtime_init()`，其中初始化了该工作）在全局PM相关工作队列中。
- en: When this work has the chance to run, the work function (that is, `pm_runtime_work()`)
    will first check whether there is still a request pending on the device (`if (dev->power.request_pending)`)
    and perform a `switch ... case` on the device’s `power.request_pending` field
    in order to invoke the underlying request handler.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当这项工作有机会运行时，工作函数（即`pm_runtime_work()`）将首先检查设备上是否仍有待处理的请求（`if (dev->power.request_pending)`），并根据设备的`power.request_pending`字段执行`switch
    ... case`以调用底层请求处理程序。
- en: Do note that a work queue manages its own thread(s), which can run scheduled
    works. Because, in asynchronous mode, the handler is scheduled in a work queue,
    asynchronous PM-related helpers are totally safe to be invoked in an atomic context.
    If invoked within an IRQ handler, for example, it would be equivalent to deferring
    the PM request handling.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，工作队列管理自己的线程，可以运行计划的工作。因为在异步模式下，处理程序被安排在工作队列中，异步PM相关的辅助程序完全可以在原子上下文中调用。例如，在IRQ处理程序中调用，相当于推迟PM请求处理。
- en: Autosuspend
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动挂起
- en: Autosuspend is a mechanism used by drivers that do not want their device to
    suspend as soon as it becomes idle at runtime, but they rather want the device
    to remain inactive for a certain minimum period of time first.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 自动挂起是由不希望设备在运行时一旦空闲就挂起的驱动程序使用的机制，而是希望设备在一定的最短时间内保持不活动。
- en: In the context of RPM, the term *autosuspend* does not mean the device automatically
    suspends itself. It is instead based on a timer that, upon expiration, will queue
    a suspend request. This timer is actually the device’s `power.suspend_timer` field
    (see `pm_runtime_init()` where it is set up). Calling `pm_runtime_put_autosuspend()`
    will start the timer, while `pm_runtime_set_autosuspend_delay()` will set the
    timeout (though that can be set via `sysfs` in the `/sys/devices/.../power/autosuspend_delay_ms`
    attribute) represented by the device’s `power.autosuspend_delay` field.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在RPM的背景下，术语*autosuspend*并不意味着设备会自动挂起自己。相反，它是基于一个定时器，当定时器到期时，将排队一个挂起请求。这个定时器实际上是设备的`power.suspend_timer`字段（请参阅`pm_runtime_init()`，在那里它被设置）。调用`pm_runtime_put_autosuspend()`将启动定时器，而`pm_runtime_set_autosuspend_delay()`将设置超时（尽管可以通过`sysfs`中的`/sys/devices/.../power/autosuspend_delay_ms`属性设置）。
- en: This timer can be used by the `pm_schedule_suspend()` helper as well, with a
    delay in argument (which in this case will take precedence on the one set in the
    `power.autosuspend_delay` field), after which a suspend request will be submitted.
    You can regard this timer as something that can be used to add a delay between
    the counters reaching zero and the device being considered to be idle. This is
    useful for devices with a high cost associated with turning on or off.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`pm_schedule_suspend()`辅助程序也可以使用这个定时器，带有延迟参数（在这种情况下，它将优先于`power.autosuspend_delay`字段中设置的延迟），之后将提交一个挂起请求。您可以将这个定时器视为可以用来在计数器达到零和设备被视为空闲之间添加延迟的东西。这对于开关成本很高的设备非常有用。'
- en: In order to use `autosuspend`, subsystems or drivers must call `pm_runtime_use_autosuspend()`
    (preferably before registering the device). This helper will set the device’s
    `power.use_autosuspend` field to `true`. After soliciting a device on which autosuspend
    is enabled, you should invoke `pm_runtime_mark_last_busy()` on this device, which
    lets it set the `power.last_busy` field to the current time (in `jiffies`), because
    this field is used in calculating inactivity periods for autosuspend (for example,
    `new_expire_time = last_busy + msecs_to_jiffies(autosuspend_delay)`).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`autosuspend`，子系统或驱动程序必须调用`pm_runtime_use_autosuspend()`（最好在注册设备之前）。这个辅助程序将把设备的`power.use_autosuspend`字段设置为`true`。在启用了autosuspend的设备上调用`pm_runtime_mark_last_busy()`，这样它就可以将`power.last_busy`字段设置为当前时间（以`jiffies`为单位），因为这个字段用于计算autosuspend的空闲期（例如，`new_expire_time
    = last_busy + msecs_to_jiffies(autosuspend_delay)`）。
- en: Given all the runtime PM concepts introduced, let’s put it all together now
    and see how things are done in a real driver.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到引入的所有运行时PM概念，现在让我们把所有东西放在一起，看看在一个真实的驱动程序中是如何完成的。
- en: Putting it all together
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: The preceding theoretical studies of the runtime PM core would be less significant
    without a genuine case study. Now is the time to see how the previous concept
    is applied. For this case study, we will pick the `bh1780` Linux driver, which
    is a `drivers/iio/light/bh1780.c` in the Linux kernel sources.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有真实案例研究的情况下，对运行时PM核心的理论研究将变得不那么重要。现在是时候看看之前的概念是如何应用的。对于这个案例研究，我们将选择Linux驱动程序`bh1780`，它是Linux内核源代码中的`drivers/iio/light/bh1780.c`。
- en: 'To start with, let’s see an excerpt of the `probe` method:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下`probe`方法的摘录：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding snippet, only the power management-related calls are left,
    for the sake of readability. First, `pm_runtime_get_noresume()` will increment
    the device usage count without carrying an idle notification of the device (the
    `_noidle` suffix). You may use the `pm_runtime_get_noresume()` interface to turn
    off the runtime suspend function or to make the usage count positive even while
    the device is suspended, so as to avoid issues that do not wake up normally due
    to the runtime suspension. Then, the next line in the driver is `pm_runtime_set_active()`.
    This helper marks the device as active (`power.runtime_status = RPM_ACTIVE`) and
    clears the device’s `power.runtime_error` field. Additionally, the device parent’s
    counter of unsuspended (active) children is modified to reflect the new status
    (it is incremented actually). Invoking `pm_runtime_set_active()` on a device will
    prevent this device’s parent from suspending at runtime (assuming the parent’s
    runtime PM is enabled), unless the parent’s `power.ignore_children` flag is set.
    For this reason, once `pm_runtime_set_active()` has been called for the device,
    `pm_runtime_enable()` should be called for it too, as soon as is reasonably possible.
    Invoking this function is not mandatory; it has to be coherent with the PM core
    and the status of the device, assuming the initial status is `RPM_SUSPENDED`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，为了便于阅读，只留下了与电源管理相关的调用。首先，`pm_runtime_get_noresume()`将增加设备的使用计数，而不携带设备的空闲通知（`_noidle`后缀）。您可以使用`pm_runtime_get_noresume()`接口关闭运行时挂起功能，或者在设备挂起时使使用计数为正，以避免由于运行时挂起而无法正常唤醒的问题。然后，在驱动程序中的下一行是`pm_runtime_set_active()`。这个辅助程序将设备标记为活动的（`power.runtime_status
    = RPM_ACTIVE`），并清除设备的`power.runtime_error`字段。此外，设备父级的未挂起（活动）子级计数将被修改以反映新的状态（实际上是增加）。在设备上调用`pm_runtime_set_active()`将阻止该设备的父级在运行时挂起（假设父级的运行时PM已启用），除非父级的`power.ignore_children`标志已设置。因此，一旦为设备调用了`pm_runtime_set_active()`，就应该尽快为其调用`pm_runtime_enable()`。调用这个函数并不是强制性的；它必须与PM核心和设备的状态保持一致，假设初始状态是`RPM_SUSPENDED`。
- en: Important note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: The opposite of `pm_runtime_set_active()` is `pm_runtime_set_suspended()`, which
    changes the device status to `RPM_SUSPENDED`, and decrements the parent’s counter
    of active children. An idle notification request for the parent is submitted.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`pm_runtime_set_active()`的相反操作是`pm_runtime_set_suspended()`，它将设备状态更改为`RPM_SUSPENDED`，并减少父级的活动子级计数。提交父级的空闲通知请求。'
- en: '`pm_runtime_enable()` is the mandatory runtime PM helper, which enables the
    runtime PM of a device, that is, de-increments the device’s `power.disable_depth`
    value in case its value is greater than `0`. For information, the device’s `power.disable_depth`
    value is checked on each runtime PM helper call, and its value must be `0` for
    the helper to progress. Its initial value is `1`, and this value is decremented
    upon a call to `pm_runtime_enable()`. On the error path, `pm_runtime_put_noidle()`
    is invoked in order to make the PM runtime counter balance, and `pm_runtime_disable()`
    completely disables the runtime PM on the device.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`pm_runtime_enable()`是强制的运行时PM助手，它启用设备的运行时PM，即在设备的`power.disable_depth`值大于`0`时递减该值。需要注意的是，每次运行时PM助手调用时都会检查设备的`power.disable_depth`值，该值必须为`0`才能继续执行。其初始值为`1`，并且在调用`pm_runtime_enable()`时递减该值。在错误路径上，会调用`pm_runtime_put_noidle()`以使PM运行时计数平衡，并且`pm_runtime_disable()`会完全禁用设备的运行时PM。'
- en: 'As you may have guessed, this driver also deals with the IIO framework, which
    means it exposes entries in sysfs, which correspond to its physical conversion
    channels. Reading the sysfs file corresponding to a channel will report the digital
    value of the conversion resulting from this channel. However, for the `bh1780`,
    the channel read entry point in its driver is `bh1780_read_raw()`. An excerpt
    of this method can be seen here:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，这个驱动程序也处理IIO框架，这意味着它在sysfs中公开了与其物理转换通道对应的条目。读取与通道对应的sysfs文件将报告该通道产生的转换的数字值。然而，对于`bh1780`，其驱动程序中的通道读取入口点是`bh1780_read_raw()`。该方法的摘录如下：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here again, only runtime PM-related function calls are worthy of our attention.
    In the event of a channel read, the preceding function is invoked. The device
    driver has to instruct the device to sample the channel, to perform the conversion
    whose result will be read by the device driver and reported to the reader. The
    thing is, the device may be in a suspended state. Thus, because the driver needs
    immediate access to the device, the driver calls `pm_runtime_get_sync()` on it.
    If you recall, this method increments the device usage count and carries out a
    synchronous (`_sync` suffix) resumption of the device. After the device resumes,
    the driver can talk with the device and read the conversion value. Because the
    driver supports autosuspend, `pm_runtime_mark_last_busy()` is called in order
    to mark the last time the device was active. This will update the timeout value
    of the timer used for autosuspend. Finally, the driver invokes `pm_runtime_put_autosuspend()`,
    which will carry out a runtime suspend of the device following the autosuspend
    timer expiration, unless this timer is restarted again by `pm_runtime_mark_last_busy()`
    being invoked somewhere or when entering the read function again (the reading
    of the channel, in sysfs, for example) prior to expiration.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，只有与运行时PM相关的函数调用值得我们关注。在通道读取时，会调用前面的函数。设备驱动程序必须指示设备对通道进行采样，执行转换，其结果将由设备驱动程序读取并报告给读取者。问题在于，设备可能处于挂起状态。因此，因为驱动程序需要立即访问设备，驱动程序在设备上调用`pm_runtime_get_sync()`。如果你还记得的话，这个方法会增加设备的使用计数，并进行同步（`_sync`后缀）恢复设备。设备恢复后，驱动程序可以与设备通信并读取转换值。因为驱动程序支持自动挂起，所以会调用`pm_runtime_mark_last_busy()`以标记设备最后活动的时间。这将更新用于自动挂起的定时器的超时值。最后，驱动程序调用`pm_runtime_put_autosuspend()`，这将在自动挂起定时器到期后执行设备的运行时挂起，除非该定时器在到期前由`pm_runtime_mark_last_busy()`在某处被调用重新启动，或者在再次进入读取函数（例如在sysfs中读取通道）之前到期。
- en: To summarize, before accessing the hardware, the driver can resume the device
    with `pm_runtime_get_sync()`, and when it’s finished with the hardware, the driver
    can notify the device as being idle with either `pm_runtime_put_sync()`, `pm_runtime_put()`,
    or `pm_runtime_put_autosuspend()` (assuming autosuspend is enabled, in which case
    `pm_runtime_mark_last_busy()` must be invoked beforehand in order to update the
    autosuspend timer’s timeout).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在访问硬件之前，驱动程序可以使用`pm_runtime_get_sync()`恢复设备，当完成硬件操作后，驱动程序可以使用`pm_runtime_put_sync()`、`pm_runtime_put()`或`pm_runtime_put_autosuspend()`通知设备处于空闲状态（假设启用了自动挂起，在这种情况下，必须先调用`pm_runtime_mark_last_busy()`以更新自动挂起定时器的超时）。
- en: 'Finally, let’s focus on the method invoked when the module is being unloaded.
    The following is an excerpt in which only PM-related calls are of interest:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们专注于模块被卸载时调用的方法。以下是一个摘录，其中只有与电源管理相关的调用是感兴趣的：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first runtime PM method invoked here is `pm_runtime_get_sync()`. This call
    gets us guessing that the device is going to be used, that is, the driver needs
    to access the hardware. Thus, this helper immediately resumes the device (it actually
    increments the device usage counter and carries out a synchronous resumption of
    the device). After this, `pm_runtime_put_noidle()` is called in order to de-increment
    the device usage count without carrying an idle notification. Next, `pm_runtime_disable()`
    is called in order to disable runtime PM on the device. This will increment `power.disable_depth`
    for the device and if it was zero previously, cancel all pending runtime PM requests
    for the device and wait for all operations in progress to complete, so that with
    regard to the PM core, the device no longer exists (remember, `power.disable_depth`
    will not match what the PM core expects, meaning that any further runtime PM helper
    invoked on this device will fail). Finally, the device is powered off thanks to
    an i2c command, after which its hardware status will reflect its runtime PM status.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里调用的第一个运行时PM方法是`pm_runtime_get_sync()`。这个调用让我们猜测设备将要被使用，也就是说，驱动程序需要访问硬件。因此，这个辅助函数立即恢复设备（实际上增加了设备的使用计数并进行了同步恢复设备）。之后，调用`pm_runtime_put_noidle()`以减少设备使用计数而不进行空闲通知。接下来，调用`pm_runtime_disable()`以在设备上禁用运行时PM。这将增加设备的`power.disable_depth`，如果之前为零，则取消设备的所有挂起运行时PM请求，并等待所有正在进行的操作完成，因此从PM核心的角度来看，设备不再存在（请记住，`power.disable_depth`将不匹配PM核心的期望，这意味着在此设备上调用的任何进一步的运行时PM辅助函数将失败）。最后，通过i2c命令关闭设备，之后其硬件状态将反映其运行时PM状态。
- en: 'The following are general rules that apply to runtime PM callback and execution:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是适用于运行时PM回调和执行的一般规则：
- en: '`->runtime_idle()` and `->runtime_suspend()` can only be executed for active
    devices (those whose status is active).'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->runtime_idle()`和`->runtime_suspend()`只能为活动设备（状态为活动）执行。'
- en: '`->runtime_idle()` and `->runtime_suspend()` can only be executed for a device
    with the usage counter equal to zero and either with the counter of active children
    equal to zero, or with the `power.ignore_children` flag set.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->runtime_idle()`和`->runtime_suspend()`只能为使用计数为零的设备执行，并且子设备的活动计数为零，或者设置了`power.ignore_children`标志。'
- en: '`->runtime_resume()` can only be executed for suspended devices (those whose
    status is *suspended*).'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`->runtime_resume()`只能为挂起的设备（状态为*挂起*）执行。'
- en: 'Additionally, the helper functions provided by the PM core obey the following
    rules:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，PM核心提供的辅助函数遵守以下规则：
- en: If `->runtime_suspend()` is about to be executed or there’s a pending request
    to execute it, `->runtime_idle()` will not be executed for the same device.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`->runtime_suspend()`即将被执行，或者有一个挂起的请求要执行它，`->runtime_idle()`将不会为同一设备执行。
- en: A request to execute or to schedule the execution of `->runtime_suspend()` will
    cancel any pending requests to execute `->runtime_idle()` for the same device.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行或计划执行`->runtime_suspend()`的请求将取消执行同一设备的`->runtime_idle()`的任何挂起请求。
- en: If `->runtime_resume()` is about to be executed or there’s a pending request
    to execute it, the other callbacks will not be executed for the same device.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`->runtime_resume()`即将被执行，或者有一个挂起的请求要执行它，其他回调将不会为同一设备执行。
- en: A request to execute `->runtime_resume()` will cancel any pending or scheduled
    requests to execute the other callbacks for the same device, except for scheduled
    autosuspends.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行`->runtime_resume()`的请求将取消执行同一设备的其他回调的任何挂起或计划请求，除了计划的自动挂起。
- en: The preceding rules are good indicators of reasons why any invocation of these
    callbacks may fail. From these, we can also observe that a resumption, or a request
    to resume, outperforms any other callback or request.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 上述规则是这些回调的任何调用可能失败的很好的指标。从中我们还可以观察到，恢复或请求恢复优于任何其他回调或请求。
- en: The concept of power domain
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电源域的概念
- en: Technically, a power domain is a set of devices sharing power resources (for
    example, clocks or power planes). From the kernel’s perspective, a power domain
    is a set of devices whose power management uses the same set of callbacks with
    common PM data at the subsystem level. From the hardware perspective, a power
    domain is a hardware concept for managing devices whose power voltages are correlated;
    for example, the video core IP sharing a power rail with the display IP.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，电源域是一组共享电源资源（例如时钟或电源平面）的设备。从内核的角度来看，电源域是一组使用相同的回调和子系统级别的公共PM数据的设备集合。从硬件的角度来看，电源域是一个用于管理电压相关的设备的硬件概念；例如，视频核心IP与显示IP共享一个电源轨。
- en: Because of SoC designs being more complex, an abstraction method needed to be
    found so that drivers remain as generic as possible; then, `genpd` came out. This
    stands for Generic Power Domain. It is a Linux Kernel abstraction that extends
    per-device runtime power management to a group of devices sharing power rails.
    Moreover, power domains are defined as part of a device tree in which relationships
    between devices and power controllers are described. This allows power domains
    to be redesigned on the fly and drivers to adapt without having to reboot the
    whole system or rebuild a new kernel.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SoC设计变得更加复杂，需要找到一种抽象方法，使驱动程序尽可能通用；然后，`genpd`出现了。这代表通用电源域。它是Linux内核的一个抽象，将每个设备的运行时电源管理扩展到共享电源轨的设备组。此外，电源域被定义为设备树的一部分，其中描述了设备和电源控制器之间的关系。这允许电源域在运行时重新设计，并且驱动程序可以适应而无需重新启动整个系统或重新构建新的内核。
- en: It is designed so that if a power domain object exists for a device, its PM
    callbacks take precedence over the bus type (or device class or type) callback.
    Generic documentation on this is available in `Documentation/devicetree/bindings/power/power_domain.txt`
    in kernel sources, and documentation related to your SoC can be found in the same
    directory.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 它被设计成如果设备存在电源域对象，则其PM回调优先于总线类型（或设备类或类型）回调。有关此的通用文档可在内核源代码的`Documentation/devicetree/bindings/power/power_domain.txt`中找到，与您的SoC相关的文档可以在同一目录中找到。
- en: System suspend and resume sequences
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统挂起和恢复序列
- en: 'The introduction of the `struct dev_pm_ops` data structure has somehow facilitated
    the understanding of the steps and actions performed by the PM core during a suspension
    or resumption phase, which can be summarized as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct dev_pm_ops`数据结构的引入在某种程度上促进了对PM核心在挂起或恢复阶段执行的步骤和操作的理解，可以总结如下：'
- en: '[PRE29]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding is the full system PM chain, as enumerated in `enum suspend_stat_step`,
    defined in `include/linux/suspend.h`. This flow should remind you of the `struct
    dev_pm_ops` data structure.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 上述是完整的系统PM链，列在`include/linux/suspend.h`中定义的`enum suspend_stat_step`中。这个流程应该让你想起`struct
    dev_pm_ops`数据结构。
- en: In the Linux kernel code, `enter_state()` is the function invoked by the system
    power management core to enter a system sleep state. Let’s now spend some time
    on what really goes on during system suspension and resumption.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux内核代码中，`enter_state()`是由系统电源管理核心调用的函数，用于进入系统睡眠状态。现在让我们花一些时间了解系统挂起和恢复期间真正发生了什么。
- en: Suspend stages
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂起阶段
- en: 'The following are the steps that `enter_state()` goes through when suspended:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在挂起时，`enter_state()`经历的步骤如下：
- en: It first invokes `sync()` on the filesystem (see `ksys_sync()`) if the `CONFIG_SUSPEND_SKIP_SYNC`
    kernel configuration option is not set.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果内核配置选项`CONFIG_SUSPEND_SKIP_SYNC`未设置，则首先在文件系统上调用`sync()`（参见`ksys_sync()`）。
- en: It invokes suspend notifiers (while the user space is still there). Refer to
    `register_pm_notifier()`, which is the helper used for their registration.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用挂起通知器（当用户空间仍然存在时）。参考`register_pm_notifier()`，这是用于注册它们的辅助程序。
- en: It freezes tasks (see `suspend_freeze_processes()`), which freezes the user
    space as well as kernel threads. This step is skipped if `CONFIG_SUSPEND_FREEZER`
    is not set in a kernel configuration.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它冻结任务（参见`suspend_freeze_processes()`），这会冻结用户空间以及内核线程。如果内核配置中未设置`CONFIG_SUSPEND_FREEZER`，则会跳过此步骤。
- en: Devices are suspended by invoking every `.suspend()` callbacks registered by
    drivers. This is the first phase of suspending (see `suspend_devices_and_enter()`).
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用驱动程序注册的每个`.suspend()`回调来挂起设备。这是挂起的第一阶段（参见`suspend_devices_and_enter()`）。
- en: It disables device interrupts (see `suspend_device_irqs()`). This prevents device
    drivers from receiving interrupts.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它禁用设备中断（参见`suspend_device_irqs()`）。这可以防止设备驱动程序接收中断。
- en: Then, the second phase of suspending devices happens (`.suspend_noirq` callbacks
    are invoked). This step is known as the *noirq* stage.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，发生设备挂起的第二阶段（调用`.suspend_noirq`回调）。这一步被称为*noirq*阶段。
- en: It disables non-boot CPUs (using a CPU hotplug). The CPU scheduler is told not
    to schedule anything on those CPUs before they go offline (see `disable_nonboot_cpus()`).
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它禁用非引导CPU（使用CPU热插拔）。在它们下线之前，CPU调度程序被告知不要在这些CPU上安排任何任务（参见`disable_nonboot_cpus()`）。
- en: It turns interrupts off.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭中断。
- en: It executes system core callbacks (see `syscore_suspend()`).
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行系统核心回调（参见`syscore_suspend()`）。
- en: It puts the system to sleep.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它让系统进入睡眠状态。
- en: This is a rough description of the actions performed before the system goes
    to sleep. The behavior of certain actions may vary slightly according to the sleep
    state the system is going to enter.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是系统进入睡眠状态之前执行的操作的粗略描述。某些操作的行为可能会根据系统即将进入的睡眠状态略有不同。
- en: Resume stages
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恢复阶段
- en: 'Once a system is suspended (however deep it is), once a wakeup event occurs,
    the system needs to resume. The following are the steps and actions the PM core
    performs in order to wake up the system:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦系统被挂起（无论有多深），一旦发生唤醒事件，系统就需要恢复。以下是PM核心执行的唤醒系统的步骤和操作：
- en: (Wakeup signal.)
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （唤醒信号。）
- en: Run the CPU’s wakeup code.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行CPU的唤醒代码。
- en: Execute system core callbacks.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行系统核心回调。
- en: Turn the interrupts on.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开中断。
- en: Enable non-boot CPUs (using the CPU hotplug).
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用非引导CPU（使用CPU热插拔）。
- en: The first phase of resuming devices (`.resume_noirq()` callbacks).
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复设备的第一阶段（`.resume_noirq()`回调）。
- en: Enable device interrupts.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用设备中断。
- en: The second phase of suspending devices (`.resume()` callbacks).
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挂起设备的第二阶段（`.resume()`回调）。
- en: Thaw tasks.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解冻任务。
- en: Call notifiers (when the user space is back).
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用通知器（当用户空间恢复时）。
- en: I will let you discover in the PM code which functions are invoked at each step
    of the resumption process. From within the driver, however, these steps are all
    transparent. The only thing the driver needs to do is to fill `struct dev_pm_ops`
    with the appropriate callbacks according to the steps it wishes to be involved
    in, as we will see in the next section.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我会让你在PM代码中发现在恢复过程的每个步骤中调用了哪些函数。然而，从驱动程序内部来看，这些步骤都是透明的。驱动程序唯一需要做的就是根据希望参与的步骤填充`struct
    dev_pm_ops`中的适当回调，我们将在下一节中看到。
- en: Implementing system sleep capability
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现系统睡眠功能
- en: System sleep and runtime PM are different things, though they are related to
    one another. There are cases where, by doing it in different ways, they bring
    the system to the same physical state. Thus, it is generally not a good idea to
    replace one with the other.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 系统睡眠和运行时PM是不同的东西，尽管它们彼此相关。有些情况下，通过不同的方式进行操作，它们会将系统带到相同的物理状态。因此，通常不建议用一个替换另一个。
- en: 'We have seen how device drivers participate in the system sleep by populating
    some callbacks in the `struct dev_pm_ops` data structure according to the sleep
    state they need to participate in. Commonly provided callbacks, irrespective of
    the sleep state, are `.suspend`, `.resume`, `.freeze`, `.thaw`, `.poweroff`, and
    `.restore`. They are quite generic callbacks and are defined as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到设备驱动程序如何通过根据它们需要参与的睡眠状态在`struct dev_pm_ops`数据结构中填充一些回调来参与系统休眠。无论睡眠状态如何，通常提供的回调都是`.suspend`、`.resume`、`.freeze`、`.thaw`、`.poweroff`和`.restore`。它们是相当通用的回调，定义如下：
- en: '`.suspend`: This is executed before the system is put into a sleep state in
    which the contents of the main memory are preserved.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .suspend：在将系统置于保留主存储器内容的睡眠状态之前执行此操作。
- en: '`.resume`: This callback is invoked after waking the system up from a sleep
    state in which the contents of the main memory were preserved, and the state of
    the device at the time this callback is run depends on the platform and subsystem
    the device belongs to.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .resume：在从保留主存储器内容的睡眠状态唤醒系统后调用此回调，此时设备的状态取决于设备所属的平台和子系统。
- en: '`.freeze`: Hibernation-specific, this callback is executed before creating
    a hibernation image. It’s analogous to `.suspend`, but it should not enable the
    device to signal wakeup events or change its power state. Most device drivers
    implementing this callback only have to save the device setting in memory so that
    it can be used back during subsequent `.resume` from hibernation.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .freeze：特定于休眠，此回调在创建休眠镜像之前执行。它类似于`.suspend`，但不应该使设备发出唤醒事件或更改其电源状态。大多数实现此回调的设备驱动程序只需将设备设置保存在内存中，以便在随后的休眠恢复中可以重新使用。
- en: '`.thaw`: This callback is hibernation-specific, and it is executed after creating
    a hibernation image OR if the creation of an image has failed. It is also executed
    after a failed attempt to restore the contents of main memory from such an image.
    It must undo the changes made by the preceding `.freeze` in order to make the
    device operate in the same way as immediately prior to the call to `.freeze`.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .thaw：这是特定于休眠的回调，在创建休眠镜像后执行，或者如果创建镜像失败，则执行。在尝试从这样的镜像中恢复主存储器的内容失败后，也会执行。它必须撤消前面`.freeze`所做的更改，以使设备以与调用`.freeze`之前相同的方式运行。
- en: '`.poweroff`: Also hibernation-specific, this is executed after saving a hibernation
    image. It’s analogous to `.suspend`, but it need not save the device’s settings
    in memory.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .poweroff：也是特定于休眠，此回调在保存休眠镜像后执行。它类似于`.suspend`，但不需要在内存中保存设备的设置。
- en: '`.restore`: This is the last hibernation-specific callback, which is executed
    after restoring the contents of the main memory from a hibernation image. It’s
    analogous to `.resume`.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .restore：这是最后一个特定于休眠的回调，在从休眠镜像中恢复主存储器的内容后执行。它类似于`.resume`。
- en: 'Most of the preceding callbacks are quite similar or perform roughly similar
    operations. While the `.resume`, `.thaw`, and `.restore` trio may perform similar
    tasks, the same is true for the other trio – `->suspend`, `->freeze`, and `->poweroff`.
    Thus, in order to improve code readability or facilitate callback population,
    the PM core provides the `SET_SYSTEM_SLEEP_PM_OPS` macro, which takes `suspend`
    and `resume` functions and populates system-related PM callbacks as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数前面的回调都是相似的，或者执行大致相似的操作。虽然`.resume`、`.thaw`和`.restore`三者可能执行类似的任务，但对于另一个三者——`->suspend`、`->freeze`和`->poweroff`也是如此。因此，为了提高代码可读性或简化回调填充，PM
    核心提供了`SET_SYSTEM_SLEEP_PM_OPS`宏，它接受`suspend`和`resume`函数，并填充系统相关的 PM 回调如下：
- en: '[PRE30]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The same is true for `_noirq()`-related callbacks. In case the driver only
    needs to participate in the `noirq` phase of the system suspend, the `SET_NOIRQ_SYSTEM_SLEEP_PM_OPS`
    macro can be used in order to automatically populate `_noirq()`-related callbacks
    in the `struct dev_pm_ops` data structure. The following is a definition of the
    macro:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 与`_noirq()`相关的回调也是如此。如果驱动程序只需要参与系统挂起的`noirq`阶段，则可以使用`SET_NOIRQ_SYSTEM_SLEEP_PM_OPS`宏，以便自动填充`struct
    dev_pm_ops`数据结构中的`_noirq()`相关回调。以下是该宏的定义：
- en: '[PRE31]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding macro takes only two parameters, which represent, as in the former
    macro, the `suspend` and `resume` callbacks, but for the `noirq` phase this time.
    You should remember that such callbacks are invoked with IRQs disabled on the
    system.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的宏只有两个参数，就像前面的宏一样，表示这次是`noirq`阶段的`suspend`和`resume`回调。您应该记住，这些回调在系统上禁用 IRQ
    时被调用。
- en: 'Finally, there is the `SET_LATE_SYSTEM_SLEEP_PM_OPS` macro, which will point
    `-> suspend_late`, `-> freeze_late`, and `-> poweroff_late` to the same function,
    and vice versa for `->resume_early`, `->thaw_early`, and `->restore_early`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有`SET_LATE_SYSTEM_SLEEP_PM_OPS`宏，它将`->suspend_late`、`->freeze_late`和`->poweroff_late`指向相同的函数，反之亦然，将`->resume_early`、`->thaw_early`和`->restore_early`指向相同的函数：
- en: '[PRE32]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In addition to reducing the coding effort, all the preceding macros are conditioned
    with the `#ifdef CONFIG_PM_SLEEP` kernel configuration option so that they are
    not built if the PM is not needed. Finally, if you want to use the same suspend
    and resume callbacks for suspension to RAM and hibernation, you can use the following
    command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 除了减少编码工作外，所有前面的宏都受到`#ifdef CONFIG_PM_SLEEP`内核配置选项的限制，以便在不需要 PM 的情况下不构建它们。最后，如果要将相同的挂起和恢复回调用于挂起到
    RAM 和休眠，可以使用以下命令：
- en: '[PRE33]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding snippet, `name` represents the name with which the device PM
    ops structure will be instantiated. `suspend_fn` and `resume_fn` are the callbacks
    to be invoked when the system is entering a suspend state or when it resumes from
    a sleep state.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的片段中，`name`表示设备 PM 操作结构的实例化名称。`suspend_fn`和`resume_fn`是在系统进入挂起状态或从睡眠状态恢复时要调用的回调。
- en: Now that we are able to implement system sleep capabilities in our driver code,
    let’s see how to behave a system wakeup source, which allows the sleep state to
    be exited.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够在驱动程序代码中实现系统休眠功能，让我们看看如何行为系统唤醒源，允许退出睡眠状态。
- en: Being a source of system wakeup
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成为系统唤醒源
- en: The PM core allows the system to be awoken following a system suspend. A device
    capable of system wakeup is known as a **wakeup source** in PM language. For a
    wakeup source to operate normally, it needs a so-called **wakeup event**, which,
    most of time, is assimilated to an IRQ line. In other words, a wakeup source generates
    wakeup events. When a wakeup source generates a wakeup event, the wakeup source
    is set to the activated state through the interface provided by the wakeup event’s
    framework. When the event processing ends, it is set to the deactivated state.
    The interval between activate and deactivate indicates that the event is being
    processed. In this section, we will see how to make your device be a source of
    system wakeup in driver code.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: PM核心允许系统在系统暂停后被唤醒。能够唤醒系统的设备在PM语言中被称为**唤醒源**。为了使唤醒源正常工作，它需要一个所谓的**唤醒事件**，大多数情况下，这被等同于IRQ线。换句话说，唤醒源生成唤醒事件。当唤醒源生成唤醒事件时，通过唤醒事件框架提供的接口将唤醒源设置为激活状态。当事件处理结束时，它被设置为非激活状态。激活和停用之间的间隔表示事件正在被处理。在本节中，我们将看到如何在驱动程序代码中使您的设备成为系统唤醒源。
- en: 'Wakeup sources work so that when there is any wakeup event being processed
    in the system, suspension is not allowed. If suspension is in progress, it is
    terminated. The kernel abstracts wakeup sources by means of `struct wakeup_source`,
    which is also used for collecting statistics related to them. The following is
    a definition of this data structure in `include/linux/pm_wakeup.h`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 唤醒源的工作方式是，当系统中有任何唤醒事件正在被处理时，不允许暂停。如果暂停正在进行，它将被终止。内核通过`struct wakeup_source`来抽象唤醒源，该结构也用于收集与它们相关的统计信息。以下是`include/linux/pm_wakeup.h`中此数据结构的定义：
- en: '[PRE34]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This structure is absolutely useless for you in terms of code, but studying
    it will help you understand what wakeup source `sysfs` attributes mean:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构对于您的代码来说是完全无用的，但是研究它将有助于您理解`sysfs`属性的唤醒源的含义：
- en: '`entry` is used to track all wakeup sources in a linked list.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entry`用于在链表中跟踪所有唤醒源。'
- en: '`timer` goes hand in hand with `timer_expires`. When a wakeup source generates
    a wakeup event and that event is being processed, the wakeup source is said to
    be *active*, and this prevents system suspension. After the wakeup event is processed
    (the system is no longer required to be active for this purpose), it returns to
    being inactive. Both activate and deactivate operations can be performed by the
    driver, or the driver can decide otherwise by specifying a timeout during activation.
    This timeout will be used by the PM wakeup core to configure a timer that will
    automatically set the event to the inactive state after it expires. `timer` and
    `timer_expires` are used for this purpose.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`计时器`与`timer_expires`密切相关。当唤醒源生成唤醒事件并且该事件正在被处理时，唤醒源被称为*活动的*，这会阻止系统暂停。处理完唤醒事件后（系统不再需要为此目的处于活动状态），它将恢复为非活动状态。驱动程序可以执行激活和停用操作，也可以通过在激活期间指定超时来决定其他操作。这个超时将被PM唤醒核心用来配置一个定时器，在超时后自动将事件设置为非活动状态。`timer`和`timer_expires`就是用于这个目的。'
- en: '`total_time` is the total time this wakeup source has been active. It sums
    up the total amount of time the wakeup source spent in the active state. It is
    a good indicator of the busy level and power consumption level of the device corresponding
    to the wakeup source.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`total_time`是这个唤醒源处于活动状态的总时间。它总结了唤醒源在活动状态下花费的总时间。这是设备繁忙水平和功耗水平的良好指标。'
- en: '`max_time` is the longest amount of time that the wakeup source remained (or
    was continuously) in the active state. The longer it is, the more abnormal it
    is.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_time`是唤醒源保持（或连续）处于活动状态的最长时间。时间越长，异常性就越大。'
- en: '`last_time` indicates the start time of the last time this wakeup source was
    active.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`last_time`表示此唤醒源上次活动的开始时间。'
- en: '`start_prevent_time` is the point in time when the wakeup source started to
    prevent the system from autosleeping.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start_prevent_time`是唤醒源开始阻止系统自动休眠的时间点。'
- en: '`prevent_sleep_time` is the total time this wakeup source prevented the system
    from autosleeping.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prevent_sleep_time`是这个唤醒源阻止系统自动休眠的总时间。'
- en: '`event_count` represents the number of events reported by the wakeup source.
    In other words, it indicates the number of signaled wakeup events.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event_count`表示唤醒源报告的事件数量。换句话说，它表示被触发的唤醒事件的数量。'
- en: '`active_count` represents the number of times the wakeup source was activated.
    This value may not be relevant or coherent in certain situations. For example,
    when a wakeup event occurs, the wakeup source needs to be switched to the active
    state. However, this is not always the case because the event may occur while
    the wakeup source is already activated. Therefore `active_count` may be less than
    `event_count`, in which case, it would mean it is likely that another wakeup event
    was generated before the previous wakeup event was processed until the end. This
    reflects the business of the equipment represented by the wakeup source to some
    extent.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active_count`表示唤醒源被激活的次数。在某些情况下，这个值可能不相关或不一致。例如，当唤醒事件发生时，唤醒源需要切换到激活状态。但这并不总是这样，因为事件可能发生在唤醒源已经被激活的情况下。因此`active_count`可能小于`event_count`，在这种情况下，这可能意味着在上一个唤醒事件被处理完之前，很可能另一个唤醒事件被生成。这在一定程度上反映了唤醒源所代表的设备的繁忙程度。'
- en: '`relax_count` represents the number of times the wakeup source was deactivated.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`relax_count`表示唤醒源被停用的次数。'
- en: '`expire_count` represents the number of times the wakeup source timeout has
    expired.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expire_count`表示唤醒源超时的次数。'
- en: '`wakeup_count` is the number of times the wakeup source has terminated the
    suspend process. If the wakeup source generates a wakeup event during the suspend
    process, the suspend process will be aborted. This variable records the number
    of times the wakeup source has terminated the suspend process. This may be a good
    indicator for checking whether you established that the system always fails to
    suspend.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wakeup_count`是唤醒源终止挂起过程的次数。如果唤醒源在挂起过程中生成唤醒事件，挂起过程将被中止。此变量记录了唤醒源终止挂起过程的次数。这可能是检查系统是否总是无法挂起的良好指标。'
- en: '`active` represents the activated state of the wakeup source.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active`表示唤醒源的激活状态。'
- en: '`autosleep_enabled`, for me, records the state of the system’s autosleep status,
    whether it is enabled or not.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于我来说，`autosleep_enabled`记录了系统的自动睡眠状态，无论它是否启用。
- en: In order for a device to be a wakeup source, its driver must call `device_init_wakeup()`.
    This function sets the device’s `power.can_wakeup` flag (so that the `device_can_wakeup()`
    helper returns the current device’s capability of being a wakeup source) and adds
    its wakeup-related attributes to sysfs. Additionally, it creates a wakeup source
    object, registers it, and attaches it to the device (`dev->power.wakeup`). However,
    `device_init_wakeup()` only turns the device into a wakeup-capable device without
    assigning a wakeup event to it.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使设备成为唤醒源，其驱动程序必须调用`device_init_wakeup()`。此函数设置设备的`power.can_wakeup`标志（以便`device_can_wakeup()`助手返回当前设备作为唤醒源的能力），并将其唤醒相关属性添加到sysfs。此外，它创建一个唤醒源对象，注册它，并将其附加到设备（`dev->power.wakeup`）。但是，`device_init_wakeup()`只会将设备变成一个具有唤醒功能的设备，而不会为其分配唤醒事件。
- en: Important note
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that only devices with wake-up capability will have a power directory in
    sysfs to provide all wakeup information.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只有具有唤醒功能的设备才会在sysfs中有一个power目录，提供所有唤醒信息。
- en: 'In order to assign a wakeup event, the driver must call `enable_irq_wake()`,
    giving as a parameter the IRQ line that will be used as a wakeup event. What `enable_irq_wake()`
    does may be platform-specific (Among other things it invokes the `irq_chip.irq_set_wake`
    callback exposed by the underlying irqchip driver). In addition to turning on
    the platform logic for handling the given IRQ as a system wakeup interrupt line,
    it instructs `suspend_device_irqs()` (which is invoked on the system suspend path:
    refer to the *Suspend stages* section, *step 5*) to treat the given IRQ differently.
    As a result, the IRQ will remain enabled for the next interrupt, after which it
    will be disabled, marked as pending, and suspended so that it will be re-enabled
    by `resume_device_irqs()` during the subsequent system resumption. This makes
    the driver’s `->suspend` method the right place to invoke `enable_irq_wake()`,
    so that the wakeup event is always rearmed at the right moment. On the other hand,
    the driver’s `->resume` callback is the right place for invoking `disable_irq_wake()`,
    which would turn off that platform configuration for the system wakeup capability
    of the IRQ.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分配唤醒事件，驱动程序必须调用`enable_irq_wake()`，并将用作唤醒事件的IRQ线作为参数。`enable_irq_wake()`的功能可能是特定于平台的（除其他功能外，它还调用底层irqchip驱动程序公开的`irq_chip.irq_set_wake`回调）。除了打开处理给定IRQ作为系统唤醒中断线的平台逻辑外，它还指示`suspend_device_irqs()`（在系统挂起路径上调用：参考*Suspend
    stages*部分，*step 5*）以不同方式处理给定的IRQ。因此，IRQ将保持启用状态，直到下一个中断，然后将被禁用，标记为挂起，并暂停，以便在随后的系统恢复期间由`resume_device_irqs()`重新启用。这使得驱动程序的`->suspend`方法成为调用`enable_irq_wake()`的正确位置，以便在正确时刻始终重新激活唤醒事件。另一方面，驱动程序的`->resume`回调是调用`disable_irq_wake()`的正确位置，该回调将关闭IRQ的系统唤醒功能的平台配置。
- en: While the device’s capability of being a wakeup source is a matter of hardware,
    whether or not a wakeup-capable device should issue wakeup events is a policy
    decision and is managed by the user space through a `sysfs` attribute, `/sys/devices/.../power/wakeup`.
    This file allows the user space to check or decide whether the device (through
    its wakeup event) is enabled to wake up the system from sleep states. This file
    can be read and written to. When read, either `enabled` or `disabled` can be returned.
    If `enabled` is returned, this would mean the device is able to issue the events;
    if instead `disabled` is returned, this would mean the device is not able to do
    so. Writing `enabled` or `disabled` strings to it will indicate whether or not,
    respectively, the device is supposed to signal system wakeup (the kernel `device_may_wakeup()`
    helper will return `true` or `false`, respectively). Do note that this file is
    not present for the devices that are not capable of generating system wakeup events.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 设备作为唤醒源的能力是硬件问题，唤醒能力设备是否应发出唤醒事件是一项政策决定，并由用户空间通过`sysfs`属性`/sys/devices/.../power/wakeup`进行管理。此文件允许用户空间检查或决定设备（通过其唤醒事件）是否能够唤醒系统从睡眠状态中唤醒。此文件可以读取和写入。读取时，可以返回`enabled`或`disabled`。如果返回`enabled`，这意味着设备能够发出事件；如果返回`disabled`，这意味着设备无法这样做。向其写入`enabled`或`disabled`字符串将指示设备是否应该信号系统唤醒（内核`device_may_wakeup()`助手将分别返回`true`或`false`）。请注意，对于无法生成系统唤醒事件的设备，此文件不存在。
- en: 'Let’s see in an example how drivers make use of the wakeup capability of the
    device. The following is an excerpt of the *i.MX6 SNVS* powerkey driver, in `drivers/input/keyboard/snvs_pwrkey.c`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，看看驱动程序如何利用设备的唤醒功能。以下是`i.MX6 SNVS` powerkey驱动程序的摘录，位于`drivers/input/keyboard/snvs_pwrkey.c`中：
- en: '[PRE35]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code excerpt, from top to bottom, we have the driver probe
    method, which first enables the device wakeup capability using the `device_init_wakeup()`
    function. Then, in the PM resume callback, it checks whether the device is allowed
    to issue a wakeup signal thanks to the `device_may_wakeup()` helper, prior to
    enabling the wakeup event by calling `enable_irq_wake()`, with the associated
    IRQ number as a parameter. The reason for using `device_may_wakeup()` for conditioning
    wakeup event enabling/disabling is because the user space may have changed the
    wakeup policy for this device (thanks to the `/sys/devices/.../power/wakeup` `sysfs`
    file), in which case this helper will return the current enabled/disabled status.
    This helper enables coherence with the user space decision. The same is true for
    the resume method, which does the same checks prior to disabling the wakeup event’s
    IRQ line.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码摘录中，从上到下，我们有驱动程序探测方法，首先使用`device_init_wakeup()`函数启用设备唤醒功能。然后，在PM恢复回调中，它通过调用`enable_irq_wake()`来检查设备是否允许发出唤醒信号，然后通过`device_may_wakeup()`助手来启用唤醒事件，参数是相关的IRQ号。使用`device_may_wakeup()`来进行唤醒事件的启用/禁用的原因是因为用户空间可能已经更改了该设备的唤醒策略（通过`/sys/devices/.../power/wakeup`
    `sysfs`文件），在这种情况下，此助手将返回当前启用/禁用状态。此助手使用户空间决策与启用一致。在禁用唤醒事件的IRQ线之前，恢复方法也会进行相同的检查。
- en: 'Next, at the bottom of the driver code, we can see the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在驱动程序代码的底部，我们可以看到以下内容：
- en: '[PRE36]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding shows the usage of the famous `SIMPLE_DEV_PM_OPS` macro, which
    means the same suspend callback (that is, `imx_snvs_pwrkey_suspend`) will be used
    for Suspend-to-RAM or hibernation sleep states, and the same resume callback (`imx_snvs_pwrkey_resume`
    actually) will be used to resume from these states. The device PM structure is
    named `imx_snvs_pwrkey_pm_ops` as we can see in the macro, and fed to the driver
    later. Populating PM ops is as simple as that.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 前面显示了著名的`SIMPLE_DEV_PM_OPS`宏的用法，这意味着相同的挂起回调（即`imx_snvs_pwrkey_suspend`）将用于挂起到RAM或休眠睡眠状态，并且相同的恢复回调（实际上是`imx_snvs_pwrkey_resume`）将用于从这些状态恢复。设备PM结构被命名为`imx_snvs_pwrkey_pm_ops`，正如我们在宏中看到的那样，并且稍后提供给驱动程序。填充PM操作就是这么简单。
- en: 'Before ending this section, let’s pay attention to the IRQ handler in this
    device driver:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本节之前，让我们注意一下此设备驱动程序中的IRQ处理程序：
- en: '[PRE37]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The key function here is `pm_wakeup_event()`. Roughly speaking, it reports
    a wakeup event. Additionally, this will halt the current system state transition.
    For example, on the suspend path, it will abort the suspend operation and prevent
    the system from going to sleep. The following is the prototype of this function:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键函数是`pm_wakeup_event()`。粗略地说，它报告了一个唤醒事件。此外，这将停止当前系统状态转换。例如，在挂起路径上，它将中止挂起操作并阻止系统进入睡眠状态。以下是此函数的原型：
- en: '[PRE38]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first parameter is the device to which the wakeup source belongs, and `msec`,
    the second parameter, is the number of milliseconds to wait before the wakeup
    source is automatically switched to an inactive state by the PM wakeup core. If
    `msec` equals 0, then the wakeup source is immediately disabled after the event
    has been reported. If `msec` is different from 0, then the wakeup source deactivation
    is scheduled `msec` milliseconds later in the future.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是唤醒源所属的设备，第二个参数`msec`是在PM唤醒核心自动将唤醒源切换到非活动状态之前等待的毫秒数。如果`msec`等于0，则在报告事件后立即禁用唤醒源。如果`msec`不等于0，则唤醒源的停用将在未来的`msec`毫秒后计划进行。
- en: 'This is where the wakeup source’s `timer` and `timer_expires` field are used.
    Roughly speaking, wakeup event reporting consists of the following steps:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这是唤醒源的`timer`和`timer_expires`字段被使用的地方。粗略地说，唤醒事件报告包括以下步骤：
- en: It increments the wakeup source’s `event_count` counter and increments the wakeup
    source’s `wakeup_count`, which is the number of times the wakeup source might
    abort the suspend operation.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它增加了唤醒源的`event_count`计数器，并增加了唤醒源的`wakeup_count`，这是唤醒源可能中止挂起操作的次数。
- en: 'If the wakeup source is not yet active (the following are the steps performed
    on the activation path):'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果唤醒源尚未激活（以下是激活路径上执行的步骤）：
- en: – It marks the wakeup source as active and increments the wakeup source’s `active_count`
    element.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '- 它标记唤醒源为活动状态，并增加唤醒源的`active_count`元素。'
- en: – It updates the wakeup source’s `last_time` field to the current time.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '- 它将唤醒源的`last_time`字段更新为当前时间。'
- en: – It updates the wakeup source’s `start_prevent_time` field if the other field,
    `autosleep_enabled`, is `true`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果其他字段`autosleep_enabled`为`true`，则更新唤醒源的`start_prevent_time`字段。'
- en: 'Then, wakeup source deactivation consists of the following steps:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，唤醒源的停用包括以下步骤：
- en: It sets the wakeup source’s `active` field to `false`.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 它将唤醒源的`active`字段设置为`false`。'
- en: It updates the wakeup source’s `total_time` field by adding the time spent in
    the active state to its old value.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过将处于活动状态的时间添加到旧值中来更新唤醒源的`total_time`字段。
- en: It updates the wakeup source’s `max_time` field with the duration spent in the
    active state if this duration is greater than the value of the old `max_time`
    field.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 如果活动状态的持续时间大于旧的`max_time`字段的值，则使用活动状态的持续时间更新唤醒源的`max_time`字段。'
- en: It updates the wakeup source’s `last_time` field with the current time, deletes
    the wakeup source’s timer, and clears `timer_expires`.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用当前时间更新唤醒源的`last_time`字段，删除唤醒源的计时器，并清除`timer_expires`。
- en: It updates the wakeup source’s `prevent_sleep_time` field if the other field,
    `prevent_sleep_time`, is `true`.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 如果其他字段`prevent_sleep_time`为`true`，则更新唤醒源的`prevent_sleep_time`字段。'
- en: Deactivation may occur either immediately if `msec == 0`, or scheduled `msec`
    milliseconds later in the future if different to zero. All the this should remind
    you of `struct wakeup_source`, which we introduced earlier, most of whose elements
    are updated by this function call. The IRQ handler is a good place for invoking
    it because the interrupt triggering also marks the wakeup event. You should also
    note that each property of any wakeup source can be inspected from the sysfs interface,
    as we will see in the next section.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 停用可能会立即发生，如果`msec == 0`，或者如果不为零，则在将来的`msec`毫秒后进行计划。所有这些都应该提醒您`struct wakeup_source`，我们之前介绍过，其中大多数元素都是通过此函数调用更新的。
    IRQ处理程序是调用它的好地方，因为中断触发也标记了唤醒事件。您还应该注意，可以从sysfs接口检查任何唤醒源的每个属性，我们将在下一节中看到。
- en: Wakeup source and sysfs (or debugfs)
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 唤醒源和sysfs（或debugfs）
- en: 'There is something else that needs to be mentioned here, at least for debugging
    purposes. The whole list of wakeup sources in the system can be listed by printing
    the content of `/sys/kernel/debug/wakeup_sources` (assuming `debugfs` is mounted
    on the system):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些需要提及的东西，至少是为了调试目的。可以通过打印`/sys/kernel/debug/wakeup_sources`的内容列出系统中所有唤醒源的完整列表（假设`debugfs`已挂载在系统上）：
- en: '[PRE39]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This file also reports the statistics for each wakeup source, which may be
    gathered individually thanks to the device’s power-related sysfs attributes. Some
    of these sysfs file attributes are as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件还报告了每个唤醒源的统计信息，这些统计信息可以通过设备的与电源相关的sysfs属性单独收集。其中一些sysfs文件属性如下：
- en: '[PRE40]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'I used the `wake*` pattern in order to filter out runtime PM-related attributes,
    which are also in this same directory. Instead of describing what each attribute
    is, it would be more worthwhile indicating in which fields in the `struct wakeup_source`
    structure the preceding attributes are mapped:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用`wake*`模式来过滤与运行时PM相关的属性，这些属性也在同一个目录中。而不是描述每个属性是什么，更有价值的是指出在`struct wakeup_source`结构中的哪些字段中映射了前面的属性：
- en: '`wakeup` is an RW attribute and has already been described earlier. Its content
    determines the return value of the `device_may_wakeup()` helper. Only this attribute
    is both readable and writable. The others here are all read-only.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wakeup`是一个RW属性，之前已经描述过。它的内容决定了`device_may_wakeup()`助手的返回值。只有这个属性是可读和可写的。这里的其他属性都是只读的。'
- en: '`wakeup_abort_count` and `wakeup_count` are read-only attributes that point
    to the same field, that is, `wakeup->wakeup_count`.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wakeup_abort_count`和`wakeup_count`是只读属性，指向相同的字段，即`wakeup->wakeup_count`。'
- en: The `wakeup_expire_count` attribute is mapped to the `wakeup->expire_count`
    field.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wakeup_expire_count`属性映射到`wakeup->expire_count`字段。'
- en: '`wakeup_active` is read-only and mapped to the `wakeup->active` element.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wakeup_active`是只读的，并映射到`wakeup->active`元素。'
- en: '`wakeup_total_time_ms` is a read-only attribute that returns the `wakeup->total_time`
    value, and its unit is `ms`.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wakeup_total_time_ms`是一个只读属性，返回`wakeup->total_time`值，单位是`ms`。'
- en: '`wakeup_max_time_ms` returns the `power.wakeup->max_time` value in `ms`.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wakeup_max_time_ms`以`ms`返回`power.wakeup->max_time`值。'
- en: '`wakeup_last_time_ms`, a read-only attribute, corresponds to the `wakeup->last_time`
    value; the unit is `ms`.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wakeup_last_time_ms`是一个只读属性，对应于`wakeup->last_time`值；单位是`ms`。'
- en: '`wakeup_prevent_sleep_time_ms` is also read-only and is mapped onto the wakeup
    `->prevent_sleep_time` value, whose unit is `ms`.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wakeup_prevent_sleep_time_ms`也是只读的，并映射到wakeup `->prevent_sleep_time`值，其单位是`ms`。'
- en: Not all devices are wakeup capable, but those that are can roughly follow this
    guideline.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有设备都具有唤醒功能，但是那些具有唤醒功能的设备可以大致遵循这个指南。
- en: Now that we are done and familiar with wakeup source management from sysfs,
    we can introduce the special `IRQF_NO_SUSPEND` flag, which assists in helps in
    preventing an IRQ from being disabled in the system suspend path.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成并熟悉了来自sysfs的唤醒源管理，我们可以介绍特殊的`IRQF_NO_SUSPEND`标志，它有助于防止在系统挂起路径中禁用IRQ。
- en: The IRQF_NO_SUSPEND flag
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IRQF_NO_SUSPEND标志
- en: There are interrupts that need to be able to trigger even during the entire
    system suspend-resume cycle, including the `noirq` phases of suspending and resuming
    devices, as well as during the time when non-boot CPUs are taken offline and brought
    back online. This is the case for timer interrupts, for example. This flag has
    to be set on such interrupts. Although this flag helps to keep the interrupt enabled
    during the suspend phase, it does not guarantee that the IRQ will wake the system
    from a suspended state – for such cases, it is necessary to use `enable_irq_wake()`,
    which once again, is platform-specific. Thus, you should not confuse or mix the
    usage of the `IRQF_NO_SUSPEND` flag and `enable_irq_wake()`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些中断需要能够在整个系统挂起-恢复周期中触发，包括挂起和恢复设备的`noirq`阶段，以及在非引导CPU被下线和重新上线时。例如，定时器中断就是这种情况。必须在这些中断上设置此标志。尽管此标志有助于在挂起阶段保持中断启用，但并不保证IRQ将唤醒系统从挂起状态唤醒-对于这种情况，有必要使用`enable_irq_wake()`，再次强调，这是特定于平台的。因此，您不应混淆或混合使用`IRQF_NO_SUSPEND`标志和`enable_irq_wake()`。
- en: If an IRQ with this flag is shared by several users, every user will be affected,
    not just the one that has set the flag. In other words, every handler registered
    with the interrupt will be invoked as usual, even after `suspend_device_irqs()`.
    This is probably not what you need. For this reason, you should avoid mixing `IRQF_NO_SUSPEND`
    and `IRQF_SHARED` flags.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果带有此标志的IRQ被多个用户共享，那么每个用户都会受到影响，而不仅仅是设置了该标志的用户。换句话说，即使在`suspend_device_irqs()`之后，也会像往常一样调用注册到中断的每个处理程序。这可能不是您所需要的。因此，您应该避免混合使用`IRQF_NO_SUSPEND`和`IRQF_SHARED`标志。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned to manage the power consumption of the system,
    both from within the code in the driver as from the user space with the command
    line), either at runtime by acting on individual devices, or by acting on the
    whole system by playing with sleep states. We have also learned how other frameworks
    can help to reduce the power consumption of the system (such as CPUFreq, Thermal,
    and CPUIdle).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经学会了如何管理系统的功耗，无论是从驱动程序中的代码内部还是从用户空间的命令行中进行操作，可以在运行时通过对单个设备进行操作，或者通过调整睡眠状态来对整个系统进行操作。我们还学会了其他框架如何帮助减少系统的功耗（如CPUFreq、Thermal和CPUIdle）。
- en: In the next chapter, we will move onto PCI device drivers, which deal with the
    devices sitting on this famous bus that needs no introduction.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将转向处理PCI设备驱动程序，这些驱动程序处理着这个无需介绍的著名总线上的设备。
