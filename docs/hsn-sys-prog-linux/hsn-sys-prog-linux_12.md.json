["```\nstruct sigaction\n  {\n    /* Signal handler. */\n#ifdef __USE_POSIX199309\n    union\n      {\n        /* Used if SA_SIGINFO is not set. */\n __sighandler_t sa_handler;\n /* Used if SA_SIGINFO is set. */\n void (*sa_sigaction) (int, siginfo_t *, void *); \n      } \n    __sigaction_handler;\n# define sa_handler __sigaction_handler.sa_handler\n# define sa_sigaction __sigaction_handler.sa_sigaction\n#else\n    __sighandler_t sa_handler;\n#endif\n *--snip--* };\n```", "```\ntypedef struct {\n    int si_signo; /* Signal number. */\n    int si_code;  \n    int si_errno; /* If non-zero, an errno value associated with\n           this signal, as defined in <errno.h>. */\n\n    union\n    {\n         int _pad[__SI_PAD_SIZE];\n        /* kill(). */\n         struct\n         {\n             __pid_t si_pid; /* Sending process ID. */\n             __uid_t si_uid; /* Real user ID of sending process. */\n         } _kill;\n\n        /* POSIX.1b timers. */\n         struct\n         {\n             int si_tid; /* Timer ID. */\n             int si_overrun; /* Overrun count. */\n             __sigval_t si_sigval; /* Signal value. */\n         } _timer;\n\n        /* POSIX.1b signals. */\n         struct\n         {\n             __pid_t si_pid; /* Sending process ID. */\n             __uid_t si_uid; /* Real user ID of sending process. */\n             __sigval_t si_sigval; /* Signal value. */\n         } _rt;\n\n        /* SIGCHLD. */\n         struct\n         {\n             __pid_t si_pid; /* Which child. */\n             __uid_t si_uid; /* Real user ID of sending process. */\n             int si_status; /* Exit value or signal. */\n             __SI_CLOCK_T si_utime;\n             __SI_CLOCK_T si_stime;\n         } _sigchld;\n\n        /* SIGILL, SIGFPE, SIGSEGV, SIGBUS. */\n         struct\n         {\n           void *si_addr; /* Faulting insn/memory ref. */\n           __SI_SIGFAULT_ADDL\n           short int si_addr_lsb; /* Valid LSB of the reported address. */\n           union\n           {\n              /* used when si_code=SEGV_BNDERR */\n              struct\n              {\n                 void *_lower;\n                 void *_upper;\n              } _addr_bnd;\n              /* used when si_code=SEGV_PKUERR */\n              __uint32_t _pkey;\n           } _bounds;\n         } _sigfault;\n\n        /* SIGPOLL. */\n        struct\n        {\n             long int si_band; /* Band event for SIGPOLL. */\n             int si_fd;\n         } _sigpoll;\n\n        /* SIGSYS. */\n#if __SI_HAVE_SIGSYS\n         struct\n         {\n             void *_call_addr; /* Calling user insn. */\n             int _syscall; /* Triggering system call number. */\n             unsigned int _arch; /* AUDIT_ARCH_* of syscall. */\n         } _sigsys;\n#endif\n    } _sifields;\n} siginfo_t ;\n```", "```\n /* SIGCHLD. */\n struct\n {\n     __pid_t si_pid; /* Which child. */\n     __uid_t si_uid; /* Real user ID of sending process. */\n     int si_status; /* Exit value or signal. */\n     __SI_CLOCK_T si_utime;\n     __SI_CLOCK_T si_stime;\n } _sigchld;\n```", "```\n...\nThe following values can be placed in si_code for a SIGSEGV signal:\n\nSEGV_MAPERR\n    Address not mapped to object.\nSEGV_ACCERR\n    Invalid permissions for mapped object.\nSEGV_BNDERR (since Linux 3.19)\n    Failed address bound checks.\nSEGV_PKUERR (since Linux 4.6)\n    Access was denied by memory protection keys. See pkeys(7). The  \n    protection key which applied to this access is available via si_pkey.\n...\n```", "```\n$ ./handle_segv \nUsage: ./handle_segv u|k r|w\nu => user mode\nk => kernel mode\n r => read attempt\n w => write attempt\n$ \n```", "```\ntypedef unsigned int u32;\ntypedef long unsigned int u64;\n\n#define ADDR_FMT \"%lx\"\n#if __x86_64__ /* 64-bit; __x86_64__ works for gcc */\n #define ADDR_TYPE u64\n static u64 invalid_uaddr = 0xdeadfaceL;\n static u64 invalid_kaddr = 0xffff0b9ffacedeadL;\n#else\n #define ADDR_TYPE u32\n static u32 invalid_uaddr = 0xfacedeadL;\n static u32 invalid_kaddr = 0xdeadfaceL;\n#endif\n```", "```\nint main(int argc, char **argv)\n{\n struct sigaction act;\n if (argc != 3) {\n     usage(argv[0]);\n     exit(1);\n }\n\n memset(&act, 0, sizeof(act));\n act.sa_sigaction = myfault;\n act.sa_flags = SA_RESTART | SA_SIGINFO;\n sigemptyset(&act.sa_mask);\n if (sigaction(SIGSEGV, &act, 0) == -1)\n     FATAL(\"sigaction SIGSEGV failed\\n\");\n\nif ((tolower(argv[1][0]) == 'u') && tolower(argv[2][0] == 'r')) {\n   ADDR_TYPE *uptr = (ADDR_TYPE *) invalid_uaddr;\n   printf(\"Attempting to read contents of arbitrary usermode va uptr = 0x\" \n             ADDR_FMT \":\\n\", (ADDR_TYPE) uptr);\n   printf(\"*uptr = 0x\" ADDR_FMT \"\\n\", *uptr); // just reading\n\n } else if ((tolower(argv[1][0]) == 'u') && tolower(argv[2][0] == 'w')) {\n    ADDR_TYPE *uptr = (ADDR_TYPE *) & main;\n    printf\n    (\"Attempting to write into arbitrary usermode va uptr (&main actually) = 0x\" ADDR_FMT \":\\n\", (ADDR_TYPE) uptr);\n    *uptr = 0x2A; // writing \n } else if ((tolower(argv[1][0]) == 'k') && tolower(argv[2][0] == 'r')) {\n    ADDR_TYPE *kptr = (ADDR_TYPE *) invalid_kaddr;\n    printf\n (\"Attempting to read contents of arbitrary kernel va kptr = 0x\" ADDR_FMT \":\\n\", (ADDR_TYPE) kptr);\n    printf(\"*kptr = 0x\" ADDR_FMT \"\\n\", *kptr); // just reading\n\n } else if ((tolower(argv[1][0]) == 'k') && tolower(argv[2][0] == 'w')) {\n    ADDR_TYPE *kptr = (ADDR_TYPE *) invalid_kaddr;\n    printf\n (\"Attempting to write into arbitrary kernel va kptr = 0x\" ADDR_FMT \":\\n\",\n      (ADDR_TYPE) kptr);\n    *kptr = 0x2A; // writing\n } else\n     usage(argv[0]);\n exit(0);\n}\n```", "```\nstatic void myfault(int signum, siginfo_t * si, void *ucontext)\n{\n  fprintf(stderr,\n    \"%s:\\n------------------- FATAL signal ---------------------------\\n\",\n    APPNAME);\n    fprintf(stderr,\" %s: received signal %d. errno=%d\\n\"\n \" Cause/Origin: (si_code=%d): \",\n         __func__, signum, si->si_errno, si->si_code);\n\n switch (si->si_code) {\n     /* Possible values si_code can have for SIGSEGV */\n case SEGV_MAPERR:\n     fprintf(stderr,\"SEGV_MAPERR: address not mapped to object\\n\");\n     break;\n case SEGV_ACCERR:\n     fprintf(stderr,\"SEGV_ACCERR: invalid permissions for mapped object\\n\");\n     break;\n /* SEGV_BNDERR and SEGV_PKUERR result in compile failure? */\n\n /* Other possibilities for si_code; here just to show them... */\n case SI_USER:\n     fprintf(stderr,\"user\\n\");\n     break;\n case SI_KERNEL:\n     fprintf(stderr,\"kernel\\n\");\n     break;\n *--snip--*\n\n default:\n     fprintf(stderr,\"-none-\\n\");\n }\n<...>\n\n    /* \n     * Placeholders for real-world apps:\n     * crashed_write_to_log();\n     * crashed_perform_cleanup();\n     * crashed_inform_enduser();\n     *\n     * Now have the kernel generate the core dump by:\n     *  Reset the SIGSEGV to (kernel) default, and,\n     *  Re-raise it!\n     */\n    signal(SIGSEGV, SIG_DFL);\n    raise(SIGSEGV);\n}\n```", "```\nfprintf(stderr,\" Faulting instr or address = 0x\" ADDR_FMT \"\\n\",\n         (ADDR_TYPE) si->si_addr);\nfprintf(stderr, \"--- Register Dump [x86_64] ---\\n\");\ndump_regs(ucontext); fprintf(stderr,\n     \"------------------------------------------------------------\\n\");\npsiginfo(si, \"psiginfo helper\");\nfprintf(stderr,\n     \"------------------------------------------------------------\\n\");\n```", "```\n/* \n * Placeholders for real-world apps:\n * crashed_write_to_log();\n * crashed_perform_cleanup();\n * crashed_inform_enduser();\n */\n```", "```\n[...]\n * Now have the kernel generate the core dump by:\n * Reset the SIGSEGV to glibc default, and,\n * Re-raise it!\n */\n signal(SIGSEGV, SIG_DFL);\n raise(SIGSEGV);\n```", "```\n/* arch - x86[_64] - specific! */\nstatic inline void dump_regs(void *ucontext)\n{\n#define FMT \"%016llx\"\nucontext_t *uctx = (ucontext_t *)ucontext;\n\n fprintf(stderr,\n \" RAX = 0x\" FMT \" RBX = 0x\" FMT \" RCX = 0x\" FMT \"\\n\"\n \" RDX = 0x\" FMT \" RSI = 0x\" FMT \" RDI = 0x\" FMT \"\\n\"\n \" RBP = 0x\" FMT \" R8 = 0x\" FMT  \" R9  = 0x\" FMT \"\\n\"\n\n \" R10 = 0x\" FMT \" R11 = 0x\" FMT \" R12 = 0x\" FMT \"\\n\"\n \" R13 = 0x\" FMT \" R14 = 0x\" FMT \" R15 = 0x\" FMT \"\\n\"\n \" RSP = 0x\" FMT \"\\n\"\n\n \"\\n RIP = 0x\" FMT \" EFLAGS = 0x\" FMT \"\\n\"\n \" TRAP# = %02lld ERROR = %02lld\\n\"\n /* CR[0,1,3,4] unavailable */\n \" CR2 = 0x\" FMT \"\\n\"\n , uctx->uc_mcontext.gregs[REG_RAX]\n , uctx->uc_mcontext.gregs[REG_RBX]\n , uctx->uc_mcontext.gregs[REG_RCX]\n , uctx->uc_mcontext.gregs[REG_RDX]\n , uctx->uc_mcontext.gregs[REG_RSI]\n , uctx->uc_mcontext.gregs[REG_RDI]\n , uctx->uc_mcontext.gregs[REG_RBP]\n , uctx->uc_mcontext.gregs[REG_R8]\n , uctx->uc_mcontext.gregs[REG_R9]\n , uctx->uc_mcontext.gregs[REG_R10]\n , uctx->uc_mcontext.gregs[REG_R11]\n , uctx->uc_mcontext.gregs[REG_R12]\n , uctx->uc_mcontext.gregs[REG_R13]\n , uctx->uc_mcontext.gregs[REG_R14]\n , uctx->uc_mcontext.gregs[REG_R15]\n , uctx->uc_mcontext.gregs[REG_RSP]\n , uctx->uc_mcontext.gregs[REG_RIP]\n , uctx->uc_mcontext.gregs[REG_EFL]\n , uctx->uc_mcontext.gregs[REG_TRAPNO]\n , uctx->uc_mcontext.gregs[REG_ERR]\n , uctx->uc_mcontext.gregs[REG_CR2]\n );\n}\n```", "```\n*Test Case: Userspace, Invalid Read*\n$ ./handle_segv u r\nAttempting to read contents of arbitrary usermode va uptr = 0xdeadface:\nhandle_segv:\n------------------- FATAL signal ---------------------------\n myfault: received signal 11. errno=0\n Cause/Origin: (si_code=1): SEGV_MAPERR: address not mapped to object\n Faulting instr or address = 0xdeadface\n --- Register Dump [x86_64] ---\nRAX = 0x00000000deadface RBX = 0x0000000000000000 RCX = 0x0000000000000000\nRDX = 0x0000000000000000 RSI = 0x0000000001e7b260 RDI = 0x0000000000000000\nRBP = 0x00007ffc8d842110 R8  = 0x0000000000000008 R9  = 0x0000000000000000\nR10 = 0x0000000000000000 R11 = 0x0000000000000246 R12 = 0x0000000000400850\nR13 = 0x00007ffc8d8421f0 R14 = 0x0000000000000000 R15 = 0x0000000000000000\nRSP = 0x00007ffc8d842040\nRIP = 0x0000000000400e84 EFLAGS = 0x0000000000010202\nTRAP# = 14 ERROR = 04\nCR2 = 0x00000000deadface\n------------------------------------------------------------\npsiginfo helper: Segmentation fault (Address not mapped to object [0xdeadface])\n------------------------------------------------------------\nSegmentation fault (core dumped)\n$\n```", "```\n$ ls -l corefile*\n-rw-------. 1 kai kai 389120 Jun 24 14:23 'corefile:host=<hostname>:gPID=2413:gTID=2413:ruid=1000:sig=11:exe=<!<path>!<to>!<executable>!ch13!handle_segv.2413'\n$\n```", "```\n*Test Case: Kernel-space, Invalid* ***Write*** $ ./handle_segv k w\nAttempting to write into arbitrary kernel va kptr = 0xffff0b9ffacedead:\nhandle_segv:\n------------------- FATAL signal ---------------------------\n myfault: received signal 11. errno=0\n Cause/Origin: (si_code=128): kernel\n Faulting instr or address = 0x0\n --- Register Dump [x86_64] ---\nRAX = 0xffff0b9ffacedead RBX = 0x0000000000000000 RCX = 0x0000000000000000\nRDX = 0x0000000000000000 RSI = 0x00000000023be260 RDI = 0x0000000000000000\nRBP = 0x00007ffcb5b5ff60 R8  = 0x0000000000000010 R9  = 0x0000000000000000\nR10 = 0x0000000000000000 R11 = 0x0000000000000246 R12 = 0x0000000000400850\nR13 = 0x00007ffcb5b60040 R14 = 0x0000000000000000 R15 = 0x0000000000000000\nRSP = 0x00007ffcb5b5fe90\n\nRIP = 0x0000000000400ffc EFLAGS = 0x0000000000010206\nTRAP# = 13 ERROR = 00\nCR2 = 0x0000000000000000\n------------------------------------------------------------\npsiginfo helper: Segmentation fault (Signal sent by the kernel [(nil)])\n------------------------------------------------------------\nSegmentation fault (core dumped)$\n```", "```\n$ gdb -q ./handle_segv_dbg\nReading symbols from ./handle_segv_dbg...done.\n(gdb) list *0x0000000000400ffc\n<< 0x0000000000400ffc is the RIP value >>\n0x400ffc is in main (handle_segv.c:212).\n207 } else if ((tolower(argv[1][0]) == 'k') && tolower(argv[2][0] == 'w')) {\n208 ADDR_TYPE *kptr = (ADDR_TYPE *) invalid_kaddr; // arbitrary kernel virtual addr\n209 printf\n210 (\"Attempting to write into arbitrary kernel va kptr = 0x\" ADDR_FMT \":\\n\",\n211 (ADDR_TYPE) kptr);\n212 *kptr = 0x2A; // writing\n213 } else\n214 usage(argv[0]);\n215 exit(0);\n216 }\n(gdb) \n```", "```\n(gdb) l *0x0000000000400ffc\n0x400ffc is in main (handle_segv.c:212).\n```", "```\n212: *kptr = 0x2A; // writing\n```", "```\n$ addr2line -e ./handle_segv_dbg 0x0000000000400ffc\n<...>/handle_segv.c:212\n$ \n```", "```\n<...>\ninclude <errno.h>\n<...>\n\nstatic void handle_sigusr(int signum)\n{\n    int myerrno = errno;\n    <... do the handling ...>\n    <... syscalls, etc ...>\n    errno = myerror;\n}\n```", "```\n#include <unistd.h>\nunsigned int sleep(unsigned int seconds);\n```", "```\n<...>\nfunc_a();\nsleep(10);\nfunc_b();\n<...>\n```", "```\n#include <time.h>\nint nanosleep(const struct timespec *req, struct timespec *rem);\n```", "```\nstruct timespec {\n    time_t tv_sec; /* seconds */\n    long tv_nsec;  /* nanoseconds */\n};\n```", "```\nstatic void sig_handler(int signum)\n{\n     fprintf(stderr, \"**Signal %d interruption!**\\n\", signum);\n}\n\nint main(int argc, char **argv)\n{\n     struct sigaction act;\n     int nsec = 10, ret;\n     struct timespec req, rem;\n\n    if (argc == 1) {\n         fprintf(stderr, \"Usage: %s option=[0|1]\\n\"\n            \"0 : uses the sleep(3) function\\n\"\n            \"1 : uses the nanosleep(2) syscall\\n\", argv[0]);\n         exit(EXIT_FAILURE);\n     }\n    /* setup signals: trap SIGINT and SIGQUIT */\n     memset(&act, 0, sizeof(act));\n     act.sa_handler = sig_handler;\n     sigemptyset(&act.sa_mask);\n     act.sa_flags = SA_RESTART;\n     if (sigaction(SIGINT, &act, 0) || sigaction(SIGQUIT, &act, 0))\n         FATAL(\"sigaction failure\\n\");\n\n    if (atoi(argv[1]) == 0) {         /* sleep */\n         printf(\"sleep for %d s now...\\n\", nsec);\n         ret = sleep(nsec);\n         printf(\"sleep returned %u\\n\", ret);\n     } else if (atoi(argv[1]) == 1) { /* nanosleep */\n         req.tv_sec = nsec;\n         req.tv_nsec = 0;\n         while ((nanosleep(&req, &rem) == -1) && (errno == EINTR)) {\n             printf(\"nanosleep interrupted: rem time: %07lu.%07lu\\n\",\n                 rem.tv_sec, rem.tv_nsec);\n             req = rem;\n         }\n     }\n exit(EXIT_SUCCESS);\n}\n```", "```\n$ ./sleeping_beauty\nUsage: ./sleeping_beauty option=[0|1]\n0 : uses the sleep(3) function\n1 : uses the nanosleep(2) syscall\n$ \n```", "```\n$ ./sleeping_beauty 0\nsleep for 10 s now...\n^C**Signal 2 interruption!**\nsleep returned 7\n$ \n```", "```\n$ ./sleeping_beauty 1\n^C**Signal 2 interruption!**\nnanosleep interrupted: rem time: 0000007.249192148\n^\\**Signal 3 interruption!**\nnanosleep interrupted: rem time: 0000006.301391001\n^C**Signal 2 interruption!**\nnanosleep interrupted: rem time: 0000004.993030983\n^\\**Signal 3 interruption!**\nnanosleep interrupted: rem time: 0000004.283608684\n^C**Signal 2 interruption!**\nnanosleep interrupted: rem time: 0000003.23244174\n^\\**Signal 3 interruption!**\nnanosleep interrupted: rem time: 0000001.525725162\n^C**Signal 2 interruption!**\nnanosleep interrupted: rem time: 0000000.906662154\n^\\**Signal 3 interruption!**\nnanosleep interrupted: rem time: 0000000.192637791\n$ \n```", "```\n$ kill -l |grep \"SIGRT\"\n31)SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3\n38)SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8\n43)SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13\n48)SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12\n53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7\n58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2\n63) SIGRTMAX-1  64) SIGRTMAX \n$ \n```", "```\n$ prlimit |grep SIGPENDING\nSIGPENDING max number of pending signals 63229     63229 signals\n$\n```", "```\n$ ./rtsigs_waiter\nTrapping the three realtime signals\nProcess awaiting signals ...\n```", "```\n$ ./bombard_sigrt.sh \nUsage: bombard_sigrt.sh PID-of-process num-RT-signals-batches-to-send\n (-1 to continously bombard the process with signals).\n$ $ ./bombard_sigrt.sh $(pgrep rtsigs_waiter) 3\nSending 3 instances each of RT signal batch\n {SIGRTMAX-5, SIGRTMAX, SIGRTMIN+5} to process 3642 ...\n i.e. signal #s {59, 64, 39}\nSIGRTMAX-5 SIGRTMAX SIGRTMIN+5 SIGRTMAX-5 SIGRTMAX SIGRTMIN+5 SIGRTMAX-5 SIGRTMAX SIGRTMIN+5 \n$ \n```", "```\nsighdlr: signal 59, s=1 ; total=1; stack 0x7ffd2f9c6100 :*\nsighdlr: signal 39, s=2 ; total=2; stack 0x7ffd2f9c6100 :*\nsighdlr: signal 39, s=3 ; total=3; stack 0x7ffd2f9c6100 :*\nsighdlr: signal 39, s=4 ; total=4; stack 0x7ffd2f9c6100 :*\nsighdlr: signal 59, s=5 ; total=5; stack 0x7ffd2f9c6100 :*\nsighdlr: signal 59, s=6 ; total=6; stack 0x7ffd2f9c6100 :*\nsighdlr: signal 64, s=7 ; total=7; stack 0x7ffd2f9c6100 :*\nsighdlr: signal 64, s=8 ; total=8; stack 0x7ffd2f9c6100 :*\nsighdlr: signal 64, s=9 ; total=9; stack 0x7ffd2f9c6100 :*\n```", "```\n#include <sys/types.h>\n#include <signal.h>\n\nint kill(pid_t pid, int sig);\n```", "```\ninclude <signal.h>\nint raise(int sig);\n```", "```\nfor i from 1 to PID_MAX\n    kill(i, SIGKILL)\n```", "```\nstatic int app_func_A(int work, pid_t target)\n{\n    [...]\n    if (kill(target, 0) < 0)\n        <handle it>\n        return -1;\n    *[...it's fine; do the work on 'target'...]*\n}\n```", "```\ntypedef struct {\n    int si_signo; /* Signal number. */\n    int si_code;  \n    int si_errno; /* If non-zero, an errno value associated with\n           this signal, as defined in <errno.h>. */\n    union\n    {\n         int _pad[__SI_PAD_SIZE];\n        /* kill(). */\n         struct\n         {\n             __pid_t si_pid; /* Sending process ID. */\n             __uid_t si_uid; /* Real user ID of sending process. */\n         } _kill;\n\n    [...]\n```", "```\n[...]\n /* POSIX.1b signals. */\n         struct\n         {\n             __pid_t si_pid; /* Sending process ID. */\n             __uid_t si_uid; /* Real user ID of sending process. */\n             __sigval_t si_sigval; /* Signal value. */\n         } _rt;\n[...]\n```", "```\nunion __sigval\n{\n    int __sival_int;\n    void *__sival_ptr;\n};\ntypedef union __sigval __sigval_t;\n```", "```\n#include <signal.h>\nint sigqueue(pid_t pid, int sig, const union sigval value);\n```", "```\n$ ./sigq_recv & [1] 13818\n./sigq_recv: Hey, consumer here [13818]! Awaiting data from producer\n(will poll every 3s ...)\n$ \n```", "```\n$ ./sigq_sender \nUsage: ./sigq_sender pid-to-send-to value-to-send[int]\n$ ./sigq_sender $(pgrep sigq_recv) 42\nProducer [13823]: sent signal 34 to PID 13818 with data item 42\n$nanosleep interrupted: rem time: 0000002.705461411\n```", "```\nConsumer [13818] received data @ Tue Jun 5 10:20:33 2018\n:\nsignal # : 34\nProducer: PID : 1000\n          UID : 1000           data item : 42\n```", "```\n#define SIG_COMM   SIGRTMIN\n#define SLP_SEC    3\n\n[...]\nstatic volatile sig_atomic_t data_recvd=0;\n[...]\nint main(int argc, char **argv)\n{\n struct sigaction act;\n\n act.sa_sigaction = read_msg;\n sigfillset(&act.sa_mask); /* disallow all while handling */\n act.sa_flags = SA_SIGINFO | SA_RESTART;\n if (sigaction(SIG_COMM, &act, 0) == -1)\n     FATAL(\"sigaction failure\");\n\n printf(\"%s: Hey, consumer here [%d]! Awaiting data from producer\\n\"\n         \"(will poll every %ds ...)\\n\",\n        argv[0], getpid(), SLP_SEC);\n\n/* Poll ... not the best way, but just for this demo... */\n while(1) {\n    r_sleep(SLP_SEC);\n    if (data_recvd) {\n        display_recv_data();\n data_recvd = 0;\n    }\n }\n exit(EXIT_SUCCESS);\n}\n```", "```\nstatic int send_peer(pid_t target, int sig, int val)\n{\n union sigval sv;\n\n if (kill(target, 0) < 0)\n     return -1;\n\n sv.sival_int = val;\n if (sigqueue(target, sig, sv) == -1)\n     return -2;\n return 0;\n}\n```", "```\n[...]\ntypedef struct {\n  time_t timestamp;\n  int signum;\n  pid_t sender_pid;\n  uid_t sender_uid;\n  int data;\n} rcv_data_t;\nstatic rcv_data_t recv_data;\n\n[...]\n\n/* \n * read_msg\n * Signal handler for SIG_COMM.\n * The signal's receipt implies a producer has sent us data;\n * read and place the details in the rcv_data_t structure.\n * For reentrant-safety, all signals are masked while this handler runs.\n */\nstatic void read_msg(int signum, siginfo_t *si, void *ctx)\n{\n time_t tm;\n\n if (time(&tm) < 0)\n     WARN(\"time(2) failed\\n\");\n\n recv_data.timestamp = tm;\n recv_data.signum = signum;\n recv_data.sender_pid = si->si_pid;\n recv_data.sender_uid = si->si_uid;\n recv_data.data = si->si_value.sival_int;\n\n data_recvd = 1;\n}\n```", "```\ninclude <unistd.h>\n int pause(void);\n```", "```\n(void)pause();\n```", "```\nwhile (1);\n```", "```\nwhile (1)\n    sleep(1);\n```", "```\nwhile (1)\n (void)pause();\n```", "```\ninclude <signal.h>\n int sigwait(const sigset_t *set, int *sig);\n```", "```\n$ ./sigwt \nUsage: ./sigwt 0|1\n 0 => block All signals and sigwait for them\n 1 => block all signals except the SIGFPE and SIGSEGV and sigwait\n (further, we setup an async handler for the SIGFPE, not the SIGSEGV)\n$ ./sigwt 0\n./sigwt: All signals blocked (and only SIGFPE caught w/ sigaction)\n[SigBlk: 1 2 3 4 5 6 7 8 10 11 12 13 14 15 16 17 18 20 21 22 23 24 25 26 27 28 29 30 31 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 ]\n./sigwt: waiting upon signals now ...\n```", "```\n$ ./bombard.sh $(pgrep sigwt) 1\nSending 1 instances each of ALL signals to process 2705\n1 2 3 4 5 6 7 8 10 11 12 13 14 15 16 17 18 20 21 22 23 24 25 26 27 28 29 30 31 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 \n$ \n```", "```\nReceived signal# 1\nReceived signal# 2\nReceived signal# 3\nReceived signal# 4\nReceived signal# 5\nReceived signal# 6\nReceived signal# 7\nReceived signal# 8\nReceived signal# 10\nReceived signal# 11\n[...]\nReceived signal# 17\nReceived signal# 18\nReceived signal# 20\nReceived signal# 21\n[...]\nReceived signal# 31\nReceived signal# 34\nReceived signal# 35\nReceived signal# 36\nReceived signal# 37\n[...]\nReceived signal# 64\n```", "```\npkill -SIGKILL sigwt \n```", "```\n$ ./sigwt \nUsage: ./sigwt 0|1\n 0 => block All signals and sigwait for them\n 1 => block all signals except the SIGFPE and SIGSEGV and sigwait\n (further, we setup an async handler for the SIGFPE, not the SIGSEGV) $ ./sigwt 1\n./sigwt: removing SIGFPE and SIGSEGV from the signal mask...\n./sigwt: all signals except SIGFPE and SIGSEGV blocked\n[SigBlk: 1 2 3 4 5 6 7 10 12 13 14 15 16 17 18 20 21 22 23 24 25 26 27 28 29 30 31 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 ]\n./sigwt: waiting upon signals now ...\n```", "```\n$ ./bombard.sh $(pgrep sigwt) 1\nSending 1 instances each of ALL signals to process 13759\n1 2 3 4 5 6 7 8 10 11 ./bombard.sh: line 16: kill: (13759) - No such process\nbombard.sh: \"kill -12 13759\" failed, loop count=1\n$ \n```", "```\nReceived signal# 1\nReceived signal# 2\nReceived signal# 3\nReceived signal# 4\nReceived signal# 5\nReceived signal# 6\nReceived signal# 7\n*** siggy: handled SIGFPE (8) ***\nReceived signal# 10\nSegmentation fault (core dumped)\n$ \n```", "```\n[...]\nif (atoi(argv[1]) == 1) {\n    /* IMP: unblocking signals here removes them from the influence of \n     * the sigwait* APIs; this is *required* for correctly handling\n     * fatal signals from the kernel.\n     */\n    printf(\"%s: removing SIGFPE and SIGSEGV from the signal mask...\\n\",         argv[0]);\n    sigdelset(&set, SIGFPE);\n#if 1\n sigdelset(&set, SIGSEGV);\n#endif\n[...] \n```", "```\n[...]\nReceived signal# 1\nReceived signal# 2\nReceived signal# 3\nReceived signal# 4\nReceived signal# 5\nReceived signal# 6\nReceived signal# 7\n*** siggy: handled SIGFPE (8) ***\nReceived signal# 10\nReceived signal# 11\nReceived signal# 12\n[...]\n```", "```\n#include <signal.h>\nint sigwaitinfo(const sigset_t *set, siginfo_t *info);\nint sigtimedwait(const sigset_t *set, siginfo_t *info,\n    const struct timespec *timeout);\n```", "```\nstruct timespec {\n    long tv_sec; /* seconds */\n    long tv_nsec; /* nanoseconds */\n}\n```", "```\n#include <sys/signalfd.h>\nint signalfd(int fd, const sigset_t *mask, int flags);\n```", "```\nssize_t read(int fd, void *buf, size_t count);\n```"]