- en: Linux System Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux系统架构
- en: This chapter informs the reader about the system architecture of the Linux ecosystem.
    It first conveys the elegant Unix philosophy and design fundamentals, then delves
    into the details of the Linux system architecture. The importance of the ABI,
    CPU privilege levels, and how modern **operating systems** (**OSes**) exploit
    them, along with the Linux system architecture's layering, and how Linux is a
    monolithic architecture, will be covered. The (simplified) flow of a system call
    API, as well as kernel-code execution contexts, are key points.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Linux生态系统的系统架构。首先介绍了优雅的Unix哲学和设计基础，然后深入探讨了Linux系统架构的细节。将涵盖ABI的重要性、CPU特权级别以及现代操作系统如何利用它们，以及Linux系统架构的分层和Linux是一个单体架构。还将介绍系统调用API的（简化的）流程以及内核代码执行上下文等关键点。
- en: 'In this chapter, the reader will be taken through the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，读者将学习以下主题：
- en: The Unix philosophy in a nutshell
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix哲学简介
- en: Architecture preliminaries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构初步
- en: Linux architecture layers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux架构层
- en: Linux—a monolithic OS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux——单体操作系统
- en: Kernel execution contexts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核执行上下文
- en: Along the way, we'll use simple examples to make the key philosophical and architectural
    points clear.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们将使用简单的例子来阐明关键的哲学和架构观点。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A modern desktop PC or laptop is required; Ubuntu Desktop specifies the following
    as recommended system requirements for installation and usage of the distribution:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一台现代台式电脑或笔记本电脑；Ubuntu桌面版指定以下为安装和使用该发行版的推荐系统要求：
- en: 2 GHz dual core processor or better
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2GHz双核处理器或更好
- en: RAM
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAM
- en: '**Running on a physical host**: 2 GB or more system memory'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在物理主机上运行**：2GB或更多系统内存'
- en: '**Running as a guest**: The host system should have at least 4 GB RAM (the
    more, the better and smoother the experience)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为客户操作系统运行**：主机系统应至少具有4GB RAM（内存越大，体验越好，更加流畅）'
- en: 25 GB of free hard drive space
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 25GB的可用硬盘空间
- en: Either a DVD drive or a USB port for the installer media
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装介质需要DVD驱动器或USB端口
- en: Internet access is definitely helpful
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网访问肯定是有帮助的
- en: 'We recommend the reader use one of the following Linux distributions (can be
    installed as a guest OSon a Windows or Linux host system, as mentioned):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议读者使用以下Linux发行版（可以安装为Windows或Linux主机系统的客户操作系统，如前所述）：
- en: Ubuntu 18.04 LTS Desktop (Ubuntu 16.04 LTS Desktop is a good choice too as it
    has long term support as well, and pretty much everything should work)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu 18.04 LTS桌面版（Ubuntu 16.04 LTS桌面版也是一个不错的选择，因为它也有长期支持，几乎所有功能都应该可以使用）
- en: Ubuntu Desktop download link: [https://www.ubuntu.com/download/desktop](https://www.ubuntu.com/download/desktop)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu桌面版下载链接：[https://www.ubuntu.com/download/desktop](https://www.ubuntu.com/download/desktop)
- en: Fedora 27 (Workstation)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fedora 27（工作站）
- en: Download link: [https://getfedora.org/en_GB/workstation/download/](https://getfedora.org/en_GB/workstation/download/)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载链接：[https://getfedora.org/en_GB/workstation/download/](https://getfedora.org/en_GB/workstation/download/)
- en: Note that these distributions are, in their default form, OSS and non-proprietary,
    and free to use as an end user.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些发行版在默认情况下是开源软件和非专有软件，可以免费使用。
- en: There are instances where the entire code snippet isn't included in the book
    . Thus the GitHub URL to refer the codes: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有时书中并未包含完整的代码片段。因此，GitHub链接可用于参考代码：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: Also, for the *Further reading* section, refer to the preceding GitHub link.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在*进一步阅读*部分，请参考上述GitHub链接。
- en: Linux and the Unix operating system
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux和Unix操作系统
- en: Moore's law famously states that the number of transistors in an IC will double
    (approximately) every two years (with an addendum that the cost would halve at
    pretty much the same rate). This law, which remained quite accurate for many years,
    is one of the things that clearly underscored what people came to realize, and
    even celebrate, about the electronics and the **Information Technology** (**IT**)
    industry; the sheer speed with which innovation and paradigm shifts in technology
    occur here is unparalleled. So much so that we now hardly raise an eyebrow when,
    every year, even every few months in some cases, new innovations and technology
    appear, challenge, and ultimately discard the old with little ceremony.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 摩尔定律著名地指出，集成电路中的晶体管数量将每两年（大约）翻一番（并附带成本将以几乎相同的速度减半）。这个定律在很多年内保持相当准确，这是清楚地表明了人们对电子和信息技术行业的创新和技术范式转变的速度的认识和庆祝；这里创新和技术范式转变的速度是无与伦比的。以至于现在，每年，甚至在某些情况下每几个月，新的创新和技术出现，挑战并最终淘汰旧的技术，几乎没有仪式感。
- en: 'Against this backdrop of rapid all-consuming change, there lives an engaging
    anomaly: an OS whose essential design, philosophy, and architecture have changed
    hardly at all in close to five decades. Yes, we are referring to the venerable
    Unix operating system.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个快速变化的背景下，有一个引人入胜的反常现象：一个操作系统的基本设计、哲学和架构在近五十年来几乎没有发生任何变化。是的，我们指的是古老的Unix操作系统。
- en: Organically emerging from a doomed project at AT&T's Bell Labs (Multics) in
    around 1969, Unix took the world by storm. Well, for a while at least.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Unix起源于AT&T贝尔实验室的一个注定失败的项目（Multics），大约在1969年。Unix曾一度风靡全球。至少在一段时间内是如此。
- en: But, you say, this is a book about Linux; why all this information about Unix?
    Simply because, at heart, Linux is the latest avatar of the venerable Unix OS.
    Linux is a Unix-like operating system (among several others). The code, by legal
    necessity, is unique; however, the design, philosophy, and architecture of Linux
    are pretty much identical to those of Unix.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你可能会说，这是一本关于Linux的书；为什么要提供这么多关于Unix的信息？简单地说，因为在本质上，Linux是古老Unix操作系统的最新化身。Linux是一种类Unix操作系统（还有其他几种）。出于法律需要，代码是独特的；然而，Linux的设计、哲学和架构与Unix的几乎完全相同。
- en: The Unix philosophy in a nutshell
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix哲学简介
- en: To understand anyone (or anything), one must strive to first understand their
    (or its) underlying philosophy; to begin to understand Linux is to begin to understand
    the Unix philosophy. Here, we shall not attempt to delve into every minute detail;
    rather, an overall understanding of the essentials of the Unix philosophy is our
    goal.  Also, when we use the term Unix, we very much also mean Linux!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解任何人（或任何事物），必须努力首先理解他们（或它的）基本哲学；要开始理解Linux就是开始理解Unix哲学。在这里，我们不打算深入到每一个细节；相反，我们的目标是对Unix哲学的基本要点有一个整体的理解。此外，当我们使用术语Unix时，我们也非常指的是Linux！
- en: 'The way that software (particularly, tools) is designed, built, and maintained
    on Unix slowly evolved into what might even be called a pattern that stuck: the
    Unix design philosophy. At its heart, here are the pillars of the Unix philosophy,
    design, and architecture:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 软件（特别是工具）在Unix上的设计、构建和维护方式慢慢演变成了一种被称为Unix设计哲学的模式。在其核心，这里是Unix哲学、设计和架构的支柱：
- en: Everything is a process; if it's not a process, it's a file
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一切都是一个进程；如果不是进程，就是一个文件
- en: One tool to do one task
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工具做一件事
- en: Three standard I/O channel
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个标准I/O通道
- en: Combine tools seamlessly
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无缝地组合工具
- en: Plain text preferred
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首选纯文本
- en: CLI, not GUI
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行界面，而不是图形界面
- en: Modular, designed to be repurposed by others
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化，设计为供他人重新利用
- en: Provide the mechanism, not the policy
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供机制，而不是策略
- en: Let's examine these pillars a little more closely, shall we?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地检查这些支柱，好吗？
- en: Everything is a process – if it's not a process, it's a file
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切都是一个进程 - 如果不是进程，就是一个文件
- en: A process is an instance of a program in execution. A file is an object on the
    filesystem; beside regular file with plain text or binary content; it could also
    be a directory, a symbolic link, a device-special file, a named pipe, or a (Unix-domain)
    socket.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是正在执行的程序的一个实例。文件是文件系统上的一个对象；除了具有纯文本或二进制内容的常规文件之外；它还可以是一个目录、一个符号链接、一个设备特殊文件、一个命名管道或者一个（Unix域）套接字。
- en: The Unix design philosophy abstracts peripheral devices (such as the keyboard,
    monitor, mouse, a sensor, and touchscreen) as files – what it calls device files.
    By doing this, Unix allows the application programmer to conveniently ignore the
    details and just treat (peripheral) devices as though they are ordinary disk files.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Unix设计哲学将外围设备（如键盘、显示器、鼠标、传感器和触摸屏）抽象为文件 - 它称之为设备文件。通过这样做，Unix允许应用程序员方便地忽略细节，只是将（外围）设备视为普通的磁盘文件。
- en: The kernel provides a layer to handle this very abstraction – it's called the
    **Virtual Filesystem Switch** (**VFS**). So, with this in place, the application
    developer can open a device file and perform I/O (reads and writes) upon it, all
    using the usual API interfaces provided (relax, these APIs will be covered in
    a subsequent chapter).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 内核提供了一个处理这种抽象的层 - 它被称为**虚拟文件系统开关**（**VFS**）。因此，有了这个层，应用程序开发人员可以打开设备文件并对其进行I/O（读取和写入），所有这些都使用提供的通常API接口（放心，这些API将在后续章节中介绍）。
- en: 'In fact, every process inherits three files on creation:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每个进程在创建时都会继承三个文件：
- en: '**Standard input** (`stdin`**: fd** **0**): The keyboard device, by default'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准输入**（`stdin`**：fd** **0**）：默认情况下是键盘设备'
- en: '**Standard output** (`stdout`**: fd 1***)*: The monitor (or terminal) device,
    by default'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准输出**（`stdout`**：fd 1**）：默认情况下是监视器（或终端）设备'
- en: '**Standard error** (`stderr`**: ****fd 2**): The monitor (or terminal) device,
    by default'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准错误**（`stderr`**：fd 2**）：默认情况下是监视器（或终端）设备'
- en: '**fd** is the common abbreviation, especially in code, for **file descriptor**;
    it''s an integer value that refers to the open file in question.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**fd**是**文件描述符**的常见缩写，特别是在代码中；它是一个指向所讨论的打开文件的整数值。'
- en: 'Also, note that we mention it''s a certain device by default – this implies
    the defaults can be changed. Indeed, this is a key part of the design: changing
    standard input, output, or error channels is called **redirection**, and by using
    the familiar <, > and 2> shell operators, these file channels are redirected to
    other files or devices.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，注意我们提到默认情况下是某个设备 - 这意味着默认值可以被更改。事实上，这是设计的一个关键部分：改变标准输入、输出或错误通道被称为**重定向**，通过使用熟悉的<、>和2>
    shell操作符，这些文件通道被重定向到其他文件或设备。
- en: On Unix, there exists a class of programs called filters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix上，存在一类被称为过滤器的程序。
- en: A filter is a program that reads from its standard input, possibly modifies
    the input, and writes the filtered result to its standard output.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器是一个从其标准输入读取的程序，可能修改输入，并将过滤后的结果写入其标准输出。
- en: Filters on Unix are very common utilities, such as `cat`, `wc`, `sort`, `grep`,
    `perl`, `head`, and `tail`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Unix上的过滤器是非常常见的实用工具，比如`cat`、`wc`、`sort`、`grep`、`perl`、`head`和`tail`。
- en: Filters allow Unix to easily sidestep design and code complexity. How?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器允许Unix轻松地规避设计和代码复杂性。如何做到的？
- en: 'Let''s take the `sort` filter as a quick example. Okay, we''ll need some data
    to sort. Let''s say we run the following commands:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`sort`过滤器作为一个快速的例子。好的，我们需要一些数据来排序。假设我们运行以下命令：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now we consider four scenarios of using `sort`; based on the parameter(s) we
    pass, we are actually performing explicit or implicit input-, output-, and/or
    error-redirection!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们考虑使用`sort`的四种情况；根据我们传递的参数，我们实际上正在执行显式或隐式的输入、输出和/或错误重定向！
- en: '**Scenario 1**: Sort a file alphabetically (one parameter, input implicitly
    redirected to file):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景1**：对文件进行字母排序（一个参数，输入隐式重定向到文件）：'
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All right!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！
- en: Hang on a second, though. If `sort` is a filter (and it is), it should read
    from its `stdin` (the keyboard) and write to its `stdout` (the terminal). It is
    indeed writing to the terminal device, but it's reading from a file, `fruit.txt`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，等一下。如果`sort`是一个过滤器（它是），它应该从其`stdin`（键盘）读取，并将其写入`stdout`（终端）。它确实是写入终端设备，但它是从一个文件`fruit.txt`中读取的。
- en: This is deliberate; if a parameter is provided, the sort program treats it as
    standard input, as clearly seen.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是故意的；如果提供了参数，sort程序会将其视为标准输入，这一点显而易见。
- en: Also, note that `sort fruit.txt ` is identical to `sort < fruit.txt`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，注意`sort fruit.txt`和`sort < fruit.txt`是相同的。
- en: '**Scenario 2**: Sort any given input alphabetically (no parameters, input and
    output from and to stdin/stdout):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**情景2**：按字母顺序对任何给定的输入进行排序（无参数，输入和输出从stdin/stdout进行）：'
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once you type `sort` and press the *Enter* key, and the sort process comes alive
    and just waits. Why? It's waiting for you, the user, to type something. Why? Recall,
    every process by default reads its input from standard input or stdin – the keyboard
    device!  So, we type in some fruit names. When we're done, press *Ctrl* + *D*.
    This is the default character sequence that signifies **end-of-file** (**EOF**),
    or in cases such as this, end-of-input. Voila! The input is sorted and written.
    To where? To the `sort` process's stdout – the terminal device, hence we see it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦输入`sort`并按下*Enter*键，排序过程就开始运行并等待。为什么？它在等待你，用户，输入。为什么？回想一下，默认情况下，每个进程都从标准输入或stdin
    - 键盘设备读取输入！所以，我们输入一些水果名称。当我们完成时，按下*Ctrl* + *D*。这是表示**文件结束**（**EOF**）的默认字符序列，或者在这种情况下，表示输入结束。哇！输入已经排序并写入。写到哪里？写到`sort`进程的stdout
    - 终端设备，因此我们可以看到它。
- en: '**Scenario 3**: Sort any given input alphabetically and save the output to
    a file (explicit output redirection):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**情景3**：按字母顺序对任何给定的输入进行排序，并将输出保存到文件中（显式输出重定向）：'
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Similar to Scenario 2, we type in some fruit names and then *Ctrl* + *D* to
    tell sort we're done. This time, though, note that the output is redirected (via
    the `>` meta-character) to the `sorted.fruits.txt` file!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与情景2类似，我们输入一些水果名称，然后按*Ctrl* + *D*告诉sort我们已经完成了。不过这次要注意的是，输出是通过`>`元字符重定向到`sorted.fruits.txt`文件！
- en: 'So, as expected is the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，预期的输出如下：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Scenario 4**: Sort a file alphabetically and save the output and errors to
    a file (explicit input-, output-, and error-redirection):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**情景4**：按字母顺序对文件进行排序，并将输出和错误保存到文件中（显式输入、输出和错误重定向）：'
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Interestingly, the end result is the same as in the preceding scenario, with
    the added advantage of redirecting any error output to the error channel. Here,
    we redirect the error output (recall that file descriptor 2 always refers to `stderr`)
    to the `/dev/null` special device file; `/dev/null` is a device file whose job
    is to act as a sink (a black hole). Anything written to the null device just disappears
    forever! (Who said there isn't magic on Unix?)  Also, its complement is `/dev/zero`*; *the
    zero device is a source – an infinite source of zeros. Reading from it returns
    zeroes (the first ASCII character, not numeric 0); it has no end-of-file!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，最终结果与前一个情景中的结果相同，还有一个额外的优势，即将任何错误输出重定向到错误通道。在这里，我们将错误输出重定向（回想一下，文件描述符2总是指向`stderr`）到`/dev/null`特殊设备文件；`/dev/null`是一个设备文件，其作用是充当一个接收器（一个黑洞）。写入空设备的任何内容都将永远消失！（谁说Unix上没有魔法？）此外，它的补充是`/dev/zero`*；*零设备是一个源
    - 一个无限的零源。从中读取将返回零（第一个ASCII字符，而不是数字0）；它没有文件结束！
- en: One tool to do one task
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个工具做一件事
- en: In the Unix design, one tries to avoid creating a Swiss Army knife; instead,
    one creates a tool for a very specific, designated purpose and for that one purpose
    only. No ifs, no buts; no cruft, no clutter. This is design simplicity at its
    best.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix设计中，人们试图避免创建一把瑞士军刀；相反，人们为一个非常具体的指定目的创建一个工具，只为这一个目的。没有如果，没有但是；没有杂物，没有混乱。这就是设计的简单性。
- en: '"Simplicity is the ultimate sophistication."'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: “简单是终极的复杂。”
- en: '- Leonardo da Vinci'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '- 列奥纳多·达·芬奇'
- en: 'Take a common example: when working on the Linux **CLI** (**command-line interface**),
    you would like to figure out which of your locally mounted filesystems has the
    most available (disk) space.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 举个常见的例子：在Linux **CLI**（命令行界面）上工作时，您可能想知道您本地挂载的文件系统中哪个有最多的可用（磁盘）空间。
- en: 'We can get the list of locally mounted filesystems by an appropriate switch
    (just `df` would do as well):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过适当的开关获取本地挂载的文件系统的列表（只需`df`也可以）：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To sort the output, one would need to first save it to a file; one could use
    a temporary file for this purpose, tmp, and then sort it, using the `sort` utility,
    of course. Finally, we delete the offending temporary file. (Yes, there's a better
    way, piping; refer to the, *Combine tools seamlessly *section)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要对输出进行排序，首先需要将其保存到一个文件中；可以使用临时文件进行此操作，tmp，然后使用`sort`实用程序进行排序。最后，我们删除这个临时文件。（是的，有一个更好的方法，管道；请参考*无缝组合工具*部分）
- en: 'Note that the available space is the fourth column, so we sort accordingly:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，可用空间是第四列，因此我们相应地进行排序：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Whoops! The output includes the heading line. Let''s first use the versatile
    `sed` utility – a powerful non-interactive editor tool – to eliminate the first
    line, the header, from the output of `df`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！输出包括标题行。让我们首先使用多功能的`sed`实用程序 - 一个强大的非交互式编辑工具 - 从`df`的输出中消除第一行，即标题行：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So what? The point is, on Unix, there is no one utility to list mounted filesystems
    and sort them by available space simultaneously.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那又怎样？关键是，在Unix上，没有一个实用程序可以同时列出挂载的文件系统并按可用空间进行排序。
- en: 'Instead, there is a utility to list mounted filesystems: `df`. It does a great
    job of it, with option switches to choose from. (How does one know which options?
    Learn to use the man pages, they''re extremely useful.)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，有一个用于列出挂载的文件系统的实用程序：`df`。它做得很好，有选择的选项开关。（如何知道哪些选项？学会使用man页面，它们非常有用。）
- en: 'There is a utility to sort text: `sort`. Again, it''s the last word in sorting
    text, with plenty of option switches to choose from for pretty much every conceivable
    sort one might require.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个用于对文本进行排序的实用程序：`sort`。同样，它是对文本进行排序的最后一个单词，有很多选项开关可供选择，几乎可以满足每一个可能需要的排序。
- en: 'The Linux man pages: **man** is short for **manual**; on a Terminal window,
    type `man man` to get help on using man. Notice the manual is divided into 9 sections.
    For example, to get the manual page on the stat system call, type `man 2 stat`
    as all system calls are in section 2 of the manual. The convention used is cmd
    or API; thus, we refer to it as `stat(2)`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Linux man页面：**man**是**manual**的缩写；在终端窗口上，输入`man man`以获取有关使用man的帮助。请注意，手册分为9个部分。例如，要获取有关stat系统调用的手册页，请输入`man
    2 stat`，因为所有系统调用都在手册的第2部分。使用的约定是cmd或API；因此，我们称之为`stat(2)`。
- en: 'As expected, we obtain the results. So what exactly is the point? It''s this:
    we used three utilities*,* not one. `df `, to list the mounted filesystems (and
    their related metadata), `sed`, to eliminate the header line, and `sort`, to sort
    whatever input its given (in any conceivable manner).'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们获得了结果。那么到底是什么意思呢？就是这个：我们使用了三个实用程序*，*而不是一个。`df`，用于列出已挂载的文件系统（及其相关的元数据），`sed`，用于消除标题行，以及`sort`，以任何可想象的方式对其给定的输入进行排序。
- en: '`df` can query and list mounted filesystems, but it cannot sort them. `sort`
    can sort text; it cannot list mounted filesystems.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`df`可以查询和列出已挂载的文件系统，但它不能对它们进行排序。`sort`可以对文本进行排序；它不能列出已挂载的文件系统。'
- en: Think about that for a moment.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想这一刻。
- en: Combine them all, and you get more than the sum of its parts! Unix tools typically
    do one task and they do it to its logical conclusion; no one does it better!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们组合起来，你会得到比其各部分更多的东西！ Unix工具通常只做一项任务，并且他们会把它做到逻辑上的结论；没有人做得比他们更好！
- en: Having said this, I would like to point out – a tiny bit sheepishly – the highly
    renowned tool Busybox. Busybox (`http://busybox.net`) is billed as The Swiss Army
    Knife of Embedded Linux. It is indeed a very versatile tool; it has its place
    in the embedded Linux ecosystem – precisely because it would be too expensive
    on an embedded box to have separate binary executables for each and every utility
    (and it would consume more RAM). Busybox solves this problem by having a single
    binary executable (along with symbolic links to it from each of its applets, such
    as ls, ps, df, and sort).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这一点，我想有点羞怯地指出，备受推崇的工具Busybox。 Busybox（`http://busybox.net`）被宣传为嵌入式Linux的瑞士军刀。它确实是一个非常多才多艺的工具；它在嵌入式Linux生态系统中有其位置
    - 正是因为在嵌入式盒子上为每个实用程序都有单独的二进制可执行文件太昂贵（而且会消耗更多的RAM）。 Busybox通过具有单个二进制可执行文件（以及从其每个applet（如ls、ps、df和sort）到它的符号链接）来解决这个问题。
- en: So, nevertheless, besides the embedded scenario and all the resource limitations
    it implies, do follow the *One tool to do one task* rule!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了嵌入式场景和它所暗示的所有资源限制之外，确实要遵循*一个工具只做一项任务*的规则！
- en: Three standard I/O channels
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三个标准I/O通道
- en: Several popular Unix tools (technically, filters) are, again, deliberately designed
    to read their input from a standard file descriptor called **standard input** (**stdin**)
    – possibly modify it, and write their resultant output to a standard file descriptor **standard
    output** (**stdout**). Any error output can be written to a separate error channel
    called **standard error** (**stderr**).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，一些流行的Unix工具（技术上称为过滤器）是故意设计为从称为**标准输入**（**stdin**）的标准文件描述符读取它们的输入 - 可能修改它，并将它们的结果输出写入称为**标准输出**（**stdout**）的标准文件描述符。任何错误输出都可以写入一个名为**标准错误**（**stderr**）的单独错误通道。
- en: In conjunction with the shell's redirection operators (`>` for output-redirection
    and `<` for input-redirection, `2>` for stderr redirection), and even more importantly
    with piping (refer section, *Combine tools seamlessly*), this enables a program
    designer to highly simplify. There's no need to hardcode (or even softcode, for
    that matter) input and output sources or sinks. It just works, as expected.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与shell的重定向操作符（`>`用于输出重定向和`<`用于输入重定向，`2>`用于stderr重定向）以及更重要的是管道（参见章节，*无缝组合工具*），这使得程序设计师能够高度简化。不需要硬编码（或者甚至软编码，无论如何）输入和输出源或接收器。它就像预期的那样工作。
- en: Let's review a couple of quick examples to illustrate this important point.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些快速示例，以说明这一重要观点。
- en: Word count
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字数统计
- en: 'How many lines of source code are there in the C `netcat.c` source file I downloaded?
    (Here, we use a small part of the popular open source `netcat` utility code base.) We
    use the `wc` utility. Before we go further, what''s wc? **word count** (**wc**)
    is a filter: it reads input from stdin, counts the number of lines, words, and
    characters in the input stream, and writes this result to its stdout. Further,
    as a convenience, one can pass filenames as parameters to it; passing the `-l`
    option switch has wc only print the number of lines:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我下载的C `netcat.c`源文件中有多少行源代码？（在这里，我们使用了流行的开源`netcat`实用程序代码库的一小部分。）我们使用`wc`实用程序。在我们进一步之前，`wc`是什么？**word
    count**（**wc**）是一个过滤器：它从stdin读取输入，计算输入流中的行数、单词数和字符数，并将结果写入其stdout。此外，作为一种便利，可以将文件名作为参数传递给它；传递`-l`选项开关使wc只打印行数：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, the input is a filename passed as a parameter to `wc`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，输入是作为参数传递给`wc`的文件名。
- en: 'Interestingly, we should by now realize that if we do not pass it any parameters,
    `wc` would read its input from stdin, which by default is the keyboard device.
    For example is shown as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们现在应该意识到，如果我们不向它传递任何参数，`wc`将从stdin读取其输入，默认情况下是键盘设备。例如如下所示：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Yes, we typed in `4` lines to stdin; thus the result is 4, written to stdout
    – the terminal device by default.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们在stdin中输入了`4`行；因此结果是4，写入stdout - 默认情况下是终端设备。
- en: 'Here is the beauty of it:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的美丽之处：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see, wc is a great example of a Unix filter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，wc是Unix过滤器的一个很好的例子。
- en: cat
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 猫
- en: Unix, and of course Linux, users learn to quickly get familiar with the daily-use `cat`
    utility. At first glance, all cat does is spit out the contents of a file to the
    terminal.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Unix，当然还有Linux，用户学会快速熟悉日常使用的`cat`实用程序。乍一看，cat所做的就是将文件的内容输出到终端。
- en: 'For example, say we have two plain text files, `myfile1.txt` and `myfile2.txt`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有两个纯文本文件，`myfile1.txt`和`myfile2.txt`：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Okay. Now check this out:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在看看这个：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Instead of needing to run `cat` twice, we ran it just once, by passing the two
    filenames to it as parameters.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要运行`cat`一次，通过将两个文件名作为参数传递给它。
- en: 'In theory, one can pass any number of parameters to cat: it will use them all,
    one by one!'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，可以向cat传递任意数量的参数：它将一个接一个地使用它们！
- en: 'Not just that, one can use shell wildcards too (`*` and `?`; in reality, the
    shell will first expand the wildcards, and pass on the resultant path names to
    the program being invoked as parameters):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，还可以使用shell通配符（`*`和`?`；实际上，shell将首先扩展通配符，并将结果路径名作为参数传递给被调用的程序）：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This, in fact, illustrates another key point: any number of parameters or none
    is considered the right way to design a program. Of course, there are exceptions
    to every rule: some programs demand mandatory parameters.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这实际上说明了另一个关键点：任何数量的参数或没有参数都被认为是设计程序的正确方式。当然，每个规则都有例外：有些程序要求强制参数。
- en: 'Wait, there''s more. `cat` too, is an excellent example of a Unix filter (recall:
    a filter is a program that reads from its standard input, modifies its input in
    some manner, and writes the result to its standard output).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，还有更多。`cat`也是Unix过滤器的一个很好的例子（回想一下：过滤器是一个从其标准输入读取的程序，以某种方式修改其输入，并将结果写入其标准输出的程序）。
- en: So, quick quiz, if we just run `cat` with no parameters, what would happen?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，快速测验，如果我们只是运行`cat`而没有参数，会发生什么？
- en: 'Well, let''s try it out and see:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们试一试看看：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Wow, look at that: `cat` blocks (waits) at its stdin, the user types in a string
    and presses the Enter key, `cat` responds by copying its stdin to its stdout –
    no surprise there, as that''s the job of cat in a nutshell!'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，看看：`cat`在其标准输入处阻塞（等待），用户输入一个字符串并按Enter键，`cat`通过将其标准输入复制到其标准输出来做出响应-毫不奇怪，因为这就是猫的工作要点！
- en: 'One realizes the commands shown as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们意识到以下命令如下所示：
- en: '`cat fname` is the same as `cat < fname`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cat fname`等同于`cat < fname`'
- en: '`cat > fname` creates or overwrites the `fname` file'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cat > fname`创建或覆盖`fname`文件'
- en: 'There''s no reason we can''t use cat to append several files together:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 没有理由我们不能使用cat将几个文件追加在一起：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There's no reason this must be done with only plain text files; one can join
    together binary files too.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这不一定要使用纯文本文件；也可以合并二进制文件。
- en: In fact, that's what the utility does – it concatenates files. Thus its name;
    as is the norm on Unix, is highly abbreviated – from concatenate to just cat.
    Again, clean and elegant – the Unix way.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这就是这个实用程序所做的-它连接文件。因此它的名字；与Unix上的规范一样，高度缩写-从concatenate到cat。再次，干净而优雅-Unix的方式。
- en: cat shunts out file contents to stdout, in order. What if one wants to display
    a file's contents in reverse order (last line first)? Use the Unix `tac` utility – yes,
    that's cat spelled backward!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 猫将文件内容输出到标准输出，按顺序。如果想要以相反的顺序（最后一行先）显示文件的内容怎么办？使用Unix的`tac`实用程序-是的，就是猫的拼写反过来！
- en: 'Also, FYI, we saw that cat can be used to efficiently join files. Guess what:
    the `split (1)` utility can be used to break a file up into pieces.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，FYI，我们看到cat可以用来高效地连接文件。猜猜：`split (1)`实用程序可以用来将文件分割成多个部分。
- en: Combine tools seamlessly
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无缝地组合工具
- en: We just saw that common Unix utilities are often designed as filters, giving
    them the ability to read from their standard input and write to their standard
    output. This concept is elegantly extended to seamlessly combine together multiple
    utilities, using an IPC mechanism called a **pipe**.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到，常见的Unix实用程序通常被设计为过滤器，这使它们能够从它们的标准输入读取，并将结果写入它们的标准输出。这个概念被优雅地扩展到无缝地组合多个实用程序，使用一个叫做**管道**的IPC机制。
- en: 'Also, we recall that the Unix philosophy embraces the do one task only design.
    What if we have one program that does task A and another that does task B and
    we want to combine them? Ah, that''s exactly what pipes do! Refer to the following
    code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还记得Unix哲学拥抱只做一项任务的设计。如果我们有一个执行任务A的程序和另一个执行任务B的程序，我们想要将它们组合起来怎么办？啊，这正是管道所做的！参考以下代码：
- en: '`prg_does_taskA | prg_does_taskB`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`prg_does_taskA | prg_does_taskB`'
- en: 'A pipe essentially is redirection performed twice: the output of the left-hand
    program becomes the input to the right-hand program. Of course, this implies that
    the program on the left must write to stdout, and the program on the read must
    read from stdin.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 管道本质上是重定向执行两次：左侧程序的输出成为右侧程序的输入。当然，这意味着左侧的程序必须写入stdout，右侧的程序必须从stdin读取。
- en: 'An example: sort the list of mounted filesystems by space available (in reverse
    order).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：按可用空间（以相反顺序）对挂载的文件系统列表进行排序。
- en: As we have already discussed this example in the *One tool to do one task* section,
    we shall not repeat the same information.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经在*一个工具只做一项任务*部分讨论过的例子一样，我们不会重复相同的信息。
- en: '**Option 1**: Perform the following code using a temporary file (refer section,
    *One tool to do one task*):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项1**：使用临时文件执行以下代码（参考部分，*一个工具只做一项任务*）：'
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Option 2** : Using pipes—clean and elegant:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**选项2**：使用管道-干净而优雅：'
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Not only is this elegant, it is also far superior performance-wise, as writing
    to memory (the pipe is a memory object) is much faster than writing to disk.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅优雅，而且在性能上也更加出色，因为写入内存（管道是一个内存对象）比写入磁盘要快得多。
- en: One can extend this notion and combine multiple tools over multiple pipes; in
    effect, one can build a super tool from several regular tools by combining them.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以扩展这个概念，并通过多个管道组合多个工具；实际上，可以通过组合它们来构建一个超级工具。
- en: 'As an example: display the three processes taking the most (physical) memory;
    only display their PID, **virtual size** (**VSZ**), **resident set size **(**RSS**)
    (RSS is a fairly accurate measure of physical memory usage), and the name:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：显示占用最多（物理）内存的三个进程；仅显示它们的PID，虚拟大小（VSZ），驻留集大小（RSS）（RSS是对物理内存使用的相当准确的度量），以及名称：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we've combined five utilities, `ps`*,* `sed`,  `awk`*,* `sort`, and `tail`, over
    four pipes. Nice!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过四个管道组合了五个实用程序，`ps`，`sed`，`awk`，`sort`和`tail`。不错！
- en: 'Another example: display the process, not including daemons*, taking up the
    most memory (RSS):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子：显示占用最多内存（RSS）的进程，不包括守护进程*：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A daemon is a system background process; we'll cover this concept in *Daemon
    Process* here: [https://www.packtpub.com/sites/default/files/downloads/Daemon_Processes.pdf](https://www.packtpub.com/sites/default/files/downloads/Daemon_Processes.pdf).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程是系统后台进程；我们将在*守护进程*这里介绍这个概念：[https://www.packtpub.com/sites/default/files/downloads/Daemon_Processes.pdf](https://www.packtpub.com/sites/default/files/downloads/Daemon_Processes.pdf)。
- en: Plain text preferred
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯文本优先
- en: 'Unix programs are generally designed to work with text as it''s a universal
    interface. Of course, there are several utilities that do indeed operate on binary
    objects (such as object and executable files); we aren''t referring to them here.
    The point is this: Unix programs are designed to work on text as it simplifies
    the design and architecture of the program.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Unix程序通常设计为使用文本，因为它是一个通用接口。当然，有一些实用程序确实操作二进制对象（如对象和可执行文件）；我们在这里不是指它们。重点是：Unix程序设计为在文本上工作，因为它简化了程序的设计和架构。
- en: 'A common example: an application, on startup, parses a configuration file.
    The configuration file could be formatted as a binary blob. On the other hand,
    having it as a plain text file renders it easily readable (invaluable!) and therefore
    easier to understand and maintain. One might argue that parsing binary would be
    faster. Perhaps to some extent this is so, but consider the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的例子：一个应用程序在启动时解析配置文件。配置文件可以格式化为二进制数据块。另一方面，将其作为纯文本文件使其易于阅读（无价！），因此更容易理解和维护。有人可能会认为解析二进制会更快。也许在某种程度上是这样，但考虑以下情况：
- en: With modern hardware, the difference is probably not significant
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现代硬件上，差异可能并不显著
- en: A standardized plain text format (such as XML) would have optimized code to
    parse it, yielding both benefits
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准化的纯文本格式（如XML）将优化代码以解析它，从而产生双重好处
- en: Remember, simplicity is key!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，简单是关键！
- en: CLI, not GUI
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLI，而不是GUI
- en: The Unix OS, and all its applications, utilities, and tools, were always built
    to be used from a **command-line-interface** (**CLI**), typically, the shell.
    From the 1980s onward, the need for a **Graphical User Interface** (**GUI**) became
    apparent.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Unix操作系统及其所有应用程序、实用程序和工具都是为了从**命令行界面**（**CLI**）而构建的，通常是shell。从20世纪80年代开始，对**图形用户界面**（**GUI**）的需求变得明显。
- en: 'Robert Scheifler of MIT, considered the chief design architect behind the X
    Window System, built an exceedingly clean and elegant architecture, a key component
    of which is this: the GUI forms a layer (well, actually, several layers) above
    the OS, providing libraries for GUI clients, that is, applications.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 麻省理工学院的Robert Scheifler被认为是X Window系统的首席设计架构师，他构建了一个非常干净和优雅的架构，其中的一个关键组成部分是：GUI形成了OS上方的一层（实际上是几层），为GUI客户端即应用程序提供库。
- en: The GUI was never designed to be intrinsic to applications or the OS—it's always
    optional.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: GUI从来不是设计为应用程序或操作系统的固有部分 - 它始终是可选的。
- en: This architecture still holds up today. Having said that, especially on embedded
    Linux, performance reasons are seeing the advent of newer architectures, such
    as the frame buffer and Wayland. Also, though Android, which uses the Linux kernel,
    necessitates a GUI for the end user, the system developer's interface to Android,
    ADB, is a CLI.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构今天仍然有效。话虽如此，尤其是在嵌入式Linux上，出于性能原因，新架构的出现，比如帧缓冲区和Wayland。此外，尽管使用Linux内核的Android需要为最终用户提供GUI，但系统开发人员与Android的接口ADB是CLI。
- en: A huge number of production-embedded and server Linux systems run purely on
    CLI interfaces. The GUI is almost like an add-on feature, for the end user's ease
    of operation.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的生产嵌入式和服务器Linux系统纯粹依靠CLI界面运行。GUI几乎就像是一个附加功能，为最终用户的操作方便。
- en: Wherever appropriate, design your tools to work in the CLI environment; adapting
    it into a GUI at a later point is then straightforward.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当的地方，设计您的工具以在CLI环境中工作；稍后将其适应GUI就变得简单了。
- en: Cleanly and carefully separating the business logic of the project or product
    from its GUI is a key to good design.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 清晰而谨慎地将项目或产品的业务逻辑与其GUI分离是良好设计的关键。
- en: Modular, designed to be repurposed by others
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化，设计为他人重新利用
- en: From its very early days, the Unix OS was deliberately designed and coded with
    the tacit assumption that multiple programmers would work on the system. Thus,
    the culture of writing clean, elegant, and understandable code, to be read and
    worked upon by other competent programmers, was ingrained.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从Unix操作系统的早期开始，它就被有意地设计和编码，假定多个程序员将在系统上工作。因此，编写干净、优雅和易于理解的代码的文化，以便其他有能力的程序员阅读和使用，已经根深蒂固。
- en: Later, with the advent of the Unix wars, proprietary and legal concerns overrode
    this sharing model. Interestingly, history shows that the Unix's were fading in
    relevance and industry use, until the timely advent of none other than the Linux
    OS – an open source ecosystem at its very best! Today, the Linux OS is widely
    acknowledged as the most successful GNU project. Ironic indeed!
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，随着Unix战争的出现，专有和法律上的关注超越了这种共享模式。有趣的是，历史表明Unix在相关性和行业使用方面逐渐失去了地位，直到及时出现了Linux操作系统
    - 这是一个开源生态系统的最佳体现！今天，Linux操作系统被广泛认为是最成功的GNU项目。确实讽刺！
- en: Provide mechanisms, not policies
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供机制，而不是政策
- en: Let's understand this principle with a simple example.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的例子来理解这个原则。
- en: 'When designing an application, you need to have the user enter a login `name`
    and `password`. The function that performs the work of getting and checking the
    password is called, let''s say, `mygetpass()`. It''s invoked by the `mylogin()` function:
    `mylogin() → mygetpass()`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计应用程序时，您需要用户输入登录`name`和`password`。执行获取和检查密码工作的函数称为，比如说，`mygetpass()`。它由`mylogin()`函数调用：`mylogin()
    → mygetpass()`。
- en: 'Now, the protocol to be followed is this: if the user gets the password wrong
    three times in a row, the program should not allow access (and should log the
    case). Fine, but where do we check this?'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要遵循的协议是：如果用户连续三次输入错误密码，程序不应允许访问（并应记录该情况）。好吧，但我们在哪里检查这个？
- en: 'The Unix philosophy: do not implement the logic, if the password is specified
    wrongly three times, abort in the `mygetpass()` function. Instead, just have `mygetpass()`
    return a Boolean (true when the password is right, false when the password is
    wrong), and have the `mylogin()` calling function implement whatever logic is
    required.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Unix哲学：如果密码在`mygetpass()`函数中被错误指定三次，不要实现逻辑，而是让`mygetpass()`返回一个布尔值（密码正确时为true，密码错误时为false），并让调用`mylogin()`函数实现所需的逻辑。
- en: Pseudocode
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪代码
- en: 'The following is the wrong approach:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是错误的方法：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now let''s take a look at the right approach: the Unix way! Refer to the following
    code:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看正确的方法：Unix的方式！参考以下代码：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The job of `mygetpass()` is to get a password from the user and check whether
    it's correct; it returns success or failure to the caller – that's it. That's
    the mechanism. It is not its job to decide what to do if the password is wrong
    – that's the policy, and left to the caller.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`mygetpass()`的工作是从用户那里获取密码并检查它是否正确；它将成功或失败的结果返回给调用者-就是这样。这就是机制。它的工作不是决定如果密码错误该怎么办-这是策略，留给调用者决定。'
- en: Now that we've covered the Unix philosophy in a nutshell, what are the important
    takeaways for you, the system developer on Linux?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经简要介绍了Unix哲学，那么对于你作为Linux系统开发者来说，重要的要点是什么呢？
- en: 'Learning from, and following, the Unix philosophy when designing and implementing
    your applications on the Linux OS will provide a huge payoff. Your application
    will do the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和实现Linux操作系统上的应用程序时，从Unix哲学中学习并遵循将会带来巨大的回报。你的应用程序将会做到以下几点：
- en: Be a natural fit on the system; this is very important
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成为系统的自然适应部分；这一点非常重要
- en: Have greatly reduced complexity
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大大减少了复杂性
- en: Have a modular design that is clean and elegant
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个干净而优雅的模块化设计
- en: Be far more maintainable
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更易于维护
- en: Linux system architecture
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux系统架构
- en: 'In order to clearly understand the Linux system architecture, one needs to
    first understand a few important concepts: the processor **Application Binary
    Interface** (**ABI**), CPU privilege levels, and how these affect the code we
    write. Accordingly, and with a few code examples, we''ll delve into these here,
    before diving into the details of the system architecture itself.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地理解Linux系统架构，首先需要了解一些重要的概念：处理器**应用二进制接口**（**ABI**）、CPU特权级别以及这些如何影响我们编写的代码。因此，在几个代码示例中，我们将在这里深入探讨这些内容，然后再深入了解系统架构的细节。
- en: Preliminaries
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'If one is posed the question, "what is the CPU for?", the answer is pretty
    obvious: the CPU is the heart of the machine – it reads in, decodes, and executes
    machine instructions, working on memory and peripherals. It does this by incorporating
    various stages.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人问“CPU是用来做什么的？”，答案显而易见：CPU是机器的核心，它读取、解码和执行机器指令，处理内存和外围设备。它通过各种阶段来实现这一点。
- en: Very simplistically, in the Instruction Fetch stage, it reads in machine instructions
    (which we represent in various human-readable ways – in hexadecimal, assembly,
    and high-level languages) from memory (RAM) or CPU cache. Then, in the Instruction
    Decode phase, it proceeds to decipher the instruction. Along the way, it makes
    use of the control unit, its register set, ALU, and memory/peripheral interfaces.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，在指令获取阶段，它从内存（RAM）或CPU缓存中读取机器指令（我们以各种人类可读的方式表示，如十六进制、汇编和高级语言）。然后，在指令解码阶段，它继续解析指令。在此过程中，它利用控制单元、寄存器集、ALU和内存/外围接口。
- en: The ABI
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ABI
- en: Let's imagine that we write a C program, and run it on the machine.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们编写了一个C程序，并在机器上运行它。
- en: Well, hang on a second. C code cannot possibly be directly deciphered by the
    CPU; it must be converted into machine language. So, we understand that on modern
    systems we will have a toolchain installed – this includes the compiler, linker,
    library objects, and various other tools. We compile and link the C source code,
    converting it into an executable format that can be run on the system.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下。C代码不可能直接被CPU解析；它必须被转换成机器语言。因此，我们了解到在现代系统上我们将安装一个工具链 - 这包括编译器、链接器、库对象和各种其他工具。我们编译和链接C源代码，将其转换为可在系统上运行的可执行格式。
- en: The processor **Instruction Set Architecture** (**ISA**) – documents the machine's
    instruction formats, the addressing schemes it supports, and its register model.
    In fact, CPU **Original Equipment Manufacturers** (**OEMs**) release a document
    that describes how the machine works; this document is generally called the ABI. The
    ABI describes more than just the ISA; it describes the machine instruction formats,
    the register set details, the calling convention, the linking semantics, and the
    executable file format, such as ELF. Try out a quick Google for x86 ABI – it should
    reveal interesting results.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器**指令集架构**（**ISA**）- 记录了机器的指令格式、支持的寻址方案和寄存器模型。事实上，CPU**原始设备制造商**（**OEMs**）发布了一份描述机器工作原理的文档；这份文档通常被称为ABI。ABI不仅描述了ISA，还描述了机器指令格式、寄存器集细节、调用约定、链接语义和可执行文件格式，比如ELF。尝试在谷歌上搜索x86
    ABI - 这应该会显示出有趣的结果。
- en: The publisher makes the full source code for this book available on their website;
    we urge the reader to perform a quick Git clone on the following URL. Build and
    try it: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 出版商在他们的网站上提供了本书的完整源代码；我们建议读者在以下URL上进行快速的Git克隆。构建并尝试它：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: 'Let''s try this out. First, we write a simple `Hello, World` type of C program:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。首先，我们编写一个简单的`Hello, World`类型的C程序：
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We build the application via the `Makefile`, with `make`. Ideally, the code must compile
    with no warnings:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`Makefile`和`make`构建应用程序。理想情况下，代码必须在没有警告的情况下编译通过。
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Important! Do not ignore compiler warnings with production code. Strive to get
    rid of all warnings, even the seemingly trivial ones; this will help a great deal
    with correctness, stability, and security.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 重要！不要忽略生产代码中的编译器警告。努力消除所有警告，即使看似微不足道的警告也是如此；这将对正确性、稳定性和安全性有很大帮助。
- en: In this trivial example code, we understand and anticipate the unused variable warning
    that `gcc` emits, and just ignore it for the purpose of this demo.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的示例代码中，我们理解并预期了`gcc`发出的未使用变量警告，并且只是为了演示目的而忽略它。
- en: The exact warning and/or error messages you see on your system could differ
    from what you see here. This is because my Linux distribution (and version), compiler/linker,
    library versions, and perhaps even CPU, may differ from yours. I built this on
    a x86_64 box running the Fedora 27/28 Linux distribution.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您在系统上看到的确切警告和/或错误消息可能与您在此处看到的不同。这是因为我的Linux发行版（和版本）、编译器/链接器、库版本，甚至可能是CPU，可能与您的不同。我在运行Fedora
    27/28 Linux发行版的x86_64框上构建了这个。
- en: 'Similarly, we build the debug version of the `hello` program (again, ignoring
    the warning for now), and run it:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们构建了`hello`程序的调试版本（暂时忽略警告），并运行它：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We use the powerful **`objdump`** utility to see the intermixed source-assembly-machine
    language of our program (`objdump's --source option switch`
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用强大的**`objdump`**实用程序来查看程序的源代码、汇编语言和机器语言的混合（`objdump`的--source选项开关）
- en: '` -S, --source Intermix source code with disassembly`):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '` -S, --source 将源代码与反汇编混合`）：'
- en: '[PRE26]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The exact assembly and machine code you see on your system will, in all likelihood,
    differ from what you see here; this is because my Linux distribution (and version),
    compiler/linker, library versions, and perhaps even CPU, may differ from yours.
    I built this on a x86_64 box running Fedora Core 27.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您在系统上看到的确切汇编和机器代码很可能与您在此处看到的不同；这是因为我的Linux发行版（和版本）、编译器/链接器、库版本，甚至可能是CPU，可能与您的不同。我在运行Fedora
    Core 27的x86_64框上构建了这个。
- en: 'Alright. Let''s take the line of source code `a = 5;` where, `objdump` reveals
    the corresponding machine and assembly language:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧。让我们看一下源代码行`a = 5;`，`objdump`显示了相应的机器和汇编语言：
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now clearly see the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以清楚地看到以下内容：
- en: '| **C source** | **Assembly language** | **Machine instructions** |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| **C源代码** | **汇编语言** | **机器指令** |'
- en: '| **`a = 5;`** | **`movl $0x5,-0x4(%rbp)`** | `c7 45 fc 05 00 00 00` |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| **`a = 5;`** | **`movl $0x5,-0x4(%rbp)`** | `c7 45 fc 05 00 00 00` |'
- en: So, when the process runs, at some point it will fetch and execute the machine
    instructions, producing the desired result. Indeed, that's exactly what a programmable
    computer is designed to do!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当进程运行时，它将在某个时刻获取并执行机器指令，产生期望的结果。确实，这正是可编程计算机的设计目的！
- en: Though we have shown examples of displaying (and even writing a bit of) assembly
    and machine code for the Intel CPU, the concepts and principles behind this discussion
    hold up for other CPU architectures, such as ARM, PPC, and MIPS. Covering similar
    examples for all these CPUs goes beyond the scope of this book; however, we urge
    the interested reader to study the processor datasheet and ABI, and try it out.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经展示了显示（甚至写了一点）英特尔CPU的汇编和机器代码的示例，但是这个讨论背后的概念和原则对其他CPU架构，如ARM、PPC和MIPS，也同样适用。涵盖所有这些CPU的类似示例超出了本书的范围；然而，我们建议感兴趣的读者研究处理器数据表和ABI，并尝试一下。
- en: Accessing a register's content via inline assembly
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过内联汇编访问寄存器的内容
- en: 'Now that we''ve written a simple C program and seen its assembly and machine
    code, let''s move on to something a little more challenging: a C program with
    inline assembly to access the contents of a CPU register.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了一个简单的C程序并看到了它的汇编和机器代码，让我们继续进行一些更具挑战性的工作：一个带有内联汇编的C程序，以访问CPU寄存器的内容。
- en: Details on assembly-language programming are outside the scope of this book;
    refer to the *Further reading* section on the GitHub repository.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有关汇编语言编程的详细信息超出了本书的范围；请参阅GitHub存储库上的*进一步阅读*部分。
- en: 'x86_64 has several registers; let''s just go with the ordinary RCX register
    for this example. We do make use of an interesting trick: the x86 ABI calling
    convention states that the return value of a function will be the value placed
    in the accumulator, that is, RAX for the x86_64\. Using this knowledge, we write
    a function that uses inline assembly to place the content of the register we want
    into RAX. This ensures that this is what it will return to the caller!'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: x86_64有几个寄存器；让我们就以普通的RCX寄存器为例。我们确实使用了一个有趣的技巧：x86 ABI调用约定规定函数的返回值将是放在累加器中的值，也就是x86_64的RAX。利用这个知识，我们编写一个使用内联汇编将我们想要的寄存器内容放入RAX的函数。这确保了这是它将返回给调用者的内容！
- en: 'Assembly micro-basics includes the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编微基础包括以下内容：
- en: '`at&t syntax:`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`at&t语法：`'
- en: '`       movq <src_reg>, <dest_reg>`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`       movq <src_reg>, <dest_reg>`'
- en: '`Register        : prefix name with %`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`寄存器：前缀名称为%`'
- en: '`Immediate value : prefix with $`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`立即值：前缀为$`'
- en: For more, see the *Further reading* section on the GitHub repository.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅GitHub存储库上的*进一步阅读*部分。
- en: 'Let''s take a look at the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下代码：
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There; it works as expected.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里；它按预期工作。
- en: Accessing a control register's content via inline assembly
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过内联汇编访问控制寄存器的内容
- en: Among the many fascinating registers on the x86_64 processor, there happen to
    be six control registers, named CR0 through CR4, and CR8\. There's really no need
    to delve into detail regarding them; suffice it to say that they are crucial to
    system control.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86_64处理器上有许多引人入胜的寄存器，其中有六个控制寄存器，命名为CR0到CR4和CR8。没有必要详细讨论它们；可以说它们对系统控制至关重要。
- en: For the purpose of an illustrative example, let's consider the CR0 register
    for a moment. Intel's manual states: CR0—contains system control flags that control
    operating mode and states of the processor.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，让我们暂时考虑一下CR0寄存器。英特尔的手册指出：CR0-包含控制处理器操作模式和状态的系统控制标志。
- en: 'Intel''s manuals can be downloaded conveniently as PDF documents from here
    (includes the Intel® 64 and IA-32 Architectures Software Developer''s Manual,
    Volume 3 (3A, 3B and 3C): System Programming Guide):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔的手册可以从这里方便地下载为PDF文档（包括英特尔® 64和IA-32体系结构软件开发人员手册，第3卷（3A、3B和3C）：系统编程指南）：
- en: '[https://software.intel.com/en-us/articles/intel-sdm](https://software.intel.com/en-us/articles/intel-sdm)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://software.intel.com/en-us/articles/intel-sdm](https://software.intel.com/en-us/articles/intel-sdm)'
- en: Clearly, CR0 is an important register!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，CR0是一个重要的寄存器！
- en: 'We modify our previous program to access and display its content (instead of
    the ordinary `RCX` register). The only relevant code (which has changed from the
    previous program) is the function that queries the `CR0` register value:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了之前的程序以访问并显示其内容（而不是普通的`RCX`寄存器）。唯一相关的代码（与之前的程序不同）是查询`CR0`寄存器值的函数：
- en: '[PRE29]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Build and run it:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行它：
- en: '[PRE30]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It crashes!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 它崩溃了！
- en: Well, what happened here? Read on.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这里发生了什么？继续阅读。
- en: CPU privilege levels
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU特权级别
- en: 'As mentioned earlier in this chapter, the essential job of the CPU is to read
    in machine instructions from memory, decipher, and execute them. In the early
    days of computing, this is pretty much all the processor did. But then, engineers,
    thinking deeper on it, realized that there is a critical issue with this: if a
    programmer can feed an arbitrary stream of machine instructions to the processor,
    which it, in turn, blindly and obediently executes, herein lies scope to do damage,
    to hack the machine!'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面提到的，CPU的基本工作是从内存中读取机器指令，解释并执行它们。在计算机的早期，这几乎是处理器所做的全部工作。但后来，工程师们更深入地思考了这个问题，意识到其中存在一个关键问题：如果程序员可以向处理器提供任意的机器指令流，而处理器又盲目地、顺从地执行它们，那么就存在损害、黑客攻击机器的可能性！
- en: 'How? Recall from the previous section the Intel processor''s CR0 control register: Contains
    system control flags that control operating mode and states of the processor. If
    one has unlimited (read/write) access to the CR0 register, one could toggle bits
    that could do the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如何？回想一下前一节中提到的英特尔处理器的CR0控制寄存器：包含控制处理器操作模式和状态的系统控制标志。如果有无限（读/写）访问CR0寄存器的权限，就可以切换位，从而可以做到以下几点：
- en: Turn hardware paging on or off
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开或关闭硬件分页
- en: Disable the CPU cache
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用CPU缓存
- en: Change caching and alignment attributes
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改缓存和对齐属性
- en: Disable WP (write protect) on memory (technically, pages) marked as read-only
    by the OS
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用操作系统标记为只读的内存（技术上是页面）上的WP（写保护）
- en: Wow, a hacker could indeed wreak havoc. At the very least, only the OS should
    be allowed this kind of access.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，黑客确实可以造成严重破坏。至少，只有操作系统应该被允许这种访问。
- en: Precisely for reasons such as the security, robustness, and correctness of the
    OS and the hardware resources it controls, all modern CPUs include the notion
    of privilege levels.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 正是出于安全、健壮性和操作系统及其控制的硬件资源的正确性等原因，所有现代CPU都包括特权级别的概念。
- en: 'The modern CPU will support at least two privilege levels, or modes, which
    are generically called the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现代CPU将支持至少两个特权级别或模式，通常称为以下内容：
- en: Supervisor
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员
- en: User
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户
- en: 'You need to understand that code, that is, machine instructions, runs on the
    CPU at a given privilege level or mode. A person designing and implementing an
    OS is free to exploit the processor privilege levels. This is exactly how modern
    OSes are designed. Take a look at the following table Generic CPU Privilege Levels:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要了解的是，即机器指令在CPU上以给定的特权级别或模式运行。设计和实现操作系统的人可以利用处理器特权级别。这正是现代操作系统的设计方式。看一下以下表格通用CPU特权级别：
- en: '| **Privilege level or mode name** | **Privilege level** | **Purpose** | **Terminology**
    |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| **特权级别或模式名称** | **特权级别** | **目的** | **术语** |'
- en: '| Supervisor | High | OS code runs here | kernel-space |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 管理员 | 高 | 操作系统代码在这里运行 | 内核空间 |'
- en: '| User | Low | Application code runs here | user-space (or userland) |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 用户 | 低 | 应用程序代码在这里运行 | 用户空间（或用户区） |'
- en: Table 1: Generic CPU Privilege Levels
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 表1：通用CPU特权级别
- en: Privilege levels or rings on the x86
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: x86特权级或环
- en: 'To understand this important concept better, let''s take the popular x86 architecture
    as a real example. Right from the i386 onward, the Intel processor supports four
    privilege levels or rings: Ring 0, Ring 1, Ring 2, and Ring 3\. On the Intel CPU''s,
    this is how the levels work:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个重要概念，让我们以流行的x86架构作为一个真实的例子。从i386开始，英特尔处理器支持四个特权级别或环：Ring 0、Ring 1、Ring
    2和Ring 3。在英特尔CPU上，这就是这些级别的工作方式：
- en: '![](img/d2294bba-9ac8-444b-9ed8-18f3223ddc66.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2294bba-9ac8-444b-9ed8-18f3223ddc66.png)'
- en: 'Figure 1: CPU ring levels and privilege'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：CPU环级别和特权
- en: 'Let''s visualize this *Figure 1* in the form of a *Table 2: x86 privilege or
    ring levels*:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将*图1*以*表2：x86特权或环级别*的形式进行可视化：
- en: '| **Privilege or ring level** | **Privilege** | **Purpose** |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| **特权或环级别** | **特权** | **目的** |'
- en: '| Ring 0 | Highest | OS code runs here |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 环0 | 最高 | 操作系统代码在这里运行 |'
- en: '| Ring 1 | < ring 0 | <Unused> |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 环1 | <环0 | <未使用> |'
- en: '| Ring 2 | < ring 1 | <Unused> |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 环2 | <环1 | <未使用> |'
- en: '| Ring 3 | Lowest | Application code runs here (userland) |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 环3 | 最低 | 应用程序代码在这里运行（用户空间） |'
- en: Table 2: x86 privilege or ring levels
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 表2：x86特权或环级别
- en: Originally, ring levels 1 and 2 were intended for device drivers, but modern
    OSes typically run driver code at ring 0 itself. Some hypervisors (VirtualBox
    being one) used to use Ring 1 to run the guest kernel code; this was the case
    earlier when no hardware virtualization support was available (Intel VT-x, AMD
    SV).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，环级别1和2是为设备驱动程序而设计的，但现代操作系统通常在环0中运行驱动程序代码。一些虚拟化程序（例如VirtualBox）曾经使用环1来运行客户机内核代码；在没有硬件虚拟化支持（如Intel
    VT-x、AMD SV）时，这是早期的情况。
- en: The ARM (32-bit) processor has seven modes of execution; of these, six are privileged,
    and only one is the non-privileged mode. On ARM, generically, the equivalent to
    Intel's Ring 0 is Supervisor (SVC) mode, and the equivalent to Intel's Ring 3 is User
    mode.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ARM（32位）处理器有七种执行模式；其中六种是特权的，只有一种是非特权模式。在ARM上，相当于英特尔的Ring 0是Supervisor（SVC）模式，相当于英特尔的Ring
    3是用户模式。
- en: For interested readers, there are more links in the *Further reading *section
    on the GitHub repository.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于感兴趣的读者，在GitHub存储库的*进一步阅读*部分中有更多链接。
- en: 'The following diagram clearly shows of all modern OSes (Linux, Unix, Windows,
    and macOS) running on an x86 processor exploit processor-privilege levels:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表清楚地显示了所有现代操作系统（Linux、Unix、Windows和macOS）在x86处理器上利用处理器特权级别：
- en: '![](img/bb4667c1-4b63-41c1-bc9b-6f2649caf32a.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb4667c1-4b63-41c1-bc9b-6f2649caf32a.png)'
- en: 'Figure 2: User-Kernel separation'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：用户-内核分离
- en: Importantly, the processor ISA assigns every machine instruction with a privilege
    level or levels at which they are allowed to be executed. A machine instruction
    that is allowed to execute at the user privilege level automatically implies it
    can also be executed at the Supervisor privilege level. This distinguishing between
    what can and cannot be done at what mode also applies to register access.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，处理器ISA为每条机器指令分配了一个特权级别或允许执行的多个特权级别。允许在用户特权级别执行的机器指令自动意味着它也可以在监管特权级别执行。对于寄存器访问，也适用于区分在哪种模式下可以做什么和不能做什么。
- en: To use the Intel terminology, the **Current Privilege Level** (**CPL**) is the
    privilege level at which the processor is currently executing code.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 用英特尔的术语来说，**当前特权级别**（**CPL**）是处理器当前执行代码的特权级别。
- en: 'For example, that on a given processor shown as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在给定的处理器上，如下所示：
- en: The foo1 machine instruction has an allowed privilege level of Supervisor (or
    Ring 0 for x86)
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: foo1机器指令的允许特权级别为监管者（或x86的Ring 0）
- en: The foo2 machine instruction has an allowed privilege level of User (or Ring
    3 for x86)
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: foo2机器指令的允许特权级别为用户（或x86的Ring 3）
- en: 'So, for a running application that executes these machine instructions, the
    following table emerges:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于执行这些机器指令的运行应用程序，出现了以下表格：
- en: '| **Machine instruction** | **Allowed-at mode** | **CPL (current privilege
    level)** | **Works?** |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| **机器指令** | **允许的模式** | **CPL（当前特权级别）** | **可行？** |'
- en: '| foo1 | Supervisor (0) | 0 | Yes |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| foo1 | 监管者（0）| 0 | 是 |'
- en: '| 3 | No |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 否 |'
- en: '| foo2 | User (3) | 0 | Yes |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| foo2 | 用户（3）| 0 | 是 |'
- en: '| 3 | Yes |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 是 |'
- en: 'Table 3: Privilege levels – an example'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 表3：特权级别示例
- en: So, thinking about it, foo2 being allowed at User mode would also be allowed
    to execute with any CPL. In other words, if the CPL <= allowed privilege level,
    it works, otherwise it does not.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑到foo2在用户模式下被允许执行，也将被允许以任何CPL执行。换句话说，如果CPL <= 允许的特权级别，则可以执行，否则不行。
- en: 'When one runs an application on, say, Linux, the application runs as a process
    (more on this later). But what privilege (or mode or ring) level does the application
    code run at? Refer to the preceding table: User Mode (Ring 3 on x86).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Linux上运行应用程序时，应用程序作为一个进程运行（稍后会详细介绍）。但应用程序代码运行在什么特权级别（或模式或环）下？参考前面的表格：用户模式（x86上的Ring
    3）。
- en: Aha! So now we see. The preceding code example, `getreg_rcx.c`, worked because
    it attempted to access the content of the general-purpose `RCX` register, which
    is allowed in User Mode (Ring 3, as well as at the other levels, of course)!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！现在我们明白了。前面的代码示例`getreg_rcx.c`之所以能够工作，是因为它试图访问通用寄存器`RCX`的内容，在用户模式（Ring 3）下是允许的，当然在其他级别也是允许的！
- en: But the code of `getreg_cr0.c` failed; it crashed, because it attempted to access
    the content of the `CR0` control register, which is disallowed in User Mode (Ring
    3), and allowed only at the Ring 0 privilege! Only OS or kernel code can access
    the control registers. This holds true for several other sensitive assembly-language
    instructions as well. This approach makes a lot of sense.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 但`getreg_cr0.c`的代码失败了；它崩溃了，因为它试图访问`CR0`控制寄存器的内容，在用户模式（Ring 3）下是不允许的，只有在Ring
    0特权级别下才允许！只有操作系统或内核代码才能访问控制寄存器。这对其他一些敏感的汇编语言指令也是适用的。这种方法非常有道理。
- en: Technically, it crashed because the processor raised a **General Protection
    Fault** (**GPF**).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，它崩溃是因为处理器引发了**通用保护故障**（**GPF**）。
- en: Linux architecture
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux架构
- en: 'The Linux system architecture is a layered one. In a very simplistic way, but
    ideal to start on our path to understanding these details, the following diagram
    illustrates the Linux system architecture:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Linux系统架构是分层的。以一种非常简单的方式来说，但是理想的开始我们理解这些细节的路径，以下图表说明了Linux系统架构：
- en: '![](img/96584a09-5291-4921-9468-fcf30591d495.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/96584a09-5291-4921-9468-fcf30591d495.png)'
- en: 'Figure 3: Linux – Simplified layered architecture'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：Linux - 简化的分层架构
- en: 'Layers help, because each layer need only be concerned with the layer directly
    above and below it. This leads to many advantages:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 层有助于减少复杂性，因为每一层只需要关注它的上一层和下一层。这带来了许多优势：
- en: Clean design, reduces complexity
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰的设计，减少复杂性
- en: Standardization, interoperability
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准化，互操作性
- en: Ability to swap layers in and out of the stack
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在堆栈中轻松地切换层
- en: Ability to easily introduce new layers as required
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够根据需要轻松引入新的层
- en: 'On the last point, there exists the FTSE. To quote directly from Wikipedia:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一点上，存在FTSE。直接引用维基百科的话：
- en: The "**fundamental theorem of software engineering** (**FTSE**)" is a term originated
    by Andrew Koenig to describe a remark by Butler Lampson attributed to the late
    David J. Wheeler
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: “**软件工程的基本定理**（**FTSE**）”是由安德鲁·科尼格创造的术语，用来描述对已故的大卫·J·惠勒所做的评论。
- en: We can solve any problem by introducing an extra level of indirection.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过引入额外的间接层来解决任何问题。
- en: 'Now that we understand the concept of CPU modes or privilege levels, and how
    modern OSes exploit them, a better diagram (expanding on the previous one) of
    the Linux system architecture would be as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了CPU模式或特权级别的概念，以及现代操作系统如何利用它们，Linux系统架构的更好的图表（在前一个图表的基础上扩展）如下所示：
- en: '![](img/c1d28e82-acf9-4791-ad82-ae2e2f135916.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1d28e82-acf9-4791-ad82-ae2e2f135916.png)'
- en: Figure 4: Linux system architecture
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：Linux系统架构
- en: In the preceding diagram, P1, P2, …, Pn are nothing but userland processes (Process
    1, Process 2) or in other words, running applications. For example, on a Linux
    laptop, we might have the vim editor, a web browser, and terminal windows (gnome-terminal)
    running.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，P1、P2、…、Pn只是用户空间进程（进程1、进程2）或者换句话说，正在运行的应用程序。例如，在Linux笔记本上，我们可能有vim编辑器、一个网页浏览器和终端窗口（gnome-terminal）正在运行。
- en: Libraries
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库
- en: Libraries, of course, are archives (collections) of code; as we well know, using
    libraries helps tremendously with code modularity, standardization, preventing
    the reinvent-the-wheel syndrome, and so on. A Linux desktop system might have
    libraries numbering in the hundreds, and possibly even a few thousand!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，库是代码的存档（集合）；正如我们所知，使用库对于代码的模块化、标准化、防止重复发明轮子综合症等方面有很大帮助。Linux桌面系统可能有数百个库，甚至可能有几千个！
- en: 'The classic K&R `hello, world` C program uses the `printf` API to write the
    string to the display:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的K&R `hello, world` C程序使用`printf` API将字符串写入显示器：
- en: '[PRE31]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Obviously, the code of `printf` is not part of the `hello, world` source. So
    where does it come from? It's part of the standard C library; on Linux, due to
    its GNU origins, this library is commonly called **GNU libc** (**glibc**).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`printf`的代码不是`hello, world`源代码的一部分。那它是从哪里来的？它是标准C库的一部分；在Linux上，由于其GNU起源，这个库通常被称为**GNU
    libc**（**glibc**）。
- en: Glibc is a critical and required component on a Linux box. It not only contains
    the usual standard C library routines (APIs), it is, in fact, the programming
    interface to the operating system! How? Via its lower layer, the system calls.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Glibc是Linux盒子上的一个关键和必需的组件。它不仅包含通常的标准C库例程（APIs），事实上，它是操作系统的编程接口！如何？通过它的较低层，系统调用。
- en: System calls
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统调用
- en: System calls are actually kernel functionality  that can be invoked from userspace
    via glibc stub routines. They serve a critical function; they connect userspace
    to kernel-space. If a user program wants to request something of the kernel (read
    from a file, write to the network, change a file's permissions), it does so by
    issuing a system call. Therefore, system calls are the only legal entry point
    to the kernel. There is no other way for a user-space process to invoke the kernel.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用实际上是可以通过glibc存根例程从用户空间调用的内核功能。它们提供了关键功能；它们将用户空间连接到内核空间。如果用户程序想要请求内核的某些东西（从文件中读取，写入网络，更改文件权限），它会通过发出系统调用来实现。因此，系统调用是用户空间进入内核的唯一合法入口。用户空间进程没有其他方法可以调用内核。
- en: 'For a list of all the available Linux system calls, see section 2 of the man
    pages ([https://linux.die.net/man/2/](https://linux.die.net/man/2/)). One can
    also do: man 2 syscalls to see the man page on all supported system calls'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 有关所有可用Linux系统调用的列表，请参阅man页面的第2节（[https://linux.die.net/man/2/](https://linux.die.net/man/2/)）。也可以执行：man
    2 syscalls来查看所有支持的系统调用的man页面
- en: 'Another way to think of this: the Linux kernel internally has literally thousands
    of APIs (or functions). Of these, only a small fraction are made visible or available,
    that is, exposed, to userspace; these exposed kernel APIs are system calls! Again,
    as an approximation, modern Linux glibc has around 300 system calls.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考方式：Linux内核内部实际上有成千上万的API（或函数）。其中，只有很小一部分是可见或可用的，也就是暴露给用户空间的；这些暴露的内核API就是系统调用！同样，作为一个近似值，现代Linux
    glibc大约有300个系统调用。
- en: On an x86_64 Fedora 27 box running the 4.13.16-302.fc27.x86_64 kernel, there
    are close to 53,000 kernel APIs!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行4.13.16-302.fc27.x86_64内核的x86_64 Fedora 27盒子上，有接近53000个内核API！
- en: 'Here is the key thing to understand: system calls are very different from all
    other (typically library) APIs. As they ultimately invoke kernel (OS) code, they
    have the ability to cross the user-kernel boundary; in effect, they have the ability
    to switch from normal unprivileged User mode to completely privileged Supervisor
    or kernel mode!'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用与所有其他（通常是库）API非常不同。由于它们最终调用内核（操作系统）代码，它们有能力跨越用户-内核边界；实际上，它们有能力从普通的非特权用户模式切换到完全特权的监督员或内核模式！
- en: How? Without delving into the gory details, system calls essentially work by
    invoking special machine instructions that have the built-in ability to switch
    the processor mode from User to Supervisor. All modern CPU ABIs will provide at
    least one such machine instruction; on the x86 processor, the traditional way
    to implement system calls is to use the special int 0x80 machine instruction.
    Yes, it is indeed a software interrupt (or trap). From Pentium Pro and Linux 2.6
    onward, the sysenter/syscall machine instructions are used. See the *Further reading*
    section on the GitHub repository.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如何？不深入了解细节，系统调用基本上是通过调用具有内置能力从用户模式切换到监督员的特殊机器指令来工作的。所有现代CPU ABI都将提供至少一条这样的机器指令；在x86处理器上，实现系统调用的传统方式是使用特殊的int
    0x80机器指令。是的，这确实是一个软件中断（或陷阱）。从奔腾Pro和Linux 2.6开始，使用sysenter/syscall机器指令。请参阅GitHub存储库上的*进一步阅读*部分。
- en: 'From the viewpoint of the application developer, a key point regarding system
    calls is that system calls appear to be regular functions (APIs) that can be invoked
    by the developer; this design is deliberate. The reality: the system call APIs
    that one invokes – such as `open()`, `read()`, `chmod()`, `dup()`, and `write()`
    – are merely stubs. They are a neat mechanism to get at the actual code that is
    in the kernel (getting there involves populating a register the accumulator on
    x86 – with the system call number, and passing parameters via other general-purpose
    registers) to execute that kernel code path, and return back to user mode when
    done. Refer to the following table:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序开发人员的角度来看，关于系统调用的一个关键点是，系统调用似乎是可以被开发人员调用的常规函数（APIs）；这种设计是故意的。实际情况：开发人员调用的系统调用API（如`open()`、`read()`、`chmod()`、`dup()`和`write()`）只是存根。它们是一种很好的机制，可以访问内核中的实际代码（通过在x86上将累加器寄存器填充为系统调用编号，并通过其他通用寄存器传递参数）来执行内核代码路径，并在完成后返回到用户模式。参考以下表格：
- en: '| CPU | Machine instruction(s) used to trap to Supervisor (kernel) Mode from
    User Mode | Allocated Register for system call number |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| CPU | 用于从用户模式陷入监督员（内核）模式的机器指令 | 用于系统调用编号的分配寄存器 |'
- en: '| `x86[_64]` | `int 0x80 or syscall` | `EAX / RAX` |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `x86[_64]` | `int 0x80或syscall` | `EAX / RAX` |'
- en: '| `ARM` | `swi / svc` | R0 to R7 |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `ARM` | `swi / svc` | R0到R7 |'
- en: '| `Aarch64` | `svc` | `X8` |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `Aarch64` | `svc` | `X8` |'
- en: '| `MIPS` | `syscall` | `$v0` |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `MIPS` | `syscall` | `$v0` |'
- en: Table 4:  System calls on various CPU Architectures for better understanding
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 表4：各种CPU架构上的系统调用，以便更好地理解
- en: Linux – a monolithic OS
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux - 一个单体操作系统
- en: 'Operating systems are generally considered to adhere to one of two major architectural
    styles: monolithic or microkernel.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统通常被认为遵循两种主要的架构风格之一：单体或微内核。
- en: Linux is decidedly a monolithic OS.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Linux显然是一个单体操作系统。
- en: What does that mean?
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这是什么意思？
- en: 'The English word monolith literally means a large single upright block of stone:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 英语单词monolith字面上意味着一个大的单立的石块：
- en: '![](img/6cbdd14a-b484-42d8-af5f-909fa6fdb60a.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cbdd14a-b484-42d8-af5f-909fa6fdb60a.jpg)'
- en: 'Figure 5: Corinthian columns – they''re monolithic!'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：科林斯柱 - 它们是单体的！
- en: On the Linux OS, applications run as independent entities called **processes**.
    A process may be single-threaded (original Unix) or multithreaded. Regardless,
    for now, we will consider the process as the unit of execution on Linux; a process
    is defined as an instance of a program in execution.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux操作系统上，应用程序作为独立实体称为**进程**运行。一个进程可以是单线程（原始Unix）或多线程。不管怎样，现在，我们将进程视为Linux上的执行单元；进程被定义为正在执行的程序的一个实例。
- en: When a user-space process issues a library call, the library API, in turn, may
    or may not issue a system call. For example, issuing the `atoi(3)` API does not
    cause glibc to issue a system call as it does not require kernel support to implement
    the conversion of a string into an integer. `<api-name>(n)` *;* n is the man page
    section.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户空间进程发出库调用时，库API可能会或可能不会发出系统调用。例如，发出`atoi(3)`API并不会导致glibc发出系统调用，因为它不需要内核支持来实现将字符串转换为整数。`<api-name>(n)`
    *;* n是man手册部分。
- en: 'To help clarify these important concepts, let''s check out the famous and classic
    K&R `Hello, World` C program again:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助澄清这些重要概念，让我们再次看看著名的经典K&R `Hello, World` C程序：
- en: '[PRE32]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Okay, that should work. Indeed it does.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，应该可以。确实可以。
- en: But, the question is, how exactly does the `printf(3)` API write to the monitor
    device?
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题是，`printf(3)`API究竟如何写入监视器设备？
- en: 'The short answer: it does not.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的答案：不是这样的。
- en: 'The reality is that `printf(3)` only has the intelligence to format a string
    as specified; that''s it. Once done, `printf` actually invokes the `write(2)`
    API – a system call. The write system call does have the ability to write the
    buffer content to a special device file – the monitor device, seen by write as
    stdout. Go back to our discussion regarding *The Unix philosophy in a nutshell*
    : if it''s not a process, it''s a file! Of course, it gets really complex under
    the hood in the kernel; to cut a long story short, the kernel code of write ultimately
    switches to the correct driver code; the device driver is the only component that
    can directly work with peripheral hardware. It performs the actual write to the
    monitor, and return values propagate all the way back to the application.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`printf(3)`只有智能来格式化指定的字符串；就是这样。一旦完成，`printf`实际上调用了`write(2)`API - 一个系统调用。写系统调用确实有能力将缓冲区内容写入到一个特殊的设备文件
    - 监视器设备，被写入视为标准输出。回到我们关于*Unix哲学的核心*的讨论：如果不是一个进程，那就是一个文件！当然，在内核下面它变得非常复杂；长话短说，写的内核代码最终切换到正确的驱动程序代码；设备驱动程序是唯一可以直接与外围硬件交互的组件。它执行实际的写入到监视器，并且返回值一直传播回应用程序。
- en: 'In the following diagram, **P** is the `hello, world` process at runtime:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，**P**是`hello, world`在运行时的进程：
- en: '![](img/7e279435-c3f2-42d6-872b-5bfc9e75783a.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e279435-c3f2-42d6-872b-5bfc9e75783a.png)'
- en: 'Fig 6: Code flow: printf-to-kernel'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：代码流程：printf到内核
- en: 'Also, from the diagram, we can see that glibc is considered to consist of two
    parts:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从图中我们可以看到，glibc被认为由两部分组成：
- en: '**Arch-independent glibc**: The regular libc APIs (such as [s|sn|v]printf,
    memcpy, memcmp, atoi)'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与架构无关的glibc**：常规的libc API（如[s|sn|v]printf，memcpy，memcmp，atoi）'
- en: '**Arch-dependent glibc**: The system call stubs'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与架构相关的glibc**：系统调用存根'
- en: Here, by arch, we mean CPU.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，arch指的是CPU。
- en: Also the ellipses (...) represent additional logic and processing within kernel-space
    that we do not show or delve into here.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，省略号（...）代表内核空间中我们没有展示或深入探讨的额外逻辑和处理。
- en: Now that the code flow path of `hello, world` is clearer, let's get back to
    the monolithic stuff!
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`hello, world`的代码流路径更清晰了，让我们回到单体的东西！
- en: 'It''s easy to assume that it works this way:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易假设它是这样工作的：
- en: The `hello, world` app (process) issues the `printf(3)` library call.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个`hello, world`应用程序（进程）发出了`printf(3)`库调用。
- en: '`printf` issues the `write(2)` system call.'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`printf`发出了`write(2)`系统调用。'
- en: We switch from User to Supervisor (kernel) Mode.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从用户模式切换到监管者（内核）模式。
- en: The kernel takes over – it writes `hello, world` onto the monitor.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内核接管 - 它将`hello, world`写入监视器。
- en: Switch back to non-privileged User Mode.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换回非特权用户模式。
- en: Actually, that's NOT the case.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，情况并非如此。
- en: 'The reality is, in the monolithic design, there is no kernel; to word it another
    way, the kernel is actually part of the process itself. It works as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在单体设计中，没有内核；换句话说，内核实际上是进程本身的一部分。它的工作方式如下：
- en: The `hello, world` app (process) issues the `printf(3)` library call.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个`hello, world`应用程序（进程）发出了`printf(3)`库调用。
- en: printf issues the `write(2)` system call.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: printf发出了`write(2)`系统调用。
- en: The process invoking the system call now switches from User to Supervisor (kernel)
    Mode.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出系统调用的进程现在从用户模式切换到监管者（内核）模式。
- en: The process runs the underlying kernel code, the underlying device driver code,
    and thus, writes `hello, world` onto the monitor!
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程运行底层内核代码，底层设备驱动程序代码，因此，将`hello, world`写入监视器！
- en: The process is then switched back to non-privileged User Mode.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后进程被切换回非特权用户模式。
- en: To summarize, in a monolithic kernel, when a process (or thread) issues a system
    call, it switches to privileged Supervisor or kernel mode and runs the kernel
    code of the system call (working on kernel data). When done, it switches back
    to unprivileged User mode and continues executing userspace code (working on user
    data).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在单片内核中，当一个进程（或线程）发出系统调用时，它会切换到特权的监督者或内核模式，并运行系统调用的内核代码（处理内核数据）。完成后，它会切换回非特权的用户模式，并继续执行用户空间代码（处理用户数据）。
- en: 'This is very important to understand:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点非常重要要理解：
- en: '![](img/c1a9482d-6e8f-43db-89cc-b6f42feec640.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1a9482d-6e8f-43db-89cc-b6f42feec640.png)'
- en: 'Fig 7: Life of a process in terms of privilege modes'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：进程的特权模式生命周期
- en: 'The preceding diagram attempts to illustrate that the X axis is the timeline,
    and the Y axis represents User Mode (at the top) and Supervisor (kernel) Mode
    (at the bottom):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图尝试说明X轴是时间线，Y轴代表用户模式（顶部）和监督者（内核）模式（底部）：
- en: '**time t[0]**: A process is born in kernel mode (the code to create a process
    is within the kernel of course). Once fully born, it is switched to User (non-privileged)
    Mode and it runs its userspace code (working on its userspace data items as well).'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间 t[0]**：一个进程在内核模式下诞生（当然，创建进程的代码在内核中）。一旦完全诞生，它就会切换到用户（非特权）模式，并运行其用户空间代码（同时处理其用户空间数据项）。'
- en: '**time t[1]**: The process, directly or indirectly (perhaps via a library API),
    invokes a system call. It now traps into kernel mode (refer the table *System
    Calls on CPU Architectures* shows the machine instructions depending on the CPU
    to do so) and executes kernel code in privileged Supervisor Mode (working on kernel
    data items as well).'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间 t[1]**：进程直接或间接（可能通过库API）调用系统调用。现在它陷入内核模式（参考表格*CPU架构上的系统调用*显示了根据CPU的机器指令）并在特权监督者模式下执行内核代码（处理内核数据项）。'
- en: '**time t[2]**: The system call is done; the process switches back to non-privileged
    User Mode and continues to execute its userspace code. This process continues,
    until some point in the future.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间 t[2]**：系统调用完成；进程切换回非特权用户模式并继续执行其用户空间代码。这个过程会一直持续，直到未来的某个时间点。'
- en: '**time t[n]**: The process dies, either deliberately by invoking the exit API,
    or it is killed by a signal. It now switches back to Supervisor Mode (as the exit(3)
    library API invokes the _exit(2) system call), executes the kernel code of _exit(), and
    terminates.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间 t[n]**：进程死亡，要么是通过调用退出API故意退出，要么是被信号杀死。现在它切换回监督者模式（因为exit(3)库API调用_exit(2)系统调用），执行_exit()的内核代码，并终止。'
- en: In fact, most modern operating systems are monolithic (especially the Unix-like
    ones).
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，大多数现代操作系统都是单片内核的（尤其是类Unix的操作系统）。
- en: Technically, Linux is not considered 100 percent monolithic. It's considered
    to be mostly monolithic, but also modular, due to the fact that the Linux kernel
    supports modularization (the plugging in and out of kernel code and data, via
    a technology called **Loadable Kernel Modules** (**LKMs**)).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，Linux并不被认为是100%的单片内核。它被认为是大部分单片内核，但也是模块化的，因为Linux内核支持模块化（通过一种称为**可加载内核模块**（**LKM**）的技术插入和拔出内核代码和数据）。
- en: Interestingly, MS Windows (specifically, from the NT kernel onward) follows
    a hybrid architecture that is both monolithic and microkernel.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，MS Windows（特别是从NT内核开始）遵循了既是单片内核又是微内核的混合架构。
- en: Execution contexts within the kernel
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核内的执行上下文
- en: 'Kernel code always executes in one of two contexts:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 内核代码总是在两种上下文中的一种中执行：
- en: Process
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程
- en: Interrupt
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断
- en: It's easy to get confused here. Remember, this discussion applies to the context
    in which kernel code executes, not userspace code.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里很容易混淆。请记住，这个讨论适用于内核代码执行的上下文，而不是用户空间代码。
- en: Process context
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程上下文
- en: Now we understand that one can invoke kernel services by issuing a system call.
    When this occurs, the calling process runs the kernel code of the system call
    in kernel mode. This is termed **process context** – kernel code is now running
    in the context of the process that invoked the system call.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们明白了可以通过发出系统调用来调用内核服务。当这种情况发生时，调用进程以内核模式运行系统调用的内核代码。这被称为**进程上下文** - 内核代码现在在调用系统调用的进程的上下文中运行。
- en: 'Process context code has the following attributes:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 进程上下文代码具有以下属性：
- en: Always triggered by a process (or thread) issuing a system call
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是由进程（或线程）发出系统调用来触发
- en: Top-down approach
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自上而下的方法
- en: Synchronous execution of kernel code by a process
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程通过同步执行内核代码
- en: Interrupt context
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断上下文
- en: 'At first glance, there appears to be no other way that kernel code executes.
    Well, think about this scenario: the network receive path. A network packet destined
    for your Ethernet MAC address arrives at the hardware adapter, the hardware detects
    that it''s meant for it, collects it, and buffers it. It now must let the OS know;
    more technically, it must let the **Network Interface Card** (**NIC**) device
    driver know, so that it can fetch and process packets as they arrive. It kicks
    the NIC driver into action by asserting a hardware interrupt.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，似乎没有其他方式可以执行内核代码。好吧，想想这种情况：网络接收路径。一个发送到您以太网MAC地址的网络数据包到达硬件适配器，硬件检测到它是为它而来的，收集它并缓冲它。现在它必须让操作系统知道；更准确地说，它必须让**网络接口卡**（**NIC**）设备驱动程序知道，以便它可以在到达时获取和处理数据包。它通过断言硬件中断来激活NIC驱动程序。
- en: Recall that device drivers reside in kernel-space, and therefore their code
    runs in Supervisor or kernel Mode. The (kernel privilege) driver code **Interrupt
    service routine** (**ISR**) now executes, fetches the packet, and sends it up
    the OS network protocol stack for processing.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，设备驱动程序驻留在内核空间，因此它们的代码在特权或内核模式下运行。现在（内核特权）驱动程序代码**中断服务例程**（**ISR**）执行，获取数据包，并将其发送到操作系统网络协议栈进行处理。
- en: The NIC driver's ISR code is kernel code, and it is has run but in what context?
    It's obviously not in the context of any particular process. In fact, the hardware
    interrupt probably interrupted some process. Thus, we just call this *interrupt
    context*.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 网卡驱动程序的ISR代码是内核代码，但它在什么上下文中运行？显然不是在任何特定进程的上下文中。实际上，硬件中断可能中断了某个进程。因此，我们只是称之为*中断上下文*。
- en: 'The interrupt context code has the following attributes:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 中断上下文代码具有以下属性：
- en: Always triggered by a hardware interrupt (not a software interrupt, fault or
    exception; that's still process context)
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终由硬件中断触发（不是软件中断、故障或异常；那仍然是进程上下文）
- en: Bottom-up approach
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自下而上的方法
- en: Asynchronous execution of kernel code by an interrupt
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过中断异步执行内核代码
- en: If, at some point, you do report a kernel bug, it helps if you point out the
    execution context.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在某个时候报告内核错误，指出执行上下文会有所帮助。
- en: Technically, within interrupt context, we have further distinctions, such as
    hard-IRQs and softirqs, bottom halves, and tasklets. However, this discussion
    goes beyond the scope of this book.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，在中断上下文中，我们有进一步的区分，比如硬中断和软中断，底半部分和任务。然而，这个讨论超出了本书的范围。
- en: Summary
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter started by explaining the Unix design philosophy, including the
    central principles or pillars of the Unix philosophy, design, and architecture.
    We then described the Linux system architecture, where we covered the meaning
    of CPU-ABI (Application Binary Interface), ISA, and toolchain (using `objdump`
    to disassemble a simple program, and accessing CPU registers with inline assembly).
    CPU privilege levels and their importance in the modern OS were discussed, leading
    in to the Linux system architecture layers – application, libraries, system calls,
    and the kernel. The chapter finished with a discussion on how Linux is a monolithic
    OS and then explored kernel execution contexts.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先解释了Unix的设计哲学，包括Unix哲学、设计和架构的核心原则或支柱。然后我们描述了Linux系统架构，其中涵盖了CPU-ABI（应用程序二进制接口）、ISA和工具链的含义（使用`objdump`来反汇编一个简单的程序，并使用内联汇编访问CPU寄存器）。讨论了CPU特权级别及其在现代操作系统中的重要性，引出了Linux系统架构的层次
    - 应用程序、库、系统调用和内核。本章以讨论Linux是一个单片操作系统开始，然后探讨了内核执行上下文。
- en: In the next chapter, the reader will delve into the mysteries of, and get a
    solid grasp of, virtual memory – what exactly it means, why it's in all modern
    OSes, and the key benefits it provides. We will discuss relevant details of the
    making of process virtual address space.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，读者将深入探讨虚拟内存的奥秘，并对其有一个扎实的理解 - 它到底意味着什么，为什么它存在于所有现代操作系统中，以及它提供的关键好处。我们将讨论进程虚拟地址空间的相关细节。
