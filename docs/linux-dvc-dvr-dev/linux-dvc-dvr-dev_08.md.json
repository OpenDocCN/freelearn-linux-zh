["```\nstruct spi_device { \n    struct devicedev; \n    struct spi_master*master; \n    u32 max_speed_hz; \n    u8 chip_select; \n    u8 bits_per_word; \n    u16 mode; \n    int irq; \n    [...] \n    int cs_gpio;        /* chip select gpio */ \n}; \n```", "```\n#define  SPI_CPHA  0x01 \n#define  SPI_CPOL  0x02 \n```", "```\nstruct spi_driver { \n   const struct spi_device_id *id_table; \n   int (*probe)(struct spi_device *spi); \n   int (*remove)(struct spi_device *spi); \n   void (*shutdown)(struct spi_device *spi); \n   struct device_driver    driver; \n}; \n```", "```\nstatic int probe(struct spi_device *spi) \n```", "```\nstatic int my_probe(struct spi_device *spi) \n{ \n    [...] /* declare your variable/structures */ \n\n    /* bits_per_word cannot be configured in platform data */ \n    spi->mode = SPI_MODE_0; /* SPI mode */ \n    spi->max_speed_hz = 20000000;   /* Max clock for the device */ \n    spi->bits_per_word = 16;    /* device bit per word */ \n    ret = spi_setup(spi); \n    ret = spi_setup(spi); \n    if (ret < 0) \n        return ret; \n\n    [...] /* Make some init */ \n    [...] /* Register with apropriate framework */ \n\n    return ret; \n} \n```", "```\nconst struct spi_device_id *id = spi_get_device_id(spi); \nmy_private_data = array_chip_info[id->driver_data]; \n```", "```\n/* set the data */ \nvoid spi_set_drvdata(struct *spi_device, void *data); \n\n/* Get the data back */ \n void *spi_get_drvdata(const struct *spi_device); \n```", "```\nstruct mc33880 { \n    struct mutex    lock; \n    u8      bar; \n    struct foo chip; \n    struct spi_device *spi; \n}; \n\nstatic int mc33880_probe(struct spi_device *spi) \n{ \n    struct mc33880 *mc; \n    [...] /* Device set up */ \n\n    mc = devm_kzalloc(&spi->dev, sizeof(struct mc33880), \n                      GFP_KERNEL); \n    if (!mc) \n        return -ENOMEM; \n\n    mutex_init(&mc->lock); \n    spi_set_drvdata(spi, mc); \n\n    mc->spi = spi; \n    mc->chip.label = DRIVER_NAME, \n    mc->chip.set = mc33880_set; \n\n    /* Register with appropriate framework */ \n    [...] \n} \n```", "```\nstatic int  my_remove(struct spi_device *spi); \n```", "```\nstatic int mc33880_remove(struct spi_device *spi) \n{ \n    struct mc33880 *mc; \n    mc = spi_get_drvdata(spi); /* Get our data back */ \n    if (!mc) \n        return -ENODEV; \n\n    /* \n     * unregister from frameworks with which we registered in the \n     * probe function \n     */ \n    [...] \n    mutex_destroy(&mc->lock); \n    return 0; \n} \n```", "```\nstatic int __init foo_init(void) \n{ \n    [...] /*My init code */ \n   return spi_register_driver(&foo_driver); \n} \nmodule_init(foo_init); \n\nstatic void __exit foo_cleanup(void) \n{ \n    [...] /* My clean up code */ \n   spi_unregister_driver(&foo_driver); \n} \nmodule_exit(foo_cleanup); \n```", "```\nmodule_spi_driver(foo_driver); \n```", "```\nstruct spi_device_id { \n   char name[SPI_NAME_SIZE]; \n   kernel_ulong_t driver_data; /* Data private to the driver */ \n}; \n```", "```\n#define ID_FOR_FOO_DEVICE  0 \n#define ID_FOR_BAR_DEVICE  1  \n\nstatic struct spi_device_id foo_idtable[] = { \n   { \"foo\", ID_FOR_FOO_DEVICE }, \n   { \"bar\", ID_FOR_BAR_DEVICE }, \n   { } \n}; \nMODULE_DEVICE_TABLE(spi, foo_idtable); \n\nstatic struct spi_driver foo_driver = { \n   .driver = { \n   .name = \"KBUILD_MODULE\", \n   }, \n\n   .id_table    = foo_idtable, \n   .probe       = foo_probe, \n   .remove      = foo_remove, \n}; \n\nmodule_spi_driver(foo_driver); \n```", "```\n/** \n * Our platform data \n */ \nstruct my_platform_data { \n   int foo; \n   bool bar; \n}; \nstatic struct my_platform_data mpfd = { \n   .foo = 15, \n   .bar = true, \n}; \n\nstatic struct spi_board_info \n   my_board_spi_board_info[] __initdata = { \n    { \n       /* the modalias must be same as spi device driver name */ \n        .modalias = \"ad7887\", /* Name of spi_driver for this device */ \n        .max_speed_hz = 1000000,  /* max spi clock (SCK) speed in HZ */ \n        .bus_num = 0, /* Framework bus number */ \n        .irq = GPIO_IRQ(40), \n        .chip_select = 3, /* Framework chip select */ \n        .platform_data = &mpfd, \n        .mode = SPI_MODE_3, \n   },{ \n        .modalias = \"spidev\", \n        .chip_select = 0, \n        .max_speed_hz = 1 * 1000 * 1000, \n        .bus_num = 1, \n        .mode = SPI_MODE_3, \n    }, \n}; \n\nstatic int __init board_init(void) \n{ \n   [...] \n   spi_register_board_info(my_board_spi_board_info, ARRAY_SIZE(my_board_spi_board_info)); \n   [...] \n\n   return 0; \n} \n[...] \n```", "```\necspi1 { \n    fsl,spi-num-chipselects = <3>; \n    cs-gpios = <&gpio5 17 0>, <&gpio5 17 0>, <&gpio5 17 0>; \n    pinctrl-0 = <&pinctrl_ecspi1 &pinctrl_ecspi1_cs>; \n    #address-cells = <1>; \n    #size-cells = <0>; \n    compatible = \"fsl,imx6q-ecspi\", \"fsl,imx51-ecspi\"; \n    reg = <0x02008000 0x4000>; \n    status = \"okay\"; \n\n    ad7606r8_0: ad7606r8@0 { \n        compatible = \"ad7606-8\"; \n        reg = <0>; \n        spi-max-frequency = <1000000>; \n        interrupt-parent = <&gpio4>; \n        interrupts = <30 0x0>; \n   }; \n   label: fake_spi_device@1 { \n        compatible = \"packtpub,foobar-device\"; \n        reg = <1>; \n        a-string-param = \"stringvalue\"; \n        spi-cs-high; \n   }; \n   mcp2515can: can@2 { \n        compatible = \"microchip,mcp2515\"; \n        reg = <2>; \n        spi-max-frequency = <1000000>; \n        clocks = <&clk8m>; \n        interrupt-parent = <&gpio4>; \n        interrupts = <29 IRQ_TYPE_LEVEL_LOW>; \n    }; \n}; \n```", "```\n&ecspi1 { \n    status = \"okay\"; \n    label: fake_spi_device@1 { \n    compatible = \"packtpub,foobar-device\"; \n    reg = <1>; \n    a-string-param = \"stringvalue\"; \n    spi-cs-high; \n   }; \n }; \n```", "```\nstatic const struct of_device_id foobar_of_match[] = { \n           { .compatible = \"packtpub,foobar-device\" }, \n           { .compatible = \"packtpub,barfoo-device\" }, \n        {} \n}; \nMODULE_DEVICE_TABLE(of, foobar_of_match); \n```", "```\nstatic struct spi_driver foo_driver = { \n    .driver = { \n    .name   = \"foo\", \n        /* The following line adds Device tree */ \n    .of_match_table = of_match_ptr(foobar_of_match), \n    }, \n    .probe   = my_spi_probe, \n    .id_table = foo_id, \n}; \n```", "```\nstatic int my_spi_probe(struct spi_device *spi) \n{ \n    const struct of_device_id *match; \n    match = of_match_device(of_match_ptr(foobar_of_match), &spi->dev); \n    if (match) { \n        /* Device tree code goes here */ \n    } else { \n        /*  \n         * Platform data code comes here. \n         * One can use \n         *   pdata = dev_get_platdata(&spi->dev); \n         * \n         * or *id*, which is a pointer on the *spi_device_id* entry that originated \n         * the match, in order to use *id->driver_data* to extract the device \n         * specific data, as described in Chapter 5, Platform Device Drivers. \n         */ \n    } \n    [...] \n} \n```", "```\nstruct spi_transfer { \n    const void  *tx_buf; \n    void *rx_buf; \n    unsigned len; \n\n    dma_addr_t tx_dma; \n    dma_addr_t rx_dma; \n\n    unsigned cs_change:1; \n    unsigned tx_nbits:3; \n    unsigned rx_nbits:3; \n#define  SPI_NBITS_SINGLE   0x01 /* 1bit transfer */ \n#define  SPI_NBITS_DUAL            0x02 /* 2bits transfer */ \n#define  SPI_NBITS_QUAD            0x04 /* 4bits transfer */ \n    u8 bits_per_word; \n    u16 delay_usecs; \n    u32 speed_hz; \n}; \n```", "```\n    struct spi_message { \n       struct list_head transfers; \n       struct spi_device *spi; \n       unsigned is_dma_mapped:1; \n       /* completion is reported through a callback */ \n       void (*complete)(void *context); \n       void *context; \n       unsigned frame_length; \n       unsigned actual_length; \n       int status; \n    }; \n```", "```\nchar tx_buf[] = { \n        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, \n        0xFF, 0x40, 0x00, 0x00, 0x00, \n        0x00, 0x95, 0xEF, 0xBA, 0xAD, \n        0xF0, 0x0D, \n}; \n\nchar rx_buf[10] = {0,}; \nint ret; \nstruct spi_message single_msg; \nstruct spi_transfer single_xfer; \n\nsingle_xfer.tx_buf = tx_buf; \nsingle_xfer.rx_buf = rx_buf; \nsingle_xfer.len    = sizeof(tx_buff); \nsingle_xfer.bits_per_word = 8; \n\nspi_message_init(&msg); \nspi_message_add_tail(&xfer, &msg); \nret = spi_sync(spi, &msg); \n```", "```\nstruct { \n    char buffer[10]; \n    char cmd[2] \n    int foo; \n} data; \n\nstruct data my_data[3]; \ninitialize_date(my_data, ARRAY_SIZE(my_data)); \n\nstruct spi_transfer   multi_xfer[3]; \nstruct spi_message    single_msg; \nint ret; \n\nmulti_xfer[0].rx_buf = data[0].buffer; \nmulti_xfer[0].len = 5; \nmulti_xfer[0].cs_change = 1; \n/* command A */ \nmulti_xfer[1].tx_buf = data[1].cmd; \nmulti_xfer[1].len = 2; \nmulti_xfer[1].cs_change = 1; \n/* command B */ \nmulti_xfer[2].rx_buf = data[2].buffer; \nmulti_xfer[2].len = 10; \n\nspi_message_init(single_msg); \nspi_message_add_tail(&multi_xfer[0], &single_msg); \nspi_message_add_tail(&multi_xfer[1], &single_msg); \nspi_message_add_tail(&multi_xfer[2], &single_msg); \nret = spi_sync(spi, &single_msg); \n```", "```\nint spi_read(struct spi_device *spi, void *buf, size_t len) \nint spi_write(struct spi_device *spi, const void *buf, size_t len) \nint spi_write_then_read(struct spi_device *spi, \n        const void *txbuf, unsigned n_tx, \nvoid *rxbuf, unsigned n_rx) \n```", "```\nspidev@0x00 { \n    compatible = \"spidev\"; \n    spi-max-frequency = <800000>; /* It depends on your device */ \n    reg = <0>; /* correspond tochipselect 0 */ \n}; \n```", "```\n#include <stdio.h> \n#include <fcntl.h> \n#include <stdlib.h> \n\nint main(int argc, char **argv)  \n{ \n   int i,fd; \n   char wr_buf[]={0xff,0x00,0x1f,0x0f}; \n   char rd_buf[10];  \n\n   if (argc<2) { \n         printf(\"Usage:\\n%s [device]\\n\", argv[0]); \n         exit(1); \n   } \n\n   fd = open(argv[1], O_RDWR); \n   if (fd<=0) {  \n         printf(\"Failed to open SPI device %s\\n\",argv[1]); \n         exit(1); \n   } \n\n   if (write(fd, wr_buf, sizeof(wr_buf)) != sizeof(wr_buf)) \n         perror(\"Write Error\"); \n   if (read(fd, rd_buf, sizeof(rd_buf)) != sizeof(rd_buf)) \n         perror(\"Read Error\"); \n   else \n         for (i = 0; i < sizeof(rd_buf); i++) \n             printf(\"0x%02X \", rd_buf[i]); \n\n   close(fd); \n   return 0; \n} \n```", "```\n #include <stdint.h> \n #include <unistd.h> \n #include <stdio.h> \n #include <stdlib.h> \n #include <string.h> \n #include <fcntl.h> \n #include <sys/ioctl.h> \n #include <linux/types.h> \n #include <linux/spi/spidev.h> \nstatic int pabort(const char *s) \n{ \n    perror(s); \n    return -1; \n} \n\nstatic int spi_device_setup(int fd) \n{ \n    int mode, speed, a, b, i; \n    int bits = 8; \n\n    /* \n     * spi mode: mode 0 \n     */ \n    mode = SPI_MODE_0; \n    a = ioctl(fd, SPI_IOC_WR_MODE, &mode); /* write mode */ \n    b = ioctl(fd, SPI_IOC_RD_MODE, &mode); /* read mode */ \n    if ((a < 0) || (b < 0)) { \n        return pabort(\"can't set spi mode\"); \n    } \n\n    /* \n     * Clock max speed in Hz \n     */ \n    speed = 8000000; /* 8 MHz */ \n    a = ioctl(fd, SPI_IOC_WR_MAX_SPEED_HZ, &speed); /* Write speed */ \n    b = ioctl(fd, SPI_IOC_RD_MAX_SPEED_HZ, &speed); /* Read speed */ \n    if ((a < 0) || (b < 0)) { \n        return pabort(\"fail to set max speed hz\"); \n    } \n\n    /* \n     * setting SPI to MSB first.  \n     * Here, 0 means \"not to use LSB first\". \n     * In order to use LSB first, argument should be > 0 \n     */ \n    i = 0; \n    a = ioctl(dev, SPI_IOC_WR_LSB_FIRST, &i); \n    b = ioctl(dev, SPI_IOC_RD_LSB_FIRST, &i); \n    if ((a < 0) || (b < 0)) { \n        pabort(\"Fail to set MSB first\\n\"); \n    } \n\n    /* \n     * setting SPI to 8 bits per word \n     */ \n    bits = 8; \n    a = ioctl(dev, SPI_IOC_WR_BITS_PER_WORD, &bits); \n    b = ioctl(dev, SPI_IOC_RD_BITS_PER_WORD, &bits); \n    if ((a < 0) || (b < 0)) { \n        pabort(\"Fail to set bits per word\\n\"); \n    } \n\n    return 0; \n} \n```", "```\nstatic void do_transfer(int fd) \n{ \n    int ret; \n    char txbuf[] = {0x0B, 0x02, 0xB5}; \n    char rxbuf[3] = {0, }; \n    char cmd_buff = 0x9f; \n\n    struct spi_ioc_transfer tr[2] = { \n        0 = { \n            .tx_buf = (unsigned long)&cmd_buff, \n            .len = 1, \n            .cs_change = 1; /* We need CS to change */ \n            .delay_usecs = 50, /* wait after this transfer */ \n            .bits_per_word = 8, \n        }, \n        [1] = { \n            .tx_buf = (unsigned long)tx, \n            .rx_buf = (unsigned long)rx, \n            .len = txbuf(tx), \n            .bits_per_word = 8, \n        }, \n    }; \n\n    ret = ioctl(fd, SPI_IOC_MESSAGE(2), &tr); \n    if (ret == 1){ \n        perror(\"can't send spi message\"); \n        exit(1); \n    } \n\n    for (ret = 0; ret < sizeof(tx); ret++) \n        printf(\"%.2X \", rx[ret]); \n    printf(\"\\n\"); \n} \n\nint main(int argc, char **argv) \n{ \n    char *device = \"/dev/spidev0.0\"; \n    int fd; \n    int error; \n\n    fd = open(device, O_RDWR); \n    if (fd < 0) \n        return pabort(\"Can't open device \"); \n\n    error = spi_device_setup(fd); \n    if (error) \n        exit (1); \n\n    do_transfer(fd); \n\n    close(fd); \n    return 0; \n} \n```"]