- en: Filesystems and File I/O
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统和文件I/O
- en: 'Thus far we have traversed across the elemental resources of the kernel, such
    as address spaces, processor time, and physical memory. We have built an empirical
    understanding of *process management*, *CPU scheduling,* and *memory management*
    and the crucial abstractions they provide. We shall continue to build our understanding
    in this chapter by looking at another key abstraction provided by the kernel,
    the *file I/O architecture.* We will look in detail at aspects such as:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经遍历了内核的基本资源，如地址空间、处理器时间和物理内存。我们已经建立了对*进程管理*、*CPU调度*和*内存管理*的实证理解，以及它们提供的关键抽象。在本章中，我们将继续建立我们的理解，通过查看内核提供的另一个关键抽象，即*文件I/O架构*。我们将详细讨论以下方面：
- en: Filesystem implementation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统实现
- en: File I/O
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件I/O
- en: VFS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟文件系统（VFS）
- en: VFS data structures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VFS数据结构
- en: Special filesystems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊文件系统
- en: Computing systems exist for the sole purpose of processing data. Most algorithms
    are designed and programmed to extract desired information from acquired data.
    Data which fuels this process must be stored persistently for continuous access,
    mandating storage systems to be engineered to contain information safely for longer
    periods of time. For users however it's the operating system which fetches data
    from these storage devices and makes it available for processing. The kernel's
    filesystem is the component that serves this purpose.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 计算系统存在的唯一目的是处理数据。大多数算法都是设计和编程用来从获取的数据中提取所需的信息。驱动这一过程的数据必须持久地存储以便持续访问，这要求存储系统被设计为安全地包含信息以供更长时间的存储。然而，对于用户来说，是操作系统从这些存储设备中获取数据并使其可用于处理。内核的文件系统就是实现这一目的的组件。
- en: Filesystem - high-level view
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统 - 高层视图
- en: '**Filesystems** abstract the physical view of storage devices from users, and
    virtualize storage area on a disk for each valid user of the system through abstract
    containers called **files and directories**. **Files** serve as containers for
    user data and **directories** act as containers to a group of user files. In simple
    words, operating systems virtualize a view of a storage device for each user as
    a set of directories and files. Filesystem services implement routines to create,
    organize, store, and retrieve files, and these operations are invoked by user
    applications through appropriate system call interfaces.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件系统**将存储设备的物理视图与用户分离，并通过抽象容器**文件和目录**在磁盘上为系统的每个有效用户虚拟化存储区域。**文件**用作用户数据的容器，**目录**用作一组用户文件的容器。简单来说，操作系统为每个用户虚拟化存储设备的视图，以一组目录和文件的形式呈现。文件系统服务实现了创建、组织、存储和检索文件的例程，这些操作是由用户应用程序通过适当的系统调用接口调用的。'
- en: We will begin this discussion by looking at the layout of a simple filesystem,
    designed to manage a standard magnetic storage disk. This discussion will help
    us comprehend key terms and concepts related to disk management in general. A
    typical filesystem implementation however involves appropriate data structures
    which describe the organization of file data on disk, and operations which enable
    applications to execute file I/O.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看一个简单文件系统的布局开始，该文件系统设计用于管理标准磁存储盘。这个讨论将帮助我们理解与磁盘管理相关的关键术语和概念。然而，典型的文件系统实现涉及适当的数据结构，描述磁盘上文件数据的组织，以及使应用程序执行文件I/O的操作。
- en: Metadata
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元数据
- en: 'A storage disk typically is composed of physical blocks of identical size called
    **sectors**; size of a sector is usually 512 bytes or in multiples, depending
    on type and capacity of storage. A sector is the minimal unit of I/O on the disk.
    When a disk is presented to the filesystem for management, it perceives storage
    area as an array of **blocks** of fixed size, where each block is identical to
    a sector or multiples of sector size. Typical default block size is 1024 bytes
    and can vary as per disk capacity and filesystem type. Block size is considered
    the minimal unit of I/O by a filesystem:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 存储磁盘通常由相同大小的物理块组成，称为**扇区**；扇区的大小通常为512字节或其倍数，取决于存储类型和容量。扇区是磁盘上的最小I/O单元。当磁盘被呈现给文件系统进行管理时，它将存储区域视为一组固定大小的**块**，其中每个块与扇区或扇区大小的倍数相同。典型的默认块大小为1024字节，可以根据磁盘容量和文件系统类型而变化。块大小被认为是文件系统的最小I/O单元：
- en: '![](img/00031.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00031.jpeg)'
- en: Inode (index node)
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引节点（inode）
- en: 'The filesystem needs to maintain metadata to identify and track various attributes
    for each file and directory created by user. There are several elements of metadata
    that describe a file such as filename, type of file, last access timestamp, owner,
    access privileges, last modification timestamp, creation time, size of file data,
    and references to disk blocks containing file data. Conventionally, filesystems
    define a structure called inode to contain all metadata of a file. The size and
    type of information contained in inode is filesystem specific and may largely
    vary based on the functionalities it supports. Each inode is identified by a unique
    number referred to as an **index**, which is considered a low-level name of the
    file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统需要维护元数据来识别和跟踪用户创建的每个文件和目录的各种属性。有几个元数据元素描述了一个文件，如文件名、文件类型、最后访问时间戳、所有者、访问权限、最后修改时间戳、创建时间、文件数据大小以及包含文件数据的磁盘块的引用。传统上，文件系统定义了一个称为inode的结构来包含文件的所有元数据。inode中包含的信息的大小和类型是特定于文件系统的，并且根据其支持的功能而大不相同。每个inode都由一个称为**索引**的唯一编号来标识，这被认为是文件的低级名称：
- en: '![](img/00032.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00032.jpeg)'
- en: 'Filesystems reserve a few disk blocks for storing inode instances and the rest
    for storing corresponding file data. The number of blocks reserved for storing
    inodes depend on the storage capacity of the disk. The on-disk list of nodes held
    in inode blocks is referred to as the **inode table**. Filesystems would need
    to track the status of the inode and data blocks to identify free blocks. This
    is generally achieved through **bitmaps**, a bitmap for tracking free inodes and
    another to track free data blocks*.* The following diagram shows the typical layout
    with bitmap, inode, and data blocks:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统为存储inode实例保留了一些磁盘块，其余用于存储相应的文件数据。为存储inode保留的块数取决于磁盘的存储容量。inode块中保存的节点的磁盘列表称为**inode表**。文件系统需要跟踪inode和数据块的状态以识别空闲块。这通常通过**位图**来实现，一个用于跟踪空闲inode，另一个用于跟踪空闲数据块。以下图表显示了带有位图、inode和数据块的典型布局：
- en: '![](img/00033.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00033.jpeg)'
- en: Data block map
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据块映射
- en: 'As mentioned before, each inode should record the locations of data blocks
    in which corresponding file data is stored. Depending on the length of file data,
    each file might occupy *n* number of data blocks. There are various methods used
    to track data block details in an inode; the simplest being **direct references**,
    which involves the inode containing **direct pointers** to data blocks of the
    file. The number of such **direct pointers** would depend on filesystem design,
    and most implementations choose to engage fewer bytes for such pointers. This
    method is productive for small files which span across a few data blocks (usually
    < 16k), but lacks support for large files spread across numerous data blocks:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个inode都应记录相应文件数据存储在其中的数据块的位置。根据文件数据的长度，每个文件可能占用*n*个数据块。有各种方法用于跟踪inode中的数据块详细信息；最简单的是**直接引用**，它涉及inode包含指向文件数据块的**直接指针**。这种**直接指针**的数量取决于文件系统设计，大多数实现选择使用更少的字节来存储这些指针。这种方法对于跨越几个数据块（通常<16k）的小文件非常有效，但不支持跨越大量数据块的大文件：
- en: '![](img/00034.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00034.jpeg)'
- en: 'To support large files, filesystems engage an alternate method called **multi-level
    indexing** which involves indirect pointers. The simplest implementation would
    have an indirect pointer along with a few direct pointers in an inode structure.
    An **indirect pointer** refers to a block containing **direct pointers** to data
    blocks of the file. When a file grows too large to be referred through direct
    pointers of the inode, a free data block is engaged with direct pointers and the
    indirect pointer of the inode is referred to it. The data block referred to by
    an indirect pointer is called **indirect block**. The number of direct pointers
    in an indirect block can be determined by block size divided by the size of block
    addresses; for instance, on a 32-bit filesystem with 4-byte (32 bits) wide block
    addresses and 1024 block size, each indirect block can contain up to 256 entries,
    whereas in a 64-bit filesystem with 8-byte (64 bits) wide block addresses, each
    indirect block can contain up to 128 direct pointers:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持大文件，文件系统采用了一种称为**多级索引**的替代方法，其中包括间接指针。最简单的实现方式是在inode结构中有一个间接指针以及一些直接指针。**间接指针**指的是一个包含文件数据块的**直接指针**的块。当文件变得太大而无法通过inode的直接指针引用时，会使用一个空闲数据块来存储直接指针，并将inode的间接指针引用到它。间接指针引用的数据块称为**间接块**。间接块中直接指针的数量可以通过块大小除以块地址的大小来确定；例如，在32位文件系统上，每个间接块最多可以包含256个条目，而在64位文件系统上，每个间接块最多可以包含128个直接指针：
- en: '![](img/00035.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00035.jpeg)'
- en: This technique can be furthered to support even larger files by engaging a **double-indirect
    pointer,** which refers to a block containing indirect pointers with each entry
    referring to a block containing direct pointers**.** Assuming a 64-bit filesystem
    with 1024 block size, with each block accommodating 128 entries, there would be
    128 indirect pointers each pointing to a block holding 128 direct pointers; thus
    with this technique a filesystem can support a file that can span up to 16,384
    (128 x 128) data blocks, which is 16 MB.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可以进一步扩展以支持更大的文件，方法是使用**双重间接指针**，它指的是一个包含间接指针的块，每个条目都指向一个包含直接指针的块。假设一个64位文件系统，块大小为1024，每个块可以容纳128个条目，那么将有128个间接指针，每个指向一个包含128个直接指针的块；因此，通过这种技术，文件系统可以支持一个跨越多达16,384（128
    x 128）个数据块的文件，即16 MB。
- en: Further, this technique can be extended with a **triple-indirection pointer,**
    resulting in even more metadata to be managed by filesystems. However, despite
    of multi-level indexing**,** increasing filesystem block size with reduction in
    block address size is the most recommended and efficient solution to support larger
    files. Users will need to choose the appropriate block size while initializing
    a disk with a filesystem, to ensure proper support for larger files.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种技术可以通过**三级间接指针**进行扩展，从而需要文件系统管理更多的元数据。然而，尽管存在多级索引，但随着文件系统块大小的增加和块地址大小的减小，这是支持更大文件的最推荐和有效的解决方案。用户在初始化带有文件系统的磁盘时需要选择适当的块大小，以确保对更大文件的正确支持。
- en: Some filesystems use a different approach called extents to store data block
    information in an inode. An **extent** is a pointer that refers to the start data
    block (similar to that of a direct pointer) with added length bits that specify
    the count of contiguous blocks where file data is stored. Depending on file size
    and disk fragmentation levels, a single extent might not be sufficient to refer
    to all data blocks of the file, and to handle such eventualities, filesystems
    build **extent lists** with each extent referring to the start address and length
    of one region of contiguous data blocks on disk.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文件系统使用称为范围的不同方法来存储inode中的数据块信息。**范围**是一个指针，它指向开始数据块（类似于直接指针），并添加长度位，指定存储文件数据的连续块的计数。根据文件大小和磁盘碎片化水平，单个范围可能不足以引用文件的所有数据块，为处理这种情况，文件系统构建**范围列表**，每个范围引用磁盘上一个连续数据块区域的起始地址和长度。
- en: 'The extents approach reduces metadata that filesystems need to manage to store
    data block maps by a significant volume, but this is realized at the cost of flexibility
    in filesystem operations. For instance, consider a read operation to be performed
    at a specific file position of a large file: to locate a data block of specified
    file offset position, the filesystem must begin with the first extent and scan
    through the list until it finds the extent that covers the required file offset.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法减少了文件系统需要管理的元数据的数量，以存储数据块映射，但这是以文件系统操作的灵活性为代价实现的。例如，考虑要在大文件的特定文件位置执行读取操作：为了定位指定文件偏移位置的数据块，文件系统必须从第一个范围开始，并扫描列表，直到找到覆盖所需文件偏移的范围。
- en: Directories
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录
- en: 'Filesystems consider a directory as a special file. They represent a directory
    or a folder with an on-disk inode. They are differentiated from normal file inodes
    through the **type** field, which is marked as **directory**. Each directory is
    assigned data blocks where it holds information about files and subdirectories
    it contains. A directory maintains records of files, and each record includes
    the filename, which is a name string not exceeding a specific length as defined
    by the filesystem''s naming policy, and the inode number associated with the file.
    For efficient management, filesystem implementations define the layout of file
    records contained in a directory through appropriate data structures such as binary
    trees, lists, radix trees, and hash tables:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统将目录视为特殊文件。它们用磁盘上的inode表示目录或文件夹。它们通过**类型**字段与普通文件inode区分开来，该字段标记为**目录**。每个目录都分配了数据块，其中包含有关其包含的文件和子目录的信息。目录维护文件的记录，每个记录包括文件名，这是一个名字字符串，不超过文件系统命名策略定义的特定长度，以及与文件关联的inode号。为了有效管理，文件系统实现通过适当的数据结构（如二叉树、列表、基数树和哈希表）定义目录中包含的文件记录的布局：
- en: '![](img/00036.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00036.jpeg)'
- en: Superblock
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超级块
- en: 'Apart from storing inodes that captures metadata of individual files, filesystems
    also need to maintain metadata pertaining to disk volume as a whole, such as size
    of the volume, total block count, current state of filesystem, count of inode
    blocks, count of inodes, count of data blocks, start inode block number, and filesystem
    signature (magic number) for identity. These details are captured in a data structure
    called **superblock**. During initialization of filesystem on disk volume, the
    superblock is organized at start of disk storage. The following diagram illustrates
    the complete layout of disk storage with superblocks:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存储捕获各个文件元数据的inode之外，文件系统还需要维护有关整个磁盘卷的元数据，例如卷的大小、总块数、文件系统的当前状态、inode块数、inode数、数据块数、起始inode块号和文件系统签名（魔术数字）以进行身份验证。这些详细信息在一个称为**超级块**的数据结构中捕获。在磁盘卷上初始化文件系统期间，超级块被组织在磁盘存储的开始处。以下图示了带有超级块的磁盘存储的完整布局：
- en: '![](img/00037.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00037.jpeg)'
- en: Operations
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作
- en: While **data structures** make up elementary constituents of a filesystem design,
    the operations possible on those data structures to render file access and manipulation
    operations makes the core feature set. The number of operations and type of functionalities
    supported are filesystem implementation specific. Following is a generic description
    of a few common operations that most filesystems provide.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**数据结构**构成了文件系统设计的基本组成部分，但对这些数据结构可能进行的操作以实现文件访问和操作操作是核心功能集。支持的操作数量和功能类型是特定于文件系统实现的。以下是大多数文件系统提供的一些常见操作的通用描述。
- en: Mount and unmount operations
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂载和卸载操作
- en: '**Mount** is an operation of enumerating an on-disk superblock and metadata
    into memory for the filesystem''s use. This process creates in-memory data structures
    that describe file metadata and present the host operating system with a view
    of the directory and file layout in the volume. The mount operation is implemented
    to check consistency of disk volume. As discussed earlier, the **superblock**
    contains the state of the filesystem; it indicates whether the volume is *consistent*
    or *dirty*. If the volume is clean or consistent, a mount operation would succeed,
    and if the volume is marked as dirty or inconsistent, it returns with the appropriate
    failure status.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**挂载**是将磁盘上的超级块和元数据枚举到内存中供文件系统使用的操作。此过程创建描述文件元数据的内存数据结构，并向主机操作系统呈现卷中目录和文件布局的视图。挂载操作被实现为检查磁盘卷的一致性。如前所述，**超级块**包含文件系统的状态；它指示卷是*一致*还是*脏*。如果卷是干净或一致的，挂载操作将成功，如果卷被标记为脏或不一致，它将返回适当的失败状态。'
- en: An abrupt shutdown causes filesystem state to be dirty*,* and requires consistency
    check before it can be marked for use again*.* Mechanisms adopted for consistency
    checks are complex and time consuming; such operations are filesystem implementation
    specific, and most simple ones provide specific tools for consistency and checks,
    and other modern implementations use journaling.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 突然的关机会导致文件系统状态变得脏乱，并需要在可以再次标记为可用之前进行一致性检查。用于一致性检查的机制是复杂且耗时的；这些操作是特定于文件系统实现的，并且大多数简单的实现提供了特定的工具来进行一致性检查，而其他现代实现则使用了日志记录。
- en: '**Unmount** is an operation of flushing the in-memory state of filesystem data
    structures back to disk. This operation causes all metadata and file caches to
    be synchronized with disk blocks. Unmount marks the filesystem state in the superblock
    as consistent, indicating graceful shutdown. In other words, the on-disk superblock
    state remains dirty until unmount is executed.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 卸载是将文件系统数据结构的内存状态刷新回磁盘的操作。此操作导致所有元数据和文件缓存与磁盘块同步。卸载将文件系统状态标记为一致，表示优雅的关闭。换句话说，直到执行卸载操作，磁盘上的超级块状态仍然是脏的。
- en: File creation and deletion operations
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件创建和删除操作
- en: '**Creation** of a file is an operation that requires instantiation of a new
    inode with appropriate attributes. User programs invoke the file creation routine
    with chosen attributes such as filename, directory under which file is to be created,
    access permissions for various users, and file modes. This routine also initializes
    other specific fields of inode such as creation timestamp and file ownership information.
    This operation writes a new file record into the directory block, describing the
    filename and inode number.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文件是一个需要实例化具有适当属性的新inode的操作。用户程序使用选择的属性（如文件名、要创建文件的目录、各种用户的访问权限和文件模式）调用文件创建例程。此例程还初始化inode的其他特定字段，如创建时间戳和文件所有权信息。此操作将新的文件记录写入目录块，描述文件名和inode号。
- en: When a user application initiates a `delete` operation on a valid file, the
    filesystem removes the corresponding file record from the directory and checks
    the file's reference count to determine the number of processes currently using
    the file. Deletion of a file record from a directory prevents other processes
    from opening the file that is marked for deletion. When all current references
    to a file are closed, all resources assigned to the file are released by returning
    its data blocks to the list of free data blocks, and inode to list of free inodes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户应用程序对有效文件启动“删除”操作时，文件系统会从目录中删除相应的文件记录，并检查文件的引用计数以确定当前使用文件的进程数。从目录中删除文件记录会阻止其他进程打开标记为删除的文件。当所有对文件的当前引用都关闭时，通过将其数据块返回到空闲数据块列表和inode返回到空闲inode列表来释放分配给文件的所有资源。
- en: File open and close operations
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件打开和关闭操作
- en: When a user process attempts to open a file, it invokes the `open` operation
    of the filesystem with appropriate arguments, which include path and name of the
    file. The filesystem traverses through directories specified in the path until
    it reaches the immediate parent directory that contains the requested file's record.
    Lookup into the file record produces the inode number of the specified file. However,
    specific logic and efficiency of lookup operation depends on the data structure
    chosen by the particular filesystem implementation for organizing file records
    in a directory block.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户进程尝试打开一个文件时，它使用文件系统的“打开”操作和适当的参数，包括文件的路径和名称。文件系统遍历路径中指定的目录，直到它到达包含所请求文件记录的直接父目录。查找文件记录产生了指定文件的inode号。然而，查找操作的具体逻辑和效率取决于特定文件系统实现选择的用于组织目录块中文件记录的数据结构。
- en: Once the filesystem retrieves the related inode number of the file, it initiates
    appropriate sanity checks to enforce access control validation on the calling
    context. If the caller process is cleared for file access, the filesystem then
    instantiates an in-memory structure called **file descriptor** to maintain file
    access state and attributes. Upon successful completion, the open operation returns
    the reference of the file descriptor structure to the caller process, which serves
    as a handle to the file for the caller process to initiate other file operations
    such as `read`, `write`, and `close`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件系统检索到文件的相关inode号，它会启动适当的健全性检查来强制执行对调用上下文的访问控制验证。如果调用进程被授权访问文件，文件系统会实例化一个称为“文件描述符”的内存结构，以维护文件访问状态和属性。成功完成后，打开操作将文件描述符结构的引用返回给调用进程，这将作为调用进程启动其他文件操作（如“读取”、“写入”和“关闭”）的句柄。
- en: Upon initiating a `close` operation, the file descriptor structure is destroyed
    and the file's reference count is decremented. The caller process will no longer
    be able to initiate any other file operation until it can open the file all over
    again.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动“关闭”操作时，文件描述符结构被销毁，文件的引用计数被减少。调用进程将无法再启动任何其他文件操作，直到它可以重新打开文件。
- en: File read and write operations
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件读写操作
- en: When user applications initiate *read* on a file with appropriate arguments,
    the underlying filesystem's `read` routine is invoked. Operations begin with a
    lookup into the file's data block map to locate the appropriate data disk sector
    to be read; it then allocates a page from the page cache and schedules disk I/O.
    On completion of I/O transfer, the filesystem moves requested data into the application's
    buffer and updates the file offset position in the caller's file descriptor structure.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户应用程序使用适当的参数启动对文件的读取时，底层文件系统的“读取”例程会被调用。操作从文件的数据块映射中查找适当的数据磁盘扇区以进行读取；然后它从页面缓存中分配一个页面并安排磁盘I/O。在I/O传输完成后，文件系统将请求的数据移入应用程序的缓冲区并更新调用者文件描述符结构中的文件偏移位置。
- en: Similarly, the `write` operation of the filesystem retrieves data passed from
    user buffer and writes it into the appropriate offset of file buffer in the page
    cache, and marks the page with the `PG*_*dirty` flag. However, when the `write`
    operation is invoked to append data at the end of the file, new data blocks might
    be required for the file to grow. The filesystem looks for free data blocks on
    disk, and allocates them for this file, before proceeding with *write*. Allocating
    new data blocks would need changes to the inode structure's data block map and
    allocation of new page(s) from page cache mapped to the new data blocks allocated.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，文件系统的“写”操作从用户缓冲区中检索数据，并将其写入页面缓存中文件缓冲区的适当偏移量，并标记页面为“PG*_*dirty”标志。然而，当“写”操作被调用以在文件末尾追加数据时，文件可能需要新的数据块来增长。文件系统在磁盘上寻找空闲数据块，并为该文件分配这些数据块，然后进行*写*操作。分配新的数据块需要更改索引节点结构的数据块映射，并分配新页面（从页面缓存映射到新分配的数据块）。
- en: Additional features
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加功能
- en: Though the fundamental components of a filesystem remain similar, the way data
    is organized and the heuristics to access data is implementation dependent. Designers
    consider factors such as **reliability**, **security**, **type** and **capacity
    of storage volume**, and **I/O efficiency** to identify and support features that
    enhance capabilities of a filesystem. Following are few extended features that
    are supported by modern filesystems.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管文件系统的基本组件保持相似，但数据组织方式和访问数据的启发式方法取决于实现。设计者考虑因素，如**可靠性**、**安全性**、**存储容量的类型**和**容量**，以及**I/O效率**，以识别和支持增强文件系统功能的特性。以下是现代文件系统支持的一些扩展功能。
- en: Extended file attributes
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展文件属性
- en: General file attributes tracked by a filesystem implementation are maintained
    in an inode and interpreted by appropriate operations. Extended file attributes
    are a feature that enables users to define custom metadata for a file, which is
    not interpreted by the filesystem. Such attributes are often used to store various
    types of information which depend on the type of data the file contains. For instance,
    document files can define the author name and contact details, web files can specify
    URL of the file and other security-related attributes such as digital certificates
    and crypto hash keys. Similar to normal attributes, each extended attribute is
    identified by a **name** and a **value**. Ideally*,* most filesystems do not impose
    restrictions on the number of such extended attributes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统实现跟踪的一般文件属性保存在索引节点中，并由适当的操作进行解释。扩展文件属性是一项功能，使用户能够为文件定义文件系统不解释的自定义元数据。这些属性通常用于存储各种类型的信息，这些信息取决于文件包含的数据类型。例如，文档文件可以定义作者姓名和联系方式，Web文件可以指定文件的URL和其他安全相关属性，如数字证书和加密哈希密钥。与普通属性类似，每个扩展属性都由**名称**和**值**标识。理想情况下，大多数文件系统不会对此类扩展属性的数量施加限制。
- en: Some filesystems also provide a facility of **indexing** the attributes, which
    aids in quick lookup for required type of data without having to navigate file
    hierarchy. For instance, assume that files are assigned with an extended attribute
    called **Keywords***,* which records keyword values that describe file data. With
    indexing, the user could issue queries to find the list of files matching specific
    keywords through appropriate scripts, regardless of the file's location. Thus,
    indexing offers a powerful alternative interface to the filesystem.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文件系统还提供了**索引**属性的功能，这有助于快速查找所需类型的数据，而无需导航文件层次结构。例如，假设文件被分配了一个名为**Keywords***的扩展属性，记录描述文件数据的关键字值。通过索引，用户可以发出查询，通过适当的脚本找到匹配特定关键字的文件列表，而不管文件的位置如何。因此，索引为文件系统提供了一个强大的替代界面。
- en: Filesystem consistency and crash recovery
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统的一致性和崩溃恢复
- en: '**Consistency** of an on-disk image is critical for reliable functioning of
    a filesystem. While the filesystem is in the process of updating its on-disk structures,
    there is every possibility for a catastrophic error to occur (power down, OS crash,
    and so on), causing interruption of a partially committed critical update. This
    results in corruption of on-disk structures and leaves the filesystem in an inconsistent
    state. Dealing with such eventualities, by engaging an effective strategy for
    crash recovery, is one of the major challenges faced by most filesystem designers.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘映像的一致性对文件系统的可靠运行至关重要。当文件系统正在更新其磁盘结构时，很有可能会发生灾难性错误（断电、操作系统崩溃等），导致部分提交的关键更新中断。这会导致磁盘结构损坏，并使文件系统处于不一致状态。通过采用有效的崩溃恢复策略来处理这种情况，是大多数文件系统设计者面临的主要挑战之一。
- en: 'Some filesystems handle crash recovery through a specially designed filesystem
    consistency check tool like **fsck** (a widely used Unix tool). It is run at system
    boot before mount and scans through on-disk filesystem structures looking for
    inconsistencies, and fixes them when found. Once finished, the on-disk filesystem
    state is reverted to a consistent state and the system proceeds with the `mount`
    operation, thus making the disk accessible to users. The tool executes its operations
    in a number of phases, closely checking for consistency of each on-disk structure
    such as superblock, inode block, free blocks, checking individual inodes for valid
    state, directory checks, and bad block check in each phase. Though it provides
    much-needed crash recovery, it has its downsides: such phased operations can consume
    a lot of time to complete on a large disk volume, which directly impacts the system''s
    boot time.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文件系统通过专门设计的文件系统一致性检查工具（如广泛使用的Unix工具fsck）处理崩溃恢复。它在挂载之前在系统启动时运行，并扫描磁盘上的文件系统结构，寻找不一致之处，并在找到时修复它们。完成后，磁盘上的文件系统状态将恢复到一致状态，并且系统将继续进行`mount`操作，从而使磁盘对用户可访问。该工具在许多阶段执行其操作，密切检查每个磁盘结构的一致性，如超级块、inode块、空闲块，在每个阶段检查单个inode的有效状态、目录检查和坏块检查。尽管它提供了必要的崩溃恢复，但它也有其缺点：这些分阶段的操作可能会消耗大量时间来完成对大容量磁盘的操作，这直接影响系统的启动时间。
- en: '**Journaling** is another technique engaged by most modern filesystem implementations
    for quick and reliable crash recovery. This method is enforced by programming
    appropriate filesystem operations for crash recovery. The idea is to prepare a
    **log** (note) listing out changes to be committed to the on-disk image of the
    filesystem, and writing the log to a special disk block called a **journal block**,
    before beginning the actual update operation*.* This ensures that on a crash during
    actual update, the filesystem can easily detect inconsistencies and fix them by
    looking through information recorded in the log*.* Thus, an implementation of
    journaling filesystem eliminates the need for the tedious and expensive task of
    disk scan, by marginally extending work done during an update.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**日志**是大多数现代文件系统实现采用的另一种技术，用于快速和可靠的崩溃恢复。这种方法是通过为崩溃恢复编程适当的文件系统操作来实施的。其思想是准备一个列出要提交到文件系统的磁盘映像的更改的**日志**（注意），并将日志写入一个称为**日志块**的特殊磁盘块，然后开始实际的更新操作。这确保在实际更新期间发生崩溃时，文件系统可以轻松地检测到不一致之处，并通过查看日志中记录的信息来修复它们。因此，日志文件系统的实现通过在更新期间边缘地扩展工作来消除了对磁盘扫描的繁琐和昂贵的任务。'
- en: Access control lists (ACLs)
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问控制列表（ACL）
- en: The default file and directory access permissions that specify access rights
    for the owner, the group to which owner belongs, and others users does not offer
    fine-grained control required in some situations. ACLs are a feature that enable
    an extended mechanism to specify file access permissions for various processes
    and users. This feature considers all files and directories as objects, and allows
    system administrators to define a list of access permissions for each. ACLs include
    operations valid on an object with access privileges, and restrictions for each
    user and system process on a specified object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 默认文件和目录访问权限指定了所有者、所有者所属的组和其他用户的访问权限，但在某些情况下并不能提供所需的细粒度控制。ACL是一种功能，它可以为各种进程和用户指定文件访问权限的扩展机制。此功能将所有文件和目录视为对象，并允许系统管理员为每个对象定义访问权限列表。ACL包括对具有访问权限的对象的操作，以及对指定对象上的每个用户和系统进程的限制。
- en: Filesystems in the Linux kernel
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux内核中的文件系统
- en: 'Now that we are familiar with fundamental concepts related to filesystem implementations,
    we will explore filesystem services supported by Linux systems. The kernel''s
    filesystem branch has implementations of numerous filesystem services, which support
    diverse file types. Based on the type of files they manage, the kernel''s filesystems
    can be broadly categorized into:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了与文件系统实现相关的基本概念，我们将探讨Linux系统支持的文件系统服务。内核的文件系统分支具有许多文件系统服务的实现，支持各种文件类型。根据它们管理的文件类型，内核的文件系统可以被广泛分类为：
- en: Storage filesystems
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储文件系统
- en: Special filesystems
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特殊文件系统
- en: Distributed filesystems or network filesystems
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分布式文件系统或网络文件系统
- en: We shall discuss special filesystems in a later section of this chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后面部分讨论特殊文件系统。
- en: '**Storage filesystems**: Kernel supports various persistent storage filesystems,
    which can be broadly categorized into various groups based on the type of storage
    device they are designed to manage.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储文件系统**：内核支持各种持久存储文件系统，可以根据它们设计用于管理的存储设备类型进行广泛分类。'
- en: '**Disk filesystems**: This category includes various standard storage disk
    filesystems supported by the kernel, which includes the Linux native ext family
    of disk filesystems, such as Ext2, Ext3, Ext4, ReiserFS, and Btrfs; Unix variants
    such as the sysv filesystem, UFS, and MINIX filesystem; Microsoft filesystems
    such as MS-DOS, VFAT, and NTFS; other proprietary filesystems such as IBM''s OS/2
    (HPFS), Qnx based filesystems such as qnx4 and qnx6, Apple''s Macintosh HFS and
    HFS2, Amiga''s Fast Filesystem (AFFS), and Acorn Disk Filing System (ADFS); and
    journaling filesystems like IBM''s JFS and SGI''s XFS.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁盘文件系统**：此类别包括内核支持的各种标准存储磁盘文件系统，包括Linux本机ext系列磁盘文件系统，如Ext2、Ext3、Ext4、ReiserFS和Btrfs；类Unix变体，如sysv文件系统、UFS和MINIX文件系统；微软文件系统，如MS-DOS、VFAT和NTFS；其他专有文件系统，如IBM的OS/2（HPFS）、基于Qnx的文件系统，如qnx4和qnx6，苹果的Macintosh
    HFS和HFS2，Amiga的快速文件系统（AFFS）和Acorn磁盘文件系统（ADFS）；以及IBM的JFS和SGI的XFS等日志文件系统。'
- en: '**Removable media filesystems**: This category includes filesystems designed
    for CD, DVD, and other movable storage media devices, such as the ISO9660 CD-ROM
    filesystem and Universal Disk Format (UDF) DVD filesystem, and squashfs used in
    live CD images for Linux distributions.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移动媒体文件系统**：此类别包括为CD、DVD和其他可移动存储介质设备设计的文件系统，如ISO9660 CD-ROM文件系统和通用磁盘格式（UDF）DVD文件系统，以及用于Linux发行版的live
    CD映像中使用的squashfs。'
- en: '**Semiconductor storage filesystems**: This category includes filesystems designed
    and implemented for raw flash and other semiconductor storage devices that require
    support of wear-leveling and erase operations. The current set of filesystems
    supported include UBIFS, JFFS2, CRAMFS, and so on.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半导体存储文件系统**：此类别包括为原始闪存和其他需要支持磨损平衡和擦除操作的半导体存储设备设计和实现的文件系统。当前支持的文件系统包括UBIFS、JFFS2、CRAMFS等。'
- en: We shall discuss in brief a few native disk filesystems in the kernel, which
    are used across various distributions of Linux as default.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要讨论内核中几种本机磁盘文件系统，这些文件系统在Linux的各个发行版中作为默认文件系统使用。
- en: Ext family filesystems
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ext家族文件系统
- en: The initial release of the Linux kernel used MINIX as the default native filesystem,
    which was designed for use in the Minix kernel for educational purposes and hence
    had many usage limitations. As the kernel matured, kernel developers built a new
    native filesystem for disk management called the **extended filesystem***.* The
    design of *ext* was heavily influenced by the standard Unix filesystem UFS. Due
    to various implementation limitations and lack of efficiency, the original ext
    was short lived and was soon replaced by an improved, stable, and efficient version
    named **second extended filesystem** (**Ext2**)*.* The Ext2 filesystem continued
    to be the default native filesystem for quite a long period of time (until 2001,
    with the 2.4.15 release of the Linux kernel).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核的初始版本使用MINIX作为默认的本机文件系统，它是为教育目的而设计用于Minix内核，因此有许多使用限制。随着内核的成熟，内核开发人员构建了一个用于磁盘管理的新本机文件系统，称为**扩展文件系统***.*
    *ext*的设计受到标准Unix文件系统UFS的重大影响。由于各种实现限制和缺乏效率，原始的ext寿命很短，很快被一个改进的、稳定的、高效的版本所取代，名为**第二扩展文件系统**（**Ext2**）*.*
    Ext2文件系统在相当长的一段时间内一直是默认的本机文件系统（直到2001年，Linux内核的2.4.15版本）。
- en: Later, rapid evolution in disk storage technologies led to a massive increase
    in storage capacity and efficiency of storage hardware. To exploit features provided
    by storage hardware, the kernel community evolved forks of *ext2* with appropriate
    design improvements and added features that are best suitable for a specific class
    of storage. Current versions of the Linux kernel contain three versions of extended
    filesystems, called Ext2, Ext3, and Ext4.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，磁盘存储技术的快速发展大大增加了存储容量和存储硬件的效率。为了利用存储硬件提供的功能，内核社区发展了*ext2*的分支，进行了适当的设计改进，并添加了最适合特定存储类别的功能。当前的Linux内核版本包含三个扩展文件系统的版本，称为Ext2、Ext3和Ext4。
- en: Ext2
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ext2
- en: The Ext2 filesystem was first introduced in kernel version 0.99.7 (1993). It
    retains the core design of classic UFS (Unix filesystem) with write-back caching,
    which enables short turnaround time and improved performance. Although it was
    implemented to support disk volumes in the range of 2 TB to 32 TB and file sizes
    in the range of 16 GB to 2 TB, its usage was restricted for up to 4 TB disk volumes
    and 2 GB max file sizes due to block device and application imposed restrictions
    in 2.4 kernels. It also includes support for ACLs, file memory maps, and crash
    recovery through the consistency checker tool fsck. Ext2 divides physical disk
    sectors into fixed-size block groups. A filesystem layout is constructed for each
    block group, with each having a complete superblock, free block bitmap, inode
    bitmap, inode, and data blocks. Thus, each block group appears as a miniature
    filesystem. This design assists *fsck* with faster consistency checks on a large
    disk.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Ext2文件系统首次出现在内核版本0.99.7（1993年）中。它保留了经典UFS（Unix文件系统）的核心设计，具有写回缓存，可以实现短的周转时间和改进的性能。尽管它被实现为支持2
    TB到32 TB范围内的磁盘卷和16 GB到2 TB范围内的文件大小，但由于2.4内核中的块设备和应用程序施加的限制，其使用仅限于最多4 TB的磁盘卷和最大2
    GB的文件大小。它还包括对ACL、文件内存映射和通过一致性检查工具fsck进行崩溃恢复的支持。Ext2将物理磁盘扇区划分为固定大小的块组。为每个块组构建文件系统布局，每个块组都有一个完整的超级块、空闲块位图、inode位图、inode和数据块。因此，每个块组都像一个微型文件系统。这种设计有助于*fsck*在大型磁盘上进行更快的一致性检查。
- en: Ext3
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ext3
- en: Also called **third extended filesystem**, it extends the functionality of Ext2
    with journaling. It retains the entire structure of Ext2 with block groups, which
    enables seamless conversion of an Ext2 partition into an Ext3 type. As discussed
    earlier, journaling causes the filesystem to log details of an update operation
    into specific regions of disk called journal blocks; these logs help expedite
    crash recovery and ensure consistency and reliability of the filesystem. However,
    on journaling filesystems, disk update operations can turn expensive due to slower
    or variable-time write operations (due to journal log) which would directly impact
    performance of regular file I/O. As a solution, Ext3 provides journal configuration
    options through which system administrators or users can select specific types
    of information to be logged to a journal. These configuration options are referred
    to as **journaling modes**.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为**第三扩展文件系统**，它通过日志记录扩展了Ext2的功能。它保留了Ext2的整个结构，包括块组，这使得可以无缝地将Ext2分区转换为Ext3类型。如前所述，日志记录会导致文件系统将更新操作的详细信息记录到磁盘的特定区域，称为日志块；这些日志有助于加快崩溃恢复，并确保文件系统的一致性和可靠性。然而，在具有日志记录的文件系统上，由于较慢或可变时间的写操作（由于日志记录），磁盘更新操作可能变得昂贵，这将直接影响常规文件I/O的性能。作为解决方案，Ext3提供了日志配置选项，通过这些选项，系统管理员或用户可以选择要记录到日志的特定类型的信息。这些配置选项称为**日志模式**。
- en: '**Journal mode**: This mode causes the filesystem to record both file data
    and metadata changes into the journal. This results in maximized filesystem consistency
    with increased disk access, causing slower updates. This mode causes the journal
    to consume additional disk blocks and is the slowest Ext3 journaling mode.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**日志模式**：此模式导致文件系统将文件数据和元数据更改记录到日志中。这会导致文件系统一致性最大化，但会导致磁盘访问增加，从而导致更新速度变慢。此模式会导致日志消耗额外的磁盘块，是最慢的Ext3日志模式。'
- en: '**Ordered mode**: This mode records only filesystem metadata into the journal,
    but it guarantees that related file data is written to disk before associated
    metadata is committed to the journal block. This ensures that file data is valid;
    if a crash occurs while executing write to a file, the journal will indicate that
    the appended data has not been committed, resulting in a purge operation on such
    data by the cleanup process. This is the default journaling mode of Ext3.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**有序模式**：此模式仅将文件系统元数据记录到日志中，但它保证相关文件数据在提交到日志块之前写入磁盘。这确保文件数据是有效的；如果在执行对文件的写入时发生崩溃，日志将指示附加的数据尚未提交，导致清理过程对此类数据进行清除。这是Ext3的默认日志模式。'
- en: '**Writeback mode**: This is similar to ordered mode with only metadata journaling,
    but with an exception that the related file contents might be written to disk
    before or after the metadata is committed to journal. This can result in corruption
    of filedata. For example, consider a file being appended to may be marked in the
    journal as *committed* before actual file write: if a crash occurs during the
    file append operation, then the journal suggests the file being larger than it
    actually is. This mode is fastest but minimizes file data reliability. Many other
    journaling filesystems such as JFS uses this mode of journaling, but ensure that
    any *garbage* due to unwritten data is zeroed out on reboot.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**写回模式**：这类似于有序模式，只进行元数据日志记录，但有一个例外，即相关文件内容可能在提交到日志之前或之后写入磁盘。这可能导致文件数据损坏。例如，考虑正在追加的文件可能在日志中标记为*已提交*，然后进行实际文件写入：如果在文件追加操作期间发生崩溃，那么日志会建议文件比实际大小要大。这种模式速度最快，但最大程度地减少了文件数据的可靠性。许多其他日志文件系统（如JFS）使用这种日志模式，但确保任何由于未写入数据而产生的*垃圾*在重新启动时被清零。'
- en: All of these modes have a similar effect with respect to the consistency of
    metadata, but differ in consistency of file and directory data, with journal mode
    ensuring maximum safety with minimal chance of file data corruption, and writeback
    mode offering minimal safety with high risk of corruption. Administrators or users
    can tune the appropriate mode during mount operation on an Ext3 volume.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些模式在元数据一致性方面具有类似的效果，但在文件和目录数据的一致性方面有所不同，日志模式确保最大安全性，最小的文件数据损坏风险，而写回模式提供最小的安全性，但存在高风险的损坏。管理员或用户可以在挂载Ext3卷时调整适当的模式。
- en: Ext4
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ext4
- en: Implemented as a replacement to Ext3 with enhanced features, Ext4 first appeared
    in kernel 2.6.28 (2008). It is fully backward compatible with Ext2 and Ext3, and
    a volume of either type can be mounted as Ext4\. This is the default ext filesystem
    on most current Linux distributions. It extends journaling capabilities of Ext3
    with **journal checksums** which increases its reliability. It also adds checksums
    for filesystem metadata and supports transparent encryption, resulting in enhanced
    filesystem integrity and security. Other features include support for extents*,*
    which help reduce fragmentation, persistent preallocation of disk blocks, which
    enables allocation of contiguous blocks for media files, and support for disk
    volumes with storage capacities up to 1 exbibyte (EiB[)](https://en.wikipedia.org/wiki/Exbibyte)
    and files with sizes up to 16 tebibytes (TiB).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对具有增强功能的Ext3的替代实现，Ext4首次出现在内核2.6.28（2008）中。它与Ext2和Ext3完全向后兼容，可以将任一类型的卷挂载为Ext4。这是大多数当前Linux发行版上的默认ext文件系统。它通过**日志校验和**扩展了Ext3的日志功能，增加了其可靠性。它还为文件系统元数据添加了校验和，并支持透明加密，从而增强了文件系统的完整性和安全性。其他功能包括支持*范围*，有助于减少碎片化，磁盘块的持久性预分配，可以为媒体文件分配连续的块，以及支持存储容量高达1艾比特（EiB）和文件大小高达16泰比特（TiB）的磁盘卷。
- en: Common filesystem interface
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见文件系统接口
- en: Presence of diverse filesystems and storage partitions results in each filesystem
    maintaining its tree of files and data structures that are distinct from others.
    Upon mount, each filesystem will require to manage its in-memory file trees in
    isolation from others, resulting in an inconsistent view of the file tree for
    system users and applications. This complicates kernel support for various file
    operations such as open, read, write, copy, and move. As a solution, the Linux
    kernel (like many other Unix systems) engages an abstraction layer called **virtual
    file system (VFS)** that hides all filesystem implementations with a common interface.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多种文件系统和存储分区导致每个文件系统维护其文件树和数据结构，这些结构与其他文件系统不同。在挂载时，每个文件系统将需要独立管理其内存中的文件树，与其他文件系统隔离，从而为系统用户和应用程序提供文件树的不一致视图。这使得内核对各种文件操作（如打开、读取、写入、复制和移动）的支持变得复杂。作为解决方案，Linux内核（与许多其他Unix系统一样）使用了一个称为**虚拟文件系统（VFS）**的抽象层，它隐藏了所有文件系统实现，并提供了一个通用接口。
- en: The VFS layer builds a common file tree called **rootfs**, under which all filesystems
    can enumerate their directories and files. This enables all filesystem-specific
    subtrees with distinct on-disk representations to be unified and presented as
    a single filesystem. System users and applications have a consistent, homogeneous
    view of the file tree, resulting in flexibility for the kernel to define a simplified
    set of common system calls that applications can engage for file I/O, regardless
    of underlying filesystems and their representations. This model ensures simplicity
    in application design due to limited and flexible APIs and enables seamless copy
    or movement of files from one disk partition or filesystem tree to another, irrespective
    of underlying dissimilarities.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: VFS层构建了一个称为**rootfs**的通用文件树，在此之下，所有文件系统都可以列举其目录和文件。这使得所有特定于文件系统的子树都可以统一并呈现为单个文件系统。系统用户和应用程序对文件树有一致的、统一的视图，从而使内核能够为应用程序提供一组简化的常见系统调用，用于文件I/O，而不考虑底层文件系统及其表示。这种模型确保了应用程序设计的简单性，因为API有限且灵活，并且可以无缝地从一个磁盘分区或文件系统树复制或移动文件到另一个，而不考虑底层的差异。
- en: 'The following diagram depicts the virtual filesystem:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了虚拟文件系统：
- en: '![](img/00038.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: 'VFS defines two sets of functions: first, a set of generic filesystem-independent
    routines that serve as common entry functions for all file access and manipulation
    operations, and second, a set of abstract operation interfaces that are filesystem
    specific. Each filesystem defines its operations (as per its notion of files and
    directories) and maps them to an abstract interface provided, and with the virtual
    filesystem, this enables VFS to handle file I/O requests by dynamically switching
    into underlying filesystem-specific functions.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: VFS定义了两组函数：首先是一组通用的与文件系统无关的例程，用作所有文件访问和操作操作的通用入口函数，其次是一组抽象操作接口，这些接口是特定于文件系统的。每个文件系统定义其操作（根据其文件和目录的概念）并将它们映射到提供的抽象接口，并且通过虚拟文件系统，这使得VFS能够通过动态切换到底层文件系统特定函数来处理文件I/O请求。
- en: VFS structures and operations
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VFS结构和操作
- en: 'Deciphering the key objects and data structures of VFS lets us gain clarity
    on how the VFS internally works with filesystems and enables the all-important
    abstraction. Following are four elemental data structures around which the entire
    web of abstraction is weaved:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 解密VFS的关键对象和数据结构让我们清楚地了解VFS如何与文件系统内部工作，并实现了至关重要的抽象。以下是围绕整个抽象网络编织的四个基本数据结构：
- en: '`struct super_block`--which contains information on specific filesystems that
    have been mounted'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct super_block`--包含已挂载的特定文件系统的信息'
- en: '`struct inode`--which represents a specific file'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct inode`--代表特定文件'
- en: '`struct dentry`--representing a directory entry'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct dentry`--代表目录条目'
- en: '`struct file`--representing the file which has been opened and linked to a
    process'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct file`--代表已打开并链接到进程的文件'
- en: All of these data structures are bound to appropriate abstract operation interfaces
    that are defined by filesystems.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数据结构都与由文件系统定义的适当的抽象操作接口绑定。
- en: struct superblock
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: struct superblock
- en: 'VFS defines a generic layout for the superblock through this structure. Each
    filesystem would need to instantiate an object of this structure to fill in its
    superblock details during mount. In other words, this structure abstracts the
    filesystem-specific superblock from the rest of the kernel, and helps VFS track
    all mounted filesystems through a list of `struct super_block`. Pseudo filesystems,
    which do not have persistent superblock structure, will dynamically generate superblocks.
    The superblock structure (`struct super_block`) is defined in `<linux/fs.h>`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: VFS通过此结构为超级块定义了通用布局。每个文件系统都需要实例化此结构的对象，在挂载期间填充其超级块详细信息。换句话说，此结构将文件系统特定的超级块与内核的其余部分抽象出来，并帮助VFS通过`struct
    super_block`列表跟踪所有已挂载的文件系统。没有持久超级块结构的伪文件系统将动态生成超级块。超级块结构（`struct super_block`）在`<linux/fs.h>`中定义：
- en: '[PRE0]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The superblock structure contains other structures which define and extend
    the information and functionalities of the superblock. Following are some of the
    elements of `super_block`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 超级块结构包含其他定义和扩展超级块信息和功能的结构。以下是`super_block`的一些元素：
- en: '`s_list` is of type `struct list_head` and contains pointers to the list of
    mounted superblocks'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s_list`是`struct list_head`类型的，包含指向已挂载超级块列表的指针'
- en: '`s_dev` is the device identifier'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s_dev`是设备标识符'
- en: '`s_maxbytes` contains the maximum file size'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s_maxbytes`包含最大文件大小'
- en: '`s_type` is a pointer of type `struct file_system_type`, which describes the
    filesystem type'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s_type`是`struct file_system_type`类型的指针，描述了文件系统类型'
- en: '`s_op` is a pointer of type `struct super_operations`, containing operations
    on the superblock'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s_op`是`struct super_operations`类型的指针，包含对超级块的操作'
- en: '`s_export_op` is of type `struct export_operations` and helps the filesystem
    be exportable for remote systems to access, using network filesystems'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s_export_op`是`struct export_operations`类型的，帮助文件系统可以被远程系统访问，使用网络文件系统进行导出'
- en: '`s_root` is a pointer of type `struct dentry` and points to the dentry object
    of the filesystem''s root directory'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s_root`是`struct dentry`类型的指针，指向文件系统根目录的dentry对象'
- en: 'Each enumerated superblock instance contains a pointer to an abstract structure
    of function pointers that define the interface for superblock operations. Filesystems
    will need to implement their superblock operations and assign them to appropriate
    function pointers. This helps each filesystem implement superblock operations
    as per its layout of on-disk superblock and hide that logic under a common interface.
    `Struct super_operations` is defined in `<linux/fs.h>`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个枚举的超级块实例都包含一个指向定义超级块操作接口的函数指针抽象结构的指针。文件系统将需要实现其超级块操作并将其分配给适当的函数指针。这有助于每个文件系统根据其磁盘上超级块的布局实现超级块操作，并将该逻辑隐藏在一个公共接口下。`Struct
    super_operations`在`<linux/fs.h>`中定义：
- en: '[PRE1]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'All elements in this structure point to functions that operate on the superblock
    object. All these operations are only called from a process context and without
    any locks being held, unless specified. Let''s look at few important ones here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构中的所有元素都指向对超级块对象进行操作的函数。除非另有说明，否则所有这些操作都仅在进程上下文中调用，且不持有任何锁。让我们来看看这里的一些重要操作：
- en: '`alloc_inode`: This method is used to create and allocate space for the new
    inode object and initialize it under the superblock.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alloc_inode`：此方法用于创建和分配新的inode对象的空间，并在超级块下初始化它。'
- en: '`destroy_inode`: This destroys the given inode object and frees resources allocated
    for the inode. This is only used if `alloc_inode` was defined.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroy_inode`：销毁给定的inode对象并释放为inode分配的资源。仅在定义了`alloc_inode`时使用。'
- en: '`dirty_inode`: This is called by the VFS to mark a dirty inode (when inode
    is modified).'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dirty_inode`：VFS调用此函数标记脏inode（当inode被修改时）。'
- en: '`write_inode`: VFS invokes this method when it needs to write an inode on to
    the disk. The second argument points to `struct writeback_control`, a structure
    that tells the writeback code what to do.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write_inode`：当VFS需要将inode写入磁盘时，会调用此方法。第二个参数指向`struct writeback_control`，这是一个告诉写回代码该做什么的结构。'
- en: '`put_super`: This is invoked when VFS needs to free the superblock.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put_super`：当VFS需要释放超级块时调用此函数。'
- en: '`sync_fs`: This is invoked to synchronize filesystem data with that of the
    underlying block device.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync_fs`: 用于将文件系统数据与底层块设备的数据同步。'
- en: '`statfs`: Invoked to get filesystem statistics for the VFS.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`statfs`: 用于获取VFS的文件系统统计信息。'
- en: '`remount_fs`: Invoked when the filesystem needs to be remounted.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remount_fs`: 当文件系统需要重新挂载时调用。'
- en: '`umount_begin`: Invoked when the VFS is unmounting a filesystem.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`umount_begin`: 当VFS卸载文件系统时调用。'
- en: '`show_options`: Invoked by VFS to show mount options.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show_options`: 由VFS调用以显示挂载选项。'
- en: '`quota_read`: Invoked by VFS to read from the filesystem quota file.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quota_read`: 由VFS调用以从文件系统配额文件中读取。'
- en: struct inode
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构inode
- en: 'Each instance of `struct inode` represents a file in `rootfs`. VFS defines
    this structure as an abstraction for filesystem-specific inodes. Irrespective
    of the type of inode structure and its representation on disk, each filesystem
    needs to enumerate its files as `struct inode` into `rootfs` for a common file
    view. This structure is defined in `<linux/fs.h>`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`struct inode`实例都代表`rootfs`中的一个文件。VFS将此结构定义为特定于文件系统的inode的抽象。无论inode结构的类型和其在磁盘上的表示如何，每个文件系统都需要将其文件枚举为`rootfs`中的`struct
    inode`，以获得一个通用的文件视图。此结构在`<linux/fs.h>`中定义：
- en: '[PRE2]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that all fields are not mandatory and applicable to all filesystems; they
    are free to initialize appropriate fields that are relevant as per their definition
    of an inode. Each inode is bound to two important groups of operations defined
    by the underlying filesystem: first, a set of operations to manage inode data.
    These are represented through an instance of type `struct inode_operations` that
    is referred to by the `i_op` pointer of the inode. Second is a group of operations
    for accessing and manipulating underlying file data that the inode represents;
    these operations are encapsulated in an instance of type `struct file_operations`
    and bound to the `i_fop` pointer of inode instance.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有字段都是强制性的，并且适用于所有文件系统；它们可以初始化适当的字段，这些字段根据它们对inode的定义而相关。每个inode都绑定到由底层文件系统定义的两个重要操作组：首先，一组操作来管理inode数据。这些通过`struct
    inode_operations`的实例表示，并由inode的`i_op`指针引用。其次是一组用于访问和操作inode所代表的底层文件数据的操作；这些操作封装在`struct
    file_operations`的实例中，并绑定到inode实例的`i_fop`指针。
- en: 'In other words, each inode is bound to metadata operations represented by an
    instance of type struct `inode_operations`, and file data operations represented
    by an instance of type `struct file_operations`. However, user-mode applications
    access file data operations from a valid `file` object created to represent an
    open file for the caller process (we will discuss more on file object in next
    section):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，每个inode都绑定到由类型为`struct inode_operations`的实例表示的元数据操作，以及由类型为`struct file_operations`的实例表示的文件数据操作。但是，用户模式应用程序从用于表示调用方进程的打开文件的有效`file`对象访问文件数据操作（我们将在下一节中更多讨论文件对象）：
- en: '[PRE3]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Following is a brief description of few important operations:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要操作的简要描述：
- en: '`lookup`: Used to locate inode instance of the file specified; this operation
    returns a dentry instance.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`查找`: 用于定位指定文件的inode实例；此操作返回一个dentry实例。'
- en: '`create`: This routine is invoked by VFS to construct an inode object for dentry
    specified as an argument.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create`: VFS调用此例程以为指定的dentry构造一个inode对象。'
- en: '`link`: Used to support hard links. Called by the `link(2)` system call.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`link`: 用于支持硬链接。由`link(2)`系统调用调用。'
- en: '`unlink`: Used to support deleting inodes. Called by the `unlink(2)` system
    call.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unlink`: 用于支持删除inode。由`unlink(2)`系统调用调用。'
- en: '`mkdir`: Used to support creation of subdirectories. Called by the `mkdir(2)`
    system call.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mkdir`: 用于支持创建子目录。由`mkdir(2)`系统调用调用。'
- en: '`mknod`: Invoked by the `mknod(2)` system call to create a device, named pipe,
    inode, or socket.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mknod`: 由`mknod(2)`系统调用调用以创建设备、命名管道、inode或套接字。'
- en: '`listxattr`: Invoked by the VFS to list all extended attributes of a file.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`listxattr`: 由VFS调用以列出文件的所有扩展属性。'
- en: '`update_time`: Invoked by the VFS to update a specific time or the `i_version`
    of the inode.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_time`: 由VFS调用以更新特定时间或inode的`i_version`。'
- en: 'The following is VFS-defined `struct file_operations`, which encapsulates filesystem-defined
    operations on the underlying file data. Since this is declared to serve as a common
    interface for all filesystems, it contains function pointer interfaces suitable
    to support operations on various types of filesystems with distinct definitions
    of file data. Underlying filesystems are free to choose appropriate interfaces
    and leave the rest, depending on their notion of file and file data:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是VFS定义的`struct file_operations`，它封装了底层文件数据上的文件系统定义操作。由于这被声明为所有文件系统的通用接口，它包含适合支持各种类型文件系统上操作的函数指针接口，这些文件系统具有不同的文件数据定义。底层文件系统可以选择适当的接口并留下其余部分，这取决于它们对文件和文件数据的概念：
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Following is a brief description of a few important operations:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要操作的简要描述：
- en: '`llseek`: Invoked when the VFS needs to move the file position index.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llseek`: 当VFS需要移动文件位置索引时调用。'
- en: '`read`: Invoked by `read(2)` and other related system calls.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read`: 由`read(2)`和其他相关系统调用调用。'
- en: '`write`: Invoked by the `write(2)` and other related system calls.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write`: 由`write(2)`和其他相关系统调用调用。'
- en: '`iterate`: Invoked when VFS needs to read directory contents.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterate`: 当VFS需要读取目录内容时调用。'
- en: '`poll`: This is invoked by the VFS when a process needs to check for activity
    on the file. Called by `select(2)` and `poll(2)` system calls.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poll`: 当进程需要检查文件上的活动时，VFS调用此例程。由`select(2)`和`poll(2)`系统调用调用。'
- en: '`unlocked_ioctl`: The operation assigned to this pointer is invoked when the
    user-mode process calls the `ioctl(2)` system call on the file descriptor. This
    function is used to support special operations. Device drivers use this interface
    to support configuration operations on the target device.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unlocked_ioctl`: 当用户模式进程调用文件描述符上的`ioctl(2)`系统调用时，将调用分配给此指针的操作。此函数用于支持特殊操作。设备驱动程序使用此接口来支持目标设备上的配置操作。'
- en: '`compat_ioctl`: Similar to ioctl with an exception that it is used to convert
    arguments passed from a 32-bit process to be used with a 64-bit kernel.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compat_ioctl`：类似于ioctl，但有一个例外，它用于将从32位进程传递的参数转换为与64位内核一起使用。'
- en: '`mmap`: The routine assigned to this pointer is invoked when the user-mode
    process calls the `mmap(2)` system call. Functionality supported by this function
    is underlying filesystem dependent. For regular persistent files, this function
    is implemented to map the caller-specified data region of the file into the virtual
    address space of the caller process. For device files that support `mmap`, this
    routine maps underlying device address space into the caller''s virtual address
    space.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mmap`：当用户模式进程调用`mmap(2)`系统调用时，分配给此指针的例程将被调用。此函数支持的功能取决于底层文件系统。对于常规持久文件，此函数被实现为将文件的调用者指定的数据区域映射到调用者进程的虚拟地址空间。对于支持`mmap`的设备文件，此例程将底层设备地址空间映射到调用者的虚拟地址空间。'
- en: '`open`: The function assigned to this interface is invoked by VFS when the
    user-mode process initiates the `open(2)` system call to create a file descriptor.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open`：当用户模式进程启动`open(2)`系统调用以创建文件描述符时，VFS将调用分配给此接口的函数。'
- en: '`flush`: Invoked by the `close(2)` system call to flush a file.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flush`：由`close(2)`系统调用调用以刷新文件。'
- en: '`release`: A function assigned to this interface is invoked by VFS when a user-mode
    process executes the close(2) system call to destroy a file descriptor.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release`：当用户模式进程执行`close(2)`系统调用销毁文件描述符时，VFS将调用分配给此接口的函数。'
- en: '`fasync`: Invoked by the `fcntl(2)` system call when asynchronous mode is enabled
    for a file.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fasync`：当文件启用异步模式时，由`fcntl(2)`系统调用调用。'
- en: '`splice_write`: Invoked by the VFS to splice data from a pipe to a file.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`splice_write`：由VFS调用以将数据从管道拼接到文件。'
- en: '`setlease`: Invoked by the VFS to set or release a file lock lease.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setlease`：由VFS调用以设置或释放文件锁定租约。'
- en: '`fallocate`: Invoked by the VFS to pre-allocate a block.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fallocate`：由VFS调用以预分配一个块。'
- en: Struct dentry
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构dentry
- en: In our earlier discussion, we gained an understanding on how a typical disk
    filesystem represents each directory through an `inode` structure, and how a directory
    block on disk represents information of files under that directory. When user-mode
    applications initiate file access operations such as `open()` with a complete
    path such as `/root/test/abc` *,* the VFS will need to perform directory lookup
    operations to decode and validate each component specified in the path.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的讨论中，我们了解了典型磁盘文件系统如何通过`inode`结构表示每个目录，以及磁盘上的目录块如何表示该目录下文件的信息。当用户模式应用程序发起诸如`open()`之类的文件访问操作时，需要使用完整路径（例如`/root/test/abc`），VFS将需要执行目录查找操作来解码和验证路径中指定的每个组件。
- en: For efficient lookup and translation of components in a file path, VFS enumerates
    a special data structure, called `dentry`. A dentry object contains a string `name`
    of the file or directory, a pointer to its `inode`, and a pointer to the parent
    `dentry`. An instance of dentry is generated for each component in the file lookup
    path; for instance, in the case of `/root/test/abc`, a dentry is enumerated for
    `root`, another for `test`*,* and finally for file `abc`*.*
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了高效查找和转换文件路径中的组件，VFS枚举了一个特殊的数据结构，称为`dentry`。dentry对象包含文件或目录的字符串`name`，指向其`inode`的指针以及指向父`dentry`的指针。对于文件查找路径中的每个组件，都会生成一个dentry实例；例如，在`/root/test/abc`的情况下，会为`root`生成一个dentry，为`test`生成另一个dentry，最后为文件`abc`生成一个dentry。
- en: '`struct dentry` is defined in kernel header `</linux/dcache.h>`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct dentry`在内核头文件`</linux/dcache.h>`中定义：'
- en: '[PRE5]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`d_parent` is pointer to the parent dentry instance.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d_parent`是指向父dentry实例的指针。'
- en: '`d_name` holds the name of the file.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d_name`保存文件的名称。'
- en: '`d_inode` is a pointer to the inode instance of the file.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d_inode`是文件的inode实例的指针。'
- en: '`d_flags` contains several flags defined in `<include/linux/dcache.h>.`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d_flags`包含在`<include/linux/dcache.h>`中定义的几个标志。'
- en: '`d_op` points to the structure containing function pointers to various operations
    for the dentry object.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d_op`指向包含dentry对象的各种操作的函数指针的结构。'
- en: 'Let''s now look at `struct dentry_operations`, which describes how a filesystem
    can overload the standard dentry operations:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`struct dentry_operations`，它描述了文件系统如何重载标准的dentry操作：
- en: '[PRE6]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Following is a brief description of a few important dentry operations:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些重要的dentry操作的简要描述：
- en: '`d_revalidate`: Invoked when VFS needs to revalidate a dentry. Whenever a name
    lookup returns a dentry in the dcache, this is called.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d_revalidate`：当VFS需要重新验证dentry时调用。每当名称查找返回dcache中的一个dentry时，就会调用此操作。'
- en: '`d_weak_revalidate`: Invoked when VFS needs to revalidate a jumped dentry.
    This is invoked if a path-walk ends at a dentry that wasn''t found on a lookup
    on the parent directory.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d_weak_revalidate`：当VFS需要重新验证跳转的dentry时调用。如果路径遍历结束于在父目录查找中未找到的dentry，则会调用此操作。'
- en: '`d_hash`: Invoked when VFS adds a dentry to the hash table.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d_hash`：当VFS将dentry添加到哈希表时调用。'
- en: '`d_compare`: Invoked to compare the filenames of two dentry instances. It compares
    a dentry name with a given name.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d_compare`：用于比较两个dentry实例的文件名。它将一个dentry名称与给定名称进行比较。'
- en: '`d_delete`: Invoked when the last reference to a dentry is removed.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d_delete`：当最后一个对dentry的引用被移除时调用。'
- en: '`d_init`: Invoked when a dentry is allocated.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d_init`：当分配dentry时调用。'
- en: '`d_release`: Invoked when a dentry is deallocated.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d_release`：当dentry被释放时调用。'
- en: '`d_iput`: Invoked when an inode is released from the dentry.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d_iput`：当inode从dentry中释放时调用。'
- en: '`d_dname`: Invoked when the pathname of the dentry must be generated. Handy
    for special filesystems to delay pathname generation (whenever the path is needed).'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d_dname`：当必须生成dentry的路径名时调用。对于特殊文件系统来说，延迟路径名生成（每当需要路径时）非常方便。'
- en: struct file
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件结构
- en: An instance of `struct fil*e*` represents an open file. This structure is created
    when a user process successfully opens a file, and contains the caller application's
    file access attributes such as offset into file data, access mode, and special
    flags, among others. This object is mapped to the caller's file descriptor table,
    and serves as the caller application's handle to the file. This structure is local
    to the process and is retained by a process until the relevant file is closed.
    A `close` operation on the file descriptor destroys the `file` instance.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '- `struct file`的一个实例代表一个打开的文件。当用户进程成功打开一个文件时，将创建这个结构，并包含调用应用程序的文件访问属性，如文件数据的偏移量、访问模式和特殊标志等。这个对象被映射到调用者的文件描述符表，并作为调用者应用程序对文件的处理。这个结构是进程本地的，并且在相关文件关闭之前一直由进程保留。对文件描述符的`close`操作会销毁`file`实例。'
- en: '[PRE7]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `f_inode` pointer refers to the inode instance of the file. When a file
    object is constructed by VFS, the `f_op` pointer is initialized with the address
    of `struct file_operations` associated with the file's inode, as we discussed
    earlier.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '- `f_inode`指针指向文件的inode实例。当VFS构造文件对象时，`f_op`指针会初始化为与文件的inode相关联的`struct file_operations`的地址，正如我们之前讨论的那样。'
- en: Special filesystems
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '- 特殊文件系统'
- en: Unlike regular filesystems, which are designed to manage persistent file data
    backed on to a storage device, the kernel implements various special filesystems
    that manage a specific class of kernel in-core data structures. Since these filesystems
    do not deal with persistent data, they do not consume disk blocks, and the entire
    filesystem structure is maintained in-core. Presence of such filesystems enables
    simplified application development, debugging, and easier error detection. There
    are many filesystems in this category, each deliberately designed and implemented
    for a specific purpose. Following is brief description of a few important ones.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '- 与设计用于管理存储在存储设备上的持久文件数据的常规文件系统不同，内核实现了各种特殊文件系统，用于管理特定类别的内核内核数据结构。由于这些文件系统不处理持久数据，它们不会占用磁盘块，并且整个文件系统结构都保持在内核中。这些文件系统的存在使应用程序开发、调试和错误检测变得更加简化。在这个类别中有许多文件系统，每个都是为特定目的而故意设计和实现的。以下是一些重要文件系统的简要描述。'
- en: Procfs
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '- Procfs'
- en: '**Procfs** is a special filesystem that enumerates kernel data structures as
    files. This filesystem serves as a debugging resource for kernel programmers,
    since it allows users to view the state of data structures through the virtual
    file interface. Procfs is mounted to the `/proc` directory (mount point) of rootfs.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '- **Procfs**是一个特殊的文件系统，它将内核数据结构枚举为文件。这个文件系统作为内核程序员的调试资源，因为它允许用户通过虚拟文件接口查看数据结构的状态。Procfs被挂载到根文件系统的`/proc`目录（挂载点）上。'
- en: Data in procfs files is not persistent, and is always constructed on the run;
    each file is an interface through which users can trigger associated operations.
    For instance, a read operation on a proc file invokes the associated read callback
    function bound to the file entry, and that function is implemented to populate
    the user buffer with appropriate data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '- procfs文件中的数据不是持久的，而是在运行时构造的；每个文件都是一个接口，用户可以通过它触发相关操作。例如，对proc文件的读操作会调用与文件条目绑定的读回调函数，并且该函数被实现为用适当的数据填充用户缓冲区。'
- en: 'The number of files enumerated depends on the configuration and architecture
    for which the kernel was built. Following is a list of a few important files with
    useful data enumerated under `/proc`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '- 枚举的文件数量取决于内核构建的配置和架构。以下是一些重要文件的列表，这些文件在`/proc`下枚举了有用的数据：'
- en: '| **File name** | **Description** |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '- **文件名** | **描述**'
- en: '| `/proc/cpuinfo` | Provides low-level cpu details such as vendor, model, clock
    speed, cache size, number of siblings, cores, CPU flags, and bogomips. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '- `/proc/cpuinfo`：提供低级CPU详细信息，如供应商、型号、时钟速度、缓存大小、兄弟姐妹的数量、核心、CPU标志和bogomips。'
- en: '| `/proc/meminfo` | Provides a summarized view of physical memory state. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '- `/proc/meminfo`：提供物理内存状态的摘要视图。'
- en: '| `/proc/ioports` | Provides details on current usage of port I/O address space
    supported by the x86 class of machines. This file is not present on other architectures.
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '- `/proc/ioports`：提供由x86类机器支持的端口I/O地址空间的当前使用情况的详细信息。此文件在其他架构上不存在。'
- en: '| `/proc/iomem` | Shows a detailed layout describing current usage of memory
    address space. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '- `/proc/iomem`：显示描述内存地址空间当前使用情况的详细布局。'
- en: '| `/proc/interrupts` | Shows a view of the IRQ descriptor table that contains
    details of IRQ lines and interrupt handlers bound to each. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '- `/proc/interrupts`：显示包含IRQ线路和绑定到每个中断处理程序的中断处理程序的详细信息的IRQ描述符表的视图。'
- en: '| `/proc/slabinfo` | Shows a detailed listing of slab caches and their current
    state. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '- `/proc/slabinfo`：显示slab缓存及其当前状态的详细列表。'
- en: '| `/proc/buddyinfo` | Shows the current state of buddy lists managed by the
    buddy system. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '- `/proc/buddyinfo`：显示由伙伴系统管理的伙伴列表的当前状态。'
- en: '| `/proc/vmstat` | Shows virtual memory management statistics. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '- `/proc/vmstat`：显示虚拟内存管理统计信息。'
- en: '| `/proc/zoneinfo` | Shows per-node memory zone statistics. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '- `/proc/zoneinfo`：显示每个节点的内存区域统计信息。'
- en: '| `/proc/cmdline` | Shows boot arguments passed to the kernel. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '- `/proc/cmdline`：显示传递给内核的引导参数。'
- en: '| `/proc/timer_list` | Shows a list of active pending timers, with details
    of clock source. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '- `/proc/timer_list`：显示活动挂起定时器的列表，以及时钟源的详细信息。'
- en: '| `/proc/timer_stats` | Provides detailed statistics on active timers, used
    for tracking timer usage and debugging. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '- `/proc/timer_stats`：提供有关活动定时器的详细统计信息，用于跟踪定时器的使用和调试。'
- en: '| `/proc/filesystems` | Presents a list of filesystem services currently active.
    |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '- `/proc/filesystems`：呈现当前活动的文件系统服务列表。'
- en: '| `/proc/mounts` | Shows currently mounted devices with their mountpoints.
    |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '- `/proc/mounts`：显示当前挂载的设备及其挂载点。'
- en: '| `/proc/partitions` | Presents details of current storage partitions detected
    with associated /dev file enumerations. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '- `/proc/partitions`：呈现检测到的当前存储分区的详细信息，带有相关的/dev文件枚举。'
- en: '| `/proc/swaps` | Lists out active swap partitions with status details. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '- `/proc/swaps`：列出具有状态详细信息的活动交换分区。'
- en: '| `/proc/modules` | Lists out names and status of kernel modules currently
    deployed. |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/modules` | 列出当前部署的内核模块的名称和状态。 |'
- en: '| `/proc/uptime` | Shows length of time kernel has been running since boot
    and spent in idle mode. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/uptime` | 显示自启动以来内核运行的时间长度和空闲模式下的时间。 |'
- en: '| `/proc/kmsg` | Shows contents of kernel''s message log buffer. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/kmsg` | 显示内核消息日志缓冲区的内容。 |'
- en: '| `/proc/kallsyms` | Presents kernel symbol table. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/kallsyms` | 显示内核符号表。 |'
- en: '| `/proc/devices` | Presents a list of registered block and character devices
    with their major numbers. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/devices` | 显示已注册的块设备和字符设备及其主要编号的列表。 |'
- en: '| `/proc/misc` | Presents a list of devices registered through the misc interface
    with their misc identifiers. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/misc` | 显示通过misc接口注册的设备及其misc标识符的列表。 |'
- en: '| `/proc/stat` | Presents system statistics. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/stat` | 显示系统统计信息。 |'
- en: '| `/proc/net` | Directory that contains various network stack-related pseudo
    files. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/net` | 包含各种与网络堆栈相关的伪文件的目录。 |'
- en: '| `/proc/sysvipc` | Subdirectory containing pseudo files that show the status
    of System V IPC objects, message queues, semaphores, and shared memory. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/sysvipc` | 包含伪文件的子目录，显示System V IPC对象、消息队列、信号量和共享内存的状态。 |'
- en: '`/proc` also lists out a number of subdirectories that provide a detailed view
    of elements in process PCB or task structure. These folders are named by the PID
    of the process that they represent. Following is a list of important files that
    present process-related information:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc`还列出了许多子目录，提供了进程PCB或任务结构中元素的详细视图。这些文件夹以它们所代表的进程的PID命名。以下是一些重要文件的列表，这些文件提供了与进程相关的信息：'
- en: '| File name | Description |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 文件名 | 描述 |'
- en: '| `/proc/pid/cmdline` | Command-line name of the process. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/pid/cmdline` | 进程的命令行名称。 |'
- en: '| `/proc/pid/exe` | A symbolic link to the executable file. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/pid/exe` | 可执行文件的符号链接。 |'
- en: '| `/proc/pid/environ` | Lists out environmental variables accessible to the
    process. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/pid/environ` | 列出进程可访问的环境变量。 |'
- en: '| `/proc/pid/cwd` | A symbolic link to the current working directory of the
    process. |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/pid/cwd` | 指向进程当前工作目录的符号链接。 |'
- en: '| `/proc/pid/mem` | A binary image that shows the virtual memory of the process.
    |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/pid/mem` | 显示进程的虚拟内存的二进制图像。 |'
- en: '| `/proc/pid/maps` | Lists out virtual memory mappings for the process. |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/pid/maps` | 列出进程的虚拟内存映射。 |'
- en: '| `/proc/pid/fdinfo` | A directory that lists out open file descriptors'' current
    status and flags. |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/pid/fdinfo` | 列出打开文件描述符的当前状态和标志的目录。 |'
- en: '| `/proc/pid/fd` | Directory that contains symlink to open file descriptors.
    |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/pid/fd` | 包含指向打开文件描述符的符号链接的目录。 |'
- en: '| `/proc/pid/status` | Lists out current status of the process, including its
    memory usage. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/pid/status` | 列出进程的当前状态，包括其内存使用情况。 |'
- en: '| `/proc/pid/sched` | Lists out scheduling statistics. |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/pid/sched` | 列出调度统计信息。 |'
- en: '| `/proc/pid/cpuset` | Lists out the cpu affinity mask for this process. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/pid/cpuset` | 列出此进程的CPU亲和性掩码。 |'
- en: '| `/proc/pid/cgroup` | Shows cgroup details for the process. |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/pid/cgroup` | 显示进程的cgroup详细信息。 |'
- en: '| `/proc/pid/stack` | Shows backtrace of the process-owned kernel stack. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/pid/stack` | 显示进程拥有的内核堆栈的回溯。 |'
- en: '| `/proc/pid/smaps` | Shows memory consumed for each mapping into its address
    space. |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/pid/smaps` | 显示每个映射到其地址空间的内存消耗。 |'
- en: '| `/proc/pid/pagemap` | Shows the physical mapping status for each virtual
    page of the process. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/pid/pagemap` | 显示进程每个虚拟页面的物理映射状态。 |'
- en: '| `/proc/pid/syscall` | Exposes the system call number and arguments for the
    system call currently being executed by the process. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/pid/syscall` | 显示当前由进程执行的系统调用的系统调用号和参数。 |'
- en: '| `/proc/pid/task` | Directory containing child process/thread details. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/pid/task` | 包含子进程/线程详细信息的目录。 |'
- en: These listings were drawn up to familiarize you with proc files and their use.
    You are advised to visit the manual page of procfs for a detailed description
    of each of these files.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这些列表是为了让您熟悉proc文件及其用法。建议您查阅procfs的手册页面，详细了解这些文件的每个描述。
- en: All of the files we listed so far are read-only; procfs also contains a branch
    `/proc/sys` that holds read-write files, which are referred to as kernel parameters.
    Files under `/proc/sys` are further classified as per the subsystems to which
    they apply. Listing out all those files is out of scope.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们列出的所有文件都是只读的；procfs还包含一个名为`/proc/sys`的分支，其中包含读写文件，这些文件被称为内核参数。`/proc/sys`下的文件根据其适用的子系统进一步分类。列出所有这些文件超出了范围。
- en: Sysfs
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sysfs
- en: '**Sysfs** is another pseudo filesystem that is introduced to export unified
    hardware and driver information to user mode. It enumerates information about
    devices and associated device drivers from the kernel''s device model perspective
    to user space through virtual files. Sysfs is mounted to the /sys directory (mount
    point) of the `rootfs`. Similar to procfs, underlying drivers and kernel subsystems
    can be configured for power management and other functionalities through virtual
    file interfaces of sysfs. Sysfs also enables hotplug event management by Linux
    distros through appropriate daemons such as **udev**, which is configured to listen
    and respond to hotplug events.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sysfs**是另一个伪文件系统，用于向用户模式导出统一的硬件和驱动程序信息。它通过虚拟文件从内核设备模型的角度向用户空间枚举有关设备和相关设备驱动程序的信息。Sysfs被挂载到`rootfs`的/sys目录（挂载点）。与procfs类似，底层驱动程序和内核子系统可以通过sysfs的虚拟文件接口进行电源管理和其他功能的配置。Sysfs还通过适当的守护程序（如**udev**）使Linux发行版能够进行热插拔事件管理，并配置为监听和响应热插拔事件。'
- en: 'Following is a brief description of important subdirectories of sysfs:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是sysfs的重要子目录的简要描述：
- en: '**Devices**: One of the objectives behind the introduction of sysfs is to present
    a unified list of devices currently enumerated and managed by respective driver
    subsystems. The devices directory contains the global device hierarchy, which
    contains information for each physical and virtual device that has been discovered
    by the driver subsystems and registered with the kernel.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备**：引入sysfs的目标之一是提供当前由各自驱动程序子系统枚举和管理的设备的统一列表。设备目录包含全局设备层次结构，其中包含每个由驱动程序子系统发现并注册到内核的物理和虚拟设备的信息。'
- en: '**BUS**: This directory contains a listing of subdirectories, each representing
    the physical bus type that has support registered in the kernel. Each bus type
    directory contains two subdirectories: `devices` and `drivers`. The `devices`
    directory contains a listing of devices currently discovered or bound to that
    bus type. Each file in the listing is a symbolic link to the device file in device''s
    directory in the global device tree. The `drivers` directory contains directories
    describing each device driver registered with the bus manager. Each of the driver
    directories lists out attributes that show the current configuration of driver
    parameters, which can be modified, and symbolic links that point to the physical
    device directory that the driver is bound to.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总线**：此目录包含子目录的列表，每个子目录代表内核中支持的物理总线类型。每个总线类型目录包含两个子目录：`devices`和`drivers`。`devices`目录包含当前发现或绑定到该总线类型的设备的列表。列表中的每个文件都是指向全局设备树中设备目录中的设备文件的符号链接。`drivers`目录包含描述与总线管理器注册的每个设备驱动程序的目录。每个驱动程序目录列出显示驱动程序参数的当前配置的属性，这些参数可以被修改，并且包含指向驱动程序绑定到的物理设备目录的符号链接。'
- en: '**Class**: The `class` directory contains representations of device classes
    that are currently registered with the kernel. A device class describes a functional
    type of device. Each device class directory contains subdirectories representing
    devices currently allocated and registered under this class. For most of the class
    device objects, their directories contain symbolic links to the device and driver
    directories in the global device hierarchy and the bus hierarchy that are associated
    with that class object.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：`class`目录包含当前在内核中注册的设备类的表示。设备类描述了设备的功能类型。每个设备类目录包含表示当前分配和注册在该类下的设备的子目录。对于大多数类设备对象，它们的目录包含到与该类对象相关联的全局设备层次结构和总线层次结构中的设备和驱动程序目录的符号链接。'
- en: '**Firmware**: The `firmware` directory contains interfaces for viewing and
    manipulating platform-specific firmware that is run during power on/reset, such
    as BIOS or UEFI on x86 and OpenFirmware for PPC platforms.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**固件**：`firmware`目录包含用于查看和操作在开机/复位期间运行的特定于平台的固件的接口，例如x86平台上的BIOS或UEFI和PPC平台上的OpenFirmware。'
- en: '**Modules**: This directory contains subdirectories that represent each kernel
    module currently deployed. Each directory is enumerated with the name of the module
    it is representing. Each module directory contains information about a module
    such as refcount, modparams, and its core size.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块**：此目录包含代表当前部署的每个内核模块的子目录。每个目录都用所代表的模块的名称进行枚举。每个模块目录包含有关模块的信息，例如引用计数、模块参数和其核心大小。'
- en: Debugfs
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Debugfs
- en: Unlike procfs and sysfs, which are implemented to present specific information
    through the virtual file interface, *debugfs* is a generic memory filesystem that
    allows kernel developers to export any arbitrary information that is deemed useful
    for debugging. Debugfs provides function interfaces used to enumerate virtual
    files and is generally mounted to the `/sys/debug` directory. Debugfs is used
    by tracing mechanisms such as ftrace to present function and interrupt traces.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 与procfs和sysfs不同，它们是通过虚拟文件接口实现呈现特定信息的，*debugfs*是一个通用的内存文件系统，允许内核开发人员导出任何被认为对调试有用的任意信息。Debugfs提供用于枚举虚拟文件的函数接口，并通常挂载到`/sys/debug`目录。Debugfs被跟踪机制（如ftrace）用于呈现函数和中断跟踪。
- en: There are many other special filesystems such as pipefs, mqueue, and sockfs;
    we shall touch upon a few of them in later chapters.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他特殊的文件系统，如pipefs、mqueue和sockfs；我们将在后面的章节中涉及其中的一些。
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Through this chapter, we have gained a generic understanding of a typical filesystem,
    its fabric and design, and what makes it an elemental part of an operating system.
    This chapter also emphasizes the importance and elegance of abstraction, using
    the common, layered architecture design which the kernel comprehensively imbibes.
    We have also stretched our understanding of the VFS and its common file interface
    that facilitates the common file API and its internal structures. In the next
    chapter, we will shall explore another facet of memory management called a virtual
    memory manager that deals with process virtual address spaces and page tables.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们对典型文件系统及其结构和设计有了一般的了解，以及它是操作系统的基本组成部分的原因。本章还强调了抽象的重要性和优雅，使用了内核全面吸收的常见、分层的架构设计。我们还扩展了对VFS及其通用文件接口的理解，该接口促进了通用文件API及其内部结构。在下一章中，我们将探索内存管理的另一个方面，称为虚拟内存管理器，它处理进程虚拟地址空间和页表。
