- en: '*Chapter 3*: Delving into the MFD Subsystem and Syscon API'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：深入研究MFD子系统和Syscon API'
- en: The increasingly dense integration of devices has led to a kind of device that
    is made up of several other devices or IPs that can achieve a dedicated function.
    With the advent of this device, a new subsystem appeared in the Linux kernel.
    These are **MFDs**, which stands for **multi-function devices**. These devices
    are physically seen as standalone devices, but from a software point of view,
    these are represented in a parent-child relationship, where the children are subdevices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设备的日益密集集成导致了一种由多个其他设备或IP组成的设备，可以实现专用功能。随着这种设备的出现，Linux内核中出现了一个新的子系统。这些是**MFDs**，代表**多功能设备**。这些设备在物理上看起来是独立的设备，但从软件角度来看，它们在父子关系中表示，其中子设备是子设备。
- en: While some I2C- and SPI-based devices/subdevices might need either some hacks
    or configurations prior to being added to the system, there are also MMIO-based
    devices/subdevices where zero conf/hacks are required as they just need to share
    the main device's register region between subdevices. The simple-mfd helper has
    then been introduced to handle zero conf/hacks subdevice registering, and syscon
    has been introduced for sharing a device's memory region with other devices. Since
    regmap was handling MMIO registers and managed locking (aka synchronization) accesses
    to memory, it has been a natural choice to build syscon on top of regmap. To get
    familiar with the MFD subsystem, in this chapter, we will begin with an introduction
    to MFD, where you will learn about its data structures and APIs, and then we will
    look at device tree binding in order to describe these devices to the kernel.
    Finally, we will talk about syscon and introduce the simple-mfd driver for a zero
    conf/hacks subdevice.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一些基于I2C和SPI的设备/子设备可能需要一些黑客或配置才能被添加到系统中，还有一些基于MMIO的设备/子设备，它们不需要任何配置或黑客，只需要在子设备之间共享主设备的寄存器区域。简单的mfd助手被引入来处理零配置/黑客子设备的注册，syscon被引入来与其他设备共享设备的内存区域。由于regmap处理MMIO寄存器并管理对内存的访问（也称为同步），因此将syscon构建在regmap之上是一个自然的选择。为了熟悉MFD子系统，在本章中，我们将首先介绍MFD，您将了解其数据结构和API，然后我们将研究设备树绑定，以便向内核描述这些设备。最后，我们将讨论syscon并介绍简单的mfd驱动程序，用于零配置/黑客子设备。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing the MFD and syscon APIs and data structures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍MFD和syscon API和数据结构
- en: Device tree binding for MFD devices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MFD设备的设备树绑定
- en: Understanding syscon and simple-mfd
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解syscon和简单的mfd
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to leverage this chapter, you will need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用本章，您需要以下内容：
- en: C programming skills
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C编程技能
- en: Good knowledge of Linux device driver models
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的Linux设备驱动程序模型知识
- en: Linux kernel v4.19.X sources, available at [https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核v4.19.X源代码，可在[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)上找到
- en: Introducing the MFD subsystem and Syscon APIs
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍MFD子系统和Syscon API
- en: 'Prior to delving into the syscon framework and its APIs, we will cover MFDs.
    There are peripherals or hardware blocks exposing more than a single functionality
    by means of subdevices they embed into them and that are handled by separate subsystems
    in the kernel. That being said, a subdevice is a dedicated entity in a so-called
    multifunction device, responsible for a specific task, and managed through a reduced
    set of registers, in the chip''s register map. `ADP5520` is a typical example
    of an MFD device, as it contains a backlight, a keypad, LEDs, and GPIO controllers.
    Each of these is then considered as a subdevice, and as you can see, each of these
    falls into a different subsystem. The MFD subsystem, defined in `include/linux/mfd/core.h`
    and implemented in `drivers/mfd/mfd-core.c`, has been created to deal with these
    devices, allowing the following features:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究syscon框架及其API之前，我们将介绍MFD。有些外围设备或硬件块通过它们嵌入的子设备来提供多个功能，这些子设备由内核中的单独子系统处理。也就是说，子设备是所谓的多功能设备中的专用实体，负责特定任务，并通过芯片的寄存器映射中的一组减少的寄存器进行管理。`ADP5520`是MFD设备的典型示例，因为它包含背光、键盘、LED和GPIO控制器。每个子设备都被视为一个子设备，正如您所看到的，每个子设备都属于不同的子系统。MFD子系统定义在`include/linux/mfd/core.h`中，并在`drivers/mfd/mfd-core.c`中实现，用于处理这些设备，允许以下功能：
- en: Registering the same device with multiple subsystems
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个子系统中注册相同的设备
- en: Multiplexing bus and register access, as there may be some registers shared
    between subdevices
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复用总线和寄存器访问，因为可能有一些寄存器在子设备之间共享
- en: Handling IRQs and clocks
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理中断和时钟
- en: Throughout this section, we will study the driver of the `da9055` device from
    the dialog-semiconductor and located in `drivers/mfd/da9055-core.c` in the kernel
    source tree. The datasheet for this device can be found at [https://www.dialog-semiconductor.com/sites/default/files/da9055-00-ids3a_20120710.pdf](https://www.dialog-semiconductor.com/sites/default/files/da9055-00-ids3a_20120710.pdf).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究来自对话半导体的`da9055`设备的驱动程序，位于内核源树中的`drivers/mfd/da9055-core.c`。该设备的数据手册可以在[https://www.dialog-semiconductor.com/sites/default/files/da9055-00-ids3a_20120710.pdf](https://www.dialog-semiconductor.com/sites/default/files/da9055-00-ids3a_20120710.pdf)找到。
- en: 'In most cases, MFD device drivers consist of two parts:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，MFD设备驱动程序由两部分组成：
- en: '`drivers/mfd`, responsible for the main initialization and registering each
    subdevice as a platform device (along with its platform data) on the system. This
    driver should provide common services for the subdevice drivers. These services
    include register access, control, and shared interrupt management. When a platform
    driver for one of the subsystems is instantiated, the core initializes the chip
    (which may be specified by the platform data). There can be support for multiple
    block devices of the same type built into a single kernel image. This is possible
    thanks to the mechanism of platform data. A platform-specific data abstraction
    mechanism in the kernel is used to pass configurations to the core, and subsidiary
    drivers make it possible to support multiple block devices of the same type.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drivers/mfd`，负责主要初始化并将每个子设备注册为系统上的平台设备（以及其平台数据）。该驱动程序应为子设备驱动程序提供通用服务。这些服务包括寄存器访问、控制和共享中断管理。当一个子系统的平台驱动程序被实例化时，核心初始化芯片（可以由平台数据指定）。单个内核映像中可以构建相同类型的多个块设备的支持。这要归功于平台数据的机制。内核中使用平台特定数据抽象机制来将配置传递给核心，并且子驱动程序使得支持多个相同类型的块设备成为可能。'
- en: '**The subdevice driver**, which is responsible for handling a specific subdevice
    registered earlier by the core driver. These drivers are located in their respective
    subsystem directories. Each peripheral (subsystem device) has a limited view of
    the device, which is implicitly reduced to the specific set of resources that
    the peripheral requires in order to function correctly.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子设备驱动程序**，负责处理核心驱动程序早期注册的特定子设备。这些驱动程序位于各自的子系统目录中。每个外围（子系统设备）对设备有一个有限的视图，隐式地缩小到外围需要为了正确运行所需的特定资源集。'
- en: Important note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The concept of subdevices in this chapter should not be confused with the concept
    of the same name in [*Chapter 7*](B10985_07_ePub_AM.xhtml#_idTextAnchor287), *Demystifying
    V4L2 and Video Capture Device Drivers*, which is slightly different, where a subdevice
    also represents an entity in the video pipeline.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的子设备概念不应与[*第7章*](B10985_07_ePub_AM.xhtml#_idTextAnchor287)中的同名概念混淆，*解密V4L2和视频捕获设备驱动程序*，稍有不同，其中子设备还代表视频管道中的实体。
- en: 'A subdevice is represented in the MFD subsystem by an instance of the `struct
    mfd_cell` structure, which you can call a `struct mfd_cell` structure, you can
    specify more advanced things, such as the resources used by the subdevice and
    suspend-resume operations (to be called from the driver for the subdevice). This
    structure is presented as follows, with some fields removed for simplicity reasons:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在MFD子系统中，子设备由`struct mfd_cell`结构的实例表示，您可以称之为`struct mfd_cell`结构，您可以指定更高级的东西，例如子设备使用的资源和挂起-恢复操作（从子设备的驱动程序调用）。该结构如下所示，为简化原因删除了一些字段：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Important note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The new platform devices that are created will have the cell structure as their
    platform data. The real platform data can then be accessed through `pdev->mfd_cell->platform_data`.
    A driver can also use `mfd_get_cell()` in order to retrieve the MFD cell corresponding
    to a platform device: `const struct mfd_cell *cell = mfd_get_cell(pdev);`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的新平台设备将具有该单元结构作为其平台数据。然后可以通过`pdev->mfd_cell->platform_data`访问真实的平台数据。驱动程序还可以使用`mfd_get_cell()`来检索与平台设备对应的MFD单元：`const
    struct mfd_cell *cell = mfd_get_cell(pdev);`。
- en: The functionality of each member of this structure is self-explanatory. However,
    the following gives you more details.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构的每个成员的功能是不言自明的。但以下内容会给您更多细节。
- en: 'The `.resources` element is an array that represents the resources specific
    to the subdevice (which is also a platform device), and `.num_resources` in the
    number of entries in the array. These are defined as it was done using `platform_data`,
    and you probably want to name them for easy retrieval. The following is an example
    from an MFD driver whose original core source file is `drivers/mfd/da9055-core.c`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`.resources`元素是表示子设备特定资源的数组（也是平台设备），`.num_resources`是数组中条目的数量。这些是使用`platform_data`定义的，您可能希望为其命名以便轻松检索。以下是一个原始核心源文件为`drivers/mfd/da9055-core.c`的MFD驱动程序的示例：'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following example shows how to retrieve the resource from the subdevice
    driver, in this case, which is implemented in `drivers/rtc/rtc-da9055.c`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何从子设备驱动程序中检索资源，本例中实现在`drivers/rtc/rtc-da9055.c`中：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Actually, you should use `platform_get_resource()`, `platform_get_resource_byname()`,
    `platform_get_irq()`, and `platform_get_irq_byname()` to retrieve the resources.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您应该使用`platform_get_resource()`、`platform_get_resource_byname()`、`platform_get_irq()`和`platform_get_irq_byname()`来检索资源。
- en: 'When using `.of_compatible`, the function has to be a child of the MFD (see
    the *Device tree binding for MFD devices* section). You should statically fill
    an array of this structure, containing as many entries as there are subdevices
    on your device:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`.of_compatible`时，该函数必须是MFD的子级（参见*MFD设备的设备树绑定*部分）。您应该静态填充一个包含与设备上的子设备数量相同的条目的结构数组：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After the array of `struct mfd_cell` is filled, it has to be passed to the
    `devm_mfd_add_devices()` function, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 填充`struct mfd_cell`数组后，必须将其传递给`devm_mfd_add_devices()`函数，如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This method''s arguments are explained as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的参数解释如下：
- en: '`dev` is the generic struct device structure of the MFD chip. It will be used
    to set the subdevice''s parent.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`是MFD芯片的通用结构设备。它将用于设置子设备的父级。'
- en: '`id`: Since subdevices are created as platform devices, they should be given
    an ID. This field should be set with `PLATFORM_DEVID_AUTO` for automatic ID allocation,
    in which case `mfd_cell.id` of the corresponding cell is ignored. Otherwise, you
    should use `PLATFORM_DEVID_NONE`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：由于子设备被创建为平台设备，因此应该为其分配一个ID。对于自动ID分配，应将此字段设置为`PLATFORM_DEVID_AUTO`，在这种情况下，相应单元的`mfd_cell.id`将被忽略。否则，您应该使用`PLATFORM_DEVID_NONE`。'
- en: '`cells` is a pointer to a list (an array actually) of `struct mfd_cell` structures
    that describe subdevices.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cells`是一个指向描述子设备的`struct mfd_cell`结构的列表（实际上是一个数组）的指针。'
- en: '`n_dev` is the number of `struct mfd_cell` entries to use in the array to create
    platform devices. To create as many platform devices as there are cells in the
    array, you should use the `ARRAY_SIZE()` macro.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n_dev`是要在数组中使用的`struct mfd_cell`条目的数量，以创建平台设备。要创建与数组中的单元数量相同的平台设备，应使用`ARRAY_SIZE()`宏。'
- en: '`mem_base`: If not `NULL`, its `.start` field will be used as the base of each
    resource of type `IORESOURCE_MEM` of each MFD cell in the previously mentioned
    array. The following is an excerpt of the `mfd_add_device()` function showing
    this:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mem_base`：如果不是`NULL`，其`.start`字段将用作先前提到的数组中每个MFD单元的`IORESOURCE_MEM`类型资源的基址。以下是`mfd_add_device()`函数的摘录，显示了这一点：'
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`irq_base`: This parameter is ignored if the domain is set. Otherwise, it behaves
    like `mem_base` but for each resource of type `IORESOURCE_IRQ`. The following
    is an excerpt of the `mfd_add_device()` function showing this:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_base`：如果设置了域，则此参数将被忽略。否则，它的行为类似于`mem_base`，但对于每个`IORESOURCE_IRQ`类型的资源。以下是`mfd_add_device()`函数的摘录，显示了这一点：'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`domain`: For MFD chips that also play the role of IRQ controller for their
    subdevices, this parameter will be used as the IRQ domain to create IRQ mappings
    for these subdevices. It works this way: for each resource `r` of type `IORESOURCE_IRQ`
    in each cell, the MFD core will create a new resource, `res`, of the same type
    (actually, an IRQ resource, whose `res.start` and `res.end` fields are set with
    the IRQ mapping in this domain that corresponds to the initial resource''s `.start`
    field: `res[r].start = res[r].end = irq_create_mapping(domain, cell->resources[r].start);`).
    New IRQ resources are then assigned to the platform device of the current cell
    and correspond to its virqs. Please have a look at the preceding excerpt, in the
    previous parameter description. Note that this parameter can be `NULL`.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domain`：对于同时扮演子设备的IRQ控制器角色的MFD芯片，此参数将用作IRQ域，为这些子设备创建IRQ映射。它的工作方式是：对于每个单元中类型为`IORESOURCE_IRQ`的资源`r`，MFD核心将创建一个相同类型的新资源`res`（实际上是一个IRQ资源，其`res.start`和`res.end`字段设置为与此域中对应于初始资源的`.start`字段的IRQ映射：`res[r].start
    = res[r].end = irq_create_mapping(domain, cell->resources[r].start);`）。然后，新的IRQ资源被分配给当前单元的平台设备，并对应于其virqs。请查看上述摘录中的前一个参数描述。请注意，此参数可以是`NULL`。'
- en: 'Let''s now see how to put this all together with an excerpt of the `da9055`
    MFD driver:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何将这些内容与`da9055` MFD驱动程序的摘录放在一起：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding excerpt, the driver defined some constants, along with a private
    data structure, whose meaning will be clear as and when you read the code. After,
    the IRQs are defined for the register map core, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述摘录中，驱动程序定义了一些常量，以及一个私有数据结构，其含义将在阅读代码时清楚。之后，为寄存器映射核心定义了IRQ，如下：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding excerpt, `da9055_irqs` is an array of elements of type `regmap_irq`,
    which describes a generic regmap IRQ. It is assigned to `da9055_regmap_irq_chip`,
    which is of type `regmap_irq_chip` and represents the regmap IRQ chip. Both are
    part of the regmap IRQ data structures set. Finally, the `probe` method is implemented,
    as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述摘录中，`da9055_irqs`是`regmap_irq`类型的元素数组，描述了通用的regmap IRQ。它被分配给`da9055_regmap_irq_chip`，它是`regmap_irq_chip`类型，代表了regmap
    IRQ芯片。两者都是regmap IRQ数据结构集的一部分。最后，`probe`方法被实现如下：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding probe method, `da9055_regmap_irq_chip` (defined earlier) is
    given as a parameter to `regmap_add_irq_chip()` in order to add a valid regmap
    IRQ controller to the IRQ core. This function returns `O` on success. Moreover,
    it also returns a fully configured `regmap_irq_chip_data` structure through its
    last parameter, which can be used later as the runtime data structure for the
    controller. This `regmap_irq_chip_data` structure will contain the IRQ domain
    associated with the previously added IRQ controller. This IRQ domain is finally
    given as a parameter to `devm_mfd_add_devices()`, along with the array of MFD
    cells and its size in terms of the number of cells.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的探测方法中，`da9055_regmap_irq_chip`（之前定义的）作为参数传递给`regmap_add_irq_chip()`，以便向IRQ核心添加一个有效的regmap
    IRQ控制器。该函数成功返回`0`。此外，它还通过最后一个参数返回一个完全配置的`regmap_irq_chip_data`结构，可以作为控制器的运行时数据结构后续使用。这个`regmap_irq_chip_data`结构将包含与先前添加的IRQ控制器相关联的IRQ域。最终，这个IRQ域作为参数传递给`devm_mfd_add_devices()`，以及MFD单元的数组和单元数量。
- en: Important note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Do note that `devm_mfd_add_devices()` is actually the resource-managed version
    of `mfd_add_devices()`, which has the following function call sequence:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`devm_mfd_add_devices()`实际上是`mfd_add_devices()`的资源管理版本，其具有以下函数调用序列：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are I2C chips where both the chip itself and internal subdevices have
    different I2C addresses. Such I2C subdevices can''t be probed as I2C clients because
    the MFD core only instantiates a platform device given an MFD cell. This issue
    is addressed by the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有些I2C芯片的芯片本身和内部子设备具有不同的I2C地址。这样的I2C子设备不能作为I2C客户端进行探测，因为MFD核心只实例化给定MFD单元的平台设备。这个问题通过以下方式解决：
- en: Creating a dummy I2C client given the subdevice's I2C address and the MFD chip's
    adapter. This actually corresponds to the adapter (bus) managing the MFD device.
    This can be achieved using `i2c_new_dummy()`. The returned I2C client should be
    saved for later use – for example, with `i2c_unregister_device()`, which should
    be called when the module is being unloaded.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个虚拟I2C客户端，给定子设备的I2C地址和MFD芯片的适配器。这实际上对应于管理MFD设备的适配器（总线）。这可以使用`i2c_new_dummy()`来实现。返回的I2C客户端应该保存以备以后使用，例如，使用`i2c_unregister_device()`，在模块被卸载时应调用。
- en: If a subdevice needs its own regmap, then this regmap has to be built on top
    of its dummy I2C client.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果子设备需要自己的regmap，则必须在其虚拟I2C客户端的基础上构建此regmap。
- en: Storing either the I2C client only (for later removal) or with the regmap in
    a private data structure that can be assigned to the underlying platform device.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅存储I2C客户端（以备以后删除）或将其与regmap一起存储在可以分配给底层平台设备的私有数据结构中。
- en: To summarize the preceding steps, let's walk through the driver of a real MFD
    device, the max8925 (which is mainly a power management IC, but is also made up
    of a large group of subdevices). Our code is a summary (dealing with two subdevices
    only) of the original one, with function names modified for the sake of readability.
    That being said, the original driver can be found in `drivers/mfd/max8925-i2c.c`
    in the kernel source tree.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前面的步骤，让我们通过一个真实MFD设备max8925的驱动程序来走一遍（主要是电源管理IC，但也由大量子设备组成）。我们的代码是原始代码的摘要（仅处理两个子设备），函数名称经过修改以便阅读。也就是说，原始驱动程序可以在内核源树中的`drivers/mfd/max8925-i2c.c`中找到。
- en: 'Let''s jump to our excerpt, starting with the context data structure definition,
    as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上下文数据结构定义开始，如下所示：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding excerpt, the driver defines the context data structure, `struct
    priv_chip`, which contains subdevice regmaps, and then initializes the MFD device
    regmap configuration as well as the subdevice''s own configuration. Then, the
    `probe` method is defined, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的摘录中，驱动程序定义了上下文数据结构`struct priv_chip`，其中包含子设备regmaps，然后初始化了MFD设备regmap配置以及子设备自身的配置。然后，定义了`probe`方法，如下所示：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For the sake of readability, the preceding excerpt omits an error check. Additionally,
    the following code shows how to remove the dummy I2C clients:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，前面的摘录省略了错误检查。此外，以下代码显示了如何删除虚拟I2C客户端：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, the following simplified code shows how the subdevice driver can grab
    the pointer to either of the regmap data structures set up in the MFD driver:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下简化的代码显示了子设备驱动程序如何获取设置在MFD驱动程序中的regmap数据结构的指针：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Though we have most of the knowledge required to develop MFD device drivers,
    it is necessary to integrate this with the device tree in order to have a better
    (that is, not hardcoded) description of our MFD device. This is what we will discuss
    in the next section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经掌握了开发MFD设备驱动程序所需的大部分知识，但是有必要将其与设备树集成，以便更好地（即非硬编码）描述我们的MFD设备。这是我们将在下一节中讨论的内容。
- en: Device tree binding for MFD devices
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MFD设备的设备树绑定
- en: 'Even though we have the necessary tools and inputs to write our own MFD driver,
    it is important for the underlying MFD device to have its description defined
    in the device tree, since this lets the MFD core know what our MFD device is made
    of and how to deal with it. Moreover, the device tree remains the right place
    to declare devices, whether they are MFD or not. Please keep in mind that its
    purpose is only to describe devices on the system. As subdevices are children
    of the MFD device into which they are built (there is a parent-and-child bond
    of belonging), it is good practice to declare these subdevice nodes beneath their
    parent node, as in the following example. Moreover, the resources used by the
    subdevices are sometimes part of the resources of the parent device. So, it enforces
    the idea of putting the subdevice node beneath the main device node. In each subdevice
    node, the compatible property should match either both the subdevice''s `cell.of_compatible`
    field and one of the `.compatible` string entries in the subdevice''s `platform_driver.of_match_table`
    array, or both the subdevice''s `cell.name` field and the subdevice''s `platform_driver.name`
    field:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们有必要的工具和输入来编写自己的MFD驱动程序，但是重要的是底层MFD设备在设备树中有其描述，因为这样可以让MFD核心知道我们的MFD设备由什么组成以及如何处理它。此外，设备树仍然是声明设备的正确位置，无论它们是否是MFD。请记住，它的目的只是描述系统上的设备。由于子设备是构建它们的MFD设备的子级（存在从属关系），因此在父节点下声明这些子设备节点是一个良好的做法，就像以下示例中所示的那样。此外，子设备使用的资源有时是父设备的资源的一部分。因此，它强调了将子设备节点放在主设备节点下的想法。在每个子设备节点中，兼容属性应该与子设备的`cell.of_compatible`字段和子设备的`platform_driver.of_match_table`数组中的一个`.compatible`字符串条目之一匹配，或者与子设备的`cell.name`字段和子设备的`platform_driver.name`字段匹配：
- en: Important note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: The subdevice's `cell.of_compatible` and `cell.name` fields are those declared
    in the subdevice's `mfd_cell` structure in the MFD core driver.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 子设备的`cell.of_compatible`和`cell.name`字段是在MFD核心驱动程序中的子设备的`mfd_cell`结构中声明的。
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding device tree sample, the parent node (`da9062`, a `da9092`,
    actually) node. Let''s focus on the subdevice''s `compatible` properties and use
    `onkey` as an example. The MFD cell of this node is declared in the MFD core driver
    (whose source file is `drivers/mfd/da9063-core.c`), as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的设备树示例中，父节点（实际上是`da9092`的`da9062`节点）。让我们专注于子设备的`compatible`属性，并以`onkey`为例。此节点的MFD单元在MFD核心驱动程序中声明（源文件为`drivers/mfd/da9063-core.c`），如下所示：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, this `onekey` platform driver structure is declared (along with its `.of_match_table`
    entry) in the driver (whose source file is `drivers/input/misc/da9063_onkey.c`),
    as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个`onekey`平台驱动程序结构被声明（以及其`.of_match_table`条目）在驱动程序中（源文件为`drivers/input/misc/da9063_onkey.c`），如下所示：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can see that both `compatible` strings match the node's `compatible` string
    in the device's node. On the other hand, we can see that the same platform driver
    may be used for two or more (sub)devices. Using name matching would be confusing,
    then. That is why you would use a device tree for declaration and a `compatible`
    string for matching. So far, we have learned how the MFD subsystem deals with
    the device and vice versa. In the next section, we will extend these concepts
    to syscon and simple-mfd, two frameworks that help with MFD driver development.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到两个`compatible`字符串与设备节点中的`compatible`字符串匹配。另一方面，我们可以看到同一平台驱动程序可能用于两个或更多（子）设备。然后使用名称匹配会很令人困惑。这就是为什么您会使用设备树进行声明和`compatible`字符串进行匹配的原因。到目前为止，我们已经了解了MFD子系统如何处理设备以及反之。在下一节中，我们将把这些概念扩展到syscon和simple-mfd，这是两个有助于MFD驱动程序开发的框架。
- en: Understanding Syscon and simple-mfd
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Syscon和simple-mfd
- en: '**Syscon** stands for **system controller**. SoCs sometimes have a set of MMIO
    registers dedicated to miscellaneous features that don''t relate to a specific
    IP. Clearly, there can''t be a functional driver for this as these registers are
    neither representative nor cohesive enough to represent a specific type of device.
    The syscon driver handles this kind of situation. Syscon permits other nodes to
    access this register space through the regmap mechanism. It is actually just a
    set of wrapper APIs for regmap. When you request access to syscon, the regmap
    is created, if it doesn''t exist yet.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**Syscon**代表**系统控制器**。SoC有时会有一组专用于与特定IP无关的杂项功能的MMIO寄存器。显然，对于这种情况，不能有功能驱动程序，因为这些寄存器既不具有代表性，也不足以代表特定类型的设备。syscon驱动程序处理这种情况。Syscon允许其他节点通过regmap机制访问此寄存器空间。实际上，它只是regmap的一组包装API。当您请求访问syscon时，如果尚不存在，则会创建regmap。'
- en: 'The header required for using the syscon API is `<linux/mfd/syscon.h>`. As
    this API is based on regmap, you must also include `<linux/regmap.h>`. The syscon
    API is implemented in `drivers/mfd/syscon.c` in the kernel source tree. Its main
    data structure is `struct syscon`, though this structure is not to be used directly:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用syscon API所需的头文件是`<linux/mfd/syscon.h>`。由于此API基于regmap，因此还必须包括`<linux/regmap.h>`。syscon
    API在内核源树中的`drivers/mfd/syscon.c`中实现。其主要数据结构是`struct syscon`，尽管不应直接使用此结构：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding structure, `np` is a pointer to the node acting as syscon.
    It is also used for syscon lookup by the device node. `regmap` is the regmap associated
    with this syscon, and `list` is used for implementing a kernel linked-lists mechanism,
    used to link all the syscons in the system together to the system-wide list, `syscon_list`,
    defined in `drivers/mfd/syscon.c`. This linked-list mechanism allows walking through
    the whole syscon list, either for a match by node or for a match by regmap.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述结构中，`np`是指向充当syscon的节点的指针。它还用于通过设备节点进行syscon查找。`regmap`是与此syscon关联的regmap，`list`用于实现内核链表机制，用于将系统中的所有syscon连接到系统范围的列表`syscon_list`中，该列表在`drivers/mfd/syscon.c`中定义。此链表机制允许遍历整个syscon列表，无论是通过节点匹配还是通过regmap匹配。
- en: 'Syscons are declared exclusively from within the device tree, by adding `"syscon"`
    to the compatible strings list in the device node that should act as Syscon. During
    early-boot, each node having `syscon` in its compatible string list will have
    its `reg` memory region IO-mapped and bound to an MMIO regmap, according to a
    default regmap configuration, `syscon_regmap_config`, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Syscon是通过在应充当Syscon的设备节点的兼容字符串列表中添加`"syscon"`来专门声明的。在早期引导期间，具有其兼容字符串列表中的`syscon`的每个节点将其`reg`内存区域进行IO映射，并根据默认的regmap配置`syscon_regmap_config`绑定到MMIO
    regmap，如下所示：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The syscon that is created is then added to the syscon framework-wide `syscon_list`,
    protected by the `syscon_list_slock` spinlock, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建的syscon将添加到syscon框架范围的`syscon_list`中，并由`syscon_list_slock`自旋锁保护，如下所示：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Syscon binding requires the following mandatory properties:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Syscon绑定需要以下强制属性：
- en: '`compatible`: This property value should be `"syscon"`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compatible`: 此属性值应为`"syscon"`。'
- en: '`reg`: This is the register region that can be accessed from syscon.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg`: 这是可以从syscon访问的寄存器区域。'
- en: 'The following are optional properties, used to mangle the default `syscon_regmap_config`
    regmap config:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可选属性，用于篡改默认的`syscon_regmap_config` regmap配置：
- en: '`reg-io-width`: The size (or width, in terms of bytes) of the IO accesses that
    should be performed on the device'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg-io-width`: 应在设备上执行的IO访问的大小（或宽度，以字节为单位）'
- en: '`hwlocks`: Reference to a phandle of a hardware spinlock provider node'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hwlocks`: 指向硬件自旋锁提供程序节点的phandle的引用'
- en: 'An example is shown in the following, an excerpt from the kernel docs, whose
    full version is available in `Documentation/devicetree/bindings/mfd/syscon.txt`
    in the kernel sources:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，摘自内核文档，完整版本可在内核源代码中的`Documentation/devicetree/bindings/mfd/syscon.txt`中找到：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'From within the device tree, you can reference a syscon node in three different
    ways: either by phandle (specified in the device node of this driver), by its
    path, or by searching it using a specific compatible value, after which the driver
    can interrogate the node (or associated OS driver of this regmap) to determine
    the location of the registers, and finally, access the registers directly. You
    can use one of the following syscon APIs in order to grab a pointer to the regmap
    associated with a given syscon node:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备树中，可以通过三种不同的方式引用syscon节点：通过phandle（在此驱动程序的设备节点中指定）、通过其路径，或者通过使用特定的兼容值进行搜索，之后驱动程序可以询问节点（或关联的此regmap的OS驱动程序）以确定寄存器的位置，最后直接访问寄存器。您可以使用以下syscon
    API之一来获取与给定syscon节点关联的regmap的指针：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding APIs have the following descriptions:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述API具有以下描述：
- en: '`syscon_regmap_lookup_by_compatible()`: Given one of the compatible strings
    of the syscon device node, this function returns the associated regmap, or creates
    one if it does not exist yet, before returning it.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscon_regmap_lookup_by_compatible()`: 给定syscon设备节点的兼容字符串之一，此函数返回关联的regmap，如果尚不存在，则创建一个，然后返回它。'
- en: '`syscon_node_to_regmap()`: Given a syscon device node as a parameter, this
    function returns the associated regmap, or creates one if it does not exist yet,
    before returning it.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscon_node_to_regmap()`: 给定一个syscon设备节点作为参数，此函数返回关联的regmap，如果尚不存在，则创建一个，然后返回它。'
- en: '`syscon_regmap_lookup_by_phandle()`: Given a phandle property holding an identifier
    of a syscon node, this function returns the regmap corresponding to this syscon
    node.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syscon_regmap_lookup_by_phandle()`: 给定一个包含syscon节点标识符的phandle属性，此函数返回与此syscon节点对应的regmap。'
- en: 'Before showing an example of using the preceding APIs, let''s introduce the
    following platform device node, for which we will write the `probe` function.
    To better understand `syscon_node_to_regmap()`, let''s declare this node as a
    child of the previous `gpr` node:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示使用上述API的示例之前，让我们介绍以下平台设备节点，我们将编写`probe`函数。为了更好地理解`syscon_node_to_regmap()`，让我们将此节点声明为先前`gpr`节点的子节点：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now that the device tree node is defined, we can focus on the code of the driver,
    implemented as follows and using the functions enumerated earlier:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在定义了设备树节点，我们可以专注于驱动程序的代码，如下所示，并使用前面列举的函数：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, if we consider that `syscon_name` contains the platform
    device name for the `gpr` device, then the `by_node_regmap`, `by_compat_regmap`,
    `by_pdevname_regmap`, and `by_phandle_regmap` variables will all point to the
    same syscon regmap. However, the purpose here is just to explain the concept.
    `my_pdev` could have been the sibling (or whatever relationship) node of `gpr`.
    Using it here as its child was done for the sake of understanding the concept
    and the code and showing that either API has its place, depending on the situation.
    Now that we are familiar with the syscon framework, let's see how it can be used
    along with simple-mfd.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，如果我们假设`syscon_name`包含`gpr`设备的平台设备名称，那么`by_node_regmap`、`by_compat_regmap`、`by_pdevname_regmap`和`by_phandle_regmap`变量将指向相同的syscon
    regmap。然而，这里的目的只是解释概念。`my_pdev`可能是`gpr`的兄弟（或其他关系）节点。在这里使用它作为其子节点是为了理解概念和代码，并展示根据情况使用任一API。现在我们熟悉了syscon框架，让我们看看它如何与simple-mfd一起使用。
- en: Introducing simple-mfd
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍simple-mfd
- en: For MMIO-based MFD devices, there may be no need to configure subdevices prior
    to adding them to the system. As this configuration is done from within the MFD
    core driver, the only goal of this MFD core driver would be to populate the system
    with platform subdevices. As a lot of these MMIO-based MFD devices exist, there
    would be a lot of redundant code. The simple MFD, which is a simple DT binding,
    addresses this.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于MMIO的MFD设备，在将它们添加到系统之前可能不需要配置子设备。因为这个配置是在MFD核心驱动程序内部完成的，所以这个MFD核心驱动程序的唯一目标将是向系统中添加平台子设备。由于存在许多基于MMIO的MFD设备，将会有大量冗余代码。简单的MFD，即简单的DT绑定，解决了这个问题。
- en: When the `simple-mfd` string is added to the list of compatible strings of a
    given device node (considered here as the MFD device), it will make the `for_each_child_of_node()`
    iterator. simple-mfd is implemented in `drivers/of/platform.c` as an alias of
    simple-bus, and its documentation is located in `Documentation/devicetree/bindings/mfd/mfd.txt`
    in the kernel source tree.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`simple-mfd`字符串添加到给定设备节点的兼容字符串列表中（在这里被视为MFD设备），它将使`for_each_child_of_node()`迭代器。simple-mfd在`drivers/of/platform.c`中实现为simple-bus的别名，其文档位于内核源树中的`Documentation/devicetree/bindings/mfd/mfd.txt`中。
- en: 'Used in conjunction with syscon to create the regmap, it helps to avoid writing
    an MFD driver, and the developer can put their effort into writing subdevice drivers.
    The following is an example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与syscon一起使用以创建regmap，有助于避免编写MFD驱动程序，开发人员可以将精力放在编写子设备驱动程序上。以下是一个例子：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding device tree excerpt, `snvs` is the main device. It is made
    up of a power control subdevice (represented by a register subregion in the main
    device register region), an `rtc` subdevice, as well as a power key, and so on.
    The whole definition can be found in `arch/arm/boot/dts/imx6qdl.dtsi`, which is
    the SoC vendor `dtsi` for the i.MX6 chip series. The respective drivers can be
    found in the kernel source by grepping (searching for) the content of their `compatible`
    properties. To summarize, for each subnode in the `snvs` node, the MFD core will
    create a corresponding device along with its regmap, which would correspond to
    their memory region from within the main device's memory region.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的设备树摘录中，`snvs`是主设备。它由一个电源控制子设备（在主设备寄存器区域中表示为一个寄存器子区域）、一个`rtc`子设备以及一个电源键等组成。整个定义可以在`arch/arm/boot/dts/imx6qdl.dtsi`中找到，这是i.MX6芯片系列的SoC供应商`dtsi`。相应的驱动程序可以通过在内核源代码中搜索它们的`compatible`属性的内容来找到。总之，对于`snvs`节点中的每个子节点，MFD核心将创建一个相应的设备以及其regmap，该regmap将对应于它们在主设备的内存区域中的内存区域。
- en: This section shows the way to ease into MFD driver development when it comes
    to MMIO devices. Though SPI/I2C devices do not fall into this category, it covers
    almost 95% of MMIO-based MFD devices.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了在处理MMIO设备时如何轻松进入MFD驱动程序开发。虽然SPI/I2C设备不属于这一类别，但它涵盖了几乎95%的基于MMIO的MFD设备。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter dealt with MFD devices, along with the syscon and regmap APIs.
    Here, we discussed how MFD devices work and how deep regmap is embedded into syscon.
    Having reached the end of this chapter, we can assume that you are able to develop
    regmap-enabled IRQ controllers, as well as to design and use syscon to share register
    regions between devices. The next chapter will deal with the common clock framework
    and how this framework is organized, its implementation, how to use it, and how
    to add your own clocks.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了MFD设备以及syscon和regmap API。在这里，我们讨论了MFD设备的工作原理以及regmap是如何嵌入到syscon中的。到达本章末尾时，我们可以假设您能够开发支持regmap的IRQ控制器，并设计和使用syscon在设备之间共享寄存器区域。下一章将涉及通用时钟框架以及该框架的组织结构、实现方式、使用方法以及如何添加自己的时钟。
