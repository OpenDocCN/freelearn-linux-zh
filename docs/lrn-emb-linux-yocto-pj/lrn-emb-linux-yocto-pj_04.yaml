- en: Chapter 4. Linux Kernel
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。Linux内核
- en: In this chapter, you will not only learn about the Linux kernel in general,
    but also specific things about it. The chapter will start with a quick presentation
    of the history of Linux and its role and will then continue with an explanation
    of its various features. The steps used to interact with the sources of the Linux
    kernel will not be omitted. You will only be presented with the steps necessary
    to obtain a Linux kernel image from a source code, but also information about
    what porting for an new **ARM machine** implies, and some of the methods used
    to debug various problems that could appear when working with the Linux kernel
    sources in general. In the end, the context will be switched to the Yocto Project
    to show how the Linux kernel can be built for a given machine, and also how an
    external module can be integrated and used later from a root filesystem image.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您不仅将了解有关Linux内核的一般信息，还将了解有关它的具体信息。本章将从Linux的历史和作用的简要介绍开始，然后继续解释其各种特性。不会省略与Linux内核源代码交互的步骤。您将了解到获取Linux内核映像的步骤，以及新**ARM机器**的移植意味着什么，以及在一般情况下使用调试各种问题的方法。最后，将切换到Yocto项目，展示如何为给定的机器构建Linux内核，以及如何集成和稍后从根文件系统映像中使用外部模块。
- en: This chapter will give you an idea of the Linux kernel and Linux operating system.
    This presentation would not have been possible without the historical component.
    Linux and UNIX are usually placed in the same historical context, but although
    the Linux kernel appeared in 1991 and the Linux operating system quickly became
    an alternative to the UNIX operating system, these two operating systems are members
    of the same family. Taking this into consideration, the history of UNIX operating
    system could not have started from another place. This means that we need to go
    back in time to more than 40 years ago, to be more precise, about 45 years ago
    to 1969 when Dennis Ritchie and Ken Thompson started the development of UNIX.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将让您了解Linux内核和Linux操作系统。没有历史组成部分，这个演示是不可能的。Linux和UNIX通常被放在同一历史背景下，但尽管Linux内核出现在1991年，Linux操作系统很快成为UNIX操作系统的替代品，但这两个操作系统是同一个家族的成员。考虑到这一点，UNIX操作系统的历史不能从其他地方开始。这意味着我们需要回到40多年前，更准确地说，大约45年前的1969年，当丹尼斯·里奇和肯·汤普森开始开发UNIX时。
- en: 'The predecessor of UNIX was **Multiplexed Information and Computing Service**
    (**Multics**), a multiuser operating system project that was not on its best shape
    at the time. Since the Multics had become a nonviable solution for Bell Laboratories
    Computer Sciences Research Center in the summer of 1969, a filesystem design was
    born and it later became what is known today as UNIX. Over time, it was ported
    on multiple machines due to its design and the fact that the source code was distributed
    alongside it. The most prolific contributor to the UNIX was the University of
    California, Berkeley. They also developed their own UNIX version called **Berkeley
    Software Distribution** (**BSD**), that was first released in 1977\. Until the
    1990s, multiple companies developed and offered their own distributions of UNIX,
    their main inspirations being Berkeley or AT&T. All of them helped UNIX become
    a stable, robust, and powerful operating system. Among the features that made
    UNIX strong as an operating system, the following can be mentioned:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX的前身是**多路信息和计算服务**（**Multics**），这是一个多用户操作系统项目，当时并不是最佳状态。自从Multics在1969年夏天成为贝尔实验室计算机科学研究中心无法实现的解决方案后，一个文件系统设计诞生了，后来成为今天所知的UNIX。随着时间的推移，由于其设计和源代码随之分发，它被移植到了多台机器上。UNIX最多产的贡献者是加州大学伯克利分校。他们还开发了自己的UNIX版本，名为**伯克利软件发行**（**BSD**），首次发布于1977年。直到1990年代，多家公司开发并提供了自己的UNIX发行版，它们的主要灵感来自伯克利或AT&T。所有这些都帮助UNIX成为一个稳定、健壮和强大的操作系统。UNIX作为操作系统强大的特点包括：
- en: UNIX is simple. The number of system calls that it uses are reduced to only
    a couple of hundred and their design is basic
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UNIX很简单。它使用的系统调用数量减少到只有几百个，它们的设计是基本的
- en: Everything is regarded as a file in UNIX, making the manipulation of data and
    devices simpler, and it minimizes system calls used for interaction.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在UNIX中，一切都被视为文件，这使得数据和设备的操作更简单，并且最小化了用于交互的系统调用。
- en: Faster process creation time and the `fork()` system call.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更快的进程创建时间和`fork()`系统调用。
- en: The UNIX kernel and utilities written in C language as well as a property that
    makes it easily portable and accessible.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UNIX内核和实用程序都是用C语言编写的，这使得它易于移植和访问。
- en: Simple and robust **interprocess communication** (**IPC**) primitives helps
    in the creation of fast and simple programs that accomplish only one thing in
    the best available manner.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单而健壮的**进程间通信**（**IPC**）原语有助于创建快速和简单的程序，以最佳方式完成一件事。
- en: Nowadays, UNIX is a mature operating system with support for features, such
    as virtual memory, TCP/IP networking, demand paging preemptive multiprocessing,
    and multithreading. The features spread is wide and varies from small embedded
    devices to systems with hundreds of processors. Its development has moved past
    the idea that UNIX is a research project, and it has become an operating system
    that is general-purpose and practically fits any needs. All this has happened
    due to its elegant design and proven simplicity. It was able to evolve without
    losing its capability to remain simple.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，UNIX是一个成熟的操作系统，支持虚拟内存、TCP/IP网络、需求分页、抢占式多任务处理和多线程等功能。其功能覆盖范围广泛，从小型嵌入式设备到拥有数百个处理器的系统。它的发展已经超越了UNIX是一个研究项目的想法，它已经成为一个通用的操作系统，几乎适用于任何需求。所有这些都是由于其优雅的设计和经过验证的简单性。它能够在不失去简单性的能力的情况下发展。
- en: Linux is as an alternative solution to a UNIX variant called **Minix**, an operating
    system that was created for teaching purposes, but it lacked easy interaction
    with the system source code. Any changes made to the source code were not easily
    integrated and distributed because of Minix's license. Linus Torvalds first started
    working at a terminal emulator to connect to other UNIX systems from his university.
    Within the same academic year, emulator evolved in a full-fledged UNIX. He released
    it to be used by everyone in 1991.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Linux是UNIX变体**Minix**的替代解决方案，Minix是一个为教学目的而创建的操作系统，但它缺乏与系统源代码的简单交互。由于Minix的许可证，对源代码的任何更改都不容易集成和分发。Linus
    Torvalds最初在终端仿真器上开始工作，以连接到他的大学的其他UNIX系统。在同一个学年内，仿真器演变成了一个完整的UNIX系统。他在1991年发布了供所有人使用的版本。
- en: One of the most attractive features of Linux is that it is an open source operating
    system whose source code is available under the GNU GPL license. When writing
    the Linux kernel, Linus Torvalds used the best design choices and features from
    the UNIX available in variations of the operating system kernel as a source of
    inspiration. Its license is what has propelled it into becoming the powerhouse
    it is today. It has engaged a large number of developers that helped with code
    enhancements, bug fixing, and much more.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Linux最吸引人的特点之一是它是一个开源操作系统，其源代码在GNU GPL许可证下可用。在编写Linux内核时，Linus Torvalds从可用的UNIX变体中选择了最佳的设计选择和功能作为灵感的来源。它的许可证是推动它成为今天强大力量的原因。它吸引了大量的开发人员，他们帮助改进了代码，修复了错误等等。
- en: Today, Linux is an experienced operating system that is able to run on a multitude
    of architectures. It is able to run on devices that are even smaller than a wristwatch
    or on clusters of supercomputer. It's the new sensation of our days and is being
    adopted by companies and developers around the world in an increasingly diversified
    manner. The interest in the Linux operating system is very strong and this implies
    not only diversity, but also offers a great number of benefits, ranging from security,
    new features, embedded solutions to server solution options, and many more.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，Linux是一个经验丰富的操作系统，能够在多种架构上运行。它能够在比手表还小的设备上运行，也能在超级计算机集群上运行。它是我们这个时代的新感觉，并且正在以越来越多样化的方式被公司和开发人员采用。对Linux操作系统的兴趣非常强烈，这不仅意味着多样性，还提供了大量的好处，从安全性、新功能、嵌入式解决方案到服务器解决方案等等。
- en: Linux has become a truly collaborative project developed by a huge community
    over the internet. Although a great number of changes were made inside this project,
    Linus has remained its creator and maintainer. Change is a constant factor in
    everything around us and this applies to Linux and its maintainer, who is now
    called Greg Kroah-Hartman, and has already been its kernel maintainer for two
    years now. It may seem that in the period that Linus was around, the Linux kernel
    was a loose-knit community of developers. This may be because of Linus' harsh
    comments that are known worldwide. Since Greg has been appointed the kernel maintainer,
    this image started fading gradually. I am looking forward to the years to come.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Linux已经成为一个真正的由互联网上的庞大社区开发的协作项目。尽管在这个项目内部进行了大量的变化，但Linus仍然是它的创造者和维护者。变化是我们周围一切的不断因素，这也适用于Linux及其维护者，现在被称为Greg
    Kroah-Hartman，已经担任内核维护者两年了。在Linus在场的时期，Linux内核似乎是一个松散的开发者社区。这可能是因为Linus全球知名的严厉评论。自从Greg被任命为内核维护者以来，这种形象逐渐消失。我期待未来的岁月。
- en: The role of the Linux kernel
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux内核的作用
- en: 'With an impressive numbers of code lines, the Linux kernel is one of the most
    prominent open source projects and at the same time, the largest available one.
    The Linux kernel constitutes a piece of software that helps with the interfacing
    of hardware, being the lowest-level code available that runs in everyone''s Linux
    operating system. It is used as an interface for other user space applications,
    as described in the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 具有令人印象深刻的代码行数，Linux内核是最重要的开源项目之一，同时也是最大的开源项目之一。Linux内核构成了一个软件部分，帮助硬件接口，是在每个人的Linux操作系统中运行的最低级别代码。它被用作其他用户空间应用程序的接口，如下图所示：
- en: '![The role of the Linux kernel](img/image00313.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Linux内核的作用](img/image00313.jpeg)'
- en: 'The main roles of the Linux kernel are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核的主要作用如下：
- en: It provides a set of portable hardware and architecture APIs that offer user
    space applications the possibility to use necessary hardware resources
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供一组可移植的硬件和架构API，为用户空间应用程序提供使用必要硬件资源的可能性。
- en: It helps with the management of hardware resources, such as a CPU, input/output
    peripherals, and memory
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于管理硬件资源，如CPU、输入/输出外设和内存。
- en: It is used for the management of concurrent accesses and the usage of necessary
    hardware resources by different applications.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它用于管理不同应用程序对必要硬件资源的并发访问和使用。
- en: To make sure that the preceding roles are well understood, an example will be
    very useful. Let's consider that in a given Linux operating system, a number of
    applications need access to the same resource, a network interface, or a device.
    For these elements, the kernel needs to multiplex a resource in order to make
    sure that all applications have access to it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保前述角色被充分理解，一个例子将非常有用。让我们假设在给定的Linux操作系统中，一些应用程序需要访问相同的资源，如网络接口或设备。对于这些元素，内核需要复用资源，以确保所有应用程序都可以访问它。
- en: Delving into the features of the Linux kernel
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解Linux内核的特性
- en: This section will introduce a number of features available inside the Linux
    kernel. It will also cover information about each of them, how they are used,
    what they represent, and any other relevant information regarding each specific
    functionality. The presentation of each feature familiarizes you with the main
    role of some of the features available inside the Linux kernel, as well as the
    Linux kernel and its source code in general.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍Linux内核中的一些可用功能。它还将涵盖关于每个功能的信息，它们如何使用，代表什么，以及有关每个特定功能的任何其他相关信息。每个功能的介绍使您熟悉Linux内核中一些可用功能的主要作用，以及Linux内核和其源代码的一般情况。
- en: 'On a more general note, some of the most valuable features that the Linux kernel
    has are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，Linux内核具有一些最有价值的功能，如下所示：
- en: Stability and reliability
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定性和可靠性
- en: Scalability
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Portability and hardware support
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可移植性和硬件支持
- en: Compliance with standards
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符合标准
- en: Interoperability between various standards
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种标准之间的互操作性
- en: Modularity
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化
- en: Ease of programming
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程的便利性
- en: Comprehensive support from the community
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社区的全面支持
- en: Security
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: The preceding features does not constitute actual functionalities, but have
    helped the project along its development process and are still helping it today.
    Having said this, there are a lot of features that are implemented, such as fast
    user space mutex (futex), netfileters, Simplified Mandatory Access Control Kernel
    (smack), and so on. A complete list of these can be accessed and studied at [http://en.wikipedia.org/wiki/Category:Linux_kernel_features](http://en.wikipedia.org/wiki/Category:Linux_kernel_features).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前述功能并不构成实际功能，但它们在项目的开发过程中有所帮助，今天仍在帮助着它。话虽如此，有很多功能已经实现，例如快速用户空间互斥（futex）、netfileters、简化强制访问控制内核（smack）等。完整的列表可以在[http://en.wikipedia.org/wiki/Category:Linux_kernel_features](http://en.wikipedia.org/wiki/Category:Linux_kernel_features)上访问和学习。
- en: Memory mapping and management
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存映射和管理
- en: 'When discussing the memory in Linux, we can refer to it as the physical and
    virtual memory. Compartments of the RAM memory are used for the containment of
    the Linux kernel variables and data structures, the rest of the memory being used
    for dynamic allocations, as described here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论Linux中的内存时，我们可以将其称为物理内存和虚拟内存。RAM内存的隔间用于包含Linux内核变量和数据结构，其余内存用于动态分配，如下所述：
- en: '![Memory mapping and management](img/image00314.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![内存映射和管理](img/image00314.jpeg)'
- en: 'The physical memory defines algorithms and data structures that are able to
    maintain the memory, and it is done at the page level relatively independently
    by the virtual memory. Here, each physical page has a `struct page` descriptor
    associated with it that is used to incorporate information about the physical
    page. Each page has a `struct page` descriptor defined. Some of the fields of
    this structure are as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 物理内存定义了能够维护内存的算法和数据结构，它是在页面级别相对独立地由虚拟内存完成的。在这里，每个物理页面都有一个与之关联的`struct page`描述符，用于包含有关物理页面的信息。每个页面都有一个定义的`struct
    page`描述符。该结构的一些字段如下：
- en: '`_count`: This represents the page counter. When it reaches the `0` value,
    the page is added to the free pages list.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_count`：这代表页面计数器。当它达到`0`值时，页面将被添加到空闲页面列表中。'
- en: '`virtual`: This represents the virtual address associated to a physical page.
    The **ZONE_DMA** and **ZONE_NORMAL** pages are always mapped, while the **ZONE_HIGHMEN**
    are not always mapped.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`虚拟`：这代表与物理页面关联的虚拟地址。**ZONE_DMA**和**ZONE_NORMAL**页面始终被映射，而**ZONE_HIGHMEN**不总是被映射。'
- en: '`flags`: This represents a set of flags that describe the attributes of the
    page.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标志`：这代表了描述页面属性的一组标志。'
- en: 'The zones of the physical memory have been previously. The physical memory
    is split up into multiple nodes that have a common physical address space and
    a fast local memory access. The smallest of them is **ZONE_DMA** between 0 to
    16Mb. The next is **ZONE_NORMAL**, which is the LowMem area between 16Mb to 896Mb,
    and the largest one is **ZONE_HIGHMEM**, which is between 900Mb to 4GB/64Gb. This
    information can be visible both in the preceding and following images:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 物理内存的区域以前已经被划分。物理内存被分割成多个节点，这些节点具有共同的物理地址空间和快速的本地内存访问。其中最小的是**ZONE_DMA**，介于0到16Mb之间。接下来是**ZONE_NORMAL**，它是介于16Mb到896Mb之间的LowMem区域，最大的是**ZONE_HIGHMEM**，介于900Mb到4GB/64Gb之间。这些信息可以在前面和后面的图像中都可见：
- en: '![Memory mapping and management](img/image00315.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![内存映射和管理](img/image00315.jpeg)'
- en: The virtual memory is used both in the user space and the kernel space. The
    allocation for a memory zone implies the allocation of a physical page as well
    as the allocation of an address space area; this is done both in the page table
    and in the internal structures available inside the operating system. The usage
    of the page table differs from one architecture type to another. For the **Complex
    instruction set computing** (**CISC**) architecture, the page table is used by
    the processor, but on a **Reduced instruction set computing** (**RISC**) architecture,
    the page table is used by the core for a page lookup and **translation lookaside
    buffer** (**TLB**) add operations. Each zone descriptor is used for zone mapping.
    It specifies whether the zone is mapped for usage by a file if the zone is read-only,
    copy-on-write, and so on. The address space descriptor is used by the operating
    system to maintain high-level information.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟内存既用于用户空间，也用于内核空间。为内存区域分配意味着分配物理页面以及地址空间区域的分配；这既在页表中，也在操作系统内部可用的内部结构中完成。页表的使用因架构类型而异。对于**复杂指令集计算**（CISC）架构，页表由处理器使用，但对于**精简指令集计算**（RISC）架构，页表由核心用于页查找和**转换查找缓冲器**（TLB）添加操作。每个区域描述符用于区域映射。它指定了区域是否被映射以供文件使用，如果区域是只读的，写时复制的等等。地址空间描述符由操作系统用于维护高级信息。
- en: The memory allocation is different between the user space and kernel space context
    because the kernel space memory allocation is not able to allocate memory in an
    easy manner. This difference is mostly due to the fact that error management in
    the kernel context is not easily done, or at least not in the same key as the
    user space context. This is one of the problems that will be presented in this
    section along with the solutions because it helps readers understand how memory
    management is done in the context of the Linux kernel.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间和内核空间上下文之间的内存分配是不同的，因为内核空间内存分配无法以简单的方式分配内存。这种差异主要是因为内核上下文中的错误管理不容易完成，或者至少不是以与用户空间上下文相同的方式完成。这是本节将介绍的问题之一，以及解决方案，因为它有助于读者了解在Linux内核上下文中如何进行内存管理。
- en: 'The methods used by the kernel for memory handling is the first subject that
    will be discussed here. This is done to make sure that you understand the methods
    used by the kernel to obtain memory. Although the smallest addressable unit of
    a processor is a byte, the **Memory Management Unit** (**MMU**), the unit responsible
    for virtual to physical translation the smallest addressable unit is the page.
    A page''s size varies from one architecture to another. It is responsible for
    maintaining the system''s page tables. Most of 32-bit architectures use 4KB pages,
    whereas the 64-bit ones usually have 8KB pages. For the Atmel SAMA5D3-Xplained
    board, the definition of the `struct page` structure is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 内核用于内存处理的方法是本节将讨论的第一个主题。这是为了确保您了解内核用于获取内存的方法。虽然处理器的最小可寻址单元是字节，但负责虚拟到物理转换的**内存管理单元**（**MMU**）的最小可寻址单元是页面。页面的大小因架构而异。它负责维护系统的页表。大多数32位架构使用4KB页面，而64位架构通常使用8KB页面。对于Atmel
    SAMA5D3-Xplained板，`struct page`结构的定义如下：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is one of the most important fields of the page structure. The `flags`
    field, for example, represents the status of the page; this holds information,
    such as whether the page is dirty or not, locked, or in another valid state. The
    values that are associated with this flag are defined inside the `include/linux/page-flags-layout.h`
    header file. The `virtual` field represents the virtual address associated with
    the page, `count` represents the count value for the page that is usually accessible
    indirectly through the `page_count()` function. All the other fields can be accessed
    inside the `include/linux/mm_types.h` header file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是页面结构中最重要的字段之一。例如，`flags`字段表示页面的状态；这包含信息，例如页面是否脏了，是否被锁定，或者处于另一个有效状态。与此标志相关的值在`include/linux/page-flags-layout.h`头文件中定义。`virtual`字段表示与页面关联的虚拟地址，`count`表示页面的计数值，通常可以通过`page_count()`函数间接访问。所有其他字段都可以在`include/linux/mm_types.h`头文件中找到。
- en: The kernel divides the hardware into various zone of memory, mostly because
    there are pages in the physical memory that are not accessible for a number of
    the tasks. For example, there are hardware devices that can perform DMA. These
    actions are done by interacting with only a zone of the physical memory, simply
    called `ZONE_DMA`. It is accessible between 0-16 Mb for x86 architectures.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 内核将硬件划分为各种内存区域，主要是因为物理内存中有一些页面对于一些任务是不可访问的。例如，有些硬件设备可以执行DMA。这些操作只与物理内存的一个区域进行交互，简称为`ZONE_DMA`。对于x86架构，它在0-16
    Mb之间可访问。
- en: 'There are four main memory zones available and other two less notable ones
    that are defined inside the kernel sources in the `include/linux/mmzone.h` header
    file. The zone mapping is also architecture-dependent for the Atmel SAMA5D3-Xplained
    board. We have the following zones defined:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 内核源代码中定义了四个主要的内存区域和另外两个不太显著的内存区域，这些定义在`include/linux/mmzone.h`头文件中。区域映射也与Atmel
    SAMA5D3-Xplained板的体系结构有关。我们有以下区域定义：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are allocations that require interaction with more than one zone. One
    such example is a normal allocation that is able to use either `ZONE_DMA` or `ZONE_NORMAL`.
    `ZONE_NORMAL` is preferred because it does not interfere with direct memory accesses,
    though when the memory is at full usage, the kernel might use other available
    zones besides the ones that it uses in normal scenarios. The kernel that is available
    is a **struct zone** structure that defines each zone''s relevant information.
    For the Atmel SAMA5D3-Xplained board, this structure is as shown here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些分配需要与多个区域进行交互。一个例子是普通分配，可以使用`ZONE_DMA`或`ZONE_NORMAL`。`ZONE_NORMAL`更受青睐，因为它不会干扰直接内存访问，尽管当内存使用完全时，内核可能会使用除正常情况下使用的区域之外的其他可用区域。可用的内核是一个**struct
    zone**结构，定义了每个区域的相关信息。对于Atmel SAMA5D3-Xplained板，该结构如下所示：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the zone that defines the structure is an impressive one. Some
    of the most interesting fields are represented by the `watermark` variable, which
    contain the high, medium, and low watermarks for the defined zone. The `present_pages`
    attribute represents the available pages within the zone. The `name` field represents
    the name of the zone, and others, such as the `lock` field, a spin lock that shields
    the zone structure for simultaneous access. All the other fields that can be identified
    inside the corresponding `include/linux/mmzone.h` header file for the Atmel SAMA5D3
    Xplained board.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，定义结构的区域是一个令人印象深刻的区域。一些最有趣的字段由`watermark`变量表示，其中包含所定义区域的高、中和低水印。`present_pages`属性表示区域内的可用页面。`name`字段表示区域的名称，还有其他字段，例如`lock`字段，一个用于保护区域结构免受同时访问的自旋锁。所有其他字段都可以在Atmel
    SAMA5D3 Xplained板的相应`include/linux/mmzone.h`头文件中找到。
- en: 'With this information available, we can move ahead and find out how the kernel
    implements memory allocation. All the available functions that are necessary for
    memory allocation and memory interaction in general, are inside the `linux/gfp.h`
    header file. Some of these functions are:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们可以继续并了解内核如何实现内存分配。所有必要的内存分配和内存交互的可用函数都在`linux/gfp.h`头文件中。其中一些函数是：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This function is used to allocate physical pages in a continuous location.
    At the end, the return value is represented by the pointer of the first page structure
    if the allocation is successful, or `NULL` if errors occur:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数用于在连续位置分配物理页面。最后，如果分配成功，则返回值由第一个页面结构的指针表示，如果发生错误，则返回`NULL`：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function is used to get the logical address for a corresponding memory
    page:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数用于获取相应内存页面的逻辑地址：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This one is similar to the `alloc_pages()` function, but the difference is
    that the return variable is offered in the `struct page * alloc_page(gfp_t gfp_mask)`
    return argument:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数类似于`alloc_pages()`函数，但不同之处在于返回变量是在`struct page * alloc_page(gfp_t gfp_mask)`返回参数中提供的：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding two functions are wrappers over similar ones, the difference
    is that this function returns only one page information. The order for this function
    has the `zero` value:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个函数是类似的函数的包装器，不同之处在于这个函数只返回一个页面信息。这个函数的顺序具有`zero`值：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding function does what the name suggests. It returns the page full
    of `zero` values. The difference between this function and the `__get_free_page()`
    function is that after being released, the page is filled with `zero` values:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数就像其名称所示。它返回一个充满`zero`值的页面。这个函数与`__get_free_page()`函数的区别在于，在被释放后，页面被填充为`zero`值：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding functions are used for freeing the given allocated pages. The
    passing of the pages should be done with care because the kernel is not able to
    check the information it is provided.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数用于释放给定的分配页面。传递页面时应谨慎，因为内核无法检查所提供的信息。
- en: Page cache and page writeback
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 页面缓存和页面写回
- en: 'Usually the disk is slower than the physical memory, so this is one of the
    reasons that memory is preferred over disk storage. The same applies for processor''s
    cache levels: the closer it resides to the processor the faster it is for the
    I/O access. The process that moves data from the disk into the physical memory
    is called **page caching**. The inverse process is defined as **page writeback**.
    These two notions will be presented in this subsection, but is it mainly about
    the kernel context.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常磁盘比物理内存慢，所以这是内存优于磁盘存储的原因之一。对于处理器的缓存级别也是一样：它离处理器越近，对I/O访问就越快。将数据从磁盘移动到物理内存的过程称为**页面缓存**。相反的过程被定义为**页面写回**。这两个概念将在本小节中介绍，但主要是关于内核上下文。
- en: The first time the kernel calls the `read()` system call, the data is verified
    if it is present in the page cache. The process by which the page is found inside
    the RAM is called **cache hit**. If it is not available there, then data needs
    to be read from the disk and this process is called **cache miss**.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 内核第一次调用`read()`系统调用时，会验证数据是否存在于页面缓存中。在RAM中找到页面的过程称为**缓存命中**。如果数据不在那里，则需要从磁盘读取数据，这个过程称为**缓存未命中**。
- en: When the kernel issues the **write()** system call, there are multiple possibilities
    for cache interaction with regard to this system call. The easiest one is to not
    cache the write system calls operations and only keep the data in the disk. This
    scenario is called **no-write cache**. When the write operation updates the physical
    memory and the disk data at the same time, the operation is called **write-through
    cache**. The third option is represented by **write-back cache** where the page
    is marked as dirty. It is added to the dirty list and over time, it is put on
    the disk and marked as not dirty. The best synonym for the dirty keyword is represented
    by the synchronized key word.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当内核发出**write()**系统调用时，关于这个系统调用的缓存交互有多种可能性。最简单的一种是不缓存写系统调用操作，只将数据保留在磁盘中。这种情况称为**无写缓存**。当写操作同时更新物理内存和磁盘数据时，该操作称为**写透缓存**。第三个选项由**写回缓存**表示，其中页面被标记为脏。它被添加到脏列表中，随着时间的推移，它被放在磁盘上并标记为非脏。脏关键字的最佳同义词由同步关键字表示。
- en: The process address space
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进程地址空间
- en: Besides its own physical memory, the kernel is also responsible for user space
    process and memory management. The memory allocated for each user space process
    is called **process address space** and it contains the virtual memory addressable
    by a given process. It also contains the related addresses used by the process
    in its interaction with the virtual memory.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自己的物理内存外，内核还负责用户空间进程和内存管理。为每个用户空间进程分配的内存称为**进程地址空间**，它包含给定进程可寻址的虚拟内存地址。它还包含进程在与虚拟内存交互时使用的相关地址。
- en: Usually a process receives a flat 32 or 64-bit address space, its size being
    dependent on the architecture type. However, there are operating systems that
    allocate a **segmented address space**. The possibility of sharing the address
    space between the operating systems is offered to threads. Although a process
    can access a large memory space, it usually has permission to access only an interval
    of memory. This is called a **memory area** and it means that a process can only
    access a memory address situated inside a viable memory area. If it somehow tries
    to administrate a memory address outside of its valid memory area, the kernel
    will kill the process with the *Segmentation fault* notification.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，进程接收一个平面的32位或64位地址空间，其大小取决于体系结构类型。然而，有些操作系统分配了**分段地址空间**。在线程之间提供了共享地址空间的可能性。虽然进程可以访问大量的内存空间，但通常只有权限访问内存的一部分。这被称为**内存区域**，意味着进程只能访问位于可行内存区域内的内存地址。如果它尝试管理位于其有效内存区域之外的内存地址，内核将使用*段错误*通知终止进程。
- en: 'A memory area contains the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 内存区域包含以下内容：
- en: The `text` section maps source code
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`部分映射源代码'
- en: The `data` section maps initialized global variables
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数据`部分映射已初始化的全局变量'
- en: The `bss` section maps uninitialized global variables
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bss`部分映射未初始化的全局变量'
- en: The `zero page` section is used to process user space stack
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`零页`部分用于处理用户空间堆栈'
- en: The `shared libraries text`, `bss` and data-specific sections
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`共享库文本`，`bss`和数据特定部分'
- en: Mapped files
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射文件
- en: Anonymous memory mapping is usually linked with functions, such as `malloc()`
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名内存映射通常与`malloc()`等函数相关联
- en: Shared memory segments
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享内存段
- en: A process address space is defined inside the Linux kernel source through a
    **memory descriptor**. This structure is called `struct mm_struct`, which is defined
    inside the `include/linux/mm_types.h` header file and contains information relevant
    for a process address space, such as the number of processes that use the address
    space, a list of memory areas, the last memory area that was used, the number
    of memory areas available, start and finish addresses for the code, data, heap
    and stack sections.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 进程地址空间在Linux内核源代码中通过**内存描述符**进行定义。这个结构被称为`struct mm_struct`，它在`include/linux/mm_types.h`头文件中定义，并包含与进程地址空间相关的信息，如使用地址空间的进程数量、内存区域列表、最后使用的内存区域、可用的内存区域数量、代码、数据、堆和栈部分的起始和结束地址。
- en: For a kernel thread, no process address space associated with it; for kernel,
    the process descriptor structure is defined as `NULL`. In this way, the kernel
    mentions that a kernel thread does not have a user context. A kernel thread only
    has access to the same memory as all the other processes. A kernel thread does
    not have any pages in a user space or access to the user space memory.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内核线程，没有与之关联的进程地址空间；对于内核来说，进程描述符结构被定义为`NULL`。这样，内核表明内核线程没有用户上下文。内核线程只能访问与所有其他进程相同的内存。内核线程没有用户空间中的任何页面或对用户空间内存的访问权限。
- en: Since the processors work only with physical addresses, the translation between
    physical and virtual memory needs to be made. These operations are done by the
    page tables that split the virtual addresses into smaller components with associated
    indexes that are used for pointing purposes. In the majority of available boards
    and architectures in general, the page table lookup is handled by the hardware;
    the kernel is responsible for setting it up.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于处理器只能使用物理地址，因此需要进行物理和虚拟内存之间的转换。这些操作由页表完成，页表将虚拟地址分割为较小的组件，并具有用于指向目的的关联索引。在大多数可用的板和体系结构中，页表查找由硬件处理；内核负责设置它。
- en: Process management
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程管理
- en: A process, as presented previously, is a fundamental unit in a Linux operating
    system and at the same time, is a form of abstraction. It is, in fact, a program
    in execution, but a program by itself is not a process. It needs to be in an active
    state and have associated resources. A process is able to become a parent by using
    the `fork()` function, which spawns a child process. Both parent and child processes
    reside in separate address spaces, but both of them have the same content. The
    `exec()` family of function is the one that is able to execute a different program,
    create an address space, and load it inside that address space.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是Linux操作系统中的基本单元，同时也是一种抽象形式。实际上，它是一个正在执行的程序，但程序本身不是一个进程。它需要处于活动状态并具有相关联的资源。通过使用`fork()`函数，进程能够成为父进程，从而生成一个子进程。父进程和子进程都驻留在单独的地址空间中，但它们都具有相同的内容。`exec()`函数族能够执行不同的程序，创建一个地址空间，并将其加载到该地址空间中。
- en: 'When `fork()` is used, the resources that the parent process has are reproduced
    for the child. This function is implemented in a very interesting manner; it uses
    the `clone()` system call that, at it''s base, contains the `copy_process()` function.
    This functions does the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fork()`时，父进程的资源会被复制给子进程。这个函数的实现方式非常有趣；它使用`clone()`系统调用，其基础包含`copy_process()`函数。这个函数执行以下操作：
- en: Calls the `dup_task_struct()` function to create a new kernel stack. The `task_struct`
    and `thread_info` structures are created for a new process.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`dup_task_struct()`函数创建一个新的内核栈。为新进程创建`task_struct`和`thread_info`结构。
- en: Checks that the child does not go beyond the limits of the memory area.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查子进程是否超出内存区域的限制。
- en: The child process distinguishes itself from its parent.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子进程与父进程有所不同。
- en: It is set as `TASK_UNINTERRUPTIBLE` to make sure it does not run.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其设置为`TASK_UNINTERRUPTIBLE`以确保它不运行。
- en: Flags are updated.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新标志。
- en: '`PID` is associated with the child process.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PID`与子进程相关联。'
- en: The flags that are already set are inspected and proper action is performed
    with respect to their values.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查已设置的标志，并根据它们的值执行适当的操作。
- en: The clean process is performed at the end when the child process pointer is
    obtained.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在获取子进程指针时执行清理过程。
- en: Threads in Linux are very similar to processes. They are viewed as processes
    that share various resources, such as memory address space, open files, and so
    on. The creation of threads is similar to a normal task, the exception being the
    `clone()` function, which passes flags that mention shared resources. For example,
    the clone function calls for a thread, which is `clone(CLONE_VM | CLONE_FS | CLONE_FILES
    | CLONE_SIGHAND, 0)`, while for the normal fork looks similar to `clone(SIGCHLD,
    0)`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中的线程与进程非常相似。它们被视为共享各种资源（如内存地址空间、打开文件等）的进程。线程的创建类似于普通任务，唯一的例外是`clone()`函数，它传递了提到共享资源的标志。例如，clone函数调用一个线程，即`clone(CLONE_VM
    | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)`，而对于正常的fork看起来类似于`clone(SIGCHLD,
    0)`。
- en: The notion of kernel threads appeared as a solution to problems involving tasks
    running in the background of the kernel context. The kernel thread does not have
    an address space and is only available inside the kernel context. It has the same
    properties as a normal process, but is only used for special tasks, such as `ksoftirqd`,
    `flush`, and so on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 内核线程的概念出现是为了解决在内核上下文的后台运行任务所涉及的问题。内核线程没有地址空间，只能在内核上下文中使用。它具有与普通进程相同的属性，但仅用于特殊任务，如`ksoftirqd`、`flush`等。
- en: 'At the end of the execution, the process need to be terminated so that the
    resources can be freed, and the parent of the executing process needs to be notified
    about this. The method that is most used to terminate a process is done by calling
    the `exit()` system call. A number of steps are needed for this process:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行结束时，需要终止进程以释放资源，并通知执行进程的父进程。最常用于终止进程的方法是调用`exit()`系统调用。此过程需要一些步骤：
- en: The `PF_EXITING` flag is set.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`PF_EXITING`标志。
- en: The `del_timer_sync()` function is called to remove the kernel timers.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`del_timer_sync()`函数来删除内核定时器。
- en: The `acct_update_integrals()` function is called when writing accounting and
    logging information.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写会计和日志信息时调用`acct_update_integrals()`函数。
- en: The `exit_mm()` is called to release the `mm_struct` structure for the process.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`exit_mm()`来释放进程的`mm_struct`结构。
- en: The `exit_sem()` is called to dequeue the process from the IPC semaphore.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`exit_sem()`来从IPC信号量中出队进程。
- en: The `exit_files()` and `exit_fs()` function are called to remove the links to
    various files descriptors.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`exit_files()`和`exit_fs()`函数来删除与各种文件描述符的链接。
- en: The task exit code should be set.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应设置任务退出代码。
- en: Call `exit_notify()` to notify the parent and set the task exit state to `EXIT_ZOMBIE`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`exit_notify()`通知父进程，并将任务退出状态设置为`EXIT_ZOMBIE`。
- en: Call `schedule()` to switch to a new process.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`schedule()`切换到新进程。
- en: After the preceding steps are performed, the object associated with this task
    is freed and it becomes unrunnable. Its memory exists solely as information for
    its parent. After its parent announces that this information is of no use to it,
    this memory is freed for the system to use.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行了前述步骤之后，与该任务关联的对象被释放，并且变得不可运行。它的内存仅作为其父进程的信息存在。在其父进程宣布此信息对其无用后，此内存将被系统释放使用。
- en: Process scheduling
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程调度
- en: The process scheduler decides which resources are allocated for a runnable process.
    It is a piece of software that is responsible for multitasking, resource allocation
    to various processes, and decides how to best set the resources and processor
    time. it also decides which processes should run next.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 进程调度程序决定为可运行的进程分配哪些资源。它是一种负责多任务处理、资源分配给各种进程，并决定如何最佳设置资源和处理器时间的软件。它还决定哪些进程应该接下来运行。
- en: The first design of the Linux scheduler was very simplistic. It was not able
    to scale properly when the number of processes increased, so from the 2.5 kernel
    version, a new scheduler was developed. It is called **O(1) scheduler** and offers
    a constant time algorithm for time slice calculation and a run queue that is defined
    on a per-processor basis. Although it is perfect for large servers, it is not
    the best solution for a normal desktop system. From the 2.6 kernel version, improvements
    have been made to the O(1) scheduler, such as the fair scheduling concept that
    later materialized from the kernel version 2.6.23 into the **Completely Fair Scheduler**
    (**CFS**), which became the defacto scheduler.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Linux调度程序的第一个设计非常简单。当进程数量增加时，它无法很好地扩展，因此从2.5内核版本开始，开发了一个新的调度程序。它被称为**O(1)调度程序**，为时间切片计算提供了常数时间算法，并且在每个处理器基础上定义了运行队列。虽然它非常适合大型服务器，但并不是普通桌面系统的最佳解决方案。从2.6内核版本开始，对O(1)调度程序进行了改进，例如公平调度概念，后来从内核版本2.6.23实现为**完全公平调度程序**（**CFS**），成为事实上的调度程序。
- en: The CFC has a simple idea behind. It behaves as if we have a perfect multitasking
    processor where each process gets `1/n` slice of the processor's time and this
    time slice is an incredibly small. The `n` value represents the number of running
    processes. Con Kolivas is the Australian programmer that contributed to the fair
    scheduling implementation, also known as **Rotating Staircase Deadline Scheduler**
    (**RSDL**). Its implementation required a red-black tree for the priorities of
    self-balancing and also a time slice that is calculated at the nanosecond level.
    Similarly to the O(1) scheduler, CFS applies the notion of weight, which implies
    that some processes wait more than others. This is based on the weighed fair queuing
    algorithm.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: CFS背后有一个简单的想法。它表现得好像我们有一个完美的多任务处理器，每个进程都获得处理器时间的`1/n`切片，而这个时间切片非常小。`n`值代表正在运行的进程数。Con
    Kolivas是澳大利亚程序员，他为公平调度实现做出了贡献，也被称为**旋转楼梯截止时间调度器**（**RSDL**）。它的实现需要一个红黑树来平衡自身的优先级，还需要在纳秒级别计算的时间切片。与O(1)调度程序类似，CFS应用了权重的概念，这意味着一些进程等待的时间比其他进程长。这是基于加权公平排队算法的。
- en: A process scheduler constitutes one of the most important components of the
    Linux kernel because it defines the user interaction with the operating system
    in general. The Linux kernel CFS is the scheduler that appeals to developers and
    users because it offers scalability and performance with the most reasonable approach.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 进程调度程序构成了Linux内核中最重要的组件之一，因为它定义了用户与操作系统的一般交互。Linux内核CFS是调度程序，吸引开发人员和用户的原因是它以最合理的方式提供了可伸缩性和性能。
- en: System calls
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统调用
- en: 'For processes to interact with a system, an interface should be provided to
    give the user space application the possibility of interacting with hardware and
    other `processes.System` calls. These are used as an interface between the hardware
    and the user space. They are also used to ensure stability, security, and abstraction,
    in general. These are common layers that constitute an entry point into the kernel
    alongside traps and exceptions, as described here:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使进程与系统交互，应该提供一个接口，使用户空间应用程序能够与硬件和其他进程进行交互。这些被用作硬件和用户空间之间的接口。它们也被用于确保稳定性、安全性和抽象性。这些是构成内核入口点的常见层，以及陷阱和异常，如下所述：
- en: '![System calls](img/image00316.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![系统调用](img/image00316.jpeg)'
- en: 'The interaction with most of the system calls that are available inside the
    Linux system is done using the C library. They are able to define a number of
    arguments and return a value that reveals whether they were successful or not.
    A value of `zero` usually means that the execution ended with success, and in
    case errors appear, an error code will be available inside the `errno` variable.
    When a system call is done, the following steps are followed:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与Linux系统内大多数系统调用的交互是通过C库完成的。它们能够定义一些参数并返回一个值，以显示它们是否成功。通常，值为`零`表示执行成功，如果出现错误，则`errno`变量中将可用错误代码。进行系统调用时，遵循以下步骤：
- en: The switch into kernel mode is made.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到内核模式。
- en: Any restrictions to the kernel space access are eliminated.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对内核空间访问的任何限制都被消除。
- en: The stack from the user space is passed into the kernel space.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户空间的堆栈被传递到内核空间。
- en: Any arguments from the user space are checked and copied into the kernel space.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自用户空间的任何参数都会被检查并复制到内核空间。
- en: The associated routine for the system call is identified and run.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别并运行与系统调用相关的例程。
- en: The switch to the user space is made and the execution of the application continues.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到用户空间并继续执行应用程序。
- en: A system call has a `syscall` number associated with it, which is a unique number
    used as a reference for the system call that cannot be changed (there is no possibility
    of implementing a system call). A symbolic constant for each system call number
    is available in the `<sys/syscall.h>` header file. To check the existence of a
    system call, `sys_ni_syscall()` is used, which returns the `ENOSYS` error for
    an invalid system call.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用有与之关联的`syscall`号码，这是一个唯一的数字，用作系统调用的参考，不能更改（无法实现系统调用）。每个系统调用号码的符号常量都在`<sys/syscall.h>`头文件中可用。要检查系统调用的存在，使用`sys_ni_syscall()`，它对于无效的系统调用返回`ENOSYS`错误。
- en: The virtual file system
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟文件系统
- en: The Linux operating system is able to support a large variety of filesystem
    options. This is done due to the existence of **Virtual File System** (**VFS**),
    which is able to provide a common interface for a large number of filesystem types
    and handle the systems calls relevant to them.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Linux操作系统能够支持多种文件系统选项。这是由于存在**虚拟文件系统**（**VFS**），它能够为大量文件系统类型提供一个通用接口，并处理与它们相关的系统调用。
- en: 'The filesystem types supported by the VFS can be put in these three categories:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: VFS支持的文件系统类型可以分为以下三类：
- en: '**Disk-based filesystems**: These manage the memory on a local disk or devices
    that are used for disk emulation. Some of the most well known ones are:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于磁盘的文件系统**：这些管理本地磁盘或用于磁盘仿真的设备上的内存。其中一些最著名的是：'
- en: Linux filesystems, such as Second Extended Filesystem (Ext2), Third Extended
    Filesystem (Ext3), and Forth Extended Filesystem (Ext4)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux文件系统，如第二扩展文件系统（Ext2），第三扩展文件系统（Ext3）和第四扩展文件系统（Ext4）
- en: UNIX filesystems, such as sysv filesystem, UFS, Minix filesystem, and so on
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UNIX文件系统，如sysv文件系统，UFS，Minix文件系统等
- en: Microsoft filesystems, such as MS-DOS, NTFS (available since Windows NT), and
    VFAT (available since Windows 95)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软文件系统，如MS-DOS，NTFS（自Windows NT起可用）和VFAT（自Windows 95起可用）
- en: ISO966 CD-ROM filesystem and disk format DVD filesystem
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO966 CD-ROM文件系统和磁盘格式DVD文件系统
- en: Proprietary filesystems, such as the ones from Apple, IBM, and other companies
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专有文件系统，如来自苹果、IBM和其他公司的文件系统
- en: '**Network filesystems**: They are allowed to access various filesystem types
    over a network on other computers. One of the most well known ones is NFS. Of
    course, there are others but they are not as well known. These include **Andrew
    filesystem** (**AFS**), **Novel''s NetWare Core Protocol** (**NCP**), **Constant
    Data Availability** (**Coda**), and so on.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络文件系统**：它们允许在其他计算机上通过网络访问各种文件系统类型。其中最著名的之一是NFS。当然，还有其他一些，但它们不那么出名。这些包括**Andrew文件系统**（**AFS**），**Novel的NetWare
    Core Protocol**（**NCP**），**Constant Data Availability**（**Coda**）等。'
- en: '**Special filesystems**: The `/proc` filesystem is the perfect example for
    this category of filesystems. This category of filesystems enables an easier access
    for system applications to interrogate data structures of kernels and implement
    various features.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特殊文件系统**：`/proc`文件系统是这类文件系统的完美例子。这类文件系统使系统应用程序更容易地访问内核的数据结构并实现各种功能。'
- en: 'The virtual filesystem system call implementation is very well summarized in
    this image:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟文件系统系统调用的实现在这张图片中得到了很好的总结：
- en: '![The virtual file system](img/image00317.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![虚拟文件系统](img/image00317.jpeg)'
- en: In the preceding image, it can be seen how easily the copy is handled from one
    filesystem type to another. It only uses the basic `open()`, `close()`, `read()`,
    `write()` functions available for all the other filesystem interaction. However,
    all of them implement the specific functionality underneath for the chosen filesystem.
    For example, the `open()` system calls `sys_open()`and it takes the same arguments
    as `open()` and returns the same result. The difference between `sys_open()` and
    `open()` is that `sys_open()` is a more permissive function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，可以看到如何轻松地从一种文件系统类型复制到另一种文件系统类型。它只使用基本的`open()`、`close()`、`read()`、`write()`函数，这些函数对所有其他文件系统交互都可用。然而，它们都在所选文件系统下实现了特定的功能。例如，`open()`系统调用`sys_open()`，它接受与`open()`相同的参数并返回相同的结果。`sys_open()`和`open()`之间的区别在于`sys_open()`是一个更宽松的函数。
- en: All the other three system calls have corresponding `sys_read()`, `sys_write()`,
    and `sys_close()` functions that are called internally.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 其他三个系统调用都有相应的`sys_read()`、`sys_write()`和`sys_close()`函数在内部调用。
- en: Interrupts
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断
- en: An interrupt is a representation of an event that changes the succession of
    instructions performed by the processor. Interrupts imply an electric signal generated
    by the hardware to signal an event that has happened, such as a key press, reset,
    and so on. Interrupts are divided into more categories depending on their reference
    system, as follows:.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 中断是表示改变处理器执行指令顺序的事件的表示。中断意味着硬件生成的电信号，用于表示已发生的事件，例如按键、复位等。根据其参考系统，中断分为更多类别，如下所示：
- en: 'Software interrupts: These are usually exceptions triggered from external devices
    and user space programs'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件中断：这些通常是从外部设备和用户空间程序触发的异常
- en: 'Hardware interrupts: These are signals from the system that usually indicate
    a processor specific instruction'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件中断：这些是系统发出的信号，通常表示处理器特定的指令
- en: The Linux interrupt handling layer offers an abstraction of interrupt handling
    for various device drivers through comprehensive API functions. It is used to
    request, enable, disable, and free interrupts, making sure that portability is
    guaranteed on multiple platforms. It handles all available interrupt controller
    hardware.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中断处理层通过全面的API函数为各种设备驱动程序提供了中断处理的抽象。它用于请求、启用、禁用和释放中断，确保在多个平台上保证可移植性。它处理所有可用的中断控制器硬件。
- en: 'The generic interrupt handling uses the `__do_IRQ()` handler, which is able
    to deal with all the available types of the interrupt logic. The handling layers
    are divided in two components:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通用中断处理使用`__do_IRQ()`处理程序，能够处理所有可用类型的中断逻辑。处理层分为两个组件：
- en: The top half component is used to respond to the interrupt
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶部组件用于响应中断
- en: The bottom half component is scheduled by the top half to run at a later time
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶部组件安排底部在稍后运行
- en: The difference between them is that all the available interrupts are permitted
    to act in the bottom half context. This helps the top half respond to another
    interrupt while the bottom half is working, which means that it is able to save
    its data in a specific buffer and it permits the bottom half to operate in a safe
    environment.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间的区别在于所有可用的中断都被允许在底部上下文中执行。这有助于顶部在底部工作时响应另一个中断，这意味着它能够将其数据保存在特定的缓冲区中，并允许底部在安全环境中运行。
- en: 'For the bottom half processing, there are four defined mechanisms available:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于底部处理，有四种定义好的机制可用：
- en: '**Softirqs**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软中断**'
- en: '**Tasklets**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tasklets**'
- en: '**Work queues**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作队列**'
- en: '**Kernel threads**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核线程**'
- en: 'The available mechanisms are well presented here:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了可用的机制：
- en: '![Interrupts](img/image00318.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![中断](img/image00318.jpeg)'
- en: 'Although the model for the top and bottom half interrupt mechanism looks simple,
    it has a very complicated function calling mechanism model. This example shows
    this fact for the ARM architecture:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管顶部和底部中断机制的模型看起来很简单，但它具有非常复杂的函数调用机制模型。这个例子展示了ARM架构的这一事实：
- en: '![Interrupts](img/image00319.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![中断](img/image00319.jpeg)'
- en: For the top half component of the interrupt, there are three levels of abstraction
    in the interrupt source code. The first one is the high-level driver API that
    has functions, such as `request_irq()`, `free_irq`, `disable_irq()`, `enable_irq()`,
    and so on. The second one is represented by the high-level IRQ flow handlers,
    which is a generic layer with predefined or architecture-specific interrupt flow
    handlers assigned to respond to various interrupts during device initialization
    or boot time. It defines a number of predefined functions, such as `handle_level_irq()`,
    `handle_simple_irq()`, `handle_percpu_irq()`, and so on. The third is represented
    by chip-level hardware encapsulation. It defines the `struct irq_chip` structure
    that holds chip-relevant functions used in the IRQ flow implementation. Some of
    the functions are `irq_ack()`, `irq_mask()`, and `irq_unmask()`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于中断的顶部组件，在中断源代码中有三个抽象级别。第一个是高级驱动程序API，具有函数，如`request_irq()`、`free_irq`、`disable_irq()`、`enable_irq()`等。第二个由高级IRQ流处理程序表示，这是一个通用层，具有预定义或特定架构的中断流处理程序，用于在设备初始化或引导时响应各种中断。它定义了一些预定义函数，如`handle_level_irq()`、`handle_simple_irq()`、`handle_percpu_irq()`等。第三个由芯片级硬件封装表示。它定义了`struct
    irq_chip`结构，其中包含在IRQ流实现中使用的与芯片相关的函数。其中一些函数是`irq_ack()`、`irq_mask()`和`irq_unmask()`。
- en: 'A module is required to register an interrupt channel and release it afterwards.
    The total number of supported requests is counted from the `0` value to the number
    of IRQs-1\. This information is available inside the `<asm/irq.h>` header file.
    When the registration is done, a handler flag is passed to the `request_irq()`
    function to specify the interrupt handler''s type, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 模块需要注册中断通道并在之后释放它。支持的请求总数从`0`值计数到IRQs的数量-1。这些信息在`<asm/irq.h>`头文件中可用。注册完成后，将处理程序标志传递给`request_irq()`函数，以指定中断处理程序的类型，如下所示：
- en: '`SA_SAMPLE_RANDOM`: This indicates that the interrupt can contribute to the
    entropy pool, that is, a pool with bits that possess a strong random property,
    by sampling unpredictable events, such as mouse movement, inter-key press time,
    disk interrupts, and so on'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SA_SAMPLE_RANDOM`：这表明中断可以为熵池做出贡献，即具有强随机属性的位的池，通过对不可预测事件进行采样，例如鼠标移动、按键间的时间、磁盘中断等'
- en: '`SA_SHIRQ`: This shows that the interrupt is sharable between devices.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SA_SHIRQ`：这表明中断可以在设备之间共享。'
- en: '`SA_INTERRUPT`: This indicates a fast interrupt handler, so interrupts are
    disabled on the current processor-it does not represent a situation that is very
    desirable'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SA_INTERRUPT`：这表示快速中断处理程序，因此在当前处理器上禁用中断-这并不是一个非常理想的情况'
- en: Bottom halves
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 底半部
- en: The first mechanism that will be discussed regarding bottom half interrupt handling
    is represented by `softirqs`. They are rarely used but can be found on the Linux
    kernel source code inside the `kernel/softirq.c` file. When it comes to implementation,
    they are statically allocated at the compile step. They are created when an entry
    is added in the `include/linux/interrupt.h` header file and the system information
    they provide is available inside the /`proc/softirqs` file. Although not used
    too often, they can be executed after exceptions, interrupts, system calls, and
    when the `ksoftirkd` daemon is run by the scheduler.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 关于底半部中断处理的第一个机制是由`softirqs`代表的。它们很少使用，但可以在Linux内核源代码中的`kernel/softirq.c`文件中找到。在实现方面，它们在编译步骤时静态分配。当在`include/linux/interrupt.h`头文件中添加条目时，它们被创建，并且它们提供的系统信息可以在`/proc/softirqs`文件中找到。虽然不经常使用，但它们可以在异常、中断、系统调用以及由调度程序运行`ksoftirkd`守护程序后执行。
- en: 'Next on the list are tasklets. Although they are built on top of `softirqs`,
    they are more commonly used for bottom half interrupt handling. Here are some
    of the reasons why this is done:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的下一个是任务let。虽然它们建立在`softirqs`之上，但它们更常用于底半部中断处理。以下是这样做的一些原因：
- en: They are very fast
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们非常快
- en: They can be created and destroyed dynamically
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以动态创建和销毁
- en: They have atomic and nonblocking code
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们具有原子和非阻塞代码
- en: They run in a soft interrupt context
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在软中断上下文中运行
- en: They run on the same processor that they were scheduled for
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在被调度的同一处理器上运行
- en: Tasklets have a **struct tasklet_struct** structure available. These are also
    available inside the `include/linux/interrupt.h` header file, and unlike `softirqs`,
    tasklets are non-reentrant.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 任务let有一个**struct tasklet_struct**结构可用。这些也可以在`include/linux/interrupt.h`头文件中找到，与`softirqs`不同，任务let是不可重入的。
- en: 'Third on the list are work queues that represent a different form of doing
    the work allotted in comparison to previously presented mechanisms. The main differences
    are as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的第三个是工作队列，它代表了与先前介绍的机制相比进行工作分配的不同形式。主要区别如下：
- en: They are able run in the same time on more the one CPU
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们能够同时在多个CPU上运行
- en: They are allowed to go to sleep
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以进入睡眠状态
- en: They runs on a process context
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在进程上下文中运行
- en: They can be scheduled or preempted
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以被调度或抢占
- en: Although they might have a latency that is slightly bigger the tasklets, the
    preceding qualities are really useful. The tasklets are built around the `struct
    workqueue_struct` structure, available inside the `kernel/workqueue.c` file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们可能具有比任务let稍大的延迟，但前述特性确实非常有用。任务let是围绕`struct workqueue_struct`结构构建的，该结构位于`kernel/workqueue.c`文件中。
- en: The last and the newest addition to the bottom half mechanism options is represented
    by the kernel threads that are operated entirely in the kernel mode since they
    are created/destroyed by the kernel. They appeared during the 2.6.30 kernel release,
    and also have the same advantages as the work queues, along with some extra features,
    such as the possibility of having their own context. It is expected that eventually
    the kernel threads will replace the work queues and tasklets, since they are similar
    to the user space threads. A driver might want to request a threaded interrupt
    handler. All it needs to do in this case is to use `request_threaded_irq()` in
    a similar way to `request_irq()`. The `request_threaded_irq()` function offers
    the possibility of passing a handler and `thread_fn` to split the interrupt handling
    code into two parts. In addition to this, `quick_check_handler` is called to check
    if the interrupt was called from a device; if that is the case, it will need to
    call `IRQ_WAKE_THREAD` to wake up the handler thread and execute `thread_fn`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 底半部机制选项中的最后一个和最新的添加是由内核线程代表的，它们完全在内核模式下操作，因为它们是由内核创建/销毁的。它们出现在2.6.30内核发布中，并且具有与工作队列相同的优势，以及一些额外的功能，例如拥有自己的上下文的可能性。预计内核线程最终将取代工作队列和任务let，因为它们类似于用户空间线程。驱动程序可能希望请求线程化的中断处理程序。在这种情况下，它只需要类似于`request_irq()`的方式使用`request_threaded_irq()`。`request_threaded_irq()`函数提供了将中断处理代码分成两部分的处理程序和`thread_fn`的可能性。除此之外，还调用`quick_check_handler`来检查中断是否来自设备；如果是这种情况，它将需要调用`IRQ_WAKE_THREAD`来唤醒处理程序线程并执行`thread_fn`。
- en: Methods to perform kernel synchronization
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行内核同步的方法
- en: 'The number of requests with which a kernel is dealing is likened to the number
    of requests a server has to receive. This situation can deal with race conditions,
    so a good synchronization method would be required. A number of policies are available
    for the way the kernel behaves by defining a kernel control path. Here is an example
    of a kernel control path:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 内核正在处理的请求数量类似于服务器必须接收的请求数量。这种情况可能会导致竞争条件，因此需要一个良好的同步方法。有多种策略可用于定义内核控制路径的方式。以下是一个内核控制路径的示例：
- en: '![Methods to perform kernel synchronization](img/image00320.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![执行内核同步的方法](img/image00320.jpeg)'
- en: The preceding image offers a clear picture as to why synchronization is necessary.
    For example, a race condition can appear when more than one kernel control path
    is interlinked. To protect these critical regions, a number of measures should
    be taken. Also, it should be taken into consideration that an interrupt handler
    cannot be interrupted and `softirqs` should not be interleaved.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像清楚地说明了为什么同步是必要的。例如，当多个内核控制路径相互关联时，可能会出现竞争条件。为了保护这些关键区域，应采取一些措施。还应考虑到中断处理程序不能被中断，`softirqs`不应该交错。
- en: 'A number of synchronization primitives have been born:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 已经诞生了许多同步原语：
- en: '**Per-CPU variables**: This is one of the most simple and efficient synchronization
    methods. It multiplies a data structure so that each one is available for each
    CPU.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每CPU变量**：这是最简单和有效的同步方法之一。它将数据结构乘以每个CPU可用。'
- en: '**Atomic operations**: This refers to atomic read-modify-write instructions.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子操作**：这指的是原子读-修改-写指令。'
- en: '**Memory barrier**: This safeguards the fact that the operations done before
    the barrier are all finished before starting the operations after it.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存屏障**：这保证了在屏障之前完成的操作在开始屏障之后的操作之前全部完成。'
- en: '**Spin lock**: This represents a type of lock that implements bust waiting.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自旋锁**：这代表一种实现忙等待的锁类型。'
- en: '**Semaphore**: This is a form of locking that implements sleep or blocking
    waiting.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号量**：这是一种实现休眠或阻塞等待的锁形式。'
- en: '**Seqlocks**: This is similar to spin locks, but is based on an access counter.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Seqlocks**：这类似于自旋锁，但基于访问计数器。'
- en: '**Local interrupt disabling**: This forbids the use of functions that can be
    postponed on a single CPU.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地中断禁用**：这禁止了可以在单个CPU上延迟使用的功能。'
- en: '**Read-copy-update(RCU)**: This is a method designed to protect the most used
    data structures used for reading. It offers a lock-free access to shared data
    structures using pointers.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读-拷贝-更新（RCU）**：这是一种旨在保护用于读取的最常用数据结构的方法。它使用指针为共享数据结构提供无锁访问。'
- en: With the preceding methods, race condition situations try to be fixed. It is
    the job of the developer to identify and solve all the eventual synchronization
    problems that might appear.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述方法，竞争条件情况试图得到解决。开发人员的工作是识别和解决可能出现的所有同步问题。
- en: Timers
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时器
- en: Around the Linux kernel, there are a great number of functions that are influenced
    by time. From the scheduler to the system uptime, they all require a time reference,
    which includes both absolute and relative time. For example, an event that needs
    to be scheduled for the future, represents a relative time, which, in fact, implies
    that there is a method used to count time.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux内核周围，有许多受时间影响的函数。从调度程序到系统正常运行时间，它们都需要一个时间参考，包括绝对时间和相对时间。例如，需要安排在未来进行的事件代表相对时间，实际上意味着有一种方法用于计算时间。
- en: The timer implementation can vary depending on the type of the event. The periodical
    implementations are defined by the system timer, which issues an interrupt at
    a fixed period of time. The system timer is a hardware component that issues a
    timer interrupt at a given frequency to update the system time and execute the
    necessary tasks. Another one that can be used is the real-time clock, which is
    a chip with a battery attached that keeps counting time long after the system
    was shut down. Besides the system time, there are dynamic timers available that
    are managed by the kernel dynamically to plan events that run after a particular
    time has passed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器的实现可以根据事件类型而变化。周期性实现由系统定时器定义，它以固定时间间隔发出中断。系统定时器是一个硬件组件，以给定频率发出定时器中断，以更新系统时间并执行必要的任务。还可以使用实时时钟，它是一个带有电池的芯片，即使在系统关闭后也能继续计时。除了系统时间，内核动态管理的动态定时器也可用于计划在特定时间后运行的事件。
- en: The timer interrupt has an occurrence window and for ARM, it is 100 times per
    second. This is called the **system timer frequency** or **tick rate** and its
    unit of measurement is **hertz** (**Hz**). The tick rate differs from one architecture
    to another. If for the most of them, we have the value of 100 Hz, there are others
    that have values of 1024 Hz, such as the Alpha and Itanium (IA-64) architectures,
    for example. The default value, of course, can be changed and increased, but this
    action has its advantages and disadvantages.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器中断具有发生窗口，对于ARM来说，每秒发生100次。这称为**系统定时器频率**或**滴答率**，其单位是**赫兹**（**Hz**）。滴答率因架构而异。对于大多数架构，我们有100
    Hz的值，还有其他架构的值为1024 Hz，例如Alpha和Itanium（IA-64）架构。当然，默认值可以更改和增加，但这种操作有其优点和缺点。
- en: 'Some of the advantages of higher frequency are:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 更高频率的一些优点包括：
- en: The timer will be executed more accurately and in a larger number
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器将更准确地执行，并且数量更多。
- en: System calls that use a timeout are executed in a more precise manner
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用超时的系统调用以更精确的方式执行
- en: Uptime measurements and other similar measurements are becoming more precise
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常运行时间测量和其他类似测量变得更加精确
- en: The preemption of process is more accurate
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程抢占更准确
- en: The disadvantages of higher frequency on the other hand, implies a higher overhead.
    The processors spend more time in a timer interrupt context; also, an increase
    in power consumption will take place because more computing is done.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，更高频率的缺点意味着更高的开销。处理器在定时器中断上花费更多时间；此外，由于进行了更多的计算，将会发生功耗的增加。
- en: The total number of ticks done on a Linux operation system from the time it
    started booting is stored in a variable called **jiffies** inside the `include/linux/jiffies.h`
    header file. At boot time, this variable is initialized to zero and one is added
    to its value each time an interrupt happens. So, the actual value of the system
    uptime can be calculated in the form of jiffies/Hz.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Linux操作系统上的总ticks数，从启动开始计时，存储在`include/linux/jiffies.h`头文件中的一个名为**jiffies**的变量中。在启动时，这个变量被初始化为零，并且每次发生中断时都会将其值加一。因此，系统正常运行时间的实际值可以以jiffies/Hz的形式计算出来。
- en: Linux kernel interaction
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux内核交互
- en: Until now, you were introduced to some of features of the Linux kernel. Now,
    it is time to present more information about the development process, versioning
    scheme, community contributions, and and interaction with the Linux kernel.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经了解了Linux内核的一些特性。现在，是时候介绍更多关于开发过程、版本控制方案、社区贡献以及与Linux内核的交互的信息了。
- en: The development process
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发过程
- en: Linux kernel is a well known open source project. To make sure that developers
    know how to interact with it, information about how the `git` interaction is done
    with this project, and at the same time, some information about its development
    and release procedures will be presented. The project has evolved and its development
    processes and release procedures have evolved with it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核是一个众所周知的开源项目。为了确保开发人员知道如何与其交互，将介绍如何使用`git`与该项目进行交互的信息，同时还将介绍一些关于其开发和发布程序的信息。该项目已经发展，其开发流程和发布程序也随之发展。
- en: Before presenting the actual development process, a bit of history will be necessary.
    Until the 2.6 version of the Linux kernel project, one release was made every
    two or three years, and each of them was identified by even middle numbers, such
    as 1.0.x, 2.0.x, and 2.6.x. The development branches were instead defined using
    even numbers, such as 1.1.x, 2.1.x, and 2.5.x, and they were used to integrate
    various features and functionalities until a major release was prepared and ready
    to be shipped. All the minor releases had names, such as 2.6.32 and 2.2.23, and
    they were released between major release cycles.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍实际的开发过程之前，需要了解一些历史。在Linux内核项目的2.6版本之前，每两三年发布一次版本，并且每个版本都以偶数中间数字标识，如1.0.x、2.0.x和2.6.x。相反，开发分支使用偶数号来定义，如1.1.x、2.1.x和2.5.x，并且它们用于集成各种功能，直到准备好进行主要发布并准备好进行发布。所有次要发布都有名称，如2.6.32和2.2.23，并且它们是在主要发布周期之间发布的。
- en: '![The development process](img/image00321.jpeg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![开发过程](img/image00321.jpeg)'
- en: 'This way of working was kept up until the 2.6.0 version when a large number
    of features were added inside the kernel during every minor release, and all of
    them were very well put together as to not cause the need for the branching out
    of a new development branch. This implied a faster pace of release with more features
    available. So, the following changes have appeared since the release of the 2.6.14
    kernel:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这种工作方式一直持续到2.6.0版本，当时在每个次要版本发布期间在内核中添加了大量功能，并且所有这些功能都非常好地组合在一起，以免引起需要分支出一个新的开发分支的需求。这意味着发布速度更快，可用功能更多。因此，自2.6.14内核发布以来，出现了以下变化：
- en: All the new minor release versions, such as 2.6.x, contain a two week merge
    window in which a number of features could be introduced in the next release
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有新的次要发布版本，如2.6.x，都包含一个两周的合并窗口，在这个窗口中可以引入下一个发布中的一些功能。
- en: This merge window will be closed with a release test version called 2.6.(x+1)-rc1
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个合并窗口将在一个名为2.6.(x+1)-rc1的发布测试版本关闭
- en: Then a 6-8 weeks bug fixing period follows when all the bugs introduced by the
    added features should be fixed
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后是一个6-8周的错误修复期，期间应该修复由新增功能引入的所有错误
- en: In the bug fixing interval, tests were run on the release candidate and the
    2.6.(x+1)-rcY test versions were released
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在错误修复间隔期间，对发布候选版本进行了测试，并发布了2.6.(x+1)-rcY测试版本
- en: After the final test were done and the last release candidate is considered
    sufficiently stable, a new release will be made with a name, such as 2.6.(x+1),
    and this process will be continued once again
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最终测试完成并且最后一个发布候选版本被认为足够稳定之后，将发布一个名为2.6.(x+1)的新版本，然后这个过程将再次继续
- en: This process worked great but the only problem was that the bug fixes were only
    released for the latest stable versions of the Linux kernel. People needed long
    term support versions and security updates for their older versions, general information
    about these versions that were long time supported, and so on.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程运行得很好，但唯一的问题是，错误修复只发布给最新的稳定版本的Linux内核。人们需要长期支持版本和旧版本的安全更新，以及关于这些长期支持版本的一般信息等。
- en: 'This process changed in time and in July 2011, the 3.0 Linux kernel version
    appeared. It appeared with a couple of small changes designed to change the way
    the interaction was to be done to solve the previously mentioned requests. The
    changes were made to the numbering scheme, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程随着时间的推移而改变，在2011年7月，出现了3.0 Linux内核版本。它出现了一些小的变化，旨在改变解决先前提到的请求的交互方式。更改是针对编号方案进行的，如下所示：
- en: The kernel official versions would be named 3.x (3.0, 3.1, 3.2, and so on)
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核官方版本将被命名为3.x（3.0, 3.1, 3.2等）
- en: The stable versions would be named 3.x.y (3.0.1, 3.1.3, and so on)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定版本将被命名为3.x.y（3.0.1, 3.1.3等）
- en: Although it only removed one digit from the numbering scheme, this change was
    necessary because it marked the 20th anniversary of the Linux kernel.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个变化只是从编号方案中删除了一个数字，但这个变化是必要的，因为它标志着Linux内核的20周年。
- en: Since a great number of patches and features are included in the Linux kernel
    everyday, it becomes difficult to keep track of all the changes, and the bigger
    picture in general. This changed over time because sites, such as [http://kernelnewbies.org/LinuxChanges](http://kernelnewbies.org/LinuxChanges)
    and [http://lwn.net/](http://lwn.net/), appeared to help developers keep in touch
    with the world of Linux kernel.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Linux内核每天包含大量的补丁和功能，很难跟踪所有的变化和整体的大局。随着时间的推移，出现了一些网站，如[http://kernelnewbies.org/LinuxChanges](http://kernelnewbies.org/LinuxChanges)和[http://lwn.net/](http://lwn.net/)，帮助开发人员与Linux内核的世界保持联系。
- en: 'Besides these links, the `git` versioning control system can offer much needed
    information. Of course, this requires the existence of Linux kernel source clones
    to be available on the workstation. Some of the commands that offer a great deal
    of information are:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些链接，`git`版本控制系统可以提供非常需要的信息。当然，这需要工作站上存在Linux内核源克隆。一些提供大量信息的命令包括：
- en: '`git log`: This lists all the commits with the latest situated on top of the
    list'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git log`: 这列出了最新的所有提交'
- en: '`git log –p`: This lists all the commits and with their corresponding `diffs`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git log –p`: 这列出了所有提交及其相应的`diffs`'
- en: '`git tag –l`: This lists the available tags'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git tag –l`: 这列出了所有可用的标签'
- en: '`git checkout <tagname>`: This checks out a branch or tag from a working repository'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git checkout <tagname>`: 这从工作库中检出一个分支或标签'
- en: '`git log v2.6.32..master`: This lists all the changes between the given tag
    and the latest version'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git log v2.6.32..master`: 这列出了给定标签和最新版本之间的所有更改'
- en: '`git log –p V2.6.32..master MAINTAINERS`: This lists all the differences between
    the two given branches in the `MAINTAINERS` file'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git log –p V2.6.32..master MAINTAINERS`: 这列出了`MAINTAINERS`文件中两个给定分支之间的所有差异'
- en: Of course, this is just a small list with helpful commands. All the other commands
    are available at [http://git-scm.com/docs/](http://git-scm.com/docs/).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个有用命令的小列表。所有其他命令都可以在[http://git-scm.com/docs/](http://git-scm.com/docs/)上找到。
- en: Kernel porting
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核移植
- en: The Linux kernel offers support for a large variety of CPU architectures. Each
    architecture and individual board have their own maintainers, and this information
    is available inside the `MAINTAINERS` file. Also, the difference between board
    porting is mostly given by the architecture, PowerPC being very different from
    ARM or x86\. Since the development board that this book focuses on is an Atmel
    with an ARM Cortex-A5 core, this section will try to focus on ARM architecture.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核支持多种CPU架构。每个架构和单独的板都有自己的维护者，这些信息可以在`MAINTAINERS`文件中找到。此外，板的移植差异主要由架构决定，PowerPC与ARM或x86非常不同。由于本书关注的开发板是一款搭载ARM
    Cortex-A5核心的Atmel，本节将尝试关注ARM架构。
- en: The main focus in our case is the `arch/arm` directory, which contains sub directories
    such as, `boot`, `common`, `configs`, `crypto`, `firmware`, `kernel`, `kvm`, `lib`,
    `mm`, `net`, `nwfpe`, `oprofile`, `tools`, `vfp`, and `xen`. It also contains
    an important number of directories that are specific for different CPU families,
    such as the `mach-*` directories or the `plat-*` directories. The first `mach-*`
    category contains support for the CPU and several boards that use that CPU, and
    the second `plat-*` category contains platform-specific code. One example is `plat-omap`,
    which contains common code for both `mach-omap1` and `mach-omap2`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，主要关注的是`arch/arm`目录，其中包含诸如`boot`、`common`、`configs`、`crypto`、`firmware`、`kernel`、`kvm`、`lib`、`mm`、`net`、`nwfpe`、`oprofile`、`tools`、`vfp`和`xen`等子目录。它还包含了许多针对不同CPU系列特定的目录，例如`mach-*`目录或`plat-*`目录。第一个`mach-*`类别包含了CPU和使用该CPU的几个板，第二个`plat-*`类别包含特定于平台的代码。一个例子是`plat-omap`，其中包含了`mach-omap1`和`mach-omap2`的通用代码。
- en: The development for the ARM architecture has suffered a great change since 2011\.
    If until then ARM did not use a device tree, it was because it needed to keep
    a large portion of the code inside the `mach-*` specific directory, and for each
    board that had support inside the Linux kernel, a unique machine ID was associated
    and a machine structure was associates with each board that contained specific
    information and a set of callbacks. The boot loader passed this machine ID to
    a specific ARM registry and in this way, the kernel knew the board.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 自2011年以来，ARM架构的开发发生了很大变化。如果直到那时ARM没有使用设备树，那是因为它需要将大部分代码保留在`mach-*`特定目录中，对于每个在Linux内核中有支持的板，都会关联一个唯一的机器ID，并且一个机器结构与包含特定信息和一组回调的每个板相关联。引导加载程序将这个机器ID传递给特定的ARM注册表，这样内核就知道了板子。
- en: The increase in popularity of the ARM architecture came with the refactoring
    of the work and the introduction of the **device tree** that dramatically reduced
    the amount of code available inside the `mach-*` directories. If the SoC is supported
    by the Linux kernel, then adding support for a board is as simple as defining
    a device tree in the `/arch/arm/boot/dts` directory with an appropriate name.
    For example, for `<soc-name>-<board-name>.d`, include the relevant `dtsi` files
    if necessary. Make sure that you build the **device tree blob** (**DTB**) by including
    the device tree into **arch/arm/boot/dts/Makefile** and add the missing device
    drivers for board.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ARM架构的流行增加是因为工作重构和**设备树**的引入，这大大减少了`mach-*`目录中可用的代码量。如果SoC受到Linux内核的支持，那么为板添加支持就像在`/arch/arm/boot/dts`目录中定义一个设备树一样简单，例如，对于`<soc-name>-<board-name>.d`，如果需要，包含相关的`dtsi`文件。确保通过将设备树包含到**arch/arm/boot/dts/Makefile**中并为板添加缺失的设备驱动程序来构建**设备树blob**（**DTB**）。
- en: 'In the eventuality that the board does not have support inside the Linux kernel,
    the appropriate additions would be required inside the `mach-*` directory. Inside
    each `mach-*` directory, there are three types of files available:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果板上没有在Linux内核中的支持，需要在`mach-*`目录中进行适当的添加。在每个`mach-*`目录中，有三种类型的文件可用：
- en: '**Generic code files**: These usually have a single word name, such as `clock.c`,
    `led.c`, and so on'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用代码文件**：这些通常只有一个单词的名称，比如`clock.c`，`led.c`等'
- en: '**CPU specific code**: This is for the machine ID and usually has the `<machine-ID>*.c`
    form - for example, `at91sam9263.c`, `at91sam9263_devices.c`, `sama5d3.c`, and
    so on'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定于CPU的代码**：这是用于机器ID的，通常采用`<machine-ID>*.c`的形式 - 例如，`at91sam9263.c`，`at91sam9263_devices.c`，`sama5d3.c`等'
- en: '**Board specific code**: This usually is defined as board-*.c, such as `board-carmeva.c`,
    `board-pcontrol-g20.c`, `board-pcontrol-g20.c`, and so on'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定于板子的代码**：这通常被定义为board-*.c，比如`board-carmeva.c`，`board-pcontrol-g20.c`等'
- en: For a given board, the proper configuration should be made first inside the
    `arch/arm/mach-*/Kconfig` file; for this, the machine ID should be identified
    for the board CPU. After the configuration is done, the compilation can begin,
    so for this, `arch/arm/mach-*/Makefile` should also be updated with the required
    files to ensure board support. Another step is represented by the machine structure
    that defines the board and the machine type number that needs to be defined in
    the `board-<machine>.c` file.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的板子，应首先在`arch/arm/mach-*/Kconfig`文件中进行适当的配置；为此，应该为板子CPU确定机器ID。配置完成后，可以开始编译，因此应该更新`arch/arm/mach-*/Makefile`以确保板子支持所需的文件。另一步是由定义板子和需要在`board-<machine>.c`文件中定义的机器类型号的机器结构表示。
- en: 'The machine structure uses two macros: `MACHINE_START` and `MACHINE_END`. Both
    are defined inside `arch/arm/include/asm/march/arch.h` and are used to define
    the `machine_desc` structure. The machine type number is available inside the
    `arch/arm/tools/mach_types` file. This file is used to generate the `include/asm-arm/mach-types.h`
    file for the board.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 机器结构使用两个宏：`MACHINE_START`和`MACHINE_END`。它们都在`arch/arm/include/asm/march/arch.h`中定义，并用于定义`machine_desc`结构。机器类型号可在`arch/arm/tools/mach_types`文件中找到。该文件用于为板子生成`include/asm-arm/mach-types.h`文件。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The updated number list of the machine type is available at [http://www.arm.linux.org.uk/developer/machines/download.php](http://www.arm.linux.org.uk/developer/machines/download.php).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 机器类型的更新编号列表可在[http://www.arm.linux.org.uk/developer/machines/download.php](http://www.arm.linux.org.uk/developer/machines/download.php)上找到。
- en: When the boot process starts in the first case, only the `dtb` is necessary
    to pass to the boot loader and loaded to initialize the Linux kernel, while in
    the second case, the machine type number needs to be loaded in the `R1` register.
    In the early boot process, `__lookup_machine_type` looks for the `machine_desc`
    structure and loads it for the initialization of the board.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，当启动过程开始时，只需要将`dtb`传递给引导加载程序并加载以初始化Linux内核，而在第二种情况下，需要将机器类型号加载到`R1`寄存器中。在早期的启动过程中，`__lookup_machine_type`寻找`machine_desc`结构并加载它以初始化板子。
- en: Community interaction
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 社区互动
- en: After this information has been presented to you, and if you are eager to contribute
    to the Linux kernel, then this section should be read next. If you want to really
    contribute to the Linux kernel project, then a few steps should be performed before
    starting this work. This is mostly related to documentation and investigation
    of the subject. No one wants to send a duplicate patch or replicate the work of
    someone else in vain, so a search on the Internet on the topic of your interest
    could save a lot of time. Other useful advice is that after you've familiarized
    yourself with the subject, avoid sending a workaround. Try to reach the problem
    and offer a solution. If not, report the problem and describe it thoroughly. If
    the solution is found, then make both the problem and solution available in the
    patch.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在向您呈现了这些信息之后，如果你渴望为Linux内核做出贡献，那么接下来应该阅读这一部分。如果你真的想为Linux内核项目做出贡献，那么在开始这项工作之前应该执行一些步骤。这主要涉及文档和调查。没有人想要发送重复的补丁或徒劳地复制别人的工作，因此在互联网上搜索你感兴趣的主题可以节省大量时间。另一个有用的建议是，在熟悉了主题之后，避免发送权宜之计。尝试解决问题并提供解决方案。如果不能，报告问题并进行彻底描述。如果找到解决方案，那么在补丁中同时提供问题和解决方案。
- en: One of the most valuable things in the open source community is the help you
    can get from others. Share your question and issues, but do not forget to mention
    the solution also. Ask the questions in appropriate mailing lists and try to avoid
    the maintainers, if possible. They are usually very busy and have hundreds and
    thousands of e-mails to read and reply. Before asking for help, try to research
    the question you want to raise, it will help both when formulating it but also
    it could offer an answer. Use IRC, if available, for smaller questions and lastly,
    but most importantly, try to not overdo it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在开源社区中最有价值的事情之一是你可以从他人那里得到帮助。分享你的问题和困难，但不要忘记提到解决方案。在适当的邮件列表中提出问题，并尽量避免联系维护者。他们通常非常忙，有数百甚至数千封邮件需要阅读和回复。在寻求帮助之前，尽量研究你想提出的问题，这将有助于表达问题，也可能提供答案。如果可能的话，使用IRC来提出较小的问题，最重要的是，尽量不要过度使用。
- en: When you are preparing for a patch, make sure that it is done on the corresponding
    branch, and also that you read the `Documentation/BUG-HUNTING` file first. Identify
    bug reports, if any, and make sure you link your patch to them. Do not hesitate
    to read the `Documentation/SubmittingPatches` guidelines before sending. Also,
    do not send your changes before testing them properly. Always sign your patches
    and make the first description line as suggestive as possible. When sending the
    patches, find appropriate mailing lists and maintainers and wait for the replies.
    Solve comments and resubmit them if this is needed, until the patch is considered
    acceptable.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好补丁时，确保它是在相应的分支上完成的，并且你首先阅读`Documentation/BUG-HUNTING`文件。如果有的话，识别bug报告，并确保将你的补丁链接到它们。在发送之前不要犹豫阅读`Documentation/SubmittingPatches`指南。在发送补丁之前一定要进行适当的测试。始终签署你的补丁，并尽可能使第一行描述具有指导性。在发送补丁时，找到适当的邮件列表和维护者，并等待回复。解决评论并重新提交，直到补丁被认为是可以接受的。
- en: Kernel sources
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核源码
- en: The official location for the Linux kernel is available at [http://www.kernel.org](http://www.kernel.org),
    but there a lot of smaller communities that contribute to the Linux kernel with
    their features or even maintain their own versions.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核的官方位置位于[http://www.kernel.org](http://www.kernel.org)，但有许多较小的社区为Linux内核贡献其特性，甚至维护自己的版本。
- en: Although the Linux core contains the scheduler, memory management, and other
    features, it is quite small in size. The extremely large number of device drivers,
    architectures and boards support together with filesystems, network protocols
    and all the other components were the ones that made the size of the Linux kernel
    really big. This can be seen by taking a look at the size of the directories of
    the Linux.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Linux核心包含调度程序、内存管理和其他功能，但其大小相当小。大量的设备驱动程序、架构和板支持以及文件系统、网络协议和所有其他组件使得Linux内核的大小真正庞大。这可以通过查看Linux目录的大小来看出。
- en: 'The Linux source code structure contains the following directories:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Linux源代码结构包含以下目录：
- en: '`arch`: This contains architecture-dependent code'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arch`：这包含了与架构相关的代码'
- en: '`block`: This contains the block layer core'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`block`：这包含了块层核心'
- en: '`crypto`: This contains cryptographic libraries'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crypto`：这包含了加密库'
- en: '`drivers`: This gathers all the implementation of the device drivers with the
    exception of the sound ones'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drivers`：这收集了除声音驱动程序之外的所有设备驱动程序的实现'
- en: '`fs`: This gathers all the available implementations of filesystem'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs`：这收集了所有可用的文件系统实现'
- en: '`include`: This contains the kernel headers'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`：这包含了内核头文件'
- en: '`init`: This has the Linux initialization code'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`：这包含了Linux初始化代码'
- en: '`ipc`: This holds the interprocess communication implementation code'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ipc`：这包含了进程间通信实现代码'
- en: '`kernel`: This is the core of the Linux kernel'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kernel`：这是Linux内核的核心'
- en: '`lib`: This contains various libraries, such as `zlibc`, `crc`, and so on'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib`：这包含了各种库，如`zlibc`，`crc`等'
- en: '`mm`: This contains the source code for memory management'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mm`：这包含了内存管理的源代码'
- en: '`net`: This offers access to all the network protocol implementations supported
    inside Linux'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net`：这提供了对Linux内部支持的所有网络协议实现的访问'
- en: '`samples`: This presents a number of sample implementations, such as `kfifo`,
    `kobject`, and so on'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`samples`：这提供了许多示例实现，如`kfifo`，`kobject`等'
- en: '`scripts`: This is used both internally and externally'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scripts`：这既在内部又在外部使用'
- en: '`security`: This has a bunch of security implementation, such as `apparmor`,
    `selinux`, `smack`, and so on'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`security`：这包含了许多安全实现，如`apparmor`，`selinux`，`smack`等'
- en: '`sound`: This contains sound drivers and support code'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sound`：这包含了声音驱动程序和支持代码'
- en: '`usr`: This is the `initramfs cpio` archive that generates sources'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usr`：这是生成源代码的`initramfs cpio`存档'
- en: '`virt`: This holds the source code for the virtualization support'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virt`：这包含了虚拟化支持的源代码'
- en: '`COPYING`: This represents the Linux license and the definition copying conditions'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPYING`：这代表了Linux许可证和定义复制条件'
- en: '`CREDITS`: This represents the collection of Linux''s main contributors'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREDITS`：这代表了Linux的主要贡献者的集合'
- en: '`Documentation`: This contains corresponding documentation of kernel sources'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Documentation`：这包含了内核源代码的相应文档'
- en: '`Kbuild`: This represents the top-level kernel build system'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Kbuild`：这代表了顶层的内核构建系统'
- en: '`Kconfig`: This is the top-level descriptor for configuration parameters'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Kconfig`：这是配置参数的顶层描述符'
- en: '`MAINTAINERS`: This a list with the maintainers of each kernel component'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAINTAINERS`：这是每个内核组件的维护者列表'
- en: '`Makefile`: This represents the top-level makefile'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Makefile`：这代表了顶层的makefile'
- en: '`README`: This file describes what Linux is, it is the starting point for understanding
    the project'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README`：这个文件描述了Linux是什么，是理解项目的起点'
- en: '`REPORTING-BUGS`: This offers information regarding the bug report procedure'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REPORTING-BUGS`：这提供了关于错误报告程序的信息'
- en: As it can be seen, the source code of the Linux kernel is quite large, so a
    browsing tool would be required. There are a number of tools that can be used,
    such as **Cscope**, **Kscope**, or the web browser, **Linux Cross Reference**
    (**LXR**). Cscope is a huge project that can be also available with extensions
    for `vim` and `emacs`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所见，Linux内核的源代码非常庞大，因此需要一个浏览工具。有许多可以使用的工具，如**Cscope**，**Kscope**，或者Web浏览器**Linux
    Cross Reference**（**LXR**）。Cscope是一个庞大的项目，也可以通过`vim`和`emacs`的扩展来使用。
- en: Configuring kernel
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置内核
- en: Before building a Linux kernel image, the proper configuration needs to be done.
    This is hard, taking into consideration that we have access to hundreds and thousands
    of components, such as drivers, filesystems, and other items. A selection process
    is done inside the configuration stage, and this is possible with the help of
    dependency definitions. The user has the chance to use and define a number of
    options that are enabled in order to define the components that will be used to
    build a Linux kernel image for a specific board.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Linux内核映像之前，需要进行适当的配置。考虑到我们可以访问数百甚至数千个组件，如驱动程序、文件系统和其他项目，这是困难的。在配置阶段内进行选择过程，并且这是可能的依赖关系的帮助下。用户有机会使用和定义一些选项，以便定义将用于为特定板构建Linux内核映像的组件。
- en: All the configurations specific for a supported board are located inside a configuration
    file, simply named `.config`, and it is situated on the same level as the previously
    presented files and directory locations. Their form is usually represented as
    `configuration_key=value`. There are, of course, dependencies between these configurations,
    so they are defined inside the `Kconfig` files.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 所有支持板的特定配置都位于一个名为`.config`的配置文件中，它位于先前介绍的文件和目录位置的同一级别。它们的形式通常表示为`configuration_key=value`。当然，这些配置之间存在依赖关系，因此它们在`Kconfig`文件中定义。
- en: 'Here are a number of variable options available for a configuration key:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可用于配置键的变量选项：
- en: '`bool`: These are the options can have true or false values'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`：这些选项可以有真或假的值'
- en: '`tristate`: This, besides the true and false options, also appears as a module
    option'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三态：除了真和假选项之外，也可以作为模块选项出现
- en: '`int` : These values, are not that spread but they usually have a well-established
    value range'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：这些值并不是那么常见，但它们通常具有一个很好的值范围'
- en: '`string` : These values, are also not the most spread ones but usually contain
    some pretty basic information'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`：这些值也不是最常见的，但通常包含一些非常基本的信息。'
- en: With regard to the `Kconfig` files, there are two options available. The first
    one makes option A visible only when option B is enabled and is defined as *depends
    on*, and the second option offers the possibility of enabling option A. This is
    done when the option is enabled automatically and is defined as *select*.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`Kconfig`文件，有两个选项可用。第一个选项只有在启用选项B时才会显示选项A，并被定义为*取决于*，第二个选项提供了启用选项A的可能性。当选项被自动启用并被定义为*选择*时，就会执行此操作。
- en: Besides the manual configuration of the `.config` file, configuration is the
    worst option for a developer, mostly because it can miss dependencies between
    some of the configurations. I would like to suggest to developers to use the make
    `menuconfig` command that will launch a text console tool for the configuration
    of a kernel image.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 除了手动配置`.config`文件之外，配置对于开发人员来说是最糟糕的选择，主要是因为它可能会忽略一些配置之间的依赖关系。我想建议开发人员使用`menuconfig`命令，它将启动一个文本控制台工具，用于配置内核映像。
- en: Compiling and installing the kernel
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译和安装内核
- en: After the configuration is done, the compilation process can be started. A piece
    of advice I would like to give is to use as many threads as possible if the host
    machine offers this possibility because it would help with the build process.
    An example of the build process start command is `make –j 8`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完成后，可以开始编译过程。我想给出的建议是，如果主机机器提供了这种可能性，尽可能使用多个线程，因为这将有助于构建过程。构建过程的启动命令示例是`make
    -j 8`。
- en: At the end of the build process, a `vmlinux` image is offered and also some
    architecture-dependent images are made available inside the architecture-specific
    files for the ARM architecture. The result of this is available inside `arch/arm/boot/*Image`.
    Also, the Atmel SAMA5D3-Xplained board will offer a specific device tree file
    that is available in `arch/arm/boot/dts/*.dtb`. If the `vmlinux` image file is
    an ELF file with debug information that cannot be used for booting except for
    debug purposes, the `arch/arm/boot/*Image` file is the solution for this purpose.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程结束时，将提供一个`vmlinux`映像，以及一些特定于体系结构的映像，可在ARM体系结构的特定文件中使用。其结果可在`arch/arm/boot/*Image`中找到。此外，Atmel
    SAMA5D3-Xplained板将提供一个特定的设备树文件，可在`arch/arm/boot/dts/*.dtb`中找到。如果`vmlinux`映像文件是带有调试信息的ELF文件，除了调试目的外不能用于引导，那么`arch/arm/boot/*Image`文件就是解决此目的的方法。
- en: The installation is the next step when development is done for any other application.
    The same also takes place for the Linux kernel, but in an embedded environment,
    this step seems kind of unnecessary. For Yocto enthusiasts, this step is also
    available. However, in this step, proper configurations are done for the kernel
    source and headers are to be used by the dependencies that do the storing for
    the deploy step.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 安装是开发完成后的下一步。对于Linux内核也是如此，但在嵌入式环境中，这一步似乎有点不必要。对于Yocto爱好者，这一步也是可用的。然而，在这一步中，为内核源代码进行适当的配置，并且要使用由存储部署步骤的依赖项使用的头文件。
- en: The kernel modules, as mentioned in the cross-compilation chapter, need to be
    later used for the compiler build. The install for the kernel modules could be
    done using the make `modules_install` command, and this offers the possibility
    to install the sources available inside the `/lib/modules/<linux-kernel-version>`
    directory with all the module dependencies, symbols, and aliases.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模块，如交叉编译章节中所述，需要稍后用于编译器构建。可以使用make `modules_install`命令进行内核模块的安装，这提供了在`/lib/modules/<linux-kernel-version>`目录中安装可用源的可能性，包括所有模块依赖项、符号和别名。
- en: Cross-compiling the Linux kernel
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交叉编译Linux内核
- en: In an embedded development, the compilation process implies cross-compilation,
    the most visible difference with the native compilation process being the fact
    that it has a prefix with the target architecture available in the naming. The
    prefix setup can be done using the `ARCH` variable that defines the name of the
    architecture of the target board and the `CROSS_COMPILE` variable that defines
    the prefix for the cross-compilation toolchain. Both of them are defined in the
    top-level `Makefile`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式开发中，编译过程意味着交叉编译，与本地编译过程最明显的区别是它具有一个以目标架构为前缀的命名。前缀设置可以使用`ARCH`变量来定义目标板的架构名称，以及`CROSS_COMPILE`变量来定义交叉编译工具链的前缀。它们都在顶层`Makefile`中定义。
- en: The best option would be to set these variables as environment variables to
    make sure that a make process is not run for the host machine. Although it only
    works in the current terminal, it will be the best solution in the situation that
    no automation tool is available for these tasks, such as the Yocto Project. It
    is not recommended though to update the `.bashrc` shell variables if you are planning
    to use more than one toolchain on the host machine.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的选择是将这些变量设置为环境变量，以确保不会为主机机器运行make过程。虽然它只在当前终端中有效，但在没有自动化工具可用的情况下，比如Yocto项目，这将是最好的解决方案。不过，如果您计划在主机机器上使用多个工具链，不建议更新`.bashrc`
    shell变量。
- en: Devices and modules
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备和模块
- en: As I mentioned previously, the Linux kernel has a lot of kernel modules and
    drivers that are already implemented and available inside the source code of the
    Linux kernel. A number of them, being so many, are also available outside the
    Linux kernel source code. Having them outside not only reduces the boot time by
    not initializing them at boot time, but is done instead at the request and needs
    of users. The only difference is that the loading and unloading of the modules
    requires root access.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，Linux内核有许多内核模块和驱动程序，这些模块和驱动程序已经在Linux内核的源代码中实现并可用。其中许多模块也可以在Linux内核源代码之外找到。将它们放在外面不仅可以减少启动时间，而且可以根据用户的请求和需求进行初始化。唯一的区别是，加载和卸载模块需要root访问权限。
- en: Loading and interacting with the Linux kernel modules requires logging information
    to be made available. The same happens for any kernel module dependencies. The
    logging information is available through the `dmesg` command and the level of
    logging enables manual configuration using the `loglevel` parameter or it can
    be disabled with the quite parameter. Also for the kernel dependencies, information
    about them is available inside the `/lib/modules/<kernel-version>/modules.dep`
    file.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 加载和与Linux内核模块交互需要提供日志信息。对于任何内核模块依赖项也是如此。日志信息可通过`dmesg`命令获得，并且日志级别可以使用`loglevel`参数手动配置，也可以使用`quite`参数禁用。对于内核依赖项，有关它们的信息可在`/lib/modules/<kernel-version>/modules.dep`文件中找到。
- en: For module interaction, multiple utilities used for multiple operations are
    available, such as `modinfo`, which is used for information gathering about modules;
    `insmod` is able for loading a module when the fill path to the kernel module
    is given. Similar utilities for a module are available. One of them is called
    `modprobe` and the difference in `modprobe` is that the full path is not necessary,
    as it is responsible for loading dependent modules of the chosen kernel object
    before loading itself. Another functionality that `modprobe` offers is the `–r`
    option. It is the remove functionality which offers support for removing the module
    and all its dependencies. An alternative to this is the `rmmod` utility, which
    removes modules not used anymore. The last utility available is `lsmod`, which
    lists the loaded modules.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模块交互，有多个用于多个操作的实用程序可用，例如`modinfo`用于收集有关模块的信息；`insmod`用于在给定内核模块的完整路径时加载模块。类似的实用程序也可用于模块。其中一个称为`modprobe`，`modprobe`的区别在于不需要完整路径，因为它负责在加载自身之前加载所选内核对象的依赖模块。`modprobe`提供的另一个功能是`-r`选项。这是删除功能，它支持删除模块及其所有依赖项。这方面的替代方法是`rmmod`实用程序，它删除不再使用的模块。最后一个可用的实用程序是`lsmod`，它列出加载的模块。
- en: 'The simplest kernel module example that can be written looks something similar
    to this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 可以编写的最简单的内核模块示例看起来类似于这样：
- en: '[PRE9]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is a simple `hello world kernel` module. Useful information that can be
    gathered from the preceding example is that every kernel module needs a start
    function defined in the preceding example as `hello_world_init()`. It is called
    when the module is inserted, and a cleanup function called `hello_world_exit()`
    is called when the module is removed.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的“hello world内核”模块。可以从上面的示例中获得的有用信息是，每个内核模块都需要在上面的示例中定义为`hello_world_init()`的启动函数。当模块被插入时，它被调用，当模块被移除时，被调用的清理函数称为`hello_world_exit()`。
- en: 'Since the Linux kernel version 2.2, there is a possibility of using the `_init
    and __exit` macros in this way:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 自Linux内核版本2.2以来，可以以这种方式使用`_init`和`__exit`宏：
- en: '[PRE10]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding macros are removed, the first one after the initialization, and
    the second one when the module is built-in within the Linux kernel sources.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的宏被移除，第一个在初始化后被移除，第二个在模块内置在Linux内核源代码中时被移除。
- en: Note
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about the Linux kernel modules can be found in the Linux **Kernel
    Module Programming Guide** available at [http://www.tldp.org/LDP/lkmpg/2.6/html/index.html](http://www.tldp.org/LDP/lkmpg/2.6/html/index.html).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Linux内核模块的更多信息可以在Linux**内核模块编程指南**中找到，网址为[http://www.tldp.org/LDP/lkmpg/2.6/html/index.html](http://www.tldp.org/LDP/lkmpg/2.6/html/index.html)。
- en: As mentioned previously, a kernel module is not only available inside a Linux
    kernel, but also outside of the Linux kernel tree. For a built-in kernel module,
    the compile process is similar to the one of other available kernel modules and
    a developer can inspire its work from one of them. The kernel module available
    outside of the Linux kernel drivers and the build process requires access to the
    sources of the Linux kernel or the kernel headers.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，内核模块不仅可以在Linux内核内部使用，还可以在Linux内核树之外使用。对于内置的内核模块，编译过程类似于其他可用的内核模块的编译过程，开发人员可以从中汲取灵感。在Linux内核驱动程序之外可用的内核模块和构建过程需要访问Linux内核源代码或内核头文件。
- en: 'For a kernel module available outside of the Linux kernel sources, a `Makefile`
    example is available, as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在Linux内核源代码之外可用的内核模块，有一个`Makefile`示例，如下：
- en: '[PRE11]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For a module that is implemented inside a Linux kernel, a configuration for
    the module needs to be made available inside the corresponding `Kconfig` file
    with the correct configuration. Also, the `Makefile` near the `Kconfig` file needs
    to be updated to let the `Makefile` system know when the configuration for the
    module is updated and the sources need to be built. We will see an example of
    this kind for a kernel device driver here.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在Linux内核内实现的模块，需要在相应的`Kconfig`文件中提供模块的配置，并进行正确的配置。此外，需要更新`Kconfig`文件附近的`Makefile`，以便让`Makefile`系统知道何时更新模块的配置并构建源代码。我们将在这里看到一个这种类型的内核设备驱动程序的示例。
- en: 'An example of the `Kconfig` file is as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kconfig`文件的示例如下：'
- en: '[PRE12]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'An example of the `Makefile` is as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`Makefile`的示例如下：'
- en: '[PRE13]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In both these examples, the source code file is `hello_world.c` and the resulting
    kernel module if it is not built-in is called `hello_world.ko`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个示例中，源代码文件是`hello_world.c`，如果没有内置，生成的内核模块称为`hello_world.ko`。
- en: 'A driver is usually used as an interface with a framework that exposes a number
    of hardware features, or with a bus interface used to detect and communicate with
    the hardware. The best example is shown here:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序通常用作与公开多种硬件特性的框架的接口，或者与用于检测和与硬件通信的总线接口一起使用。最好的例子在这里展示：
- en: '![Devices and modules](img/image00322.jpeg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![设备和模块](img/image00322.jpeg)'
- en: 'Since there are multiple scenarios of using a device driver and three device
    mode structures are available:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用设备驱动程序的多种情况以及可用的三种设备模式结构：
- en: '`struct bus_type`: This represents the types of busses, such as I2C, SPI, USB,
    PCI, MMC, and so on'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct bus_type`：表示总线类型，如I2C、SPI、USB、PCI、MMC等'
- en: '`struct device_driver`: This represents the driver used to handle a specific
    device on a bus'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct device_driver`：这代表了用于处理总线上特定设备的驱动程序'
- en: '`struct device`: This is used to represent a device connected to a bus'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct device`：用于表示连接到总线的设备'
- en: An inheritance mechanism is used to create specialized structures from more
    generic ones, such as `struct device_driver` and `struct device` for every bus
    subsystem. The bus driver is the one responsible for representing each type of
    bus and matching the corresponding device driver with the detected devices, detection
    being done through an adapter driver. For nondiscoverable devices, a description
    is made inside the device tree or the source code of the Linux kernel. They are
    handled by the platform bus that supports platform drivers and in return, handles
    platform devices.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 继承机制用于从更通用的结构（例如`struct device_driver`和`struct device`）创建专门的结构，用于每个总线子系统。总线驱动程序负责表示每种类型的总线，并将相应的设备驱动程序与检测到的设备匹配，检测是通过适配器驱动程序完成的。对于不可发现的设备，在设备树或Linux内核源代码中进行描述。它们由支持平台驱动程序并处理平台设备的平台总线处理。
- en: Debugging a kernel
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试内核
- en: Having to debug the Linux kernel is not the most easy task, but it needs to
    be accomplished to make sure that the development process moves forward. Understanding
    the Linux kernel is, of course, one of the prerequisites. Some of the available
    bugs are very hard to solve and may be available inside the Linux kernel for a
    long period of time.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 不得不调试Linux内核并不是一项容易的任务，但必须完成以确保开发过程向前推进。当然，理解Linux内核是其中的先决条件之一。一些可用的错误非常难以解决，并且可能在Linux内核中存在很长一段时间。
- en: For most of the trivial ones, some of the following steps should be taken. First,
    identify the bug properly; it is not only useful when define the problem, but
    also helps with reproducing it. The second step involves finding the source of
    the problem. Here, I am referring to the first kernel version in which the bug
    was first reported. Good knowledge about the bug or the source code of the Linux
    kernel is always useful, so make sure that you understand the code before you
    start working on it.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数简单的问题，应该采取以下一些步骤。首先，正确地识别错误；这不仅在定义问题时有用，而且在重现问题时也有帮助。第二步涉及找到问题的源头。这里，我指的是首次报告错误的内核版本。对于错误或Linux内核源代码的良好了解总是有用的，因此在开始工作之前，请确保您理解代码。
- en: The bugs inside the Linux kernel have a wide spread. They vary from a variable
    not being stored properly to race conditions or hardware management problems,
    they have widely variable manifestations and a chain of events. However, debugging
    them is not as difficult as it sounds. Besides some specific problems, such as
    race conditions and time constraints, debugging is very similar to the debugging
    of any large user space application.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核中的错误有着广泛的传播。它们从变量未正确存储到竞争条件或硬件管理问题，表现出各种各样的表现形式和一系列事件。然而，调试它们并不像听起来那么困难。除了一些特定的问题，如竞争条件和时间限制，调试与调试任何大型用户空间应用程序非常相似。
- en: The first, easiest, and most handy method to debug the kernel is the one that
    involves the use of the `printk()` function. It is very similar to the `printf()`
    C library function, and although old and not recommended by some, it does the
    trick. The new preferred method involves the usage of the `pr_*()` functions,
    such as `pr_emerg()`, `pr_alert()`, `pr_crit()`, `pr_debug()`, and so on. Another
    method involves the usage of the `dev_*()` functions, such as `dev_emerg()`, `dev_alert()`,
    `dev_crit()`, `dev_dbg()`, and so on. They correspond to each logging level and
    also have extra functions that are defined for debugging purposes and are compiled
    when `CONFIG_DEBUG` is enabled.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 调试内核的第一种、最简单、最方便的方法是使用`printk()`函数。它非常类似于`printf()`C库函数，虽然有些过时并且不被一些人推荐，但它确实有效。新的首选方法涉及使用`pr_*()`函数，比如`pr_emerg()`、`pr_alert()`、`pr_crit()`、`pr_debug()`等。另一种方法涉及使用`dev_*()`函数，比如`dev_emerg()`、`dev_alert()`、`dev_crit()`、`dev_dbg()`等。它们对应于每个日志级别，并且还有一些额外的函数，用于调试目的，并且在启用`CONFIG_DEBUG`时进行编译。
- en: Note
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about the `pr_*()` and `dev_*()` family of functions can be
    found inside the Linux kernel source code at `Documentation/dynamic-debug-howto.txt`.
    You can also find more information about `loglevel` at `Documentation/kernel-parameters.txt`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`pr_*()`和`dev_*()`函数族的更多信息可以在Linux内核源代码的`Documentation/dynamic-debug-howto.txt`中找到。您还可以在`Documentation/kernel-parameters.txt`中找到有关`loglevel`的更多信息。
- en: When a kernel **oops** crash appears, it signals that the kernel has made a
    mistake. Not being able to fix or kill itself, it offers access to a bunch of
    information, such as useful error messages, registers content, and back trace
    information.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当内核发生**oops**崩溃时，表示内核犯了一个错误。无法修复或自杀，它提供了一堆信息，如有用的错误消息、寄存器内容和回溯信息。
- en: The `Magic SysRq` key is another method used in debugging. It is enabled by
    `CONFIG_MAGIC_SYSRQ config` and can be used to debug and rescue kernel information,
    regardless of its activity. It offers a series of command-line options that can
    be used for various actions, ranging from changing the nice level to rebooting
    the system. Plus, it can be toggled on or off by changing the value in the `/proc/sys/kernel/sysrq`
    file. More information about the system request key can be found at `Documentation/sysrq.txt`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`Magic SysRq`键是调试中使用的另一种方法。它由`CONFIG_MAGIC_SYSRQ config`启用，并可用于调试和救援内核信息，而不管其活动性。它提供了一系列命令行选项，可用于各种操作，从更改优先级到重新启动系统。此外，可以通过更改`/proc/sys/kernel/sysrq`文件中的值来切换开关。有关系统请求键的更多信息，请参阅`Documentation/sysrq.txt`。'
- en: Although Linus Torvalds and the Linux community do not believe that the existence
    of a kernel debugger will do much good to a project, a better understanding of
    the code is the best approach for any project. There are still some debugger solutions
    that are available to be used. GNU debugger (`gdb`) is the first one and it can
    be used in the same way as for any other process. Another one is the `kgdb` a
    patch over `gdb` that permits debugging of serial connections.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Linus Torvalds和Linux社区并不认为内核调试器的存在对项目有多大好处，但对代码的更好理解是任何项目的最佳方法。仍然有一些调试器解决方案可供使用。GNU调试器（`gdb`）是第一个，它可以像其他任何进程一样使用。另一个是`kgdb`，它是`gdb`的一个补丁，允许调试串行连接。
- en: If none of the preceding methods fail to help solve the problem and you've tried
    everything but can't seem to arrive at a solution, then you can contact the open
    source community for help. There will always will be developers there who will
    lend you a hand.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的方法都无法解决问题，并且您已经尝试了一切但似乎无法得出解决方案，那么您可以联系开源社区寻求帮助。总会有开发人员愿意帮助您。
- en: Note
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To acquire more information related to the Linux kernel, there are a couple
    of books that can be consulted. I will present a bunch of their names here: *Embedded
    Linux Primer* by Christopher Hallinan, *Linux Kernel Development* by Robert Love,
    *Linux Kernel In A Nutshell* by Greg Kroah-Hartman, and last but not the least,
    *Understanding the Linux Kernel* by Daniel P. Bovet and Marco Cesati.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取与Linux内核相关的更多信息，可以查阅一些书籍。我将在这里列出一些书名：Christopher Hallinan的*嵌入式Linux入门*，Robert
    Love的*Linux内核开发*，Greg Kroah-Hartman的*Linux内核要点*，最后但同样重要的是，Daniel P. Bovet和Marco
    Cesati的*理解Linux内核*。
- en: The Yocto Project reference
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Yocto项目参考
- en: Moving on to the Yocto Project, we have recipes available for every kernel version
    available inside the BSP support for each supported board, and recipes for kernel
    modules that are built outside the Linux kernel source tree.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 转向Yocto项目，我们为每个支持的板上的BSP支持内核版本提供了配方，并为在Linux内核源树之外构建的内核模块提供了配方。
- en: The Atmel SAMA5D3-Xplained board uses the `linux-yocto-custom` kernel. This
    is defined inside the `conf/machine/sama5d3-xplained.conf` machine configuration
    file using the `PREFERRED_PROVIDER_virtual/kernel` variable. No `PREFERRED_VERSION`
    is mentioned, so the latest version is preferred; in this case, we are talking
    about the `linux-yocto-custom_3.10.bb` recipe.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Atmel SAMA5D3-Xplained板使用`linux-yocto-custom`内核。这是通过`conf/machine/sama5d3-xplained.conf`机器配置文件使用`PREFERRED_PROVIDER_virtual/kernel`变量进行定义的。没有提到`PREFERRED_VERSION`，因此首选最新版本；在这种情况下，我们谈论的是`linux-yocto-custom_3.10.bb`配方。
- en: 'The `linux-yocto-custom_3.10.bb` recipe fetches the kernel sources available
    inside Linux Torvalds'' `git` repository. After a quick look at the sources once
    the `do_fetch` task is finished, it can be observed that the Atmel repository
    was, in fact, fetched. The answer is available inside the `linux-yocto-custom_3.10.bbappend`
    file, which offers another `SR_URI` location. Other useful information you can
    gather from here is the one available in bbappend file, inside it is very well
    stated that the SAMA5D3 Xplained machine is a `COMPATIBLE_MACHINE`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`linux-yocto-custom_3.10.bb`配方从Linux Torvalds的`git`存储库中提取可用的内核源代码。在`do_fetch`任务完成后快速查看源代码后，可以观察到实际上已经提取了Atmel存储库。答案可以在`linux-yocto-custom_3.10.bbappend`文件中找到，该文件提供了另一个`SR_URI`位置。您可以从这里收集到的其他有用信息是在bbappend文件中可用的，其中非常清楚地说明了SAMA5D3
    Xplained机器是`COMPATIBLE_MACHINE`：'
- en: '[PRE14]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The recipe firstly defines repository-related information. It is defined through
    variables, such as `SRC_URI` and `SRCREV`. It also indicates the branch of the
    repository through the `KBRANCH` variable, and also the place from where `defconfig`
    needs to be put into the source code to define the `.config` file. As seen in
    the recipe, there is an update made to the `do_deploy` task for the kernel recipe
    to add the device driver to the `tmp/deploy/image/sama5d3-xplained` directory
    alongside the kernel image and other binaries.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 配方首先定义了与存储库相关的信息。它通过变量（如`SRC_URI`和`SRCREV`）进行定义。它还通过`KBRANCH`变量指示存储库的分支，并且还指示`defconfig`需要放入源代码中以定义`.config`文件的位置。正如在配方中所看到的，对内核配方的`do_deploy`任务进行了更新，以将设备驱动程序添加到`tmp/deploy/image/sama5d3-xplained`目录中，与内核映像和其他二进制文件一起。
- en: 'The kernel recipe inherits the `kernel.bbclass` and `kernel-yocto.bbclass`
    files, which define most of its tasks actions. Since it also generates a device
    tree, it needs access to `linux-dtb.inc`, which is available inside the `meta/recipes-kernel/linux`
    directory. The information available in the `linux-yocto-custom_3.10.bb` recipe
    is rather generic and overwritten by the `bbappend` file, as can be seen here:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 内核配方继承了`kernel.bbclass`和`kernel-yocto.bbclass`文件，这些文件定义了大部分任务操作。由于它还生成设备树，因此需要访问`linux-dtb.inc`，该文件位于`meta/recipes-kernel/linux`目录中。`linux-yocto-custom_3.10.bb`配方中提供的信息相当通用，并且被`bbappend`文件覆盖，如下所示：
- en: '[PRE15]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After the kernel is built by running the `bitbake virtual/kernel` command, the
    kernel image will be available inside the `tmp/deploy/image/sama5d3-xplained`
    directory under the `zImage-sama5d3-xplained.bin` name, which is a symbolic link
    to the full name file and has a larger name identifier. The kernel image was deployed
    here from the place where the Linux kernel tasks were executed. The simplest method
    to discover that place would be to run `bitbake –c devshell virtual/kernel`. A
    development shell will be available to the user for direct interaction with the
    Linux kernel source code and access to task scripts. This method is preferred
    because the developer has access to the same environment as `bitbake`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`bitbake virtual/kernel`命令构建内核后，内核映像将在`tmp/deploy/image/sama5d3-xplained`目录下以`zImage-sama5d3-xplained.bin`名称可用，这是一个符号链接到完整名称文件，并具有更大的名称标识符。内核映像是从执行Linux内核任务的地方部署到这里的。发现该位置的最简单方法是运行`bitbake
    –c devshell virtual/kernel`。开发shell将可供用户直接与Linux内核源代码进行交互，并访问任务脚本。这种方法是首选的，因为开发人员可以访问与`bitbake`相同的环境。
- en: 'A kernel module, on the other hand, has a different kind of behavior if it
    is not built-in inside the Linux kernel source tree. For the modules that are
    build outside of the source tree, a new recipe need to be written, that is, a
    recipe that inherits another `bitbake` class this time called `module.bbclass`.
    One example of an external Linux kernel module is available inside the `meta-skeleton`
    layer in the `recipes-kernel/hello-mod` directory:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果内核模块不是内置在Linux内核源树中，则具有不同类型行为。对于在源树之外构建的模块，需要编写一个新的配方，即继承另一个名为`module.bbclass`的`bitbake`类的配方。一个外部Linux内核模块的示例可在`meta-skeleton`层的`recipes-kernel/hello-mod`目录中找到。
- en: '[PRE16]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As mentioned in the example of the Linux kernel external module, the last two
    lines of each kernel module that is external or internal is packaged with the
    `kernel-module-` prefix to make sure that when the `IMAGE_INSTALL` variable is
    available, the value kernel-modules are added to all kernel modules available
    inside the `/lib/modules/<kernel-version>` directory. The kernel module recipe
    is very similar to any available recipe, the major difference being in the form
    of the module inherited, as shown in the line inherit module.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux内核外部模块的示例中提到，每个外部或内部内核模块的最后两行都使用`kernel-module-`前缀打包，以确保当`IMAGE_INSTALL`变量可用时，值kernel-modules将添加到`/lib/modules/<kernel-version>`目录中所有可用的内核模块。内核模块配方与任何可用配方非常相似，主要区别在于继承的模块形式，如继承模块一行所示。
- en: Inside the Yocto Project, there are multiple commands available to interact
    with the kernel and kernel module recipes. The simplest command is, of course,
    `bitbake` `<recipe-name>`, but for the Linux kernel, there are a number of commands
    available to make the interaction easier. The most used one is the `bitbake -c
    menuconfig virtual/kernel` operation, which offers access to the kernel configuration
    menu.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yocto Project中，有多个可用命令与内核和内核模块配方进行交互。最简单的命令当然是`bitbake` `<recipe-name>`，但对于Linux内核，有许多可用命令可以使交互更容易。最常用的是`bitbake
    -c menuconfig virtual/kernel`操作，它提供了对内核配置菜单的访问。
- en: Besides already known tasks, such as `configure`, `compile`, and `devshell`,
    that are used mostly in the development process, there are other ones, such as
    `diffconfig`, which uses the `diffconfig` script available in the Linux kernel
    `scripts` directory. The difference between the implementation of the Yocto Project
    and the available script of the Linux kernel is the fact that the former adds
    the kernel `config` creation phase. These `config` fragments are used to add kernel
    configurations into the `.config` file as part of the automation process.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已知的任务，如`configure`、`compile`和`devshell`，主要用于开发过程，还有其他任务，如`diffconfig`，它使用Linux内核`scripts`目录中可用的`diffconfig`脚本。
    Yocto Project的实现与Linux内核的可用脚本之间的区别在于前者添加了内核`config`创建阶段。这些`config`片段用于将内核配置添加到`.config`文件中，作为自动化过程的一部分。
- en: Summary
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the Linux kernel in general, about its features
    and methods of interacting with it. There was also information about debugging
    and porting features. All this was done to make sure that you would get enough
    information about the whole ecosystem before interacting with it. It is my opinion
    that if you understand the whole picture first, it will become easier to focus
    on the more specific things. This is also one of the reasons that the Yocto Project
    reference was kept toward the end. You were introduced to how a Linux kernel recipe
    and a Linux kernel external module are defined and used later by a given machine.
    More information on Linux kernels will also be available in the next chapter,
    which will gather all the previously presented information and will show you how
    a developer can interact with a Linux operating system image.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了Linux内核的一般情况，以及与其交互的特性和方法。还有关于调试和移植特性的信息。所有这些都是为了确保在与其交互之前，您能够获得足够的信息。我认为，如果您首先了解整个情况，将更容易专注于更具体的事物。这也是Yocto
    Project参考资料被保留到最后的原因之一。您将了解如何定义Linux内核配方和Linux内核外部模块，并在稍后由特定机器使用。有关Linux内核的更多信息也将在下一章中提供，该章将汇总先前提供的所有信息，并向您展示开发人员如何与Linux操作系统映像进行交互。
- en: Besides this information, in the next chapter, there will be an explanation
    about the organization of the root file system and the principles behind it, its
    content, and device drivers. Busybox is another interesting subject that will
    be discussed and also the various support for file systems that are available.
    Since it tends to become larger, information about what a minimal file system
    should look like will also be presented. Having said this, we shall proceed to
    the next chapter.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些信息之外，在下一章中，将会对根文件系统的组织及其背后的原理、内容和设备驱动程序进行解释。Busybox是另一个有趣的主题，将进行讨论，还有各种可用的文件系统支持。由于它倾向于变得更大，关于最小文件系统应该是什么样子的信息也将被呈现。说到这里，我们将继续下一章。
