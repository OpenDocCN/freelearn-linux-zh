["```\nstatic ssize_t chrdev_read(struct file *filp,\n               char __user *buf, size_t count, loff_t *ppos)\n{\n    struct chrdev_device *chrdev = filp->private_data;\n    int ret;\n\n    dev_info(chrdev->dev, \"should read %ld bytes (*ppos=%lld)\\n\",\n                count, *ppos);\n\n    /* Check for end-of-buffer */\n    if (*ppos + count >= BUF_LEN)\n        count = BUF_LEN - *ppos;\n\n    /* Return data to the user space */\n    ret = copy_to_user(buf, chrdev->buf + *ppos, count);\n    if (ret < 0)\n        return ret;\n\n    *ppos += count;\n    dev_info(chrdev->dev, \"return %ld bytes (*ppos=%lld)\\n\", count, *ppos);\n\n    return count;\n}\n```", "```\nstatic ssize_t chrdev_read(struct file *filp,\n               char __user *buf, size_t count, loff_t *ppos)\n{\n    struct chrdev_device *chrdev = filp->private_data;\n    int ret;\n\n    /* Wait for available data */\n    wait_for_event(chrdev->available > 0);\n\n    /* Check for end-of-buffer */\n    if (count > chrdev->available)\n        count = chrdev->available;\n\n    /* Return data to the user space */\n    ret = copy_to_user(buf, ..., count);\n    if (ret < 0)\n        return ret;\n\n    *ppos += count;\n\n    return count;\n}\n```", "```\n--- a/drivers/misc/irqtest.c\n+++ b/drivers/misc/irqtest.c\n...\n+static void irqtest_work_handler(struct work_struct *ptr)\n+{\n+     struct irqtest_data *info = container_of(ptr, struct irqtest_data,\n+                                                      work);\n+     struct device *dev = info->dev;\n+\n+     dev_info(dev, \"work executed after IRQ %d\", info->irq);\n+\n+     /* Schedule the delayed work after 2 seconds */\n+     schedule_delayed_work(&info->dwork, 2*HZ);\n+}\n+\n static irqreturn_t irqtest_interrupt(int irq, void *dev_id)\n {\n      struct irqtest_data *info = dev_id;\n@@ -36,6 +60,8 @@ static irqreturn_t irqtest_interrupt(int irq, void *dev_id)\n\n      dev_info(dev, \"interrupt occurred on IRQ %d\\n\", irq);\n\n+     schedule_work(&info->work);\n+\n      return IRQ_HANDLED;\n }\n```", "```\n@@ -80,6 +106,10 @@ static int irqtest_probe(struct platform_device *pdev)\n      dev_info(dev, \"GPIO %u correspond to IRQ %d\\n\",\n                                irqinfo.pin, irqinfo.irq);\n\n+     /* Init works */\n+     INIT_WORK(&irqinfo.work, irqtest_work_handler);\n+     INIT_DELAYED_WORK(&irqinfo.dwork, irqtest_dwork_handler);\n+\n      /* Request IRQ line and setup corresponding handler */\n      irqinfo.dev = dev;\n      ret = request_irq(irqinfo.irq, irqtest_interrupt, 0,\n@@ -98,6 +128,8 @@ static int irqtest_remove(struct platform_device *pdev)\n {\n        struct device *dev = &pdev->dev;\n\n+     cancel_work_sync(&irqinfo.work);\n+     cancel_delayed_work_sync(&irqinfo.dwork);\n      free_irq(irqinfo.irq, &irqinfo);\n      dev_info(dev, \"IRQ %d is now unmanaged!\\n\", irqinfo.irq);\n```", "```\n/**\n * container_of - cast a member of a structure out to the containing structure\n * @ptr: the pointer to the member.\n * @type: the type of the container struct this is embedded in.\n * @member: the name of the member within the struct.\n *\n */\n#define container_of(ptr, type, member) ({ \\\n    void *__mptr = (void *)(ptr); \\\n    BUILD_BUG_ON_MSG(!__same_type(*(ptr), ((type *)0)->member) && \\\n                     !__same_type(*(ptr), void), \\\n                     \"pointer type mismatch in container_of()\"); \\\n    ((type *)(__mptr - offsetof(type, member))); })\n```", "```\ntypedef int (*notifier_fn_t)(struct notifier_block *nb,\n                        unsigned long action, void *data);\n\nstruct notifier_block {\n    notifier_fn_t notifier_call;\n    struct notifier_block __rcu *next;\n    int priority;\n};\n```", "```\nstatic int __init notifier_init(void)\n{\n    int ret;\n\n    ninfo.netdevice_nb.notifier_call = netdevice_notifier;\n    ninfo.netdevice_nb.priority = 10; \n\n    ret = register_netdevice_notifier(&ninfo.netdevice_nb);\n    if (ret) {\n        pr_err(\"unable to register netdevice notifier\\n\");\n        return ret;\n    }\n\n    ninfo.reboot_nb.notifier_call = reboot_notifier;\n    ninfo.reboot_nb.priority = 10; \n\n    ret = register_reboot_notifier(&ninfo.reboot_nb);\n    if (ret) {\n        pr_err(\"unable to register reboot notifier\\n\");\n        goto unregister_netdevice;\n    }\n\n    pr_info(\"notifier module loaded\\n\");\n\n    return 0;\n\nunregister_netdevice:\n    unregister_netdevice_notifier(&ninfo.netdevice_nb);\n    return ret;\n}\n\nstatic void __exit notifier_exit(void)\n{\n    unregister_netdevice_notifier(&ninfo.netdevice_nb);\n    unregister_reboot_notifier(&ninfo.reboot_nb);\n\n    pr_info(\"notifier module unloaded\\n\");\n}\n```", "```\nstatic struct notifier_data {\n    struct notifier_block netdevice_nb;\n    struct notifier_block reboot_nb;\n    unsigned int data;\n} ninfo;\n```", "```\nstatic int netdevice_notifier(struct notifier_block *nb,\n                              unsigned long code, void *unused)\n{\n    struct notifier_data *ninfo = container_of(nb, struct notifier_data,\n                                               netdevice_nb);\n\n    pr_info(\"netdevice: event #%d with code 0x%lx caught!\\n\",\n                    ninfo->data++, code);\n\n    return NOTIFY_DONE;\n}\n\nstatic int reboot_notifier(struct notifier_block *nb,\n                           unsigned long code, void *unused)\n{ \n    struct notifier_data *ninfo = container_of(nb, struct notifier_data,\n                                               reboot_nb);\n\n    pr_info(\"reboot: event #%d with code 0x%lx caught!\\n\",\n                    ninfo->data++, code);\n\n    return NOTIFY_DONE;\n}\n```", "```\n#define NOTIFY_DONE       0x0000                     /* Don't care */\n#define NOTIFY_OK         0x0001                     /* Suits me */\n#define NOTIFY_STOP_MASK  0x8000                     /* Don't call further */\n#define NOTIFY_BAD        (NOTIFY_STOP_MASK|0x0002)  /* Bad/Veto action */\n```", "```\n/* Encapsulate (negative) errno value (in particular, NOTIFY_BAD <=> EPERM). */\nstatic inline int notifier_from_errno(int err)\n{\n    if (err)\n        return NOTIFY_STOP_MASK | (NOTIFY_OK - err);\n\n    return NOTIFY_OK;\n}\n```", "```\n/* Restore (negative) errno value from notify return value. */\nstatic inline int notifier_to_errno(int ret)\n{\n    ret &= ~NOTIFY_STOP_MASK;\n    return ret > NOTIFY_OK ? NOTIFY_OK - ret : 0;\n}\n```", "```\n# insmod notifier.ko \nnotifier:netdevice_notifier: netdevice: event #0 with code 0x5 caught!\nnotifier:netdevice_notifier: netdevice: event #1 with code 0x1 caught!\nnotifier:netdevice_notifier: netdevice: event #2 with code 0x5 caught!\nnotifier:netdevice_notifier: netdevice: event #3 with code 0x5 caught!\nnotifier:netdevice_notifier: netdevice: event #4 with code 0x5 caught!\nnotifier:netdevice_notifier: netdevice: event #5 with code 0x5 caught!\nnotifier:notifier_init: notifier module loaded\n```", "```\n# ip link set lan0 up\nnotifier:netdevice_notifier: netdevice: event #6 with code 0xd caught!\nRTNETLINK answers: Network is down\n```", "```\n/* netdevice notifier chain. Please remember to update netdev_cmd_to_name()\n * and the rtnetlink notification exclusion list in rtnetlink_event() when\n * adding new types.\n */\nenum netdev_cmd {\n    NETDEV_UP = 1, /* For now you can't veto a device up/down */\n    NETDEV_DOWN,\n    NETDEV_REBOOT, /* Tell a protocol stack a network interface\n                      detected a hardware crash and restarted\n                      - we can use this eg to kick tcp sessions\n                      once done */\n    NETDEV_CHANGE, /* Notify device state change */\n    NETDEV_REGISTER,\n    NETDEV_UNREGISTER,\n    NETDEV_CHANGEMTU, /* notify after mtu change happened */\n    NETDEV_CHANGEADDR,\n    NETDEV_GOING_DOWN,\n    NETDEV_CHANGENAME,\n    NETDEV_FEAT_CHANGE,\n    NETDEV_BONDING_FAILOVER,\n    NETDEV_PRE_UP,\n...\n```", "```\n# reboot\n...\n[ 2804.502671] notifier:reboot_notifier: reboot: event #7 with code 1 caught!\n```"]