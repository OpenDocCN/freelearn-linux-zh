- en: Chapter 7. Creating a Storage Strategy
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。创建存储策略
- en: The mass storage options for embedded devices have a great impact on the rest
    of the system in terms of robustness, speed, and methods of in-field updates.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式设备的大容量存储选项对系统的其余部分在稳健性、速度和现场更新方法方面产生了巨大影响。
- en: Most devices employ flash memory in some form or other. Flash memory has become
    much less expensive over the past few years as storage capacities have increased
    from tens of megabytes to tens of gigabytes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数设备以某种形式使用闪存存储器。随着存储容量从几十兆字节增加到几十吉字节，闪存存储器在过去几年中变得更加廉价。
- en: In this chapter, I will begin with a detailed look at the technology behind
    flash memory and how different memory organization affects the low level driver
    software that has to manage it, including the Linux memory technology device layer,
    MTD.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将详细介绍闪存存储器背后的技术，以及不同的存储器组织如何影响必须管理它的低级驱动程序软件，包括Linux内存技术设备层MTD。
- en: For each flash technology, there are different choices of filesystem. I will
    describe those most commonly found on embedded devices and complete the survey
    with a section giving a summary of choices for each type of flash.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种闪存技术，都有不同的文件系统选择。我将描述在嵌入式设备上最常见的文件系统，并在一节中总结每种闪存类型的选择。
- en: The last sections consider techniques to make the best use of flash memory,
    look at how to update devices in the field, and draw everything together into
    a coherent storage strategy.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几节考虑了利用闪存存储器的最佳技术，研究了如何在现场更新设备，并将所有内容整合成一种连贯的存储策略。
- en: Storage options
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储选项
- en: Embedded devices need storage that takes little power, is physically compact,
    robust, and reliable over a lifetime of perhaps tens of years. In almost all cases,
    that means solid state storage, which was introduced many years ago with **read-only
    memory** (**ROM**), but for the past 20 years it has been flash memory of some
    kind. There have been several generations of flash memory in that time, progressing
    from NOR to NAND to managed flash such as eMMC.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式设备需要存储器，它需要耗电少、物理上紧凑、稳固，并且在长达数十年的寿命内可靠。在几乎所有情况下，这意味着固态存储器，它在许多年前就已经引入了只读存储器（ROM），但在过去20年中一直是各种闪存存储器。在这段时间里，闪存存储器经历了几代，从NOR到NAND再到eMMC等托管闪存。
- en: NOR flash is expensive but reliable and can be mapped into the CPU address space,
    which allows you to execute code directly from flash. NOR flash chips are low-capacity,
    ranging from a few megabytes to a gigabyte or so.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: NOR闪存价格昂贵，但可靠，并且可以映射到CPU地址空间，这使得可以直接从闪存中执行代码。NOR闪存芯片容量较低，从几兆字节到大约一吉字节不等。
- en: NAND flash memory is much cheaper than NOR and is available in higher capacities,
    in the range of tens of megabytes to tens of gigabytes. However, it needs a lot
    of hardware and software support to turn it into a useful storage medium.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: NAND闪存存储器比NOR便宜得多，容量更大，范围从几十兆字节到几十吉字节。然而，它需要大量的硬件和软件支持，才能将其转化为有用的存储介质。
- en: Managed flash memory consists of one or more NAND flash chips packaged with
    a controller which handles the complexities of flash memory and presents a hardware
    interface similar to that of a hard disk. The attraction is that it removes complexity
    from the driver software and insulates the system designer against the frequent
    changes in flash technology. SD cards, eMMC chips, and USB flash drives fit into
    this category. Almost all of the current generation of smartphones and tablets
    have eMMC storage, and that trend is likely to progress with other categories
    of embedded devices.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 托管闪存存储器由一个或多个NAND闪存芯片与控制器组成，控制器处理闪存存储器的复杂性，并提供类似硬盘的硬件接口。吸引人的地方在于它可以减少驱动程序软件的复杂性，并使系统设计人员免受闪存技术的频繁变化的影响。SD卡、eMMC芯片和USB闪存驱动器属于这一类。几乎所有当前的智能手机和平板电脑都使用eMMC存储，这一趋势可能会在其他类别的嵌入式设备中继续发展。
- en: Hard drives are seldom found in embedded systems. One exception is digital video
    recording in set-top boxes and smart TVs in which a large amount of storage is
    needed with fast write times.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式系统中很少使用硬盘驱动器。一个例外是机顶盒和智能电视中的数字视频录制，这需要大量的存储空间和快速的写入时间。
- en: 'In all cases, robustness is of prime importance: you want the device to boot
    and reach a functional state despite power failures and unexpected resets. You
    should choose filesystems that behave well under such circumstances.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，稳健性是最重要的：您希望设备在断电和意外重置的情况下能够引导并达到功能状态。您应该选择在这种情况下表现良好的文件系统。
- en: NOR flash
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NOR闪存
- en: The memory cells in NOR flash chips are arranged into erase blocks of, for example,
    128 KiB. Erasing a block sets all the bits to 1\. It can be programmed one word
    at a time (8, 16 or 32 bits, depending on the data bus width). Each erase cycle
    damages the memory cells slightly and, after a number of cycles, the erase block
    becomes unreliable and cannot be used anymore. The maximum number of erase cycles
    should be given in the data sheet for the chip but is usually in the range of
    100K to 1M.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: NOR闪存芯片中的存储单元被排列成擦除块，例如128 KiB。擦除块会将所有位设置为1。它可以一次编程一个字（8、16或32位，取决于数据总线宽度）。每次擦除循环都会轻微损坏存储单元，经过多次循环后，擦除块变得不可靠，无法再使用。芯片的最大擦除循环次数应该在数据表中给出，但通常在10万到100万次之间。
- en: The data can be read word by word. The chip is usually mapped into the CPU address
    space which means that you can execute code directly from NOR flash. This makes
    it a convenient place to put the bootloader code as it needs no initialization
    beyond hardwiring the address mapping. SoCs that support NOR flash in this way
    have configurations that give a default memory mapping such that it encompasses
    the reset vector of the CPU.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以逐字读取。芯片通常被映射到CPU地址空间中，这意味着可以直接从NOR闪存中执行代码。这使得它成为放置引导加载程序代码的便利位置，因为它不需要除了硬连地址映射之外的任何初始化。支持NOR闪存的SoC具有配置，可以给出默认的内存映射，使其包含CPU的复位向量。
- en: The kernel, and even the root filesystem, can also be located in flash memory,
    avoiding the need for copying them into RAM and thus creating devices with small
    memory footprints. The technique is known as **eXecute In Place**, or **XIP**.
    It is very specialized and I will not examine it further here. There are some
    references at the end of the chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 内核，甚至根文件系统，也可以位于闪存中，避免将它们复制到RAM中，从而创建具有小内存占用的设备。这种技术称为**原地执行**，或**XIP**。这是非常专业的，我在这里不会进一步讨论。本章末尾有一些参考资料。
- en: There is a standard register-level interface for NOR flash chips called the
    **common flash interface** or **CFI**, which all modern chips support.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: NOR闪存芯片有一个称为**通用闪存接口**或**CFI**的标准寄存器级接口，所有现代芯片都支持。
- en: NAND flash
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NAND闪存
- en: NAND flash is much cheaper than NOR flash and has a higher capacity. First generation
    NAND chips stored one bit per memory cell in what is now known as an **SLC** or
    **single level cell** organization. Later generations moved on to two bits per
    cell in **multi-level cell** (**MLC**) chips and now to three bits per cell in
    **tri-level cell** (**TLC**) chips. As the number of bits per cell has increased,
    the reliability of the storage has decreased, requiring more complex controller
    hardware and software to compensate.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: NAND闪存比NOR闪存便宜得多，并且容量更大。第一代NAND芯片以每个存储单元存储一个位，即现在所称的**SLC**或**单级单元**组织。后来的几代转向每个存储单元存储两位，即**多级单元**（**MLC**）芯片，现在转向每个存储单元存储三位，即**三级单元**（**TLC**）芯片。随着每个存储单元的位数增加，存储的可靠性降低，需要更复杂的控制器硬件和软件来进行补偿。
- en: As with NOR flash, NAND flash is organized into erase blocks ranging in size
    from 16 KiB to 512 KiB and, once again, erasing a block sets all the bits to 1\.
    However, the number of erase cycles before the block becomes unreliable is lower,
    typically as few as 1K cycles for TLC chips and up to 100K for SLC. NAND flash
    can only be read and written in pages, usually of 2 or 4 KiB. Since they cannot
    be accessed byte-by-byte, they cannot be mapped into the address space and so
    code and data have to be copied into RAM before they can be accessed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与NOR闪存一样，NAND闪存被组织成擦除块，大小从16 KiB到512 KiB不等，再次擦除块会将所有位设置为1。然而，块变得不可靠之前的擦除循环次数较低，对于TLC芯片通常只有1K次，而对于SLC则高达100K次。NAND闪存只能以页面的形式读取和写入，通常为2或4
    KiB。由于它们无法逐字节访问，因此无法映射到地址空间，因此代码和数据必须在访问之前复制到RAM中。
- en: Data transfers to and from the chip are prone to bit flips, which can be detected
    and corrected using Error Correction Codes. SLC chips generally use a simple hamming
    code which can be implemented efficiently in software and can correct a single
    bit error in a page read. MLC and TLC chips need more sophisticated codes such
    as **BCH** (**Bose-Chaudhuri-Hocquenghem**) which can correct up to 8-bit errors
    per page. These need hardware support.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与芯片之间的数据传输容易发生位翻转，可以使用纠错码进行检测和纠正。SLC芯片通常使用简单的海明码，可以在软件中高效实现，并可以纠正页面读取中的单个位错误。MLC和TLC芯片需要更复杂的编码，例如**BCH**（**Bose-Chaudhuri-Hocquenghem**），可以纠正每页高达8位的错误。这些需要硬件支持。
- en: 'The error correction codes have to be stored somewhere and so there is an extra
    area of memory per page known as the **out of band** (**OOB**) area, or also the
    spare area. MLC designs usually have 1 byte of OOB per 32 bytes of main storage
    so, for a 2 KiB page device, the OOB is 64 bytes per page and for a 4 KiB page,
    128 bytes. MLC and TLC chips have proportionally larger OOB areas to accommodate
    more complex error correction codes. The following diagram shows the organization
    of a chip with a 128 KiB erase block and 2 KiB pages:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 纠错码必须存储在某个地方，因此每页都有一个额外的内存区域，称为**带外**（**OOB**）区域，也称为备用区域。MLC设计通常每32个字节的主存储空间有1个字节的OOB，因此对于2
    KiB页面设备，每页的OOB为64字节，对于4 KiB页面，则为128字节。MLC和TLC芯片具有比例更大的OOB区域，以容纳更复杂的纠错码。下图显示了具有128
    KiB擦除块和2 KiB页面的芯片的组织结构：
- en: '![NAND flash](img/B03982_07_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![NAND闪存](img/B03982_07_01.jpg)'
- en: During production, the manufacturer tests all the blocks and marks any that
    fail by setting a flag in the OOB area of each page in the block. It is not uncommon
    to find that brand new chips have up to 2% of their blocks marked bad in this
    way. Furthermore, it is within the specification for a similar proportion of blocks
    to give errors on erase before the erase cycle limit is reached. The NAND flash
    driver should detect this and mark it as bad.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产过程中，制造商测试所有块，并标记任何失败的块，通过在每个块中的每个页面的OOB区域设置标志来实现。发现全新芯片以这种方式标记为坏的块高达2%并不罕见。此外，在擦除循环限制达到之前，类似比例的块出现擦除错误是在规范内的。NAND闪存驱动程序应该检测到这一点，并将其标记为坏块。
- en: 'After space has been taken in the OOB area for a bad block flag and ECC bytes,
    there are still some bytes left. Some flash filesystems make use of these free
    bytes to store filesystem metadata. Consequently, lots of people are interested
    in the layout of the OOB area: the SoC ROM boot code, the bootloader, the kernel
    MTD driver, the filesystem code, and the tools to create filesystem images. There
    is not much standardization so it is easy to get into a situation in which the
    bootloader writes data using an OOB format that cannot be read by the kernel MTD
    driver. It is up to you to make sure that they all agree.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在OOB区域为坏块标志和ECC字节留出空间后，仍然有一些字节剩下。一些闪存文件系统利用这些空闲字节来存储文件系统元数据。因此，许多人对OOB区域的布局感兴趣：SoC
    ROM引导代码、引导加载程序、内核MTD驱动程序、文件系统代码以及创建文件系统映像的工具。标准化程度不高，因此很容易出现这样的情况：引导加载程序使用无法被内核MTD驱动程序读取的OOB格式写入数据。您需要确保它们都达成一致。
- en: Access to NAND flash chips requires a NAND flash controller, which is usually
    part of the SoC. You will need the corresponding driver in the bootloader and
    kernel. The NAND flash controller handles the hardware interface to the chip,
    transferring data to and from pages, and may include hardware for error correction.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 访问NAND闪存芯片需要一个NAND闪存控制器，通常是SoC的一部分。您需要引导加载程序和内核中相应的驱动程序。NAND闪存控制器处理与芯片的硬件接口，传输数据到和从页面，并可能包括用于纠错的硬件。
- en: There is a standard register-level interface for NAND flash chips known as the
    **open NAND flash interface** or **ONFi** which most modern chips adhere to. See
    [http://www.onfi.org](http://www.onfi.org).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: NAND闪存芯片有一个称为**开放NAND闪存接口**（**ONFi**）的标准寄存器级接口，大多数现代芯片都遵循这一标准。请参阅[http://www.onfi.org](http://www.onfi.org)。
- en: Managed flash
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理闪存
- en: The burden of supporting flash memory in the operating system, NAND in particular,
    becomes less if there is a well-defined hardware interface and a standard flash
    controller that hides the complexities of the memory. This is managed flash memory
    and it is becoming more and more common. In essence, it means combining one or
    more flash chips with a micro controller that offers an ideal storage device with
    a small sector size that is compatible with conventional filesystems. The most
    important types of managed flash for embedded systems are **Secure Digital** (**SD**)
    cards and the embedded variant known as **eMMC**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作系统中支持闪存存储的负担，尤其是NAND存储器，如果有一个明确定义的硬件接口和一个隐藏存储器复杂性的标准闪存控制器，那么负担就会减轻。这就是管理闪存存储器，它变得越来越普遍。实质上，它意味着将一个或多个闪存芯片与一个微控制器结合起来，提供一个与传统文件系统兼容的小扇区大小的理想存储设备。嵌入式系统中最重要的管理闪存类型是**安全数字**（**SD**）卡和嵌入式变体称为**eMMC**。
- en: MultiMediaCard and secure digital cards
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多媒体卡和安全数字卡
- en: 'The **MultiMediaCard** (**MMC**) was introduced in 1997 by SanDisk and Siemens
    as a form of packaged storage using flash memory. Shortly after, in 1999, SanDisk,
    Matsushita, and Toshiba created the SD card which is based on MMC but adds encryption
    and DRM (that is the secure part). Both were intended for consumer electronics
    such as digital cameras, music players, and similar devices. Currently, SD cards
    are the dominant form of managed flash for consumer and embedded electronics,
    even though the encryption features are seldom used. Newer versions of the SD
    specification allow for smaller packaging (mini SD and micro SD which is often
    written as uSD) and larger capacities: high capacity, SDHC, up to 32 GB and extended
    capacity, SDXC, up to 2 TB.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**多媒体卡**（**MMC**）于1997年由SanDisk和西门子推出，作为一种使用闪存存储的封装形式。不久之后，1999年，SanDisk、松下和东芝创建了基于MMC的SD卡，增加了加密和数字版权管理（即安全部分）。两者都是为数码相机、音乐播放器和类似设备而设计的消费类电子产品。目前，SD卡是消费类和嵌入式电子产品中主要的管理闪存形式，尽管加密功能很少被使用。SD规范的更新版本允许更小的封装（mini
    SD和micro SD，通常写作uSD）和更大的容量：高容量SDHC，最高达32GB，扩展容量SDXC，最高达2TB。'
- en: 'The hardware interface for MMC and SD cards is very similar, and it is possible
    to use fully-sized MMC in full-sized SD card slots (but not the other way round).
    Early incarnations used a 1-bit **Serial Peripheral Interface** (**SPI**); more
    recent cards use a 4-bit interface. There is a command set for reading and writing
    memory in sectors of 512 bytes. Inside the package there is a microcontroller
    and one or more NAND flash chips, as shown in the diagram that follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: MMC和SD卡的硬件接口非常相似，可以在全尺寸SD卡槽中使用全尺寸MMC（但反之则不行）。早期版本使用1位**串行外围接口**（**SPI**）；更近期的卡使用4位接口。有一个用于读写512字节扇区内存的命令集。在封装内部有一个微控制器和一个或多个NAND闪存芯片，如下图所示：
- en: '![MultiMediaCard and secure digital cards](img/B03982_07_07.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![多媒体卡和安全数字卡](img/B03982_07_07.jpg)'
- en: 'The microcontroller implements the command set and manages the flash memory,
    performing the function of a flash translation layer, as described later on in
    this chapter. They are pre-formatted with a FAT filesystem: FAT16 on SDSC cards,
    FAT32 on SDHC, and exFAT on SDXC. The quality of the NAND flash chips and the
    software on the microcontroller varies greatly between cards. It is questionable
    whether any of them are sufficiently reliable for deep embedded use, and certainly
    not with a FAT filesystem which is prone to file corruption. Remember that the
    prime use case for MMC and SD cards is for removable storage on cameras, tablets,
    and phones.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器实现命令集并管理闪存，执行闪存转换层的功能，如本章后面所述。它们预先格式化为FAT文件系统：SDSC卡上为FAT16，SDHC上为FAT32，SDXC上为exFAT。NAND闪存芯片的质量和微控制器上的软件在卡片之间差异很大。有人质疑它们是否足够可靠，尤其是对于容易发生文件损坏的FAT文件系统。请记住，MMC和SD卡的主要用途是相机、平板电脑和手机上的可移动存储。
- en: eMMC
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: eMMC
- en: '**eMMC** or **Embedded MMC** is simply MMC memory packaged so that it can be
    soldered on to the motherboard, using a 4- or 8-bit interface for data transfer.
    However, they are intended to be used as storage for an operating system so the
    components are capable of performing that task. The chips are usually not pre-formatted
    with any filesystem.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**eMMC**或**嵌入式MMC**只是MMC存储器的封装，可以焊接到主板上，使用4位或8位接口进行数据传输。但是，它们旨在用作操作系统的存储，因此组件能够执行该任务。芯片通常没有预先格式化任何文件系统。'
- en: Other types of managed flash
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他类型的管理闪存
- en: One of the first managed flash technologies was **CompactFlash** (**CF**), using
    a subset of the **PCMCIA** (**Personal Computer Memory Card International Association**)
    interface. CF exposes the memory through a parallel ATA interface and appears
    to the operating system as a standard hard disk. They are common in x86-based
    single board computers and professional video and camera equipment.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最早的管理闪存技术之一是**CompactFlash**（**CF**），使用**个人计算机存储卡国际协会**（**PCMCIA**）接口的子集。CF通过并行ATA接口公开存储器，并在操作系统中显示为标准硬盘。它们在基于x86的单板计算机和专业视频和摄像设备中很常见。
- en: One other format which we use every day is the USB flash drive. In this case,
    the memory is accessed through a USB interface and the controller implements the
    USB mass storage specification as well as the flash translation layer and interface
    to the flash chip or chips. The USB mass storage protocol, in turn, is based on
    the SCSI disk command set. As with MMC and SD cards, they are usually pre-formatted
    with a FAT filesystem. Their main use case in embedded systems is exchanging data
    with PCs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每天使用的另一种格式是USB闪存驱动器。在这种情况下，通过USB接口访问内存，并且控制器实现USB大容量存储规范以及闪存转换层和与闪存芯片的接口。USB大容量存储协议又基于SCSI磁盘命令集。与MMC和SD卡一样，它们通常预先格式化为FAT文件系统。它们在嵌入式系统中的主要用途是与个人电脑交换数据。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A recent addition to the list of options for managed flash storage is **universal
    flash storage** (**UFS**). Like eMMC, it is packaged in a chip that is mounted
    on the motherboard. It has a high-speed serial interface and can achieve data
    rates greater than eMMC. It supports a SCSI disk command set.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于受管理的闪存存储的选项列表的最新添加是**通用闪存存储**（**UFS**）。与eMMC一样，它被封装在安装在主板上的芯片中。它具有高速串行接口，可以实现比eMMC更高的数据速率。它支持SCSI磁盘命令集。
- en: Accessing flash memory from the bootloader
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从引导加载程序访问闪存
- en: In [Chapter 3](ch03.html "Chapter 3. All About Bootloaders"), *All About Bootloaders*,
    I mentioned the need for the bootloader to load kernel binaries and other images
    from various flash devices and to be able to perform system maintenance tasks
    such as erasing and reprogramming flash memory. It follows that the bootloader
    must have the drivers and infrastructure to support read, erase, and write operations
    on the type of memory you have, whether it be NOR, NAND, or managed. I will use
    U-Boot in the following example; other bootloaders follow a similar pattern.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。关于引导加载程序的一切")中，*关于引导加载程序的一切*，我提到了引导加载程序需要从各种闪存设备加载内核二进制文件和其他映像，并且能够执行系统维护任务，如擦除和重新编程闪存。因此，引导加载程序必须具有支持您拥有的内存类型的读取、擦除和写入操作的驱动程序和基础设施，无论是NOR、NAND还是受管理的内存。我将在以下示例中使用U-Boot；其他引导加载程序遵循类似的模式。
- en: U-Boot and NOR flash
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: U-Boot和NOR闪存
- en: 'U-Boot has drivers for NOR CFI chips in `drivers/mtd` and has the commands
    `erase` to erase memory and `cp.b` to copy data byte by byte, programming the
    flash. Suppose that you have NOR flash memory mapped from 0x40000000 to 0x48000000,
    of which 4MiB starting at 0x40040000 is a kernel image, then you would load a
    new kernel into flash using these U-Boot commands:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot在`drivers/mtd`中具有NOR CFI芯片的驱动程序，并具有`erase`命令来擦除内存和`cp.b`命令来逐字节复制数据，编程闪存。假设您有从0x40000000到0x48000000映射的NOR闪存，其中从0x40040000开始的4MiB是内核映像，那么您将使用这些U-Boot命令将新内核加载到闪存中：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The variable `filesize` in the preceding example is set by the `tftpboot` command
    to the size of the file just downloaded.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中的变量`filesize`是由`tftpboot`命令设置为刚刚下载的文件的大小。
- en: U-Boot and NAND flash
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: U-Boot和NAND闪存
- en: 'For NAND flash, you need a driver for the NAND flash controller on your SoC,
    which you can find in `drivers/mtd/nand`. You use the `nand` command to manage
    the memory using the sub-commands `erase`, `write`, and `read`. This example shows
    a kernel image being loaded into RAM at 0x82000000 and then placed into flash
    starting at offset 0x280000:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于NAND闪存，您需要一个针对SoC上的NAND闪存控制器的驱动程序，您可以在`drivers/mtd/nand`中找到。您可以使用`nand`命令来使用子命令`erase`、`write`和`read`来管理内存。此示例显示内核映像被加载到RAM的0x82000000处，然后从偏移0x280000开始放入闪存：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: U-Boot can also read files stored in the JFFS2, YAFFS2, and UBIFS filesystems.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot还可以读取存储在JFFS2、YAFFS2和UBIFS文件系统中的文件。
- en: U-Boot and MMC, SD and eMMC
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: U-Boot和MMC、SD和eMMC
- en: U-Boot has drivers for several MMC controllers in `drivers/mmc`. You can access
    the raw data using `mmc read` and `mmc write` at the user interface level, which
    allows you to handle raw kernel and filesystem images.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot在`drivers/mmc`中具有几个MMC控制器的驱动程序。您可以在用户界面级别使用`mmc read`和`mmc write`来访问原始数据，这允许您处理原始内核和文件系统映像。
- en: U-boot can also read files from the FAT32 and ext4 filesystems on MMC storage.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot还可以从MMC存储器上的FAT32和ext4文件系统中读取文件。
- en: Accessing flash memory from Linux
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Linux访问闪存内存
- en: Raw NOR and NAND flash memory is handled by the memory technology device sub-system,
    or MTD, which provides basic interfaces to read, erase, and write blocks of flash
    memory. In the case of NAND flash, there are functions to handle the OOB area
    and to identify bad blocks.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 原始NOR和NAND闪存由内存技术设备子系统（MTD）处理，该子系统提供了读取、擦除和写入闪存块的基本接口。对于NAND闪存，有处理OOB区域和识别坏块的功能。
- en: For managed flash, you need drivers to handle the particular hardware interface.
    MMC/SD cards and eMMC use the mmcblk driver; CompactFlash and hard drives use
    the SCSI Disk driver, sd. USB flash drives use the usb_storage driver together
    with the sd driver.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于受管理的闪存，您需要驱动程序来处理特定的硬件接口。MMC/SD卡和eMMC使用mmcblk驱动程序；CompactFlash和硬盘使用SCSI磁盘驱动程序sd。USB闪存驱动器使用usb_storage驱动程序以及sd驱动程序。
- en: Memory technology devices
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存技术设备
- en: The **memory technology** **devices** (**MTD**), sub-system was started by David
    Woodhouse in 1999 and has been extensively developed over the intervening years.
    In this section, I will concentrate on the way it handles the two main technologies,
    NOR and NAND flash.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存技术** **设备**（**MTD**）子系统由David Woodhouse于1999年创建，并在随后的几年中得到了广泛的发展。在本节中，我将集中讨论它处理的两种主要技术，NOR和NAND闪存。'
- en: 'MTD consists of three layers: a core set of functions, a set of drivers for
    various types of chips, and user-level drivers that present the flash memory as
    a character device or a block device, as shown in the following diagram:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: MTD由三层组成：一组核心功能、一组各种类型芯片的驱动程序以及将闪存内存呈现为字符设备或块设备的用户级驱动程序，如下图所示：
- en: '![Memory technology devices](img/B03982_07_02.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![内存技术设备](img/B03982_07_02.jpg)'
- en: The chip drivers are at the lowest level and interface with flash chips. Only
    a small number of drivers are needed for NOR flash chips, enough to cover the
    CFI standard and variations plus a few non-compliant chips which are now mostly
    obsolete. For NAND flash, you will need a driver for the NAND flash controller
    you are using; this is usually supplied as part of the board support package.
    There are drivers for about 40 of them in the current mainline kernel in the directory
    `drivers/mtd/nand`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 芯片驱动程序位于最低级别，并与闪存芯片进行接口。对于NOR闪存芯片，只需要少量驱动程序，足以覆盖CFI标准和变体，以及一些现在大多已经过时的不符合标准的芯片。对于NAND闪存，您将需要一个用于所使用的NAND闪存控制器的驱动程序；这通常作为板支持包的一部分提供。在当前主线内核中的`drivers/mtd/nand`目录中有大约40个这样的驱动程序。
- en: MTD partitions
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MTD分区
- en: 'In most cases, you will want to partition the flash memory into a number of
    areas, for example, to provide space for a bootloader, a kernel image, or a root
    filesystem. In MTD, there are several ways to specify the size and location of
    partitions, the main ones being:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您会希望将闪存内存分成多个区域，例如为引导加载程序、内核映像或根文件系统提供空间。在MTD中，有几种指定分区大小和位置的方法，主要包括：
- en: Through the kernel command line using `CONFIG_MTD_CMDLINE_PARTS`
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过内核命令行使用`CONFIG_MTD_CMDLINE_PARTS`
- en: Via the device tree using `CONFIG_MTD_OF_PARTS`
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设备树使用`CONFIG_MTD_OF_PARTS`
- en: With a platform mapping driver
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用平台映射驱动程序
- en: 'In the case of the first option, the kernel command line option to use is `mtdparts`,
    which is defined as follows in the Linux source code in `drivers/mtd/cmdlinepart.c`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种选项的情况下，要使用的内核命令行选项是`mtdparts`，在Linux源代码中在`drivers/mtd/cmdlinepart.c`中定义如下：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Perhaps an example will help. Imagine that you have one flash chip of 128 MB
    that is to be divided into five partitions. A typical command line would be:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 也许一个例子会有所帮助。假设您有一个128MB的闪存芯片，要分成五个分区。一个典型的命令行将是：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first element, before the colon, `:`, is `mtd-id`, which identifies the
    flash chip, either by number or by the name assigned by the board support package.
    If there is only one chip, as here, it can be left empty. If there is more than
    one chip, the information for each is separated by a semicolon, `;`. Then, for
    each chip, there is a comma-separated list of partitions, each with a size in
    bytes, kilobytes, `k`, or megabytes, `m`, and a name in brackets. The `ro` suffix
    makes the partition read-only to MTD and is often used to prevent accidental overwriting
    of the bootloader. The size of the last partition for the chip may be replaced
    by a dash, `-`, indicating that it should take up all the remaining space.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号`:`之前的第一个元素是`mtd-id`，它通过编号或者由板支持包分配的名称来标识闪存芯片。如果只有一个芯片，可以留空。如果有多个芯片，每个芯片的信息用分号`；`分隔。然后，对于每个芯片，有一个逗号分隔的分区列表，每个分区都有以字节、千字节`k`或兆字节`m`为单位的大小和括号中的名称。`ro`后缀使得分区对MTD是只读的，通常用于防止意外覆盖引导加载程序。对于芯片的最后一个分区，大小可以用破折号`-`替换，表示它应该占用所有剩余的空间。
- en: 'You can see a summary of the configuration at runtime by reading `/proc/mtd`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过读取`/proc/mtd`来查看运行时的配置摘要：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There is more detailed information for each partition in `/sys/class/mtd`,
    including the erase block size and the page size, and it is nicely summarized
    using `mtdinfo`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/sys/class/mtd`中有关每个分区的更详细信息，包括擦除块大小和页面大小，并且可以使用`mtdinfo`进行很好地总结：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The equivalent partition information can be written as part of the device tree
    like so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的分区信息可以在设备树的一部分中编写，如下所示：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A third alternative is to code the partition information as platform data in
    an `mtd_partition` structure, as shown in this example taken from `arch/arm/mach-omap2/board-omap3beagle.c`
    (NAND_BLOCK_SIZE is defined elsewhere to be 128K):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种选择是将分区信息编码为`mtd_partition`结构中的平台数据，如从`arch/arm/mach-omap2/board-omap3beagle.c`中取出的此示例所示（NAND_BLOCK_SIZE在其他地方定义为128K）：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: MTD device drivers
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MTD设备驱动程序
- en: 'The upper level of the MTD sub-system is a pair of device drivers:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: MTD子系统的上层是一对设备驱动程序：
- en: 'A character device, with a major number of 90\. There are two device nodes
    per MTD partition number, `N: /dev/mtdN` (*minor number=N*2*) and `/dev/mtdNro`
    (*minor number=(N*2 + 1)*). The latter is just a read-only version of the former.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一个字符设备，主编号为90。每个MTD分区号有两个设备节点，`N: /dev/mtdN`（*次编号=N*2*）和`/dev/mtdNro`（*次编号=(N*2
    + 1)*）。后者只是前者的只读版本。'
- en: A block device, with a major number of 31 and a minor number of N. The device
    nodes are in the form `/dev/mtdblockN`.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个块设备，主编号为31，次编号为N。设备节点的形式为`/dev/mtdblockN`。
- en: The MTD character device, mtd
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MTD字符设备，mtd
- en: 'The character devices are the most important: they allow you to access the
    underlying flash memory as an array of bytes so that you can read and write (program)
    the flash. It also implements a number of `ioctl` functions that allow you to
    erase blocks and to manage the OOB area on NAND chips. The following list is in
    `include/uapi/mtd/mtd-abi.h`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 字符设备是最重要的：它们允许您将底层闪存内存作为字节数组进行访问，以便您可以读取和写入（编程）闪存。它还实现了一些`ioctl`函数，允许您擦除块并管理NAND芯片上的OOB区域。以下列表在`include/uapi/mtd/mtd-abi.h`中：
- en: '| IOCTL | Description |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| IOCTL | 描述 |'
- en: '| --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `MEMGETINFO` | Gets basic MTD characteristic information |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `MEMGETINFO` | 获取基本的MTD特性信息 |'
- en: '| `MEMERASE` | Erases blocks in the MTD partition |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `MEMERASE` | 擦除MTD分区中的块 |'
- en: '| `MEMWRITEOOB` | Writes out-of-band data for the page |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `MEMWRITEOOB` | 写出页面的带外数据 |'
- en: '| `MEMREADOOB` | Reads out-of-band data for the page |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `MEMREADOOB` | 读取页面的带外数据 |'
- en: '| `MEMLOCK` | Locks the chip (if supported) |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `MEMLOCK` | 锁定芯片（如果支持） |'
- en: '| `MEMUNLOCK` | Unlocks the chip (if supported) |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `MEMUNLOCK` | 解锁芯片（如果支持） |'
- en: '| `MEMGETREGIONCOUNT` | Gets the number of erase regions: non-zero if there
    are erase blocks of differing sizes in the partition, which is common for NOR
    flash, rare on NAND |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `MEMGETREGIONCOUNT` | 获取擦除区域的数量：如果分区中有不同大小的擦除块，则为非零，这在NOR闪存中很常见，在NAND中很少见
    |'
- en: '| `MEMGETREGIONINFO` | If `MEMGETREGIONCOUNT` is non-zero, this can be used
    to get the offset, size, and block count of each region |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `MEMGETREGIONINFO` | 如果 `MEMGETREGIONCOUNT` 非零，可以用来获取每个区域的偏移量、大小和块数 |'
- en: '| `MEMGETOOBSEL` | Deprecated |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `MEMGETOOBSEL` | 已弃用 |'
- en: '| `MEMGETBADBLOCK` | Gets the bad block flag |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `MEMGETBADBLOCK` | 获取坏块标志 |'
- en: '| `MEMSETBADBLOCK` | Sets the bad block flag |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `MEMSETBADBLOCK` | 设置坏块标志 |'
- en: '| `OTPSELECT` | Sets OTP (one-time programmable) mode, if the chip supports
    it |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `OTPSELECT` | 如果芯片支持，设置 OTP（一次可编程）模式 |'
- en: '| `OTPGETREGIONCOUNT` | Gets the number of OTP regions |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `OTPGETREGIONCOUNT` | 获取 OTP 区域的数量 |'
- en: '| `OTPGETREGIONINFO` | Gets information about an OTP region |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `OTPGETREGIONINFO` | 获取有关 OTP 区域的信息 |'
- en: '| `ECCGETLAYOUT` | Deprecated |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `ECCGETLAYOUT` | 已弃用 |'
- en: 'There is a set of utility programs known as `mtd-utils` for manipulating flash
    memory that makes use of these `ioctl` functions. The source is available from
    [http://git.infradead.org/mtd-utils.git](http://git.infradead.org/mtd-utils.git)
    and is available as a package in the Yocto Project and Buildroot. The essential
    tools are shown in the following list. The package also contains utilities for
    the JFFS2 and UBI/UBIFS filesystems which I will cover later. For each of these
    tools, the MTD character device is one of the parameters:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有一组称为 `mtd-utils` 的实用程序，用于操作闪存内存，利用了这些 `ioctl` 函数。源代码可从 [http://git.infradead.org/mtd-utils.git](http://git.infradead.org/mtd-utils.git)
    获取，并作为 Yocto 项目和 Buildroot 中的软件包提供。以下是基本工具。该软件包还包含了稍后将介绍的 JFFS2 和 UBI/UBIFS 文件系统的实用程序。对于这些工具中的每一个，MTD
    字符设备是其中的一个参数：
- en: '**flash_erase**: Erases a range of blocks.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**flash_erase**：擦除一系列块。'
- en: '**flash_lock**: Locks a range of blocks.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**flash_lock**：锁定一系列块。'
- en: '**flash_unlock**: Unlocks a range of blocks.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**flash_unlock**：解锁一系列块。'
- en: '**nanddump**: Dumps memory from NAND flash, optionally including the OOB area.
    Skips bad blocks.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nanddump**：从 NAND 闪存中转储内存，可选择包括 OOB 区域。跳过坏块。'
- en: '**nandtest**: Tests and diagnostics for NAND flash.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nandtest**：用于 NAND 闪存的测试和诊断。'
- en: '**nandwrite**: Writes (program) from a data file to NAND flash, skipping bad
    blocks.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nandwrite**：从数据文件向 NAND 闪存写入（编程），跳过坏块。'
- en: Tip
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You must always erase flash memory before writing new contents to it: `flash_erase`
    is the command to do that.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在写入新内容之前，您必须始终擦除闪存内存：`flash_erase` 就是执行此操作的命令。
- en: To program NOR flash, you simply copy bytes to the MTD device node using the
    `cp` command or similar.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要编程 NOR 闪存，只需使用 `cp` 命令或类似命令将字节复制到 MTD 设备节点。
- en: Unfortunately, this doesn't work with NAND memory as the copy will fail at the
    first bad block. Instead, use `nandwrite`, which skips over any bad blocks. To
    read back NAND memory, you should use `nanddump` which also skips bad blocks.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这在 NAND 存储器上不起作用，因为在第一个坏块处复制将失败。相反，应该使用 `nandwrite`，它会跳过任何坏块。要读取 NAND 存储器，应该使用
    `nanddump`，它也会跳过坏块。
- en: The MTD block device, mtdblock
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MTD 块设备，mtdblock
- en: The mtdblock driver is little used. Its purpose is to present flash memory as
    a block device which you can use to format and mount as a filesystem. However,
    it has severe limitations because it does not handle bad blocks in NAND flash,
    does not do wear leveling, and does not handle the mismatch in size between filesystem
    blocks and flash erase blocks. In other words, it does not have a flash translation
    layer, which is essential for reliable file storage. The only case where the mtdblock
    device is useful is to mount read-only filesystems such as Squashfs on top of
    reliable flash memory such as NOR.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: mtdblock 驱动程序很少使用。它的目的是将闪存内存呈现为块设备，您可以使用它来格式化并挂载为文件系统。但是，它有严重的限制，因为它不处理 NAND
    闪存中的坏块，不进行磨损平衡，也不处理文件系统块和闪存擦除块之间的大小不匹配。换句话说，它没有闪存转换层，这对于可靠的文件存储至关重要。 mtdblock
    设备有用的唯一情况是在可靠的闪存内存（如 NOR）上挂载只读文件系统，例如 Squashfs。
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you want a read-only filesystem on NAND flash, you should use the UBI driver,
    as described later in this chapter.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在 NAND 闪存上使用只读文件系统，应该使用 UBI 驱动程序，如本章后面所述。
- en: Logging kernel oops to MTD
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将内核 oops 记录到 MTD
- en: Kernel errors, or oopsies, are normally logged via the `klogd` and `syslogd`
    daemons to a circular memory buffer or a file. Following a reboot, the log will
    be lost in the case of a ring buffer and, even in the case of a file, it may not
    have been properly written before the system crashed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 内核错误，或者 oopsies，通常通过 `klogd` 和 `syslogd` 守护进程记录到循环内存缓冲区或文件中。重启后，如果是环形缓冲区，日志将会丢失，即使是文件，系统崩溃前可能也没有正确写入。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A more reliable method is to write oops and kernel panics to an MTD partition
    as a circular log buffer. You enable it with `CONFIG_MTD_OOPS` and you add `console=ttyMTDN`
    to the kernel command line, `N` being the MTD device number to write the messages
    to.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 更可靠的方法是将 oops 和内核恐慌写入 MTD 分区作为循环日志缓冲区。您可以通过 `CONFIG_MTD_OOPS` 启用它，并在内核命令行中添加
    `console=ttyMTDN`，其中 `N` 是要将消息写入的 MTD 设备编号。
- en: Simulating NAND memory
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟 NAND 存储器
- en: The NAND simulator emulates a NAND chip using system RAM. The main use is for
    testing code that has to be NAND-aware without access to physical NAND memory.
    In particular, the ability to simulate bad blocks, bit flips, and other errors
    allows you to test code paths that are difficult to exercise using real flash
    memory. For more information, the best place to look is in the code itself, which
    has a comprehensive description of the ways you can configure the driver. The
    code is in `drivers/mtd/nand/nandsim.c`. Enable it with the kernel configuration
    `CONFIG_MTD_NAND_NANDSIM`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: NAND 模拟器使用系统 RAM 模拟 NAND 芯片。主要用途是测试必须了解 NAND 的代码，而无法访问物理 NAND 存储器。特别是，模拟坏块、位翻转和其他错误的能力允许您测试难以使用真实闪存内存进行练习的代码路径。有关更多信息，最好的地方是查看代码本身，其中详细描述了您可以配置驱动程序的方式。代码位于
    `drivers/mtd/nand/nandsim.c`。使用内核配置 `CONFIG_MTD_NAND_NANDSIM` 启用它。
- en: The MMC block driver
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MMC 块驱动程序
- en: MMC/SD cards and eMMC chips are accessed using the mmcblk block driver. You
    need a host controller to match the MMC adapter you are using, which is part of
    the board support package. The drivers are located in the Linux source code in
    `drivers/mmc/host`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: MMC/SD卡和eMMC芯片使用mmcblk块驱动程序进行访问。您需要一个与您使用的MMC适配器匹配的主机控制器，这是板支持包的一部分。驱动程序位于Linux源代码中的`drivers/mmc/host`中。
- en: MMC storage is partitioned using a partition table in exactly the same way you
    would for hard disks, using fdisk or a similar utility.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: MMC存储使用分区表进行分区，方式与硬盘完全相同，使用fdisk或类似的实用程序。
- en: Filesystems for flash memory
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闪存内存的文件系统
- en: 'There are several challenges when making efficient use of flash memory for
    mass storage: the mismatch between the size of an erase block and a disk sector,
    the limited number of erase cycles per erase block, and the need for bad block
    handling on NAND chips. These differences are resolved by a **Flash Translation
    Layer globally**, or **FTL**.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在有效利用闪存内存进行大容量存储时存在几个挑战：擦除块和磁盘扇区大小不匹配，每个擦除块的擦除周期有限，以及NAND芯片上需要坏块处理。这些差异通过**全局闪存转换层**或**FTL**来解决。
- en: Flash translation layers
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闪存转换层
- en: 'A flash translation layer has the following features:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 闪存转换层具有以下特点：
- en: '**Sub allocation**: Filesystems work best with a small allocation unit, traditionally
    a 512-byte sector. This is much smaller than a flash erase block of 128 KiB or
    more. Therefore erase blocks have to be sub-divided into smaller units to avoid
    wasting large amounts of space.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子分配**：文件系统最适合使用小的分配单元，传统上是512字节扇区。这比128 KiB或更大的闪存擦除块要小得多。因此，必须将擦除块细分为更小的单元，以避免浪费大量空间。'
- en: '**Garbage collection**: A consequence of sub-allocation is that an erase block
    will contain a mixture of good data and stale data after the filesystem has been
    in use for a while. Since we can only free up whole erase blocks, the only way
    to reclaim the free space is to coalesce the good data into one place and return
    the now empty erase block to the free list: this is garbage collection, and is
    usually implemented as a background thread.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾收集**：子分配的一个结果是，文件系统在使用一段时间后，擦除块将包含好数据和陈旧数据的混合。由于我们只能释放整个擦除块，因此重新获取空闲空间的唯一方法是将好数据合并到一个位置并将现在空的擦除块返回到空闲列表中：这就是垃圾收集，通常作为后台线程实现。'
- en: '**Wear leveling**: There is a limit on the number of erase cycles for each
    block. To maximize the lifespan of a chip, it is important to move data around
    so that each block is erased roughly the same number of times.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磨损平衡**：每个块的擦除周期都有限制。为了最大限度地延长芯片的寿命，重要的是移动数据，使每个块大致相同次数地擦除。'
- en: '**Bad block handling**: On NAND flash chips, you have to avoid using any block
    marked bad and also mark good blocks as bad if they cannot be erased.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**坏块处理**：在NAND闪存芯片上，您必须避免使用任何标记为坏的块，并且如果无法擦除，则将好块标记为坏。'
- en: '**Robustness**: Embedded devices may be powered off or reset without warning,
    so any filesystem should be able to cope without corruption, usually by incorporating
    a journal or log of transactions.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳健性**：嵌入式设备可能会突然断电或重置，因此任何文件系统都应该能够在没有损坏的情况下应对，通常是通过包含事务日志或日志来实现。'
- en: 'There are several ways to deploy the flash translation layer:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 部署闪存转换层有几种方法：
- en: '**In the filesystem**: as with JFFS2, YAFFS2, and UBIFS'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在文件系统中**：与JFFS2、YAFFS2和UBIFS一样'
- en: '**In the block device driver**: the UBI driver, on which UBIFS depends, implements
    some aspects of a flash translation layer'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在块设备驱动程序中**：UBI驱动程序实现了闪存转换层的一些方面，UBIFS依赖于它'
- en: '**In the device controller**: as with managed flash devices'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在设备控制器中**：与托管闪存设备一样'
- en: When the flash translation layer is in the filesystem or the block driver, the
    code is part of the kernel and so it is open source, meaning that we can see how
    it works and we can expect that it will be improved over time. On the other hand,
    the FTL is inside a managed flash device; it is hidden from view and we cannot
    verify whether or not it works as we would want. Not only that, but putting the
    FTL into the disk controller means that it misses out on information that is held
    at the filesystem layer such as which sectors belong to files that have been deleted
    and so do not contain useful data anymore. The latter problem is solved by adding
    commands that pass this information between the filesystem and the device I will
    describe in the section on the `TRIM` command later, but the question of code
    visibility remains. If you are using managed flash, you just have to choose a
    manufacturer you can trust.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当闪存转换层位于文件系统或块驱动程序中时，代码是内核的一部分，因此是开源的，这意味着我们可以看到它的工作方式，并且我们可以期望它会随着时间的推移而得到改进。另一方面，FTL位于托管闪存设备中；它被隐藏起来，我们无法验证它是否按照我们的期望工作。不仅如此，将FTL放入磁盘控制器意味着它错过了文件系统层保存的信息，比如哪些扇区属于已删除且不再包含有用数据的文件。后一个问题通过在文件系统和设备之间添加传递此信息的命令来解决，我将在后面的“TRIM”命令部分中描述，但代码可见性的问题仍然存在。如果您使用托管闪存，您只需选择一个您可以信任的制造商。
- en: Filesystems for NOR and NAND flash memory
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NOR和NAND闪存内的文件系统
- en: 'To use raw flash chips for mass storage, you have to use a filesystem that
    understands the peculiarities of the underlying technology. There are three such
    filesystems:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要将原始闪存芯片用于大容量存储，您必须使用了解底层技术特性的文件系统。有三种这样的文件系统：
- en: '**Journaling Flash File System 2, JFFS2**: This was the first flash filesystem
    for Linux, and is still in use today. It works for NOR and NAND memory, but is
    notoriously slow during mount.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志闪存文件系统2，JFFS2**：这是Linux的第一个闪存文件系统，至今仍在使用。它适用于NOR和NAND存储器，但在挂载时速度慢。'
- en: '**Yet Another Flash File System 2, YAFFS2**: This is similar to JFFS2, but
    specifically for NAND flash memory. It was adopted by Google as the preferred
    raw flash filesystem on Android devices.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**另一种闪存文件系统2，YAFFS2**：这类似于JFFS2，但专门用于NAND闪存。它被Google采用为Android设备上首选的原始闪存文件系统。'
- en: '**Unsorted Block Image File System, UBIFS**: This is the latest flash-aware
    filesystem for both NOR and NAND memory, which is used in conjunction with the
    UBI block driver. It generally offers better performance than JFFS2 or YAFFS2,
    and so should be the preferred solution for new designs.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未排序块映像文件系统，UBIFS**: 这是最新的适用于NOR和NAND存储器的闪存感知文件系统，它与UBI块驱动程序一起使用。它通常比JFFS2或YAFFS2提供更好的性能，因此应该是新设计的首选解决方案。'
- en: All of these use MTD as the common interface to flash memory.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都使用MTD作为闪存内存的通用接口。
- en: JFFS2
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JFFS2
- en: The Journaling Flash File System had its beginnings in the software for the
    Axis 2100 network camera in 1999\. For many years, it was the only flash filesystem
    for Linux and has been deployed on many thousands of different types of devices.
    Today, it is not the best choice, but I will cover it first because it shows the
    beginning of the evolutionary path.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 日志闪存文件系统始于1999年Axis 2100网络摄像机的软件。多年来，它是Linux上唯一的闪存文件系统，并已部署在成千上万种不同类型的设备上。今天，它并不是最佳选择，但我会首先介绍它，因为它展示了进化路径的开始。
- en: JFFS2 is a log-structured filesystem that uses MTD to access flash memory. In
    a log-structured filesystem, changes are written sequentially as nodes to the
    flash memory. A node may contain changes to a directory, such as the names of
    files created and deleted, or it may contain changes to file data. After a while,
    a node may be superseded by information contained in subsequent nodes and becomes
    an obsolete node.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: JFFS2是一种使用MTD访问闪存内存的日志结构文件系统。在日志结构文件系统中，更改被顺序写入闪存内存作为节点。一个节点可能包含对目录的更改，例如创建和删除的文件名，或者它可能包含对文件数据的更改。一段时间后，一个节点可能被后续节点中包含的信息取代，并成为过时的节点。
- en: 'Erase blocks are categorized into three types:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 擦除块分为三种类型：
- en: '**free**: It contains no nodes at all'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空闲**: 它根本不包含任何节点'
- en: '**clean**: It contains only valid nodes'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**干净**: 它只包含有效节点'
- en: '**dirty**: It contains at least one obsolete node'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脏**: 它至少包含一个过时的节点'
- en: At any one time, there is one block receiving updates which is called the open
    block. If power is lost or the system is reset, the only data that can be lost
    is the last write to the open block. In addition, nodes are compressed as they
    are written, increasing the effective storage capacity of the flash chip, which
    is important if you are using expensive NOR flash memory.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，都有一个正在接收更新的块，称为打开块。如果断电或系统重置，唯一可能丢失的数据就是对打开块的最后一次写入。此外，节点在写入时会被压缩，增加了闪存芯片的有效存储容量，这对于使用昂贵的NOR闪存存储器非常重要。
- en: When the number of free blocks falls below a threshold, a garbage collector
    kernel thread is started, which scans for dirty blocks and copies the valid nodes
    into the open block, and then frees up the dirty block.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当空闲块的数量低于阈值时，将启动一个垃圾收集器内核线程，扫描脏块并将有效节点复制到打开块，然后释放脏块。
- en: At the same time, the garbage collector provides a crude form of wear leveling
    because it cycles valid data from one block to another. The way that the open
    block is chosen means that each block is erased roughly the same number of times
    so long as it contains data that changes from time to time. Sometimes a clean
    block is chosen for garbage collection to make sure that blocks containing static
    data that is seldom written are also wear leveled.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，垃圾收集器提供了一种粗糙的磨损平衡，因为它将有效数据从一个块循环到另一个块。选择打开块的方式意味着只要它包含不时更改的数据，每个块被擦除的次数大致相同。有时会选择一个干净的块进行垃圾收集，以确保包含很少写入的静态数据的块也得到磨损平衡。
- en: 'JFFS2 filesystems have a write through cache, meaning that writes are written
    to the flash memory synchronously as if they have been mounted with a `-o sync`
    option. While improving reliability, it does increase the time to write data.
    There is a further problem with small writes: if the length of a write is comparable
    to the size of the node header (40 bytes) the overhead becomes high. A well-known
    corner case is log files, produced, for example, by syslogd.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: JFFS2文件系统具有写穿缓存，这意味着写入的数据会同步写入闪存内存，就好像已经使用`-o sync`选项挂载一样。虽然提高了可靠性，但会增加写入数据的时间。小写入还存在另一个问题：如果写入的长度与节点头部的大小（40字节）相当，开销就会很高。一个众所周知的特例是由syslogd产生的日志文件。
- en: Summary nodes
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要节点
- en: 'There is one overriding disadvantage to JFFS2: since there is no on-chip index,
    the directory structure has to be deduced at mount-time by reading the log from
    start to finish. At the end of the scan, you have a complete picture of the directory
    structure of the valid nodes, but the time taken is proportional to the size of
    the partition. It is not uncommon to see mount times of the order of one second
    per megabyte, leading to total mount times of tens or hundreds of seconds.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: JFFS2有一个主要的缺点：由于没有芯片上的索引，目录结构必须在挂载时通过从头到尾读取日志来推导。在扫描结束时，您可以得到有效节点的目录结构的完整图像，但所花费的时间与分区的大小成正比。挂载时间通常为每兆字节一秒左右，导致总挂载时间为几十秒或几百秒。
- en: To reduce the time to scan during mount, summary nodes became an option in Linux
    2.6.15\. A summary node is written at the end of the open erase block just before
    it is closed. The summary node contains all of the information needed for the
    mount-time scan, thereby reducing the amount of data to process during the scan.
    Summary nodes can reduce mount times by a factor of between two and five, at the
    expense of an overhead of about 5% of the storage space. They are enabled with
    the kernel configuration `CONFIG_JFFS2_SUMMARY`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少挂载时的扫描时间，摘要节点在Linux 2.6.15中成为一个选项。摘要节点是在关闭之前的打开擦除块的末尾写入的。摘要节点包含挂载时扫描所需的所有信息，从而减少了扫描期间需要处理的数据量。摘要节点可以将挂载时间缩短两到五倍，但会增加大约5%的存储空间开销。它们可以通过内核配置`CONFIG_JFFS2_SUMMARY`启用。
- en: Clean markers
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 干净标记
- en: An erased block with all bits set to 1 is indistinguishable from a block that
    has been written with 1's, but the latter has not had its memory cells refreshed
    and cannot be programmed again until it is erased. JFFS2 uses a mechanism called
    clean markers to distinguish between these two situations. After a successful
    block erase, a clean marker is written, either to the beginning of the block,
    or to the OOB area of the first page of the block. If the clean marker exists
    then it must be a clean block.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所有位设置为1的擦除块与已写入1的块无法区分，但后者尚未刷新其存储单元，直到擦除后才能再次编程。JFFS2使用称为清洁标记的机制来区分这两种情况。成功擦除块后，将写入一个清洁标记，可以写入到块的开头或块的第一页的OOB区域。如果存在清洁标记，则必须是一个干净的块。
- en: Creating a JFFS2 filesystem
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建JFFS2文件系统
- en: 'Creating an empty JFFS2 filesystem at runtime is as simple as erasing an MTD
    partition with clean markers and then mounting it. There is no formatting step
    because a blank JFFS2 filesystem consists entirely of free blocks. For example,
    to format MTD partition 6, you would enter these commands on the device:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时创建空的JFFS2文件系统就像擦除带有清洁标记的MTD分区然后挂载它一样简单。因为空白的JFFS2文件系统完全由空闲块组成，所以没有格式化步骤。例如，要格式化MTD分区6，您可以在设备上输入以下命令：
- en: '[PRE8]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `-j` option to `flash_erase` adds the clean markers, and mounting with type
    `jffs2` presents the partition as an empty filesystem. Note that the device to
    be mounted is given as `mtd6`, not `/dev/mtd6`. Alternatively, you can give the
    block device node `/dev/mtdblock6`. This is just a peculiarity of JFFS2\. Once
    mounted, you can treat it like any filesystem and, when you next boot and mount
    it, all the files will still be there.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`-j`选项`flash_erase`添加清洁标记，并使用类型`jffs2`挂载分区作为空文件系统。请注意，要挂载的设备是给定为`mtd6`，而不是`/dev/mtd6`。或者，您可以提供块设备节点`/dev/mtdblock6`。这只是JFFS2的一个特殊之处。一旦挂载，您可以像任何文件系统一样处理它，并且在下次启动和挂载时，所有文件仍将存在。'
- en: You can create a filesystem image directly from the staging area of your development
    system using `mkfs.jffs2` to write out the files in JFFS2 format and `sumtool`
    to add the summary nodes. Both of these are part of the `mtd-utils` package.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接从开发系统的暂存区使用`mkfs.jffs2`以JFFS2格式写出文件系统图像，并使用`sumtool`添加摘要节点。这两者都是`mtd-utils`软件包的一部分。
- en: 'As an example, to create an image of the files in `rootfs` for a NAND flash
    device with an erase block size of 128 KB (0x20000) and with summary nodes, you
    would use these two commands:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要为擦除块大小为128 KB（0x20000）且具有摘要节点的NAND闪存设备创建`rootfs`中的文件的图像，您将使用以下两个命令：
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `-p` option adds padding at the end of the image file to make it a whole
    number of erase blocks. The `-n` option suppresses the creation of clean markers
    in the image, which is normal for NAND devices as the clean marker is in the OOB
    area. For NOR devices, you would leave out the `-n` option. You can use a device
    table with `mkfs.jffs2` to set the permissions and the ownership of files by adding
    `-D` [device table]. Of course, Buildroot and the Yocto Project will do all this
    for you.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p`选项在图像文件末尾添加填充，使其成为整数倍的擦除块。`-n`选项抑制在图像中创建清洁标记，这对于NAND设备是正常的，因为清洁标记在OOB区域中。对于NOR设备，您可以省略`-n`选项。您可以使用`mkfs.jffs2`的设备表通过添加`-D`[设备表]来设置文件的权限和所有权。当然，Buildroot和Yocto
    Project将为您完成所有这些工作。'
- en: 'You can program the image into flash memory from your bootloader. For example,
    if you have loaded a filesytem image into RAM at address 0x82000000 and you want
    to load it into a flash partition begins at 0x163000 bytes from the start of the
    flash chip and is 0x7a9d000 bytes long, the U-Boot commands would be:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从引导加载程序将图像编程到闪存中。例如，如果您已将文件系统图像加载到RAM的地址0x82000000，并且希望将其加载到从闪存芯片开始的0x163000字节处的闪存分区，并且长度为0x7a9d000字节，则U-Boot命令将是：
- en: '[PRE10]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can do the same thing from Linux using the mtd driver like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用mtd驱动程序从Linux执行相同的操作：
- en: '[PRE11]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To boot with a JFFS2 root filesystem, you need to pass the `mtdblock` device
    on the kernel command line for the partition and a root `fstype` because JFFS2
    cannot be auto-detected:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用JFFS2根文件系统进行引导，您需要在内核命令行上传递`mtdblock`设备用于分区和根`fstype`，因为JFFS2无法自动检测：
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: YAFFS2
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: YAFFS2
- en: The YAFFS filesystem was written by Charles Manning beginning in 2001, specifically
    to handle NAND flash chips at a time when JFFS2 did not. Subsequent changes to
    handle larger (2 KiB) page sizes resulted in YAFFS2\. The website for YAFFS is
    [http://www.yaffs.net](http://www.yaffs.net).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: YAFFS文件系统是由Charles Manning于2001年开始编写的，专门用于处理当时JFFS2无法处理的NAND闪存芯片。后来的更改以处理更大（2
    KiB）的页面大小导致了YAFFS2。YAFFS的网站是[http://www.yaffs.net](http://www.yaffs.net)。
- en: YAFFS is also a log-structured filesystem following the same design principles
    as JFFS2\. The different design decisions mean that it has a faster mount-time
    scan, simpler and faster garbage collection, and has no compression, which speeds
    up reads and writes at the expense of less efficient use of storage.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: YAFFS也是一个遵循与JFFS2相同设计原则的日志结构文件系统。不同的设计决策意味着它具有更快的挂载时间扫描，更简单和更快的垃圾收集，并且没有压缩，这加快了读写速度，但以存储的效率较低为代价。
- en: 'YAFFS is not limited to Linux; it has been ported to a wide range of operating
    systems. It has a dual license: GPLv2 to be compatible with Linux, and a commercial
    license for other operating systems. Unfortunately, the YAFFS code has never been
    merged into mainline Linux so you will have to patch your kernel, as shown in
    the following code.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: YAFFS不仅限于Linux；它已被移植到各种操作系统。它具有双重许可证：GPLv2与Linux兼容，以及其他操作系统的商业许可证。不幸的是，YAFFS代码从未合并到主线Linux中，因此您将不得不像下面的代码所示一样对内核进行补丁。
- en: 'To get YAFFS2 and patch a kernel, you would:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取YAFFS2并对内核进行补丁，您可以：
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Then, configure the kernel with `CONFIG_YAFFS_YAFFS2`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`CONFIG_YAFFS_YAFFS2`配置内核。
- en: Creating a YAFFS2 filesystem
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建YAFFS2文件系统
- en: 'As with JFFS2, to create a YAFFS2 filesystem at runtime, you only need to erase
    the partition and mount it but note that, in this case, you do not enable clean
    markers:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与JFFS2一样，要在运行时创建YAFFS2文件系统，您只需要擦除分区并挂载它，但请注意，在这种情况下，不要启用清除标记：
- en: '[PRE14]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To create a filesystem image, the simplest thing to do is use the `mkyaffs2`
    tool from [https://code.google.com/p/yaffs2utils](https://code.google.com/p/yaffs2utils)
    using the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建文件系统映像，最简单的方法是使用[https://code.google.com/p/yaffs2utils](https://code.google.com/p/yaffs2utils)中的`mkyaffs2`工具，使用以下命令：
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here `-c` is the page size and `-s` the OOB size. There is a tool named `mkyaffs2image`
    that is part of the YAFFS code, but it has a couple of drawbacks. Firstly, the
    page and OOB size are hard-coded in the source: you will have to edit and recompile
    if you have memory that does not match the defaults of 2,048 and 64\. Secondly,
    the OOB layout is incompatible with MTD, which uses the first two byes as a bad
    block marker, whereas `mkyaffs2image` uses those bytes to store part of the YAFFS
    metadata.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`-c`是页面大小，`-s`是OOB大小。有一个名为`mkyaffs2image`的工具，它是YAFFS代码的一部分，但它有一些缺点。首先，页面和OOB大小在源代码中是硬编码的：如果内存与默认值2,048和64不匹配，则必须编辑并重新编译。其次，OOB布局与MTD不兼容，MTD使用前两个字节作为坏块标记，而`mkyaffs2image`使用这些字节来存储部分YAFFS元数据。
- en: 'To copy the image to the MTD partition from a Linux shell prompt, follow these
    steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux shell提示符下将图像复制到MTD分区，请按照以下步骤操作：
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To boot with a YAFFS2 root filesystem, add the following to the kernel command
    line:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用YAFFS2根文件系统启动，请将以下内容添加到内核命令行：
- en: '[PRE17]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: UBI and UBIFS
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UBI和UBIFS
- en: The **unsorted block image** (**UBI**) driver, is a volume manager for flash
    memory which takes care of bad block handling and wear leveling. It was implemented
    by Artem Bityutskiy and first appeared in Linux 2.6.22\. In parallel with that,
    engineers at Nokia were working on a filesystem that would take advantage of the
    features of UBI which they called UBIFS; it appeared in Linux 2.6.27\. Splitting
    the flash translation layer in this way makes the code more modular and also allows
    other filesystems to take advantage of the UBI driver, as we shall see later on.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**未排序的块图像**（**UBI**）驱动程序是闪存的卷管理器，负责处理坏块处理和磨损平衡。它是由Artem Bityutskiy实现的，并首次出现在Linux
    2.6.22中。与此同时，诺基亚的工程师们正在开发一种可以利用UBI功能的文件系统，他们称之为UBIFS；它出现在Linux 2.6.27中。以这种方式拆分闪存转换层使代码更加模块化，并且还允许其他文件系统利用UBI驱动程序，我们稍后将看到。'
- en: UBI
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UBI
- en: UBI provides an idealized, reliable view of a flash chip by mapping **physical
    erase blocks** (**PEB**) to **logical erase blocks** (**LEB**). Bad blocks are
    not mapped to LEBs and so are never used. If a block cannot be erased, it is marked
    as bad and dropped from the mapping. UBI keeps a count of the number of times
    each PEB has been erased in the header of the LEB and changes the mapping to ensure
    that each PEB is erased the same number of times.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: UBI通过将**物理擦除块**（**PEB**）映射到**逻辑擦除块**（**LEB**）来为闪存芯片提供理想化的可靠视图。坏块不会映射到LEB，因此不会被使用。如果块无法擦除，则将其标记为坏块并从映射中删除。UBI在LEB的标头中保留了每个PEB被擦除的次数，并更改映射以确保每个PEB被擦除相同次数。
- en: 'UBI accesses the flash memory through the MTD layer. As an extra feature, it
    can divide an MTD partition into a number of UBI volumes, which improves wear
    leveling in the following way. Imagine that you have two filesystems, one containing
    fairly static data, for example, a root filesystem, and the other containing data
    that is constantly changing. If they are stored in separate MTD partitions, the
    wear leveling only has an effect on the second one, whereas, if you choose to
    store them in two UBI volumes in a single MTD partition, the wear leveling takes
    place over both areas of the storage and the lifetime of the flash memory is increased.
    The following diagram illustrates this situation:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: UBI通过MTD层访问闪存。作为额外功能，它可以将MTD分区划分为多个UBI卷，从而以以下方式改善磨损平衡。想象一下，您有两个文件系统，一个包含相当静态的数据，例如根文件系统，另一个包含不断变化的数据。如果它们存储在单独的MTD分区中，磨损平衡只对第二个产生影响，而如果您选择将它们存储在单个MTD分区中的两个UBI卷中，磨损平衡将在存储的两个区域上进行，并且闪存的寿命将增加。以下图表说明了这种情况：
- en: '![UBI](img/B03982_07_03.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![UBI](img/B03982_07_03.jpg)'
- en: 'In this way, UBI fulfills two of the requirements of a flash translation layer:
    wear leveling and bad block handling.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，UBI满足了闪存转换层的两个要求：磨损平衡和坏块处理。
- en: 'To prepare an MTD partition for UBI, you don''t use `flash_erase` as with JFFS2
    and YAFFS2, instead you use the `ubiformat` utility, which preserves the erase
    counts that are stored in the PED headers. `ubiformat` needs to know the minimum
    unit of IO which, for most NAND flash chips, is the page size, but some chips
    allow reading and writing in sub pages that are a half or a quarter of the page
    size. Consult the chip data sheet for details and, if in doubt, use the page size.
    This example prepares `mtd6` using a page size of 2,048 bytes:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要为UBI准备MTD分区，不要像JFFS2和YAFFS2一样使用`flash_erase`，而是使用`ubiformat`实用程序，它保留存储在PED标头中的擦除计数。
    `ubiformat`需要知道IO的最小单位，对于大多数NAND闪存芯片来说，这是页面大小，但是一些芯片允许以半页或四分之一页的子页进行读写。有关详细信息，请参阅芯片数据表，如果有疑问，请使用页面大小。此示例使用2,048字节的页面大小准备`mtd6`：
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You use the `ubiattach` command to load the UBI driver on an MTD partition
    that has been prepared in this way:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`ubiattach`命令在已准备好的MTD分区上加载UBI驱动程序：
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This creates the device node `/dev/ubi0` through which you can access the UBI
    volumes. You can use `ubiattach` multiple times for other MTD partitions, in which
    case they can be accessed through `/dev/ubi1`, `/dev/ubi2`, and so on.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建设备节点`/dev/ubi0`，通过它可以访问UBI卷。您可以多次使用`ubiattach`来处理其他MTD分区，在这种情况下，它们可以通过`/dev/ubi1`，`/dev/ubi2`等进行访问。
- en: The PEB to LEB mapping is loaded into memory during the attach phase, a process
    that takes time proportional to the number of PEBs, typically a few seconds. A
    new feature was added in Linux 3.7 called the UBI fastmap which checkpoints the
    mapping to flash from time to time and so reduces the attach time. The kernel
    configuration option is `CONFIG_MTD_UBI_FASTMAP`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: PEB到LEB的映射在附加阶段加载到内存中，这个过程需要的时间与PEB的数量成正比，通常需要几秒钟。在Linux 3.7中添加了一个名为UBI fastmap的新功能，它会定期将映射检查点到闪存中，从而减少了附加时间。内核配置选项是`CONFIG_MTD_UBI_FASTMAP`。
- en: 'The first time you attach to an MTD partition after a `ubiformat` there will
    be no volumes. You can create volumes using `ubimkvol`. For example, suppose you
    have a 128MB MTD partition and you want to split it into two volumes of 32 MB
    and 96 MB using a chip with 128 KB erase blocks and 2 KB pages:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ubiformat`后第一次附加到MTD分区时，不会有卷。您可以使用`ubimkvol`创建卷。例如，假设您有一个128MB的MTD分区，并且您想要使用具有128
    KB擦除块和2 KB页面的芯片将其分成32 MB和96 MB两个卷：
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, you have device the nodes `/dev/ubi0_0` and `/dev/ubi0_1`. You can confirm
    the situation using `ubinfo`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您有设备节点`/dev/ubi0_0`和`/dev/ubi0_1`。您可以使用`ubinfo`确认情况：
- en: '[PRE21]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that, since each LEB has a header to contain the meta information used
    by UBI, the LEB is smaller than the PEB by one page. For example, a chip with
    a PEB size of 128 KB and 2 KB pages would have an LEB of 126 KB. This is important
    information that you will need when creating a UBIFS image.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于每个LEB都有一个头部来包含UBI使用的元信息，因此LEB比PEB小一个页面。例如，一个PEB大小为128 KB，页面大小为2 KB的芯片将具有126
    KB的LEB。这是您在创建UBIFS映像时需要的重要信息。
- en: UBIFS
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UBIFS
- en: UBIFS uses a UBI volume to create a robust filesystem. It adds sub-allocation
    and garbage collection to create a complete flash translation layer. Unlike JFFS2
    and YAFFS2, it stores index information on-chip and so mounting is fast, although
    don't forget that attaching the UBI volume beforehand may take a significant amount
    of time. It also allows for write-back caching like a normal disk filesystem,
    which means that writes are much faster, but with the usual problem of potential
    loss of data that has not been flushed from the cache to flash memory in the event
    of power down. You can resolve the problem by making careful use of the `fsync(2)`
    and `fdatasync(2)` functions to force a flush of file data at crucial points.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: UBIFS使用UBI卷创建一个稳健的文件系统。它添加了子分配和垃圾收集以创建一个完整的闪存转换层。与JFFS2和YAFFS2不同，它将索引信息存储在芯片上，因此挂载速度很快，尽管不要忘记预先附加UBI卷可能需要相当长的时间。它还允许像普通磁盘文件系统一样进行写回缓存，这意味着写入速度更快，但通常的问题是在断电事件中，未从缓存刷新到闪存内存的数据可能会丢失。您可以通过谨慎使用`fsync(2)`和`fdatasync(2)`函数来解决这个问题，在关键点强制刷新文件数据。
- en: UBIFS has a journal for fast recovery in the event power down. The journal takes
    up some space, typically 4 MiB or more, so UBIFS is not suitable for very small
    flash devices.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: UBIFS具有用于断电快速恢复的日志。日志占用一些空间，通常为4 MiB或更多，因此UBIFS不适用于非常小的闪存设备。
- en: 'Once you have created the UBI volumes, you can mount them using the device
    node for the volume, `/dev/ubi0_0`, or by using the device node for the whole
    partition plus the volume name, as shown here:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 创建UBI卷后，您可以使用卷的设备节点`/dev/ubi0_0`进行挂载，或者使用整个分区的设备节点加上卷名称进行挂载，如下所示：
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Creating a filesystem image for UBIFS is a two-stage process: first you create
    a UBIFS image using `mkfs.ubifs`, and then embed it into a UBI volume using `ubinize`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为UBIFS创建文件系统映像是一个两阶段的过程：首先使用`mkfs.ubifs`创建一个UBIFS映像，然后使用`ubinize`将其嵌入到UBI卷中。
- en: 'For the first stage, `mkfs.ubifs` needs to be informed of the page size with
    `-m`, the size of the UBI LEB with `-e`, remembering that the LEB is usually one
    page shorter than the PEB, and the maximum number of erase blocks in the volume
    with `-c`. If the first volume is 32 MiB and an erase block is 128 KiB, then the
    number of erase blocks is 256\. So, to take the contents of the directory rootfs
    and create a UBIFS image named `rootfs.ubi`, you would type the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一阶段，`mkfs.ubifs`需要使用`-m`指定页面大小，使用`-e`指定UBI LEB的大小，记住LEB通常比PEB短一个页面，使用`-c`指定卷中擦除块的最大数量。如果第一个卷是32
    MiB，擦除块是128 KiB，那么擦除块的数量是256。因此，要获取目录rootfs的内容并创建一个名为`rootfs.ubi`的UBIFS映像，您需要输入以下内容：
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The second stage requires you to create a configuration file for `ubinize`
    which describes the characteristics of each volume in the image. The help page
    (`ubinize -h`) gives details of the format. This example creates two volumes,
    `vol_1` and `vol_2`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段需要您为`ubinize`创建一个配置文件，描述映像中每个卷的特性。帮助页面（`ubinize -h`）提供了格式的详细信息。此示例创建了两个卷，`vol_1`和`vol_2`：
- en: '[PRE24]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The second volume has an auto-resize flag and so will expand to fill the remaining
    space on the MTD partition. Only one volume can have this flag. From this information,
    `ubinize` will create an image file named by the `-o` parameter, with the PEB
    size `-p`, the page size `-m`, and the sub-page size `-s`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 第二卷有一个自动调整大小的标志，因此会扩展以填满MTD分区上的剩余空间。只有一个卷可以有这个标志。根据这些信息，`ubinize`将创建一个由`-o`参数命名的映像文件，其PEB大小为`-p`，页面大小为`-m`，子页面大小为`-s`：
- en: '[PRE25]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To install this image on the target, you would enter these commands on the
    target:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要在目标上安装此映像，您需要在目标上输入以下命令：
- en: '[PRE26]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you want to boot with a UBIFS root filesystem, you would give these kernel
    command line parameters:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用UBIFS根文件系统进行引导，您需要提供以下内核命令行参数：
- en: '[PRE27]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Filesystems for managed flash
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受管理的闪存文件系统
- en: As the trend towards managed flash technologies continues, particularly eMMC,
    we need to consider how to use it effectively. While they appear to have the same
    characteristics as hard disk drives, some NAND flash chips have the limitations
    of large erase blocks with limited erase cycles and bad block handling. And, of
    course, we need robustness in the event of losing power.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 随着受管理的闪存技术的发展，特别是eMMC，我们需要考虑如何有效地使用它。虽然它们看起来具有与硬盘驱动器相同的特性，但一些NAND闪存芯片具有大擦除块的限制，擦除周期有限，并且坏块处理能力有限。当然，在断电事件中我们需要稳健性。
- en: It is possible to use any of the normal disk filesystems but we should try to
    choose one that reduces disk writes and has a fast restart after an unscheduled
    shutdown, typically provided by a journal.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用任何正常的磁盘文件系统，但我们应该尽量选择一个减少磁盘写入并在非计划关闭后快速重启的文件系统，通常由日志提供。
- en: Flashbench
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flashbench
- en: To make optimum use of the underlying flash memory, you need to know the erase
    block size and page size. Manufacturers do not publish these numbers, as a rule,
    but it is possible to deduce them by observing the behavior of the chip or card.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最佳利用底层闪存，您需要了解擦除块大小和页大小。通常制造商不会公布这些数字，但可以通过观察芯片或卡的行为来推断出它们。
- en: Flashbench is one such tool. It was initially written by Arnd Bergman, as described
    in the LWN article available at [http://lwn.net/Articles/428584](http://lwn.net/Articles/428584).
    You can get the code from [https://github.com/bradfa/flashbench](https://github.com/bradfa/flashbench).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Flashbench就是这样一个工具。最初是由Arnd Bergman编写的，可以在[LWN文章](http://lwn.net/Articles/428584)中找到。您可以从[https://github.com/bradfa/flashbench](https://github.com/bradfa/flashbench)获取代码。
- en: 'Here is a typical run on a SanDisk GiB SDHC card:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的SanDisk GiB SDHC卡上的运行：
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Flashbench reads blocks of, in this case, 1,024 bytes just before and just after
    various power-of-two boundaries. As you cross a page or erase block boundary,
    the reads after the boundary take longer. The rightmost column shows the difference
    and is the one that is most interesting. Reading from the bottom, there is a big
    jump at 4 KiB, which is the most likely size of a page. There is a second jump
    from 52.4µs to 349µs at 8 KiB. This is fairly common and indicates that the card
    can use multi-plane accesses to read two 4 KiB pages at the same time. Beyond
    that, the differences are less well marked, but there is a clear jump from 485µs
    to 805µs at 512 KiB, which is probably the erase block size. Given that the card
    being tested is quite old, these are the sort of numbers you would expect.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Flashbench在各种2的幂边界之前和之后读取块，本例中为1,024字节。当您跨越页或擦除块边界时，边界后的读取时间会变长。最右边的列显示了差异，这是最有趣的部分。从底部开始阅读，4
    KiB处有一个很大的跳跃，这很可能是一个页的大小。在8 KiB处，从52.4µs跳到349µs有第二个跳跃。这是相当常见的，表明卡可以使用多平面访问同时读取两个4
    KiB页。除此之外，差异不太明显，但在512 KiB处有一个明显的跳跃，从485µs跳到805µs，这可能是擦除块的大小。考虑到被测试的卡相当古老，这些是您可以预期的数字。
- en: Discard and TRIM
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 丢弃和TRIM
- en: Usually, when you delete a file, only the modified directory node is written
    to storage while the sectors containing the file's contents remain unchanged.
    When the flash translation layer is in the disk controller, as with managed flash,
    it does not know that this group of disk sectors no longer contains useful data
    and so it ends up copying stale data.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当您删除文件时，只有修改后的目录节点被写入存储，而包含文件内容的扇区保持不变。当闪存转换层位于磁盘控制器中时，例如受管理的闪存，它不知道这组磁盘扇区不再包含有用数据，因此最终会复制过时的数据。
- en: In the last few years, the addition of transactions that pass information about
    deleted sectors down to the disk controller has improved the situation. The SCSI
    and SATA specifications have a `TRIM` command and MMC has a similar command named
    `ERASE`. In Linux, this feature is known as `discard`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，传递有关已删除扇区的事务的添加已改善了情况。SCSI和SATA规范有一个`TRIM`命令，MMC有一个类似的命令称为`ERASE`。在Linux中，此功能称为`discard`。
- en: 'To make use of `discard`, you need a storage device that supports it – most
    current eMMC chips do – and a Linux device driver to match. You can check by looking
    at the block system queue parameters in `/sys/block/<block device>/queue/`. The
    ones of interest are as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`discard`，您需要一个支持它的存储设备 - 大多数当前的eMMC芯片都支持 - 以及与之匹配的Linux设备驱动程序。您可以通过查看`/sys/block/<block
    device>/queue/`中的块系统队列参数来检查。感兴趣的是以下内容：
- en: '`discard_granularity`: The size of the internal allocation unit of the device'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`discard_granularity`：设备内部分配单元的大小'
- en: '`discard_max_bytes`: The maximum number of bytes that can be discarded in one
    go'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`discard_max_bytes`：一次可以丢弃的最大字节数'
- en: '`discard_zeroes_data`: If `1`, discarded data will be set to zero'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`discard_zeroes_data`：如果为`1`，丢弃的数据将被设置为零'
- en: 'If the device or the device driver does not support `discard`, these values
    are all set to zero. These are the parameters you will see from the eMMC chip
    on the BeagleBone Black:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备或设备驱动程序不支持`discard`，这些值都将设置为零。以下是您将从BeagleBone Black上的eMMC芯片看到的参数：
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There is more information in the kernel documentation file, `Documentation/block/queue-sysfs.txt`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核文档文件`Documentation/block/queue-sysfs.txt`中有更多信息。
- en: You can enable `discard` when mounting a filesystem by adding the option `-o
    discard` to the `mount` command. Both ext4 and F2FS support it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在`mount`命令中添加选项`-o discard`来在挂载文件系统时启用`discard`。ext4和F2FS都支持它。
- en: Tip
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure that the storage device supports `discard` before using the `-o discard
    mount` option, otherwise data loss can occur.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`-o discard mount`选项之前，请确保存储设备支持`discard`，否则可能会发生数据丢失。
- en: 'It is also possible to force `discard` from the command line independently
    of how the partition is mounted, using the `fstrim` command which is part of the
    `util-linux` package. Typically, you would run this command periodically, once
    a week perhaps, to free up unused space. `fstrim` operates on a mounted filesystem
    so, to trim the root filesystem `/`, you would type the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以独立于分区的挂载方式从命令行强制执行`discard`，使用的是`util-linux`软件包的`fstrim`命令。通常，您可以定期运行此命令，例如每周运行一次，以释放未使用的空间。`fstrim`在挂载的文件系统上操作，因此要修剪根文件系统`/`，您需要输入以下内容：
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding example uses the verbose option, `-v`, so that it prints out the
    number of bytes potentially freed up. In this case 2,061,000,704 is the approximate
    amount of free space in the filesystem, so it is the maximum amount of storage
    that could have been freed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子使用了冗长选项“-v”，因此打印出了潜在释放的字节数。在这种情况下，2,061,000,704是文件系统中的大约可用空间，因此这是可能被释放的最大存储量。
- en: Ext4
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ext4
- en: The extended filesystem, ext, has been the main filesystem for Linux desktops
    since 1992\. The current version, ext4, is very stable, well tested and has a
    journal that makes recovery from an unscheduled shutdown fast and mostly painless.
    It is a good choice for managed flash devices and you will find that it is the
    preferred filesystem for Android devices that have eMMC storage. If the device
    supports `discard`, you should mount with the option `-o discard`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展文件系统ext自1992年以来一直是Linux桌面的主要文件系统。当前版本ext4非常稳定，经过了充分测试，并且具有使从意外关机中恢复变得快速且基本无痛的日志。它是受控闪存设备的不错选择，您会发现它是Android设备的首选文件系统，这些设备具有eMMC存储。如果设备支持`discard`，您应该使用选项`-o
    discard`进行挂载。
- en: 'To format and create an ext4 filesystem at runtime, you would type the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行时格式化和创建ext4文件系统，您需要输入以下命令：
- en: '[PRE31]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To create a filesystem image, you can use the `genext2fs` utility, available
    from [http://genext2fs.sourceforge.net](http://genext2fs.sourceforge.net). In
    this example, I have specified the block size with `-B` and the number of blocks
    in the image with `-b`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建文件系统镜像，可以使用`genext2fs`实用程序，可从[http://genext2fs.sourceforge.net](http://genext2fs.sourceforge.net)获取。在这个例子中，我已经用`-B`指定了块大小，并用`-b`指定了镜像中的块数：
- en: '[PRE32]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`genext2fs` can make use of a device table to set the file permissions and
    ownership, as described in [Chapter 5](ch05.html "Chapter 5. Building a Root Filesystem"),
    *Building a Root Filesystem*, with `-D [file table]`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`genext2fs`可以利用设备表来设置文件权限和所有权，如[第5章](ch05.html "第5章。构建根文件系统")中所述，*构建根文件系统*，使用`-D
    [文件表]`。'
- en: 'As the name implies, this will actually generate an image in `.ext2` format.
    You can upgrade using `tune2fs` as follows (details of the command options are
    in the main page for `tune2fs`):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，这实际上会生成一个`.ext2`格式的镜像。您可以使用`tune2fs`进行升级，具体命令选项的详细信息在`tune2fs`的主页面中。
- en: '[PRE33]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Both the Yocto Project and Buildroot use exactly these steps when creating images
    in `.ext4` format.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto项目和Buildroot在创建`.ext4`格式的镜像时使用完全相同的步骤。
- en: While a journal is an asset for devices that may power down without warning,
    it does add extra write cycles to each write transaction, wearing out the flash
    memory. If the device is battery-powered, especially if the battery is not removable,
    the chances of an unscheduled power down are small and so you may want to leave
    the journal out.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然日志对于可能在没有警告的情况下断电的设备是一种资产，但它确实会给每个写事务增加额外的写周期，从而耗尽闪存。如果设备是由电池供电的，特别是如果电池无法移除，那么意外断电的可能性很小，因此您可能希望不使用日志。
- en: F2FS
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F2FS
- en: The **Flash-Friendly File System**, **F2FS**, is a log-structured filesystem
    designed for managed flash devices, especially eMMC and SD. It was written by
    Samsung and was merged into mainline Linux in 3.8\. It is marked experimental,
    indicating that it has not been extensively deployed as yet, but it seems that
    some Android devices are using it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**Flash-Friendly File System**，**F2FS**，是为受控闪存设备设计的日志结构文件系统，特别适用于eMMC和SD。它由三星编写，并在3.8版中合并到主线Linux。它被标记为实验性，表明它尚未被广泛部署，但似乎一些Android设备正在使用它。'
- en: F2FS takes into account the page and erase block sizes and tries to align data
    on these boundaries. The log format gives resilience in the face of power down
    and also gives good write performance, in some tests showing a two-fold improvement
    over ext4\. There is a good description of the design of F2FS in the kernel documentation
    in `Documentation/filesystems/f2fs.txt` and there are references at the end of
    the chapter.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: F2FS考虑了页面和擦除块大小，并尝试在这些边界上对齐数据。日志格式在断电时具有弹性，并且具有良好的写入性能，在某些测试中显示出比ext4的两倍改进。在内核文档中有F2FS设计的良好描述，位于`Documentation/filesystems/f2fs.txt`，并且在本章末尾有参考资料。
- en: 'The `mfs2.fs2` utility creates an empty F2FS filesystem with the label `-l`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`mfs2.fs2`实用程序使用标签`-l`创建一个空的F2FS文件系统：'
- en: '[PRE34]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There isn't (yet) a tool to create F2FS filesystem images off-line.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有工具可以离线创建F2FS文件系统镜像。
- en: FAT16/32
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FAT16/32
- en: The old Microsoft filesystems, FAT16 and FAT32, continue to be important as
    a common format that is understood by most operating systems. When you buy an
    SD card or USB flash drive, it is almost certain to be formatted as FAT32 and,
    in some cases, the on-card microcontroller is optimized for FAT32 access patterns.
    Also, some boot ROMs require a FAT partition for the second stage bootloader,
    the TI OMAP-based chips for example. However, FAT formats are definitely not suitable
    for storing critical files because they are prone to corruption and make poor
    use of the storage space.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 老的Microsoft文件系统，FAT16和FAT32，作为大多数操作系统理解的常见格式，仍然很重要。当你购买SD卡或USB闪存驱动器时，它几乎肯定是以FAT32格式格式化的，并且在某些情况下，卡上的微控制器被优化为FAT32访问模式。此外，一些引导ROM需要FAT分区用于第二阶段引导加载程序，例如TI
    OMAP芯片。然而，FAT格式绝对不适合存储关键文件，因为它们容易损坏并且对存储空间利用不佳。
- en: 'Linux supports FAT16 through the `msdos` filesystem and both FAT32 and FAT16
    through the `vfat` filesystem. In most cases, you need to include the `vfat` driver.
    Then, to mount a device, say an SD card on the second `mmc` hardware adapter,
    you would type this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Linux通过`msdos`文件系统支持FAT16，通过`vfat`文件系统支持FAT32和FAT16。在大多数情况下，您需要包括`vfat`驱动程序。然后，要挂载设备，比如第二个`mmc`硬件适配器上的SD卡，您需要输入以下命令：
- en: '[PRE35]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the past, there have been licensing issues with the `vfat` driver which may
    (or may not) infringe a patent held by Microsoft.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，`vfat`驱动程序曾存在许可问题，可能侵犯了Microsoft持有的专利。
- en: FAT32 has a limitation on the device size of 32 GiB. Devices of a larger capacity
    may be formatted using the Microsoft exFAT format and it is a requirement for
    SDXC cards. There is no kernel driver for exFAT, but it can be supported by means
    of a user-space FUSE driver. Since exFAT is proprietary to Microsoft there are
    certain to be licensing implications if you support this format on your device.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: FAT32对设备大小有32 GiB的限制。容量更大的设备可以使用Microsoft exFAT格式进行格式化，并且这是SDXC卡的要求。没有exFAT的内核驱动程序，但可以通过用户空间FUSE驱动程序来支持。由于exFAT是Microsoft专有的，如果您在设备上支持这种格式，肯定会有许可证方面的影响。
- en: Read-only compressed filesystems
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只读压缩文件系统
- en: 'Compressing data is useful if you don''t have quite enough storage to fit everything
    in. Both JFFS2 and UBIFS do on-the-fly data compression by default. However, if
    the files are never going to be written, as is usually the case with the root
    filesystem, you can achieve better compression ratios by using a read-only compressed
    filesystem. Linux supports several of these: `romfs`, `cramfs`, and `squashfs`.
    The first two are obsolete now, so I will describe only `squashfs`.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存储空间不够，压缩数据是有用的。JFFS2和UBIFS默认情况下都进行即时数据压缩。但是，如果文件永远不会被写入，通常情况下是根文件系统，您可以通过使用只读的压缩文件系统来实现更好的压缩比。Linux支持几种这样的文件系统：`romfs`、`cramfs`和`squashfs`。前两者现在已经过时，因此我只描述`squashfs`。
- en: squashfs
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: squashfs
- en: '`squashfs` was written by Phillip Lougher in 2002 as a replacement for `cramfs`.
    It existed as a kernel patch for a long time, eventually being merged into mainline
    Linux in version 2.6.29 in 2009\. It is very easy to use: you create a filesystem
    image using `mksquashfs` and install it to the flash memory:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`squashfs`是由Phillip Lougher于2002年编写的，作为`cramfs`的替代品。它作为一个内核补丁存在了很长时间，最终在2009年的Linux主线版本2.6.29中合并。它非常容易使用：您可以使用`mksquashfs`创建一个文件系统映像，并将其安装到闪存存储器中：'
- en: '[PRE36]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The resulting filesystem is read-only so there is no mechanism to modify any
    of the files at runtime. The only way to update a `squashfs` filesystem is to
    erase the whole partition and program in a new image.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 由于生成的文件系统是只读的，因此没有机制可以在运行时修改任何文件。更新`squashfs`文件系统的唯一方法是擦除整个分区并编程一个新的映像。
- en: '`squashfs` is not bad block-aware and so must be used with reliable flash memory
    such as NOR flash. It can be used on NAND flash as long as you use UBI to create
    an emulated, reliable, MTD volume on top of UBI. You have to enable kernel configuration
    `CONFIG_MTD_UBI_BLOCK`, which will create a read-only MTD block device for each
    UBI volume. The following diagram shows two MTD partitions, each with accompanying
    `mtdblock` devices. The second partition is also used to create a UBI volume which
    is exposed as a third, reliable, `mtdblock` device, which you can use for any
    read-only filesystem that is not bad block-aware:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`squashfs`不具备坏块感知功能，因此必须与可靠的闪存存储器一起使用，例如NOR闪存。它可以在NAND闪存上使用，只要您使用UBI在其上创建一个模拟的、可靠的MTD卷。您必须启用内核配置`CONFIG_MTD_UBI_BLOCK`，这将为每个UBI卷创建一个只读的MTD块设备。下图显示了两个MTD分区，每个分区都有相应的`mtdblock`设备。第二个分区还用于创建一个UBI卷，该卷作为第三个可靠的`mtdblock`设备公开，您可以将其用于任何不具备坏块感知功能的只读文件系统：'
- en: '![squashfs](img/B03982_07_04.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![squashfs](img/B03982_07_04.jpg)'
- en: Temporary filesystems
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临时文件系统
- en: There are always some files that have a short lifetime or which have no significance
    after a reboot. Many such files are put into `/tmp`, and so it makes sense to
    keep these files from reaching permanent storage.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有一些文件的生命周期很短，或者在重新启动后就不再重要。许多这样的文件被放在`/tmp`中，因此将这些文件保存在永久存储中是有意义的。
- en: 'The temporary filesystem, `tmpfs`, is ideal for this purpose. You can create
    a temporary RAM-based filesystem by simply mounting `tmpfs`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 临时文件系统`tmpfs`非常适合这个目的。您可以通过简单地挂载`tmpfs`来创建一个临时的基于RAM的文件系统：
- en: '[PRE37]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As with `procfs` and `sysfs`, there is no device node associated with `tmpfs`
    so you have to supply a place-keeper string, `tmp_files` in the preceding example.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 与`procfs`和`sysfs`一样，`tmpfs`没有与设备节点相关联，因此您必须在前面的示例中提供一个占位符字符串`tmp_files`。
- en: 'The amount of memory used will grow and shrink as files are created and deleted.
    The default maximum size is half the physical RAM. In most cases, it would be
    a disaster if `tmpfs` grew that large, so it is a very good idea to cap it with
    a `-o size` parameter. The parameter can be given in bytes, KiB (`k`), MiB (`m`),
    or GiB (`g`), for example:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的内存量会随着文件的创建和删除而增长和缩小。默认的最大大小是物理RAM的一半。在大多数情况下，如果`tmpfs`增长到那么大，那将是一场灾难，因此最好使用`-o
    size`参数对其进行限制。该参数可以以字节、KiB（`k`）、MiB（`m`）或GiB（`g`）的形式给出，例如：
- en: '[PRE38]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In addition to `/tmp`, some subdirectories of `/var` contain volatile data
    and it is good practice to use `tmpfs` for them as well, either by creating a
    separate filesystem for each or, more economically, by using symbolic links. Buildroot
    does it this way:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`/tmp`之外，`/var`的一些子目录包含易失性数据，最好也使用`tmpfs`为它们创建一个单独的文件系统，或者更经济地使用符号链接。Buildroot就是这样做的：
- en: '[PRE39]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the Yocto Project, `/run` and `/var/volatile` are `tmpfs` mounts with symbolic
    links pointing to them as shown here:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yocto项目中，`/run`和`/var/volatile`是`tmpfs`挂载点，具有指向它们的符号链接，如下所示：
- en: '[PRE40]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Making the root filesystem read-only
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使根文件系统只读
- en: 'You need to make your target device able to survive unexpected events including
    file corruption, and still be able to boot and achieve at least a minimum level
    of function. Making the root filesystem read-only is a key part of achieving this
    ambition because it eliminates accidental over-writes. Making it read-only is
    easy: replace `rw` with `ro` on the kernel command line or use an inherently read-only
    filesystem such as `squashfs`. However, you will find that there are a few files
    and directories that are traditionally writable:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使目标设备能够在发生意外事件时存活，包括文件损坏，并且仍然能够引导并实现至少最低级别的功能。使根文件系统只读是实现这一目标的关键部分，因为它消除了意外覆盖。将其设置为只读很容易：在内核命令行中用`ro`替换`rw`，或者使用固有的只读文件系统，如`squashfs`。但是，您会发现有一些传统上是可写的文件和目录：
- en: '`/etc/resolv.conf`: This file is written by network configuration scripts to
    record the addresses of DNS name servers. The information is volatile, so you
    simply have to make it a symlink to a temporary directory, for example, `/etc/resolv.conf
    -> /var/run/resolv.conf`.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/resolv.conf`：此文件由网络配置脚本编写，用于记录DNS名称服务器的地址。这些信息是易失性的，因此您只需将其设置为指向临时目录的符号链接，例如`/etc/resolv.conf
    -> /var/run/resolv.conf`。'
- en: '`/etc/passwd`: This file, along with `/etc/group`, `/etc/shadow`, and `/etc/gshadow`,
    stores user and group names and passwords. They need to be symbolically linked
    to an area of persistent storage in the same way as `resolv.conf`.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/passwd`：此文件与`/etc/group`、`/etc/shadow`和`/etc/gshadow`一起存储用户和组名称以及密码。它们需要像`resolv.conf`一样被符号链接到持久存储区域。'
- en: '`/var/lib`: Many applications expect to be able to write to this directory
    and to keep permanent data here as well. One solution is to copy a base set of
    files to a `tmpfs` filesystem at boot time and then bind mount `/var/lib` to the
    new location by putting a sequence of commands such as these into one of the boot
    scripts:'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var/lib`：许多应用程序希望能够写入此目录并在此处保留永久数据。一种解决方案是在启动时将一组基本文件复制到`tmpfs`文件系统，然后通过将一系列命令绑定到新位置的`/var/lib`来将`/var/lib`绑定到新位置，将这些命令放入其中一个启动脚本中：'
- en: '[PRE41]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`/var/log`: This is the place where syslog and other daemons keep their logs.
    Generally, logging to flash memory is not desirable because of the many small
    write cycles it generates. A simple solution is to mount `/var/log` using `tmpfs`,
    making all log messages volatile. In the case of `syslogd`, BusyBox has a version
    that can log to a circular ring buffer.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var/log`：这是syslog和其他守护程序保存其日志的地方。通常，由于产生许多小的写入周期，将日志记录到闪存内存中是不可取的。一个简单的解决方案是使用`tmpfs`挂载`/var/log`，使所有日志消息都是易失性的。在`syslogd`的情况下，BusyBox有一个版本，可以记录到循环环形缓冲区。'
- en: If you are using the Yocto Project, you can create a read-only root filesystem
    by adding `IMAGE_FEATURES = "read-only-rootfs"` to `conf/local.conf` or to your
    image recipe.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Yocto项目，可以通过将`IMAGE_FEATURES = "read-only-rootfs"`添加到`conf/local.conf`或您的镜像配方来创建只读根文件系统。
- en: Filesystem choices
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统选择
- en: So far we have looked at the technology behind solid state memory and at the
    many types of filesystems. Now it is time to summarize the options.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过固态存储器背后的技术以及许多类型的文件系统。现在是总结选项的时候了。
- en: 'In most cases, you will be able to divide your storage requirements into these
    three categories:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，您将能够将存储需求分为这三类：
- en: '**Permanent, readable, and writable data**: Runtime configuration, network
    parameters, passwords, data logs, and user data'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**永久的、可读写的数据**：运行时配置、网络参数、密码、数据日志和用户数据'
- en: '**Permanent, read-only data**: Programs, libraries, and configurations files
    that are constant, for example, the root filesystem'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**永久的只读数据**：程序、库和配置文件是恒定的，例如根文件系统'
- en: '**Volatile data**: Temporary storage for example `/tmp`'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易失性数据**：临时存储，例如`/tmp`'
- en: 'The choices for read-write storage are as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 读写存储的选择如下：
- en: '**NOR**: UBIFS or JFFS2'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NOR**：UBIFS或JFFS2'
- en: '**NAND**: UBIFS, JFFS2, or YAFFS2'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NAND**：UBIFS、JFFS2或YAFFS2'
- en: '**eMMC**: ext4 or F2FS'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**eMMC**：ext4或F2FS'
- en: Note
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For read-only storage, you can use all of the above mounted with the `ro` attribute.
    Additionally, if you want to save space, you could use `squashfs`, in the case
    of NAND flash using UBI `mtdblock` device emulation to handle the bad blocks for
    you.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只读存储，您可以使用上述所有内容，并带有`ro`属性进行挂载。此外，如果要节省空间，可以在NAND闪存的情况下使用`squashfs`，使用UBI
    `mtdblock`设备仿真来处理坏块。
- en: Finally, for volatile storage, there is only one choice, `tmpfs`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于易失性存储，只有一种选择，即`tmpfs`。
- en: Updating in the field
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现场更新
- en: 'There have been several well-publicized security flaws, including Heartbleed
    (a bug in the OpenSSL libraries) and Shellshock (a bug in the bash shell), both
    of which could have serious consequences for embedded Linux devices that are currently
    deployed. For this reason alone, it is highly desirable to have a mechanism to
    update devices in the field so that you can fix security problems as they arise.
    There are other good reasons as well: to deploy other bug fixes and feature updates.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有几个广为人知的安全漏洞，包括Heartbleed（OpenSSL库中的一个错误）和Shellshock（bash shell中的一个错误），这两者都可能对当前部署的嵌入式Linux设备造成严重后果。光是出于这个原因，就非常希望有一种机制来更新现场设备，以便在出现安全问题时进行修复。还有其他很好的原因：部署其他错误修复和功能更新。
- en: 'The guiding principle of update mechanisms is that they should do no harm,
    remembering Murphy''s Law: if it can go wrong, it will go wrong, eventually. Any
    update mechanism must be:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 更新机制的指导原则是不应该造成任何伤害，要记住墨菲定律：如果有可能出错，迟早会出错。任何更新机制必须是：
- en: '**Robust**: It must not render the device inoperable. I will talk about updates
    being atomic; either the system is updated successfully or not updated at all
    and continues to run as before.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健壮**：它不能使设备无法操作。我将谈论原子更新；系统要么成功更新，要么根本不更新，并继续像以前一样运行。'
- en: '**Failsafe**: It must handle interrupted updates gracefully.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故障安全**：它必须能够优雅地处理中断的更新。'
- en: '**Secure**: It must not allow unauthorized updates, otherwise it will become
    an attack mechanism.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：它不能允许未经授权的更新，否则它将成为一种攻击机制。'
- en: Atomicity can be achieved by having duplicates of the things you want to update
    and switching to the new copy when safe to do so.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 通过复制要更新的内容的副本并在安全时切换到新副本来实现原子性。
- en: Failsafety requires there to be a mechanism to detect a failed update, such
    as a hardware watchdog, and a known good copy of software to fall back on.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 故障安全性要求必须有一种机制来检测失败的更新，例如硬件看门狗，并且有一个已知的良好软件副本可以回退。
- en: Security can be achieved in the case of updates that are local and attended
    through authentication by a password or PIN code. But, if the update is remote
    and automatic, some level of authentication via the network is needed. Ultimately,
    you may want to add a secure bootloader and signed update binaries.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性可以通过本地和经过密码或PIN码认证的更新来实现。但是，如果更新是远程和自动的，就需要通过网络进行一定级别的认证。最终，您可能希望添加安全的引导加载程序和签名的更新二进制文件。
- en: Some components are easier to update than others. The bootloader is very difficult
    to update since there are usually hardware constraints that mean there can only
    be one bootloader, and so there cannot be a backup if the update fails. On the
    other hand, bootloaders are not often a cause of runtime bugs. The best advice
    is to avoid bootloader updates in the field.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 有些组件比其他组件更容易更新。引导加载程序非常难以更新，因为通常存在硬件约束，意味着只能有一个引导加载程序，因此如果更新失败就无法备份。另一方面，引导加载程序通常不是运行时错误的原因。最好的建议是避免在现场更新引导加载程序。
- en: 'Granularity: file, package, or image?'
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 粒度：文件、软件包或镜像？
- en: This is the big question, and depends on your overall system design and your
    desired level of robustness.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的问题，取决于您的整体系统设计和所需的健壮性水平。
- en: 'File updates can be made atomic: the technique is to write the new content
    to a temporary file in the same filesystem and then use the POSIX `rename(2)`
    function to move it over the old file. It works because rename is guaranteed to
    be atomic. However, this is only one part of the problem because there will be
    dependencies between files which need to be considered.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 文件更新可以是原子的：技术是将新内容写入同一文件系统中的临时文件，然后使用POSIX `rename(2)`函数将其移动到旧文件上。它有效是因为重命名是保证原子性的。然而，这只是问题的一部分，因为文件之间会有依赖关系需要考虑。
- en: Updating at the level of packages (`RPM`, `dpkg`, or `ipk`) is a better option,
    assuming that you have a runtime package manager. This, after all, is how desktop
    distributions have been doing it for years. The package manager has a database
    of updates and can keep track of those which have been updated and those that
    haven't. Each package has an update script that is designed to make sure that
    the package update is atomic. The great advantage is that you can update existing
    packages, install new ones, and delete obsolete ones with ease. If you are using
    a root filesystem that is mounted as read-only, you will have to temporarily remount
    read-write while updating, which opens up a small window for corruption.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件包（`RPM`，`dpkg`或`ipk`）级别进行更新是一个更好的选择，假设您有一个运行时软件包管理器。毕竟，这就是桌面发行版多年来一直在做的事情。软件包管理器有一个更新数据库，并可以跟踪已更新和未更新的内容。每个软件包都有一个更新脚本，旨在确保软件包更新是原子的。最大的优势是您可以轻松更新现有软件包，安装新软件包，并删除过时的软件包。如果您使用的是以只读方式挂载的根文件系统，则在更新时必须暂时重新挂载为读写，这会打开一个小的损坏窗口。
- en: Package managers do have downsides as well. They are not able to update kernel
    or other images in raw flash memory. After devices have been deployed and updated
    several times, you may end up with a large number of combinations of packages
    and package versions, which will complicate QA for each new update cycle. Package
    managers are not bulletproof in the event of power failure during an update.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包管理器也有缺点。它们无法更新原始闪存中的内核或其他镜像。在设备部署并多次更新后，您可能会得到大量软件包和软件包版本的组合，这将使每个新的更新周期的质量保证变得更加复杂。在更新期间发生断电时，软件包管理器也无法保证安全。
- en: 'The third option is to update whole system images: the kernel, the root filesystem,
    user applications, and so on.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选项是更新整个系统镜像：内核、根文件系统、用户应用程序等。
- en: Atomic image update
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子镜像更新
- en: 'In order to make the update atomic, we need two things: a second copy of the
    operating system that can be used during the update, and a mechanism in the bootloader
    to select which copy of the operating system to load. The second copy may be exactly
    the same as the first, resulting in full redundancy of the operating system, or
    it may be a small operating system dedicated to updating the main one.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使更新是原子的，我们需要两样东西：一个可以在更新期间使用的操作系统的第二个副本，以及引导加载程序中选择要加载的操作系统副本的机制。第二个副本可能与第一个完全相同，从而实现操作系统的完全冗余，或者它可能是一个专门用于更新主操作系统的小型操作系统。
- en: 'In the first scheme ,there are two copies of the operating system, each comprised
    of the Linux kernel, the root filesystem, and system applications, as shown in
    the following diagram:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种方案中，有两份操作系统副本，每个副本由Linux内核、根文件系统和系统应用程序组成，如下图所示：
- en: '![Atomic image update](img/B03982_07_05.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![原子镜像更新](img/B03982_07_05.jpg)'
- en: Initially, the boot flag is not set, so the bootloader loads copy 1\. To install
    an update, the updater application, which is part of the operating system, overwrites
    copy 2\. When complete, it sets the boot flag and reboots. Now, the bootloader
    will load the new operating system. When a further update is installed, the updater
    in copy 2 overwrites copy 1 and clears the boot flag and so you ping-pong between
    the two copies.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，引导标志未设置，因此引导加载副本1。要安装更新，操作系统的更新程序将覆盖副本2。完成后，它设置引导标志并重新启动。现在，引导加载新的操作系统。安装进一步更新时，副本2中的更新程序将覆盖副本1，并清除引导标志，因此您在两个副本之间来回移动。
- en: If an update fails, the boot flag is not changed and the last good operating
    system is used. Even if the update consists of several components, a kernel image,
    a DTB, a root filesystem, and a system application filesystem, the whole update
    is atomic because the boot flag is only updated when all updates are completed.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更新失败，引导标志不会更改，并且将使用上一个良好的操作系统。即使更新由多个组件组成，如内核镜像、DTB、根文件系统和系统应用程序文件系统，整个更新也是原子的，因为只有在所有更新完成时才会更新引导标志。
- en: The main drawback with this scheme is that it requires storage for two copies
    of the operating system.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案的主要缺点是需要存储两份操作系统的副本。
- en: 'You can reduce storage requirements by keeping a minimal operating system purely
    for updating the main one, as shown in the following diagram:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过保留一个纯粹用于更新主操作系统的最小操作系统来减少存储需求，如下图所示：
- en: '![Atomic image update](img/B03982_07_06.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![原子镜像更新](img/B03982_07_06.jpg)'
- en: When you want to install an update, set the boot flag and reboot. Once the recovery
    operating system is running, it starts the updater which overwrites the main operating
    system images. When done, it clears the boot flag and reboots again, this time
    loading the new main operating system.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要安装更新时，设置引导标志并重新启动。一旦恢复操作系统运行，它启动更新程序，覆盖主操作系统镜像。完成后，清除引导标志并再次重新启动，这次加载新的主操作系统。
- en: The recovery operating system is usually a lot smaller than the main operating
    system, maybe only a few megabytes, and so the storage overhead is not great.
    In fact, this is the scheme adopted by Android. The main operating system is several
    hundred megabytes, but the recovery mode operating system is a simple ramdisk
    of a few megabytes only.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复操作系统通常比主操作系统小得多，可能只有几兆字节，因此存储开销并不大。事实上，这是Android采用的方案。主操作系统有几百兆字节，但恢复模式操作系统只是一个简单的几兆字节的ramdisk。
- en: Further reading
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following resources have further information about the topics introduced
    in this chapter:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源提供了有关本章介绍的主题的更多信息：
- en: '*XIP: The past, the present... the future?*, *Vitaly Wool*, presentation at
    FOSDEM 2007: [https://archive.fosdem.org/2007/slides/devrooms/embedded/Vitaly_Wool_XIP.pdf](https://archive.fosdem.org/2007/slides/devrooms/embedded/Vitaly_Wool_XIP.pdf)'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*XIP：过去，现在...未来？*，*Vitaly Wool*，在FOSDEM 2007年的演示：[https://archive.fosdem.org/2007/slides/devrooms/embedded/Vitaly_Wool_XIP.pdf](https://archive.fosdem.org/2007/slides/devrooms/embedded/Vitaly_Wool_XIP.pdf)'
- en: '*General MTD documentation*, [http://www.linux-mtd.infradead.org/doc/general.html](http://www.linux-mtd.infradead.org/doc/general.html)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*MTD文档*：[http://www.linux-mtd.infradead.org/doc/general.html](http://www.linux-mtd.infradead.org/doc/general.html)'
- en: '*Optimizing Linux with cheap flash drives*, *Arnd Bergmann*: [http://lwn.net/Articles/428584/](http://lwn.net/Articles/428584/)'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用廉价闪存驱动器优化Linux*，*Arnd Bergmann*：[http://lwn.net/Articles/428584/](http://lwn.net/Articles/428584/)'
- en: '*Flash memory card design*: [https://wiki.linaro.org/WorkingGroups/KernelArchived/Projects/FlashCardSurvey](https://wiki.linaro.org/WorkingGroups/KernelArchived/Projects/FlashCardSurvey)'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*闪存存储卡设计*：[https://wiki.linaro.org/WorkingGroups/KernelArchived/Projects/FlashCardSurvey](https://wiki.linaro.org/WorkingGroups/KernelArchived/Projects/FlashCardSurvey)'
- en: '*eMMC/SSD File System Tuning Methodology*: [http://elinux.org/images/b/b6/EMMC-SSD_File_System_Tuning_Methodology_v1.0.pdf](http://elinux.org/images/b/b6/EMMC-SSD_File_System_Tuning_Methodology_v1.0.pdf)'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*eMMC/SSD文件系统调优方法*：[http://elinux.org/images/b/b6/EMMC-SSD_File_System_Tuning_Methodology_v1.0.pdf](http://elinux.org/images/b/b6/EMMC-SSD_File_System_Tuning_Methodology_v1.0.pdf)'
- en: '*Flash-Friendly File System (F2FS)*: [http://elinux.org/images/1/12/Elc2013_Hwang.pdf](http://elinux.org/images/1/12/Elc2013_Hwang.pdf)'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*闪存友好的文件系统（F2FS）*：[http://elinux.org/images/1/12/Elc2013_Hwang.pdf](http://elinux.org/images/1/12/Elc2013_Hwang.pdf)'
- en: '*An f2fS teardown*: [http://lwn.net/Articles/518988/](http://lwn.net/Articles/518988/)'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*f2fS拆解*：[http://lwn.net/Articles/518988/](http://lwn.net/Articles/518988/)'
- en: '*Building Murphy-compatible embedded Linux systems*, *Gilad Ben-Yossef*: [https://www.kernel.org/doc/ols/2005/ols2005v1-pages-21-36.pdf](https://www.kernel.org/doc/ols/2005/ols2005v1-pages-21-36.pdf)'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建兼容Murphy的嵌入式Linux系统*，*Gilad Ben-Yossef*：[https://www.kernel.org/doc/ols/2005/ols2005v1-pages-21-36.pdf](https://www.kernel.org/doc/ols/2005/ols2005v1-pages-21-36.pdf)'
- en: Summary
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Flash memory has been the storage technology of choice for embedded Linux from
    the beginning and over the years Linux has gained very good support, from low-level
    drivers up to flash-aware filesystems, the latest being UBIFS.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，闪存存储技术一直是嵌入式Linux的首选技术，多年来Linux已经获得了非常好的支持，从低级驱动程序到支持闪存的文件系统，最新的是UBIFS。
- en: However, as the rate at which new flash technologies are introduced increases,
    it is becoming harder to keep pace with the changes at the high end. System designers
    are increasingly turning to managed flash in the form of eMMC to provide a stable
    hardware and software interface which is independent of the memory chips inside.
    Embedded Linux developers are beginning to get to grips with these new chips.
    Support for TRIM in ext4 and F2FS is well established, and it is slowly finding
    its way into the chips themselves. Also, the appearance of new filesystems that
    are optimized to manage flash, such as F2FS, is a welcome step forward.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着新的闪存技术推出的速度加快，要跟上高端变化变得更加困难。系统设计师越来越倾向于使用eMMC形式的托管闪存，以提供稳定的硬件和软件接口，独立于内部存储芯片。嵌入式Linux开发人员开始逐渐掌握这些新芯片。对于ext4和F2FS中的TRIM的支持已经很成熟，并且它正在慢慢地进入芯片本身。此外，出现了新的针对管理闪存优化的文件系统，比如F2FS，这是一个值得欢迎的进步。
- en: However, the fact remains that flash memory is not the same as a hard disk drive.
    You have to be careful to minimize the number of filesystem writes – especially
    as the higher density TLC chips may be able to support as few as 1,000 erase cycles.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事实仍然是，闪存存储技术与硬盘驱动器不同。你必须小心减少文件系统写入的次数 - 尤其是高密度TLC芯片可能只支持1000次擦除循环。
- en: Finally, it is essential to have a strategy for updating the files and images
    stored on the device in the field. A crucial part of this is the decision to use
    a package manager or not. A package manager gives you flexibility, but cannot
    give you a fully Murphy proof update solution. Your choice depends on the balance
    between convenience and robustness.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在现场更新设备上存储的文件和图像时，有一个更新策略是至关重要的。其中一个关键部分是决定是否使用软件包管理器。软件包管理器可以给你灵活性，但不能提供完全可靠的更新解决方案。你的选择取决于方便性和稳健性之间的平衡。
- en: The next chapter describes how you control the hardware components of your system
    through the use of device drivers, both in the conventional sense of drivers that
    are part of the kernel, and also the extent to which you can control hardware
    from the user space.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章描述了如何通过设备驱动程序控制系统的硬件组件，包括内核中的驱动程序以及用户空间中控制硬件的程度。
