- en: '*Chapter 11*: Writing PCI Device Drivers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：编写PCI设备驱动程序'
- en: A PCI is more than just a bus. It is a standard with a complete set of specifications
    defining how different parts of a computer should interact. Over the years, a
    PCI bus has become the de facto bus standard for device inter-connections, such
    that almost every SoC has native support for such buses. The need for speed led
    to different versions and generations of this bus.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PCI不仅仅是一个总线，它是一个具有完整规范集的标准，定义了计算机的不同部分应该如何交互。多年来，PCI总线已成为设备互连的事实标准，以至于几乎每个SoC都原生支持这样的总线。对速度的需求导致了不同版本和世代的总线。
- en: In the early days of the standard, the first bus that implemented the PCI standard
    was the PCI bus (the bus name is the same as the standard), as a replacement for
    the ISA bus. This improved (with 32-bit addressing and jumper-less autodetection
    and configuration) the address limitation encountered with ISA (limited to 24
    bits, and which occasionally necessitated playing with jumpers in order to route
    IRQs and so on). Compared with the previous bus implementation of the PCI standard,
    the major factor that has been improved is speed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准的早期阶段，实现PCI标准的第一个总线是PCI总线（总线名称与标准相同），作为ISA总线的替代。这改进了ISA的地址限制（限制为24位，并且有时需要通过跳线来路由IRQ等）。与PCI标准的先前总线实现相比，主要改进的因素是速度。
- en: '**PCI Express** is the current family of PCI bus. It is a serial bus, while
    its ancestors were parallel. In addition to speed, PCIe extended the 32-bit addressing
    of its predecessors to 64 bits, with multiple improvements in the interrupt management
    system. This family is split into generations, GenX, which we will see in the
    following sections in this chapter. We will begin with an introduction to PCI
    buses and interfaces where we will learn about bus enumeration, and then we will
    look at the Linux kernel PCI APIs and core functionalities.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: PCI Express是当前的PCI总线系列。它是串行总线，而其祖先是并行总线。除了速度，PCIe将其前身的32位寻址扩展到64位，并在中断管理系统中进行了多项改进。这个系列被分为世代，GenX，我们将在本章的以下部分中看到。我们将从PCI总线和接口的介绍开始，了解总线枚举，然后我们将看看Linux内核PCI
    API和核心功能。
- en: The good news with all of this is that, whatever the family, almost everything
    is transparent to the driver developer. The Linux kernel will abstract and hide
    most of the mechanisms behind a reduced set of APIs that can be used to write
    reliable PCI device drivers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的好消息是，无论是哪个系列，几乎所有内容对驱动程序开发人员来说都是透明的。Linux内核将通过一组简化的API来抽象和隐藏大部分机制，这些API可用于编写可靠的PCI设备驱动程序。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to PCI buses and interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PCI总线和接口简介
- en: The Linux kernel PCI subsystem and data structures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核PCI子系统和数据结构
- en: PCI and **Direct Memory Access** (**DMA**)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PCI和直接内存访问（DMA）
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A good overview of Linux memory management and memory mapping is required, as
    is a familiarity with the concept of interrupts and locking, especially with the
    Linux kernel.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对Linux内存管理和内存映射有良好的概述，以及对中断和锁定的概念有熟悉，特别是在Linux内核中。
- en: Linux kernel v4.19.X sources are available at [https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核v4.19.X源代码可在[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)上找到。
- en: Introduction to PCI buses and interfaces
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PCI总线和接口简介
- en: '**Peripheral Component Interconnect** (**PCI**) is a local bus standard used
    to attach peripheral hardware devices to the computer system. As a bus standard,
    it defines how different peripherals of a computer should interact. However, over
    the years, the PCI standard has evolved either in terms of features or in terms
    of speed. As of its creation until now, we have had several bus families implementing
    the PCI standard, such as PCI (yes, the bus with the same name as the standard),
    and **PCI Extended** (**PCI-X**), **PCI Express** (**PCIe** or **PCI-E**), which
    is the current generation of PCI. A bus that follows PCI standards is known as
    a PCI bus.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 外围组件互连（PCI）是一种本地总线标准，用于连接计算机系统的外围硬件设备。作为总线标准，它定义了计算机的不同外围设备应该如何交互。然而，多年来，PCI标准在功能或速度方面都有所发展。从其创建至今，我们已经有几个实现PCI标准的总线系列，如PCI（是的，与标准同名的总线），PCI
    Extended（PCI-X），PCI Express（PCIe或PCI-E），这是PCI的当前世代。遵循PCI标准的总线称为PCI总线。
- en: From a software point of view, all these technologies are compatible and can
    be handled by the same kernel drivers. This means the kernel doesn't need to know
    which exact bus variant is used. PCIe greatly *extends* PCI with a lot of similarities
    from a software point of view (especially Read/Write I/O or Memory transactions).
    While both are software compatible, PCIe is a serial bus instead of parallel (prior
    to PCIe, every PCI bus family was parallel), which also means you can't have a
    PCI card installed in a PCIe slot, or a PCIe card installed in a PCI slot.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从软件角度来看，所有这些技术都是兼容的，并且可以由同一内核驱动程序处理。这意味着内核不需要知道使用的确切总线变体。从软件角度来看，PCIe在很大程度上扩展了PCI，具有许多软件方面的相似之处（特别是读/写I/O或内存事务）。虽然两者在软件上兼容，但PCIe是串行总线，而不是并行总线（在PCIe之前，每个PCI总线系列都是并行的），这也意味着你不能在PCIe插槽中安装PCI卡，或者在PCI插槽中安装PCIe卡。
- en: 'PCI Express is the most popular bus standard on computers these days, so we
    are going to target PCIe in this chapter while mentioning similarities with or
    differences from PCI when necessary. Apart from the preceding, the following are
    some of the improvements in PCIe:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: PCI Express是当今计算机上最流行的总线标准，因此在本章中，我们将以PCIe为目标，同时在必要时提到与PCI的相似之处或不同之处。除了前述内容，以下是PCIe的一些改进：
- en: PCIe is a serial bus technology, whereas PCI (or other implementations) is parallel,
    thereby reducing the number of I/O lanes required for connecting devices, thus
    reducing the design complexity.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PCIe是串行总线技术，而PCI（或其他实现）是并行的，从而减少了连接设备所需的I/O通道数量，从而减少了设计复杂性。
- en: PCIe implements enhanced interrupt management features (providing Message-Based
    Interrupts, aka MSI, or its extended version, MSI-X), extending the number of
    interrupts a PCI device can deal with without increasing its latency.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PCIe实现了增强的中断管理功能（提供基于消息的中断，也称为MSI，或其扩展版本MSI-X），扩展了PCI设备可以处理的中断数量，而不增加其延迟。
- en: 'PCIe increases the transmission frequency and throughput: Gen1, Gen2, Gen3
    ...'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PCIe增加了传输频率和吞吐量：Gen1，Gen2，Gen3...
- en: PCI devices are types of memory-mapped devices. A device that is connected to
    any PCI bus is assigned address ranges in the processor's address space. These
    address ranges have a different meaning in the PCI address domain, which contains
    three different types of memory according to what they contain (control, data,
    and status registers for the PCI-based device) or to the way they are accessed
    (I/O port or memory mapped). These memory regions will be accessed by the device
    driver/kernel to control the particular device connected over the PCI bus and
    share information with it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: PCI设备是一种内存映射设备。连接到任何PCI总线的设备在处理器的地址空间中被分配地址范围。这些地址范围在PCI地址域中有不同的含义，根据它们包含的内容（PCI设备的控制、数据和状态寄存器）或它们被访问的方式（I/O端口或内存映射）。设备驱动程序/内核将访问这些内存区域，以控制连接到PCI总线上的特定设备并与其共享信息。
- en: The PCI address domain contains the three different memory types that have to
    be mapped in the processor's address space.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: PCI地址域包含三种不同的内存类型，必须在处理器的地址空间中进行映射。
- en: Terminology
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 术语
- en: 'Since the PCIe ecosystem is quite large, there are a number of terms we may
    need to be familiar with prior to going further. These are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PCIe生态系统非常庞大，我们可能需要在继续之前熟悉一些术语。这些术语如下：
- en: '**Root complex** (**RC**): This refers to the PCIe host controller in the SoC.
    It can access the main memory without CPU intervening, which is a feature used
    by other devices to access the main memory. They are also known as Host-to-PCI
    bridges.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根复杂**（**RC**）：这指的是SoC中的PCIe主机控制器。它可以在CPU不介入的情况下访问主存储器，这是其他设备用来访问主存储器的特性。它们也被称为主机到PCI桥接器。'
- en: '`00h` configuration space headers. They never appear on a switch''s internal
    bus and have no downstream port.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`00h`配置空间头。它们永远不会出现在交换机的内部总线上，并且没有下游端口。'
- en: '**Lane**: This represents a set of differential signal pairs (one pair for
    Tx, one pair for Rx).'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通道**：这代表一组差分信号对（一个对用于Tx，一个对用于Rx）。'
- en: '`xN` (`x1`, `x2`, `x4`, `x8`, `x12`, `x16`, and `x32`), where `N` is the number
    of pairs.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xN`（`x1`，`x2`，`x4`，`x8`，`x12`，`x16`和`x32`），其中`N`是对的数量。'
- en: Not all PCIe devices are endpoints. They may also be switches or bridges.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的PCIe设备都是端点。它们也可能是交换机或桥接器。
- en: '**Bridges**: These provide an interface to other buses, such as PCI or PCI
    X, or even another PCIe bus. A bridge can also provide an interface to the same
    bus. For example, a PCI-to-PCI bridge facilitates the addition of more loads to
    a bus by creating a completely separate secondary bus (we will see what a secondary
    bus is in forthcoming sections). The concept of bridges aids in understanding
    and implementing the concept of switches.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桥接器**：这些提供了与其他总线的接口，如PCI或PCI X，甚至另一个PCIe总线。桥接器也可以提供与同一总线的接口。例如，PCI到PCI桥通过创建一个完全独立的次级总线来方便在总线上添加更多负载（我们将在接下来的部分中看到次级总线是什么）。桥接器的概念有助于理解和实现交换机的概念。'
- en: '**Switches**: These provide an aggregation capability and allow more devices
    to be attached to a single root port. It goes without saying that switches have
    a single upstream port, but may have several downstream ports. They are smart
    enough to act as packet routers and recognize which path a given packet will need
    to take based on its address or other routing information, such as an ID. That
    being said, there is also implicit routing, which is used only for certain message
    transactions, such as broadcasts from the root complex and messages that always
    go to the root complex.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交换机**：这些提供了聚合功能，并允许更多的设备连接到单个根端口。不用说，交换机有一个上游端口，但可能有多个下游端口。它们足够智能，可以作为数据包路由器，并根据其地址或其他路由信息（如ID）识别给定数据包需要采取的路径。也就是说，还有隐式路由，仅用于某些消息事务，例如来自根复杂的广播和始终发送到根复杂的消息。'
- en: Switch downstream ports are (kinds of virtual) PCI-PCI bridges bridging from
    the internal bus to buses representing the downstream PCI Express links of this
    PCI Express switch. You should keep in mind that only the PCI-PCI bridges representing
    the switch downstream ports may appear on the internal bus.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 交换机下游端口是（虚拟的）PCI-PCI桥，从内部总线桥接到代表此PCI Express交换机的下游PCI Express链路的总线。应该记住，只有代表交换机下游端口的PCI-PCI桥可能出现在内部总线上。
- en: Important note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A PCI-to-PCI bridge provides a connectivity path between two peripheral component
    interconnect (PCI) buses. You should keep in mind that **only the downstream ports
    of PCI-PCI bridges are taken into account during bus enumeration**. This is very
    important in understanding the enumeration process.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: PCI到PCI桥提供了两个外围组件互连（PCI）总线之间的连接路径。在总线枚举过程中，应该记住**只有PCI-PCI桥的下游端口会被考虑**。这对于理解枚举过程非常重要。
- en: PCI bus enumeration, device configuration, and addressing
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PCI总线枚举，设备配置和寻址
- en: PCIe's most obvious improvement over PCI is its point-to-point bus topology.
    Each device sits on its own dedicated bus, which, in PCIe jargon, is known as
    a **link**. Understanding the enumeration process of PCIe devices requires some
    knowledge.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: PCIe相对于PCI最明显的改进是其点对点总线拓扑结构。每个设备都位于自己专用的总线上，在PCIe术语中被称为**链路**。理解PCIe设备的枚举过程需要一些知识。
- en: 'When you look at the register space of the devices (in the header-type register),
    they will say whether they are a type `0` or type `1` register space. Typically,
    type `0` means an endpoint device and type `1` means a bridge device. The software
    has to identify whether it talks to an endpoint device or to a bridge device.
    Bridge device configuration differs from endpoint device configuration. During
    bridge device (type 1) enumeration, the software has to assign the following elements
    to it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当您查看设备的寄存器空间（在头部类型寄存器中），它们会说明它们是类型`0`还是类型`1`的寄存器空间。通常，类型`0`表示端点设备，类型`1`表示桥接设备。软件必须确定它是在与端点设备还是桥接设备通信。桥接设备配置与端点设备配置不同。在桥接设备（类型1）枚举期间，软件必须为其分配以下元素：
- en: '**Primary Bus Number**: This is the upstream bus number.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主总线号**：这是上游总线号。'
- en: '`0xFF`, as `255` is the highest bus number. As and when enumeration continues,
    this field will be given the real value of how far downstream this bridge can
    go.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0xFF`，因为`255`是最高的总线号。随着枚举的继续，这个字段将获得这座桥可以走多远的真实值。'
- en: Device identification
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备识别
- en: 'Device identification consists of a few properties or parameters that make
    the device unique or addressable. In the PCI subsystem, these parameters are the
    following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 设备识别由一些属性或参数组成，使设备成为唯一或可寻址的。在PCI子系统中，这些参数如下：
- en: '**Vendor ID**: This identifies the manufacturer of the device.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供应商ID**：这标识设备的制造商。'
- en: '**Device ID**: This identifies the particular vendor device.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备ID**：这标识特定的供应商设备。'
- en: 'The preceding two elements may be enough, but you can also rely on the following
    elements:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的两个元素可能足够了，但您也可以依赖以下元素：
- en: '**Revision ID**: This specifies a device-specific revision identifier.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修订ID**：这指定了设备特定的修订标识符。'
- en: '**Class Code**: This identifies the generic function implemented by the device.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别码**：这标识了设备实现的通用功能。'
- en: '**Header Type**: This defines the layout of the header.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部类型**：这定义了头部的布局。'
- en: All those parameters can be read from the device configuration registers. That's
    what the kernel does to identify devices when enumerating buses.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些参数都可以从设备配置寄存器中读取。这就是内核在枚举总线时用来识别设备的方法。
- en: Bus enumeration
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总线枚举
- en: 'Prior to delving into the PCIe bus enumeration function, there are some basic
    limitations we need to take care of:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究PCIe总线枚举功能之前，我们需要处理一些基本限制：
- en: There can be `256` buses on the system (`0-255`) as there are `8` bits to identify
    them.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统上可以有256个总线（0-255），因为有8位来识别它们。
- en: There can be `32` devices per bus (`0-31`) as there are `5` bits to identify
    them on each bus.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个总线可以有32个设备（0-31），因为每个总线上有5位来识别它们。
- en: A device can have up to 8 functions (`0-7`), hence `3` bits to identify them.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个设备最多可以有8个功能（0-7），因此有3位来识别它们。
- en: All external PCIe lanes, irrespective of whether they originate from the CPU
    or not, are behind PCIe bridges (and therefore get new PCIe bus numbers). Configuration
    software is able to enumerate up to `256` PCI buses on a given system. The number
    `0` is always assigned to the root complex. Remember that only the downstream
    ports (secondary sides) of PCI-PCI bridges are taken into account during bus enumeration.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无论外部PCIe通道是否来自CPU，都位于PCIe桥后面（因此获得新的PCIe总线号）。配置软件能够在给定系统上枚举高达256个PCI总线。编号0总是分配给根复杂。请记住，在总线枚举过程中，只有PCI-PCI桥的下游端口（次级端口）会被考虑。
- en: The PCI enumeration process is based on the **Depth-first search** (**DFS**)
    algorithm, which normally starts at a random node (but in the case of PCI enumeration,
    this node is known in advance, and it is the RC in our case) and which explores
    as far as possible (actually looking for bridges) along each branch before backtracking.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: PCI枚举过程基于**深度优先搜索**（**DFS**）算法，通常从一个随机节点开始（但在PCI枚举的情况下，这个节点是预先知道的，在我们的情况下是RC），并且在回溯之前尽可能地探索（实际上是寻找桥）每个分支。
- en: Said like this, when a bridge is found, configuration software assigns a number
    to it, at least one larger than the bus number this bridge lives on. After this,
    the configuration software starts looking for new bridges on this new bus, and
    so on, before backtracking to this bridge's sibling (if the bridge was part of
    a multi-port switch) or neighbor bridge (in terms of topology).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这样说，当找到一个桥时，配置软件会为其分配一个号码，至少比这座桥所在的总线号大1。之后，配置软件开始在这个新总线上寻找新的桥，依此类推，然后回溯到这座桥的兄弟（如果该桥是多端口交换机的一部分）或邻近桥（就拓扑而言）。
- en: 'Enumerated devices are identified with the BDF format, which stands for *Bus-Device-Function*,
    which uses triple bytes – in other words `XX:YY:ZZ` – in hexadecimal (without
    the `0x`) notation for identification. For instance, `00:01:03` would literally
    mean Bus `0x00: Device 0x01: Function 0x03`. We could interpret this as function
    `3` of device `1` on bus `0`. This notation helps in quickly locating a device
    within a given topology. In case a double-byte notation is used, this would mean
    the function has been omitted or does not matter, in other words, `XX:YY`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举的设备使用BDF格式进行标识，即*总线-设备-功能*，使用三个字节 - 也就是`XX:YY:ZZ` - 用十六进制（不带`0x`）表示。例如，`00:01:03`实际上意味着总线`0x00`：设备`0x01`：功能`0x03`。我们可以解释为在总线`0`上的设备`1`的功能`3`。这种表示法有助于快速定位给定拓扑中的设备。如果使用双字节表示法，这意味着功能已被省略或不重要，换句话说，`XX:YY`。
- en: 'The following diagram shows the topology of a PCIe fabric:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了PCIe结构的拓扑：
- en: '![Figure 11.1 – PCI bus enumeration'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 - PCI总线枚举'
- en: '](img/Figure_11.1_B10985.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.1_B10985.jpg)'
- en: Figure 11.1 – PCI bus enumeration
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 - PCI总线枚举
- en: 'Before we describe the preceding topology diagram, keep repeating the following
    four statements until you become familiar with them:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们描述前面的拓扑图之前，请重复以下四个陈述，直到您熟悉它们：
- en: A PCI-to-PCI bridge facilitates the addition of more loads to a bus by creating
    a completely separate secondary bus. Thus, each bridge downstream port is a new
    bus, and must be given a bus number, at least +1 bigger than the bus number where
    it lives.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PCI到PCI桥通过创建一个完全独立的次级总线，便于向总线添加更多负载。因此，每个桥下游端口都是一个新的总线，并且必须给予一个总线号，至少比它所在的总线号大1。
- en: Switch downstream ports are (kinds of virtual) PCI-PCI (P2P) bridges bridging
    from the internal bus to buses representing the downstream PCI Express links of
    this PCI Express switch.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换机下游端口是（虚拟的）PCI-PCI（P2P）桥，从内部总线桥接到代表此PCI Express交换机的下游PCI Express链路的总线。
- en: The CPU is connected to the root complex through the Host-to-PCI bridge, which
    represents the upstream bridge in the root complex.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CPU通过主机到PCI桥与根复杂结构连接，这代表了根复杂结构中的上游桥。
- en: Only the downstream ports of PCI-PCI bridges are taken into account during bus
    enumeration.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在总线枚举过程中，只考虑PCI-PCI桥的下游端口。
- en: 'After applying the enumeration algorithm to the topology in the diagram, we
    can list 10 steps, from `0` along with two bridges (thus providing two buses),
    `00:00:00` and `00:01:00`. The following are descriptions of the steps in the
    enumeration process in the preceding topology diagram, although step **C** is
    where standardized enumeration logic starts:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在将枚举算法应用于图表中的拓扑之后，我们可以列出10个步骤，从`0`开始，以及两个桥（因此提供了两个总线），`00:00:00`和`00:01:00`。以下是在前述拓扑图中枚举过程中步骤的描述，尽管步骤**C**是标准化枚举逻辑开始的地方：
- en: '`00:00` being a (virtual) bridge, undoubtedly, its downstream port is a bus.
    It is then assigned the number `1` (remember, it is always greater than the bus
    number where the bridge lives, which is `0` in this case). Bus `1` is then enumerated.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`00:00`作为（虚拟）桥，毫无疑问，它的下游端口是一个总线。然后它被分配编号`1`（记住，它总是大于桥所在的总线号，这种情况下是`0`）。总线`1`然后被枚举。'
- en: Step `1` (one upstream virtual bridge that provides its internal bus and two
    downstream virtual bridges that expose its output buses). This switch's internal
    bus is given the number `2`.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步骤`1`（一个提供其内部总线的上游虚拟桥和两个暴露其输出总线的下游虚拟桥）。这个交换机的内部总线被赋予编号`2`。
- en: We immediately fall into step `3`, behind which there is an endpoint (no downstream
    port). According to the principle of the DFS algorithm, we reached the leaf node
    of this branch, so we can start backtracking.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们立即进入步骤`3`，在它后面有一个端点（没有下游端口）。根据DFS算法的原则，我们到达了这个分支的叶节点，所以我们可以开始回溯。
- en: Hence step `4`, and there is a device behind it. Backtracking can happen again.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此到达步骤`4`，在它后面有一个设备。回溯可以再次发生。
- en: We then reach step `5`. There is a switch behind this bus (one upstream virtual
    bridge implementing the internal bus, which is given the bus number `6`, and `3`
    downstream virtual bridges representing its external buses, hence this is a 3-port
    switch).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们到达步骤`5`。在这个总线后面有一个交换机（一个实现内部总线的上游虚拟桥，其总线号为`6`，以及`3`个代表其外部总线的下游虚拟桥，因此这是一个3端口交换机）。
- en: Step `7`, and there is an endpoint behind this bus. If we had to identify the
    function `0` of this endpoint using the BDF format, it would be `07:00:00` (function
    `0` of device `0` on bus `7`). Back to the DFS algorithm, we have reached the
    bottom of the branch. We can then start backtracking, which leads us to step **H**.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步骤`7`，在这个总线后面有一个端点。如果我们要使用BDF格式标识这个端点的功能`0`，它将是`07:00:00`（设备`0`的功能`0`在总线`7`上）。回到DFS算法，我们已经到达了分支的底部。然后我们可以开始回溯，这将引导我们到步骤**H**。
- en: In step `8`. There is a PCIe-to-PCI bridge behind this bus.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在步骤`8`。在这个总线后面有一个PCIe到PCI桥。
- en: In step `9` downstream, and there is a 3-function endpoint behind this bus.
    In BDF notation, these would be identified as `09:00:00`, `09:00:01`, and `09:00:02`.
    Since endpoints mark the depth of a branch, it allows us to perform another backtrack,
    which leads us to step **J**.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在步骤`9`下游，并且在这个总线后面有一个3功能端点。在BDF表示法中，这些将被标识为`09:00:00`，`09:00:01`和`09:00:02`。由于端点标记了分支的深度，它允许我们执行另一个回溯，这将引导我们到步骤**J**。
- en: In the backtracking phase, we enter step `10`. There is an endpoint behind this
    bus, which would have been identified as `0a:00:00` in BDF format. This marks
    the end of the enumeration process.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在回溯阶段，我们进入步骤`10`。在这个总线后面有一个端点，它将以BDF格式被标识为`0a:00:00`。这标志着枚举过程的结束。
- en: PCI(e) bus enumeration may look complicated at first glance, but it is quite
    simple. Reading the preceding material twice can be enough to understand the whole
    process.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: PCI(e)总线枚举乍看起来可能很复杂，但实际上很简单。阅读前面的材料两次就足以理解整个过程。
- en: PCI address spaces
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PCI地址空间
- en: A PCI target can implement up to three different types of address spaces according
    to their content or by access method. These are **Configuration Address Space**,
    **Memory Address Space**, and **I/O Address Space**. Configuration and memory
    address spaces are memory mapped – they are assigned address ranges from the system
    address space, so that reads and writes to that range of addresses don't go to
    RAM, but are routed to the device directly from the CPU, while I/O address space
    is not. Without further ado, let's analyze the differences between them and their
    different use cases.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: PCI目标可以根据其内容或访问方法实现最多三种不同类型的地址空间。这些是**配置地址空间**，**内存地址空间**和**I/O地址空间**。配置和内存地址空间是内存映射的
    - 它们被分配了系统地址空间的地址范围，因此对该地址范围的读写不会进入RAM，而是直接从CPU路由到设备，而I/O地址空间则不是。不多说了，让我们分析它们之间的区别以及它们不同的用例。
- en: PCI configuration space
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PCI配置空间
- en: This is the address space from where the configuration of the device can be
    accessed and which stores basic information about the device, and which is also
    used by the OS to program the device with its operational settings. There are
    `256` bytes for the configuration space on PCI. The PCIe extends this to `4` KB
    of register space. Since configuration address space is memory mapped, any address
    that points to configuration space is allocated from the system memory map. Thus,
    these `4` KB spaces allocate memory addresses from the system memory map, but
    the actual values/bits/content are generally implemented in registers on the peripheral
    device. For instance, when you read the vendor ID or device ID, the target peripheral
    device will return the data even though the memory address being used is from
    the system memory map.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设备配置可以访问的地址空间，存储有关设备的基本信息，也被操作系统用于编程设备的操作设置。PCI上有256字节的配置空间。PCIe将其扩展到4KB的寄存器空间。由于配置地址空间是内存映射的，指向配置空间的任何地址都是从系统内存映射中分配的。因此，这4KB的空间从系统内存映射中分配内存地址，但实际的值/位/内容通常在外围设备的寄存器中实现。例如，当读取供应商ID或设备ID时，目标外围设备将返回数据，即使使用的内存地址来自系统内存映射。
- en: 'Part of this address space is standardized. Configuration address space is
    split as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该地址空间的一部分是标准化的。配置地址空间分为以下部分：
- en: The first `64` bytes (`00h` – `3Fh`) represent the standard configuration header,
    which includes the PCI Bus ID, vendor ID, and device ID registers, to identify
    the device.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前64字节（00h-3Fh）代表标准配置头，包括PCI总线ID、供应商ID和设备ID寄存器，用于识别设备。
- en: The remaining `192` bytes (`40h` – `FFh`) make up the user-defined configuration
    space, such as the information specific to a PC card to be used by its accompanying
    software driver.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩下的192字节（40h-FFh）组成用户定义的配置空间，例如特定于PC卡的信息，将由其附带的软件驱动程序使用。
- en: Generally speaking, the configuration space stores basic information about the
    device. It allows the central resource or OS to program a device with operational
    settings. There is no physical memory associated with configuration address space.
    It is a list of addresses used in the **TLP** (**Transaction Layer Packet**) in
    order to identify the target of the transaction.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，配置空间存储有关设备的基本信息。它允许中央资源或操作系统使用操作设置对设备进行编程。配置地址空间没有与之关联的物理内存。它是TLP（事务层数据包）中使用的地址列表，以便识别事务的目标。
- en: Commands that are used to transfer data between each **Configuration Address
    Space** of PCI devices are known as either **Configuration Read** commands or
    **Configuration Write** commands.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在每个PCI设备的配置地址空间之间传输数据的命令称为配置读命令或配置写命令。
- en: PCI I/O address space
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PCI I/O地址空间
- en: These days, I/O address space is used for compatibility with the x86 architecture's
    I/O port address space. The PCIe specification discourages the use of this address
    space. It will be no surprise if future revisions of the PCI Express specification
    deprecate the use of I/O address space. The only advantage of I/O mapped I/O is
    that, because of its separate address space, it does not steal address ranges
    from system memory space. As a result, computers can access the whole 4 GB of
    RAM on a 32-bit system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，I/O地址空间用于与x86架构的I/O端口地址空间兼容。PCIe规范不鼓励使用此地址空间。如果PCI Express规范的未来修订废弃了I/O地址空间的使用，这将不足为奇。I/O映射I/O的唯一优势是，由于其单独的地址空间，它不会从系统内存空间中窃取地址范围。因此，计算机可以在32位系统上访问整个4GB的RAM。
- en: '**I/O Read** and **I/O Write** commands are used to transfer data in **I/O
    Address Space**.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: I/O读和I/O写命令用于在I/O地址空间中传输数据。
- en: PCI memory address space
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PCI内存地址空间
- en: In the early days of computers, Intel defined a way to access registers in I/O
    devices via the so-called I/O address space. It made sense in those days because
    of the memory address space of the processor, which was quite limited (think of
    16-bit systems, for example) and it made little or even no sense to use some ranges
    of it for accessing devices. When the system memory space became less of a constraint
    (think of 32-bit systems, for example, where the CPU can address up to 4 GB),
    the separation between I/O address space and memory address space became less
    important, and even burdensome.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机早期，英特尔定义了通过所谓的I/O地址空间访问I/O设备寄存器的方法。在那些日子里是有意义的，因为处理器的内存地址空间相当有限（例如，考虑16位系统），使用一些范围来访问设备几乎没有意义，甚至没有意义。当系统内存空间不再是约束时（例如，考虑32位系统，其中CPU可以寻址高达4GB），I/O地址空间和内存地址空间之间的分离变得不那么重要，甚至是累赘。
- en: 'There were so many limitations and constraints on that address space that it
    resulted in registers in I/O devices being mapped directly to the system''s memory
    address space, hence, memory-mapped I/O, or MMIO. Those limitations and constraints
    included the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 该地址空间上有许多限制和约束，导致I/O设备中的寄存器直接映射到系统的内存地址空间，因此称为内存映射I/O或MMIO。这些限制和约束包括以下内容：
- en: The need for a dedicated bus
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专用总线的需求
- en: A separate instruction set
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单独的指令集
- en: And since it was implemented during the 16-bit systems era, the port address
    space was limited to `65536` ports (which corresponds to 216 ), although very
    old machines used 10 bits for I/O address space and had only 1024 unique port
    addresses
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它是在16位系统时代实施的，端口地址空间被限制为65536个端口（对应于216），尽管非常旧的机器使用10位进行I/O地址空间，并且只有1024个唯一的端口地址。
- en: It has therefore become more practical to take advantage of the benefits of
    memory-mapped I/O.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，利用内存映射I/O的好处变得更加实际。
- en: Memory-mapped I/O allows hardware devices to be accessed by simply reading or
    writing to those "special" addresses using the normal memory access instructions,
    though it is more expensive to decode up to 4 GB of address (or more) as compared
    to 65536\. That being said, PCI devices expose their memory regions through windows
    called BARs. A PCI device can have up to six BARs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射I/O允许硬件设备通过简单读取或写入这些“特殊”地址来访问，使用正常的内存访问指令，尽管与65536相比，解码多达4GB的地址（或更多）更昂贵。话虽如此，PCI设备通过称为BAR的窗口公开其内存区域。PCI设备最多可以有六个BAR。
- en: The concept of BAR
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: BAR的概念
- en: '**BAR** stands for **Base Address Register** and is a PCI concept with which
    a device tells the host how much memory it needs, as well as its type. This is
    memory space (grabbed from the system memory map), not actual physical RAM (you
    can actually think of RAM itself as a "specialized memory-mapped I/O device" whose
    job is just to save and give back data, although with today''s modern CPUs with
    caching and such, this is not physically straightforward). It is the responsibility
    of the BIOS or the OS to allocate the requested memory space to the target device.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: BAR代表基址寄存器，是PCI的一个概念，设备通过它告诉主机需要多少内存以及其类型。这是内存空间（从系统内存映射中获取），而不是实际的物理RAM（实际上可以将RAM本身看作是一个“专门的内存映射I/O设备”，其工作只是保存和返回数据，尽管在今天的现代CPU中，具有缓存等功能，这并不是物理上直接的）。将请求的内存空间分配给目标设备是BIOS或操作系统的责任。
- en: Once assigned, the BARs are seen as memory windows by the host system (CPUs)
    to talk to the device. The device itself doesn't write into that window. This
    concept can be seen as an indirection mechanism to access the real physical memory,
    which is internal and local to the PCI device.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分配，BAR被主机系统（CPU）视为内存窗口，用于与设备通信。设备本身不会写入该窗口。这个概念可以看作是一种间接机制，用于访问真正的物理内存，这是PCI设备内部和本地的。
- en: 'Actually, the real physical address of the memory and the address of the input/output
    registers are internal to the PCI device. The following is how a host deals with
    the storage space of peripherals:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，内存的真实物理地址和输入/输出寄存器的地址是内部的，属于PCI设备。以下是主机处理外围设备存储空间的方式：
- en: The peripheral device tells the system by some means that it has several storage
    intervals and I/O address space, how big each interval is, and their respective
    local addresses. Obviously, these addresses are local and internal, all starting
    from `0`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外围设备通过某种方式告诉系统它有几个存储间隔和I/O地址空间，每个间隔有多大，以及它们各自的本地地址。显然，这些地址是本地和内部的，全部从`0`开始。
- en: After the system software knows how many peripherals there are, and what kind
    of storage intervals they have, they can assign "physical addresses" to these
    intervals, and establish the connection between these intervals and the bus. These
    addresses are accessible. Obviously, the so-called "physical address" here is
    somewhat different from the real physical address. It is actually a logical address,
    so it often becomes a "bus address" because this is the address that the CPU sees
    on the bus. As you can imagine, there must be some sort of address mapping mechanism
    on the peripheral. The so-called "allocation of addresses for peripherals" is
    to assign bus addresses to them and establish mappings.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统软件知道有多少外围设备以及它们具有什么样的存储间隔后，可以为这些间隔分配“物理地址”，并建立这些间隔与总线之间的连接。这些地址是可访问的。显然，这里所说的“物理地址”与真实的物理地址有些不同。实际上，这是一个逻辑地址，因此它经常变成“总线地址”，因为这是CPU在总线上看到的地址。可以想象，外围设备必须有某种地址映射机制。所谓的“为外围设备分配地址”是为它们分配总线地址并建立映射。
- en: Interrupt distribution
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中断分发
- en: 'Here we will discuss the way in which interrupts are handled by a PCI device.
    There are three interrupt types in PCI Express. These are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将讨论PCI设备处理中断的方式。PCI Express中有三种中断类型。它们如下：
- en: Legacy interrupts, also called INTx interrupts, the only one mechanism available
    in the old PCI implementations.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统中断，也称为INTx中断，在旧PCI实现中是唯一可用的机制。
- en: '**MSI** (**Message Based Interrupts**) extend the legacy mechanism, for example,
    by increasing the number of interrupts that are possible.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSI（基于消息的中断）扩展了传统机制，例如，通过增加可能的中断数量。
- en: MSI-X (eXtended MSI) extends and enhances MSI, for example, by allowing the
    targeting of individual interrupts to different processors (helpful in some high-speed
    networking applications).
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MSI-X（扩展的MSI）扩展和增强了MSI，例如，通过允许将单个中断定位到不同的处理器（在某些高速网络应用中很有帮助）。
- en: The application logic in a PCI Express endpoint can implement one or more of
    the three methods enumerated above to signal an interrupt. Let's look at these
    in detail.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: PCI Express端点中的应用逻辑可以实现上述三种方法中的一种或多种来发出中断信号。让我们详细看看这些。
- en: PCI legacy INT-X-based interrupts
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PCI传统INT-X中断
- en: 'Legacy interrupt management was based on PCI INT-X interrupt lines, made of
    up to four virtual interrupt wires, referred to as INTA, INTB, INTC, and INTD.
    These interrupt wires are shared by all the PCI devices in the system. The following
    are the steps that the legacy implementation had to go through in order to identify
    and handle the interrupt:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 传统中断管理基于PCI INT-X中断线，由最多四根虚拟中断线组成，称为INTA、INTB、INTC和INTD。这些中断线由系统中所有PCI设备共享。以下是传统实现必须经历的步骤，以识别和处理中断的概念：
- en: The device asserts one of its INT# pins in order to generate an interrupt.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备通过其INT＃引脚之一来生成中断。
- en: The CPU acknowledges the interrupt and polls each device (actually its driver)
    connected to this INT# line (shared) by calling their interrupt handlers. The
    time needed to service the interrupt depends on the number of devices sharing
    the line.The device's interrupt service routine (ISR) may check whether the interrupt
    is originating from this device by reading the device's internal registers to
    identify the cause of the interrupt.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CPU确认中断并轮询连接到此INT＃线（共享）的每个设备（实际上是其驱动程序）来调用它们的中断处理程序。服务中断所需的时间取决于共享该线路的设备数量。设备的中断服务例程（ISR）可以通过读取设备的内部寄存器来检查中断是否来自该设备，以识别中断的原因。
- en: The ISR takes action to service the interrupt.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中断服务程序（ISR）采取行动来处理中断。
- en: 'In the preceding method as well as the legacy method, interrupt lines are shared:
    Everyone answers the phone. Moreover, physical interrupt lines are limited. In
    the following section, we see how MSI addresses those issues and facilitates interrupt
    management.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述方法以及传统方法中，中断线是共享的：每个人都会接电话。此外，物理中断线是有限的。在下一节中，我们将看到MSI如何解决这些问题并促进中断管理。
- en: Important note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: The i.MX6 maps INTA/B/C/D to ARM GIC IRQ `155`/`154`/`153`/`152`, respectively.
    This allows a PCIe-to-PCI bridge to function properly. Refer to IMX6DQRM.pdf,
    page 225.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: i.MX6将INTA/B/C/D映射到ARM GIC IRQ `155`/`154`/`153`/`152`，这允许PCIe到PCI桥正常运行。请参阅IMX6DQRM.pdf，第225页。
- en: Message-based interrupt type – MSI and MSI-X
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于消息的中断类型 - MSI和MSI-X
- en: 'There are two message-based interrupt mechanisms: MSI and MSI-X, the enhanced
    and extended version. MSI (or MSI-X) is simply a way of signaling interrupts using
    the PCI Express protocol layer, and the PCIe root complex (the host) takes care
    of interrupting the CPU.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种基于消息的中断机制：MSI和MSI-X，增强和扩展版本。MSI（或MSI-X）只是使用PCI Express协议层来发出中断的一种方式，PCIe根复杂（主机）负责中断CPU。
- en: Traditionally, a device is assigned pins as interrupt lines, which it has to
    assert when it wants to signal an interrupt to the CPU. This kind of signaling
    method is out-of-band since it uses yet another way (different from the main data
    path) to send such control information.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，设备被分配为中断线，当它想要向CPU发出中断信号时，必须断言这些线。这种信号方法是带外的，因为它使用了另一种方式（与主数据路径不同）来发送这样的控制信息。
- en: However, MSI allows the device to write a small amount of interrupt-describing
    data to a special memory-mapped I/O address, and the root complex then takes care
    of delivering the corresponding interrupt to the CPU. Once the endpoint device
    wants to generate the MSI interrupt, it issues a write request to (target) the
    address specified in the message address register with the data contents specified
    in the message data register. Since the data path is used for this, it is an in-band
    mechanism. Moreover, MSI increases the number of possible interrupts. This is
    described in the next section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，MSI允许设备向特殊的内存映射I/O地址写入少量描述中断的数据，然后根复杂负责将相应的中断传递给CPU。一旦端点设备想要生成MSI中断，它就会向消息地址寄存器中指定的地址发出写请求，数据内容指定在消息数据寄存器中。由于数据路径用于此，这是一种带内机制。此外，MSI增加了可能的中断数量。这将在下一节中描述。
- en: Important note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: PCI Express does not have a separate interrupt pin at all. However, it is compatible
    with legacy interrupts on a software level. For this, it requires MSI or MSI-X
    since it uses special in-band messages to allow pin assertion or de-assertion
    to be emulated. In other words, PCI Express emulates this capability by providing
    `assert_INTx` and `deassert_INTx`. Message packets are sent through the PCI Express
    serial link.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: PCI Express根本没有单独的中断引脚。但是，它在软件级别上与传统中断兼容。为此，它需要MSI或MSI-X，因为它使用特殊的带内消息来允许引脚断言或取消断言的模拟。换句话说，PCI
    Express通过提供`assert_INTx`和`deassert_INTx`来模拟这种能力。消息包通过PCI Express串行链路发送。
- en: 'In an implementation using MSI, the following are the usual steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用MSI的实现中，通常的步骤如下：
- en: The device generates an interrupt by sending an MSI memory write upstream.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备通过发送MSI内存写来生成中断。
- en: The CPU acknowledges the interrupt and calls the appropriate device ISR since
    this is known in advance based on the MSI vector.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CPU确认中断并调用适当的设备ISR，因为这是根据MSI向量事先知道的。
- en: The ISR takes action to service the interrupt.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中断服务程序（ISR）采取行动来处理中断。
- en: MSIs are not shared, so an MSI that is assigned to a device is guaranteed to
    be unique within the system. It goes without saying that MSI implementation significantly
    reduces the total servicing time needed for the interrupt.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: MSI不是共享的，因此分配给设备的MSI在系统内是唯一的。不言而喻，MSI实现显著减少了中断所需的总服务时间。
- en: Important note
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Most people think that MSI allows the device to send data to a processor as
    part of the interrupt. This is a misconception. The truth is that the data that
    is sent as part of the memory write transaction is exclusively used by the chipset
    (the root complex actually) to determine which interrupt to trigger on which processor;
    that data is not available for the device to communicate additional information
    to the interrupt handler.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人认为MSI允许设备作为中断的一部分向处理器发送数据。这是一个误解。事实是，作为内存写事务的一部分发送的数据是由芯片组（实际上是根复杂）专门用于确定在哪个处理器上触发哪个中断；这些数据不可用于设备向中断处理程序传递附加信息。
- en: MSI mechanism
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MSI机制
- en: MSI was originally defined as part of the PCI 2.2 standard, allowing a device
    to allocate either 1, 2, 4, 8, 16, or up to 32 interrupts. The device is programmed
    with an address to write to in order to signal an interrupt (generally, a control
    register in an interrupt controller), and a 16-bit data word to identify the device.
    The interrupt number is added to the data word to identify the interrupt.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: MSI最初是作为PCI 2.2标准的一部分定义的，允许设备分配1、2、4、8、16或多达32个中断。设备被编程为写入地址以发出中断的信号（通常是中断控制器中的控制寄存器），并且一个16位数据字用于识别设备。中断号被添加到数据字中以识别中断。
- en: A PCI Express endpoint may signal an MSI by sending a standard PCI Express posted
    write packet to the root port. The packet is made of a specific address (allocated
    by the host) and one of up to 32 data values (thus, 32 interrupts) provided by
    the host to the endpoint. The varying data values and the address value provide
    more detailed identification of interrupt events than legacy interrupts. Interrupt
    masking capability is optional in MSI specifications.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: PCI Express端点可以通过向根端口发送标准的PCI Express发布写数据包来发出MSI信号。数据包由特定地址（由主机分配）和主机提供给端点的最多32个数据值（因此，32个中断）组成。不同的数据值和地址值提供了比传统中断更详细的中断事件识别。中断屏蔽功能在MSI规范中是可选的。
- en: This approach does have some limitations. Only one address is used for the 32
    data values, which makes it difficult to target individual interrupts to different
    processors. This limitation is due to the fact that a memory-write operation associated
    with an MSI can only be distinguished from other memory-write operations by the
    address locations (not the data) they target, which are reserved by the system
    for interrupt delivery.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确实有一些限制。32个数据值只使用一个地址，这使得将单个中断定位到不同处理器变得困难。这种限制是因为与MSI相关联的内存写操作只能通过它们所针对的地址位置（而不是数据）来区分，这些地址位置由系统保留用于中断传递。
- en: 'The following are the MSI configuration steps, performed by the PCI controller
    driver for a PCI Express device:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由PCI控制器驱动程序执行的PCI Express设备的MSI配置步骤：
- en: The bus enumeration process takes place during startup. It consists of kernel
    PCI core code scanning the PCI bus(es) in order to discover devices (in other
    words, it carries out configuration reads for valid vendor IDs). Upon discovering
    a PCI Express function, the PCI core code reads the capabilities list pointer
    to obtain the location of the first capability register within the chain of registers.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总线枚举过程发生在启动期间。它包括内核PCI核心代码扫描PCI总线，以发现设备（换句话说，它为有效的供应商ID执行配置读取）。在发现PCI Express功能时，PCI核心代码读取能力列表指针，以获取链式寄存器中第一个能力寄存器的位置。
- en: The PCI core code then searches the capability register sets. It keeps doing
    this until it discovers the MSI capability register set (capability ID of `05h`).
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，PCI核心代码搜索能力寄存器集。它会一直这样做，直到发现MSI能力寄存器集（能力ID为`05h`）。
- en: After that, the PCI core code configures the device, assigning a memory address
    to the device's message address register. This is the destination address of the
    memory write used when delivering an interrupt request.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，PCI核心代码配置设备，将内存地址分配给设备的消息地址寄存器。这是在传递中断请求时使用的内存写的目的地址。
- en: The PCI core code checks the Multiple Message Capable field in the device's
    message control register to determine how many event-specific messages the device
    would like assigned to it.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PCI核心代码检查设备的消息控制寄存器中的多消息能力字段，以确定设备希望分配给它多少个特定事件的消息。
- en: The core code then allocates a number of messages equal to or less than what
    the device requested. As a minimum, one message will be allocated to the device.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，核心代码分配与设备请求的数量相等或少于该数量的消息。至少会分配一个消息给设备。
- en: The core code writes the base message data pattern into the device's message
    data register.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 核心代码将基本消息数据模式写入设备的消息数据寄存器。
- en: Finally, the PCI core code sets the MSI enable bit in the device's message control
    register, thereby enabling it to generate interrupts using MSI memory writes.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，PCI核心代码在设备的消息控制寄存器中设置MSI使能位，从而使其能够使用MSI内存写生成中断。
- en: MSI-X mechanism
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MSI-X机制
- en: '`2048` address and data pairs. Thanks to this large number of address values
    available to each endpoint, it''s possible to route MSI-X messages to different
    interrupt consumers in a system, unlike the single address available to MSI packets.
    Moreover, endpoints with MSI-X capability also include application logic to mask
    and hold pending interrupts, as well as a memory table for the address and data
    pairs.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`2048`地址和数据对。由于每个端点可用的地址值数量很大，因此可以将MSI-X消息路由到系统中的不同中断消费者，而不像MSI数据包只有单个地址可用。此外，具有MSI-X功能的端点还包括应用逻辑来屏蔽和保持未决中断，以及用于地址和数据对的内存表。'
- en: Apart from the above, an MSI-X interrupt is identical to an MSI. However, optional
    features in MSI (such as 64-bit addressing and interrupt masking) are made mandatory
    with MSI-X.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除上述之外，MSI-X中断与MSI相同。但是，MSI中的可选功能（如64位寻址和中断屏蔽）在MSI-X中变为强制性。
- en: Legacy INTx emulation
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 传统INTx模拟
- en: Because PCIe claimed backward compatibility with legacy parallel PCI, it also
    needed to support INTx-based interrupt mechanisms. But how can this be implemented?
    Actually, there were four INTx (INTA, INTB, INTC, and INTD) physical IRQ lines
    in classical PCI systems, which were all level-triggered, active low actually
    (in other words, the interrupt request is active as long as the physical INTx
    wire is at a low voltage). Then how is each IRQ transported in the emulated version?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因为PCIe声称与传统的并行PCI向后兼容，所以它还需要支持基于INTx的中断机制。但是这该如何实现呢？实际上，在经典PCI系统中有四条INTx（INTA、INTB、INTC和INTD）物理IRQ线，它们都是电平触发的，实际上是低电平（换句话说，只要物理INTx线处于低电压，中断请求就是活动的）。那么在模拟版本中如何传输每个IRQ呢？
- en: 'The answer is that PCIe virtualizes PCI physical interrupt signals by using
    an in-band signaling mechanism, the so-called MSI. Since there were two levels
    (asserted and de-asserted) per physical line, PCIe provides two messages per line,
    known as `assert_INTx` and `deassert_INTx` messages. There are eight message types
    in total: `assert_INTA`, `deassert_INTA`, ... `assert_INTD`, `deassert_INTD`.
    In fact, they are simply known as INTx messages. This way, INTx interrupts are
    propagated across the PCIe link just like MSI and MSI-X.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是PCIe通过使用一种称为MSI的带内信号机制来虚拟化PCI物理中断信号。由于每个物理线有两个级别（断开和断开），PCIe为每条线提供两个消息，称为`assert_INTx`和`deassert_INTx`消息。总共有八种消息类型：`assert_INTA`、`deassert_INTA`，...
    `assert_INTD`、`deassert_INTD`。实际上，它们简单地被称为INTx消息。这样，INTx中断就像MSI和MSI-X一样在PCIe链路上传播。
- en: This backward compatibility exists mainly for PCI to PCIe bridge chips so that
    PCI devices will work properly in a PCIe system without modifying the drivers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种向后兼容性主要存在于PCI到PCIe桥接芯片，以便PCI设备可以在PCIe系统中正常工作，而无需修改驱动程序。
- en: Now we are familiar with interrupt distribution in the PCI subsystem. We have
    covered both legacy INT-X-based mechanisms and message-based mechanisms. Now it's
    time to dive into the code, from data structures to APIs.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了PCI子系统中的中断分发。我们已经涵盖了传统的基于INT-X的机制和基于消息的机制。现在是时候深入代码，从数据结构到API。
- en: The Linux kernel PCI subsystem and data structures
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux内核PCI子系统和数据结构
- en: 'The Linux kernel supports the PCI standard and provides APIs to deal with such
    devices. In Linux, the PCI implementation can be broadly divided into the following
    main components:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核支持PCI标准，并提供处理此类设备的API。在Linux中，PCI实现可以大致分为以下主要组件：
- en: '`arch/arm/kernel/bios32.c`. The PCI BIOS code interfaces with PCI Host Controller
    code as well as the PCI core in order to perform bus enumeration and the allocation
    of resources, such as memory and interrupts.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arch/arm/kernel/bios32.c`。PCI BIOS代码与PCI主机控制器代码以及PCI核心接口，以执行总线枚举和资源分配，如内存和中断。'
- en: The successful completion of BIOS execution guarantees that all the PCI devices
    in the system are assigned parts of available PCI resources and their respective
    drivers (referred to as slave or endpoint drivers) can take control of them using
    the facilities provided by the PCI core.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: BIOS执行成功保证了系统中所有PCI设备被分配了可用PCI资源的部分，并且它们各自的驱动程序（称为从属或终端点驱动程序）可以利用PCI核心提供的设施来控制它们。
- en: Here, the kernel invokes the services of architecture and board-specific PCI
    functionalities. Two important tasks of PCI configuration are completed here.
    The first task is to scan for all PCI devices on the bus, configure them, and
    allocate memory resources. The second task is to configure the device. Configured
    here means a resource (memory) was reserved and IRQ assigned. It does not mean
    initialized. Initialization is device-specific and should be done by the device
    driver. PCI BIOS may optionally skip resource allocation (if they were assigned
    before Linux was booted, for example, in a PC scenario).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，内核调用架构和特定于板的PCI功能的服务。PCI配置的两个重要任务在这里完成。第一个任务是扫描总线上的所有PCI设备，对它们进行配置，并分配内存资源。第二个任务是配置设备。这里的配置意味着已经保留了资源（内存）并分配了IRQ。这并不意味着初始化。初始化是特定于设备的，应该由设备驱动程序完成。PCI
    BIOS可以选择跳过资源分配（例如，在Linux引导之前已经分配了资源，例如在PC场景中）。
- en: '`drivers/pci/host/`, in other words, `drivers/pci/controller/pcie-rcar.c` for
    r-car SoCs). However, some SoCs may implement the same PCIe IP block from a given
    vendor, such as Synopsys DesignWare. Such controllers can be found in the same
    directory, such as `drivers/pci/controller/dwc/` in the kernel source. For instance,
    the i.MX6 whose PCIe IP block is from this vendor has its driver implemented in
    `drivers/pci/controller/dwc/pci-imx6.c`.This part handles SoC (and sometimes board)-specific
    initialization and configuration and may invoke the PCI BIOS. However, it should
    provide PCI bus access and facility callback functions for BIOS as well as the
    PCI core, which will be called during PCI system initialization and while accessing
    the PCI bus for configuration cycles. Moreover, it provides resource information
    for available memory/IO space, INTx interrupt lines, and MSI. It should facilitate
    IO space access (as supported) and may also need to provide indirect memory access
    (if supported by hardware).'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drivers/pci/host/`，换句话说，`drivers/pci/controller/pcie-rcar.c`适用于r-car SoCs）。然而，一些SoCs可能会实现来自特定供应商的相同PCIe
    IP块，比如Synopsys DesignWare。这样的控制器可以在同一目录中找到，比如内核源代码中的`drivers/pci/controller/dwc/`。例如，i.MX6的PCIe
    IP块来自这个供应商，其驱动程序实现在`drivers/pci/controller/dwc/pci-imx6.c`中。这部分处理SoC（有时也是板）特定的初始化和配置，并可能调用PCI
    BIOS。然而，它应该提供PCI总线访问和为BIOS以及PCI核心提供回调函数，这些函数将在PCI系统初始化期间和访问PCI总线进行配置周期时被调用。此外，它提供可用内存/IO空间、INTx中断线和MSI的资源信息。它应该便于IO空间访问（如果支持），并且可能还需要提供间接内存访问（如果硬件支持）。'
- en: '`drivers/pci/probe.c`): This is in charge of creating and initializing the
    data structure tree for buses, devices, as well as bridges in the system. It handles
    bus/device numbering. It creates device entries and provides `proc/sysfs` information.
    It also provides services for PCI BIOS and slave (**End Point**) drivers and optionally
    hot plug support (if supported by h/w). It targets the (**EP**) driver interface
    query and initializes corresponding devices found during enumeration. It also
    provides an MSI interrupt handling framework and PCI Express port bus support.
    All of the above is enough to facilitate the development of device drivers in
    the Linux kernel.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drivers/pci/probe.c`：这个文件负责在系统中创建和初始化总线、设备以及桥接器的数据结构树。它处理总线/设备编号。它创建设备条目并提供`proc/sysfs`信息。它还为PCI
    BIOS和从属（**终端点**）驱动程序提供服务，并可选地支持热插拔（如果硬件支持）。它针对（**EP**）驱动程序接口查询并初始化枚举期间发现的相应设备。它还提供了MSI中断处理框架和PCI
    Express端口总线支持。以上所有内容足以促进Linux内核中设备驱动程序的开发。'
- en: PCI data structures
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PCI数据结构
- en: 'The Linux kernel PCI framework aids development on PCI device drivers, which
    are built on top of the two main data structures: `struct pci_dev`, which represents
    a PCI device from within the kernel, and `struct pci_driver`, which represents
    a PCI driver.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核PCI框架有助于PCI设备驱动程序的开发，这些驱动程序建立在两个主要数据结构的基础上：`struct pci_dev`代表内核中的PCI设备，`struct
    pci_driver`代表PCI驱动程序。
- en: struct pci_dev
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构体pci_dev
- en: 'This is the structure with which the kernel instantiates each PCI device on
    the system. It describes the device and stores some of its state parameters. This
    structure is defined in `include/linux/pci.h` as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是内核在系统上实例化每个PCI设备的结构。它描述了设备并存储了一些状态参数。该结构在`include/linux/pci.h`中定义如下：
- en: '[PRE0]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding block, some elements have been removed for the sake of readability.
    For the remaining, the following elements have the following meanings:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的块中，为了可读性，已删除了一些元素。对于剩下的元素，以下元素具有以下含义：
- en: '`procent` is the device entry in `/proc/bus/pci/`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`procent`是`/proc/bus/pci/`中的设备条目。'
- en: '`slot` is the physical slot this device is in.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slot`是设备所在的物理插槽。'
- en: '`vendor` is the vendor ID of the device manufacturer. The PCI Special Interest
    Group maintains a global registry of such numbers, and manufacturers must apply
    to have a unique number assigned to them. This ID is stored in a 16-bit register
    in the device configuration space.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vendor`是设备制造商的供应商ID。PCI特别兴趣组织维护了这些数字的全球注册表，制造商必须申请分配给他们一个唯一的编号。此ID存储在设备配置空间中的一个16位寄存器中。'
- en: '`device` is the ID that identifies this particular device once it is probed.
    This is vendor-dependent and there is no official registry as such. This is also
    stored in a 16-bit register.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device`是一旦被探测出来就能识别此特定设备的ID。这是与供应商相关的，没有官方注册表。这也存储在一个16位寄存器中。'
- en: '`subsystem_vendor` and `subsystem_device` specify the PCI subsystem vendor
    and subsystem device IDs. They can be used for further identification of the device,
    as we have seen earlier.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subsystem_vendor`和`subsystem_device`指定了PCI子系统供应商和子系统设备ID。它们可以用于进一步识别设备，就像我们之前看到的那样。'
- en: '`class` identifies the class this device belongs to. It is stored in a 16-bit
    register (in the device configuration space) whose top 8 bits identify the base
    class or group.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class`标识了设备所属的类。它存储在一个16位寄存器中（在设备配置空间中），其高8位标识基类或组。'
- en: '`pin` is the interrupt pin this device uses, in the case of the legacy INTx-based
    interrupt.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pin`是设备使用的中断引脚，在传统的基于INTx的中断情况下。'
- en: '`driver` is the driver associated with this device.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver`是与此设备关联的驱动程序。'
- en: '`dev` is the underlying device structure for this PCI device.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`是此PCI设备的基础设备结构。'
- en: '`cfg_size` is the size of the configuration space.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cfg_size`是配置空间的大小。'
- en: '`irq` is the field that is worth spending time on. When the device boots, MSI(-X)
    mode is not enabled and it remains unchanged until it is explicitly enabled by
    means of the `pci_alloc_irq_vectors()` API (old drivers use `pci_enable_msi()`).'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq`是值得花时间研究的字段。当设备启动时，MSI(-X)模式未启用，并且直到通过`pci_alloc_irq_vectors()`API（旧驱动程序使用`pci_enable_msi()`）显式启用为止，它保持不变。'
- en: 'Consequently, `irq` first corresponds to the default preassigned non-MSI IRQ.
    However, its value or usage may change according to one of the following situations:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`irq`首先对应于默认预分配的非MSI IRQ。但是，根据以下情况之一，它的值或使用可能会发生变化：
- en: a) In MSI interrupt mode (upon a successful call to `pci_alloc_irq_vectors()`
    with the `PCI_IRQ_MSI` flag set), the (preassigned) value of this field is replaced
    by a new MSI vector. This vector corresponds to the base interrupt number of the
    allocated vectors, so that the IRQ number corresponding to vector X (index starting
    from 0) is equivalent to (the same as) `pci_dev->irq + X` (see the `pci_irq_vector()`
    function, which is intended to return the Linux IRQ number of a device vector).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: a) 在MSI中断模式下（成功调用`pci_alloc_irq_vectors()`并设置了`PCI_IRQ_MSI`标志），此字段的（预分配）值将被新的MSI向量替换。该向量对应于分配向量的基本中断号，因此与向量X（从0开始的索引）对应的IRQ号等同于（与）`pci_dev->irq
    + X`（参见`pci_irq_vector()`函数，旨在返回设备向量的Linux IRQ号）。
- en: b) In MSI-X interrupt mode (upon a successful call to `pci_alloc_irq_vectors()`
    with the `PCI_IRQ_MSIX` flag set), the (preassigned) value of this field is untouched
    (because of the fact that each MSI-X vector has its dedicated message address
    and message data pair, and this does not require the 1:1 vector-to-entry mapping).
    However, in this mode, `irq` is invalid. Using it in the driver to request a service
    interrupt may result in unpredictable behavior. Consequently, in case MSI(-X)
    is needed, the `pci_alloc_irq_vectors()` function (which enables MXI(-X) prior
    to allocating vectors) should be called before the driver calls `devm_equest_irq()`,
    because MSI(-X) is delivered via a vector that is different from the vector of
    a pin-based interrupt.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: b) 在MSI-X中断模式下（成功调用`pci_alloc_irq_vectors()`并设置了`PCI_IRQ_MSIX`标志），此字段的（预分配）值不变（因为每个MSI-X向量都有其专用的消息地址和消息数据对，这不需要1:1的向量到条目映射）。但是，在此模式下，`irq`是无效的。在驱动程序中使用它来请求服务中断可能导致不可预测的行为。因此，如果需要MSI(-X)，则应在驱动程序调用`devm_equest_irq()`之前调用`pci_alloc_irq_vectors()`函数（该函数在分配向量之前启用MXI(-X)），因为MSI(-X)通过与基于引脚的中断向量不同的向量传递。
- en: '`msi_enabled` holds the enabling state of the MSI IRQ mode.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msi_enabled`保存了MSI IRQ模式的启用状态。'
- en: '`msix_enabled` holds the enabling state of the MSI-X IRQ mode.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`msix_enabled`保存了MSI-X IRQ模式的启用状态。'
- en: '`enable_cnt` holds the number of times `pci_enable_device()` has been called.
    This helps in really disabling the device only after all callers of `pci_enable_device()`
    have called `pci_disable_device()`.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enable_cnt`保存了`pci_enable_device()`被调用的次数。这有助于在所有`pci_enable_device()`的调用者都调用了`pci_disable_device()`之后才真正禁用设备。'
- en: struct pci_device_id
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构体pci_device_id
- en: 'While `struct pci_dev` describes the device, `struct pci_device_id` is intended
    to identify the device. This structure is defined as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`struct pci_dev`描述了设备，`struct pci_device_id`旨在标识设备。该结构定义如下：
- en: '[PRE1]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To understand how this structure is important for the PCI driver, let''s describe
    each of its elements:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解此结构对于PCI驱动程序的重要性，让我们描述其每个元素：
- en: '`vendor` and `device` represent the vendor ID and the device ID of the device,
    respectively. Both are paired to make a unique 32-bit identifier for a device.
    The driver relies on this 32-bit identifier to identify its devices.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vendor`和`device`分别表示设备的供应商ID和设备ID。两者配对以形成设备的唯一32位标识符。驱动程序依赖于这个32位标识符来识别其设备。'
- en: '`subvendor` and `subdevice` represent the subsystem ID.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subvendor`和`subdevice`表示子系统ID。'
- en: '`class`, `class_mask` are class-related PCI drivers that are intended to handle
    every device of a given class. For such drivers, `vendor` and `device` should
    be set to `PCI_ANY_ID`. The different classes of PCI devices are described in
    the PCI specification. These two values allow the driver to specify that it supports
    a type of PCI class device.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class`、`class_mask`是与类相关的PCI驱动程序，旨在处理给定类的每个设备。对于这样的驱动程序，应将`vendor`和`device`设置为`PCI_ANY_ID`。PCI设备的不同类别在PCI规范中有描述。这两个值允许驱动程序指定它支持的PCI类设备的类型。'
- en: '`driver_data` is the data private to the driver. This field is not used to
    identify a device, but to pass different data to differentiate between devices.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver_data`是驱动程序私有的数据。此字段不用于标识设备，而是用于传递不同的数据以区分设备。'
- en: 'There are three macros that allow you to create specific instances of `struct
    pci_device_id`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个宏允许您创建`struct pci_device_id`的特定实例。
- en: '`PCI_DEVICE`: This macro is used to describe a specific PCI device by creating
    a `struct pci_device_id` that matches a specific PCI device with the vendor and
    device IDs given as parameters (`PCI_DEVICE(vend,dev)`), and with the sub-vendor,
    sub-device, and class-related fields set to `PCI_ANY_ID`.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PCI_DEVICE`：此宏用于通过创建一个`struct pci_device_id`来描述具有供应商和设备ID的特定PCI设备（`PCI_DEVICE(vend,dev)`），并将子供应商、子设备和与类相关的字段设置为`PCI_ANY_ID`。'
- en: '`PCI_DEVICE_CLASS`: This macro is used to describe a specific PCI device class
    by creating a `struct pci_device_id` that matches a specific PCI class with `class`
    and `class_mask` given as parameters (`PCI_DEVICE_CLASS(dev_class,dev_class_mask)`).
    The vendor, device, sub-vendor, and sub-device fields will be set to `PCI_ANY_ID`.
    A typical example is `PCI_DEVICE_CLASS(PCI_CLASS_STORAGE_EXPRESS, 0xffffff)`,
    which corresponds to the PCI class for NVMe devices, and which will match any
    of these whatever the vendor and device IDs are.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PCI_DEVICE_CLASS`：此宏用于通过创建一个`struct pci_device_id`来描述特定的PCI设备类，该类与给定的`class`和`class_mask`参数匹配（`PCI_DEVICE_CLASS(dev_class,dev_class_mask)`）。供应商、设备、子供应商和子设备字段将设置为`PCI_ANY_ID`。典型示例是`PCI_DEVICE_CLASS(PCI_CLASS_STORAGE_EXPRESS,
    0xffffff)`，它对应于NVMe设备的PCI类，并且无论供应商和设备ID是什么，都将匹配任何这些设备。'
- en: '`PCI_DEVICE_SUB`: This macro is used to describe a specific PCI device with
    a subsystem by creating a `struct pci_device_id` that matches a specific device
    with subsystem information given as parameters (`PCI_DEVICE_SUB(vend, dev, subvend,
    subdev)`).'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PCI_DEVICE_SUB`：此宏用于通过创建一个`struct pci_device_id`来描述具有子系统的特定PCI设备，其中子系统信息作为参数给出（`PCI_DEVICE_SUB(vend,
    dev, subvend, subdev)`）。'
- en: 'Every device/class supported by the driver should be fed into the same array
    for later use (there are two places where we are going to use it), as in the following
    example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序支持的每个设备/类别都应该被放入同一个数组以供以后使用（我们将在两个地方使用它），如以下示例所示：
- en: '[PRE2]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Each `pci_device_id` structure needs to be exported to user space in order
    to let the hotplug and device manager (`udev`, `mdev`, and so on ...) know what
    driver goes with what device. The first reason to feed them all in the same array
    is that they can be exported in a single shot. To achieve this, you should use
    the `MODULE_DEVICE_TABLE` macro, as in the following example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`pci_device_id`结构都需要导出到用户空间，以便让热插拔和设备管理器（`udev`、`mdev`等）知道哪个驱动程序适用于哪个设备。将它们全部放入同一个数组的第一个原因是它们可以一次性导出。为了实现这一点，您应该使用`MODULE_DEVICE_TABLE`宏，如以下示例所示：
- en: '[PRE3]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This macro creates a custom section with the given information. At compilation
    time, the build process (`depmod` to be more precise) extracts this information
    out of the driver and builds a human-readable table called `modules.alias`, located
    in the `/lib/modules/<kernel_version>/` directory. When the kernel tells the hotplug
    system that a new device is available, the hotplug system will refer to the `modules.alias`
    file to find the proper driver to load.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此宏创建一个具有给定信息的自定义部分。在编译时，构建过程（更精确地说是`depmod`）从驱动程序中提取这些信息，并构建一个名为`modules.alias`的人类可读表，位于`/lib/modules/<kernel_version>/`目录中。当内核告诉热插拔系统有新设备可用时，热插拔系统将参考`modules.alias`文件找到适当的驱动程序进行加载。
- en: struct pci_driver
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`struct pci_driver`'
- en: 'This structure represents an instance of a PCI device driver, whatever it is
    and whatever subsystem it belongs to. It is the main structure that every PCI
    driver must create and fill in order to be able to get them registered with the
    kernel. `struct pci_driver` is defined as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构表示PCI设备驱动程序的一个实例，无论它是什么，属于什么子系统。这是每个PCI驱动程序必须创建和填充的主要结构，以便能够将它们注册到内核中。`struct
    pci_driver`定义如下：
- en: '[PRE4]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Parts of the elements in this structure have been removed since they hold no
    interest for us. The following are the meanings of the remaining fields in the
    structure:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构中的元素部分已被删除，因为它们对我们没有兴趣。以下是结构中剩余字段的含义：
- en: '`name`: This is the name of the driver. Since drivers are identified by their
    name, it must be unique among all PCI drivers in the kernel. It is common to set
    this field to the same name as the module name of the driver. If there is already
    a driver register with the same name in the same subsystem bus, the registration
    of your driver will fail. To see how it works under the hood, have a look at `driver_register()`
    at [https://elixir.bootlin.com/linux/v4.19/source/drivers/base/driver.c#L146](https://elixir.bootlin.com/linux/v4.19/source/drivers/base/driver.c#L146).'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 这是驱动程序的名称。由于驱动程序是通过其名称标识的，它必须在内核中所有PCI驱动程序中是唯一的。通常将此字段设置为与驱动程序的模块名称相同的名称。如果在相同的子系统总线中已经注册了具有相同名称的驱动程序，则您的驱动程序的注册将失败。要了解其内部工作原理，请查看[https://elixir.bootlin.com/linux/v4.19/source/drivers/base/driver.c#L146](https://elixir.bootlin.com/linux/v4.19/source/drivers/base/driver.c#L146)中的`driver_register()`。'
- en: '`id_table`: This should point to the `struct pci_device_id` table described
    earlier. It is the second and last place this structure is used in the driver.
    It must be non-NULL for the probe to be called.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id_table`: 这应该指向先前描述的`struct pci_device_id`表。这是驱动程序中使用此结构的第二个也是最后一个地方。对于调用探测函数，它必须是非NULL的。'
- en: '`probe`: This is the pointer to the `probe` function of the driver. It is called
    by the PCI core when a PCI device matches (either by vendor/product IDs or class
    ID) an entry in `id_table` in the driver. This method should return `0` if it
    managed to initialize the device, or a negative error otherwise.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`探测`: 这是驱动程序的`probe`函数的指针。当PCI设备与驱动程序中的`id_table`中的条目匹配（通过供应商/产品ID或类ID），PCI核心会调用它。如果该方法成功初始化设备，则应返回`0`，否则返回负错误值。'
- en: '`remove`: This is called by the PCI core when a device handled by this driver
    is removed from the system (disappears from the bus) or when the driver is being
    unloaded from the kernel.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove`: 当此驱动程序处理的设备从系统中移除（从总线上消失）或驱动程序从内核中卸载时，PCI核心会调用此函数。'
- en: '`suspend`, `resume`, and `shutdown`: These are optional but recommended power
    management functions. In those callbacks, you can use PCI-related power management
    helpers such as `pci_save_state()` or `pci_restore_state()`, `pci_disable_device()`
    or `pci_enable_device()`, `pci_set_power_state()`, and `pci_choose_state()`. These
    callbacks are invoked by the PCI core, respectively:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suspend`、`resume`和`shutdown`: 这些是可选但建议的电源管理函数。在这些回调中，您可以使用与PCI相关的电源管理助手，如`pci_save_state()`或`pci_restore_state()`、`pci_disable_device()`或`pci_enable_device()`、`pci_set_power_state()`和`pci_choose_state()`。这些回调分别由PCI核心调用：'
- en: – When the device is suspended, in which case the state is given as an argument
    to the callback.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '- 当设备被挂起时，此时状态作为回调的参数给出。'
- en: – When the device is being resumed. This may occur only after `suspend` has
    been called.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '- 当设备被恢复时。这可能仅在调用`suspend`后发生。'
- en: – For a proper shutdown of the device.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '- 为了设备的正确关闭。'
- en: 'The following is an example of a PCI driver structure being initialized:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是初始化PCI驱动程序结构的示例：
- en: '[PRE5]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Registering a PCI driver
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注册PCI驱动程序
- en: 'Registering a PCI driver with the PCI core consists of calling `pci_register_driver()`,
    given an argument as a pointer to the `struct pci_driver` structure set up earlier.
    This should be done in the `init` method of the module, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`pci_register_driver()`注册PCI核心的PCI驱动程序，给定一个指向先前设置的`struct pci_driver`结构的参数。这应该在模块的`init`方法中完成，如下所示：
- en: '[PRE6]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`pci_register_driver()` returns `0` if everything went well while registering,
    or a negative error otherwise. This return value is handled by the kernel.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`pci_register_driver()`在注册成功时返回`0`，否则返回负错误值。这个返回值由内核处理。'
- en: 'However, on the unloading path of the module, `struct pci_driver` needs to
    be unregistered so that the system does not try to use a driver whose corresponding
    module no longer exists. Thus, unloading a PCI driver entails calling `pci_unregister_driver()`,
    along with a pointer to the same structure as per the registration, shown as follows.
    This should be done in the module `exit` function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在模块卸载路径上，需要注销`struct pci_driver`，以防系统尝试使用对应模块已不存在的驱动程序。因此，卸载PCI驱动程序需要调用`pci_unregister_driver()`，并且指向与注册相同的结构体指针，如下所示。这应该在模块的`exit`函数中完成：
- en: '[PRE7]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That being said, with those operations often being repeated in PCI drivers,
    the PCI core exposes the `module_pci_macro()` macro in order to handle registering/unregistering
    automatically, as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，由于这些操作在PCI驱动程序中经常重复，PCI核心暴露了`module_pci_macro()`宏，以便自动处理注册/注销，如下所示：
- en: '[PRE8]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This macro is safer, as it takes care of both registering and unregistering,
    preventing some developers from providing one and forgetting the other.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏更安全，因为它负责注册和注销，防止一些开发人员提供一个并忘记另一个。
- en: Now we are familiar with the most important PCI data structures – `struct pci_dev`,
    `pci_device_id`, and `pci_driver`, as well as the Hyphenate helpers to deal with
    those data structures. The logical continuation is the driver structure, in which
    we learn where and how to use the previously enumerated data structures.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了最重要的PCI数据结构 - `struct pci_dev`、`pci_device_id`和`pci_driver`，以及处理这些数据结构的连字符助手。逻辑的延续是驱动程序结构，在其中我们学习如何以及在哪里使用先前列举的数据结构。
- en: Overview of the PCI driver structure
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PCI驱动程序结构概述
- en: While writing a PCI device driver, there are steps that need to be followed,
    some of which need to be done in a predefined order. Here, we try to discuss in
    detail each of these steps, explaining details where applicable.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写PCI设备驱动程序时，需要遵循一些步骤，其中一些需要按预定义的顺序执行。在这里，我们试图详细讨论每个步骤，解释适用的细节。
- en: Enabling the device
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用设备
- en: 'Before any operation can be performed on a PCI device (even for reading its
    configuration registers only), this PCI device must be enabled, and this has to
    be done explicitly by the code. The kernel provides `pci_enable_device()` for
    this purpose. This function initializes the device so that it can be used by a
    driver, asking low-level code to enable I/O and memory. It also handles PCI power
    management wake up, such that if the device was suspended, it will be woken up,
    too. The following is what `pci_enable_device()` looks like:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在对PCI设备执行任何操作之前（即使只是读取其配置寄存器），必须启用此PCI设备，而且必须由代码显式地执行此操作。内核提供了`pci_enable_device()`来实现这一目的。此函数初始化设备，以便驱动程序可以使用它，并要求低级代码启用I/O和内存。它还处理PCI电源管理唤醒，以便如果设备被挂起，它也将被唤醒。以下是`pci_enable_device()`的样子：
- en: '[PRE9]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since `pci_enable_device()` can fail, the value it returns must be checked,
    as in the following example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pci_enable_device()`可能失败，因此必须检查其返回值，如以下示例所示：
- en: '[PRE10]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Remember, `pci_enable_device()` will initialize both memory-mapped and I/O BARs.
    However, you may want to initialize one but not the other, either because your
    device does not support both, or because you'll not use both in the driver.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`pci_enable_device()`将初始化内存映射和I/O BARs。但是，您可能只想初始化其中一个，而不是另一个，要么是因为您的设备不支持两者，要么是因为您在驱动程序中不会同时使用两者。
- en: In order not to initialize I/O spaces, you can use another variant of the enabling
    method, `pci_enable_device_mem()`. On the other hand, if you need to deal with
    I/O space only, you can use the `pci_enable_device_io()` variant instead. The
    difference between both variants is that `pci_enable_device_mem()` will initialize
    only memory-mapped BARs, whereas `pci_enable_device_io()` will initialize I/O
    BARs. Note that if the device is enabled more than once, each operation will increment
    the `.enable_cnt` field in the `struct pci_dev` structure, but only the first
    operation will really act on the device.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不初始化I/O空间，可以使用启用方法的另一个变体`pci_enable_device_mem()`。另一方面，如果只需要处理I/O空间，可以使用`pci_enable_device_io()`变体。两种变体之间的区别在于，`pci_enable_device_mem()`将仅初始化内存映射BARs，而`pci_enable_device_io()`将初始化I/O
    BARs。请注意，如果设备启用了多次，每次操作都将增加`struct pci_dev`结构中的`.enable_cnt`字段，但只有第一次操作才会真正影响设备。
- en: 'When the PCI device is to be disabled, you should adopt the `pci_disable_device()`
    method, whatever the enabling variant you used. This method signals to the system
    that the PCI device is no longer in use by the system. The following is its prototype:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当要禁用PCI设备时，应该采用`pci_disable_device()`方法，无论您使用的是哪种启用变体。此方法向系统发出信号，表明PCI设备不再被系统使用。以下是其原型：
- en: '[PRE11]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`pci_disable_device()` also disables bus mastering on the device, if active.
    However, the device is not disabled until all the callers of `pci_enable_device()`
    (or one of its variants) have called `pci_disable_device()`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`pci_disable_device()`还会在设备上禁用总线主控（如果激活）。但是，只有在`pci_enable_device()`（或其变体之一）的所有调用者都调用了`pci_disable_device()`之后，设备才会被禁用。'
- en: Bus mastering capability
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 总线主控能力
- en: A PCI device can, by definition, initiate transactions on the bus, at the very
    moment at which it becomes the bus master. After the device is enabled, you may
    want to enable bus mastering.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: PCI设备可以根据定义在总线上启动事务，即在成为总线主控的那一刻。在启用设备之后，您可能希望启用总线主控。
- en: 'This actually consists of enabling DMA in the device, by setting the bus master
    bit in the appropriate configuration register. The PCI core provides `pci_set_master()`
    for this purpose. This method also invokes `pci_bios (pcibios_set_master()` actually)
    in order to perform the necessary arch-specific settings. `pci_clear_master()`
    will disable DMA by clearing the bus master bit. It is the reverse operation:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上是通过在适当的配置寄存器中设置总线主控位来启用设备中的DMA。PCI核心提供了`pci_set_master()`来实现这一目的。此方法还调用`pci_bios（实际上是pcibios_set_master()）`以执行必要的特定于体系结构的设置。`pci_clear_master()`将通过清除总线主控位来禁用DMA。这是相反的操作：
- en: '[PRE12]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that `pci_set_master()` must be invoked if the device is intended to perform
    DMA operations.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果设备打算执行DMA操作，则必须调用`pci_set_master()`。
- en: Accessing configuration registers
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问配置寄存器
- en: Once the device is bound to the driver and after it has been enabled by the
    driver, it is common to access device memory spaces. The one often accessed first
    is the configuration space. Conventional PCI and PCI-X mode 1 devices have 256
    bytes of configuration space. PCI-X mode 2 and PCIe devices have 4,096 bytes of
    configuration space. It is primordial for the driver to be able to access the
    device configuration space, either to read information mandatory for the proper
    operation of the driver, or to set up some vital parameters. The kernel exposes
    standard and dedicated APIs (read and write) for different sizes of data configuration
    space.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设备绑定到驱动程序并由驱动程序启用后，通常会访问设备内存空间。通常首先访问的是配置空间。传统PCI和PCI-X模式1设备有256字节的配置空间。PCI-X模式2和PCIe设备有4096字节的配置空间。对于驱动程序能够访问设备配置空间至关重要，无论是为了读取对驱动程序的正常操作必不可少的信息，还是为了设置一些重要的参数。内核为不同大小的数据配置空间提供了标准和专用的API（读取和写入）。
- en: 'In order to read data from the device configuration space, you can use the
    following primitives:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从设备配置空间中读取数据，可以使用以下原语：
- en: '[PRE13]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The above reads, respectively, as one, two, or four bytes in the configuration
    space of the PCI device represented here by the `dev` argument. The `read` value
    is returned to the `val` argument. When it comes to writing data to the device
    configuration space, you can use the following primitives:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 上述原语分别作为一个、两个或四个字节在此处由`dev`参数表示的PCI设备的配置空间中读取。`read`值返回到`val`参数。在写入数据到设备配置空间时，可以使用以下原语：
- en: '[PRE14]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The above primitives write, respectively, one, two, or four bytes into the device
    configuration space. The `val` argument represents the value to write.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 上述原语分别将一个、两个或四个字节写入设备配置空间。`val`参数表示要写入的值。
- en: 'In either read or write cases, the `where` argument is the byte offset from
    the beginning of the configuration space. However, there exist in the kernel some
    commonly accessed configuration offsets identified by symbolically named macros,
    defined in `include/uapi/linux/pci_regs.h`. The following is a short excerpt:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取或写入情况下，`where`参数是从配置空间开头的字节偏移量。但是，在内核中存在一些常用的配置偏移量，由`include/uapi/linux/pci_regs.h`中定义的符号命名的宏标识。以下是一个简短的摘录：
- en: '[PRE15]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Thus, to get the revision ID of a given PCI device, you could use the following
    example:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要获取给定PCI设备的修订ID，可以使用以下示例：
- en: '[PRE16]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the above, we used `pci_read_config_byte()` because the revision is represented
    by one byte only.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们使用了`pci_read_config_byte()`，因为修订仅由一个字节表示。
- en: Important note
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Since data is stored in (and read from) PCI devices in little endian format,
    read primitives (actually `word` and `dword` variants) take care of converting
    read data into the native endianness of the CPU, and write primitives (`word`
    and `dword` variants) take care of converting data from the native CPU byte order
    to little endian prior to writing data to the device.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据以小端格式存储在（和从）PCI设备中，读取原语（实际上是`word`和`dword`变体）负责将读取的数据转换为CPU的本机字节顺序，并且写入原语（`word`和`dword`变体）负责在将数据写入设备之前将数据从本机CPU字节顺序转换为小端格式。
- en: Accessing memory-mapped I/O resources
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问内存映射I/O资源
- en: Memory registers are used for just about everything else, for example, for burst
    transactions. Those registers actually correspond to the device memory BARs. Each
    of them is then assigned a memory region from the system address space so that
    any access to those regions is redirected to the corresponding device, targeting
    the right local (in the device) memory corresponding to the BAR. This is memory-mapped
    I/O.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 内存寄存器用于几乎所有其他事情，例如用于突发事务。这些寄存器实际上对应于设备内存BAR。然后，为系统地址空间中的每个寄存器分配一个内存区域，以便将对这些区域的任何访问重定向到相应的设备，从而针对与BAR对应的正确本地（在设备中）内存。这就是内存映射I/O。
- en: 'In the Linux kernel memory-mapped I/O world, it is common to request (to claim
    actually) a memory region before creating a mapping for it. You can use `request_mem_region()`
    and `ioremap()` primitives for both purposes. The following are their prototypes:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux内核内存映射I/O世界中，通常在创建映射之前请求（实际上是声明）内存区域是很常见的。您可以使用`request_mem_region()`和`ioremap()`原语来实现这两个目的。以下是它们的原型：
- en: '[PRE17]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`request_mem_region()` is a pure reservation mechanism and does not perform
    any mapping. It relies on the fact that other drivers should be polite and should
    call `request_mem_region()`on their turns, which would prevent another driver
    from overlapping a memory region that has already been claimed. You should not
    map nor access the claimed region unless this call returns successfully. In its
    arguments, `name` represents the name to be given to the resource, `start` represents
    what address the mapping should be created for, and `n` indicates how large the
    mapping should be. To obtain this information for a given BAR, you can use `pci_resource_start()`,
    `pci_resource_len()`, or even `pci_resource_end()`, whose prototypes are the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`request_mem_region()`是一个纯预留机制，不执行任何映射。它依赖于其他驱动程序应该礼貌并应该在他们的轮次上调用`request_mem_region()`，这将防止另一个驱动程序重叠已经被声明的内存区域。除非此调用成功返回，否则不应映射或访问声明的区域。在其参数中，`name`表示要赋予资源的名称，`start`表示应为其创建映射的地址，`n`表示映射应有多大。要获取给定BAR的此信息，可以使用`pci_resource_start()`，`pci_resource_len()`，甚至`pci_resource_end()`，其原型如下：'
- en: '`unsigned long pci_resource_start (struct pci_dev *dev, int bar)`: This function
    returns the first address (memory address or I/O port number) associated with
    the BAR whose index is bar.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned long pci_resource_start (struct pci_dev *dev, int bar)`: 此函数返回与索引为bar的BAR关联的第一个地址（内存地址或I/O端口号）。'
- en: '`unsigned long pci_resource_len (struct pci_dev *dev, int bar)`: This function
    returns the size of the BAR `bar`.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned long pci_resource_len (struct pci_dev *dev, int bar)`: 此函数返回BAR `bar`的大小。'
- en: '`unsigned long pci_resource_end (struct pci_dev *dev, int bar)`: This function
    returns the last address that is part of the I/O region number `bar`.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned long pci_resource_end (struct pci_dev *dev, int bar)`: 此函数返回作为I/O区域编号`bar`的一部分的最后地址。'
- en: '`unsigned long pci_resource_flags (struct pci_dev *dev, int bar)`: This function
    is not only related to the memory resource BAR. It actually returns the flags
    associated with this resource. `IORESOURCE_IO` would mean the BAR `bar` is an
    I/O resource (thus suitable for I/O mapped I/O), while `IORESOURCE_MEM` would
    mean it is a memory resource (to be used for memory-mapped I/O).'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned long pci_resource_flags (struct pci_dev *dev, int bar)`: 此函数不仅与内存资源BAR相关。它实际上返回与此资源关联的标志。`IORESOURCE_IO`表示BAR
    `bar`是I/O资源（因此适用于I/O映射I/O），而`IORESOURCE_MEM`表示它是内存资源（用于内存映射I/O）。'
- en: 'On the other side, `ioremap()` does create real mapping, and returns a memory-mapped
    I/O cookie on the mapped region. As an example, the following code shows how to
    map the `bar0` of a given device:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`ioremap()`确实创建了实际映射，并返回映射区域上的内存映射I/O cookie。例如，以下代码显示了如何映射给定设备的`bar0`：
- en: '[PRE18]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code works well, but it is tedious, since we would do this for
    each BAR. In fact, `request_mem_region()` and `ioremap()` are quite basic primitives.
    The PCI framework provides many more PCI-related functions to facilitate such
    common tasks:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码运行良好，但很繁琐，因为我们需要为每个BAR执行此操作。实际上，`request_mem_region()`和`ioremap()`是非常基本的原语。PCI框架提供了许多与PCI相关的函数，以便简化这些常见任务：
- en: '[PRE19]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding helpers can be described as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的辅助程序可以描述如下：
- en: '`pci_request_regions()` marks all PCI regions associated with the `pdev` PCI
    device as being reserved by the owner `res_name`. In its arguments, `pdev` is
    the PCI device whose resources are to be reserved and `res_name` is the name to
    be associated with the resource. `pci_request_region()`, on the other hand, targets
    a single BAR, identified by the `bar` argument.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pci_request_regions()`标记与`pdev` PCI设备关联的所有PCI区域为所有者`res_name`所保留。在其参数中，`pdev`是要保留其资源的PCI设备，`res_name`是要与资源关联的名称。另一方面，`pci_request_region()`针对由`bar`参数标识的单个BAR。'
- en: '`pci_iomap()` creates a mapping for a BAR. You can access it using `ioread*()`
    and `iowrite*()`. `maxlen` specifies the maximum length to map. If you want to
    get access to the complete BAR without checking for its length first, pass `0`
    here.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pci_iomap()`为BAR创建映射。您可以使用`ioread*()`和`iowrite*()`来访问它。`maxlen`指定要映射的最大长度。如果要在不先检查其长度的情况下访问完整的BAR，请在此处传递`0`。'
- en: '`pci_iomap_range()` creates a mapping from starting from an offset in the BAR.
    The resulting mapping starts at `offset` and is `maxlen` wide. `maxlen` specifies
    the maximum length to map. If you want to get access to the complete BAR from
    `offset` to the end, pass `0` here.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pci_iomap_range()`从BAR的偏移开始创建映射。生成的映射从`offset`开始，宽度为`maxlen`。`maxlen`指定要映射的最大长度。如果要从`offset`到结尾访问完整的BAR，请在此处传递`0`。'
- en: '`pci_ioremap_bar()` provides an error-proof way (relative to `pci_ioremap()`)
    to carry out a PCI memory remapping.. It makes sure the BAR is actually a memory
    resource, not an I/O resource. However, it maps the whole BAR size.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pci_ioremap_bar()`提供了一种无误巧的方式（相对于`pci_ioremap()`）来执行PCI内存重映射。它确保BAR实际上是一个内存资源，而不是一个I/O资源。然而，它映射整个BAR大小。'
- en: '`pci_iounmap()` is the opposite of `pci_iomap()`, which undoes the mapping.
    Its `addr` argument corresponds to the cookie previously returned by `pci_iomap()`.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pci_iounmap()`是`pci_iomap()`的相反操作，用于取消映射。它的`addr`参数对应于先前由`pci_iomap()`返回的cookie。'
- en: '`pci_release_regions()` is the opposite of `pci_request_regions()`. It releases
    reserved PCI I/O and memory resources previously claimed (reserved). `pci_release_region()`
    targets the single BAR variant.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pci_release_regions()`是`pci_request_regions()`的相反操作。它释放先前声明（保留）的PCI I/O和内存资源。`pci_release_region()`针对单个BAR变体。'
- en: 'Using these helpers, we can rewrite the same code as before, but for BAR1 this
    time. This would look as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些辅助程序，我们可以重新编写与BAR1相同的代码。这将如下所示：
- en: '[PRE20]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After the memory areas are claimed and mapped, `ioread*()` and `iowrite*()`
    APIs, which provide platform abstraction, access the mapped registers.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存区域被声明和映射之后，提供平台抽象的`ioread*()`和`iowrite*()`API访问映射的寄存器。
- en: Accessing I/O port resources
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问I/O端口资源
- en: 'I/O port access requires going through the same steps as I/O memory, although
    the underlying mechanisms are different: requesting the I/O region, mapping the
    I/O region (this is not mandatory, it is just a matter of politeness), and accessing
    the I/O region.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: I/O端口访问需要经过与I/O内存相同的步骤，尽管底层机制不同：请求I/O区域，映射I/O区域（这不是强制性的，这只是一种礼貌），并访问I/O区域。
- en: 'The first two steps have already been addressed without you noticing. Actually,
    `pci_requestregion*()` primitives handle both I/O port and I/O memory. It relies
    on the resource flags (`pci_resource_flags()`) in order to call the appropriate
    low-level helper (`(request_region()`) for I/O port or `request_mem_region()`
    for I/O memory:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个步骤已经在您不知不觉中得到了解决。实际上，`pci_requestregion*()`原语处理I/O端口和I/O内存。它依赖于资源标志（`pci_resource_flags()`）以便调用适当的低级辅助程序（`（request_region()）`用于I/O端口或`request_mem_region()`用于I/O内存：
- en: '[PRE21]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Thus, whether the resource is I/O memory or I/O port, you can safely use either
    `pci_request_regions()` or its single bar variant, `pci_request_region()`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论资源是I/O内存还是I/O端口，您都可以安全地使用`pci_request_regions()`或其单个BAR变体`pci_request_region()`。
- en: The same applies to the I/O port mapping. `pci_iomap*()` primitives are able
    to deal with either I/O port or I/O memory. They rely on the resource flags too,
    and they invoke the appropriate helper to create the mapping. Based on the resource
    type, the underlying mapping functions are `ioremap()` for I/O memory, which are
    resources of the `IORESOURCE_MEM` type, and `__pci_ioport_map()` for I/O port,
    which corresponds to resources of the `IORESOURCE_IO` type. `__pci_ioport_map()`
    is an arch-dependent function (overridden by MIPS and SH architectures actually),
    which, most of the time, corresponds to `ioport_map()`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于I/O端口映射。`pci_iomap*()`原语能够处理I/O端口或I/O内存。它们也依赖于资源标志，并调用适当的辅助程序来创建映射。根据资源类型，底层映射函数是`ioremap()`用于I/O内存，这是`IORESOURCE_MEM`类型的资源，以及`__pci_ioport_map()`用于I/O端口，对应于`IORESOURCE_IO`类型的资源。`__pci_ioport_map()`是一个与体系结构相关的函数（实际上被MIPS和SH体系结构覆盖），大多数情况下对应于`ioport_map()`。
- en: 'To confirm what we just said, we can have a look at the body of the `pci_iomap_range()`
    function, on which `pci_iomap()` relies:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认我们刚才说的话，我们可以看一下`pci_iomap_range()`函数的主体，`pci_iomap()`依赖于它：
- en: '[PRE22]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, when it comes to accessing I/O ports, APIs completely change. The
    following are helpers for accessing I/O ports. These functions hide the details
    of the underlying mapping and of what type they are. The following lists the functions
    provided by the kernel to access I/O ports:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当涉及访问I/O端口时，API完全改变。以下是用于访问I/O端口的辅助程序。这些函数隐藏了底层映射的细节和它们的类型。以下列出了内核提供的用于访问I/O端口的函数：
- en: '[PRE23]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding excerpt, the `in*()` family reads one, two, or four bytes,
    respectively, from the `port` location. The data fetched is returned by a value.
    On the other hand, the `out*()` family writes one, two, or four bytes, respectively,
    referred to as a `value` argument in the `port` location.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的摘录中，`in*()`系列从`port`位置分别读取一个、两个或四个字节。获取的数据由一个值返回。另一方面，`out*()`系列将一个、两个或四个字节写入到`port`位置中的`value`参数中。
- en: Dealing with interrupts
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理中断
- en: Drivers that need to service interrupts for a device need to request those interrupts
    first. It is common to request interrupts from within the `probe()` method. That
    being said, in order to deal with legacy and non-MSI IRQ, drivers can directly
    use the `pci_dev->irq` field, which is preassigned when the device is probed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 需要为设备服务中断的驱动程序首先需要请求这些中断。通常在`probe()`方法中请求中断是很常见的。也就是说，为了处理传统和非MSI IRQ，驱动程序可以直接使用`pci_dev->irq`字段，这在设备被探测时就预先分配好了。
- en: 'However, for a more generic approach, it is recommended to use the `pci_alloc_irq_vectors()`
    API. This function is defined as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于更通用的方法，建议使用`pci_alloc_irq_vectors()` API。此函数定义如下：
- en: '[PRE24]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding function returns the number of vectors allocated (which might
    be smaller than `max_vecs`) if successful, or a negative error code in the event
    of an error. The number of allocated vectors is always at least up to `min_vecs`.
    If less than `min_vecs` interrupt vectors are available for `dev`, the function
    will fail with `-ENOSPC`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，上述函数将返回分配的向量数（如果成功可能小于`max_vecs`），或者在出现错误时返回负错误代码。分配的向量数始终至少达到`min_vecs`。如果对于`dev`来说少于`min_vecs`个中断向量是可用的，函数将以`-ENOSPC`失败。
- en: 'The advantage of this function is that it can deal with either legacy interrupts
    and MSI or MSI-X interrupts. Depending on the `flags` argument, the driver can
    instruct the PCI layer to set up the MSI or MSI-X capability for this device.
    This argument is used to specify the type of interrupt used by the device and
    the driver. Possible flags are defined in `include/linux/pci.h`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的优点是它可以处理传统中断和MSI或MSI-X中断。根据`flags`参数，驱动程序可以指示PCI层为此设备设置MSI或MSI-X功能。此参数用于指定设备和驱动程序使用的中断类型。可能的标志在`include/linux/pci.h`中定义：
- en: '`PCI_IRQ_LEGACY`: A single legacy IRQ vector.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PCI_IRQ_LEGACY`：一个传统的IRQ向量。'
- en: '`PCI_IRQ_MSI`: On the success path, `pci_dev->msi_enabled` is set to `1`.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PCI_IRQ_MSI`：在成功路径上，`pci_dev->msi_enabled`设置为`1`。'
- en: '`PCI_IRQ_MSIX`: On the success path, `pci_dev->msix_enabled` is set to `1`.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PCI_IRQ_MSIX`：在成功路径上，`pci_dev->msix_enabled`设置为`1`。'
- en: '`PCI_IRQ_ALL_TYPES`: This allows trying to allocate any of the above kinds
    of interrupt, but in a fixed order. MSI-X mode is always tried first and the function
    returns immediately in case of success. If MSI-X fails, then MSI is tried. The
    legacy mode is used as a fallback in case both MSI-X and MSI fail. The driver
    can rely on `pci_dev->msi_enabled` and `pci_dev->msix_enabled` to determine which
    mode was successful.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PCI_IRQ_ALL_TYPES`：这允许尝试分配上述任何一种中断，但按固定顺序。总是首先尝试MSI-X模式，并在成功时立即返回。如果MSI-X失败，则尝试MSI。如果MSI-X和MSI都失败，则使用传统模式作为后备。驱动程序可以依赖于`pci_dev->msi_enabled`和`pci_dev->msix_enabled`来确定哪种模式成功。'
- en: '`PCI_IRQ_AFFINITY`: This allows affinity auto-assign. If set, `pci_alloc_irq_vectors()`
    will spread the interrupts around the available CPUs.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PCI_IRQ_AFFINITY`：这允许关联自动分配。如果设置，`pci_alloc_irq_vectors()`将在可用的CPU周围分配中断。'
- en: 'To get the Linux IRQ numbers to be passed to `request_irq()` and `free_irq()`,
    which corresponds to a vector, use the following function:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取要传递给`request_irq()`和`free_irq()`的Linux IRQ编号，对应于一个向量，请使用以下函数：
- en: '[PRE25]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding, `dev` is the PCI device to operate on, and `nr` is the device-relative
    interrupt vector index (0-based). Let''s now look at how this function works more
    closely:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述中，`dev`是要操作的PCI设备，`nr`是设备相关的中断向量索引（从0开始）。现在让我们更仔细地看看这个函数是如何工作的：
- en: '[PRE26]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding excerpt, we can see that MSI-X is the first attempt (`if (dev->msix_enabled)`).
    Additionally, the returned IRQ has nothing to do with the original `pci_dev->irq`
    preassigned at device probe time. But if MSI is enabled (`dev->msi_enabled` is
    true) instead, then this function will perform some sanity check and will return
    `dev->irq + nr`. This confirms the fact that `pci_dev->irq` is replaced with a
    new value when we operate in MSI mode, and that this new value corresponds to
    the base interrupt number of the allocated MSI vectors. Finally, you'll notice
    that there are no special checks for legacy mode.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述摘录中，我们可以看到MSI-X是第一次尝试（`if (dev->msix_enabled)`）。此外，返回的IRQ与设备探测时预分配的`pci_dev->irq`没有任何关系。但是如果启用了MSI（`dev->msi_enabled`为真），那么这个函数将执行一些合理性检查，并返回`dev->irq
    + nr`。这证实了在MSI模式下操作时，`pci_dev->irq`被替换为一个新值，这个新值对应于分配的MSI向量的基本中断编号。最后，您会注意到在传统模式下没有特殊检查。
- en: Actually, in legacy mode, the preassigned `pci_dev->irq` remains untouched,
    and it is only a single allocated vector. Thus, `nr` should be `0` when operating
    in legacy mode. In this case, the vector returned is nothing but `dev->irq`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在传统模式下，预分配的`pci_dev->irq`保持不变，只有一个分配的向量。因此，在传统模式下操作时，`nr`应该是`0`。在这种情况下，返回的向量什么都不是，只是`dev->irq`。
- en: 'Some devices might not support using legacy line interrupts, in which case
    the driver can specify that only MSI or MSI-X is acceptable:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 一些设备可能不支持使用传统线中断，这种情况下，驱动程序可以指定只接受MSI或MSI-X：
- en: '[PRE27]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Important note
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that MSI/MSI-X and legacy interrupts are mutually exclusive and the reference
    design supports legacy interrupts by default. Once MSI or MSI-X interrupts are
    enabled on a device, it stays in this mode until they are disabled again.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，MSI/MSI-X和传统中断是互斥的，参考设计默认支持传统中断。一旦在设备上启用了MSI或MSI-X中断，它将一直保持在这种模式，直到再次被禁用。
- en: Legacy INTx IRQ assignment
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 传统INTx IRQ分配
- en: 'The probe method of the PCI bus type (`struct bus_type pci_bus_type`) is `pci_device_probe()`,
    implemented in `drivers/pci/pci-driver.c`. This method is invoked each time a
    new PCI device is added to the bus or when a new PCI driver is registered with
    the system. This function calls `pci_assign_irq(pci_dev)` and then `pcibios_alloc_irq(pci_dev)`
    in order to assign an IRQ to the PCI device, the famous `pci_dev->irq`. The trick
    starts happening in `pci_assign_irq()`. `pci_assign_irq()` reads the pin to which
    the PCI device is connected, as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: PCI总线类型（`struct bus_type pci_bus_type`）的探测方法是`pci_device_probe()`，实现在`drivers/pci/pci-driver.c`中。每当新的PCI设备添加到总线上或者新的PCI驱动程序注册到系统时，都会调用这个方法。这个函数调用`pci_assign_irq(pci_dev)`，然后调用`pcibios_alloc_irq(pci_dev)`来为PCI设备分配一个IRQ，即著名的`pci_dev->irq`。技巧开始在`pci_assign_irq()`中发生。`pci_assign_irq()`读取PCI设备连接的引脚，如下：
- en: '[PRE28]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next steps rely on the PCI host bridge, whose driver should expose a number
    of callbacks, including a special one, `.map_irq`, whose purpose is to create
    IRQ mappings for devices according to their slot and the previously read pin:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤依赖于PCI主机桥，其驱动程序应该公开一些回调，包括一个特殊的回调`.map_irq`，其目的是根据设备的插槽和先前读取的引脚为设备创建IRQ映射：
- en: '[PRE29]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is the first assignment of the IRQ during the device probing. Going back
    to the `pci_device_probe()` function, the next method invoked after `pci_assign_irq()`
    is `pcibios_alloc_irq()`. However, `pcibios_alloc_irq()` is defined as a weak
    and empty function, overridden only by AArch64 architecture, in `arch/arm64/kernel/pci.c`,
    and which relies on ACPI (if enabled) to mangle the assigned IRQ. Perhaps in the
    feature other architecture will want to override this function as well.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设备探测期间IRQ的第一个分配。回到`pci_device_probe()`函数，`pci_assign_irq()`之后调用的下一个方法是`pcibios_alloc_irq()`。然而，`pcibios_alloc_irq()`被定义为一个弱函数，只有AArch64架构才覆盖，位于`arch/arm64/kernel/pci.c`中，并且依赖于ACPI（如果启用）来修改分配的IRQ。也许在未来其他架构也会想要覆盖这个函数。
- en: 'The final code of `pci_device_probe()` is the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`pci_device_probe()`的最终代码如下：'
- en: '[PRE30]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Important note
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The IRQ value contained in `PCI_INTERRUPT_LINE` is BAD until after `pci_enable_device()`
    is called. However, a peripheral driver should never alter `PCI_INTERRUPT_LINE`
    because it reflects how a PCI interrupt is connected to the interrupt controller,
    which is not changeable.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`PCI_INTERRUPT_LINE`中包含的IRQ值在调用`pci_enable_device()`之后才是有效的。但是，外围设备驱动程序不应该改变`PCI_INTERRUPT_LINE`，因为它反映了PCI中断如何连接到中断控制器，这是不可更改的。'
- en: Emulated INTx IRQ swizzling
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟INTx IRQ交换
- en: Note that most PCIe devices in legacy INTx mode will default to the local INTA
    "virtual wire output," and the same holds true for many physical PCI devices connected
    by PCIe/PCI bridges. OSes would end up sharing the INTA input among all the peripherals
    in the system; all devices sharing the same IRQ line – I will let you picture
    the disaster.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，大多数处于传统INTx模式的PCIe设备将默认为本地INTA“虚拟线输出”，对于许多通过PCIe/PCI桥连接的物理PCI设备也是如此。操作系统最终会在系统中的所有外围设备之间共享INTA输入；所有共享相同IRQ线的设备
    - 我会让你想象一下灾难。
- en: The solution to this is "virtual wire INTx IRQ swizzling." Back to the code
    of the `pci_device_probe()` function, it invokes `pci_assign_irq()`. If you look
    at the body of this function (in `drivers/pci/setup-irq.c`), you'll notice some
    swizzling operations, which are intended to solve this.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是“虚拟线INTx IRQ交换”。回到`pci_device_probe()`函数的代码，它调用了`pci_assign_irq()`。如果你看一下这个函数的主体部分（在`drivers/pci/setup-irq.c`中），你会注意到一些交换操作，这些操作旨在解决这个问题。
- en: Locking considerations
  id: totrans-319
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 锁定注意事项
- en: It is common for many device drivers to have a per-device spinlock that is taken
    in the interrupt handler. Since interrupts are guaranteed to be non-reentrant
    on a Linux-based system, it is not necessary to disable interrupts when you are
    working with pin-based interrupts or a single MSI. However, if a device uses multiple
    interrupts, the driver must disable interrupts while the lock is held. This would
    prevent deadlock if the device sends a different interrupt, whose handler will
    try to acquire the spinlock that is already locked by the interrupt being serviced.
    Thus, the locking primitives to use in such situations are `spin_lock_irqsave()`
    or `spin_lock_irq()`, which disable local interrupts and acquire the lock. You
    can refer to [*Chapter 1*](B10985_01_ePub_AM.xhtml#_idTextAnchor015)*, Linux Kernel
    concepts for Embedded Developers,* for more details on locking primitive and interrupt
    management.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 许多设备驱动程序通常有一个每设备自旋锁，在中断处理程序中会使用。由于在基于Linux的系统上中断是非可重入的，因此在使用基于引脚的中断或单个MSI时，不需要禁用中断。但是，如果设备使用多个中断，驱动程序必须在持有锁时禁用中断。这将防止死锁，如果设备发送不同的中断，其处理程序将尝试获取已被正在服务的中断锁定的自旋锁。因此，在这种情况下要使用的锁原语是`spin_lock_irqsave()`或`spin_lock_irq()`，它们会禁用本地中断并获取锁。您可以参考[*第1章*](B10985_01_ePub_AM.xhtml#_idTextAnchor015)*，嵌入式开发人员的Linux内核概念*，了解有关锁定原语和中断管理的更多详细信息。
- en: A word on legacy APIs
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关于传统API的说明
- en: There are many drivers that still use the old and now deprecated MSI or MSI-X
    APIs, which are `pci_enable_msi()`, `pci_disable_msi()`, `pci_enable_msix_range()`,
    `pci_enable_msix_exact()`, and `pci_disable_msix()`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有许多驱动程序使用旧的现在已弃用的MSI或MSI-X API，包括`pci_enable_msi()`、`pci_disable_msi()`、`pci_enable_msix_range()`、`pci_enable_msix_exact()`和`pci_disable_msix()`。
- en: 'The previously listed APIs should not be used in new code at all. However,
    the following is an example of a code excerpt trying to use MSI and falling back
    to legacy interrupt mode in case MSI is not available:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 前面列出的API在新代码中都不应该使用。然而，以下是一个尝试使用MSI并在MSI不可用时回退到传统中断模式的代码摘录的例子：
- en: '[PRE31]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Since the preceding code contains deprecated APIs, it may be a good exercise
    to convert it to new APIs.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的代码包含了已弃用的API，将其转换为新的API可能是一个很好的练习。
- en: Now that we are done with the generic PCI device driver structure and have addressed
    interrupt management in such drivers, we can move a step forward and leverage
    the direct memory access capabilities of the device.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了通用PCI设备驱动程序结构，并解决了这些驱动程序中的中断管理问题，我们可以向前迈进一步，利用设备的直接内存访问能力。
- en: PCI and Direct Memory Access (DMA)
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PCI和直接内存访问（DMA）
- en: In order to speed up data transfer and offload the CPU by allowing it not to
    perform heavy memory copy operations, both the controller and the device can be
    configured to perform Direct Memory Access (DMA), which is a means by which data
    is exchanged between device and host without the CPU being involved. Depending
    on the root complex, the PCI address space can be either 32 or 64 bits.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快数据传输速度并通过允许CPU不执行繁重的内存复制操作来卸载CPU负担，控制器和设备都可以配置为执行直接内存访问（DMA），这是一种在设备和主机之间交换数据而不涉及CPU的方式。根据根复杂性，PCI地址空间可以是32位或64位。
- en: 'System memory regions that are the source or destination of DMA transfers are
    called DMA buffers. However, DMA buffer memory ranges depend on the size of the
    bus address. This originated from the ISA bus, which was 24-bits wide. In such
    a bus, DMA buffers could live only in the bottom 16 MB of system memory. This
    bottom memory is also referred to as `ZONE_DMA`. However, PCI buses do not have
    such limitations. While the classic PCI bus supports 32-bit addressing, PCIe extended
    this to 64 bits. Thus, two different address formats can be used: the 32-bit address
    format and the 64-bit address format. In order to pull the DMA API, the driver
    should contain `#include <linux/dma-mapping.h>`.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 作为DMA传输的源或目的地的系统内存区域称为DMA缓冲区。但是，DMA缓冲区内存范围取决于总线地址的大小。这源自ISA总线，其宽度为24位。在这样的总线上，DMA缓冲区只能存在于系统内存的底部16MB。这个底部内存也被称为`ZONE_DMA`。但是，PCI总线没有这样的限制。经典PCI总线支持32位寻址，PCIe将其扩展到64位。因此，可以使用两种不同的地址格式：32位地址格式和64位地址格式。为了调用DMA
    API，驱动程序应包含`#include <linux/dma-mapping.h>`。
- en: 'To inform the kernel of any special needs of DMA-able buffers (which consist
    of specifying the width of the bus), you can use `dma_set_mask()`, defined as
    follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告知内核DMA可用缓冲区的任何特殊需求（包括指定总线宽度），可以使用`dma_set_mask()`，其定义如下：
- en: '[PRE32]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This would help the system in terms of efficient memory allocation, especially
    if the device can directly address "consistent memory" in system RAM above 4 GB
    physical RAM. In the above helper, `dev` is the underlying device for the PCI
    device, and `mask` is the actual mask to use, which you can specify by using the
    `DMA_BIT_MASK` macro along with the actual bus width. `dma_set_mask()` returns
    `0` on success. Any other value means an error occurred.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有助于系统在有效的内存分配方面，特别是如果设备可以直接寻址系统RAM中4GB以上的物理RAM中的“一致内存”。在上面的帮助程序中，`dev`是PCI设备的基础设备，`mask`是要使用的实际掩码，您可以使用`DMA_BIT_MASK`宏以及实际总线宽度来指定。`dma_set_mask()`在成功时返回`0`。任何其他值都表示发生了错误。
- en: 'The following is an example for a 32-bit (or 64-bit) bit system:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是32位（或64位）系统的示例：
- en: '[PRE33]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That being said, DMA transfer requires suitable memory mapping. This mapping
    consists of allocating DMA buffers and generating a bus address for each, which
    are of the type `dma_addr_t`. Since I/O devices view DMA buffers through the lens
    of the bus controller and any intervening I/O memory management unit (IOMMU),
    the resulting bus addresses will be given to the device in order for it to be
    notified of the location of the DMA buffers. Since each memory mapping also produces
    a virtual address, not only bus addresses but also virtual addresses will be generated
    for the mapping. In order for the CPU to be able to access the buffers, DMA service
    routines also map the kernel virtual address of DMA buffers to bus addresses.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，DMA传输需要合适的内存映射。这种映射包括分配DMA缓冲区并为每个生成总线地址，这些地址的类型是`dma_addr_t`。由于I/O设备通过总线控制器和任何中间I/O内存管理单元（IOMMU）查看DMA缓冲区，因此生成的总线地址将被提供给设备，以便通知其DMA缓冲区的位置。由于每个内存映射还会产生一个虚拟地址，因此不仅会生成总线地址，还会为映射生成虚拟地址。为了使CPU能够访问缓冲区，DMA服务例程还将DMA缓冲区的内核虚拟地址映射到总线地址。
- en: 'There are two types of (PCI) DMA mapping: coherent ones and streaming ones.
    For either, the kernel provides a healthy API that masks many of the internal
    details of dealing with the DMA controller.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种（PCI）DMA映射类型：连贯映射和流映射。对于任何一种，内核都提供了一个健壮的API，可以屏蔽许多处理DMA控制器的内部细节。
- en: PCI coherent (aka consistent) mapping
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PCI连贯（又称一致）映射
- en: Such mapping is called consistent because it allocates uncached (coherent) and
    unbuffered memory for the device to perform DMA operation. Since a write by either
    the device or the CPU can be immediately read by either without worrying about
    cache coherency, such mappings are also synchronous. All this makes consistent
    mapping too expensive for the system, although most devices require it. However,
    in terms of code, it is easier to implement.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这种映射被称为连贯，因为它为设备执行DMA操作分配了非缓存（连贯）和非缓冲内存。由于设备或CPU的写入可以立即被任一方读取，而不必担心缓存一致性，因此这种映射也是同步的。所有这些使得连贯映射对系统来说太昂贵，尽管大多数设备都需要它。但是，从代码的角度来看，它更容易实现。
- en: 'The following function sets up a coherent mapping:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数设置了一个连贯的映射：
- en: '[PRE34]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With the above, memory allocated for the mapping is guaranteed to be physically
    contiguous. `size` is the length of the region you need to allocate. This function
    returns two values: the virtual address that you can use to access it from the
    CPU and `dma_handle`, the third argument, which is an output parameter and which
    corresponds to the bus address the function call generated for the allocated region.
    The bus address is actually the one you pass to the PCI device.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述方法，为映射分配的内存保证是物理上连续的。`size`是您需要分配的区域的长度。此函数返回两个值：您可以用来从CPU访问它的虚拟地址和`dma_handle`，第三个参数，它是一个输出参数，对应于函数调用为分配的区域生成的总线地址。总线地址实际上是您传递给PCI设备的地址。
- en: Do note that `pci_alloc_consistent()` is actually a dumb wrapper of `dma_alloc_coherent()`
    with the `GFP_ATOMIC` flag set, meaning allocation does not sleep and it is safe
    to call it from within an atomic context. You may want to use `dma_alloc_coherent()`
    (which is strongly encouraged) instead if you wish to change the allocation flags,
    for example, using `GFP_KERNEL` instead of `GFP_ATOMIC`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`pci_alloc_consistent()`实际上是`dma_alloc_coherent()`的一个简单包装，设置了`GFP_ATOMIC`标志，这意味着分配不会休眠，并且可以安全地在原子上下文中调用它。如果您希望更改分配标志，例如使用`GFP_KERNEL`而不是`GFP_ATOMIC`，则可以使用`dma_alloc_coherent()`（强烈建议）。
- en: Keep in mind that mapping is expensive, and the minimum it can allocate is a
    page. Under the hood, it only allocates the number of pages in the power of 2\.
    The order of pages is obtained with `int order = get_order(size)`. Such a mapping
    is to be used for buffers that last the lifetime of the device.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，映射是昂贵的，它最少可以分配一页。在底层，它只分配2的幂次方的页数。页面的顺序是通过`int order = get_order(size)`获得的。这样的映射应该用于设备寿命的缓冲区。
- en: 'To unmap and free such a DMA region, you can call `pci_free_consistent()`:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消映射并释放这样的DMA区域，可以调用`pci_free_consistent()`：
- en: '[PRE35]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, `cpu_addr` and `dma_handle` correspond to the kernel virtual address and
    to the bus address returned by `pci_alloc_consistent()`. Though the mapping function
    can be called from an atomic context, this one may not be called in such a context.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`cpu_addr`和`dma_handle`对应于`pci_alloc_consistent()`返回的内核虚拟地址和总线地址。虽然映射函数可以从原子上下文中调用，但这个函数可能不能在这样的上下文中调用。
- en: 'Do also note that `pci_free_consistent()` is a simple wrapper of `dma_free_coherent()`,
    which can be used if the mapping has been done using `dma_alloc_coherent()`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`pci_free_consistent()`是`dma_free_coherent()`的一个简单包装，如果映射是使用`dma_alloc_coherent()`完成的，可以使用它：
- en: '[PRE36]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The preceding code shows how to perform a DMA mapping and send the resulting
    bus address to the device. In the real world, an interrupt may be raised. You
    should then handle it from within the driver.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了如何执行DMA映射并将结果总线地址发送到设备。在现实世界中，可能会引发中断。然后您应该在驱动程序中处理它。
- en: Streaming DMA mapping
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流式DMA映射
- en: Streaming mapping, on the other hand, has more constraints in terms of code.
    First of all, such mappings need to work with a buffer that has already been allocated.
    Additionally, a buffer that has been mapped belongs to the device and not to the
    CPU anymore. Thus, before the CPU can use the buffer, it should be unmapped first,
    in order to address possible caching issues.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，流式映射在代码方面有更多的约束。首先，这样的映射需要使用已经分配的缓冲区。此外，已经映射的缓冲区属于设备而不再属于CPU。因此，在CPU可以使用缓冲区之前，应该首先取消映射，以解决可能的缓存问题。
- en: If you need to initiate a write transaction (CPU to device), the driver should
    place data in the buffer prior to the mapping. Moreover, the direction the data
    should move into has to be specified, and the data should only be used based on
    this direction.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要启动写事务（CPU到设备），驱动程序应该在映射之前将数据放入缓冲区。此外，必须指定数据应该移动的方向，并且只能基于这个方向使用数据。
- en: The reason the buffers must be unmapped before they can be accessed by the CPU
    is because of the cache. It goes without saying that CPU mapping is cacheable.
    The `dma_map_*()` family functions (actually wrapped by `pci_map_*()` functions),
    which are used for streaming mappings, will first clean/invalidate the caches
    related to the buffers and will rely on the CPU not to access those buffers until
    the corresponding `dma_unmap_*()` (wrapped by `pci_unmap_*()` functions). Those
    unmappings will then invalidate (if necessary) the caches again, in case of any
    speculative fetches in the meantime, before the CPU may read any data written
    to memory by the device. Only at this time can the CPU access the buffers.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区在可以被CPU访问之前必须取消映射的原因是因为缓存。不用说CPU映射是可缓存的。`dma_map_*()`系列函数（实际上是由`pci_map_*()`函数包装）用于流式映射，将首先清除/使无效与缓冲区相关的缓存，并且依赖于CPU在相应的`dma_unmap_*()`（由`pci_unmap_*()`函数包装）之前不访问这些缓冲区。在此期间，这些取消映射将再次使缓存无效（如果有必要），以便CPU可以读取设备写入内存的任何数据之前的任何推测获取。只有在这个时候CPU才能访问这些缓冲区。
- en: 'There are streaming mappings that can accept several non-contiguous and scattered
    buffers. We can then enumerate two forms of streaming mapping:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 有流式映射可以接受多个非连续和分散的缓冲区。然后我们可以列举两种形式的流式映射：
- en: Single buffer mapping, which allows only single-page mapping
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单缓冲区映射，只允许单页映射
- en: Scatter/gather mapping, which allows the passing of several buffers (scattered
    over memory)
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分散/聚集映射，允许传递多个分散在内存中的缓冲区
- en: Each of them is introduced in the following sections.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 它们中的每一个在以下各节中介绍。
- en: Single buffer mapping
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单缓冲区映射
- en: 'This consists of mapping a single buffer. It is for occasional mapping. That
    being said, you can set up a single buffer with this:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括映射单个缓冲区。它是用于偶尔映射的。也就是说，您可以使用以下方法设置单个缓冲区：
- en: '[PRE37]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`direction` should be either `PCI_DMA_BIDIRECTION`, `PCI_DMA_TODEVICE`, `PCI_DMA_FROMDEVICE`,
    `or PCI_DMA_NONE`. `ptr` is the kernel virtual address of the buffer, and `dma_addr_t`
    is the returned bus address that can be sent to the device. You should make sure
    to use the direction that really matches the way data is intended to move, not
    just always `DMA_BIDIRECTIONAL`. `pci_map_single()` is a dumb wrapper of `dma_map_single()`,
    with the directions mapping to `DMA_TO_DEVICE`, `DMA_FROM_DEVICE`, or `DMA_BIDIRECTIONAL`.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`direction`应该是`PCI_DMA_BIDIRECTION`，`PCI_DMA_TODEVICE`，`PCI_DMA_FROMDEVICE`或`PCI_DMA_NONE`。`ptr`是缓冲区的内核虚拟地址，`dma_addr_t`是返回的总线地址，可以发送到设备。您应该确保使用真正匹配数据移动方式的方向，而不仅仅是`DMA_BIDIRECTIONAL`。`pci_map_single()`是`dma_map_single()`的一个简单包装，方向映射到`DMA_TO_DEVICE`，`DMA_FROM_DEVICE`或`DMA_BIDIRECTIONAL`。'
- en: 'You should free the mapping with the following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该使用以下方法释放映射：
- en: '[PRE38]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is a wrapper around `dma_unmap_single()`. `dma_addr` should be the same
    as the one returned by `pci_map_single()` (or the one returned by `dma_map_single()`
    in case you used it). `direction` and `size` should match what you have specified
    in the mapping.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`dma_unmap_single()`的一个包装。`dma_addr`应该与`pci_map_single()`返回的地址相同（或者如果您使用了`dma_map_single()`，则应该与其返回的地址相同）。`direction`和`size`应该与您在映射中指定的相匹配。
- en: 'The following shows a simplified example of streaming mapping (actually a single
    buffer):'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是流式映射的简化示例（实际上是单个缓冲区）：
- en: '[PRE39]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the preceding example, `buffer` is supposed to be already allocated and
    to contain the data. It is then mapped, its bus address is sent to the device,
    and the DMA operation is started. The next code sample (implemented as an interrupt
    handler for the DMA transaction) demonstrates how to deal with the buffer from
    the CPU side:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`buffer`应该已经被分配并包含数据。然后它被映射，其总线地址被发送到设备，并且DMA操作被启动。下一个代码示例（作为DMA事务的中断处理程序实现）演示了如何从CPU端处理缓冲区：
- en: '[PRE40]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding, the mapping is released before the CPU can play with the buffer.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，映射在CPU可以处理缓冲区之前被释放。
- en: Scatter/gather mapping
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 散射/聚集映射
- en: Scatter/gather mapping is the second family of streaming DMA mapping with which
    you can transfer several (not necessarily physically contiguous) buffer regions
    in a single shot instead of mapping each buffer individually and transferring
    them one by one. In order to set up a `scatterlist` mapping, you should allocate
    your scattered buffers first, which must be of page size, except the last one,
    which may have a different size. After this, you should allocate an array of `scatterlist`
    and fill it with the previously allocated buffers using `sg_set_buf()`. Finally,
    you must call `dma_map_sg()` on the `scatterlist` array. Once done with DMA, call
    `dma_unmap_sg()` on the array to unmap the `scatterlist` entries.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 散射/聚集映射是流式DMA映射的第二类，您可以在一次传输中传输多个（不一定是物理上连续的）缓冲区域，而不是分别映射每个缓冲区并逐个传输它们。为了设置`scatterlist`映射，您应该首先分配您的散射缓冲区，这些缓冲区必须是页面大小，除了最后一个可能有不同的大小。之后，您应该分配一个`scatterlist`数组，并使用`sg_set_buf()`将先前分配的缓冲区填充进去。最后，您必须在`scatterlist`数组上调用`dma_map_sg()`。完成DMA后，调用`dma_unmap_sg()`来取消映射`scatterlist`条目。
- en: 'While you can send contents of several buffers over DMA one by one by mapping
    each one of them, scatter/gather can send them all at once by sending the pointer
    to `scatterlist` to the device, along with a length, which is the number of entries
    in the list:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以通过映射每个缓冲区逐个发送多个缓冲区的内容，但是散射/聚集可以通过一次发送`scatterlist`指针以及一个长度（列表中的条目数）来一次发送它们。
- en: '[PRE41]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'First of all, do note that `pci_map_sg()` is a dumb wrapper of `dma_map_sg()`.
    In the preceding code, we used `sg_init_table()`, which results in a statically
    allocated table. We could have used `sg_alloc_table()` for a dynamic allocation.
    Moreover, we could have used the `for_each_sg()` macro, in order to loop over
    each `sg` (`sg_set_page()` helper in order to set the page to which this scatterlist
    is bound (you should never assign the page directly). The following is an example
    involving such helpers:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，`pci_map_sg()`是`dma_map_sg()`的一个简单包装。在前面的代码中，我们使用了`sg_init_table()`，这导致了一个静态分配的表。我们可以使用`sg_alloc_table()`进行动态分配。此外，我们可以使用`for_each_sg()`宏，以便循环遍历每个`sg`（使用`sg_set_page()`助手来设置此scatterlist绑定的页面（您不应该直接分配页面）。以下是涉及此类助手的示例：
- en: '[PRE42]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding block, pages should have been allocated and should obviously
    be of `PAGE_SIZE` size. `st` is an output parameter that will be set up appropriately
    on the success path of this function.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，页面应该已经被分配，并且显然应该是`PAGE_SIZE`大小。`st`是一个输出参数，在此函数的成功路径上将被适当设置。
- en: 'Again, note that scatterlist entries must be of page size (except the last
    entry, which may have a different size). For each buffer in the input scatterlist,
    `dma_map_sg()` determines the proper bus address to give to the device. The bus
    address and length of each buffer are stored in the struct scatterlist entries,
    but their location in the structure varies from one architecture to another. Thus,
    there are two macros that you can use to make your code portable:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，scatterlist条目必须是页面大小（除了最后一个条目可能有不同的大小）。对于输入scatterlist中的每个缓冲区，`dma_map_sg()`确定要给设备的适当总线地址。每个缓冲区的总线地址和长度存储在struct
    scatterlist条目中，但它们在结构中的位置因架构而异。因此，有两个宏可以用于使您的代码可移植：
- en: '`dma_addr_t sg_dma_address(struct scatterlist *sg)`: This returns the bus (DMA)
    address from this scatterlist entry.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dma_addr_t sg_dma_address(struct scatterlist *sg)`: 这返回此scatterlist条目的总线（DMA）地址。'
- en: '`unsigned int sg_dma_len(struct scatterlist *sg)`: This returns the length
    of this buffer.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsigned int sg_dma_len(struct scatterlist *sg)`: 这返回此缓冲区的长度。'
- en: '`dma_map_sg()` and `dma_unmap_sg()` take care of cache coherency. However,
    if you have to access (read/write) the data between the DMA transfers, the buffers
    must be synchronized between each transfer in an appropriate manner, by means
    of either `dma_sync_sg_for_cpu()` if the CPU needs to access the buffers, or `dma_sync_sg_for_device()`
    if it is the device that needs access. Similar functions for single region mapping
    are `dma_sync_single_for_cpu()` and `dma_sync_single_for_device()`.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`dma_map_sg()`和`dma_unmap_sg()`负责缓存一致性。但是，如果您必须在DMA传输之间访问（读/写）数据，则必须适当地在每次传输之间同步缓冲区，通过`dma_sync_sg_for_cpu()`（如果CPU需要访问缓冲区）或`dma_sync_sg_for_device()`（如果设备需要访问）来实现。单个区域映射的类似函数是`dma_sync_single_for_cpu()`和`dma_sync_single_for_device()`。'
- en: Given all of the above, we can conclude that coherent mappings are simple to
    code but expensive to use, whereas streaming mappings have the reverse characteristics.
    Streaming mapping is to be used when the I/O device owns the buffer for long durations.
    Streamed DMA is common for asynchronous operations when each DMA operates on a
    different buffer, such as network drivers, where each `skbuf` data is mapped and
    unmapped on the fly. However, the device may have the last word on what method
    you should use. That being said, if you had the choice, you should use streaming
    mapping when you can and coherent mapping when you must.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于上述所有内容，我们可以得出结论，一致映射编码简单但使用昂贵，而流式映射具有相反的特征。当I/O设备长时间拥有缓冲区时，应使用流式映射。流式DMA在异步操作中很常见，每个DMA在不同的缓冲区上操作，例如网络驱动程序，其中每个“skbuf”数据都是动态映射和取消映射的。然而，设备可能对你应该使用的方法有最后的决定权。也就是说，如果你有选择的话，应该在可以的时候使用流式映射，在必须的时候使用一致映射。
- en: Summary
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have dealt with PCI specification buses and implementations,
    as well as its support in the Linux kernel. We went through the enumeration process
    and how the Linux kernel allows different address spaces to be accessed. We then
    followed a detailed step-by-step guide on how to write a PCI device driver, from
    the device table population to the module's `exit` method. We took a deeper look
    at the interrupt mechanisms and their underlying behaviors as well as the differences
    between them. Now you are able to write a PCI device driver on your own, and you
    are familiar with their enumeration process. Moreover, you understand their interrupt
    mechanisms and are aware of the differences between them (MSI or not). Finally,
    you learned how to access their respective memory regions.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们处理了PCI规范总线和实现，以及它在Linux内核中的支持。我们经历了枚举过程以及Linux内核如何允许访问不同的地址空间。然后，我们详细介绍了如何编写PCI设备驱动程序的逐步指南，从设备表的填充到模块的“退出”方法。我们深入研究了中断机制及其基本行为以及它们之间的区别。现在你能够自己编写PCI设备驱动程序，并且熟悉它们的枚举过程。此外，你了解它们的中断机制，并且知道它们之间的区别（MSI或非MSI）。最后，你学会了如何访问它们各自的内存区域。
- en: In the next chapter, we will deal with the NVMEM framework, which helps to develop
    drivers for non-volatile storage devices such as EEPROM. This will serve to end
    the complexity that we have experienced so far while learning about PCI device
    drivers.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将处理NVMEM框架，该框架有助于开发用于EEPROM等非易失性存储设备的驱动程序。这将有助于结束我们在学习PCI设备驱动程序时迄今所经历的复杂性。
