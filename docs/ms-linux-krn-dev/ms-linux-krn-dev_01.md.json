["```\n#define PF_EXITING           /* getting shut down */\n#define PF_EXITPIDONE        /* pi exit done on shut down */\n#define PF_VCPU              /* I'm a virtual CPU */\n#define PF_WQ_WORKER         /* I'm a workqueue worker */\n#define PF_FORKNOEXEC        /* forked but didn't exec */\n#define PF_MCE_PROCESS       /* process policy on mce errors */\n#define PF_SUPERPRIV         /* used super-user privileges */\n#define PF_DUMPCORE          /* dumped core */\n#define PF_SIGNALED          /* killed by a signal */\n#define PF_MEMALLOC          /* Allocating memory */\n#define PF_NPROC_EXCEEDED    /* set_user noticed that RLIMIT_NPROC was exceeded */\n#define PF_USED_MATH         /* if unset the fpu must be initialized before use */\n#define PF_USED_ASYNC        /* used async_schedule*(), used by module init */\n#define PF_NOFREEZE          /* this thread should not be frozen */\n#define PF_FROZEN            /* frozen for system suspend */\n#define PF_FSTRANS           /* inside a filesystem transaction */\n#define PF_KSWAPD            /* I am kswapd */\n#define PF_MEMALLOC_NOIO0    /* Allocating memory without IO involved */\n#define PF_LESS_THROTTLE     /* Throttle me less: I clean memory */\n#define PF_KTHREAD           /* I am a kernel thread */\n#define PF_RANDOMIZE         /* randomize virtual address space */\n#define PF_SWAPWRITE         /* Allowed to write to swap */\n#define PF_NO_SETAFFINITY    /* Userland is not allowed to meddle with cpus_allowed */\n#define PF_MCE_EARLY         /* Early kill for mce process policy */\n#define PF_MUTEX_TESTER      /* Thread belongs to the rt mutex tester */\n#define PF_FREEZER_SKIP      /* Freezer should not count it as freezable */\n#define PF_SUSPEND_TASK      /* this thread called freeze_processes and should not be frozen */\n```", "```\n/*include/uapi/linux/resource.h*/\nstruct rlimit {\n  __kernel_ulong_t        rlim_cur;\n  __kernel_ulong_t        rlim_max;\n};\nThese limits are specified in *include/uapi/asm-generic/resource.h* \n #define RLIMIT_CPU        0       /* CPU time in sec */\n #define RLIMIT_FSIZE      1       /* Maximum filesize */\n #define RLIMIT_DATA       2       /* max data size */\n #define RLIMIT_STACK      3       /* max stack size */\n #define RLIMIT_CORE       4       /* max core file size */\n #ifndef RLIMIT_RSS\n # define RLIMIT_RSS       5       /* max resident set size */\n #endif\n #ifndef RLIMIT_NPROC\n # define RLIMIT_NPROC     6       /* max number of processes */\n #endif\n #ifndef RLIMIT_NOFILE\n # define RLIMIT_NOFILE    7       /* max number of open files */\n #endif\n #ifndef RLIMIT_MEMLOCK\n # define RLIMIT_MEMLOCK   8       /* max locked-in-memory   \n address space */\n #endif\n #ifndef RLIMIT_AS\n # define RLIMIT_AS        9       /* address space limit */\n #endif\n #define RLIMIT_LOCKS      10      /* maximum file locks held */\n #define RLIMIT_SIGPENDING 11      /* max number of pending signals */\n #define RLIMIT_MSGQUEUE   12      /* maximum bytes in POSIX mqueues */\n #define RLIMIT_NICE       13      /* max nice prio allowed to \n raise to 0-39 for nice level 19 .. -20 */\n #define RLIMIT_RTPRIO     14      /* maximum realtime priority */\n #define RLIMIT_RTTIME     15      /* timeout for RT tasks in us */\n #define RLIM_NLIMITS      16\n```", "```\n  /* arch/ia64/include/asm/current.h */\n  #ifndef _ASM_IA64_CURRENT_H\n  #define _ASM_IA64_CURRENT_H\n  /*\n  * Modified 1998-2000\n  *      David Mosberger-Tang <davidm@hpl.hp.com>, Hewlett-Packard Co\n  */\n  #include <asm/intrinsics.h>\n  /*\n  * In kernel mode, thread pointer (r13) is used to point to the \n    current task\n  * structure.\n  */\n #define current ((struct task_struct *) ia64_getreg(_IA64_REG_TP))\n #endif /* _ASM_IA64_CURRENT_H */\n /* arch/powerpc/include/asm/current.h */\n #ifndef _ASM_POWERPC_CURRENT_H\n #define _ASM_POWERPC_CURRENT_H\n #ifdef __KERNEL__\n /*\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n */\n struct task_struct;\n #ifdef __powerpc64__\n #include <linux/stddef.h>\n #include <asm/paca.h>\n static inline struct task_struct *get_current(void)\n {\n       struct task_struct *task;\n\n       __asm__ __volatile__(\"ld %0,%1(13)\"\n       : \"=r\" (task)\n       : \"i\" (offsetof(struct paca_struct, __current)));\n       return task;\n }\n #define current get_current()\n #else\n /*\n * We keep `current' in r2 for speed.\n */\n register struct task_struct *current asm (\"r2\");\n #endif\n #endif /* __KERNEL__ */\n #endif /* _ASM_POWERPC_CURRENT_H */\n```", "```\nstruct thread_info for x86 architecture (kernel 3.10):\n```", "```\n/* linux-3.10/arch/x86/include/asm/thread_info.h */ struct thread_info {\n struct task_struct *task; /* main task structure */\n struct exec_domain *exec_domain; /* execution domain */\n __u32 flags; /* low level flags */\n __u32 status; /* thread synchronous flags */\n __u32 cpu; /* current CPU */\n int preempt_count; /* 0 => preemptable, <0 => BUG */\n mm_segment_t addr_limit;\n struct restart_block restart_block;\n void __user *sysenter_return;\n #ifdef CONFIG_X86_32\n unsigned long previous_esp; /* ESP of the previous stack in case of   \n nested (IRQ) stacks */\n __u8 supervisor_stack[0];\n #endif\n unsigned int sig_on_uaccess_error:1;\n unsigned int uaccess_err:1; /* uaccess failed */\n};\n```", "```\n  #ifndef __ASM_GENERIC_CURRENT_H\n  #define __ASM_GENERIC_CURRENT_H\n  #include <linux/thread_info.h>\n\n    __attribute_const__;\n\n  static inline struct thread_info *current_thread_info(void)\n  {\n        **return (struct thread_info *)**  **                (current_stack_pointer & ~(THREAD_SIZE - 1));**\n  }\nPER_CPU variable:\n```", "```\n  #ifndef _ASM_X86_CURRENT_H\n  #define _ASM_X86_CURRENT_H\n\n  #include <linux/compiler.h>\n  #include <asm/percpu.h>\n\n  #ifndef __ASSEMBLY__\n  struct task_struct;\n\n  DECLARE_PER_CPU(struct task_struct *, current_task);\n\n  static __always_inline struct task_struct *get_current(void)\n  {\n          return this_cpu_read_stable(current_task);\n  }\n\n  #define current get_current()\n\n  #endif /* __ASSEMBLY__ */\n\n  #endif /* _ASM_X86_CURRENT_H */\nthread_info structure with just one element:\n```", "```\n/* linux-4.9.10/arch/x86/include/asm/thread_info.h */\nstruct thread_info {\n unsigned long flags; /* low level flags */\n};\n```", "```\n#include <unistd.h>\nint execve(const char *filename, char *const argv[],\nchar *const envp[]);\n```", "```\n#include <unistd.h>\nextern char **environ;\nint execl(const char *path, const char *arg, ...);\nint execlp(const char *file, const char *arg, ...);\nint execle(const char *path, const char *arg,\n..., char * const envp[]);\nint execv(const char *path, char *constargv[]);\nint execvp(const char *file, char *constargv[]);\nint execvpe(const char *file, char *const argv[],\nchar *const envp[]);\n```", "```\nint clone(int (*child_func)(void *), void *child_stack, int flags, void *arg);\n```", "```\n/*clone flags for creating threads*/\nflags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID;\n```", "```\n/* clone flags for forking child */\nflags = SIGCHLD;\n/* clone flags for vfork child */ \nflags = CLONE_VFORK | CLONE_VM | SIGCHLD;\n```", "```\nUID PID PPID C STIME TTY TIME CMD\nroot 1 0 0 22:43 ? 00:00:01 /sbin/init splash\nroot 2 0 0 22:43 ? 00:00:00 [kthreadd]\nroot 3 2 0 22:43 ? 00:00:00 [ksoftirqd/0]\nroot 4 2 0 22:43 ? 00:00:00 [kworker/0:0]\nroot 5 2 0 22:43 ? 00:00:00 [kworker/0:0H]\nroot 7 2 0 22:43 ? 00:00:01 [rcu_sched]\nroot 8 2 0 22:43 ? 00:00:00 [rcu_bh]\nroot 9 2 0 22:43 ? 00:00:00 [migration/0]\nroot 10 2 0 22:43 ? 00:00:00 [watchdog/0]\nroot 11 2 0 22:43 ? 00:00:00 [watchdog/1]\nroot 12 2 0 22:43 ? 00:00:00 [migration/1]\nroot 13 2 0 22:43 ? 00:00:00 [ksoftirqd/1]\nroot 15 2 0 22:43 ? 00:00:00 [kworker/1:0H]\nroot 16 2 0 22:43 ? 00:00:00 [watchdog/2]\nroot 17 2 0 22:43 ? 00:00:00 [migration/2]\nroot 18 2 0 22:43 ? 00:00:00 [ksoftirqd/2]\nroot 20 2 0 22:43 ? 00:00:00 [kworker/2:0H]\nroot 21 2 0 22:43 ? 00:00:00 [watchdog/3]\nroot 22 2 0 22:43 ? 00:00:00 [migration/3]\nroot 23 2 0 22:43 ? 00:00:00 [ksoftirqd/3]\nroot 25 2 0 22:43 ? 00:00:00 [kworker/3:0H]\nroot 26 2 0 22:43 ? 00:00:00 [kdevtmpfs]\n/*kthreadd creation code (init/main.c) */\nstatic noinline void __ref rest_init(void)\n{\n int pid;\n\n rcu_scheduler_starting();\n /*\n * We need to spawn init first so that it obtains pid 1, however\n * the init task will end up wanting to create kthreads, which, if\n * we schedule it before we create kthreadd, will OOPS.\n */\n kernel_thread(kernel_init, NULL, CLONE_FS);\n numa_default_policy();\n pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);\n rcu_read_lock();\n kthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);\n rcu_read_unlock();\n complete(&kthreadd_done);\n\n /*\n * The boot idle thread must execute schedule()\n * at least once to get things moving:\n */\n init_idle_bootup_task(current);\n schedule_preempt_disabled();\n /* Call into cpu_idle with preempt disabled */\n cpu_startup_entry(CPUHP_ONLINE);\n}\n```", "```\n/*kthreadd routine(kthread.c) */\nint kthreadd(void *unused)\n{\n struct task_struct *tsk = current;\n\n /* Setup a clean context for our children to inherit. */\n set_task_comm(tsk, \"kthreadd\");\n ignore_signals(tsk);\n set_cpus_allowed_ptr(tsk, cpu_all_mask);\n set_mems_allowed(node_states[N_MEMORY]);\n\n current->flags |= PF_NOFREEZE;\n\n for (;;) {\n set_current_state(TASK_INTERRUPTIBLE);\n if (list_empty(&kthread_create_list))\n schedule();\n __set_current_state(TASK_RUNNING);\n\n spin_lock(&kthread_create_lock);\n while (!list_empty(&kthread_create_list)) {\n struct kthread_create_info *create;\n\n create = list_entry(kthread_create_list.next,\n struct kthread_create_info, list);\n list_del_init(&create->list);\n spin_unlock(&kthread_create_lock);\n\n create_kthread(create); /* creates kernel threads with attributes enqueued */\n\n spin_lock(&kthread_create_lock);\n }\n spin_unlock(&kthread_create_lock);\n }\n\n return 0;\n}\nkthread_create invoking kthread_create_on_node(), which by default creates threads on the current Numa node:\n```", "```\nstruct task_struct *kthread_create_on_node(int (*threadfn)(void *data),\n void *data,\n int node,\n const char namefmt[], ...);\n\n/**\n * kthread_create - create a kthread on the current node\n * @threadfn: the function to run in the thread\n * @data: data pointer for @threadfn()\n * @namefmt: printf-style format string for the thread name\n * @...: arguments for @namefmt.\n *\n * This macro will create a kthread on the current node, leaving it in\n * the stopped state. This is just a helper for       \n * kthread_create_on_node();\n * see the documentation there for more details.\n */\n#define kthread_create(threadfn, data, namefmt, arg...) \n kthread_create_on_node(threadfn, data, NUMA_NO_NODE, namefmt, ##arg)\n\nstruct task_struct *kthread_create_on_cpu(int (*threadfn)(void *data),\n void *data,\n unsigned int cpu,\n const char *namefmt);\n\n/**\n * kthread_run - create and wake a thread.\n * @threadfn: the function to run until signal_pending(current).\n * @data: data ptr for @threadfn.\n * @namefmt: printf-style name for the thread.\n *\n * Description: Convenient wrapper for kthread_create() followed by\n * wake_up_process(). Returns the kthread or ERR_PTR(-ENOMEM).\n */\n#define kthread_run(threadfn, data, namefmt, ...) \n({ \n struct task_struct *__k \n = kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \n if (!IS_ERR(__k)) \n wake_up_process(__k); \n __k; \n})\n```", "```\n/* kernel/kthread.c */\nstatic struct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n void *data, int node,\n const char namefmt[],\n va_list args)\n{\n DECLARE_COMPLETION_ONSTACK(done);\n struct task_struct *task;\n struct kthread_create_info *create = kmalloc(sizeof(*create),\n GFP_KERNEL);\n\n if (!create)\n return ERR_PTR(-ENOMEM);\n create->threadfn = threadfn;\n create->data = data;\n create->node = node;\n create->done = &done;\n\n spin_lock(&kthread_create_lock);\n list_add_tail(&create->list, &kthread_create_list);\n spin_unlock(&kthread_create_lock);\n\n wake_up_process(kthreadd_task);\n /*\n * Wait for completion in killable state, for I might be chosen by\n * the OOM killer while kthreadd is trying to allocate memory for\n * new kernel thread.\n */\n if (unlikely(wait_for_completion_killable(&done))) {\n /*\n * If I was SIGKILLed before kthreadd (or new kernel thread)\n * calls complete(), leave the cleanup of this structure to\n * that thread.\n */\n if (xchg(&create->done, NULL))\n return ERR_PTR(-EINTR);\n /*\n * kthreadd (or new kernel thread) will call complete()\n * shortly.\n */\n wait_for_completion(&done); // wakeup on completion of thread creation.\n }\n...\n...\n...\n}\n\nstruct task_struct *kthread_create_on_node(int (*threadfn)(void *data),\n void *data, int node,\n const char namefmt[],\n ...)\n{\n struct task_struct *task;\n va_list args;\n\n va_start(args, namefmt);\n task = __kthread_create_on_node(threadfn, data, node, namefmt, args);\n va_end(args);\n\n return task;\n}\n```", "```\n/* kernel/kthread.c */\nstatic void create_kthread(struct kthread_create_info *create)\n{\n int pid;\n\n #ifdef CONFIG_NUMA\n current->pref_node_fork = create->node;\n #endif\n\n /* We want our own signal handler (we take no signals by default). */\n pid = kernel_thread(kthread, create, CLONE_FS | CLONE_FILES |  \n SIGCHLD);\n if (pid < 0) {\n /* If user was SIGKILLed, I release the structure. */\n struct completion *done = xchg(&create->done, NULL);\n\n if (!done) {\n kfree(create);\n return;\n }\n create->result = ERR_PTR(pid);\n complete(done); /* signal completion of thread creation */\n }\n}\n```", "```\n/* kernel/fork.c */\n/*\n * Create a kernel thread.\n */\n```", "```\npid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)\n{\n return _do_fork(flags|CLONE_VM|CLONE_UNTRACED, (unsigned long)fn,\n (unsigned long)arg, NULL, NULL, 0);\n}\n\n/* sys_fork: create a child process by duplicating caller */\nSYSCALL_DEFINE0(fork)\n{\n#ifdef CONFIG_MMU\n return _do_fork(SIGCHLD, 0, 0, NULL, NULL, 0);\n#else\n /* cannot support in nommu mode */\n return -EINVAL;\n#endif\n}\n\n/* sys_vfork: create vfork child process */\nSYSCALL_DEFINE0(vfork)\n{\n return _do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, 0,\n 0, NULL, NULL, 0);\n}\n\n/* sys_clone: create child process as per clone flags */\n\n#ifdef __ARCH_WANT_SYS_CLONE\n#ifdef CONFIG_CLONE_BACKWARDS\nSYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,\n int __user *, parent_tidptr,\n unsigned long, tls,\n int __user *, child_tidptr)\n#elif defined(CONFIG_CLONE_BACKWARDS2)\nSYSCALL_DEFINE5(clone, unsigned long, newsp, unsigned long, clone_flags,\n int __user *, parent_tidptr,\n int __user *, child_tidptr,\n unsigned long, tls)\n#elif defined(CONFIG_CLONE_BACKWARDS3)\nSYSCALL_DEFINE6(clone, unsigned long, clone_flags, unsigned long, newsp,\n int, stack_size,\n int __user *, parent_tidptr,\n int __user *, child_tidptr,\n unsigned long, tls)\n#else\nSYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,\n int __user *, parent_tidptr,\n int __user *, child_tidptr,\n unsigned long, tls)\n#endif\n{\n return _do_fork(clone_flags, newsp, 0, parent_tidptr, child_tidptr, tls);\n}\n#endif\n\n```", "```\n#include <sys/types.h>\n#include <sys/wait.h>\npid_t wait(int *status);\npid_t waitpid(pid_t pid, int *status, intoptions);\nint waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options)\n```", "```\nclone(2)\nThe clone(2) system call creates a new process. If the flags argument of the call specifies one or more of the CLONE_NEW* flags listed below, then new namespaces are created for each flag, and the child process is made a member of those namespaces.(This system call also implements a number of features unrelated to namespaces.)\n\nsetns(2)\nThe setns(2) system call allows the calling process to join an existing namespace. The namespace to join is specified via a file descriptor that refers to one of the /proc/[pid]/ns files described below.\n\nunshare(2)\nThe unshare(2) system call moves the calling process to a new namespace. If the flags argument of the call specifies one or more of the CLONE_NEW* flags listed below, then new namespaces are created for each flag, and the calling process is made a member of those namespaces. (This system call also implements a number of features unrelated to namespaces.)\nNamespace   Constant          Isolates\nCgroup      CLONE_NEWCGROUP   Cgroup root directory\nIPC         CLONE_NEWIPC      System V IPC, POSIX message queues\nNetwork     CLONE_NEWNET      Network devices, stacks, ports, etc.\nMount       CLONE_NEWNS       Mount points\nPID         CLONE_NEWPID      Process IDs\nUser        CLONE_NEWUSER     User and group IDs\nUTS         CLONE_NEWUTS      Hostname and NIS domain name\n```"]