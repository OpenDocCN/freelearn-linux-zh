- en: Chapter 4. Troubleshooting Performance Issues
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。故障排除性能问题
- en: In [Chapter 3](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 3. Troubleshooting a Web Application"), *Troubleshooting a Web Application*
    we walked through troubleshooting a web application problem by using the troubleshooting
    methodology covered in [Chapter 1](part0014_split_000.html#DB7S1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 1. Troubleshooting Best Practices"), *Troubleshooting Best Practices*.
    We also used several of the fundamental troubleshooting commands and resources
    found in [Chapter 2](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 2. Troubleshooting Commands and Sources of Useful Information"), *Troubleshooting
    Commands and Sources of Useful Information*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4"第3章。故障排除Web应用程序")中，我们通过使用[第1章](part0014_split_000.html#DB7S1-8ae10833f0c4428b9e1482c7fee089b4"第1章。故障排除最佳实践")中介绍的故障排除方法论，以及[第2章](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4"第2章。故障排除命令和有用信息来源")中找到的几个基本故障排除命令和资源，来解决了Web应用程序的问题。
- en: Performance issues
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能问题
- en: For this chapter, we will continue the scenario that we covered in [Chapter
    3](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4 "Chapter 3. Troubleshooting
    a Web Application"), *Troubleshooting a Web Application*, where we are a new systems
    administrator at a new company. As we arrive to start our day, a fellow systems
    administrator asks us to look into a server being "slow."
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续在[第3章](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4"第3章。故障排除Web应用程序")中涵盖的情景，我们是一家新公司的新系统管理员。当我们到达开始我们的一天时，一位同事要求我们调查一个服务器变慢的问题。
- en: When asked for details, the only information our colleague could provide was
    the hostname and the IP of the server deemed "slow." Our peer mentioned that a
    user reported it and that the user did not provide many details.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在要求详细信息时，我们的同事只能提供主机名和被认为“慢”的服务器的IP。我们的同行提到一个用户报告了这个问题，而用户并没有提供太多细节。
- en: In this scenario, unlike in the scenario discussed in [Chapter 3](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 3. Troubleshooting a Web Application"), *Troubleshooting a Web Application*
    we don't have much information to begin with. It also seems that we are not able
    to ask the user troubleshooting questions. It is not uncommon as a systems administrator
    to be required to troubleshoot an issue with very little information. In fact,
    this type of scenario is quite common.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，与[第3章](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4"第3章。故障排除Web应用程序")中讨论的情况不同，我们没有太多信息可以开始。似乎我们也无法向用户提出故障排除问题。作为系统管理员，需要用很少的信息来排除问题并不罕见。事实上，这种类型的情况非常普遍。
- en: It's slow
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它很慢
- en: '"It''s slow" is problematic to troubleshoot. The biggest problem with a complaint
    about a server or service being slow is that "slow" is relative to the user experiencing
    the issue.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: “它很慢”很难排除故障。关于服务器或服务变慢的投诉最大的问题是，“慢”是相对于遇到问题的用户而言的。
- en: An important distinction to understand when dealing with any complaint about
    performance is the benchmark that the environment has been designed for. In some
    environments, a system running at 30% CPU utilization could be a business-as-usual
    activity, whereas the other environments may keep their systems running at 10%
    CPU utilization and a spike of 30% utilization would signal an issue.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理任何关于性能的投诉时，重要的区别是环境设计的基准。在某些环境中，系统以30%的CPU利用率运行可能是一种常规活动，而其他环境可能会保持系统以10%的CPU利用率运行，30%的利用率会表示问题。
- en: While troubleshooting and investigating performance issues, it is important
    to look back at the historical performance metrics of the system to ensure that
    you have context around the measurements being collected. This will assist in
    determining whether the current system utilization is expected or abnormal.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在排除故障和调查性能问题时，重要的是回顾系统的历史性能指标，以确保您对收集到的测量值有上下文。这将有助于确定当前系统利用率是否符合预期或异常。
- en: Performance
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能
- en: 'In general, performance issues can be categorized into five areas:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，性能问题可以分为五个领域：
- en: Application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序
- en: CPU
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU
- en: Memory
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存
- en: Disk
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘
- en: Network
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络
- en: A bottleneck in any one area can often affect other areas as well; therefore,
    it is a good idea to understand each of these topics. By understanding how each
    of these resources is accessed and interacts, you will be able to find the root
    cause of issues that consume multiple resources.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一个领域的瓶颈通常也会影响其他领域；因此，了解每个领域是一个好主意。通过了解如何访问和交互每个资源，您将能够找到消耗多个资源的问题的根本原因。
- en: Since the issue being reported did not include any details of the performance
    issue, we will explore and learn about each of these areas. Once complete, we
    will look at the data collected and look at historical statistics to determine
    whether the performance is as expected or whether the system performance really
    is degraded.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于报告的问题没有包括任何性能问题的细节，我们将探索和了解每个领域。完成后，我们将查看收集的数据并查看历史统计数据，以确定性能是否符合预期，或者系统性能是否真的下降了。
- en: Application
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序
- en: While creating a list of performance categories, I ordered them by areas that
    I see most often. Every environment is different, but in my experience, the application
    can often be a primary source of performance issues.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建性能类别列表时，我按照我经常看到的领域进行了排序。每个环境都是不同的，但根据我的经验，应用程序通常是性能问题的主要来源。
- en: While this chapter is designed to cover performance issues, [Chapter 9](part0061_split_000.html#1Q5IA1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 9. Using System Tools to Troubleshoot Applications"), *Using System Tools
    to Troubleshoot Applications* is dedicated to using system tools for troubleshooting
    application issues, including performance issues. For this chapter, we will assume
    that our issue is not application related and focus specifically on system performance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章旨在涵盖性能问题，[第9章](part0061_split_000.html#1Q5IA1-8ae10833f0c4428b9e1482c7fee089b4
    "第9章。使用系统工具排除应用程序")，“使用系统工具排除应用程序”专门讨论了使用系统工具排除应用程序问题，包括性能问题。在本章中，我们将假设我们的问题与应用程序无关，并专注于系统性能。
- en: CPU
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU
- en: CPU is a very common performance bottleneck. Sometimes, issues are strictly
    CPU-based, and at other times, there are instances where an increase in CPU usage
    is a symptom of another issue.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: CPU是一个非常常见的性能瓶颈。有时，问题严格基于CPU，而其他时候，增加的CPU使用率是另一个问题的症状。
- en: The most common command to investigate CPU utilization is the top command. The
    primary role of this command is to identify the CPU utilization of the processes.
    In [Chapter 2](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 2. Troubleshooting Commands and Sources of Useful Information"), *Troubleshooting
    Commands and Sources of Useful Information* we discussed utilizing the `ps` command
    for this type of activity. In this section, we are going to investigate our slowness
    complaint by using both top and ps to investigate our CPU utilization.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 调查CPU利用率最常见的命令是top命令。这个命令的主要作用是识别进程的CPU利用率。在[第2章](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4
    "第2章。故障排除命令和有用信息的来源")，“故障排除命令和有用信息的来源”中，我们讨论了使用`ps`命令进行这种活动。在本节中，我们将使用top和ps来调查CPU利用率，以解决我们的速度慢的问题。
- en: Top – a single command to look at everything
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Top – 查看所有内容的单个命令
- en: The **top** command is one of the first commands that both systems administrators
    and users run to look at the overall system performance. The reason for this is
    that top shows not only a breakdown of Load Average, CPU, and memory, but it also
    shows a sorted list of processes utilizing these resources.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`top`命令是系统管理员和用户运行的第一批命令之一，用于查看整体系统性能。原因在于top不仅显示了负载平均值、CPU和内存的详细情况，还显示了利用这些资源的进程的排序列表。'
- en: The best part of `top` is the fact that when run without any flags, these details
    are updated every 3 seconds.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`top`最好的部分是，当不带任何标志运行时，这些详细信息每3秒更新一次。'
- en: The following is an example of the `top` output when run without any flags.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是不带任何标志运行时`top`输出的示例。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There is quite a bit of information displayed with just the default output of
    `top`. For this section, we will focus solely on the CPU utilization information.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`top`的默认输出中显示了相当多的信息。在本节中，我们将专注于CPU利用率信息。'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the first section of the `top` command''s output, there is a single line
    that shows a breakdown of the current CPU utilization. Each item in this list
    represents a different way in which the CPU is being used. To understand the output
    better, let''s take a look at what each of these values mean:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`top`命令输出的第一部分显示了当前CPU利用率的详细情况。列表中的每一项代表了CPU的不同使用方式。为了更好地理解输出结果，让我们来看看每个数值的含义：'
- en: '**us – User**: This number is the percentage of CPU being consumed by the processes
    in the user mode. In this mode, applications are not able to access the underlying
    hardware and are required to use system APIs (a.k.a system calls) to perform privileged
    executions. When executing these system calls, the execution will be part of the
    system CPU utilization.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**us – User**：这个数字表示用户模式中进程所消耗的CPU百分比。在这种模式下，应用程序无法访问底层硬件，必须使用系统API（也称为系统调用）来执行特权操作。在执行这些系统调用时，执行将成为系统CPU利用率的一部分。'
- en: '**sy – System**: This number is the percentage of CPU being consumed by kernel
    mode execution. In this mode, systems can directly access the underlying hardware;
    this mode is generally reserved for trusted OS processes.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sy – System**：这个数字表示内核模式执行所消耗的CPU百分比。在这种模式下，系统可以直接访问底层硬件；这种模式通常保留给受信任的操作系统进程。'
- en: '**ni – Nice user processes**: This number is the percentage of CPU time being
    consumed by user processes that have had a nice value set. The `us%` value is
    specifically for processes that have not had their niceness values modified from
    the original value.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ni – Nice user processes**：这个数字表示由设置了nice值的用户进程所消耗的CPU时间百分比。`us%`值特指那些未修改过niceness值的进程。'
- en: '**id – Idle**: This number is the percentage of CPU time spent being idle.
    Essentially, it is the amount of CPU time spent not being utilized.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**id – Idle**：这个数字表示CPU空闲的时间百分比。基本上，它是CPU未被利用的时间。'
- en: '**wa – Wait**: This number is the percentage of CPU time spent waiting. This
    is typically high when many processes are waiting for I/O devices. I/O wait states
    do not just refer to hard disks, but rather to all I/O devices including hard
    disks.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wa – Wait**：这个数字表示CPU等待的时间百分比。当有很多进程在等待I/O设备时，这个值通常很高。I/O等待状态不仅指硬盘，而是指所有I/O设备，包括硬盘。'
- en: '**hi – Hardware interrupts**: This number is the percentage of CPU time being
    consumed by hardware interrupts. Hardware interrupts are signals from system hardware,
    such as hard drives or network devices, that are sent to the CPU. These interrupts
    signal that there are events that require CPU time.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hi – Hardware interrupts**：这个数字表示由硬件中断所消耗的CPU时间百分比。硬件中断是来自系统硬件（如硬盘或网络设备）的信号，发送给CPU。这些中断表示有事件需要CPU时间。'
- en: '**si – Software interrupts**: This number is the percentage of CPU time being
    consumed by software interrupts. Software interrupts are similar to hardware interrupts;
    however, they are triggered by a signal sent by the running processes to the kernel.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**si - 软件中断**：这个数字是被软件中断消耗的CPU时间的百分比。软件中断类似于硬件中断；但是，它们是由运行进程发送给内核的信号触发的。'
- en: '**st – Stolen**: This number specifically applies to Linux systems running
    as a virtual machine. This number is the percentage of CPU time stolen from this
    machine by the host. This number is usually present when the host machine itself
    is running into CPU contention. This can also happen in some cloud environments
    as a method of enforcing resource limitations.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**st - 被窃取**：这个数字特别适用于作为虚拟机运行的Linux系统。这个数字是被主机从这台机器上窃取的CPU时间的百分比。当主机机器本身遇到CPU争用时，通常会出现这种情况。在一些云环境中，这也可能发生，作为强制执行资源限制的一种方法。'
- en: Earlier I mentioned that the output from `top` is refreshed every 3 seconds
    by default. The CPU percentage line is also refreshed every 3 seconds; `top` will
    display the percentage of CPU time in each state since the last refresh interval.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到`top`的输出默认每3秒刷新一次。CPU百分比行也每3秒刷新一次；`top`将显示自上次刷新间隔以来每个状态的CPU时间百分比。
- en: What does this output tell us about our issue?
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 这个输出告诉我们关于我们的问题的什么？
- en: If we review the previous `top` command's output, we can determine quite a bit
    about this system.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾之前`top`命令的输出，我们可以对这个系统了解很多。
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From the preceding output, we can see that `37.3%` of the CPU time was being
    consumed by processes in the user mode. Another `0.7%` of the CPU time was used
    by processes in the kernel execution mode; this is based on the `us` and `sy`
    values. The `id` value tells us that the rest of the CPU was not utilized, meaning
    that overall, there is ample CPU available on this server.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到CPU时间的`37.3%`被用户模式下的进程消耗。另外`0.7%`的CPU时间被内核执行模式下的进程使用；这是基于`us`和`sy`的值。`id`值告诉我们剩下的CPU没有被利用，这意味着总体上，这台服务器上有充足的CPU可用。
- en: Another fact that the `top` command shows is the lack of CPU time being spent
    waiting for I/O. We can see this from the `wa` value being `0.0`. This is important
    as it tells us the performance issue that was reported is not likely due to high
    I/O. Later in this chapter, as we start exploring disk performance, we will explore
    I/O wait in depth.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`top`命令显示的另一个事实是CPU时间没有花在等待I/O上。我们可以从`wa`值为`0.0`看出。这很重要，因为它告诉我们报告的性能问题不太可能是由于高I/O。在本章后面，当我们开始探索磁盘性能时，我们将深入探讨I/O等待。'
- en: Individual processes from top
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 来自top的单个进程
- en: The CPU line in `top` commands output is a summary for the server as a whole,
    but top also includes CPU utilization for individual processes. To get a clearer
    focus, we can execute top again, but this time, let's focus on the `top` running
    processes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`top`命令输出中的CPU行是整个服务器的摘要，但top还包括单个进程的CPU利用率。为了更清晰地聚焦，我们可以再次执行top，但这次，让我们专注于正在运行的`top`进程。'
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This time when executing the `top` command, the `–n` (number) flag was used.
    This flag tells `top` to only refresh for a specified number of times, in this
    case 1 time. This trick can be helpful when trying to capture the output of `top`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这次执行`top`命令时，使用了`-n`（数字）标志。这个标志告诉`top`只刷新指定次数，这里是1次。在尝试捕获`top`的输出时，这个技巧可能会有所帮助。
- en: If we review the output of the above `top` command, we can see something quite
    interesting.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾上面`top`命令的输出，我们会看到一些非常有趣的东西。
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By default, the `top` command orders the processes by the percentage of CPU
    utilized by the processes. This means that the first process in the list is the
    process consuming the most amount of CPU in that interval.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`top`命令按照进程利用的CPU百分比对进程进行排序。这意味着列表中的第一个进程是在该时间间隔内消耗CPU最多的进程。
- en: If we look at the top process running under the process id of `3001`, we find
    that it is using `98.4%` of the CPU time. However, according to the top commands
    system-wide CPU statistics, `65.1%` of the CPU time is spent in an idle state.
    This type of scenario is actually a common source of confusion for many systems
    administrators.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下进程ID为`3001`的顶部进程，我们会发现它正在使用CPU时间的`98.4%`。然而，根据top命令的系统范围CPU统计数据，CPU时间的`65.1%`处于空闲状态。这种情况实际上是许多系统管理员困惑的常见原因。
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How can a single process be utilizing almost 100% of the CPU time, while the
    system itself is showing 65% of the CPU time is spent idle? The answer turns out
    to be simple; when `top` displays the CPU utilization in its header, the scale
    is based on the system as a whole. With individual processes, however, the CPU
    utilization scale is for one CPU. This means that our process 3001 is actually
    utilizing almost one full CPU and that our system most likely has multiple CPUs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单个进程如何使用几乎100%的CPU时间，而系统本身显示CPU时间的65%是空闲的？答案其实很简单；当`top`在其标题中显示CPU利用率时，比例是基于整个系统的。然而，对于单个进程，CPU利用率的比例是针对一个CPU的。这意味着我们的进程3001实际上几乎使用了一个完整的CPU，而我们的系统很可能有多个CPU。
- en: It is quite common to see processes that are able to utilize multiple CPUs show
    a percentage higher than 100%. For example, a process that is fully utilizing
    three CPUs would show 300%. This can also cause quite a bit of confusion for users
    unfamiliar with the difference of `top` commands server total and per-process
    output.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会看到能够利用多个CPU的进程显示的百分比高于100%。例如，完全利用三个CPU的进程将显示300%。这也可能会让不熟悉`top`命令服务器总体和每个进程输出差异的用户感到困惑。
- en: Determining the number of CPUs available
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定可用CPU数量
- en: Previously, we determined that this system must have multiple CPUs available.
    What we did not determine is how many. The easiest method to determine the number
    of CPUs available is to simply read the `/proc/cpuinfo` file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 先前，我们确定了这个系统必须有多个可用的CPU。我们没有确定的是有多少个。确定可用CPU数量的最简单方法是简单地读取`/proc/cpuinfo`文件。
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `/proc/cpuinfo` file contains quite a bit of useful information about the
    CPUs available to our system. It shows the type of CPU down to the model, what
    flags are available, the speed of the CPU, and, most importantly, the number of
    CPUs available.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc/cpuinfo`文件包含了关于系统可用CPU的大量有用信息。它显示了CPU的类型到型号，可用的标志，CPU的速度，最重要的是可用的CPU数量。'
- en: Every CPU available to the system will be listed in the `cpuinfo` file. This
    means that you can simply count the number of processors available in the `cpuinfo`
    file to determine the number of CPUs available to a server.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中每个可用的CPU都将在`cpuinfo`文件中列出。这意味着您可以简单地在`cpuinfo`文件中计算处理器的数量，以确定服务器可用的CPU数量。
- en: From the above example, we can determine that this server has 2 CPUs available.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的例子中，我们可以确定这台服务器有2个可用的CPU。
- en: Threads and Cores
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 线程和核心
- en: An interesting caveat with using `cpuinfo` to determine whether the number of
    CPUs available is that the details are a bit misleading when working with CPUs
    that have multiple cores and are hyper-threaded. The `cpuinfo` file reports both
    a core and a thread on the CPU as a processor that it can utilize. This means
    that even though you may have one physical chip installed on your system, if that
    chip was a four-core hyper-threaded CPU, the `cpuinfo` file would display eight
    processors.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cpuinfo`来确定可用CPU数量的一个有趣的注意事项是，当使用具有多个核心并且是超线程的CPU时，细节有点误导。`cpuinfo`文件将CPU上的核心和线程都报告为它可以利用的处理器。这意味着即使您的系统上安装了一个物理芯片，如果该芯片是一个四核超线程CPU，`cpuinfo`文件将显示八个处理器。
- en: lscpu – Another way to look at CPU info
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: lscpu – 查看CPU信息的另一种方法
- en: While `/proc/cpuinfo` is a method that many admins and users use to determine
    CPU information; on RHEL-based distributions, there is another command that will
    display this info as well.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`/proc/cpuinfo`是许多管理员和用户用来确定CPU信息的方法；在基于RHEL的发行版上，还有另一条命令也会显示这些信息。
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A difference between the contents of `/proc/cpuinfo` and the `lscpu` command
    is that `lscpu` makes it very easy to identify the number of cores, sockets, and
    threads. It can often be a bit difficult to identify this same information from
    the `/proc/cpuinfo` file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc/cpuinfo`和`lscpu`命令之间的一个区别是，`lscpu`使得很容易识别核心、插槽和线程的数量。从`/proc/cpuinfo`文件中识别这些信息通常会有点困难。'
- en: ps – Drill down deeper on individual processes with ps
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ps – 通过ps更深入地查看单个进程
- en: While the `top` command can be used to look at individual processes, I personally
    feel that the `ps` command is better-suited for investigating running processes.
    In [Chapter 2](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 2. Troubleshooting Commands and Sources of Useful Information"), *Troubleshooting
    Commands and Sources of Useful Information* we covered the `ps` command and how
    it can be used to look at many different aspects of a running process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`top`命令可以用来查看单个进程，但我个人认为`ps`命令更适合用于调查运行中的进程。在[第2章](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4
    "第2章。故障排除命令和有用信息来源")中，我们介绍了`ps`命令以及它如何用于查看运行进程的许多不同方面。
- en: In this chapter, we will use the `ps` command to take a deeper look at process
    `3001` that we identified with the `top` command as the process utilizing the
    most CPU time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`ps`命令更深入地查看我们用`top`命令确定为利用最多CPU时间的进程`3001`。
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In [Chapter 2](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 2. Troubleshooting Commands and Sources of Useful Information"), *Troubleshooting
    Commands and Sources of Useful Information* we discussed using the `ps` command
    to display running processes. In the preceding example, we specified two flags
    that were shown in [Chapter 2](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 2. Troubleshooting Commands and Sources of Useful Information"), *Troubleshooting
    Commands and Sources of Useful Information*, `-l` (long listing) and `–f` (full
    format). In this chapter, we discussed how these flags provide additional details
    for the processes displayed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4 "第2章。故障排除命令和有用信息来源")中，我们讨论了使用`ps`命令来显示运行中的进程。在前面的例子中，我们指定了两个标志，这些标志在[第2章](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4
    "第2章。故障排除命令和有用信息来源")中显示，`-l`（长列表）和`–f`（完整格式）。在本章中，我们讨论了这些标志如何为显示的进程提供额外的细节。
- en: To better understand the above process, let's break down the additional details
    that these two flags provide.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解上述进程，让我们分解一下这两个标志提供的额外细节。
- en: 'Current State: `S` (interruptible sleep)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前状态：`S`（可中断睡眠）
- en: 'User: `vagrant`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户：`vagrant`
- en: 'Process ID: `3001`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程ID：`3001`
- en: 'Parent Process ID: `3000`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父进程ID：`3000`
- en: 'Priority Value: `80`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先级值：`80`
- en: 'Niceness Level: `0`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先级级别：`0`
- en: 'Command being executed: `lookbusy –cpu-mode-curve –cpu-curve-peak 14h –c 20-80`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在执行的命令：`lookbusy –cpu-mode-curve –cpu-curve-peak 14h –c 20-80`
- en: Earlier with the `top` command, this process was utilizing almost a full CPU,
    which means that this process is a suspect for the reported slowness. By looking
    at the above details, we can determine a few things about this process.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，使用`top`命令时，这个进程几乎使用了一个完整的CPU，这意味着这个进程是导致报告的缓慢的嫌疑对象。通过查看上述细节，我们可以确定这个进程的一些情况。
- en: First, it is a sub process of process `3000`; something we determined by the
    parent process ID. The second being that, when we ran the `ps` command, it was
    waiting for a task to finish; we can determine this by the interruptible sleep
    state that the process is currently in.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它是进程`3000`的子进程；这是我们通过父进程ID确定的。其次，当我们运行`ps`命令时，它正在等待一个任务完成；我们可以通过进程当前处于可中断睡眠状态来确定这一点。
- en: 'In addition to these two items, we can tell that the process does not have
    a high scheduling priority. We can determine this by looking at the priority value,
    which in this case is 80\. The scheduling priority system works as follows: the
    higher the number, the lower the priority that the process has with the system
    scheduler.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两项之外，我们还可以看出该进程没有高调度优先级。我们可以通过查看优先级值来确定这一点，在这种情况下是80。调度优先级系统的工作方式如下：数字越高，进程在系统调度程序中的优先级越低。
- en: We can also see that the niceness level is set to `0`, the default. This means
    that a user has not adjusted the niceness level to a higher (or lower) priority.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到niceness级别设置为`0`，即默认值。这意味着用户没有调整niceness级别以获得更高（或更低）的优先级。
- en: These are all important data points to collect about the process, but by themselves,
    they do not answer whether or not this process is the cause of the reported slowness.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是收集有关进程的重要数据点，但单独来看，它们并不能回答这个进程是否是报告的缓慢的原因。
- en: Using ps to determine process CPU utilization
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用ps来确定进程的CPU利用率
- en: Since we know that process `3001` is a child of process `3000`, we should not
    only look at the same information for process `3000` but also use `ps` to identify
    how much CPU process `3000` is utilizing. We can do this all in one command by
    using the `-o` (options) flag with `ps`. This flag allows you to specify your
    own output format; it also allows you to see fields that are not always visible
    via common `ps` flags.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道进程`3001`是进程`3000`的子进程，我们不仅应该查看进程`3000`的相同信息，还应该使用`ps`来确定进程`3000`利用了多少CPU。我们可以通过使用`-o`（选项）标志和`ps`来一次完成所有这些。这个标志允许您指定自己的输出格式；它还允许您查看通过常见的`ps`标志通常不可见的字段。
- en: In the following command, the `–o` flag is used to format the `ps` command's
    output with the key fields from our previous run and include the `%cpu` field.
    This additional field will show the CPU utilization of the process. The command
    will also use the `–p` flag to specify both process `3000` and process `3001`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的命令中，使用`-o`标志来格式化`ps`命令的输出，使用前一次运行的关键字段并包括`%cpu`字段。这个额外的字段将显示进程的CPU利用率。该命令还将使用`-p`标志来指定进程`3000`和进程`3001`。
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: While the above command is quite long, it shows just how useful the `–o` flag
    can be. Given the right options, it is possible to find out a great deal of information
    about processes with just the `ps` command.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然上面的命令非常长，但它展示了`-o`标志有多么有用。在给定正确的选项的情况下，只用`ps`命令就可以找到大量关于进程的信息。
- en: From the above command's output, we can see that process `3000` is yet another
    instance of the `lookbusy` command. We can also see that process `3000` is a child
    process of process `2980`. Before going much further, we should try to identify
    all of the processes associated with process `3001`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面命令的输出中，我们可以看到进程`3000`是`lookbusy`命令的另一个实例。我们还可以看到进程`3000`是进程`2980`的子进程。在进一步进行之前，我们应该尝试识别与进程`3001`相关的所有进程。
- en: We can do this by using the `ps` command with the `--forest` flag, which tells
    `ps` to print the parent and child processes in a tree format. When provided the
    `–e` (everything) flag, the `ps` command will print all processes in this tree
    format.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ps`命令和`--forest`标志来做到这一点，该标志告诉`ps`以树状格式打印父进程和子进程。当提供`-e`（所有）标志时，`ps`命令将以这种树状格式打印所有进程。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: By default, the `ps` command will only print processes related to the user who
    executed the command. The `–e` flag changes this behavior to print all possible
    processes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`ps`命令只会打印与执行命令的用户相关的进程。`-e`标志改变了这种行为，以打印所有可能的进程。
- en: The below output is truncated to specifically identify the `lookbusy` process.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出被截断，以特别识别`lookbusy`进程。
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From the `ps` output above, we can see that the `lookbusy` process with the
    ID `3000` has spawned two processes, namely `3001` and `3002`. We can also see
    that the vagrant user, who is currently logged in via SSH started the `lookbusy`
    processes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的`ps`输出中，我们可以看到ID为`3000`的`lookbusy`进程产生了两个进程，分别是`3001`和`3002`。我们还可以看到当前通过SSH登录的vagrant用户启动了`lookbusy`进程。
- en: Since we also used the `–o` flag with `ps` to show CPU utilization, we can see
    that process `3002` is utilizing `14.6%` of a single CPU.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还使用了`-o`标志和`ps`来显示CPU利用率，我们可以看到进程`3002`正在利用单个CPU的`14.6%`。
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is important to note that the `ps` command also displays the percentage of
    CPU time for a single processor, meaning that a process that utilizes more than
    one processor could have a value higher than 100%.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`ps`命令还显示了单个处理器的CPU时间百分比，这意味着利用多个处理器的进程可能具有高于100%的值。
- en: Putting it all together
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 把它们都放在一起
- en: Now that we have gone through the commands to identify the system's CPU utilization,
    let's put it together to summarize what has been found.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过命令来识别系统的CPU利用率，让我们把它们放在一起总结一下找到的东西。
- en: A quick look with top
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用top快速查看
- en: Our first step to identifying issues related to CPU performance is to execute
    the `top` command.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们识别与CPU性能相关的问题的第一步是执行`top`命令。
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'From the output of `top`, we can identify the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从`top`的输出中，我们可以识别以下内容：
- en: Overall, the system is around 60%–70% idle
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总体而言，系统大约60%–70%的时间处于空闲状态
- en: There are two processes running the `lookbusy` command/program, one of which
    appears to be using 70% of a single CPU
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有两个正在运行`lookbusy`命令/程序的进程，其中一个似乎正在使用单个CPU的70%
- en: Given the CPU utilization on this individual process and the system CPU utilization,
    the server in question most likely has multiple CPUs
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鉴于这个单独进程的CPU利用率和系统CPU利用率，所涉及的服务器很可能有多个CPU
- en: We can confirm the presence of multiple CPUs with the `lscpu` command
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以用`lscpu`命令确认存在多个CPU
- en: Processes 3001 and 3002 are the top two processes utilizing CPU on this system
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程3001和3002是该系统上利用CPU最多的两个进程
- en: The CPU wait state percentage is 0, which means that the issue is not likely
    to be disk I/O related
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU等待状态百分比为0，这意味着问题不太可能与磁盘I/O有关
- en: Digging deeper with ps
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过ps深入挖掘
- en: Since we identified processes `3001` and `3002` as suspicious from the `top`
    command's output, we can investigate these processes further with the `ps` command.
    To keep our investigation quick, we will use the `ps` command with the `–o` and
    `--forest` flags to identify the maximum possible information with one command.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从`top`命令的输出中确定了进程`3001`和`3002`是可疑的，我们可以使用`ps`命令进一步调查这些进程。为了快速进行调查，我们将使用`ps`命令和`-o`和`--forest`标志来用一个命令识别最大可能的信息。
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'From this output, we can determine the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中，我们可以确定以下内容：
- en: Processes 3001 and 3002 are child processes of process 3000
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程3001和3002是进程3000的子进程
- en: Process 3000 was started by the `vagrant` user
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程3000是由`vagrant`用户启动的
- en: The `lookbusy` command seems to be a command that utilizes a significant amount
    of CPU
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lookbusy`命令似乎是一个利用大量CPU的命令'
- en: The method used to launch `lookbusy` is not indicative of a system process but
    rather a user running an ad-hoc command
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动`lookbusy`的方法并不表明这是一个系统进程，而是一个用户运行的临时命令。
- en: Given the above information, there is a possibility that the `lookbusy` process
    launched by the `vagrant` user is the source of the performance issue. This is
    a reasonable hypothesis of the root cause if this system normally operates with
    a lower CPU utilization. However, considering that we are not very familiar with
    this system, it is also possible that the `lookbusy` process using almost a full
    CPU is normal.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上述信息，`vagrant`用户启动的`lookbusy`进程有可能是性能问题的根源。如果这个系统通常的CPU利用率较低，这是一个合理的根本原因的假设。然而，考虑到我们对这个系统不太熟悉，`lookbusy`进程几乎使用了整个CPU也是可能的。
- en: Considering that we are not familiar with the system's normal running conditions,
    we should continue to investigate the other possible sources for performance issues
    before reaching a conclusion.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们对系统的正常运行条件不太熟悉，我们应该在得出结论之前继续调查性能问题的其他可能来源。
- en: Memory
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存
- en: After application and CPU utilization, memory utilization is a very common source
    of performance degradation. In the CPU section, we utilized `top` quite extensively,
    and while `top` can also be used to identify system and process memory utilization,
    in this section, we will be using other commands.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序和CPU利用率之后，内存利用率是性能下降的一个非常常见的来源。在CPU部分，我们广泛使用了`top`，虽然`top`也可以用来识别系统和进程的内存利用率，但在这一部分，我们将使用其他命令。
- en: free – Looking at free and used memory
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: free – 查看空闲和已用内存
- en: As discussed in [Chapter 2](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 2. Troubleshooting Commands and Sources of Useful Information"), *Troubleshooting
    Commands and Sources of Useful Information* the `free` command simply prints the
    current memory availability and usage for the system.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第2章](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4 "第2章。故障排除命令和有用信息来源")中所讨论的，*故障排除命令和有用信息来源*
    `free`命令只是简单地打印系统当前的内存可用性和使用情况。
- en: When executed with no flags, the `free` command will output its values in kilobytes.
    To have the output in megabytes, we can simply execute the `free` command with
    the -m (megabytes) flag.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有标志时，`free`命令将以千字节为单位输出其值。为了使输出以兆字节为单位，我们可以简单地使用`-m`（兆字节）标志执行`free`命令。
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `free` command shows quite a bit of information about this system and how
    much memory is being used. In order to gain a better understanding of this command,
    let's break down the output a bit.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`free`命令显示了关于这个系统以及内存使用情况的大量信息。为了更好地理解这个命令，让我们对输出进行一些分解。'
- en: 'Since there are multiple lines in the output, we will start with the first
    line after the output header:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于输出中有多行，我们将从输出标题之后的第一行开始：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first value in this line is the total amount of **physical memory** available
    to the system. In our case, this is 490 MB. The second value is the amount of
    **memory used** by the system. The third value is the amount of memory on the
    system that is **unused**; note that I used the term "unused" rather than "available."
    The fourth value is the amount of memory used for **shared memory**; unless your
    system uses shared memory often, this is typically a low number.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行中的第一个值是系统可用的**物理内存**总量。在我们的情况下，这是490 MB。第二个值是系统使用的**内存**量。第三个值是系统上**未使用**的内存量；请注意，我使用了“未使用”而不是“可用”这个术语。第四个值是用于**共享内存**的内存量；除非您的系统经常使用共享内存，否则这通常是一个较低的数字。
- en: The fifth value is the amount of memory used for **buffers**. Linux will often
    try to speed up disk access by putting frequently used disk information into physical
    memory. The buffer memory is typically file system metadata. The **Cached memory**,
    which happens to be the sixth value, is the contents of frequently accessed files.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个值是用于**缓冲区**的内存量。Linux通常会尝试通过将频繁使用的磁盘信息放入物理内存来加快磁盘访问速度。缓冲区内存通常是文件系统元数据。**缓存内存**，也就是第六个值，是经常访问文件的内容。
- en: Linux memory buffers and caches
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Linux内存缓冲区和缓存
- en: Linux will typically try to use "unused" memory for buffers and caches. This
    means that in order to gain efficiencies, the Linux kernel will store frequently
    accessed file data and filesystem metadata in the unused memory. This allows the
    system to utilize memory that otherwise would not have been used to enhance disk
    access which is often slower than system memory.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Linux通常会尝试使用“未使用”的内存来进行缓冲和缓存。这意味着为了提高效率，Linux内核将频繁访问的文件数据和文件系统元数据存储在未使用的内存中。这使得系统能够利用本来不会被使用的内存来增强磁盘访问，而磁盘访问通常比系统内存慢。
- en: This is why the third value "unused" memory is typically a lower number than
    expected.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么第三个值“未使用”内存通常比预期的数字要低的原因。
- en: When a system is running low on unused memory, however, the Linux kernel will
    release the buffers and cached memory, as it needs. This means that even though
    technically, the memory used for buffers and caches is used, it is technically
    available to the system when required.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当系统的未使用内存不足时，Linux内核将根据需要释放缓冲区和缓存内存。这意味着即使从技术上讲，用于缓冲区和缓存的内存被使用了，但在需要时它从技术上讲是可用的。
- en: This brings us to the second line in the output of free.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带到了free输出的第二行。
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The second line has two values, the first being a part of the **Used** column
    and the second being a part of the **Free** or "unused" column. These values are
    Used or Free memory values after taking into consideration the availability of
    buffers and cached memory.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行有两个值，第一个是**Used**列的一部分，第二个是**Free**或“未使用”列的一部分。这些值是在考虑缓冲区和缓存内存的可用或未使用内存值之后得出的。
- en: To explain in simpler terms, the Used value on the second line is the result
    of the used memory value from the first line being subtracted by the buffers and
    cached values. For our example, it is 92 MB (used) minus 17 MB (cached).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，第二行的已使用值是从第一行的已使用内存值减去缓冲区和缓存值得到的结果。对于我们的示例，这是92 MB（已使用）减去17 MB（cached）。
- en: The free value in the second line is the result of the Free value on the first
    line with the buffers and cached memory added. Using the values from our example,
    this would be 397 MB (free) plus 17 MB (cached).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行的free值是第一行的Free值加上缓冲区和缓存内存的结果。使用我们的示例数值，这将是397 MB（free）加上17 MB（cached）。
- en: Swapped memory
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 交换内存
- en: The third line in the output of the `free` command is for swap memory.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`free`命令的输出的第三行是用于交换内存的。'
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this line, there are three columns: available, used, and free. The swap
    memory values are fairly self-explanatory. The available swap value is the amount
    of swap memory available to the system, the used value is the amount of swap currently
    allocated, and the free value is essentially the amount of swap available minus
    the amount of swap allocated.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行中，有三列：可用、已使用和空闲。交换内存的值相当容易理解。可用交换值是系统可用的交换内存量，已使用值是当前分配的交换量，而空闲值基本上是可用交换减去已分配的交换量。
- en: There are many environments where a significant amount of swap being allocated
    is frowned upon as this is generally an indicator that the system has run out
    of memory and used the swap space to compensate.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多环境不赞成分配大量的交换空间，因为这通常是系统内存不足并使用交换空间来补偿的指标。
- en: What free tells us about our system
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: free告诉我们关于我们系统的信息
- en: If we look again at the output of free, we can determine quite a few things
    about this server.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看free的输出，我们可以确定关于这台服务器的很多事情。
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can identify that only a small amount of memory (79 MB) is actually in use.
    This means that overall, the system should have plenty of memory available for
    processes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确定实际上只使用了很少的内存（79 MB）。这意味着总体上，系统应该有足够的内存可用于进程。
- en: There is an additional interesting fact, however, on the third line, it shows
    that **56** MB of memory has been written to swap. Although there is currently
    plenty of memory available on the system, 56 MB has been written to swap. This
    means that at some point in the past, this system might have been low on memory,
    low enough that the system had to swap memory pages from the physical memory to
    the swap memory.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个有趣的事实，在第三行显示，**56** MB的内存已被写入交换空间。尽管系统当前有大量可用内存，但已经有56 MB被写入交换空间。这意味着在过去的某个时刻，这个系统可能内存不足，足够低到系统不得不将内存页面从物理内存交换到交换内存。
- en: Checking for oomkill
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查oomkill
- en: When a Linux system runs out of physical memory, it first attempts to reuse
    the memory allocated to buffers and caches. If there is no additional memory that
    can be reclaimed from these sources, then the kernel will take older memory pages
    from the physical memory and write them to the swap memory. Once both the physical
    and the swap memory have been allocated, the kernel will launch the **out of memory
    killer** (**oomkill**) process. The `oomkill` process is designed to find processes
    that utilize large amounts of memory and kill (stop) them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当Linux系统的物理内存耗尽时，它首先尝试重用分配给缓冲区和缓存的内存。如果没有额外的内存可以从这些来源中回收，那么内核将从物理内存中获取旧的内存页面并将它们写入交换内存。一旦物理内存和交换内存都被分配，内核将启动**内存不足杀手**（**oomkill**）进程。`oomkill`进程旨在找到使用大量内存的进程并将其杀死（停止）。
- en: In general, the `oomkill` process is unwanted in most environments. When invoked,
    the `oomkill` process can kill many different types of processes. Whether processes
    are part of the system or at the user level, `oomkill` has the ability to kill
    them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在大多数环境中，`oomkill`进程是不受欢迎的。一旦调用，`oomkill`进程可以杀死许多不同类型的进程。无论进程是系统的一部分还是用户级别的，`oomkill`都有能力杀死它们。
- en: With a performance issue that may have affected memory utilization, it is always
    a good idea to check whether the `oomkill` process was invoked recently or not.
    The easiest way to determine whether `oomkill` was run recently is to simply view
    the console of the system as the initiation of this process is logged directly
    to the system console. In the cloud and virtual environments, however, the console
    may not be available.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能影响内存利用的性能问题，检查`oomkill`进程最近是否被调用是一个很好的主意。确定`oomkill`最近是否运行的最简单方法是简单地查看系统的控制台，因为这个进程的启动会直接记录在系统控制台上。然而，在云和虚拟环境中，控制台可能不可用。
- en: Another good way to determine whether `oomkill` was invoked recently is to search
    the `/var/log/messages` log file. We can do this by executing the `grep` command
    and searching for the string `Out of memory`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个确定最近是否调用了`oomkill`的好方法是搜索`/var/log/messages`日志文件。我们可以通过执行`grep`命令并搜索字符串`Out
    of memory`来做到这一点。
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For our example system, there have been no `oomkill` invocations recently.
    If our system had invoked the `oomkill` process, we could expect a message similar
    to the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例系统，最近没有发生`oomkill`调用。如果我们的系统调用了`oomkill`进程，我们可能会收到类似以下消息：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In [Chapter 11](part0074_split_000.html#26I9K2-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 11. Recovering from Common Failures"), *Recovering from Common Failures*
    we will once again investigate memory issues and take a deeper look into `oomkill`
    and how it works. For this chapter, we can conclude that the system has not completely
    exhausted its available memory.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11章](part0074_split_000.html#26I9K2-8ae10833f0c4428b9e1482c7fee089b4 "第11章。从常见故障中恢复")中，*从常见故障中恢复*，我们将再次调查内存问题，并深入了解`oomkill`及其工作原理。对于本章，我们可以得出结论，系统尚未完全耗尽其可用内存。
- en: ps - Checking individual processes memory utilization
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ps - 检查单个进程的内存利用率
- en: So far, the memory usage on this system seems pretty small, but we know from
    the CPU validation steps that the processes running `lookbusy` are suspicious
    and possibly cause our performance issues. Since we suspect that the `lookbusy`
    processes are a problem, we should also look at how much memory these processes
    are using. To do this, we can once again use the `ps` command with the `-o` flag.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，系统上的内存使用似乎很小，但是我们从CPU验证步骤中知道，运行`lookbusy`的进程是可疑的，可能导致性能问题。由于我们怀疑`lookbusy`进程存在问题，我们还应该查看这些进程使用了多少内存。为了做到这一点，我们可以再次使用带有`-o`标志的`ps`命令。
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This time, however, we ran our `ps` command a little differently and thus, received
    different results. This time when executing the `ps` command, we used the `–e`
    (everything) flag to show all processes. The results were then piped to `grep`
    in order to narrow filter them to only the processes that match the pattern `lookbusy`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这一次我们以稍有不同的方式运行了我们的`ps`命令，因此得到了不同的结果。这一次执行`ps`命令时，我们使用了`-e`（everything）标志来显示所有进程。然后将结果传输到`grep`，以便将它们缩小到只匹配`lookbusy`模式的进程。
- en: This is a very common way of using the `ps` command; in fact, it is even more
    common than specifying process ID(s) on the command line. In addition to using
    `grep`, this `ps` command example introduces a few new formatting options.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`ps`命令的一种非常常见的方式；事实上，这比在命令行上指定进程ID更常见。除了使用`grep`之外，这个`ps`命令示例还介绍了一些新的格式选项。
- en: '**%mem**: This is the percentage of system memory that the process is using.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**%mem**：这是进程正在使用的系统内存的百分比。'
- en: '**rss**: This is the amount of the resident site size of the process, which
    essentially means the amount of memory used by the process that is not swappable.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rss**：这是进程的常驻集大小，基本上是指进程使用的不可交换内存量。'
- en: '**vsize**: This is the amount of virtual memory size; it contains the amount
    of memory that the process is fully using irrespectively of whether this memory
    is a part of the physical memory or of the swap memory.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**vsize**：这是虚拟内存大小，它包含进程完全使用的内存量，无论这些内存是物理内存的一部分还是交换内存的一部分。'
- en: '**comm**: This option is similar to cmd with the exception that it does not
    display the command-line arguments.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**comm**：此选项类似于cmd，但不显示命令行参数。'
- en: 'The `ps` example shows interesting information, particularly the following
    lines:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps`示例显示了有趣的信息，特别是以下几行：'
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It seems that several additional `lookbusy` processes have been started and
    these processes are utilizing 40% and 34% of the system memory (by using the `%mem`
    column). From the rss column, we can see that these two processes are using about
    374 MB of the total 490 MB of the physical memory.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎已经启动了几个额外的`lookbusy`进程，并且这些进程正在利用系统内存的40%和34%（通过使用`%mem`列）。从rss列中，我们可以看到这两个进程正在使用总共490MB物理内存中的约374MB。
- en: It also seems that these processes started utilizing a large amount of memory
    after we started our investigation. Originally, our free output stated that only
    70 MB of memory was in use; however, these processes seem to be utilizing much
    more. We can confirm this by running free again.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来这些进程在我们开始调查后开始利用大量内存。最初，我们的free输出表明只使用了70MB内存；然而，这些进程似乎利用了更多。我们可以通过再次运行free来确认这一点。
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our system is in fact utilizing almost all of its memory now; in fact, we are
    also using 310 MB of swap space.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们的系统现在几乎利用了所有的内存；事实上，我们还使用了310MB的交换空间。
- en: vmstat – Monitoring memory allocation and swapping
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: vmstat - 监控内存分配和交换
- en: Since this system seems to have fluctuating memory utilization, there is one
    very useful command that shows memory allocation and de-allocation along with
    the number of pages swapped in and out at regular intervals. This command is called
    `vmstat`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个系统的内存利用率似乎有所波动，有一个非常有用的命令可以定期显示内存分配和释放以及换入和换出的页面数。这个命令叫做`vmstat`。
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the above example, the `vmstat` command was executed with the `-n` (one-header)
    flag followed by the delay in seconds (10) and the number of reports to generate
    (5). These options tell `vmstat` to only output one header line for this execution
    rather than a new header line for each report, run the report every 10 seconds,
    and limit the number of reports to 5\. If the limitation on the number of reports
    is omitted than `vmstat` will simply run continuously until stopped with *CTRL*+*C*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`vmstat`命令是使用`-n`（一个标题）标志执行的，后面跟着延迟时间（10秒）和要生成的报告数（5）。这些选项告诉`vmstat`仅为此次执行输出一个标题行，而不是为每个报告输出一个新的标题行，每10秒运行一次报告，并将报告数量限制为5。如果省略了报告数量的限制，`vmstat`将简单地持续运行，直到使用*CTRL*+*C*停止。
- en: 'The output of `vmstat` can be a bit overwhelming at first, but if we break
    down the output, it will be easier to understand. The output of `vmstat` has six
    output categories, namely Procs, Memory, Swap, IO, System, and CPU. In this section,
    we will focus on two of these categories: Memory and Swap.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`vmstat`的输出一开始可能有点压倒性，但如果我们分解输出，就会更容易理解。`vmstat`的输出有六个输出类别，即进程、内存、交换、IO、系统和CPU。在本节中，我们将专注于这两个类别：内存和交换。'
- en: '**Memory**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存**'
- en: '`swpd`: Amount of memory written to swap'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swpd`：写入交换的内存量'
- en: '`free`: Amount of unused memory'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`free`：未使用的内存量'
- en: '`buff`: Amount of memory used as buffers'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buff`：用作缓冲区的内存量'
- en: '`cache`: Amount of memory used as cache'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache`：用作缓存的内存量'
- en: '`inact`: Amount of inactive memory'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inact`：非活动内存量'
- en: '`active`: amount of active memory'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active`：活动内存量'
- en: '**Swap**'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交换**'
- en: '`si`: Amount of memory swapped in from disk'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`si`：从磁盘交换的内存量'
- en: '`so`: Amount of memory swapped to disk'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`so`：交换到磁盘的内存量'
- en: Now that we have a definition of these values, let's see what the output of
    `vmstat` tells us about this system's memory usage.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这些值的定义，让我们看看`vmstat`的输出告诉我们关于这个系统内存使用情况的信息。
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we compare the first and the second line from `vmstat's` output, we can see
    a rather large disparity. In particular, we can see that in the first interval,
    the cache memory was `7676`, whereas in the second interval, this value was 2096\.
    We can also see that the `si` or swapped-in value in the first line is 8 but 1887
    in the second line.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们比较`vmstat`输出的第一行和第二行，我们会看到一个相当大的差异。特别是，我们可以看到在第一个间隔中，缓存内存是`7676`，而在第二个间隔中，这个值是2096。我们还可以看到第一行中的`si`或交换入值是8，而第二行中是1887。
- en: The reason for this disparity is that the first report of `vmstat` is always
    a summary of statistics since the last reboot, whereas the second report is a
    summary of statistics since the previous report. Each subsequent report will be
    a summary of the previous one, meaning that the third report will summarize statistics
    since the second report. This behavior of `vmstat` can often cause confusion for
    new systems administrators and users; therefore, it is often considered an advanced
    troubleshooting tool.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异的原因是，`vmstat`的第一个报告总是自上次重启以来的统计摘要，而第二个报告是自上一个报告以来的统计摘要。每个后续的报告将总结前一个报告，这意味着第三个报告将总结自第二个报告以来的统计数据。`vmstat`的这种行为经常会让新的系统管理员和用户感到困惑；因此，它通常被认为是一种高级故障排除工具。
- en: Because of the method of how `vmstat` generates the first report, the common
    practice is to discard it and start from the second report. We will follow this
    philosophy and specifically look at the second and the third reports.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`vmstat`生成第一个报告的方法，通常的做法是丢弃它并从第二个报告开始。我们将遵循这一原则，特别关注第二个和第三个报告。
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the second and the third reports, we can see some interesting data.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个和第三个报告中，我们可以看到一些有趣的数据。
- en: The first thing that sticks out is the fact that from the first report's generation
    time to the second report's generation time, there were 1,887 pages swapped in
    and 130 pages swapped out. The second report also shows that only 35 MB of the
    memory is free with 0 MB of the memory in buffer and 2 MB of the memory in cache.
    Based on how Linux utilizes memory, this means that there is effectively only
    37 MB of available memory on this system.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最引人注目的是，从第一个报告的生成时间到第二个报告的生成时间，交换了1,887页，交换出了130页。第二个报告还显示，只有35 MB的内存是空闲的，缓冲区中没有内存，缓存中有2
    MB的内存。根据Linux内存的利用方式，这意味着系统上实际上只有37 MB的可用内存。
- en: This low amount of available memory explains why our system has swapped in a
    large number of pages. We can see from the third line that the trend is continuing,
    we continue to swap in quite a few pages and our available memory has reduced
    to roughly 35 MB.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这种低可用内存量解释了为什么我们的系统已经交换了大量页面。我们可以从第三行看到这种趋势正在持续，我们继续交换了相当多的页面，我们的可用内存已经减少到大约35
    MB。
- en: From this example of `vmstat`, we can see that our system is now running out
    of physical memory. Because of this, our system is taking pages of memory from
    the physical RAM and writing it to our swap device.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个`vmstat`的例子中，我们可以看到我们的系统现在已经用尽了物理内存。因此，我们的系统正在从物理RAM中取出内存页面并将其写入我们的交换设备。
- en: Putting it all together
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: Now that we have explored the tools required for troubleshooting memory utilization,
    let's put all of them together to troubleshoot the issue of slow system performance.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探索了用于故障排除内存利用的工具，让我们把它们都放在一起来解决系统性能缓慢的问题。
- en: Taking a look at the system's memory utilization with free
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用free查看系统的内存利用
- en: The first command to give us a snapshot of the systems memory utilization is
    the `free` command. This command will give us an idea of where to look further
    for any memory utilization issues.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 给我们提供系统内存利用快照的第一个命令是`free`命令。这个命令将为我们提供在哪里进一步查找任何内存利用问题的想法。
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: From the output of `free`, we can see that there is currently 215 MB of memory
    available. We can see this via the `free` column on the second line. We can also
    see that overall, this system has 183 MB of memory that has been swapped to our
    swap devices.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从`free`的输出中，我们可以看到目前有215 MB的内存可用。我们可以通过第二行的`free`列看到这一点。我们还可以看到，总体上，这个系统有183
    MB的内存已经被交换到我们的交换设备。
- en: Watch what is happening with vmstat
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 观察vmstat的情况
- en: Since the system has swapped (or rather paged) at some point, we can use the
    `vmstat` command to see whether the system is swapping right now.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于系统在某个时候已经进行了交换（或者说分页），我们可以使用`vmstat`命令来查看系统当前是否正在进行交换。
- en: When executing `vmstat` this time around, we will leave off the number of reports
    value, which will cause `vmstat` to continuously report memory statistics, similar
    to the top command's output.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这次执行`vmstat`时，我们将不指定报告值的数量，这将导致`vmstat`持续报告内存统计，类似于top命令的输出。
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This `vmstat` output is different from our earlier execution. From this output,
    we can see that while there is quite a bit of memory swapped, the system is not
    currently swapping. We can determine this by the 0 values in both the `si` (swap
    in) and so (swap out) columns.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`vmstat`输出与我们之前的执行不同。从这个输出中，我们可以看到虽然有相当多的内存被交换，但系统目前并没有进行交换。我们可以通过`si`（交换入）和so（交换出）列中的0值来确定这一点。
- en: In fact, the memory utilization seems steady during this `vmstat` run. The `free`
    memory value is fairly consistent between each `vmstat` report, as well as the
    cache and buffer memory statistics.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在这次`vmstat`运行期间，内存利用率似乎很稳定。每个`vmstat`报告中，`free`内存值都相当一致，缓存和缓冲内存统计也是如此。
- en: Finding the processes that utilize the most memory with ps
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用ps找到内存利用最多的进程
- en: Our system has 490 MB of physical memory, and both `free` and `vmstat` show
    that roughly, 215 MB of memory available. This means that more than half of our
    system memory is currently utilized; with this level of use, it is a good idea
    to find out which processes are utilizing our system's memory. If nothing else,
    this data will be useful to show what the system's current state is.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统有490MB的物理内存，`free`和`vmstat`都显示大约215MB的可用内存。这意味着我们系统内存的一半以上目前被使用；在这种使用水平下，找出哪些进程正在使用我们系统的内存是一个好主意。即使没有别的，这些数据也将有助于显示系统当前的状态。
- en: To identify the process using the highest amount of memory, we can use the `ps`
    command along with sort and tail.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别使用最多内存的进程，我们可以使用`ps`命令以及sort和tail。
- en: '[PRE28]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The above example uses pipes to redirect the output of `ps` to the sort command.
    The sort command is performing a numeric (`-n`) sort of the first column (`-k
    1`). This will have the effect of sorting the output, putting the process with
    the highest `rss` size at the bottom. After the `sort` command, the output is
    also piped to the `tail` command, which when specified with the `-n` (number)
    flag followed by a number will limit the output to only include the specified
    number of results.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子使用管道将`ps`的输出重定向到sort命令。sort命令执行数字（`-n`）对第一列（`-k 1`）的排序。这将对输出进行排序，将具有最高`rss`大小的进程放在底部。在`sort`命令之后，输出也被管道传递到`tail`命令，当指定了`-n`（数字）标志后跟着一个数字，将限制输出只包括指定数量的结果。
- en: Tip
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If the concept of chaining commands together with pipes is new, I highly suggest
    practicing this as it is extremely useful for day-to-day `sysadmin` tasks as well
    as during troubleshooting. We will discuss this concept and provide examples several
    times throughout this book.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将命令与管道一起链接的概念是新的，我强烈建议练习这一点，因为它对日常的`sysadmin`任务以及故障排除非常有用。我们将在本书中多次讨论这个概念，并提供示例。
- en: '[PRE29]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: From the output of `ps`, we can see that process 5383 is using roughly 200 MB
    of memory. We can also see that the process is another `lookbusy` process, which
    was again spawned by the vagrant user.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ps`的输出中，我们可以看到进程5383正在使用大约200MB的内存。我们还可以看到该进程是另一个`lookbusy`进程，再次由vagrant用户生成。
- en: 'From the output of free, `vmstat`, and `ps`, we can determine the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 从`free`，`vmstat`和`ps`的输出中，我们可以确定以下内容：
- en: The system currently has roughly 200 MB of available memory
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统当前大约有200MB的可用内存
- en: While the system is not currently swapping, it has in the past, and given what
    we saw earlier from `vmstat`, we know that it was swapping recently
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然系统目前没有交换，但过去曾经有过，根据我们之前从`vmstat`看到的情况，我们知道它最近进行了交换
- en: We found that process `5383` is utilizing roughly 200 MB of memory
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们发现进程`5383`正在使用大约200MB的内存
- en: We also can see that process `5383` was started by the `vagrant` user and is
    running the `lookbusy` process
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以看到进程`5383`是由`vagrant`用户启动的，并且正在运行`lookbusy`进程
- en: Using the `free` command, we can see that this system has 490 MB of physical
    memory
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`free`命令，我们可以看到这个系统有490MB的物理内存
- en: Given the above information, it seems that the `lookbusy` process executed by
    the `vagrant` user is not only a suspicious user of the CPU but also a suspicious
    user of the memory.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以上信息，似乎由`vagrant`用户执行的`lookbusy`进程不仅是CPU的可疑使用者，还是内存的可疑使用者。
- en: Disk
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 磁盘
- en: Disk utilization is another common performance bottleneck. In general, performance
    issues are rarely due to the amount of disk space. While I have seen performance
    issues due to the large number of files or files of a large size, in general,
    disk performance is limited by how much is being written to and read from a disk.
    So, while it is important to know if a file system is full while troubleshooting
    performance issues, file system usage alone does not always indicate whether or
    not there is an issue.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘利用率是另一个常见的性能瓶颈。一般来说，性能问题很少是由于磁盘空间的问题。虽然我曾经看到由于大量文件或大文件的性能问题，但一般来说，磁盘性能受到写入和读取磁盘的限制。因此，在故障排除性能问题时，了解文件系统是否已满很重要，但仅仅根据文件系统的使用情况并不总是能指示是否存在问题。
- en: iostat – CPU and device input/output statistics
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: iostat - CPU和设备输入/输出统计
- en: The `iostat` command is an essential command for troubleshooting disk performance
    issues and is similar to vmstat in terms of both the usage and the information
    that it provides. Like `vmstat`, `iostat` when executed is followed by two numbers,
    the first being the delay in report generation and the second being the number
    of reports to generate.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`iostat`命令是用于故障排除磁盘性能问题的基本命令，类似于vmstat，它提供的使用和信息都是相似的。像`vmstat`一样，执行`iostat`命令后面跟着两个数字，第一个是报告生成的延迟，第二个是要生成的报告数。'
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the above example, the `–x` (extended statistics) flag was provided to print
    extended statistics. The extended statistics are extremely useful and provide
    additional information that can be essential for identifying performance bottlenecks.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，提供了`-x`（扩展统计）标志以打印扩展统计信息。扩展统计非常有用，并提供了额外的信息，对于识别性能瓶颈至关重要。
- en: CPU details
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CPU详情
- en: The `iostat` command will display CPU statistics along with I/O statistics.
    This is yet another command that can be utilized to troubleshoot CPU utilization.
    This is particularly useful when the CPU utilization indicates high I/O wait time.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`iostat`命令将显示CPU统计信息以及I/O统计信息。这是另一个可以用来排除CPU利用率的命令。当CPU利用率指示高I/O等待时间时，这是特别有用的。'
- en: '[PRE31]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The above is the same information displayed from the `top` command; it is not
    uncommon with Linux to find multiple commands that output similar information.
    Since these details have been covered in the CPU troubleshooting section, we will
    focus on the I/O statistics portion of the `iostat` command.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以上是从`top`命令显示的相同信息；在Linux中找到多个输出类似信息的命令并不罕见。由于这些细节已在CPU故障排除部分中涵盖，我们将专注于`iostat`命令的I/O统计部分。
- en: Reviewing I/O statistics
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 审查I/O统计
- en: To start reviewing the I/O statistics, let's start with the first two reports.
    I am including the CPU utilization below to help indicate where each report starts
    as it is the first item in each statistics report.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始审查I/O统计，让我们从前两份报告开始。我在下面包括了CPU利用率，以帮助指示每份报告的开始位置，因为它是每份统计报告中的第一项。
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By comparing the first two reports, we find that there is a large disparity
    between them. In the first report, the `%util` value for the `sda` device is `0.56`,
    and it is `65.91` in the second report.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较前两份报告，我们发现它们之间存在很大的差异。在第一个报告中，`sda`设备的`％util`值为`0.56`，而在第二个报告中为`65.91`。
- en: The reason for this difference is that as in the case of `vmstat`, the statistics
    from the first execution of `iostat` are based on the last time the server rebooted.
    The second report is based on the time since the first report. This means that
    the output of the second report is based on the 10 s between the first and the
    second report generation. This is the same behavior seen in `vmstat` and is a
    common behavior for other tools that gather performance statistics.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异的原因是，与`vmstat`一样，第一次执行`iostat`的统计是基于服务器最后一次重启的时间。第二份报告是基于第一份报告之后的时间。这意味着第二份报告的输出是基于第一份报告生成之间的10秒。这与`vmstat`中看到的行为相同，并且是其他收集性能统计信息的工具的常见行为。
- en: As with `vmstat`, we will discard the first report and only look at the second
    report.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与`vmstat`一样，我们将丢弃第一个报告，只看第二个报告。
- en: '[PRE33]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: From the above, we can identify several things about this system. The first
    and most important is the `%iowait` value in the CPU line.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面，我们可以确定这个系统的几个情况。最重要的是CPU行中的`％iowait`值。
- en: '[PRE34]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Earlier when executing the top command, the percentage of time spent waiting
    for I/O was quite minimal; however, when running `iostat`, we can see that the
    CPUs are actually spending a lot of time waiting for I/O. While I/O wait does
    not necessarily mean waiting for the disk, the rest of this output seems to suggest
    that there is quite a bit of disk activity.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候在执行top命令时，等待I/O的时间百分比相当小；然而，在运行`iostat`时，我们可以看到CPU实际上花了很多时间等待I/O。虽然I/O等待并不一定意味着等待磁盘，但这个输出的其余部分似乎表明磁盘活动相当频繁。
- en: '[PRE35]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The extended statistics output has many columns, to make this output a little
    easier to understand, let's break down what these columns tell us.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展统计输出有许多列，为了使这个输出更容易理解，让我们分解一下这些列告诉我们的内容。
- en: '**rrqm/s**: Number of read requests per second that are merged and queued'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rrqm/s**：每秒合并和排队的读取请求数'
- en: '**wrqm/s**: Number of write requests per second that are merged and queued'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wrqm/s**：每秒合并和排队的写入请求数'
- en: '**r/s**: Number of read requests per second completed'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**r/s**：每秒完成的读取请求数'
- en: '**w/s**: Number of write requests per second completed'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**w/s**：每秒完成的写入请求数'
- en: '**rkB/s**: Number of reads in kilobytes per second'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rkB/s**：每秒读取的千字节数'
- en: '**wkB/s**: Number of writes in kilobytes per second'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wkB/s**：每秒写入的千字节数'
- en: '**avgr-sz**: Average size (in sectors) of requests made to the device'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**avgr-sz**：发送到设备的请求的平均大小（以扇区为单位）'
- en: '**avgqu-sz**: Average queue length of requests made to the device'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**avgqu-sz**：发送到设备的请求的平均队列长度'
- en: '**await**: Average time in milliseconds that requests wait for to be served'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**await**：请求等待服务的平均时间（毫秒）'
- en: '**r_await**: Average time in milliseconds that read requests wait for to be
    serviced'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**r_await**：读取请求等待服务的平均时间（毫秒）'
- en: '**w_await**: Average time in milliseconds that write requests wait for to be
    serviced'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**w_await**：写入请求等待服务的平均时间（毫秒）'
- en: '**svctm**: This field is invalid and is slated to be removed; it should not
    be trusted or used'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**svctm**：此字段无效，将被删除；不应被信任或使用'
- en: '**%util**: Percentage of CPU time spent while I/O requests are being serviced
    by this device. A device can only be at most 100% utilized'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**％util**：在此设备服务I/O请求时所花费的CPU时间百分比。设备最多只能利用100％'
- en: For our example, we will focus solely on the `r/s`, `w/s`, `await`, and `%util`
    values, since these values will tell us quite a bit about this system's disk utilization
    while keeping our example simple.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将专注于`r/s`，`w/s`，`await`和`％util`值，因为这些值将告诉我们关于这个系统的磁盘利用率的很多信息，同时保持我们的示例简单。
- en: After reviewing the `iostat` output, we can see that both the `sda` and `dm-1`
    devices have the highest `%util` value, meaning that they are the closest to being
    at capacity.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 经过审查`iostat`输出后，我们可以看到`sda`和`dm-1`设备都具有最高的`％util`值，这意味着它们最接近达到容量。
- en: '[PRE36]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: From this report, we can see that the `sda` device had completed an average
    of 764 reads (`r/s`) and 808 writes (`w/s`) per second. We can also identify that
    these requests are taking an average of 39 ms (await) to complete. While these
    numbers are interesting, they do not necessarily mean that the system is in an
    abnormal state. Since we are unfamiliar with this system, we do not necessarily
    know whether the level of reads and writes are unexpected for this system. The
    information is however important to collect, as these statistics are important
    pieces of data for the data collection stage of the troubleshooting process.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 从这份报告中，我们可以看到`sda`设备平均完成了764次读取（`r/s`）和808次写入（`w/s`）每秒。我们还可以确定这些请求平均需要39毫秒（等待时间）来完成。虽然这些数字很有趣，但并不一定意味着系统处于异常状态。由于我们对这个系统不熟悉，我们并不一定知道读取和写入的水平是否出乎意料。然而，收集这些信息是很重要的，因为这些统计数据是故障排除过程中数据收集阶段的重要数据。
- en: Another interesting statistic we can see from `iostat` is that the `%util` values
    for both `sda` and `dm-1` devices are about 66%. This means that during the 10
    s between the first report generation and the second, 66% of the CPU time spent
    was spent waiting for either the `sda` or the `dm-1` device.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从`iostat`中我们可以看到另一个有趣的统计数据是，`sda`和`dm-1`设备的`%util`值都约为66%。这意味着在第一次报告生成和第二次报告之间的10秒内，66%的CPU时间都是在等待`sd`或`dm-1`设备。
- en: Identifying devices
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 识别设备
- en: Having 66% utilization for a disk device is generally considered high, while
    this is quite useful information, it does not tell us who or what is utilizing
    the disk. To answer these questions, we will need to figure out what exactly `sda`
    and `dm-1` are being used for.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于磁盘设备来说，66%的利用率通常被认为是很高的，虽然这是非常有用的信息，但它并没有告诉我们是谁或什么在利用这个磁盘。为了回答这些问题，我们需要弄清楚`sda`和`dm-1`到底被用来做什么。
- en: Since devices from `iostat` commands output are generally disk devices, the
    first step to identifying these devices is to run the `mount` command.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`iostat`命令输出的设备通常是磁盘设备，识别这些设备的第一步是运行`mount`命令。
- en: '[PRE37]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `mount` command, when run without any options, will display all of the current
    mounted file systems. The first column in the output of `mount` is the device
    that has been mounted. In the output above, we can see that the `sda` device is
    in fact a disk device and that it has a partition called `sda1` that is mounted
    as `/boot`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount`命令在没有任何选项的情况下运行时，将显示所有当前挂载的文件系统。`mount`输出中的第一列是已经挂载的设备。在上面的输出中，我们可以看到`sda`设备实际上是一个磁盘设备，并且它有一个名为`sda1`的分区，挂载为`/boot`。'
- en: What we don't see however is the `dm-1` device. Since this device is not listed
    in the output of the `mount` command another way, we may identify the `dm-1` device
    by looking within the `/dev` folder.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们没有看到`dm-1`设备。由于这个设备没有出现在`mount`命令的输出中，我们可以通过另一种方式，在`/dev`文件夹中查找`dm-1`设备。
- en: All devices on a system are presented as a file within the `/dev` folder structure.
    The `dm-1` device is no different.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 系统上的所有设备都被呈现为`/dev`文件夹结构中的一个文件。`dm-1`设备也不例外。
- en: '[PRE38]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: While we have been able to find the location of the `dm-1` device, we have yet
    to identify its use. One thing that does stick out about this device, however,
    is the name `dm-1`. When devices start with `dm`, this is an indication that the
    device is a logical device created by the device mapper.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经找到了`dm-1`设备的位置，但我们还没有确定它的用途。然而，关于这个设备，有一件事引人注目，那就是它的名字`dm-1`。当设备以`dm`开头时，这表明该设备是由设备映射器创建的逻辑设备。
- en: Device mapper is a Linux kernel framework that allows the system to create virtual
    disk devices that "map" back to physical devices. This functionality is used for
    many features including software raid, disk encryption, and logical volumes.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 设备映射器是一个Linux内核框架，允许系统创建虚拟磁盘设备，这些设备“映射”回物理设备。这个功能用于许多特性，包括软件RAID、磁盘加密和逻辑卷。
- en: A common practice within the device mapper framework is to create symlinks for
    these features that link back to a single logical device. Since we can see with
    the `ls` command that `dm-1` is a block device via the "b" value in the first
    column's output (`brw-rw----.`), we know that `dm-1` is not a symlink. We can
    use this information along with the find command to identify any symlinks that
    link back to the `dm-1` block device.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 设备映射器框架中的一个常见做法是为这些特性创建符号链接，这些符号链接指向单个逻辑设备。由于我们可以用`ls`命令看到`dm-1`是一个块设备，通过输出的第一列的“b”值（`brw-rw----.`），我们知道`dm-1`不是一个符号链接。我们可以利用这些信息以及find命令来识别任何指向`dm-1`块设备的符号链接。
- en: '[PRE39]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the earlier chapters, we used the find command to identify configuration
    and log files. In the above example, we use the `-L` (follow links) flag, followed
    by the `/dev` path and the `--samefile` flag to tell find to search the `/dev`
    folder structure, searching any symlinked folders to identify any file that is
    the "same file" as `/dev/dm-1`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用find命令来识别配置和日志文件。在上面的例子中，我们使用了`-L`（跟随链接）标志，后面跟着`/dev`路径和`--samefile`标志，告诉find搜索`/dev`文件夹结构，搜索任何符号链接的文件，以识别任何与`/dev/dm-1`相同的文件。
- en: The `--samefile` flag identifies files that have the same `inode` number. When
    the `-L` flag is included in the command, the output includes symlinks, and it
    seems that this example has returned several results. The symlink file that sticks
    out the most is `/dev/mapper/root`; the reason that this file sticks out is that
    it was also present in the output of the mount command.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`--samefile`标志标识具有相同`inode`号的文件。当命令中包含`-L`标志时，输出包括符号链接，而这个例子似乎返回了几个结果。最引人注目的符号链接文件是`/dev/mapper/root`；这个文件之所以引人注目，是因为它也出现在挂载命令的输出中。'
- en: '[PRE40]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It seems that `/dev/mapper/root` appears to be a logical volume. A logical volume
    within Linux is essentially storage virtualization. This functionality allows
    you to create pseudo devices (as part of the device mapper), which is mapped to
    one or more physical devices.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来`/dev/mapper/root`似乎是一个逻辑卷。在Linux中，逻辑卷本质上是存储虚拟化。这个功能允许您创建伪设备（作为设备映射器的一部分），它映射到一个或多个物理设备。
- en: For example, it is possible to take four different hard disks and combine these
    disks into one logical volume. The logical volume can then be used as the disk
    for a single file system. It is even possible to add another hard disk at a later
    time by using logical volumes.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以将四个不同的硬盘组合成一个逻辑卷。逻辑卷然后可以用作单个文件系统的磁盘。甚至可以在以后通过使用逻辑卷添加另一个硬盘。
- en: To confirm that the `/dev/mapper/root` device is in fact a logical volume, we
    can execute the `lvdisplay` command, which is used to display the logical volumes
    on the system.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 确认`/dev/mapper/root`设备实际上是一个逻辑卷，我们可以执行`lvdisplay`命令，该命令用于显示系统上的逻辑卷。
- en: '[PRE41]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: From the output of `lvdisplay`, we can see an interesting path called `/dev/rhel/root`,
    which also exists with the output of our `find` command. Let's take a look at
    this device with the `ls` command.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 从`lvdisplay`的输出中，我们可以看到一个名为`/dev/rhel/root`的有趣路径，这个路径也存在于我们的`find`命令的输出中。让我们用`ls`命令来查看这个设备。
- en: '[PRE42]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we can see that `/dev/rhel/root` is a symlink to `/dev/dm-1`; this confirms
    that `/dev/rhel/root` is the same as `/dev/dm-1` and that these are in fact logical
    volume devices, which means that these are not really the physical device.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`/dev/rhel/root`是一个指向`/dev/dm-1`的符号链接；这证实了`/dev/rhel/root`与`/dev/dm-1`是相同的，这些实际上是逻辑卷设备，这意味着这些并不是真正的物理设备。
- en: To display the physical device behind these logical volumes, we can use the
    `pvdisplay` command.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示这些逻辑卷背后的物理设备，我们可以使用`pvdisplay`命令。
- en: '[PRE43]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can see from the output of `pvdisplay` that the `dm-1` device actually maps
    to `sda2`, which explains why the disk utilizations for `dm-1` and `sda` were
    extremely close, as any activity on `dm-1` is actually being performed on `sda`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`pvdisplay`的输出中看到，`dm-1`设备实际上映射到`sda2`，这解释了为什么`dm-1`和`sda`的磁盘利用率非常接近，因为对`dm-1`的任何活动实际上都是在`sda`上执行的。
- en: Who is writing to these devices?
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 谁在向这些设备写入？
- en: Now that we have found where I/O is being utilized, we need to find out who
    is utilizing this I/O. The easiest method to find out which processes are writing
    to disk the most is to use the `iotop` command. This tool is a relatively new
    command and is now included by default with Red Hat Enterprise Linux 7\. However,
    this command has not always been available in previous RHEL versions.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经找到了I/O的利用情况，我们需要找出谁在利用这个I/O。找出哪些进程最多地写入磁盘的最简单方法是使用`iotop`命令。这个工具是一个相对较新的命令，现在默认包含在Red
    Hat Enterprise Linux 7中。然而，在以前的RHEL版本中，这个命令并不总是可用的。
- en: Before the adoption of `iotop`, the method for finding the top processes that
    are using I/O involved using the `ps` command and looking through the `/proc`
    filesystem.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在采用`iotop`之前，查找使用I/O最多的进程的方法涉及使用`ps`命令并浏览`/proc`文件系统。
- en: ps – Using ps to identify processes utilizing I/O
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ps - 使用ps命令识别利用I/O的进程
- en: 'While collecting data related to the CPU, we covered the state field in the
    output of the `ps` command. What we didn''t cover is the various states that a
    process can be in. The following list contains the seven possible states that
    the `ps` command will show:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在收集与CPU相关的数据时，我们涵盖了`ps`命令的输出中的状态字段。我们没有涵盖的是进程可能处于的各种状态。以下列表包含了`ps`命令将显示的七种可能的状态：
- en: '**Uninterruptible sleep** (`D`): Processes generally in a sleep state when
    waiting for I/O'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不间断睡眠（`D`）：进程通常在等待I/O时处于睡眠状态
- en: '**Running or Runnable** (`R`): Processes on the run queue'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行或可运行**（`R`）：运行队列上的进程'
- en: '**Interruptible sleep** (`S`): Processes waiting for an event to complete but
    not blocking CPU or I/O'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可中断睡眠**（`S`）：等待事件完成但不阻塞CPU或I/O的进程'
- en: '**Stopped** (`T`): Processes that are stopped by a job control system such
    as the jobs command'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已停止**（`T`）：被作业控制系统停止的进程，如jobs命令'
- en: '**Paging** (`P`): Processes that are current paging; however, this is less
    relevant on newer kernels'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分页**（`P`）：当前正在分页的进程；但是，在较新的内核上，这不太相关'
- en: '**Dead** (`X`): Processes that are dead, this should never be seen, as dead
    processes should not show up when running `ps`'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死亡**（`X`）：已经死亡的进程，不应该出现在运行`ps`时'
- en: '**Defunct** (`Z`): Zombie processes that are terminated but left in an undead
    state'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**僵尸**（`Z`）：已终止但保留在不死状态的僵尸进程'
- en: When investigating I/O utilization, it is important to identify with a state
    listed as `D` **Uninterruptible Sleep**. As these processes are generally waiting
    for I/O, they are the most likely processes to be over utilizing disk I/O.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在调查I/O利用率时，重要的是要识别状态列为`D`的**不间断睡眠**。由于这些进程通常在等待I/O，它们是最有可能过度利用磁盘I/O的进程。
- en: To do this, we will use the `ps` command with the `–e` (everything), `-l` (long
    format), and `-f` (full format) flags. We will also use pipes again to redirect
    the output to the `grep` command and filter the output to only show processes
    with a `D` state.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用`ps`命令和`-e`（所有）、`-l`（长格式）和`-f`（完整格式）标志。我们还将再次使用管道将输出重定向到`grep`命令，并将输出过滤为只显示具有`D`状态的进程。
- en: '[PRE44]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: With the above output, we see that there are two processes currently in an uninterruptible
    sleep state. One process is `kworker`, which is a kernel system process, and the
    other is `bonnie++`, a process launched by the root user. As the `kworker` process
    is a generic kernel process, we will focus on the `bonnie++` process first.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的输出中，我们看到有两个进程目前处于不间断睡眠状态。一个进程是`kworker`，这是一个内核系统进程，另一个是`bonnie++`，是由root用户启动的进程。由于`kworker`进程是一个通用的内核进程，我们将首先关注`bonnie++`进程。
- en: To better understand this process, we will run the `ps` command again but this
    time with the `--forest` option.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个过程，我们将再次运行`ps`命令，但这次使用`--forest`选项。
- en: '[PRE45]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: By reviewing the above output, we can see that the `bonnie++` process is actually
    a child process of process `16052`, which is another child process of `11243`,
    which is the bash shell for the `vagrant` user.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过审查上述输出，我们可以看到`bonnie++`进程实际上是进程`16052`的子进程，后者是`11243`的另一个子进程，后者是`vagrant`用户的bash
    shell。
- en: The preceding `ps` command has shown us that the `bonnie++` process with the
    process id of `16053` is waiting on I/O tasks. However, this does not tell us
    how much I/O this process is using; to determine this, we can read a special file
    in the `/proc` file system called `io`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`ps`命令告诉我们，进程ID为`16053`的`bonnie++`进程正在等待I/O任务。但是，这并没有告诉我们这个进程正在使用多少I/O；为了确定这一点，我们可以读取`/proc`文件系统中的一个特殊文件，名为`io`。
- en: '[PRE46]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Every running process has a subfolder in `/proc` with the same name as the process
    `id`; for our example, this is `/proc/16053`. This folder is maintained by the
    kernel for each running process, and within these folders exist many files that
    contain information about running processes.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运行的进程在`/proc`中都有一个与进程`id`同名的子文件夹；对于我们的示例，这是`/proc/16053`。这个文件夹由内核维护，用于每个运行的进程，在这些文件夹中存在许多包含有关运行进程信息的文件。
- en: These files are so useful that they are actually the source of the `ps` command's
    information. One of these useful files is named `io`; the `io` file contains statistics
    about the number of reads and writes that the process has performed.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件非常有用，它们实际上是`ps`命令信息的来源之一。其中一个有用的文件名为`io`；`io`文件包含有关进程执行的读取和写入次数的统计信息。
- en: From the output of the cat command, we can see that this process has read and
    written approximately 1 GB of data. While this seems like a lot, it could be over
    a long period of time. To get a picture of how much this process is writing to
    disk, we can read this file again to capture the differences.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 从cat命令的输出中，我们可以看到这个进程已经读取和写入了大约1GB的数据。虽然这看起来很多，但可能是在很长一段时间内完成的。为了了解这个进程向磁盘写入了多少数据，我们可以再次读取这个文件以捕捉差异。
- en: '[PRE47]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It seems, however, that when we executed the cat command a second time, we received
    an error that the `io` file is no longer present. If we run the `ps` command again
    and use `grep` to search the output for the bonnie++ process, we can see that
    a `bonnie++` process is running; however, it is a new process with a new process
    `ID`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们第二次执行cat命令时，我们收到了一个错误，即`io`文件不再存在。如果我们再次运行`ps`命令并使用`grep`在输出中搜索`bonnie++`进程，我们会发现`bonnie++`进程正在运行；但是，它是一个新的进程，具有新的进程`ID`。
- en: '[PRE48]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As it seems that the child `bonnie++` processes are short-lived processes, following
    the I/O statistics by reading the `io` file may be quite difficult.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`bonnie++`子进程是短暂的进程，通过读取`io`文件来跟踪I/O统计可能会非常困难。
- en: iotop – A top top-like command for disk i/o
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: iotop - 一个用于磁盘I/O的类似top的命令
- en: Since these processes are starting and stopping so frequently, we can use the
    `iotop` command to identify which processes are utilizing I/O the most.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些进程频繁启动和停止，我们可以使用`iotop`命令来确定哪些进程最多地利用了I/O。
- en: '[PRE49]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding output from `iotop`, we can see some interesting I/O statistics.
    With `iotop`, we can see not only system-wide statistics such as **Total Disk
    Reads** per second and **Total Disk Writes** per second but also quite a few statistics
    for single processes.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在`iotop`的输出中，我们可以看到一些有趣的I/O统计信息。通过`iotop`，我们不仅可以看到系统范围的统计信息，比如每秒的**总磁盘读取**和**总磁盘写入**，还可以看到单个进程的许多统计信息。
- en: From the per-process perspective, we can see that the `bonnie++` process is
    reading from disk at a rate of 101.96 MBps and is writing to disk at a rate of
    26.96 MBps.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 从每个进程的角度来看，我们可以看到`bonnie++`进程正在以101.96 MBps的速度从磁盘读取数据，并以26.96 MBps的速度向磁盘写入数据。
- en: '[PRE50]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `iotop` command is very similar to the top command in that it will refresh
    the reported results every few seconds. This has the effect of showing the I/O
    statistics "live."
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`iotop`命令与top命令非常相似，它会每隔几秒刷新报告的结果。这样做的效果是实时显示I/O统计信息。'
- en: Tip
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Commands such as `top` and `iotop` are very difficult to show in a book format.
    I highly suggest executing these commands on a system that has them available
    to get a feel of how they work.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`top`和`iotop`之类的命令在书本格式中很难展示。我强烈建议在具有这些命令的系统上执行这些命令，以了解它们的工作方式。
- en: Putting it all together
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整合起来
- en: Now that we have covered some of the tools for troubleshooting disk performance
    and utilization, let's put it all together while troubleshooting our reported
    slowness.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一些用于故障排除磁盘性能和利用率的工具，让我们在解决报告的缓慢时将它们整合起来。
- en: Using iostat to determine whether there is a I/O bandwidth problem
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用iostat来确定是否存在I/O带宽问题
- en: The first command that we will run is `iostat`, as this will first validate
    for us whether there is in fact an issue or not.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先运行的命令是`iostat`，因为这将首先为我们验证是否确实存在问题。
- en: '[PRE51]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'From the output of `iostat`, we can determine the following:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 从`iostat`的输出中，我们可以确定以下信息：
- en: The CPU of this system is currently spending quite a bit of time waiting for
    I/O, 30%–40%
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该系统的CPU目前花费了相当多的时间在等待I/O，占30%–40%。
- en: It appears that the `dm-1` and `sda` devices are the most-utilized devices
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看起来`dm-1`和`sda`设备是利用率最高的设备
- en: From `iostat`, it appears that these devices are at 68% utilization, a number
    that seems is quite high
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`iostat`来看，这些设备的利用率为68%，这个数字似乎相当高
- en: On the basis of these data points, we can identify that there is a potential
    I/O utilization issue, unless 68% utilization is expected.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些数据点，我们可以确定存在潜在的I/O利用率问题，除非68%的利用率是预期的。
- en: Using iotop to determine which processes are consuming disk bandwidth
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用iotop来确定哪些进程正在消耗磁盘带宽
- en: Now that we have determined that a sizeable amount of CPU time is being spent
    waiting for I/O, we should now focus on what processes are utilizing disks the
    most. To do this, we will use the `iotop` command.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了大量的CPU时间被用于等待I/O，我们现在应该关注哪些进程最多地利用了磁盘。为了做到这一点，我们将使用`iotop`命令。
- en: '[PRE52]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: From the `iotop` command, we can see that process `20262`, which is running
    the `bonnie++` command, has a high utilization along with large disk read and
    write values.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 从`iotop`命令中，我们可以看到进程`20262`，它正在运行`bonnie++`命令，具有高利用率以及大量的磁盘读写值。
- en: 'From `iotop`, we can determine the following:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 从`iotop`中，我们可以确定以下信息：
- en: The system's total disk reads per second is 100.64 MBps
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的每秒总磁盘读取量为100.64 MBps
- en: The system's total disk writes per second is 23.91 MBps
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的每秒总磁盘写入量为23.91 MBps
- en: Process `20262` running the `bonnie++` command is reading 100.35 MBps and writing
    23.91 MBps
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`bonnie++`命令的进程`20262`正在读取100.35 MBps，写入23.91 MBps
- en: Comparing the totals, we find that process `20262` is the majority contributor
    of disk reads and writes
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较总数，我们发现进程`20262`是磁盘读写的主要贡献者
- en: Given the above, it seems that we will need to identify more information about
    process `20262`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于上述情况，似乎我们需要更多地了解进程`20262`的信息。
- en: Using ps to understand more about processes
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用ps来更多地了解进程
- en: Now that we have identified a process that is using a significant amount of
    I/O, we can investigate the details of this process with the `ps` command. We
    will once again use the `ps` command with the `--forest` flag to show the parent
    and child process relationship.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了一个使用大量I/O的进程，我们可以使用`ps`命令来调查这个进程的详细信息。我们将再次使用带有`--forest`标志的`ps`命令来显示父进程和子进程的关系。
- en: '[PRE53]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Using the `ps` command, we can determine the following:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ps`命令，我们可以确定以下内容：
- en: The `bonnie++` process `20262` identified with `iotop` is absent; however, other
    `bonnie++` processes are present
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用`iotop`识别的`bonnie++`进程`20262`不见了；然而，其他`bonnie++`进程存在
- en: The `vagrant` user has started the parent `bonnie++` processes by using the
    `sudo` command
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vagrant`用户已经通过使用`sudo`命令启动了父`bonnie++`进程'
- en: The `vagrant` user is the same user as the user in the earlier observations
    discussed in the CPU and memory sections
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vagrant`用户与早期观察中讨论的CPU和内存部分的用户相同'
- en: Given the above details, it seems that the vagrant user is a likely suspect
    for our performance issues.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于上述细节，似乎`vagrant`用户是我们性能问题的嫌疑人。
- en: Network
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络
- en: The final common resource for performance issues is the network. There are many
    tools to troubleshoot networking issues; however, very few of these commands are
    geared solely towards network performance. Most of these tools are designed for
    in-depth network troubleshooting.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 性能问题的最后一个常见资源是网络。有许多工具可以用来排除网络问题；然而，这些命令中很少有专门针对网络性能的。大多数这些工具都是为深入的网络故障排除而设计的。
- en: Since [Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting* is dedicated
    to troubleshooting network issues, this section will focus specifically on performance.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 由于[第5章](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4 "第5章。网络故障排除")，*网络故障排除*专门用于解决网络问题，本节将专门关注性能。
- en: ifstat – Review interface statistics
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ifstat - 查看接口统计
- en: When it comes to a network, there are about four metrics that can be used to
    measure throughput.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络方面，有大约四个指标可以用来衡量吞吐量。
- en: '**Received Packets**: Number of packets received by the interface'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收数据包**：接口接收的数据包数量'
- en: '**Sent Packets**: Number of packets sent out by the interface'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发送数据包**：接口发送的数据包数量'
- en: '**Received Data**: Amount of data received by the interface'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收数据**：接口接收的数据量'
- en: '**Sent Data**: Amount of data sent by the interface'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发送数据**：接口发送的数据量'
- en: There are many commands that can provide these metrics, everything from `ifconfig`
    or `ip` to `netstat`. A very useful utility that specifically outputs these metrics
    is the `ifstat` command.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多命令可以提供这些指标，从`ifconfig`或`ip`到`netstat`都有。一个非常有用的专门输出这些指标的实用程序是`ifstat`命令。
- en: '[PRE54]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Much like `vmstat` or `iostat`, the first report generated by `ifstat` is based
    on statistics since the server last rebooted. What this means is that the above
    report indicates that the `enp0s3` interface has received 70,579 packets since
    the last reboot.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 与`vmstat`或`iostat`类似，`ifstat`生成的第一个报告是基于服务器上次重启以来的统计数据。这意味着上面的报告表明`enp0s3`接口自上次重启以来已接收了70,579个数据包。
- en: When executing `ifstat` a second time, the results will show a very large disparity
    from the first report. The reason for this is that the second report is based
    on the time since the first report.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当第二次执行`ifstat`时，结果将与第一个报告有很大的差异。原因是第二个报告是基于自第一个报告以来的时间。
- en: '[PRE55]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the example above, we can see that our system received 23 packets (RX Pkts)
    and transmitted 18 packets (`TX Pkts`) over the `enp0s3` interface.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们可以看到我们的系统通过`enp0s3`接口接收了23个数据包（RX Pkts）并发送了18个数据包（`TX Pkts`）。
- en: 'From the `ifstat` command, we can determine the following about our system:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ifstat`命令，我们可以确定以下关于我们的系统的内容：
- en: The network utilization at the moment is fairly small and not likely to cause
    an impact on this system as a whole
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前的网络利用率相当小，不太可能对整个系统造成影响
- en: The processes from the `vagrant` user shown earlier are not likely utilizing
    a significant amount of network resources
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 早期显示的`vagrant`用户的进程不太可能利用大量网络资源
- en: Based on the statistics seen with `ifstat`, there is minimal network traffic
    on this system, and is not likely causing the perceived slowness.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`ifstat`所见的统计数据，在这个系统上几乎没有网络流量，不太可能导致感知到的缓慢。
- en: Quick review of what we have identified
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对我们已经确定的内容进行快速回顾
- en: 'Before going too far ahead, let''s review what we have learned from the performance
    statistics that we have gathered thus far:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们回顾一下到目前为止我们从性能统计数据中学到的东西：
- en: Note
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `vagrant` user has been launching processes that run the `bonnie++` and
    `lookbusy` applications.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`vagrant`用户一直在启动运行`bonnie++`和`lookbusy`应用程序的进程。'
- en: The `lookbusy` application seems to either use up to 20%–30% of the overall
    system CPU.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookbusy`应用程序似乎要么一直占用整个系统CPU的20%–30%。'
- en: This server in question has two CPUs and `lookbusy` seems to utilize about 60%
    of one CPU consistently.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务器有两个CPU，`lookbusy`似乎一直占用一个CPU的大约60%。
- en: The `lookbusy` application also seems to use around 200 MB of memory consistently;
    however, during troubleshooting, we did see these processes using almost all of
    the system's memory causing the system to swap.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookbusy`应用程序似乎也一直使用大约200 MB的内存；然而，在故障排除期间，我们确实看到这些进程几乎使用了系统的所有内存，导致系统交换。'
- en: While the `vagrant` user was launching the `bonnie++` process the system was
    experiencing a high I/O wait time.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动`bonnie++`进程时，`vagrant`用户的系统经历了高I/O等待时间。
- en: When running, the `bonnie++` processes were utilizing approximately 60%–70%
    of the disk throughput.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，`bonnie++`进程利用了大约60%–70%的磁盘吞吐量。
- en: The activity being performed by the `vagrant` user seems to have little to no
    effect on network utilization.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`vagrant`用户正在执行的活动似乎对网络利用率几乎没有影响。'
- en: Comparing historical metrics
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较历史指标
- en: Looking at all of the facts that we learned about this system so far, it seems
    that our next best course of action would be to recommend contacting the `vagrant`
    user to identify whether the `lookbusy` and `bonnie++` applications should be
    running with such high resource utilization.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 从迄今为止我们了解到的所有事实来看，我们下一个最佳行动方案似乎是建议联系`vagrant`用户，以确定`lookbusy`和`bonnie++`应用程序是否应该以如此高的资源利用率运行。
- en: While the previous observations show a high resource utilization, this level
    of utilization may be expected for this environment. Before we start contacting
    users, we should first review the historical performance metrics of this server.
    In most environments, there is some sort of server performance monitoring software
    such as Munin, Cacti, or one of the many cloud SaaS providers in place that collects
    and stores system statistics.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管先前的观察显示了高资源利用率，但这种利用率水平可能是预期的。在开始联系用户之前，我们应该首先审查服务器的历史性能指标。在大多数环境中，都会有一些服务器性能监控软件，如Munin、Cacti或许多云SaaS提供商之一，用于收集和存储系统统计信息。
- en: If your environment utilizes one of these services, you can use the collected
    performance data to compare previous performance statistics with the information
    that we just gathered. If for instance over the past 30 days, the CPU performance
    was never higher than 10%, it stands to reason that the `lookbusy` processes may
    not have been running at that time.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的环境使用了这些服务，您可以使用收集的性能数据来将以前的性能统计与我们刚刚收集到的信息进行比较。例如，在过去30天中，CPU性能从未超过10%，那么`lookbusy`进程可能在那个时候没有运行。
- en: Even if your environment does not utilize one of these tools, you still may
    be able to perform the historical comparisons. To do so, we will use a tool that
    is installed by default on most Red Hat Enterprise Linux systems; this tool is
    called `sar`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您的环境没有使用这些工具之一，您仍然可以执行历史比较。为此，我们将使用一个默认安装在大多数Red Hat Enterprise Linux系统上的工具；这个工具叫做`sar`。
- en: sar – System activity report
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sar – 系统活动报告
- en: In [Chapter 2](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 2. Troubleshooting Commands and Sources of Useful Information"), *Troubleshooting
    Commands and Sources of Useful Information* we briefly discussed the use of the
    `sar` command to review historical performance statistics.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4 "第2章。故障排除命令和有用信息来源")，*故障排除命令和有用信息来源*中，我们简要讨论了使用`sar`命令来查看历史性能统计信息。
- en: When the `sysstat` package that deploys the `sar` utility is installed, it will
    deploy the `/etc/cron.d/sysstat` file. Within this file are two `cron` jobs that
    run `sysstat` commands with the sole purpose of collecting system performance
    statistics and generating reports of the collected information.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装了部署`sar`实用程序的`sysstat`软件包时，它将部署`/etc/cron.d/sysstat`文件。在这个文件中有两个`cron`作业，运行`sysstat`命令，其唯一目的是收集系统性能统计信息并生成收集信息的报告。
- en: '[PRE56]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When these commands are executed, the information collected is then stored in
    the `/var/log/sa/` folder.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行这些命令时，收集的信息将存储在`/var/log/sa/`文件夹中。
- en: '[PRE57]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The data files that the `sysstat` package generates use a filename that follows
    the "`sa<two digit day>`" format. For example, in the above output, we can see
    that the "`sa24`" file was generated on January 24th. We can also see that this
    system has files from January 23rd to February 9th.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`sysstat`软件包生成的数据文件使用遵循“`sa<两位数的日期>`”格式的文件名。例如，在上面的输出中，我们可以看到“`sa24`”文件是在1月24日生成的。我们还可以看到这个系统有从1月23日到2月9日的文件。'
- en: The `sar` command is a command that allows us to read these captured performance
    metrics. This section will show you how to use the `sar` command to review the
    same statistics that we reviewed earlier with commands such as `iostat`, `top`,
    and `vmstat`. This time, however, the `sar` command will provide both recent and
    historical information.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`sar`命令是一个允许我们读取这些捕获的性能指标的命令。本节将向您展示如何使用`sar`命令来查看与`iostat`、`top`和`vmstat`等命令之前查看的相同统计信息。然而，这次`sar`命令将提供最近和历史信息。'
- en: CPU
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CPU
- en: To look at CPU statistics with the `sar` command, we can simply use the `–u`
    (CPU Utilization) flag.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`sar`命令查看CPU统计信息，我们可以简单地使用`–u`（CPU利用率）标志。
- en: '[PRE58]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: If we look at the header information from above, we can see that the `sar` command
    with the `-u` flag matches the `iostat` and top CPU details.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从上面的头信息中查看，我们可以看到带有`-u`标志的`sar`命令与`iostat`和top CPU详细信息相匹配。
- en: '[PRE59]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'From the `sar -u` output, we can identify an interesting trend: from 00:00
    to 05:30, there was a constant CPU I/O wait time of 30%–40%. However, as of 05:40,
    the I/O wait decreased, but the user-level CPU utilization increased to 65%–70%
    utilization.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 从`sar -u`的输出中，我们可以发现一个有趣的趋势：从00:00到05:30，CPU I/O等待时间保持在30%–40%。然而，从05:40开始，I/O等待时间减少，但用户级CPU利用率增加到65%–70%。
- en: While these two measurements don't specifically point to any one process, they
    do show that the I/O wait time has decreased recently while the user CPU time
    has increased.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个测量并没有明确指向任何一个过程，但它们表明I/O等待时间最近已经减少，而用户CPU时间已经增加。
- en: To get a better picture of historical statistics, we will need to look at the
    previous day's CPU utilization. Luckily, we can do just that with the `–f` (filename)
    flag. The `–f` flag will allow us to specify a historical file for the `sar` command.
    This will allow us to selectively view statistics from the previous day.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解历史统计信息，我们需要查看前一天的CPU利用率。幸运的是，我们可以使用`–f`（文件名）标志来做到这一点。`–f`标志将允许我们为`sar`命令指定一个历史文件。这将允许我们有选择地查看前一天的统计信息。
- en: '[PRE60]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the report from February 7th, we can see a drastic difference in CPU utilization
    than what was identified during our previous troubleshooting. One item that stands
    out is that in the report from the 7th, no CPU time was spent in the I/O wait
    state.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在2月7日的报告中，我们可以看到CPU利用率与我们之前的故障排除所发现的情况有很大的不同。一个突出的问题是，在7日的报告中，没有CPU时间花费在I/O等待状态。
- en: However, we do see that the user CPU time fluctuated from 20% to 65% depending
    on the time of day. This may indicate that a higher user CPU time utilization
    is expected.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们看到用户CPU时间根据一天中的时间波动从20%到65%不等。这可能表明预期会有更高的用户CPU时间利用率。
- en: Memory
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存
- en: To display memory statistics, we can execute the `sar` command with the `–r`
    (memory) flag.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示内存统计信息，我们可以使用带有`-r`（内存）标志的`sar`命令。
- en: '[PRE61]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Again, if we look at the header from the memory report of `sar`, we can see
    some familiar values.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，如果我们查看`sar`的内存报告标题，我们可以看到一些熟悉的值。
- en: '[PRE62]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: From this report, we can see from the **kbmemused** column that as of 05:40,
    the system suddenly freed up 150 MB of physical memory. It appears from the `kbcached`
    column that this 150 MB of memory was allocated to the disk cache. This is based
    on the fact that at 05:40, the cached memory went from 196 MB to 22 MB.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 从这份报告中，我们可以看到在05:40时，系统突然释放了150MB的物理内存。从`kbcached`列可以看出，这150MB的内存被分配给了磁盘缓存。这是基于05:40时，缓存内存从196MB下降到22MB的事实。
- en: What is interesting is that this aligns with the CPU utilization change that
    also occurred at 05:40\. If we wished to review historical memory utilization,
    we could also use the `-f` (filename) flag with the `-r` (memory) flag. However,
    since we can see a rather obvious trend at 05:40, we will focus on this time for
    now.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这与CPU利用率的变化在05:40也是一致的。如果我们希望回顾历史内存利用情况，我们也可以使用带有`-f`（文件名）标志和`-r`（内存）标志。然而，由于我们可以看到05:40有一个相当明显的趋势，我们现在将重点放在这个时间上。
- en: Disk
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 磁盘
- en: To show disk statistics for today, we can use the `–d` (block device) flag.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示今天的磁盘统计信息，我们可以使用`-d`（块设备）标志。
- en: '[PRE63]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: By default, the `sar` command will print the device name as "`dev<major>-<minor>`,"
    which can be a bit confusing. If the `-p` (persistent names) flag is added, the
    device names will use persistent names, which match the devices from the mount
    command.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`sar`命令将打印设备名称为“`dev<major>-<minor>`”，这可能有点令人困惑。如果添加了`-p`（持久名称）标志，设备名称将使用持久名称，与挂载命令中的设备匹配。
- en: '[PRE64]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Even with the names in an unrecognizable format, we can see that `dev253-1`
    seems to have had quite a bit of activity up to 05:40, where the disk `tps` (transactions
    per seconds) decreases from 1170 to 0.11\. This large drop in disk I/O utilization
    seems to indicate that a rather large change occurred at `05:40` today.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 即使名称以不可识别的格式显示，我们也可以看到`dev253-1`似乎在05:40之前有相当多的活动，磁盘`tps`（每秒事务）从1170下降到0.11。磁盘I/O利用率的大幅下降似乎表明今天在05:40发生了相当大的变化。
- en: Network
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络
- en: To show network statistics, we will need to execute the `sar` command with the
    `–n DEV` flag.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示网络统计信息，我们需要使用带有`-n DEV`标志的`sar`命令。
- en: '[PRE65]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In the network statistics report, we see no change throughout the day. This
    suggests that, overall, there has never been any network performance bottlenecks
    associated with this server.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络统计报告中，我们看到整天都没有变化。这表明，总体上，这台服务器从未出现与网络性能瓶颈相关的问题。
- en: Review what we learned by comparing historical statistics
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过比较历史统计数据来回顾我们所学到的内容
- en: After looking through historical statistics with `sar` and recent statistics
    using commands such as `ps`, `iostat`, `vmstat`, and `top`, we can come to the
    following conclusions regarding our "slow performance."
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`sar`查看历史统计数据和使用`ps`、`iostat`、`vmstat`和`top`等命令查看最近的统计数据后，我们可以得出关于我们的“性能慢”的以下结论。
- en: Since we were asked by one of our peers to investigate the issue, our conclusions
    will be formatted in the form of an e-mail reply to this peer.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们被同事要求调查这个问题，我们的结论将以电子邮件回复的形式发送给这位同事。
- en: '*Hi Bob!*'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '*嗨鲍勃！*'
- en: '*I looked into that one server where the user said the server was "slow." It
    seems that the user called vagrant has been running multiple instances of two
    main programs. The first being the lookbusy application, which seems to use roughly
    20%–40% CPU at all times. However, in at least one instance, the lookbusy application
    also used a great deal of memory, exhausting the system of physical memory and
    forcing the system to swap heavily. However, this process did not last very long.*'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '*我调查了一个用户说服务器“慢”的服务器。看起来用户vagrant一直在运行两个主要程序的多个实例。第一个是lookbusy应用程序，似乎始终使用大约20%–40%的CPU。然而，至少有一个实例中，lookbusy应用程序还使用了大量内存，耗尽了物理内存并迫使系统大量交换。然而，这个过程并没有持续很长时间。*'
- en: '*The second program was the bonnie++ application, which seems to utilize a
    lot of disk I/O resources. While the vagrant user was running the bonnie++ application,
    it utilized approximately 60% of the dm-1 and sda disk bandwidths, causing a high
    I/O wait of around 30%. Typically, this system has an I/O wait of 0% (confirmed
    via sar).*'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '*第二个程序是bonnie++应用程序，似乎利用了大量的磁盘I/O资源。当vagrant用户运行bonnie++应用程序时，它占用了大约60%的dm-1和sda磁盘带宽，导致了大约30%的高I/O等待。通常，这个系统的I/O等待为0%（通过sar确认）。*'
- en: '*It seems that the vagrant user may be running applications that are using
    resources beyond the expected levels, causing performance degradation for the
    other users.*'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '*看起来vagrant用户可能正在运行超出预期水平的应用程序，导致其他用户的性能下降。*'
- en: Summary
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started to use some advanced Linux commands that we explored
    in [Chapter 2](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 2. Troubleshooting Commands and Sources of Useful Information"), *Troubleshooting
    Commands and Sources of Useful Information* such as `iostat` and `vmstat`. We
    also became very familiar with a fundamental utility within Linux, the `ps` command,
    while troubleshooting a vague performance issue.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始使用一些高级的Linux命令，这些命令在[第2章](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4
    "第2章。故障排除命令和有用信息的来源")中进行了探索，例如`iostat`和`vmstat`。我们还对Linux中的一个基本实用程序`ps`命令非常熟悉，同时解决了一个模糊的性能问题。
- en: While in [Chapter 3](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 3. Troubleshooting a Web Application"), *Troubleshooting a Web Application*
    we were able to follow the full troubleshooting process from Data Collection to
    Trial and Error, in this chapter, our actions were primarily focused on the Data
    Collection and Establishing a Hypothesis stages. It is quite common to find yourself
    only troubleshooting an issue and not performing corrective actions. There are
    many issues that should be resolved by a user of the system and not the systems
    administrator, but it is still the administrator's role to identify the source
    of the issue.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4 "第3章。故障排除Web应用程序")中，*故障排除Web应用程序*，我们能够从数据收集到试错的完整故障排除过程，而在本章中，我们的行动主要集中在数据收集和建立假设阶段。发现自己只是在解决问题而不是执行纠正措施是非常常见的。有许多问题应该由系统的用户而不是系统管理员来解决，但管理员的角色仍然是识别问题的来源。
- en: In [Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting* we will be troubleshooting
    some very interesting network issues. Networking is critical to any system; issues
    can sometimes be simple, and at other times, they are very complex. In the next
    chapter, we will explore networking and how to troubleshoot network issues by
    using tools such as `netstat` and `tcpdump`.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4 "第5章。网络故障排除")中，*网络故障排除*，我们将解决一些非常有趣的网络问题。网络对于任何系统都至关重要；问题有时可能很简单，而有时则非常复杂。在下一章中，我们将探讨网络和如何使用诸如`netstat`和`tcpdump`之类的工具来排除网络问题。
