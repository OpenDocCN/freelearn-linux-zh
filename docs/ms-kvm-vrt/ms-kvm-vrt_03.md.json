["```\nvirsh --connect qemu+ssh://root@remoteserver.yourdomain.com/system list \u2013\u2013all\n```", "```\n[root@kvmsource]# yum -y install git-core\n[root@kvmsource]# git clone git://libvirt.org/libvirt.git\n```", "```\nstruct _virConnectDriver {\n\u00a0\u00a0\u00a0\u00a0virHypervisorDriverPtr hypervisorDriver;\n\u00a0\u00a0\u00a0\u00a0virInterfaceDriverPtr interfaceDriver;\n\u00a0\u00a0\u00a0\u00a0virNetworkDriverPtr networkDriver;\n\u00a0\u00a0\u00a0\u00a0virNodeDeviceDriverPtr nodeDeviceDriver;\n\u00a0\u00a0\u00a0\u00a0virNWFilterDriverPtr nwfilterDriver;\n\u00a0\u00a0\u00a0\u00a0virSecretDriverPtr secretDriver;\n\u00a0\u00a0\u00a0\u00a0virStorageDriverPtr storageDriver;\n\u00a0\u00a0\u00a0\u00a0\u00a0};\n```", "```\nstatic virDrvOpenStatus qemuConnectOpen(virConnectPtr conn,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0virConnectAuthPtr auth ATTRIBUTE_UNUSED,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int flags)\n```", "```\nfrom\u00a0\u00a0(qemu_capabilities.c)\nstatic int virQEMUCapsInitGuest ( ..,\u00a0\u00a0.. ,\u00a0\u00a0virArch hostarch,\u00a0\u00a0virArch guestarch)\n{\n...\nbinary = virQEMUCapsFindBinaryForArch (hostarch, guestarch);\n...\nnative_kvm = (hostarch == guestarch);\nx86_32on64_kvm = (hostarch == VIR_ARCH_X86_64 &&\u00a0\u00a0guestarch == VIR_ARCH_I686);\n...\nif (native_kvm || x86_32on64_kvm || arm_32on64_kvm || ppc64_kvm) {\n\u00a0\u00a0\u00a0\u00a0const char *kvmbins[] = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"/usr/libexec/qemu-kvm\", /* RHEL */\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"qemu-kvm\", /* Fedora */\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"kvm\", /* Debian/Ubuntu */\u00a0\u00a0\u00a0\u00a0\u2026};\n...\nkvmbin = virFindFileInPath(kvmbins[i]); \n...\nvirQEMUCapsInitGuestFromBinary (caps, binary, qemubinCaps, kvmbin, kvmbinCaps,guestarch);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n...\n}\n```", "```\nint virQEMUCapsInitGuestFromBinary(..., *binary, qemubinCaps, *kvmbin, kvmbinCaps, guestarch)\n{\n\u2026\u2026...\n\u00a0\u00a0if (virFileExists(\"/dev/kvm\") && (virQEMUCapsGet(qemubinCaps, QEMU_CAPS_KVM) ||\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0virQEMUCapsGet(qemubinCaps, QEMU_CAPS_ENABLE_KVM) ||\u00a0\u00a0\u00a0\u00a0\u00a0kvmbin))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0haskvm = true;\n```", "```\nutil/vircommand.c\nstatic int virExec(virCommandPtr cmd) {\n\u2026...\n\u00a0\u00a0if (cmd->env)\n\u00a0\u00a0\u00a0\u00a0execve(binary, cmd->args, cmd->env);\n\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0execv(binary, cmd->args);\n```", "```\n# git clone git://git.qemu-project.org/qemu.git\n```", "```\nstruct KVMState\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0( kvm-all.c ) \n{\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026..\n\u00a0\u00a0int fd;\n\u00a0\u00a0int vmfd;\n\u00a0\u00a0int coalesced_mmio;\n\u00a0\u00a0\u00a0\u00a0struct kvm_coalesced_mmio_ring *coalesced_mmio_ring; \u2026.}\n```", "```\nstruct CPUState {\n\u2026..\n\u00a0\u00a0int nr_cores;\n\u00a0\u00a0int nr_threads;\n\u00a0\u00a0\u2026\n\u00a0\u00a0int kvm_fd;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026.\n\u00a0\u00a0struct KVMState *kvm_state;\n\u00a0\u00a0struct kvm_run *kvm_run\n}\n```", "```\ntypedef struct CPUX86State ( target/i386/cpu.h )\n {\n\u00a0\u00a0/* standard registers */\n\u00a0\u00a0target_ulong regs[CPU_NB_REGS];\n\u2026.\n\u00a0\u00a0uint64_t system_time_msr;\n\u00a0\u00a0uint64_t wall_clock_msr;\n\u2026\u2026.\n\u00a0\u00a0/* exception/interrupt handling */\n\u00a0\u00a0int error_code;\n\u00a0\u00a0int exception_is_int;\n\u2026...\n}\n```", "```\n    kvm_ioctl(s, KVM_CHECK_EXTENSION, extension);\n    kvm_ioctl(s, KVM_CREATE_VM, type);\n    ```", "```\n    kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)vcpu_id);\n    kvm_vm_ioctl(s, KVM_SET_USER_MEMORY_REGION, &mem);\n    ```", "```\n    kvm_vcpu_ioctl(cpu, KVM_RUN, 0);\n    ```", "```\n    kvm_device_ioctl(dev_fd, KVM_HAS_DEVICE_ATTR, &attribute) ? 0 : 1;\n    ```", "```\nstatic int kvm_init(MachineState *ms)\n{ \n\u2026..\nKVMState *s;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0s = KVM_STATE(ms->accelerator);\n\u00a0\u00a0\u00a0\u00a0\u2026\n\u00a0\u00a0\u00a0\u00a0s->vmfd = -1;\n\u00a0\u00a0\u00a0\u00a0s->fd = qemu_open(\"/dev/kvm\", O_RDWR);\u00a0\u00a0\u00a0----> [1]\n\u00a0\u00a0\u00a0\u00a0..\n\u00a0\u00a0\u00a0\u00a0\u00a0do {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = kvm_ioctl(s, KVM_CREATE_VM, type); --->[2]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} while (ret == -EINTR);\n\u00a0\u00a0\u00a0\u00a0\u00a0s->vmfd = ret;\n\u2026.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = kvm_arch_init(ms, s);\u00a0\u00a0\u00a0---> ( target-i386/kvm.c: ) \n.....\n\u00a0\u00a0}\n```", "```\nmain() ->\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-> cpu_init(cpu_model);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[#define cpu_init(cpu_model) CPU(cpu_x86_init(cpu_model)) ]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0->cpu_x86_create()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0->qemu_init_vcpu\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0->qemu_kvm_start_vcpu()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0->qemu_thread_create\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0->qemu_kvm_cpu_thread_fn()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-> kvm_init_vcpu(CPUState *cpu)\nint kvm_init_vcpu(CPUState *cpu)\n{\n\u00a0\u00a0KVMState *s = kvm_state;\n\u00a0\u00a0...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)kvm_arch_vcpu_id(cpu));\n\u00a0\u00a0cpu->kvm_fd = ret;\u00a0\u00a0\u00a0--->\u00a0\u00a0\u00a0[vCPU fd]\n\u00a0\u00a0..\n\u00a0\u00a0mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);\ncpu->kvm_run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,\u00a0\u00a0cpu->kvm_fd, 0);\u00a0\u00a0[3]\n...\n\u00a0\u00a0ret = kvm_arch_init_vcpu(cpu);\u00a0\u00a0\u00a0[target-i386/kvm.c]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026..\n}\n```", "```\nint kvm_cpu_exec(CPUState *cpu) {\n\u00a0\u00a0\u00a0struct kvm_run *run = cpu->kvm_run;\n\u00a0\u00a0..\n\u00a0\u00a0run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, 0);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0...\n}\n```", "```\n\u00a0\u00a0switch (run->exit_reason) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case KVM_EXIT_IO:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DPRINTF(\"handle_io\\n\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case KVM_EXIT_MMIO:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DPRINTF(\"handle_mmio\\n\");\n\u00a0\u00a0\u00a0case KVM_EXIT_IRQ_WINDOW_OPEN:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DPRINTF(\"irq_window_open\\n\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case KVM_EXIT_SHUTDOWN:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DPRINTF(\"shutdown\\n\");\n\u00a0\u00a0\u00a0\u00a0\u00a0case KVM_EXIT_UNKNOWN:\n\u00a0\u00a0\u00a0\u00a0...\n\u00a0\u00a0\u00a0\t\u00a0\u00a0case KVM_EXIT_INTERNAL_ERROR:\n\u00a0\u00a0\u00a0\u00a0\u2026\n\u00a0\u00a0\u00a0\tcase KVM_EXIT_SYSTEM_EVENT:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0switch (run->system_event.type) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case KVM_SYSTEM_EVENT_SHUTDOWN:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case KVM_SYSTEM_EVENT_RESET:\ncase KVM_SYSTEM_EVENT_CRASH:\n```", "```\n/*\u00a0\u00a0ioctls for /dev/kvm fds: */\n#define KVM_GET_API_VERSION\u00a0\u00a0\u00a0\u00a0\u00a0_IO(KVMIO,\u00a0\u00a0\u00a00x00)\n#define KVM_CREATE_VM\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0_IO(KVMIO,\u00a0\u00a0\u00a00x01) /* returns a VM fd */\n\u2026..\n/*\u00a0\u00a0ioctls for VM fds */\n#define KVM_SET_MEMORY_REGION\u00a0\u00a0\u00a0_IOW(KVMIO,\u00a0\u00a00x40, struct kvm_memory_region)\n#define KVM_CREATE_VCPU\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0_IO(KVMIO,\u00a0\u00a0\u00a00x41)\n\u2026\n/* ioctls for vcpu fds\u00a0\u00a0*/\n#define KVM_RUN\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0_IO(KVMIO,\u00a0\u00a0\u00a00x80)\n#define KVM_GET_REGS\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0_IOR(KVMIO,\u00a0\u00a00x81, struct kvm_regs)\n#define KVM_SET_REGS\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0_IOW(KVMIO,\u00a0\u00a00x82, struct kvm_regs)\n```", "```\nstatic struct file_operations kvm_chardev_ops = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.unlocked_ioctl = kvm_dev_ioctl,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.llseek\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= noop_llseek,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0KVM_COMPAT(kvm_dev_ioctl),\n};\n kvm_dev_ioctl () \n\u00a0\u00a0\u00a0\u00a0switch (ioctl) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case KVM_GET_API_VERSION:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (arg)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\tgoto out;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0r = KVM_API_VERSION;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case KVM_CREATE_VM:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0r = kvm_dev_ioctl_create_vm(arg);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case KVM_CHECK_EXTENSION:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0r = kvm_vm_ioctl_check_extension_generic(NULL, arg);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case KVM_GET_VCPU_MMAP_SIZE:\n\u00a0\u00a0.\u00a0\u00a0\u00a0\u00a0\u2026..\n}\n```", "```\nstatic struct file_operations kvm_vm_fops = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.release\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= kvm_vm_release,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.unlocked_ioctl = kvm_vm_ioctl,\n\u2026..\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.llseek\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= noop_llseek,\n};\nstatic struct file_operations kvm_vcpu_fops = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.release\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= kvm_vcpu_release,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.unlocked_ioctl = kvm_vcpu_ioctl,\n\u2026.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.mmap\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= kvm_vcpu_mmap,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.llseek\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= noop_llseek,\n};\n```", "```\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0anon_inode_getfd(name, &kvm_vcpu_fops, vcpu, O_RDWR | O_CLOEXEC);\n```", "```\ninclude/linux/kvm_host.h : \nstruct kvm {\n\u00a0\u00a0...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct mm_struct *mm; /* userspace tied to this vm */\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct kvm_vcpu *vcpus[KVM_MAX_VCPUS];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0....\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct kvm_io_bus __rcu *buses[KVM_NR_BUSES];\n\u2026.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct kvm_coalesced_mmio_ring *coalesced_mmio_ring;\n\u00a0\u00a0\u2026..\n}\n```", "```\nstruct kvm_vcpu {\n\u00a0\u00a0...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct kvm *kvm;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int cpu;\n\u2026..\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int vcpu_id;\n\u00a0\u00a0\u2026..\n\u00a0\u00a0\u00a0\tstruct kvm_run *run;\n\u00a0\u00a0\u2026...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct kvm_vcpu_arch arch;\n\u00a0\u00a0\u2026\n}\n```", "```\narch/x86/include/asm/kvm_host.h\nstruct kvm_vcpu_arch {\n..\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long regs[NR_VCPU_REGS];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long cr0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long cr0_guest_owned_bits;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026..\n\u00a0\u00a0\u00a0\tstruct kvm_lapic *apic;\u00a0\u00a0/* kernel irqchip context */\n\u00a0\u00a0\u00a0\t..\nstruct kvm_mmu mmu;\n..\nstruct kvm_pio_request pio;\nvoid *pio_data;\n..\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* emulate context */\n\u00a0\u00a0struct x86_emulate_ctxt emulate_ctxt;\n\u00a0\u00a0...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int (*complete_userspace_io)(struct kvm_vcpu *vcpu);\n\u00a0\u00a0\u2026.\n}\n```", "```\n/include/uapi/linux/kvm.h:\n/* for KVM_RUN, returned by mmap(vcpu_fd, offset=0) */\nstruct kvm_run {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* in */\n...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* out */\n...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* in (pre_kvm_run), out (post_kvm_run) */\n...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0union {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* KVM_EXIT_UNKNOWN */\n...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* KVM_EXIT_FAIL_ENTRY */\n...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* KVM_EXIT_EXCEPTION */\n...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* KVM_EXIT_IO */\nstruct {\n#define KVM_EXIT_IO_IN\u00a0\u00a00\n#define KVM_EXIT_IO_OUT 1\n...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} io;\n...\n}\n```", "```\nvcpu_vmx structure\nstruct vcpu_vmx {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct kvm_vcpu\u00a0\u00a0\u00a0\u00a0\u00a0*vcpu;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct loaded_vmcs\u00a0\u00a0vmcs01;\n\u00a0\u00a0\u00a0\u00a0\u00a0struct loaded_vmcs\u00a0\u00a0\u00a0*loaded_vmcs;\n\u00a0\u00a0\u00a0\u00a0\u2026.\n\u00a0\u00a0\u00a0\u00a0}\n```", "```\nvcpu_svm structure\nstruct vcpu_svm {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct kvm_vcpu *vcpu;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026\nstruct vmcb *vmcb;\n\u2026.\n\u00a0\u00a0\u00a0\u00a0}\n```", "```\nkvm_arch_vcpu_create()\n\u00a0\u00a0\u00a0\t\u00a0\u00a0\u00a0->kvm_x86_ops->vcpu_create\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0->vcpu_create()\u00a0\u00a0[.vcpu_create = svm_create_vcpu, .vcpu_create = vmx_create_vcpu,]\n```", "```\nQemu-kvm User Space:\nkvm_init_vcpu ()\n\u00a0\u00a0\u00a0\u00a0kvm_arch_init_vcpu()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0qemu_init_vcpu()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0qemu_kvm_start_vcpu()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0qemu_kvm_cpu_thread_fn()\n\u00a0\u00a0\u00a0\u00a0while (1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (cpu_can_run(cpu)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0r = kvm_cpu_exec(cpu);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\nkvm_cpu_exec (CPUState *cpu)\n\u00a0\u00a0\u00a0\u00a0->\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, 0);\n```", "```\nstatic struct kvm_x86_ops vmx_x86_ops = {\n\u00a0\u00a0\u00a0\u00a0...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.vcpu_create = vmx_create_vcpu,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.run = vmx_vcpu_run,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.handle_exit = vmx_handle_exit,\n\u2026\n}\n```", "```\nstatic struct kvm_x86_ops svm_x86_ops = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.vcpu_create = svm_create_vcpu,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.run = svm_vcpu_run,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.handle_exit = handle_exit,\n..\n}\n```", "```\nstatic long kvm_vcpu_ioctl(struct file *file,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int ioctl, unsigned long arg)\u00a0\u00a0{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0switch (ioctl) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case KVM_RUN:\n\u00a0\u00a0\u00a0\u00a0\u2026.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0kvm_arch_vcpu_ioctl_run(vcpu, vcpu->run);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0->vcpu_load\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-> vmx_vcpu_load\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0->vcpu_run(vcpu);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0->vcpu_enter_guest\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0->vmx_vcpu_run\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2026.\n}\n```", "```\nstatic int vcpu_run(struct kvm_vcpu *vcpu) {\n\u2026.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (;;) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (kvm_vcpu_running(vcpu)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0r = vcpu_enter_guest(vcpu);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0r = vcpu_block(kvm, vcpu);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n```", "```\nstatic int vcpu_enter_guest(struct kvm_vcpu *vcpu) {\n...\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0kvm_x86_ops.prepare_guest_switch(vcpu);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vcpu->mode = IN_GUEST_MODE;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0__kvm_guest_enter();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0kvm_x86_ops->run(vcpu);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[vmx_vcpu_run or svm_vcpu_run ]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0vcpu->mode = OUTSIDE_GUEST_MODE;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0kvm_guest_exit();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0r = kvm_x86_ops->handle_exit(vcpu);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[vmx_handle_exit or handle_exit ]\n\u2026\n}\n```", "```\nstatic int vmx_handle_exit(struct kvm_vcpu *vcpu, , fastpath_t exit_fastpath)\n{\n\u2026.. }\nstatic int (*const kvm_vmx_exit_handlers[])(struct kvm_vcpu *vcpu) = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EXIT_REASON_EXCEPTION_NMI]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= handle_exception,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EXIT_REASON_EXTERNAL_INTERRUPT]\u00a0\u00a0\u00a0\u00a0= handle_external_interrupt,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EXIT_REASON_TRIPLE_FAULT]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= handle_triple_fault,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EXIT_REASON_IO_INSTRUCTION]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= handle_io,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EXIT_REASON_CR_ACCESS]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= handle_cr,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EXIT_REASON_VMCALL]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= handle_vmcall,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EXIT_REASON_VMCLEAR]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= handle_vmclear,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[EXIT_REASON_VMLAUNCH]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\t= handle_vmlaunch,\n\u2026\n}\n```", "```\nstatic int handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)\n{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct vcpu_svm *svm = to_svm(vcpu);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct kvm_run *kvm_run = vcpu->run;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u32 exit_code = svm->vmcb->control.exit_code;\n\u2026.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return svm_exit_handlers[exit_code](svm);\n}\n```", "```\nkvm-all.c:\nstatic int (*const svm_exit_handlers[])(struct vcpu_svm *svm) = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[SVM_EXIT_READ_CR0]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= cr_interception,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[SVM_EXIT_READ_CR3]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= cr_interception,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[SVM_EXIT_READ_CR4]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0= cr_interception,\n\u2026.\n}\nswitch (run->exit_reason) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0case KVM_EXIT_IO:\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0DPRINTF(\"handle_io\\n\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* Called outside BQL */\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0kvm_handle_io(run->io.port, attrs,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(uint8_t *)run + run->io.data_offset,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0run->io.direction,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\t\u00a0\u00a0\u00a0\u00a0run->io.size,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\t\u00a0\u00a0\u00a0\u00a0run->io.count);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n```"]