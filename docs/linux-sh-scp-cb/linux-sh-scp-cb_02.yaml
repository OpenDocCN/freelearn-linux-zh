- en: Chapter 2. Have a Good Command
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。拥有一个好的命令
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Concatenating with cat
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用cat进行连接
- en: Recording and playback of terminal sessions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录和回放终端会话
- en: Finding files and file listing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找文件和文件列表
- en: Command output as argument to a command (xargs)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将命令输出作为命令的参数（xargs）
- en: Translating with tr
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用tr进行翻译
- en: Checksum and verification
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 校验和和验证
- en: Sorting, unique and duplicates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序、唯一和重复
- en: Temporary file naming and random numbers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时文件命名和随机数
- en: Splitting files and data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拆分文件和数据
- en: Slicing filenames based on extension
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于扩展名切分文件名
- en: Renaming files in bulk with rename and mv
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用rename和mv批量重命名文件
- en: Spell check and dictionary manipulation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拼写检查和字典操作
- en: Automating interactive input
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化交互输入
- en: Introduction
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Commands are beautiful components of UNIX-like systems. They help us achieve
    many tasks making our work easier. When you practise the use of commands everywhere,
    you will love it. Many circumstances make you say "wow!". Once you've had a chance
    to try some of the commands that Linux offers you to make your life easier and
    more productive, you'll wonder how you did without using them before. Some of
    my personal favorite commands are `grep`, `awk`, `sed` , and `find` .
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是UNIX-like系统中美丽的组件。它们帮助我们完成许多任务，使我们的工作更加轻松。当你在任何地方练习使用命令时，你会喜欢它。许多情况会让你说“哇！”一旦你有机会尝试Linux提供的一些命令，使你的生活更轻松和更高效，你会想知道在没有使用它们之前你是如何做的。我个人最喜欢的一些命令是`grep`、`awk`、`sed`和`find`。
- en: Using the UNIX/Linux command line is an art. You will get better at using it
    as you practice and gain experience. This chapter will introduce you to some of
    the most interesting and useful commands.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用UNIX/Linux命令行是一门艺术。随着练习和经验的积累，你会变得更擅长使用它。本章将向您介绍一些最有趣和有用的命令。
- en: Concatenating with cat
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cat进行连接
- en: '`cat` is one of the first commands which a command line warrior must learn.
    `cat` is a beautiful and simple command. It is usually used to read, display,
    or concatenate the contents of a file, but `cat` is capable of more than just
    that.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`是命令行战士必须学习的第一批命令之一。`cat`是一个美丽而简单的命令。它通常用于读取、显示或连接文件的内容，但`cat`不仅仅是这样。'
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We scratch our heads when we need to combine standard input data as well as
    data from a file using a single-line command. The regular way of combining `stdin`
    data as well as file data is to redirect `stdin` to a file and then append two
    files. But we can use the `cat` command to do it easily in a single invocation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要使用单行命令将标准输入数据与文件数据合并时，我们会感到困惑。将`stdin`数据与文件数据合并的常规方法是将`stdin`重定向到文件，然后追加两个文件。但是我们可以使用`cat`命令在单个调用中轻松完成。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: The `cat` command is a very simple command that is used very frequently in daily
    life. `cat` stands for concatenate.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`命令是一个非常简单的命令，在日常生活中经常使用。`cat`代表连接。'
- en: 'The general syntax of `cat` for reading a file''s contents is:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 读取文件内容的`cat`的一般语法是：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command outputs concatenated data from the files with file names provided
    as command-line arguments. For example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令输出作为命令行参数提供的文件的连接数据。例如：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: There are a lot of features that come along with `cat`. Let's walk through several
    usage techniques that are possible with `cat`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多功能与`cat`一起提供。让我们一起走过几种可能的`cat`使用技巧。
- en: The `cat` command not only can read from files and concatenate the data, but
    also can read the input from the standard input.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`命令不仅可以从文件中读取和连接数据，还可以从标准输入中读取输入。'
- en: 'In order to read from the standard input, use a pipe operator as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从标准输入中读取，使用管道操作符如下：
- en: '`OUTPUT_FROM_SOME COMMANDS | cat`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`某些命令的输出 | cat`'
- en: 'Similarly, we can concatenate content from input files along with standard
    input using `cat`. Combine `stdin` and data from another file, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`cat`将输入文件的内容与标准输入一起连接起来。将`stdin`和另一个文件的数据组合起来，如下所示：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code `-` acts as filename for `stdin` text.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`-`充当`stdin`文本的文件名。
- en: There's more...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The `cat` command has few other options for viewing files. Let's go through
    them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`命令还有其他一些查看文件的选项。让我们一起来看看。'
- en: Squeezing blank lines
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩空白行
- en: 'Sometimes many empty lines in text need to be squeezed into one to make it
    readable or for some other purpose. Squeeze adjacent blank lines in a text file
    by using the following syntax:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有时文本中的许多空行需要压缩成一个以便阅读或其他目的。使用以下语法在文本文件中压缩相邻的空行：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternately, we can remove all blank lines by using `tr` as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`tr`来删除所有空行，如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the above usage of `tr`, it squeezes adjacent '`\n'` characters into a single
    '`\n'` (newline character).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的`tr`使用中，它将相邻的'`\n'`字符压缩为单个'`\n'`（换行符）。
- en: Displaying tabs as ^I
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示制表符为^I
- en: 'It is hard to distinguish tabs and repeated space characters. While writing
    programs in languages like Python, it keeps special meaning for tabs and spaces
    for indentation purposes. They are treated differently. Therefore, the use of
    tab instead of spaces causes problems in indentation. It may become difficult
    to track where the misplacement of the tab or space occurred by looking through
    a text editor. `cat` has a feature that can highlight tabs. This is very helpful
    in debugging indentation errors. Use the `–T` option with `cat` to highlight tab
    characters as ^I. An example is as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 很难区分制表符和重复的空格字符。在编写像Python这样的语言的程序时，制表符和空格对缩进目的具有特殊意义。它们被不同对待。因此，使用制表符而不是空格会导致缩进问题。通过查看文本编辑器，可能很难跟踪制表符或空格的错误放置位置。`cat`有一个可以突出显示制表符的功能。这在调试缩进错误时非常有帮助。使用`cat`的`-T`选项来突出显示制表符字符为^I。例如：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Line numbers
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行号
- en: 'Using the `–n` flag for the `cat` command will output each line with a line
    number prefixed. It is to be noted that the `cat` command never changes a file;
    instead it produces an output on `stdout` with modifications to input according
    to the options provided. For example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对`cat`命令使用`-n`标志将输出每一行的行号前缀。需要注意的是，`cat`命令永远不会更改文件；相反，它根据提供的选项对输入进行修改，并在`stdout`上产生输出。例如：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Recording and playback of terminal sessions
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录和重播终端会话
- en: When you need to show somebody how to do something in the terminal or you need
    to prepare a tutorial on how to do something through command line, you would normally
    type the commands manually and show them. Or you could record a screencast video
    and playback the video to them. What if we can record the order and timing of
    the commands that we typed before and replay these commands again so that others
    can watch as if they were typing? The output of the commands gets displayed on
    the terminal until the playback is complete. Sounds interesting? It can be done
    using the commands `script` and `scriptreplay`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要向某人展示如何在终端中执行某项操作，或者需要准备关于如何通过命令行执行某项操作的教程时，通常会手动输入命令并展示给他们。或者您可以录制屏幕录像并向他们播放视频。如果我们可以记录之前输入的命令的顺序和时间，并重新播放这些命令，以便其他人可以观看并仿佛他们正在输入呢？命令的输出将显示在终端上，直到播放完成。听起来有趣吗？可以使用`script`和`scriptreplay`命令来实现。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: '`script` and `scriptreplay` commands are available in most of the GNU/Linux
    distributions. Recording the terminal sessions to a file will be interesting.
    You can create tutorials of command-line hacks and tricks to achieve some task
    by recording the terminal sessions. You can also share the recorded files for
    others to playback and see how to perform a particular task using the command
    line.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`script`和`scriptreplay`命令在大多数GNU/Linux发行版中都可用。将终端会话记录到文件中会很有趣。您可以通过记录终端会话来创建命令行技巧和窍门的教程，以实现某些任务。您还可以分享记录的文件供他人回放，并了解如何使用命令行执行特定任务。'
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We can start recording the terminal session as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始记录终端会话，如下所示：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Two configuration files are passed to the `script` command as arguments. One
    file is for storing timing information (`timing.log`) at which each of the commands
    are run, whereas the other file (`output.session`) is used for storing command
    output. The `-t` flag is used to dump timing data to `stderr`. `2>` is used to
    redirect `stderr` to `timing.log`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 两个配置文件作为参数传递给`script`命令。一个文件用于存储每个命令运行的时间信息（`timing.log`），而另一个文件（`output.session`）用于存储命令输出。使用`-t`标志将时间数据转储到`stderr`。使用`2>`将`stderr`重定向到`timing.log`。
- en: 'By using the two files, `timing.log` (stores timing information) and `output.session`
    (stores command output information), we can replay the sequence of command execution
    as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用两个文件，`timing.log`（存储时间信息）和`output.session`（存储命令输出信息），我们可以按以下方式重播命令执行的顺序：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Usually, we record the desktop video to prepare tutorials. However, videos require
    good amount of storage. But a terminal script file is just a text file. Therefore,
    it always has a file size only in the order of Kilobytes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会录制桌面视频来准备教程。但是，视频需要大量的存储空间。但是终端脚本文件只是一个文本文件。因此，它的文件大小通常只有几千字节。
- en: You can share the files `timing.log` and `output.session` with anyone who wants
    to replay a terminal session in their terminal.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以与任何想要在他们的终端中重播终端会话的人分享文件`timing.log`和`output.session`。
- en: The `script` command can also be used to set up a terminal session that can
    be broadcasted to multiple users. It is a very interesting experience. Let's see
    how to do it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`script`命令也可以用于设置可以广播给多个用户的终端会话。这是一种非常有趣的体验。让我们看看如何做。'
- en: Open two terminals, Terminal1 and Terminal2.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 打开两个终端，Terminal1和Terminal2。
- en: 'In Terminal1 enter the following command:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Terminal1中输入以下命令：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In Terminal2 enter the following command:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Terminal2中输入以下命令：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Go back to Terminal1 and enter the following command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到Terminal1并输入以下命令：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When you need to end the session, type `exit` and press *Return*. It will show
    the message "Script done, file is scriptfifo".
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要结束会话时，请输入`exit`并按*Return*。它将显示消息“脚本完成，文件为scriptfifo”。
- en: Now Terminal1 is the broadcaster and Terminal2 is the receiver.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Terminal1是广播者，Terminal2是接收者。
- en: 'When you type anything in real-time on Terminal1, it will be played on Terminal2
    or any terminal that supplies the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在Terminal1上实时输入任何内容时，它将在Terminal2或任何提供以下命令的终端上播放：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This method can be used when handling a tutorial session for many users in a
    computer lab or over the Internet. It will save bandwidth as well as provide a
    real-time experience.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机实验室或互联网上处理多个用户的教程会话时，可以使用此方法。这将节省带宽，并提供实时体验。
- en: Finding files and file listing
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找文件和文件列表
- en: '`find` is one of the great utilities in the UNIX/Linux command-line toolbox.
    It is a very useful command for shell scripts, but most people do not use it effectively
    due to the lack of understanding. This recipe deals with most of the use cases
    of `find` and how it can be used to solve problems of different criterions.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`是UNIX/Linux命令行工具箱中的伟大实用程序之一。它是shell脚本的非常有用的命令，但由于缺乏理解，大多数人并不有效地使用它。本教程涵盖了`find`的大多数用例以及如何使用它来解决不同标准的问题。'
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The `find` command uses the following strategy: `find` descends through a hierarchy
    of files, matches the files that meet specified criteria, and performs some actions.
    Let''s go through different use cases of find and the basic usages.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`命令使用以下策略：`find`通过文件层次结构进行匹配，匹配符合指定条件的文件，并执行一些操作。让我们看看`find`的不同用例和基本用法。'
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In order to list all the files and folders from the current directory to the
    descending child directories, use the following syntax:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了列出当前目录到下降子目录中的所有文件和文件夹，请使用以下语法：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`base_path` can be any location from which the `find` should start descending
    (for example, `/home/slynux/`).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`base_path`可以是`find`应该开始下降的任何位置（例如，`/home/slynux/`）。'
- en: 'An example of this command is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的一个示例如下：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`.` specifies current directory and `..` specifies the parent directory. This
    convention is followed throughout the UNIX file system.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`.`指定当前目录，`..`指定父目录。这个约定贯穿整个UNIX文件系统。'
- en: The `-print` argument specifies to print the names (path) of the matching files.
    When `-print` is used `'\n'` will be the delimiting character for separating each
    file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`-print`参数指定打印匹配文件的名称（路径）。当使用`-print`时，`''\n''`将是分隔每个文件的定界字符。'
- en: The `-print0` argument specifies each matching file name printed with the delimiting
    character `'\0'`. This is useful when a filename contains a space character.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`-print0`参数指定每个匹配文件名都用定界字符`''\0''`打印。当文件名包含空格字符时，这是有用的。'
- en: There's more...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe we have learned the usage of the most commonly-used `find` command
    with an example. The `find` command is a powerful command-line tool and it is
    armed with a variety of interesting options. Let's walk through some of these
    different options of the `find` command.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们学习了最常用的`find`命令的用法。`find`命令是一个强大的命令行工具，它配备了各种有趣的选项。让我们来看看`find`命令的一些不同选项。
- en: Search based on file name or regular expression match
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于文件名或正则表达式匹配的搜索
- en: The `-name` argument specifies a matching string for the filename. We can pass
    wildcards as its argument text. `*.txt` matches all the filenames ending with
    `.txt` and prints them. The `–print` option prints the filenames or file paths
    in the terminal that matches the conditions (for example, `–name`) given as options
    to the `find` command.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`-name`参数指定文件名的匹配字符串。我们可以将通配符作为其参数文本传递。`*.txt`匹配所有以`.txt`结尾的文件名并将它们打印出来。`-print`选项在终端中打印与给定为`find`命令选项的条件（例如，`-name`）匹配的文件名或文件路径。'
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `find` command has an option `–iname` (ignore case), which is similar to
    `-name`. `–iname` matches the name ignoring the case.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`命令有一个`–iname`（忽略大小写）选项，它类似于`-name`。`–iname`匹配名称时忽略大小写。'
- en: 'For example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we want to match either of the multiple criterions, we can use OR conditions
    as shown below:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想匹配多个条件中的任何一个，我们可以使用OR条件，如下所示：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The previous code will print all of the `.txt` and `.pdf` files, since the `find`
    command matches both `.txt` and `.pdf` files. `\(` and `\)` is used to treat `-name
    "*.txt" -o -name "*.pdf"` as a single unit.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将打印所有`.txt`和`.pdf`文件，因为`find`命令匹配`.txt`和`.pdf`文件。`\(`和`\)`用于将`-name "*.txt"
    -o -name "*.pdf"`视为单个单元。
- en: 'The `-path` argument can be used to match the file path for files that match
    the wildcards. `-name` always matches using the given filename. However, `-path`
    matches the file path as a whole. For example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`-path`参数可用于匹配与通配符匹配的文件路径。`-name`始终使用给定的文件名进行匹配。但是，`-path`匹配整个文件路径。例如：'
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `-regex` argument is similar to `-path`, but `-regex` matches the file paths
    based on regular expressions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`-regex`参数类似于`-path`，但`-regex`根据正则表达式匹配文件路径。'
- en: 'Regular expressions are an advanced form of wildcard matching. It enables to
    specify a text with patterns. By using the patterns, we can make matches to the
    text and print them. A typical example of text matching using regular expressions
    is: parsing all e-mail addresses from a given pool of text. An e-mail address
    takes the form `name@host.root`. So, it can be generalized as `[a-z0-9]+@[a-z0-9]+.[a-z0-9]+`.
    The `+` signifies that the previous class of characters can occur one or more
    times, repeatedly, in the characters that follow.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是通配符匹配的高级形式。它使我们能够指定带有模式的文本。通过使用这些模式，我们可以匹配文本并将其打印出来。使用正则表达式进行文本匹配的典型示例是：从给定的文本池中解析所有电子邮件地址。电子邮件地址采用`name@host.root`的形式。因此，它可以概括为`[a-z0-9]+@[a-z0-9]+.[a-z0-9]+`。`+`表示前一个字符类可以在后面的字符中重复一次或多次。
- en: 'The following command matches `.py` or `.sh` files:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令匹配`.py`或`.sh`文件：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Similarly, using `-iregex` ignores the case for the regular expressions that
    are available. For example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，使用`-iregex`忽略了可用的正则表达式的大小写。例如：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Negating arguments
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 否定参数
- en: '`find` can also take negation of arguments using "!". For example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`还可以使用“!”来否定参数。例如：'
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The above `find` construct matches all the file names, as long as the name
    does not end with `.txt`. The following example shows the result of the command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`find`构造匹配所有文件名，只要名称不以`.txt`结尾。以下示例显示了该命令的结果：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Search based on the directory depth
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于目录深度的搜索
- en: When the `find` command is used it recursively walks through all the subdirectories
    as much as possible until it reaches the leaf of the subdirectory tree. We can
    restrict the depth to which the `find` command traverses using some depth parameters
    given to the find. `-maxdepth` and `-mindepth` are the parameters.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`find`命令时，它会递归地遍历所有子目录，直到尽可能地达到子目录树的叶子。我们可以通过给`find`命令一些深度参数来限制`find`命令遍历的深度。`-maxdepth`和`-mindepth`是这些参数。
- en: In most of the cases, we need to search only in the current directory. It should
    not further descend into the subdirectories from the current directory. In such
    cases, we can restrict the depth to which the `find` command should descend using
    depth parameters. In order to restrict `find` from descending into the subdirectories
    from the current directory, the depth can be set as 1\. When we need to descend
    to two levels, the depth is set as 2, and so on for the rest of the levels.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们只需要在当前目录中搜索。它不应该进一步进入当前目录的子目录。在这种情况下，我们可以通过深度参数限制`find`命令应该下降的深度。为了限制`find`不进入当前目录的子目录，深度可以设置为1。当我们需要下降到两个级别时，深度设置为2，依此类推。
- en: 'For specifying the maximum depth we use the `–maxdepth` level parameter. Similarly,
    we can also specify the minimum level at which the descending should start. If
    we want to start searching from the second level onwards, we can set the minimum
    depth using the `–mindepth` level parameter. Restrict the `find` command to descend
    to a maximum depth of 1, by using the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定最大深度，我们使用`-maxdepth`级别参数。同样，我们也可以指定下降开始的最小级别。如果我们想要从第二级开始搜索，可以使用`-mindepth`级别参数设置最小深度。通过使用以下命令，将`find`命令限制为最大深度为1：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This command lists all the regular files only from the current directory. If
    there are subdirectories, they are not printed or traversed. Similarly, `-maxdepth
    2` traverses up to at most two descending levels of subdirectories.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令仅列出当前目录中的所有普通文件。如果有子目录，则不会打印或遍历它们。同样，`-maxdepth 2`最多遍历两个下降级别的子目录。
- en: '`-mindepth` is similar to `–maxdepth`, but it sets the least depth level for
    the `find` traversal. It can be used to find and print the files that are located
    with a minimum level of depth from the base path. For example, to print all the
    files that are at least two subdirectories distant from the current directory
    use the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`-mindepth`类似于`-maxdepth`，但它设置了`find`遍历的最小深度级别。它可以用于查找和打印位于基本路径最小深度级别的文件。例如，要打印出距离当前目录至少两个子目录的所有文件，请使用以下命令：'
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Even if there are files in the current directory or `dir1` and `dir3`, it will
    not be printed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 即使当前目录或`dir1`和`dir3`中有文件，也不会被打印出来。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`-maxdepth` and `–mindepth` should be specified as the third argument to the
    find. If they are specified as the fourth or further arguments, it may affect
    the efficiency of the find as it has to do unnecessary checks (for example, if
    `–maxdepth` is specified as the fourth argument and `–type` as the third argument,
    the `find` command first finds out all the files having the specified `–type`
    and then finds all of the matched files having the specified depth. However, if
    the depth were specified as the third argument and `–type` as the fourth, `find`
    could collect all the files having at most the specified depth and then check
    for the file type, which is the most efficient way of searching.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`-maxdepth`和`-mindepth`应该作为`find`的第三个参数进行指定。如果它们作为第四个或更多的参数进行指定，可能会影响`find`的效率，因为它必须进行不必要的检查（例如，如果`-maxdepth`被指定为第四个参数，`-type`被指定为第三个参数，`find`命令首先找出所有具有指定`-type`的文件，然后找出所有匹配的文件具有指定的深度。然而，如果深度被指定为第三个参数，`-type`被指定为第四个参数，`find`可以收集所有具有最多指定深度的文件，然后检查文件类型，这是搜索的最有效方式。'
- en: Search based on file type
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于文件类型进行搜索
- en: UNIX-like operating systems consider every object as a file. There are different
    kinds of files such as regular file, directory, character devices, block devices,
    symlinks, hardlinks, sockets, FIFO, and so on.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 类UNIX操作系统将每个对象都视为文件。有不同类型的文件，如普通文件、目录、字符设备、块设备、符号链接、硬链接、套接字、FIFO等。
- en: The file search can be filtered out using the `-type` option. By using `–type`,
    we can specify to the `find` command that it should only match files having a
    specified type.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 文件搜索可以使用`-type`选项进行过滤。通过使用`-type`，我们可以指定`find`命令只匹配具有指定类型的文件。
- en: 'List only directories including descendants as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 只列出包括后代的目录如下：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It is hard to list directories and files separately. But `find` helps to do
    it. List only regular files as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 很难分别列出目录和文件。但`find`可以帮助做到。只列出普通文件如下：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'List only symbolic links as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 只列出符号链接如下：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can use the `type` arguments from the following table to properly match
    the required file type:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下表中的`type`参数来正确匹配所需的文件类型：
- en: '| File type | Type argument |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 文件类型 | 类型参数 |'
- en: '| --- | --- |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Regular file | `f` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 普通文件 | `f` |'
- en: '| Symbolic link | `l` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 符号链接 | `l` |'
- en: '| Directory | `d` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 目录 | `d` |'
- en: '| Character special device | `c` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 字符特殊设备 | `c` |'
- en: '| Block device | `b` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 块设备 | `b` |'
- en: '| Socket | `s` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 套接字 | `s` |'
- en: '| Fifo | `p` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| FIFO | `p` |'
- en: Search on up file times
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索文件时间
- en: 'UNIX/Linux file systems have three types of timestamp on each file. They are
    as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX/Linux文件系统的每个文件都有三种类型的时间戳。它们如下：
- en: '**Access time** (-`atime`): This is the last timestamp of when the file was
    accessed by some user'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问时间**（-`atime`）：这是文件最后一次被某个用户访问的时间戳'
- en: '**Modification time** (-`mtime`): This is the last timestamp of when the file
    content was modified'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修改时间**（-`mtime`）：这是文件内容最后一次修改的时间戳'
- en: '**Change time** (-`ctime`): This is the last timestamp of when the metadata
    for a file (such as permissions or ownership) was modified'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改时间**（-`ctime`）：这是文件的元数据（如权限或所有权）最后一次修改的时间戳'
- en: There is nothing called creation time in UNIX.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX中没有所谓的创建时间。
- en: '`-atime`, `-mtime` , `-ctime` are the time parameter options available with
    `find`. They can be specified with integer values in "number of days". These integer
    values are often attached with `-` or + signs. The `-` sign implies less than
    whereas the `+` implies greater than. For example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`-atime`、`-mtime`、`-ctime`是`find`中可用的时间参数选项。它们可以用"天数"的整数值来指定。这些整数值通常附加有`-`或`+`符号。`-`符号表示小于，而`+`表示大于。例如：'
- en: 'Print all the files that were accessed within the last 7 days as follows:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印出在最近7天内访问过的所有文件如下：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Print all the files that are having access time exactly 7 days old as follows:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印出所有访问时间正好是7天前的文件如下：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Print all the files that are having access time older than 7 days as follows:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印出所有访问时间早于7天的文件如下：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Similarly, we can use the `–mtime` parameter for search files based on modification
    time and `-ctime` for search based on change time.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`-mtime`参数来搜索基于修改时间的文件，使用`-ctime`来搜索基于更改时间的文件。
- en: '`-atime`, `-mtime`, and `–ctime` are time-based parameters that use the time
    metric in days. There are some other time-based parameters that use the time metric
    in minutes. These are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`-atime`，`-mtime`和`-ctime`是基于时间的参数，使用以天为单位的时间度量。还有一些其他基于时间的参数，使用以分钟为单位的时间度量。这些如下：'
- en: '`-amin` (access time)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-amin`（访问时间）'
- en: '`-mmin` (modification time)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-mmin`（修改时间）'
- en: '`-cmin` (change time)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-cmin`（更改时间）'
- en: 'For example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: 'In order to print all the files that are having access time older than seven
    minutes, use the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印所有访问时间早于七分钟的文件，请使用以下命令：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Another nice feature available with `find` is the `–newer` parameter. By using
    `-newer`, we can specify a reference file to compare with the timestamp. We can
    find all the files that are newer (older modification time) than the specified
    file with the `–newer` parameter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`的另一个很好的功能是`-newer`参数。通过使用`-newer`，我们可以指定一个参考文件来与时间戳进行比较。我们可以使用`-newer`参数找到所有比指定文件更新（修改时间更早）的文件。'
- en: 'For example, find all the files that are having a modification time greater
    than that of the modification time of a given `file.txt` file as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，找出所有修改时间大于给定`file.txt`文件的修改时间的文件，如下所示：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Timestamp manipulation flags for the `find` command are very useful for writing
    system backup and maintenance scripts.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`命令的时间戳操作标志对于编写系统备份和维护脚本非常有用。'
- en: Search based on file size
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于文件大小进行搜索
- en: 'Based on the file sizes of the files, a search can be performed as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文件大小进行搜索，可以执行如下搜索：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Instead of `k` we can use different size units as the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用不同的大小单位，而不是`k`，如下所示：
- en: '`b` – 512 byte blocks'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b` – 512字节块'
- en: '`c` – bytes'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c` – 字节'
- en: '`w` – two byte words'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w` – 两个字节的字'
- en: '`k` – Kilobyte'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`k` – 千字节'
- en: '`M` – Megabyte'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M` – 兆字节'
- en: '`G` – Gigabyte'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`G` – 千兆字节'
- en: Deleting based on the file matches
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于文件匹配进行删除
- en: The `-delete` flag can be used to remove files that are matched by `find`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`-delete`标志可用于删除由`find`匹配的文件。'
- en: 'Remove all the `.swp` files from the current directory as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 从当前目录中删除所有`.swp`文件，方法如下：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Match based on the file permissions and ownership
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于文件权限和所有权进行匹配
- en: 'It is possible to match files based on the file permissions. We can list out
    the files having specified file permission as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 可以根据文件权限匹配文件。我们可以列出具有指定文件权限的文件，如下所示：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As an example usage case, we can consider the case of Apache web server. The
    PHP files in the web server require proper permissions to execute. We can find
    out the PHP files that are not having proper execute permissions as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例用例，我们可以考虑Apache Web服务器的情况。 Web服务器中的PHP文件需要适当的权限才能执行。我们可以找出没有适当执行权限的PHP文件，如下所示：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can also search files based on ownership of the files. The files owned by
    a specific user can be found out using the `-user USER` option.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以根据文件的所有权搜索文件。使用`-user USER`选项可以找到特定用户拥有的文件。
- en: The `USER` argument can be a username or UID.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`USER`参数可以是用户名或UID。'
- en: 'For example, to print the list of all files owned by the user slynux, you can
    use the following command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要打印所有由用户slynux拥有的文件的列表，可以使用以下命令：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Executing commands or actions with find
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`find`执行命令或操作
- en: The `find` command can be coupled with many of the other commands using the
    `-exec` option. `-exec` is one of the most powerful features that comes with `find`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`命令可以使用`-exec`选项与许多其他命令配合使用。`-exec`是`find`附带的最强大的功能之一。'
- en: Let's see how to use the –`exec` option.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`-exec`选项。
- en: Consider the example in the previous section. We used `–perm` to find out the
    files that do not have proper permissions. Similarly, in the case where we need
    to change the ownership of all files owned by a certain user (for example, `root`)
    to another user (for example, `www-data` the default Apache user in the web server),
    we can find all the files owned by root by using the `–user` option and using
    `–exec` to perform ownership change operation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前一节中的示例。我们使用`-perm`找出没有适当权限的文件。类似地，在需要将所有由特定用户（例如`root`）拥有的文件的所有权更改为另一个用户（例如Web服务器中的默认Apache用户`www-data`）的情况下，我们可以使用`-user`选项找到所有由root拥有的文件，并使用`-exec`执行所有权更改操作。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You must run the `find` command as root for performing ownership change.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 执行所有权更改时，必须以root身份运行`find`命令。
- en: 'Let''s have a look at the following example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this command, `{}` is a special string used with the `–exec` option. For
    each file match, `{}` will be replaced with the file name in place for `–exec`.
    For example, if the `find` command finds two files `test1.txt` and `test2.txt`
    with owner slynux, the find command will perform:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在此命令中，`{}`是与`-exec`选项一起使用的特殊字符串。对于每个文件匹配，`{}`将被替换为文件名，以替代`-exec`。例如，如果`find`命令找到两个文件`test1.txt`和`test2.txt`，所有者为slynux，`find`命令将执行：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This gets resolved to `chown slynux test1.txt` and `chown slynux test2.txt`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将解析为`chown slynux test1.txt`和`chown slynux test2.txt`。
- en: 'Another usage example is to concatenate all the C program files in a given
    directory and write it to a single file `all_c_files.txt`. We can use `find` to
    match all the C files recursively and use the `cat` command with the `-exec` flag
    as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用法示例是将给定目录中的所有C程序文件连接起来，并将其写入单个文件`all_c_files.txt`。我们可以使用`find`递归匹配所有C文件，并使用`-exec`标志与`cat`命令，如下所示：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`-exec` is followed with any command. `{}` is a match. For every matched filename,
    `{}` is replaced with filename.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`-exec`后面跟着任何命令。`{}`是一个匹配。对于每个匹配的文件名，`{}`将被替换为文件名。'
- en: To redirect the data from `find` to the `all_c_files.txt` file, we used the
    `>` operator instead of `>>` (append) because the entire output from the `find`
    command is a single data stream (`stdin`). `>>` is necessary only when multiple
    data streams are to be appended to a single file.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将来自`find`的数据重定向到`all_c_files.txt`文件，我们使用了`>`运算符，而不是`>>`（追加），因为`find`命令的整个输出是单个数据流（`stdin`）。只有在需要将多个数据流追加到单个文件时才需要`>>`。
- en: 'For example, to copy all the `.txt` files that are older than 10 days to a
    directory `OLD`, use the following command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将所有早于10天的`.txt`文件复制到目录`OLD`中，请使用以下命令：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Similarly, the `find` command can be coupled with many other commands.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`find`命令可以与许多其他命令配合使用。
- en: Tip
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**-exec with multiple commands**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**-exec与多个命令**'
- en: 'We cannot use multiple commands along with the `–exec` parameter. It accepts
    only a single command, but we can use a trick. Write multiple commands in a shell
    script (for example, `commands.sh`) and use it with `–exec` as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在`-exec`参数中使用多个命令。它只接受单个命令，但我们可以使用一个技巧。在shell脚本中编写多个命令（例如，`commands.sh`）并将其与`-exec`一起使用，如下所示：
- en: '`–exec ./commands.sh {} \;`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`–exec ./commands.sh {} \;`'
- en: '`-exec` can be coupled with `printf` to produce a very useful output. For example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`-exec`可以与`printf`结合产生非常有用的输出。例如：'
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Skip specified directories from the find
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从find中跳过指定的目录
- en: 'Skipping certain subdirectories for a performance improvement is sometimes
    required while doing a directory search and performing some action. For example,
    when programmers look for particular files on a development source tree, which
    is under a version control system such as Git, the source hierarchy will always
    contain the `.git` directory in each of the subdirectories (`.git` stores version
    control related information for every directory). Since version control related
    directories do not produce useful output, they should be excluded from the search.
    The technique of excluding files and directories from the search is known as pruning.
    It can be performed as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在进行目录搜索和执行某些操作时，需要跳过某些子目录以提高性能。例如，当程序员在开发源代码树上查找特定文件时，该源代码树位于版本控制系统（如Git）下，源代码层次结构将始终包含每个子目录中的`.git`目录（`.git`存储每个目录的版本控制相关信息）。由于版本控制相关目录不会产生有用的输出，因此应将其从搜索中排除。排除文件和目录的技术称为修剪。可以按以下方式执行：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The above command prints the name (path) of all the files that are not from
    the `.git` directories.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令打印所有不来自`.git`目录的文件的名称（路径）。
- en: Here, `\( -name ".git" -prune \)` is the exclude portion, which specifies that
    the `.git` directory should be excluded and `\( -type f -print \)` specifies the
    action to be performed. The actions to be performed are placed in the second block
    `-type f –print` (the action specified here is to print the names and path of
    all the files).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`\( -name ".git" -prune \)`是排除部分，指定了应该排除`.git`目录，`\( -type f -print \)`指定了要执行的操作。要执行的操作放在第二个块`-type
    f –print`中（这里指定的操作是打印所有文件的名称和路径）。
- en: Playing with xargs
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转xargs
- en: 'We use pipes to redirect `stdout` (standard output) of a command to `stdin`
    (standard input) of another command. For example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用管道将命令的`stdout`（标准输出）重定向到另一个命令的`stdin`（标准输入）。例如：
- en: '[PRE45]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: But, some of the commands accept data as command-line arguments rather than
    a data stream through `stdin` (standard input). In that case, we cannot use pipes
    to supply data through command-line arguments.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一些命令接受命令行参数作为数据，而不是通过stdin（标准输入）的数据流。在这种情况下，我们不能使用管道通过命令行参数提供数据。
- en: We should go for alternate methods. `xargs` is a command that is very helpful
    in handling standard input data to the command-line argument conversions. `xargs`
    can manipulate `stdin` and convert to command-line arguments for the specified
    command. Also `xargs` can convert any one line or multiple line text input into
    other formats, such as multiple lines (specified number of columns) or a single
    line and vice versa.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该选择替代方法。`xargs`是一个非常有用的命令，可以处理标准输入数据并转换为命令行参数。`xargs`可以操作stdin并将其转换为指定命令的命令行参数。此外，`xargs`还可以将任何单行或多行文本输入转换为其他格式，例如多行（指定列数）或单行，反之亦然。
- en: All the Bash hackers love one-line commands. One-liners are command sequences
    that are joined by using the pipe operator, but do not use the semi colon terminator
    (;) between the commands used. Crafting one-line commands makes tasks efficient
    and simpler to solve. It requires proper understanding and practise to formulate
    one-liners for solving text processing problems. `xargs` is one of the important
    components for building one-liner commands.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的Bash黑客都喜欢单行命令。一行命令是通过使用管道操作符连接的命令序列，但不使用分号终止符（;）在使用的命令之间。编写一行命令可以使任务更有效和更简单地解决。它需要适当的理解和实践来制定解决文本处理问题的一行命令。`xargs`是构建一行命令的重要组件之一。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The `xargs` command should always appear immediately after a pipe operator.
    `xargs` uses standard input as the primary data stream source. It uses `stdin`
    and executes another command by providing command-line arguments for that executing
    command using the stdin data source. For example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`命令应该始终出现在管道操作符之后。`xargs`使用标准输入作为主要数据流源。它使用`stdin`并通过使用stdin数据源为执行命令提供命令行参数。例如：'
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How to do it...
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The `xargs` command can supply arguments to a command by reformatting the data
    received through `stdin`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`命令可以通过重新格式化通过`stdin`接收的数据来为命令提供参数。'
- en: '`xargs` can act as a substitute that can perform similar actions as the `-exec`
    argument in the case of the `find` command. Let''s see a variety of hacks that
    can be performed using the `xargs` command.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`可以充当替代品，在`find`命令的情况下可以执行与`-exec`参数类似的操作。让我们看看可以使用`xargs`命令执行的各种技巧。'
- en: '**Converting multiple lines of input to a single line output:**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将多行输入转换为单行输出：**'
- en: 'Multiple line input can be converted simply by removing the new line character
    and replacing with the " " (space) character. ''`\n`'' is interpreted as a newline,
    which is the delimiter for the lines. By using `xargs`, we can ignore all the
    newlines with spaces so that multiple lines can be converted into a single line
    text as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 多行输入可以通过删除换行符并用" "（空格）字符替换来简单转换。`'\n'`被解释为换行符，这是行的分隔符。通过使用`xargs`，我们可以忽略所有带有空格的换行符，以便将多行转换为单行文本，如下所示：
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '**Converting single line into multiple line output:**'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将单行转换为多行输出：**'
- en: 'Given maximum no of arguments in a line `= n`, we can split any `stdin` (standard
    input) text into lines of n arguments each. An argument is a piece of string delimited
    by " " (space). Space is the default delimiter. A single line can be split into
    multiple lines as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一行中的最大参数数`= n`，我们可以将任何`stdin`（标准输入）文本分割为每个n个参数的行。参数是由“ ”（空格）分隔的字符串片段。空格是默认分隔符。一行可以分成多行，如下所示：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works…
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `xargs` command is appropriate to be applied to many problem scenarios with
    its rich and simple options. Let's see how these options can be used wisely to
    solve problems.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`命令适用于许多问题场景，具有丰富和简单的选项。让我们看看如何明智地使用这些选项来解决问题。'
- en: 'We can also use our own delimiter towards separating arguments. In order to
    specify a custom delimiter for input, use the `–d` option as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用自己的分隔符来分隔参数。为了指定输入的自定义分隔符，请使用`-d`选项，如下所示：
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the above code, `stdin` contains a string consisting of multiple 'X' characters.
    We can use 'X' as the input delimiter by using it with `–d`. Here we have explicitly
    specified X as the input delimiter, whereas in the default case `xargs` takes
    Internal Field Separator (space) as the input delimiter.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`stdin`包含一个由多个'X'字符组成的字符串。我们可以使用'X'作为输入分隔符，通过与`-d`一起使用它。在这里，我们已经明确指定X作为输入分隔符，而在默认情况下，`xargs`将内部字段分隔符（空格）作为输入分隔符。
- en: 'By using `–n` along with the above command, we can split the input into multiple
    lines having two words each as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过与上述命令一起使用`-n`，我们可以将输入拆分为每行两个单词的多行，如下所示：
- en: '[PRE50]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There's more...
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We have learned how to format `stdin` to different output as arguments from
    the above examples. Now let's learn how to supply these formatted output as arguments
    to commands.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何将`stdin`格式化为不同的输出，作为上述示例的参数。现在让我们学习如何将这些格式化的输出作为参数提供给命令。
- en: '**Passing formatted arguments to a command by reading stdin**'
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过读取标准输入将格式化的参数传递给命令**'
- en: Write a small custom echo for better understanding of example usages with xargs
    to provide command arguments.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个小的自定义echo，以更好地理解使用xargs提供命令参数的示例用法。
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'When arguments are passed to the `cecho.sh`, it will print the arguments terminated
    by the `#` character. For example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数传递给`cecho.sh`时，它将打印以`#`字符终止的参数。例如：
- en: '[PRE52]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s have a look at a problem:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个问题：
- en: 'I have a list of arguments in a file (one argument in each line) to be provided
    to a command (say `cecho.sh`). I need to provide arguments in two methods. In
    the first method, I need to provide one argument each for the command as follows:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我有一个文件中的参数列表（每行一个参数），要提供给一个命令（比如`cecho.sh`）。我需要用两种方法提供参数。在第一种方法中，我需要为命令提供一个参数，如下所示：
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Or, alternately, I need to provide two or three arguments each for each execution
    of command. For two arguments each, it would be similar to the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我需要为每次执行命令提供两个或三个参数。对于每两个参数，它将类似于以下内容：
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the second method, I need to provide all arguments at once to the command
    as follows:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二种方法中，我需要一次性提供所有参数给命令，如下所示：
- en: '[PRE55]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Run the above commands and note down the output before going through the following
    section.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令，并在阅读以下部分之前记下输出。
- en: 'The above problems can be solved using `xargs`. We have the list of arguments
    in a file called `args.txt`. The contents are as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 上述问题可以使用`xargs`解决。我们在一个名为`args.txt`的文件中有参数列表。内容如下：
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For the first problem, we can execute the command multiple times with one argument
    per execution, by using:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个问题，我们可以多次执行命令，每次执行一个参数，如下所示：
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'For executing a command with X arguments per each execution, use:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行每次执行X个参数的命令，请使用：
- en: '[PRE58]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For example:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'For the second problem, we can execute the command at once with all the arguments,
    by using:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个问题，我们可以一次执行命令，使用所有参数，如下所示：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In the above examples, we have supplied command-line arguments directly to
    a specific command (for example, `cecho.sh`). We could only supply the arguments
    from the `args.txt` file. However, in realtime, we may also need to add some constant
    parameter with the command (for example, `cecho.sh`) along with the arguments
    taken from `args.txt`. Consider the following example with the format:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们直接向特定命令（例如`cecho.sh`）提供了命令行参数。我们也可以从`args.txt`文件中提供参数。然而，在实时环境中，我们可能还需要在命令（例如`cecho.sh`）中添加一些常量参数，以及从`args.txt`中获取的参数。考虑以下格式的示例：
- en: '[PRE61]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the above command execution `arg1` is the only variable text. All others
    should remain constant. We should read arguments from a file (`args.txt`) and
    supply it as:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令执行中，`arg1`是唯一的可变文本。其他所有内容都应保持不变。我们应该从一个文件（`args.txt`）中读取参数并提供它：
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To provide a command execution sequence as shown, `xargs` has an option `–I`.
    By using `–I` we can specify a replacement string that will be replaced while
    `xargs` expands. When `–I` is used with `xargs`, it will execute as one command
    execution per argument.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供如下所示的命令执行序列，`xargs`有一个`-I`选项。通过使用`-I`，我们可以指定一个替换字符串，当`xargs`扩展时将被替换。当`-I`与`xargs`一起使用时，它将执行每个参数的一个命令执行。
- en: 'Let''s do it as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们这样做：
- en: '[PRE63]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`-I {}` specifies the replacement string. For each of the arguments supplied
    for the command, the `{}` string will be replaced with arguments read through
    `stdin`. When used with `-I`, the command is executed like in a loop. When there
    are three arguments the command is executed three times along with the command
    `{}`. Each time `{}` is replaced with arguments one by one.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`-I {}`指定替换字符串。对于为命令提供的每个参数，`{}`字符串将被通过`stdin`读取的参数替换。当与`-I`一起使用时，命令会像在循环中一样执行。当有三个参数时，命令将执行三次，以及命令`{}`。每次`{}`都会逐个替换参数。'
- en: Using xargs with find
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用xargs与find
- en: '`xargs` and `find` are best friends. They can be combined to perform tasks
    easily. Usually, people combine them in a wrong way. For example:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`和`find`是最好的朋友。它们可以结合起来轻松执行任务。通常，人们以错误的方式将它们结合在一起。例如：'
- en: '[PRE64]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This is dangerous. It may sometimes cause removal of unnecessary files. Here,
    we cannot predict the delimiting character (whether it is `'\n'` or `' '`) for
    the output of the `find` command. Many of the filenames may contain a space character
    (' ') and hence `xargs` may misinterpret it as a delimiter (for example, "hell
    text.txt" is misinterpreted by `xargs` as "hell" and "text.txt").
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这是危险的。有时可能会导致删除不必要的文件。在这里，我们无法预测定界字符（无论是`'\n'`还是`' '`）对于`find`命令的输出。许多文件名可能包含空格字符（'
    '），因此`xargs`可能会误解它作为定界符（例如，“hell text.txt”被`xargs`误解为“hell”和“text.txt”）。
- en: Hence we must use `-print0` along with `find` to produce an output with delimited
    character null (`'\0'`)whenever we use the `find` output as the `xargs` input.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须使用`-print0`以及`find`来生成一个带有分隔字符null(`'\0'`)的输出，每当我们使用`find`的输出作为`xargs`的输入时。
- en: 'Let''s use `find` to match and list of all the `.txt` files and remove them
    using `xargs`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`find`来匹配和列出所有`.txt`文件，并使用`xargs`删除它们：
- en: '[PRE65]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This removes all `.txt` files. `xargs -0` interprets that the delimiting character
    is `\0`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除所有`.txt`文件。`xargs -0`解释定界字符为`\0`。
- en: Counting number of lines of C code in a source code directory over many C files.
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在源代码目录中计算C代码的行数，涵盖了许多C文件。
- en: 'This is a task most programmers do, that is, counting all C program files for
    LOC (Lines of Code). The code for this task is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这是大多数程序员所做的任务，即计算所有C程序文件的LOC（代码行数）。此任务的代码如下：
- en: '[PRE66]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: While and subshell trick with stdin
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用while和子shell技巧处理stdin
- en: '`xargs` is restricted to provide arguments in limited ways to supply arguments.
    Also, xargs cannot supply arguments to multiple set of commands. For executing
    commands with collected arguments from standard input, we have a very flexible
    method. I call it a subshell hack. A subshell with a `while` loop can be used
    to read arguments and execute commands in a trickier way as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`受限于以有限的方式提供参数以提供参数。此外，xargs无法向多组命令提供参数。为了执行从标准输入收集的参数的命令，我们有一种非常灵活的方法。我称之为子shell
    hack。可以使用带有`while`循环的子shell来读取参数并以以下更复杂的方式执行命令：'
- en: '[PRE67]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, by replacing `cat $arg` with any number of commands using a `while` loop,
    we can perform many command actions with same arguments. We can also pass the
    output to other commands without using pipes. Subshell `( )` tricks can be used
    in a variety of problem environments. When enclosed within subshell operators,
    it acts as a single unit with multiple commands inside.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通过使用`while`循环替换`cat $arg`，我们可以执行许多具有相同参数的命令操作。我们还可以将输出传递给其他命令，而不使用管道。子shell`(
    )`技巧可以在各种问题环境中使用。当包含在子shell操作符中时，它作为一个具有多个命令的单个单元。
- en: '[PRE68]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If `cmd1` is `cd /`, within the subshell, the path of the working directory
    changes. However, this change resides inside the subshell only. `cmd4` will not
    see the directory change.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`cmd1`是`cd /`，在子shell中，工作目录的路径会更改。但是，此更改仅存在于子shell中。`cmd4`将看不到目录更改。
- en: Translating with tr
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用tr进行转换
- en: '`tr` is a small and beautiful command in the UNIX command-warrior toolkit.
    It is one of the important commands frequently used to craft beautiful one-liner
    commands.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr`是UNIX命令战士工具包中的一个小而美丽的命令。它是经常用于制作美丽的单行命令的重要命令之一。'
- en: '`tr` can be used to perform substitution of characters, deletion of the characters,
    and squeezing of repeated characters from the standard input. It is often called
    translate, since it can translate a set of characters to another set.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr`可用于执行标准输入中的字符替换、字符删除和重复字符的挤压。它通常被称为translate，因为它可以将一组字符转换为另一组字符。'
- en: Getting ready
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: '`tr` accepts input only through `stdin` (standard input). It cannot accept
    input through command-line arguments. It has the following invocation format:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr`只通过`stdin`（标准输入）接受输入。它不能通过命令行参数接受输入。它具有以下调用格式：'
- en: '[PRE69]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Input characters from `stdin` are mapped from `set1` to `set2` and the output
    is written to `stdout` (standard output). `set1` and `set2` are character classes
    or a set of characters. If the length of sets is unequal, `set2` is extended to
    the length of `set1` by repeating the last character, or else, if the length of
    `set2` is greater than that of `set1`, all the characters exceeding the length
    of `set1` are ignored from `set2`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 从`stdin`输入的字符从`set1`映射到`set2`，并将输出写入`stdout`（标准输出）。`set1`和`set2`是字符类或一组字符。如果集的长度不相等，则通过重复最后一个字符来扩展`set2`的长度到`set1`的长度，否则，如果`set2`的长度大于`set1`的长度，则从`set2`中忽略超出`set1`长度的所有字符。
- en: How to do it...
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In order to perform translation of characters in the input from uppercase to
    lowercase, use the following command:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行输入中的字符从大写转换为小写的转换，请使用以下命令：
- en: '[PRE70]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`''A-Z''` and `''a-z''` are the sets. We can specify custom sets as needed
    by appending characters or character classes.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`''A-Z''`和`''a-z''`是集合。我们可以通过附加字符或字符类来指定自定义集合。'
- en: '`''ABD-}''`, `''aA.,''`, `''a-ce-x''`, `''a-c0-9''`, and so on are valid sets.
    We can define sets easily. Instead of writing continuous character sequences,
    we can use the `''startchar-endchar''` format. It can also be combined with any
    other characters or character classes. If `startchar-endchar` are not a valid
    continuous character sequence, then they are taken as a set of three characters
    (for example, `startchar`, `-`, and `endchar`). You can also use special characters
    such as `''\t''`, `''\n''`, or any ASCII characters.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`''ABD-}''`，`''aA.,''`，`''a-ce-x''`，`''a-c0-9''`等都是有效的集合。我们可以轻松定义集合。我们可以使用`''startchar-endchar''`格式，而不是编写连续的字符序列。它也可以与任何其他字符或字符类结合使用。如果`startchar-endchar`不是有效的连续字符序列，则它们被视为三个字符的集合（例如，`startchar`，`-`和`endchar`）。您还可以使用特殊字符，如`''\t''`，`''\n''`或任何ASCII字符。'
- en: How it works…
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'By using `tr` with the concept of sets, we can map characters from one set
    to another set easily. Let''s go through an example on how to use `tr` for encrypting
    and decrypting numeric characters:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`tr`与集合的概念，我们可以轻松地将字符从一个集合映射到另一个集合。让我们通过一个示例来了解如何使用`tr`来加密和解密数字字符：
- en: '[PRE71]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Let's try another interesting example.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试另一个有趣的例子。
- en: 'ROT13 is a well known encryption algorithm. In the ROT13 scheme, the same function
    is used to encrypt and decrypt text. The ROT13 scheme performs alphabetic rotation
    of characters for 13 characters. Let''s perform ROT13 using `tr` as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: ROT13是一个众所周知的加密算法。在ROT13方案中，相同的函数用于加密和解密文本。ROT13方案对字符进行了13个字符的字母旋转。让我们使用`tr`执行ROT13，如下所示：
- en: '[PRE72]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The output will be:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：
- en: '[PRE73]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'By sending the encrypted text again to the same ROT13 function, we get:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 通过再次将加密文本发送到相同的ROT13函数，我们得到：
- en: '[PRE74]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The output will be:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：
- en: '[PRE75]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`tr` can be used to convert tab characters into space as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr`可以将制表符转换为空格，如下所示：'
- en: '[PRE76]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: There's more...
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Deleting characters using tr
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用tr删除字符
- en: '`tr` has an option `-d` to delete a set of characters that appear on `stdin`
    by using the specified set of characters to be deleted as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr`有一个`-d`选项，可以通过使用指定的要删除的字符集在`stdin`上删除一组字符。'
- en: '[PRE77]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'For example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE78]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Complementing character set
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 补集字符集
- en: 'We can use a set complement to `set1` by using the `-c` flag. `-c [set]` is
    equivalent to specifying a set (complement-set) which contains complement characters
    of `[set]`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-c`标志通过`set1`来对`set1`进行补集。`-c [set]`等同于指定一个包含`[set]`的补集字符的集合。
- en: '[PRE79]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The complement of `set1` means that it is the set having all the characters
    except for characters in `set1`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`set1`的补集意味着它是除`set1`中的字符之外的所有字符的集合。'
- en: 'The best usage example is to delete all the characters from the input text
    except the ones specified in the complement set. For example:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳的用法示例是从输入文本中删除除补集中指定的字符之外的所有字符。例如：
- en: '[PRE80]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here, the complement set is the set containing all numerals, the space character,
    and newline. All other characters are removed since `–d` is used with `tr`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，补集是包含所有数字、空格字符和换行符的集合。由于`-d`与`tr`一起使用，所有其他字符都被删除。
- en: Squeezing characters with tr
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用tr挤压字符
- en: The `tr` command is very helpful in many text processing contexts. Repeated
    continuous characters should be squeezed to a single character in many circumstances.
    Squeezing of whitespace is a frequently occurring task.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr`命令在许多文本处理上下文中非常有用。在许多情况下，需要将连续重复的字符挤压成单个字符。挤压空格是一个经常发生的任务。'
- en: '`tr` provides the `–s` option to squeeze repeating characters from the input.
    It can be performed as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr`提供了`-s`选项，用于从输入中挤出重复的字符。可以按以下方式执行：'
- en: '[PRE81]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Let''s use `tr` in a tricky way to add a given list of numbers from a file
    as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一种巧妙的方式使用`tr`从文件中添加给定的数字列表，如下所示：
- en: '[PRE82]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: How does this hack work?
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这种黑客行为是如何工作的？
- en: Here, the `tr` command is used to replace `'\n'` with the `'+'` character, hence
    we form the string `"1+2+3+..5+",` but at the end of the string we have an extra
    `+` operator. In order to nullify the effect of the `+` operator, `0` is appended.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`tr`命令用于用`'+'`字符替换`'\n'`，因此我们形成字符串`"1+2+3+..5+"`，但在字符串末尾我们有一个额外的`+`运算符。为了抵消`+`运算符的影响，附加了`0`。
- en: '`$[ operation ]` performs a numeric operation. Hence it forms the string as
    follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`$[ operation ]` 执行一个数字操作。因此，它形成如下字符串：'
- en: '[PRE83]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: If we use a loop to perform addition by reading numbers from a file, it would
    take few lines of code. Here a one-liner does the trick. The skill of crafting
    one-liners is attained by practice.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用循环从文件中读取数字执行加法，将需要几行代码。这里一行代码就能完成任务。通过实践可以掌握编写一行代码的技巧。
- en: Character classes
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符类
- en: '`tr` can use different character classes as sets. The different classes are
    as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr`可以使用不同的字符类作为集合。不同的类如下：'
- en: '`alnum`: Alphanumeric characters'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alnum`：字母数字字符'
- en: '`alpha`: Alphabetic characters'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alpha`：字母字符'
- en: '`cntrl`: Control (non-printing) characters'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cntrl`：控制（不可打印）字符'
- en: '`digit`: Numeric characters'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`digit`：数字字符'
- en: '`graph`: Graphic characters'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graph`：图形字符'
- en: '`lower`: Lower-case alphabetic characters'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lower`：小写字母字符'
- en: '`print`: Printable characters'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print`：可打印字符'
- en: '`punct`: Punctuation characters'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`punct`：标点字符'
- en: '`space`: Whitespace characters'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`space`：空白字符'
- en: '`upper`: Upper-case characters'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`upper`：大写字符'
- en: '`xdigit`: Hexadecimal characters'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xdigit`：十六进制字符'
- en: 'We can select the required classes and use them with as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择所需的类，并将它们与以下内容一起使用：
- en: '[PRE84]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'For example:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE85]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Checksum and verification
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 校验和和验证
- en: Checksum programs are used to generate checksum key strings from the files and
    verify the integrity of the files later by using that checksum string. A file
    might be distributed over the network or any storage media to different destinations.
    Due to many reasons, there are chances for the file being corrupted due to a few
    bits missing during the data transfer. These errors happen most often while downloading
    the files from the Internet, transferring through the network, CD ROM damage,
    and so on.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和程序用于从文件生成校验和密钥字符串，并通过使用该校验和字符串稍后验证文件的完整性。文件可能分布在网络或任何存储介质上到不同的目的地。由于许多原因，文件可能因数据传输过程中丢失了一些位而损坏。这些错误经常发生在从互联网下载文件、通过网络传输、CD
    ROM损坏等过程中。
- en: Hence, we need to know whether the received file is the correct one or not by
    applying some kind of test. The special key string that is used for this file
    integrity test is known as **checksum**.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要知道接收的文件是否正确，通过应用某种测试来确定。用于进行文件完整性测试的特殊密钥字符串称为**校验和**。
- en: We calculate the checksum for the original file as well as the received file.
    By comparing both of the checksums, we can verify whether the received file is
    the correct one or not. If the checksums (calculated from original file at the
    source location and the one calculated from destination) are equal, it means that
    we have received the correct file without causing any erroneous data loss during
    the data transfer, or else, the user has to repeat the data transfer and try the
    checksum comparison again.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算原始文件和接收文件的校验和。通过比较两个校验和，我们可以验证接收的文件是否正确。如果源位置的原始文件和目的地计算出的校验和相等，这意味着我们已经收到了正确的文件，没有在数据传输过程中造成任何错误的数据丢失，否则，用户必须重复数据传输并再次尝试校验和比较。
- en: Checksums are crucial while writing backup scripts or maintenance scripts that
    consist of transfer of files through the network. By using checksum verification,
    files corrupted during the data transfer over the network can be identified and
    those files can be resend again from the source to the destination. Thus the integrity
    of the data received can always be ensured.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写备份脚本或由网络传输文件的维护脚本时，校验和至关重要。通过使用校验和验证，可以识别在网络数据传输过程中损坏的文件，并可以从源重新发送这些文件到目的地。因此，始终可以确保接收到的数据的完整性。
- en: Getting ready
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The most famous and widely-used checksum techniques are `md5sum` and `sha1sum`.
    They generate checksum strings by applying the corresponding algorithm to the
    file content. Let's see how can we generate a checksum and from a file and verify
    the integrity of a file.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名和广泛使用的校验和技术是 `md5sum` 和 `sha1sum`。它们通过将相应的算法应用于文件内容生成校验和字符串。让我们看看如何生成文件的校验和并验证文件的完整性。
- en: How to do it...
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In order to compute the `md5sum`, use the following command:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算 `md5sum`，使用以下命令：
- en: '[PRE86]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: An `md5sum` is a 32 character hexadecimal string, as given above.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，`md5sum` 是一个 32 个字符的十六进制字符串。
- en: 'We redirect the checksum output into a file and use that MD5 file for verification
    as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将校验和输出重定向到文件，并使用该 MD5 文件进行验证，如下所示：
- en: '[PRE87]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: How it works...
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'The syntax for `md5sum` checksum calculation is as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`md5sum` 校验和计算的语法如下：'
- en: '[PRE88]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'When multiple files are used, the output will contain a checksum for each of
    the file having one checksum string per line, as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用多个文件时，输出将包含每个文件的校验和，每行一个校验和字符串，如下所示：
- en: '[PRE89]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The integrity of a file can be verified by using the generated file as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用生成的文件验证文件的完整性，如下所示：
- en: '[PRE90]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Or, alternately, if we need to check all the files using all `.md5` info available,
    use:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果需要使用所有可用的 `.md5` 信息检查所有文件，可以使用：
- en: '[PRE91]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: SHA1 is another commonly used checksum algorithm like md5sum. It generates a
    40-character hex code from a given input file. The command used for calculating
    a SHA1 string is `sha1sum`. Its usage is very similar to that of `md5sum`. Replace
    `md5sum` with `sha1sum` in all the commands mentioned previously in this recipe.
    Instead of `file_sum.md5`, change the output filename to `file_sum.sha1`.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: SHA1 是另一种常用的校验和算法，类似于 md5sum。它从给定的输入文件生成一个 40 个字符的十六进制代码。用于计算 SHA1 字符串的命令是 `sha1sum`。它的用法与
    `md5sum` 非常相似。在本文中先前提到的所有命令中用 `sha1sum` 替换 `md5sum`。将输出文件名更改为 `file_sum.sha1`，而不是
    `file_sum.md5`。
- en: Checksum verification is much useful to verify the integrity of files that we
    download from the Internet. The ISO images that we download from the Internet
    are usually much more prone to erroneous bits. Therefore, to check whether we
    received the file correctly, checksums are widely used. For the same file data
    the checksum program will always produce the same checksum string.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 校验和验证非常有用，可以验证我们从互联网下载的文件的完整性。我们从互联网下载的 ISO 镜像通常更容易出现错误位。因此，为了检查我们是否正确接收了文件，广泛使用校验和。对于相同的文件数据，校验和程序将始终生成相同的校验和字符串。
- en: There's more...
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Checksum are also useful when used with a number of files. Let's see how to
    apply checksum to many files and verify correctness.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当与多个文件一起使用时，校验和也非常有用。让我们看看如何对多个文件应用校验和并验证正确性。
- en: Checksum for directories
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目录的校验和
- en: Checksums are calculated for files. Calculating the checksum for a directory
    would mean that we will need to calculate the checksums for all the files in the
    directory, recursively.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的校验和是针对文件计算的。计算目录的校验和意味着我们需要递归计算目录中所有文件的校验和。
- en: 'It can be achieved by the command `md5deep` or `sha1deep`. Install the package
    `md5deep` to make these commands available. An example of this command is as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `md5deep` 或 `sha1deep` 命令实现。安装 `md5deep` 软件包以使这些命令可用。以下是此命令的示例：
- en: '[PRE92]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Alternately, combine it with `find` to calculate checksums recursively:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，将其与 `find` 结合使用以递归计算校验和：
- en: '[PRE93]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'To verify, use the following command:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证，请使用以下命令：
- en: '[PRE94]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Sorting, unique and duplicates
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序、唯一和重复项
- en: Sorting is a common task that we always encounter with text files. Hence, in
    text processing tasks, sort is very useful. `sort` commands help us to perform
    sort operations over text files and `stdin`. Most often, it can also be coupled
    with many other commands to produce the required output. `uniq` is another command
    that is often used along with a `sort` command. It helps to extract unique lines
    from a text or `stdin`. `sort` and `uniq` can be coupled to find duplicates. This
    recipe illustrates most of the use cases with `sort` and `uniq` commands.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 排序是我们在文本文件中经常遇到的常见任务。因此，在文本处理任务中，sort 非常有用。`sort` 命令帮助我们对文本文件和 `stdin` 执行排序操作。它通常也可以与许多其他命令配合使用以生成所需的输出。`uniq`
    是另一个经常与 `sort` 命令一起使用的命令。它有助于从文本或 `stdin` 中提取唯一行。`sort` 和 `uniq` 可以组合以查找重复项。本文介绍了
    `sort` 和 `uniq` 命令的大多数用例。
- en: Getting ready
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `sort` command accepts input as filenames as well as from `stdin` (Standard
    input) and outputs the result by writing into `stdout`. The `uniq` command follows
    the same sequence of operation.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort` 命令接受文件名作为输入，也可以从 `stdin`（标准输入）中读取，并通过写入 `stdout` 输出结果。`uniq` 命令遵循相同的操作顺序。'
- en: How to do it...
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We can easily sort a given set of files (for example, `file1.txt` and `file2.txt`)
    as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地对给定的一组文件（例如 `file1.txt` 和 `file2.txt`）进行排序，如下所示：
- en: '[PRE95]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Or:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE96]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In order to find the unique lines from a sorted file, use:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从已排序的文件中查找唯一行，请使用：
- en: '[PRE97]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: How it works…
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: There are numerous scenarios where `sort` and `uniq` commands can be used. Let's
    go through various options and usage techniques.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况可以使用 `sort` 和 `uniq` 命令。让我们看看各种选项和用法技巧。
- en: 'For numerical sort use:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行数字排序，请使用：
- en: '[PRE98]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'To sort in reverse order use:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 要按相反顺序排序，请使用：
- en: '[PRE99]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'For sorting by months (in the order Jan, Feb, March) use:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 按月份排序（按照 1 月、2 月、3 月的顺序）使用：
- en: '[PRE100]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'A file can be tested whether sorted or not as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按以下方式测试文件是否已排序：
- en: '[PRE101]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In order to merge two sorted files without sorting again, use:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 要合并两个已排序的文件而不再次排序，请使用：
- en: '[PRE102]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: There's more...
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Sort according to the keys or columns
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 根据键或列进行排序
- en: 'We use sort by column if we need to sort a text as follows:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要对文本进行排序，则使用列排序如下：
- en: '[PRE103]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We can sort this in many ways; currently it is numeric sorted by serial number
    (the first column). We can also sort by second column and third column.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以多种方式对其进行排序；当前是按序列号（第一列）进行数字排序。我们还可以按第二列和第三列进行排序。
- en: '`-k` specifies the key by which the sort is to be performed. Key is the column
    number by which sort is to be done. `-r` specifies the sort command to sort in
    the reverse order. For example:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`-k`指定要执行排序的键。键是要进行排序的列号。`-r`指定sort命令以相反顺序排序。例如：'
- en: '[PRE104]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Note
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Always be careful about the `-n` option for numeric sort. The sort command treats
    alphabetical sort and numeric sort differently. Hence, in order to specify numeric
    sort the `–n` option should be provided.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 始终要小心`-n`选项进行数字排序。sort命令以不同的方式处理字母排序和数字排序。因此，为了指定数字排序，应提供`-n`选项。
- en: 'Usually, by default, keys are columns in the text file. Columns are separated
    by space characters. But in certain circumstances, we will need to specify keys
    as a group of characters in the given character number range (for example, key1=
    character4-character8). In such cases where keys are to be specified explicitly
    as a range of characters, we can specify the keys as ranges with the character
    position at key starts and key ends as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，默认情况下，键是文本文件中的列。列由空格字符分隔。但在某些情况下，我们需要将键指定为给定字符编号范围内的一组字符（例如，key1= character4-character8）。在需要显式指定键为字符范围的情况下，我们可以指定键为字符位置的范围，如下所示：
- en: '[PRE105]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The highlighted characters are to be used as numeric keys. In order to extract
    them, use their start-pos and end-pos as the key format.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用突出显示的字符作为数字键。要提取它们，请使用它们的起始位置和结束位置作为键格式。
- en: 'In order to use the first character as the key, use:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用第一个字符作为键，请使用：
- en: '[PRE106]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Make the sort''s output xargs compatible with `\0` terminator, by using the
    following command:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用以下命令，使sort的输出与`\0`终止符兼容，从而与`xargs`兼容：
- en: '[PRE107]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Sometimes the text may contain unnecessary extraneous characters like spaces.
    To sort by ignoring them in dictionary order by ignoring punctuations and folds,
    use:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 有时文本可能包含不必要的多余字符，如空格。要按字典顺序忽略它们进行排序，忽略标点和折叠，使用：
- en: '[PRE108]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The option `–b` is used to ignore leading blanks from the file and the `–d`
    option is used to specify sort in the dictionary order.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 选项`-b`用于忽略文件中的前导空格，选项`-d`用于指定按字典顺序排序。
- en: uniq
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: uniq
- en: '`uniq` is a command used to find out the unique lines from the given input
    (`stdin` or from filename as command argument) by eliminating the duplicates.
    It can also be used to find out the duplicate lines from the input`. uniq` can
    be applied only for sorted data input. Hence, `uniq` is to be used always along
    with the `sort` command using pipe or using a sorted file as input.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniq`是一个用于从给定输入（`stdin`或从文件名作为命令参数）中找出唯一行的命令，通过消除重复项。它也可以用于从输入中找出重复行。`uniq`只能应用于排序后的数据输入。因此，`uniq`始终应与使用管道或使用排序文件作为输入的`sort`命令一起使用。'
- en: 'You can produce the unique lines (unique lines means that all lines in the
    input are printed, but the duplicate lines are printed only once) from the given
    input data as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从给定的输入数据中生成唯一行（唯一行表示打印输入中的所有行，但重复行仅打印一次）如下：
- en: '[PRE109]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Or:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE110]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Or:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE111]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Display only unique lines (the lines which are not repeated or duplicate in
    input file) as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 仅显示唯一行（输入文件中未重复或重复的行）如下：
- en: '[PRE112]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Or:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE113]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'In order to count how many times each of the line appears in the file, use
    the following command:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算文件中每行出现的次数，请使用以下命令：
- en: '[PRE114]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Find duplicate lines in the file as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 查找文件中的重复行如下：
- en: '[PRE115]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: To specify keys, we can use the combination of `-s` and `-w` arguments.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定键，我们可以使用`-s`和`-w`参数的组合。
- en: '`-s` specifies the number for the first `N` characters to be skipped'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s`指定要跳过的前`N`个字符的数字'
- en: '`-w` specifies the maximum number of characters to be compared'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -w`指定要比较的最大字符数
- en: 'This comparison key is used as the index for the `uniq` operation as follows:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 此比较键用作`uniq`操作的索引，如下所示：
- en: '[PRE116]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'We need to use the highlighted characters as the uniqueness key. This is used
    to ignore the first 2 characters (`-s 2`) and the max number of comparison characters
    is specified using the `–w` option `(-w 2)`:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用突出显示的字符作为唯一性键。这用于忽略前2个字符（`-s 2`），并使用`-w`选项指定比较字符的最大数量（`-w 2`）：
- en: '[PRE117]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: While we use output from one command as input to the xargs command, it is always
    preferable to use a zero byte terminator for each of the lines of the output,
    which acts as source for `xargs`. While using the `uniq` commands output as the
    source for `xargs`, we should use a zero terminated output. If a zero byte terminator
    is not used, space characters are by default taken as delimiter to split the arguments
    in the `xargs` command. For example, a line with text "this is a line" from `stdin`
    will be taken as four separate arguments by the `xargs`. But, actually, it is
    a single line. When a zero byte terminator is used, `\0` is used as the delimiter
    character and hence, a single line including space is interpreted as a single
    argument.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用一个命令的输出作为xargs命令的输入时，最好为输出的每行使用零字节终止符，这充当`xargs`的源。在使用`uniq`命令的输出作为`xargs`的源时，我们应该使用零终止输出。如果不使用零字节终止符，则空格字符默认为`xargs`命令中的分隔符以拆分参数。例如，来自`stdin`的文本“this
    is a line”将被`xargs`视为四个单独的参数。但实际上，它是一行。当使用零字节终止符时，`\0`被用作分隔符字符，因此，包括空格的单行被解释为单个参数。
- en: 'Zero byte terminated output can be generated from the `uniq` command as follows:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从`uniq`命令生成零字节终止的输出，如下所示：
- en: '[PRE118]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The following command removes all the files, with filenames read from `files.txt`:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令从`files.txt`中读取的文件名中删除所有文件：
- en: '[PRE119]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: If multiple line entries of filenames exist in the file, the `uniq` command
    writes the filename only once to `stdout`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件中存在多行文件名条目，则`uniq`命令仅将文件名写入`stdout`一次。
- en: String pattern generation with uniq
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用uniq生成字符串模式
- en: 'Here is an interesting question for you: We have a string containing repeated
    characters. How can we find the number of times each of the character appears
    in the string and output a string in the following format?'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的问题：我们有一个包含重复字符的字符串。我们如何找出每个字符在字符串中出现的次数，并输出以下格式的字符串？
- en: 'Input: ahebhaaa'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 输入：ahebhaaa
- en: 'Output: 4a1b1e2h'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：4a1b1e2h
- en: 'Each of the characters is repeated once, and each of them is prefixed with
    the number of times they appear in the string. We can solve this using `uniq`
    and `sort` as follows:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字符都重复一次，并且它们中的每一个都以它们在字符串中出现的次数作为前缀。我们可以使用`uniq`和`sort`来解决这个问题，如下所示：
- en: '[PRE120]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'In the above code, we can split each of the piped commands as follows:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们可以将每个管道命令拆分如下：
- en: '[PRE121]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Append a newline character to each of the characters so that only one character
    appears in one line. This is done to make the characters sortable by using the
    `sort` command. The `sort` command can take only items delimited by newline.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个字符附加一个换行符，以便每行只出现一个字符。这样做是为了使字符可以通过`sort`命令进行排序。`sort`命令只能接受由换行符分隔的项目。
- en: '`sed ''/^$/d''`: Here the last character is replaced as character `+\n`. Hence
    an extra newline is formed and it will form a blank line at the end. This command
    removes the blank line from the end.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sed ''/^$/d''`：这里最后一个字符被替换为字符`+\n`。因此会形成一个额外的换行符，并且会在末尾形成一个空行。此命令删除末尾的空行。'
- en: '`sort`: Since each character appears in each line, it can be sorted so that
    it can serve as input to uniq.'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort`：由于每个字符都出现在每行中，因此可以对其进行排序，以便作为uniq的输入。'
- en: '`uniq –c`: This command prints each of the line with how many times they got
    repeated(count).'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uniq -c`：此命令打印每行重复的次数。'
- en: '`tr –d '' \n''`: This removes the space characters and newline characters from
    the input so that output can be produced in the given format.'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tr -d '' \n''`：这将从输入中删除空格字符和换行字符，以便以给定格式生成输出。'
- en: Temporary file naming and random numbers
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临时文件命名和随机数
- en: While writing shell scripts, we use often require to store temporary data. The
    most suitable location to store temporary data is `/tmp` (which will be cleaned
    out by the system on reboot). We can use two methods to generate standard filenames
    for temporary data.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写shell脚本时，我们经常需要存储临时数据。存储临时数据的最合适位置是`/tmp`（系统在重新启动时将清除该位置）。我们可以使用两种方法为临时数据生成标准文件名。
- en: How to do it...
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: '`tempfile` is not seen in non-Debian Linux distributions. The `tempfile` command
    comes shipped with Debian-based distributions, such as Ubuntu, Debian, and many
    more.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`tempfile`在非Debian Linux发行版中看不到。`tempfile`命令随Debian系发行版一起提供，例如Ubuntu、Debian等。'
- en: 'The following code will assign a temporary filename to the variable `temp_file`:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将临时文件名分配给变量`temp_file`：
- en: '[PRE122]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Use `echo $temp_file` to print the temporary file name in the terminal.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`echo $temp_file`在终端中打印临时文件名。
- en: The output will look similar to `/tmp/fileaZWm8Y`.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于`/tmp/fileaZWm8Y`。
- en: 'Sometimes we may use a filename with a random number attached to it as a temporary
    filename. This can be done as follows:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能会使用带有随机数字附加的文件名作为临时文件名。可以按以下方式完成：
- en: '[PRE123]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The `$RANDOM` environment variable always returns a random number.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '`$RANDOM`环境变量始终返回一个随机数。'
- en: How it works…
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Instead of using the `tempfile` command, we can also use our own temporary.
    Most experienced UNIX programmers use the following conventions:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用自己的临时文件名，而不是使用`tempfile`命令。大多数经验丰富的UNIX程序员使用以下约定：
- en: '[PRE124]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: The `.$$` suffix is attached. `$$` is expanded as the process ID of the current
    script upon execution.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 附加了`.$$`后缀。`$$`在执行时会扩展为当前脚本的进程ID。
- en: Splitting files and data
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分文件和数据
- en: Splitting of files into many smaller pieces becomes essential in certain situations.
    Earlier, when memory was limited with devices like floppy disks, it was crucial
    to split files into smaller file sizes to transfer data in many disks. However,
    nowadays we split files for other purposes, such as readability, for generating
    logs, and so on.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，将文件拆分为许多较小的部分变得至关重要。在早期，当存储器受限于软盘等设备时，将文件拆分为较小的文件大小以在许多磁盘中传输数据至关重要。然而，如今我们拆分文件是为了其他目的，例如可读性，生成日志等。
- en: How to do it...
  id: totrans-499
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Generate a test file (`data.file`) of 100kb as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个100kb的测试文件（`data.file`）如下：
- en: '[PRE125]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The above command creates a file filled with zeros with the size of 100kb.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令创建了一个大小为100kb的用零填充的文件。
- en: 'You can split files into smaller files by specifying the split size as follows:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过指定拆分大小将文件拆分为较小的文件，如下所示：
- en: '[PRE126]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'It will split `data.file` into many files, each of a 10k chunk. The chunks
    will be named in the manner `xab`, `xac`, `xad`, and so on. This means it will
    have alphabetic suffixes. To use the numeric suffixes, use an additional `-d`
    argument. It is also possible to specify a suffix length using `-a length` as
    follows:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 它将`data.file`拆分为许多文件，每个文件大小为10k。这些块将以`xab`、`xac`、`xad`等方式命名。这意味着它们将具有字母后缀。要使用数字后缀，可以使用额外的`-d`参数。还可以使用`-a
    length`指定后缀长度，如下所示：
- en: '[PRE127]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Instead of the `k` (kilobyte) suffix we can use `M` for MB, `G` for GB, `c`
    for byte, `w` for word, and so on.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`M`代替`k`（千字节）后缀，使用`M`代替`MB`，使用`G`代替`GB`，使用`c`代替字节，使用`w`代替字，等等。
- en: There's more…
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The `split` command has more options. Let's go through them.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '`split`命令有更多选项。让我们来看看它们。'
- en: Specifying filename prefix for the split files
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定拆分文件的文件名前缀
- en: 'The above split files have a filename prefix "x". We can also use our own filename
    prefix by providing a prefix filename. The last command argument for the split
    command is `PREFIX`. It is in the format:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 上述拆分文件具有文件名前缀"x"。我们还可以通过提供前缀文件名来使用自己的文件名前缀。拆分命令的最后一个命令参数是`PREFIX`。它的格式是：
- en: '[PRE128]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Let''s run the previous command with the prefix filename for split files:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用拆分文件的前缀文件名运行上一个命令：
- en: '[PRE129]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'In order to split files based on number of lines in each split rather than
    chunk size, use `-l no_of_lines` as follows:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 为了根据每个拆分的行数而不是块大小拆分文件，使用`-l no_of_lines`如下：
- en: '[PRE130]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: There is another interesting utility called `csplit`. It can be used to split
    log file-based specified conditions and string match options. Let's see how to
    work with it.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个有趣的实用程序叫做`csplit`。它可以用于根据指定条件和字符串匹配选项拆分日志文件。让我们看看如何使用它。
- en: '`csplit` is a variant of the `split` utility. The `split` utility can only
    split files based on chunk size or based on the number of lines. `csplit` makes
    the split based on context based split. It can be used to split files based on
    existence of a certain word or text content.'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '`csplit`是`split`实用程序的一个变体。`split`实用程序只能根据块大小或行数拆分文件。`csplit`根据上下文拆分文件。它可以用于根据某个特定单词或文本内容的存在来拆分文件。'
- en: 'Look at the example log:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 看一个示例日志：
- en: '[PRE131]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'We may need to split the files into `server1.log`, `server2.log`, and `server3.log`
    from the contents for each `SERVER` in each file. This can be done as follows:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要从每个文件中的每个`SERVER`的内容中拆分文件为`server1.log`，`server2.log`和`server3.log`。可以按以下方式完成：
- en: '[PRE132]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The details of the command are as follows:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的详细信息如下：
- en: '`/SERVER/` is the line used to match a line by which the split is to be carried
    out.'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/SERVER/`是用于匹配拆分的行。'
- en: '`/[REGEX]/` is the format. It copies from current line (first line) upto the
    matching line that contains `"SERVER"` excluding match line.'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/[REGEX]/` 是格式。它从当前行（第一行）复制到包含“SERVER”的匹配行，但不包括匹配行。'
- en: '`{*}` is used to specify to repeat splitting based on match upto the end of
    the file. By using `{integer}`, we can specify no of times it is to be continued.'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{*}`用于指定根据匹配重复拆分直到文件的末尾。通过使用`{integer}`，我们可以指定要继续的次数。'
- en: '`-s` is the flag to make the command silent rather than printing other messages.'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s`是一个标志，使命令保持安静，而不是打印其他消息。'
- en: '`-n` is used to specify the number of digits to be used as suffix. 01, 02,
    03, and so on.'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-n`用于指定要用作后缀的数字位数。01、02、03等。'
- en: '`-f` is used for specifying the filename prefix for split files ("server" is
    the prefix in the previous example).'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`用于指定拆分文件的文件名前缀（在上一个示例中的前缀是"server"）。'
- en: '`-b` is used to specify the suffix format. `"%02d.log"` is similar to the `printf`
    argument format in C. Here the filename = prefix + suffix = `"server" + "%02d.log"`.'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-b`用于指定后缀格式。`"%02d.log"`类似于C中的`printf`参数格式。这里的文件名=前缀+后缀=`"server" + "%02d.log"`。'
- en: We remove `server00.log` since the first split file is an empty file (the match
    word is the first line of the file).
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 我们删除`server00.log`，因为第一个拆分文件是一个空文件（匹配单词是文件的第一行）。
- en: Slicing filenames based on extension
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据扩展名切片文件名
- en: Several custom shell scripts perform manipulations based on file names. We may
    need to perform actions like renaming the files by preserving extension, converting
    files from one format to another (change the extension by preserving the name),
    extracting a portion of the file name, and so on. The shell comes with inbuilt
    functionalities for slicing filenames based on different conditions. Let's see
    how to do it.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 几个自定义的shell脚本根据文件名执行操作。我们可能需要执行诸如保留扩展名重命名文件，将文件从一种格式转换为另一种格式（通过保留名称更改扩展名），提取文件名的一部分等操作。Shell具有内置功能，可以根据不同条件对文件名进行切片。让我们看看如何做到这一点。
- en: How to do it…
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The name from `name.extension` can be easily extracted by using the `%` operator.
    You can extract the name from `"sample.jpg"` as follows:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 从`name.extension`中的名称可以通过使用`%`运算符轻松提取。您可以按如下方式从`"sample.jpg"`中提取名称：
- en: '[PRE133]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The output is:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE134]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The next task is to extract the extension of a file from its filename. The extension
    can be extracted using the `#` operator.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个任务是从文件名中提取文件的扩展名。可以使用`#`运算符提取扩展名。
- en: 'Extract `.jpg` from the a filename stored in variable `file_jpg` as follows:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 从变量`file_jpg`中的文件名中提取`.jpg`如下：
- en: '[PRE135]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'The output is:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE136]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: How it works..
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的..
- en: In the first task, in order to extract the name from the file name in the format
    `name.extension` we have used the `%` operator.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个任务中，为了从格式为`name.extension`的文件名中提取名称，我们使用了`%`运算符。
- en: '`${VAR%.*}` can be interpreted as:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '`${VAR%.*}` 可以解释为：'
- en: Remove the string match from the `$VARIABLE` for the wildcard pattern that appears
    to the right-hand side of % (.* in the previous example). Evaluating from the
    right to the left direction should make the wildcard match.
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`$VARIABLE`中删除通配符模式的字符串匹配，该模式出现在%的右侧（在上一个示例中为.*）。从右到左的方向进行评估应该使通配符匹配。
- en: Let `VAR=sample.jpg`. Therefore, the wildcard match for `.*` from right to left
    is `.jpg`. Thus it is removed from the `$VAR` string and the output will be "sample".
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让`VAR=sample.jpg`。因此，从右到左的通配符匹配是`.jpg`。因此它从`$VAR`字符串中删除，并且输出将是"sample"。
- en: '`%` is a non-greedy operation. It finds the minimal match for the wildcard
    from the right to left. There is an operator `%%`, which is similar to `%`. But
    it is greedy in nature. That means it matches the maximal string for the wildcard.'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`%`是一种非贪婪操作。它从右到左找到通配符的最小匹配。还有一个运算符`%%`，类似于`%`。但它是贪婪的。这意味着它匹配通配符的最大字符串。'
- en: 'For example, we have:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有：
- en: '[PRE137]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'By using the % operator, we have:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`%`运算符，我们有：
- en: '[PRE138]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The output will be: `hack.fun.book`.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：`hack.fun.book`。
- en: The operator `%` performs a non-greedy match for `.*` from right to left (`.txt`).
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符`%`从右到左执行`.*`的非贪婪匹配（`.txt`）。
- en: 'By using the %% operator, we have:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`%%`运算符，我们有：
- en: '[PRE139]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The output will be: `hack`'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：`hack`
- en: The `%%` operator matches greedy match for `.*` from right to left (.`fun.book.txt`).
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '`%%`运算符从右到左进行贪婪匹配`.*`（.`fun.book.txt`）。'
- en: In the second task, we have used the `#` operator to extract the extension from
    the filename. It is similar to `%`. But it evaluates from left to right.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个任务中，我们使用了`#`运算符从文件名中提取扩展名。它类似于`%`。但它是从左到右进行评估的。
- en: '`${VAR#*.}` can be interpreted as:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '`${VAR#*.}` 可以解释为：'
- en: Remove the string match from the `$VARIABLE` for the wildcard pattern match
    appears right side to the `#` (`*.` in the above example). Evaluating from the
    left to right direction should make the wildcard match.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 从`#`右侧出现的通配符模式匹配的字符串匹配从左到右的方向应该使通配符匹配。
- en: Similarly, as in the case of `%%`, we have another greedy operator for `#`,
    which is `##`.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，与`%%`一样，我们还有另一个贪婪运算符`#`，即`##`。
- en: It makes greedy matches by evaluating from left to right and removes the match
    string from the specified variable.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过从左到右评估并从指定变量中删除匹配字符串来进行贪婪匹配。
- en: 'Let''s use this example:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个例子：
- en: '[PRE140]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'By using the `#` operator, we have:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`#`运算符，我们有：
- en: '[PRE141]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'The output will be: `fun.book.txt`.'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：`fun.book.txt`。
- en: The operator `#` performs a non-greedy match for `*.` from left to right (`hack.`).
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符`#`对`hack.`进行了从左到右的非贪婪匹配。
- en: 'By using the ## operator, we have:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用##运算符，我们有：
- en: '[PRE142]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The output will be: `txt`.'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：`txt`。
- en: 'The operator ## matches greedy match for *. from left to right (txt).'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符##从左到右（txt）进行贪婪匹配。
- en: Note
  id: totrans-575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The ## operator is more preferred over the # operator to extract an extension
    from a filename since the filename may contain multiple ''.'' characters. Since
    ## makes greedy match, it always extract extensions only.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '##运算符比#运算符更受欢迎，用于从文件名中提取扩展名，因为文件名可能包含多个''.''字符。由于##进行贪婪匹配，它总是只提取扩展名。'
- en: 'Here is practical example that can be used to extract different portions of
    a domain name, given URL="[www.google.com](http://www.google.com)":'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个实际示例，可用于提取域名的不同部分，给定URL="[www.google.com](http://www.google.com)"：
- en: '[PRE143]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Renaming and moving files in bulk
  id: totrans-579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 批量重命名和移动文件
- en: Renaming a number of files is one of the tasks we frequently come across. A
    simple example is, when you download photos from your digital camera to the computer
    you may delete unnecessary files and it causes discontinuous numbering of image
    files. Sometimes you many need to rename them with custom prefix and continuous
    numbering for filenames. We sometimes use third-party tools for performing rename
    operations. We can use Bash commands to perform a rename operation in a couple
    of seconds.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名多个文件是我们经常遇到的任务之一。一个简单的例子是，当您从数码相机下载照片到计算机时，您可能会删除不必要的文件，导致图像文件的编号不连续。有时您可能需要使用自定义前缀和连续编号对它们进行重命名。我们有时使用第三方工具执行重命名操作。我们可以使用Bash命令在几秒钟内执行重命名操作。
- en: Moving all the files having a particular substring in the filename (for example,
    same prefix for filenames) or with a specific file type to a given directory is
    another use case we frequently perform. Let's see how to write scripts to perform
    these kinds of operations.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有文件名中包含特定子字符串（例如，文件名具有相同前缀）或具有特定文件类型的文件移动到给定目录是我们经常执行的另一个用例。让我们看看如何编写脚本来执行这些类型的操作。
- en: Getting ready
  id: totrans-582
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `rename` command helps to change file names using Perl regular expressions.
    By combining the commands `find`, `rename`, and `mv`, we can perform a lot of
    things.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '`rename`命令有助于使用Perl正则表达式更改文件名。通过组合`find`、`rename`和`mv`命令，我们可以执行很多操作。'
- en: How to do it...
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The easiest way of renaming image files in the current directory to our own
    filename with a specific format is by using the following script:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前目录中重命名图像文件为特定格式的最简单方法是使用以下脚本：
- en: '[PRE144]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The output is as follows:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE145]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The script renames all the `.jpg` and `.png` files in the current directory
    to new filenames in the format `image-1.jpg`, `image-2.jpg`, `image-3.jpg` , `image-4.png`,
    and so on.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本将当前目录中的所有`.jpg`和`.png`文件重命名为格式为`image-1.jpg`、`image-2.jpg`、`image-3.jpg`、`image-4.png`等的新文件名。
- en: How it works…
  id: totrans-590
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In the above rename script, we have used a `for` loop to iterate through the
    names of all files ending with a `.jpg` extension. The wildcard `*.jpg` and *`.png`
    are used to match all the JPEG and PNG files. We can do a small improvisation
    over the extension match. The `.jpg` wildcard matches only the extension in lowercase.
    However, we can make it case insensitive by replacing `.jpg` with `.[jJ][pP][gG]`.
    Hence it can match files like `file.jpg` as well as `file.JPG` or `file.Jpg`.
    In Bash, when characters are enclosed in `[]`, it means to match one character
    from the set of characters enclosed in `[]`.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的重命名脚本中，我们使用了`for`循环来遍历所有以`.jpg`扩展名结尾的文件名。通配符`*.jpg`和`*.png`用于匹配所有JPEG和PNG文件。我们可以对扩展名匹配进行一点改进。`.jpg`通配符只匹配小写的扩展名。然而，我们可以通过用`.[jJ][pP][gG]`替换`.jpg`来使其不区分大小写。因此它可以匹配文件`file.jpg`以及`file.JPG`或`file.Jpg`。在Bash中，当字符被包含在`[]`中时，它意味着从`[]`中包含的字符集中匹配一个字符。
- en: '`for img in *.jpg *.png` in the above code will be expanded as follows:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的`for img in *.jpg *.png`将被扩展为：
- en: '`for img in hack.jpg new.jpg next.jpg`'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '`for img in hack.jpg new.jpg next.jpg`'
- en: We have initialized a variable `count=1` in order to keep track of the image
    number. The next step is to rename the file using the `mv` command. The new name
    of the file should be formulated for renaming. `${img##*.}` in the script parses
    the extension of the filename currently in the loop (see the *Slicing file names
    based on extension* recipe for interpretation of `${img##*.}`).
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化了一个变量`count=1`，以便跟踪图像编号。下一步是使用`mv`命令重命名文件。文件的新名称应该经过制定。脚本中的`${img##*.}`解析了当前循环中的文件名的扩展名（有关`${img##*.}`的解释，请参见*基于扩展名切片文件名*配方）。
- en: '`let count++` is used to increment the file number for each execution of loop.'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '`let count++`用于递增每次循环执行的文件编号。'
- en: You can see that error redirection (`stderr`) to `/dev/null` is done for the
    `mv` command using the `2>` operator. This is to stop the error messages being
    printed into the terminal.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到使用`2>`运算符将错误重定向（`stderr`）到`/dev/null`是为了阻止错误消息打印到终端。
- en: Since we use `*.png` and `*.jpg`, if atleast one image for a wildcard match
    is not present, the shell will interpret the wildcard itself as a string. In the
    above output, you can see that `.png` files are not present. Hence it will take
    `*.png` as yet another filename and execute `mv *.png image-X.png`, which will
    cause an error. An `if` statement with `[ $? –eq 0 ]` is used to check the exit
    status (`$?`). The value of `$?` will be 0 if the last executed command is successful,
    else it returns non-zero. When the `mv` command fails, it returns non-zero and,
    therefore, the message "Renaming file" will not be shown to the user, as well
    as the count will not be incremented.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`*.png`和`*.jpg`，如果通配符匹配的至少一个图像不存在，shell将解释通配符本身作为一个字符串。在上面的输出中，您可以看到`.png`文件不存在。因此它将把`*.png`作为另一个文件名并执行`mv
    *.png image-X.png`，这将导致错误。使用`[ $? –eq 0 ]`的`if`语句来检查退出状态(`$?`)。如果最后执行的命令成功，`$?`的值将为0，否则返回非零。当`mv`命令失败时，它返回非零，因此用户将不会看到消息"重命名文件"，计数也不会增加。
- en: There are a variety of other ways to perform rename operations. Let's walk through
    a few of them.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种其他方法可以执行重命名操作。让我们来看看其中的一些。
- en: Renaming `*.JPG` to `*.jpg:`
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 将`*.JPG`重命名为`*.jpg`：
- en: '[PRE146]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Replace space in the filenames with the `"_"` character as follows:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件名中的空格替换为"`_"`字符如下：
- en: '[PRE147]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '`# ''s/ /_/g''` is the replacement part in the filename and `*` is the wildcard
    for the target files. It can be `*.txt` or any other wildcard pattern.'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '`# ''s/ /_/g''`是文件名中的替换部分，`*`是目标文件的通配符。它可以是`*.txt`或任何其他通配符模式。'
- en: 'You can convert any filename of files from uppercase to lowercase and vice
    versa as follows:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下方式将任何文件名从大写转换为小写，反之亦然：
- en: '[PRE148]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'In order to recursively move all the`.mp3` files to a given directory, use:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 为了递归地将所有`.mp3`文件移动到给定目录中，请使用：
- en: '[PRE149]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Recursively rename all the files by replacing space with "`_"` character as
    follows:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方式递归重命名所有文件，将空格替换为"`_"`字符：
- en: '[PRE150]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Spell checking and dictionary manipulation
  id: totrans-610
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拼写检查和字典操作
- en: Most Linux distributions come with a dictionary file. However, I find few people
    are aware of the dictionary file and hence many people fail to make use of them.
    There is a command-line utility called `aspell` that functions as a spell checker.
    Let's go through few scripts that make use of the dictionary file and the spell
    checker.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Linux发行版都附带一个字典文件。然而，我发现很少有人知道字典文件，因此许多人未能利用它们。有一个名为`aspell`的命令行实用程序，它可以作为拼写检查器。让我们看看一些利用字典文件和拼写检查器的脚本。
- en: How to do it...
  id: totrans-612
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The `/usr/share/dict/` directory contains some of the dictionary files. Dictionary
    files are text files that contain a list of dictionary words. We can use this
    list to check whether a word is a dictionary word or not.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '`/usr/share/dict/`目录包含一些字典文件。字典文件是包含字典单词列表的文本文件。我们可以使用这个列表来检查一个单词是否是字典单词。'
- en: '[PRE151]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'In order to check whether the given word is a dictionary word, use the following
    script:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查给定的单词是否是字典单词，请使用以下脚本：
- en: '[PRE152]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The usage is as follows:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 用法如下：
- en: '[PRE153]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: How it works...
  id: totrans-619
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In `grep`, `^` is the word start marker character and the character `$` is the
    word end marker.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 在`grep`中，`^`是单词起始标记字符，字符`$`是单词结束标记。
- en: '`-q` is used to suppress any output and to be silent.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '`-q`用于抑制任何输出并保持沉默。'
- en: 'Or, alternately, we can use the spell check, `aspell`, to check whether a word
    is in a dictionary or not as follows:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用拼写检查`aspell`来检查一个单词是否在字典中，如下所示：
- en: '[PRE154]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: The `aspell list` command returns output text when the given input is not a
    dictionary word, and does not output anything when a dictionary word is the input.
    A `-z` check ensures whether `$output` is an empty string or not.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '`aspell list`命令在给定输入不是字典单词时返回输出文本，并且在输入为字典单词时不输出任何内容。`-z`检查确保`$output`是否为空字符串。'
- en: 'List all words in a file starting with a given word as follows:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 列出文件中以给定单词开头的所有单词如下：
- en: '[PRE155]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Or alternately, use:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用：
- en: '[PRE156]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: By default, if the filename argument is not given to the `look` command, it
    uses the default dictionary (`/usr/share/dict/words`) and returns an output.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果未给出文件名参数，则`look`命令使用默认字典(`/usr/share/dict/words`)并返回输出。
- en: '[PRE157]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'For example:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE158]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Automating interactive input
  id: totrans-633
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化交互式输入
- en: 'Automating interactive input for command-line utilities are extremely useful
    for writing automation tools or testing tools. There will be many situations when
    we deal with commands that read inputs interactively. Interactive input is the
    input typed by the user only when the command asks for some input. An example
    for execution of a command and supply of interactive input is as follows:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化命令行实用程序的交互式输入对于编写自动化工具或测试工具非常有用。在处理需要交互式输入的命令时，会有许多情况。交互式输入是用户在命令要求输入时键入的输入。执行命令并提供交互式输入的示例如下：
- en: '[PRE159]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Getting ready
  id: totrans-636
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Automating utilities which can automate the acceptance of input as in the above
    mentioned manner are useful to supply input to local commands as well as for remote
    applications. Let's see how to automate them.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化实用程序可以自动接受输入，就像上面提到的方式一样，对于提供输入给本地命令以及远程应用程序都是有用的。让我们看看如何自动化它们。
- en: How to do it...
  id: totrans-638
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Think about the sequence of an interactive input. From the previous code we
    can formulate the steps of the sequence as follows:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑交互式输入的顺序。从前面的代码中，我们可以得出以下序列的步骤：
- en: '`1[Return]hello[Return]`'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '`1[Return]hello[Return]`'
- en: Converting the above steps `1,Return,hello,Return` by observing the characters
    that are actually typed in the keyboard, we can formulate the following string.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察实际在键盘上键入的字符，将上述步骤`1,Return,hello,Return`转换为以下字符串。
- en: '`"1\nhello\n"`'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '`"1\nhello\n"`'
- en: The `\n` character is sent when we press *Return*. By appending return (`\n`)
    characters, we get the actual string that is passed to the `stdin` (standard input).
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按下*Return*时，`\n`字符被发送。通过附加回车(`\n`)字符，我们得到传递给`stdin`（标准输入）的实际字符串。
- en: Hence by sending the equivalent string for the characters typed by the user,
    we can automate the passing of input in the interactive processes.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过发送用户输入的等效字符串，我们可以自动化交互过程中的输入传递。
- en: How it works…
  id: totrans-645
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s write a script that reads input interactively and uses this script for
    automation examples:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个脚本，以交互方式读取输入，并将此脚本用于自动化示例：
- en: '[PRE160]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Let''s automate the sending of input to the command as follows:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下方式自动发送输入到命令：
- en: '[PRE161]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Thus crafting inputs with `\n` works.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用`\n`来制作输入是有效的。
- en: We have used `echo -e` to produce the input sequence. If the input is large
    we can use an input file and redirection operator to supply input.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`echo -e`来生成输入序列。如果输入很大，我们可以使用输入文件和重定向运算符来提供输入。
- en: '[PRE162]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'You can also manually craft the input file without `echo` commands by hand
    typing. For example:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以手动制作输入文件，而不使用`echo`命令手动输入。例如：
- en: '[PRE163]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: This redirects interactive input data from a file.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从文件中重定向交互式输入数据。
- en: 'If you are a reverse engineer, you may have played with buffer overflow exploits.
    To exploit them we need to redirect shellcode like `"\xeb\x1a\x5e\x31\xc0\x88\x46"`,
    which is written in hex. These characters cannot be typed directly through keyboard
    since, keys for these characters are not present in the keyboard. Therefore we
    should use:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是一名逆向工程师，您可能已经玩过缓冲区溢出漏洞。为了利用它们，我们需要重定向shellcode，比如`"\xeb\x1a\x5e\x31\xc0\x88\x46"`，它是用十六进制编写的。这些字符不能直接通过键盘输入，因为键盘上没有这些字符的键。因此我们应该使用：
- en: '`echo -e "\xeb\x1a\x5e\x31\xc0\x88\x46"`'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo -e "\xeb\x1a\x5e\x31\xc0\x88\x46"`'
- en: This will redirect shellcode to a vulnerable executable.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把shellcode重定向到一个有漏洞的可执行文件。
- en: We have described a method to automate interactive input programs by redirecting
    expected input text through `stdin` (standard input). We are sending the input
    without checking the input the program asks for. We are sending the input by expecting
    the program to ask input in a specific (static) order. If the program asks input
    randomly or in a changing order, or sometimes certain inputs are never asked,
    the above method fails. It will send wrong inputs to different input prompts by
    the program. In order to handle dynamic input supply and provide input by checking
    the input requirements by the program on runtime, we have a great utility called
    `expect`. The `expect` command supplies correct input for the correct input prompt
    by the program. Let's see how to use `expect`.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经描述了一种通过将预期输入文本重定向通过`stdin`（标准输入）来自动化交互式输入程序的方法。我们发送输入而不检查程序要求的输入。我们通过期望程序按特定（静态）顺序要求输入来发送输入。如果程序随机或以不同顺序要求输入，或者有时根本不要求某些输入，则上述方法将失败。它将向程序的不同输入提示发送错误的输入。为了处理动态输入供应并通过检查程序在运行时的输入要求来提供输入，我们有一个称为`expect`的实用工具。`expect`命令通过程序发送正确的输入到正确的输入提示。让我们看看如何使用`expect`。
- en: There's more...
  id: totrans-660
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Automation of interactive input can also be done using other methods. Expect
    scripting is another method for automation. Let's go through it.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式输入的自动化也可以使用其他方法。Expect脚本是另一种自动化方法。让我们来看看。
- en: Automating with expect
  id: totrans-662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用expect进行自动化
- en: The `expect` utility does not come by default with most of the common Linux
    distributions. You have to install the expect package manually using package manager.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect`实用程序在大多数常见的Linux发行版中默认不包含。您必须使用软件包管理器手动安装expect软件包。'
- en: '`expect` expects for a particular input prompt and sends data by checking message
    in the input prompt.'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '`expect`期望特定的输入提示，并通过检查输入提示中的消息发送数据。'
- en: '[PRE164]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Run as:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 运行如下：
- en: '[PRE165]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'In this script:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中：
- en: '`spawn` parameter specifies which command is to be automated'
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spawn`参数指定要自动化的命令'
- en: '`expect` parameter provides the expected message'
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect`参数提供了预期的消息'
- en: '`send` is the message to be sent.'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send`是要发送的消息。'
- en: '`expect eof` defines the end of command interaction'
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expect eof`定义了命令交互的结束'
