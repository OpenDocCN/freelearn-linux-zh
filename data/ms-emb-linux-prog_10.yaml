- en: Chapter 10. Learning About Processes and Threads
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。了解进程和线程
- en: In the preceding chapters, we have considered the various aspects of creating
    an embedded Linux platform. Now it is time to start looking at how you can use
    the platform to create a working device. In this chapter, I will talk about the
    implications of the Linux process model and how it encompasses multi-threaded
    programs. I will look at the pros and cons of using single-threaded and multi-threaded
    processes. I will also look at scheduling and differentiate between timeshare
    and real-time scheduling policies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们考虑了创建嵌入式Linux平台的各个方面。现在是时候开始了解如何使用该平台创建工作设备了。在本章中，我将讨论Linux进程模型的含义以及它如何包含多线程程序。我将探讨使用单线程和多线程进程的利弊。我还将研究调度，并区分时间共享和实时调度策略。
- en: While these topics are not specific to embedded computing, it is important for
    a designer of an embedded device to have an overview of these topics. There are
    many good reference works on the subject, some of which I reference at the end
    of the chapter, but in general, they do not consider the embedded use cases. In
    consequence, I will be concentrating on the concepts and design decisions rather
    than on the function calls and code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些主题与嵌入式计算无关，但对于嵌入式设备的设计者来说，了解这些主题非常重要。关于这个主题有很多好的参考书籍，其中一些我在本章末尾引用，但一般来说，它们并不考虑嵌入式用例。因此，我将集中讨论概念和设计决策，而不是函数调用和代码。
- en: Process or thread?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程还是线程？
- en: Many embedded developers who are familiar with **real-time operating systems**
    (**RTOS**) consider the Unix process model to be cumbersome. On the other hand,
    they see a similarity between an RTOS task and a Linux thread and they have a
    tendency to transfer an existing design using a one-to-one mapping of RTOS tasks
    to threads. I have, on several occasions, seen designs in which the entire application
    is implemented with one process containing 40 or more threads. I want to spend
    some time considering if this is a good idea or not. Let's begin with some definitions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 许多熟悉**实时操作系统**（RTOS）的嵌入式开发人员认为Unix进程模型很繁琐。另一方面，他们认为RTOS任务和Linux线程之间存在相似性，并倾向于使用一对一的映射将现有设计转移到线程。我曾多次看到整个应用程序都是使用包含40个或更多线程的一个进程来实现的设计。我想花一些时间考虑这是否是一个好主意。让我们从一些定义开始。
- en: 'A process is a memory address space and a thread of execution, as shown in
    the following diagram. The address space is private to the process and so threads
    running in different processes. cannot access it. This memory separation is created
    by the memory management subsystem in the kernel, which keeps a memory page mapping
    for each process and re-programs the memory management unit on each context switch.
    I will describe how this works in detail in [Chapter 11](ch11.html "Chapter 11. Managing
    Memory"), *Managing Memory*. Part of the address space is mapped to a file which
    contains the code and static data that the program is running:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是一个内存地址空间和一个执行线程，如下图所示。地址空间对进程是私有的，因此在不同进程中运行的线程无法访问它。这种内存分离是由内核中的内存管理子系统创建的，该子系统为每个进程保留一个内存页映射，并在每次上下文切换时重新编程内存管理单元。我将在[第11章](ch11.html
    "第11章。管理内存")*管理内存*中详细描述这是如何工作的。地址空间的一部分映射到一个文件，其中包含程序正在运行的代码和静态数据：
- en: '![Process or thread?](img/B03982_10_01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![进程还是线程？](img/B03982_10_01.jpg)'
- en: 'As the program runs, it will allocate resources such as stack space, heap memory,
    references to files, and so on. When the process terminates, these resources are
    reclaimed by the system: all the memory is freed up and all the file descriptors
    are closed.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 随着程序的运行，它将分配资源，如堆栈空间，堆内存，文件引用等。当进程终止时，系统将回收这些资源：所有内存都被释放，所有文件描述符都被关闭。
- en: Processes can communicate with each other using **inter process communication**
    (**IPC**) such as local sockets. I will talk about IPC later on.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以使用**进程间通信**（IPC）（如本地套接字）相互通信。我将在后面谈论IPC。
- en: 'A thread is a thread of execution within a process. All processes begin with
    one thread that runs the `main()` function and is called the main thread. You
    can create additional threads using the POSIX threads function `pthread_create(3)`,
    causing additional threads to execute in the same address space, as shown in the
    following diagram. Being in the same process, they share resources with each other.
    They can read and write the same memory and use the same file descriptors, and
    so communication between threads is easy, so long as you take care of the synchronization
    and locking issues:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是进程内的执行线程。所有进程都从运行`main()`函数的一个线程开始，称为主线程。您可以使用POSIX线程函数`pthread_create(3)`创建额外的线程，导致额外的线程在相同的地址空间中执行，如下图所示。由于它们在同一个进程中，它们共享资源。它们可以读写相同的内存并使用相同的文件描述符，因此线程之间的通信很容易，只要您注意同步和锁定问题：
- en: '![Process or thread?](img/B03982_10_02.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![进程还是线程？](img/B03982_10_02.jpg)'
- en: So, based on these brief details, you could imagine two extreme designs for
    a hypothetical system with 40 RTOS tasks being ported to Linux.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基于这些简要细节，您可以想象一个假设系统的两种极端设计，该系统有40个RTOS任务被移植到Linux。
- en: You could map tasks to processes, and have 40 individual programs communicating
    through IPC, for example with messages sent through sockets. You would greatly
    reduce memory corruption problems since the main thread running in each process
    is protected from the others, and you would reduce resource leakage since each
    process is cleaned up after it exits. However, the message interface between processes
    is quite complex and, where there is tight cooperation between a group of processes,
    the number of messages might be large and so become a limiting factor in the performance
    of the system. Furthermore, any one of the 40 processes may terminate, perhaps
    because of a bug causing it to crash, leaving the other 39 to carry on. Each process
    would have to handle the case that its neighbors are no longer running and recover
    gracefully.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将任务映射到进程，并通过IPC进行通信，例如通过套接字发送消息，有40个单独的程序。这样做可以大大减少内存损坏问题，因为每个进程中运行的主线程都受到其他线程的保护，还可以减少资源泄漏，因为每个进程在退出后都会被清理。然而，进程之间的消息接口非常复杂，当一组进程之间有紧密的合作时，消息的数量可能会很大，因此成为系统性能的限制因素。此外，40个进程中的任何一个可能会终止，也许是因为出现错误导致崩溃，剩下的39个继续运行。每个进程都必须处理其邻居不再运行并优雅地恢复的情况。
- en: At the other extreme, you could map tasks to threads and implement the system
    as a single process containing 40 threads. Cooperation becomes much easier because
    they share the same address space and file descriptors. The overhead of sending
    messages is reduced or eliminated and context switches between threads are faster
    than between processes. The downside is that you have introduced the possibility
    of one task corrupting the heap or the stack of another. If any one of the threads
    encounters a fatal bug, the whole process will terminate, taking all the threads
    with it. Finally, debugging a complex multi-threaded process can be a nightmare.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个极端，您可以将任务映射到线程，并将系统实现为包含40个线程的单个进程。合作变得更容易，因为它们共享相同的地址空间和文件描述符。发送消息的开销减少或消除，线程之间的上下文切换比进程之间的快。缺点是引入了一个任务破坏另一个任务的堆栈的可能性。如果任何一个线程遇到致命错误，整个进程将终止，带走所有的线程。最后，调试复杂的多线程进程可能是一场噩梦。
- en: The conclusion you should draw is that neither design is ideal, and that there
    is a better way. But before we get to that point, I will delve a little more deeply
    into the APIs and the behavior of processes and threads.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得出的结论是，这两种设计都不是理想的，有更好的方法。但在我们达到这一点之前，我将更深入地探讨进程和线程的API和行为。
- en: Processes
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程
- en: 'A process holds the environment in which threads can run: it holds the memory
    mappings, the file descriptors, the user and group IDs, and more. The first process
    is the `init` process, which is created by the kernel during boot and has a PID
    of one. Thereafter, processes are created by duplication in an operation known
    as forking.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 进程保存了线程可以运行的环境：它保存了内存映射、文件描述符、用户和组ID等。第一个进程是`init`进程，它是由内核在启动期间创建的，PID为1。此后，进程是通过复制创建的，这个操作称为forking。
- en: Creating a new process
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新进程
- en: 'The `POSIX` function to create a process is `fork(2)`. It is an odd function
    because, for each successful call, there are two returns: one in the process that
    made the call, known as the parent, and one in the newly created process, known
    as the child as shown in the following diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 创建进程的`POSIX`函数是`fork(2)`。这是一个奇怪的函数，因为对于每次成功调用，都有两个返回值：一个在进行调用的进程中，称为父进程，另一个在新创建的进程中，称为子进程，如下图所示：
- en: '![Creating a new process](img/B03982_10_03.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个新进程](img/B03982_10_03.jpg)'
- en: 'Immediately after the call, the child is an exact copy of the parent, it has
    the same stack, the same heap, the same file descriptors, and executes the same
    line of code, the one following `fork(2)`. The only way the programmer can tell
    them apart is by looking at the return value of fork: it is zero for the child
    and greater than zero for the parent. Actually, the value returned in the parent
    is the PID of the newly created child process. There is a third possibility, which
    is that the return is negative, meaning that the fork call failed and there is
    still only one process.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用之后，子进程是父进程的精确副本，它有相同的堆栈、相同的堆、相同的文件描述符，并执行与`fork(2)`后面的相同代码行。程序员唯一能够区分它们的方法是查看fork的返回值：对于子进程，返回值为零，对于父进程，返回值大于零。实际上，在父进程中返回的值是新创建的子进程的PID。还有第三种可能性，即返回值为负，意味着fork调用失败，仍然只有一个进程。
- en: Although the two processes are initially identical, they are in separate address
    spaces. Changes made to a variable by one will not be seen by the other. Under
    the hood, the kernel does not make a physical copy of the parent's memory, which
    would be quite a slow operation and consume memory unnecessarily. Instead, the
    memory is shared but marked with a **copy-on-write** (**CoW**) flag. If either
    parent or child modifies this memory, the kernel first makes a copy and then writes
    to the copy. This has the benefit of an efficient fork function while retaining
    the logical separation of process address spaces. I will discuss CoW in [Chapter
    11](ch11.html "Chapter 11. Managing Memory"), *Managing Memory*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个进程最初是相同的，但它们处于单独的地址空间中。一个进程对变量的更改不会被另一个进程看到。在底层，内核不会对父进程的内存进行物理复制，这将是一个相当缓慢的操作，并且会不必要地消耗内存。相反，内存是共享的，但标记有**写时复制**（**CoW**）标志。如果父进程或子进程修改了这个内存，内核首先会进行复制，然后写入复制。这样做既有了高效的fork函数，又保留了进程地址空间的逻辑分离。我将在[第11章](ch11.html
    "第11章。管理内存")*管理内存*中讨论CoW。
- en: Terminating a process
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终止进程
- en: A process may be stopped voluntarily by calling the `exit(3)` function or, involuntarily,
    by receiving a signal that is not handled. One signal in particular, `SIGKILL`,
    cannot be handled and so will always kill a process. In all cases, terminating
    the process will stop all threads, close all file descriptors, and release all
    memory. The system sends a signal, `SIGCHLD`, to the parent so that it knows this
    has happened.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以通过调用`exit(3)`函数自愿停止，或者通过接收未处理的信号而被迫停止。特别是，一个信号`SIGKILL`无法被处理，因此将总是杀死一个进程。在所有情况下，终止进程将停止所有线程，关闭所有文件描述符，并释放所有内存。系统会向父进程发送一个`SIGCHLD`信号，以便它知道发生了这种情况。
- en: 'Processes have a return value which is composed of either the argument to `exit(3)`,
    if it terminated normally, or the signal number if it was killed. The chief use
    for this is in shell scripts: it allows you to test the return from a program.
    By convention, `0` indicates success and other values indicate a failure of some
    sort.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 进程有一个返回值，由`exit(3)`的参数组成，如果它正常终止，或者如果它被杀死，则由信号编号组成。这主要用于shell脚本：它允许您测试程序的返回值。按照惯例，`0`表示成功，其他值表示某种失败。
- en: 'The parent can collect the return value with the `wait(2)` or `waitpid(2)`
    functions. This causes a problem: there will be a delay between a child terminating
    and its parent collecting the return value. In that period, the return value must
    be stored somewhere, and the PID number of the now dead process cannot be reused.
    A process in this state is a `zombie`, state Z in ps or top. So long as the parent
    calls `wait(2)` or `waitpid(2)`, whenever it is notified of a child''s termination
    (by means of the `SIGCHLD` signal, see *Linux System Programming*, by *Robert
    Love*, *O''Reilly Media* or *The Linux Programming Interface*, by *Michael Kerrisk*,
    *No Starch Press* for details of handling signals), zombies exist for too short
    a time to show up in process listings. They will become a problem if the parent
    fails to collect the return value because you will not be able to create any more
    processes.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程可以使用`wait(2)`或`waitpid(2)`函数收集返回值。这会导致一个问题：子进程终止和其父进程收集返回值之间会有延迟。在这段时间内，返回值必须存储在某个地方，现在已经死掉的进程的PID号码不能被重用。处于这种状态的进程是`僵尸`，在ps或top中是Z状态。只要父进程调用`wait(2)`或`waitpid(2)`，每当它被通知子进程的终止（通过`SIGCHLD`信号，参见*Linux系统编程*，由*Robert
    Love*，*O'Reilly Media*或*The Linux Programming Interface*，由*Michael Kerrisk*，*No
    Starch Press*有关处理信号的详细信息），僵尸存在的时间太短，无法在进程列表中显示出来。如果父进程未能收集返回值，它们将成为一个问题，因为您将无法创建更多进程。
- en: 'Here is a simple example, showing process creation and termination:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，显示了进程的创建和终止：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `wait(2)` function blocks until a child process exits and stores the exit
    status. When you run it, you see something like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait(2)`函数会阻塞，直到子进程退出并存储退出状态。当您运行它时，会看到类似这样的东西：'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The child process inherits most of the attributes of the parent, including the
    user and group IDs (UID and GID), all open file descriptors, signal handling,
    and scheduling characteristics.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程继承了父进程的大部分属性，包括用户和组ID（UID和GID），所有打开的文件描述符，信号处理和调度特性。
- en: Running a different program
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行不同的程序
- en: 'The `fork` function creates a copy of a running program, but it does not run
    a different program. For that, you need one of the `exec` functions:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`fork`函数创建一个正在运行程序的副本，但它不运行不同的程序。为此，您需要其中一个`exec`函数：'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Each takes a path to the program file to load and run. If the function succeeds,
    the kernel discards all the resources of the current process, including memory
    and file descriptors, and allocates memory to the new program being loaded. When
    the thread that called `exec*` returns, it returns not to the line of code after
    the call, but to the `main()` function of the new program. Here is an example
    of a command launcher: it prompts for a command, for example, `/bin/ls`, and forks
    and executes the string you enter:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都需要一个要加载和运行的程序文件的路径。如果函数成功，内核将丢弃当前进程的所有资源，包括内存和文件描述符，并为正在加载的新程序分配内存。当调用`exec*`的线程返回时，它不会返回到调用后的代码行，而是返回到新程序的`main()`函数。这是一个命令启动器的示例：它提示输入一个命令，例如`/bin/ls`，然后分叉和执行您输入的字符串：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It might seem odd to have one function that duplicates an existing process and
    another that discards its resources and loads a different program into memory,
    especially since it is common for a fork to be followed almost immediately by
    `exec`. Most operating systems combine the two actions into a single call.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个函数复制现有进程，另一个丢弃其资源并将不同的程序加载到内存中，这可能看起来有点奇怪，特别是因为`fork`后几乎立即跟随`exec`。大多数操作系统将这两个操作合并为一个单独的调用。
- en: 'There are distinct advantages, however. For example, it makes it very easy
    to implement redirection and pipes in the shell. Imagine that you want to get
    a directory listing, this is the sequence of events:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这确实有明显的优势。例如，它使得在shell中实现重定向和管道非常容易。想象一下，您想要获取目录列表，这是事件的顺序：
- en: You type `ls` at the shell prompt.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在shell提示符处键入`ls`。
- en: The shell forks a copy of itself.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: shell分叉一个自身的副本。
- en: The child execs `/bin/ls`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子进程执行`/bin/ls`。
- en: The `ls` program prints the directory listing to `stdout` (file descriptor 1)
    which is attached to the terminal. You see the directory listing.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ls`程序将目录列表打印到`stdout`（文件描述符1），该文件描述符连接到终端。您会看到目录列表。'
- en: The `ls` program terminates and the shell regains control.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ls`程序终止，shell重新获得控制。'
- en: 'Now, imagine that you want the directory listing to be written to a file by
    redirecting the output using the `>` character. The sequence is now as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，您希望通过重定向输出使用`>`字符将目录列表写入文件。现在的顺序如下：
- en: You type `ls > listing.txt`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您键入`ls > listing.txt`。
- en: The shell forks a copy of itself.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: shell分叉一个自身的副本。
- en: The child opens and truncates the file `listing.txt`, and uses `dup2(2)` to
    copy the file descriptor of the file over file descriptor 1 (`stdout`).
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子进程打开并截断文件`listing.txt`，并使用`dup2(2)`将文件的文件描述符复制到文件描述符1（`stdout`）。
- en: The child execs `/bin/ls`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子进程执行`/bin/ls`。
- en: The program prints the listing as before, but this time it is writing to `listing.txt`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序像以前一样打印列表，但这次是写入到`listing.txt`。
- en: The `ls` program terminates and the shell regains control.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ls`程序终止，shell重新获得控制。'
- en: Note that there is an opportunity at step three to modify the environment of
    the child process before executing the program. The `ls` program does not need
    to know that it is writing to a file rather than a terminal. Instead of a file,
    `stdout` could be connected to a pipe and so the `ls` program, still unchanged,
    can send output to another program. This is part of the Unix philosophy of combining
    many small components that each do a job well, as described in *The Art of Unix
    Programming*, by *Eric Steven Raymond, Addison Wesley*; (23 Sept. 2003) ISBN 978-0131429017,
    especially in the section *Pipes, Redirection, and Filters*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第三步有机会修改子进程执行程序之前的环境。`ls`程序不需要知道它正在写入文件而不是终端。`stdout`可以连接到管道，因此`ls`程序仍然不变，可以将输出发送到另一个程序。这是Unix哲学的一部分，即将许多小组件组合在一起，每个组件都能很好地完成一项工作，如*The
    Art of Unix Programming*，作者*Eric Steven Raymond, Addison Wesley*中所述；（2003年9月23日）ISBN
    978-0131429017，特别是在*Pipes, Redirection, and Filters*部分。
- en: Daemons
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 守护进程
- en: 'We have encountered daemons in several places already. A daemon is a process
    that runs in the background, owned by the `init` process, `PID1`, and not connected
    to a controlling terminal. The steps to create a daemon are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在几个地方遇到了守护进程。守护进程是在后台运行的进程，由`init`进程，`PID1`拥有，并且不连接到控制终端。创建守护进程的步骤如下：
- en: Call `fork()` to create a new process, after which the parent should exit, thus
    creating an orphan which will be re-parented to `init.`
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`fork()`创建一个新进程，之后父进程应该退出，从而创建一个孤儿进程，将被重新分配给`init`。
- en: The child process calls `setsid(2)`, creating a new session and process group
    of which it is the sole member. The exact details do not matter here, you can
    simply consider this as a way of isolating the process from any controlling terminal.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子进程调用`setsid(2)`，创建一个新的会话和进程组，它是唯一的成员。这里确切的细节并不重要，你可以简单地将其视为一种将进程与任何控制终端隔离的方法。
- en: Change the working directory to the root.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将工作目录更改为根目录。
- en: Close all file descriptors and redirect `stdin`, `stdout`, and `sterr` (descriptors
    0, 1, and 2) to `/dev/null` so that there is no input and all output is hidden.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭所有文件描述符，并将`stdin`、`stdout`和`sterr`（描述符0、1和2）重定向到`/dev/null`，以便没有输入，所有输出都被隐藏。
- en: Thankfully, all of the preceding steps can be achieved with a single function
    call, `daemon(3)`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 值得庆幸的是，所有前面的步骤都可以通过一个函数调用`daemon(3)`来实现。
- en: Inter-process communication
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程间通信
- en: Each process is an island of memory. You can pass information from one to another
    in two ways. Firstly, you can copy it from one address space to the other. Secondly,
    you can create an area of memory that both can access and so share the data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都是一个内存岛。你可以通过两种方式将信息从一个进程传递到另一个进程。首先，你可以将它从一个地址空间复制到另一个地址空间。其次，你可以创建一个两者都可以访问的内存区域，从而共享数据。
- en: 'The first is usually combined with a queue or buffer so that there is a sequence
    of messages passing between processes. This implies copying the message twice:
    first to a holding area and then to the destination. Some examples of this are
    sockets, pipes, and POSIX message queues.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常第一种方法与队列或缓冲区结合在一起，以便进程之间有一系列消息传递。这意味着消息需要复制两次：首先到一个临时区域，然后到目的地。一些例子包括套接字、管道和POSIX消息队列。
- en: The second way requires not only a method of creating memory that is mapped
    into two (or more) address spaces at once, but also a means of synchronizing access
    to that memory, for example, by using semaphores or mutexes. POSIX has functions
    for all of these.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法不仅需要一种将内存映射到两个（或更多）地址空间的方法，还需要一种同步访问该内存的方法，例如使用信号量或互斥体。POSIX有所有这些功能的函数。
- en: There is an older set of APIs known as System V IPC, which provides message
    queues, shared memory, and semaphores, but it is not as flexible as the POSIX
    equivalents so I will not describe it here. The man page on `svipc(7)` gives an
    overview of the facilities and there is more detail in *The Linux Programming
    Interface*, by *Michael Kerrisk*, *No Starch Press* and *Unix Network Programming,
    Volume 2*, by *W. Richard Stevens*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一组较旧的API称为System V IPC，它提供消息队列、共享内存和信号量，但它不像POSIX等效果那样灵活，所以我不会在这里描述它。`svipc(7)`的man页面概述了这些设施，*The
    Linux Programming Interface*，作者*Michael Kerrisk*，*No Starch Press*和*Unix Network
    Programming, Volume 2*，作者*W. Richard Stevens*中有更多细节。
- en: Message-based protocols are usually easier to program and debug than shared
    memory, but are slow if the messages are large.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 基于消息的协议通常比共享内存更容易编程和调试，但如果消息很大，则速度会慢。
- en: Message-based IPC
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于消息的IPC
- en: 'There are several options which I will summarize as follows. The attributes
    that differentiate between them are:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种选项，我将总结如下。区分它们的属性是：
- en: Whether the message flow is uni- or bi-directorial.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息流是单向还是双向。
- en: Whether the data flow is a byte stream, with no message boundary, or discrete
    messages with boundaries preserved. In the latter case, the maximum size of a
    message is important.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据流是否是字节流，没有消息边界，或者是保留边界的离散消息。在后一种情况下，消息的最大大小很重要。
- en: Whether messages are tagged with a priority.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息是否带有优先级标记。
- en: 'The following table summarizes these properties for FIFOs, sockets, and message
    queues:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了FIFO、套接字和消息队列的这些属性：
- en: '| Property | FIFO | Unix socket: stream | Unix socket: datagram | POSIX message
    queue |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | FIFO | Unix套接字：流 | Unix套接字：数据报 | POSIX消息队列 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Message boundary | Byte stream | Byte stream | Discrete | Discrete |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 消息边界 | 字节流 | 字节流 | 离散 | 离散 |'
- en: '| Uni/bi-directional | Uni | Bi | Uni | Uni |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: 单/双向 | 单向 | 双向 | 单向 | 单向 |
- en: '| Max message size | Unlimited | Unlimited | In the range 100 KiB to 250 KiB
    | Default: 8 KiB, absolute maximum: 1 MiB |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 最大消息大小 | 无限制 | 无限制 | 在100 KiB到250 KiB范围内 | 默认：8 KiB，绝对最大：1 MiB |'
- en: '| Priority levels | None | None | None | 0 to 32767 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 优先级级别 | 无 | 无 | 无 | 0到32767 |'
- en: Unix (or local) sockets
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Unix（或本地）套接字
- en: Unix sockets fulfill most requirements and, coupled with the familiarity of
    the sockets API, they are by far the most common mechanism.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Unix套接字满足大多数要求，并且与套接字API的熟悉度结合在一起，它们是迄今为止最常见的机制。
- en: Unix sockets are created with the address family `AF_UNIX` and bound to a path
    name. Access to the socket is determined by the access permission of the socket
    file. As with Internet sockets, the socket type can be `SOCK_STREAM` or `SOCK_DGRAM`,
    the former giving a bi-directional byte stream, and the latter providing discrete
    messages with preserved boundaries. Unix socket datagrams are reliable, meaning
    that they will not be dropped or reordered. The maximum size for a datagram is
    system-dependent and is available via `/proc/sys/net/core/wmem_max`. It is typically
    100 KiB or more.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Unix套接字使用地址族`AF_UNIX`创建，并绑定到路径名。对套接字的访问取决于套接字文件的访问权限。与Internet套接字一样，套接字类型可以是`SOCK_STREAM`或`SOCK_DGRAM`，前者提供双向字节流，后者提供保留边界的离散消息。Unix套接字数据报是可靠的，这意味着它们不会被丢弃或重新排序。数据报的最大大小取决于系统，并且可以通过`/proc/sys/net/core/wmem_max`获得。通常为100
    KiB或更大。
- en: Unix sockets do not have a mechanism for indicating the priority of a message.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Unix套接字没有指示消息优先级的机制。
- en: FIFOs and named pipes
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: FIFO和命名管道
- en: FIFO and named pipe are just different terms for the same thing. They are an
    extension of the anonymous pipe that is used to communicate between parent and
    child and are used to implement piping in the shell.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: FIFO和命名管道只是相同事物的不同术语。它们是匿名管道的扩展，用于在父进程和子进程之间通信，并用于在shell中实现管道。
- en: A FIFO is a special sort of file, created by the command `mkfifo(1)`. As with
    Unix sockets, the file access permissions determine who can read and write. They
    are uni-directional, meaning that there is one reader and usually one writer,
    though there may be several. The data is a pure byte stream but with a guarantee
    of atomicity of messages that are smaller than the buffer associated with the
    pipe. In other words, writes less than this size will not be split into several
    smaller writes and so the reader will read the whole message in one go, so long
    as the size of the buffer at the reader end is large enough. The default size
    of the FIFO buffer is 64 KiB on modern kernels and can be increased using `fcntl(2)`
    with `F_SETPIPE_SZ` up to the value in `/proc/sys/fs/pipe-max-size`, typically
    1 MiB.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: FIFO是一种特殊类型的文件，由命令`mkfifo(1)`创建。与Unix套接字一样，文件访问权限决定了谁可以读和写。它们是单向的，意味着有一个读取者和通常一个写入者，尽管可能有几个。数据是纯字节流，但保证了小于管道关联缓冲区的消息的原子性。换句话说，小于此大小的写入将不会分成几个较小的写入，因此读取者将一次性读取整个消息，只要读取端的缓冲区大小足够大。现代内核的FIFO缓冲区的默认大小为64
    KiB，并且可以使用`fcntl(2)`和`F_SETPIPE_SZ`增加到`/proc/sys/fs/pipe-max-size`中的值，通常为1 MiB。
- en: There is no concept of priority.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 没有优先级的概念。
- en: POSIX message queues
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: POSIX消息队列
- en: 'Message queues are identified by a name, which must begin with a forward slash
    `/` and contain only one `/` character: message queues are actually kept in a
    pseudo filesystem of the type `mqueue`. You create a queue and get a reference
    to an existing queue through `mq_open(3)`, which returns a file. Each message
    has a priority and messages are read from the queue in priority and then age order.
    Messages can be up to `/proc/sys/kernel/msgmax` bytes long. The default value
    is 8 KiB, but you can set it to be any size in the range 128 bytes to 1 MiB by
    writing the value to `/proc/sys/kernel/msgmax` bytes. Each message has a priority.
    They are read from the queue in priority then age order. Since the reference is
    a file descriptor, you can use `select(2)`, `poll(2)`, and other similar functions
    to wait for activity on the queue.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列由名称标识，名称必须以斜杠`/`开头，并且只能包含一个`/`字符：消息队列实际上保存在类型为`mqueue`的伪文件系统中。您可以通过`mq_open(3)`创建队列并获取对现有队列的引用，该函数返回一个文件。每条消息都有一个优先级，并且消息按优先级和年龄顺序从队列中读取。消息的最大长度可以达到`/proc/sys/kernel/msgmax`字节。默认值为8
    KiB，但您可以将其设置为范围为128字节到1 MiB的任何大小，方法是将该值写入`/proc/sys/kernel/msgmax`字节。每条消息都有一个优先级。它们按优先级和年龄顺序从队列中读取。由于引用是文件描述符，因此您可以使用`select(2)`、`poll(2)`和其他类似的函数等待队列上的活动。
- en: See the Linux man page *mq_overview(7)*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 参见Linux man页面*mq_overview(7)*。
- en: Summary of message-based IPC
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于消息的IPC的总结
- en: Unix sockets are the most often used because they offer all that is needed,
    except perhaps message priority. They are implemented on most operating systems,
    and so they confer maximum portability.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Unix套接字最常用，因为它们提供了除消息优先级之外的所有所需功能。它们在大多数操作系统上都有实现，因此具有最大的可移植性。
- en: FIFOs are less used, mostly because they lack an equivalent to a datagram. On
    the other hand, the API is very simple, being the normal `open(2)`, `close(2)`,
    `read(2)`, and `write(2)` file calls.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: FIFO很少使用，主要是因为它们缺乏数据报的等效功能。另一方面，API非常简单，使用常规的`open(2)`、`close(2)`、`read(2)`和`write(2)`文件调用。
- en: Message queues are the least commonly used of this group. The code paths in
    the kernel are not optimized in the way that socket (network) and FIFO (filesystem)
    calls are.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列是这组中最不常用的。内核中的代码路径没有像套接字（网络）和FIFO（文件系统）调用那样进行优化。
- en: There are also higher level abstractions, in particular dbus, which are moving
    from mainstream Linux into embedded devices. Dbus uses Unix sockets and shared
    memory under the surface.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更高级的抽象，特别是dbus，它正在从主流Linux转移到嵌入式设备。DBus在表面下使用Unix套接字和共享内存。
- en: Shared memory-based IPC
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于共享内存的IPC
- en: Sharing memory removes the need for copying data between address spaces but
    introduces the problem of synchronizing accesses to it. Synchronization between
    processes is commonly achieved using semaphores.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存消除了在地址空间之间复制数据的需要，但引入了对其进行同步访问的问题。进程之间的同步通常使用信号量来实现。
- en: POSIX shared memory
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: POSIX共享内存
- en: 'To share memory between processes, you first have to create a new area of memory
    and then map it into the address space of each process that wants access to it,
    as in the following diagram:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要在进程之间共享内存，首先必须创建一个新的内存区域，然后将其映射到每个希望访问它的进程的地址空间中，如下图所示：
- en: '![POSIX shared memory](img/B03982_10_04.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![POSIX共享内存](img/B03982_10_04.jpg)'
- en: POSIX shared memory follows the pattern we encountered with message queues.
    The segments are identified by names that begin with a `/` character and have
    exactly one such character. The function `shm_open(3)` takes the name and returns
    a file descriptor for it. If it does not exist already and the `O_CREAT` flag
    is set, then a new segment is created. Initially it has a size of zero. Use the
    (misleadingly named) `ftruncate(2)` to expand it to the desired size.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX共享内存遵循我们在消息队列中遇到的模式。段的标识以`/`字符开头，并且正好有一个这样的字符。函数`shm_open(3)`接受名称并返回其文件描述符。如果它不存在并且设置了`O_CREAT`标志，那么将创建一个新段。最初它的大小为零。使用（名字有点误导的）`ftruncate(2)`将其扩展到所需的大小。
- en: Once you have a descriptor for the shared memory, you map it into the address
    space of the process using `mmap(2)`, and so threads in different processes can
    access the memory.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了共享内存的描述符，你可以使用`mmap(2)`将其映射到进程的地址空间中，因此不同进程中的线程可以访问该内存。
- en: 'Here is an example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The memory in Linux is taken from a `tmpfs` filesystem mounted in `/dev/shm`
    or `/run/shm`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中的内存来自于`tmpfs`文件系统，挂载在`/dev/shm`或`/run/shm`中。
- en: Threads
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程
- en: Now it is time to look at multi-threaded processes. The programming interface
    for threads is the POSIX threads API, which was first defined in IEEE POSIX 1003.1c
    standard (1995), commonly known as Pthreads. It was implemented as an additional
    part of the C library, `libpthread.so`. There have been two versions of Pthreads
    over the last 15 years or so, Linux Threads and the **Native POSIX Thread Library**
    (**NPTL**). The latter is much more compliant with the specification, particularly
    with regard to the handling of signals and process IDs. It is pretty dominant
    now, but you may come across some older versions of uClibc that use Linux Threads.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看多线程进程了。线程的编程接口是POSIX线程API，最初在IEEE POSIX 1003.1c标准（1995年）中定义，通常称为Pthreads。它作为C库的附加部分实现，`libpthread.so`。在过去15年左右，已经有两个版本的Pthreads，Linux
    Threads和**本地POSIX线程库**（**NPTL**）。后者更符合规范，特别是在处理信号和进程ID方面。它现在相当占主导地位，但你可能会遇到一些使用Linux
    Threads的旧版本uClibc。
- en: Creating a new thread
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新线程
- en: 'The function to create a thread is `pthread_create(3)`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建线程的函数是`pthread_create(3)`：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It creates a new thread of execution which begins at the function `start_routine`
    and places a descriptor in `pthread_t` pointed to by `thread`. It inherits the
    scheduling parameters of the calling thread but these can be overridden by passing
    a pointer to the thread attributes in `attr`. The thread will begin to execute
    immediately.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建一个从`start_routine`函数开始的新执行线程，并将一个描述符放在`pthread_t`指向的`thread`中。它继承调用线程的调度参数，但这些参数可以通过在`attr`中传递指向线程属性的指针来覆盖。线程将立即开始执行。
- en: '`pthread_t` is the main way to refer to the thread within the program but the
    thread can also be seen from outside using a command like `ps -eLf`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`pthread_t`是程序内引用线程的主要方式，但是线程也可以通过像`ps -eLf`这样的命令从外部看到：'
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The program `thread-demo` has two threads. The `PID` and `PPID` columns show
    that they all belong to the same process and have the same parent, as you would
    expect. The column marked `LWP` is interesting, though. `LWP` stands for Light
    Weight Process which, in this context, is another name for thread. The numbers
    in that column are also known as **Thread IDs** or **TIDs**. In the main thread,
    the TID is the same as the PID, but for the others it is a different (higher)
    value. Some functions will accept a TID in places where the documentation states
    that you must give a PID, but be aware that this behavior is specific to Linux
    and not portable. Here is the code for `thread-demo`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 程序`thread-demo`有两个线程。`PID`和`PPID`列显示它们都属于同一个进程，并且有相同的父进程，这是你所期望的。不过，标记为`LWP`的列很有趣。`LWP`代表轻量级进程，在这个上下文中，是线程的另一个名称。该列中的数字也被称为**线程ID**或**TID**。在主线程中，TID与PID相同，但对于其他线程，它是一个不同（更高）的值。一些函数将在文档规定必须给出PID的地方接受TID，但请注意，这种行为是特定于Linux的，不具有可移植性。以下是`thread-demo`的代码：
- en: '[PRE7]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There is a man page for `getttid(2)` which explains that you have to make the
    Linux `syscall` directly because there isn't a C library wrapper for it, as shown.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`getttid(2)`的man页面解释说你必须直接进行Linux `syscall`，因为没有C库包装器，如所示。
- en: There is a limit to the total number of threads that a given kernel can schedule.
    The limit scales according to the size of the system from around 1,000 on small
    devices up to tens of thousands on larger embedded devices. The actual number
    is available in `/proc/sys/kernel/threads-max`. Once you reach this limit, `fork()`
    and `pthread_create()` will fail.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 给定内核可以调度的线程总数是有限的。该限制根据系统的大小而变化，从小型设备上的大约1,000个到较大嵌入式设备上的数万个。实际数量可以在`/proc/sys/kernel/threads-max`中找到。一旦达到这个限制，`fork()`和`pthread_create()`将失败。
- en: Terminating a thread
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终止线程
- en: 'A thread terminates when:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 线程在以下情况下终止：
- en: It reaches the end of its `start_routine`
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它到达其`start_routine`的末尾
- en: It calls `pthread_exit(3)`
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它调用`pthread_exit(3)`
- en: It is canceled by another thread calling `pthread_cancel(3)`
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被另一个线程调用`pthread_cancel(3)`取消
- en: The process which contains the thread terminates, for example, because of a
    thread calling `exit(3)`, or the process receiving a signal that is not handled,
    masked or ignored
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含线程的进程终止，例如，因为一个线程调用`exit(3)`，或者进程接收到一个未处理、屏蔽或忽略的信号
- en: Note that, if a multi threaded program calls `fork(2)`, only the thread that
    made the call will exist in the new child process. Fork does not replicate all
    threads.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果一个多线程程序调用`fork(2)`，只有发出调用的线程会存在于新的子进程中。`fork`不会复制所有线程。
- en: 'A thread has a return value, which is a void pointer. One thread can wait for
    another to terminate and collect its return value by calling `pthread_join(2)`.
    There is an example in the code for `thread-demo` mentioned in the preceding section.
    This produces a problem that is very similar to the zombie problem among processes:
    the resources of the thread, for example, the stack, cannot be freed up until
    another thread has joined with it. If threads remain unjoined there is a resource
    leak in the program.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 线程有一个返回值，是一个void指针。一个线程可以通过调用`pthread_join(2)`等待另一个线程终止并收集其返回值。在前面部分提到的`thread-demo`代码中有一个例子。这会产生一个与进程中的僵尸问题非常相似的问题：线程的资源，例如堆栈，在另一个线程加入之前无法被释放。如果线程保持未加入状态，程序中就会出现资源泄漏。
- en: Compiling a program with threads
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用线程编译程序
- en: 'The support for POSIX threads is part of the C library, in the library `libpthread.so`.
    However, there is more to building programs with threads than linking the library:
    there have to be changes to the way the compiler generates code to make sure that
    certain global variables, such as `errno`, have one instance per thread rather
    than one for the whole process.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对POSIX线程的支持是C库的一部分，在库`libpthread.so`中。然而，构建带有线程的程序不仅仅是链接库：必须对编译器生成的代码进行更改，以确保某些全局变量，例如`errno`，每个线程都有一个实例，而不是整个进程共享一个。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When building a threaded program, you must add the switch `–pthread` at the
    compile and link stages.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个多线程程序时，您必须在编译和链接阶段添加开关`-pthread`。
- en: Inter-thread communication
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程间通信
- en: The big advantage of threads is that they share the address space and so can
    share memory variables. This is also a big disadvantage because it requires synchronization
    to preserve data consistency, in a similar way to memory segments shared between
    processes but with the proviso that, with threads, all memory is shared. Threads
    can create private memory using **thread local storage** (**TLS**).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的一个巨大优势是它们共享地址空间，因此可以共享内存变量。这也是一个巨大的缺点，因为它需要同步以保持数据一致性，类似于进程之间共享的内存段，但需要注意的是，对于线程，所有内存都是共享的。线程可以使用**线程本地存储**（**TLS**）创建私有内存。
- en: 'The `pthreads` interface provides the basics necessary to achieve synchronization:
    mutexes and condition variables. If you want more complex structures, you will
    have to build them yourself.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`pthreads`接口提供了实现同步所需的基本功能：互斥锁和条件变量。如果您需要更复杂的结构，您将不得不自己构建它们。'
- en: It is worth noting that all of the IPC methods described earlier work equally
    well between threads in the same process.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，之前描述的所有IPC方法在同一进程中的线程之间同样有效。
- en: Mutual exclusion
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互斥排除
- en: 'To write robust programs, you need to protect each shared resource with a mutex
    lock and make sure that every code path that reads or writes the resource has
    locked the mutex first. If you apply this rule consistently, most of the problems
    should be solved. The ones that remain are associated with the fundamental behavior
    of mutexes. I will list them briefly here, but will not go into detail:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写健壮的程序，您需要用互斥锁保护每个共享资源，并确保每个读取或写入资源的代码路径都先锁定了互斥锁。如果您始终遵循这个规则，大部分问题应该可以解决。剩下的问题与互斥锁的基本行为有关。我会在这里简要列出它们，但不会详细介绍：
- en: '**Deadlock**: This occurs when mutexes become permanently locked. A classic
    situation is the deadly embrace in which two threads each require two mutexes
    and have managed to lock one of them but not the other. Each block waits for the
    lock the other has and so they remain as they are. One simple rule which avoids
    the deadly embrace problem is to make sure that mutexes are always locked in the
    same order. Other solutions involve timeouts and back off periods.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**死锁**：当互斥锁永久锁定时会发生。一个经典的情况是致命的拥抱，其中两个线程分别需要两个互斥锁，并且已经锁定了其中一个，但没有锁定另一个。每个块都在等待另一个已经锁定的锁，因此它们保持原样。避免致命拥抱问题的一个简单规则是确保互斥锁总是以相同的顺序锁定。其他解决方案涉及超时和退避期。'
- en: '**Priority inversion**: The delays caused by waiting for a mutex can cause
    a real-time thread to miss deadlines. The specific case of priority inversion
    happens when a high priority thread becomes blocked waiting for a mutex locked
    by a low priority thread. If the low priority thread is preempted by other threads
    of intermediate priority, the high priority thread is forced to wait for an unbounded
    length of time. There are mutex protocols called priority inheritance and priority
    ceiling which resolve the problem at the expense of greater processing overhead
    in the kernel for each lock and unlock call.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级反转**：由于等待互斥锁造成的延迟，实时线程可能会错过截止日期。优先级反转的特定情况发生在高优先级线程因等待被低优先级线程锁定的互斥锁而被阻塞。如果低优先级线程被中间优先级的其他线程抢占，高优先级线程将被迫等待无限长的时间。有互斥锁协议称为优先级继承和优先级上限，它们以每次锁定和解锁调用在内核中产生更大的处理开销来解决问题。'
- en: '**Poor performance**: Mutexes introduce minimal overhead to code as long as
    threads don''t have to block on them most of the time. If your design has a resource
    that is needed by a lot of threads, however, the contention ratio becomes significant.
    This is usually a design issue which can be resolved by using finer grained locking
    or a different algorithm.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能差**：互斥锁会给代码引入最小的开销，只要线程大部分时间不必在其上阻塞。然而，如果您的设计有一个被许多线程需要的资源，争用比变得显著。这通常是一个设计问题，可以通过使用更细粒度的锁定或不同的算法来解决。'
- en: Changing conditions
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变条件
- en: Cooperating threads need a method of alerting one another that something has
    changed and needs attention. That thing is called a condition and the alert is
    sent through a condition variable, `condvar`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 合作线程需要一种方法来通知彼此发生了变化并需要关注。这个东西称为条件，警报通过条件变量`condvar`发送。
- en: 'A condition is just something that you can test to give a `true` or `false`
    result. A simple example is a buffer that contains either zero or some items.
    One thread takes items from the buffer and sleeps when it is empty. Another thread
    places items into the buffer and signals the other thread that it has done so,
    because the condition that the other thread is waiting on has changed. If it is
    sleeping, it needs to wake up and do something. The only complexity is that the
    condition is, by definition, a shared resource and so has to be protected by a
    mutex. Here is a simple example which follows the producer-consumer relationship
    described in the preceding section:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 条件只是一个可以测试以给出`true`或`false`结果的东西。一个简单的例子是一个包含零个或一些项目的缓冲区。一个线程从缓冲区中取出项目，并在空时休眠。另一个线程将项目放入缓冲区，并通知另一个线程已经这样做了，因为另一个线程正在等待的条件已经改变。如果它正在休眠，它需要醒来并做一些事情。唯一的复杂性在于条件是一个共享资源，因此必须受到互斥锁的保护。以下是一个简单的例子，遵循了前一节描述的生产者-消费者关系：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that, when the consumer thread blocks on the `condvar`, it does so while
    holding a locked mutex, which would seem to be a recipe for deadlock the next
    time the producer thread tries to update the condition. To avoid this, `pthread_condwait(3)`
    unlocks the mutex after the thread is blocked and locks it again before waking
    it and returning from the wait.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当消费者线程在`condvar`上阻塞时，它是在持有锁定的互斥锁的情况下这样做的，这似乎是下一次生产者线程尝试更新条件时产生死锁的原因。为了避免这种情况，`pthread_condwait(3)`在线程被阻塞后解锁互斥锁，并在唤醒它并从等待中返回时再次锁定它。
- en: Partitioning the problem
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题的分区
- en: Now that we have covered the basics of processes and threads and the ways in
    which they communicate, it is time to see what we can do with them.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了进程和线程的基础知识以及它们之间的通信方式，是时候看看我们可以用它们做些什么了。
- en: 'Here are some of the rules I use when building systems:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我在构建系统时使用的一些规则：
- en: '**Rule 1**: Keep tasks that have a lot of interaction.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则1**：保持具有大量交互的任务。'
- en: Minimize overheads by keeping closely inter-operating threads together in one
    process.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将紧密相互操作的线程放在一个进程中，最小化开销。
- en: '**Rule 2**: Don''t put all your threads in one basket.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则2**：不要把所有的线程放在一个篮子里。'
- en: On the other hand, try and keep components with limited interaction in separate
    processes, in the interests of resilience and modularity.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，为了提高韧性和模块化，尽量将交互有限的组件放在单独的进程中。
- en: '**Rule 3**: Don''t mix critical and non-critical threads in the same process.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则3**：不要在同一个进程中混合关键和非关键线程。'
- en: 'This is an amplification of Rule 2: the critical part of the system, which
    might be the machine control program, should be kept as simple as possible and
    written in a more rigorous way than other parts. It must be able to continue even
    if other processes fail. If you have real-time threads, they, by definition, must
    be critical and should go into a process by themselves.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对规则2的进一步阐释：系统的关键部分，可能是机器控制程序，应尽可能简单，并以比其他部分更严格的方式编写。它必须能够在其他进程失败时继续运行。如果有实时线程，它们必须是关键的，并且应该单独放入一个进程中。
- en: '**Rule 4**: Threads shouldn''t get too intimate.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则4**：线程不应该过于亲密。'
- en: One of the temptations when writing a multi-threaded program is to intermingle
    the code and variables between threads because it is all in one program and easy
    to do. Don't keep threads modular with well-defined interactions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 编写多线程程序时的一个诱惑是在线程之间交织代码和变量，因为它们都在一个程序中，很容易做到。不要让线程之间的交互模块化。
- en: '**Rule 5**: Don''t think that threads are for free.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则5**：不要认为线程是免费的。'
- en: It is very easy to create additional threads but there is a cost, not least
    in the additional synchronization necessary to coordinate their activities.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建额外的线程非常容易，但成本很高，尤其是在协调它们的活动所需的额外同步方面。
- en: '**Rule 6**: Threads can work in parallel.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则6**：线程可以并行工作。'
- en: Threads can run simultaneously on a multi-core processor, giving higher throughput.
    If you have a large computing job, you can create one thread per core and make
    maximum use of the hardware. There are libraries to help you do this, such as
    OpenMP. You probably shouldn't be coding parallel programming algorithms from
    scratch.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可以在多核处理器上同时运行，从而提高吞吐量。如果有一个庞大的计算任务，可以为每个核心创建一个线程，并充分利用硬件。有一些库可以帮助你做到这一点，比如OpenMP。你可能不应该从头开始编写并行编程算法。
- en: 'The Android design is a good illustration. Each application is a separate Linux
    process which helps to modularize memory management but especially ensures that
    one app crashing does not affect the whole system. The process model is also used
    for access control: a process can only access the files and resources which its
    UID and GIDs allow it to. There are a group of threads in each process. There
    is one to manage and update the user interface, one for handling signals from
    the operating system, several for managing dynamic memory allocation and the freeing
    up of Java objects and a worker pool of at least two threads for receiving messages
    from other parts of the system using the Binder protocol.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Android设计是一个很好的例子。每个应用程序都是一个单独的Linux进程，这有助于模块化内存管理，尤其是确保一个应用程序崩溃不会影响整个系统。进程模型也用于访问控制：一个进程只能访问其UID和GID允许的文件和资源。每个进程中都有一组线程。有一个用于管理和更新用户界面的线程，一个用于处理来自操作系统的信号，几个用于管理动态内存分配和释放Java对象，以及至少两个线程的工作池，用于使用Binder协议从系统的其他部分接收消息。
- en: To summarize, processes provide resilience because each process has a protected
    memory space and, when the process terminates, all resources including memory
    and file descriptors are freed up, reducing resource leaks. On the other hand,
    threads share resources and so can communicate easily through shared variables,
    and can cooperate by sharing access to files and other resources. Threads give
    parallelism through worker pools and other abstractions which is useful on multi-core
    processors.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，进程提供了韧性，因为每个进程都有受保护的内存空间，当进程终止时，包括内存和文件描述符在内的所有资源都被释放，减少了资源泄漏。另一方面，线程共享资源，因此可以通过共享变量轻松通信，并且可以通过共享对文件和其他资源的访问来合作。线程通过工作池和其他抽象提供并行性，在多核处理器上非常有用。
- en: Scheduling
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度
- en: The second big topic I want to cover in this chapter is scheduling. The Linux
    scheduler has a queue of threads that are ready to run and its job is to schedule
    them on CPUs as they become available. Each thread has a scheduling policy which
    may be timeshared or real-time. The timeshared threads have a niceness value which
    increases or reduces their entitlement to CPU time. The real-time threads have
    a priority such that a higher priority thread will preempt a lower one. The scheduler
    works with threads, not processes. Each thread is scheduled regardless of which
    process it is running in.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在本章中要讨论的第二个重要主题是调度。Linux调度器有一个准备运行的线程队列，其工作是在CPU上安排它们。每个线程都有一个调度策略，可以是时间共享或实时。时间共享线程有一个niceness值，它增加或减少它们对CPU时间的权利。实时线程有一个优先级，较高优先级的线程将抢占较低优先级的线程。调度器与线程一起工作，而不是进程。每个线程都会被安排，不管它运行在哪个进程中。
- en: 'The scheduler runs when:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器在以下情况下运行：
- en: A thread blocks by calling `sleep()` or in a blocking I/O call
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程通过调用`sleep()`或阻塞I/O调用来阻塞
- en: A timeshare thread exhausts its time slice
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间共享线程耗尽了其时间片
- en: An interrupt causes a thread to be unblocked, for example, because of I/O completing
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断会导致线程解除阻塞，例如，因为I/O完成。
- en: 'For background information on the Linux scheduler, I recommend reading the
    chapter on process scheduling in *Linux Kernel Development*, *3rd edition by Robert
    Love*, *Addison-Wesley Professional*; (July 2, 2010) ISBN-10: 0672329468.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '关于Linux调度器的背景信息，我建议阅读*Linux Kernel Development*中关于进程调度的章节，作者是Robert Love，Addison-Wesley
    Professional出版社，ISBN-10: 0672329468。'
- en: Fairness versus determinism
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公平性与确定性
- en: I have grouped the scheduling polices into categories of timeshare and real-time.
    Timeshare policies are based on the principal of fairness. They are designed to
    make sure that each thread gets a fair amount of processor time and that no thread
    can hog the system. If a thread runs for too long it is put to the back of the
    queue so that others can have a go. At the same time, a fairness policy needs
    to adjust to threads that are doing a lot of work and give them the resources
    to get the job done. Timeshare scheduling is good because of the way it automatically
    adjusts to a wide range of workloads.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我将调度策略分为时间共享和实时两类。时间共享策略基于公平原则。它们旨在确保每个线程获得公平的处理器时间，并且没有线程可以独占系统。如果一个线程运行时间过长，它将被放到队列的末尾，以便其他线程有机会运行。同时，公平策略需要调整到正在执行大量工作的线程，并为它们提供资源以完成工作。时间共享调度很好，因为它可以自动调整到各种工作负载。
- en: On the other hand, if you have a real-time program, fairness is not helpful.
    Instead, you then want a policy that is deterministic, that will give you at least
    minimal guarantees that your real-time threads will be scheduled at the right
    time so that they don't miss their deadlines. This means that a real-time thread
    must preempt timeshare threads. Real-time threads also have a static priority
    that the scheduler can use to choose between them when there are several of them
    to run at once. The Linux real-time scheduler implements a fairly standard algorithm
    which runs the highest priority real-time thread. Most RTOS schedulers are also
    written in this way.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你有一个实时程序，公平性是没有帮助的。相反，你需要一个确定性的策略，它至少会给你最小的保证，即你的实时线程将在正确的时间被调度，以便它们不会错过截止日期。这意味着实时线程必须抢占时间共享线程。实时线程还有一个静态优先级，调度器可以用它来在多个实时线程同时运行时进行选择。Linux实时调度器实现了一个相当标准的算法，它运行最高优先级的实时线程。大多数RTOS调度器也是以这种方式编写的。
- en: Both types of thread can coexist. Those requiring deterministic scheduling are
    scheduled first and the time remaining is divided between the timeshare threads.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 两种类型的线程可以共存。需要确定性调度的线程首先被调度，剩下的时间被分配给时间共享线程。
- en: Timeshare policies
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时间共享策略
- en: Timeshare policies are designed for fairness. From Linux 2.6.23 onwards, the
    scheduler used has been the **Completely Fair Scheduler** (**CFS**). It does not
    use timeslices in the normal sense of the word. Instead, it calculates a running
    tally of the length of time a thread would be entitled to run if it had its fair
    share of CPU time, and balances that with the actual amount of time it has run.
    If it exceeds its entitlement, and there are other timeshare threads waiting to
    run, the scheduler will suspend the thread and run a waiting thread instead.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 时间共享策略是为了公平而设计的。从Linux 2.6.23开始，使用的调度器是**Completely Fair Scheduler**（**CFS**）。它不像通常意义上的时间片。相反，它计算了一个线程如果拥有其公平份额的CPU时间的运行总数，并将其与实际运行时间进行平衡。如果它超过了它的权利，并且有其他时间共享线程在等待运行，调度器将暂停该线程并运行等待线程。
- en: 'The timeshare policies are:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 时间共享策略有：
- en: '`SCHED_NORMAL` (also known as `SCHED_OTHER`): This is the default policy. The
    vast majority of Linux threads use this policy.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCHED_NORMAL`（也称为`SCHED_OTHER`）：这是默认策略。绝大多数Linux线程使用此策略。'
- en: '`SCHED_BATCH`: This is similar to `SCHED_NORMAL` except threads are scheduled
    with a larger granularity; that is they run for longer but have to wait longer
    until scheduled again. The intention is to reduce the number of context switches
    for background processing (batch jobs) and so reduce the amount of CPU cache churn.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCHED_BATCH`：这类似于 `SCHED_NORMAL`，只是线程以更大的粒度进行调度；也就是说它们运行的时间更长，但必须等待更长时间才能再次调度。其目的是减少后台处理（批处理作业）的上下文切换次数，从而减少
    CPU 缓存的使用。'
- en: '`SCHED_IDLE`: These threads are run only when there are no threads of any other
    policy ready to run. It is the lowest possible priority.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCHED_IDLE`：这些线程只有在没有其他策略的线程准备运行时才运行。这是最低优先级。'
- en: 'There are two pairs of functions to get and set the policy and priority of
    a thread. The first pair takes a PID as a parameter and affects the main thread
    in a process:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有两对函数用于获取和设置线程的策略和优先级。第一对以PID作为参数，并影响进程中的主线程：
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The second pair operates on `pthread_t` and so can change the parameters of
    the other threads in a process:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第二对函数操作 `pthread_t`，因此可以更改进程中其他线程的参数：
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Niceness
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Niceness
- en: Some timeshare threads are more important than others. You can indicate this
    with the `nice` value which multiplies a thread's CPU entitlement by a scaling
    factor. The name comes from the function call, `nice(2)`, which has been part
    of Unix since the early days. A thread becomes `nice` by reducing its load on
    the system, or moves in the opposite direction by increasing it. The range of
    values is from 19, which is really nice, to -20 which is really not nice. The
    default value is 0, which is averagely nice or so-so.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有些时间共享线程比其他线程更重要。您可以使用 `nice` 值来指示这一点，它将线程的 CPU 权利乘以一个缩放因子。这个名字来自于 Unix 早期的函数调用
    `nice(2)`。通过减少系统上的负载，线程变得“nice”，或者通过增加负载来朝相反方向移动。值的范围是从 19（非常 nice）到 -20（非常不 nice）。默认值是
    0，即平均 nice 或一般般。
- en: The `nice` value can be changed for `SCHED_NORMAL` and `SCHED_BATCH` threads.
    To reduce niceness, which increases the CPU load, you need the capability `CAP_SYS_NICE`,
    which is available to the root user.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`nice` 值可以更改 `SCHED_NORMAL` 和 `SCHED_BATCH` 线程的值。要减少 niceness，增加 CPU 负载，您需要
    `CAP_SYS_NICE` 权限，这仅适用于 root 用户。'
- en: 'Almost all the documentation for functions and commands that change the `nice`
    value (`nice(2)` and the `nice` and `renice` commands) talks in terms of processes.
    However, it really relates to threads. As mentioned in the preceding section,
    you can use a TID in place of a PID to change the `nice` value of an individual
    thread. One other discrepancy in the standard descriptions of `nice`: the `nice`
    value is referred to as the priority of a thread (or sometimes, mistakenly, a
    process). I believe this is misleading and confuses the concept with real-time
    priority which is a completely different thing.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有更改 `nice` 值的函数和命令的文档（`nice(2)` 和 `nice` 以及 `renice` 命令）都是关于进程的。但实际上它与线程有关。正如前一节中提到的，您可以使用
    TID 替换 PID 来更改单个线程的 `nice` 值。标准描述中 `nice` 的另一个不一致之处：`nice` 值被称为线程的优先级（有时甚至错误地称为进程的优先级）。我认为这是误导性的，并且将概念与实时优先级混淆了，这是完全不同的东西。
- en: Real-time policies
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时策略
- en: Real-time policies are intended for determinism. The real-time scheduler will
    always run the highest priority real-time thread that is ready to run. Real-time
    threads always preempt timeshare threads. In essence, by selecting a real-time
    policy over a timeshare policy, you are saying that you have inside knowledge
    of the expected scheduling of this thread and wish to override the scheduler's
    built-in assumptions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 实时策略旨在实现确定性。实时调度程序将始终运行准备运行的最高优先级实时线程。实时线程总是抢占时间共享线程。实质上，通过选择实时策略而不是时间共享策略，您是在说您对该线程的预期调度有内部知识，并希望覆盖调度程序的内置假设。
- en: 'There are two real-time policies:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种实时策略：
- en: '`SCHED_FIFO`: This is a run to completion algorithm, which means that, once
    the thread starts to run, it will continue until it is preempted by a higher priority
    real-time thread or blocks in a system call or terminates (completes).'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCHED_FIFO`：这是一个运行到完成的算法，这意味着一旦线程开始运行，它将一直运行，直到被更高优先级的实时线程抢占或在系统调用中阻塞或终止（完成）。'
- en: '`SCHED_RR`: This is a round robin algorithm which will cycle between threads
    of the same priority if they exceed their time slice which, by default, is 100
    ms. Since Linux 3.9, it has been possible to control the `timeslice` value through
    `/proc/sys/kernel/sched_rr_timeslice_ms`. Apart from this, it behaves in the same
    way as `SCHED_FIFO`.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCHED_RR`：这是一个循环调度算法，如果线程超过其时间片（默认为 100 毫秒），它将在相同优先级的线程之间循环。自 Linux 3.9 以来，可以通过
    `/proc/sys/kernel/sched_rr_timeslice_ms` 控制 `timeslice` 值。除此之外，它的行为方式与 `SCHED_FIFO`
    相同。'
- en: Each real-time thread has a priority in the range 1 to 99, with 99 being the
    highest.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实时线程的优先级范围为 1 到 99，99 是最高的。
- en: To give a thread a real-time policy, you need `CAP_SYS_NICE` which, by default,
    is given only to the root user.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要给线程一个实时策略，您需要 `CAP_SYS_NICE` 权限，默认情况下只有 root 用户拥有该权限。
- en: One problem with real-time scheduling, both in Linux and elsewhere, is that
    of a thread that becomes compute bound, often because a bug has caused it to loop
    indefinitely, which prevents real-time threads of lower priority from running
    as well as all the timeshare threads. The system become erratic and may lock up
    completely. There are a couple of ways to guard against this possibility.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 实时调度的一个问题，无论是在 Linux 还是其他地方，是线程变得计算密集，通常是因为错误导致其无限循环，这会阻止优先级较低的实时线程以及所有时间共享线程运行。系统变得不稳定，甚至可能完全锁死。有几种方法可以防范这种可能性。
- en: 'First, since Linux 2.6.25, the scheduler has, by default, reserved 5% of CPU
    time for non real-time threads, so that even a runaway real-time thread cannot
    completely halt the system. It is configured via two kernel controls:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，自 Linux 2.6.25 以来，默认情况下调度程序保留了 5% 的 CPU 时间用于非实时线程，因此即使是失控的实时线程也不能完全停止系统。它通过两个内核控制进行配置：
- en: '`/proc/sys/kernel/sched_rt_period_us`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc/sys/kernel/sched_rt_period_us`'
- en: '`/proc/sys/kernel/sched_rt_runtime_us`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc/sys/kernel/sched_rt_runtime_us`'
- en: They have default values of 1,000,000 (1 second) and 950,000 (950 ms) respectively,
    which means that out of every second, 50ms is reserved for non real-time processing.
    If you want real-time threads to be able to take 100% then set `sched_rt_runtime_us`
    to `-1`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的默认值分别为1,000,000（1秒）和950,000（950毫秒），这意味着每秒钟有50毫秒用于非实时处理。如果要使实时线程能够占用100％，则将`sched_rt_runtime_us`设置为`-1`。
- en: The second option is to use a watchdog, either hardware or software, to monitor
    the execution of key threads and to take action when they begin to miss deadlines.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选择是使用看门狗，无论是硬件还是软件，来监视关键线程的执行，并在它们开始错过截止日期时采取行动。
- en: Choosing a policy
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择策略
- en: In practice, timeshare policies satisfy the majority of computing workloads.
    Threads that are I/O bound spend a lot of time blocked and so always have some
    spare entitlement in hand. When they unblock they will be scheduled almost immediately.
    Meanwhile, CPU-bound threads will naturally take up any CPU cycles left over.
    Positive nice values can be applied to the less important threads and negative
    values to the important ones.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，时间共享策略满足了大多数计算工作负载。I/O绑定的线程花费大量时间被阻塞，因此总是有一些剩余的权利。当它们解除阻塞时，它们几乎立即被调度。与此同时，CPU绑定的线程将自然地占用剩余的任何CPU周期。可以将积极的优先级值应用于不太重要的线程，将负值应用于重要的线程。
- en: 'Of course, this is only average behavior, there are no guarantees that this
    will always be the case. If more deterministic behavior is needed, then real-time
    policies will be required. The things that mark out a thread as being real-time
    are:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是平均行为，不能保证这种情况总是存在。如果需要更确定的行为，则需要实时策略。标记线程为实时的因素包括：
- en: It has a deadline by which it must generate an output
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个必须生成输出的截止日期
- en: Missing the deadline would compromise the effectiveness of the system
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错过截止日期将损害系统的有效性
- en: It is event-driven
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是事件驱动的
- en: It is not compute bound
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不是计算绑定的
- en: Examples of real-time tasks include the classic robot arm servo controller,
    multimedia processing, and communication processing.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 实时任务的示例包括经典的机器人臂伺服控制器，多媒体处理和通信处理。
- en: Choosing a real-time priority
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择实时优先级
- en: Choosing real-time priorities that work for all expected workloads is a tricky
    business and a good reason for avoiding real-time policies in the first place.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 选择适用于所有预期工作负载的实时优先级是一个棘手的问题，也是避免首先使用实时策略的一个很好的理由。
- en: 'The most widely used procedure for choosing priorities is known as **Rate Monotonic
    Analysis** (**RMA**), after the 1973 paper by Liu and Layland. It applies to real-time
    systems with periodic threads, which is a very important class. Each thread has
    a period, and a utilization, which is the proportion of the period it will be
    executing. The goal is to balance the load so that all threads can complete their
    execution phase before the next period. RMA states that this can be achieved if:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 选择优先级的最常用程序称为**速率单调分析**（**RMA**），根据1973年Liu和Layland的论文。它适用于具有周期性线程的实时系统，这是一个非常重要的类别。每个线程都有一个周期和一个利用率，即其执行期的比例。目标是平衡负载，以便所有线程都能在下一个周期之前完成其执行阶段。RMA规定，如果：
- en: The highest priorities are given to the threads with the shortest periods
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最高优先级给予具有最短周期的线程
- en: The total utilization is less than 69%
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总利用率低于69％
- en: The total utilization is the sum of all of the individual utilizations. It also
    makes the assumption that the interaction between threads or the time spent blocked
    on mutexes and the like, is negligible.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 总利用率是所有个体利用率的总和。它还假设线程之间的交互或在互斥锁上阻塞的时间是可以忽略不计的。
- en: Further reading
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following resources have further information about the topics introduced
    in this chapter:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源提供了有关本章介绍的主题的更多信息：
- en: '*The Art of Unix Programming*, by *Eric Steven Raymond*, *Addison Wesley*;
    (23 Sept. 2003) ISBN 978-0131429017'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Unix编程艺术》，作者*Eric Steven Raymond*，*Addison Wesley*；（2003年9月23日）ISBN 978-0131429017
- en: '*Linux System Programming, 2nd edition*, by *Robert Love*, *O''Reilly Media*;
    (8 Jun. 2013) ISBN-10: 1449339530'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Linux系统编程，第二版》，作者*Robert Love*，*O'Reilly Media*；（2013年6月8日）ISBN-10：1449339530
- en: '*Linux Kernel Development*, *3rd edition by Robert Love*, *Addison-Wesley Professional*;
    (July 2, 2010) ISBN-10: 0672329468'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Linux内核开发》，*Robert Love*，*Addison-Wesley Professional*；（2010年7月2日）ISBN-10：0672329468
- en: '*The Linux Programming Interface*, by *Michael Kerrisk*, *No Starch Press*;
    (October 2010) ISBN 978-1-59327-220-3'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Linux编程接口》，作者*Michael Kerrisk*，*No Starch Press*；（2010年10月）ISBN 978-1-59327-220-3
- en: '*UNIX Network Programming: v. 2: Interprocess Communications, 2nd Edition*,
    by *W. Richard Stevens*, *Prentice Hall*; (25 Aug. 1998) ISBN-10: 0132974290'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《UNIX网络编程：卷2：进程间通信，第二版》，作者*W. Richard Stevens*，*Prentice Hall*；（1998年8月25日）ISBN-10：0132974290
- en: '*Programming with POSIX Threads*, by *Butenhof*, *David R*, *Addison-Wesley*,
    *Professional*'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《使用POSIX线程编程》，作者*Butenhof*，*David R*，*Addison-Wesley*，*Professional*
- en: '*Scheduling Algorithm for multiprogramming in a Hard-Real-Time Environment*,
    by *C. L. Liu* and *James W. Layland*, *Journal of ACM*, 1973, vol 20, no 1, pp.
    46-61'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《硬实时环境中的多道程序调度算法》，作者*C. L. Liu*和*James W. Layland*，*ACM杂志*，1973年，第20卷，第1期，第46-61页
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The long Unix heritage that is built into Linux and the accompanying C libraries
    provides almost everything you need to write stable and resilient embedded applications.
    The issue is that, for every job, there are at least two ways to achieve the end
    you desire.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 内置在Linux和附带的C库中的长期Unix传统几乎提供了编写稳定和弹性嵌入式应用程序所需的一切。问题在于，对于每项工作，至少有两种方法可以实现您所期望的结果。
- en: 'In this chapter, I have focused on two aspects of system design: the partitioning
    into separate processes, each with one or more threads to get the job done, and
    the scheduling of those threads. I hope that I have shed some light on this, and
    given you the basis for further study into all of them.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我专注于系统设计的两个方面：将其分成单独的进程，每个进程都有一个或多个线程来完成工作，以及对这些线程进行调度。我希望我已经为您解开了一些疑惑，并为您进一步研究所有这些内容提供了基础。
- en: In the next chapter, I will examine another important aspect of system design,
    memory management.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将研究系统设计的另一个重要方面，即内存管理。
