- en: Chapter 2. Revisiting Linux Network Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。重新审视Linux网络基础知识
- en: Whether you have a lot of knowledge of Linux networking or you are just getting
    started, we will round off the basics of Linux networking in this chapter. While
    the TCP/IP stack in Linux is implemented with the same features as in other platforms,
    specific tools are used to manage such networks. Here, we'll discuss how Linux
    handles IP addressing, network device naming, as well as bringing interfaces up
    and down. In addition, we'll discuss the graphical and nongraphical tools used
    to manage our interfaces.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您对Linux网络有很多了解，还是刚刚开始，我们将在本章中总结Linux网络的基础知识。虽然Linux中的TCP/IP堆栈实现了与其他平台相同的功能，但使用特定工具来管理这样的网络。在这里，我们将讨论Linux如何处理IP地址分配、网络设备命名，以及启用和禁用接口。此外，我们还将讨论用于管理接口的图形和非图形工具。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Understanding the TCP/IP protocol suite
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解TCP/IP协议套件
- en: Naming the network device
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名网络设备
- en: Understanding Linux hostname resolution
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Linux主机名解析
- en: Understanding the iproute2 and net-tools suites
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解iproute2和net-tools套件
- en: Managing network interfaces manually
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动管理网络接口
- en: Managing connections with Network Manager
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用网络管理器管理连接
- en: Understanding the TCP/IP protocol suite
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解TCP/IP协议套件
- en: TCP/IP is the most popular networking protocol in existence. Not only is it
    the primary protocol suite of the Internet, it's something that you can find on
    just about any device that supports network connectivity in one form or another.
    Your computer understands this suite very well, but nowadays your phone, TV, and
    perhaps even a kitchen appliance or two supports this technology. It really is
    everywhere. Although TCP/IP is often referred to as a protocol, it's actually
    a **protocol suite** made up of several individual protocols. From the name, I'm
    sure you can gather that two of them are the TCP and IP protocols. In addition,
    there is also a third, UDP, which is part of this protocol suite as well.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: TCP/IP是存在最流行的网络协议。它不仅是互联网的主要协议套件，而且几乎可以在任何支持网络连接的设备上找到。您的计算机非常了解这个套件，但现在您的手机、电视，甚至一两个厨房电器也支持这项技术。它真的无处不在。尽管TCP/IP通常被称为协议，但实际上它是由几个单独的协议组成的**协议套件**。从名称上看，我相信您可以知道其中两个是TCP和IP协议。此外，还有第三个UDP，也是这个协议套件的一部分。
- en: '**TCP** is an acronym for **Transmission Control Protocol**. It''s responsible
    for breaking down network transmissions into sequences (also known as packets
    or segments), which are then sent to the target node and reassembled back into
    the original message by TCP on the other end. In addition to managing packets,
    TCP also ensures that they were properly received (to the best of its ability).
    It does this via **error correction**. If a packet is not received by the target,
    TCP will resend it. It knows to do this because of the **retransmission time**r.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**TCP**是**传输控制协议**的缩写。它负责将网络传输分解成序列（也称为数据包或段），然后将它们发送到目标节点，并由TCP在另一端重新组装成原始消息。除了管理数据包，TCP还确保它们被正确接收（尽其所能）。它通过**错误校正**来实现这一点。如果目标节点未收到数据包，TCP将重新发送。它之所以知道这一点，是因为有**重传时间**。'
- en: Before we discuss error correction and retransmission, let's first take a look
    at the actual process that TCP uses to send data. When setting up a connection,
    TCP performs a **three-way handshake**, which consists of three special packets
    that are sent between the communicating nodes. The first packet, **SYN** (**synchronize**),
    is sent to the receiver by the sender. Essentially, it's how the node announces
    that it wants to start a communication. On the receiving end, once (and if) the
    packet is received, a **SYN/ACK** (**synchronize acknowledgment**) packet is sent
    back to the sender. Finally, an **ACK** (**acknowledge**) packet is sent to the
    receiver from the sender, which is an overall verification that the transfer is
    all set to proceed. From that point forward, the connection is established and
    the two nodes are able to send information to each other. Further packets are
    then sent, which make up the remainder of the communication.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论错误校正和重传之前，让我们先看一下TCP发送数据时实际使用的过程。在建立连接时，TCP执行**三次握手**，这包括在通信节点之间发送的三个特殊数据包。第一个数据包**SYN**（同步）由发送方发送给接收方。基本上，这是节点宣布它想要开始通信的方式。在接收端，一旦（如果）接收到数据包，就会向发送方发送**SYN/ACK**（同步确认）数据包。最后，发送方向接收方发送一个**ACK**（确认）数据包，这是对传输准备就绪的总体验证。从那时起，连接建立，两个节点能够相互发送信息。然后发送更多数据包，这构成了通信的其余部分。
- en: If we lived in a perfect world, this would be all that is needed. Packets would
    never get lost in transmission, bandwidth would be unlimited, and packets would
    never get corrupted during transmission. Unfortunately, we don't live in a perfect
    world and packets are lost and/or corrupted all the time. TCP has built-in features
    to deal with these types of things. Error correction helps ensure that the packet
    which was received is the same as the one that was sent. TCP packets contain a
    checksum, and an algorithm is used to verify it. If the verification fails, the
    packet is deemed incorrect and is then discarded. This verification isn't perfect,
    so it's still possible that the file you just downloaded may still have an error
    or two, but it's better than nothing. Most of the time, it works just fine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们生活在一个完美的世界，这就是所需要的一切。数据包永远不会在传输中丢失，带宽是无限的，数据包在传输过程中永远不会损坏。不幸的是，我们并不生活在一个完美的世界，数据包经常丢失和/或损坏。TCP具有内置功能来处理这些问题。错误校正有助于确保接收到的数据包与发送的数据包相同。TCP数据包包含一个校验和，并使用算法进行验证。如果验证失败，数据包被视为不正确，然后被丢弃。这种验证并不完美，所以您刚刚下载的文件仍然可能有一两个错误，但总比没有好。大多数时候，它运行得很好。
- en: The flow control feature of TCP handles the speed at which data is transferred.
    While most of us geeks have a very nice set of networking hardware that is able
    to handle a ton of bandwidth, the Internet is not a consistent place. Your uber
    high-end switch may be able to handle whatever you throw at it, but that really
    doesn't matter if there is a weak link somewhere upstream within the connection.
    A network transmission is only as fast as its slowest point. While you're sending
    a transmission to another node, you're only able to send as much data as its buffer
    is able to hold. At some point, its buffer will fill up and then be unable to
    receive any additional packets until it deals with the ones it already has. Any
    additional packets sent to the receiver at this time are dropped. The sender sees
    that it is no longer receiving ACK replies, and then backs off and slows down
    its rate of transfer. This is the method that TCP uses in order to adjust the
    transfer speed according to what receiving nodes are able to handle.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: TCP的流量控制功能处理数据传输的速度。虽然我们大多数极客拥有一套非常好的网络硬件，能够处理大量带宽，但互联网并不是一个一致的地方。您的高端交换机可能能够处理任何您投入其中的东西，但如果连接的上游某个地方存在薄弱环节，那就无关紧要了。网络传输的速度取决于最慢的点。当您向另一个节点发送传输时，您只能发送与其缓冲区能够容纳的数据量相同的数据。在某个时刻，其缓冲区将填满，然后无法接收任何额外的数据包，直到处理已有的数据包。此时发送到接收方的任何额外数据包都将被丢弃。发送方看到它不再收到ACK回复，然后减速并减慢传输速度。这是TCP用来根据接收节点能够处理的情况调整传输速度的方法。
- en: Flow control works by utilizing what is known as a **sliding window**. The receiving
    node specifies what is known as a **receive window**, which tells the sender how
    much data it's able to receive before it becomes overwhelmed. Once this receive
    window runs dry, the sender waits for the receiver to clarify that it's ready
    to receive data again. Of course, if the receiving end sends an update to the
    sender that it is ready to receive data and the sender never gets the memo, we
    could run into a real problem if the sender waited forever for an all-clear message
    that was lost in transmission. Thankfully, we have a **persist timer** in place
    to help deal with this. Essentially, the persist timer represents how long the
    sender is willing to wait before it needs to verify that the connection is still
    active. Once the persist timer elapses, the sender transmits another packet to
    the receiver, to see whether it is able to deal with it. If a reply is sent, the
    reply packet will contain another receive window, which identifies that it is
    indeed ready to continue the conversation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 流量控制通过利用所谓的**滑动窗口**来实现。接收节点指定了所谓的**接收窗口**，它告诉发送方在变得不堪重负之前能够接收多少数据。一旦接收窗口用尽，发送方就等待接收方澄清它再次准备好接收数据。当然，如果接收端向发送方发送了一个准备好接收数据的更新，而发送方却没有收到备忘录，如果发送方永远等待在传输中丢失的全清消息，我们可能会遇到真正的问题。幸运的是，我们有一个**持续计时器**来帮助处理这个问题。基本上，持续计时器表示发送方愿意等待多长时间，然后需要验证连接是否仍然活动。一旦持续计时器到期，发送方向接收方发送另一个数据包，以查看它是否能够处理。如果发送了回复，回复数据包将包含另一个接收窗口，表明它确实准备好继续对话。
- en: The **IP** (short for **Internet Protocol**) handles the actual sending and
    receiving of the packets that TCP wants to send or receive. Within each packet,
    there is a destination known as an **IP address** (which we'll discuss further
    in this chapter). Each connected network interface will have its own IP address,
    which the IP protocol will use to figure out where a packet needs to go, or which
    device it is from. Together, TCP and IP make up a powerful team. TCP splits up
    a communication into packets, and IP handles routing them to their destination.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**IP**（即**Internet Protocol**）处理TCP想要发送或接收的数据包的实际发送和接收。在每个数据包中，有一个称为**IP地址**的目的地（我们将在本章中进一步讨论）。每个连接的网络接口都将有自己的IP地址，IP协议将使用它来确定数据包需要去哪里，或者它来自哪个设备。TCP和IP共同组成一个强大的团队。TCP将通信分成数据包，而IP负责将它们路由到它们的目的地。'
- en: Of course, there's also **UDP** (short for **User Datagram Protocol**), which
    is part of the suite as well. It's very similar to TCP in that it breaks up a
    transmission into packets. The main difference, however, is that UDP is **connectionless**.
    This means that UDP does not verify anything. It sends the packets, but does not
    guarantee delivery. If a packet isn't received by the target, it will not be resent.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有**UDP**（即**User Datagram Protocol**），它也是套件的一部分。它与TCP非常相似，因为它将传输分成数据包。然而，主要区别在于UDP是**无连接**的。这意味着UDP不验证任何内容。它发送数据包，但不保证传递。如果目标没有收到数据包，它将不会被重新发送。
- en: Those learning about UDP for the first time may question why such an untrustworthy
    protocol would even be considered. The fact is, in some cases, a connection-oriented
    protocol such as TCP may add unwanted overhead to certain types of transmissions.
    One example of this is contacting a colleague via Skype, which offers audio calls
    over the Internet as well as video calls. If a packet was lost by either end during
    a communication, it wouldn't make much sense to resend it. You would just hear
    a bit of static for a second or so, and retransmitting a packet certainly wouldn't
    change the fact that you had difficulty hearing a word or two. Adding error correction
    to such a transmission would be pointless and add overhead.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 初次了解UDP的人可能会质疑为什么会考虑使用这样一个不可靠的协议。事实上，在某些情况下，诸如TCP这样的面向连接的协议可能会给某些类型的传输增加不必要的开销。Skype是一个例子，它提供互联网上的音频通话和视频通话。在通信过程中，如果任一端丢失了一个数据包，重新发送它就没有多大意义。您只会听到一两秒钟的杂音，重新发送数据包肯定不会改变您难以听到一两个字的事实。对这样的传输添加错误校正将是毫无意义的，而且会增加开销。
- en: Discussing TCP/IP in its entirety would be a book in and of itself. In Linux,
    this protocol is handled in much the same way as other platforms, the real difference
    is in regards to how the protocol is managed. Throughout this book, we'll talk
    about ways we can manage this protocol and tweak our network.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论TCP/IP的全部内容本身就是一本书。在Linux中，这个协议的处理方式与其他平台基本相同，真正的区别在于协议的管理方式。在本书中，我们将讨论我们可以管理这个协议并调整我们的网络的方法。
- en: Naming the network device
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名网络设备
- en: 'Nowadays, it''s not uncommon for a computer to have multiple network interfaces.
    For example, if you''re using a laptop (other than an Ultrabook), it''s likely
    that you have a wired, as well as a wireless, network interface. Each network
    interface will have its own IP address and they operate independently of each
    other. In fact, you can even route traffic between multiple interfaces, though
    this is typically disabled by default in most Linux distributions. Just like each
    interface has its own IP address, each will also be identified by the system by
    its own device name. Before we discuss this further, go ahead and take a look
    at the device names on your system. Open up a terminal and type the following
    command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，一台计算机拥有多个网络接口并不罕见。例如，如果你使用的是笔记本电脑（而不是超极本），很可能你有一个有线和一个无线网络接口。每个网络接口都有自己的IP地址，并且它们彼此独立运行。事实上，你甚至可以在多个接口之间路由流量，尽管这在大多数Linux发行版中通常默认情况下是禁用的。就像每个接口都有自己的IP地址一样，每个接口也会被系统通过自己的设备名称来识别。在我们进一步讨论之前，打开终端并输入以下命令来查看你系统上的设备名称：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Your output will look like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出将如下所示：
- en: '![Naming the network device](img/B03919_02_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![命名网络设备](img/B03919_02_01.jpg)'
- en: The output of the ip command, showing network interfaces and address assignments
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ip命令的输出，显示网络接口和地址分配
- en: In this example, we see three network interfaces listed. The first, `lo`, is
    the local loopback adapter. The second listing, `eth0`, is the wired interface.
    Finally, `wlan0` represents the wireless interface. Given this output, you can
    deduce that there is a network cable plugged in (`eth0` has an IP address) and
    it is not currently utilizing its wireless interface (there is no IP address listed
    for `wlan0`).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到列出了三个网络接口。第一个`lo`是本地环回适配器。第二个`eth0`是有线接口。最后，`wlan0`代表无线接口。根据这个输出，你可以推断出有一个网络电缆插入了（`eth0`有一个IP地址），并且它目前没有使用无线接口（`wlan0`没有列出IP地址）。
- en: 'The output shown previously was taken from a system running Debian. Now, let''s
    take a look at the output of the same command when run on a CentOS system:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 先前显示的输出来自运行Debian系统的系统。现在，让我们来看看在CentOS系统上运行相同命令时的输出：
- en: '![Naming the network device](img/B03919_02_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![命名网络设备](img/B03919_02_02.jpg)'
- en: The output of the ip command, this time run from a CentOS system
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ip命令的输出，这次是从CentOS系统运行的
- en: 'Do you see the difference? If you look at the wired connection, you can tell
    that it''s named quite differently than the wired connection from the Debian example.
    With Debian, it was named `eth0`. But on CentOS, it was named `enp0s3`. This brings
    us to the point of this section: network devices are named differently in CentOS
    and Debian.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了区别吗？如果你看有线连接，你会发现它的命名方式与Debian示例中的有线连接有很大不同。在Debian中，它的名称是`eth0`。但在CentOS中，它的名称是`enp0s3`。这就引出了本节的重点：CentOS和Debian中的网络设备命名方式不同。
- en: In the past, wired ethernet devices were named beginning with the prefix of
    `eth`, and wireless devices were prefixed with `wlan`. For example, the first
    wired ethernet adapter would be labeled `eth0`; the second would be `eth1`, and
    so on. Wireless devices were handled similarly as well, with the first device
    being `wlan0`, the second would be `wlan1`, and so on. With Debian, this is still
    the case (even in newer releases). However, some distributions that utilize **systemd**
    feature a different naming scheme for network devices. In fact, Debian 9 will
    change its naming scheme for interfaces once it's released.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，有线以太网设备的名称以`eth`为前缀，无线设备以`wlan`为前缀。例如，第一个有线以太网适配器将被标记为`eth0`；第二个将是`eth1`，依此类推。无线设备也是类似处理的，第一个设备是`wlan0`，第二个将是`wlan1`，依此类推。在Debian中，这仍然是这种情况（即使在较新的版本中也是如此）。然而，一些使用**systemd**的发行版为网络设备采用了不同的命名方案。事实上，Debian
    9将在发布时更改其接口的命名方案。
- en: The reason for this change is because the previous naming scheme was at times
    unpredictable. It was possible to have network device names cross when a machine
    was rebooted, causing confusion as to which interface is which. The various distributions
    deal with this problem in their own way, but systemd has a built in naming scheme
    that is based on the position of the card in the system's bus, rather than just
    using the names `eth0`, `eth1`, and so on as the devices are probed. As mentioned
    before, Debian still utilizes the older naming scheme, despite the fact that Debian
    8 also utilizes systemd. Throughout this book, we will practice systemd commands;
    however, systemd will be explained more thoroughly in [Chapter 5](ch05.html "Chapter 5. Monitoring
    System Resources"), *Monitoring System Resources*, so don't worry too much if
    you aren't aware of how it works just yet.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更改的原因是因为以前的命名方案有时是不可预测的。当机器重新启动时，可能会出现网络设备名称交叉，导致对接口的混淆。各种发行版以自己的方式处理这个问题，但systemd具有内置的命名方案，该方案基于系统总线中卡的位置，而不仅仅使用`eth0`、`eth1`等名称，因为设备被探测。如前所述，尽管Debian
    8也使用systemd，但Debian仍然使用较旧的命名方案。在本书中，我们将练习systemd命令；但是，在[第5章](ch05.html "第5章。监视系统资源")*监视系统资源*中，我们将更详细地解释systemd，所以如果你还不知道它是如何工作的，也不用太担心。
- en: For the CentOS machine used in the second example, the wired network card was
    given the designation of `enp0s3`. So, what exactly does this mean? First of all,
    we know that `en` represents ethernet, and this part of the designation is given
    to wired network cards. The rest of the given name represents the position of
    the network card on the bus of the system. Since each wired card, if you had more
    than one, would reside in its own physical position, the name given to the device
    would be predictable. If you were to write startup scripts for a specific network
    interface, you can be reasonably certain that you'd be writing the script to reference
    the appropriate device.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中使用的CentOS机器上，有线网络卡被指定为`enp0s3`。那么，这到底意味着什么呢？首先，我们知道`en`代表以太网，这部分指定是给有线网络卡的。给定名称的其余部分代表系统总线上网络卡的位置。由于每个有线卡（如果您有多个）都会驻留在自己的物理位置，因此给定设备的名称是可预测的。如果您要为特定网络接口编写启动脚本，您可以相当肯定地知道您将编写脚本来引用适当的设备。
- en: Understanding Linux hostname resolution
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Linux主机名解析
- en: 'On a network, it''s much more convenient to look up other resources by name,
    rather than remembering the IP address of every resource we connect to. By default,
    looking up hosts by name may not function without a little configuration. For
    example, you can try the `ping` command against the name of one of your Linux
    machines, and you may or may not get a response. This is because a DNS entry for
    the resource you''re connecting to might not exist. If it doesn''t, you''ll see
    an error similar to the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上，通过名称查找其他资源要比记住我们连接到的每个资源的IP地址方便得多。默认情况下，通过名称查找主机可能需要一些配置才能正常工作。例如，您可以尝试使用`ping`命令针对您的Linux机器之一的名称，可能会得到响应，也可能不会。这是因为您连接的资源的DNS条目可能不存在。如果不存在，您将看到类似以下的错误：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, if you ping the device by its IP, it would more than likely respond:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您通过IP地址ping设备，很可能会得到响应：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Press *Ctrl* + *C* on your keyboard to break out of your `ping` command, as
    it will ping forever if it finds a connection.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 按下键盘上的*Ctrl* + *C*来中断您的`ping`命令，因为如果找到连接，它将永远ping下去。
- en: The reason for this is in order for a network host to be able to contact another,
    it needs to know its IP address. If you type in a name instead of an IP address,
    the machine will attempt hostname resolution, and if there is a valid entry in
    **Domain Name System** (**DNS**) for the machine you're attempting to contact,
    you'll be able to receive a reply. In Microsoft networks with Windows-based **Dynamic
    Host Configuration Protocol** (**DHCP**) and DNS servers, it's very typical for
    the server to register a **dynamic DNS** entry whenever it assigns an IP address
    to a host. Linux-based DHCP and DNS servers are capable of dynamic DNS as well,
    but it's not configured by default and it's rarely enabled by the administrator.
    In an all Linux network or any network that doesn't assign DNS dynamically, this
    ping would most likely fail. We discuss DNS in more detail in chapter [Chapter
    6](ch06.html "Chapter 6. Configuring Network Services"), *Configuring Network
    Services*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因是为了使网络主机能够联系另一个主机，它需要知道其IP地址。如果您输入的是名称而不是IP地址，机器将尝试主机名解析，如果**域名系统**（**DNS**）中有机器的有效条目，您将能够收到回复。在具有基于Windows的**动态主机配置协议**（**DHCP**）和DNS服务器的Microsoft网络中，每当服务器分配IP地址给主机时，它通常会注册一个**动态DNS**条目。Linux基于的DHCP和DNS服务器也能够进行动态DNS，但默认情况下不会配置，管理员也很少启用。在全Linux网络或任何不动态分配DNS的网络中，此ping很可能会失败。我们将在第[第6章](ch06.html
    "第6章。配置网络服务")*配置网络服务*中更详细地讨论DNS。
- en: 'In most cases, DNS is not the first place that a Linux host will look in order
    to resolve hostnames. There is also a file saved locally on the system (`/etc/hosts`)
    that your machine will check first. If an entry for the host you''re contacting
    isn''t included there, your machine will then contact its configured primary DNS
    server in order to find an IP address for the name that you entered. Here''s an
    example of a `host` file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，DNS不是Linux主机解析主机名的第一个地方。系统上也保存有一个本地文件（`/etc/hosts`），您的机器将首先检查该文件。如果您要联系的主机的条目未包含在其中，您的机器将联系其配置的主DNS服务器，以查找您输入的名称的IP地址。以下是`host`文件的示例：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `hosts` file presented, we can see an entry for `localhost` and an entry
    for `trinity-debian`. Both of these entries, which begin with a `127.0.x.x` IP
    address, represent the machine itself. To test this, try pinging `localhost` as
    well as the name of your machine (in this case, `trinity-debian`). Either way,
    you''ll get a reply. This is because the machine is aware of its hostname, and
    `localhost` uses the loopback adapter to reach itself. If you desired to do so,
    you could create additional name to IP address matches within this file. For example,
    if you had a computer named `potato` at IP address `10.10.96.10`, you could add
    it to the end of the `hosts` file as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在呈现的`hosts`文件中，我们可以看到`localhost`和`trinity-debian`的条目。这两个条目以`127.0.x.x` IP地址开头，代表了机器本身。要测试这一点，请尝试ping`localhost`以及您的机器的名称（在本例中为`trinity-debian`）。无论哪种方式，您都会得到回复。这是因为机器知道自己的主机名，而`localhost`使用环回适配器来访问自己。如果您愿意，您可以在此文件中创建额外的名称到IP地址的匹配。例如，如果您有一个名为`potato`的计算机，IP地址为`10.10.96.10`，您可以将其添加到`hosts`文件的末尾，如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: From now on, you'd be able to reach IP address `10.10.96.10` by typing in `potato`.
    You could ping it, or even enter it into the address bar of your browser (providing
    the machine was serving web content). In fact, the host entry doesn't even need
    to be a local resource in your network. You could even enter an IP address for
    an external website, and reach it by a different name. However, this only works
    in theory—a well-designed website may not operate under such circumstances.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，你可以通过输入`potato`来访问IP地址`10.10.96.10`。你可以ping它，甚至在浏览器的地址栏中输入它（如果机器正在提供web内容）。事实上，主机条目甚至不需要是你网络中的本地资源。你甚至可以输入外部网站的IP地址，并通过不同的名称访问它。然而，这只是在理论上有效——一个设计良好的网站可能不会在这种情况下运行。
- en: 'While `/etc/hosts` is checked first, your Linux installation includes a file,
    `/etc/nsswitch.conf` that it uses to make the ultimate determination on the order
    in which host resolution occurs. The line in question begins with `hosts`, and
    you can easily check the host resolution order on your machine with the following
    command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然首先检查`/etc/hosts`，但你的Linux安装包括一个文件`/etc/nsswitch.conf`，它用于确定主机解析的顺序。相关行以`hosts`开头，你可以使用以下命令轻松检查你的机器上的主机解析顺序：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You''ll get the following output:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we can see the system is set up to check `files` first, which represents
    local files, which includes `/etc/hosts`. If the search is for a local domain
    and it is not found, the `NOTFOUND=return` entry causes the remainder of the search
    to abort. If you're searching for anything else, the next resource that will be
    used is DNS, as shown with `dns` being the last entry. Unless you changed this
    file, chances are that your distribution will also be set up to look within local
    hosts files first, and then DNS if the resource is not found locally.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到系统设置为首先检查`files`，这代表本地文件，包括`/etc/hosts`。如果搜索的是本地域名并且没有找到，`NOTFOUND=return`条目会导致搜索的其余部分中止。如果你搜索其他内容，下一个将被使用的资源是DNS，如最后一个条目所示。除非你改变了这个文件，你的发行版也很可能设置为首先在本地主机文件中查找，如果资源在本地找不到，然后再查找DNS。
- en: Understanding the net-tools and iproute2 suites
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解net-tools和iproute2套件
- en: 'For quite some time, **net-tools** has been the suite of tools used to manage
    network connections on Linux systems. The net-tools suite includes commands such
    as `ifconfig`, `route`, `netstat`, and others (which we''ll discuss shortly).
    The problem with net-tools is that it hasn''t been updated by its developers in
    well over a decade, making many distributions opt to abandon it in favor of the
    **iproute2** suite, which offers the same functionality (but with different commands
    to achieve the same goals). Even though net-tools are being deprecated, quite
    a few distributions still include it. For example, Debian includes both iproute2
    and net-tools, so you can use commands from either suite. In CentOS, iproute2
    is present though net-tools is not installed by default. If you would like to
    utilize the older net-tools, you can install it in CentOS with the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 相当长的一段时间以来，**net-tools**一直是在Linux系统上管理网络连接的工具套件。net-tools套件包括诸如`ifconfig`、`route`、`netstat`等命令（我们将很快讨论）。net-tools的问题在于，它的开发者已经十多年没有更新了，这使得许多发行版选择放弃它，转而选择**iproute2**套件，它提供了相同的功能（但使用不同的命令来实现相同的目标）。尽管net-tools正在被弃用，仍然有很多发行版包括它。例如，Debian包括iproute2和net-tools，因此你可以使用任一套件的命令。在CentOS中，iproute2是默认安装的，而net-tools则不是。如果你想使用旧的net-tools，你可以使用以下命令在CentOS中安装它：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, why would you want to install `net-tools` if it's being abandoned? Many
    systems still have scripts that use commands from the net-tools suite, so it's
    not something that will disappear from the Linux community any time soon. Learning
    net-tools, as well as the newer iproute2, will enable you to easily adapt to any
    environment. This is especially the case for older data centers that are using
    older distributions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么你要安装`net-tools`，如果它正在被弃用？许多系统仍然使用net-tools套件的命令，因此它不会很快从Linux社区消失。学习net-tools以及更新的iproute2，将使你能够轻松适应任何环境。特别是对于使用旧发行版的旧数据中心来说，情况尤其如此。
- en: 'Let''s see these suites in action. First, to report basic information about
    your network connections, type the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些套件的实际操作。首先，要报告有关你的网络连接的基本信息，请输入以下命令：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should see the following output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '![Understanding the net-tools and iproute2 suites](img/B03919_02_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![理解net-tools和iproute2套件](img/B03919_02_03.jpg)'
- en: The output of the ifconfig command
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ifconfig命令的输出
- en: Here, we can see statistics from both the internal wired connection (`eth0`)
    as well as the loopback adapter (`lo`). We see `HWaddr`, which is the **MAC address**
    of the network card. We also have `inet addr`, which is the IP address that the
    card was provided by the **DHCP server**. In addition, we can see the subnet mask,
    `Mask`, which is `255.255.252.0` in this case. While troubleshooting networking
    issues, we would use this tool to check these basic things, such as ensuring we
    have an IP address and we are on the appropriate subnet. In addition, we can also
    see the number of packets sent and received on the interface, as well as the number
    of errors.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到来自内部有线连接（`eth0`）和环回适配器（`lo`）的统计信息。我们看到`HWaddr`，这是网络卡的**MAC地址**。我们还有`inet
    addr`，这是网络卡由**DHCP服务器**提供的IP地址。此外，我们可以看到子网掩码`Mask`，在这种情况下是`255.255.252.0`。在解决网络问题时，我们会使用这个工具来检查这些基本信息，比如确保我们有一个IP地址并且在适当的子网上。此外，我们还可以看到在接口上发送和接收的数据包数量，以及错误的数量。
- en: 'With the iproute2 suite, we can find most of the same information with the
    following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用iproute2套件，我们可以使用以下命令找到大部分相同的信息：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here''s the output from a reference machine:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个参考机器的输出：
- en: '![Understanding the net-tools and iproute2 suites](img/B03919_02_04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![理解net-tools和iproute2套件](img/B03919_02_04.jpg)'
- en: The output from the ip addr show command
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ip addr show命令的输出
- en: 'As you can see, the information reported is mostly the same, though the layout
    is a bit different. For example, one difference is that you don''t see the number
    of packets sent and received, nor an error count (by default). In the past, the
    following command would show the IP addresses in use as well as sent and received
    packets:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，报告的信息大部分是相同的，尽管布局有些不同。例如，一个区别是你看不到发送和接收的数据包数量，也没有错误计数（默认情况下）。过去，以下命令将显示正在使用的IP地址以及发送和接收的数据包：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Understanding the net-tools and iproute2 suites](img/B03919_02_05.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![理解net-tools和iproute2套件](img/B03919_02_05.jpg)'
- en: The output of the ip addr show command with the -s flag added
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用添加了-s标志的ip addr show命令的输出
- en: Unfortunately, recent versions of the iproute2 suite don't seem to show this
    information anymore (despite adding the `-s` switch), but we'll look at additional
    tools later on in this book.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，最近版本的iproute2套件似乎不再显示这些信息（尽管添加了`-s`开关），但我们将在本书的后面看到更多的工具。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Instead of `addr` in the previous commands, you can also type out the entire
    string (address) such as:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，你也可以输入整个字符串（地址）而不是`addr`。
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The output will be the same. The commands shown in these examples were condensed,
    which save typing time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是相同的。这些示例中显示的命令是压缩过的，这样可以节省输入时间。
- en: The iproute2 suite features many more commands than just these, and we'll discuss
    them as the book continues. For now, it's important to understand the difference
    between the two command suites and to note that net-tools won't be available forever.
    In the time period in which this book was written, both are common. However, iproute2
    is the name of the game going forward.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: iproute2套件中有许多其他命令，我们将在本书继续讨论。现在，重要的是要理解这两个命令套件之间的区别，并注意net-tools不会永远可用。在本书编写的时间段内，两者都很常见。然而，iproute2是未来的主流。
- en: 'Before closing out this section, there''s a really easy command in the iproute2
    suite that might prove useful:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本节之前，iproute2套件中有一个非常简单的命令可能会很有用：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This simple command just prints the hostname of the machine on which your shell
    is attached. If you're using your default bash prompt, chances are you are already
    aware of your machine's hostname. However, the hostname command can at least help
    you verify that your device is reporting the hostname you think it should be;
    this can be useful when you're dealing with name resolution issues.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的命令只是打印出你的shell所连接的机器的主机名。如果你使用默认的bash提示符，很可能你已经知道你的机器的主机名。然而，hostname命令至少可以帮助你验证你的设备是否报告了你认为它应该报告的主机名；当你处理名称解析问题时，这可能是有用的。
- en: Manually managing network interfaces
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动管理网络接口
- en: In most cases, after you install your desired distribution of Linux, it receives
    an IP address via DHCP and away it goes. Whether you're using a graphical desktop
    environment or a shell environment with no GUI, the magic mostly happens in the
    background. While there are GUI tools to manage your network connections, anything
    you can do via a graphical tool, you can do via the shell. In the case of servers,
    there may not be a graphical environment at all, so learning how to manage your
    network connection via the shell is very important. In this section, we'll discuss
    the method for manually configuring an interface in Debian, and then discuss how
    to do the same thing with CentOS.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，在安装所需的Linux发行版后，它会通过DHCP接收一个IP地址，然后就可以使用了。无论你是使用图形桌面环境还是没有图形界面的shell环境，大部分魔术都是在后台发生的。虽然有图形工具来管理你的网络连接，但任何你可以通过图形工具做的事情，你也可以通过shell来做。在服务器的情况下，可能根本没有图形环境，所以学会如何通过shell管理你的网络连接非常重要。在本节中，我们将讨论在Debian中手动配置接口的方法，然后讨论如何在CentOS中做同样的事情。
- en: 'In the previous section, two methods were discussed for finding your current
    IP address. Depending on whether your distribution ships net-tools or iproute2,
    you can use one method or the other (or both). Of course, that''s the first step.
    Do you have a connection? Checking to see whether or not you have an IP address
    is a logical place to start. You can also utilize a simple ping test:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，讨论了两种查找当前IP地址的方法。根据你的发行版是否提供了net-tools或iproute2，你可以使用其中一种方法或两种方法（或两者）。当然，这是第一步。你有连接吗？检查你是否有IP地址是一个合乎逻辑的起点。你也可以利用一个简单的ping测试：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you do get a response, chances are that you have a network connection. However,
    if you don't get a response, it doesn't necessarily mean that there's something
    wrong with your network. Some sites are configured to not respond to ping tests.
    Whenever possible, ping against local resources instead (such as your local DNS
    or DHCP server).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到了回应，很可能你有网络连接。然而，如果你没有得到回应，并不一定意味着你的网络有问题。有些站点配置为不响应ping测试。在可能的情况下，最好针对本地资源进行ping测试（比如你的本地DNS或DHCP服务器）。
- en: 'In Linux, ping works a bit differently than in Windows. For starters, the `ping`
    command in Linux will run virtually forever by default. To break out of it, press
    *Ctrl* + *C* on your keyboard. If you prefer to have `ping` stop after a certain
    number of tries, add the `-c` flag accompanied by the number of times you''d like
    it to attempt. In this case, our `ping` command will be like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，ping的工作方式与Windows有些不同。首先，在Linux中，`ping`命令默认会一直运行下去。要退出它，按键盘上的*Ctrl*
    + *C*。如果你希望`ping`在尝试一定次数后停止，添加`-c`标志并附上你希望它尝试的次数。在这种情况下，我们的`ping`命令将是这样的：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, `ping` will attempt four times, stop, and then report some basic
    statistics to you.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`ping`将尝试四次，然后停止，并向你报告一些基本统计信息。
- en: Knowing how to check whether or not you're connected is one thing, but what
    do you do when you're not? Or what if your network connection is active, but reports
    invalid information and you need to reconfigure it?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何检查你是否连接是一回事，但当你没有连接时该怎么办呢？或者如果你的网络连接是活跃的，但报告无效信息，你需要重新配置它呢？
- en: 'First, let''s explore how to check our current configuration. In Debian, the
    file that controls the network devices by default is the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们探讨如何检查我们当前的配置。在Debian中，默认控制网络设备的文件是以下文件：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Depending on several variables, which include how you configured your Debian
    installation, this file may be created differently. First, you may see several
    interfaces listed, such as your loopback adapter, wired Ethernet, and wireless.
    If you have more than one wired interface, you'll see any additional adapters
    here as well. This file is, simply put, a **configuration file**. It's a text
    file that contains information that the underlying Linux system understands, and
    causes a device to be configured as designated in the file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据几个变量，包括您如何配置Debian安装，这个文件可能会有不同的创建方式。首先，您可能会看到列出了几个接口，比如回环适配器、有线以太网和无线。如果您有多个有线接口，您也会在这里看到任何额外的适配器。简单地说，这个文件是一个**配置文件**。它是一个文本文件，包含了底层Linux系统理解的信息，并导致设备按照文件中指定的方式进行配置。
- en: 'To edit files such as these, there are many Linux text editors available, both
    GUI and terminal based. My personal favorite is **vim**, though many administrators
    typically start off with **nano**. The nano text editor is fairly easy to use,
    though very light on features. Alternatively, vim has many more features than
    nano but is a bit harder to get used to. Take your pick. To open a file in nano,
    all you need to do is type `nano` along with the name of a text file you would
    like to edit. If the file doesn''t exist, the command will create it if you save
    the file. In the case of our `/etc/network/interfaces` file, the command will
    be similar to this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑这样的文件，有许多Linux文本编辑器可用，包括GUI和基于终端的。我个人最喜欢的是**vim**，尽管许多管理员通常从**nano**开始。nano文本编辑器非常容易使用，但功能很少。另外，vim比nano有更多的功能，但使用起来有点难。你可以自己选择。要在nano中打开一个文件，你只需要输入`nano`，然后加上你想编辑的文本文件的名称。如果文件不存在，命令会在你保存文件时创建它。对于我们的`/etc/network/interfaces`文件，命令将类似于这样：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using nano is simply a matter of opening a file, using the arrow keys on your
    keyboard to move the insertion point to where you want to type, pressing *Ctrl*
    + *O* to save the file, and pressing *Ctrl* + *X* to exit. There are more features,
    but for the purposes of editing our configuration files, that's all we need for
    now. A tutorial for vim is beyond the scope of this book, but feel free to play
    around with it if you wish.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nano只是简单地打开一个文件，使用键盘上的箭头键将插入点移动到您想要输入的位置，按下*Ctrl* + *O*保存文件，然后按下*Ctrl* + *X*退出。还有更多功能，但就目前来说，这就是我们需要的。本书不涵盖vim的教程，但如果你愿意，可以随意尝试。
- en: Now, back to the subject of our `/etc/network/interfaces` file. It's important
    to note that this file is not required for the purposes of ethernet and wireless
    adapters. If you see nothing in this file at all (other than the loopback device)
    it means that the network connections are being managed by **Network Manager**.
    Network Manager is a graphical tool for managing client-side network connections
    (which we'll discuss later in this chapter). For our purposes in this section,
    Network Manager is typically installed when you decide to include a graphical
    desktop environment when setting up Debian for the first time. If you did opt
    for a graphical environment (such as GNOME, Xfce, and so on), then Network Manager
    was more than likely set up for you and is handling the job of configuring your
    interfaces. If your `interfaces` file is blank other than the entry for the loopback
    adapter, then that means Network Manager is handling this task.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到我们的`/etc/network/interfaces`文件的主题。重要的是要注意，这个文件对于以太网和无线适配器并不是必需的。如果在这个文件中除了回环设备之外什么都没有，那就意味着网络连接是由**网络管理器**来管理的。网络管理器是一个用于管理客户端网络连接的图形工具（我们将在本章后面讨论）。对于本节中的目的，当您第一次设置Debian时，通常会安装网络管理器，特别是当您决定包括图形桌面环境时（如GNOME、Xfce等）。如果您选择了图形环境，那么网络管理器很可能已经为您设置好，并且正在处理配置您的接口的工作。如果您的`interfaces`文件除了回环适配器的条目之外是空白的，那就意味着网络管理器正在处理这个任务。
- en: With Debian, it's extremely common to see installations in the wild with no
    graphical environment installed at all. A GUI is usually not necessary for the
    server to fulfill its purpose. A typical Linux administrator will configure a
    server with the minimum required packages for it to do its job, which often will
    not include a desktop environment. In this case, Network Manager may not be installed
    at all. If it's not, the `/etc/network/interfaces` file will then be responsible
    for setting up the connection. In other cases, perhaps Network Manager is installed,
    but was disabled by the administrator whom configured the network connections
    in this file instead.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian中，非常常见的是在野外看到没有安装图形环境的安装。对于服务器来说，通常不需要GUI来实现其目的。典型的Linux管理员会为服务器配置最少的必需软件包，以便它完成其工作，这通常不包括桌面环境。在这种情况下，可能根本没有安装网络管理器。如果没有安装，那么`/etc/network/interfaces`文件将负责设置连接。在其他情况下，也许网络管理器已经安装，但是被管理员禁用了，而是在这个文件中配置了网络连接。
- en: So, when should you use Network Manager, and when should you just configure
    your connections in the `interfaces` file? In the case of end-user workstations
    (desktops and laptops), Network Manager is almost always preferred. In the case
    of servers, setting up the configuration in `/etc/network/interfaces` is preferred,
    especially when setting up a static IP address.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么时候应该使用网络管理器，什么时候应该只在`interfaces`文件中配置连接？对于最终用户工作站（台式机和笔记本电脑），几乎总是首选网络管理器。对于服务器，特别是在设置静态IP地址时，首选在`/etc/network/interfaces`中设置配置。
- en: 'We''ve discussed what the `interfaces` file is, and when you''d want to use
    it. Now, let''s take a look at `some` various types of configurations you can
    expect to see. First, let''s gander at the `interfaces` file when only the local
    loopback adapter is listed:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了`interfaces`文件是什么，以及何时使用它。现在，让我们看一下你可能会看到的`一些`各种类型的配置。首先，让我们看一下只列出本地回环适配器时的`interfaces`文件：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Comments are declared with the first character `#`, which is ignored when the
    configuration file is parsed. In the previous example, the first line is ignored
    and it just serves as information.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注释以第一个字符`#`声明，在解析配置文件时会被忽略。在前面的例子中，第一行被忽略，只是作为信息。
- en: 'In this example, the machine most likely has Network Manager in use, as neither
    the wired (typically `eth0`) or wireless (typically `wlan0`) interfaces are shown.
    To verify this, we can check to see if Network Manager is running via the following
    command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，这台机器很可能正在使用网络管理器，因为有线（通常是`eth0`）或无线（通常是`wlan0`）接口都没有显示。为了验证这一点，我们可以通过以下命令检查网络管理器是否正在运行：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If Network Manager is running, you might see an output like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网络管理器正在运行，你可能会看到这样的输出：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That mystery is solved; the machine uses Network Manager, so there is no configuration
    for `eth0` or `wlan0` stored in `/etc/network/interfaces`. Now, let''s take a
    look at an example from a machine where Network Manager is not being used. To
    configure `eth0` in such an installation, the `interfaces` file would look similar
    to this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜团已经解开了；这台机器使用了网络管理器，所以在`/etc/network/interfaces`中没有存储`eth0`或`wlan0`的配置。现在，让我们看一个网络管理器没有使用的机器的示例。要在这样的安装中配置`eth0`，`interfaces`文件看起来会类似于这样：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see, we still have the loopback entry as we did before, but at the
    end of the file, configuration details were included for `eth0`. Just as in our
    loopback entry, we declare `auto` and then an interface name `eth0`, which means
    that we would like interface `eth0` to automatically come up. In the next line,
    we clarify that we'd like to utilize `dhcp` for interface `eth0` so that it will
    obtain an IP address automatically from a DHCP server.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所做的那样，我们仍然有回环条目，但在文件的末尾，包括了`eth0`的配置细节。就像我们的回环条目一样，我们声明`auto`，然后是一个接口名`eth0`，这意味着我们希望接口`eth0`自动启动。在下一行中，我们澄清了我们希望为接口`eth0`使用`dhcp`，以便它将从DHCP服务器自动获取IP地址。
- en: In the real world, there's no good reason to abandon Network Manager in favor
    of manually configuring the connection when all we're going to do is use DHCP.
    However, this example was included here because it's actually fairly common in
    situations where a server receives a **static lease** from a DHCP server, rather
    than a dynamic one. With a static lease, the DHCP server will provide the same
    IP address for a particular MAC address each time. So in such a scenario, a server
    could have a designated IP address for it, but the IP address is still provided
    by a DHCP server. This is also known as a **DHCP reservation**.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，没有理由放弃网络管理器，而选择手动配置连接，当我们要做的只是使用DHCP时。然而，这个例子被包含在这里，因为在服务器从DHCP服务器接收**静态租约**而不是动态租约的情况下，这实际上是相当常见的。使用静态租约，DHCP服务器将为特定MAC地址提供相同的IP地址。因此，在这种情况下，服务器可以为其指定IP地址，但IP地址仍然是由DHCP服务器提供的。这也被称为**DHCP保留**。
- en: Of course, it's also possible (and perhaps more common) to simply declare a
    static IP in the interfaces file. We'll even explore that method next. But a static
    lease is worth pointing out because it does carry with it an additional benefit.
    With a static lease, the node's IP configuration is not tied to its configuration
    with its installed distribution. If it's booted from live media, or even if the
    distribution is reinstalled, the node will still receive the same IP address each
    time its interface comes up. An additional benefit of a static lease is that you
    can configure the static IPs of all your nodes in one central place (on the DHCP
    server), rather than keep track of individual configuration files from machine
    to machine.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也有可能（也许更常见）只在interfaces文件中声明静态IP。我们将在下面探讨这种方法。但是，值得指出的是，静态租约具有额外的好处。使用静态租约，节点的IP配置不会与其安装的发行版的配置绑定。如果从活动媒体引导，甚至重新安装发行版，节点每次接口启动时都会收到相同的IP地址。静态租约的另一个好处是，您可以在一个中心位置（在DHCP服务器上）配置所有节点的静态IP，而不必跟踪每台机器的单独配置文件。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to note that seeing `dhcp` listed in the `interfaces` file for
    an interface does not always mean that a static lease is in use. For Debian, it's
    common for an administrator to simply not install Network Manager, and then manually
    type the `interfaces` file when bringing up a server.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在`interfaces`文件中看到接口列出`dhcp`并不总是意味着正在使用静态租约。对于Debian来说，管理员通常只是不安装网络管理器，然后在启动服务器时手动输入`interfaces`文件。
- en: 'Now, let''s look at an example `interfaces` file where a static IP has been
    manually configured:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个示例`interfaces`文件，其中手动配置了静态IP：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'First, notice the change in the following line:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意以下一行的变化：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: At the end, we declare `static` instead of `dhcp`. If we had forgotten to change
    this, all the remaining lines of the configuration file would then be ignored.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们声明了`static`而不是`dhcp`。如果我们忘记更改这个，那么配置文件的所有剩余行将被忽略。
- en: Then, we declare the statistics for interface `eth0`. We set the IP address
    to `10.10.10.12`, the subnet mask to `255.255.248.0`, the network we're joining
    to `10.10.10.0`, the broadcast ID as `10.10.10.255`, and the gateway as `10.10.10.1`.
    We'll discuss what each of these values actually mean later on in this book, but
    for now the important thing to note is the syntax for this file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明了接口`eth0`的统计信息。我们将IP地址设置为`10.10.10.12`，子网掩码设置为`255.255.248.0`，我们加入的网络设置为`10.10.10.0`，广播ID为`10.10.10.255`，网关为`10.10.10.1`。我们将在本书的后面讨论这些值实际上是什么意思，但现在需要注意的重要事情是这个文件的语法。
- en: 'So now you may be wondering how we make these changes take effect, now that
    we went through the trouble of configuring our interface. To do so, you would
    use the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可能想知道我们如何使这些更改生效，既然我们费力地配置了我们的接口。要这样做，您将使用以下命令：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With CentOS, the process of manually configuring network interfaces is a bit
    different to Debian systems. First, we''ll need to know which interfaces are installed
    on our machine. Running the following command will list them, along with any IP
    addresses that are currently assigned:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS中，手动配置网络接口的过程与Debian系统有些不同。首先，我们需要知道机器上安装了哪些接口。运行以下命令将列出它们以及当前分配的任何IP地址：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this section, I''ll use `enp0s3`, which is the default on the test machine
    used for this book. If yours differs, change these example commands accordingly.
    Anyway, now that we know what interface we''re working with, let''s configure
    it. Next, navigate to the following directory:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将使用`enp0s3`，这是本书用于测试的测试机器上的默认设置。如果您的设置不同，请相应更改这些示例命令。无论如何，既然我们知道我们正在使用哪个接口，让我们配置它。接下来，导航到以下目录：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you list the storage for the files within that directory (the `ls` command),
    you should see a configuration file with a name that matches the name of your
    interface. In our example of `enp0s3`, you should see a file named `ifcfg-enp0s3`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列出该目录中的文件存储（`ls`命令），您应该看到一个与接口名称匹配的配置文件。在我们的示例中，`enp0s3`，您应该看到一个名为`ifcfg-enp0s3`的文件。
- en: 'Open this file with your chosen text editor and you''ll see the configuration
    looks similar to the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 用您选择的文本编辑器打开此文件，您将看到配置类似于以下内容：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, this default file is using `dhcp`, which is listed on the third
    line. To configure this connection to utilize a static address, we''ll need to
    change the file accordingly. Changes to the file are marked in bold:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此默认文件使用`dhcp`，列在第三行。要配置此连接以利用静态地址，我们需要相应地更改文件。文件的更改部分已用粗体标记：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we made just four changes to the file. First, we changed `BOOTPROTO`
    to `static`. Then, we added the following brand new lines just underneath it:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们对文件进行了四处更改。首先，我们将`BOOTPROTO`更改为`static`。然后，在其下面添加了以下全新的行：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I'm sure you can gather what the first two lines are responsible for. The fourth
    line we added may be obvious too, but just in case it isn't, we're basically telling
    our system that we would rather not manage our connection via Network Manager,
    and would like to take care of that ourselves with this configuration file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信您可以理解前两行的作用。我们添加的第四行可能也很明显，但以防万一，我们基本上告诉系统，我们宁愿不通过网络管理器管理连接，并且希望自己通过此配置文件处理。
- en: 'Of course, we need to restart networking in order for these changes to take
    effect. Since CentOS uses systemd (just like Debian 8), the command is very similar:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要重新启动网络以使这些更改生效。由于CentOS使用systemd（就像Debian 8一样），命令非常相似：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And, there you have it. We took care of manually setting up our network interfaces
    in both Debian and CentOS.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们已经在Debian和CentOS中手动设置了网络接口。
- en: Managing connections with Network Manager
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网络管理器管理连接
- en: While we just went through the trouble of manually configuring our network interfaces,
    it's not always the case that this is desirable. End user workstations, for example,
    would benefit from Network Manager handling this job for us. For laptops and their
    wireless interfaces, Network Manager does the job better than most of us would.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们刚刚费力地手动配置了网络接口，但并不总是需要这样做。例如，最终用户的工作站将受益于网络管理器为我们处理这项工作。对于笔记本电脑及其无线接口，网络管理器比大多数人做得更好。
- en: 'Network Manager is usually installed by default in most distributions of Linux.
    For Debian, it is typically installed whenever you opt for a graphical desktop
    environment. If you opted for a shell-only install (you unchecked the options
    for a desktop environment during installation), you probably don''t have it installed.
    To be sure, execute the following command (works on both Debian and CentOS):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 网络管理器通常默认安装在大多数Linux发行版中。对于Debian来说，通常在选择图形桌面环境时安装。如果您选择了仅安装shell（在安装过程中取消了桌面环境的选项），那么您可能没有安装它。要确定，请执行以下命令（在Debian和CentOS上都适用）：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you see that Network Manager is running, then it is installed. But to be
    double-sure, you can execute this command in Debian:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到网络管理器正在运行，则已安装。但为了确保，您可以在Debian中执行以下命令：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If Network Manager is installed, you''ll see it listed as follows (there will
    be an `i` designation to the left of it):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装了网络管理器，您将看到它列在以下位置（左侧将有一个`i`标记）：
- en: 'In CentOS, you can check whether Network Manager is installed or not using
    the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS中，您可以使用以下命令检查网络管理器是否已安装：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you''re running a desktop environment, you may have an implementation of
    Network Manager running within your system tray. If so, feel free to manage your
    connection via the available GUI tools. Depending on which desktop environment
    you''re using, the instructions for doing so will be different. In this section,
    we discuss a more universal approach to utilizing Network Manager to configure
    connections. This method is to use the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行图形桌面环境，您可能在系统托盘中运行了网络管理器的实现。如果是这样，请随时使用可用的GUI工具管理您的连接。根据您使用的图形桌面环境，执行此操作的说明将有所不同。在本节中，我们讨论了一种更通用的方法来利用网络管理器配置连接。这种方法是使用以下命令：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `nmtui` command allows you to configure Network Manager within a shell environment,
    but with GUI-like controls.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`nmtui`命令允许您在shell环境中配置网络管理器，但具有类似GUI的控件。'
- en: '![Managing connections with Network Manager](img/B03919_02_06.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![使用网络管理器管理连接](img/B03919_02_06.jpg)'
- en: Configuring a system's network connection via nmtui
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过nmtui配置系统的网络连接
- en: 'If we click on **Edit a connection**, we will see a list of interfaces available
    on our machine:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击**编辑连接**，我们将看到机器上可用的接口列表：
- en: '![Managing connections with Network Manager](img/B03919_02_07.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![使用网络管理器管理连接](img/B03919_02_07.jpg)'
- en: nmtui interface selection
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: nmtui接口选择
- en: When we select an interface, we'll first see some basic information.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们选择一个接口时，我们首先会看到一些基本信息。
- en: '![Managing connections with Network Manager](img/B03919_02_08.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![使用网络管理器管理连接](img/B03919_02_08.jpg)'
- en: First screen of editing a connection in nmtui
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在nmtui中编辑连接的第一个屏幕
- en: To edit the IP address for this interface, press the down arrow key to select
    **<AUTOMATIC>** on the left-hand side of **IPv4 CONFIGURATION** and press *Enter*.
    Then, press the right arrow key to select the **<Show>** option and expand the
    remaining fields.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑此接口的IP地址，请按下箭头键选择**<自动>**在**IPv4配置**左侧，并按*Enter*。然后，按右箭头键选择**<显示>**选项并展开其余字段。
- en: '![Managing connections with Network Manager](img/B03919_02_09.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![使用网络管理器管理连接](img/B03919_02_09.jpg)'
- en: Editing a connection with nmtui
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nmtui编辑连接
- en: To edit an item, press the down arrow key to the **<Add...>** option next to
    the field. It will expand a textbox to allow you to edit the item.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑项目，请按下箭头键到字段旁边的**<添加...>**选项。它会展开一个文本框，允许您编辑该项目。
- en: '![Managing connections with Network Manager](img/B03919_02_10.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![使用网络管理器管理连接](img/B03919_02_10.jpg)'
- en: Editing a connection with nmtui
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nmtui编辑连接
- en: When finished, scroll all the way down and press *Enter* on **<OK>** to save
    your changes. There you have it; you should be able to manage your connections
    via Network Manager, should you choose to do so.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，滚动到底部并按*Enter*在**<确定>**上保存您的更改。您应该能够选择通过网络管理器管理您的连接。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the basics of TCP/IP networking in Linux and even
    configured our interfaces manually. We explored how to edit the configuration
    files associated with Debian and CentOS, as well as how to restart networking
    on both platforms. We briefly talked about the systemd method, though we'll explore
    systemd in more depth in [Chapter 5](ch05.html "Chapter 5. Monitoring System Resources"),
    *Monitoring System Resources*. We finished the chapter by utilizing the `nmtui`
    tool to configure Network Manager for our system.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Linux中TCP/IP网络的基础知识，甚至手动配置了我们的接口。我们探讨了如何编辑与Debian和CentOS相关的配置文件，以及如何在两个平台上重新启动网络。我们简要讨论了systemd方法，尽管我们将在[第5章](ch05.html
    "第5章。监视系统资源")中更深入地探讨systemd，*监视系统资源*。我们通过使用`nmtui`工具为我们的系统配置网络管理器来结束本章。
- en: In the next chapter, we'll take a look at how to use **Secure Shell** (**SSH**)
    to remotely manage our systems.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看如何使用**安全外壳**（**SSH**）远程管理我们的系统。
