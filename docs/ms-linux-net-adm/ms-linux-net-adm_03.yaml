- en: Chapter 3. Communicating Between Nodes via SSH
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。通过SSH在节点之间通信
- en: SSH is one of the most important tools for a Linux network administrator. It
    allows you to connect to servers and other workstations remotely, and work on
    them from within your favorite terminal emulator—all from the comfort of your
    desk. While SSH might not be the perfect tool for every situation, it's one of
    those that you won't be able to imagine life without, once you start using it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: SSH是Linux网络管理员最重要的工具之一。它允许您远程连接到服务器和其他工作站，并在您喜爱的终端仿真器中进行工作，所有这些都可以在您的办公桌上完成。虽然SSH可能不是每种情况下的完美工具，但一旦开始使用，您就无法想象没有它的生活。
- en: 'In this chapter, we explore SSH and cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨SSH并涵盖以下主题：
- en: Using OpenSSH
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenSSH
- en: Installing and configuring OpenSSH
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置OpenSSH
- en: Connecting to network hosts via openssh-client
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过openssh-client连接到网络主机
- en: The OpenSSH config file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSSH配置文件
- en: Understanding and utilizing `scp`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和使用`scp`
- en: Transferring files to another node via `scp`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`scp`将文件传输到另一个节点
- en: Tunneling traffic via SSH
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过SSH进行流量隧道
- en: Generating public keys
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成公钥
- en: Keeping SSH connections alive
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持SSH连接活动
- en: Exploring an alternative to SSH – utilizing Mosh (mobile shell)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索SSH的替代方案-使用Mosh（移动shell）
- en: Using OpenSSH
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenSSH
- en: '**SSH**, or **Secure Shell**, is a very handy utility. SSH is not an absolute
    requirement for performing tasks in your server room, but it is one of those things
    that will make your life a lot easier. With SSH, you are able to execute commands
    on a different Linux machine as though you were sitting right there in front of
    it. Sure, you could always walk into your server room, grab the keyboard, and
    start working, but nowadays remote administration is the name of the game. This
    is especially true if it''s your turn to be on call and an issue comes up at the
    office. Depending on the nature of the issue, SSH may allow you to fix the problem
    from home (or even on your smart phone) without having to make the trek all the
    way to your company''s server room. That''s not all; SSH also allows you to copy
    files from one machine to another and set up an actual storage mount to a directory
    on a server, which can be treated, on your workstation, like the directory were
    a local part of your filesystem.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSH**，或**安全外壳**，是一个非常方便的实用程序。SSH并非在服务器室执行任务的绝对要求，但它是使您的生活变得更加轻松的工具之一。通过SSH，您可以在不同的Linux机器上执行命令，就好像您就坐在它的面前一样。当然，您可以随时走进服务器室，拿起键盘开始工作，但现在远程管理才是最重要的。特别是如果轮到您值班并且办公室出现问题。根据问题的性质，SSH可能允许您在家中（甚至在智能手机上）解决问题，而无需一直走到公司的服务器室。这还不是全部；SSH还允许您将文件从一台机器复制到另一台机器，并在服务器上的目录上设置一个实际的存储挂载，可以在您的工作站上像本地文件系统的一部分一样处理。'
- en: The concept of connecting to a remote host and opening a command shell is not
    new, and SSH is not the first to do it. Other solutions, such as telnet or rlogin,
    have existed for quite a while. What makes SSH desirable is that it is more secure
    than earlier technologies, as communication is encrypted. There are two protocols
    for SSH, protocol 1 and protocol 2\. Protocol 1 should not be used under any circumstances,
    as it is no longer secure. Traffic sent between two hosts utilizing protocol 1
    could be intercepted by an attacker. We will discuss this aspect of SSH in [Chapter
    9](ch09.html "Chapter 9. Securing Your Network"), *Securing Your Network*, but
    for now I want to make sure that you understand that you shouldn't use an SSH
    connection with protocol 1\. You should not offer protocol 1 to any of your hosts.
    Nowadays, protocol 2 is the default.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到远程主机并打开命令shell的概念并不新鲜，SSH也不是第一个这样做的工具。其他解决方案，如telnet或rlogin，已经存在了相当长的时间。使SSH令人向往的是它比早期技术更加安全，因为通信是加密的。SSH有两种协议，协议1和协议2。协议1绝对不应该在任何情况下使用，因为它不再安全。使用协议1发送的流量可能会被攻击者拦截。我们将在[第9章](ch09.html
    "第9章。保护您的网络")*保护您的网络*中讨论SSH的这一方面，但现在我想确保您了解，您不应该使用协议1的SSH连接。您不应该向任何主机提供协议1。如今，协议2是默认的。
- en: By default, SSH uses port 22 to communicate. If this port is blocked by a firewall,
    you will not be able to connect. This is extremely common in Windows-centric businesses,
    since SSH is more common in the Linux/UNIX world. By changing the configuration
    of the SSH server, you can configure it to listen on any port you like. While
    we won't get into how to configure this just yet (we'll discuss this in [Chapter
    9](ch09.html "Chapter 9. Securing Your Network"), *Securing Your Network*), it's
    mentioned here because it's important to note that you may run into a situation
    where you aren't able to connect to an SSH server, for example, when the port
    is either closed or has been changed to a different one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SSH使用端口22进行通信。如果防火墙阻止了这个端口，您将无法连接。这在以Windows为中心的企业中非常常见，因为SSH在Linux/UNIX世界中更为常见。通过更改SSH服务器的配置，您可以将其配置为监听任何您喜欢的端口。虽然我们暂时不会讨论如何配置这一点（我们将在[第9章](ch09.html
    "第9章。保护您的网络")*保护您的网络*中讨论这一点），但这里提到是因为重要的是您可能会遇到一种情况，即无法连接到SSH服务器，例如当端口关闭或已更改为其他端口时。
- en: Although I mentioned that learning SSH isn't actually required to perform tasks
    on a server or workstation, it is highly recommended that you spend time to learn
    it. Not only do companies that utilize Linux servers expect you to know it, you
    won't want to miss out on its advantages. Thankfully, as useful as SSH is, it's
    by no means difficult to learn. You could easily learn the most basic functionality
    in five minutes, or advanced usage within a week.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我提到学习SSH实际上并不是在服务器或工作站上执行任务的必需条件，但强烈建议您花时间学习它。不仅是使用Linux服务器的公司希望您了解它，您也不想错过它的优势。值得庆幸的是，尽管SSH非常有用，但学习它并不难。您可以在五分钟内轻松学会最基本的功能，或者在一周内学会高级用法。
- en: Installing and configuring OpenSSH
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置OpenSSH
- en: OpenSSH comes in two pieces, the client application and the server application.
    It's likely that the client application is installed by default in your distribution.
    The client allows you to connect to other nodes via SSH, but having the client
    alone doesn't allow others to connect to you. If you want to access a machine
    via SSH, that machine must also have the SSH server application installed. Your
    chosen distribution may have the server application installed by default, but
    most don't. This is due to security—unless you absolutely need to have an application
    running and listening for connections, it should be absent. The fewer applications,
    the smaller the attack surface someone could use against you.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSH有两个部分，客户端应用程序和服务器应用程序。在您的发行版中，默认情况下可能已安装了客户端应用程序。客户端允许您通过SSH连接到其他节点，但仅具有客户端不允许其他人连接到您。如果要通过SSH访问某台机器，则该机器还必须安装SSH服务器应用程序。您选择的发行版可能默认安装了服务器应用程序，但大多数不会。这是出于安全考虑-除非您绝对需要运行并侦听连接的应用程序，否则应该不存在。应用程序越少，攻击面就越小。
- en: 'In Debian, SSH server is an option during the installation process. If selected,
    the server application of SSH will be present and will start by default. To check
    whether the SSH server package is installed on a Debian system, execute the following
    command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian中，SSH服务器是安装过程中的一个选项。如果选择了，SSH的服务器应用程序将存在并默认启动。要检查Debian系统上是否安装了SSH服务器包，请执行以下命令：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the output, if the first character is `i`, then the package is installed.
    You can check whether the **sshd** service is running with the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，如果第一个字符是`i`，则表示已安装该软件包。您可以使用以下命令检查**sshd**服务是否正在运行：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the service isn''t running, you can start it by executing the following
    command on Debian:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务未运行，可以通过在Debian上执行以下命令来启动它：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On Debian, you can check the status of the SSH service by executing the following
    command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian上，您可以通过执行以下命令来检查SSH服务的状态：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If it''s running, the output should include `active (running)`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在运行，则输出应包括`active (running)`：
- en: 'If your system doesn''t have the SSH server package installed, you can install
    it with the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统没有安装SSH服务器包，可以使用以下命令安装它：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After you''ve installed the package, check the status of the service with the
    following command to see if it''s enabled:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 安装软件包后，使用以下命令检查服务的状态以查看是否已启用：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Otherwise, it won't start automatically the next time you boot the machine.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，下次启动机器时它将不会自动启动。
- en: 'In CentOS, you also use the `systemctl` command in order to check the status
    of the SSH service, though the daemon is named a bit differently:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS中，您还可以使用`systemctl`命令来检查SSH服务的状态，尽管守护程序的名称有点不同：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the previous command in Debian, the service was named `ssh.service`. In
    CentOS, it''s named `sshd.service`. In CentOS, both the client and server packages
    for SSH are installed by default, so you should already have them as soon as your
    CentOS system finishes installation. If you don''t have the package installed
    for some reason, you can install it via `yum`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian中的上一个命令中，服务的名称是`ssh.service`。在CentOS中，它的名称是`sshd.service`。在CentOS中，SSH的客户端和服务器包都是默认安装的，因此在CentOS系统完成安装后，您应该已经拥有它们。如果由于某种原因未安装该软件包，可以通过`yum`安装：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After installation, ensure that the service is enabled by checking the status:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，请通过检查状态来确保服务已启用：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the SSH service is not in an enabled state (start on boot), execute the
    following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SSH服务未处于启用状态（启动时启用），请执行以下命令：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that SSH is installed on your machines, we're ready to start using it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，SSH已安装在您的机器上，我们准备开始使用它。
- en: Connecting to network hosts via openssh-client
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过openssh-client连接到网络主机
- en: For this experiment, you'll need at least one Linux installation with the SSH
    server active, and another with at least the SSH client installed. For the client,
    you'll need to either install the `openssh-clients` package in CentOS, or the
    `openssh-client` package in Debian. The client package for SSH is installed by
    default on both, so you shouldn't need to install it unless the package was removed.
    For this activity, it doesn't matter which distribution is on the server or the
    client end of the connection. Feel free to mix it up.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此实验，您至少需要一个具有活动SSH服务器的Linux安装，以及另一个至少安装了SSH客户端的安装。对于客户端，您需要在CentOS中安装`openssh-clients`软件包，或在Debian中安装`openssh-client`软件包。SSH的客户端软件包在两者上默认安装，因此除非软件包已被删除，否则您不需要安装它。对于此活动，服务器端或客户端端的连接使用哪种发行版并不重要。随意混合使用。
- en: 'Next, all we need is to record the IP addresses of the node we wish to connect
    to. Regardless of the distribution, you should be able to discover the IP address
    by executing the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要记录我们希望连接到的节点的IP地址。无论发行版如何，您都应该能够通过执行以下命令来发现IP地址：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To connect to that machine via SSH, execute the `ssh` command against the IP
    address of the host. For example, if the host you want to connect to has an IP
    address `192.168.1.201`, execute the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过SSH连接到该机器，请执行针对主机的IP地址的`ssh`命令。例如，如果要连接的主机具有IP地址`192.168.1.201`，请执行以下命令：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As long as your username is the same on both sides, that command should ask
    for your password and then let you in. If your username is different on the host
    you''re attempting to connect to, add the appropriate username to the command
    like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 只要您的用户名在两端相同，该命令应该会要求您输入密码，然后让您进入。如果您要连接的主机上的用户名与您的用户名不同，请像这样将适当的用户名添加到命令中：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With SSH, you can connect to another Linux installation using any username that
    exists there, as long as you know the password for it. In fact, depending on how
    the distribution was configured by the vendor, you may even be able to log in
    directly as root. In CentOS, root login is enabled by default. In Debian, root
    login via SSH is not allowed unless you're using an RSA key (we'll discuss this
    in [Chapter 9](ch09.html "Chapter 9. Securing Your Network"), *Securing Your Network*).
    Although we'll discuss more about security (including how to allow/disallow users)
    in that chapter, for now it's important to understand that allowing root access
    to a system via SSH is a very bad idea; I hope that you'll keep this disabled
    on production servers and workstations. If you wish to disable root access now,
    go to the relevant section of [Chapter 9](ch09.html "Chapter 9. Securing Your
    Network"), *Securing Your Network*, and then come back here.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSH，你可以使用任何在那里存在的用户名连接到另一个Linux安装，只要你知道它的密码。事实上，根据供应商如何配置发行版，你甚至可以直接以root身份登录。在CentOS中，默认情况下启用了root登录。在Debian中，除非你使用RSA密钥（我们将在[第9章](ch09.html
    "第9章。保护你的网络") *保护你的网络*中讨论这个问题），否则不允许通过SSH登录root。尽管我们将在那一章讨论更多关于安全性的内容（包括如何允许/禁止用户），但现在重要的是要理解通过SSH允许root访问系统是一个非常糟糕的主意；我希望你会在生产服务器和工作站上禁用这个功能。如果你希望现在禁用root访问，请转到[第9章](ch09.html
    "第9章。保护你的网络") *保护你的网络*的相关部分，然后再回到这里。
- en: 'SSH also allows you to specify a host name rather than an IP address. In fact,
    host names are the preferred method since it''s difficult to memorize IP addresses
    if you have a great number of machines in your network. SSH itself doesn''t resolve
    host names; it relies on DNS for that. If the DNS server on your network has an
    A (address) record for the machine you wish to connect to, you should be able
    to use the host name instead of the IP address:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: SSH还允许你指定主机名而不是IP地址。事实上，主机名是首选的方法，因为如果你的网络中有大量的机器，很难记住IP地址。SSH本身不解析主机名；它依赖DNS来完成。如果你的网络上的DNS服务器有你想要连接的机器的A（地址）记录，你应该能够使用主机名而不是IP地址：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the machine doesn't have a DNS entry in your network, or if you have yet
    to set up a DNS server, don't worry. We'll discuss setting up our very own DNS
    (bind) server in [Chapter 6](ch06.html "Chapter 6. Configuring Network Services"),
    *Configuring Network Services*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果机器在你的网络中没有DNS条目，或者你还没有设置DNS服务器，不用担心。我们将在[第6章](ch06.html "第6章。配置网络服务") *配置网络服务*中讨论设置我们自己的DNS(bind)服务器。
- en: 'Another important aspect of connecting to a host is specifying a port. As mentioned
    earlier, the default port is 22\. If you don''t specify a port, then port 22 is
    assumed. If you need to specify a different port, you can do so with the `-p`
    flag, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到主机的另一个重要方面是指定端口。如前所述，默认端口是22。如果你不指定端口，那么假定端口是22。如果你需要指定一个不同的端口，你可以使用`-p`标志，如下所示：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After a successful connection, you should have a command prompt to a shell on
    the target machine. From here, you can install packages, manage users, configure
    the network, or do anything else that you'd be able to do if you were able to
    log in to the machine in person. Your only limit is whatever permissions your
    user has to the system. If it's a machine that belongs to you, or one that you
    set up yourself and you know the root password for, you can literally do anything
    you want. If the machine belongs to someone else, you might have permission to
    modify your local home folder only. Either way, you successfully connected to
    a machine using SSH. The remaining sections of this chapter, as well as [Chapter
    9](ch09.html "Chapter 9. Securing Your Network"), *Securing Your Network*, will
    expand on this basic knowledge.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 成功连接后，你应该可以在目标机器上获得一个命令提示符。从这里，你可以安装软件包，管理用户，配置网络，或者做任何你能亲自登录到机器上做的事情。你的唯一限制是你的用户对系统的权限。如果这是你自己的机器，或者是你自己设置并知道root密码的机器，你可以做任何你想做的事情。如果这台机器属于别人，你可能只有权限修改你的本地主目录。无论如何，你成功使用SSH连接到了一台机器。本章的其余部分，以及[第9章](ch09.html
    "第9章。保护你的网络") *保护你的网络*，将扩展这些基本知识。
- en: The OpenSSH config file
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenSSH配置文件
- en: 'When utilizing SSH for the first time, the `.ssh` directory will be created
    in your home directory. This directory contains useful files for your SSH client,
    which include `known_hosts`, `id_rsa`, and `id_rsa.pub` once you generate your
    keys (which we will do later). While we will discuss those files later on in this
    chapter, there is another file that the SSH client recognizes: `config`. This
    file is not created by default. If you create it yourself (following the proper
    syntax), then SSH will recognize it. So, what does this `config` file do? If you
    have one or more hosts that you connect to frequently, you can fill this file
    with the specifics for each host without having to enter the details each time.
    Let''s look at an example `~/.ssh/config` file.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当第一次使用SSH时，`.ssh`目录将在你的主目录中创建。这个目录包含了SSH客户端的有用文件，包括`known_hosts`、`id_rsa`和`id_rsa.pub`，一旦你生成了你的密钥（我们稍后会讨论）。虽然我们稍后会在本章讨论这些文件，但SSH客户端还识别另一个文件：`config`。这个文件不是默认创建的。如果你自己创建它（遵循正确的语法），那么SSH将识别它。那么，这个`config`文件是做什么的呢？如果你有一个或多个经常连接的主机，你可以在这个文件中填写每个主机的具体信息，而不必每次都输入详细信息。让我们看一个示例`~/.ssh/config`文件。
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For this file, SSH will recognize three hosts straight away: `Icarus`, `Daedalus`,
    and `dragon`. This is regardless of whether or not these machines are listed in
    DNS. If we were to type `ssh icarus` and the previous `config` file was used,
    SSH would know not only how to get to it (the IP address is given in the file)
    but SSH would also know which user and port to use. Even if our username is not
    `jdoe`, it will be used for this connection (since it''s listed in the file)—unless
    we give the `ssh` command a different user in the command string.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个文件，SSH将立即识别三个主机：`伊卡洛斯`、`代达罗斯`和`龙`。这与这些机器是否在DNS中列出无关。如果我们输入`ssh icarus`并且之前使用了`config`文件，SSH不仅会知道如何到达它（文件中给出了IP地址），而且SSH还会知道要使用哪个用户和端口。即使我们的用户名不是`jdoe`，它也会用于这个连接（因为它在文件中列出了）—除非我们在命令字符串中为`ssh`命令提供了不同的用户。
- en: In the second entry in our sample file (`daedalus`), you'll notice that it is
    a bit different from the others. First, the port is different. For all the other
    hosts in this file, the default of 22 is used. But with `daedalus`, we issue a
    different port. If we connect to `daedalus` via SSH, it will automatically try
    the referenced port. Next, you'll also notice that the username is different for
    this host. Even if our local user was `jdoe` and we didn't supply a different
    username, user `duser` would be automatically used instead. We can override this
    by providing `user@` before the host name, if we wished to.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们示例文件的第二个条目（`daedalus`）中，你会注意到它与其他条目有些不同。首先，端口是不同的。对于文件中的所有其他主机，都使用默认的22端口。但对于`daedalus`，我们使用了不同的端口。如果我们通过SSH连接到`daedalus`，它将自动尝试引用的端口。接下来，你还会注意到这个主机的用户名也是不同的。即使我们的本地用户是`jdoe`，并且我们没有提供不同的用户名，用户`duser`也会被自动使用。如果我们希望，我们可以通过在主机名之前提供`user@`来覆盖这一点。
- en: 'Since this file doesn''t exist by default, all we need to do is create it using
    any text editor and save it to the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个文件默认不存在，我们只需要使用任何文本编辑器创建它并保存到以下位置：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As long as we typed it out correctly, SSH should see the file and allow us to
    use it. Then, we can create our own list of hosts in this file to easily provide
    the required parameters for each, and allow easier access. Go ahead and give it
    a try in your lab.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们输入正确，SSH就应该能看到文件并允许我们使用它。然后，我们可以在这个文件中创建我们自己的主机列表，以便为每个主机提供所需的参数，并且更容易地访问。在你的实验室里试一试吧。
- en: Understanding and utilizing scp
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和利用scp
- en: SSH actually has several uses; it's not just for connecting one machine to another,
    though that is the most popular use case. SSH also allows you to transfer files
    to another machine, or even transfer files from a remote machine to your local
    one. The utility that allows you to do this is the `scp` (**secure copy**) command,
    which is part of the SSH suite of utilities. Of course, you can also transfer
    files via network shares, but the beauty of `scp` is that it offers an on-the-fly
    file transfer, with no share configuration being necessary. The `scp` command
    is simple and fast. You can transfer a file from your machine to anywhere on the
    filesystem of a target machine that you have permission to access.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: SSH实际上有几种用途；它不仅仅是用于连接一台机器到另一台机器，尽管这是最常见的用例。SSH还允许你将文件传输到另一台机器，甚至从远程机器传输文件到你的本地机器。允许你这样做的实用程序是`scp`（**安全复制**）命令，它是SSH工具套件的一部分。当然，你也可以通过网络共享传输文件，但`scp`的美妙之处在于它提供了即时的文件传输，而不需要进行共享配置。`scp`命令简单而快速。你可以将文件从你的机器传输到你有权限访问的目标机器的文件系统的任何位置。
- en: The `scp` utility is primarily meant for those who need a quick transfer of
    a file, as it is not a long-term solution for file access and storage. In a situation
    where you need to create a storage repository that others need to access, you
    would typically set up an **NFS** or **Samba** share to accomplish the goal. However,
    `scp` is a great utility that will prove very useful to you, whenever you want
    to simply send a file to another machine without configuring anything.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`scp`实用程序主要是为那些需要快速传输文件的人准备的，因为它不是文件访问和存储的长期解决方案。在需要创建其他人需要访问的存储库的情况下，你通常会设置一个**NFS**或**Samba**共享来实现目标。然而，`scp`是一个很棒的实用程序，无论何时你想要简单地将文件发送到另一台机器而不需要配置任何东西，它都会对你非常有用。'
- en: Transferring files to another node via scp
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过scp将文件传输到另一个节点
- en: 'Let''s give `scp` a try. As with our previous SSH activity, you''ll need at
    least two machines: one with the SSH server installed and running, and another
    with at least the client. In this case, the distribution shouldn''t matter as
    long as you meet this simple requirements. In addition, we''ll need a file to
    test with. The file can be something small (such as a text file or image) or large
    (such as an ISO file for a Linux distribution). The goal is to transfer this file
    to another machine using `scp`. Let''s see how to do this.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试`scp`。与之前的SSH活动一样，你至少需要两台机器：一台安装并运行SSH服务器的机器，另一台至少安装了客户端的机器。在这种情况下，发行版并不重要，只要你满足这个简单的要求。此外，我们需要一个测试文件。文件可以是一些小东西（比如文本文件或图像）或大东西（比如Linux发行版的ISO文件）。目标是使用`scp`将这个文件传输到另一台机器。让我们看看如何做到这一点。
- en: For the sake of this tutorial, I'll outline the procedure for a machine named
    foo to transfer a file to a machine named bar.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本教程的目的，我将概述一个名为foo的机器向一个名为bar的机器传输文件的过程。
- en: 'First, let''s take a look at a simple example of `scp`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一个`scp`的简单例子：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In that example, we've executed the `scp` command against a file named `my-image.jpg`.
    Next, we outline the target. In this case, a machine with the IP address of `192.168.1.200`.
    Then, we type a colon and the path where we'd like the file to be stored. In this
    case, we are going to copy the file into the home directory for `jdoe`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们执行了针对名为`my-image.jpg`的文件的`scp`命令。接下来，我们概述目标。在这种情况下，是一个具有IP地址`192.168.1.200`的机器。然后，我们输入一个冒号和我们想要存储文件的路径。在这种情况下，我们将文件复制到`jdoe`的主目录中。
- en: 'Since we know the name of the target machine (`bar`), we could use the name
    of the machine instead of the IP address, assuming that it is recognized by the
    DNS server. It was configured in `~/.ssh/config`, or is an entry on foo''s `/etc/hosts`
    file. The command is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道目标机器的名称（`bar`），我们可以使用机器的名称而不是IP地址，假设它被DNS服务器识别。它在`~/.ssh/config`中配置，或者是foo的`/etc/hosts`文件中的一个条目。命令如下：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We simplified the command a bit, since we know the name of the machine. Additionally,
    we don''t have to type out the name of the directory if we''re intending to copy
    to a user''s home directory. We could have simplified the command to the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍微简化了命令，因为我们知道机器的名称。此外，如果我们打算复制到用户的主目录，我们不必输入目录的名称。我们可以将命令简化为以下形式：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the example, instead of typing out `/home/jdoe`, we replaced the path with
    a period. This works because the home directory is assumed, unless you give the
    command a separate path. We''d also get the same result if we used a tilde (`~`)
    instead:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们用一个句号代替了`/home/jdoe`的路径。这是因为默认会使用主目录，除非你给命令一个单独的路径。如果我们用波浪号(`~`)代替也会得到同样的结果：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'What if the data we wish to copy is an entire directory, instead of just a
    single file? If we try to use the `scp` command against a directory, it will fail.
    In order to copy an entire directory, we need to add the `-r` flag that performs
    a recursive copy:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望复制的数据是一个整个目录，而不仅仅是一个单个文件呢？如果我们尝试使用`scp`命令来复制一个目录，它将失败。为了复制整个目录，我们需要添加`-r`标志来执行递归复制：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, the `my_dir` directory and its contents will be transferred over. Another
    useful flag when copying files is `-p`, which preserves the modification times
    when the file is copied. If we combine that with the previous command, we get:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`my_dir`目录及其内容将被传输。在复制文件时，另一个有用的标志是`-p`，它在复制文件时保留修改时间。如果我们将其与前面的命令结合起来，我们得到：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, each of these commands will fail if the user name is different on
    the two machines. For example, if the logged-on user on foo is `dlong` and the
    user doesn''t exist on `bar`, the command would fail because the sending computer
    would default to using `dlong`, the currently logged-on user. In this case, the
    other computer would ask you for the password three times, and then give you a
    message that access is denied. This is because you would essentially be typing
    a password for a user that doesn''t exist. If we need to specify the username
    for the target, the command would become similar to the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果两台机器上的用户名不同，每个命令都会失败。例如，如果foo上的登录用户是`dlong`，而在`bar`上用户不存在，命令会失败，因为发送计算机会默认使用`dlong`，当前登录的用户。在这种情况下，另一台计算机会要求你输入密码三次，然后给出一个拒绝访问的消息。这是因为你实际上在为一个不存在的用户输入密码。如果我们需要为目标指定用户名，命令会变成类似以下的形式：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With the new version of the command, you'll be prompted for the `jdoe` password
    and then the file would be copied to `/home/jdoe` on the receiving end.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新版本的命令，你将被提示输入`jdoe`的密码，然后文件将被复制到接收端的`/home/jdoe`。
- en: 'As mentioned previously in this chapter, the default port for SSH (port 22)
    may not be open on the target, as perhaps it is listening on a different port.
    With `scp`, we can specify a different port. To do so, use the `-P` flag. Note
    that this is an uppercase `P`, unlike the `ssh` command that uses a lowercase
    `-p` for specifying the port (this can be somewhat confusing at first when switching
    between `ssh` and `scp`). For example, this flag is appended to the previous command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章前面提到的，SSH的默认端口（端口22）可能在目标上没有打开，也许它正在监听不同的端口。使用`scp`，我们可以指定一个不同的端口。为此，使用`-P`标志。请注意，这是一个大写的`P`，不像`ssh`命令使用小写的`-p`来指定端口（在切换`ssh`和`scp`时，这可能有点令人困惑）。例如，这个标志被添加到前面的命令中：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Go ahead and give it a try in your lab. Find a file of any type and attempt
    to transfer it to another Linux machine. If you do this a few times, you should
    be able to get the hang of it fairly quickly. Another point of interest in regards
    to `scp` is that you can use it to copy a file or directory from a remote machine
    to your local one, if you already know the path of the file you wish to download.
    In the last example of this section, I''m copying `myimage.jpg` from remote host
    `bar` to my current working directory (which I designate with a period):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的实验室里试一试。找到任何类型的文件，尝试将其传输到另一台Linux机器上。如果你这样做几次，你应该能够很快掌握它。关于`scp`的另一个有趣的地方是，如果你已经知道要下载的文件的路径，你可以使用它将文件或目录从远程机器复制到本地机器。在本节的最后一个例子中，我正在将`myimage.jpg`从远程主机`bar`复制到我的当前工作目录（我用一个句号来指定）：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tunneling traffic via SSH
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过SSH进行隧道流量
- en: One of the most useful features of SSH is creating an **SSH tunnel**. An SSH
    tunnel allows you to access services locally that originate from another computer
    or server. This allows you to do such things as bypass local DNS filtering, or
    even access an IRC server that is segregated within your company, from home.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: SSH最有用的功能之一是创建**SSH隧道**。SSH隧道允许你在本地访问来自另一台计算机或服务器的服务。这使你可以做一些事情，比如绕过本地DNS过滤，或者甚至从家里访问公司内部隔离的IRC服务器。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be very careful when utilizing SSH tunnels. If you aren't able to access a resource
    while at work, or a work resource is blocked from being accessible from outside
    the network, chances are the network administrator (if that person is not you)
    set it up this way for a reason. When bypassing restrictions or accessing work
    resources from outside the network, always ensure you have permission to do so.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用SSH隧道时要非常小心。如果你在工作时无法访问资源，或者工作资源被阻止在网络外部访问，很可能是网络管理员（如果不是你）出于某种原因设置了这样的方式。当绕过限制或从网络外部访问工作资源时，一定要确保你有权限这样做。
- en: In order for an SSH tunnel to be effective, you first need to be able to access
    SSH where the service you'd like to access is hosted. If you're able to initiate
    a normal SSH connection to a network containing the service, chances are that
    you'll have no problem creating a tunnel.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使SSH隧道有效，您首先需要能够访问SSH，其中您想要访问的服务托管。如果您能够启动到包含该服务的网络的普通SSH连接，那么您很可能不会在创建隧道时遇到问题。
- en: While utilizing SSH to create a tunnel, the command changes a bit. Instead of
    just executing the `ssh` command against a host name or IP address, there are
    a few more flags added. First, we add the `-L` flag. This sets up what is known
    as a bind address, which basically means we are taking a local port and forwarding
    it to a specific port on the other end.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用SSH创建隧道时，命令会有所变化。我们不仅仅是针对主机名或IP地址执行`ssh`命令，还添加了一些标志。首先，我们添加了`-L`标志。这设置了所谓的绑定地址，基本上意味着我们正在将本地端口转发到另一端的特定端口。
- en: 'The syntax for such a command string would be something like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个命令字符串的语法将是这样的：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Basically, we execute SSH with the `-L` flag and use `localhost` since we intend
    to forward a local service to a remote one. However, we sandwich the command with
    a port and a colon on either side. The port on the left-hand side is our local
    port and on the right-hand side of the IP address, we have a colon and then the
    remote port. We then finish off the command with our usual syntax, that is, we
    type our user name and then the IP address of the gateway we will use for the
    connection.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们使用`-L`标志执行SSH，并使用`localhost`，因为我们打算将本地服务转发到远程服务。但是，我们在命令中夹在一个端口和一个冒号。左侧的端口是我们的本地端口，右侧的IP地址上有一个冒号，然后是远程端口。然后我们用我们通常的语法结束命令，也就是我们输入我们的用户名，然后是我们将用于连接的网关的IP地址。
- en: Confused yet? Let's break this down further and use an example.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 还是感到困惑吗？让我们进一步分解并举例说明。
- en: 'By default, VNC (a graphical remote access program) utilizes ports 5900-5902\.
    If you wanted to access a desktop environment on a remote host with an IP address
    of `10.10.10.101`, use the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，VNC（图形远程访问程序）使用端口5900-5902。如果您想要访问具有IP地址`10.10.10.101`的远程主机上的桌面环境，请使用以下命令：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we''re forwarding port `5900` on our local machine to port `5901` on
    `10.10.10.101`. As soon as the session connects and is established, we can then
    use the following in our VNC viewing application on our local machine to connect
    to the VNC service on the remote end:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将本地机器上的端口`5900`转发到`10.10.10.101`上的端口`5901`。会话连接并建立后，我们可以在本地机器上的VNC查看应用程序中使用以下内容连接到远程端上的VNC服务：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Anytime `localhost:5900` is used, we''ll be forwarded to our remote machine.
    To end the session, exit from the SSH connection. For VNC, we need to specify
    which VNC session to use. In order to use the VNC Viewer application to open a
    VNC session to `10.10.10.101`, we would execute the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 每当使用`localhost:5900`时，我们将被转发到我们的远程机器。要结束会话，请退出SSH连接。对于VNC，我们需要指定要使用的VNC会话。为了使用VNC
    Viewer应用程序打开到`10.10.10.101`的VNC会话，我们将执行以下命令：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: However, what if the machine or service we wish to connect to is behind a different
    gateway? The previous example only works if the IP address, `10.10.10.101`, is
    routable through the Internet, or we are actually on the same network as the resource
    we wish to connect to. This is not always the case, and generally useful services
    are not exposed directly to the Internet. For example, if you're at home and you
    wish to connect to the remote desktop protocol on a computer in your work network,
    the previous example wouldn't work.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们希望连接的机器或服务位于不同的网关后面怎么办？前面的例子只有在IP地址`10.10.10.101`可以通过互联网路由，或者我们实际上在要连接的资源相同的网络上时才有效。这并不总是情况，通常有用的服务并不直接暴露在互联网上。例如，如果您在家里，希望连接到工作网络中计算机上的远程桌面协议，前面的例子就行不通了。
- en: In this example, at the office, we have a computer with a remote desktop exposed
    with an IP address `10.10.10.60`. We can't get to this machine directly from home,
    because it is not routable through the Internet. However, we just so happen to
    have a server at work that actually, is exposed to the Internet with an outside
    IP address `66.238.170.50`. We are able to SSH directly into that machine from
    home, but host `10.10.10.60` is further within that network.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，在办公室，我们有一台计算机，其远程桌面暴露了一个IP地址`10.10.10.60`。我们无法直接从家里访问这台机器，因为它不能通过互联网路由。然而，我们碰巧在工作中有一台服务器，实际上是暴露在互联网上的，具有外部IP地址`66.238.170.50`。我们能够直接从家里SSH进入那台机器，但主机`10.10.10.60`在那个网络中更进一步。
- en: 'Here, we can utilize host `66.238.170.50` to facilitate our connection to `10.10.10.60`
    inside our work network. Let''s look at a command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以利用主机`66.238.170.50`来促进我们与工作网络内`10.10.10.60`的连接。让我们看一个命令：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this example, `jdoe` has a user account on host `66.238.170.50` and wishes
    to connect to host `10.10.10.60`, which is inside her company network. In this
    example, `jdoe` is forwarding local port `3388` on `localhost` to port `3389`
    on host `10.10.10.60`, but establishing the connection through host `66.238.170.50`.
    Now, user `jdoe` is able to open a remote desktop client and use the following
    command for the connection address:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`jdoe`在主机`66.238.170.50`上有一个用户帐户，并希望连接到主机`10.10.10.60`，这是在她的公司网络内的。在这个例子中，`jdoe`正在将`localhost`上的本地端口`3388`转发到主机`10.10.10.60`上的端口`3389`，但是通过主机`66.238.170.50`建立连接。现在，用户`jdoe`可以打开远程桌面客户端，并使用以下命令进行连接：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As long as the SSH connection remains open, `jdoe` will then be able to utilize
    a remote desktop on the server from her local computer. If the shell is closed,
    then the connection will terminate.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 只要SSH连接保持打开状态，`jdoe`就能够从她的本地计算机上的服务器上使用远程桌面。如果关闭shell，则连接将终止。
- en: Using SSH tunnels can be very useful. Feel free to give it a try and see which
    services you can forward through your network.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSH隧道可能非常有用。随时尝试并查看您可以通过网络转发哪些服务。
- en: Generating public keys
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成公钥
- en: SSH also supports **public key authentication**, in addition to traditional
    passwords, which is more secure. While the encryption that SSH employs using protocol
    2 is strong, the greatest encryption in the world won't save you if your password
    is leaked or brute-forced. This is especially catastrophic on a mission-critical
    server.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: SSH还支持**公钥认证**，除了传统密码之外，这更加安全。虽然SSH使用协议2的加密很强大，但即使世界上最强大的加密也无法保护你的密码泄露或被暴力破解。这在关键任务的服务器上尤为灾难性。
- en: Utilizing public key authentication allows you to connect to a host using a
    private and public key relationship, instead of using a password. By default,
    SSH will allow a user to log in via either the username/password combination or
    a username / key pair combination. The first method is only as secure as the password.
    By utilizing public key authentication, you can bypass the need for a password
    completely, and connect to a server without being prompted. But if a server still
    accepts your password as a means of authentication, then public key authentication
    is not at its strongest point.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公钥认证允许你使用私钥和公钥的关系连接到主机，而不是使用密码。默认情况下，SSH允许用户通过用户名/密码组合或用户名/密钥对组合登录。第一种方法的安全性取决于密码。通过使用公钥认证，你可以完全绕过密码的需求，并连接到服务器而不需要提示。但是，如果服务器仍然接受你的密码作为认证手段，那么公钥认证并不是最强大的。
- en: On the server end of the SSH connection, it is possible to configure it to accept
    authentication only from a public key, rather than password. If password authentication
    is disabled, then no one would be able to brute force the password and get into
    the server, since the password would be ignored. If the attacker doesn't have
    access to the private key, then he or she would not be able to connect.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在SSH连接的服务器端，可以配置它只接受公钥认证，而不是密码。如果禁用了密码认证，那么没有人能够暴力破解密码进入服务器，因为密码会被忽略。如果攻击者没有私钥，那么他或她将无法连接。
- en: Generating a key pair is simple using the `ssh-keygen` command, which will guide
    you through the process of setting up your keys. During this process, you will
    be asked to create a passphrase. You could, if you wanted to, disregard this prompt
    and simply press *Enter* to create a key without a passphrase. Doing so, however,
    drastically lowers the security of that key. While it is certainly much more convenient
    to not have to type anything at all when connecting to a host via SSH, it's definitely
    recommended to use a passphrase and benefit from the added security.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ssh-keygen`命令生成密钥对非常简单，它会引导你完成密钥设置的过程。在这个过程中，你会被要求创建一个密码。如果你愿意的话，可以忽略这个提示，直接按*Enter*键创建一个没有密码的密钥。然而，这样做会大大降低密钥的安全性。虽然通过SSH连接到主机时不需要输入任何内容肯定更方便，但强烈建议使用密码，并从增加的安全性中受益。
- en: 'With public key authentication, two files are created in the user''s home directory:
    `id_rsa` and `id_rsa.pub`. These files are created when you run through the process
    while executing `ssh-keygen`, mentioned earlier. After the command completes,
    these two files should be located in the `.ssh` directory of your home directory.
    The `id_rsa` file is your private key. You should keep it local and not transmit
    it or share it in a public place. The `id_rsa.pub` file is your public key, which
    you can safely copy to other hosts that you connect to. From that point forward,
    you will be able to use public key authentication to connect to another host.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公钥认证时，在用户的主目录中会创建两个文件：`id_rsa`和`id_rsa.pub`。这些文件是在执行`ssh-keygen`过程中创建的。命令完成后，这两个文件应该位于你主目录的`.ssh`目录中。`id_rsa`文件是你的私钥。你应该将它保留在本地，不要传输或在公共场所共享。`id_rsa.pub`文件是你的公钥，你可以安全地复制到其他你连接的主机上。从那时起，你将能够使用公钥认证连接到另一个主机。
- en: Let's summarize the entire process. First, while logged in to your local or
    main machine, execute `ssh-keygen` and walk through the steps. Make sure to create
    a passphrase for added security.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结整个过程。首先，在本地或主机上登录后，执行`ssh-keygen`并按照步骤进行。确保创建一个密码以增加安全性。
- en: '![Generating public keys](img/B03919_03_01.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![生成公钥](img/B03919_03_01.jpg)'
- en: Creating a key pair for SSH using ssh-keygen
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ssh-keygen为SSH创建密钥对
- en: Next, utilize the `ssh-copy-id` command in order to copy your key to the remote
    server you wish to connect to. The command syntax is as follows.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`ssh-copy-id`命令将你的密钥复制到你希望连接的远程服务器上。命令语法如下。
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This command will copy your public key into the `authorized_keys` file under
    your `~/.ssh` folder on the target machine. This file stores all the keys that
    the machine knows about. If you were to check before and after running through
    the `ssh-copy-id` process, you'd notice that the `authorized_keys` file on the
    target either didn't exist, or didn't include your key until after you executed
    the command.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将把你的公钥复制到目标机器的`~/.ssh`文件夹下的`authorized_keys`文件中。这个文件存储了机器知道的所有密钥。如果你在运行`ssh-copy-id`过程之前和之后进行检查，你会注意到目标机器上的`authorized_keys`文件要么不存在，要么在执行命令之后才包含你的密钥。
- en: '![Generating public keys](img/B03919_03_02.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![生成公钥](img/B03919_03_02.jpg)'
- en: Copying a public key to a remote host using ssh-copy-id
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ssh-copy-id将公钥复制到远程主机
- en: As mentioned earlier, it is possible to configure your computer or server to
    disallow authentication via password, only allowing public key authentication
    instead. This portion will be discussed further in [Chapter 9](ch09.html "Chapter 9. Securing
    Your Network"), *Securing Your Network*. For now, it's important to get in the
    habit of generating, copying, and using keys. Feel free to create a key pair on
    your local machine and copy the public key to a server that you frequently connect
    to.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，可以配置你的计算机或服务器禁止通过密码进行认证，只允许使用公钥认证。这部分将在[第9章](ch09.html "第9章。保护您的网络")*保护您的网络*中进一步讨论。现在，重要的是养成生成、复制和使用密钥的习惯。随时可以在本地机器上创建密钥对，并将公钥复制到你经常连接的服务器上。
- en: Keeping SSH connections alive
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持SSH连接活动
- en: Depending on how your SSH server or internal firewalls are configured, your
    SSH session may automatically disconnect after some time. It's possible to configure
    SSH to send a special packet every certain number of seconds, to keep the connection
    from idling and becoming a candidate for disconnection. This is useful if you
    have a service that utilizes SSH, that you do not want to be disconnected. To
    employ this tweak, we must configure the `ServerAliveInterval` setting.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的SSH服务器或内部防火墙的配置方式，您的SSH会话可能会在一段时间后自动断开连接。可以配置SSH每隔一定时间发送一个特殊数据包，以保持连接不处于空闲状态并成为断开连接的候选。如果您有一个利用SSH的服务，您不希望它被断开连接，这将非常有用。要使用此调整，我们必须配置`ServerAliveInterval`设置。
- en: There are two ways of configuring this, one that affects your user account and
    another that will deploy the setting system wide. First, let's explore how to
    configure this for your user account.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种配置方式，一种影响您的用户帐户，另一种将系统范围的设置部署。首先，让我们看看如何为您的用户帐户配置这个。
- en: 'Remember the `~/.ssh/config` file that we configured earlier in this chapter?
    Open it up again in your text editor. Here''s a sample of this file for your convenience:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们在本章前面配置的`~/.ssh/config`文件吗？再次在文本编辑器中打开它。以下是这个文件的一个示例，以方便您参考：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As before, we have three systems. If we wish to configure a host, for example
    `icarus`, to send an alive packet once every 60 seconds, we can add the following
    setting to it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们有三个系统。如果我们希望为主机（例如`icarus`）配置一个设置，使其每60秒发送一个活动数据包，我们可以向其添加以下设置：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we wish to set the `ServerAliveInterval` setting for all hosts we connect
    to, we could add this option as a wildcard instead by adding the following to
    the top of the file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望为我们连接的所有主机设置`ServerAliveInterval`设置，我们可以将此选项作为通配符添加到文件顶部：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With this, the setting takes effect for all systems we initiate a connection
    to. Although we haven''t discussed them (yet), there are two system-wide (global)
    configuration files for SSH. We''ll discuss these files later in this book, but
    the subject of this section is an opportunity to give you a quick introduction:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，该设置将对我们发起连接的所有系统生效。虽然我们还没有讨论它们（但是），SSH有两个系统范围（全局）的配置文件。我们将在本书的后面讨论这些文件，但本节的主题是为您提供一个快速介绍：
- en: '`/etc/ssh/ssh_config`: This file will impact all users whom make outbound connections.
    Think of this as the client configuration file.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/ssh/ssh_config`：此文件将影响所有进行出站连接的用户。将其视为客户端配置文件。'
- en: '`/etc/ssh/sshd_config`: This is the global config file for the server.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/ssh/sshd_config`：这是服务器的全局配置文件。'
- en: 'Anything you configure in one of these two files will impact anyone. The `ssh_config`
    file impacts all outbound connections, and the `sshd_config` impacts all the incoming
    connections. For this section, the file we''re interested in is the `ssh_config`
    file, since we can set the `ServerAliveInterval` setting for all users by including
    it there. In fact, regardless of whether we''re configuring `/etc/ssh/ssh_config`
    or the local `~/.ssh/config` file, the option is the same. Simply add it to the
    end of the file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您在这两个文件中配置的任何内容都会影响任何人。`ssh_config`文件影响所有出站连接，而`sshd_config`影响所有入站连接。对于本节，我们感兴趣的文件是`ssh_config`文件，因为我们可以在那里设置所有用户的`ServerAliveInterval`设置。实际上，无论我们是在配置`/etc/ssh/ssh_config`还是本地的`~/.ssh/config`文件，选项都是相同的。只需将其添加到文件末尾：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Of course, we'll explore configuring these options further later on in this
    book. For now, just remember the purpose of these two files and where they're
    located.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们将在本书的后面进一步探讨配置这些选项。现在，只需记住这两个文件的目的和它们的位置。
- en: Exploring an alternative to SSH – utilizing Mosh (mobile shell)
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索SSH的替代方案-使用Mosh（移动shell）
- en: 'While starting out with SSH, you might notice one quirk right away: if your
    network connection drops, it can be difficult to regain control of what you were
    doing on the machine you were connected to. This is especially common with laptops,
    as your connection state on such a device will change depending on where you are
    or what network you''re connected to. While running commands within a terminal
    multiplexer such as tmux or screen, can keep your workflow alive even after disconnecting,
    there is an alternative to SSH that may work for you. **Mosh** (**mobile shell**)
    is an alternative to SSH that will keep your remote session alive, even if you
    disconnect from the network where the resource resides. When you reconnect to
    the network, Mosh will allow you to pick up where you left off.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用SSH时，您可能会立即注意到一个怪癖：如果您的网络连接中断，重新获得对您连接到的计算机的控制可能会很困难。这在笔记本电脑上特别常见，因为这种设备上的连接状态会根据您所在的位置或所连接的网络而改变。在终端复用器（如tmux或screen）中运行命令可以使您的工作流在断开连接后保持活动状态，但是SSH的替代方案可能适合您。**Mosh**（**移动shell**）是SSH的替代方案，即使您断开了资源所在的网络，也会保持远程会话的活动状态。当您重新连接到网络时，Mosh将允许您从上次离开的地方继续进行。
- en: 'Installing Mosh in Debian is extremely easy. Simply install the `mosh` package,
    as it is available from within the default repositories:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian中安装Mosh非常容易。只需安装`mosh`包，因为它可以从默认存储库中获得：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In CentOS, Mosh is not available from that distribution''s default repositories,
    so you''ll first need to add an additional repository in order to make it available.
    First, enable the EPEL repository with the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS中，Mosh无法从该发行版的默认存储库中获得，因此您首先需要添加一个额外的存储库才能使其可用。首先，使用以下命令启用EPEL存储库：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, you should be able to install the `mosh` package:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您应该能够安装`mosh`包：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In order for Mosh to be effective, you will need to install it not only on
    your local machine, but also any machines you wish to connect to. The syntax is
    similar to SSH:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Mosh有效，您不仅需要在本地计算机上安装它，还需要在您希望连接的任何计算机上安装它。语法与SSH类似：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Like SSH, we can supply the `-p` flag to specify a different port to use:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与SSH一样，我们可以使用`-p`标志来指定要使用的不同端口：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In fact, Mosh actually utilizes SSH to initiate the connection, and then the
    mosh program takes over from there. After you connect, you can simulate a disconnect
    by removing your network cable or disconnecting from your wireless access point.
    You will notice that the next time you connect using mosh, your session should
    be just as you left it. To see the magic in all its glory, consider starting a
    process (such as running the `top` command) before disconnecting.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Mosh实际上利用SSH来建立连接，然后mosh程序接管连接。连接后，您可以通过拔掉网络电缆或断开无线接入点来模拟断开连接。您会注意到，下次使用mosh连接时，您的会话应该和您离开时一样。要看到所有这些魔法，可以考虑在断开连接之前启动一个进程（比如运行`top`命令）。
- en: While there are many ways to keep processes running on a remote server even
    when your session is disconnected, Mosh is one of the newer and more unique solutions.
    Give it a try!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多方法可以在会话断开时保持远程服务器上的进程运行，但Mosh是较新和更独特的解决方案之一。试一试吧！
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed SSH in all its glory. We started off with a discussion
    of what SSH is and why it's useful, and then we ensured it was installed on our
    systems. Using SSH, we were able to connect to other Linux machines and execute
    commands. We also took a look at configuring hosts in the `~/.ssh/config` file
    and transferring files from one host to another using `scp`. In addition, SSH
    tunneling was discussed, as well as an introduction to public key authentication.
    We finished the chapter with a look at Mosh, which is a neat alternative to SSH.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了SSH的所有优点。我们首先讨论了SSH是什么以及它的用途，然后确保它已安装在我们的系统上。使用SSH，我们能够连接到其他Linux机器并执行命令。我们还研究了在`~/.ssh/config`文件中配置主机以及使用`scp`在一个主机和另一个主机之间传输文件。此外，我们还讨论了SSH隧道，以及公钥认证的介绍。我们最后介绍了Mosh，这是SSH的一个不错的替代品。
- en: In the next chapter, we'll tackle file sharing by setting up our very own file
    server. We'll set up file shares via Samba as well as NFS, as well as the individual
    quirks of each solution. See you there!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过建立自己的文件服务器来解决文件共享的问题。我们将通过Samba和NFS设置文件共享，以及每种解决方案的个别特点。到时见！
