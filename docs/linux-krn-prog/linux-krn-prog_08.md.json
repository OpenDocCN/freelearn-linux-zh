["```\n$ cd <booksrc>/ch6\n$ ./countem.sh\nSystem release info:\nDistributor ID: Ubuntu\nDescription:    Ubuntu 18.04.4 LTS\nRelease:        18.04\nCodename:       bionic\n\nTotal # of processes alive               =       362\nTotal # of threads alive                 =      1234\nTotal # of kernel threads alive          =       181\nThus, total # of user-mode threads alive =      1053\n$ \n```", "```\nsys_fork() --> do_fork() --> _do_fork()\n```", "```\n$ sudo cat /proc/3085/stack\n[<0>] do_wait+0x1cb/0x230\n[<0>] kernel_wait4+0x89/0x130\n[<0>] __do_sys_wait4+0x95/0xa0\n[<0>] __x64_sys_wait4+0x1e/0x20\n[<0>] do_syscall_64+0x5a/0x120\n[<0>] entry_SYSCALL_64_after_hwframe+0x44/0xa9\n$ \n```", "```\n$ gstack 12696\n#0 0x00007fa6f60754eb in waitpid () from /lib64/libc.so.6\n#1 0x0000556f26c03629 in ?? ()\n#2 0x0000556f26c04cc3 in wait_for ()\n#3 0x0000556f26bf375c in execute_command_internal ()\n#4 0x0000556f26bf39b6 in execute_command ()\n#5 0x0000556f26bdb389 in reader_loop ()\n#6 0x0000556f26bd9b69 in main ()\n$ \n```", "```\n$ sudo stackcount-bpfcc -p 29819 -r \".*malloc.*\" -v -d\nTracing 73 functions for \".*malloc.*\"... Hit Ctrl-C to end.\n^C\n ffffffff99a56811 __kmalloc_reserve.isra.43\n ffffffff99a59436 alloc_skb_with_frags\n ffffffff99a51f72 sock_alloc_send_pskb\n ffffffff99b2e986 unix_stream_sendmsg\n ffffffff99a4d43e sock_sendmsg\n ffffffff99a4d4e3 sock_write_iter\n ffffffff9947f59a do_iter_readv_writev\n ffffffff99480cf6 do_iter_write\n ffffffff99480ed8 vfs_writev\n ffffffff99480fb8 do_writev\n ffffffff99482810 sys_writev\n ffffffff99203bb3 do_syscall_64\n ffffffff99c00081 entry_SYSCALL_64_after_hwframe\n   --\n 7fd0cc31b6e7     __GI___writev\n 12bc             [unknown]\n 600000195        [unknown]\n 1\n[...]\n```", "```\n// include/linux/sched.h\nstruct task_struct {\n#ifdef CONFIG_THREAD_INFO_IN_TASK\n    /*\n     * For reasons of header soup (see current_thread_info()), this\n     * must be the first element of task_struct.\n     */\n    struct thread_info      thread_info;   << important flags and status bits >>\n#endif\n    /* -1 unrunnable, 0 runnable, >0 stopped: */\n    volatile long           state;\n    [...]\n    void                *stack; << the location of the kernel-mode stack >>\n    [...]\n    /* Current CPU: */\n    unsigned int cpu;\n    [...]\n<< the members that follow are to do with CPU scheduling; some of them are discussed in Ch 9 & 10 on CPU Scheduling >>\n    int on_rq;\n    int prio;\n    int static_prio;\n    int normal_prio;\n    unsigned int rt_priority;\n    const struct sched_class *sched_class;\n    struct sched_entity se;\n    struct sched_rt_entity rt;\n    [...]\n```", "```\n    [...]\n    struct mm_struct *mm;      << memory management info >>\n    struct mm_struct *active_mm;\n    [...]\n    pid_t pid;      << task PID and TGID values; explained below >>\n    pid_t tgid;\n    [...]\n    /* Context switch counts: */\n    unsigned long nvcsw;\n    unsigned long nivcsw;\n    [...]\n    /* Effective (overridable) subjective task credentials (COW): */\n    const struct cred __rcu *cred;\n    [...]\n    char comm[TASK_COMM_LEN];             << task name >>\n    [...]\n     /* Open file information: */\n    struct files_struct *files;      << pointer to the 'open files' ds >>\n    [...]\n     /* Signal handlers: */\n    struct signal_struct *signal;\n    struct sighand_struct *sighand;\n    sigset_t blocked;\n    sigset_t real_blocked;\n    [...]\n#ifdef CONFIG_VMAP_STACK\n    struct vm_struct *stack_vm_area;\n#endif\n    [...]\n#ifdef CONFIG_SECURITY\n    /* Used by LSM modules for access restriction: */\n    void *security;\n#endif\n    [...]\n    /* CPU-specific state of this task: */\n    struct thread_struct thread;       << task hardware context detail >>\n    [...]\n};\n```", "```\n#include <linux/sched.h>\ncurrent->pid, current->comm\n```", "```\n#include <linux/preempt.h>\n in_task()\n```", "```\n/* code: ch6/current_affairs/current_affairs.c */[ ... ]\n#include <linux/sched.h>     /* current */\n#include <linux/cred.h>      /* current_{e}{u,g}id() */\n#include <linux/uidgid.h>    /* {from,make}_kuid() */\n[...]\n#define OURMODNAME    \"current_affairs\"\n[ ... ]\n\nstatic void show_ctx(char *nm)\n{\n    /* Extract the task UID and EUID using helper methods provided */\n    unsigned int uid = from_kuid(&init_user_ns, current_uid());\n    unsigned int euid = from_kuid(&init_user_ns, current_euid());\n\n    pr_info(\"%s:%s():%d \", nm, __func__, __LINE__);\n    if (likely(in_task())) {\n                pr_info(\n                \"%s: in process context ::\\n\"\n                \" PID         : %6d\\n\"\n                \" TGID        : %6d\\n\"\n                \" UID         : %6u\\n\"\n                \" EUID        : %6u (%s root)\\n\"\n                \" name        : %s\\n\"\n                \" current (ptr to our process context's task_struct) :\\n\"\n                \"           0x%pK (0x%px)\\n\"\n \" stack start : 0x%pK (0x%px)\\n\",\n                nm, \n                /* always better to use the helper methods provided */\n                task_pid_nr(current), task_tgid_nr(current), \n                /* ... rather than the 'usual' direct lookups:\n                    current->pid, current->tgid, */\n                uid, euid,\n                (euid == 0?\"have\":\"don't have\"),\n                current->comm,\n                current, current,\n current->stack, current->stack);\n    } else\n      pr_alert(\"%s: in interrupt context [Should NOT Happen here!]\\n\", nm);\n}\n```", "```\n pr_info(\n [...]\n     \" current (ptr to our process context's task_struct) :\\n\"\n     \" 0x%pK (0x%px)\\n\"\n     \" stack start : 0x%pK (0x%px)\\n\",\n     [...]\n     current, (long unsigned)current,\n     current->stack, (long unsigned)current->stack); [...]\n```", "```\n$ sudo insmod ./current_affairs.ko\n[...]\n$ dmesg\n[...]\nname : insmod\n current (ptr to our process context's task_struct) :\n 0x0000000049ee4bd2 (0xffff9bd6770fa700)\n stack start : 0x00000000c3f1cd84 (0xffffb42280c68000)\n[...]\n```", "```\n// include/linux/sched/signal.h:\n#define for_each_process(p) \\\n    for (p = &init_task ; (p = next_task(p)) != &init_task ; )\n```", "```\n$ cd ch6/foreach/prcs_showall; ../../../lkm prcs_showall\n [...]\n [ 111.657574] prcs_showall: inserted\n [ 111.658820]      Name       |  TGID  |  PID  |  RUID  |  EUID \n [ 111.659619] systemd         |       1|      1|       0|       0\n [ 111.660330] kthreadd        |       2|      2|       0|       0\n [...]\n [ 111.778937] kworker/0:5     |    1123|   1123|       0|       0\n [ 111.779833] lkm             |    1143|   1143|    1000|    1000\n [ 111.780835] sudo            |    1536|   1536|       0|       0\n [ 111.781819] insmod          |    1537|   1537|       0|       0\n```", "```\n PID  TGID        current            stack-start     Thread Name  MT?#\n 938   938   0xffff9b09e99edb00  0xffffbaffc0b0c000  VBoxService   9\n 938   940   0xffff9b09e98496c0  0xffffbaffc0b14000     RTThrdPP\n 938   941   0xffff9b09fc30c440  0xffffbaffc0ad4000      control\n 938   942   0xffff9b09fcc596c0  0xffffbaffc0a8c000     timesync\n 938   943   0xffff9b09fcc5ad80  0xffffbaffc0b1c000       vminfo\n 938   944   0xffff9b09e99e4440  0xffffbaffc0b24000   cpuhotplug\n 938   945   0xffff9b09e99e16c0  0xffffbaffc0b2c000   memballoon\n 938   946   0xffff9b09b65fad80  0xffffbaffc0b34000      vmstats\n 938   947   0xffff9b09b6ae2d80  0xffffbaffc0b3c000    automount\n```", "```\n$ ps -LA\n    PID   LWP  TTY          TIME  CMD\n      1     1  ?        00:00:02  systemd\n      2     2  ?        00:00:00  kthreadd\n      3     3  ?        00:00:00  rcu_gp\n[...]\n    938   938  ?        00:00:00  VBoxService\n    938   940  ?        00:00:00  RTThrdPP\n    938   941  ?        00:00:00  control\n    938   942  ?        00:00:00  timesync\n    938   943  ?        00:00:03  vminfo\n    938   944  ?        00:00:00  cpuhotplug\n    938   945  ?        00:00:00  memballoon\n    938   946  ?        00:00:00  vmstats\n    938   947  ?        00:00:00  automount\n [...]\n```", "```\n// ch6/foreach/thrd_showall/thrd_showall.c */\n[...]\n#include <linux/sched.h>     /* current */\n#include <linux/version.h>\n#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 10, 0)\n#include <linux/sched/signal.h>\n#endif\n[...]\n\nstatic int showthrds(void)\n{\n    struct task_struct *g, *t;      // 'g' : process ptr; 't': thread ptr\n    [...]\n#if 0\n    /* the tasklist_lock reader-writer spinlock for the task list 'should'\n     * be used here, but, it's not exported, hence unavailable to our \n     * kernel module */\n    read_lock(&tasklist_lock);\n#endif\n    disp_idle_thread();\n```", "```\n    do_each_thread(g, t) {\n        task_lock(t);\n        snprintf(buf, BUFMAX-1, \"%6d %6d \", g->tgid, t->pid);\n\n        /* task_struct addr and kernel-mode stack addr */\n        snprintf(tmp, TMPMAX-1, \" 0x%px\", t);\n        strncat(buf, tmp, TMPMAX);\n        snprintf(tmp, TMPMAX-1, \" 0x%px\", t->stack);\n        strncat(buf, tmp, TMPMAX);\n\n        [...] *<< see notes below >>*\n\n        total++;\n        memset(buf, 0, sizeof(buf));       *<< cleanup >>*\n        memset(tmp, 0, sizeof(tmp));\n        task_unlock(t);\n     } while_each_thread(g, t); #if 0\n   /* <same as above, reg the reader-writer spinlock for the task list> */\n   read_unlock(&tasklist_lock);\n#endif\n    return total;\n}\n```", "```\n        if (!g->mm) {    // kernel thread\n        /* One might question why we don't use the get_task_comm() to\n         * obtain the task's name here; the short reason: it causes a\n         * deadlock! We shall explore this (and how to avoid it) in\n         * some detail in the chapters on Synchronization. For now, we\n         * just do it the simple way ...\n         */\n            snprintf(tmp, TMPMAX-1, \" [%16s]\", t->comm);\n        } else {\n            snprintf(tmp, TMPMAX-1, \"  %16s \", t->comm);\n        }\n        strncat(buf, tmp, TMPMAX);\n\n        /* Is this the \"main\" thread of a multithreaded process?\n         * We check by seeing if (a) it's a user space thread,\n         * (b) its TGID == its PID, and (c), there are >1 threads in\n         * the process.\n         * If so, display the number of threads in the overall process\n         * to the right..\n         */\n        nr_thrds = get_nr_threads(g);\n        if (g->mm && (g->tgid == t->pid) && (nr_thrds > 1)) {\n            snprintf(tmp, TMPMAX-1, \" %3d\", nr_thrds);\n            strncat(buf, tmp, TMPMAX);\n        }\n```"]