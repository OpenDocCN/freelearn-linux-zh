- en: Scheduling and Logging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度和日志记录
- en: In this chapter, we'll teach you the basics of scheduling and logging the results
    of your scripts. We'll begin by explaining how both `at` and `cron` can be used
    to schedule commands and scripts. In the second part of the chapter, we will describe
    how we can log the results of our scripts. We can use both the local mail functionality
    of Linux and redirection to achieve this purpose.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将教您调度和记录脚本结果的基础知识。我们将首先解释如何使用`at`和`cron`来调度命令和脚本。在本章的第二部分，我们将描述如何记录脚本的结果。我们可以使用Linux的本地邮件功能和重定向来实现此目的。
- en: 'The following commands will be introduced in this chapter: `at`, `wall`, `atq`,
    `atrm`, `sendmail`, `crontab`, and `alias`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下命令：`at`、`wall`、`atq`、`atrm`、`sendmail`、`crontab`和`alias`。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Scheduling with `at` and `cron`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`at`和`cron`进行调度
- en: Logging script results
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录脚本结果
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All scripts for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter14](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter14).
    The rest of the examples and exercises should be performed on your Ubuntu virtual
    machine.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有脚本都可以在GitHub上找到：[https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter14](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter14)。其余的示例和练习应该在您的Ubuntu虚拟机上执行。
- en: Scheduling with at and cron
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用at和cron进行调度
- en: 'We''ve learned about many things in the world of shell scripting so far: variables,
    conditionals, loops, redirections, and even functions. In this chapter, we''ll
    explain another important concept that is closely related to shell scripting:
    scheduling.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了shell脚本世界中的许多内容：变量、条件、循环、重定向，甚至函数。在本章中，我们将解释另一个与shell脚本密切相关的重要概念：调度。
- en: Simply put, scheduling is making sure your commands or scripts run at certain
    times, without the need for you to personally start them every time. A classic
    example can be found in cleaning up logs; often, older logs are no longer useful
    and take up too much space. For example, you could fix this with a cleanup script
    that removes logs older than 45 days. However, such a script should probably be
    run once a day. On a workday, this shouldn't pose the biggest problem, but having
    to log in during the weekend is no fun. Actually, we should not even consider
    this, since scheduling allows us to define *when* or *how often* a script should
    run!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，调度是确保您的命令或脚本在特定时间运行，而无需您每次都亲自启动它们。经典示例可以在清理日志中找到；通常，旧日志不再有用并且占用太多空间。例如，您可以使用清理脚本解决此问题，该脚本会删除45天前的日志。但是，这样的脚本可能应该每天运行一次。在工作日，这可能不是最大的问题，但在周末登录并不好玩。实际上，我们甚至不应该考虑这一点，因为调度允许我们定义脚本应该在*何时*或*多久*运行！
- en: In Linux scheduling, the most commonly used tools are `at` and `cron`. We'll
    first describe the principles of scheduling using `at`, before we continue with
    the much more powerful (and because of that, more widely used) `cron`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux调度中，最常用的工具是`at`和`cron`。我们将首先描述使用`at`进行调度的原则，然后再继续使用更强大（因此更广泛使用）的`cron`。
- en: at
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: at
- en: 'The `at` command is used mostly for ad hoc scheduling. The syntax for `at`
    is very close to our natural language. This is easiest explained with an example,
    as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`at`命令主要用于临时调度。`at`的语法非常接近我们的自然语言。通过以下示例最容易解释：'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In essence, you're telling the system: *at <timestamp>, do something*. When
    you enter the `at 11:51` command, you will be placed in an interactive prompt
    that will allow you to enter the commands you want executed. After that, you exit
    the prompt with *Ctrl* + *D*; if you use *Ctrl* + *C*, the job will not be saved!
    For reference, we use a simple command here, `wall`, which allows you to broadcast
    a message to everyone that is logged in to the server at that time.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，您在告诉系统：*在<时间戳>，执行某些操作*。当您输入`at 11:51`命令时，您将进入一个交互式提示符，允许您输入要执行的命令。之后，您可以使用*Ctrl*
    + *D*退出提示符；如果您使用*Ctrl* + *C*，作业将不会被保存！作为参考，在这里我们使用一个简单的命令`wall`，它允许您向当时登录到服务器的所有人广播消息。
- en: Time syntax
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间语法
- en: 'When you use `at`, you can specify the time absolutely, like we did in the
    previous example, or relatively. An example of relative would be *in 5 minutes*
    or *after 24 hours*. This is often easier than checking the current time, adding
    your desired interval to it, and passing it to `at`. This works with the following
    syntax:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`at`时，可以绝对指定时间，就像我们在上一个示例中所做的那样，也可以相对指定。相对指定的示例可能是*5分钟后*或*24小时后*。这通常比检查当前时间，将所需的间隔添加到其中，并将其传递给`at`更容易。这可以使用以下语法：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You always need to specify relative to which time you want to add the minute,
    hour, or day. Fortunately, we can use now as a keyword for the current time. Do
    note that when dealing with minutes, `at` will always round to the nearest full
    minute. Besides minutes, the following are also valid (as found in `man at`):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您总是需要指定相对于哪个时间要添加分钟、小时或天。幸运的是，我们可以使用now作为当前时间的关键字。请注意，处理分钟时，`at`将始终四舍五入到最近的整分钟。除分钟外，以下内容也是有效的（如`man
    at`中所述）：
- en: Hours
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小时
- en: Days
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天
- en: Weeks
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 周
- en: You can even create more complex solutions, such as *4 pm three days from now*.
    However, we feel like `cron` is better suited for these kinds of situations. With
    regards to `at`, the best use seems to be one-off jobs at a time that is *near*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以创建更复杂的解决方案，例如*3天后的下午4点*。但是，我们认为`cron`更适合这类情况。就`at`而言，最佳用途似乎是在*接近*的时间运行一次性作业。
- en: The at queue
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: at队列
- en: 'As soon as you start scheduling jobs, you''ll find yourself in a situation
    where you either messed up the time or the content for a job. For some jobs, you
    can just add a new one and let the other fail. However, there are certainly instances
    where the original job will wreak havoc on your system. In this case, it would
    be a great idea to delete the incorrect job. Luckily, the creators of `at` foresaw
    this problem (and probably experienced it too!) and created this functionality.
    The `atq` command (short for **at** **queue**), shows you the jobs currently in
    the pipeline. With `atrm` (don''t think we need to explain that one), you can
    remove jobs by number. Let''s look at an example of multiple jobs in the queue,
    and removing one:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您开始安排作业，您就会发现自己处于这样一种情况：您要么搞砸了时间，要么搞砸了作业内容。对于某些作业，您可以添加一个新的作业，让其他作业失败。但是，肯定有一些情况下，原始作业将对您的系统造成严重破坏。在这种情况下，删除错误的作业将是一个好主意。幸运的是，`at`的创建者预见到了这个问题（可能也经历过！）并创建了这个功能。`atq`命令（**at**
    **queue**的缩写）显示当前在队列中的作业。使用`atrm`（我们想不需要解释这个），您可以按编号删除作业。让我们看一个队列中有多个作业的示例，并删除其中一个：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, we''ve used a new flag for `at`: `-f`. This allows us to run
    commands defined in a file, instead of having to use the interactive shell. This
    file, which we ended with .txt (for clarity, no extension is needed), contains
    the commands to be executed. We use this file to schedule three jobs: after 5
    minutes, after 10 minutes, and after 4 minutes. After doing that, we use `atq`
    to see the current queue: all three jobs, numbered 12, 13, and 14\. At this point
    in time, we realize we only want the jobs to run after 4 and 5 minutes, and not
    after 10\. We can now use `atrm` to remove job number 13 by simply adding that
    number to the command. When we look at the queue again right afterward, we see
    that only jobs 12 and 14 remain. After a few minutes, the first two Hello! messages
    are printed onto our screen. If we wait the full 10 minutes, we will see... nothing,
    as we''ve successfully deleted our job:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们为`at`使用了一个新的标志：`-f`。这允许我们运行在文件中定义的命令，而不必使用交互式shell。这个文件以.txt结尾（为了清晰起见，不需要扩展名），其中包含要执行的命令。我们使用这个文件来安排三个作业：5分钟后，10分钟后和4分钟后。在这样做之后，我们使用`atq`来查看当前队列：所有三个作业，编号为12、13和14。此时，我们意识到我们只想让作业在4和5分钟后运行，而不是在10分钟后运行。现在我们可以使用`atrm`通过简单地将该数字添加到命令中来删除作业编号13。然后我们再次查看队列时，只剩下作业12和14。几分钟后，前两个Hello！消息被打印到我们的屏幕上。如果我们等待完整的10分钟，我们将看到...什么也没有，因为我们已成功删除了我们的作业：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Instead of using `atq` and `atrm`, `at` also has flags we can use for those
    functions. For `atq`, this is `at -l` (*list*). `atrm` even has two possible alternatives:
    `at -d` (*delete*) and `at -r` (*remove*). It does not matter whether you use
    the supporting commands or the flags; under the hood, the same thing will be executed.
    Use whatever is easiest to remember for you!'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用`atq`和`atrm`，`at`也有我们可以用于这些功能的标志。对于`atq`，这是`at -l`（*list*）。`atrm`甚至有两个可能的替代方案：`at
    -d`（*delete*）和`at -r`（*remove*）。无论您使用支持命令还是标志，底层都将执行相同的操作。使用对您来说最容易记住的方式！
- en: at output
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: at输出
- en: 'As you might have noticed, up until now we''ve only used commands that did
    not rely on stdout (a little sneaky, we know). However, once you think about it,
    this poses a real problem. Normally, when we deal with commands and scripts, we
    use stdout/stderr to get a feeling about the result of our actions. The same goes
    for interactive prompts: we use our keyboards to supply input via stdin. Now that
    we''re scheduling *non-interactive jobs*, things will be different. For starters,
    we cannot use interactive constructs such as `read` anymore. Scripts will simply
    fail because there is no stdin available. But, again, there is no stdout available
    either, so we do not even see the scripts fail! Or is there?'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，到目前为止，我们只使用了不依赖于stdout的命令（有点狡猾，我们知道）。但是，一旦您考虑到这一点，这就会带来一个真正的问题。通常，当我们处理命令和脚本时，我们使用stdout/stderr来了解我们的操作结果。交互提示也是如此：我们使用键盘通过stdin提供输入。现在我们正在安排*非交互作业*，情况将会有所不同。首先，我们不能再使用诸如`read`之类的交互式结构。脚本将因为没有可用的stdin而简单地失败。但是，同样地，也没有可用的stdout，因此我们甚至看不到脚本失败！还是有吗？
- en: 'Somewhere in the manpage of `at`, you can find the following text:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`at`的manpage中的某个地方，您可以找到以下文本：
- en: '"The user will be mailed standard error and standard output from his commands,
    if any. Mail will be sent using the command /usr/sbin/sendmail. If at is executed
    from a su(1) shell, the owner of the  login  shell  will  receive  the mail."'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: “用户将收到他的命令的标准错误和标准输出的邮件（如果有的话）。邮件将使用命令/usr/sbin/sendmail发送。如果at是从su(1) shell执行的，则登录shell的所有者将收到邮件。”
- en: It would seem that the creators of `at` thought of this problem as well. However,
    if you do not have a lot of experience with Linux (yet!), you're probably confused
    about the mail portion of the preceding text. If you're thinking about the kind
    that has stamps, you're pretty far off. However, if you think *email*, you're
    a bit warmer.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎`at`的创建者也考虑到了这个问题。但是，如果您对Linux没有太多经验（但！），您可能会对前文中的邮件部分感到困惑。如果您在想邮票的那种，您就离谱了。但是，如果您想到*电子邮件*，您就接近了一些。
- en: 'Without going into too much detail (which is definitely outside the scope of
    this book), Linux has a local *mail spool,* which allows you to send emails within
    your local system. If you configure this with an upstream server, you can actually
    send an actual email as well, but for now, remember that an internal email on
    a Linux system is available. With this mail spool, emails are (perhaps unsurprisingly)
    files on the filesystem. These can be found at /var/spool/mail, which is actually
    a symbolic link to /var/mail. If you followed along with the installation of an
    Ubuntu 18.04 machine, these directories will be empty. This is easily explained:
    by default, `sendmail` is not installed. When it is not installed, and you schedule
    a job that has stdout, this happens:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不详细介绍（这显然超出了本书的范围），Linux有一个本地的*邮件存储箱*，允许您在本地系统内发送电子邮件。如果您将其配置为上游服务器，实际上也可以发送实际的电子邮件，但现在，请记住Linux系统上的内部电子邮件是可用的。有了这个邮件存储箱，电子邮件（也许不足为奇）是文件系统上的文件。这些文件可以在/var/spool/mail找到，这实际上是/var/mail的符号链接。如果您跟随安装Ubuntu
    18.04机器的过程，这些目录将是空的。这很容易解释：默认情况下，`sendmail`未安装。当它未安装时，您安排一个具有stdout的作业时，会发生这种情况：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Yep, exactly nothing happens. Now, if we install `sendmail` and try this again,
    we should see a different result:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，确实什么都不会发生。现在，如果我们安装`sendmail`并再次尝试，我们应该会看到不同的结果：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Mail, just for you! If we inspect /var/mail/, we''ll see just a single file
    that contains our output:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 邮件，只给你！如果我们检查/var/mail/，我们将看到只有一个包含我们输出的文件：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It even looks like a real email, with a Date:, a Subject:, a To:, and From:
    (and so on). If we schedule more jobs, we''ll see new mails appended to this single
    file. Linux has some simple, text-based mail clients that allow you to treat this
    single file as multiple emails, (one example of this is `mutt`); however, we do
    not need these for our purposes.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至看起来像一个真正的电子邮件，有一个日期：、主题：、收件人：和发件人：（等等）。如果我们安排更多的作业，我们将看到新的邮件附加到这个单个文件中。Linux有一些简单的基于文本的邮件客户端，允许您将这个单个文件视为多个电子邮件（`mutt`就是一个例子）；但是，我们不需要这些来实现我们的目的。
- en: One thing of note when dealing with notifications from the system, such as the
    You have new mail one, is that it does not always get pushed to your Terminal
    (while some others, such as `wall`, do). These messages are printed the next time
    your Terminal is updated; this is often done when you enter a new command, (or
    just an empty *Enter*). If you're working on these examples and waiting for the
    output, don't hesitate to press *Enter* a few times and see whether something
    comes up!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理系统通知时需要注意的一件事，比如您有新邮件时，它并不总是会推送到您的终端（而其他一些通知，比如`wall`，会）。这些消息会在下次更新终端时打印出来；这通常在您输入新命令时（或者只是一个空的*Enter*）时完成。如果您正在处理这些示例并等待输出，请随时按*Enter*几次，看看是否会有什么出现！
- en: While it is sometimes great to get the output of commands we're running as jobs,
    more often than not it can be very annoying, since many processes can send you
    local mail. Often, this will result in a situation where you do not look at the
    mail, or even actively suppress output for commands, so you do not receive more
    mails. Further on in this chapter, after we introduce `cron`, we'll spend some
    time describing how we can deal with output *the right way*. As a small preview,
    this means we won't rely on inbuilt capabilities like this, but we'll use redirection
    to **write the output we need to a place where we know to find it.**
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管获取我们作业的输出有时很棒，但往往会非常烦人，因为许多进程可能会发送本地邮件给您。通常情况下，这将导致您不查看邮件，甚至主动抑制命令的输出，以便您不再收到更多的邮件。在本章后面，介绍了`cron`之后，我们将花一些时间描述如何*正确处理输出*。作为一个小预览，这意味着我们不会依赖这种内置的能力，而是会使用重定向**将我们需要的输出写入我们知道的地方。**
- en: cron
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cron
- en: 'Now that the basics of scheduling via `at` have been discussed, let''s take
    a look at the real powerhouse for scheduling on Linux: `cron`. Aptly named from
    the Greek word *chronos*, which translates to *time*, `cron` is a job scheduler,
    which consists of two main components: the *cron daemon* (sometimes referred to
    as *crond*), and the *crontab*. The cron daemon is the background process that
    runs the scheduled jobs. These jobs are scheduled using the crontab, which is
    simply a file on the filesystem that is most often edited with a command by the
    same name: `crontab`. We''ll start by looking at the `crontab` command and syntax.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过`at`进行调度的基础知识已经讨论过了，让我们来看看Linux上真正强大的调度工具：`cron`。`cron`的名称源自希腊词*chronos*，意思是*时间*，它是一个作业调度程序，由两个主要组件组成：*cron守护进程*（有时称为*crond*）和*crontab*。cron守护进程是运行预定作业的后台进程。这些作业是使用crontab进行预定的，它只是文件系统上的一个文件，通常使用同名命令`crontab`进行编辑。我们将首先看一下`crontab`命令和语法。
- en: crontab
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: crontab
- en: Every user on a Linux system can have their own crontab. There is also a system-wide
    crontab (not to be confused with the crontab that can run under the root user!),
    which is used for periodic tasks; we'll get to those later in this chapter. For
    now, we'll start by exploring the crontab syntax, and create our first crontab
    for our reader user.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Linux系统上的每个用户都可以有自己的crontab。还有一个系统范围的crontab（不要与可以在root用户下运行的crontab混淆！），用于周期性任务；我们稍后会在本章中介绍这些。现在，我们将首先探索crontab的语法，并为我们的读者用户创建我们的第一个crontab。
- en: Syntax for the crontab
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: crontab的语法
- en: 'While the syntax may initially seem confusing, it is actually not that hard
    to understand but extremely flexible:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然语法可能一开始看起来令人困惑，但实际上并不难理解，而且非常灵活：
- en: <timestamp> command
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <时间戳>命令
- en: 'Wow, that was easy! If this were really the case, then yes. However, what we
    described above as <timestamp> is actually composed of five different fields,
    which make up the combined period for running jobs multiple times. In reality,
    the timestamp is defined as follows (in order):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这太容易了！如果真是这样的话，那是的。然而，我们上面描述的<时间戳>实际上由五个不同的字段组成，这些字段组成了运行作业多次的组合周期。实际上，时间戳的定义如下（按顺序）：
- en: Minute-of-the-hour
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一小时中的分钟
- en: Hour-of-the-day
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一天中的小时
- en: Day-of-the-month
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个月中的日期
- en: Month
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 月份
- en: Day-of-the-week
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 星期几
- en: 'In any of these values, we can substitute a number for a wildcard, which indicates
    *all values*. Look at the following table to get a feeling about how we combine
    these five fields for precise times:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何这些值中，我们可以用一个通配符替换一个数字，这表示*所有值*。看一下下表，了解一下我们如何组合这五个字段来精确表示时间：
- en: '| ** Crontab     syntax** | ** Semantic meaning** |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| ** Crontab     语法** | ** 语义含义** |'
- en: '|  15 16 * * * |  Every day at 16:15. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|  15 16 * * * |  每天16:15。|'
- en: '|  30 * * * * |  Once every hour, at xx:30 (because every hour is valid due
    to the wildcard). |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|  30 * * * * |  每小时一次，xx:30（因为每小时都有效，所以通配符）。|'
- en: '|  * 20 * * * |  60 times per day, between 20:00 and 20:59 (hour is fixed,
    minutes have a wildcard). |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  * 20 * * * |  每天60次，从20:00到20:59（小时固定，分钟有通配符）。|'
- en: '|  10 10 1 * * |  Once on the first of every month, at 10:10. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|  10 10 1 * * |  每个月1日的10:10。|'
- en: '|  00 21 * * 1 |  Once per week, 21:00 on Monday (1-7 is Monday through Sunday,
    Sunday is also 0). |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|  00 21 * * 1 |  每周一次，周一21:00（1-7代表周一到周日，周日也是0）。|'
- en: '|  59 23 31 12 * |  Right before the new year, 23:59 on December 31st. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|  59 23 31 12 * |  新年前夜，12月31日23:59。|'
- en: '|  01 00 1 1 3 |  On 00:01 on January 1st, but only if that takes place on
    a Wednesday (which will happen in 2020). |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|  01 00 1 1 3 |  在1月1日00:01，但仅当那天是星期三时（这将在2020年发生）。|'
- en: 'You might be a little confused by this syntax. Since many of us normally write
    time as 18:30, reversing the minutes and the hour seems a little counter intuitive.
    However, this is just the way it is (and trust us, you will get used to the crontab
    format soon enough). Now, there are a few advanced tricks that work with this
    syntax as well:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对这种语法感到有些困惑。因为我们许多人通常写时间为18:30，颠倒分钟和小时似乎有点不合常理。然而，这就是事实（相信我们，你很快就会习惯crontab格式）。现在，这种语法还有一些高级技巧：
- en: 8-16 (hyphens allows multiple values, so `00 8-16 * * *` would mean every full
    hour from 08:00 to 16:00).
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8-16（连字符允许多个值，因此`00 8-16 * * *`表示从08:00到16:00的每个整点）。
- en: '*/5 allows every 5 *units* (most often used in the first location, for every
    5 minutes). The value */6 for hours is useful as well, for four times a day.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/5允许每5个*单位*（最常用于第一个位置，每5分钟一次）。小时的值*/6也很有用，每天四次。'
- en: 00,30 for two values, such as every 30 minutes on the hour or half hour (which
    could also be written as */30).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 00,30表示两个值，比如每小时的30分钟或半小时（也可以写成*/30）。
- en: 'Before we get too bogged down in the theory, let''s create a simple first crontab
    for our user using the `crontab` command. The `crontab` command has three interesting
    flags you''ll use most often:`-l` for list, `-e` for edit, and `-r` for remove.
    Let''s create (and remove) our very first crontab using these three commands:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入理论之前，让我们使用`crontab`命令为我们的用户创建一个简单的第一个crontab。`crontab`命令有三个最常用的有趣标志：`-l`用于列出，`-e`用于编辑，`-r`用于删除。让我们使用这三个命令创建（和删除）我们的第一个crontab：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, we start by listing the current crontab using the `crontab
    -l` command. Since we do not have one, we see the message no crontab for reader
    (no surprises there). Next, when we use `crontab -e` to start editing the crontab,
    we''ll get a choice: which editor do we want to use? As always, do whatever works
    best for you. We have enough experience with `vim` to prefer it over `nano`. We
    only have to do that once for each user, because Linux will save our preference
    (check out the ~/.selected_editor file). Then, finally, we''re presented with
    a text editor screen, which, on our Ubuntu machine, is filled with a little tutorial
    on crontabs. Since all these lines start with a #, all are considered comments
    and do not interfere with execution. Usually, we delete everything *except the
    syntax hint*: m h dom mon dow command. You can expect to forget this syntax a
    few times, which is why that little hint helps a lot when you need to do a quick
    edit, especially if it has been a while since you''ve interacted with a crontab.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们首先列出当前的crontab使用`crontab -l`命令。由于我们没有，我们看到消息没有读者的crontab（没有什么意外的）。接下来，当我们使用`crontab
    -e`开始编辑crontab时，我们会得到一个选择：我们想使用哪个编辑器？像往常一样，选择最适合你的。我们有足够的经验使用`vim`，所以我们更喜欢它而不是`nano`。我们只需要为每个用户做一次，因为Linux会保存我们的偏好（查看~/.selected_editor文件）。最后，我们会看到一个文本编辑器屏幕，在我们的Ubuntu机器上，上面填满了有关crontab的小教程。由于所有这些行都以#开头，都被视为注释，不会影响执行。通常情况下，我们会删除除了语法提示之外的所有内容：m
    h dom mon dow command。你可能会忘记这个语法几次，这就是为什么这个小提示在你需要快速编辑时非常有帮助的原因，尤其是如果你有一段时间没有与crontab交互了。
- en: 'We create a crontab with the simplest time syntax of all: wildcards in all
    five positions. Simply said, that means the command specified after is run *every
    minute*. After we save and exit, we wait a maximum of one minute before we see
    the result of the `wall "Crontab rules!";` command a broadcast from our own user,
    visible to all users on the system. Because this construction spams up the system
    pretty badly, we remove the crontab after a single broadcast by using `crontab
    -r`. Alternatively, we could have also removed just that line or commented it
    out.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用最简单的时间语法创建一个crontab：在所有五个位置上都使用通配符。简单地说，这意味着指定的命令每分钟运行一次。保存并退出后，我们最多等待一分钟，然后我们就会看到`wall
    "Crontab rules!";`命令的结果，这是我们自己用户的广播，对系统上的所有用户可见。因为这种构造会严重干扰系统，我们使用`crontab -r`在单次广播后删除crontab。或者，我们也可以删除那一行或将其注释掉。
- en: A crontab can have many entries. Each entry has to be placed on its own line,
    with its own time syntax. This allows for a user to have many different jobs scheduled,
    at different frequencies. Because of this, `crontab -r` is not often used, and
    by itself is pretty destructive. We would advise you to always use `crontab -e`
    to ensure you do not accidentally delete your whole job schedule, but just the
    bits that you want.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个crontab可以有很多条目。每个条目都必须放在自己的一行上，有自己的时间语法。这允许用户安排许多不同的作业，以不同的频率。因此，`crontab
    -r`并不经常使用，而且本身相当破坏性。我们建议您始终使用`crontab -e`来确保您不会意外删除整个作业计划，而只是您想要删除的部分。
- en: 'As stated, all crontabs are saved as files in the filesystem. You can find
    them in the /var/spool/cron/crontabs/ directory. This directory is accessible
    to the root user only; it would have some big privacy concerns if all users could
    see each other''s job schedules. If you use `sudo` to become root, however, you
    would see the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，所有的crontab都保存在文件系统中的文件中。你可以在/var/spool/cron/crontabs/目录中找到它们。这个目录只有root用户才能访问；如果所有用户都能看到彼此的作业计划，那将会有一些很大的隐私问题。然而，如果你使用`sudo`成为root用户，你会看到以下内容：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we were to open this file (`vim`, `less`, `cat`, whatever you prefer), we''d
    see the same as a `crontab -e` for the reader user would show us. As a general
    rule, though, always use the available tools to edit files like these! The primary
    added benefit of this is that these tools do not allow you to save an incorrect
    format. If we were to edit the crontab file by hand and get the time syntax wrong,
    the entire crontab will no longer work. If you do the same with `crontab -e`,
    you will see an error and the crontab will not be saved, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开这个文件（`vim`、`less`、`cat`，无论你喜欢哪个），我们会看到与读者用户的`crontab -e`显示的内容相同。然而，作为一个一般规则，总是使用可用的工具来编辑这样的文件！这样做的主要附加好处是，这些工具不允许你保存不正确的格式。如果我们手动编辑crontab文件并弄错了时间语法，整个crontab将不再工作。如果你用`crontab
    -e`做同样的事情，你会看到一个错误，crontab将不会被保存，如下所示：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding example, we entered the line `* * * * true`. As can be seen
    from the error, where cron expects a digit or wildcard, it finds the command `true`
    (which, as you might recall, is a command which simply returns an exit code of
    0). It presents the user with an error, and refuses to save the new edit, which
    means all previous scheduled jobs are safe and will continue to run, even though
    we messed it up this time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们输入了一行`* * * * true`。从错误中可以看出，cron期望一个数字或通配符，但它找到了命令`true`（你可能还记得，这是一个简单返回退出码0的命令）。它向用户显示错误，并拒绝保存新的编辑，这意味着所有以前的计划任务都是安全的，将继续运行，即使我们这次搞砸了。
- en: 'The time syntax for crontab allows pretty much any combination you could think
    of. However, sometimes you do not really care about an exact time, but are more
    interested in making sure something runs *hourly*, *daily*, *weekly,* or even
    *monthly*. Cron has some special time syntaxes for this: instead of the five values
    you normally insert, you can tell the crontab `@hourly`, `@daily`, `@weekly`, and
    `@monthly`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: crontab的时间语法允许几乎任何你能想到的组合。然而，有时你并不真的关心一个确切的时间，而更感兴趣的是确保某些东西每小时、每天、每周，甚至每月运行。Cron为此提供了一些特殊的时间语法：而不是通常插入的五个值，你可以告诉crontab`@hourly`、`@daily`、`@weekly`和`@monthly`。
- en: Logging script results
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录脚本结果
- en: 'Running scripts on a schedule is a great way to automate repetitive tasks.
    There is one big consideration when doing this though: logging. Normally, when
    you run a command, the output will be visible to you directly. If something seems
    wrong, you are there behind the keyboard to investigate the issue. However, once
    we start using `cron` (and even `at`), we no longer see the direct output of the
    commands. We can only check the results once we log in, and, if we do not make
    arrangements, we can only look for the *result of the script* (for example, cleaned
    up log files). What we need is logging for our script, so we have a simple way
    to periodically verify whether our script is running successfully.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 按计划运行脚本是自动化重复任务的一种很好的方式。然而，在这样做时有一个很大的考虑因素：日志记录。通常，当你运行一个命令时，输出会直接显示给你。如果有什么问题，你就在键盘后面调查问题。然而，一旦我们开始使用`cron`（甚至`at`），我们就再也看不到命令的直接输出了。我们只能在登录后检查结果，如果我们没有做安排，我们只能寻找*脚本的结果*（例如，清理后的日志文件）。我们需要的是脚本的日志记录，这样我们就有一个简单的方法定期验证我们的脚本是否成功运行。
- en: Crontab environment variables
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Crontab环境变量
- en: 'In our crontab, we can define environment variables, which will be used by
    our commands and scripts. This function of the crontab is used quite frequently,
    but mostly only for three environment variables: PATH, SHELL, and MAILTO. We''ll
    look at the use case/necessity for these variables.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的crontab中，我们可以定义环境变量，这些变量将被我们的命令和脚本使用。crontab的这个功能经常被使用，但大多数情况下只用于三个环境变量：PATH、SHELL和MAILTO。我们将看看这些变量的用例/必要性。
- en: PATH
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路径
- en: 'Normally, when you login to a Linux system, you are given a *login shell*.
    A login shell is a fully interactive shell that does some cool stuff for you:
    it sets the PS1 variable (which determines how your prompt looks), correctly sets
    your PATH, and so on. Now, as you might imagine, there is also something other
    than a login shell. Technically, there are two dimensions that make up four different
    kinds of shells:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你登录到Linux系统时，你会得到一个*登录shell*。登录shell是一个完全交互的shell，为你做了一些很酷的事情：它设置了PS1变量（决定了你的提示符的外观），正确设置了你的PATH等等。现在，你可能会想象，除了登录shell还有其他东西。从技术上讲，有两个维度构成了四种不同类型的shell：
- en: '|  | ** Login** | ** Non-login** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|  | **登录** | **非登录** |'
- en: '| ** Interactive** |  Interactive login shell |  Interactive non-login shell
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **交互式** | 交互式登录shell | 交互式非登录shell |'
- en: '| ** Non-interactive** |  Non-interactive login shell |  Non-interactive non-login
    shell |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **非交互式** | 非交互式登录shell | 非交互式非登录shell |'
- en: Most of the time, you'll use an *interactive login shell*, such as when you
    connect via (SSH) or directly via the Terminal console. The other often encountered
    shell is the *non-interactive non-login shell*, which is what is used when commands
    are run via `at` or `cron`. The other two are possible, but we will not be going
    into the details of when you would get those.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，你会使用*交互式登录shell*，比如通过（SSH）连接或直接通过终端控制台。另一个经常遇到的shell是*非交互式非登录shell*，这是在通过`at`或`cron`运行命令时使用的。其他两种也是可能的，但我们不会详细讨论你何时会得到这些。
- en: 'So, now that you know we get a different type of shell in `at` and `cron`,
    we''re sure you''d like to know what the difference is (as in, why do you care
    about this?). There are a number of files that set your profile in Bash. Some
    of these are listed here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在你知道我们在`at`和`cron`中得到了不同类型的shell，我们相信你想知道区别是什么（也就是说，你为什么关心这个问题？）。有一些文件在Bash中设置你的配置文件。其中一些在这里列出：
- en: '`/etc/profile`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/profile`'
- en: '`/etc/bash.bashrc`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/bash.bashrc`'
- en: '`~/.profile`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~/.profile`'
- en: '`~/.bashrc`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~/.bashrc`'
- en: The first two, located in /etc/, are system-wide files, and are thus the same
    for all users. The latter two, which are found in your home directory, are personal;
    these can be edited to, for example, add aliases that you'd like to use. The `alias` command
    is used to create a shorthand for commands with flags. The ~/.bashrc file contains
    the line `alias ll='ls -alF'` by default on Ubuntu 18.04, which means you can
    type `ll` and have `ls -alF` executed instead.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个位于/etc/中，是系统范围的文件，因此对所有用户都是相同的。后两个位于你的主目录中，是个人的；这些可以被编辑，例如，添加你想使用的别名。`alias`命令用于为带有标志的命令创建一个简写。在Ubuntu
    18.04上，默认情况下，~/.bashrc文件包含一行`alias ll='ls -alF'`，这意味着你可以输入`ll`，而执行`ls -alF`。
- en: 'Without going into too much detail (and oversimplifying quite a bit), an interactive
    login shell reads and parses all these files, while a non-interactive non-login
    shell does not (for more in-depth information, see the *Further reading* section).
    As always, a picture is worth a thousand words, so let''s check out the differences
    ourselves:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不详细介绍（并且过于简化了很多），交互式登录shell读取和解析所有这些文件，而非交互式非登录shell不会（有关更深入的信息，请参见*进一步阅读*部分）。一如既往，一幅图值千言，所以让我们自己来看看区别：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we can see here, the values differ between a normal (SSH) shell and `at`
    executed commands. This goes for both PS1 and the shell itself (which we can find
    with $0). However, for `at`, the PATH is the same as for an interactive login
    session. Now, take a look at what happens if we do this in a crontab:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这里看到的，普通（SSH）shell和`at`执行的命令之间的值是不同的。这对PS1和shell本身都是如此（我们可以通过$0找到）。然而，对于`at`，PATH与交互式登录会话的PATH相同。现在，看看如果我们在crontab中这样做会发生什么：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Starting off, PS1 is equal to what `at` sees. Since PS1 controls the way the
    shell looks, this is only interesting for interactive sessions; both `at` and
    `cron` are non-interactive. If we move on to **PATH**, we see a very different
    story: when running in `cron`, we get /usr/bin:/bin instead of /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin!
    Simply put, this means for all commands that are outside of /bin/ and /usr/bin/,
    we need to use the fully qualified filename. This even manifests itself in the
    $0 difference (sh versus /bin/sh). While this is not strictly necessary (since
    /bin/ is actually part of the PATH), it is still typical to see fully qualified
    paths for anything `cron` related.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，PS1等于`at`看到的内容。由于PS1控制shell的外观，这只对交互式会话有趣；`at`和`cron`都是非交互式的。如果我们继续看**PATH**，我们会看到一个非常不同的故事：当在`cron`中运行时，我们得到的是/usr/bin:/bin，而不是/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin！简单地说，这意味着对于所有在/bin/和/usr/bin/之外的命令，我们需要使用完全限定的文件名。这甚至体现在$0的差异（sh与/bin/sh）。虽然这并不是严格必要的（因为/bin/实际上是PATH的一部分），但在与`cron`相关的任何事情上看到完全限定的路径仍然是很典型的。
- en: 'Now, we have two options to deal with this, if we want to prevent errors such
    as sudo: command not found. We can either make sure we always use fully qualified
    paths for all commands (which, in practice, will definitely fail a few times),
    or we can make sure we set a PATH for the crontab. The first option gives us a
    lot more extra work for all things we''ll ever do with `cron`. The second option
    is actually a really easy way to make sure we negate this problem. We can simply
    include a `PATH=...` at the top of the crontab, and all things executed by the
    crontab use that PATH. Give the following a try:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，我们有两种选择来处理这个问题，如果我们想要防止诸如`sudo: command not found`之类的错误。我们可以确保对所有命令始终使用完全限定的路径（实际上，这样做肯定会失败几次），或者我们可以确保为crontab设置一个PATH。第一种选择会给我们所有与`cron`相关的事情带来更多的额外工作。第二种选择实际上是确保我们消除这个问题的一个非常简单的方法。我们只需在crontab的顶部包含一个`PATH=...`，所有由crontab执行的事情都使用那个PATH。试一下以下内容：'
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Easy-peasy. If you want to verify this for yourself, you could keep the default
    PATH and run something from /sbin/ (such as the `blkid` command, which shows information
    on your disks/partitions). Since this isn''t on the PATH, if you do not run it
    fully qualified, you''ll encounter the error /bin/sh: 1: blkid: not found in your
    local mail. Pick any command that you could normally run and try it!'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '很简单。如果你想亲自验证这一点，你可以保持默认的PATH并从/sbin/运行一些东西（比如`blkid`命令，它显示你的磁盘/分区的信息）。由于这不在PATH上，如果你不使用完全限定的方式运行它，你会遇到错误/bin/sh:
    1: blkid: not found in your local mail。选择任何你通常可以运行的命令并尝试一下！'
- en: With this simple addition to a crontab, you can save yourself a lot of time
    and effort troubleshooting errors. As with all things in scheduling, you often
    have to wait at least a few minutes for each script attempt to run, making troubleshooting
    a time-intensive practice. Do yourself a favor and always make sure to include
    a relevant PATH as the first line of your crontab.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地添加到crontab中，你可以节省大量的时间和精力来排除错误。就像调度中的所有事情一样，你通常需要等待至少几分钟才能运行每个脚本尝试，这使得故障排除成为一种耗时的实践。请自己一个忙，确保在crontab的第一行包含一个相关的PATH。
- en: SHELL
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SHELL
- en: 'It should be clear from looking at the outputs we saw for **PATH**, both `at`
    and `cron` by default use /bin/sh. You might get lucky and have a distribution
    where /bin/sh defaults to Bash, but this is not necessarily the case, especially
    not if you followed along with our Ubuntu 18.04 installation! In this case, if
    we check out /bin/sh, we see something different entirely:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们看到的**PATH**的输出中，应该很清楚，`at`和`cron`默认使用/bin/sh。你可能很幸运，有一个/bin/sh默认为Bash的发行版，但这并不一定是这样，尤其是如果你跟着我们的Ubuntu
    18.04安装走的话！在这种情况下，如果我们检查/bin/sh，我们会看到完全不同的东西：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Dash is the ***D**ebian **A**lmquist **sh**ell*, which is the default system
    shell on recent Debian systems (Ubuntu, as you might remember, belongs to the
    Debian distribution family). While Dash is a wonderful shell with its own set
    of advantages and disadvantages, this book is written for Bash. So, for our use
    case, it is not practical to have `cron` default to using a Dash shell, since
    that would not allow us to use cool Bash 4.x functions such as advanced redirections,
    certain expansions, and so on. Fortunately, we can easily set the shell that `cron`
    should use when we run our commands: we use the SHELL environment variable. Setting
    this is really simple:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Dash是***D**ebian **A**lmquist **sh**ell*，它是最近Debian系统（你可能记得Ubuntu属于Debian发行系列）上的默认系统shell。虽然Dash是一个很棒的shell，有它自己的一套优点和缺点，但这本书是为Bash编写的。所以，对于我们的用例来说，让`cron`默认使用Dash
    shell并不实际，因为这将不允许我们使用酷炫的Bash 4.x功能，比如高级重定向、某些扩展等。幸运的是，当我们运行我们的命令时，我们可以很容易地设置`cron`应该使用的shell：我们使用SHELL环境变量。设置这个非常简单：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With just the simple addition of the SHELL environment variable, we made sure
    we do not have mind-boggling issues about why certain Bash functionality is not
    working. It is always a good idea to prevent these issues rather than hope you
    catch them quickly, especially if you're still mastering shell scripting.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 只需简单地添加SHELL环境变量，我们确保了不会因为某些Bash功能不起作用而感到困惑。预防这些问题总是一个好主意，而不是希望你能迅速发现它们，特别是如果你仍在掌握shell脚本。
- en: MAILTO
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MAILTO
- en: Now that we've determined we can use environment variables in our crontab by
    checking out both PATH and SHELL, let's look at the other very important one, MAILTO.
    As you might guess from the name, this variable controls where mails will be sent.
    As you remember, mails are sent when a command has stdout (which are pretty much
    all commands). That means that for every command the crontab executes, you'll
    probably get a local email. This, as you might suspect, can become annoying very
    quickly. We could suffix a nice little `&> /dev/null` to all commands we place
    in the crontab (remember, `&>` is Bash-specific, and would not have worked for
    the default Dash shell). However, this would mean that we never have any output
    at all, mailed or otherwise. Besides that problem, we'll also need to add it to
    all our lines; not really a real practical, workable solution. In a few pages,
    we're going to discuss how we can redirect our output to somewhere we want. Before
    we get to that point, however, we need to be able to manipulate the default emails
    as well.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定我们可以在crontab中使用环境变量，通过检查PATH和SHELL，让我们看看另一个非常重要的变量MAILTO。从名称上可以猜到，这个变量控制邮件发送的位置。你可能记得，当命令有stdout时（几乎所有命令都有），邮件会被发送。这意味着对于crontab执行的每个命令，你可能会收到一封本地邮件。你可能会怀疑，这很快就会变得很烦人。我们可以在我们放置在crontab中的所有命令后面加上一个不错的`&>
    /dev/null`（记住，`&>`是Bash特有的，对于默认的Dash shell不起作用）。然而，这意味着我们根本不会有任何输出，无论是邮件还是其他。除了这个问题，我们还需要将它添加到所有我们的行中；这并不是一个真正实用的、可行的解决方案。在接下来的几页中，我们将讨论如何将输出重定向到我们想要的地方。然而，在达到这一点之前，我们需要能够操纵默认的邮件。
- en: 'One option would be to either not install or uninstall `sendmail`. This might
    be a good solution for some of you, but for others there is another need to have
    `sendmail` on the system, so it cannot be removed. What then? We can use the MAILTO
    variable in the same way as we use the **PATH**; we set it in the beginning of
    the crontab, and mails will be properly redirected. If we empty this variable,
    by assigning it the empty string `""`, no mail will be sent. This looks something
    like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是要么不安装或卸载`sendmail`。这对于你们中的一些人可能是一个很好的解决方案，但对于其他人来说，他们有另一个需要在系统上安装`sendmail`，所以它不能被移除。那么呢？我们可以像使用**PATH**一样使用MAILTO变量；我们在crontab的开头设置它，邮件将被正确重定向。如果我们清空这个变量，通过将它赋值为空字符串`""`，则不会发送邮件。这看起来像这样：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We''ve used the `tail` command a lot up until now, but it actually has a great
    little flag `--follow` (`-f`), which allows us to see if any new lines are being
    written to a file. This is normally used to *tail a logfile*, but in this case
    allows us to see whether we get mail by tailing the /var/mail/reader file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经经常使用`tail`命令，但实际上它有一个很棒的小标志`--follow`（`-f`），它允许我们查看文件是否有新行被写入。这通常用于*tail
    a logfile*，但在这种情况下，它允许我们通过tailing /var/mail/reader文件来查看是否收到邮件。
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If everything went as we expected it to, this is the only thing you will see.
    Since the MAILTO variable was declared as the empty string, `""`, `cron` knows
    not to send out mails. Exit the `tail -f` with *Ctrl* + *C* (but remember the
    command), and rest easy now that you've prevented yourself from being spammed
    by your crontab!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切都按我们的预期进行，这将是你看到的唯一的东西。由于MAILTO变量被声明为空字符串`""`，`cron`知道不发送邮件。使用*Ctrl* + *C*退出`tail
    -f`（但记住这个命令），现在你可以放心了，因为你已经阻止了自己被crontab垃圾邮件轰炸！
- en: Logging with redirection
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用重定向进行日志记录
- en: 'While the mail spam has been eliminated, now you find yourself without any
    output at all, which is definitely not a good thing either. Luckily for us, we''ve
    learned all about redirection in [Chapter 12](15141e02-be0c-4709-90f4-a172809217c4.xhtml),
    *Using Pipes and Redirection in Scripts**.* Just as we can use *redirect within
    scripts* or *on the command-line*, we can use the same constructs in a crontab.
    The same rules for ordering of pipes and stdout/stderr apply, so we can chain
    whatever command we want. Before we show this, however, we''ll show one more cool
    functionality of crontab: instantiating a crontab from a file!'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然邮件垃圾邮件已经消除，但现在你发现自己根本没有任何输出，这绝对也不是一件好事。幸运的是，我们在[第12章](15141e02-be0c-4709-90f4-a172809217c4.xhtml)中学到了有关重定向的一切，*在脚本中使用管道和重定向**。*就像我们可以在脚本中使用*重定向*或*在命令行中*使用一样，我们可以在crontab中使用相同的结构。管道和stdout/stderr的顺序规则也适用，所以我们可以链接任何我们想要的命令。然而，在我们展示这个之前，我们将展示crontab的另一个很酷的功能：从文件实例化一个crontab！
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, we create the base-crontab file, which contains our Bash SHELL, the PATH
    (which we trimmed a little), the MAILTO variable, and our syntax header. Next,
    we use the `crontab base-crontab` command. Simply put, this replaces the current
    crontab with the contents from the file. This means we can manage the crontab
    as a file now; this includes support for version control systems and other backup
    solutions. Even better, when using the `crontab <filename>` command, syntax checking
    is intact. If the file isn't proper crontab format, you'll see the error errors
    in crontab file, can't install. Should you wish to save the current crontab to
    a file, the `crontab -l > filename` command will do the trick for you.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建base-crontab文件，其中包含我们的Bash SHELL、我们修剪了一点的PATH、MAILTO变量和我们的语法头。接下来，我们使用`crontab
    base-crontab`命令。简单地说，这将用文件中的内容替换当前的crontab。这意味着我们现在可以将crontab作为一个文件来管理；这包括对版本控制系统和其他备份解决方案的支持。更好的是，使用`crontab
    <filename>`命令时，语法检查是完整的。如果文件不是正确的crontab格式，你会看到错误“crontab文件中的错误，无法安装”。如果你想将当前的crontab保存到一个文件中，`crontab
    -l > filename`命令会为你解决问题。
- en: 'Now that that''s out of the way, we''ll give some examples of redirection for
    commands run by the crontab. We''ll always instantiate from a file, so that you
    can easily find these materials on the GitHub page:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 既然这样，我们将给出一些由crontab运行的命令的重定向示例。我们将始终从一个文件实例化，这样你就可以在GitHub页面上轻松找到这些材料：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, that was pretty easy. As long as our SHELL, PATH**,** and MAILTO are properly
    set, we have avoided a lot of issues that are normally experienced when people
    start working with scheduling via the crontab.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这很容易。只要我们的SHELL、PATH和MAILTO设置正确，我们就避免了在使用crontab进行调度时通常会遇到的很多问题。
- en: 'One thing we have not done yet is run a script with the crontab. So far, only
    single commands have been run. However, a script will run just as great. We''ll
    use a script from the previous chapter, reverser.sh, which will show that we can
    supply arguments to scripts via the crontab as well. Furthermore, it will show
    that the redirection we just learned works for script output just as well:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有运行一个脚本来使用crontab。到目前为止，只运行了单个命令。但是，脚本也可以很好地运行。我们将使用上一章的脚本reverser.sh，它将显示我们也可以通过crontab向脚本提供参数。此外，它将显示我们刚学到的重定向对脚本输出同样有效：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Ouch! After all our careful preparation, we still messed up here. Fortunately,
    the output file we created (which functions as a log file, and has the .log extension
    because of it) also has stderr redirected (because of our Bash 4.x `&>>` syntax)
    and we see what the error is. A classic error, Permission denied in this case
    simply means that we are trying to execute a non-executable file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！尽管我们做了仔细的准备，但我们还是搞砸了。幸运的是，我们创建的输出文件（因为它是一个日志文件，所以扩展名为.log）也有stderr重定向（因为我们的Bash
    4.x `&>>`语法），我们看到了错误。在这种情况下，经典的错误“权限被拒绝”简单地意味着我们试图执行一个非可执行文件：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, we need to fix this. We can do two things:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们需要修复这个问题。我们可以做两件事：
- en: Make the file executable with (for example) `chmod 755 reverser.sh`.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用（例如）`chmod 755 reverser.sh`使文件可执行。
- en: Change the crontab from `reverser.sh` to `bash reverser.sh`.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将crontab从`reverser.sh`更改为`bash reverser.sh`。
- en: In this case, there is not really a good or bad solution. On the one hand, it
    is always a good idea to mark files that need to be executed as executable; this
    conveys to someone seeing the system that you intended this. On the other hand,
    if the extra `bash` command in the crontab can save you from these types of issues,
    what is the harm in that?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，没有真正好坏之分。一方面，标记需要执行的文件为可执行文件总是一个好主意；这向看到系统的人表明你是有意这样做的。另一方面，如果在crontab中添加额外的`bash`命令可以避免这类问题，那又有什么坏处呢？
- en: 'In our opinion, there is slightly more merit in making the file executable
    and omitting the `bash` command in your crontab. This keeps the crontab cleaner,
    (and, from experience, crontabs can easily become a mess if mishandled, so this
    is a very big plus), and shows someone else looking at the script that it should
    be executed because of the permissions. Let''s apply this fix to our machine:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看来，使文件可执行并在crontab中省略`bash`命令略有优势。这样可以保持crontab的清洁（并且根据经验，如果处理不当，crontab很容易变得混乱，所以这是一个非常大的优点），并向查看脚本的其他人表明由于权限问题应该执行它。让我们在我们的机器上应用这个修复：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There, much better. The full command that we run in the crontab is `/home/reader/scripts/chapter_13/reverser.sh
    'crontab' &>> /tmp/reverser.log`, which includes the word crontab as the first
    argument to the script. The output, _batnorc_, is indeed the reversed word. It
    would seem that we can correctly pass arguments via the crontab! While this example
    illustrates the point, it might not get across while this might be significant.
    However, if you imagine a generic script that is normally used multiple times
    with different arguments, it could be present with those different arguments in
    the crontab as well (on multiple lines, perhaps with different schedules). Very
    useful indeed!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，好多了。我们在crontab中运行的完整命令是`/home/reader/scripts/chapter_13/reverser.sh 'crontab'
    &>> /tmp/reverser.log`，其中包括单词crontab作为脚本的第一个参数。输出_batnorc_确实是反转后的单词。看来我们可以通过crontab正确传递参数！虽然这个例子说明了这一点，但可能并不足以说明这可能是重要的。但是，如果你想象一个通用脚本，通常会使用不同的参数多次，那么它也可以在crontab中以不同的参数出现（可能在多行上，也许有不同的计划）。确实非常有用！
- en: If you ever need to quickly look up what the deal with the crontab was, you
    would of course check out `man crontab`. However, what we haven't told you yet
    is that some commands actually have more than one man page! By default, `man crontab`
    is shorthand for `man <first-manpage> crontab`. On that page, you'll see the sentence,
    "SEE ALSO crontab(5), cron(8)". By supplying this number with `man 5 crontab`,
    you'll see a different page where many of the concepts of this chapter (syntax,
    environment variables, and examples) are easily accessible to you.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要快速查看crontab的情况，您当然会查看`man crontab`。但是，我们还没有告诉您的是，有些命令实际上有多个man页面！默认情况下，`man
    crontab`是`man <first-manpage> crontab`的简写。在该页面上，您将看到这样的句子：“SEE ALSO crontab(5),
    cron(8)”。通过向`man 5 crontab`提供此数字，您将看到一个不同的页面，其中本章的许多概念（语法、环境变量和示例）都很容易访问。
- en: Final logging considerations
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终的日志记录考虑
- en: 'You might consider having your script take care of its own logging. While this
    is certainly possible, (although a little complex and not very readable), we feel
    strongly that **it is the responsibility of the caller to take care of logging**.
    If you find a script that takes care of its own logging, you might encounter some
    of the following issues:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能考虑让您的脚本自行处理其日志记录。虽然这当然是可能的（尽管有点复杂且不太可读），但我们坚信**调用者有责任处理日志记录**。如果您发现一个脚本自行处理其日志记录，您可能会遇到以下一些问题：
- en: Multiple users run the same script at different intervals, to a single log file
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个用户以不同的间隔运行相同的脚本，将输出到单个日志文件
- en: The log file needs to have robust user permissions to ensure correct exposure
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志文件需要具有健壮的用户权限，以确保正确的暴露
- en: Both ad hoc and scheduled runs will appear in the log file
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时和定期运行都将出现在日志文件中
- en: 'Simply put, delegating the responsibility of logging to the script itself is
    asking for trouble. For an ad hoc command, you get the output right in your Terminal.
    If you need it for any other purpose, you can always copy and paste it somewhere,
    or redirect it. Even more probable is running the script with a pipe to `tee`,
    so output is shown to your Terminal *and* saved to a file at the same time. For
    scheduled runs from `cron`, you need to think once about redirection: when you
    create the schedule. In this case, especially if you use the Bash 4.x construct
    of `&>>`, you will always see all output (stdout and stderr) appended to the file
    you specify. In this, there is almost no risk of missing any output. Remember:
    `tee` and redirections are your friends, and when used properly they make a great
    addition to any script scheduling!'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，将日志记录的责任委托给脚本本身是在自找麻烦。对于临时命令，您可以在终端中获得输出。如果您需要它用于其他任何目的，您可以随时将其复制并粘贴到其他地方，或者重定向它。更有可能的是使用管道运行脚本到`tee`，因此输出同时显示在您的终端上*并*保存到文件中。对于从`cron`进行的定期运行，您需要在创建计划时考虑重定向。在这种情况下，特别是如果您使用Bash
    4.x的`&>>`构造，您将始终看到所有输出（stdout和stderr）都附加到您指定的文件中。在这种情况下，几乎没有错过任何输出的风险。记住：`tee`和重定向是您的朋友，当正确使用时，它们是任何脚本调度的重要补充！
- en: If you want your cron logging mechanism to be *really fancy*, you can set up
    `sendmail` (or other software such as `postfix`) as an actual Mail Transfer Agent
    (very out of the scope of this book, but check the *Further reading* section!).
    If that is correctly configured, you can set the MAILTO variable in the crontab
    to an actual email address (perhaps `yourname@company.com`), and receive the reports
    from scheduled jobs in your normal email box. This is best used with important
    scripts that do not run too often; otherwise, you will just end up with an annoying
    amount of email.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望您的cron日志记录机制变得*非常花哨*，您可以设置`sendmail`（或其他软件，如`postfix`）作为实际的邮件传输代理（这超出了本书的范围，但请查看*进一步阅读*部分！）。如果正确配置，您可以在crontab中将MAILTO变量设置为实际的电子邮件地址（也许是`yourname@company.com`），并在您的常规电子邮件邮箱中接收来自定期作业的报告。这最适用于不经常运行的重要脚本；否则，您将只会收到大量令人讨厌的电子邮件。
- en: A note on verbosity
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于冗长的说明
- en: It is important to realize that, just as it is on the command-line directly,
    only output (stdout/stderr) is logged. By default, most commands that run successfully
    do not have any output; examples of these are `cp`, `rm`, `touch`, and so on.
    If you want informative logging in your scripts, it is your responsibility to
    add output where you see fit. The easiest way to accomplish this is by simply
    using an `echo` here and there. The easiest way to make a log file give confidence
    to the user is by having the final command in your scripts be `echo "Everything
    went well, exiting script."`. As long as you handle all potential errors properly
    during your script, you can safely say that once it reaches the final command
    the execution has succeeded, and you can notify the user of this. If you do not
    do this, the log file might stay empty, which can be kind of scary; is it empty
    because everything succeeded *or because the script did not even run*? This is
    not something you want to take a chance on, especially not when a simple `echo`
    can save you all that trouble.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，就像直接在命令行上一样，只有输出（stdout/stderr）被记录。默认情况下，大多数成功运行的命令没有任何输出；其中包括`cp`、`rm`、`touch`等。如果您希望在脚本中进行信息记录，您有责任在适当的位置添加输出。最简单的方法是偶尔使用`echo`。使日志文件对用户产生信心的最简单方法是在脚本的最后一个命令中使用`echo
    "一切顺利，退出脚本。"`。只要您在脚本中正确处理了所有潜在的错误，您可以安全地说一旦达到最后一个命令，执行就已成功，您可以通知用户。如果不这样做，日志文件可能会保持空白，这可能有点可怕；它是空白的，因为一切都成功了*还是因为脚本甚至没有运行*？这不是您想冒险的事情，尤其是当一个简单的`echo`可以帮您省去所有这些麻烦。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by showing the new `at` command and explaining how we
    can use `at` for scheduling scripts. We described the timestamp syntax for `at` and
    how it contains a queue for all scheduled jobs. We explained how `at` is mostly
    used for ad hoc scheduled commands and scripts, before we continued to the more
    powerful `cron` scheduler.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过展示新的`at`命令开始了本章，并解释了如何使用`at`来安排脚本。我们描述了`at`的时间戳语法以及它包含了所有计划作业的队列。我们解释了`at`主要用于临时安排的命令和脚本，然后继续介绍了更强大的`cron`调度程序。
- en: The `cron` daemon, responsible for most scheduled tasks on a system, is a very
    powerful and flexible scheduler, which is most often used via the so-called crontab.
    This is a user-bound file, which contains instructions for `cron` on when and
    how to run commands and scripts. We presented the timestamp syntax that is used
    in a crontab.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`cron`守护程序负责系统上大多数计划任务，它是一个非常强大和灵活的调度程序，通常通过所谓的crontab来使用。这是一个用户绑定的文件，其中包含了关于`cron`何时以及如何运行命令和脚本的指令。我们介绍了在crontab中使用的时间戳语法。'
- en: The second part of the chapter dealt with logging our scheduled commands and
    scripts. When a command is run interactively on the command line, there is no
    need for dedicated logging, but scheduled commands are not interactive, and thus
    need additional mechanisms. Output from scheduled commands can either be mailed
    to a local file with the `sendmail` process, or redirected to a log file using
    the redirection possibilities we outlined earlier.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第二部分涉及记录我们的计划命令和脚本。当在命令行上交互运行命令时，不需要专门的记录，但计划的命令不是交互式的，因此需要额外的机制。计划命令的输出可以使用`sendmail`进程发送到本地文件，也可以使用我们之前概述的重定向可能性将其重定向到日志文件中。
- en: 'We ended the chapter with some final considerations on logging: how it should
    always be the responsibility of the caller to arrange logging, and how it is the
    responsibility of the script author to make sure a script is verbose enough to
    be used non-interactively.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章结束时对日志记录进行了一些最终考虑：始终由调用者负责安排日志记录，并且脚本作者有责任确保脚本足够详细以便非交互式地使用。
- en: 'The following commands were introduced in this chapter: `at`, `wall`, `atq`,
    `atrm`, `sendmail`, `crontab`, and `alias`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了以下命令：`at`，`wall`，`atq`，`atrm`，`sendmail`，`crontab`和`alias`。
- en: Questions
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is scheduling?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是调度？
- en: What do we mean by ad hoc scheduling?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们所说的临时调度是什么意思？
- en: Where does the output of commands run with `at` normally go?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`at`运行的命令的输出通常会去哪里？
- en: How is scheduling for the `cron` daemon most often implemented?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cron`守护程序的调度最常见的实现方式是什么？'
- en: Which commands allow you to edit your personal crontab?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些命令允许您编辑个人的crontab？
- en: Which five fields are present in the crontab timestamp syntax?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在crontab时间戳语法中有哪五个字段？
- en: Which are the three most important environment variables for the crontab?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: crontab的三个最重要的环境变量是哪些？
- en: How can we inspect the output for scripts or commands we have scheduled with
    `cron`?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何检查我们使用`cron`计划的脚本或命令的输出？
- en: If our scheduled scripts do not have enough output for us to effectively work
    with log files, how should we remedy this?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们计划的脚本没有足够的输出让我们有效地使用日志文件，我们应该如何解决这个问题？
- en: Further reading
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following resources might be interesting if you''d like to go deeper into
    the subjects of this chapter:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更深入地了解本章的主题，以下资源可能会很有趣：
- en: '**Profile and Bashrc**: [https://bencane.com/2013/09/16/understanding-a-little-more-about-etcprofile-and-etcbashrc/](https://bencane.com/2013/09/16/understanding-a-little-more-about-etcprofile-and-etcbashrc/)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件和Bashrc**：[https://bencane.com/2013/09/16/understanding-a-little-more-about-etcprofile-and-etcbashrc/](https://bencane.com/2013/09/16/understanding-a-little-more-about-etcprofile-and-etcbashrc/)'
- en: '**Set up a Mail Transfer Agent with postfix**: [https://www.hiroom2.com/2018/05/06/ubuntu-1804-postfix-en/](https://www.hiroom2.com/2018/05/06/ubuntu-1804-postfix-en/)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用postfix设置邮件传输代理**：[https://www.hiroom2.com/2018/05/06/ubuntu-1804-postfix-en/](https://www.hiroom2.com/2018/05/06/ubuntu-1804-postfix-en/)'
