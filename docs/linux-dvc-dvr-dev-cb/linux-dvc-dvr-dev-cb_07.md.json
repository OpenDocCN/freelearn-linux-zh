["```\n$ patch -p1 < ../github/chapter_04/chrdev/add_chrdev_devices.dts.patch \npatching file arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts\n```", "```\nstatic const struct file_operations chrdev_fops = {\n    .owner   = THIS_MODULE,\n    .llseek  = chrdev_llseek,\n    .read    = chrdev_read,\n    .write   = chrdev_write,\n    .open    = chrdev_open,\n    .release = chrdev_release\n};\n```", "```\nstatic loff_t chrdev_llseek(struct file *filp, loff_t offset, int whence)\n{\n    struct chrdev_device *chrdev = filp->private_data;\n    loff_t newppos;\n\n    dev_info(chrdev->dev, \"should move *ppos=%lld by whence %d off=%lld\\n\",\n                filp->f_pos, whence, offset);\n\n    switch (whence) {\n    case SEEK_SET:\n        newppos = offset; \n        break;\n\n    case SEEK_CUR:\n        newppos = filp->f_pos + offset; \n        break;\n\n    case SEEK_END:\n        newppos = BUF_LEN + offset; \n        break;\n\n    default:\n        return -EINVAL;\n    }\n```", "```\n    if ((newppos < 0) || (newppos >= BUF_LEN))\n        return -EINVAL;\n\n    filp->f_pos = newppos;\n    dev_info(chrdev->dev, \"return *ppos=%lld\\n\", filp->f_pos);\n\n    return newppos;\n}\n```", "```\n$ cd github/chapter_03/\n$ patch -p2 < ../chapter_07/chrdev/modify_lseek_to_chrdev_test.patch \n```", "```\n$ make CFLAGS=\"-Wall -O2\" \\\n CC=aarch64-linux-gnu-gcc \\\n chrdev_test\naarch64-linux-gnu-gcc -Wall -O2 chrdev_test.c -o chrdev_test\n```", "```\n# insmod chrdev.ko \nchrdev:chrdev_init: got major 239\n# insmod chrdev-req.ko\nchrdev cdev-eeprom@2: chrdev cdev-eeprom with id 2 added\nchrdev cdev-rom@4: chrdev cdev-rom with id 4 added\n\n```", "```\n# ./chrdev_test /dev/cdev-eeprom\\@2 \nfile /dev/cdev-eeprom@2 opened\nwrote 11 bytes into file /dev/cdev-eeprom@2\ndata written are: 44 55 4d 4d 59 20 44 41 54 41 00 \n*ppos moved to 0\nread 11 bytes from file /dev/cdev-eeprom@2\ndata read are: 44 55 4d 4d 59 20 44 41 54 41 00 \n```", "```\nchrdev cdev-eeprom@2: chrdev (id=2) opened\nchrdev cdev-eeprom@2: should write 11 bytes (*ppos=0)\nchrdev cdev-eeprom@2: got 11 bytes (*ppos=11)\nchrdev cdev-eeprom@2: should move *ppos=11 by whence 0 off=0\nchrdev cdev-eeprom@2: return *ppos=0\nchrdev cdev-eeprom@2: should read 11 bytes (*ppos=0)\nchrdev cdev-eeprom@2: return 11 bytes (*ppos=11)\nchrdev cdev-eeprom@2: chrdev (id=2) released\n```", "```\n# dd if=/dev/cdev-eeprom\\@2 skip=11 bs=1 count=3 | od -tx1\n3+0 records in\n3+0 records out\n3 bytes copied, 0.0530299 s, 0.1 kB/s\n0000000 00 00 00\n0000003\n\n```", "```\nchrdev cdev-eeprom@2: chrdev (id=2) opened\nchrdev cdev-eeprom@2: should move *ppos=0 by whence 1 off=0\nchrdev cdev-eeprom@2: return *ppos=0\nchrdev cdev-eeprom@2: should move *ppos=0 by whence 1 off=11\nchrdev cdev-eeprom@2: return *ppos=11\nchrdev cdev-eeprom@2: should read 1 bytes (*ppos=11)\nchrdev cdev-eeprom@2: return 1 bytes (*ppos=12)\nchrdev cdev-eeprom@2: should read 1 bytes (*ppos=12)\nchrdev cdev-eeprom@2: return 1 bytes (*ppos=13)\nchrdev cdev-eeprom@2: should read 1 bytes (*ppos=13)\nchrdev cdev-eeprom@2: return 1 bytes (*ppos=14)\nchrdev cdev-eeprom@2: chrdev (id=2) released\n```", "```\nstatic const struct file_operations chrdev_fops = {\n    .owner          = THIS_MODULE,\n    .unlocked_ioctl = chrdev_ioctl,\n    .llseek         = chrdev_llseek,\n    .read           = chrdev_read,\n    .write          = chrdev_write,\n    .open           = chrdev_open,\n    .release        = chrdev_release\n};\n```", "```\nstatic long chrdev_ioctl(struct file *filp,\n                unsigned int cmd, unsigned long arg)\n{\n    struct chrdev_device *chrdev = filp->private_data;\n    struct chrdev_info info;\n    void __user *uarg = (void __user *) arg;\n    int __user *iuarg = (int __user *) arg;\n    int ret;\n\n    /* Get some command information */\n    if (_IOC_TYPE(cmd) != CHRDEV_IOCTL_BASE) {\n        dev_err(chrdev->dev, \"command %x is not for us!\\n\", cmd);\n        return -EINVAL;\n    }\n    dev_info(chrdev->dev, \"cmd nr=%d size=%d dir=%x\\n\",\n                _IOC_NR(cmd), _IOC_SIZE(cmd), _IOC_DIR(cmd));\n```", "```\n    switch (cmd) {\n    case CHRDEV_IOC_GETINFO:\n        dev_info(chrdev->dev, \"CHRDEV_IOC_GETINFO\\n\");\n\n        strncpy(info.label, chrdev->label, NAME_LEN);\n        info.read_only = chrdev->read_only;\n\n        ret = copy_to_user(uarg, &info, sizeof(struct chrdev_info));\n        if (ret)\n            return -EFAULT;\n\n        break;\n\n    case WDIOC_SET_RDONLY:\n        dev_info(chrdev->dev, \"WDIOC_SET_RDONLY\\n\");\n\n        ret = get_user(chrdev->read_only, iuarg); \n        if (ret)\n            return -EFAULT;\n\n        break;\n\n    default:\n        return -ENOIOCTLCMD;\n    }\n\n    return 0;\n}\n```", "```\n/*\n * Chrdev ioctl() include file\n */\n\n#include <linux/ioctl.h>\n#include <linux/types.h>\n\n#define CHRDEV_IOCTL_BASE    'C'\n#define CHRDEV_NAME_LEN      32\n\nstruct chrdev_info {\n    char label[CHRDEV_NAME_LEN];\n    int read_only;\n};\n\n/*\n * The ioctl() commands\n */\n\n#define CHRDEV_IOC_GETINFO _IOR(CHRDEV_IOCTL_BASE, 0, struct chrdev_info)\n#define WDIOC_SET_RDONLY _IOW(CHRDEV_IOCTL_BASE, 1, int)\n```", "```\n    /* Try reading device info */\n    ret = ioctl(fd, CHRDEV_IOC_GETINFO, &info);\n        if (ret < 0) {\n            perror(\"ioctl(CHRDEV_IOC_GETINFO)\");\n            exit(EXIT_FAILURE);\n        }\n    printf(\"got label=%s and read_only=%d\\n\", info.label, info.read_only);\n\n    /* Try toggling the device reading mode */\n    read_only = !info.read_only;\n    ret = ioctl(fd, WDIOC_SET_RDONLY, &read_only);\n        if (ret < 0) {\n            perror(\"ioctl(WDIOC_SET_RDONLY)\");\n            exit(EXIT_FAILURE);\n        }\n    printf(\"device has now read_only=%d\\n\", read_only);\n```", "```\n$ make CFLAGS=\"-Wall -O2 -Ichrdev/\" \\\n CC=aarch64-linux-gnu-gcc \\\n chrdev_ioctl aarch64-linux-gnu-gcc -Wall -O2 chrdev_ioctl.c -o chrdev_ioctl \n```", "```\n# ./chrdev_ioctl /dev/cdev-eeprom\\@2\nfile /dev/cdev-eeprom@2 opened\ngot label=cdev-eeprom and read_only=0\ndevice has now read_only=1\n```", "```\nchrdev cdev-eeprom@2: chrdev (id=2) opened\nchrdev cdev-eeprom@2: cmd nr=0 size=36 dir=2\nchrdev cdev-eeprom@2: CHRDEV_IOC_GETINFO\nchrdev cdev-eeprom@2: cmd nr=1 size=4 dir=1\nchrdev cdev-eeprom@2: WDIOC_SET_RDONLY\nchrdev cdev-eeprom@2: chrdev (id=2) released\n```", "```\ndiff --git a/chapter_07/chrdev/chrdev.h b/chapter_07/chrdev/chrdev.h\nindex 6b925fe..40a244f 100644\n--- a/chapter_07/chrdev/chrdev.h\n+++ b/chapter_07/chrdev/chrdev.h\n@@ -7,7 +7,7 @@\n\n #define MAX_DEVICES 8\n #define NAME_LEN    CHRDEV_NAME_LEN\n-#define BUF_LEN     300\n+#define BUF_LEN     PAGE_SIZE\n\n /*\n  * Chrdev basic structs\n@@ -17,7 +17,7 @@\n struct chrdev_device {\n     char label[NAME_LEN];\n     unsigned int busy : 1;\n-    char buf[BUF_LEN];\n+    char *buf;\n     int read_only;\n\n     unsigned int id;\n```", "```\ndiff --git a/chapter_07/chrdev/chrdev.c b/chapter_07/chrdev/chrdev.c\nindex 3717ad2..a8bffc3 100644\n--- a/chapter_07/chrdev/chrdev.c\n+++ b/chapter_07/chrdev/chrdev.c\n@@ -7,6 +7,7 @@\n #include <linux/module.h>\n #include <linux/fs.h>\n #include <linux/uaccess.h>\n+#include <linux/slab.h>\n #include <linux/mman.h>\n\n@@ -246,6 +247,13 @@ int chrdev_device_register(const char *label, unsigned int \nid,\n          return -EBUSY;\n      }\n\n+     /* First try to allocate memory for internal buffer */\n+     chrdev->buf = kzalloc(BUF_LEN, GFP_KERNEL);\n+     if (!chrdev->buf) {\n+         dev_err(chrdev->dev, \"cannot allocate memory buffer!\\n\");\n+         return -ENOMEM;\n+     }\n+\n      /* Create the device and initialize its data */\n      cdev_init(&chrdev->cdev, &chrdev_fops);\n      chrdev->cdev.owner = owner;\n@@ -255,7 +263,7 @@ int chrdev_device_register(const char *label, unsigned int id,\n      if (ret) {\n          pr_err(\"failed to add char device %s at %d:%d\\n\",\n                            label, MAJOR(chrdev_devt), id);\n-         return ret;\n+         goto kfree_buf;\n      }\n chrdev->dev = device_create(chrdev_class, parent, devt, chrdev,\n```", "```\n@@ -272,7 +280,6 @@ int chrdev_device_register(const char *label, unsigned int id,\n      chrdev->read_only = read_only;\n      chrdev->busy = 1;\n      strncpy(chrdev->label, label, NAME_LEN);\n-     memset(chrdev->buf, 0, BUF_LEN);\n\n      dev_info(chrdev->dev, \"chrdev %s with id %d added\\n\", label, id);\n\n@@ -280,6 +287,8 @@ int chrdev_device_register(const char *label, unsigned int id,\n\n  del_cdev:\n      cdev_del(&chrdev->cdev);\n+ kfree_buf:\n+     kfree(chrdev->buf);\n\n      return ret;\n }\n@@ -309,6 +318,9 @@ int chrdev_device_unregister(const char *label, unsigned int id)\n\n      dev_info(chrdev->dev, \"chrdev %s with id %d removed\\n\", label, id);\n\n+     /* Free allocated memory */\n+     kfree(chrdev->buf);\n+\n        /* Dealocate the device */\n        device_destroy(chrdev_class, chrdev->dev->devt);\n        cdev_del(&chrdev->cdev);\n```", "```\nstatic const struct file_operations chrdev_fops = {\n    .owner          = THIS_MODULE,\n    .mmap           = chrdev_mmap,\n    .unlocked_ioctl = chrdev_ioctl,\n    .llseek         = chrdev_llseek,\n    .read           = chrdev_read,\n    .write          = chrdev_write,\n    .open           = chrdev_open,\n    .release        = chrdev_release\n};\n```", "```\nstatic int chrdev_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n    struct chrdev_device *chrdev = filp->private_data;\n    size_t size = vma->vm_end - vma->vm_start;\n    phys_addr_t offset = (phys_addr_t) vma->vm_pgoff << PAGE_SHIFT;\n    unsigned long pfn;\n\n    /* Does it even fit in phys_addr_t? */\n    if (offset >> PAGE_SHIFT != vma->vm_pgoff)\n        return -EINVAL;\n\n    /* We cannot mmap too big areas */\n    if ((offset > BUF_LEN) || (size > BUF_LEN - offset))\n        return -EINVAL;\n```", "```\n    /* Get the physical address belong the virtual kernel address */\n    pfn = virt_to_phys(chrdev->buf) >> PAGE_SHIFT;\n```", "```\n    /* Remap-pfn-range will mark the range VM_IO */\n    if (remap_pfn_range(vma, vma->vm_start,\n                pfn, size,\n                vma->vm_page_prot))\n        return -EAGAIN;\n\n    return 0;\n}\n```", "```\n$ make CFLAGS=\"-Wall -O2\" \\\n CC=aarch64-linux-gnu-gcc \\\n chrdev_mmap\naarch64-linux-gnu-gcc -Wall -O2 chrdev_mmap.c -o chrdev_mmap\n```", "```\n# cp textfile.txt /dev/cdev-eeprom\\@2\n```", "```\nchrdev cdev-eeprom@2: chrdev (id=2) opened\nchrdev cdev-eeprom@2: chrdev (id=2) released\nchrdev cdev-eeprom@2: chrdev (id=2) opened\nchrdev cdev-eeprom@2: should write 54 bytes (*ppos=0)\nchrdev cdev-eeprom@2: got 54 bytes (*ppos=54)\nchrdev cdev-eeprom@2: chrdev (id=2) released\n```", "```\n# cat /dev/cdev-eeprom\\@2 \nThis is a test file\n\nThis is line 3.\n\nEnd of the file\n```", "```\n# ./chrdev_mmap /dev/cdev-eeprom\\@2 54\nfile /dev/cdev-eeprom@2 opened\ngot address=0xffff9896c000 and len=54\n---\nThis is a test file\n\nThis is line 3.\n\nEnd of the file\n```", "```\nchrdev cdev-eeprom@2: chrdev (id=2) opened\nchrdev cdev-eeprom@2: mmap vma=ffff9896c000 pfn=79ead size=1000\nchrdev cdev-eeprom@2: chrdev (id=2) released\n```", "```\n./chrdev_mmap /dev/cdev-eeprom\\@2 54 0\nfile /dev/cdev-eeprom@2 opened\ngot address=0xffff908ef000 and len=54\n---\nThis is a test file\n\nThis is line 3.\n\nEnd of the file\n---\nFirst character changed to '0'\n```", "```\n# cat /dev/cdev-eeprom\\@2 \n0his is a test file\n\nThis is line 3.\n\nEnd of the file\n```", "```\n/* Main struct */\nstruct chrdev_device {\n    char label[NAME_LEN];\n    unsigned int busy : 1;\n    char *buf;\n    int read_only;\n\n    unsigned int id;\n    struct module *owner;\n    struct cdev cdev;\n    struct device *dev;\n\n    struct mutex mux;\n};\n```", "```\n    /* Init the chrdev data */\n    chrdev->id = id;\n    chrdev->read_only = read_only;\n    chrdev->busy = 1;\n    strncpy(chrdev->label, label, NAME_LEN);\n    mutex_init(&chrdev->mux);\n\n    dev_info(chrdev->dev, \"chrdev %s with id %d added\\n\", label, id);\n\n    return 0;\n```", "```\nstatic ssize_t chrdev_read(struct file *filp,\n               char __user *buf, size_t count, loff_t *ppos)\n{\n    struct chrdev_device *chrdev = filp->private_data;\n    int ret;\n\n    dev_info(chrdev->dev, \"should read %ld bytes (*ppos=%lld)\\n\",\n                count, *ppos);\n    mutex_lock(&chrdev->mux); // Grab the mutex\n\n    /* Check for end-of-buffer */\n    if (*ppos + count >= BUF_LEN)\n        count = BUF_LEN - *ppos;\n\n    /* Return data to the user space */\n    ret = copy_to_user(buf, chrdev->buf + *ppos, count);\n    if (ret < 0) {\n        count = -EFAULT;\n        goto unlock;\n    }\n\n    *ppos += count;\n    dev_info(chrdev->dev, \"return %ld bytes (*ppos=%lld)\\n\", count, *ppos);\n\nunlock:\n    mutex_unlock(&chrdev->mux); // Release the mutex\n\n    return count;\n}\n```", "```\nstatic ssize_t chrdev_write(struct file *filp,\n                const char __user *buf, size_t count, loff_t *ppos)\n{\n    struct chrdev_device *chrdev = filp->private_data;\n    int ret;\n\n    dev_info(chrdev->dev, \"should write %ld bytes (*ppos=%lld)\\n\",\n                count, *ppos);\n\n    if (chrdev->read_only)\n        return -EINVAL;\n\n    mutex_lock(&chrdev->mux); // Grab the mutex\n\n    /* Check for end-of-buffer */\n    if (*ppos + count >= BUF_LEN)\n        count = BUF_LEN - *ppos;\n\n    /* Get data from the user space */\n    ret = copy_from_user(chrdev->buf + *ppos, buf, count);\n    if (ret < 0) {\n        count = -EFAULT;\n        goto unlock;\n    }\n\n    *ppos += count;\n    dev_info(chrdev->dev, \"got %ld bytes (*ppos=%lld)\\n\", count, *ppos);\n\nunlock:\n    mutex_unlock(&chrdev->mux); // Release the mutex\n\n    return count;\n}\n```", "```\nstatic long chrdev_ioctl(struct file *filp,\n            unsigned int cmd, unsigned long arg)\n{\n    struct chrdev_device *chrdev = filp->private_data;\n    struct chrdev_info info;\n    void __user *uarg = (void __user *) arg;\n    int __user *iuarg = (int __user *) arg;\n    int ret;\n\n...\n\n    /* Grab the mutex */\n    mutex_lock(&chrdev->mux);\n\n    switch (cmd) {\n    case CHRDEV_IOC_GETINFO:\n        dev_info(chrdev->dev, \"CHRDEV_IOC_GETINFO\\n\");\n\n...\n\n    default:\n        ret = -ENOIOCTLCMD;\n        goto unlock;\n    }\n    ret = 0;\n\nunlock:\n    /* Release the mutex */\n    mutex_unlock(&chrdev->mux);\n\n    return ret;\n}\n```", "```\n/*\n * Dummy function to generate data\n */\n\nstatic char get_new_char(void)\n{\n    static char d = 'A' - 1;\n\n    if (++d == ('Z' + 1))\n        d = 'A';\n\n    return d;\n}\n```", "```\n/*\n * Circular buffer management functions\n */\n\nstatic inline bool cbuf_is_empty(size_t head, size_t tail,\n                                 size_t len)\n{\n    return head == tail;\n}\n\nstatic inline bool cbuf_is_full(size_t head, size_t tail,\n                                 size_t len)\n{\n    head = (head + 1) % len;\n    return head == tail;\n}\n```", "```\nstatic inline size_t cbuf_count_to_end(size_t head, size_t tail,\n                                  size_t len)\n{\n    if (head >= tail)\n        return head - tail;\n    else\n        return len - tail + head;\n}\n\nstatic inline size_t cbuf_space_to_end(size_t head, size_t tail,\n                                  size_t len)\n{\n    if (head >= tail)\n        return len - head + tail - 1;\n    else\n        return tail - head - 1;\n}\n```", "```\nstatic inline void cbuf_pointer_move(size_t *ptr, size_t n,\n                                 size_t len)\n{\n    *ptr = (*ptr + n) % len;\n}\n```", "```\n /* Main struct */\nstruct chrdev_device {\n    char label[NAME_LEN];\n    unsigned int busy : 1;\n    char *buf;\n    size_t head, tail;\n    int read_only;\n\n    unsigned int id;\n    struct module *owner;\n    struct cdev cdev;\n    struct device *dev;\n\n    struct mutex mux;\n    struct spinlock lock;\n    struct wait_queue_head queue;\n    struct hrtimer timer;\n};\n```", "```\n    /* Init the chrdev data */\n    chrdev->id = id;\n    chrdev->read_only = read_only;\n    chrdev->busy = 1;\n    strncpy(chrdev->label, label, NAME_LEN);\n    mutex_init(&chrdev->mux);\n    spin_lock_init(&chrdev->lock);\n    init_waitqueue_head(&chrdev->queue);\n    chrdev->head = chrdev->tail = 0;\n\n    /* Setup and start the hires timer */\n    hrtimer_init(&chrdev->timer, CLOCK_MONOTONIC,\n                        HRTIMER_MODE_REL | HRTIMER_MODE_SOFT);\n    chrdev->timer.function = chrdev_timer_handler;\n    hrtimer_start(&chrdev->timer, ns_to_ktime(delay_ns),\n                        HRTIMER_MODE_REL | HRTIMER_MODE_SOFT);\n```", "```\nstatic ssize_t chrdev_read(struct file *filp,\n                           char __user *buf, size_t count, loff_t *ppos)\n{\n    struct chrdev_device *chrdev = filp->private_data;\n    unsigned long flags;\n    char tmp[256];\n    size_t n;\n    int ret;\n\n    dev_info(chrdev->dev, \"should read %ld bytes\\n\", count);\n\n    /* Grab the mutex */\n    mutex_lock(&chrdev->mux);\n```", "```\n    /* Check for some data into read buffer */\n    if (filp->f_flags & O_NONBLOCK) {\n        if (cbuf_is_empty(chrdev->head, chrdev->tail, BUF_LEN)) {\n            ret = -EAGAIN;\n            goto unlock;\n        }\n    } else if (wait_event_interruptible(chrdev->queue,\n        !cbuf_is_empty(chrdev->head, chrdev->tail, BUF_LEN))) {\n        count = -ERESTARTSYS;\n        goto unlock; \n    }\n\n    /* Grab the lock */\n    spin_lock_irqsave(&chrdev->lock, flags);\n```", "```\n    /* Get data from the circular buffer */\n    n = cbuf_count_to_end(chrdev->head, chrdev->tail, BUF_LEN);\n    count = min(count, n); \n    memcpy(tmp, &chrdev->buf[chrdev->tail], count);\n\n    /* Release the lock */\n    spin_unlock_irqrestore(&chrdev->lock, flags);\n```", "```\n    /* Return data to the user space */\n    ret = copy_to_user(buf, tmp, count);\n    if (ret < 0) {\n        ret = -EFAULT;\n        goto unlock; \n    }\n```", "```\n    /* Now we can safely move the tail pointer */\n    cbuf_pointer_move(&chrdev->tail, count, BUF_LEN);\n    dev_info(chrdev->dev, \"return %ld bytes\\n\", count);\n\nunlock:\n    /* Release the mutex */\n    mutex_unlock(&chrdev->mux);\n\n    return count;\n}\n```", "```\nstatic enum hrtimer_restart chrdev_timer_handler(struct hrtimer *ptr)\n{\n    struct chrdev_device *chrdev = container_of(ptr,\n                    struct chrdev_device, timer);\n\n    spin_lock(&chrdev->lock);    /* grab the lock */ \n\n    /* Now we should check if we have some space to\n     * save incoming data, otherwise they must be dropped...\n     */\n    if (!cbuf_is_full(chrdev->head, chrdev->tail, BUF_LEN)) {\n        chrdev->buf[chrdev->head] = get_new_char();\n\n        cbuf_pointer_move(&chrdev->head, 1, BUF_LEN);\n    }\n    spin_unlock(&chrdev->lock);  /* release the lock */\n\n    /* Wake up any possible sleeping process */\n    wake_up_interruptible(&chrdev->queue);\n\n    /* Now forward the expiration time and ask to be rescheduled */\n    hrtimer_forward_now(&chrdev->timer, ns_to_ktime(delay_ns));\n    return HRTIMER_RESTART;\n}\n```", "```\n# insmod chrdev_irq.ko \nchrdev_irq:chrdev_init: got major 239\n# insmod chrdev-req.ko \nchrdev cdev-eeprom@2: chrdev cdev-eeprom with id 2 added\nchrdev cdev-rom@4: chrdev cdev-rom with id 4 added\n```", "```\n# cat /dev/cdev-eeprom\\@2 \nACEGIKMOQSUWYACEGIKMOQSUWYACEGIKMOQSUWYACEGIKMOQSUWYACEGIKMOQSUWYACEGIKMOQSUWYACEGIKMOQSUW\n```", "```\nchrdev cdev-eeprom@2: chrdev (id=2) opened\nchrdev cdev-eeprom@2: should read 131072 bytes\nchrdev cdev-eeprom@2: return 92 bytes\n```", "```\n...\n[ 227.675229] chrdev cdev-eeprom@2: should read 131072 bytes\n[ 228.292171] chrdev cdev-eeprom@2: return 1 bytes\n[ 228.294129] chrdev cdev-eeprom@2: should read 131072 bytes\n[ 229.292156] chrdev cdev-eeprom@2: return 1 bytes\n...\n```", "```\nstatic const struct file_operations chrdev_fops = {\n    .owner   = THIS_MODULE,\n    .poll    = chrdev_poll,\n    .llseek  = no_llseek,\n    .read    = chrdev_read,\n    .open    = chrdev_open,\n    .release = chrdev_release\n};\n```", "```\nstatic __poll_t chrdev_poll(struct file *filp, poll_table *wait)\n{\n    struct chrdev_device *chrdev = filp->private_data;\n    __poll_t mask = 0;\n\n    poll_wait(filp, &chrdev->queue, wait);\n```", "```\n    /* Grab the mutex */\n    mutex_lock(&chrdev->mux);\n\n    if (!cbuf_is_empty(chrdev->head, chrdev->tail, BUF_LEN))\n        mask |= EPOLLIN | EPOLLRDNORM;\n\n    /* Release the mutex */\n    mutex_unlock(&chrdev->mux);\n\n    return mask;\n}\n```", "```\n    while (1) {\n        /* Set up reading file descriptors */\n        FD_ZERO(&read_fds);\n        FD_SET(STDIN_FILENO, &read_fds);\n        FD_SET(fd, &read_fds);\n\n        /* Wait for any data from our device or stdin */\n        ret = select(FD_SETSIZE, &read_fds, NULL, NULL, NULL);\n        if (ret < 0) {\n            perror(\"select\");\n            exit(EXIT_FAILURE);\n        }\n\n        if (FD_ISSET(STDIN_FILENO, &read_fds)) {\n            ret = read(STDIN_FILENO, &c, 1);\n            if (ret < 0) { \n                perror(\"read(STDIN, ...)\");\n                exit(EXIT_FAILURE);\n            }\n            printf(\"got '%c' from stdin!\\n\", c);\n        }\n ...\n\n    }\n```", "```\n$ make CFLAGS=\"-Wall -O2 -Ichrdev/\" \\\n CC=aarch64-linux-gnu-gcc \\\n chrdev_select aarch64-linux-gnu-gcc -Wall -O2 chrdev_ioctl.c -o chrdev_select\n```", "```\n# ./chrdev_select /dev/cdev-eeprom\\@2\nfile /dev/cdev-eeprom@2 opened\ngot 'K' from device!\ngot 'M' from device!\ngot 'O' from device!\ngot 'Q' from device!\n...\n```", "```\n...\ngot 'Y' from device!\ngot 'A' from device!\nTEST\ngot 'T' from stdin!\ngot 'E' from stdin!\ngot 'S' from stdin!\ngot 'T' from stdin!\ngot '\n' from stdin!\ngot 'C' from device!\ngot 'E' from device!\n...\n```", "```\nstatic const struct file_operations chrdev_fops = {\n    .owner   = THIS_MODULE,\n    .fasync  = chrdev_fasync,\n    .poll    = chrdev_poll,\n    .llseek  = no_llseek,\n    .read    = chrdev_read,\n    .open    = chrdev_open,\n    .release = chrdev_release\n};\n```", "```\nstatic int chrdev_fasync(int fd, struct file *filp, int on)\n{\n    struct chrdev_device *chrdev = filp->private_data;\n\n    return fasync_helper(fd, filp, on, &chrdev->fasync_queue);\n}\n```", "```\nstatic enum hrtimer_restart chrdev_timer_handler(struct hrtimer *ptr)\n{\n    struct chrdev_device *chrdev = container_of(ptr,\n                                    struct chrdev_device, timer);\n\n...\n    /* Wake up any possible sleeping process */\n    wake_up_interruptible(&chrdev->queue);\n    kill_fasync(&chrdev->fasync_queue, SIGIO, POLL_IN);\n\n    /* Now forward the expiration time and ask to be rescheduled */\n    hrtimer_forward_now(&chrdev->timer, ns_to_ktime(delay_ns));\n    return HRTIMER_RESTART;\n}\n```", "```\n    /* Try to install the signal handler and the fasync stuff */\n    sigh = signal(SIGIO, sigio_handler);\n    if (sigh == SIG_ERR) {\n            perror(\"signal\");\n            exit(EXIT_FAILURE);\n    }\n    ret = fcntl(fd, F_SETOWN, getpid());\n    if (ret < 0) {\n            perror(\"fcntl(..., F_SETOWN, ...)\");\n            exit(EXIT_FAILURE);\n    }\n    flags = fcntl(fd, F_GETFL);\n    if (flags < 0) {\n            perror(\"fcntl(..., F_GETFL)\");\n            exit(EXIT_FAILURE);\n    }\n    ret = fcntl(fd, F_SETFL, flags | FASYNC);\n    if (flags < 0) {\n            perror(\"fcntl(..., F_SETFL, ...)\");\n            exit(EXIT_FAILURE);\n    }\n```", "```\nvoid sigio_handler(int unused) {\n    char c;\n    int ret;\n\n    ret = read(fd, &c, 1);\n    if (ret < 0) {\n        perror(\"read\");\n        exit(EXIT_FAILURE);\n    }\n    ret = write(STDOUT_FILENO, &c, 1);\n    if (ret < 0) {\n        perror(\"write\");\n        exit(EXIT_FAILURE);\n    }\n}\n```", "```\n$ make CFLAGS=\"-Wall -O2 -Ichrdev/\" \\\n CC=aarch64-linux-gnu-gcc \\\n chrdev_fasync aarch64-linux-gnu-gcc -Wall -O2 chrdev_ioctl.c -o chrdev_fasync\n```", "```\n# ./chrdev_fasync /dev/cdev-eeprom\\@2 \nfile /dev/cdev-eeprom@2 opened\nQSUWYACEGI\n```", "```\n# ./chrdev_fasync /dev/cdev-eeprom\\@2 \nfile /dev/cdev-eeprom@2 opened\nQSUWYACEGIKMOQS....\ngot '.' from stdin!\ngot '.' from stdin!\ngot '.' from stdin!\ngot '.' from stdin!\ngot '\n' from stdin!\nUWYACE\n```"]