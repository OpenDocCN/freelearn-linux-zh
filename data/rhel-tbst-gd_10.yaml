- en: Chapter 10. Understanding Linux User and Kernel Limits
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。理解Linux用户和内核限制
- en: In the previous chapter, we used tools such as `lsof` and `strace` to identify
    the root cause of an application issue.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用了`lsof`和`strace`等工具来确定应用程序问题的根本原因。
- en: In this chapter, we will once again identify the root cause of an application-related
    issue. However, we will also focus on learning and understanding Linux user and
    kernel limitations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将再次确定应用程序相关问题的根本原因。但是，我们还将专注于学习和理解Linux用户和内核的限制。
- en: A reported issue
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个报告的问题
- en: Much like the previous chapter, which focused on an issue with a custom application,
    today's issue comes from the same custom application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一章专注于自定义应用程序的问题一样，今天的问题也来自同一个自定义应用程序。
- en: Today, we will be working on an issue reported by an application support team.
    However, this time the support team was able to provide us with quite a bit of
    information.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们将处理应用支持团队报告的一个问题。然而，这一次支持团队能够为我们提供相当多的信息。
- en: The application we were working on in [Chapter 9](part0061_split_000.html#1Q5IA1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 9. Using System Tools to Troubleshoot Applications"), *Using System Tools
    to Troubleshoot Applications*, now receives messages over `port 25` and stores
    them in a queue directory. Periodically, a job runs to process those queued messages,
    but the job *doesn't seem to be working anymore*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第9章](part0061_split_000.html#1Q5IA1-8ae10833f0c4428b9e1482c7fee089b4 "第9章。使用系统工具来排除应用程序问题")中处理的应用程序，*使用系统工具来排除应用程序问题*，现在通过`端口25`接收消息并将其存储在队列目录中。定期会运行一个作业来处理这些排队的消息，但是这个作业*似乎不再工作*。
- en: The application support team has noticed quite a large amount of messages backlogged
    in the queue. However, even though they have been troubleshooting the issue as
    much as possible, they are stuck and require our assistance.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 应用支持团队已经注意到队列中积压了大量消息。然而，尽管他们已经尽可能地排除了问题，但他们卡住了，需要我们的帮助。
- en: Why is the job failing?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么作业失败了？
- en: Since the issue being reported is that a scheduled job is not working, we should
    first focus on the job itself. In this scenario, we have the application support
    team available to answer any questions. So, let's get a few more details about
    this job.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于报告的问题是定时作业不起作用，我们应该首先关注作业本身。在这种情况下，我们有应用支持团队可以回答任何问题。所以，让我们再多了解一些关于这个作业的细节。
- en: Background questions
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景问题
- en: 'The following is a quick list of questions that should help provide you with
    additional information:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一系列快速问题，应该能够为您提供额外的信息：
- en: How is the job run?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作业是如何运行的？
- en: Can we run the job manually if we need to?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，我们可以手动运行作业吗？
- en: What does this job execute?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个作业执行什么？
- en: 'These three questions may seem pretty basic, but they are important. Let''s
    first look at the answers the application team provides:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个问题可能看起来很基础，但它们很重要。让我们首先看一下应用团队提供的答案：
- en: How is the job run?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作业是如何运行的？
- en: '*The job is executed as a cron job.*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*作业是作为cron作业执行的。*'
- en: Can we run the job manually if we need to?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，我们可以手动运行作业吗？
- en: '*Yes, it should be okay to execute the job manually as often as needed.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*是的，可以根据需要手动执行作业。*'
- en: What does this job execute?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个作业执行什么？
- en: '*The job executes the /opt/myapp/bin/processor command as the vagrant user*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*作业以vagrant用户身份执行/opt/myapp/bin/processor命令*。'
- en: The preceding three questions are important because they will save us quite
    a bit of troubleshooting time. The first question is focused on how the job is
    executed. Since the reported issue is that the job is not working, we don't know
    yet if the issue is because the job is not running or if the job is being executed
    but failing for some reason.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的三个问题很重要，因为它们将为我们节省大量的故障排除时间。第一个问题关注作业是如何执行的。由于报告的问题是作业不起作用，我们还不知道问题是因为作业没有运行还是作业正在执行但由于某种原因失败。
- en: The answer to the first question tells us that the job is executed by `crond`,
    which is the **cron daemon** that runs on Linux. This is useful as we can use
    this information to identify whether the job is being executed or not. In general,
    there are many methods for scheduled jobs to be executed. Sometimes the software
    that is executing the scheduled job runs on a different system and sometimes it
    runs on the same local system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题的答案告诉我们，这个作业是由在Linux上运行的**cron守护程序**`crond`执行的。这很有用，因为我们可以使用这些信息来确定作业是否正在执行。一般来说，有很多方法可以执行定时作业。有时执行定时作业的软件在不同的系统上运行，有时在同一个本地系统上运行。
- en: In this case, the job is being executed by `crond` on the same server.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，作业是由`crond`在同一台服务器上执行的。
- en: The second question is also important. Just like we had to launch the application
    manually in the last chapter, we may need to perform this troubleshooting step
    with this reported issue as well. Based on the answer, it seems we are free to
    execute this command as many times as needed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题也很重要。就像我们在上一章中需要手动启动应用程序一样，我们可能也需要对这个报告的问题执行这个故障排除步骤。根据答案，似乎我们可以根据需要多次执行这个命令。
- en: The third question is useful as it tells us not only what command is being executed
    but also which job to look out for. Cron jobs are a very common method of scheduling
    tasks. It is common for a system to have many cron jobs scheduled.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个问题很有用，因为它不仅告诉我们正在执行哪个命令，还告诉我们要注意哪个作业。cron作业是一种非常常见的调度任务的方法。一个系统通常会有许多已调度的cron作业。
- en: Is the cron job even running?
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cron作业是否在运行？
- en: 'Since we know that the job is being executed by `crond`, we should first check
    whether the job is being executed or not. To do this, we can check the cron logs
    on the server in question. For example, consider the following log:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道作业是由`crond`执行的，我们应该首先检查作业是否正在执行。为此，我们可以在相关服务器上检查cron日志。例如，考虑以下日志：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Specifically, on Red Hat based Linux systems we can check the `/var/log/cron`
    log file. I specified "Red Hat based" in the previous sentence because on non-Red-Hat-based
    systems the cron logs may be located in a different log file. Debian-based systems,
    for example, default to `/var/log/syslog`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在基于Red Hat的Linux系统上，我们可以检查`/var/log/cron`日志文件。我在前一句中指定了“基于Red Hat的”是因为在非Red
    Hat系统上，cron日志可能位于不同的日志文件中。例如，基于Debian的系统默认为`/var/log/syslog`。
- en: 'If we didn''t know which log file contained cron logs, there is a simple trick
    to find it. Just run the following command line:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不知道哪个日志文件包含cron日志，有一个简单的技巧可以找到它。只需运行以下命令行：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding command will use `grep` to search all of the log files in `/var/log`
    for the string `cron`. The command will also search for `Cron`, `CRON`, `cRon`,
    and so on, as we added the `–i` (insensitive) flag to the `grep` command. This
    tells `grep` to search in case-insensitivity mode. Essentially, this means any
    match of the word "cron" will be found even if the word is capitalized or mixed
    case. We also added the `–c` (count) flag to the `grep` command, which causes
    it to count the number of instances it has found:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将使用`grep`在`/var/log`中的所有日志文件中搜索字符串`cron`。该命令还将搜索`Cron`、`CRON`、`cRon`等，因为我们在`grep`命令中添加了`-i`（不区分大小写）标志。这告诉`grep`在不区分大小写的模式下搜索。基本上，这意味着任何匹配单词“cron”的地方都会被找到，即使单词是大写或混合大小写。我们还在`grep`命令中添加了`-c`（计数）标志，这会导致它计算它找到的实例数：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we look at the first result, we can see that `grep` has found 400 instances
    of the word "cron" in `/var/log/cron`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看第一个结果，我们可以看到`grep`在`/var/log/cron`中找到了400个“cron”单词的实例。
- en: Finally, we redirect the results to another `grep` command with the `–v` flag
    followed by `:0`. This `grep` will take the results of the first execution and
    omit (`-v`) any lines with the string `:0`. This is useful for restricting the
    results to only files with the `cron` string within them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将结果重定向到另一个带有`-v`标志和`:0`的`grep`命令。这个`grep`将获取第一次执行的结果，并省略（-v）任何包含字符串`:0`的行。这对于将结果限制为只有包含其中的`cron`字符串的文件非常有用。
- en: From the preceding results, we can see that the file, `/var/log/cron`, has the
    most instances of the word "cron" within it. This fact alone is a good indication
    that `/var/log/cron` is the log file for the `crond` daemon.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的结果中，我们可以看到文件`/var/log/cron`中包含了最多的“cron”单词实例。这一事实本身就是`/var/log/cron`是`crond`守护程序的日志文件的一个很好的指示。
- en: 'Now that we know which log file has the log messages we are looking for, we
    can take a look at the contents of that log file. Since this log file is quite
    large we will use the `less` command to read this file:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道哪个日志文件包含了我们正在寻找的日志消息，我们可以查看该日志文件的内容。由于这个日志文件非常大，我们将使用`less`命令来读取这个文件：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since there is quite a bit of information in this log, we will only focus on
    log entries that will help explain the issue. The following segment is an interesting
    group of log messages that should answer whether our job is running or not:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个日志中包含了相当多的信息，我们只会关注能帮助解释问题的日志条目。以下部分是一组有趣的日志消息，应该能回答我们的作业是否正在运行：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding log messages show quite a few lines. Let''s break down the logs
    to get a better understanding of what is being executed. Consider the following
    lines:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的日志消息显示了相当多的行。让我们分解日志以更好地理解正在执行的内容。考虑以下行：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first few lines do not seem to be the job we are searching for but rather
    the `cron.hourly` jobs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行似乎不是我们正在寻找的作业，而是`cron.hourly`作业。
- en: 'On Linux systems, there are multiple ways to specify cron jobs. On RHEL systems,
    there are several directories within `/etc/` that start with the name `cron`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux系统上，有多种方法可以指定cron作业。在RHEL系统上，`/etc/`目录下有几个以`cron`开头的目录：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `cron.daily`, `cron.hourly`, `cron.monthly`, and `cron.weekly` directories
    are all directories that can contain scripts. These scripts are to be run per
    the time specified in the directory name.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`cron.daily`、`cron.hourly`、`cron.monthly`和`cron.weekly`目录都是可以包含脚本的目录。这些脚本将按照目录名称中指定的时间运行。'
- en: 'For example, let''s look at `/etc/cron.hourly/0yum-hourly.cron`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看一下`/etc/cron.hourly/0yum-hourly.cron`：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding file is a simple `bash` script that the `crond` daemon will execute
    every hour, as it is in the `cron.hourly` directory. In general the scripts that
    are contained within these directories are put there by system services. However,
    these directories are also open to systems administrators to place their own scripts.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文件是一个简单的`bash`脚本，`crond`守护程序将每小时执行一次，因为它在`cron.hourly`目录中。一般来说，这些目录中包含的脚本是由系统服务放在那里的。不过，这些目录也对系统管理员开放，可以放置他们自己的脚本。
- en: User crontabs
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户crontabs
- en: 'If we continue down the log file, we can see an entry that is relevant to our
    custom job:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续查看日志文件，我们可以看到一个与我们自定义作业相关的条目：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This line shows the `processor` command that the application support team referenced.
    This line must be the job the application support team is having issues with.
    The log entry tells us quite a bit of useful information. For one, it provides
    us with the command line options being passed to this job:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行显示了应用支持团队引用的`processor`命令。这一行必须是应用支持团队遇到问题的作业。日志条目告诉我们很多有用的信息。首先，它为我们提供了传递给这个作业的命令行选项：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It also tells us the job is being executed as `vagrant`. The most important
    thing this log entry tells us though is that the job is being executed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 它还告诉我们作业是以`vagrant`身份执行的。不过，这个日志条目告诉我们最重要的是作业正在执行。
- en: 'Since we know the job is being executed, we should then verify if the job is
    successful. To do this we will take an easy approach and execute the job manually:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道作业正在执行，我们应该验证作业是否成功。为了做到这一点，我们将采取一种简单的方法，手动执行作业：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We should omit `> /dev/null` from the end of the cron task as this will redirect
    the output to `/dev/null`. This is a common way of throwing away the output of
    cron jobs. For this manual execution, we can utilize the output to help troubleshoot
    the issue.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该从cron任务的末尾省略`> /dev/null`，因为这将把输出重定向到`/dev/null`。这是一种常见的丢弃cron作业输出的方法。对于此手动执行，我们可以利用输出来帮助解决问题。
- en: 'Once executed, the job seems to fail. Not only does it fail, but it is also
    producing an error message along with the failure:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行，作业似乎会失败。它不仅失败了，而且还产生了一个错误消息：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This error is interesting, as it seems to suggest that the application is opening
    too many files. *Why would that matter?*
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误很有趣，因为它似乎表明应用程序打开了太多文件。*这有什么关系呢？*
- en: Understanding user limits
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解用户限制
- en: On Linux systems, there are limitations that every process is held to. These
    limits are in place to prevent processes from utilizing too many system resources.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux系统上，每个进程都受到限制。这些限制是为了防止进程使用太多的系统资源。
- en: 'While these limits are enforced on every user, it is possible, however, to
    set different limits per user. To check what limits are set on the `vagrant` user
    by default, we can use the `ulimit` command:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些限制适用于每个用户，但是可以为每个用户设置不同的限制。要检查`vagrant`用户默认设置的限制，我们可以使用`ulimit`命令：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When we executed the `ulimit` command, we did so as the vagrant user. This is
    important as when we run the `ulimit` command as any other user including root,
    the output will be the limits of that user.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行`ulimit`命令时，我们是以vagrant用户的身份执行的。这很重要，因为当我们以任何其他用户（包括root）的身份运行`ulimit`命令时，输出将是该用户的限制。
- en: If we look at the output of the `ulimit` command, we can see that there are
    quite a few limitations that can be set.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`ulimit`命令的输出，我们可以看到有很多可以设置的限制。
- en: The file size limit
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件大小限制
- en: 'Let''s take a look and breakdown a few key limits:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下并分解一些关键限制：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first interesting item is the `file size` limit. This limit will restrict
    how large a file the user can create. The current setting for the vagrant user
    is `unlimited` but what would happen if we set this value to a smaller number?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个有趣的项目是`文件大小`限制。这个限制将限制用户可以创建的文件的大小。vagrant用户的当前设置是`无限制`，但如果我们将这个值设置为一个较小的数字会发生什么呢？
- en: 'We can do this by executing `ulimit –f` followed by the number of blocks to
    limit the file to. For example, consider the following command line:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行`ulimit -f`，然后跟上要限制文件的块数来做到这一点。例如，考虑以下命令行：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After setting the value to `10` we can verify it took effect by running `ulimit
    –f` again, but this time with no value:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将值设置为`10`后，我们可以通过再次运行`ulimit -f`来验证它是否生效，但这次不带值：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that our limit is set to 10 blocks, let''s try to create a 500 MB file
    by using the `dd` command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的限制设置为10个块，让我们尝试使用`dd`命令创建一个500MB的文件：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: One nice thing about user limits on Linux is generally the errors provided are
    self-explanatory. We can see from the preceding output that not only was the `dd`
    command unable to create the file it received an error stating that the file,
    size limit was exceeded.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Linux用户限制的一个好处是通常提供的错误是不言自明的。我们可以从前面的输出中看到，`dd`命令不仅无法创建文件，还收到了一个错误，指出文件大小限制已超出。
- en: The max user processes limit
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最大用户进程限制
- en: 'Another interesting limit is the `max processes` limit:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的限制是`最大进程`限制：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This limit prevents a user from having *too many running processes* at one time.
    This is a very useful and interesting limitation as it can easily prevent a rogue
    application from taking over a system.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个限制防止用户一次运行*太多的进程*。这是一个非常有用和有趣的限制，因为它可以轻松地防止一个恶意应用程序接管系统。
- en: 'It can also be a limitation that you will often encounter. This is especially
    true for applications that launch many sub processes or threads. To see how this
    limitation works, we can change our setting to `10`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可能是您经常会遇到的限制。这对于启动许多子进程或线程的应用程序尤其如此。要查看此限制如何工作，我们可以将设置更改为`10`：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Like the file size limit, we can modify the process limit using the `ulimit`
    command. This time, however, we use the `-u` flag. Each user limit has its own
    unique flag with the `ulimit` command. We can see these flags in the output of
    `ulimit –a`, and of course, each flag is referenced in the man page for `ulimit`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与文件大小限制一样，我们可以使用`ulimit`命令修改进程限制。但这次，我们使用`-u`标志。每个用户限制都有自己独特的标志与`ulimit`命令。我们可以在`ulimit
    -a`的输出中看到这些标志，当然，每个标志都在`ulimit`的man页面中引用。
- en: 'Now that we have set our processes to be limited to `10`, we can see that limit
    enforced by running a command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经将我们的进程限制为`10`，我们可以通过运行一个命令来看到限制的执行：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By simply being logged into the vagrant user through SSH, we are already utilizing
    multiple processes. It will be quite easy to run into the limit of `10` processes
    as any new command we run will put our login over the limitation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过SSH登录vagrant用户，我们已经在使用多个进程。很容易遇到`10`个进程的限制，因为我们运行的任何新命令都会超出我们的登录限制。
- en: From the preceding example we can see that when the `man` command was executed,
    it was not able to start a child process and thus returned an error stating `Resource
    temporarily unavailable`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，我们可以看到当执行`man`命令时，它无法启动子进程，因此返回了一个错误，指出`资源暂时不可用`。
- en: The open files limit
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开文件限制
- en: 'The final interesting user limit that I want explore is the `open files` limit:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要探索的最后一个有趣的用户限制是`打开文件`限制：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `open files` limit will restrict a process from opening more than the defined
    number of files. This limit can be used to prevent a process from opening too
    many files at one time. This is something that can come in handy when preventing
    an application from consuming too many of the system's resources.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`打开文件`限制将限制进程打开的文件数不超过定义的数量。此限制可用于防止进程一次打开太多文件。当防止应用程序占用系统资源过多时，这是一种很有用的方法。'
- en: 'Like the other limits, let''s see what happens when we reduce this limit to
    a very unreasonable number:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他限制一样，让我们看看当我们将这个限制减少到一个非常不合理的数字时会发生什么：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As with the other examples, we received an error, `Too many open files`, in
    this case. However, this error looks quite familiar. If we were to look back at
    the error received from our scheduled job we will see why.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他示例一样，我们在这种情况下收到了一个错误，即`Too many open files`。但是，这个错误看起来很熟悉。如果我们回顾一下从我们的计划作业收到的错误，我们就会明白为什么。
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After setting our max number of open files to `2`, the `ls` command produced
    an error; the error has the same exact error message our application received
    when executed earlier.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的最大打开文件数设置为`2`后，`ls`命令产生了一个错误；这个错误与我们的应用程序之前执行时收到的完全相同的错误消息。
- en: Does this mean that our application is trying to open more files than our system
    is configured to allow? That is a strong possibility.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着我们的应用程序试图打开的文件比我们的系统配置允许的要多？这是一个很有可能的情况。
- en: Changing user limits
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改用户限制
- en: 'Since we suspect the `open files` limit is preventing the application from
    executing, we can set its limit to a higher value. However, this is not as simple
    as executing `ulimit –n`; the following output is what we get when it''s executed:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们怀疑`open files`限制阻止了应用程序的执行，我们可以将其限制设置为更高的值。但是，这并不像执行`ulimit -n`那样简单；执行时得到的输出如下：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By default, on our example system the highest the vagrant user is allowed to
    raise the `open files` limitation to is `4096`. As we can see from the preceding
    error, anything higher is denied; but like most things with Linux we can change
    this.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例系统上，默认情况下，vagrant用户被允许将`open files`限制提高到`4096`。从前面的错误中我们可以看到，任何更高的值都被拒绝；但是像大多数Linux一样，我们可以改变这一点。
- en: The limits.conf file
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: limits.conf文件
- en: The user limits that we have been using and modifying are part of Linux's PAM
    system. PAM or Pluggable Authentication Modules is a system that provides a modular
    authentication system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用和修改的用户限制是Linux的PAM系统的一部分。PAM或可插拔认证模块是一个提供模块化认证系统的系统。
- en: For example, if our system was to utilize LDAP for authentication, the `pam_ldap.so`
    library would be used to provide this functionality. However, since our system
    uses local users for authentication, the `pam_localuser.so` library handles the
    user authentication.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的系统要使用LDAP进行身份验证，`pam_ldap.so`库将用于提供此功能。但是，由于我们的系统使用本地用户进行身份验证，因此`pam_localuser.so`库处理用户身份验证。
- en: 'We can validate this if we read the `/etc/pam.d/system-auth` file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们阅读`/etc/pam.d/system-auth`文件，我们可以验证这一点：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we look at the preceding example, we can see that `pam_localuser.so` is
    listed with `account` as the first column:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下前面的例子，我们可以看到`pam_localuser.so`与`account`一起列在第一列：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This means the `pam_localuser.so` module is a `sufficient` module to allow an
    account to be utilized, which essentially means that the user is able to log in
    if they have a correct `/etc/passwd` and `/etc/shadow` entry.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`pam_localuser.so`模块是一个`sufficient`模块，允许账户被使用，这基本上意味着如果他们有正确的`/etc/passwd`和`/etc/shadow`条目，用户就能够登录。
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If we look at the preceding line, we can see where user limits are enforced.
    This line essentially tells the system that the `pam_limits.so` module is required
    for all user sessions. This effectively ensures that the user limits, which the
    `pam_limits.so` module identifies are enforced on each user session.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下前面的行，我们可以看到用户限制是在哪里执行的。这行基本上告诉系统`pam_limits.so`模块对所有用户会话都是必需的。这有效地确保了`pam_limits.so`模块识别的用户限制在每个用户会话上都得到执行。
- en: 'The configuration for this PAM module is located in `/etc/security/limits.conf`
    and `/etc/security/limits.d/`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个PAM模块的配置位于`/etc/security/limits.conf`和`/etc/security/limits.d/`中。
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When we read the `limits.conf` file, we can see quite a bit of useful information
    about user limits.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们阅读`limits.conf`文件时，我们可以看到关于用户限制的相当多有用的信息。
- en: 'Within this file, the available limitations are listed along with a description
    of what that limitation enforces. For example, in the preceding command lines,
    we can see the following for the number of `open files` limit:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，列出了可用的限制以及该限制强制执行的描述。例如，在前面的命令行中，我们可以看到`open files`限制的数量：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'From this line we can see that if we want to change the number of open files
    available to our user, we will need to use the `nofile` type. On top of listing
    what each limitation does, the `limits.conf` file also contains examples of setting
    custom limits for users and groups:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一行我们可以看到，如果我们想改变用户可用的打开文件数，我们需要使用`nofile`类型。除了列出每个限制的作用，`limits.conf`文件还包含了为用户和组设置自定义限制的示例：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Given this example we can see what format we need to use to set the limit;
    but what should we set the limitation too? If we look back at the error from our
    job, we can see that the error listed a file in the `/opt/myapp/queue` directory:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们可以看到我们需要使用什么格式来设置限制；但我们应该将限制设置为多少呢？如果我们回顾一下作业中的错误，我们会发现错误列出了`/opt/myapp/queue`目录中的一个文件：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It is safe to say that the application is trying to open the files within this
    directory. So, to determine how many files this process needs to have open, let''s
    find out how many files exist in this directory by using the following command
    line:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可以肯定地说，应用程序正在尝试打开此目录中的文件。因此，为了确定这个进程需要打开多少文件，让我们通过以下命令行找出这个目录中有多少文件存在：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding command uses `ls –la` to list all of the files and directories
    within the `queue/` directory and redirects that output to `wc –l`. The `wc` command
    will count the number of lines (`-l`) from the provided output, which essentially
    means that within the `queue/` directory, there are 492,304 files and/or directories.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令使用`ls -la`列出`queue/`目录中的所有文件和目录，并将输出重定向到`wc -l`。`wc`命令将从提供的输出中计算行数（`-l`），这基本上意味着在`queue/`目录中有492,304个文件和/或目录。
- en: 'Given the large number, we should set the number of `open files` limit to `500000`,
    enough to process the `queue/` directory with a little extra just in case. We
    can do this by appending the following line to the `limits.conf` file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于数量很大，我们应该将`打开文件`限制数量设置为`500000`，足以处理`queue/`目录，以防万一再多一点。我们可以通过将以下行附加到`limits.conf`文件来实现这一点：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After adding our line with `vi`, or another text editor, we can verify it is
    there with the `tail` command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`vi`或其他文本编辑器添加我们的行之后，我们可以使用`tail`命令验证它是否存在：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Changing these settings does not mean our login shell instantly has a limit
    of `500000`. Our logged in session still has a limitation of `4096` set.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 更改这些设置并不意味着我们的登录shell立即具有`500000`的限制。我们的登录会话仍然设置了`4096`的限制。
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We also still cannot increase it beyond that value.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还不能将其增加到该值以上。
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In order for our change to take effect, we must log in to our user once again.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的更改生效，我们必须再次登录到我们的用户。
- en: As we discussed earlier, these limitations are set by PAM, which is applied
    during the login of our shell session. Since the limitations are set during login,
    we are still being restricted by the previous values picked up when we last logged
    in.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，这些限制是由PAM设置的，在我们的shell会话登录期间应用。由于这些限制是在登录期间设置的，所以我们仍然受到上次登录时采用的先前数值的限制。
- en: To obtain the new limitations, we must log out and log back in (or spawn a new
    login session). For our examples, we will log out of our shell and log back in.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取新的限制，我们必须注销并重新登录（或生成一个新的登录会话）。在我们的例子中，我们将注销我们的shell并重新登录。
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If we look at the preceding command lines, we can see something quite interesting.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下前面的命令行，我们会发现一些非常有趣的东西。
- en: When we logged in this time, our number of files limitation was set to `100000`,
    which just happens to be the same limit we set as the `soft` limit in the `limits.conf`
    file. This happened because the `soft` limit is the limit set by default for each
    session.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这次登录时，我们的文件限制数量被设置为`100000`，这恰好是我们在`limits.conf`文件中设置的`soft`限制。这是因为`soft`限制是每个会话默认设置的限制。
- en: The `hard` limit is the highest value above the `soft` limit that this user
    can set. We can see this in action in the preceding example, as we were able to
    set the `nofile` limit to `500000` but not `501000`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`hard`限制是该用户可以设置的高于`soft`限制的最高值。我们可以在前面的例子中看到这一点，因为我们能够将`nofile`限制设置为`500000`，但不能设置为`501000`。'
- en: Future proofing the scheduled job
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未来保护定时作业
- en: The reason we set the `soft` limit to `100000` was because we are planning for
    similar scenarios in the future. With the `soft` limit set at `100000`, the cron
    job that runs this scheduled job will be limited to 100,000 open files. However,
    since the `hard` limit is set to `500000`, someone can then manually run the job
    with a higher limit set on their login session.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`soft`限制设置为`100000`的原因是因为我们计划在未来处理类似的情况。将`soft`限制设置为`100000`，运行这个定时作业的cron作业将被限制为100,000个打开文件。然而，由于`hard`限制设置为`500000`，某人可以在他们的登录会话中手动运行具有更高限制的作业。
- en: As long as the number of files in the `queue` directory does not exceed 500,000,
    there should no longer be a need for anyone to edit the `/etc/security/limits.conf`
    file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 只要`queue`目录中的文件数量不超过500,000，就不再需要任何人编辑`/etc/security/limits.conf`文件。
- en: Running the job again
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 再次运行作业
- en: Now that our limitations have been increased, we can try to run the job again.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的限制已经增加，我们可以尝试再次运行作业。
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once again we received an error. However, this time the error is just a little
    bit different.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次收到了一个错误。然而，这次错误略有不同。
- en: In the previous run, we received the following error.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一次运行中，我们收到了以下错误。
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: However, this time we received this error.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这一次我们收到了这个错误。
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The difference is extremely subtle, but in the second run our error stated **Too
    many open files in system**, whereas our first run did not include `in system`.
    The reason for this is because we hit a different type of limitation, not a **user**
    limitation, but a **system** limitation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异非常微妙，但在第二次运行时，我们的错误说明了**系统中打开的文件太多**，而我们第一次运行时没有包括`in system`。这是因为我们遇到了不同类型的限制，不是**用户**限制，而是**系统**限制。
- en: Kernel tunables
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核可调参数
- en: The Linux Kernel itself can set limitations on a system as well. These limits
    are defined based on kernel parameters. Some of these parameters are static and
    cannot be changed during runtime; while others can. When a kernel parameter can
    be changed during runtime this is called a **tunable parameter**.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核本身也可以对系统设置限制。这些限制是基于内核参数定义的。其中一些参数是静态的，不能在运行时更改；而其他一些可以。当内核参数可以在运行时更改时，这被称为**可调参数**。
- en: 'We can see both static and tunable kernel parameters and their current values
    by using the `sysctl` command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`sysctl`命令查看静态和可调内核参数及其当前值。
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Since there are many parameters available, I used the `head` command to limit
    the output to the first 10\. The error we received earlier mentioned a limitation
    on the system, this suggests we may be hitting a limit imposed by the kernel itself.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有许多参数可用，我使用`head`命令将输出限制为前10个。我们之前收到的错误提到了系统上的限制，这表明我们可能遇到了内核本身施加的限制。
- en: The only problem is how do we know which one? The fastest answer of course is
    to search Google. Since there are so many kernel parameters (800+ on the system
    we are working on), it is difficult to simply read the output of `sysctl –a` and
    find the right one.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是我们如何知道哪一个？最快的答案当然是搜索谷歌。由于有很多内核参数（我们正在使用的系统上有800多个），简单地阅读`sysctl –a`的输出并找到正确的参数是困难的。
- en: A more realistic approach is to simply search for the type of parameter we are
    looking to modify. An example search for our scenario would be `Linux parameter
    max open files`. If we were to perform this search we will most likely find the
    parameter and how to modify it. If Google is not an option however, there is another
    way.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更现实的方法是简单地搜索我们要修改的参数类型。我们的情况下，一个例子搜索可能是`Linux参数最大打开文件数`。如果我们进行这样的搜索，很可能会找到参数以及如何修改它。然而，如果谷歌不是一个选择，还有另一种方法。
- en: In general, the kernel parameters have a name that describes what the parameter
    controls.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，内核参数的名称描述了参数控制的内容。
- en: 'For example, if we were to look for the kernel parameter that disables IPv6
    we would first start by searching for the `net` string, as in network:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们要查找禁用IPv6的内核参数，我们首先会搜索`net`字符串，如网络：
- en: '[PRE41]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: However, this still returns a large number of results. Within those results,
    we can see the string `ipv6` though.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仍然返回了大量结果。在这些结果中，我们可以看到字符串`ipv6`。
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Still, quite a few results; however, we get the following output if we add
    a search for the string `disable`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，还是有相当多的结果；但是，如果我们添加一个搜索字符串`disable`，我们会得到以下输出：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can finally narrow down the possible parameters. However, we do not fully
    know what these parameters do. Not yet, at least.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于可以缩小可能的参数范围。但是，我们还不完全知道这些参数的作用。至少目前还不知道。
- en: 'If we perform a quick search through `/usr/share/doc`, we might find a few
    documents that explain what these settings do. We can do this quickly by performing
    a recursive search for `-r` through this directory using `grep`. In order to keep
    the output simple, we can add `-l` (list file), which causes `grep` to only list
    the filenames it finds the desired string within:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过`/usr/share/doc`进行快速搜索，可能会找到一些解释这些设置作用的文档。我们可以通过使用`grep`在该目录中进行递归搜索来快速完成这个过程。为了保持输出简洁，我们可以添加`-l`（列出文件），这会导致`grep`只列出包含所需字符串的文件名：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: On Red Hat based Linux systems, the `/usr/share/doc` directory is used for additional
    documentation outside of the system's man pages. If we were limited to only utilizing
    the documentation on the system itself, the `/usr/share/doc` directory is one
    of the first places to check.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Red Hat的Linux系统中，`/usr/share/doc`目录用于系统手册之外的额外文档。如果我们只能使用系统本身的文档，`/usr/share/doc`目录是首要检查的地方之一。
- en: Finding the kernel parameter for open files
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找打开文件的内核参数
- en: Since we like performing tasks the hard way, we will try to identify the kernel
    parameter that is potentially limiting us without searching for it on Google.
    The first step to do this will be to search the `sysctl` output for the string
    `file`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们喜欢用较困难的方式执行任务，我们将尝试识别潜在限制我们的内核参数，而不是在Google上搜索。这样做的第一步是在`sysctl`输出中搜索字符串`file`。
- en: 'The reason we are searching for `file` is because we are hitting a limitation
    on the number of files. While this may not provide the exact parameter we are
    trying to identify, the search at least is going to get us started:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们搜索`file`的原因是因为我们遇到了文件数量的限制。虽然这可能不会提供我们要识别的确切参数，但至少搜索会让我们有个起点：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Searching for `file` may have actually been a very good choice after all. Simply
    based on the names of the parameters, the two that may be interesting to us are
    `fs.file-max` and `fs.file-nr`. At this point, we do not know which one controls
    the number of open files or if either of these do.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，搜索`file`可能实际上是一个非常好的选择。仅仅根据参数的名称，对我们可能感兴趣的两个参数是`fs.file-max`和`fs.file-nr`。在这一点上，我们不知道哪一个控制打开文件的数量，或者这两个参数是否有任何作用。
- en: To find out more information we can search through the `doc` directory.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多信息，我们可以搜索`doc`目录。
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It seems that a document named `TUNING_README`, located in the Postfix services
    documentation, has a reference to at least one of our values. Let''s check out
    the file to see what this document says about this kernel parameter:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来一个名为`TUNING_README`的文档，位于Postfix服务文档中，提到了我们至少一个值的参考。让我们查看一下文件，看看这个文档对这个内核参数有什么说法：
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If we read the contents of the file around where it lists our kernel parameter,
    we can see that it specifically calls out parameters to *configure the kernel
    for more open files and sockets*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们阅读文件中列出我们的内核参数周围的内容，我们会发现它明确指出了*配置内核以获得更多打开文件和套接字*的参数。
- en: This document calls out two kernel parameters to allow for more open files and
    sockets. The first is called `fs.file-max`, which is one we also identified with
    our `sysctl` search. The second is called `kernel.threads-max`, which is fairly
    new.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文档列出了两个内核参数，允许更多的打开文件和套接字。第一个被称为`fs.file-max`，这也是我们在`sysctl`搜索中识别出的一个。第二个被称为`kernel.threads-max`，这是相当新的。
- en: 'Simply based on the names, it seems the tunable parameter we want to modify
    is the `fs.file-max` parameter. Let''s take a look at its current value as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅根据名称，似乎我们想要修改的可调参数是`fs.file-max`参数。让我们看一下它的当前值：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We can list the current value of this parameter by executing `sysctl` followed
    by the parameter name (as shown in the preceding command lines). This will simply
    display the value as it is defined currently; which seems to be set at `48582`
    a number far lower than our current user limits.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行`sysctl`命令，后跟参数名称（如前面的命令行所示）来列出此参数的当前值。这将简单地显示当前定义的值；看起来设置为`48582`，远低于我们当前的用户限制。
- en: Tip
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In the preceding example, we found this parameter in a postfix document. While
    this may be good, it is not exact. If you often find yourself needing to search
    locally for kernel parameters, it would be a good idea to install the `kernel-doc`
    package. The `kernel-doc` package contains quite a bit of information, especially
    about tunables.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在一个postfix文档中找到了这个参数。虽然这可能很好，但并不准确。如果您经常需要在本地搜索内核参数，最好安装`kernel-doc`软件包。`kernel-doc`软件包包含了大量信息，特别是关于可调参数的信息。
- en: Changing kernel tunables
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改内核可调参数
- en: Since we believe the `fs.file-max` parameter controls the maximum number of
    open files a system can have, we should change this value to allow our job to
    run.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们认为`fs.file-max`参数控制系统可以打开的最大文件数，我们应该更改这个值以允许我们的作业运行。
- en: Like most system configuration items on Linux, there is the option to change
    this value ad-hoc and on reboot. Earlier we set the `limits.conf` file to allow
    the vagrant user the ability to open 100,000 files as a `soft` limit and 500,000
    as a `hard` limit. The question is do we want this user to be able to open 500,000
    files as a normal operation? Or should this be a one-time task to correct the
    issue we are currently facing?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数Linux上的系统配置项一样，有更改此值的临时和重新启动的选项。之前我们将`limits.conf`文件设置为允许vagrant用户能够以`软`限制打开100,000个文件，以`硬`限制打开500,000个文件。问题是我们是否希望这个用户能够正常操作打开500,000个文件？还是应该是一次性任务来纠正我们目前面临的问题？
- en: 'The answer is simply: *it depends!*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单：*这取决于情况！*
- en: If we look at the situation we are working on currently, the job in question
    has not been run for quite a while. Because of this there is a large backlog of
    messages in the queue. However, these are not normal conditions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下我们目前正在处理的情况，所讨论的工作已经有一段时间没有运行了。因此，队列中积压了大量的消息。但是这些并不是正常的情况。
- en: Earlier when we set the user limit to 100,000 files, we did so as this is a
    somewhat appropriate value for this job. With this considered, we should also
    set the kernel parameter to a value slightly over `100000` but not too far over.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，当我们将用户限制设置为100,000个文件时，我们这样做是因为这对于这个作业来说是一个相当合适的值。考虑到这一点，我们还应该将内核参数设置为略高于`100000`的值，但不要太高。
- en: For this scenario and in this environment, we are going to perform two actions.
    The first is to configure the system to allow for *125,000 open files by default*.
    The second is to set the current parameter to *525,000 open files* to allow the
    scheduled job to run successfully.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况和环境，我们将执行两个操作。第一个是配置系统默认允许*125,000个打开文件*。第二个是将当前参数设置为*525,000个打开文件*，以便成功运行预定的作业。
- en: Permanently changing a tunable
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 永久更改可调整的值
- en: Since we want to change the value of `fs.file-max` to `125000` by default, we
    will need to edit the `sysctl.conf` file. The `sysctl.conf` file is a system configuration
    file, which allows you to specify custom values for tunable kernel parameters.
    During every reboot of the system, this file is read and the values within it
    are applied.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要将`fs.file-max`的值默认更改为`125000`，我们需要编辑`sysctl.conf`文件。`sysctl.conf`文件是一个系统配置文件，允许您为可调整的内核参数指定自定义值。在系统每次重新启动时，该文件都会被读取并应用其中的值。
- en: 'In order to set our `fs.file-max` value to `125000` we can simply append the
    following line to this file:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的`fs.file-max`值设置为`125000`，我们只需将以下行追加到这个文件中：
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now that we have added our custom value, we will need to tell the system to
    apply it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了我们的自定义值，我们需要告诉系统应用它。
- en: As mentioned earlier, the `sysctl.conf` file is applied on reboot, however we
    can also apply the settings to this file at any time using the `sysctl` command
    with the `–p` flag.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`sysctl.conf`文件在重新启动时生效，但是我们也可以随时使用`sysctl`命令和`-p`标志将设置应用到这个文件。
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When given the `–p` flag, the `sysctl` command will read and apply the values
    to the file specified, or if no file is specified `/etc/sysctl.conf`. Since we
    did not specify a file after the `–p` flag, the `sysctl` command applied the values
    added to `/etc/sysctl.conf` and printed the values it modified.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`-p`标志后，`sysctl`命令将读取并将值应用到指定的文件，或者如果没有指定文件，则应用到`/etc/sysctl.conf`。由于我们在`-p`标志后没有指定文件，`sysctl`命令将应用到`/etc/sysctl.conf`中添加的值，并打印修改的值。
- en: Let's validate it was applied appropriately by executing `sysctl` again.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过再次执行`sysctl`来验证它是否被正确应用。
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: It appears that in fact the value was applied appropriately, but what about
    setting it to `525000`?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，似乎值已经被正确应用了，但是将它设置为`525000`呢？
- en: Temporarily changing a tunable
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 临时更改可调整的值
- en: While it may be simple enough to change the `/etc/sysctl.conf` to a higher value,
    apply it, and then revert the change. There is a much easier way to change a tunable's
    value temporarily.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然更改`/etc/sysctl.conf`到一个更高的值，然后应用并恢复更改可能很简单。但是有一个更简单的方法可以临时更改可调整的值。
- en: The `sysctl` command, when provided with the `–w` option, will allow modification
    of tunable values. To see this in action, we will use this to set the `fs.file-max`
    value to `525000`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供`-w`选项时，`sysctl`命令允许修改可调整的值。为了看到这一点，我们将使用它将`fs.file-max`值设置为`525000`。
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Like when we applied the `sysctl.conf` file''s values, when we executed `sysctl
    –w` it printed the values it applied. If we validate them again, we will see the
    value is set to `525000` files:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们应用`sysctl.conf`文件的值一样，当我们执行`sysctl –w`时，它打印了应用的值。如果我们再次验证它们，我们会看到值被设置为`525000`个文件：
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Running the job one last time
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最后再次运行作业
- en: 'Now that we have set our `open files` limit to `500000` for the vagrant user
    and `525000` on the system as a whole. We can execute this job manually one more
    time, and this time it should be successful:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将vagrant用户的`打开文件`限制设置为`500000`，整个系统设置为`525000`。我们可以再次手动执行这个作业，这次应该会成功：
- en: '[PRE54]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This time the job executed without providing any errors! We can see from the
    output of the job that all of the files in `/opt/myapp/queue` were processed as
    well.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这次作业执行时没有提供任何错误！我们可以从作业的输出中看到`/opt/myapp/queue`中的所有文件都被处理了。
- en: A look back
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾一下
- en: Now that we have resolved the issue, let's take a second to look at what we
    did to resolve the issue.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解决了问题，让我们花点时间看看我们是如何解决这个问题的。
- en: Too many open files
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开文件太多
- en: In order to troubleshoot our issue, we executed a scheduled cron job manually.
    If we circle back to previous chapters, this is a prime example of duplicating
    an issue and seeing it for ourselves.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了排除我们的问题，我们手动执行了一个预定的cron作业。如果我们回顾之前的章节，这是一个复制问题并亲自看到的一个典型例子。
- en: In this case, the job was not performing the tasks it was supposed to. In order
    to identify the reason, we ran it manually.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，作业没有执行它应该执行的任务。为了找出原因，我们手动运行了它。
- en: 'During that manual execution, we were able to identify the following error:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在手动执行期间，我们能够识别出以下错误：
- en: '[PRE55]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This error is very common and is caused by the job running into user limits
    that prevent a single user from opening too many files. To resolve this we added
    custom settings to the `/etc/security/limits.conf` file.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误非常常见，是由作业超出用户限制而导致的，该限制阻止单个用户打开太多文件。为了解决这个问题，我们在`/etc/security/limits.conf`文件中添加了自定义设置。
- en: 'These changes set the `soft` limitation of `open files` to `100000` for our
    user by default. We also allowed the user to increase the `open files` limit to
    `500000` on an ad-hoc basis via the `hard` setting:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改将我们用户的“打开文件”限制默认设置为`100000`。我们还允许用户通过`hard`设置临时将“打开文件”限制增加到`500000`：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: After modifying these limits, we executed the job again and experienced a similar
    but different error.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 修改这些限制后，我们再次执行了作业，并遇到了类似但不同的错误。
- en: This time the `open files` limitation was being imposed on the system itself,
    which in this case imposed a system-wide limit of 48,000 open files.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，“打开文件”限制是系统本身施加的，这种情况下对系统施加了全局限制，即48000个打开文件。
- en: To resolve this we set a permanent setting of `125000` in the `/etc/sysctl.conf`
    file and temporarily changed the value to `525000`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们在`/etc/sysctl.conf`文件中设置了永久设置为`125000`，并临时将该值更改为`525000`。
- en: From that point we were able to execute the job manually. Beyond this instance
    however, since we changed the default limitations we also gave this job more resources
    to execute normally. As long as there is not a backlog of greater than 100,000
    files this job should execute without issue in the future.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，我们能够手动执行作业。然而，自从我们改变了默认限制以来，我们还为这个作业提供了更多资源以正常执行。只要没有超过10万个文件的积压，这个作业将来都应该能够正常执行。
- en: A bit of clean up
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稍微整理一下。
- en: Speaking of normal executions, in order to reduce the kernel's limitation of
    open files we can execute the `sysctl` command again with the `–p` option. This
    will reset the value to the defined value within the `/etc/sysctl.conf` file.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 说到正常执行，为了减少内核对打开文件的限制，我们可以再次执行`sysctl`命令，并加上`-p`选项。这将把值重置为`/etc/sysctl.conf`文件中定义的值。
- en: '[PRE57]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: One caveat to this method is that `sysctl -p` will only reset the values specified
    in `/etc/sysctl.conf`; *which only contains a handful of tunable values by default*.
    If a value not specified in `/etc/sysctl.conf` is modified, the `sysctl -p` method
    will not reset this value to default.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个注意事项是，`sysctl -p`只会重置`/etc/sysctl.conf`中指定的值；*默认情况下只包含少量可调整的值*。如果修改了`/etc/sysctl.conf`中未指定的值，`sysctl
    -p`方法将不会将该值重置为默认值。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we became very familiar with the kernel and user limitations
    enforced within Linux. These settings become very useful as any application that
    utilizes many resources will eventually run into one of these.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对Linux中强制执行的内核和用户限制非常熟悉。这些设置非常有用，因为任何利用许多资源的应用程序最终都会遇到其中之一。
- en: In the next chapter, we will be focusing on a very common but very tricky issue.
    We will focus on troubleshooting and identifying the cause of a system running
    out of memory. When a system runs out of memory, there are a lot of consequences
    such as application processes being killed.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于一个非常常见但非常棘手的问题。我们将专注于故障排除和确定系统内存耗尽的原因。当系统内存耗尽时，会有很多后果，比如应用程序进程被终止。
