- en: Chapter 12. Debugging with GDB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。使用GDB进行调试
- en: Bugs happen. Identifying and fixing them is part of the development process.
    There are many different techniques for finding and characterizing program defects,
    including static and dynamic analysis, code review, tracing, profiling, and interactive
    debugging. I will look at tracers and profilers in the next chapter, but here
    I want to concentrate on the traditional approach of watching code execution through
    a debugger, in our case, the **GNU debugger**, **GDB**. GDB is a powerful and
    flexible tool. You can use it to debug applications, examine the postmortem files
    (`core` files) that are created after a program crash, and even step through kernel
    code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是难免的。识别和修复它们是开发过程的一部分。有许多不同的技术用于查找和表征程序缺陷，包括静态和动态分析，代码审查，跟踪，性能分析和交互式调试。我将在下一章中介绍跟踪器和性能分析器，但在这里，我想集中讨论通过调试器观察代码执行的传统方法，也就是我们的情况下的GNU调试器GDB。GDB是一个强大而灵活的工具。您可以使用它来调试应用程序，检查程序崩溃后生成的后期文件（`core`文件），甚至逐步执行内核代码。
- en: In this chapter, I will show you how to use GDB to debug applications, how to
    look at core files and how to debug kernel code, in all cases, emphasizing the
    aspects that are relevant for embedded Linux.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将向您展示如何使用GDB调试应用程序，如何查看核心文件以及如何调试内核代码，重点是与嵌入式Linux相关的方面。
- en: The GNU debugger
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GNU调试器
- en: GDB is a source-level debugger for the compiled languages, primarily C and C++,
    although there is also support for a variety of other languages such as Go and
    Objective. You should read the notes for the version of GDB you are using to find
    out the current status of support for the various languages. The project website
    is [http://www.gnu.org/software/gdb](http://www.gnu.org/software/gdb) and contains
    a lot of useful information, including the GDB manual.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: GDB是用于编译语言的源级调试器，主要用于C和C++，尽管也支持各种其他语言，如Go和Objective。您应该阅读您正在使用的GDB版本的说明，以了解对各种语言的支持的当前状态。项目网站是[http://www.gnu.org/software/gdb](http://www.gnu.org/software/gdb)，其中包含了许多有用的信息，包括GDB手册。
- en: Out of the box, GDB has a command-line user interface which some people find
    off-putting although, in reality, it is easy to use with a little practice. If
    command-line interfaces are not to your liking, there are a lot of front-end user
    interfaces to GDB and I will describe three of them later.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: GDB默认具有命令行用户界面，有些人可能会觉得这个界面令人望而却步，但实际上，只要稍加练习，就会发现它很容易使用。如果您不喜欢命令行界面，那么有很多GDB的前端用户界面可供选择，我稍后会描述其中的三个。
- en: Preparing to debug
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备调试
- en: 'You need to compile the code you want to debug with debug symbols. GCC offers
    two options for this: `-g` and `-ggdb`. The latter adds debug information that
    is specific to GDB, whereas the former generates information in an appropriate
    format for whichever target operating system you are using, making it the more
    portable option. In our particular case, the target operating system is always
    Linux and it makes little difference whether you use `-g` or `-ggdb`. Of more
    interest is the fact that both options allow you to specify the level of debug
    information, from 0 to 3:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用调试符号编译要调试的代码。GCC提供了两个选项：`-g`和`-ggdb`。后者添加了特定于GDB的调试信息，而前者生成了适合您使用的目标操作系统的适当格式的信息，使其更具可移植性。在我们的特定情况下，目标操作系统始终是Linux，无论您使用`-g`还是`-ggdb`都没有太大区别。更有趣的是，这两个选项都允许您指定调试信息的级别，从0到3：
- en: '0: This produces no debug information at all and is equivalent to omitting
    the `-g` or `-ggdb` switch'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0：这根本不生成调试信息，等同于省略`-g`或`-ggdb`开关
- en: '1: This produces little information but which includes function names and external
    variables which is enough to generate a back trace'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1：这产生的信息很少，但包括函数名称和外部变量，足以生成回溯
- en: '2: This is the default and includes information about local variables and line
    numbers so that you can do source level debugging and a single step through the
    code'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2：这是默认设置，包括有关局部变量和行号的信息，以便您可以进行源级调试并逐步执行代码
- en: '3: This includes extra information which, among other things, means that GDB
    handles macro expansions correctly'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3：这包括额外的信息，其中包括GDB正确处理宏扩展
- en: In most cases, `-g` suffices but reserve `-g3` or `-ggdb3` if you are having
    problems stepping through code, especially if it contains macros.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`-g`足够了，但如果您在通过代码时遇到问题，特别是如果它包含宏，那么请保留`-g3`或`-ggdb3`。
- en: The next issue to consider is the level of code optimization. Compiler optimization
    tends to destroy the relationship between lines of source code and machine code,
    which makes stepping through the source unpredictable. If you experience problems
    like this you will most likely need to compile without optimization, leaving out
    the `-O` compile switch, or at least reduce it to level 1, using the compile switch
    `-O1`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要考虑的下一个问题是代码优化级别。编译器优化往往会破坏源代码和机器代码之间的关系，这使得通过源代码进行步进变得不可预测。如果您遇到这样的问题，您很可能需要在不进行优化的情况下进行编译，省略`-O`编译开关，或者至少将其降低到级别1，使用编译开关`-O1`。
- en: 'A related issue is that of stack frame pointers, which are needed by GDB to
    generate a back trace of function calls up to the current one. On some architectures,
    GCC will not generate stack frame pointers with higher levels of optimization
    (`-O2`). If you find yourself in the situation that you really have to compile
    with `-O2` but still want back traces, you can override the default behavior with
    `-fno-omit-frame-pointer`. Also look out for code that has been hand optimized
    to leave out frame pointers through the addition of `-fomit-frame-pointer`: you
    may want to temporarily remove them.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的问题是堆栈帧指针，GDB需要它们来生成当前函数调用的回溯。在某些架构上，GCC不会在更高级别的优化（`-O2`）中生成堆栈帧指针。如果您发现自己确实需要使用`-O2`进行编译，但仍然希望进行回溯，您可以使用`-fno-omit-frame-pointer`来覆盖默认行为。还要注意一下手动优化的代码，通过添加`-fomit-frame-pointer`来省略帧指针：您可能需要暂时将它们移除。
- en: Debugging applications using GDB
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GDB调试应用程序
- en: You can use GDB to debug applications in one of two ways. If you are developing
    code to run on desktops and servers, or indeed any environment where you compile
    and run the code on the same machine, it is natural to run GDB natively. However,
    most embedded development is done using a cross toolchain and hence you want to
    debug code running on the device, but control it from the cross-development environment
    where you have the source code and the tools. I will focus on the latter case
    since it is not so well documented and yet it is the most likely scenario for
    embedded developers. I am not going to describe the basics of using GDB here since
    there are many good references on that topic already, including the GDB manual
    and the suggested further reading at the end of the chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用GDB以两种方式调试应用程序。如果您正在开发要在台式机和服务器上运行的代码，或者在任何编译和运行代码在同一台机器上的环境中运行代码，那么自然会本地运行GDB。然而，大多数嵌入式开发都是使用交叉工具链进行的，因此您希望调试在设备上运行的代码，但是要从具有源代码和工具的交叉开发环境中控制它。我将专注于后一种情况，因为它没有得到很好的记录，但它是嵌入式开发人员最有可能遇到的情况。我不打算在这里描述使用GDB的基础知识，因为已经有许多关于该主题的良好参考资料，包括GDB手册和本章末尾建议的进一步阅读。
- en: I will begin with some details on working with gdbserver and then show you how
    to configure the Yocto Project and Buildroot for remote debug.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从一些关于使用gdbserver的细节开始，然后向您展示如何配置Yocto项目和Buildroot进行远程调试。
- en: Remote debugging using gdbserver
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用gdbserver进行远程调试
- en: The key component for remote debugging is the debug agent, gdbserver, which
    runs on the target and controls execution of the program being debugged. Gdbserver
    connects to a copy of GDB running on the host machine via a network connection
    or an RS-232 serial interface.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 远程调试的关键组件是调试代理gdbserver，它在目标上运行并控制正在调试的程序的执行。Gdbserver通过网络连接或RS-232串行接口连接到在主机上运行的GDB的副本。
- en: 'Debugging through gdbserver is almost, but not quite, the same as debugging
    natively. The differences are mostly centered around the fact that there are two
    computers involved and they have to be in the right state for debugging to take
    place. Here are some things to look out for:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过gdbserver进行调试几乎与本地调试相同，但并非完全相同。区别主要集中在涉及两台计算机并且它们必须处于正确状态以进行调试。以下是一些需要注意的事项：
- en: At the start of a debug session you need to load the program you want to debug
    on the target using gdbserver and then separately load GDB from your cross toolchain
    on the host.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调试会话开始时，您需要使用gdbserver在目标上加载要调试的程序，然后在主机上使用交叉工具链中的GDB单独加载GDB。
- en: GDB and gdbserver need to connect to each other before a debug session can begin.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB和gdbserver需要在调试会话开始之前相互连接。
- en: GDB, running onto the host, needs to be told where to look for debug symbols
    and source code, especially for shared libraries.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主机上运行的GDB需要告诉它在哪里查找调试符号和源代码，特别是对于共享库。
- en: The GDB `run` command does not work as expected.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB的`run`命令无法按预期工作。
- en: gdbserver will terminate when the debug session ends and you will need to restart
    it if you want another debug session.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gdbserver在调试会话结束时将终止，如果您想要另一个调试会话，您需要重新启动它。
- en: You need debug symbols and source code for the binaries you want to debug on
    the host, but not necessarily on the target. Often there is not enough storage
    space for them on the target and they will need to be stripped before deploying
    to the target.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要在主机上为要调试的二进制文件获取调试符号和源代码，但不一定需要在目标上。通常目标上没有足够的存储空间，因此在部署到目标之前需要对它们进行剥离。
- en: 'The GDB/gdbserver combination does not have all the features of GDB running
    natively: for example, gdbserver cannot follow the child after `fork()` whereas
    native GDB can.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GDB/gdbserver组合不具有本地运行的GDB的所有功能：例如，gdbserver无法在`fork()`后跟随子进程，而本地GDB可以。
- en: Odd things can happen if GDB and gdbserver are different versions or are the
    same version but configured differently. Ideally they should be built from the
    same source using your favorite build tool.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果GDB和gdbserver是不同版本或者是相同版本但配置不同，可能会发生一些奇怪的事情。理想情况下，它们应该使用您喜欢的构建工具从相同的源构建。
- en: 'Debug symbols increase the size of executables dramatically, sometimes by a
    factor of 10\. As mentioned in [Chapter 5](ch05.html "Chapter 5. Building a Root
    Filesystem"), *Building a Root Filesystem*, it can be useful to remove debug symbols
    without recompiling everything. The tool for the job is strip from your cross
    toolchain. You can control the aggressiveness of the strip with these switches:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 调试符号会显著增加可执行文件的大小，有时会增加10倍。如[第5章](ch05.html "第5章。构建根文件系统")中所述，*构建根文件系统*，可以在不重新编译所有内容的情况下删除调试符号。这项工作的工具是您交叉工具链中的strip。您可以使用以下开关来控制strip的侵略性：
- en: '`--strip-all`: (default) removes all symbols'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--strip-all`：（默认）删除所有符号'
- en: '`--strip-unneeded`: removes symbols not needed for relocation processing'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--strip-unneeded`：删除不需要进行重定位处理的符号'
- en: '`--strip-debug`: removes only debug symbols'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--strip-debug`：仅删除调试符号'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For applications and shared libraries, `--strip-all` (the default) is fine,
    but when it comes to kernel modules you will find that it will stop the module
    loading. Use `--strip-unneeded` instead. I am still working on a use case for
    `–strip-debug`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序和共享库，`--strip-all`（默认）是可以的，但是对于内核模块，您会发现它会阻止模块加载。改用`--strip-unneeded`。我仍在研究`–strip-debug`的用例。
- en: With that in mind, let's look at the specifics involved in debugging with the
    Yocto Project and Buildroot.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们看看在Yocto项目和Buildroot中进行调试涉及的具体内容。
- en: Setting up the Yocto Project
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Yocto项目
- en: 'The Yocto Project builds a cross GDB for the host as part of the SDK, but you
    will have to make changes to your target configuration to include gdbserver in
    the target image. You can add the package explicitly, for example by adding this
    to `conf/local.conf`, noting once again that there must be a leading space at
    the start of this string:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto项目在SDK的一部分中为主机构建了交叉GDB，但是您需要对目标配置进行更改以在目标映像中包含gdbserver。您可以显式添加该软件包，例如通过将以下内容添加到`conf/local.conf`，再次注意这个字符串的开头必须有一个空格：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or, you can `add tools-debug` to `EXTRA_IMAGE_FEATURES`, which will add both
    gdbserver and strace to the target image (I will talk about `strace` in the next
    chapter):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以将`tools-debug`添加到`EXTRA_IMAGE_FEATURES`中，这将同时将gdbserver和strace添加到目标映像中（我将在下一章中讨论`strace`）：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Setting up Buildroot
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Buildroot
- en: 'With Buildroot, you need to enable options both to build the cross GDB for
    the host (assuming that you are using the Buildroot internal toolchain) and to
    build gdbserver for the target. Specifically you need to enable:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Buildroot，您需要同时启用选项来为主机构建交叉GDB（假设您正在使用Buildroot内部工具链），并为目标构建gdbserver。具体来说，您需要启用：
- en: '`BR2_PACKAGE_HOST_GDB`, in the menu **Toolchain** | **Build cross gdb for the
    host**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BR2_PACKAGE_HOST_GDB`，在菜单**工具链** | **为主机构建交叉gdb**'
- en: '`BR2_PACKAGE_GDB`, in the menu **Target packages** | **Debugging, profiling
    and benchmark** | **gdb**'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BR2_PACKAGE_GDB`，在菜单**目标软件包** | **调试、性能分析和基准测试** | **gdb**'
- en: '`BR2_PACKAGE_GDB_SERVER` in the menu **Target packages** | **Debugging, profiling
    and benchmark** | **gdbserver**'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BR2_PACKAGE_GDB_SERVER`，在菜单**目标软件包** | **调试、性能分析和基准测试** | **gdbserver**'
- en: Starting to debug
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始调试
- en: Now that you have gdbserver installed on the target and a cross GDB on the host
    you can start a debug session.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您在目标上安装了gdbserver，并且在主机上安装了交叉GDB，您可以开始调试会话了。
- en: Connecting GDB and gdbserver
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接GDB和gdbserver
- en: 'The connection between GDB and gdbserver can be through a network or a serial
    interface. In the case of a network connection, you launch gdbserver with the
    TCP port number to listen on and, optionally, an IP address to accept connections
    from. In most cases you don''t care which IP address is going to connect, so you
    can just give the port number. In this example gdbserver waits for a connection
    on port `10000` from any host:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: GDB和gdbserver之间的连接可以通过网络或串行接口进行。在网络连接的情况下，您可以使用TCP端口号启动gdbserver进行监听，并且可以选择接受连接的IP地址。在大多数情况下，您不需要关心将连接到哪个IP地址，因此只需提供端口号即可。在此示例中，gdbserver等待来自任何主机的端口`10000`的连接：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, start the copy of GDB from your toolchain, giving the same program as
    an argument so that GDB can load the symbol table:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从您的工具链启动GDB，将相同的程序作为参数传递，以便GDB可以加载符号表：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In GDB, you use the command `target remote` to make the connection, giving
    the IP address or host name of the target and the port it is waiting on:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在GDB中，您使用`target remote`命令进行连接，指定目标的IP地址或主机名以及它正在等待的端口：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When gdbserver sees the connection from the host it prints the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当gdbserver看到来自主机的连接时，它会打印以下内容：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The procedure is similar for a serial connection. On the target, you tell gdbserver
    which serial port to use:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 串行连接的过程类似。在目标上，您告诉gdbserver要使用哪个串行端口：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You may need to configure the port baud rate beforehand using `stty` or a similar
    program. A simple example would be as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要使用`stty`或类似的程序预先配置端口波特率。一个简单的示例如下：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are many other options to `stty`, please read the man page for more details.
    It is worthwhile noting that the port must not be used for anything else, for
    example, you can''t use a port that is being used as the system console. On the
    host, you make the connection to gdbserver using `target remote` plus the serial
    device at the host end of the cable. In most cases you will want to set the baud
    rate of the host serial port using the GDB command `set remotebaud`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`stty`还有许多其他选项，请阅读手册以获取更多详细信息。值得注意的是，该端口不能用于其他用途，例如，您不能使用作为系统控制台使用的端口。在主机上，您可以使用`target
    remote`加上电缆末端的串行设备来连接到gdbserver。在大多数情况下，您将希望使用GDB命令`set remotebaud`设置主机串行端口的波特率：'
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Setting the sysroot
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置sysroot
- en: GDB needs to know where to find debug symbols and source code for shared libraries.
    When debugging natively the paths are well known and built in to GDB, but when
    using a cross toolchain, GDB has no way to guess where the root of the target
    filesystem is. You do so by setting the sysroot. The Yocto Project and Buildroot
    have different ways of handling library symbols so the location of the sysroot
    is quite different.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: GDB需要知道共享库的调试符号和源代码的位置。在本地调试时，路径是众所周知的，并内置到GDB中，但是在使用交叉工具链时，GDB无法猜测目标文件系统的根目录在哪里。您可以通过设置sysroot来实现。Yocto项目和Buildroot处理库符号的方式不同，因此sysroot的位置也大不相同。
- en: 'The Yocto Project includes debug information in the target filesystem image,
    so you need to unpack the target image tar file that is generated in `build/tmp/deploy/images`,
    for which you would need to do something like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto项目在目标文件系统映像中包含调试信息，因此您需要解压在`build/tmp/deploy/images`中生成的目标映像tar文件，例如：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Buildroot compiles libraries with minimal or full debug symbols, depending on
    `BR2_ENABLE_DEBUG`, puts them into the staging directory, then strips them as
    they are copied into target image. So, for Buildroot, the sysroot is always the
    staging area regardless of where the root filesystem is extracted.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot根据`BR2_ENABLE_DEBUG`编译具有最小或完整调试符号的库，将它们放入分段目录，然后在将它们复制到目标映像时剥离它们。因此，对于Buildroot来说，sysroot始终是分段区域，而不管根文件系统从何处提取。
- en: GDB command files
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GDB命令文件
- en: 'There are some things that you need to do each time you run GDB, for example,
    setting the sysroot. It is convenient to put such commands into a command file
    and run them each time GDB is started. GDB reads commands from `$HOME/.gdbinit`,
    then from `.gdbinit` in the current directory and then from files specified on
    the command line with the `-x` parameter. However, recent versions of GDB will
    refuse to load `.gdbinit` from the current directory for security reasons. You
    can override that behavior for a single directory by adding a line like this to
    your `$HOME/.gdbinit`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行GDB时，您需要做一些事情，例如设置sysroot。将这些命令放入命令文件中，并在每次启动GDB时运行它们非常方便。GDB从`$HOME/.gdbinit`读取命令，然后从当前目录中的`.gdbinit`读取命令，然后从使用`-x`参数在命令行上指定的文件中读取命令。然而，出于安全原因，最近的GDB版本将拒绝从当前目录加载`.gdbinit`。您可以通过向`$HOME/.gdbinit`添加以下行来覆盖该行为，以便为单个目录禁用检查：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also disable the check globally by adding:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过添加以下内容全局禁用检查：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: My personal preference is use the `-x` parameter to point to the command file,
    which exposes the location of the file so I don't forget about it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人偏好使用`-x`参数指向命令文件，这样可以暴露文件的位置，以免忘记它。
- en: 'To help you set up GDB, Buildroot creates a GDB command file containing the
    correct sysroot command in `output/staging/usr/share/buildroot/gdbinit`. It will
    contain a command similar to this one:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您设置GDB，Buildroot创建一个包含正确sysroot命令的GDB命令文件，位于`output/staging/usr/share/buildroot/gdbinit`中。它将包含类似于这样的命令：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Overview of GDB commands
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GDB命令概述
- en: GDB has a great many commands, which are described in the online manual and
    in the resources mentioned in the *Further Reading* section. To help you get going
    as quickly as possible, here is a list of the most commonly used commands. In
    most cases there is a short-hand for the command, which is listed underneath the
    full command.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: GDB有很多命令，这些命令在在线手册和*进一步阅读*部分提到的资源中有描述。为了帮助您尽快上手，这里列出了最常用的命令。在大多数情况下，命令都有一个缩写形式，该缩写形式在完整命令下面列出。
- en: Breakpoints
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断点
- en: 'The following table shows the commands for breakpoints:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了断点的命令：
- en: '| Commands | Use |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 用途 |'
- en: '| --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `break <location>``b <location>` | Set a breakpoint on a function name, line
    number or line. Examples are: `"main", "5", and "sortbug.c:42"` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `break <location>``b <location>` | 在函数名、行号或行上设置断点。例如："main"、"5"和"sortbug.c:42"
    |'
- en: '| `info break``i b` | List breakpoints |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `info break``i b` | 列出断点 |'
- en: '| `delete break <N>``d b <N>` | Delete breakpoint `N` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `delete break <N>``d b <N>` | 删除断点`N` |'
- en: Running and stepping
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行和步进
- en: 'The following table shows the commands for running and stepping:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了运行和步进的命令：
- en: '| Commands | Use |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 用途 |'
- en: '| --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `run``r` | Load a fresh copy of the program into memory and start it running.
    This does not work for remote debug using gdbserver |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `run``r` | 将程序的新副本加载到内存中并开始运行。这对使用gdbserver进行远程调试是无效的 |'
- en: '| `continue`c | Continue execution from a breakpoint |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `continue`c | 从断点继续执行 |'
- en: '| `Ctrl-C` | Stop the program being debugged |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `Ctrl-C` | 停止正在调试的程序 |'
- en: '| `step``s` | Step one line of code, stepping into any function that is called
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `step``s` | 执行一行代码，进入调用的任何函数 |'
- en: '| `next``n` | Step one line of code, stepping over a function call |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `next``n` | 执行一行代码，跳过函数调用 |'
- en: '| `finish` | Run until the current function returns |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `finish` | 运行直到当前函数返回 |'
- en: Information commands
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信息命令
- en: 'The following table shows the commands for getting information:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了获取信息的命令：
- en: '| Commands | Use |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 用途 |'
- en: '| --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `backtrace``bt` | List the call stack |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `backtrace``bt` | 列出调用堆栈 |'
- en: '| `info threads` | Continue execution from a breakpoint |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `info threads` | 从断点继续执行 |'
- en: '| `Info libs` | Stop the program |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `Info libs` | 停止程序 |'
- en: '| `print <variable>``p <variable>` | Print the value of a variable, e.g. `print
    foo` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `print <variable>``p <variable>` | 打印变量的值，例如`print foo` |'
- en: '| `list` | List lines of code around the current program counter |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `list` | 列出当前程序计数器周围的代码行 |'
- en: Running to a breakpoint
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行到断点
- en: 'Gdbserver loads the program into memory and sets a breakpoint at the first
    instruction, then waits for a connection from GDB. When the connection is made
    you enter into a debug session. However, you will find that if you try to single
    step immediately you will get this message:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Gdbserver将程序加载到内存中，并在第一条指令处设置断点，然后等待来自GDB的连接。当连接建立时，您将进入调试会话。但是，您会发现如果立即尝试单步执行，您将收到此消息：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is because the program is halted in code written in assembly that creates
    the run time environment for C and C++ programs. The first line of C or C++ code
    is the `main()` function. Supposing that you want to stop at `main()`, you would
    set a breakpoint there and then use the `continue` command (abbreviation `c`)
    to tell gdbserver to continue from the breakpoint at the start of the program
    and stop at main:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为程序在汇编语言中编写的代码中停止了，该代码为C和C++程序创建了运行时环境。C或C++代码的第一行是`main()`函数。假设您想在`main()`处停止，您可以在那里设置断点，然后使用`continue`命令（缩写为`c`）告诉gdbserver从程序开始处的断点继续执行并停在main处：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If at this point you see the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时您看到以下内容：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That means that you have forgotten the set sysroot!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您忘记了设置sysroot！
- en: This is all very different to starting a program natively, where you just type
    `run`. In fact, if you try typing `run` in a remote debug session, you will either
    see a message saying that the remote target does not support `run`, or in older
    versions of GDB it will just hang without any explanation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这与本地启动程序非常不同，您只需键入`run`。实际上，如果您在远程调试会话中尝试键入`run`，您要么会看到一条消息，说明远程目标不支持`run`，要么在较旧版本的GDB中，它将在没有任何解释的情况下挂起。
- en: Debugging shared libraries
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试共享库
- en: To debug the libraries that are built by the build tool you will have to make
    a few changes to the build configuration. For libraries built outside the build
    environment you will have to do some extra work.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要调试由构建工具构建的库，您需要对构建配置进行一些更改。对于在构建环境之外构建的库，您需要做一些额外的工作。
- en: The Yocto Project
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Yocto项目
- en: 'The Yocto Project builds debug variants of binary packages and puts them into
    `build/tmp/deploy/<package manager>/<target architecture>`. Here is an example
    of the debug package, for the C library in this case:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto项目构建二进制包的调试变体，并将它们放入`build/tmp/deploy/<package manager>/<target architecture>`中。以下是此示例的调试包，这里是C库的示例：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can add these debug packages selectively to your target image by adding
    `<package name-dbg>` to your target recipe. For `glibc`, the package is named
    `glibc-dbg`. Alternatively, you can simply tell the Yocto Project to install all
    debug packages by adding `dbg-pkgs` to `EXTRA_IMAGE_FEATURES`. Be warned that
    this will increase the size of the target image dramatically, perhaps by several
    hundred megabytes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将`<package name-dbg>`添加到目标配方来有选择地将这些调试包添加到目标映像中。对于`glibc`，该包的名称为`glibc-dbg`。或者，您可以简单地告诉Yocto项目通过将`dbg-pkgs`添加到`EXTRA_IMAGE_FEATURES`来安装所有调试包。请注意，这将大大增加目标映像的大小，可能会增加数百兆字节。
- en: The Yocto Project places the debug symbols in a hidden directory named `.debug`
    in both the `lib` and `usr/lib`, directories. GDB knows to look for symbol information
    in these locations within the sysroot.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Yocto项目将调试符号放在名为`.debug`的隐藏目录中，分别位于`lib`和`usr/lib`目录中。GDB知道在sysroot中的这些位置查找符号信息。
- en: 'The debug packages also contain a copy of the source code which is installed
    into directory `usr/src/debug/<package name>` in the target image, which is one
    of the reasons for the increase in size. You can prevent it from happening by
    adding to your recipes:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 调试软件包还包含安装在目标镜像中的源代码副本，位于目录`usr/src/debug/<package name>`中，这也是尺寸增加的原因之一。您可以通过向您的配方添加以下内容来阻止它发生：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember, though, that when you are debugging remotely with gdbserver, you only
    need the debug symbols and source code on the host, not on the target. There is
    nothing to stop you from deleting the `lib/.debug`, `usr/lib/.debug` and `usr/src`
    directories from the copy of the image that is installed on the target.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，请记住，当您使用gdbserver进行远程调试时，您只需要在主机上具有调试符号和源代码，而不需要在目标上具有。没有什么能阻止您从已安装在目标上的镜像的副本中删除`lib/.debug`、`usr/lib/.debug`和`usr/src`目录。
- en: Buildroot
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Buildroot
- en: 'Buildroot is characteristically straightforward. You just need to rebuild with
    line-level debug symbols, for which you need to enable the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Buildroot通常是直截了当的。您只需要重新构建带有行级调试符号的软件包，为此您需要启用以下内容：
- en: '`BR2_ENABLE_DEBUG` in the menu **Build options** | **build packages with debugging
    symbols**'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在菜单**构建选项** | **使用调试符号构建软件包**
- en: This will create the libraries with debug symbols in `output/host/usr/<arch>/sysroot`,
    but the copies in the target image are still stripped. If you need debug symbols
    on the target, perhaps to run GDB natively, you can disable stripping by setting
    **Build options** | **strip command for binaries on target** to `none`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`output/host/usr/<arch>/sysroot`中创建带有调试符号的库，但目标镜像中的副本仍然被剥离。如果您需要在目标上使用调试符号，也许是为了本地运行GDB，您可以通过将**构建选项**
    | **目标上的二进制文件剥离命令**设置为`none`来禁用剥离。
- en: Other libraries
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他库
- en: 'In addition to building with debug symbols you will have to tell GDB where
    to find the source code. GDB has a search path for source files, which you can
    see using the command `show directories`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用调试符号进行构建之外，您还需要告诉GDB在哪里找到源代码。GDB有一个用于源文件的搜索路径，您可以使用`show directories`命令查看：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'These are the default search paths: `$cdir` is the compile directory, which
    is the directory where the source was compiled; `$cwd` is the current working
    directory of GDB.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是默认搜索路径：`$cdir`是编译目录，即源代码编译的目录；`$cwd`是GDB的当前工作目录。
- en: 'Normally these are sufficient, but if the source code has been moved you will
    have to use the directory command as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这些就足够了，但如果源代码已经移动，您将需要使用如下所示的directory命令：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Just-in-time debugging
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 即时调试
- en: Sometimes a program will start to misbehave after it has been running for a
    while and you would like to know what it is doing. The GDB `attach` feature does
    exactly that. I call it just-in-time debugging. It is available with both native
    and remote debug sessions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，程序在运行一段时间后会开始表现异常，您可能想知道它在做什么。GDB的`attach`功能正是这样。我称它为即时调试。它在本地和远程调试会话中都可用。
- en: 'In the case of remote debugging, you need to find the PID of the process to
    be debugged and pass it to gdbserver with the `--attach` option. For example,
    if the PID is 109 you would type:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程调试的情况下，您需要找到要调试的进程的PID，并使用`--attach`选项将其传递给gdbserver。例如，如果PID为109，您将输入：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That forces the process to stop as if it were at a breakpoint, allowing you
    to start your cross GDB in the normal way and connect to gdbserver.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将强制进程停止，就像它处于断点处一样，这样您就可以以正常方式启动交叉GDB，并连接到gdbserver。
- en: 'When you are done you can detach, allowing the program to continue running
    without the debugger:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您可以分离，允许程序在没有调试器的情况下继续运行：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Debugging forks and threads
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试分支和线程
- en: What happens when the program you are debugging forks? Does the debug session
    follow the parent or the child? The behavior is controlled by `follow-fork-mode`
    which may be `parent` or `child`, with parent being the default. Unfortunately,
    current versions of gdbserver do not support this option, so it only works for
    native debugging. If you really need to debug the child process while using gdbserver,
    a workaround is to modify the code so that the child loops on a variable immediately
    after the fork, giving you the opportunity to attach a new gdbserver session to
    it and then to set the variable so that it drops out of the loop.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调试的程序进行分支时会发生什么？调试会跟随父进程还是子进程？这种行为由`follow-fork-mode`控制，可能是`parent`或`child`，默认为parent。不幸的是，当前版本的gdbserver不支持此选项，因此它仅适用于本地调试。如果您确实需要在使用gdbserver时调试子进程，一种解决方法是修改代码，使得子进程在分支后立即循环一个变量，这样您就有机会附加一个新的gdbserver会话，并设置变量以使其退出循环。
- en: When a thread in a multithreaded process hits a breakpoint, the default behavior
    is for all threads to halt. In most cases this is the best thing to do as it allows
    you to look at static variables without them being changed by the other threads.
    When you recommence execution of the thread, all the stopped threads start up,
    even if you are single stepping, and it is especially this last case that can
    cause problems. There is a way to modify the way GDB handles stopped threads,
    through a parameter called `scheduler-locking`. Normally it is `off`, but if you
    set it to `on`, only the thread that was stopped at the breakpoint is resumed
    and the others remain stopped, giving you a chance to see what the thread alone
    does without interference. This continues to be the case until you turn scheduler-locking
    off. Gdbserver supports this feature.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当多线程进程中的线程命中断点时，默认行为是所有线程都会停止。在大多数情况下，这是最好的做法，因为它允许您查看静态变量，而不会被其他线程更改。当您恢复线程的执行时，所有已停止的线程都会启动，即使您是单步执行，尤其是最后一种情况可能会导致问题。有一种方法可以修改GDB处理已停止线程的方式，通过称为`scheduler-locking`的参数。通常它是`off`，但如果将其设置为`on`，则只有在断点处停止的线程会恢复，其他线程将保持停止状态，这样您就有机会查看线程在没有干扰的情况下的操作。直到您关闭`scheduler-locking`为止，这种情况将继续存在。Gdbserver支持此功能。
- en: Core files
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心文件
- en: Core files capture the state of a failing program at the point that it terminates.
    You don't even have to be in the room with a debugger when the bug manifests itself.
    So when you see `Segmentation fault (core dumped)`, don't shrug; investigate the
    core file and extract the goldmine of information in there.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 核心文件捕获了程序在终止时的状态。当错误发生时，您甚至不必在调试器旁边。因此，当您看到`Segmentation fault (core dumped)`时，请不要耸肩；调查核心文件并提取其中的信息宝库。
- en: 'The first observation is that core files are not created by default, but only
    when the core file resource limit for the process is non-zero. You can change
    it for the current shell using `ulimit -c`. To remove all limits on the size of
    core files, type the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，默认情况下不会创建核心文件，而只有在进程的核心文件资源限制为非零时才会创建。您可以使用`ulimit -c`更改当前shell的限制。要删除核心文件大小的所有限制，请键入以下内容：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By default, the core file is named `core` and is placed in the current working
    directory of the process, which is the one pointed to by `/proc/<PID>/cwd`. There
    are a number of problems with this scheme. Firstly, when looking at a device with
    several files named `core` it is not obvious which program generated each one.
    Secondly, the current working directory of the process may well be in a read-only
    filesystem, or there may not be enough space to store the `core` file, or the
    process may not have permissions to write to the current working directory.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，核心文件命名为`core`，并放置在进程的当前工作目录中，该目录由`/proc/<PID>/cwd`指向。这种方案存在一些问题。首先，在查看具有多个名为`core`的文件的设备时，不明显知道每个文件是由哪个程序生成的。其次，进程的当前工作目录很可能位于只读文件系统中，或者可能没有足够的空间来存储`core`文件，或者进程可能没有权限写入当前工作目录。
- en: There are two files that control the naming and placement of `core` files. The
    first is `/proc/sys/kernel/core_uses_pid`. Writing a `1` to it causes the PID
    number of the dying process to be appended to the filename, which is somewhat
    useful as long as you can associate the PID number with a program name from log
    files.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个文件控制着`core`文件的命名和放置。第一个是`/proc/sys/kernel/core_uses_pid`。向其写入`1`会导致将正在死亡的进程的PID号附加到文件名中，只要您可以从日志文件中将PID号与程序名称关联起来，这就有些有用。
- en: 'Much more useful is `/proc/sys/kernel/core_pattern`, which gives you a lot
    more control over `core` files. The default pattern is `core` but you can change
    it to a pattern composed of these meta characters:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 更有用的是`/proc/sys/kernel/core_pattern`，它可以让您对`core`文件有更多的控制。默认模式是`core`，但您可以将其更改为由这些元字符组成的模式：
- en: '`%p`: the PID'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`％p`：PID'
- en: '`%u`: the real UID of the dumped process'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`％u`：转储进程的真实UID'
- en: '`%g`: the real GID of the dumped process'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`％g`：转储进程的真实GID'
- en: '`%s`: number of the signal causing the dump'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`％s`：导致转储的信号编号'
- en: '`%t`: the time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00
    +0000 (UTC)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`％t`：转储时间，表示自1970-01-01 00:00:00 +0000（UTC）以来的秒数。'
- en: '`%h`: the hostname'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`％h`：主机名'
- en: '`%e`: the executable filename'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`％e`：可执行文件名'
- en: '`%E`: the pathname of the executable, with slashes (`/`) replaced by exclamation
    marks (`!`)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`％E`：可执行文件的路径名，斜杠（`/`）替换为感叹号（`!`）'
- en: '`%c`: the core file size soft resource limit of the dumped process'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`％c`：转储进程的核心文件大小软资源限制'
- en: 'You can also use a pattern that begins with an absolute directory name so that
    all `core` files are gathered together in one place. As an example, the following
    pattern puts all core files into the `/corefiles` directory and names them with
    the program name and the time of the crash:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以绝对目录名开头的模式，以便将所有`core`文件收集到一个地方。例如，以下模式将所有核心文件放入`/corefiles`目录，并使用程序名称和崩溃时间命名它们：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Following a core dump, you would find something like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 核心转储后，您会发现类似以下内容：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For more information, refer to the man page *core(5)*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅man页面*core(5)*。
- en: 'For more sophisticated processing of core files you can pipe them to a program
    that does some post processing. The core pattern begins with a pipe symbol `|`
    followed by the program name and parameters. My Ubuntu 14.04, for example, has
    this core pattern:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于核心文件的更复杂处理，您可以将它们传输到进行一些后处理的程序。核心模式以管道符号`|`开头，后跟程序名称和参数。例如，我的Ubuntu 14.04有这个核心模式：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Apport is the crash reporting tool used by Canonical. A crash reporting tool
    run in this way is run while the process is still in memory, and the kernel passes
    the core image data to it on standard input. Thus, this program can process the
    image, possibly stripping parts of it to reduce the size in the filesystem, or
    just scanning it at the time of the core dump for specific information. The program
    can look at various pieces of system data, for example, reading the `/proc` filesystem
    entries for the program, and can use ptrace system calls to operate on the program
    and read data from it. However, once the core image data is read from standard
    in, the kernel does various cleanups that make information about the process no
    longer available.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Apport是Canonical使用的崩溃报告工具。这种方式运行的崩溃报告工具在进程仍在内存中运行时运行，并且内核将核心镜像数据传递给它的标准输入。因此，该程序可以处理图像，可能会剥离其中的部分以减小文件系统中的大小，或者仅在核心转储时扫描它以获取特定信息。该程序可以查看各种系统数据，例如，读取程序的`/proc`文件系统条目，并且可以使用ptrace系统调用来操作程序并从中读取数据。但是，一旦核心镜像数据从标准输入中读取，内核就会进行各种清理，使有关该进程的信息不再可用。
- en: Using GDB to look at core files
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GDB查看核心文件
- en: 'Here is a sample GDB session looking at a core file:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是查看核心文件的GDB会话示例：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'That shows that the program stopped at line 43\. The `list` command shows the
    code in the immediate vicinity:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示程序在第43行停止。`list`命令显示附近的代码：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `backtrace` command (shortened to `bt`) shows how we got to this point:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`backtrace`命令（缩写为`bt`）显示了我们到达这一点的路径：'
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'An obvious mistake: `addtree()` was called with a null pointer.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的错误：`addtree()`被空指针调用。
- en: GDB user interfaces
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GDB用户界面
- en: GDB is controlled at a low level through the GDB machine interface, GDB/MI,
    which is used to wrap GDB in a user interface or as part of a larger program and
    considerably extends the range of options available to you.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: GDB是通过GDB机器接口GDB/MI进行低级控制的，该接口用于将GDB包装在用户界面中或作为更大程序的一部分，并且大大扩展了可用的选项范围。
- en: I have only mentioned those which have features that are useful in embedded
    development.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我只提到了那些在嵌入式开发中有用的功能。
- en: Terminal user interface
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端用户界面
- en: '**Terminal user interface** (**TUI**), is an optional part of the standard
    GDB package. The main feature is a code window which shows the line of code about
    to be executed, together with any breakpoints. It is a definite improvement on
    the `list` command in command-line mode GDB.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**终端用户界面**（**TUI**）是标准GDB软件包的可选部分。其主要特点是代码窗口，显示即将执行的代码行以及任何断点。它绝对改进了命令行模式GDB中的`list`命令。'
- en: 'The attraction of TUI is that it just works and doesn''t need any extra set-up
    and, since it is in text mode, it is possible to use over an ssh terminal session
    when running `gdb` natively on a target. Most cross toolchains configure GDB with
    TUI. Simply add `-tui` to the command line and you will see the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: TUI的吸引力在于它只需要工作，不需要任何额外的设置，并且由于它是文本模式，因此在运行`gdb`时可以通过ssh终端会话在目标上使用。大多数交叉工具链都使用TUI配置GDB。只需在命令行中添加`-tui`，您将看到以下内容：
- en: '![Terminal user interface](img/B03982_12_01.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![终端用户界面](img/B03982_12_01.jpg)'
- en: Data display debugger
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据显示调试器
- en: '**Data display debugger** (**DDD**), is a simple standalone program that gives
    you a graphical user interface to GDB with minimal fuss and bother and, although
    the UI controls look dated, it does everything that is necessary.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据显示调试器**（**DDD**）是一个简单的独立程序，可以让您以最小的麻烦获得GDB的图形用户界面，尽管UI控件看起来有些过时，但它确实做到了必要的一切。'
- en: 'The `--debugger` option tells DDD to use GDB from your toolchain and you can
    use the `-x` argument for GDB command files:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`--debugger`选项告诉DDD使用您的工具链中的GDB，并且您可以使用GDB命令文件的`-x`参数：'
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following screenshot shows off one of the nicest features: the data window
    which contains items in a grid that you can rearrange as you wish. If you double-click
    on a pointer, it is expanded into a new data item and the link is shown with an
    arrow:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图展示了其中一个最好的功能：数据窗口，其中包含以您希望的方式重新排列的项目。如果双击指针，它会展开为一个新的数据项，并且链接会显示为箭头：
- en: '![Data display debugger](img/B03982_12_02.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![数据显示调试器](img/B03982_12_02.jpg)'
- en: Eclipse
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eclipse
- en: Eclipse, with the **C development toolkit** (**CDT**) plug-in, supports debugging
    with GDB, including remote debugging. If you use Eclipse for all your code development,
    this is the obvious tool to use but, if you are not a regular Eclipse user it
    is probably not worth the effort of setting it up just for this task. It would
    take me a whole chapter to explain adequately how to configure CDT to work with
    a cross toolchain and connect to a remote device, so I will refer you to the references
    at the end of the chapter for more information. The screenshot that follows shows
    the debug perspective of CDT. In the the top right window you see the stack frames
    for each of the threads in the process, and at the top right is the watch window
    showing variables. In the middle is the code window, showing the line of code
    where the debugger has stopped the program.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse，配备了**C开发工具包**（**CDT**）插件，支持使用GDB进行调试，包括远程调试。如果您在Eclipse中进行所有的代码开发，这是显而易见的工具，但是，如果您不是经常使用Eclipse，那么可能不值得为了这个任务而设置它。我需要整整一章的篇幅来充分解释如何配置CDT以使用交叉工具链并连接到远程设备，因此我将在本章末尾的参考资料中为您提供更多信息。接下来的屏幕截图显示了CDT的调试视图。在右上窗口中，您可以看到进程中每个线程的堆栈帧，右上方是显示变量的监视窗口。中间是代码窗口，显示了调试器停止程序的代码行。
- en: '![Eclipse](img/B03982_12_03.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![Eclipse](img/B03982_12_03.jpg)'
- en: Debugging kernel code
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试内核代码
- en: Debugging application code helps you gain insight into the way code works and
    what is happening when it misbehaves and you can do the same with the kernel,
    with some limitations.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 调试应用程序代码有助于了解代码的工作方式以及在代码发生故障时发生了什么，并且您可以对内核进行相同的操作，但有一些限制。
- en: You can use `kgdb` for source level debugging, in a manner similar to remote
    debugging with `gdbserver`. There is also a self-hosted kernel debugger, `kdb`,
    that is handy for lighter weight tasks such as seeing if an instruction is executed
    and getting the backtrace to find out how it got there. Finally, there are kernel
    oops messages and panics, which tell you a lot about the cause of a kernel exception.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`kgdb`进行源级调试，类似于使用`gdbserver`进行远程调试。还有一个自托管的内核调试器`kdb`，对于轻量级任务非常方便，例如查看指令是否执行并获取回溯以找出它是如何到达那里的。最后，还有内核oops消息和紧急情况，它们告诉您有关内核异常原因的很多信息。
- en: Debugging kernel code with kgdb
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用kgdb调试内核代码
- en: When looking at kernel code using a source debugger, you must remember that
    the kernel is a complex system, with real-time behaviors. Don't expect debugging
    to be as easy as it is for applications. Stepping through code that changes the
    memory mapping or switches context is likely to produce odd results.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用源代码调试器查看内核代码时，您必须记住内核是一个复杂的系统，具有实时行为。不要期望调试像应用程序一样容易。逐步执行更改内存映射或切换上下文的代码可能会产生奇怪的结果。
- en: '`kgdb` is the name given to the kernel GDB stubs that have been part of mainline
    Linux for many years now. There is a user manual in the kernel DocBook and you
    can find an online version at [https://www.kernel.org/doc/htmldocs/kgdb/index.html](https://www.kernel.org/doc/htmldocs/kgdb/index.html).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`kgdb`是多年来一直是Linux主线的内核GDB存根的名称。内核DocBook中有用户手册，您可以在[https://www.kernel.org/doc/htmldocs/kgdb/index.html](https://www.kernel.org/doc/htmldocs/kgdb/index.html)找到在线版本。'
- en: The widely supported way to connect to kgdb is over the serial interface, which
    is usually shared with the serial console, and so this implementation is called
    `kgdboc`, meaning kgdb over console. To work, it requires a platform tty driver
    that supports I/O polling instead of interrupts, since kgdb has to disable interrupts
    when communicating with GDB. A few platforms support kgdb over USB and there have
    been versions that work over Ethernet but, unfortunately, none of those have found
    their way into mainline Linux.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到kgdb的广泛支持方式是通过串行接口，通常与串行控制台共享，因此此实现称为`kgdboc`，意思是控制台上的kgdb。为了工作，它需要支持I/O轮询而不是中断的平台tty驱动程序，因为kgdb在与GDB通信时必须禁用中断。一些平台支持通过USB进行kgdb，还有一些可以通过以太网工作的版本，但不幸的是，这些都没有进入主线Linux。
- en: The same caveats about optimization and stack frames apply to the kernel, with
    the limitation that the kernel is written to assume an optimization level of at
    least `-O1`. You can override the kernel compile flags by setting `KCGLAGS` before
    running `make`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 内核的优化和堆栈帧也适用于内核，但内核的限制是，内核被写成至少为`-O1`的优化级别。您可以通过在运行`make`之前设置`KCGLAGS`来覆盖内核编译标志。
- en: 'These, then, are the kernel configuration options you will need for kernel
    debugging:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这些是您需要进行内核调试的内核配置选项：
- en: '`CONFIG_DEBUG_INFO` is in the **Kernel hacking** | **Compile-time checks and
    compiler options** | **Compile the kernel with debug info menu**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_DEBUG_INFO`在**内核调试** | **编译时检查和编译器选项** | **使用调试信息编译内核菜单**中'
- en: '`CONFIG_FRAME_POINTER` may be an option for your architecture, and is in the
    **Kernel hacking** | **Compile-time checks and compiler options** | **Compile
    the kernel with frame pointers menu**'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_FRAME_POINTER`可能是您的架构的一个选项，并且在**内核调试** | **编译时检查和编译器选项** | **使用帧指针编译内核菜单**中'
- en: '`CONFIG_KGDB` is in the **Kernel hacking** | **KGDB: kernel debugger menu**'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_KGDB`在**内核调试** | **KGDB：内核调试器菜单**中'
- en: '`CONFIG_KGDB_SERIAL_CONSOLE` is in the **Kernel hacking** | **KGDB: kernel
    debugger** | **KGDB: use kgdb over the serial console menu**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_KGDB_SERIAL_CONSOLE`在**内核调试** | **KGDB：内核调试器** | **KGDB：使用串行控制台菜单**中'
- en: 'In addition to the `uImage` or `zImage` compressed kernel image, you will need
    the kernel image in ELF object format so that GDB can load the symbols into memory.
    That is the file called `vmlinux` that is generated in the directory where Linux
    is built. In the Yocto Project, you can request that a copy be included in the
    target image, which is convenient for this and other debug tasks. It is built
    into a package named `kernel-vmlinux`, which you can install like any other, for
    example by adding it to the `IMAGE_INSTALL_append` list. The file is put into
    the boot directory, with a name like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`uImage`或`zImage`压缩内核映像，您还需要以ELF对象格式的内核映像，以便GDB可以将符号加载到内存中。这个文件称为在构建Linux的目录中生成的`vmlinux`。在Yocto项目中，您可以请求在目标映像中包含一个副本，这对于这个和其他调试任务非常方便。它构建为一个名为`kernel-vmlinux`的软件包，您可以像其他软件包一样安装，例如将其添加到`IMAGE_INSTALL_append`列表中。该文件放入引导目录，名称如下：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In Buildroot, you will find `vmlinux` in the directory where the kernel was
    built, which is in `output/build/linux-<version string>/vmlinux`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在Buildroot中，您将在构建内核的目录中找到`vmlinux`，该目录位于`output/build/linux-<version string>/vmlinux`中。
- en: A sample debug session
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个示例调试会话
- en: The best way to show you how it works is with a simple example.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 展示它的最佳方法是通过一个简单的例子。
- en: 'You need to tell `kgdb` which serial port to use, either through the kernel
    command line or at runtime via `sysfs`. For the first option, add `kgdboc=<tty>,<baud
    rate>` to the command line, as shown:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要告诉`kgdb`要使用哪个串行端口，可以通过内核命令行或通过`sysfs`在运行时进行设置。对于第一种选项，请将`kgdboc=<tty>,<波特率>`添加到命令行，如下所示：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For the second option, boot the device up and write the terminal name to the
    `/sys/module/kgdboc/parameters/kgdboc` file, as shown:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个选项，启动设备并将终端名称写入`/sys/module/kgdboc/parameters/kgdboc`文件，如下所示：
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that you cannot set the baud rate in this way. If it is the same `tty`
    as the console then it is set already, if not use `stty` or a similar program.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您不能以这种方式设置波特率。如果它与控制台相同的`tty`，则已经设置，如果不是，请使用`stty`或类似的程序。
- en: 'Now you can start GDB on the host, selecting the `vmlinux` file that matches
    the running kernel:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在主机上启动GDB，选择与正在运行的内核匹配的`vmlinux`文件：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: GDB loads the symbol table from `vmlinux` and waits for further input.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: GDB从`vmlinux`加载符号表，并等待进一步的输入。
- en: 'Next, close any terminal emulator that is attached to the console: you are
    about to use it for GDB and, if both are active at the same time, some of the
    debug strings might get corrupted.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，关闭连接到控制台的任何终端仿真器：您将要在GDB中使用它，如果两者同时活动，一些调试字符串可能会损坏。
- en: 'Now, you can return to GDB and attempt to connect to `kgdb`. However, you will
    find that the response you get from `target remote` at this time is unhelpful:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以返回到GDB并尝试连接到`kgdb`。但是，您会发现此时从`target remote`得到的响应是无用的：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The problem is that `kgdb` is not listening for a connection at this point.
    You need to interrupt the kernel before you can enter into an interactive GDB
    session with it. Unfortunately, just typing *Ctrl* + *C* in GDB, as you would
    with an application, does not work. You have to force a trap into the kernel by
    launching another shell on the target, via ssh, for example, and writing a `g`
    to `/proc/sysrq-trigger` on the target board:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于此时`kgdb`没有在监听连接。您需要在可以与之进行交互的GDB会话之前中断内核。不幸的是，就像您在应用程序中一样，仅在GDB中键入*Ctrl*
    + *C*是无效的。您需要通过例如通过ssh在目标板上启动另一个shell，并向目标板的`/proc/sysrq-trigger`写入`g`来强制内核陷入：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The target stops dead at this point. Now you can connect to `kgdb` via the
    serial device at the host end of the cable:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 目标在这一点上停止。现在，您可以通过电缆主机端的串行设备连接到`kgdb`：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'At last, GDB is in charge. You can set breakpoints, examine variables, look
    at backtraces, and so on. As an example, set a break on `sys_sync`, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，GDB掌控了。您可以设置断点，检查变量，查看回溯等。例如，设置一个在`sys_sync`上的断点，如下所示：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now the target comes back to life. Typing `sync` on the target calls `sys_sync`
    and hits the breakpoint.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在目标恢复了。在目标上输入`sync`调用`sys_sync`并触发断点。
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you have finished the debug session and want to disable `kgdboc`, just set
    the `kgdboc` terminal to null:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经完成了调试会话并想要禁用`kgdboc`，只需将`kgdboc`终端设置为null：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Debugging early code
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试早期代码
- en: 'The preceding example works in cases where the code you are interested in is
    executed when the system is fully booted. If you need to get in early, you can
    tell the kernel to wait during boot by adding `kgdbwait` to the command line,
    after the `kgdboc` option:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统完全引导时执行您感兴趣的代码的情况下，前面的示例适用。如果您需要尽早进入系统，可以通过在`kgdboc`选项之后添加`kgdbwait`到命令行来告诉内核在引导期间等待：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, when you boot, you will see this on the console:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您引导时，您将在控制台上看到这个：
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: At this point, you can close the console and connect from GDB in the usual way.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可以关闭控制台，并以通常的方式从GDB连接。
- en: Debugging modules
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试模块
- en: Debugging kernel modules presents an additional challenge because the code is
    relocated at runtime and so you need to find out at what address it resides. The
    information is presented via `sysfs`. The relocation addresses for each section
    of the module are stored in `/sys/module/<module name>/sections`. Note that, since
    ELF sections begin with a dot, '.', they appear as hidden files and you will have
    to use `ls -a` if you want to list them. The important ones are `.text`, `.data`,
    and `.bss`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 调试内核模块会带来额外的挑战，因为代码在运行时被重定位，所以您需要找出它所在的地址。这些信息通过`sysfs`呈现。模块的每个部分的重定位地址存储在`/sys/module/<module
    name>/sections`中。请注意，由于ELF部分以点'.'开头，它们显示为隐藏文件，如果要列出它们，您将需要使用`ls -a`。重要的是`.text`、`.data`和`.bss`。
- en: 'Take as an example a module named `mbx`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以模块名为`mbx`为例：
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now you can use these numbers in GDB to load the symbol table for the module
    at those addresses:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在GDB中使用这些数字来加载模块的符号表：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Everything should now work as normal: you can set breakpoints and inspect global
    and local variables in the module just as you can in `vmlinux`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切应该正常工作：您可以设置断点并检查模块中的全局和局部变量，就像在`vmlinux`中一样：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, force the device driver to call `mbx_write` and it will hit the breakpoint:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，强制设备驱动程序调用`mbx_write`，它将触发断点：
- en: '[PRE45]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Debugging kernel code with kdb
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用kdb调试内核代码
- en: Although `kdb` does not have the features of `kgdb` and GDB, it does have its
    uses and, being self-hosted, there are no external dependencies to worry about.
    `kdb` has a simple command-line interface which you can use on a serial console.
    You can use it to inspect memory, registers, process lists, `dmesg`, and even
    set breakpoints to stop in a certain location.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`kdb`没有`kgdb`和GDB的功能，但它确实有其用途，并且作为自托管的工具，没有外部依赖需要担心。`kdb`具有一个简单的命令行界面，您可以在串行控制台上使用它。您可以使用它来检查内存、寄存器、进程列表、`dmesg`，甚至设置断点以在特定位置停止。
- en: 'To configure `kgd` for access via a serial console, enable `kgdb` as shown
    previously and then enable this additional option:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置通过串行控制台访问`kgd`，请启用`kgdb`，如前所示，然后启用此附加选项：
- en: '`CONFIG_KGDB_KDB`, which is in the **KGDB:** **Kernel hacking** | **kernel
    debugger** | **KGDB_KDB: include kdb frontend for kgdb** menu'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_KGDB_KDB`，位于**KGDB:** **内核调试** | **内核调试器** | **KGDB_KDB: 包括kgdb的kdb前端**菜单中'
- en: 'Now, when you force the kernel to a trap, instead of entering into a GDB session,
    you will see the `kdb` shell on the console:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您强制内核陷入陷阱时，您将在控制台上看到`kdb` shell，而不是进入GDB会话：
- en: '[PRE46]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There are quite a few things you can do in the `kdb` shell. The `help` command
    will print all of the options. Here is an overview.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在`kdb` shell中有很多事情可以做。`help`命令将打印所有选项。这是一个概述。
- en: 'Getting information:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 获取信息：
- en: '`ps`: displays active processes'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps`：显示活动进程'
- en: '`ps A`: displays all processes'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps A`：显示所有进程'
- en: '`lsmod`: lists modules'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lsmod`：列出模块'
- en: '`dmesg`: displays the kernel log buffer'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dmesg`：显示内核日志缓冲区'
- en: 'Breakpoints:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 断点：
- en: '`bp`: sets a breakpoint'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bp`：设置断点'
- en: '`bl`: lists breakpoints'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bl`：列出断点'
- en: '`bc`: clears a breakpoint'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bc`：清除断点'
- en: '`bt`: prints a backtrace'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bt`：打印回溯'
- en: '`go`: continues execution'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go`：继续执行'
- en: 'Inspect memory and registers:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 检查内存和寄存器：
- en: '`md`: displays memory'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`md`：显示内存'
- en: '`rd`: displays registers'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rd`：显示寄存器'
- en: 'Here is a quick example of setting a break point:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设置断点的一个快速示例：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The kernel returns to life and the console shows the normal bash prompt. If
    you type `sync`, it hits the breakpoint and enters `kdb` again:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 内核恢复正常，控制台显示正常的bash提示符。如果键入`sync`，它会触发断点并再次进入`kdb`：
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`kdb` is not a source debugger so you can''t see the source code, or single
    step. However, you can display a backtrace using the `bt` command, which is useful
    to get an idea of program flow and call hierarchy.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`kdb`不是源代码调试器，因此您无法查看源代码或单步执行。但是，您可以使用`bt`命令显示回溯，这对于了解程序流程和调用层次结构很有用。'
- en: When the kernel performs an invalid memory access or executes an illegal instruction,
    a kernel oops message is written to the kernel log. The most useful part of this
    is the backtrace, and I want to show you how to use the information there to locate
    the line of code that caused the fault. I will also address the problem of preserving
    oops messages if they cause the system to crash.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当内核执行无效的内存访问或执行非法指令时，内核oops消息将被写入内核日志。其中最有用的部分是回溯，我想向您展示如何使用其中的信息来定位导致故障的代码行。我还将解决如果oops消息导致系统崩溃时如何保留oops消息的问题。
- en: Looking at an oops
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看oops
- en: 'An oops message looks like this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: oops消息看起来像这样：
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`PC is at mbx_write+0x14/0x98 [mbx]` tells you most of what you want to know:
    the last instruction was in the `mbx_write` function in a kernel module named
    `mbx`. Furthermore, it was at offset `0x14` bytes from the start of the function,
    which is `0x98` bytes long.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`PC is at mbx_write+0x14/0x98 [mbx]`告诉您大部分您想知道的内容：最后一条指令在名为`mbx`的内核模块中的`mbx_write`函数中。此外，它是从函数开始的偏移量`0x14`字节，该函数的长度为`0x98`字节。'
- en: 'Next, take a look at the backtrace:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，看一下回溯：
- en: '[PRE50]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this case, we don't learn much more, merely that `mbx_write` is called from
    the virtual filesystem code.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们并没有学到更多，只是`mbx_write`是从虚拟文件系统代码中调用的。
- en: 'It would be very nice to find the line of code that relates to `mbx_write+0x14`,
    for which we can use `objdump`. We can see from `objdump -S` that `mbx_write`
    is at offset `0x8c` in `mbx.ko`, so that last instruction executed is at `0x8c
    + 0x14 = 0xa0`. Now, we just need to look at that offset and see what is there:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 找到与`mbx_write+0x14`相关的代码行将非常好，我们可以使用`objdump`。我们可以从`objdump -S`中看到`mbx_write`在`mbx.ko`中的偏移量为`0x8c`，因此最后执行的指令位于`0x8c
    + 0x14 = 0xa0`。现在，我们只需要查看该偏移量并查看其中的内容：
- en: '[PRE51]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This shows the instruction where it stopped. The last line of code is shown
    here:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了它停止的指令。代码的最后一行显示在这里：
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can see that `m` has the type `struct mbx_data *`. Here is the place where
    that structure is defined:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`m`的类型是`struct mbx_data *`。这是定义该结构的地方：
- en: '[PRE53]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: So, it looks like the `m` variable is a null pointer, and that is causing the
    oops.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，看起来`m`变量是一个空指针，这导致了oops。
- en: Preserving the oops
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存oops
- en: Decoding an oops is only possible if you can capture it in the first place.
    If the system crashes during boot before the console is enabled, or after a suspend,
    you won't see it. There are mechanisms to log kernel oops and messages to an MTD
    partition or to persistent memory, but here is a simple technique that works in
    many cases and needs little prior thought.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 解码oops只有在首次捕获它时才可能。如果系统在启动期间在启用控制台之前或在挂起后崩溃，则不会看到它。有机制可以将内核oops和消息记录到MTD分区或持久内存中，但这里有一种在许多情况下都有效且需要很少事先考虑的简单技术。
- en: 'So long as the contents of memory are not corrupted during a reset (and usually
    they are not), you can reboot into the bootloader and use it to display memory.
    You need to know the location of the kernel log buffer, remembering that it is
    a simple ring buffer of text messages. The symbol is `__log_buf`. Look this up
    in `System.map` for the kernel:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 只要在重置期间内存内容未被损坏（通常情况下不会），您可以重新启动到引导加载程序并使用它来显示内存。您需要知道内核日志缓冲区的位置，记住它是文本消息的简单环形缓冲区。符号是`__log_buf`。在内核的`System.map`中查找此内容：
- en: '[PRE54]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Then, map that kernel logical address into a physical address that U-Boot can
    understand by subtracting `PAGE_OFFSET`, `0xc0000000`, and adding the physical
    start of RAM, `0x80000000` on a BeagleBone, so `c0f72428 – 0xc0000000 + 0x80000000
    = 80f72428`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过减去`PAGE_OFFSET`，`0xc0000000`，并在BeagleBone上加上RAM的物理起始地址`0x80000000`，将内核逻辑地址映射到U-Boot可以理解的物理地址，因此`c0f72428
    - 0xc0000000 + 0x80000000 = 80f72428`。
- en: 'Then use the U-Boot `md` command to show the log:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用U-Boot的`md`命令显示日志：
- en: '[PRE55]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From Linux 3.5 onwards, there is a 16-byte binary header for each line in the
    kernel log buffer which encodes a timestamp, a log level and other things. There
    is a discussion about it in the Linux Weekly News titled *Toward more reliable
    logging* at [https://lwn.net/Articles/492125/](https://lwn.net/Articles/492125/).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 从Linux 3.5开始，内核日志缓冲区中的每行都有一个16字节的二进制头，其中编码了时间戳、日志级别和其他内容。在Linux Weekly News的一篇名为*走向更可靠的日志记录*的文章中有关于此的讨论，网址为[https://lwn.net/Articles/492125/](https://lwn.net/Articles/492125/)。
- en: Additional reading
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外阅读
- en: 'The following resources have further information about the topics introduced
    in this chapter:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源提供了有关本章介绍的主题的更多信息：
- en: '*The Art of Debugging with GDB, DDD, and Eclipse*, by *Norman Matloff* and
    *Peter Jay Salzman*, *No Starch Press*; 1 edition (28 Sept. 2008), ISBN 978-1593271749'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用GDB、DDD和Eclipse进行调试的艺术*，作者*Norman Matloff*和*Peter Jay Salzman*，*No Starch
    Press*；第1版（2008年9月28日），ISBN 978-1593271749'
- en: '*GDB Pocket Reference* by *Arnold Robbins*, *O''Reilly Media*; 1st edition
    (12 May 2005), ISBN 978-0596100278'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GDB口袋参考*，作者*Arnold Robbins*，*O''Reilly Media*；第1版（2005年5月12日），ISBN 978-0596100278'
- en: '*Getting to grips with Eclipse: cross compiling*, [http://2net.co.uk/tutorial/eclipse-cross-compile](http://2net.co.uk/tutorial/eclipse-cross-compile)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*熟悉Eclipse：交叉编译*，[http://2net.co.uk/tutorial/eclipse-cross-compile](http://2net.co.uk/tutorial/eclipse-cross-compile)'
- en: '*Getting to grips with Eclipse: remote access and debugging*, [http://2net.co.uk/tutorial/eclipse-rse](http://2net.co.uk/tutorial/eclipse-rse)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*熟悉Eclipse：远程访问和调试*，[http://2net.co.uk/tutorial/eclipse-rse](http://2net.co.uk/tutorial/eclipse-rse)'
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: GDB for interactive debugging is a useful tool in the embedded developer's tool
    chest. It is a stable, well-documented and well-known entity. It has the ability
    to debug remotely by placing an agent on the target, be it `gdbserver` for applications
    or `kgdb` for kernel code and, although the default command-line user interface
    takes a while to get used to, there are many alternative front-ends. The three
    I mentioned were TUI, DDD, and Eclipse, which should cover most situations, but
    there are other front-ends around that you can try.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 用于交互式调试的 GDB 是嵌入式开发人员工具箱中的一个有用工具。它是一个稳定的、有文档支持的、众所周知的实体。它有能力通过在目标上放置代理来远程调试，无论是用于应用程序的
    `gdbserver` 还是用于内核代码的 `kgdb`，尽管默认的命令行用户界面需要一段时间才能习惯，但有许多替代的前端。我提到的三个是 TUI、DDD
    和 Eclipse，这应该涵盖了大多数情况，但还有其他前端可以尝试。
- en: A second and equally important way to approach debugging is to collect crash
    reports and analyze them offline. In this category, I have looked at application
    core dumps and kernel oops messages.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 调试的第二种同样重要的方法是收集崩溃报告并离线分析它们。在这个类别中，我已经查看了应用程序的核心转储和内核 oops 消息。
- en: However, this is only one way of identifying flaws in programs. In the next
    chapter, I will talk about profiling and tracing as ways of analyzing and optimizing
    programs.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只是识别程序中缺陷的一种方式。在下一章中，我将讨论分析和优化程序的方法，即性能分析和跟踪。
