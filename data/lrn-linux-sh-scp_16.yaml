- en: Bash Parameter Substitution and Expansion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bash参数替换和扩展
- en: 'This chapter is dedicated to a special feature of Bash: parameter expansion.
    Parameter expansion allows us to do many interesting things with variables, which
    we will cover extensively.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门介绍了Bash的一个特殊功能：参数扩展。参数扩展允许我们对变量进行许多有趣的操作，我们将进行广泛的介绍。
- en: We will first discuss default values of variables, input checking, and variable
    length. In the second part of this chapter, we will look more closely at how we
    can manipulate variables. This includes replacing and removing patterns from text,
    modifying the case of variables, and using substrings.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论变量的默认值、输入检查和变量长度。在本章的第二部分，我们将更仔细地看一下我们如何操作变量。这包括替换和删除文本中的模式，修改变量的大小写，并使用子字符串。
- en: 'The following commands will be introduced in this chapter: `export` and `dirname`.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下命令：`export`和`dirname`。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Parameter expansion
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数扩展
- en: Variable manipulation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量操作
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All scripts for this chapter can be found on GitHub at the following link:
    [https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter16](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter16).
    For this last regular chapter, your Ubuntu virtual machine should see you through
    once again.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有脚本都可以在GitHub上找到，链接如下：[https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter16](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter16)。对于这最后一个常规章节，你的Ubuntu虚拟机应该能再次帮助你度过难关。
- en: Parameter expansion
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数扩展
- en: 'In this second-to-last chapter, with the final chapter being tips and tricks,
    we will deal with a very cool feature of Bash: *parameter expansion*.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在倒数第二章中，最后一章是技巧和窍门，我们将讨论Bash的一个非常酷的功能：*参数扩展*。
- en: 'We''ll begin with a few notes on terminology. First of all, what''s considered
    *parameter expansion* in Bash deals with more than just parameters/arguments supplied
    to a script: all special operations we''ll be discussing in this chapter are applicable
    to Bash *variables*. In the official Bash manual page (`man bash`), these are
    all referred to as parameters.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先对术语进行一些说明。首先，在Bash中被认为是*参数扩展*的东西不仅仅涉及到脚本提供的参数/参数：我们将在本章讨论的所有特殊操作都适用于Bash
    *变量*。在官方Bash手册页（`man bash`）中，所有这些都被称为参数。
- en: For positional arguments to scripts, or even options with arguments, this makes
    sense. However, once we enter the territory of constants defined by the script
    creator, the distinction between a constant/variable and a parameter gets a bit
    muddy. This is of no further consequence; just remember that when you see the
    word *parameter* in a `man page`, it might be referring to variables in general.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于脚本的位置参数，甚至带参数的选项，这是有意义的。然而，一旦我们进入由脚本创建者定义的常量领域，常量/变量和参数之间的区别就有点模糊了。这并不重要；只要记住，当你在`man page`中看到*参数*这个词时，它可能是指一般的变量。
- en: Secondly, people tend to be a bit confused about the terms *parameter expansion*
    and *parameter substitution*, and you'll see these terms used interchangeably
    on the internet. In the official documentation, the word *substitution* is only
    used in *command substitution* and *process* *substitution*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，人们对术语*参数扩展*和*参数替换*有些困惑，在互联网上这两个术语经常被交替使用。在官方文档中，*替换*这个词只用在*命令替换*和*进程替换*中。
- en: 'Command substitution is something we''ve discussed: it''s the `$(...)` syntax.
    Process substitution is pretty advanced and has not been described: if you ever
    come across `<(...)` syntax, you''re dealing with process substitution. We''ve
    included an article on process substitution in the *Further reading* section of
    this chapter, so be sure to give it a look.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 命令替换是我们讨论过的：它是`$(...)`的语法。进程替换非常高级，还没有描述过：如果你遇到`<(...)`的语法，那就是在处理进程替换。我们在本章的*进一步阅读*部分包括了一篇关于进程替换的文章，所以一定要看一下。
- en: The confusion, we think, stems from the fact that *parameter substitution*,
    that is, the replacing of the variable name with its value at runtime, is considered
    only a small part of the greater *parameter expansion* in Bash. That is why you
    will see some articles or sources refer to all the great features of parameter
    expansion (default values, case manipulation, and pattern removal, to name a few)
    as parameter substitution.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为混淆的根源在于*参数替换*，也就是在运行时用变量名替换其值，只被认为是Bash中更大的*参数扩展*的一小部分。这就是为什么你会看到一些文章或来源将参数扩展的所有伟大功能（默认值、大小写操作和模式删除等）称为参数替换。
- en: 'Again, just remember that these terms are often interchanged, and people are
    (probably) talking about the same thing. If you are ever in doubt yourself, we
    would advise opening up the Bash `man page` on any of your machines, and sticking
    with the official designation: *parameter expansion*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这些术语经常被互换使用，人们（可能）谈论的是同一件事。如果你自己有任何疑问，我们建议在任何一台机器上打开Bash的`man page`，并坚持使用官方的称呼：*参数扩展*。
- en: Parameter substitutions – recap
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数替换-回顾
- en: While it probably isn't necessary at this point for you, we'd like to quickly
    recap parameter substitutions so that we can place it within the greater context
    of parameter expansion.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这一点上可能并不是必要的，但我们想快速回顾一下参数替换，以便将其放在参数扩展的更大背景中。
- en: 'As we stated in the introduction, and as you''ve seen throughout this book,
    parameter substitution is nothing more than replacing a variable with its value
    at runtime. On the command line, this looks a little like the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍中所述，并且你在整本书中都看到了，参数替换只是在运行时用变量的值替换变量。在命令行中，这看起来有点像下面这样：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Normally in a recap you don''t learn any new things, but because we''re using
    this just for context we''ve managed to sneak some new stuff in here: the `export`
    command. `export` is a shell builtin (as found with `type -a export`), which we
    can read about using `help export` (which is the way to get information for all
    shell builtins).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在回顾中你不会学到任何新东西，但因为我们只是为了背景，我们设法在这里偷偷加入了一些新东西：`export`命令。`export`是一个shell内置命令（可以用`type
    -a export`找到），我们可以使用`help export`来了解它（这是获取所有shell内置命令信息的方法）。
- en: 'We don''t always need to use `export` when setting a variable value: in this
    instance, we could have also just used `word=Script`. Normally, when we set a
    variable, it is only available in our current shell. Any processes that run in
    a fork of our shell do not have that piece of the environment forked with them:
    they cannot see the value we have assigned to the variable.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置变量值时，我们并不总是需要使用`export`：在这种情况下，我们也可以只使用`word=Script`。通常情况下，当我们设置一个变量时，它只在当前的shell中可用。在我们的shell的分支中运行的任何进程都不会将环境的这一部分与它们一起分叉：它们无法看到我们为变量分配的值。
- en: While it is not always necessary, you might encounter the use of `export` when
    looking for answers online, so it is good to know what it does!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不总是必要的，但你可能会在网上寻找答案时遇到`export`的使用，所以了解它是很好的！
- en: The rest of the example should speak for itself. We assign a value to a variable,
    and we use parameter substitution at runtime (in this case, with an `echo`) to
    replace the variable name with the actual value.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的示例应该不言自明。我们为一个变量赋值，并在运行时使用参数替换（在这种情况下，使用`echo`）来替换变量名为实际值。
- en: 'As a reminder, will we show you why we advise you to *always* include the curly
    braces around your variable: it makes sure Bash knows where the name of the variable
    starts and ends. In the last `echo`, where we can forget to do this, we see that
    the variable is resolved incorrectly, and the text does not get printed correctly.
    While not necessary for all scripts, we think it looks better and is a good practice
    that you should always follow.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，我们将向你展示为什么我们建议*始终*在变量周围包含花括号：这样可以确保Bash知道变量的名称从何处开始和结束。在最后的`echo`中，我们可能会忘记这样做，我们会发现变量被错误解析，文本打印不正确。虽然并非所有脚本都需要，但我们认为这样做看起来更好，是一个你应该始终遵循的良好实践。
- en: As far as we're concerned, only what we've covered here falls under *parameter
    substitution*. All other features in this chapter are *parameter expansion*, and
    we will refer to them accordingly!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们而言，只有我们在这里涵盖的内容属于*参数替换*。本章中的所有其他特性都是*参数扩展*，我们将相应地引用它们！
- en: Default values
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认值
- en: On to parameter expansion! As we've hinted, Bash allows us to do many cool things
    directly with variables. We'll start with the seemingly simple example of defining
    a default value for your variables.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是参数扩展！正如我们所暗示的，Bash允许我们直接对变量进行许多酷炫的操作。我们将从看似简单的示例开始，为变量定义默认值。
- en: 'When dealing with user input, this makes both your life and the script user''s
    life much easier: as long as there is a reasonable default value, we can make
    sure that we use that instead of throwing an error when the user does not supply
    the information we want.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理用户输入时，这样做会让你和脚本用户的生活都变得更加轻松：只要有一个合理的默认值，我们就可以确保使用它，而不是在用户没有提供我们想要的信息时抛出错误。
- en: 'We will reuse one of our earliest scripts, `interactive.sh`, from [Chapter
    8](41d3c327-f6d6-4ec5-8ec9-127e493bdd05.xhtml), *Variables and User Input*. It
    was a very simple script that did not verify user input, and was thus prone to
    all sorts of problems. Let''s get it up-to-date and include our new default values
    for our parameters, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用我们最早的一个脚本，`interactive.sh`，来自[第8章](41d3c327-f6d6-4ec5-8ec9-127e493bdd05.xhtml)，*变量和用户输入*。这是一个非常简单的脚本，没有验证用户输入，因此容易出现各种问题。让我们更新一下，并包括我们的参数的新默认值，如下所示：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Instead of just grabbing user input with `$1`, `$2` and `$3`, we will now create
    a more complicated syntax, defined by `man bash`, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不再仅仅使用`$1`，`$2`和`$3`来获取用户输入，而是使用`man bash`中定义的更复杂的语法，如下所示：
- en: ${parameter:-word}
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ${parameter:-word}
- en: '**Use Default Values.** If parameter is unset or null, the expansion of word
    is substituted. Otherwise, the value of parameter is substituted.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用默认值。** 如果参数未设置或为空，将替换为word的扩展。否则，将替换为参数的值。'
- en: Again, you should read the word *parameter* as *variable* in this context (even
    though, when user-supplied, it is actually an argument to a parameter, but it
    could very well be a constant as well). With this syntax, if the variable is either
    not set or null (empty), the value supplied after the dash (called *word* in the
    `man page`) will be inserted instead.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你应该在这个上下文中将*参数*读作*变量*（即使在用户提供时，它实际上是参数的一个参数，但它也很可能是一个常量）。使用这种语法，如果变量未设置或为空（空字符串），则在破折号后面提供的值（在`man`页面中称为*word*）将被插入。
- en: 'We''ve done this for all three parameters, so let''s check out how this works
    in practice:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为所有三个参数做了这个，所以让我们看看这在实践中是如何工作的：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we do not supply any values to the script, all the defaults are inserted.
    If we supply three arguments, of which two are just empty strings (`''`), we can
    see that Bash will still substitute the defaults for us for the empty string.
    However, the actual string, `Amsterdam`, is correctly entered into the text, instead
    of **`Utrecht`.**
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有向脚本提供任何值，所有默认值都会被插入。如果我们提供了三个参数，其中两个只是空字符串（`''`），我们可以看到Bash仍然会为我们替换空字符串的默认值。然而，实际的字符串`Amsterdam`被正确输入到文本中，而不是`Utrecht`。
- en: 'While dealing with empty strings in this manner is often desirable behavior,
    you can also write your scripts to allow for empty strings as a variable default.
    That looks like the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式处理空字符串通常是期望的行为，你也可以编写你的脚本以允许空字符串作为变量的默认值。具体如下：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we created a temporary copy to illustrate this functionality. When you
    remove the colon from the default declaration (`${1-word}` instead of `${1:-word}`),
    it no longer inserts the default for empty strings. It does, however, for values
    that are not set at all, as can be seen when we call it with `'' Amsterdam` instead
    of `'' Amsterdam ''`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个临时副本来说明这个功能。当您从默认声明中删除冒号（`${1-word}`而不是`${1:-word}`）时，它不再为空字符串插入默认值。但是，对于根本没有设置的值，它会插入默认值，当我们使用`''
    Amsterdam`而不是`'' Amsterdam ''`调用它时可以看到。
- en: In our experience, in most cases, the default should ignore empty strings, so
    the syntax as presented in the `man page` is more desirable. If you have a niche
    case, though, you are now aware of this possibility!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的经验，在大多数情况下，默认值应忽略空字符串，因此`man page`中呈现的语法更可取。不过，如果您有一个特殊情况，现在您已经意识到了这种可能性！
- en: 'For some of your scripts, you might find that just substituting a default is
    not enough: you''d rather have the variable set to a value that can then be evaluated
    with more granularity. This is also possible with parameter expansion, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您的一些脚本，您可能会发现仅替换默认值是不够的：您可能更愿意将变量设置为可以更细致评估的值。这也是可能的，使用参数扩展，如下所示：
- en: ${parameter:=word}
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ${parameter:=word}
- en: '**Assign Default Values.** If parameter is unset or null, the expansion of
    word is assigned to parameter. The value of parameter is then substituted. Positional
    parameters and special parameters may not be assigned to in this way.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 分配默认值。如果参数未设置或为空，则将单词的扩展分配给参数。然后替换参数的值。不能以这种方式分配位置参数和特殊参数。
- en: We've never seen the need to use this function, especially since it is not compatible
    with positional parameters (and as such, we only mention it here and do not go
    into detail). But, as with all things, it is good to be aware of the possibilities
    parameter expansion provides in this area.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从未见过需要使用此功能，特别是因为它与位置参数不兼容（因此，我们只在这里提到它，不详细介绍）。但是，与所有事物一样，了解参数扩展在这个领域提供的可能性是很好的。
- en: Input checking
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入检查
- en: Closely related to setting default values with parameter expansion, we can also
    use parameter expansion to display an error if a variable is null or empty. Up
    until now, we've done this by implementing if-then logic within our scripts. While
    this is an excellent and flexible solution, it is a little verbose—especially
    if the only thing you're interested in is the user supplying the parameters.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用参数扩展设置默认值密切相关，我们还可以使用参数扩展来显示如果变量为空或为空则显示错误。到目前为止，我们通过在脚本中实现if-then逻辑来实现这一点。虽然这是一个很好且灵活的解决方案，但有点冗长，特别是如果您只对用户提供参数感兴趣的话。
- en: 'Let''s create a new version of our previous example: this one does not supply
    default values, but will alert the user if positional arguments are missing.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们之前示例的新版本：这个版本不提供默认值，但会在缺少位置参数时提醒用户。
- en: 'We''ll use the following syntax:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下语法：
- en: ${parameter:?word}
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ${parameter:?word}
- en: '**Display Error if Null or Unset.** If parameter is null or unset, the expansion
    of word (or a message to that effect if word is not present) is written to the
    standard error and the shell, if it is not interactive, exits. Otherwise, the
    value of parameter is substituted.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数为空或未设置，则将单词的扩展（或者如果单词不存在，则写入相应的消息）写入标准错误和shell，如果不是交互式的，则退出。否则，替换参数的值。
- en: 'When we use this in our script, it might look something like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在脚本中使用这个时，它可能看起来像这样：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note the colon again. In the same way the colon worked in the previous example,
    it also forces this parameter expansion to consider an empty string as a null/unset
    value.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意冒号。与前面的示例中冒号的工作方式相同，它还会强制此参数扩展将空字符串视为null/未设置值。
- en: 'When we run this script, we see the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个脚本时，我们会看到以下内容：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While this works like a charm, it doesn't really look that great, does it? The
    script name and line numbers are printed, which seems like a bit too much in-depth
    information for a user of the script.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做效果很好，但看起来并不是那么好，对吧？打印了脚本名称和行号，这对于脚本的用户来说似乎是太多深入的信息。
- en: It is up to you to decide if you think these are acceptable looking feedback
    messages to your users; personally, we think a nice if-then is often better, but
    with regards to concise scripting, this cannot be beaten.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以决定您是否认为这些是可以接受的反馈消息给您的用户；就个人而言，我们认为一个好的if-then通常更好，但是在简洁的脚本方面，这是无法超越的。
- en: 'There is another parameter expansion closely related to these: `${parameter:+word}`.
    This allows you to use *word* only if the parameter is NOT null or empty. In our
    experience, this isn''t a common occurrence, but for your scripting needs it might
    be; look for the words `Use Alternate Value` in `man bash` to get more information.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个与此密切相关的参数扩展：`${parameter:+word}`。这允许您仅在参数不为空时使用*word*。根据我们的经验，这并不常见，但对于您的脚本需求可能会有用；在`man
    bash`中查找`Use Alternate Value`以获取更多信息。
- en: Parameter length
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数长度
- en: 'We''ve done a lot of checks in the book so far. One we haven''t carried out,
    however, is on the length of the supplied parameter. What will probably not surprise
    you at this point is how we can achieve this: with parameter expansion, of course.
    The syntax is really simple, too:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在书中进行了很多检查。然而，我们没有进行的一个是所提供参数的长度。在这一点上，您可能不会感到惊讶的是我们如何实现这一点：当然是通过参数扩展。语法也非常简单：
- en: ${#parameter}
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ${#parameter}
- en: Parameter length. The length in characters of the value of parameter is substituted.
    If parameter is * or @, the value substituted is the number of positional parameters.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 参数长度。替换参数值的字符数。如果参数是*或@，则替换的值是位置参数的数量。
- en: 'So, instead of printing `${variable}`, which will substitute the value at runtime,
    we will use `${#variable}`, which will give us a number: the number of characters
    in our value. This might be a little tricky, as things such as whitespaces can
    also be considered characters.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们将使用`${#variable}`而不是`${variable}`来打印，后者会在运行时替换值，而前者会给我们一个数字：值中的字符数。这可能有点棘手，因为空格等内容也可以被视为字符。
- en: 'Take a look at the following example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的例子：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, the word `hello` is identified as five characters; so far,
    so good. When we look at the sentence `hello there`, we can see two words of five
    letters each. While you might expect the parameter expansion to return `10`, it
    actually returns `11`. Since the words are separated by a space, you should not
    be surprised: this space is the 11th character.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，单词`hello`被识别为五个字符；到目前为止一切顺利。当我们看看句子`hello there`时，我们可以看到两个分别有五个字母的单词。虽然你可能期望参数扩展返回`10`，但实际上它返回的是`11`。由于单词之间用空格分隔，你不应感到惊讶：这个空格是第11个字符。
- en: 'If we take a look back at the syntax definition from the `man bash` page, we''ll
    see the following interesting tidbit:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下`man bash`页面上的语法定义，我们会看到以下有趣的细节：
- en: If parameter is * or @, the value substituted is the number of positional parameters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数是*或@，则替换的值是位置参数的数量。
- en: Remember how we used `$#` to determine how many arguments are passed to the
    script in the rest of this book? This is actually Bash parameter expansion at
    work, as `${#*}` is equal to `$#!`
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们在本书的其余部分中使用`$#`来确定传递给脚本的参数数量吗？这实际上就是Bash参数扩展的工作，因为`${#*}`等于`$#!`
- en: 'To drive these points home, let''s create a quick script that deals with three-letter
    acronyms (our personal favorite type of acronym). For now, the functionality of
    this script will be limited to verifying and printing the user input, but when
    we get to the end of this chapter, we''ll amend it a bit to make it even cooler:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加深这些观点，让我们创建一个快速脚本，处理三个字母的首字母缩略词（我们个人最喜欢的缩略词类型）。目前，这个脚本的功能将仅限于验证和打印用户输入，但当我们到达本章的末尾时，我们将稍作修改，使其更加酷炫：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We did two interesting things in this script: we used the full syntax of `${#*}`
    to determine the number of arguments passed to our script, and we checked the
    acronym length with `${#acronym}`. Because we used two different checks, we used
    two different exit codes: `exit 1` for the wrong number of arguments, and `exit
    2` for incorrect acronym length.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们做了两件有趣的事情：我们使用了`${#*}`的完整语法来确定传递给我们脚本的参数数量，并使用`${#acronym}`检查了首字母缩略词的长度。因为我们使用了两种不同的检查，所以我们使用了两种不同的退出代码：对于错误的参数数量，我们使用`exit
    1`，对于不正确的首字母缩略词长度，我们使用`exit 2`。
- en: In larger, more complex scripts, using different exit codes might save you a
    significant amount of troubleshooting, so we've included it here for information.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大、更复杂的脚本中，使用不同的退出代码可能会节省大量的故障排除时间，因此我们在这里提供了相关信息。
- en: 'If we now run our script with different incorrect and correct input, we can
    see it works as planned:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在用不同的不正确和正确的输入运行我们的脚本，我们可以看到它按计划运行。
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'No arguments, too many arguments, arguments of incorrect length: we''re equipped
    to handle everything the user might throw at us. As always, never expect the user
    to do what you hope, just ensure your script will only execute if the input is
    correct!'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 没有参数，太多参数，参数长度不正确：我们已经准备好处理用户可能抛给我们的一切。一如既往，永远不要指望用户会按照你的期望去做，只需确保你的脚本只有在输入正确时才会执行！
- en: Variable manipulation
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量操作
- en: Parameter expansion in Bash deals with more than just default values, input
    checking, and parameter length. It actually also allows us to manipulate the variables
    before we use them. In this second part of this chapter, we'll explore the capabilities
    within parameter expansion that deal with *variable manipulation* (our terminology;
    as far as Bash is concerned, these are just normal parameter expansions).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Bash中的参数扩展不仅涉及默认值、输入检查和参数长度，它实际上还允许我们在使用变量之前操纵这些变量。在本章的第二部分中，我们将探讨参数扩展中处理*变量操作*（我们的术语；就Bash而言，这些只是普通的参数扩展）的能力。
- en: We'll kick this off with *pattern substitution*, something you should be familiar
    with after our explanation of `sed` in [Chapter 10](d3b18cbd-f152-498a-b7b8-79da604e66b4.xhtml),
    *Regular Expressions*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以*模式替换*开始，这是我们在[第10章](d3b18cbd-f152-498a-b7b8-79da604e66b4.xhtml)中对`sed`的解释后应该熟悉的内容。
- en: Pattern substitution
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式替换
- en: 'Simply said, pattern substitution allows us to substitute a pattern with something
    else (who would have thought!). This is what we could already do with `sed`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，模式替换允许我们用其他东西替换模式（谁会想到呢！）。这就是我们之前用`sed`已经能做的事情：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Initially, our `echo` contains the word `Hi`. We then pipe it through `sed`,
    in which we look for the *pattern* `Hi`, which we will *substitute* with `Bye`.
    The `s` at the front of the instruction to `sed` signals that we're searching
    and replacing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们的`echo`包含单词`Hi`。然后我们通过`sed`进行管道传输，在其中查找*模式* `Hi`，我们将用`Bye` *替换*它。`sed`指令前面的`s`表示我们正在搜索和替换。
- en: Behold, after `sed` is done parsing the stream, we end up with `Bye` on our
    screen.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 看吧，当`sed`解析完流之后，我们的屏幕上就会出现`Bye`。
- en: 'If we want to do the same when using a variable, we have two options: we''ll
    either parse it through `sed` as we did previously, or we''ll turn to our new
    best friend for another great parameter expansion:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在使用变量时做同样的事情，我们有两个选择：要么像之前一样通过`sed`解析它，要么转而使用我们的新朋友进行另一次很棒的参数扩展：
- en: ${parameter/pattern/string}
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ${parameter/pattern/string}
- en: '**Pattern substitution.** The pattern is expanded to produce a pattern just
    as in pathname expansion. Parameter is expanded and the longest match of pattern
    against its value is replaced with string. If pattern begins with /, all matches
    of pattern are replaced with string.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**模式替换。** 模式会扩展成与路径名扩展中一样的模式。参数会被扩展，模式与其值的最长匹配将被替换为字符串。如果模式以/开头，则所有模式的匹配都将被替换为字符串。'
- en: So, for the `${sentence}` variable, we could replace the first instance of a
    pattern with `${sentence/pattern/string}`, or all instances of the pattern with `${sentence//pattern/string}`
    (notice the extra forward slash).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于`${sentence}`变量，我们可以用`${sentence/pattern/string}`替换模式的第一个实例，或者用`${sentence//pattern/string}`替换所有实例（注意额外的斜杠）。
- en: 'On the command line, it might look something like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上，它可能看起来像这样：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once again, this is pretty self-explanatory and simple to use.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是非常直观和简单的。
- en: 'One important thing to realize is that this parameter expansion doesn''t actually
    edit the value of the variable: it only affects the current substitution. If you
    wanted to do a permanent manipulation of the variable, you''d need to write the
    result to a variable again, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的事实是，这种参数扩展实际上并不编辑变量的值：它只影响当前的替换。如果您想对变量进行永久操作，您需要再次将结果写入变量，如下所示：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or, if you''d prefer to keep the variable name after the mutation, you can
    assign the mutated value back to the variable in one go, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您希望在变异后保留变量名称，可以将变异值一次性赋回变量，如下所示：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It should not be too difficult to imagine using this syntax in a script. As
    a simple example, we''ve created a little interactive quiz in which we''ll *help*
    the user if they happen to give the wrong answer to our very non-opinionated question:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 想象在脚本中使用这种语法应该不难。举个简单的例子，我们创建了一个小型交互式测验，在其中，如果用户给出了错误答案，我们将*帮助*他们：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this script, if the user is temporarily *confused* and does not give the
    wanted answer, we'll simply replace their *wrong* answer (`zsh`) with the *correct*
    answer, `bash`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，如果用户暂时*困惑*并且没有给出想要的答案，我们将简单地用*正确*答案`bash`替换他们的*错误*答案（`zsh`）。
- en: 'All jokes aside, other shells such as `zsh`, `ksh`, and even the newer fish
    have their own unique selling points and strengths that makes some users prefer
    them over Bash for daily work. This is obviously great, and a big part of the
    mentality of using Linux: you have the freedom to choose whichever software you
    prefer!'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 开玩笑的时候到此为止，其他shell（如`zsh`，`ksh`，甚至较新的fish）都有自己独特的卖点和优势，使一些用户更喜欢它们而不是Bash进行日常工作。这显然很好，也是使用Linux的心态的一部分：您有自由选择您喜欢的软件！
- en: When it comes to scripting, however, we are (obviously) of the opinion that
    Bash is still the king of shells, if only for the very simple reason that it has
    become the de facto shell for most distributions. This is very helpful when it
    comes to portability and interoperability, qualities that are often beneficial
    for scripts.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当涉及到脚本时，我们（显然）认为Bash仍然是shell之王，即使只是因为它已经成为大多数发行版的事实标准shell。这在可移植性和互操作性方面非常有帮助，这些特性通常对脚本有益。
- en: Pattern removal
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式删除
- en: A topic closely related to pattern substitution is *pattern removal*. Let's
    face it, pattern removal is basically the same as replacing a pattern with nothing.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与模式替换紧密相关的一个主题是*模式删除*。让我们面对现实，模式删除基本上就是用空白替换模式。
- en: If pattern removal had exactly the same functionality as pattern substitution,
    we would not need it. However, pattern removal has a few cool tricks that would
    be difficult or even impossible to do with pattern substitution.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模式删除与模式替换具有完全相同的功能，我们就不需要它。但是，模式删除有一些很酷的技巧，使用模式替换可能会很困难，甚至不可能做到。
- en: 'Pattern removal has two options: removing matched pattern *prefixes* or *suffixes*.
    In simpler words, it allows you to remove stuff either from the beginning or the
    end. It also has an option to stop after the first matched pattern, or to continue
    up until the last.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 模式删除有两个选项：删除匹配模式的*前缀*或*后缀*。简单来说，它允许您从开头或结尾删除内容。它还有一个选项，可以在找到第一个匹配模式后停止，或者一直持续到最后。
- en: 'Without a good example, this might be a bit too abstract (it definitely was
    for us the first time we encountered this). However, there is an excellent example
    here: it all has to do with files:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一个好的例子，这可能有点太抽象（对我们来说，第一次遇到这种情况时肯定是这样）。然而，这里有一个很好的例子：这一切都与文件有关：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''ve created a variable that contains a reference to a file. If we wanted
    the directory, or the file without the directory, we could use either `basename`
    or `dirname`, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含对文件的引用的变量。如果我们想要目录，或者不带目录的文件，我们可以使用`basename`或`dirname`，如下所示：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We could also achieve this with parameter expansions. The syntax for prefix
    and suffix removal is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过参数扩展来实现这一点。前缀和后缀删除的语法如下：
- en: ${parameter#word}
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ${parameter#word}
- en: ${parameter##word}
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ${parameter##word}
- en: '**Remove matching prefix pattern.** ${parameter%word}${parameter%%word} **Remove
    matching suffix pattern.**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除匹配前缀模式。** ${parameter%word}${parameter%%word} **删除匹配后缀模式。**'
- en: 'For our `${file}` variable, we can use parameter expansion to remove all directories
    and only keep the filename, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`${file}`变量，我们可以使用参数扩展来删除所有目录，只保留文件名，如下所示：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The difference between the first and second command is minimal: we''re using
    the asterisk wildcard that can match on anything, zero or more times. In this
    case, since the value of the variable starts with a forward slash, it does not
    match. However, as soon as we get to the third command, we see the need to include
    it: we need to match *everything we want to delete*.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条和第二条命令之间的区别很小：我们使用了可以匹配任何内容零次或多次的星号通配符。在这种情况下，由于变量的值以斜杠开头，它不匹配。然而，一旦我们到达第三个命令，我们就看到了需要包括它：我们需要匹配*我们想要删除的所有内容*。
- en: In this case, the `*/` pattern matches on `/tmp/`, whereas the `/` pattern only
    matches on the first forward slash (as the result of the third command clearly
    shows).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`*/`模式匹配`/tmp/`，而`/`模式仅匹配第一个正斜杠（正如第三个命令的结果清楚显示的那样）。
- en: It is good to remember that in this instance, we're merely using parameter expansion
    to replace the functionality of the `basename` command. However, if we were not
    dealing with file references, but (for example) underscore delimited files, we
    could not achieve this with `basename`, and parameter expansion would come in
    quite handy!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的是，在这种情况下，我们仅仅是使用参数扩展来替换`basename`命令的功能。然而，如果我们不是在处理文件引用，而是（例如）下划线分隔的文件，我们就无法用`basename`来实现这一点，参数扩展就会派上用场！
- en: 'Now that we''ve seen what we can do with prefixes, let''s look at suffixes.
    The functionality is of the same order, but instead of parsing from the start
    of a value, we''re now looking at the end of the value first. We could use this,
    for example, to remove the extension from the file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了前缀的用法，让我们来看看后缀。功能是一样的，但是不是从值的开头解析，而是先从值的末尾开始。例如，我们可以使用这个功能从文件中删除扩展名：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This allows us to grab the filename, without the extension. This might be desirable
    if there is some logic in your script that can be applied to this part of the
    file. In our experience, this is more common than you think!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够获取文件名，不包括扩展名。如果你的脚本中有一些逻辑可以应用到文件的这一部分，这可能是可取的。根据我们的经验，这比你想象的要常见！
- en: For example, you might imagine backups that have a date in the filename that
    you'd like to compare to today's date, to ensure a backup was successful. A little
    bit of parameter expansion can get you to your desired format, so the comparison
    of dates is then trivial.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能想象一下备份文件名中有一个日期，你想将其与今天的日期进行比较，以确保备份成功。一点点的参数扩展就可以让你得到你想要的格式，这样日期的比较就变得微不足道了。
- en: 'Just as we were able to replace the `basename` command, we can do the reverse
    with suffix pattern removal to find the `dirname`, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们能够替换`basename`命令一样，我们也可以使用后缀模式删除来找到`dirname`，如下所示：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Again, these examples mostly serve for educational purposes. There are many
    situations in which this could be useful; since these are very diverse, it is
    hard to give an example that is interesting for everyone.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这些示例主要用于教育目的。有许多情况下这可能会有用；由于这些情况非常多样化，很难给出一个对每个人都有趣的例子。
- en: 'The situation we introduced regarding backups, however, might be relevant for
    you. As a basic script, it would look something like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们介绍的关于备份的情况可能对你有用。作为一个基本的脚本，它看起来会是这样的：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To illustrate this, we're touching dummy backup files. For a real situation,
    you'd be more likely to pick up the newest file in a directory (with `ls -ltr
    /backups/ | awk '{print $9}' | tail -1`, for example) and compare that to the
    current date.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们正在创建虚拟备份文件。在实际情况下，你更有可能在目录中挑选最新的文件（例如使用`ls -ltr /backups/ | awk '{print
    $9}' | tail -1`）并将其与当前日期进行比较。
- en: 'As with most things in Bash scripting, there are other ways to accomplish this
    date checking. You could argue that we could leave the extension in the file variable
    and use a regular expression that parses the date: that would work just as well,
    with pretty much the same amount of work.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 与Bash脚本中的大多数事物一样，还有其他方法可以完成这个日期检查。你可以说我们可以保留文件变量中的扩展名，并使用解析日期的正则表达式：这样也可以，工作量几乎相同。
- en: The takeaway from this example (and the whole book, really) should be to use
    something *that works for you and your organization*, as long as you've built
    it in a robust manner and added the necessary comments for everyone to understand
    what you did!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子（以及整本书）的要点应该是使用对你和你的组织有用的东西，只要你以稳固的方式构建它，并为每个人添加必要的注释，让大家都能理解你做了什么！
- en: Case modification
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大小写修改
- en: 'Next up is another parameter expansion we''ve already briefly seen: *case modification.*
    In this instance, case refers to lowercase and uppercase letters.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是另一个参数扩展，我们已经简要看到了：*大小写修改*。在这种情况下，大小写是指小写和大写字母。
- en: 'In the `yes-no-optimized.sh` script we originally created in [Chapter 9](125f46ad-bffc-4bf6-86e7-ae6a2ca47bb6.xhtml),
    *Error Checking and Handling*, we had the following instructions:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最初在[第9章](125f46ad-bffc-4bf6-86e7-ae6a2ca47bb6.xhtml)中创建的`yes-no-optimized.sh`脚本中，*错误检查和处理*，我们有以下指令：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you might expect, the `,,` and `^^` found within the curly braces of the
    variable are the parameter expansions we're talking about.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的那样，在变量的花括号中找到的`,,`和`^^`是我们所讨论的参数扩展。
- en: 'The syntax, as found on `man bash`, is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如`man bash`中所述的语法如下：
- en: ${parameter^pattern}
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ${parameter^pattern}
- en: ${parameter^^pattern}
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ${parameter^^pattern}
- en: ${parameter,pattern}
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ${parameter,pattern}
- en: ${parameter,,pattern}
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ${parameter,,pattern}
- en: '**Case modification.** This expansion modifies the case of alphabetic characters
    in parameter. The pattern is expanded to produce a pattern just as in pathname
    expansion. Each character in the expanded value of parameter is tested against
    pattern, and, if it matches the pattern, its case is converted. The pattern should
    not attempt to match more than one character.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**大小写修改。** 这个扩展修改参数中字母字符的大小写。模式被扩展以产生一个与路径名扩展中一样的模式。参数的扩展值中的每个字符都与模式进行匹配，如果匹配模式，则其大小写被转换。模式不应尝试匹配多于一个字符。 '
- en: In our first script, we haven't used a pattern. When not using a pattern, it
    is implied that the pattern is a wildcard (in this case, the `?`), which means
    everything matches.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个脚本中，我们没有使用模式。当不使用模式时，暗示着模式是通配符（在这种情况下是`?`），这意味着一切都匹配。
- en: 'A quick command-line example of both lowercase and uppercase modification should
    clear this up. First, let''s take a look at how we can uppercase a variable:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 快速的命令行示例可以清楚地说明如何进行大小写修改。首先，让我们看看如何将变量转换为大写：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If we use a single caret (`^`), we can see that the first letter of our variables'
    value will be uppercased. If we use a double caret, `^^`, we now have the full
    value in uppercase.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用单个插入符（`^`），我们可以看到我们变量值的第一个字母将变成大写。如果我们使用双插入符，`^^`，我们现在有了全部大写的值。
- en: 'In a similar manner, commas do the same thing for lowercasing:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，逗号也可以用于小写：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Because we can choose to uppercase or lowercase the entire value, we can now
    much more easily compare user input to a predefined value. Regardless of whether
    the user inputs `YES`, `Yes`, or `yes`, we can verify all these situations with
    a single check: `${input,,} == ''yes''`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们可以选择将整个值大写或小写，所以现在我们可以更容易地将用户输入与预定义值进行比较。无论用户输入`YES`，`Yes`还是`yes`，我们都可以通过单个检查来验证所有这些情况：`${input,,}
    == 'yes'`。
- en: This gives the user fewer headaches, and a happy user is what we want (remember,
    you are often the user of your own scripts, and you deserve happiness!).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以减少用户的头疼，而一个快乐的用户正是我们想要的（记住，你经常是你自己脚本的用户，你也应该快乐！）。
- en: Now, for the *pattern*, as the `man page` specifies it. In our personal experience,
    we have not had to use this option yet, but it is powerful and flexible, so it
    never hurts to get a little bit more explanation on this.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于*模式*，就像`man page`指定的那样。根据我们的个人经验，我们还没有使用过这个选项，但它是强大和灵活的，所以多解释一点也没有坏处。
- en: 'Basically, the case modification will only be performed if the pattern matches.
    It can get a little tricky, but you can see how it works here:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，只有在模式匹配时才会执行大小写修改。这可能有点棘手，但你可以看到它是如何工作的：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The first command we run, `${animal^a}`, only uppercases the first letter if
    it matches the pattern: `a`. Since the first letter is actually an `s`, the entire
    word is printed as lowercase.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行的第一个命令`${animal^a}`，只有在匹配模式`a`时才会将第一个字母大写。由于第一个字母实际上是`s`，整个单词被打印为小写。
- en: For the next command, `${animal^^a}`, *all matching letters* are uppercased.
    So, all three instances of `a` in the word `salamander` are given in uppercase.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个命令`${animal^^a}`，*所有匹配的字母*都会被大写。因此，单词`salamander`中的所有三个`a`实例都会变成大写。
- en: 'On the third command, we try to add an extra letter to the pattern. Since this
    is not the correct way of doing this, the parameter expansion is (likely) trying
    to find a single letter to match two letters in the pattern. Spoiler alert: this
    is very much impossible. As soon as we bring some of our regular expression expertise
    in the mix, we can do what we want: by using `[ae]`, we''re specifying that both
    `a` and `e` are valid targets for the case modification operation.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个命令中，我们尝试向模式添加一个额外的字母。由于这不是正确的做法，参数扩展（可能）试图找到一个单个字母来匹配模式中的两个字母。剧透警告：这是不可能的。一旦我们将一些正则表达式专业知识融入其中，我们就可以做我们想做的事情：通过使用`[ae]`，我们指定`a`和`e`都是大小写修改操作的有效目标。
- en: In the end, the animal returned is now `sAlAmAndEr`, with all vowels uppercased
    using a custom pattern in combination with the case modification parameter expansion!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，返回的动物现在是`sAlAmAndEr`，所有元音字母都使用自定义模式和大小写修改参数扩展为大写！
- en: As a little bonus, we'd like to share a case modification that is not even present
    on the `man bash` page! It is not that complicated, either. If you replace either
    `,` or `^` with a tilde, `~`, you will get a *case reversal*. As you might expect,
    a single tilde will operate only on the first letter (if it matches the pattern,
    if specified), while a double tilde will match on all instances of the pattern
    (or everything, if no pattern is specified and the default `?` is used).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个小小的奖励，我们想分享一个甚至在`man bash`页面上都没有的大小写修改！它也不是那么复杂。如果你用波浪号`~`替换逗号`,`或插入符`^`，你将得到一个*大小写反转*。正如你可能期望的那样，单个波浪号只会作用于第一个字母（如果匹配模式的话），而双波浪号将匹配模式的所有实例（如果没有指定模式并且使用默认的`?`）。
- en: 'Take a look:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This should be a sufficient explanation of case modification, as all syntaxes
    are similar and predictable.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该足够解释大小写修改，因为所有的语法都是相似和可预测的。
- en: Now that you know how to lowercase, uppercase, and even reverse the case of
    your variables, you should be able to mutate them in any way you like, especially
    if you add a pattern into the mix, this parameter expansion provides many possibilities!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何将变量转换为小写、大写，甚至反转大小写，你应该能够以任何你喜欢的方式改变它们，特别是如果你加入一个模式，这个参数扩展提供了许多可能性！
- en: Substring expansion
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子字符串扩展
- en: 'Only a single topic with regards to parameter expansion remains: substring
    expansion. While you might have heard of a substring, it could also be a very
    complex-sounding term.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 关于参数扩展，只剩下一个主题：子字符串扩展。虽然你可能听说过子字符串，但它也可能是一个非常复杂的术语。
- en: 'Fortunately, it is actually *really really* simple. If we take a string, such
    as *Today is a great day*, then any part of that sentence that is in the correct
    order but not the full sentence can be considered a substring of the full string.
    Examples of this are as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这实际上是*非常非常*简单的。如果我们拿一个字符串，比如*今天是一个伟大的一天*，那么这个句子的任何部分，只要顺序正确但不是完整的句子，都可以被视为完整字符串的子字符串。例如：
- en: Today is
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天是
- en: a great day
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个伟大的一天
- en: day is a gre
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: day is a gre
- en: Today is a great da
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天是一个伟大的一天
- en: o
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: o
- en: (<- there is a space here, you just can't see it)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （<- 这里有一个空格，你只是看不到它）
- en: 'As you can see from these examples, we''re not looking at the semantic meaning
    of the sentence, but simply at the characters: any number of characters in the
    correct order can be considered a substring. This includes the entire sentence
    minus one letter, but also includes just a single letter, or even a single space
    character.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些例子中可以看出，我们并不关注句子的语义意义，而只是关注字符：任意数量的字符按正确的顺序可以被视为子字符串。这包括整个句子减去一个字母，但也包括单个字母，甚至是单个空格字符。
- en: 'So, let''s look at the syntax for this parameter expansion one last time:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们最后一次看一下这个参数扩展的语法：
- en: ${parameter:offset}
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ${parameter:offset}
- en: ${parameter:offset:length}
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ${parameter:offset:length}
- en: '**Substring Expansion.** Expands to up to length characters of the value of
    parameter starting at the character specified by offset.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**子字符串扩展。** 从偏移量指定的字符开始，将参数值的长度扩展到长度个字符。'
- en: Basically, we specify where we should start our substring, and what length (in
    characters) it should have. As with most things computers, the first character
    will be considered a `0` (and not a `1`, as any non-technical person might expect).
    If we omit the length, we will get everything after the offset; if we do specify
    it, we get exactly that number of characters.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们指定了子字符串应该从哪里开始，以及应该有多长（以字符为单位）。与大多数计算机一样，第一个字符将被视为`0`（而不是任何非技术人员可能期望的`1`）。如果我们省略长度，我们将得到偏移量之后的所有内容；如果我们指定了长度，我们将得到确切数量的字符。
- en: 'Let''s take a look at how this would work for our sentence:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这对我们的句子会怎么样：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In our command-line example, we first create the `${sentence}` variable containing
    our previously-given text. First, we `echo` it fully, before we use `${sentence:0:5}`
    to only print the first five characters (remember, strings start at 0!).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的命令行示例中，我们首先创建包含先前给定文本的`${sentence}`变量。首先，我们完全`echo`它，然后我们使用`${sentence:0:5}`只打印前五个字符（记住，字符串从0开始！）。
- en: Next, we print the first six characters, starting from the second character
    (as denoted by the `:1:6` notation). In the final command, `echo ${sentence:11}`
    shows that we can also use substring expansion without specifying a length. In
    this case, Bash will simply print everything from the offset until it reaches
    the end of the variable's value.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们打印从第二个字符开始的前六个字符（由`:1:6`表示）。在最后一个命令中，`echo ${sentence:11}`显示我们也可以在不指定长度的情况下使用子字符串扩展。在这种情况下，Bash将简单地打印从偏移量到变量值结束的所有内容。
- en: 'We''d like to end this chapter with a promise we made earlier: our three-letter
    acronym script. Now that we know how to easily extract separate letters from the
    user input, it would be fun to create a chant!'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想以前面承诺的方式结束本章：我们的三个字母缩写脚本。现在我们知道如何轻松地从用户输入中提取单独的字母，创建一个咒语会很有趣！
- en: 'Let''s revise the script:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改脚本：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We threw in a few case modifications in there for good measure. After we split
    the letters using substring expansion, we cannot be sure of the casing the user
    has presented us with. Since this is a chant, we'll assume that uppercase is a
    not a bad idea, and we'll uppercase everything.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还加入了一些大小写修改以确保万无一失。在我们使用子字符串扩展拆分字母之后，我们无法确定用户呈现给我们的大小写。由于这是一首咒语，我们假设大写不是一个坏主意，我们将所有内容都转换为大写。
- en: For the single letter, a single caret will do the trick. For the full acronym,
    we use double carets so that all three characters are uppercase. Using the substring
    expansions of `${acronym:0:1}`, `${acronym:1:1}` and `${acronym:2:1}`, we are
    able to get single letters (because the *length* is always 1, but the offset is
    different).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个字母，一个插入符就足够了。对于完整的首字母缩写，我们使用双插入符，以便所有三个字符都是大写。使用`${acronym:0:1}`、`${acronym:1:1}`和`${acronym:2:1}`的子字符串扩展，我们能够获得单个字母（因为*长度*总是1，但偏移量不同）。
- en: For the ever-important readability, we assign these letters to their own variables
    before using them. We could have also used `${acronym:0:1}` directly in the `echo`,
    but since this script isn't too long, we have chosen the more verbose option of
    extra variables, in which the names give away what we achieve with the substring
    expansion.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重要的可读性，我们将这些字母分配给它们自己的变量，然后再使用它们。我们也可以直接在`echo`中使用`${acronym:0:1}`，但由于这个脚本不太长，我们选择了更冗长的额外变量选项，其中名称透露了我们通过子字符串扩展实现的目标。
- en: 'Finally, let''s run this last script and enjoy our personal chant:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们运行这个最后的脚本，享受我们的个人咒语：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Mixed-case, lowercase, uppercase, it does not matter: whatever the user inputs,
    as long as it is three characters, our chant will work just fine. Good stuff!
    Who knew substring expansion could be so convenient?'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 大小写混合，小写，大写，都无所谓：无论用户输入什么，只要是三个字符，我们的咒语就能正常工作。好东西！谁知道子字符串扩展可以如此方便呢？
- en: One very advanced parameter expansion feature is so-called *parameter transformation*.
    Its syntax, `${parameter@operator}`, allows some complex operators to be performed
    on the parameter. To get an idea of what this can do, head over to `man bash`
    and look for Parameter transformation. You'll probably never need it, but the
    functionality is really cool, so it is definitely worth a look!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常高级的参数扩展功能是所谓的*参数转换*。它的语法`${parameter@operator}`允许对参数执行一些复杂的操作。要了解这可以做什么，转到`man
    bash`并查找参数转换。你可能永远不需要它，但功能确实很酷，所以绝对值得一看！
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've discussed everything parameter expansion in Bash. We
    started by recapping how we've used parameter substitution throughout most of
    this book, and how parameter substitution is only a small part of Bash parameter
    expansion.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Bash中的参数扩展。我们首先回顾了我们如何在本书的大部分内容中使用参数替换，以及参数替换只是Bash参数扩展的一小部分。
- en: We moved on to show you how we can use parameter expansion to include default
    values for variables, in case the user does not supply their own. This functionality
    also allows us to present the user with an error message if input is missing,
    although not in the cleanest way.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续向你展示如何使用参数扩展来包括变量的默认值，以防用户没有提供自己的值。这个功能还允许我们在输入缺失时向用户呈现错误消息，尽管不是最干净的方式。
- en: We ended this introduction to parameter expansion by showing you how we could
    use this to determine the length of variable values, and we showed you how we've
    actually used that extensively in the book already, in the form of the `$#` syntax.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过展示如何使用这个来确定变量值的长度来结束了参数扩展的介绍，并且我们向你展示了我们在书中已经广泛使用了这个形式的`$#`语法。
- en: We continued with describing parameter expansions under the heading of *Variable
    manipulation*. This includes the functionality of *pattern substitution*, which
    allows us to replace a part of the variable's value (the *pattern*) with another
    string. In very similar functionality, *pattern removal* allows us to remove some
    of the value that matches a pattern.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在“变量操作”标题下继续描述参数扩展的功能。这包括“模式替换”的功能，它允许我们用另一个字符串替换变量值的一部分（“模式”）。在非常相似的功能中，“模式删除”允许我们删除与模式匹配的部分值。
- en: Next up, we showed you how we can manipulate characters from lowercase to uppercase,
    and vice versa. This functionality was already mentioned earlier in this book,
    but we have now explained it in more depth.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们向您展示了如何将字符从小写转换为大写，反之亦然。这个功能在本书的早期已经提到，但现在我们已经更深入地解释了它。
- en: We ended this chapter with *substring expansion*, which allows us to take parts
    of variables from an *offset* and/or with a specified *length.*
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以“子字符串扩展”结束了本章，它允许我们从“偏移量”和/或指定的“长度”中获取变量的部分。
- en: 'The following commands were introduced in this chapter: `export` and `dirname`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了以下命令：`export`和`dirname`。
- en: Questions
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is parameter substitution?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是参数替换？
- en: How can we include default values for our defined variables?
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何为已定义的变量包含默认值？
- en: How can we use parameter expansion to handle missing parameter values?
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用参数扩展来处理缺失的参数值？
- en: What does `${#*}` do?
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`${#*}`是什么意思？'
- en: How does pattern substitution work when talking about parameter expansions?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在谈论参数扩展时，模式替换是如何工作的？
- en: How is pattern removal related to pattern substitution?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模式删除与模式替换有什么关系？
- en: What types of case modifications can we perform?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以执行哪些类型的大小写修改？
- en: Which two things can we use to get a substring from a variable's value?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪两种方法从变量的值中获取子字符串？
- en: Further reading
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Please refer to the following links for more information on the topics in this
    chapter:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章主题的更多信息，请参考以下链接：
- en: '**TLDP on process substitution**: [http://www.tldp.org/LDP/abs/html/process-sub.html](http://www.tldp.org/LDP/abs/html/process-sub.html)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLDP关于进程替换：[http://www.tldp.org/LDP/abs/html/process-sub.html](http://www.tldp.org/LDP/abs/html/process-sub.html)
- en: '**TLDP on parameter substitution**: [https://www.tldp.org/LDP/abs/html/parameter-substitution.html](https://www.tldp.org/LDP/abs/html/parameter-substitution.html)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TLDP关于参数替换的内容：[https://www.tldp.org/LDP/abs/html/parameter-substitution.html](https://www.tldp.org/LDP/abs/html/parameter-substitution.html)
- en: '**GNU on parameter expansion**: [https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html](https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU关于参数扩展：[https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html](https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html)
