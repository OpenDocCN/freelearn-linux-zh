- en: Chapter 8. Understanding Advanced Networking Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。理解高级网络概念
- en: As we've made our way through our journey into Linux network administration
    so far, we've covered everything from planning, setting up file servers, network
    services, and more. Now as we approach the end of this book, the last few chapters
    will round off this knowledge with information on advanced networking, security,
    and even troubleshooting. In this chapter, we'll take a look at several concepts
    that are a bit more advanced, such as subnetting, routing, and more!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在Linux网络管理方面已经覆盖了从规划、设置文件服务器、网络服务等方面的所有内容。现在，当我们接近本书的结尾时，最后几章将通过关于高级网络、安全性甚至故障排除的信息来完善这些知识。在本章中，我们将介绍一些更高级的概念，例如子网划分、路由等！
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Dividing your network into subnets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的网络划分为子网
- en: Understanding the CIDR notation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解CIDR表示法
- en: Implementing **Quality of Service** (**QoS**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施**服务质量**（**QoS**）
- en: Understanding **Network Address Translation** (**NAT**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解**网络地址转换**（**NAT**）
- en: Routing TCP/IP traffic
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由TCP/IP流量
- en: Creating redundant DHCP and DNS servers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建冗余的DHCP和DNS服务器
- en: Configuring a network gateway
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置网络网关
- en: Dividing your network into subnets
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的网络划分为子网
- en: Unless you're running a very small home or office network, subnetting is generally
    a good idea. Subnetting allows you to split your network into smaller pieces,
    each with their own IP addresses and resources. An example may include placing
    wireless traffic, servers, workstations, and company-issued mobile devices on
    their own subnets. In addition, if there is any specific service on your network
    that receives the most traffic, you can also place that service on its own subnet
    as well. There are endless possibilities, and every administrator will have his
    or her own ideas of the best way of splitting up the network.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您运行的是非常小的家庭或办公网络，否则进行子网划分通常是一个好主意。子网划分允许您将网络分割成更小的部分，每个部分都有自己的IP地址和资源。例如，可以将无线流量、服务器、工作站和公司发放的移动设备放在各自的子网上。此外，如果您的网络上有任何特定服务接收最多的流量，您也可以将该服务放在自己的子网上。有无限的可能性，每个管理员都会有自己关于最佳网络划分方式的想法。
- en: In [Chapter 6](ch06.html "Chapter 6. Configuring Network Services"), *Configuring
    Network Services*, we set up a DHCP server. In it, I included an example of using
    a specific subnet for dynamically leased IP addresses. In that scheme, the network
    we used was `10.10.96.0/22`. This means that we have several networks available
    to us, which include `10.10.96.0`, `10.10.97.0`, `10.10.98.0`, and `10.10.99.0`.
    With this network, we can basically divide several services each into their own
    network. In our configuration, `10.10.99.0` was used for DHCP. But of course,
    there's nothing stopping you from using IP addresses `10.10.96.1` through `10.10.99.254`
    should you decide to do so. It really is up to you how you configure your network.
    In that chapter, we set some of the ground work that will be used in this chapter.
    But we didn't go over how we arrived at these numbers, or how to manually split
    up the network ourselves.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。配置网络服务")中，*配置网络服务*，我们设置了一个DHCP服务器。在其中，我包括了一个使用特定子网动态租用IP地址的示例。在该方案中，我们使用的网络是`10.10.96.0/22`。这意味着我们可以使用几个网络，包括`10.10.96.0`，`10.10.97.0`，`10.10.98.0`和`10.10.99.0`。有了这个网络，我们基本上可以将每个服务划分到自己的网络中。在我们的配置中，`10.10.99.0`用于DHCP。但是，如果您决定这样做，当然可以使用IP地址`10.10.96.1`到`10.10.99.254`。您如何配置您的网络完全取决于您。在该章节中，我们设置了一些将在本章中使用的基础工作。但我们没有讨论如何得出这些数字，或者如何手动分割网络。
- en: The magic in subnetting is all about the subnet mask, though this number is
    only glanced over by most. For quite a few networks, the subnet mask is left at
    its default (`255.255.255.0`) and no one really questions it. If you purchase
    a router from a store and put it into production without configuring it (bad idea),
    you're left with a 24-bit network and a `255.255.255.0` subnet mask. But what
    does this actually mean?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 子网划分的魔力完全在于子网掩码，尽管大多数人只是匆匆一瞥。对于相当多的网络，子网掩码保持默认值（`255.255.255.0`），没有人真正质疑它。如果您从商店购买路由器并在未配置的情况下投入生产（这是个坏主意），您将得到一个24位网络和`255.255.255.0`子网掩码。但这实际上意味着什么呢？
- en: There are two different styles of subnets, **classful** and **classless**. In
    production networks, it's rare that anyone mentions actual classes anymore, as
    classless is how subnetting is done nowadays (more on that later). But before
    we get into classless networking, it's important to understand what came before.
    With our discussion on subnetting, we used the example subnet mask of `255.255.255.0`
    several times, which belongs to what is considered a Class C network. In total,
    there are five classes, Class A through Class E. Classes D and E aren't used for
    much, so we'll stick with Classes A through C for the sake of our discussion of
    classful IP addressing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同的子网风格，**有类**和**无类**。在生产网络中，几乎没有人再提到实际的类，因为现在的子网划分是以无类进行的（稍后详细介绍）。但在我们深入讨论无类网络之前，了解之前的内容是很重要的。在我们讨论子网划分时，我们多次使用了子网掩码`255.255.255.0`的示例，这属于被认为是C类网络的子网掩码。总共有五个类，A类到E类。D类和E类用途不大，所以我们将坚持使用A类到C类来讨论有类IP地址。
- en: 'The subnet masks for classes A to C are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: A到C类的子网掩码如下：
- en: '| Class | Subnet mask |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 子网掩码 |'
- en: '| --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| A | `255.0.0.0` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| A | `255.0.0.0` |'
- en: '| B | `255.255.0.0` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| B | `255.255.0.0` |'
- en: '| C | `255.255.255.0` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| C | `255.255.255.0` |'
- en: 'Each of these subnet masks corresponds to which portion of the IP address is
    designated for the network, and which part is designated for each individual node.
    For example, say we have a network configured with a network address `192.168.50.0`
    as a Class C network. This means that our network has a subnet mask of `255.255.255.0`.
    As with all IPv4 IP addresses, our network address has four octets: `192`, `168`,
    `50`, and `0`. To illustrate how a subnet mask affects an IP address, I''ll line
    up each octet in a table:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些子网掩码对应于IP地址的哪一部分被指定为网络，哪一部分被指定为每个单独的节点。例如，假设我们配置了一个网络地址为`192.168.50.0`的C类网络。这意味着我们的网络有一个子网掩码为`255.255.255.0`。与所有IPv4
    IP地址一样，我们的网络地址有四个八位组：`192`，`168`，`50`和`0`。为了说明子网掩码如何影响IP地址，我将每个八位组排成一张表：
- en: '| 192 | 168 | 50 | 0 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 192 | 168 | 50 | 0 |'
- en: '| 255 | 255 | 255 | 0 |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 255 | 255 | 255 | 0 |'
- en: The purpose of a subnet mask is to *mask out* which octets of an IPv4 address
    correspond to the entire network and which correspond to individual nodes. The
    highest possible number in each octet is `255`. If an octet within a subnet mask
    is set to `255`, which takes up that entire octet and thus cancels it out. In
    this case, the IP address of every node will begin with `192.168.50`, since the
    first three octets were canceled out. Notice that the last octet is a zero in
    both the network address and subnet mask. In IPv4 networking, a `0` means anything.
    Therefore, the last octet of the subnet mask being `0` tells us that it doesn't
    care about that octet, and the network address being `0` means that it doesn't
    either. Thus, any number in the last place is fair game.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 子网掩码的目的是*掩盖*IPv4地址的哪些八位组对应于整个网络，哪些对应于单个节点。每个八位组中可能的最大数字是`255`。如果子网掩码中的一个八位组设置为`255`，那么它将占据整个八位组，因此将其取消。在这种情况下，每个节点的IP地址将以`192.168.50`开头，因为前三个八位组被取消了。请注意，网络地址和子网掩码的最后一个八位组都是零。在IPv4网络中，`0`表示任何内容。因此，子网掩码的最后一个八位组为`0`告诉我们它不关心该八位组，而网络地址为`0`表示它也不关心。因此，最后一位的任何数字都是可以的。
- en: In our case, IP addresses starting from `192.168.50.0` through `192.168.50.255`
    belong to this network (subnet). Well, almost. We could never begin our DHCP IP
    range with distributing the `192.168.50.0` IP address if our subnet mask was `255.255.255.0`.
    This is because the first IP address of a subnet cannot be assigned to a node.
    The first IP address is designated as the **network identifier** and is reserved.
    It's certainly possible to have an IP address ending in `0`, as long as it's not
    the first IP address in the block. But in a Class C network, an IP address of
    `192.168.50.0` is not valid since it is indeed the first address within that subnet.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，从`192.168.50.0`到`192.168.50.255`的IP地址属于这个网络（子网）。嗯，几乎是。如果我们的子网掩码是`255.255.255.0`，我们就不能以分配`192.168.50.0`
    IP地址开始我们的DHCP IP范围。这是因为子网的第一个IP地址不能分配给节点。第一个IP地址被指定为**网络标识符**并被保留。在一个C类网络中，IP地址`192.168.50.0`是无效的，因为它确实是该子网中的第一个地址。
- en: Another IP address that cannot be assigned to any node is the last IP of a subnet.
    In our Class C example, that would be `192.168.255.255`. This IP address is known
    as the **broadcast address** and is also reserved. If a broadcast message needs
    to be sent to the entire network, the broadcast address is used for that purpose.
    With that in mind, the maximum our DHCP range can be in a Class C network such
    as the one used in our example is `192.168.50.1` to `192.168.50.254`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不能分配给任何节点的IP地址是子网的最后一个IP。在我们的C类示例中，那将是`192.168.255.255`。这个IP地址被称为**广播地址**，也是保留的。如果需要向整个网络发送广播消息，就会使用广播地址。考虑到这一点，在我们的示例中使用的C类网络中，我们的DHCP范围的最大值是`192.168.50.1`到`192.168.50.254`。
- en: You may be wondering about the purpose of a broadcast address. As mentioned,
    it allows for packets to be sent to an entire network. In practice, network services,
    such as DHCP, utilize broadcast. When you first plug in a computer to an Ethernet
    cable (a computer that is not programmed with a static IP), it will send a broadcast
    message requesting an IP address. Until it connects, it has no idea what the IP
    address is of your DHCP server. It could be `192.168.1.1`, or even `192.168.1.100`.
    It has no idea whatsoever. By sending broadcast messages, whichever server is
    responsible for DHCP should be able to hear the request and respond to it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道广播地址的目的。如前所述，它允许将数据包发送到整个网络。在实践中，网络服务，如DHCP，利用广播。当你第一次将计算机插入以太网电缆（一个没有静态IP的计算机），它会发送一个广播消息请求IP地址。在连接之前，它不知道你的DHCP服务器的IP地址是什么。它可能是`192.168.1.1`，甚至是`192.168.1.100`。它完全不知道。通过发送广播消息，负责DHCP的任何服务器都应该能够听到请求并做出响应。
- en: So, why was the IP address `192.168.50.0` chosen for the previous example? That
    number was just chosen at random in order to illustrate how the subnet mask impacts
    the IP addresses that are available. We could have used `172.16.254.0` as our
    network address and with the Class C subnet mask of `255.255.255.0`, which would
    still give us the same number of usable IP addresses (254). In this second example,
    we're still declaring a Class C network, but just with a different IP scheme.
    Since you're managing an internal network, you can choose whatever numbering system
    you want. As long as your IP addresses aren't publicly routable, it's all fair
    game as long as you don't use numbers above 255 in any octet, or the first or
    last IP address within a network. There are a few other IP addresses we can't
    use, but we'll get to those later.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么在上面的例子中选择了IP地址`192.168.50.0`？那个数字只是随机选择的，以便说明子网掩码如何影响可用的IP地址。我们可以使用`172.16.254.0`作为我们的网络地址，并且使用C类子网掩码`255.255.255.0`，这仍然会给我们相同数量的可用IP地址（254）。在第二个例子中，我们仍然声明了一个C类网络，但只是使用了不同的IP方案。由于你正在管理一个内部网络，你可以选择任何你想要的编号系统。只要你的IP地址不是公共可路由的，只要你不在任何八位组中使用大于255的数字，或者在网络中使用第一个或最后一个IP地址，那么你可以使用任何数字。还有一些其他IP地址我们不能使用，但我们稍后会讨论。
- en: To better understand how this works, we'll need to revisit subnet masks. As
    mentioned, a subnet mask helps determine which portion of an IP address scheme
    belongs to individual nodes and which portion belongs to the network itself. Think
    about it like this. A value of 255 is the maximum number that can be in any octet
    of a subnet mask or IP address. Each 255 within a subnet mask represents a number
    that cannot change. So, if you have an IP address `10.19.100.24` and a subnet
    mask `255.255.255.0`, you can tell right away that the first three octets of this
    network will never change. This means that every host that is a member of this
    subnet will have an IP address beginning with `10.19.100`. If the subnet mask
    was `255.255.0.0`, there would be more IP addresses available, since the last
    two octets are up for grabs. This would actually give us 65,534 IP addresses.
    The former would only allow us 254 IP addresses, since the last octet is the only
    one that could change and its maximum number is 255 (subtracting one for the broadcast
    address).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这是如何工作的，我们需要重新讨论子网掩码。如前所述，子网掩码有助于确定IP地址方案的哪一部分属于各个节点，哪一部分属于网络本身。可以这样理解。子网掩码中的255是子网掩码或IP地址中任何八位中可能的最大数字。子网掩码中的每个255代表一个不会改变的数字。因此，如果您有一个IP地址`10.19.100.24`和一个子网掩码`255.255.255.0`，您可以立即知道这个网络的前三个八位永远不会改变。这意味着该子网的每个主机都将具有以`10.19.100`开头的IP地址。如果子网掩码是`255.255.0.0`，将有更多的IP地址可用，因为最后两个八位是可用的。这实际上将给我们提供65,534个IP地址。前者只允许我们使用254个IP地址，因为最后一个八位是唯一可以改变的，其最大数字是255（减去一个广播地址）。
- en: But you may have noticed that I used an example of a Class A IP address (`10.19.100.24`),
    but I used a Class C subnet mask (`255.255.255.0`). Is this valid? Sure! Regardless
    of the generally agreed upon class structure, the sole purpose of a subnet mask
    is to help you understand which portion is host and which portion of node. Thus,
    subnet masks of `255.255.0.0` and `255.255.255.0` are both valid for this network.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但您可能已经注意到，我使用了一个Class A IP地址的例子（`10.19.100.24`），但我使用了一个Class C子网掩码（`255.255.255.0`）。这是有效的吗？当然！尽管通常约定的类结构，子网掩码的唯一目的是帮助您理解哪一部分是主机，哪一部分是节点。因此，`255.255.0.0`和`255.255.255.0`的子网掩码对于这个网络都是有效的。
- en: 'However, some IP addresses aren''t considered valid for individual classes.
    While an internal IP network of `253.221.96.0` with a subnet mask of `255.255.255.0`
    fits all these rules, it''s not considered valid for a Class C network. If you''re
    only managing your IP addresses within your network, it may or may not work. So
    for each class in the classful style, there is a recommended scheme to stay within.
    I''ll illustrate that in the following table:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些IP地址并不被认为是适用于各个类别的有效地址。虽然具有子网掩码为`255.255.255.0`的内部IP网络`253.221.96.0`符合所有这些规则，但它并不被认为是Class
    C网络的有效地址。如果您只在网络内管理IP地址，它可能有效，也可能无效。因此，对于经典风格中的每个类别，都有一个推荐的方案可供选择。我将在下表中说明：
- en: '| Class | Beginning IP | Ending IP |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 起始IP | 结束IP |'
- en: '| --- | --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| A | `0.0.0.0` | `127.255.255.255` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| A | `0.0.0.0` | `127.255.255.255` |'
- en: '| B | `128.0.0.0` | `191.255.255.255` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| B | `128.0.0.0` | `191.255.255.255` |'
- en: '| C | `192.0.0.0` | `223.255.255.255` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| C | `192.0.0.0` | `223.255.255.255` |'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As with all things networking, there's an exception to keep in mind here as
    well and you cannot assign `127.0.0.0` or `127.0.0.1` to anything, since that
    refers to your local loop-back adapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有网络相关的事物一样，这里也有一个需要牢记的例外，您不能将`127.0.0.0`或`127.0.0.1`分配给任何东西，因为这是指您的本地环回适配器。
- en: In fact, it's very common with internal networks to start an IP address range
    with `10`, within the Class A scheme. That's what we've done earlier in the book
    when we set up our DHCP server. In that example, we used the `10.10.96.0` network.
    But if you recall, we did not use a Class C subnet mask of `255.255.255.0`; we
    used `255.255.252.0`. This distinction will lead us right into our next topic,
    CIDR.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，使用以`10`开头的IP地址范围在Class A方案中是非常常见的，这就是我们在本书早期设置DHCP服务器时所做的。在那个例子中，我们使用了`10.10.96.0`网络。但是如果您回忆起来，我们没有使用Class
    C子网掩码`255.255.255.0`，而是使用了`255.255.252.0`。这个区别将直接引导我们进入下一个主题CIDR。
- en: Understanding the CIDR notation
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解CIDR表示法
- en: As I mentioned earlier, the concept of classful subnetting isn't used that often
    anymore. The main use of classful subnetting is in the default configuration of
    network appliances (such as routers) and also the default settings of most DHCP
    servers. In the case of home routers, the DHCP server is typically built in, and
    the default scheme is most often a Class C network (typically `192.168.1.0`, with
    a couple of variations in between). But with most devices, home or enterprise,
    you'll probably get a Class C IP scheme if you don't change it to something else.
    There's nothing necessarily wrong with these default settings in a small network,
    but almost no one configuring a network nowadays uses the classful style. The
    reason for this is that classful networks are too limiting; in complex network
    roll-outs, it can be a pain to try to force your network plan to fit within one
    of these predetermined schemes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我之前提到的，经典子网划分的概念现在并不经常使用。经典子网划分的主要用途是网络设备（如路由器）的默认配置，以及大多数DHCP服务器的默认设置。在家用路由器的情况下，DHCP服务器通常是内置的，默认方案通常是Class
    C网络（通常为`192.168.1.0`，中间有几个变化）。但对于大多数设备，家庭或企业，如果您不将其更改为其他内容，您可能会得到一个Class C IP方案。在小型网络中，这些默认设置并没有什么问题，但是几乎没有人在配置网络时使用经典风格。原因是经典网络太过限制；在复杂的网络部署中，强迫您的网络计划适应这些预定方案可能会很麻烦。 '
- en: The answer to the lack of flexibility in classful schemes comes in the form
    of **Classless Inter-Domain Routing** (**CIDR**). With CIDR, we basically throw
    the limitations of Class A, B, and C subnet masks out the window. Instead, we
    use a binary system to determine how to divide our networks. So, rather than stick
    with just three different subnet masks, we can *borrow* bits and change the subnet
    mask to divide networks in more flexible ways.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在有类别的方案中缺乏灵活性的答案是**无类别域间路由**（**CIDR**）。使用CIDR，我们基本上抛弃了类A、B和C子网掩码的限制。相反，我们使用二进制系统来确定如何划分我们的网络。因此，我们不再仅使用三种不同的子网掩码，我们可以*借用*位并更灵活地改变子网掩码以划分网络。
- en: To understand this concept, it's important to first understand the idea of bits.
    Each octet within a subnet mask contains eight bits. Each bit is either a `1`
    or a `0` (binary). Also, each of the eight bits has a value of worth. To illustrate
    this, take the number `255`. This is the highest value any octet can be. Written
    in binary, `255` is `11111111`. Therefore, a Class C subnet mask of `255.255.255.0`
    written in binary would be `11111111.11111111.11111111.00000000`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个概念，首先要理解位的概念。子网掩码中的每个八位组包含八位。每一位都是`1`或`0`（二进制）。此外，这八位中的每一位都有一个值。为了说明这一点，拿数字`255`来说。这是任何八位组的最大值。用二进制写，`255`是`11111111`。因此，一个类C子网掩码`255.255.255.0`用二进制写就是`11111111.11111111.11111111.00000000`。
- en: To make this even easier to understand, see the following table where I outline
    one of the four outlets (`255`) and show it in binary. In this table, the top
    row gives you the point value of each bit. You can see that the rightmost bit
    is worth only `1`, while the leftmost is worth `128`. Any bit that is a `1` on
    the bottom gets totaled up. In this case, every bit is a `1` (since `255` is the
    maximum), so we add up every number on the top row and come out with `255`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易理解，看看下表，我在其中概述了四个插座（`255`）之一，并以二进制形式显示出来。在这个表中，顶部行给出了每个位的点值。你可以看到最右边的位只值`1`，而最左边的位值为`128`。底部的任何位是`1`都会被加起来。在这种情况下，每个位都是`1`（因为`255`是最大值），所以我们把顶部行的每个数字加起来，得到`255`。
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |'
- en: 'For another example, see the following table:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子，参见以下表：
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |'
- en: '| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |'
- en: To convert this number into a decimal, start at the right and work your way
    to the left. The first bit is a 0\. Does it qualify for the point value of 1?
    Nope. Skip it. Next, it doesn't qualify for 2, 4, or 8 either. So skip those.
    But it does qualify for the last four, 16, 32, 64, and 128\. Add those together.
    The answer? 224\. You just converted the binary number of `1111000` into decimal.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这个数字转换成十进制，从右边开始，向左移动。第一位是0。它是否符合1的点值？不符合。跳过。接下来，它也不符合2、4或8。所以跳过这些。但它确实符合最后四位，16、32、64和128。把它们加在一起。答案是224。你刚刚把二进制数`1111000`转换成了十进制。
- en: 'Could we have used `1101000` for a value within a subnet mask? No way. The
    reason is because the bits that are a 1 in a subnet mask must be sequential. The
    following are all valid binary numbers in a subnet mask:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在子网掩码中使用`1101000`吗？不行。原因是因为子网掩码中的1必须是连续的。以下是子网掩码中所有有效的二进制数：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In fact, that's it. Since any 1's must be sequential (starting from the left
    to the right), those are the only numbers that are valid for any octet within
    a subnet mask. Therefore, the only valid decimal values for any octet of a subnet
    mask are 0, 128, 192, 224, 240, 248, 252, 254, and 255.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，就是这样。由于任何1必须是连续的（从左到右开始），这些是子网掩码中任何八位组的唯一有效数字。因此，子网掩码的任何八位组的唯一有效十进制值是0、128、192、224、240、248、252、254和255。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If converting an IP address into binary, you'd follow the same point values
    in the tables previously, though the rule of sequential 1's wouldn't apply. Any
    number from 0 to 255 is valid in any octet in an IP address, as are any combination
    of 1's and 0's in each octet.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将IP地址转换为二进制，你会按照之前的表中的点值进行转换，尽管连续1的规则不适用。IP地址中的任何数字从0到255在任何八位组中都是有效的，每个八位组中的1和0的任何组合也是有效的。
- en: To *subnet* a network, we simply alter the number of sequential 1's. For example,
    the binary representation of `255.255.255.0` is `11111111.11111111.11111111.00000000`.
    We could add an additional 1 to this mask, giving us `11111111.11111111.11111111.10000000`,
    which gives us a subnet mask of `255.255.255.128`. Using this subnet mask, we
    are able to divide our network into two parts. Let's break this down.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要对网络进行*子网化*，我们只需改变连续1的数量。例如，`255.255.255.0`的二进制表示是`11111111.11111111.11111111.00000000`。我们可以在这个掩码中添加一个额外的1，得到`11111111.11111111.11111111.10000000`，这给我们一个子网掩码为`255.255.255.128`。使用这个子网掩码，我们能够将我们的网络分成两部分。让我们来分解一下。
- en: As I've mentioned several times, the purpose of a subnet mask is to *mask out*
    which portion of the IP address is for the network and which portion is for the
    individual nodes. As we already know, a subnet mask of `255.255.255.0` means that
    the first three octets cannot be used, but we can use it as the last one is a
    0\. If we apply this subnet mask to the `10.10.10.0` network, we can tell that
    every host will have an IP address of `10.10.10.x`. The last octet is 0 and it
    tells us that IP addresses `10.10.10.1` to `10.10.10.254` are up for grabs. Again,
    we can't use the first IP of a subnet (`10.10.10.0` in this case) or the last
    (`10.10.10.255`), as those correspond to the network identifier and broadcast
    address, respectively.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我多次提到的，子网掩码的目的是*掩盖*IP地址的哪一部分是网络的，哪一部分是个体节点的。正如我们已经知道的，子网掩码为`255.255.255.0`意味着前三个八位组不能使用，但我们可以使用最后一个为0。如果我们将这个子网掩码应用到`10.10.10.0`网络，我们可以知道每个主机的IP地址都是`10.10.10.x`。最后一个八位组是0，它告诉我们IP地址`10.10.10.1`到`10.10.10.254`是可用的。同样，我们不能使用子网的第一个IP（在这种情况下是`10.10.10.0`）或最后一个（`10.10.10.255`），因为它们分别对应网络标识符和广播地址。
- en: 'But what do we do with a subnet mask that does *not* end in 0? With a subnet
    mask of `255.255.255.128`, the last octet is used but not exhausted, since it''s
    not the maximum value of 255\. We have some left over. This is because when an
    octet is *not* 255 in a subnet mask, it doesn''t completely mask out that octet.
    Instead, it creates a dividing line. If we apply that subnet mask to our `10.10.10.0`
    network, the IP address of `10.10.10.128` cannot be used. What we''ve done is
    split that last octet in half. Remember, values 0 to 255 are valid in an octet;
    thus, 256 available numbers halved is 128\. With that in mind, we created a scheme
    where we have two networks. One network contains IP addresses `10.10.10.1` to
    `10.10.10.126`. The other allows us IP addresses `10.10.10.129` to `10.10.10.254`.
    The reason for this is because `10.10.10.128` is the dividing line of our subnet
    and cannot be used. I also mentioned that the first and last IP addresses within
    a block can''t be used either, because `10.10.10.0` and `10.10.10.128` are the
    identifiers for each network. The last IP addresses in each block are `10.10.10.127`
    and `10.10.10.255`, respectively, and are off-limits because those are now the
    broadcast addresses for these two networks. If we write out these networks in
    the CIDR format, we get the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于一个子网掩码并*不*以0结尾的情况，我们该怎么办呢？对于子网掩码为`255.255.255.128`，最后一个八位组被使用但没有耗尽，因为它不是255的最大值。我们还有一些剩余。这是因为当一个八位组在子网掩码中*不*是255时，它并没有完全屏蔽掉该八位组。相反，它创建了一个分割线。如果我们将该子网掩码应用到我们的`10.10.10.0`网络上，IP地址`10.10.10.128`就不能使用。我们已经将最后一个八位组分成了两半。记住，八位组中的值从0到255都是有效的；因此，256个可用数字的一半是128。考虑到这一点，我们创建了一个方案，其中我们有两个网络。一个网络包含IP地址`10.10.10.1`到`10.10.10.126`。另一个允许我们使用IP地址`10.10.10.129`到`10.10.10.254`。之所以这样做是因为`10.10.10.128`是我们子网的分割线，不能使用。我还提到了块内的第一个和最后一个IP地址也不能使用，因为`10.10.10.0`和`10.10.10.128`是每个网络的标识符。每个块中的最后一个IP地址分别是`10.10.10.127`和`10.10.10.255`，因为这些现在是这两个网络的广播地址。如果我们以CIDR格式写出这些网络，我们会得到以下结果：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Remember, we count the number of sequential ones in the subnet mask to reach
    the *slash* number at the end. We could have written it as the following, but
    I''m sure you''ll agree that CIDR is easier to type:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们计算子网掩码中连续的1的数量，以达到最后的*斜杠*数字。我们可以将其写成以下形式，但我相信你会同意CIDR更容易输入：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In binary, that subnet mask is `11111111.11111111.11111111.1 0000000`. Since
    there are 25 1's, the CIDR notation for this subnet mask is 25\. Hopefully, the
    concept is making sense now.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制中，该子网掩码是`11111111.11111111.11111100.00000000`。因为有25个1，这个子网掩码的CIDR表示法是25。希望现在这个概念已经讲清楚了。
- en: As for our classless style, there's nothing stopping you from using a subnet
    mask such as `255.255.255.0`. Not everyone needs a large number of hosts. But
    instead of calling that a Class C subnet mask, in the CIDR style we would instead
    refer to it as a `/24` network. In the table, I list the subnet masks used in
    discussion of classful networks, as well as their CIDR equivalent.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 至于我们的无类别样式，没有什么能阻止你使用诸如`255.255.255.0`这样的子网掩码。并不是每个人都需要大量的主机。但是，我们不再称之为类C子网掩码，而是在CIDR样式中我们会称之为`/24`网络。在表中，我列出了在讨论有类别网络时使用的子网掩码，以及它们的CIDR等效。
- en: '| Class | Subnet mask | CIDR notation |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: 类别 | 子网掩码 | CIDR表示法
- en: '| --- | --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| A | 255.0.0.0 | /8 |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| A | 255.0.0.0 | /8 |'
- en: '| B | 255.255.0.0 | /16 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| B | 255.255.0.0 | /16 |'
- en: '| C | 255.255.255.0 | /24 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| C | 255.255.255.0 | /24 |'
- en: 'Now that we understand how subnetting works, how do we put this in action in
    our network? Fortunately, that part is easy. The magic for rolling out a subnet
    is all in your DHCP server. If you recall, in [Chapter 6](ch06.html "Chapter 6. Configuring
    Network Services"), *Configuring Network Services*, we used the following configuration
    in our DHCP server''s `/etc/dhcp/dhcpd.conf` file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们了解了子网划分的工作原理，那么我们如何在我们的网络中实施呢？幸运的是，这部分很容易。实施子网的魔力都在于你的DHCP服务器。如果你还记得，在[第6章](ch06.html
    "第6章。配置网络服务")中，*配置网络服务*，我们在DHCP服务器的`/etc/dhcp/dhcpd.conf`文件中使用了以下配置：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the first bold line, I'm providing a subnet mask of `255.255.252.0` to each
    node that receives an IP address from this server. In the block of code toward
    the end, I've decided to issue IP addresses from `10.10.99.100` through `10.10.99.254`.
    Therefore, each node will receive a `10.10.99.x` IP address and a `255.255.252.0`
    subnet mask.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行粗体字中，我为从该服务器接收IP地址的每个节点提供了一个子网掩码为`255.255.252.0`。在代码块的末尾，我决定从`10.10.99.100`到`10.10.99.254`发放IP地址。因此，每个节点将收到一个`10.10.99.x`的IP地址和一个`255.255.252.0`的子网掩码。
- en: The only thing left when rolling out a subnet scheme is to ensure that every
    server or appliance that has a static IP address is also changed. Unless you've
    used a static lease (also known as a *reservation*), you'll have to find those
    hosts and change them manually. For this reason, I always prefer static leases
    over static IPs. With static leases, all you would have to do is edit your DHCP
    configuration and change the IPs distributed to your hosts. Refer to [Chapter
    6](ch06.html "Chapter 6. Configuring Network Services"), *Configuring Network
    Services*, for how we set up our reservations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 实施子网方案时唯一剩下的事情就是确保每个具有静态IP地址的服务器或设备也被更改。除非你使用了静态租约（也称为*保留*），否则你将不得不手动找到这些主机并进行更改。因此，我总是更喜欢静态租约而不是静态IP。使用静态租约，你只需要编辑DHCP配置并更改分配给你的主机的IP。参考[第6章](ch06.html
    "第6章。配置网络服务")中我们是如何设置我们的保留的。
- en: Implementing Quality of Service
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施服务质量
- en: Not all network traffic is created equal nor are all services equally important.
    There are times when a network requires certain services to be treated with more
    urgency than others. Perhaps in a server environment, your web servers receive
    a high level of traffic from visitors and must prioritize MySQL, or perhaps your
    office uses **VoIP** (short for **Voice over IP**) and needs priority placed on
    the phone system. There are many reasons why your network may require a service
    to be treated with more urgency than others. **Quality of Service** (**QoS**)
    helps us achieve this.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的网络流量都是平等的，也并非所有的服务都同等重要。有时，网络需要对某些服务给予比其他服务更紧急的处理。也许在服务器环境中，您的Web服务器从访问者那里接收到大量流量，并且必须优先考虑MySQL，或者您的办公室使用**VoIP**（即**IP电话**）并需要优先考虑电话系统。您的网络可能有许多原因需要对某项服务给予比其他服务更紧急的处理。**服务质量**（**QoS**）帮助我们实现这一点。
- en: 'While there are multiple ways of tweaking network adapters for QoS, the most
    typical is something known as **queuing discipline** (or more simply, **qdisc**).
    A queuing discipline is something an administrator can apply to a network adapter
    to use one of a multiple of schedulers, each with varying effects on how traffic
    is handled. To see which scheduler your network adapter is currently using, run
    the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有多种调整网络适配器以实现QoS的方法，但最典型的是所谓的**排队规则**（或更简单地说，**qdisc**）。排队规则是管理员可以应用于网络适配器的一种方法，以使用多种调度程序中的一种，每种调度程序对流量处理方式有不同的影响。要查看您的网络适配器当前使用的调度程序，请运行以下命令：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Look for your default network card, which will likely either be `eth0` (in Debian)
    or `eno1` (in CentOS) or similar.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 查找您的默认网络卡，很可能是`eth0`（在Debian中）或`eno1`（在CentOS中）或类似的。
- en: '![Implementing Quality of Service](img/B03919_08_01.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![实施服务质量](img/B03919_08_01.jpg)'
- en: Viewing the output of IP link list in Debian
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian中查看IP链接列表的输出
- en: Most likely, you'll see `qdisc pfifo_fast` in the output, which tells us that
    the queuing discipline currently in use is `pfifo_fast`. This is basically a first-come
    first-serve scheduler (first in, first out). But rather than contain a single
    band, `pfifo_fast` it contains three—each separating traffic into three priorities.
    The first band (band 0) contains the highest priority traffic. Each band is handled
    only after the previous one has been serviced. Unless your distribution has changed
    the default scheduler, `pfifo_fast`, is most likely what is currently in use on
    your system out of the box.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最有可能，您会在输出中看到`qdisc pfifo_fast`，这告诉我们当前使用的排队规则是`pfifo_fast`。这基本上是一个先到先服务的调度程序（先进先出）。但`pfifo_fast`不是包含一个带宽，而是包含三个——每个都将流量分为三个优先级。第一个带宽（带宽0）包含最高优先级的流量。除非您的发行版更改了默认调度程序，否则`pfifo_fast`很可能是您系统中默认使用的。
- en: The `pfifo_fast` scheduler is known as a classless scheduler. In other words,
    what you see is what you get—there is no configuration to be done when it comes
    to how classless schedulers filter traffic. Other classless disciplines include
    **Stochastic Fair** **Queuing** (**SFQ**), **Extended Stochastic Fair Queuing**
    (**ESFQ**), and **Token Bucket Filter** (**TBF**).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`pfifo_fast`调度程序被称为无类调度程序。换句话说，你看到的就是你得到的——在处理无类调度程序过滤流量时不需要进行任何配置。其他无类规则包括**随机公平**
    **排队**（**SFQ**）、**扩展随机公平排队**（**ESFQ**）和**令牌桶过滤器**（**TBF**）。'
- en: 'The SFQ qdisc uses the concept of FIFO as we''ve mentioned before, but separates
    network traffic into more than one FIFO, handled in a round-robin fashion. This
    qdisc tries to be as fair as possible, using flows to schedule packet transmission.
    This gives each flow a turn to transmit, preventing any one of them from becoming
    saturated. ESFQ is very similar, but it gives the administrator more options in
    which to configure. Unlike SFQ, TBF does not actually manipulate packets nor does
    it do any scheduling. The main purpose of TBF is to set a rate at which transmission
    will occur, allowing you to set parameters, such as the rate, burst, peakrate,
    and more. For more in-depth information, on these qdiscs, see the main pages for
    `sfq` and `tbf`. Setting the preferred qdisc on a network adapter is done via
    the `tc` command. See the following example for setting `sfq` on Ethernet adapter
    `eno1`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: SFQ qdisc使用了我们之前提到的FIFO的概念，但将网络流量分成多个FIFO，并以循环方式处理。这种qdisc试图尽可能公平地使用流来调度数据包传输。这使得每个流都有机会传输，防止任何一个流变得过度饱和。ESFQ非常相似，但它为管理员提供了更多配置选项。与SFQ不同，TBF实际上不会操纵数据包，也不会进行任何调度。TBF的主要目的是设置传输速率，允许您设置参数，如速率、突发、峰值速率等。有关这些qdisc的更深入信息，请参阅`sfq`和`tbf`的主页。通过`tc`命令可以在网络适配器上设置首选的qdisc。请参阅以下示例，设置以太网适配器`eno1`上的`sfq`：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we're calling the `tc` command with `qdisc` and clarifying that we would
    like to `add` (we can also `del`) a qdisc. We're going to execute this against
    interface `eno1`, and we're requesting this change to egress (`root`) while targeting
    the `sfq` qdisc for our interface. Finally, we're setting our qdisc specific parameters
    (in this case, `pertub`). The perturb parameter allows us to set the seconds in
    which the hashing algorithm for this qdisc will be reset. There are other sfq-specific
    values we can alter, such as the number of flows used, quantum, redflowlimit,
    and more. See `man sfq` for complete descriptions of the parameters that can be
    used with sfq or tbf.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`tc`命令与`qdisc`，并澄清我们想要`add`（我们也可以`del`）一个qdisc。我们将对接口`eno1`执行此操作，并请求将此更改应用于出口（`root`），同时针对我们的接口使用`sfq`
    qdisc。最后，我们设置我们的qdisc特定参数（在本例中为`pertub`）。perturb参数允许我们设置此qdisc的哈希算法将被重置的秒数。我们可以更改其他特定于sfq的值，如使用的流数、量子、redflowlimit等。请参阅`man
    sfq`，了解可以与sfq或tbf一起使用的参数的完整描述。
- en: Where the concept of classless qdiscs falls short is the fact that they don't
    allow you to classify traffic as granularly as one might like. While it is certainly
    useful to change how packets are scheduled, that concept doesn't allow you to
    pick and choose which type of traffic receives priority at any given time. Classful
    qdiscs solves this issue, and gives the administrator much more flexibility. With
    these, you're able to set parents and children, each with different rules. In
    fact, that is the primary difference between classful and classless qdiscs. It's
    not the case that classless qdiscs aren't configurable at all; they just don't
    have the options to support the flexibility of advanced use cases. Next, we'll
    explore the classful qdiscs and how they allow us this added flexibility.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 无类qdisc的概念存在不足之处，即它们不允许你像人们希望的那样对流量进行细致的分类。虽然改变数据包的调度方式肯定是有用的，但这个概念不允许你在任何给定时间选择哪种类型的流量优先级。有类qdisc解决了这个问题，并给管理员更多的灵活性。通过这些，你可以设置父类和子类，每个都有不同的规则。事实上，这是有类和无类qdisc之间的主要区别。无类qdisc并不是完全不可配置；它们只是没有支持高级用例灵活性的选项。接下来，我们将探讨有类qdisc以及它们如何为我们提供这种额外的灵活性。
- en: By utilizing the power of classful qdiscs, you gain almost total control over
    how packets are handled on your network. I said *almost* because it's important
    to remember that the idea of queuing discipline affects only outbound traffic
    (egress) while little can be done to manage incoming traffic. However, on a production
    network, guaranteeing particular services a certain amount of bandwidth can be
    very beneficial. As we've discussed in the previous section, classless qdiscs
    allow us to manage the general way in which packets are handled, but classful
    qdiscs allow us more control by setting classes as well as filters.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用有类qdisc的强大功能，你几乎完全控制了网络上数据包的处理方式。我说*几乎*是因为重要的是要记住，排队规则的概念只影响出站流量（出口），而对于管理入站流量几乎无能为力。然而，在生产网络中，保证特定服务一定数量的带宽是非常有益的。正如我们在前一节中讨论的，无类qdisc允许我们管理数据包处理的一般方式，但有类qdisc通过设置类别和过滤器为我们提供了更多的控制。
- en: A possible scenario you may run into is VoIP traffic becoming unstable, causing
    calls to sound fuzzy or drop altogether. In this case, you may want to guarantee
    more bandwidth to your VoIP server, even if that means sacrificing traffic from
    another source. In addition, SSH is also important on a Linux network. If your
    server is too inundated with packets to even respond to a request to connect to
    it via SSH, that could be a very bad problem since you wouldn't be able to log
    in and correct any issues that may come up. These are very real scenarios many
    face without prioritizing traffic. If there is a service your network or company
    depends on, it's a good measure to prioritize it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到的一个可能情况是VoIP流量变得不稳定，导致通话听起来模糊或完全中断。在这种情况下，你可能希望为你的VoIP服务器保证更多的带宽，即使这意味着牺牲来自其他来源的流量。此外，在Linux网络中，SSH也很重要。如果你的服务器被数据包淹没，甚至无法响应通过SSH连接到它的请求，那可能是一个非常严重的问题，因为你将无法登录并纠正可能出现的任何问题。这些是许多人在没有优先处理流量的情况下面临的非常真实的情况。如果有一个你的网络或公司依赖的服务，优先处理它是一个很好的措施。
- en: The most popular qdisc to achieve this is **Hierarchical Token Bucket** (**HTB**),
    which is a classful qdisc. HTB allows you to control the egress bandwidth used
    on a device, and it is based on the TBF style we discussed earlier. HBT features
    a number of classes that can be used to control traffic, such as setting the `parent`,
    `priority`, `rate`, `ceil`, and the number of burst bytes. See `man htb` to view
    a complete list.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点最流行的qdisc是**分层令牌桶**（**HTB**），这是一个有类qdisc。HTB允许你控制设备上使用的出口带宽，它基于我们之前讨论的TBF风格。HBT具有一些可以用来控制流量的类，比如设置`parent`、`priority`、`rate`、`ceil`和字节的突发数量。查看`man
    htb`以查看完整的列表。
- en: Just as we did with configuring a classless qdisc, the setting of a classful
    qdisc like HTB is also done via the `tc` command. On most systems, this command
    is stored in `/sbin` and is likely not to be in a regular user's path. Type `which
    tc` to locate where this binary is on your distribution. In most cases, your system
    should recognize this command if run while logged in root. What follows is an
    example of the process of setting up HTB as the qdisc for a network device named
    `eth0`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们配置无类qdisc一样，类似HTB的有类qdisc的设置也是通过`tc`命令完成的。在大多数系统上，这个命令存储在`/sbin`中，可能不在常规用户的路径中。输入`which
    tc`来定位这个二进制文件在你的发行版上的位置。在大多数情况下，如果以root用户登录时运行此命令，系统应该能识别这个命令。接下来是一个设置HTB作为名为`eth0`的网络设备的qdisc的过程示例。
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the first command, we're changing the qdisc from the default `pfifo_fast`
    to `htb`. In this command, `root` pertains to the fact we're setting this against
    egress traffic. The handle of `1:` is a name for this particular instance of `htb`.
    Setting a default of `10` means that any traffic that is not specifically classed
    elsewhere will be given a class ID of `1:10`. With the second command, we're creating
    class ID `1:1` and adjusting it to use a rate of `2mbit`. In the third, we're
    doing the same, except we're creating an ID of `1:10` with a ceiling, which will
    limit this class to `1.5mbit`. Because we set the default as `10`, this is the
    class that will be used if we don't specifically target traffic to use something
    else. Finally, I also threw in a third class, `1:20`, which has a much lower limit
    of `100kbps`. With both the `rate` and `ceil` values set to the same value, we
    can reasonably expect traffic under this class to consume `100kbps` but also be
    limited to `100kbps`. You can continue to add additional classes to the `1:` parent
    using this method, as many as you need to split up your bandwidth accordingly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个命令中，我们将qdisc从默认的`pfifo_fast`更改为`htb`。在这个命令中，`root`表示我们正在设置这个出口流量。`1:`的句柄是对`htb`的这个特定实例的名称。将默认设置为`10`意味着任何没有特别分类的流量将被赋予`1:10`的类别ID。通过第二个命令，我们创建了类别ID`1:1`，并将其调整为使用速率`2mbit`。在第三个命令中，我们做了同样的事情，只是我们创建了一个ID为`1:10`的类别，并设置了一个上限，这将限制这个类别为`1.5mbit`。因为我们将默认设置为`10`，所以如果我们没有特别指定流量使用其他类别，就会使用这个类别。最后，我还加入了第三个类别`1:20`，它的上限要低得多，为`100kbps`。通过将`rate`和`ceil`值设置为相同的值，我们可以合理地期望这个类别的流量消耗`100kbps`，但也受到`100kbps`的限制。您可以继续使用这种方法向`1:`父类添加额外的类别，根据需要将带宽分割成多个类别。
- en: 'Now that we have our classes identified, we should put them to use. With our
    previous example, you''ll likely notice your bandwidth is now less than it was
    (assuming your bandwidth is above the `1.5mbit` default that we set). But our
    other two classes are unused, so we can boost our limit our bandwidth for other
    services as we see fit. So, let''s add a filter for SSH. Since SSH doesn''t require
    a great deal of bandwidth, we can assign our `1:20` class to it. To do so, we''ll
    again use the `tc` command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了我们的类别，我们应该开始使用它们。通过我们之前的例子，您可能会注意到您的带宽现在比之前少了（假设您的带宽高于我们设置的`1.5mbit`的默认值）。但我们的其他两个类别没有使用，因此我们可以根据需要提高或限制其他服务的带宽。因此，让我们为SSH添加一个过滤器。由于SSH不需要大量带宽，我们可以将我们的`1:20`类别分配给它。为此，我们将再次使用`tc`命令：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's possible to change the port that your server listens on for SSH connections,
    as we'll discuss in [Chapter 9](ch09.html "Chapter 9. Securing Your Network"),
    *Securing Your Network*. If you changed your SSH port, adjust the `tc` command
    accordingly.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 可以更改服务器用于SSH连接的端口，我们将在[第9章](ch09.html "第9章。保护您的网络")*保护您的网络*中讨论。如果更改了SSH端口，请相应调整`tc`命令。
- en: 'That leaves us with two classes, `1:1` and `1:10`. We can assign filters to
    those as well, depending on which port we would like to classify for the traffic:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这留下了两个类别，`1:1`和`1:10`。我们也可以根据需要为它们分配过滤器，具体取决于我们想要为流量分类的端口：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, I used ports `80` and `5060` for HTTP and VoIP traffic, respectively.
    Your ports may differ, so feel free to adjust the command accordingly to fit the
    needs of your network. But in this hypothetical example, traffic on port `80`
    will be classified as `1:1` and granted a maximum rate of `2mbit` (great for a
    web server), and traffic on port `5060` will be granted `1.5mbit`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用端口`80`和`5060`分别用于HTTP和VoIP流量。您的端口可能不同，因此可以根据您的网络需求自由调整命令。但在这个假设的例子中，端口`80`上的流量将被分类为`1:1`，并被授予最大速率为`2mbit`（非常适合Web服务器），端口`5060`上的流量将被授予`1.5mbit`。
- en: In summary, classless qdiscs allow you to control the general consensus of how
    packets are managed on your system. Depending on your environment, you may find
    that changing to a classless qdisc increases performance. But the real benefit
    comes in the form of classful qdiscs, which allows you more granular control over
    how packets are handled, as well as the rates your server's resources are provided.
    Tuning network performance is a time-consuming task and requires trial and error
    to determine which values, classes, and filters will improve performance on your
    network.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，无类qdisc允许您控制系统上如何管理数据包的一般共识。根据您的环境，您可能会发现切换到无类qdisc会提高性能。但真正的好处在于有类qdisc，它允许您更加精细地控制数据包的处理方式，以及服务器资源提供的速率。调整网络性能是一项耗时的任务，需要通过试错来确定哪些值、类别和过滤器会提高网络性能。
- en: Routing TCP/IP traffic
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由TCP/IP流量
- en: The entire purpose of networking is to get traffic from point A to point B.
    When a computer requests information from another, packets are routed to the destination
    and then back. Sometimes, computers need a little guidance on how to get packets
    to the destination. This is known as **routing**. To assist with this, nodes utilize
    the concept of a **routing table** to help decide where packets should be sent
    given specific destinations. It would be very easy if every network in existence
    used the same IP scheme, but in truth, every network is completely different.
    To talk to a different network, your computer must know how to get to that network.
    Think of a routing table as a map of external destinations and the gateways to
    get to those destinations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的整个目的是将流量从A点传输到B点。当一台计算机从另一台计算机请求信息时，数据包被路由到目的地，然后返回。有时，计算机需要一点指导，以确定如何将数据包传输到目的地。这就是所谓的**路由**。为了帮助实现这一点，节点利用**路由表**的概念来决定特定目的地应该发送数据包的位置。如果每个网络都使用相同的IP方案，那将会非常容易，但事实上，每个网络都是完全不同的。要与不同的网络通信，您的计算机必须知道如何到达该网络。可以将路由表视为外部目的地和到达这些目的地的网关的地图。
- en: To better understand this, let's also talk about the concept of the **default
    gateway**. Typically, the default gateway is a router that understands how to
    talk to other networks. When you send a request for information over a network,
    packets traverse to the local default gateway and then onto other networks from
    there. In the case of a small office or home network, the default gateway is likely
    the router that sits in between your network and the rest of the world. In addition,
    it's also in between your local device and all other devices within your network.
    Without a default gateway, it's unlikely you'd be able to communicate over your
    network at all.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们也谈谈**默认网关**的概念。通常，默认网关是一个理解如何与其他网络通信的路由器。当您在网络上发送信息请求时，数据包会经过本地默认网关，然后从那里进入其他网络。在小型办公室或家庭网络的情况下，默认网关很可能是位于您的网络和世界其他部分之间的路由器。此外，它还位于您的本地设备和网络内所有其他设备之间。如果没有默认网关，您很可能无法在网络上进行通信。
- en: To view your default gateway, issue the `ip route` command and look for the
    line that reads `default via`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看您的默认网关，请发出`ip route`命令，并查找读取`default via`的行。
- en: '![Routing TCP/IP traffic](img/B03919_08_02.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![路由TCP/IP流量](img/B03919_08_02.jpg)'
- en: Output of the ip route command
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ip route命令的输出
- en: 'Without a default gateway (or with a default gateway that hasn''t been properly
    configured), you''re likely to find that you aren''t able to communicate with
    other nodes on your network. In most cases, the default gateway is added to your
    routing table once you receive an address via DHCP. If you''re using a static
    IP configuration, you can manually set the default gateway in Debian via `/etc/network/interfaces`,
    or the init script for your network card in CentOS (such as `/etc/sysconfig/network-scripts/ifcfg-eno1`).
    Here''s a sample of these configuration files with the relevant line highlighted:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有默认网关（或者默认网关没有正确配置），您可能会发现无法与网络上的其他节点进行通信。在大多数情况下，一旦通过DHCP接收到地址，默认网关就会添加到您的路由表中。如果您使用静态IP配置，您可以通过`/etc/network/interfaces`在Debian中手动设置默认网关，或者在CentOS中通过网络卡的init脚本（例如`/etc/sysconfig/network-scripts/ifcfg-eno1`）。以下是这些配置文件的示例，其中突出显示了相关行：
- en: 'The `/etc/network/interfaces` file (Debian):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/network/interfaces`文件（Debian）：'
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `/etc/sysconfig/network-scripts/ifcfg-eno1` file (CentOS):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/sysconfig/network-scripts/ifcfg-eno1`文件（CentOS）：'
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you''d like to set your default gateway even more manually than that, you
    can also do so in your terminal via a shell command, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要比那更手动地设置默认网关，您也可以通过终端使用shell命令来执行此操作，如下所示：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the route command isn't recognized by your system, you'll need to install
    the `net-tools` package.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统不识别route命令，则需要安装`net-tools`软件包。
- en: Simple enough. We use the route command to add a new route; in this case, we're
    adding our default gateway (`default gw`). In this case, we're setting that gateway
    to `10.10.10.1` and binding it to interface `eth0`. It probably goes without saying,
    but once you reboot this machine or restart networking, this setting will likely
    be lost unless you make it permanent by updating the `init` script for your interface
    card, as we discussed earlier.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 足够简单。我们使用route命令来添加新路由；在这种情况下，我们正在添加我们的默认网关（`default gw`）。在这种情况下，我们将该网关设置为`10.10.10.1`并将其绑定到接口`eth0`。可能不用说，但一旦重新启动此计算机或重新启动网络，除非通过更新接口卡的`init`脚本使其永久化，否则此设置可能会丢失，正如我们之前讨论的那样。
- en: To view your routing table, simply execute the `route -n` command without any
    arguments. If the command isn't found, you may need to call out the path (such
    as `/sbin/route`) or run it as root. When you execute this command, you'll see
    the routing table. This will also show you your default gateway.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看您的路由表，只需执行`route -n`命令而不带任何参数。如果找不到该命令，您可能需要调用路径（例如`/sbin/route`）或以root身份运行它。当您执行此命令时，您将看到路由表。这也将显示您的默认网关。
- en: '![Routing TCP/IP traffic](img/B03919_08_03.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![路由TCP/IP流量](img/B03919_08_03.jpg)'
- en: Output of the route -n command
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: route -n命令的输出
- en: 'First up for discussion in regards to this table is the IP address of `0.0.0.0`.
    In terms of networking, this refers to everything. As you can see in the table
    shown in the previous example, the gateway for destination `0.0.0.0` on this network
    is `192.168.1.1`. Therefore, any communication is sent to this IP (after all,
    it is the default gateway). There are also other networks shown in this table
    as well. In my case, they refer to instances of Docker running on this test machine
    as well as KVM virtualization, and each have their own independent virtual networking.
    Since they are all running on this same machine, their gateway is local: `0.0.0.0`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论此表时，首先要讨论的是`0.0.0.0`的IP地址。在网络方面，这指的是一切。正如您在前面的示例中所看到的表中所示的，目的地`0.0.0.0`的网关在这个网络上是`192.168.1.1`。因此，任何通信都会发送到这个IP（毕竟，这是默认网关）。在此表中还显示了其他网络。在我的情况下，它们指的是在此测试机器上运行的Docker实例以及KVM虚拟化，并且每个都有自己独立的虚拟网络。由于它们都在同一台机器上运行，它们的网关是本地的：`0.0.0.0`。
- en: A Linux machine can easily act as a router itself, without the need for expensive
    networking equipment from companies such as Cisco. This flexibility makes Linux
    a very prominent choice for networking, and Linux-based hardware routers are becoming
    quite common. This is due, at least in part, to how easy it is to configure a
    Linux system to be a router. In a nutshell, all it takes to turn a Linux node
    into a router is multiple network interface cards. Each interface card can have
    its own default gateway, so you can actually configure routing the same way as
    how we've added a default gateway for `eth0` earlier in this section. You would
    just do the same for `eth1`, `eth2`, or for whatever other interfaces you may
    have on the system.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Linux机器可以很容易地充当路由器，而无需来自诸如思科公司等公司的昂贵网络设备。这种灵活性使Linux成为网络的一个非常突出的选择，基于Linux的硬件路由器变得非常普遍。这至少部分是因为配置Linux系统成为路由器是多么容易。简而言之，将Linux节点变成路由器所需的只是多个网络接口卡。每个接口卡都可以有自己的默认网关，因此你实际上可以像我们在本节前面为`eth0`添加默认网关一样配置路由。你只需对`eth1`、`eth2`或者系统上其他任何接口执行相同的操作。
- en: However, there is one caveat. With most Linux distributions, routing between
    network interfaces is typically disabled by default. This has caused your author
    much grief and frustration until this became known early on in my career, so I'll
    save you the trouble and show you how to enable routing between interfaces on
    your Linux system.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个例外。对于大多数Linux发行版，默认情况下通常禁用网络接口之间的路由。在我职业生涯的早期，这给你的作者带来了很多痛苦和挫折，直到这一点变得众所周知，所以我会为你节省麻烦，并向你展示如何在Linux系统上启用网络接口之间的路由。
- en: 'First, see if this has already been done for you. While I''ve found that many
    distributions don''t have forwarding enabled by default, some do. Checking this
    is easy:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，看看这是否已经为你完成。虽然我发现许多发行版默认情况下不启用转发，但有些发行版会启用。检查这一点很容易：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What is the output of that command? Is it `1`? If so, you''re all set. If not,
    we''ll need to change this. To do so, simply replace the value with 1 (as root):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 那个命令的输出是什么？是`1`吗？如果是，那就没问题了。如果不是，我们需要进行更改。要做到这一点，只需将值替换为1（作为root）：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'That''s it, you''re done. You just enabled routing between interfaces (forwarding).
    That wasn''t so hard. But, I suppose you''d prefer this to be a permanent change.
    Once you reboot your system, it''s likely that this setting will just revert back
    to its default. To make this change permanent, edit `/etc/sysctl.conf` with your
    favorite text editor (as root) and add the following line to the end of the file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，你完成了。你刚刚启用了网络接口之间的路由（转发）。这并不难。但是，我想你可能更希望这是一个永久性的改变。一旦重新启动系统，这个设置很可能会恢复到默认值。要使这个改变永久生效，用你喜欢的文本编辑器（作为root）编辑`/etc/sysctl.conf`，并在文件末尾添加以下行：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, whenever you reboot your system, you will keep this setting. Of all the
    networking tweaks I've had you do thus far, this was definitely the easiest.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论何时重新启动系统，你都将保留这个设置。在我让你做的所有网络调整中，这绝对是最容易的。
- en: Finally, let's spend a little bit of time on **Network Address Translation**
    (**NAT**). The concept of NAT is to alter packets that are destined for one host
    and alter them so that their destination becomes something else. This alteration
    is actually done by altering the packets themselves, and it can be quite useful
    for managing network routing. The most common use for NAT is to conserve IP addresses,
    which is especially important given the shortage of IPv4 addresses these days.
    If you have a router in your home, you're likely familiar with this concept already.
    Your **Internet Service Provider** (**ISP**) gives you an IP, and that IP is what
    the rest of the world sees you as. But within your local network, you probably
    have a dozen or so devices connected and using the same Internet connection. Each
    of your internal devices have an IP address given to them by your local DHCP server,
    but that address is just local and is not routable to the outside world. In this
    case your router keeps track of the packets coming to and from each of your devices,
    and it alters the packets so that they don't get mixed up and end up at the right
    place.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们花一点时间来讨论**网络地址转换**（**NAT**）。NAT的概念是改变那些目的地是一个主机的数据包，并改变它们的目的地，使其变成其他东西。这种改变实际上是通过改变数据包本身来完成的，对于管理网络路由来说非常有用。NAT最常见的用途是保留IP地址，尤其是考虑到当前IPv4地址短缺的情况下。如果你家里有一台路由器，你可能已经很熟悉这个概念了。你的**互联网服务提供商**（**ISP**）给你一个IP，这个IP就是世界其他地方看到你的IP。但是在你的本地网络中，你可能有十几个设备连接并使用同一个互联网连接。你的每个内部设备都有一个由本地DHCP服务器分配的IP地址，但这个地址只是本地的，不能路由到外部世界。在这种情况下，你的路由器会跟踪每个设备收发的数据包，并改变数据包，使它们不会混淆，并最终到达正确的位置。
- en: For example, say you have a laptop and a desktop (on the same network), and
    you visit [https://www.packtpub.com/](https://www.packtpub.com/) on your laptop.
    Your router sends the request out to the Internet, and delivers the result. Basically,
    your router makes that request on behalf of your laptop. When the return packets
    arrive from [https://www.packtpub.com/](https://www.packtpub.com/), the destination
    address of the packets is changed from your public IP address, back to the IP
    address of the machine that requested the information. This way, you can be reasonably
    sure your laptop will get the reply, since it was the one that asked for it in
    the first place.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一台笔记本电脑和一台台式机（在同一个网络上），你在笔记本电脑上访问[https://www.packtpub.com/](https://www.packtpub.com/)。你的路由器将请求发送到互联网，并传递结果。基本上，你的路由器代表你的笔记本电脑发出请求。当来自[https://www.packtpub.com/](https://www.packtpub.com/)的返回数据包到达时，数据包的目的地地址会从你的公共IP地址更改为请求信息的机器的IP地址。这样，你可以相当肯定你的笔记本电脑会得到回复，因为它是最初发出请求的那个。
- en: 'The concept of NAT is clever, and this isn''t even the only use-case. You could
    even manually alter the destination address yourself as well, which could assist
    you with sending packets to other networks that your internal computers would
    otherwise have no idea how to route to. To alter NAT manually, we use the `ip
    rule` command. Utilizing this command is just a matter of altering the destination
    based on where the traffic is originating from. Consider the following example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: NAT的概念很聪明，这甚至不是唯一的用例。您甚至可以手动更改目标地址，这可以帮助您将数据包发送到内部计算机原本无法路由到的其他网络。要手动更改NAT，我们使用`ip
    rule`命令。利用这个命令只是根据流量的来源改变目的地。考虑以下示例：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This couldn't be simpler. Here, we're telling our system to look for any packets
    that are from `192.168.1.134`, and rewrite them to flow to `10.10.10.1` instead.
    Repeat this for any other *NATing* you need to perform.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这再简单不过了。在这里，我们告诉我们的系统查找任何来自`192.168.1.134`的数据包，并将其重写为流向`10.10.10.1`。对于您需要执行的任何其他*NATing*，请重复此操作。
- en: Creating redundant DHCP and DNS servers
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建冗余的DHCP和DNS服务器
- en: In [Chapter 6](ch06.html "Chapter 6. Configuring Network Services"), *Configuring
    Network Services*, we set up DHCP and DNS servers. This is great, but unfortunately
    there's one major problem. Either one is a single point of failure. If the DHCP
    server were to go down, new devices wouldn't be able to receive an IP address,
    and clients that are currently connected will drop off the network as their current
    IP lease expires. If the DNS server were to go down, clients wouldn't be able
    to reach destinations by the hostname. Depending on the scope of your network,
    this downtime might be hard to deal with, so having redundancy for these services
    may be a good idea.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。配置网络服务")中，我们设置了DHCP和DNS服务器。这很好，但不幸的是有一个主要问题。任何一个都是单点故障。如果DHCP服务器崩溃，新设备将无法接收IP地址，并且当前连接的客户端将在其当前IP租约到期时从网络中断开。如果DNS服务器崩溃，客户端将无法通过主机名到达目的地。根据您的网络范围，这种停机时间可能很难处理，因此为这些服务提供冗余可能是一个好主意。
- en: With a DHCP server configured for redundancy with another server, it will synchronize
    its list of IP addresses that were issued, and each will detect if the other stops
    responding. In this case, the secondary would take over the task of issuing new
    IP addresses. With DNS, it's just a matter of adding another DNS server on your
    network, but I'll talk more about that in just a bit.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了另一台服务器进行冗余的DHCP服务器将同步其已发出的IP地址列表，并且每台服务器都会检测另一台服务器是否停止响应。在这种情况下，备用服务器将接管发放新的IP地址的任务。对于DNS，只需在网络上添加另一台DNS服务器，但我稍后会详细讨论这个问题。
- en: Let's start with adding redundancy to our DHCP server. The initial one that
    was created earlier can be considered the primary server for the sake of simplicity.
    The next thing you would do is create another server to serve as the secondary.
    This can be another physical server or even a VM, the choice is yours. Install
    `isc-dhcp-server` as we discussed in [Chapter 6](ch06.html "Chapter 6. Configuring
    Network Services"), *Configuring Network Services*. Once you have the second server
    stood up, we can begin.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向我们的DHCP服务器添加冗余开始。之前创建的初始服务器可以简单地视为主服务器。接下来要做的是创建另一台服务器作为辅助服务器。这可以是另一台物理服务器，甚至是虚拟机，选择权在你。安装`isc-dhcp-server`，就像我们在[第6章](ch06.html
    "第6章。配置网络服务")中讨论的那样，*配置网络服务*。一旦你有了第二台服务器，我们就可以开始了。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's absolutely *imperative* to ensure the clocks are synchronized on both of
    your DHCP servers before they are placed into production. Before continuing, it
    may be a good idea to double check that NTP is configured and working on both.
    In [Chapter 6](ch06.html "Chapter 6. Configuring Network Services"), *Configuring
    Network Services*, information pertaining to setting up NTP was included.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在将DHCP服务器投入生产之前，务必确保两台DHCP服务器的时钟同步。在继续之前，最好再次检查两者上是否配置了NTP并且正常工作。在[第6章](ch06.html
    "第6章。配置网络服务")中，包括了有关设置NTP的信息。
- en: 'Starting on our primary node, we should add some additional code to our /`etc/dhcp/dhcpd.conf`
    file. I''ve bolded the lines of configuration that are new and for the purpose
    of adding redundancy:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的主节点开始，我们应该向我们的/`etc/dhcp/dhcpd.conf`文件添加一些额外的代码。我已经加粗了新的配置行，以实现冗余：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that the following line was removed:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下行已被删除：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It was replaced by the pool `{}` block in the same section.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它被同一部分中的`{}`块替换了。
- en: 'For the most part, the same configuration we''ve done on our primary server
    can be copied over to the secondary. Feel free to use the /`etc/dhcp/dhcpd.conf`
    file we have here as a base for starting the configuration on the second server.
    Again, I''ll highlight what''s different between the two. The code is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在很大程度上，我们在主服务器上做的相同配置可以复制到辅助服务器上。请随意使用我们在这里的/`etc/dhcp/dhcpd.conf`文件作为在第二台服务器上开始配置的基础。我将再次强调两者之间的不同之处。代码如下：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The following lines were removed from the configuration of the secondary server:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从辅助服务器的配置中删除了以下行：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You should notice that the address of the primary and secondary are reversed
    in each. In the first configuration file, the primary is `10.10.96.1` and the
    secondary was set to `10.10.96.2`. In the second, this was changed to `10.10.96.2`
    and `10.10.96.1`, respectively. Also, pay careful attention to the IP addresses,
    subnet mask, and any other value that would likely be different from one network
    to the next. If you start the DHCP service on both your servers (on Debian, it's
    `isc-dhcp-server`, and on CentOS it's `dhcpd`) you should see them communicate
    via the logs. The specific logs to check would be `/var/log/syslog` in Debian-based
    systems and `/var/log/messages` in CentOS systems. You can easily test if this
    is working, by disabling the DHCP service on one of the servers and you should
    see the other issuing IP addresses in its place.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到主要和次要的地址在每个配置文件中是颠倒的。在第一个配置文件中，主要是`10.10.96.1`，次要设置为`10.10.96.2`。在第二个配置文件中，这被更改为`10.10.96.2`和`10.10.96.1`。此外，要特别注意IP地址、子网掩码和任何其他值，这些值可能会因网络而异。如果你在两台服务器上启动DHCP服务（在Debian上是`isc-dhcp-server`，在CentOS上是`dhcpd`），你应该看到它们通过日志进行通信。要检查的具体日志将在基于Debian的系统中是`/var/log/syslog`，在CentOS系统中是`/var/log/messages`。你可以很容易地测试这是否有效，方法是在其中一台服务器上禁用DHCP服务，然后你应该看到另一台服务器代替它发放IP地址。
- en: Now that we have redundancy configured for DHCP, let's do the same for DNS.
    In fact, this is a great deal easier. All you have to do is designate another
    server to act as your secondary DNS server (you can create a new machine, or just
    add it to your secondary DHCP server) and then copy over your configuration files
    and zone files to the new server. Again, [Chapter 6](ch06.html "Chapter 6. Configuring
    Network Services"), *Configuring Network Services*, has all the relevant details
    for these files. If you want to save a bit of time, you could even just clone
    your original DNS server into a new machine, which is easy to do if you're using
    virtualization or understand how to use the `dd` command. After whatever method
    you prefer for creating the secondary server and copying your zone files over,
    test that DNS is working on the new server. Once it is, we turn back to our DHCP
    configuration to deploy this secondary server to all of our nodes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为DHCP配置了冗余，让我们为DNS做同样的事情。事实上，这要容易得多。你所需要做的就是指定另一台服务器作为你的次要DNS服务器（你可以创建一台新的机器，或者只是将它添加到你的次要DHCP服务器），然后将你的配置文件和区域文件复制到新的服务器上。同样，[第6章](ch06.html
    "第6章。配置网络服务")，“配置网络服务”，包含了这些文件的所有相关细节。如果你想节省一些时间，甚至可以将你的原始DNS服务器克隆到一台新的机器上，如果你使用虚拟化或了解如何使用`dd`命令，这是很容易做到的。无论你喜欢使用哪种方法来创建次要服务器并复制你的区域文件，都要测试DNS是否在新服务器上工作。一旦它工作了，我们就回到我们的DHCP配置，将这个次要服务器部署到我们所有的节点上。
- en: 'In our /`etc/dhcp/dhcpd.conf` file, look for the following line:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`/etc/dhcp/dhcpd.conf`文件中，查找以下行：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Change it to the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为以下内容：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You're done. Now, every time your clients' lease expires or they request a new
    IP address, they'll automatically be provided the secondary DNS address.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你完成了。现在，每当你的客户的租约到期或他们请求一个新的IP地址时，他们将自动获得次要DNS地址。
- en: The only thing left to do at this point is to configure any nodes you may have
    set up with static IP addresses to use the secondary DNS server. As I've mentioned
    somewhere in the neighborhood of a thousand times by now, I highly prefer static
    leases (reserving IP addresses for various nodes on the DHCP server) to manual
    static IP assignments for this reason and more. You only need to configure them
    in the DHCP server. But if you do have any nodes you've configured networking
    by hand (to each their own), just update their `init` scripts. Again, you'll find
    this configuration in `/etc/network/interfaces` (Debian) or `/etc/sysconfig/network-scripts/<if-name>.cfg`
    (CentOS).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上唯一剩下的事情就是配置你可能设置了静态IP地址的任何节点来使用次要DNS服务器。正如我现在已经提到过大约一千次，出于这个原因和更多原因，我非常喜欢静态租约（为DHCP服务器上的各个节点保留IP地址）而不是手动静态IP分配。你只需要在DHCP服务器中配置它们。但是，如果你有任何你手动配置了网络的节点（各有各的方式），只需更新它们的`init`脚本。同样，你会在`/etc/network/interfaces`（Debian）或`/etc/sysconfig/network-scripts/<if-name>.cfg`（CentOS）中找到这个配置。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At this point in our journey, your network should be in much better shape. In
    this chapter, we accomplished quite a bit. We've discussed advanced topics such
    as routing, NAT, subnetting, Quality of Service, and we even set up redundancy
    for our DHCP and DNS servers. It would sure be a shame if something were to happen
    to our awesome network. That's why in the next chapter, I'll cover how to strengthen
    the security of our network. See you there!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的旅程中的这一点上，你的网络应该处于更好的状态。在本章中，我们完成了相当多的工作。我们讨论了诸如路由、NAT、子网划分、服务质量等高级主题，甚至为我们的DHCP和DNS服务器设置了冗余。如果我们了不起的网络发生了什么事情，那真是太遗憾了。这就是为什么在下一章中，我将介绍如何加强我们网络的安全性。到时见！
