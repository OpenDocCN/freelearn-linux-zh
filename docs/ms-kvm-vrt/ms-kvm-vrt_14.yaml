- en: '*Chapter 11*: Ansible and Scripting for Orchestration and Automation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：Ansible和编排自动化'
- en: Ansible has become the de facto standard in today's open source community because
    it offers so much while asking so little of you and your infrastructure. Using
    Ansible with **Kernel-based Virtual Machine** (**KVM**) also makes a lot of sense,
    especially when you think about larger environments. It doesn't really matter
    if it's just a simple provisioning of KVM hosts that you want to do (install libvirt
    and related software), or if you want to uniformly configure KVM networking on
    hosts – Ansible can be invaluable for both. For example, in this chapter, we will
    use Ansible to deploy a virtual machine and multi-tier application that's hosted
    inside KVM virtual machines, which is a very common use case in larger environments.
    Then, we'll move to more pedantic subjects of combining Ansible and cloud-init
    since they differ in terms of timeline when they're applied and a way in which
    things get done. Cloud-init is an ideal automatic way for initial virtual machine
    configuration (hostname, network, and SSH keys). Then, we usually move to Ansible
    so that we can perform additional orchestration post-initial configuration – add
    software packages, make bigger changes to the system, and so on. Let's see how
    we can use Ansible and cloud-init with KVM.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible已经成为当今开源社区的事实标准，因为它提供了很多功能，同时对您和您的基础设施要求很少。在**基于内核的虚拟机**（**KVM**）中使用Ansible也是很有意义的，特别是当您考虑到更大的环境。无论您只是想要简单地配置KVM主机（安装libvirt和相关软件），还是想要统一配置主机上的KVM网络
    - Ansible对于这两者都非常有价值。例如，在本章中，我们将使用Ansible来部署托管在KVM虚拟机内的虚拟机和多层应用程序，这在更大的环境中是非常常见的用例。然后，我们将转向更加严谨的主题，结合Ansible和cloud-init，因为它们在应用时间轴和完成方式上有所不同。Cloud-init是一种理想的自动化初始虚拟机配置的方式（主机名、网络和SSH密钥）。然后，我们通常转向Ansible，以便在初始配置后执行额外的编排
    - 添加软件包，对系统进行更大的更改等等。让我们看看如何在KVM中使用Ansible和cloud-init。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Understanding Ansible
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Ansible
- en: Provisioning a virtual machine using the `kvm_libvirt` module
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`kvm_libvirt`模块来配置虚拟机
- en: Using Ansible and cloud-init for automation and orchestration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible和cloud-init进行自动化和编排
- en: Orchestrating multi-tier application deployment on KVM VMs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在KVM虚拟机上编排多层应用程序部署
- en: Learning by example, including various examples on how to use Ansible with KVM
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过示例学习，包括如何在KVM中使用Ansible的各种示例
- en: Let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Understanding Ansible
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Ansible
- en: One of the primary roles of a competent administrator is to try and automate
    themselves out of everything they possibly can. There is a saying that you must
    do everything manually at least once. If you must do it again, you will probably
    be annoyed by it, and the third time you must do it, you will automate the process.
    When we talk about automation, it can mean a lot of different things.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个称职管理员的主要职责之一是尽可能自动化自己的工作。有一句话说，你必须手动做一次所有的事情。如果你必须再做一次，你可能会对此感到恼火，第三次你必须做的时候，你会自动化这个过程。当我们谈论自动化时，它可能意味着很多不同的东西。
- en: Let's try to explain this with an example as this is the most convenient way
    of describing the problem and solution. Let's say that you're working for a company
    that needs to deploy 50 web servers to host a web application, with standard configuration.
    Standard configuration includes the software packages that you need to install,
    the services and network settings that need to be configured, the firewall rules
    that need to be configured, and the files that need to be copied from a network
    share to a local disk inside a virtual machine so that we can serve these files
    via a web server. How are you going to make that happen?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来解释这个问题和解决方案，因为这是描述问题和解决方案最方便的方式。假设你在一家公司工作，需要部署50台Web服务器来托管一个Web应用程序，具有标准配置。标准配置包括需要安装的软件包、需要配置的服务和网络设置、需要配置的防火墙规则，以及需要从网络共享复制到虚拟机内部的本地磁盘上的文件，以便我们可以通过Web服务器提供这些文件。你将如何实现这一点？
- en: 'There are three basic approaches that come to mind:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种基本的方法：
- en: Do everything manually. This will cost a lot of time and there will be ample
    opportunity to do something wrong as we're humans, after all, and we make mistakes
    (pun intended).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动做所有事情。这将花费很多时间，也会有很多机会出错，因为毕竟我们是人类，会犯错误（故意的）。
- en: Try to automate the process by deploying 50 virtual machines and then throwing
    the whole configuration aspect into a script, which can be a part of the automated
    installation procedure (for example, kickstart).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试通过部署50台虚拟机来自动化流程，然后将整个配置方面放入脚本中，这可以成为自动安装过程的一部分（例如，kickstart）。
- en: Try to automate the process by deploying a single virtual machine template that
    will contain all the moving parts already installed. This means we just need to
    deploy these 50 virtual machines from a virtual machine template and do a bit
    of customization to make sure that our virtual machines are ready to be used.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试通过部署一个包含所有组件的单个虚拟机模板来自动化流程。这意味着我们只需要从虚拟机模板部署这50台虚拟机，并进行一些定制，以确保我们的虚拟机准备好使用。
- en: There are different kinds of automation available. Pure scripting is one of
    them, and it involves creating a script out of everything that needs to run more
    than once. An administrator that has been doing a job for years usually has a
    batch of useful scripts. Good administrators also know at least one programming
    language, even when they hate to admit it, since being an administrator means
    having to fix things after others break them, and it sometimes involves quite
    a bit of programming.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的自动化可用。纯脚本编写是其中之一，它涉及将需要多次运行的所有内容创建成脚本。做了多年工作的管理员通常都有一堆有用的脚本。优秀的管理员通常至少懂一种编程语言，即使他们不愿承认，因为作为管理员意味着在别人弄坏东西后需要修复，有时需要相当多的编程。
- en: So, if you're considering doing automation via a script, we absolutely agree
    with you that it's doable. But the question remains regarding how much time you'll
    spend covering every single aspect of that script to get everything right so that
    the script *always* works properly. Furthermore, if it doesn't, you're going to
    have to do a lot of manual labor to make it right, without any real way of amending
    an additional configuration on top of the previous, unsuccessful one.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你考虑通过脚本进行自动化，我们完全同意这是可行的。但问题在于，你将花费多少时间来覆盖脚本的每一个方面，以确保脚本*始终*正常工作。此外，如果脚本出现问题，你将不得不进行大量的手动劳动来修复它，而没有任何真正的方法在之前不成功的配置之上进行额外的修正。
- en: This is where procedure-based tools such as Ansible come in handy. Ansible produces
    **modules** that get pushed to endpoints (in our example, virtual machines) that
    bring our object to a *desired state*. If you're coming from the Microsoft PowerShell
    world, yes, Ansible and PowerShell **Desired State Configuration** (**DSC**) are
    essentially trying to do the same thing. They just go about it in a different
    way. So, let's discuss these different automatization processes to see where Ansible
    fits into that world.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基于过程的工具如Ansible派上用场的地方。Ansible生成**模块**，将其推送到端点（在我们的示例中是虚拟机），将我们的对象带到*期望的状态*。如果你来自Microsoft
    PowerShell世界，是的，Ansible和PowerShell **期望状态配置**（**DSC**）基本上是在尝试做同样的事情。它们只是以不同的方式去做。所以，让我们讨论这些不同的自动化过程，看看Ansible在其中的定位。
- en: Automation approaches
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化方法
- en: In general, all of this applies to administering systems and their parts, installing
    applications, and generally taking care of things inside the installed system.
    This can be considered an *old* approach to administration since it generally
    deals with services, not servers. At the same time, this kind of automation is
    decidedly focused on a single server or a small number of servers since it doesn't
    scale well. If we need to work on multiple servers, using regular scripts creates
    new problems. We need to take a lot of additional variables into account (different
    SSH keys, hostnames, and IP addresses) since scripts are more difficult to expand
    to work on multiple servers (which is easy in Ansible).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，所有这些都适用于管理系统及其部件，安装应用程序，并且通常照顾已安装系统内部的事务。这可以被认为是一种*旧*的管理方法，因为它通常处理的是服务，而不是服务器。与此同时，这种自动化明显地专注于单个服务器或少量服务器，因为它的扩展性不强。如果我们需要处理多个服务器，使用常规脚本会带来新的问题。因为脚本更难以扩展到多个服务器上（而在Ansible中很容易），我们需要考虑很多额外的变量（不同的SSH密钥、主机名和IP地址）。
- en: If one script isn't enough, then we have to move to multiple scripts, which
    creates a new problem, one of which is script management. Think about it – what
    happens when we need to change something in a script? How do we make sure that
    all the instances on all the servers are using the same version, especially if
    the server IP addresses aren't sequential? So, to conclude, while old and tested,
    this kind of automation has serious drawbacks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个脚本不够，那么我们就必须使用多个脚本，这就产生了一个新问题，即脚本管理。想想看 - 当我们需要在脚本中做一些更改时会发生什么？我们如何确保所有服务器上的所有实例都使用相同的版本，特别是如果服务器IP地址不是顺序的呢？因此，总之，虽然旧的和经过测试，这种自动化方式有严重的缺点。
- en: 'There''s another kind of automation that is gathering traction in the DevOps
    community – Automation with a capital A. This is a way to automate systems operation
    across different machines – even across different operating systems. There are
    a couple of automation systems that enable this, and they can basically be divided
    into two groups: systems that use agents and agentless systems.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在DevOps社区中，还有另一种自动化方式正在受到关注 - 大写字母A的自动化。这是一种在不同机器上自动化系统操作的方式 - 甚至在不同操作系统上也是如此。有一些自动化系统可以实现这一点，它们基本上可以分为两组：使用代理的系统和无代理系统。
- en: Systems that use agents
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用代理的系统
- en: Systems that use agents are more common since they have a few advantages over
    agentless systems. The first and foremost advantage is their ability to track
    not only changes that need to be done, but also changes that the user makes to
    the system. This change tracking means that we can track what is happening across
    systems and take appropriate actions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代理的系统更常见，因为它们比无代理系统有一些优势。首要的优势是它们能够跟踪不仅需要进行的更改，还能跟踪用户对系统所做的更改。这种更改跟踪意味着我们可以跟踪系统上发生的事情并采取适当的行动。
- en: 'Almost all of them work in the same way. A small application – called an agent
    – is installed on the system that we need to monitor. After the application has
    been installed, it connects, or permits connections, from the central server,
    which handles everything regarding automation. Since you are reading this, you
    are probably familiar with systems like this. There are quite a few of them around,
    and chances are you''ve already run into one of them. To understand this principle,
    take a look at the following diagram:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的工作方式都是一样的。一个小应用程序 - 称为代理 - 安装在我们需要监视的系统上。应用程序安装完成后，它连接或允许来自中央服务器的连接，中央服务器处理自动化的所有事务。由于你正在阅读这篇文章，你可能对这样的系统很熟悉。这样的系统有很多，很有可能你已经遇到过其中的一个。为了理解这个原理，看一下下面的图表：
- en: '![Figure 11.1 – The management platform needs an agent to connect to objects
    that need orchestration and automation'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 - 管理平台需要代理连接到需要编排和自动化的对象'
- en: '](img/B14834_11_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_01.jpg)'
- en: Figure 11.1 – The management platform needs an agent to connect to objects that
    need orchestration and automation
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 - 管理平台需要代理连接到需要编排和自动化的对象
- en: In these systems, agents have a dual purpose. They are here to run whatever
    needs to run locally, and to constantly monitor the system for changes. This change-tracking
    ability can be accomplished in different ways, but the result is similar – the
    central system will know what has changed and in what way. Change-tracking is
    an important thing in deployment since it enables compliance checking in real-time
    and prevents a lot of problems that arise from unauthorized changes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些系统中，代理有双重目的。它们在这里运行需要在本地运行的任何东西，并不断监视系统的变化。这种变化跟踪能力可以通过不同的方式实现，但结果是相似的 -
    中央系统将知道发生了什么变化以及以何种方式发生了变化。变化跟踪在部署中是一件重要的事情，因为它能够实时进行合规性检查，并防止由未经授权的变化引起的许多问题。
- en: Agentless systems
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无代理系统
- en: 'Agentless systems behave differently. Nothing is installed on the system that
    has to be managed; instead, the central server (or servers) does everything using
    some kind of command and control channel. On Windows, this may be **PowerShell**,
    **WinRM**, or something similar, while on Linux, this usually **SSH** or some
    other remote execution framework. The central server creates a task that then
    gets executed through the remote channel, usually in the form of a script that
    is copied and then started on the target system. This is what this principle would
    look like:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 无代理系统的行为不同。在需要管理的系统上没有安装任何东西；相反，中央服务器（或服务器）使用某种命令和控制通道执行所有操作。在Windows上，这可能是**PowerShell**，**WinRM**或类似的东西，而在Linux上，通常是**SSH**或其他远程执行框架。中央服务器创建一个任务，然后通过远程通道执行，通常以脚本的形式在目标系统上复制并启动。这就是这个原则的样子：
- en: '![Figure 11.2 – The management platform doesn''t need an agent to connect to
    objects that need orchestration and automation'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2 - 管理平台不需要代理连接需要编排和自动化的对象'
- en: '](img/B14834_11_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_02.jpg)'
- en: Figure 11.2 – The management platform doesn't need an agent to connect to objects
    that need orchestration and automation
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 - 管理平台不需要代理连接需要编排和自动化的对象
- en: Regardless of their type, these systems are usually called either automation
    or configuration management systems, and although these are two de facto standards
    yet completely different things, in reality, they are used indiscriminately. At
    the time of writing, two of the most popular are Puppet and Ansible, although
    there are others (Chef, SaltStack, and so on).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 无论其类型如何，这些系统通常被称为自动化或配置管理系统，尽管这两者是两个事实上的标准，但在现实中它们被不加区分地使用。在撰写本文时，最受欢迎的两个是Puppet和Ansible，尽管还有其他的（Chef、SaltStack等）。
- en: In this chapter, we will cover Ansible since it is easy to learn, agentless,
    and has a big pool of users on the internet.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Ansible，因为它易于学习，无代理，并且在互联网上有大量用户。
- en: Introduction to Ansible
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible介绍
- en: Ansible is an IT automation engine – some call it an automation framework –
    that enables administrators to automate provisioning, configuration management,
    and many everyday tasks a system administrator may need to accomplish.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个IT自动化引擎 - 有些人称其为自动化框架 - 它使管理员能够自动化配置、配置管理和许多系统管理员可能需要完成的日常任务。
- en: The easiest (and way too simplified) way of thinking about Ansible is that it
    is a complicated set of scripts that are intended to accomplish administration
    tasks on a large scale, both in terms of complexity and the sheer number of systems
    it can control. Ansible runs on a simple server that has all the parts of the
    Ansible system installed. It requires nothing to be installed on the machines
    it controls. It is safe to say that Ansible is completely agentless and that in
    order to accomplish its goal, it uses different ways to connect to remote systems
    and push small scripts to them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Ansible最简单（也太过简化）的思考方式是，它是一组复杂的脚本，旨在以大规模的方式（无论是在复杂性还是它可以控制的系统数量方面）完成管理任务。Ansible运行在一个安装了Ansible系统所有部分的简单服务器上。它不需要在所控制的机器上安装任何东西。可以说Ansible完全无代理，并且为了实现其目标，它使用不同的方式连接到远程系统并向其推送小型脚本。
- en: This also means that Ansible has no way of detecting changes on the systems
    it controls; it is completely up to the configuration script we create to control
    what happens if something is not as we expect it to be.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着Ansible无法检测所控制系统上的变化；完全取决于我们创建的配置脚本来控制如果某些情况不如预期发生时会发生什么。
- en: There are a couple of things that we need to define before doing everything
    else – things that we can think of as *building blocks* or modules. Ansible likes
    to call itself a radically simple IT engine, and it only has a couple of these
    building blocks that enable it to work.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在做其他事情之前，我们需要定义一些东西 - 我们可以将其视为*构建块*或模块。Ansible喜欢称自己为一个根本简单的IT引擎，它只有几个使其能够工作的这些构建块。
- en: First, it has **inventories** – lists of hosts that define what hosts a certain
    task will be performed on. Hosts are defined in a simple text file and can be
    as simple as a straight list that contains one host per line, or as complicated
    as a dynamic inventory that is created as Ansible is performing a task. We will
    cover these in more detail as we show how they are used. The thing to remember
    is that hosts are defined in text files as there are no databases involved (although
    there can be) and that hosts can be grouped, a feature that you will use extensively.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它有**清单** - 定义了某个任务将在哪些主机上执行的主机列表。主机在一个简单的文本文件中定义，可以是一个简单的包含每行一个主机的直接列表，也可以是一个在Ansible执行任务时创建的动态清单。我们将在展示它们如何使用时更详细地介绍这些内容。要记住的是，主机在文本文件中定义，没有涉及数据库（尽管可以有），主机可以被分组，这是一个你会广泛使用的功能。
- en: Secondly, there's a concept called *play*, which we will define as a set of
    different tasks run by Ansible on target hosts. We usually use a playbook to start
    a play, which is another type of object in the Ansible hierarchy.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，有一个称为*play*的概念，我们将其定义为Ansible在目标主机上运行的一组不同任务。我们通常使用一个playbook来启动一个play，这是Ansible层次结构中的另一种对象。
- en: In terms of playbooks, think of them as a policy or a set of tasks/plays that
    are required to do something or achieve a certain state on a particular system.
    Playbooks are also text files and are specifically designed to be readable by
    humans and are created by humans. Playbooks are used to define a configuration
    or, to be more precise, declare it. They can contain steps that start different
    tasks in an ordered manner. These steps are called plays, hence the name playbook.
    The Ansible documentation is helpful in explaining this as thinking about plays
    in sports where list of tasks that may be performed are provided and need to be
    documented, but at the same time may not be called. The important thing to understand
    here is that our playbooks can have decision-making logic inside them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就playbooks而言，将它们视为一项政策或一组任务/操作，这些任务/操作需要在特定系统上执行某些操作或达到某种状态。Playbooks也是文本文件，专门设计为可读性强，由人类创建。Playbooks用于定义配置或更准确地说是声明配置。它们可以包含以有序方式启动不同任务的步骤。这些步骤称为plays，因此得名playbook。Ansible文档对此有所帮助，将plays比作体育比赛中提供的任务清单，并需要进行记录，但同时可能不会被调用。在这里需要理解的重要一点是，我们的playbooks可以在其中包含决策逻辑。
- en: The fourth big part of the Ansible puzzle are its **modules**. Think of modules
    as small programs that are executed on the machines you are trying to control
    in order to accomplish something. There are literally hundreds of modules included
    with the Ansible package, and they can be used individually or inside your playbooks.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible拼图的第四个重要部分是它的模块。将模块视为在您试图控制的机器上执行的小程序，以实现某些目标。Ansible软件包中包含了数百个模块，它们可以单独使用或在您的playbooks中使用。
- en: Modules allow us to accomplish tasks, and some of them are strictly declarative.
    Others return data, either as the results of the tasks the modules did, or explicit
    data that the module got from a running system through a process called fact gathering.
    This process is based on a module called `gather_facts`. Gathering correct facts
    about the system is one of the most important things we can do once we've started
    to develop our own playbooks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 模块允许我们完成任务，其中一些模块是严格声明性的。其他模块返回数据，要么作为模块执行的任务的结果，要么作为模块通过称为事实收集的过程从运行中的系统获取的显式数据。这个过程基于一个称为`gather_facts`的模块。收集关于系统的正确事实是我们开始开发自己的playbooks后可以做的最重要的事情之一。
- en: 'The following architecture shows all of these parts working together:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下架构显示了所有这些部分如何一起工作：
- en: '![Figure 11.3 – Ansible architecture – Python API and SSH connections'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3 - Ansible架构 - Python API和SSH连接'
- en: '](img/B14834_11_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_03.jpg)'
- en: Figure 11.3 – Ansible architecture – Python API and SSH connections
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 - Ansible架构 - Python API和SSH连接
- en: 'The general consensus among the people working in IT is that management via
    Ansible is easier to do than via other tools as it doesn''t require you to waste
    days on setup or on playbook development. Make no mistake, however: you will have
    to learn your way around YAML syntax to use Ansible extensively. That being said,
    if you''re interested in a more GUI-based approach, you can always consider buying
    Red Hat Ansible Tower.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在IT领域工作的人普遍认为，通过Ansible进行管理比通过其他工具更容易，因为它不需要您在设置或playbook开发上浪费几天的时间。然而，不要误解：您必须学习如何使用YAML语法来广泛使用Ansible。也就是说，如果您对基于GUI的方法感兴趣，您可以考虑购买Red
    Hat Ansible Tower。
- en: Ansible Tower is a GUI-based utility that you can use to manage your Ansible-based
    environments. This started as a project called **AWX**, which is still very much
    alive today. But there are some key differences in the way in which AWX gets released
    versus how Ansible Tower gets released. The main one is the fact that Ansible
    Tower uses specific release versions while AWX takes a more *what OpenStack used
    to be* approach – a project that's moving forward rather quickly and has new releases
    very often.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Tower是一个基于GUI的实用工具，您可以使用它来管理基于Ansible的环境。这最初是一个名为AWX的项目，今天仍然非常活跃。但是AWX发布的方式与Ansible
    Tower发布的方式有一些关键区别。主要区别在于Ansible Tower使用特定的发布版本，而AWX采用了更像是OpenStack的方法 - 一个项目在快速前进并经常发布新版本。
- en: 'As Red Hat clearly states on [https://www.ansible.com/products/awx-project/faq](https://www.ansible.com/products/awx-project/faq),
    that:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Red Hat在[https://www.ansible.com/products/awx-project/faq](https://www.ansible.com/products/awx-project/faq)上明确说明的那样：
- en: '*"Ansible Tower is produced by taking selected releases of AWX, hardening them
    for long-term supportability, and making them available to customers as Ansible
    Tower offerings."*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: “Ansible Tower是通过选择AWX的特定版本、加固以支持长期可维护性，并将其作为Ansible Tower产品提供给客户而生产的。”
- en: 'Basically, AWX is a community-supported project, while Red Hat directly supports
    Ansible Tower. Here''s a screenshot from **Ansible AWX** so that you can see what
    the GUI looks like:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，AWX是一个社区支持的项目，而Red Hat直接支持Ansible Tower。以下是来自Ansible AWX的屏幕截图，这样您就可以看到GUI的样子：
- en: '![Figure 11.4 – Ansible AWX GUI for Ansible'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.4 - Ansible AWX GUI for Ansible'
- en: '](img/B14834_11_04.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_04.jpg)'
- en: Figure 11.4 – Ansible AWX GUI for Ansible
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 - Ansible AWX GUI for Ansible
- en: There are other GUIs available for Ansible, such as **Rundeck**, **Semaphore**,
    and more. But somehow, AWX seems like the most logical choice for users who don't
    way to pay additional money for Ansible Tower. Let's spend a bit of time working
    on AWX before moving on to regular Ansible deployment and usage.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他可用于Ansible的GUI，例如Rundeck、Semaphore等。但不知何故，AWX似乎是那些不想为Ansible Tower支付额外费用的用户最合乎逻辑的选择。在继续进行常规的Ansible部署和使用之前，让我们花点时间来研究AWX。
- en: Deploying and using AWX
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署和使用AWX
- en: AWX was announced as an open source project that offers developers access to
    the Ansible Tower, without need for a license. As with almost all other Red Hat
    projects, this one also aims to bridge the gap between a paid product that is
    production hardened and ready for corporate use, and a community-driven project
    that has almost all the required functionality, but on a smaller scale and without
    all the bells and whistles available to corporate customers. But this does not
    mean that AWX is in any way a *small* project. It builds up the functionality
    of Ansible and enables a simple GUI that helps you run everything inside your
    Ansible deployments.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: AWX被宣布为一个开源项目，为开发人员提供对Ansible Tower的访问，无需许可证。与几乎所有其他红帽项目一样，这个项目也旨在弥合付费产品和社区驱动项目之间的差距，后者在较小的规模上具有几乎所有所需的功能，但没有为企业客户提供的所有功能。但这并不意味着AWX在任何方面都是一个*小*项目。它构建了Ansible的功能，并启用了一个简单的GUI，帮助您在Ansible部署中运行所有内容。
- en: We don't nearly have enough space here to demonstrate how it looks and what
    it can be used for, so we are just going to go through the basics of installing
    it and deploying the simplest scenario.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里没有足够的空间来演示它的外观和用途，所以我们只会介绍安装和部署最简单的场景。
- en: The single-most important address we need to know about when we are talking
    about AWX is [https://github.com/ansible/awx](https://github.com/ansible/awx).
    This is the place where the project resides. The most up-to-date information is
    here, in `readme.md`, a file that is shown on the GitHub page. If you are unfamiliar
    with *cloning* from GitHub, do not worry – we are basically just copying from
    a special source that will enable you to copy only the things that have changed
    since you last got your version of the files. This means that in order to update
    to a new version, you only need to clone once more using the same exact command.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到AWX时，我们需要知道的最重要的地址是[https://github.com/ansible/awx](https://github.com/ansible/awx)。这是项目所在的地方。最新的信息在这里，在`readme.md`中，在GitHub页面上显示。如果您不熟悉从GitHub克隆，不用担心-我们基本上只是从一个特殊的源复制，这将使您只能复制自上次获取文件版本以来发生变化的内容。这意味着为了更新到新版本，您只需要再次使用完全相同的命令克隆一次。
- en: On the GitHub page, there is a direct link to the install instructions we are
    going to follow. Remember, this deployment is from scratch, so we will need to
    build up our demo machine once again and install everything that is missing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub页面上，有一个直接链接到我们将要遵循的安装说明。请记住，这次部署是从头开始的，因此我们需要再次构建我们的演示机器，并安装所有缺少的东西。
- en: 'The first thing we need to do is get the necessary AWX files. Let''s clone
    the GitHub repository to our local disk:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是获取必要的AWX文件。让我们将GitHub存储库克隆到我们的本地磁盘上：
- en: '![Figure 11.5 – Git cloning the AWX files'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.5-Git克隆AWX文件'
- en: '](img/B14834_11_05.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_05.jpg)'
- en: Figure 11.5 – Git cloning the AWX files
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5-Git克隆AWX文件
- en: Note that we are using 13.0.0 as the version number as this is the current version
    of AWX at the time of writing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用13.0.0作为版本号，因为这是撰写时AWX的当前版本。
- en: Then, we need to sort out some dependencies. AWX obviously needs Ansible, Python,
    and Git, but other than that, we need to be able to support Docker, and we need
    GNU Make to be able to prepare some files later. We also need an environment to
    run our VMs. In this tutorial, we opted for Docker, so we will be using Docker
    Compose.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要解决一些依赖关系。显然，AWX需要Ansible、Python和Git，但除此之外，我们还需要支持Docker，并且我们需要GNU Make来准备一些文件。我们还需要一个环境来运行我们的虚拟机。在本教程中，我们选择了Docker，因此我们将使用Docker
    Compose。
- en: Also, this is a good place to mention that we need at least 4 GB of RAM and
    20 GB of space on our machine in order to run AWX. This differs to the low footprint
    that we are used to using with Ansible, but this makes sense since AWX is much
    more than just a bunch of scripts. Let's start by installing the prerequisites.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这也是一个好地方提到，我们的机器至少需要4GB的RAM和20GB的空间才能运行AWX。这与我们习惯使用的低占用空间有所不同，但这是有道理的，因为AWX不仅仅是一堆脚本。让我们从安装先决条件开始。
- en: 'Docker is the first one we will install. We are using CentOS 8 for this, so
    Docker is no longer part of the default set of packages. Therefore, we need to
    add the repository and then install the Docker engine. We are going to use the
    `-ce` package, which stands for Community Edition. We will also use the `--nobest`
    option to install Docker – without this option, CentOS will report that we are
    missing some dependencies:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是我们将安装的第一个软件。我们在这里使用CentOS 8，因此Docker不再是默认软件包的一部分。因此，我们需要添加存储库，然后安装Docker引擎。我们将使用`-ce`软件包，代表Community
    Edition。我们还将使用`--nobest`选项来安装Docker-如果没有此选项，CentOS将报告我们缺少一些依赖项：
- en: '![Figure 11.6 – Deploying docker-ce package on CentOS 8'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.6-在CentOS 8上部署docker-ce软件包'
- en: '](img/B14834_11_06.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_06.jpg)'
- en: Figure 11.6 – Deploying docker-ce package on CentOS 8
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6-在CentOS 8上部署docker-ce软件包
- en: 'After that, we need to run the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们需要运行以下命令：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The overall result should look something like this. Note that the versions
    of every package on your particular installations will probably be different.
    This is normal as packages change all the time:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 总体结果应该看起来像这样。请注意，您特定安装的每个软件包的版本可能会有所不同。这是正常的，因为软件包一直在变化：
- en: '![Figure 11.7 – Starting and enabling the Docker service'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.7-启动和启用Docker服务'
- en: '](img/B14834_11_07.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_07.jpg)'
- en: Figure 11.7 – Starting and enabling the Docker service
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7-启动和启用Docker服务
- en: 'Then, we will install Ansible itself using the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用以下命令安装Ansible本身：
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you are running on a completely clean CentOS 8 installation, you might have
    to install `epel-release` before Ansible is available.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行完全干净的CentOS 8安装，可能需要在可用Ansible之前安装`epel-release`。
- en: 'Next on our list is Python. Just using the `dnf` command is not going to get
    Python installed as we''re going to have to supply the Python version we want.
    For this, we would do something like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是Python。仅使用`dnf`命令不会安装Python，因为我们将不得不提供我们想要的Python版本。为此，我们会做这样的事情：
- en: '![Figure 11.8 – Installing Python; in this case, version 3.8'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.8-安装Python；在这种情况下，版本3.8'
- en: '](img/B14834_11_08.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_08.jpg)'
- en: Figure 11.8 – Installing Python; in this case, version 3.8
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8-安装Python；在这种情况下，版本3.8
- en: After that, we will use pip to install the Docker component for Python. Simply
    type `pip3 install docker` and everything you need will be installed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将使用pip安装Python的Docker组件。只需输入`pip3 install docker`，您需要的一切都将被安装。
- en: 'We also need to install the `make` package:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要安装`make`包：
- en: '![Figure 11.9 – Deploying GNU Make'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.9-部署GNU Make'
- en: '](img/B14834_11_09.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_09.jpg)'
- en: Figure 11.9 – Deploying GNU Make
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9-部署GNU Make
- en: 'Now, it''s time for the Docker Compose part. We need to run the `pip3 install
    docker-compose` command to install the Python part and the following command to
    install docker-compose:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进行Docker Compose部分了。我们需要运行`pip3 install docker-compose`命令来安装Python部分，以及以下命令来安装docker-compose：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command will get the necessary install file from GitHub and use the necessary
    input parameters (by executing `uname` commands) to start the installation process
    for docker-compose.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将从GitHub获取必要的安装文件，并使用必要的输入参数（通过执行`uname`命令）来启动docker-compose的安装过程。
- en: We know this is a lot of dependencies, but AWX is a pretty complex system under
    the hood. On the surface, however, things are not so complicated. Before we do
    the final install part, we need to verify that our firewall has stopped and that
    it is disabled. We are creating a demo environment, and `firewalld` will block
    communication between containers. We can fix that later, once we have the system
    running.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道这是很多依赖关系，但是AWX在内部是一个非常复杂的系统。然而，在表面上，事情并不那么复杂。在我们进行最后的安装之前，我们需要验证我们的防火墙是否已停止并且已禁用。我们正在创建一个演示环境，`firewalld`将阻止容器之间的通信。一旦系统运行起来，我们可以稍后解决这个问题。
- en: 'Once we have everything running, installing AWX is simple. Just go to the `awx/installer`
    directory and run the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一切都运行起来，安装AWX就很简单。只需转到`awx/installer`目录并运行以下命令：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The installation should take a couple of minutes. The result should be a long
    listing that ends with the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 安装应该需要几分钟。结果应该是一个以以下内容结尾的长列表：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This means that the local AWX environment has been deployed successfully.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着本地AWX环境已成功部署。
- en: Now, the fun part starts. AWX is comprised of four small Docker images. For
    it to work, all of them need to be configured and running. You can check them
    out by using `docker ps` and `docker logs -t awx_task`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有趣的部分开始了。AWX由四个小的Docker图像组成。为了使其工作，所有这些图像都需要配置和运行。您可以使用`docker ps`和`docker
    logs -t awx_task`来查看它们。
- en: 'The first command lists all the images that got deployed, as well as their
    status:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令列出了部署的所有图像，以及它们的状态：
- en: '![Figure 11.10 – Checking the pulled and started docker images'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.10-检查拉取和启动的docker图像'
- en: '](img/B14834_11_10.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_10.jpg)'
- en: Figure 11.10 – Checking the pulled and started docker images
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10-检查拉取和启动的docker图像
- en: 'The second command shows us all the logs that the `awx_task` machine is creating.
    These are the main logs for the whole system. After a while, the initial configuration
    will complete:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令向我们显示了`awx_task`机器正在创建的所有日志。这些是整个系统的主要日志。一段时间后，初始配置将完成：
- en: '![Figure 11.11 – Checking the awx_task logs'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.11-检查awx_task日志'
- en: '](img/B14834_11_11.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_11.jpg)'
- en: Figure 11.11 – Checking the awx_task logs
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11-检查awx_task日志
- en: There will be a lot of logging going on, and you will have to interrupt this
    command by using *Ctrl + C*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将有大量的日志记录，您将不得不使用*Ctrl + C*来中断此命令。
- en: 'After this whole process, we can point our web browser to `http://localhost`.
    We should be greeted by a screen that looks like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程之后，我们可以将我们的Web浏览器指向`http://localhost`。我们应该会看到一个看起来像这样的屏幕：
- en: '![Figure 11.12 – AWX default login screen'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.12-AWX默认登录屏幕'
- en: '](img/B14834_11_12.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_12.jpg)'
- en: Figure 11.12 – AWX default login screen
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12-AWX默认登录屏幕
- en: 'The default username is `admin`, while the password is `password`. After logging
    in successfully, we should be faced with the following UI:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 默认用户名是`admin`，密码是`password`。成功登录后，我们应该会看到以下UI：
- en: '![Figure 11.13 – Initial AWX dashboard after logging in'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.13-登录后的初始AWX仪表板'
- en: '](img/B14834_11_13.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_13.jpg)'
- en: Figure 11.13 – Initial AWX dashboard after logging in
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13-登录后的初始AWX仪表板
- en: 'There is a lot to learn here, so we are just going to go through the basics.
    Basically, what AWX represents is a smart GUI for Ansible. We can see this quickly
    if we open **Templates** (on the left-hand side of the window) and take a look
    at the **Demo** template:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多东西需要学习，所以我们只会简单介绍一下基础知识。基本上，AWX代表的是Ansible的智能GUI。如果我们快速打开**模板**（在窗口的左侧）并查看**演示**模板，我们就可以看到这一点：
- en: '![Figure 11.14 – Using a demo template in AWX'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.14-在AWX中使用演示模板'
- en: '](img/B14834_11_14.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_14.jpg)'
- en: Figure 11.14 – Using a demo template in AWX
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14-在AWX中使用演示模板
- en: 'What we can see here will become much more familiar to us in the next part
    of this chapter, when we deploy Ansible. All these attributes are different parts
    of an Ansible playbook, including the playbook itself, the inventory, the credentials
    used, and a couple of other things that make using Ansible easier. If we scroll
    down a bit, there should be three buttons there. Press the `job`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的下一部分更加熟悉这里看到的内容，当我们部署Ansible时。所有这些属性都是Ansible playbook的不同部分，包括playbook本身、清单、使用的凭据以及使使用Ansible变得更容易的其他一些东西。如果我们向下滚动一点，那里应该有三个按钮。按`job`：
- en: '![Figure 11.15 – By clicking on the Launch button, we can start our template
    job'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.15-通过单击启动按钮，我们可以启动我们的模板作业'
- en: '](img/B14834_11_15.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_15.jpg)'
- en: Figure 11.15 – By clicking on the Launch button, we can start our template job
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15 – 通过单击启动按钮，我们可以启动我们的模板作业
- en: 'The idea is that we can create templates and run them at will. Once you''ve
    run them, the results of the runs will end up under **Jobs** (find it as the second
    item on the left-hand side of the window):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是我们可以创建模板并随时运行它们。运行它们后，运行的结果将出现在**作业**下（在窗口左侧的第二个项目中找到）：
- en: '![Figure 11.16 – Template job details'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.16 – 模板作业详情'
- en: '](img/B14834_11_16.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_16.jpg)'
- en: Figure 11.16 – Template job details
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16 – 模板作业详情
- en: 'The details of the job are basically a summary of what happened, when, and
    which Ansible elements were used. We can also see the actual result of the playbook
    we just ran:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 作业的详细信息基本上是发生了什么，何时发生，以及使用了哪些Ansible元素的总结。我们还可以看到我们刚刚运行的playbook的实际结果：
- en: '![Figure 11.17 – Checking the demo job template''s text output'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.17 – 检查演示作业模板的文本输出'
- en: '](img/B14834_11_17.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_17.jpg)'
- en: Figure 11.17 – Checking the demo job template's text output
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17 – 检查演示作业模板的文本输出
- en: What AWX really does is automate the automation. It enables you to be much more
    efficient while using Ansible simply because it offers a much more intuitive interface
    to the different files Ansible uses. It also gives you the ability to track what
    has been done and when, as well as what the results were. All of this is possible
    using the Ansible CLI, but AWX saves us a lot of effort while we're keeping control
    of the whole process.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: AWX的真正作用是自动化自动化。它使您能够在使用Ansible时更加高效，因为它为Ansible使用的不同文件提供了一个更直观的界面。它还使您能够跟踪已完成的工作及其时间，以及结果是什么。所有这些都可以使用Ansible
    CLI实现，但AWX在我们控制整个过程的同时节省了大量精力。
- en: Of course, because the goal of this chapter is to use Ansible, this means that
    we need to deploy all of the necessary software packages so that we can use it.
    Therefore, let's move on to the next phase in our Ansible process and deploy Ansible.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，因为本章的目标是使用Ansible，这意味着我们需要部署所有必要的软件包，以便我们可以使用它。因此，让我们继续进行我们的Ansible过程的下一个阶段，并部署Ansible。
- en: Deploying Ansible
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署Ansible
- en: Out of all the similar applications designed for orchestration and systems management,
    Ansible is probably the simplest one to install. Since it requires no agents on
    the systems it manages, installation is limited to only one machine – the one
    that will run all the scripts and playbooks. By default, Ansible uses SSH to connect
    to machines, so the only prerequisite for its use is that our remote systems have
    an SSH server up and running.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有设计用于编排和系统管理的类似应用程序中，Ansible可能是最简单的安装。由于它在管理的系统上不需要代理，因此安装仅限于一台机器 - 将运行所有脚本和playbook的机器。默认情况下，Ansible使用SSH连接到机器，因此其使用的唯一先决条件是我们的远程系统上有一个正在运行的SSH服务器。
- en: Other than that, there are no databases (Ansible uses text files), no daemons
    (Ansible runs on demand), and no management of Ansible itself to speak of. Since
    nothing is running in the background, Ansible is easily upgraded – the only thing
    that can change is the way playbooks are structured, and that can easily be fixed.
    Ansible is based on the Python programming language, but its structure is simpler
    than that of a standard Python program. Configuration files and playbooks are
    either simple text files or YAML formatted text files, with YAML being a file
    format used to define data structures. Learning YAML is outside the scope of this
    chapter, so we will just presume that you understand simple data structures. The
    YAML files we'll be using as examples are simple enough to warrant almost no explanation,
    but if one is needed, it will be provided.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，没有数据库（Ansible使用文本文件），没有守护程序（Ansible按需运行），也没有管理Ansible本身的必要。由于没有后台运行任何东西，因此可以轻松升级Ansible
    - 唯一可能改变的是playbook的结构方式，而这可以很容易地修复。Ansible基于Python编程语言，但其结构比标准Python程序更简单。配置文件和playbook要么是简单的文本文件，要么是YAML格式的文本文件，YAML是用于定义数据结构的文件格式。学习YAML超出了本章的范围，因此我们只是假设您了解简单的数据结构。我们将使用的YAML文件示例足够简单，几乎不需要解释，但如果需要，我们会提供解释。
- en: 'The installation can be as simple as running the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 安装可以简单地运行以下命令：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can run this command as the root user or use the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以root用户身份运行此命令，也可以使用以下命令：
- en: '[PRE6]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The choice depends on your distribution (Red Hat/CentOS or Ubuntu/Debian). More
    information can be found on the Ansible website at [https://docs.ansible.com/](https://docs.ansible.com/).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 选择取决于您的发行版（Red Hat/CentOS或Ubuntu/Debian）。更多信息可以在Ansible网站上找到[https://docs.ansible.com/](https://docs.ansible.com/)。
- en: 'RHEL8 users will have to enable the repo containing Ansible RPMs first. At
    the time of writing, this can be accomplished by running the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: RHEL8用户首先需要启用包含Ansible RPM的存储库。在撰写本文时，可以通过运行以下命令来实现：
- en: '[PRE7]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After running the preceding command, use the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令后，使用以下代码：
- en: '[PRE8]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is all it takes to install Ansible.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是安装Ansible所需的全部内容。
- en: 'One thing that can surprise you is the size of the installation: it really
    is that small (around 20 MB) and will install Python dependencies as needed.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件事可能会让您感到惊讶，那就是安装的大小：它确实如此小（约20 MB），并且会根据需要安装Python依赖项。
- en: The machine that Ansible is installed in is also called the *control node*.
    It must be installed on a Linux host as Windows is not supported in this role.
    Ansible control nodes can be run inside virtual machines.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了Ansible的机器也被称为*控制节点*。它必须安装在Linux主机上，因为Windows不支持这个角色。Ansible控制节点可以在虚拟机内运行。
- en: Machines that we control are called managed nodes, and by default, they are
    Linux boxes controlled through the `SSH` protocol. There are modules and plugins
    that enable extending this to Windows and macOS operating systems, as well as
    other communication channels. When you start reading the Ansible documentation,
    you will notice that most of the modules that support more than one architecture
    have clear instructions regarding how to accomplish the same tasks on different
    operating systems.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们控制的机器称为受控节点，默认情况下，它们是通过`SSH`协议控制的Linux系统。有一些模块和插件可以扩展到Windows和macOS操作系统，以及其他通信渠道。当你开始阅读Ansible文档时，你会注意到大多数支持多个架构的模块都有清晰的说明，关于如何在不同的操作系统上完成相同的任务。
- en: We can configure Ansible's settings using `/etc/ansible/ansible`. This file
    contains parameters that define the defaults, and by itself contains a lot of
    lines that are commented out but contain default values for all the things Ansible
    uses to work. Unless we change something, these are the values that Ansible is
    going to use to run. Let's use Ansible in a practical sense to see how all of
    this fits together. In our scenario, we are going to use Ansible to provision
    a virtual machine by using its built-in module.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`/etc/ansible/ansible`来配置Ansible的设置。这个文件包含了定义默认值的参数，并且本身包含了很多被注释掉的行，但包含了Ansible用于工作的所有默认值。除非我们改变了什么，否则这些值就是Ansible要使用的值。让我们实际使用Ansible来看看所有这些是如何配合在一起的。在我们的场景中，我们将使用Ansible来通过其内置模块配置虚拟机。
- en: Provisioning a virtual machine using the kvm_libvirt module
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用kvm_libvirt模块配置虚拟机
- en: One thing that you may or may not include is a setting that defines how SSH
    is used to connect to machines Ansible is going to configure. Before we do that,
    we need to spend a bit of time talking about security and Ansible. Like almost
    all things related to Linux (or `*nix` in general), Ansible is not an integrated
    system, instead relying on different services that already exist. To connect to
    systems it manages and to execute commands, Ansible relies on `SSH` (in Linux)
    or other systems such as **WinRM** or **PowerShell** on Windows. We are going
    to focus on Linux here, but remember that quite a bit of information about Ansible
    is completely system-independent.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个你可能会或可能不会包括的设置是定义SSH如何用于连接Ansible将要配置的机器。在我们这样做之前，我们需要花一点时间来谈谈安全和Ansible。与几乎所有与Linux（或`*nix`一般）相关的事物一样，Ansible不是一个集成的系统，而是依赖于已经存在的不同服务。为了连接到它管理的系统并执行命令，Ansible依赖于`SSH`（在Linux中）或其他系统，如Windows上的**WinRM**或**PowerShell**。我们将在这里专注于Linux，但请记住，关于Ansible的相当多的信息是完全与系统无关的。
- en: '`SSH` is a simple but extremely robust protocol that allows us to transfer
    data (Secure FTP, SFTP, and so on) and execute commands (`SSH`) on remote hosts
    through a secure channel. Ansible uses SSH directly by connecting and then executing
    commands and transferring files. This, of course, means that in order for Ansible
    to work, it is crucial that SSH works.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`SSH`是一个简单但非常强大的协议，它允许我们通过安全通道传输数据（安全FTP，SFTP等）并在远程主机上执行命令（`SSH`）。Ansible直接使用SSH连接，然后执行命令和传输文件。当然，这意味着为了使Ansible工作，SSH至关重要。'
- en: 'There are a couple of things that you need to remember when using `SSH` to
    connect:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SSH`连接时需要记住的几件事：
- en: The first is a key fingerprint, as seen from the Ansible control node (server).
    When establishing a connection for the first time, `SSH` requires the user to
    verify and accept keys that the remote system presents. This is designed to prevent
    MITM attacks and is a good tactic in everyday use. But if we are in the position
    of having to configure freshly installed systems, *all* of them will require for
    us to accept their keys. This is time-consuming and complicated to do once we
    start using playbooks, so the first playbook you will start is probably going
    to disable key checks and logging into machines. Of course, this should only be
    used in a controlled environment since this lowers the security of the whole Ansible
    system.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是密钥指纹，从Ansible控制节点（服务器）看到的。在首次建立连接时，`SSH`要求用户验证和接受远程系统呈现的密钥。这旨在防止中间人攻击，并且在日常使用中是一个很好的策略。但如果我们处于必须配置新安装系统的位置，*所有*它们都将要求我们接受它们的密钥。这是耗时且复杂的，一旦我们开始使用playbooks，就很难做到，所以你可能会开始的第一个playbook是禁用密钥检查和登录到机器。当然，这只应该在受控环境中使用，因为这会降低整个Ansible系统的安全性。
- en: The second thing you need to know is that Ansible runs as a normal user. Having
    said that, maybe we do not want to connect to the remote systems as the current
    user. Ansible solves that by having a variable that can be set on individual computers
    or groups that indicates what username the system is going to use to connect to
    this particular computer. After connecting, Ansible allows us to execute commands
    on the remote system as a different user entirely. This is something that is commonly
    used since it enables us to reconfigure the machine completely and change users
    as if we were at the console.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二件你需要知道的事情是Ansible作为一个普通用户运行。话虽如此，也许我们不想以当前用户连接到远程系统。Ansible通过在单独的计算机或组上设置一个变量来解决这个问题，该变量指示系统将用于连接到这台特定计算机的用户名。连接后，Ansible允许我们以完全不同的用户身份在远程系统上执行命令。这是一个常用的功能，因为它使我们能够完全重新配置机器并像在控制台上一样更改用户。
- en: The third thing that we need to remember are the keys – `SSH` can log in by
    using interactive authentication, meaning via password or by using pre-shared
    keys that are exchanged once and then reused to establish the SSH session. There
    is also `ssh-agent`, which can be used to authenticate sessions.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三件我们需要记住的事情是密钥 - `SSH`可以通过交互式身份验证登录，意思是通过密码或使用一次交换的预共享密钥来建立SSH会话。还有`ssh-agent`，它可以用于身份验证会话。
- en: Although we can use fixed passwords inside inventory files (or special key vaults),
    this is a bad idea. Luckily, Ansible enables us to script a lot of things, including
    copying keys to remote systems. This means that we are going to have some playbooks
    that are going to automate deployment of new systems, and these will enable us
    to take control of them for further configuration.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在清单文件（或特殊的密钥库）中使用固定密码，但这是一个坏主意。幸运的是，Ansible使我们能够脚本化许多事情，包括将密钥复制到远程系统。这意味着我们将有一些playbooks来自动部署新系统，并且这些将使我们能够控制它们进行进一步的配置。
- en: 'To sum this up, the Ansible steps for deploying a system will probably start
    like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，部署系统的Ansible步骤可能会像这样开始：
- en: Install the core system and make sure that `SSHD` is running.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装核心系统，并确保`SSHD`正在运行。
- en: Define a user that has admin rights on the system.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个在系统上具有管理员权限的用户。
- en: From the control node, run a playlist that will establish the initial connection
    and copy the local `SSH` key to a remote location.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从控制节点运行一个播放列表，将建立初始连接并将本地的`SSH`密钥复制到远程位置。
- en: Use the appropriate playbooks to reconfigure the system securely, and without
    the need to store passwords locally.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的playbooks来安全地重新配置系统，而无需在本地存储密码。
- en: Now, let's dig deeper.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解一下。
- en: Every reasonable manager will tell you that in order to do anything, you need
    to define the scope of the problem. In automation, this means defining systems
    that Ansible is going to work on. This is done through an inventory file, located
    in `/etc/Ansible`, called `hosts`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每个合理的管理者都会告诉你，为了做任何事情，你需要定义问题的范围。在自动化中，这意味着定义Ansible将要处理的系统。这是通过位于`/etc/Ansible`的清单文件`hosts`完成的。
- en: '`Hosts` can be grouped or individually named. In text format, that can look
    like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hosts`可以被分组或单独命名。在文本格式中，可以这样写：'
- en: '[PRE9]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Computers can be part of multiple groups simultaneously, and groups can be nested.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机可以同时属于多个组，组也可以是嵌套的。
- en: 'The format we used here is straight text. Let''s rewrite this in YAML:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的格式是纯文本。让我们用YAML来重写这个：
- en: '[PRE10]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Important Note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We created another group called Production that contains all the workstations
    and one server.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了另一个名为Production的组，其中包含所有工作站和一个服务器。
- en: Anything that is not part of the default or standard configuration can be included
    individually in the host definition or in the group definition as variables. Every
    Ansible command has some way of giving you flexibility in terms of partially or
    completely overriding all the items in the configuration or inventory.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不属于默认或标准配置的内容都可以作为变量单独包含在主机定义或组定义中。每个Ansible命令都有一些方式可以在配置或清单中部分或完全覆盖所有项目的灵活性。
- en: 'The inventory supports ranges in host definitions. Our previous example can
    be written as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 清单支持主机定义中的范围。我们之前的示例可以写成如下形式：
- en: '[PRE11]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This also works for characters, so if we need to define servers named `srva`,
    `srvb`, `srvc`, and `srvd`, we can do that by stating the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于字符，所以如果我们需要定义名为`srva`、`srvb`、`srvc`和`srvd`的服务器，我们可以通过以下方式来说明：
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'IP ranges can also be used. So, for instance, `10.0.0.0/24` would be written
    down as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用IP范围。因此，例如，`10.0.0.0/24`将被写成如下形式：
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There are two predefined default groups that can also be used: `all` and `ungrouped`.
    As their names suggest, if we reference `all` in a playbook, it will be run on
    every server we have in our inventory. `Ungrouped` will reference only those systems
    that are not part of any group.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个预定义的默认组也可以使用：`all`和`ungrouped`。顾名思义，如果我们在playbook中引用`all`，它将在清单中的每台服务器上运行。`Ungrouped`将仅引用那些不属于任何组的系统。
- en: Ungrouped references are especially useful when setting up new computers – if
    they are not in any group, we can consider them *new* and set them up to be joined
    to a specific group.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 未分组的引用在设置新计算机时特别有用-如果它们不属于任何组，我们可以将它们视为*新*，并设置它们加入特定的组。
- en: These groups are defined implicitly and there is no need to reconfigure them
    or even mention them in the inventory file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组是隐式定义的，无需重新配置它们，甚至在清单文件中提及它们。
- en: 'We mentioned that the inventory file can contain variables. Variables are useful
    when we need to have a property that is defined inside a group of computers, a
    user, password, or a setting specific to that group. Let''s say that we want to
    define a user that is going to be using on the `servers` group:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到清单文件可以包含变量。当我们需要在计算机组、用户、密码或特定于该组的设置中定义一个属性时，变量是有用的。假设我们想要定义一个将在`servers`组上使用的用户：
- en: 'First, we define a group:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个组：
- en: '[PRE14]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we define the variables that are going to be used for the whole group:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义将用于整个组的变量：
- en: '[PRE15]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will use the user named `Ansibleuser` to connect using `SSH` when asked
    to perform a playbook.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当要求执行playbook时，这将使用名为`Ansibleuser`的用户使用`SSH`进行连接。
- en: Important Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that the password is not present and that this playbook will fail if either
    the password is not separately mentioned or the keys are not exchanged beforehand.
    For more on variables and their use, consult Ansible documentation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，密码不在此处出现，如果密码没有单独提及或密钥在此之前没有交换，此playbook将失败。有关变量及其使用的更多信息，请参阅Ansible文档。
- en: Now that we've created our first practical Ansible task, it's time to talk about
    how to make Ansible do many things at once while using a more *objective* approach.
    It's important to be able to create a single task or a couple of tasks that we
    can combine through a concept called a *playbook*, which can include multiple
    tasks/plays.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的第一个实用的Ansible任务，是时候谈谈如何让Ansible一次执行多个任务了，同时使用更*客观*的方法。能够创建单个任务或一对任务，并通过一个称为*playbook*的概念将它们组合起来是非常重要的。
- en: Working with playbooks
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用playbooks
- en: Once we've decided how to connect to the machines we plan to administer, and
    once we have created the inventory, we can start actually using Ansible to do
    something useful. This is where playbooks start to make sense.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们决定如何连接到我们打算管理的机器，并且一旦我们创建了清单，我们就可以开始实际使用Ansible来做一些有用的事情。这就是playbooks开始变得有意义的地方。
- en: In our examples, we've configured four CentOS7 systems, gave them consecutive
    addresses in the range of `10.0.0.1` to `10.0.0.4`, and used them for everything.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们配置了四台CentOS7系统，为它们分配了连续的地址范围内的地址`10.0.0.1`到`10.0.0.4`，并将它们用于一切。
- en: Ansible is installed on the system with the IP address `10.0.0.1`, but as we
    already said, this is completely arbitrary. Ansible has a minimal footprint on
    the system that is used as a control node and can be installed on any system as
    long as it has connectivity to the rest of the network we are going to manage.
    We simply chose the first computer in our small network. One more thing to note
    is that the control node can be controlled by itself through Ansible. This is
    useful, but at the same time not a good thing to do. Depending on your setup,
    you will want to test not only playbooks, but individual commands before they
    are deployed to other machines – doing that on your control server is not a wise
    thing to do.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible已安装在IP地址为`10.0.0.1`的系统上，但正如我们已经说过的，这完全是任意的。Ansible在用作控制节点的系统上占用空间很小，并且只要它与我们打算管理的网络的其余部分有连接，就可以安装在任何系统上。我们只是选择了我们小型网络中的第一台计算机。还要注意的一件事是，控制节点可以通过Ansible自身进行控制。这很有用，但同时也不是一个明智的做法。根据您的设置，您不仅要测试playbooks，还要测试部署到其他机器之前的单个命令-在控制服务器上进行这样的操作是不明智的。
- en: Now that Ansible is installed, we can try and do something with it. There are
    two distinct ways that Ansible can be run. One is by running a playbook, a file
    that contains tasks that are to be performed. The other way is by using a single
    task, sometimes called **ad hoc** execution. There are reasons to use Ansible
    either way – playbooks are our main tool, and you will probably use them most
    of the time. But ad hoc execution also has its advantages, especially if we are
    interested in doing something that we need done once, but across multiple servers.
    A typical example is using a simple command to check the version of an installed
    application or application state. If we need it to check something, we are not
    going to write a playbook.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Ansible已安装，我们可以尝试使用它做一些事情。Ansible有两种不同的运行方式。一种是运行playbook，其中包含要执行的任务。另一种方式是使用单个任务，有时称为**临时**执行。无论哪种方式都有使用Ansible的原因-
    playbooks是我们的主要工具，你可能会大部分时间使用它们。但临时执行也有其优势，特别是如果我们有兴趣做一些我们需要一次完成的事情，但是要跨多台服务器进行。一个典型的例子是使用一个简单的命令来检查已安装应用程序的版本或应用程序状态。如果我们需要检查某些东西，我们不会编写一个playbook。
- en: To see if everything works, we are going to start by simply using ping to check
    if the machines are online.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看一切是否正常工作，我们将从简单地使用ping开始，以检查机器是否在线。
- en: Ansible likes to call itself *radically simple automation*, and the first thing
    we are going to do proves that.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible喜欢称自己为*根本简单的自动化*，我们要做的第一件事就证明了这一点。
- en: 'We are going to use a module named ping that tries to connect to a host, verifies
    that it can run on local Python environment, and returns a message if everything
    is ok. Do not confuse this module with the `ping` command in Linux; we are not
    pinging through a network; we are only *pinging* from the control node to the
    server we are trying to control. We will use a simple `ansible` command to ping
    all the defined hosts by issuing the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为ping的模块，该模块尝试连接到主机，验证它是否可以在本地Python环境中运行，并在一切正常时返回一条消息。不要将此模块与Linux中的`ping`命令混淆；我们不是通过网络进行ping操作；我们只是从控制节点向我们试图控制的服务器进行*ping*。我们将使用一个简单的`ansible`命令来ping所有已定义的主机，发出以下命令：
- en: '[PRE16]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the result of running the preceding command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令的结果如下：
- en: '![Figure 11.18 – Our first Ansible module – ping, checks for Python and reports
    its state'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.18-我们的第一个Ansible模块-ping，检查Python并报告其状态'
- en: '](img/B14834_11_18.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_18.jpg)'
- en: Figure 11.18 – Our first Ansible module – ping, checks for Python and reports
    its state
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18-我们的第一个Ansible模块-ping，检查Python并报告其状态
- en: What we did here is run a single command called `ansible all -m ping`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是运行一个名为`ansible all -m ping`的单个命令。
- en: '`ansible` is the simplest command available and runs a single task. The `all`
    parameter means run it on all the hosts in the inventory, and `-m` is used to
    call a module that will be run.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible`是可用的最简单的命令，运行单个任务。`all`参数表示在清单中的所有主机上运行它，`-m`用于调用将要运行的模块。'
- en: This particular module has no parameters or options, so we just need to run
    it in order to get a result. The result itself is interesting; it is in YAML format
    and contains a few things other than just the result of the command.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的模块没有参数或选项，所以我们只需要运行它以获得结果。结果本身很有趣；它是以YAML格式呈现的，并包含除命令结果之外的一些内容。
- en: If we take a closer look at this, we will see that Ansible returned one result
    for each host in the inventory. The first thing we can see is the final result
    of the command – `SUCCESS` means that the task itself ran without a problem. After
    that, we can see data in form of an array – `ansible_facts` contains information
    that the module returns, and it is used extensively when writing playbooks. Data
    that is returned this way can vary. In the next section, we will show a much bigger
    dataset, but in this particular case, the only thing that is shown is the location
    of the Python interpreter. After that, we have the `changed` variable, which is
    an interesting one.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细看一下，我们会发现Ansible为清单中的每个主机返回了一个结果。我们可以看到的第一件事是命令的最终结果-`SUCCESS`表示任务本身顺利运行。之后，我们可以看到一个数组形式的数据-`ansible_facts`包含模块返回的信息，在编写playbooks时被广泛使用。以这种方式返回的数据可能会有所不同。在下一节中，我们将展示一个更大的数据集，但在这种特殊情况下，显示的唯一内容是Python解释器的位置。之后，我们有`changed`变量，这是一个有趣的变量。
- en: When Ansible runs, it tries to detect whether it ran correctly and whether it
    has changed the system state. In this particular task, the command that ran is
    just informative and does not change anything on the system, so the system state
    was unchanged.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当Ansible运行时，它会尝试检测它是否正确运行以及是否已更改系统状态。在这个特定的任务中，运行的命令只是提供信息，并不会更改系统上的任何内容，因此系统状态没有改变。
- en: In other words, this means that whatever was run did not install or change anything
    on the system. States will make more sense later when we need to check if something
    was installed or not, such as a service.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这意味着运行的任何命令都没有安装或更改系统上的任何内容。在以后需要检查某些东西是否已安装或未安装（例如服务）时，状态将更有意义。
- en: The last variable we can see is the return of the `ping` command. It simply
    states **pong** since this is the correct answer that the module gives if everything
    was set up correctly.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到的最后一个变量是`ping`命令的返回。它简单地声明**pong**，因为这是模块在一切设置正确时给出的正确答案。
- en: 'Let''s do something similar, but this time with an argument, such as an ad
    hoc command that we want to be executed on remote hosts. So, type in the following
    command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做类似的事情，但这次带有一个参数，比如我们希望在远程主机上执行的临时命令。因此，请输入以下命令：
- en: '[PRE17]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following is the output:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Figure 11.19 – Using Ansible to explicitly execute a specific command on
    Ansible targets'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.19 - 使用Ansible在Ansible目标上显式执行特定命令'
- en: '](img/B14834_11_19.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_19.jpg)'
- en: Figure 11.19 – Using Ansible to explicitly execute a specific command on Ansible
    targets
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19 - 使用Ansible在Ansible目标上显式执行特定命令
- en: Here, we called another module called `shell`. It simply runs whatever is given
    as a parameter as a shell command. What is returned is the local hostname. This
    is functionally the same as what would happen if we connected to each host in
    our inventory using `SSH`, executed the command, and then logged out.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用了另一个名为`shell`的模块。它只是将给定的参数作为shell命令运行。返回的是本地主机名。这在功能上与我们使用`SSH`连接到清单中的每个主机，执行命令，然后注销的操作是一样的。
- en: For a simple demonstration of what Ansible can do, this is OK, but let's do
    something more complex. We are going to use a module called `yum` that is specific
    to CentOS/Red Hat to check if there is a web server installed on our hosts. The
    web server we are going to check for is going to be `lighttpd` since we want something
    lightweight.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Ansible可以做的简单演示来说，这是可以的，但让我们做一些更复杂的事情。我们将使用一个特定于CentOS/Red Hat的名为`yum`的模块来检查我们的主机上是否安装了Web服务器。我们要检查的Web服务器将是`lighttpd`，因为我们想要轻量级的东西。
- en: 'When we talked about states, we touched on a concept that is both a little
    confusing at first and extremely useful once we start using it. When calling a
    command like this, we are declaring a desired state, so the system itself will
    change if the state is not the one we are demanding. This means that, in this
    example, we are not actually testing if `lighttpd` is installed – we are telling
    Ansible to check it and that if it''s not installed to install it. Even this is
    not completely true – the module takes two arguments: the name of the service
    and the state it should be in. If the state on the system we are checking is the
    same as the state we sent when invoking the module, we are going to get `changed:
    false` since nothing changed. But if the state of the system is not the same,
    Ansible will make the current state of the system the same as the state we requested.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们谈到状态时，我们触及了一个起初有点令人困惑，但一旦开始使用就非常有用的概念。当调用这样的命令时，我们正在声明一个期望的状态，因此如果状态不是我们要求的状态，系统本身将发生变化。这意味着，在这个例子中，我们实际上并不是在测试`lighttpd`是否已安装
    - 我们是在告诉Ansible去检查它，如果它没有安装就安装它。即使这也不完全正确 - 该模块接受两个参数：服务的名称和它应该处于的状态。如果我们检查的系统状态与调用模块时发送的状态相同，我们将得到`changed:
    false`，因为没有发生任何变化。但是，如果系统的状态不同，Ansible将使系统的当前状态与我们请求的状态相同。'
- en: 'To prove this, we are going to see if the service is *not* installed or *absent*
    in Ansible terms. Remember that if the service was installed, this will uninstall
    it. Type in the following command:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，我们将看看服务在Ansible术语中是*未*安装或*不存在*的。请键入以下命令：
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is what you should get as the result of running the preceding command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行前述命令后应该得到的结果：
- en: '![Figure 11.20 – Using Ansible to check the state of a service'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.20 - 使用Ansible检查服务状态'
- en: '](img/B14834_11_20.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_20.jpg)'
- en: Figure 11.20 – Using Ansible to check the state of a service
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20 - 使用Ansible检查服务状态
- en: 'Then, we can say that we want it present on the system. Ansible is going to
    install the services as needed:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以说我们希望它出现在系统上。Ansible将根据需要安装服务：
- en: '![Figure 11.21 – Using the yum install command on all Ansible targets'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.21 - 在所有Ansible目标上使用yum install命令'
- en: '](img/B14834_11_21.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_21.jpg)'
- en: Figure 11.21 – Using the yum install command on all Ansible targets
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21 - 在所有Ansible目标上使用yum install命令
- en: Here, we can see that Ansible simply checked and installed the service since
    it wasn't there. It also provided us with other useful information, such as what
    changes were done on the system and the output of the command it performed. Information
    was provided as an array of variables; this usually means that we will have to
    do some string manipulation in order to make it look nicer.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到Ansible只是检查并安装了服务，因为它之前不存在。它还为我们提供了其他有用的信息，比如系统上做了什么更改以及它执行的命令的输出。信息以变量数组的形式提供；这通常意味着我们需要进行一些字符串操作，以使其看起来更好。
- en: 'Now, let''s run the command again:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次运行该命令：
- en: '[PRE19]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This should be the result:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是结果：
- en: '![Figure 11.22 – Using Ansible to check the service state after service installation'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.22 - 在服务安装后使用Ansible检查服务状态'
- en: '](img/B14834_11_22.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_22.jpg)'
- en: Figure 11.22 – Using Ansible to check the service state after service installation
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.22 - 在服务安装后使用Ansible检查服务状态
- en: As we can see, there were no changes here since the service is installed.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这里没有任何变化，因为服务已安装。
- en: These were all just starting examples so that we could get to know Ansible a
    little bit. Now, let's expand on this and create an Ansible playbook that's going
    to install KVM on our predefined set of hosts.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是一些起步示例，以便我们能够稍微了解一下Ansible。现在，让我们扩展一下，并创建一个Ansible playbook，它将在我们预定义的一组主机上安装KVM。
- en: Installing KVM
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装KVM
- en: Now, let's create our first playbook and use it to install KVM on all of our
    hosts. For our playbook, we used an excellent example from the GitHub repository,
    created by Jared Bloomer, that we changed a bit since we already have our options
    and inventory configured. The original files are available at [https://github.com/jbloomer/Ansible---Install-KVM-on-CentOS-7.git](https://github.com/jbloomer/Ansible---Install-KVM-on-CentOS-7.git).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的第一个playbook，并使用它在所有主机上安装KVM。对于我们的playbook，我们使用了GitHub存储库中的一个很好的例子，由Jared
    Bloomer创建，我们稍微修改了一下，因为我们已经配置了我们的选项和清单。原始文件可在[https://github.com/jbloomer/Ansible---Install-KVM-on-CentOS-7.git](https://github.com/jbloomer/Ansible---Install-KVM-on-CentOS-7.git)找到。
- en: 'This playbook will show everything that we need to know about automating simple
    tasks. We chose this particular example because it shows not only how automation
    works, but also how to create separate tasks and reuse them in different playbooks.
    Using a public repository has an added benefit that you will always get the latest
    version, but it may differ significantly than the one presented here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个playbook将展示我们需要了解的关于自动化简单任务的一切。我们选择了这个特定的例子，因为它不仅展示了自动化的工作原理，还展示了如何创建单独的任务并在不同的playbook中重用它们。使用公共存储库的一个额外好处是你将始终获得最新版本，但它可能与这里呈现的版本有很大不同：
- en: First, we created our main playbook – the one that will get called – and named
    it `installkvm.yaml`:![Figure 11.23 – The main Ansible playbook, which checks
    for virtualization support and installs KVM
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建了我们的主要playbook – 将被调用的那个 – 并命名为`installkvm.yaml`：![图11.23–检查虚拟化支持并安装KVM的主要Ansible
    playbook
- en: '](img/B14834_11_23.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_23.jpg)'
- en: Figure 11.23 – The main Ansible playbook, which checks for virtualization support
    and installs KVM
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.23–检查虚拟化支持并安装KVM的主要Ansible playbook
- en: 'As we can see, this is simple declaration, so let''s analyze it line by line.
    First, we have the playbook name, a string that can contain whatever we want:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这是一个简单的声明，所以让我们逐行分析一下。首先，我们有playbook名称，一个可以包含我们想要的任何内容的字符串：
- en: The `hosts` variable defines what part of the inventory this playbook is going
    to be performed on – in our case, all the hosts. We can override this (and all
    the other variables) at runtime, but it helps to limit the playbook to just the
    hosts we need to control. In our particular case, this is actually all the hosts
    in our inventory, but in production, we will probably have more than one group
    of hosts.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`hosts`变量定义了这个playbook将在清单的哪一部分上执行 – 在我们的情况下，是所有主机。我们可以在运行时覆盖这一点（以及所有其他变量），但将playbook限制在我们需要控制的主机上是有帮助的。在我们的特定情况下，这实际上是我们清单中的所有主机，但在生产中，我们可能会有多个主机组。'
- en: The next variable is the name of the user that is going to perform the task.
    What we did here is not recommended in production since we are using a superuser
    account to perform tasks. Ansible is completely capable of working with non-privileged
    accounts and elevating rights when needed, but as in all demonstrations, we are
    going to make mistakes so that you don't have to and all in order to make things
    easier to understand.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个变量是执行任务的用户的名称。我们在这里做的事情在生产中是不推荐的，因为我们使用超级用户帐户来执行任务。Ansible完全能够使用非特权帐户并在需要时提升权限，但就像所有演示一样，我们会犯错误，这样你就不必犯错误，所有这些都是为了更容易理解事情。
- en: Now comes the part that is actually performing our tasks. In Ansible, we declare
    roles for the system. In our example, there are two of them. Roles are really
    just tasks to be performed, and that will result in a system that will be in a
    certain state. In our first role, we are going to check if the system supports
    virtualization, and then in the second one, we will install KVM services on all
    the systems that do.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是实际执行我们任务的部分。在Ansible中，我们为系统声明角色。在我们的例子中，有两个角色。角色实际上只是要执行的任务，这将导致系统处于某种状态。在我们的第一个角色中，我们将检查系统是否支持虚拟化，然后在第二个角色中，我们将在所有支持虚拟化的系统上安装KVM服务。
- en: When we downloaded the script from the GitHub, it created a few folders. In
    the one named `roles`, there are two subfolders that each contain a file; one
    is called `checkVirtualization` and the other is called `installKVM`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们从GitHub下载脚本时，它创建了一些文件夹。在名为`roles`的文件夹中，有两个子文件夹，每个文件夹都包含一个文件；一个叫做`checkVirtualization`，另一个叫做`installKVM`。
- en: 'You can probably already see where this is heading. First, let''s see what
    `checkVirtualization` contains:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看到这是怎么回事了。首先，让我们看看`checkVirtualization`包含什么：
- en: '![Figure 11.24 – Checking for CPU virtualization via the lscpu command'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.24–通过lscpu命令检查CPU虚拟化'
- en: '](img/B14834_11_24.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_24.jpg)'
- en: Figure 11.24 – Checking for CPU virtualization via the lscpu command
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.24–通过lscpu命令检查CPU虚拟化
- en: This tasks simply calls a shell command and tries to `grep` for the lines containing
    virtualization parameters for the CPU. If it finds none, it fails.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务只是调用一个shell命令，并尝试使用`grep`来查找包含CPU虚拟化参数的行。如果找不到，它就会失败。
- en: Now, let's see the other task:![Figure 11.25 – Ansible task for installing the
    necessary libvirt packages
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个任务：![图11.25–用于安装必要的libvirt软件包的Ansible任务
- en: '](img/B14834_11_25.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_25.jpg)'
- en: Figure 11.25 – Ansible task for installing the necessary libvirt packages
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.25–用于安装必要的libvirt软件包的Ansible任务
- en: The first part is a simple loop that will just install five different packages
    if they are not present. We are using the package module here, which is a different
    approach than the one we used in our first demonstration regarding how to install
    packages. The module that we used earlier in this chapter is called `yum` and
    is specific to CentOS as a distribution. The `package` module is a generic module
    that will translate to whatever package manager a specific distribution is using.
    Once we've installed all the packages we need, we need to make sure that `libvirtd`
    is enabled and started.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是一个简单的循环，如果它们不存在，将安装五个不同的软件包。我们在这里使用的是包模块，这与我们在第一次演示中如何安装软件包的方法不同。我们在本章早些时候使用的模块称为`yum`，它是特定于CentOS作为发行版的。`package`模块是一个通用模块，将转换为特定发行版使用的任何软件包管理器。一旦我们安装了所有需要的软件包，我们需要确保`libvirtd`已启用并已启动。
- en: We are using a simple loop to go through all the packages that we are installing.
    This is not necessary, but it is a better way to do things than copying and pasting
    individual commands since it makes the list of packages that we need much more
    readable.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个简单的循环来遍历我们正在安装的所有软件包。这不是必需的，但这比复制和粘贴单个命令更好，因为它使我们需要的软件包列表更加可读。
- en: Then, as the last part of the task, we verify if the KVM has loaded.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，作为任务的最后一部分，我们验证KVM是否已加载。
- en: As we can see, the syntax for the playbook is a simple one. It is easily readable,
    even by somebody who has only minor knowledge of scripting or programming. We
    could even say that having a firm understanding of how the Linux command line
    works is more important.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，playbook的语法很简单。即使是对脚本编程只有少量知识的人也可以轻松阅读。我们甚至可以说，对Linux命令行工作原理的深刻理解更为重要。
- en: In order to run a playbook, we use the `ansible-playbook` command, followed
    by the name of the playbook. In our case, we're going to use the `ansible-playbook
    main.yaml` command. Here are the results:![Figure 11.26 – Interactive Ansible
    playbook monitoring
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了运行playbook，我们使用`ansible-playbook`命令，后面跟着playbook的名称。在我们的情况下，我们将使用`ansible-playbook
    main.yaml`命令。这里是结果：![图11.26 - 交互式Ansible playbook监控
- en: '](img/B14834_11_26.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_26.jpg)'
- en: Figure 11.26 – Interactive Ansible playbook monitoring
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.26 - 交互式Ansible playbook监控
- en: Here, we can see that Ansible breaks down everything it did on every host, change
    by change. The end result is a success:![Figure 11.27 – Ansible playbook report
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到Ansible将在每个主机上做的每一项更改进行了详细的拆分。最终结果是成功的：![图11.27 - Ansible playbook报告
- en: '](img/B14834_11_27.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_27.jpg)'
- en: Figure 11.27 – Ansible playbook report
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.27 - Ansible playbook报告
- en: Now, let's check if our freshly installed KVM *cluster* is working.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查我们新安装的KVM *集群*是否正常工作。
- en: 'We are going to start `virsh` and list the active VMs on all the parts of the
    cluster:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将启动`virsh`并列出集群各部分的活动VM：
- en: '![Figure 11.28 – Using Ansible to check all the virtual machines on Ansible
    targets'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.28 - 使用Ansible检查所有Ansible目标上的虚拟机'
- en: '](img/B14834_11_28.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_28.jpg)'
- en: Figure 11.28 – Using Ansible to check all the virtual machines on Ansible targets
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.28 - 使用Ansible检查所有Ansible目标上的虚拟机
- en: Having finished this simple exercise, we have a running KVM on four machines
    and the ability to control them from one place. But we still have no VMs running
    on the hosts. Next, we are going to show you how to create a CentOS installation
    inside the KVM environment, but we are going to use the most basic method to do
    so – `virsh`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了这个简单的练习后，我们在四台机器上都运行了KVM，并且可以从一个地方控制它们。但是我们的主机上还没有运行任何VM。接下来，我们将向您展示如何在KVM环境中创建一个CentOS安装，但我们将使用最基本的方法
    - `virsh`。
- en: 'We are going to do two things: first, we are going to download a minimal ISO
    image for CentOS from the internet. Then, we are going to call `virsh`. This book
    will show you different ways to accomplish this task; downloading from the internet
    is one of the slowest:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将做两件事：首先，我们将从互联网上下载一个CentOS的最小ISO镜像。然后，我们将调用`virsh`。本书将向您展示完成此任务的不同方法；从互联网上下载是最慢的方法之一：
- en: As always, Ansible has a module dedicated to downloading files. The parameters
    it expects are the URL where the file is located and the location of the saved
    file:![Figure 11.29 – Downloading files in Ansible playbooks
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，Ansible有一个专门用于下载文件的模块。它期望的参数是文件所在的URL和保存文件的位置：![图11.29 - 在Ansible playbook中下载文件
- en: '](img/B14834_11_29.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_29.jpg)'
- en: Figure 11.29 – Downloading files in Ansible playbooks
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.29 - 在Ansible playbook中下载文件
- en: After running the playbook, we need to check if the files have been downloaded:![Figure
    11.30 – Status check – checking if the files have been downloaded to our targets
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行playbook后，我们需要检查文件是否已经下载：![图11.30 - 状态检查 - 检查文件是否已经下载到我们的目标
- en: '](img/B14834_11_30.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_30.jpg)'
- en: Figure 11.30 – Status check – checking if the files have been downloaded to
    our targets
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.30 - 状态检查 - 检查文件是否已经下载到我们的目标
- en: 'Since we are not automating this and instead creating a single task, we are
    going to run it in a local shell. The command to run for this would be something
    like the following:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们没有自动化这个过程，而是创建了一个单独的任务，我们将在本地shell中运行它。要运行此命令，可以使用类似以下的命令：
- en: '[PRE20]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Without a kickstart file or some other kind of preconfiguration, this VM makes
    no sense since we will not be able to connect to it or even finish the installation.
    In the next task, we will remedy that using cloud-init.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有kickstart文件或其他类型的预配置，这个VM是没有意义的，因为我们将无法连接到它，甚至无法完成安装。在下一个任务中，我们将使用cloud-init来解决这个问题。
- en: 'Now, we can check if everything worked:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以检查一切是否都正常工作：
- en: '![Figure 11.31 – Using Ansible to check if all our VMs are running'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.31 - 使用Ansible检查我们的所有VM是否正在运行'
- en: '](img/B14834_11_31.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_31.jpg)'
- en: Figure 11.31 – Using Ansible to check if all our VMs are running
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.31 - 使用Ansible检查我们的所有VM是否正在运行
- en: Here, we can see that all the KVMs are running and that each of them has its
    own virtual machine online and running.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到所有的KVM都在运行，并且每个KVM都有自己的虚拟机在线并运行。
- en: 'Now, we are going to wipe our KVM cluster and start again, but this time with
    a different configuration: we are going to deploy the cloud version of CentOS
    and reconfigure it using cloud-init.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将清除我们的KVM集群，并重新开始，但这次使用不同的配置：我们将部署CentOS的云版本，并使用cloud-init重新配置它。
- en: Using Ansible and cloud-init for automation and orchestration
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ansible和cloud-init进行自动化和编排
- en: '**Cloud-init** is one of the more popular ways of machine deployment in private
    and hybrid cloud environments. This is because it enables machines to be quickly
    reconfigured in a way that enables just enough functionality to get them connected
    to an orchestration environment such as Ansible.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cloud-init**是私有和混合云环境中机器部署的更受欢迎的方式之一。这是因为它使机器能够快速重新配置，以便启用足够的功能，使它们能够连接到诸如Ansible之类的编排环境。'
- en: More details can be found at [cloud-init.io](http://cloud-init.io), but in a
    nutshell, cloud-init is a tool that enables the creation of special files that
    can be combined with VM templates in order to rapidly deploy them. The main difference
    between cloud-init and unattended installation scripts is that cloud-init is more
    or less distribution-agnostic and much easier to change with scripting tools.
    This means less work during deployment, and less time from start of deployment
    until machines are online and working. On CentOS, this can be accomplished with
    kickstart files, but this not nearly as flexible as cloud-init.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 更多细节可以在[cloud-init.io](http://cloud-init.io)找到，但简而言之，cloud-init是一个工具，可以创建特殊文件，可以与VM模板结合，以便快速部署它们。cloud-init和无人值守安装脚本之间的主要区别在于，cloud-init更多或更少地与发行版无关，并且更容易使用脚本工具进行更改。这意味着在部署过程中工作量更少，从部署开始到机器在线并工作的时间更短。在CentOS上，可以使用kickstart文件来实现这一点，但这远不及cloud-init灵活。
- en: 'Cloud-init works using two separate parts: one is the distribution file for
    the operating system we are deploying. This is not the usual OS installation file,
    but a specially configured machine template intended to be used as a cloud-init
    image.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud-init使用两个单独的部分工作：一个是我们正在部署的操作系统的分发文件。这不是通常的OS安装文件，而是一个特别配置的机器模板，旨在用作cloud-init镜像。
- en: The other part of the system is the configuration file, which is *compiled*–or
    to be more precise, *packed* – from a special YAML text file that contains configuration
    for the machine. This configuration is small and ideal for network transmission.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的另一部分是配置文件，它是从一个包含机器配置的特殊YAML文本文件中*编译* - 或者更准确地说，*打包*出来的。这个配置很小，非常适合网络传输。
- en: These two parts are intended to be used as a whole to create multiple instances
    of identical virtual machines.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个部分旨在作为一个整体用于创建多个相同虚拟机实例。
- en: 'The way this works is simple:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式很简单：
- en: First, we distribute a machine template that is completely identical for all
    the machines that we are going to create. This means having one master copy and
    creating all the instances out of it.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们分发一个完全相同的机器模板，用于创建我们将要创建的所有机器。这意味着有一个主模板副本，并且可以从中创建所有实例。
- en: Then, we pair the template with a specially crafted file that is created using
    cloud-init. Our template, regardless of the OS it uses, is capable of understanding
    different directives that we can set in the cloud-init file and will be reconfigured.
    This can be repeated as needed.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将模板与使用cloud-init创建的一个特制文件配对。我们的模板，无论使用的操作系统是什么，都能够理解可以在cloud-init文件中设置的不同指令，并将被重新配置。这可以根据需要重复进行。
- en: 'Let''s simplify this even more: if we need to create 100 servers that will
    have four different roles using the unattended installation files, we would have
    to boot 100 images and wait for them to go through all the installation steps
    one by one. Then, we would need to reconfigure them for the task we need. Using
    cloud-init, we are booting one image in 100 instances, but the system takes only
    a couple of seconds to boot since it is already installed. Only critical information
    is needed to put it online, after which we can take over and completely configure
    it using Ansible.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更简化一下：如果我们需要使用无人值守安装文件创建具有四种不同角色的100台服务器，我们将不得不启动100个镜像，并等待它们逐个完成所有安装步骤。然后，我们需要为我们需要的任务重新配置它们。使用cloud-init，我们在100个实例中启动一个镜像，但系统只需要几秒钟就能启动，因为它已经安装好了。只需要关键信息将其上线，之后我们可以接管并使用Ansible完全配置它。
- en: 'We are not going to dwell too much on cloud-init''s configuration; everything
    we need is in this example:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会过多讨论cloud-init的配置；我们需要的一切都在这个例子中：
- en: '![Figure 11.32 – Using cloud-init for additional configuration'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.32 - 使用cloud-init进行附加配置'
- en: '](img/B14834_11_32.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_32.jpg)'
- en: Figure 11.32 – Using cloud-init for additional configuration
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.32 - 使用cloud-init进行附加配置
- en: As always, we will explain what's going on step by step. One thing we can see
    from the start is that it uses straight YAML notation, the same as Ansible. The
    first directive is here to make sure that our machine is updated as it enables
    automatically updating the packages on the cloud instance.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们将一步一步地解释发生了什么。我们从一开始就可以看到它使用直接的YAML表示法，与Ansible相同。第一个指令是为了确保我们的机器已更新，因为它可以自动更新云实例上的软件包。
- en: Then, we are configuring users. We are going to create one user named `ansible`
    who will belong to group `wheel`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们正在配置用户。我们将创建一个名为`ansible`的用户，他将属于`wheel`组。
- en: '`Lock_passwd` means that we are going to permit using the password to log in.
    If nothing is configured, then the default is to permit logging in only using
    `SSH` keys and disabling password login completely.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lock_passwd`表示我们将允许使用密码登录。如果没有配置任何内容，则默认情况下只允许使用`SSH`密钥登录，并完全禁用密码登录。'
- en: Then, we have the password in hash format. Depending on the distribution, this
    hash can be created in different ways. Do *not* put a plaintext password here.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有哈希格式的密码。根据发行版的不同，可以以不同的方式创建这个哈希。在这里*不要*放置明文密码。
- en: Then, we have a shell that this user will be able to use if something needs
    to be added to the `/etc/sudoers` file. In this particular case, we are giving
    this user complete control over the system.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有一个shell，这个用户将能够使用，如果需要向`/etc/sudoers`文件添加内容。在这种情况下，我们给予这个用户对系统的完全控制。
- en: The last thing is probably the most important. This is the public `SSH` key
    that we have on our system. It's used to authorize the user when they're logging
    in. There can be multiple keys here, and they are going to end up in the `SSHD`
    configuration to enable users to perform a passwordless login.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事可能是最重要的。这是我们系统上的公共`SSH`密钥。它用于授权用户登录时使用。这里可以有多个密钥，并且它们将最终出现在`SSHD`配置中，以便用户可以进行无密码登录。
- en: There are plenty more variables and directives we can use here, so consult the
    `cloud-config` documentation for more information.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多变量和指令可以使用，因此请查阅`cloud-config`文档以获取更多信息。
- en: After we have created this file, we need to convert it into an `.iso` file that
    is going to be used for installation. The command to do this is `cloud-localds`.
    We are using our YAML file as one parameter and the `.iso` file as another.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完这个文件后，我们需要将其转换为一个`.iso`文件，该文件将用于安装。执行此操作的命令是`cloud-localds`。我们将我们的YAML文件用作一个参数，`.iso`文件用作另一个参数。
- en: After running `cloud-localds config.iso config.yaml`, we are ready to begin
    our deployment.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`cloud-localds config.iso config.yaml`之后，我们准备开始部署。
- en: The next thing we need is the cloud image for CentOS. As we mentioned previously,
    this is a special image that is designed to be used for this particular purpose.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的下一件事是CentOS的云镜像。正如我们之前提到的，这是一种专门设计用于这个特定目的的特殊镜像。
- en: We are going to get it from [https://cloud.centos.org/centos/7/images](https://cloud.centos.org/centos/7/images).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从[https://cloud.centos.org/centos/7/images](https://cloud.centos.org/centos/7/images)获取它。
- en: There are quite a few files here denoting all the available versions of the
    CentOS image. If you need a specific version, pay attention to the numbers denoting
    the month/year of the image release. Also, note that images come in two flavors
    – compressed and uncompressed.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多文件，表示CentOS镜像的所有可用版本。如果您需要特定版本，请注意表示镜像发布的月/年的数字。还要注意，镜像有两种类型 - 压缩和未压缩。
- en: Images are in `qcow2` format and intended to be used in the cloud as a disk.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像以`qcow2`格式存在，旨在作为云盘使用。
- en: 'In our example, on the Ansible machine, we created a new directory called `/clouddeploy`
    and saved two file into it: one that contains the OS cloud image and `config.iso`,
    which we created using `cloud-init`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，在Ansible机器上，我们创建了一个名为`/clouddeploy`的新目录，并将两个文件保存在其中：一个包含OS云镜像的文件和使用`cloud-init`创建的`config.iso`：
- en: '![Figure 11.33 – Checking the content of a directory'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.33 - 检查目录内容'
- en: '](img/B14834_11_33.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_33.jpg)'
- en: Figure 11.33 – Checking the content of a directory
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.33 - 检查目录内容
- en: 'All that remains now is to create a playbook to deploy these. Let''s go through
    the steps:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是创建一个部署这些内容的playbook。让我们按照以下步骤进行：
- en: First, we are going to copy the cloud image and our configuration onto our KVM
    hosts. After that, we are going to create a machine out of these and start it:![Figure
    11.34 – The playbook that will download the required image, configure cloud-init,
    and start the VM deployment process
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将复制云镜像和我们的配置到我们的KVM主机上。之后，我们将创建一个机器，并启动它：![图11.34 - 将下载所需镜像、配置cloud-init并启动VM部署过程的playbook
- en: '](img/B14834_11_34.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_34.jpg)'
- en: Figure 11.34 – The playbook that will download the required image, configure
    cloud-init, and start the VM deployment process
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.34 - 将下载所需镜像、配置cloud-init并启动VM部署过程的playbook
- en: Since this is our first *complicated* playbook, we need to explain a few things.
    In every play or task, there are some things that are important. A name is used
    to simplify running the playbook; this is what is going to be displayed when the
    playbook runs. This name should be explanatory enough to help, but not too long
    in order to avoid clutter.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们的第一个*复杂*的playbook，我们需要解释一些事情。在每个play或task中，有一些重要的事情。名称用于简化运行playbook；这是playbook运行时将显示的内容。这个名称应该足够解释性，以帮助理解，但不要太长以避免混乱。
- en: 'After the name, we have the business part of each task – the name of the module
    being called. In our example, we are using three distinct ones: `copy`, `command`,
    and `virt`. `copy` is used to copy files between hosts, `command` executes commands
    on the remote machine, and `virt` contains commands and states needed to control
    the virtual environment.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在名称之后，我们有每个任务的业务部分 - 被调用的模块的名称。在我们的例子中，我们使用了三个不同的模块：`copy`、`command`和`virt`。`copy`用于在主机之间复制文件，`command`在远程机器上执行命令，`virt`包含控制虚拟环境所需的命令和状态。
- en: You will notice when reading this that `copy` looks strange; `src` denotes a
    local directory, while `dest` denotes a remote one. This is by design. To simplify
    things, `copy` works between the local machine (the control node running Ansible)
    and the remote machine (the one being configured). Directories will get created
    if they do not exist, and `copy` will apply the appropriate permissions.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读时您会注意到`copy`看起来很奇怪；`src`表示本地目录，而`dest`表示远程目录。这是有意设计的。为了简化事情，`copy`在本地机器（运行Ansible的控制节点）和远程机器（正在配置的机器）之间工作。如果目录不存在，将会创建目录，并且`copy`将应用适当的权限。
- en: After that, we are running a command that will work on local files and create
    a virtual machine. One important thing here is that we are basically running the
    image we copied; the template is on the control node. At the same time, this saves
    disk space and deployment time – there is no need to copy the machine from local
    to remote disk and then duplicate it on the remote machine once again; as soon
    as the image is there, we can run it.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将运行一个命令，该命令将处理本地文件并创建一个虚拟机。这里的一个重要事情是，我们基本上运行了我们复制的镜像；模板在控制节点上。同时，这节省了磁盘空间和部署时间
    - 没有必要将机器从本地复制到远程磁盘，然后再次在远程机器上复制；一旦镜像在那里，我们就可以运行它。
- en: Back to the important part – the local installation. We are creating a machine
    with 1 GB of RAM and one CPU using the disk image we just copied. We're also attaching
    our `config.iso` file as a virtual CD/DVD. We are then importing this image and
    using no graphic terminal.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 回到重要的部分 – 本地安装。我们正在创建一个具有1GB RAM和一个CPU的机器，使用我们刚刚复制的磁盘映像。我们还将`config.iso`文件作为虚拟CD/DVD附加。然后，我们导入此映像并不使用图形终端。
- en: 'The last task is starting the VM on the remote KVM host. We will use the following
    command to do so:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '最后一个任务是在远程KVM主机上启动VM。我们将使用以下命令来执行： '
- en: '[PRE21]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If everything ran OK, we should see something like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常运行，我们应该看到类似于这样的东西：
- en: '![Figure 11.35 – Checking our installation process'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.35 – 检查我们的安装过程'
- en: '](img/B14834_11_35.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_35.jpg)'
- en: Figure 11.35 – Checking our installation process
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.35 – 检查我们的安装过程
- en: 'We can also check this using the command line:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用命令行来检查：
- en: '[PRE22]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of this command should look something like this:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出应该看起来像这样：
- en: '![Figure 11.36 – Checking our VMs'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.36 – 检查我们的虚拟机'
- en: '](img/B14834_11_36.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_36.jpg)'
- en: Figure 11.36 – Checking our VMs
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.36 – 检查我们的虚拟机
- en: 'Let''s check two more things – networking and the machine state. Type in the
    following command:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再检查两件事 – 网络和机器状态。输入以下命令：
- en: '[PRE23]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We should get something like this:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到类似于这样的东西：
- en: '![Figure 11.37 – Checking our VM network connectivity and network configuration'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.37 – 检查我们的VM网络连接和网络配置'
- en: '](img/B14834_11_37.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_37.jpg)'
- en: Figure 11.37 – Checking our VM network connectivity and network configuration
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.37 – 检查我们的VM网络连接和网络配置
- en: This verifies that our machines are running correctly and that they are connected
    to their local network on the local KVM instance. Elsewhere in this book, we will
    deal with KVM networking in more detail, so it should be easy to reconfigure machines
    to use a common network, either by bridging adapters on the KVMs or by creating
    a separate virtual network that will span across hosts.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这验证了我们的机器是否正常运行，并且它们连接到本地KVM实例的本地网络。在本书的其他地方，我们将更详细地处理KVM网络，因此重新配置机器以使用公共网络应该很容易，无论是通过在KVM上桥接适配器，还是通过创建一个跨主机的独立虚拟网络。
- en: Another thing we wanted to show is the machine status for all the hosts. The
    point is that we are not using the shell module this time; instead, we are relying
    on the `virt` module to show us how to use it from the command line. There is
    only one subtle difference here. When we are calling shell (or `command`) modules,
    we are calling parameters that are going to get called. These modules basically
    just spawn another process on the remote machine and run it with the parameters
    we provided.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要展示的另一件事是所有主机的机器状态。重点是，这次我们不是使用shell模块；相反，我们依靠`virt`模块来显示如何从命令行使用它。这里只有一个细微的区别。当我们调用shell（或`command`）模块时，我们正在调用将被调用的参数。这些模块基本上只是在远程机器上生成另一个进程，并使用我们提供的参数运行它。
- en: 'In contrast, the `virt` module takes the variable declaration as its parameter
    since we are running `virt` with `command=info`. When using Ansible, you will
    notice that, sometimes, variables are just states. If we wanted to start a particular
    instance, we would just add `state=running`, along with an appropriate name, and
    Ansible would make sure that the VM is running. Let''s type in the following command:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`virt`模块以变量声明作为其参数，因为我们正在使用`command=info`运行`virt`。在使用Ansible时，您会注意到，有时变量只是状态。如果我们想要启动特定的实例，我们只需添加`state=running`，以及一个适当的名称，Ansible会确保虚拟机正在运行。让我们输入以下命令：
- en: '[PRE24]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following is the expected output:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是预期的输出：
- en: '![Figure 11.38 – Using the virt module with Ansible'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.38 – 使用virt模块与Ansible'
- en: '](img/B14834_11_38.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_38.jpg)'
- en: Figure 11.38 – Using the virt module with Ansible
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.38 – 使用virt模块与Ansible
- en: There is only one thing that we haven't covered yet – how to install multi-tiered
    applications. Pushing the definition to its smallest extreme, we are going to
    install a LAMP server using a simple playbook.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有涵盖的一件事是如何安装多层应用程序。将定义推到最小的极端，我们将使用简单的playbook安装LAMP服务器。
- en: Orchestrating multi-tier application deployment on KVM VM
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在KVM VM上编排多层应用程序部署
- en: Now, let's learn how to install multi-tiered applications. Pushing the definition
    to its smallest extreme, we are going to install a LAMP server using a simple
    Ansible playbook.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何安装多层应用程序。将定义推到最小的极端，我们将使用简单的Ansible playbook安装LAMP服务器。
- en: The tasks that need to be done are simple enough – we need to install Apache,
    MySQL, and PHP. The *L* part of LAMP is already installed, so we are not going
    to go through that again.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 需要完成的任务非常简单 – 我们需要安装Apache、MySQL和PHP。LAMP的*L*部分已经安装好了，所以我们不会再次进行安装。
- en: 'The difficult part is the package names: in our demonstration machine, we are
    using CentOS7 as the operating system and its package names are a little different.
    Apache is called `httpd` and `mysql` is replaced with `mariaDB`, another engine
    that is compatible with MySQL. PHP is luckily the same as on other distributions.
    We also need another package named `python2-PyMySQL` (the name is case sensitive)
    in order to get our playbook to work.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 困难的部分是软件包名称：在我们的演示机器上，我们使用CentOS7作为操作系统，其软件包名称有些不同。Apache被称为`httpd`，`mysql`被替换为与MySQL兼容的另一个引擎`mariaDB`。PHP幸运地与其他发行版上的相同。我们还需要另一个名为`python2-PyMySQL`的软件包（名称区分大小写）以使我们的playbook工作。
- en: 'The next thing we are going to do is test the installation by starting all
    the services and creating the simplest `.php` script possible. After that, we
    are going to create a database and a user that is going to use it. As a warning,
    in this chapter, we are concentrating on Ansible basics, since Ansible is far
    too complex to be covered in one chapter of a book. Also, we are presuming a lot
    of things, and our biggest assumption is that we are creating demo systems that
    are not in any way intended for production. This playbook in particular lacks
    one important step: creating a root password. Do not go into production with your
    SQL password not set.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的事情是通过启动所有服务并创建最简单的`.php`脚本来测试安装。之后，我们将创建一个数据库和一个将使用它的用户。需要警告的是，在本章中，我们专注于Ansible的基础知识，因为Ansible太复杂，无法在一本书的一章中涵盖。此外，我们假设了很多事情，我们最大的假设是我们正在创建的演示系统并不打算用于生产。特别是这个playbook缺少一个重要的步骤：创建一个root密码。不要在未设置SQL密码的情况下投入生产。
- en: 'One more thing: our script presumes that there is a file named `index.php`
    in the directory our playbook runs from, and that file will get copied to the
    remote system:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事：我们的脚本假设在我们的playbook运行的目录中有一个名为`index.php`的文件，并且该文件将被复制到远程系统中：
- en: '![Figure 11.39 – Ansible LAMP playbook'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.39 - Ansible LAMP playbook'
- en: '](img/B14834_11_39.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_39.jpg)'
- en: Figure 11.39 – Ansible LAMP playbook
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.39 - Ansible LAMP playbook
- en: 'As we can see, there is nothing complicated going on, just a simple sequence
    of steps. Our `.php` file looks like this:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，没有发生复杂的事情，只是一系列简单的步骤。我们的`.php`文件如下所示：
- en: '![Figure 11.40 – Testing if PHP works'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.40 - 测试PHP是否正常工作'
- en: '](img/B14834_11_40.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_40.jpg)'
- en: Figure 11.40 – Testing if PHP works
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.40 - 测试PHP是否正常工作
- en: 'Things can''t get any simpler than that. In a normal deployment scenario, we
    would have something more complicated in the web server directory, such as a WordPress
    or Joomla installation, or even a custom application. The only thing that needs
    to change is the file that is copied (or a set of files) and the location of the
    database. Our file just prints information about the local `.php` installation:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 事情不可能比这更简单了。在正常的部署场景中，我们在web服务器目录中会有更复杂的东西，比如WordPress或Joomla安装，甚至是自定义应用程序。唯一需要改变的是被复制的文件（或一组文件）和数据库的位置。我们的文件只是打印有关本地`.php`安装的信息：
- en: '![Figure 11.41 – Checking if PHP works on Apache using a web browser'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.41 - 使用Web浏览器检查PHP在Apache上是否正常工作'
- en: and a previously configured PHP file
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 以及之前配置的PHP文件
- en: '](img/B14834_11_41.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_11_41.jpg)'
- en: Figure 11.41 – Checking if PHP works on Apache using a web browser and a previously
    configured PHP file
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.41 - 使用Web浏览器检查PHP在Apache上是否正常工作和之前配置的PHP文件
- en: Ansible is much more complex than what we showed you here in this chapter, so
    we strongly suggest you do some further reading and learning. What we did here
    was just the simplest example of how we can install KVM on multiple hosts and
    control all of them at once using the command line. What Ansible does best is
    save us time – imagine having a couple of hundred hypervisors and having to deploy
    thousands of servers. Using playbooks and a couple of preconfigured images, we
    can not only configure KVM to run our machines, but reconfigure anything on the
    machines themselves. The only real prerequisites are a running SSH server and
    an inventory that will enable us to group machines.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible比我们在本章中展示的要复杂得多，因此我们强烈建议您进行进一步阅读和学习。我们在这里所做的只是如何在多个主机上安装KVM并使用命令行一次性控制它们的最简单示例。Ansible最擅长的是节省我们的时间
    - 想象一下有几百个hypervisor并且必须部署成千上万台服务器。使用playbooks和一些预配置的镜像，我们不仅可以配置KVM来运行我们的机器，还可以重新配置机器上的任何东西。唯一真正的先决条件是运行的SSH服务器和一个能够使我们对机器进行分组的清单。
- en: Learning by example – various examples of using Ansible with KVM
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过示例学习 - 使用Ansible与KVM的各种示例
- en: 'Now that we''ve covered simple and more complex Ansible tasks, let''s think
    about how to use Ansible to further our configuration skills and overall compliance
    based on some kind of policy. The following are some things that we are going
    to leave as exercises for you:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了简单和更复杂的Ansible任务，让我们考虑如何使用Ansible来进一步提高我们的配置技能和整体合规性，基于某种政策。以下是一些我们将留给您作为练习的事项：
- en: 'Task 1:'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务1：
- en: We configured and ran one machine per KVM host. Create a playbook that will
    form a pair of hosts – one running a website and another running a database. You
    can use any open source CMS for this.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置并运行了每个KVM主机上的一台机器。创建一个将形成一对主机的playbook - 一个运行网站，另一个运行数据库。您可以使用任何开源CMS来实现这一点。
- en: 'Task 2:'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '任务2:'
- en: 'Use Ansible and the `virt-net` module to reconfigure the network so that the
    entire cluster can communicate. KVM accepts `.xml` configuration for networking,
    and `virt-net` can both read and write XML. Hint: If you get confused, use a separate
    RHEL8 machine to create a virtual network in the GUI and then use the `virsh net-dumpxml`
    syntax to output a virtual network configuration to standard output, which you
    can then use as a template.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ansible和`virt-net`模块重新配置网络，以便整个集群可以通信。KVM接受网络的`.xml`配置，`virt-net`可以读取和写入XML。提示：如果感到困惑，请使用单独的RHEL8机器在GUI中创建一个虚拟网络，然后使用`virsh
    net-dumpxml`语法将虚拟网络配置输出到标准输出，然后可以将其用作模板。
- en: 'Task 3:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务3：
- en: Use `ansible` and `virsh` to auto-start a specific VM that you created/imported
    on the host.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ansible`和`virsh`自动启动您在主机上创建/导入的特定VM。
- en: 'Task 4:'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务4：
- en: 'Based on our LAMP deployment playbook, improve on it by doing the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的LAMP部署playbook，通过以下方式改进它：
- en: a) Create a playbook that will run on a remote machine.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: a）创建一个可以在远程机器上运行的playbook。
- en: b) Create a playbook that will install different roles on different servers.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: b）创建一个将在不同服务器上安装不同角色的playbook。
- en: c) Create a playbook that will deploy a more complex application, such as WordPress.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: c）创建一个部署更复杂应用程序（如WordPress）的playbook。
- en: If you managed to solve these five tasks, then congratulations – you're *en
    route* to becoming an administrator who can use Automation, with a capital *A*.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您成功解决了这五个任务，那么恭喜您——您正在成为一个可以使用大写字母*A*的自动化管理员。
- en: Summary
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed Ansible – a simple tool for orchestration and
    automation. It can be used both in open source and Microsoft-based environments
    as it supports both natively. Open source systems can be accessed via SSH keys,
    while Microsoft operating systems can be accessed by using WinRM and PowerShell.
    We learned a lot about simple Ansible tasks and more complex ones since deploying
    a multi-tier application that's hosted on multiple virtual machines isn't an easy
    task to do – especially if you're approaching the problem manually. Even deploying
    a KVM hypervisor on multiple hosts can take quite a bit of time, but we managed
    to solve that with one simple Ansible playbook. Mind you, we only needed some
    20 configuration lines to do that, and the upshot of that is that we can easily
    add hundreds of more hosts as targets for this Ansible playbook.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Ansible——一个用于编排和自动化的简单工具。它可以在开源和基于Microsoft的环境中使用，因为它本身支持这两种环境。可以通过SSH密钥访问开源系统，而可以通过WinRM和PowerShell访问Microsoft操作系统。我们学到了许多关于简单的Ansible任务和更复杂的任务，因为部署托管在多个虚拟机上的多层应用程序并不是一件容易的事情——特别是如果您手动解决问题。即使在多个主机上部署KVM
    hypervisor也可能需要相当长的时间，但我们成功地用一个简单的Ansible playbook解决了这个问题。请注意，我们只需要大约20行配置来做到这一点，而由此带来的好处是我们可以轻松地将数百个主机添加为此Ansible
    playbook的目标。
- en: The next chapter takes us to a world of cloud services – specifically OpenStack
    – where our Ansible knowledge is going to be very useful for large-scale virtual
    machine configuration as it's impossible to configure all of our cloud virtual
    machines by using any kind of manual utilities. Apart from that, we'll extend
    our knowledge of Ansible by integrating OpenStack and Ansible so that we can use
    both of these platforms to do what they do really well – manage cloud environments
    and configure their consumables.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将带我们进入云服务的世界——具体来说是OpenStack——在那里我们的Ansible知识将对大规模虚拟机配置非常有用，因为使用任何手动工具都无法配置所有的云虚拟机。除此之外，我们将通过集成OpenStack和Ansible来扩展我们对Ansible的了解，以便我们可以同时使用这两个平台来做它们擅长的事情——管理云环境和配置其可消耗资源。
- en: Questions
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is Ansible?
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Ansible？
- en: What does an Ansible playbook do?
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible playbook的作用是什么？
- en: Which communication protocol does Ansible use to connect to its targets?
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ansible使用哪种通信协议连接到其目标？
- en: What is AWX?
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是AWX？
- en: What is Ansible Tower?
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Ansible Tower？
- en: Further reading
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Please refer to the following links for more information regarding what was
    covered in this chapter:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章内容的更多信息，请参考以下链接：
- en: 'What is Ansible?: [https://www.ansible.com/](https://www.ansible.com/)'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Ansible？：[https://www.ansible.com/](https://www.ansible.com/)
- en: 'Ansible documentation: [https://docs.ansible.com/](https://docs.ansible.com/)'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible文档：[https://docs.ansible.com/](https://docs.ansible.com/)
- en: 'Ansible overview: [https://www.ansible.com/overview/it-automation](https://www.ansible.com/overview/it-automation)'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible概述：[https://www.ansible.com/overview/it-automation](https://www.ansible.com/overview/it-automation)
- en: 'Ansible use cases: [https://www.ansible.com/use-cases](https://www.ansible.com/use-cases)'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible用例：[https://www.ansible.com/use-cases](https://www.ansible.com/use-cases)
- en: 'Ansible for continuous delivery: [https://www.ansible.com/use-cases/continuous-delivery](https://www.ansible.com/use-cases/continuous-delivery)'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于持续交付的Ansible：[https://www.ansible.com/use-cases/continuous-delivery](https://www.ansible.com/use-cases/continuous-delivery)
- en: 'Integrating Ansible with Jenkins: [https://www.redhat.com/en/blog/integrating-ansible-jenkins-cicd-process](https://www.redhat.com/en/blog/integrating-ansible-jenkins-cicd-process)'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Ansible与Jenkins集成：[https://www.redhat.com/en/blog/integrating-ansible-jenkins-cicd-process](https://www.redhat.com/en/blog/integrating-ansible-jenkins-cicd-process)
