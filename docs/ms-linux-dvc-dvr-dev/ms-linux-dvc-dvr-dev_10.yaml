- en: '*Chapter 8*: Integrating with V4L2 Async and Media Controller Frameworks'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：与V4L2异步和媒体控制器框架集成
- en: Over time, media support has become a must and a saling argument for **System
    on Chips** (**SoCs**), which keep becoming more and more complex. The complexity
    of those media IP cores is such that grabbing sensor data requires a whole pipeline
    (made of several sub-devices) to be set up by the software. The asynchronous nature
    of a device tree-based system means the setup and probing of those sub-devices
    are not straightforward. Thus entered the async framework, which addresses the
    unordered probing of sub-devices in order for the media device to be popped on
    time, when all of the media sub-devices are ready. Last but not least, because
    of the complexity of the media pipe, it became necessary to find a way to ease
    the configuration of the sub-devices it is made of. Thus came the media controller
    framework, which wraps the whole media pipe in a single element, the media device.
    It comes with some abstractions, one of which is that each sub-device is considered
    as an entity, with either a sink pad, a source pad, or both.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，媒体支持已成为**片上系统**（**SoCs**）的必备和销售论点，这些系统变得越来越复杂。这些媒体IP核的复杂性使得获取传感器数据需要软件建立整个管道（由多个子设备组成）。基于设备树的系统的异步性质意味着这些子设备的设置和探测并不是直接的。因此，异步框架应运而生，它解决了无序探测子设备的问题，以便在所有媒体子设备准备就绪时及时弹出媒体设备。最后但并非最不重要的是，由于媒体管道的复杂性，有必要找到一种简化其构成子设备配置的方法。因此，媒体控制器框架应运而生，它将整个媒体管道包装在一个单一元素中，即媒体设备。它带有一些抽象，其中之一是将每个子设备视为一个实体，具有接收端口、发送端口或两者兼有。
- en: This chapter will focus on how both the async and media controller frameworks
    work and how they are designed, and we will go through their APIs to learn how
    to leverage them in **Video4Linux2** (**V4L2**) device driver development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍异步和媒体控制器框架的工作原理和设计，并且我们将通过它们的API来学习如何在**Video4Linux2**（**V4L2**）设备驱动程序开发中利用它们。
- en: 'In other words, in this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在本章中，我们将涵盖以下主题：
- en: The V4L2 async interface and the concept of graph binding
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: V4L2异步接口和图形绑定的概念
- en: The V4L2 async and graph-oriented API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: V4L2异步和图形导向的API
- en: The V4L2 async framework and APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: V4L2异步框架和API
- en: The Linux media controller framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux媒体控制器框架
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, you''ll need the following elements:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将需要以下元素：
- en: Advanced computer architecture knowledge and C programming skills
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级计算机架构知识和C编程技能
- en: Linux kernel v4.19.X sources, available at [https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核v4.19.X源代码，可在[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)上找到
- en: The V4L2 async interface and the concept of graph binding
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: V4L2异步接口和图形绑定的概念
- en: So far, with V4L2 driver development, we have not actually dealt with the probing
    order. That being said, we considered the synchronous approach, where bridge device
    drivers register devices for all sub-devices synchronously during their probing.
    However, this approach cannot be used with intrinsically asynchronous and unordered
    device registration systems, such as the **flattened device tree**. To address
    this, what we currently call the async interface has been introduced.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，对于V4L2驱动程序开发，我们实际上并没有处理探测顺序。也就是说，我们考虑了同步方法，其中桥接设备驱动程序在它们的探测期间同步为所有子设备注册设备。然而，这种方法不能用于固有的异步和无序设备注册系统，例如**扁平设备树**。为了解决这个问题，我们目前所说的异步接口被引入。
- en: With this new approach, bridge drivers register lists of sub-device descriptors
    and notifier callbacks, and sub-device drivers register sub-devices that they
    are about to probe or have successfully probed. The async core will take care
    of matching sub-devices against hardware descriptors and calling bridge driver
    callbacks when matches are found. Another callback is called when the sub-device
    is unregistered. The async subsystem relies on device declaration in a special
    way, called **graph binding**, which we will deal with in the next section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种新方法，桥接驱动程序注册子设备描述符和通知回调列表，子设备驱动程序注册它们即将探测或已成功探测的子设备。异步核心将负责匹配子设备与硬件描述符，并在找到匹配项时调用桥接驱动程序的回调。当子设备注销时，将调用另一个回调。异步子系统依赖于以一种特殊方式声明的设备，称为**图形绑定**，我们将在下一节中处理。
- en: Graph binding
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图形绑定
- en: Embedded systems have a reduced set of devices, some of which are not discoverable.
    The device tree, however, came into the picture to allow describing the actual
    system (from a hardware point of view) to the kernel. Sometimes (if not always),
    these devices are somehow interconnected.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式系统具有一组减少的设备，其中一些是不可发现的。然而，设备树出现在画面中，允许从内核描述实际系统（从硬件角度）的描述。有时（如果不是总是），这些设备在某种程度上是相互连接的。
- en: While the `phandle` properties pointing to other nodes could be used in the
    device tree to describe simple and direct connections, such as parent/child relationships,
    there was no way to model compound devices made of several interconnections. There
    were situations where the relationship modeling resulted in a quite complete graph
    – for example, the i.MX6 **Image Processing Unit** (**IPU**), which is a logical
    device on its own, but made up of several physical IP blocks whose interconnections
    may result in a quite complex pipe.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然设备树中指向其他节点的`phandle`属性可以用来描述简单和直接的连接，例如父/子关系，但无法对由多个互连组成的复合设备进行建模。有时，关系建模会导致相当完整的图形，例如i.MX6
    **图像处理单元**（**IPU**），它本身是一个逻辑设备，但由多个物理IP块组成，它们的互连可能导致一个相当复杂的管道。
- en: 'This is where the so-called **Open Firmware** (**OF**) **graph** intervenes,
    along with its API and some new concepts, the concepts of **port** and **endpoint**:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的**开放固件**（**OF**）**图形**介入的地方，以及它的API和一些新概念，即**端口**和**端点**的概念：
- en: A **port** can be seen as an interface in a device (as in an IP block).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**可以被视为设备中的接口（如IP块）。'
- en: An **endpoint** can be seen as a pad, as it describes one end of a connection
    to a remote port.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端点**可以被视为一个垫，因为它描述了与远程端口的连接的一端。'
- en: However, `phandle` properties are still used to refer to other nodes in the
    tree. More documentation on this can be found in `Documentation/devicetree/bindings/graph.txt`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`phandle`属性仍然用于引用树中的其他节点。关于这方面的更多文档可以在`Documentation/devicetree/bindings/graph.txt`中找到。
- en: Port and endpoint representations
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端口和端点表示
- en: A port is an interface to a device. A device can have one or several ports.
    Ports are represented by port nodes contained in the node of the device they belong
    to. Each port node contains an endpoint subnode for each remote device port to
    which this port is connected. This means a single port can be connected to more
    than one port on the remote device(s) and that each link must be represented by
    an endpoint child node. Now, if a device node contains more than one port, if
    there is more than one endpoint at a port, or a port node needs to be connected
    to a selected hardware interface, a popular scheme using the `#address-cells`,
    `#size-cells`, and `reg` properties is used to number the nodes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 端口是设备的接口。一个设备可以有一个或多个端口。端口由包含在其所属设备的节点中的端口节点表示。每个端口节点包含一个端点子节点，用于连接到该端口的一个或多个远程设备端口。这意味着单个端口可以连接到一个或多个远程设备的端口，并且每个链接必须由一个端点子节点表示。现在，如果一个设备节点包含多个端口，如果一个端口有多个端点，或者一个端口节点需要连接到选定的硬件接口，那么使用`#address-cells`、`#size-cells`和`reg`属性的流行方案用于对节点进行编号。
- en: 'The following excerpt shows how to use the `#address-cells`, `#size-cells`,
    and `reg` properties to handle those cases:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下摘录显示了如何使用`#address-cells`、`#size-cells`和`reg`属性来处理这些情况：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Complete documentation of this can be found in `Documentation/devicetree/bindings/graph.txt`.
    Now that we are done with port and endpoint representation, we need to learn how
    to link each with the other, as explained in the next section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的文档可以在`Documentation/devicetree/bindings/graph.txt`中找到。现在我们已经完成了端口和端点的表示，我们需要学习如何将它们彼此连接，如下一节所述。
- en: Endpoint linking
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端点链接
- en: 'For two endpoints to be linked together, each of them should contain a `remote-endpoint`
    `phandle` property that points to the corresponding endpoint in the port of the
    remote device. In turn, the remote endpoint should contain a `remote-endpoint`
    property. Two endpoints with their `remote-endpoint` phandles pointing at each
    other form a link between the containing ports, as in the following example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将两个端点连接在一起，每个端点都应包含一个指向远程设备端口对应端点的“remote-endpoint”“phandle”属性。反过来，远程端点应包含一个“remote-endpoint”属性。两个端点的“remote-endpoint”
    phandles相互指向形成包含端口之间的链接，如下例所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Introducing the graph binding concept without talking at all about its API would
    be a waste of time. Let's jump to the API that comes along with this new binding
    method.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在完全不谈论其API的情况下介绍图绑定概念将是浪费时间。让我们跳到与这种新绑定方法一起使用的API。
- en: The V4L2 async and graph-oriented API
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: V4L2异步和面向图形的API
- en: This section heading must not mislead you since graph binding is not just intended
    for the V4L2 subsystem. The Linux `DRM` subsystem also takes advantage of it.
    That being said, the async framework heavily relies on the device tree to describe
    either media devices along with their endpoints and connections, or links between
    those endpoints along with their bus configuration properties.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分的标题不应误导你，因为图绑定不仅仅是为了V4L2子系统。Linux `DRM`子系统也利用了它。也就是说，异步框架严重依赖设备树来描述媒体设备及其端点和连接，或者端点之间的链接以及它们的总线配置属性。
- en: From the DT (of_graph_*) API to the generic fwnode graph API (fwnode_graph_*)
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从DT（of_graph_*）API到通用fwnode图API（fwnode_graph_*）
- en: 'The `fwnode` graph API is a successful attempt at changing the device tree-only-based
    OF graph API to a generic API, merging both ACPI and device tree OF APIs together
    in order to have unified and generic APIs. This extends the concept of the graph
    with ACPI by using the same APIs. By having a look at the `struct device_node`
    and `struct acpi_device` structures, you can see the members they have in common:
    `struct fwnode_handle fwnode`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`fwnode`图API是将仅基于设备树的OF图API更改为通用API的成功尝试，将ACPI和设备树OF API合并在一起，以获得统一和通用的API。这通过使用相同的API扩展了ACPI的图概念。通过查看`struct
    device_node`和`struct acpi_device`结构，您可以看到它们共同具有的成员：`struct fwnode_handle fwnode`：'
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding excerpt represents a device node from a device tree point of
    view, while the following is related to ACPI:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的摘录代表了从设备树角度来看的设备节点，而以下内容与ACPI相关：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `fwnode` member, which is of the `struct fwnode_handle` type, is a lower
    level and generic data structure abstracting either `device_node` or `acpi_device`
    as they both inherit from this data structure. This makes `struct fwnode_handle`
    a good client for graph API homogenization so that an endpoint (by means of its
    field of the `fwnode_handle` type) can refer to either an ACPI device or an OF-based
    device. This abstraction model is now used in graph APIs, allowing us to abstract
    an endpoint by a generic data structure (`struct fwnode_endpoint`, described as
    follows) embedding a pointer to `struct fwnode_handle`, which may refer to either
    an ACPI or OF node. In addition to the genericity, this allows the underlying
    sub-device to this endpoint to be either ACPI- or OF-based:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`fwnode`成员是`struct fwnode_handle`类型的，它是一个较低级别和通用的数据结构，抽象出`device_node`或`acpi_device`，因为它们都继承自这个数据结构。这使得`struct
    fwnode_handle`成为图API同质化的良好客户端，以便端点（通过其`fwnode_handle`类型的字段）可以引用ACPI设备或基于OF的设备。这种抽象模型现在用于图API中，允许我们通过一个通用数据结构（如下所述的`struct
    fwnode_endpoint`）来抽象一个端点，该数据结构嵌入了指向`struct fwnode_handle`的指针，该指针可以引用ACPI或OF节点。除了通用性，这还允许与此端点相关的子设备可以是基于ACPI或OF的：'
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This structure deprecates the old `struct of_endpoint` structure and the member
    of type `device_node*` leaves room for a member of the `fwnode_handle*` type.
    In the preceding structure, `local_fwnode` points to the related firmware node,
    `port` is the port number (that is, it corresponds to `0` in `port@0` or `1` in
    `port@1`), and `id` is the index of this endpoint from within the port (that is,
    it corresponds to the `0` in `endpoint@0` and to the `1` in `endpoint@1`).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构使旧的`struct of_endpoint`结构过时，并且类型为`device_node*`的成员留出了`fwnode_handle*`类型的成员。在前面的结构中，`local_fwnode`指向相关的固件节点，`port`是端口号（即对应于`port@0`中的`0`或`port@1`中的`1`），`id`是端点在端口内的索引（即对应于`endpoint@0`中的`0`和`endpoint@1`中的`1`）。
- en: 'The V4L2 framework uses this model for abstracting V4L2-related endpoints by
    means of `struct v4l2_fwnode_endpoint`, which is built on top of `fwnode_endpoint`,
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: V4L2框架使用这个模型来通过`struct v4l2_fwnode_endpoint`对V4L2相关的端点进行抽象，该结构是建立在`fwnode_endpoint`之上的。
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This structure deprecates and replaces `struct v4l2_of_endpoint` since kernel
    v4.13, formerly used by V4L2 to represent endpoint nodes in the era of the `base`
    represents the `struct fwnode_endpoint` structure of the underlying ACPI or device
    node. Other fields are V4L2-related, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构自内核v4.13以来就已经过时并取代了`struct v4l2_of_endpoint`，以前被V4L2用来表示`base`代表底层ACPI或设备节点的`struct
    fwnode_endpoint`结构。其他字段都是与V4L2相关的，如下：
- en: '`bus_type` is the type of media bus through which this sub-device streams data.
    The value of this member determines which underlying bus structure should be filled
    with the parsed bus properties from the `fwnode` endpoint (either device tree
    or ACPI). Possible values are listed in `enum v4l2_mbus_type`, as follows:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bus_type`是此子设备流数据的媒体总线类型。此成员的值确定应该用`fwnode`端点（设备树或ACPI）中解析的总线属性填充哪个底层总线结构。可能的值在`enum
    v4l2_mbus_type`中列出，如下：'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`bus` is the structure representing the media bus itself. Possible values are
    already present in the union, and `bus_type` determines which one to consider.
    These bus structures are all defined in `include/media/v4l2-fwnode.h`.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bus`是表示媒体总线本身的结构。可能的值已经存在于联合体中，`bus_type`确定要考虑哪一个。这些总线结构都在`include/media/v4l2-fwnode.h`中定义。'
- en: '`link_frequencies` is the list of frequencies supported by this link.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`link_frequencies`是支持此链接的频率列表。'
- en: '`nr_of_link_frequencies` is the number of elements in `link_frequencies`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nr_of_link_frequencies`是`link_frequencies`中元素的数量。'
- en: Important note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In kernel v4.19, the `bus_type` member is exclusively set according to the `bus-type`
    property in `fwnode`. The driver can check the read value and adapt its behavior.
    This means the V4L2 `fwnode` API will always base its parsing strategy on this
    `fwnode` property. However, as of kernel v5.0, drivers have to set this member
    to an expected bus type (prior to calling the parsing function), which will be
    compared to the value of the `bus-type` property read in `fwnode` and will raise
    an error if they don't match. If the bus type is not known or if the driver can
    deal with several bus types, the `V4L2_MBUS_UNKNOWN` value has to be used. This
    value is also part of `enum v4l2_mbus_type`, as of kernel v5.0.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核v4.19中，`bus_type`成员是根据`fwnode`中的`bus-type`属性来设置的。驱动程序可以检查读取的值并调整其行为。这意味着V4L2
    `fwnode` API将始终基于此`fwnode`属性来解析策略。然而，从内核v5.0开始，驱动程序必须将此成员设置为预期的总线类型（在调用解析函数之前），然后将其与在`fwnode`中读取的`bus-type`属性的值进行比较，如果它们不匹配，则会引发错误。如果总线类型未知，或者驱动程序可以处理多种总线类型，则必须使用`V4L2_MBUS_UNKNOWN`值。从内核v5.0开始，此值也是`enum
    v4l2_mbus_type`的一部分。
- en: In the kernel code, you may find the `enum v4l2_fwnode_bus_type` enum type.
    This is a V4L2 `fwnode` local enum type that is the counterpart of the global
    `enum v4l2_mbus_type` enum type and whose values map each other. Their respective
    values are kept in sync as the code evolves.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核代码中，您可能会找到`enum v4l2_fwnode_bus_type`枚举类型。这是V4L2 `fwnode`本地枚举类型，是全局`enum
    v4l2_mbus_type`枚举类型的对应物，它们的值相互映射。它们各自的值会随着代码的演变而保持同步。
- en: The V4L2-related binding then requires additional properties. Part of these
    properties is used to build `v4l2_fwnode_endpoint`, while the other part is used
    to build the underlying `bus` (the media bus, actually) structure. All are described
    in a dedicated and video-related binding documentation, `Documentation/devicetree/bindings/media/video-
    interfaces.txt`, which I strongly recommend checking out.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，V4L2相关的绑定需要额外的属性。这些属性的一部分用于构建`v4l2_fwnode_endpoint`，而另一部分用于构建底层的`bus`（实际上是媒体总线）结构。所有这些都在专门的与视频相关的绑定文档`Documentation/devicetree/bindings/media/video-interfaces.txt`中描述，我强烈建议查看。
- en: 'The following is a typical binding between a bridge (`isc`) and a sensor sub-device
    (`mt9v032`):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是桥接（`isc`）和传感器子设备（`mt9v032`）之间的典型绑定：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding binding, `hsync-active`, `vsync-active`, `link-frequencies`,
    and `pclk- sample` are all V4L2-specific properties and describe the media bus.
    Their values are not coherent here and do not really make sense but fit well for
    our learning purpose. This excerpt shows well the concepts of endpoint and remote
    endpoint; the use of `struct v4l2_fwnode_endpoint` is discussed in detail in the
    *The Linux media controller framework* section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的绑定中，`hsync-active`、`vsync-active`、`link-frequencies`和`pclk-sample`都是V4L2特定的属性，描述了媒体总线。它们的值在这里并不一致，并且实际上没有意义，但非常适合我们的学习目的。这段摘录很好地展示了端点和远程端点的概念；`struct
    v4l2_fwnode_endpoint`的使用在*Linux媒体控制器框架*部分中有详细讨论。
- en: Important note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The part of V4L2 dealing with the `fwnode` API is called the `v4l2_fwnode_`,
    while the second's API set is prefixed with `v4l2_of_`. Do note that in OF-only-based
    APIs, an endpoint is represented by `struct of_endpoint`, and a V4L2-related endpoint
    is represented by `struct v4l2_of_endpoint`. There are APIs that allow switching
    from OF- to `fwnode`-based models and vice versa.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`fwnode` API的V4L2部分称为`v4l2_fwnode_`，而第二个API集以`v4l2_of_`为前缀。请注意，在仅基于OF的API中，端点由`struct
    of_endpoint`表示，而与V4L2相关的端点由`struct v4l2_of_endpoint`表示。有一些API允许从基于OF的模型切换到基于`fwnode`的模型，反之亦然。
- en: V4L2 `fwnode` and V4L2 OF are fully interoperable. For example, a sub-device
    driver using V4L2 `fwnode` will work with a media device driver using V4L2 OF
    without any effort, and vice versa! However, new drivers must use the `fwnode`
    API, including `#include <media/v4l2- fwnode.h>`, which should replace `#include
    <media/v4l2-of.h>` in the old driver when switching to the `fwnode` API.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: V4L2 `fwnode`和V4L2 OF完全可互操作。例如，使用V4L2 `fwnode`的子设备驱动程序将与使用V4L2 OF的媒体设备驱动程序无需任何努力即可工作，反之亦然！但是，新驱动程序必须使用`fwnode`
    API，包括`#include <media/v4l2- fwnode.h>`，在切换到`fwnode` API时应替换旧驱动程序中的`#include <media/v4l2-of.h>`。
- en: 'That being said, `struct fwnode_endpoint`, which was discussed earlier, is
    just for showing the underlying mechanisms. We could have completely skipped it
    since only the core deals with this data structure. For a more generic approach,
    instead of using `struct device_node` to refer to the device''s firmware node,
    you''re better off using the new `struct fwnode_handle`. This definitely makes
    sure that DT and ACPI bindings are compatible/interoperable using the same code
    in the driver. The following is a short excerpt of how changes should look in
    new drivers:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，前面讨论过的`struct fwnode_endpoint`仅用于显示底层机制。我们完全可以跳过它，因为只有核心处理此数据结构。为了更通用的方法，您最好使用新的`struct
    fwnode_handle`，而不是使用`struct device_node`来引用设备的固件节点。这绝对确保了DT和ACPI绑定在驱动程序中使用相同的代码时是兼容/可互操作的。以下是新驱动程序中更改应该如何看起来的简短摘录：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Some of the common `fwnode` node-related APIs are as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的`fwnode`节点相关的API如下：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The aforementioned APIs have the following description:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述API具有以下描述：
- en: '`fwnode_get_parent()` returns the parent handle of the node whose `fwnode`
    value is given in an argument, or `NULL` otherwise.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fwnode_get_parent()` 返回给定参数中`fwnode`值的节点的父句柄，否则返回`NULL`。'
- en: '`fwnode_get_next_child_node()` takes a parent node as its first argument and
    returns the next child (or `NULL` otherwise) after a given child (given as the
    second argument) in this parent. If `child` (the second argument) is `NULL`, then
    the first child of this parent will be returned.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fwnode_get_next_child_node()` 以其父节点作为第一个参数，并在此父节点中给定子节点（作为第二个参数）之后返回下一个子节点（或`NULL`）。如果`child`（第二个参数）为`NULL`，则将返回此父节点的第一个子节点。'
- en: '`fwnode_get_next_available_child_node()` is the same as `fwnode_get_next_child_node()`
    but makes sure that the device actually exists (has been probed successfully)
    prior to returning the `fwnode` handle.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fwnode_get_next_available_child_node()` 与`fwnode_get_next_child_node()`相同，但确保设备在返回`fwnode`句柄之前实际存在（已成功探测）。'
- en: '`fwnode_for_each_child_node()` iterates over the child in a given node (the
    first argument) and the second argument is used as an iterator.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fwnode_for_each_child_node()` 遍历给定节点（第一个参数）中的子节点，并使用第二个参数作为迭代器。'
- en: '`fwnode_for_each_available_child_node` is the same as `fwnode_for_each_child_node()`
    but iterates only over nodes whose device is actually present on the system.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fwnode_for_each_available_child_node` 与`fwnode_for_each_child_node()`相同，但只遍历实际存在于系统上的设备的节点。'
- en: '`fwnode_get_named_child_node()` gets a child in a given node by its name.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fwnode_get_named_child_node()` 通过名称获取给定节点中的子节点。'
- en: '`fwnode_handle_get()` obtains a reference to a device node and `fwnode_handle_put()`
    drops this reference.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fwnode_handle_get()` 获取对设备节点的引用，`fwnode_handle_put()` 释放此引用。'
- en: 'Some of the `fwnode`-related properties are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一些`fwnode`相关的属性如下：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Both property- and node-related `fwnode` APIs are available in `include/linux/property.h`.
    However, there are helpers that allow switching back and forth between OF, ACPI,
    and `fwnode`. The following is a short example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`fwnode`属性和节点相关的API都在`include/linux/property.h`中可用。但是，有一些辅助程序允许在OF、ACPI和`fwnode`之间来回切换。以下是一个简短的示例：'
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, and most important for us, is the `fwnode` graph API. In the following
    code snippet, we enumerate the most important function of this API:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对我们来说最重要的是`fwnode`图形API。在以下代码片段中，我们列举了此API的最重要功能：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Though the preceding function names talk about themselves, the following are
    better descriptions of what they do:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的函数名称已经说明了它们的作用，但以下是更好的描述：
- en: '`fwnode_graph_get_next_endpoint()` returns the next endpoint (or `NULL` otherwise)
    in a given node (the first argument) after a previous endpoint (`prev`, the second
    argument). If `prev` is `NULL`, then the first endpoint is returned. This function
    obtains a reference to the returned endpoint that must be dropped after use. See
    `fwnode_handle_put()`.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fwnode_graph_get_next_endpoint()` 返回给定节点（第一个参数）中的下一个端点（或`NULL`），在先前的端点（第二个参数`prev`）之后。如果`prev`为`NULL`，则返回第一个端点。此函数获取对返回的端点的引用，必须在使用后放弃。参见`fwnode_handle_put()`。'
- en: '`fwnode_graph_get_port_parent()` returns the parent of the port node given
    in the argument.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fwnode_graph_get_port_parent()` 返回给定参数中端口节点的父节点。'
- en: '`fwnode_graph_get_remote_port_parent()` returns the firmware node of the remote
    device containing the endpoint whose firmware node is given through the `fwnode`
    argument.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fwnode_graph_get_remote_port_parent()` 返回包含通过`fwnode`参数给定的固件节点的端点的远程设备的固件节点。'
- en: '`fwnode_graph_get_remote_endpoint()` returns the firmware node of the remote
    endpoint corresponding to a local endpoint whose firmware node is given through
    the `fwnode` argument.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fwnode_graph_get_remote_endpoint()` 返回与通过`fwnode`参数给定的本地端点对应的远程端点的固件节点。'
- en: '`fwnode_graph_parse_endpoint()` parses common endpoint node properties in `fwnode`
    (the first argument) representing a graph endpoint node and stores the information
    in `endpoint` (the second and output argument). The V4L2 firmware node API heavily
    uses this.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fwnode_graph_parse_endpoint()` 解析`fwnode`中表示图端点节点的常见端点节点属性（第一个参数），并将信息存储在`endpoint`中（第二个和输出参数）。V4L2固件节点API大量使用这个功能。'
- en: The V4L2 firmware node (V4L2 fwnode) API
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: V4L2固件节点（V4L2 fwnode）API
- en: 'The main data structure in the V4L2 fwnode API is `struct v4l2_fwnode_endpoint`.
    This structure is nothing but `struct fwnode_handle` augmented with some V4L2-related
    properties. However, there is a V4L2-related fwnode graph function that it is
    worth talking about here: `v4l2_fwnode_endpoint_parse()`. This function''s prototype
    is declared `include/media/v4l2-fwnode.h`, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: V4L2 fwnode API中的主要数据结构是`struct v4l2_fwnode_endpoint`。这个结构实际上就是`struct fwnode_handle`，增加了一些与V4L2相关的属性。然而，有一个与V4L2相关的fwnode图函数值得在这里谈论：`v4l2_fwnode_endpoint_parse()`。该函数的原型在`include/media/v4l2-fwnode.h`中声明如下：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Given `fwnode_handle` (the first argument in the preceding function) of an endpoint,
    you can use `v4l2_fwnode_endpoint_parse()` to parse all the fwnode node properties.
    This function also recognizes and takes care of the V4L2-specific properties,
    which are, if you remember, those documented in `Documentation/devicetree/bindings/media/video-interfaces.txt`.
    `v4l2_fwnode_endpoint_parse()` uses `fwnode_graph_parse_endpoint()` to parse common
    fwnode properties and uses V4L2-specific parser helpers to parse V4L2-related
    properties. It returns `0` on success or a negative error code on failure.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 给定端点的`fwnode_handle`（在前面的函数中的第一个参数），您可以使用`v4l2_fwnode_endpoint_parse()`来解析所有fwnode节点属性。该函数还识别并处理V4L2特定的属性，这些属性是在`Documentation/devicetree/bindings/media/video-interfaces.txt`中记录的。`v4l2_fwnode_endpoint_parse()`使用`fwnode_graph_parse_endpoint()`来解析常见的fwnode属性，并使用V4L2特定的解析器助手来解析与V4L2相关的属性。它在成功时返回`0`，在失败时返回负错误代码。
- en: 'If we consider the `mt9v032` CMOS image sensor node in `dts`, we can have the
    following code in the `probe` method:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑`dts`中的`mt9v032` CMOS图像传感器节点，我们可以在`probe`方法中有以下代码：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code shows how you use the fwnode API, as well as its V4L2 version,
    for accessing node and endpoint properties. There are, however, V4L2-specific
    properties being parsed upon the `v4l2_fwnode_endpoint_parse()` call. These properties
    describe the so-called **media bus** through which data is carried from one interface
    to another. We will discuss this in the next section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了如何使用fwnode API及其V4L2版本来访问节点和端点属性。然而，在`v4l2_fwnode_endpoint_parse()`调用时，也会解析特定于V4L2的属性。这些属性描述了所谓的**媒体总线**，通过这个总线，数据从一个接口传输到另一个接口。我们将在下一节讨论这个问题。
- en: V4L2 fwnode or media bus types
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: V4L2 fwnode或媒体总线类型
- en: Most media devices support a particular media bus type. While endpoints are
    linked together, they are actually connected through buses, whose properties need
    to be described to the V4L2 framework. For V4L2 to be able to find this information,
    it is provided as properties in the device's fwnode (DT or ACPI). As these are
    specific properties, the V4L2 fwnode API is able to recognize and parse them.
    Each bus has its specificities and properties.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数媒体设备支持特定的媒体总线类型。当端点链接在一起时，它们实际上是通过总线连接的，其属性需要在V4L2框架中描述。为了使V4L2能够找到这些信息，它作为设备的fwnode（DT或ACPI）中的属性提供。由于这些是特定的属性，V4L2
    fwnode API能够识别和解析它们。每个总线都有其特定性和属性。
- en: 'First of all, let''s have a look at the currently supported buses, along with
    their data structures:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下当前支持的总线，以及它们的数据结构：
- en: '`struct v4l2_fwnode_bus_mipi_csi1`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct v4l2_fwnode_bus_mipi_csi1`。'
- en: '`struct v4l2_fwnode_bus_mipi_csi1` too.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct v4l2_fwnode_bus_mipi_csi1`也是如此。'
- en: '`HSYNC` and `VSYNC` signals. The structure used to represent this bus is `struct
    v4l2_fwnode_bus_parallel`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HSYNC`和`VSYNC`信号。用于表示这个总线的结构是`struct v4l2_fwnode_bus_parallel`。'
- en: '`HSYNC`, `VSYNC`, and `BLANK`) in the data. These buses have a reduced number
    of pins compared to the standard parallel bus. This framework uses `struct v4l2_fwnode_bus_parallel`
    to represent this bus.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HSYNC`、`VSYNC`和`BLANK`）的数据。与标准并行总线相比，这些总线的引脚数量减少。该框架使用`struct v4l2_fwnode_bus_parallel`来表示这个总线。'
- en: '`struct v4l2_fwnode_bus_mipi_csi2` structure. However, this data structure
    does not differentiate between D-PHY and C-PHY. This lack of differentiation is
    addressed as of kernel v5.0.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct v4l2_fwnode_bus_mipi_csi2`结构。但是，这个数据结构没有区分D-PHY和C-PHY。这种缺乏区分在内核v5.0中得到了解决。'
- en: As we will see later in the chapter, in the *The concept of a media bus* section,
    this concept of a bus can be used to detect compatibility between a local endpoint
    and its remote counterpart so that two sub-devices can't be linked together if
    they don't have the same bus properties, which makes complete sense.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章后面的*媒体总线的概念*部分中看到的，总线的这个概念可以用来检测本地端点与其远程对应端点之间的兼容性，以便如果它们没有相同的总线属性，两个子设备就不能链接在一起，这是完全合理的。
- en: 'Earlier, in the *The V4L2 fwnode API* section, we saw that `v4l2_fwnode_endpoint_parse()`
    is responsible for parsing the endpoint''s fwnode and filling the appropriate
    bus structure. This function first calls `fwnode_graph_parse_endpoint()` in order
    to parse the common fwnode graph-related properties, and then checks the value
    of the `bus-type` property, as follows, in order to determine the appropriate
    `v4l2_fwnode_endpoint.bus` data type:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在*V4L2 fwnode API*部分中，我们看到`v4l2_fwnode_endpoint_parse()`负责解析端点的fwnode并填充适当的总线结构。该函数首先调用`fwnode_graph_parse_endpoint()`来解析常见的fwnode图相关属性，然后检查`bus-type`属性的值，如下所示，以确定适当的`v4l2_fwnode_endpoint.bus`数据类型：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Depending on this value, a bus data structure will be chosen. The following
    are expected possible values from the `fwnode` device:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个值，将选择一个总线数据结构。以下是来自`fwnode`设备的预期可能值：
- en: '`0`: This means auto-detect. The core will try to guess the bus type according
    to the properties present in the fwnode (MIPI CSI-2 D-PHY, parallel, or BT656).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：这意味着自动检测。核心将尝试根据fwnode中存在的属性来猜测总线类型（MIPI CSI-2 D-PHY、并行或BT656）。'
- en: '`1`: This means MIPI CSI-2 C-PHY.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：这意味着MIPI CSI-2 C-PHY。'
- en: '`2`: This means MIPI CSI-1.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：这意味着MIPI CSI-1。'
- en: '`3`: This means CCP2.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`：这意味着CCP2。'
- en: 'For the CPP2 bus, for example, the device''s fwnode would contain the following
    line:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于CPP2总线，设备的fwnode将包含以下行：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Important note
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As of kernel v5.0, drivers can specify the expected bus type in the `bus_type`
    member of `v4l2_fwnode_endpoint` prior to giving it as a second argument to `v4l2_fwnode_endpoint_parse()`.
    This way, parsing will fail if the value returned by the preceding `fwnode_property_read_u32`
    does not match the expected one, except if the expected bus type was set to `V4L2_MBUS_UNKNOWN`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核v5.0开始，驱动程序可以在`v4l2_fwnode_endpoint`的`bus_type`成员中指定预期的总线类型，然后将其作为第二个参数提供给`v4l2_fwnode_endpoint_parse()`。这样，如果前面的`fwnode_property_read_u32`返回的值与预期值不匹配，解析将失败，除非将预期的总线类型设置为`V4L2_MBUS_UNKNOWN`。
- en: BT656 and parallel buses
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: BT656和并行总线
- en: 'Those bus types are all represented by `struct v4l2_fwnode_bus_parallel`, as
    follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些总线类型都由`struct v4l2_fwnode_bus_parallel`表示，如下所示：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding data structure, `flags` represents the flags of the bus. Those
    flags will be set according to the properties present in the device''s firmware
    node. `bus_width` represents the number of data lines actively used, not necessarily
    the total number of lines of the bus. `data_shift` is used to specify which data
    lines are really used by specifying the number of lines to skip prior to reaching
    the first active data line. The following are the binding properties of these
    media buses, which are used to set up `struct v4l2_fwnode_bus_parallel`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述数据结构中，`flags`表示总线的标志。这些标志将根据设备固件节点中存在的属性设置。`bus_width`表示实际使用的数据线数量，不一定是总线的总线数量。`data_shift`用于指定实际使用的数据线，通过指定要跳过的线路数量来实现。以下是这些媒体总线的绑定属性，用于设置`struct
    v4l2_fwnode_bus_parallel`：
- en: '`hsync-active`: Active state of the HSYNC signal; `0`/`1` for `LOW`/`HIGH`,
    respectively. If this property''s value is `0`, then the `V4L2_MBUS_HSYNC_ACTIVE_LOW`
    flag is set in the `flags` member. Any other value will set the `V4L2_MBUS_HSYNC_ACTIVE_HIGH`
    flag instead.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hsync-active`：HSYNC信号的活动状态；分别为`LOW`/`HIGH`的`0`/`1`。如果此属性的值为`0`，则在`flags`成员中设置`V4L2_MBUS_HSYNC_ACTIVE_LOW`标志。任何其他值将设置`V4L2_MBUS_HSYNC_ACTIVE_HIGH`标志。'
- en: '`vsync-active`: Active state of the VSYNC signal; `0`/`1` for `LOW`/`HIGH`,
    respectively. If this property''s value is `0`, then the `V4L2_MBUS_VSYNC_ACTIVE_LOW`
    flag is set in the `flags` member. Any other value will set the `V4L2_MBUS_VSYNC_ACTIVE_HIGH`
    flag instead.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vsync-active`：VSYNC信号的活动状态；分别为`LOW`/`HIGH`的`0`/`1`。如果此属性的值为`0`，则在`flags`成员中设置`V4L2_MBUS_VSYNC_ACTIVE_LOW`标志。任何其他值将设置`V4L2_MBUS_VSYNC_ACTIVE_HIGH`标志。'
- en: '`field-even-active`: The field signal level during the even field data transmission.
    This is the same as the preceding, but the concerned flags are `V4L2_MBUS_FIELD_EVEN_HIGH`
    and `V4L2_MBUS_FIELD_EVEN_LOW`.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`field-even-active`：在偶场数据传输期间的场信号电平。这与前面的情况相同，但相关标志为`V4L2_MBUS_FIELD_EVEN_HIGH`和`V4L2_MBUS_FIELD_EVEN_LOW`。'
- en: '`pclk-sample`: Sample data on the rising (`1`) or falling (`0`) edge of the
    pixel clock signal, `V4L2_MBUS_PCLK_SAMPLE_RISING` and `V4L2_MBUS_PCLK_SAMPLE_FALLING`.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pclk-sample`：在像素时钟信号的上升（`1`）或下降（`0`）沿上采样数据，`V4L2_MBUS_PCLK_SAMPLE_RISING`和`V4L2_MBUS_PCLK_SAMPLE_FALLING`。'
- en: '`data-active`: Similar to `HSYNC` and `VSYNC`, specifies data line polarity,
    `V4L2_MBUS_DATA_ACTIVE_HIGH` and `V4L2_MBUS_DATA_ACTIVE_LOW`.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data-active`：类似于`HSYNC`和`VSYNC`，指定数据线极性，`V4L2_MBUS_DATA_ACTIVE_HIGH`和`V4L2_MBUS_DATA_ACTIVE_LOW`。'
- en: '`slave-mode`: This is a Boolean property whose presence indicates that the
    link is run in slave mode, and the `V4L2_MBUS_SLAVE` flag is set. Otherwise, the
    `V4L2_MBUS_MASTER` flag will be set.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slave-mode`：这是一个布尔属性，其存在表示链接以从模式运行，并设置了`V4L2_MBUS_SLAVE`标志。否则，将设置`V4L2_MBUS_MASTER`标志。'
- en: '`data-enable-active`: Similar to `HSYNC` and `VSYNC`, specifies the data-enable
    signal polarity.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data-enable-active`：类似于`HSYNC`和`VSYNC`，指定数据使能信号的极性。'
- en: '`bus-width`: This property concerns parallel buses only and represents the
    number of data lines actively used. The `V4L2_MBUS_DATA_ENABLE_HIGH` or `V4L2_MBUS_DATA_ENABLE_LOW`
    flags are set accordingly.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bus-width`：此属性仅涉及并行总线，并表示实际使用的数据线数量。相应地设置`V4L2_MBUS_DATA_ENABLE_HIGH`或`V4L2_MBUS_DATA_ENABLE_LOW`标志。'
- en: '`data-shift`: On parallel data buses where `bus-width` is used to specify the
    number of data lines, this property can be used to specify which data lines are
    really used; for example, `bus-width=<8>; data-shift=<2>;` means that lines 9:2
    are used.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data-shift`：在并行数据总线上，`bus-width`用于指定实际使用的数据线数量，此属性可用于指定实际使用的数据线；例如，`bus-width=<8>;
    data-shift=<2>;`表示使用线路9:2。'
- en: '`sync-on-green-active`: The active state of the `0`/`1` for `LOW`/`HIGH`, respectively.
    The `V4L2_MBUS_VIDEO_SOG_ACTIVE_HIGH` or `V4L2_MBUS_VIDEO_SOG_ACTIVE_LOW` flags
    are set accordingly.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sync-on-green-active`：`0`/`1`的活动状态分别为`LOW`/`HIGH`。相应地设置`V4L2_MBUS_VIDEO_SOG_ACTIVE_HIGH`或`V4L2_MBUS_VIDEO_SOG_ACTIVE_LOW`标志。'
- en: The type of these buses is either `V4L2_MBUS_PARALLEL` or `V4L2_MBUS_BT656`.
    The underlying function responsible for parsing these buses is `v4l2_fwnode_endpoint_parse_parallel_bus()`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这些总线的类型可以是`V4L2_MBUS_PARALLEL`或`V4L2_MBUS_BT656`。负责解析这些总线的底层函数是`v4l2_fwnode_endpoint_parse_parallel_bus()`。
- en: MIPI CSI-2 bus
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MIPI CSI-2总线
- en: 'This is version 2 of MIPI Alliance''s CSI bus. This bus involves two PHYs:
    either D- PHY or C-PHY. D-PHY has been around for a while and targets cameras,
    displays, and lower-speed applications. C-PHY is a newer and more complex PHY,
    where a clock is embedded into the data, rendering a separate clock lane unnecessary.
    It has fewer wires, a smaller number of lanes, and lower power consumption, and
    can achieve a higher data rate compared to D-PHY. C-PHY provides high throughput
    performance over bandwidth-limited channels.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是MIPI联盟的CSI总线的第2版。该总线涉及两个PHY：D-PHY或C-PHY。 D-PHY已经存在一段时间，针对相机、显示器和低速应用。 C-PHY是一种更新更复杂的PHY，其中时钟嵌入到数据中，使得不需要单独的时钟通道。它的线路更少，通道数更少，功耗更低，并且与D-PHY相比可以实现更高的数据速率。
    C-PHY在带宽受限的通道上提供高吞吐性能。
- en: 'Both C-PHY- and D-PHY-enabled buses are represented using one data structure,
    `struct` `v4l2_fwnode_bus_mipi_csi2`, as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: C-PHY和D-PHY启用的总线都使用一个数据结构`struct v4l2_fwnode_bus_mipi_csi2`表示，如下所示：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding block, `flags` represents the flags of the bus and will be
    set according to the properties present in the firmware node:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的块中，`flags`表示总线的标志，并将根据固件节点中存在的属性进行设置：
- en: '`data-lanes` is an array of physical data lane indexes.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data-lanes`是物理数据线索引的数组。'
- en: '`lane-polarities`: This property is valid for serial busses only. It is an
    array of polarities of the lanes, starting from the clock lane and followed by
    the data lanes, in the same order as in the `data-lanes` property. Valid values
    are `0` (normal) and `1` (inverted). The length of this array should be the combined
    length of the `data-lanes` and `clock-lanes` properties. Valid values are `0`
    (normal) and `1` (inverted). If the `lane-polarities` property is omitted, the
    value must be interpreted as `0` (normal).'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lane-polarities`：此属性仅适用于串行总线。这是一个从时钟线开始，然后是数据线的极性数组，顺序与`data-lanes`属性相同。有效值为`0`（正常）和`1`（反转）。此数组的长度应为`data-lanes`和`clock-lanes`属性的组合长度。有效值为`0`（正常）和`1`（反转）。如果省略了`lane-polarities`属性，则必须将值解释为`0`（正常）。'
- en: '`clock-lanes` is the physical lane index of the clock lane. This is the clock
    lane position.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clock-lanes`是时钟线的物理线索引。这是时钟线的位置。'
- en: '`clock-noncontinuous`: If present, the `V4L2_MBUS_CSI2_NONCONTINUOUS_CLOCK`
    flag is set. Otherwise, `V4L2_MBUS_CSI2_CONTINUOUS_CLOCK` is set.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clock-noncontinuous`：如果存在，则设置`V4L2_MBUS_CSI2_NONCONTINUOUS_CLOCK`标志。否则，设置`V4L2_MBUS_CSI2_CONTINUOUS_CLOCK`。'
- en: These buses have the `V4L2_MBUS_CSI2` type. Until Linux kernel v4.20, there
    were no differences between C-PHY- and D-PHY-enabled CSI buses. However as of
    Linux kernel v5.0, this difference has been introduced and `V4L2_MBUS_CSI2` has
    been replaced with either `V4L2_MBUS_CSI2_DPHY` or `V4L2_MBUS_CSI2_CPHY`, respectively,
    for D-PHY- or C-PHY-enabled buses.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些总线具有`V4L2_MBUS_CSI2`类型。直到Linux内核v4.20，C-PHY和D-PHY启用的CSI总线之间没有区别。但是，从Linux内核v5.0开始，引入了这种差异，并且`V4L2_MBUS_CSI2`已被分别替换为`V4L2_MBUS_CSI2_DPHY`或`V4L2_MBUS_CSI2_CPHY`，用于D-PHY或C-PHY启用的总线。
- en: 'The underlying function responsible for parsing these buses is `v4l2_fwnode_endpoint_parse_csi2_bus()`.
    An example is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 负责解析这些总线的基础功能是`v4l2_fwnode_endpoint_parse_csi2_bus()`。一个示例如下：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: CPP2 and MIPI CSI-1 buses
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: CPP2和MIPI CSI-1总线
- en: 'These are older single data lane serial buses. Their type corresponds to either
    `V4L2_FWNODE_BUS_TYPE_CCP2` or `V4L2_FWNODE_BUS_TYPE_CSI1`. The kernel uses `struct
    v4l2_fwnode_bus_mipi_csi1` to represent these buses:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是较旧的单数据线串行总线。它们的类型对应于`V4L2_FWNODE_BUS_TYPE_CCP2`或`V4L2_FWNODE_BUS_TYPE_CSI1`。内核使用`struct
    v4l2_fwnode_bus_mipi_csi1`来表示这些总线：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following are the meanings of the elements in this structure:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此结构中元素的含义：
- en: '`clock-inv`: The polarity of the clock/strobe signal (false means not inverted,
    true means inverted). `0` means false, and other values mean true.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clock-inv`：时钟/闪光信号的极性（false表示未反转，true表示反转）。`0`表示false，其他值表示true。'
- en: '`strobe`: False – data/clock, true – data/strobe.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strobe`：False - 数据/时钟，true - 数据/闪光灯。'
- en: '`data-lanes`: The number of the data lanes.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data-lanes`：数据线的数量。'
- en: '`clock-lanes`: The number of the clock lanes.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clock-lanes`：时钟线的数量。'
- en: '`lane-polarities`: This is the same as the preceding, but since CPP2 and MIPI
    CSI-1 are single data serial buses, the array can have only two entries: the polarities
    of the clock (index `0`) and data lanes (index `1`).'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lane-polarities`：这与前面相同，但由于CPP2和MIPI CSI-1是单数据串行总线，因此数组只能有两个条目：时钟（索引`0`）和数据线（索引`1`）的极性。'
- en: The preceding data structure is filled with `v4l2_fwnode_endpoint_parse_csi1_bus()`
    after parsing the given node.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析给定节点后，前面的数据结构由`v4l2_fwnode_endpoint_parse_csi1_bus()`填充。
- en: Bus guessing
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 总线猜测
- en: Specifying the bus type to `0` (or `V4L2_MBUS_UNKNOWN`) will instruct the V4L2
    core to try to guess the actual media bus according to the properties found in
    the firmware node. It will first consider whether the device is on a CSI-2 bus
    and try to parse the endpoint node accordingly, looking for CSI-2-related properties.
    Fortunately, CSI-2 and parallel buses have no properties in common. This way,
    if, and only if, no MIPI CSI-2-specific properties were found, the core will parse
    the parallel video bus properties. The core does not guess `V4L2_MBUS_CCP2` nor
    `V4L2_MBUS_CSI1`. For these buses, the `bus-type` property must be specified.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将总线类型指定为`0`（或`V4L2_MBUS_UNKNOWN`）将指示V4L2核心尝试根据在固件节点中找到的属性来猜测实际的媒体总线。它首先会考虑设备是否在CSI-2总线上，并尝试相应地解析端点节点，寻找与CSI-2相关的属性。幸运的是，CSI-2和并行总线没有共同的属性。因此，只有在没有找到MIPI
    CSI-2特定属性时，核心才会解析并行视频总线属性。核心不会猜测`V4L2_MBUS_CCP2`或`V4L2_MBUS_CSI1`。对于这些总线，必须指定`bus-type`属性。
- en: V4L2 async
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: V4L2异步
- en: Because of the complexity of video-based hardware that sometimes integrates
    non-V4L2 devices (sub-devices, actually) sitting on different buses, the need
    has come for sub-devices to defer initialization until the bridge driver has been
    loaded, and on the other hand, the bridge driver needs to postpone initializing
    sub-devices until all required sub-devices have been loaded; that is, V4L2 async.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基于视频的硬件的复杂性，有时会集成非V4L2设备（实际上是子设备）位于不同的总线上，因此需要子设备推迟初始化，直到桥接驱动程序已加载，另一方面，桥接驱动程序需要推迟初始化子设备，直到所有必需的子设备已加载；也就是说，V4L2异步。
- en: In asynchronous mode, sub-device probing can be invoked independently of bridge
    driver availability. The sub-device driver then has to verify whether all the
    requirements for a successful probing are satisfied. This can include a check
    for master clock availability, a GPIO, or anything else. If any of the conditions
    aren't satisfied, the sub-device driver might decide to return `-EPROBE_DEFER`
    to request further re-probing attempts. Once all the conditions are met, the sub-device
    will be registered with the V4L2 async core using the `v4l2_async_register_subdev()`
    function. The unregistration is performed using the `v4l2_async_unregister_subdev()`
    call.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步模式下，子设备探测可以独立于桥接驱动程序的可用性进行。然后，子设备驱动程序必须验证是否满足了成功探测的所有要求。这可能包括检查主时钟的可用性、GPIO或其他任何内容。如果任何条件不满足，子设备驱动程序可能决定返回`-EPROBE_DEFER`以请求进一步的重新探测尝试。一旦满足所有条件，子设备将使用`v4l2_async_register_subdev()`函数在V4L2异步核心中注册。取消注册使用`v4l2_async_unregister_subdev()`调用执行。
- en: We saw earlier where synchronous registration applies. It is a mode where the
    bridge driver is aware of the context of all the sub-devices it is responsible
    for. It has the responsibility of registering all the sub-devices using `v4l2_device_register_subdev()`
    on each of them during its probing, as is the case with the `drivers/media/platform/exynos4-is/media-dev.c`
    driver.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到同步注册适用的情况。这是一种模式，桥接驱动程序了解其负责的所有子设备的上下文。它有责任在其探测期间使用`v4l2_device_register_subdev()`在每个子设备上注册所有子设备，就像`drivers/media/platform/exynos4-is/media-dev.c`驱动程序一样。
- en: 'In the V4L2 async framework, the concept of a sub-device is abstracted. A sub-device
    is known in the async framework as an instance of a `struct v4l2_async_subdev`
    structure. Along with this structure, there is another `struct v4l2_async_notifier`
    structure. Both are defined in `include/media/v4l2-async.h` and somehow form the
    center part of the V4L2 async core. Prior to going further, we have to introduce
    the center part of the V4L2 async framework, `struct v4l2_async_notifier`, as
    follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在V4L2异步框架中，子设备的概念被抽象化。在异步框架中，子设备被称为`struct v4l2_async_subdev`结构的一个实例。除了这个结构，还有另一个`struct
    v4l2_async_notifier`结构。两者都在`include/media/v4l2-async.h`中定义，并且在V4L2异步核心的中心部分。在进一步进行之前，我们必须介绍V4L2异步框架的中心部分`struct
    v4l2_async_notifier`，如下所示：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding structure is mostly used by the bridge drivers and the async
    core. In some cases, however, sub-device drivers may need to be notified by some
    other sub-devices. In either case, the uses and meanings of the members are the
    same:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结构主要由桥接驱动程序和异步核心使用。然而，在某些情况下，子设备驱动程序可能需要被其他子设备通知。在任何情况下，成员的用途和含义都是相同的：
- en: '`ops` is a set of callbacks to be provided by the owner of this notifier that
    are invoked by the async core as and when sub-devices waiting in this notifier
    are probed.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ops`是由此通知器的所有者提供的一组回调，由异步核心在等待在此通知器中的子设备被探测时调用。'
- en: '`v4l2_dev` is the V4L2 parent of the bridge driver that registered this notifier.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v4l2_dev`是注册此通知器的桥接驱动程序的V4L2父级。'
- en: '`sd`, if this notifier has been registered by a sub-device, will point to this
    sub-device. We do not address this case here.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sd`，如果此通知器是由子设备注册的，将指向此子设备。我们在这里不讨论这种情况。'
- en: '`subdevs` is an array of sub-devices for which the registrar of this notifier
    (either the bridge driver or another sub-device driver) should be notified.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subdevs`是应该通知此通知器的注册者（桥接驱动程序或另一个子设备驱动程序）的子设备数组。'
- en: '`waiting` is a list of the sub-devices in this notifier waiting to be probed.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`waiting`是此通知器中等待被探测的子设备的列表。'
- en: '`done` is a list of the sub-devices actually bound to this notifier.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`done`是实际绑定到此通知器的子设备的列表。'
- en: '`num_subdevs` is the number of sub-devices in `**subdevs`.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_subdevs`是`**subdevs`中子设备的数量。'
- en: '`list` is used by the async core during the registration of this notifier in
    order to link this notifier to the global list of notifiers, `notifier_list`.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`在注册此通知器时由异步核心使用，以将此通知器链接到通知器的全局列表`notifier_list`。'
- en: 'Back to our `struct v4l2_async_subdev` structure, which is defined as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`struct v4l2_async_subdev`结构，定义如下：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding data structure is a sub-device in the eyes of the V4L2 async
    framework. Only the bridge driver (which allocates the async sub-device) and the
    async core can play with this structure. The sub-device driver is not aware of
    this at all. The meanings of its members are as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的数据结构在V4L2异步框架中是一个子设备。只有桥接驱动程序（分配异步子设备）和异步核心可以使用这个结构。子设备驱动程序完全不知道这一点。其成员的含义如下：
- en: '`match_type` is of the `enum v4l2_async_match_type` type. A match is a comparison
    of some criteria (occurring `struct v4l2_subdev` type and an async sub-device
    of the `struct v4l2_async_subdev` type). Since each `struct v4l2_async_subdev`
    structure must be associated with its `struct v4l2_subdev` structure, this field
    specifies the algorithm used by the async core to match both. This field is set
    by the driver (which is also responsible for allocating asynchronous sub-devices).
    Possible values are as follows:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match_type`是`enum v4l2_async_match_type`类型。匹配是对某些标准进行比较（发生`struct v4l2_subdev`类型和`struct
    v4l2_async_subdev`类型的异步子设备）。由于每个`struct v4l2_async_subdev`结构必须与其`struct v4l2_subdev`结构相关联，因此该字段指定了异步核心用于匹配两者的算法。该字段由驱动程序设置（也负责分配异步子设备）。可能的值如下：'
- en: --`V4L2_ASYNC_MATCH_DEVNAME`, which instructs the async core to use the device
    name for the matching. In this case, the bridge driver must set the `v4l2_async_subdev.match.device_name`
    field so that it can match the sub-device device name (that is, `dev_name(v4l2_subdev->dev)`)
    when that sub-device will be probed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: --`V4L2_ASYNC_MATCH_DEVNAME`，指示异步核心使用设备名称进行匹配。在这种情况下，桥接驱动程序必须设置`v4l2_async_subdev.match.device_name`字段，以便在探测到子设备时可以匹配子设备的设备名称（即`dev_name(v4l2_subdev->dev)`）。
- en: --`V4L2_ASYNC_MATCH_FWNODE`, which means the async core should use the firmware
    node for the match. In this case, the bridge driver must set `v4l2_async_subdev.match.fwnode`
    with the firmware node handle corresponding to the sub-device's device node so
    that they can match.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: -`V4L2_ASYNC_MATCH_FWNODE`，这意味着异步核心应使用固件节点进行匹配。在这种情况下，桥接驱动程序必须使用与子设备的设备节点对应的固件节点句柄`v4l2_async_subdev.match.fwnode`进行匹配。
- en: --`V4L2_ASYNC_MATCH_I2C` is to be used to perform the match by checking for
    the I2C adapter ID and address. Using this, the bridge driver must set both `v4l2_async_subdev.match.i2c.adapter_id`
    and `v4l2_async_subdev.match.i2c.address`. These values will be compared with
    the address and the adapter number of the `i2c_client` object associated with
    `v4l2_subdev.dev`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: -应使用`V4L2_ASYNC_MATCH_I2C`通过检查I2C适配器ID和地址来执行匹配。使用此功能，桥接驱动程序必须同时设置`v4l2_async_subdev.match.i2c.adapter_id`和`v4l2_async_subdev.match.i2c.address`。这些值将与与`v4l2_subdev.dev`关联的`i2c_client`对象的地址和适配器编号进行比较。
- en: --`V4L2_ASYNC_MATCH_CUSTOM` is the last possibility and means the async core
    should use the matching callback set by the bridge driver in `v4l2_async_subdev.match.custom.match`.
    If this flag is set and there is no custom matching callback provided, any matching
    attempt will immediately return true.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: -`V4L2_ASYNC_MATCH_CUSTOM`是最后一种可能性，意味着异步核心应使用桥接驱动程序中设置的匹配回调`v4l2_async_subdev.match.custom.match`。如果设置了此标志并且未提供自定义匹配回调，则任何匹配尝试将立即返回true。
- en: '`list` is used to add this async sub-device waiting to be probed in the waiting
    list of a notifier.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`用于将此异步子设备添加到通知程序的等待列表中等待探测。'
- en: 'Sub-device registration does not depend on the bridge availability anymore
    and only consists of calling the `v4l2_async_unregister_subdev()` method. However,
    prior to registering itself, the bridge driver will have to do the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 子设备注册不再依赖于桥接可用性，只需调用`v4l2_async_unregister_subdev（）`方法即可。但是，在注册自身之前，桥接驱动程序将不得不执行以下操作：
- en: Allocate a notifier for later use. It is better to embed this notifier in a
    larger device state data structure. This notifier object is of the `struct v4l2_async_notifier`
    type.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为以后使用分配一个通知程序。最好将此通知程序嵌入较大的设备状态数据结构中。此通知程序对象是`struct v4l2_async_notifier`类型。
- en: 'Parse its port node(s) and create an async sub-device (`struct v4l2_async_subdev`)
    for each sensor (or IP block) specified there and that it needs for its operations:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析其端口节点并为其中指定的每个传感器（或IP块）创建一个异步子设备（`struct v4l2_async_subdev`），并且它需要进行操作：
- en: 'a) This parsing is done using the `fwnode` graph API (old drivers still use
    the `of_graph` API), such as the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: a）使用`fwnode`图形API（旧驱动程序仍使用`of_graph` API）进行此解析，例如以下内容：
- en: --`fwnode_graph_get_next_endpoint()` (or `of_graph_get_next_endpoint()` in old
    drivers) to grab the `fw_handle` (or the `of_node` in old drivers) of an endpoint
    from within the bridge's port subnode.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: -`fwnode_graph_get_next_endpoint（）`（或旧驱动程序中的`of_graph_get_next_endpoint（）`）来抓取桥接的端口子节点中的端点的`fw_handle`（或旧驱动程序中的`of_node`）。
- en: --`fwnode_graph_get_remote_port_parent()` (or `of_graph_get_remote_port_parent()`
    in old drivers) to grab the `fw_handle` (or the device's `of_node` in old drivers)
    corresponding to the parent of the remote port of the current endpoint.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: -`fwnode_graph_get_remote_port_parent（）`（或旧驱动程序中的`of_graph_get_remote_port_parent（）`）来抓取当前端点的远程端口的`fw_handle`（或设备的`of_node`）对应的父级。
- en: Optionally (in old drivers using the OF API), `of_fwnode_handle()` is used in
    order to convert the `of_node` grabbed in the previous state into an `fw_handle`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地（在使用OF API的旧驱动程序中），使用`of_fwnode_handle（）`将先前状态中抓取的`of_node`转换为`fw_handle`。
- en: b) Set up the current async sub-device according to the matching logic that
    should be used. It should set the `v4l2_async_subdev.match_type` and `v4l2_async_subdev.match`
    members.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: b）根据应使用的匹配逻辑设置当前异步子设备。它应设置`v4l2_async_subdev.match_type`和`v4l2_async_subdev.match`成员。
- en: c) Add this async sub-device to the list of async sub-devices of the notifier.
    As of version 4.20 of the kernel, there is a helper, `v4l2_async_notifier_add_subdev()`,
    allowing you to do this.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: c）将此异步子设备添加到通知程序的异步子设备列表中。在内核的4.20版本中，有一个辅助程序`v4l2_async_notifier_add_subdev（）`，允许您执行此操作。
- en: Register the notifier object (this notifier will be stored in the global `notifier_list`
    list defined in `drivers/media/v4l2-core/v4l2-async.c`) using the `v4l2_async_notifier_register(&big_struct->v4l2_dev,
    &big_struct->notifier)` call. To unregister the notifier, the driver has to call
    `v4l2_async_notifier_unregister(&big_struct->notifier)`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`v4l2_async_notifier_register（＆big_struct->v4l2_dev，＆big_struct->notifier）`调用注册通知对象（此通知对象将存储在`drivers/media/v4l2-core/v4l2-async.c`中定义的全局`notifier_list`列表中）。要取消注册通知程序，驱动程序必须调用`v4l2_async_notifier_unregister（＆big_struct->notifier）`。
- en: When the bridge driver invokes `v4l2_async_notifier_register()`, the async core
    iterates over async sub-devices in the `notifier->subdevs` array. For each async
    sub-device inside, the core checks whether this `asd->match_type` value is `V4L2_ASYNC_MATCH_FWNODE`.
    If applicable, the async core makes sure `asd` is not present in the `notifier->waiting`
    list or in the `notifier->done` list by comparing fwnodes. This provides assurance
    that `asd` was not already set up for `fwnode` and it does not already exist in
    the given notifier. If `asd` is not already known, it is added to `notifier->waiting`.
    After this, the async core will test all async sub-devices in the `notifier->waiting`
    list for a match with all sub-devices present in `subdev_list`, which is the list
    of "kind-of" orphan sub-devices, those that were registered prior to their bridge
    driver (thus prior to their notifier). The async core uses the `asd->match` value
    of each current `asd` for this. If a match occurs (the `asd->match` callback returns
    true), the current async sub-device (from `notifier->waiting`) and the current
    sub-device (from `subdev_list`) will be bound, the async sub-device will be removed
    from the `notifier->waiting` list, the sub-device will be registered with the
    V4L2 core using `v4l2_device_register_subdev()`, and the sub-device will be moved
    from the global `subdev_list` list to the `notifier->done` list.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当桥接驱动程序调用`v4l2_async_notifier_register()`时，异步核心会迭代`notifier->subdevs`数组中的异步子设备。对于每个异步子设备，核心会检查`asd->match_type`值是否为`V4L2_ASYNC_MATCH_FWNODE`。如果适用，异步核心会通过比较fwnodes来确保`asd`不在`notifier->waiting`列表或`notifier->done`列表中。这可以确保`asd`尚未为`fwnode`设置，并且它尚不存在于给定的通知器中。如果`asd`尚未知晓，则将其添加到`notifier->waiting`中。之后，异步核心将测试`notifier->waiting`列表中的所有异步子设备，以与`subdev_list`中存在的所有子设备进行匹配。`subdev_list`是“类似”孤立子设备的列表，这些子设备是在其桥接驱动程序（因此在其通知器）之前注册的。异步核心使用每个当前`asd`的`asd->match`值进行匹配。如果匹配发生（`asd->match`回调返回true），则当前异步子设备（来自`notifier->waiting`）和当前子设备（来自`subdev_list`）将被绑定，异步子设备将从`notifier->waiting`列表中移除，子设备将使用`v4l2_device_register_subdev()`注册到V4L2核心，并且子设备将从全局`subdev_list`列表移动到`notifier->done`列表中。
- en: Finally, the actual notifier being registered will be added to the global list
    of notifiers, `notifier_list`, so that it can be used later for matching attempts
    whenever a new sub-device is registered with the async core.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，被注册的实际通知器将被添加到全局通知器列表`notifier_list`中，以便在以后使用时，可以在异步核心中注册新的子设备时进行匹配尝试。
- en: Important note
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: What the async core does when the sub-device driver invokes `v4l2_async_register_subdev()`
    can be guessed from the preceding matching and bounding logic descriptions. Effectively,
    upon this call, the async core will attempt to match the current sub-device with
    all the async sub-devices waiting in each notifier present in the `notifier_list`
    global list. If no match occurs, it means this sub-device's bridge has not been
    probed yet, and the sub-device is added to the global list of sub-devices, `subdev_list`.
    If a match occurs, the sub-device will not be added to this list at all.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当子设备驱动程序调用`v4l2_async_register_subdev()`时，异步核心会尝试将当前子设备与`notifier_list`全局列表中存在的每个通知器中等待的所有异步子设备进行匹配。如果没有匹配发生，这意味着尚未探测到此子设备的桥接，子设备将被添加到全局子设备列表`subdev_list`中。如果发生匹配，子设备将根本不会添加到此列表中。
- en: Do also keep in mind that a match test is a comparison of some criteria, occurring
    strictly between a sub-device of the `struct v4l2_subdev` type and an async sub-device
    of the `struct v4l2_async_subdev` type.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，匹配测试是在`struct v4l2_subdev`类型的子设备和`struct v4l2_async_subdev`类型的异步子设备之间严格发生的一些标准的比较。
- en: 'In the preceding paaragraphs, we said the async sub-device and the sub-device
    are bound. But what does this mean? Here is where the `notifier->ops` member comes
    into the picture. It is of the `struct v4l2_async_notifier_operations` type and
    is defined as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的段落中，我们说异步子设备和子设备是绑定的。但这是什么意思呢？这就是`notifier->ops`成员发挥作用的地方。它是`struct v4l2_async_notifier_operations`类型，并定义如下：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following are the meanings of each callback in this structure despite the
    fact that all three callbacks are optional:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构中，以下是每个回调的含义，尽管所有三个回调都是可选的：
- en: '`bound`: If set, this callback will be invoked by the async core in response
    to a successful sub-device probing by its (sub-device) driver. This also implies
    that an async sub-device has successfully matched this sub-device. This callback
    takes as an argument the notifier that originated the match, as well as the sub-device
    (`subdev`) and the async sub-device (`asd`) that matched. Most drivers simply
    print debug messages here. However, you can perform additional setup on the sub-device
    here – that is, `v4l2_subdev_call()`. If everything seems OK, it should return
    a positive value; otherwise, the sub-device is unregistered.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bound`：如果设置，异步核心将在成功的子设备探测后由其（子设备）驱动程序调用此回调。这也意味着异步子设备已成功匹配此子设备。此回调将以发起匹配的通知器以及匹配的子设备（`subdev`）和异步子设备（`asd`）作为参数。大多数驱动程序在这里只是打印调试消息。但是，您可以在这里对子设备进行额外的设置-即`v4l2_subdev_call()`。如果一切正常，它应该返回一个正值；否则，子设备将被注销。'
- en: '`unbind` is invoked when a sub-device is removed from the system. In addition
    to printing debug messages here, the bridge driver must unregister the video device
    if the unbound sub-device was a requirement for it to work normally – that is,
    `video_unregister_device()`.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unbind`在从系统中移除子设备时被调用。除了在这里打印调试消息外，桥接驱动程序还必须取消注册视频设备，如果未绑定的子设备对其正常工作是必需的-即`video_unregister_device()`。'
- en: '`complete` is invoked when there are no more async sub-devices waiting in the
    notifier. The async core can detect when the `notifier->waiting` list is empty
    (which would mean sub-devices have been probed successfully and are all moved
    into the `notifier->done` list). The complete callback is only executed for the
    root notifier. Sub-devices that registered notifiers will not have their `.complete`
    callback invoked. The root notifier is usually the one registered by the bridge
    device.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complete`在通知器中没有更多的异步子设备等待时被调用。异步核心可以检测到`notifier->waiting`列表为空（这意味着子设备已经成功探测并全部移动到`notifier->done`列表中）。完成回调仅对根通知器执行。注册了通知器的子设备不会调用其`.complete`回调。根通知器通常是由桥接设备注册的。'
- en: There is no doubt, then, that, prior to registering the notifier object, the
    bridge driver must set the notifier's `ops` member. The most important callback
    for us is `.complete`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，在注册通知器对象之前，桥接驱动程序必须设置通知器的`ops`成员。对我们来说最重要的回调是`.complete`。
- en: While you can call `v4l2_device_register()` from within the bridge driver's
    `probe` function, it is a common practice to register the actual video device
    from within the `notifier.complete` callback, as all sub-devices would be registered,
    and the presence of `/dev/videoX` would mean it is really usable. The `.complete`
    callback is also suitable for both registering the actual video device's subnode
    and registering the media device by means of `v4l2_device_register_subdev_nodes()`
    and `media_device_register()`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在桥接驱动程序的`probe`函数中调用`v4l2_device_register()`是一种常见做法，但通常在`notifier.complete`回调中注册实际的视频设备，因为所有子设备都将被注册，并且`/dev/videoX`的存在意味着它确实可用。`.complete`回调也适用于注册实际视频设备的子节点，并通过`v4l2_device_register_subdev_nodes()`和`media_device_register()`注册媒体设备。
- en: Note that `v4l2_device_register_subdev_nodes()` will create a device node (`/dev/v4l2-subdevX`,
    actually) for every `subdev` object marked with the `V4L2_SUBDEV_FL_HAS_DEVNODE`
    flag.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`v4l2_device_register_subdev_nodes()`将为每个标有`V4L2_SUBDEV_FL_HAS_DEVNODE`标志的`subdev`对象创建一个设备节点（实际上是`/dev/v4l2-subdevX`）。
- en: Async bridge and sub-device probing example
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步桥接和子设备探测示例
- en: 'We will go through this section with a simple use case. Consider the following
    config:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个简单的用例来介绍这一部分。考虑以下配置：
- en: One bridge device (our CSI controller) – let's say the `omap` ISP, with `foo`
    as its name.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个桥接设备（我们的CSI控制器） - 让我们说`omap` ISP，以`foo`作为其名称。
- en: One off-chip sub-device, the camera sensor, with `bar` as its name.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个片外子设备，摄像头传感器，以`bar`作为其名称。
- en: 'Both are connected this way: `CSI <-- Camera Sensor`.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 两者是这样连接的：`CSI <-- 摄像头传感器`。
- en: 'In the `bar` driver, we could register an async sub-device as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bar`驱动程序中，我们可以注册一个异步子设备，如下所示：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `probe` function of the `foo` driver could be as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo`驱动程序的`probe`函数可能如下所示：'
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the following code, we implement the `foo` fwnode (or `of_node`) parser
    helper, `foo_parse_nodes()`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们实现了`foo` fwnode（或`of_node`）解析器助手`foo_parse_nodes()`：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, both `of_graph_get_next_endpoint()` and `fwnode_graph_get_next_endpoint()`
    have been used in order to show how to play with the two. That being said, you're
    better off using the fwnode version, as it is much more generic.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`of_graph_get_next_endpoint()`和`fwnode_graph_get_next_endpoint()`都已经被用来展示如何使用这两者。也就是说，最好使用fwnode版本，因为它更通用。
- en: 'In the meantime, we need to write `foo`''s notifier operations, which could
    look as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们需要编写`foo`的通知器操作，可能如下所示：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the device tree, the V4L2 bridge device can be declared as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备树中，V4L2桥接设备可以声明如下：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The camera node from within the I2C controller node can be declared as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在I2C控制器节点内部的摄像头节点可以声明如下：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now we are familiar with the V4L2 async framework and we have seen how the asynchronous
    sub-device registration eases both the probe and the code. We ended with a concrete
    example that highlights each aspect we have discussed. Now we can move forward
    and integrate with the media controller framework, which is the last improvement
    we can add to our V4L2 drivers.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了V4L2异步框架，看到了异步子设备注册如何简化探测和代码。我们以一个具体的例子结束了，突出了我们讨论的每个方面。现在我们可以继续并集成媒体控制器框架，这是我们可以为V4L2驱动程序添加的最后一个改进。
- en: The Linux media controller framework
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux媒体控制器框架
- en: Media devices turn out to be very complex, involving several IP blocks of the
    SoC and thus requiring video stream (re)routing.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体设备非常复杂，涉及SoC的多个IP块，因此需要视频流（重新）路由。
- en: Now, let's consider a case where we have a much more sophisticated SoC made
    of two more on-chip sub-devices – let's say a resizer and an image converter,
    called `baz` and `biz`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个更复杂的SoC情况，由两个更多的片上子设备组成 - 比如一个重塑器和一个图像转换器，称为`baz`和`biz`。
- en: In the previous example in the *V4L2 async* section, the setup was made up of
    one bridge device and one sub-device (the fact that it is off-chip does not matter),
    the camera sensor. This was quite straightforward. Luckily, things worked. But
    what if now we have to route the stream through the image converter or the image
    resizer, or even through both IPs? Or, say we have to switch from one to the other
    (dynamically)?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在*V4L2异步*部分的前面的示例中，设置由一个桥接设备和一个子设备（它是片外的事实并不重要），摄像头传感器组成。这相当简单。幸运的是，事情进展顺利。但是，如果现在我们必须通过图像转换器或图像重塑器路由流，甚至通过这两个IP呢？或者说我们必须动态地从一个切换到另一个？
- en: 'We could achieve this either via `sysfs` or `ioctls`, but this would have the
    following problems:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`sysfs`或`ioctls`来实现这一点，但这将会有以下问题：
- en: It would be too ugly (no doubt) and probably buggy.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将会非常丑陋（毫无疑问），而且可能会有bug。
- en: It would be too hard (a lot of work).
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将会非常困难（需要大量工作）。
- en: It would be deeply SoC vendor-dependent, with possibly a lot of code duplication,
    no unified user space API and ABI, and no consistency between drivers.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将深深地依赖于SoC供应商，可能会有大量的代码重复，没有统一的用户空间API和ABI，驱动程序之间没有一致性。
- en: It would be not a very credible solution.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将不是一个非常可信的解决方案。
- en: Many SoCs can reroute internal video streams – for example, capturing them from
    a sensor and doing memory-to-memory resizing, or sending the sensor output directly
    to the resizer. Since the V4L2 API did not support these advanced devices, SoC
    manufacturers made their own custom drivers. However, V4L2 is undisputably the
    Linux API for capturing images and is sometimes used for specific display devices
    (these are mem2mem devices).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 许多SoC可以重新路由内部视频流 - 例如，从传感器捕获它们并进行内存到内存的调整，或直接将传感器输出发送到调整器。由于V4L2 API不支持这些高级设备，SoC制造商制作了自己的定制驱动程序。但是，V4L2无疑是用于捕获图像的Linux
    API，并且有时用于特定的显示设备（这些是mem2mem设备）。
- en: It is becoming clear that we need another subsystem and framework that covers
    the limits of V4L2\. This is how the Linux media controller framework was born.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们需要另一个子系统和框架来涵盖V4L2的限制。这就是Linux媒体控制器框架诞生的原因。
- en: The media controller abstraction model
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 媒体控制器抽象模型
- en: Discovering a device's internal topology and configuring it at runtime is one
    of the goals of the media framework. To achieve this, it comes with a layer of
    abstraction. With the media controller framework, hardware devices are represented
    through an oriented graph made of **entities** whose **pads** are connected via
    **links**. This set of elements put together forms the so-called **media device**.
    A source pad can only generate data.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 发现设备的内部拓扑并在运行时对其进行配置是媒体框架的目标之一。为了实现这一点，它带有一层抽象。通过媒体控制器框架，硬件设备通过由**实体**组成的有向图来表示，这些**实体**的**pad**通过**链接**连接。这些元素的集合组成了所谓的**媒体设备**。源pad只能生成数据。
- en: 'The preceding short description deserves some attention. There are three highlighted
    words that are of high interest: entity, pad, and link:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的简短描述值得关注。有三个高度关注的突出词：entity、pad和link：
- en: '`struct media_entity` instance, defined in `include/media/media-entity.h`.
    The structure is usually embedded into a higher-level structure, such as a `v4l2_subdev`
    or `video_device` instance, although drivers can allocate entities directly.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct media_entity`实例，定义在`include/media/media-entity.h`中。该结构通常嵌入到更高级的结构中，例如`v4l2_subdev`或`video_device`实例，尽管驱动程序可以直接分配实体。'
- en: '`/dev/videoX` pad would be modeled as an input pad since it is the end of the
    stream.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev/videoX` pad将被建模为输入pad，因为它是流的结束。'
- en: '**Links**: These links can be set, fetched, and enumerated through the media
    device. The application, for a driver to properly work, is responsible for setting
    up the links properly so that the driver understands the source and destination
    of the video data.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接**：这些链接可以通过媒体设备进行设置、获取和枚举。为了使驱动程序正常工作，应用程序负责正确设置这些链接，以便驱动程序了解视频数据的源和目的地。'
- en: 'All the entities on the system, along with their pads and the connection links
    between them, give the **media device** shown in the following diagram:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 系统上的所有实体以及它们的pad和它们之间的连接链接，构成了下图所示的**媒体设备**：
- en: '![Figure 8.1 – Media controller abstraction model'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 - 媒体控制器抽象模型'
- en: '](img/Figure_8.1_B10985.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.1_B10985.jpg)'
- en: Figure 8.1 – Media controller abstraction model
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 - 媒体控制器抽象模型
- en: In the preceding diagram, `/dev/videoX` char device as it is the end of the
    stream.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，`/dev/videoX` char设备因为它是流的结束。
- en: V4L2 device abstraction
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: V4L2设备抽象
- en: 'At a higher level, the media controller uses `struct media_device` to abstract
    `struct v4l2_device` in the V4L2 framework. That being said, `struct media_device`
    is to the media controller what `struct v4l2_device` is to V4L2, englobing other
    lower-level structures. Back to `struct v4l2_device`, the `mdev` member is used
    by the media controller framework to abstract this structure. The following is
    an excerpt:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高级别上，媒体控制器使用`struct media_device`来抽象V4L2框架中的`struct v4l2_device`。也就是说，`struct
    media_device`对于媒体控制器来说就像`struct v4l2_device`对于V4L2一样，包含其他更低级别的结构。回到`struct v4l2_device`，`mdev`成员被媒体控制器框架用来抽象此结构。以下是摘录：
- en: '[PRE30]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, from a media controller point of view, V4L2 video devices and sub-devices
    are all seen as media entities, represented in this framework as instances of
    `struct media_entity`. It is then obvious for the video device and sub-device
    data structures to embed a member of this type, as shown in the following excerpt:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从媒体控制器的角度来看，V4L2视频设备和子设备都被视为媒体实体，在该框架中表示为`struct media_entity`的实例。因此，视频设备和子设备数据结构明显需要嵌入此类型的成员，如下摘录所示：
- en: '[PRE31]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The video device has additional members, `intf_devnode` and `pipe`. The former,
    of the `struct media_intf_devnode` type, represents the media controller interface
    to the video device node. This structure gives the media controller access to
    information of the underlying video device node, such as its major and minor numbers.
    The other additional member, `pipe`, which is of the `struct media_pipeline` type,
    stores information related to the streaming pipeline of this video device.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 视频设备具有额外的成员，`intf_devnode`和`pipe`。前者是`struct media_intf_devnode`类型，表示媒体控制器接口到视频设备节点的接口。该结构使媒体控制器能够访问底层视频设备节点的信息，如其主次编号。另一个额外的成员`pipe`是`struct
    media_pipeline`类型，存储与该视频设备的流水线相关的信息。
- en: Media controller data structures
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体控制器数据结构
- en: 'The media controller framework is based on a few data structures, among which
    is the `struct media_device` structure, which is on top of the hierarchy and defined
    as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体控制器框架基于一些数据结构，其中包括`struct media_device`结构，它位于层次结构的顶部，并定义如下：
- en: '[PRE32]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This structure represents a high-level media device. It allows easy access
    to entities and provides basic media device-level support:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构表示高级媒体设备。它允许轻松访问实体并提供基本的媒体设备级别支持：
- en: '`dev` is the parent device for this media device (usually a `&pci_dev`, `&usb_interface`,
    or `&platform_device` instance).'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`是此媒体设备的父设备（通常是`&pci_dev`，`&usb_interface`或`&platform_device`实例）。'
- en: '`devnode` is the media device node, abstracting the underlying `/dev/mediaX`.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devnode`是媒体设备节点，抽象底层的`/dev/mediaX`。'
- en: '`driver_name` is an optional but recommended field, representing the media
    device driver name. If not set, it defaults to `dev->driver->name`.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver_name`是一个可选但建议的字段，表示媒体设备驱动程序的名称。如果未设置，默认为`dev->driver->name`。'
- en: '`model` is the model name of this media device. It doesn''t have to be unique.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model`是该媒体设备的型号名称。它不必是唯一的。'
- en: '`serial` is an optional member that should be set with the device serial number.
    `hw_revision` is the hardware device revision for this media device.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serial`是一个可选成员，应该设置为设备序列号。`hw_revision`是该媒体设备的硬件设备版本。'
- en: '`topology_version`: Monotonic counter for storing the version of the graph
    topology. Should be incremented each time the topology changes.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`topology_version`：用于存储图拓扑的版本的单调计数器。每次拓扑发生变化时应该递增。'
- en: '`entities` is the list of registered entities.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entities`是注册实体的列表。'
- en: '`pads` is the list of pads registered with this media device.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pads`是注册到该媒体设备的pad列表。'
- en: '`links` is the list of links registered with this media device.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`links`是注册到该媒体设备的链接列表。'
- en: '`entity_notify` is the notify callback list invoked when a new entity is registered
    with this media device. Drivers may register this callback to take action via
    `media_device_unregister_entity_notify()` and unregister it using `media_device_register_entity_notify()`.
    All the registered `media_entity_notify` callbacks are invoked when a new entity
    is registered.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entity_notify`是在新实体注册到该媒体设备时调用的通知回调列表。驱动程序可以通过`media_device_unregister_entity_notify()`注册此回调，并使用`media_device_register_entity_notify()`取消注册。当新实体注册时，所有注册的`media_entity_notify`回调都会被调用。'
- en: '`graph_mutex`: Protects access to `struct media_device` data. It should, for
    example, be held when using `media_graph_*` family functions.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graph_mutex`：保护对`struct media_device`数据的访问。例如，在使用`media_graph_*`系列函数时应该持有该锁。'
- en: '`ops` is of the `struct media_device_ops` type and represents the operation
    handler callbacks for this media device.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ops`是`struct media_device_ops`类型，表示该媒体设备的操作处理程序回调。'
- en: In addition to being manipulated by the media controller framework, `struct
    media_device` is essentially used in the bridge driver, where it is initialized
    and registered. That being said, the media device on its own is made up of several
    entities. This concept of entities allows the media controller to be the central
    authority when it comes to modern and complex V4L2 drivers that may also support
    framebuffers, ALSA, I2C, LIRC, and/or DVB devices at the same time and is used
    to inform user space of what is what.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 除了被媒体控制器框架操作外，`struct media_device`基本上是在桥接驱动程序中使用的，在那里进行初始化和注册。也就是说，媒体设备本身由多个实体组成。这种实体的概念允许媒体控制器成为现代和复杂的V4L2驱动程序的中央管理机构，这些驱动程序可能同时支持帧缓冲区、ALSA、I2C、LIRC和/或DVB设备，并用于通知用户空间的各种信息。
- en: 'A media entity is represented as an instance of `struct media_entity`, defined
    in `include/media/media-entity.h` as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体实体表示为`struct media_entity`的实例，如下所示：
- en: '[PRE33]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is the second data structure in the media framework in terms of hierarchy.
    The preceding definition has been shrunk to the minimum that we are interested
    in. The following are the meanings of the members in this structure:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这是媒体框架中按层次结构排列的第二个数据结构。前面的定义已经被缩减到我们感兴趣的最小值。以下是该结构中成员的含义：
- en: '`name` is the name of this entity. It should be meaningful enough as it is
    used as it is in user space with the `media-ctl` tool.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`是该实体的名称。它应该足够有意义，因为它在用户空间中与`media-ctl`工具一起使用。'
- en: '`type` is most of the time set by the core depending on the type of V4L2 video
    data structure this struct is embedded in. It is the type of the object that implements
    `media_entity` – for example, set with `MEDIA_ENTITY_TYPE_V4L2_SUBDEV` at the
    sub-device initialization by the core. This allows runtime type identification
    of media entities and safe casting to the correct object type using the `container_of`
    macro, for instance. Possible values are as follows:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`大多数情况下由核心根据该结构嵌入的V4L2视频数据结构的类型设置。它是实现`media_entity`的对象类型，例如，由核心在子设备初始化时设置为`MEDIA_ENTITY_TYPE_V4L2_SUBDEV`。这允许在运行时对媒体实体进行类型识别，并使用`container_of`宏安全地转换为正确的对象类型。可能的值如下：'
- en: '--`MEDIA_ENTITY_TYPE_BASE`: This means the entity is not embedded in another.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: --`MEDIA_ENTITY_TYPE_BASE`：这意味着该实体未嵌入在其他实体中。
- en: '--`MEDIA_ENTITY_TYPE_VIDEO_DEVICE`: This indicates the entity is embedded in
    a `struct video_device` instance.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: --`MEDIA_ENTITY_TYPE_VIDEO_DEVICE`：表示该实体嵌入在`struct video_device`实例中。
- en: '--`MEDIA_ENTITY_TYPE_V4L2_SUBDEV`: This means the entity is embedded in a `struct
    v4l2_subdev` instance.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: --`MEDIA_ENTITY_TYPE_V4L2_SUBDEV`：这意味着该实体嵌入在`struct v4l2_subdev`实例中。
- en: '`function` represents the entity''s main function. This must be set by the
    driver according to the value defined in `include/uapi/linux/media.h`. The following
    are commonly used values while dealing with video devices:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function`表示实体的主要功能。这必须由驱动程序根据`include/uapi/linux/media.h`中定义的值进行设置。在处理视频设备时，以下是常用的值：'
- en: '--`MEDIA_ENT_F_IO_V4L`: This flag means the entity is a data streaming input
    and/or output entity.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: --`MEDIA_ENT_F_IO_V4L`：此标志表示该实体是数据流输入和/或输出实体。
- en: '--`MEDIA_ENT_F_CAM_SENSOR`: This flag means this entity is a camera video sensor
    entity.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: --`MEDIA_ENT_F_CAM_SENSOR`：此标志表示该实体是摄像头视频传感器实体。
- en: '--`MEDIA_ENT_F_PROC_VIDEO_SCALER`: Means this entity can perform video scaling.
    These entities have at least one sink pad, from which they receive frame(s) (on
    the active one) and one source pad where they output the scaled frame(s).'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: --`MEDIA_ENT_F_PROC_VIDEO_SCALER`：表示该实体可以执行视频缩放。这些实体至少有一个接收端口，从中接收帧（在活动端口上），以及一个源端口，用于输出缩放后的帧。
- en: '--`MEDIA_ENT_F_PROC_VIDEO_ENCODER`: Means this entity is capable of compressing
    video. These entities must have one sink pad and at least one source pad.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: --`MEDIA_ENT_F_PROC_VIDEO_ENCODER`：表示该实体能够压缩视频。这些实体必须有一个接收端口和至少一个源端口。
- en: '--`MEDIA_ENT_F_VID_MUX`: This is to be used for a video multiplexer. This entity
    has at least two sink pads and one source pad and must pass the video frame(s)
    received from the active sink pad to the source pad.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: --`MEDIA_ENT_F_VID_MUX`：这是用于视频复用器。这个实体至少有两个接收端口和一个发送端口，并且必须将从活动接收端口接收到的视频帧传递到发送端口。
- en: '--`MEDIA_ENT_F_VID_IF_BRIDGE`: Video interface bridge. A video interface bridge
    entity should have at least one sink pad and one source pad. It receives video
    frames on its sink pad from an input video bus of one type (HDMI, eDP, MIPI CSI-2,
    and so on) and outputs them on its source pad to an output video bus of another
    type (eDP, MIPI CSI-2, parallel, and so on).'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: --`MEDIA_ENT_F_VID_IF_BRIDGE`：视频接口桥。视频接口桥实体应该至少有一个接收端口和一个发送端口。它从一个类型的输入视频总线（HDMI、eDP、MIPI
    CSI-2等）的接收端口接收视频帧，并将其从发送端口输出到另一种类型的输出视频总线（eDP、MIPI CSI-2、并行等）。
- en: '`flags` is set by the driver. It represents the flags for this entity. Possible
    values are the `MEDIA_ENT_FL_*` flag family defined in `include/uapi/linux/media.h`.
    The following link may be of help to you to understand the possible values: [https://linuxtv.org/downloads/v4l-dvb-apis/userspace-api/mediactl/media-types.html](https://linuxtv.org/downloads/v4l-dvb-apis/userspace-api/mediactl/media-types.html).'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`由驱动程序设置。它表示这个实体的标志。可能的值是`include/uapi/linux/media.h`中定义的`MEDIA_ENT_FL_*`标志系列。以下链接可能对您理解可能的值有所帮助：[https://linuxtv.org/downloads/v4l-dvb-apis/userspace-api/mediactl/media-types.html](https://linuxtv.org/downloads/v4l-dvb-apis/userspace-api/mediactl/media-types.html)。'
- en: '`function` represents this entity''s function and by default is `MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN`.
    Possible values are the `MEDIA_ENT_F_*` function family defined in `include/uapi/linux/media.h`.
    For example, a camera sensor sub-device driver must contain `sd->entity.function
    = MEDIA_ENT_F_CAM_SENSOR;`. You can follow this link to find detailed information
    on what may be suitable for your media entity: https://linuxtv.org/downloads/v4l-dvb-apis/uapi/mediactl/media-types.html.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`function`代表这个实体的功能，默认为`MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN`。可能的值是`include/uapi/linux/media.h`中定义的`MEDIA_ENT_F_*`功能系列。例如，相机传感器子设备驱动程序必须包含`sd->entity.function
    = MEDIA_ENT_F_CAM_SENSOR;`。您可以通过此链接找到关于适合您的媒体实体的详细信息：https://linuxtv.org/downloads/v4l-dvb-apis/uapi/mediactl/media-types.html。'
- en: '`num_pads` is the total number of pads of this entity (sink and source).'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_pads`是这个实体的pad总数（接收端口和发送端口）。'
- en: '`num_links` is the total number of links of this entity (forward, back, enabled,
    and disabled)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_links`是这个实体的链接总数（前向、后向、启用和禁用）。'
- en: '`num_backlinks` is the numbers of backlinks of this entity. Backlinks are used
    to help graph traversal and are not reported to user space.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_backlinks`是这个实体的反向链接数。反向链接用于帮助图遍历，并不报告给用户空间。'
- en: '`internal_idx`: A unique entity number assigned by the media controller core
    when the entity is registered.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`internal_idx`：当实体注册时，媒体控制器核心分配的唯一实体编号。'
- en: '`pads` is the array of pads of this entity. Its size is defined by `num_pads`.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pads`是这个实体的pad数组。其大小由`num_pads`定义。'
- en: '`links` is the list of data links of this entity. See `media_add_link()`.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`links`是这个实体的数据链接列表。参见`media_add_link()`。'
- en: '`ops` is of the `media_entity_operations` type and represents operations for
    this entity. This structure will be discussed later.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ops`是`media_entity_operations`类型，代表了这个实体的操作。这个结构将在后面讨论。'
- en: '`stream_count`: Stream count for the entity.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream_count`：实体的流计数。'
- en: '`use_count`: The use count for the entity. Used for power management purposes.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_count`：实体的使用计数。用于电源管理目的。'
- en: '`pipe` is the media pipeline that this entity belongs to.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pipe`是这个实体所属的媒体管道。'
- en: 'Naturally, the next data structure that seems obvious for us to introduce is
    the `struct media_pad` structure, which represents a pad in this framework. A
    pad is a connection endpoint through which an entity can interact with other entities.
    Data (not restricted to video) produced by an entity flows from the entity''s
    output to one or more entity inputs. Pads should not be confused with the physical
    pins at chip boundaries. `struct media_pad` is defined as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 自然而然，我们要介绍的下一个数据结构是`struct media_pad`结构，它代表了这个框架中的一个pad。Pad是一个连接端点，通过它实体可以与其他实体进行交互。实体产生的数据（不限于视频）从实体的输出流向一个或多个实体的输入。Pad不应与芯片边界上的物理引脚混淆。`struct
    media_pad`定义如下：
- en: '[PRE34]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Pads are identified by their entity and their 0-based `index` in the entity's
    pads array. In the `flags` field, either `MEDIA_PAD_FL_SINK` (which indicates
    that the pad supports sinking data) or `MEDIA_PAD_FL_SOURCE` (which indicates
    that the pad supports sourcing data) can be set, but not both at the same time,
    since a pad can't both sink and source.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Pad由它们的实体和它们在实体的pad数组中的基于0的`index`标识。在`flags`字段中，可以设置`MEDIA_PAD_FL_SINK`（表示pad支持接收数据）或`MEDIA_PAD_FL_SOURCE`（表示pad支持发送数据），但不能同时设置两者，因为一个pad不能同时接收和发送。
- en: 'Pads are meant to be bound together to allow data flow paths. Two pads, either
    from the same entity or from different entities, are bound together by means of
    point-to-point-oriented connections called links. Links are represented in the
    media framework as instances of `struct media_link`, defined as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Pad旨在绑定在一起以允许数据流路径。两个pad，无论是来自同一实体还是来自不同实体，都可以通过点对点的连接方式绑定在一起，称为链接。链接在媒体框架中表示为`struct
    media_link`的实例，定义如下：
- en: '[PRE35]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding code block, only a few fields have been listed for the sake
    of readability. The following are the meanings of those fields:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码块中，为了可读性，只列出了一些字段。以下是这些字段的含义：
- en: '`list`: Used to associate this link with the entity or interface owning the
    link.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`：用于将这个链接与拥有链接的实体或接口关联起来。'
- en: '`source`: Where this link originates from.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source`：链接的起始位置。'
- en: '`sink`: The link target.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sink`：链接的目标。'
- en: '`flags`: Represents the link flags, as defined in `uapi/media.h` (with the
    `MEDIA_LNK_FL_*` pattern). The following are the possible values:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`：表示链接标志，如`uapi/media.h`中定义的（使用`MEDIA_LNK_FL_*`模式）。以下是可能的值：'
- en: '--`MEDIA_LNK_FL_ENABLED`: This flag means the link is enabled and is ready
    for data transfer.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: --`MEDIA_LNK_FL_ENABLED`：此标志表示链接已启用并准备好进行数据传输。
- en: '--`MEDIA_LNK_FL_IMMUTABLE`: This flag means the link enabled state can''t be
    modified at runtime.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: --`MEDIA_LNK_FL_IMMUTABLE`：此标志表示链接启用状态无法在运行时修改。
- en: '--`MEDIA_LNK_FL_DYNAMIC`: This flag means the state of the link can be modified
    during streaming. However, this flag is set by drivers but is read-only for applications.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: --`MEDIA_LNK_FL_DYNAMIC`：此标志表示链接的状态可以在流媒体期间修改。但是，此标志由驱动程序设置，但对应用程序是只读的。
- en: '`reverse`: Pointer to the link (the backlink, actually) for the reverse direction
    of a pad-to-pad link.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse`：指向链接（实际上是反向链接）的指针，用于垫到垫链接的反向方向。'
- en: '`is_backlink`: Tells whether this link is a backlink.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_backlink`：告诉此链接是否为反向链接。'
- en: 'Each entity has a list that points to all links originating at or targeting
    any of its pads. A given link is thus stored twice, once in the source entity
    and once in the target entity. When you want to link `A` to `B`, two links are
    actually created:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 每个实体都有一个指向其任何垫发出或针对其任何垫的所有链接的列表。因此，给定链接存储两次，一次在源实体中，一次在目标实体中。当您想要将`A`链接到`B`时，实际上创建了两个链接：
- en: One that corresponds to what was expected; the link is stored in the source
    entity, and the source entity's `num_links` field is incremented.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个对应于预期的；链接存储在源实体中，并且源实体的`num_links`字段递增。
- en: Another one is stored in the sink entity. The sink and source remain the same,
    with the difference being that the `is_backlink` member is set to `true`. This
    corresponds to the reverse of the link you created. The sink entity's `num_backlinks`
    and `num_links` fields will be incremented. This backlink is then assigned to
    the original link's `reverse` member.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个存储在接收实体中。接收和源保持不变，不同之处在于`is_backlink`成员设置为`true`。这对应于您创建的链接的反向。接收实体的`num_backlinks`和`num_links`字段将被递增。然后将此反向链接分配给原始链接的`reverse`成员。
- en: 'At the end, the `mdev->topology_version` member is incremented twice. This
    principle of link and backlink allows the media controller to numerate entities,
    along with the possible and current links between entities, such as in the following
    diagram:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`mdev->topology_version`成员递增两次。链接和反向链接的原则允许媒体控制器对实体进行编号，以及实体之间可能的当前链接，如下图所示：
- en: '![Figure 8.2 – Media controller entity description'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 - 媒体控制器实体描述'
- en: '](img/Figure_8.2_B10985.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.2_B10985.jpg)'
- en: Figure 8.2 – Media controller entity description
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 - 媒体控制器实体描述
- en: In the preceding diagram, if we consider **Entity-1** and **Entity-2**, then
    **link** and **backlink** are essentially the same, except that **link** belongs
    to **Entity-1** and **backlink** belongs to **Entity-2**. You should then consider
    the backlink as a backup link. We can see that an entity can be either a sink,
    a source, or both.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，如果我们考虑**实体-1**和**实体-2**，那么**链接**和**反向链接**本质上是相同的，只是**链接**属于**实体-1**，**反向链接**属于**实体-2**。然后，应将反向链接视为备用链接。我们可以看到实体可以是接收器、源或两者兼而有之。
- en: The data structures we have introduced so far may make the media controller
    framework sound a bit scary. However, most of those data structures will be managed
    under the hood by the framework by means of the APIs it offers. That being said,
    the complete framework's documentation can be found in `Documentation/media-framework.txt`
    in the kernel sources.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们介绍的数据结构可能会让媒体控制器框架听起来有点可怕。但是，大多数这些数据结构将由框架通过其提供的API在幕后进行管理。也就是说，完整的框架文档可以在内核源代码中的`Documentation/media-framework.txt`中找到。
- en: Integrating media controller support in the driver
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在驱动程序中集成媒体控制器支持
- en: When the support of the media controller is needed, the V4L2 driver must first
    initialize `struct media_device` within `struct v4l2_device` using the `media_device_init()`
    function. Each entity driver must initialize its entities (actually `video_device->entity`
    or `v4l2_subdev->entity`) and its pad arrays using the `media_entity_pads_init()`
    function and, if needed, create pad-to-pad links using `media_create_pad_link()`.
    After that, entities can be registered. However, the V4L2 framework will handle
    this registration for you through either the `v4l2_device_register_subdev()` or
    the `video_register_device()` methods. In both cases, the underlying registration
    function that is invoked is `media_device_register_entity()`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要媒体控制器的支持时，V4L2驱动程序必须首先使用`media_device_init()`函数在`struct v4l2_device`中初始化`struct
    media_device`。每个实体驱动程序必须使用`media_entity_pads_init()`函数初始化其实体（实际上是`video_device->entity`或`v4l2_subdev->entity`）和其垫数组，并且如果需要，使用`media_create_pad_link()`创建垫到垫的链接。之后，实体可以注册。但是，V4L2框架将通过`v4l2_device_register_subdev()`或`video_register_device()`方法为您处理此注册。在这两种情况下，调用的底层注册函数是`media_device_register_entity()`。
- en: As a final step, the media device has to be registered using `media_device_register()`.
    It's worth mentioning that the media device registration should be postponed to
    later in the future when we are sure that every sub-device (or should I say entities)
    is registered and ready to be used. It definitely makes sense registering the
    media device in the root notifier's `.complete` callback.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是使用`media_device_register()`注册媒体设备。值得一提的是，媒体设备的注册应该延迟到将来的某个时间点，当我们确定每个子设备（或者我应该说实体）都已注册并准备好使用时。在根通知器的`.complete`回调中注册媒体设备绝对是有意义的。
- en: Initializing and registering pads and entities
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化和注册垫和实体
- en: 'The same function is used to initialize both the entity and its pad array:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的函数用于初始化实体及其垫数组：
- en: '[PRE36]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding prototype, `*entity` is the entity to which the pads to be
    registered belong, `*pads` is the array of pads to be registered, and `num_pads`
    is the number of entities in the array that should be registered. The driver must
    have set the type of every pad in the pads array before calling:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的原型中，`*entity`是要注册的垫所属的实体，`*pads`是要注册的垫数组，`num_pads`是应该注册的数组中的实体数。在调用之前，驱动程序必须设置垫数组中每个垫的类型：
- en: '[PRE37]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Drivers that need to unregister entities must call the following function on
    the entity to be unregistered:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注销实体的驱动程序必须在要注销的实体上调用以下函数：
- en: '[PRE38]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, in order for a driver to free resources associated with an entity, it
    should call the following:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了使驱动程序释放与实体关联的资源，应调用以下函数：
- en: '[PRE39]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When a media device is unregistered, all of its entities are unregistered automatically.
    No unregistration of manual entities is then required.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当媒体设备注销时，所有实体将自动注销。然后不需要注销手动实体。
- en: Media entity operations
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 媒体实体操作
- en: 'An entity may be provided link-related callbacks, so that these can be invoked
    by the media framework upon link creation and validation:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 实体可以提供链接相关的回调，以便媒体框架在链接创建和验证时调用这些回调：
- en: '[PRE40]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Providing the preceding structure is optional. However, there may be situations
    where additional stuff needs to be done or checked either at link setup or link
    validation. In this case, note the following descriptions:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 提供上述结构是可选的。但是，可能存在需要在链接设置或链接验证时执行或检查其他内容的情况。在这种情况下，请注意以下描述：
- en: '`get_fwnode_pad`: Returns the pad number based on a fwnode endpoint or a negative
    value on error. This operation can be used to map a fwnode to a media pad number
    (optional).'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_fwnode_pad`：根据fwnode端点返回垫号，或在错误时返回负值。此操作可用于将fwnode映射到媒体垫号（可选）。'
- en: '`link_setup`: Notifies the entity of link changes. This operation can return
    an error, in which case the link setup will be canceled (optional).'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`link_setup`：通知实体链接更改。此操作可能返回错误，在这种情况下，链接设置将被取消（可选）。'
- en: '`link_validate`: Returns whether a link is valid from the entity point of view.
    The `media_pipeline_start()` function validates all the links this entity is involved
    in by calling this operation. This member is optional. However, if it has not
    been set, then `v4l2_subdev_link_validate_default` will be used as the default
    callback function, which ensures that the source pad and sink pad width, height,
    and media bus pixels code are consistent; otherwise, it will return an error.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`link_validate`：返回链接是否从实体角度有效。`media_pipeline_start()`函数通过调用此操作验证此实体涉及的所有链接。此成员是可选的。但是，如果未设置，则将使用`v4l2_subdev_link_validate_default`作为默认回调函数，以确保源垫和接收垫的宽度、高度和媒体总线像素代码一致；否则，将返回错误。'
- en: The concept of a media bus
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 媒体总线的概念
- en: The main purpose of the media framework is to configure and control the pipeline
    and its entities. Video sub-devices, such as cameras and decoders, connect to
    video bridges or other sub-devices over specialized buses. Data is being transferred
    over these buses in various formats. That being said, in order for two entities
    to actually exchange data, their pad configs need to be the same.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体框架的主要目的是配置和控制管道及其实体。视频子设备（如摄像头和解码器）通过专用总线连接到视频桥或其他子设备。数据以各种格式通过这些总线传输。也就是说，为了使两个实体实际交换数据，它们的垫配置需要相同。
- en: Applications are responsible for configuring coherent parameters on the whole
    pipeline and ensuring that connected pads have compatible formats. The pipeline
    is checked for formats that are mismatching at `VIDIOC_STREAMON` time.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序负责在整个管道上配置一致的参数，并确保连接的垫有兼容的格式。在`VIDIOC_STREAMON`时间，管道将检查格式是否不匹配。
- en: The driver is responsible for applying the configuration of every block in the
    video pipeline according to the requested (from the user) format at the pipeline
    input and/or output.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序负责根据用户请求的（从用户）格式在管道输入和/或输出处应用每个块的配置。
- en: Take the following simple data flow, `sensor ---> CPHY ---> csi ---> isp --->
    stream`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 采用以下简单的数据流，`sensor ---> CPHY ---> csi ---> isp ---> stream`。
- en: 'In order for the media framework to be able to configure the bus prior to streaming
    data, the driver needs to provide some pad-level setter and getter for the media
    bus properties, which are present in the `struct v4l2_subdev_pad_ops` structure.
    This structure implements pad-level operations that have to be defined if the
    sub-device driver intends to process the video and integrate with the media framework.
    The following is its definition:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使媒体框架能够在流数据之前配置总线，驱动程序需要为媒体总线属性提供一些垫级别的设置器和获取器，这些属性包含在`struct v4l2_subdev_pad_ops`结构中。此结构实现了必须定义的垫级别操作，如果子设备驱动程序打算处理视频并与媒体框架集成，则必须定义这些操作。以下是其定义：
- en: '[PRE41]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following are the meanings of the members in this structure:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此结构中成员的含义：
- en: '`init_cfg`: Initializes the pad config to default values. This is the right
    place to initialize `cfg->try_fmt`, which can be grabbed through `v4l2_subdev_get_try_format()`.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init_cfg`：将垫配置初始化为默认值。这是初始化`cfg->try_fmt`的正确位置，可以通过`v4l2_subdev_get_try_format()`获取。'
- en: '`enum_mbus_code`: Callback for the `VIDIOC_SUBDEV_ENUM_MBUS_CODE` ioctl handler
    code. Enumerates the currently supported data format. This callback handles pixel
    format enumeration.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enum_mbus_code`：`VIDIOC_SUBDEV_ENUM_MBUS_CODE`ioctl处理程序代码的回调。枚举当前支持的数据格式。此回调处理像素格式枚举。'
- en: '`enum_frame_size`: Callback for the `VIDIOC_SUBDEV_ENUM_FRAME_SIZE` ioctl handler
    code. Enumerates the frame (image) size supported by the sub-device. Enumerates
    the currently supported resolution.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enum_frame_size`：`VIDIOC_SUBDEV_ENUM_FRAME_SIZE`ioctl处理程序代码的回调。枚举子设备支持的帧（图像）大小。列举当前支持的分辨率。'
- en: '`enum_frame_interval`: Callback for the `VIDIOC_SUBDEV_ENUM_FRAME_INTERVAL`
    ioctl handler code.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enum_frame_interval`：`VIDIOC_SUBDEV_ENUM_FRAME_INTERVAL`ioctl处理程序代码的回调。'
- en: '`get_fmt`: Callback for the `VIDIOC_SUBDEV_G_FMT` ioctl handler code.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_fmt`：`VIDIOC_SUBDEV_G_FMT`ioctl处理程序代码的回调。'
- en: '`set_fmt`: Callback for the `VIDIOC_SUBDEV_S_FMT` ioctl handler code. Sets
    the output data format and resolution.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_fmt`：`VIDIOC_SUBDEV_S_FMT`ioctl处理程序代码的回调。设置输出数据格式和分辨率。'
- en: '`get_selection`: Callback for the `VIDIOC_SUBDEV_G_SELECTION` ioctl handler
    code.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_selection`：`VIDIOC_SUBDEV_G_SELECTION`ioctl处理程序代码的回调。'
- en: '`set_selection`: Callback for the `VIDIOC_SUBDEV_S_SELECTION` ioctl handler
    code.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_selection`：`VIDIOC_SUBDEV_S_SELECTION`ioctl处理程序代码的回调。'
- en: '`link_validate`: Used by the media controller code to check whether the links
    that belong to a pipeline can be used for the stream.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`link_validate`：媒体控制器代码用于检查属于管道的链接是否可以用于流的函数。'
- en: 'The argument that all of these callbacks have in common is `cfg`, which is
    of the `struct v4l2_subdev_pad_config` type and is used for storing sub-device
    pad information. This structure is defined in `include/uapi/linux/v4l2-mediabus.h`
    as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些回调共同具有的参数是`cfg`，它是`struct v4l2_subdev_pad_config`类型，用于存储子设备垫信息。该结构在`include/uapi/linux/v4l2-mediabus.h`中定义如下：
- en: '[PRE42]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the preceding code block, the main field we are interested in is `try_fmt`,
    which is of the `struct v4l2_mbus_framefmt` type. This data structure is used
    to describe the pad-level media bus format and is defined as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们感兴趣的主要字段是`try_fmt`，它是`struct v4l2_mbus_framefmt`类型。这个数据结构用于描述媒体总线格式的垫级别，并定义如下：
- en: '[PRE43]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the preceding structure, `which` is the format type (try or active) and
    `pad` is the pad number as reported by the media API. This field is set by user
    space. `format` represents the frame format on the bus. The `format` term here
    means a combination of the media bus data format, frame width, and frame height.
    It is of the `struct v4l2_mbus_framefmt` type and its turn is defined as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的结构中，`which`是格式类型（尝试或活动），`pad`是媒体API报告的垫编号。这个字段由用户空间设置。`format`表示总线上的帧格式。这里的`format`术语表示媒体总线数据格式、帧宽度和帧高度的组合。它是`struct
    v4l2_mbus_framefmt`类型，其定义如下：
- en: '[PRE44]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding bus frame format data structure, only the fields that are relevant
    to us have been listed. `width` and `height`, respectively, represent the image
    width and height. `code` is from `enum v4l2_mbus_pixelcode` and represents the
    data format code. `field` indicates the used interlacing type, which should be
    from `enum v4l2_field`, and `colorspace` represents the color space of the data
    from `enum v4l2_colorspace`.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的总线帧格式数据结构中，只列出了对我们相关的字段。`width`和`height`分别表示图像宽度和高度。`code`来自`enum v4l2_mbus_pixelcode`，表示数据格式代码。`field`表示使用的隔行类型，应该来自`enum
    v4l2_field`，`colorspace`表示来自`enum v4l2_colorspace`的数据颜色空间。
- en: 'Now, let''s pay more attention to the `get_fmt` and `set_fmt` callbacks. They
    get and set, respectively, the data format on a sub-device pad. These ioctl handlers
    are used to negotiate the frame format at specific sub-device pads in the image
    pipeline. To set the current format applications, set the `.pad` field of `struct
    v4l2_subdev_format` to the desired pad number as reported by the media API and
    the `which` field (which is from `enum v4l2_subdev_format_whence`) to either `V4L2_SUBDEV_FORMAT_TRY`
    or `V4L2_SUBDEV_FORMAT_ACTIVE`, and issue a `VIDIOC_SUBDEV_S_FMT` ioctl with a
    pointer to this structure. This ioctl ends up calling the `v4l2_subdev_pad_ops->set_fmt`
    callback. If `which` is set to `V4L2_SUBDEV_FORMAT_TRY`, then the driver should
    set the `.try_fmt` field of the requested pad config with the values of the `try`
    format given in the argument. However, if `which` is set to `V4L2_SUBDEV_FORMAT_ACTIVE`,
    the driver must then apply the config to the device. It is common in this case
    to store the requested "active" format in a driver-state structure and apply it
    to the underlying device when the pipeline starts the stream. This way, the right
    place to actually apply the format config to the device is from within a callback
    invoked at the start of the streaming, such as `v4l2_subdev_video_ops.s_stream`,
    for example. The following is an example from the RCAR CSI driver:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更加关注`get_fmt`和`set_fmt`回调。它们分别获取和设置图像管道中子设备垫上的数据格式。这些ioctl处理程序用于协商图像管道中特定子设备垫的帧格式。要设置当前格式的应用程序，将`struct
    v4l2_subdev_format`的`.pad`字段设置为媒体API报告的所需垫编号，并将`which`字段（来自`enum v4l2_subdev_format_whence`）设置为`V4L2_SUBDEV_FORMAT_TRY`或`V4L2_SUBDEV_FORMAT_ACTIVE`，然后发出带有指向此结构的指针的`VIDIOC_SUBDEV_S_FMT`ioctl。这个ioctl最终会调用`v4l2_subdev_pad_ops->set_fmt`回调。如果`which`设置为`V4L2_SUBDEV_FORMAT_TRY`，那么驱动程序应该使用参数中给定的`try`格式的值设置请求的垫配置的`.try_fmt`字段。然而，如果`which`设置为`V4L2_SUBDEV_FORMAT_ACTIVE`，那么驱动程序必须将配置应用到设备上。在这种情况下，通常是在流开始时从回调中存储请求的“活动”格式，并将其应用到底层设备。因此，实际应用格式配置到设备的正确位置是在流开始时从回调中调用，例如`v4l2_subdev_video_ops.s_stream`。以下是RCAR
    CSI驱动程序的示例：
- en: '[PRE45]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Also, note that the driver is free to change the values in the requested format
    to the one it actually supports. It is then up to the application to check for
    it and adapt its logic according to the format granted by the driver. Modifying
    those `try` formats leaves the device state untouched.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，驱动程序可以自由更改请求格式中的值为其实际支持的值。然后由应用程序来检查并根据驱动程序授予的格式调整其逻辑。修改这些`try`格式不会改变设备状态。
- en: 'On the other hand, when it comes to retrieving the current format, applications
    should do the same as the preceding and issue a `VIDIOC_SUBDEV_G_FMT` ioctl. This
    ioctl will end up calling the `v4l2_subdev_pad_ops->get_fmt` callback. The driver
    fills the members of the `format` field either with the currently active format
    values or with the last `try` format stored (most of the time in the driver-state
    structure):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当涉及检索当前格式时，应用程序应该像前面一样发出`VIDIOC_SUBDEV_G_FMT`ioctl。这个ioctl最终会调用`v4l2_subdev_pad_ops->get_fmt`回调。驱动程序将使用当前活动格式值或上次存储的`try`格式填充`format`字段的成员（大多数情况下在驱动程序状态结构中）：
- en: '[PRE46]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It is obvious that the `.try_fmt` field of the pad config should have been
    initialized before it can be passed to the `get` callback for the first time,
    and the `v4l2_subdev_pad_ops.init_cfg` callback is the right place for this initialization,
    as in the following example:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，在第一次传递给`get`回调之前，垫配置的`.try_fmt`字段应该已经初始化，`v4l2_subdev_pad_ops.init_cfg`回调是进行此初始化的正确位置，如下例所示：
- en: '[PRE47]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Important note
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'The list of supported formats can be found in `include/uapi/linux/videodev2.h`
    from the kernel source, and part of their documentation is available at this link:
    [https://linuxtv.org/downloads/v4l-dvb-apis/userspace-api/v4l/subdev-formats.html](https://linuxtv.org/downloads/v4l-dvb-apis/userspace-api/v4l/subdev-formats.html).'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的格式列表可以在内核源码的`include/uapi/linux/videodev2.h`中找到，它们的部分文档可以在此链接找到：[https://linuxtv.org/downloads/v4l-dvb-apis/userspace-api/v4l/subdev-formats.html](https://linuxtv.org/downloads/v4l-dvb-apis/userspace-api/v4l/subdev-formats.html)。
- en: Now that we are familiar with the concept of media, we can learn how to finally
    make the media device part of the system by using the appropriate API to register
    it.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了媒体的概念，我们可以学习如何最终通过适当的API将媒体设备纳入系统。
- en: Registering the media device
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册媒体设备
- en: Drivers register media device instances by calling `__media_device_register()`
    via the `media_device_register()` macro and unregister them by calling `media_device_unregister()`.
    Upon successful registration, a character device named `media[0-9] +` will be
    created. The device major and minor numbers are dynamic. `media_device_register()`
    accepts a pointer to the media device to be registered and returns `0` on success
    or a negative error code on error.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序通过调用`media_device_register()`宏中的`__media_device_register()`来注册媒体设备实例，并通过调用`media_device_unregister()`来注销它们。成功注册后，将创建一个名为`media[0-9]
    +`的字符设备。设备的主要和次要编号是动态的。`media_device_register()`接受要注册的媒体设备的指针，并在成功时返回`0`，在错误时返回负错误代码。
- en: 'As we said earlier, you''re better off registering the media device from within
    the root notifier''s `.complete` callback in order to make sure that the actual
    media device is registered only after all its entities have been probed. The following
    is an excerpt from the TI OMAP3 ISP media driver (the whole code can be found
    in `drivers/media/platform/omap3isp/isp.c` in the kernel sources):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，最好在根notifier的`.complete`回调中注册媒体设备，以确保实际的媒体设备只有在所有实体被探测后才注册。以下是TI OMAP3
    ISP媒体驱动程序的摘录（整个代码可以在内核源码的`drivers/media/platform/omap3isp/isp.c`中找到）：
- en: '[PRE48]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The preceding code shows how you can take benefit of the root notifier's `.complete`
    callback to register the final media device, by means of the `media_device_register()`
    method.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了如何利用根notifier的`.complete`回调来注册最终的媒体设备，通过`media_device_register()`方法。
- en: Now that the media device is part of the system, the time has come to leverage
    it, particularly from user space. Let's now see how, from the command line, we
    can take control of and interact with the media device.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 既然媒体设备已经成为系统的一部分，现在是时候利用它了，特别是从用户空间。现在让我们看看如何从命令行控制和与媒体设备交互。
- en: Media controller from user space
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来自用户空间的媒体控制器
- en: Though it remains the streaming interface, `/dev/video0` is not the default
    pipeline centerpiece anymore since it is wrapped by `/dev/mediaX`. The pipeline
    can be configured through the media node (`/dev/media*`), and the control operations,
    such as stream on/off, can be performed through the video node (`/dev/video*`).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它仍然是流接口，但`/dev/video0`不再是默认的管道中心，因为它被`/dev/mediaX`所包裹。管道可以通过媒体节点（`/dev/media*`）进行配置，并且控制操作，如流开/关，可以通过视频节点（`/dev/video*`）执行。
- en: Using media-ctl (the v4l-utils package)
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用media-ctl（v4l-utils软件包）
- en: 'The `media-ctl` application from the `v4l-utils` package is a user space application
    that uses the Linux media controller API to configure pipelines. The following
    are the flags to use with it:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`v4l-utils`软件包中的`media-ctl`应用程序是一个用户空间应用程序，它使用Linux媒体控制器API来配置管道。以下是与其一起使用的标志：'
- en: '`--device <dev>` specifies the media device (`/dev/media0` by default).'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--device <dev>`指定媒体设备（默认为`/dev/media0`）。'
- en: '`--entity <name>` prints the device name associated with the given entity.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--entity <name>`打印与给定实体相关联的设备名称。'
- en: '`--set-v4l2 <v4l2>` provides a comma-separated list of formats to set up.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--set-v4l2 <v4l2>`提供一个逗号分隔的格式列表进行设置。'
- en: '`--get-v4l2 <pad>` prints an active format on a given pad.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--get-v4l2 <pad>`打印给定pad上的活动格式。'
- en: '`--set-dv <pad>` configures DV timings on a given pad.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--set-dv <pad>`在给定的pad上配置DV定时。'
- en: '`--interactive` modifies links interactively.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--interactive`交互修改链接。'
- en: '`--links <linux>` provides a comma-separated list of link descriptors to set
    up.'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--links <linux>`提供一个逗号分隔的链接描述符列表进行设置。'
- en: '`--known-mbus-fmts` lists known formats and their numeric values.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--known-mbus-fmts`列出已知格式及其数值。'
- en: '`--print-topology` prints the device topology, or the short version, `-p`.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--print-topology`打印设备拓扑，或者使用简短版本`-p`。'
- en: '`--reset` resets all links to inactive.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--reset`重置所有链接为非活动状态。'
- en: 'That being said, the basic configuration steps for a hardware media pipeline
    are as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，硬件媒体管道的基本配置步骤如下：
- en: Reset all links with `media-ctl --reset`.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`media-ctl --reset`重置所有链接。
- en: Configure links with `media-ctl --links`.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`media-ctl --links`配置链接。
- en: Configure pad formats with `media-ctl --set-v4l2`.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`media-ctl --set-v4l2`配置pad格式。
- en: Configure sub-device properties with `v4l2-ctl` capture frames on the `/dev/video*`
    device.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`v4l2-ctl`配置子设备属性捕获`/dev/video*`设备上的帧。
- en: 'Using `media-ctl --links` to link an entity source pad to an entity sink pad
    should follow the following pattern:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`media-ctl --links`将实体源pad链接到实体接收pad应该遵循以下模式：
- en: '[PRE49]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the preceding line, `flags` can be either `0` (inactive) or `1` (active).
    Additionally, to see the current settings of the media bus, use the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一行中，`flags`可以是`0`（非活动）或`1`（活动）。此外，要查看媒体总线的当前设置，请使用以下命令：
- en: '[PRE50]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'On some systems, media device `0` may not be the default one, in which case
    you should use the following:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些系统上，媒体设备`0`可能不是默认设备，这种情况下，您应该使用以下方法：
- en: '[PRE51]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The previous command would print the media topology associated with the specified
    media device.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将打印与指定媒体设备相关联的媒体拓扑。
- en: 'Do note that `--print-topology` just dumps the media topology on the console
    in an ASCII format. However, this topology can be better represented by generating
    its `dot` representation, changing this representation into a graphic image that
    is more human-friendly. The following are the commands to use:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`--print-topology`只是以ASCII格式在控制台上转储媒体拓扑。但是，通过生成其`dot`表示形式，将此拓扑转换为更加人性化的图像更好地表示。以下是使用的命令：
- en: '[PRE52]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'For example, in order to set up a media pipe, the following commands have been
    run on an UDOO QUAD board. The board has been shipped with an i.MX6 quad core
    and an OV5640 camera plugged into the MIPI CSI-2 connector:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了设置媒体管道，在UDOO QUAD开发板上运行了以下命令。该板已配备i.MX6四核和插入MIPI CSI-2连接器的OV5640摄像头：
- en: '[PRE53]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following is a diagram representing the preceding setup:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是表示前述设置的图表：
- en: '![Figure 8.3 – Graph representation of a media device'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 - 媒体设备的图形表示'
- en: '](img/Figure_8.3_B10985.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.3_B10985.jpg)'
- en: Figure 8.3 – Graph representation of a media device
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 - 媒体设备的图形表示
- en: 'As you can see, it helps to visualize what the hardware components are. The
    following are descriptions of these generated images:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它有助于可视化硬件组件是什么。以下是这些生成图像的描述：
- en: Dashed lines show possible connections. You can use these to determine the possibilities.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚线表示可能的连接。您可以使用这些来确定可能性。
- en: Solid lines show active connections.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实线表示活动连接。
- en: Green boxes show media entities.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色框表示媒体实体。
- en: Yellow boxes show **Video4Linux** (**V4L**) endpoints.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黄色框表示**Video4Linux** (**V4L**)端点。
- en: 'After that, you can see that solid lines correspond exactly to the setup that
    was done earlier. We have five solid lines, which correspond to the number of
    commands used to configure the media device. The following are the meanings of
    these commands:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您可以看到实线与之前进行的设置完全对应。我们有五条实线，对应于用于配置媒体设备的命令数量。以下是这些命令的含义：
- en: '`media-ctl -l "''ov5640 2-003c'':0 -> ''imx6-mipi-csi2'':0[1]"` means linking
    output pad number `0` of the camera sensor (`''ov5640 2-003c'':0`) to MIPI CSI-2
    input pad number `0` (`''imx6-mipi-csi2'':0`) and setting this link active (`[1]`).'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`media-ctl -l "''ov5640 2-003c'':0 -> ''imx6-mipi-csi2'':0[1]"`表示将摄像头传感器(`''ov5640
    2-003c'':0`)的输出端口号`0`连接到MIPI CSI-2的输入端口号`0`(`''imx6-mipi-csi2'':0`)，并设置此链接为活动(`[1]`)。'
- en: '`media-ctl -l "''imx6-mipi-csi2'':2 -> ''ipu1_csi1'':0[1]"` means linking output
    pad number `2` of the MIPI CSI-2 entity (`''imx6-mipi-csi2'':2`) to the input
    pad number `0` of the IPU capture sensor interface #1 (`'' ipu1_csi1'':0`) and
    setting this link active (`[1]`).'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`media-ctl -l "''imx6-mipi-csi2'':2 -> ''ipu1_csi1'':0[1]"`表示将MIPI CSI-2实体(`''imx6-mipi-csi2'':2`)的输出接口号`2`连接到IPU捕获传感器接口#1(`''ipu1_csi1'':0`)的输入接口号`0`，并设置此链接为活动(`[1]`)。'
- en: The same decoding rules apply to other command lines, until the last one, `media-ctl
    -l "'ipu1_ic_prpenc':1 -> 'ipu1_ic_prpenc capture':0[1]"`, which means linking
    output pad number `1` of `ipu1`'s image converter preprocessing encode entity
    (`'ipu1_ic_prpenc':1`) to the capture interface input pad number `0` and setting
    this link to active.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的解码规则适用于其他命令行，直到最后一个命令`media-ctl -l "'ipu1_ic_prpenc':1 -> 'ipu1_ic_prpenc
    capture':0[1]"`，表示将`ipu1`的图像转换器预处理编码实体(`'ipu1_ic_prpenc':1`)的输出端口号`1`连接到捕获接口的输入端口号`0`，并将此链接设置为活动状态。
- en: Do not hesitate to go back to the image and read those descriptions several
    times in order to understand the concepts of entity, link, and pad.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 请随时返回图像并多次阅读这些描述，以便理解实体、链接和端口的概念。
- en: Important note
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If the `dot` package is not installed on your target, you can download the `.dot`
    file on your host (assuming it has the package installed) and convert it into
    an image.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的目标设备上未安装`dot`软件包，您可以在主机上下载`.dot`文件（假设主机已安装该软件包）并将其转换为图像。
- en: WaRP7 with an OV2680 example
  id: totrans-418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带有OV2680的WaRP7示例
- en: 'The WaRP7 is an i.MX7-based board, which, unlike the i.MX5/6 family, does not
    contain an IPU. Because of this, there are fewer capabilities to perform operations
    or manipulation of the capture frames. The i.MX7 image capture chain is made up
    of three units: the camera censor interface, the video multiplexer, and the MIPI
    CSI-2 receiver, which represent the media entities, described as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: WaRP7是一款基于i.MX7的开发板，与i.MX5/6系列不同，它不包含IPU。因此，执行操作或处理捕获帧的能力较少。i.MX7图像捕获链由三个单元组成：摄像头传感器接口、视频多路复用器和MIPI
    CSI-2接收器，它们表示为以下媒体实体：
- en: '`imx7-mipi-csi2`: This is the MIPI CSI-2 receiver entity. It has one sink pad
    to receive the pixel data from the MIPI CSI-2 camera sensor. It has one source
    pad, corresponding to virtual channel `0`.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imx7-mipi-csi2`：这是MIPI CSI-2接收器实体。它有一个接收来自MIPI CSI-2摄像头传感器的像素数据的接收端口。它有一个源端口，对应虚拟通道`0`。'
- en: '`csi_mux`: This is the video multiplexer. It has two sink pads to select from
    either camera sensors with a parallel interface or MIPI CSI-2 virtual channel
    `0`. It has a single source pad that routes to the CSI.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`csi_mux`：这是视频多路复用器。它有两个接收端口，可以从具有并行接口或MIPI CSI-2虚拟通道`0`的摄像头传感器中选择。它有一个源端口，路由到CSI。'
- en: '`csi`: The CSI allows the chip to connect directly to the external CMOS image
    sensor. The CSI can interface directly with parallel and MIPI CSI-2 buses. It
    has 256 x 64 FIFO to store received image pixel data and embedded DMA controllers
    to transfer data from the FIFO through the AHB bus. This entity has one sink pad
    that receives from the `csi_mux` entity and a single source pad that routes video
    frames directly to memory buffers. This pad is routed to a capture device node:'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`csi`：CSI允许芯片直接连接到外部CMOS图像传感器。CSI可以直接与并行和MIPI CSI-2总线进行接口。它有256 x 64 FIFO来存储接收到的图像像素数据，并嵌入DMA控制器通过AHB总线从FIFO传输数据。此实体有一个接收端口，从`csi_mux`实体接收，一个源端口，直接路由视频帧到内存缓冲区。此端口路由到捕获设备节点：'
- en: '[PRE54]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'On this platform, an OV2680 MIPI CSI-2 module is connected to the internal
    MIPI CSI-2 receiver. The following example configures a video capture pipeline
    with an output of 800 x 600 in BGGR 10-bit Bayer format:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在此平台上，OV2680 MIPI CSI-2模块连接到内部MIPI CSI-2接收器。以下示例配置了一个输出为800 x 600的BGGR 10位Bayer格式的视频捕获管道：
- en: '[PRE55]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding lines could be merged into one single command, as follows:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行可以合并为一个单一的命令，如下所示：
- en: '[PRE56]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the preceding commands, note the following:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，请注意以下内容：
- en: '`-r` means reset all links to inactive.'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-r`表示重置所有链接为非活动状态。'
- en: '`-l` sets up links in a comma-separated list of the links'' descriptors.'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-l`：在逗号分隔的链接描述符列表中设置链接。'
- en: '`"ov2680 1-0036":0->"imx7-mipi-csis.0":0[1]` links output pad number `0` of
    the camera sensor to MIPI CSI-2 input pad number `0` and sets this link to active.'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"ov2680 1-0036":0->"imx7-mipi-csis.0":0[1]` 将摄像头传感器的输出端口号`0`链接到MIPI CSI-2输入端口号`0`，并将此链接设置为活动状态。'
- en: '`"csi_mux":2->"csi":0[1]` links output pad number `2` of `csi_mux` to `csi`
    input pad number `0` and sets this link to active.'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"csi_mux":2->"csi":0[1]` 将`csi_mux`的输出端口号`2`链接到`csi`的输入端口号`0`，并将此链接设置为活动状态。'
- en: '`"csi":1->"csi capture":0[1]` links output pad number `1` of `csi` to capture
    the interface''s input pad number `0` and sets this link to active.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"csi":1->"csi capture":0[1]` 将`csi`的输出端口号`1`链接到捕获接口的输入端口号`0`，并将此链接设置为活动状态。'
- en: 'In order to configure the format on each pad, we can use the following commands:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在每个端口上配置格式，我们可以使用以下命令：
- en: '[PRE57]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Once again, the preceding command lines could be merged into a single command,
    as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，前面的命令行可以合并为一个单一的命令，如下所示：
- en: '[PRE58]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding command lines could be translated as follows:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令行可以翻译如下：
- en: '`-f`: Sets up pad formats into a comma-separated list of format descriptors.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`：将端口格式设置为逗号分隔的格式描述符列表。'
- en: '`"ov2680 1-0036":0 [SGRBG10 800x600 (32,20)/800x600]`: Sets up the camera sensor
    pad number `0` format to a RAW Bayer 10-bit image with a resolution (capture size)
    of 800 x 600\. Sets the maximum allowed sensor window width by specifying the
    crop rectangle.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"ov2680 1-0036":0 [SGRBG10 800x600 (32,20)/800x600]`: 将摄像头传感器端口号`0`的格式设置为800
    x 600的RAW Bayer 10位图像。设置最大允许的传感器窗口宽度，指定裁剪矩形。'
- en: '`"csi_mux":1 [SGRBG10 800x600]`: Sets up the `csi_mux` pad number `1` format
    to a RAW Bayer 10-bit image with a resolution of 800 x 600.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"csi_mux":1 [SGRBG10 800x600]`：将`csi_mux`端口号`1`的格式设置为800 x 600的RAW Bayer 10位图像。'
- en: '`"csi_mux":2 [SGRBG10 800x600]`: Sets up the `csi_mux` pad number `2` format
    to a RAW Bayer 10-bit image with a resolution of 800 x 600.'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"csi_mux":2 [SGRBG10 800x600]`: 将`csi_mux`端口号`2`的格式设置为800 x 600的RAW Bayer
    10位图像。'
- en: '`"csi":0 [UYVY 800x600]`: Sets up the `csi` pad number `0` format to a `YUV4:2:2`
    image with a resolution of 800 x 600.'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"csi":0 [UYVY 800x600]`: 将`csi`端口号`0`的格式设置为分辨率为800 x 600的`YUV4:2:2`图像。'
- en: '`video_mux`, `csi`, and `mipi-csi-2` are all part of the SoC, so they are declared
    in the vendor `dtsi` file (that is, `arch/arm/boot/dts/imx7s.dtsi` in the kernel
    sources). `video_mux` is declared as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`video_mux`，`csi`和`mipi-csi-2`都是SoC的一部分，因此它们在供应商`dtsi`文件中声明（即内核源代码中的`arch/arm/boot/dts/imx7s.dtsi`）。`video_mux`声明如下：'
- en: '[PRE59]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the preceding code block, we have three ports, where ports `1` are `2` are
    connected to remote endpoints. `csi` and `mipi-csi-2` are declared as follows:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们有三个端口，其中端口`1`和`2`连接到远程端点。`csi`和`mipi-csi-2`声明如下：
- en: '[PRE60]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: From the `csi` and `mipi-csi-2` nodes, we can see how they are linked to their
    remote ports in the `video_mux` node.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 从`csi`和`mipi-csi-2`节点，我们可以看到它们如何链接到`video_mux`节点中的远程端口。
- en: Important note
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: More information on `video_mux` binding can be found in `Documentation/devicetree/bindings/media/video-mux.txt`
    in the kernel sources.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`video_mux`绑定的更多信息可以在内核源代码中的`Documentation/devicetree/bindings/media/video-mux.txt`中找到。
- en: 'However, most of the vendor-declared nodes are disabled by default, and need
    to be enabled from within the board file (the `dts` file, actually). This is what
    is done in the following code block. Moreover, the camera sensor is part of the
    board, not the SoC. So, it needs to be declared in the board `dts` file, which
    is `arch/arm/boot/dts/imx7s-warp.dts` in kernel sources. The following is an excerpt:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数供应商声明的节点默认情况下是禁用的，需要在板文件（实际上是`dts`文件）中启用。这就是下面的代码块所做的。此外，摄像头传感器是板的一部分，而不是SoC的一部分。因此，需要在板`dts`文件中声明它，即内核源代码中的`arch/arm/boot/dts/imx7s-warp.dts`。以下是摘录：
- en: '[PRE61]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Important note
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: More on i.MX7 entity binding can be found in both `Documentation/devicetree/bindings/media/imx7-csi.txt`
    and `Documentation/devicetree/bindings/media/imx7-mipi-csi2.txt` in the kernel
    sources.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 有关i.MX7实体绑定的更多信息可以在内核源代码中的`Documentation/devicetree/bindings/media/imx7-csi.txt`和`Documentation/devicetree/bindings/media/imx7-mipi-csi2.txt`中找到。
- en: 'After this, the streaming can start. The `v4l2-ctl` tool can be used to select
    any of the resolutions supported by the sensor:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，流媒体可以开始。`v4l2-ctl`工具可用于选择传感器支持的任何分辨率：
- en: '[PRE62]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As data streams from left to right, we can interpret the preceding console
    logs as follows:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据从左到右流动，我们可以将前面的控制台日志解释如下：
- en: '`-> "imx7-mipi-csis.0":0 [ENABLED]`: This source pad feeds data to the entity
    on its right, which is `"imx7-mipi-csis.0":0`.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-> "imx7-mipi-csis.0":0 [ENABLED]`: 此源端口向其右侧的实体提供数据，该实体是`"imx7-mipi-csis.0":0`。'
- en: '`<- "ov2680 1-0036":0 [ENABLED]`: This sink pad is fed by (that is, it queries
    data from) the entity to its left, which is `"ov2680 1-0036":0`.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<- "ov2680 1-0036":0 [ENABLED]`: 此接收端口由其左侧的实体提供数据（即，它从左侧查询数据），该实体是`"ov2680
    1-0036":0`。'
- en: We are now done with all the aspects of the media controller framework. We started
    with its architecture, then described the data structure it is made of, and then
    learned about its API in detail. We ended with its use from user space in order
    to leverage the mode media pipe.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了媒体控制器框架的所有方面。我们从其架构开始，然后详细描述了它的数据结构，然后详细了解了其API。最后，我们以用户空间中的使用方式结束，以利用模式媒体管道。
- en: Summary
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the V4L2 asynchronous interface, which eases
    video bridge and sub-device driver probing. This is useful for intrinsically asynchronous
    and unordered device registration systems, such as flattened device tree driver
    probing. Moreover, we dealt with the media controller framework, which allows
    leveraging V4L2 video pipelines. What we have seen so far lies in the kernel space.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过了V4L2异步接口，这简化了视频桥和子设备驱动程序的探测。这对于固有异步和无序设备注册系统非常有用，比如扁平设备树驱动程序的探测。此外，我们处理了媒体控制器框架，它允许利用V4L2视频管道。到目前为止，我们所看到的都是在内核空间中。
- en: In the next chapter, we will see how to deal with V4L2 devices from user space,
    thus leveraging features exposed by their device drivers.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何从用户空间处理V4L2设备，从而利用其设备驱动程序提供的功能。
