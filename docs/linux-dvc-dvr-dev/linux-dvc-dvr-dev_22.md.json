["```\n#include <linux/skbuff.h>  \n```", "```\n#include <linux/netdevice.h> \n```", "```\n#include <linux/ethtool.h>  \n#include <linux/etherdevice.h> \n```", "```\nstruct sk_buff { \n  struct sk_buff * next; \n  struct sk_buff * prev; \n  ktime_t tstamp; \n  struct rb_node     rbnode; /* used in netem & tcp stack */ \n  struct sock * sk; \n  struct net_device * dev; \n  unsigned int       len; \n  unsigned int       data_len; \n  __u16              mac_len; \n  __u16              hdr_len; \n  unsigned int len; \n  unsigned int data_len; \n  __u16 mac_len; \n  __u16 hdr_len; \n  __u32 priority; \n  dma_cookie_t dma_cookie; \n  sk_buff_data_t tail; \n  sk_buff_data_t end; \n  unsigned char * head; \n  unsigned char * data; \n  unsigned int truesize; \n  atomic_t users; \n}; \n```", "```\nstruct sk_buff *netdev_alloc_skb(struct net_device *dev, \n                                   unsigned int length) \n```", "```\n#define NET_IP_ALIGN 2 \n```", "```\nvoid skb_reserve(struct sk_buff *skb, int len) \n```", "```\nunsigned char *skb_put(struct sk_buff *skb, unsigned int len) \n```", "```\nint netif_rx_ni(struct sk_buff *skb) \n```", "```\nstruct net_device { \n   char name[IFNAMSIZ]; \n   char *ifalias; \n   unsigned long mem_end; \n   unsigned long mem_start; \n   unsigned long base_addr; \n   int irq; \n   netdev_features_t features; \n   netdev_features_t hw_features; \n   netdev_features_t  wanted_features; \n   int ifindex; \n   struct net_device_stats stats; \n   atomic_long_t rx_dropped; \n   atomic_long_t  tx_dropped; \n   const struct net_device_ops *netdev_ops; \n   const struct ethtool_ops *ethtool_ops; \n   unsigned int flags; \n   unsigned int priv_flags; \n   unsigned char link_mode; \n      unsigned char if_port; \n   unsigned char dma; \n   unsigned int mtu; \n   unsigned short type; \n   /* Interface address info. */ \n   unsigned char perm_addr[MAX_ADDR_LEN]; \n   unsigned char addr_assign_type; \n   unsigned char addr_len; \n   unsigned short neigh_priv_len; \n   unsigned short dev_id; \n   unsigned short dev_port; \n   unsigned long last_rx; \n   /* Interface address info used in eth_type_trans() */ \n   unsigned char *dev_addr; \n\n   struct device dev; \n   struct phy_device *phydev; \n}; \n```", "```\nstruct net_device *alloc_etherdev(int sizeof_priv); \n```", "```\nvoid *netdev_priv(const struct net_device *dev) \n```", "```\nstruct net_device *net_dev; \nstruct priv_struct *priv_net_struct; \nnet_dev = alloc_etherdev(sizeof(struct priv_struct)); \nmy_priv_struct = netdev_priv(dev); \n```", "```\nvoid free_netdev(struct net_device *dev) \n```", "```\nint register_netdev(struct net_device *dev) \n```", "```\nstruct net_device_ops { \n   int (*ndo_init)(struct net_device *dev); \n   void (*ndo_uninit)(struct net_device *dev); \n   int (*ndo_open)(struct net_device *dev); \n   int (*ndo_stop)(struct net_device *dev); \n   netdev_tx_t (*ndo_start_xmit) (struct sk_buff *skb, \n                              struct net_device *dev); \n   void (*ndo_change_rx_flags)(struct net_device *dev, int flags); \n   void (*ndo_set_rx_mode)(struct net_device *dev); \n   int (*ndo_set_mac_address)(struct net_device *dev, void *addr); \n   int (*ndo_validate_addr)(struct net_device *dev); \n   int (*ndo_do_ioctl)(struct net_device *dev, \n                             struct ifreq *ifr, int cmd); \n   int (*ndo_set_config)(struct net_device *dev, struct ifmap *map); \n   int (*ndo_change_mtu)(struct net_device *dev, int new_mtu); \n   void (*ndo_tx_timeout) (struct net_device *dev); \n\n   struct net_device_stats* (*ndo_get_stats)( \n   struct net_device *dev); \n}; \n```", "```\n/* \n * This routine should set everything up new at each open, even \n * registers that should only need to be set once at boot, so that \n * there is non-reboot way to recover if something goes wrong. \n */ \nstatic int enc28j60_net_open(struct net_device *dev) \n{ \n   struct priv_net_struct *priv = netdev_priv(dev); \n\n   if (!is_valid_ether_addr(dev->dev_addr)) { \n         [...] /* Maybe print a debug message ? */ \n         return -EADDRNOTAVAIL; \n   } \n   /* \n * Reset the hardware here and take it out of low \n * power mode \n */ \n   my_netdev_lowpower(priv, false); \n\n   if (!my_netdev_hw_init(priv)) { \n         [...] /* handle hardware reset failure */ \n         return -EINVAL; \n   } \n\n   /* Update the MAC address (in case user has changed it) \n    * The new address is stored in netdev->dev_addr field \n */ \nset_hw_macaddr_registers(netdev, MAC_REGADDR_START, \nnetdev->addr_len, netdev->dev_addr); \n\n   /* Enable interrupts */ \n   my_netdev_hw_enable(priv); \n\n   /* We are now ready to accept transmit requests from \n    * the queueing layer of the networking. \n    */ \n   netif_start_queue(dev); \n\n   return 0; \n} \n```", "```\n/* The inverse routine to net_open(). */ \nstatic int enc28j60_net_close(struct net_device *dev) \n{ \n   struct priv_net_struct *priv = netdev_priv(dev); \n\n   my_netdev_hw_disable(priv); \n   my_netdev_lowpower(priv, true); \n\n    /** \n     *   netif_stop_queue - stop transmitted packets \n     * \n     *   Stop upper layers calling the device ndo_start_xmit routine. \n     *   Used for flow control when transmit resources are unavailable. \n     */ \n   netif_stop_queue(dev); \n\n   return 0; \n} \n```", "```\n/* \n * RX handler \n * This function is called in the work responsible of packet \n * reception (bottom half) handler. We use work because access to  \n * our device (which sit on a SPI bus) may sleep \n */ \nstatic int my_rx_interrupt(struct net_device *ndev) \n{ \n   struct priv_net_struct *priv = netdev_priv(ndev); \n   int pk_counter, ret; \n\n   /* Let's get the number of packet our device received */ \n   pk_counter = my_device_reg_read(priv, REG_PKT_CNT); \n\n   if (pk_counter > priv->max_pk_counter) { \n         /* update statistics */ \n         priv->max_pk_counter = pk_counter; \n   } \n   ret = pk_counter; \n\n   /* set receive buffer start */ \n   priv->next_pk_ptr = KNOWN_START_REGISTER; \n   while (pk_counter-- > 0) \n         /*  \n* By calling this internal helper function in a \"while\" \n* loop, packets get extracted one by one from the device \n* and forwarder to the network layer.  \n*/ \n         my_hw_rx(ndev); \n\n   return ret; \n} \n```", "```\n/* \n * Hardware receive function. \n * Read the buffer memory, update the FIFO pointer to \n * free the buffer. \n * This function decrements the packet counter. \n */ \nstatic void my_hw_rx(struct net_device *ndev) \n{ \n   struct priv_net_struct *priv = netdev_priv(ndev); \n   struct sk_buff *skb = NULL; \n   u16 erxrdpt, next_packet, rxstat; \n   u8 rsv[RSV_SIZE]; \n   int packet_len; \n\n   packet_len = my_device_read_current_packet_size(); \n   /* Can't cross boundaries */ \n   if ((priv->next_pk_ptr > RXEND_INIT)) { \n         /* packet address corrupted: reset RX logic */ \n         [...] \n         /* Update RX errors stats */ \n         ndev->stats.rx_errors++; \n         return; \n   } \n   /* Read next packet pointer and rx status vector \n    * This is device-specific \n    */ \n   my_device_reg_read(priv, priv->next_pk_ptr, sizeof(rsv), rsv); \n\n   /* Check for errors in the device RX status reg, \n    * and update error stats accordingly \n    */ \n   if(an_error_is_detected_in_device_status_registers()) \n         /* Depending on the error, \n          * stats.rx_errors++; \n          * ndev->stats.rx_crc_errors++; \n          * ndev->stats.rx_frame_errors++; \n          * ndev->stats.rx_over_errors++; \n          */ \n   } else { \n         skb = netdev_alloc_skb(ndev, len + NET_IP_ALIGN); \n         if (!skb) { \n               ndev->stats.rx_dropped++; \n         } else { \n               skb_reserve(skb, NET_IP_ALIGN); \n               /* \n                 * copy the packet from the device' receive buffer \n                 * to the socket buffer data memory. \n                 * Remember skb_put() return a pointer to the \n                 * beginning of data region. \n                 */ \n               my_netdev_mem_read(priv, \n                     rx_packet_start(priv->next_pk_ptr), \n                     len, skb_put(skb, len)); \n\n               /* Set the packet's protocol ID */ \n               skb->protocol = eth_type_trans(skb, ndev); \n               /* update RX statistics */ \n               ndev->stats.rx_packets++; \n               ndev->stats.rx_bytes += len; \n\n               /* Submit socket buffer to the network layer */ \n               netif_rx_ni(skb); \n         } \n   } \n   /* Move the RX read pointer to the start of the next \n    * received packet. \n    */ \n   priv->next_pk_ptr = my_netdev_update_reg_next_pkt(); \n} \n```", "```\nvoid netif_stop_queue(struct net_device *dev) \n```", "```\nvoid netif_wake_queue(struct net_device *dev) \n```", "```\n/* Somewhere in the code */ \nINIT_WORK(&priv->tx_work, my_netdev_hw_tx); \n\nstatic netdev_tx_t my_netdev_start_xmit(struct sk_buff *skb, \n                           struct net_device *dev) \n{ \n   struct priv_net_struct *priv = netdev_priv(dev); \n\n   /* Notify the kernel our device will be busy */ \n   netif_stop_queue(dev); \n\n   /* Remember the skb for deferred processing */ \n   priv->tx_skb = skb; \n\n   /* This work will copy data from sk_buffer->data to \n    * the hardware's FIFO and start transmission \n    */ \n   schedule_work(&priv->tx_work); \n\n   /* Everything is OK */ \n   return NETDEV_TX_OK; \n} \nThe work is described below: \n/* \n * Hardware transmit function. \n * Fill the buffer memory and send the contents of the \n * transmit buffer onto the network \n */ \nstatic void my_netdev_hw_tx(struct priv_net_struct *priv) \n{ \n   /* Write packet to hardware device TX buffer memory */ \n   my_netdev_packet_write(priv, priv->tx_skb->len, \npriv->tx_skb->data); \n\n/*  \n * does this network device support write-verify? \n * Perform it  \n */ \n[...]; \n\n   /* set TX request flag, \n * so that the hardware can perform transmission. \n * This is device-specific \n */ \n   my_netdev_reg_bitset(priv, ECON1, ECON1_TXRTS); \n} \n```", "```\n#include <linux/module.h> \n#include <linux/kernel.h> \n#include <linux/errno.h> \n#include <linux/init.h> \n#include <linux/netdevice.h> \n#include <linux/etherdevice.h> \n#include <linux/ethtool.h> \n#include <linux/skbuff.h> \n#include <linux/slab.h> \n#include <linux/of.h>                   /* For DT*/ \n#include <linux/platform_device.h>      /* For platform devices */ \n\nstruct eth_struct { \n    int bar; \n    int foo; \n    struct net_device *dummy_ndev; \n}; \n\nstatic int fake_eth_open(struct net_device *dev) { \n    printk(\"fake_eth_open called\\n\"); \n    /* We are now ready to accept transmit requests from \n    * the queueing layer of the networking. \n    */ \n   netif_start_queue(dev); \n    return 0; \n} \n\nstatic int fake_eth_release(struct net_device *dev) { \n    pr_info(\"fake_eth_release called\\n\"); \n    netif_stop_queue(dev); \n    return 0; \n} \n\nstatic int fake_eth_xmit(struct sk_buff *skb, struct net_device *ndev) {     \n    pr_info(\"dummy xmit called...\\n\"); \n    ndev->stats.tx_bytes += skb->len; \n    ndev->stats.tx_packets++; \n\n    skb_tx_timestamp(skb); \n   dev_kfree_skb(skb); \n   return NETDEV_TX_OK; \n} \n\nstatic int fake_eth_init(struct net_device *dev) \n{ \n    pr_info(\"fake eth device initialized\\n\"); \n    return 0; \n}; \n\nstatic const struct net_device_ops my_netdev_ops = { \n     .ndo_init = fake_eth_init, \n     .ndo_open = fake_eth_open, \n     .ndo_stop = fake_eth_release, \n     .ndo_start_xmit = fake_eth_xmit, \n     .ndo_validate_addr    = eth_validate_addr, \n     .ndo_validate_addr    = eth_validate_addr, \n}; \n\nstatic const struct of_device_id fake_eth_dt_ids[] = { \n    { .compatible = \"packt,fake-eth\", }, \n    { /* sentinel */ } \n}; \n\nstatic int fake_eth_probe(struct platform_device *pdev) \n{ \n    int ret; \n    struct eth_struct *priv; \n    struct net_device *dummy_ndev; \n\n    priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL); \n    if (!priv) \n        return -ENOMEM; \n\n    dummy_ndev = alloc_etherdev(sizeof(struct eth_struct)); \n    dummy_ndev->if_port = IF_PORT_10BASET; \n    dummy_ndev->netdev_ops = &my_netdev_ops; \n\n    /* If needed, dev->ethtool_ops = &fake_ethtool_ops; */ \n\n    ret = register_netdev(dummy_ndev); \n    if(ret) { \n        pr_info(\"dummy net dev: Error %d initalizing card ...\", ret); \n        return ret; \n    } \n\n    priv->dummy_ndev = dummy_ndev; \n    platform_set_drvdata(pdev, priv); \n    return 0; \n} \n\nstatic int fake_eth_remove(struct platform_device *pdev) \n{ \n    struct eth_struct *priv; \n   priv = platform_get_drvdata(pdev); \n   pr_info(\"Cleaning Up the Module\\n\"); \n    unregister_netdev(priv->dummy_ndev); \n    free_netdev(priv->dummy_ndev); \n\n   return 0; \n} \n\nstatic struct platform_driver mypdrv = { \n    .probe      = fake_eth_probe, \n    .remove     = fake_eth_remove, \n    .driver     = { \n        .name     = \"fake-eth\", \n        .of_match_table = of_match_ptr(fake_eth_dt_ids),   \n        .owner    = THIS_MODULE, \n    }, \n}; \nmodule_platform_driver(mypdrv); \n\nMODULE_LICENSE(\"GPL\"); \nMODULE_AUTHOR(\"John Madieu <john.madieu@gmail.com>\"); \nMODULE_DESCRIPTION(\"Fake Ethernet driver\"); \n```", "```\n# dmesg\n\n[...]\n\n[146698.060074] fake eth device initialized\n\n[146698.087297] IPv6: ADDRCONF(NETDEV_UP): eth0: link is not ready\n\n```", "```\n# ifconfig -a\n\n[...]\n\neth0 Link encap:Ethernet HWaddr 00:00:00:00:00:00\n\nBROADCAST MULTICAST MTU:1500 Metric:1\n\nRX packets:0 errors:0 dropped:0 overruns:0 frame:0\n\nTX packets:0 errors:0 dropped:0 overruns:0 carrier:0\n\ncollisions:0 txqueuelen:1000\n\nRX bytes:0 (0.0 B) TX bytes:0 (0.0 B)\n\n```", "```\n# ifconfig eth0 192.168.1.45\n\n# ifconfig\n\n[...]\n\neth0 Link encap:Ethernet HWaddr 00:00:00:00:00:00\n\ninet addr:192.168.1.45 Bcast:192.168.1.255 Mask:255.255.255.0\n\nBROADCAST MULTICAST MTU:1500 Metric:1\n\nRX packets:0 errors:0 dropped:0 overruns:0 frame:0\n\nTX packets:0 errors:0 dropped:0 overruns:0 carrier:0\n\ncollisions:0 txqueuelen:1000\n\nRX bytes:0 (0.0 B) TX bytes:0 (0.0 B)\n\n```", "```\nstatic irqreturn_t my_netdev_irq(int irq, void *dev_id) \n{ \n   struct priv_net_struct *priv = dev_id; \n\n   /* \n    * Can't do anything in interrupt context because we need to \n    * block (spi_sync() is blocking) so fire of the interrupt \n    * handling workqueue. \n    * Remember, we access our netdev registers through SPI bus \n    * via spi_sync() call. \n    */ \n   schedule_work(&priv->irq_work); \n\n   return IRQ_HANDLED; \n} \n```", "```\nstatic void my_netdev_irq_work_handler(struct work_struct *work) \n{ \n   struct priv_net_struct *priv = \n         container_of(work, struct priv_net_struct, irq_work); \n   struct net_device *ndev = priv->netdev; \n   int intflags, loop; \n\n   /* disable further interrupts */ \n   my_netdev_reg_bitclear(priv, EIE, EIE_INTIE); \n\n   do { \n         loop = 0; \n         intflags = my_netdev_regb_read(priv, EIR); \n         /* DMA interrupt handler (not currently used) */ \n         if ((intflags & EIR_DMAIF) != 0) { \n               loop++; \n               handle_dma_complete(); \n               clear_dma_interrupt_flag(); \n         } \n         /* LINK changed handler */ \n         if ((intflags & EIR_LINKIF) != 0) { \n               loop++; \n               my_netdev_check_link_status(ndev); \n               clear_link_interrupt_flag(); \n         } \n         /* TX complete handler */ \n         if ((intflags & EIR_TXIF) != 0) { \n               bool err = false; \n               loop++; \n               priv->tx_retry_count = 0; \n               if (locked_regb_read(priv, ESTAT) & ESTAT_TXABRT) \n                     clear_tx_interrupt_flag(); \n\n         /* TX Error handler */ \n         if ((intflags & EIR_TXERIF) != 0) { \n               loop++; \n               /* \n                * Reset TX logic by setting/clearing appropriate \n                 * bit in the right register \n                 */ \n               [...] \n\n               /* Transmit Late collision check for retransmit */ \n               if (my_netdev_cpllision_bit_set())  \n                     /* Handlecollision */ \n                     [...] \n         } \n         /* RX Error handler */ \n         if ((intflags & EIR_RXERIF) != 0) { \n               loop++; \n               /* Check free FIFO space to flag RX overrun */ \n               [...] \n         } \n         /* RX handler */ \n         if (my_rx_interrupt(ndev)) \n               loop++; \n   } while (loop); \n\n   /* re-enable interrupts */ \n   my_netdev_reg_bitset(priv, EIE, EIE_INTIE); \n} \n```", "```\nmy_netdev->ethtool_ops = &my_ethtool_ops; \n```", "```\nstatic const struct net_device_ops my_netdev_ops = { \n   .ndo_open         = my_netdev_open, \n   .ndo_stop         = my_netdev_close, \n   .ndo_start_xmit   = my_netdev_start_xmit, \n   .ndo_set_rx_mode  = my_netdev_set_multicast_list, \n   .ndo_set_mac_address    = my_netdev_set_mac_address, \n   .ndo_tx_timeout   = my_netdev_tx_timeout, \n   .ndo_change_mtu   = eth_change_mtu, \n   .ndo_validate_addr      = eth_validate_addr, \n}; \n```", "```\nstatic int my_netdev_probe(struct spi_device *spi) \n{ \n   struct net_device *dev; \n   struct priv_net_struct *priv; \n   int ret = 0; \n\n   /* Allocate network interface */ \n   dev = alloc_etherdev(sizeof(struct priv_net_struct)); \n   if (!dev) \n         [...] /* handle -ENOMEM error */ \n\n   /* Private data */ \n   priv = netdev_priv(dev); \n\n   /* set private data and bus-specific parameter */ \n   [...] \n\n   /* Initialize some works */ \n   INIT_WORK(&priv->tx_work, data_tx_work_handler); \n   [...] \n\n   /* Devicerealy init, only few things */ \n   if (!my_netdev_chipset_init(dev)) \n         [...] /* handle -EIO error */  \n\n   /* Generate and assign random MAC address to the device */ \n   eth_hw_addr_random(dev); \n   my_netdev_set_hw_macaddr(dev); \n\n   /* Board setup must set the relevant edge trigger type; \n    * level triggers won't currently work. \n    */ \n   ret = request_irq(spi->irq, my_netdev_irq, 0, DRV_NAME, priv); \n   if (ret < 0) \n         [...]; /* Handle irq request failure */ \n\n   /* Fill some netdev mandatory or useful properties */ \n   dev->if_port = IF_PORT_10BASET; \n   dev->irq = spi->irq; \n   dev->netdev_ops = &my_netdev_ops; \n   dev->ethtool_ops = &my_ethtool_ops; \n\n   /* Put device into sleep mode */ \n   My_netdev_lowpower(priv, true); \n\n   /* Register our device with the kernel */ \n   if (register_netdev(dev)) \n         [...]; /* Handle registration failure error */ \n\n   dev_info(&dev->dev, DRV_NAME \" driver registered\\n\"); \n\n   return 0; \n} \n```", "```\nstatic int my_netdev_remove(struct spi_device *spi) \n{ \n   struct priv_net_struct *priv = spi_get_drvdata(spi); \n\n   unregister_netdev(priv->netdev); \n   free_irq(spi->irq, priv); \n   free_netdev(priv->netdev); \n\n   return 0; \n} \n```"]