["```\n/**\n * kmalloc - allocate memory\n * @size: how many bytes of memory are required.\n * @flags: the type of memory to allocate.\n...\n*/\nstatic __always_inline void *kmalloc(size_t size, gfp_t flags);\n\n/**\n * kzalloc - allocate memory. The memory is set to zero.\n * @size: how many bytes of memory are required.\n * @flags: the type of memory to allocate (see kmalloc).\n */\nstatic inline void *kzalloc(size_t size, gfp_t flags)\n{\n    return kmalloc(size, flags | __GFP_ZERO);\n}\n\n/**\n * kmalloc_array - allocate memory for an array.\n * @n: number of elements.\n * @size: element size.\n * @flags: the type of memory to allocate (see kmalloc).\n */\nstatic inline void *kmalloc_array(size_t n, size_t size, gfp_t flags);\n\n/**\n * kcalloc - allocate memory for an array. The memory is set to zero.\n * @n: number of elements.\n * @size: element size.\n * @flags: the type of memory to allocate (see kmalloc).\n */\nstatic inline void *kcalloc(size_t n, size_t size, gfp_t flags)\n{\n    return kmalloc_array(n, size, flags | __GFP_ZERO);\n}\n\nvoid kfree(const void *);\n```", "```\n/**\n * kmalloc - allocate memory\n * @size: how many bytes of memory are required.\n * @flags: the type of memory to allocate.\n *\n * kmalloc is the normal method of allocating memory\n * for objects smaller than page size in the kernel.\n *\n * The @flags argument may be one of:\n *\n * %GFP_USER - Allocate memory on behalf of user. May sleep.\n *\n * %GFP_KERNEL - Allocate normal kernel ram. May sleep.\n *\n * %GFP_ATOMIC - Allocation will not sleep. May use emergency pools.\n * For example, use this inside interrupt handlers.\n *\n * %GFP_HIGHUSER - Allocate pages from high memory.\n *\n * %GFP_NOIO - Do not do any I/O at all while trying to get memory.\n *\n * %GFP_NOFS - Do not make any fs calls while trying to get memory.\n *\n * %GFP_NOWAIT - Allocation will not sleep.\n...\n```", "```\nspin_lock(...);\nptr = kmalloc(..., GFP_KERNEL);\nspin_unlock(...);\n```", "```\nextern void *vmalloc(unsigned long size);\nextern void *vzalloc(unsigned long size);\n```", "```\nstatic inline void *kvmalloc(size_t size, gfp_t flags)\n{\n    return kvmalloc_node(size, flags, NUMA_NO_NODE);\n}\n\nstatic inline void *kvzalloc(size_t size, gfp_t flags)\n{\n    return kvmalloc(size, flags | __GFP_ZERO);\n}\n\nstatic inline void *kvmalloc_array(size_t n, size_t size, gfp_t flags)\n{\n    size_t bytes;\n\n    if (unlikely(check_mul_overflow(n, size, &bytes)))\n        return NULL;\n\n    return kvmalloc(bytes, flags);\n}\n\nstatic inline void *kvcalloc(size_t n, size_t size, gfp_t flags)\n{\n    return kvmalloc_array(n, size, flags | __GFP_ZERO);\n}\n\nextern void kvfree(const void *addr);\n```", "```\nstruct list_head {\n    struct list_head *next, *prev;\n};\n```", "```\nstruct l_struct {\n    int data;\n    ... \n    /* other driver specific fields */\n    ...\n    struct list_head list;\n};\n```", "```\nstruct list_head data_list;\nINIT_LIST_HEAD(&data_list);\n```", "```\n/**\n * list_add - add a new entry\n * @new: new entry to be added\n * @head: list head to add it after\n *\n * Insert a new entry after the specified head.\n * This is good for implementing stacks.\n */\nstatic inline void list_add(struct list_head *new, struct list_head *head);\n\n * list_del - deletes entry from list.\n * @entry: the element to delete from the list.\n * Note: list_empty() on entry does not return true after this, the entry is\n * in an undefined state.\n */\nstatic inline void list_del(struct list_head *entry);\n```", "```\n/**\n * list_replace - replace old entry by new one\n * @old : the element to be replaced\n * @new : the new element to insert\n *\n * If @old was empty, it will be overwritten.\n */\nstatic inline void list_replace(struct list_head *old,\n                                struct list_head *new);\n...\n```", "```\nvoid add_ordered_entry(struct l_struct *new)\n{\n    struct list_head *ptr;\n    struct my_struct *entry;\n\n    list_for_each(ptr, &data_list) {\n        entry = list_entry(ptr, struct l_struct, list);\n        if (entry->data < new->data) {\n            list_add_tail(&new->list, ptr);\n            return;\n        }\n    }\n    list_add_tail(&new->list, &data_list)\n}\n```", "```\n/**\n * list_entry - get the struct for this entry\n * @ptr: the &struct list_head pointer.\n * @type: the type of the struct this is embedded in.\n * @member: the name of the list_head within the struct.\n */\n#define list_entry(ptr, type, member) \\\n    container_of(ptr, type, member)\n\n/**\n * list_first_entry - get the first element from a list\n * @ptr: the list head to take the element from.\n * @type: the type of the struct this is embedded in.\n * @member: the name of the list_head within the struct.\n *\n * Note, that list is expected to be not empty.\n */\n#define list_first_entry(ptr, type, member) \\\n        list_entry((ptr)->next, type, member)\n\n/**\n * list_last_entry - get the last element from a list\n * @ptr: the list head to take the element from.\n * @type: the type of the struct this is embedded in.\n * @member: the name of the list_head within the struct.\n *\n * Note, that list is expected to be not empty.\n */\n#define list_last_entry(ptr, type, member) \\\n        list_entry((ptr)->prev, type, member)\n...\n```", "```\n/**\n * list_for_each - iterate over a list\n * @pos: the &struct list_head to use as a loop cursor.\n * @head: the head for your list.\n */\n#define list_for_each(pos, head) \\\n        for (pos = (head)->next; pos != (head); pos = pos->next)\n\n/**\n * list_for_each_prev - iterate over a list backwards\n * @pos: the &struct list_head to use as a loop cursor.\n * @head: the head for your list.\n */\n#define list_for_each_prev(pos, head) \\\n        for (pos = (head)->prev; pos != (head); pos = pos->prev)\n...\n```", "```\nDECLARE_HASHTABLE(data_hash, bits)\nhash_init(data_hash);\n```", "```\n#define DECLARE_HASHTABLE(name, bits) \\\n    struct hlist_head name[1 << (bits)]\n```", "```\nstruct h_struct {\n    int key;\n    int data;\n    ... \n    /* other driver specific fields */\n    ...\n    struct hlist_node node;\n};\n```", "```\nstruct hlist_head {\n    struct hlist_node *first;\n};\n\nstruct hlist_node {\n    struct hlist_node *next, **pprev;\n};\n```", "```\nhash_add(data_hash, &entry.node, key);\n```", "```\nu8 hash_func(u8 *buf, size_t len)\n{\n    u8 key = 0;\n\n    for (i = 0; i < len; i++)\n        key += data[i];\n\n    return key;\n}\n```", "```\nhash_del(&entry.node);\n```", "```\nhash_for_each(name, bkt, node, obj, member)\n```", "```\nhash_for_each_possible(name, obj, member, key)\n```", "```\nvoid del_node(int data)\n{\n    int key = hash_func(data);\n    struct h_struct *entry;\n\n    hash_for_each_possible(data_hash, entry, node, key) {\n        if (entry->data == data) {\n            hash_del(&entry->node);\n            return;\n        }\n    }\n}\n```", "```\n/**\n * hash_add - add an object to a hashtable\n * @hashtable: hashtable to add to\n * @node: the &struct hlist_node of the object to be added\n * @key: the key of the object to be added\n */\n#define hash_add(hashtable, node, key) \\\n        hlist_add_head(node, &hashtable[hash_min(key, HASH_BITS(hashtable))])\n\n/**\n * hash_del - remove an object from a hashtable\n * @node: &struct hlist_node of the object to remove\n */\nstatic inline void hash_del(struct hlist_node *node);\n\n/**\n * hash_for_each_possible - iterate over all possible objects hashing to the\n * same bucket\n * @name: hashtable to iterate\n * @obj: the type * to use as a loop cursor for each entry\n * @member: the name of the hlist_node within the struct\n * @key: the key of the objects to iterate over\n */\n#define hash_for_each_possible(name, obj, member, key) \\\n        hlist_for_each_entry(obj, &name[hash_min(key, HASH_BITS(name))], member)\n```", "```\nsoc {\n    compatible = \"simple-bus\";\n    #address-cells = <2>;\n    #size-cells = <2>;\n    ranges;\n\n    internal-regs@d0000000 {\n        #address-cells = <1>;\n        #size-cells = <1>;\n        compatible = \"simple-bus\";\n        /* 32M internal register @ 0xd000_0000 */\n        ranges = <0x0 0x0 0xd0000000 0x2000000>;\n\n...\n\n        uart0: serial@12000 {\n            compatible = \"marvell,armada-3700-uart\";\n            reg = <0x12000 0x200>;\n            clocks = <&xtalclk>;\n            interrupts =\n            <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>,\n            <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>,\n            <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;\n            interrupt-names = \"uart-sum\", \"uart-tx\", \"uart-rx\";\n            status = \"disabled\";\n        };\n```", "```\nd0012000.serial: ttyMV0 at MMIO 0xd0012000 (irq = 0, base_baud = \n1562500) is a mvebu-uart\n```", "```\n# wget http://free-electrons.com/pub/mirror/devmem2.c\n```", "```\n    if((fd = open(\"/dev/mem\", O_RDWR | O_SYNC)) == -1) FATAL;\n    printf(\"/dev/mem opened.\\n\"); \n    fflush(stdout);\n\n    /* Map one page */\n    map_base = mmap(0, MAP_SIZE,\n                    PROT_READ | PROT_WRITE,\n                    MAP_SHARED, fd, target & ~MAP_MASK);\n    if(map_base == (void *) -1) FATAL;\n    printf(\"Memory mapped at address %p.\\n\", map_base); \n    fflush(stdout);\n```", "```\nstatic int mmap_mem(struct file *file, struct vm_area_struct *vma)\n{\n    size_t size = vma->vm_end - vma->vm_start;\n    phys_addr_t offset = (phys_addr_t)vma->vm_pgoff << PAGE_SHIFT;\n\n...\n\n    /* Remap-pfn-range will mark the range VM_IO */\n    if (remap_pfn_range(vma,\n                        vma->vm_start, vma->vm_pgoff,\n                        size,\n                        vma->vm_page_prot)) {\n        return -EAGAIN;\n    }\n    return 0;\n}\n```", "```\n# make CFLAGS=\"-Wall -O\" devmem2 cc -Wall -O devmem2.c -o devmem2\n```", "```\n# ./devmem2 0xd0012000 \n/dev/mem opened.\nMemory mapped at address 0xffffbd41d000.\nValue at address 0xD0012000 (0xffffbd41d000): 0xD\n```", "```\nstatic inline void writeb(u8 value, volatile void __iomem *addr)\n{\n    __io_bw();\n    __raw_writeb(value, addr);\n    __io_aw();\n}\n\nstatic inline void writew(u16 value, volatile void __iomem *addr)\n{\n    __io_bw();\n    __raw_writew(cpu_to_le16(value), addr);\n    __io_aw();\n}\n\nstatic inline void writel(u32 value, volatile void __iomem *addr)\n{\n    __io_bw();\n    __raw_writel(__cpu_to_le32(value), addr);\n    __io_aw();\n}\n\n#ifdef CONFIG_64BIT\nstatic inline void writeq(u64 value, volatile void __iomem *addr)\n{\n    __io_bw();\n    __raw_writeq(__cpu_to_le64(value), addr);\n    __io_aw();\n}\n#endif /* CONFIG_64BIT */\n```", "```\nstatic int sunxi_wdt_start(struct watchdog_device *wdt_dev)\n{\n...\n    void __iomem *wdt_base = sunxi_wdt->wdt_base;\n    const struct sunxi_wdt_reg *regs = sunxi_wdt->wdt_regs;\n\n...\n\n    /* Set system reset function */\n    reg = readl(wdt_base + regs->wdt_cfg);\n    reg &= ~(regs->wdt_reset_mask);\n    reg |= regs->wdt_reset_val;\n    writel(reg, wdt_base + regs->wdt_cfg);\n\n    /* Enable watchdog */\n    reg = readl(wdt_base + regs->wdt_mode);\n    reg |= WDT_MODE_EN;\n    writel(reg, wdt_base + regs->wdt_mode);\n\n    return 0;\n}\n```", "```\nwriteb(0x12, ctrl_reg);\nwait_us(100);\nwriteb(0x00, ctrl_reg);\n```", "```\nvoid ndelay(unsigned long nsecs);\nvoid udelay(unsigned long usecs);\nvoid mdelay(unsigned long msecs);\n\nvoid usleep_range(unsigned long min, unsigned long max);\nvoid msleep(unsigned int msecs);\nunsigned long msleep_interruptible(unsigned int msecs);\nvoid ssleep(unsigned int seconds);\n```", "```\n/**\n * usleep_range - Sleep for an approximate time\n * @min: Minimum time in usecs to sleep\n * @max: Maximum time in usecs to sleep\n *\n * In non-atomic context where the exact wakeup time is flexible, use\n * usleep_range() instead of udelay(). The sleep improves responsiveness\n * by avoiding the CPU-hogging busy-wait of udelay(), and the range reduces\n * power usage by allowing hrtimers to take advantage of an already-\n * scheduled interrupt instead of scheduling a new one just for this sleep.\n */\nvoid __sched usleep_range(unsigned long min, unsigned long max);\n```", "```\n/**\n * msleep_interruptible - sleep waiting for signals\n * @msecs: Time in milliseconds to sleep for\n */\nunsigned long msleep_interruptible(unsigned int msecs);\n```"]