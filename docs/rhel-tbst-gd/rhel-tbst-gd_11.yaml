- en: Chapter 11. Recovering from Common Failures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。从常见故障中恢复
- en: In the previous chapter, we explored the user and system limitations that exist
    on Linux servers. We looked at what limits are in place and how to change the
    values for applications that require more than default.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了Linux服务器上存在的用户和系统限制。我们看了看现有的限制以及如何更改应用程序所需的默认值。
- en: In this chapter, we will put our troubleshooting skills to use with a system
    that has had its resources exhausted.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将运用我们的故障排除技能来处理一个资源耗尽的系统。
- en: The reported problem
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 报告的问题
- en: 'Today''s chapter, much like the other chapters, will start with someone reporting
    an issue. The issue being reported is that Apache is no longer running on the
    server, which serves the company''s blog: `blog.example.com`.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的章节，就像其他章节一样，将以某人报告问题开始。报告的问题是Apache不再在服务器上运行，该服务器为公司的博客`blog.example.com`提供服务。
- en: A fellow systems administrator who is reporting the issue has explained that
    someone reported that the blog was down and when he logged into the server he
    could see Apache was no longer running. At that point, our peer was unsure what
    to do to continue and asked for our help.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 报告问题的另一位系统管理员解释说，有人报告博客宕机，当他登录服务器时，他发现Apache不再运行。在那时，我们的同行不确定接下来该怎么做，并请求我们的帮助。
- en: Is Apache really down?
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apache真的宕机了吗？
- en: The first thing that we should do when a service is reported as down is to validate
    that it really is down. This is essentially our *duplicate it for ourselves* step
    from our troubleshooting process. With a service such as Apache, we should also
    validate that it is in fact down fairly quickly.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当报告某个服务宕机时，我们应该做的第一件事是验证它是否真的宕机。这本质上是我们故障排除过程中的*为自己复制*步骤。对于Apache这样的服务，我们也应该相当快地验证它是否真的宕机。
- en: In my experience, I have often been told that a service is down when it really
    was not. The server may have been having an issue but it was not technically down.
    The difference between up or down can change the troubleshooting steps that we
    need to perform to resolve the issue.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，我经常被告知服务宕机，而实际上并非如此。服务器可能出现问题，但技术上并没有宕机。上线或宕机的区别会改变我们需要执行的故障排除步骤。
- en: This said, the first step that I always perform for issues like this is to validate
    whether the service really is down or whether the service simply is not responding.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我总是首先执行的步骤是验证服务是否真的宕机，还是服务只是没有响应。
- en: 'To validate that Apache is really down, we will use the `ps` command. As we
    learned earlier, this command will print a list of the currently running processes.
    We will redirect this output to the `grep` command to check whether there are
    any instances of the `httpd` (Apache) service running:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证Apache是否真的宕机，我们将使用`ps`命令。正如我们之前学到的，这个命令将打印当前运行的进程列表。我们将将这个输出重定向到`grep`命令，以检查是否有`httpd`（Apache）服务的实例在运行：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'From the output of the abovementioned `ps` command, we can see that there are
    no processes running with the name `httpd`. Under normal circumstances, we would
    expect to see at least a few lines that look similar to the following example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述`ps`命令的输出中，我们可以看到没有以`httpd`命名的进程在运行。在正常情况下，我们期望至少看到几行类似于以下示例的内容：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since there are no `httpd` processes found in the process list, we can conclude
    that Apache is in fact down on this system. The question now is, why?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在进程列表中找不到`httpd`进程，我们可以得出结论，Apache实际上在这个系统上宕机了。现在的问题是，为什么？
- en: Why is it down?
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么它宕机了？
- en: Before simply resolving the issue by starting the Apache service, we are going
    to first figure out why the Apache service is not running. This is a process called
    **Root Cause Analysis** (**RCA**), which is a formal process that is used to understand
    what first caused the issue.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单地启动Apache服务解决问题之前，我们将首先弄清楚为什么Apache服务没有运行。这是一个称为**根本原因分析**（**RCA**）的过程，这是一个正式的过程，用于了解最初导致问题的原因。
- en: We will get very familiar with this process in the next chapter. In this chapter,
    we will keep it simple and focus specifically on why Apache is not running.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将对这个过程非常熟悉。在本章中，我们将保持简单，专注于为什么Apache没有运行。
- en: One of the first places for us to look is in the Apache logs in `/var/log/httpd`.
    We learned of these logs in the previous chapters while troubleshooting other
    webserver-related issues. As we saw in these earlier chapters, application and
    service logs can be very helpful in determining what has happened to the service.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要查看的第一个地方是`/var/log/httpd`中的Apache日志。在之前的章节中，我们在排除其他与Web服务器相关的问题时了解了这些日志。正如我们在之前的章节中看到的，应用程序和服务日志在确定服务发生了什么事情方面非常有帮助。
- en: Since Apache is no longer running, we are more interested in the last few events
    that happened. If the service experienced a fatal error or was stopped, there
    should be a message at the end of the log file showing this.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Apache不再运行，我们对最近发生的事件更感兴趣。如果服务遇到致命错误或被停止，应该在日志文件的末尾显示相应的消息。
- en: 'Because we are only interested in the last few events, we will use the `tail`
    command to show the last 10 lines of the `error_log` file. The `error_log` file
    is the first log to check as it is the most likely place for anything unusual:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们只对最近发生的事件感兴趣，所以我们将使用`tail`命令显示`error_log`文件的最后10行。`error_log`文件是第一个要检查的日志，因为它是发生异常的最可能地方：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From the `error_log` file contents, we can see quite a few interesting messages.
    Let's take a quick look at some of the more informational log entries.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从`error_log`文件内容中，我们可以看到一些有趣的信息。让我们快速浏览一下一些更具信息量的日志条目。
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding line shows that the Apache process was shut down on `Sunday,
    Jun 21` at `20:53`. We can see this as the error message clearly states `shutting
    down gracefully`. The next few lines, however, seem to indicate that the Apache
    service was back up only `2` seconds later:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行显示Apache进程在`Sunday, Jun 21`的`20:53`被关闭。我们可以看到错误消息清楚地说明了`优雅地关闭`。然而，接下来的几行似乎表明Apache服务只在`2`秒后重新启动：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The shutdown log entry shows a process id of `2218`, whereas the preceding five
    lines show a process id of `2249`. The 5th line also states `resuming normal operations`.
    These four messages seem to indicate that the Apache process simply restarted.
    Most likely, this was a graceful restart of Apache.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关机日志条目显示了一个进程ID为`2218`，而前面的五行显示了一个进程ID为`2249`。第五行还声明了`恢复正常运行`。这四条消息似乎表明Apache进程只是重新启动了。很可能，这是Apache的优雅重启。
- en: A graceful restart of Apache is a fairly common task performed during the modification
    of its configuration. This is a way to restart the Apache process without taking
    it fully down and impacting the web service.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Apache的优雅重启是在修改其配置时执行的一个相当常见的任务。这是一种在不完全关闭和影响Web服务的情况下重新启动Apache进程的方法。
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The most interesting thing that these 10 lines tell us, however, is that the
    last log Apache printed was nothing more than a notification. When Apache was
    stopped gracefully, it logged a message in the `error_log` file to show that it
    was being stopped.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这10行告诉我们最有趣的事情是，Apache打印的最后一个日志只是一个通知。当Apache被优雅地停止时，它会在`error_log`文件中记录一条消息，以显示它正在被停止。
- en: Since the Apache processes are no longer running and there are no log entries
    showing that it was shut down gracefully or even ungracefully, we conclude that
    irrespective of the reason why Apache was not running, it did not shut down normally.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Apache进程不再运行，并且没有日志条目显示它是正常关闭或非正常关闭，我们得出结论，无论Apache为什么不运行，它都没有正常关闭。
- en: If a person shut down the service by using `apachectl` or the `systemctl` command,
    we would expect to see a message similar to that discussed in the earlier example.
    Since the last line of the log file shows no shutdown message, we can only assume
    that this process was killed or terminated under abnormal circumstances.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个人使用`apachectl`或`systemctl`命令关闭了服务，我们会期望看到类似于之前例子中讨论的消息。由于日志文件的最后一行没有显示关闭消息，我们只能假设这个进程是在异常情况下被终止或终止的。
- en: Now, the question is *What might have caused the Apache process to terminate
    in an abnormal manner like this?*
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题是*是什么导致了Apache进程以这种异常方式终止？*
- en: One place that may provide a clue as to what happened with Apache is the systemd
    facility as Red Hat Enterprise Linux 7 services, such as Apache, have been moved
    to systemd. Upon booting, the `systemd` facility starts up any service that it
    has been configured to start.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Apache发生了什么事情的线索可能在于systemd设施，因为Red Hat Enterprise Linux 7服务，比如Apache，已经被迁移到了systemd。在启动时，`systemd`设施会启动任何已经配置好的服务。
- en: 'When a process that `systemd` starts is terminated, that activity is captured
    by `systemd`. Depending on what has happened since the process was terminated,
    we can see whether `systemd` captured this event by using the `systemctl` command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当`systemd`启动的进程被终止时，这个活动会被`systemd`捕获。根据进程终止后发生的情况，我们可以使用`systemctl`命令来查看`systemd`是否捕获了这个事件：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output of the `systemctl status` command shows quite a bit of information.
    Since we covered this quite a bit in the previous chapters, I am going to skip
    to just the parts of this output that will tell us what happened to the Apache
    service.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemctl status`命令的输出显示了相当多的信息。由于我们在之前的章节中已经涵盖了这个问题，我将跳过这个输出的大部分，只看一些能告诉我们Apache服务发生了什么的部分。'
- en: 'The first two lines that look interesting are the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来有趣的前两行是：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In these two lines, we can see process id `2249`, which we also saw in the
    `error_log` file. This is the process id of the Apache instance started on `Sunday,
    June 21`. We can also see from these lines that process `2249` was killed. This
    seems to indicate that someone or something killed our Apache service:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两行中，我们可以看到进程ID为`2249`，这也是我们在`error_log`文件中看到的。这是在`6月21日星期日`启动的Apache实例的进程ID。我们还可以从这些行中看到，进程`2249`被终止了。这似乎表明有人或某物终止了我们的Apache服务：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If we look at the last few lines in the `systemctl` status output, we can see
    events that the `systemd` facility captured. The first event that we can see is
    that the Apache service was started on `June 21` at `20:53`. This isn't much of
    a surprise as it correlates with the information we saw in `error_log`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下`systemctl`状态输出的最后几行，我们可以看到`systemd`设施捕获的事件。我们可以看到的第一个事件是Apache服务在`6月21日20:53`启动。这并不奇怪，因为它与我们在`error_log`中看到的信息相符。
- en: The last three lines, however, show that the Apache process was subsequently
    killed on `June 26` at `21:21`. Unfortunately these events do not show exactly
    why the Apache process was killed or who killed it. What it does tell us is the
    exact time that Apache was killed. This also shows that it was not likely that
    the `systemd` facility stopped the Apache service.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最后三行显示Apache进程随后在`6月26日21:21`被终止。不幸的是，这些事件并没有准确显示Apache进程被终止的原因或是谁终止了它。它告诉我们的是Apache被终止的确切时间。这也表明`systemd`设施不太可能停止了Apache服务。
- en: What else was happening at that time?
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那个时候还发生了什么？
- en: Since we were not able to determine the cause from the Apache logs or `systemctl
    status`, we will need to keep digging to understand what else may have killed
    this service.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法从Apache日志或`systemctl status`中确定原因，我们需要继续挖掘以了解是什么导致了这个服务的停止。
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since the 26th was several days ago, we have a somewhat limited set of places
    to look for additional information. One place that we can look is the `/var/log/messages`
    log file. As we discovered in the earlier chapters, the `messages` log contains
    quite a lot of diverse information from many of the different facilities within
    the system. If there were a place that could tell us what was happening with the
    system at that time, it would be there.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于26号已经过去了几天，我们有一些有限的地方可以寻找额外的信息。我们可以查看`/var/log/messages`日志文件。正如我们在前面的章节中发现的，`messages`日志包含了系统中许多不同设施的各种信息。如果有一个地方可以告诉我们那个时候系统发生了什么，那就是那里。
- en: Searching the messages log
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索messages日志
- en: 'The `messages` log is quite large and has many log entries within it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`messages`日志非常庞大，在其中有许多日志条目：'
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Therefore, we need to filter log messages that are either not relevant to our
    issue or not during the time of our issue. The first thing that we can do is search
    the log for messages from the day Apache was stopped: `June 26`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要过滤掉与我们的问题无关或不在我们问题发生时的日志消息。我们可以做的第一件事是搜索日志中Apache停止的那一天的消息：`June 26`：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: From the previously mentioned `tail` command, we can see that messages within
    the `/var/log/messages` file have the format of date, hostname, process, and then
    message. The date field is a three-letter month followed by the day number and
    a 24-h timestamp.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面提到的`tail`命令中，我们可以看到`/var/log/messages`文件中的消息格式是日期、主机名、进程，然后是消息。日期字段是一个三个字母的月份，后面跟着日期数字和24小时时间戳。
- en: 'Since our issue occurred on June 26th, we can search this log file for any
    instance of the string "`Jun 26`". This should provide all messages that were
    written on the 26th:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的问题发生在6月26日，我们可以搜索这个日志文件中字符串"`Jun 26`"的任何实例。这应该提供所有在26日写入的消息：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This evidently is still quite a few log messages, far too many to read them
    all. Given this number, we need to filter the messages even more, maybe by the
    process:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 显然这仍然是相当多的日志消息，太多了，无法全部阅读。鉴于这个数量，我们需要进一步过滤消息，也许可以按进程来过滤：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code is commonly called a **bash** one-liner. This is often a
    series of commands that redirect their output to another command to provide a
    function or output that one command by itself cannot perform or generate. In this
    case, we have a one-liner that shows us which processes were logging the most
    on June 26th.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码通常被称为**bash**一行代码。这通常是一系列命令，它们将它们的输出重定向到另一个命令，以提供一个单独的命令无法执行或生成的功能或输出。在这种情况下，我们有一个一行代码，它显示了6月26日记录最多的进程。
- en: Breaking down this useful one-liner
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分解这个有用的一行代码
- en: The above mentioned one-liner is somewhat complicated at first but once we break
    down this one-liner, it becomes much easier to understand. This is a useful one-liner
    as it makes identifying trends within log files a lot easier.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上面提到的一行代码一开始可能有点复杂，但一旦我们分解这个一行代码，它就变得容易理解了。这是一个有用的一行代码，因为它使得在日志文件中识别趋势变得更容易。
- en: 'Let''s break down this one-liner to get a better understanding of what it is
    doing:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个一行代码，以更好地理解它的作用：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We already know what the first command does; it simply searches the `/var/log/messages`
    file for any instance of the string "`Jun 26`". The other commands are ones that
    we haven't covered before, but they can be useful commands to know.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道第一个命令的作用；它只是在`/var/log/messages`文件中搜索字符串"`Jun 26`"的任何实例。其他命令是我们以前没有涉及过的命令，但它们可能是有用的命令。
- en: The cut command
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: cut命令
- en: 'The `cut` command in this one-liner is used to read the output of the `grep`
    command and print only specific parts of each line. To understand how this works,
    we should first run the one-liner ending at the `cut` command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一行代码中的`cut`命令用于读取`grep`命令的输出，并只打印每行的特定部分。要理解它是如何工作的，我们应该首先运行在`cut`命令结束的一行代码：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding `cut` command works by specifying a delimiter and cutting the
    output by that delimiter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`cut`命令通过指定分隔符并按该分隔符切割输出来工作。
- en: A delimiter is a character used to break down the line into multiple fields;
    we can specify it with the `–d` flag. In the preceding example, the `–d` flag
    is followed by "`\`"; the backslash is an escape character and is followed by
    a single space. This tells the `cut` command to use a single space character as
    the delimiter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔符是用来将行分解为多个字段的字符；我们可以用`-d`标志来指定它。在上面的例子中，`-d`标志后面跟着"`\`"；反斜杠是一个转义字符，后面跟着一个空格。这告诉`cut`命令使用一个空格字符作为分隔符。
- en: The `–f` flag is used to specify the `fields` that should be displayed. These
    fields are the strings of text between the delimiter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f`标志用于指定应该显示的`fields`。这些字段是分隔符之间的文本字符串。'
- en: 'For example, let''s take a look at the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看下面的命令：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we specified that the "`:`" character is the delimiter for `cut`. We also
    specified that it should print the first, second, and fourth fields. This had
    the effect of printing Apples (the first field), Bananas (the second field), and
    Dried Cherries (the fourth field). The third field, Carrots, was omitted from
    the output. This is because we didn't specifically tell the `cut` command to print
    the third field.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定"`:`"字符是`cut`的分隔符。我们还指定它应该打印第一、第二和第四个字段。这导致打印了Apples（第一个字段）、Bananas（第二个字段）和Dried
    Cherries（第四个字段）。第三个字段Carrots被省略了。这是因为我们没有明确告诉`cut`命令打印第三个字段。
- en: Now that we know how `cut` works, let's look at how it processes the `messages`
    log entries.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了`cut`是如何工作的，让我们看看它是如何处理`messages`日志条目的。
- en: 'Here''s a sample of a log message:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个日志消息的样本：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we executed the `cut` command in our one-liner, we specifically told it
    to only print the first, second, and fifth fields:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行这个一行代码中的`cut`命令时，我们明确告诉它只打印第一、第二和第五个字段：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By specifying a single space character to be the delimiter in our `cut` command,
    we can see that this causes `cut` to only print the month, day, and program from
    each log entry. By itself, this may not seem very useful, but as we continue looking
    through this one-liner, the functionality provided by cut will be critical.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的`cut`命令中指定一个空格字符作为分隔符，我们可以看到这会导致`cut`只打印每个日志条目的月份、日期和程序。单独看可能并不那么有用，但随着我们继续查看这个一行代码，cut提供的功能将变得至关重要。
- en: The sort command
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: sort命令
- en: 'The next command `sort` is actually used twice within this one-liner:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的`sort`命令在这个一行代码中实际上被使用了两次：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command is actually pretty simple in what it does. The `sort` command in
    this one-liner takes the output of the `cut` command and orders (sorts) it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令实际上很简单，它的作用是对`cut`命令的输出进行排序。
- en: 'To explain this better, let''s look at the following example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地解释这一点，让我们看下面的例子：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The above file again has several fruits, and this time, they are not in alphabetical
    order. If we use the `sort` command to read this file, however, the order of these
    fruits will change:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的文件再次包含几种水果，这一次它们不是按字母顺序排列的。然而，如果我们使用`sort`命令来读取这个文件，这些水果的顺序将会改变：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we can see, the order is now alphabetical despite how the fruits are listed
    in the file itself. The nice thing about `sort` is that it can be used to order
    text in several different ways. In fact, in the second instance of `sort` within
    our one-liner, we use the `–n` flag to sort the text numerically as well:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，现在的顺序是按字母顺序排列的，尽管水果在文件中的顺序是不同的。`sort`的好处在于它可以用几种不同的方式对文本进行排序。实际上，在我们的一行命令中`sort`的第二个实例中，我们使用`-n`标志对文本进行了数字排序：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The uniq command
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: uniq命令
- en: 'The reason that our one-liner contains the `sort` command is simply to order
    the input sent to `uniq -c`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一行命令包含`sort`命令的原因很简单，就是为了对发送到`uniq -c`的输入进行排序：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `uniq` command can be used to identify lines that match and display these
    lines in a single unique line. To understand this better, let''s look at the following
    example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniq`命令可以用来识别匹配的行，并将这些行显示为单个唯一行。为了更好地理解这一点，让我们看看下面的例子：'
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Our example file "`duplicates.txt`" contains multiple duplicate lines. When
    we read this file with `uniq`, we will only see each unique line:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例文件"`duplicates.txt`"包含多个重复的行。当我们用`uniq`读取这个文件时，我们只会看到每一行的唯一内容：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This can be somewhat useful; however, I find that with the `–c` flag, the output
    can be even more useful:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有些有用；但是，我发现使用`-c`标志，输出可能会更有用：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With the `–c` flag, the `uniq` command will count the number of times that
    it finds each line. Here, we can see that there are four lines with the word Apple.
    Therefore, the `uniq` command printed the number 4 before the word Apple to show
    that there were four instances of this line:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-c`标志，`uniq`命令将计算它找到每行的次数。在这里，我们可以看到有四行包含单词苹果。因此，`uniq`命令在单词苹果之前打印了数字4，以显示这行有四个实例：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: One caveat to the `uniq` command is that in order to get an accurate count,
    each instance needs to be right after the other. You can see what happens when
    we add the word Orange between the groups of Apple lines.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniq`命令的一个注意事项是，为了获得准确的计数，每个实例都需要紧挨在一起。当我们在苹果行的组之间添加单词橙子时，可以看到会发生什么。'
- en: Tying it all together
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 把所有东西都联系在一起
- en: 'If we look at our command again, we can now better understand what it is doing:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次看看我们的命令，现在我们可以更好地理解它在做什么：
- en: '[PRE28]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The above command will filter and print all of the log messages in `/var/log/messages`
    that match the string "`Jun 26`". The output will then be sent to the `cut` command,
    which prints the month, day, and process of each line. This output is then sent
    to the `sort` command to order the output into groups that match each other. The
    sorted output is then sent to `uniq –c` that counts the number of occurrences
    of each line and prints one unique line with the count.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的命令将过滤并打印`/var/log/messages`中与字符串"`Jun 26`"匹配的所有日志消息。然后输出将被发送到`cut`命令，该命令打印每行的月份、日期和进程。然后将此输出发送到`sort`命令，以将输出排序为相互匹配的组。排序后的输出然后被发送到`uniq
    -c`，它计算每行出现的次数并打印一个带有计数的唯一行。
- en: From there, we add another `sort` to order the output by the number added by
    `uniq`, and add `tail` to shorten the output to the last 10 lines.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加另一个`sort`来按`uniq`添加的数字对输出进行排序，并添加`tail`来将输出缩短到最后10行。
- en: So, what exactly does this fancy one-liner tell us? Well, it tells us that the
    `kernel` facility and the `systemd` process are logging quite a bit. In fact,
    in comparison to the other items listed, we can see that these two have more log
    messages than the others.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这个花哨的一行命令到底告诉我们什么呢？嗯，它告诉我们`kernel`设施和`systemd`进程正在记录相当多的内容。实际上，与其他列出的项目相比，我们可以看到这两个项目的日志消息比其他项目更多。
- en: 'However, it may not be unusual for `systemd` and `kernel` to have more log
    messages in `/var/log/messages`. If there was another process that wrote many
    logs, we would be able to see this in the one-liner''s output. However, since
    our first run did not yield anything useful, we can modify the one-liner to narrow
    down the output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`systemd`和`kernel`在`/var/log/messages`中有更多的日志消息可能并不奇怪。如果有另一个写入许多日志的进程，我们将能够在一行输出中看到这一点。然而，由于我们的第一次运行没有产生有用的结果，我们可以修改一行命令来缩小输出范围：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If we look at the format of a `messages` log entry, we can see that after the
    process, the log message can be found. To narrow down our search a little bit
    more, we can add a little bit of the message to our output.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下`messages`日志条目的格式，我们会发现在进程之后，可以找到日志消息。为了进一步缩小我们的搜索范围，我们可以在输出中添加一点消息。
- en: 'We can do this by changing the `cut` command''s field list to "`1,2,5-8`".
    By adding the "`-8`" after `5`, we find that the `cut` command displays all fields
    from 5 to 8\. This has the effect of including the first three words of each log
    message in our one-liner:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`cut`命令的字段列表更改为"`1,2,5-8`"来实现这一点。通过在`5`后面添加"`-8`"，我们发现`cut`命令显示从5到8的所有字段。这样做的效果是在我们的一行命令中包含每条日志消息的前三个单词：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we also increase the `tail` command to display the last 30 lines, we can
    see some interesting trends. The first line that is very interesting is the fourth
    line in the output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还增加`tail`命令以显示最后30行，我们可以看到一些有趣的趋势。非常有趣的第一行是输出中的第四行：
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It seems that the `kernel` printed `79` log messages that start with the term
    "`Out of memory`". While it may seem a bit obvious to say, it seems that this
    server may have run out of memory at some point.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎`kernel`打印了以术语"`Out of memory`"开头的`79`条日志消息。虽然这似乎有点显而易见，但似乎这台服务器可能在某个时候耗尽了内存。
- en: 'The next two interesting lines seem to support this theory as well:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行看起来也支持这个理论：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first line seems to suggest that the kernel killed a process; the second
    line once again indicates that there is an *out of memory* situation. Could this
    system have run out of memory and in doing so killed the Apache process? This
    seems very likely.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行似乎表明内核终止了一个进程；第二行再次表明出现了*内存耗尽*的情况。这个系统可能已经耗尽了内存，并在这样做时终止了Apache进程。这似乎非常可能。
- en: What happens when a Linux system runs out of memory?
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当Linux系统内存耗尽时会发生什么？
- en: On Linux, memory is managed a bit differently from that on other operating systems.
    When a system is running low on memory, the kernel has a process that is designed
    to reclaim the used memory; this process is called **out of memory killer** (**oom-kill**).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，内存的管理方式与其他操作系统有些不同。当系统内存不足时，内核有一个旨在回收已使用内存的进程；这个进程称为**内存耗尽终结者**（**oom-kill**）。
- en: The `oom-kill` process is designed to kill processes that utilize a large amount
    of memory in order to free this memory for critical system processes. We will
    cover `oom-kill` in a bit, but first, we should understand how Linux defines out
    of memory.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`oom-kill`进程旨在终止使用大量内存的进程，以释放这些内存供关键系统进程使用。我们将稍后讨论`oom-kill`，但首先，我们应该了解Linux如何定义内存耗尽。'
- en: Minimum free memory
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小空闲内存
- en: On Linux, the oom-kill process will be initiated when the amount of free memory
    is lower than a defined minimum. This minimum is of course a kernel tunable parameter
    named `vm.min_free_kbytes`. This parameter allows you to set the amount of memory
    in kilobytes that the system ensures is always available.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，当空闲内存量低于定义的最小值时，将启动oom-kill进程。这个最小值当然是一个名为`vm.min_free_kbytes`的内核可调参数。该参数允许您设置系统始终可用的内存量（以千字节为单位）。
- en: When the available memory is below the value of this parameter, the system starts
    to take action. Before going too far, let's first look at what this value is set
    at on our system and refresh how memory is managed in Linux.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当可用内存低于此参数的值时，系统开始采取行动。在深入讨论之前，让我们首先看看我们系统上设置的这个值，并重新了解Linux中的内存管理方式。
- en: 'We can view the current `vm.min_free_kbytes` value with the same `sysctl` command
    that we used in the previous chapter:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与上一章相同的`sysctl`命令查看当前的`vm.min_free_kbytes`值：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Currently, the value is `11424` kilobytes or approximately 11 megabytes. This
    means that our system''s free memory must always be greater than 11 megabytes
    or the system will kick off the oom-kill process. This seems pretty straightforward,
    but as we know from [Chapter 4](part0028_split_000.html#QMFO1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 4. Troubleshooting Performance Issues"), *Troubleshooting Performance
    Issues*, the way Linux manages memory is not necessarily that easy:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当前值为`11424`千字节，约为11兆字节。这意味着我们系统的空闲内存必须始终大于11兆字节，否则系统将启动oom-kill进程。这似乎很简单，但正如我们从[第4章](part0028_split_000.html#QMFO1-8ae10833f0c4428b9e1482c7fee089b4
    "第4章。故障排除性能问题")中所知道的那样，Linux管理内存的方式并不一定那么简单：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If we run the `free` command on this system, we can see the current memory usage
    and how much is available. Before going too far, we will break down this output
    to refresh our understanding of how Linux uses memory.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这个系统上运行`free`命令，我们可以看到当前的内存使用情况以及可用内存量。在深入讨论之前，我们将分解这个输出，以便重新理解Linux如何使用内存。
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the first line, we can see that the system has a total of 243MB of physical
    memory. We can see in the second column that 230MB of that is currently used,
    and the third column shows that 13MB is unused. It is this unused value that the
    system is measuring in order to determine whether or not the minimum required
    memory is currently free.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们可以看到系统总共有243MB的物理内存。我们可以在第二列中看到目前使用了230MB，第三列显示有13MB未使用。系统测量的正是这个未使用的值，以确定当前是否有足够的最小所需内存空闲。
- en: This is important because if we remember from [Chapter 4](part0028_split_000.html#QMFO1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 4. Troubleshooting Performance Issues"), *Troubleshooting Performance
    Issues*, there is a second "memory free" value that we use to determine how much
    memory is available.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为如果我们记得[第4章](part0028_split_000.html#QMFO1-8ae10833f0c4428b9e1482c7fee089b4
    "第4章。故障排除性能问题")中所说的，我们使用第二个“内存空闲”值来确定有多少内存可用。
- en: '[PRE36]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: On the second line of `free`, we can see the amount of used and free memory
    when the system accounts for the memory used by the cache. As we learned earlier,
    the Linux system very aggressively caches files and filesystem attributes. All
    of this cache is stored in memory, and we can see that in the instant when this
    `free` command was run, we had 2,272 KB of memory used by cache.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`free`的第二行，我们可以看到系统在考虑缓存使用的内存量时的已使用和空闲内存量。正如我们之前学到的，Linux系统非常积极地缓存文件和文件系统属性。所有这些缓存都存储在内存中，我们可以看到，在运行这个`free`命令的瞬间，我们的缓存使用了2,272
    KB的内存。
- en: 'When the free memory (not including cache) starts to get close to the `min_free_kbytes`
    value, the system will start reclaiming some of the memory used for the cache.
    This is designed to allow the system to cache what it can, but during low memory
    conditions, this cache becomes disposable in order to prevent the oom-kill process
    from starting:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当空闲内存（不包括缓存）接近`min_free_kbytes`值时，系统将开始回收一些用于缓存的内存。这旨在允许系统尽可能地缓存，但在内存不足的情况下，为了防止oom-kill进程的启动，这个缓存变得可丢弃：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The third line of the `free` command brings us to another important step in
    Linux''s memory management: swapping. As we can see from the preceding line, when
    this `free` command was executed, the system swapped roughly 231MB of data from
    the physical memory to the swap device.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`free`命令的第三行将我们带到Linux内存管理的另一个重要步骤：交换。正如我们从前一行中看到的，当执行这个`free`命令时，系统将大约231MB的数据从物理内存交换到交换设备。'
- en: This is what we would expect to see on a system that has been running low on
    available memory. When `free` memory starts to become scarce, the system will
    start taking memory objects that are in the physical memory and push them to the
    swap memory.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们期望在运行内存不足的系统上看到的情况。当“free”内存开始变得稀缺时，系统将开始获取物理内存中的内存对象并将它们推送到交换内存中。
- en: 'How aggressively the system starts to perform these swapping activities depends
    greatly on the value defined in the kernel parameter called `vm.swappiness`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 系统开始执行这些交换活动的侵略性取决于内核参数`vm.swappiness`中定义的值：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: On our system, the `swappiness` value is currently set to `30`. This tunable
    parameter accepts values between 0 and 100, with 100 allowing for the most aggressive
    swapping policy.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的系统上，`swappiness`值目前设置为`30`。这个可调参数接受0到100之间的值，其中100允许最激进的交换策略。
- en: When the `swappiness` value is lower, the system will prefer to retain memory
    objects in the physical memory for as long as possible before moving them to the
    swap device.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当`swappiness`值较低时，系统会更倾向于将内存对象保留在物理内存中尽可能长的时间，然后再将它们移动到交换设备上。
- en: A quick recap
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 快速回顾
- en: Before going into oom-kill, let's recap what happens when the memory starts
    to get low on a Linux system. The system will first try to free memory objects
    used for disk cache and move the used memory to the swap device. If the system
    is unable to free an adequate amount of memory through the two previously mentioned
    processes, the kernel kicks off the oom-kill process.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入oom-kill之前，让我们回顾一下当Linux系统上的内存开始变得紧张时会发生什么。系统首先会尝试释放用于磁盘缓存的内存对象，并将已使用的内存移动到交换设备上。如果系统无法通过前面提到的两个过程释放足够的内存，内核就会启动oom-kill进程。
- en: How oom-kill works
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: oom-kill的工作原理
- en: As mentioned earlier, the oom-kill process is a process launched when free memory
    is low. This process is designed to identify processes that are utilizing large
    amounts of memory and are not critical to the system operation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，oom-kill进程是在空闲内存不足时启动的一个进程。这个进程旨在识别使用大量内存并且对系统操作不重要的进程。
- en: So, how does oom-kill determine this? Well, it's actually determined by the
    kernel and is constantly updated.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，oom-kill是如何确定这一点的呢？嗯，实际上是由内核确定的，并且不断更新。
- en: We discussed in the earlier chapters how every running process on a system has
    a folder within the `/proc` file system. The `kernel` maintains this folder, and
    within it, there are many interesting files.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的章节中讨论了系统上每个运行的进程都有一个在“/proc”文件系统中的文件夹。内核维护着这个文件夹，里面有很多有趣的文件。
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The three previously mentioned files are specifically relevant to the oom-kill
    process and how likely each process is to be killed. The first file that we are
    going to look at is the `oom_score` file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的三个文件与oom-kill进程及每个进程被杀死的可能性有关。我们要看的第一个文件是`oom_score`文件：
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If we `cat` this file, we see that it simply contains a number. However, this
    number is very important to the oom-kill process as this number is process 6689's
    OOM Score.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们`cat`这个文件，我们会发现它只包含一个数字。然而，这个数字对于oom-kill进程非常重要，因为这个数字就是进程6689的OOM分数。
- en: The OOM Score is a value that the `kernel` assigns to a process that determines
    whether the corresponding process is a high or low priority for oom-kill. The
    higher the score, the more likely the process is to be killed. When the kernel
    assigns this process a value, it bases the value on the amount of memory and swap
    that the process uses as well as its criticality to the system.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: OOM分数是内核分配给一个进程的一个值，用来确定相应进程对oom-kill的优先级高低。分数越高，进程被杀死的可能性就越大。当内核为这个进程分配一个值时，它基于进程使用的内存和交换空间的数量以及对系统的重要性。
- en: You may be asking yourself, *I wonder if there is a way to adjust the oom score
    for my processes.* The answer to this question is yes, there is! This is where
    the other two files `oom_adj` and `oom_score_adj` come into play. These two files
    allow you to adjust the oom score of a process, allowing you to control the likelihood
    of the process being killed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问自己，“我想知道是否有办法调整我的进程的oom分数。” 这个问题的答案是肯定的，有！这就是另外两个文件`oom_adj`和`oom_score_adj`发挥作用的地方。这两个文件允许您调整进程的oom分数，从而控制进程被杀死的可能性。
- en: Currently, the `oom_adj` file is to be depreciated in lieu of `oom_score_adj`.
    For this reason, we will simply focus on the `oom_score_adj` file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`oom_adj`文件将被淘汰，取而代之的是`oom_score_adj`。因此，我们将只关注`oom_score_adj`文件。
- en: Adjusting the oom score
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调整oom分数
- en: 'The `oom_score_adj` file supports values from -1000 to 1000, where the higher
    value will increase the likelihood of oom-kill selecting the process. Let''s see
    what happens to our oom score when we add an adjustment of 800 to our process:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`oom_score_adj`文件支持从-1000到1000的值，其中较高的值将增加oom-kill选择该进程的可能性。让我们看看当我们为我们的进程添加800的调整时，我们的oom分数会发生什么变化：'
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Simply by changing the contents to 800, the kernel detected this adjustment
    and added 800 to the oom score for this process. If this system were to run out
    of memory in the near future, this process would absolutely be killed by oom-kill.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅通过改变内容为800，内核就检测到了这个调整并为这个进程的oom分数增加了800。如果这个系统在不久的将来内存耗尽，这个进程绝对会被oom-kill杀死。
- en: If we were to change this value to -1000, this would essentially exclude the
    process from oom-kill.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个值改为-1000，这实际上会排除该进程被oom-kill杀死的可能性。
- en: Determining whether our process was killed by oom-kill
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定我们的进程是否被oom-kill杀死
- en: 'Now that we know what happens when a system runs low on memory, let''s take
    a closer look at what exactly happened to our system. To do this, we will use
    `less` to read the `/var/log/messages` file and look for the first instance of
    the "`kernel: Out of memory`" message:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们知道了系统内存不足时会发生什么，让我们更仔细地看看我们的系统到底发生了什么。为了做到这一点，我们将使用`less`来读取`/var/log/messages`文件，并寻找“kernel:
    Out of memory”消息的第一个实例：'
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Interestingly enough, the first instance of an "`Out of memory`" log message
    is 20 hours before our Apache process was killed. To add to this, the process
    killed is a very familiar process, the "`processor`" cronjob from the previous
    chapter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，“内存不足”日志消息的第一个实例是在我们的Apache进程被杀死之前的20小时。更重要的是，被杀死的进程是一个非常熟悉的进程，即上一章的“处理器”cronjob。
- en: This single log entry can actually tell us quite a bit about that process and
    why oom-kill selected this process. On the first line, we can see that the kernel
    has given the processor process a score of `265`. While not the highest score,
    we have seen that the score of 265 is very likely to be higher than that of most
    processes running at this time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这一条日志记录实际上可以告诉我们关于该进程以及为什么oom-kill选择了该进程的很多信息。在第一行，我们可以看到内核给了处理器进程一个`265`的分数。虽然不是最高分，但我们已经看到265分很可能比此时运行的大多数进程的分数都要高。
- en: 'This seems to suggest that the processor job was utilizing quite a bit of memory
    at this time. Let''s keep looking through this file to see what else may have
    been happening on this system:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎表明处理器作业在这个时候使用了相当多的内存。让我们继续查看这个文件，看看在这个系统上可能发生了什么其他事情：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Just a bit further down the log file, we can see yet another instance of the
    processor process being killed. It seems that every time this job runs, this system
    is running out of memory.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志文件中再往下看一点，我们可以看到处理器进程再次被杀死。似乎每次这个作业运行时，系统都会耗尽内存。
- en: 'In the interest of time, let''s jump down to the 21st hour to take a closer
    look at the time that our Apache process being killed:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节约时间，让我们跳到第21个小时，更仔细地看看我们的Apache进程被杀死的时间：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'It seems that the `messages` log had our answer all along. From the preceding
    few lines, we can see process `2249`, which happens to be our Apache server process
    id:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来`messages`日志一直都有我们的答案。从前面几行可以看到进程`2249`，这恰好是我们的Apache服务器进程ID：
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we see that `systemd` detected that the process was killed at `21:12:55`.
    Further, we can see from the messages log that oom-kill targeted this process
    at `21:12:54`. At this point, there is no doubt that the process was killed by
    oom-kill.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`systemd`检测到该进程在`21:12:55`被杀死。此外，我们可以从消息日志中看到oom-kill在`21:12:54`针对该进程进行了操作。在这一点上，毫无疑问，该进程是被oom-kill杀死的。
- en: Why did the system run out of memory?
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统为什么耗尽了内存？
- en: At this point, we were able to determine that the Apache service was killed
    by the system when it ran out of memory. Unfortunately, oom-kill is not the root
    cause of the issue, but rather a symptom. While it is the reason that the Apache
    service is down, if we simply restarted the process and did nothing else, the
    issue may reoccur.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们能够确定Apache服务在内存耗尽时被系统杀死。不幸的是，oom-kill并不是问题的根本原因，而是一个症状。虽然它是Apache服务停止的原因，但如果我们只是重新启动进程而不做其他操作，问题可能会再次发生。
- en: 'At this point, we need to identify what caused the system to run out of memory
    in the first place. To do this, let''s take a look at the entire list of `Out
    of memory` messages in the messages log file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要确定是什么导致系统首先耗尽了内存。为了做到这一点，让我们来看看消息日志文件中“内存不足”消息的整个列表：
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Using the `cut` and `uniq –c` commands again, we can see an interesting trend
    in the messages log. We can see that the kernel has invoked oom-kill quite a few
    times. We can see that even today the system kicked off the oom-kill process.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`cut`和`uniq -c`命令，我们可以在消息日志中看到一个有趣的趋势。我们可以看到内核已经多次调用了oom-kill。我们可以看到即使今天系统也启动了oom-kill进程。
- en: The first thing that we should do now is to figure out just how much memory
    this system has.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该做的第一件事是弄清楚这个系统有多少内存。
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Using the `free` command, we can see that the system has `238` MB of physical
    memory and `1055` MB of swap. However, we can also see that only `34` MB of memory
    is free and that the system has swapped `428` MB of physical memory.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`free`命令，我们可以看到系统有`238` MB的物理内存和`1055` MB的交换空间。然而，我们也可以看到只有`34` MB的内存是空闲的，系统已经交换了`428`
    MB的物理内存。
- en: It's very obvious that for the current workload that this system is under, it
    simply does not have enough memory allocated.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，对于当前的工作负载，该系统分配的内存根本不够。
- en: 'If we look back at the processes that are targeted by oom-kill, we can see
    an interesting trend:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下oom-kill所针对的进程，我们可以看到一个有趣的趋势：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, it is very obvious that the two processes that were killed the most often
    were `httpd` and `processor`. What we learned earlier is that oom-kill identifies
    which processes to kill on the basis of the amount of memory that they are using.
    This means that these two processes are using the most memory on the system, but
    just how much memory are they using?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，很明显，被最频繁杀死的两个进程是`httpd`和`processor`。我们之前了解到，oom-kill根据它们使用的内存量来确定要杀死的进程。这意味着这两个进程在系统上使用了最多的内存，但它们到底使用了多少内存呢？
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Using the `ps` command to specifically display the **rss** and **size** fields,
    which we learned in [Chapter 4](part0028_split_000.html#QMFO1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 4. Troubleshooting Performance Issues"), *Troubleshooting Performance
    Issues*, we can see that the `processor` job is using `130` MB of resident memory
    and `240` MB of virtual memory.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ps`命令来专门显示**rss**和**size**字段，我们在[第4章](part0028_split_000.html#QMFO1-8ae10833f0c4428b9e1482c7fee089b4
    "第4章。故障排除性能问题")中学到了，*故障排除性能问题*，我们可以看到`processor`作业使用了`130` MB的常驻内存和`240` MB的虚拟内存。
- en: If the system only has `238` MB of physical memory and the process is using
    `240` MB of virtual memory, eventually, this system is going to run low on physical
    memory.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统只有`238` MB的物理内存，而进程使用了`240` MB的虚拟内存，最终，这个系统的物理内存会不足。
- en: Resolving the issue in the long-term and short-term
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长期和短期解决问题
- en: Issues such as the one discussed in this chapter can be a bit tricky, as they
    generally have two paths to resolution. There is a long-term fix and a short-term
    fix; both are necessary, but one is only temporary.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 像本章讨论的这种问题可能有点棘手，因为它们通常有两种解决路径。有一个长期解决方案和一个短期解决方案；两者都是必要的，但一个只是临时的。
- en: Long-term resolution
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长期解决方案
- en: For the long-term resolution of this issue, we really have two options. We could
    increase the server's physical memory to provide both Apache and Processor adequate
    memory for their tasks. Alternatively, we could move the processor to another
    server.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题的长期解决方案，我们确实有两个选择。我们可以增加服务器的物理内存，为Apache和Processor提供足够的内存来完成它们的任务。或者，我们可以将processor移动到另一台服务器上。
- en: Since we know that this server has frequently killed the Apache service and
    the `processor` job, it is likely that the memory on the system is simply too
    low for it to perform both these roles. By moving the `processor` job (and likely
    the custom app that it is part of) to another system, we would be moving the workload
    to a dedicated server.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道这台服务器经常杀死Apache服务和`processor`任务，很可能是系统上的内存对于执行这两个角色来说太低了。通过将`processor`任务（以及很可能是其一部分的自定义应用程序）移动到另一个系统，我们将工作负载移动到一个专用服务器。
- en: On the basis of the memory usage of the processor, it may also be worth increasing
    the memory on the new server as well. As it seems, the `processor` job utilizes
    enough memory to cause out of memory conditions on a low memory server such as
    the one that it is on now.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 基于处理器的内存使用情况，增加新服务器的内存也可能是值得的。似乎`processor`任务使用了足够的内存，在目前这样的低内存服务器上可能会导致内存不足的情况。
- en: Determining which long-term solution is best frankly depends on the environment
    and the applications causing the system to run out of memory. In some cases, it
    may be better to simply increase the server's memory and call it a day.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 确定哪个长期解决方案最好取决于环境和导致系统内存不足的应用程序。在某些情况下，增加服务器的内存可能是更好的选择。
- en: This task is very easy in virtual and cloud environments, but it may not always
    be the best answer. Determining which answer is better truly depends on the environment
    that you are working with.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟和云环境中，这个任务非常容易，但这并不总是最好的答案。确定哪个答案更好取决于你所使用的环境。
- en: Short-term resolution
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 短期解决方案
- en: Let's say hypothetically that both the long-term resolutions would take several
    days to implement. As of right now, the Apache service is still down on our system.
    This means that our company blog is also still down; to resolve the issue momentarily,
    we need to bring Apache back up.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 假设两个长期解决方案都需要几天时间来实施。就目前而言，我们的系统上Apache服务仍然处于停机状态。这意味着我们的公司博客也仍然处于停机状态；为了暂时解决问题，我们需要重新启动Apache。
- en: However, we shouldn't just simply restart Apache with the `systemctl` command.
    Before bringing anything up, we should actually first reboot the server.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不应该只是用`systemctl`命令简单地重新启动Apache。在启动任何内容之前，我们实际上应该首先重新启动服务器。
- en: When most Linux administrators hear the words "let's reboot" they get a sinking
    feeling in their stomach. This is because, as Linux systems administrators, we
    very rarely need to reboot our systems. We have been told that rebooting Linux
    servers outside of updating the kernel is a naughty thing to do.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当大多数Linux管理员听到“让我们重启”这句话时，他们会感到沮丧。这是因为作为Linux系统管理员，我们很少需要重启系统。我们被告知在更新内核之外重启Linux服务器是一件不好的事情。
- en: For the most part, we are correct in believing that rebooting a server is not
    the right solution. However, I consider the system running out of memory to be
    a special case.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们认为重新启动服务器不是正确的解决方案。然而，我认为系统内存不足是一个特殊情况。
- en: It is my opinion that when oom-kill is launched the system in question should
    be rebooted before being fully restored to its normal state.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，在启动oom-kill时，应该在完全恢复到正常状态之前重新启动相关系统。
- en: The reason I say this is that the oom-kill process can kill any process, including
    critical system processes. While the oom-kill process does log via syslog what
    processes were killed, the syslog daemon is just another process on the system
    that can be killed by oom-kill.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我这样说的原因是oom-kill进程可以杀死任何进程，包括关键的系统进程。虽然oom-kill进程确实会通过syslog记录被杀死的进程，但syslog守护程序只是系统上的另一个可以被oom-kill杀死的进程。
- en: Even if oom-kill did not kill the syslog process in situations where oom-kill
    has killed many different processes, it can be tricky to ensure each one is up
    and running as it should be. This is particularly true when the person working
    on the issue is less experienced.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 即使oom-kill没有在oom-kill杀死许多不同进程的情况下杀死syslog进程，要确保每个进程都正常运行可能会有些棘手。特别是当处理问题的人经验较少时。
- en: While you can spend time determining what processes are running and ensure that
    you restart each process, it is much faster and arguably safer to simply reboot
    the server. As you know that upon booting, every process that is defined to start
    will be started.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以花时间确定正在运行的进程，并确保重新启动每个进程，但简单地重新启动服务器可能更快，而且可以说更安全。因为你知道在启动时，每个定义为启动的进程都将被启动。
- en: While not every system administrator would agree with this opinion, I believe
    that it is the best approach to ensure that the system is in a stable state. It's
    important to remember though that this is only a short-term solution, upon rebooting,
    unless something changes, the system can simply run out of memory again.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并非每个系统管理员都会同意这种观点，但我认为这是确保系统处于稳定状态的最佳方法。但重要的是要记住，这只是一个短期解决方案，重新启动后，除非有变化，系统可能会再次出现内存不足的情况。
- en: For our situation, it would be best to disable the `processor` job until the
    server's memory can be increased or the job can be moved to a dedicated system.
    However, that may not be acceptable in all situations. Like the long-term resolution,
    preventing this from happening again is situational and depends on the environment
    that you are managing.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的情况，最好是在服务器的内存增加或作业可以移至专用系统之前禁用“processor”作业。然而，在某些情况下，这可能是不可接受的。像长期解决方案一样，防止再次发生这种情况是情境性的，并取决于你所管理的环境。
- en: 'Since we assume that the short-term solution is the right solution for our
    example, we will proceed to reboot the system:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们假设短期解决方案是我们示例的正确解决方案，我们将继续重新启动系统：
- en: '[PRE50]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Once the system is back online, we can validate that Apache is running with
    the `systemctl` command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 系统恢复在线后，我们可以使用`systemctl`命令验证Apache是否正在运行。
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If we run `free` again on this system, we can see that the memory utilization
    is much lower, at least until now:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这个系统上再次运行`free`命令，我们可以看到内存利用率要低得多，至少直到现在为止。
- en: '[PRE52]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we used our troubleshooting skills to identify both the issue
    affecting the company blog and the root cause of this issue. We were able to use
    the skills and techniques that we learned in earlier chapters to determine that
    the Apache service was down. We also identified that the root cause of this issue
    was the system running out of memory.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们运用了我们的故障排除技能，确定了影响公司博客的问题以及这个问题的根本原因。我们能够运用在之前章节学到的技能和技术，确定Apache服务已经停止。我们还确定了这个问题的根本原因是系统内存耗尽。
- en: We could see by investigating the log files that the two processes using the
    most memory on the system were Apache and a custom application named `processor`.
    Furthermore, by identifying these processes, we were able to make a long-term
    recommendation to prevent this issue from re-occurring.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调查日志文件，我们发现系统上占用最多内存的两个进程是Apache和一个名为“processor”的自定义应用程序。此外，通过识别这些进程，我们能够提出长期建议，以防止此问题再次发生。
- en: On top of all this, we learned quite a bit about what happens when Linux systems
    run out of memory.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们还学到了当Linux系统内存耗尽时会发生什么。
- en: In the next chapter, we will put everything you have learned this far to the
    test by performing a root cause analysis of an unresponsive system.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把你到目前为止学到的一切付诸实践，通过对一个无响应系统进行根本原因分析。
