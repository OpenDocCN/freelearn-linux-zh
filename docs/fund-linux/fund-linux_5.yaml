- en: More Advanced Command Lines and Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更高级的命令行和概念
- en: 'In this chapter, we are going to take a look at the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下以下内容：
- en: Basic networking concepts
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本网络概念
- en: Installing new software and updating the system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装新软件和更新系统
- en: Introduction to services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务简介
- en: Basic system troubleshooting and firewalling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本系统故障排除和防火墙
- en: Introduction to ACL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACL简介
- en: '`setuid`, `setgid`, and `sticky bit`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setuid`，`setgid`和`sticky bit`'
- en: Basic networking concepts
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本网络概念
- en: In this section, you will learn the foundations of networking in Linux. Everything
    about networking is within the classic domain of Unix and Linux, and, in fact,
    the old Unix folks do say that Unix has been created for network communication.
    Linux is considered one of the best systems to use, learn, test, play, diagnose,
    and troubleshoot computer networks because a lot of great tools are available
    in Linux for free and come right out of the box, or just need a single command
    to install. There's a lot to learn about the subject of computer networks, and
    here we can only teach you the fundamentals of it using the CentOS 7 Linux operating
    system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习Linux中网络的基础知识。关于网络的一切都在Unix和Linux的经典领域内，事实上，老的Unix人说Unix是为了网络通信而创建的。Linux被认为是使用、学习、测试、玩耍、诊断和排除计算机网络的最佳系统之一，因为Linux中有很多免费的优秀工具，这些工具可以直接使用，或者只需要一个命令来安装。关于计算机网络的主题有很多要学习的地方，在这里我们只能使用CentOS
    7 Linux操作系统来教授您其中的基础知识。
- en: 'Now, let''s learn about computer networks from 10,000 up. The two most fundamental
    concepts in networking are the network, or subnetwork, and the IP address. The
    three most important facts every Linux user needs to know are the network, or
    sometimes called the subnetwork, the IP address, and the rules of the network:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从一万英尺高处了解计算机网络。网络或子网络和IP地址是网络中最基本的两个概念。每个Linux用户需要知道的三个最重要的事实是网络或有时称为子网络，IP地址和网络规则：
- en: 'Rule 1: The network'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则1：网络
- en: 'Every network, or sometimes called subnetwork, has a so-called network address
    consisting of only numbers, which looks like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网络或有时称为子网络，都有一个由数字组成的所谓的网络地址，看起来像这样：
- en: '![](img/350a4969-33cb-4b4e-8f34-8d04af3d0d28.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/350a4969-33cb-4b4e-8f34-8d04af3d0d28.png)'
- en: 'Rule 2: The IP address'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则2：IP地址
- en: 'Every computer needs an IP address for communication, which is part of a subnetwork''s
    address. In our example, the first three numbers divided by dots are the same
    between the IP addresses and the network address:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每台计算机需要一个IP地址进行通信，这个IP地址是子网络地址的一部分。在我们的例子中，由点分隔的前三个数字在IP地址和网络地址之间是相同的：
- en: '![](img/e8143da7-1838-4d7a-9c09-19dc442dc282.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8143da7-1838-4d7a-9c09-19dc442dc282.png)'
- en: 'Rule 3: The same network'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规则3：相同的网络
- en: 'The easiest way for network communication between two or multiple computers
    is to connect them physically (for example, by using network cables and a single
    switch), and then put them in the same network, which means choosing all of the
    computers'' IP addresses from the same range as our subnetwork''s network address.
    In our example, choose `10.0.2` as the first three digits for all our IP addresses.
    As you can see, only the last digit is variable. Every computer that wants to
    talk to another computer in the same network then only needs the correct IP address
    of the recipient. This is also the basic setup of almost all private networks
    you may have at home:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 两台或多台计算机之间进行网络通信的最简单方法是将它们物理连接（例如，使用网络电缆和单个交换机），然后将它们放在同一个网络中，这意味着选择所有计算机的IP地址都来自与我们子网络的网络地址相同的范围。在我们的例子中，选择`10.0.2`作为所有IP地址的前三位数字。正如您所看到的，只有最后一位是可变的。然后，想要与同一网络中的另一台计算机通信的每台计算机只需要知道接收方的正确IP地址。这也是几乎所有家庭私人网络的基本设置：
- en: '![](img/82fd0c2c-7b75-4719-98f7-d4eac7a40776.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82fd0c2c-7b75-4719-98f7-d4eac7a40776.png)'
- en: 'As we have just learned, for normal network communication, all participants
    need to be in the same network. If this was all there was to networking, we would
    have to stop here and modern communication and the World Wide Web would not exist.
    The reality is that there are millions of networks connected together around the
    globe, such as our own private one, which are all connected through routers. If
    you want to communicate with another machine in your network or any other network,
    your computer needs to have a so-called IP routing table that defines static routes
    or the next hop towards a particular destination. This IP routing table is part
    of every Linux operating system. For example, if we have a private network consisting
    of three subnetworks with the following IP network addresses, if you want to get
    into contact with another computer in your subnetwork, your routing table could
    work the following way. If there is an entry in the table that defines what to
    do if someone wants to access the IP address of the `10.0.2.0` subnetwork, for
    example, with the IP `10.0.2.15`, there is a route entry in the table that defines
    that you should hop to the `10.0.2.0` network:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚学到的，对于正常的网络通信，所有参与者都需要在同一个网络中。如果网络只是这样，我们就必须在这里停下来，现代通信和全球网络就不会存在。事实上，全球连接了数百万个网络，例如我们自己的私人网络，它们都通过路由器连接在一起。如果您想与您网络中的另一台计算机或任何其他网络中的计算机进行通信，您的计算机需要具有所谓的IP路由表，该表定义了静态路由或通往特定目的地的下一跳。这个IP路由表是每个Linux操作系统的一部分。例如，如果我们有一个由三个子网络组成的私人网络，具有以下IP网络地址，如果您想与您子网络中的另一台计算机联系，您的路由表可能按以下方式工作。如果表中有一个条目，定义了如果有人想要访问`10.0.2.0`子网络的IP地址，例如，使用IP`10.0.2.15`，则表中有一个路由条目，定义了您应该跳转到`10.0.2.0`网络：
- en: '![](img/7cc02cbc-89a6-49bf-981a-7831a5248fa6.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7cc02cbc-89a6-49bf-981a-7831a5248fa6.png)'
- en: 'The same happens if you want to access the machine with the IP address `192.168.122`.
    Because there is an entry in the table, the routing table will hop to the `192.168.1.0`
    network that this computer is part of:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想访问具有IP地址`192.168.122`的机器，情况也是一样的。因为路由表中有一个条目，所以路由表将跳转到这台计算机所属的`192.168.1.0`网络：
- en: '![](img/c290d1ac-a116-4c33-b712-677910b343dd.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c290d1ac-a116-4c33-b712-677910b343dd.png)'
- en: 'For all the other IP addresses where there is no explicit rule, the so-called
    default route will be used. In most private networks, the default rule is the
    IP address of a real hardware router, which basically is the same as an IP routing
    table, but which can do more, as it is connected to other routers around the globe
    where it will find its way to the correct destination address:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有明确规则的所有其他IP地址，将使用所谓的默认路由。在大多数私人网络中，默认规则是一个真实硬件路由器的IP地址，它基本上与IP路由表相同，但可以做更多的事情，因为它连接到全球其他路由器，它将找到通往正确目的地地址的路径：
- en: '![](img/c01d8f98-0bf5-49bf-95e4-06f4020e8a36.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c01d8f98-0bf5-49bf-95e4-06f4020e8a36.png)'
- en: 'This is also called dynamic routing, as the router or path between the source
    and the destination can vary depending on which routers it will use. Normally,
    each private network that most internet service providers offer has only one public
    IP address that connects to the public internet:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这也被称为动态路由，因为源和目的地之间的路由器或路径可能会有所不同，取决于它将使用哪些路由器。通常，大多数互联网服务提供商提供的每个私人网络只有一个连接到公共互联网的公共IP地址：
- en: '![](img/9b03a412-0b6b-439f-b6a1-77849dc6c292.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b03a412-0b6b-439f-b6a1-77849dc6c292.png)'
- en: All machines from our private network need to go via this router, with its single
    public IP address, if they want to communicate with other computers in the public
    internet.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们私人网络中的所有计算机都需要通过这个路由器，带有其单个公共IP地址，如果它们想要与公共互联网中的其他计算机通信。
- en: On the other hand, if an outside public machine from the internet wants to access
    the private computers from our subnetwork, the router needs to handle the correct
    delivery of messages to the correct recipient, which has an internal IP address
    only visible within our private network.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果来自互联网的外部公共机器想要访问我们子网络中的私人计算机，路由器需要处理将消息正确传递给正确的接收者，这些接收者只在我们的私人网络内部可见。
- en: 'But how can you define an IP address for a computer? The IP address needs to
    be set on an OS level in the correct configuration location associated with a
    certain network interface:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如何为计算机定义IP地址呢？IP地址需要在与某个网络接口相关联的正确配置位置上设置在操作系统级别：
- en: '![](img/09f07a3c-9a4a-4bde-b997-d2df61ddd88f.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09f07a3c-9a4a-4bde-b997-d2df61ddd88f.png)'
- en: But, as mentioned before, the IP addresses need to be unique in the same subnetwork;
    otherwise, the correct recipient for a network message cannot be found.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如前所述，IP地址在同一子网络中需要是唯一的；否则，无法找到网络消息的正确接收者。
- en: 'So, how can you take care of that? The first approach is to manually manage
    a list of computers and all free and reserved IP addresses available in this network.
    Here, we need to assign static IP addresses, which means every computer gets an
    IP address hardcoded into the system, which will not change and remain stable:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你如何处理呢？第一种方法是手动管理计算机列表和此网络中所有可用的空闲和保留IP地址。在这里，我们需要分配静态IP地址，这意味着每台计算机都会获得硬编码到系统中的IP地址，这些地址不会改变并保持稳定：
- en: '![](img/4a981e2c-3333-4380-90ab-3fe3e8f26644.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a981e2c-3333-4380-90ab-3fe3e8f26644.png)'
- en: 'Often, important services in networks, such as a mail or web server, have a
    static IP because they must be reachable under the same address all the time from
    multiple other computers or services. But, as you can imagine, this system is
    very inflexible and needs manual intervention all the time. Just think about a
    public wireless hotspot and all the people who are connecting to this network
    all the time with multiple devices, such as smartphones, laptops, and tablets.
    A much better solution is to use a so-called DHCP server. This is a service running
    in your network that listens to new devices and keeps a database of all devices
    currently connected to the network. It automatically assigns or revokes, and manages,
    in a very reliable manner, IP addresses to all the machines connected:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，网络中的重要服务，如邮件或Web服务器，具有静态IP，因为它们必须始终在相同地址下从多台其他计算机或服务中可访问。但是，正如你可以想象的，这个系统非常不灵活，需要经常手动干预。想象一下一个公共无线热点，以及一直连接到该网络的所有人，使用多个设备，如智能手机、笔记本电脑和平板电脑。一个更好的解决方案是使用所谓的DHCP服务器。这是在您的网络中运行的一个服务，它监听新设备，并保持当前连接到网络的所有设备的数据库。它自动分配或撤销，并以非常可靠的方式管理IP地址给所有连接的机器：
- en: '![](img/9a6a7d59-ae58-42cf-99a1-a57362865dc5.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a6a7d59-ae58-42cf-99a1-a57362865dc5.png)'
- en: 'The IP addresses assigned to the computers are dynamic, which means tomorrow,
    your computer can have an IP address other than the one used today. The great
    thing about this system is that it can also send additional information about
    your network to the computers connected, for example, the IP address of a private
    DNS or mail server in your network, as can be seen in the following diagram:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给计算机的IP地址是动态的，这意味着明天，您的计算机可能具有不同于今天使用的IP地址。这个系统的好处是它还可以向连接的计算机发送有关您网络的其他信息，例如，您网络中私有DNS或邮件服务器的IP地址，如下图所示：
- en: '![](img/f579f775-7eeb-4f85-9df7-6a3f491e357b.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f579f775-7eeb-4f85-9df7-6a3f491e357b.png)'
- en: A DNS server is another very important networking feature that we need to know
    about. As we have just learned, computers communicate with each other using IP
    addresses only, which are just numbers. As we humans are not so good at memorizing
    or recalling long sequences of numbers, but are much better working with names
    for objects or things, a system has been developed to assign names or aliases
    to these IP addresses so that we can address computers by names instead.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: DNS服务器是另一个非常重要的网络功能，我们需要了解。正如我们刚刚学到的，计算机只使用IP地址相互通信，这些只是数字。由于我们人类不擅长记忆或回忆长序列的数字，但在使用对象或事物的名称时要好得多，因此开发了一种系统，为这些IP地址分配名称或别名，以便我们可以用名称而不是IP地址来寻址计算机。
- en: 'A DNS server has a database that stores these relationships. As computers can
    only work with numbers and not names on the network, every time we want to connect
    the computer using a name, a corresponding DNS server gets asked internally to
    translate the name to its corresponding IP address so that we can make the right
    connection with the IP address instead. Now, for resolving names of the normal
    internet, such as `google.com`, we will use some public DNS servers normally provided
    by your ISP or from another source:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: DNS服务器有一个存储这些关系的数据库。由于计算机只能在网络上使用数字而不是名称，所以每次我们想要使用名称连接计算机时，都会内部询问相应的DNS服务器，将名称翻译为相应的IP地址，以便我们可以使用IP地址进行正确的连接。现在，为了解析正常互联网的名称，比如`google.com`，我们通常会使用一些由您的ISP或其他来源提供的公共DNS服务器：
- en: '![](img/a7436e53-37c4-4f67-ac08-c92aca2dc5a2.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7436e53-37c4-4f67-ac08-c92aca2dc5a2.png)'
- en: But how can we give names to our internal private computers' IP addresses in
    our subnetwork when the public DNS servers don't have this information? One solution
    would be to install and set up our own private DNS server and add new names to
    IP address relationships.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当公共DNS服务器没有此信息时，我们如何为子网络中的内部私有计算机的IP地址提供名称？一种解决方案是安装和设置我们自己的私有DNS服务器，并添加新的名称到IP地址关系。
- en: 'As this needs a lot of work to install and configure. An easier, and quicker,
    solution is to put the name to an IP address relationship locally in a special
    file called the `/etc/hosts` file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这需要大量工作来安装和配置。一个更简单、更快速的解决方案是将名称与IP地址关系放在一个特殊的文件中，称为`/etc/hosts`文件：
- en: '![](img/01781fed-e595-4932-8c2d-ea8805ed09ee.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01781fed-e595-4932-8c2d-ea8805ed09ee.png)'
- en: The biggest disadvantage of using the hosts file is that you have to put this
    file on every single computer in your network that wants to resolve network names,
    and also you have to keep this file up to date at all times so that each time
    a new computer is added to the network, every computer in the network needs to
    update their hosts file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用hosts文件的最大缺点是，您必须在网络中的每台计算机上放置此文件，以解析网络名称，并且您还必须始终保持此文件的最新状态，以便每次向网络添加新计算机时，网络中的每台计算机都需要更新其hosts文件。
- en: 'Until now, we have only spoken of names to IP address relationships when it
    comes to DNS servers and the hosts file. But here we need to discuss the anatomy
    of such a name in greater detail. For example, you could give all the computers
    in your network hostnames of the persons working with them:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只谈到了DNS服务器和hosts文件的名称到IP地址关系。但是在这里，我们需要更详细地讨论这种名称的解剖。例如，您可以为网络中的所有计算机分配与其一起工作的人的主机名：
- en: '![](img/dc16a2b3-f028-4381-8ea8-66ddbc9429c8.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc16a2b3-f028-4381-8ea8-66ddbc9429c8.png)'
- en: 'You can also use any name schema you like, but, as you can imagine, these hostnames
    are not unique enough to fully qualify a computer in a network so that we can
    address it directly. Bear in mind that our private network can consist of several
    different subnetworks, for example, one for the IT department, and one for the
    human resources department:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用任何您喜欢的名称模式，但是，正如您可以想象的那样，这些主机名不够唯一，无法完全确定网络中的计算机，以便我们可以直接寻址。请记住，我们的私人网络可能由几个不同的子网络组成，例如，一个用于IT部门，一个用于人力资源部门：
- en: '![](img/c009193b-7539-4697-90f4-1c0e0abe623f.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c009193b-7539-4697-90f4-1c0e0abe623f.png)'
- en: 'Here, two people can easily exist with the same name in different subnetworks,
    so this would not work because the computer hostname, Carl, exists in both networks
    and we just cannot use the hostname alone to differentiate between unique computer
    names. Therefore, we can also give names to subnetworks or network addresses.
    This kind of name is also called the DNS name, or domain name. The hostname or
    name of the computer plus the DNS name, combined together and separated by a dot,
    is called the **fully-qualified domain name** (**FQDN**), and really is needed
    each time we need to access computers in different networks outside our own local
    subnetwork:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，两个人可以很容易地存在于不同的子网络中，所以这是行不通的，因为计算机主机名Carl存在于两个网络中，我们不能仅仅使用主机名来区分唯一的计算机名称。因此，我们还可以为子网络或网络地址分配名称。这种名称也称为DNS名称或域名。计算机的主机名或名称加上DNS名称，组合在一起，用点分隔，称为**完全限定域名**（**FQDN**），每当我们需要访问本地子网络之外的不同网络中的计算机时，都是真正需要的：
- en: '![](img/2bf24fce-9aed-48ff-bedc-288f2b8a38c3.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2bf24fce-9aed-48ff-bedc-288f2b8a38c3.png)'
- en: So here, using the fully-qualified name to address Carl at **it-department.com**
    will not clash with the Carl in the **human-resources.com** subnetwork.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，使用全名来寻址**it-department.com**的Carl将不会与**human-resources.com**子网络中的Carl发生冲突。
- en: Let's recap! The hostname is a computer name (for example, Carl), the DNS name
    is the name of a network or subnetwork, such as `my-company.com` or `google.com`,
    and the fully-qualified domain name is the hostname plus the DNS name separated
    by a dot (for example, `Carl.my-company.com` or `mail.google.com`).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下！主机名是计算机名称（例如，Carl），DNS名称是网络或子网络的名称，例如`my-company.com`或`google.com`，完全限定域名是主机名加上由点分隔的DNS名称（例如，`Carl.my-company.com`或`mail.google.com`）。
- en: 'In [Chapter 1](16d0169d-0972-43c0-b5e4-228d9b8956ad.xhtml), *Introduction to
    Linux*, of this book, we set up three VMs called **Master**, **client1**, and
    **client2**. We configured the network of our three machines to have one network
    interface per VM, always with the same isolated IP `10.0.2.15`, which means no
    internal connections between the three VMs can be made because they all have the
    same IP:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的[第1章](16d0169d-0972-43c0-b5e4-228d9b8956ad.xhtml) *Linux简介* 中，我们设置了三个名为**Master**、**client1**和**client2**的VM。我们配置了我们三台机器的网络，每台机器都有一个网络接口，始终使用相同的隔离IP`10.0.2.15`，这意味着三台虚拟机之间不能进行内部连接，因为它们都具有相同的IP：
- en: '![](img/c29ecc67-d1c8-41f4-a29e-64fc94d2adac.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c29ecc67-d1c8-41f4-a29e-64fc94d2adac.png)'
- en: 'We use VirtualBox port forwarding to access our machines from outside through
    SSH using the host ports `2222`, `2223`, and `2224`, which all map to port `22`,
    the internal SSH port of the machines. Now, we want to make the machines able
    to communicate with each other using an internal private network. As each network
    interface can only have one IP address, we will accomplish this by adding a second
    virtual network adapter with a new IP address from another subnetwork to each
    machine, so that every VM has one network adapter for public access via SSH, and
    one for internal subnetwork communication:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用VirtualBox端口转发来通过主机端口`2222`、`2223`和`2224`访问我们的机器，这些端口都映射到机器的内部SSH端口`22`。现在，我们希望使机器能够使用内部私有网络进行通信。由于每个网络接口只能有一个IP地址，我们将通过为每台机器添加第二个虚拟网络适配器，并为每台机器添加来自另一个子网的新IP地址，从而实现这一目标，以便每个虚拟机都有一个网络适配器用于通过SSH进行公共访问，另一个用于内部子网通信：
- en: '![](img/2c4ab2d6-47ea-468a-8086-7b9b4f8df068.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c4ab2d6-47ea-468a-8086-7b9b4f8df068.png)'
- en: 'As you can see, we use a second subnetwork called `10.0.5` instead of our `10.0.2`
    for our internal network:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用第二个子网`10.0.5`而不是我们的`10.0.2`作为我们的内部网络：
- en: '![](img/2845aa26-4aaa-4d9e-b1b3-6164484e45c5.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2845aa26-4aaa-4d9e-b1b3-6164484e45c5.png)'
- en: 'If you type in the `ip addr list`, you will get a list of all the network interfaces
    currently attached to your computer:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入`ip addr list`，您将获得当前连接到计算机的所有网络接口的列表：
- en: '![](img/6875b8b1-1a5c-42eb-8518-fbcb34ba4428.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6875b8b1-1a5c-42eb-8518-fbcb34ba4428.png)'
- en: 'The first device is the loopback device, which is a non-physical device so
    that we can make a network connection to our own computer. It always has the IP
    address `127.0.0.1`. The second network interface is enp0s3, which is a virtual
    network interface provided by the VirtualBox configuration. This reflects to adapt
    the one in the following setup:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个设备是环回设备，这是一个非物理设备，以便我们可以与自己的计算机建立网络连接。它总是具有IP地址`127.0.0.1`。第二个网络接口是enp0s3，这是VirtualBox配置提供的虚拟网络接口。这反映了以下设置中的一个：
- en: '![](img/bb9ae48a-e5ae-4748-b868-7c9fc6c7e71a.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb9ae48a-e5ae-4748-b868-7c9fc6c7e71a.png)'
- en: This virtual network interface has the IP address `10.0.2.15` and is mainly
    used so we can SSH to the machine.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个虚拟网络接口的IP地址是`10.0.2.15`，主要用于我们可以通过SSH连接到机器。
- en: 'Now, let''s add another network interface to our virtual machine:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们给虚拟机添加另一个网络接口：
- en: 'In order to do that, first shut down the machine:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了做到这一点，首先关闭机器：
- en: '![](img/1e46dca3-5bb3-4787-87c4-bb076c37c06d.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e46dca3-5bb3-4787-87c4-bb076c37c06d.png)'
- en: 'Now, to add a new network interface for internal communication between your
    virtual machines, add a second network interface to each machine in the following
    way. First, open your VM Settings, go to Network, open the tab Adapter 2, enable
    it, and attach it to the internal network. As you can see, the name of the internal
    network is called internet. We will put all our other VMs in the same network:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了在虚拟机之间进行内部通信添加新的网络接口，以以下方式为每台机器添加第二个网络接口。首先，打开VM设置，转到网络，打开适配器2选项卡，启用它，并将其连接到内部网络。如您所见，内部网络的名称称为internet。我们将把所有其他虚拟机放在同一个网络中：
- en: '![](img/f26c507d-ad70-443c-8f8f-377cf5bc89f9.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f26c507d-ad70-443c-8f8f-377cf5bc89f9.png)'
- en: Now, press OK to proceed.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按“确定”继续。
- en: Do the same for every VM you want to have as part of your internal network for
    communication between the machines.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于您希望作为内部网络的一部分进行通信的每个虚拟机都要执行相同的操作。
- en: Now let's start one of your VMs to test the network settings.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们启动其中一个虚拟机来测试网络设置。
- en: 'Now, if you again run the IP address list, you will see that our newly added
    network interface appears at interface number 3 with the name `enp0s8`. Also,
    you will see that currently, no IP address has been associated to this device
    automatically:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果您再次运行IP地址列表，您将看到我们新添加的网络接口出现在第3个接口上，名称为`enp0s8`。此外，您将看到当前没有自动为此设备分配IP地址：
- en: '![](img/73d2b578-48b4-4c74-a1ce-8cb883c2a864.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73d2b578-48b4-4c74-a1ce-8cb883c2a864.png)'
- en: 'Let''s get some information about our current network. Let''s show the IP routing
    table for our network devices:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们获取有关当前网络的一些信息。让我们显示我们网络设备的IP路由表：
- en: '![](img/3c96398b-731e-42d5-a76e-63bb483819a1.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c96398b-731e-42d5-a76e-63bb483819a1.png)'
- en: 'As you can see, the `enp0s3` network adapter with the IP address `10.0.2.15`,
    which is the interface we used to connect via SSH from the host machine using
    port forwarding, currently has two routes in the IP routing table. The first route
    is the route for the subnetwork we are currently a member of, `10.0.2.0`. This
    means that this route will be taken if we try to contact another computer in our
    subnetwork. For example, `10.0.2.16`. All the other IP addresses we want to reach
    are using the default route, which points to the IP address `10.0.2.2`. This is
    the IP address of our router. So, for example, if you want to go to www.google.com,
    first the domain name will be translated to an IP address using a DNS server,
    and then it will be matched against our routes there. We can use the `nslookup`
    command to resolve any domain name into an IP address using the system''s default
    DNS server. As you can see, the `google.com` domain name has the following IP
    address:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`enp0s3`网络适配器的IP地址为`10.0.2.15`，这是我们用来通过端口转发从主机机器连接的接口，目前在IP路由表中有两条路由。第一条路由是我们当前所属的子网`10.0.2.0`的路由。这意味着如果我们尝试联系我们子网中的另一台计算机，例如`10.0.2.16`，将采用这条路由。我们想要到达的所有其他IP地址都使用默认路由，指向IP地址`10.0.2.2`。这是我们路由器的IP地址。因此，例如，如果您想要访问www.google.com，首先域名将使用DNS服务器转换为IP地址，然后将与我们的路由匹配。我们可以使用`nslookup`命令使用系统的默认DNS服务器将任何域名解析为IP地址。如您所见，`google.com`域名具有以下IP地址：
- en: '![](img/62bfc9da-cce4-4664-8dac-671ef3cee1a4.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62bfc9da-cce4-4664-8dac-671ef3cee1a4.png)'
- en: Since the IP addresses starting with `172` are not part of our subnetwork, the
    default route will be used. Behind the `10.0.2.2` IP address sits a real hardware
    router; it will take care of the proper routing between the virtual machine and
    the `google.com` website.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以`172`开头的IP地址不属于我们的子网，将使用默认路由。在`10.0.2.2` IP地址后面有一个真实的硬件路由器；它将负责虚拟机和`google.com`网站之间的正确路由。
- en: Before we create a new network connection between our three virtual machines
    using the `enp0s8` network interface, let's set three unique FQDNs. We will do
    this using the root account.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用`enp0s8`网络接口在我们的三台虚拟机之间创建新的网络连接之前，让我们设置三个唯一的FQDN。我们将使用root帐户进行此操作。
- en: 'To print out the FQDN, use the `hostnamectl status` command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印出FQDN，请使用`hostnamectl status`命令：
- en: '![](img/d2b2fee6-5c14-4e70-8cd7-9abf309a5f1b.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2b2fee6-5c14-4e70-8cd7-9abf309a5f1b.png)'
- en: As you can see, currently we have the FQDN of `localhost.localdomain`. Now,
    to change the FQDN, use the set-hostname option of the `hostnamectl` command.
    In our example, we used the hostname or computer name master and the DNS name,
    `centos7vt.com`. The fully-qualified domain name is `master.centos7vt.com`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，目前我们有`localhost.localdomain`的FQDN。现在，要更改FQDN，请使用`hostnamectl`命令的set-hostname选项。在我们的示例中，我们使用了主机名或计算机名master和DNS名称`centos7vt.com`。完全合格的域名是`master.centos7vt.com`。
- en: Let's recheck using the `status` option. On our two other VMs, we will later
    set the `hostnames`, `client1` and `client2`, and the same DNS name, `centos7vt.com`.
    You can also set the FQDN by editing the `/etc/hostname` file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`status`选项进行重新检查。在我们的另外两个VM上，我们稍后将设置`hostnames` `client1`和`client2`，以及相同的DNS名称`centos7vt.com`。您还可以通过编辑`/etc/hostname`文件来设置FQDN。
- en: 'To change your system''s default DNS server IP address, open the file called
    `/etc/resolv.conf`. Under the keyword name server, you can change or add new name
    servers. For example, to add a new name server, introduce a new name server line
    and change the IP address. In this example, we will use Google''s official DNS
    server address, or you can just use `1`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改系统的默认DNS服务器IP地址，请打开名为`/etc/resolv.conf`的文件。在关键字名称服务器下，您可以更改或添加新的名称服务器。例如，要添加新的名称服务器，请引入新的名称服务器行并更改IP地址。在此示例中，我们将使用Google的官方DNS服务器地址，或者您可以只使用`1`：
- en: '![](img/c13125f7-07d1-4c24-9338-b0f1fdbfa1f3.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c13125f7-07d1-4c24-9338-b0f1fdbfa1f3.png)'
- en: 'Next, let''s set up a new static network configuration for our new network
    adapter, `enp0s8`. On CentOS 7, all the network configuration files can be found
    at `/etc/sysconfig/network-scripts`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为我们的新网络适配器`enp0s8`设置一个新的静态网络配置。在CentOS 7上，所有网络配置文件都可以在`/etc/sysconfig/network-scripts`中找到：
- en: '![](img/4ee5ade4-92f0-467d-bfc4-5c02715d4b29.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ee5ade4-92f0-467d-bfc4-5c02715d4b29.png)'
- en: 'As you can see, for the `enp0s3` network interface, a corresponding network
    interface configuration file called `ifcfg-enp0s3`. Let''s view its content by
    typing `cat ifcfg-eno0s3` exists:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于`enp0s3`网络接口，有一个相应的网络接口配置文件称为`ifcfg-enp0s3`。通过键入`cat ifcfg-eno0s3`来查看其内容：
- en: '![](img/2a6f1619-bd75-49dd-b4c5-e3611bb8b4a5.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a6f1619-bd75-49dd-b4c5-e3611bb8b4a5.png)'
- en: The most important things to know about this Ethernet network device are that
    it's getting its IP address from a DHCP server, the device is activated on boot
    up, and has the device ID `enp0s3`. The other items you see in this configuration
    file can also become very important when configuring different network devices
    in different environments. Since there is no visual manual page for the `if` configuration
    file format, please refer to the excellent documentation at `/usr/share/doc/initscripts-*
    sysconfig.txt:`
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此以太网网络设备最重要的事情是，它从DHCP服务器获取其IP地址，设备在启动时激活，并且具有设备ID`enp0s3`。在配置不同环境中的不同网络设备时，此配置文件中的其他项目也可能变得非常重要。由于`if`配置文件格式没有可视化手册页，请参考`/usr/share/doc/initscripts-*
    sysconfig.txt`中的出色文档。
- en: '![](img/9755575b-bd9e-4891-89bd-2233ccefee41.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9755575b-bd9e-4891-89bd-2233ccefee41.png)'
- en: If you open the file and search for `ifcfg`, you will come to the section where
    all the different items of the `ifcfg` file format are being explained. For example,
    the BOOTPROTO item can have the values `none`, `bootp`, and `dhcp`. Since both
    `bootp` and `dhcp` refer to a DHCP client for our new network device, `enp0s8`,
    that we want to configure as a static device, we will use the `BOOTPROTO none`,
    but what items do we need for setting up our simple static network connection?
    Since we are setting up an internal network only, we don't need any routing set
    up and only need very little information in our **interface config** (**ifcfg**)
    file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果打开文件并搜索`ifcfg`，您将找到解释`ifcfg`文件格式的所有不同项目的部分。例如，BOOTPROTO项目可以具有值`none`、`bootp`和`dhcp`。由于`bootp`和`dhcp`都是指我们要将其配置为静态设备的新网络设备`enp0s8`的DHCP客户端，我们将使用`BOOTPROTO
    none`，但是我们在设置简单的静态网络连接时需要哪些项目呢？由于我们只设置内部网络，因此不需要设置任何路由，并且在我们的**接口配置**（**ifcfg**）文件中只需要非常少的信息。
- en: 'So we will need the following items: the name, the device, the IP address,
    because we will hardcode a static IP address, and the BOOTPROTO, which we will
    set to none. So let''s review our plan network configuration from the introduction.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将需要以下项目：名称、设备、IP地址，因为我们将硬编码一个静态IP地址，以及BOOTPROTO，我们将将其设置为none。因此，让我们从介绍中审查我们的计划网络配置。
- en: 'As you will remember, the master node we are currently logged in should have
    a second network interface with the static IP address `10.0.5.1`. **Client1**
    should have a second network adapter with the static IP address `10.0.5.2`, and
    **client2** should have `10.0.5.3`, all for internal network communication between
    the nodes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所记得的，我们当前登录的主节点应该有第二个网络接口，静态IP地址为`10.0.5.1`。**Client1**应该有第二个网络适配器，静态IP地址为`10.0.5.2`，**client2**应该有`10.0.5.3`，所有这些都是用于节点之间的内部网络通信：
- en: '![](img/a14839a1-810b-49f4-8e5c-2e6373551eb8.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a14839a1-810b-49f4-8e5c-2e6373551eb8.png)'
- en: 'So let''s configure our new device:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们配置我们的新设备：
- en: 'As you can see, we are currently in the network scripts folder, where all our
    network interface''s configuration files can be found. So let''s first create
    a new configuration file for our new network interface:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们目前位于网络脚本文件夹，所有网络接口的配置文件都可以在这里找到。因此，让我们首先为我们的新网络接口创建一个新的配置文件：
- en: '![](img/d882dba1-3d6e-442f-9f4b-1d3edcd914de.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d882dba1-3d6e-442f-9f4b-1d3edcd914de.png)'
- en: 'We will make our life easy by copying the existing configuration file for the
    `enp0s3` network device to the new `enp0s8` configuration file. Now let''s open
    this new configuration file:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过将现有的`enp0s3`网络设备的配置文件复制到新的`enp0s8`配置文件来简化我们的生活。现在让我们打开这个新的配置文件：
- en: '![](img/9df1539f-96c1-49e3-9820-e523df3ef92c.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9df1539f-96c1-49e3-9820-e523df3ef92c.png)'
- en: 'Let''s change the boot protocol to `none` for the static IP configuration.
    Most of the items are not needed, so just delete the lines. Change the name of
    the device to `s8`; UUID is not needed here. Also, change the device ID, leave
    the `ONBOOT` as `yes`, so the interface will come up on server restart, and finally,
    add a new line that defines the hardcoded IP address of our static internet network
    configuration. Use the IP address `10.0.5.1` for our master server:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将静态IP配置的引导协议更改为`none`。大多数项目都是不需要的，所以只需删除这些行。将设备名称更改为`s8`；这里不需要UUID。还要更改设备ID，将`ONBOOT`保留为`yes`，这样接口将在服务器重新启动时启动，并最后添加一行，定义我们静态互联网网络配置的硬编码IP地址。对于我们的主服务器，请使用IP地址`10.0.5.1`：
- en: '![](img/160a492c-6f77-4aae-9044-45a61fba1ec6.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/160a492c-6f77-4aae-9044-45a61fba1ec6.png)'
- en: Now save the file and exit.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在保存文件并退出。
- en: We then need to hard reset our `enp0s8` network interface so that the changes
    we made to the configuration file can be applied to the device and the static
    IP address can get active. In order to do so, first shut down the `enp0s8` device
    using the `ifdown` command.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要强制重置我们的`enp0s8`网络接口，以便我们对配置文件所做的更改可以应用到设备上，并且静态IP地址可以生效。为此，首先使用`ifdown`命令关闭`enp0s8`设备。
- en: Then bring it back online using the `ifup` command.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用`ifup`命令将其重新上线。
- en: Finally, let's review the `ip addr` list command.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们回顾一下`ip addr`列表命令。
- en: If you compare the output of `enp0s8` before we restarted the device and afterwards,
    you will see that the changes we made to the configuration file were valid, and
    now we have a static IP of `10.0.5.1` for our `enp0s8` network device.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在重新启动设备之前和之后比较了`enp0s8`的输出，您将看到我们对配置文件所做的更改是有效的，现在我们的`enp0s8`网络设备具有静态IP`10.0.5.1`。
- en: Now, after we set up the static network configuration for the enp0s8 network
    adapter, let's recheck our IP routing table with the `ip route show` command.
    If you compare the routing table before and after we have set up the new network
    interface, `enp0s8`, you will see that a new route has been created for routing
    network communications in our new `10.0.0.0` subnetwork.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们为enp0s8网络适配器设置了静态网络配置之后，让我们使用`ip route show`命令重新检查我们的IP路由表。如果您比较了我们设置新网络接口`enp0s8`之前和之后的路由表，您将看到为在我们的新`10.0.0.0`子网中路由网络通信创建了一个新路由。
- en: 'The last thing still left on the master node, as we don''t have a private DNS
    server, is to set up our network''s computer names to IP relationships in the
    `/etc/hosts` file. Always start adding new entries at the end of the file by using
    the fully-qualified domain names first, and then you can add further short hostnames.
    You can always add multiple names for the same IP address:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 作为主节点上仍然剩下的最后一件事，因为我们没有私有DNS服务器，需要在`/etc/hosts`文件中设置我们网络的计算机名称到IP的关系。始终通过首先使用完全合格的域名，然后可以添加更多的短主机名，从文件的末尾开始添加新条目。您可以始终为相同的IP地址添加多个名称：
- en: '![](img/5cf43398-71bf-472c-a115-572956e2d689.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5cf43398-71bf-472c-a115-572956e2d689.png)'
- en: The first entry will be our own machine we just set up. The other entries are
    for our clients we are about to set up shortly. Save and exit the file. Now start
    the two client VMs. After booting up the VMs is complete, open two new tabs in
    your Terminal emulator of your choosing. The first tab on the left holds the connection
    to the `master` node. On the next tab to the right, please log in to the `client2`
    VM using the SSH port forwarding on port `2223`. In the third tab, log into the
    `client2` VM on port `2224`. Now go to the middle tab where our `client1` VM is
    open.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个条目将是我们刚刚设置的自己的机器。其他条目是我们即将设置的客户端。保存并退出文件。现在启动两个客户端VM。启动VM完成后，在您选择的终端模拟器中打开两个新标签。左侧的第一个标签保持与`master`节点的连接。在右侧的下一个标签上，请使用端口`2223`上的SSH端口转发登录到`client2`
    VM。在第三个标签中，使用端口`2224`登录到`client2` VM。现在转到我们打开的`client1` VM的中间标签。
- en: 'Here let''s repeat the steps to configure our `enp0s8` network interface so
    we can make the connection between our servers:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，让我们重复配置我们的`enp0s8`网络接口的步骤，以便我们可以在服务器之间建立连接：
- en: First, log in as root.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，以root身份登录。
- en: Next, set a fully-qualified domain name to `client1.centos7vt.com`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将完全合格的域名设置为`client1.centos7vt.com`。
- en: Next, create a configuration file for our new **enp0s8** static network connection.
    Here, enter the same information as on the master; only change the IP address
    to the `10.0.5.2`. Save and exit the file.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为我们的新**enp0s8**静态网络连接创建一个配置文件。在这里，输入与主机相同的信息；只需将IP地址更改为`10.0.5.2`。保存并退出文件。
- en: 'Next, restart the network interface:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，重新启动网络接口：
- en: '![](img/ef38b7ea-cd77-4153-baf2-3a571405c203.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef38b7ea-cd77-4153-baf2-3a571405c203.png)'
- en: 'As you can see, we have successfully assigned the `10.0.5.2` IP address to
    our enp0s8 network interface. Finally, add entries to the `/etc/hosts` file so
    that we can resolve other domain names in our subnetwork. Add the same information
    as on the master:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们已成功将`10.0.5.2` IP地址分配给了我们的enp0s8网络接口。最后，在`/etc/hosts`文件中添加条目，以便我们可以解析子网络中的其他域名。添加与主机相同的信息：
- en: '![](img/33c6d24e-7726-4bbb-952c-8172592ebe07.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/33c6d24e-7726-4bbb-952c-8172592ebe07.png)'
- en: Save and exit the file. Next, do the same steps for the `client2` VM in the
    third tab. First log, in as root, use `client2` for the hostname, use the `10.0.5.3`
    for the IP address, restart your network interface, and finally, add entries to
    the `/etc/hosts` file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并退出文件。接下来，在第三个选项卡中对`client2` VM执行相同的步骤。首先以root用户登录，使用`client2`作为主机名，使用`10.0.5.3`作为IP地址，重新启动网络接口，最后，向`/etc/hosts`文件添加条目。
- en: 'Now that we have set up our private network for communication, the easiest
    way to test whether it is working properly is to use the `ping` command. This
    command can be used to see whether another host is alive and reachable. If it
    is not reachable, the following error message will be printed:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经为通信设置了私有网络，测试它是否正常工作的最简单方法就是使用`ping`命令。该命令可用于查看另一个主机是否处于活动状态并且可达。如果不可达，将打印以下错误消息：
- en: '![](img/bdd15634-cffe-40ad-b43b-dcb7674c2595.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bdd15634-cffe-40ad-b43b-dcb7674c2595.png)'
- en: 'Now let''s start our connection tests from the `master` in the first tab. First,
    let''s test if we can reach `client1` with the IP address `10.0.5.2`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从第一个选项卡中的`master`开始我们的连接测试。首先，让我们测试是否可以使用IP地址`10.0.5.2`连接到`client1`：
- en: '![](img/e37912ee-7319-4678-96be-9c0de4eb968a.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e37912ee-7319-4678-96be-9c0de4eb968a.png)'
- en: 'As you can see, it works. Also, test if we can reach `client2` with the IP
    address `10.0.5.3`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它有效。此外，测试一下我们是否可以使用IP地址`10.0.5.3`连接到`client2`：
- en: '![](img/5922c243-45c3-4a53-ba99-9d7d36306baa.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5922c243-45c3-4a53-ba99-9d7d36306baa.png)'
- en: As you can see, this also works.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这也有效。
- en: 'As a next step, test if our `/etc/hosts` configuration is also working. In
    order to do so, let''s ping the various hostnames we set up in this file. The
    fully-qualified domain name of client1 is working. Also, the hostname client1
    is working. C2 is also working as a short name for client2\. The fully-qualified
    domain name of client2 is also working. The short name client2 is working and
    the very short name c2 is also working for client2:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为下一步，测试我们的`/etc/hosts`配置是否也有效。为了这样做，让我们ping一下我们在该文件中设置的各种主机名。client1的全限定域名有效。同样，主机名client1有效。C2也作为client2的简称有效。client2的全限定域名也有效。client2的简称有效，c2作为client2的非常简称也有效：
- en: '![](img/6f2f0d87-9ba5-48e1-a600-db4e829f1f73.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f2f0d87-9ba5-48e1-a600-db4e829f1f73.png)'
- en: 'Now let''s move to client1\. Here, let''s test if we can reach the master server:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们转到client1。在这里，让我们测试是否可以连接到主服务器：
- en: '![](img/8ed41205-90b4-4282-a324-4b959042b53e.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8ed41205-90b4-4282-a324-4b959042b53e.png)'
- en: Yes, it's working. Also, you can test the master server under a different name.
    Let's also test the client2 connection. Test the master under a different name,
    and also test client1\. In summary, we can say that the network configuration
    between our three VM machines is now working properly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它有效。此外，您还可以使用不同的名称测试主服务器。让我们也测试一下client2的连接。测试不同名称下的主服务器，还要测试client1。总之，我们可以说我们三台VM机器之间的网络配置现在正常工作。
- en: Installing new software and updating the system
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装新软件和更新系统
- en: In this section, we will show you how you can install new software on your computer
    and how to update your CentOS 7 system.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何在计算机上安装新软件以及如何更新您的CentOS 7系统。
- en: 'First, let''s show all the currently installed RPM packages on the system.
    Type `yum list installed`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们显示系统上当前安装的所有RPM软件包。键入`yum list installed`：
- en: '![](img/30cb1957-3e81-4667-b8e7-54f241c1757d.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30cb1957-3e81-4667-b8e7-54f241c1757d.png)'
- en: In the installation chapter in [Chapter 1](16d0169d-0972-43c0-b5e4-228d9b8956ad.xhtml),
    *Introduction to Linux*, we already demonstrated how you can do a full system
    update using the `yum` command, which will update all of the RPM packages that
    are already included in the minimal installation, and also all the packages we
    have installed afterwards.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](16d0169d-0972-43c0-b5e4-228d9b8956ad.xhtml)的安装章节中，*Linux简介*，我们已经演示了如何使用`yum`命令进行完整的系统更新，这将更新最小安装中已包含的所有RPM软件包，以及我们之后安装的所有软件包。
- en: 'To get a list of all the updates currently available for all the software packages
    already installed on your system, type the following command to see what''s new:
    `yum check update`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取系统上已安装的所有软件包的所有更新的列表，请键入以下命令查看新内容：`yum check update`：
- en: '![](img/c76558bf-ee55-433a-922b-ef67b0f63992.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c76558bf-ee55-433a-922b-ef67b0f63992.png)'
- en: 'Here, all the RPM software packages are listed with the new version of the
    updates you can install. All updates must be done using the root user. So first
    log in as root. To update only a single ROM software package, such as the `vim-minimal`
    package, which was presented in the list of available software updates, use `yum
    update` and then incorporate the name of the package; for example, `vim-minimal`.
    Type yes when asked to update the software package, and type `yes` again to confirm
    the importing of the GBG key:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，列出了所有的RPM软件包以及您可以安装的更新的新版本。所有的更新都必须使用root用户进行。所以首先以root用户登录。要仅更新单个ROM软件包，比如在可用软件更新列表中呈现的`vim-minimal`软件包，使用`yum
    update`，然后加入软件包的名称；例如，`vim-minimal`。在询问是否更新软件包时输入yes，并再次输入`yes`确认导入GBG密钥：
- en: '![](img/b690227d-48d5-4072-ac95-acd40de53ebf.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b690227d-48d5-4072-ac95-acd40de53ebf.png)'
- en: As we can see, the `vim-minimal` package has been successfully updated to the
    latest version. As we have already learned in [Chapter 1](16d0169d-0972-43c0-b5e4-228d9b8956ad.xhtml), *Introduction
    to Linux*, in this book, just type `yum update` to do a full system update of
    all the packages currently installed on your system. Now let's press the *N* key
    to cancel the download and installation of the updates of all the packages. Most
    yum commands need some kind of confirmation by the user; for example, to confirm
    the update of software packages. If you are absolutely sure that you will answer
    yes to any question, you can further automate the `yum` command of your choosing
    by providing the `-y` flag. This works on almost any command. This will perform
    the yum action of your choosing without further confirmation by the user.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`vim-minimal`软件包已成功更新到最新版本。正如我们在[第1章](16d0169d-0972-43c0-b5e4-228d9b8956ad.xhtml)中已经学到的，在本书中，只需输入`yum
    update`来对系统上当前安装的所有软件包进行完整的系统更新。现在让我们按下*N*键来取消所有软件包的更新的下载和安装。大多数yum命令都需要用户的某种确认；例如，确认软件包的更新。如果你绝对确定会回答“是”任何问题，你可以通过提供`-y`标志来进一步自动化你选择的`yum`命令。这几乎适用于任何命令。这将执行你选择的yum操作，而无需用户进一步确认。
- en: Please note that there is a big ongoing debate as to whether you need to restart
    your system after packages have been updated. The consensus is that normally this
    is not needed, but, if the kernel or glibc software packages have been updated,
    you should do it. Of course, you should really do it for security reasons.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，关于在更新软件包后是否需要重新启动系统存在着一个长期的争论。一般的共识是通常不需要，但是，如果内核或glibc软件包已经更新，你应该这样做。当然，出于安全原因，你确实应该这样做。
- en: 'We can also see that the reboot is necessary when we compare the currently
    installed kernel with the currently running kernel in the system:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到，当我们比较系统中当前安装的内核和当前运行的内核时，需要重新启动：
- en: '![](img/51086241-cad9-4526-b139-3c426fdb7c0f.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51086241-cad9-4526-b139-3c426fdb7c0f.png)'
- en: 'The currently running kernel ends with `514.el7`. The currently installed latest
    kernel ends with `514.21`, so we are currently not running the latest kernel.
    So let''s reboot the system. After rebooting has finished and you are logged in
    as the root user back to the system, type the `uname -r` command again, and now
    we can see that we are now running the latest kernel, so rebooting was necessary
    in this instance:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当前运行的内核以`514.el7`结尾。当前安装的最新内核以`514.21`结尾，所以我们目前没有运行最新的内核。所以让我们重新启动系统。重新启动完成后，以root用户登录系统，再次输入`uname
    -r`命令，现在我们可以看到我们现在正在运行最新的内核，所以在这种情况下重新启动是必要的：
- en: '![](img/0ffbc806-45d5-4371-8a2c-66c649bd0ced.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ffbc806-45d5-4371-8a2c-66c649bd0ced.png)'
- en: 'Now, to search in your package repositories using a keyword (for example, `Apache2
    Web Server`), use the `yum search` command and then the keyword. This will print
    out a list of all the software packages matching the keyword; in our example,
    apache, in the package name or in the package description:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要使用关键字（例如`Apache2 Web Server`）在你的软件包仓库中搜索，使用`yum search`命令，然后是关键字。这将打印出所有与关键字匹配的软件包的列表；在我们的例子中，apache，无论是在软件包名称还是在软件包描述中。
- en: '![](img/a60ce958-e594-4ec3-962a-5c37c94874b8.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a60ce958-e594-4ec3-962a-5c37c94874b8.png)'
- en: If you want to get more information about one of the package names (for example,
    the HTTP package name), you can use the `yum info` subcommand.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要获取有关某个软件包名称的更多信息（例如，HTTP软件包名称），可以使用`yum info`子命令。
- en: 'Another really useful feature is if you know the name of a file or command
    included in an RPM package, but actually don''t know the name of the RPM package
    where this command or file is from, you can use the `yum whatprovides` command,
    prefixing the command or file you are searching for with an `*/`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的功能是，如果你知道一个RPM软件包中包含的文件或命令的名称，但实际上不知道这个命令或文件来自哪个RPM软件包，你可以使用`yum whatprovides`命令，将你正在搜索的命令或文件的前缀设为`*/`：
- en: '![](img/c1abd357-91c0-4b4d-985f-0d707cd77ac6.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1abd357-91c0-4b4d-985f-0d707cd77ac6.png)'
- en: In this example, we are searching for all the package names that include files
    or commands named `ifconfig`. As we can see, we have one hit in the `net-tools`
    RPM package where a binary or command exists in `/bin/ifconfig`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在搜索所有包含`ifconfig`文件或命令的软件包名称。正如我们所看到的，我们在`net-tools` RPM软件包中找到了一个匹配，其中存在一个二进制文件或命令`/bin/ifconfig`。
- en: 'Now, to install a software package, use the `yum install` command, providing
    the package name as an argument. Here, in this example, we install the Apache
    HTTP server package:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要安装一个软件包，使用`yum install`命令，提供软件包名称作为参数。在这个例子中，我们安装了Apache HTTP服务器软件包：
- en: '![](img/c6586b70-c9d5-4aab-8427-6300090f38f6.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6586b70-c9d5-4aab-8427-6300090f38f6.png)'
- en: Another interesting command is the `rpm -ql` command followed by the name of
    the installed software package to get a list of all the files and their exact
    location in the filesystem that has been installed by this software package. To
    remove a software package, you can use the `yum remove` command and then the name
    of the software package you want to remove.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的命令是`rpm -ql`命令，后面跟上已安装软件包的名称，以获取该软件包安装的所有文件及其在文件系统中的确切位置的列表。要删除一个软件包，可以使用`yum
    remove`命令，然后是要删除的软件包的名称。
- en: 'In [Chapter 4](5cb16aa6-1fad-46e8-a176-8eb9ce50e63c.xhtml), *Working with the
    Command Line*, we showed you how to use a third-party repository, called `epl`,
    to install software such as `htop`, and `iotop `because they are not available
    from the official CentOS 7 repositories. For example, if you search for the `htop`
    package, it''s not available from official sources:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](5cb16aa6-1fad-46e8-a176-8eb9ce50e63c.xhtml)中，*使用命令行*，我们向您展示了如何使用第三方软件仓库`epl`来安装诸如`htop`和`iotop`之类的软件，因为它们在官方CentOS
    7软件仓库中不可用。例如，如果你搜索`htop`软件包，它在官方来源中是不可用的：
- en: '![](img/dbd7df80-c72e-4d4b-b55b-ba849eb087c3.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbd7df80-c72e-4d4b-b55b-ba849eb087c3.png)'
- en: 'So let''s install the `epl` repository, as it is available from default package
    sources. As you can see, the `epl` repository can be installed using the `epl-release`
    RPM package:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们安装`epl`存储库，因为它可以从默认软件包源中获得。如您所见，可以使用`epl-release` RPM软件包安装`epl`存储库：
- en: '![](img/6f6ab4a0-25f8-43af-877c-a6faa714eed1.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f6ab4a0-25f8-43af-877c-a6faa714eed1.png)'
- en: Use the following command to see if the `epl` repository has been successfully
    installed by retrieving a list of all the available repositories in the system.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令查看`epl`存储库是否已成功安装，以检索系统中所有可用存储库的列表。
- en: 'We can now find the `htop` package, as it is part of `epl`. Installing other
    repositories is not so easy, since no RPM packages are available from the official
    sources, but most third-party repositories can be installed by downloading an
    external RPM. You will most likely find the repositories on a web page. For example,
    for the famous `remi` repository, you can first download the official `remi` repository
    RPM package from the official `remi` website:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以找到`htop`软件包，因为它是`epl`的一部分。安装其他存储库并不那么容易，因为官方来源没有RPM软件包，但大多数第三方存储库可以通过下载外部RPM来安装。您很可能会在网页上找到存储库。例如，对于著名的`remi`存储库，您可以首先从官方`remi`网站下载官方`remi`存储库RPM软件包：
- en: '![](img/b24cc00c-09b8-401c-960a-8068b8877e71.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b24cc00c-09b8-401c-960a-8068b8877e71.png)'
- en: 'Next, install this downloaded `remi` repository RPM using the `rpm` command
    with the capital `Uvh` option:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用带有大写`Uvh`选项的`rpm`命令安装下载的`remi`存储库RPM：
- en: '![](img/36b3d925-073f-482d-aad1-94c694276e48.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36b3d925-073f-482d-aad1-94c694276e48.png)'
- en: 'Then, you need to enable the `remi` repository by editing the `remi yum config`
    file. First, open the `remi.repo` file in your `/etc/yum.repos.d` folder. Here,
    in this file, go to the section `remi`, then go down to the keyword enabled and
    change it from `0` to `1`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要通过编辑`remi yum config`文件来启用`remi`存储库。首先，在`/etc/yum.repos.d`文件夹中打开`remi.repo`文件。在这个文件中，转到`remi`部分，然后转到关键字`enabled`并将其从`0`更改为`1`：
- en: '![](img/bdbbea0b-df94-4d34-904e-2c99c9ec5176.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bdbbea0b-df94-4d34-904e-2c99c9ec5176.png)'
- en: 'Now save the file. Then you can use your newly installed third-party repository
    after updating your repositories software packages list. To recheck if the third-party
    repositories have been installed correctly, you can also use the `yum repolist`
    command again:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存文件。然后，在更新软件包列表后，您可以使用新安装的第三方存储库。要重新检查第三方存储库是否已正确安装，还可以再次使用`yum repolist`命令：
- en: '![](img/f823d15b-ac5d-4591-9288-7371a77ad319.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f823d15b-ac5d-4591-9288-7371a77ad319.png)'
- en: Introduction to services
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务简介
- en: In this section, we will show you how to work with services in CentOS 7.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何在CentOS 7中使用服务。
- en: Let's open your three VMs, master, client1, and client2, from the previous section
    of this chapter in three different tabs that are connected together on the same
    internal subnetwork.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在三个不同的选项卡中打开上一章节中的主服务器、client1和client2三个VM，它们连接在同一个内部子网络上。
- en: 'Let''s begin by installing a simple networking service. In our example, let''s
    install the Apache2 web server on the master server, as it is very easy to set
    up and use:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从安装一个简单的网络服务开始。在我们的示例中，让我们在主服务器上安装Apache2 Web服务器，因为它非常容易设置和使用：
- en: '![](img/b1c94fc5-d607-4404-b5fb-02b51325e815.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1c94fc5-d607-4404-b5fb-02b51325e815.png)'
- en: Now, following installation of the `httpd` package on CentOS 7, you can manage
    services using the `systemctl` command, which is part of the `systemd` service.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在CentOS 7上安装`httpd`软件包后，您可以使用`systemctl`命令来管理服务，该命令是`systemd`服务的一部分。
- en: 'To get a list of all the units currently available in the system, use the following
    command: `system ctl list-units`. This will open the unit list with less navigation:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取系统中当前可用的所有单元的列表，请使用以下命令：`system ctl list-units`。这将打开带有较少导航的单元列表：
- en: '![](img/f10184d1-dbf5-4f50-9514-9da0f0dcafc5.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f10184d1-dbf5-4f50-9514-9da0f0dcafc5.png)'
- en: 'As you can see, different kinds of unit files are available; for example, one
    that ends with `device`, one that ends with `mount`, and the service files. Press
    *q* to quit the navigation. To get a list of all the services currently available
    in your system, just type `systemctl list-unit-files` and then filter for services
    by using `--type=service`. In this list, you will see all the available services
    currently enabled or disabled in your system. As we installed Apache2 Web Server
    an `httpd services` file that is currently disabled also exists. To get a detailed
    status of a single service, use the `systemctl` command with the `status` option
    and the service name; in our example, the `httpd` service:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有不同类型的单元文件可用；例如，以`device`结尾的文件，以`mount`结尾的文件和服务文件。按*q*退出导航。要获取系统中当前可用的所有服务的列表，只需键入`systemctl
    list-unit-files`，然后使用`--type=service`进行服务过滤。在此列表中，您将看到系统中当前启用或禁用的所有可用服务。与我们安装的Apache2
    Web服务器一样，当前已禁用的`httpd服务`文件也存在。要获取单个服务的详细状态，请使用带有`status`选项和服务名称的`systemctl`命令；在我们的示例中，是`httpd`服务：
- en: '![](img/5eae9ca8-290b-4f07-821c-3ea361bd9d5e.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5eae9ca8-290b-4f07-821c-3ea361bd9d5e.png)'
- en: 'As you can see, following installation of our new Apache HTTP server, the service
    is not running. By default, there are two different states a `systemd` service
    can have that are important for us: enabled or disabled, and active or inactive.
    In our example, the `httpd` service is disabled and inactive by default after
    installation. Just like any other service, the Apache HTTP server, by default,
    is disabled and inactive. Enabled means that a service should automatically start
    every time you start your Linux system, which is also referred to as on boot.
    Active means that a service is currently running.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在安装新的Apache HTTP服务器后，服务未运行。默认情况下，`systemd`服务可以有两种不同的状态对我们很重要：已启用或已禁用，已激活或未激活。在我们的示例中，`httpd`服务在安装后默认处于禁用和未激活状态。与任何其他服务一样，Apache
    HTTP服务器默认情况下是禁用和未激活的。已启用意味着服务应在每次启动Linux系统时自动启动，这也称为启动时。已激活意味着服务当前正在运行。
- en: 'To start a service, use the `systemctl start` option and then the name of the
    service; in our, example, the `httpd.service`. Now recheck the service, using
    the `status` option again:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个服务，请使用`systemctl start`选项，然后是服务的名称；在我们的例子中是`httpd.service`。现在再次检查服务，再次使用`status`选项：
- en: '![](img/e89d371a-9b1a-4bc9-89e1-153ae2eb91d2.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e89d371a-9b1a-4bc9-89e1-153ae2eb91d2.png)'
- en: 'As you can see, it''s now running. Also, you can see two other very important
    things in the output here. First, you can see that a service can consist of several
    processes. In our example, the httpd service consists of six different HTTP processes.
    The other important thing is that the `systemctl status` command will output the
    last lines of messages generated by the service when it is started up. Such lines
    of useful text generated by a process are also called a log and can give us useful
    information about the running behavior of a service. Still, our service is disabled.
    To enable it, use the `systemctl enable` option. Now view the status again:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它现在正在运行。此外，你还可以在这里的输出中看到另外两个非常重要的事情。首先，你可以看到一个服务可以由多个进程组成。在我们的例子中，httpd服务由六个不同的HTTP进程组成。另一个重要的事情是，`systemctl
    status`命令在启动服务时会输出服务生成的最后几行消息。进程生成的这些有用的文本行也称为日志，可以为我们提供有关服务运行行为的有用信息。不过，我们的服务目前是禁用状态。要启用它，请使用`systemctl
    enable`选项。现在再次查看状态：
- en: '![](img/b9c38fcc-8e8d-4750-b4e7-91730e31363f.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9c38fcc-8e8d-4750-b4e7-91730e31363f.png)'
- en: You can see now that it's also enabled, so this service will automatically start
    up every time we restart our server. To stop a currently running service, use
    the `systemctl stop` option. We will see that it's inactive again.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到它也已经启用，所以这项服务将在每次重新启动服务器时自动启动。要停止当前运行的服务，请使用`systemctl stop`选项。我们会看到它再次变为非活动状态。
- en: It's important to note that starting or stopping will not influence the service's
    disabled or enabled server boot behavior. Here, this service is still enabled
    while it's not running. This is also true for the other way around. Disabling
    or enabling a service will not start or stop it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，启动或停止不会影响服务的禁用或启用服务器引导行为。在这里，这项服务仍然是启用的，尽管它没有运行。反之亦然。禁用或启用服务不会启动或停止它。
- en: 'To disable a service, use the `systemctl disable` option. Then, again, start
    the service up. Now, to test if our HTTP server is working and can host and deliver
    web content, let''s first create a standard home page for our server. The standard
    home page for our server is the `index.html` file in the `/var/www/html` folder.
    Now, incorporate the following HTML content, which is a greeting message from
    our server:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用一个服务，请使用`systemctl disable`选项。然后再次启动服务。现在，为了测试我们的HTTP服务器是否正常工作并且能够托管和传递Web内容，让我们首先为我们的服务器创建一个标准主页。我们服务器的标准主页是`/var/www/html`文件夹中的`index.html`文件。现在，将以下HTML内容包含进去，这是我们服务器的问候消息：
- en: '![](img/cff68994-f27a-4b15-8029-9a4659952270.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cff68994-f27a-4b15-8029-9a4659952270.png)'
- en: 'Save and exit the file. Now, to access our home page from our new web server
    on the master server where this web server is located, use `wget`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并退出文件。现在，要从我们所在的主服务器上的新Web服务器访问我们的主页，请使用`wget`：
- en: '![](img/eadcb655-17c1-4942-8cfc-03b71c88fcfb.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eadcb655-17c1-4942-8cfc-03b71c88fcfb.png)'
- en: As you can see, we can properly access the home page locally from our master
    server. Now, what happens if you stop the web service and try again to access
    our web page? You will see that the web page is not accessible any more. Restart
    the web server. Now, let's test if we can access our new web server from another
    machine in our local network. Just go to the client1 tab and test if the web server
    is accessible through the network. You will see that it is not.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以从我们的主服务器本地正确访问主页。现在，如果你停止Web服务并尝试再次访问我们的网页会发生什么？你会发现网页不再可访问。重新启动Web服务器。现在，让我们测试一下我们是否可以从本地网络中的另一台计算机访问我们的新Web服务器。只需转到client1选项卡并测试Web服务器是否可以通过网络访问。你会发现它是不可以的。
- en: Basic system troubleshooting and firewalling
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本系统故障排除和防火墙
- en: In this section, we will continue our work on the Apache2 Web Server we started
    in the last section, so as to make it accessible for other computers in our subnetwork.
    Also, we will give you a brief introduction to Linux firewalls in CentOS 7.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续上一节中开始的Apache2 Web服务器的工作，以便使其可以被我们子网络中的其他计算机访问。此外，我们还将简要介绍CentOS 7中的Linux防火墙。
- en: 'As briefly mentioned in the first section of this chapter, a network connection
    is always made through a combination of an IP address and the port, which together
    is called a socket address. Now, every Linux network service, such as a mail or
    web server, must be connected to an IP address and the port so that we can establish
    a connection to it at all from a different computer in the network or from the
    same local one:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分简要提到，网络连接总是通过IP地址和端口的组合进行的，这两者合称为套接字地址。现在，每个Linux网络服务，比如邮件或Web服务器，都必须连接到IP地址和端口，这样我们才能从网络中的另一台计算机或同一台本地计算机上建立连接：
- en: '![](img/ca19ad25-2863-484d-a1d2-e52c22dcc128.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca19ad25-2863-484d-a1d2-e52c22dcc128.png)'
- en: When we are talking about network communication, we often refer to this as "a
    service is listening to IP address a port b". For example, our web server is listening
    on port `80` of the IP address `10.0.2.15`, the mail service is listening on port
    `24`, the web service is listening on port `80` of the IP address `10.0.2.15`,
    and the FTP service is listening on port `21` of IP address `10.0.2.15`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论网络通信时，我们经常将其称为“一个服务正在监听IP地址a端口b”。例如，我们的Web服务器正在监听IP地址`10.0.2.15`的端口`80`，邮件服务正在监听端口`24`，Web服务正在监听IP地址`10.0.2.15`的端口`80`，FTP服务正在监听IP地址`10.0.2.15`的端口`21`。
- en: 'But maybe you are wondering which IP address does a service use for communication
    if we have configured multiple network interfaces on our system, all with a different
    IP address? The answer to this is simple. Most networking services on any Linux
    system listen to all available network interfaces for network connections by default
    after installation. For almost all standard services, you can also change this
    to listen only to a specific network interface, or network connection, or subnetwork,
    or even ranges of networks:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 但也许你想知道，如果我们在系统上配置了多个网络接口，每个接口都有不同的IP地址，那么服务使用哪个IP地址进行通信？答案很简单。在安装后，任何Linux系统上的大多数网络服务默认会监听所有可用的网络接口进行网络连接。对于几乎所有标准服务，你也可以将其更改为仅监听特定的网络接口、网络连接或子网络，甚至是网络范围：
- en: '![](img/572ef538-ecca-44bf-89a9-a9dfd2bf1c6c.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/572ef538-ecca-44bf-89a9-a9dfd2bf1c6c.png)'
- en: Some even only listen to a localhost by default after installation, as these
    often are very critical services where system administrators need to change the
    listening address intentionally as a measurement of responsibility to make them
    aware of the risks.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有些甚至在安装后默认只监听本地主机，因为这些通常是非常关键的服务，系统管理员需要有意更改监听地址，以此作为对风险的责任意识。
- en: 'So let''s say you have a Linux server that is running several networking services
    and each is listening on a different port. A firewall is a tool for managing connections
    to your computer. In Linux, the standard firewall is called **firewalld**. This
    firewall can protect your system against unwanted network connections from outside
    your system, for example, if some intruder is trying to break into your system
    and steal data. It does so by managing your incoming network ports for communication.
    By default, `firewalld` closes all incoming network ports except the port `22`
    for SSH connections. Otherwise, you would not be able to remotely connect to your
    machine:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一台运行多个网络服务并且每个服务都在不同端口上监听的Linux服务器。防火墙是管理计算机连接的工具。在Linux中，标准防火墙称为**firewalld**。这个防火墙可以保护你的系统免受外部不需要的网络连接，例如，如果有人试图侵入你的系统并窃取数据。它通过管理你的入站网络端口来实现。默认情况下，`firewalld`关闭除了用于SSH连接的端口`22`之外的所有入站网络端口。否则，你将无法远程连接到你的机器：
- en: '![](img/09ebe94d-250e-4f5e-a26f-83b843a62f48.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09ebe94d-250e-4f5e-a26f-83b843a62f48.png)'
- en: 'So if you want to have some kind of network communication, you have to explicitly
    tell the firewall to do so. You can open or close individual ports or ranges of
    ports, and so on. This helps a lot in managing security on your server, but it''s
    important to note that, by default, firewalld does not restrict any local network
    communication within a system, so the localhost network connection is always working
    and is not blocked by the firewall. Also, it''s very important to know that firewalld,
    by default, is an incoming firewall only, which means it does not block any outgoing
    connections at all:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想进行某种网络通信，你必须明确告诉防火墙这样做。你可以打开或关闭单个端口或端口范围等。这在管理服务器安全性方面非常有帮助，但重要的是要注意，默认情况下，firewalld不会限制系统内的任何本地网络通信，因此本地主机网络连接始终有效，并且不会被防火墙阻止。此外，非常重要的是要知道，默认情况下，firewalld只是一个入站防火墙，这意味着它根本不会阻止任何出站连接：
- en: '![](img/052891d5-d628-4e37-a634-28f6aea3e317.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/052891d5-d628-4e37-a634-28f6aea3e317.png)'
- en: 'In order to fix this problem, we need to know how we can troubleshoot a system
    service. So, first go back to our master server where this web server is running.
    To find out if something is wrong with your service, there are always at least
    three places where to look. The first thing we should do is to check the `systemctl
    status` output, as we have done before. As you can see, the service is currently
    running and the final current lines of output of the service also look `OK`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要知道如何对系统服务进行故障排除。因此，首先回到我们的主服务器，查看运行此Web服务器的情况。要找出服务是否出现问题，至少有三个地方可以查看。我们应该做的第一件事是检查`systemctl
    status`的输出，就像我们之前做的那样。正如你所看到的，服务目前正在运行，服务的最终当前输出行也显示为`OK`：
- en: '![](img/4852cf3c-9a62-4c11-a9ae-684b1aaf659a.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4852cf3c-9a62-4c11-a9ae-684b1aaf659a.png)'
- en: Sometimes, here in this output, you will find error messages or warnings if
    a service is not functioning normally.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在这里的输出中，如果服务没有正常运行，你会找到错误消息或警告。
- en: 'Sometimes, the last two lines of the log output for a service are not enough,
    so the second place to look for if you need to troubleshoot your service, is the
    `journalctl` command. If you use the `journalctl` command with the `-u` flag,
    you can filter log messages for your service of choice; in our example, the `httpd`
    service:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，服务的日志输出的最后两行不足以，因此如果你需要对服务进行故障排除，可以查看的第二个地方是`journalctl`命令。如果你使用`journalctl`命令和`-u`标志，你可以过滤你选择的服务的日志消息；在我们的示例中，是`httpd`服务：
- en: '![](img/3b5c5c41-1015-4efd-ab03-45686d58a550.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b5c5c41-1015-4efd-ab03-45686d58a550.png)'
- en: Here, in our example, no suspicious log output can be found in `journald`, which
    is the service that writes all the log messages of all the services running into
    a centralized database. The journal log for the Apache HTTP Server looks normal.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，在`journald`中找不到任何可疑的日志输出，这是将所有正在运行的服务的所有日志消息写入集中数据库的服务。Apache HTTP服务器的日志看起来很正常。
- en: 'So, the third place where we can have a look for troubleshooting services is
    the `rsyslog` log file, which is located at `/var/log/messages`. Open this file
    and go to the end of it, pressing capital *G*:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以查看故障排除服务的第三个地方是`rsyslog`日志文件，它位于`/var/log/messages`。打开这个文件，按大写*G*键跳到末尾。
- en: '![](img/a2171118-83f1-4ffa-8b87-340940d9040d.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2171118-83f1-4ffa-8b87-340940d9040d.png)'
- en: Here also, nothing really suspicious has been logged to the `rsyslog` file.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`rsyslog`文件中并没有记录任何可疑的内容。
- en: Some services, such as our Apache HTTP Web Server, provide their own log files
    for troubleshooting or getting info about the service.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一些服务，比如我们的Apache HTTP Web服务器，提供了自己的日志文件，用于故障排除或获取有关服务的信息。
- en: 'Please note that there is no standardized directory where a service outputs
    its own log files, but some services write their log files into a subdirectory
    under the `/var/log` file directory. Here, you can find two log files. One is
    the `access_log`, which logs user access to our web server (for example, the files
    on the server that have been downloaded). The other is the `error_log` file, which
    logs all kinds of errors that this service may encounter. So, first have a look
    at the `access_log` file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，没有标准化的目录可以让服务输出自己的日志文件，但是一些服务会将它们的日志文件写入到`/var/log`文件目录下的子目录中。在这里，您可以找到两个日志文件。一个是`access_log`，记录用户访问我们的Web服务器（例如，已下载的服务器上的文件）。另一个是`error_log`文件，记录此服务可能遇到的各种错误。因此，首先查看`access_log`文件：
- en: '![](img/0e668333-8e35-4fab-bb91-e36ce2a42c17.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e668333-8e35-4fab-bb91-e36ce2a42c17.png)'
- en: 'This looks very normal. Now, also open the `error_log` file. Jump to the end
    using capital *G*:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常正常。现在，也打开`error_log`文件。使用大写*G*跳转到末尾：
- en: '![](img/f5c1e5a5-f975-48b6-b180-f452087d2a57.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5c1e5a5-f975-48b6-b180-f452087d2a57.png)'
- en: Here, no special error messages can be found.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，找不到特殊的错误消息。
- en: The solution to the problem of why nobody outside of our server can access the
    Apache HTTP Web Server instead of CentOS 7 is that a very restrictive firewall
    is active that blocks almost any incoming network connection.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 解决CentOS 7上的Apache HTTP Web服务器之外没有人能访问的问题是因为有一个非常严格的防火墙正在阻止几乎所有传入的网络连接。
- en: 'You can view the currently allowed firewall rules by typing `firewall-cmd --list-all`.
    On CentOS 7, the standard firewall is called firewalld:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过输入`firewall-cmd --list-all`来查看当前允许的防火墙规则。在CentOS 7上，标准防火墙称为firewalld：
- en: '![](img/35a33271-a875-4714-8a9e-5de4ff1c6e07.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35a33271-a875-4714-8a9e-5de4ff1c6e07.png)'
- en: As you can see here, only the SSH service is allowed by default to communicate
    with our server. Firewalld is mainly protecting all incoming network connections.
    Outgoing connections from our server to other servers are not restricted or limited;
    that's the reason why we can access our web server from the localhost, but not
    from any other host.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在这里所见，只有SSH服务默认允许与我们的服务器通信。Firewalld主要保护所有传入的网络连接。从我们的服务器到其他服务器的出站连接没有受到限制或限制；这就是为什么我们可以从本地主机访问我们的Web服务器，但不能从任何其他主机访问的原因。
- en: 'To fix this problem, we can open the HTTP service, also known as opening port
    80, in our firewall. So that we can do that permanently, use the following two
    commands: `firewall-cmd --permanent --add-service`, and then `http`. So that the
    changes can be applied, next reload the firewall rules. Finally, let''s see if
    the HTTP service is now enabled in the firewall:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以在防火墙中打开HTTP服务，也就是打开端口80。为了能够永久地这样做，使用以下两个命令：`firewall-cmd --permanent
    --add-service`，然后是`http`。为了应用更改，接下来重新加载防火墙规则。最后，让我们看看HTTP服务现在是否在防火墙中启用了：
- en: '![](img/082b7f50-01bf-4157-bc61-71755cc6b741.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/082b7f50-01bf-4157-bc61-71755cc6b741.png)'
- en: As you can see, it works.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它有效。
- en: 'Finally, let''s test if we can make remote connections to our Apache Web Server
    from another server. Go to client1 and repeat the `wget` command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们测试一下是否可以从另一台服务器远程连接到我们的Apache Web服务器。转到client1并重复`wget`命令：
- en: '![](img/92529b85-e4fc-4cf6-864b-3e7e42283faa.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92529b85-e4fc-4cf6-864b-3e7e42283faa.png)'
- en: Yes, it works! You are now able to access your web server in your network.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它有效！您现在可以在您的网络中访问您的Web服务器。
- en: Until now, we haven't talked about how to remove a service from the firewall.
    To remove the HTTP service or port from the firewall configuration, use the following
    firewall command syntax, `firewall-cmd --permanent --remove-service`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有讨论如何从防火墙中删除服务。要从防火墙配置中删除HTTP服务或端口，请使用以下防火墙命令语法，`firewall-cmd --permanent
    --remove-service`。
- en: 'Then the service of choice; in our example, the `http` service. Similar to
    adding a service, you also have to reload the firewall here. Let''s recheck our
    firewall settings:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后选择服务；在我们的例子中，是`http`服务。与添加服务类似，您还必须在这里重新加载防火墙。让我们重新检查一下防火墙设置：
- en: '![](img/3e52883d-5cfc-41f4-a520-2197296924a7.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e52883d-5cfc-41f4-a520-2197296924a7.png)'
- en: As you can see, HTTP port has been closed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，HTTP端口已关闭。
- en: 'Finally, a very useful feature of the firewalld service is to open individual
    port numbers without providing a service name. This is very useful if you need
    to open a port where no service file, such as the HTTP, is available. For example,
    to open port `12345`, use the TCP protocol. Let''s show the new firewall configuration
    after we have reloaded the firewall:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，firewalld服务的一个非常有用的功能是可以打开单独的端口号，而无需提供服务名称。如果需要打开一个没有服务文件（例如HTTP）的端口，这将非常有用。例如，要打开端口`12345`，请使用TCP协议。让我们在重新加载防火墙后显示新的防火墙配置：
- en: '![](img/0b4341af-f9ed-4dad-8a59-1d58e993016b.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0b4341af-f9ed-4dad-8a59-1d58e993016b.png)'
- en: 'As you can see, the port `12345` is now open using the TCP protocol. Instead
    of TCP, you can also use the UDP protocol. Now, to close the port `12345` using
    the TCP protocol, use the following command. Here, also reload the firewall configuration.
    Let''s perform a recheck:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，端口`12345`现在使用TCP协议打开。除了TCP，您还可以使用UDP协议。现在，要使用TCP协议关闭端口`12345`，请使用以下命令。在这里，还要重新加载防火墙配置。让我们进行重新检查：
- en: '![](img/d6ddbcd4-835b-4b8f-b995-f77c4afefc3f.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6ddbcd4-835b-4b8f-b995-f77c4afefc3f.png)'
- en: 'Let''s summarize what we have learned so far:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下到目前为止我们学到的东西：
- en: If it is a service-related problem, first have a look at the `systemctl` output
    for the service.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是与服务相关的问题，首先查看服务的`systemctl`输出。
- en: If the problem persists, next look at the `journalctl` output for the service.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果问题仍然存在，请查看服务的`journalctl`输出。
- en: If it is a general system problem, or you cannot fix your service problems with
    the `systemctl` and `journalctl` outputs, next have a look at the `/var/log-messages
    rsyslog` output file.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这是一个一般的系统问题，或者您无法通过`systemctl`和`journalctl`的输出来解决您的服务问题，接下来看一下`/var/log-messages
    rsyslog`输出文件。
- en: Also, some services provide special log file locations outside of `journald`
    or the `rsyslog` file, so also have a look there. But you must be aware that not
    every service or program has such a special log file directory or output.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，一些服务提供了`journald`或`rsyslog`文件之外的特殊日志文件位置，因此也要查看那里。但您必须意识到，并非每个服务或程序都有这样一个特殊的日志文件目录或输出。
- en: Finally, we gave you a brief introduction to the firewalld service using predefined
    service files, such as the HTTP, and also we showed you how to work with individual
    ports that are not defined by service files. In the next chapter, we will show
    you advanced file permissions.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们向您简要介绍了使用预定义服务文件（如HTTP）的firewalld服务，并向您展示了如何处理未由服务文件定义的单个端口。在下一章中，我们将向您展示高级文件权限。
- en: Introducing ACLs
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍ACL
- en: In this section, we will give you a brief introduction to how ACLs, or access
    control lists, work.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您简要介绍ACL（访问控制列表）的工作原理。
- en: 'Linux has some special file and folder permissions, namely the ACLs, `setuid`,
    `setgid`, and `sticky bit`. If you look at the file in the filesystem, such as
    a new file that only the root user has access to, currently we are logged in as
    `olip`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Linux具有一些特殊的文件和文件夹权限，即ACL（访问控制列表）、`setuid`、`setgid`和`sticky bit`。如果您查看文件系统中的文件，比如只有root用户可以访问的新文件，当前我们登录为`olip`：
- en: '![](img/4906246a-fcfb-4bf9-86e9-485310d7210e.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4906246a-fcfb-4bf9-86e9-485310d7210e.png)'
- en: 'As you can see, the `olip` user has no write access on that file. Maybe you
    have already asked yourself this question: how can you give permissions to a file
    or folder to individual users who are not the file or group owner, in our example
    root? The only way is to use the others group, but this is not individual as all
    users who are not the file or group owner fall into this category. But here, we
    want to set single user permissions; for example, for the `olip` user.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`olip`用户对该文件没有写访问权限。也许您已经问过自己这个问题：如何将文件或文件夹的权限授予不是文件或组所有者的个别用户，比如我们的例子中的root用户？唯一的方法是使用其他组，但这不是个别的，因为所有不是文件或组所有者的用户都属于此类别。但在这里，我们想要设置单个用户权限；例如，对于`olip`用户。
- en: Access control lists, or ACLs, is a system that extends our normal file access
    control under Linux with its simple ownership and permission model. With ACLs
    you can define file or folder permissions on a single user or group-level basis.
    To work with ACLs, use the `getfacl` and `setfacl` commands.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ACL（访问控制列表）是一个系统，它通过简单的所有权和权限模型扩展了我们在Linux下的正常文件访问控制。使用ACL，您可以在单个用户或组级别上定义文件或文件夹权限。要使用ACL，请使用`getfacl`和`setfacl`命令。
- en: 'For example, to display ACLs, use the `getfacl` command and then the filename
    where you want to show permissions:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要显示ACL，请使用`getfacl`命令，然后是要显示权限的文件名：
- en: '![](img/187752b3-8eaf-47ae-81d9-33a67ca25adf.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/187752b3-8eaf-47ae-81d9-33a67ca25adf.png)'
- en: 'Here, as you can see, no ACLs have currently been set on this file. As with
    normal file permissions, if we want to change something, we need to log in as
    root. Now, to set ACLs, for example, for the `olip` user, use the following command.
    If you remember [Chapter 3](4a931838-be11-4c95-90f4-7662129e4d32.xhtml), *The
    Linux Filesystem*, this should be self-explanatory:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，目前此文件上没有设置ACL。与普通文件权限一样，如果我们想要更改某些内容，就需要以root身份登录。现在，例如，要为`olip`用户设置ACL，请使用以下命令。如果您还记得[第3章](4a931838-be11-4c95-90f4-7662129e4d32.xhtml)
    *Linux文件系统*，这应该是不言自明的：
- en: '![](img/1266dd6d-4277-4aea-b587-93992323d892.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1266dd6d-4277-4aea-b587-93992323d892.png)'
- en: 'To display the ACL, again view the ACL of this file. If you compare the `getfacl`
    command output before and after, you will see that we now have single user permissions
    for the `olup` user: `read`, `write`, and `execute`. Now, the `olip` user should
    be able to write to this file:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示ACL，请再次查看此文件的ACL。如果比较之前和之后的`getfacl`命令输出，您将看到我们现在为`olup`用户设置了单个用户权限：`读`、`写`和`执行`。现在，`olip`用户应该能够写入此文件：
- en: '![](img/a64db54e-37ed-42ff-9426-d0033d817100.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a64db54e-37ed-42ff-9426-d0033d817100.png)'
- en: Success; the ACLs are working as expected.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 成功；ACL正常工作。
- en: 'You can also set ACLs on a group-level basis. Here, instead of using the user,
    we will use the group identifier. To remove a single ACL, use the `-x` flag. You
    can also see if a file has an ACL set by the marked plus in the output of the
    `ls -l` command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以基于组设置ACL。在这里，我们将使用组标识符而不是用户。要删除单个ACL，请使用`-x`标志。您还可以通过`ls -l`命令的输出中标记的加号来查看文件是否设置了ACL：
- en: '![](img/26a876b0-52ee-4f1c-b04c-6e65a86eeda1.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26a876b0-52ee-4f1c-b04c-6e65a86eeda1.png)'
- en: setuid, setgid and sticky bit
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: setuid、setgid和sticky bit
- en: In this section, we will show you everything you need to know about the special
    file permission flags, `setid`, `setgid`, and the `sticky bit`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示有关特殊文件权限标志`setid`、`setgid`和`sticky bit`的所有必要信息。
- en: setuid
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: setuid
- en: Now let's talk about `setuid`, `setgid`, and the `sticky bit`. As we work with
    users, groups, and file permissions, let's first log in as root.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈`setuid`、`setgid`和`sticky bit`。在处理用户、组和文件权限时，让我们首先以root身份登录。
- en: 'First, let''s create a new user, group, and the copy of the `whoami` command
    locally to see what''s going on with the `setuid` flag:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新用户、组，并在本地复制`whoami`命令，以查看`setuid`标志的情况：
- en: '![](img/2f1fd404-74c4-410a-a80f-8e03419f224e.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f1fd404-74c4-410a-a80f-8e03419f224e.png)'
- en: 'Next, let''s change the file owner and group owner of this command to `awesome_user`
    and `awesome_group`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将此命令的文件所有者和组所有者更改为`awesome_user`和`awesome_group`：
- en: '![](img/02f714b5-54cd-48dc-ae56-1a3c17a4abc0.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02f714b5-54cd-48dc-ae56-1a3c17a4abc0.png)'
- en: 'Setting the `setuid`, `setgid`, and the `sticky bit` can also be done using
    octal notations. You already know about them from the file permissions chapter.
    These special permissions can be represented by one single additional bit in the
    file permission string, using the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用八进制表示法也可以设置`setuid`、`setgid`和`sticky bit`。您已经从文件权限章节了解了它们。这些特殊权限可以通过文件权限字符串中的一个额外位来表示，使用以下代码：
- en: '![](img/1ee75da5-26b6-492a-a168-1c73dc777f65.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ee75da5-26b6-492a-a168-1c73dc777f65.png)'
- en: 'The `setuid` has the number `4`, the `setgid` the number `2`, and the `sticky
    bit` the number `1`. Similar to the files'' simple `read`, `write`, and `execute`
    permissions, here you can also add combinations of special permissions to a file:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuid`的数字是`4`，`setgid`的数字是`2`，`粘滞位`的数字是`1`。与文件的简单`读`、`写`和`执行`权限类似，您还可以向文件添加特殊权限的组合：'
- en: '![](img/a7bd5161-7c6d-43a6-9d0f-5b17628d3aed.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7bd5161-7c6d-43a6-9d0f-5b17628d3aed.png)'
- en: If you want to set both `setuid` and `setgid` flags, you need to add up the
    `4` and the `2`, which totals `6`, or `setgid` and `sticky bit` are represented
    by the `3`, or `sticky bit` and `setuid` are represented by the `5`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要设置`setuid`和`setgid`标志，您需要将`4`和`2`相加，总共是`6`，或者`setgid`和`粘滞位`由`3`表示，或者`粘滞位`和`setuid`由`5`表示。
- en: 'Now, how do we set the special permission information? It can be set using
    an additional number in the `chmod` command. You already know that it takes three
    numbers to define permissions for the user, group, and others. To display special
    permissions on the file, you can use the `ls -l` command, but this is very hard
    to read and it''s more easy to use the `getfacl` command, which not only works
    for ACLs, but also shows flags that are the names for our special permissions.
    By default, no flag or special permission is defined on any file, as you can see
    in the output of the `getfacl` command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何设置特殊权限信息？可以使用`chmod`命令中的附加数字进行设置。您已经知道，为用户、组和其他人定义权限需要三个数字。要在文件上显示特殊权限，可以使用`ls
    -l`命令，但这很难阅读，更容易使用`getfacl`命令，它不仅适用于ACL，还显示了我们特殊权限的标志。默认情况下，没有为任何文件定义标志或特殊权限，如您在`getfacl`命令的输出中所见：
- en: '![](img/73ae921a-d3f2-4c5a-b852-e6be40e65382.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/73ae921a-d3f2-4c5a-b852-e6be40e65382.png)'
- en: 'Now, to add a special permission flag to a file, or, in other words, set the
    `setuid`, `setgid`, or `sticky bit`, you can use the `chmod` command with four
    numbers instead of three, where the first leading number defines the special permission.
    For example, if you use a `2` as the leading first number for the `chmod` command,
    you will set the set group ID flag, which is shown in the flags line. If we have
    an `s` at the second position, it''s the set group ID:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要向文件添加特殊权限标志，或者换句话说，设置`setuid`、`setgid`或`粘滞位`，您可以使用带有四个数字的`chmod`命令，而不是三个数字，其中第一个前导数字定义了特殊权限。例如，如果您在`chmod`命令的第一个位置使用`2`，则会设置设置组ID标志，该标志显示在标志行中。如果我们在第二个位置有`s`，那么它就是设置组ID：
- en: '![](img/51782889-847f-4473-96e9-0750a1376dc6.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51782889-847f-4473-96e9-0750a1376dc6.png)'
- en: 'Now, to set the `setuid` flag, use number `4` as your first number in the `chmod`
    command. Recheck using the `getfacl` command. Here, in the flags line, the first
    leftmost character has been set to an `s`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要设置`setuid`标志，请在`chmod`命令中使用数字`4`作为第一个数字。使用`getfacl`命令重新检查。在标志行中，最左边的字符已设置为`s`：
- en: '![](img/9f985704-14a6-4a96-a593-8d284882d887.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f985704-14a6-4a96-a593-8d284882d887.png)'
- en: 'Now, adding a combination of special file permission flags (for example, number
    6, which is a combination of `setuid` and `setgid`, or 4 plus 2, equals 6), is
    shown in the following way in the `getfacl` output:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加特殊文件权限标志的组合（例如，数字6，表示`setuid`和`setgid`的组合，或4加2等于6），在`getfacl`输出中以以下方式显示：
- en: '![](img/d4d68e59-0267-415d-b6de-289461895060.png)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4d68e59-0267-415d-b6de-289461895060.png)'
- en: 'The first leftmost flag is the `setuid` flag, and the second flag is the `setgid`
    flag. To set all three permission types, `setuid`, `setgid`, and `sticky bit`,
    use `getfacl` (path):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最左边的第一个标志是`setuid`标志，第二个标志是`setgid`标志。要设置所有三种权限类型，`setuid`、`setgid`和`粘滞位`，请使用`getfacl`（路径）：
- en: '![](img/b272143f-9236-44b3-92c2-10b5457fa3bb.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b272143f-9236-44b3-92c2-10b5457fa3bb.png)'
- en: Here, you see that all three flags have been set. The short flag for the `sticky
    bit` is a `t` instead of an `s`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到所有三个标志都已设置。`粘滞位`的短标志是`t`，而不是`s`。
- en: 'To remove all special file permissions, just use `0` as the number for the
    file permission encoding, and just use `0` as the first number for the `chmod`
    command:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除所有特殊文件权限，只需将`0`用作文件权限编码的数字，并将`0`用作`chmod`命令的第一个数字：
- en: '![](img/bfc57246-c6f3-46c0-95a4-3810d23fd8f4.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfc57246-c6f3-46c0-95a4-3810d23fd8f4.png)'
- en: Now, let's briefly discuss the `setuid` permissions. The `setuid` flag is only
    important on executable commands and never on a directory or other file types.
    It is also important to know that it does not work on script files for security
    reasons, but only on compiled binary executable files.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们简要讨论一下`setuid`权限。`setuid`标志仅对可执行命令重要，对目录或其他文件类型无关紧要。还要知道，出于安全原因，它不适用于脚本文件，而仅适用于编译的二进制可执行文件。
- en: 'As already mentioned, each process has an associated user that we refer to
    as "a user runs a command". Here, in this example, all the processes you see are
    run by the root user:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个进程都有一个关联的用户，我们称之为“用户运行命令”。在这个例子中，您看到的所有进程都是由root用户运行的：
- en: '![](img/fef88911-1180-4dd1-8764-0ed7b8b37028.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fef88911-1180-4dd1-8764-0ed7b8b37028.png)'
- en: 'Now the `setuid` permission flag will run a command as the user that is defined
    as the file owner of that file. This is important and useful for some special
    commands in the system; for example, commands that must be run as the root user
    because they access protected filesystem files or folders, but must also be executable
    for normal users. Take, for example, the `passwd` command. It accesses and writes
    to files such as the `etc/passwd` file, which is only writable for root, so this
    command must be run as root, but normal users also need to change their passwords
    on the `passwd` command:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`setuid`权限标志将以定义为该文件所有者的用户身份运行命令。这对于系统中的一些特殊命令非常重要和有用；例如，必须作为root用户运行的命令，因为它们访问受保护的文件系统文件或文件夹，但对于普通用户也必须是可执行的。例如，`passwd`命令。它访问并写入文件，例如`etc/passwd`文件，该文件仅对root可写，因此必须以root身份运行此命令，但普通用户也需要在`passwd`命令上更改密码：
- en: '![](img/fa0ec1bc-0c90-46ae-8cf3-9d208d33c490.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa0ec1bc-0c90-46ae-8cf3-9d208d33c490.png)'
- en: Now, let's exit the root user to test the `setuid` flag with a normal user account.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们退出root用户，用普通用户账户测试`setuid`标志。
- en: 'Let''s recheck if we are really the `olip` user. Now, without setting the `setuid`
    flag on a file, if we execute our local `whoami` command, it will print out our
    username, as we are the user who started it:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次检查一下我们是否真的是`olip`用户。现在，如果不在文件上设置`setuid`标志，如果我们执行本地的`whoami`命令，它将打印出我们的用户名，因为我们是启动它的用户：
- en: '![](img/486f3310-e830-4d30-94c0-5b00bb286f5a.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/486f3310-e830-4d30-94c0-5b00bb286f5a.png)'
- en: 'Now, what happens if we set the `setuid` permission on that command and execute
    it again? First, let''s view the permission flags. We will see that the `setuid`
    flag has been successfully set on that file. Now, let''s execute a command again:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在该命令上设置`setuid`权限并再次执行它，会发生什么？首先，让我们查看权限标志。我们会看到该文件上成功设置了`setuid`标志。现在，让我们再次执行一个命令：
- en: '![](img/9e855733-11e5-4b59-8287-eb5efb3fc26a.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e855733-11e5-4b59-8287-eb5efb3fc26a.png)'
- en: As you can see, the `setuid` flag works as expected. We run our command as the
    `olip` user but the file owner, `awesome_user`, was used during the execution
    of the process.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`setuid`标志的效果如预期。我们以`olip`用户身份运行命令，但在执行过程中使用的是文件所有者`awesome_user`。
- en: setgid
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: setgid
- en: Now, let's learn about the `setgid` permission. This flag has two different
    meanings, which is important to know about and should be memorized. When set on
    a file, it has the same effect as the `setuid` permission, but here it will execute
    a command with the rights of the group owner instead of the file owner.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解一下`setgid`权限。这个标志有两个不同的含义，这是很重要的，应该被记住。当在文件上设置时，它与`setuid`权限具有相同的效果，但这里它将以组所有者的权限执行命令，而不是文件所有者的权限。
- en: 'To set the `setgid` flag on the file, use the number `2` in the `chmod` command:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chmod`命令中使用数字`2`来设置文件的`setgid`标志：
- en: '![](img/6045bc66-e569-4642-b5ab-758dbd38206a.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6045bc66-e569-4642-b5ab-758dbd38206a.png)'
- en: The second meaning of the `setgid` flag is very important and should be memorized
    because it can be a typical use case. If you set the `setgid` on a folder instead
    of a file, every new file, or folder, or subfolder created within this folder
    will automatically get the group permissions of the folder where you set the `setgid`
    flag. This works for all the files included recursively. This can become very
    important because normally the group permissions of new files created automatically
    get assigned by the creator of the file.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`setgid`标志的第二个含义非常重要，应该被记住，因为它可能是一个典型的用例。如果在文件夹而不是文件上设置了`setgid`，那么在该文件夹中创建的每个新文件、文件夹或子文件夹都将自动获得设置了`setgid`标志的文件夹的组权限。这适用于递归包含的所有文件。这可能非常重要，因为通常新创建的文件的组权限会自动由文件的创建者分配。'
- en: So if you want to separate locations in your filesystems for collaborations
    or group work where you can put in shared files for anyone belonging to a special
    group, `setgid` is a very powerful feature. This is like a shared folder you may
    know about from other operating systems. So if you want to separate your filesystems
    into locations for collaborations or group work, where anybody who is belonging
    to a special group can create documents that automatically can be fully accessed
    by other persons of that same group, just set a `setgid` flag on a folder.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想要在文件系统中为协作或团队工作分隔位置，可以将共享文件放入其中，供属于特定组的任何人使用，`setgid`是一个非常强大的功能。这就像你可能从其他操作系统中了解到的共享文件夹。因此，如果你想要将文件系统分隔成为协作或团队工作的位置，任何属于特定组的人都可以创建文件，并且其他同一组的人可以完全访问这些文件，只需在文件夹上设置`setgid`标志。
- en: 'To test this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个：
- en: Create a new folder under the username `olip`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在用户名`olip`下创建一个新文件夹。
- en: Now, change the group ownership to `awesome_group`. Now, if a user creates a
    new file in this folder, it will have the group ownership of that user.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将组所有权更改为`awesome_group`。现在，如果用户在该文件夹中创建新文件，它将具有该用户的组所有权。
- en: Now, let's set the `setgid` flag on that folder and see what happens.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在那个文件夹上设置`setgid`标志，看看会发生什么。
- en: 'Let''s create a new file under the username `olip` in that folder where we
    set the `setgid` flag:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在设置了`setgid`标志的文件夹中，使用用户名`olip`创建一个新文件：
- en: '![](img/31c7762e-1527-44a9-b50d-73ecf61a3018.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31c7762e-1527-44a9-b50d-73ecf61a3018.png)'
- en: As you can see, any new file created in this folder now gets the group ownership
    of the folder, which is `awesome_group`. So our `setgid` flag is working properly.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，现在在这个文件夹中创建的任何新文件都会获得文件夹的组所有权，即`awesome_group`。所以我们的`setgid`标志正常工作。
- en: sticky bit
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粘性位
- en: '`sticky bit` only has an effect on directories and not on files. If `sticky
    bit` is set on a folder, only the owner of a specific file, folder, or subfolder
    created in that directory is allowed to delete it. There are some special cases
    where this is useful, for example, in the `/tmp` directory, where anybody should
    be allowed to see anything, but quite often processes create and rely on data
    stored in that folder, so it would be very bad if someone other than the creator
    of the process could be able to delete files from other users.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`sticky bit`只对目录有效，对文件无效。如果在文件夹上设置了`sticky bit`，则只有特定文件、文件夹或子文件夹的所有者才能删除它。有一些特殊情况下这是有用的，例如在`/tmp`目录中，任何人都应该被允许查看任何内容，但很多时候进程会在该文件夹中创建并依赖存储的数据，因此如果除了进程的创建者之外的其他人能够删除其他用户的文件，那将是非常糟糕的。'
- en: 'So let''s test this out:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下：
- en: '![](img/bbc27a8e-a024-4001-bbfa-f2ff6d7cf5a7.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbc27a8e-a024-4001-bbfa-f2ff6d7cf5a7.png)'
- en: 'As you can see, `sticky bit` has been set on the `/tmp` directory, so let''s
    create a new file with the `olip` user in the `/tmp` directory. Now, let''s look
    in with `awesome_user`. As no password has been set, let''s set one for it. Now, `awesome_user`
    will also create a new file in the `/tmp` directory. Now, let''s try to delete
    our own file, which works. Now, let''s try to delete the file of the `olip` user;
    this does not work, so `sticky bit` is working as expected:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，“粘性位”已在“/tmp”目录上设置，因此让我们在“/tmp”目录中使用“olip”用户创建一个新文件。现在，让我们用“awesome_user”登录。由于尚未设置密码，让我们为其设置一个密码。现在，“awesome_user”也将在“/tmp”目录中创建一个新文件。现在，让我们尝试删除我们自己的文件，这是有效的。现在，让我们尝试删除“olip”用户的文件；这不起作用，因此“粘性位”正在按预期工作：
- en: '![](img/cc153ad7-1db1-4491-a264-ef49b370a034.png)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc153ad7-1db1-4491-a264-ef49b370a034.png)'
- en: Summary
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we gave you a brief introduction to special file permission
    flags in Linux. The `setuid` flag works only on commands and not on scripts, and
    lets a program execute as the user defined as the file owner instead of the user
    who is running that program. The `setgid` flag has two special meanings. The first
    is for commands and the other for folders. If you set it on a command, it will
    work like the `setuid` flag, but will run it as the group ownership of that file
    instead of the file owner of that file. The second meaning is if you set it on
    a folder, the group owner of the folder where you set `setgid` will automatically
    be assigned to every new file you created within that folder. Within a directory
    where `sticky bit` has been set, only the file owner can delete his own files
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您简要介绍了Linux中特殊文件权限标志。`setuid`标志仅适用于命令，而不适用于脚本，并允许程序以文件所有者定义的用户而不是运行该程序的用户来执行。`setgid`标志有两个特殊含义。第一个是用于命令，另一个是用于文件夹。如果您在命令上设置它，它将像`setuid`标志一样工作，但将以该文件的组所有权而不是该文件的文件所有者来运行它。第二个含义是，如果您在文件夹上设置它，您设置了`setgid`的文件夹的组所有者将自动分配给您在该文件夹中创建的每个新文件。在设置了“粘性位”的目录中，只有文件所有者才能删除自己的文件。
