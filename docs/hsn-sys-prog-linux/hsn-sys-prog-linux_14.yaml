- en: Multithreading with Pthreads Part I - Essentials
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pthreads进行多线程编程第一部分 - 基础知识
- en: Have you downloaded a large file using a download-accelerator type of application?
    Have you played an online game? A flight simulator program? Used word processing,
    web browsers, Java apps, and so on? (The temptation to put in a smiley emoji here
    is high!)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否使用过下载加速器类型的应用程序下载过大文件？你玩过在线游戏吗？飞行模拟器程序？使用过文字处理、网页浏览器、Java应用程序等等？（在这里放一个笑脸表情的诱惑很高！）
- en: 'It''s quite likely that you have used at least some of these; so what? All
    of these disparate applications have something in common: it''s highly likely
    that they are all designed for multithreading, meaning that their implementation
    uses multiple threads that run in parallel with each other. Multithreading has
    indeed become almost a way of life for the modern programmer.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你至少使用过其中一些；那又怎样呢？所有这些不同的应用程序有一个共同点：它们很可能都是为多线程设计的，这意味着它们的实现使用多个线程并行运行。多线程确实已经成为现代程序员几乎是一种生活方式。
- en: Explaining a topic as large as multithreading is itself a big task; hence we
    are dividing the coverage into three separate chapters. This one is the first
    of them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 解释一个像多线程这样庞大的话题本身就是一项艰巨的任务；因此我们将其分成三个单独的章节进行覆盖。这是其中的第一章。
- en: 'This chapter is itself logically divided into two broad parts: in the first,
    we carefully consider and understand the concepts behind the threading model—the
    what and why of multithreading. What exactly is a thread, why do we want threads,
    and a quick take on how multithreading has evolved on the Linux platform.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章本身在逻辑上分为两个广泛的部分：在第一部分中，我们仔细考虑并理解线程模型背后的概念——多线程的“什么”和“为什么”。线程到底是什么，我们为什么需要线程，以及多线程在Linux平台上是如何发展的一个快速了解。
- en: In the second part, we focus on the thread management APIs—the how (to some
    extent) of multithreading on Linux. The API set required to create and manage
    threads is discussed, with, of course, a lot of practical code to be seen and
    tried out.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分中，我们将重点关注Linux上多线程的线程管理API，即多线程的“如何”（在某种程度上）。我们将讨论创建和管理线程所需的API集合，并且当然会有很多实际的代码可以看到和尝试。
- en: At the outset of this topic, we must also clearly point out the fact that in
    this book we are only concerned with multithreading in the context of software
    programming; particularly, the **POSIX threads** (**pthreads**) implementation
    and specifically, pthreads on the Linux platform. We do not attempt to deal with
    various other multithreaded frameworks and implementations that have sprung up
    (such as MPI, OpenMP, OpenCL, and so on) or hardware threading (hyperthreading,
    GPUs with CUDA, and so on).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个话题的开始，我们还必须明确指出这样一个事实，即在本书中，我们只关注软件编程的多线程；特别是在Linux平台上的POSIX线程（pthreads）实现，具体来说是Linux平台上的pthreads。我们不打算处理其他各种出现的多线程框架和实现（如MPI、OpenMP、OpenCL等）或硬件线程（超线程、具有CUDA的GPU等）。
- en: 'In this chapter, you will learn about programming with multiple threads on
    the Linux platform, specifically, getting started with the pthreads programming
    model or framework. This chapter is broadly divided into two parts:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在Linux平台上使用多个线程进行编程，具体来说，是如何开始使用pthread编程模型或框架。本章大致分为两部分：
- en: In the first, key multithreading concepts—the what and the why of multithreading
    —are covered, laying the groundwork for the second part (and indeed the two subsequent
    chapters on multithreading).
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一部分，涵盖了关键的多线程概念——多线程的“什么”和“为什么”，为第二部分（以及后面两章关于多线程的内容）奠定了基础。
- en: The second part covers the essential pthreads APIs required to build a functional
    multithreaded application on Linux (it deliberately does not cover all aspects,
    through; the next two chapters will build on this one).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二部分涵盖了在Linux上构建功能性多线程应用程序所需的基本pthread API（它故意没有涵盖所有方面；接下来的两章将在此基础上展开）。
- en: Multithreading concepts
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程概念
- en: In this section, we'll learn about the what and why of multithreading on the
    Linux platform. We will begin by answering the FAQ, "what exactly is a thread?".
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习在Linux平台上多线程的“什么”和“为什么”。我们将从回答“线程到底是什么？”这个常见问题开始。
- en: What exactly is a thread?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程到底是什么？
- en: 'In the good (or bad?) old days, Unix programmers had a straightforward software
    model (which got inherited pretty much exactly by other OSes and vendors): there
    is a process that lives in a **virtual address space** (**VAS**); the VAS essentially
    consists of homogeneous regions (essentially collections of virtual pages) called segments: text,
    data, other mappings (libraries), and stack. The text is really the executable—in
    fact, the machine—code that is fed to the processor. We have certainly covered
    all of this earlier in this book (you can brush up on these basics in [Chapter
    2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml), *Virtual Memory*).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在古老的Unix程序员的好（或坏？）旧日子里，有一个简单的软件模型（其他操作系统和供应商几乎完全继承了这个模型）：有一个存在于虚拟地址空间（VAS）中的进程；VAS本质上由称为段的同质区域（基本上是虚拟页面的集合）组成：文本、数据、其他映射（库）和栈。文本实际上是可执行的——事实上是机器——代码，它被馈送到处理器。我们在本书的早期部分已经涵盖了所有这些内容（你可以在第2章《虚拟内存》中复习这些基础知识）。
- en: A thread is an independent execution (or flow) path within a process. The life
    and scope of a thread, in the familiar procedural programming paradigm we typically
    work with, is simply a function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 线程是进程内部的独立执行（或流）路径。在线程的生命周期和范围中，在我们通常使用的熟悉的过程式编程范式中，它只是一个函数。
- en: 'So, in the traditional model we mentioned previously, we have a single thread
    of execution; that thread, in the C programming paradigm, is the `main()` function!
    Think about it: the `main()` thread is where execution begins (well, at least
    from the app developer''s viewpoint) and ends. This model is (now) called the single
    threaded software model. As opposed to what? The multithreaded one, of course.
    So, there we have it: it is possible to have more than one thread alive and executing
    concurrently (in parallel) with other independent threads within the same process.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们之前提到的传统模型中，我们有一个执行线程；在C编程范式中，该线程是`main()`函数！想想看：`main()`线程是执行开始（至少从应用程序开发者的角度来看）和结束的地方。这个模型现在被称为单线程软件模型。与之相对的是什么？当然是多线程模型。所以，我们可以有多个线程与同一进程中的其他独立线程同时执行（并行）。
- en: 'But, hang on, can''t processes generate parallelism too and have multiple copies
    of themselves working on different aspects of the application? Yes, of course:
    we have covered the `fork(2)` system call in all its considerable glory (and implications)
    in [Chapter 10](607ad988-406d-4736-90a4-3a318672ab6e.xhtml), *Process Creation*.
    This is known as the multiprocessing model. So, if we have multiprocessing – where
    several processes run in parallel and, hey, they get the work done—the million
    dollar question becomes: "why multithreading at all?" (Kindly deposit a million
    dollars and we shall provide the answer.) There are several good reasons; check
    out the upcoming sections (especially *Motivation – why threads?*; we do suggest
    that first-time readers follow the sequence as laid out in this book) for more
    detail.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，等等，进程难道也不能产生并行性，并且在应用程序的不同方面上有多个副本在工作吗？当然可以：我们已经在[第10章](607ad988-406d-4736-90a4-3a318672ab6e.xhtml)中以所有的荣耀（和影响）介绍了`fork(2)`系统调用。这被称为多进程模型。因此，如果我们有多进程——在这里，有几个进程并行运行，并且完成了工作——百万美元的问题就变成了：“为什么还要使用多线程？”（请存入一百万美元，我们将提供答案。）有几个很好的理由；请查看接下来的章节（特别是*动机-为什么要使用线程？*；我们建议第一次读者按照本书中所规定的顺序进行阅读）以获取更多细节。
- en: Resource sharing
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源共享
- en: In [Chapter 10](607ad988-406d-4736-90a4-3a318672ab6e.xhtml), *Process Creation*,
    we repeatedly pointed out that although the fork(2) system call is very powerful
    and useful, it's considered to be a heavyweight operation; performing the fork takes
    a lot of CPU cycles (and thus time) and is expensive in terms of memory (RAM),
    too. Computer scientists were looking for a way to lighten this; the result, as
    you have guessed, is the thread.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](607ad988-406d-4736-90a4-3a318672ab6e.xhtml)中，*进程创建*，我们反复指出，虽然fork(2)系统调用非常强大和有用，但它被认为是一种重量级操作；执行fork需要大量的CPU周期（因此需要时间），而且在内存（RAM）方面也很昂贵。计算机科学家们正在寻找一种减轻这种情况的方法；结果，正如你所猜到的那样，就是线程。
- en: 'Hang on, though: for the convenience of the reader, we reproduce a diagram—*The
    Linux process – inheritance and non-inheritance across the fork()*—from [Chapter
    10](607ad988-406d-4736-90a4-3a318672ab6e.xhtml), *Process Creation*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，为了方便读者，我们在这里重现了一个图表——*Linux进程-在fork()中的继承和非继承*——来自[第10章](607ad988-406d-4736-90a4-3a318672ab6e.xhtml)，*进程创建*：
- en: '![](img/8beb0e4e-7a50-43a7-a15e-f07976f2cf65.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8beb0e4e-7a50-43a7-a15e-f07976f2cf65.png)'
- en: Figure 1: The Linux process – inheritance and non-inheritance across the fork()
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：Linux进程-在fork()中的继承和非继承
- en: 'This diagram is important because it shows us why the fork is a heavy weight
    operation: every time you invoke the fork(2) system call,, the complete VAS of
    the parent process and all the data structures on the right inherited across fork side
    of the diagram have to be  copied into the newly born child process. That is indeed
    a lot of work and memory usage! (Okay, we''re exaggerating a bit: as mentioned
    in [Chapter 10](607ad988-406d-4736-90a4-3a318672ab6e.xhtml), *Process Creation**, *modern
    OSes, especially Linux, do take a lot of pains to optimize the fork. Nevertheless,
    it''s heavy. Check out our example 1 demo program that follows—the creation and
    destruction of a process is much slower (and takes much more RAM) than the creation
    and destruction of a thread.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表很重要，因为它向我们展示了为什么fork是一种重量级操作：每次调用fork(2)系统调用时，父进程的完整虚拟地址空间和图表右侧的所有数据结构都必须被复制到新生的子进程中。这确实是很多工作和内存使用！（好吧，我们有点夸张：正如在[第10章](607ad988-406d-4736-90a4-3a318672ab6e.xhtml)中所提到的，*进程创建*，*现代操作系统，特别是Linux，确实费了很多功夫来优化fork。尽管如此，它还是很重的。请查看我们的示例1演示程序，进程的创建和销毁比线程的创建和销毁要慢得多（并且需要更多的RAM）。
- en: 'The reality is this: when a process creates a thread, the thread shares (almost)
    everything with all other threads of the same process—all of the preceding VAS,
    thus the segments, and all the data structures—except for a stack.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 事实是这样的：当一个进程创建一个线程时，该线程与同一进程的所有其他线程（几乎）共享所有内容——包括之前的虚拟地址空间、段和所有数据结构——除了栈。
- en: 'Every thread has its own private stack segment. Where does it reside? Obviously,
    within the VAS of the creating process; where exactly it resides is really inconsequential
    to us (recall that it''s all virtual memory, in any case, not physical). The question
    that''s a lot more relevant and important to the app developer is how large the
    thread stack will be. The short answer: the same as usual (typically 8 MB on the
    Linux platform), but we shall get to the nitty-gritty details later in this chapter.
    Just think of it this way: the stack of `main()` always resides at the very top
    of the (user mode) virtual address space; the stacks of the remaining threads
    in the process can reside anywhere in this space. Realistically, they typically
    reside in the virtual memory space between the heap and the stack (of main).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都有自己的私有堆栈段。它位于哪里？显然，它位于创建进程的虚拟地址空间内；它确切地位于哪里对我们来说并不重要（回想一下，无论如何都是虚拟内存，而不是物理内存）。对应用程序开发人员来说，更相关和重要的问题是线程堆栈的大小。简短的答案是：与通常一样（在Linux平台上通常为8MB），但我们将在本章后面详细介绍细节。只需这样想：`main()`的堆栈总是位于（用户模式）虚拟地址空间的顶部；进程中其余线程的堆栈通常位于该空间中的任何位置。实际上，它们通常位于堆和（main的）堆栈之间的虚拟内存空间中。
- en: 'The following diagram helps us understand the memory layout of a multithreaded
    process on Linux; in the upper portion of the diagram is the process before `pthread_create(3)`; the
    lower portion shows the process after the thread has been successfully created:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表帮助我们了解Linux上多线程进程的内存布局；图表的上部是`pthread_create(3)`之前的进程；下部显示了成功创建线程后的进程：
- en: '![](img/8f2b1600-8814-4675-988c-45739f349fd6.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8f2b1600-8814-4675-988c-45739f349fd6.png)'
- en: Fig 2 : The thread – everything except the stack is shared across pthread_create()
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：线程-除了堆栈之外，一切都在pthread_create()中共享
- en: The blue squiggle in the process text segment represents the `main()` thread;
    its stack is also clearly seen. We use the dashed lines to indicate that all these
    memory objects (both user and kernel space) are shared across `pthread_create(3)`.
    As can clearly be seen, the only new objects after `pthread_create(3)` are the
    new thread itself (**thrd2**; shown as a red squiggle in the process text segment)
    and a new stack for the just born thread **thrd2** (in red). Contrast this diagram
    with *Fig 1*; when we fork(2), pretty much everything has to be copied into the
    newly born child process.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 进程文本段中的蓝色波浪线代表`main()`线程；它的堆栈也清晰可见。我们使用虚线表示所有这些内存对象（用户空间和内核空间）都在`pthread_create(3)`中被共享。显然可以看到，在`pthread_create(3)`之后，唯一的新对象是新线程本身（**thrd2**；在进程文本段中显示为红色波浪线）和刚刚创建的线程**thrd2**的新堆栈（红色）。将此图与*图1*进行对比；当我们进行`fork(2)`时，几乎所有东西都必须复制到新生的子进程中。
- en: 'From what we have described so far, the only difference between a process and
    a thread is that of resource sharing—processes do not share, they copy; threads
    do share everything, except for the stack. Dig a little deeper and you will realize
    that both software and hardware state have to be maintained on a per thread basis.
    The Linux OS does exactly that: it maintains a per-thread task structure within
    the OS; the task structure contains all the process/thread attributes, including
    software and hardware context (CPU register values and so on) information.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们描述的唯一区别是进程和线程之间的资源共享——进程不共享，它们复制；线程共享一切，除了堆栈。再深入一点，你会意识到软件和硬件状态都必须以每个线程为基础进行维护。Linux操作系统正是这样做的：它在操作系统内部维护了一个每个线程的任务结构；任务结构包含所有进程/线程属性，包括软件和硬件上下文（CPU寄存器值等）信息。
- en: 'Again, digging a little deeper, we realize that the OS does maintain a distinct
    copy of the following attributes per thread: the stack segment (and thus the stack
    pointer), possible alternate signal stack (covered in the [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml), *Signaling
    - Part I*), both regular signal and real-time signal masks, thread ID, scheduling
    policy and priority, capability bits, CPU affinity mask, and the errno value (don''t
    worry—several of these will be explained along the way).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 再深入挖掘一下，我们意识到操作系统确实会为每个线程维护以下属性的独立副本：堆栈段（因此堆栈指针）、可能的备用信号堆栈（在[第11章](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml)中介绍，*信号-第一部分*）、常规信号和实时信号掩码、线程ID、调度策略和优先级、能力位、CPU亲和性掩码以及errno值（不用担心，这些中的几个将在后面解释）。
- en: Multiprocess versus multithreaded
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多进程与多线程
- en: 'To help clearly understand why and how threads can provide a performance benefit,
    let''s perform a few experiments! (the importance of being empirical - experimenting,
    trying things out - is a critical feature; our [Chapter 19](b6b41870-c02e-4379-af86-b5e501799c31.xhtml),
    *Troubleshooting and Best Practices*, covers more on such points). First, we take
    two simple example programs: one, a program that compares the creation and destruction
    of processes versus threads, and two, a program that performs matrix multiplication
    in two ways—one via the traditional single threaded process model, and two, via
    the multithreaded model.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地理解为什么和如何线程可以提供性能优势，让我们进行一些实验！（实证的重要性-实验，尝试-是一个关键特征；我们的[第19章](b6b41870-c02e-4379-af86-b5e501799c31.xhtml)，*故障排除和最佳实践*，更多涵盖了这些内容）。首先，我们进行两个简单示例程序的比较：一个是比较创建和销毁进程与线程的程序，另一个是以两种方式进行矩阵乘法运算的程序——一种是传统的单线程进程模型，另一种是多线程模型。
- en: So, what we are really comparing here is the performance in terms of execution
    time between using the multiprocess versus multithreaded model. We will have the
    reader note that, right here and now, we will not be taking pains to detail and
    explain the thread code right now for two reasons; one, it's besides the point,
    and two, until we have covered the thread APIs in some detail, it will not really
    make sense to do so. (So in effect, dear reader, we ask that you ignore the thread
    code for now; just follow along, and build and reproduce what we do here; the
    code and APIs will become clear to you as you learn more.)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在这里真正比较的是使用多进程模型和多线程模型的执行时间性能。我们要请读者注意，我们现在不会费力详细解释线程代码的原因有两个：一是这不是重点，二是在我们详细介绍线程API之前，这样做没有意义。（因此，亲爱的读者，我们要求你暂时忽略线程代码；只需跟着我们，构建和重现我们在这里做的事情；随着你的学习，代码和API将变得清晰。）
- en: Example 1 – creation/destruction – process/thread
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例1 - 创建/销毁 - 进程/线程
- en: 'The process model: Here''s what we do: in a loop (that executes a total of
    60,000 times!), create and destroy a process by calling `fork(2)` and subsequently exiting.
    (We take care of details such as clearing any possible zombie by waiting in the
    parent for the child to die before proceeding in the loop.) The relevant code
    is as follows (`ch14/speed_multiprcs_vs_multithrd_simple/create_destroy/fork_test.c`):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 进程模型：我们的做法是：在一个循环中（总共执行了60,000次！），通过调用`fork(2)`创建和销毁进程，然后退出。（我们处理了一些细节，比如在父进程中等待子进程死亡，以清除任何可能的僵尸进程，然后继续循环。）相关的代码如下（`ch14/speed_multiprcs_vs_multithrd_simple/create_destroy/fork_test.c`）：
- en: 'For readability, only the relevant parts of the code are displayed in the following
    code; to view and run it, the entire source code can be found here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，以下代码中只显示了相关部分；要查看和运行完整的源代码，可以在这里找到：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We run it prefixed with the `time(1)` utility, which gives us a rough idea
    of the time taken by the program on the processor; the time spent shows up as
    three components: `real` (total wall-clock time spent), `user` (time spent in
    user space), and `sys` (time spent in kernel space):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`time(1)`实用程序的前缀下运行它，这给了我们一个程序在处理器上花费的时间的大致概念；花费的时间显示为三个组成部分：`real`（总的挂钟时间），`user`（用户空间中花费的时间）和`sys`（内核空间中花费的时间）：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Obviously, the precise values you get on your Linux box can, and likely will,
    vary. And, no, `user` + `sys` does not add up exactly to real, either.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你在Linux系统上得到的确切数值可能会有所不同。而且，`user` + `sys`的总和也不会完全等于real。
- en: The multithreading model
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多线程模型
- en: 'Again, here''s what we do: it''s key to understand that the code used here
    (`ch14/speed_multiprcs_vs_multithrd_simple/create_destroy/pthread_test.c`), is
    equivalent in all respects to the previous code except that here we work with
    threads and not processes: in a loop (that executes a total of 60,000 times!),
    create and destroy a thread by calling `pthread_create(3)` and subsequently `pthread_exit(3)`. (We
    take care of details such as waiting in the calling thread for the sibling thread
    to terminate by invoking `pthread_join(3)`.) As mentioned earlier, let''s skip
    the code/API details for now and just see the execution:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们的做法是：关键是要理解这里使用的代码（`ch14/speed_multiprcs_vs_multithrd_simple/create_destroy/pthread_test.c`）在所有方面都与前面的代码相同，只是这里我们使用线程而不是进程：在一个循环中（总共执行了60,000次！），通过调用`pthread_create(3)`创建和销毁线程，然后通过调用`pthread_exit(3)`退出。（我们处理了一些细节，比如在调用线程中等待兄弟线程终止，通过调用`pthread_join(3)`。）如前所述，让我们暂时跳过代码/API的细节，只看执行情况：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Wow, the threaded code has run approximately 3x faster than the process model
    code! The conclusion is obvious: creating and destroying a thread is much faster
    than creating and destroying a process.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，线程化的代码运行速度大约比进程模型的代码快3倍！结论很明显：创建和销毁线程比创建和销毁进程要快得多。
- en: 'A technical side note: For the more curious geeks: why exactly is the `fork(2)`
    so much slower than `pthread_create(3)`? Those familiar with OS development will
    understand that Linux makes heavy use of the performance-enhancing **copy-on-write**(**COW**)
    memory techniques within its internal implementation of `fork(2)`. Thus, it begs
    the question, if COW is heavily used, then what is slowing the fork down? The
    short answer: page table creation and setup cannot be COW-ed; it takes a while
    to do. When creating threads of the same process, this work (page table setup)
    is completely skipped.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 技术方面的一点说明：对于更好奇的极客：为什么`fork(2)`比`pthread_create(3)`慢得多？熟悉操作系统开发的人会明白，Linux在`fork(2)`的内部实现中大量使用了性能增强的**写时复制**（COW）内存技术。因此，问题是，如果COW被大量使用，那么是什么使fork变慢？简短的答案是：页表的创建和设置不能进行COW；这需要一段时间。当创建同一进程的线程时，这项工作（页表设置）完全被跳过。
- en: Even so, Linux's fork is pretty much considered to be the fastest of any comparable
    OS today.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 即便如此，Linux的fork在今天任何可比较的操作系统中都被认为是最快的。
- en: 'As an aside, a far more accurate way to measure the time spent—and performance
    characteristics in general—is by using the well-known `perf(1)` utility (note
    that in this book, we do not intend to cover `perf` in any detail whatsoever;
    if interested, please look up the *Further reading* section on the GitHub repository
    for some links to perf-related materials):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，衡量花费的时间和性能特征的一种更准确的方法是使用众所周知的`perf(1)`实用程序（请注意，在本书中，我们不打算详细介绍`perf`；如果感兴趣，请查看GitHub存储库的*进一步阅读*部分，其中有一些与`perf`相关的链接）：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As can be seen in the preceding code, on a virtual machine, current versions
    of `perf` cannot show all the counters; this does not impede us in any way here
    as all we're really after is the final time it took to execute—which is shown
    in the last line of `perf` output.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面的代码所示，在虚拟机上，当前版本的`perf`不能显示所有的计数器；这在这里并不妨碍我们，因为我们真正关心的是执行所花费的最终时间——这显示在`perf`输出的最后一行中。
- en: 'The following code shows `perf(1)` for the multithreaded app:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了多线程应用程序的`perf(1)`：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For interested readers, we have also provided a wrapper script (`ch14/speed_multiprcs_vs_multithrd_simple/create_destroy/perf_runs.sh`),
    allowing the user to perform a record and report session with `perf(1)`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于感兴趣的读者，我们还提供了一个包装脚本（`ch14/speed_multiprcs_vs_multithrd_simple/create_destroy/perf_runs.sh`），允许用户使用`perf(1)`进行记录和报告会话。
- en: Example 2 – matrix multiplication – process/thread
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例2-矩阵乘法-进程/线程
- en: 'A well-known exercise is to write a program to compute the (dot) product of
    two given matrices. Essentially, we would like to perform the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一个众所周知的练习是编写一个计算两个给定矩阵的（点）积的程序。基本上，我们想执行以下操作：
- en: '`matrix C = matrix A * matrix B`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`矩阵C = 矩阵A * 矩阵B`'
- en: 'Again, we emphasize the fact that here, we are not really concerned with the
    details of the algorithm (and code); what concerns us here is how, at a design
    level the matrix multiplication is performed. We propose (and write the corresponding
    code for) two ways:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调的是，我们在这里实际上并不关心算法（和代码）的细节；我们关心的是在设计层面上如何执行矩阵乘法。我们提出（并编写相应的代码）两种方法：
- en: Sequentially, via the single threaded model
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按顺序，通过单线程模型
- en: In parallel, via the multithreaded model
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时，通过多线程模型
- en: 'Note: None of this—the algorithm or code—is purported to be original or ground-breaking
    in any manner; these are well-known programs.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这些算法或代码都不打算是原创或突破性的；这些都是众所周知的程序。
- en: In the first model, one thread—`main()`, of course—will run and perform the
    computation; the program can be found here: `ch14/speed_multiprcs_vs_multithrd_simple/matrixmul/prcs_matrixmul.c`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个模型中，一个线程-当然是`main()`-将运行并执行计算；程序可以在这里找到：`ch14/speed_multiprcs_vs_multithrd_simple/matrixmul/prcs_matrixmul.c`。
- en: In the second, we will create at least as many threads as there are CPU cores
    on the target system to take full advantage of the hardware (this aspect is dealt
    with in a later section of this chapter called *How many threads can you create?*);
    each thread will perform a part of the computation, in parallel with the other
    threads. The program can be found here: `ch14/speed_multiprcs_vs_multithrd_simple/matrixmul/thrd_matrixmul.c`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们将在目标系统上创建至少与CPU核心数相同的线程，以充分利用硬件（这个方面在本章的后面一节中处理，名为*你可以创建多少线程？*）；每个线程将与其他线程并行执行一部分计算。程序可以在这里找到：`ch14/speed_multiprcs_vs_multithrd_simple/matrixmul/thrd_matrixmul.c`。
- en: In the multithreaded version, for now, we just hardcode the number of CPU cores
    in our code to four as it matches one of our native Linux test systems.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程版本中，目前，我们只是在代码中硬编码CPU核心数为四，因为它与我们的本机Linux测试系统之一匹配。
- en: To truly appreciate how the process(es) and/or threads of our applications actually
    consume CPU bandwidth, let's use the interesting `gnome-system-monitor` GUI application
    to see resource consumption graphically! (To run it, assuming it's installed,
    just type `$ gnome-system-monitor &`  on the shell).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正了解我们的应用程序的进程和/或线程如何实际消耗CPU带宽，让我们使用有趣的`gnome-system-monitor` GUI应用程序以图形方式查看资源消耗！（要运行它，假设已安装，只需在shell上键入`$
    gnome-system-monitor＆`）。
- en: We remind you that all software and hardware requirements have been enumerated
    in some detail in the software-hardware list material available on this book's
    GitHub repository.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提醒您，所有软件和硬件要求都已在本书的GitHub存储库上提供的软件硬件清单材料中详细列出。
- en: 'We will perform the experiment as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按以下方式进行实验：
- en: 'Run the apps on a native Linux box with four CPU cores:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在具有四个CPU核心的本机Linux系统上运行应用程序：
- en: '![](img/e3a13cd1-66d2-48a1-b3ef-527f115b79ef.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/e3a13cd1-66d2-48a1-b3ef-527f115b79ef.png)
- en: 'Look carefully at the preceding (annotated) screenshot (zoom in if you are
    reading the electronic version); we will notice several items of interest:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看前面的（带注释的）屏幕截图（如果您正在阅读电子版本，请放大）；我们会注意到几个有趣的项目：
- en: 'In the foreground is the terminal window app where we run the `prcs_matrixmul` and
    the `thrd_matrixmul` applications:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前台是我们运行`prcs_matrixmul`和`thrd_matrixmul`应用程序的终端窗口应用程序：
- en: We use `perf(1)` to accurately measure the time taken and deliberately filter
    out all output except for the final number of seconds elapsed during execution.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`perf(1)`来准确测量所花费的时间，并故意过滤除了执行期间经过的最终秒数之外的所有输出。
- en: In the background, you can see the gnome-system-monitor GUI app running.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在背景中，您可以看到正在运行的`gnome-system-monitor` GUI应用程序。
- en: 'The (native Linux) system—the particular one that we have tested this on—has
    four CPU cores:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （本机Linux）系统-我们已经在其上进行了测试-有四个CPU核心：
- en: 'One way to find the number of CPU cores on your system is by using the following
    code: `getconf -a | grep _NPROCESSORS_ONLN | awk ''{print $2}''`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到系统上CPU核心数量的一种方法是使用以下代码：`getconf -a | grep _NPROCESSORS_ONLN | awk '{print
    $2}'`
- en: (you can update the `NCORES` macro in the source code `thrd_matrixmul.c`to reflect
    this value)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: （您可以在源代码`thrd_matrixmul.c`中更新`NCORES`宏以反映此值）
- en: 'The `prcs_matrixmul` app runs first; while it runs, it consumes 100% CPU bandwidth on
    exactly one CPU core out of the four available (it happens to be CPU core #2)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prcs_matrixmul`应用程序首先运行；当它运行时，它会在四个可用的CPU核心中的一个上消耗100%的CPU带宽（它恰好是CPU核心＃2）'
- en: Notice how, on the middle-to-left of the CPU History meter, the red line representing
    CPU2 shoots up to a 100% (highlighted with a purple ellipse and labeled Process)!
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，在CPU历史记录仪的中间到左侧，代表CPU2的红线飙升到100%（用紫色椭圆标出并标记为进程）！
- en: At the time the screenshot was actually taken (OS on the X-axis timeline; it
    moves from right to left), the CPUs are back to normal levels.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实际拍摄屏幕截图时（OS在X轴时间线上；它从右向左移动），CPU恢复到正常水平。
- en: 'Next (after a gap of 10 seconds in this particular run), the `thrd_matrixmul` app
    runs; and herein lies the key point: While it runs, it consumes 100% CPU bandwidth on
    all four CPU cores!'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来（在这次运行的间隔为10秒后），`thrd_matrixmul`应用程序运行；这里的关键点在于：当它运行时，它会在所有四个CPU核心上消耗100%的CPU带宽！
- en: Notice at how, approximately just after the 15s marking (read it from right-to-left)
    on the X-axis timeline, all four CPU cores shoot to 100% – that's during the execution
    of `thrd_matrixmul` (highlighted with a red ellipsis and labeled Threads).
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，在X轴时间线上大约在15秒标记之后（从右到左阅读），所有四个CPU核心都突然达到了100%——这是在执行`thrd_matrixmul`（用红色省略号突出显示并标记为Threads）时发生的。
- en: 'What does this tell us? Something really important: the underlying Linux OS
    CPU scheduler will try and take advantage of the hardware and, if possible, schedule
    our four application threads to run in parallel on the four CPUs available! Hence,
    we get higher throughput, higher performance, and more bang for our buck.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们什么？非常重要的一点：底层的Linux操作系统CPU调度器将尝试利用硬件，并且如果可能的话，将我们的四个应用程序线程安排在四个可用的CPU上并行运行！因此，我们获得了更高的吞吐量、更高的性能和更高的性价比。
- en: Understandably, you might at this point wonder about and have a lot of questions
    on how Linux performs CPU (thread) scheduling; worry not, but please have some
    patience—we shall explore CPU scheduling in some detail in [Chapter 17](36229bac-c402-4d2f-b876-d1eb4aba8051.xhtml),
    *CPU* *Scheduling on Linux*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 可以理解的是，此时您可能会对Linux如何执行CPU（线程）调度产生很多疑问；不用担心，但请耐心等待——我们将在[第17章](36229bac-c402-4d2f-b876-d1eb4aba8051.xhtml)中详细探讨Linux的CPU调度。
- en: 'Restricted to exactly one CPU:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制为仅一个CPU：
- en: 'The `taskset(1)` utility allows one to run a process on a specified set of
    processor core(s). (This ability to associate a process with a given CPU(s) is
    called CPU affinity. We shall come back to this in the chapter on scheduling.)
    Using `taskset` in its basic form is easy: `taskset -c <cpu-mask> <app-to-run-on-given-cpus>`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`taskset(1)`实用程序允许在指定的处理器核心上运行进程。 （将进程与给定的CPU关联起来的能力称为CPU亲和性。我们将在调度章节中回到这一点。）使用`taskset`的基本形式很容易：`taskset
    -c <cpu-mask> <app-to-run-on-given-cpus>`'
- en: 'As you can see from the following screenshot, we contrast performing a run
    of the `thrd_matrixmul` app on all four CPU cores on the system (in the usual
    way) with running it on exactly one CPU by specifying the CPU mask via `taskset(1)`;
    the screenshot again clearly reveals how, on the former run, all four CPUs are
    pressed into action by the OS (and it takes a total of 8.084s), whereas on the
    latter run only a single CPU (it shows up as CPU3 in green) is employed to execute
    its code (resulting in a total time of 11.189s):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以从以下截图中看到的，我们对系统上所有四个CPU核心（通常方式）执行`thrd_matrixmul`应用程序的运行进行了对比，以及通过`taskset(1)`指定CPU掩码在仅一个CPU上运行它；截图再次清楚地显示了，在前一次运行中，所有四个CPU都被操作系统利用（总共需要8.084秒），而在后一次运行中，只有一个CPU（以绿色显示为CPU3）被用于执行其代码（总共需要11.189秒）：
- en: '![](img/61357669-4d7c-4bf5-8ddd-2dcfbd514e28.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61357669-4d7c-4bf5-8ddd-2dcfbd514e28.png)'
- en: 'Seeing what we have just learned in this section, you might leap to the conclusion,"hey,
    we''ve found the answer: let''s just always use multithreading." But, of course,
    experience tells us that there is no silver bullet. The reality is that although
    threading does indeed offer some real advantages, as with everything in life,
    there are also downsides to it. We shall postpone more discussion on the pros
    and cons in [Chapter 16](4df10c19-b400-4805-8e6e-51a8f43dcfa4.xhtml), *Multithreading
    with Pthreads Part III*; do keep this in mind, though.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据本节刚学到的内容，您可能会得出结论：“嘿，我们找到答案了：让我们总是使用多线程。”但是，当然，经验告诉我们并没有银弹。事实是，尽管线程确实提供了一些真正的优势，但就像生活中的一切一样，它也有缺点。我们将在[第16章](4df10c19-b400-4805-8e6e-51a8f43dcfa4.xhtml)中推迟更多关于利弊的讨论，即*使用Pthreads进行多线程编程第三部分*；但请记住这一点。
- en: For now, let's do one more experiment to clearly illustrate the fact that not
    just multithreading, but multiprocessing—the use of fork to spawn multiple processes—is
    very helpful as well to gain higher throughput.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进行另一个实验，以清楚地说明不仅多线程，而且多进程——使用fork生成多个进程——也非常有助于获得更高的吞吐量。
- en: Example 3 – kernel build
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例3——内核构建
- en: 'So, one last experiment (for this section): we will build (cross-compile) a
    Linux kernel ver. 4.17 for the ARM Versatile Express platform (with its default
    configuration). The details of the kernel build and so on are out of scope of
    this book, but that''s all right: the key point here is that the kernel build
    is definitely a CPU and RAM intensive operation. Not only that, the modern `make(1)` utility
    is multiprocess capable! One can tell `make` the number of jobs—processes, really—to
    internally spawn (fork) via its `-jn` option switch, where `n` is the number of
    jobs (threads). We use a heuristic (a rule of thumb) to determine this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最后一个实验（本节）：我们将为ARM Versatile Express平台构建（交叉编译）Linux内核版本4.17（使用默认配置）。内核构建的细节等都不在本书的范围之内，但没关系：关键点在于内核构建绝对是一个CPU和RAM密集型的操作。不仅如此，现代的`make(1)`实用程序也支持多进程！可以通过其`-jn`选项开关告诉`make`要内部生成（fork）的作业数量，其中`n`是作业（线程）的数量。我们使用一个启发式（经验法则）来确定这个数量：
- en: '`n = number-of-CPU-cores * 2`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`n = CPU核心数量 * 2`'
- en: (multiply by 1.5 on very high-end systems with a lot of cores.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: （在具有大量核心的高端系统上乘以1.5。）
- en: Knowing this, check out the experiments that follow.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了这一点，接下来看看接下来的实验。
- en: On a VM with 1 GB RAM, two CPU cores and parallelized make -j4
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在具有1GB RAM、两个CPU核心和并行化make -j4的VM上
- en: 'We configure the guest VM to have two processors, and proceed with the parallelized
    build (by specifying `make -j4` ):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置了虚拟机客户机具有两个处理器，并进行了并行化构建（通过指定`make -j4`）：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The build took a total time of approximately 684 seconds (11.5 min). Just so
    you know, the compressed kernel image for ARM—the one we boot with—is the file
    called `zImage`; the uncompressed kernel image (used only for debug purposes)
    is the `vmlinux` file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 构建总共花费了大约684秒（11.5分钟）。只是让您知道，用于ARM的压缩内核映像是名为`zImage`的文件；未压缩的内核映像（仅用于调试目的）是`vmlinux`文件。
- en: 'While it was running, doing a quick `ps -LA`during the build indeed reveals
    its multiprocess—not multithreaded—nature:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，通过快速执行`ps -LA`确实显示了其多进程——而不是多线程——的性质：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: On a VM with 1 GB RAM, one CPU core and sequential make -j1
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在具有1GB RAM、一个CPU核心和顺序make -j1的VM上
- en: 'We configure the guest VM to have only one processor, clean up the build directory,
    and proceed once more, but this time with a sequential build (by specifying `make
    -j1`):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们配置客户VM只有一个处理器，清理构建目录，然后再次进行，但这次是顺序构建（通过指定`make -j1`）：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The build took a total time of approximately 1232 seconds (20.5 min), which
    is nearly twice as long as the previous build!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 构建总共花费了大约1232秒（20.5分钟），几乎是上一次构建的两倍长！
- en: You might be asking this question: so, if the build with one process took around
    20 minutes and the same build with multiple processes took approximately half
    the time, why use multithreading at all? Multiprocessing seems to be as good!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问这个问题：那么，如果使用一个进程构建大约花费了20分钟，而使用多个进程进行相同的构建大约花费了一半的时间，为什么还要使用多线程？多处理似乎也很好！
- en: 'No, please think: our very first example regarding process versus thread creation/destruction taught
    us that spawning (and terminating) processes is much slower than doing the same
    with threads. That is still a key advantage that many applications exploit. After
    all, threads are far more efficient than processes in terms of creation and destruction.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 不，想一想：我们关于进程与线程创建/销毁的第一个例子告诉我们，生成（和终止）进程比使用线程慢得多。这仍然是许多应用程序利用的关键优势。毕竟，线程在创建和销毁方面比进程更有效。
- en: 'In a dynamic, unpredictable environment, where we do not know in advance how
    much work will be required, the use of multithreading to be able to quickly create
    worker threads (and quickly have them terminated) is very important. Think of
    the famous Apache web server: it''s multithreaded by default (via its `mpm_worker`
    module in order to quickly serve client requests). In a similar fashion, the modern NGINX web
    server uses thread pools (more on this for those interested can be found in the *Further
    reading* section on the GitHub repository).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个动态、不可预测的环境中，我们事先不知道需要多少工作，使用多线程能够快速创建工作线程（并快速终止它们）非常重要。想想著名的Apache网络服务器：它默认是多线程的（通过其mpm_worker模块，以便快速响应客户端请求）。同样，现代的NGINX网络服务器使用线程池（对于感兴趣的人，更多信息可以在GitHub存储库的“进一步阅读”部分找到）。
- en: Motivation – why threads?
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动机 - 为什么要使用线程？
- en: Threading does indeed offer a number of useful advantages; here, we attempt
    to enumerate some of the more important ones. We think of this in terms of motivation
    for the application architect to make use of multithreading because of potential
    advantages to be gained. We divide this discussion into two areas: design and performance.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 线程确实提供了许多有用的优势；在这里，我们试图列举一些更重要的优势。我们认为这是对应用架构师使用多线程的动机，因为可能获得的优势。我们将这个讨论分为两个方面：设计和性能。
- en: Design motivation
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计动机
- en: 'In terms of design, we take into account the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计方面，我们考虑以下内容：
- en: Taking advantage of potential parallelism
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用潜在的并行性
- en: Many real-world applications will benefit from designing them in such a manner
    that the work can be split into distinct units, and these units or work parcels
    can run in parallel—concurrently—with each other. At the implementation level,
    we can use threads to implement the work parcels.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现实世界的应用程序将受益于以这样的方式设计它们，使得工作可以分成不同的单元，并且这些单元或工作包可以并行 - 与彼此同时运行。在实现层面，我们可以使用线程来实现工作包。
- en: As an example, a download accelerator program exploits the network by having
    several threads perform network I/O. Each thread is assigned work to download
    only a portion of the file; they all run in parallel, effectively gaining more
    network bandwidth than a single thread could, and when done, the destination file
    is stitched together.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下载加速器程序通过让几个线程执行网络I/O来利用网络。每个线程被分配下载文件的一部分的工作；它们都并行运行，有效地获得比单个线程更多的网络带宽，完成后，目标文件被拼接在一起。
- en: Many such examples abound; recognizing the potential for parallelism is an important
    part of the architect's job.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多这样的例子；认识到并行性的潜力是架构师工作的重要部分。
- en: Logical separation
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑分离
- en: The threading model intuitively lends itself to letting the designer logically
    separate work. For example, a GUI frontend application might have a few threads
    managing the GUI state, waiting for and reacting to user input, and so on. Other
    threads could be used to handle the app's business logic. Not mixing the **user
    interface** (**UI**) with the business logic is a key element of good design.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 线程模型直观地适合让设计者逻辑上分离工作。例如，GUI前端应用程序可能有几个线程管理GUI状态，等待并响应用户输入等。其他线程可以用于处理应用程序的业务逻辑。不将用户界面（UI）与业务逻辑混合在一起是良好设计的关键要素。
- en: Overlapping CPU with I/O
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU与I/O重叠
- en: This point is similar in fashion to the previous one—the logical separation
    of tasks. In the context of what we're discussing, CPU refers to software that
    is CPU-intensive or CPU-bound (the canonical example being the `while (1)`; piece
    of C code); I/O refers to software that is in a blocked state—we say that it is
    waiting on I/O, meaning that it is waiting on some other operation to complete
    (perhaps a file or network read, or any blocking API, in fact) before it can move
    forward; this is referred to as I/O bound.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点与前面的类似——任务的逻辑分离。在我们讨论的背景下，CPU指的是软件是CPU密集型或CPU绑定的（经典的例子是C代码的`while（1）`）；I/O指的是软件处于阻塞状态
    - 我们说它在等待I/O，意味着它在等待某些其他操作完成（也许是文件或网络读取，或者任何阻塞API），然后它才能继续前进；这被称为I/O绑定。
- en: 'So, think of it this way: let''s say we have a series of tasks to perform (with
    no dependencies between them): task A, task B, task C, and task D.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这样想：假设我们有一系列要执行的任务（它们之间没有依赖关系）：任务A，任务B，任务C和任务D。
- en: Let's also say that task A and task C are highly CPU-bound, whereas task B and task
    D are more I/O-bound. If we use the traditional single threaded approach, then
    of course each task has to be carried out in sequence; so, the process ends up
    waiting—for perhaps a long while—for tasks B and D, thus delaying task C. If,
    on the other hand, we use a multithreaded approach, we can separate the tasks
    as individual threads. Thus, even while the threads for tasks B and D are blocked
    on I/O, the threads for task A and C continue to make progress.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以说，任务A和任务C高度依赖CPU，而任务B和任务D更依赖I/O。如果我们使用传统的单线程方法，那么每个任务都必须按顺序执行；因此，进程最终会等待——也许要等很长时间——等待任务B和D，从而延迟任务C。另一方面，如果我们使用多线程方法，我们可以将任务分开为单独的线程。因此，即使任务B和D的线程在I/O上被阻塞，任务A和C的线程仍然可以取得进展。
- en: This is called overlapping CPU with I/O. Decoupling (and separating out) tasks
    when there is no dependency between them, by using threads, is a design approach
    that is usually worth pursuing. It leads to better application responsiveness.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为CPU与I/O的重叠。在没有依赖关系的情况下，通过使用线程来解耦（和分离）任务，这是一种通常值得追求的设计方法。这会导致更好的应用程序响应能力。
- en: Manager-worker model
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经理-工人模型
- en: Threads quite easily lend themselves to the familiar manager-worker model; a
    manager thread (often `main()`) creates worker threads on demand (or pools them);
    when work arises, a worker thread handles it. Think of busy web servers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 线程非常容易适用于熟悉的经理-工人模型；一个经理线程（通常是`main()`）根据需要创建工作线程（或者将它们汇集在一起）；当工作出现时，工作线程处理它。想想繁忙的网络服务器。
- en: IPC becoming simple(r)
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPC变得更简单
- en: Performing IPC  between processes takes a learning curve, experience, and just
    a lot of work. With threads belonging to a process, IPC—communication—between
    them is as simple as writing and reading global memory (well, to be honest, it's
    not that simple, as we shall learn when we reach the topics on concurrency and
    synchronization in the next chapter; it's still less work conceptually and literally
    than processing IPC).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程之间执行IPC需要学习曲线、经验和大量工作。对于属于一个进程的线程，它们之间的IPC——通信——就像写入和读取全局内存一样简单（说实话，这并不那么简单，当我们在下一章中讨论并发和同步的主题时，我们将了解到，概念上和实际上，这仍然比处理IPC要少得多）。
- en: Performance motivation
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能动机
- en: As the two examples in the previous section quite clearly showed us, using multithreading
    can raise application performance significantly; some of the reasons for this
    are mentioned here.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一节的两个示例清楚地向我们展示的那样，使用多线程可以显著提高应用程序的性能；这其中的一些原因在这里提到。
- en: Creation and destruction
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和销毁
- en: Preceding example 1  clearly showed us that the time taken for the creation
    and destruction of a thread is far less than that of a process. Many applications
    require that you do this almost constantly. (We shall see that creating and destroying
    threads is programmatically much simpler to do than doing the same with processes.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例1清楚地表明，创建和销毁线程所需的时间远远少于进程。许多应用程序几乎要求您几乎不断地这样做。（我们将看到，与进程相比，创建和销毁线程在编程上要简单得多。）
- en: Automatically taking advantage of modern hardware
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动利用现代硬件的优势
- en: 'Preceding example 2 clearly illustrated this point: when running a multithreaded
    app on modern multicore hardware (high-end enterprise class servers can have in
    excess of 700 CPU cores!), the underlying OS will take care of optimally scheduling
    threads onto available CPU cores; the app developers need not concern themselves
    with this. Effectively, the Linux kernel will try and ensure perfect SMP scalability
    whenever possible, which will result in higher throughput and, ultimately, speed
    gains. (Again, dear reader, we''re being optimistic here: the reality is that
    with heavy parallelism and CPU cores also comes the heavy downsides of concurrency
    concerns; we shall discuss all of this in more detail in upcoming chapters.)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例2清楚地说明了这一点：在现代多核硬件上运行多线程应用程序时（高端企业级服务器可以拥有超过700个CPU核心！），底层操作系统将负责将线程优化地调度到可用的CPU核心上；应用程序开发人员不需要关心这一点。实际上，Linux内核将尽可能确保完美的SMP可伸缩性，这将导致更高的吞吐量，最终实现速度增益。（亲爱的读者，我们在这里是乐观的：现实是，随着并行性和CPU核心的增加，也伴随着并发问题的严重缺陷；我们将在接下来的章节中更详细地讨论所有这些。）
- en: Resource sharing
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源共享
- en: 'We have already covered this very point in the *Resource sharing *section earlier
    in the beginning portion of this chapter (re-read it, if required). The bottom
    line is this: thread creation is comparatively cheap as opposed to process creation (the
    same goes for destruction). Also, the memory footprint of a thread as opposed
    to a process is much lower. Thus, resource sharing, and the associated performance
    advantages, are obtained.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本章的开始部分的*资源共享*部分中涵盖了这一点（如果需要，可以重新阅读）。最重要的是：与进程创建相比，线程创建成本较低（销毁也是如此）。此外，与进程相比，线程的内存占用要低得多。因此，可以获得资源共享和相关的性能优势。
- en: Context switching
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文切换
- en: 'Context switching is an unfortunate reality on the OS—it''s meta-work that
    must be done every time the OS switches from running one process to running another
    process (we have voluntary and involuntary context switches). The actual amount
    of time it takes to context switch is highly dependent on the hardware system
    and the software quality of the OS; typically, though, it''s in the region of
    tens of microseconds for x86-based hardware systems. That sounds quite tiny: to
    get an idea of why this is considered important (and indeed wasteful), look at
    the output of running `vmstat 3` on an average Linux desktop computer (`vmstat(1)` is
    a famous utility; used this way, it gives us a nice 10,000-foot view of system
    activity; hey, also try out its modern successor, `dstat(1)`):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文切换是操作系统上不幸的现实-每次操作系统从运行一个进程切换到运行另一个进程时都必须进行的元工作（我们有自愿和非自愿的上下文切换）。上下文切换所需的实际时间高度依赖于硬件系统和操作系统的软件质量；通常情况下，对于基于x86的硬件系统，大约在几十微秒的范围内。这听起来很小：要想知道为什么这被认为很重要（而且确实很浪费），看看在平均Linux台式电脑上运行`vmstat
    3`的输出（`vmstat(1)`是一个著名的实用程序；以这种方式使用，它给我们提供了系统活动的一个很好的总体视图；嘿，还可以尝试它的现代继任者`dstat(1)`）：
- en: '[PRE8]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: (Please look up the man page on `vmstat(1)` for a detailed explanation of all
    fields). Preceding under the `system` heading, we have two columns: `in` and `cs`
    (hardware) interrupts and context switches, respectively, that have occurred in
    the last one second. Just look at the numbers (ignore the first output line, though)!
    It's fairly high. This is why it really does matter to system designers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: （请查阅`vmstat(1)`的man页面，详细解释所有字段）。在`system`标题下，我们有两列：`in`和`cs`（硬件）中断和上下文切换，分别表示在过去一秒内发生的。只需看看数字（尽管忽略第一行输出）！这是相当高的。这就是为什么这对系统设计者来说真的很重要。
- en: 'Context switching between the threads of the same process takes a lot less
    work (and thus time) than between processes (or threads belonging to different
    processes). This makes sense: a good amount of the kernel code can be effectively
    short-circuited when the overall process remains the same. Thus, this becomes
    another advantage of using threads.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一进程的线程之间进行上下文切换所需的工作量（因此时间）要比在不同进程（或属于不同进程的线程）之间要少得多。这是有道理的：当整个进程保持不变时，大部分内核代码可以有效地被短路。因此，这成为使用线程的另一个优势。
- en: A brief history of threading
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程的简要历史
- en: Threads—a sequential flow of control—have been around for a long while now;
    only, they went under the name of processes (reports put this at the time of the
    Berkeley Timesharing System, 1965). Then, by the early 1970s, along came Unix,
    which cemented the process as the combination of a VAS and a sequential flow of
    control. As mentioned earlier, this is now called the single threaded model, as
    of course only a single thread of control—the main function—existed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 线程-一个顺序控制流-现在已经存在很长时间了；只是以进程的名义存在（据报道，这是在1965年的伯克利分时系统时）。然后，在20世纪70年代初，Unix出现了，将进程巩固为VAS和顺序控制流的组合。正如前面提到的，这现在被称为单线程模型，因为当然只有一个控制流-主函数-存在。
- en: Then, in May 1993, Sun Solaris 2.2 came out with UI threads, and a thread library
    called *libthread*, which exposed the UI API set; in effect, modern threads. Competing
    Unix vendors quickly came up with their own proprietary multithreaded solutions
    (with runtime libraries exposing APIs)—Digital with DECthreads (which was later
    absorbed by Compaq Tru64 Unix and subsequently HP-UX), IBM with AIX, Silicon Graphics
    with IRIX, and so on—each with their own proprietary solution.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，1993年5月，Sun Solaris 2.2推出了UI线程，并推出了一个名为*libthread*的线程库，它公开了UI API集；实际上，这是现代线程。竞争的Unix供应商迅速推出了自己的专有多线程解决方案（带有暴露API的运行时库）-Digital的DECthreads（后来被Compaq
    Tru64 Unix吸收，随后是HP-UX）、IBM的AIX、Silicon Graphics的IRIX等等-每个都有自己的专有解决方案。
- en: POSIX threads
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POSIX线程
- en: 'Proprietary solutions poses a major problem to the big customer who owns heterogeneous
    hardware and software from several of these vendors; being proprietary, it is
    difficult to get the differing libraries and API sets to talk to each other. It''s
    the usual problem—a lack of interoperability. The good news: in 1995, the IEEE
    formed a separate POSIX committee—IEEE 1003.1c—the **POSIX threads** (**pthreads**) committee,
    to evolve a standardized solution for an API for multithreading.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 专有解决方案对拥有来自几家供应商的异构硬件和软件的大客户构成了重大问题；由于是专有的，很难让不同的库和API集相互通信。这是一个常见的问题-缺乏互操作性。好消息是：1995年，IEEE成立了一个单独的POSIX委员会-IEEE
    1003.1c-**POSIX线程**（**pthreads**）委员会，以制定多线程API的标准化解决方案。
- en: 'POSIX: Apparently, the original name of the IEEE body is **Portable Operating
    System Interface for Computing Environments** (**POSICE**). Richard M. Stallman
    (RMS)  suggested shortening the name to **Portable Operating System Interface
    for uniX** (**POSIX**), and that name has stuck.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX：显然，IEEE机构的原始名称是**计算环境的便携式操作系统接口**（**POSICE**）。Richard M. Stallman（RMS）建议将名称缩短为**Unix的便携式操作系统接口**（**POSIX**），这个名称一直沿用至今。
- en: So, the bottom line is that pthreads is an API standard; formally, IEEE 1003.1c-1995\.
    The upshot of all of this is that all Unix and Unix-like OS vendors gradually
    built implementations supporting pthreads; so, today (in theory, at least), you
    can write a pthreads multithreaded application and it will run unmodified on any
    pthreads-compliant platform (in practice, expect a bit of porting effort).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，pthreads是一个API标准；正式来说，是IEEE 1003.1c-1995。所有Unix和类Unix操作系统供应商逐渐构建了支持pthreads的实现；因此，今天（至少在理论上），你可以编写一个pthreads多线程应用程序，并且它将在任何支持pthreads的平台上运行（在实践中，可能需要一些移植工作）。
- en: Pthreads and Linux
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pthreads和Linux
- en: Of course, Linux wanted to be compliant with the POSIX threads standard; but
    who would actually build an implementation (remember, the standard is merely a
    draft specification document; it's not code)? Back in 1996, Xavier Leroy stepped
    up and built Linux's first pthreads implementation—a threading library called Linux
    threads. All considered, it was a good effort, but was not fully compatible with
    the (then brand new) pthreads standard.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Linux希望符合POSIX线程标准；但是谁会真正构建一个实现（记住，标准只是一个草案规范文件；它不是代码）？1996年，Xavier Leroy站出来构建了Linux的第一个pthread实现——一个名为Linux线程的线程库。总的来说，这是一个很好的努力，但并不完全兼容（当时全新的）pthread标准。
- en: An early effort at resolving problems was called **Next Generation Posix Threads** (**NGPT**).
    At around the same time, Red Hat threw in a team to work on this area as well;
    they called the project **Native Posix Threading Library** (**NPTL**). In the
    best traditions of open source culture, the NGPT developers worked together with
    their counterparts at NPTL and began merging the best features of NGPT into NPTL.
    NGPT development was abandoned sometime in 2003;  by then, the realistic implementation
    of pthreads on Linux—which remains to this day—is NPTL.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 早期解决问题的努力被称为**下一代Posix线程**（**NGPT**）。大约在同一时间，Red Hat也派出一个团队来处理这个领域；他们称之为**本机Posix线程库**（**NPTL**）项目。在开源文化的最佳传统中，NGPT开发人员与NPTL的同行合作，开始将NGPT的最佳特性合并到NPTL中。NGPT的开发在2003年的某个时候被放弃；到那时，在Linux上实际的pthread实现——直到今天仍然存在的——是NPTL。
- en: 'More technically: NPTL was entrenched as the superior threading API interface,
    even as features were integrated into the 2.6 Linux kernel (December 2003 onward),
    which helped greatly improve threading performance.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说：尽管特性被集成到2.6版Linux内核（2003年12月以后），NPTL作为优越的线程API接口得到了巩固，这有助于大大提高线程性能。
- en: NPTL implements the 1:1 threading model; this model provides true multithreading
    (user and kernel state) and is also known as the native threads model. Here, we
    do not intend to delve into these internal details; a link has been provided for
    interested readers in the *Further reading *section on the GitHub repository.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: NPTL实现了1:1线程模型；这个模型提供了真正的多线程（用户和内核状态），也被称为本地线程模型。在这里，我们不打算深入探讨这些内部细节；在GitHub存储库的*进一步阅读*部分中提供了一个链接，供感兴趣的读者参考。
- en: 'One can look up the threading implementation (since glibc 2.3.2) with the following
    code (on a Fedora 28 system):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下代码（在Fedora 28系统上）查找线程实现（自glibc 2.3.2以来）：
- en: '[PRE9]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Clearly, it's NPTL.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是NPTL。
- en: Thread management – the essential pthread APIs
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程管理——基本的pthread API
- en: 'In this—the second major portion of this first chapter on multithreading—we
    shall now focus on the mechanics: using the pthreads API, how exactly does the
    programmer create and manage threads in an effective fashion? We will explore
    the essential pthreads API interfaces to fulfill this key purpose; this knowledge
    is the building block for writing functional and performance-friendly pthreads
    applications.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一章关于多线程的第二个重要部分中，我们现在将专注于机制：使用pthread API，程序员究竟如何以有效的方式创建和管理线程？我们将探索基本的pthread
    API接口，以实现这一关键目的；这种知识是编写功能性和性能友好的pthread应用程序的基础。
- en: We will take you through the thread life cycle in terms of API sets—creating,
    terminating, joining upon (waiting for), and in general, managing the threads
    of a process. We will also cover thread stack management.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过API集来介绍线程的生命周期——创建、终止、等待（等待）、以及一般地管理进程的线程。我们还将涵盖线程堆栈管理。
- en: This, of course, implies that we have a pthreads runtime library installed on
    the Linux system. On modern Linux distributions, this will certainly be the case;
    it's only if you are using a rather exotic embedded Linux that you will have to
    verify this. The name of the pthreads library on the Linux platform is libpthread.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然意味着我们在Linux系统上安装了一个pthread运行时库。在现代Linux发行版上，这肯定是这样；只有在使用相当古怪的嵌入式Linux时，您才需要验证这一点。Linux平台上pthread库的名称是libpthread。
- en: 'A couple of key points regarding the pthread APIs are as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 关于pthread API的一些关键点如下：
- en: All pthread APIs require the  `<pthread.h>` header file to be included in the
    source.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有pthread API都需要在源文件中包含`<pthread.h>`头文件。
- en: 'The API often uses the object-oriented concepts of data hiding and data abstraction;
    many data types are internal typedefs; this design is deliberate: we want portable
    code. Thus, the programmer must not assume types and must work with the provided
    helper methods where applicable to access and/or query data types. (Of course,
    the code itself is the usual procedural C; nevertheless, many concepts are modeled
    around object orientation. Interestingly, the Linux kernel also follows this approach.)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该API经常使用面向对象的数据隐藏和数据抽象概念；许多数据类型是内部typedefs；这种设计是故意的：我们希望代码是可移植的。因此，程序员不应该假设类型，并且必须使用提供的辅助方法来访问和/或查询数据类型。
    （当然，代码本身是通常的过程式C；然而，许多概念都是围绕对象导向建模的。有趣的是，Linux内核也遵循这种方法。）
- en: Thread creation
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程创建
- en: 'The pthreads API for creating a thread is `pthread_create(3)`; its signature
    is as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建线程的pthread API是`pthread_create(3)`；其签名如下：
- en: '[PRE10]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When compiling pthread applications, it's very important to specify the `-pthread`
    `gcc` option switch (it enables required macros for using the libpthread library(more
    on this to follow).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译pthread应用程序时，非常重要的是指定`-pthread` `gcc`选项开关（它启用了使用libpthread库所需的宏（后续将详细介绍）。
- en: '`pthread_create` is the API to invoke to create a new thread within the calling
    process. On success, the new thread will be running concurrently (in parallel)
    with other threads that may be alive in that process at that point in time; but
    what code will it be running? It will start by running the code of the `start_routine`
    function (the third parameter to this API: a pointer to the function). Of course,
    this `thread` function can subsequently make any number of function calls.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`pthread_create`是调用以在调用进程中创建新线程的API。成功时，新线程将与该进程中可能存在的其他线程并发（并行）运行；但它将运行什么代码呢？它将从运行`start_routine`函数的代码开始（这是API的第三个参数：指向函数的指针）。当然，这个线程函数随后可以进行任意数量的函数调用。'
- en: The new thread's thread ID will be stored in the opaque data item `thread`—the
    first parameter (it's a value-result style parameter). Its data type, `pthread_t`
    is deliberately opaque; we must not assume that it's an integer (or any such thing).
    We shall soon come across when and how we use the thread ID.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 新线程的线程ID将被存储在不透明数据项`thread`中——第一个参数（这是一个值-结果样式的参数）。它的数据类型`pthread_t`是故意不透明的；我们不能假设它是整数（或任何其他东西）。我们很快将遇到何时以及如何使用线程ID。
- en: Notice that the third parameter, the function pointer—the routine run by the
    new thread—itself receives a void* parameter—a generic pointer. This is a common
    and helpful programming technique, enabling us to pass absolutely any value(s)
    to the newly created thread. (This kind of parameter is often referred to as client
    data or tag in the literature.) How do we pass it? Via the fourth parameter to `pthread_create(3)`, `arg`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第三个参数，函数指针——新线程运行的例程本身接收一个void*参数——一个通用指针。这是一种常见且有用的编程技术，使我们能够向新创建的线程传递绝对任何值。
    （这种参数通常在文献中被称为客户数据或标签。）我们如何传递它？通过`pthread_create(3)`的第四个参数`arg`。
- en: 'The second parameter to `pthread_create(3)` is a thread attribute structure;
    here, the programmer should pass the attributes of the thread being created (we
    shall discuss some of them shortly). There is a shortcut: passing `NULL` here
    implies that the library should use the default attributes when creating a thread.
    However, the defaults on a certain Unix might differ substantially from those
    on a different Unix or Linux; writing portable code implies one does not assume
    any defaults, but rather explicitly initializes a thread with attributes that
    are correct for the application. Thus, our recommendation would definitely be
    to not pass `NULL`, but to explicitly initialize a `pthread_attr_t` structure
    and pass it along (the code examples that follow will illustrate this).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`pthread_create(3)`的第二个参数是线程属性结构；在这里，程序员应该传递正在创建的线程的属性（我们很快将讨论其中的一些）。有一个快捷方式：在这里传递`NULL`意味着库应该在创建线程时使用默认属性。然而，在某个Unix上的默认值可能与另一个Unix或Linux上的默认值有很大不同；编写可移植的代码意味着不要假设任何默认值，而是显式地初始化适合应用程序的属性。因此，我们的建议肯定是不要传递`NULL`，而是显式地初始化一个`pthread_attr_t`结构并将其传递（接下来的代码示例将说明这一点）。'
- en: Finally, the return value to `pthread_create(3)` is `0` on success and non-zero
    on failure; `errno` is set to a few values as appropriate (we refer you to the
    man page on `pthread_create(3)` for these details).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`pthread_create(3)`的返回值在成功时为`0`，失败时为非零；`errno`将根据需要设置为几个值（我们建议您参考`pthread_create(3)`的手册页了解这些细节）。
- en: 'When a new thread is created, it inherits certain attributes from its creating
    thread; these include the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建新线程时，它会从创建线程那里继承某些属性；其中包括以下内容：
- en: The creating thread's capability sets (recall our discussion in [Chapter 8](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml),
    *Process Capabilities*); this is Linux-specific
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建线程的能力集（回想一下我们在[第8章](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml)中的讨论，*进程能力*）；这是特定于Linux的
- en: The creating thread's CPU affinity mask; this is Linux-specific
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建线程的CPU亲和性掩码；这是特定于Linux的
- en: The signal mask
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号掩码
- en: Any pending signals and pending timers (alarms) in the new thread are cleared. CPU
    execution times will be reset as well for the new thread.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 新线程中的任何未决信号和未决定时器（警报）都将被清除。新线程的CPU执行时间也将被重置。
- en: Just so you know, on the Linux libpthreads implementation, `pthread_create(3)` calls
    the `clone(2)` system call, which, within the kernel, actually creates the thread.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你知道，在Linux libpthreads实现中，`pthread_create(3)`调用了`clone(2)`系统调用，在内核中实际上创建了线程。
- en: Interestingly, modern glibc's fork implementation also invokes the `clone(2)` system
    call. Flags passed to `clone(2)` determine how resource sharing is done.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，现代glibc的`fork`实现也调用了`clone(2)`系统调用。传递给`clone(2)`的标志确定了如何进行资源共享。
- en: 'It''s about time that we did some coding! We will write a really simple (and
    actually quite buggy!)  `hello, world.` for pthreads application (`ch14/pthreads1.c`):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候写一些代码了！我们将为pthread编写一个非常简单（实际上相当有bug的）`hello, world.`应用程序（`ch14/pthreads1.c`）：
- en: '[PRE11]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we loop three times, and on each loop iteration we create a
    thread. Notice the third parameter to the `pthread_create(3)`—a function pointer
    (just providing the name of the function is sufficient; the compiler will figure
    the rest); this is the the thread's work routine. Here, it's the function `worker`.
    We also pass the fourth parameter to `pthread_create`—recall that's it's the client
    data, any data you would like to pass to the newly created thread; here, we pass
    the loop index `i` (of course, we appropriately typecast it so that the compiler
    won't complain).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们循环三次，在每次循环迭代时创建一个线程。注意`pthread_create(3)`的第三个参数——一个函数指针（只提供函数名称就足够了；编译器会自动处理剩下的部分）；这是线程的工作例程。这里是函数`worker`。我们还传递第四个参数给`pthread_create`——记住这是客户数据，任何你想传递给新创建线程的数据；这里我们传递循环索引`i`（当然，我们适当地对其进行类型转换，以免编译器抱怨）。
- en: 'In the `worker` function, worker, we gain access to the client data (received
    as the formal parameter `data`) by again type-casting the `void *` back to its
    original type, `long`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在`worker`函数中，我们通过再次将`void *`强制转换回其原始类型`long`来访问客户数据（作为形式参数`data`接收）：
- en: '`long datum = (long)data;`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`long datum = (long)data;`'
- en: We then merely emit a couple of printf's to show that, yes, we are here indeed.
    Notice how all the worker threads run the same code—the `worker` function. This
    is entirely acceptable; recall that code (text) is read-execute in terms of page
    permissions; running text in parallel is not only all right, but it's often desirable
    (providing high throughput).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们只是发出了一些printf来显示，是的，我们确实在这里。请注意，所有工作线程都运行相同的代码——`worker`函数。这是完全可以接受的；请记住，代码（文本）是按页权限进行读取执行的；并行运行文本不仅是可以的，而且通常是可取的（提供高吞吐量）。
- en: 'To build it, we have provided the Makefile; note, though, that all the pthreads APIs
    aren''t linked in by default, like glibc. No, they are, of course, in libpthread, which
    we shall have to both explicitly compile (to our source files) and link in to
    our binary executable via the `-pthread` directive. The following snippet from
    the Makefile shows this being done:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 构建它，我们提供了Makefile；请注意，所有pthread API默认情况下并未链接，就像glibc一样。不，它们当然在libpthread中，我们需要显式编译（到我们的源文件）并通过`-pthread`指令链接到我们的二进制可执行文件中。Makefile中的以下片段显示了这一点：
- en: '[PRE12]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Building it now works, but—and please note this carefully—the program does not work
    well at all! In the following code, we perform some test runs by looping around `./pthreads1`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建已经可以工作了，但是请注意，这个程序实际上并不工作得很好！在下面的代码中，我们通过循环运行`./pthreads1`来执行一些测试运行：
- en: '[PRE13]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see the `hello, world.` message only appears intermittently and not
    at all in trial runs 4 and 5 (of course, the output you see when you try this
    out can certainly vary due to timing issues).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，“hello, world.”消息只是间歇性地出现，并且在第4和第5次试运行中根本没有出现（当然，由于时间问题，您尝试这个程序时看到的输出肯定会有所不同）。
- en: 'Why is it like this? Simple: we have inadvertently set up a buggy situation—a race!
    Where exactly? Look at the code again, carefully: what does the `main()` function
    do once the loop is done? It calls `exit(3)`; thus the entire process terminates,
    not just the main thread! And who is to say that the worker threads completed
    their work before this occurred? Ah—that, ladies and gentlemen, is your classic
    race.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会这样？很简单：我们无意中设置了一个有bug的情况——竞争！到底在哪里？仔细再看一遍代码：一旦循环结束，`main()`函数会做什么？它调用`exit(3)`；因此整个进程终止，不仅仅是主线程！而且谁能说工作线程在这发生之前完成了他们的工作呢？啊——这位女士们先生们，这就是您经典的竞争。
- en: So, how do we fix it? For now, we shall just perform a couple of quick fixes;
    the proper way to avoid racy code is via synchronization; this is a big topic
    and deserves a chapter by itself (as you shall see). Okay, first, let's fix the
    problem of the main thread prematurely exiting.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何修复它呢？目前，我们将只进行一些快速修复；避免竞争代码的正确方法是通过同步；这是一个重要的话题，值得单独一章来讨论（您将会看到）。好的，首先，让我们解决主线程过早退出的问题。
- en: Termination
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止
- en: 'The `exit(3)` library API causes the calling process—along with all of its
    threads – to terminate. If you would like a single thread to terminate, have it
    invoke the `pthread_exit(3)` API instead:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit(3)`库API会导致调用进程以及其所有线程终止。如果您希望单个线程终止，请让它调用`pthread_exit(3)`API：'
- en: '[PRE14]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This parameter specifies the exit status of the calling thread; for the time
    being, we ignore it and just pass `NULL` (we shall examine using this parameter
    shortly).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数指定了调用线程的退出状态；目前，我们忽略它，只传递`NULL`（我们将很快研究如何使用这个参数）。
- en: So, back to our racy app (`ch14/pthreads1.c`); let's make a second, better version
    (`ch14/pthreads2.c`). The problem, really, with our first version was the race—the main thread
    calls `exit(3)`, causing the entire process to die, probably before the worker
    threads got a chance to complete their work. So, let's fix this by having `main()`
    call `pthread_exit(3)`! Also, why not have our thread worker function terminate
    properly by explicitly invoking the `pthread_exit(3)` as well?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，回到我们的竞争应用程序（`ch14/pthreads1.c`）；让我们制作一个第二个更好的版本（`ch14/pthreads2.c`）。实际上，我们第一个版本的问题是竞争——主线程调用`exit(3)`，导致整个进程可能在工作线程有机会完成工作之前就死掉了。所以，让我们通过让`main()`调用`pthread_exit(3)`来解决这个问题！另外，为什么不让我们的线程工作函数通过显式调用`pthread_exit(3)`来正确终止呢？
- en: 'The following are the modified code snippets for the `worker()` and `main()` functions
    (`ch14/pthreads2.c`):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`worker()`和`main()`函数的修改后的代码片段（`ch14/pthreads2.c`）：
- en: '[PRE15]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s try out the preceding program:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下前面的程序：
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That's much better!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 好多了！
- en: The return of the ghost
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鬼魂的回归
- en: 'There is still a hidden problem. Let''s do some more experimentation: let''s
    write a third version of this program (let''s call it `ch14/pthreads3.c`). In
    it, we say, what if the worker threads take longer to perform their work (than
    they are currently taking)? We can easily simulate this with a simple `sleep(3)` function,
    which is going to be introduced into the worker routine:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个隐藏的问题。让我们进行更多的实验：让我们编写这个程序的第三个版本（让我们称之为`ch14/pthreads3.c`）。在这个版本中，我们假设工作线程需要更长的时间来完成他们的工作（比它们目前所需的时间长）。我们可以很容易地通过一个简单的`sleep(3)`函数来模拟这一点，这将被引入到工作例程中：
- en: '[PRE17]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s try it out:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Well? It looks just fine. Is it really? There's just one more quick and minor
    modification that has to be done; increase the sleep time from 3 seconds to, say,
    30 seconds, and rebuild and retry (the only reason we do this is to give the end
    user a chance to type a `ps(1)` command, as shown in the following screenshot,
    before the app dies). Now, run it in the background , and take a closer look!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 好了？看起来很好。真的吗？还有一个快速而次要的修改必须完成；将睡眠时间从3秒增加到30秒，然后重新构建和重试（我们这样做的唯一原因是给最终用户一个机会输入`ps(1)`命令，如下面的屏幕截图所示，然后应用程序就会死掉）。现在，在后台运行，并仔细观察！
- en: '![](img/142c88d2-a84e-4026-855c-0fe06c95b0a1.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/142c88d2-a84e-4026-855c-0fe06c95b0a1.png)'
- en: 'Check out the preceding screenshot: we run the `pthreads3` app in the background;
    the app (well, the main thread of the app) creates an additional three threads.
    The threads merely block by going to sleep for thirty seconds each. As we ran
    the process in the background, we get control on the shell process; now we run `ps(1)`with
    the `-LA` option switches. From the man page on `ps(1)`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 查看前面的屏幕截图：我们在后台运行`pthreads3`应用程序；该应用程序（实际上是应用程序的主线程）创建了另外三个线程。这些线程只是通过每个休眠三十秒来阻塞。当我们在后台运行进程时，我们可以在shell进程上获得控制；现在我们使用`ps(1)`和`-LA`选项开关运行。从`ps(1)`的man页面上：
- en: '`-A`: Select all processes; identical to `-e`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-A`：选择所有进程；与`-e`相同'
- en: '`-L`: Show threads, possibly with LWP and NLWP columns'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-L`：显示线程，可能带有LWP和NLWP列'
- en: 'All right! (GNU) `ps(1)` can even show us every thread alive by making use
    of the `-L` option switch (try out `ps H` too). With the `-L` switch, the first
    column in the output of `ps` is the PID of the process (quite familiar to us);
    the second column is the thread **Light Weight Process** (**LWP**); in effect,
    this is the PID of the individual thread as seen by the kernel. Interesting. Not
    just that, look at the numbers carefully: where the PID and LWP match, it''s the `main()`
    thread of the process; where the PID and LWP differ, it tells us that this is
    a child, or more correctly just a peer thread, belonging to the process; the LWP
    is the thread PID as seen by the OS. So, in our sample run, we have the process
    PID of 3906, along with four threads: the first one is the `main()` thread (as
    its PID == its LWP value), while the remaining three have the same PID—proving
    they belong to the same overall process, but their individual thread PIDs (their
    LWPs) are unique – 3907, 3908, and 3909!'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧！（GNU）`ps(1)`甚至可以通过使用`-L`选项开关来显示每个活动的线程（也尝试一下`ps H`）。使用`-L`开关，`ps`输出的第一列是进程的PID（对我们来说非常熟悉）；第二列是**轻量级进程**（**LWP**）；实际上，这是内核所见的单个线程的PID。有趣。不仅如此，仔细看看这些数字：PID和LWP匹配的地方是进程的`main()`线程；PID和LWP不同的地方告诉我们这是一个子线程，或者更准确地说是属于进程的对等线程；LWP是操作系统所见的线程PID。因此，在我们的示例运行中，我们有进程PID为3906，以及四个线程：第一个是`main()`线程（因为其PID
    == 其LWP值），而其余三个具有相同的PID——证明它们属于同一个进程，但它们各自的线程PID（它们的LWP）是唯一的——3907、3908和3909！
- en: The problem we have been referring to, though, is that in the first line—which
    represents the main thread—of the `ps` output is that the process name is followed
    by the phrase
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在提到的问题是，在`ps`输出的第一行（代表`main`线程）中，进程名称后面跟着短语
- en: '`<defunct>` (on the extreme right). The alert reader will remember that defunct is
    another term for zombie! Yes indeed, the infamous zombie has returned to haunt
    us.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`<defunct>`（极端右侧）。敏锐的读者会记得`defunct`是`zombie`的另一个术语！是的，臭名昭著的僵尸又回来了。'
- en: 'The main thread, by invoking `pthread_exit(3)` (recall the code of main in
    `ch14/pthreads3.c`), has exited before the other threads in the process; the Linux
    kernel thus marks it as a zombie. As we learned in [Chapter 10](607ad988-406d-4736-90a4-3a318672ab6e.xhtml), *Process
    Creation*, zombies are undesirable entities; we really do not want a zombie hanging
    around (wasting resources). So, the question, of course, is how do we prevent
    the main thread from becoming a zombie? The answer is straightforward: do not allow
    the main thread to terminate before the other threads in the application; in other
    words, the recommendation is to always keep `main()` alive, waiting for all the
    other threads to die, before it itself terminates (and thus the process terminates).
    How? Read on.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 主线程通过调用`pthread_exit(3)`（回想一下`ch14/pthreads3.c`中的主代码）在进程中的其他线程之前退出；因此Linux内核将其标记为僵尸。正如我们在[第10章](607ad988-406d-4736-90a4-3a318672ab6e.xhtml)中学到的那样，僵尸是不受欢迎的实体；我们真的不希望有僵尸挂在那里（浪费资源）。因此，问题当然是如何防止主线程成为僵尸？答案很简单：不要允许主线程在应用程序中的其他线程之前终止；换句话说，建议始终保持`main()`活动，等待所有其他线程死亡，然后再终止自身（从而终止进程）。如何做到？继续阅读。
- en: 'Again, it goes without saying (but we shall say it!): the process remains alive
    as long as at least one thread within it remains alive.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调（但我们还是要说！）：只要其中至少一个线程保持活动状态，进程就会保持活动状态。
- en: As a quick aside, when will the worker threads run with respect to each other
    and main? In other words, is it guaranteed that the first thread created will
    run first, followed by the second thread, then the third, and so on?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速的旁白，工作线程何时运行相对于彼此和主线程？换句话说，第一个创建的线程是否保证首先运行，然后是第二个线程，然后是第三个，依此类推？
- en: 'The short answer: no, there is no such guarantee. Especially on modern **Symmetric
    Multiprocessor** (**SMP**) hardware and a modern multiprocess-and-multithreaded-capable
    OS such as Linux, the actual order at runtime is indeterminate (which is a fancy
    way of saying it can''t be known). In reality, it''s up to the OS scheduler to
    make these decisions (that is, in the absence of real-time scheduling policies
    and thread priorities; we shall tackle these topics later in this book).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的答案是：没有这样的保证。特别是在现代的**对称多处理器**（**SMP**）硬件和像Linux这样的现代多进程和多线程能力的操作系统上，运行时的实际顺序是不确定的（这是一种说法，即无法知道）。实际上，这取决于操作系统调度程序来做出这些决定（也就是说，在没有实时调度策略和线程优先级的情况下；我们将在本书的后面讨论这些主题）。
- en: 'Another trial run of our `./pthreads2` sample program reveals this very case:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`./pthreads2`示例程序的另一个试运行显示了这种情况：
- en: '[PRE19]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Can you see what happened? The order shown in the preceding code is: `thread
    #0`, followed by `thread #2`, followed by `thread #1`! It''s unpredictable. Do
    not assume any specific order of execution when designing your multithreaded applications.
    (We shall cover synchronization in a later chapter, which teaches us how to achieve
    the order we require.)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '你能看到发生了什么吗？在前面的代码中显示的顺序是：`thread #0`，然后是`thread #2`，然后是`thread #1`！这是不可预测的。在设计多线程应用程序时，不要假设任何特定的执行顺序（我们将在以后的章节中介绍同步，教我们如何实现所需的顺序）。'
- en: So many ways to die
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 死亡的方式有很多
- en: 'How can a thread terminate? It turns out there are several ways:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 线程如何终止？事实证明有几种方式：
- en: Explicitly, by invoking `pthread_exit(3)`.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`pthread_exit(3)`。
- en: Implicitly, by returning from the thread function; the return value is implicitly
    passed (as though via `pthread_exit` parameter).
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从线程函数返回，返回值会被隐式传递（就像通过`pthread_exit`参数一样）。
- en: Implicitly, by falling off the thread function; that is, hitting the close brace
    `}`; note however that this is not recommended (a later discussion will show you
    why)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式地，通过从线程函数中跳出；也就是说，到达右括号`}`；但请注意，这并不推荐（稍后的讨论将告诉你为什么）
- en: Any thread invoking the `exit(3)` API will, of course, cause the entire process,
    along with all threads in it, to die.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何调用`exit(3)`API的线程，当然会导致整个进程以及其中的所有线程死掉。
- en: The thread gets canceled (which we will cover later).
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程被取消（我们稍后会讨论）。
- en: How many threads is too many?
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有太多线程了吗？
- en: 'So, by now, we know how to create an application process with a few threads
    executing within it. We will repeat a code snippet from our very first demo program,
    `ch14/pthreads1.c`, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道如何创建一个应用程序进程，并在其中执行一些线程。我们将重复我们的第一个演示程序`ch14/pthreads1.c`中的代码片段，如下：
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Clearly, the process—well, we really mean the main thread of the process (or
    application)—goes in a loop, and each loop iteration creates a thread. So, when
    it's done, we will have three threads in addition to the main thread, which is
    a total of four threads, alive in the process.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，进程-实际上我们指的是进程的主线程（或应用程序）-进入循环，每次循环迭代都会创建一个线程。因此，当完成时，我们将有三个线程，加上主线程，总共有四个线程，在进程中活动。
- en: 'This is obvious. The point here is this: creating threads is so much simpler
    than creating (child) processes with the `fork(2)`; with fork, we had to carefully
    code it, getting the child to run its code while the parent continues with its
    code path (recall the switch-case construct; take another quick look at our `ch10/fork4.c` code
    example, if you wish to). With `pthread_create(3)`, things have become easy for
    the application programmer – just call the API in a loop—and voila! You get as
    many threads as you like! In the preceding code snippet, imagine tweaking it,
    changing the value of `NTHREADS` from 3 to 300; and just like that, the process
    will produce 300 threads. What if we made `NTHREADS` 3,000? Or 30,000!?'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是显而易见的。这里的重点是：创建线程比使用`fork(2)`创建（子）进程要简单得多；使用fork时，我们必须仔细编写代码，让子进程运行其代码，而父进程继续其代码路径（回想一下switch-case结构；如果愿意，可以快速查看我们的`ch10/fork4.c`代码示例）。使用`pthread_create(3)`，对于应用程序员来说变得很容易-只需在循环中调用API-就可以了！在前面的代码片段中，想象一下调整它，将`NTHREADS`的值从3更改为300；就这样，进程将产生300个线程。如果我们将`NTHREADS`设为3,000呢？或者30,000！？
- en: 'Thinking about this brings up a couple of pertinent questions: one, how many
    threads can you actually create? And two, how many threads should you create?
    Please, read on.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 思考这一点会引发一些相关的问题：一，你实际上能创建多少线程？二，你应该创建多少线程？请继续阅读。
- en: How many threads can you create?
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你能创建多少线程？
- en: If you think about it, there must be some artificial constraint upon the number
    of threads that the underlying OS will allow an application to create; otherwise,
    system resources would get exhausted pretty quickly. In fact, this is not really
    something new; our whole discussion in [Chapter 3](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml),
    *Resource Limits*, was really about similar things.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，底层操作系统对应用程序可以创建的线程数量肯定有一些人为的限制；否则，系统资源会很快被耗尽。事实上，这并不是什么新鲜事；我们在[第3章](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml)中的整个讨论实际上就是关于类似的事情。
- en: 'With regard to threads (and processes), there are two (direct) limits that
    impact the number of threads that can exist at any given point in time:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 关于线程（和进程），有两个（直接）限制影响着任何给定时间点可以存在的线程数量：
- en: 'Per process resource limits: You will recall from our [Chapter 3](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml),
    *Resource Limits*, that there are two utilities to look up the currently defined
    resource limits: `ulimit(1)` and `prlimit(1)`, the latter being the modern interface.
    Let''s take a quick look at the resource limit for max user processes; also realize
    that although the word processes is used, you should actually think of these as
    threads:'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个进程的资源限制：你会回忆起我们在[第3章](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml)中讨论过，有两个实用程序可以查看当前定义的资源限制：`ulimit(1)`和`prlimit(1)`，后者是现代接口。让我们快速看一下最大用户进程的资源限制；还要意识到，尽管使用了单词进程，但实际上应该将其视为线程：
- en: '[PRE21]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Similarly, `prlimit()` shows us the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`prlimit()`向我们展示了以下内容：
- en: '[PRE22]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we have shown you how to query the limit via the CLI; to see how to change
    it—both interactively and programmatically with API interfaces – refer to [Chapter
    3](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml), *Resource Limits.*
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经向你展示了如何通过CLI查询限制；要查看如何进行交互和使用API接口来更改它，请参考[第3章](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml)，*资源限制*。
- en: 'System-wide limits: The Linux OS maintains a system-wide (not per-process)
    limit on the total number of threads that can be alive at any given point in time.
    This value is exposed to the user space via the proc filesystem:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统范围限制：Linux操作系统维护着一个系统范围的（而不是每个进程的）限制，限制了在任何给定时间点可以活动的线程总数。这个值通过proc文件系统暴露给用户空间：
- en: '[PRE23]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, the thing to understand is that if either of the preceding two limits are
    breached, `pthread_create(3)` (and similarly, the `fork(2)`) will fail (typically
    setting `errno` to the value `EAGAIN` try again; the OS saying, in effect, "I
    cannot do this for you right now, please try again later").
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要理解的是，如果违反了前两个限制中的任何一个，`pthread_create(3)`（以及类似地，`fork(2)`）将失败（通常将`errno`设置为值`EAGAIN`再试一次；操作系统实际上是在说：“我现在无法为你做到这一点，请稍后再试一次”）。
- en: 'Can you change these values? Yes, of course, but with the usual caveat—you
    require root (super user) access to do so. (Again, we have discussed these points
    in detail with respect to  in [Chapter 3](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml),
    *Resource Limits*) Regarding the system-wide limit, you can indeed change it as
    the root. But, hang on, blindly changing system parameters like this without an
    understanding of the impact is a sure way to lose grip on a system! So, let''s
    start by asking ourselves this: the OS sets the `threads-max` limit at boot time;
    what does it base the value on?'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你能改变这些值吗？当然可以，但通常情况下，你需要root（超级用户）访问权限才能这样做。（同样，我们已经在[第3章](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml)中详细讨论了这些要点，*资源限制*）关于系统范围的限制，你确实可以作为root来改变它。但是，请等一下，盲目地改变系统参数而不了解其影响是失去对系统控制的一种确定方式！所以，让我们首先问自己这个问题：操作系统在启动时设置`threads-max`限制的值是基于什么的？
- en: 'The short answer: it''s directly proportional to the amount of RAM on the system.
    This makes sense: ultimately, memory is the key limiting resource with regard
    to creating threads and processes.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是：它与系统上的RAM数量成正比。这是有道理的：最终，内存是关于创建线程和进程的关键限制资源。
- en: 'In more detail for our dear OS-level geek readers: kernel code at boot time
    sets the `/proc/sys/kernel/threads-max` value so that thread (task) structures
    within the OS can take a maximum of one-eighth of available RAM. (The threads-max minimum
    value is 20; the maximum value is the constant `FUTEX_TID_MASK 0x3fffffff`.)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们亲爱的操作系统级别的极客读者来说，更详细地说：内核代码在启动时设置了`/proc/sys/kernel/threads-max`的值，以便操作系统中的线程（任务）结构最多可以占用可用RAM的八分之一。（`threads-max`的最小值是20；最大值是常量`FUTEX_TID_MASK
    0x3fffffff`。）
- en: Also, by default, the per-process resource limit for the maximum number of threads
    is half of the system limit.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，默认情况下，最大线程数的每进程资源限制是系统限制的一半。
- en: 'As seen from the preceding code, the value we obtained was 126,446; this was
    done on a native Linux laptop with 16 GB of RAM. Running the same commands on
    a guest VM with 1 GB of RAM yields the following results:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看出，我们得到的值是126,446；这是在一台带有16GB RAM的本机Linux笔记本电脑上完成的。在一台带有1GB RAM的虚拟机上运行相同的命令会得到以下结果：
- en: '[PRE24]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Setting the `threads-max`kernel tunable to too high a value – beyond `FUTEX_TID_MASK`
    – will cause it to be brought down to that value (but, of course, that is almost
    certainly too large in any case). But even within limits, you can stray too far,
    causing the system to become vulnerable (to **denial-of-service** (**DoS**) attacks,
    perhaps!). On an embedded Linux system, lowering the limit might actually help
    by constraining the system.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将`threads-max`内核可调整值设置为过高的值——超过`FUTEX_TID_MASK`——将导致它被降低到该值（但是，当然，在任何情况下，这几乎肯定都太大了）。但即使在限制范围内，你也可能走得太远，导致系统变得脆弱（可能会受到**拒绝服务**（DoS）攻击的影响！）。在嵌入式Linux系统上，降低限制实际上可能有助于约束系统。
- en: Code example – creating any number of threads
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例——创建任意数量的线程
- en: 'So, let''s put it to the test: we will write a simple extension of our previous
    program, this time allowing the user to specify the number of threads to attempt
    to create within the process as the parameter (`ch14/cr8_so_many_threads.c`).
    The main function is as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们来测试一下：我们将编写我们先前程序的一个简单扩展，这次允许用户指定要在进程中尝试创建的线程数量作为参数（`ch14/cr8_so_many_threads.c`）。主函数如下：
- en: '[PRE25]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It''s quite simple: we convert the string value the user passed as the first
    parameter to a numeric one with `numthrds`; we then have main loop `numthrds` times,
    invoking `pthread_create(3)` and thus creating a brand new thread upon each loop
    iteration! Once created, what do the new threads do? It''s clear – they execute
    the code of the `worker` function. Let''s take a look:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单：我们将用户传递的字符串值作为第一个参数转换为数字值，然后我们循环`numthrds`次，每次调用`pthread_create(3)`，从而在每次循环迭代时创建一个全新的线程！一旦创建，新线程会做什么？很明显——它们执行`worker`函数的代码。让我们来看一下：
- en: '[PRE26]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Again, this is very simple: the worker threads just emit a `printf(3)`—which
    is useful because they print out their thread number—it''s just the loop index
    of course. Then, they go to sleep via the `pause(2)` system call. (This system
    call is useful: it''s a perfect blocking call; it puts the calling thread to sleep
    until a signal arrives.)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这非常简单：工作线程只是发出一个`printf(3)`——这很有用，因为它们打印出它们的线程号——当然只是循环索引。然后，它们通过`pause(2)`系统调用进入睡眠状态。（这个系统调用很有用：它是一个完美的阻塞调用；它会将调用线程置于睡眠状态，直到收到信号。）
- en: 'All right, let''s try it out:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，让我们试一试：
- en: '[PRE28]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It works (notice that we've truncated the output as there would be far too much
    to show in this book). Notice how the order in which the threads come alive and
    execute (emitting their `printf`) is random. We can see that the last thread we
    created is the one highlighted in bold—thread `# 299` (0 to 299 is 300 threads).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 它起作用了（请注意，我们已经截断了输出，因为在本书中显示太多内容）。请注意，线程启动和执行的顺序（发出它们的`printf`）是随机的。我们可以看到，我们创建的最后一个线程是加粗显示的——线程`#
    299`（0到299是300个线程）。
- en: 'Now, let''s run it again, but this time ask it to create an impossibly large
    number of threads (we are currently trying this out on a guest VM with 1 GB of
    RAM):'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次运行它，但这次让它创建一个不可能的大数量的线程（我们目前正在一台带有1GB RAM的虚拟机上尝试这个）：
- en: '[PRE29]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Obviously, again, the results that you will see will depend on your system;
    we encourage the reader to try it out on different systems. Also, it's possible
    that the actual failure message may have appeared somewhere higher up in your
    Terminal window; scroll up to find it!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你将看到的结果取决于你的系统；我们鼓励读者在不同的系统上尝试一下。此外，实际的失败消息可能出现在你的终端窗口的更高位置；向上滚动以找到它！
- en: The name of the thread, as shown by `ps(1)`, and so on, can be set via the `pthread_setname_np(3)` API;
    note that the `np` suffix implies that the API is non-portable (Linux-only).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 线程的名称，如`ps(1)`所示，等等，可以通过`pthread_setname_np(3)`API来设置；请注意，`np`后缀意味着该API是不可移植的（仅限Linux）。
- en: How many threads should one create?
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应该创建多少个线程？
- en: The number of threads you create really does depend on the nature of the application. For
    our discussion here, we will consider which the application tends to be – CPU
    versus IO bound.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建的线程数量确实取决于应用程序的性质。在我们的讨论中，我们将考虑应用程序倾向于是CPU还是I/O限制。
- en: 'Earlier in this chapter (specifically within the sections on *Design Motivation*
    and* Overlapping CPU with I/O*), we mentioned the fact that a thread, in terms
    of its execution behavior, falls somewhere on a continuum, somewhere between two
    extremes: one extreme being a completely CPU-bound task and the other extreme
    being a completely I/O-bound task. The continuum may be visualized like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面（特别是在*设计动机*和*重叠CPU与I/O*的部分），我们提到了一个事实，即一个线程在执行行为上，处于一个连续体的某个位置，介于两个极端之间：一个极端是完全CPU限制的任务，另一个极端是完全I/O限制的任务。这个连续体可以被想象成这样：
- en: '![](img/4d003f8d-0633-4386-a8b0-d06b42ae6701.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d003f8d-0633-4386-a8b0-d06b42ae6701.png)'
- en: 'Fig 3: The CPU-bound/IO-bound continuum'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：CPU限制/I/O限制连续体
- en: A thread that is a 100% CPU-bound will be continually hammering away on the
    CPU; a 100% I/O-bound thread is one that is always in a blocking (or wait) state,
    never executing on CPU. Both extremes are unrealistic in real applications; however,
    it's quite easy to visualize the domains where they tend to have one of these.
    For example, domains that involve heavy mathematical processing (scientific models,
    vector graphics such as flash animations in a web browser, matrix multiplication,
    and so on), (un)compression utilities, multimedia codecs, and so on will certainly
    tend to be more CPU-bound. On the other hand, many (but not all) applications
    that us humans interact with on a daily basis (think of your email client, web
    browser, word processing, and so on) tend to wait for the human to do something;
    in effect, they tend to be I/O-bound.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一个100%的CPU绑定线程将不断地在CPU上运行；一个100%的I/O绑定线程是一个总是处于阻塞（或等待）状态的线程，从不在CPU上执行。这两个极端在真实应用中都是不现实的；然而，很容易想象出它们倾向于出现的领域。例如，涉及大量数学处理（科学模型，矢量图形，如Web浏览器中的Flash动画，矩阵乘法等），（解）压缩实用程序，多媒体编解码器等领域肯定倾向于更多地受CPU限制。另一方面，我们人类每天与之交互的许多（但不是所有）应用程序（想想你的电子邮件客户端，Web浏览器，文字处理等）倾向于等待人类做一些事情；实际上，它们倾向于受I/O限制。
- en: 'Therefore—a bit simplistically, but nevertheless—this serves as a useful design
    rule of thumb: if the application being designed is I/O-bound in nature, then
    creating even a large-ish number of threads that just wait for work is all right;
    this is because they will be asleep the majority of the time, thus not placing
    any strain on the CPU(s) (of course, create too many threads and they  do strain
    memory.)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管有点简化，但这仍然作为一个有用的设计经验法则：如果正在设计的应用程序在性质上受到I/O限制，那么创建甚至是大量等待工作的线程是可以的；这是因为它们大部分时间都会处于休眠状态，因此不会对CPU造成任何压力（当然，创建太多线程会对内存造成压力）。
- en: 'On the other hand, if the application is determined to be highly CPU-bound,
    then creating a large number of threads will stress the system (and end up causing
    thrashing – a phenomenon wherein the meta-work takes longer than the actual work!).
    Thus, for CPU-bound workloads, the thumb rule is this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果应用程序被确定为高度CPU限制，那么创建大量线程将会给系统带来压力（最终导致抖动-一种现象，其中元工作的时间比实际工作的时间更长！）。因此，对于CPU限制的工作负载，经验法则是：
- en: '[PRE30]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note, though, that there do exist CPU cores that do not provide any **hyperthreading**
    (**HT**) features; on cores like this, factor should just remain 1.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 但需要注意的是，确实存在一些CPU核心不提供任何**超线程**（**HT**）功能；在这样的核心上，因子应该保持为1。
- en: 'Actually, our discussion has been quite simplistic: many real-world applications
    (think of powerful web servers such as Apache and NGINX) will dynamically create
    and adjust the number of threads required based on the exact circumstances, configuration
    presets, and present workload. Nevertheless, the preceding discussion serves as
    a starting point so that you can start thinking about design for multithreaded
    applications.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们的讨论相当简单：许多现实世界的应用程序（想想像Apache和NGINX这样的强大的Web服务器）将根据确切的情况、配置预设和当前工作负载动态地创建和调整所需的线程数量。然而，前面的讨论作为一个起点，让你开始思考多线程应用程序的设计。
- en: Thread attributes
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程属性
- en: In our initial discussion on *Thread Creation* earlier in this chapter, we saw
    the `pthread_create(3)` API; the second parameter is a pointer to the thread attribute structure: `const
    pthread_attr_t *attr`. We mentioned there that passing NULL here, in effect, has
    the library create a thread with default attributes. While that is indeed the
    case, the problem is that, for truly portable applications, this is not good enough.
    Why? Because the default thread attributes actually differ quite widely from implementation
    to implementation. The right way-specify the thread attributes explicitly at thread
    creation time.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章早期的*线程创建*讨论中，我们看到了`pthread_create(3)`API；第二个参数是指向线程属性结构的指针：`const pthread_attr_t
    *attr`。我们提到过，在这里传递NULL，实际上是让库使用默认属性创建线程。虽然这确实是这样，但问题在于，对于真正可移植的应用程序，这是不够的。为什么？因为默认线程属性在不同的实现中实际上有很大的差异。正确的方法是在线程创建时显式指定线程属性。
- en: 'Firstly, of course, we need to learn what attributes a pthread has. The following
    table enumerates this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当然，我们需要了解pthread具有哪些属性。以下表格列举了这些属性：
- en: '| **Attribute** | **Meaning** | **APIs: **`pthread_attr_[...](3)` | **Values
    Possible** | ***Linux Default*** |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **含义** | **APIs: **`pthread_attr_[...](3)` | **可能的值** | ***Linux默认***
    |'
- en: '| Detach state | Create threads as joinable or detached | `pthread_attr_` `[get&#124;set]detachstate`
    | PTHREAD_CREATE_JOINABLE PTHREAD_CREATE_DETACHED | PTHREAD_CREATE_JOINABLE |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 分离状态 | 创建可连接或分离的线程 | `pthread_attr_` `[get&#124;set]detachstate` | PTHREAD_CREATE_JOINABLE
    PTHREAD_CREATE_DETACHED | PTHREAD_CREATE_JOINABLE |'
- en: '| Scheduling/contention scope | Set of threads against which we compete for
    resources (CPU) | `pthread_attr_``[get&#124;set]scope` | PTHREAD_SCOPE_SYSTEM
    PTHREAD_SCOPE_PROCESS | PTHREAD_SCOPE_SYSTEM |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 调度/争用范围 | 我们与之竞争资源（CPU）的线程集 | `pthread_attr_``[get&#124;set]scope` | PTHREAD_SCOPE_SYSTEM
    PTHREAD_SCOPE_PROCESS | PTHREAD_SCOPE_SYSTEM |'
- en: '| Scheduling/inheritance | Determines whether scheduling attributes are inherited
    implicitly from calling a thread or explicitly from the attr structure | `pthread_attr_``[get&#124;set]inheritsched`
    | PTHREAD_INHERIT_SCHED PTHREAD_EXPLICIT_SCHED | PTHREAD_INHERIT_SCHED |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 调度/继承 | 确定调度属性是从调用线程隐式继承还是从attr结构显式继承 | `pthread_attr_``[get&#124;set]inheritsched`
    | PTHREAD_INHERIT_SCHED PTHREAD_EXPLICIT_SCHED | PTHREAD_INHERIT_SCHED |'
- en: '| Scheduling/policy | Determines the scheduling policy of the thread being
    created | `pthread_attr_``[get&#124;set]schedpolicy` | SCHED_FIFO SCHED_RR'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '| 调度/策略 | 确定正在创建的线程的调度策略 | `pthread_attr_``[get&#124;set]schedpolicy` | SCHED_FIFO
    SCHED_RR'
- en: SCHED_OTHER | SCHED_OTHER |
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: SCHED_OTHER | SCHED_OTHER |
- en: '| Scheduling/priority | Determines the scheduling priority of the thread being created
    | `pthread_attr_``[get&#124;set]schedparam` | struct sched_param holds    int
    sched_priority | 0 (non real-time) |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 调度/优先级 | 确定正在创建的线程的调度优先级 | `pthread_attr_``[get&#124;set]schedparam` | 结构sched_param 保存 
      int sched_priority | 0（非实时） |'
- en: '| Stack/guard region | A guard region for the thread''s stack | `pthread_attr_``[get&#124;set]guardsize`
    | Stack guard region size in bytes | 1 page |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 栈/保护区域 | 线程栈的保护区域 | `pthread_attr_``[get&#124;set]guardsize` | 字节中的栈保护区域大小
    | 1页 |'
- en: '| Stack/location, size | Query or set the thread''s stack location and size
    | `pthread_attr_` `[get&#124;set]stack``pthread_attr_`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '| 栈/位置，大小 | 查询或设置线程的栈位置和大小 | `pthread_attr_` `[get&#124;set]stack``pthread_attr_`'
- en: '`[get&#124;set]stackaddr``pthread_attr_`'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`[get&#124;set]stackaddr``pthread_attr_`'
- en: '`[get&#124;set]stacksize` | Stack address and/or stack size, in bytes | Thread
    Stack Location: left to the OSThread Stack Size: 8 MB |'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`[get&#124;set]stacksize` | 字节中的栈地址和/或栈大小 | 线程栈位置：左到OSThread栈大小：8 MB |'
- en: As you can see, clearly understanding what exactly many of these attributes
    signify requires further information. Please be patient as we proceed through
    this chapter (and, in fact, this book), as several of these attributes and their
    meanings will become abundantly clear ( details on scheduling will be shown in
    [Chapter 17](36229bac-c402-4d2f-b876-d1eb4aba8051.xhtml), *CPU Scheduling on Linux*).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '正如您所看到的，要清楚地理解这些属性的确切含义需要进一步的信息。请耐心等待我们在本章（实际上是本书）中继续进行，因为其中的一些属性及其含义将变得非常清楚（调度的详细信息将在[第17章](36229bac-c402-4d2f-b876-d1eb4aba8051.xhtml)中显示，*Linux上的CPU调度*）。 '
- en: Code example – querying the default thread attributes
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例 - 查询默认线程属性
- en: 'For now, a useful experiment would be to query the default attributes of a
    newly born thread whose attribute structure is specified as NULL (default). How? `pthread_default_getattr_np(3)` will
    do the trick (note though, that again, the `_np` suffix implies that it''s a Linux-only,
    non-portable API):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个有用的实验是查询新创建线程的默认属性，其属性结构指定为NULL（默认）。如何？`pthread_default_getattr_np(3)`将起作用（请注意，再次，`_np`后缀意味着它是一个仅限Linux的非可移植API）：
- en: '[PRE31]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Interestingly, as this function depends on the `_GNU_SOURCE` macro being defined,
    we must first define the macro (early in the source); otherwise, the compile triggers
    warnings and possibly fails. (In our code, we thus use `#include "../common.h"`
    first as our *common.h *header defines the `_GNU_SOURCE` macro.)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，由于此函数依赖于定义`_GNU_SOURCE`宏，因此我们必须首先定义该宏（在源代码中的早期）；否则，编译会触发警告并可能失败。（在我们的代码中，我们首先使用`#include
    "../common.h"`，因为我们的*common.h*头文件定义了`_GNU_SOURCE`宏。）
- en: 'Our code example can be found here, within this book''s GitHub repository:
    `ch14/disp_defattr_pthread.c` *. *'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码示例可以在这里找到，位于本书的GitHub存储库中：`ch14/disp_defattr_pthread.c` *。*
- en: 'In the following code, we display a trial run on a Fedora x86_64 box running
    the 4.17.12 Linux kernel:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们在运行4.17.12 Linux内核的Fedora x86_64箱上进行了试验：
- en: '[PRE32]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For readability, only key parts of the source code are displayed; to view the
    complete source code, build and run it, the entire tree is available for cloning
    from GitHub here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，只显示了源代码的关键部分；要查看完整的源代码，构建并运行它，整个树都可以从GitHub克隆到这里：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: 'The key function here is shown in the following code (`ch14/disp_defattr_pthread.c`);
    we first query and display the thread attribute structure''s "detached state"
    (these terms will be explained in detail shortly):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键函数显示在以下代码中（`ch14/disp_defattr_pthread.c`）；我们首先查询和显示线程属性结构的“分离状态”（这些术语将很快详细解释）：
- en: '[PRE33]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, various scheduling attributes are queried and displayed (some details
    covered later  in [Chapter 17](36229bac-c402-4d2f-b876-d1eb4aba8051.xhtml), *CPU
    Scheduling on Linux*):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将查询和显示各种调度属性（一些细节稍后在[第17章](36229bac-c402-4d2f-b876-d1eb4aba8051.xhtml)中讨论，*Linux上的CPU调度*）：
- en: '[PRE34]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, the thread stack attributes are queried and displayed:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，线程栈属性被查询和显示：
- en: '[PRE35]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, we put in the `pthread_getattr_default_np(3)` API to
    query the default thread attributes. Its counterpart, the` pthread_setattr_default_np(3)`
    API, allows you to specify what exactly the default thread attributes should be when
    creating a thread, and the second parameter to `pthread_create(3)` is passed as
    NULL. Do see its man page for details.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`pthread_getattr_default_np(3)` API来查询默认线程属性。它的对应物，`pthread_setattr_default_np(3)`
    API，允许您在创建线程时指定默认线程属性应该是什么，并且将第二个参数传递给`pthread_create(3)`。请参阅其手册以获取详细信息。
- en: 'There is an alternate way to write a similar program: why not create a thread
    with a NULL attribute structure—thus making it default attributes—and then issue
    the `pthread_getattr_np(3)` API to query and display the actual thread attributes?
    We leave this as an exercise to the reader (in fact, the man page on `pthread_attr_init(3)` supplies
    just such a program).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种编写类似程序的替代方法：为什么不创建一个带有NULL属性结构的线程，从而使其成为默认属性，然后使用`pthread_getattr_np(3)`
    API来查询和显示实际的线程属性？我们把这留给读者作为一个练习（事实上，`pthread_attr_init(3)`的man页面提供了这样一个程序）。
- en: Joining
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接
- en: Imagine an application where a thread (typically, main) has spawned off several
    other worker threads. Each worker thread has a specific job to do; once done,
    it terminates (via `pthread_exit(3)`). How will the creator thread know when a
    worker thread is done (terminated)? Ah, that is precisely where joining comes
    in. With the join, the creator thread can wait for, or block upon, the death (termination)
    of another thread within the process!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个应用程序，其中一个线程（通常是`main`）产生了几个其他工作线程。每个工作线程都有特定的工作要做；一旦完成，它就会终止（通过`pthread_exit(3)`）。创建线程如何知道工作线程何时完成（终止）？啊，这正是连接的作用。通过连接，创建线程可以等待另一个线程在进程内终止。
- en: Does this not sound very much like the `wait(2)` system call that a parent process
    issues to wait for the death of a child? True, but as we shall see shortly, it's
    certainly not identical.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是听起来非常像父进程发出的`wait(2)`系统调用等待子进程死亡吗？是的，但正如我们马上会看到的那样，它肯定不是完全相同的。
- en: 'Also, importantly, the return value from the thread that terminated is passed
    along to the thread that issued the join upon it. This way, it comes to know whether
    the worker succeeded in its task or not (and if not, the failure value can be
    examined to pinpoint the cause of failure):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是，终止的线程的返回值被传递给发出对其的连接的线程。这样，它就知道工作线程是否成功完成了它的任务（如果没有，失败的值可以被检查以找出失败的原因）：
- en: '[PRE36]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The first parameter to `pthread_join(3)`, `thread,` is the ID of the thread
    to wait for. The moment it terminates, the calling thread will receive, in the
    second parameter (yes, it's a value-result style parameter), the return value
    from the thread that terminated—which, of course is the value passed via its `pthread_exit(3)` call.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`pthread_join(3)`的第一个参数`thread`是要等待的线程的ID。它终止时，调用线程将在第二个参数中接收到终止的线程的返回值（是的，这是一个值-结果风格的参数），这当然是通过其`pthread_exit(3)`调用传递的值。'
- en: Thus, the join is very helpful; using this construct, you can ensure that a thread
    can block upon the termination of any given thread. Specifically, in the case
    of the main thread, we often use this mechanism to ensure that main waits for
    all other application threads to terminate before it itself terminates (thus preventing
    the zombie we saw earlier). This is considered the right approach.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，连接非常有帮助；使用这个结构，你可以确保一个线程可以阻塞在任何给定线程的终止上。特别是在`main`线程的情况下，我们经常使用这种机制来确保`main`等待所有其他应用程序线程在它自己终止之前终止（从而防止我们之前看到的僵尸）。这被认为是正确的方法。
- en: 'Recall that in the earlier section, *The return of the ghost*, we clearly saw
    how the main thread, dying before its counterparts, becomes an inadvertent zombie
    (the `ch14/pthreads3.c` program). A quick example, built upon this previous code,
    will help clarify things. So, let''s enhance that program – we shall now call
    it `ch14/pthreads_joiner1.c` – so that we have the main thread wait for all other
    threads to die by invoking the `pthread_join(3)` API on each of the worker threads,
    and only then itself terminate:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在前面的部分，“幽灵的回归”中，我们清楚地看到了`main`线程在其对应线程之前死亡，成为了一个无意识的僵尸（`ch14/pthreads3.c`程序）。建立在这个先前代码的快速示例将有助于澄清事情。所以，让我们增强那个程序
    - 现在我们将它称为`ch14/pthreads_joiner1.c` - 以便我们的`main`线程通过调用`pthread_join(3)` API等待所有其他线程死亡，然后自己终止：
- en: '[PRE37]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There are a few things to notice here:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几件事情需要注意：
- en: To perform the join subsequently, we require each thread's ID; hence, we declare
    an array of `pthread_t` (the `tid` variable). Each element will store the corresponding
    thread's ID value.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随后执行连接，我们需要每个线程的ID；因此，我们声明了一个`pthread_t`的数组（`tid`变量）。每个元素将存储相应线程的ID值。
- en: 'Thread attributes:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程属性：
- en: Until now, we have not explicitly initialized and made use of a thread attribute
    structure when creating threads. Here, we rectify this shortcoming. `pthread_attr_init(3)` is
    used to initialize (to defaults) an attribute structure.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们在创建线程时没有明确地初始化和使用线程属性结构。在这里，我们纠正了这个缺点。`pthread_attr_init(3)`用于初始化（为默认值）属性结构。
- en: Furthermore, we explicitly make the threads joinable by setting up this attribute
    within the structure (via the `pthread_attr_setdetachstate(3)` API).
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们通过在结构中设置这个属性（通过`pthread_attr_setdetachstate(3)` API）来明确地使线程可连接。
- en: Once the threads are created, we must destroy the thread attribute structure
    (via the `pthread_attr_destroy(3)` API).
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦线程被创建，我们必须销毁线程属性结构（通过`pthread_attr_destroy(3)` API）。
- en: It is key to understand that only threads that have their detach state set as
    joinable can be joined upon. Interestingly, a joinable thread can later be set
    to the detached state (by calling the `pthread_detach(3)` API upon it); there
    is no converse routine.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是要理解，只有将其分离状态设置为可连接的线程才能被连接。有趣的是，可连接的线程以后可以被设置为分离状态（通过调用`pthread_detach(3)`
    API）；没有相反的例程。
- en: 'The code continues; we now show you the thread `worker` function:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 代码继续；现在我们向你展示线程`worker`函数：
- en: '[PRE38]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Easy: we just have the so-called worker threads sleep for 8 seconds and then
    die; the `pthread_exit(3)`, this time, passes the return status `0` as a parameter.
    In the following code snippet, we continue the code of main:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 简单：我们让所谓的工作线程睡8秒然后死掉；这次，`pthread_exit(3)`传递`0`作为返回状态。在下面的代码片段中，我们继续`main`的代码：
- en: '[PRE39]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here''s the key part: in a loop, the main thread blocks (waits) upon the death
    of each worker thread via the `pthread_join(3)` API; the second (value-result
    style) parameter, in effect, returns the status of the thread that just terminated.
    The usual zero-upon-success convention is followed, thus allowing the main thread
    to figure out whether the worker threads completed their work successfully or
    not.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关键部分：在循环中，主线程通过`pthread_join(3)`API阻塞（等待）每个工作线程的死亡；第二个（值-结果风格）参数实际上返回刚终止的线程的状态。遵循通常的成功返回零的约定，因此允许主线程判断工作线程是否成功完成工作。
- en: 'Let''s build and run it:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建并运行它：
- en: '[PRE40]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As the worker threads die, they are picked up, or joined, by the main thread
    via `pthread_join`; not only that, their termination status—return value—can be
    examined.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当工作线程死亡时，它们被`main`线程通过`pthread_join`接收或加入；不仅如此，它们的终止状态-返回值-可以被检查。
- en: Okay, we'll make a copy of the preceding program and call it `ch14/pthreads_joiner2.c`.
    The only change we make is instead of having each worker thread sleep for an identical
    8 seconds, we'll make the sleep time dynamic. We will change the code; for instance,
    this line would be changed:`sleep(slptm);`
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们将复制前面的程序并将其命名为`ch14/pthreads_joiner2.c`。我们唯一的改变是，不是让每个工作线程睡眠相同的8秒，而是让睡眠时间动态变化。我们将更改代码；例如，这一行将被更改为：`sleep(slptm);`
- en: The new line would read as follows: `sleep(slptm-datum);`
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 新的一行将如下所示：`sleep(slptm-datum);`
- en: 'Here, `datum` is the value passed to the thread—the loop index. This way, we
    find that the worker threads sleep as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`datum`是传递给线程的值-循环索引。这样，我们发现工作线程的睡眠如下：
- en: 'Worker thread #0 sleeps for (8-0) = 8 seconds'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作线程＃0睡眠（8-0）= 8秒
- en: 'Worker thread #1 sleeps for (8-1) = 7 seconds'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作线程＃1睡眠（8-1）= 7秒
- en: 'Worker thread #2 sleeps for (8-2) = 6 seconds'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作线程＃2睡眠（8-2）= 6秒
- en: 'Obviously, worker thread #2 will terminate first; so what? Well, think about
    it: in the meantime, the main thread is looping around `pthread_join`, but in
    the order of thread #0, thread #1, thread #2. Now, thread #0 will die last and thread
    #2 will die first. Will this be an issue?'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，工作线程＃2将首先终止；那又怎样？嗯，想想看：与此同时，`main`线程正在循环`pthread_join`，但是按照线程＃0，线程＃1，线程＃2的顺序。现在，线程＃0将最后死亡，线程＃2将首先死亡。这会有问题吗？
- en: 'Let''s try it out and see:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '[PRE41]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'What do we notice? In spite of worker thread #2 dying first, worker thread
    #0 gets joined first because, in the code, that is the thread we wait for first!'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到什么？尽管工作线程＃2首先死亡，但工作线程＃0首先加入，因为在代码中，这是我们首先等待的线程！
- en: The thread model join and the process model wait
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程模型加入和进程模型等待
- en: 'By now, you should have begun to realize that although the `pthread_join(3)` and `wait(2)` (and
    family) APIs seem to be very similar, they are certainly not equivalent; several
    differences between them exist and are enumerated in the following table:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经开始意识到，尽管`pthread_join(3)`和`wait(2)`（以及家族）API似乎非常相似，但它们肯定不是等价的；它们之间存在几个差异，并在以下表中列举出来：
- en: '| **Situation** | **Thread : `pthread_join(3)`** | **Process: `wait[pid](2)`**
    |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| **情况** | **线程：`pthread_join(3)`** | **进程：`wait[pid](2)`** |'
- en: '| Condition | A thread being waited for must have its detached state attribute
    set as joinable, not detached. | None; any child process can (and in fact must)
    be waited upon (recall our *fork rule #7*) |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 条件 | 等待的线程必须将其分离状态属性设置为可连接的，而不是分离的。 | 无；任何子进程都可以（实际上必须）等待（回想一下我们的*fork规则＃7*）|'
- en: '| Hierarchy | None: any thread can join on any other thread; there is no requirement
    of a parent-child relationship. In fact, we do not consider threads to live within
    a strict parent-child hierarchy as processes do; all threads are peers. | A strict parent-child
    hierarchy exists; only a parent can wait for a child process. |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 层次结构 | 无：任何线程都可以加入任何其他线程；没有父子关系的要求。实际上，我们不认为线程像进程那样严格存在父子关系；所有线程都是对等的。 |
    存在严格的父子关系层次结构；只有父进程可以等待子进程。|'
- en: '| Order | With threads, one is forced to join (wait) upon the particular thread
    specified as the parameter to `pthread_join(3)`. In other words, if there are,
    say, three threads running and main issues the join within an ascending ordered
    loop, then it must wait for the death or thread #1, then thread #2, and then thread
    #3\. If thread #2 terminates earlier, there is no help for it. | With wait, a
    process can wait upon the death (or stoppage) of any child, or specify a particular
    child process to wait for with waitpid. |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 顺序 | 使用线程时，必须强制加入（等待）指定为`pthread_join(3)`参数的特定线程。换句话说，如果有，比如说，三个线程在运行，主线程在一个升序循环中发出加入，那么它必须等待线程＃1的死亡，然后是线程＃2，然后是线程＃3。如果线程＃2提前终止，那就没办法了。
    | 使用`wait`，进程可以等待（或停止）任何子进程的死亡，或者使用`waitpid`指定等待的特定子进程。|'
- en: '| Signaling | No signal is sent upon a thread''s death. | Upon a process''s
    death, the kernel sends the `SIGCHLD` signal to the parent process. |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 信号 | 在线程死亡时不发送信号。 | 在进程死亡时，内核向父进程发送`SIGCHLD`信号。|'
- en: 'A few other points to note regarding `pthread_join(3)` are as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`pthread_join(3)`的另外一些要点如下：
- en: You require the thread ID of a thread in order to join upon it; this is deliberately
    done so that we can, in effect, only join the threads of our application process.
    Attempting to join on other threads (like a third-party library thread) would
    be poor design.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要线程的线程ID才能加入它；这是故意这样做的，以便我们实际上只加入我们应用程序进程的线程。尝试加入其他线程（比如第三方库线程）将是糟糕的设计。
- en: What if the thread we are waiting for (to die) has already died? Then `pthread_join(3)` just
    returns immediately.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们正在等待的线程（已经死亡）已经死亡了怎么办？然后`pthread_join(3)`立即返回。
- en: What if a thread tries to join upon itself? This results in failure (with `errno` set
    to `EDEADLK`).
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个线程试图加入自己会怎样？这会导致失败（`errno`设置为`EDEADLK`）。
- en: Attempting to have several threads join upon one thread results in undefined
    behavior; avoid this.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 试图让几个线程加入一个线程会导致未定义的行为；要避免这种情况。
- en: If a thread attempting to join on another thread is cancelled (covered later),
    the target thread remains as it was (joinable).
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个试图连接到另一个线程的线程被取消（稍后会讨论），目标线程保持原样（可连接）。
- en: Checking for life, timing out
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查生命，超时
- en: 'Sometimes, we might have a situation wherein we want to check whether a particular
    thread is still alive or not; one way to do so is via the `pthread_tryjoin_np(3)` API:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能会遇到这样的情况，我们想要检查特定线程是否仍然存活；通过`pthread_tryjoin_np(3)` API就可以做到这一点：
- en: '[PRE42]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first parameter to `pthread_tryjoin_np(3)` is the thread we are attempting
    to join to; (the second parameter, as usual, is the target thread's termination
    status). Notice the try phrase within the API – this typically specifies that
    the call is non-blocking; in other words, we perform a non-blocking join on the
    target thread. If the target thread is alive, then instead of waiting for it to
    die, the API returns immediately with an error: `errno` will be set to `EBUSY` (and
    the man page tells us that this implies the thread had not yet terminated at the
    time of the call).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`pthread_tryjoin_np(3)`的第一个参数是我们要连接的线程；（第二个参数和往常一样，是目标线程的终止状态）。注意API中的try短语
    - 这通常指定调用是非阻塞的；换句话说，我们对目标线程执行非阻塞连接。如果目标线程仍然存活，那么API将立即返回错误：`errno`将被设置为`EBUSY`（手册页告诉我们，这意味着在调用时线程尚未终止）。'
- en: What if we would like to wait (block) upon a target thread's death, but not
    forever? In other words, we would like to wait for a given maximum time period.
    This can be achieved via the `pthread_timedjoin_np(3)` API; the first two parameters
    are the usual ones (the same as with `pthread_join)`, while the third parameter
    specifies the timeout in terms of the absolute time (or what is often called Unix
    time – the number of seconds (and nanoseconds) elapsed since midnight 1 January
    1970—the Epoch!).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要等待（阻塞）直到目标线程死亡，但不是永远？换句话说，我们想要等待一段给定的最长时间。这可以通过`pthread_timedjoin_np(3)`
    API实现；前两个参数与`pthread_join`相同，而第三个参数指定了绝对时间的超时（通常称为Unix时间 - 自1970年1月1日午夜以来经过的秒数（和纳秒数）
    - 纪元！）。
- en: 'As covered in [Chapter 13](1f621f72-e067-42db-b2eb-b82e20161dec.xhtml), *Timers*, the `timespec` data
    structure is of the following format:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第13章](1f621f72-e067-42db-b2eb-b82e20161dec.xhtml)所述，*定时器*，`timespec`数据结构的格式如下：
- en: '[PRE43]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: That's easy; but how do we specify the time as UNIX time (or time since the
    Epoch)? We refer the reader to the man page on `pthread_timedjoin_np(3)`, which
    gives a simple example of the same (also, we ask you try this API out as an exercise).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单；但是我们如何将时间指定为UNIX时间（或自纪元以来的时间）？我们建议读者参考`pthread_timedjoin_np(3)`的手册页，其中提供了一个简单的示例（同时，我们建议您尝试这个API作为练习）。
- en: Another thing I noticed when using the `pthread_timedjoin_np(3)` API: it's possible
    that the join times out and then proceeds to, say, release some resources – like
    performing `free(3)` on a heap buffer—while the worker thread is still alive and
    using it. This is a bug, of course; it also goes to show that you must carefully
    think out and test the design; usually, using a blocking join on all worker threads,
    thus ensuring they have all terminated before freeing up resources, is the right
    approach.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`pthread_timedjoin_np(3)` API时，我注意到另一件事：连接可能超时，然后继续释放一些资源，比如在工作线程仍然存活并使用它时执行`free(3)`在堆缓冲区上。这显然是一个错误；这也表明你必须仔细考虑和测试设计；通常，对所有工作线程执行阻塞连接，从而确保它们在释放资源之前已经全部终止，是正确的方法。
- en: Again, we remind you that the `_np` suffix to the APIs implies that they are non-portable
    (Linux-only).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒您，API的后缀`_np`表示它们是不可移植的（仅限Linux）。
- en: Join or not?
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接还是不连接？
- en: A thread that is explicitly set to the detached state cannot be joined upon;
    so, what happens when it dies? Its resources are disposed of by the library.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明确设置为分离状态的线程不能被连接；那么当它死亡时会发生什么？它的资源将被库处理。
- en: 'A thread that is explicitly set to the joinable state (or if joinable is the
    default state) must be joined upon; failure to do so results in a kind of resource
    leakage. So, be careful: if you have created threads to be joinable, then you
    must ensure that the join is performed.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明确设置为可连接状态的线程（或者可连接是默认状态）必须被连接；否则会导致一种资源泄漏。所以要小心：如果你已经创建了可连接的线程，那么你必须确保连接已经完成。
- en: Performing a join on other app threads by the main thread is usually considered
    a best practice, since it prevents the zombie thread behavior we saw earlier.
    Also, it's usually important for the creator thread to come to know whether its
    workers successfully performed their job or not, and if not, why not. The join
    makes all of this possible.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 通常认为，通过主线程对其他应用程序线程执行连接是最佳实践，因为这可以防止我们之前看到的僵尸线程行为。此外，对于创建线程来说，了解它的工作线程是否成功执行了任务，如果没有，原因是什么通常是很重要的。连接使所有这些成为可能。
- en: However, it is possible that your application does not want to wait around for
    some worker threads; in this case, ensure that you create them as detached.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能你的应用程序不想等待一些工作线程；在这种情况下，请确保将它们创建为分离状态。
- en: Parameter passing
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数传递
- en: 'Recall the signature of the `pthread_create(3)` API:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下`pthread_create(3)` API的签名：
- en: '`int pthread_create(pthread_t *thread, const pthread_attr_t *attr,`'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`int pthread_create(pthread_t *thread, const pthread_attr_t *attr,`'
- en: '`                    void *(*start_routine) **(void *), void *arg**);`'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`                    void *(*start_routine) **(void *), void *arg**);`'
- en: 'The third parameter is the thread function—in effect, the life and scope of
    the newly born thread. It receives a single parameter of type `void *`; this parameter
    to the new born thread is passed via the fourth parameter to `pthread_create`:
    `void *arg`.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是线程函数 - 实际上是新生线程的生命和范围。它接收一个类型为`void *`的参数；这个参数传递给新生线程的是通过第四个参数`pthread_create`传递的：`void
    *arg`。
- en: 'As mentioned earlier, its data type is a generic pointer, precisely so that
    we can, in effect, pass along any data type as a parameter, and then in the thread
    routine, appropriately typecast and use it. Until now, we have come across simple
    use cases of the same – typically, passing along an integer value as the parameter.
    In our very first simple multithreaded app – `ch14/pthreads1.c` – in our main function, we
    did the following:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，它的数据类型是一个通用指针，这样我们就可以实际上将任何数据类型作为参数传递，然后在线程例程中适当地进行类型转换和使用。到目前为止，我们已经遇到了相同的简单用例
    - 通常是将整数值作为参数传递。在我们的第一个简单的多线程应用程序`ch14/pthreads1.c`中，在我们的`main`函数中，我们做了以下操作：
- en: '[PRE44]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And, in the thread routine worker, we performed a simple typecast-and-use:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 而在线程例程`worker`中，我们进行了简单的类型转换和使用：
- en: '[PRE45]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'That''s easy, but it does raise a fairly obvious question: in the `pthread_create(3)` API, as
    there seems to be just one placeholder for the `arg` (the parameter) how can you
    pass along more than one data item – several parameters, in effect – to the thread
    routine?'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但确实引发了一个非常明显的问题：在`pthread_create(3)` API中，似乎只有一个占位符用于`arg`（参数），如何传递多个数据项
    - 实际上是几个参数 - 给线程例程？
- en: Passing a structure as a parameter
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将结构作为参数传递
- en: 'The preceding heading gives it away: we pass a data structure. But how, exactly?
    Allocate memory to a pointer to the data structure, initialize it, and pass the
    pointer typecast as `void *`. (In fact, this is a very common approach that C
    programmers use.) In the thread routine, as usual, typecast and use it.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的标题揭示了答案：我们传递一个数据结构。但是，具体来说呢？为数据结构的指针分配内存，初始化它，并将指针强制转换为`void *`进行传递。（事实上，这是C程序员常用的方法。）在线程例程中，像往常一样，进行类型转换并使用它。
- en: 'To bring clarity, we will try this out ( `ch14/param_passing/struct_as_param.c`):'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清，我们将尝试这个（`ch14/param_passing/struct_as_param.c`）：
- en: For readability, only key parts of the source code are displayed; to view the
    complete source code, build, and run it, the entire tree is available for cloning
    from GitHub here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)*.*
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，只显示了源代码的关键部分；要查看完整的源代码，构建并运行它，整个树可以在GitHub上克隆：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)*.*
- en: '[PRE46]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As an example, we build our very own airport info data structure, airport, and then
    set up an array (`city_airports`), initializing a few members of it.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们构建了自己的机场信息数据结构airport，然后设置了一个数组（`city_airports`），初始化了其中的一些成员。
- en: 'In the main function, we declare an array of pointers to the airport structure;
    we know that a pointer by itself has no memory, so in the thread creation loop,
    we allocate memory to each pointer and then initialize it to an airport (via a
    simple `memcpy(3)`):'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们声明了一个指向机场结构的指针数组；我们知道单独的指针没有内存，所以在线程创建循环中，我们为每个指针分配内存，然后将其初始化为一个机场（通过简单的`memcpy(3)`）：
- en: '[PRE47]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Okay, so we already know that the preceding code is not really optimal; we could
    have just passed the `city_airports[i]` structure pointer as the parameter to
    the thread. For the sake of a pedantic example, making use of our just allocated
    `plocdata[i]` structures, we `memcpy` one structure into another.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们已经知道前面的代码并不是真正的最佳选择；我们本可以只将`city_airports[i]`结构指针作为线程的参数传递。为了举例说明，我们使用刚刚分配的`plocdata[i]`结构，将一个结构`memcpy`到另一个结构中。
- en: 'Then, in the `pthread_create(3)` call, we pass the pointer to our data structure
    as the fourth parameter.  This will become the argument to the thread; in the
    thread routine, we declare an `arg` pointer of the same data type and equate it
    to the typecast data pointer we receive:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`pthread_create(3)`调用中，我们将指向我们数据结构的指针作为第四个参数传递。这将成为线程的参数；在线程例程中，我们声明一个相同数据类型的`arg`指针，并将其等同于我们接收到的类型转换数据指针：
- en: '[PRE48]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We can then proceed to use `arg` as a pointer to Airport; in the preceding demo
    code, we merely print out the values in the structure. We encourage the reader
    to build and run this code.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将`arg`用作指向Airport的指针；在前面的演示代码中，我们只是打印了结构中的值。我们鼓励读者构建并运行此代码。
- en: Did you notice the `%.*s` C printf format specifier trick in the preceding code?
    This is done when we want to print a string that is not necessarily NULL-terminated;
    the `%.*s` format specifier allows one to specify the size followed by the string
    pointer. The string will be printed to only size bytes.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你注意到了`%.*s` C printf格式说明符的技巧吗？当我们想要打印一个不一定以NULL结尾的字符串时，`%.*s`格式说明符允许我们指定大小，然后是字符串指针。字符串将只打印大小字节。
- en: Thread parameters – what not to do
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程参数 - 不要这样做
- en: The really key thing to keep in mind when passing a parameter to a thread routine
    is that you must guarantee that the parameter passed along is thread-safe; essentially,
    that it does not get modified in any manner while a thread (or threads) are using
    it.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数传递给线程例程时要牢记的关键事情是，必须保证传递的参数是线程安全的；基本上，在线程（或线程）使用它时不会以任何方式进行修改。
- en: (Thread safety is a crucial aspect of working with threads; we shall revisit
    this point often in upcoming chapters, too).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: （线程安全是处理线程的一个关键方面；在接下来的章节中，我们将经常回顾这一点）。
- en: 'To help understand the possible issues clearly, let''s take a couple of typical
    examples. In the first one, we shall (attempt to) pass the loop index as the parameter
    to the newly born thread such as, in main (code: `ch14/pthreads1_wrong.c`):'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地理解可能的问题，让我们举几个典型的例子。在第一个例子中，我们将尝试将循环索引作为参数传递给新创建的线程，比如在主函数中（代码：`ch14/pthreads1_wrong.c`）：
- en: '[PRE49]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Did you notice!? We have passed the parameter as `&i`. So? Dereferencing it
    correctly in the thread routine should still work, right:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了吗？我们将参数传递为`&i`。那么？在线程例程中正确解引用它应该仍然有效，对吧：
- en: '[PRE50]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Looks okay – let's give it a try!
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错 - 让我们试试看！
- en: '[PRE51]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Well, it works. But hang on, try it a few more times—timing coincidences can
    fool you into thinking that all''s well when it''s really not:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，它有效。但等等，再试几次 - 时间巧合可能会让你误以为一切都很好，但实际上并非如此：
- en: '[PRE52]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'There''s a bug! The index value has evaluated to the value 2 twice; why? Think
    carefully: we have passed the loop index by reference – as the pointer to the
    loop variable. Thread 1 comes alive, and looks up its value – so does thread 2,
    as does thread 3\. But wait: isn''t it possible that we have a race here? Isn''t
    it possible that by the time thread 1 runs and looks up the value of the loop
    variable it has already changed underneath it (because, don''t forget, the loop
    is running in main)? That, of course, is precisely what happened in the preceding
    code.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个错误！`index`的值已经两次评估为值`2`；为什么？仔细思考：我们已经通过引用将循环索引传递了 - 作为循环变量的指针。线程1启动，并查找其值
    - 线程2也是如此，线程3也是如此。但等等：这里难道不可能存在竞争吗？难道不可能在线程1运行并查找循环变量的值时，它已经在其下发生了变化（因为，不要忘记，循环是在主线程中运行的）？当然，这正是在前面的代码中发生的。
- en: In other words, passing the variable by address is unsafe because its value
    could change while it is being read (by the worker threads) as it being simultaneously
    written to (by main); hence, it's not thread-safe and therefore will be buggy
    (racy).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，通过地址传递变量是不安全的，因为在它被读取（由工作线程）的同时被写入（由主线程）时，其值可能会发生变化；因此，它不是线程安全的，因此会出现错误（竞争）。
- en: 'The solution is actually really simple: do not pass the loop index by address;
    just pass it as a literal value:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案实际上非常简单：不要通过地址传递循环索引；只需将其作为文字值传递：
- en: '[PRE53]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, each worker thread receives a copy of the loop index, thus eliminating
    any race, thus making it safe.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个工作线程都收到了循环索引的副本，从而消除了任何竞争，使其安全。
- en: Now, don't jump to the conclusion that, hey, okay, so we should never pass a
    pointer (an address) as a parameter. Of course you can! Just ensure that it's thread-safe
    – that its value cannot change underneath it while being manipulated by main and
    the other application threads.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不要草率地得出结论，嘿，好吧，所以我们永远不应该将指针（地址）作为参数传递。当然可以！只要确保它是线程安全的 - 在主线程和其他应用线程操作它时，它的值不会在其下发生变化。
- en: Refer back to the `ch14/struct_as_param.c` code we demonstrated in the previous
    section; we very much pass the thread parameter as a pointer to a structure. Look
    closely: each pointer was separately allocated (via `calloc(3)`) in the main thread
    creation loop. Thus, each worker thread received its own copy of the structure;
    hence, all is safe and it works well.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 参考我们在上一节演示的`ch14/struct_as_param.c`代码；我们非常明确地将线程参数作为结构体的指针传递。仔细看：在主线程创建循环中，每个指针都是单独分配的（通过`calloc(3)`）。因此，每个工作线程都收到了结构体的副本；因此，一切都是安全的，而且运行良好。
- en: An interesting exercise (that we leave to the reader) is to deliberately insert
    a defect into the `struct_as_param` application by using exactly one allocated
    structure (not three) and passing it to each of the worker threads. This time,
    it will be racy and will (eventually) fail.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的练习（我们留给读者）是故意在`struct_as_param`应用程序中插入一个缺陷，方法是只分配一个结构（而不是三个），并将其传递给每个工作线程。这次，它将是竞争的，并且（最终）会失败。
- en: Thread stacks
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程堆栈
- en: We understand that whenever a thread is created, it acquires a new, freshly
    allocated piece of memory for its stack. This leads to the understanding that
    (obviously, but we shall state it nevertheless) all local variables declared within
    a thread function will remain private to that thread; this is because they will
    reside in that thread's stack. (Refer back to *Fig 2* in this chapter – the new
    stack of the newly created thread is shown in red). Also, whenever a context switch
    occurs, the **Stack Pointer** (**SP**) register is updated to point to the current
    thread's stack.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，每当创建一个线程时，它都会为其堆栈获取一个新的、新分配的内存块。这导致了这样的理解：（显然，但我们还是要说明）在线程函数中声明的所有局部变量都将保持私有，因为它们将驻留在该线程的堆栈中。（参考本章中的*图2*
    - 新创建线程的新堆栈显示为红色）。此外，每当发生上下文切换时，**堆栈指针**（**SP**）寄存器会更新为指向当前线程的堆栈。
- en: Get and set thread stack size
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取和设置线程堆栈大小
- en: Knowing, and being able to change, the size of thread stacks does matter (do
    see the link provided in the *Further reading* section on the GitHub repository,
    which mentions a real-world experience on how setting up a stack that's too small
    for a certain platform caused random and really hard-to-debug failures).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 了解并能够更改线程堆栈的大小很重要（请参阅GitHub存储库中*进一步阅读*部分提供的链接，其中提到了如何设置某个平台的堆栈太小导致了随机且难以调试的故障的真实经验）。
- en: 'So, what is the default thread stack size? The answer has already been provided;
    recall the `disp_defattr_pthread` program we ran earlier in this chapter (in the *Code
    example – querying the default thread attributes* section): it shows us that the
    default thread stack size on the (modern NPTL) Linux platform is 8 MB.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，默认的线程堆栈大小是多少？答案已经提供了；回想一下我们在本章前面运行的`disp_defattr_pthread`程序（在*代码示例 - 查询默认线程属性*部分）：它告诉我们，在（现代NPTL）Linux平台上，默认的线程堆栈大小为8
    MB。
- en: 'The pthreads API set provides a few routines to set and query the thread stack
    size. One way is as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: pthread API集提供了一些例程来设置和查询线程堆栈大小。一种方法如下：
- en: '[PRE54]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As we have already used `pthread_attr_getstacksize(3)` in the earlier `disp_defattr_pthread` program,
    we shall refrain from showing its usage once more over here. Setting the thread
    size is easily done with the complementary `pthread_attr_setstacksize(3)` API
    – the second parameter is the required size (in bytes). Note, though, that both
    of these APIs have the phrase `_attr_` in them, implying that the stack size is
    actually set or queried from the thread attribute structure and not a live thread
    itself. This leads us to understand that we can only set or query the stack size
    at the time of creation of the thread by setting up the attribute structure (which
    is, of course, subsequently passed as the second parameter to `pthread_create(3)`).
    Once a thread is created, its stack size cannot be changed. The exception to this
    rule is the stack of the main thread.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前已经在早期的`disp_defattr_pthread`程序中使用了`pthread_attr_getstacksize(3)`，我们将避免在这里再次展示它的用法。使用互补的`pthread_attr_setstacksize(3)`
    API可以轻松设置线程大小-第二个参数是所需的大小（以字节为单位）。不过，这两个API都包含`_attr_`短语，这意味着栈大小实际上是从线程属性结构中设置或查询的，而不是从活动线程本身。这使我们了解到我们只能在创建线程时通过设置属性结构（当然，随后作为第二个参数传递给`pthread_create(3)`）来设置或查询栈大小。一旦线程被创建，其栈大小就无法更改。这条规则的例外是主线程的栈。
- en: Stack location
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈位置
- en: 'Where in memory (technically, where in the VAS of the given process) does the
    thread stack actually reside? The following points help us in this regard:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 线程栈实际上位于内存中的哪个位置（从技术上讲，给定进程的VAS中的哪个位置）？以下几点有助于我们理解：
- en: The stack of the main thread is always situated at the very top of the process
    VAS.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主线程的栈总是位于进程VAS的顶部。
- en: The stacks of all other threads in the process are located somewhere between
    the process heap segment and the stack of main; the precise location is not known
    in advance to the app developer; in any case, we should not need to know.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程中所有其他线程的栈位于进程堆段和主栈之间的某个位置；这个具体位置对应用程序开发人员来说事先是未知的；无论如何，我们不应该需要知道。
- en: 'This is not directly related, but important: recall from [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml),
    *Virtual Memory*, that, for most processors, the stack(s) conform to the stack-grows-down semantic;
    that is, the direction of growth of the stack segment is toward lower virtual
    addresses.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这与直接相关，但很重要：回想一下[第2章](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml)，“虚拟内存”中提到，对于大多数处理器，栈符合栈向下增长的语义；也就是说，栈段的增长方向是朝着较低的虚拟地址。
- en: 'Though we should not need to, is there a way to specify the location of the
    thread stack? Well, yes, if you insist: the `pthread_attr_[get|set]stack(3)` APIs
    can be used for this purpose, as well as to set and/or query the thread stack''s
    size:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不应该需要，但是有没有一种方法可以指定线程栈的位置？如果你坚持的话，是的：`pthread_attr_[get|set]stack(3)` API可以用于此目的，以及设置和/或查询线程栈的大小：
- en: '[PRE55]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Although you can use `pthread_attr_setstack` to set the stack location, it's
    recommended that this be left to the OS. Also, if you do use it, it's again recommended
    that both the stack location, `stackaddr`, and the stack size, `stacksize`, be
    a multiple of the system page size (and that the location is aligned to a page
    boundary). Aligning the thread stack to a page boundary can be easily achieved
    via the `posix_memalign(3)` API (we have covered example usage of this API in [Chapter
    4](0b4868f7-a8d0-4ced-831f-20af9929de9f.xhtml), *Dynamic Memory Allocation*).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以使用`pthread_attr_setstack`来设置栈位置，但建议将此工作留给操作系统。此外，如果您确实使用它，还建议栈位置`stackaddr`和栈大小`stacksize`都是系统页面大小的倍数（并且位置对齐到页面边界）。通过`posix_memalign(3)`
    API可以轻松实现将线程栈对齐到页面边界（我们已经在[第4章](0b4868f7-a8d0-4ced-831f-20af9929de9f.xhtml)，“动态内存分配”中涵盖了此API的示例用法）。
- en: 'Be careful: if you are specifying the stack location within the thread attribute
    structure, and creating threads in a loop (as is the normal fashion), you must
    ensure that each thread receives a unique stack location (this is often done by
    allocating the stack memory via the aforementioned `posix_memalign(3)` and then
    passing its return value as the stack location). Also, of course, the memory pages
    that will be used for the thread stack(s) must have both read-write permission
    (recall `mprotect(2)` from [Chapter 4](0b4868f7-a8d0-4ced-831f-20af9929de9f.xhtml),
    *Dynamic Memory Allocation*).'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 要小心：如果您在线程属性结构中指定栈位置，并且在循环中创建线程（这是正常的方式），您必须确保每个线程都接收到唯一的栈位置（通常通过通过前述的`posix_memalign(3)`分配栈内存，然后将其返回值作为栈位置传递）。当然，将用于线程栈的内存页面必须具有读写权限（回想一下[第4章](0b4868f7-a8d0-4ced-831f-20af9929de9f.xhtml)，“动态内存分配”中的`mprotect(2)`）。
- en: 'After all is said and done, the mechanics of setting and querying the thread
    stack is straightforward; the really key point is this: (stress) test your application
    to ensure that the provided thread stack memory is sufficient. As we saw in the
    [Chapters 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml),  *Signaling - Part
    I*, overflowing the stack is a serious defect and will cause undefined behavior.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，设置和查询线程栈的机制是直截了当的；真正关键的一点是：（强调）测试您的应用程序，以确保提供的线程栈内存是足够的。正如我们在[第11章](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml)，“信号-第一部分”中看到的，栈溢出是一个严重的缺陷，并将导致未定义的行为。
- en: Stack guards
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈保护
- en: 'This neatly brings us to the next point: is there a way to have the application
    know that stack memory is in danger of being, or rather, has been, overflowed?
    Indeed: stack guards. Guard memory is a region of one or more virtual memory pages
    that has been deliberately placed, and with appropriate permissions, to ensure
    that any attempt to access that memory results in failure (or a warning of some
    sort; for example, a signal handler for `SIGSEGV` could provide just such a semantic
    - with the caveat that once we''ve received the SIGSEGV, we are in an undefined
    state and must terminate; but at least we''ll know and can fix the stack size!):'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好地引出了下一个问题：有没有一种方法可以让应用程序知道堆栈内存处于危险之中，或者说，已经溢出了？确实有：堆栈保护。保护内存是一个或多个虚拟内存页面的区域，它被故意放置，并且具有适当的权限，以确保任何尝试访问该内存都会导致失败（或某种警告；例如，`SIGSEGV`的信号处理程序可以提供这样的语义-但要注意一旦收到SIGSEGV，我们就处于未定义状态，必须终止；但至少我们会知道并且可以修复堆栈大小！）：
- en: '[PRE56]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The guard region is an additional memory region allocated at the end of the
    thread stack for the number of bytes specified. The default (guard) size is the
    system page size. Note, again, that the guard size is an attribute of the thread
    and can thus only be specified at thread creation time (and not later). We will
    run the (code: `ch14/stack_test.c`) app like so:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 保护区是在线程堆栈末尾分配的额外内存区域，其大小为指定的字节数。默认（保护）大小是系统页面大小。再次注意，保护大小是线程的一个属性，因此只能在线程创建时（而不是以后）指定。我们将运行（代码：`ch14/stack_test.c`）这样的应用程序：
- en: '[PRE57]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the preceding code, we specify 2,560 KB (2.5 MB) as the thread stack size.
    Though this is far less than the default (8 MB), it turns out to be enough (for
    x86_64 at least, a quick back-of-the-envelope calculation shows that, for the
    given program parameters, we shall require a minimum of 1,960 KB to be allocated
    for each thread stack).
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将2,560 KB（2.5 MB）指定为线程堆栈大小。尽管这远低于默认值（8 MB），但事实证明足够了（至少对于x86_64来说，一个快速的粗略计算显示，对于给定的程序参数，我们将需要为每个线程堆栈分配至少1,960
    KB）。
- en: 'In the following code, we run it again, but this time specify the thread stack
    size as a mere 256 KB:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们再次运行它，但这次将线程堆栈大小指定为仅256 KB：
- en: '[PRE58]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: And, as expected, it segfaults.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，它导致段错误。
- en: Examining the core dump with GDB will reveal a lot of clues regarding why the
    segfault occurred – including, very importantly, the state of the thread stacks
    (in effect, the stack `backtrace(s)`), at the time of the crash. This, however,
    goes beyond the scope of this book.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GDB检查核心转储将揭示关于为什么发生段错误的许多线索-包括非常重要的线程堆栈的状态（实际上是堆栈`回溯`）在崩溃时。然而，这超出了本书的范围。
- en: We definitely encourage you to learn about using a powerful debugger such as
    GDB (see the *Further reading *section on the GitHub repository as well).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们绝对鼓励您学习使用诸如GDB这样强大的调试器（请参见GitHub存储库上的*进一步阅读*部分）。
- en: 'Also (on our test system at least), the kernel emits a message into the kernel
    log regarding this crash; one way to look up the kernel log messages is via the
    convenience utility `dmesg(1)`. The following output is from an Ubuntu 18.04 box:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 此外（至少在我们的测试系统上），内核会向内核日志中发出有关此崩溃的消息；查找内核日志消息的一种方法是通过方便的实用程序`dmesg(1)`。以下输出来自Ubuntu
    18.04框：
- en: '[PRE59]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The code for the preceding application can be found here: `ch14/stack_test.c`
    :'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 前面应用程序的代码可以在这里找到：`ch14/stack_test.c`：
- en: For readability, only key parts of the source code are displayed; to view the
    complete source code, build it, and run it, the entire tree is available for cloning
    from GitHub here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，只显示了源代码的关键部分；要查看完整的源代码，构建并运行它，整个树都可以从GitHub克隆：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: '[PRE60]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In main, we show the thread stack size attribute being initialized to the parameter
    passed by the user (in KB). The code then goes on to create three worker threads
    and then joins (waits) on them.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`中，我们展示了线程堆栈大小属性被初始化为用户传递的参数（以KB为单位）。然后代码继续创建三个工作线程，然后等待它们。
- en: 'In the thread worker routine, we have only thread #2 performing some actual
    work—you guessed it, stack-intensive work. The code for this is as follows:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程工作例程中，我们只有线程＃2执行一些实际工作-你猜对了，是堆栈密集型工作。这段代码如下：
- en: '[PRE61]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `danger` function, of course, is the one where this dangerous, potentially
    stack-overflowing work is carried out:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`danger`函数，当然，是进行这项危险的、潜在的堆栈溢出工作的函数：'
- en: '[PRE62]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The preceding function uses large amounts of (thread) stack space since we have
    declared a local variable called `heavylocal` – a 2D-array of `NEL*NEL` elements
    (`NEL=500`). On an x86_64 with a long data type occupying 8 bytes, this works
    out to approximately 2 MB of space! Thus, specifying the thread stack size as
    any less than 2 MB should result in a stack overflow (the stack guard memory region
    will in fact detect this) and therefore result in a segmentation violation (or
    segfault); this is precisely what happened (as you can see in our trial run).
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数使用大量（线程）堆栈空间，因为我们声明了一个名为`heavylocal`的本地变量-一个`NEL*NEL`元素（`NEL=500`）的二维数组。在一个占用8字节的x86_64上，这大约相当于2
    MB的空间！因此，将线程堆栈大小指定为小于2 MB的任何值应该导致堆栈溢出（堆栈保护内存区域实际上将检测到这一点），因此导致分段违规（或段错误）；这正是发生的事情（正如您在我们的试运行中所看到的）。
- en: Interestingly, if we merely declare the local variable but do not actually make
    use of it, modern compilers will just optimize the code out; hence, in the code,
    we strive to make some (silly) use of the `heavylocal` variable.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果我们仅声明本地变量但实际上没有使用它，现代编译器将会优化代码；因此，在代码中，我们努力对`heavylocal`变量进行一些（愚蠢的）使用。
- en: 'A few additional points on the stack guard memory region, to round off this
    discussion, are as follows:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 关于堆栈保护内存区域的一些额外要点，以结束本讨论，如下：
- en: If an application has used `pthread_attr_setstack(3)`, it implies that it is
    managing thread stack memory itself, and any guard size attribute will be ignored.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用程序使用了`pthread_attr_setstack(3)`，这意味着它正在自行管理线程堆栈内存，并且任何保护大小属性都将被忽略。
- en: The guard region must be aligned to a page boundary.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护区域必须对齐到页面边界。
- en: If the size of the guard memory region is less than a page, the actual (internal)
    size will be rounded to a page; `pthread_attr_getguardsize(3)` returns the theoretical
    size.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果保护内存区域的大小小于一页，实际（内部）大小将会被舍入到一页；`pthread_attr_getguardsize(3)`返回理论大小。
- en: The man page on `pthread_attr_[get|set]guardsize(3)` does provide additional
    information, including possible glibc bugs within the implementation.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_attr_[get|set]guardsize(3)`的man页面提供了额外信息，包括实现中可能存在的glibc错误。'
- en: Summary
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter forms the first of three on the large topic of writing multithreaded
    applications on the Linux platform. Here, we have covered two key areas: the first
    was in regards to the all-important concepts regarding what exactly is a thread,
    and we contrast it to the process model (which we studied in [Chapter 9](3b2340aa-4ab7-46e3-93c0-7f7c210f834b.xhtml), *Process
    Execution* and [Chapter 10](607ad988-406d-4736-90a4-3a318672ab6e.xhtml), *Process
    Creation*). Why you would prefer a multithreaded design was covered in some detail,
    and included three examples. In this way, the motivation to use a multithreaded
    design approach was being brought out.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于在Linux平台上编写多线程应用程序的三章中的第一章。在这里，我们涵盖了两个关键领域：第一个是关于关于线程的重要概念，我们将其与进程模型进行了对比（我们在第9章*进程执行*和第10章*进程创建*中学习过）。我们详细介绍了为什么你会更喜欢多线程设计，并包括了三个例子。通过这种方式，我们展现了使用多线程设计方法的动机。
- en: The second part of this chapter focused on the actual pthread APIs (and their
    related concepts), how we create a thread—how many can and how many should be
    created was addressed as well. Thread termination basics, thread attributes, passing
    along a parameter to the newly created thread, what is joining and how to perform
    it, and finally, details on how we can manipulate the thread stack (and stack
    guard) size was covered. Many example programs were shown to help solidify the
    concepts that were taught.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第二部分着重介绍了实际的pthread API（及其相关概念），我们如何创建线程，可以创建多少个线程以及应该创建多少个线程也有所讨论。还涉及了线程终止的基础知识，线程属性，向新创建的线程传递参数，什么是加入以及如何执行加入，最后还介绍了如何操纵线程堆栈（和堆栈保护）的细节。展示了许多示例程序来帮助巩固所学的概念。
- en: In the next chapter, we shall focus squarely on another critical aspect of writing
    powerful and safe multithreaded software – the issues of concurrency, races, critical
    sections, deadlock (and it's avoidance) and atomicity; how we deal with these
    using the mutex lock (and it's variants), as well as the condition variable.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于另一个编写强大且安全的多线程软件的关键方面——并发性、竞争、临界区、死锁（及其避免）和原子性；我们如何使用互斥锁（及其变体）以及条件变量来处理这些问题。
