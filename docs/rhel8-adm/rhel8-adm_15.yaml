- en: '*Chapter 12*: Managing Local Storage and Filesystems'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：管理本地存储和文件系统'
- en: In the previous chapters, we have learned about security and system administration.
    In this chapter, we will focus on the administration of resources—specifically,
    storage administration.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们已经学习了安全和系统管理。在本章中，我们将专注于资源管理，特别是存储管理。
- en: 'Storage administration is an important part of keeping a system running: the
    system logs can eat available space, new applications might require additional
    storage set up for them (even on separate disks to improve performance), and such
    issues may require our action in order to solve them.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 存储管理是保持系统运行的重要部分：系统日志可能会占用可用空间，新应用程序可能需要为它们设置额外的存储空间（甚至在单独的磁盘上以提高性能），这些问题可能需要我们采取行动来解决。
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Partitioning disks (**Master Boot Record** (**MBR**) and **Globally Unique Identifier**
    (**GUID**) **Partition Table** (**GPT**) disks)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区磁盘（**主引导记录**（**MBR**）和**全局唯一标识符**（**GUID**）**分区表**（**GPT**）磁盘）
- en: Formatting and mounting filesystems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化和挂载文件系统
- en: Setting default mounts and options in `fstab`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`fstab`中设置默认挂载和选项
- en: Using network filesystems with **Network File System** (**NFS**)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**网络文件系统**（**NFS**）的网络文件系统
- en: This will provide us basic knowledge to build upon our storage administration
    skills to keep our systems running.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供基本知识，以便在存储管理技能上建立，以保持系统运行。
- en: Let's get hands-on!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们动手操作！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can continue the practice using the **virtual machine** (**VM**) created
    at the beginning of this book in [*Chapter 1*](B16799_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Installing RHEL8*. Any additional packages required for this chapter will be
    indicated alongside the text. You will also need partitioning disks (MBR and GPT
    disks).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续使用本书开头创建的**虚拟机**（**VM**）进行练习[*第1章*](B16799_01_Final_SK_ePub.xhtml#_idTextAnchor014)，*安装RHEL8*。本章所需的任何其他软件包将在文本旁边指示。您还需要分区磁盘（MBR和GPT磁盘）。
- en: Let's start with a definition
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们从一个定义开始
- en: A partition is a logical division of a storage device and it's used to logically
    separate the available storage into smaller pieces.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 分区是存储设备的逻辑分割，用于将可用存储逻辑地分成较小的部分。
- en: Now, let's move on to learning a bit about the origins of storage to better
    understand it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续学习一些关于存储起源的知识，以更好地理解它。
- en: A bit of history
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一点历史
- en: Storage is also related to a system's ability to use it, so let's explain a
    bit about the history of **personal computers** (**PCs**), the software that allows
    them to boot (**Basic Input/Output System** (**BIOS**)), and how that influenced
    storage administration.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 存储也与系统使用它的能力有关，因此让我们简要解释一下**个人计算机**（**PC**）的历史，允许它们引导的软件（**基本输入/输出系统**（**BIOS**）），以及这如何影响存储管理。
- en: It might sound a bit strange, but initial storage needs were just a small amount
    of **kilobytes** (**KB**), and for the first hard drives in PCs, storage was just
    a few **megabytes** (**MB**).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来有点奇怪，但最初的存储需求只是一小部分**千字节**（**KB**），对于PC中的第一块硬盘，存储只是几**兆字节**（**MB**）。
- en: 'PCs also come with one feature and limitation: PCs were compatible, which means
    that subsequent models had compatibility with the initial **International Business
    Machines** (**IBM**) PC design.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: PC还具有一个特点和限制：PC是兼容的，这意味着后续型号与最初的**国际商业机器**（**IBM**）PC设计兼容。
- en: Traditional disk partitioning uses a space at the beginning of disks after the
    MBR that allows four partition registers (start, end, size, partition type, active
    flag), called **primary** partitions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的磁盘分区在MBR之后使用了一些空间，允许四个分区寄存器（起始、结束、大小、分区类型、活动标志），称为**主**分区。
- en: When the PC is booting, BIOS will check the partition table of the disk by running
    a small program in the MBR, and then it loads the boot area of the active partition
    and executes it to get the operating system booting.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当PC启动时，BIOS将通过在MBR中运行一个小程序来检查磁盘的分区表，然后加载活动分区的引导区域并执行它，以启动操作系统。
- en: The IBM PC that contained a **Disk Operating System** (**DOS**) and compatibles
    (MS-DOS, DR-DOS, FreeDOS, and others) also used a filesystem named a **File Allocation
    Table** (**FAT**). The FAT contained several structures based on its evolution,
    indicated as the cluster addressing size (as well of some other features).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 包含**磁盘操作系统**（**DOS**）和兼容（MS-DOS、DR-DOS、FreeDOS等）的IBM PC还使用了一个名为**文件分配表**（**FAT**）的文件系统。
    FAT包含了几个基于其演变的结构，指示为簇寻址大小（以及其他一些特性）。
- en: With a limit in the number of clusters, having bigger disks meant having bigger
    blocks, so if a file was using just a limited amount of space, the remaining ones
    couldn't be used by other files. Thus, it became more or less normal to break
    bigger hard drives into smaller logical partitions so that small files would not
    eat up the available space because of limits.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于簇的数量有限，更大的磁盘意味着更大的块，因此，如果一个文件只使用了有限的空间，剩下的空间就不能被其他文件使用。因此，将更大的硬盘分成较小的逻辑分区变得更加正常，这样小文件就不会因为限制而占用可用空间。
- en: 'Think about this as an agenda with a maximum number of entries, similar to
    a speed dial in your phone: if you have only nine slots for the speed dial, a
    short number such as calling voicemail will still count as having stored a big
    international number as both still use one slot.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 把这看作是一个议程，最多有一定数量的条目，类似于手机上的快速拨号：如果你只有九个快速拨号的位置，一个短号码，比如打语音信箱，仍然会占用一个位置，就像存储一个大的国际号码一样。
- en: Some of those limitations became reduced by subsequent versions of the FAT sizing,
    which in parallel increased the maximum supported disk size.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些限制在FAT大小的后续版本中得到了减少，与此同时增加了最大支持的磁盘大小。
- en: Of course, other operating systems introduced their own filesystems, but using
    this same partitioning schema.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，其他操作系统也引入了自己的文件系统，但使用相同的分区模式。
- en: 'Later, a new partition type was created: the **extended partition**, which
    used one of the four available **primary partition** slots and allowed extra partitions
    to be defined inside it, enabling us to create logical disks to be assigned as
    needed.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，创建了一种新的分区类型：**扩展分区**，它使用了四个可用的**主分区**插槽之一，并允许在其中定义额外的分区，从而使我们能够创建逻辑磁盘以根据需要分配。
- en: Additionally, having several primary partitions also allowed the installation
    in the same computer of different operating systems with their own dedicated space
    that were completely independent of other operating systems.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，拥有多个主分区还允许在同一台计算机上安装不同操作系统，并且这些操作系统具有完全独立的专用空间。
- en: So... partitions allowed computers to have different operating systems, have
    a better usage of the available storage, or even logically sorting the data by
    keeping it on different areas, such as keeping operating system space separate
    from user data so that a user filling the available space would not affect the
    computer's operation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所以...分区允许计算机拥有不同的操作系统，更好地利用可用的存储空间，甚至通过在不同的区域保留数据来逻辑地对数据进行排序，例如将操作系统空间与用户数据分开，以便用户填满可用空间不会影响计算机的运行。
- en: As we said, many of those designs came with the compatibility restriction of
    the original IBM PC, so when new computers using the **Extensible Firmware Interface**
    (**EFI**) appeared to overcome the limitations of traditional BIOS, a new partition
    table format called **GPT** arrived.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，许多这些设计都带有原始IBM PC的兼容性限制，因此当新的使用**可扩展固件接口**（**EFI**）的计算机出现以克服传统BIOS的限制时，就出现了一种新的分区表格式称为**GPT**。
- en: Systems using GPT make use of 32-bit and 64-bit support versus the 16-bit support
    used by BIOS (inherited from IBM PC compatibility), so bigger addressing can be
    used for the disks, as well as extra features such as extended controllers loading.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GPT的系统使用32位和64位支持，而BIOS使用16位支持（从IBM PC兼容性继承），因此可以为磁盘使用更大的寻址，以及额外的功能，如扩展控制器加载。
- en: Now, let's learn about disk partitioning in the next section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在下一节学习关于磁盘分区。
- en: Partitioning disks (MBR and GPT disks)
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区磁盘（MBR和GPT磁盘）
- en: As mentioned, using disk partitions allows us to more efficiently use the space
    available in our computers and servers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，使用磁盘分区允许我们更有效地利用计算机和服务器中可用的空间。
- en: Let's dig into disk partitioning by first identifying the disk to act on.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过识别要操作的磁盘来深入了解磁盘分区。
- en: Important note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Once we have learned about what caused disks to be partitioned and the limitations
    of this, we should follow one schema or another based on our system specifications,
    but bear in mind that EFI requires GPT and BIOS requires MBR, so a system supporting
    UEFI, but having a disk partitioned with MBR, will boot the system into BIOS-compatible
    mode.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了导致磁盘被分区以及其限制的原因，我们应该根据我们的系统规格遵循一个模式或另一个模式，但要记住EFI需要GPT，BIOS需要MBR，因此支持UEFI的系统，但磁盘分区为MBR，将会将系统引导到兼容BIOS的模式。
- en: Linux uses different notation for the disks based on the way those are connected
    to the system, so—for example—you can see disks as `hda` or `sda` or `mmbclk0`
    depending on that connection being used. Traditionally, disks connected using
    the `hda`, `hdb`, and so on, while disks using the `sda`, `sdb`, and so on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Linux根据连接到系统的方式使用不同的符号表示磁盘，因此，例如，您可以看到磁盘为`hda`或`sda`或`mmbclk0`，具体取决于所使用的连接。传统上，使用`hda`，`hdb`等连接的磁盘，而使用`sda`，`sdb`等连接的磁盘。
- en: 'We can list the available devices with `fdisk –l` or `lsblk –fp`, as we can
    see in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`fdisk –l`或`lsblk –fp`列出可用设备，如下面的屏幕截图所示：
- en: '![Figure 12.1 – lsblk-fp and fdisk –l output'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 – lsblk-fp和fdisk –l输出'
- en: '](img/B16799_12_001.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_12_001.jpg)'
- en: Figure 12.1 – lsblk-fp and fdisk –l output
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – lsblk-fp和fdisk –l输出
- en: 'As we can see, our disk named `/dev/sda` has three partitions: `sda1`, `sda2`,
    and `sda3`, with `sda3` being a `LVM` volume group that has a volume named `/dev/mapper/rhel-root`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们的名为`/dev/sda`的磁盘有三个分区：`sda1`，`sda2`和`sda3`，其中`sda3`是一个`LVM`卷组，其卷名为`/dev/mapper/rhel-root`。
- en: To demonstrate disk partitioning in a safe way and to make it easier for readers
    using a VM for testing, we will create a fake `truncate` utility that comes with
    the `coreutil` package and the `losetup` utility that comes with the `util-linux`
    package.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以安全的方式演示磁盘分区，并使读者在使用虚拟机进行测试时更容易，我们将创建一个虚拟的`truncate`实用程序，该实用程序随`coreutil`软件包一起提供，以及一个随`util-linux`软件包一起提供的`losetup`实用程序。
- en: 'In order to create a VHD, we will execute the following sequence of commands
    as they appear in *Figure 12.2*:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个VHD，我们将按照*图12.2*中显示的命令序列执行以下命令：
- en: '`truncate –s 20G myharddrive.hdd`'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`truncate –s 20G myharddrive.hdd`'
- en: Note
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This command creates a 20 **gigabytes** (**GB**)-sized file but this will be
    an empty file, which means that the file is not really using 20 GB on our disk,
    just showing that size. Unless we use it, it will not consume more disk space
    (this is called a **sparse file**).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建一个大小为20**GB**的文件，但这将是一个空文件，这意味着该文件实际上并未在我们的磁盘上使用20 GB的空间，只是显示了那个大小。除非我们使用它，它将不会占用更多的磁盘空间（这称为**稀疏文件**）。
- en: '`losetup –f`, which will find the next available device'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`losetup –f`，将找到下一个可用设备'
- en: '`losetup /dev/loop0 myharddrive.hdd`, which will associate `loop0` with the
    file created'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`losetup /dev/loop0 myharddrive.hdd`，将`loop0`与创建的文件关联'
- en: '`lsblk –fp`, to validate the newly looped disk'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`lsblk –fp`，验证新循环磁盘'
- en: '`fdisk –l /dev/loop0`, to list the available space in the new disk'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fdisk –l /dev/loop0`，列出新磁盘中的可用空间'
- en: 'The following screenshot shows the output of the preceding sequential commands:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了前面顺序命令的输出：
- en: '![Figure 12.2 – Execution of the indicated commands for creating a fake hard
    drive'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 – 执行指定命令以创建一个虚拟硬盘'
- en: '](img/B16799_12_002.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_12_002.jpg)'
- en: Figure 12.2 – Execution of the indicated commands for creating a fake hard drive
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 执行指定命令以创建一个虚拟硬盘
- en: The `losetup -f` command finds the next available loopback device, which is
    a device used for looping back accesses to a backing file. This is often used
    for mounting ISO files locally, for example.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`losetup -f`命令找到下一个可用的回环设备，这是用于将访问回环到支持文件的设备。例如，这经常用于本地挂载ISO文件。'
- en: With the third command, we use the previously available loopback device to set
    up a loop connection between device `loop0` device and the file we created with
    the first command.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第三个命令，我们使用先前可用的回环设备来设置设备`loop0`和我们用第一个命令创建的文件之间的回环连接。
- en: As we can see, in the remaining commands, the device now appears when running
    the same commands, we executed in *Figure 12.1*, showing that we have a disk of
    20 GB available.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，在剩下的命令中，当运行相同的命令时，设备现在会出现，我们在*图12.1*中执行，显示我们有一个可用的20 GB磁盘。
- en: Important note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Partitioning operations on disks can be dangerous and can render a system unusable
    and in need of restoration or reinstallation. To reduce that chance, the examples
    in this chapter will use the `/dev/loop0` fake created disk and only interact
    with this. Pay attention when performing this over real volumes, disks, and so
    on.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在磁盘上进行分区操作可能是危险的，并且可能使系统无法使用，需要恢复或重新安装。为了减少这种可能性，本章中的示例将使用`/dev/loop0`虚拟创建的磁盘，并且只与此交互。在对真实卷、磁盘等执行此操作时要注意。
- en: 'Let''s start creating partitions by executing `fdisk /dev/loop0` on our newly
    created device, as seen in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在我们新创建的设备上执行`fdisk /dev/loop0`来开始创建分区，如下一张截图所示：
- en: '![Figure 12.3 – fdisk execution over /dev/loop0'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 - fdisk在/dev/loop0上执行'
- en: '](img/B16799_12_003.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_12_003.jpg)'
- en: Figure 12.3 – fdisk execution over /dev/loop0
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 - fdisk在/dev/loop0上执行
- en: As we can see in *Figure 12.3*, the disk doesn't contain a recognized partition
    table, so a new DOS partition disk label is created, but the changes only remain
    in memory until written back to disk.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*图12.3*中所看到的，磁盘不包含已识别的分区表，因此创建了一个新的DOS分区磁盘标签，但更改只保留在内存中，直到写回磁盘。
- en: Inside the `fdisk` command, we can use several options to create a partition.
    The first one we should be aware of is `m`, as indicated in *Figure 12.3*, which
    shows the help functionality and available commands.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fdisk`命令中，我们可以使用多个选项来创建分区。我们应该注意的第一个选项是`m`，如*图12.3*中所示，它显示了帮助功能和可用命令。
- en: The first thing to take into consideration is our previous explanation about
    UEFI, BIOS, and so on. By default, `fdisk` is creating a DOS partition, but as
    we can see inside the manual (`m`), we can create a GPT one by running the `g`
    command inside `fdisk`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要考虑的是我们之前关于UEFI、BIOS等的解释。默认情况下，`fdisk`正在创建一个DOS分区，但正如我们在手册（`m`）中所看到的，我们可以通过在`fdisk`中运行`g`命令来创建一个GPT分区。
- en: 'One important command to remember is `p`, which prints the current disk layout
    and partition, as defined in the next screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住的一个重要命令是`p`，它打印当前磁盘布局和分区，如下一张截图中所定义的：
- en: '![Figure 12.4 – fdisk creating a new partition table'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4 - fdisk创建新的分区表'
- en: '](img/B16799_12_004.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_12_004.jpg)'
- en: Figure 12.4 – fdisk creating a new partition table
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 - fdisk创建新的分区表
- en: As we can see, the initial `disklabel` type was `dos` and now is `gpt`, compatible
    with EFI/UEFI.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，初始的`disklabel`类型是`dos`，现在是`gpt`，与EFI/UEFI兼容。
- en: 'Let''s review some of the basic commands we can use, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些我们可以使用的基本命令，如下所示：
- en: '`n`: Creates a new partition'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`：创建一个新分区'
- en: '`d`: Deletes a partition'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`：删除一个分区'
- en: '`m`: Shows manual page (help)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m`：显示手册页（帮助）'
- en: '`p`: Prints current layout'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p`：打印当前布局'
- en: '`x`: Enters advanced mode (extra functionality intended for experts)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`：进入高级模式（专为专家设计的额外功能）'
- en: '`q`: Quits without saving'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`q`：退出而不保存'
- en: '`w`: Writes changes to disk and exits'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`：将更改写入磁盘并退出'
- en: '`g`: Creates new GPT disk label'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`：创建新的GPT磁盘标签'
- en: '`o`: Creates a DOS disk label'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`o`：创建DOS磁盘标签'
- en: '`a`: In DOS mode, sets the bootable flag to one of the primary partitions'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`：在DOS模式下，将可引导标志设置为其中一个主分区'
- en: What will be the sequence for creating a new traditional disk partition layout
    with a bootable partition for the operating system and another one for the user
    data with half the disk size each?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 创建具有用于操作系统的可引导分区和用于用户数据的另一个分区的新传统磁盘分区布局的顺序是什么？
- en: 'This will be the sequence of commands (these are also shown in *Figure 12.5*):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是命令的顺序（这些命令也显示在*图12.5*中）：
- en: '`o` and press *Enter* to create a new DOS disk label'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`o`并按*Enter*创建新的DOS磁盘标签'
- en: '`n` and press *Enter* to create a new partition'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`n`并按*Enter*创建一个新分区'
- en: Press *Enter* to accept a primary partition type
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Enter*接受主分区类型
- en: Press *Enter* to confirm use of the first partition (`1`)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Enter*确认使用第一个分区（`1`）
- en: Press *Enter* to accept initial sector
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Enter*接受初始扇区
- en: '`+10G` and press *Enter* to indicate 10 GB in size from first sector'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`+10G`并按*Enter*指示从第一个扇区开始的大小为10 GB'
- en: '`n` and press *Enter* to create a second new partition'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`n`并按*Enter*创建第二个新分区'
- en: Press *Enter* to accept it as a primary partition type
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Enter*接受它作为主分区类型
- en: Press *Enter* to accept the partition number (`2`)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Enter*接受分区号（`2`）
- en: Press *Enter* to accept the first sector as default proposed by fdisk
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Enter*接受fdisk提出的默认第一个扇区
- en: Press *Enter* to accept the end sector as default proposed by fdisk
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Enter*接受fdisk提出的默认结束扇区
- en: '`a` and press *Enter* to mark a partition as bootable'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a`并按*Enter*将分区标记为可引导'
- en: '`1` and press *Enter* to mark the first partition'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1`并按*Enter*标记第一个分区'
- en: As you can see, most of the options accept the defaults; the only change was
    to specify a partition size of `+10G`, meaning it should be 10 GB (the disk was
    20 GB), and then start with the second partition with the new `n` command, now
    not specifying the size as we want to use all the remaining ones. The last step
    is to mark the first partition as active for booting.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，大多数选项接受默认值；唯一的更改是指定分区大小为`+10G`，表示应为10 GB（磁盘为20 GB），然后使用新的`n`命令开始第二个分区，现在不指定大小，因为我们要使用所有剩余的分区。最后一步是将第一个分区标记为可引导的。
- en: 'Of course, remember what we said before: unless we execute the `w` command,
    the changes are not written to disk, and we can use `p` to review them, as shown
    in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，记住我们之前说过的：除非执行`w`命令，否则更改不会写入磁盘，我们可以使用`p`来查看它们，如下面的屏幕截图所示：
- en: '![Figure 12.5 – Disk partition layout creation and verification before writing
    it back to disk'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 – 在将其写回磁盘之前创建和验证磁盘分区布局'
- en: '](img/B16799_12_005.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_12_005.jpg)'
- en: Figure 12.5 – Disk partition layout creation and verification before writing
    it back to disk
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 在将其写回磁盘之前创建和验证磁盘分区布局
- en: To conclude this section, let's write the changes to disk with the `w` command
    and let's move on to discuss filesystems in the next section. Before that, however,
    let's execute `partprobe /dev/loop0` to make the kernel update its internal view
    on the disk and find the two new partitions. Without this, the `/dev/loop0p1`
    and `/dev/loop0p2` special files might not be created and will not be usable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本节，让我们使用`w`命令将更改写入磁盘，并继续讨论下一节中的文件系统。然而，在此之前，让我们执行`partprobe /dev/loop0`，以使内核更新其对磁盘的内部视图，并找到两个新分区。如果不这样做，`/dev/loop0p1`和`/dev/loop0p2`特殊文件可能不会被创建，也无法使用。
- en: Note that some partition modifications will not be updated even after a `partprobe`
    execution and might require the system to be rebooted. This is, for example, happening
    in disks that have partitions in use, such as the one holding the root filesystem
    in our computer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一些分区修改即使在执行`partprobe`后也不会更新，并可能需要系统重新启动。例如，在使用分区的磁盘上，例如我们计算机中保存根文件系统的磁盘上，就会发生这种情况。
- en: Formatting and mounting filesystems
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化和挂载文件系统
- en: In the previous section, we learned how to logically divide our disk, but that
    disk is still not usable for storing data. In order to enable this to do so, we
    need to define a **filesystem** on it as the first step to make it available to
    our system.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何在逻辑上划分我们的磁盘，但该磁盘仍然无法用于存储数据。为了使其可用于存储数据，我们需要在其上定义一个**文件系统**，这是使其对我们的系统可用的第一步。
- en: A filesystem is a logical structure that defines how files, folders, and more
    are stored and provides, based on each type, a different set of features.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统是一个逻辑结构，定义了文件、文件夹等的存储方式，并根据每种类型提供了不同的功能集。
- en: The number and types of filesystems supported depends on the operating system
    version, as during its evolution, new filesystems might be added, removed, and
    so on.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的文件系统数量和类型取决于操作系统版本，因为在其演变过程中，可能会添加、删除新的文件系统等。
- en: Tip
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that **Red Hat Enterprise Linux** (**RHEL**) focuses on stability,
    so there are strict controls about which features are added or phased out for
    newer releases, but not within the current release. You can read more about this
    at [https://access.redhat.com/articles/rhel8-abi-compatibility](https://access.redhat.com/articles/rhel8-abi-compatibility).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，**Red Hat Enterprise Linux** (**RHEL**) 专注于稳定性，因此严格控制了哪些功能被添加或在新版本中被淘汰，但不包括当前版本内。您可以在[https://access.redhat.com/articles/rhel8-abi-compatibility](https://access.redhat.com/articles/rhel8-abi-compatibility)了解更多信息。
- en: In RHEL 8, the default filesystem is the **eXtended File System** (**XFS**),
    but you can see a list of available ones at the RHEL documentation found at [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/system_design_guide/overview-of-available-file-systems_system-design-guide](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/system_design_guide/overview-of-available-file-systems_system-design-guide),
    and of course, others such as **Fourth Extended Filesystem** (**EXT4**) can be
    used.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在RHEL 8中，默认文件系统是**eXtended File System** (**XFS**)，但您可以在RHEL文档中找到可用文件系统的列表，网址为[https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/system_design_guide/overview-of-available-file-systems_system-design-guide](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/system_design_guide/overview-of-available-file-systems_system-design-guide)，当然，也可以使用**Fourth
    Extended Filesystem** (**EXT4**)等其他文件系统。
- en: The choice of the filesystem depends on several factors such as usage intention,
    type of files that are going to be used, and more, as different filesystems might
    have performance implications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统的选择取决于诸多因素，如使用意图、将要使用的文件类型等，不同的文件系统可能会对性能产生影响。
- en: For example, both EXT4 and XFS are journaled filesystems that provide more protection
    against power failures, but the maximum filesystem differs in terms of other aspects
    such as the likeliness of becoming fragmented, and so on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，EXT4和XFS都是日志文件系统，可以提供更多的保护，防止断电故障，但在其他方面，如文件系统的最大值等方面有所不同。
- en: Before choosing a filesystem, it is a good practice to get an idea of the kind
    of files being deployed and their usage pattern, as choosing the wrong one might
    affect system performance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择文件系统之前，了解部署的文件类型和它们的使用模式是一个很好的做法，因为选择错误的文件系统可能会影响系统性能。
- en: As we defined in the previous section two partitions on our VHD, we can try
    creating both XFS and EXT4 filesystems. Again, however, be very careful when performing
    operations, as filesystem creation is a destructive operation that writes new
    structures back to the disk, and when operating as root user of the system, which
    is required, selecting the wrong one can destroy within seconds the available
    data we had on our system.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中定义的，在我们的VHD上创建了两个分区，我们可以尝试创建XFS和EXT4文件系统。然而，在执行操作时要非常小心，因为文件系统的创建是一种破坏性操作，会将新的结构写回磁盘，当以系统的root用户操作时，选择错误的文件系统可能会在几秒钟内摧毁我们系统上的可用数据。
- en: Important note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember to check the man page for the commands being used in order to get familiar
    with the different recommendations and options available for each one.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住查看正在使用的命令的man页面，以熟悉每个命令的不同建议和可用选项。
- en: 'Let''s then use the two partitions we created to test with two filesystems,
    XFS and EXT4, by using the `mkfs.xfs` and `mkfs.ext4` commands against each one
    of the devices respectively, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们使用我们创建的两个分区来测试两种文件系统，XFS和EXT4，分别使用`mkfs.xfs`和`mkfs.ext4`命令对每个设备进行操作，如下所示：
- en: '![Figure 12.6 – Filesystem creation on the VHD created'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6—在创建的VHD上创建文件系统'
- en: '](img/B16799_12_006.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_12_006.jpg)'
- en: Figure 12.6 – Filesystem creation on the VHD created
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6—在创建的VHD上创建文件系统
- en: Note that we have specified the different loop device partition and we also
    specified one `-L` parameter for each command. We will look at this again later.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经指定了不同的循环设备分区，并且还为每个命令指定了一个`-L`参数。稍后我们将再次查看这个。
- en: 'Now that the filesystem has been created, we can run `lsblk -fp` to verify
    this, and we can see both devices, now indicating the filesystem is in use as
    well as `LABEL` and `UUID` values (the ones shown when we created the filesystem
    with `mkfs`), as we can see in the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在文件系统已经创建，我们可以运行`lsblk -fp`来验证这一点，我们可以看到两个设备，现在指示文件系统正在使用以及`LABEL`和`UUID`值（我们使用`mkfs`创建文件系统时显示的值），如下面的屏幕截图所示：
- en: '![Figure 12.7 – Output of lsblk –fp after creating the filesystems'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7—创建文件系统后lsblk –fp的输出'
- en: '](img/B16799_12_007.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_12_007.jpg)'
- en: Figure 12.7 – Output of lsblk –fp after creating the filesystems
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7—创建文件系统后lsblk –fp的输出
- en: From the preceding output, it's important to pay attention to the `UUID` and
    `LABEL` values (if you remember, the value listed is the one we specified in the
    `mkfs` command with the `–L` option), as we will be using them later in this chapter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，重要的是要注意`UUID`和`LABEL`的值（如果您记得，列出的值是我们在`mkfs`命令中使用`-L`选项指定的值），因为我们将在本章后面使用它们。
- en: Now that the filesystems have been created, in order to use them we need to
    mount them, which means making the filesystem available at a path in our system
    so that every time we store inside that path, we will be using that device.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在文件系统已经创建，为了使用它们，我们需要挂载它们，这意味着使文件系统在我们的系统中的某个路径上可用，这样每次我们存储在该路径中，我们将使用该设备。
- en: Mounting a filesystem can be done in several ways, but the simplest way is to
    use autodetection and just specify the device to mount and the local path to mount
    it at, but more complex ones that allow several options to be defined can be found
    when checking the `man mount` help page.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载文件系统可以通过多种方式完成，但最简单的方法是使用自动检测，只需指定要挂载的设备和要挂载的本地路径，但在检查`man mount`帮助页面时，还可以找到更复杂的方法，允许定义多个选项。
- en: 'For mounting our two created filesystems, we will create two folders and then
    proceed to mounting each device by executing the following commands:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了挂载我们创建的两个文件系统，我们将创建两个文件夹，然后执行以下命令挂载每个设备：
- en: '`cd`'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cd`'
- en: '`mkdir first second`'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mkdir first second`'
- en: '`mount /dev/loop0p1 first/`'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mount /dev/loop0p1 first/`'
- en: '`mount /dev/loop0p2 second/`'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mount /dev/loop0p2 second/`'
- en: At this point, the two filesystems will be available in our home folder (root
    user) in the subfolders named `first` and `second`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，两个文件系统将在我们的主文件夹（根用户）中的名为`first`和`second`的子文件夹中可用。
- en: The kernel has automatically found which filesystem is in use for each device
    and has loaded it via the appropriate controller and this worked, but sometimes
    we might want to define specific options— for example, forcing the filesystem
    type, which was used in the past when `ext2` and `ext3` were the common filesystems
    to enable or disable journaling, or, for example, to disable the built-in features
    that update the file or directory access time to reduce the disk I/O and increase
    performance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 内核已自动找到每个设备正在使用的文件系统，并通过适当的控制器加载它，这很有效，但有时我们可能想要定义特定的选项——例如，强制文件系统类型，在过去使用`ext2`和`ext3`作为常见文件系统时启用或禁用日志记录，或者例如，禁用更新文件或目录访问时间的内置功能，以减少磁盘I/O并提高性能。
- en: All options specified on the command line, or filesystems mounted, will not
    be available once the system is rebooted as those are only runtime changes. Let's
    move on to the next section to learn how to define default options and filesystem
    mounts when the system is being started.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上指定的所有选项，或者挂载的文件系统，在系统重新启动后将不可用，因为这些只是运行时更改。让我们继续下一节，学习如何在系统启动时定义默认选项和文件系统挂载。
- en: Setting default mounts and options in fstab
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在fstab中设置默认挂载和选项
- en: In the previous section, we introduced how disks and partitions can be mounted
    so that our services and users can make use of them. In this section, we will
    learn how to make those filesystems available in a persistent way.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们介绍了如何挂载磁盘和分区，以便我们的服务和用户可以使用它们。在本节中，我们将学习如何以持久的方式使这些文件系统可用。
- en: The `/etc/fstab` file contains the filesystem definitions for our system and,
    of course, it has a dedicated manual page that can be checked with `man fstab`
    containing useful information about the formatting, fields, ordering, and so on
    that must be taken into consideration, as this file is critical for the smooth
    operation of the system.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/fstab`文件包含系统的文件系统定义，并且当然有一个专门的手册页面，可以使用`man fstab`来查看，其中包含有关格式、字段、排序等必须考虑的有用信息，因为这个文件对系统的平稳运行至关重要。'
- en: The file format is defined by several fields separated by tabs or spaces, with
    lines starting with a `#` considered as comments.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 文件格式由用制表符或空格分隔的几个字段定义，以`#`开头的行被视为注释。
- en: 'For example, we will use this line to look at each field description:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将使用这行来查看每个字段的描述：
- en: '[PRE0]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first field is the device definition, which can be a special block device,
    a remote filesystem, or—as we can see—a selector made by `LABEL`, `UUID`, or,
    for `PARTUUID` or `PARTLABEL`. The `man` page for `mount`, `blkid`, and `lsblk`
    provides more information about device identifiers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字段是设备定义，可以是特殊的块设备、远程文件系统，或者—正如我们所看到的—由`LABEL`、`UUID`或`PARTUUID`或`PARTLABEL`制作的选择器。`mount`、`blkid`和`lsblk`的`man`页面提供了有关设备标识符的更多信息。
- en: The second field is the mount point for the filesystem, which is where to make
    the contents of that filesystem available based on our system directory hierarchy.
    Some special devices/partitions such as swap areas have this defined as `none`,
    as effectively the contents are not made available via the filesystem.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个字段是文件系统的挂载点，这是根据我们的系统目录层次结构使该文件系统的内容可用的位置。一些特殊的设备/分区，如交换区，将其定义为`none`，因为实际上内容不会通过文件系统可用。
- en: The third field is the filesystem type as supported by the `mount` command or
    `swap`, for swap partitions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个字段是由`mount`命令或`swap`支持的文件系统类型，用于交换分区。
- en: The fourth field is the mount options as supported by `mount` or `swapon` commands
    (check their `man` pages for more details), being at its default setting an alias
    for most common options (read/write, allow devices, allow execution, automount
    on boot, async access, and so on). Other common options might be `noauto`, which
    defines the filesystem but doesn't mount at boot (often used with removable devices),
    `user`, which allows users to mount and unmount it, and `_netdev`, which defines
    remote paths that require networking to be up before attempting the mount.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个字段是由`mount`或`swapon`命令支持的挂载选项（查看它们的`man`页面以获取更多详细信息），在其默认设置下，它是大多数常见选项的别名（读/写，允许设备，允许执行，自动挂载启动，异步访问等）。其他常见选项可能是`noauto`，它定义了文件系统但不会在启动时挂载（通常与可移动设备一起使用），`user`，它允许用户挂载和卸载它，以及`_netdev`，它定义了需要在尝试挂载之前网络处于连接状态的远程路径。
- en: The fifth field is used by `dump` to determine which filesystems should be used—its
    value defaults to `0`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个字段由`dump`用于确定应使用哪些文件系统 - 其值默认为`0`。
- en: The sixth field is used by `fsck` to determine the order for filesystems to
    be checked on boot. The root filesystem should have a value of 1 and the others
    should have a value of 2 (the default is 0, not `fsck`). Checks are performed
    in parallel to speed up the booting process. Note that with filesystems that have
    a journal, the filesystem itself can perform a fast validation instead of a full
    one.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第六个字段由`fsck`用于确定在启动时要检查的文件系统的顺序。根文件系统的值应为1，其他文件系统的值应为2（默认值为0，而不是`fsck`）。检查是并行执行的，以加快启动过程。请注意，具有日志的文件系统本身可以执行快速验证而不是完整验证。
- en: 'In the following screenshot, let''s see how it looks in our system with the
    output of `cat /etc/fstab`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，让我们看看我们系统中`cat /etc/fstab`的输出是什么：
- en: '![Figure 12.8 – fstab example from our system'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8 - 我们系统的fstab示例'
- en: '](img/B16799_12_008.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_12_008.jpg)'
- en: Figure 12.8 – fstab example from our system
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 - 我们系统的fstab示例
- en: Why should we use `UUID` or `LABEL` instead of devices such as `/dev/sda1`?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们应该使用`UUID`或`LABEL`而不是`/dev/sda1`等设备？
- en: Disk ordering might change when a system is booting, as some kernels might introduce
    differences in the devices in how those are accessed, and so on, causing changes
    in the enumeration of the devices; this happens not only for removable devices
    such as **Universal Serial Bus** (**USB**) ones, but also to internal devices
    such as network interfaces or hard drives.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统启动时，磁盘排序可能会发生变化，因为一些内核可能会引入设备访问方式的差异等，导致设备的枚举发生变化；这不仅发生在可移动设备（如**通用串行总线**（**USB**）设备），还发生在网络接口或硬盘等内部设备上。
- en: When, instead of specifying the devices, we use `UUID` or `LABEL`, even in the
    event of a device reordering, the system will still be able to find the right
    device to use and boot from it. This was especially important when systems used
    to have **IDE** and **Serial Advanced Technology Attachment** (**SATA**) drives
    and **SCSI** drives, or even today when **internet SCSI** (**iSCSI**) devices
    might be connected in a different order than expected, resulting in device name
    changes and failures when reaching them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`UUID`或`LABEL`而不是指定设备时，即使在设备重新排序的情况下，系统仍将能够找到正确的设备并从中引导。这在系统以前使用**IDE**和**串行高级技术附件**（**SATA**）驱动器和**SCSI**驱动器时尤为重要，甚至在今天，**Internet
    SCSI**（**iSCSI**）设备可能以与预期不同的顺序连接，导致设备名称更改和在到达时失败。
- en: Remember to use `blkid` or `lsblk –fp` commands to check the filesystems' labels
    and **universally unique identifiers** (**UUIDs**) that could be used when referring
    to them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住使用`blkid`或`lsblk -fp`命令来检查文件系统的标签和**通用唯一标识符**（**UUID**），这些标识符在引用它们时可能会用到。
- en: Important note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'When editing the `/etc/fstab` file, be extremely careful: altering the mount
    points used by the system might render your system unusable. If in doubt, double-check
    for any change and be sure to be familiar with system recovery methods and have
    rescue media available in case this is needed.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑`/etc/fstab`文件时，务必小心：更改系统使用的挂载点可能会导致系统无法使用。如果有疑问，请仔细检查任何更改，并确保熟悉系统恢复方法，并在需要时准备好救援介质。
- en: Let's learn about mounting a remote NFS in the next section
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节学习如何挂载远程NFS
- en: Using network filesystems with NFS
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NFS进行网络文件系统
- en: Mounting a remote NFS is not much different than mounting local devices, but
    instead of specifying a local device as we did in the previous section with our
    `/dev/loop0p1` file, we provide `server:export` as a device.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载远程NFS与挂载本地设备并没有太大区别，但是与在上一节中使用`/dev/loop0p1`文件指定本地设备不同，我们提供`server:export`作为设备。
- en: We can find a range of available options by checking the manual page via `man
    mount`, and this will show us several of the options and the way the device looks.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查手册页面`man mount`来找到一系列可用选项，这将向我们显示几个选项以及设备的外观。
- en: 'When a NFS mount is going to be used, the administrator will need to use the
    host and the export name to mount that device—for example, based on the following
    data about the NFS export:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当要使用NFS挂载时，管理员需要使用主机和导出名称来挂载该设备，例如，基于以下关于NFS导出的数据：
- en: '`server.example.com`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server.example.com`'
- en: '`/isos`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/isos`'
- en: '`/mnt/nfs`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/mnt/nfs`'
- en: 'With the preceding data, it''s easy to construct the `mount` command, which
    will look like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上述数据，很容易构建`mount`命令，它将如下所示：
- en: '[PRE1]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we analyze the preceding command, it will define the type of filesystem to
    mount as `nfs`, provided by a `server.example.com` hostname, and using the `/isos`
    NFS export, and will be made available locally under the `/mnt/nfs` folder.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分析上述命令，它将定义要挂载的文件系统类型为`nfs`，由`server.example.com`主机名提供，并使用`/isos` NFS导出，并将在本地的`/mnt/nfs`文件夹下可用。
- en: If we want to define this filesystem as available at boot, we should add an
    entry in `/etc/fstab`, but... how should we indicate this?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在启动时定义此文件系统为可用，我们应该在`/etc/fstab`中添加一个条目，但是...我们应该如何指示这一点呢？
- en: 'Based on the settings explained during this chapter, the constructed entry
    would look something like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 根据本章节中解释的设置，构建的条目将看起来像这样：
- en: '[PRE2]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding line of code contains the parameters we indicated on the command
    line, but it also adds that it is a resource that required network access before
    attempting to mount it, as networking is required to be able to reach the NFS
    server, similar to what will be required for other network-based storage such
    as Samba mounts, iSCSI, and so on.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码包含了我们在命令行上指定的参数，但它还添加了在尝试挂载之前需要网络访问的资源，因为网络访问是必需的，以便能够访问NFS服务器，类似于其他基于网络的存储，如Samba挂载、iSCSI等，都需要的情况。
- en: Important note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Reinstating the idea of keeping our system bootable, once we make modifications
    to the `/etc/fstab` configuration file, it is recommended to execute `mount -a`
    so that the validation is performed from a running system. If after the execution
    the new filesystems are available and shown when executing—for example, `df`—and
    no error appeared, it should be safe.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 重申保持系统可引导的想法，一旦我们对`/etc/fstab`配置文件进行修改，建议执行`mount -a`，以便在运行系统时执行验证。如果执行后新的文件系统可用，并且在执行例如`df`时显示，并且没有出现错误，那么应该是安全的。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've learned about how a disk is divided logically for optimal
    use of storage and how to later create a filesystem on that disk division so that
    it can be used to actually store data.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何对磁盘进行逻辑划分，以便最佳利用存储空间，并且如何稍后在该磁盘划分上创建文件系统，以便实际存储数据。
- en: Once the actual filesystem was created, we learned how to make it accessible
    in our system and how to ensure that it will be available after the next system
    restart via modification of the `/etc/fstab` configuration file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实际文件系统被创建，我们学会了如何在系统中使其可访问，以及如何通过修改`/etc/fstab`配置文件来确保在下次系统重启后它仍然可用。
- en: Finally, we also learned about using a remote filesystem with NFS based on the
    data that was provided for us and how to add it to our `fstab` file to make it
    persistent.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还学习了如何使用提供给我们的数据来使用NFS远程文件系统，并将其添加到我们的`fstab`文件中以使其持久化。
- en: In the next chapter, we will learn how to make storage even more useful via
    **Logical Volume Management** (**LVM**), which empowers the definition of different
    logical units that can be resized, combined to provide data redundancy, and so
    on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过**逻辑卷管理**（**LVM**）使存储更加有用，它赋予了定义不同逻辑单元的能力，可以调整大小，组合以提供数据冗余等。
