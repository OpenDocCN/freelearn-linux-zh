- en: '*Chapter 3*: Installing KVM Hypervisor, libvirt, and oVirt'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：安装KVM Hypervisor、libvirt和oVirt'
- en: This chapter provides you with an insight into the main topic of our book, which
    is the **Kernel Virtual Machine** (**KVM**) and its management tools, libvirt
    and oVirt. We will also learn how to do a complete installation of these tools
    from scratch using a basic deployment of CentOS 8\. You'll find this to be a very
    important topic as there will be situations where you just don't have all of the
    necessary utilities installed – especially oVirt, as this is a completely separate
    part of the overall software stack, and a free management platform for KVM. As
    oVirt has a lot of moving parts – Python-based daemons and supporting utilities,
    libraries, and a GUI frontend – we will include a step-by-step guide to make sure
    that you can install oVirt with ease.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为您提供了对我们书籍主题的深入了解，即**内核虚拟机**（**KVM**）及其管理工具libvirt和oVirt。我们还将学习如何使用基本的CentOS
    8部署从头开始完整安装这些工具。您会发现这是一个非常重要的主题，因为有时您可能没有安装所有必要的实用程序，特别是oVirt，因为它是整体软件堆栈的一个完全独立的部分，也是KVM的免费管理平台。由于oVirt有很多组成部分
    - 基于Python的守护程序和支持实用程序、库和GUI前端 - 我们将包括一步一步的指南，以确保您可以轻松安装oVirt。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting acquainted with QEMU and libvirt
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉QEMU和libvirt
- en: Getting acquainted with oVirt
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉oVirt
- en: Installing QEMU, libvirt, and oVirt
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装QEMU、libvirt和oVirt
- en: Starting a virtual machine using QEMU and libvirt
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用QEMU和libvirt启动虚拟机
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Getting acquainted with QEMU and libvirt
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉QEMU和libvirt
- en: In [*Chapter 2*](B14834_02_Final_ASB_ePub.xhtml#_idTextAnchor029), *KVM as a
    Virtualization Solution*, we started discussing KVM, QEMU, and various additional
    utilities that we can use to manage our KVM-based virtualization platform. As
    a machine emulator, QEMU will be used so that we can create and run our virtual
    machines on any supported platform – be it as an emulator or virtualizer. We're
    going to focus our time on the second paradigm, which is using QEMU as a virtualizer.
    This means that we will be able to execute our virtual machine code directly on
    a hardware CPU below it, which means native or near-native performance and less
    overhead.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B14834_02_Final_ASB_ePub.xhtml#_idTextAnchor029)，*KVM作为虚拟化解决方案*中，我们开始讨论KVM、QEMU和各种其他实用程序，可以用来管理基于KVM的虚拟化平台。作为机器模拟器，QEMU将被用于在任何支持的平台上创建和运行我们的虚拟机
    - 无论是作为模拟器还是虚拟化器。我们将把时间集中在第二种范式上，即使用QEMU作为虚拟化器。这意味着我们将能够直接在其下方的硬件CPU上执行我们的虚拟机代码，这意味着本地或接近本地的性能和更少的开销。
- en: Bearing in mind that the overall KVM stack is built as a module, it shouldn't
    come as a surprise that QEMU also uses a modular approach. This has been a core
    principle in the Linux world for many years, which further boosts the efficiency
    of how we use our physical resources.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要牢记整体KVM堆栈是作为一个模块构建的，因此QEMU也采用了模块化的方法并不足为奇。多年来，这一点一直是Linux世界的核心原则，进一步提高了我们使用物理资源的效率。
- en: When we add libvirt as a management platform on top of QEMU, we get access to
    some cool new utilities such as the `virsh` command, which we can use to do virtual
    machine administration, virtual network administration, and a whole lot more.
    Some of the utilities that we're going to discuss later on in this book (for example,
    oVirt) use libvirt as a standardized set of libraries and utilities to make their
    GUI-magic possible – basically, they use libvirt as an API. There are other commands
    that we get access to for a variety of purposes. For example, we're going to use
    a command called `virt-host-validate` to check whether our server is compatible
    with KVM or not.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将libvirt作为QEMU的管理平台时，我们可以访问一些很酷的新实用程序，比如`virsh`命令，我们可以用它来进行虚拟机管理、虚拟网络管理等等。我们将在本书的后面讨论一些实用程序（例如oVirt），它们使用libvirt作为标准化的库和实用程序，使其GUI魔术成为可能
    - 基本上，它们使用libvirt作为API。我们还可以访问其他命令，用于各种目的。例如，我们将使用一个名为`virt-host-validate`的命令来检查我们的服务器是否与KVM兼容。
- en: Getting acquainted with oVirt
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉oVirt
- en: Bear in mind that most of the work that a sizeable percentage of Linux system
    administrators do is done via command-line utilities, libvirt, and KVM. They offer
    us a good set of tools to do everything that we need from the command line, as
    we're going to see in next part of this chapter. But also, we will get a *hint*
    as to what GUI-based administration can be like, as we're briefly going to discuss
    Virtual Machine Manager later in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，大多数Linux系统管理员所做的工作是通过命令行工具、libvirt和KVM完成的。它们为我们提供了一套良好的工具，可以在命令行中完成我们需要的一切，正如我们将在本章的后面部分看到的那样。但同时，我们也将对基于GUI的管理有所了解，因为我们稍后将简要讨论虚拟机管理器。
- en: However, that still doesn't cover a situation in which you have loads of KVM-based
    hosts, hundreds of virtual machines, dozens of virtual networks interconnecting
    them, and a rack full of storage devices that you need to integrate with your
    KVM environment. Using the aforementioned utilities is just going to introduce
    you to a world of pain as you scale your environment out. The primary reason for
    this is rather simple – we still haven't introduced any kind of *centralized*
    software package for managing KVM-based environments. When we say centralized,
    we mean that in a literal sense – we need some kind of software solution that
    can connect to multiple hypervisors and manage all of their capabilities, including
    network, storage, memory, and CPU or, what we sometimes refer to as the *four
    pillars of virtualization*. This kind of software would preferably have some kind
    of GUI interface from which we can *centrally* manage all of our KVM resources,
    because – well – we're all human. Quite a few of us prefer pictures to text, and
    interactivity to text-administration only, especially at scale.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仍然无法涵盖这样一种情况，即您拥有大量基于KVM的主机、数百台虚拟机、数十个相互连接的虚拟网络，以及一整个机架的存储设备，您需要将其集成到您的KVM环境中。使用上述实用程序只会在您扩展环境时给您带来痛苦。这主要原因相当简单-我们仍然没有引入任何一种*集中式*软件包来管理基于KVM的环境。当我们说集中式时，我们指的是字面意义上-我们需要一种可以连接到多个虚拟化程序并管理它们所有功能的软件解决方案，包括网络、存储、内存和CPU，或者我们有时所说的*虚拟化的四大支柱*。这种软件最好有某种GUI界面，我们可以从中*集中*管理我们所有的KVM资源，因为-嗯-我们都是人类。我们中有相当多的人更喜欢图片而不是文本，更喜欢交互而不是仅限于文本管理，尤其是在规模化时。
- en: This is where the oVirt project comes in. oVirt is an open source platform for
    the management of our KVM environment. It's a GUI-based tool that has a lot of
    moving parts in the background – the engine runs on a Java-based WildFly server
    (what used to be known as JBoss), the frontend uses a GWT toolkit, and so on.
    But all of them are there to make one thing possible – for us to manage a KVM-based
    environment from a centralized, web-based administration console.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是oVirt项目的用武之地。oVirt是一个用于管理我们的KVM环境的开源平台。它是一个基于GUI的工具，在后台有很多运行部件-引擎在基于Java的WildFly服务器上运行（以前被称为JBoss），前端使用GWT工具包等。但它们都是为了实现一件事-让我们能够从一个集中的、基于Web的管理控制台管理基于KVM的环境。
- en: From an administration standpoint, oVirt has two main building blocks – the
    engine (which we can connect to by using a GUI interface) and its agents (which
    are used to communicate with hosts). Let's describe their functionalities in brief.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从管理的角度来看，oVirt有两个主要的构建模块-引擎（我们可以通过GUI界面连接到）和其代理（用于与主机通信）。让我们简要描述它们的功能。
- en: The oVirt engine is the centralized service that can be used to perform anything
    that we need in a virtualized environment – manage virtual machines, move them,
    create images, storage administration, virtual network administration, and so
    on. This service is used to manage oVirt hosts and to do that, it needs to talk
    to something on those hosts. This is where the oVirt agent (vdsm) comes into play.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: oVirt引擎是一个集中式服务，可用于执行虚拟化环境中所需的任何操作-管理虚拟机、移动它们、创建镜像、存储管理、虚拟网络管理等。此服务用于管理oVirt主机，并且为此，它需要与主机上的某些东西进行通信。这就是oVirt代理（vdsm）发挥作用的地方。
- en: 'Some of the available advanced functionalities of the oVirt engine include
    the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: oVirt引擎的一些可用高级功能包括以下内容：
- en: Live migration of virtual machines
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机的实时迁移
- en: Image management
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像管理
- en: Export and import of virtual machines (OVF format)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机的导入和导出（OVF格式）
- en: '**Virtual-to-virtual conversion (V2V)**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟到虚拟转换（V2V）
- en: High availability (restart virtual machines from failed hosts on remaining hosts
    in the cluster)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高可用性（在集群中的剩余主机上重新启动虚拟机）
- en: Resource monitoring
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源监控
- en: Obviously, we need to deploy an oVirt agent and related utilities to our hosts,
    which are going to be the main part of our environment and a place where we will
    host everything – virtual machines, templates, virtual networks, and so on. For
    that purpose, oVirt uses a specific agent-based mechanism, via an agent called
    **vdsm**. This is an agent that we will deploy to our CentOS 8 hosts so that we
    can add them to oVirt's inventory, which, in turn, means that we can manage them
    by using the oVirt engine GUI. Vdsm is a Python-based agent that the oVirt engine
    uses so that it can directly communicate with a KVM host, and vdsm can then talk
    to the locally installed libvirt engine to do all the necessary operations. It's
    also used for configuration purposes as hosts need to be configured to be used
    in the oVirt environment in order to configure virtual networks, storage management
    and access, and so on. Also, vdsm has **Memory Overcommitment Manager** (**MOM**)
    integration so that it can efficiently manage memory on our virtualization hosts.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要在主机上部署oVirt代理和相关实用程序，这些主机将成为我们环境的主要部分，我们将在其中托管一切-虚拟机、模板、虚拟网络等。为此，oVirt使用了一种特定的基于代理的机制，通过一个名为vdsm的代理。这是一个我们将部署到我们的CentOS
    8主机上的代理，以便我们可以将它们添加到oVirt的清单中，进而意味着我们可以通过使用oVirt引擎GUI来管理它们。Vdsm是一个基于Python的代理，oVirt引擎使用它可以直接与KVM主机通信，然后vdsm可以与本地安装的libvirt引擎进行通信以执行所有必要的操作。它还用于配置目的，因为主机需要配置为在oVirt环境中使用，以配置虚拟网络、存储管理和访问等。此外，vdsm还具有内存过量管理器（MOM）集成，以便它可以有效地管理我们虚拟化主机上的内存。
- en: 'In graphical terms, this is what the architecture of oVirt looks like:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以图形方式来看，oVirt的架构如下所示：
- en: '![Figure 3.1 – The oVirt architecture (source: http://ovirt.org)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.1- oVirt架构（来源：http://ovirt.org）'
- en: '](img/B14834_03_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_03_01.jpg)'
- en: 'Figure 3.1 – The oVirt architecture (source: http://ovirt.org)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1- oVirt架构（来源：http://ovirt.org）
- en: We will take care of how to install oVirt in the next chapter. If you've ever
    heard or used a product called Red Hat Enterprise Virtualization, it might look
    very, very familiar.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中介绍如何安装oVirt。如果您曾听说过或使用过一个名为Red Hat Enterprise Virtualization的产品，那么它可能看起来非常熟悉。
- en: Installing QEMU, libvirt, and oVirt
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装QEMU、libvirt和oVirt
- en: 'Let''s start our discussion about installing QEMU, libvirt, and oVirt with
    some basic information:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些基本信息开始讨论安装QEMU、libvirt和oVirt：
- en: We're going to use CentOS 8 for everything in this book (apart from some bits
    and pieces that only support CentOS 7 as the last supported version at the time
    of writing).
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在本书中的所有内容中使用CentOS 8（除了一些仅支持CentOS 7的部分，因为在撰写本书时，CentOS 7是最后一个受支持的版本）。
- en: Our default installation profile is always going to be **Server with GUI**,
    with the premise being that we're going to cover both GUI and text-mode utilities
    to do almost everything that we're going to do in this book.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的默认安装配置文件始终是**带GUI的服务器**，前提是我们将覆盖几乎在本书中要做的所有事情的GUI和文本模式实用程序。
- en: Everything that we need to install on top of our default *Server with GUI* installation
    is going to be installed manually so that we have a complete, step-by-step guide
    for everything that we do.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在默认的*带GUI的服务器*安装之上手动安装所有内容，以便我们有一个完整的，一步一步的指南来完成所有操作。
- en: All the examples that we're going to cover in this book can be installed on
    a single physical server with 16 physical cores and 64 GB of memory. If you modify
    some numbers (number of cores assigned to virtual machines, amount of memory assigned
    to some virtual machines, and so on), you could do this with a 6-core laptop and
    16 GB of memory, provided that you're not running all the virtual machines all
    the time. If you shut the virtual machines down after you've completed this chapter
    and start the necessary ones in the next chapter, you'll be fine with that. In
    our case, we used a HP ProLiant DL380p Gen8, an easy-to-find, second-hand server
    – and a quite cheap one at that.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书中涵盖的所有示例都可以安装在一台具有16个物理核心和64GB内存的单个物理服务器上。如果您修改一些数字（分配给虚拟机的核心数、分配给某些虚拟机的内存量等），您可以使用一台6核笔记本电脑和16GB内存来完成这些操作，前提是您不会一直运行所有虚拟机。如果在完成本章后关闭虚拟机，并在下一章中启动必要的虚拟机，那么这样做是可以的。在我们的情况下，我们使用了一台HP
    ProLiant DL380p Gen8，这是一台易于找到的二手服务器 - 价格也相当便宜。
- en: 'After going through a basic installation of our server – selecting the installation
    profile, assigning network configuration and root password, and adding additional
    users (if we need them) – we''re faced with a system that we can''t do virtualization
    with because it doesn''t have all of the necessary utilities to run KVM virtual
    machines. So, the first thing that we''re going to do is a simple installation
    of the necessary modules and base applications so that we can check whether our
    server is compatible with KVM. So, log into your server as an administrative user
    and issue the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成了服务器的基本安装后 - 选择安装配置文件、分配网络配置和root密码，并添加额外用户（如果需要） - 我们面临着一个无法进行虚拟化的系统，因为它没有运行KVM虚拟机所需的所有必要工具。因此，我们要做的第一件事是简单安装必要的模块和基本应用程序，以便检查我们的服务器是否与KVM兼容。因此，请以管理员用户身份登录到服务器并发出以下命令：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We also need to tell the kernel that we''re going to use IOMMU. This is achieved
    by editing `/etc/default/grub` file, finding the `GRUB_CMDLINE_LINUX` and adding
    a statement at the end of this line:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要告诉内核我们将使用IOMMU。这可以通过编辑`/etc/default/grub`文件来实现，找到`GRUB_CMDLINE_LINUX`并在该行的末尾添加一条语句：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Don''t forget to add a single space before adding the line. Next step is reboot,
    so, we need to do:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加该行之前不要忘记添加一个空格。下一步是重新启动，所以我们需要执行：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By issuing these commands, we're installing all the necessary libraries and
    binaries to run our KVM-based virtual machines, as well as to use virt-manager
    (the GUI libvirt management utility) to manage our KVM virtualization server.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过发出这些命令，我们安装了运行基于KVM的虚拟机所需的所有必要库和二进制文件，以及使用virt-manager（GUI libvirt管理实用程序）来管理我们的KVM虚拟化服务器。
- en: Also, by adding the IOMMU configuration, we're making sure that our host sees
    the IOMMU and doesn't throw us an error when we use `virt-host-validate` command
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过添加IOMMU配置，我们确保我们的主机看到IOMMU，并在使用`virt-host-validate`命令时不会抛出错误
- en: 'After that, let''s check whether our host is compatible with all the necessary
    KVM requirements by issuing the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，让我们通过发出以下命令来检查我们的主机是否与所有必要的KVM要求兼容：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command goes through multiple tests to determine whether our server is
    compatible or not. We should get an output like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令经过多次测试，以确定我们的服务器是否兼容。我们应该得到这样的输出：
- en: '![Figure 3.2 – virt-host-validate output'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 - virt-host-validate输出'
- en: '](img/B14834_03_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_03_02.jpg)'
- en: Figure 3.2 – virt-host-validate output
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 - virt-host-validate输出
- en: 'This shows that our server is ready for KVM. So, the next step, now that all
    the necessary QEMU/libvirt utilities are installed, is to do some pre-flight checks
    to see whether everything that we installed was deployed correctly and works like
    it should. We will run the `virsh net-list` and `virsh list` commands to do this,
    as shown in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们的服务器已准备好用于KVM。因此，下一步是，既然所有必要的QEMU/libvirt实用程序都已安装，我们要进行一些预检查，以查看我们安装的所有内容是否部署正确，并且是否像应该那样工作。我们将运行`virsh
    net-list`和`virsh list`命令来执行此操作，如下面的屏幕截图所示：
- en: '![Figure 3.3 – Testing KVM virtual networks and listing the available virtual
    machines'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.3 - 测试KVM虚拟网络并列出可用的虚拟机'
- en: '](img/B14834_03_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_03_03.jpg)'
- en: Figure 3.3 – Testing KVM virtual networks and listing the available virtual
    machines
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 - 测试KVM虚拟网络并列出可用的虚拟机
- en: By using these two commands, we checked whether our virtualization host has
    a correctly configured default virtual network switch/bridge (more about this
    in the next chapter), as well as whether we have any virtual machines running.
    We have the default bridge and no virtual machines, so everything is as it should
    be.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这两个命令，我们检查了我们的虚拟化主机是否有正确配置的默认虚拟网络交换机/桥（关于这一点，我们将在下一章中详细介绍），以及我们是否有任何正在运行的虚拟机。我们有默认的桥接和没有虚拟机，所以一切都是正常的。
- en: Installing the first virtual machine in KVM
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在KVM中安装第一个虚拟机
- en: 'We can now start using our KVM virtualization server for its primary purpose
    – to run virtual machines. Let''s start by deploying a virtual machine on our
    host. For this purpose, we copied a CentOS 8.0 ISO file to our local folder called
    `/var/lib/libvirt/images`, which we''re going to use to create our first virtual
    machine. We can do that from the command line by using the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始使用我们的KVM虚拟化服务器来运行虚拟机。让我们从在我们的主机上部署一个虚拟机开始。为此，我们将一个CentOS 8.0 ISO文件复制到我们的本地文件夹`/var/lib/libvirt/images`，我们将使用它来创建我们的第一个虚拟机。我们可以通过使用以下命令从命令行执行此操作：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are some parameters here that might be a bit confusing. Let''s start
    with the `--os-variant` parameter, which describes which guest operating system
    you want to install by using the `virt-install` command. If you want to get a
    list of supported guest operating systems, run the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些可能有点令人困惑的参数。让我们从`--os-variant`参数开始，该参数描述了您想要使用`virt-install`命令安装的客户操作系统。如果您想获取受支持的客户操作系统列表，请运行以下命令：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `--network` parameter is related to our default virtual bridge (we mentioned
    this earlier). We definitely want our virtual machine to be network-connected,
    so we picked this parameter to make sure that it's network-connected out of the
    box.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`--network`参数与我们的默认虚拟桥有关（我们之前提到过这一点）。我们绝对希望我们的虚拟机能够连接到网络，因此我们选择了这个参数，以确保它在开箱即用时能够连接到网络。'
- en: After starting the `virt-install` command, we should be presented with a VNC
    console window to follow along with the installation procedure. We can then select
    the language used, keyboard, time and date, and installation destination (click
    on the selected disk and press **Done** in the top-left corner). We can also activate
    the network by going to **Network & Host Name**, clicking on the **OFF** button,
    selecting **Done** (which will then switch to the **ON** position), and connecting
    our virtual machine to the underlying network bridge (*default*). After that,
    we can press **Begin Installation** and let the installation process finish. While
    waiting for that to happen, we can click on **Root Password** and assign a root
    password for our administrative user.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动`virt-install`命令后，我们应该会看到一个VNC控制台窗口，以便跟随安装过程。然后我们可以选择使用的语言、键盘、时间和日期，以及安装目的地（点击所选磁盘，然后在左上角按**完成**）。我们还可以通过转到**网络和主机名**，点击**关闭**按钮，选择**完成**（然后会切换到**打开**位置），并将我们的虚拟机连接到底层网络桥（*默认*）来激活网络。之后，我们可以按**开始安装**，让安装过程完成。在等待过程中，我们可以点击**Root密码**为我们的管理用户分配一个root密码。
- en: If all of this seems a bit like *manual labor* to you, we feel your pain. Imagine
    having to deploy dozens of virtual machines and clicking on all these settings.
    We're not in the 19th century anymore, so there must be an easier way to do this.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些对您来说似乎有点像*手工劳动*，我们能理解您的痛苦。想象一下不得不部署数十个虚拟机并点击所有这些设置。我们已经不再处于19世纪，所以一定有更简单的方法来做这件事。
- en: Automating virtual machine installation
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化虚拟机安装
- en: By far, the simplest and the easiest way to do these things in a more *automatic*
    fashion would be to create and use something called a **kickstart** file. A kickstart
    file is basically a text configuration file that we can use to configure all the
    deployment settings of our server, regardless of whether we're talking about a
    physical or a virtual server. The only caveat is that kickstart files need to
    be pre-prepared and widely available – either on the network (web) or on a local
    disk. There are other options that are supported, but these are the most commonly
    used ones.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，以更*自动*的方式执行这些操作的最简单和最简单的方法是创建和使用一个称为**kickstart**文件。kickstart文件基本上是一个文本配置文件，我们可以使用它来配置服务器的所有部署设置，无论我们是在谈论物理服务器还是虚拟服务器。唯一的注意事项是kickstart文件需要预先准备并广泛可用-无论是在网络（web）上还是在本地磁盘上。还有其他支持的选项，但这些是最常用的选项。
- en: For our purpose, we're going to use a kickstart file that's available on the
    network (via the web server), but we're going to edit it a little bit so that
    it's usable, and leave it on our network where `virt-install` can use it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的目的，我们将使用一个在网络上（通过Web服务器）可用的kickstart文件，但我们将对其进行一些编辑，以使其可用，并将其留在我们的网络上，以便`virt-install`可以使用它。
- en: When we installed our physical server, as part of the installation process (called
    `anaconda`), a file was saved in our `/root` directory called `anaconda-ks.cfg`.
    This is a kickstart file that contains the complete deployment configuration of
    our physical server, which we can then use as a basis to create a new kickstart
    file for our virtual machines.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们安装物理服务器时，作为安装过程的一部分（称为`anaconda`），一个名为`anaconda-ks.cfg`的文件被保存在我们的`/root`目录中。这是一个kickstart文件，其中包含了我们的物理服务器的完整部署配置，我们可以以此为基础创建一个新的虚拟机的kickstart文件。
- en: 'The simplest way to do that in CentOS 7 was to deploy a utility called `system-config-kickstart`,
    which is not available anymore in CentOS 8\. There''s a replacement online utility
    at [https://access.redhat.com/labs/kickstartconfig/](https://access.redhat.com/labs/kickstartconfig/)
    called Kickstart Generator, but you need to have a Red Hat Customer Portal account
    for that one. So, if you don''t have that, you''re stuck with text-editing an
    existing kickstart file. It''s not very difficult, but it might take a bit of
    effort. The most important setting that we need to configure correctly is related
    to the *location* that we''re going to install our virtual machine from – on a
    network or from a local directory (as we did in our first `virt-install` example,
    by using a CentOS ISO from local disk). If we''re going to use an ISO file locally
    stored on the server, then it''s an easy configuration. First, we''re going to
    deploy the Apache web server so that we can host our kickstart file online (which
    will come in handy later). So, we need the following commands:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS 7中执行这个最简单的方法是部署一个名为`system-config-kickstart`的实用程序，在CentOS 8中不再可用。在[https://access.redhat.com/labs/kickstartconfig/](https://access.redhat.com/labs/kickstartconfig/)有一个在线替代实用程序称为Kickstart
    Generator，但您需要拥有Red Hat Customer Portal帐户。因此，如果您没有，您只能使用文本编辑现有的kickstart文件。这并不是很困难，但可能需要一些努力。我们需要正确配置的最重要的设置与我们将从中安装虚拟机的*位置*有关-是在网络上还是从本地目录（就像我们在第一个`virt-install`示例中所做的那样，使用本地磁盘上的CentOS
    ISO）。如果我们将在服务器上本地存储ISO文件，则这是一个简单的配置。首先，我们将部署Apache Web服务器，以便我们可以在线托管我们的kickstart文件（稍后会派上用场）。因此，我们需要以下命令：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Before we start the deployment process, use the vi editor (or any other editor
    you prefer) to edit the first configuration line in our kickstart file (`/var/www/html/ks.cfg`),
    which says something like `ignoredisk --only-use=sda`, to `ignoredisk --only-use=vda`.
    This is because virtual KVM machines don't use `sd*` naming for devices, but `vd`
    naming. This makes it easier for any administrator to figure out if they are administering
    a physical or a virtual server after connecting to it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始部署过程之前，使用vi编辑器（或您喜欢的任何其他编辑器）编辑我们的kickstart文件（`/var/www/html/ks.cfg`）中的第一行配置，该配置类似于`ignoredisk
    --only-use=sda`，改为`ignoredisk --only-use=vda`。这是因为虚拟KVM机器不使用`sd*`设备命名，而是使用`vd`命名。这样任何管理员在连接到服务器后就可以更容易地弄清楚他们是在管理物理服务器还是虚拟服务器。
- en: 'By editing the kickstart file and using these commands, we installed and started
    `httpd` (Apache web server). Then, we permanently started it so that it gets started
    after every next server reboot. Then, we copied our default kickstart file (`anaconda-ks.cfg`)
    to Apache''s `DocumentRoot` directory (the directory that Apache serves its files
    from) and changed permissions so that Apache can actually read that file when
    a client requests it. In our example, the *client* that''s going to use it is
    going to be the `virt-install` command. The server that we''re using to illustrate
    this feature has an IP address of `10.10.48.1`, which is what we''re going to
    use for our kickstart URL. Bear in mind that the default KVM bridge uses IP address
    `192.168.122.1`, which you can easily check with the `ip` command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编辑kickstart文件并使用这些命令，我们安装并启动了`httpd`（Apache Web服务器）。然后，我们永久启动它，以便在每次服务器重启后都启动它。然后，我们将默认的kickstart文件（`anaconda-ks.cfg`）复制到Apache的`DocumentRoot`目录（Apache提供文件的目录），并更改权限，以便Apache在客户端请求时实际读取该文件。在我们的示例中，将使用它的*客户端*是`virt-install`命令。我们用来说明这个特性的服务器的IP地址是`10.10.48.1`，这是我们将用于kickstart
    URL的地址。请注意，默认的KVM桥使用IP地址`192.168.122.1`，您可以使用`ip`命令轻松检查：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Also, there might be some firewall settings that will need to be changed on
    the physical server (accepting HTTP connections) so that the installer can successfully
    get the kickstart file. So, let''s try that. In this and the following examples,
    pay close attention to the `--vcpus` parameter (the number of virtual CPU cores
    for our virtual machine) as you might want to change that to your environment.
    In other words, if you don''t have 4 cores, make sure that you lower the core
    count. We are just using this as an example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可能需要更改一些防火墙设置，以便在物理服务器上成功获取kickstart文件（接受HTTP连接）。因此，让我们尝试一下。在这个和以下的示例中，要特别注意`--vcpus`参数（虚拟机的虚拟CPU核心数），因为您可能需要根据自己的环境进行更改。换句话说，如果您没有4个核心，请确保降低核心数量。我们只是以此作为示例：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Important note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please take note of the parameter that we changed. Here, we must use the `--location`
    parameter, not the `--cdrom` parameter, as we're injecting a kickstart configuration
    into the boot process (it's mandatory to do it this way).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们更改的参数。在这里，我们必须使用`--location`参数，而不是`--cdrom`参数，因为我们正在将kickstart配置注入到引导过程中（必须以这种方式执行）。
- en: After the deployment process is done, we should have two fully functional virtual
    machines called `MasteringKVM01` and `MasteringKVM02` on our server, ready to
    be used for our future demonstrations. The second virtual machine (`MasteringKVM02`)
    will have the same root password as the first one because we didn't change anything
    in the kickstart file except for the virtual disk option. So, after deployment,
    we can log into our `MasteringKVM02` machine by using the root username and password
    from the `MasteringKVM01` machine.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 部署过程完成后，我们应该在服务器上有两个名为`MasteringKVM01`和`MasteringKVM02`的完全功能的虚拟机，准备用于我们未来的演示。第二个虚拟机（`MasteringKVM02`）的根密码与第一个虚拟机相同，因为我们除了虚拟磁盘选项之外，没有更改kickstart文件中的任何内容。因此，在部署后，我们可以使用`MasteringKVM01`机器的根用户名和密码登录到我们的`MasteringKVM02`机器。
- en: 'If we wanted to take this a step further, we could create a shell script with
    a loop that''s going to automatically give unique names to virtual machines by
    using indexing. We can easily implement this by using a `for` loop and its counter:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想进一步发展，我们可以创建一个带有循环的shell脚本，该循环将使用索引自动为虚拟机提供唯一名称。我们可以通过使用`for`循环及其计数器轻松实现这一点：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When we execute this script (don't forget to `chmod` it to `755`!), we should
    get 10 virtual machines named `LoopVM1-LoopVM5`, all with the same settings, which
    includes the same root password.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行此脚本（不要忘记将其`chmod`为`755`！）时，我们应该会得到10个名为`LoopVM1-LoopVM5`的虚拟机，所有设置都相同，包括相同的root密码。
- en: 'If we''re using a GUI server installation, we can use GUI utilities to administer
    our KVM server. One of these utilities is called `virtual`, click on **Virtual
    Machine Manager**, and start using it. This is what Virtual Machine Manager looks
    like:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用GUI服务器安装，我们可以使用GUI实用程序来管理我们的KVM服务器。其中一个实用程序称为“virtual”，点击**虚拟机管理器**，然后开始使用它。虚拟机管理器的外观如下：
- en: '![Figure 3.4 – Virtual Machine Manager'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.4 – 虚拟机管理器'
- en: '](img/B14834_03_04.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_03_04.jpg)'
- en: Figure 3.4 – Virtual Machine Manager
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 虚拟机管理器
- en: Now that we've covered the basic command-line utilities (`virsh` and `virt-install`)
    and have a very simple-to-use GUI application (Virtual Machine Manager), let's
    move away from that perspective a bit and think about what we said about oVirt
    and managing a lot of hosts, virtual machines, networks, and storage devices.
    So, now, let's discuss how to install oVirt, which we will then use to manage
    our KVM-based environments in a much more centralized fashion.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了基本的命令行实用程序（`virsh`和`virt-install`），并且有一个非常简单易用的GUI应用程序（虚拟机管理器），让我们从这个角度转移一下，思考一下我们对oVirt和管理大量主机、虚拟机、网络和存储设备的看法。因此，现在让我们讨论如何安装oVirt，然后我们将使用它来以更集中的方式管理基于KVM的环境。
- en: Installing oVirt
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装oVirt
- en: 'There are different methods of installing oVirt. We can either deploy it as
    a self-hosted engine (via the Cockpit web interface or CLI) or as a standalone
    application via package-based installation. Let''s use the second way for this
    example – a standalone installation in a virtual machine. We''re going to split
    the installation into two parts:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 安装oVirt有不同的方法。我们可以将其部署为自托管引擎（通过Cockpit Web界面或CLI），也可以通过基于软件包的安装将其部署为独立应用程序。让我们以第二种方式为例-在虚拟机中进行独立安装。我们将安装分为两部分：
- en: Installing the oVirt engine for centralized management
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装oVirt引擎进行集中管理
- en: Deploying oVirt agents on our CentOS 8-based hosts
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的基于CentOS 8的主机上部署oVirt代理
- en: 'First, let''s deal with oVirt engine deployment. Deployment is simple enough,
    and people usually use one virtual machine for this purpose. Keeping in mind that
    CentOS 8 is not supported for oVirt, in our CentOS 8 virtual machine, we need
    to punch in a couple of commands:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们处理oVirt引擎部署。部署足够简单，人们通常使用一个虚拟机来实现这一目的。请记住，CentOS 8不支持oVirt，在我们的CentOS
    8虚拟机中，我们需要输入一些命令：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Again, this is just the installation part; we haven''t done any configuration
    as of yet. So, that''s our logical next step. We need to start a shell application
    called `engine-setup`, which is going to ask us 20 or so questions. They''re rather
    descriptive and explanations are actually provided by the engine setup directly,
    so these are the settings that we''ve used for our testing environment (FQDN will
    be different in your environment):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这只是安装部分；我们还没有进行任何配置。所以，这是我们的逻辑下一步。我们需要启动一个名为“engine-setup”的shell应用程序，它将询问我们大约20个问题。它们相当描述性，引擎设置直接提供了解释，所以这些是我们在测试环境中使用的设置（在您的环境中FQDN将不同）：
- en: '![Figure 3.5 – oVirt configuration settings'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5 – oVirt配置设置'
- en: '](img/B14834_03_05.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_03_05.jpg)'
- en: Figure 3.5 – oVirt configuration settings
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – oVirt配置设置
- en: 'After typing in `OK`, the engine setup will start. The end result should look
    something like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入“OK”后，引擎设置将开始。最终结果应该看起来像这样：
- en: '![Figure 3.6 – oVirt engine setup summary'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.6 – oVirt引擎设置摘要'
- en: '](img/B14834_03_06.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_03_06.jpg)'
- en: Figure 3.6 – oVirt engine setup summary
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – oVirt引擎设置摘要
- en: 'Now, we should be able to log into our oVirt engine by using a web browser
    and pointing it to the URL mentioned in the installation summary. During the installation
    process, we''re asked to provide a password for the `admin@internal` user – this
    is the oVirt administrative user that we''re going to use to manage our environment.
    The oVirt web interface is simple enough to use, and for the time being, we just
    need to log into the Administration Portal (a link is directly available on the
    oVirt engine web GUI before you try to log in). After logging in, we should be
    greeted with the oVirt GUI:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该能够通过使用Web浏览器并将其指向安装摘要中提到的URL来登录到我们的oVirt引擎。在安装过程中，我们被要求为“admin@internal”用户提供密码-这是我们将用来管理环境的oVirt管理用户。oVirt
    Web界面足够简单易用，目前我们只需要登录到管理门户（在尝试登录之前，oVirt引擎Web GUI上直接提供了一个链接）。登录后，我们应该会看到oVirt
    GUI：
- en: '![Figure 3.7 – oVirt Engine Administration Portal'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.7 – oVirt引擎管理门户'
- en: '](img/B14834_03_07.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_03_07.jpg)'
- en: Figure 3.7 – oVirt Engine Administration Portal
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 – oVirt引擎管理门户
- en: 'We have various tabs on the left-hand side of the screen – **Dashboard**, **Compute**,
    **Network**, **Storage**, and **Administration** – and each and every one of these
    has a specific purpose:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕左侧有各种选项卡-**仪表板**、**计算**、**网络**、**存储**和**管理**-每一个都有特定的用途：
- en: '**Dashboard**: The default landing page. It contains the most important information,
    a visual representation of the state of the health of our environment, and some
    basic information, including the amount of virtual data centers that we''re managing,
    clusters, hosts, data storage domains, and so on.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仪表板**：默认的着陆页面。它包含最重要的信息，环境健康状态的可视化表示，以及一些基本信息，包括我们正在管理的虚拟数据中心的数量、集群、主机、数据存储域等等。'
- en: '**Compute**: We go to this page to manage hosts, virtual machines, templates,
    pools, data centers, and clusters.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计算**：我们转到此页面以管理主机、虚拟机、模板、池、数据中心和集群。'
- en: '**Network**: We go to this page to manage our virtualized networks and profiles.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：我们转到此页面以管理我们的虚拟网络和配置文件。'
- en: '**Storage**: We go to this page to manage storage resources, including disks,
    volumes, domains, and data centers.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储**：我们可以在此页面上管理存储资源，包括磁盘、卷、域和数据中心。'
- en: '**Administration**: For the administration of users, quotas, and so on.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理**：用于管理用户、配额等。'
- en: We will deal with many more oVirt-related operations in [*Chapter 7*](B14834_07_Final_ASB_ePub.xhtml#_idTextAnchor125),
    *Virtual Machine – Installation, Configuration, and Life Cycle Management*, which
    is all about oVirt. But for the time being, let's keep the oVirt engine up and
    running so that we can come back to it later and use it for all of our day-to-day
    operations in our KVM-based virtualized environment.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第7章*](B14834_07_Final_ASB_ePub.xhtml#_idTextAnchor125)中处理更多与oVirt相关的操作，*虚拟机-安装、配置和生命周期管理*，这是关于oVirt的全部内容。但目前，让我们保持oVirt引擎运行，以便以后再次使用它，并在基于KVM的虚拟化环境中进行日常操作。
- en: Starting a virtual machine using QEMU and libvirt
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用QEMU和libvirt启动虚拟机
- en: 'After the deployment process, we can start managing our virtual machines. We
    will use `MasteringKVM01` and `MasteringKVM02` as an example. Let''s start them
    by using the `virsh` command, along with the `start` keyword:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 部署完成后，我们可以开始管理我们的虚拟机。我们将以`MasteringKVM01`和`MasteringKVM02`为例。让我们使用`virsh`命令和`start`关键字来启动它们：
- en: '![Figure 3.8 – Using the virsh start command'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8 - 使用virsh start命令'
- en: '](img/B14834_03_08.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_03_08.jpg)'
- en: Figure 3.8 – Using the virsh start command
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 - 使用virsh start命令
- en: 'Let''s say that we created all five of our virtual machines from the shell
    script example and that we left them powered on. We can easily check their status
    by issuing a simple `virsh list` command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从shell脚本示例中创建了所有五台虚拟机，并且将它们保持开机状态。我们可以通过发出简单的`virsh list`命令轻松检查它们的状态：
- en: '![Figure 3.9 – Using the virsh list command'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9 - 使用virsh list命令'
- en: '](img/B14834_03_09.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_03_09.jpg)'
- en: Figure 3.9 – Using the virsh list command
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 - 使用virsh list命令
- en: 'If we want to gracefully shut down the `MasteringKVM01` virtual machine, we
    can do so by using the `virsh shutdown` command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要优雅地关闭`MasteringKVM01`虚拟机，可以使用`virsh shutdown`命令：
- en: '![Figure 3.10 – Using the virsh shutdown command'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10 - 使用virsh shutdown命令'
- en: '](img/B14834_03_10.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_03_10.jpg)'
- en: Figure 3.10 – Using the virsh shutdown command
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 - 使用virsh shutdown命令
- en: 'If we want to forcefully shut down the `MasteringKVM02` virtual machine, we
    can do so by using the `virsh destroy` command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要强制关闭`MasteringKVM02`虚拟机，可以使用`virsh destroy`命令：
- en: '![Figure 3.11 – Using the virsh destroy command'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.11 - 使用virsh destroy命令'
- en: '](img/B14834_03_11.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_03_11.jpg)'
- en: Figure 3.11 – Using the virsh destroy command
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 - 使用virsh destroy命令
- en: 'If we want to completely remove a virtual machine (for example, `MasteringKVM02`),
    you''d normally shut it down first (gracefully or forcefully) and then use the
    `virsh undefine` command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要完全删除虚拟机（例如`MasteringKVM02`），通常需要先关闭它（优雅或强制），然后使用`virsh undefine`命令：
- en: '![Figure 3.12 – Using the virsh destroy and undefine commands'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.12 - 使用virsh destroy和undefine命令'
- en: '](img/B14834_03_12.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_03_12.jpg)'
- en: Figure 3.12 – Using the virsh destroy and undefine commands
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12 - 使用virsh destroy和undefine命令
- en: Bear in mind that you can actually do `virsh undefine` first, and then `destroy`,
    and that the end result is going to be the same. However, that may go against
    the *expected behavior* in which you first shut down an object before you actually
    remove it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您实际上可以先执行`virsh undefine`，然后再执行`destroy`，最终结果将是相同的。但是，这可能违反了*预期行为*，即您首先关闭对象，然后再删除它。
- en: We just learned how to use the `virsh` command to manage a virtual machine –
    start it and stop it – forcefully and gracefully. This will come in handy when
    we start extending our knowledge of using the `virsh` command in the following
    chapters, in which we're going to learn how to manage KVM networking and storage.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学会了如何使用`virsh`命令来管理虚拟机 - 启动和停止 - 强制和优雅。当我们开始扩展对`virsh`命令的使用知识时，这将会很有用，在接下来的章节中，我们将学习如何管理KVM网络和存储。
- en: 'We could do all these things from the GUI as well. As you may recall, earlier
    in this chapter, we installed a package called `virt-manager`. That''s actually
    a GUI application for managing your KVM host. Let''s use that to play with our
    virtual machines some more. This is the basic GUI interface of `virt-manager`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从GUI中完成所有这些操作。您可能还记得，在本章的前面，我们安装了一个名为`virt-manager`的软件包。实际上，这是一个用于管理KVM主机的GUI应用程序。让我们使用它来进一步操作我们的虚拟机。这是`virt-manager`的基本GUI界面：
- en: '![Figure 3.13 – The virt-manager GUI – we can see the list of registered'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.13 - virt-manager GUI - 我们可以看到已注册的'
- en: virtual machines and start managing them
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机并开始管理它们
- en: '](img/B14834_03_13.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_03_13.jpg)'
- en: Figure 3.13 – The virt-manager GUI – we can see the list of registered virtual
    machines and start managing them
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 - virt-manager GUI - 我们可以看到已注册的虚拟机列表并开始管理它们
- en: 'If we want to do our regular operations on a virtual machine – start, restart,
    shut down, turn off – we just need to right-click it and select that option from
    the menu. For all the operations to become visible, first, we must start a virtual
    machine; otherwise, only four actions are usable out of the available seven –
    `MasteringKVM01`, the list of available options is going to get quite a bit bigger:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想对虚拟机进行常规操作 - 启动、重启、关闭、关闭电源 - 我们只需要右键单击它，并从菜单中选择该选项。要使所有操作可见，首先我们必须启动虚拟机；否则，只有四个操作可用，而可用的七个操作中，`MasteringKVM01`的列表将变得更大：
- en: '![Figure 3.14 – The virt-manager options – after powering the virtual machine
    on,'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.14 - virt-manager选项 - 在虚拟机上电后，'
- en: we can now use many more options
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用更多选项
- en: '](img/B14834_03_14.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_03_14.jpg)'
- en: Figure 3.14 – The virt-manager options – after powering the virtual machine
    on, we can now use many more options
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14 - virt-manager选项 - 在虚拟机上电后，我们现在可以使用更多选项
- en: We will use `virt-manager` for various operations throughout this book, so make
    sure that you familiarize yourself with it. It is going to make our administrative
    jobs quite a bit easier in many situations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中的各种操作中使用`virt-manager`，所以请确保您熟悉它。在许多情况下，它将使我们的管理工作变得更加容易。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we laid some basic groundwork and prerequisites for practically
    everything that we're going to do in the remaining chapters of this book. We learned
    how to install KVM and a libvirt stack. We also learned how to deploy oVirt as
    a GUI tool to manage our KVM hosts.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为本书剩余章节中要做的几乎所有事情奠定了一些基本的基础和先决条件。我们学会了如何安装KVM和libvirt堆栈。我们还学会了如何部署oVirt作为管理我们的KVM主机的GUI工具。
- en: The next few chapters will take us in a more technical direction as we will
    cover networking and storage concepts. In order to do that, we will have to take
    a step back and learn or review our previous knowledge about networking and storage
    as these are extremely important concepts for virtualization, and especially the
    cloud.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几章将带领我们走向更加技术化的方向，我们将涵盖网络和存储概念。为了做到这一点，我们将不得不退一步，学习或复习我们之前关于网络和存储的知识，因为这些对于虚拟化，特别是云计算来说是非常重要的概念。
- en: Questions
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How can we validate whether our host is compatible with the KVM requirements?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何验证我们的主机是否与KVM要求兼容？
- en: What's the name of oVirt's default landing page?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: oVirt的默认登陆页面是什么？
- en: Which command can we use to manage virtual machines from the command line?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪个命令从命令行管理虚拟机？
- en: Which command can we use to deploy virtual machines from the command line?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪个命令从命令行部署虚拟机？
- en: Further reading
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Please refer to the following links for more information regarding what was
    covered in this chapter:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下链接，了解本章涵盖的更多信息：
- en: 'Kickstart Generator: [https://access.redhat.com/labs/kickstartconfig/](https://access.redhat.com/labs/kickstartconfig/).
    Just to remind you, you need to have a RedHat support account to access this link.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Kickstart Generator: [https://access.redhat.com/labs/kickstartconfig/](https://access.redhat.com/labs/kickstartconfig/).
    只是提醒您，您需要拥有RedHat支持帐户才能访问此链接。'
- en: 'oVirt: [https://www.ovirt.org/](https://www.ovirt.org/).'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'oVirt: [https://www.ovirt.org/](https://www.ovirt.org/).'
