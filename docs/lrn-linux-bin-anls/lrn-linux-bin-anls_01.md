# 第一章：Linux 环境及其工具

在本章中，我们将重点关注与本书主题相关的 Linux 环境。由于本书专注于 Linux 二进制文件分析，因此利用 Linux 提供的本地环境工具并且每个人都可以访问是有意义的。Linux 已经预装了无处不在的 binutils，但是它们也可以在[`www.gnu.org/software/binutils/`](http://www.gnu.org/software/binutils/)找到。它们包含了大量对二进制文件分析和黑客行为有用的工具。这不是另一本关于使用 IDA Pro 的书。IDA 是无疑是最好的通用软件，用于反向工程二进制文件，我鼓励根据需要使用它，但是在本书中我们不会使用它。相反，您将学会如何在几乎任何 Linux 系统上开始使用已经可访问的环境进行二进制文件的黑客行为。因此，您可以学会欣赏 Linux 作为一个真正的黑客环境，其中有许多免费工具可用。在整本书中，我们将演示各种工具的使用，并随着每一章的进展对如何使用它们进行回顾。然而，让本章作为 Linux 环境中这些工具和技巧的入门或参考。如果您已经非常熟悉 Linux 环境及其用于反汇编、调试和解析 ELF 文件的工具，那么您可以简单地跳过本章。

# Linux 工具

在本书中，我们将使用各种任何人都可以访问的免费工具。本节将为您简要介绍其中一些工具。

## GDB

GNU 调试器（GDB）不仅用于调试有错误的应用程序。它还可以用于了解程序的控制流，改变程序的控制流，并修改代码、寄存器和数据结构。这些任务对于一个正在利用软件漏洞或揭示复杂病毒内部运作的黑客来说是很常见的。GDB 适用于 ELF 二进制文件和 Linux 进程。它是 Linux 黑客的必备工具，并将在本书的各个示例中使用。

## 来自 GNU binutils 的 Objdump

对象转储（objdump）是一个快速反汇编代码的简单干净的解决方案。它非常适合反汇编简单且未被篡改的二进制文件，但是当尝试用它进行任何真正具有挑战性的逆向工程任务时，特别是针对敌对软件时，它很快就会显示出其局限性。它的主要弱点在于它依赖于`ELF`部分头，并且不执行控制流分析，这两个限制大大降低了它的鲁棒性。这导致无法正确地反汇编二进制文件中的代码，甚至在没有部分头的情况下根本无法打开二进制文件。然而，对于许多常规任务来说，它应该足够了，比如反汇编未加固、剥离或以任何方式混淆的常见二进制文件。它可以读取所有常见的`ELF`类型。以下是一些使用`objdump`的常见示例：

+   查看`ELF`文件中每个部分的所有数据/代码：

```
objdump -D <elf_object>

```

+   仅查看`ELF`文件中的程序代码：

```
objdump -d <elf_object>

```

+   查看所有符号：

```
objdump -tT <elf_object>

```

我们将在第二章中深入探讨`objdump`和其他工具，*ELF 二进制格式*。

## 来自 GNU binutils 的 Objcopy

对象复制（Objcopy）是一个非常强大的小工具，我们无法用简单的摘要来总结。我建议您阅读手册页以获取完整的描述。`Objcopy`可以用于分析和修改任何类型的`ELF`对象，尽管它的一些功能是特定于某些类型的`ELF`对象的。`Objcopy`通常用于修改或复制`ELF`二进制文件中的`ELF`部分。

要将`.data`节从一个`ELF`对象复制到一个文件，使用以下命令：

```
objcopy –only-section=.data <infile> <outfile>

```

`objcopy`工具将在本书的其余部分中根据需要进行演示。只需记住它的存在，它可以成为 Linux 二进制黑客非常有用的工具。

## strace

系统调用跟踪（strace）是一种基于`ptrace(2)`系统调用的工具，它利用循环中的`PTRACE_SYSCALL`请求来显示运行程序中系统调用（也称为`syscalls`）活动的信息，以及执行过程中捕获的信号。这个程序对于调试非常有用，或者只是收集运行时调用了哪些`syscalls`的信息。

这是用于跟踪基本程序的`strace`命令：

```
strace /bin/ls -o ls.out

```

用于附加到现有进程的`strace`命令如下：

```
strace -p <pid> -o daemon.out

```

初始输出将显示每个以文件描述符作为参数的系统调用的文件描述符号码，例如：

```
SYS_read(3, buf, sizeof(buf));

```

如果你想看到所有被读入文件描述符 3 的数据，你可以运行以下命令：

```
strace -e read=3 /bin/ls

```

您还可以使用`-e write=fd`来查看写入的数据。`strace`工具是一个非常好的小工具，您肯定会找到许多使用它的理由。

## ltrace

**库跟踪**（ltrace）是另一个非常有用的小工具，它与`strace`非常相似。它的工作方式类似，但它实际上解析了程序的共享库链接信息，并打印正在使用的库函数。

## 基本的 ltrace 命令

您可以使用`-S`标志在库函数调用之外看到系统调用。`ltrace`命令旨在提供更细粒度的信息，因为它解析可执行文件的动态段，并打印来自共享和静态库的实际符号/函数：

```
ltrace <program> -o program.out

```

## ftrace

**函数跟踪**（ftrace）是我设计的一个工具。它类似于`ltrace`，但它还显示了二进制本身内部函数的调用。我在 Linux 中找不到其他公开可用的工具可以做到这一点，所以我决定编写一个。这个工具可以在[`github.com/elfmaster/ftrace`](https://github.com/elfmaster/ftrace)找到。下一章将演示这个工具。

## readelf

`readelf`命令是解剖`ELF`二进制文件的最有用的工具之一。它提供了关于`ELF`的每一点数据，这些数据对于在逆向工程之前收集有关对象的信息是必要的。这个工具将在本书中经常使用，以收集有关符号、段、节、重定位条目、数据的动态链接等信息。`readelf`命令是`ELF`的瑞士军刀。我们将根据需要深入讨论它，在第二章*ELF 二进制格式*中，但以下是它最常用的一些标志：

+   要检索节头表：

```
readelf -S <object>

```

+   要检索程序头表：

```
readelf -l <object>

```

+   要检索符号表：

```
readelf -s <object>

```

+   要检索`ELF`文件头数据：

```
readelf -e <object>

```

+   要检索重定位条目：

```
readelf -r <object>

```

+   要检索动态段：

```
readelf -d <object>

```

## ERESI - ELF 逆向工程系统接口

ERESI 项目（[`www.eresi-project.org`](http://www.eresi-project.org)）包含许多工具，这些工具是 Linux 二进制黑客的梦想。不幸的是，其中许多工具没有得到更新，并且与 64 位 Linux 不完全兼容。但是，它们确实适用于各种架构，并且无疑是用于黑客`ELF`二进制的最具创新性的工具集。因为我个人对使用 ERESI 项目的工具并不是很熟悉，而且它们已经不再得到更新，所以我不会在本书中探讨它们的能力。但是，请注意，有两篇 Phrack 文章展示了 ERESI 工具的创新和强大功能：

+   Cerberus ELF 接口（[`www.phrack.org/archives/issues/61/8.txt`](http://www.phrack.org/archives/issues/61/8.txt)）

+   嵌入式 ELF 调试（[`www.phrack.org/archives/issues/63/9.txt`](http://www.phrack.org/archives/issues/63/9.txt)）

# 有用的设备和文件

Linux 有许多文件、设备和`/proc`条目对于热衷于黑客和逆向工程师非常有帮助。在本书中，我们将演示许多这些文件的用处。以下是本书中经常使用的一些文件的描述。

## /proc/<pid>/maps

`/proc/<pid>/maps`文件通过显示每个内存映射来包含进程映像的布局。这包括可执行文件、共享库、堆栈、堆、VDSO 等。这个文件对于能够快速解析进程地址空间的布局至关重要，并且在本书中多次使用。

## /proc/kcore

`/proc/kcore`是`proc`文件系统中的一个条目，它充当 Linux 内核的动态核心文件。也就是说，它是内存的原始转储，以`ELF`核心文件的形式呈现，可以被 GDB 用于调试和分析内核。我们将在第九章 *Linux /proc/kcore 分析*中深入探讨`/proc/kcore`。

## /boot/System.map

这个文件几乎在所有 Linux 发行版上都可以找到，对内核黑客非常有用。它包含整个内核的每个符号。

## /proc/kallsyms

`kallsyms`与`System.map`非常相似，只是它是一个`/proc`条目，这意味着它由内核维护并动态更新。因此，如果安装了任何新的 LKM，符号将会即时添加到`/proc/kallsyms`中。`/proc/kallsyms`至少包含内核中的大部分符号，如果在`CONFIG_KALLSYMS_ALL`内核配置中指定，将包含所有符号。

## /proc/iomem

`iomem`是一个有用的 proc 条目，它与`/proc/<pid>/maps`非常相似，但是适用于系统内存的所有部分。例如，如果你想知道内核的文本段在物理内存中的映射位置，你可以搜索`Kernel`字符串，你将看到`code/text`段、数据段和`bss`段：

```
 $ grep Kernel /proc/iomem
 01000000-016d9b27 : Kernel code
 016d9b28-01ceeebf : Kernel data
 01df0000-01f26fff : Kernel bss

```

## ECFS

扩展核心文件快照（ECFS）是一种专门为进程映像的高级取证分析而设计的特殊核心转储技术。该软件的代码可以在[`github.com/elfmaster/ecfs`](https://github.com/elfmaster/ecfs)找到。此外，第八章 *ECFS – 扩展核心文件快照技术*，专门解释了 ECFS 是什么以及如何使用它。对于那些对高级内存取证感兴趣的人，你会想要仔细关注这一点。

# 与链接器相关的环境变量

动态加载器/链接器和链接概念是程序链接和执行过程中不可避免的组成部分。在本书中，你将学到很多关于这些主题的知识。在 Linux 中，有很多方法可以改变动态链接器的行为，可以为二进制黑客提供很多帮助。随着我们在本书中的学习，你将开始理解链接、重定位和动态加载（程序解释器）的过程。以下是一些与链接器相关的属性，它们是有用的，并将在本书中使用。

## LD_PRELOAD 环境变量

`LD_PRELOAD`环境变量可以设置为指定在任何其他库之前应动态链接的库路径。这样做的效果是允许预加载库中的函数和符号覆盖之后链接的其他库中的函数和符号。这实质上允许您通过重定向共享库函数来执行运行时修补。正如我们将在后面的章节中看到的，这种技术可以用于绕过反调试代码和用户态 rootkit。

## LD_SHOW_AUXV 环境变量

这个环境变量告诉程序加载器在运行时显示程序的辅助向量。辅助向量是放置在程序堆栈上的信息（由内核的`ELF`加载例程放置），其中包含传递给动态链接器的有关程序的某些信息。我们将在第三章中更仔细地研究这一点，*Linux Process Tracing*，但这些信息可能对逆向和调试有用。例如，如果您想获取进程映像中 VDSO 页面的内存地址（也可以从`maps`文件中获取，如前所示），您必须寻找`AT_SYSINFO`。

以下是使用`LD_SHOW_AUXV`的辅助向量的示例：

```
$ LD_SHOW_AUXV=1 whoami
AT_SYSINFO: 0xb7779414
AT_SYSINFO_EHDR: 0xb7779000
AT_HWCAP: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2
AT_PAGESZ: 4096
AT_CLKTCK: 100
AT_PHDR:  0x8048034
AT_PHENT: 32
AT_PHNUM: 9
AT_BASE:  0xb777a000
AT_FLAGS: 0x0
AT_ENTRY: 0x8048eb8
AT_UID:  1000
AT_EUID: 1000
AT_GID:  1000
AT_EGID: 1000
AT_SECURE: 0
AT_RANDOM: 0xbfb4ca2b
AT_EXECFN: /usr/bin/whoami
AT_PLATFORM: i686
elfmaster

```

辅助向量将在第二章中更深入地介绍，*The ELF Binary Format*。

## 链接器脚本

链接器脚本对我们来说是一个关注点，因为它们由链接器解释，并帮助塑造程序的布局，涉及到节、内存和符号。默认的链接器脚本可以通过`ld -verbose`查看。

`ld`链接程序有一个完整的语言，当它接受输入文件（如可重定位目标文件、共享库和头文件）时，它会解释这种语言，并使用这种语言来确定输出文件，如可执行程序，将如何组织。例如，如果输出是一个`ELF`可执行文件，链接器脚本将帮助确定布局和哪些段中存在哪些节。另一个例子是：`.bss`节总是在数据段的末尾；这是由链接器脚本确定的。您可能想知道这对我们来说有什么意义。嗯！首先，重要的是在编译时对链接过程有一些了解。`gcc`依赖于链接器和其他程序来执行这项任务，在某些情况下，能够控制可执行文件的布局是很重要的。`ld`命令语言是一种非常深入的语言，超出了本书的范围，但值得一看。在逆向工程可执行文件时，要记住，常见的段地址有时可能会被修改，布局的其他部分也可能会被修改。这表明涉及自定义链接器脚本。可以使用`gcc`的`-T`标志指定链接器脚本。我们将在第五章中看一个使用链接器脚本的具体例子，*Linux Binary Protection*。

# 总结

我们刚刚简要介绍了 Linux 环境的一些基本方面和每章演示中最常用的工具。二进制分析在很大程度上是关于了解可用的工具和资源以及它们如何相互配合。我们只是简要介绍了这些工具，但随着我们在接下来的章节中探索 Linux 二进制黑客的广阔世界，我们将有机会强调每个工具的能力。在下一章中，我们将深入探讨 ELF 二进制格式的内部，并涵盖许多有趣的主题，如动态链接、重定位、符号、节等。
