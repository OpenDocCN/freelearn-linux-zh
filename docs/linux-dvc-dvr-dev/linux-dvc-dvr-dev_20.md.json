["```\n#include <linux/platform_device.h> \n#include <linux/regulator/driver.h> \n#include <linux/regulator/of_regulator.h> \n```", "```\nstruct regulator_desc { \n   const char *name; \n   const char *of_match; \n\n   int id; \n   unsigned n_voltages; \n   const struct regulator_ops *ops; \n   int irq; \n   enum regulator_type type; \n   struct module *owner; \n\n   unsigned int min_uV; \n   unsigned int uV_step; \n}; \n```", "```\nstruct regulation_constraints { \n   const char *name; \n\n   /* voltage output range (inclusive) - for voltage control */ \n   int min_uV; \n   int max_uV; \n\n   int uV_offset; \n\n   /* current output range (inclusive) - for current control */ \n   int min_uA; \n   int max_uA; \n\n   /* valid regulator operating modes for this machine */ \n   unsigned int valid_modes_mask; \n\n   /* valid operations for regulator on this machine */ \n   unsigned int valid_ops_mask; \n\n   struct regulator_state state_disk; \n   struct regulator_state state_mem; \n   struct regulator_state state_standby; \n   suspend_state_t initial_state; /* suspend state to set at init */ \n\n   /* mode to set on startup */ \n   unsigned int initial_mode; \n\n   /* constraint flags */ \n   unsigned always_on:1;   /* regulator never off when system is on */ \n   unsigned boot_on:1;     /* bootloader/firmware enabled regulator */ \n   unsigned apply_uV:1;    /* apply uV constraint if min == max */ \n}; \n```", "```\nstruct regulator_init_data { \n   struct regulation_constraints constraints; \n\n   /* optional regulator machine specific init */ \n   int (*regulator_init)(void *driver_data); \n   void *driver_data;      /* core does not touch this */ \n}; \n```", "```\nstatic struct regulator_init_data isl_init_data[] = { \n    [0] = { \n                .constraints = { \n                    .name           = \"Core Buck\", \n                    .min_uV         = 850000, \n                    .max_uV         = 1600000, \n                    .valid_modes_mask   = REGULATOR_MODE_NORMAL \n                                | REGULATOR_MODE_STANDBY, \n                    .valid_ops_mask     = REGULATOR_CHANGE_MODE \n                                | REGULATOR_CHANGE_STATUS, \n                }, \n        }, \n    [1] = { \n                .constraints = { \n                    .name           = \"LDO1\", \n                    .min_uV         = 1100000, \n                    .max_uV         = 1100000, \n                    .always_on      = true, \n                    .valid_modes_mask   = REGULATOR_MODE_NORMAL \n                                | REGULATOR_MODE_STANDBY, \n                    .valid_ops_mask     = REGULATOR_CHANGE_MODE \n                                | REGULATOR_CHANGE_STATUS, \n                }, \n        }, \n    [2] = { \n                .constraints = { \n                    .name           = \"LDO2\", \n                    .min_uV         = 1300000, \n                    .max_uV         = 1300000, \n                    .always_on      = true, \n                    .valid_modes_mask   = REGULATOR_MODE_NORMAL \n                                | REGULATOR_MODE_STANDBY, \n                    .valid_ops_mask     = REGULATOR_CHANGE_MODE \n                                | REGULATOR_CHANGE_STATUS, \n                }, \n        }, \n}; \n```", "```\nstruct of_regulator_match { \n   const char *name; \n   void *driver_data; \n   struct regulator_init_data *init_data; \n   struct device_node *of_node; \n   const struct regulator_desc *desc; \n}; \n```", "```\nisl6271a@3c { \n   compatible = \"isl6271a\"; \n   reg = <0x3c>; \n   interrupts = <0 86 0x4>; \n\n    /* supposing our regulator is powered by another regulator */ \n   in-v1-supply = <&some_reg>; \n   [...] \n\n   regulators { \n         reg1: core_buck { \n               regulator-name = \"Core Buck\"; \n               regulator-min-microvolt = <850000>; \n               regulator-max-microvolt = <1600000>; \n         }; \n\n         reg2: ldo1 { \n               regulator-name = \"LDO1\"; \n               regulator-min-microvolt = <1100000>; \n               regulator-max-microvolt = <1100000>; \n               regulator-always-on; \n         }; \n\n         reg3: ldo2 { \n               regulator-name = \"LDO2\"; \n               regulator-min-microvolt = <1300000>; \n               regulator-max-microvolt = <1300000>; \n               regulator-always-on; \n         }; \n   }; \n}; \n```", "```\nstruct regulator_config { \n   struct device *dev; \n   const struct regulator_init_data *init_data; \n   void *driver_data; \n   struct device_node *of_node; \n}; \n```", "```\nstruct regulator_ops { \n   /* enumerate supported voltages */ \n   int (*list_voltage) (struct regulator_dev *, \n                        unsigned selector); \n\n   /* get/set regulator voltage */ \n   int (*set_voltage) (struct regulator_dev *, \n                        int min_uV, int max_uV, \n                        unsigned *selector); \n   int (*map_voltage)(struct regulator_dev *, \n                       int min_uV, int max_uV); \n   int (*set_voltage_sel) (struct regulator_dev *, \n                           unsigned selector); \n   int (*get_voltage) (struct regulator_dev *); \n   int (*get_voltage_sel) (struct regulator_dev *); \n\n   /* get/set regulator current  */ \n   int (*set_current_limit) (struct regulator_dev *, \n                          int min_uA, int max_uA); \n   int (*get_current_limit) (struct regulator_dev *); \n\n   int (*set_input_current_limit) (struct regulator_dev *, \n                                   int lim_uA); \n   int (*set_over_current_protection) (struct regulator_dev *); \n   int (*set_active_discharge) (struct regulator_dev *, \n                                bool enable); \n\n   /* enable/disable regulator */ \n   int (*enable) (struct regulator_dev *); \n   int (*disable) (struct regulator_dev *); \n   int (*is_enabled) (struct regulator_dev *); \n\n   /* get/set regulator operating mode (defined in consumer.h) */ \n   int (*set_mode) (struct regulator_dev *, unsigned int mode); \n   unsigned int (*get_mode) (struct regulator_dev *); \n}; \n```", "```\nint rdev_get_id(struct regulator_dev *rdev) \n```", "```\nstruct regulator_dev * regulator_register(const struct regulator_desc           *regulator_desc, const struct regulator_config *cfg) \n```", "```\nvoid regulator_unregister(struct regulator_dev *rdev) \n```", "```\nstatic int __devexit isl6271a_remove(struct i2c_client *i2c) \n{ \n   struct isl_pmic *pmic = i2c_get_clientdata(i2c); \n   int i; \n\n   for (i = 0; i < 3; i++) \n         regulator_unregister(pmic->rdev[i]); \n\n   kfree(pmic); \n   return 0; \n} \n```", "```\nstruct isl_pmic { \n   struct i2c_client *client; \n   struct regulator_dev    *rdev[3]; \n   struct mutex            mtx; \n}; \n```", "```\nstatic int isl6271a_get_voltage_sel(struct regulator_dev *rdev) \n{ \n   struct isl_pmic *pmic = rdev_get_drvdata(dev); \n   int idx = rdev_get_id(rdev); \n   idx = i2c_smbus_read_byte(pmic->client); \n   if (idx < 0) \n         [...] /* handle this error */ \n\n   return idx; \n} \n```", "```\nstatic int isl6271a_set_voltage_sel( \nstruct regulator_dev *dev, unsigned selector) \n{ \n   struct isl_pmic *pmic = rdev_get_drvdata(dev); \n   int err; \n\n   err = i2c_smbus_write_byte(pmic->client, selector); \n   if (err < 0) \n         [...] /* handle this error */ \n\n   return err; \n} \n```", "```\nstatic struct regulator_ops isl_core_ops = { \n   .get_voltage_sel = isl6271a_get_voltage_sel, \n   .set_voltage_sel = isl6271a_set_voltage_sel, \n   .list_voltage     = regulator_list_voltage_linear, \n   .map_voltage      = regulator_map_voltage_linear, \n}; \n\nstatic struct regulator_ops isl_fixed_ops = { \n   .list_voltage     = regulator_list_voltage_linear, \n}; \n```", "```\nstatic const struct regulator_desc isl_rd[] = { \n   { \n         .name       = \"Core Buck\", \n         .id         = 0, \n         .n_voltages = 16, \n         .ops        = &isl_core_ops, \n         .type       = REGULATOR_VOLTAGE, \n         .owner            = THIS_MODULE, \n         .min_uV     = ISL6271A_VOLTAGE_MIN, \n         .uV_step    = ISL6271A_VOLTAGE_STEP, \n   }, { \n         .name       = \"LDO1\", \n         .id         = 1, \n         .n_voltages = 1, \n         .ops        = &isl_fixed_ops, \n         .type       = REGULATOR_VOLTAGE, \n         .owner            = THIS_MODULE, \n         .min_uV     = 1100000, \n   }, { \n         .name       = \"LDO2\", \n         .id         = 2, \n         .n_voltages = 1, \n         .ops        = &isl_fixed_ops, \n         .type       = REGULATOR_VOLTAGE, \n         .owner            = THIS_MODULE, \n         .min_uV     = 1300000, \n   }, \n}; \n```", "```\nstatic struct of_regulator_match isl6271a_matches[] = { \n   { .name = \"core_buck\",  }, \n   { .name = \"ldo1\",       }, \n   { .name = \"ldo2\",       }, \n}; \n```", "```\nstatic int isl6271a_probe(struct i2c_client *i2c, \n                          const struct i2c_device_id *id) \n{ \nstruct regulator_config config = { }; \nstruct regulator_init_data *init_data     = \ndev_get_platdata(&i2c->dev); \nstruct isl_pmic *pmic; \nint i, ret; \n\n    struct device *dev = &i2c->dev; \n    struct device_node *np, *parent; \n\n   if (!i2c_check_functionality(i2c->adapter, \n                     I2C_FUNC_SMBUS_BYTE_DATA)) \n         return -EIO; \n\n   pmic = devm_kzalloc(&i2c->dev, \nsizeof(struct isl_pmic), GFP_KERNEL); \n   if (!pmic) \n         return -ENOMEM; \n\n    /* Get the device (PMIC) node */ \n    np = of_node_get(dev->of_node); \n   if (!np) \n         return -EINVAL; \n\n    /* Get 'regulators' subnode */ \n    parent = of_get_child_by_name(np, \"regulators\"); \n   if (!parent) { \n         dev_err(dev, \"regulators node not found\\n\"); \n         return -EINVAL; \n   } \n\n    /* fill isl6271a_matches array */ \n    ret = of_regulator_match(dev, parent, isl6271a_matches, \n                            ARRAY_SIZE(isl6271a_matches)); \n\n    of_node_put(parent); \n   if (ret < 0) { \n         dev_err(dev, \"Error parsing regulator init data: %d\\n\", \n               ret); \n         return ret; \n   } \n\n   pmic->client = i2c; \n   mutex_init(&pmic->mtx); \n\n   for (i = 0; i < 3; i++) { \n        struct regulator_init_data *init_data; \n         struct regulator_desc *desc; \n         int val; \n\n         if (pdata) \n               /* Given as platform data */ \n               config.init_data = pdata->init_data[i]; \n         else \n               /* Fetched from device tree */ \n               config.init_data = isl6271a_matches[i].init_data; \n\n         config.dev = &i2c->dev; \nconfig.of_node = isl6271a_matches[i].of_node; \nconfig.ena_gpio = -EINVAL; \n\n         /* \n          * config is passed by reference because the kernel \n          * internally duplicate it to create its own copy \n          * so that it can override some fields \n          */ \n         pmic->rdev[i] = devm_regulator_register(&i2c->dev, \n                                 &isl_rd[i], &config); \n         if (IS_ERR(pmic->rdev[i])) { \n               dev_err(&i2c->dev, \"failed to register %s\\n\", \nid->name); \n               return PTR_ERR(pmic->rdev[i]); \n         } \n   } \n   i2c_set_clientdata(i2c, pmic); \n   return 0; \n} \n```", "```\n/* Only the first regulator actually need it */ \nif (i == 0) \n    if(pdata) \n            config.init_data = init_data; /* pdata */ \n      else \n            isl6271a_matches[i].init_data; /* DT */ \nelse \n    config.init_data = NULL; \n```", "```\n#include <linux/init.h> \n#include <linux/module.h> \n#include <linux/kernel.h> \n#include <linux/platform_device.h>      /* For platform devices */ \n#include <linux/interrupt.h>            /* For IRQ */ \n#include <linux/of.h>                   /* For DT*/ \n#include <linux/err.h> \n#include <linux/regulator/driver.h> \n#include <linux/regulator/machine.h> \n\n#define DUMMY_VOLTAGE_MIN    850000 \n#define DUMMY_VOLTAGE_MAX    1600000 \n#define DUMMY_VOLTAGE_STEP   50000 \n\nstruct my_private_data { \n    int foo; \n    int bar; \n    struct mutex lock; \n}; \n\nstatic const struct of_device_id regulator_dummy_ids[] = { \n    { .compatible = \"packt,regulator-dummy\", }, \n    { /* sentinel */ } \n}; \n\nstatic struct regulator_init_data dummy_initdata[] = { \n    [0] = { \n        .constraints = { \n            .always_on = 0, \n            .min_uV = DUMMY_VOLTAGE_MIN, \n            .max_uV = DUMMY_VOLTAGE_MAX, \n        }, \n    }, \n    [1] = { \n        .constraints = { \n            .always_on = 1, \n        }, \n    }, \n}; \n\nstatic int isl6271a_get_voltage_sel(struct regulator_dev *dev) \n{ \n    return 0; \n} \n\nstatic int isl6271a_set_voltage_sel(struct regulator_dev *dev, \n                    unsigned selector) \n{ \n    return 0; \n} \n\nstatic struct regulator_ops dummy_fixed_ops = { \n    .list_voltage   = regulator_list_voltage_linear, \n}; \n\nstatic struct regulator_ops dummy_core_ops = { \n    .get_voltage_sel = isl6271a_get_voltage_sel, \n    .set_voltage_sel = isl6271a_set_voltage_sel, \n    .list_voltage   = regulator_list_voltage_linear, \n    .map_voltage    = regulator_map_voltage_linear, \n}; \n\nstatic const struct regulator_desc dummy_desc[] = { \n    { \n        .name       = \"Dummy Core\", \n        .id     = 0, \n        .n_voltages = 16, \n        .ops        = &dummy_core_ops, \n        .type       = REGULATOR_VOLTAGE, \n        .owner      = THIS_MODULE, \n        .min_uV     = DUMMY_VOLTAGE_MIN, \n        .uV_step    = DUMMY_VOLTAGE_STEP, \n    }, { \n        .name       = \"Dummy Fixed\", \n        .id     = 1, \n        .n_voltages = 1, \n        .ops        = &dummy_fixed_ops, \n        .type       = REGULATOR_VOLTAGE, \n        .owner      = THIS_MODULE, \n        .min_uV     = 1300000, \n    }, \n}; \n\nstatic int my_pdrv_probe (struct platform_device *pdev) \n{ \n   struct regulator_config config = { }; \n   config.dev = &pdev->dev; \n\n   struct regulator_dev *dummy_regulator_rdev[2]; \n\n    int ret, i; \n    for (i = 0; i < 2; i++){ \n        config.init_data = &dummy_initdata[i]; \n        dummy_regulator_rdev[i] = \\ \n              regulator_register(&dummy_desc[i], &config); \n        if (IS_ERR(dummy_regulator_rdev)) { \n            ret = PTR_ERR(dummy_regulator_rdev); \n            pr_err(\"Failed to register regulator: %d\\n\", ret); \n            return ret; \n        } \n    } \n\n    platform_set_drvdata(pdev, dummy_regulator_rdev); \n    return 0; \n} \n\nstatic void my_pdrv_remove(struct platform_device *pdev) \n{ \n    int i; \n    struct regulator_dev *dummy_regulator_rdev = \\ \n                            platform_get_drvdata(pdev); \n    for (i = 0; i < 2; i++) \n        regulator_unregister(&dummy_regulator_rdev[i]); \n} \n\nstatic struct platform_driver mypdrv = { \n    .probe      = my_pdrv_probe, \n    .remove     = my_pdrv_remove, \n    .driver     = { \n        .name     = \"regulator-dummy\", \n        .of_match_table = of_match_ptr(regulator_dummy_ids),   \n        .owner    = THIS_MODULE, \n    }, \n}; \nmodule_platform_driver(mypdrv); \nMODULE_AUTHOR(\"John Madieu <john.madieu@gmail.com>\"); \nMODULE_LICENSE(\"GPL\"); \n```", "```\nDummy Core: at 850 mV\n\nDummy Fixed: 1300 mV\n\n```", "```\n # ls /sys/class/regulator/\n\nregulator.0 regulator.11 regulator.14 regulator.4 regulator.7\n\nregulator.1 regulator.12 regulator.2 regulator.5 regulator.8\n\nregulator.10 regulator.13 regulator.3 regulator.6 regulator.9 \n\n```", "```\n# cd /sys/class/regulator\n\n# cat regulator.13/name\n\nDummy Core\n\n# cat regulator.14/name\n\nDummy Fixed\n\n# cat regulator.14/type\n\nvoltage\n\n# cat regulator.14/microvolts\n\n1300000\n\n# cat regulator.13/microvolts\n\n850000\n\n```", "```\n#include <linux/regulator/consumer.h> \n```", "```\n/* \n * struct regulator \n * \n * One for each consumer device. \n */ \nstruct regulator { \n   struct device *dev; \n   struct list_head list; \n   unsigned int always_on:1; \n   unsigned int bypass:1; \n   int uA_load; \n   int min_uV; \n   int max_uV; \n   char *supply_name; \n   struct device_attribute dev_attr; \n   struct regulator_dev *rdev; \n   struct dentry *debugfs; \n}; \n```", "```\n[...] \nint ret; \nstruct regulator *reg; \nconst char *supply = \"vdd1\"; \nint min_uV, max_uV; \nreg = regulator_get(dev, supply); \n[...] \n```", "```\nstruct regulator *regulator_get(struct device *dev, \nconst char *id) \n```", "```\n    reg = regulator_get(dev, \"Vcc\"); \n```", "```\nvoid regulator_put(struct regulator *regulator) \n```", "```\n    digital = regulator_get(dev, \"Vcc\");  /* digital core */ \n    analog = regulator_get(dev, \"Avdd\");  /* analog */ \n```", "```\nint regulator_enable(regulator); \n```", "```\nint regulator_disable(regulator); \n```", "```\nint regulator_is_enabled(regulator); \n```", "```\n printk (KERN_INFO \"Regulator Enabled = %d\\n\", \n                           regulator_is_enabled(reg));     \n```", "```\nint regulator_force_disable(regulator); \n```", "```\nint regulator_set_voltage(regulator, min_uV, max_uV); \n```", "```\nint regulator_get_voltage(regulator); \n```", "```\nprintk (KERN_INFO \"Regulator Voltage = %d\\n\",  \nregulator_get_voltage(reg)); \n```", "```\nint regulator_set_current_limit(regulator, min_uA, max_uA); \n```", "```\nint regulator_get_current_limit(regulator); \n```", "```\nint regulator_set_optimum_mode(struct regulator *regulator, \nint load_uA); \nint regulator_set_mode(struct regulator *regulator, \nunsigned int mode); \nunsigned int regulator_get_mode(struct regulator *regulator); \n```", "```\n<name>-supply: phandle to the regulator node \n```", "```\ntwl_reg1: regulator@0 { \n   [...] \n}; \n\ntwl_reg2: regulator@1 { \n   [...] \n}; \n\nmmc: mmc@0x0 { \n   [...] \n   vmmc-supply = <&twl_reg1>; \n   vmmcaux-supply = <&twl_reg2>; \n}; \n```", "```\nstruct regulator *main_regulator; \nstruct regulator *aux_regulator;  \nint ret; \nmain_regulator = devm_regulator_get(dev, \"vmmc\"); \n\n/* \n * It is a good practive to apply the config before \n * enabling the regulator \n */ \nif (!IS_ERR(io_regulator)) { \n   regulator_set_voltage(main_regulator, \n                    MMC_VOLTAGE_DIGITAL, \n                     MMC_VOLTAGE_DIGITAL); \n   ret = regulator_enable(io_regulator); \n} \n[...] \naux_regulator = devm_regulator_get(dev, \"vmmcaux\"); \n[...] \n```"]