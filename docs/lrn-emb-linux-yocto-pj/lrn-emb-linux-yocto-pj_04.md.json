["```\nstruct page {\n        unsigned long \tflags;\n        atomic_t        _count;\n        atomic_t        _mapcount;\n        struct address_space *mapping;\n        void        *virtual;\n        unsigned long \tdebug_flags;\n        void        *shadow;\n        int        _last_nid;\n\n};\n```", "```\nenum zone_type {\n#ifdef CONFIG_ZONE_DMA\n        /*\n         * ZONE_DMA is used when there are devices that are not able\n         * to do DMA to all of addressable memory (ZONE_NORMAL). Then we\n         * carve out the portion of memory that is needed for these devices.\n         * The range is arch specific.\n         *\n         * Some examples\n         *\n         * Architecture         Limit\n         * ---------------------------\n         * parisc, ia64, sparc  <4G\n         * s390                 <2G\n         * arm                  Various\n         * alpha                Unlimited or 0-16MB.\n         *\n         * i386, x86_64 and multiple other arches\n         *                      <16M.\n         */\n        ZONE_DMA,\n#endif\n#ifdef CONFIG_ZONE_DMA32\n        /*\n         * x86_64 needs two ZONE_DMAs because it supports devices that are\n         * only able to do DMA to the lower 16M but also 32 bit devices that\n         * can only do DMA areas below 4G.\n         */\n        ZONE_DMA32,\n#endif\n        /*\n         * Normal addressable memory is in ZONE_NORMAL. DMA operations can be\n         * performed on pages in ZONE_NORMAL if the DMA devices support\n         * transfers to all addressable memory.\n         */\n        ZONE_NORMAL,\n#ifdef CONFIG_HIGHMEM\n        /*\n         * A memory area that is only addressable by the kernel through\n         * mapping portions into its own address space. This is for example\n         * used by i386 to allow the kernel to address the memory beyond\n         * 900MB. The kernel will set up special mappings (page\n         * table entries on i386) for each page that the kernel needs to\n         * access.\n         */\n        ZONE_HIGHMEM,\n#endif\n        ZONE_MOVABLE,\n        __MAX_NR_ZONES\n};\n```", "```\nstruct zone {\n        unsigned long \twatermark[NR_WMARK];\n        unsigned long \tpercpu_drift_mark;\n        unsigned long \tlowmem_reserve[MAX_NR_ZONES];\n        unsigned long \tdirty_balance_reserve;\n        struct per_cpu_pageset __percpu *pageset;\n        spinlock_t        lock;\n        int        all_unreclaimable;\n        struct free_area        free_area[MAX_ORDER];\n        unsigned int            compact_considered;\n        unsigned int            compact_defer_shift;\n        int                     compact_order_failed;\n        spinlock_t              lru_lock;\n        struct lruvec           lruvec;\n        unsigned long         pages_scanned;\n        unsigned long         flags;\n        unsigned int        inactive_ratio;\n        wait_queue_head_t       * wait_table;\n        unsigned long         wait_table_hash_nr_entries;\n        unsigned long         wait_table_bits;\n        struct pglist_data    *zone_pgdat;\n        unsigned long         zone_start_pfn;\n        unsigned long         spanned_pages;\n        unsigned long         present_pages;\n        unsigned long         managed_pages;\n        const char              *name;\n};\n```", "```\nstruct page * alloc_pages(gfp_t gfp_mask, unsigned int order)\n```", "```\nvoid * page_address(struct page *page)\n```", "```\nunsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order)\n```", "```\nunsigned long __get_free_page(gfp_t gfp_mask)\nstruct page * alloc_page(gfp_t gfp_mask)\n```", "```\nunsigned long get_zeroed_page(unsigned int gfp_mask)\n```", "```\nvoid __free_pages(struct page *page, unsigned int order)\nvoid free_pages(unsigned long addr, unsigned int order)\nvoid free_page(unsigned long addr)\n```", "```\n#define MODULE\n#define LINUX\n#define __KERNEL__\n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int hello_world_init(void)\n{\n   printk(KERN_ALERT \"Hello world!\\n\");\n   return 0;\n}\n\nstatic void hello_world_exit(void)\n{\n   printk(KERN_ALERT \"Goodbye!\\n\");\n}\n\nmodule_init(hello_world_init);\nmodule_exit(hello_world_exit);\n\nMODULE_LICENSE(\"GPL\");\n```", "```\nstatic int __init hello_world_init (void)\nstatic void __exit hello_world_exit (void)\n```", "```\nKDIR := <path/to/linux/kernel/sources>\nPWD := $(shell pwd)\nobj-m := hello_world.o\nall:\n$(MAKE) ARCH=arm CROSS_COMPILE=<arm-cross-compiler-prefix> -C\n$(KDIR) M=$(PWD)\n\n```", "```\nconfig HELLO_WORLD_TEST \n tristate \"Hello world module test\"\n help\n To compile this driver as a module chose the M option.\n otherwise chose Y option.\n\n```", "```\nobj-$(CONFIG_ HELLO_WORLD_TEST)  += hello_world.c\n\n```", "```\nKBRANCH = \"linux-3.10-at91\"\nSRCREV = \"35158dd80a94df2b71484b9ffa6e642378209156\"\nPV = \"${LINUX_VERSION}+${SRCPV}\"\n\nPR = \"r5\"\n\nFILESEXTRAPATHS_prepend := \"${THISDIR}/files/${MACHINE}:\"\n\nSRC_URI = \"git://github.com/linux4sam/linux-at91.git;protocol=git;branch=${KBRANCH};nocheckout=1\"\nSRC_URI += \"file://defconfig\"\n\nSRCREV_sama5d4-xplained = \"46f4253693b0ee8d25214e7ca0dde52e788ffe95\"\n\ndo_deploy_append() {\n  if [ ${UBOOT_FIT_IMAGE} = \"xyes\" ]; then\n    DTB_PATH=\"${B}/arch/${ARCH}/boot/dts/\"\n    if [ ! -e \"${DTB_PATH}\" ]; then\n      DTB_PATH=\"${B}/arch/${ARCH}/boot/\"\n    fi\n\n    cp ${S}/arch/${ARCH}/boot/dts/${MACHINE}*.its ${DTB_PATH}\n    cd ${DTB_PATH}\n    mkimage -f ${MACHINE}.its ${MACHINE}.itb\n    install -m 0644 ${MACHINE}.itb ${DEPLOYDIR}/${MACHINE}.itb\n    cd -\n  fi\n}\n\nCOMPATIBLE_MACHINE = \"(sama5d4ek|sama5d4-xplained|sama5d3xek|sama5d3-xplained|at91sam9x5ek|at91sam9rlek|at91sam9m10g45ek)\"\n```", "```\nSRC_URI = \"git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git;protocol=git;nocheckout=1\"\n\nLINUX_VERSION ?= \"3.10\"\nLINUX_VERSION_EXTENSION ?= \"-custom\"\n\ninherit kernel\nrequire recipes-kernel/linux/linux-yocto.inc\n\n# Override SRCREV to point to a different commit in a bbappend file to\n# build a different release of the Linux kernel.\n# tag: v3.10 8bb495e3f02401ee6f76d1b1d77f3ac9f079e376\"\nSRCREV = \"8bb495e3f02401ee6f76d1b1d77f3ac9f079e376\"\n\nPR = \"r1\"\nPV = \"${LINUX_VERSION}+git${SRCPV}\"\n\n# Override COMPATIBLE_MACHINE to include your machine in a bbappend\n# file. Leaving it empty here ensures an early explicit build failure.\nCOMPATIBLE_MACHINE = \"(^$)\"\n\n# module_autoload is used by the kernel packaging bbclass\nmodule_autoload_atmel_usba_udc = \"atmel_usba_udc\"\nmodule_autoload_g_serial = \"g_serial\"\n```", "```\nSUMMARY = \"Example of how to build an external Linux kernel module\"\nLICENSE = \"GPLv2\"\nLIC_FILES_CHKSUM = \"file://COPYING;md5=12f884d2ae1ff87c09e5b7ccc2c4ca7e\"\n\ninherit module\n\nPR = \"r0\"\nPV = \"0.1\"\n\nSRC_URI = \"file://Makefile \\\n           file://hello.c \\\n           file://COPYING \\\n          \"\n\nS = \"${WORKDIR}\"\n\n# The inherit of module.bbclass will automatically name module packages with\n# \"kernel-module-\" prefix as required by the oe-core build environment.\n```"]