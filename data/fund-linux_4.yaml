- en: Working with the Command Line
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命令行
- en: In this chapter, we'll learn about more fundamental commands every Linux user
    should know, then we will learn how to install other important third-party Linux
    programs. We will also learn about processes and signals, introduce you to Bash
    shell scripting, and finally, show you how you can automate the execution of your
    Bash shell scripts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习每个Linux用户都应该知道的更多基本命令，然后我们将学习如何安装其他重要的第三方Linux程序。我们还将学习有关进程和信号的知识，向您介绍Bash
    shell脚本编写，并最终向您展示如何自动执行Bash shell脚本。
- en: 'We''ll be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Essential Linux commands
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的Linux命令
- en: Additional programs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他程序
- en: Understanding processes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解进程
- en: Signals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号
- en: Working with Bash shell variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Bash shell变量
- en: Bash shell scripting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash shell脚本编写
- en: Essential Linux commands
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的Linux命令
- en: In this section, we will learn more essential Linux Bash commands that every
    Linux user should know. Use the `cat` command to quickly cut columns out of text
    files. This is like a light version of awk.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习更多每个Linux用户都应该知道的基本Linux Bash命令。使用`cat`命令快速从文本文件中剪切列。这类似于`awk`的轻量级版本。
- en: 'We''ll be discussing the following commands:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论以下命令：
- en: '`cat`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cat`'
- en: '`sort`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort`'
- en: '`awk`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awk`'
- en: '`tee`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tee`'
- en: '`tar`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar`'
- en: Other miscellaneous commands
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他杂项命令
- en: 'First, let''s create a smaller version of the `passwd` file to work with the
    `cat` command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建`passwd`文件的较小版本，以便使用`cat`命令：
- en: '![](img/88408c56-6030-42df-ae10-e606d5343a63.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88408c56-6030-42df-ae10-e606d5343a63.png)'
- en: '`-d` sets the field delimiter; by default it''s the tab character. `-f` uses
    a single field number or comma-separated list of field numbers that you want to
    extract. If using comma-separated lists also, the split input delimiter will be
    output, which can be changed using `-- output-delimiter`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d`设置字段分隔符；默认情况下是制表符。`-f`使用要提取的单个字段编号或逗号分隔的字段编号列表。如果使用逗号分隔的列表，分割输入分隔符将被输出，可以使用`--output-delimiter`进行更改。'
- en: Next, let's create a smaller version of the `services` file without comments
    and empty lines. Using the `cat` command is very limited to the special use case
    that a file separator is a single character, such as a colon or the tab character.
    For splitting text files as multiple consecutive whitespace characters, which
    are often used in Linux config files, for example, in the `/etc/services` file,
    the `cat` command does not work. Also, when using the `cat` command, the field
    order must be fixed in every line or you will run into problems.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个没有注释和空行的`services`文件的较小版本。使用`cat`命令非常受限于文件分隔符是单个字符的特殊用例，例如冒号或制表符。对于拆分包含多个连续空格字符的文本文件，例如在Linux配置文件中经常使用的情况，例如在`/etc/services`文件中，`cat`命令不起作用。此外，当使用`cat`命令时，每行的字段顺序必须固定，否则会遇到问题。
- en: 'In the following screenshot, you can see that the `services` file contains
    no tab separator, but multiple whitespace characters marked with the star character:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，您可以看到`services`文件不包含制表符，而是包含多个用星号标记的空白字符：
- en: '![](img/3d5e6dd5-5e05-4a45-a30d-19eb05bf2635.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d5e6dd5-5e05-4a45-a30d-19eb05bf2635.png)'
- en: If you use `cat` on this file, it will produce nothing but garbage. To split
    files with multiple consecutive whitespaces, use `awk` instead. The `tr` command
    is like a lightweight version or subset of the set substitute mode. It translates
    a character set one into a character set two, reading from `stdin` and outputting
    to `stdout`. The syntax is self-explanatory. You can translate both single characters
    and ranges of characters. The character sets are similar to POSIX regular expression
    classes; read the manual to find out more.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在此文件上使用`cat`，它将产生一堆垃圾。要使用`awk`来拆分具有多个连续空格的文件。`tr`命令类似于集合替换模式的轻量级版本或子集。它将一个字符集从`stdin`转换为另一个字符集，并输出到`stdout`。语法是不言自明的。您可以转换单个字符和字符范围。字符集类似于POSIX正则表达式类；请阅读手册以了解更多信息。
- en: Let's discuss the `sort` command. The `sort` command sorts the text file line
    by line. By default, it takes the whole line into account for sorting. The `-u`
    flag only prints out unique fields. If we take a file that has numbers instead
    of alphanumeric values, by default, `sort` expects alphanumeric values, so the
    sorting of numbers is wrong or unnatural. To fix this, use the `-n` option, which
    sorts using numbers. To sort values from bottom to top, use the `-r` flag. You
    can also influence the sort column if you need. `sort` always takes the whole
    line into account. To fix this, use the `-k 2.2` option to sort by the second
    column. There are many more sort options. Refer to the manual to find out more.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论`sort`命令。`sort`命令按行对文本文件进行排序。默认情况下，它考虑整行进行排序。`-u`标志只打印出唯一的字段。如果我们使用数字而不是字母数字值的文件，默认情况下，`sort`期望字母数字值，因此数字的排序是错误的或不自然的。为了解决这个问题，使用`-n`选项，它使用数字进行排序。要从底部到顶部排序值，请使用`-r`标志。如果需要，您还可以影响排序列。`sort`始终考虑整行。为了解决这个问题，使用`-k
    2.2`选项按第二列进行排序。还有许多其他排序选项。请参考手册以了解更多信息。
- en: 'Now, in order to combine the power of `cat` or `awk`, `sort` and `unique`,
    let''s use these tools together to print the 10 most recurring service names from
    the `/etc/services` file while ignoring comments and empty lines:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了结合`cat`或`awk`，`sort`和`unique`的功能，让我们一起使用这些工具来打印`/etc/services`文件中出现最频繁的10个服务名称，同时忽略注释和空行：
- en: '![](img/bc2915cf-f480-4875-a2cc-c8450e975445.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc2915cf-f480-4875-a2cc-c8450e975445.png)'
- en: The second command should now be pretty self-explanatory. As you can see, `discard`,
    `exp1`, and `exp2` are the most recurring service names in the `/etc/services`
    file with four occurrences. To count all lines in the file, use the `wc` for the
    word count command. To extract the pure filename from a path, use the `basename`
    command, which is often used in scripts, as we will see later. If you know the
    extension of a file, you can also use the `basename` command to extract the filename
    from the extension. Similarly, to extract the path name, use the `dirname` command.
    To measure the time a command needs, execute the prefix of your command with the
    `time` command. To compare two files, use the `diff` command, which will print
    an empty output. If these files are identical, there will be no output. Otherwise,
    the changes between the files will be shown. The `diff` command can also be used
    for comparing two directories, file by file, using the recursive flag, which will
    go through all the files from A and compare them to the corresponding size files
    from B with the same name in folder B. The command that can be used to print out
    where a specific command is located in the filesystem is based on the `/path`
    variable, which we will see later.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个命令现在应该是非常容易理解的。正如您所看到的，`discard`，`exp1`和`exp2`是`/etc/services`文件中最常出现的服务名称，出现了四次。要计算文件中的所有行，请使用`wc`命令进行单词计数。要从路径中提取纯文件名，请使用`basename`命令，这在脚本中经常使用，我们稍后将看到。如果您知道文件的扩展名，也可以使用`basename`命令从扩展名中提取文件名。类似地，要提取路径名，请使用`dirname`命令。要测量命令所需的时间，请使用`time`命令执行命令的前缀。要比较两个文件，请使用`diff`命令，它将打印空输出。如果这些文件相同，将不会有输出。否则，将显示文件之间的更改。`diff`命令也可以用于比较两个目录，逐个文件使用递归标志进行比较，该标志将遍历来自A的所有文件，并将它们与B文件夹中具有相同名称的相应大小文件进行比较。可以用于打印特定命令在文件系统中的位置的命令是基于`/path`变量，稍后我们将看到。
- en: '`tee` is a useful command, which can be used to store an `stdout` command in
    a file, as well as print it on the command line. It is useful for keeping a record
    of an output while also seeing what''s going on at the same time. Just give the
    `tee` command the filename you want to write to as an argument. To compress a
    single file, which means reduce the file size, use `gzip`. To uncompress, use
    the `gunzip` command.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`tee`是一个有用的命令，可以用于将`stdout`命令存储在文件中，并在命令行上打印出来。在同时查看输出的同时保留输出记录非常有用。只需将要写入的文件名作为参数给`tee`命令。要压缩单个文件，即减小文件大小，请使用`gzip`。要解压缩，请使用`gunzip`命令。'
- en: To compress a complete subdirectory, recursively use the `tar` command. Note
    that the `f` option must be the last option followed by the archive name you want
    to create as the first argument and then the directory you want to archive and
    compress as the second argument. To extract an archive to any following directory,
    use the `tar` command with the following flag, `-C` is the output directory. `hostname`
    prints out the hostname; `uptime` prints out how long the server computer is powered
    on, and `uname` prints system information such as the kernel version.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要递归压缩完整的子目录，请使用`tar`命令。请注意，`f`选项必须是后面的选项，后面跟着您要创建的存档名称作为第一个参数，然后是您要存档和压缩的目录作为第二个参数。要将存档提取到任何后续目录，请使用`tar`命令和以下标志，`-C`是输出目录。`hostname`打印主机名；`uptime`打印服务器计算机已经运行的时间，`uname`打印系统信息，例如内核版本。
- en: In the `/etc/redhat-release` file, you will find the version of Red Hat Enterprise
    that this CentOS 7 is based on. In the `/prog/meminfo` file, you will find memory
    information, for example, how much RAM you have. In `/proc/cpuinfo`, you will
    find information about your CPUs and cores. `free -m` prints out useful memory
    information, for example, how much free RAM you've got. `df` prints out information
    about the available disk space. `du -page` prints out how much space the files
    in the current directory take. If you use it with the `max-depth=1` option, you
    will also get a summary of the folder content. `users` print out all the users
    currently logged in to the system. The `whoami` command prints the name of the
    user who is currently using this Terminal.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/etc/redhat-release`文件中，您将找到此CentOS 7基于的Red Hat Enterprise的版本。在`/proc/meminfo`文件中，您将找到内存信息，例如，您有多少RAM。在`/proc/cpuinfo`中，您将找到有关CPU和核心的信息。`free
    -m`打印出有用的内存信息，例如，您有多少可用的RAM。`df`打印出有关可用磁盘空间的信息。`du -page`打印出当前目录中文件占用的空间。如果您使用`max-depth=1`选项，还将获得文件夹内容的摘要。`users`打印出当前登录到系统的所有用户。`whoami`命令打印出当前使用此终端的用户的名称。
- en: Now, we'll see some very useful commands. To print the current date and time,
    use the `date` command. Use `+%s` to generate a unique timestamp. To print out
    a calendar, use the `cal` command. To pause, interrupt the shell execution using
    the `sleep` command. The `dd` program, or disk dump, is a very essential tool
    every Linux user needs to know. It is used to copy data from an input file or
    device to an output file or device. We have used `dd` before, in the first section,
    to override the filesystem's free space with zeros so we can shrink our VM images,
    but there are many more use cases for the `dd` command. `dd` basic syntax uses
    `if` for input file and `of` for output file as arguments. Also, two options are
    very important, the block size and the count.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到一些非常有用的命令。要打印当前日期和时间，请使用`date`命令。使用`+%s`生成唯一的时间戳。要打印日历，请使用`cal`命令。要暂停，中断shell执行，请使用`sleep`命令。`dd`程序，或磁盘转储，是每个Linux用户都需要了解的非常重要的工具。它用于从输入文件或设备复制数据到输出文件或设备。我们之前使用过`dd`，在第一部分中，用零覆盖文件系统的空闲空间，以便我们可以缩小VM映像，但`dd`命令还有许多其他用途。`dd`基本语法使用`if`作为输入文件和`of`作为输出文件的参数。还有两个非常重要的选项，块大小和计数。
- en: You will see that the block size, which means the amount of data read at once,
    is 1 MB, and the count is the amount of repetitions of the block size, so that,
    in our example, 1 MB multiplied by 1,024 equals exactly 1 GB. `dd` also supports
    reading from `stdin` and writing to `stdout` so that the command we just used
    can be rewritten as `dd if=/dev/zero of=/tmp/1gig_file.empty bs=1M count=1024`.
    You can use `dd` not only with device files, but also to copy normal files. Also,
    you can use it for creating images of whole partitions, for example, for backups.
    To access partitions, the root account is needed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到块大小，即一次读取的数据量，为1 MB，计数是块大小的重复次数，因此，在我们的示例中，1 MB乘以1,024等于1 GB。`dd`还支持从`stdin`读取和写入`stdout`，因此我们刚才使用的命令可以重写为`dd
    if=/dev/zero of=/tmp/1gig_file.empty bs=1M count=1024`。您不仅可以使用`dd`与设备文件一起使用，还可以使用它来复制普通文件。此外，您还可以使用它来创建整个分区的映像，例如用于备份。要访问分区，需要root帐户。
- en: Additional programs
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的程序
- en: In this section, we will show you some other very important Linux commands you
    don't want to miss. These programs are not included in the CentOS 7 minimal installation,
    so we first need to install it in order to install them. This section is about
    learning additional command-line programs. Additional because these tools are
    not included in the CentOS 7 minimal installation, so let's first install all
    of these programs using the CentOS 7 package manager, `yum`. In order to install
    new software, the root user is needed. So, first log in as `root`. Before we start,
    let's install the `epel` repository, which is an additional third-party repository
    for software that is not found in the official CentOS 7 sources, but is highly
    trustable and secure.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示一些其他非常重要的Linux命令，您不想错过。这些程序未包含在CentOS 7最小安装中，因此我们首先需要安装它们以安装它们。本节是关于学习额外的命令行程序。额外的因为这些工具未包含在CentOS
    7最小安装中，因此让我们首先使用CentOS 7软件包管理器`yum`安装所有这些程序。为了安装新软件，需要root用户。因此，首先以`root`身份登录。在开始之前，让我们安装`epel`存储库，这是一个额外的第三方存储库，用于存储官方CentOS
    7源中找不到的软件，但非常值得信赖和安全。
- en: First, let's install some tools to make our user life easier. `rsync` is a file
    transfer program, `pv` is the pipe viewer; `git` is for version control; `net-tools`
    contains tools to display network information; `bind-utils` contain tools to query
    DNS information; `telnet` and `nmap` are for basic network troubleshooting; `nc`
    stands for netcat, `wget` is used to download files from the internet; and `links`
    is a command-line web browser.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们安装一些工具，使我们的用户生活更轻松。`rsync`是一个文件传输程序，`pv`是管道查看器；`git`用于版本控制；`net-tools`包含显示网络信息的工具；`bind-utils`包含查询DNS信息的工具；`telnet`和`nmap`用于基本的网络故障排除；`nc`代表netcat，`wget`用于从互联网下载文件；`links`是一个命令行网页浏览器。
- en: Next, let's install some programs that give you a kind of life view on the system.
    This will install `htop`, `iotop`, and `iftop`. Finally, let's install some essential
    tools, which are screen, a calculator, `bc`, and `lsof`. First, let's introduce
    `rsync`. Every Linux user needs to know it as it's an awesome tool with many useful
    features. Basically, `rsync` is a file transfer program, but it does not simply
    copy files between a source and destination; instead, it synchronizes them, which
    means it only transfers a file if the source file is different from the destination
    qfile. This saves a lot of data overhead and time. I often use `rsync` with the
    `-rav` flags, which is the default to copy files verbosely and recursively with
    a common set of parameters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们安装一些可以让您对系统进行实时查看的程序。这将安装`htop`，`iotop`和`iftop`。最后，让我们安装一些基本工具，包括屏幕，计算器，`bc`和`lsof`。首先，让我们介绍`rsync`。每个Linux用户都需要了解它，因为它是一个具有许多有用功能的强大工具。基本上，`rsync`是一个文件传输程序，但它不仅仅是在源和目标之间复制文件；相反，它会将它们同步，这意味着它只在源文件与目标文件不同时传输文件。这节省了大量的数据开销和时间。我经常使用`rsync`与`-rav`标志，这是默认使用的参数集，用于详细和递归地复制文件。
- en: '`cp` copies the `olip-home` folder to a new location recursively. Now, if you
    change the source file and restart the copying process afterward, `rsync` first
    checks whether there are any differences in the source and destination files,
    and only transfers changes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`cp`将`olip-home`文件夹递归地复制到新位置。现在，如果您更改源文件并在之后重新启动复制过程，`rsync`首先检查源文件和目标文件之间是否有任何差异，只传输更改部分：'
- en: '![](img/a9ee4c73-daff-4518-9f4f-823242a6af94.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9ee4c73-daff-4518-9f4f-823242a6af94.png)'
- en: As shown in the preceding screenshot, we touch the `bashrc` file in the `olip-home`
    directory, which means update the file's timestamp, and afterward `rsync` checks
    and sees that the `bashrc` file has an updated timestamp, so the file gets transferred
    to the destination again because it's different. To copy files remotely to another
    server running the SSH service, and `rsync` is installed, use the following syntax: `rsync
    -rav`. As you can see, the colon at the end of the IP address starts the destination.
    Here, we will copy the `olip-home` directory to the `/tmp` directory and the other
    way around, to copy remote files to the local server, using `rsync .rav /home/olip/
    /tmp/new-olip-home`. `rsync` has a lot of different features and is just awesome.
    You can refer to the manual to learn more about it. Another example of useful
    tools that I often use is the `-- progress` flag, which shows you the progress
    of the file transfer. `pv` is the pipe viewer, which is a very useful program
    to display traffic through `stdout`. For example, we can use it to display progress
    when piping big amounts of data streams, for example, using the `dd` command.
    `git` is a program for file version control, which can help you keep track of
    your file versions, as well as be used for installing programs from the Git repositories,
    such as the very popular GitHub service. For example, we can download the latest
    `pv` source code using the following command: `$ git clone https://github.com/icetee/pv.git`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，我们触及了 `olip-home` 目录中的 `bashrc` 文件，这意味着更新了文件的时间戳，然后 `rsync` 检查并发现 `bashrc`
    文件的时间戳已更新，因此文件会再次传输到目的地，因为它已经不同了。要远程复制文件到另一台运行 SSH 服务的服务器，并且已安装了 `rsync`，使用以下语法：`rsync
    -rav`。如你所见，IP 地址末尾的冒号表示目的地。在这里，我们将 `olip-home` 目录复制到 `/tmp` 目录，反之亦然，要将远程文件复制到本地服务器，使用
    `rsync .rav /home/olip/ /tmp/new-olip-home`。`rsync` 有很多不同的功能，非常棒。你可以参考手册了解更多。我经常使用的另一个有用的工具的例子是
    `--progress` 标志，它可以显示文件传输的进度。`pv` 是管道查看器，是一个非常有用的程序，可以显示通过 `stdout` 的流量。例如，我们可以用它来显示在传输大量数据流时的进度，比如使用
    `dd` 命令。`git` 是一个文件版本控制程序，可以帮助你跟踪文件版本，也可以用于从 Git 仓库安装程序，比如非常流行的 GitHub 服务。例如，我们可以使用以下命令下载最新的
    `pv` 源代码：`$ git clone https://github.com/icetee/pv.git`。
- en: net-tools
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: net-tools
- en: '`net-tools` is a collection of important tools for displaying network-related
    information, such as `netstat` to print network information, or the `route` command
    to view the IP routing table. The `bind-utils` we just installed contain programs
    to browse DNS information, for example, to see whether a certain port is open
    on a domain, such as port `80` on [https://www.google.com](https://www.google.com);
    you will get some connection details. Type the *Esc* key to exit. `wget` is one
    of the most essential tools every system administrator needs to know. It can be
    used to download files from the internet. For example, to download a random programming
    command from HTTP to `stdout`, use the following command line: `wget -q0- http://whatthecommit.com/index.txt`,
    or type the following directly into a new file: `wget -0 /tmp/output.txt http://whatthecommit.com/index.txt`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`net-tools` 是一组重要的工具，用于显示与网络相关的信息，比如 `netstat` 用于打印网络信息，或者 `route` 命令用于查看 IP
    路由表。我们刚刚安装的 `bind-utils` 包含了浏览 DNS 信息的程序，例如，可以查看某个域上是否开放了某个端口，比如在 [https://www.google.com](https://www.google.com)
    上的端口 `80`；你将会得到一些连接细节。按 *Esc* 键退出。`wget` 是每个系统管理员都需要了解的最基本的工具之一。它可以用来从互联网上下载文件。例如，要从
    HTTP 下载一个随机的编程命令到 `stdout`，可以使用以下命令行：`wget -q0- http://whatthecommit.com/index.txt`，或者直接输入到一个新文件中：`wget
    -0 /tmp/output.txt http://whatthecommit.com/index.txt`。'
- en: Nmap
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Nmap
- en: Nmap is another very useful tool that can be used to troubleshoot or get information
    about your network. It scans the computer network and discovers and collects all
    kind of information about other hosts connected to it. Note that port scanning
    a network is a very controversial topic; since improperly using `nmap` can get
    you sued, fired, banned by your country, or even put in jail, we will only use
    it to retrieve very valuable information about our own private network here. For
    example, to scan the network for all available hosts and open ports, use the syntax: `nmap`
    network address.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap 是另一个非常有用的工具，可以用来排除故障或获取有关网络的信息。它扫描计算机网络，发现并收集与其连接的其他主机的各种信息。请注意，端口扫描网络是一个非常有争议的话题；因为不正确地使用
    `nmap` 可能会让你被起诉、被解雇、被国家禁止，甚至被监禁，我们只会用它来检索关于我们自己私有网络的非常有价值的信息。例如，要扫描网络上所有可用的主机和开放的端口，使用以下语法：`nmap`
    网络地址。
- en: You will see few IP addresses available that have various ports and services
    open. This can give you very important information about who is connected to your
    network and whether the services and computers are secure and not exposing unwanted
    details. `nc` or netcat is another very useful tool to help you debug and troubleshoot
    your server's network and firewall settings. For example, you can use it to see
    whether a certain port is open on a server. On the server, you want to verify
    the use, for example, the following command is used to open port `9999` and put
    a text file stream behind this port: `nc -l -p 9999 < /etc/redhat-release`. On
    any other server in this network, you could then try to access the server, for
    example, with the IP address `197`, then with the IP address `192.168.1.1.200`
    on port `9999` and stream this file back, using the following `nc` command: `nc
    192.168.1.200 9999 > /tmp/redhat-release`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一些可用的 IP 地址，它们有各种开放的端口和服务。这可以为你提供非常重要的信息，关于谁连接到你的网络，以及服务和计算机是否安全，是否暴露了不需要的细节。`nc`
    或 netcat 是另一个非常有用的工具，可以帮助你调试和排除服务器的网络和防火墙设置。例如，你可以用它来查看服务器上是否开放了某个端口。在服务器上，你想要验证使用，例如，以下命令用于打开端口
    `9999` 并在该端口后面放置一个文本文件流：`nc -l -p 9999 < /etc/redhat-release`。在这个网络中的任何其他服务器上，你可以尝试访问该服务器，例如使用
    IP 地址 `197`，然后使用 IP 地址 `192.168.1.200` 上的端口 `9999` 并将该文件流回传，使用以下 `nc` 命令：`nc 192.168.1.200
    9999 > /tmp/redhat-release`。
- en: links
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: links
- en: 'In this sub-section, we''ll learn about `links`—the command-line web browser.
    To open the DuckDuckGo search website using the links program, use the following
    command line: links [https://duckduckgo.com/](https://duckduckgo.com/). This will
    open the links web browser. Move the cursor up and down to reach the DuckDuckGo
    text search field. Now, you can type in your search term as you would on the normal
    DuckDuckGo website and then press *Enter* key to start your search. Again, use
    the up and down arrow keys to jump to the result of the search you want to browse
    to. Learning links navigation and shortcuts is outside of the scope of this book.
    Read the manual pages to find out more. Press the *q* key to exit links, and then
    confirm your choice by pressing the *Enter* key.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小节中，我们将学习关于`links`——命令行网页浏览器。要使用links程序打开DuckDuckGo搜索网站，请使用以下命令行：links [https://duckduckgo.com/](https://duckduckgo.com/)。这将打开links网页浏览器。移动光标上下以到达DuckDuckGo文本搜索字段。现在，你可以像在普通的DuckDuckGo网站上一样输入你的搜索词，然后按*Enter*键开始搜索。再次使用上下箭头键跳转到你想要浏览的搜索结果。学习links导航和快捷键超出了本书的范围。按*q*键退出links，然后按*Enter*键确认你的选择。
- en: iotop
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iotop
- en: To get a live view of the input and output, or short I/O, bandwidth usage of
    your system, type `iotop`. iotop needs to be started with the root user. You can
    use `iotop`, for example, to learn how fast your hard disk can read and write,
    then press the *q* key to exit. Read the manual section on `iotop` to learn more
    about its shortcuts, for example, for sorting columns.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要实时查看系统的输入和输出，或者简称I/O，带宽使用情况，输入`iotop`。iotop需要使用root用户启动。你可以使用`iotop`，例如，了解你的硬盘读写速度有多快，然后按*q*键退出。阅读`iotop`的手册部分，了解更多关于它的快捷键，例如用于排序列。
- en: iftop
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iftop
- en: Let's learn about the `iftop` program, which gets a live view on network traffic
    and network bandwidth usage and monitor. Again, this tool needs to be started
    with the root user account. As you can see, network traffic can be displayed with
    this tool, press the *q* key to quit the program. Read the manual section on `iftop`
    to learn more about its shortcuts.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来了解一下`iftop`程序，它可以实时查看网络流量和网络带宽使用情况，并进行监控。同样，这个工具需要使用root用户账户启动。如你所见，可以使用这个工具显示网络流量，按*q*键退出程序。阅读`iftop`的手册部分，了解更多关于它的快捷键。
- en: htop
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: htop
- en: Now, let's start `htop`, which is similar to the famous top program to view
    processes interactively. `htop` is the improved version of the normal top program,
    which adds new features such as scrolling vertically and horizontally so that
    you can see all the processes running on your system along with the full command
    lines. The `htop` program shows you a lot of different information about your
    system. Press the *q* key to quit the program. There are a lot of different shortcut
    options to learn; read the manual pages to learn more.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启动`htop`，它类似于著名的top程序，可以交互式查看进程。`htop`是正常top程序的改进版本，增加了新功能，例如垂直和水平滚动，这样你就可以看到系统上运行的所有进程以及完整的命令行。`htop`程序会显示关于你的系统的许多不同信息。按*q*键退出程序。有许多不同的快捷选项要学习；阅读手册页面以了解更多。
- en: lsof
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: lsof
- en: To print out a list of all open files, which means programs accessing files
    at the moment, use the `lsof` command. You'll get a long list; it's best to use
    it with `grep` to filter the content. To quickly do some math calculations on
    the command line, use the PC calculator. `screen` is a very useful command to
    detach from an SSH connection without actually disconnecting or exiting from it,
    which is very useful to pause your work and later go back to exactly the same
    point where you left, or to work from another computer. This can save a tremendous
    amount of time. First, in order to create a new detachable session, type `screen`.
    Now do your work, for example, type a text in VI. Now, imagine your day at work
    is over and you go home. Without the screen, you would now need to save your changes,
    close VI, and logout from the server. With a screen, just use the key combination
    *Ctrl* + *A* + *D* to detach from the current SSH session. If you have successfully
    detached from a session, a line will appear saying `detached from` and then the
    screen session ID. Now, in order to prove that we can reattach to this session,
    just log out from the server and then log back in to the server. Then, back on
    the server type screen -list to get a list of all the detached screens. To reattach
    to your screen, use the screen ID: `$ screen -r 23433.pts-l_localhost`. As you
    can see, we are exactly back where we left off. If you want to stop your screen
    session, type `exit`. Here, we showed you the most fundamental use cases for these
    programs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印出所有打开文件的列表，也就是当前访问文件的程序，请使用`lsof`命令。你会得到一个很长的列表；最好使用`grep`来过滤内容。要在命令行上快速进行一些数学计算，请使用PC计算器。`screen`是一个非常有用的命令，可以从SSH连接中分离出来，而不会实际断开或退出连接，这对于暂停工作然后稍后回到完全相同的位置，或者从另一台计算机工作非常有用。这可以节省大量时间。首先，为了创建一个新的可分离会话，请输入`screen`。现在做你的工作，例如，在VI中输入文本。现在，想象一下你的工作日结束了，你回家了。如果没有screen，现在你需要保存你的更改，关闭VI，并从服务器注销。有了screen，只需使用组合键*Ctrl*
    + *A* + *D*从当前SSH会话中分离出来。如果成功从会话中分离出来，会出现一行显示`detached from`，然后是screen会话ID。现在，为了证明我们可以重新附加到这个会话，只需从服务器注销，然后重新登录到服务器。然后，在服务器上输入screen
    -list以获取所有分离的屏幕的列表。要重新附加到你的屏幕，使用screen ID：`$ screen -r 23433.pts-l_localhost`。如你所见，我们恢复到了离开的地方。如果要停止你的屏幕会话，请输入`exit`。在这里，我们向你展示了这些程序的最基本用例。
- en: Understanding processes
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解进程
- en: In this section, we will show you how processes work in Linux. Now, let's discuss
    everything about processes. Every program in a Linux system that is currently
    running is called a process. One single program can consist of multiple processes,
    and the process can start other processes. For example, as we already know, the
    Bash shell itself is a command, so, when started, it gets a process. Each command
    you start in this shell is a new process started by the shell process. So, for
    example, each time we execute the `la -al` command, the Bash shell process creates
    a new process in which the `ls -al` command is running. There are many, processes
    running all the time on every Linux system. If you have a multiprocessor CPU computer,
    some of those processes really are physically running in parallel all the time.
    Other processes, or if you have a single processor CPU, are running only semi-parallel,
    which means every process only runs for a few milliseconds on the CPU then pauses,
    which is also called being put to sleep, so the system can execute the next process
    for a small period of time. This system allows the execution of all processes
    seemingly in parallel, when in reality they are processed sequentially one after
    another.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示Linux中的进程如何工作。现在，让我们讨论有关进程的一切。在Linux系统中，当前正在运行的每个程序都称为进程。一个单独的程序可以由多个进程组成，并且进程可以启动其他进程。例如，正如我们已经知道的那样，Bash
    shell本身就是一个命令，因此在启动时会得到一个进程。您在此shell中启动的每个命令都是由shell进程启动的新进程。因此，例如，每次我们执行`la -al`命令时，Bash
    shell进程都会创建一个新进程，其中`ls -al`命令正在运行。在每个Linux系统上，都有许多进程一直在运行。如果您有多处理器CPU计算机，则其中一些进程确实一直在并行运行。其他进程，或者如果您有单处理器CPU，则只是半并行运行，这意味着每个进程只在CPU上运行几毫秒然后暂停，这也被称为进入睡眠状态，因此系统可以在一小段时间内执行下一个进程。这个系统允许所有进程看似并行执行，而实际上它们是依次顺序处理的。
- en: All processes in a Linux system get created by another process so that every
    process has a parent process that created it. Only the first process does not
    have a parent, which in CentOS 7 is the `systemd` process. To get a list of all
    the running processes, run the `ps` command. Herem we use it with the `-ev` option
    and pipe its output into the `less` command as it does not fit the screen. You'll
    see that every process has a unique identifier, which is called the process identifier,
    or PID for short. The first process, the systemd process, has the PID of 1\. The
    subsequent ones are in increasing order. Every process has a user ID associated
    to it, and also every process has a parent denoted by the parent process ID column.
    You'll notice that the first two processes in the list have a parent PID of 0,
    which means they don't have a parent.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Linux系统中的所有进程都是由另一个进程创建的，以便每个进程都有一个创建它的父进程。只有第一个进程没有父进程，在CentOS 7中是`systemd`进程。要获取所有运行中进程的列表，请运行`ps`命令。这里我们使用`-ev`选项，并将其输出管道传输到`less`命令，因为它不适合屏幕。您将看到每个进程都有一个称为进程标识符或PID的唯一标识符。第一个进程，systemd进程，具有PID
    1。随后的进程按递增顺序排列。每个进程都有一个与之关联的用户ID，而且每个进程都有一个由父进程ID列表示的父进程。您会注意到列表中的前两个进程的父PID为0，这意味着它们没有父进程。
- en: To get a better understanding of the parent-child process relationship, you
    can use the `pstree` command, which we first need to install using the `psmisc`
    package. Afterward, just start the `pstree` command. With it you get a better
    understanding of which parent process created which child process, and how the
    relationship between the processes is. As said before, the systemd process is
    the first process in the system, which created all the other processes in the
    system. Every process also has a state; type `man ps` and go to the state section.
    The most important states are `running`. This means the process is currently running
    and will get executed by the CPU, or is in the run queue, which means it's just
    about to be started. You will see `sleeping` if the process execution is interrupted
    in favor of the next process in the waiting queue, or `stopped`, and even `defunct`
    or `zombie`, which means that the process terminated but the parent process does
    not know about it yet.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解父子进程关系，您可以使用`pstree`命令，我们首先需要使用`psmisc`软件包进行安装。之后，只需启动`pstree`命令。通过它，您可以更好地了解哪个父进程创建了哪个子进程，以及进程之间的关系。如前所述，systemd进程是系统中的第一个进程，它创建了系统中的所有其他进程。每个进程也有一个状态；输入`man
    ps`并转到状态部分。最重要的状态是`running`。这意味着进程当前正在运行，并将由CPU执行，或者在运行队列中，这意味着它即将启动。如果进程执行在等待队列中的下一个进程的情况下被中断，您将看到`sleeping`，或者`stopped`，甚至`defunct`或`zombie`，这意味着进程已终止，但父进程尚不知道。
- en: As we have learned in the previous section, you can also use the `top` or `htop`
    command to get a dynamic or real-time view on the processes in your system. The
    state column shows you the state of the process, where `r` stands for running,
    `s` for sleeping, and so on. If a new process gets created, the parent process
    will be cloned or copied exactly to the child process, so it has exactly the same
    data and environment as the parent process. Only the PID will be different, but
    the parent and child process are completely independent from each other.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们已经学习了，您也可以使用`top`或`htop`命令来动态或实时查看系统中的进程。状态列显示进程的状态，其中`r`代表运行，`s`代表睡眠，等等。如果创建了一个新进程，父进程将被克隆或复制到子进程，因此它与父进程具有完全相同的数据和环境。只有PID会有所不同，但父进程和子进程彼此完全独立。
- en: Cloning
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆
- en: Cloning a process is also called **forking** in Linux. For example, if you execute
    a command, such as the `sleep` command in the shell, a new process gets created
    identical to the parent Bash shell process in which the `sleep` command gets executed.
    Normally, the parent process, in our example the Bash shell process, waits until
    the child process has been finished. That is why you don't get an interactive
    cursor as long as your subprocess is running. This is the normal behavior for
    every command you run in the shell. If your Bash command-line prompt is blocked,
    this is also called running a foreground job. To kill this foreground job, press
    *Ctrl* + *C*. You can also influence this foreground behavior by setting the ampersand
    symbol at the end of any command. So, let's rerun the last command with the ampersand
    sign. When using the ampersand sign at the end of the command, the parent process
    does not wait until the child process finishes, but both processes now run in
    parallel. This is also referred to as running a process in the background. You'll
    notice that running a process in the background returns the process ID of the
    child process, so we can reference it later. For example, for killing it, use
    `kill` command. In order to put the last background job into the foreground, again
    type `fg` and press the *Enter* key. Now, our `sleep` command is back in the foreground.
    To put it back into the background, press *Ctrl* + *Z*. This does not put our
    process running in the foreground directly into the background, but rather suspends
    the process. To put a suspended process into the background type `pg`, or in the
    foreground type `fg`. In order to kill any suspended or background job, you can
    use the `kill` command. Our processes running in the background are also called
    **jobs**. In order to list all the jobs you currently have in your Terminal, you
    can use the `jobs` command. If you have any running jobs in the background, the
    output will be shown from which you can reference it using the number in the brackets.
    In order to address such a job ID, you need to prefix it with a percentage sign.
    For example, to kill the job with the job ID number 1, type `kill %1`. Note that
    the `pg`, `fg`, and `kill` commands that we just used only work when you only
    have one single current background job in the Terminal. If you are working with
    multiple jobs in the current Terminal, you need to address them individually using
    the percentage sign.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，克隆一个进程也被称为**forking**。例如，如果你在shell中执行一个命令，比如`sleep`命令，一个新的进程就会被创建，与父Bash
    shell进程相同，其中`sleep`命令被执行。通常，父进程，例如我们的例子中的Bash shell进程，会等待直到子进程完成。这就是为什么在子进程运行时你得不到一个交互式的光标。这是你在shell中运行每个命令的正常行为。如果你的Bash命令行提示被阻塞，这也被称为运行一个前台作业。要杀死这个前台作业，按下*Ctrl*
    + *C*。你也可以通过在任何命令的末尾设置&符号来影响这个前台行为。所以，让我们用&符号重新运行上一个命令。当在命令的末尾使用&符号时，父进程不会等待子进程完成，而是两个进程现在并行运行。这也被称为在后台运行一个进程。你会注意到，在后台运行一个进程会返回子进程的进程ID，所以我们以后可以引用它。例如，要杀死它，使用`kill`命令。为了将最后一个后台作业放到前台，再次输入`fg`并按下*Enter*键。现在，我们的`sleep`命令又回到了前台。要将它放回后台，按下*Ctrl*
    + *Z*。这并不是直接将我们的前台进程放到后台，而是暂停了进程。要将一个暂停的进程放到后台，输入`pg`，或者放到前台，输入`fg`。为了杀死任何暂停或后台作业，你可以使用`kill`命令。我们在后台运行的进程也被称为**作业**。要列出你当前在终端中拥有的所有作业，你可以使用`jobs`命令。如果你在后台有任何正在运行的作业，输出将显示出来，你可以用括号中的数字引用它。为了处理这样的作业ID，你需要在前面加上一个百分号。例如，要杀死作业ID为1的作业，输入`kill
    %1`。请注意，我们刚刚使用的`pg`，`fg`和`kill`命令只在你在终端中只有一个当前后台作业时才有效。如果你在当前终端中使用多个作业，你需要使用百分号分别处理它们。
- en: Signals
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号
- en: Signals are used for communication between processes. If you start a new process,
    how can you communicate with it through your shell or any other program or process
    while it is running? Also, how does the parent process know when the child process
    is finishing? For example, how does your Bash know when the `ls -al` command is
    terminating? In Linux, this kind of notification and interprocess communication
    is done using signals. In Linux, if a process starts another process, the parent
    process is put to sleep until the child process command has finished, which will
    trigger a special signal and this will wake up the parent process. The parent
    process is put to sleep so that no active CPU time is needed for waiting. A popular
    signal is the seek or interrupt signal, which will be sent to the running process
    each time we press *Ctrl* + *C* in an active program. This will interrupt and
    stop the process immediately. Another signal we have already sent is the signal
    to trigger by pressing *Ctrl* + *Z* to suspend a process so that we can put it
    in the background. Instead of using key combinations to send a signal, you can
    also directly use the `kill` command to send various signals to a running process.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 信号被用于进程之间的通信。如果你启动一个新的进程，当它运行时，你如何通过你的shell或任何其他程序或进程与它通信？另外，父进程如何知道子进程何时结束？例如，你的Bash如何知道`ls
    -al`命令何时终止？在Linux中，这种通知和进程间通信是通过信号来完成的。在Linux中，如果一个进程启动另一个进程，父进程会被挂起，直到子进程命令完成，这将触发一个特殊的信号，这将唤醒父进程。父进程被挂起，以便不需要等待活动的CPU时间。一个常用的信号是中断信号，每当我们在一个活动程序中按下*Ctrl*
    + *C*时，它就会被发送到正在运行的进程。这将立即中断和停止进程。我们已经发送的另一个信号是通过按下*Ctrl* + *Z*来挂起一个进程，以便我们可以将它放到后台。除了使用键组合发送信号，你也可以直接使用`kill`命令向正在运行的进程发送各种信号。
- en: kill
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杀死
- en: 'To get a list of all the available signals which one can send to a process
    use `kill -l`. For example, the standard signal to send to a program to kill it
    is the `SIGKILL` signal, which has the signal ID 9\. So, let''s first create a
    new process and then kill it; as an example, start a new sleep process in the
    background. As you already have learned, putting a process into the background
    prints out the process ID. Most of the time, we use the `kill` command to kill
    system processes, which usually are not started by our user. So a standard way
    to retrieve is using the `ps` option, `aux`, and then filter by the name of the
    process you want to kill. Using `ps` with the option `aux` prints out the full
    command line, which often is helpful to differentiate the right process because
    often there are multiple processes with the same command name in this list. In
    our example, we only have one sleep process running and we can confirm the right
    process ID. Now, in order to kill this process, use `kill -9` for sending the
    `SIGKILL` signal and then the process ID. Let''s confirm this using the `ps` command
    again:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取可以发送给进程的所有可用信号的列表，请使用`kill -l`。例如，发送给程序以终止它的标准信号是`SIGKILL`信号，其信号ID为9。因此，让我们首先创建一个新进程，然后终止它；例如，在后台启动一个新的sleep进程。正如你已经学到的，将一个进程放入后台会打印出进程ID。大多数情况下，我们使用`kill`命令来终止系统进程，这些进程通常不是由我们的用户启动的。因此，检索的标准方法是使用`ps`选项`aux`，然后按进程名称进行过滤。使用带有选项`aux`的`ps`会打印出完整的命令行，这通常有助于区分正确的进程，因为通常在这个列表中有多个具有相同命令名称的进程。在我们的示例中，我们只有一个正在运行的sleep进程，我们可以确认正确的进程ID。现在，为了终止这个进程，使用`kill
    -9`发送`SIGKILL`信号，然后是进程ID。让我们再次使用`ps`命令来确认：
- en: '![](img/e51b61bc-e449-4a4e-a70a-2319c1403587.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e51b61bc-e449-4a4e-a70a-2319c1403587.png)'
- en: As you can see, the `sleep` command has been successfully killed. In the previous
    section, we use the `kill` command with the percentage job ID, but what is the
    difference in  using the `kill` command with the PID instead of the job ID? Background
    and suspended processes are usually manipulated via the job number or job ID.
    This number is different from the process ID and is used because it is shorter.
    Killing processes using the PID is most often used to kill malfunctioning system
    processes using the root account. In addition, a job can consist of multiple processes
    running in a series or at the same time in parallel. Using the job ID is easier
    than tracking individual processes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`sleep`命令已成功终止。在前面的部分中，我们使用了`kill`命令和百分比作业ID，但是使用PID而不是作业ID的`kill`命令有什么区别呢？后台和挂起的进程通常通过作业编号或作业ID进行操作。这个编号不同于进程ID，因为它更短。使用PID杀死进程通常用于使用root账户杀死出现故障的系统进程。此外，一个作业可以由一系列或同时并行运行的多个进程组成。使用作业ID比跟踪单个进程更容易。
- en: hang-up
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂起
- en: Finally, let's discuss the `SIGUP` signal, or the hang-up signal. In CentOS
    7, if you run a program in the background, like the `sleep` command, and log out
    of the system, then log in again, you'll see the command or process still running.
    So, in CentOS 7, we can easily run background processes and log out of the SSH
    session, which is useful to run programs that need to run all the time or to do
    some heavy calculations that take hours, days, or even months. In other Linux
    distributions, if you log out of the system, the kernel will send the hang-up
    signal, or in short `SIGUP`, to all running background processes and terminate
    them. In such systems, to disable the hang-up signal that is sent to your processes,
    use `nohup`; prefix your command with the `nohup` command, such as `nohup sleep
    1000 &`. This way you can safely log out of the system and your job will not stop
    running. But, as mentioned before, on a CentOS 7 system, you don't have to do
    this.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们讨论`SIGUP`信号，或者挂起信号。在CentOS 7中，如果你在后台运行一个程序，比如`sleep`命令，并且退出系统，然后再次登录，你会看到命令或进程仍在运行。因此，在CentOS
    7中，我们可以轻松地运行后台进程并退出SSH会话，这对于需要一直运行的程序或需要进行几个小时、几天甚至几个月的大量计算非常有用。在其他Linux发行版中，如果你退出系统，内核会向所有正在运行的后台进程发送挂起信号，或者简称为`SIGUP`，并终止它们。在这样的系统中，要禁用发送给你的进程的挂起信号，使用`nohup`；在你的命令前加上`nohup`命令，比如`nohup
    sleep 1000 &`。这样你就可以安全地退出系统，你的任务不会停止运行。但是，如前所述，在CentOS 7系统中，你不需要这样做。
- en: Working with Bash shell variables
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bash shell变量
- en: In this section, we will introduce you to Linux Bash shell variables. Bash shell
    variables are a great way to give symbolic names to any dynamic values, so we
    can reference values by a name. This helps to create very flexible and convenient
    systems where you often only have to change a single value, and all processes
    on your computer accessing this value can change their behavior automatically.
    Using shell variables provides a simple way to share configuration settings between
    multiple applications and processes in Linux, as we will see in the next section.
    To define a new environment variable, use the following syntax `MY_VALUE=1`, name
    of the variable equals, then the value. All Bash shell variables must not contain
    spaces or special characters, and, by convention, often shell variables are all
    uppercase. To access the stored value of the shell variable, which is nothing
    more than a shell expansion of the stored value, prefix the variable with the
    dollar sign. You can also look at shell variables as containers for dynamic values.
    You can also change the value of a shell variable anytime if you want. You can
    also copy a shell variable's content to another variable using the following syntax: `MY_NEW_VALUE=$MY_VALUE`.
    To unset a shell variable's content, use the `unset` command. For assigning shell
    variables, the same quoting and escaping rules apply as for any other Bash topics
    we have learned in the shell quoting and globbing sections in the previous chapters.
    For example, first assign the string `b` to the shell variable `a`. Now, for embedding
    spaces in the string, quotes must be used. Other shell expansions such as other
    shell variables can also be expanded in the assignment of a string. For embedding
    double quotes in a string, use single quotes to surround. There are a number of
    predefined and global shell environment variables to configure system-wide settings,
    such as `home`, `path`, `shell`, and so forth.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您介绍Linux Bash shell变量。Bash shell变量是一种为任何动态值提供符号名称的好方法，因此我们可以通过名称引用值。这有助于创建非常灵活和方便的系统，您通常只需更改一个值，访问此值的计算机上的所有进程都可以自动更改其行为。使用shell变量提供了一种简单的方法，在Linux中多个应用程序和进程之间共享配置设置，我们将在下一节中看到。要定义一个新的环境变量，请使用以下语法`MY_VALUE=1`，变量的名称等于，然后是值。所有Bash
    shell变量都不得包含空格或特殊字符，并且按照惯例，通常shell变量都是大写的。要访问存储的shell变量的值，这只是存储值的shell扩展，用美元符号作为变量的前缀。您还可以将shell变量的内容复制到另一个变量中，使用以下语法：`MY_NEW_VALUE=$MY_VALUE`。要取消设置shell变量的内容，请使用`unset`命令。对于分配shell变量，与我们在前几章的shell引用和globbing部分学到的任何其他Bash主题一样，都适用相同的引用和转义规则。例如，首先将字符串`b`分配给shell变量`a`。现在，为了在字符串中嵌入空格，必须使用引号。在字符串中嵌入双引号时，使用单引号来包围。有许多预定义和全局的shell环境变量来配置系统范围的设置，例如`home`、`path`、`shell`等。
- en: While there are no official standard for most environment variables in Linux,
    a lot of programs are using common variable names. For example, if you set a value
    for the `PROXY` environment variable, all programs and services that make use
    of this variable can now access this new centralized information without the need
    for you to tell each program or service individually that something has changed.
    Another very important system environment variable is the `PATH` variable. It
    is used by the Bash shell itself. It contains all the paths separated by a colon
    where the Bash shell tries to look up places for executable files, so you don't
    have to provide the full path for a command, which is included in this path. For
    example, if we create a new script file in a new local script folder called `my-script.sh`,
    we need to provide its full name location in order to execute it; there is no
    other way we can execute a script. But we cannot run it, for example, from the
    `/tmp` directory because Bash cannot find it in its path. Now, if we add the script's
    location to the path environment variable, we are able to run our script from
    everywhere without having to provide the full path, and even autocomplete is working.
    But what is the difference between a Bash shell variable and an environment variable?
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Linux中没有大多数环境变量的官方标准，但很多程序都使用常见的变量名。例如，如果为`PROXY`环境变量设置一个值，所有使用该变量的程序和服务现在都可以访问这些新的集中信息，而无需您单独告诉每个程序或服务有什么变化。另一个非常重要的系统环境变量是`PATH`变量。它被Bash
    shell本身使用。它包含所有由冒号分隔的路径，Bash shell尝试查找可执行文件的位置，因此您不必为包含在此路径中的命令提供完整路径。例如，如果我们在一个名为`my-script.sh`的新本地脚本文件夹中创建一个新的脚本文件，我们需要提供其完整的名称位置才能执行它；没有其他方法可以执行脚本。但是，我们不能从`/tmp`目录运行它，因为Bash在其路径中找不到它。现在，如果我们将脚本的位置添加到路径环境变量中，我们就可以在任何地方运行我们的脚本，而无需提供完整的路径，甚至自动完成也可以工作。但是Bash
    shell变量和环境变量之间有什么区别呢？
- en: 'Normal shell variables are not part of the so-called process environment or,
    in other words, they are not visible in any sub or child process. This is because
    when executing a process, only the environment gets cloned, and not the local
    shell variables. You can test this by creating the following shell variable using
    `MYVAR=helloworld` and then use it in the script that we will run as a subprocess:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 普通的shell变量不是所谓的进程环境的一部分，换句话说，在任何子进程或子进程中都看不到它们。这是因为在执行进程时，只有环境被克隆，而不是本地shell变量。您可以通过使用`MYVAR=helloworld`创建以下shell变量来测试这一点，然后在我们将作为子进程运行的脚本中使用它：
- en: '![](img/7b5b9eba-a6f7-4014-bc58-0402c11b383b.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b5b9eba-a6f7-4014-bc58-0402c11b383b.png)'
- en: As you can see, we create a new shell variable called `MYVAR`, and then create
    a script that references or tries to access this environment variable. What happens
    now if we execute this script? As you can see, the child process, or subprocess,
    is not able to access the `MYVAR` Bash shell variable from the parent, but you
    can change this behavior by defining our `MYVAR` shell variable as an environment
    variable. Any child process gets a copy of the parent's environment during process
    creation, including all environment variables, but not the local shell variables.
    If you prefix the shell variable with the word `export`, the child process can
    access this environment variable because the environment is being copied from
    the parent process to the child process when a new process is created. But even
    environment variables like shell variables don't survive logging out of the system,
    which means that if you close your SSH session, all your defined variables are
    gone.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们创建了一个名为`MYVAR`的新shell变量，然后创建了一个引用或尝试访问此环境变量的脚本。现在，如果我们执行此脚本会发生什么？正如您所看到的，子进程或子进程无法访问父进程中的`MYVAR`
    Bash shell变量，但是您可以通过将我们的`MYVAR` shell变量定义为环境变量来更改此行为。在进程创建期间，任何子进程都会获得父进程的环境副本，包括所有环境变量，但不包括本地shell变量。如果您在shell变量前加上`export`这个词，子进程就可以访问这个环境变量，因为在创建新进程时，环境是从父进程复制到子进程的。但是，即使像shell变量这样的环境变量也无法在系统退出时保留，这意味着如果您关闭SSH会话，所有定义的变量都会消失。
- en: 'If you want to create a system-wide environment variable that is present for
    every user and survives logging out of the system, put your variable into the `/etc/environment` file
    using your root user account. You can also make a shell variable available for
    a child process using the following syntax by prefixing the shell variable name
    before running the command, such as `MYVAR=NEW_Helloworld ~/scripts/local_var.sh`.
    This way you don''t have to define a shell variable as an environment variable.
    Another very important rule is that a child process will never be able to change
    the parent''s environment variables, because the child and parent are independent
    of each other, and the child only has a local copy of the parent''s environment.
    To test this out, try the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建一个系统范围的环境变量，该变量对每个用户都可用，并且在系统退出时仍然存在，请使用您的root用户帐户将变量放入`/etc/environment`文件中。您还可以使用以下语法通过在运行命令之前在shell变量名称前加上前缀的方式使shell变量对子进程可用，例如`MYVAR=NEW_Helloworld
    ~/scripts/local_var.sh`。这样，您就不必将shell变量定义为环境变量。另一个非常重要的规则是，子进程永远无法更改父进程的环境变量，因为子进程和父进程彼此独立，子进程只有父进程环境的本地副本。要测试这一点，请尝试以下操作：
- en: '![](img/9c5ff27f-be37-4490-b6e5-59ff3f1859c0.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c5ff27f-be37-4490-b6e5-59ff3f1859c0.png)'
- en: First, let's clear all the possible former values a local child Bash shell variable
    has. Next, create a script that creates a new environment variable called `CHILDVAR`
    with the value `Hello_from_child`. Now, what happens if we execute the script?
    If we execute the script, the `CHILDVAR` environment variable will be set in the
    child process, and this `CHILDVAR` environment variable is not visible for the
    parent process. In summary, any shell variable or environment variable that you
    define in a script can never be seen in the parent process. If you want to make
    shell variables available from a child process to a parent process, first you
    need to create a so-called source file in your child process where you define
    your environment variables in `vi ~/scripts/child.sh`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们清除本地子Bash shell变量可能具有的所有可能的旧值。接下来，创建一个脚本，创建一个名为`CHILDVAR`的新环境变量，其值为`Hello_from_child`。现在，如果我们执行此脚本会发生什么？如果执行脚本，`CHILDVAR`环境变量将在子进程中设置，并且此`CHILDVAR`环境变量对父进程不可见。总之，在脚本中定义的任何shell变量或环境变量永远不会在父进程中可见。如果要使shell变量从子进程可用于父进程，首先需要在子进程中创建一个所谓的源文件，在其中定义您的环境变量`vi
    ~/scripts/child.sh`。
- en: 'Next, execute the script in your child process:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在您的子进程中执行脚本：
- en: '![](img/97fcd181-08af-46a4-b269-99fc37ed054b.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97fcd181-08af-46a4-b269-99fc37ed054b.png)'
- en: This creates the source file for the parent process. Now, in the parent process,
    first we check whether the `CHILDVAR` environment variable is available. If it's
    not, let's source it using the `source` command. Finally, let's recheck whether
    the `CHILDVAR` environment variable is now accessible. If it is, then this is
    a valid way to create environment variables in a child process and make them available.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为父进程创建源文件。现在，在父进程中，首先我们检查`CHILDVAR`环境变量是否可用。如果没有，让我们使用`source`命令来源化它。最后，让我们重新检查`CHILDVAR`环境变量是否现在可访问。如果是，那么这是在子进程中创建环境变量并使其可用的有效方法。
- en: Introduction to Bash shell scripting
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bash shell脚本介绍
- en: In this section, we will introduce you to the core concept of Bash shell scripting.
    Another very important feature of Bash shell scripts are functions. We use functions
    excessively in Bash shell scripts to make reoccurring tasks or commands reusable.
    Functions encapsulate a task to make it more modular. Functions usually take in
    data, process it, and return a result. Once a function is written, it can be used
    over and over again, but we can also work with functions on the command line.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您介绍Bash shell脚本的核心概念。Bash shell脚本的另一个非常重要的特性是函数。我们在Bash shell脚本中大量使用函数，以使重复出现的任务或命令可重用。函数封装了一个任务，使其更加模块化。函数通常接收数据，处理数据，并返回结果。一旦编写了一个函数，它就可以一遍又一遍地使用，但我们也可以在命令行上使用函数。
- en: 'Let''s discuss the general syntax of a function by creating one:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个来讨论函数的一般语法：
- en: '[PRE0]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first word is the function name followed by opening and closing brackets,
    which are used to define a function, followed by a curly opening bracket; all
    the commands belonging to a function are defined within the open and closing brackets,
    which is also called the function body. Functions can have arguments as normal
    commands, which will be accessible to the function body from outside. To access
    a certain argument in the function, use the dollar number notation. So `$1` is
    the first argument, `$2` would be the second, and so on. Let's take a look at
    our `say_hello` function. If we call this function with one argument, the function
    will be executed with one argument, and this argument will be taken in the function
    body, where we can access the first argument with the `$1` variable, which is
    nothing more than a normal shell expansion.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个单词是函数名，后面跟着开括号和闭括号，用于定义函数，然后是一个大括号；所有属于函数的命令都在开括号和闭括号内定义，这也被称为函数体。函数可以像普通命令一样有参数，这些参数可以从外部访问函数体。要在函数中访问特定参数，使用美元符号加数字的表示法。所以`$1`是第一个参数，`$2`是第二个，依此类推。让我们来看看我们的`say_hello`函数。如果我们用一个参数调用这个函数，函数将用一个参数执行，并且这个参数将在函数体中被使用，我们可以用`$1`变量访问第一个参数，这不过是一个普通的shell扩展。
- en: 'Functions can also call other functions in their body. Now, let''s learn to
    put your shell commands in a shell script file. Script files are just plain text
    files which contain different Linux commands, control structures, loops, and so
    on. Usually, they are written to solve everyday computer problems and fit your
    own individual needs instead of having to execute single commands one by one manually.
    There are two ways to execute a text file as a shell script. The first way is
    to use it as an argument for the Bash command. Another way to execute it without
    using it as an argument for the Bash command is to first make the script executable
    and then put the so-called shebang line at the first line, which tells the command
    line that this file is a Bash script and should be started with the Bash interpreter.
    In our example, `#!/bin/bash` is the shebang line and tells Bash that this is
    a Bash shell script. Now, to start it with the shebang approach, make it executable
    and then you can just run it on the command line, as following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以在它们的函数体中调用其他函数。现在，让我们学习如何将你的shell命令放入一个shell脚本文件中。脚本文件只是包含不同Linux命令、控制结构、循环等的纯文本文件。通常，它们是为了解决日常计算机问题并满足你自己的个人需求，而不是手动逐个执行单个命令。有两种方法可以将文本文件作为shell脚本执行。第一种方法是将其作为Bash命令的参数使用。另一种方法是在不使用它作为Bash命令的参数的情况下首先使脚本可执行，然后在第一行放置所谓的shebang行，告诉命令行这个文件是一个Bash脚本，并且应该用Bash解释器启动。在我们的例子中，`#!/bin/bash`是shebang行，告诉Bash这是一个Bash
    shell脚本。现在，要用shebang方法启动它，使它可执行，然后你可以在命令行上运行它，如下：
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Similar to using functions, we can also access command-line arguments in shell
    scripts, such as `$ vi /tmp/new-script.sh`. The first argument can be accessed
    using `$1`, the second argument `$2`, and so on. In shell scripts, you can also
    access the name of the shell script using the `$0`. The total number of arguments
    can be accessed using the `$#`. So, for example, to write a check that your script
    needs at least two arguments do the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用函数类似，我们也可以在shell脚本中访问命令行参数，比如`$ vi /tmp/new-script.sh`。第一个参数可以用`$1`访问，第二个参数用`$2`，依此类推。在shell脚本中，你还可以用`$0`访问shell脚本的名称。可以用`$#`访问参数的总数。所以，例如，要编写一个检查你的脚本至少需要两个参数的检查，做如下操作：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So, what this script does is check whether the number of command-line arguments
    are at least two and, if this is not the case, then a usage format will be printed
    out stating that you need two parameters, press *Enter*, and then an exit value
    of `1` will be returned, which means that this script has thrown an error, because,
    as we already know, a script will return `0` on successful execution. Let''s test
    this script out:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这个脚本的作用是检查命令行参数的数量是否至少为两个，如果不是这样，那么将打印出一个使用格式，说明你需要两个参数，按*Enter*，然后返回一个值为`1`的退出值，这意味着这个脚本抛出了一个错误，因为，正如我们已经知道的，脚本将在成功执行时返回`0`。让我们测试一下这个脚本：
- en: '![](img/e74aa248-dede-4c8d-b5a6-e0a0fc11d9b6.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e74aa248-dede-4c8d-b5a6-e0a0fc11d9b6.png)'
- en: If we start the script with only one argument, it will print out the usage format.
    However, if we start it with two arguments, it will correctly work. When it comes
    to shell scripting, there is much more to learn and we could only show you the
    very basics to get you started. You can refer to the Bash manual or just start
    reading the various shell scripts that are shipped with your Cent0S 7 OS for free.
    Type the following command to get a list of all the `.sh` files: `su -c 'find
    / -name "*.sh"'`, which is the default extension for shell script files in your
    system. Just start by opening one of the available shell script files in your
    system and try to understand it, for example, `/usr/libexec/grepconf.sh`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只用一个参数启动脚本，它将打印出使用格式。然而，如果我们用两个参数启动它，它将正确工作。当涉及shell脚本时，还有很多东西要学习，我们只能向你展示最基本的东西来让你开始。你可以参考Bash手册，或者开始阅读你的Cent0S
    7操作系统中免费提供的各种shell脚本。输入以下命令以获取所有`.sh`文件的列表：`su -c 'find / -name "*.sh"'`，这是你系统中shell脚本文件的默认扩展名。只需打开系统中可用的一个shell脚本文件，并尝试理解它，例如`/usr/libexec/grepconf.sh`。
- en: Implementing Bash shell scripting
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施Bash shell脚本
- en: Besides the logical `and` and `or` expressions that we used in the previous
    section, if we need to make a decision based on a command's exit status, variable
    value, command output, and so on, we need to understand the `if` statement or
    conditional branch. In plain words, the `if` statement means that, based on some
    condition, our script or command line should perform one action, otherwise it
    should perform something else.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在前一节中使用的逻辑`and`和`or`表达式，如果我们需要根据命令的退出状态、变量值、命令输出等做出决定，我们需要理解`if`语句或条件分支。简而言之，`if`语句意味着基于某些条件，我们的脚本或命令行应该执行一个动作，否则应该执行其他动作。
- en: 'Let''s work with the exit code from the previous section again to demonstrate:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用上一节的退出代码来演示：
- en: '![](img/e85d9ae2-c58a-4d0b-ba90-360496cda0f2.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e85d9ae2-c58a-4d0b-ba90-360496cda0f2.png)'
- en: 'In this example, we issued the `ls` command to see the content of the `oiip`
    home directory. We stored the exit status of the `ls` command in the `EXIT` Bash
    variable. In the next line, we now state the if condition. This can be read as:
    `if` the Bash variable `EXIT` equals `0`, then print out two lines of text, and
    this `if` condition with the reverse if word, fi. As you see, the two lines have
    been printed out, which means the if condition was true, so the exit value was
    `0`. It''s important to note that you have to be very careful that you set the
    spaces and new lines exactly as I did in the preceding example, but you can also
    put the complete if statement in one line, which you can see if you press the
    up arrow key to show the last command in the history. As you can see, the shell
    internally uses a semicolon space instead of new lines to separate most of the
    expressions, which is a bit hard to read, especially if you''re writing more complex
    Bash shell script one-liners. To negate any if expression which means that the
    `if` statement evaluates to true if the condition is not met, use the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们发出了`ls`命令来查看`oiip`主目录的内容。我们将`ls`命令的退出状态存储在`EXIT` Bash变量中。在下一行，我们现在陈述了if条件。这可以理解为：`if`
    Bash变量`EXIT`等于`0`，那么打印出两行文本，以及这个`if`条件与反向if词fi。正如你所看到的，这两行已经被打印出来，这意味着if条件是真的，所以退出值是`0`。重要的是要注意，你必须非常小心地设置空格和换行，就像我在前面的例子中所做的那样，但你也可以把完整的if语句放在一行中，你可以看到如果按上箭头键显示历史中的最后一个命令。正如你所看到的，shell在内部使用分号空格而不是换行来分隔大多数表达式，这有点难以阅读，特别是当你写更复杂的Bash
    shell脚本一行代码时。要否定任何if表达式，这意味着`if`语句在条件不满足时评估为真，使用以下内容：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this example, the if condition can be read as: if the exit value equals
    not `0`, then print out the text. In our example, this is true because the exit
    value is `1`. If conditions can include a lot of different tests, which are too
    much to demonstrate here. Here, follow the most important ones. To test for equality,
    use the `-eq` test as we have just seen. You can use it for numbers. For string
    comparisons, use the `==` operator instead. You can also use the logical `and`
    and `or` expressions as introduced in the last section, for example, to also test
    for alternatives. This example can be read as: if the password equals to `Hello_my_world_555`
    or if the password equals to `my_secret_pass`. In this example, the password is
    correct. You can also use regular expressions using the equals tilde operator.
    This statement can be read as: the if condition is true if the string matches
    at the beginning of the line, where the first two characters are variables, but
    then there must be an `rem`, which is true. For numeric values, you can also test
    for less than or greater than numbers using `-lt` and `-gt` instead of `-eq`,
    for example, to test for less than or to test for greater than.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，if条件可以理解为：如果退出值不等于`0`，那么打印出文本。在我们的例子中，这是真的，因为退出值是`1`。if条件可以包括许多不同的测试，这里展示了最重要的一些。要测试相等性，使用`-eq`测试，就像我们刚刚看到的那样。你可以用它来比较数字。对于字符串比较，使用`==`运算符。你还可以使用逻辑`and`和`or`表达式，就像在上一节中介绍的那样，例如，也可以测试替代方案。这个例子可以理解为：如果密码等于`Hello_my_world_555`或者密码等于`my_secret_pass`。在这个例子中，密码是正确的。你还可以使用等于波浪线运算符来使用正则表达式。这个语句可以理解为：如果字符串与行的开头匹配，则if条件为真，其中第一个两个字符是变量，但接下来必须是`rem`，这是真的。对于数字值，你也可以使用`-lt`和`-gt`来测试小于或大于数字，而不是使用`-eq`，例如，测试小于或测试大于。
- en: 'Another group of very important if conditions are file tests. There exist vast
    number of very powerful file tests to see if a file or directory meets a special
    property. There are a vast number of very powerful file tests to see whether a
    file or directory, for example to test whether the file exists, use the `-a` file
    test, or to check whether a directory exists use the `-d` file test. This is shown
    in the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组非常重要的if条件是文件测试。存在大量非常强大的文件测试，用于查看文件或目录是否满足特定属性。有大量非常强大的文件测试，用于查看文件或目录是否满足特定属性，例如测试文件是否存在，使用`-a`文件测试，或者检查目录是否存在使用`-d`文件测试。这在下面的截图中显示：
- en: '![](img/e90b6248-ed1b-4803-98db-85f1d17a014c.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e90b6248-ed1b-4803-98db-85f1d17a014c.png)'
- en: 'To learn more about all the existing file tests, as well as all available comparison
    operators, open the Bash manual and search for conditional expressions. The general
    syntax for the most simple if statements we have just learned is that, if the
    condition is true, all the commands between the beginning if and the ending `fi`
    are executed. Now, you can also incorporate an `else` branch, which will be executed
    if the condition is not true. The following screenshot shows the execution:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解所有现有文件测试，以及所有可用的比较运算符，请打开Bash手册并搜索条件表达式。我们刚刚学到的最简单的if语句的一般语法是，如果条件为真，则在开始if和结束`fi`之间的所有命令都会被执行。现在，你也可以加入一个`else`分支，如果条件不为真，则会执行该分支。下面的截图显示了执行情况：
- en: '![](img/23e888b5-7f09-45cd-8940-0801ccb8f8a1.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23e888b5-7f09-45cd-8940-0801ccb8f8a1.png)'
- en: 'The else branch is introduced by the `else` keyword. In our example, the if
    condition is not true, so the else branch will be executed. If you have several
    independent conditions to check, you can also use the `elif` statement, which
    is better than writing multiple `if` statements one after another. So, instead
    of writing three single `if` statements to check for conditions equal to, less
    than, and greater than, you can use the more compact `elif` notations instead:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`分支由`else`关键字引入。在我们的例子中，if条件不为真，所以将执行else分支。如果你有几个独立的条件要检查，你也可以使用`elif`语句，这比连续写多个`if`语句要好。所以，不是写三个单独的`if`语句来检查等于、小于和大于的条件，而是使用更紧凑的`elif`表示法：'
- en: '![](img/f565c1c7-4290-4328-9762-b4d442a7969f.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f565c1c7-4290-4328-9762-b4d442a7969f.png)'
- en: 'Next, we''ll discuss loops. One of the most important loops in the Bash shell
    is the `for in` loop. It can be used to iterate over a series of words. The word
    delimiter can be a space or a new line. Now, if we use such a list of space or
    new line separated words with the `for` loop, it will iterate over every item
    in that list and we can use the current value in the body of the for loop, where
    we can also execute commands. This block will then be repeated as often as we
    have elements in this list. The name of the loop variable in our example, we have
    called it `count`, is free to choose:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论循环。Bash shell中最重要的循环之一是`for in`循环。它可以用于迭代一系列单词。单词的分隔符可以是空格或换行符。现在，如果我们在`for`循环中使用这样一个以空格或换行符分隔的单词列表，它将迭代列表中的每一项，我们可以在`for`循环的主体中使用当前值，在那里我们也可以执行命令。这个块将重复多次，就像我们在这个列表中有多少元素一样。在我们的例子中，循环变量的名称，我们称之为`count`，是可以自由选择的：
- en: '![](img/35e6cf55-b95c-4ec3-9643-437edd33597b.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35e6cf55-b95c-4ec3-9643-437edd33597b.png)'
- en: 'This example can be read as: for, go through the list of `1`, `2`, `3` and
    `4`, and in each iteration of it, save the current value in the count variable
    and then, in the body of the loop, print out its content. But what can we do with
    the `for in` loop? For example, the following Bash built-in expands to a list
    of consecutive numbers: `$ echo {1..20}`. You can also do the same with the `seq`
    command, but this produces a new line-separated list instead. So, if we need to
    run a loop, we can just do the following. New line-separated lists do all the
    work, but don''t forget to put the command in dollar bracket notation. As we already
    know, the shell globbing character outputs a list of all the files separated by
    a space, so we can also do so. An important use case for using files in the for
    in loop is to rename  multiple files, for example, in a directory with a different
    filename extension. Note that, in this example, we use the `basename` command
    and surround it with the dollar bracket notation to return the pure filename:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以理解为：对于`1`、`2`、`3`和`4`的列表，每次迭代都将当前值保存在计数变量中，然后在循环体中打印出其内容。但是`for in`循环可以做什么呢？例如，以下Bash内置命令扩展为连续数字的列表：`$
    echo {1..20}`。您也可以使用`seq`命令做同样的事情，但这会产生一个以换行符分隔的列表。因此，如果我们需要运行一个循环，我们可以这样做。换行符分隔的列表可以完成所有工作，但不要忘记将命令放在美元括号表示法中。正如我们已经知道的那样，shell通配符字符输出由空格分隔的所有文件的列表，因此我们也可以这样做。在`for
    in`循环中使用文件的一个重要用例是重命名多个文件，例如，在具有不同文件扩展名的目录中。请注意，在此示例中，我们使用`basename`命令并将其放在美元括号表示法中以返回纯文件名：
- en: '![](img/bc907652-f59f-4f97-8a58-0ab9bf7359a9.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc907652-f59f-4f97-8a58-0ab9bf7359a9.png)'
- en: As you can see, we created a new directory with five files having the extension
    `.txt`. Then, we loop over our five files using a `for each` loop, and, for every
    file, we move the file to a doc extension. There are other very important loops
    as well as the `while` loop. You can refer to the Bash manual and search for while.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们创建了一个具有扩展名`.txt`的新目录，其中包含五个文件。然后，我们使用`for each`循环循环我们的五个文件，并且对于每个文件，我们将文件移动到doc扩展名。还有其他非常重要的循环，比如`while`循环。您可以参考Bash手册并搜索while。
- en: Automating script execution
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化脚本执行
- en: In this section, we will show you how to automate Bash shell script execution.
    The cron system, which is available on every Linux system, allows for the automation
    of commands or scripts by enabling the administrator to determine a predefined
    schedule based on any hour, day, or even month. It is a standard component of
    the CentOS 7 operating system, and in this section we will introduce you to the
    concept of managing recurring tasks in order to take advantage of this invaluable
    tool.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何自动化Bash shell脚本执行。Cron系统在每个Linux系统上都可用，允许管理员根据任何小时、天甚至月份来确定预定义的计划，从而自动化命令或脚本。它是CentOS
    7操作系统的标准组件，在本节中，我们将向您介绍管理重复任务的概念，以便利用这个宝贵的工具。
- en: First, let's create a new script, which will download an elegant and useful
    Linux command-line example from the incredible **Commandlinefu** web page and
    put it in the `motd`, or message of the day, file in the Linux system so that
    it is visible whenever a user logs into the system. The `motd` file is a simple
    text file from which the content will be displayed on successful login. We then
    run the script as a cron job so that the message of the day will be updated every
    day, which is very useful to learn a new and elegant command-line solution each
    day.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的脚本，它将从令人难以置信的**Commandlinefu**网页下载一个优雅而有用的Linux命令行示例，并将其放入Linux系统中的`motd`或每日消息文件中，以便用户每次登录系统时都可以看到。`motd`文件是一个简单的文本文件，其中的内容将在成功登录时显示。然后，我们将脚本作为cron作业运行，以便每天更新一次每日消息，这对于每天学习一个新的优雅的命令行解决方案非常有用。
- en: 'In order to do that, first log in as `root`, as the cron system is located
    in the system directories. Next, make a copy of the original `motd` file. Afterward,
    let''s create our script file to update the `motd` file in the system:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，首先以`root`身份登录，因为cron系统位于系统目录中。接下来，复制原始的`motd`文件。之后，让我们创建我们的脚本文件来更新系统中的`motd`文件：
- en: '![](img/8d41cb92-dd19-490a-ad88-4d27d46abdd5.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d41cb92-dd19-490a-ad88-4d27d46abdd5.png)'
- en: '[PRE4]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This script is normal batch script and downloads a random Commandlinefu example
    from the web page, [http://www.commandlinefu.com/commands/random/plaintext](http://www.commandlinefu.com/commands/random/plaintext),
    using the `wget` program and saves the downloaded file as `/etc/motd`. So, we
    can directly see the content when we log in to the system. Now, let''s test drive
    our new script:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本是普通的批处理脚本，从网页[http://www.commandlinefu.com/commands/random/plaintext](http://www.commandlinefu.com/commands/random/plaintext)下载一个随机的Commandlinefu示例，使用`wget`程序将下载的文件保存为`/etc/motd`。因此，我们可以在登录系统时直接看到内容。现在，让我们测试一下我们的新脚本：
- en: '![](img/e22ea232-2309-486e-8922-c9e8bb155502.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e22ea232-2309-486e-8922-c9e8bb155502.png)'
- en: 'As you can see, the script has been successfully downloading a Commandlinefu
    from the [http://www.commandlinefu.com/](http://www.commandlinefu.com/) web page.
    To test whether the Commandlinefu web page URL we use truly returns a random command-line
    example, let''s restart our script:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，脚本已成功从[http://www.commandlinefu.com/](http://www.commandlinefu.com/)网页下载了一个Commandlinefu。为了测试我们使用的Commandlinefu网页URL是否真的返回一个随机的命令行示例，让我们重新启动我们的脚本：
- en: '![](img/72e3a481-291c-4e5d-977d-a438557e2864.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72e3a481-291c-4e5d-977d-a438557e2864.png)'
- en: 'As you can see, the command-line example is different this time. Now, based
    on your own preferred schedule of script execution, you need to decide how often
    you want to execute the script. There are some special cron directories in the
    filesystem for execution of system-wide cron jobs, and you can access them using
    `# ls /etc/cron* -d`. The folders are called `cron.daily`, `cron.hourly`, `cron.weekly`,
    and `cron.monthly` and are in the `/etc` directory, and their names refer to the
    time point that they are run. So, if we want our new Commandlinefu script to be
    started on a daily basis, just drop the script file into the `cron.daily` directory
    or create a symbolic link to it using `cd /etc/cron* -d`. If you want to run it
    using a different schedule, just drop it into the `cron.hourly`, `cron.monthly`,
    or `cron.weekly` directories. Just remove the script or the symbolic link from
    the folder if you don''t want to execute it anymore. If you don''t want to run
    system-wide cron jobs, you can also use the `crontab` command as a normal user.
    You can read the `crontab` manual to learn more about this command. Finally, let''s
    test whether the `motd` file is working. Exit out of the SSH session and then
    log in again:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这次的命令行示例是不同的。现在，根据您自己的脚本执行偏好，您需要决定要多久执行一次脚本。文件系统中有一些特殊的cron目录用于执行系统范围的cron作业，您可以使用`#
    ls /etc/cron* -d`来访问它们。这些文件夹称为`cron.daily`、`cron.hourly`、`cron.weekly`和`cron.monthly`，它们位于`/etc`目录中，它们的名称指的是它们运行的时间点。因此，如果我们希望我们的新Commandlinefu脚本每天启动一次，只需将脚本文件放入`cron.daily`目录中，或者使用`cd
    /etc/cron* -d`创建一个符号链接。如果您希望使用不同的时间表运行它，只需将其放入`cron.hourly`、`cron.monthly`或`cron.weekly`目录中。如果您不想再执行它，只需从文件夹中删除脚本或符号链接。如果您不想运行系统范围的cron作业，您也可以作为普通用户使用`crontab`命令。您可以阅读`crontab`手册以了解更多关于这个命令的信息。最后，让我们测试一下`motd`文件是否工作。退出SSH会话，然后重新登录：
- en: '![](img/f57b53a4-dda2-498d-8433-45e31749d239.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f57b53a4-dda2-498d-8433-45e31749d239.png)'
- en: As you can see, it's working beautifully. Based on the cron job we created,
    tomorrow there should be a different command-line example presented here.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它运行得很好。根据我们创建的cron作业，明天应该会在这里呈现一个不同的命令行示例。
- en: In this chapter, we have introduced you to the Linux cron system for script
    automation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了用于脚本自动化的Linux cron系统。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've discussed topics ranging from essential Linux commands,
    signals, processes and Bash shell scripting.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了从基本的Linux命令、信号、进程到Bash shell脚本的各种主题。
- en: In the next chapter, we'll cover advanced command-line concepts.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍高级命令行概念。
