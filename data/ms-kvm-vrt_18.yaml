- en: '*Chapter 14*: Monitoring the KVM Virtualization Platform'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章：监视KVM虚拟化平台
- en: When you move away from an environment that only has a couple of objects to
    manage (for example, KVM hosts) to an environment that has hundreds of objects
    to manage, you start asking yourself very important questions. One of the most
    prominent questions is, *How am I going to monitor my hundreds of objects without
    doing a lot of manual work and with some GUI reporting options?* And the answer
    to that question is the **Elasticsearch, Logstash, Kibana** (**ELK**) stack. In
    this chapter, we'll see what these software solutions can do for you and your
    KVM-based environment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从只有几个对象需要管理的环境（例如KVM主机）转移到需要管理数百个对象的环境时，你会开始问自己一些非常重要的问题。其中一个最突出的问题是，“我要如何在不做大量手动工作并且有一些GUI报告选项的情况下监视我的数百个对象？”这个问题的答案就是Elasticsearch、Logstash、Kibana（ELK）堆栈。在本章中，我们将看到这些软件解决方案对你和基于KVM的环境能做些什么。
- en: Behind those cryptic names are technologies that are here to solve a lot of
    problems you might have when running more than one server. Although you can run
    the ELK stack to monitor one service, it makes no sense to do so. The advice and
    solutions provided in this chapter are applicable to all projects involving multiple
    devices and servers, not only those running on KVM but, in essence, anything that
    is capable of producing any kind of logging. We will start with the basics of
    how to monitor KVM as a virtualization platform in general. Then, we'll move on
    to the ELK stack, including its building blocks and installation, before moving
    on to its advanced configuration and customization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些晦涩的名字背后是一些技术，它们可以解决在运行多个服务器时可能遇到的许多问题。虽然你可以运行ELK堆栈来监视一个服务，但这样做是没有意义的。本章提供的建议和解决方案适用于涉及多个设备和服务器的所有项目，不仅仅是在KVM上运行的项目，而是任何能够产生任何类型日志的项目。我们将从如何监视KVM作为虚拟化平台的基础知识开始。然后，我们将继续讨论ELK堆栈，包括其构建模块和安装，然后再进行高级配置和定制。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Monitoring the KVM virtualization platform
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视KVM虚拟化平台
- en: Introduction to the open source ELK solution
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开源ELK解决方案简介
- en: Setting up and integrating the ELK stack
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和集成ELK堆栈
- en: Configuring the data collector and aggregator
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置数据收集器和聚合器
- en: Creating custom utilization reports
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义利用报告
- en: Let's get started!
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Monitoring the KVM virtualization platform
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视KVM虚拟化平台
- en: When we talk about running a system that is performing any kind of processing,
    we quickly come to the problem of monitoring and making sure that our system runs
    inside a given set of parameters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论运行任何类型的处理系统时，我们很快就会遇到监视和确保我们的系统在给定的一组参数内运行的问题。
- en: When we create a system that is running a workload, it will inevitably produce
    some kind of data on everything that is happening. This data can be almost infinite
    in its scope – a server that is just online, without a single *useful* task running
    will create some kind of log or service data, such as the amount of used memory,
    services that are starting or stopping, the amount of disk space left, devices
    that are connecting and disconnecting, and more.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个运行工作负载的系统时，它将不可避免地产生一些关于正在发生的一切的数据。这些数据的范围几乎是无限的——一个只在线而没有单个“有用”任务运行的服务器将创建一些日志或服务数据，比如已使用的内存量、正在启动或停止的服务、剩余的磁盘空间量、连接和断开的设备等。
- en: When we start running any useful task, the logs will only get larger.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始运行任何有用的任务时，日志只会变得越来越大。
- en: Having a good and verbose log means that we can find what is going on at this
    instant with the system; is it running correctly and do we need to do something
    to make it run better? If something unexpected happens, logs can help us determine
    what is actually wrong and point us in the direction of the solution. Correctly
    configured logs can even help us spot errors before they start to create problems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个良好且详细的日志意味着我们可以找到系统当前的运行情况；它是否正常运行，我们是否需要做一些事情让它运行得更好？如果发生了意外情况，日志可以帮助我们确定实际出了什么问题，并指引我们找到解决方案的方向。正确配置的日志甚至可以帮助我们在问题开始制造麻烦之前发现错误。
- en: Suppose you have a system that is getting slower and slower week after week.
    Let's further suppose that our problem is with the memory allocation of an app
    we installed on the system. But let's also suppose that this memory allocation
    is not constant, and instead varies with the number of users using the system.
    If you take a look at any point in time, you may notice the number of users and
    memory allocated. But if you just take measurements at different times, you will
    have a hard time understanding what kind of correlation there is between the memory
    and the number of users – will the amount of memory allocated be linear to the
    number of users or will it behave exponentially? If we can see that 100 users
    are using 100 MB of memory, does that mean that 1,000 users will use 1,000 MB?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个系统，每周都在变得越来越慢。让我们进一步假设我们的问题出在我们在系统上安装的应用程序的内存分配上。但也让我们假设这个内存分配是不固定的，而是随着使用系统的用户数量而变化的。如果你在任何时间点看一下，你可能会注意到用户数量和分配的内存。但如果你只在不同的时间测量，你会很难理解内存和用户数量之间有什么样的相关性——分配的内存量是否与用户数量成线性关系，还是呈指数增长？如果我们能看到100个用户使用100MB内存，那是否意味着1000个用户将使用1000MB？
- en: But let's suppose that we are logging the amount of memory and the number of
    users at equally spaced intervals.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但假设我们正在记录内存量和用户数量在等间隔时间内的情况。
- en: We are not doing anything complicated; every couple of seconds, we are writing
    down the time of the measurement, the amount of memory allocated, and the number
    of users using the system. We are creating something called a dataset, consisting
    of **data points**. Using data points is no different than what we did in the
    preceding example, but once we have a dataset, we can do trend analysis. Basically,
    instead of looking at a slice of the problem, we can analyze different time segments
    and compare the number of users and what the amount of memory they were using
    actually was. That will give us important information about how our system is
    actually using our memory and at what point we had a problem, even if we don't
    have a problem right now.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有做什么复杂的事情；每隔几秒，我们都会记录测量时间、分配的内存量和使用系统的用户数量。我们正在创建一个称为**数据点**的数据集。使用数据点与我们在前面的例子中所做的没有什么不同，但一旦我们有了数据集，我们就可以进行趋势分析。基本上，我们可以分析不同的时间段，比较用户数量以及他们实际使用的内存量。即使我们现在没有问题，这将为我们提供有关我们的系统实际如何使用内存以及我们何时出现问题的重要信息。
- en: This approach can even help us find and troubleshoot problems that are non-obvious,
    such as a backup that is taking too long to finish once a month and works normally
    the rest of the time. This kind of capability that enables us to spot trends and
    analyze data and system performance is what logging is all about.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法甚至可以帮助我们找到和解决那些不明显的问题，比如每个月备份花费太长时间才能完成，而其他时间都正常工作。这种能力使我们能够发现趋势并分析数据和系统性能，这就是日志记录的全部意义。
- en: 'Put simply, any kind of monitoring boils down to two things: collecting data
    from the thing we are trying to monitor and analyzing that data.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，任何类型的监控都归结为两件事：从我们试图监控的事物中收集数据，然后分析这些数据。
- en: Monitoring can be either online or offline. Online monitoring is useful when
    we are trying to create some sort of alerting system or when we are trying to
    establish the self-correcting system that will be able to respond to changes in
    the process. Then, we can either try to correct problems or shut down or restart
    the system. Online monitoring is usually used by the operations team in order
    to make sure that everything is running smoothly and that the problems the system
    may have are logged.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 监控可以是在线的，也可以是离线的。在线监控在我们试图创建某种警报系统或者试图建立能够响应过程变化的自我纠正系统时非常有用。然后，我们可以尝试纠正问题或关闭或重新启动系统。在线监控通常由运维团队使用，以确保一切运行顺利，并记录系统可能出现的问题。
- en: Offline monitoring is much more complicated. Offline monitoring enables us to
    gather all the data into logs, analyze these logs later, and extrapolate trends
    and figure out what can be done to the system to make it better. But the fact
    of the matter is that it's always *delayed* in terms of real-time activity since
    the offline methodology requires us to *download* and then *analyze* the logs.
    That's why we prefer real-time log ingestion, which is something that needs to
    be done online. That's why learning about the ELK stack is so important.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 离线监控要复杂得多。离线监控使我们能够将所有数据收集到日志中，稍后分析这些日志，并推断趋势，找出如何改进系统。但事实是，它总是*延迟*的，因为离线方法要求我们*下载*然后*分析*日志。这就是为什么我们更喜欢实时日志摄入，这是需要在线完成的事情。这就是为什么学习ELK堆栈如此重要。
- en: By fitting all these small pieces – real-time log ingestion, search, analytics,
    and reports –into one larger stack, ELK makes it easier for us to monitor our
    environment in real time. Let's learn how.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将所有这些小组件-实时日志摄入、搜索、分析和报告-组合成一个更大的堆栈，ELK使我们能够更容易地实时监控我们的环境。让我们来学习一下。
- en: Introduction to the open source ELK solution
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开源ELK解决方案简介
- en: We mentioned previously that ELK stands for Elasticsearch, Logstash, and Kibana
    because these three applications or systems are the building blocks of a complete
    monitoring and reporting solution. Each part has its own purpose and functions
    it performs – Logstash gathers all the data into a consistent database, Elasticsearch
    is able to quickly go through all the data that Logstash stored, and Kibana is
    here to turn search results into something that is both informational and visually
    appealing. Having said all this, ELK recently changed its name. Although it is
    still referred to as the ELK Stack, and almost the entirety of the internet will
    call it that, the ELK stack is now named the Elastic Stack, for the sole reason
    that, at the time of writing, there is another fourth component included in the
    stack. This component is called Beats, and it represents a significant addition
    to the whole system.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到ELK代表Elasticsearch、Logstash和Kibana，因为这三个应用程序或系统是完整监控和报告解决方案的基本组成部分。每个部分都有自己的目的和功能-Logstash将所有数据收集到一个一致的数据库中，Elasticsearch能够快速浏览Logstash存储的所有数据，而Kibana则将搜索结果转化为信息丰富且视觉上吸引人的内容。说了这么多，ELK最近更改了其名称。尽管它仍然被称为ELK堆栈，几乎整个互联网都会这样称呼它，但ELK堆栈现在被称为Elastic
    Stack，原因是在撰写本文时，堆栈中还包括另一个第四个组件。这个组件被称为Beats，它代表整个系统的重要补充。
- en: But let's start from the beginning and try to describe the whole system the
    way its creators describe it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们从头开始，尝试以其创建者描述的方式描述整个系统。
- en: Elasticsearch
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Elasticsearch
- en: The first component that was created and that got traction in the community
    was Elasticsearch, created to be a flexible, scalable system for indexing and
    searching large datasets. Elasticsearch was used for thousands of different purposes,
    including searching for specific content in documents, websites, or logs. Its
    main selling point and the reason a lot of people started using it is that it
    is both flexible and scalable, and at the same time extremely fast.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建并在社区中获得关注的组件是Elasticsearch，它被创建为一个灵活、可扩展的系统，用于索引和搜索大型数据集。Elasticsearch被用于成千上万种不同的用途，包括在文档、网站或日志中搜索特定内容。它的主要卖点和许多人开始使用它的原因是它既灵活又可扩展，同时速度极快。
- en: When we think of searching, we usually think about creating some kind of query
    and then waiting for the database to give us back some form of answer. In complex
    searches, the problem is usually the waiting since it is exhausting having to
    tweak our queries and wait for them to produce results. Since a lot of modern
    data science relies on the concept of non-structured data, meaning that a lot
    of data that we need to search has no fixed structure, or no structure at all,
    creating a fast way to search inside this pool of data is a tough problem.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑搜索时，我们通常会考虑创建某种查询，然后等待数据库给我们一些形式的答案。在复杂的搜索中，问题通常是等待，因为不断调整我们的查询并等待它们产生结果是很累人的。由于许多现代数据科学依赖于非结构化数据的概念，这意味着我们需要搜索的许多数据没有固定的结构，或者根本没有结构，因此在这些数据池中创建快速搜索的方法是一个棘手的问题。
- en: Imagine you need to find a certain book in a library. Also, imagine you do not
    have a database of all the books, authors, publishing information, and everything
    else that a normal library has; you are only allowed to search through all the
    books themselves.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你需要在图书馆里找到一本特定的书。再想象一下，你没有所有书籍、作者、出版信息和其他一切正常图书馆都有的数据库；你只被允许搜索所有的书籍。
- en: Having a tool that is able to recognize patterns in those books and that can
    tell you the answer to questions such as *who wrote this book?* or *how many times
    is KVM mentioned in all the books that are longer than 200 pages?* is a really
    useful thing. This is what a good search solution does.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一种能够识别这些书中的模式并告诉您答案的工具，比如*谁写了这本书？*或*在所有超过200页的书中KVM被提到了多少次？*是一件非常有用的事情。这就是一个好的搜索解决方案所做的事情。
- en: Being able to search for a machine that is running the Apache web server and
    has problems with a certain page requested by a certain IP address is essential
    if we want to quickly and efficiently administer a cluster or a multitude of clusters
    of physical and virtual servers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要快速有效地管理一个集群或多个集群的物理和虚拟服务器，那么能够搜索运行Apache web服务器并且在某个IP地址请求的某个页面上出现问题的机器是至关重要的。
- en: The same goes for system information when we are monitoring even a single point
    of data, such as memory allocation across hundreds of hosts. Even presenting that
    data is a problem and searching for it in real time is almost impossible without
    the right tool.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们监控系统信息时，即使是单个数据点，比如跨数百台主机的内存分配，也是一个问题，即使是呈现这些数据也是一个问题，而在实时搜索中查找这些数据几乎是不可能的，没有正确的工具。
- en: 'Elasticsearch does exactly that: it creates a way for us to quickly go through
    enormous amounts of barely structured data and then comes up with results that
    make sense. What makes Elasticsearch different is its ability to scale, which
    means you can use it to create search queries on your laptop, and later just run
    them on a multi-node instance that searches through a petabyte of data.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch确实做到了这一点：它为我们快速浏览大量几乎没有结构的数据创造了一种方式，然后得出有意义的结果。Elasticsearch的不同之处在于其可扩展性，这意味着您可以使用它在笔记本电脑上创建搜索查询，然后在多节点实例上运行这些查询，搜索PB级的数据。
- en: Elasticsearch is also fast, and this is not something that only saves time.
    Having the ability to get search results faster gives you a way to learn more
    about your data by creating and modifying queries and then understanding their
    results.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Elasticsearch也很快，这不仅节省时间。能够更快地获取搜索结果的能力使您能够通过创建和修改查询，然后理解其结果来更多地了解您的数据。
- en: Since this is just a simple introduction to what ELK actually does, we will
    switch to the next component, Logstash, and come back to searching a bit later.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这只是对ELK实际做的事情的简单介绍，我们将转到下一个组件Logstash，并稍后回到搜索。
- en: Logstash
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Logstash
- en: Logstash has a simple purpose. It is designed to be able to digest any number
    of logs and events that generate data and store them for future use. After storing
    them, it can export them in multiple formats such as email, files, HTTP, and others.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Logstash有一个简单的目的。它旨在能够消化任意数量的生成数据的日志和事件，并将它们存储以备将来使用。存储后，它可以以多种格式导出，如电子邮件、文件、HTTP等。
- en: What is important about how Logstash works is its versatility in accepting different
    input streams. It is not limited to using only logs; it can even accept things
    such as Twitter feeds.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Logstash的重要之处在于它的多功能性，可以接受不同的输入流。它不仅限于使用日志；甚至可以接受诸如Twitter feeds之类的东西。
- en: Kibana
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kibana
- en: The last part of the old ELK stack is Kibana. If Logstash is storage and Elasticsearch
    is for computing, then Kibana is the output engine. Simply put, Kibana is a way
    to use the results of Elasticsearch queries to create visually impressive and
    highly customizable layouts. Although the output of Kibana is usually some kind
    of a dashboard, its output can be many things, depending on the user's ability
    to create new layouts and visualize data. Having said all this, don't be afraid
    – the internet offers at least a partial, if not full solution, to almost every
    imaginable scenario.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 旧ELK堆栈的最后一部分是Kibana。如果Logstash是存储，Elasticsearch是计算，那么Kibana就是输出引擎。简而言之，Kibana是一种利用Elasticsearch查询结果创建视觉上令人印象深刻且高度可定制布局的方法。尽管Kibana的输出通常是某种仪表板，但其输出可以是许多东西，取决于用户创建新布局和可视化数据的能力。说了这么多，不要害怕-互联网提供了几乎每种想象的场景的至少部分，如果不是全部的解决方案。
- en: Next, what we will do is go through the basic installation of the ELK stack,
    show what it can do, point you in the right direction, and demonstrate one of
    the most popular *beats* – **metricbeat**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍ELK堆栈的基本安装，展示它的功能，指导您正确的方向，并演示最受欢迎的*beats*之一-**metricbeat**。
- en: Using the ELK stack is, in many ways, identical to *running* a server – what
    you need to do depends on what you actually want to accomplish; it takes only
    a couple of minutes to get the ELK stack running, but the real effort only starts
    there.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ELK堆栈在许多方面与运行服务器相同-你需要做什么取决于你实际想要实现什么；只需几分钟就可以让ELK堆栈运行起来，但真正的努力却是从那时开始。
- en: Of course, for us to fully understand how the ELK stack is used in a live environment,
    we need to deploy it and set it up first. We'll do that next.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了充分理解ELK堆栈在实际环境中的使用方式，我们需要先部署和设置它。我们接下来就要做这件事。
- en: Setting up and integrating the ELK stack
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立和集成ELK堆栈
- en: Thankfully, almost everything that we need to install is already prepared by
    the Elasticsearch team. Aside from Java, everything is nicely sorted and documented
    on their site.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 值得庆幸的是，几乎我们需要安装的所有东西都已经由Elasticsearch团队准备好了。除了Java，其他所有东西都在他们的网站上得到了很好的整理和记录。
- en: 'The first thing you need to do is install Java – ELK depends on Java to run,
    so we need to have it installed. Java has two different install candidates: the
    official one from Oracle and the open source OpenJDK. Since we are trying to stay
    in the open source ecosystem, we''ll install OpenJDK. In this book, we are using
    CentOS 8 as our platform, so the `yum` package manager will be used extensively.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是安装Java - ELK依赖于Java运行，因此我们需要安装它。Java有两种不同的安装候选项：来自Oracle的官方安装和开源的OpenJDK。由于我们试图留在开源生态系统中，我们将安装OpenJDK。在本书中，我们使用CentOS
    8作为我们的平台，因此将广泛使用`yum`软件包管理器。
- en: 'Let''s start with the prerequisite packages. The only prerequisite package
    we need in order to install Java is the `java-11-OpenJDK-devel` package (substitute
    "11" with the current version of OpenJDK). So, here, we need to run the following
    command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从先决条件软件包开始。我们安装Java所需的唯一先决条件软件包是`java-11-OpenJDK-devel`软件包（用当前的OpenJDK版本替换“11”）。因此，在这里，我们需要运行以下命令：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After issuing that command, you should get a result like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 发出该命令后，您应该会得到如下结果：
- en: '![Figure 14.1 – Installing one of the main prerequisites – Java'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.1 - 安装主要先决条件之一 - Java'
- en: '](img/B14834_14_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_01.jpg)'
- en: Figure 14.1 – Installing one of the main prerequisites – Java
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 - 安装主要先决条件之一 - Java
- en: 'Once installed, we can verify whether the setup was successful and whether
    Java is working properly by running the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以通过运行以下命令来验证安装是否成功以及Java是否正常工作：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is the expected output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的输出：
- en: '![Figure 14.2 – Checking Java''s version'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.2 - 检查Java的版本'
- en: '](img/B14834_14_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_02.jpg)'
- en: Figure 14.2 – Checking Java's version
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 - 检查Java的版本
- en: The output should be the current version of Java and no errors. Other than verifying
    whether Java works, this step is important in order to verify that the path to
    Java is correctly set – if you are running on some other distributions, you may
    have to set the path manually.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该是当前的Java版本和没有错误。除了验证Java是否正常工作之外，这一步还很重要，以便验证Java的路径是否设置正确 - 如果您在其他发行版上运行，可能需要手动设置路径。
- en: 'Now that java is installed and ready to go, we can continue with the installation
    of the ELK stack. The next step is to configure the install source for Elasticsearch
    and other services:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Java已经安装并准备就绪，我们可以继续安装ELK堆栈。下一步是配置Elasticsearch和其他服务的安装源：
- en: 'We need to create a file in `/etc/yum.repos.d/` named `elasticsearch.repo`
    that will contain all the information about our repository:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在`/etc/yum.repos.d/`中创建一个名为`elasticsearch.repo`的文件，其中将包含有关我们存储库的所有信息：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Save the file. The important thing here is that the repository is GPG-signed,
    so we need to import its key and apply it so that the packages can be verified
    when they're downloaded.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件。这里重要的是仓库是GPG签名的，所以我们需要导入它的密钥并应用它，以便在下载时可以验证软件包。
- en: The files that you are going to install are not free software. Elasticsearch
    has two distinct free versions and a paid subscription model. What you are going
    to get using the files in this repository is the subscription-based install that
    is going to run in *basic* mode, which is free. At the time of writing, Elastic
    has four subscription models – one is open source, based on the Apache License
    2.0, and free; the rest of them are closed source but offer additional functionalities.
    Currently, these subscriptions are named Basic, Gold, and Platinum. Basic is free,
    while the other models require a monthly paid subscription.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您要安装的文件不是免费软件。Elasticsearch有两个不同的免费版本和一个付费订阅模型。使用此存储库中的文件将获得基于订阅的安装，该安装将在*basic*模式下运行，该模式是免费的。在撰写本文时，Elastic有四种订阅模型
    - 一种是基于Apache License 2.0的开源模型，免费；其余的都是闭源的，但提供额外的功能。目前，这些订阅被命名为Basic、Gold和Platinum。Basic是免费的，而其他模型需要每月付费订阅。
- en: You will inevitably ask why you should choose open source over Basic, or vice
    versa since they are both free. While both of them have the same core, Basic is
    more advanced as it offers core security features and more things that can be
    important in everyday use, especially if you are after Kibana visualizations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定会问为什么你应该选择开源而不是Basic，或者反过来，因为它们都是免费的。虽然它们都有相同的核心，但Basic更先进，因为它提供了核心安全功能和更多在日常使用中可能很重要的东西，特别是如果你追求Kibana可视化。
- en: 'Let''s continue with the installation and import the necessary GPG key:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续安装并导入必要的GPG密钥：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we are ready to do some housekeeping on the system side and grab all the
    changes in the repository system:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备在系统端进行一些维护工作，并获取存储库系统中的所有更改：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: elasticsearch nor any of the other services are going to be started or enabled
    automatically. We must do this manually for each of them. Let's do that now.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: elasticsearch或任何其他服务都不会自动启动或启用。我们必须为它们中的每一个手动执行此操作。现在让我们来做这件事。
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The procedure to start and enable services is standard and is the same for
    all three services:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动和启用服务的过程是标准的，对所有三个服务都是相同的：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The last thing to do is installing *beats*, which are services that are usually
    installed on the monitored servers, and which can be configured to create and
    send important metrics on the system. Let's do that now.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的就是安装*beats*，这些服务通常安装在受监视的服务器上，并且可以配置为创建和发送系统上的重要指标。现在让我们来做这件事。
- en: 'For the purpose of this demonstration, we will install them all, although we
    are not going to use all of them:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将安装它们所有，尽管我们不会使用它们所有：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After this, we should have a functional system. Let's have a quick overview.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们应该有一个功能齐全的系统。让我们快速回顾一下。
- en: 'Kibana and Elasticsearch are both running as web services, on different ports.
    We are going to interact with Kibana via the web browser (using the URLs `http://localhost:9200`
    and `http://localhost:5601`) since this is where the visualization happens:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Kibana和Elasticsearch都作为Web服务运行在不同的端口上。我们将通过Web浏览器与Kibana进行交互（使用URL `http://localhost:9200`和`http://localhost:5601`），因为这是可视化发生的地方：
- en: '![Figure 14.3 – Checking the Elasticsearch service'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.3 – 检查Elasticsearch服务'
- en: '](img/B14834_14_03.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_03.jpg)'
- en: Figure 14.3 – Checking the Elasticsearch service
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – 检查Elasticsearch服务
- en: 'Now, we can connect to Kibana on port `5601`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在端口`5601`上连接到Kibana：
- en: '![Figure 14.4 – Successful connection to Kibana'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.4 – 成功连接到Kibana'
- en: '](img/B14834_14_04.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_04.jpg)'
- en: Figure 14.4 – Successful connection to Kibana
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 – 成功连接到Kibana
- en: With that, the deployment process was finished successfully. Our logical next
    step would be to create a workflow. Let's do that now.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 部署过程已经成功完成。我们的下一个逻辑步骤将是创建一个工作流程。让我们现在就做。
- en: Workflow
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作流程
- en: In this section, we are going to establish a workflow – we are going to create
    logs and metrics that are going to be ingested into Logstash, queried via Elasticsearch,
    and then visually represented in Kibana.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将建立一个工作流程 – 我们将创建日志和指标，这些日志和指标将被摄入Logstash，通过Elasticsearch查询，然后在Kibana中进行可视化呈现。
- en: By default, Kibana runs on port `5601`, which can be changed in the configuration.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kibana运行在端口`5601`上，这可以在配置中更改。
- en: But what does this mean for me? What does this mean for KVM?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但这对我意味着什么？这对KVM意味着什么？
- en: The biggest selling point for using Elastic stack is flexibility and ease of
    presentation. It doesn't matter if we are running one, 10, or 1,000 machines inside
    dozens of KVM hosts; we can treat them the same in production and establish a
    stable monitoring workflow. Using extremely simple scripts, we can create completely
    custom metrics and quickly display them, we can watch for trends, and we can even
    create a near-real-time monitoring system. All this, essentially for free.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Elastic Stack的最大卖点是灵活性和简单的展示方式。无论我们在几十个KVM主机内运行一台、10台还是1,000台机器，我们都可以在生产中以相同的方式对待它们，并建立稳定的监控工作流程。使用极其简单的脚本，我们可以创建完全定制的指标并快速显示它们，我们可以观察趋势，甚至可以创建一个几乎实时的监控系统。所有这些，基本上都是免费的。
- en: Let's create a simple monitor that is going to dump system metrics for the host
    system that is running ELK. We've already installed Metricbeat, so the only thing
    left is to configure the service to send the data to Elasticsearch. Data is sent
    to Elasticsearch, not Logstash, and this is simply because of the way that the
    services interoperate. It is possible to send both to Logstash and Elasticsearch,
    so we need to do a quick bit of explaining here.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的监视器，用于为运行ELK的主机系统转储系统指标。我们已经安装了Metricbeat，所以唯一剩下的就是配置服务将数据发送到Elasticsearch。数据发送到Elasticsearch，而不是Logstash，这仅仅是因为服务之间的相互操作方式。可以将数据同时发送到Logstash和Elasticsearch，因此我们需要在这里做一点快速的解释。
- en: Logstash is, by definition, a service that stores data that's sent to it. Elasticsearch
    searches that data and communicates with Logstash. If we send the data to Logstash,
    we are not doing anything wrong; we are just dumping data for later analysis.
    But sending to Elasticsearch gives us one more feature – we can send not only
    data but also information about the data in the form of templates.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Logstash从定义上来说是一个存储发送到它的数据的服务。Elasticsearch搜索该数据并与Logstash通信。如果我们将数据发送到Logstash，我们并没有做错什么；我们只是为以后的分析转储数据。但是，将数据发送到Elasticsearch还给了我们一个功能
    – 我们不仅可以发送数据，还可以以模板的形式发送关于数据的信息。
- en: On the other hand, Logstash has the ability to perform data transformation right
    after it receives it and before data is stored, so if we need to do things such
    as parse GeoIP information, change the names of hosts, and so on, we will probably
    use Logstash as our primary destination. Keeping that in mind, do not set Metricbeat
    so that it sends data both to Elasticsearch and Logstash; you will only get duplicate
    data stored in the database.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Logstash具有在接收数据后并在数据存储之前执行数据转换的能力，因此，如果我们需要执行诸如解析GeoIP信息、更改主机名称等操作，我们可能会将Logstash作为我们的主要目的地。牢记这一点，不要设置Metricbeat以便将数据同时发送到Elasticsearch和Logstash；否则，您将只会在数据库中获得重复的数据。
- en: Using ELK is simple, and we've got this far into the installation without any
    real effort. When we start analyzing the data is when the real problems start.
    Even simple and perfectly formatted data that comes out of Metricbeat can be complex
    to visualize, especially if we are doing it for the first time. Having premade
    templates both for Elasticsearch and Kibana saves a lot of time.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ELK很简单，我们已经在安装过程中毫不费力地进行了这一步。当我们开始分析数据时，真正的问题就开始了。即使是来自Metricbeat的简单且完全格式良好的数据，也可能很难可视化，特别是如果我们是第一次这样做的话。为Elasticsearch和Kibana准备的预制模板可以节省大量时间。
- en: 'Take a look at the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下的屏幕截图：
- en: '![Figure 14.5 – Metricbeat dashboard'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.5 – Metricbeat仪表板'
- en: '](img/B14834_14_05.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_05.jpg)'
- en: Figure 14.5 – Metricbeat dashboard
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 – Metricbeat仪表板
- en: It takes no more than 10 minutes of setup to get a complete dashboard like this
    one. Let's go through this step by step.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 只需不到10分钟的设置，就可以获得一个像这样的完整仪表板。让我们一步一步地进行。
- en: We already have Metricbeat installed and only need to configure it, but before
    that, we need to configure Logstash. We only need to define one *pipeline*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经安装了Metricbeat，只需要配置它，但在此之前，我们需要配置Logstash。我们只需要定义一个*pipeline*。
- en: So, how can data be transformed?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，数据如何被转换？
- en: Up until now, we did not go into details regarding how Logstash functions, but
    to create our first set of data, we need to know some of the inner workings of
    Logstash. Logstash uses a concept of a pipeline to define what happens to data
    once it's received, and before that data is sent to Elasticsearch.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有详细介绍Logstash的功能，但是为了创建我们的第一组数据，我们需要了解Logstash的一些内部工作原理。Logstash使用管道的概念来定义数据在接收到数据后发生的情况，以及在将数据发送到Elasticsearch之前。
- en: 'Each pipeline has two required, and one optional, elements:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个管道都有两个必需的元素和一个可选的元素：
- en: The input is always the first in the pipeline and is designed to receive data
    from the source.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入始终是管道中的第一个，并且旨在从源接收数据。
- en: The output is the last element in the pipeline, and it outputs the data.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出是管道中的最后一个元素，并且输出数据。
- en: The filter is an optional element and stands between the input and output in
    order to modify the data in accordance with the rules that we can define.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器是一个可选元素，位于输入和输出之间，以便根据我们可以定义的规则修改数据。
- en: All these elements can be chosen from a list of plugins in order for us to create
    an optimal pipeline adjusted for a specific purpose. Let's go through this step
    by step.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些元素都可以从插件列表中选择，以便我们创建一个针对特定目的调整的最佳管道。让我们一步一步地进行。
- en: What we need to do is just uncomment the one pipeline that is defined in the
    configuration file, located in the `/etc/logstash` folder.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的就是取消注释配置文件中定义的一个管道，该文件位于`/etc/logstash`文件夹中。
- en: The whole stack uses YAML as the standard for the configuration file structure,
    so every configuration file ends with the `.yml` extension. This is important
    in order to understand that all the files that do not have this extension are
    here as either a sample or some kind of template for the configuration; only files
    with the `.yml` extension will get parsed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 整个堆栈使用YAML作为配置文件结构的标准，因此每个配置文件都以`.yml`扩展名结尾。这一点很重要，以便理解所有没有此扩展名的文件都在这里作为样本或某种配置模板；只有带有`.yml`扩展名的文件才会被解析。
- en: 'To configure Logstash, just open `logstash.yml` and uncomment all the lines
    that are related to the first pipeline, called `main`. We don''t need to do anything
    else. The file itself is located in the `/etc/logstash` folder, and should look
    something like this after you make these changes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置Logstash，只需打开`logstash.yml`并取消注释与第一个管道`main`相关的所有行。我们不需要做其他事情。该文件本身位于`/etc/logstash`文件夹中，在您进行这些更改后应该看起来像这样：
- en: '![Figure 14.6 – The logstash.yml file'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.6 - logstash.yml文件'
- en: '](img/B14834_14_06.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_06.jpg)'
- en: Figure 14.6 – The logstash.yml file
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 - logstash.yml文件
- en: The next thing we need to do is configure Metricbeat.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的下一件事是配置Metricbeat。
- en: Configuring data collector and aggregator
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置数据收集器和聚合器
- en: 'In the previous steps, we managed to deploy Metricbeat. Now, we need to start
    the actual configuration. So, let''s go through the configuration procedure, step
    by step:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的步骤中，我们成功部署了Metricbeat。现在，我们需要开始实际的配置。因此，让我们一步一步地进行配置过程：
- en: Go to `/etc/metricbeat` and open `metricbeat.yml`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`/etc/metricbeat`并打开`metricbeat.yml`。
- en: 'Uncomment the lines that define `elasticsearch` as the target for Metricbeat.
    Now, we need to change one more thing. Find the line containing the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 取消注释定义`elasticsearch`为Metricbeat目标的行。现在，我们需要改变一件事。找到包含以下内容的行：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Change the preceding line to the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的行更改为以下内容：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We need to do this to load to dashboards so that we can use them.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这样做来加载仪表板，以便我们可以使用它们。
- en: 'The rest of the configuration is done from the command line. Metricbeat has
    a couple of commands that can be run, but the most important is the following
    one:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其余的配置都是通过命令行完成的。Metricbeat有几个可以运行的命令，但最重要的是以下命令：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This command will go through the initial setup. This part of the setup is probably
    the most important thing in the whole initial configuration – pushing the dashboard
    templates to Kibana. These templates will enable you to get up and running in
    a couple of clicks, as opposed to learning how to do visualization and configuring
    it from scratch. You will have to do this eventually but for this example, we
    want to get things running as quickly as possible.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将通过初始设置。设置的这一部分可能是整个初始配置中最重要的事情 - 将仪表板模板推送到Kibana。这些模板将使您能够在几次点击之内启动和运行，而不是学习如何进行可视化和从头开始配置。您最终将不得不这样做，但是对于这个示例，我们希望尽快让事情运行起来。
- en: 'One more command that you need right now is the following one:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在需要的另一个命令是以下命令：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: metricbeat modules enable kvm
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: metricbeat模块启用kvm
- en: metricbeat modules enable logstash
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: metricbeat模块启用logstash
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `logstash` module is confusingly named since it is not intended to push
    data to Logstash; instead, its main purpose is to report the Logstash service
    and enable you to monitor it through Logstash. Sound confusing? Let''s rephrase
    this: this module enables Logstash to monitor itself. Or to be more precise, it
    enables beats to monitor part of the Elastic stack.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`logstash`模块的命名令人困惑，因为它并不打算将数据推送到Logstash；相反，它的主要目的是报告Logstash服务，并使您能够通过Logstash监视它。听起来困惑吗？让我们重新表达一下：这个模块使Logstash能够监视自己。或者更准确地说，它使beats能够监视Elastic堆栈的一部分。'
- en: The KVM module is a template that will enable you to gather different KVM-related
    metrics.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: KVM模块是一个模板，将使您能够收集不同的与KVM相关的指标。
- en: 'This should be it. As a precaution, type in the following command to check
    Metricbeat''s configuration:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。作为预防措施，键入以下命令以检查Metricbeat的配置：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the preceding command runs okay, start the Metricbeat service using the
    following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的命令运行正常，请使用以下命令启动Metricbeat服务：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You now have a running service that is gathering data on your host – the same
    one that is running KVM and dumping that data into Elasticsearch. This is essential
    since we are going to use all that data to create visualizations and dashboards.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在有一个正在运行的服务，正在收集您主机上的数据 - 与运行KVM并将数据转储到Elasticsearch的主机相同。这是至关重要的，因为我们将使用所有这些数据来创建可视化和仪表板。
- en: Creating charts in Kibana
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Kibana中创建图表
- en: Now, open Kibana in a browser using `localhost:5601` as the address. There should
    be an icon-based menu on the left-hand side of the screen. Go to **Stack management**
    and take a look at **Elasticsearch index management**.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中使用`localhost:5601`作为地址打开Kibana。屏幕左侧应该有一个基于图标的菜单。转到**堆栈管理**，查看**Elasticsearch索引管理**。
- en: There should be an active index named `metricbeat-`*<somenumber>*. In this particular
    example, *<somenumber>* will be the current version of metricbeat and the date
    of the first entry in the log file. This is completely arbitrary and is just a
    default that ensures you know when this instance was started.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 应该有一个名为`metricbeat-`*<somenumber>*的活动索引。在这个特定的例子中，*<somenumber>*将是metricbeat的当前版本和日志文件中第一个条目的日期。这完全是任意的，只是一个默认值，确保您知道此实例何时启动。
- en: 'In the same line as this name, there should be some numbers: what we are interested
    in is the docs count – the number of objects that database holds. For the time
    being, if it''s not zero, we are okay.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与此名称相同的一行中应该有一些数字：我们感兴趣的是文档计数 - 数据库持有的对象数量。暂时来说，如果不是零，我们就没问题。
- en: 'Now, go to the **Dashboard** page and open the **Metricbeat System Overview
    ECS** dashboard. It will show a lot of visual widgets representing CPU, memory,
    disk, and network usage:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到**仪表板**页面，打开**Metricbeat系统概览ECS**仪表板。它将显示许多可视化小部件，代表CPU、内存、磁盘和网络使用情况：
- en: '![Figure 14.7 – Overview of the ECS dashboard'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.7 - ECS仪表板概览'
- en: '](img/B14834_14_07.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_07.jpg)'
- en: Figure 14.7 – Overview of the ECS dashboard
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7 - ECS仪表板概览
- en: Now, you can click on `last 15 minutes`. After you click the **Refresh** button,
    new data should show on the page.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以点击“最近15分钟”。在您点击**刷新**按钮之后，新数据应该显示在页面上。
- en: With that, you now know enough about Kibana to get started, but we still are
    unable to visualize KVM data. The next step is to create a dashboard that will
    cover that.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，您现在已经了解了足够的关于Kibana的知识，但我们仍然无法可视化KVM数据。下一步是创建一个覆盖这一点的仪表板。
- en: But before we do that, think about what you can do with only what we've learned
    so far. Not only can you monitor the local system that has your KVM stack installed,
    but you can also monitor any system that is able to run Metricbeat. The only thing
    that you need to know is the IP address of the ELK stack, so that you can send
    data to it. Kibana will automatically deal with visualizing all the different
    data from different systems, as we will see later.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们这样做之前，想想我们到目前为止学到的东西可以做什么。您不仅可以监视安装了KVM堆栈的本地系统，还可以监视任何能够运行Metricbeat的系统。您唯一需要知道的是ELK堆栈的IP地址，以便您可以向其发送数据。Kibana将自动处理来自不同系统的所有不同数据的可视化，我们稍后将看到。
- en: Creating custom utilization reports
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义利用率报告
- en: Since version 7, Elastic stack has introduced mandatory checks that are designed
    to ensure minimum security and functionality compliance, especially once we start
    using ELK in production.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本7以来，Elastic stack引入了强制性检查，旨在确保最低安全性和功能合规性，特别是一旦我们开始在生产中使用ELK。
- en: At first glance, these checks may confuse you – the installation that we guided
    you through will work, and suddenly, as you try to configure some settings, everything
    will fail. This is intentional.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这些检查可能会让您困惑 - 我们引导您完成的安装将正常工作，突然间，当您尝试配置一些设置时，一切都会失败。这是有意的。
- en: In previous versions, these checks were performed but were flagged as warnings
    if a configuration item was missed or misconfigured. Starting from version 7,
    these checks will trigger an error when the system is in production and not configured
    correctly. This state automatically means that your installation will not work
    if it's not configured properly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的版本中，这些检查是执行的，但如果错过或配置错误了配置项，它们会被标记为警告。从第7版开始，如果系统处于生产状态且配置不正确，这些检查将触发错误。这种状态自动意味着如果配置不正确，您的安装将无法工作。
- en: 'ELK has two distinct modes of operation: *development* and *production*. On
    the first installation, it is assumed that you are in development mode, so most
    of the functionality simply works out of the box.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ELK有两种不同的操作模式：*开发*和*生产*。在第一次安装时，假定您处于开发模式，因此大多数功能都可以直接使用。
- en: Things change a lot once you go into production mode – security settings and
    other configuration options need to be explicitly set in order for the stack to
    function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入生产模式，事情就会发生很大变化 - 安全设置和其他配置选项需要明确设置，以使堆栈正常运行。
- en: The trick is that there is no explicit mode change – production settings and
    checks associated with them are triggered by some settings in the configuration.
    The idea is that once you reconfigure something that can be important from a security
    standpoint, you need to reconfigure everything correctly. This will prevent you
    from forgetting something that can be a big problem in production and force you
    to have at least a stable configuration to start from. There is a switch to disable
    checks, but it is not recommended in any circumstances.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 诀窍在于没有明确的模式更改 - 与之相关的生产设置和检查是由配置中的一些设置触发的。这个想法是一旦您重新配置了一些可能从安全角度重要的东西，您需要正确地重新配置一切。这将防止您忘记一些在生产中可能成为大问题的东西，并迫使您至少有一个稳定的配置作为起点。有一个关闭检查的开关，但在任何情况下都不建议使用。
- en: The main thing to pay attention to is the binding interface – the default installation
    binds everything to `localhost` or a local loopback interface, which is completely
    fine for production. Once your Elasticsearch is capable of forming a cluster and
    it can be triggered by simply reconfiguring the network address for HTTP and transport
    communication, you have to pay attention to the checks and reconfigure the whole
    system in order to make it work. Please consult the documentation available on
    https://www.elastic.co/ for more information, starting with [https://www.elastic.co/guide/index.html](https://www.elastic.co/guide/index.html).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的主要事项是绑定接口——默认安装将所有内容绑定到`localhost`或本地环回接口，这对于生产完全没问题。一旦您的Elasticsearch能够形成集群，并且可以通过简单地重新配置HTTP和传输通信的网络地址来触发，您必须注意检查并重新配置整个系统以使其正常工作。请参阅https://www.elastic.co/上提供的文档以获取更多信息，从[https://www.elastic.co/guide/index.html](https://www.elastic.co/guide/index.html)开始。
- en: For example, configuring clusters in the Elastic stack and all that it entails
    is way out of the scope of this book – we are going to stay within the realm of
    a *single-node cluster* in our configuration. This solution was specifically created
    for situations that can work with a single node or, more precisely, a single machine
    instance that covers all the functionality of a stack. In a normal deployment,
    you will run Elastic stack in a cluster, but implementation details will be something
    determined by your configuration and its needs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Elastic stack中配置集群以及所有相关内容远远超出了本书的范围——我们将在我们的配置中保持在*单节点集群*的范围内。这个解决方案专门针对可以使用单个节点或更准确地说，覆盖堆栈所有功能的单个机器实例的情况而创建的。在正常部署中，您将在集群中运行Elastic
    stack，但实施细节将由您的配置和其需求决定。
- en: We need to warn you of two crucial points – firewall and SELinux settings are
    up to you. All the services use standard TCP to communicate. Don't forget that
    for the services to run, the network has to be configured correctly.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要警告您两个关键点——防火墙和SELinux设置由您决定。所有服务使用标准的TCP进行通信。不要忘记，为了使服务运行，网络必须正确配置。
- en: 'Now that we''ve gotten that out of the way, let''s answer one simple question:
    what do we need to do to make the Elastic stack work with more than one server?
    Let''s discuss this scenario, bit by bit.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经解决了这个问题，让我们回答一个简单的问题：要使Elastic stack与多个服务器一起工作，我们需要做些什么？让我们逐步讨论这种情况。
- en: Elasticsearch
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Elasticsearch
- en: 'Go to the configuration file (`/etc/elasticsearch/elasticsearch.yml`) and add
    a line in the discovery section:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 转到配置文件（`/etc/elasticsearch/elasticsearch.yml`）并在发现部分中添加一行：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using this section is not mandatory, but it helps when you must go back to the
    configuration later.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此部分不是强制性的，但在以后必须返回到配置时会有所帮助。
- en: This option will tell Elasticsearch that you will have only one node in the
    cluster, and it will make Elasticsearch ignore all the checks associated with
    the cluster and its network. This setting will also make this node the master
    node automatically since Elasticsearch depends on having master nodes that control
    everything in the cluster.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项将告诉Elasticsearch，您的集群中只有一个节点，并且它将使Elasticsearch忽略与集群及其网络相关的所有检查。此设置还将使此节点自动成为主节点，因为Elasticsearch依赖于具有控制集群中所有内容的主节点。
- en: Change the setting under `network.host:` so that it points to the IP address
    of the interface Elasticsearch is going to be available on. By default, it points
    to localhost and is not visible from the network.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`network.host:`下的设置，使其指向Elasticsearch将要在其上可用的接口的IP地址。默认情况下，它指向localhost，并且从网络上不可见。
- en: 'Restart the Elasticsearch service and make sure it is running and not generating
    errors:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动Elasticsearch服务，并确保它正在运行且没有生成错误：
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once you have it working, check whether the service is behaving normally from
    the local machine. The easiest way is to do this is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它正常工作，检查服务是否从本地机器正常运行。最简单的方法是这样做：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The response should be `.json` formatted text containing information about the
    server.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 响应应该是一个以`.json`格式的文本，包含有关服务器的信息。
- en: Important note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The Elastic stack has three (or four) parts or *services*. In all our examples,
    three of them (Logstash, Elasticsearch, and Kibana) were running on the same server,
    so no additional configuration was necessary to accommodate network communication.
    In a normal configuration, these services would probably run on independent servers
    and in multiple instances, depending on the workload and configuration of the
    service we are trying to monitor.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Elastic stack有三（或四）部分或*服务*。在我们所有的示例中，其中三个（Logstash、Elasticsearch和Kibana）都在同一台服务器上运行，因此不需要额外的配置来适应网络通信。在正常配置中，这些服务可能会在独立的服务器上运行，并且根据我们尝试监视的服务的工作负载和配置，可能会运行多个实例。
- en: Logstash
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Logstash
- en: 'The default installation for Logstash is a file named `logstash-sample.conf`
    in the `/etc/logstash` folder. This contains a simple Logstash pipeline to be
    used when we are using Logstash as the primary destination for beats. We will
    come to this later, but for the time being, copy this file to `/etc/logstash/conf.d/logstash.conf`
    and change the address of the Elasticsearch server in the file you just copied.
    It should look something like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Logstash的默认安装文件名为`logstash-sample.conf`，位于`/etc/logstash`文件夹中。这包含了一个简单的Logstash管道，用于在Logstash作为beats的主要目的地时使用。稍后我们会讨论这一点，但目前，将此文件复制到`/etc/logstash/conf.d/logstash.conf`，并在刚刚复制的文件中更改Elasticsearch服务器的地址。它应该看起来像这样：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Change `localhost` to the correct IP address of your server. This will make
    Logstash listen on port `5044` and forward the data to Elasticsearch. Restart
    the service and verify that it runs:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将`localhost`更改为服务器的正确IP地址。这将使Logstash侦听端口`5044`并将数据转发到Elasticsearch。重新启动服务并验证其运行：
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, let's learn how to configure Kibana.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何配置Kibana。
- en: Kibana
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kibana
- en: 'Kibana also has some settings that need to be changed, but when doing so, there
    are a couple of things to remember about this service:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Kibana也有一些需要更改的设置，但在这样做时，有几件事情需要记住：
- en: By itself, Kibana is a service that serves visualizations and data over the
    HTTP protocol (or HTTPS, depending on the configuration).
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单独来说，Kibana是一个通过HTTP协议（或根据配置的情况是HTTPS）提供可视化和数据的服务。
- en: 'At the same time, Kibana uses Elasticsearch as its backend in order to get
    and work with data. This means that there are two IP addresses that we must care
    about:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时，Kibana使用Elasticsearch作为其后端，以便获取和处理数据。这意味着我们必须关心两个IP地址：
- en: a) The first one is the address that will be used to show Kibana pages. By default,
    this is localhost on port `5601`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: a) 第一个是用于显示Kibana页面的地址。默认情况下，这是localhost的端口`5601`。
- en: b) The other IP address is the Elasticsearh service that will deal with the
    queries. The default for this is also localhost, but it needs to be changed to
    the IP address of the Elasticsearch server.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: b) 另一个IP地址是将处理查询的Elasticsearh服务。这个的默认值也是localhost，但它需要更改为Elasticsearch服务器的IP地址。
- en: 'The file that contains configuration details is `/etc/kibana/kibana.yml` and
    you need to at least make the following changes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 包含配置详细信息的文件是`/etc/kibana/kibana.yml`，您至少需要进行以下更改：
- en: '`server.host`: This needs to point to the IP address where Kibana is going
    to have its pages.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`server.host`：这需要指向Kibana将拥有其页面的IP地址。'
- en: '`elasticsearch.hosts`: This needs to point to the host (or a cluster, or multiple
    hosts) that are going to perform queries.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elasticsearch.hosts`：这需要指向将执行查询的主机（或集群，或多个主机）。'
- en: Restart the service, and that's it. Now, log into Kibana and test whether everything
    works.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动服务，就可以了。现在，登录Kibana并测试一切是否正常。
- en: 'To get you even more familiarized with Kibana, we will try and establish some
    basic system monitoring and show how we can monitor multiple hosts. We are going
    to configure two *beats*: Metricbeat and Filebeat.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您更加熟悉Kibana，我们将尝试建立一些基本的系统监控，并展示如何监控多个主机。我们将配置两个*beats*：Metricbeat和Filebeat。
- en: 'We already configured Metricbeat, but it was for localhost, so let''s fix that
    first. In the `/etc/metricbeat/metricbeat.yml` file, reconfigure the output in
    order to send data to the `elasticsearch` address. You only need to change the
    host IP address since everything else stays the same:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了Metricbeat，但是它是为本地主机配置的，所以让我们先解决这个问题。在`/etc/metricbeat/metricbeat.yml`文件中，重新配置输出以将数据发送到`elasticsearch`地址。您只需要更改主机IP地址，因为其他所有内容保持不变：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Make sure that you change `Your-host-IP-address` to the IP address you're using.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`Your-host-IP-address`更改为您正在使用的IP地址。
- en: 'Configuring filebeat is mostly the same; we need to use `/etc/filebeat/filebeat.yml`
    to configure it. Since all the beats use the same concepts, both filebeat and
    metricbeat (as well as other beats) use modules to provide functionality. In both,
    the core module is named `system`, so enable it using the following command in
    filebeat:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 配置filebeat基本上是相同的；我们需要使用`/etc/filebeat/filebeat.yml`进行配置。由于所有的beats都使用相同的概念，filebeat和metricbeat（以及其他beats）都使用模块来提供功能。在两者中，核心模块都被命名为`system`，因此在filebeat中使用以下命令启用它：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Use the following command for metricbeat:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令进行metricbeat：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We mentioned this previously, in the first example, but you can test your configuration
    by running the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，在第一个示例中，但是您可以通过运行以下命令来测试您的配置：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can also use the following command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下命令：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Both beats should say that the config is `ok`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 两个beats都应该显示配置为`ok`。
- en: Also, you can check the output settings, which will show you what the output
    settings actually are and how they work. If you are configuring the system using
    only this book, you should have a warning come up to remind you there is no TLS
    protection for the connection, but otherwise, the outputs should work on the IP
    address that you set in the configuration file.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以检查输出设置，这将显示输出设置实际上是什么以及它们是如何工作的。如果您只使用本书来配置系统，您应该会收到一个警告，提醒您连接没有TLS保护，但除此之外，输出应该在配置文件中设置的IP地址上工作。
- en: 'To test the outputs, use the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试输出，请使用以下命令：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can also use the following command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用以下命令：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Repeat all this for every system that you intend to monitor. In our example,
    we have two systems: one that is running KVM and another that is running Kibana.
    We also have Kibana set up on the other system to test syslog and the way it notifies
    us of the problems it notices.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您打算监视的每个系统都要重复所有这些步骤。在我们的示例中，我们有两个系统：一个正在运行KVM，另一个正在运行Kibana。我们还在另一个系统上设置了Kibana，以测试syslog以及它通知我们注意到的问题的方式。
- en: 'We need to configure filebeat and metricbeat to send data to Kibana. We''ll
    edit the `filebeat.yml` and `metricbeat.yml` files for that purpose, by changing
    the following portion of both files:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要配置filebeat和metricbeat以将数据发送到Kibana。我们将编辑`filebeat.yml`和`metricbeat.yml`文件，通过更改两个文件的以下部分来实现这一目的：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Before running beats, on a fresh installation, you need to upload dashboards
    to Kibana. You only need to do this once for each Kibana installation, and you
    only need to do this from one of the systems you are monitoring – templates will
    work, regardless of the system they were uploaded from; they will just deal with
    data that is coming into Elasticsearch.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行beats之前，在新安装中，您需要将仪表板上传到Kibana。您只需要为每个Kibana安装执行一次此操作，并且您只需要从要监视的系统中的一个系统执行此操作
    - 模板将起作用，无论它们是从哪个系统上传的；它们只会处理进入Elasticsearch的数据。
- en: 'To do this, use the following command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请使用以下命令：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You also need to use the following command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要使用以下命令：
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will take a couple of seconds or even a minute, depending on your server
    and client. Once it says that it created the dashboards, it will display all the
    dashboards and settings it created.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要几秒钟甚至一分钟，这取决于您的服务器和客户端。一旦它说它创建了仪表板，它将显示所有创建的仪表板和设置。
- en: 'Now, you are almost ready to go through all the data that Kibana will display:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您几乎可以开始查看Kibana将显示的所有数据了：
- en: '![](img/B14834_14_08.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14834_14_08.jpg)'
- en: Figure 14.8 – Excerpt from the Kibana dashboard
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8 - 来自Kibana仪表板的摘录
- en: 'Before we start, there''s something else you need to know about time and timestamps.
    The date/time picker in the top-right corner will let you choose either your own
    timespan or one of the predefined intervals:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，还有一件事情您需要了解有关时间和时间戳。右上角的日期/时间选择器将让您选择自己的时间跨度或预定义的间隔之一：
- en: '![Figure 14.9 – Date/time picker'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.9-日期/时间选择器'
- en: '](img/B14834_14_09.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_09.jpg)'
- en: Figure 14.9 – Date/time picker
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9-日期/时间选择器
- en: Important note
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Always remember that the time that's shown is *local* to the browser's/machine's
    time zone you are accessing Kibana from.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 始终记住显示的时间是从您访问Kibana的浏览器/机器的时区*本地*时间。
- en: All the timestamps in the logs are *local* to the machine that is sending the
    logs. Kibana will try and match time zones and translate the resulting timestamps,
    but if there is a mismatch in the actual time settings on the machines you are
    monitoring, there is going to be a problem trying to establish a timeline of events.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 日志中的所有时间戳都是发送日志的机器的*本地*时间。Kibana将尝试匹配时区并转换生成的时间戳，但如果您监视的机器上的实际时间设置不匹配，那么在尝试建立事件时间线时就会出现问题。
- en: 'Let''s presume you got filebeat and metricbeat running. What can you do with
    these? As it turns out, a lot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经运行了filebeat和metricbeat。您可以用这些做什么？事实证明，很多：
- en: The first thing is discovering what is in your data. Press the **Discover**
    button in Kibana (it looks like a small compass). Some data should show on the
    right if everything is okay.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先要做的是发现您的数据中有什么。在Kibana中按下**发现**按钮（看起来像一个小指南针）。如果一切正常，右侧应该显示一些数据。
- en: To the right of the icon you just clicked on, a vertical space will fill up
    with all the attributes that Kibana got from the data. If you do not see anything
    or something is missing, remember that the time span you select narrows down the
    data that will get shown in this view. Try readjusting the interval to **Last
    24 hours** or **Last 30 days**.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您刚刚单击的图标右侧，将填充一个垂直空间，其中包含Kibana从数据中获取的所有属性。如果您没有看到任何内容或缺少某些内容，请记住您选择的时间跨度会缩小在此视图中显示的数据。尝试重新调整间隔到**最近24小时**或**最近30天**。
- en: Once the list of attributes shows up, you can quickly establish how many times
    each shows up in the data you just selected – just click on any attribute and
    select **Visualize**. Also note that once you click on the attribute, Kibana shows
    you the top five distinct values in the last 500 records. This is a very useful
    tool if you need to know, for example, which hosts are showing data, or how many
    different OS versions there are.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦属性列表显示出来，您可以快速确定每个属性在您刚刚选择的数据中出现了多少次-只需单击任何属性并选择**可视化**。还要注意，一旦单击属性，Kibana会显示最近500条记录中前五个不同的值。如果您需要知道例如哪些主机显示数据，或者有多少不同的操作系统版本，这是一个非常有用的工具。
- en: The visualization of particular attributes is just a start – notice how, once
    you hover over an attribute name, a button called **Add** appears? Try clicking
    it. A table will start forming on the right, filled with just the attributes you
    selected, sorted by timestamp. By default, these values are not auto-refreshed,
    so the timestamps will be fixed. You can choose as many attributes as you want
    and save this list or open it later.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 特定属性的可视化只是一个开始-注意一旦悬停在属性名称上，一个名为**添加**的按钮会出现？尝试单击它。右侧将开始形成一个表，其中只包含您选择的属性，按时间戳排序。默认情况下，这些值不会自动刷新，因此时间戳将被固定。您可以选择任意数量的属性，并保存此列表或稍后打开它。
- en: The next thing we need to look at is individual visualizations. We are not going
    to go into too many details, but you can create your own visualizations out of
    the datasets using predefined visualization types. At the same time, you are not
    limited to using only predefined things – using JSON and scripting is also possible,
    for even more customization.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要查看的下一件事是单独的可视化。我们不会详细介绍，但您可以使用预定义的可视化类型从数据集中创建自己的可视化。同时，您不仅限于使用预定义的内容-还可以使用JSON和脚本进行更多的自定义。
- en: The next thing we need to learn about is dashboards.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要了解的下一件事是仪表板。
- en: Depending on a particular dataset, or to be more precise, on the particular
    set of machines you are monitoring, some of them will have attributes that cover
    things only a particular machine does or has. One example is virtual machines
    on AWS – they will have some information that is useful only in the context of
    AWS. This is not important in our configuration, but you need to understand that
    there may be some attributes in the data that are unique for a particular set
    of machines. For starters, choose one of the system metrics; either **System Navigation
    ECS** for metricbeat or **Dashboards ECS** for filebeat.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 根据特定数据集，或者更准确地说，根据您正在监视的特定一组机器，其中一些将具有仅涵盖特定机器执行或具有的属性。一个例子是AWS上的虚拟机-它们将具有一些仅在AWS上下文中有用的信息。这在我们的配置中并不重要，但您需要了解数据中可能存在一些特定机器集的唯一属性。首先，选择一个系统指标；要么选择**System
    Navigation ECS**用于metricbeat，要么选择**Dashboards ECS**用于filebeat。
- en: These dashboards show a lot of information about your systems in a lot of ways.
    Try clicking around and see what you can deduce.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这些仪表板以多种方式显示有关系统的大量信息。尝试点击并查看您能推断出什么。
- en: 'The metricbeat dashboard is more oriented toward running systems and keeping
    an eye on memory and CPU allocation. You can click and filter a lot of information,
    and have it presented in different ways. The following is a screenshot of metricbeat
    so that you can get a rough idea of what it looks like:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: metricbeat仪表板更侧重于运行系统并关注内存和CPU分配情况。您可以单击并过滤大量信息，并以不同的方式呈现。以下是metricbeat的屏幕截图，以便您对其外观有一个大致的了解：
- en: '![Figure 14.10 – metricbeat dashboard'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.10-metricbeat仪表板'
- en: '](img/B14834_14_10.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_10.jpg)'
- en: Figure 14.10 – metricbeat dashboard
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10-metricbeat仪表板
- en: 'The filebeat dashboard is more oriented toward analyzing what happened and
    establishing trends. Let''s check a couple of excerpts from the filebeat dashboard,
    starting with the syslog entries part:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: filebeat仪表板更多地面向分析发生了什么并建立趋势。让我们从filebeat仪表板中的一些摘录开始检查，首先是syslog条目部分：
- en: '![Figure 14.11 – filebeat syslog entries part'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.11 - filebeat syslog条目部分'
- en: '](img/B14834_14_11.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_11.jpg)'
- en: Figure 14.11 – filebeat syslog entries part
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11 - filebeat syslog条目部分
- en: 'At first glance, you can notice a couple of things. We are showing data for
    two systems, and the data is partial since it covers a part of the interval that
    we set. Also, we can see that some of the processes are running and generating
    logs more frequently than others. Even if we do not know anything about the particular
    system, we can now see there are some processes that show up in logs, and they
    probably shouldn''t:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，您可以注意到一些事情。我们正在显示两个系统的数据，而且数据是部分的，因为它覆盖了我们设置的一部分时间间隔。此外，我们可以看到一些进程比其他进程更频繁地运行并生成日志。即使我们对特定系统一无所知，我们现在也可以看到一些进程出现在日志中，而它们可能不应该出现：
- en: '![Figure 14.12 – filebeat interactive doughnut chart'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.12 - filebeat交互式圆环图'
- en: '](img/B14834_14_12.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_12.jpg)'
- en: Figure 14.12 – filebeat interactive doughnut chart
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12 - filebeat交互式圆环图
- en: Let's take a look at `setroubleshoot`. Click on the process name. In the window
    that opens, click on the magnifying glass. This isolates only this process and
    shows only its logs at the bottom of the screen.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`setroubleshoot`。点击进程名称。在打开的窗口中，点击放大镜。这将隔离只有这个进程，并在屏幕底部显示它的日志。
- en: We can quickly see on which host – including how often and why – `setroubleshoot`
    is writing logs to. This is a quick way to spot potential problems. In this particular
    case, some action should obviously be taken on this system to reconfigure SELinux
    since it generates exceptions and stops some applications from accessing files.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速看到`setroubleshoot`在哪个主机上 - 包括频率和原因 - 写入日志。这是发现潜在问题的快速方法。在这种特殊情况下，显然应该在这个系统上采取一些行动，重新配置SELinux，因为它生成异常并阻止一些应用程序访问文件。
- en: Let's move along the vertical navigation bar and point out some other interesting
    functionalities.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们沿着垂直导航栏继续，并指出一些其他有趣的功能。
- en: Going from top to bottom, the next big functionality is **Canvas** – it enables
    us to create live presentations using data from the dataset we are collecting.
    The interface is similar to what can be expected from other presentation programs,
    but the accent is on using data directly in slides and generating slides in almost
    real time.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从上到下，下一个重要功能是**Canvas** - 它使我们能够使用我们正在收集的数据创建实时演示文稿。界面类似于其他演示程序所期望的，但重点是直接在幻灯片中使用数据并几乎实时生成幻灯片。
- en: The next is **Maps**. This is a new addition to version 7.0 and allows us to
    create a geographic presentation of data.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是**地图**。这是7.0版本的一个新功能，它允许我们创建数据的地理演示。
- en: '**Machine learning** is next – it enables you to manipulate data and use it
    to "train" filters and create pipelines out of them.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**机器学习**是下一个功能 - 它使您能够操纵数据并使用它来“训练”过滤器，并从中创建管道。'
- en: '**Infrastructure** is also interesting – when we mentioned dashboards, we were
    talking about flexibility and customization. Infrastructure is a module that enables
    us to do real-time monitoring with minimal effort and observe important metrics.
    You can see important data either as a table, a balloon-like interface, or as
    a graph. Data can be averaged or presented in other ways, and all that is done
    through a highly intuitive interface.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础设施**也很有趣 - 当我们提到仪表板时，我们谈论的是灵活性和定制。基础设施是一个模块，它使我们能够以最小的努力进行实时监控并观察重要的指标。您可以将重要数据显示为表格、气球状界面或图表。数据可以被平均或以其他方式呈现，所有这些都是通过一个非常直观的界面完成的。'
- en: Heartbeat is another of these highly specialized boards – as its name suggests,
    it is the easiest way to track and report on uptime data, and to quickly notice
    if something has gone offline. Inventory hosts require the Heartbeat service to
    be installed on each system we intend to monitor.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Heartbeat是另一个高度专业化的仪表板 - 正如其名称所示，这是跟踪和报告正常运行时间数据的最简单方法，并迅速注意到是否有什么东西已经离线。库存主机需要安装Heartbeat服务，以便监视我们打算监视的每个系统。
- en: '**SIEM** deserves a more thorough explanation: if we think about dashboards
    as being multipurpose, SIEM is the exact opposite; it is created to be able to
    track all the events on all the systems that can be categorized as security-related.
    This module will parse the data when searching for IPs, network events, sources,
    destinations, network flows, and all other data, and create simple to understand
    reports regarding what is happening on the machines you are monitoring. It even
    offers anomaly detection, a feature that enables the Elastic stack to serve as
    a solution for advanced security purposes. This feature is a paid one and requires
    the highest-paid tier to function.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**SIEM**值得更深入的解释：如果我们把仪表板看作是多功能的，那么SIEM恰恰相反；它被创建为能够跟踪所有可以归类为安全相关的系统上的所有事件。当搜索IP、网络事件、源、目的地、网络流和所有其他数据时，这个模块将解析数据，并创建简单易懂的报告，报告了您正在监视的机器上发生了什么。它甚至提供异常检测，这是一项付费功能，需要最高付费等级才能使用。'
- en: '**Stack monitor** is another notable board as it enables you to actually see
    what is happening in all the different parts of the Elastic stack. It will show
    the status of all the services, their resource allocation, and license status.
    The **Logs** feature is especially useful since it tracks how many logs of what
    type the stack is generating, and it can quickly point to problems if there are
    any.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆栈监视器**是另一个值得注意的仪表板，因为它使您实际上可以看到Elastic堆栈的所有不同部分发生了什么。它将显示所有服务的状态、它们的资源分配和许可证状态。**日志**功能特别有用，因为它跟踪堆栈生成了多少种类型的日志，并且如果有任何问题，它可以快速指出问题。'
- en: This module also generates statistics for services, enabling us to understand
    how the system can be optimized.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块还为服务生成统计信息，使我们能够了解系统如何进行优化。
- en: '**Management**, the last icon at the bottom, was already mentioned – it enables
    the management of the cluster and its parts. This is the place where we can see
    whether there are any indices we are expecting, whether the data flowing in, whether
    can we optimize something, and so on. This is also the place we can manage licenses
    and create snapshots of system configuration.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**管理**，底部的最后一个图标已经提到过了 - 它使集群及其部分的管理成为可能。这是我们可以看到是否有我们期望的任何索引，数据是否流入，我们是否可以优化某些内容等的地方。这也是我们可以管理许可证并创建系统配置快照的地方。'
- en: ELK and KVM
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ELK和KVM
- en: 'Last but not least, let''s create a system gauge that is going to show us a
    parameter from a KVM hypervisor, and then visualize it in a couple of ways. The
    prerequisites for this are a running KVM hypervisor, metricbeat with the KVM module
    installed, and an Elastic stack configuration that supports receiving data from
    metricbeat. Let''s go through ELK''s configuration for this specific use case:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '最后但同样重要的是，让我们创建一个系统仪表，它将向我们显示来自KVM hypervisor的参数，然后以几种方式进行可视化。这需要运行的KVM hypervisor，安装了KVM模块的metricbeat和支持从metricbeat接收数据的Elastic
    stack配置。让我们详细了解ELK针对这个特定用例的配置:'
- en: First, go to the hypervisor and open a `virsh` shell. List all the available
    domains, choose a domain, and use the `dommemstat –-domain <domain_name>` command.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，转到hypervisor并打开`virsh` shell。列出所有可用的域，选择一个域，并使用`dommemstat –-domain <domain_name>`命令。
- en: 'The result should be something like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '结果应该是这样的:'
- en: '![Figure 14.13 – dommemtest for a domain'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.13 – 用于域的dommemtest'
- en: '](img/B14834_14_13.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_13.jpg)'
- en: Figure 14.13 – dommemtest for a domain
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13 – 用于域的dommemtest
- en: Open Kibana and log in, go to the `metric*` as the index we are working with.
    The left column should populate with attributes that are in the dataset that metricbeat
    sends to this Kibana instance. Now, look at the attributes and select a couple
    of them:![Figure 14.14 – Selecting attributes in Kibana
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Kibana并登录，转到`metric*`作为我们正在使用的索引。左侧列应该填充有metricbeat发送到此Kibana实例的数据集中的属性。现在，查看属性并选择其中的一些:![图14.14
    – 在Kibana中选择属性
- en: '](img/B14834_14_14.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_14.jpg)'
- en: Figure 14.14 – Selecting attributes in Kibana
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.14 – 在Kibana中选择属性
- en: 'You can select fields using a button that will show up as soon as you hover
    the mouse cursor over any field. The same goes for deselecting them:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以使用一个按钮选择字段，只要将鼠标光标悬停在任何字段上，该按钮就会显示出来。取消选择它们也是一样的:'
- en: '![Figure 14.15 – Adding attributes in Kibana'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.15 – 在Kibana中添加属性'
- en: '](img/B14834_14_15.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_15.jpg)'
- en: Figure 14.15 – Adding attributes in Kibana
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.15 – 在Kibana中添加属性
- en: For now, let's stick with the ones we selected. To the right of the column,
    a table is formed that contains only the fields you selected, enabling you to
    check the data that the system is receiving. You may need to scroll down to see
    the actual information since this table will display all the data that was received
    that has at least one item that has a value. Since one of the fields is always
    a timestamp, there will be a lot of rows that will not contain any useful data
    for our analysis:![Figure 14.16 – Checking the selected fields
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们坚持我们选择的那些。在列的右侧，形成了一个表，其中只包含您选择的字段，使您能够检查系统正在接收的数据。您可能需要向下滚动以查看实际信息，因为此表将显示接收到的所有数据，其中至少有一个具有值的项目。由于其中一个字段始终是时间戳，因此将有许多行不包含任何对我们的分析有用的数据:![图14.16
    – 检查所选字段
- en: '](img/B14834_14_16.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_16.jpg)'
- en: Figure 14.16 – Checking the selected fields
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.16 – 检查所选字段
- en: What we can see here is that we get the same data that was the result of running
    the command line on the monitored server.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以看到的是，我们得到了在监视服务器上运行命令行的结果相同的数据。
- en: What we need is a way to use these results as data to show our graphs. Click
    on the `dommemstat`. Save the search.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一种方法来使用这些结果作为数据来显示我们的图表。点击`dommemstat`。保存搜索。
- en: Now, let's build a gauge that will show us the real-time data and a quick visualization
    of one of the values. Go to `area` graph. Then, on the next screen, find and select
    our source for the data:![Figure 14.18 – Selecting a visualization source
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个仪表，它将向我们显示实时数据和一个值的快速可视化。转到`area`图。然后，在下一个屏幕上，找到并选择我们的数据源:![图14.18
    – 选择可视化源
- en: '](img/B14834_14_18.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_18.jpg)'
- en: Figure 14.18 – Selecting a visualization source
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.18 – 选择可视化源
- en: 'This is going to create a window that has all the settings on the left and
    the end result on the right. At the moment, what we can see makes no sense, so
    let''s configure what we need in order to show our data. There are a couple of
    ways to accomplish what we want: we are going to use a histogram and filters to
    quickly display how our value for unused memory changed over time.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个窗口，左侧显示所有设置，右侧显示最终结果。目前，我们看到的东西毫无意义，因此让我们配置我们需要的内容以显示我们的数据。有几种方法可以实现我们想要的内容：我们将使用直方图和过滤器快速显示我们的未使用内存随时间的变化。
- en: We are going to configure the *y* axis to show average data for `kvm.dommemstat.stat.value`,
    which is the attribute that holds our data. Select `kvm.dommemstat.stat.value`
    as the field we are aggregating. You can create a custom label if you want to:![Figure
    18.19 – Selecting metric properties
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将配置*y*轴以显示`kvm.dommemstat.stat.value`的平均数据，这是保存我们数据的属性。选择`kvm.dommemstat.stat.value`作为我们正在聚合的字段。如果需要，您可以创建自定义标签:![图18.19
    – 选择度量属性
- en: '](img/B14834_14_19.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_19.jpg)'
- en: Figure 18.19 – Selecting metric properties
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.19 – 选择度量属性
- en: 'This is still not right; we need to add a timestamp to see how our data changed
    over time. We need to add a **Date Histogram** type to the *x* axis and use it:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '这还不对，我们需要添加一个时间戳以查看我们的数据随时间的变化。我们需要在*x*轴上添加**日期直方图**类型并使用它:'
- en: '![Figure 14.20 – Choosing an aggregation type'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.20 – 选择聚合类型'
- en: '](img/B14834_14_20.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_20.jpg)'
- en: Figure 14.20 – Choosing an aggregation type
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.20 - 选择聚合类型
- en: Before we finish this visualization, we need to add a filter. The problem with
    data that is received from the KVM metricbeat module is that it uses one attribute
    to hold different data – if we want to know what the number in the file we are
    displaying actually means, we need to read its name from `kvm.dommemstat.stat.name`.
    To accomplish this, just create a filter called `kvm.dommemstat.stat.name:"unused"`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在完成此可视化之前，我们需要添加一个过滤器。从KVM metricbeat模块接收的数据的问题是，它使用一个属性来保存不同的数据 - 如果我们想知道我们正在显示的文件中的数字实际上意味着什么，我们需要从`kvm.dommemstat.stat.name`中读取其名称。为了实现这一点，只需创建一个名为`kvm.dommemstat.stat.name:"unused"`的过滤器。
- en: 'After we refresh the visualization, our data should be correctly visualized
    on the right:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刷新可视化后，我们的数据应该正确显示在右侧：
- en: '![](img/B14834_14_21.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14834_14_21.jpg)'
- en: Figure 14.21 – Correct visualization
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.21 - 正确的可视化
- en: We need to save this visualization using the `Save` button, give it a name that
    we will be able to find later, and repeat this process but instead of filtering
    for `unused`, filter for `usable`. Leave all the settings identical to the first
    visualization.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用“保存”按钮保存此可视化，为其命名，以便以后能够找到它，并重复此过程，但是不是过滤“未使用”，而是过滤“可用”。将所有设置保持与第一个可视化相同。
- en: Let's build a dashboard. Open the **Dashboard** tab and click on **Add new dashboard**
    on the first screen. Now, add our two visualizations to this dashboard. You just
    need to find the right visualization and click on it; it will show up on the dashboard.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个仪表板。打开**仪表板**选项卡，然后在第一个屏幕上单击**添加新仪表板**。现在，将我们的两个可视化添加到此仪表板。您只需要找到正确的可视化并单击它；它将显示在仪表板上。
- en: 'As a result, we have a couple of simple dashboards running:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有几个简单的仪表板正在运行：
- en: '![Figure 14.22 – Finished dashboard showing usable memory'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.22 - 显示可用内存的完成仪表板'
- en: '](img/B14834_14_22.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_22.jpg)'
- en: Figure 14.22 – Finished dashboard showing usable memory
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.22 - 显示可用内存的完成仪表板
- en: 'The second dashboard – in the UI, which is actually right next to the first
    one – is the unused memory dashboard:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个仪表板 - 在UI中，实际上就在第一个仪表板旁边 - 是未使用的内存仪表板：
- en: '![Figure 14.23 – Finished dashboard showing unused memory'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.23 - 显示未使用内存的完成仪表板'
- en: '](img/B14834_14_23.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_23.jpg)'
- en: Figure 14.23 – Finished dashboard showing unused memory
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.23 - 显示未使用内存的完成仪表板
- en: 'Save this dashboard so that you can use it later. All the elements of the dashboard
    can be customized, and the dashboard can consist of any number of visualizations.
    Kibana lets you customize almost everything you see and combine a lot of data
    on one screen for easy monitoring. There is only one thing we need to change to
    make this a good monitoring dashboard, and that is to make it autorefresh. Click
    on the calendar icon on the right-hand side of the screen and select the auto
    refresh interval. We decided on `5 seconds`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存此仪表板，以便以后使用。仪表板的所有元素都可以自定义，并且仪表板可以包含任意数量的可视化。Kibana让您几乎可以自定义您看到的一切，并将大量数据组合在一个屏幕上进行轻松监视。我们只需要更改一件事情，使其成为一个良好的监控仪表板，那就是使其自动刷新。单击屏幕右侧的日历图标，并选择自动刷新间隔。我们决定使用`5秒`：
- en: '![Figure 14.24 – Selecting time-related parameters'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.24 - 选择与时间相关的参数'
- en: '](img/B14834_14_24.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_14_24.jpg)'
- en: Figure 14.24 – Selecting time-related parameters
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.24 - 选择与时间相关的参数
- en: Now that we've done this, we can reflect on the fact that building this dashboard
    was really straightforward and easy. This only took us a couple of minutes, and
    it's easy to read. Imagine going through hundreds of megabytes of log files in
    text mode compared to this. There's really no contest, as we were able to use
    our previously deployed ELK stack to monitor information about KVM, which was
    the whole point of this chapter.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了这个，我们可以反思一下，构建这个仪表板真的非常简单和容易。这只花了我们几分钟，而且很容易阅读。想象一下，以文本模式查看数百兆字节的日志文件与这种方式相比。真的没有可比性，因为我们能够使用先前部署的ELK堆栈来监视有关KVM的信息，这正是本章的重点。
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: What Kibana enables you to do is create custom dashboards that can show you
    data for different machines side by side, so KVM is just one of the many options
    we have. Depending on your needs, you can display, for example, disk usage for
    a KVM hypervisor and all the hosts running on it, or some other metric. The Elastic
    stack is a flexible tool, but as with all things, it requires time to master.
    This chapter only covered the bare basics of Elastic configuration, so we strongly
    recommend further reading on this topic – alongside KVM, ELK can be used to monitor
    almost everything that produces any kind of data.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Kibana让您可以创建自定义仪表板，可以并排显示不同机器的数据，因此KVM只是我们的许多选项之一。根据您的需求，您可以显示，例如，KVM超级管理程序的磁盘使用情况以及运行在其上的所有主机，或者其他一些指标。弹性堆栈是一个灵活的工具，但与所有事物一样，它需要时间来掌握。本章仅涵盖了弹性配置的基础知识，因此我们强烈建议在此主题上进行进一步阅读
    - 除了KVM之外，ELK可以用于监视几乎所有产生任何类型数据的东西。
- en: The next chapter is all about performance tuning and optimization for KVM virtual
    machines, a subject that we didn't really touch upon. There's quite a lot to be
    discussed – virtual machine compute sizes, optimizing performance, disks, storage
    access and multipathing, optimizing kernels, and virtual machine settings, just
    to name a few. All these subjects will be more important the larger our environment
    becomes.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将全面讨论KVM虚拟机的性能调优和优化，这是我们并没有真正涉及的一个主题。有很多内容需要讨论 - 虚拟机计算大小、性能优化、磁盘、存储访问和多路径、优化内核和虚拟机设置等等。所有这些主题在我们的环境变得越来越大时将变得更加重要。
- en: Questions
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What do we use metricbeat for?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用metricbeat做什么？
- en: Why do we use Kibana?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么使用Kibana？
- en: What is the basic prerequisite before installing the ELK stack?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装ELK堆栈之前的基本先决条件是什么？
- en: How do we add data to Kibana?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何向Kibana添加数据？
- en: Further reading
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Please refer to the following links for more information regarding what was
    covered in this chapter:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章涵盖的内容的更多信息，请参考以下链接：
- en: 'ELK stack: [https://www.elastic.co/what-is/elk-stack](https://www.elastic.co/what-is/elk-stack)'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ELK stack：[https://www.elastic.co/what-is/elk-stack](https://www.elastic.co/what-is/elk-stack)
- en: 'ELK stack documentation: [https://www.elastic.co/guide/index.html](https://www.elastic.co/guide/index.html)'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ELK stack文档：[https://www.elastic.co/guide/index.html](https://www.elastic.co/guide/index.html)
- en: 'Kibana documentation: [https://www.elastic.co/guide/en/kibana/current/index.html](https://www.elastic.co/guide/en/kibana/current/index.html)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kibana文档：[https://www.elastic.co/guide/en/kibana/current/index.html](https://www.elastic.co/guide/en/kibana/current/index.html)
- en: 'Metricbeat documentation: [https://www.elastic.co/guide/en/beats/metricbeat/current/index.html](https://www.elastic.co/guide/en/beats/metricbeat/current/index.html)'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Metricbeat文档：[https://www.elastic.co/guide/en/beats/metricbeat/current/index.html](https://www.elastic.co/guide/en/beats/metricbeat/current/index.html)
