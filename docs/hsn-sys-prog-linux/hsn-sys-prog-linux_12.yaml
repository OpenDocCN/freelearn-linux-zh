- en: Signaling - Part II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号处理 - 第II部分
- en: 'As mentioned in the previous chapter, signals are a crucial mechanism for the
    Linux system developer to understand and exploit. The previous chapter covered
    several areas: an introduction, why signaling is useful to the systems developer,
    and, most importantly, how exactly the developer is to handle and thus exploit
    the signaling mechanism.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，信号是Linux系统开发人员理解和利用的关键机制。前一章涵盖了几个方面：介绍，为什么信号对系统开发人员有用，以及最重要的是，开发人员如何处理和利用信号机制。
- en: This chapter continues this exploration. Here, we will drill down into the inner
    details of process crash handling with signaling, how to recognize and avoid common
    issues when dealing with signals, working with real-time signals, sending signals,
    and finally, alternative means of performing signal handling.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续探讨这一问题。在这里，我们将深入研究使用信号处理进程崩溃的内部细节，如何识别和避免处理信号时的常见问题，处理实时信号，发送信号，以及最后，执行信号处理的替代方法。
- en: 'In this chapter, the reader will learn the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，读者将学到以下内容：
- en: Gracefully handling process crashes, and collecting valuable diagnostics at
    that point
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优雅地处理进程崩溃，并在那时收集有价值的诊断信息
- en: Handling common gotchas to do with signaling—errno races, the correct way to
    sleep (yes, you read that right!)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理与信号相关的常见陷阱——errno竞争，正确的睡眠方式（是的，你没看错！）
- en: Handling powerful real-time signals
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理强大的实时信号
- en: Sending signals to other processes, and performing IPC via signals
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向其他进程发送信号，并通过信号执行IPC
- en: Alternative signal-handling techniques
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代信号处理技术
- en: Gracefully handling process crashes
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优雅地处理进程崩溃
- en: A bug in the application that caused a crash at runtime? My God, how is this
    possible?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中导致运行时崩溃的错误？天啊，这怎么可能？
- en: Unfortunately, to the well-heeled software veteran, though, this is not a big
    surprise. Bugs exist; they can hide really well, for years, sometimes; one day,
    they come out and—bang!*—*the process crashes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于经验丰富的软件老手来说，这并不是一个大惊喜。错误存在；它们有时可以很好地隐藏多年；有一天，它们会出现，然后*砰！*进程崩溃了。
- en: 'Here, our intention is not to discuss debugging techniques or tools (let''s
    save that for another book perhaps, shall we?); instead, it''s this key point:
    if our application process does crash, can we do something? Certainly: in the
    previous chapter, we have learned in detail how we can trap signals. Why not design
    our application such that we trap the typical fatal signals—the SIGBUS, SIGFPE,
    SIGILL, and SIGSEGV—and, in their signal handler(s), perform useful tasks such
    as these:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的意图不是讨论调试技术或工具（也许我们可以把这个留到另一本书中吧？）；相反，关键是：如果我们的应用程序进程崩溃了，我们能做些什么？当然可以：在上一章中，我们已经详细学习了如何捕获信号。为什么不设计我们的应用程序，使我们捕获典型的致命信号——SIGBUS、SIGFPE、SIGILL和SIGSEGV，并在它们的信号处理程序中执行有用的任务，比如：
- en: Perform critical application cleanup—for example, free up memory regions, flush
    and close open files, and so on
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行关键应用程序清理——例如，释放内存区域，刷新和关闭打开的文件等
- en: Write relevant details to a log file (the signal that caused the crash, the
    signal's origin, reason, CPU register values, and so on)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将相关详细信息写入日志文件（导致崩溃的信号，信号的来源，原因，CPU寄存器值等）
- en: Inform the end user that, hey, too bad, we crashed
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知最终用户，嘿，太糟糕了，我们崩溃了
- en: Kindly allow us to collect crash details, and we'll do better next time, we
    promise!
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请允许我们收集崩溃详细信息，我们下次会做得更好，我们保证！
- en: This not only gives us valuable information that can help you debug the root
    cause of the crash, but also has the application die gracefully.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅为我们提供了有价值的信息，可以帮助您调试崩溃的根本原因，而且还可以使应用程序优雅地退出。
- en: Detailing information with the SA_SIGINFO
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SA_SIGINFO详细信息
- en: 'Let''s recall the very first member of the `sigaction` structure we saw in
    the previous, [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml), *Signaling
    - Part I*,* The sigaction structure* section; it''s a function pointer, and it
    specifies the signal handler:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在上一章中看到的`sigaction`结构的第一个成员，*信号处理 - 第I部分*，*sigaction结构*部分；它是一个函数指针，它指定了信号处理程序：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding highlighted code highlights the fact that as it''s in a union, the
    signal handler can be either one of the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面突出显示的代码突出显示了，由于它在一个联合中，信号处理程序可以是以下之一：
- en: '`sa_handler` : when the `SA_SIGINFO` flag is cleared'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sa_handler`：当清除`SA_SIGINFO`标志时'
- en: '`sa_sigaction` : when the `SA_SIGINFO` flag is set'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sa_sigaction`：当设置了`SA_SIGINFO`标志时'
- en: 'So far, we have used the `sa_handler` style prototype for the signal handler:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了`sa_handler`风格的信号处理程序原型：
- en: '`void (*sa_handler)(int);`'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`void (*sa_handler)(int);`'
- en: 'It receives just one parameter: the integer value of the signal that occurred.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 它只接收一个参数：发生的信号的整数值。
- en: 'If you set the **`SA_SIGINFO`** flag (while issuing the `sigaction(2)` system
    call of course), the signal handler function prototype now becomes this: `void
    (*sa_sigaction)(int, siginfo_t *, void *);`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您设置了**`SA_SIGINFO`**标志（当然，在发出`sigaction(2)`系统调用时），信号处理程序函数原型现在变成了这样：`void
    (*sa_sigaction)(int, siginfo_t *, void *);`
- en: 'The parameters are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 参数如下：
- en: The integer value of the signal that occurred
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生的信号的整数值
- en: A pointer to a structure of type `siginfo_t` (a typedef, obviously)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指向`siginfo_t`类型的结构的指针（显然是一个typedef）
- en: An internal-use-only (undocumented) pointer called the **ucontext**
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个仅供内部使用的（未记录的）指针称为**ucontext**
- en: The second parameter is where the power lies!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是关键所在！
- en: The siginfo_t structure
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: siginfo_t结构
- en: 'When you use the `SA_SIGINFO` signal flag and a trapped signal occurs, the
    kernel populates a data structure: the `siginfo_t` structure.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`SA_SIGINFO`信号标志并发生受困信号时，内核会填充一个数据结构：`siginfo_t`结构。
- en: 'The `siginfo_t` structure definition (slightly simplified; there is some #if wrapping
    around the first few members which we need not worry about here) is shown next(It''s
    in the header `/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h` on Ubuntu 
    and `/usr/include/bits/types/siginfo_t.h` on a Fedora box):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面显示了`siginfo_t`结构定义（稍微简化；在前几个成员周围有一些`#if`包装，我们在这里不需要担心）（在Ubuntu的头文件`/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h`中，Fedora的头文件为`/usr/include/bits/types/siginfo_t.h`）：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first three members are integers:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个成员是整数：
- en: '`si_signo` : signal number—the signal that was delivered to the process'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`si_signo` : 信号编号 - 传递给进程的信号'
- en: '`si_code` : signal origin; an enum; typical values are as follows:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`si_code` : 信号来源；一个枚举；典型值如下：'
- en: '`SI_QUEUE`      : Sent by `sigqueue(3)`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`SI_QUEUE` : 由`sigqueue(3)`发送'
- en: '`SI_USER`        : Sent by `kill(2)`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`SI_USER` : 由`kill(2)`发送'
- en: '`SI_KERNEL`   : Sent by kernel'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`SI_KERNEL` : 由内核发送'
- en: '`SI_SIGIO`      : Sent by queued SIGIO'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`SI_SIGIO` : 由排队的SIGIO发送'
- en: '`SI_ASYNCIO` : Sent by AIO completion'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`SI_ASYNCIO` : 由AIO完成发送'
- en: '`SI_MESGQ`      : Sent by real time message queue state change'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`SI_MESGQ` : 由实时消息队列状态更改发送'
- en: '`SI_TIMER`      : Sent by timer expiration'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`SI_TIMER` : 由定时器到期发送'
- en: '`si_errno` : (if non-zero) the errnovalue'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`si_errno` : （如果非零）errnovalue'
- en: 'Here''s the really interesting part: the fourth member of the structure is
    a union (`_sifields`) of seven structures. We understand that a union implies
    that any one member will be instantiated at runtime: it will be one of the seven
    structures depending on which signal is received!'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里真正有趣的部分是：结构的第四个成员是七个结构的`union`（`_sifields`）。我们知道`union`意味着在运行时将实例化任何一个成员：它将是七个结构中的一个，具体取决于接收到哪个信号！
- en: Take a look at the union within the `siginfo_t` structure previously shown;
    the comments within the union quite clearly point out which signal(s) will cause
    which data structure to be instantiated at runtime.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下之前显示的`siginfo_t`结构中的`union`；`union`中的注释非常清楚地指出了哪些信号将导致在运行时实例化哪个数据结构。
- en: 'For example, we see within the union that this structure will be populated
    when the `SIGCHLD` signal is received (that is, when a child process dies, stops,
    or continues):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们在`union`中看到，当接收到`SIGCHLD`信号时，将填充此结构（也就是说，当子进程死亡、停止或继续时）：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The information is with respect to the child process; hence, we receive the
    PID and real UID of the process that died (or was stopped or continued, unless
    the `SA_NOCLDWAIT` flag was used, of course). Further, we receive the integer
    bitmask `si_status` telling us how exactly the child died (and so on). Also, some
    audit information, `si_utime` and `si_stime`, the time spent by the child process
    in user and kernel space respectively.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 信息是关于子进程的；因此，我们接收到了进程的PID和真实UID（除非使用了`SA_NOCLDWAIT`标志，当然）。此外，我们接收到整数位掩码`si_status`告诉我们子进程究竟是如何死亡的（等等）。还有一些审计信息，`si_utime`和`si_stime`，子进程在用户空间和内核空间中所花费的时间。
- en: 'Recall from our detailed discussion in [Chapter 10](607ad988-406d-4736-90a4-3a318672ab6e.xhtml),* Process
    Creation*, *The wait API - Details* section*,* that we could obtain the child
    termination status information via (any of) the wait APIs. Well, here, we can
    see, it''s simpler: use the `SA_SIGINFO` flag, trap the `SIGCHLD` signal, and,
    in the handler function, just look up the relevant values from the union!'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在[第10章](607ad988-406d-4736-90a4-3a318672ab6e.xhtml)中的详细讨论，*进程创建*，*等待API
    - 详细信息*部分*，*我们可以通过（任何）`wait`API获取子进程终止状态信息。好吧，在这里，我们可以看到，更简单：使用`SA_SIGINFO`标志，捕获`SIGCHLD`信号，并且在处理程序函数中，只需从`union`中查找相关值！
- en: The man page on `sigaction(2)` describes the `siginfo_t` structure members in
    depth, providing detailed information. Do read through it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`sigaction(2)`的手册详细描述了`siginfo_t`结构的成员，提供了详细信息。务必仔细阅读。'
- en: Getting system-level details when a process crashes
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在进程崩溃时获取系统级细节
- en: 'A wealth of information can be gleaned from the kernel when a process dies
    via the `SIGSEGV`: memory bugs or defects, a common case, as we have discussed
    in the [Chapters 4](0b4868f7-a8d0-4ced-831f-20af9929de9f.xhtml), *Dynamic Memory
    Allocation*, [Chapter 5](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml), *Linux Memory
    Issues*, and  [Chapter 6](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml), *Debugging
    Tools for Memory Issues*. (This section also applies to the fatal signals `SIGBUS`, `SIGILL`,
    and `SIGFPE`. Incidentally, `SIGFPE` occurs not just upon a divide-by-zero error
    but in any kind of arithmetic-related exception).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程通过`SIGSEGV`死亡时，可以从内核中获取大量信息：内存错误或缺陷，这是一个常见情况，正如我们在[第4章](0b4868f7-a8d0-4ced-831f-20af9929de9f.xhtml)中讨论的那样，*动态内存分配*，[第5章](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml)，*Linux内存问题*和[第6章](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml)，*内存问题的调试工具*。（本节也适用于致命信号`SIGBUS`，`SIGILL`和`SIGFPE`。顺便说一句，`SIGFPE`不仅在除以零错误时发生，而且在任何与算术相关的异常中都会发生）。
- en: 'The man page on `sigaction(2)` reveals the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sigaction(2)`的手册中揭示了以下信息：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `SEGV_MAPERR` means that the address the process is attempting to access
    (for read, write, or execute) is invalid; there is either no **Page Table Entry** (**PTE**)
    entry available for it, or it refuses to map to any valid address.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEGV_MAPERR`表示进程试图访问的地址（读取、写入或执行）无效；要么没有可用于它的**页表项**（**PTE**）条目，要么它拒绝映射到任何有效地址。'
- en: 'The `SEGV_ACCERR` is easy to understand: the attempted access (read, write,
    or execute) cannot be performed, as permission is lacking (for example, attempting
    to write to a read-only memory page).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEGV_ACCERR`很容易理解：尝试访问（读取、写入或执行）无法执行，因为缺少权限（例如，尝试写入只读内存页）。'
- en: Peculiarly, the `SEGV_BNDERR` and `SEGV_PKUERR` macros fail to compile; we shall
    not attempt to use them here.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，`SEGV_BNDERR`和`SEGV_PKUERR`宏无法编译；我们不会在这里尝试使用它们。
- en: The glibc library provides the helper routines `psignal(3)` and `psiginfo(3)`;
    passed an informational string, they print it, appending a :  and then the actual
    signal that occurred and information on the cause of the signal being delivered
    and the faulting address (looked up from the siginfo_t structure) respectively.
    We use the `psiginfo(3)` in our example code as follows.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: glibc库提供了辅助例程`psignal(3)`和`psiginfo(3)`；传递一个信息字符串，它们会打印出来，然后是实际发生的信号以及有关信号传递和故障地址的信息（分别从siginfo_t结构中查找）。我们在示例代码中使用`psiginfo(3)`如下。
- en: Trapping and extracting information from a crash
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获并提取崩溃信息
- en: 'Next, we will see a test program `ch12/handle_segv.c`,with deliberate bugs,
    to help us understand the use cases possible. All this will result in the `SIGSEGV` signal being
    generated by the OS. How the application developer handles this signal is important:
    we demonstrate how you can use it to gather important details, such as the address
    of the memory location upon whose access the crash took place and the value of
    all registers at that point in time. These details often provide useful clues
    into the root cause of the memory bug.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到一个测试程序`ch12/handle_segv.c`，其中包含故意的错误，以帮助我们理解可能的用例。所有这些都将导致OS生成`SIGSEGV`信号。应用程序开发人员如何处理这个信号很重要：我们演示了如何使用它来收集重要的细节，例如发生崩溃的内存位置的地址以及那时所有寄存器的值。这些细节通常提供有用的线索，可以解释内存错误的根本原因。
- en: 'To help understand how we are constructing this program, run it without any
    parameters:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助理解我们如何构建这个程序，可以不带任何参数运行它：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As can be seen, we can thus perform four kinds of invalid memory accesses:
    in effect, four bug cases:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，我们可以执行四种类型的无效内存访问：实际上，有四种错误情况：
- en: Invalid user [u] mode read [r]
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效用户[u]模式读[r]
- en: Invalid user [u] mode write [w]
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效用户[u]模式写[w]
- en: Invalid kernel [k] mode read [r]
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核无效[k]模式读[r]
- en: Invalid kernel [k] mode write [w]
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效内核[k]模式写[w]
- en: 'Some typedefs and macros we use are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的一些typedef和宏如下：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `main` function is shown as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数如下所示：'
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: va = virtual address.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: va = 虚拟地址。
- en: 'Here is the key part: the signal handler for the SIGSEGV:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关键部分：SIGSEGV的信号处理程序：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There is much to observe here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多要观察的地方：
- en: We print out the signal number and origin value
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们打印出信号编号和原始值
- en: We interpret the signal origin value (via the switch-case)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过`switch-case`解释信号的原始值
- en: Particularly for SIGSEGV, the SEGV_MAPERR, and SEGV_ACCERR
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别是对于SIGSEGV，SEGV_MAPERR和SEGV_ACCERR
- en: 'Here comes the interesting bit: the following code prints out the faulting
    instruction or address! Not only that, we devise a means by which we can print
    out most of the CPU registers as well via our `dump_regs` function. As mentioned
    earlier, we also make use of the helper routine `psiginfo(3)` as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是有趣的部分：以下代码打印出故障指令或地址！不仅如此，我们设计了一种方法，通过它我们可以通过我们的`dump_regs`函数打印出大部分CPU寄存器。正如前面提到的，我们还使用辅助例程`psiginfo(3)`如下：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then just keep some dummy stubs for the functionality you probably want
    in a real-world application, when handling a fatal signal such as this (here,
    we do not actually write any code, as it''s of course very application-specific):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只保留了一些虚拟存根，用于处理这种致命信号在真实世界应用程序中可能需要的功能（在这里，我们实际上没有编写任何代码，因为这当然是非常特定于应用程序的）：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, calling `abort(3)` so that the process terminates (as it''s now in
    an undefined state and cannot continue) is one way to finish. However, think for
    a second: if we abort() now, the process dies without the kernel getting a chance
    to generate a core dump. (As mentioned, a core dump is essentially a snapshot
    of the process''s dynamic memory segments at the time of the crash; it''s very
    useful for developers to debug and determine the root cause of the crash). So,
    having the kernel generate a core dump would indeed be useful. How can we arrange
    for this? Its quite simple really: we need to do the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用`abort(3)`使进程终止（因为它现在处于未定义状态，无法继续）是一种结束的方式。然而，请思考一下：如果我们现在`abort()`，进程将在内核有机会生成核心转储的情况下死亡。（如前所述，核心转储实质上是进程在崩溃时的动态内存段的快照；对于开发人员来说，它非常有用，可以用于调试和确定崩溃的根本原因）。因此，让内核生成核心转储确实是有用的。我们如何安排这个呢？这其实非常简单：我们需要做以下几点：
- en: Reset the `SIGSEGV` signal's handler to the (kernel) default
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`SIGSEGV`信号的处理程序重置为（内核）默认值
- en: Have the signal (re)raised on the process
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进程上重新引发信号
- en: 'This code fragment achieves just this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段实现了这一点：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As it's a simple case, we just use the simpler `signal(2)` API to revert the
    signal's action to the default. Then, again, we use the library API `raise(3)` to
    raise a given signal on the calling process. (The error-checking code has been
    left out for easy readability.)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个简单的情况，我们只需使用更简单的`signal(2)` API将信号的操作恢复为默认值。然后，我们再次使用库API `raise(3)` 来在调用进程上引发给定的信号。（出于易读性的考虑，错误检查代码已被省略。）
- en: Register dumping
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寄存器转储
- en: 'As mentioned, the `dump_regs` function prints out CPU register values; here
    are a few things to note regarding this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`dump_regs`函数打印出CPU寄存器的值；以下是关于此的一些需要注意的事项：
- en: It's very CPU-specific (the example case shown as follows works only for the
    x86_64 CPUs).
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是非常特定于CPU的（下面显示的示例情况仅适用于x86_64 CPU）。
- en: 'To actually gain access to the CPU registers, we make use of the undocumented
    third parameter to the signal handler function (note: when used with`SA_SIGINFO`),
    the so-called user context pointer. It is possible to interpret it (as we demonstrate
    here), but, of course, as it''s not officially visible via the glibc system call
    (or other) interfaces, you cannot rely on this functionality. Use with caution
    (and a lot of testing).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了实际访问CPU寄存器，我们利用信号处理程序函数的未记录的第三个参数（注意：当与`SA_SIGINFO`一起使用时），即所谓的用户上下文指针。它是可能解释的（正如我们在这里展示的），但是，当然，由于它在glibc系统调用（或其他）接口中没有正式可见，您不能依赖这个功能。谨慎使用（并进行大量测试）。
- en: 'Having said that, let''s check out the code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，让我们来看看代码：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s run two of the test cases:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行两个测试用例：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here are some things to note:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的事项：
- en: The origin value is `SEGV_MAPERR`: yes, the arbitrary userspace virtual address
    we attempted to read (`0xdeadface`)  is not present (or mapped), hence the segfault!
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始值是`SEGV_MAPERR`：是的，我们尝试读取的任意用户空间虚拟地址（`0xdeadface`）不存在（或映射），因此发生了段错误！
- en: 'The faulting address is revealed as the invalid arbitrary userspace virtual
    address we attempted to read (`0xdeadface`):'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障地址被显示为我们尝试读取的无效任意用户空间虚拟地址（`0xdeadface`）：
- en: 'An aside: an important value—the faulting instruction or address—is actually
    the value saved in the x86''s **control register 2** (**CR2**), as can be seen.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另外：一个重要的值——故障指令或地址——实际上是保存在x86的**控制寄存器2**（**CR2**）中，如下所示。
- en: 'The TRAP number shows up as 14; trap 14 on an x86[_64] is the Page Fault. The
    reality is: when the process attempted to read the invalid virtual address (`0xdeadface`),
    the bad access resulted in the x86[_64] MMU raising a bad page fault exception,
    which in turn led to the OS fault handler code running and killing the process
    via the SIGSEGV.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TRAP号显示为14；在x86[_64]上的trap 14是页面故障。事实上：当进程尝试读取无效虚拟地址（`0xdeadface`）时，错误访问导致了x86[_64]
    MMU引发了一个坏页故障异常，进而导致了操作系统故障处理程序的运行，并通过SIGSEGV杀死了进程。
- en: The CPU registers are dumped as well.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU寄存器也被转储。
- en: The curious reader will perhaps wonder what exactly each register is used for.
    This is an area beyond this book's scope; nevertheless, the reader can find useful
    information by seeking out the CPU OEM's **Application Binary Interface** (**ABI**)
    documentation; among many things, it specifies register usage for function calling,
    return, parameter passing, and so on. Check out the *Further reading *section
    on the GitHub repository for more on ABI docs.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 好奇的读者也许会想知道每个寄存器究竟用来做什么。这超出了本书的范围；然而，读者可以通过查找CPU OEM的**应用二进制接口**（**ABI**）文档来找到有用的信息；其中包括函数调用、返回、参数传递等的寄存器使用。在GitHub存储库的*进一步阅读*部分查看ABI文档的更多内容。
- en: The `psiginfo(3)` takes effect as well, printing out the cause of the signal
    and the faulting address
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`psiginfo(3)`也生效，打印出信号的原因和故障地址'
- en: 'The message `Segmentation fault (core dumped)` tells us that our strategy worked:
    we reset the signal handling for the SIGSEGV to the default one and re-raised
    the signal, causing the OS (kernel) to generate a core dump. The resulting core
    file (generated on a Fedora 28 x86_64 box) shows up as shown below:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息`Segmentation fault (core dumped)`告诉我们我们的策略奏效了：我们将SIGSEGV的信号处理重置为默认值，然后重新引发了信号，导致操作系统（内核）生成了一个核心转储。生成的核心文件（在Fedora
    28 x86_64上生成）如下所示：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here are a couple of points to mention:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些要提到的要点：
- en: The detailed analysis and interpretation of a core dump is beyond the scope
    of this book. Using GDB to analyze a core dump is easy; a little googling will
    yield results.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对核心转储的详细分析和解释超出了本书的范围。使用GDB分析核心转储很容易；稍微搜索一下就会有结果。
- en: The name given to the core file varies; modern Fedora distribution set the name
    to be very descriptive (as you can see); in reality, the core filename is controlled
    via a kernel tunable in the proc filesystem. See the man page on `core(5)`for
    details.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心文件的名称因发行版而异；现代的Fedora发行版设置名称非常描述性（如您所见）；实际上，核心文件名是通过`proc`文件系统中的内核可调参数来控制的。有关详细信息，请参阅`core(5)`的手册页。
- en: 'We run the kernel-space, invalid write test case for our `handle_segv`program
    as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行内核空间的无效写入测试用例，为我们的`handle_segv`程序如下：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that, this time, the trap value is 13; on the x86[_64] MMU, that''s the **General
    Protection Fault** (**GPF**). Again, this bad access resulted in the x86[_64]
    MMU raising a GPF exception, which in turn led to the OS fault handler code running
    and killing the process via the SIGSEGV. The trap being a GPF is a clue: we have
    violated a protection rule; recall from [Chapter 1](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml),
    *Linux System Architecture*: a process (or thread) running in a higher, more privileged
    level can always access memory at a lower privilege level but not vice versa of
    course. Here, the process at ring three attempted to access memory at ring zero;
    hence, the MMU raised the GPF exception and the OS killed it (via the `SIGSEGV`).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次陷阱值为13；在x86[_64] MMU上，这是**通用保护故障**（**GPF**）。再次，这次错误访问导致了x86[_64] MMU引发了GPF异常，进而导致了操作系统故障处理程序的运行，并通过SIGSEGV杀死了进程。陷阱是GPF是一个线索：我们违反了保护规则；回想一下[第1章](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml)中所述的内容：运行在更高、更特权级别的进程（或线程）总是可以访问更低特权级别的内存，但反之则不行。在这里，运行在第三特权级的进程尝试访问第零特权级的内存；因此，MMU引发了GPF异常，操作系统将其杀死（通过`SIGSEGV`）。
- en: This time, unfortunately, the CR2 value and thus the faulting address is 0x0
    (in the case where the crash occurs in kernel-space). However, we still get valuable
    details in other registers (the instruction and stack pointer values, and so on,
    as we shall see next).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，不幸的是，CR2值和因此故障地址为0x0（在崩溃发生在内核空间的情况下）。然而，我们仍然可以从其他寄存器中获得有价值的细节（指令和堆栈指针值等），接下来我们将看到。
- en: Finding the crash location in source code
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在源代码中找到崩溃位置
- en: 'The RIP (Instruction Pointer**;** EIP on IA-32, PC on the ARM) is useful: using
    its value and some utilities, we can pretty much pinpoint the location in code
    when the process crashed. How? There are several ways; some of them are as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: RIP（指令指针**；**IA-32上的EIP，ARM上的PC）是有用的：使用它的值和一些实用程序，我们几乎可以确定进程崩溃时代码的位置。如何？有几种方法；其中一些如下：
- en: Use the toolchain utility `objdump` (with the `-d` `-S` switches)
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工具链实用程序`objdump`（带有`-d` `-S`开关）
- en: An easier way is to use `gdb(1)` (see the following)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更简单的方法是使用`gdb(1)`（请参阅下文）
- en: With the `addr2line(1)` utility
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`addr2line(1)`实用程序
- en: 'With GDB:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GDB：
- en: 'Load up `gdb(1)` with the debug version (compiled with the `-g` switch) of
    the program, and then use the list command as shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用程序的调试版本（使用`-g`开关编译）加载`gdb(1)`，然后使用如下所示的`list`命令：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `list * <address>` command literally pinpoints the code that caused the
    crash, reproduced here for clarity:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`list * <address>`命令确切地指出了导致崩溃的代码，为了清晰起见，这里再次重现：'
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Line 212 is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 第212行如下：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is exactly right.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全正确。
- en: 'With `addr2line`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`addr2line`：
- en: 'The `addr2line(1)` utility provides a similar feature; again, run it against
    the built-for-debug (compiled with `-g`) version of the binary executable file
    via it''s `-e` switch:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`addr2line(1)`实用程序提供了类似的功能；再次运行它针对使用`-g`编译的二进制可执行文件的`-e`开关版本（用于调试构建）：'
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Also, think about it: our previous `ch12/altstack.c`program can, and will,
    suffer a segmentation fault when its alternate signal stack is overflowed; we
    leave it as an exercise to the reader to write a `SIGSEGV` handler similar to
    the one shown here to properly handle the case.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，想想：我们之前的`ch12/altstack.c`程序在其备用信号栈溢出时可能会遭受段错误；我们留给读者的练习是编写一个类似于此处所示的`SIGSEGV`处理程序来正确处理这种情况。
- en: Finally, though, we have shown that handling the segfault, the SIGSEGV, can
    be very beneficial to figuring out the cause of a crash; the simple fact remains
    that once this signal is generated upon a process, the process is considered to
    be in an undefined, in effect, unstable, state. Thus, there is no guarantee that
    whatever work we perform in its signal handler will actually go through as intended.
    Thus, keeping the signal handling code to a minimum would be recommended.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经表明处理段错误SIGSEGV对于找出崩溃原因非常有益；简单的事实仍然是，一旦此信号在进程上生成，该进程被认为处于未定义的，实际上是不稳定的状态。因此，不能保证我们在其信号处理程序中执行的任何工作实际上会按预期进行。因此，建议将信号处理代码保持最少。
- en: Signaling – caveats and gotchas
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号 - 注意事项和陷阱
- en: Signals, being asynchronous events, can cause errors and bugs in subtle ways
    that are not immediately apparent to the casual reviewer (or programmer, for that
    matter). Some kinds of functionality or behavior are directly or indirectly affected
    by the arrival of one or more signal; you need to be alert to possible subtle
    races and similar conditions.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 信号作为异步事件，可能以不立即显而易见的方式导致错误和错误（或者对程序员来说）。某些功能或行为直接或间接受到一个或多个信号到达的影响；您需要警惕可能的微妙竞争和类似条件。
- en: 'One important area in this that we have already covered is as follows: inside
    a signal handler, you can only invoke functions that are documented as being (or
    have been designed to be) async-signal safe. Other areas too deserve some contemplation;
    read on.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖的一个重要领域是：在信号处理程序内，您只能调用已记录为（或已设计为）异步信号安全的函数。其他领域也值得一些思考；继续阅读。
- en: Handling errno gracefully
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优雅地处理errno
- en: A race with the uninitialized global integer `errno` can occur in programs using
    system calls and signals.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用系统调用和信号的程序中可能会出现与未初始化的全局整数`errno`的竞争。
- en: What does errno do?
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: errno的作用是什么？
- en: Remember the errnoglobal; it's an uninitialized global integer in the process's uninitialized
    data segment (process layout was covered in [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml), *Virtual
    Memory*).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 记住errnoglobal；它是进程未初始化数据段中的未初始化全局整数（进程布局在[第2章](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml)中已经涵盖，*虚拟内存*）。
- en: 'What is errno for? Whenever a system call fails, it returns `-1` to userspace.
    But why did it fail? Ah, the error diagnostic, the reason it failed, is returned
    to userspace like this: glibc, in conjunction with the kernel, pokes the global errno with
    a positive integer value. This value is actually an index into a two-dimensional
    array of English error messages (which is NULL-terminated); it''s called`_sys_errlist`.
    So, looking up `_sys_errlist`[errno] reveals the English error message: the reason
    the system call failed.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: errno是用来做什么的？每当系统调用失败时，它会向用户空间返回`-1`。但是它为什么失败？啊，错误诊断，它失败的原因，以这种方式返回给用户空间：glibc与内核一起，用正整数值poke全局errno。这个值实际上是一个英文错误消息的二维数组的索引（它是以NULL结尾的）；它被称为`_sys_errlist`。因此，查找`_sys_errlist`[errno]会显示英文错误消息：系统调用失败的原因。
- en: 'Instead of the developer performing all the work, convenience routines such
    as `perror(3)`, `strerror(3)`, and `error(3)` are designed to emit error messages
    by looking up `_sys_errlist[errno]`. Programmers very often use routines such
    as this in the system call error- handling code (in fact, we do: check out our
    code for the macros `WARN` and `FATAL`—they call the `handle_err` function, which
    in turn invokes `perror(3)` as part of its processing).'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员不再执行所有工作，而是设计了方便的例程，如`perror(3)`、`strerror(3)`和`error(3)`，通过查找`_sys_errlist[errno]`来发出错误消息。程序员经常在系统调用错误处理代码中使用这样的例程（事实上，我们确实这样做：查看我们的宏`WARN`和`FATAL`的代码
    - 它们调用`handle_err`函数，该函数又调用`perror(3)`作为其处理的一部分）。
- en: Here is a useful-to-look-up item—the list of all possible `errno` values resides
    in the header file `/usr/include/asm-generic/errno-base.h`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的查找项目 - 所有可能的`errno`值列表位于头文件`/usr/include/asm-generic/errno-base.h`中。
- en: The errno race
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: errno竞争
- en: 'Consider this situation:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种情况：
- en: 'A process sets up a signal handler for several signals:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程为几个信号设置了信号处理程序：
- en: Let's say the signal handler for `SIGUSR1` is called `handle_sigusr.`
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设`SIGUSR1`的信号处理程序称为`handle_sigusr`。
- en: 'Now the process is running a part of its code, a function `foo`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在进程正在运行其代码的一部分，一个名为`foo`的函数。
- en: foo issues a system call, say the `open(2)`
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: foo发出一个系统调用，比如`open(2)`。
- en: The system call fails returning `-1`
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用失败返回`-1`。
- en: errno gets set to the positive integer `13` reflecting the error permission
    denied (errno macro EACCES).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: errno设置为正整数`13`，反映了错误的权限被拒绝（errno宏EACCES）。
- en: The system call's error-handling code calls `perror(3)`to emit the English error
    message.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用的错误处理代码调用`perror(3)`来发出英文错误消息。
- en: 'All this seems innocent enough, yes. However, now let''s consider signals in
    the mix; check out the following scenario:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些似乎都很无辜，是的。但是，现在让我们考虑信号的情况；查看以下情景：
- en: '*<...>*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*<...>*'
- en: foo issues a system call, say the `open(2)`*.*
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: foo发出一个系统调用，比如`open(2)`。
- en: The system call fails returning `-1`.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用失败返回`-1`。
- en: errno gets set to the positive integer `13` reflecting the error permission
    denied (errno macro EACCES).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: errno设置为正整数`13`，反映了错误的权限被拒绝（errno宏EACCES）。
- en: The signal `SIGUSR1` is delivered at this instant to the process.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号`SIGUSR1`此刻传递给进程。
- en: Control is switched to the signal handler routine, `handle_sigusr`.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制转移到信号处理程序`handle_sigusr`。
- en: The code here issues another system call, say, `stat(2)`**.**
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里的代码发出另一个系统调用，比如`stat(2)`**。**
- en: The `stat(2)` system call fails returning `-1`.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stat(2)`系统调用失败，返回`-1`。'
- en: errno now gets set to the positive integer `9` reflecting the error bad file
    number (errno macro EBADF).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在`errno`被设置为正整数`9`，反映了错误的坏文件号（errno宏EBADF）。
- en: The signal handler returns.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号处理程序返回。
- en: The system call's error-handling code calls `perror(3)` to emit the English
    error message.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用的错误处理代码调用`perror(3)`来发出英文错误消息。
- en: As can be seen, the value of errno gets overwritten from the value 13 to the
    value 9 because of the sequence of events. The result is that the application
    developer (along with everyone else on the project) is now confounded by the weird
    error reporting (the error bad file number is possibly reported twice!). Races—the
    bane of programmers!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，由于事件序列，`errno`的值从13被覆盖为9。结果是应用程序开发人员（以及项目中的其他人）现在被奇怪的错误报告所困扰（错误的坏文件号可能被报告两次！）。竞争——程序员的悲哀！
- en: Fixing the errno race
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复errno竞争
- en: The fix for the previous race is actually quite simple.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 修复之前的竞争实际上非常简单。
- en: Whenever you have a signal handler with code within it that could possibly cause
    the errno value to change, save `errno` upon function entry and restore it just
    before returning from the handler.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你有一个信号处理程序，其中的代码可能导致`errno`值发生变化时，要在函数进入时保存`errno`，并在处理程序返回之前恢复它。
- en: 'Gain access to the `errno` variable simply by including its header file. Here
    is a quick example code snippet of a signal handler that does this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包含其头文件来简单地访问`errno`变量。以下是一个快速示例代码片段，显示了如何在信号处理程序中实现这一点：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Sleeping correctly
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确睡眠
- en: Yes, even sleeping requires sufficient knowledge to perform correctly!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，即使睡眠也需要足够的知识才能正确执行！
- en: 'Often, your process has to enter a sleep state. We have all probably learned
    to use the `sleep(3)` API to do so:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你的进程必须进入睡眠状态。我们都可能学会了使用`sleep(3)`API来实现：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As a simple example, let''s say that the process must work this way (pseudo
    code follows):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 举个简单的例子，假设进程必须以这种方式工作（伪代码如下）：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It''s quite clear: the process must sleep for `10` seconds; the code shown
    should work. Is there a problem?'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显：进程必须睡眠`10`秒；所示的代码应该可以工作。有问题吗？
- en: 'Well, yes, signals: what if the process enters the sleep, but three seconds
    into the sleep a signal arrives? The default behavior (meaning, unless signals
    are masked) is to handle the signal, and you would imagine, go back to sleep for
    the remaining time (seven seconds). But, no, that''s not what happens: the sleep is
    aborted! The astute reader might argue that it''s possible to fix this behavior
    (a blocking system call interrupted by signals) by using the `SA_RESTART` flag;
    indeed, it sounds reasonable, but the reality is that even using the flag does
    not help (the sleep has to be manually restarted).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，是的，信号：如果进程进入睡眠状态，但是在睡眠三秒钟后收到一个信号呢？默认行为（也就是说，除非信号被屏蔽）是处理信号，你会想象，然后回到睡眠状态，剩下的时间（七秒）。但是，不，事实并非如此：睡眠被中止了！敏锐的读者可能会争辩说可以通过使用`SA_RESTART`标志来修复这种行为（被信号中断的阻塞系统调用）；的确，这听起来是合理的，但现实是即使使用了该标志也没有帮助（睡眠必须手动重新启动）。
- en: Further, it's important to realize that the `sleep(3)` API documents that its
    return value is the amount of time remaining to sleep; so unless `sleep(3)` returns
    `0`, the sleep is not done! The developer is actually expected to invoke `sleep(3)` in
    a loop, until the return value is `0`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重要的是要意识到`sleep(3)`API文档规定其返回值是剩余的睡眠时间；因此，除非`sleep(3)`返回`0`，否则睡眠没有完成！实际上，开发人员期望在循环中调用`sleep(3)`，直到返回值为`0`。
- en: What does making a process (or thread) "go to sleep" really mean?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让进程（或线程）"进入睡眠"到底意味着什么？
- en: 'The key point is this: a process (or thread) that''s asleep cannot run on the
    CPU while in that state; it is not even a candidate for the OS scheduler (technically,
    the transition from state'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于：处于睡眠状态的进程（或线程）在该状态下无法在CPU上运行；它甚至不是OS调度程序的候选对象（从技术上讲，从状态转换
- en: Running->sleeping is a dequeue from a run queue and an enqueue on to a wait
    queue within the OS, and vice versa). More on this in [Chapter 17](36229bac-c402-4d2f-b876-d1eb4aba8051.xhtml),
    *CPU Scheduling on Linux*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 运行->睡眠是从运行队列出队并进入OS的等待队列，反之亦然）。有关更多信息，请参阅[第17章](36229bac-c402-4d2f-b876-d1eb4aba8051.xhtml)，*Linux上的CPU调度*。
- en: 'So, we conclude that just using a `sleep(3)` in the code is not that great
    an idea because of the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得出结论，仅仅在代码中使用`sleep(3)`并不是一个好主意，因为：
- en: The sleep, once interrupted by signal delivery, must be manually restarted.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦被信号传递中断，睡眠必须手动重新启动。
- en: 'The granularity of `sleep(3)` is very coarse: a second. (A second is a very,
    very long time for a modern microprocessor! Many real-world applications rely
    on at least millisecond-to-microsecond-level granularity.)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sleep(3)`的粒度非常粗糙：一秒。（对于现代微处理器来说，一秒是非常非常长的时间！许多现实世界的应用程序依赖于至少毫秒到微秒级的粒度。）'
- en: So, what is the solution?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，解决方案是什么？
- en: The nanosleep system call
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: nanosleep系统调用
- en: 'Linux provides a system call, `nanosleep(2)`, that in theory can provide nanosecond-level
    granularity, that is, a sleep of a single nanosecond. (Well, in practice, the
    granularity will also depend on the resolution of the hardware timer chip on the
    board.) This is the prototype of this API:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Linux提供了一个系统调用`nanosleep(2)`，理论上可以提供纳秒级的粒度，也就是说，可以睡眠一纳秒。（实际上，粒度还取决于板上硬件定时器芯片的分辨率。）这是该API的原型：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The system call has two parameters both are pointers to structure of data type
    struct `timespec`; this structure definition is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用有两个参数，都是指向数据类型为struct `timespec`的结构的指针；该结构定义如下：
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Obviously, this allows you to specify the sleep time in seconds and nanoseconds;
    the first parameter `req` is the required time (`s.ns`), the second parameter `rem` is
    the remaining time to sleep. See, the OS helps us out here: if the sleep is interrupted
    by a signal (any signal that is non-fatal), the `nanosleep `system call fails
    returning `-1` , and errno is set to the value `EINTR` (Interrupted system call).
    Not only that, the OS calculates and returns (into this second pointer, a value-result type
    of parameter), the amount of time remaining to sleep accurate to the nanosecond. This
    way, we detect the case, set `req` to `rem`, and manually reissue the `nanosleep(2)` to
    have the sleep continue until it''s fully done.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这允许您以秒和纳秒为单位指定睡眠时间；第一个参数`req`是所需时间（`s.ns`），第二个参数`rem`是剩余的睡眠时间。看，操作系统在这里帮了我们：如果睡眠被信号（任何非致命的信号）中断，`nanosleep`系统调用失败，返回`-1`，并将`errno`设置为值`EINTR`（中断的系统调用）。不仅如此，操作系统会计算并返回（到这第二个指针，一个值-结果类型的参数），准确到纳秒的剩余睡眠时间。这样，我们检测到这种情况，将`req`设置为`rem`，并手动重新发出`nanosleep(2)`，使睡眠继续进行直到完全完成。
- en: 'To demonstrate, we show a small application next (source code: `ch12/sleeping_beauty.c`); the
    user can invoke either the usual `sleep(3)` method of sleeping, or use the highly
    superior `nanosleep(2)` API such that the sleep time is accurate:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们接下来展示一个小应用程序（源代码：`ch12/sleeping_beauty.c`）；用户可以调用通常的`sleep(3)`睡眠方法，也可以使用高度优越的`nanosleep(2)`API，以便睡眠时间准确：
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note the following from the previous code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前面代码中的以下内容：
- en: Passing `0` as the parameter has us invoke the usual `sleep(3)`*.*
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`0`作为参数传递使我们调用通常的`sleep(3)`*.*。
- en: We deliberately code without using a loop here, as this is how most programmers
    call `sleep(3)` (and thus we can see the pitfalls).
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们故意在这里编写代码而不使用循环，因为这是大多数程序员调用`sleep(3)`的方式（因此我们可以看到其中的缺陷）。
- en: Passing `1` as the parameter has us invoke the powerful `nanosleep(2)` API;
    we initialize the required time to be 10 seconds (same as in the previous case).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`1`作为参数传递使我们调用强大的`nanosleep(2)`API；我们将所需时间初始化为10秒（与前面的情况相同）。
- en: But, this time, we call the `nanosleep(2)` in a loop, checking for the signal
    interruption case `errno == EINTR`, and if so,
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但是，这一次，我们在循环中调用`nanosleep(2)`，检查信号中断情况`errno == EINTR`，如果是的话，
- en: We set `req` to `rem` and call it again!
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`req`设置为`rem`并再次调用它！
- en: '(For fun, we print the time remaining `s.ns`):'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （为了好玩，我们打印剩余时间`s.ns`）：
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s try both cases: first, the usual `sleep(3)` method:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试两种情况：首先是通常的`sleep(3)`方法：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A few seconds into the sleep, we press *^C*; the signal arrives, but the sleep
    is aborted (as shown, an additional seven seconds of the sleep remain, which the
    code here simply ignores)!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 睡眠几秒钟后，我们按下*^C*；信号到达，但睡眠被中止（如所示，睡眠还剩下额外的七秒，这里的代码简单地忽略了）！
- en: 'Now for the good case: sleeping via the `nanosleep(2)`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是好的情况：通过`nanosleep(2)`睡眠：
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This time, our dear `sleeping_beauty` runs (sleeps?) to completion even in
    the presence of continuous interruption via multiple signals. You should notice,
    though, this fact: there is going to be some overhead, yes. The only guarantee
    made by the OS is that the sleep continues for at least as long as required, possibly
    a bit longer.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们亲爱的`睡美人`（睡觉？）即使在连续中断多个信号的情况下也能完成。不过，你应该注意到这一点：确实会有一些开销。操作系统唯一保证的是睡眠至少持续所需的时间，可能会稍微长一些。
- en: 'Note: although using the `nanosleep(2)` results in a highly superior implementation
    to the usual `sleep(3)` API, the fact is that even the `nanosleep` is subject
    to (what could become significant) time overruns when the code is within a loop and a
    sufficiently large number of signals interrupts our loop many, many times (as
    could occur in our previous example). In cases such as this, we can end up oversleeping quite
    a bit. To fix this, the POSIX standard, and Linux, provide an even better `clock_nanosleep(2)` system
    call: using it with a real-time clock and a flag value of `TIMER_ABSTIME` takes
    care of the oversleeping issue. Also note that though Linux''s `sleep(3)` API
    is internally implemented via `nanosleep(2)`, the sleep semantics remain as described;
    it''s the app developer''s responsibility to call the sleep code in a loop, checking
    for return value and the failure case.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：尽管使用`nanosleep(2)`相对于通常的`sleep(3)`API来说是一个高度优越的实现，但事实是，即使`nanosleep`也会受到（可能会变得显著）的时间超限的影响，当代码在循环中并且足够多的信号中断我们的循环很多次（就像在我们之前的例子中可能发生的那样）。在这种情况下，我们可能会睡得过多。为了解决这个问题，POSIX标准和Linux提供了一个更好的`clock_nanosleep(2)`系统调用：使用它和实时时钟以及`TIMER_ABSTIME`标志值可以解决过度睡眠的问题。还要注意，尽管Linux的`sleep(3)`API是通过`nanosleep(2)`内部实现的，但睡眠语义仍然如描述的那样；调用睡眠代码在循环中，检查返回值和失败情况是应用程序开发人员的责任。
- en: Real-time signals
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时信号
- en: Recall the output of the `kill -l` (l for list) command; the platform's supported
    signals are displayed—numeric integer and symbolic name, both. The first 31 signals
    are the standard or Unix signals (seen in [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml),
    *Signaling - Part I*, *The standard or Unix signals* section); we have been working
    with them quite a bit now.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下`kill -l`（l代表列表）命令的输出；平台支持的信号都会显示出来——包括数字整数和符号名称。前31个信号是标准的Unix信号（在[第11章](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml)中看到，*信号-第一部分*，*标准或Unix信号*部分）；我们现在已经在使用它们了。
- en: 'Signal numbers 34 to 64 all start with `SIGRT`—`SIGRTMIN` to `SIGRTMAX`—they
    are called the **real time** signals:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 信号编号34到64都以`SIGRT`开头——`SIGRTMIN`到`SIGRTMAX`——它们被称为**实时**信号：
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: (The first one, `SIGSYS` seen here is not a real time signal; it shows up because
    it's in the same line as the other SIGRT's and so `grep(1)` prints it.)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: （这里看到的第一个`SIGSYS`不是实时信号；它出现是因为它与其他SIGRT在同一行，所以`grep(1)`打印出来。）
- en: Differences from standard signals
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与标准信号的不同之处
- en: 'So, how do the so-called real time signals differ from the regular standard
    signals; the following table reveals  this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 那么所谓的实时信号与常规标准信号有何不同；以下表格揭示了这一点：
- en: '| **Characteristic** | **Standard signals** | **Real time signals** |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| **特征** | **标准信号** | **实时信号** |'
- en: '| Numbering | 1 - 31 ¹ | 34 - 64 ² |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 编号 | 1 - 31 ¹ | 34 - 64 ² |'
- en: '| Standard first defined in | POSIX.1-1990 (it''s old) | POSIX 1003.1b : real
    time Extensions to POSIX (2001) |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 标准首次定义于 | POSIX.1-1990（很旧） | POSIX 1003.1b：POSIX的实时扩展（2001） |'
- en: '| Meaning assigned | Individual signals have a particular meaning (and are named
    accordingly); the exception is `SIGUSR[1&#124;2]` | Individual RT signals have no particular
    meaning; their meaning is app-defined |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 分配的含义 | 单个信号具有特定含义（并相应命名）；例外是`SIGUSR[1&#124;2]` | 单个RT信号没有特定含义；它们的含义由应用程序定义
    |'
- en: '| Behavior when blocked and multiple instances of same signal  continuously
    delivered | Out of n instances of the same signal, n-1 are lost; only 1 instance
    is kept pending and delivered to the target process when unblocked | All instances
    of RT signals are queued and delivered to the target process by the OS when unblocked (there
    is a system-wide upper limit ³) |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 阻塞时和多个相同信号实例连续传递时的行为 | 在n个相同信号的实例中，n-1个会丢失；只有1个实例保持挂起，并在解除阻塞时传递给目标进程 | 所有RT信号的实例都会被排队并在解除阻塞时由操作系统传递给目标进程（存在系统范围的上限³）|'
- en: '| Signal priority | The same: all standard signals are peers | FCFS unless
    pending; if pending, then signals delivered from lowest to highest numbered realtime
    signal ⁴ |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 信号优先级 | 相同：所有标准信号都是对等的 | FCFS，除非挂起；如果挂起，那么从最低编号的实时信号开始传递到最高编号的实时信号⁴ |'
- en: '| **Inter Process Communication** (**IPC**) | Crude IPC; you can use `SIGUSR[1&#124;2]` to
    communicate, but no data can be passed | Better: via the `sigqueue(3)`, a single
    data item, an integer or pointer value, can be sent to a peer process (which can
    retrieve it) |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| **进程间通信**（**IPC**） | 粗糙的IPC；可以使用`SIGUSR[1&#124;2]`进行通信，但无法传递数据 | 更好：通过`sigqueue(3)`，可以向对等进程发送单个数据项，整数或指针值（对等进程可以检索它）|'
- en: Differences between standard and realtime signals
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 标准信号和实时信号之间的差异
- en: ¹ Signal number `0`? Does not exist, used to check for process existence (seen
    later).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 信号编号`0`？不存在，用于检查进程是否存在（稍后看到）。
- en: '² An FAQ: whatever happened to realtime signal numbers 32 and 33? The answer:
    they are reserved for use by the pthreads implementation, and thus unavailable
    to the application developer.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ² 一个常见问题：实时信号编号32和33发生了什么？答案：它们被pthread实现保留，因此应用程序开发人员无法使用。
- en: '³ The system-wide upper limit is a resource limit and can thus be queried or
    set via the `prlimit(1)` utility (or the `prlimit(2)` system call):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ³ 系统范围的上限是一个资源限制，因此可以通过`prlimit(1)`实用程序（或`prlimit(2)`系统调用）查询或设置：
- en: '[PRE29]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: (Recall from [Chapter 3](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml), *Resource
    Limits*, that the first number is the soft limit, the second is the hard limit).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: （回想一下[第3章](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml)，*资源限制*，第一个数字是软限制，第二个是硬限制）。
- en: '⁴ RT signal priority: multiple instances of realtime signals are processed
    in exactly the order they were delivered (in other words, **First Come First Served** (**FCFC**).
    However, if these multiple real time signals are pending delivery to the process,
    that is, they are currently blocked, then they are processed in priority order, rather
    non-intuitively, `SIGRTMIN` being the highest priority signal and `SIGRTMAX` being
    the lowest.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ⁴ RT信号优先级：实时信号的多个实例将按照它们被传递的顺序进行处理（换句话说，**先来先服务**（**FCFC**）。但是，如果这些多个实时信号正在等待传递给进程，也就是说，它们当前被阻塞，那么它们将按照优先顺序进行处理，相当不直观地，`SIGRTMIN`是最高优先级信号，`SIGRTMAX`是最低优先级信号。
- en: Real time signals and priority
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时信号和优先级
- en: 'The POSIX standard, and the Linux documentation, states that when multiple
    real time signals of different types are pending delivery to a process (that is the
    process is blocking them); then, at some point, when the process''s signal mask
    is unblocked (thereby allowing the signals to be delivered), the signals are indeed
    delivered in priority order: lowest signal number to highest signal number.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX标准和Linux文档指出，当不同类型的多个实时信号正在等待传递给进程时（即进程正在阻塞它们）；然后，在某个时刻，当进程的信号掩码解除阻塞（从而允许信号传递）时，信号确实按照优先顺序传递：从最低信号编号到最高信号编号。
- en: 'Let''s test this: we write a program that traps and blocks upon the delivery
    of three real time signals: {`SIGRTMAX-5`, `SIGRTMAX`, `SIGRTMIN+5`}. (Have a
    look at the output of `kill -l`; their integer values are {59, 64, 39} respectively.)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下：我们编写一个程序，捕获并在传递三个实时信号时阻塞：{`SIGRTMAX-5`，`SIGRTMAX`，`SIGRTMIN+5`}。（查看`kill
    -l`的输出；它们的整数值分别为{59，64，39}。）
- en: Importantly, our program will, at the time of `sigaction(2)`, use the `sigfillset(3)` convenience
    method to populate the signal mask member of struct sigaction with all 1s, thereby
    ensuring that all signals are blocked (masked) while the signal handler code is
    running.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们的程序在`sigaction(2)`时将使用`sigfillset(3)`便利方法，用全1填充结构sigaction的信号掩码成员，从而确保所有信号在信号处理程序代码运行时被阻塞（屏蔽）。
- en: 'Consider the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下内容：
- en: 'The process (code: `ch12/rtsigs_waiter.c`) traps the RT signals (with sigaction)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程（代码：`ch12/rtsigs_waiter.c`）捕获RT信号（使用sigaction）
- en: '{`SIGRTMAX-5`, `SIGRTMAX`, `SIGRTMIN+5`} : integer values {59, 64, 39} respectively.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '{`SIGRTMAX-5`，`SIGRTMAX`，`SIGRTMIN+5`}：整数值分别为{59，64，39}。'
- en: 'Then, we have a shell script (`bombard_sigrt.sh`) send these three real time
    signals continually (or for the number requested) in batches of three, in the
    following order:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有一个shell脚本（`bombard_sigrt.sh`）不断地发送这三个实时信号（或者按照请求的次数）以三个一组的方式，顺序如下：
- en: '{`SIGRTMAX-5`, `SIGRTMAX`, `SIGRTMIN+5`} : integer values {59, 64, 39} respectively.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '{`SIGRTMAX-5`，`SIGRTMAX`，`SIGRTMIN+5`}：整数值分别为{59，64，39}。'
- en: The first of the RT signals (# 59) causes the process to enter the signal handler
    routine; recall, we have specified (at the time of `sigaction(2)`) that all signals are
    blocked (masked) while the signal handler code runs.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个RT信号（＃59）导致进程进入信号处理程序例程；回想一下，我们已经在`sigaction(2)`时指定了所有信号在信号处理程序代码运行时都被阻塞（屏蔽）。
- en: We deliberately use our `DELAY_LOOP_SILENT` macro to keep the signal handler
    running for a while.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们故意使用我们的`DELAY_LOOP_SILENT`宏来让信号处理程序运行一段时间。
- en: Accordingly, the RT signals delivered by the script cannot interrupt the handler
    (they are blocked), so the OS queues them up.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，脚本传递的RT信号不能中断处理程序（它们被阻塞），因此操作系统将它们排队。
- en: Once the signal handler completes and returns, the next RT signal in the queue
    is delivered to the process.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦信号处理程序完成并返回，队列中的下一个RT信号将被传递给进程。
- en: 'In priority order, they are delivered least to highest, like so:'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按优先顺序，它们按从最低到最高的顺序交付，就像这样：
- en: '{`SIGRTMIN+5`, `SIGRTMAX-5`, `SIGRTMAX`} : integer values {39, 59, 64}.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '{`SIGRTMIN+5`, `SIGRTMAX-5`, `SIGRTMAX`}：整数值{39, 59, 64}。'
- en: 'The next run verifies this behavior on Linux:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 下一次运行将在Linux上验证这种行为：
- en: We do not show the source code here; to view the complete source code, build
    it, and run it, the entire tree is available for cloning from GitHub here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/ch12/rtsigs_waiter.c](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/ch12/rtsigs_waiter.c) and [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/ch12/bombard_sigrt.sh](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/ch12/bombard_sigrt.sh).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不显示源代码；要查看完整的源代码，构建它并运行它，整个树可在GitHub上克隆：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/ch12/rtsigs_waiter.c](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/ch12/rtsigs_waiter.c)和[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/ch12/bombard_sigrt.sh](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux/blob/master/ch12/bombard_sigrt.sh)。
- en: '[PRE30]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In another Terminal window we run the bombard script:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，我们运行bombard脚本：
- en: '[PRE31]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the original Terminal window where the `rtsigs_waiter` process is running,
    we now see this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在`rtsigs_waiter`进程正在运行的原始终端窗口中，我们现在看到了这个：
- en: '[PRE32]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: The first RT signal sent by the script is the `SIGRTMAX-5` (value 59); hence,
    it enters the signal handler and is processed.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本发送的第一个RT信号是`SIGRTMAX-5`（值59）；因此，它进入信号处理程序并被处理。
- en: While the signal handler is running, all signals are blocked.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当信号处理程序运行时，所有信号都被阻塞。
- en: The script continues to pump out the remaining RT signals (see its output),
    while they are masked.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本继续输出剩余的RT信号（请参见其输出），而它们被屏蔽。
- en: 'Thus, they are queued by the OS and delivered once the handler completes in
    priority order: lowest to highest numbered RT signal, that is, the priority order
    is from `SIGRTMIN` (highest) to `SIGRTMAX` (lowest).'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，它们由操作系统排队，并按优先顺序传递：从`SIGRTMIN`（最高）到`SIGRTMAX`（最低）的编号RT信号的优先顺序是从低到高。
- en: As they are queued, no signals are lost.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它们被排队，没有信号会丢失。
- en: 'Here is a screenshot demonstrating the same, for a larger number of RT signals:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个截图，展示了相同的情况，对于更多数量的RT信号：
- en: '![](img/b0438cda-7ad0-4ffc-95e5-d8f4e4019a1c.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0438cda-7ad0-4ffc-95e5-d8f4e4019a1c.png)'
- en: 'Passing 10 to the script (see the right hand window) has it deliver 3x10: 30
    RT signals in 10 batches of {`SIGRTMIN+5`, `SIGRTMAX-5`, `SIGRTMAX`}). Note, in
    the left hand window, how (except for the first instance of course) they are (queued
    and) processed in priority order, lowest to highest—first, all the 39s {`SIGRTMIN+5`},
    then all the 59s {`SIGRTMAX-5`}, and finally the lowest priority 64s {`SIGRTMAX`}
    RT signals.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将10传递给脚本（请参见右侧窗口）会使其传递3x10：30个RT信号，分为10批次的{`SIGRTMIN+5`, `SIGRTMAX-5`, `SIGRTMAX`}。请注意，在左侧窗口中，除了第一个实例之外，它们（被排队并）按优先顺序处理，从低到高——首先是所有的39（`SIGRTMIN+5`），然后是所有的59（`SIGRTMAX-5`），最后是最低优先级的64（`SIGRTMAX`）RT信号。
- en: The script sends signals to the process by issuing the `kill(1)` command; it will
    be explained in detail later in this chapter.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本通过发出`kill(1)`命令向进程发送信号；这将在本章后面详细解释。
- en: 'To conclude, real time signals are processed as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，实时信号的处理方式如下：
- en: If unblocked, they are processed one after the other in FCFS order.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果解除阻塞，它们将按FCFS顺序依次处理。
- en: If blocked, they are queued and delivered in priority order—the lowest RT signal
    being the highest priority and the the highest RT signal being the lowest priority.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果被阻塞，它们将按优先顺序排队并传递——最低的RT信号具有最高优先级，最高的RT信号具有最低优先级。
- en: As always, you, the reader, are strongly encouraged to check out the code and
    try out these experiments yourself.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，强烈建议您，读者，查看代码并自己尝试这些实验。
- en: Sending signals
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送信号
- en: We have typically seen cases where the kernel sends signals to a process; there
    is no reason a process cannot send a signal (or several) to another process. In
    this section, we delve into the details of sending signals to processes from a
    process, and ideas related to the same.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常看到内核向进程发送信号的情况；没有理由一个进程不能向另一个进程发送信号（或多个）。在本节中，我们将深入探讨从一个进程向另一个进程发送信号以及与此相关的想法的细节。
- en: 'You might wonder, even if you could send a signal to another process, how would
    it be useful? Well, think about it: signal-sending could be used as an **interprocess
    communication** (**IPC**) mechanism, for one. Also, it''s a way of checking for
    a process''s existence! There are other useful cases, such as sending yourself
    a signal. Let''s explore these further.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，即使你可以向另一个进程发送信号，那有什么用呢？嗯，想想看：信号发送可以用作**进程间通信**（**IPC**）机制。此外，这是一种检查进程存在的方法！还有其他有用的情况，比如向自己发送信号。让我们进一步探讨这些情况。
- en: Just kill 'em
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只是杀死它们
- en: 'How do we send a signal to another process: the short answer, via the `kill(2)` system
    call. The kill API can deliver a signal, any signal, to a process given its PID;
    the function signature from the man page on `kill(2)`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何向另一个进程发送信号：简短的答案是通过`kill(2)`系统调用。`kill` API可以向给定PID的进程传递任何信号；来自`kill(2)`手册页的函数签名：
- en: '[PRE33]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note it's very generic—you can send pretty much any signal to any process (it
    might perhaps have been better named as `sendsig`, but, of course, that's not
    as exciting a name as kill).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它非常通用——你几乎可以向任何进程发送任何信号（也许更好的名字可能是`sendsig`，但当然，这并不像`kill`那样令人兴奋）。
- en: The user command `kill(1)` is, of course, a wrapper over the `kill(2)` system
    call.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 用户命令`kill(1)`当然是`kill(2)`系统调用的包装器。
- en: 'Quite obviously, from the previous API, you can infer that the signal `sig` is
    sent to the process that has the PID value pid. Hang on, though, there are several
    special cases to consider as well; see the following table:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，根据前面的API，您可以推断信号`sig`被发送到具有PID值`pid`的进程。不过，请稍等，还有一些特殊情况需要考虑；请参阅以下表格：
- en: '| **kill PID value **  | **Meaning** |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| **kill PID值**  | **含义** |'
- en: '| > 0 | The signal is sent to the process with numeric PID equal to this value
    (the usual case). |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| > 0 | 信号发送给PID等于该值的进程（通常情况）。 |'
- en: '| 0 | The signal is sent to all processes within the process group ¹ of the
    caller. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 信号发送给调用者进程组内的所有进程。 |'
- en: '| -1 | The signal is sent to all processes for which the caller has permission
    to send (see next), except the overall ancestor process, PID 1 (traditionally init,
    nowadays systemd). ² |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| -1 | 信号发送给调用者有权限发送的所有进程，但不包括整体祖先进程PID 1（传统上是init，现在是systemd）。² |'
- en: '| < -1 | The signal is sent to all processes within the process group one having
    ID, pid. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| < -1 | 信号发送给进程组one内具有ID`pid`的所有进程。 |'
- en: '¹ Process group: Every process will be a member of a process group (each pgrp
    will have its own unique ID, equal to the PID of the first member, called the process
    group leader. Use `ps j `to look up process group details; also, the system calls
    `get|set]pgid(2), [get|set]pgrp(2)`, are available.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ¹ 进程组：每个进程都将成为一个进程组的成员（每个pgrp都有自己独特的ID，等于第一个成员的PID，称为进程组领导者。使用`ps j`查找进程组详细信息；还有系统调用`get|set]pgid(2),
    [get|set]pgrp(2)`可用。
- en: 'If you run a chain of processes via pipes (for example, `ps aux |tail |sort
    -k6n`) and, once it''s running, type *^C* on the keyboard, then we understand
    the signal SIGINT is generated via the kernel''s tty layer; but to which process?
    All the processes currently running as part of the preceding pipeline form the foreground
    process group. The significance with regard to signaling: any signals generated
    via the keyboard (such as *^C*, *^\*, *^Z*), is delivered to all processes belonging
    in the foreground process group. (Thus all three will receive the signal. Check
    the *Further reading *section for a link to more information on process groups
    on the GitHub repository.)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过管道运行一系列进程（例如，`ps aux |tail |sort -k6n`），并且在运行时在键盘上输入*^C*，那么我们知道信号SIGINT是通过内核的tty层生成的；但是发送给哪个进程呢？当前作为前置管道一部分运行的所有进程形成了前台进程组。关于信号传递的重要性：通过键盘生成的任何信号（如*^C*、*^\*、*^Z*）都会传递给属于前台进程组的所有进程。（因此所有三个进程都会收到该信号。请查看*更多阅读*部分，了解有关进程组的更多信息的GitHub存储库链接。）
- en: ^(2 )On Linux, `kill(-1, sig)` does not send `sig` to the calling process itself.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，`kill(-1, sig)`不会将`sig`发送给调用进程本身。
- en: Killing yourself with a raise
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用加薪来杀死自己
- en: 'Dramatic as it sounds, here we point out a simple wrapper API: the *raise(3) *library
    call. Here is its signature:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管听起来戏剧性，但这里我们指出一个简单的包装API：*raise(3)*库调用。以下是它的签名：
- en: '[PRE34]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It''s really very simple: given a signal number, the raise API raises, sends,
    the given signal to the calling process (or thread). If the signal in question
    is caught, the raise will return only once the signal handler has completed.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的非常简单：给定一个信号编号，`raise` API会向调用进程（或线程）发送给定的信号。如果所讨论的信号被捕获，`raise`将只在信号处理程序完成后返回一次。
- en: 'Recall that we have used this API in our `handle_segv.c`program earlier in
    this chapter: we used it to ensure that, for the signal SIGSEGV, after our own
    handling is done, we re-raise the same signal on  ourselves, thereby ensuring
    that the core dump occurs.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在本章的早些时候，我们在`handle_segv.c`程序中使用了这个API：我们用它来确保对于信号SIGSEGV，在我们自己的处理完成后，我们重新向自己发送相同的信号，从而确保核心转储发生。
- en: (Well, philosophically, though, there's only so much that getting that raise
    will do for your happiness quotient.)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: （嗯，哲学上来说，获得加薪对您的幸福指数只能起到有限的作用。）
- en: Agent 00 – permission to kill
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 00特工-有权杀人
- en: 'In Ian Fleming''s books, James Bond is a double-oh agent (007): a secret agent
    with permission to kill!'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在伊恩·弗莱明的书中，詹姆斯·邦德是一名双零特工（007）：一名有权杀人的特工！
- en: Well, like Bond, we too can kill; um, a process, of course, that is, send it
    a signal. It's nowhere as dramatic and exciting as Bond, but, hey, we can! Well,
    IFF (if and only if) we have the permission to do so.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，就像邦德一样，我们也可以杀死；嗯，当然是一个进程，也就是发送一个信号。这并不像邦德那样戏剧性和令人兴奋，但是，嘿，我们可以！嗯，当且仅当我们有权限这样做时。
- en: 'The required permission: the sending process must either:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的权限：发送进程必须满足以下条件之一：
- en: Have root privileges—Under the modern capabilities model (recall [Chapter 8](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml),
    *Process Capabilities*), the requirement becomes that a process has the `CAP_KILL`
    capability bit set; from the man page on capabilities(7): CAP_KILL : Bypass permission
    checks for sending signals (see `kill(2)`).
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有root权限-根据现代的能力模型（回想[第8章](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml)，*进程能力*），要求是进程具有`CAP_KILL`能力位设置；来自`capabilities(7)`的man页面：CAP_KILL：绕过发送信号的权限检查（参见`kill(2)`）。
- en: Own the target process, which implies that the sender's EUID (effective UID)
    or RUID (real UID) and the target's EUID or RUID, respectively, should match.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有目标进程，这意味着发送者的EUID（有效UID）或RUID（真实UID）和目标的EUID或RUID应该匹配。
- en: The man page on `kill(2)` specifies in more detail some corner cases on Linux
    regarding permissions to send signals; take a look if interested.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`kill(2)`的man页面在Linux上详细说明了一些关于发送信号权限的特殊情况；如果感兴趣，可以看一下。'
- en: 'So, tempting as it sounds, just performing a loop like (pseudo-code follows) will
    not necessarily work for all processes alive, mostly because of a lack of permissions
    of course:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管听起来很诱人，但只是执行一个循环（伪代码如下）并不一定适用于所有活动进程，主要是因为缺乏权限：
- en: '[PRE35]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Even if you were to run code such as the one shown previously as root, the system
    will disallow abruptly terminating key processes such as systemd (or init). (Why
    not try it—it's a suggested exercise anyway. Of course, trying stuff like this
    is asking for trouble; we suggest you try this a test VM.)
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你以root身份运行类似之前显示的代码，系统也会禁止突然终止关键进程，比如systemd（或init）。（为什么不试试——反正这是一个建议的练习。当然，尝试这样的东西是在自找麻烦；我们建议你在测试虚拟机中尝试。）
- en: Are you there?
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你在吗？
- en: Checking for a process's very existence, is it alive now?, can be crucial to
    an application. For example, an application function receives the PID of a process
    as a parameter. Before it actually does something with the process via the provided
    PID (perhaps send it a signal), it would be a good idea to verify that the process
    is indeed valid (what if it's dead or the PID invalid?).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 检查进程的存在非常重要，现在它还活着吗？对于应用程序来说可能至关重要。例如，应用程序函数接收进程的PID作为参数。在实际使用提供的PID之前（也许发送一个信号），验证一下进程是否有效是个好主意（如果它已经死了或PID无效怎么办？）。
- en: 'The `kill(2)` system call helps us in this regard: the second parameter to kill is
    the signal to send; using the value `0` (recall there is no signal numbered 0)
    validates the first parameter: the PID. How exactly? If the `kill(2)` returns
    failure, either the PID is invalid or we do not have permission to send the process
    (or process group) a signal.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`kill(2)`系统调用在这方面帮助我们：`kill`的第二个参数是要发送的信号；使用值`0`（回想一下没有编号为0的信号）验证第一个参数：PID。具体是如何验证的？如果`kill(2)`返回失败，要么PID无效，要么我们没有权限发送信号给进程（或进程组）。'
- en: 'The following pseudo-code demonstrates this:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下伪代码演示了这一点：
- en: '[PRE36]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Signaling as IPC
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号作为IPC
- en: We learned that a fundamental side effect of the virtual memory architecture
    that modern OSes (such as Linux) use is that a process can only access memory
    within its own **virtual address space** (**VAS**); and that too only the valid
    mapped memory.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，现代操作系统（如Linux）使用的虚拟内存架构的一个基本副作用是，进程只能访问其自己的**虚拟地址空间**（**VAS**）内存；而且只能访问有效映射的内存。
- en: Practically speaking, this implies a process cannot read from or write into
    the VAS of any other process. Yes; but then, how do you communicate with other
    processes? This scenario is critical in many multi-process applications.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这意味着一个进程不能读取或写入任何其他进程的VAS。是的；但是，那么你如何与其他进程通信呢？这种情况在许多多进程应用程序中非常关键。
- en: 'The short answer: IPC mechanisms. The Linux OS has several; here, we make use
    of one of them: signaling.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答：IPC机制。Linux操作系统有几种；在这里，我们使用其中一种：信号。
- en: Crude IPC
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粗糙的IPC
- en: 'Think about it, it''s quite simple: processes A and B are part of a multi-process
    application. Now process A wants to inform process B that it has completed some
    work; upon receiving this information, we expect process B to acknowledge the
    same.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看，这很简单：进程A和B是多进程应用程序的一部分。现在进程A想要通知进程B它已经完成了一些工作；在收到这个信息后，我们期望进程B做出相同的确认。
- en: 'We can devise a simple IPC scheme via signaling as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过信号设计一个简单的IPC方案，如下所示：
- en: Process A is performing its work.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程A正在执行它的工作。
- en: Process B is performing its work (they run in parallel of course).
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程B正在执行它的工作（它们当然是并行运行的）。
- en: Process A reaches a milestone; it informs process B of this by sending it `SIGUSR1`
    (via the `kill(2)`).
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程A达到一个里程碑；它通过发送`SIGUSR1`（通过`kill(2)`）通知进程B。
- en: Having trapped the signal, process B enters its signal handler and verifies
    things as required.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获了信号后，进程B进入其信号处理程序并根据需要验证事物。
- en: It acknowledges the message by sending process A, say, `SIGUSR2` (via the `kill(2)`).
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过发送进程A来确认消息，比如说，`SIGUSR2`（通过`kill(2)`）。
- en: Having trapped the signal, process A enters its signal handler, understands
    that the ack has been received from B, and life continues.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获了信号后，进程A进入其信号处理程序，理解来自B的确认已经收到，生活继续。
- en: (The reader can try this as a small exercise.)
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: （读者可以尝试这个作为一个小练习。）
- en: 'However, we should realize an important detail: IPC implies the ability to
    send data to another process. Above, however, we have not been able to transmit
    or receive any data; just the fact that we can communicate via signals (well,
    you could argue that the signal number itself is data; true, in a limited sense).
    So we think of this as a crude IPC mechanism.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们应该意识到一个重要的细节：IPC意味着能够向另一个进程发送数据。然而，在上面，我们无法传输或接收任何数据；只是我们可以通过信号进行通信的事实（嗯，你可以争论信号编号本身就是数据；在有限的意义上是真的）。因此，我们将这视为一种粗糙的IPC机制。
- en: Better IPC – sending a data item
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好的IPC - 发送数据项
- en: 'This leads us to the next interesting fact: it is possible to send a data quantum—a
    piece  of data—via signals. To see how, let''s revisit the powerful struct `siginfo_t` we
    studied earlier in this chapter. To have the signal handler receive the pointer
    to it, recall that we use the `SA_SIGINFO` flag when calling `sigaction(2)`.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们来到下一个有趣的事实：通过信号是可以发送数据量子——一小段数据——的。要看如何做到这一点，让我们重新审视我们在本章前面学习的强大的`siginfo_t`结构。为了让信号处理程序接收到指针，回想一下我们在调用`sigaction(2)`时使用`SA_SIGINFO`标志。
- en: Recall the fact that, within struct `siginfo_t`, the first three members are
    simple integers, the fourth member is a union of structures, there are seven of
    them—only one of which will get instantiated at runtime; the one that does depends
    on which signal is being handled!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在`struct siginfo_t`中，前三个成员是简单的整数，第四个成员是结构的联合体，有七个——其中只有一个会在运行时实例化；实例化的取决于处理的信号！
- en: 'To help us recall, here''s the initial portion of struct `siginfo_t`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们回忆，这是`siginfo_t`结构的初始部分：
- en: '[PRE37]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Within the union of structures, the structure of interest to us right now is
    the one that deals with real time signals—this one:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构的联合体中，我们现在感兴趣的结构是处理实时信号的结构——这个：
- en: '[PRE38]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So, it''s quite straightforward: if we trap some real time signals and use
    `SA_SIGINFO`, we shall be able to retrieve the pointer to this structure; the
    first two members reveal the PID and RUID of the sending process. That itself
    is valuable information!'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，很简单：如果我们捕获了一些实时信号并使用`SA_SIGINFO`，我们将能够检索到这个结构的指针；前两个成员显示了发送进程的PID和RUID。这本身就是有价值的信息！
- en: 'The third member though, the `sigval_t`, is the key (`in /usr/include/asm-generic/siginfo.h`
    on Ubuntu and `in /usr/include/bits/types/__sigval_t.h` on Fedora):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个成员，`sigval_t`，是关键（在Ubuntu上是`/usr/include/asm-generic/siginfo.h`，在Fedora上是`/usr/include/bits/types/__sigval_t.h`）：
- en: '[PRE39]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Note that the `sigval_t` is itself a union of two members: an integer and a
    pointer! We know that a union can only have one of its members instantiated at
    runtime; so the deal here is: the sender process populates one of the preceding
    members with data and then sends a real time signal to the receiver process. The
    receiver can extract the data quantum sent by appropriately de-referencing the
    preceding union. This way, one is able to send data across processes; the data
    is effectively piggy-backed on a real time signal! Quite cool.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`sigval_t`本身是两个成员的联合：一个整数和一个指针！我们知道联合在运行时只能有一个成员实例化；所以这里的问题是：发送进程用数据填充前面的成员之一，然后向接收进程发送实时信号。接收方可以通过适当地取消引用前面的联合来提取发送的数据量。这样，我们就能够在进程之间发送数据；数据实际上是搭载在实时信号上的！非常酷。
- en: 'But think: we can use only one of the members to piggy-back our data, either
    the integer `int sival_int` or the `void * sival_ptr` pointer. Which should one
    use? It''s instructive to recall what we learned in [Chapter 10](607ad988-406d-4736-90a4-3a318672ab6e.xhtml), *Process
    Creation* on process creation: every address within a process is a virtual address;
    that is, my  virtual address X is likely not pointing to the same physical memory
    as your virtual address X. In other words, attempting to communicate data via
    a pointer, which is after all nothing but a virtual address, might now work as
    well as expected. (If you are unsure about this, might we suggest rereading the *malloc*
    *and* *The fork* sections in [Chapter 10](607ad988-406d-4736-90a4-3a318672ab6e.xhtml),
    *Process Creation*.)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 但是想一想：我们只能使用其中一个成员来携带我们的数据，要么是整数`int sival_int`，要么是`void * sival_ptr`指针。应该使用哪一个？回想一下我们在[第10章](607ad988-406d-4736-90a4-3a318672ab6e.xhtml)中学到的内容是很有启发性的，即进程创建：进程中的每个地址都是虚拟地址；也就是说，我的虚拟地址X可能指向的并不是你的虚拟地址X所指向的相同的物理内存。换句话说，尝试通过指针来传递数据，实际上只是一个虚拟地址，可能不会像预期的那样有效。（如果你对此不确定，我们建议重新阅读[第10章](607ad988-406d-4736-90a4-3a318672ab6e.xhtml)中的*malloc*和*The
    fork*部分，*进程创建*。）
- en: In conclusion, using an integer to hold and communicate data to our peer process
    would usually be a better idea. In fact, C programmers know how to extract, literally,
    every last bit from memory; you can always treat the integer as a bitmask and
    communicate even more information!
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，使用整数来保存和传递数据给我们的对等进程通常是一个更好的主意。事实上，C程序员知道如何从内存中提取每一个比特；你总是可以将整数视为位掩码，并传递更多的信息！
- en: 'Additionally, the C library provides a helper routine to quite easily send
    a signal with data embedded within, the `sigqueue(3)` API. Its signature:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，C库提供了一个辅助例程，可以很容易地发送一个带有嵌入数据的信号，`sigqueue(3)` API。它的签名：
- en: '[PRE40]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The first two parameters are obvious: the process to send the signal `sig`
    to; the third parameter value is the union discussed.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数很明显：要发送信号`sig`的进程；第三个参数`value`是讨论过的联合。
- en: Lets try this out; we write a small producer-consumer type of application. We
    run the consumer process in the background; it polls, waiting for the producer
    to send it some data. (As you might guess, polling is not ideal; in the multithreading
    topics, we shall cover superior methods; for now, we shall just simplistically
    poll.) When the receiver detects data has been sent to it, it displays all relevant
    details.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试；我们编写一个小的生产者-消费者类型的应用程序。我们在后台运行消费者进程；它轮询，等待生产者发送一些数据。（正如你可能猜到的那样，轮询并不理想；在多线程主题中，我们将介绍更好的方法；但现在，我们只是简单地轮询。）当接收者检测到已经发送数据给它时，它会显示所有相关的细节。
- en: 'First, a sample run: to begin, we run the consumer (receiver) process (`ch12/sigq_ipc/sigq_recv.c`) 
    in the background:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个示例运行：首先，我们在后台运行消费者（接收者）进程（`ch12/sigq_ipc/sigq_recv.c`）：
- en: '[PRE41]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we run the producer (`ch12/sigq_ipc/sigq_sender.c`) , sending a data
    item to the consumer:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们运行生产者（`ch12/sigq_ipc/sigq_sender.c`），向消费者发送一个数据项：
- en: '[PRE42]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The consumer processes the signal, understands that data has arrived, and in
    the next polling cycle prints out the details:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者处理信号，理解数据已经到达，并在下一个轮询周期打印出详细信息：
- en: '[PRE43]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For readability, only key parts of the source code are displayed next; to view
    the complete source code, build it and run it, the entire tree is available for cloning
    from GitHub here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，下面只显示了源代码的关键部分；要查看完整的源代码，构建并运行它，整个树都可以从GitHub上克隆：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: 'Here''s the receiver: `ch12/sigq_ipc/sigq_recv.c`: `main()` function:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是接收者：`ch12/sigq_ipc/sigq_recv.c`：`main()`函数：
- en: '[PRE44]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We poll upon the arrival of the real time signal, sleeping in a loop for three
    seconds on each loop iteration; polling is really not the best way to code; for
    now, we just keep things simple and do so (in the [Chapters 14](586f3099-3953-4816-8688-490c9cf2bfd7.xhtml),
    *Multithreading with Pthreads Part I - Essentials* and [Chapter 15](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml),
    *Multithreading with Pthreads Part II - Synchronization*, we shall cover other
    efficient means of synchronizing on a data value).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在实时信号到达时进行轮询，每次循环迭代都在循环中睡眠三秒钟；轮询实际上并不是编码的最佳方式；但现在，我们只是保持简单并这样做（在[第14章](586f3099-3953-4816-8688-490c9cf2bfd7.xhtml)中，*使用Pthreads进行多线程编程第I部分-基础知识*和[第15章](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml)中，*使用Pthreads进行多线程编程第II部分-同步*，我们将介绍其他有效的同步数据值的方法）。
- en: As explained in the section *Sleeping correctly*, we prefer to use our own wrapper
    over `nanosleep(2)`, our `r_sleep()` function, keeping the sleep safe.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在*正确休眠*部分中所解释的，我们更喜欢使用我们自己的包装器而不是`nanosleep(2)`，我们的`r_sleep()`函数，保持休眠安全。
- en: 'In the meantime, a part of the sender code: `ch12/sigq_ipc/sigq_sender.c`: `send_peer()`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，发送者代码的一部分：`ch12/sigq_ipc/sigq_sender.c`：`send_peer()`：
- en: '[PRE45]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This function performs the work of checking that the target process is indeed
    alive, and if so, sending it the real time signal via the useful `sigqueue(3)` library
    API. A key point: we wrap or embed the data to be sent inside the `sigval` union,
    as an integer value.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数执行检查目标进程是否确实存活的工作，如果是的话，通过有用的`sigqueue(3)`库API向其发送实时信号。一个关键点：我们将要发送的数据包装或嵌入到`sigval`联合体中，作为一个整数值。
- en: 'Back to the receiver: when it does receive the real time signal, its designated
    signal handler code, `read_msg()`, runs:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 回到接收者：当它确实接收到实时信号时，它指定的信号处理程序代码`read_msg()`将运行：
- en: '[PRE46]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We update a structure to hold the data (and metadata), allowing us to conveniently
    print it whenever required.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新一个结构来保存数据（和元数据），使我们能够在需要时方便地打印它。
- en: Sidebar – LTTng
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侧边栏 - LTTng
- en: As a very interesting aside, wouldn't it be wonderful if one could actually trace
    the flow of the sender and receiver processes as they execute? Well, Linux provides
    several tools to do precisely this. Among the more sophisticated ones is a software
    called **Linux Tracing Toolkit next generation** (**LTTng**).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个非常有趣的旁注，如果能够实际追踪发送者和接收者进程在执行时的流程，那不是很棒吗？嗯，Linux提供了几种工具来做到这一点。其中比较复杂的是一个名为**Linux
    Tracing Toolkit next generation**（**LTTng**）的软件。
- en: LTTng is really powerful; once set up, it has the ability to trace both kernel
    and user space (although tracing user space involves the application developers
    explicitly instrumenting their code). Well, your author used LTTng to perform
    a trace of the system (kernel-space) while the previous processes ran; LTTng did
    its job, capturing trace data (in a format called CTF).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: LTTng真的很强大；一旦设置好，它就有能力跟踪内核和用户空间（尽管跟踪用户空间需要应用程序开发人员明确地对其代码进行仪器化）。嗯，您的作者使用LTTng来对系统（内核空间）进行跟踪，而前面的进程运行；LTTng完成了它的工作，捕获了跟踪数据（以CTF格式）。
- en: Then, the superb *Trace Compass* GUI application was used to display and interpret
    the trace session in a meaningful manner; the following screenshot shows an example;
    you can see the point at which the sender sent the signal to the receiver process
    via the `sigqueue(3)` library API, which, as you can see, translated to the `rt_sigqueueinfo(2)` system
    call (its entry point inside the kernel shows up as the `syscall_entry_rt_sigqueueinfo`
    event as follows).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用了出色的*Trace Compass* GUI应用程序以有意义的方式显示和解释跟踪会话；以下屏幕截图显示了一个示例；您可以看到发送者通过`sigqueue(3)`库API向接收进程发送信号的时间点，正如您所看到的，这被转换为`rt_sigqueueinfo(2)`系统调用（其在内核中的入口点显示为`syscall_entry_rt_sigqueueinfo`事件）。
- en: 'Next, the receiver process (`sigq_trc_recv` here) received (and then processed)
    the signal:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，接收进程（这里是`sigq_trc_recv`）接收（然后处理）了信号：
- en: '![](img/633873c7-7faa-4f61-9a0b-5ef42fb71bdd.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](img/633873c7-7faa-4f61-9a0b-5ef42fb71bdd.png)'
- en: '(As a fun thing to do: calculate the time delta between the real time signal
    being sent and the signal being received, bookmarked in purple and red color,
    respectively. It''s approximately 300 ms (microseconds).)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: （作为一个有趣的事情：计算发送实时信号和接收信号之间的时间差，分别用紫色和红色标记。大约是300毫秒（微秒）。）
- en: The details of LTTng is not within the scope of this book's coverage; please
    see the *Further reading *section on the GitHub repository.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: LTTng的细节不在本书的范围之内；请参阅GitHub存储库上的*进一步阅读*部分。
- en: 'For completeness, we note the following APIs to send signals as well:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我们还注意到以下发送信号的API：
- en: '`pthread_kill(3)` : an API to send a signal to a particular thread within the
    same process'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pthread_kill(3)`: 一个API，用于向同一进程中的特定线程发送信号'
- en: '`tgkill(2)` : an API to send a signal to a particular thread within a given
    thread group'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tgkill(2)`: 一个API，用于向给定线程组中的特定线程发送信号'
- en: '`tkill(2)` : a deprecated predecessor to tgkill'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tkill(2)`: tgkill的一个已弃用的前身'
- en: Let's ignore these for now; these APIs become more relevant in the context of
    multithreading in later [Chapter 14](586f3099-3953-4816-8688-490c9cf2bfd7.xhtml),
    *Multithreading with Pthreads Part I - Essentials*, in the book.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们暂时忽略这些；这些API在后面的[第14章](586f3099-3953-4816-8688-490c9cf2bfd7.xhtml)中，即本书中的*使用Pthreads进行多线程编程的第一部分
    - 基础知识*中，将在多线程的上下文中变得更加相关。
- en: Alternative signal-handling techniques
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代的信号处理技术
- en: 'So far, in the previous chapter as well as this one on signaling, we have seen
    and learned to use several techniques with regard to asynchronously trapping and
    working with signals. The essential idea is this: the process is busy performing
    its work, running its business logic; a signal suddenly arrives; nevertheless,
    the process must handle it. We saw in quite some detail how one leverages the 
    powerful `sigaction(2)` system call to do so.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在前一章以及这一章关于信号的内容中，我们已经看到并学会了使用几种技术来异步捕获和处理信号。基本思想是：进程正在忙于执行其工作，运行其业务逻辑；突然收到一个信号；尽管如此，进程必须处理它。我们详细地看到了如何利用强大的`sigaction(2)`系统调用来做到这一点。
- en: Now, we look at signal handling in a different manner: synchronously handling
    signals, that is, how to have the process (or thread) wait for (block upon) signals and
    handle them as they arrive.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们以一种不同的方式来看待信号处理：同步处理信号，也就是说，如何让进程（或线程）等待（阻塞）信号并在其到达时处理它们。
- en: The chapters to come on multithreading will provide some use cases of the same.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 即将到来的关于多线程的章节将提供一些相同用例。
- en: Synchronously waiting for signals
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步等待信号
- en: 'At first glance, and the traditional manner in which signaling is taught, it
    appears that as signals are asynchronous in nature, why would one ever attempt
    to synchronously block upon signals delivered? Well, the reality is: performing
    robust signal handling in large projects is a difficult thing to do correctly
    and consistently. A lot of the complexity stems from the issue of signal-async
    safety; we are not allowed to use just any API within a signal handler; only a
    relatively small subset of APIs is considered async-signal-safe and is viable
    to use. This raises significant hurdles in large programs, and of course, at times,
    programmers inadvertently cause defects (bugs) (that too, ones that are difficult
    to catch during testing).'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，以及传统的信号传递方式，似乎信号是异步的，为什么会有人尝试同步阻塞信号的传递呢？事实上：在大型项目中执行健壮的信号处理是一件难以正确和一致地做到的事情。许多复杂性源于信号异步安全问题；我们不允许在信号处理程序中使用任何API；只有相对较小的API子集被认为是异步信号安全的，并且可以使用。这在大型程序中带来了重大障碍，当然，有时程序员会无意中引起缺陷（错误）（而且，这些缺陷在测试期间很难捕捉到）。
- en: These signal-handling difficulties pretty much vanish when one eliminates the
    whole asynchronous signal handler with signal-safety requirements design. How?
    By synchronously blocking upon signals and, when the signal(s) arrive, handling
    them then and there.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 当消除具有信号安全要求设计的整个异步信号处理程序时，这些信号处理困难几乎消失了。如何做到？通过对信号进行同步阻塞，当信号到达时，立即处理它们。
- en: Thus, the goal in this section is to teach the budding systems programmer these
    important concepts (and their APIs); learning to use these can significantly decrease
    oddities and bugs.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本节的目标是教会初学的系统程序员这些重要的概念（以及它们的API）；学会使用这些API可以显著减少异常和错误。
- en: A number of useful mechanisms exist on the Linux OS to perform synchronous signal
    handling; let's start with the simple yet useful `pause(2)` system call.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux操作系统上存在许多有用的机制来执行同步信号处理；让我们从简单但有用的`pause(2)`系统调用开始。
- en: Pause, please
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请暂停
- en: 'The pause is a very good example of a blocking call; when a process calls this
    API, it blocks, that is, it goes to sleep waiting for an event; the event: the
    arrival of any signal to it. The moment a signal arrives, the pause is unblocked
    and execution continues. Of course, delivery of a fatal signal will cause the
    unsuspecting process to die:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`pause`是一个非常好的阻塞调用的例子；当进程调用此API时，它会阻塞，也就是说，它会进入睡眠状态等待事件的发生；事件：任何信号到达。一旦信号到达，`pause`就会解除阻塞，执行继续。当然，传递致命信号将导致毫无防备的进程死亡：'
- en: '[PRE47]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Throughout, we have said that checking system calls for their failure case
    `-1` is considered very important: a best practice to always follow. The `pause(2)`
    throws up an interesting exception case: it seems to be the one system call that always
    returns `-1 `and errno is set to the value `EINTR` Interrupted system call (the
    interruption being the signal of course).'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，我们一直强调检查系统调用的失败情况`-1`是非常重要的：这是一种始终要遵循的最佳实践。`pause(2)`提出了一个有趣的异常情况：它似乎是唯一一个始终返回`-1`并且将`errno`设置为值`EINTR`的系统调用（中断当然是信号）。
- en: 'For this reason, we often code the pause as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们经常将`pause`编码如下：
- en: '[PRE48]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The typecast to `void` is to inform tools such as the compiler and static analyzers
    that we don't really care about the return value from pause.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 将类型转换为`void`是为了通知编译器和静态分析器等工具，我们并不真的关心来自`pause`的返回值。
- en: Waiting forever or until a signal arrives
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 永远等待或直到收到信号
- en: 'Often, one would like to wait forever, or until a signal arrives. One way to
    do so is the very simple, but very bad, terribly expensive spin on the CPU code
    such as this:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，人们希望永远等待，或者直到收到信号。一种方法是非常简单但非常糟糕的，非常昂贵的在CPU上旋转的代码，比如：
- en: '[PRE49]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Ugh! That''s just ugly: please do not write code like that!'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 天啊！那太丑陋了：请不要编写这样的代码！
- en: 'Slightly better, but still quite off, is this:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 略微好一些，但仍然相当偏离的是：
- en: '[PRE50]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The pause can be used to effectively and efficiently set up a useful wait forever
    or until I receive any signal semantic, as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`pause`可以有效且高效地设置一个有用的永远等待或直到我收到任何信号的语义，如下所示：'
- en: '[PRE51]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This semantic is very useful for this wait forever or until I receive any signal situation,
    as it's inexpensive (hardly any CPU usage as the `pause(2)` has the caller immediately
    go to sleep), and get unblocked only when a signal arrives. Then, the whole scenario
    repeats (due to the infinite loop of course).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语义对于这种永远等待或直到我收到任何信号的情况非常有用，因为它很廉价（几乎没有CPU使用率，因为`pause(2)`会立即使调用者进入睡眠状态），并且只有在信号到达时才解除阻塞。然后，整个情景重复（当然是由于无限循环）。
- en: Synchronously blocking for signals via the sigwait* APIs
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过`sigwait*`API同步阻塞信号
- en: 'Next, we briefly visit a set of related functions, the sigwait* APIs; they
    are as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们简要介绍一组相关函数，即`sigwait*`API；它们如下：
- en: '`sigwait(3)`'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sigwait(3)`'
- en: '`sigwaitinfo(2)`'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sigwaitinfo(2)`'
- en: '`sigtimedwait(2)`'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sigtimedwait(2)`'
- en: All of these APIs allow a process (or thread) to block (wait) upon the delivery
    of one or more signal.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些API都允许进程（或线程）在收到一个或多个信号时阻塞（等待）。
- en: The sigwait library API
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sigwait库API
- en: 'Let''s start with the `sigwait(3)`:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`sigwait(3)`开始：
- en: '[PRE52]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `sigwait(3)` library API allows a process (or thread) to block, wait, until
    any  signal in the signal-set `set` is pending delivery to it. The moment a signal
    arrives, the `sigwait `is unblocked; the particular signal that arrived, its integer
    value, is placed in the value-result second parameter `sig`. Under the hood, the sigwait removes
    the signal just delivered from the process (or thread) pending mask.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`sigwait(3)`库API允许进程（或线程）阻塞，等待，直到信号集`set`中的任何信号待传递给它。一旦信号到达，`sigwait`就会解除阻塞；到达的特定信号及其整数值将放置在值-结果的第二个参数`sig`中。在底层，`sigwait`从进程（或线程）的挂起掩码中删除刚刚传递的信号。'
- en: 'Thus, the `sigwait(3)` is advantageous to the `pause(2)` by virtue of the following:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`sigwait(3)`相对于`pause(2)`具有以下优势：
- en: You can wait upon the delivery of particular signals to the process
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以等待将特定信号传递给进程
- en: When one of those signals is delivered, its value is known
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当其中一个信号被传递时，它的值是已知的
- en: The return value from `sigwait(3)` is `0` on success and a positive value on
    error (note that it being a library API, errno remains unaffected). (Internally,
    the `sigwait(3)` is implemented via the `sigtimedwait(2)` API.)
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`sigwait(3)`的返回值在成功时为`0`，在错误时为正值（请注意，它是一个库API，`errno`不受影响）。 （在内部，`sigwait(3)`是通过`sigtimedwait(2)`
    API实现的。）'
- en: 'However, things are not always as simple as they appear at first glance. The
    reality is that there are a couple of important points to consider:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事情并不总是像乍一看那么简单。事实是有一些重要的要点需要考虑：
- en: A risky situation called a race can be set up if the signals one intends waiting
    upon are not first blocked by the calling process. (Technically, this is as there
    is a window of opportunity between a signal being delivered to the process and
    the sigwait call initializing). Once running, though, the sigwait will atomically unblock the
    signals, allowing them to be delivered upon the caller process.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果等待的信号没有被调用进程首先阻塞，就会设置一个风险情况，称为竞争。（从技术上讲，这是因为在信号传递到进程和`sigwait`调用初始化之间存在一个机会窗口）。一旦运行，`sigwait`将原子地解除信号阻塞，允许它们被传递给调用进程。
- en: 'What if a signal (one within the signal set we define), is also trapped (caught)
    via either the `sigaction(2)` or `signal(2)` API, AND via the `sigwait(3)` API?
    In such a scenario, the POSIX standard states that it is up to the implementation
    to decide how to handle the delivered signal; Linux seems  to favor handling the
    signal via the `sigwait(3)`. (This makes sense: if a process  issues the sigwait API,
    the process blocks on signals. If a signal does become pending (meaning, it has
    just been delivered) on the process, then the sigwait API sucks in or consumes
    the signal: it is now no longer pending delivery on the process, and thus cannot
    be caught via signal handlers set up via the `sigaction(2)` or `signal(3)` APIs.)'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个信号（在我们定义的信号集中）也通过`sigaction(2)`或`signal(2)` API以及`sigwait(3)` API被捕获，那么在这种情况下，POSIX标准规定由实现决定如何处理传递的信号；Linux似乎更倾向于通过`sigwait(3)`处理信号。（这是有道理的：如果一个进程发出`sigwait`
    API，该进程会阻塞信号。如果信号变为挂起状态（意味着它刚刚被传递到进程），则`sigwait` API会吸收或消耗信号：它现在不再挂起传递到进程，因此不能通过`sigaction(2)`或`signal(3)`
    API设置的信号处理程序捕获。）
- en: 'To test this, we write a small application `ch12/sigwt/sigwt.c` as well as
    a shell script `ch12/sigwt/bombard.sh` to shower all signals upon it. (The reader
    will find the code within the book''s GitHub repository, as always; this time,
    we leave it as an exercise to the reader to study the source, and experiment with
    it.) A couple of sample runs follow:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这一点，我们编写了一个小应用程序`ch12/sigwt/sigwt.c`以及一个shell脚本`ch12/sigwt/bombard.sh`来对其进行所有信号的轰炸。（读者将像往常一样在书的GitHub存储库中找到代码；这次，我们留给读者来研究源代码并进行实验。）以下是一些示例运行：
- en: 'In one Terminal window, we run our `sigwt`program as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个终端窗口中，我们按以下方式运行我们的`sigwt`程序：
- en: '[PRE53]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note how we have first blocked all signals (via the `sigprocmask(2)`; we invoke
    our generic  `common.c:show_blocked_signals()` function to display all currently
    blocked signals in the process signal mask; as expected, all are blocked, with
    the obvious exception of signal numbers 9, 19, 32, and 33 (why?)). Recall that,
    once running, the `sigwait(3)` will atomically unblock the signals, allowing them
    to be delivered upon the caller.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们首先通过`sigprocmask(2)`阻塞了所有信号；我们调用我们的通用`common.c:show_blocked_signals()`函数来显示进程信号掩码中当前阻塞的所有信号；如预期的那样，所有信号都被阻塞，除了明显的9、19、32和33号信号（为什么？）。请记住，一旦运行，`sigwait(3)`将原子地解除信号阻塞，允许它们被传递给调用者。
- en: 'In another Terminal window, run the shell script; the script''s job is simple:
    it sends (via `kill(1)`) every signal—from 1 to 64, except for `SIGKILL (9)`,
    `SIGSTOP (19)`, 32, and 33—the two RT signals reserved for use by the pthreads
    framework:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，运行shell脚本；脚本的工作很简单：它发送（通过`kill(1)`）从1到64的每个信号，除了`SIGKILL（9）`、`SIGSTOP（19）`、32和33——这两个RT信号保留供pthread框架使用：
- en: '[PRE54]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the original window, we observe the output:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始窗口中，我们观察到输出：
- en: '[PRE55]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: All delivered signals were processed via the sigwait! Including the SIGFPE (#
    8) and the SIGSEGV (# 11). This is as they were synchronously sent by another
    process (the shell script) and not by the kernel.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 所有传递的信号都通过`sigwait`进行了处理！包括`SIGFPE`（＃8）和`SIGSEGV`（＃11）。这是因为它们是由另一个进程（shell脚本）同步发送的，而不是由内核发送的。
- en: 'A quick `pkill(1)` kills off the sigwt process (as if one needs reminding:
    SIGKILL and SIGSTOP cannot be masked):'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 快速的`pkill(1)`会终止`sigwt`进程（如果需要提醒：SIGKILL和SIGSTOP不能被屏蔽）：
- en: '[PRE56]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now for the next test case, running it with option `1`:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行下一个测试案例，使用选项`1`运行它：
- en: '[PRE57]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note how signal numbers 8 (`SIGFPE`) and 11 (`SIGSEGV`) are not among the rest
    that are now blocked (besides the usual suspects, 9, 19, 32, 33). Recall that,
    once running, the `sigwait(3)` will atomically unblock the signals, allowing them
    to be delivered upon the caller.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 注意信号编号8（`SIGFPE`）和11（`SIGSEGV`）现在被阻塞，而其他信号都不被阻塞（除了通常的9、19、32、33）。请记住，一旦运行，`sigwait(3)`将原子地解除信号阻塞，允许它们被传递给调用者。
- en: 'In another Terminal window, run the shell script:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，运行shell脚本：
- en: '[PRE58]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the original window, we observe the output:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始窗口中，我们观察到输出：
- en: '[PRE59]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As we trapped the `SIGFPE` (via `sigaction(2)`), it was handled; however, the
    uncaught `SIGSEGV` of course causes the process to die abnormally. Not very pleasant
    at all.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们捕获`SIGFPE`（通过`sigaction(2)`）时，它被处理；然而，未捕获的`SIGSEGV`当然会导致进程异常死亡。一点也不愉快。
- en: 'A little tinkering with the code reveals an interesting aspect; the original
    code snippet is this:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 对代码进行一些小的调整揭示了一个有趣的方面；原始代码片段如下：
- en: '[PRE60]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'What if we effectively block the `SIGSEGV` by changing the preceding `#if 1`
    to `#if 0`? Let''s do so, rebuild, and retry:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过将前面的`#if 1`更改为`#if 0`来有效地阻止`SIGSEGV`会发生什么？让我们这样做，重新构建并重试：
- en: '[PRE61]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This time the SIGSEGV is processed via the sigwait! Yes, indeed; but only because
    it was artificially generated by a process, and not sent by the OS.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这次`SIGSEGV`通过`sigwait`进行了处理！确实；但只是因为它是由进程人为生成的，而不是由操作系统发送的。
- en: 'So, as usual, there''s more to it: how exactly signal handling happens is determined
    by the following:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，像往常一样，还有更多内容：信号处理的具体方式由以下因素决定：
- en: Whether or not the process blocks the signal prior to calling sigmask (or variants)
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用`sigmask`（或其变体）之前，进程是否阻塞信号
- en: 'With regard to fatal signals (such as `SIGILL`, `SIGFPE`, `SIGSEGV`, `SIGBUS`,
    and so on), how the  signal is generated matters: artificially, via just a process
    (`kill(2)`) or actually generated via the kernel (due to a bug of some sort)'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于致命信号（如`SIGILL`，`SIGFPE`，`SIGSEGV`，`SIGBUS`等），信号是如何生成的很重要：人为地，通过进程（`kill(2)`）或实际由内核生成（由于某种错误）
- en: 'We find the following:'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们发现以下内容：
- en: If the signal is blocked by the process before invoking the sigwait, then, if
    the signal is delivered artificially via `kill(2)` (or variants), the `sigwait` will
    get unblocked upon delivery of the signal and the application developer can handle
    the signal.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果信号在调用`sigwait`之前被进程阻塞，那么如果信号是通过`kill(2)`（或变体）人为地传递的，`sigwait`将在信号传递时解除阻塞，应用程序开发人员可以处理该信号。
- en: However, if the fatal signal is delivered via the OS due to a bug, then, whether
    or not the process blocks it, the default action takes place, abruptly (and disgracefully)
    killing the process! This is probably not what one wants; thus, we conclude that
    it's better to trap fatal signals like the preceding via the usual asynchronous
    `sigaction(2)` style and not via the sigwait (or variants thereof).
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，如果致命信号是由于内核的错误而通过操作系统传递的，那么无论进程是否阻塞它，都会发生默认操作，突然（和可耻地）终止进程！这可能不是人们想要的；因此，我们得出结论，最好通过通常的异步`sigaction(2)`风格而不是通过`sigwait`（或其变体）来捕获前述的致命信号。
- en: The sigwaitinfo and the sigtimedwait system calls
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`sigwaitinfo`和`sigtimedwait`系统调用'
- en: 'The `sigwaitinfo(2)` system call is similar to sigwait: provided with a set
    of signals to watch out for, the function puts the caller to sleep until any one
    of those signals (in set) are pending. Here are their prototypes:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`sigwaitinfo(2)`系统调用类似于sigwait：提供一组要注意的信号，该函数将调用者置于休眠状态，直到其中任何一个信号（在集合中）挂起。这是它们的原型：'
- en: '[PRE62]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In terms of a return, the sigwait API was able to provide us with the signal
    number of the signal that got delivered to the calling process. However, recall
    that there is a much more powerful feature of the `sigaction(2)` API—the ability
    to return valuable diagnostic and other information within the `siginfo_t` data
    structure. Well, that's precisely what the `sigwaitinfo(2)` system call provides!
    (We covered the `siginfo_t` structure and what you can interpret from it earlier
    in the section detailing information with the `SA_SIGINFO`.)
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 就返回而言，`sigwait` API能够为我们提供传递给调用进程的信号编号。但是，请记住，`sigaction(2)` API的一个更强大的特性是——能够在`siginfo_t`数据结构中返回有价值的诊断和其他信息。这正是`sigwaitinfo(2)`系统调用提供的功能！（我们在详细介绍`SA_SIGINFO`的信息部分中已经介绍了`siginfo_t`结构以及您可以从中解释的内容。）
- en: 'And the `sigtimedwait(2)`? Well, it''s quite apparent; it''s identical to the `sigwaitinfo(2)` API,
    except that there is an additional parameter—a timeout value. Hence, the function
    will block the caller either until one of the signals in set is pending, or the
    timeout expires (whichever occurs first). The timeout is specified via a simple `timespec` structure,
    which allows one to provide the time in seconds and nanoseconds:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`sigtimedwait(2)`呢？嗯，很明显；它与`sigwaitinfo(2)` API相同，只是多了一个参数——超时值。因此，该函数将阻塞调用者，直到集合中的一个信号挂起，或超时到期（以先发生者为准）。超时是通过一个简单的`timespec`结构指定的，它允许提供秒和纳秒的时间：'
- en: '[PRE63]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If the structure is memset to zero, the `sigtimedwait(2)` returns immediately,
    either with information returned about a signal that was pending, or an error
    value. Both the `sigwaitinfo(2)` and the `sigtimedwait(2)` APIs return the actual
    signal number on success and `-1` on failure, with `errno` set appropriately.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结构被memset为零，`sigtimedwait(2)`将立即返回，要么返回有关挂起信号的信息，要么返回错误值。`sigwaitinfo(2)`和`sigtimedwait(2)`
    API在成功时返回实际的信号编号，失败时返回-1，并适当设置`errno`。
- en: 'An important point to note (it has been mentioned previously, but it''s key):
    neither the `sigwait`, `sigwaitinfo`, or `sigtimedwait` APIs can wait for synchronously
    generated signals from the kernel; typically the ones that indicate a failure
    of some sort, like the `SIGFPE` and the `SIGSEGV`. These can only be caught in
    the normal asynchronous fashion—via `signal(2)` or `sigaction(2)`. For such cases,
    as we have repeatedly shown, the` sigaction(2)` system callwould be the superior
    choice.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的要点（之前已经提到过，但很关键）：`sigwait`、`sigwaitinfo`或`sigtimedwait` API都不能等待内核同步生成的信号；通常是指示某种失败的信号，如`SIGFPE`和`SIGSEGV`。这些只能以正常的异步方式捕获——通过`signal(2)`或`sigaction(2)`。对于这种情况，正如我们反复展示的那样，`sigaction(2)`系统调用将是更好的选择。
- en: The signalfd(2) API
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`signalfd(2)` API'
- en: 'The reader will recall that, in [Chapter 1](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml),
    *Linux System Architecture*, in the section entitled, *The Unix philosophy in
    a nutshell*, we drove home the point that a cornerstone of the Unix philosophy
    is this:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 读者会回忆起，在[第1章](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml)中，*Linux系统架构*，在标题为*Unix哲学的要点*的部分中，我们强调了Unix哲学的一个基石是：
- en: On Unix, everything is a process; if it's not a process, it's a file.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix上，一切都是一个进程；如果不是进程，就是一个文件。
- en: Experienced Unix and Linux developers are very used to the idea (abstraction,
    really) of treating stuff as if it were a file; this includes devices, pipes,
    and sockets. Why not signals?
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富的Unix和Linux开发人员非常习惯将东西抽象为文件的概念；这包括设备、管道和套接字。为什么不包括信号呢？
- en: That's precisely the idea behind the `signalfd(2)` system call; with `signalfd`,
    you can create a file descriptor and associate it with a signal set. Now, the
    application programmer is free to monitor signals using a variety of familiar
    file-based APIs—among them the `read(2)`, `select(2)` and `poll(2)` (and its variations),
    and the `close(2)`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是`signalfd(2)`系统调用的理念；使用`signalfd`，您可以创建一个文件描述符并将其与信号集关联起来。现在，应用程序员可以自由地使用各种熟悉的基于文件的API来监视信号
    - 其中包括`read(2)`、`select(2)`和`poll(2)`（及其变体），以及`close(2)`。
- en: Also, similar to the `sigwait*` family of APIs we covered, `signalfd` is another
    way to have a process (or thread) synchronously block upon signals.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们讨论过的`sigwait*`API系列类似，`signalfd`是另一种让进程（或线程）同步阻塞信号的方法。
- en: 'How do you make use of the `signalfd(2)` API? Its signature is as follows:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何使用`signalfd(2)` API？它的签名如下：
- en: '[PRE64]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The first parameter, `fd`, is either an existing signal descriptor, or the value
    -1\. When -1 is passed, the system call creates a new signal file descriptor (we
    should obviously call it in this manner at first). The second parameter mask is
    the signal `mask`—the set of signals that this signal descriptor will be associated
    with. As before with the sigwait* APIs, one is expected to block these signals
    (via the `sigprocmask(2)`).
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`fd`，要么是现有的信号描述符，要么是值-1。当传递-1时，系统调用会创建一个新的信号文件描述符（显然，我们应该首先以这种方式调用它）。第二个参数`mask`是信号`mask`
    - 这个信号描述符将与之关联的信号集。与`sigwait*`API一样，人们期望通过`sigprocmask(2)`来阻止这些信号。
- en: It's important to understand that the `signalfd(2)` system call, by itself,
    is not a blocking call. The blocking behavior comes into play only on invocation
    of a file-related API, such as `read(2)`, `select(2)`, or `poll(2)`. Only then
    is the caller put into a sleep state. The moment one of the signals in the set
    is delivered to the calling process (or is already pending on it), the file-related API returns.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，`signalfd(2)`系统调用本身不是一个阻塞调用。阻塞行为只有在调用与文件相关的API时才会发生，比如`read(2)`、`select(2)`或`poll(2)`。只有在信号集中的一个信号被传递给调用进程（或者已经挂起在它上面）时，文件相关的API才会返回。
- en: 'The third parameter to `signalfd(2)` is a `flags` value—a means to change the
    default behavior. It''s only from Linux kernel version 2.6.27 onwards that the flags work
    well; the possible values are as follows:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`signalfd(2)`的第三个参数是一个`flags`值 - 一种改变默认行为的方式。只有从Linux内核版本2.6.27开始，`flags`才能正常工作；可能的值如下：'
- en: '`SFD_NONBLOCK` : use non-blocking I/O semantics on the signal descriptor (equivalent
    to the `fcntl(2)` `O_NONBLOCK`).'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SFD_NONBLOCK`：在信号描述符上使用非阻塞I/O语义（相当于`fcntl(2)`的`O_NONBLOCK`）。'
- en: '`SFD_CLOEXEC` : if the process ever execs another process (via the exec family
    APIs), ensure that the signal descriptor is closed (this is good for security
    as otherwise, all the predecessor process'' open files are inherited across the
    exec operation to the successor; equivalent to the `open(2)` `FD_CLOEXEC`).'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SFD_CLOEXEC`：如果进程通过`exec`系列APIs执行另一个进程，确保关闭信号描述符（这对安全性很重要，否则，所有前任进程的打开文件都会在执行操作中继承到后继进程；相当于`open(2)`的`FD_CLOEXEC`）。'
- en: In terms of return value, the `signalfd(2)` API returns the newly created signal
    descriptor on success; of course, this is if the first parameter was -1\. If not,
    then it should be an already existing signal descriptor; then, this value is returned
    on success. On failure, as usual, `-1` is returned and the `errno` variable reflects
    the diagnostic.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 就返回值而言，`signalfd(2)` API在成功时返回新创建的信号描述符；当然，如果第一个参数是-1的话。如果不是，那么它应该是一个已经存在的信号描述符；然后，成功时返回这个值。失败时，像往常一样，返回-1，并且`errno`变量反映了诊断信息。
- en: Here, we shall limit the discussion of using the `signalfd(2)` to reading signal
    information via the familiar `read(2)` system call; this time, on the signal descriptor
    returned by the `signalfd` API.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将限制使用`signalfd(2)`来通过熟悉的`read(2)`系统调用读取信号信息的讨论；这次是在`signalfd`API返回的信号描述符上。
- en: 'The way the `read(2)` works in a nutshell (`read(2)` was covered in detail
    in [Appendix A](https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf),
    *File I/O Essentials*): we specify a file (in this case, signal) descriptor to
    read from as the first parameter, the buffer to place the just-read data as the
    second parameter, and the maximum number of bytes to read as the third parameter:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`read(2)`的工作原理简而言之（`read(2)`在[附录A](https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf)中有详细介绍，*文件I/O基础*）：我们将要读取的文件（在本例中是信号）描述符作为第一个参数，刚读取的数据的缓冲区作为第二个参数，要读取的最大字节数作为第三个参数：'
- en: '[PRE65]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: These are the common typdefs:`size_t` is essentially an unsigned long (integer)
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是常见的`typedefs`：`size_t`本质上是一个无符号长整型
- en: '`ssize_t` is essentially a signed long (integer)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '`ssize_t`本质上是一个有符号长整型'
- en: 'The second parameter here is special: a pointer to (one or more) structures
    of type `signalfd_siginfo`. The struct `signalfd_siginfo` is quite analogous to
    the `siginfo_t` we saw in some detail in the earlier section, *The siginfo_t structure*.
    Detailed information regarding the signal that arrived will be populated here.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第二个参数很特别：指向一个或多个`signalfd_siginfo`类型的结构的指针。`struct signalfd_siginfo`与我们在前面的*siginfo_t结构*部分中详细介绍的`siginfo_t`非常类似。有关到达的信号的详细信息将在这里填充。
- en: We leave it to the interested reader to glean the details of the `signalfd_siginfo`
    data structure from the man page on `signalfd(2)` here: [https://linux.die.net/man/2/signalfd](https://linux.die.net/man/2/signalfd). The
    page also contains a small example program.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有兴趣的读者从`signalfd(2)`的man页面中获取`signalfd_siginfo`数据结构的详细信息：[https://linux.die.net/man/2/signalfd](https://linux.die.net/man/2/signalfd)。该页面还包含一个小的示例程序。
- en: The third parameter to read, the size, must in this case be at least sizeof(`signalfd_siginfo`) bytes.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: read的第三个参数，大小，在这种情况下必须至少是sizeof(`signalfd_siginfo`)字节。
- en: Summary
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, the reader has been taken through some advanced details with
    regard to signaling: how to handle crashing processes via appropriate fatal signal
    trapping, and once in the handler, getting key details including CPU registers,
    and so on. This was done by learning to interpret the powerful `siginfo_t` data
    structure. Further, handling races when working with the `errno` variable, and
    learning how to sleep correctly was covered.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，读者已经了解了一些关于信号的高级细节：如何通过适当的致命信号捕获来处理崩溃进程，以及在处理程序中获取关键细节，包括CPU寄存器等。通过学习解释强大的`siginfo_t`数据结构来实现这一点。此外，还涵盖了处理`errno`变量时的竞争情况，以及学习如何正确休眠。
- en: Real time signals and their differences from regular Unix signals was covered;
    then, there was a section regarding the different means of sending signals to
    other processes. Finally, we looked at signal handling by synchronously blocking
    upon a given set of signals (using various APIs).
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 实时信号及其与常规Unix信号的区别已经涵盖；然后，有关向其他进程发送信号的不同方式的部分。最后，我们看了一下通过同步阻塞一组信号来处理信号（使用各种API）。
- en: In the next [Chapter 13](1f621f72-e067-42db-b2eb-b82e20161dec.xhtml), *Timers*,we
    shall make use of the knowledge we gained here (and in the preceding) [Chapter
    11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml), *Signaling - Part I*, and learn
    how to set up and use timers effectively.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章[第13章](1f621f72-e067-42db-b2eb-b82e20161dec.xhtml) *定时器*中，我们将利用我们在这里（以及前一章[第11章](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml)
    *信号-第一部分*中获得的知识，并学习如何有效地设置和使用定时器。
