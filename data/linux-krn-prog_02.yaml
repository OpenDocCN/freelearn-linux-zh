- en: Kernel Workspace Setup
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 内核工作区设置
- en: Hello, and welcome to this book on learning Linux kernel development. To get
    the most out of this book, it is very important that you first set up the workspace
    environment that we will be using throughout the book. This chapter will teach
    you exactly how to do this and get started.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你好，欢迎来到这本关于学习Linux内核开发的书。为了充分利用本书，非常重要的是您首先设置我们将在整本书中使用的工作区环境。本章将教您如何做到这一点并开始。
- en: We will install a recent Linux distribution, preferably as a **Virtual Machine**
    (**VM**), and set it up to include all the required software packages. We will
    also clone this book's code repository on GitHub, and learn about a few useful
    projects that will help along this journey.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装最新的Linux发行版，最好作为**虚拟机**（**VM**），并设置它以包括所有必需的软件包。我们还将在GitHub上克隆本书的代码库，并了解一些有用的项目，这些项目将在这个过程中帮助我们。
- en: The best way to learn something is to do so *empirically –* not taking anyone's
    word on anything at all, but trying it out and experiencing it for yourself. Hence,
    this book gives you many hands-on experiments and kernel code examples that you
    can and indeed must try out yourself; this will greatly aid in your making real
    progress and deeply learning and understanding various aspects of Linux kernel
    and driver development. So, let's begin!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 学习某事的最佳方法是*经验主义*-不要完全相信任何人的话，而是尝试并亲身体验。因此，本书为您提供了许多实践实验和内核代码示例，您可以并且必须自己尝试；这将极大地帮助您取得实质性进展，深入学习和理解Linux内核和驱动程序开发的各个方面。所以，让我们开始吧！
- en: 'This chapter will take us through the following topics, which will help us
    set up our environment:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带领我们通过以下主题，帮助我们设置我们的环境：
- en: Running Linux as a guest VM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为客户VM运行Linux
- en: Setting up the software – distribution and packages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置软件-分发和软件包
- en: A few additional useful projects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些额外有用的项目
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need a modern desktop PC or laptop. Ubuntu Desktop specifies the following
    as "recommended system requirements" for the installation and usage of the distribution:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一台现代台式机或笔记本电脑。Ubuntu桌面指定了以下作为“推荐系统要求”的分发安装和使用：
- en: A 2 GHz dual core processor or better.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 GHz双核处理器或更好。
- en: 'RAM:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存：
- en: 'Running on physical host: 2 GB or more system memory (more will certainly help).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在物理主机上运行：2 GB或更多系统内存（更多肯定会有所帮助）。
- en: 'Running as a guest VM: The host system should have at least 4 GB RAM (the more
    the better and the smoother the experience).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为客户VM运行：主机系统应至少有4 GB RAM（内存越多越好，体验越流畅）。
- en: 25 GB of free hard drive space (I suggest more, at least double this).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 25 GB的可用硬盘空间（我建议更多，至少是这个的两倍）。
- en: Either a DVD drive or a USB port for the installer media (not required when
    setting up Ubuntu as a guest VM).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装介质的DVD驱动器或USB端口（在设置Ubuntu作为客户VM时不需要）。
- en: Internet access is definitely helpful and required at times.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网访问绝对是有帮助的，有时是必需的。
- en: As performing tasks such as building a Linux kernel from source is a very memory-
    and CPU-intensive process, I highly recommend that you try it out on a powerful
    Linux system with plenty of RAM and disk space to spare as well. It should be
    pretty obvious – the more RAM and CPU power the host system has, the better!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从源代码构建Linux内核等任务是一个非常消耗内存和CPU的过程，我强烈建议您在具有充足内存和磁盘空间的强大Linux系统上尝试。很明显-主机系统的RAM和CPU功率越大，越好！
- en: Like any seasoned kernel contributor, I would say that working on a native Linux
    system is best. However, for the purposes of this book, we cannot assume that
    you will always have a dedicated native Linux box available to you. So, we will
    assume that you are working on a Linux guest. Working within a guest VM also adds
    an additional layer of isolation and thus safety.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何经验丰富的内核贡献者一样，我会说在本地Linux系统上工作是最好的。但是，出于本书的目的，我们不能假设您总是有一个专用的本地Linux框可供使用。因此，我们将假设您正在使用Linux客户端。在客户VM中工作还增加了一个额外的隔离层，因此更安全。
- en: '**Cloning our code repository**: The complete source code for this book is
    freely available on GitHub at [https://github.com/PacktPublishing/Linux-Kernel-Programming](https://github.com/PacktPublishing/Learn-Linux-Kernel-Development)*.* You
    can clone and work on it by cloning the `git` tree, like so:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**克隆我们的代码库**：本书的完整源代码可以在GitHub上免费获取，网址为[https://github.com/PacktPublishing/Linux-Kernel-Programming](https://github.com/PacktPublishing/Learn-Linux-Kernel-Development)*.*
    您可以通过克隆`git`树来克隆并使用它。'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The source code is organized chapter-wise. Each chapter is represented as a
    directory – for example, `ch1/` has the source code for this chapter. The root
    of the source tree has some code that is common to all chapters, such as the source
    files `convenient.h`, `klib_llkd.c`, as well as others.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码按章节组织。每个章节都表示为一个目录-例如，`ch1/`包含本章的源代码。源树的根目录有一些对所有章节都通用的代码，比如源文件`convenient.h`，`klib_llkd.c`等等。
- en: For efficient code browsing, I would strongly recommend that you always index
    the code base with `ctags(1)` and/or `cscope(1)`. For example, to set up the `ctags`
    index, just `cd` to the root of the source tree and type `ctags -R` .
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了高效地浏览代码，我强烈建议您始终使用`ctags(1)`和/或`cscope(1)`对代码库进行索引。例如，要设置`ctags`索引，只需`cd`到源树的根目录，然后输入`ctags
    -R`。
- en: Unless noted otherwise, the code output we show in the book is the output as
    seen on an x86-64 *Ubuntu 18.04.3 LTS* guest VM (running under Oracle VirtualBox
    6.1). You should realize that due to (usually minor) distribution – and even within
    the same distributions but differing versions – differences, the output shown
    here may not perfectly match what you see on your Linux system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有说明，我们在书中展示的代码输出是在x86-64 *Ubuntu 18.04.3 LTS* 客户VM上看到的输出（在Oracle VirtualBox
    6.1下运行）。您应该意识到，由于（通常是轻微的）分布-甚至在相同的发行版中但是不同的版本-差异，这里显示的输出可能不完全匹配您在Linux系统上看到的内容。
- en: Running Linux as a guest VM
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为客户VM运行Linux
- en: As discussed previously, a practical and convenient alternative to using a native
    Linux system is to install and use the Linux distribution as a guest OS on a VM.
    It's key that you install a recent Linux distribution, preferably as a VM to be
    safe and avoid unpleasant data loss or other surprises. The fact is when working
    at the level of the kernel, abruptly crashing the system (and the data loss risks
    that arise thereof) is actually a commonplace occurrence. I recommend using **Oracle
    VirtualBox 6.x** (or the latest stable version) or other virtualization software,
    such as **VMware Workstation***.*
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前讨论的，与使用本机Linux系统相比，一个实用和方便的替代方法是在虚拟机上安装和使用Linux发行版作为客户端操作系统。重要的是，您安装一个最近的Linux发行版，最好作为虚拟机，以确保安全并避免不愉快的数据丢失或其他意外。事实上，当在内核级别工作时，突然崩溃系统（以及由此产生的数据丢失风险）实际上是一个常见的情况。我建议使用**Oracle
    VirtualBox 6.x**（或最新的稳定版本）或其他虚拟化软件，如**VMware Workstation***.*
- en: Both of these are freely available. It's just that the code for this book has
    been tested on *VirtualBox 6.1*. Oracle VirtualBox is considered **Open Source
    Software** (**OSS**) and is licensed under the GPL v2 (the same as the Linux kernel).
    You can download it from [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
    Its documentation can be found here: [https://www.virtualbox.org/wiki/End-user_documentation](https://www.virtualbox.org/wiki/End-user_documentation).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者都是免费提供的。只是这本书的代码已经在*VirtualBox 6.1*上进行了测试。Oracle VirtualBox被认为是**开源软件**（**OSS**），并且根据GPL
    v2许可（与Linux内核相同）。您可以从[https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)下载它。其文档可以在这里找到：[https://www.virtualbox.org/wiki/End-user_documentation](https://www.virtualbox.org/wiki/End-user_documentation)。
- en: The host system should be either MS Windows 10 or later (of course, even Windows
    7 will work), a recent Linux distribution (for example, Ubuntu or Fedora), or
    macOS. So, let's get started by installing our Linux guest.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 主机系统应该是MS Windows 10或更高版本（当然，甚至Windows 7也可以），最近的Linux发行版（例如Ubuntu或Fedora）或macOS。因此，让我们通过安装我们的Linux客户端来开始。
- en: Installing a 64-bit Linux guest
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装64位Linux客户端
- en: Here, I won't delve into the minutiae of installing Linux as a guest on Oracle
    VirtualBox, the reason being that this installation is *not* directly related
    to Linux kernel development. There are many ways to set up a Linux VM; we really
    don't want to get into the details and the pros and cons of each of them here.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我不会深入讨论在Oracle VirtualBox上安装Linux作为客户端的细节，原因是这种安装与Linux内核开发*没有*直接关联。有许多设置Linux虚拟机的方法；我们真的不想在这里讨论每种方法的细节和利弊。
- en: 'But if you are not familiar with this, don''t worry. For your convenience,
    here are some excellent resources that will help you out:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您对此不熟悉，不用担心。为了您的方便，这里有一些非常好的资源可以帮助您：
- en: A very clearly written tutorial entitled *Install Linux Inside Windows Using
    VirtualBox* by Abhishek Prakash (*It's FOSS!, August 2019*): [https://itsfoss.com/install-linux-in-virtualbox/](https://itsfoss.com/install-linux-in-virtualbox/).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Abhishek Prakash撰写的非常清晰的教程，名为*在VirtualBox中在Windows上安装Linux*（*It's FOSS！，2019年8月*）：[https://itsfoss.com/install-linux-in-virtualbox/](https://itsfoss.com/install-linux-in-virtualbox/)。
- en: An alternate, similarly excellent resource is *Install Ubuntu on Oracle VirtualBox:* [https://brb.nci.nih.gov/seqtools/installUbuntu.html](https://brb.nci.nih.gov/seqtools/installUbuntu.html).
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个同样出色的资源是*在Oracle VirtualBox上安装Ubuntu：*[https://brb.nci.nih.gov/seqtools/installUbuntu.html](https://brb.nci.nih.gov/seqtools/installUbuntu.html)。
- en: Also, you can look up useful resources for installing a Linux guest on VirtualBox
    in the *Further reading *section at the end of this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以在本章末尾的*进一步阅读*部分查找有关在VirtualBox上安装Linux客户端的有用资源。
- en: While you install the Linux VM, keep the following things in mind.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装Linux虚拟机时，请记住以下几点。
- en: Turn on your x86 system's virtualization extension support
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开您的x86系统的虚拟化扩展支持
- en: 'Installing a 64-bit Linux guest requires that CPU virtualization extension
    support (Intel VT-x or AMD-SV) be turned on within the host system''s **basic
    input/output system** (**BIOS**) settings. Let''s see how to do this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 安装64位Linux客户端需要在主机系统的**基本输入/输出系统**（**BIOS**）设置中打开CPU虚拟化扩展支持（Intel VT-x或AMD-SV）。让我们看看如何做到这一点：
- en: 'Our first step is to ensure that our CPU supports virtualization:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一步是确保我们的CPU支持虚拟化：
- en: '**There are two broad ways to check this while on a Windows host**:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在Windows主机上检查这一点有两种广泛的方法**：'
- en: One, run the Task Manager app and switch to the Performance tab. Below the CPU
    graph, you will see, among several other things, Virtualization, with Enabled
    or Disabled following it.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，运行任务管理器应用程序并切换到性能选项卡。在CPU图表下，您将看到，除其他几个选项外，有一个名为虚拟化的选项，后面跟着启用或禁用。
- en: A second way to check on Windows systems is to open a Command window (cmd).
    In Command Prompt, type `systeminfo` and press *Enter.* Among the output seen
    will be the `Virtualization Enabled in firmware` line. It will be followed by
    either `Yes` or `No`.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows系统上检查的第二种方法是打开命令窗口（cmd）。在命令提示符中，键入`systeminfo`并按*Enter*。在输出中将看到`固件中启用了虚拟化`一行。它将后面跟着`是`或`否`。
- en: '**To check this while on a Linux host**, from Terminal, issue the following
    commands (processor virtualization extension support: `vmx` is the check for Intel
    processors, `smv` is the check for AMD processors):'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在Linux主机上检查这一点**，从终端，输入以下命令（处理器虚拟化扩展支持：`vmx`是Intel处理器的检查，`smv`是AMD处理器的检查）：'
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For Intel CPUs, the `vmx` flag will show up (in color) if virtualization is
    supported. In the case of AMD CPUs, `svm` will show up (in color). With this,
    we know that our CPU supports virtualization. But in order to use it, we need
    to enable it in the computer BIOS.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Intel CPU，如果支持虚拟化，`vmx`标志将显示出来（以颜色显示）。对于AMD CPU，`svm`将显示出来（以颜色显示）。有了这个，我们知道我们的CPU支持虚拟化。但是为了使用它，我们需要在计算机BIOS中启用它。
- en: 'Enter the BIOS by pressing *Del* or *F12* while booting (the precise key to
    press varies with the BIOS). Please refer to your system''s manual to see which
    key to use. Search for terms such as `Virtualization` or `Virtualization Technology
    (VT-x)`. Here is an example for Award BIOS:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Del*或*F12*进入BIOS（按键的确切按键因BIOS而异）。请参阅系统手册，了解要使用哪个键。搜索诸如`虚拟化`或`虚拟化技术（VT-x）`之类的术语。以下是Award
    BIOS的示例：
- en: '![](img/72bfc0d7-0c9b-4ffc-8393-427ca3b78384.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/72bfc0d7-0c9b-4ffc-8393-427ca3b78384.png)
- en: Figure 1.1 – Setting the BIOS Virtualization option to the Enabled state
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 - 将BIOS虚拟化选项设置为已启用状态
- en: If you are using an Asus EFI-BIOS, you will have to set the entry to `[Enabled]`
    if it is not set by default. Visit [https://superuser.com/questions/367290/how-to-enable-hardware-virtualization-on-asus-motherboard/375351#375351](https://superuser.com/questions/367290/how-to-enable-hardware-virtualization-on-asus-motherboard/375351#375351).
    [](https://superuser.com/questions/367290/how-to-enable-hardware-virtualization-on-asus-motherboard/375351#375351)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Asus EFI-BIOS，则如果默认情况下未设置该条目，则必须将该条目设置为`[Enabled]`。访问[https://superuser.com/questions/367290/how-to-enable-hardware-virtualization-on-asus-motherboard/375351#375351](https://superuser.com/questions/367290/how-to-enable-hardware-virtualization-on-asus-motherboard/375351#375351)。
    [](https://superuser.com/questions/367290/how-to-enable-hardware-virtualization-on-asus-motherboard/375351#375351)
- en: 'Now, choose to use hardware virtualization in VirtualBox''s Settings menu for
    your VM. To do this, click on System and then Acceleration. After that, check
    the boxes, as shown in the following screenshot:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择在VM的VirtualBox设置菜单中使用硬件虚拟化。要做到这一点，请单击系统，然后加速。之后，检查框，如下面的屏幕截图所示：
- en: '![](img/e815207f-62a8-4a25-ae0b-b27d80b98be6.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/e815207f-62a8-4a25-ae0b-b27d80b98be6.png)
- en: Figure 1.2 – Enabling hardware virtualization options within the VirtualBox
    VM settings
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 - 在VirtualBox VM设置中启用硬件虚拟化选项
- en: This is how we enable our host processor's hardware virtualization features
    for optimal performance.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们启用主机处理器的硬件虚拟化功能以获得最佳性能的方法。
- en: Allocate sufficient space to the disk
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为磁盘分配足够的空间
- en: For most desktop/laptop systems, allocating a gigabyte of RAM and two CPUs to
    the guest VM should be sufficient.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数台式机/笔记本系统，为客户VM分配1 GB的RAM和两个CPU应该足够了。
- en: However, when allocating space for the guest's disk, please be generous. Instead
    of the usual/default 8 GB suggested, I strongly recommend you make it 50 GB or
    even more. Of course, this implies that the host system has more disk space than
    this available! Also, you can specify this amount to be *dynamically allocated*
    or *allocated on-demand*. The hypervisor will "grow" the virtual disk optimally,
    not giving it the entire space to begin with.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在为客户的磁盘分配空间时，请慷慨一些。我强烈建议您将其设置为50 GB甚至更多，而不是通常/默认的8 GB建议。当然，这意味着主机系统有更多的磁盘空间可用！此外，您可以将此金额指定为*动态分配*或*按需分配*。虚拟机监视程序将以最佳方式“增长”虚拟磁盘，而不是一开始就给它整个空间。
- en: Install the Oracle VirtualBox Guest Additions
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Oracle VirtualBox客户附加组件
- en: 'For best performance, it''s important to install the Oracle VirtualBox Guest
    Additions as well within the guest VM. These are essentially para-virtualization
    accelerator software, which greatly helps with optimal performance. Let''s see
    how to do this on an Ubuntu guest session:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳性能，重要的是在客户VM中安装Oracle VirtualBox客户附加组件。这些本质上是用于优化性能的para-virtualization加速软件。让我们看看如何在Ubuntu客户会话中执行此操作：
- en: 'First, update your Ubuntu guest OS''s software packages. You can do so using
    the following command:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，更新您的Ubuntu客户操作系统的软件包。您可以使用以下命令来执行此操作：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On completion, reboot your Ubuntu guest OS and then install the required packages
    using the following command:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，重新启动您的Ubuntu客户操作系统，然后使用以下命令安装所需的软件包：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, from the VM menu bar, go to Devices | Insert Guest Additions CD image.... This
    will mount the `Guest Additions ISO` file inside your VM. The following screenshot shows
    what it looks like doing this:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从VM菜单栏，转到设备 | 插入客户附加CD映像.... 这将在VM内部挂载`客户附加ISO`文件。以下屏幕截图显示了这样做的样子：
- en: '![](img/389c7708-c2c5-4b5b-b039-a454da17fab0.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/389c7708-c2c5-4b5b-b039-a454da17fab0.png)
- en: Figure 1.3 – VirtualBox | Devices | Insert Guest Additions CD image
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 - VirtualBox | 设备 | 插入客户附加CD映像
- en: Now, a dialog window will pop up that will prompt you to run the installer in
    order to launch it. Select Run.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将弹出一个对话框窗口，提示您运行安装程序以启动它。选择运行。
- en: The Guest Additions installation will now take place in a Terminal window that
    shows up. Once complete, hit the *Enter* key to close the window. Then, power
    off your Ubuntu guest OS in order to change some settings from the VirtualBox
    manager, as explained next.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户添加安装现在将在显示的终端窗口中进行。完成后，按*Enter*键关闭窗口。然后，关闭Ubuntu客户操作系统，以便从VirtualBox管理器更改一些设置，如下所述。
- en: 'Now, to enable Shared Clipboard and Drag''n''Drop functionalities between the
    guest and host machines, go to General | Advanced and enable the two options (Shared
    Clipboard and Drag''n''Drop) as you wish with the dropdowns:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要在客户机和主机之间启用共享剪贴板和拖放功能，请转到常规 | 高级，并使用下拉菜单启用两个选项（共享剪贴板和拖放）：
- en: '![](img/aa611c54-cea4-4676-8abc-c0e5cd159d39.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/aa611c54-cea4-4676-8abc-c0e5cd159d39.png)
- en: 'Figure 1.4 – VirtualBox: enabling functionality between the host and guest'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 - VirtualBox：启用主机和客户之间的功能
- en: Then, click OK to save the settings. Now boot into your guest system, log in,
    and test that everything is working fine.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，单击OK保存设置。现在启动到您的客户系统，登录并测试一切是否正常工作。
- en: 'As of the time of writing, Fedora 29 has an issue with the installation of
    the `vboxsf` kernel module required for the Shared Folders feature. I refer you
    to the following resource to attempt to rectify the situation: *Bug 1576832 **- virtualbox-guest-additions
    does not mount shared folder (*[https://bugzilla.redhat.com/show_bug.cgi?id=1576832](https://bugzilla.redhat.com/show_bug.cgi?id=1576832)).
    [](https://bugzilla.redhat.com/show_bug.cgi?id=1576832) If this refuses to work,
    you can simply transfer files between your host and guest VM over SSH (using `scp(1)`);
    to do so, install and start up the SSH daemon with the following commands:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 截至撰写本文时，Fedora 29在安装所需的共享文件夹功能的`vboxsf`内核模块时存在问题。我建议您参考以下资源来尝试纠正这种情况：*Bug 1576832*
    - virtualbox-guest-additions does not mount shared folder (*[https://bugzilla.redhat.com/show_bug.cgi?id=1576832](https://bugzilla.redhat.com/show_bug.cgi?id=1576832))。如果这种方法不起作用，您可以使用`scp(1)`通过SSH在主机和来宾VM之间传输文件；要这样做，请使用以下命令安装并启动SSH守护程序：
- en: '`sudo yum install openssh-server`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo yum install openssh-server`'
- en: '`sudo systemctl start sshd`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo systemctl start sshd`'
- en: 'Remember to update the guest VM regularly and when prompted. This is an essential
    security requirement. You can do so manually by using the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 记得定期更新来宾VM，当提示时。这是一个必要的安全要求。您可以通过以下方式手动执行：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, to be safe, please do not keep any important data on the guest VM.
    We will be working on kernel development. Crashing the guest kernel is actually
    a commonplace occurrence. While this usually does not cause data loss, you can
    never tell! To be safe, always back up any important data. This applies to Fedora
    as well. To learn how to install Fedora as a VirtualBox guest, visit [https://fedoramagazine.org/install-fedora-virtualbox-guest/](https://fedoramagazine.org/install-fedora-virtualbox-guest/).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请不要在来宾VM上保存任何重要数据。我们将进行内核开发。崩溃来宾内核实际上是一个常见的情况。虽然这通常不会导致数据丢失，但你永远无法确定！为了安全起见，请始终备份任何重要数据。这也适用于Fedora。要了解如何将Fedora安装为VirtualBox来宾，请访问[https://fedoramagazine.org/install-fedora-virtualbox-guest/](https://fedoramagazine.org/install-fedora-virtualbox-guest/)。
- en: Sometimes, especially when the overhead of the X Window System (or Wayland)
    GUI is too high, it's preferable to simply work in console mode. You can do so
    by appending `3` (the run level) to the kernel command line via the bootloader.
    However, working in console mode within VirtualBoxmay not be that pleasant an
    experience (for one, the clipboard is unavailable, and the screen size and fonts
    are less than desirable). Thus, simply doing a remote login (via `ssh`, `putty`,
    or equivalent) into the VM from the host system can be a great way to work.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，特别是当X Window系统（或Wayland）GUI的开销太高时，最好只是在控制台模式下工作。您可以通过在引导加载程序中的内核命令行中附加`3`（运行级别）来实现。但是，在VirtualBox中以控制台模式工作可能不是那么愉快的体验（例如，剪贴板不可用，屏幕大小和字体不太理想）。因此，只需从主机系统中进行远程登录（通过`ssh`，`putty`或等效工具）到VM中，这是一种很好的工作方式。
- en: Experimenting with the Raspberry Pi
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用树莓派进行实验
- en: 'The Raspberry Pi is a popular credit card-sized **Single-Board Computer **(**SBC**),
    much like a small-factor PC that has USB ports, a microSD card, HDMI, audio, Ethernet,
    GPIO, and more. The **System on Chip** (**SoC**) that powers it is from Broadcom,
    and in it is an ARM core or cluster of cores. Though not mandatory, of course,
    in this book, we strive to also test and run our code on a Raspberry Pi 3 Model
    B+ target. Running your code on different target architectures is always a good
    eye-opener to possible defects and helps with testing. I encourage you to do the
    same:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派是一种流行的信用卡大小的**单板计算机**（**SBC**），就像一个具有USB端口，microSD卡，HDMI，音频，以太网，GPIO等的小型PC。驱动它的**SoC**（**系统芯片**）来自Broadcom，其中包含ARM核心或核心集群。当然，这并非强制要求，但在本书中，我们还努力在树莓派3
    Model B+目标上测试和运行我们的代码。在不同的目标架构上运行代码始终是发现可能缺陷并有助于测试的好方法。我鼓励您也这样做：
- en: '![](img/29496127-e03d-4829-b976-47296b7509fe.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29496127-e03d-4829-b976-47296b7509fe.png)'
- en: Figure 1.5 – The Raspberry Pi with a USB-to-serial adapter cable attached to
    its GPIO pins
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5-连接到其GPIO引脚的树莓派的USB到串行适配器电缆
- en: You can work on the Raspberry Pi target either using a digital monitor/TV via
    HDMI as the output device and a traditional keyboard/mouse over its USB ports
    or, more commonly for developers, over a remote shell via `ssh(1)`. However, the SSH approach
    does not cut it in all circumstances. Having a *serial console* on the Raspberry
    Pi helps, especially when doing kernel debugging.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用数字监视器/电视通过HDMI作为输出设备和传统键盘/鼠标通过其USB端口，或者更常见的是通过`ssh(1)`远程shell在树莓派目标上工作。但是，在某些情况下，SSH方法并不适用。在树莓派上有一个*串行控制台*有所帮助，特别是在进行内核调试时。
- en: I would recommend that you check out the following article, which will help
    you set up a USB-to-serial connection, thus getting a console login to the Raspberry
    Pi from a PC/laptop: *WORKING ON THE CONSOLE WITH THE RASPBERRY PI,* kaiwanTECH: [https://kaiwantech.wordpress.com/2018/12/16/working-on-the-console-with-the-raspberry-pi/](https://kaiwantech.wordpress.com/2018/12/16/working-on-the-console-with-the-raspberry-pi/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您查看以下文章，该文章将帮助您建立USB到串行连接，从而可以从PC /笔记本电脑登录到树莓派的控制台：*使用树莓派在控制台上工作，* kaiwanTECH：[https://kaiwantech.wordpress.com/2018/12/16/working-on-the-console-with-the-raspberry-pi/](https://kaiwantech.wordpress.com/2018/12/16/working-on-the-console-with-the-raspberry-pi/)。
- en: 'To set up your Raspberry Pi, please refer to the official documentation: [https://www.raspberrypi.org/documentation/](https://www.raspberrypi.org/documentation/).
    Our Raspberry Pi system runs the "official" Raspbian (Debian for Raspberry Pi)
    Linux OS with a recent (as of the time of writing) 4.14 Linux kernel. On the console
    of the Raspberry Pi, we run the following commands:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置您的树莓派，请参阅官方文档：[https://www.raspberrypi.org/documentation/](https://www.raspberrypi.org/documentation/)。我们的树莓派系统运行“官方”Raspbian（树莓派的Debian）Linux操作系统，带有最新（写作时）的4.14
    Linux内核。在树莓派的控制台上，我们运行以下命令：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What if you don't have a Raspberry Pi, or it's not handy? Well, there's always
    a way – emulation! Though not as good as having the real thing, emulating the
    Raspberry Pi with the powerful **Free and Open Source Software** (**FOSS**) emulator
    called **QEMU **or** Quick Emulator** is a nice way to get started, at least.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有树莓派，或者它不方便使用，那怎么办？嗯，总是有办法——模拟！虽然不如拥有真正的设备好，但用强大的**自由开源软件**（**FOSS**）模拟器**QEMU**或**Quick
    Emulator**模拟树莓派是一个不错的开始方式，至少是这样。
- en: As the details of setting up the emulated Raspberry Pi via QEMU go beyond the
    scope of this book, we will not be covering it. However, you can check out the
    following links to find out more: *Emulating Raspberry Pi on Linux*: [http://embedonix.com/articles/linux/emulating-raspberry-pi-on-linux/](http://embedonix.com/articles/linux/emulating-raspberry-pi-on-linux/)and *qemu-rpi-kernel,
    GitHub*: [https://github.com/dhruvvyas90/qemu-rpi-kernel/wiki](https://github.com/dhruvvyas90/qemu-rpi-kernel/wiki).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设置通过QEMU模拟树莓派的细节超出了本书的范围，我们将不予涵盖。但是，您可以查看以下链接以了解更多信息：*在Linux上模拟树莓派*：[http://embedonix.com/articles/linux/emulating-raspberry-pi-on-linux/](http://embedonix.com/articles/linux/emulating-raspberry-pi-on-linux/)和*qemu-rpi-kernel，GitHub*：[https://github.com/dhruvvyas90/qemu-rpi-kernel/wiki](https://github.com/dhruvvyas90/qemu-rpi-kernel/wiki)。
- en: Also, of course, you do not have to confine yourself to the Raspberry Pi family;
    there are several other excellent prototyping boards available. One that springs
    to mind is the popular **BeagleBone Black** (**BBB**) board.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您不必局限于树莓派家族；还有几个其他出色的原型板可供选择。其中一个让人印象深刻的是流行的**BeagleBone Black**（**BBB**）开发板。
- en: In fact, for professional development and product work, the Raspberry Pi is
    really not the best choice, for several reasons... a bit of googling will help
    you understand this. Having said that, as a learning and basic prototyping environment
    it's hard to beat, with the strong community (and tech hobbyist) support it enjoys.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，对于专业开发和产品工作来说，树莓派并不是最佳选择，原因有几个……稍微搜索一下就能理解。话虽如此，作为学习和基本原型环境，它很难被超越，因为它拥有强大的社区（和技术爱好者）支持。
- en: 'Several modern choices of microprocessors for embedded Linux (and much more)
    are discussed and contrasted in this excellent in-depth article: *SO YOU WANT
    TO BUILD AN EMBEDDED LINUX SYSTEM?*, Jay Carlson, Oct 2020 : [https://jaycarlson.net/embedded-linux/](https://jaycarlson.net/embedded-linux/);
    do check it out.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇深度文章中，讨论并对比了几种嵌入式Linux（以及更多）的现代微处理器选择：*SO YOU WANT TO BUILD AN EMBEDDED LINUX
    SYSTEM?*，Jay Carlson，2020年10月：[https://jaycarlson.net/embedded-linux/](https://jaycarlson.net/embedded-linux/)；请查看。
- en: 'By now, I expect that you have set up Linux as a guest machine (or are using
    a native "test" Linux box) and have cloned the book''s GitHub code repository.
    So far, we have covered some information regarding setting up Linux as a guest
    VM (as well as optionally using boards such as the Raspberry Pi or the BeagleBone).
    Let''s now move on to a key step: actually installing software components on our
    Linux guest system so that we can learn and write Linux kernel code on the system!'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我希望您已经设置了Linux作为虚拟机（或者正在使用本地的“测试”Linux框）并克隆了本书的GitHub代码库。到目前为止，我们已经涵盖了一些关于将Linux设置为虚拟机（以及可选地使用树莓派或BeagleBone等开发板）的信息。现在让我们继续进行一个关键步骤：在我们的Linux虚拟系统上实际安装软件组件，以便我们可以在系统上学习和编写Linux内核代码！
- en: Setting up the software – distribution and packages
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置软件——发行版和软件包
- en: 'It is recommended to use one of the following or later stable version Linux
    distributions. As mentioned in the previous section, they can always be installed
    as a guest OS on a Windows or Linux host system, with the clear first choice being
    Ubuntu Linux 18.04 LTS Desktop*.* The following screenshot shows you the recommended
    version and the user interface:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用以下或更高版本的稳定版Linux发行版。正如前一节中提到的，它们始终可以安装为Windows或Linux主机系统的虚拟操作系统，首选当然是Ubuntu
    Linux 18.04 LTS桌面。以下截图显示了推荐的版本和用户界面：
- en: '![](img/ebd213e7-04ce-4dcd-909e-0977d073f2a8.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ebd213e7-04ce-4dcd-909e-0977d073f2a8.png)'
- en: Figure 1.6 – Oracle VirtualBox 6.1 running Ubuntu 18.04.4 LTS as a guest VM
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 - Oracle VirtualBox 6.1运行Ubuntu 18.04.4 LTS作为虚拟机
- en: 'The preceding version – Ubuntu 18.04 LTS Desktop** –** is the version of choice
    for this book, at least.  The two primary reasons for this are straightforward:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个版本——Ubuntu 18.04 LTS桌面——至少对于本书来说是首选版本。选择这个版本的两个主要原因很简单：
- en: Ubuntu Linux is one of the, if not *the, *most popular Linux (kernel) development
    workstation environments in industry use today.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu Linux是当今工业中最受欢迎的Linux（内核）开发工作站环境之一，如果不是*最*受欢迎的话。
- en: We cannot always, for lack of space and clarity, show the code/build output
    of multiple environments in this book. Hence, we have chosen to show the output
    as seen on Ubuntu 18.04 LTS Desktop.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于篇幅和清晰度的限制，我们无法在本书中展示多个环境的代码/构建输出。因此，我们选择以Ubuntu 18.04 LTS桌面上看到的输出来展示。
- en: Ubuntu 16.04 LTS Desktop is a good choice too (it has **Long-Term Support** (**LTS**)
    as well), and everything should work. To download it, visit [https://www.ubuntu.com/download/desktop](https://www.ubuntu.com/download/desktop).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu 16.04 LTS桌面也是一个不错的选择（它也有**长期支持**（**LTS**）），一切都应该可以正常工作。要下载它，请访问[https://www.ubuntu.com/download/desktop](https://www.ubuntu.com/download/desktop)。
- en: 'Some other Linux distributions that can also be considered include the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以考虑一些其他Linux发行版，包括以下内容：
- en: '**CentOS 8 Linux (not CentOS Stream)**: CentOS Linux is a distribution that''s
    essentially a clone of the popular enterprise server distribution from RedHat
    (RHEL 8, in our case). You can download it from here: [https://www.centos.org/download/](https://www.centos.org/download/).'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CentOS 8 Linux（不是CentOS Stream）**：CentOS Linux是一个基本上是RedHat流行企业服务器发行版（在我们的案例中是RHEL
    8）的克隆。您可以从这里下载：[https://www.centos.org/download/](https://www.centos.org/download/)。'
- en: '**Fedora Workstation**: Fedora is a very well-known FOSS Linux distribution
    as well. You can think of it as being a kind of test-bed for projects and code
    that will eventually land up within RedHat''s enterprise products. Download it
    from [https://getfedora.org/](https://getfedora.org/) (download the Fedora Workstation
    image).'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fedora Workstation**：Fedora也是一个非常知名的FOSS Linux发行版。您可以将其视为RedHat企业产品中最终会出现的项目和代码的测试平台。从[https://getfedora.org/](https://getfedora.org/)下载（下载Fedora
    Workstation镜像）。'
- en: '**Raspberry Pi as a target**: It''s really best to refer to the official documentation
    to set up your Raspberry Pi (*Raspberry Pi documentation*: [https://www.raspberrypi.org/documentation/](https://www.raspberrypi.org/documentation/)).
    It''s perhaps worth noting that Raspberry Pi "kits" are widely available that
    come completely pre-installed and with some hardware accessories as well.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Raspberry Pi作为目标**：最好参考官方文档来设置您的Raspberry Pi（*Raspberry Pi文档*：[https://www.raspberrypi.org/documentation/](https://www.raspberrypi.org/documentation/)）。也许值得注意的是，广泛提供完全预安装的Raspberry
    Pi“套件”，还配备了一些硬件配件。'
- en: If you want to learn how to install a Raspberry Pi OS image on an SD card, visit [https://www.raspberrypi.org/documentation/installation/installing-images/](https://www.raspberrypi.org/documentation/installation/installing-images/).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想学习如何在SD卡上安装Raspberry Pi OS映像，请访问[https://www.raspberrypi.org/documentation/installation/installing-images/](https://www.raspberrypi.org/documentation/installation/installing-images)。
- en: '**BeagleBone Black as a target**: The BBB is, like the Raspberry Pi, an extremely
    popular embedded ARM SBC for hobbyists and pros. You can get started here: [https://beagleboard.org/black](https://beagleboard.org/black). The
    System Reference Manual for the BBB can be found here: [https://cdn.sparkfun.com/datasheets/Dev/Beagle/BBB_SRM_C.pdf](https://cdn.sparkfun.com/datasheets/Dev/Beagle/BBB_SRM_C.pdf).
    Though we don''t present examples running on the BBB, nevertheless, it''s a valid
    embedded Linux system that, once properly set up, you can run this book''s code
    on.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BeagleBone Black作为目标**：BBB与Raspberry Pi一样，是业余爱好者和专业人士非常受欢迎的嵌入式ARM SBC。您可以从这里开始：[https://beagleboard.org/black](https://beagleboard.org/black)。BBB的系统参考手册可以在这里找到：[https://cdn.sparkfun.com/datasheets/Dev/Beagle/BBB_SRM_C.pdf](https://cdn.sparkfun.com/datasheets/Dev/Beagle/BBB_SRM_C.pdf)。尽管我们没有在BBB上运行示例，但它仍然是一个有效的嵌入式Linux系统，一旦正确设置，您可以在上面运行本书的代码。'
- en: 'Before we conclude our discussion on selecting our software distribution for
    the book, here are a few more points to note:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束对书中软件发行版的选择讨论之前，还有一些要注意的地方：
- en: These distributions are, in their default form, FOSS and non-proprietary, and
    free to use as an end user.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些发行版在其默认形式下是FOSS和非专有的，可以作为最终用户免费使用。
- en: Though our aim is to be Linux distribution-neutral, the code has only been tested
    on Ubuntu 18.04 LTS and "lightly" tested on CentOS 8, and a Raspberry Pi 3 Model
    B+ running the Raspbian GNU/Linux 9.9 (stretch) Debian-based Linux OS.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管我们的目标是成为与Linux发行版无关，但代码只在Ubuntu 18.04 LTS上进行了测试，并在CentOS 8上进行了“轻微”测试，以及在运行基于Debian的Raspbian
    GNU/Linux 9.9（stretch）的Raspberry Pi 3 Model B+上进行了测试。
- en: We will, as far as is possible, use the very latest (as of the time of writing)
    **stable LTS**
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将尽可能使用最新的（在撰写时）**稳定的LTS**
- en: '**Linux kernel version 5.4** for our kernel build and code runs. Being an LTS
    kernel, the 5.4 kernel is an excellent choice to run on and learn with.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux内核版本5.4**用于我们的内核构建和代码运行。作为LTS内核，5.4内核是一个非常好的选择来运行和学习。'
- en: It is interesting to know that the 5.4 LTS kernel will indeed have a long lifespan;
    from November 2019 right up to December 2025! This is good news: this book's content
    remains current and valid for years to come!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，5.4 LTS内核的寿命将会很长；从2019年11月一直到2025年12月！这是个好消息：本书的内容将在未来几年内保持最新和有效！
- en: For this book, we'll log in as the user account named `llkd`.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于这本书，我们将以名为`llkd`的用户帐户登录。
- en: It's important to realize, for maximized security (with the latest defenses
    and fixes), that you must run the most recent **Long Term Support** (**LTS**)
    kernel possible for your project or product.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要最大限度地提高安全性（使用最新的防御和修复），您必须运行最新的**长期支持**（**LTS**）内核，以便用于您的项目或产品。
- en: Now that we have chosen our Linux distribution and/or hardware boards and VMs,
    it's time we install essential software packages.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经选择了我们的Linux发行版和/或硬件板和VM，是时候安装必要的软件包了。
- en: Installing software packages
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装软件包
- en: 'The packages that are installed by default when you use a typical Linux desktop
    distribution, such as any recent Ubuntu, CentOS, or Fedora Linux system, will
    include the minimal set required by a systems programmer: the native toolchain,
    which includes the `gcc` compiler along with headers, and the `make` utility/packages.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用典型的Linux桌面发行版（如任何最近的Ubuntu、CentOS或Fedora Linux系统）时，默认安装的软件包将包括系统程序员所需的最小设置：本地工具链，其中包括`gcc`编译器和头文件，以及`make`实用程序/软件包。
- en: In this book, though, we are going to learn how to write kernel-space code using
    a VM and/or a target system running on a foreign processor (ARM or AArch64 being
    the typical cases). To effectively develop kernel code on these systems, we will
    need to install some software packages. Read on.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将学习如何使用VM和/或在外部处理器（ARM或AArch64是典型情况）上运行的目标系统编写内核空间代码。为了有效地在这些系统上开发内核代码，我们需要安装一些软件包。继续阅读。
- en: Installing the Oracle VirtualBox guest additions
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Oracle VirtualBox客户附加组件
- en: 'Make sure you have installed the guest VM (as explained previously). Then,
    follow along:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已安装了客户端VM（如前所述）。然后，跟着做：
- en: 'Log in to your Linux guest VM and first run the following commands within a
    Terminal window (on a shell):'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到您的Linux客户VM，首先在终端窗口（shell上）运行以下命令：
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Install the Oracle VirtualBox Guest Additions now. Refer to *How to Install
    VirtualBox Guest Additions in Ubuntu:* [https://www.tecmint.com/install-virtualbox-guest-additions-in-ubuntu/](https://www.tecmint.com/install-virtualbox-guest-additions-in-ubuntu/).
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在安装Oracle VirtualBox客户附加组件。参考*如何在Ubuntu中安装VirtualBox客户附加组件：*[https://www.tecmint.com/install-virtualbox-guest-additions-in-ubuntu/](https://www.tecmint.com/install-virtualbox-guest-additions-in-ubuntu/)。
- en: This only applies if you are running Ubuntu as a VM using Oracle VirtualBox
    as the hypervisor app.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当您将Ubuntu作为使用Oracle VirtualBox作为hypervisor应用程序的VM运行时才适用。
- en: Installing required software packages
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装所需的软件包
- en: 'To install the packages, take the following steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装这些软件包，请执行以下步骤：
- en: 'Within the Ubuntu VM, first do the following:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Ubuntu VM中，首先执行以下操作：
- en: '[PRE7]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, run the following command in a single line:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在一行中运行以下命令：
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The command installing `gcc`, `make`, and `perl` is done first so that the Oracle
    VirtualBox Guest Additions can be properly installed straight after. These (Guest
    Additions) are essentially para-virtualization accelerator software. It's important
    to install them for optimal performance.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先执行安装`gcc`，`make`和`perl`的命令，以便可以直接安装Oracle VirtualBox Guest Additions。这些（Guest
    Additions）本质上是para-virtualization加速软件。安装它们对于性能优化很重要。
- en: This book, at times, mentions that running a program on another CPU architecture
    – typically ARM – might be a useful exercise. If you want to try (interesting!)
    stuff like this, please read on; otherwise, feel free to skip ahead to the *Important
    installation notes* section.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书有时提到在另一个CPU架构上运行程序-通常是ARM-可能是一个有用的练习。如果您想尝试（有趣！）这样的东西，请继续阅读；否则，可以随意跳到*重要的安装注意事项*部分。
- en: Installing a cross toolchain and QEMU
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装交叉工具链和QEMU
- en: One way to try things on an ARM machine is to actually do so on a physical ARM-based
    SBC; for example, the Raspberry Pi is a very popular choice. In this case, the
    typical development workflow is to first build the ARM code on your x86-64 host
    system. But to do so, we need to install a **cross toolchain** – a set of tools
    allowing you to build software on one host CPU designed to execute on a different
    *target* CPU. An x86-64 *host* building programs for an ARM *target* is a very
    common case, and indeed is our use case here. Details on installing the cross
    compiler follow shortly.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在ARM机器上尝试事物的一种方法是实际在物理ARM-based SBC上这样做；例如，树莓派是一个非常受欢迎的选择。在这种情况下，典型的开发工作流程是首先在x86-64主机系统上构建ARM代码。但为了这样做，我们需要安装一个**交叉工具链**-一组工具，允许您在一个设计为在不同*目标*CPU上执行的主机CPU上构建软件。一个x86-64
    *主机*构建ARM *目标*的程序是一个非常常见的情况，确实是我们的用例。稍后将详细介绍安装交叉编译器的详细信息。
- en: Often, an alternate way to just trying things out is to have an ARM/Linux system
    emulated – this alleviates the need for hardware! To do so, we recommend using
    the superb **QEMU** project ([https://www.qemu.org/](https://www.qemu.org/)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，尝试事物的另一种方法是模拟ARM/Linux系统-这样可以减轻对硬件的需求！为此，我们建议使用出色的**QEMU**项目（[https://www.qemu.org/](https://www.qemu.org/)）。
- en: 'To install the required QEMU packages, do the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装所需的QEMU软件包，请执行以下操作：
- en: 'For installation on Ubuntu, use the following:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Ubuntu的安装，请使用以下命令：
- en: '[PRE9]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For installation on Fedora, use the following:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Fedora的安装，请使用以下命令：
- en: '[PRE10]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To get the version number on Fedora, just type the preceding command and after
    typing the required package name (here, `qemu-system-arm-`), press the *Tab* key
    twice. It will auto-complete, providing a list of choices. Choose the latest version
    and press *Enter*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Fedora上获取版本号，只需输入前面的命令，然后在输入所需的软件包名称（这里是`qemu-system-arm-`）后，按两次*Tab*键。它将自动完成，提供一个选择列表。选择最新版本，然后按*Enter*。
- en: CentOS 8 does not seem to have a simple means to install the QEMU package we
    require. (You could always install a cross toolchain via the source, but that's
    challenging; or, obtain an appropriate binary package.) Due to these difficulties,
    we will skip showing cross-compilation on CentOS.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: CentOS 8似乎没有简单的方法来安装我们需要的QEMU软件包。（您可以通过源代码安装交叉工具链，但这很具有挑战性；或者，获取一个合适的二进制软件包。）由于这些困难，我们将跳过在CentOS上展示交叉编译。
- en: Installing a cross compiler
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装交叉编译器
- en: 'If you intend to write a C program that is compiled on a certain host system
    but must execute on another target system, then you need to compile it with what''s
    known as a cross compiler or cross toolchain. For example, in our use case, we
    want to work on an x86-64 host machine. It could even be an x86-64 guest VM, no
    issues, but run our code on an ARM-32 target:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算编写一个在特定主机系统上编译但必须在另一个目标系统上执行的C程序，那么您需要使用所谓的交叉编译器或交叉工具链进行编译。例如，在我们的用例中，我们希望在一个x86-64主机上工作。甚至可以是x86-64虚拟机，没有问题，但在ARM-32目标上运行我们的代码：
- en: 'On Ubuntu, you can install the cross toolchain with the following:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Ubuntu上，您可以使用以下命令安装交叉工具链：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding command installs an x86_64-to-ARM-32 toolchain appropriate for
    ARM-32 "hard float" (armhf) systems (such as the Raspberry Pi); this is usually
    just fine. It results in the `arm-linux-gnueabihf-<foo>` set of tools being installed;
    where `<foo>` represents cross tools such as `addr2line`, `as`, `g++`, `gcc`,
    `gcov`, `gprof`, `ld`, `nm`, `objcopy`, `objdump`, `readelf`, `size`, `strip`,
    and so on. (The cross compiler prefix in this case is `arm-linux-gnueabihf-`).
    In addition, though not mandatory, you can install the `arm-linux-gnueabi-<foo>` cross
    toolset like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令安装了适用于ARM-32“硬浮点”（armhf）系统（例如树莓派）的x86_64到ARM-32工具链（通常很好）。它会安装`arm-linux-gnueabihf-<foo>`一组工具；其中`<foo>`代表交叉工具，如`addr2line`，`as`，`g++`，`gcc`，`gcov`，`gprof`，`ld`，`nm`，`objcopy`，`objdump`，`readelf`，`size`，`strip`等。
    （在这种情况下，交叉编译器前缀是`arm-linux-gnueabihf-`）。此外，虽然不是强制的，您也可以这样安装`arm-linux-gnueabi-<foo>`交叉工具集：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On Fedora, you can install the cross toolchain with the following:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Fedora上，您可以使用以下命令安装交叉工具链：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For Fedora Linux, the same tip as earlier applies – use the *Tab* key to help
    auto-complete the command.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Fedora Linux，与之前相同的提示适用-使用*Tab*键来帮助自动完成命令。
- en: Installing and using a cross toolchain might require some reading up for newbie
    users. You can visit the *Further reading* section where I have placed a few useful
    links that will surely be of great help.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和使用交叉工具链可能需要一些新手用户的阅读。您可以访问*进一步阅读*部分，我在那里放置了一些有用的链接，这些链接肯定会帮助很大。
- en: Important installation notes
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重要的安装注意事项
- en: 'We will now mention a few remaining points, most of them pertaining to software
    installation or other issues when working on particular distributions:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将提到一些剩下的要点，其中大部分涉及软件安装或在特定发行版上工作时的其他问题：
- en: 'On CentOS 8, you can install Python with the following command:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CentOS 8上，您可以使用以下命令安装Python：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, this does not actually create the (required) **symbolic link** (**symlink**),
    `/usr/bin/python`; why not? Check out this link for details: [https://developers.redhat.com/blog/2019/05/07/what-no-python-in-red-hat-enterprise-linux-8/](https://developers.redhat.com/blog/2019/05/07/what-no-python-in-red-hat-enterprise-linux-8/).
    [](https://developers.redhat.com/blog/2019/05/07/what-no-python-in-red-hat-enterprise-linux-8/)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这实际上并没有创建（必需的）**符号链接**（**symlink**），`/usr/bin/python`；为什么呢？查看此链接获取详细信息：[https://developers.redhat.com/blog/2019/05/07/what-no-python-in-red-hat-enterprise-linux-8/](https://developers.redhat.com/blog/2019/05/07/what-no-python-in-red-hat-enterprise-linux-8/)。
- en: 'To manually create the symlink to, for example, `python3`, do the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 手动创建符号链接，例如 `python3`，请执行以下操作：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The kernel build might fail if the OpenSSL header files aren''t installed.
    Fix this on CentOS 8 with the following:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未安装OpenSSL头文件，内核构建可能会失败。在CentOS 8上使用以下命令修复：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'On CentOS 8, the `lsb_release` utility can be installed with the following:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CentOS 8上，可以使用以下命令安装 `lsb_release` 实用程序：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On Fedora, do the following:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Fedora上，执行以下操作：
- en: 'Install these two packages, ensuring the dependencies are met when building
    a kernel on Fedora systems:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装这两个包，确保在Fedora系统上构建内核时满足依赖关系：
- en: '`sudo dnf install openssl-devel-1:1.1.1d-2.fc31 elfutils-libelf-devel` (the
    preceding `openssl-devel` package is suffixed with the relevant Fedora version
    number (`.fc31` here; adjust it as required for your system).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo dnf install openssl-devel-1:1.1.1d-2.fc31 elfutils-libelf-devel`（前面的`openssl-devel`包后缀为相关的Fedora版本号（这里是`.fc31`；根据您的系统需要进行调整）。'
- en: In order to use the `lsb_release` command, you must install the `redhat-lsb-core` package.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使用 `lsb_release` 命令，您必须安装 `redhat-lsb-core` 包。
- en: Congratulations! This completes the software setup, and your kernel journey
    begins! Now, let's check out a few additional and useful projects to complete
    this chapter. It's certainly recommended that you read through these as well.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！软件设置完成，您的内核之旅开始了！现在，让我们看看一些额外的有用项目，以完成本章。强烈建议您也阅读这些。
- en: Additional useful projects
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外有用的项目
- en: This section brings you details of some additional miscellaneous projects that
    you might find very useful indeed. In a few appropriate places in this book, we
    refer to or directly make use of some of them, thus making them important to understand.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本节为您带来了一些额外的杂项项目的详细信息，您可能会发现它们非常有用。在本书的一些适当的地方，我们提到或直接使用了其中一些，因此理解它们非常重要。
- en: Let's get started with the well-known and important Linux *man pages* project.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始熟悉并重要的Linux *man页面*项目。
- en: Using the Linux man pages
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Linux man页面
- en: 'You must have noticed the convention followed in most Linux/Unix literature:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您一定已经注意到了大多数Linux/Unix文献中遵循的惯例：
- en: The suffixing of *user commands* with `(1)` – for example, `gcc(1)` or `gcc.1`
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户命令* 的后缀为 `(1)` – 例如， `gcc(1)` 或 `gcc.1`'
- en: '*System calls* with `(2)` – for example, `fork(2)` or `fork().2`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*系统调用* 带有 `(2)` – 例如， `fork(2)` 或 `fork().2`'
- en: '*Library APIs* with `(3)` – for example, `pthread_create(3)` or `pthread_create().3`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*库API* 带有 `(3)` – 例如， `pthread_create(3)` 或 `pthread_create().3`'
- en: 'As you are no doubt aware, the number in parentheses (or after the period)
    denotes the section of the **manual** (the **man** pages) that the command/API
    in question belongs to. A quick check with `man(1)`, via the `man man` command (that''s
    why we love Unix/Linux!) reveals the sections of the Unix/Linux manual:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您无疑所知，括号中的数字（或句号后面的数字）表示命令/API所属的**手册**（**man**页面）的部分。通过 `man(1)` 快速检查，通过 `man
    man` 命令 （这就是我们喜欢Unix/Linux的原因！）可以查看Unix/Linux手册的部分：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So, for example, to look up the man page on the `stat(2)` system call, you
    would use the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，要查找 `stat(2)` 系统调用的man页面，您将使用以下命令：
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At times (quite often, in fact), the `man` pages are simply too detailed to
    warrant reading through when a quick answer is all that's required. Enter the `tldr`
    project – read on!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有时（实际上经常），`man`页面太详细了，不值得阅读，只需要一个快速答案。这就是 `tldr` 项目的用途 – 继续阅读！
- en: The tldr variant
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tldr变种
- en: While we're discussing `man` pages, a common annoyance is that the `man` page
    on a command is, at times, too large. Take the `ps(1)` utility as an example.
    It has a large `man` page as, of course, it has a huge number of option switches.
    Wouldn't it be nice, though, to have a simplified and summarized "common usage"
    page? This is precisely what the `tldr` pages project aims to do.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论`man`页面时，一个常见的烦恼是命令的`man`页面有时太大了。以 `ps(1)` 实用程序为例。它有一个很大的`man`页面，因为它当然有大量的选项开关。不过，有一个简化和总结的“常见用法”页面会很好，对吧？这正是 `tldr` 页面项目的目标。
- en: '**TL;DR** literally means **Too Long; Didn''t Read***.*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**TL;DR** 字面意思是 **太长了；没读***.*'
- en: 'In their own words, they provide *"*simplified and community-driven man pages."
    So, once installed, `tldr ps` provides a neat brief summary on the most commonly
    used `ps` command option switches to do something useful:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 他们提供*“简化和社区驱动的man页面。”*因此，一旦安装，`tldr ps` 提供了一个简洁的摘要，介绍了最常用的`ps` 命令选项开关，以便做一些有用的事情：
- en: '![](img/a3222a01-e03c-4c9b-842d-d16a5295ee50.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3222a01-e03c-4c9b-842d-d16a5295ee50.png)'
- en: 'Figure 1.7 – A screenshot of the tldr utility in action: tldr ps'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – tldr实用程序的截图：tldr ps
- en: All Ubuntu repos have the `tldr` package. Install it with `sudo apt install
    tldr`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Ubuntu仓库都有 `tldr` 包。使用 `sudo apt install tldr` 进行安装。
- en: It's indeed worth checking out. If you're interested in knowing more, visit [https://tldr.sh/](https://tldr.sh/).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 确实值得一看。如果您想了解更多，请访问 [https://tldr.sh/](https://tldr.sh/)。
- en: Earlier, recall that we said that userspace system calls fall under section
    2 of the man pages, library subroutines under section 3, and kernel APIs under
    section 9. Given this, then, in this book, why don't we specify the, say, `printk`
    kernel function (or API) as `printk(9)` – as `man man` shows us that section `9`
    of the manual is *Kernel routines*? Well, it's fiction, really (at least on today's
    Linux): *no man pages actually exist for kernel APIs! *So, how do you get documentation
    on the kernel APIs and so on? That's just what we will briefly delve into in the
    following section.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们提到用户空间系统调用属于man页面的第2节，库子例程属于第3节，内核API属于第9节。鉴于此，在本书中，为什么我们不将，比如，`printk`内核函数（或API）指定为`printk(9)`
    - 因为`man man`向我们展示手册的第9节是*Kernel routines*？嗯，实际上这是虚构的（至少在今天的Linux上）：*内核API实际上没有man页面！*那么，你如何获取内核API的文档等？这正是我们将在下一节中简要探讨的内容。
- en: Locating and using the Linux kernel documentation
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找和使用Linux内核文档
- en: The community has developed and evolved the Linux kernel documentation into
    a good state over many years of effort. The *latest version* of the kernel documentation,
    presented in a nice and modern "web" style, can always be accessed online here: [https://www.kernel.org/doc/html/latest/](https://www.kernel.org/doc/html/latest/).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 社区经过多年的努力，已经将Linux内核文档发展和演变到一个良好的状态。内核文档的*最新版本*以一种漂亮和现代的“web”风格呈现，可以在这里在线访问：[https://www.kernel.org/doc/html/latest/](https://www.kernel.org/doc/html/latest/)。
- en: Of course, as we will mention in the next chapter, the kernel documentation
    is always available for that kernel version within the kernel source tree itself,
    in the directory called `Documentation/`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，正如我们将在下一章中提到的那样，内核文档始终可以在内核源树中的该内核版本中找到，位于名为`Documentation/`的目录中。
- en: 'As just one example of the online kernel documentation, see the following partial
    screenshot of the page on *Core Kernel Documentation*/*Basic C Library Functions* ([https://www.kernel.org/doc/html/latest/core-api/kernel-api.html#basic-c-library-functions](https://www.kernel.org/doc/html/latest/core-api/kernel-api.html#basic-c-library-functions)):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在线内核文档的一个例子，可以查看以下页面的部分截图*Core Kernel Documentation*/*Basic C Library Functions*
    ([https://www.kernel.org/doc/html/latest/core-api/kernel-api.html#basic-c-library-functions](https://www.kernel.org/doc/html/latest/core-api/kernel-api.html#basic-c-library-functions))：
- en: '![](img/89f4c179-15d9-4d6e-a241-9e984e14ebae.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89f4c179-15d9-4d6e-a241-9e984e14ebae.png)'
- en: Figure 1.8 – Partial screenshot showing a small part of the modern online Linux
    kernel documentation
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 - 部分截图显示现代在线Linux内核文档的一小部分
- en: As can be gleaned from the screenshot, the modern documentation is pretty comprehensive.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从截图中可以看出，现代文档非常全面。
- en: Generating the kernel documentation from source
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从源代码生成内核文档
- en: You can literally generate the full Linux kernel documentation from within the
    kernel source tree in various popular formats (including PDF, HTML, LaTeX, EPUB,
    or XML), in a *Javadoc* or *Doxygen-like* style. The modern documentation system
    used internally by the kernel is called **Sphinx**. Using `make help` within the
    kernel source tree will reveal several *documentation targets*, among them `htmldocs`,
    `pdfdocs`, and more. So, you can, for example, `cd` to the kernel source tree
    and run `make pdfdocs` to build the complete Linux kernel documentation as PDF
    documents (the PDFs, as well as some other meta-docs, will be placed in `Documentation/output/latex`).
    The first time, at least, you will likely be prompted to install several packages
    and utilities (we don't show this explicitly).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从内核源树中以各种流行的格式（包括PDF、HTML、LaTeX、EPUB或XML）生成完整的Linux内核文档，以*Javadoc*或*Doxygen*风格。内核内部使用的现代文档系统称为**Sphinx**。在内核源树中使用`make
    help`将显示几个*文档目标*，其中包括`htmldocs`、`pdfdocs`等。因此，例如，你可以`cd`到内核源树并运行`make pdfdocs`来构建完整的Linux内核文档作为PDF文档（PDF文档以及其他一些元文档将放在`Documentation/output/latex`中）。至少在第一次，你可能会被提示安装几个软件包和实用程序（我们没有明确显示这一点）。
- en: Don't worry if the preceding details are not crystal clear yet. I suggest you
    first read [Chapter 2](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml), *Building
    the 5.x Linux Kernel from Source – Part 1*, and [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml),
    *Building the 5.x Linux Kernel from Source – Part 2*, and then revisit these details.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的细节还不是很清楚，不要担心。我建议你先阅读[第2章](e0b89a37-18a3-424d-8983-58c4ac0725f6.xhtml)，*从源代码构建5.x
    Linux内核-第1部分*，和[第3章](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml)，*从源代码构建5.x Linux内核-第2部分*，然后再回顾这些细节。
- en: Static analysis tools for the Linux kernel
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux内核的静态分析工具
- en: Static analyzers are tools that, by examining the source code, attempt to identify
    potential errors within it. They can be tremendously useful to you as the developer,
    though you must learn how to "tame" them – in the sense that they can result in
    false positives.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析工具是通过检查源代码来尝试识别其中潜在错误的工具。它们对开发人员非常有用，尽管你必须学会如何“驯服”它们 - 因为它们可能会产生误报。
- en: 'Several useful static analysis tools exist. Among them, the ones that are more
    relevant for Linux kernel code analysis include the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些有用的静态分析工具。其中，对于Linux内核代码分析更相关的工具包括以下内容：
- en: Sparse: [https://sparse.wiki.kernel.org/index.php/Main_Page](https://sparse.wiki.kernel.org/index.php/Main_Page)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Sparse: [https://sparse.wiki.kernel.org/index.php/Main_Page](https://sparse.wiki.kernel.org/index.php/Main_Page)'
- en: Coccinelle: [http://coccinelle.lip6.fr/](http://coccinelle.lip6.fr/) (requires
    the `ocaml` package installed)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Coccinelle: [http://coccinelle.lip6.fr/](http://coccinelle.lip6.fr/)（需要安装`ocaml`包）'
- en: Smatch: [http://smatch.sourceforge.net/](http://smatch.sourceforge.net/), [http://repo.or.cz/w/smatch.git](http://repo.or.cz/w/smatch.git)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Smatch: [http://smatch.sourceforge.net/](http://smatch.sourceforge.net/)，[http://repo.or.cz/w/smatch.git](http://repo.or.cz/w/smatch.git)'
- en: Flawfinder: [https://dwheeler.com/flawfinder/](https://dwheeler.com/flawfinder/)
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Flawfinder: [https://dwheeler.com/flawfinder/](https://dwheeler.com/flawfinder/)'
- en: Cppcheck: [https://github.com/danmar/cppcheck](https://github.com/danmar/cppcheck)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Cppcheck: [https://github.com/danmar/cppcheck](https://github.com/danmar/cppcheck)'
- en: 'For example, to install and try Sparse, do the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要安装并尝试Sparse，请执行以下操作：
- en: '[PRE20]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There are also several high-quality commercial static analysis tools available.
    Among them are the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些高质量的商业静态分析工具可用。其中包括以下内容：
- en: 'SonarQube: [https://www.sonarqube.org/](https://www.sonarqube.org/)​ (a free
    and open source community edition is available)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SonarQube: [https://www.sonarqube.org/](https://www.sonarqube.org/)（提供免费的开源社区版）'
- en: 'Coverity Scan: [https://scan.coverity.com/](https://scan.coverity.com/)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Coverity Scan: [https://scan.coverity.com/](https://scan.coverity.com/)'
- en: Klocwork: [https://www.meteonic.com/klocwork](https://www.meteonic.com/klocwork)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Klocwork: [https://www.meteonic.com/klocwork](https://www.meteonic.com/klocwork)
- en: '`clang` is a frontend to GCC that is becoming more popular even for kernel
    builds. You can install it on Ubuntu with `sudo apt install clang clang-tools`.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`clang`是GCC的前端，即使用于内核构建也越来越受欢迎。您可以使用`sudo apt install clang clang-tools`在Ubuntu上安装它。'
- en: Static analysis tools can save the day. Time spent learning to use them effectively
    is time well spent!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析工具可以帮助解决问题。花时间学习如何有效使用它们是值得的！
- en: Linux Trace Toolkit next generation
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux Trace Toolkit next generation
- en: A superb tool for *tracing* and *profiling* is the powerful**Linux Tracing Toolkit
    next generation** (**LTTng**) toolset, a Linux Foundation project. LTTng allows
    you to trace both userspace (applications) and/or the kernel code paths in minute
    detail. This can tremendously aid you in understanding where performance bottlenecks
    occur, as well as aiding you in understanding the overall code flow and thus in
    learning about how the code actually performs its tasks.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 用于*跟踪*和*分析*的绝佳工具是功能强大的**Linux Tracing Toolkit next generation**（LTTng）工具集，这是一个Linux基金会项目。LTTng允许您详细跟踪用户空间（应用程序）和/或内核代码路径。这可以极大地帮助您了解性能瓶颈出现在哪里，以及帮助您了解整体代码流程，从而了解代码实际执行任务的方式。
- en: In order to learn how to install and use it, I refer you to its very good documentation
    here: [https://lttng.org/docs](https://lttng.org/docs)​ (try [https://lttng.org/download/](https://lttng.org/download/) for
    installation for common Linux distributions). It is also highly recommended that
    you install the Trace Compass GUI: [https://www.eclipse.org/tracecompass/](https://www.eclipse.org/tracecompass/).
    It provides an excellent GUI for examining and interpreting LTTng's output.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习如何安装和使用它，我建议您参考这里非常好的文档：[https://lttng.org/docs](https://lttng.org/docs)（尝试[https://lttng.org/download/](https://lttng.org/download/) 安装常见的Linux发行版）。强烈建议您安装Trace
    Compass GUI：[https://www.eclipse.org/tracecompass/](https://www.eclipse.org/tracecompass/)。它提供了一个优秀的GUI来检查和解释LTTng的输出。
- en: Trace Compass minimally requires a **Java Runtime Environment** (**JRE**) to
    be installed as well. I installed one on my Ubuntu 20.04 LTS system with `sudo
    apt install openjdk-14-jre`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Trace Compass最低要求安装**Java Runtime Environment**（JRE）。我在我的Ubuntu 20.04 LTS系统上安装了一个，使用`sudo
    apt install openjdk-14-jre`。
- en: 'As an example (I can''t resist!), here''s a screenshot of a capture by LTTng
    being "visualized" by the superb Trace Compass GUI. Here, I show a couple of hardware
    interrupts (IRQ lines 1 and 130, the interrupt lines for the i8042 and Wi-Fi chipset,
    respectively, on my native x86_64 system.):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子（我忍不住！），这是LTTng捕获的截图，由出色的Trace Compass GUI“可视化”。在这里，我展示了一些硬件中断（IRQ线1和130，分别是我的本机x86_64系统上i8042和Wi-Fi芯片组的中断线。）
- en: '![](img/3845add2-b5a5-4f1b-a6b2-a2bb787f58e9.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3845add2-b5a5-4f1b-a6b2-a2bb787f58e9.png)'
- en: Figure 1.9 – Sample screenshot of the Trace Compass GUI; samples recorded by
    LTTng showing IRQ lines 1 and 130
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 - Trace Compass GUI的示例截图；由LTTng记录的显示IRQ线1和130的样本
- en: The pink color in the upper part of the preceding screenshot represents the
    occurrence of a hardware interrupt. Underneath that, in the IRQ vs Time tab (it's
    only partially visible), the interrupt distribution is seen. (In the distribution
    graph, the *y* axis is the time taken; interestingly, the network interrupt handler
    – in red – seems to take very little time, the i8042 keyboard/mouse controller
    chip's handler – in blue – takes more time, even exceeding 200 microseconds!)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 前面截图上部的粉色表示硬件中断的发生。在下面，在IRQ vs Time标签（仅部分可见），可以看到中断分布。（在分布图中，*y*轴是所花费的时间；有趣的是，网络中断处理程序
    - 以红色显示 - 似乎花费的时间很少，i8042键盘/鼠标控制器芯片的处理程序 - 以蓝色显示 - 花费更多时间，甚至超过200微秒！）
- en: The procmap utility
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: procmap实用程序
- en: Visualizing the complete memory map of the kernel **Virtual Address Space**
    (**VAS**) as well as any given process's user VAS is what the `procmap` utility
    is designed to do.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`procmap`实用程序的设计目的是可视化内核**虚拟地址空间**（VAS）的完整内存映射，以及任何给定进程的用户VAS。'
- en: 'The description on its GitHub page sums it up:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 其GitHub页面上的描述总结如下：
- en: <q>It outputs a simple visualization of the complete memory map of a given process
    in a vertically-tiled format ordered by descending virtual address. The script
    has the intelligence to show kernel and userspace mappings as well as calculate
    and show the sparse memory regions that will be present. Also, each segment or
    mapping is scaled by relative size (and color-coded for readability). On 64-bit
    systems, it also shows the so-called non-canonical sparse region or 'hole' (typically
    close to 16,384 PB on the x86_64).</q>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: <q>它以垂直平铺的格式输出给定进程的完整内存映射的简单可视化，按降序虚拟地址排序。脚本具有智能功能，可以显示内核和用户空间映射，并计算并显示将出现的稀疏内存区域。此外，每个段或映射都按相对大小进行缩放（并以颜色编码以便阅读）。在64位系统上，它还显示所谓的非规范稀疏区域或“空洞”（通常接近x86_64上的16,384
    PB）。</q>
- en: The utility includes options to see only kernel space or userspace, verbose
    and debug modes, the ability to export its output in convenient CSV format to
    a specified file, as well as other options. It has a kernel component as well
    and currently works (and auto-detects) on x86_64, AArch32, and Aarch64 CPUs.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 该实用程序包括查看仅内核空间或用户空间、详细和调试模式、将输出以便于的CSV格式导出到指定文件以及其他选项。它还有一个内核组件，目前可以在x86_64、AArch32和Aarch64
    CPU上**工作**（并自动检测）。
- en: Do note, though, that I am still working on this utility; it's currently under
    development... there are several caveats. Feedback and contributions are most
    appreciated!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我仍在开发此实用程序...目前仍有一些注意事项。欢迎反馈和贡献！
- en: 'Download/clone it from [https://github.com/kaiwan/procmap](https://github.com/kaiwan/procmap):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://github.com/kaiwan/procmap](https://github.com/kaiwan/procmap)下载/克隆它：
- en: '![](img/c6518827-5c73-4216-8c8d-3dfb7675c5c1.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c6518827-5c73-4216-8c8d-3dfb7675c5c1.png)'
- en: Figure 1.10 – A partial screenshot of the procmap utility's output, showing
    only the top portion of kernel VAS on x86_64
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10- procmap实用程序输出的部分截图，仅显示x86_64内核VAS的顶部部分
- en: We make good use of this utility in [Chapter 7](06ee05b5-3e71-482d-93b8-235c27ce23bc.xhtml),
    *Memory Management Internals - Essentials*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第7章](06ee05b5-3e71-482d-93b8-235c27ce23bc.xhtml)中充分利用了这个实用程序，*内存管理内部-基础*。
- en: Simple Embedded ARM Linux System FOSS project
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的嵌入式ARM Linux系统FOSS项目
- en: '**SEALS** or **Simple Embedded ARM Linux System** is a very simple "skeleton"
    Linux base system running on an emulated ARM machine. It provides a primary Bash
    script that asks the end user what functionality they want via a menu, then accordingly
    proceeds to cross-compile a Linux kernel for ARM, then creates and initializes
    a simple root filesystem. It can then call upon QEMU ( `qemu-system-arm`) to emulate
    and run an ARM platform (the Versatile Express CA-9 is the default board emulated).
    The useful thing is, the script builds the target kernel, the root filesystem,
    and the root filesystem image file, and sets things up for boot. It even has a
    simple GUI (or console) frontend, to make usage a bit simpler for the end user. The
    project''s GitHub page is here: [https://github.com/kaiwan/seals/](https://github.com/kaiwan/seals/).
    Clone it and give it a try... we definitely recommend you have a look at its wiki
    section pages at [https://github.com/kaiwan/seals/wiki](https://github.com/kaiwan/seals/wiki) for
    help.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**SEALS**或**Simple Embedded ARM Linux System**是一个非常简单的“骨架”Linux基本系统，运行在模拟的ARM机器上。它提供了一个主要的Bash脚本，通过菜单询问最终用户需要什么功能，然后相应地继续为ARM交叉编译Linux内核，然后创建和初始化一个简单的根文件系统。然后可以调用QEMU（`qemu-system-arm`）来模拟和运行ARM平台（Versatile
    Express CA-9是默认的模拟板）。有用的是，该脚本构建目标内核、根文件系统和根文件系统映像文件，并设置引导。它甚至有一个简单的GUI（或控制台）前端，以使最终用户的使用变得更简单一些。该项目的GitHub页面在这里：[https://github.com/kaiwan/seals/](https://github.com/kaiwan/seals/)。克隆它并试试看...我们强烈建议您查看其wiki部分页面以获取帮助。'
- en: Modern tracing and performance analysis with [e]BPF
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用[e]BPF进行现代跟踪和性能分析
- en: An extension of the well-known**Berkeley Packet Filter** or **BPF**, **eBPF**is
    the **extended BPF***.* (FYI, modern usage of the term is simply to refer to it
    as **BPF**, dropping the 'e' prefix).Very briefly, BPF used to provide the supporting
    infrastructure within the kernel to effectively trace network packets. BPF is
    a very recent kernel innovation – available only from the Linux 4.0 kernel onward.
    It extends the BPF notion, allowing you to trace much more than just the network
    stack. Also, it works for tracing both kernel space as well as userspace apps.
    *In effect, BPF and its frontends are the modern approach to tracing and performance
    analysis on a Linux system*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 作为众所周知的**伯克利数据包过滤器**或**BPF**的扩展，**eBPF**是**扩展BPF**（顺便说一句，现代用法是简单地将其称为**BPF**，去掉前缀'e'）。简而言之，BPF用于在内核中提供支持基本上是为了有效地跟踪网络数据包。BPF是非常近期的内核创新-仅从Linux
    4.0内核开始可用。它扩展了BPF的概念，允许您跟踪的不仅仅是网络堆栈。此外，它适用于跟踪内核空间和用户空间应用程序。*实际上，BPF及其前端是在Linux系统上进行跟踪和性能分析的现代方法*。
- en: 'To use BPF, you will need a system with the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用BPF，您需要具有以下系统：
- en: Linux kernel 4.0 or later
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核4.0或更高版本
- en: Kernel support for BPF ([https://github.com/iovisor/bcc/blob/master/INSTALL.md#kernel-configuration](https://github.com/iovisor/bcc/blob/master/INSTALL.md#kernel-configuration))
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BPF的内核支持（[https://github.com/iovisor/bcc/blob/master/INSTALL.md#kernel-configuration](https://github.com/iovisor/bcc/blob/master/INSTALL.md#kernel-configuration)）
- en: 'The **BCC** or `bpftrace` frontends installed (link to install them on popular
    Linux distributions: [https://github.com/iovisor/bcc/blob/master/INSTALL.md#installing-bcc](https://github.com/iovisor/bcc/blob/master/INSTALL.md#installing-bcc))'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装**BCC**或`bpftrace`前端（在流行的Linux发行版上安装它们的链接：[https://github.com/iovisor/bcc/blob/master/INSTALL.md#installing-bcc](https://github.com/iovisor/bcc/blob/master/INSTALL.md#installing-bcc)）
- en: Root access on the target system
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标系统上的根访问权限
- en: 'Using the BPF kernel feature directly is very hard, so there are several easier
    front ends to use. Among them, BCC and `bpftrace` are regarded as useful. Check
    out the following link to a picture that opens your eyes to just how many powerful
    BCC tools are available to help trace different Linux subsystems and hardware:
    [https://github.com/iovisor/bcc/blob/master/images/bcc_tracing_tools_2019.png](https://github.com/iovisor/bcc/blob/master/images/bcc_tracing_tools_2019.png).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用BPF内核功能非常困难，因此有几个更容易的前端可供使用。其中，BCC和`bpftrace`被认为是有用的。查看以下链接，了解有多少强大的BCC工具可用于帮助跟踪不同的Linux子系统和硬件：[https://github.com/iovisor/bcc/blob/master/images/bcc_tracing_tools_2019.png](https://github.com/iovisor/bcc/blob/master/images/bcc_tracing_tools_2019.png)。
- en: 'Important: You can install the BCC tools for your regular host Linux distro
    by reading the installation instructions here: [https://github.com/iovisor/bcc/blob/master/INSTALL.md](https://github.com/iovisor/bcc/blob/master/INSTALL.md). Why
    not on our guest Linux VM? You can, when running a distro kernel (such as an Ubuntu-
    or Fedora-supplied kernel). The reason: the installation of the BCC toolset includes
    (and depends upon) the installation of the `linux-headers-$(uname -r)` package;
    this `linux-headers` package exists *only for* distro kernels (and not for our
    custom 5.4 kernel that we shall often be running on the guest).'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：您可以通过阅读此处的安装说明在您的常规主机Linux发行版上安装BCC工具：[https://github.com/iovisor/bcc/blob/master/INSTALL.md](https://github.com/iovisor/bcc/blob/master/INSTALL.md)。为什么不能在我们的Linux
    VM上安装？当运行发行版内核（如Ubuntu或Fedora提供的内核）时，您可以。原因是：BCC工具集的安装包括（并依赖于）`linux-headers-$(uname
    -r)`包的安装；这个`linux-headers`包仅适用于发行版内核（而不适用于我们经常在客人上运行的自定义5.4内核）。
- en: The main site for BCC can be found at [https://github.com/iovisor/bcc](https://github.com/iovisor/bcc).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: BCC的主要网站可以在[https://github.com/iovisor/bcc](https://github.com/iovisor/bcc)找到。
- en: The LDV - Linux Driver Verification - project
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LDV - Linux驱动程序验证 - 项目
- en: The Russian Linux Verification Center, founded in 2005, is an opensource project;
    it has specialists in, and thus specializes in, automated testing of complex software
    projects. This includes comprehensive test suites, frameworks, and detailed analyses
    (both static and dynamic) being performed on the core Linux kernel as well as on
    the primarily device drivers within the kernel. This project puts a great deal
    of focus on the testing and verification of *kernel modules* as well, which many
    similar projects tend to skim.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 成立于2005年的俄罗斯Linux验证中心是一个开源项目；它拥有专家，并因此专门从事复杂软件项目的自动化测试。这包括在核心Linux内核以及主要的内核内设备驱动程序上执行的全面测试套件、框架和详细分析（静态和动态）。该项目还非常注重对*内核模块*的测试和验证，而许多类似的项目往往只是粗略地涉及。
- en: 'Of particular interest to us here is the Online Linux Driver Verification Service
    page ([http://linuxtesting.org/ldv/online?action=rules](http://linuxtesting.org/ldv/online?action=rules));
    it contains a list of a few verified Rules (Figure 1.11):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别感兴趣的是在线Linux驱动程序验证服务页面([http://linuxtesting.org/ldv/online?action=rules](http://linuxtesting.org/ldv/online?action=rules))；它包含了一些经过验证的规则（图1.11）：
- en: '![](img/e0e68bf6-a2d9-4bb0-b09e-cc02a2bf32da.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0e68bf6-a2d9-4bb0-b09e-cc02a2bf32da.png)'
- en: Figure 1.11 – Screenshot of the 'Rules' page of the Linux Driver Verification
    (LDV) project site
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 - Linux驱动程序验证（LDV）项目网站的“规则”页面的屏幕截图
- en: By glancing through these rules, we'll be able to not only see the rule but
    also instances of actual cases where these rules were violated by driver/kernel
    code within the mainline kernel, thus introducing bugs. The LDV project has successfully
    discovered and fixed (by sending in patches in the usual manner) several driver/kernel
    bugs. In a few of the upcoming chapters, we shall mention instances of these LDV
    rule violations (for example, memory leakage, **Use After Free** (**UAF**) bugs,
    and locking violations) having been uncovered, and (probably) even fixed.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通过浏览这些规则，我们不仅能够看到规则，还能看到这些规则在主线内核中被驱动程序/内核代码违反的实际案例，从而引入了错误。LDV项目已成功发现并修复（通过通常方式发送补丁）了几个驱动程序/内核错误。在接下来的几章中，我们将提到这些LDV规则违反的实例（例如，内存泄漏，**使用后释放**（UAF）错误和锁定违规）已经被发现，并（可能）已经修复。
- en: 'Here are some useful links on the LDV website:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是LDV网站上一些有用的链接：
- en: The Linux Verification Center home page; [http://linuxtesting.org/](http://linuxtesting.org/)
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux验证中心主页；[http://linuxtesting.org/](http://linuxtesting.org/)
- en: Linux Kernel Space Verification; [http://linuxtesting.org/kernel](http://linuxtesting.org/kernel)
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核空间验证；[http://linuxtesting.org/kernel](http://linuxtesting.org/kernel)
- en: Online Linux Driver Verification Service page **with verified Rules** : [http://linuxtesting.org/ldv/online?action=rules](http://linuxtesting.org/ldv/online?action=rules)
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线Linux驱动程序验证服务页面**具有经过验证的规则**：[http://linuxtesting.org/ldv/online?action=rules](http://linuxtesting.org/ldv/online?action=rules)
- en: '*Problems in Linux Kernel* page; lists over 400 issues found in existing drivers
    (mostly fixed as well); [http://linuxtesting.org/results/ldv](http://linuxtesting.org/results/ldv)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux内核中的问题*页面；列出了现有驱动程序中发现的400多个问题（大部分也已经修复）；[http://linuxtesting.org/results/ldv](http://linuxtesting.org/results/ldv)'
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered in detail the hardware and software requirements
    to set up an appropriate development environment for beginning to work on Linux
    kernel development. In addition, we mentioned the basics and provided links, wherever
    appropriate, for setting up a Raspberry Pi device, installing powerful tools such
    as QEMU and a cross toolchain, and so on. We also threw some light on other "miscellaneous"
    tools and projects that you, as a budding kernel and/or device driver developer,
    might find useful, as well as information on how to begin looking up kernel documentation.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了设置适当的开发环境的硬件和软件要求，以便开始进行Linux内核开发。此外，我们提到了基础知识，并在适当的地方提供了设置树莓派设备、安装强大工具如QEMU和交叉工具链等的链接。我们还介绍了其他一些“杂项”工具和项目，作为一个新手内核和/或设备驱动程序开发人员，您可能会发现这些工具和如何开始查找内核文档的信息很有用。
- en: In this book, we definitely recommend and expect you to try out and work on
    kernel code in a hands-on fashion. To do so, you must have a proper kernel workspace
    environment set up, which we have successfully done in this chapter.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们强烈建议并期望您以实际操作的方式尝试并开展内核代码的工作。为此，您必须设置一个适当的内核工作空间环境，我们在本章中已经成功完成了这一点。
- en: Now that our environment is ready, let's move on and explore the brave world
    of Linux kernel development! The next two chapters will teach you how to download,
    extract, configure, and build a Linux kernel from source.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的环境已经准备好，让我们继续探索Linux内核开发的广阔世界吧！接下来的两章将教您如何从源代码下载、提取、配置和构建Linux内核。
- en: Questions
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions).
    You will find some of the questions answered in the book''s GitHub repo: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一些问题供您测试对本章材料的了解：[https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions)。您会发现一些问题的答案在书的GitHub存储库中：[https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn)。
- en: Further reading
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To help you delve deeper into the subject with useful materials, we provide
    a rather detailed list of online references and links (and at times, even books)
    in a Further reading document in this book's GitHub repository. The *Further reading*
    document is available here: [https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md](https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您深入了解这个主题并提供有用的材料，我们在本书的GitHub存储库中提供了一个相当详细的在线参考和链接列表（有时甚至包括书籍）。*进一步阅读*文档在这里可用：[https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md](https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md)。
