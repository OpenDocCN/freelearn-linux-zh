["```\n#!/bin/bash\n\n# Housekeeping...\nrm -f /tmp/ramdisk.img\nrm -f /tmp/ramdisk.img.gz\n\n# Ramdisk Constants\nRDSIZE=4000\nBLKSIZE=1024\n\n# Create an empty ramdisk image\ndd if=/dev/zero of=/tmp/ramdisk.img bs=$BLKSIZE count=$RDSIZE\n\n# Make it an ext2 mountable file system\n/sbin/mke2fs -F -m 0 -b $BLKSIZE /tmp/ramdisk.img $RDSIZE\n\n# Mount it so that we can populate\nmount /tmp/ramdisk.img /mnt/initrd -t ext2 -o loop=/dev/loop0\n\n# Populate the filesystem (subdirectories)\nmkdir /mnt/initrd/bin\nmkdir /mnt/initrd/sys\nmkdir /mnt/initrd/dev\nmkdir /mnt/initrd/proc\n\n# Grab busybox and create the symbolic links\npushd /mnt/initrd/bin\ncp /usr/local/src/busybox-1.1.1/busybox .\nln -s busybox ash\nln -s busybox mount\nln -s busybox echo\nln -s busybox ls\nln -s busybox cat\nln -s busybox ps\nln -s busybox dmesg\nln -s busybox sysctl\npopd\n\n# Grab the necessary dev files\ncp -a /dev/console /mnt/initrd/dev\ncp -a /dev/ramdisk /mnt/initrd/dev\ncp -a /dev/ram0 /mnt/initrd/dev\ncp -a /dev/null /mnt/initrd/dev\ncp -a /dev/tty1 /mnt/initrd/dev\ncp -a /dev/tty2 /mnt/initrd/dev\n\n# Equate sbin with bin\npushd /mnt/initrd\nln -s bin sbin\npopd\n\n# Create the init file\ncat >> /mnt/initrd/linuxrc << EOF\n#!/bin/ash\necho\necho \"Simple initrd is active\"\necho\nmount -t proc /proc /proc\nmount -t sysfs none /sys\n/bin/ash --login\nEOF\n\nchmod +x /mnt/initrd/linuxrc\n\n# Finish up...\numount /mnt/initrd\ngzip -9 /tmp/ramdisk.img\ncp /tmp/ramdisk.img.gz /boot/ramdisk.img.gz\n\n```", "```\n/*\n  * We try each of these until one succeeds.\n  *\n  * The Bourne shell can be used instead of init if we are\n  * trying to recover a really broken machine.\n  */\n  if (execute_command) {\n    ret = run_init_process(execute_command);\n    if (!ret)\n      return 0;\n    pr_err(\"Failed to execute %s (error %d).  Attempting defaults...\\n\",execute_command, ret);\n  }\n  if (!try_to_run_init_process(\"/sbin/init\") ||\n    !try_to_run_init_process(\"/etc/init\") ||\n    !try_to_run_init_process(\"/bin/init\") ||\n    !try_to_run_init_process(\"/bin/sh\"))\n      return 0;\n\n  panic(\"No working init found.  Try passing init= option to kernel.\" \"See Linux Documentation/init.txt for guidance.\");\n```", "```\n# /etc/inittab: init(8) configuration.\n# $Id: inittab,v 1.91 2002/01/25 13:35:21 miquels Exp $\n\n# The default runlevel.\nid:5:initdefault:\n\n# Boot-time system configuration/initialization script.\n# This is run first except when booting in emergency (-b) mode.\nsi::sysinit:/etc/init.d/rcS\n\n# What to do in single-user mode.\n~~:S:wait:/sbin/sulogin\n\n# /etc/init.d executes the S and K scripts upon change\n# of runlevel.\n#\n# Runlevel 0 is halt.\n# Runlevel 1 is single-user.\n# Runlevels 2-5 are multi-user.\n# Runlevel 6 is reboot.\n\nl0:0:wait:/etc/init.d/rc 0\nl1:1:wait:/etc/init.d/rc 1\nl2:2:wait:/etc/init.d/rc 2\nl3:3:wait:/etc/init.d/rc 3\nl4:4:wait:/etc/init.d/rc 4\nl5:5:wait:/etc/init.d/rc 5\nl6:6:wait:/etc/init.d/rc 6\n# Normally not reached, but fallthrough in case of emergency.\nz6:6:respawn:/sbin/sulogin\nS0:12345:respawn:/sbin/getty 115200 ttyS0\n# /sbin/getty invocations for the runlevels.\n#\n# The \"id\" field MUST be the same as the last\n# characters of the device (after \"tty\").\n#\n# Format:\n#  <id>:<runlevels>:<action>:<process>\n#\n\n1:2345:respawn:/sbin/getty 38400 tty1\n```", "```\nUsage: busybox [function] [arguments]...\n or: [function] [arguments]...\n\n BusyBox is a multi-call binary that combines many common Unix\n utilities into a single executable.  Most people will create a\n link to busybox for each function they wish to use and BusyBox\n will act like whatever it was invoked as!\n\nCurrently defined functions:\n [, [[, arping, ash, awk, basename, bunzip2, busybox, bzcat, cat,\n chgrp, chmod, chown, chroot, clear, cp, crond, crontab, cut, date,\n dd, df, dirname, dmesg, du, echo, egrep, env, expr, false, fgrep,\n find, free, grep, gunzip, gzip, halt, head, hexdump, hostid, hostname,\n id, ifconfig, init, insmod, ipcalc, ipkg, kill, killall, killall5,\n klogd, length, ln, lock, logger, logread, ls, lsmod, md5sum, mesg,\n mkdir, mkfifo, mktemp, more, mount, mv, nc, \"netmsg\", netstat,\n nslookup, passwd, pidof, ping, pivot_root, poweroff, printf, ps,\n pwd, rdate, reboot, reset, rm, rmdir, rmmod, route, sed, seq,\n sh, sleep, sort, strings, switch_root, sync, sysctl, syslogd,\n tail, tar, tee, telnet, test, time, top, touch, tr, traceroute,\n true, udhcpc, umount, uname, uniq, uptime, vi, wc, wget, which,\n xargs, yes, zcat\n\n```", "```\nlinux-gate.so.1 (0xb7785000)\nlibc.so.6 => /lib/libc.so.6 (0x4273b000)\n/lib/ld-linux.so.2 (0x42716000)\n\n```", "```\nlib\n|-- ld-2.3.2.so\n|-- ld-linux.so.2 -> ld-2.3.2.so\n|-- libc-2.3.2.so\n'-- libc.so.6 -> libc-2.3.2.so\n\n```", "```\nbin\n|-- busybox\n'-- sh -> busybox\n\n```", "```\netc\n'-- init.d\n '-- rcS\n\n```", "```\ndev\n'-- console\n\n```", "```\nSUMMARY = \"A small image just capable of allowing a device to boot.\"\n\nIMAGE_INSTALL = \"packagegroup-core-boot ${ROOTFS_PKGMANAGE_BOOTSTRAP} ${CORE_IMAGE_EXTRA_INSTALL} ldd\"\n\nIMAGE_LINGUAS = \" \"\n\nLICENSE = \"MIT\"\n\ninherit core-image\n\nIMAGE_ROOTFS_SIZE ?= \"8192\"\n\n```", "```\nDESCRIPTION = \"An image for network and communication.\"\nLICENSE = \"MIT\"\nPR = \"r1\"\n\nrequire atmel-demo-image.inc\n\nIMAGE_INSTALL += \"\\\n    packagegroup-base-3g \\\n    packagegroup-base-usbhost \\\n    \"\n```"]