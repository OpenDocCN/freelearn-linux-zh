- en: Clock and Time Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时钟和时间管理
- en: The Linux time management subsystem manages various time-related activities
    and keeps track of timing data such as current time and date, time elapsed since
    system boot up (system uptime) and timeouts, for example, how long to wait for
    a particular event to be initiated or terminated, locking the system after a timeout
    period has elapsed, or raising a signal to kill an unresponsive process.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Linux时间管理子系统管理各种与时间相关的活动，并跟踪时间数据，如当前时间和日期、自系统启动以来经过的时间（系统正常运行时间）和超时，例如，等待特定事件启动或终止的时间、在超时后锁定系统，或引发信号以终止无响应的进程。
- en: 'There are two types of timing activities handled by the Linux time management
    subsystem:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Linux时间管理子系统处理两种类型的定时活动：
- en: Keeping the current time and date
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪当前时间和日期
- en: Maintaining timers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护定时器
- en: Time representation
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间表示
- en: 'Depending on the use cases, time is represented in three different ways in
    Linux:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 根据使用情况，Linux以三种不同的方式表示时间：
- en: '**Wall time (or real time):** This is the actual time and date in the real
    world, such as 07:00 AM, 10 Aug 2017, and is used for timestamps on files and
    packets sent through the network.'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**墙上时间（或实时时间）：**这是真实世界中的实际时间和日期，例如2017年8月10日上午07:00，用于文件和通过网络发送的数据包的时间戳。'
- en: '**Process time:** This is the time consumed by a process in its life span.
    It includes the time consumed by the process in user mode and the time consumed
    by the kernel code when executing on behalf of the process. This is useful for
    statistical purposes, auditing, and profiling.'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**进程时间：**这是进程在其生命周期中消耗的时间。它包括进程在用户模式下消耗的时间以及内核代码在代表进程执行时消耗的时间。这对于统计目的、审计和分析很有用。'
- en: '**Monotonic time:** This is the time elapsed since system bootup. It''s ever
    incrementing and monotonic in nature (system uptime).'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单调时间：**这是自系统启动以来经过的时间。它是不断增加且单调的（系统正常运行时间）。'
- en: 'These three times are measured in either of the following ways:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种时间可以用以下任一方式来衡量：
- en: '**Relative time:** This is the time relative to some specific event, such as
    7 minutes since system bootup, or 2 minutes since last input from user.'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**相对时间：**这是相对于某个特定事件的时间，例如自系统启动以来的7分钟，或自用户上次输入以来的2分钟。'
- en: '**Absolute time:** This is a unique point in time without any reference to
    a previous event, such as 10:00 AM, 12 Aug 2017\. In Linux, absolute time is represented
    as the number of elapsed seconds since 00:00:00 midnight of 1 January 1970 (UTC)'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**绝对时间：**这是没有任何参考先前事件的唯一时间点，例如2017年8月12日上午10:00。在Linux中，绝对时间表示为自1970年1月1日午夜00:00:00（UTC）以来经过的秒数。'
- en: Wall time is ever incrementing (unless it has been modified by the user), even
    between reboots and shutdowns, but process time and system uptime start from some
    predefined point in time (*usually zero*) every time a new process is created
    or when the system starts.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 墙上的时间是不断增加的（除非用户修改了它），即使在重新启动和关机之间，但进程时间和系统正常运行时间始于某个预定义的时间点（*通常为零*），每次创建新进程或系统启动时。
- en: Timing hardware
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计时硬件
- en: 'Linux relies on appropriate hardware devices to maintain time. These hardware
    devices can be categorized broadly into two types: system clock and timers.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Linux依赖于适当的硬件设备来维护时间。这些硬件设备可以大致分为两类：系统时钟和定时器。
- en: Real-time clock (RTC)
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时时钟（RTC）
- en: Keeping track of the current time and date is very crucial, not just to let
    the user know about it but to use it as a timestamp for various resources in the
    system, specifically, files present in secondary storage. Every file has metadata
    information such as the date of creation and last modification date, and every
    time a file is created or modified, these two fields are updated with the current
    time in the system. These fields are used by several apps to manage files such
    as to sort, group, or even delete them (if the file hasn't been accessed a for
    long time). The *make* tool uses this timestamp to determine whether a source
    file has been edited since the last time it accessed it; only then is it compiled,
    otherwise left untouched.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪当前时间和日期非常重要，不仅是为了让用户了解时间，还可以将其用作系统中各种资源的时间戳，特别是存储在辅助存储器中的文件。每个文件都有元数据信息，如创建日期和最后修改日期，每当创建或修改文件时，这两个字段都会使用系统中的当前时间进行更新。这些字段被多个应用程序用于管理文件，例如排序、分组，甚至删除（如果文件长时间未被访问）。*make*工具使用此时间戳来确定自上次访问以来源文件是否已被编辑；只有在这种情况下才会对其进行编译，否则保持不变。
- en: The system clock RTC keeps track of the current time and date; backed by an
    additional battery, it continues to tick even when the system is turned off.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 系统时钟RTC跟踪当前时间和日期；由额外的电池支持，即使系统关闭，它也会继续运行。
- en: RTC can raise interrupts on IRQ8 periodically. This feature can be used as an
    alarm facility, by programming the RTC to raise interrupt on IRQ8 when it reaches
    a specific time. In IBM-compatible PCs, the RTC is mapped to the 0x70 and 0x71
    I/O ports. It can be accessed through the `/dev/rtc` device file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: RTC可以定期在IRQ8上引发中断。通过编程RTC在达到特定时间时在IRQ8上引发中断，可以将此功能用作警报设施。在兼容IBM的个人电脑中，RTC被映射到0x70和0x71
    I/O端口。可以通过`/dev/rtc`设备文件访问它。
- en: Timestamp counter (TSC)
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间戳计数器（TSC）
- en: This is a counter implemented in every x86 microprocessor by means of a 64-bit
    register called TSC the register. It counts the number of clock signals arriving
    on the CLK pin of the processor. The current counter value can be read by accessing
    the TSC register. The number of ticks counted per second can be calculated as
    1/(clock frequency); for a 1 GHz clock it translates to once every nanosecond.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过64位寄存器TSC实现的计数器，每个x86微处理器都有，该寄存器称为TSC寄存器。它计算处理器的CLK引脚上到达的时钟信号数量。可以通过访问TSC寄存器来读取当前计数器值。每秒计数的时钟信号数可以计算为1/(时钟频率)；对于1
    GHz时钟，这相当于每纳秒一次。
- en: 'Knowing the duration between two consecutive ticks is very crucial. The fact
    that one processor clock''s frequency might not be the same as others makes it
    vary across processors. CPU clock frequency is calculated during system boot by
    the `calibrate_tsc()` callback routine of the x86_platform_ops structure defined
    in the `arch/x86/include/asm/x86_init.h` header file:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 知道两个连续tick之间的持续时间非常关键。一个处理器时钟的频率可能与其他处理器不同，这使得它在处理器之间变化。CPU时钟频率是在系统引导期间通过`calibrate_tsc()`回调例程计算的，该例程定义在`arch/x86/include/asm/x86_init.h`头文件中的`x86_platform_ops`结构中：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This data structure manages other timing operations too, such as getting time
    from the RTC through `get_wallclock()` or setting time on the RTC through the
    `set_wallclock()` callback.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据结构还管理其他计时操作，比如通过`get_wallclock()`从RTC获取时间或通过`set_wallclock()`回调在RTC上设置时间。
- en: Programmable interrupt timer (PIT)
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可编程中断定时器（PIT）
- en: 'There are certain tasks that need to be carried out by the kernel at regular
    intervals, such as:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 内核需要定期执行某些任务，比如：
- en: Updating the current time and date (at midnight)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新当前时间和日期（在午夜）
- en: Updating the system running time (uptime)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新系统运行时间（正常运行时间）
- en: Keeping track of the time consumed by each process so that they don't exceed
    the time allotted to run on the CPU
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪每个进程消耗的时间，以便它们不超过分配给CPU运行的时间
- en: Keeping track of various timer activities
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪各种计时器活动
- en: In order to carry out these tasks, interrupts must be periodically raised. Every
    time this periodic interrupt is raised, the kernel knows it's time to update the
    aforementioned timing data. The PIT is the piece of hardware responsible for issuing
    this periodic interrupt, called timer interrupt. The PIT keeps on issuing timer
    interrupts on IRQ0 periodically at approximately 1000 Hz frequency, once every
    millisecond. This periodic interrupt is called the **tick** and the frequency
    at which it's issued is called the **tick rate**. The tick rate frequency is defined
    by the kernel macro **HZ** and is measured in hertz.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这些任务，必须定期引发中断。每次引发这种周期性中断时，内核都知道是时候更新前面提到的时间数据了。PIT是负责发出这种周期性中断的硬件部件，称为定时器中断。PIT会以大约1000赫兹的频率在IRQ0上定期发出定时器中断，即每毫秒一次。这种周期性中断称为**tick**，发出的频率称为**tick
    rate**。tick rate频率由内核宏**HZ**定义，以赫兹为单位。
- en: 'System responsiveness depends on the tick rate: the shorter the ticks, the
    more responsive a system would be, and vice versa. With shorter ticks, `poll()`
    and `select()` system calls will have a faster response time. However, the considerable
    drawback of a shorter tick rate is that the CPU will be working in kernel mode
    (executing the interrupt handler for the timer interrupt) most of the time, leaving
    less time for user-mode code (programs) to execute on it. In a high-performance
    CPU, it wouldn''t be much of an overhead, but in slower CPUs, the overall system
    performance would be affected considerably.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 系统响应性取决于tick rate：tick越短，系统的响应性就越高，反之亦然。使用较短的tick，`poll()`和`select()`系统调用将具有更快的响应时间。然而，较短的tick
    rate的相当大缺点是CPU将在内核模式下工作（执行定时器中断的中断处理程序）大部分时间，留下较少的时间供用户模式代码（程序）在其上执行。在高性能CPU中，这不会产生太多开销，但在较慢的CPU中，整体系统性能会受到相当大的影响。
- en: To reach a balance between response time and system performance, a tick rate
    of 100 Hz is used in most machines. Except for *Alpha* and *m68knommu*, which
    use a 1000 Hz tick rate, the rest of the common architectures, including *x86*
    (arm, powerpc, sparc, mips, and so on) use a 100 Hz tick rate. Common PIT hardware
    found in *x86* machines is Intel 8253\. It's I/O mapped and accessed through addresses
    0x40 – 0x43\. The PIT is initialized by `setup_pit_timer()`, defined in the `arch/x86/kernel/i8253.c`
    file*:*
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在响应时间和系统性能之间取得平衡，在大多数机器上使用了100赫兹的tick rate。除了*Alpha*和*m68knommu*使用1000赫兹的tick
    rate外，其余常见架构，包括*x86*（arm、powerpc、sparc、mips等），使用了100赫兹的tick rate。在*x86*机器中找到的常见PIT硬件是Intel
    8253。它是I/O映射的，并通过地址0x40-0x43进行访问。PIT由`setup_pit_timer()`初始化，定义在`arch/x86/kernel/i8253.c`文件中。
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This calls `clockevent_i8253_init()` internally, defined in `<drivers/clocksource/i8253.c>`*:*
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这在内部调用`clockevent_i8253_init()`，定义在`<drivers/clocksource/i8253.c>`中：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: CPU local timer
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU本地定时器
- en: PIT is a global timer, and interrupts raised by it that can be handled by any
    CPU in an SMP system. In some cases, having such a common timer is beneficial,
    whereas in other cases, a per-CPU timer is more desirable. In an SMP system, keeping
    process time and monitoring allotted time slices to a process in each CPU would
    be much easier and efficient with a local timer.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: PIT是一个全局定时器，由它引发的中断可以由SMP系统中的任何CPU处理。在某些情况下，拥有这样一个共同的定时器是有益的，而在其他情况下，每CPU定时器更可取。在SMP系统中，保持进程时间并监视每个CPU中进程的分配时间片将更加容易和高效。
- en: Local APIC in recent x86 microprocessors embeds such a CPU local timer. A CPU
    local timer can issue interrupts either once or periodically. It uses a 32-bit
    timer and can issue interrupts at a very low frequency (this wider counter allows
    more ticks to occur before an interrupt is raised). The APIC timer works with
    the bus clock signal. The APIC timer is quite similar to PIT except that it's
    local to the CPU, has a 32-bit counter (PIT has a 16-bit one), and works with
    the bus clock signal (PIT uses its own clock signal).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的x86微处理器中的本地APIC嵌入了这样一个CPU本地定时器。CPU本地定时器可以发出一次或定期中断。它使用32位计时器，可以以非常低的频率发出中断（这个更宽的计数器允许更多的tick发生在引发中断之前）。APIC定时器与总线时钟信号一起工作。APIC定时器与PIT非常相似，只是它是本地CPU的，有一个32位计数器（PIT有一个16位计数器），并且与总线时钟信号一起工作（PIT使用自己的时钟信号）。
- en: High-precision event timer (HPET)
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高精度事件定时器（HPET）
- en: The HPET works with clock signals in excess of 10 Mhz, issuing interrupts once
    every 100 nano seconds, hence the name high-precision. HPET implements a 64-bit
    main counter to count at such a high frequency. It was co-developed by Intel and
    Microsoft for the need of a new high-resolution timer. HPET embeds a collection
    of timers. Each of them is capable of issuing interrupts independently, and can
    be used by specific applications as assigned by the kernel. These timers are managed
    as groups of timers, where each group can have a maximum of 32 timers in it. An
    HPET can implement maximum of 8 such groups. Each timer has a set of *comparator*
    and *match register***.** A timer issues an interrupt when the value in its match
    register matches the value of the main counter. Timers can be programmed to generate
    interrupts either once or periodically.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: HPET使用超过10 Mhz的时钟信号，每100纳秒发出一次中断，因此被称为高精度。HPET实现了一个64位的主计数器，以如此高的频率进行计数。它是由英特尔和微软共同开发的，用于需要新的高分辨率计时器。HPET嵌入了一组定时器。每个定时器都能够独立发出中断，并可以由内核分配给特定应用程序使用。这些定时器被管理为定时器组，每个组最多可以有32个定时器。一个HPET最多可以实现8个这样的组。每个定时器都有一组*比较器*和*匹配寄存器*。当定时器的匹配寄存器中的值与主计数器的值匹配时，定时器会发出中断。定时器可以被编程为定期或周期性地生成中断。
- en: Registers are memory mapped and have relocatable address space. During system
    bootup, the BIOS sets up the registers' address space and passes it to the kernel.
    Once the BIOS maps the address, it's seldom remapped by the kernel.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器是内存映射的，并具有可重定位的地址空间。在系统引导期间，BIOS设置寄存器的地址空间并将其传递给内核。一旦BIOS映射了地址，内核就很少重新映射它。
- en: ACPI power management timer (ACPI PMT)
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ACPI电源管理计时器（ACPI PMT）
- en: The ACPI PMT is a simple counter that has a fixed frequency clock at 3.58 Mhz.
    It increments on each tick. The PMT is port mapped; the BIOS takes care of address
    mapping in the hardware initialization phase during bootup. The PMT is more reliable
    than the TSC, as it works with a constant clock frequency. The TSC depends on
    the CPU clock, which can be underclocked or overclocked as per the current load,
    resulting in time dilation and inaccurate measurements. Among all, the HPET is
    preferable since it allows very short time intervals if present in the system.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ACPI PMT是一个简单的计数器，具有固定频率时钟，为3.58 Mhz。它在每个时钟脉冲上递增。PMT是端口映射的；BIOS在引导期间的硬件初始化阶段负责地址映射。PMT比TSC更可靠，因为它使用恒定的时钟频率。TSC依赖于CPU时钟，根据当前负载可以被降频或超频，导致时间膨胀和不准确的测量。在所有情况下，HPET是首选，因为它允许系统中存在非常短的时间间隔。
- en: Hardware abstraction
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬件抽象
- en: 'Every system has at least one clock counter. As with any hardware device in
    a machine, this counter too is represented and managed by a structure. Hardware
    abstraction is provided by `struct clocksource`**,** defined in the `include/linux/clocksource.h`
    header file. This structure provides callbacks to access and handle power management
    on the counter through the `read`, `enable`, `disable`, `suspend`, and `resume`
    routines:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统至少有一个时钟计数器。与机器中的任何硬件设备一样，这个计数器也由一个结构表示和管理。硬件抽象由`include/linux/clocksource.h`头文件中定义的`struct
    clocksource`提供。该结构提供了回调函数来通过`read`、`enable`、`disable`、`suspend`和`resume`例程访问和处理计数器的电源管理：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Members `mult` and `shift` are useful in obtaining elapsed time in relevant
    units.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 成员`mult`和`shift`对于获取相关单位的经过时间非常有用。
- en: Calculating elapsed time
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算经过的时间
- en: 'Until this point we know that in every system there is a free-running, ever-incrementing
    counter, and all time is derived from it, be it wall time or any duration. The
    most natural idea here to calculate the time (seconds elapsed since the start
    of counter) would be dividing the number of cycles provided by this counter with
    the clock frequency, as expressed in the following formula:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道在每个系统中都有一个自由运行的、不断递增的计数器，并且所有时间都是从中派生的，无论是墙上的时间还是任何持续时间。在这里计算时间（自计数器启动以来经过的秒数）的最自然的想法是将这个计数器提供的周期数除以时钟频率，如下式所示：
- en: Time (seconds) = (counter value)/(clock frequency)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 时间（秒）=（计数器值）/（时钟频率）
- en: 'There is a catch with this approach, however: it involves division (which works
    on an iterative algorithm, making it the slowest among the four basic arithmetic
    operations) and floating point calculations, which might be slower on certain
    architectures. While working with embedded platforms, floating point calculations
    are evidently slower than they are on PC or server platforms.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法有一个问题：它涉及除法（它使用迭代算法，使其成为四种基本算术运算中最慢的）和浮点计算，在某些体系结构上可能会更慢。在处理嵌入式平台时，浮点计算显然比在个人电脑或服务器平台上慢。
- en: 'So how do we overcome this issue? Instead of division, time is calculated using
    multiplication and bitwise shift operations. The kernel provides a helper routine
    that derives the time this way. `clocksource_cyc2ns()`, defined in `include/linux/clocksource.h`,
    converts the clocksource cycles to nanoseconds:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何解决这个问题呢？与其使用除法，不如使用乘法和位移操作来计算时间。内核提供了一个辅助例程，以这种方式推导时间。`include/linux/clocksource.h`中定义的`clocksource_cyc2ns()`将时钟源周期转换为纳秒：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, the parameter cycles is the number of elapsed cycles from the clock source,
    `mult` is the cycle-to-nanosecond multiplier, while `shift` is the cycle-to-nanosecond
    divisor (power of two). Both these parameters are clock source dependent. These
    values are provided by the clock source kernel abstraction discussed earlier.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，参数cycles是来自时钟源的经过的周期数，`mult`是周期到纳秒的乘数，而`shift`是周期到纳秒的除数（2的幂）。这两个参数都是时钟源相关的。这些值是由之前讨论的时钟源内核抽象提供的。
- en: Clock source hardware are not accurate all the time; their frequency might vary.
    This clock variation causes time drift (making the clock run faster or slower).
    In such cases, the variable *mult* can be adjusted to make up for this time drift.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟源硬件并非始终准确；它们的频率可能会变化。这种时钟变化会导致时间漂移（使时钟运行得更快或更慢）。在这种情况下，可以调整变量*mult*来弥补这种时间漂移。
- en: 'The helper routine `clocks_calc_mult_shift()`**,** defined in `kernel/time/clocksource.c`,
    helps evaluate `mult` and `shift` factors:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`kernel/time/clocksource.c`中定义的辅助例程`clocks_calc_mult_shift()`有助于评估`mult`和`shift`因子：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Time duration between two events can be calculated as shown in the following
    code snippet:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 两个事件之间的时间持续时间可以通过以下代码片段计算：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Linux timekeeping data structures, macros, and helper routines
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux时间保持数据结构、宏和辅助例程
- en: We will now broaden our awareness by looking at some key timekeeping structures,
    macros, and helper routines that can assist programmers in extracting specific
    time-related data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过查看一些关键的时间保持结构、宏和辅助例程来扩大我们的认识，这些可以帮助程序员提取特定的与时间相关的数据。
- en: Jiffies
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jiffies
- en: '*The* `jiffies` variable holds the number of ticks elapsed since system bootup.
    Every time a tick occurs, *jiffies* is incremented by one. It''s a 32-bit variable,
    meaning for a tick rate of 100 Hz, overflow will occur in approximately 497 days
    (and in 49 days, 17 hours for a 1000 Hz tick rate).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`jiffies`变量保存自系统启动以来经过的滴答数。每次发生滴答时，`jiffies`增加一。它是一个32位变量，这意味着对于100 Hz的滴答率，大约在497天后（对于1000
    Hz的滴答率，在49天17小时后）会发生溢出。'
- en: 'To overcome this issue, a 64-bit variable `jiffies_64` is used instead, which
    allows for thousands of millions of years before the overflow occurs. The `jiffies`
    variable is equated to the 32 least significant bits of `jiffies_64`. The reason
    for having both `jiffies` and `jiffies_64` variables is that in 32-bit machines,
    a 64-bit variable can not be accessed atomically; some synchronization is required
    in order to avoid any counter update while these two 32-bit halves are processed.
    The function `get_jiffies_64()` defined in the `/kernel/time/jiffies.c` source
    file returns the current value of `jiffies`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，使用了64位变量`jiffies_64`，它允许在溢出发生之前经过数千万年。`jiffies`变量等于`jiffies_64`的32位最低有效位。之所以同时拥有`jiffies`和`jiffies_64`变量，是因为在32位机器中，无法原子地访问64位变量；在处理这两个32位半部分时需要一些同步，以避免在处理这两个32位半部分时发生任何计数器更新。在`/kernel/time/jiffies.c`源文件中定义的函数`get_jiffies_64()`返回`jiffies`的当前值：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'While working with `jiffies`, it''s crucial to take into account the possibility
    of wraparound, because it leads to unpredictable results while comparing two time
    events. There are four macros that serve this purpose, defined in `include/linux/jiffies.h`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理`jiffies`时，必须考虑可能发生的回绕，因为在比较两个时间事件时会导致不可预测的结果。有四个宏在`include/linux/jiffies.h`中定义，用于此目的：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All these macros return Boolean values; parameters **a** and **b** are time
    events to be compared. If a happens to be the time after b, `time_after()` returns
    true, otherwise false. Conversely, if **a** happens to be before **b**, `time_before()`
    returns true, else false. Both `time_after_eq()` and `time_before_eq()` return
    true if both a and b are equal. Jiffies can be converted to other time units such
    as milliseconds, microseconds, and nanoseconds using routines `jiffies_to_msecs()`,
    `jiffies_to_usecs()`, defined in `kernel/time/time.c`, and `jiffies_to_nsecs()`,
    in `include/linux/jiffies.h`*:*
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些宏都返回布尔值；参数**a**和**b**是要比较的时间事件。如果a恰好是b之后的时间，`time_after()`返回true，否则返回false。相反，如果a恰好在b之前，`time_before()`返回true，否则返回false。`time_after_eq()`和`time_before_eq()`如果a和b都相等，则返回true。可以使用`kernel/time/time.c`中定义的例程`jiffies_to_msecs()`、`jiffies_to_usecs()`将jiffies转换为其他时间单位，如毫秒、微秒和纳秒，以及`include/linux/jiffies.h`中的`jiffies_to_nsecs()`：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Other conversion routines can be explored in the `include/linux/jiffies.h` file.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 其他转换例程可以在`include/linux/jiffies.h`文件中探索。
- en: Timeval and timespec
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Timeval和timespec
- en: 'In Linux, the current time is maintained by keeping the number of seconds elapsed
    since midnight of January 01, 1970 (called epoch); the second elements in each
    of these represent the time elapsed since the last second in microseconds and
    nanoseconds, respectively:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，当前时间是通过保持自1970年1月1日午夜以来经过的秒数（称为纪元）来维护的；这些中的每个第二个元素分别表示自上次秒数以来经过的时间，以微秒和纳秒为单位：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Time (counter value) read from the clock source needs to be accumulated and
    tracked somewhere; the structure `struct tk_read_base`, defined in `include/linux/timekeeper_internal.h,`
    serves this purpose:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从时钟源读取的时间（计数器值）需要在某个地方累积和跟踪；`include/linux/timekeeper_internal.h`中定义的`struct
    tk_read_base`结构用于此目的：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The structure `struct timekeeper`**,** defined in `include/linux/timekeeper_internal.h,`
    keeps various timekeeping values. It''s the primary data structure to maintain
    and manipulate the timekeeping data for different timelines, such as monotonic
    and raw:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`include/linux/timekeeper_internal.h`中定义的`struct timekeeper`结构保持各种时间保持值。它是用于维护和操作不同时间线的时间保持数据的主要数据结构，如单调和原始：'
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tracking and maintaining time
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪和维护时间
- en: 'Timekeeping helper routines `timekeeping_get_ns()` and `timekeeping_get_ns()`
    help get the correction factor (delta t) between universal time and terrestrial
    time in nanoseconds:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 时间保持辅助例程`timekeeping_get_ns()`和`timekeeping_get_ns()`有助于获取通用时间和地球时间之间的校正因子（Δt），单位为纳秒：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The routine `logarithmic_accumulation()` updates mono, raw, and xtime timelines;
    it accumulates shifted intervals of cycles into a shifted interval of nanoseconds.
    The routine `accumulate_nsecs_to_secs()` accumulates the nanoseconds in the `xtime_nsec`
    field of `struct tk_read_base` into `xtime_sec` of `struct timekeeper`. These
    routines help keep track of the current time in the system, and are defined in
    `kernel/time/timekeeping.c`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例程`logarithmic_accumulation()`更新mono、raw和xtime时间线；它将周期的移位间隔累积到纳秒的移位间隔中。例程`accumulate_nsecs_to_secs()`将`struct
    tk_read_base`的`xtime_nsec`字段中的纳秒累积到`struct timekeeper`的`xtime_sec`中。这些例程有助于跟踪系统中的当前时间，并在`kernel/time/timekeeping.c`中定义：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Another routine `update_wall_time()`, defined in `kernel/time/timekeeping.c,`
    is responsible for maintaining the wall time. It increments the wall time using
    the current clock source as reference.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例程`update_wall_time()`，在`kernel/time/timekeeping.c`中定义，负责维护壁钟时间。它使用当前时钟源作为参考递增壁钟时间。
- en: Tick and interrupt handling
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时钟中断处理
- en: 'To provide the programming interface, the clock device generating the ticks
    is abstracted through the structure `struct clock_event_device`, defined in `include/linux/clockchips.h`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供编程接口，生成滴答的时钟设备通过`include/linux/clockchips.h`中定义的`struct clock_event_device`结构进行抽象：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, `event_handler` is the appropriate routine, assigned by the framework
    to be called by the low-level handler to run the tick. Depending on the configuration,
    this `clock_event_device` could be `periodic`*,* `one-shot,` or `ktime` based*.*
    Out of these three, the appropriate operating mode for the tick device is set
    through the `unsigned int features` field, using any of these macros:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`event_handler`是由框架分配的适当例程，由低级处理程序调用以运行滴答。根据配置，这个`clock_event_device`可以是`periodic`、`one-shot`或`ktime`基础的。在这三种情况中，滴答设备的适当操作模式是通过`unsigned
    int features`字段设置的，使用这些宏之一：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Periodic mode configures the hardware generate the tick once every *1/HZ* seconds,
    while one-shot mode makes the hardware generate the tick after the passage of
    a specific number of cycles from the current time.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 周期模式配置硬件每*1/HZ*秒生成一次滴答，而单次模式使硬件在当前时间后经过特定数量的周期生成滴答。
- en: 'Depending on the use cases and the operating mode, event_handler could be any
    of these three routines:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据用例和操作模式，event_handler可以是这三个例程中的任何一个：
- en: '`tick_handle_periodic()`*,* which is the default handler for periodic ticks
    and is defined in `kernel/time/tick-common.c`*.*'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tick_handle_periodic()`是周期性滴答的默认处理程序，定义在`kernel/time/tick-common.c`中。'
- en: '`tick_nohz_handler()` is the low-resolution interrupt handler, used in low
    res mode. It''s defined in `kernel/time/tick-sched.c`*.*'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tick_nohz_handler()`是低分辨率中断处理程序，在低分辨率模式下使用。它在`kernel/time/tick-sched.c`中定义。'
- en: '`hrtimer_interrupt()` is used in high res mode and is defined in `kernel/time/hrtimer.c`.
    Interrupts are disabled when it''s called.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hrtimer_interrupt()`在高分辨率模式下使用，并在调用时禁用中断。'
- en: A clock event device is configured and registered through the routine `clockevents_config_and_register()`,
    defined in `kernel/time/clockevents.c.`
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`clockevents_config_and_register()`例程配置和注册时钟事件设备，定义在`kernel/time/clockevents.c`中。
- en: Tick devices
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滴答设备
- en: 'The `clock_event_device` abstraction is for the core timing framework; we need
    a separate abstraction for tick devices per CPU; this is achieved through the
    structure `struct tick_device` and macro `DEFINE_PER_CPU()`*,* defined in `kernel/time/tick-sched.h`
    and `include/linux/percpu-defs.h`, respectively:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`clock_event_device`抽象是为了核心定时框架；我们需要一个单独的抽象来处理每个CPU的滴答设备；这是通过`struct tick_device`结构和`DEFINE_PER_CPU()`宏来实现的，分别在`kernel/time/tick-sched.h`和`include/linux/percpu-defs.h`中定义：'
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A `tick_device` could be either periodic or one shot. It's set through the `enum
    tick_device_mode`*.*
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`tick_device`可以是周期性的或单次的。它通过`enum tick_device_mode`设置。'
- en: Software timers and delay functions
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件定时器和延迟函数
- en: 'A software timer allows a function to be invoked on expiry of a time duration.
    There are two types of timers: dynamic timers used by the kernel and interval
    timers used by the user-space processes. Apart from software timers, there is
    another type of commonly used timing function called delay functions. Delay functions
    implement a precise loop, which is executed as per (usually as many times as the)
    delay function''s argument.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 软件定时器允许在时间到期时调用函数。有两种类型的定时器：内核使用的动态定时器和用户空间进程使用的间隔定时器。除了软件定时器，还有另一种常用的定时函数称为延迟函数。延迟函数实现一个精确的循环，根据延迟函数的参数执行（通常是多次）。
- en: Dynamic timers
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态定时器
- en: 'Dynamic timers can be created and destroyed at any time, hence the name dynamic
    timers. Dynamic timers are represented by the `struct timer_list` object, defined
    in `include/linux/timer.h`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 动态定时器可以随时创建和销毁，因此称为动态定时器。动态定时器由`struct timer_list`对象表示，定义在`include/linux/timer.h`中：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: All timers in a system are managed by a doubly linked list, and are sorted in
    order of their expiry time, represented by the expires field. The expires field
    specifies the time duration, after which the timer expires. As soon as the current
    `jiffies` value matches or exceeds this field's value, the timer decays. Through
    the entry field, a timer is added into this timer linked list. The function field
    points to the routine to be invoked on expiry of the timer and the data field
    holds the parameter to be passed to the function, if needed. The expires field
    is constantly compared with `jiffies_64` values to determine whether the timer
    has expired or not.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 系统中的所有定时器都由一个双向链表管理，并按照它们的到期时间排序，由expires字段表示。expires字段指定定时器到期后的时间。一旦当前的`jiffies`值匹配或超过此字段的值，定时器就会过期。通过entry字段，定时器被添加到此定时器链表中。函数字段指向在定时器到期时要调用的例程，数据字段保存要传递给函数的参数（如果需要）。expires字段不断与`jiffies_64`值进行比较，以确定定时器是否已经过期。
- en: 'A dynamic timer can be created and activated as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 动态定时器可以按以下方式创建和激活：
- en: Create a new `timer_list` object, let's say `t_obj`.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的`timer_list`对象，比如说`t_obj`。
- en: Initialize this timer object using macro `init_timer(&t_obj)`, defined in `include/linux/timer.h.`
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用宏`init_timer(&t_obj)`初始化此定时器对象，定义在`include/linux/timer.h`中。
- en: Initialize the function field with the function's address to be invoked on expiry
    of the timer. If the function requires a parameter, initialize the data field
    too.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数字段初始化函数的地址，以在定时器到期时调用该函数。如果函数需要参数，则也初始化数据字段。
- en: If the timer object is already added to a timer list, update the expires field
    by calling the function `mod_timer(&t_obj, <timeout-value-in-jiffies>)`*,* defined
    in `kernel/time/timer.c`*.*
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果定时器对象已经添加到定时器列表中，则通过调用函数`mod_timer(&t_obj, <timeout-value-in-jiffies>)`更新expires字段，定义在`kernel/time/timer.c`中。
- en: If not, initialize the expires field and add the timer object into the timer
    list using `add_timer(&t_obj)`*,* defined in `/kernel/time/timer.c`*.*
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有，初始化expires字段，并使用`add_timer(&t_obj)`将定时器对象添加到定时器列表中，定义在`/kernel/time/timer.c`中。
- en: 'The kernel removes a decayed timer from its timer list automatically, but there
    are other methods too to remove a timer from its list. The `del_timer()` and `del_timer_sync()`
    routines and the macro `del_singleshot_timer_sync()` defined in `kernel/time/timer.c`
    help in doing so:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 内核会自动从定时器列表中删除已过期的定时器，但也有其他方法可以从列表中删除定时器。`kernel/time/timer.c`中定义的`del_timer()`和`del_timer_sync()`例程以及宏`del_singleshot_timer_sync()`可以帮助实现这一点：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`del_timer()` removes both active and inactive timers. Particularly useful
    in SMP systems, `del_timer_sync()` deactivates the timer and waits until the handler
    has finished executing on other CPUs.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`del_timer()` 删除活动和非活动的定时器。在SMP系统中特别有用，`del_timer_sync()` 会停止定时器，并等待处理程序在其他CPU上执行完成。'
- en: Race conditions with dynamic timers
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态定时器的竞争条件
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This approach, however, is applicable to uni-processor systems only. In an
    SMP system, it''s quite possible that when the timer is stopped, its function
    might already be running on another CPU. In such a scenario, resources will be
    released as soon as the `del_timer()` returns, while the timer function is still
    manipulating them on other CPU; not a desirable situation at all. `del_timer_sync()`
    fixes this problem: after stopping the timer, it waits until the timer function
    completes its execution on the other CPU. `del_timer_sync()` is useful in cases
    where the timer function can reactivate itself. If the timer function doesn''t
    reactivate the timer, a much simpler and faster macro, `del_singleshot_timer_sync()`,
    should be used instead.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法仅适用于单处理器系统。在SMP系统中，当定时器停止时，其功能可能已经在另一个CPU上运行。在这种情况下，资源将在`del_timer()`返回时立即释放，而定时器功能仍在其他CPU上操作它们；这绝非理想的情况。`del_timer_sync()`解决了这个问题：在停止定时器后，它会等待定时器功能在其他CPU上执行完成。`del_timer_sync()`在定时器功能可以重新激活自身的情况下非常有用。如果定时器功能不重新激活定时器，则应该使用一个更简单和更快的宏`del_singleshot_timer_sync()`。
- en: Dynamic timer handling
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态定时器处理
- en: 'Software timers are complex and time consuming, and therefore should not be
    handled by the timer ISR. Rather they should be performed by a deferrable bottom-half
    softirq routine called `TIMER_SOFTIRQ` *,* and its routine is defined in `kernel/time/timer.c`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 软件定时器复杂且耗时，因此不应由定时器ISR处理。而应该由一个可延迟的底半软中断例程`TIMER_SOFTIRQ`来执行，其例程在`kernel/time/timer.c`中定义：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Delay functions
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟函数
- en: Timers are useful when the timeout period is relatively long; in all other use
    cases where a shorter duration is desired, delay functions are used instead. While
    working with hardware such as storage devices (namely *flash memory* and *EEPROM*),
    it's is very crucial for the device driver to wait until the device finishes the
    hardware operations such as writing and erasing, which in most cases is in the
    range of a few microseconds to milliseconds. Going ahead and executing other instructions
    without waiting for the hardware to complete such operations would result in unpredictable
    read/write operations and data corruption. In cases such as these, delay functions
    come in handy. The kernel provides such short delays by means of the `ndelay()`*,*
    `udelay()`, and `mdelay()` routines and macro, which receive arguments in nanoseconds,
    microseconds, and milliseconds, respectively.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器在超时期相对较长时非常有用；在所有其他需要较短持续时间的用例中，使用延迟函数。在处理诸如存储设备（即*闪存*和*EEPROM*）等硬件时，设备驱动程序非常关键，需要等待设备完成写入和擦除等硬件操作，这在大多数情况下是在几微秒到毫秒的范围内。在不等待硬件完成这些操作的情况下继续执行其他指令将导致不可预测的读/写操作和数据损坏。在这种情况下，延迟函数非常有用。内核通过`ndelay()`、`udelay()`和`mdelay()`例程和宏提供这样的短延迟，分别接收纳秒、微秒和毫秒为参数。
- en: 'The following functions can be found in `include/linux/delay.h`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数可以在`include/linux/delay.h`中找到：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'These functions can be found in `arch/ia64/kernel/time.c`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以在`arch/ia64/kernel/time.c`中找到：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: POSIX clocks
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: POSIX时钟
- en: 'POSIX provides software timers to multithreaded and real-time user space applications,
    known as POSIX timers. POSIX provides the following clocks:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX为多线程和实时用户空间应用程序提供了软件定时器，称为POSIX定时器。POSIX提供以下时钟：
- en: '`CLOCK_REALTIME`: This clock represents the real time in the system. Also known
    as the wall time, it''s similar to the time from a wall clock and used for timestamping
    as well as providing actual time to the user. This clock is modifiable.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLOCK_REALTIME`：该时钟表示系统中的实时时间。也称为墙上时间，类似于挂钟上的时间，用于时间戳和向用户提供实际时间。该时钟是可修改的。'
- en: '`CLOCK_MONOTONIC`: This clock keeps the time elapsed since the system bootup.
    It''s ever increasing and non modifiable by any process or user. Due to its monotonic
    nature, it''s the the preferred clock to determine the time difference between
    two time events.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLOCK_MONOTONIC`：该时钟保持系统启动以来经过的时间。它是不断增加的，并且不可被任何进程或用户修改。由于其单调性质，它是确定两个时间事件之间时间差的首选时钟。'
- en: '`CLOCK_BOOTTIME`: This clock is identical to CLOCK_MONOTONIC; however, it includes
    time spent in suspend.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLOCK_BOOTTIME`：该时钟与`CLOCK_MONOTONIC`相同；但它包括在挂起中花费的时间。'
- en: 'These clocks can be accessed and modified (if the selected clock allows it)
    through the following POSIX clock routines, defined in the `time.h` header:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些时钟可以通过以下POSIX时钟例程进行访问和修改（如果所选时钟允许）：
- en: '`int clock_getres(clockid_t clk_id, struct timespec *res);`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int clock_getres(clockid_t clk_id, struct timespec *res);`'
- en: '`int clock_gettime(clockid_t clk_id, struct timespec *tp);`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int clock_gettime(clockid_t clk_id, struct timespec *tp);`'
- en: '`int clock_settime(clockid_t clk_id, const struct timespec *tp);`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int clock_settime(clockid_t clk_id, const struct timespec *tp);`'
- en: 'The function `clock_getres()` gets the resolution (precision) of the clock
    specified by *clk_id*. And if the resolution is non-null, it stores it in the
    `struct timespec` pointed to by the resolution. Functions `clock_gettime()` and
    `clock_settime()` read and set the time of the clock specified by *clk_id*. *clk_id*
    could be any of the POSIX clocks: `CLOCK_REALTIME`, `CLOCK_MONOTONIC`, and so
    on.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `clock_getres()` 获取由 *clk_id* 指定的时钟的分辨率（精度）。如果分辨率非空，则将其存储在由分辨率指向的 `struct
    timespec` 中。函数 `clock_gettime()` 和 `clock_settime()` 读取和设置由 *clk_id* 指定的时钟的时间。*clk_id*
    可以是任何 POSIX 时钟：`CLOCK_REALTIME`，`CLOCK_MONOTONIC` 等等。
- en: '`CLOCK_REALTIME_COARSE`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLOCK_REALTIME_COARSE`'
- en: '`CLOCK_MONOTONIC_COARSE`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLOCK_MONOTONIC_COARSE`'
- en: 'Each of these POSIX routines has corresponding system calls, namely `sys_clock_getres(),
    sys_ clock_gettime()`, and `sys_clock_settime`*.* So every time any of these routines
    is invoked, a context switching occurs from user mode to kernel mode. If calls
    to these routines are frequent, context switching can result in low system performance.
    To avoid context switching, two coarse variants of the POSIX clock were implemented
    as the vDSO (virtual Dynamic Shared Object) library:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些 POSIX 例程都有相应的系统调用，即 `sys_clock_getres()，sys_clock_gettime()` 和 `sys_clock_settime`*.*
    因此，每次调用这些例程时，都会发生从用户模式到内核模式的上下文切换。如果对这些例程的调用频繁，上下文切换可能会导致系统性能下降。为了避免上下文切换，POSIX
    时钟的两个粗糙变体被实现为 vDSO（虚拟动态共享对象）库：
- en: vDSO is a small shared library with selected kernel space routines that the
    kernel maps into the address space of user-space applications so that these kernel-space
    routines can be called by them in process from user space directly. The C library
    calls the vDSOs, so the user space applications can be programmed in the usual
    way through standard functions and the C library will utilize the functionalities
    available through vDSO without engaging any syscall interface, thus avoiding any
    user mode-kernel mode context switching and syscall overhead. Being an vDSO implementation,
    these coarse variants are faster and have a resolution of 1 milliseconds.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: vDSO 是一个小型共享库，其中包含内核空间的选定例程，内核将其映射到用户空间应用程序的地址空间中，以便这些内核空间例程可以直接由它们在用户空间中的进程调用。C
    库调用 vDSO，因此用户空间应用程序可以通过标准函数以通常的方式进行编程，并且 C 库将利用通过 vDSO 可用的功能，而不涉及任何系统调用接口，从而避免任何用户模式-内核模式上下文切换和系统调用开销。作为
    vDSO 实现，这些粗糙的变体速度更快，分辨率为 1 毫秒。
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked in detail at most of the routines that the kernel
    provides to drive time-based events, in addition to comprehending the fundamental
    aspects of Linux time, its infrastructure, and its measurement. We also briefly
    looked at POSIX clocks and some of their key time access and modification routines.
    Effective time-driven programs however rest on careful and calculated use of these
    routines.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细了解了内核提供的大多数用于驱动基于时间的事件的例程，以及理解了 Linux 时间、其基础设施和其测量的基本方面。我们还简要介绍了 POSIX
    时钟及其一些关键的时间访问和修改例程。然而，有效的时间驱动程序取决于对这些例程的谨慎和计算使用。
- en: In the next chapter, we will briefly look at the management of dynamic kernel
    modules.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将简要介绍动态内核模块的管理。
