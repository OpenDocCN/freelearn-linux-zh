- en: Working with Char Drivers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Char驱动程序
- en: A device driver is special code (running in kernel space) that interfaces a
    physical device to the system and exports it to the user space processes using
    a well-defined API, that is, by implementing some **system calls** on a **special
    file**. This is due to the fact that, in a Unix-like OS, **everything is a file**
    and physical devices are represented as special files (usually placed in the `/dev`
    directory), each one connected to a particular device (so, for instance, the keyboard
    can be a file named `/dev/input0`, a serial port can be a file named `/dev/ttyS1`,
    and a real-time clock can be `/dev/rtc2`).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序是一种特殊的代码（在内核空间中运行），它将物理设备与系统进行接口，并通过实现一些**系统调用**在**特殊文件**上向用户空间进程提供访问，这是因为在类Unix的操作系统中，**一切都是文件**，物理设备被表示为特殊文件（通常放置在`/dev`目录中），每个文件连接到特定设备（因此，例如，键盘可以是名为`/dev/input0`的文件，串行端口可以是名为`/dev/ttyS1`的文件，实时时钟可以是`/dev/rtc2`）。
- en: We can expect that network devices belong to a particular set of devices not
    respecting this rule because we have no `/dev/eth0` file for the `eth0` interface. This
    is true, since network devices are the only devices class that doesn't respect
    this rule because network-related applications don't care about individual network
    interfaces; they work at a higher level by referring sockets instead. That's why
    Linux doesn't provide direct access to network devices, as for other devices classes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以预期，网络设备属于一组特定的设备，不遵守这个规则，因为我们没有`/dev/eth0`文件用于`eth0`接口。这是真的，因为网络设备是唯一不遵守这个规则的设备类，因为与其他设备类不同，与网络相关的应用程序不关心单个网络接口；它们通过引用套接字在更高级别上工作。这就是为什么Linux不提供对网络设备的直接访问，就像其他设备类一样。
- en: 'Looking at the next diagram, we see that the kernel space is used to abstract
    hardware to user space, so that every process uses the same interface to get access
    to peripherals, and this interface is composed by a set of system calls:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从下图中可以看出，内核空间用于将硬件抽象到用户空间，以便每个进程都使用相同的接口来访问外围设备，这个接口由一组系统调用组成。
- en: '![](img/86240942-ff71-4d42-a1de-dfc3717df2ae.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86240942-ff71-4d42-a1de-dfc3717df2ae.png)'
- en: The diagram also shows that it is possible to get access to peripherals not
    only by using device drivers but also by using another interface such as **sysfs**
    or by implementing a user space driver.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 该图还显示，除了使用设备驱动程序之外，还可以通过使用另一个接口（如**sysfs**）或实现用户空间驱动程序来访问外围设备。
- en: Since our peripherals are just (special) files, our drivers should implement
    the system calls we need to manipulate these files and especially the ones useful
    to exchange data. For example, we need `open()` and `close()` system calls to
    start and stop the communication with the peripheral and `read()` and `write()`
    system calls to exchange data with it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的外围设备只是（特殊）文件，因此我们的驱动程序应该实现我们需要操作这些文件的系统调用，特别是用于交换数据的系统调用。例如，我们需要`open()`和`close()`系统调用来启动和停止与外围设备的通信，以及`read()`和`write()`系统调用来与其交换数据。
- en: The main difference between a normal C function and a system call is just the
    fact that the latter is mainly executed into the kernel, while a function executes
    into the user space only. For example, `printf()` is a function, while `write()`
    is a system call. The latter (except for the prologue and epilogue part of a C
    function) executes in the kernel space, while the former executes predominantly
    in the user space even if, at the and, it calls `write()` to actually write its
    data to the output stream (this is because all input/output data flows must pass through the
    kernel anyway).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 普通C函数和系统调用之间的主要区别在于后者主要在内核中执行，而函数仅在用户空间中执行。例如，`printf()`是一个函数，而`write()`是一个系统调用。后者（除了C函数的序言和尾声部分）在内核空间中执行，而前者主要在用户空间中执行，即使最终调用`write()`来实际将数据写入输出流（这是因为所有输入/输出数据流无论如何都必须通过内核）。
- en: For more information check this book out:[ https://prod.packtpub.com/hardware-and-creative/gnulinux-rapid-embedded-programming](https://prod.packtpub.com/hardware-and-creative/gnulinux-rapid-embedded-programming)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请查看本书：[https://prod.packtpub.com/hardware-and-creative/gnulinux-rapid-embedded-programming](https://prod.packtpub.com/hardware-and-creative/gnulinux-rapid-embedded-programming)
- en: Well, this chapter will show us how to implement at least the `open()`, `close()`,
    `read()`, and `write()` system calls in order to introduce device drivers programming
    and the first steps into char drivers development.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，本章将向我们展示如何至少实现`open()`、`close()`、`read()`和`write()`系统调用，以介绍设备驱动程序编程和字符驱动程序开发的第一步。
- en: 'Now it''s time to write our first device driver! In this chapter, we will start
    with a very simple character (or char) driver in order to cover the following
    recipes:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写我们的第一个设备驱动程序了！在本章中，我们将从一个非常简单的字符（或char）驱动程序开始，以涵盖以下内容：
- en: Creating the simplest char driver
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建最简单的char驱动程序
- en: Exchanging data with a char driver
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与char驱动程序交换数据
- en: Using the ''Everything Is a File" abstraction
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“一切都是文件”抽象
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Throughout this chapter, we'll need whatever we used in [Chapter 1](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml), *Installing
    the Development System*, and [Chapter 2](c044f5b1-bd3a-4ac7-bc14-421acd9448ed.xhtml), *A
    Peek Inside the Kernel*, so please refer to them for cross-compilation, kernel
    modules loading and management, and so on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将需要[第1章](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml)和[第2章](c044f5b1-bd3a-4ac7-bc14-421acd9448ed.xhtml)中使用的内容，*安装开发系统*和*内核内部一瞥*，因此请参考它们进行交叉编译、内核模块加载和管理等操作。
- en: For more information on this chapter please read the *Appendix*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章的更多信息，请阅读*附录*。
- en: The code and other files used in this chapter can be downloaded from GitHub
    at [https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_03](https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_03).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码和其他文件可以从GitHub上下载：[https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_03](https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_03)。
- en: Creating the simplest char driver
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建最简单的字符驱动程序
- en: In the Linux kernel, three major device types exist—char device, block device,
    and net device. And of course, we have three major device driver types; that is,
    char, block, and net drivers. In this chapter, we're taking a look at a char (or
    character) device, which is a kind of peripheral that can be accessed as a stream
    of bytes, such as a serial port, audio device, and so on. However, in this recipe,
    we're going to present a really basic char driver, which simply registers itself
    and does nothing more than this. Even if it may seem useless, we will discover
    that this step really introduces plenty of new concepts!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux内核中，存在三种主要的设备类型——字符设备、块设备和网络设备。当然，我们有三种主要的设备驱动程序类型；即字符、块和网络驱动程序。在本章中，我们将看一下字符（或字符）设备，这是一种可以作为字节流访问的外围设备，例如串行端口、音频设备等。然而，在这个配方中，我们将介绍一个真正基本的字符驱动程序，它只是注册自己，除此之外什么也不做。即使它可能看起来毫无用处，我们将发现这一步确实引入了许多新概念！
- en: Actually, it could be possible to exchange data between peripherals and user
    space without a char, block, or net driver but by simply using some mechanism
    offered by the **sysfs**, but this is a special case and it is generally used
    only for very simple devices that have to exchange simple data types.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，可能可以通过简单地使用**sysfs**提供的一些机制在外围设备和用户空间之间交换数据，而不是通过字符、块或网络驱动程序，但这是一种特殊情况，通常仅用于必须交换简单数据类型的非常简单的设备。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To realize our first char driver, we need the module presented in the previous
    chapter. This is because using kernel modules is the simplest method we have to
    inject code into kernel space. Of course, we can decide to compile our driver
    as built in to the kernel but, in this manner, we have to fully recompile the
    kernel and reboot our system each time we have to modify the code (it's a possibility
    but definitely not the best!).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现我们的第一个字符驱动程序，我们需要使用上一章介绍的模块。这是因为使用内核模块是我们将代码注入内核空间的最简单方法。当然，我们可以决定将我们的驱动程序编译为内核内置，但是这样做，每次修改代码时我们都必须完全重新编译内核并重新启动系统（这是一种可能性，但绝对不是最好的！）。
- en: 'Just a note before carrying on: to provide a clearer explanation regarding
    how a char driver works and to present a really simple example, I decided to use
    the legacy way to register a char driver into the kernel. There''s nothing to
    be concerned about, since this mode of operation is perfectly legal and still
    supported and, in any case, in the *Using a device tree to describe a character
    driver* recipe, in [Chapter 4](5f22a69e-e8b7-402e-8e67-72938d00c914.xhtml), *Using
    the Device Tre**e*, I''m going to present the currently advised way of registering
    char drivers.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，先说明一点：为了更清楚地解释字符驱动程序的工作原理，并且提供一个真正简单的示例，我决定使用传统的方式将字符驱动程序注册到内核中。没有什么需要担心的，因为这种操作模式是完全合法的，仍然得到支持，在任何情况下，在*使用设备树描述字符驱动程序*配方中，在[第4章](5f22a69e-e8b7-402e-8e67-72938d00c914.xhtml)中，*使用设备树*，我将介绍目前建议的注册字符驱动程序的方式。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s look into the `chrdev_legacy.c` file from GitHub sources. We have our
    very first driver, so let''s start and examine it in detail:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从GitHub源代码中查看`chrdev_legacy.c`文件。我们有我们的第一个驱动程序，所以让我们开始并详细检查它：
- en: 'First of all, let''s take a look at the beginning of the file:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看一下文件的开头：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'At the end of `chrdev_legacy.c`, check the following code where the module''s
    `init()` function is defined as below:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`chrdev_legacy.c`的末尾，检查以下代码，其中模块的`init()`函数定义如下：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And the module''s `exit()` function looks like the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的`exit()`函数如下所示：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If the `major` number is the driver reference into the kernel from the user
    space, the **file operations** structure (referenced by `chrdev_fops`) represents
    the only allowed system calls that we can execute on our driver, and they are
    defined as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`major`号是内核中用户空间的驱动程序引用，那么**文件操作**结构（由`chrdev_fops`引用）代表了我们可以在驱动程序上执行的唯一允许的系统调用，它们定义如下：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Methods are then basically implemented as follows. Here are the `read()` and
    `write()` methods:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，方法基本上实现如下。这里是`read()`和`write()`方法：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'While here are the `open()` and `release()` (aka the `close()`) methods:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`open()`和`release()`（又名`close()`）方法：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To compile the code, we can do it the usual way on the host machine, as follows:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译代码，我们可以在主机上使用通常的方式进行，如下所示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, to test our driver, we can load it in our target system (again we can
    use the `scp` command to load the module file into the ESPRESSObin):'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为了测试我们的驱动程序，我们可以在目标系统中加载它（再次可以使用`scp`命令将模块文件加载到ESPRESSObin中）：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: OK. The driver has been loaded and our major number is `239`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 好了。驱动程序已加载，我们的主要号码是`239`。
- en: 'As a final note, let me suggest you take a look into the `/proc/devices` file on
    the ESPRESSObin. This special file is generated on the fly when someone reads
    it and it holds all character (and block) drivers registered into the system;
    that''s why we should find something as follows if we filter it with the `grep` command:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我建议您查看ESPRESSObin上的`/proc/devices`文件。这个特殊的文件是在有人读取它时动态生成的，它保存了所有注册到系统中的字符（和块）驱动程序；这就是为什么如果我们用`grep`命令过滤它，我们应该找到以下内容：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Of course, your major number can be a different number! There's nothing strange
    about that; just rewrite the next commands according to the number you get.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你的主要号码可能是一个不同的号码！这一点并不奇怪；只需根据你得到的号码重写下一个命令。
- en: 'To effectively execute some system calls on our driver, we can use the program
    stored in the `chrdev_test.c` file (still from GitHub sources); the beginning
    of its `main()` function looks like the following:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在我们的驱动程序上有效地执行一些系统调用，我们可以使用存储在`chrdev_test.c`文件中的程序（仍然来自GitHub源代码）；其`main()`函数的开头如下所示：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First of all, we need to open the file device and then get a file descriptor;
    this can be done by using the `open()` system call.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要打开文件设备，然后获取文件描述符；这可以通过使用`open()`系统调用来完成。
- en: 'Then, the `main()` function continues, as follow by writing data in the device:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`main()`函数继续，通过在设备中写入数据：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And the by reading just written data from it:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过刚刚写入的数据进行读取：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After the device opens, our program performs `write()` followed by a `read()` system
    call.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 设备打开后，我们的程序执行`write()`，然后是`read()`系统调用。
- en: We should notice that I call `read()` and `write()` system calls inside a `for()` loop;
    the reason behind this implementation will be clearer in the following recipe, *Exchanging
    data with a char driver,* where we're going to see how these system calls actually
    work.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，我在`for()`循环内调用`read()`和`write()`系统调用；这种实现背后的原因将在下一个配方*与字符驱动程序交换数据*中更清晰地看到这些系统调用实际上是如何工作的。
- en: 'Finally, `main()` can close the file device and then exit:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`main()`可以关闭文件设备，然后退出：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this manner, we can test the system calls we implemented earlier.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以测试我们之前实现的系统调用。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1*, As you can see, it's very similar to the kernel module we presented
    in the previous chapter, even if there are some new `include` files. However,
    the most important new entry is the `major` variable and, in order to understand
    what it is useful for, we should directly go to the end of the file, where we
    find the real char driver registration.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，正如您所看到的，它与我们在上一章中介绍的内核模块非常相似，即使有一些新的`include`文件。然而，最重要的新条目是`major`变量，为了理解它的用途，我们应该直接转到文件末尾，在那里找到真正的字符驱动程序注册。
- en: In step 2, Again, we have the `module_init()` and `module_exit()` functions
    and macros such as `MODULE_LICENSE()` (see [Chapter 2](c044f5b1-bd3a-4ac7-bc14-421acd9448ed.xhtml),
    *A Peek Inside the Kernel*, the Working with kernel modules recipe); however,
    what is really important here is what the `chrdev_init()` and `chrdev_exit()`
    functions effectively do. In fact, `chrdev_init()` calls the `register_chrdev()`
    function, which, in turn, is the one that registers a new char driver into the
    system, labeling it as `chrdev` and using the provided `chrdev_fops` as file operations,
    while storing the return value into the major variable.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤2中，我们再次看到`module_init()`和`module_exit()`函数和宏，例如`MODULE_LICENSE()`（请参阅[第2章](c044f5b1-bd3a-4ac7-bc14-421acd9448ed.xhtml)，*内核内部*，与内核模块一起工作的配方）；然而，这里真正重要的是`chrdev_init()`和`chrdev_exit()`函数的实际作用。实际上，`chrdev_init()`调用`register_chrdev()`函数，而`register_chrdev()`函数又是将新的字符驱动程序注册到系统中的函数，将其标记为`chrdev`，并使用提供的`chrdev_fops`作为文件操作，同时将返回值存储到major变量中。
- en: We should take into account this fact because, in case no errors were returned, `major` is
    the main reference of our new driver in the system! In fact, the kernel distinguishes
    one char driver from another by just using its **major number** (that's why we
    save it and then we use it in the `chrdev_exit()` function as a parameter of `unregister_chrdev()`).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该考虑这一事实，因为如果没有返回错误，`major`将是系统中新驱动程序的主要引用！实际上，内核仅通过其**主要编号**来区分一个字符驱动程序和另一个字符驱动程序（这就是为什么我们保存它，然后在`chrdev_exit()`函数中将其用作`unregister_chrdev()`的参数）。
- en: In *step 3*, Each field then points to a well-defined function, which, in turn,
    implements the system call body. The only non-function field here is `owner`,
    which is just used to point to the module's owner and it's not related to the
    driver but to the kernel modules management system only.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，然后每个字段指向一个明确定义的函数，这些函数又实现了系统调用体。这里唯一的非函数字段是`owner`，它只用于指向模块的所有者，与驱动程序无关，仅与内核模块管理系统有关。
- en: In *step 4*, Through the means of the preceding code our char driver implements
    four system calls by using four methods: `open()`, `close()` (called as `release()`), `read()`,
    and `write()`, which are a very minimal (and simple) system calls set we can define
    into a char driver.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，通过前面的代码，我们的字符驱动程序使用四种方法实现了四个系统调用：`open()`，`close()`（称为`release()`），`read()`和`write()`，这是我们可以在字符驱动程序中定义的非常简单的系统调用集。
- en: Note that, at this time, all methods simply do nothing! When we issue a  `read()` system
    call on our driver, the `chrdev_read()` method is properly called inside our driver
    in kernel space (see the next section in order to understand how to exchange data
    with the user space).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此时所有方法都不执行任何操作！当我们在驱动程序上发出`read()`系统调用时，内核空间中的驱动程序内部将正确调用`chrdev_read()`方法（请参阅下一节以了解如何与用户空间交换数据）。
- en: I use both **function** and **method** names interchangeably because all of
    these functions can be seen as methods in object programming, where the same function
    names specialize into different steps according to the object they are applied
    to.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我交替使用**函数**和**方法**名称，因为所有这些函数都可以被视为对象编程中的方法，这些函数名称根据它们应用的对象而专门化为不同的步骤。
- en: 'With drivers it is the same: for example, they all have a `read()` method,
    but this method''s behavior changes according to the object (or peripheral) it
    is applied to.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于驱动程序也是一样的：例如，它们都有一个`read()`方法，但是这个方法的行为会根据它所应用的对象（或外围设备）而改变。
- en: In *step 6*, Again, the `loading out-of-tree module taints kernel` message is
    just a warning and can be safely ignored; please note, however, that the module
    filename is `chrdev_legacy.ko` while the driver's name is just `chrdev`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，`loading out-of-tree module taints kernel`消息只是一个警告，可以安全地忽略；但请注意，模块文件名为`chrdev_legacy.ko`，而驱动程序的名称只是`chrdev`。
- en: There's more...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can verify how our new driver works, so let''s compile the program stored
    in the `chrdev_test.c` file we saw earlier. To do so, we can use the next command
    on the ESPRESSObin:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证我们的新驱动程序的工作方式，因此让我们编译之前看到的`chrdev_test.c`文件中存储的程序。为此，我们可以在ESPRESSObin上使用以下命令：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If not yet installed, both the `make` and `gcc` commands can be easily installed
    into your ESPRESSObin, just using the usual `apt` command `apt install make gcc`
    (after the ESPRESSObin has been connected to the internet!).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未安装，可以使用常规的`apt`命令`apt install make gcc`轻松将`make`和`gcc`命令安装到您的ESPRESSObin中（在ESPRESSObin连接到互联网后）。
- en: 'Now we can try it by executing it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过执行它来尝试它：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Yes! Which is the filename we have to use? We always said that our devices
    are files in a Unix OS, but which file? Well, to generate this file—that is, the
    file which represents our driver—we must use the `mknod` command, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 是的！我们必须使用哪个文件名？我们一直说我们的设备是Unix OS中的文件，但是哪个文件？好吧，要生成这个文件——也就是代表我们的驱动程序的文件——我们必须使用`mknod`命令，如下所示：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For further information regarding the `mknod` command, you can take a look at
    its man pages by using the command line `man mknod`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`mknod`命令的更多信息，您可以使用命令行`man mknod`查看其手册页面。
- en: Usually `mknod` created files are located in the `/dev` directory; however,
    they can be created wherever we wish and this is just an example to show how the
    mechanism works.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通常`mknod`创建的文件位于`/dev`目录中；但是，它们可以创建在我们希望的任何地方，这只是一个示例，展示了机制的工作原理。
- en: The preceding command creates a file named `chrdev` in the current directory,
    which is a special file of the type **character** (or **unbuffered**),  having
    as a major number `239` (which is, of course, the major number of our driver as
    seen in *step 1*) and as a minor number `0`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令在当前目录中创建一个名为`chrdev`的文件，这是一种特殊文件类型**字符**（或**无缓冲**），其主要编号为`239`（这当然是我们驱动程序的主要编号，如*步骤1*中所见），次要编号为`0`。
- en: At this time, we still haven't introduced minor numbers however, you should
    consider them as just a simple extra parameter that the kernel simply passes to
    the driver without changing it. It's the driver itself that knows how to manage
    the minor number.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们还没有引入次要编号，但是，您应该将它们视为内核简单传递给驱动程序的一个简单的额外参数。驱动程序本身知道如何管理次要编号。
- en: 'In fact, if we examine it by using the `ls` command, we see the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们使用`ls`命令检查它，我们会看到以下内容：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the initial character, `c`, points out that this `chrdev` file is not
    a usual file (which is represented by a `-` character) but it's a character device
    file instead.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，初始字符`c`指出这个`chrdev`文件不是一个普通文件（用`-`字符表示），而是一个字符设备文件。
- en: OK. Now that we have our file *connected* to our driver, let's try our testing
    program on it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在我们的文件*已连接*到我们的驱动程序，让我们在上面尝试我们的测试程序。
- en: 'We get the following output on the Terminal:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在终端上得到以下输出：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, on the serial console (or via `dmesg`), we get the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在串行控制台（或通过`dmesg`），我们得到以下输出：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is exactly what we expected! As stated in *step 4* here we can verify that
    all system calls  `open()`, `close()` (called as `release()`), `read()`, and `write()`,
    we defined in the driver, are effectively executed by the call of the corresponding
    method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们所期望的！如*步骤4*中所述，我们可以验证所有系统调用`open()`、`close()`（称为`release()`）、`read()`和`write()`，我们在驱动程序中定义的，是否通过调用相应的方法有效执行。
- en: Note that, if you execute the `chrdev_test` program directly on the serial console,
    all of the preceding messages will overlap each other and you may not easily recognize
    them! So, let me suggest you use a SSH connection to execute the test.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您直接在串行控制台上执行`chrdev_test`程序，所有先前的消息将重叠在一起，您可能无法轻松识别它们！因此，让我建议您使用SSH连接来执行测试。
- en: See also
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For further information regarding how to register character devices by using
    legacy functions, a good starting point are some old (but still existing) pages
    of *The Linux Kernel Module Programming Guide* at [https://www.tldp.org/LDP/lkmpg/2.6/html/x569.html](https://www.tldp.org/LDP/lkmpg/2.6/html/x569.html)
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关如何使用传统功能注册字符设备的更多信息，一个很好的起点是*Linux内核模块编程指南*的一些旧（但仍然存在）页面[https://www.tldp.org/LDP/lkmpg/2.6/html/x569.html](https://www.tldp.org/LDP/lkmpg/2.6/html/x569.html)
- en: Exchanging data with a char driver
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与字符驱动程序交换数据
- en: In this recipe we'll see how to read and write data to and from a driver according
    to `read()` and `write()` system calls behaviors.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将看到如何根据`read()`和`write()`系统调用的行为从驱动程序中读取和写入数据。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To modify our first char driver in order to allow it to exchange data between
    user space we can still work on the module used in the previous recipe.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修改我们的第一个字符驱动程序，以便允许它在用户空间之间交换数据，我们仍然可以在上一个配方中使用的模块上进行工作。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In order to exchange data with our new driver, we need to modify the `read()`
    and `write()` methods according to what we said earlier, and we have to add a
    data buffer where exchanged data can be stored:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与我们的新驱动程序交换数据，我们需要根据我们之前说的修改`read()`和`write()`方法，并且我们必须添加一个数据缓冲区，用于存储交换的数据：
- en: 'So, let''s modify our file, `chrdev_legacy.c`, as follows, in order to include
    the `linux/uaccess.h` file and to define our internal buffer:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们修改我们的文件`chrdev_legacy.c`，如下所示，以包括`linux/uaccess.h`文件并定义我们的内部缓冲区：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, the `chrdev_read()` method should be modified, as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`chrdev_read()`方法应该修改如下：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'All of the preceding modifications and the next ones in this section can be
    easily applied by using the `modify_read_write_to_chrdev_legacy.patch` patch file
    from GitHub sources, issuing the following command line in the same directory
    where the `chrdev_legacy.c` file is located:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所有先前的修改和本节中的下一个修改都可以通过使用GitHub来源中的`modify_read_write_to_chrdev_legacy.patch`补丁文件轻松应用，发出以下命令行，该命令行位于`chrdev_legacy.c`文件所在的同一目录中：
- en: '`$ patch -p3 < modify_read_write_to_chrdev_legacy.patch`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ patch -p3 < modify_read_write_to_chrdev_legacy.patch`'
- en: 'We can repeat this for the `chrdev_write()` method:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以重复这个过程，对`chrdev_write()`方法进行修改：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 2*, with the preceding modifications to our `chrdev_read()` method,
    now we will copy the supplied data from the user space by using the `copy_to_user()` function
    in the driver's internal buffer while moving the `ppos` pointer accordingly and
    then returning how much data has been read (or error).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，通过对我们的`chrdev_read()`方法进行上述修改，现在我们将使用`copy_to_user()`函数将用户空间提供的数据复制到驱动程序的内部缓冲区中，同时移动`ppos`指针，并返回已读取的数据量（或错误）。
- en: Note that `copy_from/to_user()` functions return zero on success or non-zero
    to indicate the number of bytes that weren't transferred, so, here, we should
    account for this situation (even if rare) and properly update `count`, subtracting
    the number of bytes not transferred (if any), in order to correctly update `ppos` and
    return a correct count value to user space. However, to keep the example as simple
    as possible, we simply prefer return an error condition.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`copy_from/to_user()`函数在成功时返回零，或者返回非零以指示未传输的字节数，因此在这里，我们应该考虑这种情况（即使很少发生），并适当更新`count`，减去未传输的字节数（如果有的话），以便正确更新`ppos`并向用户空间返回正确的计数值。但是，为了尽可能简单，我们只是选择返回错误条件。
- en: Note also that, in case `*ppos + count` points beyond the buffer end, `count` is
    recomputed accordingly and the function will return a value representing the number
    of transferred bytes, which is smaller than the original `count` value provided
    in input (which represented the size of the provided destination user buffer and
    so the maximum length of data allowed for transfer).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，如果`*ppos + count`指向缓冲区末尾之外，`count`将相应地重新计算，并且该函数将返回表示传输字节数的值，该值小于输入时提供的原始`count`值（该值表示提供的目标用户缓冲区的大小，因此是允许传输的数据的最大长度）。
- en: In *step 3*, we can consider the same note as before regarding the `copy_to_user()`
    return value. However, additionally on `copy_from_user()`, if some data could
    not be copied, this function will pad the copied data to the requested size using
    zero bytes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们可以考虑与`copy_to_user()`返回值相同的注意事项。但是，另外在`copy_from_user()`上，如果无法复制一些数据，该函数将使用零字节填充已复制的数据以达到请求的大小。
- en: As we can see, this function is very similar to the preceding one, even if it
    implements the opposite data flow.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个函数与前一个函数非常相似，即使它实现了相反的数据流。
- en: There's more...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'After the modifications are in place and the new driver version has been recompiled
    and correctly loaded into ESPRESSObin''s kernel, we can again execute our testing
    program, `chrdev_test`. We should get the following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 修改完成并且新的驱动程序版本已经重新编译并正确加载到ESPRESSObin的内核中后，我们可以再次执行我们的测试程序`chrdev_test`。我们应该会得到以下输出：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'From the serial console, we should see something as similar to the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从串行控制台，我们应该看到类似于以下内容：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'OK. We got exactly what we expected! In fact, from kernel messages, we can
    see the calling of `chrdev_open()` and then what happens when `chrdev_write()`
    and `chrdev_read()` are called: 11 bytes are transferred and the `ppos` pointer
    is moved as we expected. Then, `chrdev_release()` is called and the file definitely
    closed.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。我们得到了我们预期的结果！实际上，从内核消息中，我们可以看到`chrdev_open()`的调用，然后当调用`chrdev_write()`和`chrdev_read()`时发生了什么：传输了11个字节，并且`ppos`指针移动了我们预期的位置。然后，调用了`chrdev_release()`，文件被关闭。
- en: 'Now a question: what happens if we call the preceding command again?'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一个问题：如果我们再次调用前面的命令会发生什么？
- en: Well, we should expect exactly the same output; in fact, each time the file
    is opened, `ppos` is re-positioned at the file beginning (that is, to 0) and we
    continue reading and writing at the same positions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们应该期望完全相同的输出；实际上，每次打开文件时，`ppos`都会重新定位到文件开头（即0），我们继续在相同的位置读取和写入。
- en: 'The following is the output of this second execution:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第二次执行的输出：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Additionally, the following are the related kernel messages:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下是相关的内核消息：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we wish to read the data just written data, we can modify the `chrdev_test`
    program in such a way it will close and then reopen the file after calling `write()`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望读取刚刚写入的数据，我们可以修改`chrdev_test`程序，使其在调用`write()`后关闭然后重新打开文件：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that all of these modifications are stored in the `modify_close_open_to_chrdev_test.patch`
    patch file from GitHub sources and it can be applied by using the following command
    where the `chrdev_test.c` file is located:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有这些修改都存储在GitHub来源的`modify_close_open_to_chrdev_test.patch`补丁文件中，可以使用以下命令应用该补丁，该命令位于`chrdev_test.c`文件所在的位置：
- en: '`$ patch -p2 < modify_close_open_to_chrdev_test.patch`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ patch -p2 < modify_close_open_to_chrdev_test.patch`'
- en: 'Now, if we try to execute `chrdev_test` again, we should get the following
    output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次尝试执行`chrdev_test`，我们应该会得到以下输出：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Perfect! Now, we read exactly what we wrote and, from the kernel space, we
    get the following messages:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在，我们读取到了我们写入的内容，并且从内核空间中，我们得到了以下消息：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, we can see perfectly what happens to `ppos`, and how the `chrdev_read()`
    and `chrdev_write()` methods work in order to exchange data with the user space.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以清楚地看到`ppos`发生了什么，以及`chrdev_read()`和`chrdev_write()`方法是如何工作的，以便与用户空间交换数据。
- en: See also
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For further information regarding `read()` and `write()` system calls, the reader
    can start reading the related man pages, which can be obtained with the usual
    commands: `man 2 read` and `man 2 write`.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`read()`和`write()`系统调用的更多信息，读者可以开始阅读相关的man页面，可以使用以下常规命令获得：`man 2 read`和`man
    2 write`。
- en: Note that, this time, we have to specify section 2 of the man pages (system-calls);
    otherwise, we will get information straight from section 1 (executable programs).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次我们必须指定手册页的第2节（系统调用）；否则，我们将直接从第1节（可执行程序）获取信息。
- en: Alternatively, regarding the `copy_from_user()` and `copy_to_user()` functions,
    the reader can take a look at *The Linux Kernel API* at [https://www.kernel.org/doc/htmldocs/kernel-api/API---copy-from-user.html](https://www.kernel.org/doc/htmldocs/kernel-api/API---copy-from-user.html)
    and [https://www.kernel.org/doc/htmldocs/kernel-api/API---copy-to-user.html](https://www.kernel.org/doc/htmldocs/kernel-api/API---copy-to-user.html).
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`copy_from_user()`和`copy_to_user()`函数，读者可以查看[https://www.kernel.org/doc/htmldocs/kernel-api/API---copy-from-user.html](https://www.kernel.org/doc/htmldocs/kernel-api/API---copy-from-user.html)和[https://www.kernel.org/doc/htmldocs/kernel-api/API---copy-to-user.html](https://www.kernel.org/doc/htmldocs/kernel-api/API---copy-to-user.html)上的*Linux内核API*。
- en: Using the “Everything Is a File” abstraction
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用“一切皆文件”抽象
- en: When we introduced device drivers we said that they lay under the Unix file
    abstraction; that is, in a Unix-like OS, everything is a file. Now, it's time
    to verify it, so let's see what happens if we try to execute some file-related
    utility programs against our new driver.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们介绍设备驱动程序时，我们说它们位于Unix文件抽象之下；也就是说，在类Unix操作系统中，一切都是文件。现在，是时候验证它了，所以让我们看看如果我们尝试对我们的新驱动程序执行一些与文件相关的实用程序会发生什么。
- en: Thanks to our latest modifications to the `chrdev_legacy.c` file, our driver
    simulates a file 300 bytes long (see the `chrdev_buf[BUF_LEN]` buffer where `BUF_LEN` is
    set to `300`), where we're able to execute `read()` and `write()` system calls
    on it, just as we do on a *normal* file.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对`chrdev_legacy.c`文件进行了最新的修改，我们的驱动程序模拟了一个300字节长的文件（参见`chrdev_buf[BUF_LEN]`缓冲区，其中`BUF_LEN`设置为`300`），我们可以在其上执行`read()`和`write()`系统调用，就像我们在*普通*文件上做的那样。
- en: 'However, we may still have some doubts, so let''s consider standard `cat` or `dd` commands,
    as we know they are utilities useful to manipulate files content. For example,
    in the man pages of the `cat` command, we can read the following definition:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可能仍然有一些疑问，所以让我们考虑标准的`cat`或`dd`命令，因为我们知道它们是用于操作文件内容的实用程序。例如，在`cat`命令的man页面中，我们可以读到以下定义：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And, for `dd`, we have the following definition:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`dd`，我们有以下定义：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We don't see any reference to device drivers, only to files, so if our driver
    works like a file, we should be able to use these commands on it!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有看到任何与设备驱动程序的引用，只有文件，因此如果我们的驱动程序像文件一样工作，我们应该能够在其上使用这些命令！
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To check how the “Everything Is a File” abstraction we can still use our new
    character driver which can be managed as it was a regular file. So let's be sure
    that the driver is correctly loaded in the kernel and move to the next section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查“一切都是文件”的抽象，我们仍然可以使用我们的新字符驱动程序，它可以像处理常规文件一样进行管理。因此，让我们确保驱动程序已正确加载到内核中，并转到下一节。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s see how to do it by following these steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤来操作：
- en: 'First of all, we can try to clear the driver''s buffer by writing into it all
    `0` characters with the following command:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以尝试通过以下命令将所有`0`字符写入驱动程序的缓冲区以清除它：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, we can read just written data by using the `cat` command, as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用`cat`命令读取刚刚写入的数据，如下所示：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Perfect! As we can see, we erased the driver's internal buffer, as expected.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！正如我们所预期的那样，我们擦除了驱动程序的内部缓冲区。
- en: The reader should notice that we use the `tr` command in order to translate
    data bytes 0 to the printable character 0; otherwise, we'll see garbage (or most
    probably nothing).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应该注意，我们使用`tr`命令来将数据字节0转换为可打印字符0；否则，我们会看到垃圾（或很可能什么也看不到）。
- en: See the `tr` man page with `man tr` for further information about its usage.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅`man tr`中的`tr`手册页，以获取有关其用法的更多信息。
- en: 'Now, we can try to move a normal file data into our char device; for instance,
    if we consider the `/etc/passwd` file, we should see something as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试将普通文件数据移入我们的字符设备；例如，如果我们考虑`/etc/passwd`文件，我们应该看到以下内容：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This file is larger than 300 bytes but we can still try to move it into our
    char driver with the next command line:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件大于300字节，但我们仍然可以尝试使用下一个命令将其移入我们的字符驱动程序：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We get an error message, as expected, due to the fact our file cannot hold
    more than 300 bytes. However, the really interesting things to see are in the
    kernel:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们预期的那样，由于我们的文件不能容纳超过300字节，我们收到了错误消息。然而，真正有趣的事情在于内核中：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Even if we get an error, from the preceding kernel messages, we see that some
    data has been actually written in our char driver, so we can try to find a specific
    line in it with the next command line using the `grep` command:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使我们收到错误消息，从前面的内核消息中，我们看到确实已经写入了一些数据到我们的字符驱动程序中，所以我们可以尝试使用`grep`命令来找到其中的特定行：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For further information about `grep`, just see its man page with `man grep`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`grep`的更多信息，请参阅其`man`手册页。
- en: 'Since the line referring to the root user is one of the first lines in `/etc/passwd`,
    it has definitely been copied into the char driver, and then we get it as expected.
    For completeness, below are reported the relative kernel messages where we can
    see all system calls that `grep` does on our driver:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于引用根用户的行是`/etc/passwd`中的第一行之一，它肯定已经被复制到字符驱动程序中，然后我们按预期得到它。为了完整起见，下面报告了相对内核消息，我们可以在其中看到`grep`在我们的驱动程序上执行的所有系统调用：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'With the preceding `dd` command, we generate three blocks that are 100 bytes
    long and that we pass to the `write()` system calls; in fact, if we take a look
    at kernel messages, we explicitly see what happens:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的`dd`命令，我们生成了三个长度为100字节的块，并将它们传递给`write()`系统调用；实际上，如果我们查看内核消息，我们明确看到了发生了什么：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At first calling, after `open()`, `ppos` is set to `0`, and then it's moved
    to 100 after the data has been written. Then, on the next calls, `ppos` is increased
    by 100 bytes until it reaches 300.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首次调用后，在`open()`之后，`ppos`设置为`0`，然后在写入数据后移动到100。然后，在下一次调用中，`ppos`每次增加100字节，直到达到300。
- en: 'In *step 2*, it''s really interesting to see what happened in the kernel space
    when we issue the `cat` command, so let''s see the kernel messages related to
    it:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，当我们发出`cat`命令时，看到内核空间中发生了什么是非常有趣的，所以让我们看看与此相关的内核消息：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As we can see, `cat` asks for 131,072 bytes but, since our buffer is shorter, only
    300 bytes are returned; then, `cat` executes again `read()` asking for 131,072
    bytes but now `ppos` points to the end of file, so 0 is returned just to signal
    the end-of-file condition.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`cat`要求131,072字节，但由于我们的缓冲区较短，只返回了300字节；然后，`cat`再次执行`read()`，要求131,072字节，但现在`ppos`指向文件末尾，因此返回0，表示文件结束的条件。
- en: 'When we try to write too much data into our device file, we obviously get an
    error message, but the really interesting things to see are in the kernel:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试将太多数据写入设备文件时，显然会收到错误消息，但真正有趣的事情在于内核中的情况：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: First, the `write()` call asks to write 1,285 bytes (which is the real size
    of `/etc/passwd`) but only 300 bytes are actually written (due to the limited
    buffer size). Then, the second `write()` call asks to write 985 bytes (*1,285-300*
    bytes) but now `ppos` points to 300, which means that the buffer is full and then
    0 (bytes written) is returned, which has been interpreted as a No space left on
    device error condition by the write command.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`write()`调用要求写入1,285字节（这是`/etc/passwd`的实际大小），但实际只写入了300字节（由于有限的缓冲区大小）。然后，第二个`write()`调用要求写入985字节（*1,285-300*字节），但现在`ppos`指向300，这意味着缓冲区已满，然后返回0（写入的字节数），这被写入命令解释为设备上没有空间的错误条件。
- en: 'In *step 4*, the kernel messages relative to the preceding `grep` command are
    reported as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，与前面的`grep`命令相关的内核消息报告如下：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can easily see that the `grep` command first opens our device file by using
    the `open()` system call, then it keeps reading data with `read()` until our driver
    returns end-of-file (which is addressed by 0), and finally it executes the `close()`
    system call to release our driver.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地看到，`grep`命令首先使用`open()`系统调用打开我们的设备文件，然后使用`read()`持续读取数据，直到我们的驱动程序返回文件结束（用0表示），最后执行`close()`系统调用释放我们的驱动程序。
