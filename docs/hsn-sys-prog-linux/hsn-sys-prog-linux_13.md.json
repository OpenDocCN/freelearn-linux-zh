["```\n#include <unistd.h>\nunsigned int alarm(unsigned int seconds);\n```", "```\n[...]\n/* Init sigaction to defaults via the memset,\n * setup 'sig_handler' as the signal handler function,\n * trap just the SIGALRM signal.\n */\n memset(&act, 0, sizeof(act));\n act.sa_handler = sig_handler;\n if (sigaction(SIGALRM, &act, 0) < 0)\n     FATAL(\"sigaction on SIGALRM failed\");\n\n alarm(n);\n printf(\"A timeout for %ds has been armed...\\n\", n);\n pause(); /* wait for the signal ... */\n```", "```\nstatic void sig_handler(int signum)\n{\n    const char *str = \" *** Timeout! [SIGALRM received] ***\\n\";\n    if (signum != SIGALRM)\n        return;\n    if (write(STDOUT_FILENO, str, strlen(str)) < 0)\n        WARN(\"write str failed!\");\n}\n```", "```\n$ make alarm1\ngcc -Wall -UDEBUG -c ../common.c -o common.o\ngcc -Wall -UDEBUG -c alarm1.c -o alarm1.o\ngcc -Wall -UDEBUG -o alarm1 alarm1.o common.o \n$ ./alarm1 \nUsage: ./alarm1 seconds-to-timeout(>0)\n$ ./alarm1 3\nA timeout for 3s has been armed...\n    *** Timeout! [SIGALRM received] ***            *<< 3 seconds later! >>*\n$ \n```", "```\n[...]\nalarm(n);\nprintf(\"A timeout for %ds has been armed...\\n\", n);\n/* (Manually) re-invoke the alarm every 'n' seconds */\nwhile (1) {\n    pause(); /* wait for the signal ... */\n    alarm(n);\n    printf(\" Timeout for %ds has been (re)armed...\\n\", n);\n}\n[...]\n```", "```\n$ ./alarm2_rep 1\nA timeout for 1s has been armed...\n *** Timeout! [SIGALRM received] ***\n Timeout for 1s has been (re)armed...\n *** Timeout! [SIGALRM received] ***\n Timeout for 1s has been (re)armed...\n *** Timeout! [SIGALRM received] ***\n Timeout for 1s has been (re)armed...\n *** Timeout! [SIGALRM received] ***\n Timeout for 1s has been (re)armed...\n^C\n$ \n```", "```\n#include <sys/time.h>\nint getitimer(int which, struct itimerval *curr_value);\nint setitimer(int which, const struct itimerval *new_value,\n                struct itimerval *old_value);\n```", "```\nstruct itimerval {\n    struct timeval it_interval;    /* Interval for periodic timer */\n    struct timeval it_value;       /* Time until next expiration */\n};\n\nstruct timeval {\n    time_t      tv_sec;            /* seconds */\n    suseconds_t tv_usec;           /* microseconds */\n};\n```", "```\nstruct itimerval mytimer;\nmemset(&mytimer, 0, sizeof(struct itimerval));\nmytimer.it_value.tv_sec = 1;\nmytimer.it_interval.tv_sec = 1;\nsetitimer(ITIMER_REAL, &mytimer, 0);\n```", "```\nstatic volatile sig_atomic_t opt;\n[...]\nint main(int argc, char **argv)\n{\n    struct sigaction act;\n    struct itimerval mytimer;\n[...]\n    memset(&act, 0, sizeof(act));\n    act.sa_handler = ticktock;\n    sigfillset(&act.sa_mask); /* disallow all signals while handling */\n    /*\n    * We deliberately do *not* use the SA_RESTART flag;\n    * if we do so, it's possible that any blocking syscall gets\n    * auto-restarted. In a timeout context, we don't want that\n    * to happen - we *expect* a signal to interrupt our blocking\n    * syscall (in this case, the pause(2)).\n    * act.sa_flags = SA_RESTART;\n    */\n    if (sigaction(SIGALRM, &act, 0) < 0)\n        FATAL(\"sigaction on SIGALRM failed\");\n    /* Setup a single second (repeating) interval timer */\n    memset(&mytimer, 0, sizeof(struct itimerval));\n    mytimer.it_value.tv_sec = 1;\n mytimer.it_interval.tv_sec = 1;\n    if (setitimer(ITIMER_REAL, &mytimer, 0) < 0)\n        FATAL(\"setitimer failed\\n\");\n    while (1)\n        (void)pause();\n```", "```\nstatic void ticktock(int signum)\n{\n    char tmstamp[128];\n    struct timespec tm;\n    int myerrno = errno;\n\n    /* Query the timestamp ; both clock_gettime(2) and\n     * ctime_r(3) are reentrant-and-signal-safe */\n    if (clock_gettime(CLOCK_REALTIME, &tm) < 0)\n        FATAL(\"clock_gettime failed\\n\");\n    if (ctime_r(&tm.tv_sec, &tmstamp[0]) == NULL)\n        FATAL(\"ctime_r failed\\n\");\n\n    if (opt == 0) {\n        if (write(STDOUT_FILENO, tmstamp, strlen(tmstamp)) < 0)\n            FATAL(\"write failed\\n\");\n    } else if (opt == 1) {\n      /* WARNING! Using the printf / fflush here in a signal handler is\n       * unsafe! We do so for the purposes of this demo app only; do not\n       * use in production.\n       */\n        tmstamp[strlen(tmstamp) - 1] = '\\0';\n        printf(\"\\r%s\", tmstamp);\n        fflush(stdout);\n    }\n    errno = myerrno;\n}\n```", "```\ntime(2)\nlocaltime(3)\nstrftime(3)\n```", "```\nint clock_gettime(clockid_t clk_id, struct timespec *tp);\n```", "```\nstruct timespec {\n    time_t tv_sec; /* seconds */\n    long tv_nsec; /* nanoseconds */\n };\n```", "```\nchar *ctime_r(const time_t *timep, char *buf);\n```", "```\n$ ./intv_clksimple\nUsage: ./intv_clksimple {0|1}\n 0 : the Correct way (using write(2) in the signal handler)\n 1 : the *Wrong* way (using printf(3) in the signal handler) *@your risk*\n$ ./intv_clksimple 0\nThu Jun 28 17:52:38 2018\nThu Jun 28 17:52:39 2018\nThu Jun 28 17:52:40 2018\nThu Jun 28 17:52:41 2018\nThu Jun 28 17:52:42 2018\n^C\n$ \n```", "```\n$ ./intv_clksimple 1\n *WARNING* [Using printf in signal handler]\nThu Jun 28 17:54:53 2018^C\n$ \n```", "```\nstatic void profalrm(int signum)\n{\n    /* In production, do Not use signal-unsafe APIs like this! */\n    printf(\"In %s:%d sig=%d\\n\", __func__, __LINE__, signum);\n}\n\n[...]\n\n// in main() ...\n\nstruct sigaction act;\nstruct itimerval t1;\n\nmemset(&act, 0, sizeof(act));\nact.sa_handler = profalrm;\nsigfillset(&act.sa_mask); /* disallow all signals while handling */\nif (sigaction(SIGPROF, &act, 0) < 0)\n    FATAL(\"sigaction on SIGALRM failed\");\n\n[...]\n\nmemset(&t1, 0, sizeof(struct itimerval));\nt1.it_value.tv_sec = 1;\nt1.it_interval.tv_sec = 1;\nif (setitimer(ITIMER_PROF, &t1, 0) < 0)\n    FATAL(\"setitimer failed\\n\");\n\nwhile (1)\n    (void)pause();\n```", "```\n[...]\nmemset(&t1, 0, sizeof(struct itimerval));\nt1.it_value.tv_sec = 0;\nt1.it_value.tv_usec = 10000;       // 10,000 us = 10 ms\nt1.it_interval.tv_sec = 0;\nt1.it_interval.tv_usec = 10000;    // 10,000 us = 10 ms\nif (setitimer(ITIMER_PROF, &t1, 0) < 0)\n    FATAL(\"setitimer failed\\n\");\n\nwhile (1) {\n    DELAY_LOOP_SILENT(20);\n    (void)pause();\n}\n```", "```\nIn profalrm:34 sig=27\nIn profalrm:34 sig=27\nIn profalrm:34 sig=27\nIn profalrm:34 sig=27\nIn profalrm:34 sig=27\n...\n```", "```\n#include <signal.h>\n#include <time.h>\nint timer_create(clockid_t clockid, struct sigevent *sevp,\n                 timer_t *timerid);\nLink with -lrt.\n```", "```\n#include <signal.h>\n\nunion sigval {     /* Data passed with notification */\n    int sival_int;      /* Integer value */\n    void *sival_ptr;    /* Pointer value */\n };\n\nstruct sigevent {\n    int sigev_notify;         /* Notification method */\n    int sigev_signo;          /* Notification signal */\n    union sigval sigev_value; /* Data passed with notification */\n    void (*sigev_notify_function) (union sigval);\n    /* Function used for thread notification (SIGEV_THREAD) */\n    void *sigev_notify_attributes; /* Attributes for notification \n    thread(SIGEV_THREAD) */\n    pid_t sigev_notify_thread_id;\n             /* ID of thread to signal (SIGEV_THREAD_ID) */\n };\n```", "```\n#include <time.h>\nint timer_settime(timer_t timerid, int flags,\n                    const struct itimerspec *new_value,\n                    struct itimerspec *old_value);\nLink with -lrt.\n```", "```\nstruct timespec {\n    time_t tv_sec; /* Seconds */\n    long tv_nsec;  /* Nanoseconds */\n};\n\nstruct itimerspec {\n    struct timespec it_interval; /* Timer interval */\n    struct timespec it_value;    /* Initial expiration */\n};\n```", "```\n#include <time.h>\nint timer_gettime(timer_t timerid, struct itimerspec *curr_value);\n```", "```\nstruct sigaction act;\n[...]\n// Trap SIGRTMIN : delivered on (interval) timer expiry\nmemset(&act, 0, sizeof(act));\nact.sa_flags = SA_SIGINFO | SA_RESTART;\nact.sa_sigaction = timer_handler;\nif (sigaction(SIGRTMIN, &act, NULL) == -1)\n    FATAL(\"sigaction SIGRTMIN failed\\n\");\n```", "```\nstruct sigevent sev;\n[...]\n/* Create and init the timer */\nsev.sigev_notify = SIGEV_SIGNAL;\nsev.sigev_signo = SIGRTMIN;\nsev.sigev_value.sival_ptr = &timerid;\nif (timer_create(CLOCK_REALTIME, &sev, &timerid) == -1)\n    FATAL(\"timer_create failed\\n\");\n```", "```\nstatic struct itimerspec itv;    // global\n[...]\nstatic void arm_timer(timer_t tmrid, struct itimerspec *itmspec)\n{\n    VPRINT(\"Arming timer now\\n\");\n    if (timer_settime(tmrid, 0, itmspec, NULL) == -1)\n        FATAL(\"timer_settime failed\\n\");\n    jumped_the_gun = 0;\n}\n[...]\nprintf(\"Initializing timer to generate SIGRTMIN every %ld ms\\n\",\n freq_ms);\nmemset(&itv, 0, sizeof(struct itimerspec));\nitv.it_value.tv_sec = (freq_ms * 1000000) / 1000000000;\nitv.it_value.tv_nsec = (freq_ms * 1000000) % 1000000000;\nitv.it_interval.tv_sec = (freq_ms * 1000000) / 1000000000;\nitv.it_interval.tv_nsec = (freq_ms * 1000000) % 1000000000;\n[...]\narm_timer(timerid, &itv);\n```", "```\n/* \n * The realtime signal (SIGRTMIN) - timer expiry - handler.\n * WARNING! Using the printf in a signal handler is unsafe!\n * We do so for the purposes of this demo app only; do Not\n * use in production.\n */\nstatic void timer_handler(int sig, siginfo_t * si, void *uc)\n{\n  char buf[] = \".\";\n\n  c++;\n  if (verbose) {\n      write(2, buf, 1);\n#define SHOW_OVERRUN 1\n#if (SHOW_OVERRUN == 1)\n    {\n          int ovrun = timer_getoverrun(timerid);\n          if (ovrun == -1)\n              WARN(\"timer_getoverrun\");\n          else {\n              if (ovrun)\n                  printf(\" overrun=%d [@count=%d]\\n\", ovrun, c);\n          }\n    }\n#endif\n  }\n}\n```", "```\nWe shall start a timer anywhere between 1 and 5 seconds of starting this app.\n\nGET READY ...\n [ when the \"QUICK! Press ^C\" message appears, press ^C quickly as you can ]\n```", "```\n$ ./react \nUsage: ./react <freq-in-millisec> [verbose-mode:[0]|1]\n  default: verbosity is off\n  f.e.: ./react 100   => timeout every 100 ms, verbosity Off\n      : ./react   5 1 => timeout every   5 ms, verbosity On\n\nHow fast can you react!?\nOnce you run this app with the freq-in-millisec parameter,\nwe shall start a timer anywhere between 1 and 5 seconds of\nyour starting it. Watch the screen carefully; the moment\nthe message \"QUICK! Press ^C\" appears, press ^C (Ctrl+c simultaneously)!\nYour reaction time is displayed... Have fun!\n\n$ \n```", "```\n$ ./react 10\nInitializing timer to generate SIGRTMIN every 10 ms\n[Verbose: N]\nWe shall start a timer anytime between 1 and 5 seconds from now...\n\nGET READY ...\n [ when the \"QUICK! Press ^C\" message appears, press ^C quickly as you can ]\n```", "```\n*** QUICK! Press ^C !!! ***\n^C\n*** PRESSED ***\n Your reaction time is precisely 0.404794198 s.ns [~= 405 ms, count=40]\n$ \n```", "```\n$ ./react 10 1\nInitializing timer to generate SIGRTMIN every 10 ms\ntimer struct ::\n it_value.tv_sec = 0 it_value.tv_nsec = 10000000\n it_interval.tv_sec = 0 it_interval.tv_nsec = 10000000\n[SigBlk: -none-]\n[Verbose: Y]\nWe shall start a timer anytime between 1 and 5 seconds from now...\n\nGET READY ...\n [ when the \"QUICK! Press ^C\" message appears, press ^C quickly as you can ]\n```", "```\nreact.c:arm_timer:161: Arming timer now\n\n*** QUICK! Press ^C !!! *\n```", "```\n.....................................^C\n*** PRESSED ***\n Your reaction time is precisely 0.379339662 s.ns [~= 379 ms, count=37]\n$ \n```", "```\nstatic int init(void)\n{\n struct sigevent sev;\n  struct rlimit rlim;\n  struct sigaction act;\n\n  // Trap SIGRTMIN : delivered on (interval) timer expiry\n  memset(&act, 0, sizeof(act));\n  act.sa_flags = SA_SIGINFO | SA_RESTART;\n  act.sa_sigaction = timer_handler;\n  if (sigaction(SIGRTMIN, &act, NULL) == -1)\n    FATAL(\"sigaction SIGRTMIN failed\\n\");\n\n[...]\n\n/* Create and init the timer */\n  sev.sigev_notify = SIGEV_SIGNAL;\n  sev.sigev_signo = SIGRTMIN;\n  sev.sigev_value.sival_ptr = &timerid;\n  if (timer_create(CLOCK_REALTIME, &sev, &timerid) == -1)\n    FATAL(\"timer_create failed\\n\");\n\n  printf(\"Initializing timer to generate SIGRTMIN every %ld ms\\n\",\n         freq_ms);\n  memset(&itv, 0, sizeof(struct itimerspec));\n  itv.it_value.tv_sec = (freq_ms * 1000000) / 1000000000;\n  itv.it_value.tv_nsec = (freq_ms * 1000000) % 1000000000;\n  itv.it_interval.tv_sec = (freq_ms * 1000000) / 1000000000;\n  itv.it_interval.tv_nsec = (freq_ms * 1000000) % 1000000000;\n[...]\n```", "```\n/* random_start\n * The element of surprise: fire off an 'alarm' - resulting in SIGALRM being\n * delivered to us - in a random number between [min..max] seconds.\n */\nstatic void random_start(int min, int max)\n{\n    unsigned int nr;\n\n    alarm(0);\n    srandom(time(0));\n    nr = (random() % max) + min;\n\n#define CHEAT_MODE     0\n#if (CHEAT_MODE == 1)\n    printf(\"Ok Cheater :-) get ready; press ^C in %ds ...\\n\", nr);\n#endif\n alarm(nr);\n}\n```", "```\n#define MIN_START_SEC 1\n#define MAX_START_SEC 5\n[...]\nrandom_start(MIN_START_SEC, MAX_START_SEC);\n```", "```\nstatic void arm_timer(timer_t tmrid, struct itimerspec *itmspec)\n{\n  VPRINT(\"Arming timer now\\n\");\n  if (timer_settime(tmrid, 0, itmspec, NULL) == -1)\n      FATAL(\"timer_settime failed\\n\");\n  jumped_the_gun = 0;\n}\n\n/*\n * startoff\n * The signal handler for SIGALRM; arrival here implies the app has\n * \"started\" - we shall arm the interval timer here, it will start\n * running immediately. Take a timestamp now.\n */\nstatic void startoff(int sig)\n{\n  char press_msg[] = \"\\n*** QUICK! Press ^C !!! ***\\n\";\n\n  arm_timer(timerid, &itv);\n  write(STDERR_FILENO, press_msg, strlen(press_msg));\n\n  //\u2014- timestamp it: start time\n  if (clock_gettime(CLOCK_REALTIME, &tm_start) < 0)\n      FATAL(\"clock_gettime (tm_start) failed\\n\");\n}\n```", "```\nstatic volatile sig_atomic_t gTimerRepeats = 0, c = 0, first_time = 1,\n    jumped_the_gun = 1; [...] static void timer_handler(int sig, siginfo_t * si, void *uc)\n{\n  char buf[] = \".\";\n\n  c++;\n  if (verbose) {\n      write(2, buf, 1);\n#define SHOW_OVERRUN 1\n#if (SHOW_OVERRUN == 1)\n      {\n          int ovrun = timer_getoverrun(timerid);\n          if (ovrun == -1)\n              WARN(\"timer_getoverrun\");\n          else {\n              if (ovrun)\n                  printf(\" overrun=%d [@count=%d]\\n\", ovrun, c);\n          }\n    }\n#endif\n  }\n}\n```", "```\nstatic void userpress(int sig)\n{\n  struct timespec res;\n\n  // timestamp it: end time\n  if (clock_gettime(CLOCK_REALTIME, &tm_end) < 0)\n    FATAL(\"clock_gettime (tm_end) failed\\n\");\n\n  [...]\n      printf(\"\\n*** PRESSED ***\\n\");\n      /* Calculate the delta; subtracting one struct timespec\n       * from another takes a little work. A retrofit ver of\n       * the 'timerspecsub' macro has been incorporated into\n       * our ../common.h header to do this.\n       */\n      timerspecsub(&tm_end, &tm_start, &res);\n      printf\n          (\" Your reaction time is precisely %ld.%ld s.ns\"\n           \" [~= %3.0f ms, count=%d]\\n\",\n           res.tv_sec, res.tv_nsec,\n           res.tv_sec * 1000 +\n             round((double)res.tv_nsec / 1000000), c);\n    }\n   [...]\n  c = 0;\n  if (!gTimerRepeats)\n    exit(EXIT_SUCCESS);\n}\n```", "```\n$ ./runwalk_timer \nUsage: ./runwalk_timer Run-for[sec] Walk-for[sec] [verbosity-level=0|[1]|2]\n Verbosity Level :: 0 = OFF [1 = LOW] 2 = HIGH\n$ \n```", "```\n$ ./runwalk_timer 5 2\n************* Run Walk Timer *************\n                  Ver 1.0\n\nGet moving... Run for 5 seconds\n.....        *<< each \".\" represents 1 second of elapsed time >>*\n*** Bzzzz!!! WALK! *** for 2 seconds\n..\n*** Bzzzz!!! RUN! *** for 5 seconds\n.....\n*** Bzzzz!!! WALK! *** for 2 seconds\n..\n*** Bzzzz!!! RUN! *** for 5 seconds\n....^C\n+++ Good job, bye! +++\n$ \n```", "```\n$ ./runwalk_timer 5 2 2\n************* Run Walk Timer *************\n                  Ver 1.0\n\nGet moving... Run for 5 seconds\ntrun= 5 twalk= 2; app ctx ptr = 0x7ffce9c55270\nrunwalk: 4.999s                    *<< query on time remaining >>*\nrunwalk: 3.999s\nrunwalk: 2.999s\nrunwalk: 1.999s\nrunwalk: 0.999s\nits_time: signal 34. runwalk ptr: 0x7ffce9c55270 Type: Run. Overrun: 0\n\n*** Bzzzz!!! WALK! *** for 2 seconds\nrunwalk: 1.999s\nrunwalk: 0.999s\nits_time: signal 34. runwalk ptr: 0x7ffce9c55270 Type: Walk. Overrun: 0\n\n*** Bzzzz!!! RUN! *** for 5 seconds\nrunwalk: 4.999s\nrunwalk: 3.999s\nrunwalk: 2.999s\nrunwalk: 1.999s\nrunwalk: 0.999s\nits_time: signal 34. runwalk ptr: 0x7ffce9c55270 Type: Run. Overrun: 0\n\n*** Bzzzz!!! WALK! *** for 2 seconds\nrunwalk: 1.999s\nrunwalk: 0.999s\nits_time: signal 34. runwalk ptr: 0x7ffce9c55270 Type: Walk. Overrun: 0\n\n*** Bzzzz!!! RUN! *** for 5 seconds\nrunwalk: 4.999s\nrunwalk: 3.999s\nrunwalk: 2.999s\n^C\n+++ Good job, bye! +++\n$ \n```", "```\n// Our app context data structure\ntypedef struct {\n  int trun, twalk;\n  int type;\n  struct itimerspec *itmrspec;\n  timer_t timerid;\n} sRunWalk;\n```", "```\nint main(int argc, char **argv)\n{\n  struct sigaction act;\n  sRunWalk runwalk;\n  struct itimerspec runwalk_curval;\n[...]\n```", "```\n/*\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014 Our POSIX Timer setup\n * Setup a 'one-shot' POSIX Timer; initially set it to expire upon\n * 'run time' seconds elapsing.\n */\nstatic void runwalk_timer_init_and_arm(sRunWalk * ps)\n{\n  struct sigaction act;\n  struct sigevent runwalk_evp;\n\n  assert(ps);\n\n  act.sa_sigaction = its_time;\n  act.sa_flags = SA_SIGINFO;\n  sigfillset(&act.sa_mask);\n  if (sigaction(SIGRTMIN, &act, 0) < 0)\n      FATAL(\"sigaction: SIGRTMIN\");\n  memset(ps->itmrspec, 0, sizeof(sRunWalk));\n  ps->type = RUN;\n ps->itmrspec->it_value.tv_sec = ps->trun;\n\n  runwalk_evp.sigev_notify = SIGEV_SIGNAL;\n  runwalk_evp.sigev_signo = SIGRTMIN;\n  // Pass along the app context structure pointer\n runwalk_evp.sigev_value.sival_ptr = ps;\n\n  // Create the runwalk 'one-shot' timer\n  if (timer_create(CLOCK_REALTIME, &runwalk_evp, &ps->timerid) < 0)\n      FATAL(\"timer_create\");\n\n  // Arm timer; will exire in ps->trun seconds, triggering the RT signal\n  if (timer_settime(ps->timerid, 0, ps->itmrspec, NULL) < 0)\n      FATAL(\"timer_settime failed\");\n}\n[...]\nrunwalk_timer_init_and_arm(&runwalk);\n[...]\n```", "```\nstatic void its_time(int signum, siginfo_t *si, void *uctx)\n{\n  // Gain access to our app context\n volatile sRunWalk *ps = (sRunWalk *)si->si_value.sival_ptr;\n\n  assert(ps);\n  if (verbose == HIGH)\n    printf(\"%s: signal %d. runwalk ptr: %p\"\n           \" Type: %s. Overrun: %d\\n\",\n           __func__, signum,\n           ps,\n           ps->type == WALK ? \"Walk\" : \"Run\", \n           timer_getoverrun(ps->timerid)\n        );\n\n  memset(ps->itmrspec, 0, sizeof(sRunWalk));\n  if (ps->type == WALK) {\n    BUZZ(\" RUN!\");\n    ps->itmrspec->it_value.tv_sec = ps->trun;\n    printf(\" for %4d seconds\\n\", ps->trun);\n  }\n  else {\n    BUZZ(\" WALK!\");\n    ps->itmrspec->it_value.tv_sec = ps->twalk;\n    printf(\" for %4d seconds\\n\", ps->twalk);\n  }\n  ps->type = !ps->type; // toggle the type\n\n  // Reset: re-arm the one-shot timer\n  if (timer_settime(ps->timerid, 0, ps->itmrspec, NULL) < 0)\n    FATAL(\"timer_settime failed\");\n}\n```", "```\ninclude <sys/timerfd.h>\n\nint timerfd_create(int clockid, int flags);\n\nint timerfd_settime(int fd, int flags,\n const struct itimerspec *new_value, struct itimerspec *old_value);\n\nint timerfd_gettime(int fd, struct itimerspec *curr_value);\n```"]