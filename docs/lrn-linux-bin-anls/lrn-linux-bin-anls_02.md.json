["```\n#define EI_NIDENT 16\n           typedef struct {\n               unsigned char e_ident[EI_NIDENT];\n               uint16_t      e_type;\n               uint16_t      e_machine;\n               uint32_t      e_version;\n               ElfN_Addr     e_entry;\n               ElfN_Off      e_phoff;\n               ElfN_Off      e_shoff;\n               uint32_t      e_flags;\n               uint16_t      e_ehsize;\n               uint16_t      e_phentsize;\n               uint16_t      e_phnum;\n               uint16_t      e_shentsize;\n               uint16_t      e_shnum;\n               uint16_t      e_shstrndx;\n           } ElfN_Ehdr;\n```", "```\ntypedef struct {\n    uint32_t   p_type;   (segment type)\n    Elf32_Off  p_offset; (segment offset)\n    Elf32_Addr p_vaddr;   (segment virtual address)\n    Elf32_Addr p_paddr;    (segment physical address)\n    uint32_t   p_filesz;   (size of segment in the file)\n    uint32_t   p_memsz; (size of segment in memory)\n    uint32_t   p_flags; (segment flags, I.E execute|read|read)\n    uint32_t   p_align;  (segment alignment in memory)\n  } Elf32_Phdr;\n```", "```\ntypedef struct {\nElf32_Sword    d_tag;\n    union {\nElf32_Word d_val;\nElf32_Addr d_ptr;\n    } d_un;\n} Elf32_Dyn;\nextern Elf32_Dyn _DYNAMIC[];\n```", "```\nElf file type is EXEC (Executable file)\nEntry point 0x8049a30\nThere are 9 program headers, starting at offset 52\nProgram Headers:\n  Type          Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n  PHDR          0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4\n  INTERP        0x000154 0x08048154 0x08048154 0x00013 0x00013 R   0x1\n      [Requesting program interpreter: /lib/ld-linux.so.2]\n  LOAD          0x000000 0x08048000 0x08048000 0x1622c 0x1622c R E 0x1000\n  LOAD          0x016ef8 0x0805fef8 0x0805fef8 0x003c8 0x00fe8 RW  0x1000\n  DYNAMIC       0x016f0c 0x0805ff0c 0x0805ff0c 0x000e0 0x000e0 RW  0x4\n  NOTE          0x000168 0x08048168 0x08048168 0x00044 0x00044 R   0x4\n  GNU_EH_FRAME  0x016104 0x0805e104 0x0805e104 0x0002c 0x0002c R   0x4\n  GNU_STACK     0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4\n  GNU_RELRO     0x016ef8 0x0805fef8 0x0805fef8 0x00108 0x00108 R   0x1\n```", "```\ntypedef struct {\nuint32_t   sh_name; // offset into shdr string table for shdr name\n    uint32_t   sh_type; // shdr type I.E SHT_PROGBITS\n    uint32_t   sh_flags; // shdr flags I.E SHT_WRITE|SHT_ALLOC\n    Elf32_Addr sh_addr;  // address of where section begins\n    Elf32_Off  sh_offset; // offset of shdr from beginning of file\n    uint32_t   sh_size;   // size that section takes up on disk\n    uint32_t   sh_link;   // points to another section\n    uint32_t   sh_info;   // interpretation depends on section type\nuint32_t   sh_addralign; // alignment for address of section\nuint32_t   sh_entsize;  // size of each certain entries that may be in section\n} Elf32_Shdr;\n```", "```\nprintf(\"Hello World!\\n\");\n```", "```\nuint32_t\ndl_new_hash (const char *s)\n{\n        uint32_t h = 5381;\n\n        for (unsigned char c = *s; c != '\\0'; c = *++s)\n                h = h * 33 + c;\n\n        return h;\n}\n```", "```\nryan@alchemy:~$ gcc -c test.c\nryan@alchemy:~$ readelf -S test.o\n```", "```\n  [Nr] Name              Type            Addr           Off\n       Size              ES              Flg  Lk   Inf   Al\n  [ 0]                   NULL            00000000    000000\n       000000            00                   0    0     0\n  [ 1] .text             PROGBITS        00000000       000034\n       000034            00              AX   0    0     4\n  [ 2] .rel.text         REL             00000000       0003d0\n       000010            08                   10   1     4\n  [ 3] .data             PROGBITS        00000000 000068\n       000000            00              WA   0    0     4\n  [ 4] .bss              NOBITS          00000000       000068\n       000000            00              WA   0    0     4\n  [ 5] .comment          PROGBITS        00000000       000068\n       00002b            01              MS   0    0     1\n  [ 6] .note.GNU-stack   PROGBITS        00000000       000093\n       000000            00                   0    0     1\n  [ 7] .eh_frame         PROGBITS        00000000       000094\n       000038            00              A    0    0     4\n  [ 8] .rel.eh_frame     REL             00000000       0003e0\n       000008            08                   10   7     4\n  [ 9] .shstrtab         STRTAB          00000000       0000cc\n       000057            00                   0    0     1\n  [10] .symtab           SYMTAB          00000000       000304\n       0000b0            10                   11   8     4\n  [11] .strtab           STRTAB          00000000       0003b4\n       00001a            00                   0    0     1\n```", "```\nryan@alchemy:~$ gcc evil.o -o evil\nryan@alchemy:~$ readelf -S evil\n```", "```\n  [Nr] Name              Type            Addr           Off\n       Size              ES              Flg  Lk  Inf   Al\n  [ 0]                   NULL            00000000       000000\n       000000            00                   0   0     0\n  [ 1] .interp           PROGBITS        08048154       000154\n       000013            00              A    0   0     1\n  [ 2] .note.ABI-tag     NOTE            08048168       000168\n       000020            00              A    0   0     4\n  [ 3] .note.gnu.build-i NOTE            08048188       000188\n       000024            00              A    0   0     4\n  [ 4] .gnu.hash         GNU_HASH        080481ac       0001ac\n       000020            04              A    5   0     4\n  [ 5] .dynsym           DYNSYM          080481cc       0001cc\n       000060            10              A    6   1     4\n  [ 6] .dynstr           STRTAB          0804822c       00022c\n       000052            00              A    0   0     1\n  [ 7] .gnu.version      VERSYM          0804827e       00027e\n       00000c            02              A    5   0     2\n  [ 8] .gnu.version_r    VERNEED         0804828c       00028c\n       000020            00              A    6   1     4\n  [ 9] .rel.dyn          REL             080482ac       0002ac\n       000008            08              A    5   0     4\n  [10] .rel.plt          REL             080482b4       0002b4\n       000020            08              A    5   12    4\n  [11] .init             PROGBITS        080482d4       0002d4\n       00002e            00              AX   0   0     4\n  [12] .plt              PROGBITS        08048310       000310\n       000050            04              AX   0   0     16\n  [13] .text             PROGBITS        08048360       000360\n       00019c            00              AX   0   0     16\n  [14] .fini             PROGBITS        080484fc       0004fc\n       00001a            00              AX   0   0     4\n  [15] .rodata           PROGBITS        08048518       000518\n       000008            00              A    0   0     4\n  [16] .eh_frame_hdr     PROGBITS        08048520       000520\n       000034            00              A    0   0     4\n  [17] .eh_frame         PROGBITS        08048554       000554\n       0000c4            00              A    0   0     4\n  [18] .ctors            PROGBITS        08049f14       000f14\n       000008            00              WA   0   0     4\n  [19] .dtors            PROGBITS        08049f1c       000f1c\n       000008            00              WA   0   0     4\n  [20] .jcr              PROGBITS        08049f24       000f24\n       000004            00              WA   0   0     4\n  [21] .dynamic          DYNAMIC         08049f28       000f28\n       0000c8            08              WA   6   0     4\n  [22] .got              PROGBITS        08049ff0       000ff0\n       000004            04              WA   0   0     4\n  [23] .got.plt          PROGBITS        08049ff4       000ff4\n       00001c            04              WA   0   0     4\n  [24] .data             PROGBITS        0804a010       001010\n       000008            00              WA   0   0     4\n  [25] .bss              NOBITS          0804a018       001018\n       000008            00              WA   0   0     4\n  [26] .comment          PROGBITS        00000000       001018\n       00002a            01              MS   0   0     1\n  [27] .shstrtab         STRTAB          00000000       001042\n       0000fc            00                   0   0     1\n  [28] .symtab           SYMTAB          00000000       0015f0\n       000420            10                   29  45    4\n  [29] .strtab           STRTAB          00000000       001a10\n       00020d            00                   0   0\n```", "```\ntypedef struct {\nuint32_t      st_name;\n    unsigned char st_info;\n    unsigned char st_other;\n    uint16_t      st_shndx;\n    Elf64_Addr    st_value;\n    Uint64_t      st_size;\n} Elf64_Sym;\n```", "```\nstatic inline void foochu()\n{ /* Do nothing */ }\n\nvoid func1()\n{ /* Do nothing */ }\n\n_start()\n{\n        func1();\n        foochu();\n}\n```", "```\nryan@alchemy:~$ readelf -s test | egrep 'foochu|func1'\n     7: 080480d8     5 FUNC    LOCAL  DEFAULT    2 foochu\n     8: 080480dd     5 FUNC    GLOBAL DEFAULT    2 func1\n```", "```\n#include <stdio.h>\n\nint func1(int a, int b, int c)\n{\n  printf(\"%d %d %d\\n\", a, b ,c);\n}\n\nint main(void)\n{\n  func1(1, 2, 3);\n}\n```", "```\nftrace [-p <pid>] [-Sstve] <prog>\n```", "```\nryan@alchemy:~$ ftrace -s test\n[+] Function tracing begins here:\nPLT_call@0x400420:__libc_start_main()\nLOCAL_call@0x4003e0:_init()\n(RETURN VALUE) LOCAL_call@0x4003e0: _init() = 0\nLOCAL_call@0x40052c:func1(0x1,0x2,0x3)  // notice values passed\nPLT_call@0x400410:printf(\"%d %d %d\\n\")  // notice we see string value\n1 2 3\n(RETURN VALUE) PLT_call@0x400410: printf(\"%d %d %d\\n\") = 6\n(RETURN VALUE) LOCAL_call@0x40052c: func1(0x1,0x2,0x3) = 6\nLOCAL_call@0x400470:deregister_tm_clones()\n(RETURN VALUE) LOCAL_call@0x400470: deregister_tm_clones() = 7\n```", "```\nint foo(void) {\n}\n\n_start()\n{\n  foo();\n  __asm__(\"leave\");\n}\n```", "```\ngcc -nostdlib test2.c -o test2\n```", "```\nryan@alchemy:~$ ftrace ./test2\n[+] Function tracing begins here:\nLOCAL_call@0x400144:foo()\n(RETURN VALUE) LOCAL_call@0x400144: foo() = 0\nNow let's strip the symbol table and run ftrace on it again:\nryan@alchemy:~$ strip test2\nryan@alchemy:~$ ftrace -S test2\n[+] Function tracing begins here:\nLOCAL_call@0x400144:sub_400144()\n(RETURN VALUE) LOCAL_call@0x400144: sub_400144() = 0\n```", "```\nryan@alchemy:~$ objdump -d test2\ntest2:     file format elf64-x86-64\nDisassembly of section .text:\n0000000000400144<foo>:\n  400144:   55                      push   %rbp\n  400145:   48 89 e5                mov    %rsp,%rbp\n  400148:   5d                      pop    %rbp\n  400149:   c3                      retq   \n\n000000000040014a <_start>:\n  40014a:   55                      push   %rbp\n  40014b:   48 89 e5                mov    %rsp,%rbp\n  40014e:   e8 f1 ff ff ff          callq  400144 <foo>\n  400153:   c9                      leaveq\n  400154:   5d                      pop    %rbp\n  400155:   c3                 retq\n```", "```\n$ objdump -d test2\ntest2:     file format elf64-x86-64\nDisassembly of section .text:\n0000000000400144 <.text>:\n  400144:   55                      push   %rbp  \n  400145:   48 89 e5                mov    %rsp,%rbp\n  400148:   5d                      pop    %rbp\n  400149:   c3                      retq   \n  40014a:   55                      push   %rbp \n  40014b:   48 89 e5                mov    %rsp,%rbp\n  40014e:   e8 f1 ff ff ff          callq  0x400144\n  400153:   c9                      leaveq\n  400154:   5d                      pop    %rbp\n  400155:   c3                      retq   \n```", "```\ntypedef struct {\n        Elf64_Addr r_offset;\n        Uint64_t   r_info;\n} Elf64_Rel;\n```", "```\ntypedef struct {\n        Elf64_Addr r_offset;\n        uint64_t   r_info;\n        int64_t    r_addend;\n} Elf64_Rela;\n```", "```\n_start()\n{\n   foo();\n}\n```", "```\n$ objdump -d obj1.o\nobj1.o:     file format elf32-i386\nDisassembly of section .text:\n00000000 <func>:\n   0:   55                      push   %ebp\n   1:   89 e5                   mov    %esp,%ebp\n   3:   83 ec 08                sub    $0x8,%esp\n   6:   e8 fc ff ff ff          call 7 <func+0x7>\n   b:   c9                      leave  \n   c:   c3                      ret   \n```", "```\n$ readelf -r obj1.o\n\nRelocation section '.rel.text' at offset 0x394 contains 1 entries:\n Offset     Info    Type            Sym.Value  Sym. Name\n00000007  00000902 R_386_PC32        00000000   foo\n```", "```\n$ gcc -nostdlib obj1.o obj2.o -o relocated\n$ objdump -d relocated\n\ntest:     file format elf32-i386\n\nDisassembly of section .text:\n\n080480d8 <func>:\n 80480d8:   55                      push   %ebp\n 80480d9:   89 e5                   mov    %esp,%ebp\n 80480db:   83 ec 08                sub    $0x8,%esp\n 80480de:   e8 05 00 00 00          call   80480e8 <foo>\n 80480e3:   c9                      leave  \n 80480e4:   c3                      ret    \n 80480e5:   90                      nop\n 80480e6:   90                      nop\n 80480e7:   90                      nop\n\n080480e8 <foo>:\n 80480e8:   55                      push   %ebp\n 80480e9:   89 e5                   mov    %esp,%ebp\n 80480eb:   5d                      pop    %ebp\n 80480ec:   c3                      ret\n```", "```\nS + A \u2013 P: 0x80480e8 + 0xfffffffc \u2013 0x80480df = 5\n```", "```\n0x80480e8 + (0x80480df + sizeof(uint32_t))\n```", "```\naddress_of_call + offset + 5 (Where 5 is the length of the call instruction)\n```", "```\naddress \u2013 address_of_call \u2013 4 (Where 4 is the length of the immediate operand to the call instruction, which is 32bits).\n```", "```\n#include <sys/syscall.h>\nint _write (int fd, void *buf, int count)\n{\n  long ret;\n\n  __asm__ __volatile__ (\"pushl %%ebx\\n\\t\"\n\"movl %%esi,%%ebx\\n\\t\"\n\"int $0x80\\n\\t\"\"popl %%ebx\":\"=a\" (ret)\n                        :\"0\" (SYS_write), \"S\" ((long) fd),\n\"c\" ((long) buf), \"d\" ((long) count));\n  if (ret >= 0) {\n    return (int) ret;\n  }\n  return -1;\n}\nint evil_puts(void)\n{\n        _write(1, \"HAHA puts() has been hijacked!\\n\", 31);\n}\n```", "```\n$ ./hello_world\nHello World\n```", "```\nputs(\"Hello World\\n\");\n```", "```\n[Quenya v0.1@alchemy] reloc evil_puts.o hello_world\n0x08048624  addr: 0x8048612\n0x080485c4 _write addr: 0x804861e\n0x080485c4  addr: 0x804868f\n0x080485c4  addr: 0x80486b7\nInjection/Relocation succeeded\n```", "```\n[Quenya v0.1@alchemy] hijack binary hello_world evil_puts puts\nAttempting to hijack function: puts\nModifying GOT entry for puts\nSuccessfully hijacked function: puts\nCommitting changes into executable file\n[Quenya v0.1@alchemy] quit\n```", "```\nryan@alchemy:~/quenya$ ./hello_world\nHAHA puts() has been hijacked!\n```", "```\nswitch(obj.shdr[i].sh_type)\n{\ncase SHT_REL: /* Section contains ElfN_Rel records */\nrel = (Elf32_Rel *)(obj.mem + obj.shdr[i].sh_offset);\nfor (j = 0; j < obj.shdr[i].sh_size / sizeof(Elf32_Rel); j++, rel++)\n{\n/* symbol table */ \nsymtab = (Elf32_Sym *)obj.section[obj.shdr[i].sh_link]; \n\n/* symbol we are applying relocation to */\nsymbol = &symtab[ELF32_R_SYM(rel->r_info)];\n\n/* section to modify */\nTargetSection = &obj.shdr[obj.shdr[i].sh_info];\nTargetIndex = obj.shdr[i].sh_info;\n\n/* target location */\nTargetAddr = TargetSection->sh_addr + rel->r_offset;\n\n/* pointer to relocation target */\nRelocPtr = (Elf32_Addr *)(obj.section[TargetIndex] + rel->r_offset);\n\n/* relocation value */\nRelVal = symbol->st_value; \nRelVal += obj.shdr[symbol->st_shndx].sh_addr;\n\nprintf(\"0x%08x %s addr: 0x%x\\n\",RelVal, &SymStringTable[symbol->st_name], TargetAddr);\n\nswitch (ELF32_R_TYPE(rel->r_info)) \n{\n/* R_386_PC32      2    word32  S + A - P */ \ncase R_386_PC32:\n*RelocPtr += RelVal;\n*RelocPtr -= TargetAddr;\nbreak;\n\n/* R_386_32        1    word32  S + A */\ncase R_386_32:\n*RelocPtr += RelVal;\n     break;\n } \n}\n```", "```\ntypedef struct\n{\n  uint64_t a_type;              /* Entry type */\n  union\n    {\n      uint64_t a_val;           /* Integer value */\n    } a_un;\n} Elf64_auxv_t;\n```", "```\n#define AT_EXECFD       2       /* File descriptor of program */\n#define AT_PHDR         3       /* Program headers for program */\n#define AT_PHENT        4       /* Size of program header entry */\n#define AT_PHNUM        5       /* Number of program headers */\n#define AT_PAGESZ       6       /* System page size */\n#define AT_ENTRY        9       /* Entry point of program */\n#define AT_UID          11      /* Real uid */\n```", "```\nNEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE);\nNEW_AUX_ENT(AT_PHDR, load_addr + exec->e_phoff);\nNEW_AUX_ENT(AT_PHENT, sizeof(struct elf_phdr));\nNEW_AUX_ENT(AT_PHNUM, exec->e_phnum);\nNEW_AUX_ENT(AT_BASE, interp_load_addr);\nNEW_AUX_ENT(AT_ENTRY, exec->e_entry);\n```", "```\nobjdump -d test\n ...\n 8048481:       e8 da fe ff ff          call   8048360<fgets@plt>\n ...\n```", "```\nobjdump -d test (grep for 8048360)\n...\n08048360<fgets@plt>:                    /* A jmp into the GOT */\n 8048360:       ff 25 00 a0 04 08       jmp    *0x804a000\n 8048366:       68 00 00 00 00          push   $0x0\n 804836b:       e9 e0 ff ff ff          jmp    8048350 <_init+0x34>\n...\n```", "```\n$ readelf -r test\nOffset   Info      Type           SymValue    SymName\n...\n0804a000  00000107 R_386_JUMP_SLOT   00000000   fgets\n...\n```", "```\n08049ff4 <_GLOBAL_OFFSET_TABLE_>:\n 8049ff4:       28 9f 04 08 00 00       sub    %bl,0x804(%edi)\n 8049ffa:       00 00                   add    %al,(%eax)\n 8049ffc:       00 00                   add    %al,(%eax)\n 8049ffe:       00 00                   add    %al,(%eax)\n 804a000:       66 83 04 08 76          addw   $0x76,(%eax,%ecx,1)\n 804a005:       83 04 08 86             addl   $0xffffff86,(%eax,%ecx,1)\n 804a009:       83 04 08 96             addl   $0xffffff96,(%eax,%ecx,1)\n 804a00d:       83                      .byte 0x83\n 804a00e:       04 08                   add    $0x8,%al\n```", "```\n08048360 <fgets@plt>:\n 8048360:       ff 25 00 a0 04 08       jmp    *0x804a000\n 8048366:       68 00 00 00 00          push   $0x0\n 804836b:       e9 e0 ff ff ff          jmp    8048350 <_init+0x34>\n```", "```\n 8048350:       ff 35 f8 9f 04 08       pushl  0x8049ff8\n 8048356:       ff 25 fc 9f 04 08       jmp    *0x8049ffc\n 804835c:       00 00                   add    %al,(%eax)\n```", "```\ntypedef struct {\n    Elf32_Sword    d_tag;\n    union {\n      Elf32_Word d_val;\n      Elf32_Addr d_ptr;\n    } d_un;\n} Elf32_Dyn;\n```", "```\nstruct link_map\n  {\n    ElfW(Addr) l_addr; /* Base address shared object is loaded at.  */\n    char *l_name;      /* Absolute file name object was found in.  */\n    ElfW(Dyn) *l_ld;   /* Dynamic section of the shared object.  */\n    struct link_map *l_next, *l_prev; /* Chain of loaded objects.  */\n  };\n```", "```\n/* elfparse.c \u2013 gcc elfparse.c -o elfparse */\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <elf.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <stdint.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint main(int argc, char **argv)\n{\n   int fd, i;\n   uint8_t *mem;\n   struct stat st;\n   char *StringTable, *interp;\n\n   Elf32_Ehdr *ehdr;\n   Elf32_Phdr *phdr;\n   Elf32_Shdr *shdr;\n\n   if (argc < 2) {\n      printf(\"Usage: %s <executable>\\n\", argv[0]);\n      exit(0);\n   }\n\n   if ((fd = open(argv[1], O_RDONLY)) < 0) {\n      perror(\"open\");\n      exit(-1);\n   }\n\n   if (fstat(fd, &st) < 0) {\n      perror(\"fstat\");\n      exit(-1);\n   }\n\n   /* Map the executable into memory */\n   mem = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n   if (mem == MAP_FAILED) {\n      perror(\"mmap\");\n      exit(-1);\n   }\n\n   /*\n    * The initial ELF Header starts at offset 0\n    * of our mapped memory.\n    */\n   ehdr = (Elf32_Ehdr *)mem;\n\n   /*\n    * The shdr table and phdr table offsets are\n    * given by e_shoff and e_phoff members of the\n    * Elf32_Ehdr.\n    */\n   phdr = (Elf32_Phdr *)&mem[ehdr->e_phoff];\n   shdr = (Elf32_Shdr *)&mem[ehdr->e_shoff];\n\n   /*\n    * Check to see if the ELF magic (The first 4 bytes)\n    * match up as 0x7f E L F\n    */\n   if (mem[0] != 0x7f && strcmp(&mem[1], \"ELF\")) {\n      fprintf(stderr, \"%s is not an ELF file\\n\", argv[1]);\n      exit(-1);\n   }\n\n   /* We are only parsing executables with this code.\n    * so ET_EXEC marks an executable.\n    */\n   if (ehdr->e_type != ET_EXEC) {\n      fprintf(stderr, \"%s is not an executable\\n\", argv[1]);\n      exit(-1);\n   }\n\n   printf(\"Program Entry point: 0x%x\\n\", ehdr->e_entry);\n\n   /*\n    * We find the string table for the section header\n    * names with e_shstrndx which gives the index of\n    * which section holds the string table.\n    */\n   StringTable = &mem[shdr[ehdr->e_shstrndx].sh_offset];\n\n   /*\n    * Print each section header name and address.\n    * Notice we get the index into the string table\n    * that contains each section header name with\n    * the shdr.sh_name member.\n    */\n   printf(\"Section header list:\\n\\n\");\n   for (i = 1; i < ehdr->e_shnum; i++)\n      printf(\"%s: 0x%x\\n\", &StringTable[shdr[i].sh_name], shdr[i].sh_addr);\n\n   /*\n    * Print out each segment name, and address.\n    * Except for PT_INTERP we print the path to\n    * the dynamic linker (Interpreter).\n    */\n   printf(\"\\nProgram header list\\n\\n\");\n   for (i = 0; i < ehdr->e_phnum; i++) {   \n      switch(phdr[i].p_type) {\n         case PT_LOAD:\n            /*\n             * We know that text segment starts\n             * at offset 0\\. And only one other\n             * possible loadable segment exists\n             * which is the data segment.\n             */\n            if (phdr[i].p_offset == 0)\n               printf(\"Text segment: 0x%x\\n\", phdr[i].p_vaddr);\n            else\n               printf(\"Data segment: 0x%x\\n\", phdr[i].p_vaddr);\n         break;\n         case PT_INTERP:\n            interp = strdup((char *)&mem[phdr[i].p_offset]);\n            printf(\"Interpreter: %s\\n\", interp);\n            break;\n         case PT_NOTE:\n            printf(\"Note segment: 0x%x\\n\", phdr[i].p_vaddr);\n            break;\n         case PT_DYNAMIC:\n            printf(\"Dynamic segment: 0x%x\\n\", phdr[i].p_vaddr);\n            break;\n         case PT_PHDR:\n            printf(\"Phdr segment: 0x%x\\n\", phdr[i].p_vaddr);\n            break;\n      }\n   }\n\n   exit(0);\n}\n```"]