["```\nphy_offset = 0x0;\nsrc = phy_offset + (300*1024);       /* = 0x0004 b000 */\ndest = phy_offset + (400*1024);      /* = 0x0006 4000 */\nn = 1024;\nmemcpy(dest, src, n);\n```", "```\nphy_offset = 0x0;\nsrc = phy_offset + (300*1024);       /* = 0x0004 b000 */\ndest = phy_offset + (400*1024*156);  /* = 0x03cf 0000 *!*BUG*!* */\nn = 1024;\nmemcpy(dest, src, n);\n```", "```\nP1:va1 \u2192 P1:pa1\nP1:va2 \u2192 P1:pa2\n...\n\nP2:va1 \u2192 P2:pa1\nP2:va2 \u2192 P2:pa2\n...\n\n[...]\n\nPn:va1 \u2192 Pn:pa1\nPn:va2 \u2192 Pn:pa2\n...\n```", "```\npa = (pf * PAGE_SIZE) + offset\n   = (5 * 4096) + 1000\n   = 21480 = 0x000053E8\n```", "```\n$ cat mem_app1buggy.c /*\n * mem_app1buggy.c\n *\n ***************************************************************\n * This program is part of the source code released for the book\n *  \"Linux System Programming\"\n *  (c) Kaiwan N Billimoria\n *  Packt Publishers\n *\n * From:\n *  Ch 2 : Virtual Memory\n ****************************************************************\n * A simple demo to show that on Linux - full-fledged Virtual \n * Memory enabled OS - even a buggy app will _NOT_ cause system\n * failure; rather, the buggy process will be killed by the \n * kernel!\n * On the other hand, if we had run this or a similar program in a flat purely \n * physical address space based OS, this seemingly trivial bug \n * can wreak havoc, bringing the entire system down.\n */\n#define _GNU_SOURCE\n#include <stdio.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"../common.h\"\n\nint main(int argc, char **argv)\n{\n    void *ptr = NULL;\n    void *dest, *src = \"abcdef0123456789\";\n    void *arbit_addr = (void *)0xffffffffff601000;\n    int n = strlen(src);\n\n    ptr = malloc(256 * 1024);\n    if (!ptr)\n          FATAL(\"malloc(256*1024) failed\\n\");\n\n    if (argc == 1)\n        dest = ptr;           /* correct */\n    else\n        dest = arbit_addr;    /* bug! */\n    memcpy(dest, src, n);\n\n    free(ptr);\n    exit(0);\n}\n```", "```\nvoid *memcpy(void *dest, const void *src, size_t n);\n```", "```\n$ ./mem_app1buggy\n$ \n```", "```\n$ ./mem_app1buggy buggy-case pass-params forcing-argc-to-not-be-1\nSegmentation fault (core dumped)\n$ \n```", "```\nbar() { jail();}\nfoo() { bar();}\nmain() { foo();}\n```", "```\n$ gstack 14654\n#0  0x00007f3539ece7ea in waitpid () from /lib64/libc.so.6\n#1  0x000056474b4b41d9 in waitchld.isra ()\n#2  0x000056474b4b595d in wait_for ()\n#3  0x000056474b4a5033 in execute_command_internal ()\n#4  0x000056474b4a52c2 in execute_command ()\n#5  0x000056474b48f252 in reader_loop ()\n#6  0x000056474b48dd32 in main ()\n$ \n```", "```\nmain() --> foo() --> bar() --> bar_is_now_closed() --> pause()\n```", "```\nstatic void bar_is_now_closed(void)\n{\n     printf(\"In function %s\\n\"\n     \"\\t(bye, pl go '~/' now).\\n\", __FUNCTION__);\n     printf(\"\\n Now blocking on pause()...\\n\"\n         \" Connect via GDB's 'attach' and then issue the 'bt' command\"\n         \" to view the process stack\\n\");\n     pause(); /*process blocks here until it receives a signal */\n}\nstatic void bar(void)\n{\n     printf(\"In function %s\\n\", __FUNCTION__);\n     bar_is_now_closed();\n}\nstatic void foo(void)\n{\n     printf(\"In function %s\\n\", __FUNCTION__);\n     bar();\n}\nint main(int argc, char **argv)\n{\n     printf(\"In function %s\\n\", __FUNCTION__);\n     foo();\n     exit (EXIT_SUCCESS);\n}\n```", "```\n$ ./stacker_dbg &\n[2] 28957\nIn function main\nIn function foo\nIn function bar\nIn function bar_is_now_closed\n (bye, pl go '~/' now).\n Now blocking on pause()...\n Connect via GDB's 'attach' and then issue the 'bt' command to view the process stack\n$ \n```", "```\n$ gdb --quiet\n(gdb) attach 28957 *# parameter to 'attach' is the PID of the process to attach to*\nAttaching to process 28957\nReading symbols from <...>/Hands-on-System-Programming-with-Linux/ch2/stacker_dbg...done.\nReading symbols from /lib64/libc.so.6...Reading symbols from /usr/lib/debug/usr/lib64/libc-2.26.so.debug...done.\ndone.\nReading symbols from /lib64/ld-linux-x86-64.so.2...Reading symbols from /usr/lib/debug/usr/lib64/ld-2.26.so.debug...done.\ndone.\n0x00007fce204143b1 in __libc_pause () at ../sysdeps/unix/sysv/linux/pause.c:30\n30 return SYSCALL_CANCEL (pause);\n(gdb) bt\n#0 0x00007fce204143b1 in __libc_pause () at ../sysdeps/unix/sysv/linux/pause.c:30\n#1 0x00000000004007ce in bar_is_now_closed () at stacker.c:31\n#2 0x00000000004007ee in bar () at stacker.c:36\n#3 0x000000000040080e in foo () at stacker.c:41\n#4 0x0000000000400839 in main (argc=1, argv=0x7ffca9ac5ff8) at stacker.c:47\n(gdb) \n```", "```\n$ gstack 28957\n#0 0x00007fce204143b1 in __libc_pause () at ../sysdeps/unix/sysv/linux/pause.c:30\n#1 0x00000000004007ce in bar_is_now_closed () at stacker.c:31\n#2 0x00000000004007ee in bar () at stacker.c:36\n#3 0x000000000040080e in foo () at stacker.c:41\n#4 0x0000000000400839 in main (argc=1, argv=0x7ffca9ac5ff8) at stacker.c:47\n$ \n```"]