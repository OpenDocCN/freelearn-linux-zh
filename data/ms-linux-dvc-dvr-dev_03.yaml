- en: '*Chapter 2*: Leveraging the Regmap API and Simplifying the Code'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：利用Regmap API并简化代码'
- en: This chapter introduces the Linux kernel register mapping abstraction layer
    and shows how to simplify and delegate I/O operations to the regmap subsystem.
    Dealing with devices, whether they are built-in in the SoC (**memory mapped I/O**,
    also known as **MMIO**) or seated on I2C/SPI buses, consists of accessing (reading/modifying/updating)
    registers. Regmap became necessary because a lot of device drivers open-coded
    their register access routines. **Regmap** stands for **Register Map**. It was
    primarily developed for **ALSA SoC** (**ASoC**) in order to get rid of redundant
    open-coded SPI/I2C register access routines in codec drivers. At its origin, regmap
    provided a set of APIs for reading/writing non-memory-map I/O (for example, I2C
    and SPI read/write). Since then, MMIO regmap has been upgraded so that we can
    use regmap to access MMIO.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Linux内核寄存器映射抽象层，并展示了如何简化和委托I/O操作给regmap子系统。处理设备，无论是在SoC中内置的（也称为MMIO）还是位于I2C/SPI总线上，都包括访问（读取/修改/更新）寄存器。Regmap是必需的，因为许多设备驱动程序在其寄存器访问例程中使用了开放编码。**Regmap**代表**寄存器映射**。它最初是为了**ALSA
    SoC**（**ASoC**）而开发的，以消除编解码器驱动程序中多余的开放编码SPI/I2C寄存器访问例程。最初，regmap提供了一组用于读取/写入非内存映射I/O（例如，I2C和SPI读/写）的API。从那时起，MMIO
    regmap已经升级，以便我们可以使用regmap来访问MMIO。
- en: Nowadays, this framework abstracts I2C, SPI, and MMIO register access, and not
    only handles locking when necessary, but also manages the register cache, as well
    as register readability and writability. It also handles IRQ chips and IRQs. This
    chapter will discuss regmap and explain the way to use it to abstract register
    access with I2C, SPI, and MMIO devices. We will also describe how to use regmap
    to manage IRQ and IRQ controllers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，该框架抽象了I2C，SPI和MMIO寄存器访问，不仅在必要时处理锁定，还管理寄存器缓存，以及寄存器的可读性和可写性。它还处理IRQ芯片和IRQ。本章将讨论regmap，并解释如何使用它来抽象I2C，SPI和MMIO设备的寄存器访问。我们还将描述如何使用regmap来管理IRQ和IRQ控制器。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: 'Introduction to regmap and its data structures: I2C, SPI, and MMIO'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Regmap和其数据结构的介绍：I2C，SPI和MMIO
- en: Regmap and IRQ management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Regmap和IRQ管理
- en: Regmap IRQ API and data structures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Regmap IRQ API和数据结构
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to be comfortable when going through this chapter, you’ll need the
    following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在阅读本章时感到舒适，您需要以下内容：
- en: Good C programming skills
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好的C编程技能
- en: Familiarity with the concept of the device tree
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉设备树的概念
- en: Linux kernel v4.19.X sources, available at [https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核v4.19.X源代码，可在[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)上获得
- en: Introduction to regmap and its data structures – I2C, SPI, and MMIO
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Regmap和其数据结构的介绍- I2C，SPI和MMIO
- en: Regmap is an abstraction register access mechanism provided by the Linux kernel
    that mainly targets SPI, I2C, and memory-mapped registers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Regmap是Linux内核提供的抽象寄存器访问机制，主要针对SPI，I2C和内存映射寄存器。
- en: 'APIs in this framework are bus agnostic and handle the underlying configuration
    under the hood. That being said, the main data structure in this framework is
    `struct regmap_config`, defined in `include/linux/regmap.h` in the kernel source
    tree as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此框架中的API是总线不可知的，并在幕后处理底层配置。也就是说，该框架中的主要数据结构是`struct regmap_config`，在内核源代码树中的`include/linux/regmap.h`中定义如下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For simplicity, some of the fields in this structure have been removed and
    are not discussed in this chapter. As long as `struct regmap_config` is properly
    completed, users may ignore underlying bus mechanisms. Let’s introduce the fields
    in this data structure:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，本结构中的一些字段已被删除，在本章中不讨论。只要`struct regmap_config`正确完成，用户可以忽略底层总线机制。让我们介绍这个数据结构中的字段：
- en: '`reg_bits` indicates the size of a register in terms of bits. In other words,
    it is the number of bits in a register’s address.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg_bits`表示寄存器的位数。换句话说，它是寄存器地址的位数。'
- en: '`reg_stride` is the stride of the register address. A register address is valid
    if it is a multiple of this value. If set to `0`, a value of `1` will be used,
    meaning any address is valid. Any read/write to an address that is not a multiple
    of this value will return `-EINVAL`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg_stride`是寄存器地址的步幅。如果寄存器地址是该值的倍数，则为有效。如果设置为`0`，则将使用`1`的值，这意味着任何地址都是有效的。对不是该值的倍数的地址进行读/写将返回`-EINVAL`。'
- en: '`pad_bits` is the number of bits of padding between the register and the value.
    This is the number of bits to shift the register’s value left when formatting.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pad_bits`是寄存器和值之间填充位的数量。这是在格式化时将寄存器的值左移的位数。'
- en: '`val_bits`: This represents the number of bits used to store a register’s value.
    It is a mandatory field.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`val_bits`：表示用于存储寄存器值的位数。这是一个强制性字段。'
- en: '`writeable_reg`: If provided, this optional callback will be called on each
    regmap write operation to check whether the given address is writable or not.
    If this function returns `false` on an address given to a regmap write transaction,
    the transaction will return `-EIO`. The following excerpt shows how this callback
    can be implemented:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writeable_reg`：如果提供，将在每次regmap写操作时调用此可选回调函数，以检查给定地址是否可写。如果此函数在给定给regmap写事务的地址上返回`false`，则事务将返回`-EIO`。以下摘录显示了如何实现此回调：'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`readable_reg`: This is the same as `writeable_reg` but for register read operations.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readable_reg`：这与`writeable_reg`相同，但用于寄存器读取操作。'
- en: '`volatile_reg`: This is an optional callback that, if provided, will be called
    every time a register needs to be read or written through the regmap cache. If
    the register is volatile (the register value can’t be cached), the function should
    return `true`. A direct read/write is then performed on the register. If `false`
    is returned, it means the register is cacheable. In this case, the cache will
    be used for a read operation, and the cache will be written to in the case of
    a write operation. The following is an example, with fake register addresses chosen
    randomly:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volatile_reg`: 这是一个可选的回调，如果提供，将在每次需要通过regmap缓存读取或写入寄存器时调用。如果寄存器是易失性的（寄存器值无法被缓存），则该函数应返回`true`。然后在寄存器上执行直接读/写操作。如果返回`false`，表示寄存器是可缓存的。在这种情况下，将使用缓存进行读取操作，并在写入操作的情况下将写入缓存。以下是一个示例，其中随机选择了虚假寄存器地址：'
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`reg_read`: If your device needs *special hacks* for reading operations, you
    can provide a custom read callback and make this field point to it so that instead
    of using standard regmap read functions, this callback is used. That said, most
    devices do not need this.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg_read`: 如果您的设备需要*特殊的黑客*来进行读取操作，您可以提供自定义的读取回调，并使该字段指向它，以便使用回调而不是标准的regmap读取函数。也就是说，大多数设备不需要这样做。'
- en: '`reg_write`: This is the same as `reg_read` but for write operations.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg_write`: 这与`reg_read`相同，但用于写操作。'
- en: '`disable_locking`: This shows whether the `lock`/`unlock` callbacks should
    be used or not. If `false`, no locking mechanisms will be used. It means this
    regmap is either protected by external means or is guaranteed not to be accessed
    from multiple threads.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disable_locking`: 这显示了是否应该使用`lock`/`unlock`回调。如果为`false`，将不使用任何锁定机制。这意味着此regmap要么受到外部手段的保护，要么保证不会从多个线程访问。'
- en: '`lock`/`unlock`: These are optional lock/unlock callbacks that override the
    regmap’s default lock/unlock functions. These are based on spinlock or mutex,
    depending on whether accessing the underlying device may sleep or not.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock`/`unlock`: 这些是可选的锁定/解锁回调，它们会覆盖regmap的默认锁定/解锁函数。这些基于自旋锁或互斥锁，具体取决于访问底层设备是否可能休眠。'
- en: '`lock_arg`: This is the only argument of the `lock`/`unlock` functions (it
    will be ignored if the regular lock/unlock functions are not overridden).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock_arg`: 这是`lock`/`unlock`函数的唯一参数（如果未覆盖常规的锁定/解锁函数，则将被忽略）。'
- en: '`fast_io`: This indicates that the register’s I/O is fast. If set, the regmap
    will use a spinlock instead of a mutex to perform locking. This field is ignored
    if custom lock/unlock (not discussed here) functions are used (see the `lock`/`unlock`
    fields of `struct regmap_config` in the kernel sources). It should be used only
    for "`no bus`" cases (MMIO devices), not for slow buses such as I2C, SPI, or similar
    buses whose accesses may sleep.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fast_io`: 这表示寄存器的I/O速度很快。如果设置了，regmap将使用自旋锁而不是互斥锁来执行锁定。如果使用自定义的锁定/解锁（这里没有讨论）函数（请参阅内核源代码中`struct
    regmap_config`的`lock`/`unlock`字段），则此字段将被忽略。它应该仅用于“无总线”情况（MMIO设备），而不是用于可能休眠的慢总线，如I2C、SPI或类似总线。'
- en: '`wr_table`: This is an alternative to the `writeable_reg()` callback, of type
    `regmap_access_table`, which is a structure holding a `yes_range` and a `no_range`
    field, both of which are pointers to `struct regmap_range`. Any register that
    belongs to a `yes_range` entry is considered writable, and is considered not writable
    if it belongs to `no_range` or is not specified in `yes_range`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wr_table`: 这是`writeable_reg()`回调的替代，类型为`regmap_access_table`，它是一个包含`yes_range`和`no_range`字段的结构，两者都是指向`struct
    regmap_range`的指针。属于`yes_range`条目的任何寄存器都被视为可写，如果属于`no_range`或未在`yes_range`中指定，则被视为不可写。'
- en: '`rd_table`: This is the same as `wr_table`, but for any read operation.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rd_table`: 这与`wr_table`相同，但用于任何读取操作。'
- en: '`volatile_table`: Instead of `volatile_reg`, you could provide `volatile_table`.
    The principle is the same as `wr_table` and `rd_table`, but for the caching mechanism.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volatile_table`: 您可以提供`volatile_table`而不是`volatile_reg`。其原理与`wr_table`和`rd_table`相同，但用于缓存机制。'
- en: '`max_register`: This is optional; it specifies the maximum valid register address
    upon which no operation is permitted.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_register`: 这是可选的；它指定了不允许任何操作的最大有效寄存器地址。'
- en: '`reg_defaults` is an array of elements of type `reg_default`, where each element
    is a `{reg, value}` pair that represents the power-on reset values for a given
    register. This is used along with the cache so that reading an address that exists
    in this array and that has not been written since a power-on reset will return
    the default register value in this array without performing any read transactions
    on the device. An example of this is the IIO device driver, which you can find
    out more about at [https://elixir.bootlin.com/linux/v4.19/source/drivers/iio/light/apds9960.c](https://elixir.bootlin.com/linux/v4.19/source/drivers/iio/light/apds9960.c).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg_defaults`是`reg_default`类型的元素数组，其中每个元素都是表示给定寄存器的上电复位值的`{reg, value}`对。这与缓存一起使用，以便读取存在于此数组中且自上电复位以来尚未写入的地址时，将返回此数组中的默认寄存器值，而无需对设备执行任何读取事务。这的一个示例是IIO设备驱动程序，您可以在[https://elixir.bootlin.com/linux/v4.19/source/drivers/iio/light/apds9960.c](https://elixir.bootlin.com/linux/v4.19/source/drivers/iio/light/apds9960.c)上了解更多信息。'
- en: '`use_single_rw`: This is a Boolean that, if set, will instruct the regmap to
    convert any bulk write or read operations on the device into a series of single
    write or read operations. This is useful for devices that do not support bulk
    read and/or write operations.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_single_rw`: 这是一个布尔值，如果设置，将指示regmap将设备上的任何批量写或读操作转换为一系列单个写或读操作。这对于不支持批量读取和/或写入操作的设备非常有用。'
- en: '`can_multi_write`: This only targets write operations. If set, it indicates
    that this device supports the multi-write mode of bulk write operations. If it’s
    empty, multi-write requests will be split into individual write operations.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`can_multi_write`: 这仅针对写操作。如果设置，表示此设备支持批量写操作的多写模式。如果为空，多写请求将被拆分为单独的写操作。'
- en: '`num_reg_defaults`: This is the number of elements in `reg_defaults`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_reg_defaults`: 这是`reg_defaults`中元素的数量。'
- en: '`read_flag_mask`: This is a mask to be set in the highest bytes of the register
    when doing a read. Normally, in SPI or I2C, a write or a read will have the highest
    bit set in the top byte to differentiate write and read operations.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read_flag_mask`：这是在进行读取时要设置在寄存器的最高字节中的掩码。 通常，在SPI或I2C中，写入或读取将在顶部字节中设置最高位，以区分写入和读取操作。'
- en: '`write_flag_mask`: This is a mask to be set in the highest bytes of the register
    when doing a write.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write_flag_mask`：这是在进行写入时要设置在寄存器的最高字节中的掩码。'
- en: '`cache_type`: This is the actual cache type, which can be either `REGCACHE_NONE`,
    `REGCACHE_RBTREE`, `REGCACHE_COMPRESSED`, or `REGCACHE_FLAT`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cache_type`：这是实际的缓存类型，可以是`REGCACHE_NONE`，`REGCACHE_RBTREE`，`REGCACHE_COMPRESSED`或`REGCACHE_FLAT`。'
- en: 'Initializing a regmap is as simple as calling one of the following functions
    depending on the bus behind which our device sits:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化regmap就像调用以下函数之一一样简单，具体取决于我们的设备所在的总线：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding prototypes, the return value will be a valid pointer to `struct
    regmap` or `ERR_PTR()` if there is an error. The regmap will be automatically
    freed by the device management code. `regs` is a pointer to the memory-mapped
    IO region (returned by `devm_ioremap_resource()` or any `ioremap*` family function).
    `dev` is the device (of type `struct device`) that will be interacted with. The
    following example is an excerpt of `drivers/mfd/sun4i-gpadc.c` in the kernel source
    code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的原型中，返回值将是一个有效的指向`struct regmap`的指针，如果出现错误，则返回`ERR_PTR()`。 regmap将由设备管理代码自动释放。
    `regs`是指向内存映射IO区域的指针（由`devm_ioremap_resource()`或任何`ioremap*`系列函数返回）。 `dev`是将要交互的设备（类型为`struct
    device`）。 以下示例是内核源代码中`drivers/mfd/sun4i-gpadc.c`的摘录：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This excerpt shows how to create a regmap. Though this excerpt is MMIO-oriented,
    the concept remains the same for other types. Instead of using `devm_regmap_init_MMIO()`,
    we would use `devm_regmap_init_spi()` or `devm_regmap_init_i2c()` respectively
    for an SPI- or I2C-based regmap.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这段摘录显示了如何创建regmap。 尽管这段摘录是面向MMIO的，但对于其他类型，概念仍然相同。 而不是使用`devm_regmap_init_MMIO()`，我们将分别使用`devm_regmap_init_spi()`或`devm_regmap_init_i2c()`来创建基于SPI或I2C的regmap。
- en: Accessing device registers
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问设备寄存器
- en: 'There are two main functions for accessing device registers. These are `regmap_write()`
    and `regmap_read()`, which take care of locking and abstracting the underlying
    bus:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个主要函数用于访问设备寄存器。 这些是`regmap_write()`和`regmap_read()`，它们负责锁定和抽象底层总线：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding two functions, the first argument, `map`, is the regmap structure
    returned during initialization. `reg` is the register address to write/read data
    to/from. `val` is the data to be written in a write operation, or the read value
    in a read operation. The following is a detailed description of these APIs:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的两个函数中，第一个参数`map`是初始化期间返回的regmap结构。 `reg`是要写入/读取数据的寄存器地址。 `val`是写操作中要写入的数据，或读操作中的读取值。以下是这些API的详细描述：
- en: '`regmap_write` is used to write data to the device. The following are the steps
    performed by this function:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regmap_write`用于向设备写入数据。 此函数执行以下步骤：'
- en: 1) First, it checks whether `reg` is aligned with the `regmap_config.reg_stride`.
    If not, it returns `-EINVAL` and the function fails.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 1) 首先，它检查`reg`是否与`regmap_config.reg_stride`对齐。 如果不是，则返回`-EINVAL`，函数失败。
- en: '2) It then takes the lock depending on the `fast_io`, `lock`, and `unlock`
    fields. If a `lock` callback is provided, it will be used to take the lock. Otherwise,
    the regmap core will use its internal default lock function, using a spinlock
    or a mutex depending on whether `fast_io` has been set or not. Next, the regmap
    core performs some sanity checks on the register address passed as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 2) 然后，根据`fast_io`，`lock`和`unlock`字段获取锁。 如果提供了`lock`回调，则将使用它来获取锁。 否则，regmap核心将使用其内部默认的锁定函数，使用自旋锁或互斥锁，具体取决于是否设置了`fast_io`。
    接下来，regmap核心对传递的寄存器地址执行一些合理性检查，如下所示：
- en: --If `max_register` is set, it will check whether this register’s address is
    less than `max_register`. If the address is not less than `max_register`, then
    `regmap_write()` fails, returning an `-EIO` (invalid I/O) error code
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: -如果设置了`max_register`，它将检查此寄存器的地址是否小于`max_register`。 如果地址不小于`max_register`，则`regmap_write()`失败，返回`-EIO`（无效的I/O）错误代码
- en: --Then, if the `writeable_reg` callback is set, this callback is called with
    the register as a parameter. If this callback returns `false`, then `regmap_write()`
    fails, returning `-EIO`. If `writeable_reg` is not set but `wr_table` is set,
    the regmap core will check whether the register address lies within `no_range`.
    If it does, then `regmap_write()` fails and returns `-EIO`. If it doesn’t, the
    regmap core will check whether the register address lies in `yes_range`. If it
    is not present there, then `regmap_write()` fails and returns `-EIO`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: -然后，如果设置了`writeable_reg`回调，则将使用寄存器作为参数调用此回调。 如果此回调返回`false`，则`regmap_write()`失败，返回`-EIO`。
    如果未设置`writeable_reg`但设置了`wr_table`，则regmap核心将检查寄存器地址是否位于`no_range`内。 如果是，则`regmap_write()`失败并返回`-EIO`。
    如果不是，则regmap核心将检查寄存器地址是否位于`yes_range`内。 如果不在那里，则`regmap_write()`失败并返回`-EIO`。
- en: 3) If the `cache_type` field is set, then caching will be used. The value to
    be written will be cached for future reference instead of being written to the
    hardware.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 3) 如果设置了`cache_type`字段，则将使用缓存。 要写入的值将被缓存以供将来参考，而不是写入硬件。
- en: 4) If `cache_type` is not set, then the write routine is invoked immediately
    to write the value into the hardware register. This routine will first apply `write_flag_mask`
    to the first byte of the register address before writing the value into this register.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 4) 如果未设置`cache_type`，则立即调用写入例程将值写入硬件寄存器。 在将值写入此寄存器之前，此例程将首先将`write_flag_mask`应用于寄存器地址的第一个字节。
- en: 5) Finally, the lock is released using the appropriate unlocking function.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 5) 最后，使用适当的解锁函数释放锁。
- en: '`regmap_read` is used to read data from the device. This function performs
    the same security and sanity checks as `regmap_write()`, but replaces `writable_reg`
    and `wr_table` with `readable_reg` and `rd_table`. When it comes to caching, if
    it is enabled, the register value is read from the cache. If caching is not enabled,
    the read routine is called to read the value from the hardware register instead.
    That routine will apply `read_flag_mask` to the highest byte of the register address
    prior to the read operation, and `*val` is updated with the new value read. After
    this, the lock is released using the appropriate unlocking function.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regmap_read`用于从设备中读取数据。此函数执行与`regmap_write()`相同的安全性和健全性检查，但用`readable_reg`和`rd_table`替换了`writable_reg`和`wr_table`。在缓存方面，如果启用了缓存，则从缓存中读取寄存器值。如果未启用缓存，则调用读取例程从硬件寄存器中读取值。该例程将在读取操作之前将`read_flag_mask`应用于寄存器地址的最高字节，并使用新读取的值更新`*val`。之后，使用适当的解锁函数释放锁。'
- en: While the preceding accessors target a single register at a time, others can
    perform bulk accesses, as we will see in the next section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的访问器一次只针对一个寄存器，但其他访问器可以执行批量访问，我们将在下一节中看到。
- en: Reading/writing multiple registers in a single shot
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一次性读/写多个寄存器
- en: 'Sometimes you may want to perform bulk read/write operations of data from/to
    a register range at the same time. Even if you use `regmap_read()` or `regmap_write()`
    in a loop, the best solution would be to use the regmap APIs provided for such
    situations. These functions are `regmap_bulk_read()` and `regmap_bulk_write()`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能希望同时对寄存器范围中的数据执行批量读/写操作。即使您在循环中使用`regmap_read()`或`regmap_write()`，最好的解决方案也是使用为此类情况提供的regmap
    API。这些函数是`regmap_bulk_read()`和`regmap_bulk_write()`：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These functions read/write multiple registers from/to the device. `map` is the
    regmap used to perform operations. For a read operation, `reg` is the first register
    from where reading should start, `val` is a pointer to the buffer where read values
    should be stored in *native register size* of the device (it means if the device
    register size is 4 bytes, the read value will be stored in 4 bytes units), and
    `val_count` is the number of registers to read. For a write operation, `reg` is
    the first register to be written from, `val` is a pointer to the block of data
    to be written in *native register size* of the device, and `val_count` is the
    number of registers to write. For both of these functions, a value of `0` will
    be returned on success and a negative `errno` will be returned if there is an
    error.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数从/向设备读/写多个寄存器。`map`是用于执行操作的regmap。对于读操作，`reg`是应该开始读取的第一个寄存器，`val`是指向应该以*设备的本机寄存器大小*存储读取值的缓冲区的指针（这意味着如果设备寄存器大小为4字节，则读取值将以4字节单位存储），`val_count`是要读取的寄存器数量。对于写操作，`reg`是应该从中开始写入的第一个寄存器，`val`是指向应该以*设备的本机寄存器大小*写入的数据块的指针，`val_count`是要写入的寄存器数量。对于这两个函数，成功时将返回`0`的值，如果出现错误，则将返回负的`errno`。
- en: Tip
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: There are other interesting read/write functions provided by this framework.
    Take a look at the kernel header file for more information. An interesting one
    is `regmap_multi_reg_write()`, which writes multiple registers in a set of {register,
    value} pairs supplied in any order, possibly not all in a single range, to the
    device given as a parameter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此框架提供了其他有趣的读/写函数。查看内核头文件以获取更多信息。一个有趣的函数是`regmap_multi_reg_write()`，它以任何顺序提供的{寄存器，值}对集合写入多个寄存器，可能不都在单个范围内，给定为参数的设备。
- en: Now that we are familiar with register access, we can go further by managing
    register content at a bit level.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了寄存器访问，我们可以通过在位级别管理寄存器内容来进一步深入。
- en: Updating bits in registers
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新寄存器中的位
- en: 'To update a bit in a given register, we have `regmap_update_bits()`, a three-in-one
    function. Its prototype is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新给定寄存器中的位，我们有`regmap_update_bits()`，一个三合一的函数。其原型如下：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It performs a read/modify/write cycle on the register map. It is a wrapper
    of `_regmap_update_bits()`, which looks as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 它在寄存器映射上执行读/修改/写循环。它是`_regmap_update_bits()`的包装器，如下所示：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Bits that need to be updated should be set to `1` in `mask`, and the corresponding
    bits will be given the value of the bit of the same position in `val`. As an example,
    to set the first (`BIT(0)`) and third (`BIT(2)`) bits to `1`, `mask` should be
    `0b00000101` and the value should be `0bxxxxx1x1`. To clear the seventh bit (`BIT(6)`),
    `mask` must be `0b01000000` and the value should be `0bx0xxxxxx`, and so on.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更新的位应该在`mask`中设置为`1`，相应的位将获得`val`中相同位置的位的值。例如，要将第一个（`BIT(0)`）和第三个（`BIT(2)`）位设置为`1`，`mask`应该是`0b00000101`，值应该是`0bxxxxx1x1`。要清除第七位（`BIT(6)`），`mask`必须是`0b01000000`，值应该是`0bx0xxxxxx`，依此类推。
- en: Tip
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'For debugging purpose, you can use the `debugfs` filesystem to dump the content
    of the regmap managed registers, as the following excerpt shows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试目的，您可以使用`debugfs`文件系统来转储regmap管理的寄存器内容，如下摘录所示：
- en: mount -t debugfs none /sys/kernel/debug
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mount -t debugfs none /sys/kernel/debug
- en: cat /sys/kernel/debug/regmap/1-0008/registers
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cat /sys/kernel/debug/regmap/1-0008/registers
- en: This will dump the register addresses along with their values in `<addr:value>`
    format.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以`<addr:value>`格式转储寄存器地址及其值。
- en: In this section, we have seen how easy it is to access hardware registers. Moreover,
    we have learned some fancy tricks for playing with registers at the bit level,
    which is often used in status and configuration registers. Next, we will have
    a look at IRQ management.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经看到了访问硬件寄存器是多么容易。此外，我们已经学会了一些在位级别上玩耍寄存器的花哨技巧，这在状态和配置寄存器中经常使用。接下来，我们将看一下IRQ管理。
- en: Regmap and IRQ management
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Regmap和IRQ管理
- en: Regmap does not only abstract access to registers. Here, we will see how this
    framework abstracts IRQ management at a lower level, such as IRQ chip handling,
    thus hiding boilerplate operations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Regmap不仅仅是对寄存器的访问进行了抽象。在这里，我们将看到这个框架如何在更低的级别抽象IRQ管理，比如IRQ芯片处理，从而隐藏样板操作。
- en: Quick recap on Linux kernel IRQ management
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux内核IRQ管理的快速回顾
- en: 'IRQs are exposed to devices by means of special devices called interrupt controllers.
    From a software point of view, an interrupt controller device driver manages and
    exposes these lines using the virtual IRQ concept, known as the IRQ domain in
    the Linux kernel. Interrupt management is built on top of the following structures:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通过特殊设备称为中断控制器向设备公开IRQ。从软件角度来看，中断控制器设备驱动程序使用Linux内核中的IRQ域概念来管理和公开这些线。中断管理建立在以下结构之上：
- en: '`struct irq_chip`: This structure is the Linux representation of an IRQ controller
    and implements a set of methods to drive the interrupt controller that are directly
    called by the core IRQ code. If necessary, this structure should be filled by
    the driver, providing a set of callbacks allowing us to manage IRQs on the IRQ
    chip, such as `irq_startup`, `irq_shutdown`, `irq_enable`, `irq_disable`, `irq_ack`,
    `irq_mask`, `irq_unmask`, `irq_eoi`, and `irq_set_affinity`. Dumb IRQ chip devices
    (chip that does not allow IRQ management, for example) should use the kernel-provided
    `dummy_irq_chip`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct irq_chip`：这个结构体是Linux对IRQ控制器的表示，并实现了一组方法来驱动直接由核心IRQ代码调用的中断控制器。必要时，该结构应该由驱动程序填充，提供一组回调函数，允许我们在IRQ芯片上管理IRQ，例如`irq_startup`、`irq_shutdown`、`irq_enable`、`irq_disable`、`irq_ack`、`irq_mask`、`irq_unmask`、`irq_eoi`和`irq_set_affinity`。愚蠢的IRQ芯片设备（例如不允许IRQ管理的芯片）应该使用内核提供的`dummy_irq_chip`。'
- en: '`struct irq_domain`: Each interrupt controller is given a domain, which is
    for the controller what the address space is for a process. The `struct irq_domain`
    structure stores mappings between hardware IRQs and Linux IRQs (that is, virtual
    IRQs, or virq). It is the hardware interrupt number translation object. This structure
    provides the following:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct irq_domain`：每个中断控制器都有一个域，对于控制器来说，它就像地址空间对于进程一样。`struct irq_domain`结构存储了硬件IRQ和Linux
    IRQ（即虚拟IRQ或virq）之间的映射。它是硬件中断号转换对象。这个结构提供以下内容：'
- en: --A pointer to the firmware node for a given interrupt controller (`fwnode`).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '- 给定中断控制器的固件节点（`fwnode`）的指针。'
- en: --A method to convert a firmware (device tree) description of an IRQ into an
    ID local to the interrupt controller (the **hardware IRQ** number, known as the
    **hwirq**). For gpio chips that also act as IRQ controllers, the hardware IRQ
    number (hwirq) for a given gpio line corresponds to the local index of this line
    in the chip most of times.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '- 将IRQ的固件（设备树）描述转换为中断控制器本地的ID（硬件IRQ号，称为hwirq）的方法。对于也充当IRQ控制器的gpio芯片，给定gpio线的硬件IRQ号（hwirq）大多数情况下对应于该线在芯片中的本地索引。'
- en: --A way to retrieve the Linux view of an IRQ from the hwirq.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '- 从hwirq中检索IRQ的Linux视图的方法。'
- en: '`struct irq_desc`: This structure is the Linux kernel view of an interrupt,
    containing all of the core stuff and one-to-one mapping to the Linux interrupt
    number.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct irq_desc`：这个结构是Linux内核对中断的视图，包含所有核心内容，并且与Linux中断号一一对应。'
- en: '`struct irq_action`: This is the structure Linux uses to describe an IRQ handler.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct irq_action`：这是Linux用来描述IRQ处理程序的结构。'
- en: '`struct irq_data`: This structure is embedded in the `struct irq_desc` structure,
    and contains the following:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct irq_data`：这个结构嵌入在`struct irq_desc`结构中，并包含以下内容：'
- en: --The data that is relevant to the `irq_chip` managing this interrupt
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '- 与管理此中断的`irq_chip`相关的数据'
- en: --Both the Linux IRQ number and the hwirq
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '- Linux IRQ号和hwirq都是'
- en: --A pointer to the `irq_chip`
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '- 指向`irq_chip`的指针'
- en: --A pointer to the interrupt translation domain (`irq_domain`)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '- 指向中断转换域（`irq_domain`）的指针'
- en: Always keep in mind that **the irq_domain is for the interrupt controller what
    an address space is for a process, as it stores mappings between virqs and hwirqs**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 始终牢记**irq_domain对于中断控制器就像地址空间对于进程一样，因为它存储了virq和hwirq之间的映射**。
- en: An interrupt controller driver creates and registers `irq_domain` by calling
    one of the `irq_domain_add_<mapping_method>()` functions. These functions are
    actually `irq_domain_add_linear()`, `irq_domain_add_tree()`, and `irq_domain_add_nomap()`.
    In fact, `<mapping_method>` is the method by which `hwirqs` should be mapped to
    `virqs`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 中断控制器驱动程序通过调用`irq_domain_add_<mapping_method>()`函数之一来创建和注册`irq_domain`。这些函数实际上是`irq_domain_add_linear()`、`irq_domain_add_tree()`和`irq_domain_add_nomap()`。事实上，`<mapping_method>`是`hwirqs`应该映射到`virqs`的方法。
- en: '`irq_domain_add_linear()` creates an empty and fixed-size table, indexed by
    the hwirq number. `struct irq_desc` is allocated for each hwirq that gets mapped.
    The allocated IRQ descriptor is then stored in the table, at the index that equals
    the hwirq to which it has been allocated. This linear mapping is suitable for
    fixed and small numbers of hwirqs (lower than 256).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`irq_domain_add_linear()`创建一个空的固定大小的表，由hwirq号索引。为每个被映射的hwirq分配`struct irq_desc`。然后将分配的IRQ描述符存储在表中，索引等于它被分配的hwirq。这种线性映射适用于固定和较小数量的hwirq（小于256）。'
- en: 'While the main advantages of this mapping are the fact that the IRQ number
    lookup time is fixed and that `irq_desc` is allocated for in-use IRQs only, the
    major drawback comes from the size of the table, which can be as large as the
    largest possible `hwirq` number. The majority of drivers should use the linear
    map. This function has the following prototype:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种映射的主要优势是IRQ号查找时间是固定的，并且`irq_desc`仅为正在使用的IRQ分配，但主要缺点来自表的大小，它可能与最大可能的`hwirq`号一样大。大多数驱动程序应该使用线性映射。这个函数有以下原型：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`irq_domain_add_tree()` creates an empty `irq_domain` that maintains the mapping
    between Linux IRQs and `hwirq` numbers in a radix tree. When an hwirq is mapped,
    a `struct irq_desc` is allocated, and the hwirq is used as the lookup key for
    the radix tree. A tree map is a good choice if the hwirq number is very large,
    since it does not need to allocate a table as large as the largest hwirq number.
    The disadvantage is that the `hwirq-to-IRQ` number lookup is dependent on how
    many entries are in the table. Very few drivers should need this mapping. It has
    the following prototype:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`irq_domain_add_tree()`创建一个空的`irq_domain`，在基数树中维护Linux IRQ和`hwirq`号之间的映射。当映射hwirq时，会分配一个`struct
    irq_desc`，并且hwirq被用作基数树的查找键。如果hwirq号非常大，则树映射是一个很好的选择，因为它不需要分配一个与最大hwirq号一样大的表。缺点是`hwirq-to-IRQ`号查找取决于表中有多少条目。很少有驱动程序需要这种映射。它有以下原型：'
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`irq_domain_add_nomap()` is something you will probably never use; however,
    its entire description is available in `Documentation/IRQ-domain.txt`, in the
    kernel source tree. Its prototype is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`irq_domain_add_nomap()`是您可能永远不会使用的东西；但是，其完整描述可以在内核源树中的`Documentation/IRQ-domain.txt`中找到。其原型如下：'
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In all of those prototypes, `of_node` is a pointer to the interrupt controller’s
    DT node. `size` represents the number of interrupts in the domain in case of linear
    mapping. `ops` represents map/unmap domain callbacks, and `host_data` is the controller’s
    private data pointer. As these three functions all create empty `irq` domains,
    you should use the `irq_create_mapping()` function with the hwirq and a pointer
    to the `irq` domain passed to it in order to create a mapping, and insert this
    mapping into the domain:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些原型中，`of_node`是指向中断控制器的DT节点的指针。`size`表示线性映射情况下域中中断的数量。`ops`表示map/unmap域回调，`host_data`是控制器的私有数据指针。由于这三个函数都创建了空的`irq`域，因此应该使用`irq_create_mapping()`函数，将hwirq和传递给它的`irq`域的指针一起使用，以创建映射，并将此映射插入到域中：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding prototype, `domain` is the domain to which this hardware interrupt
    belongs. A `NULL` value means the default domain. `hwirq` is the hardware IRQ
    number you need to create a mapping for. This function maps a hardware interrupt
    into the Linux IRQ space and returns a Linux IRQ number. Also, keep in mind that
    only one mapping per hardware interrupt is permitted. The following is an example
    of creating a mapping:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述原型中，`domain`是此硬件中断所属的域。`NULL`值表示默认域。`hwirq`是您需要为其创建映射的硬件IRQ号。此函数将硬件中断映射到Linux
    IRQ空间，并返回Linux IRQ号。还要记住，每个硬件中断只允许一个映射。以下是创建映射的示例：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, `virq` is the Linux kernel IRQ (the **virtual IRQ number**,
    **virq**) corresponding to the mapping.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`virq`是Linux内核IRQ（**虚拟IRQ号**，**virq**）对应的映射。
- en: Important note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When writing drivers for GPIO controllers that are also interrupt controllers,
    `irq_create_mapping()` is called from within the `gpio_chip.to_irq()` callback,
    and the virq is returned as `return irq_create_mapping(gpiochip->irq_domain, hwirq)`,
    where `hwirq` is the GPIO offset from the GPIO chip.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当为也是中断控制器的GPIO控制器编写驱动程序时，从`gpio_chip.to_irq()`回调中调用`irq_create_mapping()`，并将virq返回为`return
    irq_create_mapping(gpiochip->irq_domain, hwirq)`，其中`hwirq`是从GPIO芯片的GPIO偏移量。
- en: 'Some drivers prefer creating the mappings and populating the domain for each
    hwirq in advance inside the `probe()` function, as shown here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一些驱动程序更喜欢在`probe()`函数内提前创建映射并填充每个hwirq的域，如下所示：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After this, such drivers just call `irq_find_mapping()` (given the hwirq) into
    the `to_irq()` callback function. `irq_create_mapping()` will allocate a new `struct
    irq_desc` structure if no mapping already exists for the given `hwirq`, associate
    it with the hwirq, and call the `irq_domain_ops.map()` callback (by using the
    `irq_domain_associate()` function) so that the driver can perform any required
    hardware setup.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，这样的驱动程序只需在`to_irq()`回调函数中调用`irq_find_mapping()`（给定hwirq）。如果给定的`hwirq`尚不存在映射，则`irq_create_mapping()`将分配一个新的`struct
    irq_desc`结构，将其与hwirq关联，并调用`irq_domain_ops.map()`回调（使用`irq_domain_associate()`函数）以便驱动程序可以执行任何所需的硬件设置。
- en: The struct irq_domain_ops
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: struct irq_domain_ops
- en: 'This structure exposes some callbacks that are specific to the irq domain.
    As mappings are created in a given irq domain, each mapping (actually each `irq_desc`)
    should be given an irq configuration, some private data, and a translation function
    (given a device tree node and an interrupt specifier, the translation function
    decodes the hardware irq number and Linux irq type value). This is what callbacks
    in this structure do:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构公开了一些特定于irq域的回调。由于在给定的irq域中创建了映射，因此应为每个映射（实际上是每个`irq_desc`）提供一个irq配置、一些私有数据和一个转换函数（给定设备树节点和中断说明符，转换函数解码硬件irq号和Linux
    irq类型值）。这就是此结构中回调的作用：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each Linux kernel IRQ management of the elements in the preceding data structure
    deserves a section on its own to describe it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上述数据结构中Linux内核IRQ管理的元素都值得单独的部分来描述。
- en: irq_domain_ops.map()
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: irq_domain_ops.map()
- en: 'The following is the prototype of this callback:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此回调的原型：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Before describing what this function does, let’s describe its arguments:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述此函数的功能之前，让我们描述一下它的参数：
- en: '`d`: The IRQ domain used by this IRQ chip'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`：此IRQ芯片使用的IRQ域'
- en: '`virq`: The global IRQ number used by this GPIO-based IRQ chip'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`virq`：此基于GPIO的IRQ芯片使用的全局IRQ号'
- en: '`hw`: The local IRQ/GPIO line offset on this GPIO chip'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hw`：此GPIO芯片上的本地IRQ/GPIO线偏移量'
- en: '`.map()` creates or updates a mapping between a virq and an hwirq. This callback
    sets up the IRQ configuration. It is called (internally by the irq core) only
    once for a given mapping. This is where we set the `irq` chip data for the given
    irq, which could be done using `irq_set_chip_data()`, which has this prototype:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`.map()`创建或更新virq和hwirq之间的映射。此回调设置IRQ配置。对于给定的映射，它只会被（由irq核心内部）调用一次。这是我们为给定的irq设置`irq`芯片数据的地方，可以使用`irq_set_chip_data()`来完成，其原型如下：'
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Depending on the type of the IRQ chip (nested or chained), additional actions
    can be performed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 根据IRQ芯片的类型（嵌套或链式），可以执行其他操作。
- en: irq_domain_ops.xlate()
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: irq_domain_ops.xlate()
- en: 'Given a DT node and an interrupt specifier, this callback decodes the hardware
    IRQ number along with its Linux IRQ type value. Depending on the `#interrupt-cells`
    property specified in your DT controller node, the kernel provides a generic translation
    function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个DT节点和一个中断指定器，这个回调函数解码硬件IRQ号以及它的Linux IRQ类型值。根据你的DT控制器节点中指定的`#interrupt-cells`属性，内核提供了一个通用的翻译函数：
- en: '`irq_domain_xlate_twocell()`: This generic translation function is for direct
    two-cell binding. The DT IRQ specifier works with two-cell bindings, where the
    cell values map directly to the `hwirq` number and Linux IRQ flags.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_domain_xlate_twocell()`: 这是一个用于直接双细胞绑定的通用翻译函数。DT IRQ指定器与双细胞绑定一起工作，其中细胞值直接映射到`hwirq`号和Linux
    IRQ标志。'
- en: '`irq_domain_xlate_onecell()`: This is a generic `xlate` function for direct
    one-cell bindings.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_domain_xlate_onecell()`: 这是一个用于直接单细胞绑定的通用`xlate`函数。'
- en: '`irq_domain_xlate_onetwocell()`: This is a generic `xlate` function for one-
    or two-cell bindings.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_domain_xlate_onetwocell()`: 这是一个用于单细胞或双细胞绑定的通用`xlate`函数。'
- en: 'An example of the domain operation is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 域操作的一个示例如下：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The distinctive feature of the preceding data structure is the value assigned
    to the `.xlate` element, that is, `irq_domain_xlate_twocell`. This means we are
    expecting a two-cell `irq` specifier in the device tree in which the first cell
    would specify the `irq`, and the second would specify its flags.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前面数据结构的显著特点是分配给`.xlate`元素的值，即`irq_domain_xlate_twocell`。这意味着我们期望在设备树中有一个双细胞`irq`指定器，其中第一个细胞指定`irq`，第二个指定其标志。
- en: Chaining IRQs
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接IRQ
- en: When an interrupt occurs, the `irq_find_mapping()` helper function can be used
    to find the Linux IRQ number from the hwirq number. This hwirq number could be,
    for example, the GPIO offset in a bank of GPIO controllers. Once a valid virq
    has been found and returned, you should call either `handle_nested_irq()` or `generic_handle_irq()`
    on this `virq`. The magic comes from the previous two functions, which manage
    the `irq`-flow handlers.This means that there are two ways to play with interrupt
    handlers. Hard interrupt handlers, or **chained interrupts**, are atomic and run
    with irqs disabled and may schedule the threaded handler; there are also the simply
    threaded interrupt handlers, known as **nested interrupts**, which may be interrupted
    by other interrupts.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生中断时，可以使用`irq_find_mapping()`辅助函数从`hwirq`号中找到Linux IRQ号。例如，这个`hwirq`号可能是GPIO控制器组中的GPIO偏移量。一旦找到并返回了有效的virq，你应该在这个`virq`上调用`handle_nested_irq()`或`generic_handle_irq()`。魔法来自于前两个函数，它们管理了`irq`流处理程序。这意味着有两种处理中断处理程序的方法。硬中断处理程序，或者**链式中断**，是原子的，运行时中断被禁用，并且可能调度线程处理程序；还有简单的线程中断处理程序，称为**嵌套中断**，可能会被其他中断打断。
- en: Chained interrupts
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链式中断
- en: This approach is used for a controller that may not sleep, such as the SoC’s
    internal GPIO controller, which is memory-mapped and whose accesses do not sleep.
    *Chained* means that those interrupts are just chains of function calls (for example,
    the SoC’s GPIO controller interrupt handler is being called from within the GIC
    interrupt handler, just like a function call). With this approach, child IRQ handlers
    are being called inside the parent hwirq handler. `generic_handle_irq()` must
    be used here for chaining child IRQ handlers inside the parent hwirq handler.
    Even from within the child interrupt handlers, we are still in an atomic context
    (hardware interrupt). You cannot call functions that may sleep.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法用于可能不休眠的控制器，比如SoC的内部GPIO控制器，它是内存映射的，其访问不休眠。*链式*意味着这些中断只是一系列函数调用（例如，SoC的GPIO控制器中断处理程序是从GIC中断处理程序中调用的，就像函数调用一样）。采用这种方法，子IRQ处理程序在父hwirq处理程序内被调用。在这里必须使用`generic_handle_irq()`将子IRQ处理程序链接到父hwirq处理程序。即使在子中断处理程序内部，我们仍然处于原子上下文（硬件中断）。你不能调用可能会休眠的函数。
- en: 'For chained (and only chained) IRQ chips, `irq_domain_ops.map()` is also the
    right place to assign a high-level `irq-type` flow handler to the given irq using
    `irq_set_chip_and_handler()`, so that this high-level code, depending on what
    it is, will do some hacks before calling the corresponding irq handler. The magic
    operates here thanks to the `irq_set_chip_and_handler()` function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于链式（仅链式）IRQ芯片，`irq_domain_ops.map()`也是将高级`irq-type`流处理程序分配给给定的irq的正确位置，使用`irq_set_chip_and_handler()`，这样高级代码，根据它的内容，将在调用相应的irq处理程序之前执行一些操作。这里的魔法操作得益于`irq_set_chip_and_handler()`函数：
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding prototype, `irq` represents the Linux IRQ (the `virq`), given
    as a parameter to the `irq_domain_ops.map()` function; `chip` is your `irq_chip`
    structure; and `handle` is your high-level interrupt flow handler.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的原型中，`irq`代表Linux IRQ（`virq`），作为参数传递给`irq_domain_ops.map()`函数；`chip`是你的`irq_chip`结构；`handle`是你的高级中断流处理程序。
- en: Important note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Some controllers are quite dumb and need almost nothing in their `irq_chip`
    structure. In this case, you should pass `dummy_irq_chip` to `irq_set_chip_and_handler()`.
    `dummy_irq_chip` is defined in `kernel/irq/dummychip.c`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有些控制器非常简单，几乎不需要在它们的`irq_chip`结构中做任何事情。在这种情况下，你应该将`dummy_irq_chip`传递给`irq_set_chip_and_handler()`。`dummy_irq_chip`在`kernel/irq/dummychip.c`中定义。
- en: 'The following code flow summarizes what `irq_set_chip_and_handler()` does:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`irq_set_chip_and_handler()`的代码流程总结：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'These are some possible high-level IRQ flow handlers provided by the generic
    layer:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是通用层提供的一些可能的高级IRQ流处理程序：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Each function name describes quite well the type of IRQ it handles. This is
    what `irq_domain_ops.map()` may look like for a chained IRQ chip:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数名都很好地描述了它处理的IRQ类型。对于链式IRQ芯片，`irq_domain_ops.map()`可能如下所示：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: While writing the parent irq handler for a chained IRQ chip, the code should
    call `generic_handle_irq()` on each child `irq`. This function simply calls `irq_desc->handle_irq()`,
    which points to the high-level interrupt handler assigned to the given child IRQ
    using `irq_set_chip_and_handler()`. The underlying high-level `irq` event handler
    (let’s say `handle_level_irq()`) will first do some hacks, then will run the hard
    `irq-handler` (`irq_desc->action->handler`) and, depending on the return value,
    will run the threaded handler (`irq_desc->action->thread_fn`) if provided.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在为链式IRQ芯片编写父irq处理程序时，代码应该在每个子irq上调用`generic_handle_irq()`。这个函数简单地调用`irq_desc->handle_irq()`，它指向使用`irq_set_chip_and_handler()`分配给给定子IRQ的高级中断处理程序。底层的高级`irq`事件处理程序（比如`handle_level_irq()`）首先会做一些小技巧，然后会运行硬`irq-handler`（`irq_desc->action->handler`），根据返回值，如果提供的话，会运行线程处理程序（`irq_desc->action->thread_fn`）。
- en: 'Here is an example of the parent IRQ handler for a chained IRQ chip, whose
    original code is located in `drivers/pinctrl/pinctrl-at91.c` in the kernel source:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是链式IRQ芯片的父IRQ处理程序的示例，其原始代码位于内核源码中的`drivers/pinctrl/pinctrl-at91.c`中：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Chained IRQ chip drivers do not need to register the parent `irq` handler using
    `devm_request_threaded_irq()` or `devm_request_irq()`. This handler is automatically
    registered when the driver calls `irq_set_chained_handler_and_data()` on this
    parent irq, given the associated handler as parameter, along with some private
    data:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 链式IRQ芯片驱动程序不需要使用`devm_request_threaded_irq()`或`devm_request_irq()`注册父`irq`处理程序。当驱动程序在父irq上调用`irq_set_chained_handler_and_data()`时，此处理程序会自动注册，并提供相关的处理程序和一些私有数据：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The parameters of this function are quite self-explanatory. You should call
    this function in the `probe` function as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的参数非常容易理解。您应该在`probe`函数中调用这个函数，如下所示：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding fake `probe` method, a linear domain is created using `irq_domain_add_linear()`,
    and an irq mapping (virtual irq) is created in this domain with `irq_create_mapping()`.
    Finally, we set a high-level chained flow handler and its data for the main (or
    parent) IRQ.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面虚假的`probe`方法中，使用`irq_domain_add_linear()`创建了一个线性域，并在该域中使用`irq_create_mapping()`创建了一个irq映射（虚拟irq）。最后，我们为主（或父）IRQ设置了一个高级链式流处理程序及其数据。
- en: Important note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that `irq_set_chained_handler_and_data()` automatically enables the interrupt
    (specified in the first parameter), assigns its handler (also given as a parameter),
    and marks this interrupt as `IRQ_NOREQUEST`, `IRQ_NOPROBE`, or `IRQ_NOTHREAD`,
    which mean this interrupt cannot be requested via `request_irq()` anymore, cannot
    be probed by auto probing, and cannot be threaded at all (it is chained), respectively.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`irq_set_chained_handler_and_data()`会自动启用中断（指定为第一个参数），分配其处理程序（也作为参数给出），并将此中断标记为`IRQ_NOREQUEST`、`IRQ_NOPROBE`或`IRQ_NOTHREAD`，这意味着此中断不能再通过`request_irq()`请求，不能通过自动探测进行探测，也不能线程化（它是链式的）。
- en: Nested interrupts
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌套中断
- en: 'The nested flow method is used by IRQ chips that may sleep, such as those that
    are on slow buses, such as I2C (for example, an I2C GPIO expander). "Nested" refers
    to those interrupt handlers that do not run in the hardware context (they are
    not really hwirq, and are not in an atomic context), but are threaded instead
    and can be preempted. Here, the handler function is called inside the calling
    threads context. For nested (and only nested) IRQ chips, the `irq_domain_ops.map()`
    callback is also the right place to set up `irq` configuration flags. The most
    important configuration flags are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套流方法是由可能休眠的IRQ芯片使用的，例如那些位于慢总线上的IRQ芯片，比如I2C（例如，I2C GPIO扩展器）。"嵌套"指的是那些不在硬件上下文中运行的中断处理程序（它们实际上不是hwirq，并且不在原子上下文中），而是线程化的，可以被抢占。在这里，处理程序函数是在调用线程的上下文中调用的。对于嵌套（仅对嵌套）IRQ芯片，`irq_domain_ops.map()`回调也是设置`irq`配置标志的正确位置。最重要的配置标志如下：
- en: '`IRQ_NESTED_THREAD`: This is a flag that indicates that on `devm_request_threaded_irq()`,
    no dedicated interrupt thread should be created for the irq handler, as it is
    called nested in the context of a demultiplexing interrupt handler thread (there’s
    more information about this in the `__setup_irq()` function, implemented in `kernel/irq/manage.c`
    in the kernel source). You can use `void irq_set_nested_thread(unsigned int irq,
    int nest)` to act on this flag, where `irq` corresponds to the global interrupt
    number and `nest` should be `0` to clear or `1` to set the `IRQ_NESTED_THREAD`
    flag.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IRQ_NESTED_THREAD`：这是一个标志，表示在`devm_request_threaded_irq()`上，不应为irq处理程序创建专用的中断线程，因为它在解复用中断处理程序线程的上下文中被嵌套调用（在内核源码中的`kernel/irq/manage.c`中实现了`__setup_irq()`函数中有更多关于此的信息）。您可以使用`void
    irq_set_nested_thread(unsigned int irq, int nest)`来操作此标志，其中`irq`对应于全局中断号，`nest`应为`0`以清除或`1`以设置`IRQ_NESTED_THREAD`标志。'
- en: '`IRQ_NOTHREAD`: This flag can be set using `void irq_set_nothread(unsigned
    int irq)`. It is used to mark the given IRQ as non-threadable.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IRQ_NOTHREAD`：可以使用`void irq_set_nothread(unsigned int irq)`设置此标志。它用于将给定的IRQ标记为不可线程化。'
- en: 'This is what `irq_domain_ops.map()` may look like for a nested IRQ chip:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是嵌套IRQ芯片的`irq_domain_ops.map()`可能看起来像这样：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'While writing the parent irq handler for a nested IRQ chip, the code should
    call `handle_nested_irq()` in order to handle child irq handlers so that they
    run from the parent irq thread. `handle_nested_irq()` does not care about `irq_desc->action->handler`,
    which is the hard irq handler. It simply runs `irq_desc->action->thread_fn`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在为嵌套IRQ芯片编写父irq处理程序时，代码应该调用`handle_nested_irq()`来处理子irq处理程序，以便它们从父irq线程中运行。`handle_nested_irq()`不关心`irq_desc->action->handler`，即硬irq处理程序。它只运行`irq_desc->action->thread_fn`：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Nested IRQ chip drivers `devm_request_threaded_irq()`, as there is no function
    like `irq_set_chained_handler_and_data()` for this kind of IRQ chip. It does not
    make sense to use this API for nested IRQ chips. Nested IRQ chips, most of the
    time, are GPIO chip-based. Thus, we would be better off using the GPIO chip-based
    IRQ chip API, or using the regmap-based IRQ chip API, as shown in the next section.
    However, let’s see what such an example looks like:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套IRQ芯片驱动程序使用`devm_request_threaded_irq()`，因为对于这种类型的IRQ芯片没有像`irq_set_chained_handler_and_data()`这样的函数。对于嵌套IRQ芯片使用这个API是没有意义的。嵌套IRQ芯片大多数情况下是基于GPIO芯片的。因此，最好使用基于GPIO芯片的IRQ芯片API，或者使用基于regmap的IRQ芯片API，如下一节所示。然而，让我们看看这样一个例子是什么样子的：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding `probe` method, there are two main differences with the chained
    flow:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的`probe`方法中，与链接流有两个主要区别：
- en: 'First, the way the main IRQ is registered: While chained IRQ chips used `irq_set_chained_handler_and_data()`,
    which automatically registered the handler, the nested flow method has to register
    its handler explicitly using the `request_threaded_irq()` family method.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，主IRQ的注册方式：在链接的IRQ芯片中使用了`irq_set_chained_handler_and_data()`，它自动注册了处理程序，而嵌套流方法必须使用`request_threaded_irq()`系列方法显式注册其处理程序。
- en: 'Second, the way the main IRQ handler invokes underlying irq handlers: In the
    chained flow, `handle_nested_irq()` is called in the main IRQ handler, which invokes
    the handlers of each underlying irq as a chain of function calls, which are executed
    in the same context as the main handler, that is, atomically (the atomicity is
    also known as `hard-irq`). However, the nested flow handler had to call `handle_nested_irq()`,
    which executes the handler `(thread_fn`) of the underlying irq in the thread context
    of the parent.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，主IRQ处理程序调用底层irq处理程序的方式：在链接流中，主IRQ处理程序中调用`handle_nested_irq()`，它调用每个底层irq的处理程序作为一系列函数调用，这些函数调用在与主处理程序相同的上下文中执行，即原子地（原子性也称为`hard-irq`）。然而，嵌套流处理程序必须调用`handle_nested_irq()`，它在父级的线程上下文中执行底层irq的处理程序（`thread_fn`）。
- en: These are the main differences between chained and nested flows.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是链接和嵌套流之间的主要区别。
- en: irqchip and gpiolib API – new generation
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: irqchip和gpiolib API - 新一代
- en: 'Since each `irq-gpiochip` driver open-coded its own `irqdomain` handling, this
    led to a lot of redundant code. Kernel developers decided to move that code to
    the gpiolib framework, thus providing the `GPIOLIB_IRQCHIP` Kconfig symbol, enabling
    us to use a unified irq domain management API for GPIO chips. That portion of
    code helps with handling the management of GPIO IRQ chips and the associated `irq_domain`
    and resource allocation callbacks, as well as their setup, using the reduced set
    of helper functions. These are `gpiochip_irqchip_add()`or `gpiochip_irqchip_add_nested()`,
    and `gpiochip_set_chained_irqchip()` or `gpiochip_set_nested_irqchip()`. `gpiochip_irqchip_add()`
    or `gpiochip_irqchip_add_nested()` both add an IRQ chip to a GPIO chip. Here are
    their respective prototypes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个`irq-gpiochip`驱动程序都在其自己的`irqdomain`处理中进行了开放编码，这导致了大量的冗余代码。内核开发人员决定将该代码移动到gpiolib框架中，从而提供了`GPIOLIB_IRQCHIP`
    Kconfig符号，使我们能够为GPIO芯片使用统一的irq域管理API。该代码部分有助于处理GPIO IRQ芯片和相关`irq_domain`和资源分配回调的管理，以及它们的设置，使用了一组减少的辅助函数。这些函数是`gpiochip_irqchip_add()`或`gpiochip_irqchip_add_nested()`，以及`gpiochip_set_chained_irqchip()`或`gpiochip_set_nested_irqchip()`。`gpiochip_irqchip_add()`或`gpiochip_irqchip_add_nested()`都向GPIO芯片添加一个IRQ芯片。以下是它们各自的原型：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding prototypes, the `gpiochip` parameter is the GPIO chip to add
    the `irqchip` to. `irqchip` is the IRQ chip to be added to the GPIO chip in order
    to extend its capabilities so that it can act as an IRQ controller as well. This
    IRQ chip has to be configured properly, either by the driver or by the IRQ core
    code (if `dummy_irq_chip` is given as a parameter). If it’s not dynamically assigned,
    `first_irq` will be the base (first) IRQ to allocate GPIO chip IRQs from. `handler`
    is the primary IRQ handler to use (often one of the predefined high-level IRQ
    core functions). `type` is the default type for IRQs on this `IRQ chip`; pass
    `IRQ_TYPE_NONE` here and let the drivers configure this upon request.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述原型中，`gpiochip`参数是要将`irqchip`添加到的GPIO芯片。`irqchip`是要添加到GPIO芯片以扩展其功能，使其也可以充当IRQ控制器的IRQ芯片。这个IRQ芯片必须被正确配置，要么由驱动程序，要么由IRQ核心代码（如果给定`dummy_irq_chip`作为参数）。如果没有动态分配，`first_irq`将是从中分配GPIO芯片IRQ的基础（第一个）IRQ。`handler`是要使用的主要IRQ处理程序（通常是预定义的高级IRQ核心函数之一）。`type`是此`IRQ芯片`上IRQ的默认类型；在这里传递`IRQ_TYPE_NONE`，并让驱动程序在请求时配置这个。
- en: 'A summary of each of these function actions is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数操作的摘要如下：
- en: The first one allocates a `struct irq_domain` to the GPIO chip using the `irq_domain_add_simple()`
    function. This IRQ domain's ops is set with the kernel IRQ core domain ops variable
    called `gpiochip_domain_ops`. This domain ops is defined in `drivers/gpio/gpiolib.c`,
    with the `irq_domain_ops.xlate` field set to `irq_domain_xlate_twocell`, meaning
    that this gpio chip will handle two-celled IRQs.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个函数使用`irq_domain_add_simple()`函数为GPIO芯片分配了一个`struct irq_domain`。这个IRQ域的ops是使用内核IRQ核心域ops变量`gpiochip_domain_ops`设置的。这个域ops在`drivers/gpio/gpiolib.c`中定义，`irq_domain_ops.xlate`字段设置为`irq_domain_xlate_twocell`，这意味着这个gpio芯片将处理双细胞的IRQ。
- en: 'Sets the `gpiochip.to_irq` field to `gpiochip_to_irq`, which is a callback
    that returns `irq_create_mapping(chip->irq.domain, offset)`, creating an IRQ mapping
    that corresponds to the GPIO offset. This is performed when we invoke `gpiod_to_irq()`
    on that GPIO. This function assumes that each of the pins on the `gpiochip` can
    generate a unique IRQ. The following is how the `gpiochip_domain_ops` IRQ domain
    is defined:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`gpiochip.to_irq`字段设置为`gpiochip_to_irq`，这是一个回调函数，返回`irq_create_mapping(chip->irq.domain,
    offset)`，创建一个与GPIO偏移对应的IRQ映射。当我们在该GPIO上调用`gpiod_to_irq()`时执行此操作。这个函数假设`gpiochip`上的每个引脚都可以生成唯一的IRQ。以下是`gpiochip_domain_ops`
    IRQ域的定义：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The only difference between `gpiochip_irqchip_add_nested()` and `gpiochip_irqchip_add()`
    is that the former adds a nested IRQ chip to the GPIO chip (it sets the `gpio_chip->irq.threaded`
    field to `true`), while the later adds a chained IRQ chip to a GPIO chip and sets
    this field to `false`. On the other hand, `gpiochip_set_chained_irqchip()` and
    `gpiochip_set_nested_irqchip()` respectively assign/connect a chained or a nested
    IRQ chip to the GPIO chip. The following are the prototypes of those two functions:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpiochip_irqchip_add_nested()`和`gpiochip_irqchip_add()`之间唯一的区别是前者向GPIO芯片添加了一个嵌套的IRQ芯片（它将`gpio_chip->irq.threaded`字段设置为`true`），而后者向GPIO芯片添加了一个链式的IRQ芯片，并将此字段设置为`false`。另一方面，`gpiochip_set_chained_irqchip()`和`gpiochip_set_nested_irqchip()`分别将链式或嵌套的IRQ芯片分配/连接到GPIO芯片。以下是这两个函数的原型：'
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding prototypes, `gpiochip` is the GPIO chip to set the `irqchip`
    chain to. `irqchip` represents the IRQ chip to chain to the GPIO chip. `parent_irq`
    is the irq number corresponding to the parent IRQ for this chained IRQ chip. In
    other words, it is the IRQ number to which this chip is connected. `parent_handler`
    is the parent interrupt handler for the accumulated IRQ coming out of the GPIO
    chip. It is actually the hwirq handler. This is not used for nested IRQ chips,
    as the parent handler is threaded. The chained variant will internally call `irq_set_chained_handler_and_data()`
    on `parent_handler`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述原型中，`gpiochip`是要设置`irqchip`链的GPIO芯片。`irqchip`代表要连接到GPIO芯片的IRQ芯片。`parent_irq`是与此链式IRQ芯片对应的父IRQ的irq编号。换句话说，它是连接到此芯片的IRQ编号。`parent_handler`是GPIO芯片累积的IRQ的父中断处理程序。实际上，这是hwirq处理程序。对于嵌套的IRQ芯片，这不会被使用，因为父处理程序是线程化的。链式变体将在`parent_handler`上内部调用`irq_set_chained_handler_and_data()`。
- en: Chained gpiochip-based IRQ chips
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 链式gpiochip基于的IRQ芯片
- en: '`gpiochip_irqchip_add()` and `gpiochip_set_chained_irqchip()` are to be used
    on chained GPIO chip-based IRQ chips, while `gpiochip_irqchip_add_nested()` and
    `gpiochip_set_nested_irqchip()` are used on nested GPIO chip-based IRQ chips only.
    With chained GPIO chip-based IRQ chips, `gpiochip_set_chained_irqchip()` will
    configure the parent hwirq’s handler. There’s no need to call any `devm_request_*`
    `irq` family function. However, the parent hwirq’s handler has to call `generic_handle_irq()`
    on the raised child `irqs`, as in the following example (from `drivers/pinctrl/pinctrl-at91.c`
    in the kernel sources), somewhat similar to a standard chained IRQ chip:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpiochip_irqchip_add()`和`gpiochip_set_chained_irqchip()`用于链式GPIO芯片基于的IRQ芯片，而`gpiochip_irqchip_add_nested()`和`gpiochip_set_nested_irqchip()`仅用于嵌套GPIO芯片基于的IRQ芯片。对于链式GPIO芯片基于的IRQ芯片，`gpiochip_set_chained_irqchip()`将配置父hwirq的处理程序。不需要调用任何`devm_request_*`
    `irq`家族函数。但是，父hwirq的处理程序必须在引发的子`irqs`上调用`generic_handle_irq()`，如下面的示例（来自内核源代码中的`drivers/pinctrl/pinctrl-at91.c`），与标准的链式IRQ芯片有些相似：'
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, the interrupt handler is introduced first. Upon an interrupt
    issued by the GPIO chip, its whole gpio status bank is read in order to detect
    each bit that is set there, which would mean a potential IRQ triggered by the
    device behind the corresponding gpio line.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先介绍了中断处理程序。当GPIO芯片发出中断时，将读取整个gpio状态银行，以便检测其中设置的每个位，这意味着由相应的gpio线后面的设备触发的潜在IRQ。
- en: '`generic_handle_irq()` is then invoked on each irq descriptor whose index in
    the domain corresponds to the index of a bit set in the gpio status bank. This
    method in turn will invoke each handler registered for each descriptor found in
    the previous step in an atomic context (the `hard-irq` context), except if the
    underlying driver for the device for which the gpio is used as an irq line requested
    the handler to be threaded.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在域中索引与gpio状态银行中设置的位的索引相对应的每个irq描述符上调用`generic_handle_irq()`。这种方法将在原子上下文（`hard-irq`上下文）中调用在前一步中找到的每个描述符的每个处理程序，除非用于将gpio用作irq线的设备的底层驱动程序请求处理程序为线程化。
- en: 'Now we can introduce the `probe` method, an example of which is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以介绍`probe`方法，一个示例如下：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There’s nothing special there. The mechanism here somehow follows what we have
    seen in the generic IRQ chips. The parent IRQ is not requested here using any
    of the `request_irq()` family methods because `gpiochip_set_chained_irqchip()`
    will invoke `irq_set_chained_handler_and_data()` under the hood.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的。这里的机制在某种程度上遵循了我们在通用IRQ芯片中看到的内容。父IRQ在这里不是使用任何`request_irq()`家族方法请求的，因为`gpiochip_set_chained_irqchip()`将在底层调用`irq_set_chained_handler_and_data()`。
- en: Nested gpiochip-based irqchips
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于嵌套的gpiochip irqchips
- en: 'The following excerpt shows how nested GPIO chip-based IRQ chips are registered
    by their drivers. This is somewhat similar to standalone nested IRQ chips:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下摘录显示了驱动程序如何注册其嵌套GPIO芯片基于的IRQ芯片。这在某种程度上类似于独立的嵌套IRQ芯片：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding code is the IRQ handler. As we can see, it uses `handle_nested_irq()`,
    which is nothing new for us. Let’s now inspect the `probe` method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是IRQ处理程序。正如我们所看到的，它使用`handle_nested_irq()`，这对我们来说并不新鲜。现在让我们检查`probe`方法：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, the parent irq handler is threaded and has to be registered using `devm_request_threaded_irq()`.
    This explains why its IRQ handler has to call `handle_nested_irq()` on child irqs
    in order to invoke their handlers. Once more, this looks like generic nested `irqchips`,
    except for the fact that gpiolib has wrapped some of the underlying nested `irqchip`
    APIs. To confirm this, you can have a look into the body of the `gpiochip_set_nested_irqchip()`
    and `gpiochip_irqchip_add_nested()` methods.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，父irq处理程序是线程化的，并且必须使用`devm_request_threaded_irq()`进行注册。这解释了为什么它的IRQ处理程序必须在子irq上调用`handle_nested_irq()`以调用它们的处理程序。再次，这看起来像通用的嵌套`irqchips`，除了gpiolib已经包装了一些底层的嵌套`irqchip`API。要确认这一点，您可以查看`gpiochip_set_nested_irqchip()`和`gpiochip_irqchip_add_nested()`方法的主体。
- en: Regmap IRQ API and data structures
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Regmap IRQ API和数据结构
- en: The regmap IRQ API is implemented in `drivers/base/regmap/regmap-irq.c`. It
    is mainly built on top of two essential functions, `devm_regmap_add_irq_chip()`
    and `regmap_irq_get_virq()`, and three data structures, `struct regmap_irq_chip`,
    `struct regmap_irq_chip_data`, and `struct regmap_irq`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Regmap IRQ API 实现在 `drivers/base/regmap/regmap-irq.c` 中。它主要建立在两个基本函数 `devm_regmap_add_irq_chip()`
    和 `regmap_irq_get_virq()` 以及三个数据结构 `struct regmap_irq_chip`、`struct regmap_irq_chip_data`
    和 `struct regmap_irq` 的基础上。
- en: Important note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Regmap’s `irqchip` API entirely uses threaded IRQs. Thus, only what we have
    seen in the *Nested interrupts* section will apply here.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Regmap 的 `irqchip` API 完全使用了线程中断。因此，只有我们在 *嵌套中断* 部分看到的内容才适用于这里。
- en: Regmap IRQ data structures
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Regmap IRQ 数据结构
- en: As mentioned earlier, we need to introduce the three data structures of the
    `regmap irq api` in order to understand how it abstracts IRQ management.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要介绍 `regmap irq api` 的三个数据结构，以便了解它如何抽象中断管理。
- en: struct regmap_irq_chip and struct regmap_irq
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`struct regmap_irq_chip` 和 `struct regmap_irq`'
- en: 'The `struct regmap_irq_chip` structure describes a generic `regmap irq_chip`.
    Prior to discussing this structure, let’s first introduce `struct regmap_irq`,
    which stores the register and the mask description of an IRQ for `regmap irq_chip`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct regmap_irq_chip` 结构描述了一个通用的 `regmap irq_chip`。在讨论这个结构之前，让我们先介绍 `struct
    regmap_irq`，它存储了 `regmap irq_chip` 的中断的寄存器和掩码描述：'
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following are descriptions of the fields in the preceding structure:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述结构中字段的描述：
- en: '`reg_offset` is the offset of the status/mask register within the bank. This
    bank may actually be the `{status/mask/unmask/ack/wake}_base` register of the
    IRQ `chip`.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg_offset` 是在银行内状态/掩码寄存器的偏移。该银行实际上可能是 IRQ `chip` 的 `{status/mask/unmask/ack/wake}_base`
    寄存器。'
- en: '`mask` is the mask used to flag/control this IRQ status register. When disabling
    the IRQ, the mask value will be *ORed* with the actual content of `reg_offset`
    from the regmap’s `irq_chip.status_base` register. For `irq` enabling, `~mask`
    will be ANDed.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mask` 是用于标记/控制此中断状态寄存器的掩码。在禁用中断时，掩码值将与来自 regmap 的 `irq_chip.status_base` 寄存器的
    `reg_offset` 的实际内容进行 *OR* 运算。对于中断使能，将进行 `~mask` 的 AND 运算。'
- en: '`type_reg_offset` is the offset register (from the `irqchip` status base register)
    for the IRQ type setting.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type_reg_offset` 是 IRQ 类型设置的偏移寄存器（从 `irqchip` 状态基地址寄存器）。'
- en: '`type_rising_mask` is the mask bit to configure *rising* type IRQs. This value
    will be ORed with the actual content of `type_reg_offset` when setting the type
    of the IRQ to `IRQ_TYPE_EDGE_RISING`.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type_rising_mask` 是用于配置 *上升* 类型中断的掩码位。当将中断类型设置为 `IRQ_TYPE_EDGE_RISING` 时，此值将与
    `type_reg_offset` 的实际内容进行 OR 运算。'
- en: '`type_falling_mask` is the mask bit to configure *falling* type IRQs. This
    value will be ORed with the actual content of `type_reg_offset` when setting the
    type of the IRQ to `IRQ_TYPE_EDGE_FALLING`. For the `IRQ_TYPE_EDGE_BOTH` type,
    `(type_falling_mask | irq_data->type_rising_mask)` will be used as a mask.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type_falling_mask` 是用于配置 *下降* 类型中断的掩码位。当将中断类型设置为 `IRQ_TYPE_EDGE_FALLING` 时，此值将与
    `type_reg_offset` 的实际内容进行 OR 运算。对于 `IRQ_TYPE_EDGE_BOTH` 类型，将使用 `(type_falling_mask
    | irq_data->type_rising_mask)` 作为掩码。'
- en: 'Now that we are familiar with `struct regmap_irq`, let’s describe `struct regmap_irq_chip`,
    the structure of which looks as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了 `struct regmap_irq`，让我们描述 `struct regmap_irq_chip`，其结构如下：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This structure describes a generic `regmap_irq_chip`, which can handle most
    interrupt controllers (not all of them, as we will see later). The following list
    describes the fields in this data structure:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构描述了一个通用的 `regmap_irq_chip`，它可以处理大多数中断控制器（并非所有，我们稍后会看到）。以下列表描述了此数据结构中的字段：
- en: '`name` is a descriptive name for the IRQ controller.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 是中断控制器的描述性名称。'
- en: '`status_base` is the base status register address to which the regmap IRQ core
    adds `regmap_irq.reg_offset` prior to obtaining the final status register for
    the given `regmap_irq`.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status_base` 是基本状态寄存器地址，regmap IRQ 核心在获取给定 `regmap_irq` 的最终状态寄存器之前会添加 `regmap_irq.reg_offset`。'
- en: '`mask_writeonly` states whether the base mask register is write-only or not.
    If yes, `regmap_write_bits()` is used to write into the register, otherwise `regmap_update_bits()`
    is used.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mask_writeonly` 表示基本掩码寄存器是否是只写的。如果是，将使用 `regmap_write_bits()` 写入寄存器，否则使用 `regmap_update_bits()`。'
- en: '`unmask_base` is the base unmask register address, which has to be specified
    for chips that have separate mask and unmask registers.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unmask_base` 是基本取消屏蔽寄存器地址，对于具有单独的屏蔽和取消屏蔽寄存器的芯片必须指定。'
- en: '`ack_base` is the acknowledgement base register address. Using a value of `0`
    is possible with the `use_ack` bit.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ack_base` 是确认基地址寄存器。使用 `use_ack` 位时，可以使用值 `0`。'
- en: '`wake_base` is the base address for `wake enable`, used to control the irq
    power management wakeups. If the value is `0`, it means this is unsupported.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wake_base` 是 `wake enable` 的基地址，用于控制中断电源管理唤醒。如果值为 `0`，表示不支持。'
- en: '`type_base` is the base address for the IRQ type to which the regmap IRQ core
    adds `regmap_irq.type_reg_offset` prior to obtaining the final type register for
    the given `regmap_irq`. If it is `0`, it means this is unsupported.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type_base` 是 IRQ 类型的基地址，regmap IRQ 核心在获取给定 `regmap_irq` 的最终类型寄存器之前会添加 `regmap_irq.type_reg_offset`。如果为
    `0`，表示不支持。'
- en: '`irq_reg_stride` is the stride to use for chips where registers are not contiguous.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_reg_stride` 是在寄存器不连续的芯片上使用的步幅。'
- en: '`init_ack_masked` states whether the regmap IRQ core should acknowledge all
    masked interrupts once during initialization.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init_ack_masked` 表示 regmap IRQ 核心在初始化期间是否应确认所有屏蔽中断。'
- en: '`mask_invert`, if `true`, means the mask register is inverted. It means cleared
    bit indexes correspond to masked out interrupts.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mask_invert`，如果为 `true`，表示掩码寄存器是反转的。这意味着清除的位索引对应于被屏蔽的中断。'
- en: '`use_ack`, if `true`, means the acknowledgement register should be used even
    if it is `0`.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use_ack`，如果为 `true`，表示即使为 `0`，也应该使用确认寄存器。'
- en: '`ack_invert`, if `true`, means the acknowledgement register is inverted: corresponding
    bit is cleared for a acknowledge.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ack_invert`，如果为 `true`，表示确认寄存器是反转的：对于确认，相应的位将被清除。'
- en: '`wake_invert`, if `true`, means the wake register is inverted: cleared bits
    correspond to wake enabled.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wake_invert`，如果为`true`，表示唤醒寄存器被反转：清除的位对应于唤醒使能。'
- en: '`type_invert`, if `true`, means inverted type flags are used.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type_invert`，如果为`true`，表示使用反转类型标志。'
- en: '`num_regs` is the number of registers in each control bank. The number of registers
    to read when using `regmap_bulk_read()` will be given. Have a look at the definition
    of `regmap_irq_thread()` for more information.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_regs`是每个控制块中寄存器的数量。使用`regmap_bulk_read()`时要读取的寄存器数量将被给出。查看`regmap_irq_thread()`的定义以获取更多信息。'
- en: '`irqs` is an array of descriptors for individual IRQs, and `num_irqs` is the
    total number of descriptors in the array. Interrupt numbers are assigned based
    on the index in this array.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irqs`是单个IRQ的描述符数组，`num_irqs`是数组中描述符的总数。中断号是基于该数组中的索引分配的。'
- en: '`num_type_reg` is the number of type registers, while `type_reg_stride` is
    the stride to use for chips where type registers are not contiguous. Regmap IRQ
    implements the generic interrupt service routine, which is common for most devices.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_type_reg`是类型寄存器的数量，而`type_reg_stride`是用于非连续类型寄存器芯片的步幅。Regmap IRQ实现了通用中断服务例程，对大多数设备都是通用的。'
- en: 'Some devices, such as `MAX77620` or `MAX20024`, need special handling before
    and after servicing the interrupt. This is where `handle_pre_irq` and `handle_post_irq`
    come in. These are driver-specific callbacks to handle interrupts from devices
    before `regmap_irq_handler` processes the interrupts. `irq_drv_data` is then the
    data that is passed as a parameter to those pre-/post-interrupt handlers. For
    example, the `MAX77620` programming guidelines for interrupt servicing says the
    following:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些设备，比如`MAX77620`或`MAX20024`，在服务中断之前和之后需要特殊处理。这就是`handle_pre_irq`和`handle_post_irq`发挥作用的地方。这些是特定于驱动程序的回调函数，用于在`regmap_irq_handler`处理中断之前处理设备的中断。然后`irq_drv_data`是作为参数传递给这些前/后中断处理程序的数据。例如，`MAX77620`的中断服务编程指南如下所示：
- en: --When interrupt occurs from PMIC, mask the PMIC interrupt by setting GLBLM.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: --当来自PMIC的中断发生时，通过设置GLBLM来屏蔽PMIC中断。
- en: --Read IRQTOP and service the interrupt accordingly.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: --读取IRQTOP并相应地服务中断。
- en: --Once all interrupts have been checked and serviced, the interrupt service
    routine un-masks the hardware interrupt line by clearing GLBLM.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: --一旦所有中断都经过检查和服务，中断服务例程通过清除GLBLM来取消屏蔽硬件中断线。
- en: Back to the `regmap_irq_chip.irqs` field, this field is of the `regmap_irq`
    type, introduced earlier.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`regmap_irq_chip.irqs`字段，这个字段是之前介绍的`regmap_irq`类型。
- en: struct regmap_irq_chip_data
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结构体`regmap_irq_chip_data`
- en: 'This structure is the runtime data structure for the regmap IRQ controller,
    allocated on the successful return path of `devm_regmap_add_irq_chip()`. It has
    to be stored in a large and private data structure for later use. Its definition
    is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构是regmap IRQ控制器的运行时数据结构，在`devm_regmap_add_irq_chip()`成功返回路径上分配。它必须存储在一个大型和私有的数据结构中以供以后使用。其定义如下：
- en: '[PRE38]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For simplicity, some fields in the structure have been removed. Here is a description
    of the fields in this structure:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，结构中的一些字段已被删除。以下是该结构中字段的描述：
- en: '`lock` is the lock used to protect accesses to the `irq_chip` to which `regmap_irq_chip_data`
    belongs. As regmap IRQs are totally threaded, it is safe to use a mutex.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock`是用于保护对`regmap_irq_chip_data`所属的`irq_chip`的访问的锁。由于regmap IRQ是完全线程化的，因此可以安全地使用互斥锁。'
- en: '`irq_chip` is the underlying interrupt chip descriptor structure (providing
    IRQ-related operations) for this regmap-enabled `irqchip`, set with `regmap_irq_chip`,
    defined as follows in `drivers/base/regmap/regmap-irq.c`:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_chip`是此regmap启用的`irqchip`的底层中断芯片描述符结构（提供IRQ相关操作），使用`regmap_irq_chip`设置，如`drivers/base/regmap/regmap-irq.c`中所定义：'
- en: '[PRE39]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`map` is the regmap structure for the aforementioned `irq_chip`.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`是前述`irq_chip`的regmap结构。'
- en: '`chip` is a pointer to the generic regmap `irq_chip`, which should have been
    set up in the driver. It is given as a parameter to `devm_regmap_add_irq_chip()`.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chip`是指向通用regmap `irq_chip`的指针，它应该已经在驱动程序中设置好。它作为参数传递给`devm_regmap_add_irq_chip()`。'
- en: '`base`, if more than zero, is the base from which it allocates a specific IRQ
    number. In other words, the numbering of IRQ starts at `base`.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base`，如果大于零，是从其分配特定IRQ编号的基数。换句话说，IRQ的编号从`base`开始。'
- en: '`domain` is the IRQ domain for the underlying IRQ chip, with `ops` set to `regmap_domain_ops`,
    defined as follows:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domain`是底层IRQ芯片的IRQ域，`ops`设置为`regmap_domain_ops`，定义如下：'
- en: '[PRE40]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`irq` is the parent (base) IRQ for `irq_chip`. It corresponds to the `irq`
    parameter given to `devm_regmap_add_irq_chip()`.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq`是`irq_chip`的父（基本）IRQ。它对应于给定给`devm_regmap_add_irq_chip()`的`irq`参数。'
- en: Regmap IRQ API
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Regmap IRQ API
- en: 'Earlier in the chapter, we introduced both `devm_regmap_add_irq_chip()` and
    `regmap_irq_get_virq()` as two essential functions the regmap IRQ API is made
    of. These are actually the most important functions for regmap IRQ management
    and the following are their respective prototypes:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们介绍了`devm_regmap_add_irq_chip()`和`regmap_irq_get_virq()`作为regmap IRQ
    API的两个基本函数。这些实际上是regmap IRQ管理中最重要的函数，以下是它们各自的原型：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, `dev` is the device pointer to which `irq_chip` belongs.
    `map` is a valid and initialized regmap for the device. `irq_base`, if more than
    zero, will be the number of the first allocated IRQ. `chip` is the configuration
    for the interrupt controller. In the prototype of `regmap_irq_get_virq()`, `*data`
    is an initialized input parameter that must have been returned by `devm_regmap_add_irq_chip()`
    through `**data`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`dev`是`irq_chip`所属的设备指针。`map`是设备的有效和初始化的regmap。`irq_base`，如果大于零，将是第一个分配的IRQ的编号。`chip`是中断控制器的配置。在`regmap_irq_get_virq()`的原型中，`*data`是一个初始化的输入参数，必须通过`devm_regmap_add_irq_chip()`通过`**data`返回。
- en: '`devm_regmap_add_irq_chip()` is the function you should use to add regmap-based
    irqchip support in the code. Its `data` parameter is an output argument that represents
    the runtime data structure for the controller, allocated at the success of this
    function call. Its `irq` argument is the parent and primary IRQ for the irqchip.
    It is the IRQ the device uses to signal interrupts, while `irq_flags` is a mask
    of `IRQF_` flags to use for this primary interrupt. If this function succeeds
    (that is, returns `0`), then output data will be set with a fresh allocated and
    well-configured structure of type `regmap_irq_chip_data`. This function returns
    `errno` on failure. `devm_regmap_add_irq_chip()` is a combination of the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`devm_regmap_add_irq_chip()`是您应该在代码中使用以添加基于regmap的irqchip支持的函数。它的`data`参数是一个输出参数，表示在此函数调用成功时分配的控制器的运行时数据结构。它的`irq`参数是irqchip的父和主要IRQ。这是设备用于发出中断信号的IRQ，而`irq_flags`是用于此主要中断的`IRQF_`标志的掩码。如果此函数成功（即返回`0`），则输出数据将设置为类型为`regmap_irq_chip_data`的新分配和配置良好的结构。此函数在失败时返回`errno`。`devm_regmap_add_irq_chip()`是以下内容的组合：'
- en: Allocating and initializing `struct regmap_irq_chip_data`.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配和初始化`struct regmap_irq_chip_data`。
- en: '`irq_domain_add_linear()` (if `irq_base == 0`), which allocates an IRQ domain
    given the number of IRQs needed in the domain. On success, the IRQ domain will
    be assigned to the `.domain` field of the previously allocated IRQ chip’s data.
    This domain’s `ops.map` function will configure each IRQ child as nested into
    the parent thread, and `ops.xlate` will be set to `irq_domain_xlate_onetwocell`.
    If `irq_base > 0`, `irq_domain_add_legacy()` is used instead of `irq_domain_add_linear()`.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_domain_add_linear()`（如果`irq_base == 0`），它根据域中所需的IRQ数量分配一个IRQ域。成功后，IRQ域将分配给先前分配的IRQ芯片数据的`.domain`字段。此域的`ops.map`函数将配置每个IRQ子作为嵌套到父线程中，`ops.xlate`将设置为`irq_domain_xlate_onetwocell`。如果`irq_base
    > 0`，则使用`irq_domain_add_legacy()`而不是`irq_domain_add_linear()`。'
- en: '`request_threaded_irq()`, in order to register the parent IRQ thread handler.
    Regmap uses its own defined threaded handler, `regmap_irq_thread()`, which does
    some hacks prior to calling `handle_nested_irq()` on the child `irqs`.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request_threaded_irq()`，以注册父IRQ线程处理程序。Regmap使用其自定义的线程处理程序`regmap_irq_thread()`，在调用子`irqs`上的`handle_nested_irq()`之前进行一些修改。'
- en: 'The following is an excerpt that summarizes the preceding actions:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是总结前述操作的摘录：
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`regmap_irq_get_virq()` maps an interrupt on a chip to a virtual IRQ. It simply
    returns `irq_create_mapping(data->domain, irq)` on the given `irq` and domain,
    as we saw earlier. Its `irq` parameter is the index of the interrupt requested
    in the chip IRQs.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`regmap_irq_get_virq()`将芯片上的中断映射到虚拟IRQ。它只是在给定的`irq`和域上返回`irq_create_mapping(data->domain,
    irq)`，就像我们之前看到的那样。它的`irq`参数是在芯片IRQs中请求的中断的索引。'
- en: Regmap IRQ API example
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Regmap IRQ API示例
- en: Let’s use the `max7760` GPIO controller’s driver to see how the concepts behind
    the regmap IRQ API are applied. This driver is located at `drivers/gpio/gpio-max77620.c`
    in the kernel source, and the following is a simplified excerpt of the way this
    driver uses regmap to handle IRQ management.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`max7760` GPIO控制器的驱动程序来看看regmap IRQ API背后的概念是如何应用的。此驱动程序位于内核源中的`drivers/gpio/gpio-max77620.c`，以下是此驱动程序使用regmap处理IRQ管理的简化摘录。
- en: 'Let’s start by defining the data structure that will be used throughout the
    writing of the code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先定义将在编写代码期间使用的数据结构：
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The meaning of the preceding data structure will become clear when you go through
    the code. Next, let’s define our regmap IRQs array, as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当您阅读代码时，上述数据结构的含义将变得清晰。接下来，让我们定义我们的regmap IRQ数组，如下所示：
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You may have noticed the array has been truncated for the sake of readability.
    This array can then be assigned to the `regmap_irq_chip` data structure, as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到为了可读性而对数组进行了截断。然后，可以将此数组分配给`regmap_irq_chip`数据结构，如下所示：
- en: '[PRE45]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To summarize the preceding excerpts, the driver fills an array (`max77620_gpio_irqs[]`
    ) of `regmap_irq` and uses it to build a `regmap_irq_chip` structure (`max77620_gpio_irq_chip`).
    Once the `regmap_irq_chip` data structure is ready, we start writing an `irqchip`
    callback, as required by the kernel `gpiochip` core:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 总结前述摘录，驱动程序填充了一个`regmap_irq`数组（`max77620_gpio_irqs[]`），并使用它来构建一个`regmap_irq_chip`结构（`max77620_gpio_irq_chip`）。一旦`regmap_irq_chip`数据结构准备就绪，我们开始编写一个`irqchip`回调，这是内核`gpiochip`核心所需的：
- en: '[PRE46]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the preceding snippet, we have only defined the callback that will be assigned
    to the `.to_irq` field of the GPIO chip. Other callbacks can be found in the original
    driver. Again, the code has been truncated here. At this stage, we can talk about
    the `probe` method, which will use all of the previously defined functions:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述片段中，我们只定义了将分配给GPIO芯片的`.to_irq`字段的回调。其他回调可以在原始驱动程序中找到。再次强调，此处的代码已被截断。在这个阶段，我们可以谈论`probe`方法，它将使用之前定义的所有函数：
- en: '[PRE47]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this `probe` method excerpt (which has no error checks), `max77620_gpio_irq_chip`
    is finally given to `devm_regmap_add_irq_chip` in order to populate the irqchip
    with IRQs and then add the IRQ chip to the regmap core. This function also sets
    `chip->gpio_irq_data` with a valid `regmap_irq_chip_data` structure, and `chip`
    is the private data structure allowing us to store this IRQ chip data for later
    use. Since this IRQ controller is built on top of a GPIO controller (`gpiochip`),
    the `gpio_chip.to_irq` field had to be set, and here it is the `max77620_gpio_to_irq`
    callback. This callback simply returns the value returned by `regmap_irq_get_virq()`,
    which creates and returns a valid `irq` mapping in `regmap_irq_chip_data.domain`
    according to the offset given as a parameter. The other functions have already
    been introduced and are not new for us.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个“probe”方法摘录中（没有错误检查），`max77620_gpio_irq_chip`最终被提供给`devm_regmap_add_irq_chip`，以便用IRQ填充irqchip，然后将IRQ芯片添加到regmap核心。这个函数还使用一个有效的`regmap_irq_chip_data`结构设置了`chip->gpio_irq_data`，而`chip`是私有数据结构，允许我们存储这个IRQ芯片数据以供以后使用。由于这个IRQ控制器是建立在GPIO控制器（`gpiochip`）之上的，所以必须设置`gpio_chip.to_irq`字段，这里就是`max77620_gpio_to_irq`回调函数。这个回调函数简单地返回`regmap_irq_get_virq()`返回的值，后者根据给定的偏移量在`regmap_irq_chip_data.domain`中创建并返回一个有效的`irq`映射。其他函数已经被介绍过，对我们来说并不新鲜。
- en: In this section, we introduced the entirety of IRQ management using regmap.
    You are ready to move your MMIO-based IRQ management to regmap.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了使用regmap进行完整的IRQ管理。你已经准备好将基于MMIO的IRQ管理迁移到regmap。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter essentially dealt with regmap core. We introduced the framework,
    walked through its APIs, and described some use cases. Apart from register access,
    we have also learned how to use regmap for MMIO-based IRQ management. The next
    chapter, which deals with MFD devices and the syscon framework, will make intense
    use of the concepts learned in this chapter. By the end of this chapter, you should
    be able to develop regmap-enabled IRQ controllers, and you won’t find yourself
    reinventing the wheel and leveraging this framework for register access.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章主要涉及regmap核心。我们介绍了这个框架，走过了它的API，并描述了一些用例。除了寄存器访问，我们还学会了如何使用regmap进行基于MMIO的IRQ管理。下一章将涉及MFD设备和syscon框架，将大量使用本章学到的概念。在本章结束时，你应该能够开发支持regmap的IRQ控制器，并且不会发现自己在为寄存器访问重新发明轮子并利用这个框架。
