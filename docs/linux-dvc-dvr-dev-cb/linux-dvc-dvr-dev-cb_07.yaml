- en: Advanced Char Driver Operations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级字符驱动程序操作
- en: In previous chapters, we learned several useful things that can be handy in
    device driver development; however, a final step is needed. We must see how to
    add advanced functionalities to our character device and fully understand how
    we can synchronize user space processes with the peripheral I/O activity.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学到了一些在设备驱动程序开发中很有用的东西；然而，还需要一步。我们必须看看如何为我们的字符设备添加高级功能，并充分理解如何将用户空间进程与外围I/O活动同步。
- en: 'In this chapter, we''ll see how to implement system calls for the `lseek()`,
    `ioctl()`, and `mmap()` functions, and we''ll also get to know several techniques
    to put a process to sleep, just in case our peripheral does not yet have data
    to return to it; therefore, in this chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何为`lseek()`、`ioctl()`和`mmap()`函数实现系统调用，并且我们还将了解几种技术来使进程进入睡眠状态，以防我们的外围设备尚未有数据返回；因此，在本章中，我们将涵盖以下配方：
- en: Going up and down within a file with lseek()
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件中上下移动lseek()
- en: Using ioctl() for custom commands
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ioctl()进行自定义命令
- en: Accessing I/O memory with mmap()
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用mmap()访问I/O内存
- en: Locking with the process context
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与进程上下文锁定
- en: Locking (and syncing) with the interrupt context
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定（和同步）中断上下文
- en: Waiting for I/O operations with poll() and select()
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用poll()和select()等待I/O操作
- en: Managing asynchronous notifications with fasync()
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用fasync()管理异步通知
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Please check the appendix section of this chapter for more information.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请查看本章的附录部分。
- en: The code and other files used in this chapter can be downloaded from GitHub
    at [https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_07](https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_07).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码和其他文件可以从GitHub上下载，网址为[https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_07](https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_07)。
- en: Going up and down within a file with lseek()
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在文件中上下移动lseek()
- en: In this recipe, we're going to take a better look at how we can manipulate the `ppos` pointer (described
    in the *Exchanging data with a char driver* recipe in [Chapter 3](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml), *W**orking
    with Char Drivers*), which is related to the `read()` and `write()` system call
    implementations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将更仔细地看一下如何操纵`ppos`指针（在[第3章](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml)中的*与字符驱动程序交换数据*配方中描述），这与`read()`和`write()`系统调用的实现有关。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To provide a simple example about `lseek()` implementation, we can reuse our
    `chrdev` driver in [Chapter 4](5f22a69e-e8b7-402e-8e67-72938d00c914.xhtml), *Using
    the Device Tree* in the `chapter_04/chrdev `directory (we need both of the  `chrdev.c`
    and `chrdev-req.c` files of GitHub repository), where we can simply add our custom
    `llseek()` method according to our device memory layout.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供`lseek()`实现的一个简单示例，我们可以在[第4章](5f22a69e-e8b7-402e-8e67-72938d00c914.xhtml)中的`chapter_04/chrdev`目录中重用我们的`chrdev`驱动程序（我们需要GitHub存储库的`chrdev.c`和`chrdev-req.c`文件），在那里我们可以根据我们的设备内存布局简单地添加我们的自定义`llseek()`方法。
- en: For simplicity, I just copied these files in the `chapter_07/chrdev/` directory,
    and reworked them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我只是将这些文件复制到`chapter_07/chrdev/`目录中，并对其进行了重新处理。
- en: We also need to modify the ESPRESSObin's DTS file as we did in chapter 4 with
    the  `chapter_04/chrdev/add_chrdev_devices.dts.patch `file in order to enable
    the chrdev device, and then, finally, we can reuse the  `chrdev_test.c` program created
    in [Chapter 3](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml), *Working with Char
    Drivers* within the `chapter_03/chrdev_test.c` file as a base program for our `lseek()` implementation
    testing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改ESPRESSObin的DTS文件，就像我们在第4章中使用`chapter_04/chrdev/add_chrdev_devices.dts.patch`文件一样，以启用chrdev设备，然后最后，我们可以重用[第3章](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml)中创建的`chrdev_test.c`程序，作为我们的`lseek()`实现测试的基本程序。
- en: 'Regarding the ESPRESSObin''s DTS file, we can patch it by going in the kernel
    sources and then executing the `patch` command, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 关于ESPRESSObin的DTS文件，我们可以通过进入内核源并执行`patch`命令来修补它，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then, we have to recompile the kernel and reinstall it with the preceding DTS
    as we did in [Chapter 1](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml), I*nstalling
    the Development System*, and, finally, reboot the system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须重新编译内核，并像我们在[第1章](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml)中所做的那样，使用前述的DTS重新安装内核，最后，重新启动系统。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how to do it by following these steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过以下步骤来做到这一点：
- en: 'First, we can simply redefine `struct file_operations` by adding our  `chrdev_llseek` method:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以通过添加我们的`chrdev_llseek`方法来简单地重新定义`struct file_operations`：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we define the method''s body by using a big switch, where the `SEEK_SET`, `SEEK_CUR`,
    and `SEEK_END` possible values are managed, according to the memory layout of
    the driver:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过使用一个大开关来定义方法的主体，根据驱动程序的内存布局来处理`SEEK_SET`、`SEEK_CUR`和`SEEK_END`可能的值：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we have to verify that `newppos` is still between 0 and `BUF_LEN`
    and, in a positive case, we have to update `filp->f_pos` with the `newppos` value
    as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须验证`newppos`是否仍在0和`BUF_LEN`之间，并且在肯定的情况下，我们必须更新`filp->f_pos`为`newppos`值，如下所示：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the new version of the `chrdev.c` driver can be retrieved from GitHub
    sources within the `chapter_07/` directory related to this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，可以从GitHub源中的`chapter_07/`目录中检索到`chrdev.c`驱动程序的新版本，该目录与本章相关。
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 2*, we should remember that we have a memory buffer of `BUF_LEN` bytes
    per device, so we can compute the new `newppos` position within the device by
    simply executing some simple operations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们应该记住每个设备有一个`BUF_LEN`字节的内存缓冲区，因此我们可以通过执行一些简单的操作来计算设备内的新`newppos`位置。
- en: So, for `SEEK_SET`, which sets `ppos` to `offset`, we can simply perform an
    assignment; for `SEEK_CUR`, which moves `ppos` from its current location (which
    is `filp->f_pos`) plus `offset` bytes, we execute a sum; and, finally, for `SEEK_END`,
    which set `ppos` to the end of the file plus `offset` bytes, we still perform
    a sum with the  `BUF_LEN` buffer size since we are expecting a negative value
    or zero from the userspace.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于`SEEK_SET`，将`ppos`设置为`offset`，我们可以简单地执行赋值操作；对于`SEEK_CUR`，将`ppos`从其当前位置（即`filp->f_pos`）加上`offset`字节，我们执行求和操作；最后，对于`SEEK_END`，将`ppos`设置为文件末尾加上`offset`字节，我们仍然执行与`BUF_LEN`缓冲区大小的求和操作，因为我们期望从用户空间得到负值或零。
- en: There's more...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you wish to test the `lseek()` system call now, we can modify the `chrdev_test.c`
    program as reported previously, and then try to execute it on our new driver version.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在希望测试`lseek()`系统调用，我们可以修改之前报告的`chrdev_test.c`程序，然后尝试在我们的新驱动程序版本上执行它。
- en: 'So, let''s modify chrdev_test.c using the `modify_lseek_to_chrdev_test.patch` file,
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们使用`modify_lseek_to_chrdev_test.patch`文件修改`chrdev_test.c`，如下所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, we have to recompile it as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须重新编译它，如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that this command can be executed in the ESPRESSObin by simply removing
    the `CC=aarch64-linux-gnu-gcc` setting.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，可以通过简单地删除`CC=aarch64-linux-gnu-gcc`设置在ESPRESSObin上执行此命令。
- en: 'Then we have to move both the new `chrdev_test` executable and the `chrdev.ko`
    (the one with `lseek()` support) and `chrdev-req.ko` kernel modules on the ESPRESSObin,
    and then insert them into the kernel:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将新的`chrdev_test`可执行文件和具有`lseek()`支持的`chrdev.ko`（以及`chrdev-req.ko`内核模块）移动到ESPRESSObin，然后将它们插入内核：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This output is from a serial console, so we also get kernel messages. If you
    execute these commands over an SSH connection, you'll get no output and you will
    have to use the `dmesg` command to get an output in the preceding example.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出来自串行控制台，因此我们也会得到内核消息。如果您通过SSH连接执行这些命令，您将得不到输出，您将不得不使用`dmesg`命令来获取前面示例中的输出。
- en: 'Finally, we can execute the `chrdev_test` program on one chrdev device, as
    shown in the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在一个chrdev设备上执行`chrdev_test`程序，如下所示：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As expected, the `lseek()` system call invokes the driver''s `chrdev_llseek()` method, which
    does what we expect. The kernel messages related to the preceding command are
    reported as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，`lseek()`系统调用调用了驱动程序的`chrdev_llseek()`方法，这正是我们所期望的。与前述命令相关的内核消息如下所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, `ppos` moved from byte 0 to byte 11 when the first `write()` system call
    is executed, then it moves back to 0 thanks to `lseek()`, and, finally, it moves
    again to 11 due to the execution of the `read()` system call.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当第一个`write()`系统调用执行时，`ppos`从字节0移动到字节11，然后由于`lseek()`的作用又移回到0，最后由于`read()`系统调用的执行又移动到11。
- en: 'Note that we can also invoke the `lseek()` method using the `dd` command, as
    follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还可以使用`dd`命令调用`lseek()`方法，如下所示：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we open the device, then we move `ppos` 11 bytes forward from the beginning,
    and then we do three 1-byte length reads for each.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们打开设备，然后将`ppos`从开头向前移动11个字节，然后对每个进行三次1字节长度的读取。
- en: 'In the following kernel messages, we can verify that the  `dd` program behaves
    exactly as expected:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下内核消息中，我们可以验证`dd`程序的行为与预期完全一致：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: See also
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For further information about the `lseek()` system call, a good starting point
    is its man page, which can be obtained by using the `man 2 lseek` command.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`lseek()`系统调用的更多信息，一个很好的起点是它的man页面，可以使用`man 2 lseek`命令获取。
- en: Using ioctl() for custom commands
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ioctl()进行自定义命令
- en: In this recipe, we will see how to add custom commands to configure or manage
    our peripheral in a very customized manner.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将看到如何以非常定制的方式添加自定义命令来配置或管理我们的外围设备。
- en: Getting ready
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作完成
- en: Now, in order to present a simple example about how we can implement an `ioctl()`
    system call within our driver, we can still use the chrdev driver presented earlier,
    where we add the `unlocked_ioctl()` method, as explained later.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了展示如何在我们的驱动程序中实现`ioctl()`系统调用的简单示例，我们仍然可以使用之前介绍的chrdev驱动程序，在其中添加`unlocked_ioctl()`方法，如后面所述。
- en: How to do it...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how to do it by following these steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤来做：
- en: 'First of all, we have to add the `unlocked_ioctl()` method within the  `chrdev_fops`
    structure:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须在`chrdev_fops`结构中添加`unlocked_ioctl()`方法：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we add the method''s body where, at the beginning, we did some assignments
    and checks as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加方法的主体，在开始时，我们进行了一些赋值和检查，如下所示：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we can implement a big switch to execute the requested command, as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以实现一个大开关来执行请求的命令，如下所示：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For the last step, we have to define the `chrdev_ioctl.h` include file to be
    shared with the user space, holding the `ioctl()` commands defined in the preceding
    code block:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一步中，我们必须定义`chrdev_ioctl.h`包含文件，以便与用户空间共享，其中包含在前面的代码块中定义的`ioctl()`命令：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 2*, the `info`, `uarg`, and `iuarg` variables will be used, while the
    usage of the  `_IOC_TYPE()` macro is to verify that the `cmd` command was effective
    for our driver by checking the command's type against the  `CHRDEV_IOCTL_BASE` definition.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，将使用`info`、`uarg`和`iuarg`变量，而使用`_IOC_TYPE()`宏是为了通过检查命令的类型与`CHRDEV_IOCTL_BASE`定义相比较来验证`cmd`命令对我们的驱动程序是否有效。
- en: A careful reader should note that this check is not fault-proof due to the fact
    that a command's type is just a random number; however, it can be enough for our
    purposes here.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 细心的读者应该注意，由于命令类型只是一个随机数，因此此检查并不是绝对可靠的；但是，对于我们在这里的目的来说可能已经足够了。
- en: Also, by using `_IOC_NR()`, `_IOC_SIZE()`, and `_IOC_DIR()`, we can extract other
    information from the command, which can be useful for further checks.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过使用`_IOC_NR()`、`_IOC_SIZE()`和`_IOC_DIR()`，我们可以从命令中提取其他信息，这对进一步的检查可能有用。
- en: In *step 3*, as we can see for each command, according to the fact it's a reading
    or writing (or both) command, we have to get, or put, user data from the user
    space by utilizing the proper access functions, as explained in [Chapter 3](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml), *W**orking
    with Char Drivers,* in order to avoid memory corruption!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们可以看到对于每个命令，根据它是读取还是写入（或两者），我们必须通过使用适当的访问函数从用户空间获取或放置用户数据，如[第3章](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml)中所解释的那样，*使用字符驱动程序*，以避免内存损坏！
- en: Now it should be also clear how the `info`, `uarg`, and `iuarg` variables are
    used. The first is used to locally store `struct chrdev_info` data, while the
    others are used to have properly typed data to be used with the `copy_to_user()` or `get_user()` functions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该清楚`info`、`uarg`和`iuarg`变量是如何使用的。第一个用于本地存储`struct chrdev_info`数据，而其他变量用于具有适当类型的数据，以便与`copy_to_user()`或`get_user()`函数一起使用。
- en: There's more...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To test the code and see how it behaves, we need to realize a proper tool that
    executes our new `ioctl()` commands.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试代码并查看其行为，我们需要制作一个适当的工具来执行我们的新`ioctl()`命令。
- en: 'An example is provided in the `chrdev_ioctl.c` file, and in the following snippet,
    where the `ioctl()` calls are used:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`chrdev_ioctl.c`文件中提供了一个示例，并在下面的片段中使用了`ioctl()`调用：'
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s compile the `chrdev_ioctl.c` program by using the next command
    line on our host PC:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在主机PC上使用下一个命令行编译`chrdev_ioctl.c`程序：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that this command can also be executed in the ESPRESSObin by simply removing
    the  `CC=aarch64-linux-gnu-gcc` setting.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个命令也可以在ESPRESSObin上执行，只需删除`CC=aarch64-linux-gnu-gcc`设置。
- en: 'Now, if we try to execute the command on a chrdev device, we should get the
    following output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试在chrdev设备上执行该命令，我们应该得到以下输出：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Of course, for this to work, we'll have already loaded this new chrdev driver's
    version containing the `ioctl()` method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了使其工作，我们将已经加载了包含`ioctl()`方法的新chrdev驱动程序版本。
- en: 'While on the kernel messages we should get the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核消息中，我们应该得到以下内容：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As we can see, after the device opening, two `ioctl()` commands are executed
    as expected.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在设备打开后，两个`ioctl()`命令按预期执行。
- en: See also
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For further information about the `ioctl()` system call, a good starting point
    is its man page, which can be obtained by using the `man 2 ioctl` command.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`ioctl()`系统调用的更多信息，一个很好的起点是它的man页面，可以使用`man 2 ioctl`命令获得。
- en: Accessing I/O memory with mmap()
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用mmap()访问I/O内存
- en: In this recipe, we will see how to map an I/O memory region within the process
    memory space to gain access to our peripheral's internal by simply using a pointer
    in memory.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何映射一个I/O内存区域到进程内存空间，以便通过内存中的指针访问我们的外围设备内部。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Now, let's see how we can implement a custom `mmap()` system call for our chrdev
    driver.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何为我们的chrdev驱动程序实现自定义的`mmap()`系统调用。
- en: Since we have a virtual device totally mapped into memory, we may suppose that
    the `buf` buffer within `struct chrdev_device` represents the memory areas to
    be mapped. Also, we need to dynamically allocate it for it to be remapped; this
    is due to the fact that kernel virtual memory addresses cannot be remapped using
    the `remap_pfn_range()` function.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有一个完全映射到内存中的虚拟设备，我们可以假设`struct chrdev_device`中的`buf`缓冲区代表要映射的内存区域。此外，我们需要动态分配它以便重新映射；这是因为内核虚拟内存地址不能使用`remap_pfn_range()`函数重新映射。
- en: This is the only limitation of `remap_pfn_range()`, which is unable to remap
    the kernel virtual memory addresses that are not dynamically allocated. These
    addresses can be remapped too, but by using another technique not covered in this
    book.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`remap_pfn_range()`的唯一限制，它无法重新映射未动态分配的内核虚拟内存地址。这些地址也可以重新映射，但是使用本书未涵盖的另一种技术。
- en: 'To prepare our driver, we must make the following modifications to `struct
    chrdev_device`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备我们的驱动程序，我们必须对`struct chrdev_device`进行以下修改：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that we also modified the buffer size to be at least a `PAGE_SIZE` long
    due to the fact we cannot remap memory areas shorter than the `PAGE_SIZE` bytes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还修改了缓冲区大小，至少为`PAGE_SIZE`长，因为我们不能重新映射小于`PAGE_SIZE`字节的内存区域。
- en: 'Then, to dynamically allocate the memory buffer, we have to make the modifications
    listed as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了动态分配内存缓冲区，我们必须进行以下列出的修改：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here is the continuation of the preceding `diff` file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面`diff`文件的延续：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: However, apart from this little note, we can proceed as we did previously, that
    is, by modifying our chrdev driver and adding the new method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了这个小注释，我们可以像之前一样继续，即修改我们的chrdev驱动程序并添加新的方法。
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how to do it by following these steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤来做：
- en: 'Again, as in previous sections, the first step is adding our new `mmap()` method
    to the driver''s `struct file_operations`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与前几节一样，第一步是将我们的新`mmap()`方法添加到驱动程序的`struct file_operations`中：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we add the `chrdev_mmap()` implementation, as explained in the previous
    section and reported in the following:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加`chrdev_mmap()`实现，如前一节中所解释的并在下面报告：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we must get the physical address of the `buf` buffer:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须获取`buf`缓冲区的物理地址：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that this step won't be needed if we simply wanted to remap the physical
    address on which our peripheral is mapped.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们只想重新映射外围设备映射的物理地址，则不需要这一步。
- en: 'Finally, we can do the remap:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以进行重新映射：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 2*, the function begins with some sanity checks in which we must verify
    that the memory region requested is compatible with the system and peripheral
    requirements. In our example, we must verify that the size of the memory region
    and the offset within it, and where the map starts from, are within the `buf` size,
    which is `BUF_LEN` bytes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，函数从一些健全性检查开始，我们必须验证所请求的内存区域是否与系统和外围设备的要求兼容。在我们的示例中，我们必须验证内存区域的大小和偏移量，以及映射开始的位置是否在`buf`的大小（`BUF_LEN`字节）内。
- en: There's more...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'To test our new `mmap()` implementation, we can use the  `chrdev_mmap.c` program introduced
    earlier. where we talked about `textfile.txt`. To compile it, we can use the following
    command on the host PC:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的新的`mmap()`实现，我们可以使用之前介绍的`chrdev_mmap.c`程序。在这里我们谈到了`textfile.txt`。要编译它，我们可以在主机PC上使用以下命令：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that this command can be executed in the ESPRESSObin by simply removing
    the `CC=aarch64-linux-gnu-gcc` setting.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，可以通过简单删除`CC=aarch64-linux-gnu-gcc`设置在ESPRESSObin中执行此命令。
- en: 'Now, let''s start by writing something in the driver:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始在驱动程序中写点东西：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The kernel messages are as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 内核消息如下：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, as expected, within our memory buffer we have the `textfile.txt` contents;
    in fact:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如预期的那样，在我们的内存缓冲区中有`textfile.txt`的内容；实际上：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we can try to execute the `chrdev_mmap`  program on our device to verify
    whether everything works well:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试在我们的设备上执行`chrdev_mmap`程序，以验证一切是否正常工作：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that we must be sure not to specify a size a value bigger than the device''s
    buffer size, which is 4,096 in our example. In fact, if we do the following, we
    get an error:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须确保不指定大于设备缓冲区大小的值，例如在我们的示例中为4,096。实际上，如果我们这样做，会出现错误：
- en: '**`./chrdev_mmap /dev/cdev-eeprom\@2 4097`**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**`./chrdev_mmap /dev/cdev-eeprom\@2 4097`**'
- en: '`file /dev/cdev-eeprom@2 opened`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`file /dev/cdev-eeprom@2 opened`'
- en: '`mmap: Invalid argument`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`mmap: Invalid argument`'
- en: This means we got it! Note that the  `chrdev_mmap` program (as `cp` and `cat`)
    works exactly the same on both usual files and on our char device.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们成功了！请注意，`chrdev_mmap`程序（如`cp`和`cat`）在通常文件和我们的字符设备上的工作完全相同。
- en: 'The kernel messages related to the `mmap()` execution are as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与`mmap()`执行相关的内核消息如下：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that, after the remap, the program doesn't execute any system calls to
    gain access to the data. This leads to the possibility of better performances
    in obtaining access to the device's data rather than the case where we needed
    to use the `read()` or `write()` system calls.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在重新映射之后，程序不执行任何系统调用来访问数据。这导致在获取对设备数据的访问权限时，可能会比我们需要使用`read()`或`write()`系统调用的情况下性能更好。
- en: 'We can also modify the buffer content by adding the optional argument, `0`,
    to the `chrdev_mmap` program, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过向`chrdev_mmap`程序添加可选参数`0`来修改缓冲区内容，如下所示：
- en: '[PRE32]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, when we read the buffer again using the `read()` system call with, `cat`
    command, we can see that the first character within the file has changed to 0 as
    expected:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们使用`read()`系统调用和`cat`命令再次读取缓冲区时，我们可以看到文件中的第一个字符已经按预期更改为0：
- en: '[PRE33]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: See also
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For further information regarding `mmap()`, a good starting point is its man
    page (`man 2 mmap`); then, looking at [https://linux-kernel-labs.github.io/master/labs/memory_mapping.html](https://linux-kernel-labs.github.io/master/labs/memory_mapping.html) would be
    even better.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`mmap()`的更多信息，一个很好的起点是它的man页面（`man 2 mmap`）；然后，查看[https://linux-kernel-labs.github.io/master/labs/memory_mapping.html](https://linux-kernel-labs.github.io/master/labs/memory_mapping.html)会更好。
- en: Locking with the process context
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用进程上下文进行锁定
- en: In this recipe, we will see how to protect data against the concurrent access
    of two or more processes to avoid race conditions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何保护数据，以防止两个或更多进程并发访问，以避免竞争条件。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: To present a simple example about how to add a mutex to the chrdev driver, we
    can make a few modifications to it, as reported in the following.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单地演示如何向chrdev驱动程序添加互斥体，我们可以对其进行一些修改，如下所示。
- en: 'First, we have to add the `mux` mutex to the driver''s main structure in the `chrdev.h` header
    file, as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须在`chrdev.h`头文件中的驱动程序主结构中添加`mux`互斥体，如下所示：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'All modifications presented here can be applied to the chrdev code using the
    `patch` command in the  `add_mutex_to_chrdev.patch` file, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍的所有修改都可以应用于chrdev代码，使用`add_mutex_to_chrdev.patch`文件中的`patch`命令，如下所示：
- en: '**`$ patch -p3 < add_mutex_to_chrdev.patch`**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**`$ patch -p3 < add_mutex_to_chrdev.patch`**'
- en: 'Then, in the `chrdev_device_register()` function, we have to initialize the
    mutex by using the `mutex_init()` function:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`chrdev_device_register()`函数中，我们必须使用`mutex_init()`函数初始化互斥体：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we can modify the `read()` and `write()` methods to protect them. The
    `read()` methods should then look like the following:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以修改`read()`和`write()`方法以保护它们。然后，`read()`方法应该如下所示：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `write()` method is reported as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`write()`方法报告如下：'
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we have to protect the `ioctl()` method too, since the driver''s  `read_only` property
    may change:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还必须保护`ioctl()`方法，因为驱动程序的`read_only`属性可能会改变：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is really a silly example, but you should consider the case where even
    the `ioctl()` method may change the data buffer or other shared data of the driver.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是一个愚蠢的例子，但你应该考虑即使`ioctl()`方法也可能改变驱动程序的数据缓冲区或其他共享数据的情况。
- en: This time, we removed all the `return` statements in favor of `goto`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们删除了所有的`return`语句，改用`goto`。
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: It's really hard to show how the code works by simply executing it, due to the
    intrinsic difficulties in reproducing a race condition, so it's better to discuss
    what we may expect from it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 展示代码的工作原理是非常困难的，因为在复制竞争条件时存在固有的困难，所以最好讨论一下我们可以从中期望什么。
- en: However, you are encouraged to test the code anyway, maybe by trying to write
    a more complex driver where the concurrency may be a real problem if not correctly
    managed by the use of mutexes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您仍然被鼓励测试代码，也许尝试编写一个更复杂的驱动程序，如果不正确地使用互斥体来管理并发，可能会成为一个真正的问题。
- en: In *step 1, *we added a mutex for each chrdev device we may have in the system.
    Then, after its initialization in *step 2*, we can effectively use it, as reported
    in *step 3* and *step 4.*
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，我们为系统中可能有的每个chrdev设备添加了一个互斥体。然后，在*步骤2*中初始化后，我们可以有效地使用它，如*步骤3*和*步骤4*中所述。
- en: By using the `mutex_lock()` function we are, in fact, telling the kernel that
    no other process may go concurrently beyond this point to ensure that just one
    process can manage the driver's shared data. If some other process should effectively
    try to acquire the mutex while it was already held by the first process, a new
    process will be put to sleep on a waiting queue at the exact moment it tries to
    acquire the already locked mutex.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`mutex_lock()`函数，实际上告诉内核没有其他进程可以在这一点之后并发地进行，以确保只有一个进程可以管理驱动程序的共享数据。如果其他进程确实尝试在第一个进程已经持有互斥锁的情况下获取互斥锁，新进程将在它尝试获取已锁定的互斥锁的确切时刻被放入等待队列中进入睡眠状态。
- en: When finished, by using `mutex_unlock()`, we instead inform the kernel that
    the `mux` mutex has been released, and so, any awaiting (that is, sleeping) processes
    will be awakened; then, once finally rescheduled to run again, it could proceed
    and try, in turn, to grab the lock.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，通过使用`mutex_unlock()`，我们通知内核`mux`互斥锁已被释放，因此，任何等待（即睡眠）的进程将被唤醒；然后，一旦最终重新调度运行，它可以继续并尝试，反过来，抓住锁。
- en: Please note that in *step 3*, in both functions, we grab the mutex when it's
    really useful to avoid race conditions and not at their beginning; in fact, we
    should try to keep the locking as small as possible in order to protect the shared
    data (in our example, the `ppos` pointer and the  `buf` data buffer). By doing
    this, we are restricting the usage of our chosen mutual exclusion mechanism to
    the smallest possible section of code (the critical section), which accesses the
    shared data we want to protect from possible corruption introduced by a race condition
    happening under the previously specified conditions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在*步骤3*中，在两个函数中，我们在真正有用的时候才抓住互斥锁，而不是在它们的开始；实际上，我们应该尽量保持锁定尽可能小，以保护共享数据（在我们的例子中，`ppos`指针和`buf`数据缓冲区）。通过这样做，我们将我们选择的互斥排除机制的使用限制在代码的最小可能部分（临界区），这个临界区访问我们想要保护免受在先前指定的条件下发生的竞争条件引入的可能破坏。
- en: Also, note that we must be careful not to return before releasing the lock,
    otherwise new accessing processes will hang! That's why we removed all the `return` statements
    but the last one and we used the `goto` statement to skip to the `unlock` label.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，我们必须小心，不要在释放锁之前返回，否则新的访问进程将挂起！这就是为什么我们删除了所有的`return`语句，除了最后一个，并且使用`goto`语句跳转到`unlock`标签。
- en: See also
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For further information regarding the mutexes and locking a good document, see
    the kernel documentation directory at `linux/Documentation/locking/mutex-design.txt`.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关互斥锁和锁定的更多信息，请参阅内核文档目录中的`linux/Documentation/locking/mutex-design.txt`。
- en: Locking (and syncing) with the interrupt context
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用中断上下文进行锁定（和同步）
- en: Now, let's see how we can avoid race conditions between the process context
    and the interrupt context. However, this time we must pay more attention than
    before because, this time, we must implement a locking mechanism to protect shared
    data between the process context and the interrupt context. However, we must also
    provide a syncing mechanism between the reading process and the driver too, to
    allow the reading process to proceed in its action if some data to be read is
    present within the driver's queues.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何避免进程上下文和中断上下文之间的竞争条件。然而，这一次我们必须比以前更加注意，因为这一次我们必须实现一个锁定机制来保护进程上下文和中断上下文之间的共享数据。但是，我们还必须为读取进程和驱动程序之间提供同步机制，以允许读取进程在驱动程序的队列中存在要读取的数据时继续执行其操作。
- en: To explain this problem, it is better to do a practical example. Let's suppose
    we have a peripheral that generates data for reading processes. To signal that
    new data has arrived, the peripheral sends an interrupt to the CPU, so we can
    imagine implementing our driver by using a circular buffer where the interrupt
    handler will save data from the peripheral into, and where any reading processes
    may get data from.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释这个问题，最好做一个实际的例子。假设我们有一个生成数据供读取进程使用的外围设备。为了通知新数据已到达，外围设备向CPU发送中断，因此我们可以想象使用循环缓冲区来实现我们的驱动程序，其中中断处理程序将数据从外围设备保存到缓冲区中，并且任何读取进程可以从中获取数据。
- en: Circular buffers (also known as ring buffers) are fixed-size buffers that work
    as if the memory is contiguous and all memory locations are handled in a circular
    manner. As the information is generated and consumed from the buffer, it does
    not need to be reshuffled; we simply adjust the head and tail pointers. When data
    is added, the head pointer advances, and while data is consumed, the tail pointer
    advances. If we reach the end of the buffer, then each pointer simply wraps around
    to pointing back to the beginning of the ring.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 循环缓冲区（也称为环形缓冲区）是固定大小的缓冲区，其工作方式就好像内存是连续的，所有内存位置都以循环方式处理。随着信息从缓冲区生成和消耗，不需要重新整理；我们只需调整头指针和尾指针。添加数据时，头指针前进，而消耗数据时，尾指针前进。如果到达缓冲区的末尾，那么每个指针都会简单地回到环的起始位置。
- en: In this scenario, we must protect the circular buffer against race conditions
    from both process and interrupt contexts since both get access to it, but we must also provide
    a syncing mechanism to put to sleep any reading process when no data is available
    for reading!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须保护循环缓冲区免受进程和中断上下文的竞争条件，因为两者都可以访问它，但我们还必须提供同步机制，以便在没有可供读取的数据时使任何读取进程进入睡眠状态！
- en: In [Chapter 5](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=30&action=edit#post_28), *Managing
    Interrupts and Concurrency*, we presented spinlocks, which can be used to place
    a locking mechanism between the process and interrupt context; we also presented
    waitqueues, which can be used to sync the reading processes with the interrupt
    handler.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=30&action=edit#post_28)中，*管理中断和并发*，我们介绍了自旋锁，它可以用于在进程和中断上下文之间放置锁定机制；我们还介绍了等待队列，它可以用于将读取进程与中断处理程序同步。
- en: Getting ready
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This time, we have to use a modified version of our chrdev driver. In the `chapter_07/chrdev/` directory of
    the GitHub repository, we can find the  `chrdev_irq.c` and `chrdev_irq.h` files, which
    implement our modified driver.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们必须使用我们chrdev驱动程序的修改版本。在GitHub存储库的`chapter_07/chrdev/`目录中，我们可以找到实现我们修改后的驱动程序的`chrdev_irq.c`和`chrdev_irq.h`文件。
- en: We can still use `chrdev-req.ko` to generate the chrdev devices within the system,
    but now the kernel module will be used `chrdev_irq.ko` instead of `chrdev.ko`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以使用`chrdev-req.ko`在系统中生成chrdev设备，但现在内核模块将使用`chrdev_irq.ko`而不是`chrdev.ko`。
- en: 'Also, since we have a real peripheral, we can simulate the IRQ using a kernel
    timer (see [Chapter 5](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=30&action=edit#post_28), *Managing
    Interrupts and Concurrency*), which also triggers data generation using the following  `get_new_char()` function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们有一个真正的外围设备，我们可以使用内核定时器来模拟IRQ（请参阅[第5章](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=30&action=edit#post_28)，*管理中断和并发性*），该定时器还使用以下`get_new_char()`函数触发数据生成：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This function simply generates a new character from A to Z each time it's called,
    restarting from character A after the generation of Z.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能每次调用时都会简单地从A到Z生成一个新字符，在生成Z后重新从字符A开始。
- en: 'Just to focus our attention to the locking and syncing mechanisms of our driver,
    we present here, some useful functions to manage the circular buffer, which is
    self-explanatory. Here are two functions to check the buffer is empty or full:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了集中精力关注驱动程序的锁定和同步机制，我们在这里介绍了一些有用的函数来管理循环缓冲区，这是不言自明的。以下是两个检查缓冲区是否为空或已满的函数：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then, there are two functions to check how much data or how many spaces are
    available until the end of the buffer''s memory area. They are useful for when
    we have to use functions such as `memmove()`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有两个函数来检查缓冲区的内存区域直到末尾有多少数据或多少空间可用。当我们必须使用`memmove()`等函数时，它们非常有用：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we can use function to properly move forward the head or tail pointer
    in such a way that it can restart from the beginning, whenever the end of the
    buffer is reached:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用函数正确地向前移动头部或尾部指针，以便在缓冲区末尾时重新开始：
- en: '[PRE42]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How to do it...
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how to do it by following these steps:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤来做：
- en: 'The first step is to rewrite our driver''s main structure by adding the `mux` mutex
    (as before), the  `lock` spinlock, the kernel `timer`, and the waitqueue `queue`
    as follows:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是通过添加`mux`互斥锁（与以前一样）、`lock`自旋锁、内核`timer`和等待队列`queue`来重写我们驱动程序的主要结构，如下所示：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, we have to initialize them during device allocation in the `chrdev_device_register()`
    function, as shown here:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`chrdev_device_register()`函数中进行设备分配期间必须对其进行初始化，如下所示：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, a possible implementation of the `read()` method is shown in the next
    snippet. We start by grabbing the mutex to do the first lock against other processes:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，`read()`方法的可能实现如下代码片段所示。我们首先获取互斥锁，以对其他进程进行第一次锁定：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now we are sure that no other process may go beyond this point, but some core
    running in the interrupt context can still do it!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以确信没有其他进程可以超越这一点，但是在中断上下文中运行的一些核心仍然可以这样做！
- en: 'That''s why we need the following step to ensure that they are synced with
    the interrupt context:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是为什么我们需要以下步骤来确保它们与中断上下文同步：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When we''ve grabbed the lock, we can be sure that we are the only reading process
    here and that we are protected from the interrupt context, too; therefore, we
    can safely proceed to read data from the circular buffer, and then release the
    lock as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们获取了锁时，我们可以确信我们是唯一的读取进程，并且我们也受到中断上下文的保护；因此，我们可以安全地从循环缓冲区读取数据，然后释放锁，如下所示：
- en: '[PRE47]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that we must copy data from the circular buffer to a local buffer and not
    directly into the user space buffer, `buf`, with the `copy_to_user()` function;
    this is because this function may go to sleep, and holding a spinlock while we
    are sleeping is evil!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须将数据从循环缓冲区复制到本地缓冲区，而不是直接复制到用户空间缓冲区`buf`，使用`copy_to_user()`函数；这是因为此函数可能会进入睡眠状态，而在我们睡眠时持有自旋锁是不好的！
- en: 'Once the spinlock has been released, we can safely call `copy_to_user()` to
    send data to the user space:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自旋锁释放后，我们可以安全地调用`copy_to_user()`将数据发送到用户空间：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, before releasing the mutex, we must update the circular buffer''s
    `tail` pointer as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在释放互斥锁之前，我们必须更新循环缓冲区的`tail`指针，如下所示：
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that since there are only readers in the process context, which are the
    only ones that move the `tail` pointer (or the interrupt handler does it—see the
    following snippet), we can be sure that everything will work well.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于在进程上下文中只有读取器，它们是唯一移动`tail`指针的进程（或者中断处理程序这样做——请参见下面的代码片段），我们可以确信一切都会正常工作。
- en: 'In the end, the interrupt handler (in our case, it''s simulated by a kernel
    timer handler) looks like the following:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，中断处理程序（在我们的情况下，它是由内核定时器处理程序模拟的）如下所示：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The handler''s body is simple: it grabs the lock and then it adds a single
    character to the circular buffer.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序的主体很简单：它获取锁，然后将单个字符添加到循环缓冲区。
- en: Note that, here, we simply drop data, due to the fact we have a real peripheral;
    in real cases, the driver developer may do whatever is needed to prevent data
    loss, for instance by stopping the peripheral and then signaling this error condition,
    in some way, to the user space!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这里，由于我们有一个真正的外围设备，我们只是丢弃数据；在实际情况下，驱动程序开发人员可能需要采取任何必要的措施来防止数据丢失，例如停止外围设备，然后以某种方式向用户空间发出此错误条件的信号！
- en: Also, before exiting, it uses the  `wake_up_interruptible()` function to awake
    possible sleeping processes on the waitqueue.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在退出之前，它使用`wake_up_interruptible()`函数唤醒等待队列上可能正在睡眠的进程。
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The steps are quite self-explanatory. However, in *step 4*, we perform two
    important steps: the first one is to suspend the process if the circular buffer
    is empty and, if not, to grab the lock with the interrupt context since we''re
    going to get access to the circular buffer.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤相当不言自明。但是，在*步骤4*中，我们执行了两个重要步骤：第一个是如果循环缓冲区为空，则挂起进程，如果不是，则使用中断上下文抓取锁，因为我们将要访问循环缓冲区。
- en: The check against the `O_NONBLOCK` flag is just to respect the `read()` behavior,
    which says that if the `O_NONBLOCK` flag is used, then it should go ahead, and
    then returns the `EAGAIN` error if no data is available.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对`O_NONBLOCK`标志的检查只是为了遵守`read()`的行为，即如果使用了`O_NONBLOCK`标志，那么它应该继续进行，然后如果没有数据可用，则返回`EAGAIN`错误。
- en: Note that the lock can be safely obtained before checking for buffer emptiness,
    due to the fact that if we decide that the buffer is empty, but some new data
    arrive in the meantime and `O_NONBLOCK` is active, we simply return `EAGAIN` (signaling
    to the reading process to redo the operation). If it is not, we go to sleep on
    the waitqueue and then we will be woken by the interrupt handler (see the following
    information). In both cases, our operations are correct.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在检查缓冲区是否为空之前，可以安全地获取锁，因为如果我们决定缓冲区为空，但同时到达了一些新数据并且`O_NONBLOCK`处于活动状态，我们只需返回`EAGAIN`（向读取进程发出重新执行操作的信号）。如果不是，我们会在等待队列上睡眠，然后会被中断处理程序唤醒（请参阅以下信息）。在这两种情况下，我们的操作都是正确的。
- en: There's more...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you wish to test the code, compile the code and insert it in the ESPRESSObin:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望测试代码，请编译代码并将其插入ESPRESSObin中：
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now our peripheral is enabled (the kernel timer has been enabled in *step 2* in
    the `chrdev_device_register()` function) and some data should already be available
    to be read; in fact, if we do a `read()` on the driver by using the `cat` command
    we get the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的外围设备已启用（内核定时器已在`chrdev_device_register()`函数中的*步骤2*中启用），并且应该已经有一些数据可供读取；实际上，如果我们通过使用`cat`命令在驱动程序上进行`read()`，我们会得到以下结果：
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we should notice that since we have defined two devices in the system
    (see the `chapter_04/chrdev/add_chrdev_devices.dts.patch` DTS file used at the
    beginning of this chapter) the  `get_new_char()` function is executed twice per
    second, and that's why we get the sequence `ACE...` instead of `ABC...`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应该注意，由于我们在系统中定义了两个设备（请参阅本章开头使用的`chapter_04/chrdev/add_chrdev_devices.dts.patch`
    DTS文件），因此`get_new_char()`函数每秒执行两次，这就是为什么我们得到序列`ACE...`而不是`ABC...`。
- en: A good exercise here would be to modify the driver to start the kernel timer
    when the driver is opened the first time, and then stop it when it is released
    the last time. Also, you may try to provide a per device `get_new_char()` function
    to generate the right sequence (ABC...) for each device within the system.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个很好的练习是修改驱动程序，当第一次打开驱动程序时启动内核定时器，然后在最后一次释放时停止它。此外，您可以尝试为每个系统中的设备提供一个每设备的`get_new_char()`函数来生成正确的序列（ABC...）。
- en: 'The corresponding kernel messages are reported as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的内核消息如下所示：
- en: '[PRE53]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, thanks to *step 3* to *step 7*, the `read()` system call puts to sleep
    the calling process and then returns the new data as soon as it arrives.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，由于*步骤3*到*步骤7*，`read()`系统调用使调用进程进入睡眠状态，然后一旦数据到达就立即返回新数据。
- en: 'In fact, if we wait a while, we see that we get a new character each second
    with the following kernel messages:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们等一会儿，我们会看到以下内核消息每秒获得一个新字符：
- en: '[PRE54]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: I left the timings to get an idea about the time when each message is generated.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我留下了时间，以便了解生成每条消息的时间。
- en: This behavior is due to *step 8*, where the kernel timer generates new data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是由*步骤8*引起的，内核定时器生成新数据。
- en: See also
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For further information regarding spinlocks and locking a good document, see
    the kernel documentation directory at `linux/Documentation/locking/spinlocks.txt`.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关自旋锁和锁定的更多信息，请参阅内核文档目录中的`linux/Documentation/locking/spinlocks.txt`。
- en: Waiting for I/O operations with poll() and select()
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用poll()和select()等待I/O操作
- en: In this recipe, we will find out how to ask to the kernel to check for us when
    our driver has new data to be read (or it's willing to accept new data to be written),
    and then to wake up the reading (or writing) process without the risk of being
    blocked on the I/O operation.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将了解如何要求内核在我们的驱动程序有新数据可供读取（或愿意接受新数据进行写入）时为我们检查，然后唤醒读取（或写入）进程，而不会在I/O操作上被阻塞。
- en: Getting ready
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: To test our implementation, we can still use the `chrdev_irq.c` driver as before;
    this is because we can use the *new data* event simulated by the kernel timer.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的实现，我们仍然可以像以前一样使用`chrdev_irq.c`驱动程序；这是因为我们可以使用内核定时器模拟的*新数据*事件。
- en: How to do it...
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how to do it by following these steps:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过以下步骤来做到这一点：
- en: 'First of all, we have to add our new `chrdev_poll()` method in the `struct
    file_operations` of our driver:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须在驱动程序的`struct file_operations`中添加我们的新`chrdev_poll()`方法：
- en: '[PRE55]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, the implementation is in the following. We start by passing to the `poll_wait()`
    function, the which is waitqueue of the current device `chrdev->queue`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，实现如下。我们首先通过将当前设备`chrdev->queue`的等待队列传递给`poll_wait()`函数：
- en: '[PRE56]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, before checking that the circular buffer isn''t empty and we can proceed
    to read data from it, we grab the mutex:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在检查循环缓冲区不为空并且我们可以继续从中读取数据之前，我们抓住互斥锁：
- en: '[PRE57]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that grabbing the spinlock, too, is not necessary. This is due to the fact
    that if the buffer is empty we will be informed when new data has arrived by the
    interrupt (the kernel timer in our simulation) handler. This will, in turn, call
    the `wake_up_interruptible(&chrdev->queue)`, which acts on the waitqueue we supplied
    earlier to the `poll_wait()` function. On the other hand, if the buffer is not
    empty, it cannot become empty by the interrupt context and then we cannot have
    any race conditions at all.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，抓取自旋锁也是不必要的。这是因为如果缓冲区为空，当新数据通过中断（在我们的模拟中是内核定时器）处理程序到达时，我们将得到通知。这将反过来调用`wake_up_interruptible(&chrdev->queue)`，它作用于我们之前提供给`poll_wait()`函数的等待队列。另一方面，如果缓冲区不为空，它不可能在中断上下文中变为空，因此我们根本不可能有任何竞争条件。
- en: There's more...
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As before, if we wish to test the code, we need to realize a proper tool that
    executes our new `poll()` method. When we add it within the driver, we get both
    the `poll()` and `select()` system call support; an example of the `select()`
    usage is reported in the `chrdev_select.c`  file and, in the following, there
    is a snippet in which the `select()` call is used:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，如果我们希望测试代码，我们需要实现一个适当的工具来执行我们的新`poll()`方法。当我们将其添加到驱动程序中时，我们将获得`poll()`和`select()`系统调用支持；`select()`的使用示例在`chrdev_select.c`文件中报告，在下面，有一个片段中使用了`select()`调用：
- en: '[PRE58]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As we can see, this program will monitor the standard input channel (named `stdin`)
    of our process and the character device by using the `select()` system call, which,
    in turn, calls our new `poll()` method implemented in *step 2* and *step 3*.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个程序将使用`select()`系统调用来监视我们进程的标准输入通道（名为`stdin`）和字符设备，`select()`系统调用又调用我们在*步骤2*和*步骤3*中实现的新`poll()`方法。
- en: 'Now, let''s compile the `chrdev_select.c` program by using the next command
    line on our host PC:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的主机PC上使用下一个命令行编译`chrdev_select.c`程序：
- en: '[PRE59]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note that this command can be executed in the ESPRESSObin by simply removing
    the  `CC=aarch64-linux-gnu-gcc` setting.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个命令可以通过简单地删除`CC=aarch64-linux-gnu-gcc`设置在ESPRESSObin上执行。
- en: 'Now, if we try to execute the command on a chrdev device, we should get this
    output:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试在chrdev设备上执行该命令，我们应该会得到这个输出：
- en: '[PRE60]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Of course, we'll have already loaded the `chrdev_irq` driver containing the `poll()` method.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们已经加载了包含`poll()`方法的`chrdev_irq`驱动程序。
- en: 'If we try to insert some characters from the standard input, as shown in the
    following, we can see that when there is new data from the device, the process
    can safely do a read on it without blocking, while when there is new data from
    its standard input, the process can do the same, also without blocking:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试从标准输入插入一些字符，如下所示，我们可以看到当设备有新数据时，进程可以安全地对其进行读取而不会阻塞，而当标准输入有新数据时，进程也可以做同样的事情，同样也不会阻塞：
- en: '[PRE61]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: See also
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For further information regarding `poll()` or `select()`, a good starting point
    is their man pages (`man 2 poll` and `man 2 select`).
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`poll()`或`select()`的更多信息，一个很好的起点是它们的man页面（`man 2 poll`和`man 2 select`）。
- en: Managing asynchronous notifications with fasync()
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`fasync()`管理异步通知
- en: In this recipe, we will see how we can generate asynchronous `SIGIO` signals
    whenever our driver has new data to be read (or it's willing to accept new data
    from the user space).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何在我们的驱动程序有新数据要读取时（或者愿意接受来自用户空间的新数据）生成异步的`SIGIO`信号。
- en: Getting ready
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As done previously, we can still present our implementation using the `chrdev_irq.c` driver.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们仍然可以使用`chrdev_irq.c`驱动程序来展示我们的实现。
- en: How to do it...
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how to do it by following these steps:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过以下步骤来做到：
- en: 'First of all, we have to add our new `chrdev_fasync()` method in the `struct
    file_operations` of our driver:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须在驱动程序的`struct file_operations`中添加我们的新`chrdev_fasync()`方法：
- en: '[PRE62]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The implementation is as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现如下：
- en: '[PRE63]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Finally, we have to add the `kill_fasync()` call into our (simulated) interrupt
    handler to signal that the signal `SIGIO` can be sent due to the fact that new
    data is ready to be read:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须在我们的（模拟的）中断处理程序中添加`kill_fasync()`调用，以表示由于有新数据准备好被读取，可以发送`SIGIO`信号：
- en: '[PRE64]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: There's more...
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you wish to test the code, you need to realize a proper tool that executes
    all of the steps presented to ask the kernel to receive the `SIGIO` signal. In
    the following, a snippet of the `chrdev_fasync.c` program is reported, which does
    what''s needed:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望测试代码，您需要实现一个适当的工具来执行所有步骤，以要求内核接收`SIGIO`信号。下面报告了`chrdev_fasync.c`程序的片段，其中执行了所需的操作：
- en: '[PRE65]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This code is needed to ask the kernel to invoke the `fasync()` method implemented
    in *step 2*. Then, whenever new data arrives, thanks to *step 3*, the  `SIGIO` signal is
    sent to our process and the signal handler, `sigio_handler()`, is executed, even
    if the process is suspended, for example, on reading another file descriptor.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是要求内核调用我们在*步骤2*中实现的`fasync()`方法。然后，每当有新数据到达时，由于*步骤3*，`SIGIO`信号将发送到我们的进程，并且信号处理程序`sigio_handler()`将被执行，即使进程被挂起，例如，在读取另一个文件描述符时。
- en: '[PRE66]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, let''s compile the `chrdev_fasync.c` program by using the next command
    line on our host PC:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的主机PC上使用下一个命令行编译`chrdev_fasync.c`程序：
- en: '[PRE67]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note that this command can be executed in the ESPRESSObin by simply removing
    the  `CC=aarch64-linux-gnu-gcc` setting.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个命令可以通过简单地删除`CC=aarch64-linux-gnu-gcc`设置在ESPRESSObin上执行。
- en: 'Now, if we try to execute the command on a chrdev device, we should get the
    following output:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试在chrdev设备上执行该命令，我们应该会得到以下输出：
- en: '[PRE68]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Of course, we'll have already loaded the `chrdev_irq` driver containing the `fasync()` method.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们已经加载了包含`fasync()`方法的`chrdev_irq`驱动程序。
- en: 'Here, the process is suspended on a `read()` on the stdin and whenever a signal
    arrives, the signal handler is executed and the new data is read. However, when
    we try to send some characters to the standard input, the process reads them as
    expected:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，进程在标准输入上的`read()`上被挂起，每当信号到达时，信号处理程序被执行并且新数据被读取。然而，当我们尝试向标准输入发送一些字符时，进程会如预期地读取它们：
- en: '[PRE69]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: See also
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For further information regarding the `fasync()` method or the `fcntl()` system
    call, a good starting point is the `man 2 fcntl` man page.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`fasync()`方法或`fcntl()`系统调用的更多信息，一个很好的起点是`man 2 fcntl`手册页。
