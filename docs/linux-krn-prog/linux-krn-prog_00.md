# 前言

这本书明确地旨在帮助你以实际、动手的方式学习 Linux 内核开发，同时提供必要的理论背景，使你对这个广阔而有趣的主题有一个全面的了解。它有意地专注于通过强大的**可加载内核模块**（**LKM**）框架进行内核开发；绝大多数的内核项目和产品，包括设备驱动程序开发，都是以这种方式完成的。

重点放在实际操作和对 Linux 操作系统内部的深入理解上。在这方面，我们涵盖了从源代码构建 Linux 内核到理解和处理内核中的同步等复杂主题的方方面面。

为了指导你进行这激动人心的旅程，我们将这本书分为三个部分。第一部分涵盖了基础知识-设置内核开发所需的工作空间，从源代码构建内核，以及编写你的第一个内核模块。

接下来的一部分，一个关键部分，将帮助你理解重要和必要的内核内部- Linux 内核架构、任务结构以及用户和内核模式堆栈。内存管理是一个重要且有趣的主题-我们专门撰写了三整章来涵盖它（充分涵盖了内部内容，以及如何准确分配任何空闲内核内存）。Linux 上的 CPU 调度的工作和更深入的细节结束了这一部分。

本书的最后一部分涉及更高级的内核同步主题-这是 Linux 内核专业设计和编码的必要内容。我们专门撰写了两整章来涵盖这些关键主题。

本书使用了截至撰写时最新的 5.4 **长期支持**（**LTS**）Linux 内核。这是一个将从 2019 年 11 月一直维护（包括错误修复和安全修复）到 2025 年 12 月的内核！这是一个关键点，确保了本书的内容在未来多年仍然保持最新和有效！

我们非常相信实践：本书的 GitHub 仓库上有超过 20 个内核模块（以及几个用户应用程序和 shell 脚本），使学习变得生动、有趣和有用。

我们强烈建议你也使用本书的配套指南*Linux Kernel Programming (Part 2)*。

这是一本与行业接轨的初学者指南，涵盖了编写`misc`字符驱动程序、在外围芯片内存上执行 I/O 以及处理硬件中断。你可以免费获取这本书，同时也可以在 GitHub 仓库中找到这本电子书：[`github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/Linux-Kernel-Programming-(Part-2)`](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/Linux-Kernel-Programming-(Part-2))。

我们真诚地希望你能从这本书中学到东西并且享受阅读。祝阅读愉快！

# 这本书适合谁

这本书主要是为那些刚开始涉足 Linux 内核模块开发以及在一定程度上 Linux 设备驱动程序开发的人而写的。它也非常针对那些已经在 Linux 模块和/或驱动程序上工作的人，他们希望对 Linux 内核架构、内存管理和同步有更深入、结构良好的理解。这种对底层操作系统的了解，以适当的结构方式进行覆盖，将在面对难以调试的现实情况时帮助你无比。

# 本书涵盖的内容

第一章，“内核工作空间设置”，指导您设置一个完整的 Linux 内核开发工作空间（通常作为一个完全虚拟化的客户系统）。您将学习如何在其中安装所有必需的软件包，包括交叉工具链。您还将了解其他几个开源项目，这些项目对您成为专业内核/驱动程序开发人员的旅程将会有用。完成本章后，您将准备好构建 Linux 内核，以及开始编写和测试内核代码（通过可加载内核模块框架）。在我们看来，您实际上使用这本书进行动手操作，尝试和实验代码非常重要。学习某件事情的最好方法是通过经验主义 - 不是完全相信任何人的话，而是通过尝试和亲身体验来学习。

第二章，“从源代码构建 5.x Linux 内核 - 第一部分”，是解释如何从头开始使用源代码构建现代 Linux 内核的第一部分。在这一部分，您将获得必要的背景信息 - 版本命名、不同的源树、内核源代码的布局。接下来，您将详细了解如何将稳定的 vanilla Linux 内核源代码树下载到虚拟机上。然后，我们将学习一些关于内核源代码布局的知识，实际上是对内核代码库的“鸟瞰”。然后是提取和配置 Linux 内核的实际工作。还展示了创建和使用自定义菜单条目进行内核配置。

第三章，“从源代码构建 5.x Linux 内核 - 第二部分”，是关于从源代码执行内核构建的第二部分。在这一部分，您将继续上一章的内容，现在实际上构建内核，安装内核模块，了解`initramfs`（`initrd`）的确切含义以及如何生成它，以及设置引导加载程序（对于 x86）。此外，作为有价值的附加内容，本章还解释了如何为典型的嵌入式 ARM 目标（使用流行的树莓派作为目标设备）交叉编译内核。还提到了一些关于内核构建的技巧和窍门，甚至内核安全（加固）的内容。

第四章，“编写您的第一个内核模块 - LKMs 第一部分”，是涵盖 Linux 内核开发的一个基本方面的两个部分之一 - LKM 框架，以及模块用户（您 - 内核模块或设备驱动程序程序员）如何理解和使用它。它涵盖了 Linux 内核架构的基础知识，然后详细介绍了编写一个简单的“Hello, world”内核模块的每个步骤，包括编译、插入、检查和从内核空间中删除。我们还详细介绍了通过普遍的 printk API 进行内核日志记录。

第五章，“编写您的第一个内核模块 - LKMs 第二部分”，是涵盖 LKM 框架的第二部分。在这里，我们首先要学习如何使用“更好”的 Makefile，这将帮助您生成更健壮的代码（具有多个代码检查、纠正、静态分析目标等）。然后我们详细展示了成功交叉编译内核模块到另一个架构的步骤，以及如何在内核中模拟“类库”代码（通过“链接”和模块堆叠方法），定义和使用传递参数给内核模块。其他主题包括在启动时自动加载模块、重要的安全指南，以及有关内核文档的一些信息以及如何访问它。几个示例内核模块使学习更加有趣。

第六章，*内核内部要点-进程和线程*，深入探讨了一些基本的内核内部主题。我们首先介绍了进程和中断上下文中执行的含义，以及进程用户**虚拟地址空间**（VAS）布局的最小但必需的覆盖范围。这为您铺平了道路；然后您将更深入地了解 Linux 内核架构，重点关注进程/线程任务结构及其相应的堆栈（用户模式和内核模式）。然后我们向您展示了更多关于内核任务结构（一个“根”数据结构），如何从中实际获取信息，甚至遍历各种（任务）列表。几个内核模块使这个主题更加生动。

第七章，*内存管理内部要点-基础知识*，是一个关键章节，深入探讨了 Linux 内存管理子系统的基本内部结构，以满足典型模块作者或驱动程序开发人员所需的详细程度。因此，这种覆盖范围在本质上更加理论化；然而，在这里获得的知识对于您作为内核开发人员来说至关重要，无论是为了深入理解和使用适当的内核内存 API，还是为了在内核层面进行有意义的调试。我们涵盖了 VM 分割（以及它在各种实际架构上的情况），深入了解用户 VAS（我们的 procmap 实用程序将让您大开眼界），以及内核段（或内核 VAS）。然后我们简要地探讨了内存布局随机化（[K]ASLR）的安全技术，并以讨论 Linux 内部的物理内存组织结束了本章。

第八章，*模块作者的内核内存分配第一部分*，让我们亲自动手使用内核内存分配（和显然的释放）API。您将首先了解 Linux 内部的两种分配“层”-位于内核内存分配“引擎”上方的 slab 分配器，以及页面分配器（或 BSA）。我们将简要了解页面分配器算法的基础和其“空闲列表”数据结构；在决定使用哪一层时，这些信息是有价值的。接下来，我们直接投入到学习这些关键 API 的实际工作中。我们将涵盖 slab 分配器（或缓存）的背后思想以及主要的内核分配器 API-`kzalloc`/`kfree`。重要的是，详细介绍了使用这些常见 API 时的大小限制、缺点和注意事项。此外，特别适用于驱动程序作者的是，我们涵盖了内核的现代资源管理内存分配 API（`devm_*()`例程）。

第九章，*模块作者的内核内存分配第二部分*，在逻辑上进一步发展了前一章。在这里，您将学习如何创建自定义 slab 缓存（对于高频（de）分配，例如自定义驱动程序非常有用），以及关于在 slab 层调试内存分配的一些帮助。接下来，您将了解并使用`vmalloc()` API（及其相关内容）。非常重要的是，在涵盖了许多内核内存（de）分配 API 之后，您现在将学习如何根据您所处的实际情况选择适当的 API。本章以对内核的**内存不足**（OOM）“killer”框架的重要覆盖结束。了解它也将导致您对用户空间内存分配的工作原理有更深入的理解，通过需求分页技术。

第十章，“CPU 调度器-第一部分”，是两章中的第一部分，涵盖了关于 Linux 操作系统上 CPU 调度的理论和实践的有用混合内容。首先介绍了关于线程作为 KSE 以及可用的内核调度策略的最低必要理论背景。接下来，介绍了足够的内核 CPU 调度的细节，以便让您了解现代 Linux 操作系统上的调度工作原理。在学习的过程中，您将学习如何使用强大的工具（如 perf）“可视化”PU 调度；还深入探讨了线程调度属性（策略和实时优先级）。

第十一章，“CPU 调度器-第二部分”，是关于 CPU 调度的第二部分，继续更深入地介绍了这个主题。在这里，我们介绍了更多用于 CPU 调度的可视化工具（利用强大的软件，如 LTTng 和 trace-cmd 实用程序）。接下来，深入探讨了 CPU 亲和性掩码以及如何查询/设置它，以及在每个线程基础上控制调度策略和优先级的功能。还概述了控制组（cgroups）的含义和重要性，以及通过 cgroups v2 进行 CPU 带宽分配的有趣示例。您可以将 Linux 作为 RTOS 运行吗？确实可以！然后展示了实际操作的详细信息。最后，我们讨论了（调度）延迟以及如何测量它们。

第十二章，“内核同步-第一部分”，首先介绍了关于临界区、原子性、锁概念的关键概念，以及所有这些的重要性。然后我们介绍了在 Linux 内核中工作时的并发问题；这自然地引出了重要的锁定准则，死锁的含义，以及预防死锁的关键方法。然后深入讨论了两种最流行的内核锁技术——互斥锁和自旋锁——以及几个（驱动程序）代码示例。

第十三章，“内核同步-第二部分”，继续介绍内核同步的内容。在这里，您将了解关键的锁定优化——使用轻量级原子和（更近期的）引用计数运算符来安全地操作整数，使用 RMW 位运算符来安全地执行位操作，以及使用读者-写者自旋锁而不是常规自旋锁。还讨论了缓存“虚假共享”等固有风险。然后概述了无锁编程技术（重点是每 CPU 变量及其用法，并提供示例）。然后介绍了关键主题——锁调试技术，包括使用内核强大的“lockdep”锁验证器。最后简要介绍了内存屏障（并提供了一个示例）。

# 为了充分利用本书

为了充分利用本书，我们希望您具有以下知识和经验：

+   熟悉 Linux 系统的命令行（shell）。

+   C 编程语言。

+   这不是强制性的，但具有 Linux 系统编程概念和技术的经验将大大有助于。

有关硬件和软件要求以及其安装的详细信息在第一章，“内核工作区设置”中完整而深入地介绍。您必须详细阅读并遵循其中的说明。

此外，我们还在这些平台上测试了本书中的所有代码（它还有自己的 GitHub 存储库）：

+   x86_64 Ubuntu 18.04 LTS 客户操作系统（在 Oracle VirtualBox 6.1 上运行）

+   x86_64 Ubuntu 20.04.1 LTS 客户操作系统（在 Oracle VirtualBox 6.1 上运行）

+   x86_64 Ubuntu 20.04.1 LTS 本机操作系统

+   ARM Raspberry Pi 3B+（同时运行其“发行版”内核和我们的自定义 5.4 内核）；轻度测试

+   x86_64 CentOS 8 客户操作系统（在 Oracle VirtualBox 6.1 上运行）；轻度测试

我们假设在作为客户机（VM）运行 Linux 时，主机系统要么是 Windows 10 或更高版本（当然，甚至 Windows 7 也可以），要么是最新的 Linux 发行版（例如 Ubuntu 或 Fedora），甚至是 macOS。

**如果您使用本书的数字版本，我们建议您自己输入代码，或者更好的是通过 GitHub 存储库访问代码（链接在下一节中提供）。这样做将有助于避免与复制和粘贴代码相关的任何潜在错误。

我强烈建议您遵循*经验主义方法：不要轻信任何人的话，而是亲自尝试并体验。*因此，本书为您提供了许多实践实验和内核代码示例，您可以并且必须亲自尝试；这将极大地帮助您取得实质性进展，并深入学习和理解 Linux 内核开发的各个方面。

## 下载示例代码文件

您可以从 GitHub 上下载本书的示例代码文件，链接为[`github.com/PacktPublishing/Linux-Kernel-Programming`](https://github.com/PacktPublishing/Linux-Kernel-Programming)。如果代码有更新，将在现有的 GitHub 存储库上进行更新。

我们还有来自我们丰富书籍和视频目录的其他代码包，可在**[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)**上找到。去看看吧！

## 下载彩色图像

我们还提供了一个 PDF 文件，其中包含本书中使用的屏幕截图/图表的彩色图像。您可以在这里下载：`www.packtpub.com/sites/default/files/downloads/9781789953435_ColorImages.pdf`。

## 使用的约定

本书中使用了许多文本约定。

`CodeInText`：表示文本中的代码字词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 用户名。这是一个例子：“`ioremap()` API 返回`void *`类型的 KVA（因为它是一个地址位置）”

代码块设置如下：

```
static int __init miscdrv_init(void)
{
    int ret;
    struct device *dev;
```

当我们希望引起您对代码块的特定部分的注意时，相关行或项目将以粗体显示：

```
#define pr_fmt(fmt) "%s:%s(): " fmt, KBUILD_MODNAME, __func__
[...]
#include <linux/miscdevice.h>
#include <linux/fs.h>             
[...]
```

任何命令行输入或输出都是按照以下方式编写的：

```
pi@raspberrypi:~ $ sudo cat /proc/iomem
```

**粗体**：表示新术语、重要单词或屏幕上看到的单词。例如，菜单或对话框中的单词会以这种形式出现在文本中。这是一个例子：“从管理面板中选择系统信息”。

警告或重要说明会出现在这样的形式中。

提示和技巧会以这种形式出现。

# 联系我们

我们始终欢迎读者的反馈意见。

**一般反馈**：如果您对本书的任何方面有疑问，请在您的消息主题中提及书名，并通过电子邮件联系我们，邮箱为`customercare@packtpub.com`。

**勘误**：尽管我们已经非常注意确保内容的准确性，但错误是难免的。如果您在本书中发现错误，我们将不胜感激，如果您能向我们报告。请访问[www.packtpub.com/support/errata](https://www.packtpub.com/support/errata)，选择您的书，点击勘误提交表单链接，并输入详细信息。

**盗版**：如果您在互联网上发现我们作品的任何形式的非法副本，我们将不胜感激，如果您能向我们提供位置地址或网站名称。请通过`copyright@packt.com`与我们联系，并提供材料链接。

**如果您有兴趣成为作者**：如果您在某个专业领域有专长，并且有兴趣撰写或为书籍做出贡献，请访问[authors.packtpub.com](http://authors.packtpub.com/)。

## 评论

请留下评论。在阅读并使用本书后，为什么不在购买书籍的网站上留下评论呢？潜在的读者可以看到并使用您的客观意见来做出购买决定，我们在 Packt 可以了解您对我们产品的看法，我们的作者也可以看到您对他们书籍的反馈。谢谢！

有关 Packt 的更多信息，请访问 [packt.com](http://www.packt.com/)。
