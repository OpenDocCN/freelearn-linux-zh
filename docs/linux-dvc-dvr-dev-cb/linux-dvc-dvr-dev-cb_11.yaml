- en: 'Additional Information: Miscellaneous Kernel Internals'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加信息：杂项内核内部
- en: Here's some general information on dynamic memory allocation and I/O memory
    access methods.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是有关动态内存分配和I/O内存访问方法的一些一般信息。
- en: While talking about dynamic memory allocation, we should keep in mind that we're
    programming in the C language inside the kernel, so it's really important to remember
    that each allocated memory chunk must be freed up when not used anymore. This
    is very important because in userspace, when a process ends its execution, the
    kernel (which actually knows all about memory chunks owned by the process) can
    easily get back all process-allocated memory; but this does not hold true for
    the kernel. In fact, a driver (or other kernel entity) that asks for a memory
    chunk must be sure to free it, otherwise, nobody will ask for it back and the
    memory chunk will be lost until the machine is restarted.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论动态内存分配时，我们应该记住我们是在内核中使用C语言进行编程，因此非常重要的一点是要记住每个分配的内存块在不再使用时必须被释放。这非常重要，因为在用户空间，当一个进程结束执行时，内核（实际上知道进程拥有的所有内存块）可以轻松地收回所有进程分配的内存；但对于内核来说，情况并非如此。实际上，要求内存块的驱动程序（或其他内核实体）必须确保释放它，否则没有人会要求它回来，内存块将丢失，直到机器重新启动。
- en: Regarding access to I/O memory, which is that area composed by the memory cells
    underlying peripheral registers, we must consider that we can't access them using
    their physical memory address; instead, we'll have to use the corresponding virtual
    one. In fact, Linux is an operating system that uses a **Memory Management Unit** (**MMU**)
    to virtualize and protect memory accesses, so we'll have to remap each peripheral's
    physical memory area to its corresponding virtual memory area to be able to read
    from and write to them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 关于对I/O内存的访问，这是由底层外围寄存器下的内存单元组成的区域，我们必须考虑到我们不能使用它们的物理内存地址来访问它们；相反，我们将不得不使用相应的虚拟地址。事实上，Linux是一个使用**内存管理单元**（MMU）来虚拟化和保护内存访问的操作系统，因此我们必须将每个外围设备的物理内存区域重新映射到其相应的虚拟内存区域，以便能够从中读取和写入。
- en: This operation can be easily done by using the kernel functions presented in
    the code snippet in Chapter , but it is of paramount importance to point out that
    it must be done before any I/O memory access is attempted, or a segmentation fault
    will be triggered. This can terminate the process in user space, or possibly terminate
    the kernel itself for a bug in a device driver.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作可以很容易地通过使用代码段中介绍的内核函数来完成，但是非常重要的一点是必须在尝试进行任何I/O内存访问之前完成，否则将触发段错误。这可能会终止用户空间中的进程，或者可能因为设备驱动程序中的错误而终止内核本身。
- en: Dynamic memory allocation
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态内存分配
- en: The most straightforward way to allocate memory is to use the `kmalloc()` function,
    and, to be on the safe side, it’s best to use routines that clear the allocated
    memory to zero, such as the `kzalloc()` function. On the other hand, if we need
    to allocate memory for an array, there are `kmalloc_array()` and `kcalloc()` dedicated
    functions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 分配内存的最直接方式是使用`kmalloc()`函数，并且为了安全起见，最好使用清除分配的内存为零的例程，例如`kzalloc()`函数。另一方面，如果我们需要为数组分配内存，有专门的函数`kmalloc_array()`和`kcalloc()`。
- en: 'Here are some snippets containing memory allocation kernel functions (and the
    relative kernel memory deallocation functions) as reported in the header file, `linux/include/linux/slab.h`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是包含内存分配内核函数（以及相关的内核内存释放函数）的一些片段，如内核源文件`linux/include/linux/slab.h`中所述。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All the preceding functions expose two main differences between the userspace
    counterpart `malloc()` and other memory allocation functions:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述函数都暴露了用户空间对应的`malloc()`和其他内存分配函数之间的两个主要区别：
- en: The maximum size of a chunk that can be allocated with `kmalloc()` and friends
    is limited. The actual limit depends on the hardware and the kernel configuration,
    but it is a good practice to use `kmalloc()` and other kernel helpers for objects
    smaller than a page size.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`kmalloc()`和其他类似函数分配的块的最大大小是有限的。实际限制取决于硬件和内核配置，但是最好的做法是对小于页面大小的对象使用`kmalloc()`和其他内核辅助函数。
- en: The number of bytes that make a page size is stated by defined `PAGE_SIZE` info
    kernel sources in the `linux/include/asm-generic/page.h` file; usually, it's 4096
    bytes for 32-bit systems and 8192 bytes for 64-bit systems. It can be explicitly
    chosen by the user via the usual kernel configuration mechanism.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`PAGE_SIZE`信息内核源文件`linux/include/asm-generic/page.h`中指定了构成页面大小的字节数；通常情况下，32位系统为4096字节，64位系统为8192字节。用户可以通过通常的内核配置机制来明确选择它。
- en: 'Kernel functions for dynamic memory allocation, such as `kmalloc()` and similar
    functions take an extra argument; the allocation flags are used to specify the
    behavior of `kmalloc()` in a number of ways, as reported in the snippet below
    from the `linux/include/linux/slab.h` file of kernel sources:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于动态内存分配的内核函数，如`kmalloc()`和类似函数，需要额外的参数；分配标志用于指定`kmalloc()`的行为方式，如下面从内核源文件`linux/include/linux/slab.h`中报告的片段所述。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see, there exist a lot of flags; however, a device driver developer
    will be interested mainly in `GFP_KERNEL` and `GFP_ATOMIC`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，存在许多标志；然而，设备驱动程序开发人员主要感兴趣的是`GFP_KERNEL`和`GFP_ATOMIC`。
- en: It is clear that the main difference between the two flags is that the former
    can allocate normal kernel RAM and it may sleep, while the latter does the same
    without allowing the caller to sleep. This is a big difference between the two
    functions because it tells us which flag we have to use when we are in interrupt
    context or process context.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这两个标志之间的主要区别在于前者可以分配正常的内核RAM并且可能会休眠，而后者在不允许调用者休眠的情况下执行相同的操作。这两个函数之间的这个巨大区别告诉我们，当我们处于中断上下文或进程上下文时，我们必须使用哪个标志。
- en: 'As seen in [Chapter 5](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=6&action=edit#post_28), *Managing
    Interrupts and Concurrency*,when we are in interrupt context we cannot sleep (as
    reported in the code above), in these situations, we must call `kmalloc()` and friends
    by specifying the `GFP_ATOMIC` flag, while the `GFP_KERNEL` flag can be used elsewhere,
    keeping in account that it can lead the caller to sleep and then the CPU may leave
    us to execute something else; therefore, we should avoid doing the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第5章](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=6&action=edit#post_28)所示，*管理中断和并发*，当我们处于中断上下文时，我们不能休眠（如上面的代码所述），在这种情况下，我们必须通过指定`GFP_ATOMIC`标志来调用`kmalloc()`和相关函数，而`GFP_KERNEL`标志可以在其他地方使用，需要注意的是它可能导致调用者休眠，然后CPU可能会让我们执行其他操作；因此，我们应该避免以下操作：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In fact, even if we're executing in the process context, executing a sleeping `kmalloc()` while
    holding a spinlock is considered evil! So, we must use the `GFP_ATOMIC` flag anyway
    in this case. Moreover, be aware that the maximum size for a successful `GFP_ATOMIC` allocation
    request tends to be smaller than a `GFP_KERNEL` request for the same reasons mentioned
    here clearly, related to physically-contiguous memory allocation and that the
    kernel keeps a limited pool of memory readily available for atomic allocation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，即使我们在进程上下文中执行，持有自旋锁的休眠`kmalloc()`被认为是邪恶的！因此，在这种情况下，我们无论如何都必须使用`GFP_ATOMIC`标志。此外，需要注意的是，对于相同原因，成功的`GFP_ATOMIC`分配请求的最大大小往往比`GFP_KERNEL`请求要小，这与物理连续内存分配有关，内核保留了有限的内存池可供原子分配使用。
- en: Regarding the first point above, on the limited size of an allocable memory
    chunk, for large allocations, we can alternatively consider using another class
    of functions: `vmalloc()` and `vzalloc()`, even if we have to underline the fact
    that memory allocated by `vmalloc()` and related functions are not physically
    contiguous and can't be used for **Direct Memory Access** (**DMA**) activities
    (while `kmalloc()` and friends, as stated previously, allocate contiguous memory
    areas in both virtual and physical addressing spaces).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 关于上面的第一点，对于可分配内存块的有限大小，对于大型分配，我们可以考虑使用另一类函数：`vmalloc()`和`vzalloc()`，即使我们必须强调`vmalloc()`和相关函数分配的内存不是物理上连续的，不能用于**直接内存访问**（**DMA**）活动（而`kmalloc()`和相关函数，如前面所述，分配了虚拟和物理寻址空间中的连续内存区域）。
- en: Allocating memory for DMA activities is currently not addressed in this book;
    however, you may get further information regarding this issue in kernel sources
    within the `linux/Documentation/DMA-API.txt` and `linux/Documentation/DMA-API-HOWTO.txt` files.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，本书未涉及为DMA活动分配内存；但是，您可以在内核源代码中的`linux/Documentation/DMA-API.txt`和`linux/Documentation/DMA-API-HOWTO.txt`文件中获取有关此问题的更多信息。
- en: 'In the following, there is the prototype of the `vmalloc()` function and friends
    definitions as reported in the `linux/include/linux/vmalloc.h` header file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`vmalloc()`函数的原型和在`linux/include/linux/vmalloc.h`头文件中报告的函数定义：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we are not sure whether the allocation size is too large for `kmalloc()`,
    we can use `kvmalloc()` and its derivatives. This function will try to allocate
    memory with `kmalloc()`, and if the allocation fails it will fall back to `vmalloc()`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不确定分配的大小是否对于`kmalloc()`来说太大，我们可以使用`kvmalloc()`及其衍生函数。这个函数将尝试使用`kmalloc()`来分配内存，如果分配失败，它将退而使用`vmalloc()`。
- en: Note that `kvmalloc()`may return memory that is not physically contiguous.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`kvmalloc()`可能返回的内存不是物理上连续的。
- en: There are also restrictions on which `GFP_*` flags can be used with `kvmalloc()`, as reported
    in `kvmalloc_node()` documentation at [https://www.kernel.org/doc/html/latest/core-api/mm-api.html#c.kvmalloc_node](https://www.kernel.org/doc/html/latest/core-api/mm-api.html#c.kvmalloc_node).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还有关于`kvmalloc()`可以与哪些`GFP_*`标志一起使用的限制，可以在[https://www.kernel.org/doc/html/latest/core-api/mm-api.html#c.kvmalloc_node](https://www.kernel.org/doc/html/latest/core-api/mm-api.html#c.kvmalloc_node)中的`kvmalloc_node()`文档中找到。
- en: 'Here are code snippets about `kvmalloc()`, `kvzalloc()`, `kvmalloc_array()`,
    `kvcalloc()`, and `kvfree()` as reported in the `linux/include/linux/mm.h`  header
    file:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`linux/include/linux/mm.h`头文件中报告的`kvmalloc()`、`kvzalloc()`、`kvmalloc_array()`、`kvcalloc()`和`kvfree()`的代码片段：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Kernel doubly linked lists
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核双向链表
- en: When working with the Linux's **doubly linked list** interface, we should always
    bear in mind that these list functions perform no locking, so there is a possibility
    that our device driver (or other kernel entities) could attempt to perform concurrent
    operations on the same list. That's why we must be sure to implement a good locking
    scheme to protect our data against race conditions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Linux的**双向链表**接口时，我们应该始终记住这些列表函数不执行锁定，因此我们的设备驱动程序（或其他内核实体）可能尝试对同一列表执行并发操作。这就是为什么我们必须确保实现一个良好的锁定方案来保护我们的数据免受竞争条件的影响。
- en: 'To use the list mechanism, our driver must include the header file `linux/include/linux/list.h`;
    this file includes the header, `linux/include/linux/types.h`, where a simple structure
    of the `struct list_head` type is defined as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用列表机制，我们的驱动程序必须包括头文件`linux/include/linux/list.h`；这个文件包括头文件`linux/include/linux/types.h`，在这里定义了`struct
    list_head`类型的简单结构如下：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see, this structure contains two pointers (`prev` and `next`) to a `list_head` structure;
    these two pointers implement the doubly linked list functionality. However, the
    interesting thing is that `struct list_head` has no dedicated data field as it
    would in a canonical list implementation. In fact, in the Linux kernel list implementation,
    the data field is not embedded in the list element itself; rather it's the list
    structure that is meant to be enclosed in the related data structure. This may
    be confusing but, in reality, it is not; in fact, to use the Linux list facility
    in our code, we just need to embed a `struct list_head` inside the structure that
    makes use of the list.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个结构包含两个指针（`prev`和`next`）指向`list_head`结构；这两个指针实现了双向链表的功能。然而，有趣的是`struct
    list_head`没有专用的数据字段，就像在经典的列表实现中那样。事实上，在Linux内核列表实现中，数据字段并没有嵌入在列表元素本身中；相反，列表结构是被认为被封装在相关数据结构中。这可能会让人困惑，但实际上并不是；事实上，要在我们的代码中使用Linux列表功能，我们只需要在使用列表的结构中嵌入一个`struct
    list_head`。
- en: 'A simple example of how we can declare our object structure into our device
    driver is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在设备驱动程序中声明对象结构的简单示例如下：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'By doing this, we create a doubly linked list with custom data. Then, to effectively
    create our list, we just need to declare and initialize the list head using the
    following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们创建了一个带有自定义数据的双向链表。然后，要有效地创建我们的列表，我们只需要声明并初始化列表头，使用以下代码：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As per other kernel structures, we have the compile time counterpart macro
    `LIST_HEAD()`, which can be used to do the same in case of non-dynamic list allocation.
    In our example, we can do as follows: `LIST_HEAD(data_list)`;'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他内核结构一样，我们有编译时对应的宏`LIST_HEAD()`，它可以用于在非动态列表分配的情况下执行相同的操作。在我们的示例中，我们可以这样做：`LIST_HEAD(data_list)`；
- en: Once the list head has been declared and properly initialized, we can use several
    functions, still from the `linux/include/linux/list.h` file, to add, remove, or
    do other list entry manipulation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦列表头部被声明并正确初始化，我们可以使用`linux/include/linux/list.h`文件中的几个函数来添加、删除或执行其他列表条目操作。
- en: 'If we take a look at the header file, we can see the following functions to
    add or remove an element from the list:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看头文件，我们可以看到以下函数用于向列表中添加或删除元素：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following function to replace an old entry by a new one are also visible:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 用于用新条目替换旧条目的以下函数也是可见的：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is just a subset of all available functions. You are encouraged to take
    a look at the `linux/include/linux/list.h` file to discover more.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是所有可用函数的一个子集。鼓励您查看`linux/include/linux/list.h`文件以发现更多。
- en: 'However, apart from the preceding functions, which can be used to add or remove
    an entry from the list, it is more interesting to see the macros used to create
    loops that iterate through lists. For example, if we wish to add a new entry in
    an ordered manner, we can do something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的函数之外，用于向列表中添加或删除条目的宏更有趣。例如，如果我们希望以有序的方式添加新条目，我们可以这样做：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By using the `list_for_each()` macro, we iterate the list and by using `list_entry()`, we
    obtain a pointer to our enclosing data. Note that we must pass to `list_entry()` the
    pointer to the current element `ptr`, our struct type, and then the name of the
    list entry within our struct (which is `list` in the preceding example).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`list_for_each()`宏，我们可以迭代列表，并通过使用`list_entry()`，我们可以获得指向我们封闭数据的指针。请注意，我们必须将指向当前元素`ptr`、我们的结构类型以及我们结构中的列表条目的名称（在前面的示例中为`list`）传递给`list_entry()`。
- en: Finally, we can add our new element at the right position using the `list_add_tail()`
    function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`list_add_tail()`函数将我们的新元素添加到正确的位置。
- en: Note that `list_entry()` simply uses the `container_of()` macro to do its job.
    The macro is explained in [Chapter 5](cbd6e9f7-f07c-46b8-b751-ece44101ca8b.xhtml)*,
    Managing Interrupts and Concurrency,* The container_of() macro section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`list_entry()`只是使用`container_of()`宏来执行其工作。该宏在[第5章](cbd6e9f7-f07c-46b8-b751-ece44101ca8b.xhtml)*管理中断和并发性*的*container_of()宏*部分中有解释。
- en: 'If we take a look again at the `linux/include/linux/list.h` file, we can see
    more functions that we can use to get an entry from the list or to iterate all
    list elements in a different manner:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看`linux/include/linux/list.h`文件，我们可以看到更多的函数，我们可以使用这些函数来从列表中获取条目或以不同的方式迭代所有列表元素：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Some macros are also useful to iterate over the elements of each list:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一些宏也可用于迭代每个列表的元素：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Again you should note that this is just a subset of all available functions,
    so you are encouraged to take a look at the `linux/include/linux/list.h` file to
    discover more.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，这只是所有可用函数的一个子集，因此鼓励您查看`linux/include/linux/list.h`文件以发现更多。
- en: Kernel hash tables
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核哈希表
- en: As stated previously, for linked lists, when working with the Linux's **hash
    table** interface, we should always bear in mind that these hashing functions
    perform no locking, so it is possible that our device driver (or other kernel
    entities) could attempt to perform concurrent operations on the same hash table.
    This is why we must be sure to also implement a good locking scheme to protect
    our data against race conditions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，对于链表，当使用Linux的**哈希表**接口时，我们应该始终记住这些哈希函数不执行锁定，因此我们的设备驱动程序（或其他内核实体）可能尝试对同一哈希表执行并发操作。这就是为什么我们必须确保还实现了一个良好的锁定方案来保护我们的数据免受竞争条件的影响。
- en: 'As with kernel lists, we can declare and then initialize a hash table with
    a size of power-of-2 bits, using the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与内核列表一样，我们可以声明然后初始化一个具有2的幂位大小的哈希表，使用以下代码：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As per lists, we have the compile time counterpart macro `DEFINE_HASHTABLE()`,
    which can be used to do the same in case of a non-dynamic hash table allocation.
    In our example, we can use `DEFINE_HASHTABLE(data_hash, bits)`;
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表一样，我们有编译时对应的宏`DEFINE_HASHTABLE()`，它可以用于在非动态哈希表分配的情况下执行相同的操作。在我们的示例中，我们可以使用`DEFINE_HASHTABLE(data_hash,
    bits)`；
- en: 'This creates and initializes a table named `data_hash` and a power-of-2 size
    based on bits. As just said, the table is implemented using buckets containing
    a kernel `struct hlist_head` type; this is due to the fact that kernel hash tables
    are implemented using a hash chain, whereas hash collisions are simply added to
    the head of the list. To better see this, we can refer to the `DECLARE_HASHTABLE()` macro
    definition:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建并初始化一个名为`data_hash`的表，其大小基于2的幂。正如刚才所说，该表是使用包含内核`struct hlist_head`类型的桶来实现的；这是因为内核哈希表是使用哈希链实现的，而哈希冲突只是添加到列表的头部。为了更好地看到这一点，我们可以参考`DECLARE_HASHTABLE()`宏的定义：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once that''s done, a structure containing a `struct hlist_node` pointer can
    be constructed to hold the data to be inserted, as we did before for lists:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，可以构建一个包含`struct hlist_node`指针的结构来保存要插入的数据，就像我们之前为列表所做的那样：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `struct hlist_node` and its head, `struct hlist_head`, are defined in the `linux/include/linux/types.h` header
    file as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct hlist_node`及其头`struct hlist_head`在`linux/include/linux/types.h`头文件中定义如下：'
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A new node can then be added into the hash table using the `hash_add()` function
    as follows, where `&entry.node` is a pointer to `struct hlist_node` within the
    data structure, and `key` is the hashed key:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用`hash_add()`函数将新节点添加到哈希表中，如下所示，其中`&entry.node`是数据结构中`struct hlist_node`的指针，`key`是哈希键：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The key can be whatever; however, usually it''s computed by using a special
    hash function applied to the data to be stored. For instance, having a hash table
    of 256 buckets, the key can be computed with the following `hash_func()`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥可以是任何东西；但通常是通过使用特殊的哈希函数应用于要存储的数据来计算的。例如，有一个256个桶的哈希表，密钥可以用以下`hash_func()`计算：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The opposite operation, which is deletion, can be done by using the `hash_del()` function
    as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的操作，即删除，可以通过使用`hash_del()`函数来完成，如下所示：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'However, as for lists, the most interesting macros are the ones used to iterate
    the table. There exist two mechanisms; one iterates through the entire hash table,
    returning the entries in each bucket:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，与列表一样，最有趣的宏是用于迭代表的宏。存在两种机制；一种是遍历整个哈希表，返回每个桶中的条目：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The other returns only the entries that correspond to the key''s hash bucket:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个仅返回与密钥的哈希桶对应的条目：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'By using this last macro, a procedure to delete a node from the hash table
    looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用最后一个宏，从哈希表中删除节点的过程如下：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that this implementation just deletes the first matching entry.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此实现只删除第一个匹配的条目。
- en: By using `hash_for_each_possible()`, we can iterate the list into the bucket
    related to a key.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`hash_for_each_possible()`，我们可以迭代与密钥相关的桶中的列表。
- en: 'In the following, there are definitions of `hash_add()`, `hash_del()`, and
    `hash_for_each_possible()` as reported in the `linux/include/linux/hashtable.h`
    file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`linux/include/linux/hashtable.h`文件中报告的`hash_add()`、`hash_del()`和`hash_for_each_possible()`的定义：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: These are just a subset of all available functions to manage hash tables. You
    are encouraged to take a look at the `linux/include/linux/hashtable.h` file to
    see more.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是管理哈希表的所有可用函数的子集。鼓励您查看`linux/include/linux/hashtable.h`文件以了解更多。
- en: Getting access to I/O memory
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问I/O内存
- en: 'To be able to effectively talk with a peripheral, we need to have a way to
    read and write within its registers and, to do that, we have two ways: by using **I/O
    ports** or by using **I/O memory**. The former mechanism is not covered in this
    book because it is not used so much in modern platforms (apart form x86 and x86_64
    ones), while the latter just uses normal memory areas to map each peripheral register
    and is the one that is commonly used in modern CPUs. In fact, I/O memory mapping
    is really common in **System-on-Chip** (**SoC**) systems, where the CPU can talk
    to its internal peripherals just by reading and writing into well-known physical
    addresses; in this scenario, each peripheral has its own reserved address and
    each one is connected to a register.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够有效地与外围设备通信，我们需要一种方法来读写其寄存器，为此我们有两种方法：通过**I/O端口**或通过**I/O内存**。前一种机制在本书中没有涵盖，因为它在现代平台中（除了x86和x86_64之外）并不经常使用，而后者只是使用正常的内存区域来映射每个外围寄存器，这是现代CPU中常用的一种方法。事实上，I/O内存映射在**片上系统**（**SoC**）系统中非常常见，其中CPU可以通过读写到众所周知的物理地址来与其内部外围设备通信；在这种情况下，每个外围设备都有其自己的保留地址，并且每个外围设备都连接到一个寄存器。
- en: To see a simple example of what I'm talking about, you can get the SAMA5D3 CPU's
    datasheet from [http://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-11121-32-bit-Cortex-A5-Microcontroller-SAMA5D3_Datasheet_B.pdf](http://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-11121-32-bit-Cortex-A5-Microcontroller-SAMA5D3_Datasheet_B.pdf); look
    up page 30, where a complete memory mapping of the whole CPU is reported.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要看我所说的一个简单示例，您可以从[http://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-11121-32-bit-Cortex-A5-Microcontroller-SAMA5D3_Datasheet_B.pdf](http://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-11121-32-bit-Cortex-A5-Microcontroller-SAMA5D3_Datasheet_B.pdf)获取SAMA5D3
    CPU的数据表，查看第30页，其中报告了整个CPU的完整内存映射。
- en: 'This I/O memory mapping is then reported in the device tree files related to
    a platform. Just as an example, if we take a look at the definition of the UART
    controller of our ESPRESSObin''s CPU in the `linux/arch/arm64/boot/dts/marvell/armada-37xx.dtsi`
    file of the kernel sources, we can see the following settings:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个I/O内存映射被报告在与平台相关的设备树文件中。举个例子，如果我们看一下内核源文件中`linux/arch/arm64/boot/dts/marvell/armada-37xx.dtsi`文件中我们ESPRESSObin的CPU的UART控制器的定义，我们可以看到以下设置：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As explained in [Chapter 4](5f22a69e-e8b7-402e-8e67-72938d00c914.xhtml), *Using
    the Device Tree*, we can deduce that the UART0 controller is mapped at a physical
    address `0xd0012000`. This is also confirmed by the following kernel message we
    can see at boot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第4章](5f22a69e-e8b7-402e-8e67-72938d00c914.xhtml)中所解释的，*使用设备树*，我们可以推断UART0控制器被映射到物理地址`0xd0012000`。这也被我们在启动时可以看到的以下内核消息所证实：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'OK, now we have to keep in mind that `0xd0012000` is the **physical address** of
    the UART controller, but our CPU knows **virtual addresses** because it uses its
    MMU to get access to RAM! So, how can we do the translation between the physical
    address `0xd0012000` and its virtual counterpart? The answer is: by memory remapping.
    This operation must be done in the kernel before every read or write operation
    on the UART controller''s registers, otherwise, a segmentation fault will be raised.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们必须记住`0xd0012000`是UART控制器的**物理地址**，但我们的CPU知道**虚拟地址**，因为它使用其MMU来访问RAM！那么，我们如何在物理地址`0xd0012000`和其虚拟对应地址之间进行转换呢？答案是：通过内存重新映射。在每次读取或写入UART控制器的寄存器之前，必须在内核中执行此操作，否则将引发段错误。
- en: 'Just to have an idea about the difference between physical and virtual addresses
    and about how the remap operation behaves, we can have a look at the utility program
    named `devmem2`, which is downloadable within the ESPRESSObin via the `wget` program
    from [http://free-electrons.com/pub/mirror/devmem2.c](http://free-electrons.com/pub/mirror/devmem2.c):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了了解物理地址和虚拟地址之间的差异以及重新映射操作的行为，我们可以看一下名为`devmem2`的实用程序，该实用程序可以通过ESPRESSObin上的`wget`程序从[http://free-electrons.com/pub/mirror/devmem2.c](http://free-electrons.com/pub/mirror/devmem2.c)下载：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we take a look at the code, we see the following operations:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下代码，我们会看到以下操作：
- en: '[PRE27]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So the `devmem2` program just opens the `/dev/mem` device and then it calls
    the `mmap() `system call. This operation will cause the execution of the `mmap_mem()` method in
    the `linux/ drivers/char/mem.c `file , in kernel sources, where the `/dev/mem` char
    device is implemented:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`devmem2`程序只是打开`/dev/mem`设备，然后调用`mmap()`系统调用。这将导致在内核源文件`linux/ drivers/char/mem.c`中执行`mmap_mem（）`方法，其中实现了`/dev/mem`字符设备：
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Further information regarding these memory-remap operations and usage of the `remap_pfn_range()` functions
    and similar functions will be more clear in [Chapter 7](3a9fe19d-0ba6-4959-bc71-493d9f499cc4.xhtml),
    *Advanced Char Driver Operations*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些内存重新映射操作以及`remap_pfn_range（）`函数和类似函数的使用的更多信息将在[第7章](3a9fe19d-0ba6-4959-bc71-493d9f499cc4.xhtml)“高级字符驱动程序操作”中更清楚。
- en: Well, the  `mmap_mem()`method conducts the memory remapping operation of the
    physical address `0xd0012000` into a virtual one suitable to be used by the CPU
    to access the UART controller's registers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，`mmap_mem（）`方法对物理地址`0xd0012000`进行内存重新映射操作，将其映射为适合CPU访问UART控制器寄存器的虚拟地址。
- en: 'If we try to compile the code with the following command on the ESPRESSObin,
    we get an executable suitable access from the user space to the UART controller''s
    registers:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在ESPRESSObin上使用以下命令编译代码，我们将得到一个可执行文件，从用户空间访问UART控制器的寄存器：
- en: '[PRE29]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can safely ignore possible warning messages shown below:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以安全地忽略下面显示的可能的警告消息：
- en: '`devmem2.c:104:33: warning: format ''%X'' expects argument of type ''unsigned
    int'',`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`devmem2.c:104:33: 警告：格式“％X”需要类型为“unsigned int”的参数，`'
- en: '`but argument 2 has type ''off_t {aka long int}'' [-Wformat=]`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`但参数2的类型为''off_t {aka long int}'' [-Wformat=]`'
- en: '`printf("Value at address 0x%X (%p): 0x%X\n", target, virt_addr, read_result`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf("地址0x%X（%p）处的值：0x%X\n"，target，virt_addr，read_result`'
- en: '`);`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`);`'
- en: '`devmem2.c:104:44: warning: format ''%X'' expects argument of type ''unsigned
    int'',`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`devmem2.c:104:44: 警告：格式“％X”需要类型为“unsigned int”的参数，`'
- en: '`but argument 4 has type ''long unsigned int'' [-Wformat=]`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`但参数4的类型为''long unsigned int'' [-Wformat=]`'
- en: '`printf("Value at address 0x%X (%p): 0x%X\n", target, virt_addr, read_result`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf("地址0x%X（%p）处的值：0x%X\n"，target，virt_addr，read_result`'
- en: '`);`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`);`'
- en: '`devmem2.c:123:22: warning: format ''%X'' expects argument of type ''unsigned
    int'',`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`devmem2.c:123:22: 警告：格式“％X”需要类型为“unsigned int”的参数，`'
- en: '`but argument 2 has type ''long unsigned int'' [-Wformat=]`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`但参数2的类型为''long unsigned int'' [-Wformat=]`'
- en: '`printf("Written 0x%X; readback 0x%X\n", writeval, read_result);`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf("写入0x%X；读回0x%X\n"，writeval，read_result);`'
- en: '`devmem2.c:123:37: warning: format ''%X'' expects argument of type ''unsigned
    int'',`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`devmem2.c:123:37: 警告：格式“％X”需要类型为“unsigned int”的参数，`'
- en: '`but argument 3 has type ''long unsigned int'' [-Wformat=]`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`但参数3的类型为''long unsigned int'' [-Wformat=]`'
- en: '`printf("Written 0x%X; readback 0x%X\n", writeval, read_result);`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf("写入0x%X；读回0x%X\n"，writeval，read_result);`'
- en: 'Then, if we execute the program, we should get the following output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们执行程序，我们应该得到以下输出：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we can see, the `devmem2` programs prints the remapping result as expected
    and the actual read is done using the virtual address, which, in turn, the MMU
    translates into the desired physical one at `0xd0012000`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`devmem2`程序按预期打印了重新映射结果，并且实际读取是使用虚拟地址完成的，而MMU又将其转换为所需的物理地址`0xd0012000`。
- en: OK, now that it's clear that a memory remap is needed to access the peripheral's
    registers, we may suppose that once we have a virtual address physically mapped
    to a register, we can simply reference it to actually read or write data. Well
    this is wrong! In fact, despite the strong similarity between hardware registers
    mapped in memory and the usual RAM memory, when we get access to I/O registers,
    we must be careful to avoid being tricked by the CPU or compiler optimizations
    that can modify the expected I/O behavior.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在清楚了，访问外围寄存器需要进行内存重新映射，我们可以假设一旦我们有了一个虚拟地址物理映射到一个寄存器，我们可以简单地引用它来实际读取或写入数据。这是错误的！实际上，尽管硬件寄存器在内存中映射和通常的RAM内存之间有很强的相似性，但当我们访问I/O寄存器时，我们必须小心避免被CPU或编译器优化所欺骗，这些优化可能会修改预期的I/O行为。
- en: The main difference between I/O registers and RAM is that I/O operations have
    side effects, while memory operations do not; in fact, when we write a value into
    RAM, we expect it to be unchanged by someone else, but for I/O memory, this is
    not true due to the fact that our peripheral may change some data in registers,
    even if we wrote a specific value into them. This is a really important fact to
    keep in mind, because, to attain good performance, RAM content can be cached and
    read/write instructions can be reordered by the CPU instruction pipeline; moreover,
    the compiler can autonomously decide to put data values in CPU registers without
    writing them to memory, and even if it finally stores them to memory, both write
    and read operations can operate on cache memory without ever reaching physical
    RAM. Even if it finally stores them to memory, both optimizations are not acceptable
    on I/O memory. In fact, these optimizations are transparent and benign when applied
    to conventional memory, but they can be fatal on I/O operations because a peripheral
    has a well-defined way of being programmed, and read and write operations on its
    registers can't be reordered or cached without causing malfunctions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: I/O寄存器和RAM之间的主要区别在于I/O操作具有副作用，而内存操作则没有；实际上，当我们向RAM中写入一个值时，我们希望它不会被其他人改变，但对于I/O内存来说，这并不是真的，因为我们的外设可能会改变寄存器中的一些数据，即使我们向其中写入了特定的值。这是一个非常重要的事实，因为为了获得良好的性能，RAM内容可以被缓存，并且CPU指令流水线可以重新排序读/写指令；此外，编译器可以自主决定将数据值放入CPU寄存器而不将其写入内存，即使最终将其存储到内存中，写入和读取操作都可以在缓存内存上进行，而不必到达物理RAM。即使最终将其存储到内存中，这两种优化在I/O内存上是不可接受的。实际上，这些优化在应用于常规内存时是透明且良性的，但在I/O操作中可能是致命的，因为外设有明确定义的编程方式，对其寄存器的读写操作不能重新排序或缓存，否则会导致故障。
- en: 'These are the main reasons we can''t simply reference a virtual memory address
    to read and write data from a memory mapped peripheral. And a driver must, therefore,
    ensure that no caching is performed and no read or write reordering takes place
    when accessing registers; the solution is to use special functions that actually
    do read and write operations. In the `linux/include/asm-generic/io.h` header file, we
    can find these functions, as in the following example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们不能简单地引用虚拟内存地址来从内存映射的外设中读取和写入数据的主要原因。因此，驱动程序必须确保在访问寄存器时不执行缓存操作，也不进行读取或写入重排序；解决方案是使用实际执行读写操作的特殊函数。在`linux/include/asm-generic/io.h`头文件中，我们可以找到这些函数，如以下示例所示：
- en: '[PRE31]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding functions are to write data only; you are encouraged to take a
    look at the header file to see definitions of reading functions, such as `readb()`, `readw()`, `readl()`, and `readq()`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 前述函数仅用于写入数据；您可以查看头文件以查看读取函数的定义，例如`readb()`、`readw()`、`readl()`和`readq()`。
- en: Each function is defined to be used with a well-defined data type according
    to the size of the register to be operated on; also, each of them uses memory
    barriers to instruct the CPU to execute read and write operations in a well-defined
    order.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都定义为与要操作的寄存器的大小相对应的明确定义的数据类型一起使用；此外，它们每个都使用内存屏障来指示CPU按照明确定义的顺序执行读写操作。
- en: I'm not going to explain what memory barriers are in this book; if you're curious,
    you can always read more about it in the kernel documentation directory in the `linux/Documentation/memory-barriers.txt` file
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我不打算在本书中解释内存屏障是什么；如果您感兴趣，您可以在`linux/Documentation/memory-barriers.txt`文件中的内核文档目录中阅读更多相关内容。
- en: 'As a simple example of the preceding functions, we can take a look at the `sunxi_wdt_start()`
    function within the `linux/drivers/watchdog/sunxi_wdt.c` file of Linux sources:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 作为前述功能的一个简单示例，我们可以看一下Linux源文件中`linux/drivers/watchdog/sunxi_wdt.c`文件中的`sunxi_wdt_start()`函数：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Once the register's base address, `wdt_base`, and the register's mapping `regs` have
    been obtained, we can simply perform our read and write operations by using `readl()` and `writel()`, as
    shown in the preceding section, and we can rest assured that they will be executed
    properly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦寄存器的基地址`wdt_base`和寄存器的映射`regs`已经获得，我们可以简单地通过使用`readl()`和`writel()`来执行我们的读写操作，如前面的部分所示，并且我们可以放心地确保它们将被正确执行。
- en: Spending time in the kernel
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在内核中花费时间
- en: 'In [Chapter 5](cbd6e9f7-f07c-46b8-b751-ece44101ca8b.xhtml), *Managing Interrupts
    and Concurrency*, we saw how we can defer action at a later time; however, it
    may happen that we still have to wait some time between two operations on a peripheral,
    as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](cbd6e9f7-f07c-46b8-b751-ece44101ca8b.xhtml)中，*管理中断和并发*，我们看到了如何延迟在以后的时间执行操作；然而，可能会发生这样的情况，我们仍然需要在外设上的两个操作之间等待一段时间，如下所示：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'That is, if we have to write a value into a register, then wait for 100 microseconds,
    then write another value, these operations can be done by simply using functions
    defined in the `linux/include/linux/delay.h` header file (and other ones) instead
    of using techniques presented before (kernel timers and workqueues, and so on):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，如果我们需要向寄存器中写入一个值，然后等待100微秒，然后再写入另一个值，这些操作可以通过简单地使用`linux/include/linux/delay.h`头文件（和其他文件）中定义的函数来完成，而不是使用之前介绍的技术（内核定时器和工作队列等）：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: All these functions are just used to delay for a specific amount of time expressed
    in nano, micro, or milliseconds (or just in seconds, as for `ssleep()`).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都是用于延迟一定量的时间，以纳秒、微秒或毫秒（或仅以秒为单位，如`ssleep()`）表示。
- en: The first functions set (that is, the `*delay()` functions) can be used everywhere
    in both interrupt or process context, while the second set of functions must be
    used in the process context only due to the fact they may implicitly go to sleep.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组函数（即`*delay()`函数）可以在中断或进程上下文中的任何地方使用，而第二组函数必须仅在进程上下文中使用，因为它们可能会隐式进入睡眠状态。
- en: 'Moreover, we see that, for instance, the `usleep_range()` function takes minimal
    and maximal sleep time to reduce power usage by allowing high-resolution timers
    to take advantage of an already scheduled interrupt, rather than scheduling a
    new one just for this sleep. The following is the function description in the `linux/kernel/time/timer.c` file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们看到，例如，`usleep_range()`函数采用最小和最大睡眠时间，以通过允许高分辨率定时器利用已经安排的中断来减少功耗，而不是仅为此睡眠安排新的中断。以下是`linux/kernel/time/timer.c`文件中的函数描述：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Also, in the same file we see that the `msleep_interruptible()`is a variant
    of `msleep()`, which can be interrupted by a signal (in *Waiting for an event*
    recipe, in [Chapter 5](cbd6e9f7-f07c-46b8-b751-ece44101ca8b.xhtml), *Managing
    Interrupts and Concurrency,* we talked about this possibility) and the return
    value is simply the time in milliseconds not slept due to the interruption:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在同一文件中，我们看到`msleep_interruptible()`是`msleep()`的变体，可以被信号中断（在*等待事件*配方中，在[第5章](cbd6e9f7-f07c-46b8-b751-ece44101ca8b.xhtml)中，*管理中断和并发性*，我们谈到了这种可能性），返回值只是由于中断而未睡眠的时间（以毫秒为单位）：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, we should also notice the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还应该注意以下内容：
- en: '`*delay()` functions use the jiffy estimation of clock speed (`loops_per_jiffy` value) and
    will busy wait for enough loop cycles to achieve the desired delay.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*delay()`函数使用时钟速度的jiffy估计（`loops_per_jiffy`值），并将忙等待足够的循环周期以实现所需的延迟。'
- en: '`*delay()` functions may return early in case of too low computed `loops_per_jiffy` (due
    to the time taken to execute the timer interrupt), or cache behavior affecting
    the time it takes to execute the loop function, or due to CPU clock rate changes.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*delay()`函数可能会在计算出的`loops_per_jiffy`太低（由于执行定时器中断所需的时间）或者缓存行为影响执行循环函数所需的时间，或者由于CPU时钟速率的变化而提前返回。'
- en: '`udelay()` is the generally preferred API, and `ndelay()`''s level precision
    may not actually exist on many non-PC devices.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`udelay()`是通常首选的API，`ndelay()`的级别精度实际上可能不存在于许多非PC设备上。'
- en: '`mdelay()` is a macro wrapper around `udelay()`, to account for possible overflow
    when passing large arguments to `udelay()`. That''s why the usage of `mdelay()` is
    discouraged and the code should be refactored to allow for the use of `msleep()`.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mdelay()`是对`udelay()`的宏包装，以考虑将大参数传递给`udelay()`时可能发生的溢出。这就是为什么不建议使用`mdelay()`，代码应该重构以允许使用`msleep()`。'
