- en: Error Checking and Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误检查和处理
- en: 'In this chapter, we will describe how we can check for errors and handle them
    gracefully. We will start by explaining the exit status concept, followed by a
    number of functional checks with the `test` command. After that, we will start
    using shorthand notation for `test` command. The next part of this chapter is
    dedicated to error handling: we will use `if-then-exit` and `if-then-else` to
    handle simple errors. In the final part of this chapter, we will present some
    ways in which we can prevent errors from occurring in the first place, since prevention
    is better than remediation.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述如何检查错误并优雅地处理它们。我们将首先解释退出状态的概念，然后进行一些使用`test`命令的功能检查。之后，我们将开始使用`test`命令的简写表示法。本章的下一部分专门讨论错误处理：我们将使用`if-then-exit`和`if-then-else`来处理简单的错误。在本章的最后部分，我们将介绍一些可以防止错误发生的方法，因为预防胜于治疗。
- en: 'The following commands will be introduced in this chapter: `mktemp`, `true`,
    and `false`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下命令：`mktemp`，`true`和`false`。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Error checking
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误检查
- en: Error handling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Error prevention
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误预防
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Only the Ubuntu virtual machine is needed for this chapter. If you have never
    updated your machine, now might be a good time! The `sudo apt update && sudo apt
    upgrade -y` command upgrades your machine with all tools completely. If you choose
    to do this, make sure that you reboot your machine so that upgraded kernels are
    loaded. On Ubuntu, if the` /var/log/reboot-required` file is present, you can
    be sure a reboot is, well, *required*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章只需要Ubuntu虚拟机。如果您从未更新过您的机器，现在可能是一个好时机！`sudo apt update && sudo apt upgrade
    -y`命令会完全升级您的机器上的所有工具。如果您选择这样做，请确保重新启动您的机器，以加载升级后的内核。在Ubuntu上，如果存在`/var/log/reboot-required`文件，您可以确定需要重新启动。
- en: 'All scripts for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter09](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter09).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有脚本都可以在GitHub上找到：[https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter09](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter09)。
- en: Error checking
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误检查
- en: 'In the previous chapter, we spent some time explaining how we could capture
    and use *user input* in our scripts. While this makes our scripts much more dynamic
    and, by extension, much more practical, we also introduce a new concept: **human
    error.** Let''s say you''re writing a script where you want to present the user
    with a yes/no question. You might expect a reasonable user to use any of the following
    as an answer:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们花了一些时间解释了如何在脚本中捕获和使用*用户输入*。虽然这使得我们的脚本更加动态，从而更加实用，但我们也引入了一个新概念：**人为错误**。假设您正在编写一个脚本，您希望向用户提出一个是/否问题。您可能期望一个合理的用户使用以下任何一个作为答案：
- en: y
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: y
- en: n
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: n
- en: Y
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是
- en: N
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否
- en: 'Yes'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是
- en: 'No'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否
- en: 'yes'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是
- en: 'no'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不
- en: 'YES'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'YES'
- en: 'NO'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否
- en: 'While Bash allows us to check for all values we can think of, sometimes a user
    will still be able to *break* the script by supplying input you do not expect.
    An example of this would be the user answering the yes/no question in their native
    language: `ja`, `si`, `nei`, or any of the countless other possibilities. In practice,
    you will find that you can *never* think of every possible input a user will provide.
    That being the way it is, the best solution is to handle the most common expected
    input, and catch all other input with a generic error message which tells the
    user *how to correctly supply the answer*. We''ll see how we can do that later
    on in this chapter, but first, we''ll start by looking at how we can even determine
    if an error has occurred by checking the **exit status** of a command.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Bash允许我们检查我们能想到的所有值，但有时用户仍然可以通过提供您不希望的输入来*破坏*脚本。例如，用户用他们的母语回答是/否问题：`ja`，`si`，`nei`，或者其他无数的可能性。实际上，您会发现您*永远*无法考虑到用户提供的每种可能的输入。鉴于事实如此，最好的解决方案是处理最常见的预期输入，并用通用错误消息捕获所有其他输入，告诉用户*如何正确提供答案*。我们将在本章后面看到如何做到这一点，但首先，我们将开始查看如何甚至确定是否发生了错误，通过检查命令的**退出状态**。
- en: Exit status
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 退出状态
- en: 'The exit status, commonly also referred to as *exit codes* or *return codes*,
    is the way Bash communicates the successful or unsuccessful termination of a process
    to its parent. In Bash, all processes are *forked* from the shell that calls them.
    The following diagram illustrates this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 退出状态，通常也称为*退出代码*或*返回代码*，是Bash向其父进程通信进程成功或不成功终止的方式。在Bash中，所有进程都是从调用它们的shell中*fork*出来的。以下图解释了这一点：
- en: '![](img/ee93b0e8-d32a-41ec-ace1-c7e41a598265.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee93b0e8-d32a-41ec-ace1-c7e41a598265.png)'
- en: When a command runs, such as `ps -f` in the preceding diagram, the current shell
    is copied (including the environment variables!), and the command runs in the
    copy, called the *fork*. After the command/process is done, it terminates the
    fork and returns the exit status to the shell that it was initially forked from
    (which, in the case of an interactive session, will be your user session). At
    that point, you can determine whether the process was executed successfully by
    looking at the exit code. As explained in the previous chapter, an exit code of
    0 is considered OK, while all other codes should be treated as NOT OK. Because
    the fork is terminated, we need the return code, otherwise we will have no way
    of communicating the status back to our session!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当命令运行时，例如前面图中的`ps -f`，当前shell被复制（包括环境变量！），命令在副本中运行，称为*fork*。命令/进程完成后，它终止fork并将退出状态返回给最初从中fork出来的shell（在交互会话的情况下，将是您的用户会话）。在那时，您可以通过查看退出代码来确定进程是否成功执行。如前一章所述，退出代码为0被认为是OK，而所有其他代码应被视为NOT
    OK。由于fork被终止，我们需要返回代码，否则我们将无法将状态传递回我们的会话！
- en: 'Because we have already seen how to grab the exit status in an interactive
    session in the previous chapter (hint: we looked at the content of the `$?` variable!),
    let''s see how we can do the same in a script:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经在上一章的交互式会话中看到了如何获取退出状态（提示：我们查看了`$?`变量的内容！），让我们看看如何在脚本中做同样的事情：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Going through the script, we start with the shebang and header. Since we don''t
    use user input in this script, the usage is just the script name. The first command
    we run is `mktemp`. This command is used to create a temporary *file* with a random
    name, which could be useful is we needed to have a place on disk for some temporary
    data. Alternatively, if we supplied the `-d` flag to `mktemp`, we would create
    a temporary *directory* with a random name. Because the random name is sufficiently
    long and we should always have write permissions in `/tmp/`, we would expect the
    `mktemp` command to almost always succeed and thus return an exit status of 0\.
    We save the return code to the `mktemp_rc` variable by running the variable assignment
    **directly after the command**. In that lies the biggest weakness with return
    codes: we only have them available directly after the command completes. If we
    do anything else after, the return code will be set for that action, overwriting
    the previous exit status!'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过脚本，我们从shebang和header开始。由于在此脚本中我们不使用用户输入，因此用法只是脚本名称。我们运行的第一个命令是`mktemp`。这个命令用于创建一个具有随机名称的临时*文件*，如果我们需要在磁盘上有一个临时数据的地方，这可能会很有用。或者，如果我们向`mktemp`提供了`-d`标志，我们将创建一个具有随机名称的临时*目录*。因为随机名称足够长，并且我们应该始终在`/tmp/`中有写权限，我们期望`mktemp`命令几乎总是成功的，因此返回退出状态为0。我们通过在命令**直接完成后**运行变量赋值来将返回代码保存到`mktemp_rc`变量中。这就是返回代码的最大弱点所在：我们只能在命令完成后直接使用它们。如果我们在之后做任何其他事情，返回代码将被设置为该操作，覆盖先前的退出状态！
- en: 'Next, we run a command which we expect to always fail: `mkdir /home/`. The
    reason we expect this to fail is because on our system (and on pretty much every
    Linux system), the `/home/` directory already exists. In this case, it cannot
    be created again, which is why the command fails with an exit status of 1\. Again,
    directly after the `mkdir` command, we save the exit status into the `mkdir_rc`
    variable.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们运行一个我们期望总是失败的命令：`mkdir /home/`。我们期望它失败的原因是因为在我们的系统上（以及几乎每个Linux系统上），`/home/`目录已经存在。在这种情况下，它无法再次创建，这就是为什么该命令以退出状态1失败。同样，在`mkdir`命令之后，我们将退出状态保存到`mkdir_rc`变量中。
- en: 'Finally, we need to check to see whether our assumptions are correct. Using
    `echo`, we print the values of both variables along with some text so that we
    know where we printed which value. One last thing to note here: we used *double
    quotes* for our sentence containing variables. If we used *single quotes*, the
    variables would not be *expanded* (the Bash term for substituting the variable
    name with its value). Alternatively, we could omit the quotes altogether, and
    `echo` would perform as desired as well, however that could start presenting issues
    when we start working with redirection, which is why we consider it good form
    to always use double quotes when dealing with strings containing variables.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要检查我们的假设是否正确。使用`echo`，我们打印两个变量的值以及一些文本，以便知道我们在哪里打印了哪个值。这里还有一件事要注意：我们在包含变量的句子中使用了*双引号*。如果我们使用*单引号*，变量将不会被*展开*（Bash术语是用变量的值替换变量名）。或者，我们可以完全省略引号，`echo`也会按预期执行，但是当我们开始使用重定向时，这可能会开始出现问题，这就是为什么我们认为在处理包含变量的字符串时始终使用双引号是一个好习惯。
- en: Functional checks
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能检查
- en: Now, we know how we can check the exit status of a process to determine if it
    was successful. However, that is not the only way we can validate the success/failure
    of commands. For most commands that we run, we could also perform a functional
    check to see if we were successful. In the previous script, we tried to create
    the `/home/` directory. But what if we were more concerned with the existence
    of the `/home/` directory, instead of the exit status of the process?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道如何检查进程的退出状态以确定它是否成功。然而，这并不是我们验证命令成功/失败的唯一方法。对于我们运行的大多数命令，我们还可以执行功能检查以查看我们是否成功。在上一个脚本中，我们尝试创建`/home/`目录。但是，如果我们更关心`/home/`目录的存在，而不是进程的退出状态呢？
- en: 'The following script shows how we can perform *functional checks* on the state
    of our system:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本显示了我们如何对系统状态执行*功能检查*：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We start the preceding script with the usual plumbing. Next, we want to create
    a directory with `mkdir`. We grab the exit status and store it in a variable.
    Next, we use the `test` command (which we briefly explored in the previous chapter)
    to validate whether `/tmp/temp_dir/` is a directory (and thus, if it was created
    **sometime**). We then print the return codes with `echo`, in the same fashion
    as we did for return-code.sh.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从通常的管道开始前面的脚本。接下来，我们想用`mkdir`创建一个目录。我们获取退出状态并将其存储在一个变量中。接下来，我们使用`test`命令（我们在上一章中简要探讨过）来验证`/tmp/temp_dir/`是否是一个目录（因此，如果它被创建了**某个时间**）。然后，我们用`echo`打印返回代码，方式与我们在return-code.sh中做的一样。
- en: Next, we run the script twice. Here is where something interesting happens.
    The first time we run the script, the `/tmp/temp_dir/` directory does not exist
    on the filesystem and is created. Because of this, the exit code for the `mkdir`
    command is 0\. Since it was successfully created, `test -d` also succeeds and
    gives us back an exit status of 0, as expected.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们运行脚本两次。这里发生了一些有趣的事情。第一次运行脚本时，文件系统上不存在`/tmp/temp_dir/`目录，因此被创建。因此，`mkdir`命令的退出代码为0。由于它成功创建了，`test
    -d`也成功，并像预期的那样给我们返回了退出状态0。
- en: 'Now, in the second run of the script, the `mkdir` command does not successfully
    complete. This is expected, because the first run of the script already created
    the directory. Since we did not delete it in between the runs, the second run
    of `mkdir` is unsuccessful. However, `test -d` still runs fine: **the directory
    exists**, even though it was not created in that run of the script.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在脚本的第二次运行中，`mkdir`命令并没有成功完成。这是预期的，因为脚本的第一次运行已经创建了该目录。由于我们没有在两次运行之间删除它，`mkdir`的第二次运行是不成功的。然而，`test
    -d`仍然可以正常运行：**目录存在**，即使它并没有在脚本的那次运行中创建。
- en: 'When creating scripts, make sure you think long and hard about how you want
    to check for errors. Sometimes, return codes will be what you need: this is the
    case when you need to be sure that the command has been run successfully. Other
    times, however, a functional check might be a better fit. This is often the case
    when it is the end result that matters (for example, a directory must exist),
    but it does not matter so much what caused the desired state.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建脚本时，请确保仔细考虑如何检查错误。有时，返回代码是你需要的：当你需要确保命令已成功运行时就是这种情况。然而，有时功能性检查可能更合适。当最终结果很重要时（例如，目录必须存在），但造成所需状态的原因并不那么重要时，这通常是情况。
- en: Test shorthand
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试简写
- en: 'The `test` command is one of the most important commands we have in our shell
    scripting arsenal. Because shell scripts can often be fragile, especially where
    user input is concerned, we want to make these as robust as possible. While explaining
    every aspect of the `test` command would take a whole chapter, the following are
    the things `test` can do:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`命令是我们shell脚本工具中最重要的命令之一。因为shell脚本经常很脆弱，特别是涉及用户输入时，我们希望尽可能使其健壮。虽然解释`test`命令的每个方面需要一整章，但以下是`test`可以做的事情：'
- en: Check whether a file exists
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查文件是否存在
- en: Check whether a directory exists
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查目录是否存在
- en: Check whether a variable is not empty
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查变量是否不为空
- en: Check whether two variables have the same values
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查两个变量是否具有相同的值
- en: Check whether FILE1 is older than FILE2
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查FILE1是否比FILE2旧
- en: Check whether INTEGER1 is greater than INTEGER2
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查INTEGER1是否大于INTEGER2
- en: And so on and on and on—this should give you at least an impression of things
    you can check with `test`. In the *Further reading* section, we have included
    an extensive source on test. Make sure to give it a look, as it will definitely
    help in your shell scripting adventures!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 等等等等——这应该至少让你对可以用`test`检查的事情有所印象。在*进一步阅读*部分，我们包含了有关测试的广泛来源。确保看一看，因为它肯定会帮助你进行shell脚本编写冒险！
- en: 'For most scripting and programming languages, there is no such thing as a `test`
    command. Obviously, tests are just as important in those languages but, unlike
    Bash, tests are often directly integrated with the `if-then-else` logic (which
    we will discuss in the next part of this chapter). Luckily for us, Bash has a
    shorthand for the `test` command, which brings it a lot closer to the syntax of
    other languages: `[` and `[[`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数脚本和编程语言，没有`test`命令这样的东西。显然，在这些语言中测试同样重要，但与Bash不同的是，测试通常直接与`if-then-else`逻辑集成在一起（我们将在本章的下一部分讨论）。幸运的是，Bash有一个`test`命令的简写，这使它与其他语言的语法更接近：`[`和`[[`。
- en: 'Look at the following code to get a better idea of how we can replace the `test`
    command with this shorthand:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码，以更好地了解我们如何用这种简写替换`test`命令：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, after the plumbing we started with the previously introduced
    `test` syntax. Next, we replaced the word test with `[`, and ended the line with `]`.
    This is the part that Bash has in common with other scripting/programming languages.
    Note that, unlike most languages, Bash requires a **whitespace after [ and before
    ]**! Finally, we used the extended shorthand syntax, starting with `[[` and ending
    with `]]`. When we print the return codes, they all return `0`, which means that
    all tests succeeded, even with the different syntaxes.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在我们介绍的`test`语法之后，我们开始进行管道操作。接下来，我们用`[`替换了test这个词，并以`]`结束了这一行。这是Bash与其他脚本/编程语言共有的部分。请注意，与大多数语言不同，Bash要求在`[`之后和`]`之前有**空格**！最后，我们使用了扩展的简写语法，以`[[`开头，以`]]`结尾。当我们打印返回代码时，它们都返回`0`，这意味着所有测试都成功了，即使使用了不同的语法。
- en: 'The difference between [ ] and [[ ]] is minor, but can be very important. Simply
    said, the simple shorthand syntax of [ ] can introduce problems when variables
    or paths have whitespace in them. In this case, the test considers the whitespace
    the delimiter, which means the string `hello there` becomes two arguments instead
    of one (`hello + there`). There are other differences, but in the end our advice
    is really simple: **use the extended shorthand syntax of [[ ]]**. For more information,
    see the *Further reading* section on test.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[ ]和[[ ]]之间的区别很小，但可能非常重要。简单地说，[ ]的简写语法在变量或路径中包含空格时可能会引入问题。在这种情况下，测试会将空格视为分隔符，这意味着字符串`hello
    there`变成了两个参数而不是一个（`hello + there`）。还有其他区别，但最终我们的建议非常简单：**使用[[ ]]的扩展简写语法**。有关更多信息，请参阅测试部分的*进一步阅读*。'
- en: Variable refresher
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量复习
- en: 'As a little bonus, we have a slight improvement for the `test-shorthand.sh`
    script. In the previous chapter, we explained that, if we have to use the same
    value multiple times in a script, we''re better off making it a variable. If the
    value of the variable does not change during the script''s execution and is not
    influenced by user input, we use a CONSTANT. Take a look at how we would incorporate
    that in our previous script:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个小小的奖励，我们对`test-shorthand.sh`脚本进行了轻微改进。在上一章中，我们解释了，如果我们在脚本中多次使用相同的值，最好将其作为变量。如果变量的值在脚本执行过程中不会改变，并且不受用户输入的影响，我们使用一个常量。看看我们如何在之前的脚本中加入这个：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While the end result is the same, this script is more robust if we ever want
    to change it. Furthermore, it shows us that we can use variables in the `test`
    shorthand, which will automatically be expanded by Bash.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最终结果是相同的，但如果我们想要更改它，这个脚本更加健壮。此外，它向我们展示了我们可以在`test`简写中使用变量，这些变量将自动被Bash展开。
- en: Bash debugging
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bash调试
- en: 'We have one more trick up our sleeve to prove that values are expanded properly:
    running the Bash script **with debug logging**. Look at the following execution:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个更聪明的方法来证明值是否被正确展开：使用Bash脚本**带有调试日志**运行。看一下以下执行：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you compare this to the actual script, you will see that the script text
    `test -d ${DIRECTORY}` is resolved to `test -d /tmp/` at runtime. This is because,
    instead of running `bash test-shorthand-variable.sh`, we're running `bash -x test-shorthand-variable.sh`.
    In this case, the `-x` flag tells Bash to *print commands and their arguments
    as they are executed—*a very handy thing to remember if you're ever building scripts
    and unsure why the script is not doing what you expect it to do!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将此与实际脚本进行比较，您将看到脚本文本`test -d ${DIRECTORY}`在运行时解析为`test -d /tmp/`。这是因为我们没有运行`bash
    test-shorthand-variable.sh`，而是运行`bash -x test-shorthand-variable.sh`。在这种情况下，`-x`标志告诉Bash*打印命令及其参数在执行时*——这是一个非常方便的事情，如果您曾经编写脚本并不确定为什么脚本没有按照您的期望执行！
- en: Error handling
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'So far, we have looked at how we can check for errors. However, besides checking
    for errors, there is an aspect to this which is just as important: handling errors.
    We''ll initially combine our previous experience with `if` and `test` to exit
    on errors, before we go on to introduce much smarter ways to handle errors!'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何检查错误。然而，除了检查错误之外，还有一个同样重要的方面：处理错误。我们将首先结合我们以前的`if`和`test`的经验来处理错误，然后介绍更智能的处理错误的方法！
- en: if-then-exit
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if-then-exit
- en: As you might recall from the previous chapter, the `if-then` construct used
    by Bash is common to (almost) all programming languages. In its basic form, the
    idea is that you test for a condition (IF), and if that condition is true, you
    do something (THEN).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能还记得的，Bash使用的`if-then`结构对（几乎）所有编程语言都是通用的。在其基本形式中，想法是您测试一个条件（IF），如果该条件为真，则执行某些操作（THEN）。
- en: 'Here''s a very basic example: if `name` is longer than or equal to 2 characters,
    then `echo "hello ${name}"`. In this case, we assume that a name has to be, at
    the very least, 2 characters. If it is not, the input is invalid and we do not
    give it a "hello".'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本的例子：如果`name`的长度大于或等于2个字符，则`echo "hello ${name}"`。在这种情况下，我们假设一个名字至少要有2个字符。如果不是，输入是无效的，我们不会给它一个“hello”。
- en: 'In the following script, `if-then-exit.sh`, we will see that our goal is to
    print the contents of a file using `cat`. However, before we do that, we check
    if the file exists, and if it doesn''t, we exit the script with a message to the
    caller that specifies what went wrong:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的脚本`if-then-exit.sh`中，我们将看到我们的目标是使用`cat`打印文件的内容。然而，在这之前，我们检查文件是否存在，如果不存在，我们将退出脚本，并向调用者显示指定出了什么问题的消息：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Most of this script should be clear by now. We used the *extended shorthand
    syntax* for the test, as we will do in the rest of this book. The `-f` flag is
    described in the man page of `test` as *FILE exists and is a regular file*. However,
    we ran into a little issue here: we want to print the file (with `cat`), but only
    if the file exists; otherwise, we want to print the message with `echo`. Later
    in this chapter, when we introduce `if-then-else`, we''ll see how we can do this
    with a positive test. At the moment though, we want the test to give us a TRUE
    if the file we''re checking **is not** an existing file. In this case, semantically
    speaking, we''re doing the following: IF the file does not exist, THEN print a
    message and EXIT. The test syntax in Bash does not have a flag for this. There
    is, luckily, one powerful construct we can use: the exclamation mark, !, which
    negates/reverses the test!'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这个脚本应该是清楚的。我们使用了测试的*扩展简写语法*，就像我们在本书的其余部分中所做的那样。`-f`标志在`test`的man页面中被描述为*文件存在且是一个常规文件*。然而，在这里我们遇到了一个小问题：我们想要打印文件（使用`cat`），但只有在文件存在时才这样做；否则，我们想要使用`echo`打印消息。在本章后面，当我们介绍`if-then-else`时，我们将看到如何使用正测试来实现这一点。不过，目前我们希望测试在我们检查的文件**不是**一个现有文件时给我们一个TRUE。在这种情况下，从语义上讲，我们正在做以下事情：如果文件不存在，则打印一条消息并退出。Bash中的测试语法没有一个标志可以做到这一点。幸运的是，我们可以使用一个强大的构造：感叹号，！，它可以对测试进行否定/反转！
- en: 'Some examples of this are as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例如下：
- en: if [[ -f /tmp/file ]]; then *do-something* -> *do-something* is executed if
    the file /tmp/file exists
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: if [[-f /tmp/file]]; then *做某事* -> 如果文件/tmp/file存在，则执行*做某事*
- en: if [[ ! -f /tmp/file ]]; then *do-something* -> *do-something* is executed if
    the file /tmp/file **does not** exist
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: if [[！-f /tmp/file]]; then *做某事* -> 如果文件/tmp/file不存在，则执行*做某事*
- en: if [[ -n ${variable} ]]; then *do-something* -> *do-something* is executed if
    the variable ${variable} is not empty
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: if [[-n ${variable}]]; then *做某事* -> 如果变量${variable}不为空，则执行*做某事*
- en: if [[ ! -n ${variable} ]]; then *do-something* -> *do-something* is executed
    if the variable ${variable} is **not** not empty (so, the double negative means
    do-something is only executed if the variable is in fact empty)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: if [[！-n ${variable}]]; then *做某事* -> 如果变量${variable}**不**为空，则执行*做某事*（因此，双重否定意味着只有在变量实际为空时才执行do-something）
- en: if [[ -z ${variable} ]]; then *do-something* -> *do-something* is executed if
    the variable ${variable} is empty
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: if [[-z ${variable}]]; then *做某事* -> 如果变量${variable}为空，则执行*做某事*
- en: if [[ ! -z ${variable} ]]; then *do-something* -> *do-something* is executed
    if the variable ${variable} is **not** empty
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: if [[！-z ${variable}]]; then *做某事* -> 如果变量${variable}**不**为空，则执行*做某事*
- en: As you should be aware, the last four examples overlap. This is because the
    flags `-n` (nonzero) and `-z` (zero) are already each other's opposites. Since
    we can negate the test with !, this means that `-z` is equal to `! -n`, and `!
    -z` is the same as `-n`. In this case, it would not matter if you used `-n` or
    ! `-z`. We would advise you to use the specific flag if it is available, before
    using a negation with another flag.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你应该知道的那样，最后四个例子是重叠的。这是因为标志`-n`（非零）和`-z`（零）已经是彼此的对立面。由于我们可以用!否定测试，这意味着`-z`等于`!
    -n`，而`! -z`与`-n`相同。在这种情况下，使用`-n`或!`-z`都无关紧要。我们建议您在使用另一个标志的否定之前，先使用特定的标志。
- en: Let's get back to our script. When we found that the file did not exist by using
    the negated file exists test, we then printed the helpful message to the caller
    and exited the script. In this case, we never reached the `cat` command, but since
    the file does not exist anyway, the `cat` would never have succeeded. If we'd
    let the execution continue to that point, we would be presented with an error
    message by `cat`. In the case of `cat`, this message is no worse than our own
    message, but for some other commands, error messages are definitely not always
    as clear as we'd like; in this case, a check of our own with a clear message is
    not a bad thing!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的脚本。当我们使用否定的文件存在测试发现文件不存在时，我们向调用者打印了有用的消息并退出了脚本。在这种情况下，我们从未达到`cat`命令，但由于文件根本不存在，`cat`永远不会成功。如果我们让执行继续到那一点，我们将收到`cat`的错误消息。对于`cat`来说，这条消息并不比我们自己的消息更糟糕，但对于其他一些命令来说，错误消息绝对不总是像我们希望的那样清晰；在这种情况下，我们自己的检查并附上清晰的消息并不是一件坏事！
- en: 'Here''s another example, where we use if and test to look at the status code
    which we''ll catch in a variable:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一个例子，我们在其中使用if和test来查看我们将在变量中捕获的状态代码：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the first functional part of this script, we tried to create the top-level
    directory `/temporary_dir/`. Since only root has these privileges, and we''re
    neither running this as the root user nor with `sudo`, the `mkdir` fails. When
    we catch the exit status in the `mkdir_rc` variable, we do not know the exact
    value (we could print it if we wanted it), but we know one thing for sure: it
    is not `0`, which is reserved for successful execution. So, we have two options
    here: we can check if the exit status *is not equal to 0*, or if the status code
    *is equal to 1* (which is actually what `mkdir` reports back to the parent shell
    in this case). We generally prefer **checking for the absence of success**, instead
    of checking for a specific type of failure (as denoted by different return codes,
    such as 1, 113, 127, 255, and so on). If we only stop on an exit code of 1, we
    would continue the script in all cases where we do not get a 1: this would hopefully
    be a 0, but we''re not sure of that. And, in general, anything that is not successful
    warrants stopping a script!'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的第一个功能部分中，我们试图创建顶层目录`/temporary_dir/`。由于只有root用户拥有这些特权，而我们既不是以root用户身份运行，也没有使用`sudo`，所以`mkdir`失败了。当我们在`mkdir_rc`变量中捕获退出状态时，我们不知道确切的值（如果需要，我们可以打印它），但我们知道一件事：它不是`0`，这个值是保留用于成功执行的。因此，我们有两个选择：我们可以检查退出状态是否**不等于0**，或者状态代码是否**等于1**（这实际上是`mkdir`在这种情况下向父shell报告的）。我们通常更喜欢**检查成功的缺席**，而不是检查特定类型的失败（如不同的返回代码，如1、113、127、255等）。如果我们只在退出代码为1时停止，那么我们将在所有不得到1的情况下继续脚本：这有希望是0，但我们不能确定。总的来说，任何不成功的事情都需要停止脚本！
- en: 'For this situation, checking if the return code is not `0`, we''re using an
    integer (remember, a fancy word for *number*) comparison. If we check `man test`,
    we can see that the `-ne` flag is described as `INTEGER1 -ne INTEGER2: INTEGER1
    is not equal to INTEGER2`. So, for our logic, that would mean that, if the return
    code caught in the variable is **n**ot **e**qual to `0`, the command did not succeed
    successfully and we should stop. Remember that we could also use the `-eq` (**eq**ual
    to) flag and negate it with `!` for the same effect.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，检查返回代码是否不是`0`，我们使用整数（记住，*数字*的一个花哨的词）比较。如果我们检查`man test`，我们可以看到`-ne`标志被描述为`INTEGER1
    -ne INTEGER2：INTEGER1不等于INTEGER2`。因此，对于我们的逻辑，这意味着，如果在变量中捕获的返回代码**不等于**`0`，命令就没有成功执行，我们应该停止。记住，我们也可以使用`-eq`（**等于**）标志，并用`!`否定它以达到相同的效果。
- en: 'In its current form, the script is a little longer than it strictly needs to
    be. We first store the return code in a variable, and then we compare that variable.
    What we can also do is directly use the exit status in the `if-test` construction,
    like so:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前形式中，脚本比严格需要的要长一点。我们首先将返回代码存储在一个变量中，然后再比较该变量。我们还可以直接在`if-test`结构中使用退出状态，就像这样：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'While this *only* saves us a single line (the variable assignment), it also
    saves us an unnecessary variable. You can see that we changed the test to comparing
    0 to $?. We know that we want to check the execution anyway, so we might as well
    do it right away. Should we need to do it later, we would still need to save it
    in a variable, because remember: the exit status is only available directly after
    running a command. After that point, it has been overridden by the exit status
    of later commands.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这*只*节省了一行（变量赋值），但也节省了一个不必要的变量。你可以看到我们将测试改为比较0和$?。我们知道无论如何我们都想检查执行，所以我们也可以立即这样做。如果以后需要再做，我们仍然需要将其保存在一个变量中，因为记住：退出状态只在运行命令后直接可用。在那之后，它已经被后续命令的退出状态覆盖了。
- en: if-then-else
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if-then-else
- en: 'By now, you''ll hopefully have a feeling for how useful `if-then` logic is.
    However, you might feel like something is missing still. If that is the case,
    you would be right! An `if-then` construct is not complete without the ELSE statement.
    The `if-then-else` construct allows us to specify what should happen if the test
    in the if-clause does **not** equal true. Semantically, it could be translated
    as:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经对`if-then`逻辑有了一些了解。然而，你可能觉得还缺少了一些东西。如果是这样，你是对的！一个`if-then`结构没有ELSE语句是不完整的。`if-then-else`结构允许我们指定如果if子句中的测试**不**为真时应该发生什么。从语义上讲，它可以被翻译为：
- en: IF condition, THEN do-something, ELSE (otherwise) do-something-else
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件，那么做某事，否则（其他情况）做其他事情
- en: 'We can illustrate this very easily by taking one of our earlier scripts, `if-then-exit.sh`,
    and optimizing both the flow of the script and the code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过拿我们之前的一个脚本`if-then-exit.sh`来很容易地说明这一点，并优化脚本的流程和代码：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, this is starting to look like something! We moved our `cat` command into
    the `if-then-else` logic block. Now, it feels (and is!) like a single command:
    if the file does not exist, print an error message and exit, otherwise, print
    its contents. It is a little weird that we used the then block for the error situation,
    though; by convention, that is reserved for the success condition. We can make
    our script a little more intuitive by swapping the then and else blocks; however,
    we will also need to invert our test condition. Let''s take a look:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这开始看起来像是一些东西！我们将`cat`命令移到了`if-then-else`逻辑块中。现在，它感觉（而且确实是！）像一个单一的命令：如果文件不存在，则打印错误消息并退出，否则打印其内容。不过，我们在错误情况下使用了then块有点奇怪；按照惯例，then块是为成功条件保留的。我们可以通过交换then和else块来使我们的脚本更加直观；但是，我们还需要反转我们的测试条件。让我们来看一下：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The changes we made in this script are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个脚本中所做的更改如下：
- en: We replaced the hard-coded FILE constant with a user input variable `file_name`
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们用用户输入变量`file_name`替换了硬编码的FILE常量
- en: We removed the ! which inverts the `test`
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们去掉了`test`的!反转
- en: We swapped the then and else execution blocks
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们交换了then和else执行块
- en: 'As it is now, the script first checks if the file exists, and if it does, it
    prints its contents (success scenario). If the file does not exist, the script
    prints an error message and exits with an exit code of 1 (failure scenario). In
    practice, `else` is often reserved for failure scenarios, and `then` for the success
    scenario. However, these are not golden rules and could differ, based on the types
    of test you have available. If you''re ever writing a script and you want to use
    the else block for the success scenario, go right ahead: as long as you''re sure
    it''s the right choice for your situation, there is definitely no shame in it!'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，脚本首先检查文件是否存在，如果存在，则打印其内容（成功场景）。如果文件不存在，脚本将打印错误消息并以退出代码1退出（失败场景）。在实践中，`else`通常用于失败场景，`then`用于成功场景。但这并不是铁律，可能会有所不同，根据您可用的测试类型。如果您正在编写脚本，并且希望使用else块来处理成功场景，那就尽管去做：只要您确定这是您情况下的正确选择，绝对没有什么可耻的！
- en: 'You might have noticed that within an `if-then-else` block, the commands we
    execute in then or else are always preceded by two whitespaces. In scripting/programming,
    this is called indenting. It serves only a single function in Bash: to improve
    readability. By indenting those commands with two spaces, we know they''re part
    of the then-else logic. In that same manner, it is much easier to see where the
    `then` ends and the `else` begins. Note that, in some languages, notably Python,
    whitespace is part of the programming language syntax and cannot be omitted!'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在`if-then-else`块中，我们在then或else中执行的命令之前始终有两个空格。在脚本/编程中，这称为缩进。在Bash中，它只有一个功能：提高可读性。通过用两个空格缩进这些命令，我们知道它们是then-else逻辑的一部分。同样，很容易看到`then`在哪里结束，`else`在哪里开始。请注意，在某些语言中，特别是Python，空白是编程语言语法的一部分，不能省略！
- en: 'Until this point, we have only used `if-then-else` logic for error detection,
    followed by an exit `1`. However, in some cases, both *then* and *else* can be
    used to accomplish the goal of the script, instead of one of them being used for
    error handling. Take a look at the following script:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用`if-then-else`逻辑来检测错误，然后退出`1`。然而，在某些情况下，*then*和*else*都可以用来实现脚本的目标，而不是其中一个用于错误处理。看一下以下脚本：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We use this script to make sure that a file exists and is empty. Basically,
    there are two scenarios: the file exists (and *might* not be empty) or it does
    not exist. In our **if** test, we check to see if the file exists. If it does,
    we replace it with an empty file by copying `/dev/null` (which is always empty)
    to the location given by the user. Otherwise, if the file does not exist, we simply
    create it using `touch`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用此脚本来确保文件存在且为空。基本上，有两种情况：文件存在（*可能*不为空）或不存在。在我们的**if**测试中，我们检查文件是否存在。如果存在，我们通过将`/dev/null`（始终为空）复制到用户给定的位置来用空文件替换它。否则，如果文件不存在，我们只需使用`touch`创建它。
- en: As you can see in the script's execution, the first time we run this script,
    the file does not exist and is created with `touch`. In the next run of the script,
    directly after, the file does exist (since it was created in the first run). This
    time, we can see in the debug that `cp` is used. Because we want to make sure
    whether either of these actions succeeded, we include an extra **if** block, which
    handles exit status checking, as we have seen before.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在脚本执行中所看到的，第一次运行此脚本时，文件不存在，并且使用`touch`创建。在直接之后的脚本运行中，文件存在（因为它是在第一次运行中创建的）。这次，我们可以看到`cp`被使用。因为我们想确保这些操作中的任何一个是否成功，我们包含了额外的**if**块，用于处理退出状态检查，就像我们以前看到的那样。
- en: Shorthand syntax
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简写语法
- en: 'By now, we''ve seen a few uses of an if block to see if our previous commands
    ran successfully. While the functionality is great, using 5-7 lines after each
    command where you suspect errors could occur really adds to the total script length!
    Even more of an issue will be readability: if half the script is error checking,
    it might be very hard to get to the bottom of the code. Fortunately, there is
    a way in which we can check for errors directly after a command. We can accomplish
    this with the || command, which is the Bash version of a logical OR. Its counterpart,
    &&, is the implementation of a logical AND. To illustrate this, we''ll introduce
    two new commands: `true` and `false`. If you take a look at the respective man
    pages, you''ll find the clearest answer you can possibly get:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了使用 if 块来查看我们之前的命令是否成功运行的一些用法。虽然功能很棒，但在每个可能发生错误的命令之后使用 5-7 行真的会增加脚本的总长度！更大的问题将是可读性：如果一半的脚本是错误检查，可能很难找到代码的底部。幸运的是，我们可以在命令之后直接检查错误的方法。我们可以使用
    || 命令来实现这一点，这是逻辑 OR 的 Bash 版本。它的对应物 && 是逻辑 AND 的实现。为了说明这一点，我们将介绍两个新命令：`true` 和
    `false`。如果您查看各自的 man 页面，您将找到可能得到的最清晰的答案：
- en: 'true: Do nothing, successfully'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: true：不执行任何操作，成功
- en: 'false: Do nothing, unsuccessfully'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: false：不执行任何操作，不成功
- en: 'The following script illustrates how we use || and && to create a logical application
    flow. If logical operators are unfamiliar terrain, check out the link in the *Further
    reading* section under *Logical operators* first:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本说明了我们如何使用 || 和 && 来创建逻辑应用程序流。如果逻辑运算符是陌生的领域，请先查看 *进一步阅读* 部分下的 *逻辑运算符* 链接：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we expect, the code after && is only executed if the command before returns
    an exit code of 0, while the code after || is only executed if the exit code is
    **not** 0 (so, most often, 1). If you look closely, you can actually see this
    happening in the debug of the script. You can see `true` being executed twice,
    as well as `false`. However, the first `echo` we actually end up seeing is after
    the first true, whereas the second `echo` we see is after the second false! We've
    highlighted this in the preceding code for your convenience.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的，只有在前一个命令返回退出代码 0 时，才会执行 && 之后的代码，而只有在退出代码 **不是** 0 时（通常是 1）才会执行 ||
    之后的代码。如果您仔细观察，您实际上可以在脚本的调试中看到这种情况发生。您可以看到 `true` 被执行了两次，以及 `false`。然而，我们实际上看到的第一个
    `echo` 是在第一个 true 之后，而我们看到的第二个 `echo` 是在第二个 false 之后！我们已经在前面的代码中突出显示了这一点，以方便您查看。
- en: 'Now, how can we use this to handle errors? An error will give an exit status
    that is anything other than 0, so this is comparable to the `false` command. In
    our example, the code after the logical operator || was printed after the false.
    This makes sense, because either `false` OR `echo` should succeed. In this case,
    since `false` (by default) fails, `echo` is executed. In the following simple
    example, we''ll show you how we would use the || operator in a script:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们如何使用这个来处理错误呢？错误将给出一个不为 0 的退出状态，因此这与 `false` 命令是可比的。在我们的例子中，逻辑运算符 || 后面的代码在
    false 之后被打印出来。这是有道理的，因为 `false` 或 `echo` 应该成功。在这种情况下，由于 `false`（默认）失败，`echo` 被执行。在下面的简单示例中，我们将向您展示如何在脚本中使用
    || 运算符：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We try to `cat` a file that we do not have permissions to (which is a good thing,
    since `/etc/shadow` contains the hash passwords for all users on the system).
    When we do this normally, we receive the exit status of 1, as you can see from
    our manual `cat`. However, in our script, we use `exit 123`. If our logical operator
    does its job, we will not exit with the default `1`, but instead with exit status
    123\. When we call the script, we get the same `Permission denied` error, but
    this time when we print the return code, we see the expected `123`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试 `cat` 一个我们没有权限的文件（这是一件好事，因为 `/etc/shadow` 包含系统上所有用户的哈希密码）。当我们正常执行此操作时，我们会收到
    1 的退出状态，就像我们的手动 `cat` 中所看到的那样。但是，在我们的脚本中，我们使用 `exit 123`。如果我们的逻辑运算符起作用，我们将不会以默认的
    `1` 退出，而是以退出状态 `123`。当我们调用脚本时，我们会收到相同的 `Permission denied` 错误，但是这次当我们打印返回代码时，我们会看到预期的
    `123`。
- en: If you really want to confirm that the code after || is only executed if the
    first part fails, run the script with `sudo`. In this case, you will see the contents
    of `/etc/shadow`, since root has those permissions and the exit code will be 0
    instead of the earlier 1 and 123.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的想要确认，只有在第一部分失败时才会执行 || 后面的代码，请使用 `sudo` 运行脚本。在这种情况下，您将看到 `/etc/shadow`
    的内容，因为 root 具有这些权限，退出代码将是 0，而不是之前的 1 和 123。
- en: Similarly, you can also use && if you only want to execute code when you're
    entirely sure the first command has finished successfully. To handle potential
    errors in a really graceful manner, it would be best to combine `echo` and `exit`
    after the ||. In the next example, on one of the next few pages, you will see
    how this is achieved! We will use that way of handling errors in the rest of this
    book, so don't worry about the syntax just yet – you will encounter it many more
    times before this book is over.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果您只想在完全确定第一个命令已成功完成时执行代码，也可以使用 &&。要以非常优雅的方式处理潜在错误，最好在 || 之后结合使用 `echo` 和
    `exit`。在接下来的示例中，您将在接下来的几页中看到如何实现这一点！我们将在本书的其余部分中使用处理错误的方式，所以现在不要担心语法 - 在本书结束之前，您将遇到它很多次。
- en: Error prevention
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误预防
- en: 'At this point, you should have a firm grasp on how we can handle (user input)
    error. Obviously, context is everything here: depending on the situation, some
    errors are handled in different ways. There is one more important subject in this
    chapter, and that is *error prevention*. While knowing how to handle errors is
    one thing, it would be even better if we can prevent errors during script execution
    altogether.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经牢固掌握了我们如何处理（用户输入）错误。显然，这里的上下文是一切：根据情况，一些错误以不同的方式处理。本章中还有一个更重要的主题，那就是
    *错误预防*。虽然知道如何处理错误是一回事，但如果我们能在脚本执行过程中完全避免错误，那就更好了。
- en: Checking arguments
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查参数
- en: 'As we noted in the previous chapter, when you''re dealing with positional arguments
    passed to your script, a few things are very important. One of them is whitespace,
    which signifies the boundary between arguments. If we need to pass an argument
    to our script that contains whitespace, we need to wrap that argument in single
    or double quotes, otherwise it will be interpreted as multiple arguments. Another
    important aspect of positional arguments is getting exactly the right number of
    arguments: not too few, but definitely not too many either.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中指出的，当处理传递给脚本的位置参数时，有一些非常重要的事情。其中之一是空格，它表示参数之间的边界。如果我们需要向脚本传递包含空格的参数，我们需要将该参数用单引号或双引号括起来，否则它将被解释为多个参数。位置参数的另一个重要方面是确切地获得正确数量的参数：既不要太少，也绝对不要太多。
- en: 'By starting our scripts (that use positional arguments) with a check on the
    number of arguments passed, we can validate if the user called the script correctly.
    Otherwise, we can instruct the user on how to correctly call it! The following
    example shows you how we can do this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在使用位置参数的脚本中以检查传递的参数数量开始，我们可以验证用户是否正确调用了脚本。否则，我们可以指导用户如何正确调用它！以下示例向您展示了我们如何做到这一点：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To properly illustrate this principle and some others we have seen before,
    we''ve created a rather large and complicated script (compared to what you have
    seen before). To make it easy to understand this, we''ll cut it up into pieces
    and discuss each piece sequentially. We''ll start with the header:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确说明这个原则和我们之前看到的一些其他原则，我们创建了一个相当大而复杂的脚本（与您之前看到的相比）。为了更容易理解这一点，我们将它分成几部分，并依次讨论每一部分。我们将从头部开始：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The shebang and most fields should feel natural right now. When specifying
    positional parameters, however, we like to enclose them within **<>** if they''re
    **required**, and **[]** if they''re **optional** (which they are if they have
    a default value, for instance, which we will see at the end of this chapter).
    This is a common pattern in scripting and you would do well to follow it! The
    next part of the script is the actual check for the number of arguments:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，shebang和大多数字段应该感觉很自然。然而，在指定位置参数时，我们喜欢在**<>**中将它们括起来，如果它们是**必需的**，则在**[]**中将它们括起来，如果它们是**可选的**（例如，如果它们有默认值，我们将在本章末尾看到）。这是脚本编写中的常见模式，您最好遵循它！脚本的下一部分是实际检查参数数量的部分：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The magic in this section comes from the $# combination. Similar to the $?
    exit status construct, $# is resolved to the number of arguments that have been
    passed to the script. Because this is an integer, we can compare it, using the
    `-ne` and `-eq` flags of `test`, to the number of arguments we need: three. Anything
    that is *not three* will not work for this script, which is why we build the check
    in this manner. If the *test is positive* (which means a negative result!), we
    perform the `then-logic`, which tells the user that they called the script incorrectly.
    To prevent that from happening again, the correct way to use the script is passed
    as well. We use one more trick here, the `$0` signs. This resolves to the script
    name, which is why, in the case of incorrect calling, the script name is printed
    nicely next to the actual expected arguments, like so:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分的魔力来自$#的组合。类似于$?退出状态构造，$#解析为传递给脚本的参数数量。因为这是一个整数，我们可以使用`test`的`-ne`和`-eq`标志将其与我们需要的参数数量进行比较：三个。任何*不是三个*的都不适用于这个脚本，这就是为什么我们以这种方式构建检查。如果*测试结果为正*（这意味着负结果！），我们执行`then-logic`，告诉用户他们错误地调用了脚本。为了防止再次发生这种情况，还传递了使用脚本的正确方法。我们在这里使用了另一个技巧，即$0符号。这解析为脚本名称，这就是为什么在错误调用的情况下，脚本名称会很好地打印在实际预期参数旁边，就像这样：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Because of this check and the hint to the user, we would expect the user to
    call this script incorrectly only once. Because we have not started processing
    the script''s functionality yet, we will not have a situation where half the tasks
    in the script have been completed, even though we would know **at the start of
    the script** that it would never complete, since it is missing information that
    the script needs. Let''s move on to the next part of the script:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个检查和对用户的提示，我们预期用户只会错误地调用此脚本一次。因为我们还没有开始处理脚本的功能，所以我们不会出现脚本中一半的任务已经完成的情况，即使我们在脚本开始时就知道它永远不会完成，因为缺少脚本需要的信息。让我们继续下一部分脚本：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As a recap, we can see that we assigned positional user input to a variable
    name we chose to represent the thing it is saving. Because we need to use the
    absolute path of the final file more than once, we combine two of the variables
    based on user input to form the absolute path to the file. The next part of the
    script contains the actual functionality:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回顾，我们可以看到我们将位置用户输入分配给一个我们选择的变量名，以表示它所保存的内容。因为我们需要多次使用最终文件的绝对路径，我们根据用户输入结合两个变量来形成文件的绝对路径。脚本的下一部分包含实际功能：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For both the file and the directory, we do a similar check: we check if the
    directory/file is already there, or if we need to create it. By using the || shorthand
    with `echo` and `exit`, we check if `mkdir` and `touch` return an exit status
    of 0\. Remember, if they return *anything other than 0*, everything after the
    || and within the curly braces will be executed, in this case exiting the script!'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文件和目录，我们进行类似的检查：我们检查目录/文件是否已经存在，或者我们是否需要创建它。通过使用`echo`和`exit`的||简写，我们检查`mkdir`和`touch`是否返回退出状态0。请记住，如果它们返回*除0以外的任何值*，则||之后和花括号内的所有内容都将被执行，这种情况下会退出脚本！
- en: The last part contains the *redirection* of the echo to the file. Simply said,
    the output of echo is redirected into a file. Redirection will be discussed in
    depth in [Chapter 12](15141e02-be0c-4709-90f4-a172809217c4.xhtml), *Using Pipes
    and Redirection in Scripts*. For now, accept that the text we used for `${file_content}`
    will be written to the file (as you can check yourself).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分包含了将回显重定向到文件的操作。简单地说，echo 的输出被重定向到一个文件中。重定向将在[第12章](15141e02-be0c-4709-90f4-a172809217c4.xhtml)中深入讨论，“在脚本中使用管道和重定向”。现在，接受我们用于`${file_content}`的文本将被写入文件中（您可以自行检查）。
- en: Managing absolute and relative paths
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理绝对路径和相对路径
- en: 'There is an issue we have not discussed yet: running scripts with absolute
    and relative paths. This might seem like a trivial difference, but it most certainly
    is not. Most commands you run, while directly interactive or from within a script
    you call, use your current working directory as their current working directory.
    You might have expected commands in a script to default to the directory where
    the script is, but since the script is nothing more than a fork of your current
    shell (as explained at the beginning of this chapter), it also inherits the current
    working directory. We can best illustrate this by creating a script which copies
    a file to a relative path:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论的一个问题是：使用绝对路径和相对路径运行脚本。这可能看起来像是一个微不足道的差异，但实际上并非如此。大多数你运行的命令，无论是直接交互还是从你调用的脚本中运行，都使用你的当前工作目录作为它们的当前工作目录。你可能期望脚本中的命令默认为脚本所在的目录，但由于脚本只是你当前
    shell 的一个分支（正如本章开头所解释的那样），它也继承了当前工作目录。我们可以通过创建一个复制文件到相对路径的脚本来最好地说明这一点：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The script itself is pretty easy – check if a directory is present, otherwise
    create it. You can check for errors on `mkdir` by using our shorthand error handling.
    Next, copy a known file (`/var/log/dpkg.log`) to the `dpkg` directory. The first
    time we run it, we''re in the same directory as the script. We can see the `dpkg`
    directory that was created there and the file copied inside it. Then, we move
    our current working directory to `/tmp/` and we run the script again, this time
    using the absolute path instead of the relative path of the first call. Now, we
    can see that the `dpkg` directory is created at `/tmp/dpkg/`! Not really unexpected,
    but how could we `avoid` this? Just a single line at the beginning of the script
    will fix this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本本身非常简单——检查目录是否存在，否则创建它。您可以使用我们的简写错误处理来检查`mkdir`的错误。接下来，将一个已知文件（`/var/log/dpkg.log`）复制到`dpkg`目录中。第一次运行时，我们与脚本位于同一目录。我们可以看到在那里创建了`dpkg`目录，并且文件被复制到其中。然后，我们将当前工作目录移动到`/tmp/`，并再次运行脚本，这次使用绝对路径而不是第一次调用的相对路径。现在，我们可以看到`dpkg`目录被创建在`/tmp/dpkg/`下！这并不是非常意外的，但我们如何可以“避免”这种情况呢？脚本开头的一行代码就可以解决这个问题：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As the code execution should show, we now do everything relative to the script
    location. This is made possible by a little bit of Bash magic combined with the
    `dirname` command. This command is pretty simple as well: it prints the directory
    name from whatever we pass, in this case, $0\. As you might remember, $0 resolves
    to the script name as it is called. From /tmp/, this is the absolute path; if
    we call it from another directory, it might be a relative path. If we are in the
    same directory as the script, `dirname`, $0 will result in `.`, which means we
    `cd` to the current directory. This is not really needed, but it does not do any
    harm either. This seems like a small payoff for a much more robust script, which
    we can now call from wherever we want!'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如代码执行所示，现在我们可以相对于脚本位置执行所有操作。这是通过一点点 Bash 魔法和`dirname`命令实现的。这个命令也很简单：它从我们传递的任何内容中打印目录名，这里是`$0`。你可能记得，$0
    解析为脚本名称，因为它被调用。从`/tmp/`，这是绝对路径；如果我们从另一个目录调用它，它可能是一个相对路径。如果我们在与脚本相同的目录中，`dirname`，$0
    将结果为`.`，这意味着我们`cd`到当前目录。这并不是真正需要的，但它也不会造成任何伤害。这似乎是一个小小的代价，换来了一个更加健壮的脚本，现在我们可以从任何地方调用它！
- en: For now, we won't go into details regarding the `$(...)` syntax. We will further
    discuss this in [Chapter 12](15141e02-be0c-4709-90f4-a172809217c4.xhtml), *Using
    Pipes and Redirection in Scripts*. At this point, remember that this allows us
    to get a value which we can pass to `cd` in a single line.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不会详细讨论`$(...)`语法。我们将在[第12章](15141e02-be0c-4709-90f4-a172809217c4.xhtml)中进一步讨论这个问题，“在脚本中使用管道和重定向”。在这一点上，记住这使我们能够在一行中获取一个值，然后将其传递给`cd`。
- en: Dealing with y/n
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理y/n
- en: 'At the beginning of this chapter, we presented you with something to think
    about: asking the user to agree or disagree with something by stating yes or no.
    As we discussed, there are many possible answers we can expect a user to give.
    Realistically, there are five ways a user could give us a *yes*: y, Y, yes, YES,
    and Yes.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开始，我们向您提出了一个思考的问题：通过陈述是或否来要求用户同意或不同意某事。正如我们讨论过的，有许多可能的答案可以期待用户给出。实际上，用户可以以五种方式给出“是”的答案：y、Y、yes、YES
    和 Yes。
- en: 'The same goes for *no*. Let''s see how we could check this without using any
    tricks:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“否”也是一样。让我们看看如何在不使用任何技巧的情况下进行检查：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'While this works, it is not really a very workable solution. Even worse, if
    the user happens to have Caps Lock on while they''re trying to type *Yes*, we
    will end up with *yES*! Do we need to include that as well? The answer is, of
    course, no. Bash has a nifty little feature called **parameter expansion**. We
    will explain this in much more depth in [Chapter 16](89ec6d77-023a-482a-bd93-23e3945002bf.xhtml),
    *Bash Parameter Substitution and Expansion*, but for now, we can give you a preview
    of what it is capable of:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样做是有效的，但并不是一个非常可行的解决方案。更糟糕的是，如果用户在尝试输入“是”时碰巧开启了大写锁定键，我们最终会得到“yES”！我们需要包括这种情况吗？答案当然是否定的。Bash
    有一个称为**参数扩展**的巧妙功能。我们将在[第16章](89ec6d77-023a-482a-bd93-23e3945002bf.xhtml)中更深入地解释这一点，“Bash
    参数替换和扩展”，但现在，我们可以给你一个它能做什么的预览：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Instead of five checks for each answer, we now use two: one for the full word
    (yes/no) and one for the short one-letter answer (y/n). But, how does the answer
    *YES* work, when we have only specified *yes*? The solution to this question lies
    in the ,, and ^^, which we have included inside the variable. So, instead of ${reply_variable},
    we used ${reply_variable,,} and ${reply_variable^^}. In the case of ,,, the variable
    is first resolved to its value and then converted to *all lowercase letters*.
    Because of this, all three answers – *YES, Yes, and yes* – can be compared with
    *yes*, as that is how Bash will expand them. You might take a guess at what ^^
    does: it converts the content of the string to uppercase, which is why we can
    compare it to NO, even though we give the answer no.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再对每个答案进行五次检查，而是只使用两次：一个用于完整单词（是/否），一个用于简短的单字母答案（y/n）。但是，当我们只指定了*yes*时，答案*YES*是如何工作的呢？这个问题的解决方案在于我们在变量内部包含的,,和^^。因此，我们使用了${reply_variable,,}和${reply_variable^^}，而不是${reply_variable}。在,,,的情况下，变量首先解析为其值，然后转换为*所有小写字母*。因此，所有三个答案——*YES,
    Yes和yes*——都可以与*yes*进行比较，因为Bash会将它们扩展为这样。你可能猜到^^的作用是什么：它将字符串的内容转换为大写，这就是为什么我们可以将其与NO进行比较，即使我们给出的答案是no。
- en: Always try to place yourself in the users' shoes. They are dealing with many
    different tools and commands. In most of these cases, logic as given for dealing
    with different ways of writing yes/no has been integrated. This can make even
    the most friendly system administrator a bit lazy and train them to go for the
    one-letter answer. But you wouldn't want to punish the sysadmin that actually
    listens to you, either! So, make a point of dealing with the most *reasonable*
    answers in a friendly manner.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 始终试图站在用户的角度。他们正在处理许多不同的工具和命令。在这些情况下，处理不同方式的是/否写法的逻辑已经被整合。这甚至可以让最友好的系统管理员有点懒惰，并训练他们选择单字母答案。但你也不想惩罚那些真正听你话的系统管理员！因此，要点是以友好的方式处理最*合理*的答案。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed many aspects of errors in Bash scripts. First,
    error **checking** was described. To start with, we explained that an exit status
    is a way for commands to communicate whether their execution was considered a
    success or failure. The `test` command and its shorthand `[[...]]` notation were
    introduced. This command allows us to perform functional checks in our scripts.
    Examples of this are comparing strings and integers, and checking if a file or
    directory is created and accessible/writable. We gave a quick refresher on variables,
    followed by a short introduction to running a script with the debug flag, `-x`,
    set.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Bash脚本中错误的许多方面。首先描述了错误**检查**。首先，我们解释了退出状态是命令用来传达其执行是否被视为成功或失败的一种方式。介绍了`test`命令及其简写`[[...]]`符号。该命令允许我们在脚本中执行功能性检查。其中的示例包括比较字符串和整数，以及检查文件或目录是否被创建和可访问/可写。我们对变量进行了快速复习，然后简要介绍了使用调试标志`-x`运行脚本。
- en: The second part of this chapter dealt with error **handling**. We described
    the (unofficial) `if-then-exit` construct, which we use to check command execution
    and exit if it failed. In the examples that followed, we saw that we do not always
    have to write return code to variables when we want to check them; we can use
    $? directly in a test case. Going on, we gave a preview of how we can use `if-then-else`
    logic to handle errors in a better way. We ended the second part of this chapter
    by presenting the shorthand syntax for error handling, which we will continue
    to use throughout the rest of this book.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第二部分涉及错误**处理**。我们描述了（非官方的）`if-then-exit`结构，我们用它来检查命令执行并在失败时退出。在随后的示例中，我们看到当我们想要检查它们时，我们并不总是需要将返回码写入变量中；我们可以直接在测试用例中使用$?。接着，我们预览了如何使用`if-then-else`逻辑更好地处理错误。我们通过介绍了错误处理的简写语法来结束本章的第二部分，这将在本书的其余部分中继续使用。
- en: 'In the third and final part of this chapter, we explained error **prevention**.
    We learned how we can check if the arguments are correct and how we can avoid
    issues with absolute and relative paths when calling our script. In the final
    part of this chapter, we answered the question we posed at the beginning: How
    can we best deal with yes/no input from the user? By using some simple Bash parameter
    expansions (which will be further explained in the last chapter of this book),
    we were able to simply facilitate multiple answering styles for the users of our
    script.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第三部分和最后一部分中，我们解释了错误**预防**。我们学习了如何检查参数是否正确，以及在调用脚本时如何避免绝对路径和相对路径的问题。在本章的最后部分，我们回答了一开始提出的问题：我们如何最好地处理用户的是/否输入？通过使用一些简单的Bash参数扩展（这将在本书的最后一章中进一步解释），我们能够简单地为我们的脚本的用户提供多种回答方式。
- en: 'The following commands were introduced in this chapter: `mktemp`, `true`, and `false`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了以下命令：`mktemp`、`true`和`false`。
- en: Questions
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why do we need an exit status?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为什么需要退出状态？
- en: What is the difference between exit status, exit code, and return code?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出状态、退出码和返回码之间有什么区别？
- en: Which flag do we use with test to test for the following?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在test中使用哪个标志来测试以下内容？
- en: An existing directory
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的目录
- en: A writable file
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可写文件
- en: An existing symbolic link
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的符号链接
- en: What is the preferred shorthand syntax for `test -d /tmp/`?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`test -d /tmp/`的首选简写语法是什么？'
- en: How can we print debug information in a Bash session?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在Bash会话中打印调试信息？
- en: How can we check whether a variable has content?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何检查变量是否有内容？
- en: What is the Bash format for grabbing a return code?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抓取返回码的Bash格式是什么？
- en: Of `||` and `&&`, which is the logical AND and which is the OR?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`||`和`&&`中，哪个是逻辑与，哪个是逻辑或？'
- en: What is the Bash format for grabbing the number of arguments?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抓取参数数量的Bash格式是什么？
- en: How can we make sure that it does not matter from which working directory the
    user calls the script?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何确保用户从任何工作目录调用脚本都没有关系？
- en: How do Bash parameter expansions help us when dealing with user input?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理用户输入时，Bash参数扩展如何帮助我们？
- en: Further reading
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following resources might be interesting if you''d like to go deeper into
    the subjects of this chapter:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想深入了解本章主题，以下资源可能会很有趣：
- en: '**The test** **command**: [http://wiki.bash-hackers.org/commands/classictest](http://wiki.bash-hackers.org/commands/classictest)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试命令：[http://wiki.bash-hackers.org/commands/classictest](http://wiki.bash-hackers.org/commands/classictest)
- en: '**Bash debugging**: [http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash调试：[http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_02_03.html)
- en: '**Logical operators**: [https://secure.php.net/manual/en/language.operators.logical.php](https://secure.php.net/manual/en/language.operators.logical.php)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符：[https://secure.php.net/manual/en/language.operators.logical.php](https://secure.php.net/manual/en/language.operators.logical.php)
