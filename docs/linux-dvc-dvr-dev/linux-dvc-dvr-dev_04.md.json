["```\nstruct cdev { \n    struct kobject kobj; \n    struct module *owner; \n    const struct file_operations *ops; \n    struct list_head list; \n    dev_t dev; \n    unsigned int count; \n}; \n```", "```\n[...]\n\ndrwxr-xr-x 2 root root 160 Mar 21 08:57 input\n\ncrw-r----- 1 root kmem 1, 2 Mar 21 08:57 kmem\n\nlrwxrwxrwx 1 root root 28 Mar 21 08:57 log -> /run/systemd/journal/dev-log\n\ncrw-rw---- 1 root disk 10, 237 Mar 21 08:57 loop-control\n\nbrw-rw---- 1 root disk 7, 0 Mar 21 08:57 loop0\n\nbrw-rw---- 1 root disk 7, 1 Mar 21 08:57 loop1\n\nbrw-rw---- 1 root disk 7, 2 Mar 21 08:57 loop2\n\nbrw-rw---- 1 root disk 7, 3 Mar 21 08:57 loop3\n\n```", "```\nMAJOR(dev_t dev); \nMINOR(dev_t dev); \n```", "```\n#define MINORBITS    20 \n#define MINORMASK    ((1U << MINORBITS) - 1) \n#define MAJOR(dev)   ((unsigned int) ((dev) >> MINORBITS)) \n#define MINOR(dev)   ((unsigned int) ((dev) & MINORMASK)) \n#define MKDEV(ma,mi) (((ma) << MINORBITS) | (mi)) \n```", "```\n   int register_chrdev_region(dev_t first, unsigned int count, \\ \n                             char *name); \n```", "```\nint alloc_chrdev_region(dev_t *dev, unsigned int firstminor, \\ \n                        unsigned int count, char *name); \n```", "```\nstruct file_operations { \n    struct module *owner; \n    loff_t (*llseek) (struct file *, loff_t, int); \n    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); \n    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); \n    unsigned int (*poll) (struct file *, struct poll_table_struct *); \n    int (*mmap) (struct file *, struct vm_area_struct *); \n    int (*open) (struct inode *, struct file *); \n    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); \n    int (*release) (struct inode *, struct file *); \n    int (*fsync) (struct file *, loff_t, loff_t, int datasync); \n    int (*fasync) (int, struct file *, int); \n    int (*lock) (struct file *, int, struct file_lock *); \n    int (*flock) (struct file *, int, struct file_lock *); \n   [...] \n}; \n```", "```\nstruct inode { \n    [...] \n   struct pipe_inode_info *i_pipe;     /* Set and used if this is a \n *linux kernel pipe */ \n   struct block_device *i_bdev;  /* Set and used if this is a \n * a block device */ \n   struct cdev       *i_cdev;    /* Set and used if this is a \n * character device */ \n    [...] \n} \n```", "```\nstruct file { \n   [...] \n   struct path f_path;                /* Path to the file */ \n   struct inode *f_inode;             /* inode associated to this file */ \n   const struct file_operations *f_op;/* operations that can be \n          * performed on this file \n          */ \n   loff_t f_pos;                       /* Position of the cursor in \n * this file */ \n   /* needed for tty driver, and maybe others */ \n   void *private_data;     /* private data that driver can set \n                            * in order to share some data between file \n                            * operations. This can point to any data \n                            * structure. \n */ \n[...] \n} \n```", "```\n#define EEP_NBANK 8 \n#define EEP_DEVICE_NAME \"eep-mem\" \n#define EEP_CLASS \"eep-class\" \n\nstruct class *eep_class; \nstruct cdev eep_cdev[EEP_NBANK]; \ndev_t dev_num; \n\nstatic int __init my_init(void) \n{ \n    int i; \n    dev_t curr_dev; \n\n    /* Request the kernel for EEP_NBANK devices */ \n    alloc_chrdev_region(&dev_num, 0, EEP_NBANK, EEP_DEVICE_NAME); \n\n    /* Let's create our device's class, visible in /sys/class */ \n    eep_class = class_create(THIS_MODULE, EEP_CLASS); \n\n    /* Each eeprom bank represented as a char device (cdev)   */ \n    for (i = 0; i < EEP_NBANK; i++) { \n\n        /* Tie file_operations to the cdev */ \n        cdev_init(&my_cdev[i], &eep_fops); \n        eep_cdev[i].owner = THIS_MODULE; \n\n        /* Device number to use to add cdev to the core */ \n        curr_dev = MKDEV(MAJOR(dev_num), MINOR(dev_num) + i); \n\n        /* Now make the device live for the users to access */ \n        cdev_add(&eep_cdev[i], curr_dev, 1); \n\n        /* create a device node each device /dev/eep-mem0, /dev/eep-mem1, \n         * With our class used here, devices can also be viewed under \n         * /sys/class/eep-class. \n         */ \n        device_create(eep_class, \n                      NULL,     /* no parent device */ \n                      curr_dev, \n                      NULL,     /* no additional data */ \n                      EEP_DEVICE_NAME \"%d\", i); /* eep-mem[0-7] */ \n    } \n    return 0; \n} \n```", "```\nunsigned long copy_from_user(void *to, const void __user *from, \n                             unsigned long n) \nunsigned long copy_to_user(void __user *to, const void *from, \n                              unsigned long n) \n```", "```\nint (*open)(struct inode *inode, struct file *filp); \n```", "```\nstruct pcf2127 { \n    struct cdev cdev; \n    unsigned char *sram_data; \n    struct i2c_client *client; \n    int sram_size; \n    [...] \n}; \n```", "```\nstatic unsigned int sram_major = 0; \nstatic struct class *sram_class = NULL; \n\nstatic int sram_open(struct inode *inode, struct file *filp) \n{ \n   unsigned int maj = imajor(inode); \n   unsigned int min = iminor(inode); \n\n   struct pcf2127 *pcf = NULL; \n   pcf = container_of(inode->i_cdev, struct pcf2127, cdev); \n   pcf->sram_size = SRAM_SIZE; \n\n   if (maj != sram_major || min < 0 ){ \n         pr_err (\"device not found\\n\"); \n         return -ENODEV; /* No such device */ \n   } \n\n   /* prepare the buffer if the device is opened for the first time */ \n   if (pcf->sram_data == NULL) { \n         pcf->sram_data = kzalloc(pcf->sram_size, GFP_KERNEL); \n         if (pcf->sram_data == NULL) { \n               pr_err(\"Open: memory allocation failed\\n\"); \n               return -ENOMEM; \n         } \n   } \n   filp->private_data = pcf; \n   return 0; \n} \n```", "```\nstatic int sram_release(struct inode *inode, struct file *filp) \n{ \n   struct pcf2127 *pcf = NULL; \n   pcf = container_of(inode->i_cdev, struct pcf2127, cdev); \n\n   mutex_lock(&device_list_lock); \n   filp->private_data = NULL; \n\n   /* last close? */ \n   pcf2127->users--; \n   if (!pcf2127->users) { \n         kfree(tx_buffer); \n         kfree(rx_buffer); \n         tx_buffer = NULL; \n         rx_buffer = NULL; \n\n         [...] \n\n         if (any_global_struct) \n               kfree(any_global_struct); \n   } \n   mutex_unlock(&device_list_lock); \n\n   return 0; \n} \n```", "```\nssize_t(*write)(struct file *filp, const char __user *buf, size_t count, loff_t *pos); \n```", "```\n/* if trying to Write beyond the end of the file, return error. \n * \"filesize\" here corresponds to the size of the device memory (if any) \n */ \nif ( *pos >= filesize ) return -EINVAL; \n```", "```\n/* filesize coerresponds to the size of device memory */ \nif (*pos + count > filesize)  \n    count = filesize - *pos; \n```", "```\n/* convert pos into valid address */ \nvoid *from = pos_to_address( *pos );  \n```", "```\nif (copy_from_user(dev->buffer, buf, count) != 0){ \n    retval = -EFAULT; \n    goto out; \n} \n/* now move data from dev->buffer to physical device */ \n```", "```\nwrite_error = device_write(dev->buffer, count); \nif ( write_error ) \n    return -EFAULT; \n```", "```\n*pos += count; \nReturn count; \n```", "```\nssize_t  \neeprom_write(struct file *filp, const char __user *buf, size_t count, \n   loff_t *f_pos) \n{ \n   struct eeprom_dev *eep = filp->private_data; \n   ssize_t retval = 0; \n\n    /* step (1) */ \n    if (*f_pos >= eep->part_size)  \n        /* Writing beyond the end of a partition is not allowed. */ \n        return -EINVAL; \n\n    /* step (2) */ \n    if (*pos + count > eep->part_size) \n        count = eep->part_size - *pos; \n\n   /* step (3) */ \n   int part_origin = PART_SIZE * eep->part_index; \n   int register_address = part_origin + *pos; \n\n    /* step(4) */ \n    /* Copy data from user space to kernel space */ \n    if (copy_from_user(eep->data, buf, count) != 0) \n        return -EFAULT; \n\n       /* step (5) */ \n    /* perform the write to the device */ \n    if (write_to_device(register_address, buff, count) < 0){ \n        pr_err(\"ee24lc512: i2c_transfer failed\\n\");   \n        return -EFAULT; \n     } \n\n    /* step (6) */ \n    *f_pos += count; \n    return count; \n} \n```", "```\nssize_t (*read) (struct file *filp, char __user *buf, size_t count, loff_t *pos);\n```", "```\nif (*pos >= filesize) \n  return 0; /* 0 means EOF */ \n```", "```\nif (*pos + count > filesize) \n    count = filesize - (*pos); \n```", "```\nvoid *from = pos_to_address (*pos); /* convert pos into valid address */ \n```", "```\nsent = copy_to_user(buf, from, count); \nif (sent) \n    return -EFAULT; \n```", "```\n*pos += count; \nReturn count; \n```", "```\nssize_t  eep_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos) \n{ \n    struct eeprom_dev *eep = filp->private_data; \n\n    if (*f_pos >= EEP_SIZE) /* EOF */ \n        return 0; \n\n    if (*f_pos + count > EEP_SIZE) \n        count = EEP_SIZE - *f_pos; \n\n    /* Find location of next data bytes */ \n    int part_origin  =  PART_SIZE * eep->part_index; \n    int eep_reg_addr_start  =  part_origin + *pos; \n\n    /* perform the read from the device */ \n    if (read_from_device(eep_reg_addr_start, buff, count) < 0){ \n        pr_err(\"ee24lc512: i2c_transfer failed\\n\");   \n        return -EFAULT; \n    }  \n\n    /* copy from kernel to user space */ \n    if(copy_to_user(buf, dev->data, count) != 0) \n        return -EIO; \n\n    *f_pos += count; \n    return count; \n} \n```", "```\nloff_t(*llseek) (structfile *filp, loff_t offset, int whence); \n```", "```\nswitch( whence ){ \n    case SEEK_SET:/* relative from the beginning of file */ \n        newpos = offset; /* offset become the new position */ \n        break; \n    case SEEK_CUR: /* relative to current file position */ \n        newpos = file->f_pos + offset; /* just add offset to the current position */ \n        break; \n    case SEEK_END: /* relative to end of file */ \n        newpos = filesize + offset; \n        break; \n    default: \n        return -EINVAL; \n} \n```", "```\nif ( newpos < 0 ) \n    return -EINVAL; \n```", "```\nfilp->f_pos = newpos; \n```", "```\nreturn newpos; \n```", "```\n#include <unistd.h> \n#include <fcntl.h> \n#include <sys/types.h> \n#include <stdio.h> \n\n#define CHAR_DEVICE \"toto.txt\" \n\nint main(int argc, char **argv) \n{ \n    int fd= 0; \n    char buf[20]; \n\n    if ((fd = open(CHAR_DEVICE, O_RDONLY)) < -1) \n        return 1; \n\n    /* Read 20 bytes */ \n    if (read(fd, buf, 20) != 20) \n        return 1; \n    printf(\"%s\\n\", buf); \n\n    /* Move the cursor to 10 time, relative to its actual position */ \n    if (lseek(fd, 10, SEEK_CUR) < 0) \n        return 1; \n    if (read(fd, buf, 20) != 20)  \n        return 1; \n    printf(\"%s\\n\",buf); \n\n    /* Move the cursor ten time, relative from the beginig of the file */ \n    if (lseek(fd, 7, SEEK_SET) < 0) \n        return 1; \n    if (read(fd, buf, 20) != 20) \n        return 1; \n    printf(\"%s\\n\",buf); \n\n    close(fd); \n    return 0; \n} \n```", "```\njma@jma:~/work/tutos/sources$ cat toto.txt\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\n\njma@jma:~/work/tutos/sources$ ./seek\n\nLorem ipsum dolor si\n\nnsectetur adipiscing\n\npsum dolor sit amet,\n\njma@jma:~/work/tutos/sources$\n\n```", "```\nunsigned int (*poll) (struct file *, struct poll_table_struct *); \n```", "```\nvoid poll_wait(struct file * filp, wait_queue_head_t * wait_address, \npoll_table *p) \n```", "```\nstatic DECLARE_WAIT_QUEUE_HEAD(my_wq); \nstatic DECLARE_WAIT_QUEUE_HEAD(my_rq); \n```", "```\n#include <linux/poll.h> \nstatic unsigned int eep_poll(struct file *file, poll_table *wait) \n{ \n    unsigned int reval_mask = 0; \n    poll_wait(file, &my_wq, wait); \n    poll_wait(file, &my_rq, wait); \n\n    if (new-data-is-ready) \n        reval_mask |= (POLLIN | POLLRDNORM); \n    if (ready_to_be_written) \n       reval_mask |= (POLLOUT | POLLWRNORM); \n    return reval_mask; \n} \n```", "```\nwake_up_interruptible(&my_rq); /* Ready to read */ \nwake_up_interruptible(&my_wq); /* Ready to be written to */ \n```", "```\n#include <unistd.h> \n#include <fcntl.h> \n#include <stdio.h> \n#include <stdlib.h> \n#include <sys/select.h> \n\n#define NUMBER_OF_BYTE 100 \n#define CHAR_DEVICE \"/dev/packt_char\" \n\nchar data[NUMBER_OF_BYTE]; \n\nint main(int argc, char **argv) \n{ \n    int fd, retval; \n    ssize_t read_count; \n    fd_set readfds; \n\n    fd = open(CHAR_DEVICE, O_RDONLY); \n    if(fd < 0) \n        /* Print a message and exit*/ \n        [...] \n\n    while(1){  \n        FD_ZERO(&readfds); \n        FD_SET(fd, &readfds); \n\n        /* \n         * One needs to be notified of \"read\" events only, without timeout. \n         * This call will put the process to sleep until it is notified the \n         * event for which it registered itself \n         */ \n        ret = select(fd + 1, &readfds, NULL, NULL, NULL); \n\n        /* From this line, the process has been notified already */ \n        if (ret == -1) { \n            fprintf(stderr, \"select call on %s: an error ocurred\", CHAR_DEVICE); \n            break; \n        } \n\n        /* \n         * file descriptor is now ready. \n         * This step assume we are interested in one file only. \n         */ \n        if (FD_ISSET(fd, &readfds)) { \n            read_count = read(fd, data, NUMBER_OF_BYTE); \n            if (read_count < 0 ) \n                /* An error occured. Handle this */ \n                [...] \n\n            if (read_count != NUMBER_OF_BYTE) \n                /* We have read less than need bytes */ \n                [...] /* handle this */ \n            else \n            /* Now we can process data we have read */ \n            [...] \n        } \n    }     \n    close(fd); \n    return EXIT_SUCCESS; \n} \n```", "```\n_IO(MAGIC, SEQ_NO) \n_IOW(MAGIC, SEQ_NO, TYPE) \n_IOR(MAGIC, SEQ_NO, TYPE) \n_IORW(MAGIC, SEQ_NO, TYPE) \n```", "```\n#ifndef PACKT_IOCTL_H \n#define PACKT_IOCTL_H \n/* \n * We need to choose a magic number for our driver, and sequential numbers \n * for each command: \n */ \n#define EEP_MAGIC 'E' \n#define ERASE_SEQ_NO 0x01 \n#define RENAME_SEQ_NO 0x02 \n#define ClEAR_BYTE_SEQ_NO 0x03 \n#define GET_SIZE 0x04 \n\n/* \n * Partition name must be 32 byte max \n */ \n#define MAX_PART_NAME 32 \n\n/* \n * Now let's define our ioctl numbers: \n */ \n#define EEP_ERASE _IO(EEP_MAGIC, ERASE_SEQ_NO) \n#define EEP_RENAME_PART _IOW(EEP_MAGIC, RENAME_SEQ_NO, unsigned long) \n#define EEP_GET_SIZE _IOR(EEP_MAGIC, GET_SIZE, int *) \n#endif \n```", "```\nlong ioctl(struct file *f, unsigned int cmd, unsigned long arg); \n```", "```\n/* \n * User space code also need to include the header file in which ioctls \n * defined are defined. This is eep_ioctl.h in our case. \n */ \n#include \"eep_ioctl.h\" \nstatic long eep_ioctl(struct file *f, unsigned int cmd, unsigned long arg) \n{ \n    int part; \n    char *buf = NULL; \n    int size = 1300; \n\n    switch(cmd){ \n        case EEP_ERASE: \n            erase_eepreom(); \n            break; \n        case EEP_RENAME_PART: \n            buf = kmalloc(MAX_PART_NAME, GFP_KERNEL); \n            copy_from_user(buf, (char *)arg, MAX_PART_NAME); \n            rename_part(buf); \n            break; \n        case EEP_GET_SIZE: \n            copy_to_user((int*)arg, &size, sizeof(int)); \n            break; \n        default: \n            return -ENOTTY; \n    } \n    return 0; \n} \n```", "```\n#include <stdio.h> \n#include <stdlib.h> \n#include <fcntl.h> \n#include <unistd.h> \n#include \"eep_ioctl.h\"  /* our ioctl header file */ \n\nint main() \n{ \n    int size = 0; \n    int fd; \n    char *new_name = \"lorem_ipsum\"; /* must not be longer than MAX_PART_NAME */ \n\n    fd = open(\"/dev/eep-mem1\", O_RDWR); \n    if (fd == -1){ \n        printf(\"Error while opening the eeprom\\n\"); \n        return -1; \n    } \n\n    ioctl(fd, EEP_ERASE);  /* ioctl call to erase partition */ \n    ioctl(fd, EEP_GET_SIZE, &size); /* ioctl call to get partition size */ \n    ioctl(fd, EEP_RENAME_PART, new_name);  /* ioctl call to rename partition */ \n\n    close(fd); \n    return 0; \n} \n```", "```\nstatic const struct file_operations eep_fops = { \n   .owner =    THIS_MODULE, \n   .read =     eep_read, \n   .write =    eep_write, \n   .open =     eep_open, \n   .release =  eep_release, \n   .llseek =   eep_llseek, \n   .poll =     eep_poll, \n   .unlocked_ioctl = eep_ioctl, \n}; \n```"]