["```\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\nint main(void)\n{\n  int pid;\n  int status;\n  pid = fork();\n  if (pid == 0) {\n    printf(\"I am the child, PID %d\\n\", getpid());\n    sleep(10);\n    exit(42);\n  } else if (pid > 0) {\n    printf(\"I am the parent, PID %d\\n\", getpid());\n    wait(&status);\n    printf(\"Child terminated, status %d\\n\",\n    WEXITSTATUS(status));\n  } else\n    perror(\"fork:\");\n  return 0;\n}\n```", "```\nI am the parent, PID 13851\nI am the child, PID 13852\nChild terminated with status 42\n```", "```\nint execl(const char *path, const char *arg, ...);\nint execlp(const char *file, const char *arg, ...);\nint execle(const char *path, const char *arg,\n           ..., char * const envp[]);\nint execv(const char *path, char *const argv[]);\nint execvp(const char *file, char *const argv[]);\nint execvpe(const char *file, char *const argv[],\n           char *const envp[]);\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\nint main(int argc, char *argv[])\n{\n  char command_str[128];\n  int pid;\n  int child_status;\n  int wait_for = 1;\n  while (1) {\n    printf(\"sh> \");\n    scanf(\"%s\", command_str);\n    pid = fork();\n    if (pid == 0) {\n      /* child */\n      printf(\"cmd '%s'\\n\", command_str);\n      execl(command_str, command_str, (char *)NULL);\n      /* We should not return from execl, so only get to this line if it failed */\n      perror(\"exec\");\n      exit(1);\n    }\n    if (wait_for) {\n      waitpid(pid, &child_status, 0);\n      printf(\"Done, status %d\\n\", child_status);\n    }\n  }\n  return 0;\n}\n```", "```\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <sys/stat.h>  /* For mode constants */\n#include <fcntl.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <semaphore.h>\n#define SHM_SEGMENT_SIZE 65536\n#define SHM_SEGMENT_NAME \"/demo-shm\"\n#define SEMA_NAME \"/demo-sem\"\n\nstatic sem_t *demo_sem;\n/*\n * If the shared memory segment does not exist already, create it\n * Returns a pointer to the segment or NULL if there is an error\n */\n\nstatic void *get_shared_memory(void)\n{\n  int shm_fd;\n  struct shared_data *shm_p;\n  /* Attempt to create the shared memory segment */\n  shm_fd = shm_open(SHM_SEGMENT_NAME, O_CREAT | O_EXCL | O_RDWR, 0666);\n\n  if (shm_fd > 0) {\n    /* succeeded: expand it to the desired size (Note: dont't do \"this every time because ftruncate fills it with zeros) */\n    printf (\"Creating shared memory and setting size=%d\\n\",\n    SHM_SEGMENT_SIZE);\n\n    if (ftruncate(shm_fd, SHM_SEGMENT_SIZE) < 0) {\n      perror(\"ftruncate\");\n      exit(1);\n    }\n    /* Create a semaphore as well */\n    demo_sem = sem_open(SEMA_NAME, O_RDWR | O_CREAT, 0666, 1);\n\n    if (demo_sem == SEM_FAILED)\n      perror(\"sem_open failed\\n\");\n  }\n  else if (shm_fd == -1 && errno == EEXIST) {\n    /* Already exists: open again without O_CREAT */\n    shm_fd = shm_open(SHM_SEGMENT_NAME, O_RDWR, 0);\n    demo_sem = sem_open(SEMA_NAME, O_RDWR);\n\n    if (demo_sem == SEM_FAILED)\n      perror(\"sem_open failed\\n\");\n  }\n\n  if (shm_fd == -1) {\n    perror(\"shm_open \" SHM_SEGMENT_NAME);\n    exit(1);\n  }\n  /* Map the shared memory */\n  shm_p = mmap(NULL, SHM_SEGMENT_SIZE, PROT_READ | PROT_WRITE,\n    MAP_SHARED, shm_fd, 0);\n\n  if (shm_p == NULL) {\n    perror(\"mmap\");\n    exit(1);\n  }\n  return shm_p;\n}\nint main(int argc, char *argv[])\n{\n  char *shm_p;\n  printf(\"%s PID=%d\\n\", argv[0], getpid());\n  shm_p = get_shared_memory();\n\n  while (1) {\n    printf(\"Press enter to see the current contents of shm\\n\");\n    getchar();\n    sem_wait(demo_sem);\n    printf(\"%s\\n\", shm_p);\n    /* Write our signature to the shared memory */\n    sprintf(shm_p, \"Hello from process %d\\n\", getpid());\n    sem_post(demo_sem);\n  }\n  return 0;\n}\n```", "```\nint pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);\n```", "```\nUID    PID  PPID   LWP  C  NLWP  STIME        TTY           TIME CMD\n...\nchris  6072  5648  6072  0   3    21:18  pts/0 00:00:00 ./thread-demo\nchris  6072  5648  6073  0   3    21:18  pts/0 00:00:00 ./thread-demo\n\n```", "```\n#include <stdio.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <sys/syscall.h>\n\nstatic void *thread_fn(void *arg)\n{\n  printf(\"New thread started, PID %d TID %d\\n\",\n  getpid(), (pid_t)syscall(SYS_gettid));\n  sleep(10);\n  printf(\"New thread terminating\\n\");\n  return NULL;\n}\n\nint main(int argc, char *argv[])\n{\n  pthread_t t;\n  printf(\"Main thread, PID %d TID %d\\n\",\n  getpid(), (pid_t)syscall(SYS_gettid));\n  pthread_create(&t, NULL, thread_fn, NULL);\n  pthread_join(t, NULL);\n  return 0;\n}\n```", "```\npthread_cond_t cv = PTHREAD_COND_INITIALIZER;\npthread_mutex_t mutx = PTHREAD_MUTEX_INITIALIZER;\n\nvoid *consumer(void *arg)\n{\n  while (1) {\n    pthread_mutex_lock(&mutx);\n    while (buffer_empty(data))\n      pthread_cond_wait(&cv, &mutx);\n    /* Got data: take from buffer */\n    pthread_mutex_unlock(&mutx);\n    /* Process data item */\n  }\n  return NULL;\n}\n\nvoid *producer(void *arg)\n{\n  while (1) {\n    /* Produce an item of data */\n    pthread_mutex_lock(&mutx);\n    add_data(data);\n    pthread_mutex_unlock(&mutx);\n    pthread_cond_signal(&cv);\n  }\n  return NULL;\n}\n```", "```\nstruct sched_param {\n  ...\n  int sched_priority;\n  ...\n};\nint sched_setscheduler(pid_t pid, int policy, const struct sched_param *param);\nint sched_getscheduler(pid_t pid);\n```", "```\npthread_setschedparam(pthread_t thread, int policy, const struct sched_param *param);\npthread_getschedparam(pthread_t thread, int *policy, struct sched_param *param);\n```"]