# 第二章：Linux 命令行

在本章中，我们将向您介绍开始使用 Linux 命令行时最基本的概念。这是一个非常强大和高效的工具，您可以使用它执行在 Linux 中通常需要的各种操作。大量的快捷方式和技巧将帮助您更有效地导航命令行。

在本章中，我们将带您了解以下内容：

+   Shell 通配符

+   重定向和管道

+   `grep`、`sed`和`awk`命令

+   在 Linux 系统中导航文件和文件夹

# 介绍命令行

在本节中，您将学习如何运行 Linux 命令行程序以及命令行的基本结构是什么。您还将了解程序选项和参数以及它们对自定义命令的重要性。

当我们说 Linux 命令行时，我们真正指的是**shell**。重要的是要知道 shell 不同于终端仿真器。终端是一个屏幕或窗口，让您访问 Linux 服务器的输入和输出。shell 只是在服务器上运行的一个程序，就像任何其他命令一样，它等待、解释、处理、执行和响应用户输入的命令。

首先，打开一个新的终端仿真器，并使用 SSH 登录到您的 CentOS 7 服务器，就像我们在第一章中学到的那样，*Linux 简介*。使用您在安装过程中设置的普通用户账户登录，因为正如我们之前所说的，除非必须，永远不要使用 root 用户。在我的示例中，用户名是`olip`：

![](img/3973123b-3647-47cd-963a-91fd8ea28937.png)

成功登录到服务器后，一个重要的程序已经自动启动，这个程序叫做 shell，我们一直在使用它。事实上，当我们谈论 Linux 终端时，我们真正说的是 shell。存在几种 shell 变体；在 CentOS 7 上，默认使用**Bash**，或者**Bourne Again Shell**。当 shell 启动时，您会注意到以美元符号($)结尾的行，这被称为 shell 提示符。

在我们的示例中，它为我们提供了一些有用的信息：登录用户名和当前所在的目录。波浪号是一个特殊字符，表示家目录，这是登录时的默认目录。在 shell 提示符之后是光标，即下划线字符，这是用户可以输入文本的地方，然后由 shell 处理和执行。但是只有当输入以*Enter*键结束时，用户输入才会被 shell 处理和执行。如果出现任何错误，只需按下退格键删除最后一个字符。我们将在本章学习的第一个有用的命令是如何退出系统。

在 Linux 终端上，这个命令注销当前用户并返回到登录屏幕：

1.  打开 Linux 终端，输入`logout`命令，然后按*Enter*键。

1.  然而，如果您在使用 SSH 连接时执行相同的操作，它的效果与我们在上一章学到的`exit`命令相同。

1.  让我们再次尝试登录到 CentOS 服务器。

1.  让我们尝试一个简单的命令；输入`date`并按下*Enter*键。这是一个打印当前日期时间值的命令：

![](img/997fd978-1da6-461b-a240-4087ce52aff9.png)

如您所见，如果 shell 已经执行完特定命令并准备接受用户的新输入，新的 shell 提示符将出现在新行中标志着它的准备就绪。现在，输入`cal`并按*Enter*。这个命令打印出当前月份的一个漂亮的表格视图。

如果任何命令类型的第一个字符在 shell 中以井号键前置，当按下*Enter*键时，该命令将不会被执行。

一个典型的 Linux 系统，比如 CentOS 7，包含了默认安装的数百个不同的命令。如果你只能输入纯命令而没有其他东西，我们在 shell 中的工作将非常有限和静态，你将无法正常工作。因此，我们需要一种方法来自定义我们的命令或在执行过程中改变默认行为，提供更多的信息。但是我们该如何做呢？

进入命令行选项和参数的力量。首先，我们需要讨论 shell 中命令的一般结构，它最简单的形式是`COMMANDNAME OPTIONS ARGUMENTS`。命令名称是要启动的命令的名称。注意，在 Linux 中命令名称是区分大小写的。输入`whoami`然后按*Enter*。这个命令将打印出在 shell 中工作的当前用户的名称。由于 Linux 是区分大小写的，这个命令不能使用大写字母启动，比如每个版本都指代不同的命令。在这里，我们也将看到为什么 shell 是一个如此有用的程序。它不仅听取和解释命令，而且在出现问题时还会显示有用的错误消息，比如系统中找不到一个命令。通常，在 Linux 上所有标准的 Bash 脚本命令都是用小写字母编写的。要获取一些可用命令的列表，输入`ls /bin`。现在，让我们继续讨论 shell 中可用的最基本的命令之一。输入`ls`并按*Enter*键。这个命令列出目录中的文件。如果没有提供更多的信息，它将打印出我们当前所在目录中所有可见的文件：

![](img/df3b85c2-095a-4ffe-97cb-0be15e3cad29.png)

正如你所看到的，一个 shell 命令也可以包含附加到命令名称的选项和参数，并且用空格分隔开。这意味着如果你想提供至少一个选项或参数，那么在命令名称后至少需要一个空格。首先，让我们谈谈命令行选项。它们的目的是影响命令的行为。它们也被称为**开关**或**标志**。没有强制性的标准，但通常任何单字符命令行选项以单破折号开头，而较长的选项名称有两个破折号符号。此外，如果你想提供多个单字符命令行选项，对于大多数标准的 Linux 命令，你可以直接连续写它们。值得知道的是，单字符命令行选项通常是描述它们含义的缩写：`-d`可能代表目录，`-x`代表排除，等等。

我们已经知道，`ls`命令没有任何其他选项时会给我们当前目录中所有文件的列表。如果你输入`ls -a`并按*Enter*，你就运行了你的第一个带命令行选项的命令。`a`开关代表所有，这通过给你一个包括隐藏文件在内的所有文件的列表来影响`ls`的默认行为，这些文件在 Linux 中以当前目录中的前导破折号开头。现在，让我们输入`ls -alth`并按*Enter*键来看结果：

![](img/7794f997-1e4a-49d5-b10a-3d1e7ef60280.png)

这通过使用我们刚刚讨论的`-a`标志更进一步影响了命令的默认行为，并且还使用了`-l`开关，代表**列表**，它以列表格式打印出所有文件，包括更详细的信息，比如创建日期。`-t`开关代表**时间**，它按修改日期对文件列表进行排序，最新的条目首先出现，`-h`代表**人类可读**，它将以更易读的形式打印出文件大小，使用**MB**而不是字节来表示文件大小。

通常，命令行选项可以有与之绑定的参数。除了选项，我们还有命令行参数，也称为**参数**。这是在命令启动时输入的任何动态或自由文本信息，它不是选项，并在执行期间被传递给命令。典型的例子是命令在执行期间想要处理的文件名或目录。参数也由*空格*分隔。

键入`echo Hello`并按*Enter*键：

![](img/d5263ce5-9a0b-4a9f-b0c1-1a1565fec613.png)

在上一个命令中，`Hello`是`echo`命令的参数，而不是选项。`echo`命令是最基本的 shell 命令之一。它只是将给定的参数打印回命令行。正如我们将看到的，这对于测试 shell 功能非常理想，比如**通配符**，我们稍后将在本节中学到更多关于它的知识。现在让我们在终端中键入`ls -al /boot /var`并按*Enter*键，以查看类似以下的结果：

![](img/1f8ccccd-1e52-4272-afeb-d3155c28a548.png)

在这个例子中，我们第一次使用了命令行选项和参数。`ls`命令使用`a`和`l`选项执行，并且参数是`/boot`和`/var`。这将打印出`/boot`和`/var`目录中的所有文件，包括隐藏文件，以详细列表视图显示。如前所述，通常情况下参数与特定选项绑定，例如`tar`命令，我们稍后会讨论。当您需要处理输入文件时，您必须直接在`-f`选项之后指定，而不是其他地方，或者简而言之，输入文件参数与`-f`选项绑定。这种方法是不正确的，会产生错误。

# 文件通配符

在这一部分，您将学习 shell 扩展的工作原理，以及我们如何使用文件通配符来使我们在使用处理大量输入文件的命令时更加轻松。我们将讨论所有现有和可用的 shell 通配符字符类，并为每个字符类展示重要的用例和示例。在处理将文件或目录名称作为参数的命令时，比如`ls`命令，学习文件和目录通配符非常有帮助。这些是在 shell 中键入的特殊字符，其行为与普通字符不同。所有通配符字符都将在任何命令使用它们作为参数之前被 shell 替换为与字符模式匹配的文件列表。这是一种简化处理文件的表示法，特别是在处理大量需要输入和处理的文件时。使用文件通配符可以节省大量时间，因为多个文件可以由一个字符表示。将这些特殊字符替换为文件组列表的概念也称为**shell 扩展**。有几个可用的通配符字符，我们可以使用它们来创建非常复杂的文件列表选择。

通配符字符是通配符、问号、感叹号、方括号和破折号。尽管它们看起来行为非常相似，但 shell 通配符和正则表达式并不相同，这两个概念也不可互换。这意味着您不能将正则表达式应用于通配文件，反之亦然。我们将在本章的后续部分中学习更多关于正则表达式的知识。最重要的通配符字符是通配符字符。它将匹配特定目录中任意数量的任何字符文件名，有一个例外，它不匹配以点开头的文件，这一点您可能已经注意到了在 Linux 中查看隐藏文件时。如果您使用通配符字符与以点开头的文件并按*Enter*键会发生什么？让我们看一个例子。正如我们之前展示的，我们可以使用`echo`命令在终端中打印出随机文本。

让我们首先切换到另一个目录。输入`cd /etc`并按*Enter*。现在，输入`echo *`并按*Enter*：

![](img/f1dc0322-b8d6-41ba-8e8c-ae951eb1e8f7.png)

在上一个命令中，在第一步中，shell 将通配符替换为当前目录中的文件列表，并按照规则用空格分隔打印出来，然后显示包含任何字符的所有文件和目录，但不显示以点开头的文件。使用`echo`是测试您的通配模式是否完全匹配您想要的内容的完美方式，然后将其应用为真实的命令行参数。您可以将通配符与任何其他静态字符混合使用，使文件过滤更严格。输入`echo pa*`并按*Enter*。这将匹配所有以小写`p`开头，后跟`a`，后跟任何其他字符的文件。或者输入`echo *.d`并按*Enter*。这个例子找到所有具有`.d`文件扩展名的文件：

![](img/3edc1a0f-159c-4235-9b08-eb72bf4c4b43.png)

您甚至可以定义一个更严格的模式，例如，输入`echo li*.conf`并按*Enter*。这个通配模式将匹配当前目录中以小写`l`开头，后跟`i`，后跟任何其他字符的所有文件，但只有那些具有`.conf`文件扩展名的文件。我们可以在接受文件选项列表作为参数的任何命令中使用文件通配，比如`ls`命令。

例如，使用通配模式`li *.conf`作为`ls`命令的命令行参数，会给我们一个详细的列表，列出了这个模式匹配的所有文件。同样，重要的是要理解，我们并没有将通配模式输入`ls`命令，`ls`在程序执行期间也不会内部扩展文件。事实上，shell 在第一步中将通配符扩展为文件列表，然后将此列表作为`ls`命令的参数。

我们将使用`ls -d`选项来不显示目录内容，默认情况下会显示；这是因为 shell 通配不区分文件和目录。

在终端中输入`ls -d rc?.d`。这将为您列出所有只有一个随机字符作为第三个字符的文件。接下来，按照以下方式输入`ls -d krb5.conf??`命令：

![](img/c7c97ed5-ae3a-47ee-bf3a-1ec2eb4c6d25.png)

正如您所看到的，问号也可以多次使用。这将获取所有具有扩展名的两个随机字符的文件，只有这些文件。我们将要学习的最后一种通配符是方括号，它定义了特定位置上允许字符的范围，例如，输入`ls -l sub[ug]id`。这将扩展为以`sub`开头并且第四个字符为`u`或`g`，后跟`id`的所有文件列表：

![](img/5dce98d6-f011-4606-99a5-9e0e4e1effdf.png)

正如我们将在下面学到的，我们可以将括号与其他通配符字符混合使用。输入以下`ls`命令参数：

```
ls /bin/[mM]ail*  
```

这将扩展为`bin`目录中所有邮件程序的列表，包括大小写。我们稍后将学习更多关于`bin`目录的知识。您还可以使用数字来表示范围；在终端中输入`ls -d rc[01234].d`命令：

![](img/91788f1c-35a5-43be-9bcb-aaa224664a62.png)

在我们的例子中，这将扩展为`rc0.d`，`rc1.d`等。如果您有连续的数字或字母范围，就像在最后一个例子中一样，您还可以使用减号来进一步缩短您的通配表达式。例如，输入`ls /bin/m[a-z] [a-z]`。这将给我们`bin`目录中以`m`开头的所有三个字母命令名称。

还有另一个有用的通配符，即感叹号，它可以在括号中使用，定义在扩展结果中不得出现的内容，例如，`ls -d rc[!256].d`：

![](img/485cd3dd-c149-4cfb-b3fc-1700138933a5.png)

这表示我们不希望扩展第三个字符为`2`、`5`或`6`的文件。这也适用于括号内的连续范围，例如，`ls -d rc[!3-6].d`。

您已经学到了关于 Linux 中隐藏文件的三件事。它们的文件名以点开头，通配符通配字符会忽略它们，`ls`默认情况下不显示它们；因此，它们被称为隐藏。要显示主目录中的所有隐藏文件，我们使用`ls`命令的`-a`选项。您会看到主目录中有几个隐藏文件，例如`.bashrc`文件：

![](img/873ee66e-2631-4a6b-909f-71cd386f56a8.png)

但是在您的目录中还有两个特殊文件，名为[`.`]和[`..`]，我们将在本章后面学习这两个特殊文件是什么。如果您只想显示当前目录中的隐藏文件而不包括这两个点文件，您需要输入什么？有了您现在拥有的所有知识，这应该很容易实现，下一行现在应该对您有意义。因此，输入`ls .[!.]*`。但这也会列出目录内容。为了不列出目录内容，使用`ls -d`标志，因此命令将是`ls -d .[!.]*`：

![](img/40f6e6de-d304-4168-ba3d-de3df85e21d7.png)

在本节中，我们讨论了关于 Linux shell 通配符的一切。请记住，通配符字符匹配任何位置的每个文件名字符。对于这个规则有一个例外是非常重要的：它不匹配以点开头的文件名，这在 Linux 中称为隐藏文件。问号也是如此，但只在单个位置上；它也不匹配以点开头的文件名。括号在括号之间定义的单个位置匹配特定字符。当具有连续允许字符时，您还可以使用破折号符号。要匹配特定位置上除了一组字符之外的所有内容，请在括号中使用感叹号。

# 引用命令

正如我们在前一节中学到的，shell 有一系列特殊字符，在 shell 中具有特殊含义并触发某些功能，例如使用通配符字符作为文件名。但是，特殊字符比我们之前向您展示的还要多。如果您想使用包含问号符号的文件名等特殊字符，您将遇到问题，因为 shell 总是首先尝试对特殊字符应用特殊操作，因此它们不会像正常的文件名字符一样工作。解决方案是使用各种方法禁用这些字符的所有特殊含义，例如引用，以便我们可以将它们视为任何其他普通的文字字符。正如您现在所知，在 Linux Bash shell 中有一些特殊字符，例如`* # [ ] . ~ ! $ { } < > | ? & - / , "`，它们对 shell 具有特殊含义，并且与普通字符不同。但是，如果您想要使用包含其中一个特殊字符的文件名或目录作为参数，该怎么办？另外，如何处理名称中带有空格的文件名，这也可以被视为特殊字符？

例如，如果您的目录中有一个名为`My private Documents.txt`的文件，您如何将其用作命令行参数？如果您将其与`ls`命令一起使用，由于空格是命令行参数分隔符，shell 无法将其视为一个独立的文件。相反，它认为您提供了三个名为`My`、`private`和`Documents.txt`的不同文件：

![](img/a27557b4-d315-4bc3-a904-ec2d1f82c080.png)

另外，如果你想使用包含特殊字符的文件，比如感叹号，例如，如果你有一个名为`!super!file!.txt`的文件，在 Linux 中这是一个有效的文件名？如果我们尝试将这个文件名作为命令行参数使用，它无法找到这个名称的文件，因为它包含特殊字符，而 shell 以不同的方式处理它们。或者如果你想要`echo`一些文本，单词之间有多个空格？正如我们所学到的，空格也是一个特殊的 shell 字符，用于分隔命令行参数。

![](img/9d5efe93-75b1-4979-a3a8-c157d1b5f47f.png)

在刚才展示的示例中，我们需要找到一种方法来禁用 shell 扩展并停止 shell 处理特殊字符。在参数中禁用 shell 扩展有两种简单的方法，即引用和转义。将特殊字符和空格放入单引号中将防止 shell 扩展并将所有可能的字符，包括特殊字符，视为普通的字母数字字符。在单引号中，任何东西都不会被 shell 扩展；对于大多数特殊字符，这也适用于双引号，但有一些例外。 

在下面的截图中，两个示例有效，但其他示例不起作用，它们会得到特殊处理：

![](img/0bbdb7b6-ba43-4bd5-aa7e-292f3ef3694c.png)

另外，如前面的截图所示，美元符号也保持特殊，这经常用于在引用时需要 shell 扩展环境变量。如前所述，单引号将禁用所有特殊字符。你可以通过使用反斜杠键来做到同样的效果，在 shell 中，它也被称为**转义字符**，几乎与引号完全相同，但它只会禁用 shell 扩展和下一个特殊含义，只有在反斜杠键之后的下一个字符：

![](img/cbb41cd7-c4ec-4108-adc7-56267743bd0e.png)

正如你所看到的，基本上是一样的。通常，转义字符用于通过在每一行中转义或禁用换行字符来创建清晰的多行命令行调用。反斜杠字符的另一个用例是在处理以破折号开头的文件等参数时使用它，因为这经常会让 shell 感到困惑，因为它会将任何破折号符号解释为选项。

例如，如果我们想创建一个名为`-dashy.txt`的空文件，这是行不通的，因为命令行混淆了并认为文件名是一个单字符选项列表。在这里，我们可以使用转义字符来摆脱破折号符号的特殊含义。对于以破折号开头的参数，一些命令，如`ls`或`touch`，还有另一个很棒的功能，双破折号，它标志着选项列表的结束。因此，为了将您的 dashy 文件作为参数而不是选项进行处理，我们还可以输入`nano -dashy.txt`或`touch '-dashy.txt'`命令。

正如你已经学到的，shell 中存在许多特殊字符，例如 shell 通配符字符或感叹号。如果你想使用这些字符，而不是扩展文件列表，而是在文件名或其他文字命令参数中使用它们，该怎么办？你需要禁用它们。使用单引号将禁用所有特殊字符，并且在 shell 中工作时是首选的方式；它适用于几乎所有日常引用用例。在使用双引号时，大多数特殊字符会被禁用，但不是全部，比如环境变量的 shell 扩展。因此，这种方法对包含普通字符和环境变量值的文本创建非常有用。反斜杠或转义字符将仅禁用接下来的字符的任何特殊含义。

# 获取帮助

在我们开始教您如何使用 Linux 命令的各种文档形式获取帮助之前，我们首先必须学习如何阅读默认命令语法文档。Linux 中提供的大多数标准 shell 命令都遵循描述其用法的统一格式。之后，我们将向您展示如何获取帮助。

在使用 Linux 命令行时，获取帮助并查找信息和文档非常重要，因为命令行可能非常复杂，没有人知道并且能记住一切。在每个 Linux 系统上，有几种可用的方式可以获取帮助，具体取决于您需要了解的信息级别。在本节中，我们将利用不同的文档来源。

在前面的部分，您已经学习了 Bash shell 命令的一般结构以及您需要了解的关于命令选项和参数的一切，但通常这是不够的。对于许多 shell 命令，选项和参数的特定结构非常复杂。一个命令可以绑定到特定位置，其中一些可能是强制性的或可选的。此外，选项和参数可以相互依赖。在 Linux 中，命令的命令行格式描述，包括参数和选项，称为**命令用法**或**命令的语法**。学习阅读命令用法是 Linux 初学者在开始时需要学习的最基本的技能之一。在 Linux 中描述命令用法的标准方式是命令名称，包含文本的方括号，点和文本，例如，`CommandName [XXX]... TEXT`。方括号表示其中的内容是可选的。三个点表示点之前的表达式可以重复多次或仅一次。没有方括号的任何单词都是强制性的。

例如，`ls`命令的一般语法，您已经知道如何使用。从官方`ls`手册中，可以读取为`ls [OPTION]... [FILE]...`；这意味着列出文件的命令具有以下用法。它以`ls`命令名称开头，其他所有内容都在括号中，因此所有选项和参数都是可选的，这意味着您也可以只通过按*Enter*键来执行`ls`而不提供任何其他信息。但您也可以提供多个选项或仅一个。此外，我们可以看到参数是`FILE`类型，这意味着在这个位置需要一个文件或目录。您还可以提供多个文件或目录，或者只有一个或零个，如下面的屏幕截图所示：

![](img/254bdc69-e724-4e5b-a1ce-877a01332fd6.png)

另一个例子是`copy`命令可以通过使用`cp`命令名称后跟零个或多个选项来运行。`cp`命令的语法是`cp [OPTION]... SOURCE... DEST_DIR`。您可以完全跳过选项，但至少一个或多个源目录和一个目标目录是强制性的，并由三个点表示，没有它们您无法运行该命令。例如，仅运行`cp`而不提供至少两个参数会产生以下错误。正确的用法应该包括所有选项：

![](img/1054ecf2-c917-41b4-841b-6e4bfcdb8b17.png)

现在我们知道如何阅读任何标准命令语法或用法，那么我们如何实际获取帮助呢？正如我们之前所说，有几种可用的方式，即命令帮助选项、man 页面和完整的程序文档。通常，所有这三种类型的帮助都与命令行或程序一起安装，因此首先尝试在相同的机器上本地获取 shell 命令的帮助是一个非常好的习惯。这通常是每个命令的最准确、可靠和最新的信息，并且应该优先于在互联网上进行研究或使用来自具有不同 Linux 版本或系统的其他计算机的文档。

通常在博客或论坛中找到的互联网解决方案对于您特定的 Linux 安装来说太不具体或纯属错误，应始终谨慎使用。永远不要盲目地从互联网上复制和粘贴命令片段。

命令参数、选项和功能可能会随着版本和实现的变化而发生变化，如果错误应用，可能会非常危险。Linux 上有数百个可用的命令，每个命令都有不同的语法。没有人可以记住所有内容，所以让我们首先从获取任何标准 Linux 程序的快速帮助的最简单和最快的方法开始。实际上，大多数程序都有一个特殊的命令行开关，可以在屏幕上打印出其选项和参数的快速摘要，这在大多数情况下就是您需要了解的全部内容。但是，在 Linux 上，帮助或使用标志并不是标准化的，有些命令甚至根本没有这个标志，但大多数工具开发人员遵循使用单字符标志`-h`或长选项标志`--help`的规则。

并非所有 shell 命令都有帮助选项，特别是那些非常简单的命令。

现在，如果您需要更多帮助，您可以查看命令手册，Linux 用户通常称之为**man 页面**。大多数程序都有这样的文档。对于接下来的几个示例，您需要使用您在安装过程中设置的 root 帐户密码安装一些额外的软件。man 页面使用较少的导航，我们将在学习如何查看文本文件时稍后讨论。

以下步骤将帮助您在 Linux 终端中导航到任何命令的手册：

1.  打开终端，输入`man cp`以查看`copy`命令的手册。

1.  使用*Page Up*和*Page Down*键向上和向下滚动文档，斜杠（*/*）可用于搜索文本；在斜杠后面放置任何关键字进行搜索，然后按*Enter*。例如，`/backup`。

1.  按*End*键搜索 man 页面中的下一个条目。

1.  要退出搜索选项，请使用*Esc*键。

1.  使用小写字母*g*，您可以滚动到页面顶部，而大写字母*G*则可以滚动到页面底部。

1.  您可以按小写字母*q*退出 man 页面。

当您返回页面顶部时，`cp`命令的 man 页面被分成不同的主题和标题，如下面的截图所示：

![](img/a16d1618-56c7-43fa-ad49-b81e6ee9cf5f.png)

大多数标准的 Linux 命令都遵循这种结构。此外，您可以在这里看到，一些命令可以根据给定的选项和参数具有不同的使用格式。现在，使用*q*键退出。`man`命令有一个非常有用的选项，输入`man -k`，然后在参数后面放置任何感兴趣的定义。这将搜索系统上安装的所有 man 页面，以查找特定关键字。例如，如果您忘记了特定的命令名称，或者需要关于主题或要使用的命令的一般帮助，或者首先查找的位置，这将非常有用。如果您键入`man -k copy`命令，这将打印出所有与复制有关的命令的 man 页面：

![](img/ad0c03ec-3196-4227-9505-5a66403941ef.png)

在使用`-k`标志时，您还会看到搜索结果在 man 名称后面写了一些数字；这些是 man 页面部分，这是另一个非常有用的概念，我们需要了解。Linux shell 定义，例如`printf`，可以描述的不仅仅是命令行程序，man 页面不仅仅描述命令行工具。在我们的例子中，`printf`不仅是一个可以由 shell 用户启动的命令行工具，还是 C 编程语言中使用的库函数的名称。`man`现在为特定 man 名称的类型定义了一套部分编号系统。键入`man man`将显示`man`命令的手册文档，并搜索键盘部分，如下所示：

![](img/e1609794-341f-41c7-b07b-b02aa13663cb.png)

正如我们在之前的截图中看到的，man 命令的 man 页面有九个部分。第一个对我们来说是最重要的，因为我们很可能是 shell 命令的用户。但是，正如你所看到的，第三部分是一个库调用。输入`man printf`，它会打印`printf`命令的用法。另一方面，如果你输入`man 3 printf`，它将打印 C 语言的 Linux 程序员手册。

让我们跳到第八部分，这是为系统管理员编写的`xfs_copy`命令的手册。除了手册页面外，许多可以在 Linux 上安装或者与系统一起提供的命令，在文件系统中的特定文件夹位置都有额外和高级的文档。对于一些程序，还可以使用特殊的安装包安装额外的文档，我们将在本节后面学习。有时，这些额外的文档包含了如何使用程序的宝贵用法示例；关于内部算法或方法的信息；更改日志和许可信息；作者联系信息；历史记录；错误或限制列表；或者样本配置文件，我们稍后会谈到。

如果你在手册中遇到困难，或者手册对你来说不够，尝试查看你的 CentOS 7 标准文档路径中是否存在你感兴趣的命令的文档文件夹。例如，输入`postfix`文档文件夹所在的位置。这是一个很好的例子。如果你进入该目录，你会发现很多文本文件格式的额外文档。更多信息请参考以下截图：

![](img/353c36f2-8d79-4fe1-a1d8-8766fee5dd81.png)

使用 less 程序来阅读文件。使用与 man 页面相同的键盘快捷键来浏览文件，例如，输入*q*退出。

如果你需要更多或高级文档，请查看`/usr/share/doc`文件夹，看看是否有适合你的内容。

# 使用 Linux shell

在本节中，我们将学习如何在 shell 中高效工作。我们将介绍一些重要的实践和技术，这将提高你的生产力，使你成为一个更快的 shell 命令黑客。这可以让你成为一个更快乐的人，因为最终，你将能够感到非常舒适地在 shell 中工作。请注意，在本节中，我们将向你展示很多键盘快捷键。学习键盘快捷键就像学习任何其他技能一样，你要慢慢开始，因为一次学习太多新技能会让你感到不知所措，比学习小块的知识更容易忘记。我的建议是从学习前三到四个命令编辑快捷键开始，然后逐日或逐周增加更多。我们将从命令编辑快捷键开始。现在，如果你根本不知道任何命令编辑快捷键，让我们回顾一下你可能已经知道的如何在命令行中输入和编辑文本。

移动光标位置的第一个快捷键是使用左右箭头键，这有助于编辑你输入的文本，在特定位置插入或删除字符。但如果这是在 shell 中所能做的一切，那么在 shell 中工作将会非常低效，因为单个字符的光标移动非常缓慢。此外，每当使用有错别字的命令或者需要以稍有不同的方式重新运行命令时，例如更改一个选项，就需要从头到尾重新输入完整的命令。

为了更高效，让我们介绍一些非常重要的命令编辑快捷键，用于你在 Linux 中的日常工作：

+   要将光标移动到行尾，使用*Ctrl* + *E*。

+   要返回到开头，分别按下*Ctrl* + *A*，*Ctrl* + *E*，*Ctrl* + *A*。

+   将光标移动到下一个单词，该单词由空格或特殊字符（如句点、分号或点）定义，使用*Ctrl*和右箭头键向前移动。

+   要向后移动一个单词，请按住*Ctrl*键并使用左箭头键。您还可以使用*meta* + *F*和*meta* + *B*来执行相同的操作。

+   在大多数系统上，就像任何普通 PC 键盘一样，没有元键，因此元键映射到*Esc*或*Alt*键。

在某些终端仿真器（如 Xfce4 终端）中使用*Alt*键保留用于菜单可访问性。因此，在使用它作为快捷键之前，您必须在首选项中禁用*Alt*键作为菜单快捷键。

+   要在当前位置和行的开头之间切换，请两次按*Ctrl* + *XX*。

+   按*Ctrl* + *K*删除光标到命令行末尾的文本。

+   要删除光标到命令行开头的文本，请按*Ctrl* + *U*。使用*Alt* + *D*删除到单词的末尾。

我们刚刚讨论的所有命令编辑键盘快捷键都是您日常使用中最重要和高效的快捷键，还有很多很多。

要获取所有 Bash 键盘快捷键的完整列表，请执行以下操作：

+   输入`man bash`，然后搜索移动命令的部分

+   在此手册页中搜索`Killing`

+   在此手册页中，*C*键是*Ctrl*键，*M*键是元键，破折号表示组合或按住两个键，就像我们之前使用*Ctrl* + *A*快捷键所示的那样

例如，`C-k`代表**kill-line**，它会删除从光标到行尾的文本。*Alt* + *T*用于交换单词，`M-u`用于将单词大写，`M-l`用于将单词小写。

现在，让我们继续讨论命令完成快捷键。最重要的命令完成快捷键是键盘上的*Tab*键。它会尝试猜测并自动完成您即将输入的命令。这非常有用，可以大大加快输入命令的速度，但是在使用此键时不要过度使用，如果没有可用的替代方案，它只能打印完整的唯一命令名称。输入`pass`并按*Tab*键；它将自动完成名称`passwd`，因为没有其他具有完整名称的程序。输入`pa`并按*Tab*键；这将给出几个结果，因为找不到唯一的名称。输入`yp`并按*Tab*键；这将自动完成为长名称，因为这是唯一的`variant`。*Tab*快捷键默认情况下自动完成命令；要自动完成其他内容，如文件名，请使用*Alt* + */*键。在 Bash 手册中的相应部分中可以找到更多信息。

现在，让我们看一下命令回调快捷键。Linux shell 具有一个非常好的功能，即`history`命令。这是一个用于存储和检索输入到 shell 中的所有命令的系统。在 CentOS 7 系统上，默认情况下会存储最近的一千个命令。这个数字也可以更改。命令行历史记录是一个非常有用的功能，可以节省时间，不用重复输入，或者查看一段时间前如何执行特定命令。要打印当前历史记录，请输入`history`并按*Enter*。如果要从此列表重新执行命令，请使用感叹号和相应的数字。两个感叹号运行历史记录中的最后一个命令。另一种感叹号符号表示可以从历史命令中提取特定参数。这将从`history`命令中提取第三个参数`166`，如下图所示：

![](img/8a19d06c-e425-49dd-8361-beb6320793cd.png)

另一个非常有用的历史功能是回调上一个命令：

+   要浏览以前执行的历史命令，请按键盘上的上箭头键。

+   要返回到下一个历史命令，请使用下箭头键。

+   要在历史记录中搜索命令，请按 *Ctrl* + *R*，然后输入搜索关键字。

+   要循环浏览结果，请再次按下 *Ctrl* + *R*。

+   要运行找到的特定命令，请按 *Enter* 键。

+   要快速插入上一个命令的最后一个参数，请使用 *Alt* + 点。

+   另一个非常有用的功能是手动扩展一行而不实际执行该行，这对于查找错误和框很有用。这可以使用 *Ctrl* + *Alt* + *E* 来完成。

接下来，我们需要知道如何使用程序和进程。首先，我们将讨论如何中止任何正在运行的程序。如果需要退出命令，因为它没有响应或者您犯了一个错误并希望停止它，这一点非常重要。例如，让我们输入 `cat` 命令，它将永远运行。让我们暂时忽略此命令目前正在做什么。这会使 shell 无响应，因为 `cat` 永远不会在我们的 shell 前台完成运行并永远运行。为了回到 shell 提示符，以便我们可以再次输入新命令并继续工作，我们需要在其运行时退出命令。在 shell 中，我们可以使用一个特殊的组合键来退出当前前台进程。按下 *Ctrl* + *C*。

这是一个非常重要的快捷键，应该记住：*Ctrl* + *C*。

您还可以暂停一个程序，就像暂停其处理并将其放入后台，这样您就可以再次在 shell 中工作。可以按照以下步骤完成：

1.  按下 *Ctrl* + *Z*。如果以后想要继续在前台运行程序，输入 `fg` 然后按 *Enter*。

1.  您还可以在暂停时使用 `bg` 命令将其放入后台。现在程序在后台运行，您可以在前台工作。

1.  退出后台运行的程序的最简单方法是将其放到前台，然后使用 *Ctrl* + *C* 中止它。

1.  下一个非常有用的命令是按下 *Ctrl* + *L*，这将清除屏幕，与 `clear` 命令具有相同的效果。

1.  我们将在这里学习的最后一个非常有用的命令是按下 *Ctrl* + *D*，这将关闭 Bash shell。这类似于输入 `exit` 命令。

# 理解标准流

在本节中，您将了解为什么每个命令都可以使用三个标准流来访问其输入和输出。此外，您还将学习如何使用这些输入和输出流以及如何使用重定向。最后，我们将学习如何使用管道以及它们为何如此重要。Linux 操作系统的一个理念是，每个命令在系统中都有确切的功能，没有多余的，也没有不足的。例如，有一个命令用于列出文件，另一个用于对文本进行排序，还有一个用于打印文件的内容，等等。

现在，shell 的最重要功能之一是连接不同的命令，以创建定制的解决方案和工具来解决各种问题和工作流程。但在我们展示如何将不同的命令连接在一起构建强大的东西之前，我们首先需要知道命令如何使用其输入和输出，以及输入和输出重定向是什么。大多数 Linux 命令在处理数据时遵循类似的模式。我们使用的大多数命令都会获得某种输入，例如，它们读取文件的内容，然后处理这些信息，之后几乎所有命令都会在计算机屏幕上输出某种结果。因为每个命令在 Linux 上都会使用某种输入并返回某种输出，所以为每个命令定义了三个标准通道，并且这些通道对于每个命令都是可用的。它们用于在执行期间操作系统和命令之间的通信。它们被称为**标准输入**或 `stdin`，**标准输出**或 `stdout`，以及**标准错误**或 `stderr`。

正常程序输出进入`stdout`通道，而`stderr`也是一个输出流，可以用于显示和处理在执行命令时发生的任何错误消息。这些也被称为**标准流**。它们被称为流，是因为数据通过特定通道持续流动，并由命令连续处理或生成，尽管它们有一个开放的末端，这意味着使用它们的命令无法预测数据流何时会停止或结束。现在，我们可以使用特定文件更改`stdin`和`stdout`的位置；这称为**重定向**。

在这一部分，我们还将解释管道的概念，这是 Linux shell 最基本的概念和主要特性之一，以及如何使用它们。例如，如果您键入`ls /var/lib/system/`，结果 random-seed 将被打印到屏幕上，因为它默认为每个 Linux 命令的`stdout`设备。但是，如果您键入`cat /var/log/messages`，错误消息将打印到同一屏幕上，因为`stdout`和`stderr`都连接到同一输出设备，即屏幕。

在 Linux 上，您的物理输入和输出设备，如键盘或屏幕，与其他硬件设备一样，都是通过特殊的系统文件进行抽象和表示的。所有这些特殊文件都驻留在一个名为`/dev`的系统目录中，也称为**系统设备目录**。但是我们可以用这样的系统做什么呢？它的美妙之处在于我们可以将命令的输入和输出重定向到除默认键盘和屏幕源或目的地之外的其他位置，这些位置也必须是文件类型。这对将`stdout`和`stderr`分开到两个不同的位置也非常有用，特别是在命令产生大量输出时有助于保持概览。

对于输出通道重定向，我们使用大于号（*>*），对于输入重定向，我们使用小于号（*<*）。要处理特定通道，如`stdin`、`stdout`和`stderr`，我们使用相应的数字`0`、`1`和`2`。在使用输出重定向时，期望`stdout`通道，因此我们不必明确写出它。在 99%的情况下，您只需要重定向`stdout`和`stderr`，因此让我们专注于这些示例。

要将命令的`stdout`流输出重定向到文件，请使用大于号。如前所述，期望`stdout`通道，因此最后一个命令也可以输入如下：

```
ls /var/lib/systemd/ > /tmp/stdout-output.txt
ls /var/lib/systemd/ 1> /tmp/stdout-output.txt  
```

使用`card`命令打印出刚刚通过重定向到`stdout`创建的文件的内容。要重定向`stderr`通道，请使用数字`2`作为标准流描述符。以下截图显示了先前命令的输出：

![](img/7b04e011-9e42-422d-9fa8-43cc7e64a47e.png)

正如您所看到的，错误消息已被重定向到一个文件中。要将`stdout`和`stderr`重定向到两个不同的文件中，请输入以下截图中显示的命令：

![](img/7a3bd9a4-0228-48af-9ca0-c832a49f06f2.png)

另一种表示法，使用*和符号*允许将一个通道重定向到另一个通道。要将`stderr`重定向到`stdout`通道，请输入以下截图中显示的命令：

![](img/5754adbc-5759-4200-8c37-19fcac394707.png)

有时，您只对一个输出流感兴趣，因此在任何 Linux 系统中都存在一个特殊的设备文件，称为`null`设备，它会消耗并消失任何被重定向到它的流数据。如果您不希望对任何命令输出任何输出，例如，您可以使用以下截图中显示的命令：

![](img/11f2e005-80c4-41aa-a86b-3a34ca25356a.png)

最后，要重定向`stdin`，您可以使用小于号[`<`]。例如，这可能非常有用，因为一些可用的 shell 命令可以直接读取文件的内容作为`stdin`，比如`grep`命令，我们稍后会学习。

现在，让我们讨论管道。除了将命令的默认输入和输出流`stdin`、`stdout`和`stderr`重定向到文件之外，我们还可以使用 shell 管道的概念，将一个命令的输出作为另一个命令的输入。这个系统没有限制，非常容易构建多命令链，为您回答非常复杂的问题。正如之前提到的，这个 shell 功能可以让您创建非常强大的命令管道和工作流程，为各种 Linux 命令行工作创建定制解决方案，并为您回答非常复杂的问题。

要将命令链接在一起，也就是将第一个命令的`stdout`作为下一个命令的`stdin`使用，我们使用键盘上的竖线符号[`|`]，在 Linux 中称为**管道**符号。例如，如果您有一个非常长的目录内容列表，您希望在终端窗口中不断滚动地阅读，您可以使用管道将`ls`命令的目录内容输出到屏幕上，而不是直接作为文件查看器的输入，就像我们之前学到的那样。通常，管道用于避免中间结果文件，并且没有它们更有效率。这种用法的用例是无穷无尽的，例如，如果我们有一个包含未排序人名的文件，我们可以使用`cat names.txt | sort`进行排序：

![](img/06f54597-854a-4347-bc93-2c6b62fa8f2b.png)

您还可以获得此文件中所有唯一名称的列表。我们将使用唯一命令来执行此操作，该命令仅适用于已排序的列表。因此，我们需要使用`cat names.text | sort | uniq`进行排序：

![](img/729cab59-0336-4c7a-a106-a3cd9c908b25.png)

您还可以使用单词计数命令行工具来计算唯一行的数量，使用`cat names.text | sort | uniq | wc`：

![](img/ef883ce1-f0bb-4d18-ba83-41772fec0efe.png)

此文件中有相当多的唯一名称。在管道示例方面，天马行空，例子太多。理想情况下，应该使用`root`用户帐户运行。请忽略错误。以下屏幕截图显示了文件系统的核心摘要：

![](img/72686415-4aae-4ceb-ac5d-9819e377693e.png)

另一个有用的管道命令是打印目录中使用的文件。如果您使用的是 Windows 系统，您可能知道一个称为 ZIP 的实用程序，它可以压缩文件。在 Linux 上，您可以做类似的事情，但是这里我们需要两个工具一起工作。对于压缩，我们使用`gzip`工具。因为`gzip`只能处理单个文件，所以我们首先需要创建一个将多个文件连接到单个文件的存档。对于存档，我们使用`tar`命令。因此，要在`/tmp`目录中创建您的主目录的压缩存档，请首先使用`tar`命令创建您的主目录的存档：`tar -cv /home/olip/ | gzip`。存档将输出到`stdout`流，因此我们将其作为`stdin`管道到`gzip`命令。因为 gzip 本身将压缩文件输出到`stdout`，所以我们将其重定向到文件。压缩与未压缩数据量的结果如下：

![](img/4fd858d0-e6f0-4260-bf40-0183ec1aa613.png)

本书将展示更多的管道示例。如果将`stdout`或`stderr`重定向到文件，通常情况下，如果文件已经存在，它将被删除，或者在写入任何内容之前将创建一个新文件。为了不删除文件，而是追加内容，使用大于号。例如，要创建一个新的输出文件，请执行以下屏幕截图中显示的命令：

![](img/47b8f3be-2e24-459d-a657-e025a89885db.png)

现在，要将字符串`Hello World`附加到输出文件，我们将使用大于号。这不会在我们开始将内容重定向到文件时删除文件的内容。相反，它将在文件末尾附加内容。如前所述，管道是 shell 中最重要的概念之一，与它们一起工作非常有趣。

# 理解正则表达式

在本节中，我们将介绍正则表达式的奇妙艺术。您将了解它们是什么，以及它们为何如此强大。有许多不同的正则表达式字符可用，在这里我们将介绍最重要的字符。之后，您将学习如何使用`grep`命令应用正则表达式来查找、提取和过滤文本文件中的有用信息。**正则表达式**，简称**regexps**，是一种非常强大的概念，用于使用特殊模式搜索文本，描述搜索项的结构，而不是在这种情况下称为**文字文本搜索**的常量字符字符串。使用正则表达式可以节省大量时间，不需要重复工作，Linux 系统管理员在日常工作中广泛使用它们。

在*文件 globbing*部分，当我们使用 globbing 字符查找模式以寻址具有一些特殊字符的多个文件名时，我们学习了一个非常相似的概念。正则表达式是一个更强大的工具；它们包含了一组非常广泛的特殊字符，用于完全或部分匹配甚至最复杂的文本片段。在 Linux shell 中，我们使用正则表达式不是为了 shell 扩展或对文件名进行分组，而是为了处理文本文件或文本行的内容，以解析和分析其内容或从中提取文本特征。如前所述，正则表达式是一个非常复杂的主题，我们只能在这里给您一个概述。请注意，有几种风格的正则表达式可用，例如 Perl 正则表达式。在我们的示例中，我们将使用大多数 shell 工具使用的 POSIX、基本和扩展正则表达式。有许多不同的正则表达式字符可用，也称为**元字符**。

由于一些元字符是扩展的 POSIX 字符，我们需要在扩展模式下启动我们的正则表达式处理命令。

一些扩展表达式如下：

+   `n`用于匹配行的末尾。

+   `t` 匹配顶部的空格。

+   插入符`^`符号匹配行的开头。

+   美元符号`$`匹配行的末尾。

+   `[x]`与 globbing 括号非常相似，您之前已经学过。这描述了在特定位置的括号内匹配的字符类。您还可以在这里定义字符范围。

+   `[^x]`匹配在括号中未定义的所有字符。

+   括号用于分组；这将保存括号内的文本以便以后引用。

+   数字`1`用于反向引用。这将从括号中提取引用的数字*n*。

+   `a|b` 表示在此位置允许*a*或*b*。

+   `x*` 表示匹配在此位置的零个或多个*x*字符。

+   `y+` 表示匹配在此位置的一个或多个*y*字符的多个出现。

+   点表示匹配特定位置的任何字符。

还非常重要的是，许多使用正则表达式的工具，如`sed`和`awk`，期望正则表达式被斜杠包围。另外，脚本语言 Perl 也采用了这种风格。在`grep`等其他工具中，您不需要使用斜杠表示法。

让我们首先用`grep`命令来实验一下我们的新正则表达式概念。我们使用`egrep`命令行工具启动扩展模式的 grep。你也可以用大写的`-E`选项来运行`grep`命令，效果是一样的。`grep`是一个命令，它逐行遍历文本文件或输入流，并尝试将给定的搜索模式参数与每一行进行匹配。如果特定行匹配模式，它将打印出完整的行。这对于各种文本提取非常有用，`grep`是 Linux 上最重要的命令行工具之一。事实上，我在 shell 中工作的一天中，几乎没有不使用它的。很多时候，`grep`被用作管道命令工作流的一部分，以减少你想进一步处理的大量输出文本。

首先，正如前面所说，我们将使用 POSIX `regex`。有很多不同的正则表达式术语，太多了，无法记住，所以每次需要查找语法时，输入`man 7 regex`。在这个手册中，你会找到关于正则表达式的所有你需要知道的东西。

让我们开始从文件中提取各种信息。我们将首先使用`grep`命令，而不是使用正则表达式，而是搜索简单的文本字面量，`grep root /etc/passwd`。这将返回`passwd`文件中包含单词`root`的所有行。输出中的任何行都会给我们提供属于`root`用户的信息。正如你所看到的，grep 会遍历整个文件，并找到包含字符串`root`的所有行。一个非常有用的`grep`选项是`-i`。这可以用于忽略搜索项的大小写敏感性。例如，执行`grep -I root /etc/services`。这将找到单词`root`的所有出现，同时忽略大小写。这也将找到单词`root`的所有其他大小写排列。当使用正则表达式作为`grep`、`sed`或`awk`等命令的参数时，建议用*单引号*引用你的元字符。这是因为一些正则表达式字符与 shell 通配符字符相同，比如通配符字符，这是不好的。在任何参数被输入任何命令之前，shell 扩展总是发生的，所以使用正确的命令而没有禁用通配符字符会搜索包含你想要搜索的特定文件中所有文件名的字符串。

相反，总是将你的正则表达式元字符放在单引号中。另外，如果你想在文件中搜索与正则表达式元字符相同的特殊字符，你需要转义该字符，这与我们在*文件通配符*部分学到的使用反斜杠键类似。以下截图说明了本节开头提到的每个元字符的一个例子：

![](img/42eee779-0e46-4aed-92b0-61cbec2cfdf6.png)

美元符号匹配行尾，因此这将打印出在 services 文件中以 data 结尾的所有文件。类似地，我们使用插入符`^`符号来匹配行首。以下命令在这里匹配所有以单词`day`开头的行：

![](img/f06d6723-c123-4b1a-9b61-c158f5d503cb.png)

括号表达式是括在方括号中的字符列表。它通常匹配列表中特定位置的任何单个字符。您还可以使用破折号符号在方括号中定义范围，类似于我们在*文件通配符*部分中展示的那些。如果括号中的列表以插入符号开头，它匹配不属于此列表其余部分的任何单个字符。普通括号可用于保存其中的匹配的引用。要进行反向引用，我们使用括号表达式的`/number`，以便正则表达式匹配所有以第一个字母开头的行，例如，`egrep 't(ac)1*s' /etc/services`。管道符号代表*或*，因此下一个表达式匹配所有包含**domain**或**gopher**的行。点匹配特定位置的任何字符。加号表示匹配字符之前的零个或多个出现，因此这个正则表达式匹配所有包含`at-`的行，但不是在行末。星号元字符匹配字符之前的一个或多个出现，因此这里的`egrep 'aa+' /etc/services`表达式匹配所有包含至少两个`aa`或更多的行。加号字符匹配字符之前的一个或多个出现，因此这个正则表达式在这里匹配所有的行。

如前所述，点匹配表达式中特定位置的每个字符，因此正则表达式匹配所有包含与表达式中的点数相对应的字符数的行。`grep`有许多有用的选项，例如，`-v`反转搜索匹配，这意味着打印出所有不包含搜索模式的行。我经常使用这个选项来删除所有以井号开头的空行和命令行在许多配置文件中的 shell 脚本文件。例如，执行以下截图中显示的命令：

![](img/43c20227-c279-46f3-a1f7-9f1422d30d33.png)

手册包含许多以井号和空行开头的命令行。要过滤掉所有这些不需要的行，可以使用`grep -v`选项。另一个有用的功能是`grep -o`选项，它只打印匹配的模式，而不是完整的行。因此，例如，`egrep 'netbios-...' /etc/services`会打印出完整的行，而`-o`选项只会打印出模式中的纯 NetBIOS 名称。

# 使用 sed 进行工作

在本节中，我们将学习关于`sed`命令，这个强大的流编辑器。我们将为您简要介绍`sed`的工作原理，并向您展示自动替换文本和文件的替换模式，这是最重要的可用模式之一。接下来，我们将学习关于`sed`命令。让我们首先检查它的语法：

```
sed [OPTION] 'pattern rule' FILE  
```

`sed`代表**流编辑器**，这个命令可以在没有任何用户交互的情况下自动编辑文件。它逐行处理输入文件。通常情况下，`sed`用于 shell 脚本中，将任何命令的输出转换为进一步处理所需的形式。大多数`sed`的日常用例都遵循类似的模式，最简单的形式是首先使用正则表达式或其他模式来定义要在输入文件或流中更改的行，然后提供一个规则来更改或转换匹配的行。与`grep`命令类似，使用`sed`时总是使用单引号，除非您需要在`sed`表达式中使用环境变量，那么您应该改用双引号。通常情况下，`sed`从`stdin`读取，内部处理流，并将文本的转换版本输出到`stdout`。因此，它最好用在`pipe`命令中，因此它经常是管道的一部分。`sed`可以用于许多不同的用例。

使用地址范围的一个非常简单的示例是`d`选项，用于删除，这也有助于您了解`sed`如何在输入和输出流上进行处理。因此，再次，`cat /etc/services | sed '20,50 d'`将`etc/services`文件流使用`cat`管道传输到`sed`。`sed`逐行处理输入流，在这里，所有不在 20 到 50 行之间的行直接处理到`stdout`通道，而 20 到 50 行的行完全被抑制。您还可以在`d`选项中使用正则表达式。请记住，在使用`sed`时将任何正则表达式放在斜杠中。`sed`命令会忽略以井号符号开头的所有行，但会将所有其他行打印到`stdout`。有许多不同的选项和模式可以工作，但这里提及的太多了。

`sed`的最重要用法肯定是替换模式，它可以用于自动化文件或文本编辑，无需任何用户交互。其一般语法是：`sed 's/search_for_text/replace_with_text/' FILENAME`。这将在文件 filename 中搜索第一个斜杠之间的模式，该模式可以是正则表达式或文字表达式，并且仅当此模式在文件中的某行中的文本与之匹配时，才会被另一个斜杠之间的文本替换。这仅适用于文件中的第一次出现。如果您需要替换文件中搜索文本的所有出现，必须在斜杠表达式的末尾使用`g`选项。例如，要替换`passwd`文件中的单词`root`为单词`King_of_the_Jungle`，并且要替换每次出现，执行以下屏幕截图中显示的命令：

![](img/5a46e9cd-26af-4ed3-a86b-9dc62120a57c.png)

如果您正在搜索包含斜杠的任何内容，可以使用不同的模式分隔符来转义常规替换用法，否则您将需要转义要搜索或替换的斜杠字符，这看起来可能非常复杂和无结构。这也可以写成`sed 's:XX:YY:g' FILENAME`，或者您选择的任何其他字符。例如，如果您想在文件中用双斜杠替换单斜杠，而不是使用`sed 's//////g' FILENAME`，最好使用`sed 's:/://:g' FILENAME`或`sed 's#/#//#g' FILENAME`。在不带任何`sed`选项的替换模式下，将始终将转换后的文本打印到`stdout`。有时，直接更改输入文件中的文本是有用的。这可以使用`sed -i`选项或内联选项来完成。

在以下示例中，我们将处理`passwd`文件的副本，以向您展示如何进行原地编辑。为此，请执行以下步骤：

1.  在`/tmp`目录中创建`passwd`文件的副本，如下屏幕截图所示：

![](img/140e3682-1a00-4c39-acce-e0199bc574f8.png)

1.  让我们首先显示所有包含单词`root`的行。

1.  接下来，在文件中用随机文本替换`root`一词，仅在`stdout`上执行以下命令：

```
sed 's/root/RULER_OF_THE_WORLD/g' /tmp/test-passwd | less  
```

1.  现在要进行原地编辑文件，请使用`-i`选项：

```
sed -i 's/root/RULER_OF_THE_WORLD/g' /tmp/test-passwd
less /tmp/test-passwd  
```

文件已经永久更改。在使用此选项时请小心，因为如果您在进行替换之前没有测试过，并且犯了一个错误，您将无法恢复更改。在应用原地编辑之前最好创建原始文件的备份副本，您可以使用`sed -i`选项来执行此操作，例如，`sed -i.bak 's/root/RULER_OF_THE_WORLD/g' /tmp/test-passwd`。如果在`-i`选项后面写入新的扩展名，例如`.bak`，它将在将正则表达式应用于原始文件之前创建一个带有扩展名`bak`的备份副本。在使用这些正则表达式进行替换模式时，我们之前向您展示的分组和反向引用功能使替换非常强大，因为这使您真正控制了需要对输入文本进行的更改，例如，`passwd`文件包含冒号作为字段分隔符，一个冒号用于分隔一个字段。使用 sed 进行反向引用时，我们可以用四个冒号替换一个冒号：

![](img/cd6696d5-77cc-4f47-b11a-8b0eb26bafee.png)

由`grep`、`sed`和`awk`使用的 POSIX 扩展正则表达式还在括号中定义了许多非常有用的特殊字符类，这在模式匹配中非常有用。一般的语法是`grep '[:digit:], [:space:], [:blank:]'`。数字括号字符类匹配特定位置的所有数字。空格匹配所有空格，空白匹配所有空格，例如*Tab*空格，空白匹配所有空格。要匹配`etc/passwd`文件中包含数字的所有行，请使用`grep '[[:digit:]]' /etc/passwd`。要查看所有特殊字符类的列表，请使用`man 7 regex`手册。

# 使用 awk

在本节中，我们将向您展示`awk`命令的全部内容以及它对我们而言的重要性。我们还将向您展示如何将其用于文本文件操作和处理。`awk`是另一个非常重要的文本处理和操作工具。它可以作为一个完整的脚本语言来处理文本文件或流。它包含一些非常强大的编程结构，包括变量：*if...else*、*while*、*do while*和*for*循环；数组；函数；和数学运算。`awk`也像`sed`一样逐行处理。`awk`的一个关键特点，也是与`sed`的主要区别之一，是它会自动将输入行拆分为字段。但它是如何工作的，为什么它如此有用呢？

`awk`使您能够创建规则和动作对，对于每个匹配此规则或条件的记录，动作将触发。规则也称为**模式**，非常强大，并且可以使用**扩展正则表达式**。动作的语言类似于编程语言 C。使用`awk`符号范例在输入中查找模式，然后应用某种动作通常将复杂和繁琐的数据操作任务减少到几行代码，甚至一行代码。`awk`还允许您创建和执行强大的`awk`脚本文件，以自动化具有挑战性的文本转换任务，但在本节中，我们将仅专注于在命令行上使用`awk`选项和参数。请注意，由于`awk`是一个具有许多功能和选项的完整脚本语言，因此我们只能在这里向您展示最重要的用例和示例。

这是任何`awk`命令的基本结构：`awk [pattern] { action }...INPUTFILE`。重要的是要注意，动作必须用花括号括起来。这也可以理解为：逐行浏览输入文件，并尝试将模式应用于每一行。如果且仅当模式匹配或规则可以应用于该行并且为真时，花括号之间的动作将被执行。

学习和理解`awk`工具的最简单方法是在没有任何规则或模式的情况下使用它，并定义一个简单的操作。不给定模式，操作将应用于任何输入行。如前所述，`awk`完全将每个输入行拆分为字段，因此我们可以在操作参数中直接访问这些字段，使用以下表示法。与往常一样，操作和模式应放入单引号中：

```
awk '{print $1}' /etc/networks  
```

这将打印出`etc/networks`文件的所有行的字段`1`。正如您现在可能已经知道的那样，`awk`默认在每个空格位置拆分。您可以使用`-f`选项来更改字段分隔符。例如，要正确拆分具有冒号作为字段分隔符的`passwd`文件，您将使用冒号指定字段分隔符`-f`。这将打印出`etc/passwd`文件和用户名的第一个字段：`awk -F: '{ print $1 }' /etc/passwd`。您还可以使用 awk 的`printf`函数，它会按照您从其他编程语言中了解的方式打印出格式化的文本：`awk -F: '{ print "user: %stgroup: %sn", S1, S3 }' /etc/passwd`。`%s`将被字段号替换。`t`表示*Tab*字符，`n`表示换行字符。

现在，是时候测试一些模式了。如前所述，如果您定义的模式或规则也可以是扩展的正则表达式，它将应用于每个输入行，只有符合规则的行才会执行操作。

以下命令将打印出所有以小写`t`开头的行的第一个字段，并且只有这些行，位于`etc/services`文件中。在这里，我们将其传输到`head`命令中，以将输出减少到前 10 行：

![](img/a70171b9-8dff-44d3-af97-5cdd635d5fd9.png)

请记住，在使用`awk`命令时，将任何正则表达式放入斜杠中。awk 的最大特点之一是模式也可以不仅仅是简单的正则表达式。例如，您还可以在此处使用字符串和数学比较运算符。这将帮助您仅使用几个小表达式回答非常复杂的文本操作问题：

![](img/fc95c7e7-31df-4995-a9b3-17085cc0422c.png)

在前面的示例中，`awk`仅输出`etc/passwd`文件中组 ID 大于`500`的用户行。大于号是操作符。还有许多其他可用的操作符，但这里无法一一列举。例如，要匹配正则表达式，请使用`awk '$1 ~ /netrjs/ {print $0}' /etc/services`。波浪号是正则表达式匹配操作符。要匹配字符串文字，请使用两个等号，例如`awk '$1 == "netrjs-4" {print $0}' /etc/services`。要获取所有 awk 操作符的列表，请在 man 页面中搜索操作符。此外，`awk`还有两个特殊模式，称为**BEGIN**和**END**。与任何其他模式一样，您可以为开始和结束模式定义一个操作，这将在文件的开头或结尾处仅触发一次。我们可以使用这个功能来打印出目录中的总字节数：

![](img/fafc9ee2-d1d3-422c-92db-9bf188441ca1.png)

这个`awk`命令的工作方式是：首先它使用一个名为`SUM`的变量，它充当我们计数数字的容器。`+=`是一个数学运算符，它将字段号`5`添加到我们的容器`SUM`中，因此，此操作计算每行中字段`5`的单字节数字的总字节数。此外，在每行上，我们打印出整行内容，并且一旦到达文件末尾，将触发结束模式，它将打印出我们的`SUM`变量的内容，其中包含此目录中的总字节数。正如您刚才看到的，我们可以定义自定义变量来保存我们想要拥有和处理的值。awk 中还有许多预定义的变量名称，其中包含非常有用的信息。例如，`NR`变量名称包含当前行号。这在以下`awk`命令中可能很有用：

```
awk '{printf "Line number: %st%sn", NR, $0}' /etc/passwd  
```

这将使用`NR`变量在输出的每一行前添加行号，该变量包含每一行中的当前行号。要获取所有特殊的 awk 内置变量列表，请使用手册并搜索变量。

awk 包含许多非常有用的预定义函数，例如我们已经从操作语句中了解的`print`或`printf`函数。要在一个动作块中执行多个函数，可以使用分号。例如，awk 包含许多非常有用的字符串操作函数，例如`toupper(argument)`函数。awk 中的函数与大多数其他编程语言中的函数一样。您可以使用函数名称调用它，然后在括号中添加参数或参数。例如，我们在 awk 动作中使用`print`和`printf`函数。例如，在 awk 中存在一个名为`toupper`的字符串函数，它将每个字符串参数转换为大写字母。

以下是一个完整的使用`toupper`函数的`awk`命令行示例：

![](img/5addac74-524f-4f61-b729-45e5bfd8e3eb.png)

这将正常打印出`passwd`文件中的第一个字段，然后再次打印出所有字母大写的字段。我们的最终示例将向您展示如何在一个动作语句中使用分号作为表达式分隔符执行多个表达式或函数：

![](img/91e0abde-a7b5-4de3-be0e-d2bfdbd88dec.png)

此外，您还可以在此处看到，您可以将任何函数的返回值分配给变量名称，然后稍后引用此变量名称，因此，这个示例与之前的示例非常相似，首先打印出大写版本，然后是普通的小写版本，然后是普通的字段值版本。对于所有可用的 awk 函数，我们使用手册并搜索函数、数字函数、字符串函数、时间函数等。

# 导航 Linux 文件系统

在本节中，您将学习如何导航 Linux 文件系统。您还将了解 Linux 文件系统的结构。如果我们通过执行`tree -d -L 1 /`命令打印出根目录下顶级目录的文件夹结构，您将看到一系列听起来奇怪的目录名称。这些目录名称在任何 Linux 发行版上都是相同的，并且遵循一种称为**文件系统层次结构标准**（**FHS**）的标准。Linux 文件系统中的每个标准目录都有特定的目的，用户可以期望在特定位置找到某些文件，这也意味着程序可以预测文件的位置，也意味着任何使用这些系统目录的程序都可以预测文件的位置。以下是这些目录：

+   `/`斜杠是主要的层次结构根。

+   `/bin`包含系统所需的基本命令，例如，当系统出现故障时，用户可以在恢复模式下使用，或者例如，当用户启动到恢复模式时需要的可执行文件。

+   `/boot`包含用于引导的文件，例如内核文件。

+   `/dev` 包含了系统的设备文件，例如 `/dev/null`，我们之前使用过。这个目录非常重要，在你担任系统管理员时会经常用到。它包含了你在系统上安装的所有应用程序的系统范围配置文件。

+   `/home` 包含了用户的主目录，就像我们在本节中学到的那样。

+   `/lib` 包含了对 `/bin` 和 `/sbin` 中的二进制文件至关重要的库，接下来我们会看到。`/lib64` 包含了 64 位架构的必要的备用格式库。

+   `/media` 包含了可移动介质的挂载点，比如 CD-ROM。

+   `/mnt` 包含了临时挂载的文件系统。

+   `/opt` 包含了可选的应用软件包。

+   `/proc` 包含了提供进程和内核信息的虚拟文件系统，例如，当前会话的所有环境变量都存储在这里。

+   `/root` 包含了 `root` 用户的主目录。`root` 用户的主目录不在 `/home` 中。

+   `/run` 包含了运行时变量数据；这是关于系统自上次启动以来运行情况的信息。

+   `/sbin` 包含了必要的系统二进制文件。

+   `/srv` 包含了系统应该提供的所有数据，例如，用于网页服务器的数据和脚本，或者在系统上作为服务运行的 FTP 服务器提供的数据。

+   `/sys` 包含了连接到系统的设备的信息。

+   `/tmp` 包含了临时文件。每个用户都对这个目录有完全访问权限。

+   `/usr` 包含了大部分用户实用程序和应用程序，例如，用户安装的所有应用程序都在这里。它也被称为**次要层次结构**，用于只读用户数据；因为它有与根目录相似的结构，顶级目录。例如，你也有一个 `/usr/bin` 目录，一个 `/usr/lib` 目录，一个 `/usr/sbin` 目录，等等。

+   `/var` 目录用于系统正常运行期间预计会不断变化的所有文件，例如日志文件、溢出文件和临时电子邮件文件。

首先，让我们介绍 Linux 主目录的概念。Linux 系统中的每个用户都有自己在文件系统中的私人空间，他们可以在其中管理自己的数据，并且拥有对所有内容的完全访问权限，例如，创建目录或新文件，删除东西，或更改权限。出于安全原因，Linux 文件系统中的大多数地方，除了一些例外，例如系统的 `/tmp` 目录，都在某种程度上受到限制，通常登录的用户没有对其的完全访问权限，只有 `root` 用户对所有内容有完全访问权限。每个登录的用户都有一个当前目录的属性，这是你当前所在的目录。当用户登录到 Linux 系统时，默认情况下，他们特定的主目录将被设置为当前目录，因此他们将从这个目录开始。

要显示当前目录的名称，也就是你当前所在的位置，输入`pwd`，然后按*Enter*键。pwd 代表**打印工作目录**。这是一个非常有用的命令，因为当你浏览目录时，很容易迷失方向。目录是一种用于组织数据的概念。通常用于对属于同一项目或相同类型的所有文件进行分类，例如所有配置文件。正如你所看到的，`pwd`命令的输出包含一个包含斜杠符号的字符串，用于分隔目录名称，这也被称为**目录分隔符号**。最左边的斜杠有一个特殊的名称，也被称为**根目录**。当前目录的最后一个目录名称也可以在 shell 提示符中看到。在 Linux 文件系统中，每个目录都可以包含文件，并且可以包含进一步的子目录，然后称为子目录。这些子目录也可以包括文件和文件夹等。包含子目录的目录也被称为父目录，而子目录被称为**子目录**。在我们的例子中，主目录是`olip`目录的父目录，也被称为子目录。这种类型的文件和文件夹可以使用类似树状结构的方式进行可视化，也可以称为分层文件系统，因为该结构中的每个目录都有特定的位置，有些在层次结构中更高，而其他的更低。最高的目录是`/`目录，或`root`目录。我们需要记住可视化这种分层树结构。我们可以使用`tree`命令，但需要安装，因为它不在标准安装中。要安装它，使用你在安装过程中设置的`root`密码。

安装完成后，可以使用`tree`命令来首次概览系统。在顶层，我们有`/`目录，这是树中最高的目录。直接在其下有许多系统目录。当我们定制`tree`命令以显示树中两级目录时，可以看到主目录在树中的位置，以及如何从根目录到达它，根目录是所有其他目录的父目录。现在，要在主目录中创建一个新目录，可以使用`mkdir`命令。`mkdir`命令以要创建的文件夹的名称作为参数。要删除一个空目录，使用`mrdir`命令。要创建一个新的空文件，使用`touch`命令。要删除一个文件，使用`rm`命令。

现在，让我们重新创建文件夹和文件名。要切换到一个目录，可以使用`cd`命令，它代表**改变目录**。改变目录命令将当前目录更改为`cd`命令的参数所指定的新目录。使用`pwd`再次测试这一点。以下截图说明了这一点：

![](img/6a6673ed-e287-4ee1-b983-90c48f5d9f2a.png)

在 Linux 中，当我们说要进入一个目录时，我们真正的意思是通过使用`cd`命令将另一个目录设为当前目录。如前所述，每个目录都包含两个特殊的快捷链接，你无法更改也无法删除，即`.`和`..`，它是我们当前所在目录的名称。每个目录都包含名称为`..`的链接，它是我们当前所在目录的唯一父目录的名称。此外，每个子目录都只包含一个父目录，而一个父目录可以包含多个子目录。这些点对于快速浏览目录非常有用。要返回到上一个目录，也就是我们的主目录，我们可以使用`..`符号。要在子目录中创建子目录，可以使用以下方法：

![](img/488b4c86-b24f-4c5d-b8dc-7122f94ed5d0.png)

要查看我们刚刚创建的文件夹结构，我们可以再次使用`pwd`命令。要上升一个目录级别，我们可以使用`cd..`。要返回，使用`cd FolderD`。现在，要上升两个目录级别，你可以使用目录分隔符斜杠符号-`cd ../ ../`。要返回我们子目录结构的两个级别，我们也可以使用目录分隔符斜杠符号。在遍历目录时，总是有很多方法可以做到这一点。要快速返回主目录，我们可以使用几种不同的方法。首先要返回主目录，你可以使用一些快捷方式。正如我们之前提到的，波浪号符号代表主目录，所以我们可以轻松返回主目录`cd ~`。波浪号符号可以从任何地方使用，所以你可以从任何目录返回到你的主目录。另一个非常有用的快捷方式是`cd -`，它可以让你在当前目录和之前所在的目录之间切换。

甚至存在一种更短的方法，可以在任何位置只使用`cd`命令而不带任何参数就返回到你的主目录。从任何位置进入你的主目录的另一种方法是直接使用`pwd`命令输出的路径。为了删除包含子目录或文件的目录结构，你不能使用`rmdir`命令。相反，为了删除包含文件和目录的目录子树，我们需要使用`rm -rf`选项，但请谨慎使用，因为这将无需询问地删除所有内容，这是完全不可逆的。

为了重新创建相同的子目录结构，我们可以使用目录分隔符符号和`mkdir -p`选项，这样我们可以以更简单的形式展示。到目前为止，我们对文件和文件夹的所有操作和动作，比如`ls`、`mkdir`或`mrdir`，都是相对于当前目录的，这意味着如何进入所选目录或文件的描述总是相对于当前目录的。例如，我们使用命令来处理位于当前目录内的文件和目录。要引用当前目录之外的文件和文件夹，我们使用`..`和斜杠目录分隔符。

如果我们想要在同一目录中处理文件和目录，我们只需要资源的名称。如果我们想要访问当前目录之外的资源，我们可以使用目录分隔符和`..`符号来访问正确的文件或目录。现在，让我们再次执行`pwd`命令。`pwd`命令的输出被称为**绝对**或**完整路径**。绝对路径很容易从前导斜杠识别出来，这被称为根目录，正如你现在所知道的。斜杠符号意味着你从顶层目录，或根目录开始，然后继续向下。绝对路径实际上是一个沿着层次结构的路径。路径名指定并描述了如何遍历或导航文件系统中的分层目录名称，以达到从最高根目录开始的某个目标对象的目的。完整路径始终包含了如何从根目录到文件系统中的任何目的地的完整信息。换句话说，要进入当前目录，也就是`/home/olip/FolderA`，你必须从`/root`目录遍历到`home`目录，然后到`olip`目录，最后到`FolderA`目录。要以类似树状结构的方式可视化这一点，使用带有子目录**L 3**的`tree`命令：

![](img/6e2770f4-c1a2-495b-9fcc-06529fc4a948.png)

重要的是要记住，绝对路径可以从任何地方起作用。相对路径没有前导斜杠。例如，使用相对路径切换到`FolderA`，始终取决于您当前在文件系统中的位置。因此，`cd FolderA`仅在当前位置起作用。如果您在其他地方重新执行命令，它将无效。在使用任何与文件或目录相关的 Linux 命令时，您始终可以选择使用相对于当前目录的本地路径，或者使用相对于根目录的完整绝对路径。通常情况下，相对路径更快且直接切换到要直接处理的文件目录也更方便。但绝对路径对于脚本或需要从任何目录起作用的命令很重要。

# 总结

在本章中，我们从介绍命令行、文件通配符和引用命令开始。我们通过使用 shell、标准流和正则表达式来进行实际执行。我们还涵盖了`sed`、`awk`和 Linux 文件系统的功能。

在下一章中，我们将涵盖与文件相关的概念。
