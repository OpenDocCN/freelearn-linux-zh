- en: Deciphering the Process Scheduler
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解密进程调度程序
- en: 'Process scheduling is one of the most crucial executive jobs of any operating
    system, Linux being no different. The heuristics and efficiency in scheduling
    processes is what make any operating system tick and also give it an identity,
    such as a general-purpose operating system, server, or a real-time system. In
    this chapter, we will get under the skin of the Linux scheduler, deciphering concepts
    such as:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 进程调度是任何操作系统的最关键的执行工作之一，Linux也不例外。调度进程的启发式和效率是使任何操作系统运行并赋予其身份的关键因素，例如通用操作系统、服务器或实时系统。在本章中，我们将深入了解Linux调度程序，解密诸如：
- en: Linux scheduler design
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux调度程序设计
- en: Scheduling classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度类
- en: Scheduling policies and priorities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度策略和优先级
- en: Completely Fair Scheduler
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全公平调度器
- en: Real-Time Scheduler
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时调度程序
- en: Deadline Scheduler
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 截止时间调度器
- en: Group scheduling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组调度
- en: Preemption
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抢占
- en: Process schedulers
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程调度程序
- en: The effectiveness of any operating system is proportional to its ability to
    fairly schedule all contending processes. The process scheduler is the core component
    of the kernel, which computes and decides when and for how long a process gets
    CPU time. Ideally, processes require a *timeslice* of the CPU to run, so schedulers
    essentially need to allocate slices of processor time fairly among processes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 任何操作系统的有效性与其公平调度所有竞争进程的能力成正比。进程调度程序是内核的核心组件，它计算并决定进程何时以及多长时间获得CPU时间。理想情况下，进程需要CPU的*时间片*来运行，因此调度程序基本上需要公平地分配处理器时间片给进程。
- en: 'A scheduler typically has to:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 调度程序通常需要：
- en: Avoid process starvation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免进程饥饿
- en: Manage priority scheduling
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理优先级调度
- en: Maximize throughput of all processes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大化所有进程的吞吐量
- en: Ensure low turnaround time
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保低周转时间
- en: Ensure even resource usage
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保资源使用均匀
- en: Avoid CPU hogging
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免CPU占用
- en: Consider process' behavioral patterns for prioritization
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑进程的行为模式进行优先级排序
- en: Elegantly subsidize under heavy load
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重负载下优雅地补贴
- en: Handle scheduling on multiple cores efficiently
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效地处理多核上的调度
- en: Linux process scheduler design
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux进程调度程序设计
- en: Linux, which was primarily developed for desktop systems, has unassumingly evolved
    into a multi-dimensional operating system with its usage spread across embedded
    devices, mainframes, and supercomputers to room-sized servers. It has also seamlessly
    accommodated the ever-evolving diverse computing platforms such as SMP, virtualization,
    and real-time systems. The diversity of these platforms is brought forth by the
    kind of processes that run on these systems. For instance, a highly interactive
    desktop system may run processes that are I/O bound, and a real-time system thrives
    on deterministic processes. Every kind of process thus calls for a different kind
    of heuristic when it needs to be fairly scheduled, as a CPU-intensive process
    may require more CPU time than a normal process, and a real-time process would
    require deterministic execution. Linux, which caters to a wide spectrum of systems,
    is thus confronted with addressing the varying scheduling challenges that come
    along when managing these diverse processes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Linux最初是为桌面系统开发的，但不知不觉地演变成了一个多维操作系统，其使用范围涵盖嵌入式设备、大型机和超级计算机，以及房间大小的服务器。它还无缝地适应了不断发展的多样化计算平台，如SMP、虚拟化和实时系统。这些平台的多样性是由在这些系统上运行的进程类型带来的。例如，一个高度交互式的桌面系统可能运行I/O绑定的进程，而实时系统则依赖确定性进程。因此，每种类型的进程在需要公平调度时都需要不同类型的启发式方法，因为CPU密集型进程可能需要比普通进程更多的CPU时间，而实时进程则需要确定性执行。因此，Linux面临着处理这些多样化进程管理时带来的不同调度挑战。
- en: '![](img/00013.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00013.jpeg)'
- en: The intrinsic design of Linux's process scheduler elegantly and deftly handles
    this challenge by adopting a simple two-layered model, with its first layer, the
    **Generic Scheduler**, defining abstract operations that serve as entry functions
    for the scheduler, and the second layer, the scheduling class, implementing the
    actual scheduling operations, where each class is dedicated to handling the scheduling
    heuristics of a particular kind of process. This model enables the generic scheduler
    to remain abstracted from the implementation details of every scheduler class.
    For instance, normal processes (I/O bound) can be handled by one class, and processes
    that require deterministic execution, such as real-time processes, can be handled
    by another class. This architecture also enables adding a new scheduling class
    seamlessly. The previous figure depicts the layered design of the process scheduler.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Linux进程调度程序的内在设计通过采用简单的两层模型，优雅而巧妙地处理了这一挑战。其第一层，**通用调度程序**，定义了作为调度程序入口函数的抽象操作，而第二层，调度类，实现了实际的调度操作，其中每个类专门处理特定类型进程的调度启发式。这种模型使得通用调度程序能够从每个调度类的实现细节中抽象出来。例如，普通进程（I/O绑定）可以由一个类处理，而需要确定性执行的进程，如实时进程，可以由另一个类处理。这种架构还能够无缝地添加新的调度类。前面的图示了进程调度程序的分层设计。
- en: 'The generic scheduler defines abstract interfaces through a structure called
    `sched_class`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通用调度程序通过一个称为`sched_class`的结构定义了抽象接口：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Every scheduler class implements operations as defined in the `sched_class`
    structure. As of the 4.12.x kernel, there are three scheduling classes: the **Completely
    Fair Scheduling** (**CFS**) class , Real-Time Scheduling class, and Deadline Scheduling
    class, with each class handling processes with specific scheduling requirements.
    The following code snippets show how each class populates its operations as per
    the `sched_class` structure.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个调度类都实现了`sched_class`结构中定义的操作。截至4.12.x内核，有三个调度类：**完全公平调度**（**CFS**）类，实时调度类和截止时间调度类，每个类处理具有特定调度要求的进程。以下代码片段显示了每个类如何根据`sched_class`结构填充其操作。
- en: '**CFS class****:**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**CFS类**：'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Real-Time Scheduling class****:**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**实时调度类**：'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Deadline Scheduling class****:**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**截止时间调度类**：'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Runqueue
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行队列
- en: Conventionally, the runqueue contains all the processes that are contending
    for CPU time on a given CPU core (a runqueue is per-CPU). The generic scheduler
    is designed to look into the runqueue whenever it is invoked to schedule the next
    best runnable task. Maintaining a common runqueue for all the runnable processes
    would not be a possible since each scheduling class deals with specific scheduling
    policies and priorities.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，运行队列包含了在给定 CPU 核心上争夺 CPU 时间的所有进程（每个 CPU 都有一个运行队列）。通用调度程序被设计为在调度下一个最佳的可运行任务时查看运行队列。由于每个调度类处理特定的调度策略和优先级，维护所有可运行进程的公共运行队列是不可能的。
- en: The kernel addresses this by bringing its design principles to the fore. Each
    scheduling class defined the layout of its runqueue data structure as best suitable
    for its policies. The generic scheduler layer implements an abstract runqueue
    structure with common elements that serves as the runqueue interface. This structure
    is extended with pointers that refer to class-specific runqueues. In other words,
    all scheduling classes embed their runqueues into the main runqueue structure.
    This is a classic design hack, which lets every scheduler class choose an appropriate
    layout for its runqueue data structure.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 内核通过将其设计原则引入前台来解决这个问题。每个调度类都定义了其运行队列数据结构的布局，以最适合其策略。通用调度程序层实现了一个抽象的运行队列结构，其中包含作为运行队列接口的公共元素。该结构通过指针扩展，这些指针指向特定类的运行队列。换句话说，所有调度类都将其运行队列嵌入到主运行队列结构中。这是一个经典的设计技巧，它让每个调度程序类选择适合其运行队列数据结构的适当布局。
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can see how the scheduling classes (`cfs`, `rt`, and `dl`) embed themselves
    into the runqueue. Other elements of interest in the runqueue are:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到调度类（`cfs`、`rt` 和 `dl`）是如何嵌入到运行队列中的。运行队列中其他感兴趣的元素包括：
- en: '`nr_running`: This denotes the number of processes in the runqueue'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nr_running`: 这表示运行队列中的进程数量'
- en: '`load`: This denotes the current load on the queue (all runnable processes)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load`: 这表示队列上的当前负载（所有可运行进程）'
- en: '`curr` and `idle`: These point to the *task_struct* of the current running
    task and the idle task, respectively. The idle task is scheduled when there are
    no other tasks to run.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`curr` 和 `idle`: 这些分别指向当前运行任务的 *task_struct* 和空闲任务。当没有其他任务要运行时，空闲任务会被调度。'
- en: The scheduler's entry point
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度程序的入口
- en: The process of scheduling starts with a call to the generic scheduler, that
    is, the `schedule()` function, defined in `<kernel/sched/core.c>`. This is perhaps
    one of the most invoked routines in the kernel. The functionality of `schedule()`
    is to pick the next best runnable task. The `pick_next_task()` of the `schedule()`
    function iterates through all the corresponding functions contained in the scheduler
    classes and ends up picking the next best task to run. Each scheduler class is
    linked using a single linked list, which enables the `pick_next_task()` to iterate
    through these classes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 调度过程始于对通用调度程序的调用，即 `<kernel/sched/core.c>` 中定义的 `schedule()` 函数。这可能是内核中最常调用的例程之一。`schedule()`
    的功能是选择下一个最佳的可运行任务。`schedule()` 函数的 `pick_next_task()` 遍历调度类中包含的所有相应函数，并最终选择下一个最佳的任务来运行。每个调度类都使用单链表连接，这使得
    `pick_next_task()` 能够遍历这些类。
- en: Considering that Linux was primarily designed to cater to highly interactive
    systems, the function first looks for the next best runnable task in the CFS class
    if there are no higher-priority runnable tasks in any of the other classes (this
    is done by checking whether the total number of runnable tasks (`nr_running`)
    in the runqueue is equal to the total number of runnable tasks in the CFS class's
    sub-runqueue); else, it iterates through all the other classes and picks the next
    best runnable task. Finally, if no tasks are found, it invokes the idle, background
    tasks (which always returns a non-null value).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 Linux 主要设计用于高度交互式系统，该函数首先在 CFS 类中查找下一个最佳的可运行任务，如果在其他类中没有更高优先级的可运行任务（通过检查运行队列中可运行任务的总数（`nr_running`）是否等于
    CFS 类子运行队列中可运行任务的总数来实现）；否则，它会遍历所有其他类，并选择下一个最佳的可运行任务。最后，如果找不到任务，则调用空闲后台任务（始终返回非空值）。
- en: 'The following code block shows the implementation of `pick_next_task()`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块显示了 `pick_next_task()` 的实现：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Process priorities
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程优先级
- en: The decision of which process to run depends on the priority of the process.
    Every process is labelled with a priority value, giving it an immediate position
    in terms of when it will be given CPU time. Priorities are fundamentally classified
    into *dynamic* and *static* priorities on *nix systems. **Dynamic priorities**
    are basically applied to normal processes dynamically by the kernel, considering
    various factors such as the nice value of the process, its historic behavior (I/O
    bound or processor bound), lapsed execution, and waiting time. **Static priorities**
    are applied to real-time processes by the user and the kernel does not change
    their priorities dynamically. Processes with static priorities are thus given
    higher priority when scheduling.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 决定运行哪个进程取决于进程的优先级。每个进程都标有一个优先级值，这使得它在获得 CPU 时间方面有一个即时的位置。在 *nix 系统上，优先级基本上分为
    *动态* 和 *静态* 优先级。**动态优先级** 基本上是内核动态地应用于正常进程，考虑到诸如进程的良好值、其历史行为（I/O 绑定或处理器绑定）、已过去的执行和等待时间等各种因素。**静态优先级**
    是由用户应用于实时进程的，内核不会动态地改变它们的优先级。因此，具有静态优先级的进程在调度时会被赋予更高的优先级。
- en: '**I/O bound process:** When the execution of a process is heavily punctuated
    with I/O operations (waiting for a resource or an event), for instance a text
    editor, which almost alternates between running and waiting for a key press, such
    processes are called I/O bound. Due to this nature, the scheduler normally allocates
    short processor time slices to I/O-bound processes and multiplexes them with other
    processes, adding the overhead of context switching and the subsequent heuristics
    of computing the next best process to run.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**I/O绑定进程：**当进程的执行严重受到I/O操作的影响（等待资源或事件），例如文本编辑器几乎在运行和等待按键之间交替时，这样的进程被称为I/O绑定。由于这种特性，调度器通常会为I/O绑定的进程分配较短的处理器时间片，并将它们与其他进程复用，增加了上下文切换的开销以及计算下一个最佳进程的后续启发式。'
- en: '**Processor bound process:** These are processes that love to stick on to CPU
    time slices, as they require maximum utilization of the processor''s computing
    capacity. Processes requiring heavy computations such as complex scientific calculations,
    and video rendering codecs are processor bound. Though the need for a longer CPU
    slice looks desirable, the expectation to run them under fixed time periods is
    not often a requirement. Schedulers on interactive operating systems tend to favor
    more I/O-bound processes than processor-bound ones. Linux, which aims for good
    interactive performance, is more optimized for faster response time, inclining
    towards I/O bound processes, even though processor-bound processes are run less
    frequently they are ideally given longer timeslices to run.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理器绑定进程：**这些进程喜欢占用CPU时间片，因为它们需要最大限度地利用处理器的计算能力。需要进行复杂科学计算和视频渲染编解码的进程是处理器绑定的。虽然需要更长的CPU时间片看起来很理想，但通常不需要在固定时间段内运行它们。交互式操作系统上的调度器倾向于更喜欢I/O绑定的进程而不是处理器绑定的进程。Linux旨在提供良好的交互性能，更倾向于I/O绑定的进程，即使处理器绑定的进程运行频率较低，它们通常会被分配更长的时间片来运行。'
- en: Processes can also be **multi-faceted**, with an I/O-bound process needing to
    perform serious scientific computations, burning the CPU.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 进程也可以是**多面手**，I/O绑定进程需要执行严肃的科学计算，占用CPU。
- en: The *nice* value of any normal process ranges between 19 (lowest priority) and
    -20 (highest priority), with 0 being the default value. A higher nice value indicates
    a lower priority (the process is being nicer to other processes). Real-time processes
    are prioritized between 0 and 99 (static priority). All these priority ranges
    are from the perspective of the user.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 任何正常进程的*nice*值范围在19（最低优先级）和-20（最高优先级）之间，0是默认值。较高的nice值表示较低的优先级（进程对其他进程更友好）。实时进程的优先级在0到99之间（静态优先级）。所有这些优先级范围都是从用户的角度来看的。
- en: '**Kernel''s perspective of priorities**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**内核对优先级的看法**'
- en: Linux however looks at process priorities from its own perspective. It adds
    a lot more computation for arriving at the priority of a process. Basically, it
    scales all priorities between 0 to 139, where 0 to 99 is assigned for real-time
    processes and 100 to 139 represents the nice value range (-20 to 19).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Linux从自己的角度看待进程优先级。它为计算进程的优先级增加了更多的计算。基本上，它将所有优先级在0到139之间进行缩放，其中0到99分配给实时进程，100到139代表了nice值范围（-20到19）。
- en: Scheduler classes
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度器类
- en: 'Let''s now go deeper into each scheduling class and understand the operations,
    policies, and heuristics it engages in managing scheduling operations adeptly
    and elegantly for its processes. As mentioned earlier, an instance of `struct
    sched_class` must be provided by each scheduling class; let''s look at some of
    the key elements from that structure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入了解每个调度类，并了解它在管理调度操作时所涉及的操作、政策和启发式。如前所述，每个调度类必须提供`struct sched_class`的一个实例；让我们看一下该结构中的一些关键元素：
- en: '`enqueue_task`: Basically adds a new process to the run queue'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enqueue_task`：基本上是将新进程添加到运行队列'
- en: '`dequeue_task`: When the process is taken off the runqueue'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dequeue_task`：当进程从运行队列中移除时'
- en: '`yield_task`: When the process wants to relinquish CPU voluntarily'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yield_task`：当进程希望自愿放弃CPU时'
- en: '`pick_next_task`: The corresponding function of the *pick_next_task* called
    by s*chedule()*. It picks up the next best runnable task from its class.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pick_next_task`：由*s*chedule()调用的*pick_next_task*的相应函数。它从其类中挑选出下一个最佳的可运行任务。'
- en: Completely Fair Scheduling class (CFS)
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完全公平调度类（CFS）
- en: All processes with dynamic priorities are handled by the CFS class, and as most
    processes in general-purpose *nix systems are normal (non-realtime), CFS remains
    the busiest scheduler class in the kernel.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所有具有动态优先级的进程都由CFS类处理，而大多数通用*nix系统中的进程都是正常的（非实时），因此CFS仍然是内核中最繁忙的调度器类。
- en: CFS relies on maintaining *balance* in allocating processor time to tasks, based
    on policies and dynamic priorities assigned per task. Process scheduling under
    CFS is implemented under the premise that it has an "ideal, precise multi-tasking
    CPU," that equally powers all processes at its peak capacity. For instance, if
    there are two processes, the perfectly multi-tasking CPU ensures that both processes
    run simultaneously, each utilizing 50% of its power. As this is practically impossible
    (achieving parallelism), CFS allocates processor time to a process by maintaining
    proper balance across all contending processes. If a process fails to receive
    a fair amount of time, it is considered out of balance, and thus goes in next
    as the best runnable process.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: CFS依赖于根据任务分配处理器时间的政策和动态分配的优先级来保持*平衡*。CFS下的进程调度是在假设下实现的，即它具有"理想的、精确的多任务CPU"，在其峰值容量下平等地为所有进程提供动力。例如，如果有两个进程，完美的多任务CPU确保两个进程同时运行，每个进程利用其50%的能力。由于这在实际上是不可能的（实现并行性），CFS通过在所有竞争进程之间保持适当的平衡来为进程分配处理器时间。如果一个进程未能获得公平的时间，它被认为是不平衡的，因此作为最佳可运行进程进入下一个进程。
- en: 'CFS does not rely on the traditional time slices for allocating processor time,
    but rather uses a concept of virtual runtime (*vruntime*): it denotes the amount
    of time a process got CPU time, which means a low `vruntime` value indicates that
    the process is processor deprived and a high `vruntime` value denotes that the
    process acquired considerable processor time. Processes with low `vruntime` values
    get maximum priority when scheduling. CFS also engages *sleeper fairness* for
    processes that are ideally waiting for an I/O request. Sleeper fairness demands
    that waiting processes be given considerable CPU time when they eventually wake
    up, post event. Based on the `vruntime` value, CFS decides what amount of time
    the process is to run. It also uses the nice value to weigh a process in relation
    to all contending processes: a higher-value, low-priority process gets less weight,
    and a lower-value, high-priority task gets more weight. Even handling processes
    with varying priorities is elegant in Linux, as a lower-priority task gets considerable
    factors of delay compared to a higher-priority task; this makes the time allocated
    to a low-priority task dissipate quickly.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: CFS不依赖于传统的时间片来分配处理器时间，而是使用虚拟运行时间（*vruntime*）的概念：它表示进程获得CPU时间的数量，这意味着低`vruntime`值表示进程处理器匮乏，而高`vruntime`值表示进程获得了相当多的处理器时间。具有低`vruntime`值的进程在调度时获得最高优先级。CFS还为理想情况下等待I/O请求的进程使用*睡眠公平性*。睡眠公平性要求等待的进程在最终唤醒后获得相当多的CPU时间。根据`vruntime`值，CFS决定进程运行的时间。它还使用nice值来衡量进程与所有竞争进程的关系：较高值的低优先级进程获得较少的权重，而较低值的高优先级任务获得更多的权重。即使在Linux中处理具有不同优先级的进程也是优雅的，因为与较高优先级任务相比，较低优先级任务会有相当大的延迟因素；这使得分配给低优先级任务的时间迅速消失。
- en: Computing priorities and time slices under CFS
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CFS下计算优先级和时间片
- en: Priorities are assigned based on how long the process is waiting, how long the
    process ran, the process's historical behavior, and its nice value. Normally,
    schedulers engage complex algorithms to end up with the next best process to run.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级是基于进程等待时间、进程运行时间、进程的历史行为和其nice值来分配的。通常，调度程序使用复杂的算法来找到下一个最佳的要运行的进程。
- en: 'In computing the timeslice every process gets, CFS not just relies on the nice
    value of the process but also looks at the load weight of the process. For every
    jump in the nice value of a process by 1, there will be a 10% reduction in the
    CPU timeslice, and for every decrease in the nice value by 1, there will be a
    10% addition in the CPU timeslice, indicating that nice values are multiplicative
    by a 10% change for every jump. To compute the load weight for corresponding nice
    values, the kernel maintains an array called `prio_to_weight`*,* where each nice
    value corresponds to a weight:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算每个进程获得的时间片时，CFS不仅依赖于进程的nice值，还考虑进程的负载权重。对于进程nice值的每次增加1，CPU时间片将减少10%，对于nice值的每次减少1，CPU时间片将增加10%，这表明nice值对于每次变化都是以10%的乘法变化。为了计算相应nice值的负载权重，内核维护了一个名为`prio_to_weight`的数组，其中每个nice值对应一个权重：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The load value of a process is stored in the `weight` field of `struct load_weight`*.*
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的负载值存储在`struct load_weight`的`weight`字段中。
- en: Like a process's weight, the runqueue of CFS is also assigned a weight, which
    is the gross weight of all the tasks in the runqueue. Now the timeslice is computed
    by factoring the entity's load weight, the runqueue's load weight, and the `sched_period`
    (scheduling period).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 像进程的权重一样，CFS的运行队列也被分配了一个权重，这是运行队列中所有任务的总权重。现在，时间片是通过考虑实体的负载权重、运行队列的负载权重和`sched_period`（调度周期）来计算的。
- en: CFS's runqueue
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CFS的运行队列
- en: CFS sheds the need for a normal runqueue and uses a self-balancing, red-black
    tree instead to get to the next best process to run in the shortest possible time.
    The *RB tree* holds all the contending processes and facilitates easy and quick
    insertion, deletion, and searching of processes. The highest-priority process
    is placed to its leftmost node. The `pick_next_task()` function now just picks
    the leftmost node from the `rb tree` to schedule.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: CFS摆脱了普通运行队列的需要，而是使用自平衡的红黑树，以便在最短时间内找到下一个最佳的要运行的进程。*RB树*保存了所有竞争进程，并便于对进程进行快速插入、删除和搜索。最高优先级的进程被放置在最左边的节点上。`pick_next_task()`函数现在只是从`rb
    tree`中选择最左边的节点进行调度。
- en: Group scheduling
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组调度
- en: 'To ensure fairness when scheduling, CFS is designed to guarantee that every
    runnable process gets at least one run on the processor under a defined time duration,
    called the **scheduling period**. Within a scheduling period, CFS rudimentarily
    ensures fairness or, in other words, ensures that unfairness is kept at a minimum,
    as each process at least runs once. CFS divides the scheduling period into timeslices
    among all threads of execution to avoid process starvation; however, imagine a
    scenario where process A spawns 10 threads of execution and process B spawns 5
    threads of execution: here CFS divides timeslices to all the threads equally,
    leading to process A and its spawned threads getting the maximum time and process
    B to be dealt with unfairly. If process A keeps on spawning more threads, the
    situation may become grave for process B and its spawned threads, as process B
    will have to contend with the minimum scheduling granularity or timeslice (which
    is 1 millisecond). Fairness in this scenario demands process A and B getting equal
    timeslices with spawned threads to share these timeslices internally. For instance,
    if process A and B get 50% of the time each, then process A shall divide its 50%
    time among its spawned 10 threads, with each thread getting 5% time internally.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保调度时的公平性，CFS被设计为保证每个可运行的进程在一个定义的时间段内至少运行一次，称为**调度周期**。在调度周期内，CFS基本上确保公平性，或者换句话说，确保不公平性被最小化，因为每个进程至少运行一次。CFS将调度周期分成时间片，以避免进程饥饿；然而，想象一下这样的情况，进程A生成了10个执行线程，进程B生成了5个执行线程：在这里，CFS将时间片均匀分配给所有线程，导致进程A及其生成的线程获得最大的时间，而进程B则受到不公平对待。如果进程A继续生成更多的线程，情况可能对进程B及其生成的线程变得严重，因为进程B将不得不应对最小的调度粒度或时间片（即1毫秒）。在这种情况下，公平性要求进程A和B获得相等的时间片，并且生成的线程在内部共享这些时间片。例如，如果进程A和B各获得50%的时间，那么进程A将把其50%的时间分配给其生成的10个线程，每个线程在内部获得5%的时间。
- en: 'To address this issue and to keep up the fairness, CFS introduced **group scheduling**,
    where timeslices are allotted to groups of threads instead of individual threads.
    Continuing the same example, under group scheduling, process A and its spawned
    threads belong to one group and process B and its spawned threads belong to another.
    As scheduling granularity is imposed at a group level and not at a thread level,
    it gives process A and B equal share of processor time, with process A and B dividing
    the timeslice among its group members internally. Here, a thread spawned under
    process A suffers as it is penalized for spawning more threads of execution. To
    ensure group scheduling, `CONFIG_FAIR_GROUP_SCHED` is to be set when configuring
    the kernel. CFS task groups are represented by the structure `sched_entity`*,*
    and every group is referred as a **scheduling entity**. The following code snippet
    shows key elements of the scheduling entity structure:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题并保持公平性，CFS引入了**组调度**，其中时间片分配给线程组而不是单个线程。继续上面的例子，在组调度下，进程A及其生成的线程属于一组，进程B及其生成的线程属于另一组。由于调度粒度是在组级别而不是线程级别上强加的，它给予进程A和B相等的处理器时间份额，进程A和B在其组成员内部分配时间片。在这里，生成在进程A下的线程会受到影响，因为它因生成更多的执行线程而受到惩罚。为了确保组调度，在配置内核时需要设置`CONFIG_FAIR_GROUP_SCHED`。CFS任务组由结构`sched_entity`*表示，每个组被称为**调度实体**。以下代码片段显示了调度实体结构的关键元素：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`load`: Denotes the amount of load each entity bears on the total load of the
    queue'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load`：表示每个实体对队列总负载的负载量'
- en: '`vruntime`: Denotes the amount of time the process ran'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vruntime`：表示进程运行的时间'
- en: Scheduling entities under many-core systems
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 许多核心系统下的调度实体
- en: 'Task groups can in a many-core system run on any CPU core, but to facilitate
    this, creating only one scheduling entity will not suffice. Groups thus must create
    a scheduling entity for every CPU core on the system. Scheduling entities across
    CPUs are represented by `struct task_group`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 任务组可以在许多核心系统上的任何CPU核心上运行，但为了实现这一点，创建一个调度实体是不够的。因此，组必须为系统上的每个CPU核心创建一个调度实体。跨CPU的调度实体由`struct
    task_group`表示：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now every task group has a scheduling entity for every CPU core along with a
    CFS runqueue associated with it. When a task from one task group migrates from
    one CPU core (x) to another CPU core (y), the task is dequeued from the CFS runqueue
    of CPU x and enqueued to the CFS runqueue of CPU y.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个任务组都有一个调度实体，每个CPU核心都有一个与之关联的CFS运行队列。当一个任务从一个任务组迁移到另一个CPU核心时，该任务将从CPU x的CFS运行队列中出列，并入列到CPU
    y的CFS运行队列中。
- en: Scheduling policies
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调度策略
- en: 'Scheduling policies are applied to processes, and help in determining scheduling
    decisions. If you recall, in [Chapter 1](part0020.html#J2B80-7300e3ede2f245b0b80e1b18d02a323f),
    *Comprehending Processes, Address Space, and Threads*, we described the `int policy`
    field under the scheduling attributes of struct `task_struct`*.* The `policy field`
    contains the value indicating which policy is to be applied to the process when
    scheduling. The CFS class handles all normal processes using the following two
    policies:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 调度策略适用于进程，并有助于确定调度决策。如果您回忆一下，在[第1章](part0020.html#J2B80-7300e3ede2f245b0b80e1b18d02a323f)中，*理解进程、地址空间和线程*，我们描述了`task_struct`结构的调度属性下的`int
    policy`字段。`policy`字段包含一个值，指示调度时要应用哪种策略。CFS类使用以下两种策略处理所有普通进程：
- en: '`SCHED_NORMAL (0)`: This is used for all normal processes. All non-realtime
    processes can be summarized as normal processes. As Linux aims to be a highly
    responsive and interactive system, most of the scheduling activity and heuristics
    are centered to fairly schedule normal processes. Normal processes are referred
    to as `SCHED_OTHER` as per POSIX.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCHED_NORMAL (0)`：用于所有普通进程。所有非实时进程都可以总结为普通进程。由于Linux旨在成为一个高度响应和交互式的系统，大部分调度活动和启发式方法都集中在公平调度普通进程上。普通进程根据POSIX标准被称为`SCHED_OTHER`。'
- en: '`SCHED_BATCH (3)`: Normally in servers, where processes are non-interactive,
    CPU-bound batch processing is employed. These processes that are CPU intensive
    are given less priority than a `SCHED_NORMAL` process, and they do not preempt
    normal processes, which are scheduled.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCHED_BATCH (3)`: 通常在服务器上，非交互式的CPU密集型批处理被使用。这些CPU密集型的进程比`SCHED_NORMAL`进程被赋予更低的优先级，并且它们不会抢占正常进程的调度。'
- en: 'The CFS class also handles scheduling the idle process, which is specified
    by the following policy:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CFS类还处理空闲进程的调度，其指定如下策略：
- en: '`SCHED_IDLE (5)`: When there are no processes to run, the *idle* process (low-priority
    background processes) is scheduled. The *idle* process is assigned the least priority
    among all processes.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCHED_IDLE (5)`: 当没有进程需要运行时，*空闲*进程（低优先级后台进程）被调度。*空闲*进程被分配了所有进程中最低的优先级。'
- en: Real-time scheduling class
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时调度类
- en: Linux supports soft real-time tasks and they are scheduled by the real-time
    scheduling class. `rt` processes are assigned static priorities and are unchanged
    dynamically by the kernel. As real-time tasks aim at deterministic runs and desire
    control over when and how long they are to be scheduled, they are always given
    preference over normal tasks (`SCHED_NORMAL`). Unlike CFS, which uses `rb tree`
    as its sub-runqueue, the `rt` scheduler, which is less complicated, uses a simple
    `linked list` per priority value (1 to 99). Linux applies two real-time policies,
    `rr` and `fifo`*,* when scheduling static priority processes; these are indicated
    by the `policy` element of `struct task_struct`*.*
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Linux支持软实时任务，并由实时调度类进行调度。`rt`进程被分配静态优先级，并且不会被内核动态改变。由于实时任务旨在确定性运行并希望控制何时以及多长时间被调度，它们总是优先于正常任务（`SCHED_NORMAL`）。与CFS使用`rb树`作为其子运行队列不同，较不复杂的`rt`调度器使用每个优先级值（1到99）的简单`链表`。Linux应用了两种实时策略，`rr`和`fifo`*,*在调度静态优先级进程时；这些由`struct
    task_struct`*:*的`policy`元素指示。
- en: '`SCHED_FIFO` (1): This uses the first in, first out method to schedule soft
    real-time processes'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCHED_FIFO` (1): 这使用先进先出的方法来调度软实时进程'
- en: '`SCHED_RR` (2): This is the round-robin policy used to schedule soft real-time
    processes'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCHED_RR` (2): 这是用于调度软实时进程的轮转策略'
- en: FIFO
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FIFO
- en: '**FIFO** is a scheduling mechanism applied to processes with priorities higher
    than 0 (0 is assigned to normal processes). FIFO processes run sans any timeslice
    allocation; in other words, they invariably run until they block for some event
    or explicitly yield to another process. A FIFO process also gets preempted when
    the scheduler encounters a higher-priority runnable FIFO, RR, or deadline task.
    When scheduler encounters more than one fifo task with the same priority, it runs
    the processes in round robin, starting with the first process at the head of the
    list. On preemption, the process is added back to the tail of the list. If a higher-priority
    process preempts the FIFO process, it waits at the head of the list, and when
    all other high-priority tasks are preempted, it is again picked up to run. When
    a new fifo process becomes runnable, it is added to the tail of the list.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**FIFO**是应用于优先级高于0的进程的调度机制（0分配给正常进程）。FIFO进程在没有任何时间片分配的情况下运行；换句话说，它们一直运行直到阻塞某个事件或明确让出给另一个进程。当调度器遇到更高优先级的可运行FIFO、RR或截止任务时，FIFO进程也会被抢占。当调度器遇到多个具有相同优先级的fifo任务时，它会以轮转的方式运行这些进程，从列表头部的第一个进程开始。在抢占时，进程被添加回列表的尾部。如果更高优先级的进程抢占了FIFO进程，它会等待在列表的头部，当所有其他高优先级任务被抢占时，它再次被选中运行。当新的fifo进程变为可运行时，它被添加到列表的尾部。'
- en: RR
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RR
- en: The round-robin policy is similar to FIFO, with the only exception being that
    it is allocated a timeslice to run. This is kind of an enhancement to FIFO (as
    a FIFO process may run until it yields or waits). Similar to FIFO, the RR process
    at the head of the list is picked for execution (if no other higher-priority task
    is available) and on completion of the timeslice gets preempted and is added back
    to the tail end of the list. RR processes with the same priority run round robin
    until preempted by a high-priority task. When a high-priority task preempts an
    RR task, it waits at the head of the list, and on resumption runs for the remainder
    of its timeslice only.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 轮转策略类似于FIFO，唯一的区别是它被分配了一个时间片来运行。这是对FIFO的一种增强（因为FIFO进程可能一直运行直到让出或等待）。与FIFO类似，列表头部的RR进程被选中执行（如果没有其他更高优先级的任务可用），并在时间片完成时被抢占，并被添加回列表的尾部。具有相同优先级的RR进程会轮流运行，直到被高优先级任务抢占。当高优先级任务抢占RR任务时，它会等待在列表的头部，并在恢复时只运行其剩余的时间片。
- en: Real-time group scheduling
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时组调度
- en: Similar to group scheduling under CFS, real-time processes can also be grouped
    for scheduling with `CONFIG_RT_GROUP_SCHED` set. For group scheduling to succeed,
    each group must be assigned a portion of CPU time, with a guarantee that the timeslice
    is enough to run the tasks under each entity, or it fails. So "run time" (a portion
    of how much time a CPU can spend running in a period) is allocated per group.
    The run time allocated to one group will not be used by another group. CPU time
    that is not allocated for real-time groups will be used by normal-priority tasks
    and any time unused by the real-time entities will also be picked by the normal
    tasks. FIFO and RR groups are represented by `struct sched_rt_entity`*:*
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与CFS下的组调度类似，实时进程也可以通过设置`CONFIG_RT_GROUP_SCHED`来进行分组调度。为了使组调度成功，每个组必须被分配一部分CPU时间，并保证时间片足够运行每个实体下的任务，否则会失败。因此，每个组都被分配了一部分“运行时间”（CPU在一段时间内可以运行的时间）。分配给一个组的运行时间不会被另一个组使用。未分配给实时组的CPU时间将被正常优先级任务使用，实时实体未使用的时间也将被正常任务使用。FIFO和RR组由`struct
    sched_rt_entity`*:*表示
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Deadline scheduling class (sporadic task model deadline scheduling)
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 截止调度类（间歇任务模型截止调度）
- en: '**Deadline** represents the new breed of RT processes on Linux (added since
    the 3.14 kernel). Unlike FIFO and RR, where processes may hog CPU or be bound
    by timeslices, a deadline process, which is based on GEDF (Global Earliest Deadline
    First) and CBS (Constant Bandwidth Server) algorithms, predetermines its runtime
    requirements. A sporadic process internally runs multiple tasks, with each task
    having a relative deadline within which it must complete executing and a computation
    time, defining the time that the CPU needs to complete process execution. To ensure
    that the kernel succeeds in executing deadline processes, the kernel runs an admittance
    test based on the deadline parameters, and on failure returns an error, `EBUSY`.
    Processes with the deadline policy gets precedence over all other processes. Deadline
    processes use `SCHED_DEADLINE` (6) as their policy element.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**Deadline**代表Linux上新一代的RT进程（自3.14内核以来添加）。与FIFO和RR不同，这些进程可能占用CPU或受到时间片的限制，截止进程基于GEDF（全局最早截止时间优先）和CBS（恒定带宽服务器）算法，预先确定其运行时需求。间歇性进程内部运行多个任务，每个任务都有一个相对截止时间，必须在其中完成执行，并且有一个计算时间，定义CPU需要完成进程执行的时间。为了确保内核成功执行截止进程，内核基于截止时间参数运行准入测试，如果失败则返回错误`EBUSY`。截止策略的进程优先于所有其他进程。截止进程使用`SCHED_DEADLINE`（6）作为其策略元素。'
- en: Scheduler related system calls
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与调度程序相关的系统调用
- en: 'Linux provides an entire family of system calls that manage various scheduler
    parameters, policies, and priorities and retrieve a multitude of scheduling-related
    information for the calling threads. It also enables threads to yield CPU explicitly:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Linux提供了一整套系统调用，用于管理各种调度程序参数、策略和优先级，并为调用线程检索大量与调度相关的信息。它还允许线程显式地放弃CPU：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`nice()` takes an *int* parameter and adds it to the `nice` value of the calling
    thread. On success, it returns the new nice value of the thread. Nice values are
    within the range 19 (lowest priority) to -20 (highest priority). *Nice* values
    can be incremented only within this range:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`nice()`接受一个*int*参数，并将其添加到调用线程的`nice`值中。成功时返回线程的新`nice`值。`Nice`值在范围19（最低优先级）到-20（最高优先级）内。*Nice*值只能在此范围内递增：'
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This returns the `nice` value of the thread, group, user, or set of threads
    of a specified user as indicated by its parameters. It returns the highest priority
    held by any of the processes:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回线程、组、用户或一组由其参数指示的特定用户的`nice`值。它返回任何进程持有的最高优先级：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The scheduling priority of the thread, group, user, or set of threads of a
    specified user as indicated by its parameters is set by `setpriority`*.* It returns
    zero on success:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`setpriority`*.*设置由其参数指示的特定用户的线程、组、用户或一组线程的调度优先级。成功时返回零：'
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This sets both the scheduling policy and parameters of a specified thread,
    indicated by its `pid`. If the `pid` is zero, the policy of the calling thread
    will be set. The `param` argument, which specifies the scheduling parameters,
    points to a structure `sched_param`, which holds `int sched_priority`. `sched_priority`
    must be zero for normal processes and a priority value in the range 1 to 99 for
    FIFO and RR policies (mentioned in policy argument). It returns zero on success:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这设置了指定线程的调度策略和参数，由其`pid`指示。如果`pid`为零，则设置调用线程的策略。指定调度参数的`param`参数指向一个`sched_param`结构，其中包含`int
    sched_priority`。对于正常进程，`sched_priority`必须为零，对于FIFO和RR策略（在策略参数中提到）的优先级值必须在1到99的范围内。成功时返回零：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It returns the scheduling policy of a thread (`pid`). If the `pid` is zero,
    the policy of the calling thread will be retrieved:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回线程（`pid`）的调度策略。如果`pid`为零，则将检索调用线程的策略：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It sets the scheduling parameters associated with the scheduling policy of
    the given thread (`pid`). If the `pid` is zero, the parameters of the calling
    process are set. On success, it returns zero:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 它设置与给定线程（`pid`）的调度策略相关联的调度参数。如果`pid`为零，则设置调用进程的参数。成功时返回零：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This sets the scheduling parameters for the specified thread (`pid`). If the
    `pid` is zero, the scheduling parameters of the calling thread will be retrieved.
    On success, it returns zero:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为指定的线程（`pid`）设置调度参数。如果`pid`为零，则将检索调用线程的调度参数。成功时返回零：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It sets the scheduling policy and related attributes for the specified thread
    (`pid`). If the `pid` is zero, the policy and attributes of the calling process
    are set. This is a Linux-specific call and is the superset of the functionality
    provided by `sched_setscheduler()` and `sched_setparam()` calls. On success, it
    returns zero.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 它为指定的线程（`pid`）设置调度策略和相关属性。如果`pid`为零，则设置调用进程的策略和属性。这是一个特定于Linux的调用，是`sched_setscheduler()`和`sched_setparam()`调用提供的功能的超集。成功时返回零。
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It fetches the scheduling policy and related attributes of the specified thread
    (`pid`). If the `pid` is zero the scheduling policy and related attributes of
    the calling thread will be retrieved. This is a Linux-specific call and is a superset
    of the functionality provided by `sched_getscheduler()` and `sched_getparam()`
    calls. On success, it returns zero.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它获取指定线程（`pid`）的调度策略和相关属性。如果`pid`为零，则将检索调用线程的调度策略和相关属性。这是一个特定于Linux的调用，是`sched_getscheduler()`和`sched_getparam()`调用提供的功能的超集。成功时返回零。
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This returns the max and min priority respectively for the specified `policy`.
    `fifo`, `rr`, `deadline`, `normal`, `batch`, and `idle` are supported values of
    policy.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这分别返回指定`policy`的最大和最小优先级。`fifo`、`rr`、`deadline`、`normal`、`batch`和`idle`是策略的支持值。
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It fetches the time quantum of the specified thread (`pid`) and writes it into
    the `timespec struct`, specified by `tp`*.* If the `pid` is zero, the time quantum
    of the calling process is fetched into `tp`. This is only applicable to processes
    with the `*rr*` policy. On success, it returns zero.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 它获取指定线程（`pid`）的时间量，并将其写入由`tp`指定的`timespec`结构。如果`pid`为零，则将调用进程的时间量获取到`tp`中。这仅适用于具有`*rr*`策略的进程。成功时返回零。
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is called to relinquish the CPU explicitly. The thread is now added back
    to the queue. On success, it returns zero.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为显式地放弃CPU。线程现在被添加回队列。成功时返回零。
- en: Processor affinity calls
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器亲和力调用
- en: 'Linux-specific processor affinity calls are provided, which help the threads
    define on which CPU(s) they want to run. By default, every thread inherits the
    processor affinity of its parent, but it can define its affinity mask to determine
    its processor affinity. On many-core systems, CPU affinity calls help in enhancing
    the performance, by helping the process stick to one core (Linux however attempts
    to keep a thread on one CPU). The affinity bitmask information is contained in
    the `cpu_allowed` field of `struct task_struct`*.* The affinity calls are as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了特定于Linux的处理器亲和性调用，帮助线程定义它们想要在哪个CPU上运行。默认情况下，每个线程继承其父线程的处理器亲和性，但它可以定义其亲和性掩码以确定其处理器亲和性。在许多核心系统上，CPU亲和性调用有助于提高性能，通过帮助进程保持在一个核心上（但Linux会尝试保持一个线程在一个CPU上）。亲和性位掩信息包含在`struct
    task_struct`的`cpu_allowed`字段中。亲和性调用如下：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It sets the CPU affinity mask of the thread (`pid`) to the value mentioned by
    `mask`*.* If the thread (`pid`) is not running in one of the specified CPU's queues,
    it is migrated to the specified `cpu`. On success, it returns zero.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它将线程（`pid`）的CPU亲和性掩码设置为`mask`指定的值。如果线程（`pid`）不在指定CPU的队列中运行，则迁移到指定的`cpu`。成功时返回零。
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This fetches the affinity mask of the thread (`pid`) into the `cpusetsize` structure,
    pointed to by *mask.* If the `pid` is zero, the mask of the calling thread is
    returned. On success, it returns zero.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这将线程（`pid`）的亲和性掩码提取到由*mask*指向的`cpusetsize`结构中。如果`pid`为零，则返回调用线程的掩码。成功时返回零。
- en: Process preemption
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程抢占
- en: 'Understanding preemption and context switching is key to fully comprehending
    scheduling and the impact it has on the kernel in maintaining low latency and
    consistency. Every process must be preempted either implicitly or explicitly to
    make way for another process. Preemption might lead to context switching, which
    requires a low-level architecture-specific operation, carried out by the function
    `context_switch()`*.* There are two primary tasks that need to be done for a processor
    to switch its context: switch the virtual memory mapping of the old process with
    the new one, and switch the processor state from that of the old process to the
    new one. These two tasks are carried out by `switch_mm()` and `switch_to()`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 理解抢占和上下文切换对于完全理解调度以及它对内核在维持低延迟和一致性方面的影响至关重要。每个进程都必须被隐式或显式地抢占，以为另一个进程腾出位置。抢占可能导致上下文切换，这需要一个低级别的特定体系结构操作，由函数`context_switch()`执行。为了使处理器切换上下文，需要完成两个主要任务：将旧进程的虚拟内存映射切换为新进程的映射，并将处理器状态从旧进程切换为新进程的状态。这两个任务由`switch_mm()`和`switch_to()`执行。
- en: 'Preemption can happen for any of the following reasons:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 抢占可能发生的原因有：
- en: When a high-priority process becomes runnable. For this, the scheduler will
    have to periodically check for a high-priority runnable thread. On return from
    interrupts and system calls, `TIF_NEED_RESCHEDULE` (kernel-provided flag that
    indicates the need for a reschedule) is set, invoking the scheduler. Since there
    is a periodic timer interrupt that is guaranteed to occur at regular intervals,
    invocation of the scheduler is guaranteed. Preemption also happens when a process
    enters a blocking call or on occurrence of an interrupt event.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当高优先级进程变为可运行状态时。为此，调度程序将不时地检查是否有高优先级的可运行线程。从中断和系统调用返回时，设置`TIF_NEED_RESCHEDULE`（内核提供的指示需要重新调度的标志），调用调度程序。由于有一个周期性的定时器中断保证定期发生，调用调度程序也是有保证的。当进程进入阻塞调用或发生中断事件时，也会发生抢占。
- en: The Linux kernel historically has been non-preemptive, which means a task in
    kernel mode is non-preemptible unless an interrupt event occurs or it chooses
    to explicitly relinquish CPU. Since the 2.6 kernel, preemption has been added
    (needs to be enabled during kernel build). With kernel preemption enabled, a task
    in kernel mode is preemptible for all the reasons listed, but a kernel-mode task
    is allowed to disable kernel preemption while carrying out critical operations.
    This has been made possible by adding a preemption counter (`preempt_count`) to
    each process's `thread_info` structure*.* Tasks can disable/enable preemption
    through the kernel macros `preempt_disable()` and `preempt_enable()`*,* which
    in turn increment and decrement the `preempt_counter`*.* This ensures that the
    kernel is preemptible only when the `preempt_counter` is zero (indicating no acquired
    locks).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核在历史上一直是非抢占的，这意味着内核模式下的任务在没有中断事件发生或选择显式放弃CPU的情况下是不可抢占的。自2.6内核以来，已经添加了抢占（需要在内核构建期间启用）。启用内核抢占后，内核模式下的任务因为列出的所有原因都是可抢占的，但内核模式下的任务在执行关键操作时可以禁用内核抢占。这是通过向每个进程的`thread_info`结构添加了一个抢占计数器（`preempt_count`）来实现的。任务可以通过内核宏`preempt_disable()`和`preempt_enable()`来禁用/启用抢占，这会增加和减少`preempt_counter`。这确保了只有当`preempt_counter`为零时（表示没有获取锁）内核才是可抢占的。
- en: Critical sections in the kernel code are executed by disabling preemption, which
    is enforced by invoking `preempt_disable` and `preempt_enable` calls within kernel
    lock operations (spinlock, mutex).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 内核代码中的关键部分是通过禁用抢占来执行的，这是通过在内核锁操作（自旋锁、互斥锁）中调用`preempt_disable`和`preempt_enable`来实现的。
- en: Linux kernels build with "preempt rt", supporting *fully preemptible kernel*
    option, which when enabled makes all the kernel code including critical sections
    be fully preemptible.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“抢占rt”构建的Linux内核，支持*完全可抢占内核*选项，启用后使所有内核代码包括关键部分都是完全可抢占的。
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Process scheduling is an ever-evolving aspect of the kernel, and as Linux evolves
    and diversifies further into many computing domains, finer tweaks and changes
    to the process scheduler will be mandated. However, with our understanding established
    over this chapter, gaining deeper insights or comprehending any new changes will
    be quite easy. We are now equipped to go further and explore another important
    aspect of job control and signal management. We will brush through basics of signals
    and move on into signal management data structures and routines of the kernel.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 进程调度是内核的一个不断发展的方面，随着Linux的发展和进一步多样化到许多计算领域，对进程调度器的微调和更改将是必要的。然而，通过本章建立的理解，深入了解或理解任何新的变化将会很容易。我们现在已经具备了进一步探索作业控制和信号管理的另一个重要方面的能力。我们将简要介绍信号的基础知识，然后进入内核的信号管理数据结构和例程。
