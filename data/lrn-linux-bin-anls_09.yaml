- en: Chapter 9. Linux /proc/kcore Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。Linux /proc/kcore分析
- en: So far, we have covered Linux binaries and memory as it pertains to userland.
    This book won't be complete, however, if we don't spend a chapter on the Linux
    kernel. This is because it is actually an ELF binary as well. Similar to how a
    program is loaded into memory, the Linux kernel image, also known as **vmlinux**,
    is loaded into memory at boot time. It has a text segment and a data segment,
    overlaid with many section headers that are very specific to the kernel, and which
    you won't see in userland executables. We will also briefly cover LKMs in this
    chapter, as they are ELF files too.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了与用户空间相关的Linux二进制文件和内存。然而，如果我们不花一章的时间来讨论Linux内核，这本书就不会完整。这是因为它实际上也是一个ELF二进制文件。类似于程序加载到内存中，Linux内核映像，也被称为**vmlinux**，在启动时加载到内存中。它有一个文本段和一个数据段，上面覆盖着许多与内核非常特定的部分头，这些部分头在用户空间可执行文件中是看不到的。在本章中，我们还将简要介绍LKM，因为它们也是ELF文件。
- en: Linux kernel forensics and rootkits
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux内核取证和rootkit
- en: 'It is important to learn the layout of the Linux kernel image if you want to
    be a true master of kernel forensics in Linux. Attackers can modify the kernel
    memory to create very sophisticated kernel rootkits. There are quite a number
    of techniques out there for infecting a kernel at runtime. To list a few, we have
    the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 学习Linux内核映像的布局对于想要成为Linux内核取证真正专家的人来说非常重要。攻击者可以修改内核内存以创建非常复杂的内核rootkit。有很多技术可以在运行时感染内核。列举一些，我们有以下内容：
- en: A `sys_call_table` infection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- `sys_call_table`感染'
- en: Interrupt handler patching
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 中断处理程序修补'
- en: Function trampolines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 函数跳板'
- en: Debug register rootkits
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 调试寄存器rootkit'
- en: Exception table infection
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 异常表感染'
- en: Kprobe instrumentation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- Kprobe仪器化'
- en: The techniques listed here are the primary methods that are most commonly used
    by a kernel rootkit, which usually infects the kernel in the form of an **LKM**
    (short for **Loadable Kernel Module**). Getting an understanding of each technique
    and knowing where each infection resides within the Linux kernel and where to
    look in the memory are paramount to being able to detect this insidious class
    of Linux malware. Firstly, however, let's take a step back and see what we have
    to work with. Currently, there are a number of tools in the market and in the
    open source world that are capable of detecting kernel rootkits and help in searches
    for memory infections. We will not be discussing those. We will, however, be discussing
    methods that are taken from kernel Voodoo. Kernel Voodoo is a project of mine
    that is still mostly private, with the exception of releasing a few components
    of it to the public, such as **taskverse**. This will be discussed later in this
    chapter, with a link to download it from. It uses some very practical techniques
    for detecting almost any type of kernel infection. The software is based on ideas
    from my original work, named Kernel Detective, which was designed in 2009, and
    for the curious, it can still be found on my website at [http://www.bitlackeys.org/#kerneldetective](http://www.bitlackeys.org/#kerneldetective).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的技术是最常被内核rootkit使用的主要方法，通常以**LKM**（**可加载内核模块**的缩写）的形式感染内核。了解每种技术并知道每种感染在Linux内核中的位置以及在内存中的查找位置对于能够检测这种阴险的Linux恶意软件类别至关重要。然而，首先让我们退一步，看看我们有什么可以使用的。目前市场上和开源世界中有许多工具可以检测内核rootkit并帮助搜索内存感染。我们不会讨论这些。然而，我们将讨论从内核Voodoo中提取的方法。内核Voodoo是我的一个项目，目前大部分仍然是私有的，只有一些组件被发布给公众，比如**taskverse**。这将在本章后面讨论，并提供下载链接。它使用一些非常实用的技术来检测几乎任何类型的内核感染。该软件基于我原始作品的想法，名为Kernel
    Detective，该作品设计于2009年，对于好奇的人，仍然可以在我的网站上找到[http://www.bitlackeys.org/#kerneldetective](http://www.bitlackeys.org/#kerneldetective)。
- en: This software works on older 32-bit Linux kernels (2.6.0 to 2.6.32) only; 64-bit
    support was only partially completed. Some of the ideas from this project were
    timeless, however, and I extracted them recently and coupled them with some new
    ideas. The result is Kernel Voodoo, a host intrusion detection system, and kernel
    forensics software that relies on /proc/kcore for advanced memory acquisition
    and analysis. In this chapter, we are going to discuss some of the fundamental
    techniques that it uses, and in some cases, we will employ them manually with
    GDB and /proc/kcore.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个软件只适用于旧的32位Linux内核（2.6.0到2.6.32）；64位支持只完成了部分。然而，这个项目的一些想法是永恒的，我最近提取了它们，并结合了一些新的想法。结果就是Kernel
    Voodoo，一个依赖于/proc/kcore进行高级内存获取和分析的主机入侵检测系统和内核取证软件。在本章中，我们将讨论它使用的一些基本技术，并在某些情况下，我们将使用GDB和/proc/kcore手动进行操作。
- en: stock vmlinux has no symbols
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '- 标准vmlinux没有符号'
- en: Unless you have compiled your own kernel, you will not have a readily accessible
    vmlinux, which is an ELF executable. Instead, you will have a compressed kernel
    in `/boot`, usually named `vmlinuz-<kernel_version>`. This compressed kernel image
    can be decompressed, but the result is a kernel executable that has no symbol
    table. This poses a problem for forensics analysts or kernel debugging with GDB.
    The solution for most people in this case is to hope that their Linux distribution
    has a special package with their kernel version having debug symbols. If so, then
    they can download a copy of their kernel that has symbols from the distribution
    repository. In many cases, however, this is not possible, or not convenient for
    one reason or another. Nonetheless, this problem can be remedied with a custom
    utility that I designed and released in 2014\. This tool is called **kdress**,
    because it dresses the kernel symbol table.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您自己编译了内核，否则您将无法直接访问vmlinux，它是一个ELF可执行文件。相反，您将在`/boot`中有一个压缩的内核，通常命名为`vmlinuz-<kernel_version>`。这个压缩的内核镜像可以被解压缩，但结果是一个没有符号表的内核可执行文件。这对于取证分析师或使用GDB进行内核调试来说是一个问题。在这种情况下，大多数人的解决方案是希望他们的Linux发行版有一个带有调试符号的内核版本的特殊软件包。如果是这样，他们可以从发行库中下载一个带有符号的内核副本。然而，在许多情况下，这是不可能的，或者由于某种原因不方便。尽管如此，这个问题可以通过我在2014年设计和发布的一个自定义实用程序来解决。这个工具叫做**kdress**，因为它装饰了内核符号表。
- en: Actually, it is named after an old tool by Michael Zalewskis, called dress.
    That tool would dress a static executable with a symbol table. This name originates
    from the fact that people run a program called **strip** to remove symbols from
    an executable, and therefore "dress" is an appropriate name for a tool that rebuilds
    the symbol table. Our tool, kdress, simply takes information about symbols from
    either the `System.map` file or `/proc/kallsyms` depending on whichever is more
    readily available. Then, it reconstructs that information into the kernel executable
    by creating a section header for the symbol table. This tool can be found on my
    GitHub profile at [https://github.com/elfmaster/kdress](https://github.com/elfmaster/kdress).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它是以Michael Zalewskis的一个旧工具dress命名的。那个工具会给一个静态可执行文件添加一个符号表。这个名字源于人们运行一个叫做**strip**的程序来从可执行文件中删除符号，因此"装饰"是一个重建符号表的工具的合适名字。我们的工具kdress只是从`System.map`文件或`/proc/kallsyms`中获取符号的信息，然后通过为符号表创建一个段头将该信息重建到内核可执行文件中。这个工具可以在我的GitHub个人资料中找到[https://github.com/elfmaster/kdress](https://github.com/elfmaster/kdress)。
- en: Building a proper vmlinux with kdress
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用kdress构建适当的vmlinux
- en: 'Here is an example that shows how to use the kdress utility to build a vmlinux
    image that can be loaded with GDB:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示了如何使用kdress实用程序构建一个可以在GDB中加载的vmlinux镜像：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The utility has created an output file called vmlinux, which has a fully reconstructed
    symbol table. If, for example, we want to locate the `sys_call_table` in the kernel,
    then we can easily find it:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 该实用程序已创建一个名为vmlinux的输出文件，其中包含完全重建的符号表。例如，如果我们想要在内核中定位`sys_call_table`，那么我们可以很容易地找到它：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Having a kernel image with symbols is very important for both debugging and
    forensic analysis. Nearly all forensics on the Linux kernel can be done with GDB
    and `/proc/kcore`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 具有符号的内核镜像对于调试和取证分析都非常重要。几乎所有对Linux内核的取证都可以通过GDB和`/proc/kcore`完成。
- en: /proc/kcore and GDB exploration
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: /proc/kcore和GDB探索
- en: The `/proc/kcore` technique is an interface for accessing kernel memory, and
    is conveniently in the form of an ELF core file that can be easily navigated with
    GDB.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc/kcore`技术是访问内核内存的接口，以ELF核心文件的形式方便地使用GDB进行导航。'
- en: Using GDB with `/proc/kcore` is a priceless technique that can be expanded to
    very in-depth forensics for the skilled analyst. Here is a brief example that
    shows how to navigate `sys_call_table`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GDB和`/proc/kcore`是一种无价的技术，可以扩展到熟练分析师的深入取证。以下是一个简短的示例，展示了如何导航`sys_call_table`。
- en: An example of navigating sys_call_table
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航sys_call_table的示例
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we can look at the first pointer held in `sys_call_table[0]`
    and determine that it contains the address of the syscall function `sys_read`.
    We can then look at the first five instructions of that syscall. This is an example
    of how easy it is to navigate kernel memory using GDB and `/proc/kcore`. If there
    had been a kernel rootkit installed that hooked `sys_read` with function trampolines,
    then displaying the first few instructions would have shown a jump or return to
    another malicious function. Using a debugger in this manner to detect kernel rootkits
    is very useful if you know what to look for. The structural nuances of the Linux
    kernel and how it may be infected are advanced topics and seem esoteric to many
    people. One chapter is not enough to fully demystify all of this, but we will
    cover the methods that may be used to infect the kernel and detect the infections.
    In the following sections, I will discuss a few approaches used to infect the
    kernel from a general standpoint, while giving some examples.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以查看`sys_call_table[0]`中保存的第一个指针，并确定它包含了系统调用函数`sys_read`的地址。然后我们可以查看该系统调用的前五条指令。这是一个例子，说明使用GDB和`/proc/kcore`轻松导航内核内存。如果已经安装了钩住`sys_read`的内核rootkit，并使用了函数trampolines，那么显示前几条指令将显示跳转或返回到另一个恶意函数。如果您知道要查找什么，使用调试器来检测内核rootkit非常有用。Linux内核的结构细微差别以及可能被感染的方式是高级主题，对许多人来说似乎是神秘的。一章不足以完全揭开所有这些，但我们将涵盖可能用于感染内核和检测感染的方法。在接下来的章节中，我将从一般的角度讨论一些用于感染内核的方法，并给出一些例子。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using just GDB and `/proc/kcore`, it is possible to detect every type of infection
    that is mentioned throughout this chapter. Tools such as kernel Voodoo are very
    nice and convenient but are not absolutely necessary to detect deviations from
    a normally operating kernel.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 只使用GDB和`/proc/kcore`，就可以检测到本章中提到的每一种感染。像内核Voodoo这样的工具非常好用方便，但并不是绝对必要的，可以检测到与正常运行的内核有所不同。
- en: Direct sys_call_table modifications
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接sys_call_table修改
- en: Traditional kernel rootkits, such as **adore** and **phalanx**, worked by overwriting
    pointers in `sys_call_table` so that they would point to a replacement function,
    which would then call the original syscall as needed. This was accomplished by
    either an LKM or a program that modified the kernel through `/dev/kmem` or `/dev/mem`.
    On today's Linux systems, for security reasons, these writable windows into memory
    are disabled or are no longer capable of anything but read operations depending
    on how the kernel is configured. There have been other ways of trying to prevent
    this type of infection, such as marking `sys_call_table` as `const` so that it
    is stored in the `.rodata` section of the text segment. This can be bypassed by
    marking the corresponding **PTE** (short for **Page Table Entry**) as writeable,
    or by disabling the write-protect bit in the `cr0` register. Therefore, this type
    of infection is a very reliable way to make a rootkit even today, but it is also
    very easily detected.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的内核rootkit，如**adore**和**phalanx**，通过覆盖`sys_call_table`中的指针，使它们指向替代函数，然后根据需要调用原始系统调用来工作。这是通过LKM或通过`/dev/kmem`或`/dev/mem`修改内核的程序来实现的。在今天的Linux系统中，出于安全原因，这些可写的内存窗口已被禁用，或者根据内核的配置，除了读操作外，不再能够进行任何操作。还有其他方法试图防止这种感染，例如将`sys_call_table`标记为`const`，以便它存储在文本段的`.rodata`部分。这可以通过将相应的**PTE**（Page
    Table Entry的缩写）标记为可写，或者通过禁用`cr0`寄存器中的写保护位来绕过。因此，这种类型的感染是一种非常可靠的制作rootkit的方法，但也非常容易被检测到。
- en: Detecting sys_call_table modifications
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测`sys_call_table`的修改
- en: To detect `sys_call_table` modifications, you may look at the `System.map` file
    or `/proc/kallsyms` to see what the memory address of each system call should
    be. For instance, if we want to detect whether or not the `sys_write` system call
    has been infected, we need to learn the legitimate address of `sys_write` and
    its index within the `sys_call_table`, and then validate that the correct address
    is actually stored there in memory using GDB and `/proc/kcore`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测`sys_call_table`的修改，可以查看`System.map`文件或`/proc/kallsyms`，以查看每个系统调用的内存地址。例如，如果我们想要检测`sys_write`系统调用是否被感染，我们需要了解`sys_write`的合法地址及其在`sys_call_table`中的索引，然后使用GDB和`/proc/kcore`验证正确的地址是否实际存储在内存中。
- en: An example of validating the integrity of a syscall
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证系统调用完整性的示例
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Remember that numbers are stored in little endian on x86 architecture. The value
    at `sys_call_table[1]` is equivalent to the correct `sys_write` address as looked
    up in `/proc/kallsyms`. We have therefore successfully verified that the `sys_call_table`
    entry for `sys_write` has not been tampered with.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在x86架构上，数字是以小端存储的。`sys_call_table[1]`处的值等同于在`/proc/kallsyms`中查找的正确的`sys_write`地址。因此，我们已成功验证了`sys_write`的`sys_call_table`条目没有被篡改。
- en: Kernel function trampolines
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核函数跳板
- en: This technique was originally introduced by Silvio Cesare in 1998\. The idea
    was to be able to modify syscalls without having to touch `sys_call_table`, but
    the truth is that this technique allows any function in the kernel to be hooked.
    Therefore, it is very powerful. Since 1998, a lot has changed; the kernels text
    segments can no longer be modified without disabling the write-protect bit in
    `cr0` or modifying a PTE. The main issue, however, is that most modern kernels
    use SMP, and kernel function trampolines are unsafe because they use non-atomic
    operations such as `memcpy()` every time the patched function is called. As it
    turns out, there are methods for circumventing this problem as well, using a technique
    that I will not discuss here. The real point is that kernel function trampolines
    are actually still being used, and therefore understanding them is still quite
    important.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术最初是由Silvio Cesare于1998年引入的。其想法是能够修改系统调用而无需触及`sys_call_table`，但事实上，这种技术允许钩住内核中的任何函数。因此，它非常强大。自1998年以来，很多事情已经发生了；内核的文本段现在不能再被修改，除非禁用`cr0`中的写保护位或修改PTE。然而，主要问题在于，大多数现代内核使用SMP，而内核函数跳板是不安全的，因为它们在每次调用补丁函数时使用非原子操作，比如`memcpy()`。事实证明，还有方法可以规避这个问题，使用一种我在这里不讨论的技术。真正的问题在于，内核函数跳板实际上仍在使用，因此理解它们仍然非常重要。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is considered a safer technique to patch the individual call instructions
    that invoke the original function so that they invoke the replacement function
    instead. This method can be used as an alternative to function trampolines, but
    it may be arduous to find every single call, and this often changes from kernel
    to kernel. Therefore, this method is not as portable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 修改调用原始函数的单个调用指令，使其调用替代函数，被认为是一种更安全的技术。这种方法可以用作替代函数跳板，但可能很难找到每个单独的调用，而且这通常会因内核而异。因此，这种方法不太具有可移植性。
- en: Example of function trampolines
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数跳板的示例
- en: Imagine you want to hijack syscall `SYS_write` and do not want to worry about
    modifying `sys_call_table` directly since it is easily detectable. This can be
    accomplished by overwriting the first 7 bytes of the `sys_write` code with a stub
    that contains code for jumping to another function.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你想劫持系统调用`SYS_write`，并且不想担心直接修改`sys_call_table`，因为这很容易被检测到。这可以通过覆盖`sys_write`代码的前7个字节，使用包含跳转到另一个函数的代码的存根来实现。
- en: An example code for hijacking sys_write on a 32-bit kernel
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在32位内核上劫持sys_write的示例代码
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code example replaces the first 6 bytes of `sys_write` with a `push; ret`
    stub, which pushes the address of the new `sys_write` function onto the stack
    and returns to it. The new `sys_write` function can then do any sneaky stuff it
    wants to, although in this example we only print a message to the kernel log buffer.
    After it has done the sneaky stuff, it must remove the trampoline code so that
    it can call untampered sys_write, and finally it puts the trampoline code back
    in place.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例用`push; ret`存根替换了`sys_write`的前6个字节，它将新的`sys_write`函数的地址推送到堆栈上并返回到它。然后新的`sys_write`函数可以做任何诡秘的事情，尽管在这个示例中我们只是向内核日志缓冲区打印一条消息。在完成了诡秘的事情之后，它必须删除跳板代码，以便调用未篡改的sys_write，并最后将跳板代码放回原处。
- en: Detecting function trampolines
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测函数跳板
- en: Typically, function trampolines will overwrite part of the procedure prologue
    (the first 5 to 7 bytes) of the function that they are hooking. So, to detect
    function trampolines within any kernel function or syscall, you should inspect
    the first 5 to 7 bytes and look for code that jumps or returns to another address.
    Code like this can come in a variety of forms. Here are a few examples.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，函数跳板将覆盖它们钩住的函数的过程前言的一部分（前5到7个字节）。因此，要检测内核函数或系统调用中的函数跳板，应检查前5到7个字节，并寻找跳转或返回到另一个地址的代码。这样的代码可以有各种形式。以下是一些示例。
- en: An example with the ret instruction
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ret指令的示例
- en: 'Push the target address onto the stack and return to it. This takes up 6 bytes
    of machine code when a 32-bit target address is used:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将目标地址推送到堆栈上并返回到它。当使用32位目标地址时，这需要6个字节的机器代码：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: An example with indirect jmp
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用间接jmp的示例
- en: 'Move the target address into a register for an indirect jump. This takes 7
    bytes of code when a 32-bit target address is used:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将目标地址移入寄存器以进行间接跳转。当使用32位目标地址时，这需要7个字节的代码：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: An example with relative jmp
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用相对jmp的示例
- en: 'Calculate the offset and perform a relative jump. This takes 5 bytes of code
    when a 32-bit offset is used:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 计算偏移量并执行相对跳转。当使用32位偏移量时，这需要5个字节的代码：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If, for instance, we want to validate whether or not the sys_write syscall
    has been hooked with a function trampoline, we can simply examine its code to
    see whether the procedure prologue is still in place:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要验证`sys_write`系统调用是否已经被函数跳板钩住，我们可以简单地检查它的代码，看看过程前言是否还在原位：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first 5 bytes are actually serving as NOP instructions for alignment (or
    possibly space for ftrace probes). The kernel uses certain sequences of bytes
    (0x66, 0x66, 0x66, 0x66, and 0x90). The procedure prologue code follows the initial
    5 NOP bytes, and is perfectly intact. Therefore, this validates that `sys_write`
    syscall has not been hooked with any function trampolines.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前5个字节实际上用作NOP指令以进行对齐（或可能是ftrace探针的空间）。内核使用某些字节序列（0x66、0x66、0x66、0x66和0x90）。过程前言代码跟随最初的5个NOP字节，并且完全完整。因此，这验证了`sys_write`系统调用没有被任何函数跳板钩住。
- en: Interrupt handler patching – int 0x80, syscall
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 中断处理程序修补- int 0x80, syscall
- en: 'One classic way of infecting the kernel is by inserting a phony system call
    table into the kernel memory and modifying the top-half interrupt handler that
    is responsible for invoking syscalls. In an x86 architecture, the interrupt 0x80
    is deprecated and has been replaced with a special `syscall/sysenter` instruction
    for invoking system calls. Both syscall/sysenter and `int 0x80` end up invoking
    the same function, named `system_call()`, which in-turn calls the selected syscall
    within `sys_call_table`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 感染内核的一个经典方法是将一个虚假的系统调用表插入内核内存，并修改负责调用系统调用的顶半部中断处理程序。在x86架构中，中断0x80已经被弃用，并已被用特殊的`syscall/sysenter`指令替换，用于调用系统调用。syscall/sysenter和`int
    0x80`最终都会调用同一个函数，名为`system_call()`，它又调用`sys_call_table`中选择的系统调用。
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On x86_64, the preceding call instruction takes place after a swapgs in `system_call()`.
    Here is what the code looks like in `entry.S`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86_64上，在`system_call()`中的swapgs之后发生前面的call指令。以下是`entry.S`中代码的样子：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `(r/e)ax` register contains the syscall number that is multiplied by `sizeof(long)`
    to get the index into the correct syscall pointer. It is easily conceivable that
    an attacker can `kmalloc()` a phony system call table into the memory (which contains
    some modifications with pointers to malicious functions), and then patch the call
    instruction so that the phony system call table is used. This technique is actually
    quite stealthy because it yields no modifications to the original `sys_call_table`.
    Unfortunately for intruders, however, this technique is still very easy to detect
    for the trained eye.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`(r/e)ax`寄存器包含被`sizeof(long)`乘以以获取正确系统调用指针的索引的系统调用号。很容易想象，攻击者可以`kmalloc()`一个虚假的系统调用表到内存中（其中包含一些指向恶意函数的修改），然后修补调用指令，以便使用虚假的系统调用表。这种技术实际上非常隐秘，因为它对原始的`sys_call_table`没有任何修改。然而，对于训练有素的人来说，这种技术仍然很容易检测到。'
- en: Detecting interrupt handler patching
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测中断处理程序的修补
- en: To detect whether the `system_call()` routine has been patched with a call to
    a phony `sys_call_table` or not, simply disassemble the code with GDB and `/proc/kcore`,
    and then find out whether or not the call offset points to the address of `sys_call_table`.
    The correct `sys_call_table` address can be found in `System.map` or `/proc/kallsyms`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测`system_call()`例程是否已经被修补为调用虚假的`sys_call_table`，只需使用GDB和`/proc/kcore`反汇编代码，然后找出调用偏移是否指向`sys_call_table`的地址。正确的`sys_call_table`地址可以在`System.map`或`/proc/kallsyms`中找到。
- en: Kprobe rootkits
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kprobe rootkits
- en: This particular type of kernel rootkit was originally conceived and described
    in great detail in a 2010 Phrack paper that I wrote. The paper can be found at
    [http://phrack.org/issues/67/6.html](http://phrack.org/issues/67/6.html).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特定类型的内核rootkit最初是在2010年我写的一篇Phrack论文中详细构想和描述的。该论文可以在[http://phrack.org/issues/67/6.html](http://phrack.org/issues/67/6.html)找到。
- en: This type of kernel rootkit is one of the more exotic brands in that it uses
    the Linux kernels Kprobe debugging hooks to set breakpoints on the target kernel
    function that the rootkit is attempting to modify. This particular technique has
    its limitations, but it can be quite powerful and stealthy. However, just like
    any of the other techniques, if the analyst knows what to look for, then the kernel
    rootkits that use kprobes can be quite easy to detect.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的内核rootkit是比较奇特的品牌之一，它使用Linux内核的Kprobe调试钩子在rootkit试图修改的目标内核函数上设置断点。这种特定的技术有其局限性，但它可以非常强大和隐蔽。然而，就像其他任何技术一样，如果分析人员知道要寻找什么，那么使用kprobes的内核rootkit就可以很容易地被检测到。
- en: Detecting kprobe rootkits
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测kprobe rootkit
- en: Detecting the presence of kprobes by analyzing memory is quite easy. When a
    regular kprobe is set, a breakpoint is placed on either the entry point of a function
    (see jprobes) or on an arbitrary instruction. This is extremely easy to detect
    by scanning the entire code segment looking for breakpoints, as there is no reason
    a breakpoint should be placed in the kernel code other than for the sake of kprobes.
    For the case of detecting optimized kprobes, a jmp instruction is used instead
    of a breakpoint (`int3`) instruction. This would be easiest to detect when jmp
    is placed on the first byte of a function, since that is clearly out of place.
    Lastly, there is a simple list of active kprobes in `/sys/kernel/debug/kprobes/list`
    that actually contains a list of kprobes that are being used. However, any rootkit,
    including the one that I demonstrated in phrack, will hide its kprobes from the
    file, so do not rely on it. A good rootkit will also prevent kprobes from being
    disabled in `/sys/kernel/debug/kprobes/enabled`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析内存来检测kprobes的存在非常容易。当设置常规kprobe时，会在函数的入口点（参见jprobes）或任意指令上设置断点。通过扫描整个代码段寻找断点来检测是非常容易的，因为除了为了kprobes而设置断点外，没有其他原因应该在内核代码中设置断点。对于检测优化过的kprobes，会使用jmp指令而不是断点（`int3`）指令。当jmp放置在函数的第一个字节上时，这是最容易检测的，因为那显然是不合适的。最后，在`/sys/kernel/debug/kprobes/list`中有一个活跃的kprobes简单列表，其中实际包含正在使用的kprobes的列表。然而，任何rootkit，包括我在phrack中演示的rootkit，都会隐藏其kprobes，所以不要依赖它。一个好的rootkit还会阻止在`/sys/kernel/debug/kprobes/enabled`中禁用kprobes。
- en: Debug register rootkits – DRR
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试寄存器rootkit – DRR
- en: 'This type of kernel rootkit uses the Intel Debug registers as a means to hijack
    the control flow. A great Phrack paper was written by *halfdead* on this technique.
    It is available here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的内核rootkit使用Intel Debug寄存器来劫持控制流。 *halfdead*在这种技术上写了一篇很棒的Phrack论文。它可以在这里找到：
- en: '[http://phrack.org/issues/65/8.html](http://phrack.org/issues/65/8.html).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://phrack.org/issues/65/8.html](http://phrack.org/issues/65/8.html)。'
- en: This technique is often hailed as ultra-stealth because it requires no modification
    of `sys_call_table`. Once again, however, there are ways of detecting this type
    of infection as well.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术通常被誉为超级隐蔽，因为它不需要修改`sys_call_table`。然而，同样地，也有方法来检测这种类型的感染。
- en: Detecting DRR
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测DRR
- en: 'In many rootkit implementations, `sys_call_table` and other common infection
    points do go unmodified, but the `int1` handler does not. The call instruction
    to the `do_debug` function gets patched to call an alternative `do_debug` function,
    as shown in the phrack paper linked earlier. Therefore, detecting this type of
    rootkit is often as simple as disassembling the int1 handler and looking at the
    offset of the `call do_debug` instruction, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多rootkit实现中，`sys_call_table`和其他常见的感染点确实没有被修改，但`int1`处理程序没有。对`do_debug`函数的调用指令被修改为调用另一个`do_debug`函数，如前面链接的phrack论文所示。因此，检测这种类型的rootkit通常就像反汇编int1处理程序并查看`call
    do_debug`指令的偏移一样简单，如下所示：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If `target_address` has the same value as the `do_debug` address found in `System.map`
    or `/proc/kallsyms`, it means that the int1 handler has not been patched and is
    considered clean.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`target_address`的值与`System.map`或`/proc/kallsyms`中找到的`do_debug`地址相同，则意味着int1处理程序未被修改，被视为干净的。
- en: VFS layer rootkits
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VFS层rootkit
- en: Another classic and powerful method of infecting the kernel is by infecting
    the kernel's VFS layer. This technique is wonderful and quite stealthy since it
    technically modifies the data segment in the memory and not the text segment,
    where discrepancies are easier to detect. The VFS layer is very object-oriented
    and contains a variety of structs with function pointers. These function pointers
    are filesystem operations such as open, read, write, readdir, and so on. If an
    attacker can patch these function pointers, then they can take control of these
    operations in any way that they see fit.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 感染内核的另一个经典而强大的方法是通过感染内核的VFS层。这种技术非常出色和隐蔽，因为它在技术上修改了内存中的数据段而不是文本段，而后者更容易检测到不一致。VFS层是非常面向对象的，包含各种带有函数指针的结构。这些函数指针是文件系统操作，如打开、读取、写入、读取目录等。如果攻击者可以修改这些函数指针，那么他们可以以任何他们认为合适的方式控制这些操作。
- en: Detecting VFS layer rootkits
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测VFS层rootkit
- en: There are probably several techniques out there for detecting this type of infection.
    The general idea, however, is to validate the function pointer addresses and confirm
    that they are pointing to the expected functions. In most cases, these should
    be pointing to functions within the kernel and not to functions that exist in
    LKMs. One quick approach to detecting is to validate that the pointers are within
    the range of the kernel's text segment.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有几种技术可以用来检测这种类型的感染。然而，一般的想法是验证函数指针地址，并确认它们指向预期的函数。在大多数情况下，这些应该指向内核中的函数，而不是存在于LKMs中的函数。检测的一个快速方法是验证指针是否在内核的文本段范围内。
- en: An example of validating a VFS function pointer
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证VFS函数指针的一个例子
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Other kernel infection techniques
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他内核感染技术
- en: There are other techniques available for hackers for the purpose of infecting
    the Linux kernel (we have not discussed these in this chapter), such as hijacking
    the Linux page fault handler ([http://phrack.org/issues/61/7.html](http://phrack.org/issues/61/7.html)).
    Many of these techniques can be detected by looking for modifications to the text
    segment, which is a detection approach that we will examine further in the next
    sections.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客可以使用其他技术来感染 Linux 内核（我们在本章中没有讨论这些技术），比如劫持 Linux 页面错误处理程序（[http://phrack.org/issues/61/7.html](http://phrack.org/issues/61/7.html)）。许多这些技术可以通过查找对文本段的修改来检测，这是我们将在接下来的章节中进一步研究的检测方法。
- en: vmlinux and .altinstructions patching
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: vmlinux和.altinstructions补丁
- en: 'In my opinion, the single most effective method of rootkit detection can be
    summed up by verifying the code integrity of the kernel in the memory—in other
    words, comparing the code in the kernel memory against the expected code. But
    what can we compare kernel memory code against? Well, why not vmlinux? This was
    an approach that I originally explored in 2008\. Knowing that an ELF executable''s
    text segment does not change from disk to memory, unless it''s some weird self-modifying
    binary, which the kernel is not… or is it? I quickly ran into trouble and was
    finding all sorts of code discrepancies between the kernel memory text segment
    and the vmlinux text segment. This was baffling at first since I had no kernel
    rootkits installed during these tests. After examining some of the ELF sections
    in vmlinux, however, I quickly saw some areas that caught my attention:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，检测 rootkit 最有效的方法可以通过验证内核内存中的代码完整性来概括，换句话说，就是将内核内存中的代码与预期的代码进行比较。但是我们可以将内核内存代码与什么进行比较呢？嗯，为什么不是
    vmlinux 呢？这是我最初在 2008 年探索的一种方法。知道 ELF 可执行文件的文本段从磁盘到内存不会改变，除非它是一些奇怪的自修改二进制文件，而内核不是……或者它是吗？我很快遇到了麻烦，并发现内核内存文本段和
    vmlinux 文本段之间存在各种代码差异。这一开始让我感到困惑，因为在这些测试期间我没有安装任何内核 rootkit。然而，在检查了 vmlinux 中的一些
    ELF 部分后，我很快发现了一些引起我的注意的地方：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There are several sections within the Linux kernel binary that contain alternative
    instructions. As it turns out, the Linux kernel developers had a bright idea:
    what if the Linux kernel can intelligently patch its own code segment at runtime,
    changing certain instructions for "memory barriers" based on the specific CPU
    that was detected? This would be a nice idea because fewer stock kernels would
    need to be created for all the different types of CPUs out there. Unfortunately
    for the security researcher who wants to detect any malicious changes in the kernel''s
    code segment, these alternative instructions would have to be understood and applied
    first.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核二进制文件中有几个部分包含了替代指令。事实证明，Linux 内核开发人员有一个聪明的想法：如果 Linux 内核可以智能地在运行时修补自己的代码段，根据检测到的特定
    CPU 改变某些指令以进行“内存屏障”，这将是一个好主意，因为更少的标准内核需要为所有不同类型的 CPU 创建。不幸的是，对于想要检测内核代码段中的任何恶意更改的安全研究人员来说，这些替代指令首先需要被理解和应用。
- en: .altinstructions and .altinstr_replace
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .altinstructions 和 .altinstr_replace
- en: 'There are two sections that contain the majority of information needed to know
    which instructions in the kernel are getting patched at runtime. There is a great
    article that explains these sections now, which was not available at the time
    of my early research into this area of the kernel:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个部分包含了大部分需要知道的信息，即内核中哪些指令在运行时被修补。现在有一篇很好的文章解释了这些部分，这在我早期研究这一内核领域时是不可用的。
- en: '[https://lwn.net/Articles/531148/](https://lwn.net/Articles/531148/)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://lwn.net/Articles/531148/](https://lwn.net/Articles/531148/)'
- en: The general idea, however, is that the `.altinstructions` section contains an
    array of `struct alt_instr` structs. Each one represents an alternative instruction
    record, giving you the location of the original instruction and the location of
    the new instruction that should be used to patch the original. The `.altinstr_replace`
    section contains the actual alternative instructions that are referenced by the
    `alt_instr->repl_offset` member.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，总体思路是，`.altinstructions` 部分包含一个 `struct alt_instr` 结构的数组。每个结构代表一个替代指令记录，给出了应该用于修补原始指令的新指令的位置。`.altinstr_replace`
    部分包含了实际的替代指令，这些指令由 `alt_instr->repl_offset` 成员引用。
- en: From arch/x86/include/asm/alternative.h
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来自 arch/x86/include/asm/alternative.h
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: On older kernels, the first two members gave the absolute addresses of the old
    and new instructions, but on newer kernels, a relative offset is used.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧内核上，前两个成员给出了旧指令和新指令的绝对地址，但在新内核上，使用了相对偏移量。
- en: Using textify to verify kernel code integrity
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 textify 来验证内核代码完整性
- en: Over the years, I have designed several tools that detect the integrity of the
    Linux kernel's code segment. This detection technique will obviously work only
    on kernel rootkits that modify the text segment, and most of them do in some way
    or the other. However, there are exceptions such as rootkits that rely only on
    altering the VFS layer, which resides in the data segment and will not be detected
    by verifying the integrity of the text segment. Most recently, the tool that I
    wrote (a part of the kernel Voodoo software suite) is named textify, and it essentially
    compares the text segment of the kernel memory, taken from `/proc/kcore`, against
    the text segment in vmlinux. It parses `.altinstructions` and various other sections,
    such as `.parainstructions`, to learn the locations of code instructions that
    are legally patched. In this way, there are no false positives showing up. Although
    textify is currently not available to the public, the general idea has been explained.
    Therefore, it may be reimplemented by anyone who wishes to attempt the somewhat
    arduous coding procedures necessary to make it work.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，我设计了几个工具，用于检测Linux内核代码段的完整性。这种检测技术显然只对修改文本段的内核rootkit有效，而大多数内核rootkit在某种程度上都会这样做。但是，也有一些例外，例如仅依赖于修改VFS层的rootkit，它位于数据段中，不会通过验证文本段的完整性来检测到。最近，我编写的工具（内核Voodoo软件套件的一部分）名为textify，它基本上比较了从`/proc/kcore`中获取的内核内存的文本段与vmlinux中的文本段。它解析`.altinstructions`和其他各种部分，例如`.parainstructions`，以了解合法修补的代码指令的位置。通过这种方式，不会出现错误的阳性。尽管textify目前不向公众开放，但一般思路已经解释过。因此，任何希望尝试使其工作的人都可以重新实现它，尽管这需要一些繁琐的编码过程。
- en: An example of using textify to check sys_call_table
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用textify检查sys_call_table的示例
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, we first check to make sure that `sys_call_table`
    has not been modified. On modern Linux systems, `sys_call_table` is marked as
    read-only and is therefore stored in the text segment, which is why we can use
    textify to validate its integrity. In the next command, we run textify with the
    `-a` switch, which scans every single byte in the entire text segment for illegal
    modifications. We could have simply run `-a` to begin with since `sys_call_table`
    is included in `-a`, but sometimes, it's nice to scan things by symbol name too.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们首先检查`sys_call_table`是否已被修改。在现代Linux系统上，`sys_call_table`被标记为只读，因此存储在文本段中，这就是为什么我们可以使用textify来验证其完整性。在下一个命令中，我们使用`-a`开关运行textify，该开关扫描整个文本段中的每个字节，以查找非法修改。我们本可以直接运行`-a`，因为`sys_call_table`包含在`-a`中，但有时，按符号名称扫描东西也很好。
- en: Using taskverse to see hidden processes
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用taskverse查看隐藏进程
- en: In the Linux kernel, there are a several ways to modify the kernel so that process
    hiding can work. Since this chapter is not meant to be an exegesis on all kernel
    rootkits, I will cover only the most commonly used method and then propose a way
    of detecting it, which is implemented in the taskverse program I made available
    in 2014.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux内核中，有几种修改内核的方法，以便进程隐藏可以工作。由于本章不是要对所有内核rootkit进行详细解释，我只会介绍最常用的方法，然后提出一种检测方法，这种方法已经在我2014年发布的taskverse程序中实现。
- en: In Linux, the process IDs are stored as directories within the `/proc` filesystem;
    each directory contains a plethora of information about the process. The `/bin/ps`
    program does a directory listing in `/proc` to see which pids are currently running
    on the system. A directory listing in Linux (such as with `ps` or `ls`) uses the
    `sys_getdents64` system call and the `filldir64` kernel function. Many kernel
    rootkits hijack one of these functions (depending on the kernel version) and then
    insert some code that skips over the directory entry containing the `d_name` of
    the hidden process. As a result, the `/bin/ps` program is unable to find the processes
    that the kernel rootkit deems hidden by skipping over them in the directory listing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，进程ID存储为`/proc`文件系统中的目录；每个目录包含有关进程的大量信息。`/bin/ps`程序在`/proc`中进行目录列表，以查看系统上当前正在运行的pid。Linux中的目录列表（例如使用`ps`或`ls`）使用`sys_getdents64`系统调用和`filldir64`内核函数。许多内核rootkit劫持其中一个这些函数（取决于内核版本），然后插入一些代码，跳过包含隐藏进程的`d_name`的目录条目。因此，`/bin/ps`程序无法找到内核rootkit认为在目录列表中跳过的进程。
- en: Taskverse techniques
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Taskverse技术
- en: The taskverse program is a part of the kernel Voodoo package, but I released
    a more elementary version for free that uses only one technique to detect hidden
    processes; however, this technique is still very useful. As we were just discussing,
    rootkits commonly hide the pid-directories in `/proc` so that `sys_getdents64`
    and `filldir64` cannot see them. The most straightforward and obvious approach
    used to see these processes would be to bypass the /proc directory completely
    and follow the task list in the kernel memory to look at each process descriptor
    that is represented by a linked list of `struct task_struct` entries. The head
    of the list pointer can be found by looking up the `init_task` symbol. With this
    knowledge, a programmer with some skill can open up `/proc/kcore` and traverse
    the task list. The details of this code can be viewed in the project itself, which
    is available on my GitHub profile at [https://github.com/elfmaster/taskverse](https://github.com/elfmaster/taskverse).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: taskverse程序是内核Voodoo软件包的一部分，但我发布了一个更基本的免费版本，只使用一种技术来检测隐藏进程；但是，这种技术仍然非常有用。正如我们刚才讨论的，rootkit通常会隐藏`/proc`中的pid目录，以便`sys_getdents64`和`filldir64`无法看到它们。用于查看这些进程的最直接和明显的方法是完全绕过/proc目录，并在内核内存中的任务列表中查看由`struct
    task_struct`条目的链接列表表示的每个进程描述符。可以通过查找`init_task`符号找到列表指针的头部。有一定技能的程序员可以利用这些知识打开`/proc/kcore`并遍历任务列表。此代码的详细信息可以在项目本身中查看，该项目可以在我的GitHub个人资料上找到[https://github.com/elfmaster/taskverse](https://github.com/elfmaster/taskverse)。
- en: Infected LKMs – kernel drivers
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 感染的LKMs-内核驱动程序
- en: So far, we have covered various types of kernel rootkit infections in memory,
    but I think that this chapter begs a section dedicated to explaining how kernel
    drivers can be infected by attackers, and how to go about detecting these infections.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了内存中各种类型的内核rootkit感染，但我认为这一章节需要专门解释攻击者如何感染内核驱动程序，以及如何检测这些感染。
- en: Method 1 for infecting LKM files – symbol hijacking
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法1感染LKM文件的方法-符号劫持
- en: 'LKMs are ELF objects. To be more specific, they are `ET_REL` files (object
    files). Since they are effectively just relocatable code, the ways to infect them,
    such as hijacking functions, are more limited. Fortunately, there are some kernel-specific
    mechanisms that take place during the load time of the ELF kernel object, the
    process of relocating functions within the LKM, that makes infecting them quite
    easy. The entire method and reasons for it working are described in this wonderful
    phrack paper at [http://phrack.org/issues/68/11.html](http://phrack.org/issues/68/11.html),
    but the general idea is simple:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: LKMs是ELF对象。更具体地说，它们是`ET_REL`文件（目标文件）。由于它们实际上只是可重定位代码，因此感染它们的方式（如劫持函数）更有限。幸运的是，在加载ELF内核对象的过程中，会发生一些特定于内核的机制，即在LKM内重定位函数的过程，这使得感染它们变得非常容易。整个方法及其原因在这篇精彩的phrack论文中有详细描述：[http://phrack.org/issues/68/11.html](http://phrack.org/issues/68/11.html)，但总体思路很简单：
- en: Inject or link in the parasite code to the kernel module.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将寄生虫代码注入或链接到内核模块中。
- en: Change the symbol value of `init_module()` to have the same offset/value as
    the evil replacement function.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`init_module()`的符号值，使其具有与恶意替换函数相同的偏移/值。
- en: This is the method used most ubiquitously by attackers on modern Linux systems
    (2.6 to 3.x kernels). There is another method that has not been specifically described
    anywhere else, and I will share it briefly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是攻击者在现代Linux系统（2.6到3.x内核）上最常用的方法。还有另一种方法，其他地方没有具体描述，我会简要分享一下。
- en: Method 2 for infecting LKM files (function hijacking)
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法2感染LKM文件（函数劫持）
- en: LKM files are relocatable code, as previously mentioned, and are therefore quite
    easy to add code to since the parasite can be written in C and then compiled as
    relocatable before linking. After linking the new parasite code, which presumably
    contains a new function (or several functions), the attacker can simply hijack
    any function within the LKM using function trampolines, as described early in
    this chapter. So, the attacker replaces the first several bytes of the target
    function with a jump to the new function. The new function then memcpy's the original
    bytes to the old function before invoking it, and memcpy's the trampoline back
    in place for the next time the hook is to be called.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: LKM文件是可重定位代码，如前所述，因此非常容易添加代码，因为寄生虫可以用C编写，然后在链接之前编译为可重定位代码。在链接新的寄生虫代码之后，攻击者可以使用函数跳板简单地劫持LKM中的任何函数，就像本章节早期描述的那样。因此，攻击者用新函数替换目标函数的前几个字节。新函数然后将原始字节复制到旧函数中，然后调用它，并将跳板复制回原来的位置，以便下次调用钩子时使用。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On newer systems, the write protect bit must be disabled prior to patching the
    text segment, such as with the `memcpy()` calls that are necessary to implement
    function trampolines.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在较新的系统上，在对文本段进行补丁之前，必须禁用写保护位，例如使用`memcpy()`调用来实现函数跳板。
- en: Detecting infected LKMs
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测感染的LKM
- en: 'The solution to this problem should seem obvious based on the two simple detection
    methods just described. For the symbol hijacking method, you can simply look for
    two symbols that have the same value. In the example shown in the Phrack article,
    the `init_module()` function was hijacked, but the technique should apply to any
    function that the attacker wants to hijack. This is because the kernel handles
    relocations for each one (although I have not tested this theory):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 基于刚刚描述的两种简单检测方法，解决这个问题的方法似乎是显而易见的。对于符号劫持方法，您可以简单地查找具有相同值的两个符号。在Phrack文章中显示的示例中，`init_module()`函数被劫持，但该技术应该适用于攻击者想要劫持的任何函数。这是因为内核为每个函数处理重定位（尽管我尚未测试过这个理论）：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Notice in the preceding symbol output that `init_module` and `evil` have the
    same relative address. This—right here—is an infected LKM as demonstrated in Phrack
    68 #11\. Detecting functions hijacked with trampolines is also quite simple and
    was already described in section 9.6.3, where we discussed detecting trampolines
    in the kernel. Simply apply the same analysis to the functions in a LKM file,
    which can be disassembled with tools such as objdump.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，在前面的符号输出中，`init_module`和`evil`具有相同的相对地址。这就是Phrack 68 #11中演示的感染LKM。检测使用跳板劫持的函数也非常简单，并且已经在第9.6.3节中描述过，在那里我们讨论了在内核中检测跳板的方法。只需将相同的分析应用于LKM文件中的函数，可以使用诸如objdump之类的工具对其进行反汇编。'
- en: Notes on /dev/kmem and /dev/mem
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于/dev/kmem和/dev/mem的注意事项
- en: 'In the good old days, hackers were able to modify the kernel using the /dev/kmem
    device file. This file, which gave programmers a raw portal to the kernel memory,
    was eventually subject to various security patches and removed from many distributions.
    However, some distros still have it available to read from, which can be a powerful
    tool for detecting kernel malware, but it is not necessary as long as /proc/kcore
    is available. Some of the best work ever written on patching the Linux kernel
    was conceived by Silvio Cesare, which can be seen in his early writings from 1998
    and can be found on vxheaven or on this link:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，黑客可以使用/dev/kmem设备文件修改内核。这个文件为程序员提供了一个对内核内存的原始入口，最终受到各种安全补丁的影响，并从许多发行版中删除。但是，一些发行版仍然可以从中读取，这可以成为检测内核恶意软件的强大工具，但只要/proc/kcore可用即可。有关修补Linux内核的最佳工作之一是由Silvio
    Cesare构思的，可以在他1998年的早期著作中看到，并且可以在vxheaven或此链接中找到：
- en: '*Runtime kernel kmem patching*: [http://althing.cs.dartmouth.edu/local/vsc07.html](http://althing.cs.dartmouth.edu/local/vsc07.html)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运行时内核kmem补丁*：[http://althing.cs.dartmouth.edu/local/vsc07.html](http://althing.cs.dartmouth.edu/local/vsc07.html)'
- en: /dev/mem
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: /dev/mem
- en: There have been a number of kernel rootkits that used /dev/mem, namely phalanx
    and phalanx2, written by Rebel. This device has also undergone a number of security
    patches. Currently, it is present on all systems for backwards compatibility,
    but only the first 1 MB of memory is accessible, primarily for legacy tools used
    by X Windows.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些内核rootkit使用了/dev/mem，即由Rebel编写的phalanx和phalanx2。这个设备也经历了一些安全补丁。目前，它在所有系统上都存在以实现向后兼容性，但只有前1MB的内存是可访问的，主要用于X
    Windows使用的传统工具。
- en: FreeBSD /dev/kmem
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FreeBSD /dev/kmem
- en: On some OSes such as FreeBSD, the /dev/kmem device is still available and is
    writable by default. There is even an API specifically designed for accessing
    it, and there's a book called *Writing BSD rootkits* that demonstrates its abilities.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些操作系统（如FreeBSD）中，/dev/kmem设备仍然可用，并且默认情况下是可写的。甚至还有一个专门设计用于访问它的API，还有一本名为*Writing
    BSD rootkits*的书展示了它的能力。
- en: K-ecfs – kernel ECFS
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: K-ecfs – 内核ECFS
- en: In the previous chapter, we discussed the **ECFS** (short for **Extended Core
    File Snapshot**) technology. It is worth mentioning near the end of this chapter
    that I have worked out some code for a kernel-ecfs, which merges vmlinux and `/proc/kcore`
    into a kernel-ecfs file. The result is essentially a file similar to /proc/kcore,
    but one that also has section headers and symbols. In this way, an analyst can
    easily access any part of the kernel, LKMs, and kernel memory (such as the "vmalloc'd"
    memory). This code will eventually become publicly available.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了**ECFS**（**扩展核心文件快照**）技术。值得一提的是，在本章末尾，我已经为kernel-ecfs编写了一些代码，将vmlinux和`/proc/kcore`合并到一个kernel-ecfs文件中。结果实质上是一个类似于/proc/kcore的文件，但它还具有段头和符号。通过这种方式，分析人员可以轻松访问内核、LKMs和内核内存（如“vmalloc'd”内存）的任何部分。这些代码最终将公开可用。
- en: A sneak peek of the kernel-ecfs file
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核-ecfs文件的一瞥
- en: 'Here, we are demonstrating how `/proc/kcore` has been snapshotted into a file
    called `kcore.img` and given a set of ELF section headers:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了如何将`/proc/kcore`快照到一个名为`kcore.img`的文件中，并给出了一组ELF段头：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Kernel hacking goodies
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核黑客好东西
- en: The Linux kernel is a vast topic with regards to forensic analysis and reverse
    engineering. There are many exciting ways to go about instrumenting the kernel
    for purposes of hacking, reversing, and debugging, and Linux offers its users
    many entry points into these areas. I have discussed some files and APIs that
    are useful throughout this chapter, but I will also give a small, condensed list
    of things that may be of help in your research.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核是关于取证分析和逆向工程的广泛主题。有许多令人兴奋的方法可以用于对内核进行仪器化，以进行黑客攻击、逆向和调试，Linux为用户提供了许多进入这些领域的入口。我在本章中讨论了一些在研究中有用的文件和API，但我也将列出一些可能对您的研究有帮助的小而简洁的清单。
- en: General reverse engineering and debugging
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般逆向工程和调试
- en: '`/proc/kcore`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc/kcore`'
- en: '`/proc/kallsyms`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc/kallsyms`'
- en: '`/boot/System.map`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/boot/System.map`'
- en: '`/dev/mem` (deprecated)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev/mem`（已弃用）'
- en: '`/dev/kmem` (deprecated)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev/kmem`（已弃用）'
- en: GNU debugger (used with kcore)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU调试器（与kcore一起使用）
- en: Advanced kernel hacking/debugging interfaces
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级内核黑客/调试接口
- en: Kprobes
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kprobes
- en: Ftrace
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ftrace
- en: Papers mentioned in this chapter
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本章提到的论文
- en: 'Kprobe instrumentation: [http://phrack.org/issues/67/6.html](http://phrack.org/issues/67/6.html)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kprobe仪器：[http://phrack.org/issues/67/6.html](http://phrack.org/issues/67/6.html)
- en: '*Runtime kernel* *kmem patching*: [http://althing.cs.dartmouth.edu/local/vsc07.html](http://althing.cs.dartmouth.edu/local/vsc07.html)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运行时内核* *kmem修补*：[http://althing.cs.dartmouth.edu/local/vsc07.html](http://althing.cs.dartmouth.edu/local/vsc07.html)'
- en: 'LKM infection: [http://phrack.org/issues/68/11.html](http://phrack.org/issues/68/11.html)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LKM感染：[http://phrack.org/issues/68/11.html](http://phrack.org/issues/68/11.html)
- en: '*Special sections in Linux binaries*: [https://lwn.net/Articles/531148/](https://lwn.net/Articles/531148/)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux二进制文件中的特殊部分*：[https://lwn.net/Articles/531148/](https://lwn.net/Articles/531148/)'
- en: 'Kernel Voodoo: [http://www.bitlackeys.org/#ikore](http://www.bitlackeys.org/#ikore)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核巫术：[http://www.bitlackeys.org/#ikore](http://www.bitlackeys.org/#ikore)
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this final chapter of this book, we stepped out of userland binaries and
    took a general look at what types of ELF binaries are used in the kernel, and
    how to utilize them with GDB and `/proc/kcore` for memory analysis and forensics
    purposes. We also explained some of the most common Linux kernel rootkit techniques
    that are used and what methods can be applied to detect them. This small chapter
    serves only as a primary resource for understanding the fundamentals, but we just
    listed some excellent resources so that you can continue to expand your knowledge
    in this area.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章中，我们走出了用户空间二进制文件，对内核中使用的ELF二进制文件类型进行了一般性的介绍，以及如何利用它们与GDB和`/proc/kcore`进行内存分析和取证目的。我们还解释了一些常见的Linux内核rootkit技术以及可以应用于检测它们的方法。这个小章节只是作为理解基础知识的主要资源，但我们列出了一些优秀的资源，以便您可以继续扩展您在这个领域的知识。
