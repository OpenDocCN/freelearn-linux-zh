# 第九章：Linux /proc/kcore 分析

到目前为止，我们已经涵盖了与用户空间相关的 Linux 二进制文件和内存。然而，如果我们不花一章的时间来讨论 Linux 内核，这本书就不会完整。这是因为它实际上也是一个 ELF 二进制文件。类似于程序加载到内存中，Linux 内核映像，也被称为**vmlinux**，在启动时加载到内存中。它有一个文本段和一个数据段，上面覆盖着许多与内核非常特定的部分头，这些部分头在用户空间可执行文件中是看不到的。在本章中，我们还将简要介绍 LKM，因为它们也是 ELF 文件。

# Linux 内核取证和 rootkit

学习 Linux 内核映像的布局对于想要成为 Linux 内核取证真正专家的人来说非常重要。攻击者可以修改内核内存以创建非常复杂的内核 rootkit。有很多技术可以在运行时感染内核。列举一些，我们有以下内容：

+   - `sys_call_table`感染

+   - 中断处理程序修补

+   - 函数跳板

+   - 调试寄存器 rootkit

+   - 异常表感染

+   - Kprobe 仪器化

这里列出的技术是最常被内核 rootkit 使用的主要方法，通常以**LKM**（**可加载内核模块**的缩写）的形式感染内核。了解每种技术并知道每种感染在 Linux 内核中的位置以及在内存中的查找位置对于能够检测这种阴险的 Linux 恶意软件类别至关重要。然而，首先让我们退一步，看看我们有什么可以使用的。目前市场上和开源世界中有许多工具可以检测内核 rootkit 并帮助搜索内存感染。我们不会讨论这些。然而，我们将讨论从内核 Voodoo 中提取的方法。内核 Voodoo 是我的一个项目，目前大部分仍然是私有的，只有一些组件被发布给公众，比如**taskverse**。这将在本章后面讨论，并提供下载链接。它使用一些非常实用的技术来检测几乎任何类型的内核感染。该软件基于我原始作品的想法，名为 Kernel Detective，该作品设计于 2009 年，对于好奇的人，仍然可以在我的网站上找到[`www.bitlackeys.org/#kerneldetective`](http://www.bitlackeys.org/#kerneldetective)。

这个软件只适用于旧的 32 位 Linux 内核（2.6.0 到 2.6.32）；64 位支持只完成了部分。然而，这个项目的一些想法是永恒的，我最近提取了它们，并结合了一些新的想法。结果就是 Kernel Voodoo，一个依赖于/proc/kcore 进行高级内存获取和分析的主机入侵检测系统和内核取证软件。在本章中，我们将讨论它使用的一些基本技术，并在某些情况下，我们将使用 GDB 和/proc/kcore 手动进行操作。

# - 标准 vmlinux 没有符号

除非您自己编译了内核，否则您将无法直接访问 vmlinux，它是一个 ELF 可执行文件。相反，您将在`/boot`中有一个压缩的内核，通常命名为`vmlinuz-<kernel_version>`。这个压缩的内核镜像可以被解压缩，但结果是一个没有符号表的内核可执行文件。这对于取证分析师或使用 GDB 进行内核调试来说是一个问题。在这种情况下，大多数人的解决方案是希望他们的 Linux 发行版有一个带有调试符号的内核版本的特殊软件包。如果是这样，他们可以从发行库中下载一个带有符号的内核副本。然而，在许多情况下，这是不可能的，或者由于某种原因不方便。尽管如此，这个问题可以通过我在 2014 年设计和发布的一个自定义实用程序来解决。这个工具叫做**kdress**，因为它装饰了内核符号表。

实际上，它是以 Michael Zalewskis 的一个旧工具 dress 命名的。那个工具会给一个静态可执行文件添加一个符号表。这个名字源于人们运行一个叫做**strip**的程序来从可执行文件中删除符号，因此"装饰"是一个重建符号表的工具的合适名字。我们的工具 kdress 只是从`System.map`文件或`/proc/kallsyms`中获取符号的信息，然后通过为符号表创建一个段头将该信息重建到内核可执行文件中。这个工具可以在我的 GitHub 个人资料中找到[`github.com/elfmaster/kdress`](https://github.com/elfmaster/kdress)。

## 使用 kdress 构建适当的 vmlinux

以下是一个示例，展示了如何使用 kdress 实用程序构建一个可以在 GDB 中加载的 vmlinux 镜像：

```
Usage: ./kdress vmlinuz_input vmlinux_output <system.map>

$ ./kdress /boot/vmlinuz-`uname -r` vmlinux /boot/System.map-`uname -r`
[+] vmlinux has been successfully extracted
[+] vmlinux has been successfully instrumented with a complete ELF symbol table.
```

该实用程序已创建一个名为 vmlinux 的输出文件，其中包含完全重建的符号表。例如，如果我们想要在内核中定位`sys_call_table`，那么我们可以很容易地找到它：

```
$ readelf -s vmlinux | grep sys_call_table
 34214: ffffffff81801460  4368 OBJECT  GLOBAL DEFAULT    4 sys_call_table
 34379: ffffffff8180c5a0  2928 OBJECT  GLOBAL DEFAULT    4 ia32_sys_call_table
```

具有符号的内核镜像对于调试和取证分析都非常重要。几乎所有对 Linux 内核的取证都可以通过 GDB 和`/proc/kcore`完成。

# /proc/kcore 和 GDB 探索

`/proc/kcore`技术是访问内核内存的接口，以 ELF 核心文件的形式方便地使用 GDB 进行导航。

使用 GDB 和`/proc/kcore`是一种无价的技术，可以扩展到熟练分析师的深入取证。以下是一个简短的示例，展示了如何导航`sys_call_table`。

## 导航 sys_call_table 的示例

```
$ sudo gdb -q vmlinux /proc/kcore
Reading symbols from vmlinux...
[New process 1]
Core was generated by `BOOT_IMAGE=/vmlinuz-3.16.0-49-generic root=/dev/mapper/ubuntu--vg-root ro quiet'.
#0  0x0000000000000000 in ?? ()
(gdb) print &sys_call_table
$1 = (<data variable, no debug info> *) 0xffffffff81801460 <sys_call_table>
(gdb) x/gx &sys_call_table
0xffffffff81801460 <sys_call_table>:  0xffffffff811d5260
(gdb) x/5i 0xffffffff811d5260
   0xffffffff811d5260 <sys_read>:  data32 data32 data32 xchg %ax,%ax
   0xffffffff811d5265 <sys_read+5>:  push   %rbp
   0xffffffff811d5266 <sys_read+6>:  mov    %rsp,%rbp
   0xffffffff811d5269 <sys_read+9>:  push   %r14
   0xffffffff811d526b <sys_read+11>:mov    %rdx,%r14
```

在这个例子中，我们可以查看`sys_call_table[0]`中保存的第一个指针，并确定它包含了系统调用函数`sys_read`的地址。然后我们可以查看该系统调用的前五条指令。这是一个例子，说明使用 GDB 和`/proc/kcore`轻松导航内核内存。如果已经安装了钩住`sys_read`的内核 rootkit，并使用了函数 trampolines，那么显示前几条指令将显示跳转或返回到另一个恶意函数。如果您知道要查找什么，使用调试器来检测内核 rootkit 非常有用。Linux 内核的结构细微差别以及可能被感染的方式是高级主题，对许多人来说似乎是神秘的。一章不足以完全揭开所有这些，但我们将涵盖可能用于感染内核和检测感染的方法。在接下来的章节中，我将从一般的角度讨论一些用于感染内核的方法，并给出一些例子。

### 注意

只使用 GDB 和`/proc/kcore`，就可以检测到本章中提到的每一种感染。像内核 Voodoo 这样的工具非常好用方便，但并不是绝对必要的，可以检测到与正常运行的内核有所不同。

# 直接 sys_call_table 修改

传统的内核 rootkit，如**adore**和**phalanx**，通过覆盖`sys_call_table`中的指针，使它们指向替代函数，然后根据需要调用原始系统调用来工作。这是通过 LKM 或通过`/dev/kmem`或`/dev/mem`修改内核的程序来实现的。在今天的 Linux 系统中，出于安全原因，这些可写的内存窗口已被禁用，或者根据内核的配置，除了读操作外，不再能够进行任何操作。还有其他方法试图防止这种感染，例如将`sys_call_table`标记为`const`，以便它存储在文本段的`.rodata`部分。这可以通过将相应的**PTE**（Page Table Entry 的缩写）标记为可写，或者通过禁用`cr0`寄存器中的写保护位来绕过。因此，这种类型的感染是一种非常可靠的制作 rootkit 的方法，但也非常容易被检测到。

## 检测`sys_call_table`的修改

要检测`sys_call_table`的修改，可以查看`System.map`文件或`/proc/kallsyms`，以查看每个系统调用的内存地址。例如，如果我们想要检测`sys_write`系统调用是否被感染，我们需要了解`sys_write`的合法地址及其在`sys_call_table`中的索引，然后使用 GDB 和`/proc/kcore`验证正确的地址是否实际存储在内存中。

### 验证系统调用完整性的示例

```
$ sudo grep sys_write /proc/kallsyms
ffffffff811d5310 T sys_write
$ grep _write /usr/include/x86_64-linux-gnu/asm/unistd_64.h
#define __NR_write 1
$ sudo gdb -q vmlinux /proc/kcore
(gdb) x/gx &sys_call_table+1
0xffffffff81801464 <sys_call_table+4>:  0x811d5310ffffffff
```

请记住，在 x86 架构上，数字是以小端存储的。`sys_call_table[1]`处的值等同于在`/proc/kallsyms`中查找的正确的`sys_write`地址。因此，我们已成功验证了`sys_write`的`sys_call_table`条目没有被篡改。

## 内核函数跳板

这种技术最初是由 Silvio Cesare 于 1998 年引入的。其想法是能够修改系统调用而无需触及`sys_call_table`，但事实上，这种技术允许钩住内核中的任何函数。因此，它非常强大。自 1998 年以来，很多事情已经发生了；内核的文本段现在不能再被修改，除非禁用`cr0`中的写保护位或修改 PTE。然而，主要问题在于，大多数现代内核使用 SMP，而内核函数跳板是不安全的，因为它们在每次调用补丁函数时使用非原子操作，比如`memcpy()`。事实证明，还有方法可以规避这个问题，使用一种我在这里不讨论的技术。真正的问题在于，内核函数跳板实际上仍在使用，因此理解它们仍然非常重要。

### 注意

修改调用原始函数的单个调用指令，使其调用替代函数，被认为是一种更安全的技术。这种方法可以用作替代函数跳板，但可能很难找到每个单独的调用，而且这通常会因内核而异。因此，这种方法不太具有可移植性。

## 函数跳板的示例

想象一下，你想劫持系统调用`SYS_write`，并且不想担心直接修改`sys_call_table`，因为这很容易被检测到。这可以通过覆盖`sys_write`代码的前 7 个字节，使用包含跳转到另一个函数的代码的存根来实现。

### 在 32 位内核上劫持 sys_write 的示例代码

```
#define SYSCALL_NR __NR_write

static char syscall_code[7];
static char new_syscall_code[7] =
"\x68\x00\x00\x00\x00\xc3"; // push $addr; ret

// our new version of sys_write
int new_syscall(long fd, void *buf, size_t len)
{
        printk(KERN_INFO "I am the evil sys_write!\n");

        // Replace the original code back into the first 6
        // bytes of sys_write (remove trampoline)

        memcpy(
       sys_call_table[SYSCALL_NR], syscall_code,
                sizeof(syscall_code)
        );

        // now we invoke the original system call with no trampoline
        ((int (*)(fd, buf, len))sys_call_table[SYSCALL_NR])(fd, buf, len);

        // Copy the trampoline back in place!
        memcpy(
                sys_call_table[SYSCALL_NR], new_syscall_code,
                sizeof(syscall_code)
        );
}

int init_module(void)
{
        // patch trampoline code with address of new sys_write
        *(long *)&new_syscall_code[1] = (long)new_syscall;

        // insert trampoline code into sys_write
        memcpy(
                syscall_code, sys_call_table[SYSCALL_NR],
                sizeof(syscall_code)
        );
        memcpy(
                sys_call_table[SYSCALL_NR], new_syscall_code,
                sizeof(syscall_code)
        );
        return 0;
}

void cleanup_module(void)
{
        // remove infection (trampoline)
        memcpy(
                sys_call_table[SYSCALL_NR], syscall_code,
                sizeof(syscall_code)
        );
}
```

这个代码示例用`push; ret`存根替换了`sys_write`的前 6 个字节，它将新的`sys_write`函数的地址推送到堆栈上并返回到它。然后新的`sys_write`函数可以做任何诡秘的事情，尽管在这个示例中我们只是向内核日志缓冲区打印一条消息。在完成了诡秘的事情之后，它必须删除跳板代码，以便调用未篡改的 sys_write，并最后将跳板代码放回原处。

## 检测函数跳板

通常，函数跳板将覆盖它们钩住的函数的过程前言的一部分（前 5 到 7 个字节）。因此，要检测内核函数或系统调用中的函数跳板，应检查前 5 到 7 个字节，并寻找跳转或返回到另一个地址的代码。这样的代码可以有各种形式。以下是一些示例。

### 使用 ret 指令的示例

将目标地址推送到堆栈上并返回到它。当使用 32 位目标地址时，这需要 6 个字节的机器代码：

```
push $address
ret
```

### 使用间接 jmp 的示例

将目标地址移入寄存器以进行间接跳转。当使用 32 位目标地址时，这需要 7 个字节的代码：

```
movl $addr, %eax
jmp *%eax
```

### 使用相对 jmp 的示例

计算偏移量并执行相对跳转。当使用 32 位偏移量时，这需要 5 个字节的代码：

```
jmp offset
```

例如，如果我们想要验证`sys_write`系统调用是否已经被函数跳板钩住，我们可以简单地检查它的代码，看看过程前言是否还在原位：

```
$ sudo grep sys_write /proc/kallsyms
0xffffffff811d5310
$ sudo gdb -q vmlinux /proc/kcore
Reading symbols from vmlinux...
[New process 1]
Core was generated by `BOOT_IMAGE=/vmlinuz-3.16.0-49-generic root=/dev/mapper/ubuntu--vg-root ro quiet'.
#0  0x0000000000000000 in ?? ()
(gdb) x/3i 0xffffffff811d5310
   0xffffffff811d5310 <sys_write>:  data32 data32 data32 xchg %ax,%ax
   0xffffffff811d5315 <sys_write+5>:  push   %rbp
   0xffffffff811d5316 <sys_write+6>:  mov    %rsp,%rbp
```

前 5 个字节实际上用作 NOP 指令以进行对齐（或可能是 ftrace 探针的空间）。内核使用某些字节序列（0x66、0x66、0x66、0x66 和 0x90）。过程前言代码跟随最初的 5 个 NOP 字节，并且完全完整。因此，这验证了`sys_write`系统调用没有被任何函数跳板钩住。

### 中断处理程序修补- int 0x80, syscall

感染内核的一个经典方法是将一个虚假的系统调用表插入内核内存，并修改负责调用系统调用的顶半部中断处理程序。在 x86 架构中，中断 0x80 已经被弃用，并已被用特殊的`syscall/sysenter`指令替换，用于调用系统调用。syscall/sysenter 和`int 0x80`最终都会调用同一个函数，名为`system_call()`，它又调用`sys_call_table`中选择的系统调用。

```
(gdb) x/i system_call_fastpath+19
0xffffffff8176ea86 <system_call_fastpath+19>:  
callq  *-0x7e7feba0(,%rax,8)

```

在 x86_64 上，在`system_call()`中的 swapgs 之后发生前面的 call 指令。以下是`entry.S`中代码的样子：

```
call *sys_call_table(,%rax,8)

```

`(r/e)ax`寄存器包含被`sizeof(long)`乘以以获取正确系统调用指针的索引的系统调用号。很容易想象，攻击者可以`kmalloc()`一个虚假的系统调用表到内存中（其中包含一些指向恶意函数的修改），然后修补调用指令，以便使用虚假的系统调用表。这种技术实际上非常隐秘，因为它对原始的`sys_call_table`没有任何修改。然而，对于训练有素的人来说，这种技术仍然很容易检测到。

## 检测中断处理程序的修补

要检测`system_call()`例程是否已经被修补为调用虚假的`sys_call_table`，只需使用 GDB 和`/proc/kcore`反汇编代码，然后找出调用偏移是否指向`sys_call_table`的地址。正确的`sys_call_table`地址可以在`System.map`或`/proc/kallsyms`中找到。

# Kprobe rootkits

这种特定类型的内核 rootkit 最初是在 2010 年我写的一篇 Phrack 论文中详细构想和描述的。该论文可以在[`phrack.org/issues/67/6.html`](http://phrack.org/issues/67/6.html)找到。

这种类型的内核 rootkit 是比较奇特的品牌之一，它使用 Linux 内核的 Kprobe 调试钩子在 rootkit 试图修改的目标内核函数上设置断点。这种特定的技术有其局限性，但它可以非常强大和隐蔽。然而，就像其他任何技术一样，如果分析人员知道要寻找什么，那么使用 kprobes 的内核 rootkit 就可以很容易地被检测到。

## 检测 kprobe rootkit

通过分析内存来检测 kprobes 的存在非常容易。当设置常规 kprobe 时，会在函数的入口点（参见 jprobes）或任意指令上设置断点。通过扫描整个代码段寻找断点来检测是非常容易的，因为除了为了 kprobes 而设置断点外，没有其他原因应该在内核代码中设置断点。对于检测优化过的 kprobes，会使用 jmp 指令而不是断点（`int3`）指令。当 jmp 放置在函数的第一个字节上时，这是最容易检测的，因为那显然是不合适的。最后，在`/sys/kernel/debug/kprobes/list`中有一个活跃的 kprobes 简单列表，其中实际包含正在使用的 kprobes 的列表。然而，任何 rootkit，包括我在 phrack 中演示的 rootkit，都会隐藏其 kprobes，所以不要依赖它。一个好的 rootkit 还会阻止在`/sys/kernel/debug/kprobes/enabled`中禁用 kprobes。

# 调试寄存器 rootkit – DRR

这种类型的内核 rootkit 使用 Intel Debug 寄存器来劫持控制流。 *halfdead*在这种技术上写了一篇很棒的 Phrack 论文。它可以在这里找到：

[`phrack.org/issues/65/8.html`](http://phrack.org/issues/65/8.html)。

这种技术通常被誉为超级隐蔽，因为它不需要修改`sys_call_table`。然而，同样地，也有方法来检测这种类型的感染。

## 检测 DRR

在许多 rootkit 实现中，`sys_call_table`和其他常见的感染点确实没有被修改，但`int1`处理程序没有。对`do_debug`函数的调用指令被修改为调用另一个`do_debug`函数，如前面链接的 phrack 论文所示。因此，检测这种类型的 rootkit 通常就像反汇编 int1 处理程序并查看`call do_debug`指令的偏移一样简单，如下所示：

```
target_address = address_of_call + offset + 5
```

如果`target_address`的值与`System.map`或`/proc/kallsyms`中找到的`do_debug`地址相同，则意味着 int1 处理程序未被修改，被视为干净的。

# VFS 层 rootkit

感染内核的另一个经典而强大的方法是通过感染内核的 VFS 层。这种技术非常出色和隐蔽，因为它在技术上修改了内存中的数据段而不是文本段，而后者更容易检测到不一致。VFS 层是非常面向对象的，包含各种带有函数指针的结构。这些函数指针是文件系统操作，如打开、读取、写入、读取目录等。如果攻击者可以修改这些函数指针，那么他们可以以任何他们认为合适的方式控制这些操作。

## 检测 VFS 层 rootkit

可能有几种技术可以用来检测这种类型的感染。然而，一般的想法是验证函数指针地址，并确认它们指向预期的函数。在大多数情况下，这些应该指向内核中的函数，而不是存在于 LKMs 中的函数。检测的一个快速方法是验证指针是否在内核的文本段范围内。

### 验证 VFS 函数指针的一个例子

```
if ((long)vfs_ops->readdir >= KERNEL_MIN_ADDR &&
    (long)vfs_ops->readdir < KERNEL_MAX_ADDR)
        pointer_is_valid = 1;
else
        pointer_is_valid = 0;
```

# 其他内核感染技术

黑客可以使用其他技术来感染 Linux 内核（我们在本章中没有讨论这些技术），比如劫持 Linux 页面错误处理程序（[`phrack.org/issues/61/7.html`](http://phrack.org/issues/61/7.html)）。许多这些技术可以通过查找对文本段的修改来检测，这是我们将在接下来的章节中进一步研究的检测方法。

# vmlinux 和.altinstructions 补丁

在我看来，检测 rootkit 最有效的方法可以通过验证内核内存中的代码完整性来概括，换句话说，就是将内核内存中的代码与预期的代码进行比较。但是我们可以将内核内存代码与什么进行比较呢？嗯，为什么不是 vmlinux 呢？这是我最初在 2008 年探索的一种方法。知道 ELF 可执行文件的文本段从磁盘到内存不会改变，除非它是一些奇怪的自修改二进制文件，而内核不是……或者它是吗？我很快遇到了麻烦，并发现内核内存文本段和 vmlinux 文本段之间存在各种代码差异。这一开始让我感到困惑，因为在这些测试期间我没有安装任何内核 rootkit。然而，在检查了 vmlinux 中的一些 ELF 部分后，我很快发现了一些引起我的注意的地方：

```
$ readelf -S vmlinux | grep alt
  [23] .altinstructions  PROGBITS         ffffffff81e64528  01264528
  [24] .altinstr_replace PROGBITS         ffffffff81e6a480  0126a480
```

Linux 内核二进制文件中有几个部分包含了替代指令。事实证明，Linux 内核开发人员有一个聪明的想法：如果 Linux 内核可以智能地在运行时修补自己的代码段，根据检测到的特定 CPU 改变某些指令以进行“内存屏障”，这将是一个好主意，因为更少的标准内核需要为所有不同类型的 CPU 创建。不幸的是，对于想要检测内核代码段中的任何恶意更改的安全研究人员来说，这些替代指令首先需要被理解和应用。

## .altinstructions 和 .altinstr_replace

有两个部分包含了大部分需要知道的信息，即内核中哪些指令在运行时被修补。现在有一篇很好的文章解释了这些部分，这在我早期研究这一内核领域时是不可用的。

[`lwn.net/Articles/531148/`](https://lwn.net/Articles/531148/)

然而，总体思路是，`.altinstructions` 部分包含一个 `struct alt_instr` 结构的数组。每个结构代表一个替代指令记录，给出了应该用于修补原始指令的新指令的位置。`.altinstr_replace` 部分包含了实际的替代指令，这些指令由 `alt_instr->repl_offset` 成员引用。

## 来自 arch/x86/include/asm/alternative.h

```
struct alt_instr {
   s32 instr_offset;      /* original instruction */
   s32 repl_offset;       /* offset to replacement instruction */
   u16 cpuid;             /* cpuid bit set for replacement */
   u8  instrlen;          /* length of original instruction */
   u8  replacementlen;    /* length of new instruction, <= instrlen */
};
```

在旧内核上，前两个成员给出了旧指令和新指令的绝对地址，但在新内核上，使用了相对偏移量。

## 使用 textify 来验证内核代码完整性

多年来，我设计了几个工具，用于检测 Linux 内核代码段的完整性。这种检测技术显然只对修改文本段的内核 rootkit 有效，而大多数内核 rootkit 在某种程度上都会这样做。但是，也有一些例外，例如仅依赖于修改 VFS 层的 rootkit，它位于数据段中，不会通过验证文本段的完整性来检测到。最近，我编写的工具（内核 Voodoo 软件套件的一部分）名为 textify，它基本上比较了从`/proc/kcore`中获取的内核内存的文本段与 vmlinux 中的文本段。它解析`.altinstructions`和其他各种部分，例如`.parainstructions`，以了解合法修补的代码指令的位置。通过这种方式，不会出现错误的阳性。尽管 textify 目前不向公众开放，但一般思路已经解释过。因此，任何希望尝试使其工作的人都可以重新实现它，尽管这需要一些繁琐的编码过程。

## 使用 textify 检查 sys_call_table 的示例

```
# ./textify vmlinux /proc/kcore -s sys_call_table
kernel Detective 2014 - Bitlackeys.org
[+] Analyzing kernel code/data for symbol sys_call_table in range [0xffffffff81801460 - 0xffffffff81802570]
[+] No code modifications found for object named 'sys_call_table'

# ./textify vmlinux /proc/kcore -a
kernel Detective 2014 - Bitlackeys.org
[+] Analyzing kernel code of entire text segment. [0xffffffff81000000 - 0xffffffff81773da4]
[+] No code modifications have been detected within kernel memory
```

在上面的示例中，我们首先检查`sys_call_table`是否已被修改。在现代 Linux 系统上，`sys_call_table`被标记为只读，因此存储在文本段中，这就是为什么我们可以使用 textify 来验证其完整性。在下一个命令中，我们使用`-a`开关运行 textify，该开关扫描整个文本段中的每个字节，以查找非法修改。我们本可以直接运行`-a`，因为`sys_call_table`包含在`-a`中，但有时，按符号名称扫描东西也很好。

# 使用 taskverse 查看隐藏进程

在 Linux 内核中，有几种修改内核的方法，以便进程隐藏可以工作。由于本章不是要对所有内核 rootkit 进行详细解释，我只会介绍最常用的方法，然后提出一种检测方法，这种方法已经在我 2014 年发布的 taskverse 程序中实现。

在 Linux 中，进程 ID 存储为`/proc`文件系统中的目录；每个目录包含有关进程的大量信息。`/bin/ps`程序在`/proc`中进行目录列表，以查看系统上当前正在运行的 pid。Linux 中的目录列表（例如使用`ps`或`ls`）使用`sys_getdents64`系统调用和`filldir64`内核函数。许多内核 rootkit 劫持其中一个这些函数（取决于内核版本），然后插入一些代码，跳过包含隐藏进程的`d_name`的目录条目。因此，`/bin/ps`程序无法找到内核 rootkit 认为在目录列表中跳过的进程。

## Taskverse 技术

taskverse 程序是内核 Voodoo 软件包的一部分，但我发布了一个更基本的免费版本，只使用一种技术来检测隐藏进程；但是，这种技术仍然非常有用。正如我们刚才讨论的，rootkit 通常会隐藏`/proc`中的 pid 目录，以便`sys_getdents64`和`filldir64`无法看到它们。用于查看这些进程的最直接和明显的方法是完全绕过/proc 目录，并在内核内存中的任务列表中查看由`struct task_struct`条目的链接列表表示的每个进程描述符。可以通过查找`init_task`符号找到列表指针的头部。有一定技能的程序员可以利用这些知识打开`/proc/kcore`并遍历任务列表。此代码的详细信息可以在项目本身中查看，该项目可以在我的 GitHub 个人资料上找到[`github.com/elfmaster/taskverse`](https://github.com/elfmaster/taskverse)。

# 感染的 LKMs-内核驱动程序

到目前为止，我们已经涵盖了内存中各种类型的内核 rootkit 感染，但我认为这一章节需要专门解释攻击者如何感染内核驱动程序，以及如何检测这些感染。

## 方法 1 感染 LKM 文件的方法-符号劫持

LKMs 是 ELF 对象。更具体地说，它们是`ET_REL`文件（目标文件）。由于它们实际上只是可重定位代码，因此感染它们的方式（如劫持函数）更有限。幸运的是，在加载 ELF 内核对象的过程中，会发生一些特定于内核的机制，即在 LKM 内重定位函数的过程，这使得感染它们变得非常容易。整个方法及其原因在这篇精彩的 phrack 论文中有详细描述：[`phrack.org/issues/68/11.html`](http://phrack.org/issues/68/11.html)，但总体思路很简单：

1.  将寄生虫代码注入或链接到内核模块中。

1.  更改`init_module()`的符号值，使其具有与恶意替换函数相同的偏移/值。

这是攻击者在现代 Linux 系统（2.6 到 3.x 内核）上最常用的方法。还有另一种方法，其他地方没有具体描述，我会简要分享一下。

## 方法 2 感染 LKM 文件（函数劫持）

LKM 文件是可重定位代码，如前所述，因此非常容易添加代码，因为寄生虫可以用 C 编写，然后在链接之前编译为可重定位代码。在链接新的寄生虫代码之后，攻击者可以使用函数跳板简单地劫持 LKM 中的任何函数，就像本章节早期描述的那样。因此，攻击者用新函数替换目标函数的前几个字节。新函数然后将原始字节复制到旧函数中，然后调用它，并将跳板复制回原来的位置，以便下次调用钩子时使用。

### 注意

在较新的系统上，在对文本段进行补丁之前，必须禁用写保护位，例如使用`memcpy()`调用来实现函数跳板。

## 检测感染的 LKM

基于刚刚描述的两种简单检测方法，解决这个问题的方法似乎是显而易见的。对于符号劫持方法，您可以简单地查找具有相同值的两个符号。在 Phrack 文章中显示的示例中，`init_module()`函数被劫持，但该技术应该适用于攻击者想要劫持的任何函数。这是因为内核为每个函数处理重定位（尽管我尚未测试过这个理论）：

```
$ objdump -t infected.lkm
00000040 g     F .text  0000001b evil
...
00000040 g     F .text  0000001b init_module
```

请注意，在前面的符号输出中，`init_module`和`evil`具有相同的相对地址。这就是 Phrack 68 #11 中演示的感染 LKM。检测使用跳板劫持的函数也非常简单，并且已经在第 9.6.3 节中描述过，在那里我们讨论了在内核中检测跳板的方法。只需将相同的分析应用于 LKM 文件中的函数，可以使用诸如 objdump 之类的工具对其进行反汇编。

# 关于/dev/kmem 和/dev/mem 的注意事项

在过去，黑客可以使用/dev/kmem 设备文件修改内核。这个文件为程序员提供了一个对内核内存的原始入口，最终受到各种安全补丁的影响，并从许多发行版中删除。但是，一些发行版仍然可以从中读取，这可以成为检测内核恶意软件的强大工具，但只要/proc/kcore 可用即可。有关修补 Linux 内核的最佳工作之一是由 Silvio Cesare 构思的，可以在他 1998 年的早期著作中看到，并且可以在 vxheaven 或此链接中找到：

+   *运行时内核 kmem 补丁*：[`althing.cs.dartmouth.edu/local/vsc07.html`](http://althing.cs.dartmouth.edu/local/vsc07.html)

# /dev/mem

有一些内核 rootkit 使用了/dev/mem，即由 Rebel 编写的 phalanx 和 phalanx2。这个设备也经历了一些安全补丁。目前，它在所有系统上都存在以实现向后兼容性，但只有前 1MB 的内存是可访问的，主要用于 X Windows 使用的传统工具。

## FreeBSD /dev/kmem

在一些操作系统（如 FreeBSD）中，/dev/kmem 设备仍然可用，并且默认情况下是可写的。甚至还有一个专门设计用于访问它的 API，还有一本名为*Writing BSD rootkits*的书展示了它的能力。

# K-ecfs – 内核 ECFS

在上一章中，我们讨论了**ECFS**（**扩展核心文件快照**）技术。值得一提的是，在本章末尾，我已经为 kernel-ecfs 编写了一些代码，将 vmlinux 和`/proc/kcore`合并到一个 kernel-ecfs 文件中。结果实质上是一个类似于/proc/kcore 的文件，但它还具有段头和符号。通过这种方式，分析人员可以轻松访问内核、LKMs 和内核内存（如“vmalloc'd”内存）的任何部分。这些代码最终将公开可用。

## 内核-ecfs 文件的一瞥

在这里，我们展示了如何将`/proc/kcore`快照到一个名为`kcore.img`的文件中，并给出了一组 ELF 段头：

```
# ./kcore_ecfs kcore.img

# readelf -S kcore.img
here are 6 section headers, starting at offset 0x60404afc:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .note             NULL             0000000000000000  000000e8
       0000000000001a14  000000000000000c           0    48     0
  [ 2] .kernel           PROGBITS         ffffffff81000000  01001afc
       0000000001403000  0000000000000000 WAX       0     0     0
  [ 3] .bss              PROGBITS         ffffffff81e77000  00000000
       0000000000169000  0000000000000000  WA       0     0     0
  [ 4] .modules          PROGBITS         ffffffffa0000000  01404afc
       000000005f000000  0000000000000000 WAX       0     0     0
  [ 5] .shstrtab         STRTAB           0000000000000000  60404c7c
       0000000000000026  0000000000000000           0     0     0

# readelf -s kcore.img | grep sys_call_table
 34214: ffffffff81801460  4368 OBJECT 4 sys_call_table
 34379: ffffffff8180c5a0  2928 OBJECT 4 ia32_sys_call_table
```

# 内核黑客好东西

Linux 内核是关于取证分析和逆向工程的广泛主题。有许多令人兴奋的方法可以用于对内核进行仪器化，以进行黑客攻击、逆向和调试，Linux 为用户提供了许多进入这些领域的入口。我在本章中讨论了一些在研究中有用的文件和 API，但我也将列出一些可能对您的研究有帮助的小而简洁的清单。

## 一般逆向工程和调试

+   `/proc/kcore`

+   `/proc/kallsyms`

+   `/boot/System.map`

+   `/dev/mem`（已弃用）

+   `/dev/kmem`（已弃用）

+   GNU 调试器（与 kcore 一起使用）

## 高级内核黑客/调试接口

+   Kprobes

+   Ftrace

## 本章提到的论文

+   Kprobe 仪器：[`phrack.org/issues/67/6.html`](http://phrack.org/issues/67/6.html)

+   *运行时内核* *kmem 修补*：[`althing.cs.dartmouth.edu/local/vsc07.html`](http://althing.cs.dartmouth.edu/local/vsc07.html)

+   LKM 感染：[`phrack.org/issues/68/11.html`](http://phrack.org/issues/68/11.html)

+   *Linux 二进制文件中的特殊部分*：[`lwn.net/Articles/531148/`](https://lwn.net/Articles/531148/)

+   内核巫术：[`www.bitlackeys.org/#ikore`](http://www.bitlackeys.org/#ikore)

# 总结

在本书的最后一章中，我们走出了用户空间二进制文件，对内核中使用的 ELF 二进制文件类型进行了一般性的介绍，以及如何利用它们与 GDB 和`/proc/kcore`进行内存分析和取证目的。我们还解释了一些常见的 Linux 内核 rootkit 技术以及可以应用于检测它们的方法。这个小章节只是作为理解基础知识的主要资源，但我们列出了一些优秀的资源，以便您可以继续扩展您在这个领域的知识。
