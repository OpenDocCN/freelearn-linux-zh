- en: A Peek Inside the Kernel
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解内核
- en: Simple operating systems (such as MS-DOS) always execute in a single CPU mode,
    but Unix-like operating systems use dual modes to effectively implement timesharing
    and resource allocation and protection. At any time in Linux, the CPU is either
    operating in a trusted **kernel mode** (where we can do everything we wish) or
    in a restricted **user mode** (where some operations are not allowed). All user
    processes execute in user mode, whereas the core kernel itself and most device
    drivers (except ones implemented in user space) run in kernel mode so that they
    have unrestricted access to the entire processor instruction set and to the full
    memory and I/O space.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的操作系统（如MS-DOS）总是在单CPU模式下执行，但类Unix操作系统使用双模式来有效地实现时间共享和资源分配和保护。在Linux中，CPU在任何时候都处于受信任的**内核模式**（我们可以做任何我们想做的事情）或受限的**用户模式**（某些操作不允许）。所有用户进程都在用户模式下执行，而核心内核本身和大多数设备驱动程序（除了在用户空间实现的驱动程序）都在内核模式下运行，因此它们可以无限制地访问整个处理器指令集以及完整的内存和I/O空间。
- en: When a user mode process needs to get access to peripherals, it cannot do it
    by itself, but it has to channel requests through device drivers or other kernel
    mode code via **system calls**, which play a major role in controlling process
    activities and managing data exchange. In this chapter, we will not see system
    calls yet (they will be introduced in [Chapter 3](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml),
    *Working with Char Drivers*), but we will start programming into the kernel by
    directly adding new code into its sources or by using kernel modules, which is
    another, more versatile, manner to add code to the kernel.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户模式进程需要访问外围设备时，它不能自己完成，而必须通过设备驱动程序或其他内核模式代码通过**系统调用**来传递请求，系统调用在控制进程活动和管理数据交换中起着重要作用。在本章中，我们不会看到系统调用（它们将在[第3章](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml)中介绍），但我们将通过直接向内核源代码添加新代码或使用内核模块来开始在内核中编程，这是另一种更灵活的方式来向内核添加代码。
- en: Once we get started writing kernel code, we must not forget that, while in user
    mode, every resource allocation (the CPU, RAM, and so on) is automatically managed
    by the kernel (which can properly release them when a process dies), in kernel
    mode, we are allowed to monopolize the processor until either we voluntarily relinquish
    the CPU or an interrupt or exception occurs; moreover, every requested resource
    (as the RAM, for instance) is lost if not properly released. That's why it's really
    important to correctly manage the CPU usage and to free whatever resource we request!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始编写内核代码，我们必须不要忘记，当处于用户模式时，每个资源分配（CPU、RAM等）都由内核自动管理（当进程死亡时可以适当释放它们），在内核模式下，我们被允许独占处理器，直到我们自愿放弃CPU或发生中断或异常；此外，如果不适当释放，每个请求的资源（如RAM）都会丢失。这就是为什么正确管理CPU使用和释放我们请求的任何资源非常重要！
- en: 'Now, it''s time to do a first jump into the kernel, so in this chapter, we
    will cover the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候第一次跳入内核了，因此在本章中，我们将涵盖以下示例：
- en: Adding custom code to the sources
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向源代码添加自定义代码
- en: Using kernel messages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内核消息
- en: Working with kernel modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内核模块
- en: Using module parameters
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块参数
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: During this chapter, we need kernel sources we already downloaded in the *Configuring
    and building the kernel* recipe in [Chapter 1](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml), *Installing
    the Development System*, and, of course, we also need our cross-compiler installed,
    as seen in the *Setting up the host machine* recipe in [Chapter 1](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml),
    *Installing the Development System*. The code and other files used in this chapter
    can be downloaded from GitHub at [https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_02](https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_02).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们需要在[第1章](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml)的*配置和构建内核*示例中已经下载的内核源代码，当然，我们还需要安装交叉编译器，就像在[第1章](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml)的*设置主机机器*示例中所示。本章中使用的代码和其他文件可以从GitHub上下载：[https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_02](https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_02)。
- en: Adding custom code to the sources
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向源代码添加自定义代码
- en: As a first step, let's see how we can add some simple code to our kernel sources.
    In this recipe, we'll simply add silly code just to demonstrate how easy it is,
    but further into this book, we're going to add even more complex code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，让我们看看如何向我们的内核源代码中添加一些简单的代码。在这个示例中，我们将简单地添加一些愚蠢的代码，只是为了演示它有多容易，但在本书的后面，我们将添加更复杂的代码。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Since we need to add our code to the Linux sources, let''s go into the directory
    where all sources are located. On my system, I use the `Projects/ldddc/linux/`
    path located in my home directory. Here is what the kernel sources look like:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要将我们的代码添加到Linux源代码中，让我们进入存放所有源代码的目录。在我的系统中，我使用位于我的主目录中的`Projects/ldddc/linux/`路径。以下是内核源代码的样子：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we need to set the environment variables, `ARCH` and `CROSS_COMPILE`,
    as follows in order to be able to cross-compile code for the ESPRESSObin:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要设置环境变量`ARCH`和`CROSS_COMPILE`，如下所示，以便能够为ESPRESSObin进行交叉编译代码：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So, if we try to execute a `make` command as follows, the system should start
    compiling the kernel as usual:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们尝试执行以下`make`命令，系统应该像往常一样开始编译内核：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note that you may avoid exporting preceding variables by just specifying them
    on the following command line:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以通过在以下命令行上指定它们来避免导出前面的变量：
- en: '`$ make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- \`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- \`'
- en: '`Image dtbs modules`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image dtbs modules`'
- en: At this point, kernel sources and the compiling environment are ready.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，内核源代码和编译环境已经准备就绪。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how to do it by following these steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤来做：
- en: 'Since this book talks about device drivers, let''s start by adding our code
    under the `drivers` directory of the Linux sources, and specifically in `drivers/misc`,
    where miscellaneous drivers lie. We should place a file named `dummy-code.c` in `drivers/misc`
    with the following contents:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于本书涉及设备驱动程序，让我们从Linux源代码的`drivers`目录下开始添加我们的代码，具体来说是在`drivers/misc`中，杂项驱动程序所在的地方。我们应该在`drivers/misc`中放置一个名为`dummy-code.c`的文件，内容如下：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our new file, `drivers/misc/dummy-code.c`, will have no effect if we don''t
    properly insert it into the kernel configuration and building system. In order
    to do so, we have to modify the `drivers/misc/Kconfig` and `drivers/misc/Makefile`
    files as follows. The former file must be changed, as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的新文件`drivers/misc/dummy-code.c`如果不正确地插入到内核配置和构建系统中，将不会产生任何效果。为了做到这一点，我们必须修改`drivers/misc/Kconfig`和`drivers/misc/Makefile`文件如下。前者文件必须更改如下：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The modifications for the latter are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 后者的修改如下：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that you can easily add the preceding code and whatever is needed to compile
    it by just using the `patch` command, as follows, in your main directory of Linux
    sources:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以通过在Linux源代码的主目录中使用`patch`命令轻松添加前面的代码以及编译所需的任何内容，如下所示：
- en: '**`$ patch -p1 < add_custom_code.patch`**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**`$ patch -p1 < add_custom_code.patch`**'
- en: 'Well, if we now use the `make menuconfig` command and we navigate through Device
    Drivers to the bottom of the Misc devices menu entries, we should get something
    as shown in the following screenshot:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好吧，如果我们现在使用`make menuconfig`命令，并且我们通过设备驱动程序导航到杂项设备菜单条目的底部，我们应该会得到以下截图所示的内容：
- en: '![](img/01c65282-ef07-458f-bc60-be630fb3a9e1.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/01c65282-ef07-458f-bc60-be630fb3a9e1.png)
- en: In the preceding screenshot, I've already selected the Dummy code entry so that
    we can see what the final settings should look like.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我已经选择了虚拟代码条目，以便我们可以看到最终的设置应该是什么样子的。
- en: Note that the Dummy code entry must be selected as built-in ( the `*` character)
    and not as module (the `M` character).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虚拟代码条目必须选择为内置（`*`字符），而不是模块（`M`字符）。
- en: 'Note also that, if we do not execute the `make menuconfig` command and we execute
    directly the `make Image` command to compile the kernel, then the building system
    will ask us what to do with the `DUMMY_CODE` setting, as shown in the following.
    Obviously, we have to answer yes by using the `y` character:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，如果我们不执行`make menuconfig`命令，而是直接执行`make Image`命令来编译内核，那么构建系统将询问我们如何处理`DUMMY_CODE`设置，如下所示。显然，我们必须使用`y`字符回答是：
- en: '**`$ make Image`**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**`$ make Image`**'
- en: '`scripts/kconfig/conf --syncconfig Kconfig`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`scripts/kconfig/conf --syncconfig Kconfig`'
- en: '`*`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`'
- en: '`* Restart config...`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`* 重新启动配置...`'
- en: '`*`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`'
- en: '`*`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`'
- en: '`* Misc devices`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`* 杂项设备`'
- en: '`*`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`'
- en: '`Analog Devices Digital Potentiometers (AD525X_DPOT) [N/m/y/?] n`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`模拟设备数字电位器（AD525X_DPOT）[N/m/y/?] n`'
- en: '`...`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`...`'
- en: '`Dummy code (DUMMY_CODE) [N/m/y/?] (NEW) y`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`虚拟代码（DUMMY_CODE）[N/m/y/?]（NEW）y`'
- en: 'If everything is correctly in place, then we execute the `make Image` command
    to recompile the kernel. We should see that our new file is compiled and then
    added to the kernel `Image` file, as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切都摆放正确，那么我们执行`make Image`命令重新编译内核。我们应该看到我们的新文件被编译然后添加到内核`Image`文件中，如下所示：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: OK, now what we have to do is just replace the `Image` file on the microSD with
    the one that has just been rebuilt and then restart the system (see the *How to
    add the kernel* recipe in [Chapter 1](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml),
    *Installing the Development System*).
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好了，现在我们要做的就是用刚刚重新构建的`Image`文件替换microSD上的`Image`文件，然后重新启动系统（参见[第1章](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml)中的*如何添加内核*配方，*安装开发系统*）。
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Now, it's time to see how all of the previous steps work. In future sections,
    we're going to explain better what this code really does. However, at the moment,
    we should just notice the following.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看看之前所有步骤是如何工作的了。在接下来的章节中，我们将更好地解释这段代码的真正作用。但是，目前，我们应该注意以下内容。
- en: In *step 1*, notice the calls to `module_init()` and `module_exit()`, kernel-provided
    C macros, which are used to tell the kernel that, during the boot or shutdown
    of the system, it must call the functions we provided, named `dummy_code_init()`
    and `dummy_code_exit()`, which, in turn, just print some information messages.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，请注意对`module_init()`和`module_exit()`的调用，这是内核提供的C宏，用于告诉内核，在系统启动或关闭期间，必须调用我们提供的函数，名为`dummy_code_init()`和`dummy_code_exit()`，这些函数只是打印一些信息消息。
- en: Later on in this chapter, we're going to see in detail what `printk()` does
    and what the `KERN_INFO` macro means but, for now, we should take into account
    only that they are used to print a message during the boot (or shutdown). For
    instance, the preceding code instructs the kernel to print out the message dummy-code
    loaded at some time during the boot stage.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将详细了解`printk()`的作用以及`KERN_INFO`宏的含义，但是目前，我们只需要考虑它们用于在引导（或关闭）期间打印消息。例如，前面的代码指示内核在引导阶段的某个时候打印出消息dummy-code
    loaded。
- en: In *step 2*, in the `Makefile`, we are simply telling the kernel that if `CONFIG_DUMMY_CODE`
    has been enabled (that is `CONFIG_DUMMY_CODE=y`), then `dummy-code.c` must be
    compiled and inserted into the kernel binary (linked), while with the `Kconfig`
    file, we just add our new module into the kernel configuration system.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，在`Makefile`中，我们只是告诉内核，如果启用了`CONFIG_DUMMY_CODE`（即`CONFIG_DUMMY_CODE=y`），那么必须编译并插入内核二进制文件（链接）`dummy-code.c`，而使用`Kconfig`文件，我们只是将新模块添加到内核配置系统中。
- en: In *step 3*, we enable the compilation of our code by using the `make menuconfig`
    command.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们使用`make menuconfig`命令启用我们的代码的编译。
- en: In *step 4*, finally, we recompiled the kernel in order to add our code within
    it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*步骤4*中，我们重新编译内核以将我们的代码添加到其中。
- en: 'In *step 5*, during the boot, we should see the following kernel message:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，在引导过程中，我们应该看到以下内核消息：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: See also
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information regarding how kernel configuration and its building systems
    work, we can take a look into the kernel documentation file within kernel sources
    in the following file: `linux/Documentation/kbuild/kconfig-macro-language.txt`.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关内核配置及其构建系统工作原理的更多信息，我们可以查看内核源代码中的内核文档文件，路径为`linux/Documentation/kbuild/kconfig-macro-language.txt`。
- en: Using kernel messages
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内核消息
- en: As already stated, the serial console is very helpful if we need to set up a
    system from scratch, but it's also very useful if we wish to see kernel messages
    as soon as they are generated. In order to generate kernel messages, we can use
    several functions and, in this recipe, we will take a look at them and how to
    display messages on the serial console or over an SSH connection.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，串行控制台在我们需要从头开始设置系统时非常有用，但如果我们希望在生成时立即看到内核消息，它也非常有用。为了生成内核消息，我们可以使用多个函数，在本教程中，我们将看看它们以及如何在串行控制台或通过SSH连接显示消息。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Our ESPRESSObin is the system that generates kernel messages, so we need a
    connection to it. Through the serial console, these messages are automatically
    displayed as soon as they arrive, but if we are using an SSH connection, we can
    still display them by reading specific files, as with the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的ESPRESSObin是生成内核消息的系统，所以我们需要与它建立连接。通过串行控制台，这些消息一旦到达就会自动显示，但如果我们使用SSH连接，我们仍然可以通过读取特定文件来显示它们，就像以下命令一样：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, the serial console deserves a special note: in fact, in our example,
    the kernel messages will be automatically displayed on the serial console, if,
    and only if, the leftmost number, among the ones found inside the `/proc/sys/kernel/printk`
    file, happens to be greater than seven, as shown in the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，串行控制台值得特别注意：实际上，在我们的示例中，只有当`/proc/sys/kernel/printk`文件中最左边的数字大于七时，内核消息才会自动显示在串行控制台上，如下所示：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These magic numbers have a well-defined meaning; in particular, the first one
    represents the error message level that the kernel must show on the serial console.
    These levels are defined in the `linux/include/linux/kern_levels.h` file, as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这些魔术数字有明确定义的含义；特别是第一个代表内核必须在串行控制台上显示的错误消息级别。这些级别在`linux/include/linux/kern_levels.h`文件中定义，如下所示：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For example, if the contents of the preceding file were 4, as reported in the
    following, only messages having the `KERN_EMERG`, `KERN_ALERT`, `KERN_CRIT`, and
    `KERN_ERR` levels will be automatically displayed on the serial console:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果前面文件的内容是4，如下所示，只有具有`KERN_EMERG`、`KERN_ALERT`、`KERN_CRIT`和`KERN_ERR`级别的消息才会自动显示在串行控制台上：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In order to allow all messages, a subset of them, or none to be displayed,
    we have to modify the leftmost number of the `/proc/sys/kernel/printk` file by
    using the `echo` command, as in the following example in which we act in such
    a way to completely disable the printing of all kernel messages. This is because
    no message can have a priority level greater than 0:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许显示所有消息、它们的子集或不显示任何消息，我们必须使用`echo`命令修改`/proc/sys/kernel/printk`文件的最左边的数字，就像在以下示例中那样，我们以这种方式完全禁用所有内核消息的打印。这是因为没有消息的优先级可以大于0：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Kernel message priorities start from 0 (the highest) and go up to 7 (the lowest)!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 内核消息的优先级从0（最高）开始，到7（最低）结束！
- en: Now that we know how to display kernel messages, we can try to perform some
    modifications to our kernel code in order to do some experimentation with kernel
    messages.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何显示内核消息，我们可以尝试对内核代码进行一些修改，以便对内核消息进行一些实验。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In the previous example, we saw that we can use the `printk()` function to
    generate kernel messages, but there are other functions that we can use in place
    of `printk()` in order to have more efficient messages and compact and readable
    code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到可以使用`printk()`函数生成内核消息，但是还有其他函数可以替代`printk()`，以便获得更高效的消息和更紧凑可读的代码：
- en: 'Use the following macros (as defined in the `include/linux/printk.h` file),
    which are listed in the following:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下宏（在`include/linux/printk.h`文件中定义），如下所示：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, to generate a kernel message, we can do the following: looking at these
    definitions, we can rewrite our `dummy_code_init()` and `dummy_code_exit()` functions
    from the previous example into the `dummy-code.c` file, as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要生成一个内核消息，我们可以这样做：查看这些定义，我们可以将前面示例中的`dummy_code_init()`和`dummy_code_exit()`函数重写到`dummy-code.c`文件中，如下所示：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'If we look carefully at the preceding printing functions (`pr_info()` and similar
    functions), we notice that they also depend on the `pr_fmt(fmt)` parameter, which
    can be used to add other useful information into our message. For instance, the
    following definition alters all messages generated by `pr_info()` by adding the
    current module and calling function names:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察前面的打印函数（`pr_info()`和类似的函数），我们会注意到它们还依赖于`pr_fmt(fmt)`参数，该参数可用于向我们的消息中添加其他有用的信息。例如，以下定义通过添加当前模块和调用函数名称来改变`pr_info()`生成的所有消息：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that the `pr_fmt()` macro definition must appear at the start of the file,
    even before the includes, to have any effect.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`pr_fmt()`宏定义必须出现在文件的开头，甚至在包含之前，才能生效。
- en: 'If we add this line to our `dummy-code.c`, as shown in the following code block,
    the kernel messages will change as described:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这行添加到我们的`dummy-code.c`中，内核消息将会按照描述发生变化：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In fact, when the `pr_info()` function is executed the output message, telling
    us that the module has been inserted turns in the following form, where we can
    see the module name and the calling function name followed by the loading message:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，当执行`pr_info()`函数时，输出消息会告诉我们模块已被插入，变成以下形式，我们可以看到模块名称和调用函数名称，然后是加载消息：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There is another set of printing functions but, before starting to talk about
    them, we need some information that is located in [Chapter 3](5f22a69e-e8b7-402e-8e67-72938d00c914.xhtml),
    *Using the Device Tree*, so, for the moment, we'll continue using these functions
    only.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一组打印函数，但在开始讨论它们之前，我们需要一些位于[第3章](5f22a69e-e8b7-402e-8e67-72938d00c914.xhtml)中的信息，*使用设备树*，所以，暂时，我们只会继续使用这些函数。
- en: There's more...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: here are many kernel activities, many of them really complex, and frequently,
    a kernel developer has to work with several messages and not all of them interesting;
    so, we need to find some ways to filter out interesting messages.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多内核活动，其中许多确实很复杂，而且经常，内核开发人员必须处理几条消息，而不是所有消息都有趣；因此，我们需要找到一些方法来过滤出有趣的消息。
- en: Filtering kernel messages
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤内核消息
- en: 'Suppose we wish to know which serial ports have been detected during boot.
    We know we can use the `tail` command, but by using it, we can see only the latest
    messages; on the other hand, we could use the `cat` command to recall all kernel
    messages since boot, but that''s a lot of information! Alternatively, we can use
    these steps to filter the kernel messages:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望知道在引导期间检测到了哪些串行端口。我们知道可以使用`tail`命令，但是通过使用它，我们只能看到最新的消息；另一方面，我们可以使用`cat`命令来回忆自引导以来的所有内核消息，但那是大量的信息！或者，我们可以使用以下步骤来过滤内核消息：
- en: 'Here, we use the `grep` command as follows to filter out lines within the `uart`
    (or `UART`) string:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用`grep`命令来过滤`uart`（或`UART`）字符串中的行：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding output can also be obtained by using the `dmesg` command as follows,
    which is a tool designed for this purpose:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出也可以通过使用`dmesg`命令来获得，这是一个专为此目的设计的工具：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that, while `cat` displays everything in the log file, even very old messages
    from previous OS executions, `dmesg` displays current OS execution messages only.
    This is because `dmesg` takes kernel messages directly from the current running
    system via its ring buffer (that is, the buffer where all messages are stored).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然`cat`显示日志文件中的所有内容，甚至是来自先前操作系统执行的非常旧的消息，但`dmesg`仅显示当前操作系统执行的消息。这是因为`dmesg`直接从当前运行的系统通过其环形缓冲区（即存储所有消息的缓冲区）获取内核消息。
- en: 'On the other hand, if we want to gather information regarding early boot activities,
    we can still use the `dmesg` command with the `head` command in order to display
    the first 10 lines of `dmesg` output only:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，如果我们想收集有关早期引导活动的信息，我们仍然可以使用`dmesg`命令和`head`命令，以仅显示`dmesg`输出的前10行：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On the other hand, if we are interested in the last 10 lines, we can use the
    `tail` command. In fact, we already saw that, to monitor kernel activities, we
    can use it as shown in the following:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，如果我们对最后10行感兴趣，我们可以使用`tail`命令。实际上，我们已经看到，为了监视内核活动，我们可以像下面这样使用它：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So, to see the last 10 lines, we can do the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要查看最后10行，我们可以执行以下操作：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The same can be done with `dmesg`, too, by adding the `-w` option argument,
    as shown in the following example:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，也可以使用`dmesg`，通过添加`-w`选项参数，如下例所示：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `dmesg` command can also filter out kernel messages according to their
    level by using the `-l` (or `--level`) option argument, as follows:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dmesg`命令也可以根据它们的级别过滤内核消息，方法是使用`-l`（或`--level`）选项参数，如下所示：'
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding command shows kernel messages having the `KERN_ERR` level, while
    the following is the command to show messages having the `KERN_WARNING` level
    instead:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令显示具有`KERN_ERR`级别的内核消息，而以下是显示具有`KERN_WARNING`级别的消息的命令：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can also combine levels in order to have both `KERN_ERR` and `KERN_WARNING`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以组合级别，以同时具有`KERN_ERR`和`KERN_WARNING`：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the end, in the event of a lot of noisy messages, we can ask the system
    to clean the kernel ring buffer (where all kernel messages are stored) by using
    the following command:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在大量嘈杂的消息的情况下，我们可以要求系统通过使用以下命令来清除内核环形缓冲区（存储所有内核消息的地方）：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, if we use `dmesg` again, we will see newly generated kernel messages only.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次使用`dmesg`，我们将只看到新生成的内核消息。
- en: See also
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information regarding kernel messages management, a good starting point
    is the `dmesg` man pages, which we can display by executing the `man dmesg` command.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关内核消息管理的更多信息，一个很好的起点是`dmesg`手册页，我们可以通过执行`man dmesg`命令来显示它。
- en: Working with kernel modules
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内核模块
- en: Knowing how to add custom code to the kernel is useful but, when we have to
    write a new driver, it can be more useful writing our code as a **kernel module**.
    In fact, by using a module, we can easily modify kernel code and then test it
    without rebooting the system every time! We simply have to remove and then reinsert
    the module (after the necessary modifications) in order to test the new version
    of our code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何向内核添加自定义代码是有用的，但是，当我们必须编写新的驱动程序时，将我们的代码编写为**内核模块**可能更有用。实际上，通过使用模块，我们可以轻松修改内核代码，然后在不需要每次重新启动系统的情况下进行测试！我们只需删除然后重新插入模块（在必要的修改之后）以测试我们代码的新版本。
- en: In this recipe, we'll take a look at how kernel modules can get compiled even
    on a directory outside the kernel tree.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看看即使在内核树之外的目录中，内核模块也可以被编译。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To turn our `dummy-code.c` file into a kernel module, we only have to change
    our kernel settings, allowing the compilation of our example module (by replacing
    the `*` character with `M` in the kernel configuration menu). However, under some
    circumstances, it could be more useful having our driver released into a dedicated
    archive completely separated from kernel sources. Even in this case, no changes
    are to be done to the existing code, and we will be able to compile `dummy-code.c` inside
    the kernel source tree, or even outside it!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的`dummy-code.c`文件转换为内核模块，我们只需更改内核设置，允许编译我们示例模块（在内核配置菜单中用`*`字符替换为`M`）。但是，在某些情况下，将我们的驱动程序发布到与内核源代码完全分开的专用存档中可能更有用。即使在这种情况下，也不需要对现有代码进行任何更改，我们将能够在内核源树内部或者在外部编译`dummy-code.c`！
- en: 'To build up our first kernel module as external code, we can safely take the
    preceding `dummy-code.c` file and then put it into a dedicated directory with
    the following `Makefile`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建我们的第一个内核模块作为外部代码，我们可以安全地使用前面的`dummy-code.c`文件，然后将其放入一个专用目录，并使用以下`Makefile`：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Looking at the preceding code, we see that the `KERNEL_DIR` variable must be
    supplied on the command line pointing to the path to ESPRESSObin's previously
    compiled kernel sources, while the `ARCH` and `CROSS_COMPILE` variables are not
    mandatory since `Makefile` specifies them (however, supplying them on the command
    line will take precedence).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 查看前面的代码，我们看到`KERNEL_DIR`变量必须在命令行上提供，指向ESPRESSObin之前编译的内核源代码的路径，而`ARCH`和`CROSS_COMPILE`变量不是强制性的，因为`Makefile`指定了它们（但是，在命令行上提供它们将优先）。
- en: 'Also, we should verify that the `insmod` and `rmmod` commands are available
    in our ESPRESSObin, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们应该验证`insmod`和`rmmod`命令是否在我们的ESPRESSObin中可用，如下所示：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If they are not present, then they can be installed by adding the `kmod` package
    with the usual `apt install kmod` command.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在，那么可以通过使用通常的`apt install kmod`命令添加`kmod`软件包来安装它们。
- en: How to do it...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how to do it by following these steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过以下步骤来做到这一点：
- en: 'After placing the `dummy-code.c` and `Makefile` files in our current working
    directory on the host PC, it should look like the following when using the `ls`
    command, as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将`dummy-code.c`和`Makefile`文件放置在主机PC上的当前工作目录后，当使用`ls`命令时，它应该如下所示：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we can compile our module by using the following command:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令编译我们的模块：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As we can see, now we have several files in the current working directory, and
    one of them is named `dummy-code.ko`; this is our kernel module ready to be transferred
    to the ESPRESSObin!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，现在我们在当前工作目录中有几个文件，其中一个名为`dummy-code.ko`；这是我们的内核模块，准备好传输到ESPRESSObin！
- en: 'Once the module has been moved into the target system (for example, by using
    the `scp` command), we can load it by using the `insmod` utility, as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦模块已经移动到目标系统（例如，通过使用`scp`命令），我们可以使用`insmod`实用程序加载它，如下所示：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, by using the `lsmod` command, we can ask the system to display all loaded
    modules. On my ESPRESSObin, I only have the `dummy-code.ko` module, so my output
    is as shown:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过使用`lsmod`命令，我们可以要求系统显示所有加载的模块。在我的ESPRESSObin上，我只有`dummy-code.ko`模块，所以我的输出如下所示：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that the `.ko` postfix has been removed by the kernel module name, as the
    `-` character is replaced by `_`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于内核模块名称中的`-`字符被替换为`_`，内核模块名称的`.ko`后缀已被删除。
- en: 'Then, we can remove our module from the kernel by using the `rmmod` command,
    as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`rmmod`命令从内核中删除我们的模块，如下所示：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In case you get the following error, please verify you're running the correct
    `Image` file we got in[Chapter 1](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml), *Installing
    the Development System*
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现以下错误，请验证您是否运行了我们在[第1章](2739e129-3c1a-4c98-ba9a-9c17ae4c09db.xhtml)中获得的正确`Image`文件，*安装开发系统*
- en: '`rmmod: ERROR: ../libkmod/libkmod.c:514 lookup_builtin_file() could not open
    builtin file ''/lib/modules/4.18.0-dirty/modules.builtin.bin''`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`rmmod: ERROR: ../libkmod/libkmod.c:514 lookup_builtin_file() could not open
    builtin file ''/lib/modules/4.18.0-dirty/modules.builtin.bin''`'
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `insmod` command just takes our module and inserts it into the kernel; after
    that, it executes the `module_init()` function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`insmod`命令只是将我们的模块插入内核；之后，它执行`module_init()`函数。'
- en: 'During module insertion, if we''re over an SSH connection, we''ll see nothing
    on the Terminal and we have to use `dmesg` to see kernel messages (or `tail` on
    the `/var/log/kern.log` file, as discussed previously); otherwise, on the serial
    console, after inserting the module, we should see something like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块插入期间，如果我们在SSH连接上，终端上将看不到任何内容，我们必须使用`dmesg`来查看内核消息（或者在串行控制台上，在插入模块后，我们应该看到类似以下内容的内容：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that the message, loading out-of-tree module taints kernel, is just a warning
    and can be safely ignored for our purposes. See [https://www.kernel.org/doc/html/v4.15/admin-guide/tainted-kernels.html](https://www.kernel.org/doc/html/v4.15/admin-guide/tainted-kernels.html)
    for further information about tainted kernels.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，消息“加载非树模块会污染内核”只是一个警告，可以安全地忽略我们的目的。有关污染内核的更多信息，请参见[https://www.kernel.org/doc/html/v4.15/admin-guide/tainted-kernels.html](https://www.kernel.org/doc/html/v4.15/admin-guide/tainted-kernels.html)。
- en: The `rmmod` command does the inverse steps of `insmod`, that is, it executes
    the `module_exit()` function and then removes the module from the kernel.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`rmmod`命令执行`module_exit()`函数，然后从内核中删除模块，执行`insmod`的逆步骤。'
- en: See also
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information regarding the modutils, their man pages are a good starting
    point (the commands are: `man insmod`, `man rmmod`, and `man modinfo`); also,
    we can take a look at the `modprobe` command by reading its man pages (`man modprobe`).'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关modutils的更多信息，它们的手册页是一个很好的起点（命令是：`man insmod`，`man rmmod`和`man modinfo`）；此外，我们可以通过阅读其手册页（`man
    modprobe`）来了解`modprobe`命令。
- en: Using module parameters
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块参数
- en: During kernel module development, it can be very useful having some way to dynamically
    set some variables during module insertion and not only at compile time. In Linux,
    this can be done by using the kernel module's parameters, which allow arguments
    to be passed to a module by specifying them on the command line of the `insmod`
    command.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核模块开发过程中，动态设置一些变量在模块插入时非常有用，而不仅仅是在编译时。在Linux中，可以通过使用内核模块的参数来实现，这允许通过在`insmod`命令的命令行上指定参数来传递参数给模块。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order to show an example, let's consider a situation where we have a new
    module information file, `module_par.c` (this file is also in our GitHub repository).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，让我们考虑一个情况，我们有一个新的模块信息文件`module_par.c`（此文件也在我们的GitHub存储库中）。
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how to do it by following these steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过以下步骤来做到这一点：
- en: 'First, let''s define our module parameters, as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们定义我们的模块参数，如下所示：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we can use the following `init` and `exit` functions:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下的`init`和`exit`函数：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, at the end, we can add module description macros as usual:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在最后，我们可以像往常一样添加模块描述宏：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Once compiled as before, a new file, `module_par.ko`, should be ready to be
    loaded into our ESPRESSObin. However, before doing it, let''s use the `modinfo`
    utility on it, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 编译完成后，应该会生成一个名为`module_par.ko`的新文件，可以加载到我们的ESPRESSObin中。但在这之前，让我们使用`modinfo`实用程序对其进行如下操作：
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `modinfo` command is also included in the `kmod` package as `insmod`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`modinfo`命令也包含在`kmod`软件包中，名为`insmod`。'
- en: As we can see in the last three lines (all prefixed by the `parm:` string),
    we have a list of module's parameters defined in the code by the `module_param()`
    and `module_param_array()` macros and described with `MODULE_PARM_DESC()`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在最后三行中所看到的（都以`parm：`字符串为前缀），我们在代码中使用`module_param（）`和`module_param_array（）`宏定义了模块的参数列表，并使用`MODULE_PARM_DESC（）`进行描述。
- en: 'Now, if we simply insert the module as before, we get default values, as shown
    in the following code block:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们像以前一样插入模块，我们会得到默认值，如下面的代码块所示：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'But if we use the next command line, we force new values:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们使用下一个命令行，我们可以强制使用新值：
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Don't forget to remove the `module_par` module by using the `rmmod module_par`
    command before trying to reload it with new values!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试使用新值重新加载之前，请不要忘记使用`rmmod module_par`命令删除`module_par`模块！
- en: 'As a final note, let me suggest taking a closer look at the following module
    parameter definition:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我建议仔细查看以下模块参数定义：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: First, we have the declaration of the variable that represents the parameter,
    then we have the real module parameter definition (where we specify the type and
    the file access permissions), and then we have the description.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有代表参数的变量声明，然后是真正的模块参数定义（在这里我们指定类型和文件访问权限），然后是描述。
- en: 'The `modinfo` command is able to display all of the preceding information,
    except the file access permissions, which refer to the file related to this parameter
    within the sysfs filesystem! In fact, if we take a look at the `/sys/module/module_par/parameters/`
    directory, we get the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`modinfo`命令能够显示所有前面的信息，除了文件访问权限，这些权限是指与`sysfs`文件系统中的参数相关的文件！实际上，如果我们看一下`/sys/module/module_par/parameters/`目录，我们会得到以下内容：'
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, it should be clear what parameters `S_IRUSR` and `S_IWUSR` means; they
    allow the module user (that is, the root user) to write into these files and then
    read from them the corresponding parameters.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应该清楚参数`S_IRUSR`和`S_IWUSR`的含义；它们允许模块用户（即root用户）写入这些文件，然后从中读取相应的参数。
- en: 'Defines `S_IRUSR` and related function are defined in the following file: `linux/include/uapi/linux/stat.h`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`S_IRUSR`和相关函数的定义在以下文件中：`linux/include/uapi/linux/stat.h`。'
- en: See also
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Regarding kernel modules in general and about how to export kernel symbols,
    you can take a look at *The Linux Kernel Module Programming Guide,* available
    online at [https://www.tldp.org/LDP/lkmpg/2.6/html/index.html](https://www.tldp.org/LDP/lkmpg/2.6/html/index.html)[.](https://www.tldp.org/LDP/lkmpg/2.6/html/index.html)
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于内核模块的一般信息以及如何导出内核符号，您可以查看在线提供的*Linux内核模块编程指南*，网址为[https://www.tldp.org/LDP/lkmpg/2.6/html/index.html](https://www.tldp.org/LDP/lkmpg/2.6/html/index.html)[.](https://www.tldp.org/LDP/lkmpg/2.6/html/index.html)
