- en: The Linux Filesystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux文件系统
- en: In this chapter, we'll spend some time exploring the Linux filesystem. We will
    explain what a filesystem is and what makes the Linux filesystem unique. We will
    describe the structure of the Linux filesystem and how, under Linux, (almost)
    everything is a file. We will do this interactively, giving your the first closer
    look at some common Linux commands which will be used in scripting later on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将花一些时间探索Linux文件系统。我们将解释文件系统是什么，以及什么使Linux文件系统独特。我们将描述Linux文件系统的结构以及在Linux下（几乎）一切都是文件。我们将以交互方式进行，让您首次近距离了解一些常见的Linux命令，这些命令将在后面的脚本中使用。
- en: 'The following commands will be introduced in this chapter: `pwd`, `cd`, `df`,
    `echo`, `type`, `cat`, and `less`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下命令：`pwd`、`cd`、`df`、`echo`、`type`、`cat`和`less`。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The Linux filesystem explained
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux文件系统解释
- en: The structure of the Linux filesystem
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux文件系统的结构
- en: Everything is a file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一切都是文件
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will explore the Linux filesystem using the virtual machine we created in
    [Chapter 2](cdd5838b-007b-4e1a-a8dc-3c9ea8ebefca.xhtml), *Setting Up Your Local
    Environment*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在[第2章](cdd5838b-007b-4e1a-a8dc-3c9ea8ebefca.xhtml)中创建的虚拟机来探索Linux文件系统，*设置本地环境*。
- en: If you run into issues with connecting to your virtual machine, make sure that
    VirtualBox is running and the virtual machine has been started. While there are
    many things that can cause issues, making sure the hypervisor and virtual machine
    are running should always be your first step in troubleshooting.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在连接到虚拟机时遇到问题，请确保VirtualBox正在运行，并且虚拟机已启动。虽然有许多可能导致问题的原因，但确保虚拟机监控程序和虚拟机正在运行应始终是故障排除的第一步。
- en: The Linux filesystem explained
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux文件系统解释
- en: This chapter will present the basics of the Linux filesystem. Because filesystems
    are complicated, we will not be delving too deeply into the guts of the technology;
    instead, we'll present just enough information that's still relevant for shell
    scripting.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍Linux文件系统的基础知识。由于文件系统很复杂，我们不会深入探讨技术的细节；相反，我们将提供足够相关的信息，以便进行shell脚本编写。
- en: What is a filesystem?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是文件系统？
- en: A filesystem is, in essence, the way data is stored and retrieved on a physical
    medium (which can be a hard disk, solid state drive, or even RAM). It is a software
    implementation that manages where and how the bits are written and found again,
    and may include various advanced features which enhance reliability, performance,
    and functionality.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统本质上是数据在物理介质上存储和检索的方式（可以是硬盘、固态硬盘，甚至是RAM）。它是一个软件实现，管理位的写入和再次找到的位置和方式，并可能包括各种增强可靠性、性能和功能的高级功能。
- en: 'The concept of a filesystem is abstract: there are many filesystem *implementations*,
    which are confusingly often referred to as filesystems. We find it easiest to
    grasp by ordering the filesystems in families, just as with Linux distributions:
    there are Linux filesystems, Windows filesystems, macOS filesystems, and many
    others. The Windows filesystem family spans from the earliest filesystem of **FAT**
    up until the newest **ReFS**, with the most widely used currently being **NTFS**.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统的概念是抽象的：有许多文件系统*实现*，令人困惑的是它们经常被称为文件系统。我们发现最容易理解的方法是按照家族对文件系统进行排序，就像Linux发行版一样：有Linux文件系统、Windows文件系统、macOS文件系统以及许多其他文件系统。Windows文件系统家族从最早的**FAT**文件系统一直延伸到最新的**ReFS**，目前最广泛使用的是**NTFS**。
- en: 'At the time of writing, the most important filesystems in the Linux family
    are the following implementations:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Linux家族中最重要的文件系统实现如下：
- en: '**ext4**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ext4**'
- en: '**XFS**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XFS**'
- en: '**Btrfs**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Btrfs**'
- en: The most commonly used Linux filesystem implementation is currently ext4\. It
    is the fourth iteration in the **extended file system** (**ext**) series of Linux
    filesystems. It was released in 2008 and is considered *very* stable, but it is
    not state-of-the-art; reliability is the most important consideration.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 目前最常用的Linux文件系统实现是ext4。它是Linux文件系统**扩展文件系统**（**ext**）系列的第四个版本。它于2008年发布，被认为非常稳定，但并非最先进；可靠性是最重要的考虑因素。
- en: XFS is most famously used in Red Hat distributions (Red Hat Enterprise Linux,
    CentOS, and Fedora). It contains some features that are more advanced than ext4,
    such as parallel I/O, larger file size support, and better handling of large files.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: XFS最著名的用途是在Red Hat发行版（Red Hat Enterprise Linux、CentOS和Fedora）中。它包含一些比ext4更先进的功能，如并行I/O、更大的文件大小支持和更好地处理大文件。
- en: 'Finally, there is Btrfs. This filesystem implementation was initially designed
    at Oracle and is considered stable as of 2014\. Btrfs has many advanced features
    that could make it preferable to ext4 and XFS; the principal developer of ext4
    even stated that ext4 should eventually be replaced by Btrfs. The most interesting
    feature of Btrfs is that it uses the **copy-on-write** (**COW**) principle: files
    that are copied aren''t actually written out to the physical medium fully, but
    only a new pointer to the same data is created. Only when either the copy or the
    original gets modified is new data written.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是Btrfs。这个文件系统实现最初是在Oracle设计的，截至2014年被认为是稳定的。Btrfs具有许多先进的功能，这使得它可能比ext4和XFS更可取；甚至ext4的主要开发人员表示，ext4最终应该被Btrfs取代。Btrfs最有趣的特性是它使用**写时复制**（**COW**）原则：复制的文件实际上并没有完全写入物理介质，而只是创建了指向相同数据的新指针。只有在复制或原始文件被修改时才会写入新数据。
- en: As you might have guessed, a filesystem implementation is nothing more than
    software. For Linux, the three implementations previously described are present
    in all newer Linux kernels. This means that, as long as the correct drivers are
    installed in the operating system, these can all be used. Even better, all of
    these can even be used *concurrently*! We will discuss this further later in this
    chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的那样，文件系统实现只不过是软件而已。对于Linux，前面描述的三种实现都存在于所有更新的Linux内核中。这意味着只要在操作系统中安装了正确的驱动程序，这些都可以使用。更好的是，所有这些甚至可以*同时*使用！我们将在本章的后面进一步讨论这一点。
- en: Another interesting thing to note is that, while ext4 is native to Linux, with
    the help of drivers it can be used under, for example, Windows as well. You would
    not use ext4 as the filesystem for the primary drive under Windows, but you could
    *mount* a Linux-formatted ext4 filesystem under Windows and interact with the
    contents. The other way around, mounting a Windows filesystem under Linux, is
    also supported for most implementations. And while we used ext4 as the example
    here, the same goes for XFS and Btrfs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的事情是，虽然ext4是Linux原生的文件系统，但在驱动程序的帮助下，它也可以在Windows下使用。你不会将ext4用作Windows下的主要驱动器文件系统，但你可以在Windows下*挂载*一个Linux格式的ext4文件系统并与其中的内容交互。反过来，在Linux下挂载Windows文件系统也是大多数实现所支持的。虽然我们在这里使用ext4作为例子，但XFS和Btrfs也是一样的。
- en: What makes the Linux filesystem unique?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux文件系统的独特之处是什么？
- en: As should be clear by now, in reality, there is no such thing as *the* Linux
    filesystem. However, these filesystems share certain characteristics that make
    them viable as Linux filesystems.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该清楚的是，实际上并不存在*the* Linux文件系统。然而，这些文件系统共享某些特征，使它们成为可行的Linux文件系统。
- en: 'A Linux filesystem adheres to the **Filesystem Hierarchy Standard** (**FHS**).
    This FHS is maintained by The Linux Foundation and is currently up to version
    3.0\. As with many things in the Linux ecosystem, it is based on a Unix predecessor:
    the **Unix Filesystem Standard** (**UFS**).It specifies the **directory structure**
    and its contents. We''ll explore this structure together in the next part of this
    chapter.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Linux文件系统遵循**文件系统层次结构标准**（**FHS**）。这个FHS由Linux基金会维护，目前已经更新到3.0版。与Linux生态系统中的许多其他事物一样，它是基于Unix的前身：**Unix文件系统标准**（**UFS**）。它指定了**目录结构**及其内容。我们将在本章的下一部分一起探讨这个结构。
- en: 'Since Linux is most commonly used in servers, Linux filesystem implementations
    (often) have very advanced features on the topic of file integrity and disaster
    recovery. An example of such a disaster would be a system experiencing a power
    outage when it was in the middle of writing a business-critical file. If the write
    operation was stored in memory and aborted halfway through, the file would be
    in an inconsistent state. When the system is brought up again, the operating system
    does not have the write operation in memory anymore (since memory is cleared on
    each reboot), and only a part of the file will be written. Obviously, this is
    unwanted behavior and can lead to problems. Because of the properties of COW,
    Btrfs does not have this problem. However, ext4 and XFS are not COW filesystems.
    They both handle this issue in another way: with **journaling**:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Linux最常用于服务器，Linux文件系统实现（通常）在文件完整性和灾难恢复方面具有非常先进的功能。这种灾难的一个例子是，当系统在写入一个业务关键文件时遇到停电。如果写入操作存储在内存中并在中途中止，文件将处于不一致的状态。当系统再次启动时，操作系统不再在内存中有写入操作（因为内存在每次重启时都会被清除），只有部分文件会被写入。显然，这是不希望发生的行为，可能会导致问题。由于COW的特性，Btrfs不会出现这个问题。然而，ext4和XFS不是COW文件系统。它们以另一种方式处理这个问题：通过**日志记录**：
- en: '![](img/7612f577-21c9-4856-a2d4-65bcbad6c62c.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7612f577-21c9-4856-a2d4-65bcbad6c62c.png)'
- en: 'As the preceding diagram shows, files are written to disk in three steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，文件被写入磁盘分为三个步骤：
- en: Filesystem requests disk write from journal
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件系统请求从日志中写入磁盘
- en: Journal writes on disk
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日志写入磁盘
- en: After file write, journal is updated
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件写入后，更新日志
- en: If the server crashes between steps 2 and 3, the write will be done again after
    power up, because the journal still contains the entry. The journal only contains
    some metadata about the operation, not the entire file. Since the journal contains
    a reference to the *actual* location on disk (the drive sectors), it will overwrite
    what was previously written, in this case, part of the file. If it finished successfully
    this time, the journal entry will be removed and the state of the file/disk is
    guaranteed. Should the server fail between steps 1 and 2, the actual instruction
    to write to disk has never been given and the software giving the instruction
    should account for that possibility.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器在步骤2和3之间崩溃，那么在上电后将再次进行写入，因为日志仍然包含该条目。日志只包含有关操作的一些元数据，而不是整个文件。由于日志包含对磁盘上*实际*位置（驱动器扇区）的引用，它将覆盖先前写入的内容，即文件的一部分。如果这次成功完成，日志条目将被删除，文件/磁盘的状态得到保证。如果服务器在步骤1和2之间失败，那么实际的写入磁盘指令从未被给出，给出指令的软件应该考虑到这种可能性。
- en: '**Full disclosure**: This part about journaling is a bit of an oversimplification,
    but again filesystems are complicated and we want to focus on things that are
    relevant for shell scripting. If you''re interested in how filesystems work on
    a lower level, be sure to pick up another book since it really is a very interesting
    subject!'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**免责声明**：关于日志记录的部分有点过于简化，但是文件系统很复杂，我们想要专注于与shell脚本相关的内容。如果你对文件系统在更低层次上的工作原理感兴趣，一定要找一本其他的书来看，因为这确实是一个非常有趣的主题！'
- en: Structure of the Linux filesystem
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux文件系统的结构
- en: 'While there are many more advanced filesystem features that are very interesting,
    we want to focus on what makes the Linux filesystem distinctively Linux: the filesystem
    structure. If you''re used to Windows, this will probably be the single most confusing
    difference between the two operating systems. If you''re coming from macOS, the
    difference is still noticeable, but much smaller: this is a result of macOS being
    a Unix operating system, which has obvious similarities with the Unix-like Linux
    structure.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然还有许多更高级的文件系统功能非常有趣，但我们想要专注于使Linux文件系统与众不同的东西：文件系统结构。如果您习惯于Windows，这可能是两个操作系统之间最令人困惑的区别。如果您来自macOS，差异仍然明显，但要小得多：这是macOS作为Unix操作系统的结果，它与类Unix的Linux结构有明显的相似之处。
- en: We're going to be interactively exploring the Linux filesystem from this point
    on. We advise you to follow along with the code examples that follow, since this
    increases information retention significantly. Besides that, your system might
    look differently from the one we use, should you have chosen not to use Ubuntu
    18.04 LTS for this book. In any case, start up that virtual machine and start
    exploring with us!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，我们将交互式地探索Linux文件系统。我们建议您跟随后面的代码示例，因为这会显著增加信息的保留。此外，如果您选择不使用Ubuntu 18.04
    LTS进行本书学习，您的系统可能与我们使用的系统有所不同。无论如何，启动虚拟机并与我们一起开始探索吧！
- en: Tree structure
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 树结构
- en: 'Let''s start by logging in to our virtual machine via SSH:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过SSH登录到我们的虚拟机：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Enter your password at the prompt and you should arrive at the default Ubuntu
    18.04 login banner, which should look similar to the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示处输入密码，然后您应该到达默认的Ubuntu 18.04登录横幅，应该看起来类似于以下内容：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When logging in (either via SSH or the Terminal console) you will end up at
    the `home` directory of the user. You can always find out where you are exactly
    by using the `pwd` command. `pwd` stands for **p**rint **w**orking **d**irectory:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 登录时（无论是通过SSH还是终端控制台），您将最终进入用户的`home`目录。您可以始终使用`pwd`命令来确定您的确切位置。`pwd`代表**p**rint
    **w**orking **d**irectory：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So, we''ve ended up in the `/home/reader/` directory. This is the default for
    most Linux distributions: `/home/$USERNAME/`. Since we created the primary user
    `reader`, this is where we expect to be. For those of you coming from Windows,
    this might look very foreign: where is the drive name (`C:`, `D:`, and so on)
    and why are we using (forward) slashes instead of backslashes?'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们最终进入了`/home/reader/`目录。这是大多数Linux发行版的默认设置：`/home/$USERNAME/`。由于我们创建了主用户`reader`，这就是我们期望的位置。对于那些来自Windows的人来说，这可能看起来非常陌生：驱动器名称（`C:`、`D:`等）在哪里？为什么我们使用（正斜杠）而不是反斜杠？
- en: 'Linux, as well as Unix and other Unix-like systems, uses a **tree structure**.
    It is referred to as a tree because it starts at a single origin point, the `root`
    (found at `/`). Directories are nested from there (like **branches** from a tree),
    not much differently from other operating systems. Finally, the tree structure
    ends in files that are considered the **leaves** of the tree. This might sound
    terribly complicated still, but it''s actually relatively simple. Let''s keep
    exploring to make sure we fully understand this structure! Under Linux, we use
    the `cd` command to change directories. It works by entering `cd`, followed by
    the location on the filesystem where we want to go as the *argument to the command*.
    Navigate to the filesystem root:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Linux以及Unix和其他类Unix系统使用**树结构**。它被称为树，因为它从单个起始点`root`（位于`/`）开始。目录从那里嵌套（就像树的**分支**一样），与其他操作系统并没有太大不同。最后，树结构以被视为树的**叶子**的文件结束。这可能听起来仍然非常复杂，但实际上相对简单。让我们继续探索，以确保我们完全理解这个结构！在Linux下，我们使用`cd`命令来更改目录。它通过输入`cd`，后跟我们想要去的文件系统位置作为*命令的参数*来工作。导航到文件系统根目录：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, nothing much seems to have happened. However, there is one
    tiny difference in your Terminal prompt: the `~` character has been replaced by
    `/`. Under Ubuntu, the default configuration shows the location on the filesystem
    without needing to use the `pwd` command. The prompt is built as follows: `<username>@<hostname>**:**<location>**$**`.
    Why the `~` then? Simple: the tilde character is shorthand for the user''s home
    directory! If the shorthand wasn''t there, the prompt at login would be `reader@ubuntu:/home/reader$`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，似乎没有发生太多事情。但是，您的终端提示中有一个微小的区别：`~`字符已被`/`替换。在Ubuntu下，默认配置显示文件系统的位置，无需使用`pwd`命令。提示构建如下：`<username>@<hostname>**:**<location>**$**`。那么为什么是`~`呢？简单：波浪符号是用户主目录的简写！如果简写不存在，登录时的提示将是`reader@ubuntu:/home/reader$`。
- en: 'Since we have navigated to the root of the filesystem, let''s check out what
    we can find there. To list the contents of the current directory, we use the `ls`
    command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经导航到了文件系统的根目录，让我们看看我们可以在那里找到什么。要列出当前目录的内容，我们使用`ls`命令：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you''re using SSH, you''ll most likely have some colors to differentiate
    between files and directories (and even permissions on directories, if you see
    `tmp` in a different manner; this will be discussed in the next chapter). However,
    even with color assistance, this still feels unclear. Let''s clean it up a bit
    by using an **option** on the `ls` command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用SSH，您很可能会看到一些颜色来区分文件和目录（甚至可以看到目录权限的颜色，如果您以不同方式看到`tmp`；这将在下一章中讨论）。然而，即使有颜色的帮助，这仍然感觉不清晰。让我们通过在`ls`命令上使用一个**选项**来清理一下：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The option `-l` (hyphen lowercase l, as in *long*) to `ls` gives the **long
    listing format**. Among other things, this prints the permissions, the owner of
    the file/directory, the type of file, and its size. Remember, permissions and
    ownership are discussed in the next chapter, so no need to worry about this for
    now. The most important thing to take away from this is that each file/directory
    is printed on its own line, where the first character of that line denotes the
    type of file: `d` for directory, `-` for regular file, and `l` for symlinks (which
    are shortcuts under Linux).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls`命令的选项`-l`（连字符小写l，如*long*）提供了**长列表格式**。除其他外，这会打印权限、文件/目录的所有者、文件类型和大小。请记住，权限和所有权将在下一章中讨论，所以现在不需要担心这些。从中最重要的是，每个文件/目录都会单独打印在自己的一行上，该行的第一个字符表示文件类型：`d`表示目录，`-`表示普通文件，`l`表示符号链接（在Linux下是快捷方式）。'
- en: 'Let''s navigate deeper into the tree structure, back *toward* our `home` directory.
    At this point, you have two options. You can use a **relative path** (as in: relative
    to the current location) or a **fully qualified path** (which is *not* relative
    to the current directory). Let''s try both:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入树结构，回到我们的`home`目录。此时，你有两个选择。你可以使用**相对路径**（即：相对于当前位置）或**全路径**（*不*相对于当前目录）。让我们都试一下：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding is an example of changing directories into a relative directory.
    We were positioned in the root directory, `/`, and we navigated to home from there,
    effectively ending up in `/home`. We could have navigated there from anywhere
    by using the fully qualified path:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述是进入相对目录的示例。我们位于根目录`/`，然后从那里导航到home，最终到达`/home`。我们可以使用全路径从任何地方导航到那里：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Did you spot the difference? In the fully qualified example, the argument to
    `cd` started with a slash, but in the relative example it did not. Let''s see
    what happens if you use both types incorrectly:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了区别吗？在全路径示例中，`cd`的参数以斜杠开头，但在相对示例中没有。让我们看看如果你使用这两种类型时会发生什么错误：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We listed the contents of the `/home` directory with `ls`. As expected, we
    saw (at least) the current user''s home directory, `reader`. However, when we
    tried to navigate to it using `cd /reader`, we got the infamous error `No such
    file or directory`. This is not surprising though: there isn''t actually a directory
    `/reader`. The directory we''re looking for is `/home/reader`, which would be
    reached fully qualified with the command `cd /home/reader`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ls`列出了`/home`目录的内容。如预期的那样，我们看到（至少）当前用户的主目录`reader`。然而，当我们尝试使用`cd /reader`导航到它时，我们得到了臭名昭著的错误`No
    such file or directory`。尽管这并不令人意外：实际上并没有一个目录`/reader`。我们要找的目录是`/home/reader`，可以使用命令`cd
    /home/reader`全路径到达：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The same error is presented if we try to use an incorrect relative path. In
    the preceding example, we are currently located in the `/home` directory and we
    use the `cd home` command. Effectively, this would put us in `/home/home`, which,
    as we saw when we used `ls` in the `/home` directory, does not exist!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用不正确的相对路径，也会出现相同的错误。在上面的示例中，我们当前位于`/home`目录，然后使用`cd home`命令。实际上，这会把我们放在`/home/home`，就像我们在`/home`目录中使用`ls`时看到的那样，这个目录并不存在！
- en: 'The safest way to navigate around Linux is fully qualified: as long as you
    have the correct directory, it always works, no matter where you are currently
    located on the filesystem. However, especially when you get deeper into the filesystem,
    you''re typing a lot more. We always recommend beginning users to start with fully
    qualified navigation and switch to relative once they''re comfortable with the
    `cd`, `ls`, and `pwd` commands.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中安全地导航的最佳方式是全路径：只要你有正确的目录，它总是有效的，无论你当前位于文件系统的何处。然而，特别是当你深入文件系统时，你需要输入更多。我们始终建议初学者从全路径导航开始，一旦他们熟悉了`cd`、`ls`和`pwd`命令，就可以切换到相对路径。
- en: 'Even though fully qualified is safer, it''s much less efficient then relative.
    You saw how we can move deeper into the branches of the tree structure, but what
    if you had to go down a level, back toward the root? Luckily for us, that does
    not force us to use fully qualified paths. We can use the `..` notation, which
    means as much as go up a level toward `/`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管全路径更安全，但比起相对路径效率要低得多。你看到了我们如何可以深入树结构的分支，但如果你需要向下一级，回到根呢？幸运的是，这并不强迫我们使用全路径。我们可以使用`..`符号，这意味着向上一级，朝着`/`：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A note on terminology is in order here. While we conceptualized the filesystem
    as a tree, when talking about the root directory, we consider this as the *highest
    point* in the filesystem. So when moving from `/` to `/home`, we're moving *down*.
    If we use the command `cd ..` to move back to `/`, we're moving *up*. While we
    think that this doesn't really match with the picture of a tree (where the root
    is actually the *lowest* point), please remember this convention!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意一下术语。虽然我们将文件系统构想为一棵树，但在谈到根目录时，我们将其视为文件系统中的*最高点*。因此，从`/`移动到`/home`时，我们是在*向下*移动。如果我们使用`cd
    ..`命令移回`/`，我们是在*向上*移动。虽然我们认为这实际上与树的图像不太匹配（根实际上是*最低*点），但请记住这个约定！
- en: 'Using `cd ..` to move up lands us back at the root of the filesystem. At this
    point, you might think *If I do this again while I''m on the highest level of
    the filesystem*, *what would happen?*. Give it a try:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`cd ..`向上移动会使我们回到文件系统的根目录。此时，你可能会想*如果我在文件系统的最高级别再次这样做，会发生什么？*试一试：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Fortunately for us, we do not get an error nor a crashing machine; instead,
    we just end up (or, depending on how you look at it, stay) on the root of the
    filesystem.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说幸运的是，我们没有收到错误，也没有崩溃的机器；相反，我们只是最终到达（或者，取决于你的看法，停留在）文件系统的根目录。
- en: 'A source of confusion among new users of Linux is often the term **root**.
    It can stand for any of three things:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Linux新用户经常困惑的一个术语是**root**。它可以代表以下三种情况之一：
- en: The lowest point in the filesystem, at `/`
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件系统中的最低点，在`/`
- en: The default superuser, named just `root`
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认的超级用户，名为`root`
- en: The default superuser's home directory, at `/root/`
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认超级用户的主目录，在`/root/`
- en: 'Often, it is left to the reader to use context to determine which of the three
    is meant. When talking in the context of filesystems, it will probably be:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，读者需要根据上下文来确定指的是这三者中的哪一个。当谈论文件系统的上下文时，可能是：
- en: If it seems to be referring to a *user*, you can expect it to mean the root
    user
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它似乎是在提到*用户*，你可以期望它指的是root用户
- en: Only when talking about the root user's home directory or `/root/` should  you
    think of
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有在谈论根用户的主目录或`/root/`时，你应该考虑
- en: Most often, you will encounter root to mean either 1 or 2!
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最常见的是，你会发现root指的是1或2！
- en: Overview of top-level directories
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶级目录概述
- en: 'Now that we''ve got the basics of moving around using `cd` and listing directory
    contents using `ls` under control, let''s start exploring other parts of the filesystem.
    Let''s begin with an overview of every directory directly under the root filesystem,
    as specified by the FHS:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了使用`cd`移动和使用`ls`列出目录内容的基础知识，让我们开始探索文件系统的其他部分。让我们从根文件系统下直接的每个目录的概述开始，如FHS所指定的：
- en: '| **Location** | **Purpose** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **位置** | **目的** |'
- en: '| `/bin/` | Contains essential **bin**aries (=tools) used by normal users |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `/bin/` | 包含普通用户使用的基本**工具**（=工具） |'
- en: '| `/boot/` | Contains files used in the **boot** process: `kernel`, `initramfs`,
    `bootloader` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `/boot/` | 包含**启动**过程中使用的文件：`kernel`，`initramfs`，`bootloader` |'
- en: '| `/dev/` | Contains special files used to access **dev**ices |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `/dev/` | 包含用于访问**设备**的特殊文件 |'
- en: '| `/etc/` | Default location for software configuration files |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `/etc/` | 软件配置文件的默认位置 |'
- en: '| `/home/` | Contains the **home** directories for normal users |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `/home/` | 包含普通用户的**主目录** |'
- en: '| `/lib/` | Contains system **lib**raries |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `/lib/` | 包含系统**库** |'
- en: '| `/lib64/` | Contains **64**bit system **lib**raries |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `/lib64/` | 包含**64**位系统**库** |'
- en: '| `/media/` | Removable devices such as USB and DVDs can be found here |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `/media/` | 可移动设备，如USB和DVD，可以在这里找到 |'
- en: '| `/mnt/` | Empty by default, can be used to **mount** other filesystems |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `/mnt/` | 默认为空，可以用来**挂载**其他文件系统 |'
- en: '| `/opt/` | Directory where **opt**ional software can be installed |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `/opt/` | 可以安装**可选**软件的目录 |'
- en: '| `/proc/` | Directory where information about **proc**esses is stored |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `/proc/` | 存储有关**进程**的信息的目录 |'
- en: '| `/root/` | The home directory of the **root** user |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `/root/` | **root**用户的主目录 |'
- en: '| `/run/` | Contains variable data about **run**-time data, different each
    boot |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `/run/` | 包含关于**运行**时数据的可变数据，每次启动都不同 |'
- en: '| `/sbin/` | Contains essential **s**ytem **bin**aries (=tools) used by administrative
    users |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `/sbin/` | 包含管理员用户使用的基本**系统**工具（=工具） |'
- en: '| `/srv/` | Directory to place data to be **serv**ed by the server |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `/srv/` | 放置服务器**服务**的数据的目录 |'
- en: '| `/sys/` | Contains information about the **sys**tem, such as drivers and
    kernel features |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `/sys/` | 包含有关**系统**的信息，如驱动程序和内核功能 |'
- en: '| `/tmp/` | Directory intended for **temp**orary files, often cleared on reboot
    (because it is stored in RAM, instead of on disk) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `/tmp/` | 用于**临时**文件的目录，通常在重新启动时清除（因为它存储在RAM中，而不是在磁盘上） |'
- en: '| `/usr/` | Contains non-essential files and binaries as read-only **user**
    data |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `/usr/` | 包含只读**用户**数据的非必要文件和二进制文件 |'
- en: '| `/var/` | Contains **var**iable files, such as logs |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `/var/` | 包含**变量**文件，如日志 |'
- en: While each and every **top-level directory** has an important function, there
    are a few we're going to examine more closely since we're undoubtedly going to
    encounter them in our shell scripting. These are `/bin/`, `/sbin/`, `/usr/`, `/etc/`,
    `/opt/`, `/tmp/`, and `/var/`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个**顶级目录**都有重要的功能，但有一些我们将更仔细地检查，因为我们肯定会在我们的shell脚本中遇到它们。这些是`/bin/`，`/sbin/`，`/usr/`，`/etc/`，`/opt/`，`/tmp/`和`/var/`。
- en: What about multiple partitions?
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个分区呢？
- en: But first, we'd like to briefly address something you might have found confusing,
    especially if you're coming from a Windows background where you're used to multiple
    disks/partitions in the form of `C:\`, `D:\`, `E:\`, and so on. With the preceding
    directory structure, and the information that the highest point in the filesystem
    is at `/`, how does Linux deal with multiple disks/partitions?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们想简要解释一些可能让你感到困惑的事情，特别是如果你来自Windows背景，习惯于`C:\`，`D:\`，`E:\`等形式的多个磁盘/分区。有了前面的目录结构和最高点在`/`的信息，Linux如何处理多个磁盘/分区？
- en: 'The answer is actually pretty simple. Linux *mounts* filesystems somewhere
    within the tree structure. The first mount is found on the primary partition we
    have already covered: it is mounted on `/`! Let''s see how this looks while we
    check out a new `df` tool:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 答案实际上相当简单。Linux在树结构中的某个位置*挂载*文件系统。第一个挂载点位于我们已经介绍过的主分区上：它被挂载在`/`上！让我们看看在我们检查新的`df`工具时它是什么样子：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'While this is a lot of output by `df` (which *reports filesystem disk space
    usage*), the most interesting was highlighted previously: the partition `/dev/sda2`
    of type `ext4` (remember?) is mounted on `/`. You''re getting a preview of the
    *everything is a file* later in this chapter: `/dev/sda2` is handled as a file,
    but it is actually a reference to a partition on the disk (which is, in this case,
    a virtual disk). Another example from our Arch Linux host gives even more information
    (don''t worry if you don''t have a Linux host, we''ll explain later):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是`df`（*报告文件系统磁盘空间使用情况*）的大量输出，但最有趣的是之前突出显示的：类型为`ext4`（记得吗？）的分区`/dev/sda2`被挂载在`/`上。你将在本章后面看到*一切都是文件*的预览：`/dev/sda2`被处理为文件，但实际上是对磁盘上的分区的引用（在这种情况下是虚拟磁盘）。我们的Arch
    Linux主机的另一个示例提供了更多信息（如果你没有Linux主机，不用担心，我们以后会解释）：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can see I have an `ext4` filesystem mounted as my root. However, I also
    have an extra `btrfs` partition mounted on `/data/` and a `vfat` boot partition
    (which is needed on bare-metal installations, but not on virtual machines) on
    `/boot/`. To top it off, there's also a `vfat` USB device with the Arch Linux
    installer connected, which was automatically mounted under `/run/media/`. So not
    only does Linux handle multiple partitions or disks gracefully, even different
    types of filesystems can be used side by side under the same tree structure!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我有一个`ext4`文件系统挂载在我的根目录。然而，我还有一个额外的`btrfs`分区挂载在`/data/`上，以及一个`vfat`引导分区（在裸机安装时需要，但在虚拟机上不需要）挂载在`/boot/`上。最后，还有一个连接着Arch
    Linux安装程序的`vfat` USB设备，它被自动挂载在`/run/media/`下。因此，Linux不仅可以优雅地处理多个分区或磁盘，甚至不同类型的文件系统也可以在同一树结构下并存！
- en: /bin/, /sbin/, and /usr/
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: /bin/、/sbin/和/usr/
- en: 'Let''s get back to top-level directories. We''ll discuss `/bin/`, `/sbin/`,
    and `/usr/` first, because they are really similar. As stated in the overview,
    all of these directories contain binaries used by normal users and administrators
    of the system. Let''s see where those binaries are and how our user session knows
    how to find them in the process. We''ll manage this by using the `echo` command.
    Its short description is simply display a line of text. Let''s see how it works:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到顶级目录。我们将首先讨论`/bin/`、`/sbin/`和`/usr/`，因为它们非常相似。正如概述中所述，所有这些目录都包含了系统的普通用户和管理员使用的二进制文件。让我们看看这些二进制文件在哪里，以及我们的用户会话如何在进程中找到它们。我们将使用`echo`命令来管理这个过程。它的简短描述只是显示一行文本。让我们看看它是如何工作的：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we use `echo` without passing an argument, an empty line of text is displayed
    (pretty much just as promised by the short description!). If we pass text, which
    we enclose in single quotes, that text is printed instead. In this context, a
    bit of text which contains either letters, numbers, or other characters is referred
    to as a **string**. So, any string we pass to `echo` will be printed in our Terminal.
    While this might not seem that interesting, it is interesting when you start to
    consider **variables**. A variable is a string which value is, as the name implies,
    variable from time to time. Let''s use `echo` to print the current value of the
    variable `BASH_VERSION`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`echo`而没有传递参数，将显示一行空白文本（基本上就像简短描述所承诺的那样！）。如果我们传递文本，将其用单引号括起来，那么该文本将被打印出来。在这种情况下，包含字母、数字或其他字符的文本被称为**字符串**。因此，我们传递给`echo`的任何字符串都将在我们的终端中打印出来。虽然这可能看起来不那么有趣，但当你开始考虑**变量**时，它就变得有趣了。变量是一个值会随时间变化的字符串，正如其名称所暗示的那样。让我们使用`echo`来打印变量`BASH_VERSION`的当前值：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should notice we did not use the `echo BASH_VERSION` command, since that
    would print the literal text `BASH_VERSION`, but we instead started the variable
    name with a `$`. In Bash, the `$` denotes the fact that we''re using a variable
    (we will explain *variables* and *variable interpolation* further in [Chapter
    8](41d3c327-f6d6-4ec5-8ec9-127e493bdd05.xhtml), *Variables and User Input*). Why
    are we telling you this? Because the binaries we can use from our Terminal are
    found by using a variable, specifically the `PATH` variable:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到我们没有使用`echo BASH_VERSION`命令，因为那样会打印出文字`BASH_VERSION`，而是我们用`$`符号开始了变量名。在Bash中，`$`表示我们正在使用一个变量（我们将在[第8章](41d3c327-f6d6-4ec5-8ec9-127e493bdd05.xhtml)中进一步解释*变量*和*变量插值*）。为什么我们告诉你这个？因为我们可以从我们的终端使用的二进制文件是通过使用一个变量找到的，具体来说是`PATH`变量：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see here, binaries need to be in the `/usr/local/sbin/`, `/usr/local/bin/`,
    `/usr/sbin/`, `/usr/bin/`, `/sbin/`, or `/bin/` directory for us to be able to
    use them (with the current value of `PATH`, which we can change, but that''s out
    of scope for now). That would mean that binaries we''ve been using up until now
    (`cd`, `ls`, `pwd`, and `echo`) would need to be in one of these directories so
    that we can use them, right? Unfortunately, this is where things get slightly
    complicated. On Linux, we basically use two types of binaries: those that are
    found on disk (in a directory as specified by the `PATH` variable), or they can
    be built into the shell we''re using, then called a *shell builtin*. A good example
    is actually the `echo` command we just learned, which is both! We can see what
    type of command we''re dealing with by using `type`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，二进制文件需要在`/usr/local/sbin/`、`/usr/local/bin/`、`/usr/sbin/`、`/usr/bin/`、`/sbin/`或`/bin/`目录中才能使用（使用当前值的`PATH`，我们可以更改，但这暂时超出了范围）。这意味着我们到目前为止使用的二进制文件（`cd`、`ls`、`pwd`和`echo`）需要在这些目录中的一个中才能使用，对吗？不幸的是，这就是事情变得稍微复杂的地方。在Linux上，我们基本上使用两种类型的二进制文件：在磁盘上找到的（在`PATH`变量指定的目录中），或者它们可以内置到我们正在使用的shell中，然后称为*shell内置*。一个很好的例子实际上是我们刚学到的`echo`命令，它两者都是！我们可以使用`type`来查看我们正在处理的命令的类型：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If a command is both built-in and a binary within the `PATH`, the binary is
    used. If it is only present as a built-in, such as `cd`, the built-in is used.
    As a general rule, most commands you use will be binaries on disk, as found in
    your `PATH`. Furthermore, most of these will be present in the `/usr/bin/` directory
    (on our Ubuntu virtual machine, more than half of the total binaries are present
    in `/usr/bin/`!).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个命令既是内置命令又是`PATH`中的二进制文件，则使用二进制文件。如果它只存在于内置命令中，比如`cd`，则使用内置命令。一般来说，你使用的大多数命令都是磁盘上的二进制文件，在你的`PATH`中找到。此外，这些命令中大多数都存在于`/usr/bin/`目录中（在我们的Ubuntu虚拟机上，超过一半的二进制文件都存在于`/usr/bin/`中！）。
- en: 'So, the overall goal of the binary directories should be clear: to provide
    us with the tools we need to perform our work. The question remains, why are there
    (at least) six different directories, and why are they divided between `bin` and
    `sbin`? The answer to the last part of the question is easy: `bin` has normal
    utilities used by users, while `sbin` has utilities used by system administrators.
    In that last category, tools related to disk maintenance, network configuration,
    and firewalling, for example, are found. The `bin` directories contain utilities
    that are used for filesystem operations (such as creating and removing files/directories),
    archiving, and listing information about the system, among others.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，二进制目录的总体目标应该是清楚的：为我们提供执行工作所需的工具。问题仍然存在，为什么有（至少）六个不同的目录，它们为什么分为`bin`和`sbin`？对于问题的最后一部分的答案很容易：`bin`包含用户使用的常规实用程序，而`sbin`包含系统管理员使用的实用程序。在最后一类中，可以找到与磁盘维护、网络配置和防火墙等相关的工具。`bin`目录包含用于文件系统操作（例如创建和删除文件/目录）、存档和列出系统信息等的实用程序。
- en: The difference between the top-level `/(s)bin/` and `/usr/(s)bin/` is a bit
    more vague. In general, the rule is that essential tools are found in `/(s)bin`,
    while system-specific binaries are placed in the `/usr/(s)bin` directories. So
    if you installed a package to run a web server, it would be placed in either `/usr/bin/`
    or `/usr/sbin/`, since it is system-specific. Finally, the `/usr/local/(s)bin/`
    directories are, in our experience, most often used for binaries that are installed
    manually, instead of from a package manager. But you could place them in either
    directory of the `PATH` to work; it's mostly a matter of convention.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级目录`/(s)bin/`和`/usr/(s)bin/`之间的区别有点模糊。一般来说，基本工具可以在`/(s)bin`中找到，而系统特定的二进制文件则放在`/usr/(s)bin`目录中。因此，如果你安装了一个用于运行Web服务器的软件包，它将被放置在`/usr/bin/`或`/usr/sbin/`中，因为它是系统特定的。最后，根据我们的经验，`/usr/local/(s)bin/`目录最常用于手动安装的二进制文件，而不是从软件包管理器中安装。但你可以将它们放在`PATH`的任一目录中工作；这主要是一种惯例问题。
- en: As a final note, `/usr/` contains more than just binaries. Among these are some
    libraries (which have the same relation to the `/lib/` and `/lib64/` top-level
    directories) and some miscellaneous files. If you're curious, we would definitely
    recommend checking out the rest of the `/usr/` directory using `cd` and `ls`,
    but the most important thing to remember is that **binaries** and **libraries**
    can be located here.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`/usr/`包含的不仅仅是二进制文件。其中包括一些库（与`/lib/`和`/lib64/`顶级目录具有相同关系）和一些杂项文件。如果你感兴趣，我们绝对建议使用`cd`和`ls`来查看`/usr/`目录的其余部分，但最重要的是要记住**二进制文件**和**库**可以在这里找到。
- en: /etc/
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: /etc/
- en: 'On to the next interesting top-level directory within the Linux filesystem:
    the `/etc/` directory. Pronounced *et-c* as in *et-cetera*, it is used to store
    configuration files for both system software as well as user software. Let''s
    see what it contains:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是Linux文件系统中另一个有趣的顶级目录：`/etc/`目录。发音为*et-c*，用于存储系统软件和用户软件的配置文件。让我们看看它包含了什么：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We snipped the preceding output to only the top line of our system. If you
    followed along with the example (and you should!) you will see well over 150 files
    and directories. We will print a particularly interesting one using the `cat`
    command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剪掉了前面的输出，只保留了我们系统的顶行。如果你跟着这个例子（你应该这样做！）你会看到超过150个文件和目录。我们将使用`cat`命令打印一个特别有趣的文件：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What we're seeing here is the **f**ile **s**ystems **tab**le, or `fstab` file.
    It contains the instructions for Linux to mount the filesystems at each start.
    As we can see here, we're referencing a partition by its **Universally Unique
    Identifier** (**UUID**) and we're mounting it on `/`, so as the root filesystem.
    It's of type `ext4`, mounted using options `defaults`. The last two zeros deal
    with backups and checks at the start of the system. On the second line, we see
    we're using a file as swap space. Swap is used in case there isn't enough memory
    available to the system, which can be compensated for by writing it to disk (but
    incurring a hefty performance penalty, since a disk is much slower than RAM).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是**文件系统表**，或者`fstab`文件。它包含了Linux在每次启动时挂载文件系统的指令。正如我们在这里看到的，我们通过**通用唯一标识符**（**UUID**）引用一个分区，并将其挂载在`/`上，作为根文件系统。它的类型是`ext4`，使用`defaults`选项挂载。最后的两个零处理系统启动时的备份和检查。在第二行，我们看到我们正在使用一个文件作为交换空间。交换空间用于在系统没有足够的内存可用时使用，可以通过将其写入磁盘来补偿（但会导致严重的性能损失，因为磁盘比RAM慢得多）。
- en: 'Another interesting configuration file in the `/etc/` directory is the `passwd`
    file. While it sounds like *password*, don''t worry, those aren''t stored there.
    Let''s check the contents using the `less` command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/`目录中的另一个有趣的配置文件是`passwd`文件。虽然听起来像*密码*，但别担心，密码并没有存储在那里。让我们使用`less`命令查看内容：'
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will open the file in a so-called pager, in read-only mode. `less` uses
    Vim commands, so you can quit by pressing the *Q* on your keyboard. If the file
    is larger than your screen, you can navigate up and down with the Vim keystrokes:
    either the arrow keys or by using *J* and *K*. When in the `less`, the screen
    should look something like the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以只读模式在所谓的分页器中打开文件。`less`使用Vim命令，所以你可以通过在键盘上按*Q*来退出。如果文件比你的屏幕大，你可以使用Vim的按键：箭头键或使用*J*和*K*来上下导航。在`less`中，屏幕应该看起来像下面这样：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This file contains information about all users on the system. In order, the
    fields separated by the `:` denote the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件包含了系统上所有用户的信息。按顺序，由`:`分隔的字段表示以下内容：
- en: '| Username | Password | User ID (UID) | Group ID (GID) | User real name | Home
    directory | Users'' default shell |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 用户名 | 密码 | 用户ID（UID） | 组ID（GID） | 用户真实姓名 | 主目录 | 用户默认shell |'
- en: While there is a password field here, this is because of legacy reasons; the
    (hashed!) password has been moved to the `/etc/shadow` file, which can only be
    read by the root superuser. We will cover the UID and GID in the next chapter;
    the other fields should be clear by now.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这里有一个密码字段，但这是出于传统原因；（哈希！）密码已经移动到`/etc/shadow`文件中，只有root超级用户才能读取。我们将在下一章中讨论UID和GID；其他字段现在应该是清楚的。
- en: These are just two examples of configuration files found in the `/etc/` directory
    (important ones though!).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是在`/etc/`目录中找到的配置文件的两个例子（尽管很重要！）。
- en: /opt/, /tmp/, and /var/
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`/opt/`，`/tmp/`和`/var/`'
- en: On a fresh installation of Ubuntu, the `/opt/` directory is empty. While it
    is again a matter of convention, in our experience, this directory is most often
    used to install software that comes from outside the distribution's package manager.
    However, some applications that are installed with the package manager do use
    `/opt/` for their files; it's all a matter of preference by the package maintainer.
    In our case, we will be using this directory *to save the shell scripts* we'll
    be creating, as these definitely classify as optional software.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu的新安装中，`/opt/`目录是空的。虽然这又是一个惯例问题，但根据我们的经验，这个目录最常用于安装来自发行版软件包管理器之外的软件。但是，一些使用软件包管理器安装的应用程序确实使用`/opt/`来存储它们的文件；这完全取决于软件包维护者的偏好。在我们的情况下，我们将使用这个目录*来保存我们将要创建的shell脚本*，因为这些绝对属于可选软件。
- en: The `/tmp/` directory is used for temporary files (who would have guessed?).
    In some Linux distributions, `/tmp/` is not part of the root partition but mounted
    as a separate **tmpfs** filesystem. This type of filesystem is allocated within
    the RAM, which means the contents of `/tmp/` do not survive a reboot. Since we're
    dealing with temporary files, this is sometimes not only a nice feature, but a
    prerequisite for particular uses. For a desktop Linux user, this could for example
    be used to save a note which is only needed during the active session, without
    having to worry about cleaning it up after you're done.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`/tmp/`目录用于临时文件（谁会猜到呢？）。在一些Linux发行版中，`/tmp/`不是根分区的一部分，而是作为单独的**tmpfs**文件系统挂载的。这种类型的文件系统是在RAM中分配的，这意味着`/tmp/`的内容在重新启动后不会存活。由于我们处理临时文件，这有时不仅是一个很好的功能，而且是特定用途的先决条件。例如，对于桌面Linux用户，可以用来保存只在活动会话期间需要的笔记，而无需担心在完成后清理它。'
- en: 'Finally, the `/var/` directory is a little more complex. Let''s have a look:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`/var/`目录稍微复杂一些。让我们来看看：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you should see, `/var/` contains many subdirectories and some symlinks (which
    are denoted by the `->` characters). In this case, `/var/run/` is actually a shortcut
    to the top-level directory `/run`. The most interesting subdirectories within
    `/var/` (for now) are `log/` and `mail/`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`/var/`包含许多子目录和一些符号链接（由`->`字符表示）。在这种情况下，`/var/run/`实际上是指向顶级目录`/run`的快捷方式。`/var/`中最有趣的子目录（目前）是`log/`和`mail/`。
- en: '`/var/log/` is conventionally used to save log files for most system and user
    processes. In our experience, most third-party software installed on a Linux system
    will adhere to this convention and will output log files to the `/var/log/` directory,
    or create a subdirectory in `/var/log/`. Let''s look at an example of a log file
    using `less` with a fully qualified path:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`/var/log/`通常用于保存大多数系统和用户进程的日志文件。根据我们的经验，在Linux系统上安装的大多数第三方软件都会遵守这个惯例，并将日志文件输出到`/var/log/`目录，或者在`/var/log/`中创建一个子目录。让我们看一个使用`less`的完全限定路径的日志文件的例子：'
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the `less` pager, you''ll encounter something which looks similar to the
    following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`less`分页器中，您将遇到类似以下内容的东西：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This log file contains information about the kernel boot process. You can see
    a reference to the actual kernel on disk, `/boot/vmlinuz-4.15.0-23-generic`, and
    the UUID of the filesystem being mounted at root, `UUID=376cd784-7c8f-11e8-a415-080027a7d0ea`.
    This file would be something you would check if your system has trouble booting
    or if some functionality does not seem to be working!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个日志文件包含有关内核引导过程的信息。您可以看到对磁盘上实际内核的引用，`/boot/vmlinuz-4.15.0-23-generic`，以及挂载在根目录的文件系统的UUID，`UUID=376cd784-7c8f-11e8-a415-080027a7d0ea`。如果您的系统在启动时出现问题或某些功能似乎无法正常工作，您将检查此文件！
- en: In the earliest days of Unix and Linux, sending mail was something that wasn't
    only used over the internet (which was in its mere infancy at that time), but
    also to relay messages between servers or users on the same server. On your new
    Ubuntu virtual machine, the `/var/mail/` directory and its symlink, `/var/spool/mail/`,
    will be empty. However, once we start talking about scheduling and logging, we
    will see that this directory will be used to store messages.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix和Linux的早期，发送邮件不仅仅是在互联网上使用（当时互联网还处于萌芽阶段），还用于在服务器或同一服务器上的用户之间中继消息。在您的新Ubuntu虚拟机上，`/var/mail/`目录及其符号链接`/var/spool/mail/`将是空的。但是，一旦我们开始讨论调度和日志记录，我们将看到该目录将用于存储消息。
- en: That concludes the short description about the top-level directories in the
    default Linux filesystem. We discussed the most important ones, in our eyes, when
    relating to shell scripting. However, in time, you will get a feeling for all
    directories and finding anything on the Linux filesystem will surely get a lot
    easier, as difficult as it might sound right now.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于默认Linux文件系统中顶级目录的简要描述。我们讨论了我们认为与shell脚本相关的最重要的目录。然而，随着时间的推移，您将对所有目录有所了解，并且在Linux文件系统中找到任何东西肯定会变得更容易，尽管现在可能听起来很困难。
- en: Everything is a file
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切都是文件
- en: 'Under Linux, there is a well-known expression:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux下，有一个众所周知的表达：
- en: On a Linux system, everything is a file; if something is not a file, it is a
    process.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux系统中，一切都是文件；如果某物不是文件，那就是一个进程。
- en: While this is not strictly 100% true, it is true for at least 90% of things
    you will encounter on Linux, definitely if you're not very advanced yet. Even
    though, in general, this rule works out, it has some extra notes. While most stuff
    on Linux is a file, there are different file types, seven to be exact. We'll discuss
    them all in the coming pages. You will probably not use all seven; however, having
    basic knowledge about them all gives you a better understanding about Linux in
    general, something which is never a bad thing!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不是严格意义上的100%真实，但至少对于您在 Linux 上遇到的90%的事情来说是真实的，特别是如果您还不是很高级的话。尽管一般来说，这个规则是成立的，但它还有一些额外的注意事项。尽管
    Linux 上的大部分东西都是文件，但有不同的文件类型，确切地说是七种。我们将在接下来的页面上讨论它们。您可能不会使用所有七种；但是，对它们都有基本的了解可以让您更好地理解
    Linux，这绝对是一件好事！
- en: Different types of files
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的文件
- en: 'The seven types of files are as follows, denoted with the character used by
    Linux to represent them:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这七种文件类型如下，用 Linux 用来表示它们的字符：
- en: '| **Type** | **Explanation** |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **解释** |'
- en: '| `-`: Normal file | A regular file, containing text or bytes |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `-`: 常规文件 | 一个包含文本或字节的常规文件 |'
- en: '| `d`: Directory | A directory, which can contain other directories and regular
    files |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `d`: 目录 | 一个目录，可以包含其他目录和常规文件 |'
- en: '| `l`: Symlink | Symbolic link, used as a shortcut |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `l`: 符号链接 | 用作快捷方式 |'
- en: '| `s`: Socket | A channel used for communication |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `s`: 套接字 | 用于通信的通道 |'
- en: '| `c`: Special file | Mostly used for device handlers |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `c`: 特殊文件 | 主要用于设备处理程序 |'
- en: '| `b`: Block device | The type that represents storage hardware, such as disk
    partitions |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `b`: 块设备 | 表示存储硬件的类型，如磁盘分区 |'
- en: '| `p`: Named pipe | Used between processes to talk to each other |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `p`: 命名管道 | 用于进程之间进行通信 |'
- en: 'Out of these seven file types, you will first encounter just the regular files
    (`-`) and the directories (`d`). Next, you will probably interact some more with
    symlinks (`l`), block devices (`b`), and special files (`c`). Very rarely will
    you use the last two: sockets (`s`) and named pipes (`p`).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这七种文件类型中，您首先会遇到常规文件（`-`）和目录（`d`）。接下来，您可能会更多地与符号链接（`l`）、块设备（`b`）和特殊文件（`c`）进行交互。很少会使用最后两种：套接字（`s`）和命名管道（`p`）。
- en: 'A good place to encounter the most common file types is in `/dev/`. Let''s
    use `ls` to see what it contains:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/dev/` 中遇到最常见的文件类型是一个不错的地方。让我们使用 `ls` 命令来查看它包含了什么：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As you saw from your output, `/dev/` contains a lot of files, with most of
    the types as outlined above. Ironically, it does not contain the most common file
    type: regular files. However, because we have been interacting with regular files
    until now, you should have an idea about what they are (and otherwise the rest
    of the book will *definitely* give you an idea).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从输出中看到的那样，`/dev/` 包含了大量文件，其中大多数类型如上所述。具有讽刺意味的是，它不包含最常见的文件类型：常规文件。但是，因为我们一直在与常规文件交互，所以您应该对它们有所了解（否则本书的其余部分肯定会给您一个概念）。
- en: 'So, let''s look at anything other than a regular file. Let''s start with the
    most familiar: directories. Any line that starts with a `d` is a directory, and,
    if you''re using SSH, will most probably be represented in a different color as
    well. Do not underestimate how important this visual aid is, as it will save you
    a lot of time when you''re navigating a Linux machine. Remember, you can move
    into a directory by using either `cd` with a relative path or a fully qualified
    path, which always starts from the root of the filesystem.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看除了常规文件之外的任何东西。让我们从最熟悉的开始：目录。任何以 `d` 开头的行都是一个目录，如果您使用 SSH，它很可能也会以不同的颜色表示。不要低估这种视觉辅助的重要性，因为当您在
    Linux 机器上导航时，它会为您节省大量时间。记住，您可以使用相对路径或绝对路径（始终从文件系统的根目录开始）来进入目录，其中相对路径使用 `cd` 命令。
- en: 'Next, you will see files starting with the `b`. These files are used to represent
    `block` devices, the most common usage being a disk device or partition. Under
    most Linux distributions, disks are often called `/dev/sda`, `/dev/sdb`, and so
    on. Partitions on those disks are referred to with a number: `/dev/sda1`, `/dev/sda2`,
    and further. As you can see in the preceding output, our system has a single disk
    (only `/dev/sda`). That disk does, however, have two partitions: `/dev/sda1` and
    `/dev/sda2`. Try using `df -hT` again, and you will notice `/dev/sda2` mounted
    as the root filesystem (unless your virtual machine was configured differently,
    in which case it might be `/dev/sda1` or even `/dev/sda3`).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将看到以 `b` 开头的文件。这些文件用于表示 `块` 设备，最常见的用途是磁盘设备或分区。在大多数 Linux 发行版中，磁盘通常被称为 `/dev/sda`、`/dev/sdb`
    等。这些磁盘上的分区用数字表示：`/dev/sda1`、`/dev/sda2` 等。正如您在前面的输出中所看到的，我们的系统只有一个磁盘（只有 `/dev/sda`）。但是该磁盘有两个分区：`/dev/sda1`
    和 `/dev/sda2`。再次尝试使用 `df -hT` 命令，您会注意到 `/dev/sda2` 被挂载为根文件系统（除非您的虚拟机配置不同，否则可能是
    `/dev/sda1` 或甚至 `/dev/sda3`）。
- en: 'Symlinks are often used on Linux. Look in the preceding output for the entry
    `cdrom`, which you will see starts with an `l`. The term `cdrom` has contextual
    meaning: it refers to the CD (or more probably, in a newer system, the DVD) drive.
    However, it is linked to the actual block device that handles the interaction,
    `/dev/sr0`, which starts with the `b` for block device. Using a symlink makes
    it easy to find the item you need (the disk drive) while still preserving the
    Linux configuration which calls the device handler `sr0`.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '在 Linux 上经常使用符号链接。在前面的输出中查找条目 `cdrom`，您会看到它以 `l` 开头。术语 `cdrom` 具有上下文意义：它指的是
    CD（或更可能是在新系统中，DVD）驱动器。但是，它链接到处理交互的实际块设备 `/dev/sr0`，它以 `b` 开头表示块设备。使用符号链接可以轻松找到您需要的项目（磁盘驱动器），同时仍然保留
    Linux 配置，调用设备处理程序 `sr0`。 '
- en: Finally, you should see a long list of files called `tty`. These are denoted
    by a `c` at the beginning of the line, indicating a special file. To keep it simple,
    you should consider a `tty` as a Terminal you use to connect to your Linux server.
    These are a kind of virtual device that Linux uses to allow interaction from the
    user with the system. Many virtual and physical devices use the special file handlers
    when they appear on your Linux filesystem.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您应该看到一个名为“tty”的文件的长列表。这些文件的开头标有“c”，表示特殊文件。为了简单起见，您应该将“tty”视为连接到Linux服务器的终端。这些是Linux用来允许用户与系统进行交互的一种虚拟设备。许多虚拟和物理设备在它们出现在Linux文件系统上时使用特殊文件处理程序。
- en: 'This chapter introduced you to many commands. Perhaps you have gotten sick
    of typing everything already, perhaps not. In any case, we have some good news:
    Bash has something called autocomplete. It is something we did not want to introduce
    to early as to avoid confusion, but it is something that is used so extensively
    when working with a Linux system that we would be cheating you if we had not explained
    it.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了许多命令。也许您已经厌倦了一切都要手动输入，也许没有。无论如何，我们有一些好消息：Bash有一个叫做自动完成的功能。我们不想过早介绍它以避免混淆，但在使用Linux系统时，它被广泛使用，如果我们不解释它，我们就会欺骗您。
- en: 'It''s actually pretty simple: if you hit the *Tab* key after the first part
    of a command (such as `cd` or `ls`), it will complete your command if it has a
    single choice, or if you hit *Tab *again, it will present you a list of options.
    Go to `/`, type `cd`, and press *Tab *twice to see this in action. Moving into
    the `/home/` directory and pressing *Tab *once (after entering `cd`) will make
    it autocomplete with the only directory there is, saving you time!'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上很简单：如果在命令的第一部分（如`cd`或`ls`）后按下*Tab*键，如果只有一个选择，它将完成您的命令，或者如果再次按下*Tab*，它将向您呈现一个选项列表。转到`/`，输入`cd`，然后按两次*Tab*键，看看它是如何工作的。进入`/home/`目录并在输入`cd`后按一次*Tab*键将使其自动完成，只有一个目录，节省时间！
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we presented an overview of the Linux filesystem. We started
    with a short introduction on filesystems in general, before explaining what is
    unique about the Linux filesystem. Ext4, XFS, and Btrfs filesystem implementations
    were discussed, together with the journaling feature of these filesystems. Next,
    the FHS that Linux adheres to was explained in high level, before focusing on
    the more important parts of the Linux filesystem in detail. This was done by exploring
    parts of the tree structure that makes up the Linux filesystem. We explained that
    different filesystems can be used side by side, by mounting them somewhere inside
    the tree. We ended the chapter by explaining that (almost) everything on Linux
    is handled as a file, and we discussed the different file types that are used.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Linux文件系统的概述。我们首先简要介绍了一般文件系统，然后解释了Linux文件系统的独特之处。讨论了Ext4、XFS和Btrfs文件系统实现，以及这些文件系统的日志记录功能。接下来，解释了Linux遵循的FHS，然后详细介绍了Linux文件系统的更重要部分。这是通过探索构成Linux文件系统的树结构的部分来完成的。我们解释了可以在树的某个地方挂载不同的文件系统。最后，我们解释了在Linux上（几乎）一切都被处理为文件，并讨论了使用的不同文件类型。
- en: 'The following commands were introduced in this chapter: `pwd`, `cd`, `df`,
    `echo`, `type`, `cat`, and `less`. As a tip, the Bash autocomplete feature was
    explained.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了以下命令：`pwd`、`cd`、`df`、`echo`、`type`、`cat`和`less`。作为提示，解释了Bash自动完成功能。
- en: Questions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a filesystem?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是文件系统？
- en: Which Linux-specific filesystems are most common?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些Linux特定的文件系统最常见？
- en: 'True or false: multiple filesystem implementations can be used concurrently
    on Linux?'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：Linux上可以同时使用多个文件系统实现？
- en: What is the journaling feature present on most Linux filesystem implementations?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数Linux文件系统实现中存在的日志记录功能是什么？
- en: On which point in the tree is the root filesystem mounted?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根文件系统挂载在树的哪个位置？
- en: What is the `PATH` variable used for?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PATH`变量用于什么？'
- en: In which top-level directory are configuration files stored according to the
    FHS?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据FHS，配置文件存储在哪个顶级目录中？
- en: Where are process logs commonly saved?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程日志通常保存在哪里？
- en: How many file types does Linux have?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linux有多少种文件类型？
- en: How does the Bash autocomplete function work?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Bash自动完成功能是如何工作的？
- en: Further reading
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following resource might be interesting if you''d like to go deeper into
    the subjects of this chapter:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更深入地了解本章的主题，可以参考以下资源：
- en: '**General overview of the Linux filesystem**: [https://www.tldp.org/LDP/intro-linux/html/sect_03_01.html](https://www.tldp.org/LDP/intro-linux/html/sect_03_01.html)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux文件系统的概述**：[https://www.tldp.org/LDP/intro-linux/html/sect_03_01.html](https://www.tldp.org/LDP/intro-linux/html/sect_03_01.html)'
