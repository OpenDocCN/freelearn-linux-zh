- en: DMA – Direct Memory Access
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DMA - 直接内存访问
- en: DMA is a feature of computer systems that allows devices to access the main
    system memory RAM without CPU intervention, which then allows them to devote themselves
    to other tasks. One typically uses it for accelerating network traffic, but it
    supports any kind of copy.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: DMA是计算机系统的一种功能，允许设备在没有CPU干预的情况下访问主系统内存RAM，从而使它们能够专注于其他任务。通常用于加速网络流量，但支持任何类型的复制。
- en: The DMA controller is the peripheral responsible for DMA management. One mostly
    finds it in modern processors and microcontrollers. DMA is a feature used to perform
    memory read and write operations without stealing CPU cycles. When one needs to
    transfer a block of data, the processor feeds the DMA controller with the source
    and destination addresses and the total number of bytes. The DMA controller then
    transfers the data from the source to the destination automatically, without stealing
    CPU cycles. When the number of bytes remaining reaches zero, the block transfer
    ends.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: DMA控制器是负责DMA管理的外围设备。它主要出现在现代处理器和微控制器中。DMA是一种用于执行内存读写操作而不占用CPU周期的功能。当需要传输一块数据时，处理器将源地址、目的地址和总字节数提供给DMA控制器。DMA控制器然后自动将数据从源传输到目的地，而不占用CPU周期。当剩余字节数达到零时，块传输结束。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Coherent and non-coherent DMA mappings, as well as coherency issues
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致和非一致的DMA映射，以及一致性问题
- en: DMA engine API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DMA引擎API
- en: DMA and DT binding
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DMA和DT绑定
- en: Setting up DMA mappings
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置DMA映射
- en: For any type of DMA transfer, one needs to provide source and destination addresses,
    as well as the number of words to transfer. In the case of a peripheral DMA, the
    peripheral's FIFO serves as either the source or the destination. When the peripheral
    serves as the source, a memory location (internal or external) serves as the destination
    address. When the peripheral serves as the destination, a memory location (internal
    or external) serves as the source address.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何类型的DMA传输，都需要提供源地址、目的地址以及要传输的字数。在外围DMA的情况下，外围的FIFO作为源或目的地。当外围作为源时，内部或外部的内存位置作为目的地地址。当外围作为目的地时，内部或外部的内存位置作为源地址。
- en: With a peripheral DMA, we specify either the source or the destination, depending
    on the direction of the transfer. In others words, a DMA transfer requires suitable
    memory mappings. This is what we will discuss in the following sections.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于外围DMA，我们根据传输方向指定源或目的地。换句话说，DMA传输需要合适的内存映射。这是我们将在以下部分讨论的内容。
- en: Cache coherency and DMA
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存一致性和DMA
- en: As discussed in [Chapter 11](http://kernel) , *Kernel Memory Management* , copies
    of recently accessed memory areas are stored in the cache. This applies to DMA
    memory too. The reality is that memory shared between two independent devices
    is generally the source of cache coherency problems. Cache incoherence is an issue
    coming from the fact that other devices may not be aware of an update from a writing
    device. On the other hand, cache coherency ensures that every write operation
    appears to occur instantaneously, so that all devices sharing the same memory
    region see exactly the same sequence of changes.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第11章](http://kernel) *内核内存管理* 中所讨论的，最近访问的内存区域的副本存储在缓存中。DMA内存也适用于这一点。事实上，两个独立设备之间共享的内存通常是缓存一致性问题的根源。缓存不一致是一个问题，因为其他设备可能不知道写入设备的更新。另一方面，缓存一致性确保每个写操作都似乎是瞬时发生的，因此共享相同内存区域的所有设备看到的是完全相同的变化序列。
- en: 'A well-explained situation of the coherency issue is illustrated in the following
    excerpt from LDD3:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在LDD3的以下摘录中，对一致性问题进行了详细说明：
- en: Let us imagine a CPU equipped with a cache and an external memory that can be
    accessed directly by devices using DMA. When the CPU accesses location X in the
    memory, the current value will be stored in the cache. Subsequent operations on
    X will update the cached copy of X, but not the external memory version of X,
    assuming a write-back cache. If the cache is not flushed to the memory before
    the next time a device tries to access X, the device will receive a stale value
    of X. Similarly, if the cached copy of X is not invalidated when a device writes
    a new value to the memory, then the CPU will operate on a stale value of X.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一个CPU配备了缓存和可以被设备直接使用DMA访问的外部内存。当CPU访问内存中的位置X时，当前值将存储在缓存中。对X的后续操作将更新X的缓存副本，但不会更新X的外部内存版本，假设是写回缓存。如果在下一次设备尝试访问X之前，缓存没有刷新到内存中，设备将收到X的旧值。同样，如果在设备将新值写入内存时，X的缓存副本没有失效，那么CPU将操作X的旧值。
- en: 'There are actually two ways to address this issue:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有两种解决这个问题的方法：
- en: A hardware-based solution. Such systems are **coherent systems** .
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于硬件的解决方案。这样的系统是**一致的系统**。
- en: A software-based solution, where the OS is responsible for ensuring cache coherency.
    One calls such systems **non-coherent systems** .
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种基于软件的解决方案，其中操作系统负责确保缓存一致性。这样的系统称为**非一致的系统**。
- en: DMA mappings
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DMA映射
- en: Any suitable DMA transfer requires suitable memory mapping. A DMA mapping consists
    of allocating a DMA buffer and generating a bus address for it. Devices actually
    use bus addresses. Bus addresses are each instance of the `dma_addr_t` type.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 任何合适的DMA传输都需要合适的内存映射。DMA映射包括分配DMA缓冲区并为其生成总线地址。设备实际上使用总线地址。总线地址是`dma_addr_t`类型的每个实例。
- en: 'One distinguishes two types of mapping: **coherent DMA mappings** and **streaming
    DMA mappings** . One can use the former over several transfers, which automatically
    addresses cache coherency issues. Therefore, it is too expensive. The streaming
    mapping has a lot of constraints and does not automatically address coherency
    issues, although, there is a solution for that, which consists of several function
    calls between each transfer. Coherent mapping usually exists for the life of the
    driver, whereas one streaming mapping is usually unmapped once the DMA transfer
    completes.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 区分两种类型的映射：**一致DMA映射**和**流式DMA映射**。可以在多个传输中使用前者，它会自动解决缓存一致性问题。因此，它太昂贵了。流式映射有很多约束，并且不会自动解决一致性问题，尽管有解决方案，其中包括每次传输之间的几个函数调用。一致映射通常存在于驱动程序的生命周期中，而流式映射通常在DMA传输完成后取消映射。
- en: One should use streaming mapping when one can and coherent mapping when one
    must.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当可以时应使用流式映射，当必须时应使用一致映射。
- en: 'Back to the code; the main header should include the following to handle DMA
    mapping:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 回到代码；主要头文件应包括以下内容以处理DMA映射：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Coherent mapping
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一致映射
- en: 'The following function sets up a coherent mapping:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数设置了一致映射：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function handles both the allocation and the mapping of the buffer, and
    returns a kernel virtual address for that buffer, which is `size` bytes wide and
    accessible by the CPU. `dev` is your device structure. The third argument is an
    output parameter that points to the associated bus address. Memory allocated for
    the mapping is guaranteed to be physically contiguous, and `flag` determines how
    memory should be allocated, which is usually `GFP_KERNEL` , or `GFP_ATOMIC` (if
    we are in an atomic context).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数处理缓冲区的分配和映射，并返回该缓冲区的内核虚拟地址，该地址为`size`字节宽，并可被CPU访问。`dev`是您的设备结构。第三个参数是一个输出参数，指向相关的总线地址。映射的内存保证是物理连续的，`flag`确定应如何分配内存，通常是`GFP_KERNEL`或`GFP_ATOMIC`（如果我们处于原子上下文中）。
- en: 'Do note that this mapping is said to be:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，据说这种映射是：
- en: '**Consistent (coherent)** , since it allocates uncached unbuffered memory for
    a device for performing DMA'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致（协调）**，因为它为执行DMA分配了设备的非缓存非缓冲内存'
- en: '**Synchronous** , because a write by either the device or the CPU can be immediately
    read by either without worrying about cache coherency'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步**，因为设备或CPU的写入可以立即被任一方读取，而不必担心缓存一致性'
- en: 'In order to free a mapping, one can use the following function:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了释放映射，可以使用以下函数：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here `cpu_addr` corresponds to the kernel virtual address returned by `dma_alloc_coherent()`
    . This mapping is expensive, and the minimum it can allocate is a page. In fact,
    it only allocates the number of pages that is the power of 2\. The order of pages
    is obtained with `int order = get_order(size)` . One should use this mapping for
    buffers that last the life of the device.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`cpu_addr`对应于`dma_alloc_coherent()`返回的内核虚拟地址。这种映射是昂贵的，它最少可以分配一页。实际上，它只分配2的幂次方的页数。页面的顺序是用`int
    order = get_order(size)`获得的。应该将此映射用于设备生命周期内持续的缓冲区。
- en: Streaming DMA mapping
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流式DMA映射
- en: 'Streaming mapping has more constraints, and is different from coherent mapping
    for the following reasons:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 流式映射有更多的约束，并且与一致映射不同，原因如下：
- en: Mappings need to work with a buffer that has already been allocated.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射需要使用已经分配的缓冲区。
- en: Mappings may accept several non-contiguous and scattered buffers.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射可以接受多个非连续和分散的缓冲区。
- en: A mapped buffer belongs to the device and not to the CPU anymore. Before the
    CPU can use the buffer, it should be unmapped first (after `dma_unmap_single()`
    or `dma_unmap_sg()` ). This is for caching purposes.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射的缓冲区属于设备而不再属于CPU。在CPU可以使用缓冲区之前，应首先取消映射（在`dma_unmap_single()`或`dma_unmap_sg()`之后）。这是为了缓存目的。
- en: For write transactions (CPU to device), the driver should place data in the
    buffer before the mapping.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于写事务（CPU到设备），驱动程序应在映射之前将数据放入缓冲区。
- en: The direction the data should move into has to be specified, and the data should
    only be used based on this direction.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须指定数据移入的方向，并且只能根据这个方向使用数据。
- en: 'One may wonder why one should not access the buffer until it is unmapped. The
    reason is simple: CPU mapping is cacheable. The `dma_map_*()` family functions,
    which are used for streaming mapping, will first clean/invalidate the caches related
    to the buffer and rely on the CPU not to access it until the corresponding `dma_unmap_*()`
    . That will then invalidate (if necessary) the caches again, in case of any speculative
    fetches in the meantime, before the CPU may read any data written to memory by
    the device. Now the CPU can access the buffer.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 人们可能会想知道为什么在取消映射之前不应访问缓冲区。原因很简单：CPU映射是可缓存的。用于流式映射的`dma_map_*()`系列函数将首先清除/使缓存无效，然后依赖CPU不访问它，直到相应的`dma_unmap_*()`。然后，CPU可以访问缓冲区。
- en: 'There are actually two forms of streaming mapping:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有两种形式的流式映射：
- en: Single buffer mapping, which allow only one-page mapping
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个缓冲区映射，只允许单页映射
- en: Scatter/gather mapping, which allows passing several buffers (scattered over
    memory)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分散/聚集映射，允许传递多个分散在内存中的缓冲区
- en: 'For either mapping, direction should be specified, by a symbol of type `enum
    dma_data_direction` , defined in `include/linux/dma-direction.h` :'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何映射，都应指定方向，通过`include/linux/dma-direction.h`中定义的`enum dma_data_direction`类型的符号：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Single buffer mapping
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单个缓冲区映射
- en: 'This is for occasional mapping. One can set up a single buffer with this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于偶尔映射的。可以使用以下设置单个缓冲区：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The direction should be `DMA_TO_DEVICE` , `DMA_FROM_DEVICE` , or `DMA_BIDIRECTIONAL,`
    as described in the preceding code. `ptr` is the kernel virtual address of the
    buffer, and `dma_addr_t` is the returned bus address for the device. Make sure
    to use the direction that really fits your need, not just always `DMA_BIDIRECTIONAL`
    .
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 方向应该是`DMA_TO_DEVICE`，`DMA_FROM_DEVICE`或`DMA_BIDIRECTIONAL`，如前面的代码所述。`ptr`是缓冲区的内核虚拟地址，`dma_addr_t`是设备的返回总线地址。确保使用真正符合您需求的方向，而不仅仅是`DMA_BIDIRECTIONAL`。
- en: 'One should free the mapping with this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用以下方法释放映射：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Scatter/gather mapping
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分散/聚集映射
- en: 'Scatter/gather mappings are a special type of streaming DMA mapping where one
    can transfer several buffer regions in a single shot, instead of mapping each
    buffer individually and transferring them one by one. Suppose you have several
    buffers that might not be physically contiguous, all of which need to be transferred
    at the same time to or from the device. This situation may occur due to:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Scatter/gather映射是一种特殊类型的流DMA映射，其中可以一次传输多个缓冲区区域，而不是分别映射每个缓冲区并逐个传输它们。假设您有几个可能不是物理上连续的缓冲区，所有这些缓冲区都需要同时传输到设备或从设备传输。由于以下情况可能发生：
- en: A readv or writev system call
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个readv或writev系统调用
- en: A disk I/O request
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘I/O请求
- en: Or simply a list of pages in a mapped kernel I/O buffer
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者只是映射内核I/O缓冲区中的页面列表
- en: 'The kernel represents the scatterlist as a coherent structure, `struct scatterlist`
    :'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 内核将scatterlist表示为一个连贯的结构，`struct scatterlist`：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In order to set up a scatterlist mapping, one should:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置scatterlist映射，应该：
- en: Allocate your scattered buffers.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配您的分散缓冲区。
- en: Create an array of the scatter list and fill it with allocated memory using
    `sg_set_buf().` Note that scatterlist entries must be of page size (except ends).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建scatter列表的数组，并使用`sg_set_buf()`填充分配的内存。请注意，scatterlist条目必须是页面大小（除了末尾）。
- en: Call `dma_map_sg()` on the scatterlist.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在scatterlist上调用`dma_map_sg()`。
- en: Once done with DMA, call `dma_unmap_sg()` to unmap the scatterlist.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成DMA后，调用`dma_unmap_sg()`取消映射scatterlist。
- en: 'While one can send contents of several buffers over DMA one at a time by individually
    mapping each of them, scatter/gather can send them all at once by sending the
    pointer to the scatterlist to the device, along with a length, which is the number
    of entries in the list:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以通过分别映射每个缓冲区来一次性发送多个缓冲区的内容，但是scatter/gather可以通过将scatterlist的指针和长度一起发送到设备来一次性发送所有缓冲区的内容，长度是列表中的条目数：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The same rules described in the single-buffer mapping section apply to scatter/gather.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于单缓冲区映射部分的相同规则也适用于scatter/gather。
- en: '![](img/Image00032.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00032.jpg)'
- en: DMA scatter/gather
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: DMA scatter/gather
- en: '`dma_map_sg()` and `dma_unmap_sg()` take care of cache coherency. But if one
    needs to use the same mapping to access (read/write) the data between the DMA
    transfer, the buffers must be synced between each transfer in an appropriate manner,
    by either `dma_sync_sg_for_cpu()` if the CPU needs to access the buffers, or `dma_sync_sg_for_device()`
    if it is the device. Similar functions for single region mapping are `dma_sync_single_for_cpu()`
    and `dma_sync_single_for_device()` :'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`dma_map_sg()`和`dma_unmap_sg()`负责缓存一致性。但是，如果需要使用相同的映射来在DMA传输之间访问（读/写）数据，则必须以适当的方式在每次传输之间同步缓冲区，通过`dma_sync_sg_for_cpu()`（如果CPU需要访问缓冲区）或`dma_sync_sg_for_device()`（如果是设备）。单个区域映射的类似函数是`dma_sync_single_for_cpu()`和`dma_sync_single_for_device()`：'
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There is no need to call the preceding functions again after the buffer(s) has
    been unmapped. You can just read the content.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓冲区被取消映射后，无需再次调用前面的函数。您只需读取内容。
- en: Concept of completion
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成的概念
- en: This section will briefly describe completion and the necessary part of its
    API that the DMA transfer uses. For a complete description, please feel free to
    have a look at the kernel documentation at *Documentation/scheduler/completion.txt*
    . A common pattern in kernel programming involves initiating some activity outside
    of the current thread, then waiting for that activity to complete.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将简要描述完成和DMA传输使用的API的必要部分。有关完整的描述，请随时查看内核文档*Documentation/scheduler/completion.txt*。内核编程中的一个常见模式涉及启动当前线程之外的某些活动，然后等待该活动完成。
- en: Completion is a good alternative to `sleep()` when waiting for a buffer to be
    used. It is suitable for sensing data, which is exactly what the DMA callback
    does.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在等待缓冲区被使用时，完成是`sleep()`的一个很好的替代方案。它适用于感知数据，这正是DMA回调所做的。
- en: 'Working with completion requires this header:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完成需要这个头文件：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Like other kernel facility data structures, one can create instances of the
    `struct completion` structure either statically or dynamically:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他内核设施数据结构一样，可以静态或动态地创建`struct completion`结构的实例：
- en: 'Static declaration and initialization looks like this:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态声明和初始化如下：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Dynamic allocation looks like this:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态分配如下：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the driver begins some work whose completion must be waited for (a DMA
    transaction in our case), it just has to pass the completion event to the `wait_for_completion()`
    function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '当驱动程序开始一些必须等待完成的工作（在我们的情况下是DMA事务）时，它只需将完成事件传递给`wait_for_completion()`函数： '
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When some other part of the code has decided that the completion has happened
    (transaction completes), it can wake up anybody (actually the code that needs
    to access DMA buffer) who is waiting with one of:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码的其他部分决定完成已经发生（事务完成）时，它可以唤醒任何等待的人（实际上是需要访问DMA缓冲区的代码）：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As one can guess, `complete()` will wake up only one waiting process, while
    `complete_all()` will wake up every one waiting for that event. Completions are
    implemented in such a way that they will work properly even if `complete()` is
    called before `wait_for_completion()` .
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 可以猜到，`complete()`只会唤醒一个等待的进程，而`complete_all()`会唤醒每一个等待该事件的进程。即使在调用`wait_for_completion()`之前调用`complete()`，完成也是以这样一种方式实现的，即它们将正常工作。
- en: Along with code samples used in the next sections, one will have a better understanding
    of how this works.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 随着下一节中使用的代码示例，您将更好地了解这是如何工作的。
- en: DMA engine API
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DMA引擎API
- en: The DMA engine is a generic kernel framework for developing a DMA controller
    driver. The main goal of DMA is offloading the CPU when it comes to copy memory.
    One delegates a transaction (I/O data transfers) to the DMA engine by use of channels.
    A DMA engine, through its driver/API, exposes a set of channels, which can be
    used by other devices (slaves).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: DMA引擎是用于开发DMA控制器驱动程序的通用内核框架。DMA的主要目标是在复制内存时卸载CPU。通过使用通道，可以通过DMA引擎委托事务（I/O数据传输）。DMA引擎通过其驱动程序/API公开一组通道，其他设备（从设备）可以使用这些通道。
- en: '![](img/Image00033.gif)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00033.gif)'
- en: DMA Engine layout
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: DMA引擎布局
- en: 'Here we will simply walk through that (slave) API, which is applicable for
    slave DMA usage only. The mandatory header here is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将简单地介绍（从设备）API，这仅适用于从设备DMA使用。这里的强制性标头如下：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The slave DMA usage is straightforward, and consists of the following steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从设备DMA的使用非常简单，包括以下步骤：
- en: Allocate a DMA slave channel.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配DMA从设备通道。
- en: Set slave and controller specific parameters.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置从设备和控制器特定参数。
- en: Get a descriptor for the transaction.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取事务的描述符。
- en: Submit the transaction.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交事务。
- en: Issue pending requests and wait for callback notification.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出挂起的请求并等待回调通知。
- en: One can see a DMA channel as a highway for I/O data transfer
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将DMA通道视为I/O数据传输的高速公路
- en: Allocate a DMA slave channel
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配DMA从设备通道
- en: 'One requests a channel using `dma_request_channel()` . Its prototype is as
    follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dma_request_channel()`请求通道。其原型如下：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`mask` is a bitmap mask that represents the capabilities the channel must satisfy.
    One uses it essentially to specify the transfer types the driver needs to perform:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`mask`是一个位图掩码，表示通道必须满足的功能。主要用于指定驱动程序需要执行的传输类型：'
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`The dma_cap_zero()` and `dma_cap_set()` functions are used to clear the mask
    and set the capability we need. For example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`dma_cap_zero()`和`dma_cap_set()`函数用于清除掩码并设置我们需要的功能。例如：'
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding excerpt, `dma_filter_fn` is defined as:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述摘录中，`dma_filter_fn`被定义为：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If `filter_fn` parameter (which is optional) is `NULL` , `dma_request_channel()`
    will simply return the first channel that satisfies the capability mask. Otherwise,
    when the mask parameter is insufficient for specifying the necessary channel,
    one can use the `filter_fn` routine as a filter for the available channels in
    the system. The kernel calls the `filter_fn` routine once for each free channel
    in the system. Upon seeing a suitable channel, `filter_fn` should return `DMA_ACK,`
    which will tag the given channel to be the return value from `dma_request_channel()`
    .
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`filter_fn`参数（可选）为`NULL`，`dma_request_channel()`将简单地返回满足能力掩码的第一个通道。否则，当掩码参数不足以指定必要的通道时，可以使用`filter_fn`例程作为系统中可用通道的过滤器。内核会为系统中的每个空闲通道调用`filter_fn`例程。在找到合适的通道时，`filter_fn`应返回`DMA_ACK`，这将标记给定通道为`dma_request_channel()`的返回值。
- en: 'A channel allocated through this interface is exclusive to the caller, until
    `dma_release_channel()` is called:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此接口分配的通道对调用者是独占的，直到调用`dma_release_channel()`为止：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Set slave and controller specific parameters
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置从设备和控制器特定参数
- en: This step introduces a new data structure, `struct dma_slave_config` , which
    represents the runtime configuration for the DMA slave channel. This allows clients
    to specify settings, such as the DMA direction, DMA addresses, bus width, DMA
    burst lengths, and so on, for the peripheral.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步引入了一个新的数据结构`struct dma_slave_config`，它表示DMA从设备通道的运行时配置。这允许客户端指定设置，例如DMA方向、DMA地址、总线宽度、DMA突发长度等。
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `struct dma_slave_config` structure looks like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct dma_slave_config`结构如下：'
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is the meaning of each element in the structure:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结构中每个元素的含义：
- en: '`direction` : This indicates whether the data should go in or out on this slave
    channel, right now. The possible values are:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`direction`：这表示数据当前是否应该在此从设备通道上进出。可能的值为：'
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`src_addr` : This is the physical address (actually the bus address) of the
    buffer where the DMA slave data should be read (RX). This element is ignored if
    the source is memory. `dst_addr` is the physical address (actually the bus address)
    of the buffer where the DMA slave data should be written (TX), which is ignored
    if the source is memory. `src_addr_width` is the width in bytes of the source
    (RX) register where the DMA data should be read. If the source is memory, this
    may be ignored depending on the architecture. The legal values are 1, 2, 4, or
    8\. Therefore, `dst_addr_width` is the same as `src_addr_width` but for the destination
    target (TX).'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src_addr`：这是DMA从设备数据应该被读取（RX）的缓冲区的物理地址（实际上是总线地址）。如果源是内存，则此元素将被忽略。`dst_addr`是DMA从设备数据应该被写入（TX）的缓冲区的物理地址（实际上是总线地址），如果源是内存，则将被忽略。`src_addr_width`是DMA数据应该被读取的源（RX）寄存器的宽度（以字节为单位）。如果源是内存，根据架构的不同可能会被忽略。合法的值为1、2、4或8。因此，`dst_addr_width`与`src_addr_width`相同，但用于目标（TX）。'
- en: 'Any bus width must be one of the following enumerations:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何总线宽度必顺为以下枚举值之一：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`src_maxburs` : This is the maximum number of words (here, consider words as
    units of the `src_addr_width` member, not in bytes) that can be sent in one burst
    to the device. Typically, something like half the FIFO depth on I/O peripherals
    so you do not overflow it. This may or may not be applicable on memory sources.
    `dst_maxburst` is the same as `src_maxburst` but for the destination target.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src_maxburs`：这是可以一次发送到设备的最大字数（在这里，将字视为`src_addr_width`成员的单位，而不是字节）。通常是I/O外围设备上FIFO深度的一半，以防止溢出。这可能适用于内存源，也可能不适用。`dst_maxburst`与`src_maxburst`相同，但用于目标。'
- en: 'For example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding excerpt, one calls `dma_request_channel()` function in order
    to take the owner chip of the DMA channel, on which one calls `dmaengine_slave_config()`
    to apply its configuration. `dma_map_single()` is called in order to map rx and
    tx buffers, so that these can be used for purpose of DMA.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述摘录中，我们调用`dma_request_channel()`函数以获取DMA通道的所有者芯片，然后调用`dmaengine_slave_config()`来应用其配置。调用`dma_map_single()`以映射rx和tx缓冲区，以便可以用于DMA的目的。
- en: Get a descriptor for transaction
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取事务的描述符
- en: 'If you remember the first step of this section, when one requests a DMA channel,
    the return value is an instance of the `struct dma_chan` structure. If one looks
    at its definition in `include/linux/dmaengine.h` , one will notice that it contains
    a `struct dma_device *device` field, which represents the DMA device (the controller
    actually) that supplied the channel. The kernel driver of this controller is responsible
    (it is a rule imposed by the kernel API for DMA controller drivers) for exposing
    a set of functions to prepare DMA transactions, where each of them correspond
    to a DMA transaction type (enumerated in step 1). Depending on the transaction
    type, one has no choice but to choose the dedicated function. Some of these functions
    are:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记得本节的第一步，当请求DMA通道时，返回值是`struct dma_chan`结构的一个实例。如果您查看`include/linux/dmaengine.h`中的定义，您会注意到它包含一个`struct
    dma_device *device`字段，表示提供通道的DMA设备（实际上是控制器）。这个控制器的内核驱动程序负责（这是内核API对DMA控制器驱动程序施加的规则）暴露一组函数来准备DMA事务，其中每个函数对应一个DMA事务类型（在第1步中枚举）。根据事务类型，您别无选择，只能选择专用函数。其中一些函数是：
- en: '`device_prep_dma_memcpy()` : Prepares a memcpy operation'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_dma_memcpy()`：准备memcpy操作'
- en: '`device_prep_dma_sg()` : Prepare a scatter/gather memcpy operation'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_dma_sg()`：准备分散/聚集的memcpy操作'
- en: '`device_prep_dma_xor()` : For a xor operation'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_dma_xor()`：进行xor操作'
- en: '`device_prep_dma_xor_val()` : Prepares a xor validation operation'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_dma_xor_val()`：准备xor验证操作'
- en: '`device_prep_dma_pq()` : Prepares a pq operation'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_dma_pq()`：准备pq操作'
- en: '`device_prep_dma_pq_val()` : Prepares a pqzero_sum operation'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_dma_pq_val()`：准备pqzero_sum操作'
- en: '`device_prep_dma_memset()` : Prepares a memset operation'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_dma_memset()`：准备memset操作'
- en: '`device_prep_dma_memset_sg()` : For a memset operation over a scatterlist'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_dma_memset_sg()`：对分散列表进行memset操作'
- en: '`device_prep_slave_sg()` : Prepares a slave DMA operation'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_slave_sg()`：准备从属DMA操作'
- en: '`device_prep_interleaved_dma()` : Transfers an expression in a generic way'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_prep_interleaved_dma()`：以通用方式传输表达式'
- en: 'Let us have a look at `drivers/dma/imx-sdma.c` , which is the i.MX6 DMA controller
    (SDMA) driver. Each of these functions returns a pointer to a `struct dma_async_tx_descriptor`
    structure, which corresponds to the transaction descriptor. With memory-to-memory
    copy, one will use `device_prep_dma_memcpy` :'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`drivers/dma/imx-sdma.c`，这是i.MX6 DMA控制器（SDMA）驱动程序。这些函数中的每一个都返回一个指向`struct
    dma_async_tx_descriptor`结构的指针，对应于事务描述符。对于内存到内存的复制，可以使用`device_prep_dma_memcpy`：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In fact, we should have used `dmaengine_prep_*` DMA engine API. Just note that
    these functions internally do what we just performed earlier. For example, for
    memory-to-memory, one could have used the `device_prep_dma_memcpy ()` function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们应该使用`dmaengine_prep_*` DMA引擎API。只需注意，这些函数在内部执行了我们之前执行的操作。例如，对于内存到内存，可以使用`device_prep_dma_memcpy()`函数：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our sample becomes:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例变成了：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Please have a look at `include/linux/dmaengine.h` , in the definition of a `struct
    dma_device` structure, to see how all of these hooks are implemented.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看`include/linux/dmaengine.h`，在`struct dma_device`结构的定义中，看看所有这些挂钩是如何实现的。
- en: Submit the transaction
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交事务
- en: 'To put the transaction in the driver pending queue, one uses `dmaengine_submit()`
    . Once the descriptor has been prepared and the callback information added, one
    should place it on the DMA engine drivers pending the queue:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要将事务放入驱动程序的挂起队列中，可以使用`dmaengine_submit()`。一旦描述符准备好并添加了回调信息，就应该将其放在DMA引擎驱动程序的挂起队列中：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This function returns a cookie that one can use to check the progress of DMA
    activity through other DMA engines. `dmaengine_submit()` will not start the DMA
    operation, it merely adds it to the pending queue. How to start the transaction
    is discussed in the next step:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数返回一个cookie，可以用它来通过其他DMA引擎检查DMA活动的进度。`dmaengine_submit()`不会启动DMA操作，它只是将其添加到挂起队列中。如何启动事务将在下一步中讨论：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Issue pending DMA requests and wait for callback notification
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发出挂起的DMA请求并等待回调通知
- en: 'Starting the transaction is the last step of the DMA transfer setup. One activates
    transactions in the pending queue of a channel by calling `dma_async_issue_pending()`
    on that channel. If the channel is idle then the first transaction in the queue
    is started and subsequent ones are queued up. On completion of a DMA operation,
    the next one in the queue is started and a tasklet triggered. This tasklet is
    in charge of calling the client driver completion callback routine for notification,
    if set:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 启动事务是DMA传输设置的最后一步。通过在通道的挂起队列上调用`dma_async_issue_pending()`来激活通道中的事务。如果通道空闲，则启动队列中的第一个事务，并排队后续事务。在DMA操作完成后，启动队列中的下一个事务，并触发一个tasklet。这个tasklet负责调用客户驱动程序完成回调例程进行通知，如果设置：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'An example would look like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例可能如下所示：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `wait_for_completion()` function will block until our DMA callback gets
    called, which will update (complete) our completion variable in order to resume
    the previous blocked code. It is a suitable alternative to `while (!done) msleep(SOME_TIME);`
    .
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait_for_completion()`函数将阻塞，直到我们的DMA回调被调用，这将更新（完成）我们的完成变量，以便恢复先前被阻塞的代码。这是`while
    (!done) msleep(SOME_TIME);`的一个合适的替代方法。'
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The DMA engine API function that actually issues pending transactions is `dmaengine_issue_pending(struct
    dma_chan *chan)` , which is a wrap around `dma_async_issue_pending()` .
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 实际发出挂起事务的DMA引擎API函数是`dmaengine_issue_pending(struct dma_chan *chan)`，它是对`dma_async_issue_pending()`的封装。
- en: Putting it all together – NXP SDMA (i.MX6)
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容放在一起 - NXP SDMA（i.MX6）
- en: 'The SDMA engine is a programmable controller in the i.MX6 and each peripheral
    has its own copy function in this controller. One uses this `enum` to determine
    their addresses:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: SDMA引擎是i.MX6中的可编程控制器，每个外设在此控制器中都有自己的复制功能。使用此`enum`来确定它们的地址：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Despite the generic DMA engine API, any constructor may provide its own custom
    data structure. This is the case for the `imx_dma_data` structure, which is a
    private data (used to describe the DMA device type one needs to use) that is to
    be passed to the `.private` field of the `struct dma_chan` in the filter callback:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通用DMA引擎API，任何构造函数都可以提供自己的自定义数据结构。这适用于`imx_dma_data`结构，它是一个私有数据（用于描述需要使用的DMA设备类型），将传递给过滤回调中`struct
    dma_chan`的`.private`字段：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'These structures and enum are all specific to i.MX and are defined in `include/linux/platform_data/dma-imx.h`
    . Now, let us write our kernel DMA module. It allocates two buffers (source and
    destination). Fill the source with predefined data, and perform a transaction
    in order to copy src into dst. One can improve this module by using data coming
    from user space (`copy_from_user()` ). This driver is inspired from the one provided
    in the imx-test package:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结构和枚举都是特定于i.MX的，并在`include/linux/platform_data/dma-imx.h`中定义。现在，让我们编写我们的内核DMA模块。它分配两个缓冲区（源和目标）。用预定义数据填充源，并执行事务以将src复制到dst。可以通过使用来自用户空间的数据（`copy_from_user()`）来改进此模块。此驱动程序受到imx-test软件包中提供的驱动程序的启发：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let us define the filter function. When one requests a DMA channel, the controller
    driver may perform a lookup in a list of channels (which it has). For fine-grained
    lookup, one can provide a callback method that will be called on each channel
    found. It is then up to the callback to choose the suitable channel to use:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义过滤函数。当请求DMA通道时，控制器驱动程序可能会在通道列表中进行查找。对于细粒度的查找，可以提供一个回调方法，该方法将在找到的每个通道上调用。然后由回调来选择要使用的合适通道：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`imx_dma_is_general_purpose` is a special function that checks the controller
    driver''s name. The `open` function will allocate the buffer and request the DMA
    channel, given our filter function as callback:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`imx_dma_is_general_purpose`是一个特殊函数，用于检查控制器驱动程序的名称。`open`函数将分配缓冲区并请求DMA通道，给定我们的过滤函数作为回调：'
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `release` function simply does the reverse of the `open` function; it frees
    the buffer and releases the DMA channel:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`release`函数只是`open`函数的反向操作；它释放缓冲区并释放DMA通道：'
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the `read` function, we just compare the source and destination buffer and
    inform the user about the result.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在`read`函数中，我们只是比较源缓冲区和目标缓冲区，并通知用户结果。
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We use completion in order to get notified (woken up) when the transaction
    has terminated. This callback is called after our transaction has finished and
    sets our completion variable to the complete state:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用完成来在事务终止时得到通知（唤醒）。此回调在我们的事务完成后调用，并将我们的完成变量设置为完成状态：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the `write` function, we fill our source buffer with the data, perform DMA
    mapping in order to get physical addresses that correspond to our source and destination
    buffer, and call `device_prep_dma_memcpy` to get a transaction descriptor. That
    transaction descriptor is then submitted to the DMA engine with `dmaengine_submit`
    , which does not perform our transaction yet. It is only after we have called
    `dma_async_issue_pending` on our DMA channel, that our pending transaction will
    be processed:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在`write`函数中，我们用数据填充源缓冲区，执行DMA映射以获取与我们的源和目标缓冲区对应的物理地址，并调用`device_prep_dma_memcpy`来获取事务描述符。然后，将该事务描述符提交给DMA引擎，使用`dmaengine_submit`，这时并不执行我们的事务。只有在我们在DMA通道上调用`dma_async_issue_pending`后，我们的待处理事务才会被处理：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The full code is available in the repository of the book: `chapter-12/imx-sdma/imx-sdma-single.c`
    . There is also a module with which to perform the same task, but using scatter/gather
    mapping: `chapter-12/imx-sdma/imx-sdma-scatter-gather.c` .'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可在书的存储库中找到：`chapter-12/imx-sdma/imx-sdma-single.c`。还有一个模块，可以执行相同的任务，但使用分散/聚集映射：`chapter-12/imx-sdma/imx-sdma-scatter-gather.c`。
- en: DMA DT binding
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DMA DT绑定
- en: DT binding for the DMA channel depends on the DMA controller node, which is
    SoC dependent, and some parameters (such as DMA cells) may vary from one SoC to
    another. This example only focuses on the i.MX SDMA controller, which one can
    find in the kernel source, at *Documentation/devicetree/bindings/dma/fsl-imx-sdma.txt*
    .
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: DMA通道的DT绑定取决于DMA控制器节点，这是SoC相关的，一些参数（如DMA单元格）可能因SoC而异。此示例仅关注i.MX SDMA控制器，可以在内核源码中找到，位于*Documentation/devicetree/bindings/dma/fsl-imx-sdma.txt*。
- en: Consumer binding
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用者绑定
- en: 'According to the SDMA event-mapping table, the following code shows the DMA
    request signals for peripherals in i.MX 6Dual/ 6Quad:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 根据SDMA事件映射表，以下代码显示了i.MX 6Dual/6Quad外围设备的DMA请求信号：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The second cells (`25` and `26` ) in the DMA property correspond to the DMA
    request/event ID. Those values come from the SoC manuals (i.MX53 in our case).
    Please have a look at [https://community.nxp.com/servlet/JiveServlet/download/614186-1-373516/iMX6_Firmware_Guide.pdf](https://community.nxp.com/servlet/JiveServlet/download/614186-1-373516/iMX6_Firmware_Guide.pdf)
    and the Linux reference manual at [https://community.nxp.com/servlet/JiveServlet/download/614186-1-373515/i.MX_Linux_Reference_Manual.pdf](https://community.nxp.com/servlet/JiveServlet/download/614186-1-373515/i.MX_Linux_Reference_Manual.pdf)
    .
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: DMA属性中的第二个单元格（`25`和`26`）对应于DMA请求/事件ID。这些值来自SoC手册（在我们的情况下是i.MX53）。请查看[https://community.nxp.com/servlet/JiveServlet/download/614186-1-373516/iMX6_Firmware_Guide.pdf](https://community.nxp.com/servlet/JiveServlet/download/614186-1-373516/iMX6_Firmware_Guide.pdf)和Linux参考手册[https://community.nxp.com/servlet/JiveServlet/download/614186-1-373515/i.MX_Linux_Reference_Manual.pdf](https://community.nxp.com/servlet/JiveServlet/download/614186-1-373515/i.MX_Linux_Reference_Manual.pdf)。
- en: 'The third cell indicates the priority to use. The driver code to request a
    specified parameter is defined next. One can find the complete code in `drivers/tty/serial/imx.c`
    in the kernel source tree:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个单元格指示要使用的优先级。请求指定参数的驱动程序代码在下面定义。可以在内核源树的`drivers/tty/serial/imx.c`中找到完整的代码：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The magic call here is the `dma_request_slave_channel()` function, which will
    parse the device node (in the DT) using `of_dma_request_slave_channel()` to gather
    channel settings, according to the DMA name (refer to the named resource in [Chapter
    6](text00162.html) , *The Concept of Device Tree* ).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的魔法调用是`dma_request_slave_channel()`函数，它将使用`of_dma_request_slave_channel()`解析设备节点（在DT中），以根据DMA名称（参考[第6章](text00162.html)中的命名资源，*设备树的概念*）收集通道设置。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: DMA is a feature that one finds in many modern CPUs. This chapter gives you
    the necessary steps to get the most out of this device, using the kernel DMA mapping
    and DMA engine APIs. After this chapter, I have no doubt you will be able to set
    up at least a memory-to-memory DMA transfer. One can find further information
    at *Documentation/dmaengine/* , in the kernel source tree. Therefore, the next
    chapter deals with an entirely different subject—the Linux device model.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: DMA是许多现代CPU中的一个功能。本章为您提供了使用内核DMA映射和DMA引擎API的必要步骤，以充分利用此设备。在本章之后，我毫无疑问您将能够设置至少一个内存到内存的DMA传输。可以在内核源树中的*Documentation/dmaengine/*中找到更多信息。因此，下一章涉及一个完全不同的主题——Linux设备模型。
