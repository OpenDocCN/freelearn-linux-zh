- en: Chapter 3. All About Bootloaders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。关于引导加载程序的一切
- en: The bootloader is the second element of embedded Linux. It is the part that
    starts the system up and loads the operating system kernel. In this chapter, I
    will look at the role of the bootloader and, in particular, how it passes control
    from itself to the kernel using a data structure called a device tree, also known
    as a **flattened device tree** or **FDT**. I will cover the basics of device trees
    so that you will be able to follow the connections described in a device tree
    and relate it to real hardware.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序是嵌入式Linux的第二个元素。它是启动系统并加载操作系统内核的部分。在本章中，我将研究引导加载程序的作用，特别是它如何使用称为设备树的数据结构将控制权从自身传递给内核，也称为**扁平设备树**或**FDT**。我将介绍设备树的基础知识，以便您能够跟随设备树中描述的连接，并将其与实际硬件联系起来。
- en: I will look at the popular open source bootloader U-Boot and see how to use
    it to boot a target device and also how to customize it to a new device. Finally,
    I will take a quick look at Barebox, a bootloader that shares its past with U-Boot
    but which has, arguably, a cleaner design.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我将研究流行的开源引导加载程序U-Boot，并看看如何使用它来引导目标设备，以及如何定制它以适应新设备。最后，我将简要介绍Barebox，这是一个与U-Boot共享历史的引导加载程序，但可以说它具有更清晰的设计。
- en: What does a bootloader do?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导加载程序的作用是什么？
- en: 'In an embedded Linux system, the bootloader has two main jobs: basic system
    initialization and the loading of the kernel. In fact, the first job is somewhat
    subsidiary to the second in that it is only necessary to get as much of the system
    working as is needed to load the kernel.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式Linux系统中，引导加载程序有两个主要任务：基本系统初始化和内核加载。实际上，第一个任务在某种程度上是第二个任务的附属，因为只有在加载内核所需的系统工作正常时才需要。
- en: When the first lines of bootloader code are executed, following power-on or
    a reset, the system is in a very minimal state. The DRAM controller will not have
    been set up so main memory is not accessible, likewise other interfaces will not
    have been configured so storage accessed via NAND flash controllers, MMC controllers,
    and so on, are also not usable. Typically, the only resources operational at the
    beginning are a single CPU core and some on-chip static memory. As a result, system
    bootstrap consists of several phases of code, each bringing more of the system
    into operation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行引导加载程序代码的第一行时，随着通电或复位，系统处于非常基本的状态。DRAM控制器尚未设置，因此主存储器不可访问，同样，其他接口也尚未配置，因此通过NAND闪存控制器、MMC控制器等访问的存储器也不可用。通常，在开始时仅有一个CPU核心和一些芯片上的静态存储器是可操作的。因此，系统引导包括几个代码阶段，每个阶段都将系统的更多部分带入运行。
- en: The early boot phase stops once the interfaces required to load a kernel are
    working. That includes main memory and the peripherals used to access the kernel
    and other images, be they mass storage or network. The final act of the bootloader
    is to load the kernel into RAM and create an execution environment for it. The
    details of the interface between the bootloader and the kernel are architecture-specific
    but, in all cases, it means passing a pointer to information about the hardware
    that the bootloader knows about and passing a kernel command line, which is an
    ASCII string containing essential information for Linux. Once the kernel has begun
    executing, the bootloader is no longer needed and all the memory it was using
    can be reclaimed.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 早期引导阶段在加载内核所需的接口正常工作后停止。这包括主存储器和用于访问内核和其他映像的外围设备，无论是大容量存储还是网络。引导加载程序的最后一步是将内核加载到RAM中，并为其创建执行环境。引导加载程序与内核之间的接口细节是特定于体系结构的，但在所有情况下，这意味着传递有关引导加载程序已知的硬件信息的指针，并传递一个内核命令行，这是一个包含Linux必要信息的ASCII字符串。一旦内核开始执行，引导加载程序就不再需要，并且可以回收它使用的所有内存。
- en: A subsidiary job of the bootloader is to provide a maintenance mode for updating
    boot configurations, loading new boot images into memory and, maybe, running diagnostics.
    This is usually controlled by a simple command-line user interface, commonly over
    a serial interface.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序的附属任务是提供维护模式，用于更新引导配置，将新的引导映像加载到内存中，可能运行诊断。这通常由一个简单的命令行用户界面控制，通常通过串行接口。
- en: The boot sequence
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引导序列
- en: 'In simpler times, some years ago, it was only necessary to place the bootloader
    in non-volatile memory at the reset vector of the processor. NOR flash memory
    was common at that time and, since it can be mapped directly into the address
    space, it was the ideal method of storage. The following diagram shows such a
    configuration, with the reset vector at 0xfffffffc at the top end of an area of
    flash memory. The bootloader is linked so that there is a jump instruction at
    that location that points to the start of the bootloader code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在更简单的时代，几年前，只需要将引导加载程序放在处理器的复位向量处的非易失性存储器中。当时NOR闪存存储器很常见，由于它可以直接映射到地址空间中，因此是存储的理想方法。以下图表显示了这样的配置，复位向量位于闪存存储器区域的顶端0xfffffffc处。引导加载程序被链接，以便在该位置有一个跳转指令，指向引导加载程序代码的开始位置：
- en: '![The boot sequence](img/B03982_03_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![引导序列](img/B03982_03_01.jpg)'
- en: Boot in the old days
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 旧日的引导
- en: From that point, it can initialize the memory controller so that the main memory,
    the DRAM, becomes available and copies itself into DRAM. Once fully operational,
    the bootloader can load the kernel from flash memory into DRAM and transfer control
    to it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，它可以初始化内存控制器，使主存储器DRAM可用，并将自身复制到DRAM中。一旦完全运行，引导加载程序可以将内核从闪存加载到DRAM中，并将控制权转移给它。
- en: However, once you move away from a simple linearly addressable storage medium
    like NOR flash, the boot sequence becomes a complex, multi-stage procedure. The
    details are very specific to each SoC, but they generally follow each of the following
    phases.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦远离像NOR闪存这样的简单线性可寻址存储介质，引导序列就变成了一个复杂的多阶段过程。细节对于每个SoC都非常具体，但它们通常遵循以下各个阶段。
- en: 'Phase 1: ROM code'
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阶段1：ROM代码
- en: 'In the absence of reliable external memory, the code that runs immediately
    after a reset or power-on has to be stored on-chip in the SoC; this is known as
    ROM code. It is programmed into the chip when it is manufactured, hence ROM code
    is proprietary and cannot be replaced by an open source equivalent. The ROM code
    can make very few assumptions about any hardware that is not on the chip, because
    it will be different from one design to another. This applies even to the DRAM
    chips used for the main system memory. Consequently, the only RAM that the ROM
    code has access to is the small amount of static RAM (SRAM) found in most SoC
    designs. The size of the SRAM varies from as little as 4 KiB up to a few hundred
    KiB:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有可靠的外部存储器的情况下，立即在重置或上电后运行的代码必须存储在SoC芯片上；这就是所谓的ROM代码。它在制造芯片时被编程，因此ROM代码是专有的，不能被开源等效物替换。ROM代码对不在芯片上的任何硬件都可以做出非常少的假设，因为它将与另一个设计不同。这甚至适用于用于主系统内存的DRAM芯片。因此，ROM代码只能访问大多数SoC设计中找到的少量静态RAM（SRAM）。SRAM的大小从4
    KiB到几百KiB不等：
- en: '![Phase 1: ROM code](img/B03982_03_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![第1阶段：ROM代码](img/B03982_03_02.jpg)'
- en: Phase 1 bootloader
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第1阶段引导加载程序
- en: The ROM code is capable of loading a small chunk of code from one of several
    preprogrammed locations into the SRAM. As an example, TI OMAP and Sitara chips
    will try to load code from the first few pages of NAND flash memory, or from flash
    memory connected through **SPI** (**Serial Peripheral Interface**), or from the
    first sectors of an MMC device (which could be an eMMC chip or an SD card), or
    from a file named `MLO` on the first partition of an MMC device. If reading from
    all of those memory devices fails, then it will try reading a byte stream from
    Ethernet, USB, or UART; the latter is provided mainly as a means of loading code
    into flash memory during production rather than for use in normal operation. Most
    embedded SoCs have ROM code that works in a similar way. In SoCs where the SRAM
    is not large enough to load a full bootloader like U-Boot, there has to be an
    intermediate loader called the secondary program loader, or SPL.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ROM代码能够从几个预编程位置之一加载一小块代码到SRAM中。例如，TI OMAP和Sitara芯片将尝试从NAND闪存的前几页，或通过SPI（串行外围接口）连接的闪存，或MMC设备的前几个扇区（可能是eMMC芯片或SD卡），或MMC设备的第一个分区上名为`MLO`的文件中加载代码。如果从所有这些存储设备读取失败，那么它将尝试从以太网、USB或UART读取字节流；后者主要用作在生产过程中将代码加载到闪存中，而不是用于正常操作。大多数嵌入式SoC都有类似的ROM代码工作方式。在SRAM不足以加载像U-Boot这样的完整引导加载程序的SoC中，必须有一个称为二级程序加载器或SPL的中间加载器。
- en: At the end of this phase, the next stage bootloader is present in on-chip memory
    and the ROM code jumps to the beginning of that code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段结束时，下一阶段的引导加载程序存在于芯片内存中，ROM代码跳转到该代码的开头。
- en: 'Phase 2: SPL'
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2阶段：SPL
- en: 'The SPL must set up the memory controller and other essential parts of the
    system preparatory to loading the **third stage program loader** (**TPL**) into
    main memory, the DRAM. The functionality of the SPL is limited by its size. It
    can read a program from a list of storage devices, as can the ROM code, once again
    using preprogrammed offsets from the start of a flash device, or a well known
    file name such as `u-boot.bin`. The SPL usually doesn''t allow for any user interaction
    but it may print version information and progress messages which you will see
    on the console. The following diagram explains the phase 2 architecture:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: SPL必须设置内存控制器和系统的其他必要部分，以准备将第三阶段程序加载器（TPL）加载到主内存DRAM中。SPL的功能受其大小限制。它可以从存储设备列表中读取程序，就像ROM代码一样，再次使用从闪存设备开始的预编程偏移量，或者像`u-boot.bin`这样的众所周知的文件名。SPL通常不允许用户交互，但它可以打印版本信息和进度消息，这些消息将显示在控制台上。以下图解释了第2阶段的架构：
- en: '![Phase 2: SPL](img/B03982_03_03.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![第2阶段：SPL](img/B03982_03_03.jpg)'
- en: Second stage boot
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段引导
- en: The SPL may be open source, as is the case with the TI x-loader and Atmel AT91Bootstrap,
    but it is quite common for it to contain proprietary code that is supplied by
    the manufacturer as a binary blob.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SPL可能是开源的，就像TI x-loader和Atmel AT91Bootstrap一样，但它通常包含供应商提供的专有代码，以二进制块的形式提供。
- en: At the end of the second phase, the third stage loader is present in DRAM, and
    the SPL can make a jump to that area.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二阶段结束时，DRAM中存在第三阶段加载器，并且SPL可以跳转到该区域。
- en: 'Phase 3: TPL'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3阶段：TPL
- en: 'Now, at last, we are running a full bootloader like U-Boot or Barebox. Usually,
    there is a simple command-line user interface that will let you perform maintenance
    tasks such as loading new boot and kernel images into flash storage, loading and
    booting a kernel, and there is a way to load the kernel automatically without
    user intervention. The following diagram explains the phase 3 architecture:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后，我们正在运行像U-Boot或Barebox这样的完整引导加载程序。通常，有一个简单的命令行用户界面，让您执行维护任务，如将新的引导和内核映像加载到闪存中，加载和引导内核，并且有一种方法可以在没有用户干预的情况下自动加载内核。以下图解释了第3阶段的架构：
- en: '![Phase 3: TPL](img/B03982_03_04.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![第3阶段：TPL](img/B03982_03_04.jpg)'
- en: Third stage boot
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第三阶段引导
- en: At the end of the third phase, there is a kernel in memory, waiting to be started.
    Embedded bootloaders usually disappear from memory once the kernel is running
    and perform no further part in the operation of the system.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三阶段结束时，内存中存在一个等待启动的内核。嵌入式引导加载程序通常在内核运行后从内存中消失，并且在系统操作中不再起任何作用。
- en: Booting with UEFI firmware
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UEFI固件引导
- en: 'Most embedded PC designs and some ARM designs have firmware based on the **Universal
    Extensible Firmware Interface** (**UEFI**) standard, see the official website
    at [http://www.uefi.org](http://www.uefi.org) for more information. The boot sequence
    is fundamentally the same as described in the preceding section:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数嵌入式PC设计和一些ARM设计都基于通用可扩展固件接口（UEFI）标准的固件，有关更多信息，请参阅官方网站[http://www.uefi.org](http://www.uefi.org)。引导顺序基本上与前一节中描述的相同：
- en: '**Phase 1**: The processor loads the UEFI boot manager firmware from flash
    memory. In some designs, it is loaded directly from NOR flash memory, in others
    there is ROM code on-chip which loads the boot manager from SPI flash memory.
    The boot manager is roughly equivalent to the SPL, but may allow user interaction
    through a text-based or graphical interface.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一阶段**：处理器从闪存加载UEFI引导管理器固件。在某些设计中，它直接从NOR闪存加载，而在其他设计中，芯片上有ROM代码，它从SPI闪存加载引导管理器。引导管理器大致相当于SPL，但可能允许用户通过基于文本或图形界面进行交互。'
- en: '**Phase 2**: The boot manager loads the boot firmware from the **EFI System
    Partition** (**ESP**) or a hard disk or SSD, or from a network server via PXE
    boot. If loading from a local disk drive, the EXP is identified by a well-known
    GUID value of C12A7328-F81F-11D2-BA4B-00A0C93EC93B. The partition should be formatted
    using the FAT32 format. The third stage bootloader should be in a file named `<efi_system_partition>/boot/boot<machine_type_short_name>.efi`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二阶段**：引导管理器从**EFI系统分区**（**ESP**）或硬盘或固态硬盘加载引导固件，或通过PXE引导从网络服务器加载。如果从本地磁盘驱动器加载，则EXP由已知的GUID值C12A7328-F81F-11D2-BA4B-00A0C93EC93B标识。分区应使用FAT32格式进行格式化。第三阶段引导加载程序应该位于名为`<efi_system_partition>/boot/boot<machine_type_short_name>.efi`的文件中。'
- en: 'For example, the file path to the loader on an x86_64 system is: `/efi/boot/bootx64.efi`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在x86_64系统上加载器的文件路径是：`/efi/boot/bootx64.efi`
- en: '**Phase 3**: The TPL in this case has to be a bootloader that is capable of
    loading a Linux kernel and an optional RAM disk into memory. Common choices are:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**第三阶段**：在这种情况下，TPL必须是一个能够将Linux内核和可选的RAM磁盘加载到内存中的引导加载程序。常见选择包括：'
- en: '**GRUB 2**: This is the GNU Grand Unified Bootloader, version 2, and it is
    the most commonly used Linux loader on PC platforms. However, there is one controversy
    in that it is licensed under GPL v3, which may make it incompatible with secure
    booting since the license requires the boot keys to to be supplied with the code.
    The website is [https://www.gnu.org/software/grub/](https://www.gnu.org/software/grub/).'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GRUB 2**：这是GNU统一引导加载程序，第2版，是PC平台上最常用的Linux加载程序。然而，有一个争议，即它根据GPL v3许可，这可能使其与安全引导不兼容，因为许可要求提供代码的引导密钥。网站是[https://www.gnu.org/software/grub/](https://www.gnu.org/software/grub/)。'
- en: '**gummiboot**: This is a simple UEFI-compatible bootloader which has since
    been integrated into systemd, and is licensed under LGPL v2.1 The website is [https://wiki.archlinux.org/index.php/Systemd-boot](https://wiki.archlinux.org/index.php/Systemd-boot).'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gummiboot**：这是一个简单的与UEFI兼容的引导加载程序，已经集成到systemd中，并且根据LGPL v2.1许可。网站是[https://wiki.archlinux.org/index.php/Systemd-boot](https://wiki.archlinux.org/index.php/Systemd-boot)。'
- en: Moving from bootloader to kernel
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从引导加载程序到内核的转移
- en: 'When the bootloader passes control to the kernel it has to pass some basic
    information to the kernel, which may include some of the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当引导加载程序将控制权传递给内核时，它必须向内核传递一些基本信息，其中可能包括以下一些内容：
- en: 'On PowerPC and ARM architectures: a number unique to the type of the SoC'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PowerPC和ARM架构上：一种与SoC类型相关的数字
- en: Basic details of the hardware detected so far, including at least the size and
    location of the physical RAM, and the CPU clock speed
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迄今为止检测到的硬件的基本细节，包括至少物理RAM的大小和位置，以及CPU时钟速度
- en: The kernel command line
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核命令行
- en: Optionally, the location and size of a device tree binary
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的设备树二进制文件的位置和大小
- en: Optionally, the location and size of an initial RAM disk
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的初始RAM磁盘的位置和大小
- en: The kernel command line is a plain ASCII string which controls the behavior
    of Linux, setting, for example, the device that contains the root filesystem.
    I will look at the details of this in the next chapter. It is common to provide
    the root filesystem as a RAM disk, in which case it is the responsibility of the
    bootloader to load the RAM disk image into memory. I will cover the way you create
    initial RAM disks in [Chapter 5](ch05.html "Chapter 5. Building a Root Filesystem"),
    *Building a Root Filesystem*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 内核命令行是一个纯ASCII字符串，用于控制Linux的行为，例如设置包含根文件系统的设备。我将在下一章中详细介绍这一点。通常会将根文件系统提供为RAM磁盘，在这种情况下，引导加载程序有责任将RAM磁盘映像加载到内存中。我将在[第5章](ch05.html
    "第5章。构建根文件系统")中介绍创建初始RAM磁盘的方法，*构建根文件系统*。
- en: The way this information is passed is dependent on the architecture and has
    changed in recent years. For instance, with PowerPC, the bootloader simply used
    to pass a pointer to a board information structure, whereas, with ARM, it passed
    a pointer to a list of "A tags". There is a good description of the format of
    the kernel source in `Documentation/arm/Booting`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 传递这些信息的方式取决于架构，并且近年来发生了变化。例如，对于PowerPC，引导加载程序过去只是传递一个指向板信息结构的指针，而对于ARM，它传递了一个指向“A标签”列表的指针。在`Documentation/arm/Booting`中有关内核源代码格式的良好描述。
- en: In both cases, the amount of information passed was very limited, leaving the
    bulk of it to be discovered at runtime or hard-coded into the kernel as "platform
    data". The widespread use of platform data meant that each device had to have
    a kernel configured and modified for that platform. A better way was needed, and
    that way is the device tree. In the ARM world, the move away from A tags began
    in earnest in February 2013 with the release of Linux 3.8 but there are still
    quite a lot of devices in the field, and even in development, still using A tags.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，传递的信息量非常有限，大部分信息需要在运行时发现或硬编码到内核中作为“平台数据”。广泛使用平台数据意味着每个设备都必须有为该平台配置和修改的内核。需要一种更好的方法，这种方法就是设备树。在ARM世界中，从2013年2月发布Linux
    3.8开始，逐渐摆脱了A标签，但仍然有相当多的设备在现场使用，甚至在开发中，仍在使用A标签。
- en: Introducing device trees
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍设备树
- en: You are almost certainly going to encounter device trees at some point. This
    section aims to give you a quick overview of what they are and how they work but
    there are many details that are not discussed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎肯定会在某个时候遇到设备树。本节旨在为您快速概述它们是什么以及它们是如何工作的，但有许多细节没有讨论。
- en: A device tree is a flexible way to define the hardware components of a computer
    system. Usually, the device tree is loaded by the bootloader and passed to the
    kernel, although it is possible to bundle the device tree with the kernel image
    itself to cater for bootloaders that are not capable of handling them separately.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树是定义计算机系统的硬件组件的灵活方式。通常，设备树由引导加载程序加载并传递给内核，尽管也可以将设备树与内核映像捆绑在一起，以适应不能单独处理它们的引导加载程序。
- en: The format is derived from a Sun Microsystems bootloader known as OpenBoot,
    which was formalized as the Open Firmware specification, IEEE standard IEEE1275-1994\.
    It was used in PowerPC-based Macintosh computers and so was a logical choice for
    the PowerPC Linux port. Since then, it has been adapted on a large scale by the
    many ARM Linux implementations and, to a lesser extent, by MIPS, MicroBlaze, ARC,
    and other architectures.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 该格式源自Sun Microsystems引导加载程序OpenBoot，它被正式规范为Open Firmware规范，IEEE标准IEEE1275-1994。它曾在基于PowerPC的Macintosh计算机上使用，因此是PowerPC
    Linux端口的一个合乎逻辑的选择。从那时起，它已被许多ARM Linux实现大规模采用，并在较小程度上被MIPS、MicroBlaze、ARC和其他架构所采用。
- en: I would recommend visiting [http://devicetree.org](http://devicetree.org) for
    more information.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议访问[http://devicetree.org](http://devicetree.org)获取更多信息。
- en: Device tree basics
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备树基础
- en: The Linux kernel contains a large number of device tree source files in `arch/$ARCH/boot/dts`,
    and this is a good starting point for learning about device trees. There are also
    a smaller number of sources in the U-boot source code in `arch/$ARCH/dts`. If
    you acquired your hardware from a third party, the `dts` file forms part of a
    board support package and you should expect to receive one along with the other
    source files.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核包含大量设备树源文件，位于`arch/$ARCH/boot/dts`，这是学习设备树的良好起点。U-boot源代码中也有较少数量的源文件，位于`arch/$ARCH/dts`。如果您从第三方获取硬件，则`dts`文件是板支持包的一部分，您应该期望收到其他源文件以及它。
- en: 'The device tree represents a computer system as a collection of components
    joined together in a hierarchy, like a tree. The device tree begins with a root
    node, represented by a forward slash, `/`, which contains subsequent nodes representing
    the hardware of the system. Each node has a name and contains a number of properties
    in the form `name = "value"`. Here is a simple example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树将计算机系统表示为一个层次结构中连接在一起的组件的集合，就像一棵树。设备树以根节点开始，由正斜杠`/`表示，其中包含代表系统硬件的后续节点。每个节点都有一个名称，并包含一些形式为`name
    = "value"`的属性。这是一个简单的例子：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we have a root node which contains a `cpus` node and a memory node. The
    `cpus` node contains a single CPU node named `cpu@0`. It is a common convention
    that the names of nodes include an `@` followed by an address that distinguishes
    them from any others.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个包含`cpus`节点和内存节点的根节点。`cpus`节点包含一个名为`cpu@0`的单个CPU节点。通常约定节点的名称包括一个`@`后跟一个地址，用于将其与其他节点区分开。
- en: Both the root and CPU nodes have a compatible property. The Linux kernel uses
    this to match this name against the strings exported by device drivers in a `struct
    of_device_id` (more on this in [Chapter 8](ch08.html "Chapter 8. Introducing Device
    Drivers"), *Introducing Device Drivers*). It is a convention that the value is
    composed of a manufacturer name and a component name to reduce confusion between
    similar devices made by different manufacturers, hence `ti,am33xx` and `arm,cortex-a8`.
    It is also quite common to have more than one value for `compatible` where there
    is more than one driver that can handle this device. They are listed with the
    most suitable first.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 根节点和CPU节点都有一个兼容属性。Linux内核使用这个属性来将此名称与设备驱动程序中的`struct of_device_id`导出的字符串进行匹配（有关更多信息，请参见[第8章](ch08.html
    "第8章。介绍设备驱动程序")，“介绍设备驱动程序”）。这是一个惯例，该值由制造商名称和组件名称组成，以减少不同制造商制造的类似设备之间的混淆，因此`ti,am33xx`和`arm,cortex-a8`。`compatible`通常有多个值，其中有多个驱动程序可以处理此设备。它们按最合适的顺序列出。
- en: The CPU node and the memory node have a `device_type` property which describes
    the class of device. The node name is often derived from the `device_type`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: CPU节点和内存节点都有一个`device_type`属性，描述设备的类别。节点名称通常是从`device_type`派生的。
- en: The reg property
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: reg属性
- en: The memory and CPU nodes have a `reg` property, which refers to a range of units
    in a register space. A `reg` property consists of two values representing the
    start address and the size (length) of the range. Both are written down as zero
    or more 32-bit integers, called cells. Hence, the memory node refers to a single
    bank of memory that begins at 0x80000000 and is 0x20000000 bytes long.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 内存和CPU节点都有一个`reg`属性，它指的是寄存器空间中的一系列单元。`reg`属性由两个值组成，表示范围的起始地址和大小（长度）。两者都以零个或多个32位整数（称为单元）写下。因此，内存节点指的是从0x80000000开始，长度为0x20000000字节的单个内存银行。
- en: 'Understanding `reg` properties becomes more complex when the address or size
    values cannot be represented in 32 bits. For example, on a device with 64-bit
    addressing, you need two cells for each:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当地址或大小值无法用32位表示时，理解`reg`属性变得更加复杂。例如，在具有64位寻址的设备上，每个需要两个单元：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The information about the number of cells required is held in `#address-cells`
    and `#size_cells` declarations in an ancestor node. In other words, to understand
    a `reg` property, you have to look backwards down the node hierarchy until you
    find `#address-cells` and `#size_cells`. If there are none, the default values
    are `1` for each – but it is bad practice for device tree writers to depend on
    fall-backs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有关所需单元数的信息存储在祖先节点中的`#address-cells`和`#size_cells`声明中。换句话说，要理解`reg`属性，您必须向下查找节点层次结构，直到找到`#address-cells`和`#size_cells`。如果没有，则默认值为每个都是`1`
    - 但是依赖后备是设备树编写者的不良做法。
- en: 'Now, let''s return to the cpu and cpus nodes. CPUs have addresses as well:
    in a quad core device they might be addressed as 0, 1, 2, and 3\. That can be
    thought of as a one-dimensional array without any depth so the size is zero. Therefore,
    you can see that we have `#address-cells = <1>` and `#size-cells = <0>` in the
    cpus node, and in the child node, `cpu@0`, we assign a single value to the `reg`
    property: node `reg = <0>`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到cpu和cpus节点。 CPU也有地址：在四核设备中，它们可能被标记为0、1、2和3。这可以被看作是一个没有深度的一维数组，因此大小为零。因此，你可以看到在cpus节点中我们有`#address-cells
    = <1>`和`#size-cells = <0>`，在子节点`cpu@0`中，我们为`reg`属性分配了一个单一值：节点`reg = <0>`。
- en: Phandles and interrupts
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Phandles和中断
- en: The structure of the device tree described so far assumes that there is a single
    hierarchy of components, whereas in fact there are several. As well as the obvious
    data connection between a component and other parts of the system, it might also
    be connected to an interrupt controller, to a clock source and to a voltage regulator.
    To express these connections, we have phandles.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，设备树的结构假设存在一个组件的单一层次结构，而实际上存在多个层次结构。除了组件与系统其他部分之间的明显数据连接之外，它还可能连接到中断控制器、时钟源和电压调节器。为了表达这些连接，我们有phandles。
- en: 'Take an example of a system containing a serial port which can generate interrupts
    and the interrupt controller:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个包含可以生成中断并且中断控制器的串行端口的系统为例：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have an interrupt-controller node which has the special property `#interrupt-cells`,
    which tells us how many 4-byte values are needed to represent an interrupt line.
    In this case, it is just one giving the IRQ number, but it is quite common to
    use additional values to characterize the interrupt, for example `1 = low-to-high
    edge triggered`, `2 = high-to-low edge triggered`, and so on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个中断控制器节点，它有特殊属性`#interrupt-cells`，告诉我们需要多少个4字节值来表示一个中断线。在这种情况下，只需要一个给出IRQ号码，但通常使用额外的值来描述中断，例如`1
    = 低到高边沿触发`，`2 = 高到低边沿触发`，等等。
- en: Looking at the serial node, it has an `interrupt-parent` property which references
    the interrupt-controller it is connected to by using its label. This is the phandle.
    The actual IRQ line is given by the `interrupts` property, `72` in this case.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`serial`节点，它有一个`interrupt-parent`属性，引用了它连接到的中断控制器的标签。这就是phandle。实际的IRQ线由`interrupts`属性给出，在这种情况下是`72`。
- en: 'The `serial` node has other properties that we have not seen before: `clock-frequency`
    and `ti,hwmods`. These are part of the bindings for this particular type of device,
    in other words, the kernel device driver will read these properties to manage
    the device. The bindings can be found in the Linux kernel source, in directory
    `Documentation/devicetree/bindings/`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`serial`节点有其他我们之前没有见过的属性：`clock-frequency`和`ti,hwmods`。这些是特定类型设备的绑定的一部分，换句话说，内核设备驱动程序将读取这些属性来管理设备。这些绑定可以在Linux内核源代码的`Documentation/devicetree/bindings/`目录中找到。'
- en: Device tree include files
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设备树包含文件
- en: 'A lot of hardware is common between SoCs of the same family and between boards
    using the same SoC. This is reflected in the device tree by splitting out common
    sections into `include` files, usually with the extension `.dtsi`. The Open Firmware
    standard defines `/include/` as the mechanism to be used, as in this snippet from
    `vexpress-v2p-ca9.dts`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 许多硬件在同一系列SoC和使用相同SoC的板之间是共同的。这在设备树中通过将共同部分拆分为`include`文件来反映，通常使用扩展名`.dtsi`。开放固件标准将`/include/`定义为要使用的机制，就像在`vexpress-v2p-ca9.dts`的这个片段中一样：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Look through the `.dts` files in the kernel, though, and you will find an alternative
    `include` statement that is borrowed from C, for example in `am335x-boneblack.dts`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核的`.dts`文件中查找，你会发现一个借用自C的替代`include`语句，例如在`am335x-boneblack.dts`中：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here is another example from `am33xx.dtsi`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`am33xx.dtsi`的另一个例子：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Lastly, `include/dt-bindings/pinctrl/am33xx.h` contains normal C macros:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`include/dt-bindings/pinctrl/am33xx.h`包含普通的C宏：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'All of this is resolved if the device tree sources are built using kernel kbuild,
    which first runs them through the C pre-processor, `cpp`, where the `#include`
    and `#define` statements are processed into plain text that is suitable for the
    device tree compiler. The motivation is shown in the previous example: it means
    that device tree sources can use the same constant definitions as the kernel code.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备树源文件使用内核kbuild构建，所有这些问题都会得到解决，因为它首先通过C预处理器`cpp`运行它们，其中`#include`和`#define`语句被处理成适合设备树编译器的纯文本。先前的示例中显示了这一动机：这意味着设备树源可以使用与内核代码相同的常量定义。
- en: 'When we include files in this way the nodes are overlaid on top of one another
    to create a composite tree in which the outer layers extend or modify the inner
    ones. For example, `am33xx.dtsi,` which is general to all am33xx SoCs, defines
    the first MMC controller interface like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以这种方式包含文件时，节点会叠加在一起，以创建一个复合树，其中外层扩展或修改内层。例如，`am33xx.dtsi`，它适用于所有am33xx SoC，像这样定义了第一个MMC控制器接口：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the status is `disabled`, meaning that no device driver should be
    bound to it, and also that it has the label `mmc1`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，状态是`disabled`，意味着没有设备驱动程序应该绑定到它，而且它有标签`mmc1`。
- en: 'In `am335x-bone-common.dtsi`, which is included with both BeagleBone and BeagleBone
    Black, the same node is referenced by its phandle:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`am335x-bone-common.dtsi`中，它被BeagleBone和BeagleBone Black都包含，相同的节点通过它的phandle被引用：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, `mmc1` is enabled (`status="okay"`) because both variants have a physical
    MMC1 device, and the `pinctrl` is established. Then, in `am335x-boneblack.dts,`
    you will see another reference to `mmc1` which associates it with a voltage regulator:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`mmc1`被启用（`status="okay"`）因为两个变体都有物理MMC1设备，并且`pinctrl`已经建立。然后，在`am335x-boneblack.dts`中，你会看到另一个对`mmc1`的引用，它将其与电压调节器关联起来：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, layering source files like this gives flexibility and reduces the need for
    duplicated code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，像这样分层源文件可以提供灵活性，并减少重复代码的需求。
- en: Compiling a device tree
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译设备树
- en: The bootloader and kernel require a binary representation of the device tree,
    so it has to be compiled using the device tree compiler, `dtc`. The result is
    a file ending with `.dtb`, which is referred to as a device tree binary or a device
    tree blob.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序和内核需要设备树的二进制表示，因此必须使用设备树编译器`dtc`进行编译。结果是一个以`.dtb`结尾的文件，称为设备树二进制或设备树blob。
- en: 'There is a copy of `dtc` in the Linux source, in `scripts/dtc/dtc`, and it
    is also available as a package on many Linux distributions. You can use it to
    compile a simple device tree (one that does not use `#include`) like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Linux源代码中有一个`dtc`的副本，在`scripts/dtc/dtc`中，它也可以作为许多Linux发行版的软件包使用。您可以使用它来编译一个简单的设备树（不使用`#include`的设备树）如下：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Be wary of the fact that `dtc` does not give helpful error messages and it makes
    no checks other than on the basic syntax of the language, which means that debugging
    a typing error in a source file can be a lengthy business.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意的是，`dtc`不提供有用的错误消息，它只对语言的基本语法进行检查，这意味着在源文件中调试打字错误可能是一个漫长的过程。
- en: To build more complex examples, you will have to use the kernel `kbuild`, as
    shown in the next chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建更复杂的示例，您将需要使用内核`kbuild`，如下一章所示。
- en: Choosing a bootloader
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择引导加载程序
- en: 'Bootloaders come in all shapes and sizes. The kind of characteristics you want
    from a bootloader are that they be simple and customizable with lots of sample
    configurations for common development boards and devices. The following table
    shows a number of them that are in general use:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序有各种形状和大小。您希望从引导加载程序中获得的特征是它们简单且可定制，并且有许多常见开发板和设备的示例配置。以下表格显示了一些通常使用的引导加载程序：
- en: '| Name | Architectures |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 架构 |'
- en: '| --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Das U-Boot | ARM, Blackfin, MIPS, PowerPC, SH |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| Das U-Boot | ARM, Blackfin, MIPS, PowerPC, SH |'
- en: '| Barebox | ARM, Blackfin, MIPS, PowerPC |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| Barebox | ARM, Blackfin, MIPS, PowerPC |'
- en: '| GRUB 2 | X86, X86_64 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| GRUB 2 | X86, X86_64 |'
- en: '| RedBoot | ARM, MIPS, PowerPC, SH |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| RedBoot | ARM, MIPS, PowerPC, SH |'
- en: '| CFE | Broadcom MIPS |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| CFE | Broadcom MIPS |'
- en: '| YAMON | MIPS |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| YAMON | MIPS |'
- en: We are going to focus on U-Boot because it supports a good number of processor
    architectures and a large number of individual boards and devices. It has been
    around for a long time and has a good community for support.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于U-Boot，因为它支持许多处理器架构和大量的个别板和设备。它已经存在很长时间，并且有一个良好的社区支持。
- en: It may be that you received a bootloader along with your SoC or board. As always,
    take a good look at what you have and ask questions about where you can get the
    source code from, what the update policy is, how they will support you if you
    want to make changes, and so on. You may want to consider abandoning the vendor-supplied
    loader and use the current version of an open source bootloader instead.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您收到了一个与您的SoC或板一起的引导加载程序。像往常一样，仔细看看您拥有的东西，并询问您可以从哪里获取源代码，更新政策是什么，如果您想进行更改他们将如何支持您等等。您可能要考虑放弃供应商提供的加载程序，改用开源引导加载程序的当前版本。
- en: U-Boot
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: U-Boot
- en: U-Boot, or to give its full name, Das U-Boot, began life as an open source bootloader
    for embedded PowerPC boards. Then, it was ported to ARM-based boards and later
    to other architectures, including MIPS, SH, and x86\. It is hosted and maintained
    by Denx Software Engineering. There is plenty of information available, and a
    good place to start is [www.denx.de/wiki/U-Boot](http://www.denx.de/wiki/U-Boot).
    There is also a mailing list at `<[u-boot@lists.denx.de](mailto:u-boot@lists.denx.de)>`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot，或者以其全名Das U-Boot，最初是嵌入式PowerPC板的开源引导加载程序。然后，它被移植到基于ARM的板上，后来又移植到其他架构，包括MIPS、SH和x86。它由Denx软件工程托管和维护。有大量的信息可用，一个很好的起点是[www.denx.de/wiki/U-Boot](http://www.denx.de/wiki/U-Boot)。还有一个邮件列表在`<[u-boot@lists.denx.de](mailto:u-boot@lists.denx.de)>`。
- en: Building U-Boot
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建U-Boot
- en: 'Begin by getting the source code. As with most projects, the recommended way
    is to clone the git archive and check out the tag you intend to use which, in
    this case, is the version that was current at the time of writing:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要获取源代码。与大多数项目一样，推荐的方法是克隆git存档并检出您打算使用的标签，本例中是写作时的当前版本：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Alternatively, you can get a tarball from [ftp://ftp.denx.de/pub/u-boot/](ftp://ftp.denx.de/pub/u-boot/).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以从[ftp://ftp.denx.de/pub/u-boot/](ftp://ftp.denx.de/pub/u-boot/)获取一个tarball。
- en: There are more than 1,000 configuration files for common development boards
    and devices in the `configs/` directory. In most cases, you can make a good guess
    of which to use, based on the filename, but you can get more detailed information
    by looking through the per-board `README` files in the `board/` directory, or
    you can find information in an appropriate web tutorial or forum. Beware, though,
    the way U-Boot is configured has undergone a lot of changes since the 2014.10
    release. Double-check that the instructions you are following are appropriate.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在`configs/`目录中有超过1,000个常见开发板和设备的配置文件。在大多数情况下，您可以根据文件名猜出要使用哪个，但您可以通过查看`board/`目录中每个板的`README`文件来获取更详细的信息，或者您可以在适当的网络教程或论坛中找到信息。不过要注意，自2014.10版本以来，U-Boot的配置方式发生了很多变化。请仔细检查您正在遵循的说明是否合适。
- en: 'Taking the BeagleBone Black as an example, we find that there is a likely configuration
    file named `am335x_boneblack_defconfig` in `configs/` and we find the text **The
    binary produced by this board supports … Beaglebone Black** in the board `README`
    files for the am335x chip, `board/ti/am335x/README`. With this knowledge, building
    U-Boot for a BeagleBone Black is simple. You need to inform U-Boot of the prefix
    for your cross compiler by setting the `make` variable `CROSS_COMPILE` and then
    select the configuration file using a command of the type `make [board]_defconfig`,
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以BeagleBone Black为例，我们发现在`configs/`中有一个名为`am335x_boneblack_defconfig`的可能配置文件，并且在am335x芯片的板`README`文件`board/ti/am335x/README`中找到了文本**该板生成的二进制文件支持...Beaglebone
    Black**。有了这些知识，为BeagleBone Black构建U-Boot就很简单了。您需要通过设置`make`变量`CROSS_COMPILE`来告知U-Boot交叉编译器的前缀，然后使用`make
    [board]_defconfig`类型的命令选择配置文件，如下所示：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The results of the compilation are:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 编译的结果是：
- en: '`u-boot`: This is U-Boot in ELF object format, suitable for use with a debugger'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u-boot`：这是以ELF对象格式的U-Boot，适合与调试器一起使用'
- en: '`u-boot.map`: This is the symbol table'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u-boot.map`：这是符号表'
- en: '`u-boot.bin`: This is U-Boot in raw binary format, suitable for running on
    your device'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u-boot.bin`：这是U-Boot的原始二进制格式，适合在设备上运行'
- en: '`u-boot.img`: This is `u-boot.bin` with a U-Boot header added, suitable for
    uploading to a running copy of U-Boot'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u-boot.img`：这是`u-boot.bin`添加了U-Boot头的版本，适合上传到正在运行的U-Boot副本'
- en: '`u-boot.srec`: This is U-Boot in Motorola `srec` format, suitable for transferring
    over a serial connection'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u-boot.srec`：这是以Motorola `srec`格式的U-Boot，适合通过串行连接传输'
- en: 'The BeagleBone Black also requires a **Secondary Program Loader** (**SPL**),
    as described earlier. This is built at the same time and is named `MLO`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: BeagleBone Black还需要一个**Secondary Program Loader**（**SPL**），如前所述。这是同时构建的，命名为`MLO`。
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The procedure is similar for other targets.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 其他目标的过程类似。
- en: Installing U-Boot
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装U-Boot
- en: Installing a bootloader on a board for the first time requires some outside
    assistance. If the board has a hardware debug interface, such as JTAG, it is usually
    possible to load a copy of U-Boot directly into RAM and set it running. From that
    point, you can use U-Boot commands to copy it into flash memory. The details of
    this are very board-specific and outside the scope of this book.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首次在板上安装引导加载程序需要一些外部帮助。如果板上有硬件调试接口，比如JTAG，通常可以直接将U-Boot的副本加载到RAM中并运行。从那时起，您可以使用U-Boot命令将其复制到闪存中。这些细节非常依赖于板子，并且超出了本书的范围。
- en: Some SoC designs have a boot ROM built in which can be used to read boot code
    from various external sources such as SD cards, serial interfaces, or USBs, and
    this is the case with the AM335x chip in the BeagleBone Black. Here is how to
    load U-Boot via the micro-SD card.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一些SoC设计内置了引导ROM，可以用于从各种外部来源（如SD卡、串行接口或USB）读取引导代码，BeagleBone Black中的AM335x芯片就是这种情况。以下是如何通过micro-SD卡加载U-Boot。
- en: 'Firstly, format a micro-SD card so that the first partition is in FAT32 format,
    and mark it as bootable. If you have a direct SD slot available, the card appears
    as `/dev/mmcblk0`, otherwise, if you are using a memory card reader, it will be
    seen as `/dev/sdb`, or `/dev/sdc`, and so on. Now, type the following command
    to partition the micro-SD card, assuming that the card is seen as `/dev/mmcblk0`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，格式化micro-SD卡，使第一个分区为FAT32格式，并标记为可引导。如果有直接的SD卡插槽可用，卡片将显示为`/dev/mmcblk0`，否则，如果使用内存卡读卡器，它将显示为`/dev/sdb`，或`/dev/sdc`等。现在，假设卡片显示为`/dev/mmcblk0`，输入以下命令对micro-SD卡进行分区：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Format the first partition as `FAT16`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将第一个分区格式化为`FAT16`：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, mount the partition you have just formatted: on some systems it is enough
    to simply remove the micro-SD card and then plug it back in again, on others you
    may have to click on an icon. On current versions of Ubuntu, it should be mounted
    as `/media/[user]/boot` so I would copy U-Boot and the SPL to it like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，挂载您刚刚格式化的分区：在某些系统上，只需简单地拔出micro-SD卡，然后再插入即可，而在其他系统上，您可能需要单击一个图标。在当前版本的Ubuntu上，它应该被挂载为`/media/[user]/boot`，所以我会像这样将U-Boot和SPL复制到它：
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, unmount it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，卸载它。
- en: With no power on the BeagleBone board, insert the micro-SD card.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在BeagleBone板上没有电源的情况下，插入micro-SD卡。
- en: Plug in the serial cable. A serial port should appear on your PC as `/dev/ttyUSB0`
    or similar.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 插入串行电缆。串行端口应该出现在您的PC上，如`/dev/ttyUSB0`或类似。
- en: 'Start a suitable terminal program such as `gtkterm`, `minicom`, or `picocom`
    and attach to the port at 115,200 bps with no flow control:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 启动适当的终端程序，如`gtkterm`、`minicom`或`picocom`，并以115,200 bps的速度，无流控制连接到端口：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Press and hold the **Boot Switch** button on the Beaglebone, power up the board
    using the external 5V power connector, and release the button after about 5 seconds.
    You should see a U-Boot prompt on the serial console:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 按住Beaglebone上的**Boot Switch**按钮，使用外部5V电源连接器启动板，大约5秒后释放按钮。您应该在串行控制台上看到一个U-Boot提示：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using U-Boot
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用U-Boot
- en: In this section, I will describe some of the common tasks that you can use U-Boot
    to perform.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将描述一些您可以使用U-Boot执行的常见任务。
- en: Usually, U-Boot offers a command-line interface over a serial port. It gives
    a command prompt which is customized for each board. In the examples, I will use
    `U-Boot#`. Typing `help` prints out all the commands configured in this version
    of U-Boot; typing `help <command>` prints out more information about a particular
    command.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，U-Boot通过串行端口提供命令行界面。它提供一个为每个板定制的命令提示符。在示例中，我将使用`U-Boot#`。输入`help`会打印出此版本U-Boot中配置的所有命令；输入`help
    <command>`会打印出有关特定命令的更多信息。
- en: The default command interpreter is quite simple. There is no command-line editing
    by pressing cursor left or right keys; there is no command completion by pressing
    the *Tab* key; there is no command history by pressing the cursor up key. Pressing
    any of these keys will disrupt the command you are currently trying to type and
    you will have to type `Ctrl`+`C` and start over again. The only line editing key
    you can safely use is the back space. As an option, you can configure a different
    command shell called Hush, which has more sophisticated interactive support.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的命令解释器非常简单。按左右光标键没有命令行编辑；按*Tab*键没有命令完成；按上光标键没有命令历史。按下这些键会中断您当前尝试输入的命令，您将不得不输入`Ctrl`+`C`并重新开始。您唯一可以安全使用的行编辑键是退格键。作为一个选项，您可以配置一个名为Hush的不同命令外壳，它具有更复杂的交互式支持。
- en: 'The default number format is hexadecimal. For example, as shown in this command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的数字格式是十六进制。例如，如下命令所示：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command will read 0x200000 bytes from offset 0x400000 from the start of
    the NAND flash memory into RAM address 0x82000000.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将从NAND闪存的偏移0x400000处读取0x200000字节，加载到RAM地址0x82000000处。
- en: Environment variables
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境变量
- en: 'U-Boot uses environment variables extensively to store and pass information
    between functions and even to create scripts. Environment variables are simple
    `name=value` pairs that are stored in an area of memory. The initial population
    of variables may be coded in the board configuration header file, like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot广泛使用环境变量来存储和传递信息，甚至创建脚本。环境变量是简单的`name=value`对，存储在内存的一个区域中。变量的初始填充可以在板配置头文件中编码，如下所示：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can create and modify variables from the U-Boot command line using `setenv`.
    For example `setenv foo bar` creates the variable `foo` with the value `bar`.
    Note that there is no `=` sign between the variable name and the value. You can
    delete a variable by setting it to a null string, `setenv foo`. You can print
    all the variables to the console using `printenv`, or a single variable using
    `printenv foo`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`setenv`从U-Boot命令行创建和修改变量。例如，`setenv foo bar`会创建变量`foo`，其值为`bar`。请注意，变量名称和值之间没有`=`号。您可以通过将其设置为空字符串`setenv
    foo`来删除变量。您可以使用`printenv`将所有变量打印到控制台，或者使用`printenv foo`打印单个变量。
- en: Usually, it is possible to use the `saveenv` command to save the entire environment
    to permanent storage of some kind. If there is raw NAND or NOR flash, then an
    erase block is reserved for this purpose, often with another used for a redundant
    copy to guard against corruption. If there is eMMC or SD card storage it can be
    stored in a file in a partition of the disk. Other options include storing in
    a serial EEPROM connected via an I2C or SPI interface or non-volatile RAM.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，可以使用`saveenv`命令将整个环境保存到某种永久存储中。如果有原始NAND或NOR闪存，则会保留一个擦除块，通常还有另一个用于冗余副本，以防止损坏。如果有eMMC或SD卡存储，它可以存储在磁盘分区中的文件中。其他选项包括存储在通过I2C或SPI接口连接的串行EEPROM中，或者存储在非易失性RAM中。
- en: Boot image format
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引导映像格式
- en: 'U-Boot doesn''t have a filesystem. Instead, it tags blocks of information with
    a 64-byte header so that it can track the contents. You prepare files for U-Boot
    using the `mkimage` command. Here is a brief summary of its usage:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: U-Boot没有文件系统。相反，它使用64字节的标头标记信息块，以便跟踪内容。您可以使用`mkimage`命令为U-Boot准备文件。以下是其用法的简要总结：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For example, to prepare a kernel image for an ARM processor, the command is:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为ARM处理器准备内核映像的命令是：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Loading images
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载映像
- en: 'Usually, you will load images from removable storage such as an SD card or
    a network. SD cards are handled in U-Boot by the `mmc` driver. A typical sequence
    to load an image into memory would be:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您将从可移动存储介质（如SD卡或网络）加载映像。SD卡在U-Boot中由`mmc`驱动程序处理。将映像加载到内存的典型序列如下：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The command `mmc rescan` re-initializes the `mmc` driver, perhaps to detect
    that an SD card has recently been inserted. Next, `fatload` is used to read a
    file from a FAT-formatted partition on the SD card. The format is:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`mmc rescan`命令重新初始化`mmc`驱动程序，也许是为了检测最近插入的SD卡。接下来，使用`fatload`从SD卡上的FAT格式分区中读取文件。格式如下：'
- en: '`fatload <interface> [<dev[:part]> [<addr> [<filename> [bytes [pos]]]]]`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`fatload <interface> [<dev[:part]> [<addr> [<filename> [bytes [pos]]]]]`'
- en: If `<interface>` is `mmc`, as in our case, `<dev:part>` is the device number
    of the `mmc` interface counting from zero, and the partition number counting from
    one. Hence `<0:1>` is the first partition on the first device. The memory location,
    `0x82000000`, is chosen to be in an area of RAM that is not being used at this
    moment. If we intend to boot this kernel, we have to make sure that this area
    of RAM will not be overwritten when the kernel image is decompressed and located
    at the runtime location, `0x80008000`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`<interface>`是`mmc`，如我们的情况，`<dev:part>`是从零开始计数的`mmc`接口的设备号，以及从一开始计数的分区号。因此，`<0:1>`是第一个设备上的第一个分区。选择的内存位置`0x82000000`是为了在此时未被使用的RAM区域中。如果我们打算引导此内核，我们必须确保在解压缩内核映像并将其定位到运行时位置`0x80008000`时，不会覆盖此RAM区域。
- en: 'To load image files over a network you use the **Trivial File Transfer Protocol**
    (**TFTP**). This requires you to install a TFTP daemon, tftpd, on your development
    system and start it running. You also have to configure any firewalls between
    your PC and the target board to allow the TFTP protocol on UDP port 69 to pass
    through. The default configuration of tftpd allows access only to the directory
    `/var/lib/tftpboot`. The next step is to copy the files you want to transfer to
    the target into that directory. Then, assuming that you are using a pair of static
    IP addresses, which removes the need for further network administration, the sequence
    of commands to load a set of kernel image files should look like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过网络加载映像文件，您可以使用**Trivial File Transfer Protocol**（**TFTP**）。这需要您在开发系统上安装TFTP守护程序tftpd，并启动它运行。您还必须配置PC和目标板之间的任何防火墙，以允许UDP端口69上的TFTP协议通过。tftpd的默认配置仅允许访问目录`/var/lib/tftpboot`。下一步是将要传输的文件复制到该目录中。然后，假设您使用一对静态IP地址，这样就无需进行进一步的网络管理，加载一组内核映像文件的命令序列应如下所示：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, let''s look at how to program images into NAND flash memory and read
    them back, which is is handled by the `nand` command. This example loads a kernel
    image via TFTP and programs it into flash:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如何将映像编程到NAND闪存中并读取它们，这由`nand`命令处理。此示例通过TFTP加载内核映像并将其编程到闪存：
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now you can load the kernel from flash memory using `nand read`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以使用`nand read`从闪存中加载内核：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Booting Linux
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导Linux
- en: 'The `bootm` command starts a kernel image running. The syntax is:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`bootm`命令启动内核映像。语法是：'
- en: '`bootm [address of kernel] [address of ramdisk] [address of dtb]`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`bootm [内核地址] [ramdisk地址] [dtb地址]`。'
- en: 'The address of the kernel image is necessary, but the address of ramdisk and
    dtb can be omitted if the kernel configuration does not need them. If there is
    a dtb but no ramdisk, the second address can be replaced with a dash (`-`). That
    would look like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 内核映像的地址是必需的，但如果内核配置不需要ramdisk和dtb，则可以省略ramdisk和dtb的地址。如果有dtb但没有ramdisk，则第二个地址可以替换为破折号（`-`）。看起来像这样：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Automating the boot with U-Boot scripts
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用U-Boot脚本自动引导
- en: Plainly, typing a long series of commands to boot your board each time it is
    turned on is not acceptable. To automate the process, U-Boot stores a sequence
    of commands in environment variables. If the special variable named `bootcmd`
    contains a script, it is run at power-up after a delay of `bootdelay` seconds.
    If you are watching this on the serial console, you will see the delay counting
    down to zero. You can press any key during this period to terminate the countdown
    and enter into an interactive session with U-Boot.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，每次打开电源时键入一长串命令来引导板是不可接受的。为了自动化这个过程，U-Boot将一系列命令存储在环境变量中。如果特殊变量`bootcmd`包含一个脚本，它将在`bootdelay`秒的延迟后在上电时运行。如果你在串行控制台上观看，你会看到延迟倒计时到零。在这段时间内，你可以按任意键终止倒计时，并进入与U-Boot的交互会话。
- en: 'The way that you create scripts is simple, though not easy to read. You simply
    append commands separated by semicolons, which must be preceded by a backslash
    escape character. So, for example, to load a kernel image from an offset in flash
    memory and boot it, you might use the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 创建脚本的方式很简单，尽管不容易阅读。你只需附加由分号分隔的命令，分号前必须有一个反斜杠转义字符。因此，例如，要从闪存中的偏移加载内核镜像并引导它，你可以使用以下命令：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Porting U-Boot to a new board
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将U-Boot移植到新板
- en: Let's assume that your hardware department has created a new board called "Nova"
    that is based on the BeagleBone Black and that you need to port U-Boot to it.
    You will need to understand the layout of the U-Boot code and how the board configuration
    mechanism works. In the 2014.10 release, U-Boot adopted the same configuration
    mechanism as the Linux kernel, `Kconfig`. Over the next few releases, the existing
    configuration settings will be moved from the current location in the header files
    in `include/configs` into `Kconfig` files. As of the 2014.10 release, each board
    had a `Kconfig` file which contains minimal information derived from the old `boards.cfg`
    file.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的硬件部门创建了一个基于BeagleBone Black的名为“Nova”的新板，你需要将U-Boot移植到它上面。你需要了解U-Boot代码的布局以及板配置机制的工作原理。在2014.10版本中，U-Boot采用了与Linux内核相同的配置机制，`Kconfig`。在接下来的几个版本中，现有的配置设置将从`include/configs`中的当前位置移动到`Kconfig`文件中。截至2014.10版本，每个板都有一个`Kconfig`文件，其中包含从旧的`boards.cfg`文件中提取的最小信息。
- en: 'The main directories you will be dealing with are:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要处理的主要目录是：
- en: '`arch`: Contains code specific to each supported architecture in directories
    arm, mips, powerpc, and so on. Within each architecture, there is a subdirectory
    for each member of the family, for example, in `arch/arm/cpu`, there are directories
    for the architecture variants, including amt926ejs, armv7, and armv8.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arch`：包含特定于每个支持的架构的代码，位于arm、mips、powerpc等目录中。在每个架构中，都有一个家族成员的子目录，例如在`arch/arm/cpu`中，有包括amt926ejs、armv7和armv8在内的架构变体的目录。'
- en: '`board`: Contains code specific to a board. Where there are several boards
    from the same vendor, they can be collected together into a subdirectory, hence
    the support for the am335x evm board, on which the BeagelBone is based, is in
    `board/ti/am335x`.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`板`: 包含特定于板的代码。如果同一个供应商有多个板，它们可以被收集到一个子目录中，因此基于BeagelBone的am335x evm板的支持在`board/ti/am335x`中。'
- en: '`common`: Contains core functions including the command shells and the commands
    that can be called from them, each in a file named `cmd_[command name].c`.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`公共`: 包含核心功能，包括命令行和可以从中调用的命令，每个命令都在一个名为`cmd_[命令名称].c`的文件中。'
- en: '`doc`: Contains several `README` files describing various aspects of U-Boot.
    If you are wondering how to proceed with your U-Boot port, this is a good place
    to start.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doc`：包含几个描述U-Boot各个方面的`README`文件。如果你想知道如何进行U-Boot移植，这是一个很好的起点。'
- en: '`include`: In addition to many shared header files, this contains the very
    important subdirectory `include/configs` where you will find the majority of the
    board configuration settings. As the move to `Kconfig` progresses, the information
    will be moved out into `Kconfig` files but, at the time of writing, that process
    has only just begun.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`包括`：除了许多共享的头文件外，这还包括非常重要的子目录`include/configs`，在这里你会找到大部分的板配置设置。随着向`Kconfig`的转变，信息将被移出到`Kconfig`文件中，但在撰写本文时，这个过程才刚刚开始。'
- en: Kconfig and U-Boot
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kconfig和U-Boot
- en: 'The way that `Kconfig` extracts configuration information from `Kconfig` files
    and stores the total system configuration in a file named `.config` is described
    in some detail in [Chapter 4](ch04.html "Chapter 4. Porting and Configuring the
    Kernel"), *Porting and Configuring the Kernel*. U-Boot has adopted kconfig and
    kbuild with one change. A U-Boot build can produce up to three binaries: a `normal
    u-boot.bin`, a **Secondary Program Loader** (**SPL**), and a **Tertiary Program
    Loader** (**TPL**), each with possibly different configuration options. Consequently,
    lines in `.config` and default configuration files can be prefixed with the codes
    shown in the following table to indicate which target they apply to:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Kconfig`从`Kconfig`文件中提取配置信息，并将总系统配置存储在一个名为`.config`的文件中的方式在[第4章](ch04.html
    "第4章。移植和配置内核")中有详细描述，*移植和配置内核*。U-Boot采用了kconfig和kbuild，并进行了一些更改。一个U-Boot构建可以产生最多三个二进制文件：一个`普通的u-boot.bin`，一个**二级程序加载器**（**SPL**），和一个**三级程序加载器**（**TPL**），每个可能有不同的配置选项。因此，`.config`文件和默认配置文件中的行可以用下表中显示的代码前缀来表示它们适用于哪个目标：'
- en: '| None | Normal image only |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 无 | 仅普通镜像 |'
- en: '| `S:` | SPL image only |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `S:` | 仅SPL镜像 |'
- en: '| `T:` | TPL image only |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `T:` | 仅TPL镜像 |'
- en: '| `ST:` | SPL and TPL images |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `ST:` | SPL和TPL镜像 |'
- en: '| `+S:` | Normal and SPL images |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `+S:` | 普通和SPL镜像 |'
- en: '| `+T:` | Normal and TPL images |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `+T:` | 普通和TPL镜像 |'
- en: '| `+ST:` | Normal, SPL and TPL images |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `+ST:` | 普通、SPL和TPL镜像 |'
- en: 'Each board has a default configuration stored in `configs/[board name}_defconfig`.
    For your Nova board, you will have to create a file named `nova_defonfig.` for
    example, and add these lines to it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 每个板都有一个存储在`configs/[板名称]_defconfig`中的默认配置。对于你的Nova板，你需要创建一个名为`nova_defonfig`的文件，并在其中添加这些行：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: On the first line, `CONFIG_SPL=y` causes the SPL binary, MLO, to be generated,
    `CONFIG_ARM=y` causes the contents of `arch/arm/Kconfig` to be included on line
    three. On line four, `CONFIG_TARGET_NOVA=y` selects your board. Note that lines
    three and four are prefixed by `+S:` so that they apply to both the SPL and normal
    binaries.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，`CONFIG_SPL=y`会导致生成SPL二进制文件MLO，`CONFIG_ARM=y`会导致在第三行包含`arch/arm/Kconfig`的内容。在第四行，`CONFIG_TARGET_NOVA=y`选择您的板。请注意，第三行和第四行都以`+S：`为前缀，以便它们适用于SPL和普通二进制文件。
- en: 'You should also add a menu option to the ARM architecture `Kconfig` that allows
    people to select Nova as a target:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该在ARM架构的`Kconfig`中添加一个菜单选项，允许人们选择Nova作为目标：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Board-specific files
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特定于板的文件
- en: 'Each board has a subdirectory named `board/[board name]` or `board/[vendor]/[board
    name]` which should contain:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 每个板都有一个名为`board/[board name]`或`board/[vendor]/[board name]`的子目录，其中应包含：
- en: '`Kconfig`: Contains configuration options for the board'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Kconfig`：包含板的配置选项'
- en: '`MAINTAINERS`: Contains a record of whether the board is currently maintained
    and, if so, by whom'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAINTAINERS`：包含有关板当前是否被维护以及如果是的话由谁维护的记录'
- en: '`Makefile`: Used to build the board-specific code'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Makefile`：用于构建特定于板的代码'
- en: '`README`: Contains any useful information about this port of U-Boot, for example,
    which hardware variants are covered'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`README`：包含有关U-Boot端口的任何有用信息，例如，涵盖了哪些硬件变体'
- en: In addition, there may be source files for board specific functions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可能还有特定于板的功能的源文件。
- en: 'Your Nova board is based on a BeagleBone which, in turn, is based on a TI AM335x
    EVM, so, you can start by taking a copy of the am335x board files:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Nova板基于BeagleBone，而BeagleBone又基于TI AM335x EVM，因此，您可以首先复制am335x板文件：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, change the `Kconfig` file to reflect the Nova board:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更改`Kconfig`文件以反映Nova板：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Setting `SYS_CPU` to `armv7` causes the code in `arch/arm/cpu/armv7` to be compiled
    and linked. Setting `SYS_SOC` to `am33xx` causes the code in `arch/arm/cpu/armv7/am33xx`
    to be included, setting `SYS_BOARD` to `nova` brings in `board/nova` and setting
    `SYS_CONFIG_NAME` to `nova` means that the header file `include/configs/nova.h`
    is used for further configuration options.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将`SYS_CPU`设置为`armv7`会导致`arch/arm/cpu/armv7`中的代码被编译和链接。将`SYS_SOC`设置为`am33xx`会导致`arch/arm/cpu/armv7/am33xx`中的代码被包含，将`SYS_BOARD`设置为`nova`会引入`board/nova`，将`SYS_CONFIG_NAME`设置为`nova`意味着头文件`include/configs/nova.h`用于进一步的配置选项。
- en: 'There is one other file in `board/nova` that you need to change, the linker
    script placed at `board/nova/u-boot.lds`, which has a hard-coded reference to
    `board/ti/am335x/built-in.o`. Change this to use the copy local to `nova`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`board/nova`中还有另一个文件需要更改，即放置在`board/nova/u-boot.lds`的链接器脚本，其中硬编码引用了`board/ti/am335x/built-in.o`。将其更改为使用`nova`本地的副本：'
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Configuration header files
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置头文件
- en: Each board has a header file in `include/configs` which contains the majority
    of the configuration. The file is named by the `SYS_CONFIG_NAME` identifier in
    the board's `Kconfig`. The format of this file is described in detail in the `README`
    file at the top level of the U-Boot source tree.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 每个板在`include/configs`中都有一个头文件，其中包含大部分配置。该文件由板的`Kconfig`中的`SYS_CONFIG_NAME`标识符命名。该文件的格式在U-Boot源树顶层的`README`文件中有详细描述。
- en: 'For the purposes of your Nova board, simply copy `am335x_evm.h to nova.h` to
    `nova.h` and make a small number of changes:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于您的Nova板，只需将`am335x_evm.h`复制到`nova.h`并进行少量更改：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Building and testing
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和测试
- en: 'To build for the Nova board, select the configuration you have just created:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要为Nova板构建，请选择您刚刚创建的配置：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Copy `MLO` and `u-boot.img` to the FAT partition of the micro-SD card you created
    earlier and boot the board.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将`MLO`和`u-boot.img`复制到您之前创建的micro-SD卡的FAT分区，并启动板。
- en: Falcon mode
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 猎鹰模式
- en: We are used to the idea that booting a modern embedded processor involves the
    CPU boot ROM loading an SPL which loads `u-boot.bin` which then loads a Linux
    kernel. You may be wondering if there is a way to reduce the number of steps,
    thereby simplifying and speeding up the boot process. The answer is U-Boot "Falcon
    mode", named after the Peregrine falcon which is claimed to be the fastest of
    all birds.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们习惯于现代嵌入式处理器的引导涉及CPU引导ROM加载SPL，SPL加载`u-boot.bin`，然后加载Linux内核。您可能想知道是否有办法减少步骤数量，从而简化和加快引导过程。答案是U-Boot“猎鹰模式”，以游隼命名，据称是所有鸟类中最快的。
- en: 'The idea is simple: have the SPL load a kernel image directly, missing out
    `u-boot.bin`. There is no user interaction and there are no scripts. It just loads
    a kernel from a known location in flash or eMMC into memory, passes it a pre-prepared
    parameter block and starts it running. The details of configuring Falcon mode
    are beyond this book. If you would like more information, take a look at `doc/README.falcon`.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很简单：让SPL直接加载内核映像，跳过`u-boot.bin`。没有用户交互，也没有脚本。它只是从flash或eMMC中的已知位置加载内核到内存中，传递给它一个预先准备好的参数块并启动它运行。配置猎鹰模式的详细信息超出了本书的范围。如果您想了解更多信息，请查看`doc/README.falcon`。
- en: Barebox
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Barebox
- en: I will complete this chapter with a look at another bootloader that has the
    same roots as U-Boot but takes a new approach to bootloaders. It is derived from
    U-Boot and was actually called U-Boot v2 in the early days. The Barebox developers
    aimed to combine the best parts of U-Boot and Linux, including a POSIX-like API
    and mountable filesystems.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我将以另一个引导加载程序结束这一章，它与U-Boot有相同的根源，但对引导加载程序采取了新的方法。它源自U-Boot，在早期实际上被称为U-Boot v2。Barebox的开发人员旨在结合U-Boot和Linux的最佳部分，包括类似POSIX的API和可挂载的文件系统。
- en: The Barebox project website is [www.barebox.org](http://www.barebox.org) and
    the developer mailing list is `<[barebox@lists.infradead.org](mailto:barebox@lists.infradead.org)>`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Barebox项目网站是[www.barebox.org](http://www.barebox.org)，开发者邮件列表是`<[barebox@lists.infradead.org](mailto:barebox@lists.infradead.org)>`。
- en: Getting Barebox
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取Barebox
- en: 'To get Barebox, clone the git repository and check out the version you want
    to use:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取Barebox，克隆git存储库并检出您想要使用的版本：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The layout of the code is similar to U-Boot:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的布局类似于U-Boot：
- en: '`arch`: Contains code specific to each supported architecture, which includes
    all the major embedded architectures. SoC support is in `arch/[architecture]/mach-[SoC]`.
    Support for individual boards is in `arch/[architecture]/boards`.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arch`：包含每个支持的架构的特定代码，其中包括所有主要的嵌入式架构。SoC支持在`arch/[architecture]/mach-[SoC]`中。对于单独的板支持在`arch/[architecture]/boards`中。'
- en: '`common`: Contains core functions, including the shell.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`common`：包含核心功能，包括shell。'
- en: '`commands`: Contains the commands that can be called from the shell.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`commands`：包含可以从shell中调用的命令。'
- en: '`Documentation`: Contains the templates for documentation files. To build it,
    type "`make docs`". The results are put in `Documentation/html`.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Documentation`：包含文档文件的模板。要构建它，输入"`make docs`"。结果放在`Documentation/html`中。'
- en: '`drivers`: Contains the code for the device drivers.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drivers`：包含设备驱动程序的代码。'
- en: '`include`: Contains header files.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`：包含头文件。'
- en: Building Barebox
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建Barebox
- en: 'Barebox has used `kconfig/kbuild` for a long time. There are default configuration
    files in `arch/[architecture]/configs`. As an example, assume that you want to
    build Barebox for the BeagleBoard C4\. You need two configurations, one for the
    SPL, and one for the main binary. Firstly, build MLO:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Barebox长期以来一直使用`kconfig/kbuild`。在`arch/[architecture]/configs`中有默认的配置文件。举个例子，假设你想为BeagleBoard
    C4构建Barebox。你需要两个配置，一个是SPL，一个是主二进制文件。首先，构建MLO：
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The result is the secondary program loader, MLO.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是次级程序加载器MLO。
- en: 'Next, build Barebox:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，构建Barebox：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Copy both to an SD card:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 将两者都复制到SD卡上：
- en: '[PRE39]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, boot up the board and you should see messages like these on the console:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，启动板子，你应该在控制台上看到这样的消息：
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Barebox is continuing to evolve. At the time of writing, it lacks the breadth
    of hardware support that U-Boot has, but it is worth considering for new projects.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Barebox正在不断发展。在撰写本文时，它缺乏U-Boot所具有的广泛硬件支持，但对于新项目来说是值得考虑的。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Every system needs a bootloader to bring the hardware to life and to load a
    kernel. U-Boot has found favor with many developers because it supports a useful
    range of hardware and it is fairly easy to port to a new device. Over the last
    few years, the complexity and ever increasing variety of embedded hardware has
    led to the introduction of the device tree as a way of describing hardware. The
    device tree is simply a textual representation of a system that is compiled into
    a **devicetree binary** (**dtb**) and which is passed to the kernel when it loads.
    It is up to the kernel to interpret the device tree and to load and initialize
    drivers for the devices it finds there.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统都需要一个引导加载程序来启动硬件并加载内核。U-Boot受到许多开发人员的青睐，因为它支持一系列有用的硬件，并且相对容易移植到新设备上。在过去几年中，嵌入式硬件的复杂性和不断增加的种类导致了设备树的引入，作为描述硬件的一种方式。设备树只是系统的文本表示，编译成**设备树二进制**（**dtb**），并在内核加载时传递给内核。内核需要解释设备树，并加载和初始化设备驱动程序。
- en: In use, U-Boot is very flexible, allowing images to be loaded from mass storage,
    flash memory, or a network, and booted. Likewise, Barebox can achieve the same
    but with a smaller base of hardware support. Despite its cleaner design and POSIX-inspired
    internal APIs, at the time of writing it does not seem to have been accepted beyond
    its own small but dedicated community.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用中，U-Boot非常灵活，允许从大容量存储、闪存或网络加载和引导镜像。同样，Barebox也可以实现相同的功能，但硬件支持的基础较小。尽管其更清晰的设计和受POSIX启发的内部API，但在撰写本文时，它似乎还没有被接受到自己的小而专注的社区之外。
- en: Having covered some of the intricacies of booting Linux, in the next chapter
    you will see the next stage of the process as the third element of your embedded
    project, the kernel, comes into play.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了一些Linux引导的复杂性之后，下一章中你将看到嵌入式项目的第三个元素，内核，进入到过程的下一个阶段。
