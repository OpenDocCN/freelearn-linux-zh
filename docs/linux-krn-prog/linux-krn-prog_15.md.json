["```\nstatic int i = 5;\n[ ... ]\nfoo()\n{\n    [ ... ]\n    i ++;     // is this safe? yes, if truly atomic... but is it truly atomic??\n}\n```", "```\nwhile (locked) ;\n```", "```\nt_locked < 2 * t_ctxsw\n```", "```\nif (in_task())\n    /* we're in process context (usually safe to sleep / block) */\nelse\n    /* we're in an atomic or interrupt context (cannot sleep / block) */\n```", "```\n#include <linux/mutex.h>\nstruct mutex mymtx;\n```", "```\nstruct mydrv_priv {\n    <member 1>;\n    <member 2>;\n    [...]\n    struct mutex mymtx; /* protects access to mydrv_priv */\n    [...]\n};\n```", "```\nstatic int init_mydrv(struct mydrv_priv *drvctx)\n{\n    [...]\n    mutex_init(drvctx->mymtx);\n    [...]\n}\n```", "```\n// include/linux/mutex.h\n/*\n * Simple, straightforward mutexes with strict semantics:\n *\n * - only one task can hold the mutex at a time\n * - only the owner can unlock the mutex\n * - multiple unlocks are not permitted\n * - recursive locking is not permitted\n * - a mutex object must be initialized via the API\n * - a mutex object must not be initialized via memset or copying\n * - task may not exit with mutex held\n * - memory areas where held locks reside must not be freed\n * - held mutexes must not be reinitialized\n * - mutexes may not be used in hardware or software interrupt\n * contexts such as tasklets and timers\n *\n * These semantics are fully enforced when DEBUG_MUTEXES is\n * enabled. Furthermore, besides enforcing the above rules, the mutex\n * [ ... ]\n```", "```\n/*\n * Lock order:\n * 1\\. slab_mutex (Global Mutex)\n * 2\\. node->list_lock\n * 3\\. slab_lock(page) (Only on some arches and for debugging)\n```", "```\nvoid __sched mutex_lock(struct mutex *lock);\nvoid __sched mutex_unlock(struct mutex *lock);\n```", "```\n// kernel/locking/mutex.c\n[ ... ]\n/**\n * mutex_lock - acquire the mutex\n * @lock: the mutex to be acquired\n *\n * Lock the mutex exclusively for this task. If the mutex is not\n * available right now, it will sleep until it can get it.\n *\n * The mutex must later on be released by the same task that\n * acquired it. Recursive locking is not allowed. The task\n * may not exit without first unlocking the mutex. Also, kernel\n * memory where the mutex resides must not be freed with\n * the mutex still locked. The mutex must first be initialized\n * (or statically defined) before it can be locked. memset()-ing\n * the mutex to 0 is not allowed.\n *\n * (The CONFIG_DEBUG_MUTEXES .config option turns on debugging\n * checks that will enforce the restrictions and will also do\n * deadlock debugging)\n *\n * This function is similar to (but not equivalent to) down().\n */\nvoid __sched mutex_lock(struct mutex *lock)\n{\n    might_sleep();\n\n    if (!__mutex_trylock_fast(lock))\n        __mutex_lock_slowpath(lock);\n}\nEXPORT_SYMBOL(mutex_lock);\n```", "```\nDEFINE_MUTEX(...);        // init: initialize the mutex object\n/* or */ mutex_init();\n[ ... ]\n    /* critical section: perform the (mutex) locking, unlocking */\n    mutex_lock[_interruptible]();\n    << ... critical section ... >>\n    mutex_unlock();\n    mutex_destroy();      // cleanup: destroy the mutex object\n```", "```\n$ pwd\n<...>/ch12/1_miscdrv_rdwr_mutexlock\n$ diff -u ../../ch12/miscdrv_rdwr/miscdrv_rdwr.c miscdrv_rdwr_mutexlock.c > miscdrv_rdwr.patch\n$ cat miscdrv_rdwr.patch\n[ ... ]\n+#include <linux/mutex.h> // mutex lock, unlock, etc\n #include \"../../convenient.h\"\n[ ... ] \n-#define OURMODNAME \"miscdrv_rdwr\"\n+#define OURMODNAME \"miscdrv_rdwr_mutexlock\"\n\n+DEFINE_MUTEX(lock1); // this mutex lock is meant to protect the integers ga and gb\n[ ... ]\n+     struct mutex lock; // this mutex protects this data structure\n };\n[ ... ]\n```", "```\n+     mutex_init(&ctx->lock);\n+\n+     /* Initialize the \"secret\" value :-) */\n      strscpy(ctx->oursecret, \"initmsg\", 8);\n-     dev_dbg(ctx->dev, \"A sample print via the dev_dbg(): driver initialized\\n\");\n+     /* Why don't we protect the above strscpy() with the mutex lock?\n+      * It's working on shared writable data, yes?\n+      * Yes, BUT this is the init code; it's guaranteed to run in exactly\n+      * one context (typically the insmod(8) process), thus there is\n+      * no concurrency possible here. The same goes for the cleanup\n+      * code path.\n+      */\n```", "```\n-static void __exit miscdrv_rdwr_exit(void)\n+static void __exit miscdrv_exit_mutexlock(void)\n {\n+     mutex_destroy(&lock1);\n+     mutex_destroy(&ctx->lock);\n      misc_deregister(&llkd_miscdev);\n }\n```", "```\n+\n+     mutex_lock(&lock1);\n+     ga++; gb--;\n+     mutex_unlock(&lock1);\n+\n+     dev_info(dev, \" filename: \\\"%s\\\"\\n\"\n      [ ... ]\n```", "```\n+ dev_info(dev, \" filename: \\\"%s\\\"\\n\"\n+         \" wrt open file: f_flags = 0x%x\\n\"\n+         \" ga = %d, gb = %d\\n\",\n+         filp->f_path.dentry->d_iname, filp->f_flags, ga, gb);\n```", "```\nint mutex_trylock(struct mutex *lock);\n```", "```\n// kernel/module.c\n[ ... ]\nSYSCALL_DEFINE2(delete_module, const char __user *, name_user,\n        unsigned int, flags)\n{\n    struct module *mod;\n    [ ... ]\n    if (!capable(CAP_SYS_MODULE) || modules_disabled)\n        return -EPERM;\n    [ ... ]\n    if (mutex_lock_interruptible(&module_mutex) != 0)\n return -EINTR;\n    mod = find_module(name);\n    [ ... ]\nout:\n    mutex_unlock(&module_mutex);\n    return ret;\n}\n```", "```\nspinlock_t lock;\nspin_lock_init(&lock);\n```", "```\n// include/linux/fs.h\nstruct file {\n    [...]\n    struct path f_path;\n    struct inode *f_inode; /* cached value */\n    const struct file_operations *f_op;\n    /*\n     * Protects f_ep_links, f_flags.\n     * Must not be taken from IRQ context.\n     */\n    spinlock_t f_lock;\n    [...]\n    struct mutex f_pos_lock;\n    loff_t f_pos;\n    [...]\n```", "```\nvoid spin_lock(spinlock_t *lock);\n<< ... critical section ... >>\nvoid spin_unlock(spinlock_t *lock);\n```", "```\n// location: ch12/2_miscdrv_rdwr_spinlock/\n+#include <linux/spinlock.h>\n[ ... ]\n-#define OURMODNAME \"miscdrv_rdwr_mutexlock\"\n+#define OURMODNAME \"miscdrv_rdwr_spinlock\"\n[ ... ]\nstatic int ga, gb = 1;\n-DEFINE_MUTEX(lock1); // this mutex lock is meant to protect the integers ga and gb\n+DEFINE_SPINLOCK(lock1); // this spinlock protects the global integers ga and gb\n[ ... ]\n+/* The driver 'context' data structure;\n+ * all relevant 'state info' reg the driver is here.\n  */\n struct drv_ctx {\n    struct device *dev;\n@@ -63,10 +66,22 @@\n    u64 config3;\n #define MAXBYTES 128\n    char oursecret[MAXBYTES];\n- struct mutex lock; // this mutex protects this data structure\n+ struct mutex mutex; // this mutex protects this data structure\n+ spinlock_t spinlock; // ...so does this spinlock\n };\n static struct drv_ctx *ctx;\n```", "```\n-   mutex_init(&ctx->lock);\n+   mutex_init(&ctx->mutex);\n+   spin_lock_init(&ctx->spinlock);\n```", "```\n * open_miscdrv_rdwr()\n@@ -82,14 +97,15 @@\n\n    PRINT_CTX(); // displays process (or intr) context info\n\n-   mutex_lock(&lock1);\n+   spin_lock(&lock1);\n    ga++; gb--;\n-   mutex_unlock(&lock1);\n+   spin_unlock(&lock1);\n```", "```\n static ssize_t read_miscdrv_rdwr(struct file *filp, char __user *ubuf, size_t count, loff_t  *off)\n {\n-   int ret = count, secret_len;\n+   int ret = count, secret_len, err_path = 0;\n    struct device *dev = ctx->dev;\n\n-   mutex_lock(&ctx->lock);\n+   spin_lock(&ctx->spinlock);\n    secret_len = strlen(ctx->oursecret);\n-   mutex_unlock(&ctx->lock);\n+   spin_unlock(&ctx->spinlock);\n```", "```\n[ ... ]\n@@ -139,20 +157,28 @@\n     * member to userspace.\n     */\n    ret = -EFAULT;\n-   mutex_lock(&ctx->lock);\n+   mutex_lock(&ctx->mutex);\n+   /* Why don't we just use the spinlock??\n+    * Because - VERY IMP! - remember that the spinlock can only be used when\n+    * the critical section will not sleep or block in any manner; here,\n+    * the critical section invokes the copy_to_user(); it very much can\n+    * cause a 'sleep' (a schedule()) to occur.\n+    */\n    if (copy_to_user(ubuf, ctx->oursecret, secret_len)) {\n[ ... ]\n```", "```\n// ch12/2_miscdrv_rdwr_spinlock/2_miscdrv_rdwr_spinlock.c\n[ ... ]\nstatic int buggy;\nmodule_param(buggy, int, 0600);\nMODULE_PARM_DESC(buggy,\n\"If 1, cause an error by issuing a blocking call within a spinlock critical section\");\n[ ... ]\nstatic ssize_t write_miscdrv_rdwr(struct file *filp, const char __user *ubuf,\n                size_t count, loff_t *off)\n{\n    int ret, err_path = 0;\n    [ ... ]\n    spin_lock(&ctx->spinlock);\n    strscpy(ctx->oursecret, kbuf, (count > MAXBYTES ? MAXBYTES : count));\n    [ ... ]\n    if (1 == buggy) {\n        /* We're still holding the spinlock! */\n        set_current_state(TASK_INTERRUPTIBLE);\n        schedule_timeout(1*HZ); /* ... and this is a blocking call!\n * Congratulations! you've just engineered a bug */\n    }\n    spin_unlock(&ctx->spinlock);\n    [ ... ]\n}\n```", "```\n$ lsb_release -a 2>/dev/null | grep \"^Description\" ; uname -r\nDescription: Ubuntu 20.04.1 LTS\n5.4.0-llkd-dbg $ make\n[ ... ]\n$ modinfo ./miscdrv_rdwr_spinlock.ko \nfilename: /home/llkd/llkd_src/ch12/2_miscdrv_rdwr_spinlock/./miscdrv_rdwr_spinlock.ko\n[ ... ]\ndescription: LLKD book:ch12/2_miscdrv_rdwr_spinlock: simple misc char driver rewritten with spinlocks\n[ ... ]\nparm: buggy:If 1, cause an error by issuing a blocking call within a spinlock critical section (int)\n$ sudo virt-what\nvirtualbox\nkvm\n$ \n```", "```\n$ sudo dmesg -C\n$ sudo insmod ./miscdrv_rdwr_spinlock.ko buggy=1\n$ ../../ch12/miscdrv_rdwr/rdwr_test_secret \nUsage: ../../ch12/miscdrv_rdwr/rdwr_test_secret opt=read/write device_file [\"secret-msg\"]\n opt = 'r' => we shall issue the read(2), retrieving the 'secret' form the driver\n opt = 'w' => we shall issue the write(2), writing the secret message <secret-msg>\n  (max 128 bytes)\n$ \n$ ../../ch12/miscdrv_rdwr/rdwr_test_secret r /dev/llkd_miscdrv_rdwr_spinlock \nDevice file /dev/llkd_miscdrv_rdwr_spinlock opened (in read-only mode): fd=3\n../../ch12/miscdrv_rdwr/rdwr_test_secret: read 7 bytes from /dev/llkd_miscdrv_rdwr_spinlock\nThe 'secret' is:\n \"initmsg\"\n$ \n```", "```\nmiscdrv_rdwr_spinlock:write_miscdrv_rdwr(): 004) rdwr_test_secre :23578 | ...0 /*  write_miscdrv_rdwr() */\n```", "```\nBUG: scheduling while atomic: rdwr_test_secre/23578/0x00000002\n```", "```\nprintk(KERN_ERR \"BUG: scheduling while atomic: %s/%d/0x%08x\\n\", prev->comm, prev->pid, preempt_count());\n```", "```\n      BUG: scheduling while atomic: rdwr_test_secre/23578/0x00000002\n```", "```\n// lib/Kconfig.debug\n[ ... ]\nconfig DEBUG_ATOMIC_SLEEP\n    bool \"Sleep inside atomic section checking\"\n    select PREEMPT_COUNT\n    depends on DEBUG_KERNEL\n    depends on !ARCH_NO_PREEMPT\n    help \n      If you say Y here, various routines which may sleep will become very \n noisy if they are called inside atomic sections: when a spinlock is\n held, inside an rcu read side critical section, inside preempt disabled\n sections, inside an interrupt, etc...\n```", "```\n$ uname -r\n5.4.0-56-generic\n$ sudo insmod ./miscdrv_rdwr_spinlock.ko buggy=1\n$ ../../ch12/miscdrv_rdwr/rdwr_test_secret w /dev/llkd_miscdrv_rdwr_spinlock \"passwdcosts500bucksdude\"\nDevice file /dev/llkd_miscdrv_rdwr_spinlock opened (in write-only mode): fd=3\n../../ch12/miscdrv_rdwr/rdwr_test_secret: wrote 24 bytes to /dev/llkd_miscdrv_rdwr_spinlock\n$ dmesg \n[ ... ]\n[ 65.420017] miscdrv_rdwr_spinlock:miscdrv_init_spinlock(): LLKD misc driver (major # 10) registered, minor# = 56, dev node is /dev/llkd_miscdrv_rdwr\n[ 81.665077] miscdrv_rdwr_spinlock:miscdrv_exit_spinlock(): miscdrv_rdwr_spinlock: LLKD misc driver deregistered, bye\n[ 86.798720] miscdrv_rdwr_spinlock:miscdrv_init_spinlock(): VERMAGIC_STRING = 5.4.0-56-generic SMP mod_unload \n[ 86.799890] miscdrv_rdwr_spinlock:miscdrv_init_spinlock(): LLKD misc driver (major # 10) registered, minor# = 56, dev node is /dev/llkd_miscdrv_rdwr\n[ 130.214238] misc llkd_miscdrv_rdwr_spinlock: filename: \"llkd_miscdrv_rdwr_spinlock\"\n                wrt open file: f_flags = 0x8001\n                ga = 1, gb = 0\n[ 130.219233] misc llkd_miscdrv_rdwr_spinlock: stats: tx=0, rx=0\n[ 130.219680] misc llkd_miscdrv_rdwr_spinlock: rdwr_test_secre wants to write 24 bytes\n[ 130.220329] misc llkd_miscdrv_rdwr_spinlock: 24 bytes written, returning... (stats: tx=0, rx=24)\n[ 131.249639] misc llkd_miscdrv_rdwr_spinlock: filename: \"llkd_miscdrv_rdwr_spinlock\"\n                ga = 0, gb = 1\n[ 131.253511] misc llkd_miscdrv_rdwr_spinlock: stats: tx=0, rx=24\n$ \n```", "```\n$ sudo trace-cmd record -p function_graph -F ../../ch12/miscdrv_rdwr/rdwr_test_secret w /dev/llkd_miscdrv_rdwr_spinlock \"passwdcosts500bucks\"\n$ sudo trace-cmd report -I -S -l > report.txt\n$ sudo less report.txt\n[ ... ]\n```", "```\n$ grep DEBUG_ATOMIC_SLEEP /boot/config-5.4.0-56-generic\n# CONFIG_DEBUG_ATOMIC_SLEEP is not set\n$\n```", "```\n// Driver read method ; WRONG ! driver_read(...)                  << time t0 >>\n{\n    [ ... ]\n    spin_lock(&slock);\n    <<--- time t1 : start of critical section >>\n... << operating on global data object gCtx >> ...\n    spin_unlock(&slock);\n    <<--- time t2 : end of critical section >>\n    [ ... ]\n}                                << time t3 >>\n```", "```\nhandle_interrupt(...)           << time t4; hardware interrupt fires!     >>\n{\n    [ ... ]\n    spin_lock(&slock);\n    <<--- time t5: start of critical section >>\n    ... << operating on global data object gCtx >> ...\n    spin_unlock(&slock);\n    <<--- time t6 : end of critical section >>\n    [ ... ]\n}                               << time t7 >> \n```", "```\n#include <linux/spinlock.h>\nvoid spin_lock_irq(spinlock_t *lock);\n```", "```\n// Driver read method ; CORRECT ! driver_read(...)                  << time t0 >>\n{\n    [ ... ]\n    spin_lock_irq(&slock);\n    <<--- time t1 : start of critical section >>\n*[now all interrupts + preemption on local CPU core are masked (disabled)]*\n... << operating on global data object gCtx >> ...\n    spin_unlock_irq(&slock);\n    <<--- time t2 : end of critical section >>\n    [ ... ]\n}                                << time t3 >>\n```", "```\n#include <linux/spinlock.h>\n unsigned long spin_lock_irqsave(spinlock_t *lock, unsigned long flags);\n void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags);\n```", "```\nspinlock_t slock;\nspin_lock_init(&slock);\n[ ... ]\ndriver_read(...) \n{\n    [ ... ]\n    spin_lock_irqsave(&slock, flags);\n    << ... critical section ... >>\n    spin_unlock_irqrestore(&slock, flags);\n    [ ... ]\n}\n```", "```\nvoid spin_lock_bh(spinlock_t *lock);\n```"]