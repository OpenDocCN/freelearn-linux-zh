- en: Working with Hardware I/O Memory
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用硬件I/O内存
- en: 'In this chapter, we will focus on an important hardware-related aspect of writing
    a device driver: how exactly to access and perform I/O (input/output, reads and
    writes) to hardware (or peripheral) I/O memory – the peripheral hardware chip
    that you are writing the driver for.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将专注于编写设备驱动程序的一个重要与硬件相关的方面：如何准确地访问和执行对硬件（或外围）I/O内存的I/O（输入/输出，读取和写入）。
- en: 'The motivation behind the knowledge you will gain in this chapter is straightforward:
    without this, how will you actually control the device? Most devices are driven
    by carefully calibrated writes and reads to their hardware registers and/or peripheral
    memory, also called hardware I/O memory. Linux, being a virtual memory-based OS,
    requires some abstraction in the way it works with peripheral I/O memory.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章中获得的知识背后的动机很简单：没有这个，你如何实际控制设备呢？大多数设备都是通过对它们的硬件寄存器和/或外围内存进行精心校准的写入和读取来驱动的，也称为硬件I/O内存。作为一个基于虚拟内存的操作系统，Linux在处理外围I/O内存时需要一些抽象。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Accessing hardware I/O memory from the kernel
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从内核访问硬件I/O内存
- en: Understanding and using memory-mapped I/O
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和使用内存映射I/O
- en: Understanding and using port-mapped I/O
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和使用端口映射I/O
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'I assume that you have gone through the *Preface* section *To get the most
    out of this book* and have appropriately prepared a guest VM running Ubuntu 18.04
    LTS (or a later stable release) and installed all the required packages. If not,
    I highly recommend you do this first. To get the most out of this book, I strongly
    recommend you first set up the workspace environment, including cloning this book''s
    GitHub repository for the code, and work on it in a hands-on fashion. The repository
    can be found here: [https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你已经阅读了*前言*部分*为了充分利用本书*，并适当地准备了一个运行Ubuntu 18.04 LTS（或更高版本）的虚拟机，并安装了所有必需的软件包。如果没有，我强烈建议你首先这样做。为了充分利用本书，我强烈建议你首先设置好工作环境，包括克隆本书的GitHub代码库，并以实际操作的方式进行工作。代码库可以在这里找到：[https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2)。
- en: Accessing hardware I/O memory from the kernel
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从内核访问硬件I/O内存
- en: 'An interesting issue that you, as a device driver author, will likely face
    is this: you need to be able to access and work on the I/O memory, the hardware
    registers, and/or hardware memory of a peripheral chip. This is, in fact, typically
    the way in which the driver programs the hardware at the level of the "metal":
    by issuing commands to it via its registers and/or peripheral memory. However,
    there is an issue to be faced with directly accessing hardware I/O memory on Linux.
    In this first section, we''ll take a look at this issue and provide a solution
    for it.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 作为设备驱动程序的作者，你可能会面临的一个有趣问题是：你需要能够访问和处理外围芯片的I/O内存、硬件寄存器和/或硬件内存。实际上，这通常是驱动程序以"金属"级别的方式对硬件进行编程的方式：通过对其发出命令来控制它的寄存器和/或外围内存。然而，在Linux上直接访问硬件I/O内存存在一个问题。在本节中，我们将看看这个问题，并为其提供解决方案。
- en: Understanding the issue with direct access
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解直接访问的问题
- en: 'Now, of course, this hardware memory on the chip, the so-called I/O memory, is
    not RAM. The Linux kernel refuses the module or driver author direct access to
    such hardware I/O memory locations. We already know why: on a modern VM-based
    OS, all memory access has to be via the **Memory Management Unit** (**MMU**) and
    paging tables.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当然，芯片上的这个硬件内存，所谓的I/O内存，不是RAM。Linux内核拒绝模块或驱动程序的作者直接访问这样的硬件I/O内存位置。我们已经知道原因：在现代基于VM的操作系统中，所有内存访问都必须通过**内存管理单元**（**MMU**）和分页表。
- en: 'Let''s quickly summarize the key aspect of what was seen in the companion guide
    *Linux Kernel Programming* in *Chapter 7,* *Memory Management Internals – Essentials*:
    by default, memory is virtualized, which means that all addresses are virtual
    and not physical (this includes the addresses within the kernel segment or VAS).
    Think of it this way: once a virtual address is accessed by a process (or the
    kernel) for reading or writing or execution, the system has to fetch the memory
    content at the corresponding physical address. This involves translating the virtual
    address to the physical address at runtime; hardware optimizations (the CPU caches, **Translation
    Lookaside Buffers** (**TLBs**), and so on) can speed this up. The process that
    is carried out is as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速总结一下在伴随指南*Linux内核编程*中*第7章* *内存管理内部-基础*中所见的关键方面：默认情况下，内存是虚拟化的，这意味着所有地址都是虚拟的而不是物理的（这包括内核段或VAS内的地址）。可以这样理解：一旦进程（或内核）访问虚拟地址进行读取、写入或执行，系统就必须在相应的物理地址处获取内存内容。这涉及在运行时将虚拟地址转换为物理地址；硬件优化（CPU缓存、**转换旁路缓冲器**（**TLB**）等）可以加速这一过程。所进行的过程如下：
- en: First, the CPU caches (L1-D/L1-I, L2, and so on) are checked to see whether
    the memory referred to by this virtual address is already onboard the CPU cache(s) silicon.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，CPU缓存（L1-D/L1-I，L2等）会被检查，以查看由这个虚拟地址引用的内存是否已经在CPU缓存（硅）上。
- en: If the memory is already onboard, we have a cache hit and the work is done.
    If not (it's a **Last Level Cache**—**LLC **miss - expensive!), the virtual address
    is fed to the microprocessor MMU.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果内存已经在板上，我们就有了缓存命中，工作就完成了。如果没有（这是一个**最后一级缓存**—**LLC**未命中—昂贵！），虚拟地址就会被馈送到微处理器MMU。
- en: The MMU now looks for the corresponding physical address within the processor
    TLB(s). If it's there, we have a TLB hit and the work is done; if not, we have
    a TLB miss (this is expensive!).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在MMU在处理器TLB(s)中寻找相应的物理地址。如果找到了，我们就有了TLB命中，工作就完成了；如果没有，我们就有了TLB未命中（这是昂贵的！）。
- en: The MMU now walks the paging tables of the user space process that made the
    access; or, if the kernel made the access, it walks the kernel paging tables,
    translating the virtual address into the corresponding physical one. At this point,
    the physical address is placed on the bus and the work is done.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MMU现在遍历进行访问的用户空间进程的分页表；或者，如果内核进行了访问，它会遍历内核分页表，将虚拟地址转换为相应的物理地址。在这一点上，物理地址被放置在总线上，工作完成。
- en: Please refer to TI's *Technical Reference Manual* for the OMAP35x at [https://www.ti.com/lit/ug/spruf98y/spruf98y.pdf?ts=1594376085647](https://www.ti.com/lit/ug/spruf98y/spruf98y.pdf?ts=1594376085647) for
    more information on this; the *MMU Functional Description* topic (page 946) is
    illustrated with excellent diagrams (for our purpose, see *Figures 8.4*, *8.6*,
    and *8.7* – the latter is a flowchart depicting the preceding procedures).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅TI的OMAP35x的*技术参考手册* [https://www.ti.com/lit/ug/spruf98y/spruf98y.pdf?ts=1594376085647](https://www.ti.com/lit/ug/spruf98y/spruf98y.pdf?ts=1594376085647)；*MMU功能描述*主题（第946页）用出色的图表进行了说明（对于我们的目的，请参见*图8.4*、*8.6*和*8.7*
    - 后者是描述前述过程的流程图）。
- en: Also, we mention the fact that the actual address translation procedure is of
    course very arch-dependent. On some systems, the order is as shown here; on others
    (often on ARM), the MMU (including TLB lookups) is performed first, and then the
    CPU caches are checked.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们提到实际地址转换过程当然是非常依赖于架构的。在一些系统上，顺序如下所示；在其他系统上（通常在ARM上），MMU（包括TLB查找）首先执行，然后检查CPU缓存。
- en: So, think about this: even normal RAM locations aren't really directly accessed
    by software running on a modern OS; this is because its memory is virtualized.
    In such cases, the paging tables (of every process, as well as the kernel itself)
    enable the OS to be able to runtime translate the virtual address to its physical
    counterpart. (We have covered these areas in some detail in our companion book, *Linux
    Kernel Programming*, in *Chapter 7*,* Memory Management Internals – Essentials*,
    in the *Virtual addressing and address translation* section; do glance back at
    it to refresh these key points if you need to.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，想一想：即使是普通的RAM位置在现代操作系统上运行的软件也不是直接访问的；这是因为它的内存是虚拟化的。在这种情况下，分页表（每个进程以及内核本身的）使操作系统能够在运行时将虚拟地址转换为其物理对应地址。（我们在我们的配套书籍*Linux内核编程*的*第7章*，*内存管理内部-基本*，*虚拟寻址和地址转换*部分中详细介绍了这些领域；如果需要，可以回顾一下以刷新这些关键点。）
- en: Now, if we have a hardware peripheral or chip containing I/O memory, the issue
    seems even more complicated if we consider the fact that this memory isn't RAM.
    So, is this memory not being mapped by paging tables? Or is it? In the next section,
    we'll look at two common solutions to this issue, so read on!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们有一个包含I/O内存的硬件外围设备或芯片，如果考虑到这个内存不是RAM，问题似乎更加复杂。那么，这个内存不是通过分页表进行映射的吗？还是？在下一节中，我们将看一下这个问题的两种常见解决方案，所以请继续阅读！
- en: The solution – mapping via I/O memory or I/O port
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案-通过I/O内存或I/O端口进行映射
- en: 'In order to solve this issue, we must understand that modern processors provide
    two broad ways by which they can access and work with hardware I/O (peripheral
    chip) memory:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们必须了解现代处理器提供了两种广泛的方式，通过这两种方式可以访问和处理硬件I/O（外围芯片）内存：
- en: By reserving some region(s) of the processor's address space for these peripheral
    devices; that is, by using **memory-mapped I/O** (**MMIO**) as a mapping type
    for I/O.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过为这些外围设备保留处理器地址空间的某些区域；也就是说，通过**内存映射I/O**（**MMIO**）作为I/O的映射类型。
- en: By providing distinct assembly (and the corresponding machine) CPU instructions
    to directly access the I/O memory. Using such a mapping type for I/O is called**port-mapped
    I/O** (**PMIO** or simply **PIO**).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供不同的汇编（和相应的机器）CPU指令来直接访问I/O内存。使用这种I/O的映射类型称为**端口映射I/O**（**PMIO**或简称**PIO**）。
- en: We shall consider both of these techniques in the *Understanding and using memory-mapped
    I/O* and *Understanding and using port-mapped I/O* sections, respectively. Before
    we do that, though, we need to learn how to politely ask the kernel for permission
    to use these I/O resources!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别考虑这两种技术，即*理解和使用内存映射I/O*和*理解和使用端口映射I/O*部分。不过，在这之前，我们需要学习如何礼貌地请求内核允许使用这些I/O资源！
- en: Asking the kernel's permission
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求内核的许可
- en: 'Think about this for a moment: even if you know which API(s) to use to map
    or work upon I/O memory in some manner, first, you need to request permission
    from the OS*. *After all, the OS is the system''s overall resource manager and
    you must ask it nicely before using its resources. Well, there''s more to this,
    of course – when you ask it, what you''re really doing is asking it to set up
    some internal data structures that allow the kernel to understand which driver
    or subsystem is using what I/O memory region or port.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想：即使您知道要使用哪些API来以某种方式映射或处理I/O内存，首先，您需要从操作系统*请求权限。毕竟，操作系统是系统的整体资源管理器，您必须在使用其资源之前得到它的许可。当然，这还有更多内容-当您请求时，您实际上是在请求它设置一些内部数据结构，使内核能够理解哪个驱动程序或子系统正在使用哪个I/O内存区域或端口。
- en: 'Before performing any peripheral I/O, you are expected to ask the kernel for
    permission to do so, and assuming you get it, you perform the I/O. After this,
    you are expected to release the I/O region back to the kernel. The following steps
    are involved in this process:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行任何外围I/O之前，您应该要求内核允许这样做，并假设您得到了允许，您将执行I/O。之后，您应该将I/O区域释放回内核。这个过程涉及以下步骤：
- en: '**Before I/O**: Request access to the memory or port region.'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**I/O之前**：请求访问内存或端口区域。'
- en: '**Having received the green light from the kernel core, perform the actual
    I/O**: You use either MMIO or PMIO to do this (details are provided in the following
    table).'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在从内核核心收到绿灯后，执行实际的I/O**：您可以使用MMIO或PMIO来执行此操作（详细信息请参见下表）。'
- en: '**After I/O**: Release the memory or port region back to the OS.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**I/O之后**：将内存或端口区域释放回操作系统。'
- en: 'So, how do you perform these request, I/O, and release operations? There are
    APIs that can do this, and the ones you should use depend on whether you are using
    MMIO or PMIO. The following table summarizes the APIs you should use before performing
    I/O and then releasing the region after this work has been done (the actual APIs
    that perform I/O will be covered later):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何执行这些请求、I/O和释放操作呢？有一些API可以做到这一点，您应该使用哪些取决于您是使用MMIO还是PMIO。以下表格总结了在执行I/O之前应该使用的API，然后在完成这项工作后释放该区域的API（执行I/O的实际API将在后面介绍）：
- en: '| **Method of access to I/O memory ** | **MMIO** | **PMIO** |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **访问I/O内存的方法** | **MMIO** | **PMIO** |'
- en: '| Before performing any I/O, request access to the I/O memory/port region.
    |  `request_mem_region()` |  `request_region()` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 在执行任何I/O之前，请求对I/O内存/端口区域的访问。 | `request_mem_region()` | `request_region()`
    |'
- en: '| Perform the I/O operation. | (See the *MMIO – performing the actual I/O* section)
    | (See the *PMIO – performing the actual I/O* section) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 执行I/O操作。 | （参见*MMIO - 执行实际I/O*部分） | （参见*PMIO - 执行实际I/O*部分） |'
- en: '| After performing the I/O operation, release the region. |  `release_mem_region()`
    |  `release_region()` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 在执行I/O操作后，释放该区域。 | `release_mem_region()` | `release_region()` |'
- en: 'The functions shown in the preceding table are defined as macros in the `linux/ioport.h` header;
    their signatures are as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前面表格中显示的函数在`linux/ioport.h`头文件中定义为宏，它们的签名如下：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All these macros are essentially wrappers over the `__request_region()` and `__release_region()` internal
    APIs. The parameters for these macros are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些宏本质上都是对`__request_region()`和`__release_region()`内部API的包装。这些宏的参数如下：
- en: '`start` is the beginning of the I/O memory region or port; for MMIO, it''s
    a physical (or bus) address, while for PMIO, it''s a port number.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`是I/O内存区域或端口的起始位置；对于MMIO，它是物理（或总线）地址，而对于PMIO，它是端口号。'
- en: '`n` is the length of the region that''s being requested.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`是正在请求的区域的长度。'
- en: '`name` is any name you''d like to associate the mapped region or port range
    with. It''s usually the name of the driver that performs the I/O operation (you
    can see it within the proc filesystem; we''ll look at this in more detail when
    we cover how to use MMIO and PMIO).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`是您想要将映射区域或端口范围与之关联的任何名称。通常是执行I/O操作的驱动程序的名称（您可以在proc文件系统中看到它；在我们介绍如何使用MMIO和PMIO时，我们将更详细地讨论这一点）。'
- en: The return value from the `request_[mem_]region()` APIs/macros is a pointer
    to a `struct resource` (again, more on this in the *Obtaining the device resources*
    section). If `NULL` is returned, this implies that the resource failed to be reserved;
    the driver typically returns `-EBUSY`, signaling that the resource is now busy
    or unavailable (possibly because another component/driver has already requested
    and is currently using it).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`request_[mem_]region()`API/宏的返回值是指向`struct resource`的指针（关于这一点我们稍后会详细介绍）。如果返回`NULL`，这意味着资源未能被保留；驱动程序通常返回`-EBUSY`，表示资源现在正忙或不可用（可能是因为另一个组件/驱动程序已经请求并正在使用它）。'
- en: We will provide some actual examples of using these APIs/macros in the coming
    sections. Now, let's learn how to actually map and work with I/O memory. We will
    begin with the common approach that pretty much all modern processors support;
    that is, MMIO.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的部分提供一些使用这些API/宏的实际示例。现在，让我们学习如何实际映射和使用I/O内存。我们将从几乎所有现代处理器都支持的常见方法开始；即MMIO。
- en: Understanding and using memory-mapped I/O
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和使用内存映射I/O
- en: In the MMIO approach, the CPU understands that a certain region (or several)
    of its address space is reserved for I/O peripheral memory. You can actually look
    up the region(s) by referring to the physical memory map of a given processor's
    (or SoC's) datasheet.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在MMIO方法中，CPU理解到其地址空间的某个区域（或多个区域）被保留用于I/O外围设备内存。您可以通过参考给定处理器（或SoC）的数据表的物理内存映射来查找这些区域。
- en: 'To help make this clearer, let''s take a look at a real example: the Raspberry
    Pi. As you''ll be aware, this popular board uses a Broadcom BCM2835 (or later)
    SoC. The *BCM2835 ARM Peripherals* document at [https://github.com/raspberrypi/documentation/blob/master/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf](https://github.com/raspberrypi/documentation/blob/master/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf),
    on *page 90*, provides a screenshot of a small portion of its physical memory
    map. The mapping of the SoC''s **General Purpose Input/Output** (**GPIO**) registers
    shows a portion of the hardware I/O memory in the processor''s address space:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰地说明这一点，让我们来看一个真实的例子：树莓派。正如您所知，这款热门的开发板使用的是Broadcom BCM2835（或更高版本）SoC。*BCM2835
    ARM Peripherals*文档位于[https://github.com/raspberrypi/documentation/blob/master/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf](https://github.com/raspberrypi/documentation/blob/master/hardware/raspberrypi/bcm2835/BCM2835-ARM-Peripherals.pdf)，*第90页*提供了其物理内存映射的一小部分的截图。SoC的**通用输入/输出**（**GPIO**）寄存器的映射显示了处理器地址空间中的一部分硬件I/O内存：
- en: '![](img/7722610d-9047-4246-a6c8-0584fd0b363e.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7722610d-9047-4246-a6c8-0584fd0b363e.png)'
- en: Figure 3.1 – Physical memory map on the BCM2835 showing the GPIO register bank
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 - BCM2835上的物理内存映射显示了GPIO寄存器组
- en: 'Well, the reality is more complex; the BCM2835 SoC has multiple MMUs: one –
    the VC/ARM MMU (**VC** stands for **VideoCore** here) – translates the ARM bus
    address into the ARM physical address, after which the regular ARM MMU translates
    the physical address into a virtual address. Take a look at the diagram on *page
    5* of the aforementioned *BCM2835 ARM Peripherals* document to see this.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上更加复杂；BCM2835 SoC有多个MMU：其中一个——VC/ARM MMU（**VC**在这里代表**VideoCore**）——将ARM总线地址转换为ARM物理地址，之后常规的ARM
    MMU将物理地址转换为虚拟地址。请查看前述*BCM2835 ARM Peripherals*文档的*第5页*上的图表以了解这一点。
- en: 'As we can see, this is a register block (or bank), a collection of 32-bit registers
    serving a similar purpose (here, GPIO). In the preceding figure, the crucial column
    for our current purpose is the first one, which is the **Address** column: this
    is the physical or bus address and is the location in the ARM processor''s physical
    address space where it sees the GPIO registers. It begins at `0x7e20 0000` (as
    that''s the very first address in the preceding screenshot) and has a finite length
    (here, it''s documented as having 41 registers of 32 bits each, so we''ll take
    the length of the region as *41 * 4* bytes).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这是一个寄存器块（或者说是银行），包含了一组32位寄存器，用于类似的目的（这里是GPIO）。在前面的图中，对我们当前目的至关重要的一列是第一列，即**地址**列：这是物理或总线地址，是ARM处理器物理地址空间中看到GPIO寄存器的位置。它从`0x7e20
    0000`开始（因为这是前面截图中的第一个地址），并且有一个有限的长度（这里记录为有41个32位寄存器，所以我们将区域的长度取为*41 * 4*字节）。
- en: Using the ioremap*() APIs
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ioremap*() API
- en: 'Now, as we saw in the *Understanding the issue with direct access* section,
    attempting to perform I/O directly on these physical or bus addresses simply won''t
    work. The way we should do this is by telling Linux to **map** these bus addresses
    into the kernel''s VAS so that we can access it through **kernel virtual addresses**
    (**KVAs**)! How do we do this? The kernel provides APIs for this express purpose;
    a very common one that driver authors use is the `ioremap()` API. Its signature
    is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如我们在*理解直接访问的问题*部分所看到的，直接在这些物理或总线地址上进行I/O操作是行不通的。我们应该告诉Linux将这些总线地址映射到内核的VAS中，这样我们就可以通过内核虚拟地址（KVA）来访问它！我们该如何做到这一点呢？内核为此提供了API；驱动程序作者经常使用的一个常见API是`ioremap()`。它的签名如下：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `asm/io.h` header becomes an arch-specific header file as required. Notice
    how the first parameter to `ioremap()` is a physical (or bus) address (it's data
    type is `phys_addr_t`). This is one of the rare cases in Linux where you, as a
    driver author, have to supply a physical – not a virtual – address (the other
    typical case being when performing **Direct Memory Access** (**DMA**) operations).
    The second parameter is obvious; this is the size or length of the memory I/O
    region we must map. When invoked, the `ioremap()` routine will map the I/O chip
    or peripheral memory starting from `offset` for a length of `size` bytes into
    the kernel's VAS! This is necessary - running with kernel privilege, your driver
    can now access this I/O memory region via the return pointer and thus perform
    I/O on the memory region.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`asm/io.h`头文件根据需要成为一个特定于架构的头文件。注意`ioremap()`的第一个参数是一个物理（或总线）地址（它的数据类型是`phys_addr_t`）。这是Linux中你作为驱动程序作者必须提供物理地址而不是虚拟地址的罕见情况之一（另一个典型情况是执行**直接内存访问**（**DMA**）操作时）。第二个参数是显而易见的；这是我们必须映射的内存I/O区域的大小或长度。当调用`ioremap()`例程时，将从`offset`开始，将长度为`size`字节的I/O芯片或外围内存映射到内核的VAS！这是必要的
    - 在内核特权下，你的驱动程序现在可以通过返回指针访问这个I/O内存区域，从而对内存区域进行I/O操作。'
- en: Think about it! Just like the `mmap()` system call allows you to memory map
    a region of KVA space to a user space process, the `[devm_]ioremap*()` (and friends)
    APIs allow you to map a region of peripheral I/O memory to the KVA space.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想！就像`mmap()`系统调用允许你将KVA空间的一部分映射到用户空间进程一样，`[devm_]ioremap*()`（以及其他相关的）API允许你将外围I/O内存的一部分映射到KVA空间。
- en: The `ioremap()` API returns a KVA of the `void *` type (since it's an address
    location). So, what's the peculiar-looking `__iomem` directive here (`void __iomem
    *`)? It's simply a compiler attribute that is wiped away at build time; it's merely there
    to remind us humans (as well as to perform sanity checking or look at static analysis
    code) that this is an I/O address and not your regular RAM address!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`ioremap()` API返回一个`void *`类型的KVA（因为它是一个地址位置）。那么这里看起来奇怪的`__iomem`指令（`void __iomem
    *`）是什么？它只是一个编译器属性，在构建时会被清除；它只是为了提醒我们人类（以及执行静态分析代码的人）这是一个I/O地址，而不是你常规的RAM地址！'
- en: 'So, for the preceding example, on a Raspberry Pi device, you can map the GPIO
    register bank to a KVA by doing the following (this isn''t the actual code, but
    an example to show you how `ioremap()` API can be invoked):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面的例子中，在树莓派设备上，你可以通过以下方式将GPIO寄存器银行映射到KVA（这不是实际的代码，而是一个示例，用来展示如何调用`ioremap()`
    API）：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `iobase` variable now holds the return value from `ioremap()`; it's a KVA,
    a kernel virtual address. You can now use it, as long as it's non-NULL (you are
    expected to verify this!). So, in this example, the return value from the `ioremap()`
    is the place in kernel VAS where the GPIO registers (the peripheral I/O memory)
    of the Raspberry Pi is now mapped and available.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`iobase`变量现在保存了`ioremap()`的返回值；它是一个KVA，即内核虚拟地址。只要它不是NULL（你应该验证这一点！），你现在可以使用它。因此，在这个例子中，`ioremap()`的返回值是树莓派的GPIO寄存器（外围I/O内存）在内核VAS中的映射位置，现在可以使用了。'
- en: 'Once done, you''re expected to unmap the mapping (as can be seen in the preceding
    code fragment) using the `iounmap()` API; the parameter to the `iounmap()` API
    is obvious - the start of the I/O mapping (the value returned by the `ioremap()`):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你应该使用`iounmap()` API取消映射（如前面的代码片段中所示）；`iounmap()` API的参数是显而易见的 - I/O映射的起始位置（`ioremap()`返回的值）：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, when we map the (GPIO registers) I/O memory into kernel VAS, we get a KVA
    so that we can work with it. Interestingly, the return value from the `ioremap()`
    API is typically an address within the *vmalloc* region of the kernel VAS (refer
    back to the companion guide *Linux Kernel Programming* - Chapter 7, *Memory Management
    Internals – Essentials*, for these details). This is because `ioremap`usually
    allocates and uses the required virtual memory for mapping from the kernel''s
    vmalloc region (this is not always the case though; variants such as `ioremap_cache()`
    can use a region outside the vmalloc one). Here, let''s say the return value –
    our `iobase` address – is `0xbbed 8000` (refer to Figure 3.2: with a 2:2 GB VM
    split here, you can see that the `iobase` return address is indeed a KVA within
    the kernel''s vmalloc region).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们将(GPIO寄存器)I/O内存映射到内核VAS时，我们得到一个KVA，这样我们就可以使用它。有趣的是，`ioremap()` API的返回值通常是内核VAS的*vmalloc*区域内的地址（关于这些细节，请参考伴随指南*Linux
    Kernel Programming* - 第7章，*内存管理内部 - 基本知识*）。这是因为`ioremap`通常分配并使用所需的虚拟内存来自内核的vmalloc区域（尽管并非总是如此；变体如`ioremap_cache()`可以使用vmalloc之外的区域）。在这里，假设返回值
    – 我们的`iobase`地址 – 是`0xbbed 8000`（参考图3.2：在这里有一个2:2 GB的VM分割，你可以看到`iobase`返回地址确实是内核的vmalloc区域内的KVA）。
- en: 'The following is a conceptual diagram showing this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个概念性图表显示这一点：
- en: '![](img/ca8067d9-46ef-4063-9399-b711a79e04ac.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ca8067d9-46ef-4063-9399-b711a79e04ac.png)'
- en: Figure 3.2 – The physical-to-virtual mapping of I/O peripheral memory
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – I/O外围内存的物理到虚拟映射
- en: Comparing the preceding diagram (*Figure 3.2*) with our detailed diagram of
    kernel VAS on the Raspberry Pi, which we covered in the companion guide *Linux
    Kernel Programming* in *Chapter 7,* *Memory Management Internals - Essentials* (*Figure
    7.12*), is something interesting to do.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的图表（*图3.2*）与我们在伴随指南*Linux Kernel Programming*中涵盖的树莓派内核VAS的详细图表进行比较，*第7章*，*内存管理内部
    - 基本知识*（*图7.12*），是一件有趣的事情。
- en: (It's also educative to see a similar diagram showing the physical/virtual mapping
    of the memory on the Aarch64 or ARM64 processor; you can look it up in the official
    ARM documentation; that is, *ARM Cortex-A Series Programmer's Guide for ARMv8-A*,
    under the *The Memory Management Unit* section – check out *Figure 12.2:*[https://developer.arm.com/documentation/den0024/a/The-Memory-Management-Unit](https://developer.arm.com/documentation/den0024/a/The-Memory-Management-Unit).)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个教育性的图表，展示了Aarch64或ARM64处理器上内存的物理/虚拟映射；你可以在官方ARM文档中查找到，即*ARM Cortex-A Series
    Programmer's Guide for ARMv8-A*，在*The Memory Management Unit*部分 – 查看*Figure 12.2:*[https://developer.arm.com/documentation/den0024/a/The-Memory-Management-Unit](https://developer.arm.com/documentation/den0024/a/The-Memory-Management-Unit)。
- en: The newer breed – the devm_* managed APIs
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新一代 – devm_* 管理的API
- en: Now that you understand how to use the `request_mem_region()` and the just-seen
    `ioremap*()` APIs, guess what? The reality is that both these APIs are now considered
    deprecated; as a modern driver author, you're expected to use the better resource-managed
    `devm_*` APIs. (We covered the older ones for a few reasons, including the fact
    that many older drivers still very much use them, for understanding the basics of
    using the `ioremap()` resource management APIs, and for completeness.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了如何使用`request_mem_region()`和刚刚看到的`ioremap*()` API，猜猜看？事实上，这两个API现在被视为已弃用；作为现代驱动程序作者，你应该使用更好的资源管理`devm_*`
    API。（我们介绍了旧的API是出于几个原因，包括许多旧驱动程序仍然在使用它们，以及为了理解使用`ioremap()`资源管理API的基础知识和完整性。）
- en: 'First, let''s check out the new resource-managed ioremap, known as `devm_ioremap()`,
    in `lib/devres.c`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看新的资源管理ioremap，称为`devm_ioremap()`，位于`lib/devres.c`中：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Just as we learned with regard to the very common `kmalloc`*/*`kzalloc` APIs
    (refer to the companion guide *Linux Kernel Programming,* *Chapter 8*, *Kernel
    Memory Allocation for Module Authors – Part 1*), the `devm_kmalloc()` and the `devm_kzalloc()` APIs
    simplify life for us as they guarantee that they'll free the memory that's been
    allocated on device detach or driver removal. In a similar fashion, using `devm_ioremap()`
    implies that you don't need to explicitly invoke the `iounmap()` API since the
    kernel's *devres* framework will handle it upon driver detach!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们学习了关于非常常见的`kmalloc`*/*`kzalloc` API（参考伴随指南*Linux Kernel Programming*，*第8章*，*模块作者的内核内存分配
    - 第1部分*），`devm_kmalloc()`和`devm_kzalloc()` API也简化了我们的生活，因为它们保证在设备分离或驱动程序移除时释放已分配的内存。类似地，使用`devm_ioremap()`意味着你不需要显式调用`iounmap()`
    API，因为内核的*devres*框架将在驱动程序分离时处理它！
- en: Again, since this book is not primarily focused on writing device drivers, we
    shall mention bit not delve into deep details of using the modern **Linux Device
    Model** (**LDM**) with the `probe()` and `remove()`/`disconnect()` hooks. Other
    literature dedicated to this subject can be found in the *Further reading *section,
    at the end of this chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于本书的主要重点不是编写设备驱动程序，我们将提及但不深入探讨使用现代**Linux设备模型**（**LDM**）与`probe()`和`remove()`/`disconnect()`钩子的细节。其他专门讨论这一主题的文献可以在本章末尾的*进一步阅读*部分找到。
- en: Note that the first parameter of any `devm_*()` API is the pointer to `struct
    device` (we showed you how to obtain this in [Chapter 1](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml),
    *Writing a Simple misc Character Device Driver*, when we covered how to write
    a simple `misc` driver).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，任何`devm_*()` API的第一个参数都是指向`struct device`的指针（我们在[第1章](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml)中向你展示了如何获取这个指针，*编写一个简单的misc字符设备驱动程序*，当我们介绍如何编写一个简单的`misc`驱动程序时）。
- en: Obtaining the device resources
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取设备资源
- en: The second parameter of the `devm_ioremap()` API (see its signature in the preceding
    section) is `resource_size_t offset`. The formal parameter name `offset` is a
    bit misleading – it's really the physical or bus address of the peripheral I/O
    memory region that's used to remap to kernel VAS (in fact, the `resource_size_t` data
    type is nothing but a `typedef` for `phys_addr_t`, a physical address).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`devm_ioremap()` API的第二个参数（请参阅前面部分的签名）是`resource_size_t offset`。正式参数名`offset`有点误导-它实际上是用于重新映射到内核VAS的外围I/O内存区域的物理或总线地址（实际上，`resource_size_t`数据类型只是`phys_addr_t`的`typedef`，即物理地址）。'
- en: This and the following section's coverage is **important for Linux device driver
    authors** since it introduces some key ideas (the **Device Tree** (**DT**), the
    platform and `devres` APIs, and so on) and encompasses some very common strategies
    that are employed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分和以下部分的覆盖对于Linux设备驱动程序作者非常重要，因为它介绍了一些关键思想（**设备树**（**DT**）、平台和`devres` API等），并包含了一些常用的策略。
- en: But how will you obtain this first parameter to the `devm_ioremap()` API - the
    bus or physical address? An FAQ indeed! Well, of course, this is very device-specific.
    Having said that, the starting bus or physical address is just one of several
    I/O resources that the driver author can – and at times, must – specify. The Linux
    kernel provides a powerful framework – the **I/O resource management** framework
    – for exactly this purpose in that it allows you to get/set hardware resources.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您将如何获得`devm_ioremap()` API的第一个参数-总线或物理地址？确实是一个常见问题！当然，这是非常特定于设备的。话虽如此，起始总线或物理地址只是驱动程序作者可以-并且有时必须-指定的几个I/O资源中的一个。Linux内核提供了一个强大的框架-**I/O资源管理**框架-专门用于此目的，它允许您获取/设置硬件资源。
- en: There are several kinds of resources available; it includes device MMIO ranges,
    I/O port ranges, **interrupt request** (**IRQ**) lines, register offsets, DMAs,
    and bus values.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的资源有几种类型；包括设备MMIO范围、I/O端口范围、**中断请求**（**IRQ**）线、寄存器偏移、DMA和总线值。
- en: 'Now, in order for all this to work, the I/O resources have to be specified
    on a per-device basis. There are two broad ways in which this is done:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使所有这些工作，必须基于每个设备来指定I/O资源。这样做有两种广泛的方式：
- en: '**The traditional approach**: By hard-coding them (the I/O resources) into
    the kernel source tree in what''s often called board-specific files. (For example,
    for the popular ARM CPU, these are typically found at `arch/arm/mach->foo/...`,
    where `foo` is the machine (`mach`) or platform/board name. As a further example,
    the number of platform devices defined within these board-specific files was 1,670
    with Linux 3.10.6; migrating to the modern DT approach has had this number reduce
    to 885 for the 5.4.0 kernel source tree.)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传统方法**：通过在内核源代码树中硬编码它们（I/O资源），通常称为特定于板的文件。 （例如，对于流行的ARM CPU，这些通常可以在`arch/arm/mach->foo/...`找到，其中`foo`是机器（`mach`）或平台/板名称。例如，Linux
    3.10.6中在这些特定于板的文件中定义的平台设备数量为1,670；迁移到现代DT方法后，这个数字在5.4.0内核源代码树中减少到885。）'
- en: '**The modern approach**: By placing them (the I/O resources) in a way that
    they can be discovered at boot by the OS; this is usually done for embedded systems,
    such as ARM-32, AArch64, and PPC, by describing the hardware topology of a board
    or platform (all the hardware stuff on it, such as the SoC, CPUs, peripherals,
    disks, flash chips, sensor chips, and so on) via a hardware-specific language
    called the DT (analogous to VHDL). The **Device Tree Source** (**DTS**) files
    live under the kernel source tree (for ARM, in `arch/arm/boot/dts/`) and are compiled
    at kernel build time (via the DT compiler; that is, `dtc`) into a binary format
    called the **Device Tree Blob** (**DTB**). The DTB is typically passed along at
    boot by the bootloader to the kernel. During early boot, the kernel reads in,
    flattens, and interprets the DTB, creating platform (and other) devices as required,
    and then binds them to their appropriate drivers.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现代方法**：通过以一种可以在操作系统启动时发现它们的方式放置它们（I/O资源）；这通常用于嵌入式系统，如ARM-32、AArch64和PPC，通过描述板或平台的硬件拓扑（板上的所有硬件设备，如SoC、CPU、外围设备、磁盘、闪存芯片、传感器芯片等）来完成，使用一种称为DT的硬件特定语言（类似于VHDL）。**设备树源**（**DTS**）文件位于内核源代码树下（对于ARM，在`arch/arm/boot/dts/`），并在内核构建时编译（通过DT编译器；即`dtc`）成一种称为**设备树块**（**DTB**）的二进制格式。DTB通常由引导加载程序传递给内核。在早期引导期间，内核读取、展开和解释DTB，根据需要创建平台（和其他）设备，然后将它们绑定到适当的驱动程序。'
- en: The DT isn't present for x86[_64] systems. The closest equivalent is perhaps
    the ACPI tables. Also, note that the DT isn't a Linux-specific technology; it
    was designed to be OS-agnostic, and the generic org is called **Open Firmware**
    (**OF**).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: DT对x86[_64]系统不适用。最接近的等效物可能是ACPI表。另外，需要注意的是DT并不是Linux特定的技术；它被设计为与操作系统无关，通用的组织称为**开放固件**（**OF**）。
- en: As we mentioned previously, with this modern model, the kernel and/or the device
    driver must obtain the resource information (which is populated inside a `include/linux/ioport.h:struct
    resource`) from the DTB. How? One common way in which a platform driver usually
    does this is via the `platform_get_*()` APIs.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，使用这种现代模型，内核和/或设备驱动程序必须从DTB中获取资源信息（这些信息填充在`include/linux/ioport.h:struct
    resource`中）。如何做到？平台驱动程序通常通过`platform_get_*()` API来实现这一点。
- en: We hope to make this clear with an example from a **Video For Linux** (**V4L**) media
    controller driver within the kernel source. This driver is for the SP5 TV mixer
    on the Samsung Exynos 4 SoC (used in some Galaxy S2 models). There's even some
    kernel documentation on this, under the *V4L driver-specific documentation* section: [https://www.kernel.org/doc/html/v5.4/media/v4l-drivers/fimc.html#the-samsung-s5p-exynos4-fimc-driver](https://www.kernel.org/doc/html/v5.4/media/v4l-drivers/fimc.html#the-samsung-s5p-exynos4-fimc-driver).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过内核源中的**Video For Linux**（**V4L**）媒体控制器驱动程序的示例来澄清这一点。这个驱动程序是用于三星Exynos
    4 SoC上的SP5 TV混频器的（用于一些Galaxy S2型号）驱动程序。甚至在*V4L驱动程序特定文档*部分下有一些内核文档：[https://www.kernel.org/doc/html/v5.4/media/v4l-drivers/fimc.html#the-samsung-s5p-exynos4-fimc-driver](https://www.kernel.org/doc/html/v5.4/media/v4l-drivers/fimc.html#the-samsung-s5p-exynos4-fimc-driver)。
- en: 'The following code can be found at `drivers/gpu/drm/exynos/exynos_mixer.c`.
    Here, the driver exploits the `platform_get_resource()` API to obtain the value
    of the I/O memory resource; that is, the start physical address of the I/O memory
    for that peripheral chip:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码可以在drivers/gpu/drm/exynos/exynos_mixer.c中找到。在这里，驱动程序利用platform_get_resource()
    API来获取I/O内存资源的值；也就是说，该外围芯片的I/O内存的起始物理地址：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code snippet, the driver issues the `platform_get_resource()`
    API to fetch the pointer to the resource structure for the `IORESOURCE_MEM` type
    resource (MMIO memory!). It then issues the `devm_ioremap()` API to map this MMIO
    region into kernel VAS (as explained in some detail in the previous section).
    Using the `devm` version alleviates the need for manually unmapping the I/O memory
    when this is done (or due to an error), thus reducing the chance of leaks!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，驱动程序使用platform_get_resource() API来获取IORESOURCE_MEM类型资源（MMIO内存！）的资源结构的指针。然后，它使用devm_ioremap()
    API将这个MMIO区域映射到内核VAS（在前一节中有详细解释）。使用devm版本减轻了手动取消映射I/O内存的需要（或由于错误），从而减少了泄漏的机会！
- en: All in one with the devm_ioremap_resource() API
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用devm_ioremap_resource() API一体化
- en: 'As a driver author, you should become aware of and employ this useful routine:
    the `devm_ioremap_resource()` managed API performs the job of (validity) checking
    the requested I/O memory region, requesting it from the kernel (internally via
    the `devm_request_mem_region()` API), and remapping it (internally via `devm_ioremap()`)!
    This makes it a useful wrapper for driver authors like you, and its usage is pretty
    common (in the 5.4.0 kernel code base, it''s employed over 1,400 times). Its signature
    is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为驱动程序作者，您应该了解并使用这个有用的例程：devm_ioremap_resource()管理的API执行了请求的I/O内存区域的（有效性）检查，从内核请求它（内部通过devm_request_mem_region()
    API），并重新映射它（内部通过devm_ioremap()）！这使得它成为像您这样的驱动程序作者的一个有用的包装器，它的使用非常普遍（在5.4.0内核代码库中，它被使用了超过1400次）。它的签名如下：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here''s a usage example from `drivers/char/hw_random/bcm2835-rng.c`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自drivers/char/hw_random/bcm2835-rng.c的使用示例：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Again, as is typical with the modern LDM, this code is executed as part of the probe routine
    of the driver. Also (again, this is very common), the `platform_get_resource()`
    API is employed first in order to fetch and place the value of the physical (or
    bus) address in a `resource` structure, whose address is passed as the second
    parameter to `devm_ioremap_resource()`. The I/O memory, using MMIO, is now checked,
    requested, and remapped to kernel VAS, ready for the driver to use!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，与现代LDM典型的情况一样，此代码作为驱动程序的probe例程的一部分执行。同样（这是非常常见的），首先使用platform_get_resource()
    API，以获取并放置物理（或总线）地址的值在resource结构中，其地址作为第二个参数传递给devm_ioremap_resource()。现在，使用MMIO的I/O内存已经被检查、请求和重新映射到内核VAS，准备供驱动程序使用！
- en: You may have come across the `devm_request_and_ioremap()` API which was commonly
    used for similar purposes; back in 2013, it was replaced with the `devm_ioremap_resource()`
    API.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经遇到过devm_request_and_ioremap() API，它通常用于类似的目的；2013年，它被devm_ioremap_resource()
    API所取代。
- en: Finally, there are several variants of `ioremap()`. The `[devm_]ioremap_nocache()`
    and `ioremap_cache()` APIs are such examples and affect the CPU's caching modes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有几种ioremap()的变体。[devm_]ioremap_nocache()和ioremap_cache() API就是这样的例子，它们影响CPU的缓存模式。
- en: Driver authors would do well to carefully read the (arch-specific) comments
    in the kernel source where these routines are; for example, on the x86 at `arch/x86/mm/ioremap.c:ioremap_nocache()`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序作者最好仔细阅读内核源代码中这些例程的（特定于体系结构的）注释；例如，在x86上的arch/x86/mm/ioremap.c:ioremap_nocache()。
- en: Now, having covered this important section on how to get resource information
    and use the modern `devm_*()` managed APIs, let's learn how to interpret the output
    from `/proc` with regard to MMIO.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，已经涵盖了如何获取资源信息并使用现代的devm_*()管理API的重要部分，让我们学习如何解释与MMIO有关的/proc的输出。
- en: Looking up the new mapping via /proc/iomem
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过/proc/iomem查找新映射
- en: 'Once you have performed a mapping (via one of the just-covered `[devm_]ioremap*()`APIs),
    it can actually be seen via the read-only pseudo-file; that is, `/proc/iomem`. The
    reality is that a new entry under `/proc/iomem` is generated when you successfully
    call `request_mem_region()`. Viewing it requires root access (more correctly,
    you can view it as non-root but will only see all the addresses as `0`; this is
    for security purposes). So, let''s take a look at this on our trusty x86_64 Ubuntu
    guest VM. In the following output, due to lack of space and for clarity, we''ll
    show it partially truncated:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您执行了映射（通过刚刚涵盖的[devm_]ioremap*()API之一），它实际上可以通过只读伪文件/proc/iomem看到。事实上，当您成功调用request_mem_region()时，将在/proc/iomem下生成一个新条目。查看它需要root访问权限（更正确地说，您可以以非root身份查看它，但只会看到所有地址为0；这是出于安全目的）。因此，让我们在我们可靠的x86_64
    Ubuntu客户VM上看一下这个。在以下输出中，由于空间不足和为了清晰起见，我们将显示部分截断：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The really important thing to realize is that the address ranges shown in the
    left hand-side column are not virtual – **they are physical (or bus) addresses**. You
    can see where the system (or platform) RAM is mapped. Also, within it, you can
    see where exactly the kernel code, data, and bss sections are (in terms of physical
    addresses). In fact, my `procmap` utility ([https://github.com/kaiwan/procmap](https://github.com/kaiwan/procmap))
    uses precisely this information (converting the physical addresses to virtual).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 真正重要的是要意识到左侧列中显示的地址范围不是虚拟的 - 它们是物理（或总线）地址。您可以看到系统（或平台）RAM映射的位置。此外，在其中，您可以看到内核代码、数据和bss部分的确切位置（以物理地址表示）。实际上，我的`procmap`实用程序（[https://github.com/kaiwan/procmap](https://github.com/kaiwan/procmap)）正是使用这些信息（将物理地址转换为虚拟地址）。
- en: 'For some contrast, let''s run the same command on our Raspberry Pi 3 device
    (the B+ model sports a Broadcom BCM2837 SoC with a quad-core ARM Cortex A53).
    Again, due to space restrictions and for clarity, we''ll show a partially truncated
    part of the output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对比一下，让我们在我们的树莓派3设备上运行相同的命令（B+型号搭载了Broadcom BCM2837 SoC，带有四核ARM Cortex A53）。同样，由于空间限制和为了清晰起见，我们将显示输出的部分内容：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice how the GPIO register bank shows up as `gpio@7e200000`, which, as we
    saw in *Figure 3.1*, is the physical address. You may be wondering why the format
    on ARM looks different from that of the x86_64\. What does the left column now
    mean? Here, the kernel allows the BSP/platform team to decide on how exactly they
    construct and set up (via `/proc/iomem`) the I/O memory regions for display, which
    makes sense! They know the hardware platform best. We mentioned this previously,
    but the fact is that the BCM2835 SoC (which the Raspberry Pi uses) has multiple
    MMUs. One such MMU is the coarse granularity VC/ARM MMU, which translates the
    ARM bus address into an ARM physical address, after which the regular ARM MMU
    translates the physical address into a virtual address. Hence, here, the ARM bus
    address `start-end` values show up in the left column and the ARM physical address
    shows as suffixed to the `@` symbol (`gpio@xxx`). So, for the preceding GPIO registers
    being mapped, the ARM bus addresses are `3f200000`-`3f2000b3` and the ARM physical
    address is `0x7e200000`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意GPIO寄存器组显示为`gpio@7e200000`，正如我们在*图3.1*中看到的那样，这是物理地址。您可能会想知道为什么ARM的格式看起来与x86_64的格式不同。左列现在表示什么？在这里，内核允许BSP/平台团队决定如何构建和设置（通过`/proc/iomem`）用于显示的I/O内存区域，这是有道理的！他们最了解硬件平台。我们之前提到过这一点，但事实是BCM2835
    SoC（树莓派使用的SoC）有多个MMU。其中一个MMU是粗粒度VC/ARM MMU，它将ARM总线地址转换为ARM物理地址，然后常规的ARM MMU将物理地址转换为虚拟地址。因此，在这里，ARM总线地址`start-end`值显示在左列，ARM物理地址作为后缀显示在`@`符号后面（`gpio@xxx`）。因此，对于被映射的前述GPIO寄存器，ARM总线地址是`3f200000`-`3f2000b3`，ARM物理地址是`0x7e200000`。
- en: 'Let''s finish this section by mentioning a few more points regarding the `/proc/iomem`
    pseudo-file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过提到关于`/proc/iomem`伪文件的一些要点来完成本节：
- en: '`/proc/iomem` displays the physical (and/or bus) addresses currently being
    mapped by the kernel and/or various device drivers. However, the exact display
    format is very arch- and device-dependent.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc/iomem`显示了内核和/或各种设备驱动程序当前正在映射的物理（和/或总线）地址。但是，确切的显示格式非常依赖于架构和设备。'
- en: An entry is generated for `/proc/iomem` whenever the `request_mem_region()`
    API runs.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当`request_mem_region()` API运行时，都会为`/proc/iomem`生成一个条目。
- en: The entry is removed when the corresponding `release_mem_region()` API runs.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当相应的`release_mem_region()` API运行时，条目将被移除。
- en: You can find the relevant kernel code at `kernel/resource.c:ioresources_init()`.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在`kernel/resource.c:ioresources_init()`中找到相关的内核代码。
- en: So, now that you have the I/O memory region successfully mapped to kernel VAS,
    how will you actually read/write this I/O memory? What are the APIs for MMIO?
    The next section delves into this topic.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在您已经成功将I/O内存区域映射到内核VAS，您将如何实际读取/写入这个I/O内存？MMIO的API是什么？下一节将深入探讨这个话题。
- en: MMIO – performing the actual I/O
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MMIO - 执行实际I/O
- en: 'When working with the MMIO approach, the peripheral I/O memory is mapped to
    the kernel VAS, and thus appears to you – the driver author – as plain old memory,
    just like RAM. We need to be careful here: there are caveats and cautions to be
    observed. You are *not *expected to treat the region as plain old RAM and access
    it directly via the usual C routines!'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用MMIO方法时，外围I/O内存被映射到内核VAS，因此对于驱动程序作者来说，它看起来就像普通的内存，就像RAM一样。我们需要小心：有一些注意事项和警告需要遵守。您不应该将该区域视为普通的RAM并直接通过通常的C例程访问它！
- en: In the upcoming sections, we'll show you how to perform I/O (reads and writes)
    for any peripheral I/O region that's been remapped via the MMIO approach. We'll
    begin with the very common case of performing small (1- to 8-byte) I/O, then move
    on to repeating I/O, before looking at how to `memset` and `memcpy` an MMIO region.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将向您展示如何对通过MMIO方法重新映射的任何外围I/O区域执行I/O（读取和写入）。我们将从执行小（1到8字节）I/O的常见情况开始，然后转向重复I/O，再看看如何对MMIO区域进行`memset`和`memcpy`。
- en: Performing 1- to 8-byte reads and writes on MMIO memory regions
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在MMIO内存区域上执行1到8字节的读写
- en: 'So, how exactly can you access and perform I/O (reads and writes) on peripheral
    I/O memory via the MMIO approach? The kernel provides APIs allowing you to both
    read and write chip memory. By using these APIs (or macros/inline functions),
    you can perform I/O, such as reads and writes, in four possible bit-widths; that
    is, 8-bit, 16-bit, 32-bit, and, on 64-bit systems, 64-bit:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您究竟如何通过MMIO方法访问和执行外围I/O内存上的I/O（读取和写入）？内核提供了允许您读取和写入芯片内存的API。通过使用这些API（或宏/内联函数），您可以以四种可能的位宽进行I/O，即8位、16位、32位，在64位系统上是64位。
- en: 'MMIO reads: `ioread8()`, `ioread16()`, `ioread32()`, and `ioread64()`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MMIO读取：`ioread8()`、`ioread16()`、`ioread32()`和`ioread64()`
- en: MMIO writes: `iowrite8()`, `iowrite16()`, `iowrite32()`, and `iowrite64()`
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MMIO写入：`iowrite8()`、`iowrite16()`、`iowrite32()`和`iowrite64()`
- en: 'The signatures of the **I/O read routines** are as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**I/O读取例程**的签名如下：'
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The single parameter for the `ioreadN()` APIs is the address of the I/O memory
    location that must be read from. Typically, it's the return value that's obtained
    from one of the `*ioremap*()` APIs we have seen, plus an offset (the offset could
    be `0`). Adding an offset to the base (`__iomem`) address is a very common thing
    since hardware designers deliberately lay out registers in such a way that they
    can be easily sequentially accessed, as an array (or register bank), by software!
    Driver authors take advantage of this. Of course, there's no shortcut for this
    as you cannot assume anything – you have to carefully study the datasheet for
    the particular I/O peripheral you're writing the driver for; the devil lies in
    the details!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`ioreadN()` API的单个参数是必须从中读取的I/O内存位置的地址。通常，它是从我们看到的`*ioremap*()` API之一获得的返回值，再加上一个偏移量（偏移量可以是`0`）。在基本地址（`__iomem`）上添加偏移量是一件非常常见的事情，因为硬件设计者故意以这种方式布置寄存器，以便软件可以轻松地按顺序访问，作为数组（或寄存器组）！驱动程序作者利用了这一点。当然，这里没有捷径，因为你不能假设任何东西
    - 你必须仔细研究你为其编写驱动程序的特定I/O外设的数据表；魔鬼就在细节中！'
- en: The `u8` return type is a `typedef` specifying an unsigned 8-bit data type (conversely,
    the `s` prefix denotes a signed data type). The same goes for the other data types
    (there's `s8`, `u8`, `s16`, `u16`, `s32`, `u32`, `s64`, and `u64`, all very useful
    and unambiguous).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`u8`返回类型是指定无符号8位数据类型的`typedef`（相反，`s`前缀表示有符号数据类型）。其他数据类型也是一样的（有`s8`、`u8`、`s16`、`u16`、`s32`、`u32`、`s64`和`u64`，都非常有用且明确）。'
- en: 'The signatures of the **I/O write routines** are as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**I/O写入例程**的签名如下：'
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first parameter for the `iowriteN()` APIs is the value to write (of the
    appropriate bit-width), while the second parameter specifies the location to write
    it to; that is, the MMIO address (again, this is obtained via one of the `*ioremap*()`
    APIs). Notice that there''s no return value. This is because these I/O routines
    literally work on the hardware, so there''s no question of them failing: they
    always succeed! Now, of course, your driver may still not work, but this could
    be due to any number of reasons (resource unavailable, wrongly mapped, using the
    wrong offset, timing or synchronization issues, and so on). However, the I/O routines
    will still work.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`iowriteN()` API的第一个参数是要写入的值（适当位宽的值），而第二个参数指定要写入的位置；也就是MMIO地址（同样，这是通过`*ioremap*()`
    API之一获得的）。请注意，这里没有返回值。这是因为这些I/O例程实际上是在硬件上工作的，所以它们不会失败：它们总是成功的！当然，你的驱动程序可能仍然无法工作，但这可能是由于许多原因（资源不可用，错误映射，使用错误的偏移量，时间或同步问题等）。但是，I/O例程仍然会工作。'
- en: A common test that driver authors use to fundamentally test the driver's/hardware's
    sanity is that they write a value, `n`, into a register and read it back; you
    should get the same value (`n`). (Of course, this only holds true if the register/hardware
    won't immediately change or consume it.)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序作者常用的一个常见测试是，他们将一个值`n`写入一个寄存器并读取它；你应该得到相同的值（`n`）。（当然，这只有在寄存器/硬件不会立即改变或消耗它的情况下才成立。）
- en: Performing repeating I/O on MMIO memory regions
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在MMIO内存区域上执行重复I/O
- en: 'The `ioread[8|16|32|64]()` and `iowrite[8|16|32|64]()` APIs can work upon small
    data quantums ranging from 1 to 8 bytes only. But what if we''d like to read or
    write a few dozen or a few hundred bytes? You can always encode these APIs in
    a loop. However, the kernel, anticipating exactly this, provides helper routines
    that are more efficient, that internally use a tight assembly loop. These are
    the so-called repeating versions of the MMIO APIs:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`ioread[8|16|32|64]()`和`iowrite[8|16|32|64]()` API只能处理1到8字节的小数据量。但是如果我们想要读取或写入几十或几百字节怎么办？你总是可以在循环中编码这些API。但是，内核预期到这一点，提供了更有效的辅助例程，内部使用紧凑的汇编循环。这些被称为MMIO
    API的重复版本：'
- en: For reading, we have the `ioread[8|16|32|64]_rep()` set of APIs.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于读取的API是`ioread[8|16|32|64]_rep()`。
- en: For writing, we have the `iowrite[8|16|32|64]_rep()` set of APIs.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于写入的API是`iowrite[8|16|32|64]_rep()`。
- en: 'Let''s look at the signature for one of them; that is, an 8-bit repeating read.
    The remaining reads are completely analogous:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看其中一个的签名；也就是，8位重复读取的签名。其余读取完全类似。
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will read `count` bytes from the source address, `addr` (an MMIO location),
    into the (kernel-space) destination buffer specified by `buffer`. Similarly, the
    following is the signature for the repeating 8-bit write:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从源地址`addr`（一个MMIO位置）读取`count`字节到由`buffer`指定的（内核空间）目标缓冲区。类似地，以下是重复8位写入的签名：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will write `count` bytes from the source (kernel-space) buffer ( `buffer`)
    into the destination address, `addr` (an MMIO location).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从源（内核空间）缓冲区`buffer`写入`count`字节到目标地址`addr`（一个MMIO位置）。
- en: Besides these APIs, the kernel does have a few helpers that are variations of
    this; for example, for endianness, it provides `ioread32be()`, where `be` is big-endian.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些API之外，内核还有一些变体的辅助程序；例如，对于字节顺序，它提供了`ioread32be()`，其中`be`是大端。
- en: Setting and copying on MMIO memory regions
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在MMIO内存区域上进行设置和复制
- en: 'The kernel also provides helper routines for the `memset()` and `memcpy()` operations
    when using MMIO. Note that you must use the following helpers:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 内核还为使用MMIO时的`memset()`和`memcpy()`操作提供了辅助例程。请注意，你必须使用以下辅助程序：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will set the I/O memory from the start address, `addr` (an MMIO location),
    to the value specified by the `value` parameter for `size` bytes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置从起始地址`addr`（一个MMIO位置）开始的I/O内存为`size`字节的`value`参数指定的值。
- en: 'For the purpose of copying memory, two helper routines are available, depending
    on the direction of the memory transfer:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了复制内存，有两个辅助例程可用，取决于内存传输的方向：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first copies memory from the MMIO location `addr` to the (kernel-space)
    destination buffer (`buffer`) for `size` bytes; the second routine copies memory
    from the (kernel-space) source buffer (`buffer`) to the destination MMIO location
    `addr` for `size` bytes. Again, for all these helpers, notice that there is no
    return value; they always succeed. Also, for all the preceding routines, ensure
    you include the `linux/io.h` header.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例程将内存从MMIO位置`addr`复制到（内核空间）目标缓冲区（`buffer`）的`size`字节；第二个例程将内存从（内核空间）源缓冲区（`buffer`）复制到目标MMIO位置`addr`的`size`字节。同样，对于所有这些辅助程序，请注意没有返回值；它们总是成功的。另外，对于所有前面的例程，请确保包括`linux/io.h`头文件。
- en: Originally, the `asm/io.h` header was typically included. However, now, the
    `linux/io.h` header is an abstraction layer above it and internally includes the
    `asm/io.h` file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，通常包括`asm/io.h`头文件。但是现在，`linux/io.h`头文件是其上的一个抽象层，并在内部包括`asm/io.h`文件。
- en: 'Something to be aware of is that the kernel has older helper routines for performing
    MMIO; these are the `read[b|w|l|q]()` and `write[b|w|l|q]()` API helpers. Here,
    the letter that''s suffixed to the read/write specifies the bit width; it''s really
    very simple:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，内核具有用于执行MMIO的较旧的辅助例程；这些是`read[b|w|l|q]()`和`write[b|w|l|q]()` API辅助程序。在这里，附加到读/写的字母指定了位宽；这实际上非常简单：
- en: '`b`: Byte-wide (8 bits)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`：字节宽（8位）'
- en: '`w`: Word-wide (16 bits)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`：字宽（16位）'
- en: '`l`: Long-wide (32 bits)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l`：长宽（32位）'
- en: '`q`: Quad-word-wide (64 bits); only available on 64-bit machines'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`q`：四字宽（64位）；仅适用于64位机器'
- en: Note that with modern kernels, you are *not* expected to use these routines,
    but rather the aforementioned `ioread/iowrite[8|16|32|64]()` API helpers. The
    only reason we're mentioning them here is that there are still several drivers
    using these older helper routines. The syntax and semantics are completely analogous
    to the newer helpers, so I'll leave it to you to look them up if required.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于现代内核，不希望您使用这些例程，而是使用前面提到的`ioread/iowrite[8|16|32|64]()` API辅助程序。我们在这里提到它们的唯一原因是仍然有几个驱动程序使用这些较旧的辅助例程。语法和语义与新的辅助程序完全类似，因此如果需要，我会留给您自己查找它们。
- en: 'Let''s end this section by summarizing (without paying too much attention to
    all the details we''ve covered so far) the **typical sequence that drivers follow
    when performing MMIO**:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过总结（不要太关注我们到目前为止所涵盖的所有细节）**驱动程序在执行MMIO时遵循的典型顺序**来结束本节：
- en: Request the memory region from the kernel via `request_mem_region()` (generates
    an entry in `*/*proc/iomem`).
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`request_mem_region()`从内核请求内存区域（在`/proc/iomem`中生成一个条目）。
- en: Remap the peripheral I/O memory to kernel VAS via `[devm_]ioremap[_resource|[no]cache()`;
    modern drivers typically use the managed `devm_ioremap()` (or the `devm_ioremap_resource()`
    API) to do so
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`[devm_]ioremap[_resource|[no]cache()`将外围I/O内存重新映射到内核VAS；现代驱动程序通常使用`managed
    devm_ioremap()`（或`devm_ioremap_resource()` API）来执行此操作
- en: 'Perform the actual I/O via one or more of the modern helper routines:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过一个或多个现代辅助例程执行实际I/O：
- en: '`ioread[8|16|32|64]()`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ioread[8|16|32|64]()`'
- en: '`iowrite[8|16|32|64]()`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iowrite[8|16|32|64]()`'
- en: '`memset_io() / memcpy_fromio() / memcpy_toio()`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memset_io() / memcpy_fromio() / memcpy_toio()`'
- en: (Older helper routines: `read[b|w|l|q]()` and `write[b|w|l|q]()`)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （较旧的辅助例程：`read[b|w|l|q]()`和`write[b|w|l|q]()`）
- en: When done, unmap the MMIO region; that is, `iounmap()`. This is only done if
    required (when using the managed `devm_ioremap*()` APIs, this is unnecessary).
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，取消映射MMIO区域；也就是`iounmap()`。只有在需要时才会执行此操作（使用`managed` `devm_ioremap*()` API时，这是不必要的）。
- en: Release the MMIO region back to the kernel via `release_mem_region()` (clears
    the entry in `/proc/iomem`).
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`release_mem_region()`将MMIO区域释放回内核（清除`/proc/iomem`中的条目）。
- en: With MMIO being a powerful means to communicate with peripheral chips, you might
    imagine that all drivers (including the so-called bus drivers) are designed and
    written to use it (and/or port I/O) but this isn't true. This is due to performance
    issues. After all is said and done, performing MMIO (or PMIO) on a peripheral
    requires the processor's continuous interaction and attention. This, on many classes
    of devices (think about streaming high-definition media content on your smartphone
    or tablet!), is just far too slow. So, what's the high-performance way of communicating
    with a peripheral device? The answer is DMA*,* a topic that's unfortunately beyond
    the scope of this book (do look at the *Further reading *section for suggestions
    on useful driver books and resources on DMA). So, where is MMIO used? Realistically,
    it's used for plenty of lower speed peripherals, including for status and control
    operations.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于MMIO是与外围芯片通信的强大手段，您可能会想象所有驱动程序（包括所谓的总线驱动程序）都设计和编写以使用它（和/或端口I/O），但事实并非如此。这是由于性能问题。毕竟，对外围设备执行MMIO（或PMIO）需要处理器的持续交互和关注。在许多设备类别上（想想在智能手机或平板电脑上流式传输高清媒体内容！），这只是太慢了。那么，与外围设备通信的高性能方式是什么？答案是DMA*，这是本书范围之外的一个话题（请查看*进一步阅读*部分，了解有关DMA的有用驱动程序书籍和资源的建议）。那么，MMIO用在哪里？实际上，它用于许多较低速的外围设备，包括状态和控制操作。
- en: While MMIO is the most common way of performing I/O on peripherals, port I/O is
    another. So, let's learn how to work with it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然MMIO是对外围设备执行I/O的最常见方式，端口I/O是另一种方式。因此，让我们学习如何使用它。
- en: Understanding and using port-mapped I/O
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和使用端口映射I/O
- en: 'As we mentioned earlier in the *The solution – mapping via I/O memory or I/O
    port* section, besides MMIO, there is another way to perform I/O on peripheral
    device memory called PMIO,or often simply **PIO**. It works quite differently
    from MMIO. Here, the CPU has distinct assembly (and corresponding machine) instructions
    to enable it to directly read and write I/O memory locations. Not only that, but
    this I/O memory range is a separate address space altogether, distinct from RAM.
    These memory locations are called ports. Don''t confuse the term **port** that''s
    being used here with the same term that''s used in networking technology; think
    of this port as an **hardware register** in that it closely approximates the meaning.
    (While it''s usually 8-bit, peripheral chip registers can actually be of three
    bit widths: 8, 16, or 32 bits.)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在“解决方案-通过I/O内存或I/O端口进行映射”部分中早些时候提到的，除了MMIO，还有另一种在外围设备内存上执行I/O的方法，称为PMIO，或者简称为PIO。它的工作方式与MMIO完全不同。在这里，CPU具有不同的汇编（和相应的机器）指令，使其能够直接读取和写入I/O内存位置。不仅如此，而且这个I/O内存范围是一个完全独立的地址空间，与RAM完全不同。这些内存位置被称为端口。不要混淆这里使用的术语“端口”与网络技术中使用的相同术语；把这个端口看作是一个硬件寄存器，这更接近其含义。（虽然通常是8位，外围芯片寄存器实际上可以是三种位宽：8、16或32位。）
- en: The reality is that most modern processors, even if they do support PMIO with
    a separate I/O port address space, tend to mostly use the MMIO approach for peripheral
    I/O mapping. The mainstream processor family that does support PMIO and employs
    it often – in addition to MMIO – is the x86. On these processors, as documented
    in their **physical memory map**, is a range of address locations reserved for
    this purpose. This is called the **port address range** and typically - on the
    x86 - spans from physical address `0x0` to `0xffff`; that is, 64 kilobytes in
    length. What registers does this region contain? Typically, on the x86, there
    are registers (usually data/status/control) for various I/O peripherals. Some
    common ones include the i8042 keyboard/mouse controller chip, **DMA controller**
    (**DMAC**), timers, RTC, and so on. We'll look at these in more detail in the *Looking
    up the* *ports via /proc/ioports* section.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，大多数现代处理器，即使支持具有独立I/O端口地址空间的PMIO，也倾向于主要使用MMIO方法进行外围I/O映射。主流处理器系列中支持PMIO并经常使用它的是x86。在这些处理器上，如其**物理内存映射**中所记录的，有一段地址位置专门用于此目的。这被称为**端口地址范围**，通常在x86上跨越从物理地址`0x0`到`0xffff`的范围；也就是说，长度为64千字节。这个区域包含哪些寄存器？通常在x86上，有各种I/O外围设备的寄存器（通常是数据/状态/控制）。一些常见的包括i8042键盘/鼠标控制器芯片，DMA控制器（DMAC），定时器，RTC等。我们将在“通过/proc/ioports查找端口”部分中更详细地讨论这些。
- en: PMIO – performing the actual I/O
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PMIO - 执行实际I/O
- en: Port I/O is pretty simple compared to all the hoopla we saw with MMIO. This
    is because the processor provides machine instructions to directly perform the
    work. Of course, just like MMIO, you are expected to politely ask the kernel for
    permission to access a PIO region (we covered this in the *Asking the kernel's
    permission* section). The APIs for doing this are `request_region()` and `release_region()`
    (their parameters are identical to their MMIO counterpart APIs).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 端口I/O与我们在MMIO中看到的所有热闹相比要简单得多。这是因为处理器提供了机器指令来直接执行工作。当然，就像MMIO一样，你需要礼貌地请求内核允许访问PIO区域（我们在“请求内核的许可”部分中介绍了这一点）。用于执行此操作的API是`request_region()`和`release_region()`（它们的参数与它们的MMIO对应API完全相同）。
- en: 'So, how can you access and perform I/O (reads and writes) upon the *I/O* *port(s)*?
    Again, the kernel provides API wrappers over the underlying assembly/machine instructions
    to do so for both reading and writing. Using them, you can perform I/O reads and
    writes in three possible bit-widths; that is, 8-bit, 16-bit, and 32-bit:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你如何访问和执行I/O（读取和写入）*I/O* *端口*？同样，内核提供了API包装器，用于对底层的汇编/机器指令进行读取和写入。使用它们，你可以以三种可能的位宽进行I/O读取和写入；即8位、16位和32位。
- en: 'PMIO reads: `inb()`, `inw()`, and `inl()`'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PMIO读取：`inb()`，`inw()`和`inl()`
- en: 'PMIO writes: `outb()`, `outw()`, and `outl()`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PMIO写入：`outb()`，`outw()`和`outl()`
- en: Quite intuitively, `b` implies byte-wide (8 bits), `w` implies word-wide (16
    bits), and `l` implies long-wide (32 bits).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 相当直观地，`b`表示字节宽（8位），`w`表示字宽（16位），`l`表示长宽（32位）。
- en: 'The signatures of the **port I/O read routines** are as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**端口I/O读例程**的签名如下：'
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The single parameter for the `in[b|w|l]()` wrappers is the port address of
    the port I/O memory location that will be read from. We covered this in the *Obtaining
    the device resources* section (a really key section for driver developers like
    you!). A **port** is also a resource, which means it can be obtained in the usual
    manner: on modern embedded systems, this is done by parsing the *device tree*
    (or ACPI tables); the older way was to hard-code the values within board-specific
    source files. Actually, for many common peripherals, the port number or port address
    range is a well-known one, which means it can be hard-coded into the driver (this
    often occurs in the driver''s header files). Again, it''s best to not simply assume
    anything, ensure you refer to the datasheet for the peripheral in question.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`in[b|w|l]()`包装器的单个参数是将要从中读取的端口I/O内存位置的端口地址。我们在“获取设备资源”部分中介绍了这一点（对于像你这样的驱动程序开发人员来说，这是一个非常关键的部分！）。端口也是一种资源，这意味着它可以以通常的方式获得：在现代嵌入式系统上，这是通过解析设备树（或ACPI表）来完成的；旧的方法是在特定于板的源文件中硬编码这些值。实际上，对于许多常见的外围设备，端口号或端口地址范围是众所周知的，这意味着它可以被硬编码到驱动程序中（这经常发生在驱动程序的头文件中）。再次强调，最好不要简单地假设任何事情，确保你参考所涉及外围设备的数据表。'
- en: Now, let's get back to the APIs. The return value is an unsigned integer (with
    the bit-width varying, depending on the helper routine being used). It's the current
    value on that port (register) at the instant the read was issued.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到API。返回值是一个无符号整数（位宽取决于所使用的辅助例程）。它是在发出读取时端口（寄存器）上的当前值。
- en: 'The signatures of the **port I/O write routines** are as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**端口I/O写例程**的签名如下：'
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first parameter is the value to be written to the hardware (port), while
    the second parameter is the port address of the port I/O memory to write to. Again,
    as with MMIO, there's no question of failure since these helper I/O routines always
    succeed. On the x86 at least, a write to an I/O port is guaranteed to be completed
    before the next instruction is executed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是要写入硬件（端口）的值，而第二个参数是要写入的I/O端口内存的端口地址。与MMIO一样，这些助手I/O例程总是成功的，没有失败的问题。至少在x86上，对I/O端口的写入保证在执行下一条指令之前完成。
- en: A PIO example – the i8042
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PIO示例 - i8042
- en: To help make things clearer, let's look at a few code snippets from the device
    driver for the i8042 keyboard and mouse controller, which, though nowadays considered
    quite old, is still very common on x86 systems.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助澄清事情，让我们看一下i8042键盘和鼠标控制器的设备驱动程序的一些代码片段，尽管现在被认为相当古老，但在x86系统上仍然非常常见。
- en: You can find a basic schematic of the 8042 controller here: [https://wiki.osdev.org/File:Ps2-kbc.png](https://wiki.osdev.org/File:Ps2-kbc.png).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里找到8042控制器的基本原理图：[https://wiki.osdev.org/File:Ps2-kbc.png](https://wiki.osdev.org/File:Ps2-kbc.png)。
- en: 'The interesting bits (for us, at least) are in the driver''s header file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分（至少对我们来说）在驱动程序的头文件中：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding code snippet, we can see the I/O ports or hardware registers that
    this driver works with. How come the status and data registers resolve to the
    same I/O port (`0x64`) address? The *direction* matters: reading it has I/O port
    `0x64` behave as the status register, while writing to it has it behave as the
    command register! Furthermore, the datasheet will show you that these are 8-bit
    registers; so, here, the actual I/O is performed via the `inb()` and `outb()`
    helpers. The driver abstracts these further in small inline routines:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们可以看到这个驱动程序使用的I/O端口或硬件寄存器。为什么状态和数据寄存器解析为相同的I/O端口（`0x64`）地址？*方向*很重要：读取它使I/O端口`0x64`的行为像状态寄存器，而写入它使其行为像命令寄存器！此外，数据表将向您展示这些是8位寄存器；因此，在这里，实际的I/O是通过`inb()`和`outb()`助手执行的。驱动程序在小的内联例程中进一步抽象了这些：
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Of course, the reality is that there's far more that this driver does (than
    what we've shown here), including handling hardware interrupts, initializing and
    working with multiple ports, blocking reads and writes, flushing buffers, blinking
    the keyboard LEDs on kernel panic, and more. We won't look into this any further
    here.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，事实是这个驱动程序做的事情远不止我们在这里展示的，包括处理硬件中断，初始化和处理多个端口，阻塞读写，刷新缓冲区，在内核崩溃时闪烁键盘LED等等。我们不会在这里进一步探讨这个问题。
- en: Looking up the port(s) via /proc/ioports
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过/proc/ioports查找端口
- en: 'The kernel provides a viewport into the port address space via the `/proc/ioports` pseudo-file.
    Let''s check it out on our x86_64 guest VM (again, we''re only showing part of
    the output):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 内核通过`/proc/ioports`伪文件提供了对端口地址空间的视图。让我们在我们的x86_64虚拟机上检查一下（再次，我们只显示部分输出）：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We've highlighted the keyboard ports in bold. Notice how the port numbers match
    what the i8042 driver code we saw previously specifies. Interestingly, running
    the same command on the Raspberry Pi yields nothing; this is because no driver
    or subsystem is using any I/O ports. Analogous with MMIO, an entry in `/proc/ioports` is
    generated when the `request_region()` API runs, and, conversely, is removed when
    the corresponding `release_region()` API runs.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用粗体标出了键盘端口。请注意端口号与我们之前看到的i8042驱动程序代码匹配。有趣的是，在树莓派上运行相同的命令什么也没有；这是因为没有驱动程序或子系统使用任何I/O端口。与MMIO类似，当`request_region()`
    API运行时，`/proc/ioports`中会生成一个条目，相反，当相应的`release_region()` API运行时，它会被删除。
- en: Now, let's quickly mention a few things with respect to port I/O.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速提一下与端口I/O相关的一些事情。
- en: Port I/O – a few remaining points to note
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端口I/O - 还有一些要注意的地方
- en: 'A few more or less miscellaneous points remain on PIO that you as a driver
    author should take note of:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: PIO还有一些更多或更少的杂项要点，作为驱动程序作者，您应该注意：
- en: 'Just like MMIO provides the repeating I/O routines (recall the `ioread|iowrite[8|16|32|64]_rep()`
    helpers), PMIO (or PIO) provides somewhat similar repeating functionality for
    those cases where you''d like to read or write the same I/O port multiple times.
    These are the so-called *string versions* of the regular port helper routines;
    they have an `s` in their name to remind you of this. The kernel source contains
    a comment that neatly sums this up:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像MMIO提供了重复的I/O例程（回想一下`ioread|iowrite[8|16|32|64]_rep()`助手），PMIO（或PIO）为那些希望多次读取或写入相同I/O端口的情况提供了类似的重复功能。这些是常规端口助手例程的所谓*字符串版本*；它们的名称中有一个`s`来提醒你这一点。内核源代码中包含了一个简洁总结这一点的注释：
- en: '[PRE21]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, for example, the `insw()` helper routine will read a total of `count` times
    (that is, *count*2* bytes since it's 2-byte or 16-bit reads each) from the starting
    `addr`, which is an I/O port address, into the successive locations of the destination
    buffer at `buffer` (the `readsw()` inline function is the internal implementation).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，`insw()`助手例程将从起始地址`addr`（即I/O端口地址）读取`count`次（也就是*count*2*字节，因为每次都是2字节或16位读取）到目标缓冲区`buffer`的连续位置（`readsw()`内联函数是内部实现）。
- en: Similarly, the `outsw()` helper routine writes a total of `count` times (that
    is, *count*2* bytes since it's 2-byte or 16-bit reads each), data from the source
    buffer at `buffer` to the I/O port at `address` (the `writesw()` inline function
    is the internal implementation).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`outsw()`助手例程写入了`count`次（也就是*count*2*字节，因为每次都是2字节或16位读取），从`buffer`的源缓冲区到`address`的I/O端口（`writesw()`内联函数是内部实现）。
- en: 'Next, the kernel seems to provide helper APIs equivalent to the `in|out[b|w|l]()`
    ones; that is, `in|out[b|w|l]_p()`. Here, the `_p` suffix implies that a *pause*
    or delay was introduced into the I/O. Originally, this was meant for slow peripherals;
    nowadays, though, this seems to have become a backward-compatible moot point:
    the "delayed I/O" routines are nothing but simple wrappers over the regular routines
    (in effect there is no delaying).'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，内核似乎提供了与`in|out[b|w|l]()`等价的辅助API；也就是`in|out[b|w|l]_p()`。在这里，后缀`_p`意味着I/O中引入了*暂停*或延迟。最初，这是为了慢速外围设备；然而，现在似乎已经成为了向后兼容的无关紧要的问题：这些“延迟I/O”例程只是对常规例程的简单包装（实际上没有延迟）。
- en: There are also user space equivalents of the PIO APIs (you can use one these
    to, for example, write a user space driver). Of course, successfully issuing the
    `in|out[b|w|l]()` APIs in user mode requires the issuing process to successfully
    invoke the `iopl(2)`/`ioperm(2)` system calls, which, in turn, requires root access
    (or you require to have the `CAP_SYS_RAWIO` capability bit set; this can also
    be done for security purposes.)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有用户空间等效的PIO API（您可以使用其中一个来编写用户空间驱动程序）。当然，成功在用户模式下发出`in|out[b|w|l]()` API需要发出进程成功调用`iopl(2)`/`ioperm(2)`系统调用，这又需要root访问权限（或者您需要设置`CAP_SYS_RAWIO`能力位；这也可以出于安全目的而做）。
- en: With that, we have concluded our discussion of port I/O, as well as this chapter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经结束了对端口I/O的讨论，也结束了本章。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned why we can''t just work directly with peripheral
    I/O memory. Next, we covered how, within the Linux device driver framework, to
    access and perform I/O (reads and writes) on hardware (or peripheral) I/O memory.
    You learned that there are two broad ways to do this: via MMIO (the common approach)
    and P(M)IO.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了为什么我们不能直接使用外围I/O内存。接下来，我们介绍了如何在Linux设备驱动程序框架内访问和执行I/O（读取和写入）硬件（或外围）I/O内存。您了解到有两种广泛的方法可以做到这一点：通过MMIO（常见方法）和P(M)IO。
- en: We learned that systems such as the x86 often employ both approaches as that's
    how the peripherals are designed. MMIO and/or PMIO access is a key task for any
    driver – after all, this is how we talk to and control hardware! Not only that,
    but many of the underlying bus drivers (for various buses on Linux, such as I2C,
    USB, SPI, PCI, and more) internally use MMIO/PMIO for performing peripheral I/O.
    So, good job on completing this chapter!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到像x86这样的系统通常同时采用这两种方法，因为这就是外围设备的设计方式。MMIO和/或PMIO访问是任何驱动程序的关键任务 - 毕竟，这就是我们与硬件交流和控制的方式！不仅如此，而且许多底层总线驱动程序（用于Linux上的各种总线，如I2C、USB、SPI、PCI等）在内部使用MMIO/PMIO执行外围I/O。因此，完成本章的工作很出色！
- en: 'In the next chapter, we''ll look at another critical hardware-related area
    of importance: understanding, dealing with, and working with hardware interrupts.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到另一个重要的与硬件相关的领域：理解、处理和使用硬件中断。
- en: Questions
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Imagine that you have mapped an 8-bit register bank to a peripheral chip (via
    the `devm_ioremap_resource()` API in your driver''s `xxx_probe()` method; assume
    it succeeds). Now, you want to read the current content in the third 8-bit register.
    The following is some (pseudo)code that you can use to do this. Study it and spot
    the bug inside it:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经将一个8位寄存器组映射到外围芯片（通过驱动程序的`xxx_probe()`方法中的`devm_ioremap_resource()` API；假设成功）。现在，您想要读取第三个8位寄存器中的当前内容。以下是一些（伪）代码，您可以使用它来做到这一点。研究它并找出其中的错误。
- en: '[PRE22]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Can you suggest a fix?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你能提出一个解决方案吗？
- en: Possible solution to this exercise can be found at [https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的可能解决方案可以在[https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn)找到。
- en: Further reading
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Modern (and older) *Linux device drivers* books: Working with the LDM:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代（和较旧的）*Linux设备驱动程序*书籍：与LDM一起工作：
- en: '*Linux Device Drivers Development, Madieu*, Packt, October 2017 – This is an
    excellent resource that provides modern and wide coverage.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux设备驱动程序开发，Madieu*，Packt，2017年10月 - 这是一个提供现代和广泛覆盖的优秀资源。'
- en: '*Linux Driver Development for Embedded Processors*, Alberto Liberal de los
    Ríos, second edition, 2018.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《嵌入式处理器的Linux驱动程序开发》，Alberto Liberal de los Ríos，第二版，2018年。
- en: '*Essential Linux Device Drivers*, Sreekrishnan Venkateswaran, Pearson, March
    2008 – This is an older book but provides superb coverage on literally all types
    of Linux drivers!'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*基本Linux设备驱动程序*，Sreekrishnan Venkateswaran，Pearson，2008年3月 - 这是一本较旧的书，但提供了对各种类型的Linux驱动程序的出色覆盖！'
- en: '*Linux Device Drivers*, Rubini, Corbet, GK-Hartman, O''Reilly, February 2005
    – This is the old Linux drivers bible; how can it possibly be left out?'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Linux设备驱动程序》，Rubini，Corbet，GK-Hartman，O'Reilly，2005年2月 - 这是旧的Linux驱动程序圣经；怎么可能被遗漏呢？
- en: 'Device tree:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备树：
- en: Device tree specification: [https://www.devicetree.org/](https://www.devicetree.org/).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备树规范：[https://www.devicetree.org/](https://www.devicetree.org/)。
- en: '*Device Tree Reference*, eLinux: [https://elinux.org/Device_Tree_Reference](https://elinux.org/Device_Tree_Reference).'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设备树参考*，eLinux：[https://elinux.org/Device_Tree_Reference](https://elinux.org/Device_Tree_Reference)。'
- en: '*Generate and compile the device tree to config the hardware setup of your [Arietta](http://www.acmesystems.it/arietta)
    G25 board*: [http://linux.tanzilli.com/](http://linux.tanzilli.com/) – This provides
    a very interesting and interactive configuration that can be performed for a device
    tree!'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成和编译设备树以配置您的[Arietta](http://www.acmesystems.it/arietta) G25板的硬件设置*：[http://linux.tanzilli.com/](http://linux.tanzilli.com/)
    - 这提供了一个非常有趣和交互式的配置，可以用于设备树！'
- en: 'DMA:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DMA：
- en: Article:* Introduction to direct memory access*, October 2003: [https://www.embedded.com/introduction-to-direct-memory-access/](https://www.embedded.com/introduction-to-direct-memory-access/)
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文章：*直接内存访问简介*，2003年10月：[https://www.embedded.com/introduction-to-direct-memory-access/](https://www.embedded.com/introduction-to-direct-memory-access/)
- en: 'LWN kernel index: articles on DMA: [https://lwn.net/Kernel/Index/#Direct_memory_access](https://lwn.net/Kernel/Index/#Direct_memory_access)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LWN内核索引：有关DMA的文章：[https://lwn.net/Kernel/Index/#Direct_memory_access](https://lwn.net/Kernel/Index/#Direct_memory_access)
- en: Linux kernel documentation: *DMAEngine documentation*: [https://www.kernel.org/doc/html/latest/driver-api/dmaengine/index.html](https://www.kernel.org/doc/html/latest/driver-api/dmaengine/index.html)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核文档：*DMAEngine文档*：[https://www.kernel.org/doc/html/latest/driver-api/dmaengine/index.html](https://www.kernel.org/doc/html/latest/driver-api/dmaengine/index.html)
- en: '*Linux kernel has a "DMA test" kernel module*; documentation: [https://www.kernel.org/doc/html/latest/driver-api/dmaengine/dmatest.html](https://www.kernel.org/doc/html/latest/driver-api/dmaengine/dmatest.html)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux内核有一个“DMA测试”内核模块*；文档：[https://www.kernel.org/doc/html/latest/driver-api/dmaengine/dmatest.html](https://www.kernel.org/doc/html/latest/driver-api/dmaengine/dmatest.html)'
- en: '*Stack Overflow: From the kernel to the user space (DMA)*: [https://stackoverflow.com/questions/11137058/from-the-kernel-to-the-user-space-dma](https://stackoverflow.com/questions/11137058/from-the-kernel-to-the-user-space-dma)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Stack Overflow：从内核到用户空间（DMA）*：[https://stackoverflow.com/questions/11137058/from-the-kernel-to-the-user-space-dma](https://stackoverflow.com/questions/11137058/from-the-kernel-to-the-user-space-dma)'
- en: Laurent Pinchart – *mastering the dma and iommu apis | ELC 2014*: [https://www.youtube.com/watch?v=n07zPcbdX_w](https://www.youtube.com/watch?v=n07zPcbdX_w)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Laurent Pinchart – *掌握dma和iommu api | ELC 2014*：[https://www.youtube.com/watch?v=n07zPcbdX_w](https://www.youtube.com/watch?v=n07zPcbdX_w)
- en: 'Hardware/CPU:'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件/CPU：
- en: Intel x86 architecture, Min: [https://www.slideshare.net/multics69/intel-x86-architecture](https://www.slideshare.net/multics69/intel-x86-architecture)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Intel x86架构，Min：[https://www.slideshare.net/multics69/intel-x86-architecture](https://www.slideshare.net/multics69/intel-x86-architecture)
