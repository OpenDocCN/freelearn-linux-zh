["```\nstatic int __init data_types_init(void)\n{\n    struct dtypes_s *ptr = (struct dtypes_s *) base_addr;\n\n    pr_info(\"\\tu8\\tu16\\tu32\\tu64\\n\");\n    pr_info(\"size\\t%ld\\t%ld\\t%ld\\t%ld\\n\",\n        sizeof(u8), sizeof(u16), sizeof(u32), sizeof(u64));\n\n    pr_info(\"name\\tptr\\n\");\n    pr_info(\"reg0\\t%px\\n\", &ptr->reg0);\n    pr_info(\"reg1\\t%px\\n\", &ptr->reg1);\n    pr_info(\"reg2\\t%px\\n\", &ptr->reg2);\n    pr_info(\"reg3\\t%px\\n\", &ptr->reg3);\n    pr_info(\"reg4\\t%px\\n\", &ptr->reg4);\n    pr_info(\"reg5\\t%px\\n\", &ptr->reg5);\n\n    return -EINVAL;\n}\n```", "```\nstruct dtypes_s {\n    u32 reg0;\n    u8 pad0[2];\n    u16 reg1;\n    u32 pad1[2];\n    u8 reg2;\n    u8 reg3;\n    u16 reg4;\n    u32 reg5;\n} __attribute__ ((packed));\n```", "```\n# insmod data_types.ko \n```", "```\ndata_types:data_types_init:      u8 u16 u32 u64\ndata_types:data_types_init: size 1  2   4   8\n```", "```\ndata_types:data_types_init: name ptr\ndata_types:data_types_init: reg0 0000000080000000\ndata_types:data_types_init: reg1 0000000080000006\ndata_types:data_types_init: reg2 0000000080000010\ndata_types:data_types_init: reg3 0000000080000011\ndata_types:data_types_init: reg4 0000000080000012\ndata_types:data_types_init: reg5 0000000080000014\n```", "```\n#ifndef __HAVE_ARCH_STRCPY\nextern char * strcpy(char *,const char *);\n#endif\n#ifndef __HAVE_ARCH_STRNCPY\nextern char * strncpy(char *,const char *, __kernel_size_t);\n#endif\n#ifndef __HAVE_ARCH_STRLCPY\nsize_t strlcpy(char *, const char *, size_t);\n#endif\n#ifndef __HAVE_ARCH_STRSCPY\nssize_t strscpy(char *, const char *, size_t);\n#endif\n#ifndef __HAVE_ARCH_STRCAT\nextern char * strcat(char *, const char *);\n#endif\n#ifndef __HAVE_ARCH_STRNCAT\nextern char * strncat(char *, const char *, __kernel_size_t);\n#endif\n...\n```", "```\nstatic int __init helper_funcs_init(void)\n{\n    char str2[STR2_LEN];\n\n    pr_info(\"str=\\\"%s\\\"\\n\", str);\n    pr_info(\"str size=%ld\\n\", strlen(str));\n\n    strncpy(str2, str, STR2_LEN);\n\n    pr_info(\"str2=\\\"%s\\\"\\n\", str2);\n    pr_info(\"str2 size=%ld\\n\", strlen(str2));\n\n    return -EINVAL;\n}\n```", "```\nstatic char *str = \"default string\";\nmodule_param(str, charp, S_IRUSR | S_IWUSR);\nMODULE_PARM_DESC(str, \"a string value\");\n```", "```\n# insmod helper_funcs.ko\n```", "```\nhelper_funcs:helper_funcs_init: str=\"default string\"\nhelper_funcs:helper_funcs_init: str size=14\nhelper_funcs:helper_funcs_init: str2=\"default string\"\nhelper_funcs:helper_funcs_init: str2 size=14\n```", "```\n# insmod helper_funcs.ko str=\\\"very very very loooooooooong string\\\"\nhelper_funcs:helper_funcs_init: str=\"very very very loooooooooong string\"\nhelper_funcs:helper_funcs_init: str size=35\nhelper_funcs:helper_funcs_init: str2=\"very very very loooooooooong str\"\nhelper_funcs:helper_funcs_init: str2 size=32\n```", "```\n#define STR2_LEN    32\n```", "```\nstatic int __init mem_alloc_init(void)\n{\n    void *ptr;\n\n    pr_info(\"size=%ldkbytes\\n\", size);\n\n    ptr = kmalloc(size << 10, GFP_KERNEL);\n    pr_info(\"kmalloc(..., GFP_KERNEL) =%px\\n\", ptr);\n    kfree(ptr);\n\n    ptr = kmalloc(size << 10, GFP_ATOMIC);\n    pr_info(\"kmalloc(..., GFP_ATOMIC) =%px\\n\", ptr);\n    kfree(ptr);\n```", "```\n    ptr = vmalloc(size << 10);\n    pr_info(\"vmalloc(...) =%px\\n\", ptr);\n    vfree(ptr);\n```", "```\n    ptr = kvmalloc(size << 10, GFP_KERNEL);\n    pr_info(\"kvmalloc(..., GFP_KERNEL)=%px\\n\", ptr);\n    kvfree(ptr);\n\n    ptr = kvmalloc(size << 10, GFP_ATOMIC);\n    pr_info(\"kvmalloc(..., GFP_ATOMIC)=%px\\n\", ptr);\n    kvfree(ptr);\n\n    return -EINVAL;\n}\n```", "```\nstatic long size = 4;\nmodule_param(size, long, S_IRUSR | S_IWUSR);\nMODULE_PARM_DESC(size, \"memory size in Kbytes\");\n```", "```\n# insmod mem_alloc.ko\nmem_alloc:mem_alloc_init: size=4kbytes\nmem_alloc:mem_alloc_init: kmalloc(..., GFP_KERNEL) =ffff800079831000\nmem_alloc:mem_alloc_init: kmalloc(..., GFP_ATOMIC) =ffff800079831000\nmem_alloc:mem_alloc_init: vmalloc(...) =ffff000009655000\nmem_alloc:mem_alloc_init: kvmalloc(..., GFP_KERNEL)=ffff800079831000\nmem_alloc:mem_alloc_init: kvmalloc(..., GFP_ATOMIC)=ffff800079831000\n```", "```\nroot@espressobin:~# insmod mem_alloc.ko size=5000\nmem_alloc:mem_alloc_init: size=5000kbytes\nmem_alloc:mem_alloc_init: kmalloc(..., GFP_KERNEL) =0000000000000000\nmem_alloc:mem_alloc_init: kmalloc(..., GFP_ATOMIC) =0000000000000000\nmem_alloc:mem_alloc_init: vmalloc(...) =ffff00000b9fb000\nmem_alloc:mem_alloc_init: kvmalloc(..., GFP_KERNEL)=ffff00000c135000\nmem_alloc:mem_alloc_init: kvmalloc(..., GFP_ATOMIC)=0000000000000000\n```", "```\nstatic LIST_HEAD(data_list);\n\nstruct l_struct {\n    int data;\n    struct list_head list;\n};\n```", "```\nstatic int __init list_init(void)\n{\n    struct l_struct e1 = {\n        .data = 5\n    };\n    struct l_struct e2 = {\n        .data = 1\n    }; \n    struct l_struct e3 = {\n        .data = 7\n    };\n```", "```\n    pr_info(\"add e1...\\n\");\n    add_ordered_entry(&e1);\n    print_entries();\n```", "```\n    pr_info(\"add e2, e3...\\n\");\n    add_ordered_entry(&e2);\n    add_ordered_entry(&e3);\n    print_entries();\n```", "```\n    pr_info(\"del data=5...\\n\");\n    del_entry(5);\n    print_entries();\n\n    return -EINVAL;\n}\n```", "```\nstatic void add_ordered_entry(struct l_struct *new)\n{\n    struct list_head *ptr;\n    struct l_struct *entry;\n\n    list_for_each(ptr, &data_list) {\n        entry = list_entry(ptr, struct l_struct, list);\n        if (entry->data < new->data) {\n            list_add_tail(&new->list, ptr);\n            return;\n        }\n    }\n    list_add_tail(&new->list, &data_list);\n}\n```", "```\nstatic void del_entry(int data)\n{\n    struct list_head *ptr;\n    struct l_struct *entry;\n\n    list_for_each(ptr, &data_list) {\n        entry = list_entry(ptr, struct l_struct, list);\n        if (entry->data == data) {\n            list_del(ptr);\n            return;\n        }\n    }\n}\n```", "```\nstatic void print_entries(void)\n{\n    struct l_struct *entry;\n\n    list_for_each_entry(entry, &data_list, list)\n        pr_info(\"data=%d\\n\", entry->data);\n}\n```", "```\n/**\n * list_for_each_entry - iterate over list of given type\n * @pos: the type * to use as a loop cursor.\n * @head: the head for your list.\n * @member: the name of the list_head within the struct.\n */\n#define list_for_each_entry(pos, head, member) \\\n        for (pos = list_first_entry(head, typeof(*pos), member); \\\n             &pos->member != (head); \\\n             pos = list_next_entry(pos, member))\n```", "```\n# insmod list.ko \n```", "```\nlist:list_init: add e1...\nlist:print_entries: data=5\n```", "```\nlist:list_init: add e2, e3...\nlist:print_entries: data=7\nlist:print_entries: data=5\nlist:print_entries: data=1\n```", "```\nlist:list_init: del data=5...\nlist:print_entries: data=7\nlist:print_entries: data=1\n```", "```\nstatic DEFINE_HASHTABLE(data_hash, 1);\n\nstruct h_struct {\n    int data;\n    struct hlist_node node;\n};\n\nstatic int hash_func(int data)\n{\n    return data % 2;\n}\n```", "```\nstatic int __init hashtable_init(void)\n{\n    struct h_struct e1 = {\n        .data = 5\n    };\n    struct h_struct e2 = {\n        .data = 2\n    };\n    struct h_struct e3 = {\n        .data = 7\n    };\n```", "```\n    pr_info(\"add e1...\\n\");\n    add_node(&e1);\n    print_nodes();\n```", "```\n    pr_info(\"add e2, e3...\\n\");\n    add_node(&e2);\n    add_node(&e3);\n    print_nodes();\n```", "```\n    pr_info(\"del data=5\\n\");\n    del_node(5);\n    print_nodes();\n\n    return -EINVAL;\n}\n```", "```\nstatic void add_node(struct h_struct *new)\n{\n    int key = hash_func(new->data);\n\n    hash_add(data_hash, &new->node, key);\n}\n\nstatic void del_node(int data)\n{\n    int key = hash_func(data);\n    struct h_struct *entry; \n\n    hash_for_each_possible(data_hash, entry, node, key) {\n        if (entry->data == data) {\n            hash_del(&entry->node);\n            return;\n        }\n    }\n}\n```", "```\nstatic void print_nodes(void)\n{\n    int key;\n    struct h_struct *entry;\n\n    hash_for_each(data_hash, key, entry, node)\n        pr_info(\"data=%d\\n\", entry->data);\n}\n```", "```\n# insmod ./hashtable.ko \nhashtable:hashtable_init: add e1...\nhashtable:print_nodes: data=5\n```", "```\nhashtable:hashtable_init: add e2, e3...\nhashtable:print_nodes: data=7\nhashtable:print_nodes: data=2\nhashtable:print_nodes: data=5\n```", "```\nhashtable:hashtable_init: del data=5\nhashtable:print_nodes: data=7\nhashtable:print_nodes: data=2\n```", "```\nstatic int sunxi_reset_init(struct device_node *np)\n{\n    struct reset_simple_data *data;\n    struct resource res;\n    resource_size_t size;\n    int ret;\n\n    data = kzalloc(sizeof(*data), GFP_KERNEL);\n    if (!data)\n        return -ENOMEM;\n\n    ret = of_address_to_resource(np, 0, &res);\n    if (ret)\n        goto err_alloc;\n```", "```\n        size = resource_size(&res);\n        if (!request_mem_region(res.start, size, np->name)) {\n                ret = -EBUSY;\n                goto err_alloc;\n        }\n```", "```\n    data->membase = ioremap(res.start, size);\n    if (!data->membase) {\n        ret = -ENOMEM;\n        goto err_alloc;\n    }\n```", "```\nvoid __iomem *ioremap(phys_addr_t phys_addr, size_t size);\n\nvoid iounmap(void __iomem *addr);\n```", "```\n...\n    port->membase = devm_ioremap_resource(&pdev->dev, reg);\n    if (IS_ERR(port->membase))\n        return -PTR_ERR(port->membase);\n...\n    /* UART Soft Reset*/\n    writel(CTRL_SOFT_RST, port->membase + UART_CTRL(port));\n    udelay(1);\n    writel(0, port->membase + UART_CTRL(port));\n...\n```", "```\nroot@espressobin:~# cat /proc/iomem \n00000000-7fffffff : System RAM\n00080000-00faffff : Kernel code\n010f0000-012a9fff : Kernel data\nd0010600-d0010fff : spi@10600\nd0012000-d00121ff : serial@12000\nd0013000-d00130ff : nb-periph-clk@13000\nd0013200-d00132ff : tbg@13200\nd0013c00-d0013c1f : pinctrl@13800\nd0018000-d00180ff : sb-periph-clk@18000\nd0018c00-d0018c1f : pinctrl@18800\nd001e808-d001e80b : sdhci@d0000\nd0030000-d0033fff : ethernet@30000\nd0058000-d005bfff : usb@58000\nd005e000-d005ffff : usb@5e000\nd0070000-d008ffff : pcie@d0070000\nd00d0000-d00d02ff : sdhci@d0000\nd00e0000-d00e1fff : sata@e0000\ne8000000-e8ffffff : pcie@d0070000\n```", "```\n#define print_time(str, code)     \\\n    do {                          \\\n        u64 t0, t1;               \\\n        t0 = ktime_get_real_ns(); \\\n        code;                     \\\n        t1 = ktime_get_real_ns(); \\\n        pr_info(str \" -> %lluns\\n\", t1 - t0); \\\n    } while (0)\n```", "```\nstatic int __init time_init(void)\n{\n    pr_info(\"*delay() functions:\\n\");\n    print_time(\"10ns\", ndelay(10));\n    print_time(\"10000ns\", udelay(10));\n    print_time(\"10000000ns\", mdelay(10));\n\n    pr_info(\"*sleep() functions:\\n\");\n    print_time(\"10000ns\", usleep_range(10, 10));\n    print_time(\"10000000ns\", msleep(10));\n    print_time(\"10000000ns\", msleep_interruptible(10));\n    print_time(\"10000000000ns\", ssleep(10));\n\n    return -EINVAL;\n}\n```", "```\n# insmod time.ko \n```", "```\ntime:time_init: *delay() functions:\ntime:time_init: 10ns -> 480ns\ntime:time_init: 10000us -> 10560ns\ntime:time_init: 10000000ms -> 10387920ns\ntime:time_init: *sleep() functions:\ntime:time_init: 10000us -> 580720ns\ntime:time_init: 10000000ms -> 17979680ns\ntime:time_init: 10000000ms -> 17739280ns\ntime:time_init: 10000000000ms -> 10073738800ns\n```"]