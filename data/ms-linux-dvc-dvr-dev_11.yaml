- en: '*Chapter 9*:Leveraging the V4L2 API from the User Space'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：从用户空间利用V4L2 API'
- en: The main purpose of device drivers is controlling and leveraging the underlying
    hardware while exposing functionalities to users. These users may be applications
    running in user space or other kernel drivers. While the two previous chapters
    dealt with V4L2 device drivers, in this chapter, we will learn how to take advantage
    of V4L2 device functionalities exposed by the kernel. We will start by describing
    and enumerating user space V4L2 APIs, and then we will learn how to leverage those
    APIs to grab video data from the sensor, including mangling the sensor properties.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序的主要目的是控制和利用底层硬件，同时向用户公开功能。这些用户可能是在用户空间运行的应用程序或其他内核驱动程序。前两章涉及V4L2设备驱动程序，而在本章中，我们将学习如何利用内核公开的V4L2设备功能。我们将首先描述和枚举用户空间V4L2
    API，然后学习如何利用这些API从传感器中获取视频数据，包括篡改传感器属性。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: V4L2 user space APIs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: V4L2用户空间API
- en: Video device property management from user space
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频设备属性管理从用户空间
- en: Buffer management from user space
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户空间的缓冲区管理
- en: V4L2 user space tools
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: V4L2用户空间工具
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to make the most out of this chapter, you will need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本章，您将需要以下内容：
- en: Advanced computer architecture knowledge and C programming skills
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级计算机体系结构知识和C编程技能
- en: Linux kernel v4.19.X sources, available at [https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核v4.19.X源代码，可在[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)获取
- en: Introduction to V4L2 from user space
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从用户空间介绍V4L2
- en: 'The main purpose of writing device drivers is to ease the control and usage
    of the underlying device by the application. There are two ways for user space
    to deal with V4L2 devices: either by using all-in-one utilities such as `GStreamer`
    and its `gst-*` tools or by writing a dedicated application using user space V4L2
    APIs. In this chapter, we only deal with the code, thus we will cover how to write
    applications that use the V4L2 API.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 编写设备驱动程序的主要目的是简化应用程序对底层设备的控制和使用。用户空间处理V4L2设备有两种方式：一种是使用诸如`GStreamer`及其`gst-*`工具之类的一体化工具，另一种是使用用户空间V4L2
    API编写专用应用程序。在本章中，我们只涉及代码，因此我们将介绍如何编写使用V4L2 API的应用程序。
- en: The V4L2 user space API
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: V4L2用户空间API
- en: 'The V4L2 user space API has a reduced number of functions and a lot of data
    structures, all defined in `include/uapi/linux/videodev2.h`. In this section,
    we will try to describe the most important of them—or, better said, the most commonly
    used. Your code should include the following header:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: V4L2用户空间API具有较少的功能和大量的数据结构，所有这些都在`include/uapi/linux/videodev2.h`中定义。在本节中，我们将尝试描述其中最重要的，或者更确切地说，最常用的。您的代码应包括以下标头：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This API relies on the following functions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此API依赖以下功能：
- en: '`open()`: To open a video device'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open()`: 打开视频设备'
- en: '`close()`: To close a video device'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close()`: 关闭视频设备'
- en: '`ioctl()`: To send ioctl commands to the display driver'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ioctl()`: 向显示驱动程序发送ioctl命令'
- en: '`mmap()`: To memory map a driver-allocated buffer to user space'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mmap()`: 将驱动程序分配的缓冲区内存映射到用户空间'
- en: '`read()` or `write()`, depending on the streaming method'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read()`或`write()`，取决于流方法'
- en: 'This reduced set of APIs is extended by a very large number of ioctl commands,
    the most important of which are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个减少的API集合由大量的ioctl命令扩展，其中最重要的是：
- en: '`VIDIOC_QUERYCAP`: This is used to query the capabilities of the driver. People
    used to say it is used to query the device''s capabilities, but this is not true
    as the device may be capable of things that are not implemented in the driver.
    User space passes a `struct v4l2_capability` structure, which will be filled by
    the video driver with the relevant information.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIDIOC_QUERYCAP`: 用于查询驱动程序的功能。人们过去常说它用于查询设备的功能，但这并不正确，因为设备可能具有驱动程序中未实现的功能。用户空间传递一个`struct
    v4l2_capability`结构，该结构将由视频驱动程序填充相关信息。'
- en: '`VIDIOC_ENUM_FMT`: This is used to enumerate the image formats that are supported
    by the driver. The driver user space passes a `struct v4l2_fmtdesc` structure,
    which will be filled by the driver with the relevant information.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIDIOC_ENUM_FMT`: 用于枚举驱动程序支持的图像格式。驱动程序用户空间传递一个`struct v4l2_fmtdesc`结构，该结构将由驱动程序填充相关信息。'
- en: '`VIDIOC_G_FMT`: For a capture device, this is used to get the current image
    format. However, for a display device, you use this to get the current display
    window. In either case, user space passes a `struct v4l2_format` structure, which
    will be filled by the driver with the relevant information.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIDIOC_G_FMT`: 对于捕获设备，用于获取当前图像格式。但是，对于显示设备，您可以使用此功能获取当前显示窗口。在任何情况下，用户空间传递一个`struct
    v4l2_format`结构，该结构将由驱动程序填充相关信息。'
- en: '`VIDIOC_TRY_FMT` should be used when you are unsure about the format to be
    submitted to the device. This is used to validate a new image format for a capture
    device or a new display window depending on an output (display) device. User space
    passes a `struct v4l2_format` structure with the properties it would like to apply,
    and the driver may change the given values if they are not supported. The application
    should then check what is granted.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIDIOC_TRY_FMT`应在不确定要提交给设备的格式时使用。这用于验证捕获设备的新图像格式或根据输出（显示）设备使用新的显示窗口。用户空间传递一个带有它想要应用的属性的`struct
    v4l2_format`结构，如果它们不受支持，驱动程序可能会更改给定的值。然后应用程序应检查授予了什么。'
- en: '`VIDIOC_S_FMT` is used to set a new image format for a capture device or a
    new display window for a display (output device). The driver may change the values
    passed by user space if they are not supported. The application should check what
    is granted if `VIDIOC_TRY_FMT` is not used first.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIDIOC_S_FMT`用于为捕获设备设置新的图像格式或为显示（输出设备）设置新的显示窗口。如果不首先使用`VIDIOC_TRY_FMT`，驱动程序可能会更改用户空间传递的值，如果它们不受支持。应用程序应检查是否授予了什么。'
- en: '`VIDIOC_CROPCAP` is used to get the default cropping rectangle based on the
    current image size and the current display panel size. The driver fills a `struct
    v4l2_cropcap` structure.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIDIOC_CROPCAP` 用于根据当前图像大小和当前显示面板大小获取默认裁剪矩形。驱动程序填充一个 `struct v4l2_cropcap`
    结构。'
- en: '`VIDIOC_G_CROP` is used to get the current cropping rectangle. The driver fills
    a `struct v4l2_crop` structure.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIDIOC_G_CROP` 用于获取当前裁剪矩形。驱动程序填充一个 `struct v4l2_crop` 结构。'
- en: '`VIDIOC_S_CROP` is used to set a new cropping rectangle. The driver fills a
    `struct v4l2_crop` structure. The application should check what is granted.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIDIOC_S_CROP` 用于设置新的裁剪矩形。驱动程序填充一个 `struct v4l2_crop` 结构。应用程序应该检查授予了什么。'
- en: '`VIDIOC_REQBUFS`: This ioctl is used to request a number of buffers that can
    later be memory mapped. The driver fills a `struct v4l2_requestbuffers` structure.
    As the driver may allocate more or less than the actual number of buffers requested,
    the application should check how many buffers are really granted. No buffer is
    queued yet after this.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIDIOC_REQBUFS`：这个 ioctl 用于请求一定数量的缓冲区，以便稍后进行内存映射。驱动程序填充一个 `struct v4l2_requestbuffers`
    结构。由于驱动程序可能分配的缓冲区数量多于或少于实际请求的数量，应用程序应该检查实际授予了多少个缓冲区。在此之后还没有排队任何缓冲区。'
- en: The `VIDIOC_QUERYBUF` ioctl is used to get a buffer's information, which can
    be used by the `mmap()` system call in order to map that buffer to user space.
    The driver fills a `struct v4l2_buffer` structure.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIDIOC_QUERYBUF` ioctl 用于获取缓冲区的信息，这些信息可以被 `mmap()` 系统调用用来将缓冲区映射到用户空间。驱动程序填充一个
    `struct v4l2_buffer` 结构。'
- en: '`VIDIOC_QBUF` is used to queue a buffer by passing a `struct v4l2_buffer` structure
    associated with that buffer. On the execution path of this ioctl, the driver will
    add this buffer to its list of buffers so that it is filled when there are no
    more pending queued buffers before it. Once the buffer is filled, it is passed
    to the V4L2 core, which maintains its own list (that is, a ready buffer list)
    and it is moved off the driver''s list of DMA buffers.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIDIOC_QBUF` 用于通过传递与该缓冲区相关联的 `struct v4l2_buffer` 结构来排队一个缓冲区。在这个 ioctl 的执行路径上，驱动程序将把这个缓冲区添加到其缓冲区列表中，以便在没有更多待处理的排队缓冲区之前填充它。一旦缓冲区被填充，它就会传递给
    V4L2 核心，它维护自己的列表（即准备好的缓冲区列表），并且它会从驱动程序的 DMA 缓冲区列表中移除。'
- en: '`VIDIOC_DQBUF` is used to dequeue a filled buffer (from the V4L2''s list of
    ready buffers for the input device) or a displayed (output device) buffer by passing
    a `struct v4l2_buffer` structure associated with that buffer. This will block
    if no buffer is ready unless `O_NONBLOCK` was used with `open()`, in which case
    `VIDIOC_DQBUF` will immediately return with an `EAGAIN` error code. You should
    call `VIDIOC_DQBUF` only after `STREAMON` has been called. In the meantime, calling
    this ioctl after `STREAMOFF` would return `-EINVAL`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIDIOC_DQBUF` 用于从 V4L2 的准备好的缓冲区列表（对于输入设备）或显示的（输出设备）缓冲区中出列一个已填充的缓冲区，通过传递与该缓冲区相关联的
    `struct v4l2_buffer` 结构。如果没有准备好的缓冲区，它会阻塞，除非在 `open()` 中使用了 `O_NONBLOCK`，在这种情况下，`VIDIOC_DQBUF`
    会立即返回一个 `EAGAIN` 错误代码。只有在调用了 `STREAMON` 之后才应该调用 `VIDIOC_DQBUF`。与此同时，在 `STREAMOFF`
    之后调用这个 ioctl 会返回 `-EINVAL`。'
- en: '`VIDIOC_STREAMON` is used to turn on streaming. After that, any `VIDIOC_QBUF`
    results in an image are rendered.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIDIOC_STREAMON` 用于开启流。之后，任何 `VIDIOC_QBUF` 的结果都会呈现图像。'
- en: '`VIDIOC_STREAMOFF` is used to turn off streaming. This ioctl removes all buffers.
    It actually flushes the buffer queue.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VIDIOC_STREAMOFF` 用于关闭流。这个 ioctl 移除所有缓冲区。它实际上刷新了缓冲队列。'
- en: 'There are many more ioctl commands than those we have just enumerated. There
    are actually at least as many ioctls as there are ops in the kernel''s `v4l2_ioctl_ops`
    data structure. However, the preceding ioctls are enough to go deeper into the
    V4L2 user space API. In this section, we will not go into detail about each data
    structure. You should then keep open the `include/uapi/linux/videodev2.h` file,
    also available at [https://elixir.bootlin.com/linux/v4.19/source/include/uapi/linux/videodev2.h](https://elixir.bootlin.com/linux/v4.19/source/include/uapi/linux/videodev2.h),
    as it contains all the V4L2 APIs and data structures. That being said, the following
    pseudo-code shows a typical ioctl sequence to grab video from user space using
    V4L2 APIs:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多 ioctl 命令，不仅仅是我们刚刚列举的那些。实际上，内核的 `v4l2_ioctl_ops` 数据结构中至少有和操作一样多的 ioctl。然而，上述的
    ioctl 已经足够深入了解 V4L2 用户空间 API。在本节中，我们不会详细介绍每个数据结构。因此，你应该保持 `include/uapi/linux/videodev2.h`
    文件的打开状态，也可以在 [https://elixir.bootlin.com/linux/v4.19/source/include/uapi/linux/videodev2.h](https://elixir.bootlin.com/linux/v4.19/source/include/uapi/linux/videodev2.h)
    找到，因为它包含了所有的 V4L2 API 和数据结构。话虽如此，以下伪代码展示了使用 V4L2 API 从用户空间抓取视频的典型 ioctl 序列：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding sequence will serve as a guideline to deal with the V4L2 API in
    user space.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上述序列将作为指南来处理用户空间中的 V4L2 API。
- en: 'Be aware that it is possible for the `ioctl` system call to return a `-1` value
    while `errno = EINTR`. In this case, it would not mean an error but simply that
    the system call was interrupted, in which case it should be tried again. To address
    this (rare but possible) issue, we can consider writing our own wrapper for `ioctl`,
    such as the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ioctl` 系统调用可能返回 `-1` 值，而 `errno = EINTR`。在这种情况下，这并不意味着错误，而只是系统调用被中断，此时应该再次尝试。为了解决这个（虽然可能性很小但是可能发生的）问题，我们可以考虑编写自己的
    `ioctl` 包装器，例如以下内容：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we are done with the video grabbing sequence overview, we can figure
    out what steps are required to proceed to video streaming from device opening
    to closing, through format negotiation. We can now jump to the code, starting
    with the device opening, from which everything begins.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了视频抓取序列的概述，我们可以弄清楚从设备打开到关闭的视频流程需要哪些步骤，包括格式协商。现在我们可以跳转到代码，从设备打开开始，一切都从这里开始。
- en: Video device opening and property management
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频设备的打开和属性管理
- en: 'Drivers expose node entries in the `/dev/` directory corresponding to the video
    interfaces they are responsible for. These file nodes correspond to the `/dev/videoX`
    special files for capture devices (in our case). The application must open the
    appropriate file node prior to any interaction with the video device. It uses
    the `open()` system call for that, which will return a file descriptor that will
    be the entry point for any command sent to the device, as in the following example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序在`/dev/`目录中公开节点条目，对应于它们负责的视频接口。这些文件节点对应于捕获设备的`/dev/videoX`特殊文件（在我们的情况下）。应用程序必须在与视频设备的任何交互之前打开适当的文件节点。它使用`open()`系统调用来打开，这将返回一个文件描述符，将成为发送到设备的任何命令的入口点，如下例所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding snippet is an opening in blocking mode. Passing `O_NONBLOCK`
    to `open()` would prevent the application from being blocked if there is no ready
    buffer while trying to dequeue. Once you''re done with the video device, it should
    be closed using the `close()` system call:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段是以阻塞模式打开的。将`O_NONBLOCK`传递给`open()`将防止应用程序在尝试出队时没有准备好的缓冲区时被阻塞。完成视频设备的使用后，应使用`close()`系统调用关闭它：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After we are able to open the video device, we can start our interaction with
    it. Generally, the first action that takes place once the video device is opened
    is to query its capabilities, through which we can make it operate optimally.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够打开视频设备之后，我们可以开始与其进行交互。通常，视频设备打开后发生的第一个动作是查询其功能，通过这个功能，我们可以使其以最佳方式运行。
- en: Querying the device capabilities
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询设备功能
- en: 'It is common to query the capabilities of the device in order to make sure
    it supports the mode we need to work with. You do this using the `VIDIOC_QUERYCAP`
    ioctl command. To achieve this, the application passes a `struct v4l2_capability`
    structure (defined in `include/uapi/linux/videodev2.h`), which will be filled
    by the driver. This structure has a `.capabilities` field that has to be checked.
    That field contains the capabilities of the whole device. The following excerpt
    from the kernel source shows the possible values:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通常查询设备的功能以确保它支持我们需要处理的模式是很常见的。您可以使用`VIDIOC_QUERYCAP` ioctl命令来执行此操作。为此，应用程序传递一个`struct
    v4l2_capability`结构（在`include/uapi/linux/videodev2.h`中定义），该结构将由驱动程序填充。该结构具有一个`.capabilities`字段需要进行检查。该字段包含整个设备的功能。内核源代码的以下摘录显示了可能的值：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following code block shows a common use case that shows how to query the
    device capabilities from the code using the `VIDIOC_QUERYCAP` ioctl:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块显示了一个常见用例，展示了如何使用`VIDIOC_QUERYCAP` ioctl从代码中查询设备功能：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding code, `struct v4l2_capability` is first zeroed thanks to `memset()`
    prior to being given to the `ioctl` command. At this step, if no error occurs,
    then our `cap` variable now contains the device capabilities. You can use the
    following to check for the device type and the I/O methods:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`struct v4l2_capability`在传递给`ioctl`命令之前首先通过`memset()`清零。在这一步，如果没有错误发生，那么我们的`cap`变量现在包含了设备的功能。您可以使用以下内容来检查设备类型和I/O方法：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You may have noticed that we first zeroed our `cap` variable prior to using
    it. It is good practice to always clear parameters that will be given to V4L2
    APIs in order to avoid stale content. Let''s then define a macro—say, `CLEAR`—that
    will zero any variable given as a parameter, and use it in the rest of the chapter:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在使用之前，我们首先将`cap`变量清零。在给V4L2 API提供参数时，清除参数是一个好的做法，以避免陈旧的内容。然后，让我们定义一个宏——比如`CLEAR`——它将清零作为参数给定的任何变量，并在本章的其余部分中使用它：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, we are done with querying the video device capabilities. This allows us
    to configure the device and tweak the image format according to what we need to
    achieve. By negotiating the appropriate image format, we can leverage the video
    device, as we will see in the next section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了查询视频设备功能。这使我们能够配置设备并根据我们需要实现的内容调整图像格式。通过协商适当的图像格式，我们可以利用视频设备，正如我们将在下一节中看到的那样。
- en: Buffer management
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲区管理
- en: 'You should consider that in V4L2, two buffer queues are maintained: one for
    the driver (referred to as the `VIDIOC_QBUF` ioctl for this). Buffers are filled
    by the driver in the order they have been enqueued. Once filled, each buffer is
    moved off the INPUT queue and put into the OUTPUT queue, which is the user queue.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在V4L2中，维护两个缓冲队列：一个用于驱动程序（称为`VIDIOC_QBUF` ioctl）。缓冲区按照它们被入队的顺序由驱动程序填充。一旦填充，每个缓冲区就会从输入队列移出，并放入输出队列，即用户队列。
- en: Whenever the user application calls `VIDIOC_DQBUF` in order to dequeue a buffer,
    this buffer is looked for in the OUTPUT queue. If it's in there, the buffer will
    be dequeued and *pushed* to the user application; otherwise, the application will
    wait until a filled buffer is there. After the user finishes using the buffer,
    it must call `VIDIOC_QBUF` on this buffer in order to enqueue it back in the INPUT
    queue so that it can be filled again.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户应用程序调用`VIDIOC_DQBUF`以出队一个缓冲区时，该缓冲区将在输出队列中查找。如果在那里，缓冲区将被出队并*推送*到用户应用程序；否则，应用程序将等待直到有填充的缓冲区。用户完成使用缓冲区后，必须调用`VIDIOC_QBUF`将该缓冲区重新入队到输入队列中，以便可以再次填充。
- en: After driver initialization, the application calls the `VIDIOC_REQBUFS` ioctl
    to set the number of buffers it needs to work with. Once this is granted, the
    application queues all the buffers using `VIDIOC_QBUF`, and then calls the `VIDIOC_STREAMON`
    ioctl. Then, the driver goes ahead on its own and fills all the queued buffers.
    If there are no more queued buffers, then the driver will be waiting for a buffer
    to be queued in by the application. If such a case arises, then it means that
    some frames are lost in the capture itself.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序初始化后，应用程序调用`VIDIOC_REQBUFS` ioctl来设置它需要处理的缓冲区数量。一旦获准，应用程序使用`VIDIOC_QBUF`队列中的所有缓冲区，然后调用`VIDIOC_STREAMON`
    ioctl。然后，驱动程序自行填充所有排队的缓冲区。如果没有更多排队的缓冲区，那么驱动程序将等待应用程序入队缓冲区。如果出现这种情况，那么这意味着在捕获本身中丢失了一些帧。
- en: Image (buffer) format
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像（缓冲区）格式
- en: 'After making sure that the device is of the correct type and supports the modes
    it can work with, the application must negotiate the video format it needs. The
    application has to make sure that the video device is configured to send video
    frames in a format that the application can deal with. It has to do this before
    starting to grab and gather data (or video frames). The V4L2 API uses `struct
    v4l2_format` to represent the buffer format, whatever the type of the device is.
    This structure is defined as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在确保设备是正确类型并支持其可以使用的模式之后，应用程序必须协商其需要的视频格式。应用程序必须确保视频设备配置为以应用程序可以处理的格式发送视频帧。在开始抓取和收集数据（或视频帧）之前，必须这样做。V4L2
    API使用`struct v4l2_format`来表示缓冲区格式，无论设备类型是什么。该结构定义如下：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding structure, the `type` field represents the type of the data
    stream and should be set by the application. Depending on its value, the `fmt`
    field will be of the appropriate type. In our case, `type` must be `V4L2_BUF_TYPE_VIDEO_CAPTURE`
    as we are dealing with video capture devices. `fmt` will then be of the `struct
    v4l2_pix_format` type.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的结构中，`type`字段表示数据流的类型，并应由应用程序设置。根据其值，`fmt`字段将是适当的类型。在我们的情况下，`type`必须是`V4L2_BUF_TYPE_VIDEO_CAPTURE`，因为我们正在处理视频捕获设备。然后，`fmt`将是`struct
    v4l2_pix_format`类型。
- en: Important note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Almost all (if not all) ioctls playing directly or indirectly with the buffer
    (such as cropping, buffer requesting/queue/dequeue/querying) need to specify the
    buffer type, which makes sense. We will use `V4L2_BUF_TYPE_VIDEO_CAPTURE` as it
    is the only choice we have for our device type. The whole list of buffer types
    is of the `enum v4l2_buf_type` type defined in `include/uapi/linux/videodev2.h`.
    You should have a look.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有（如果不是全部）直接或间接与缓冲区播放的ioctl（如裁剪、缓冲区请求/排队/出队/查询）都需要指定缓冲区类型，这是有道理的。我们将使用`V4L2_BUF_TYPE_VIDEO_CAPTURE`，因为这是我们设备类型的唯一选择。缓冲区类型的整个列表是在`include/uapi/linux/videodev2.h`中定义的`enum
    v4l2_buf_type`类型。你应该看一看。
- en: 'It is common for applications to query the current format of the video device
    and then only change the properties of interest in it, and send back the new,
    mangled buffer format to the video device. However, this is not mandatory. We
    have only done it here to demonstrate how you can either get or set the current
    format. The application queries the current buffer format using the `VIDIOC_G_FMT`
    ioctl command. It has to pass a fresh (by fresh, I mean zeroed) `struct v4l2_format`
    structure with the `type` field set. The driver will fill the rest in the return
    path of the ioctl. The following is an example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常会查询视频设备的当前格式，然后仅更改其中感兴趣的属性，并将新的混合缓冲区格式发送回视频设备。但这并不是强制性的。我们只是在这里做了这个演示，以演示您如何获取或设置当前格式。应用程序使用`VIDIOC_G_FMT`
    ioctl命令查询当前缓冲区格式。它必须传递一个新的（我指的是清零的）`struct v4l2_format`结构，并设置`type`字段。驱动程序将在ioctl的返回路径中填充其余部分。以下是一个例子：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once we have the current format, we can change the relevant properties and
    send back the new format to the device. These properties may be pixel format,
    memory organization for each color component, and interlaced capture memory organization
    for each field. We can also describe the size and pitch of the buffer. Common
    (but not the only) pixel formats supported by devices are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了当前的格式，我们就可以更改相关属性，并将新格式发送回设备。这些属性可能是像素格式，每个颜色分量的内存组织，以及每个字段的交错捕获内存组织。我们还可以描述缓冲区的大小和间距。设备支持的常见（但不是唯一的）像素格式如下：
- en: '`V4L2_PIX_FMT_YUYV`: YUV422 (interleaved)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V4L2_PIX_FMT_YUYV`：YUV422（交错）'
- en: '`V4L2_PIX_FMT_NV12`: YUV420 (semi-planar)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V4L2_PIX_FMT_NV12`：YUV420（半平面）'
- en: '`V4L2_PIX_FMT_NV16`: YUV422 (semi-planar)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V4L2_PIX_FMT_NV16`：YUV422（半平面）'
- en: '`V4L2_PIX_FMT_RGB24`: RGB888 (packed)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`V4L2_PIX_FMT_RGB24`：RGB888（打包）'
- en: 'Now, let''s write the piece of code that changes the properties we need. However,
    sending the new format to the video device requires using a new ioctl command—that
    is, `VIDIOC_S_FMT`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写改变我们需要的属性的代码片段。但是，将新格式发送到视频设备需要使用新的ioctl命令，即`VIDIOC_S_FMT`：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Important note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: We could have used the preceding code without needing the current format.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面的代码，而不需要当前格式。
- en: 'The ioctl may succeed. However, this does not mean your parameters have been
    applied as is. By default, a device may not support every combination of image
    width and height, or even the required pixel format. In this case, the driver
    will apply the closest values it supports according to the ones you requested.
    You then have to check whether your parameters have been accepted or whether the
    ones that are granted are good enough for you to proceed:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ioctl可能会成功。但是，这并不意味着您的参数已经被应用。默认情况下，设备可能不支持每种图像宽度和高度的组合，甚至不支持所需的像素格式。在这种情况下，驱动程序将应用其支持的最接近的值，以符合您请求的值。然后，您需要检查您的参数是否被接受，或者被授予的参数是否足够好，以便您继续进行：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can even go further by changing the streaming parameters, such as the number
    of frames per second. We can achieve this by doing the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以进一步改变流参数，例如每秒帧数。我们可以通过以下方式实现这一点：
- en: Using the `VIDIOC_G_PARM` ioctl to query the video device's streaming parameters.
    This ioctl accepts as a parameter a fresh `struct v4l2_streamparm` structure with
    its `type` member set. This type should be one of the `enum v4l2_buf_type` values.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`VIDIOC_G_PARM` ioctl查询视频设备的流参数。此ioctl接受一个新的`struct v4l2_streamparm`结构作为参数，并设置其`type`成员。此类型应该是`enum
    v4l2_buf_type`值之一。
- en: Checking `v4l2_streamparm.parm.capture.capability` and making sure the `V4L2_CAP_TIMEPERFRAME`
    flag is set. This means that the driver allows changing the capture frame rate.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`v4l2_streamparm.parm.capture.capability`，并确保设置了`V4L2_CAP_TIMEPERFRAME`标志。这意味着驱动程序允许更改捕获帧速率。
- en: If so, we can (optionally) use the `VIDIOC_ENUM_FRAMEINTERVALS` ioctl in order
    to get the list of possible frame intervals (the API uses the frame interval,
    which is the inverse of the frame rate).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，我们可以（可选地）使用`VIDIOC_ENUM_FRAMEINTERVALS` ioctl来获取可能的帧间隔列表（API使用帧间隔，这是帧速率的倒数）。
- en: Using the `VIDIOC_S_PARM` ioctl and filling in the `v4l2_streamparm.parm.capture.timeperframe`
    members with the appropriate values. That should allow setting the capture-side
    frame rate. It's your task to make sure you're reading fast enough to not get
    frame drops.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`VIDIOC_S_PARM` ioctl并填写`v4l2_streamparm.parm.capture.timeperframe`成员的适当值。这应该允许设置捕获端的帧速率。您的任务是确保您读取得足够快，以免出现帧丢失。
- en: 'The following is an example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we can negotiate image formats and set the streaming parameter. The next
    logical continuation would be requesting buffers and proceeding to further processing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以协商图像格式并设置流参数。下一个逻辑延续将是请求缓冲区并继续进行进一步处理。
- en: Requesting buffers
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求缓冲区
- en: 'Once done with format preparation, it is time to instruct the driver to allocate
    memory that is to be used to store video frames. The `VIDIOC_REQBUFS` ioctl is
    there to achieve this. This ioctl takes a fresh `struct v4l2_requestbuffers` structure
    as an argument. Prior to being given to the ioctl, `v4l2_requestbuffers` must
    have some of its fields set:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 完成格式准备后，现在是指示驱动程序分配用于存储视频帧的内存的时候了。`VIDIOC_REQBUFS` ioctl就是为了实现这一点。此ioctl将新的`struct
    v4l2_requestbuffers`结构作为参数。在传递给ioctl之前，`v4l2_requestbuffers`必须设置其一些字段：
- en: '`v4l2_requestbuffers.count`: This member should be set with the number of memory
    buffers to be allocated. This member should be set with a value ensuring that
    frames won''t be dropped because of a lack of queued buffers in the INPUT queue.
    Most of the time, `3` or `4` are correct values. Therefore, the driver may not
    be comfortable with the requested number of buffers. In this case, the driver
    will set `v4l2_requestbuffers.count` with the granted number of buffers on the
    return path of the ioctl. The application should then check this value in order
    to make sure this granted value fits its needs.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v4l2_requestbuffers.count`：此成员应设置为要分配的内存缓冲区的数量。此成员应设置为确保帧不会因输入队列中排队的缓冲区不足而丢失的值。大多数情况下，`3`或`4`是正确的值。因此，驱动程序可能不满意请求的缓冲区数量。在这种情况下，驱动程序将在ioctl的返回路径上使用授予的缓冲区数量设置`v4l2_requestbuffers.count`。然后，应用程序应检查此值，以确保此授予的值符合其需求。'
- en: '`v4l2_requestbuffers.type`: This must be set with the video buffer type, of
    the `enum 4l2_buf_type` type. Here, again, we use `V4L2_BUF_TYPE_VIDEO_CAPTURE`.
    This would be `V4L2_BUF_TYPE_VIDEO_OUTPUT` for an output device, for example.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v4l2_requestbuffers.type`：这必须使用`enum 4l2_buf_type`类型的视频缓冲区类型进行设置。在这里，我们再次使用`V4L2_BUF_TYPE_VIDEO_CAPTURE`。例如，对于输出设备，这将是`V4L2_BUF_TYPE_VIDEO_OUTPUT`。'
- en: '`v4l2_requestbuffers.memory`: This must be one of the possible `enum v4l2_memory`
    values. Possible values of interest are `V4L2_MEMORY_MMAP`, `V4L2_MEMORY_USERPTR`,
    and `V4L2_MEMORY_DMABUF`. These are all streaming methods. However, depending
    on the value of this member, the application may have additional tasks to perform.Unfortunately,
    the `VIDIOC_REQBUFS` command is the only way for an application to discover which
    types of streaming I/O buffer are supported by a given driver. The application
    can then try `VIDIOC_REQBUFS` with each of these values and adapt its logic according
    to which one failed or succeeded.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v4l2_requestbuffers.memory`：这必须是可能的`enum v4l2_memory`值之一。感兴趣的可能值是`V4L2_MEMORY_MMAP`，`V4L2_MEMORY_USERPTR`和`V4L2_MEMORY_DMABUF`。这些都是流式传输方法。但是，根据此成员的值，应用程序可能需要执行其他任务。不幸的是，`VIDIOC_REQBUFS`命令是应用程序发现给定驱动程序支持哪些类型的流式I/O缓冲区的唯一方法。然后，应用程序可以尝试使用这些值中的每一个`VIDIOC_REQBUFS`，并根据失败或成功的情况调整其逻辑。'
- en: Requesting user pointer buﬀers – VIDIOC_REQBUFS and malloc
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求用户指针缓冲区 - VIDIOC_REQBUFS和malloc
- en: 'This step involves the driver supporting streaming mode, especially user pointer
    I/O mode. Here, the application informs the driver that it is about to allocate
    a given number of buffers:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步涉及驱动程序支持流式传输模式，特别是用户指针I/O模式。在这里，应用程序通知驱动程序即将分配一定数量的缓冲区：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, the application allocates the buffer memory from user space:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，应用程序从用户空间分配缓冲区内存：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is the first type of streaming, where buffers are malloced in user space
    and given to the kernel in order to be filled with video data: the so-called user
    pointer I/O mode. There is another fancy streaming mode, where almost everything
    is done from the kernel. Without delay, let''s introduce it.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一种流式传输，其中缓冲区在用户空间中分配并交给内核以便填充视频数据：所谓的用户指针I/O模式。还有另一种花哨的流式传输模式，几乎所有操作都是从内核完成的。让我们立刻介绍它。
- en: Requesting the memory mappable buﬀer – VIDIOC_REQBUFS, VIDIOC_QUERYBUF, and
    mmap
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求内存可映射缓冲区 - VIDIOC_REQBUFS，VIDIOC_QUERYBUF和mmap
- en: In driver buffer mode, this ioctl also returns the actual number of buffers
    allocated in the `count` member of the `v4l2_requestbuffer` structure. This streaming
    method also requires a new data structure, `struct v4l2_buffer`. After buffers
    are allocated by the driver in the kernel, this structure is used along with the
    `VIDIOC_QUERYBUFS` ioctl in order to query the physical address of each allocated
    buffer, which can be used with the `mmap()` system call. The physical address
    returned from the driver will be stored in `buffer.m.offset`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在驱动程序缓冲区模式中，此ioctl还返回`v4l2_requestbuffer`结构的`count`成员中分配的实际缓冲区数量。此流式传输方法还需要一个新的数据结构`struct
    v4l2_buffer`。在内核中由驱动程序分配缓冲区后，此结构与`VIDIOC_QUERYBUFS` ioctl一起使用，以查询每个分配的缓冲区的物理地址，该地址可与`mmap()`系统调用一起使用。驱动程序返回的物理地址将存储在`buffer.m.offset`中。
- en: 'The following code excerpt instructs the driver to allocate memory buffers
    and check the number of buffers granted:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码摘录指示驱动程序分配内存缓冲区并检查授予的缓冲区数量：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After this, the application should call the `VIDIOC_QUERYBUF` ioctl on each
    allocated buffer in order to get their corresponding physical addresses, as the
    following example shows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，应用程序应该对每个分配的缓冲区调用`VIDIOC_QUERYBUF` ioctl，以获取它们对应的物理地址，如下例所示：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In order for the application to internally track the memory mapping (obtained
    with `mmap()`) of each buffer, we defined a custom data structure, `struct buffer_addr`,
    allocated for each granted buffer, which will hold the mapping corresponding to
    this buffer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用程序能够内部跟踪每个缓冲区的内存映射（使用`mmap()`获得），我们定义了一个自定义数据结构`struct buffer_addr`，为每个授予的缓冲区分配，该结构将保存与该缓冲区对应的映射。
- en: Requesting DMABUF buffers – VIDIOC_REQBUFS, VIDIOC_EXPBUF, and mmap
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求DMABUF缓冲区 - VIDIOC_REQBUFS、VIDIOC_EXPBUF和mmap
- en: DMABUF is mostly used on `mem2mem` devices and introduces the concept of the
    **exporter** and **importer**. Say driver **A** wants to use buffers created by
    driver **B**; then we call **B** as the exporter and **A** as the buffer user/importer.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: DMABUF主要用于`mem2mem`设备，并引入了**导出者**和**导入者**的概念。假设驱动程序**A**想要使用由驱动程序**B**创建的缓冲区；那么我们称**B**为导出者，**A**为缓冲区用户/导入者。
- en: 'The `export` method instructs the driver to export its DMA buffers to user
    space by means of the file descriptor. The application achieves this using the
    `VIDIOC_EXPBUF` ioctl and requires a new data structure, `struct v4l2_exportbuffer`.
    On the return path of this ioctl, the driver will set the `v4l2_requestbuffers.md`
    member with the file descriptor corresponding to the given buffer. This is a DMABUF
    file descriptor:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`export`方法指示驱动程序通过文件描述符将其DMA缓冲区导出到用户空间。应用程序使用`VIDIOC_EXPBUF` ioctl来实现这一点，并需要一个新的数据结构`struct
    v4l2_exportbuffer`。在此ioctl的返回路径上，驱动程序将使用文件描述符设置`v4l2_requestbuffers.md`成员，该文件描述符对应于给定缓冲区。这是一个DMABUF文件描述符：'
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is possible for the application to export those buffers as DMABUF file descriptors
    so that they can be memory mapped to access the captured video content. The application
    should use the `VIDIOC_EXPBUF` ioctl for this. This ioctl extends the memory mapping
    I/O method, so it is only available for `V4L2_MEMORY_MMAP` buffers. However, it
    is actually useless at exporting capture buffers using `VIDIOC_EXPBUF` and then
    mapping them. You should use `V4L2_MEMORY_MMAP` instead.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以将这些缓冲区导出为DMABUF文件描述符，以便可以将其内存映射到访问捕获的视频内容。应用程序应该使用`VIDIOC_EXPBUF`ioctl来实现这一点。此ioctl扩展了内存映射I/O方法，因此仅适用于`V4L2_MEMORY_MMAP`缓冲区。但是，使用`VIDIOC_EXPBUF`导出捕获缓冲区然后映射它们实际上是没有意义的。应该使用`V4L2_MEMORY_MMAP`。
- en: '`VIDIOC_EXPBUF` becomes very interesting when it comes to V4L2 output devices.
    This way, the application allocates buffers on both capture and output devices
    using the `VIDIOC_REQBUFS` ioctl, and then the application exports the output
    device''s buffers as DMABUF file descriptors and uses these file descriptors to
    set the `v4l2_buffer.m.fd` field before the enqueueing ioctl on the capture device.
    The queued buffer will then have its counterpart (the output device buffer corresponding
    to `v4l2_buffer.m.fd`) filled.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`VIDIOC_EXPBUF`在涉及V4L2输出设备时变得非常有趣。这样，应用程序可以使用`VIDIOC_REQBUFS`ioctl在捕获和输出设备上分配缓冲区，然后应用程序将输出设备的缓冲区导出为DMABUF文件描述符，并在捕获设备上的入队ioctl之前使用这些文件描述符来设置`v4l2_buffer.m.fd`字段。然后，排队的缓冲区将填充其对应的缓冲区（与`v4l2_buffer.m.fd`对应的输出设备缓冲区）。'
- en: 'In the following example, we export output device buffers as DMABUF file descriptors.
    This assumes buffers for this output device have been allocated using the `VIDIOC_REQBUFS`
    ioctl with `req.type` set to `V4L2_BUF_TYPE_VIDEO_OUTPUT` and `req.memory` set
    to `V4L2_MEMORY_DMABUF`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们将输出设备缓冲区导出为DMABUF文件描述符。这假设已经使用`VIDIOC_REQBUFS`ioctl分配了此输出设备的缓冲区，其中`req.type`设置为`V4L2_BUF_TYPE_VIDEO_OUTPUT`，`req.memory`设置为`V4L2_MEMORY_DMABUF`：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, we have learned about DMABUF-based streaming and introduced the concepts
    it comes with. The next and last streaming method is much simpler and requires
    less code. Let's jump to it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了基于DMABUF的流式传输，并介绍了它所带来的概念。接下来和最后的流式传输方法要简单得多，需要的代码也更少。让我们来看看。
- en: Requesting read/write I/O memory
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请求读/写I/O内存
- en: 'This is the simpler streaming mode from a coding point of view. In the case
    of **read/write I/O**, there is nothing to do except to allocate the memory location
    where the application will store the read data, as in the following example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从编码的角度来看，这是更简单的流式传输模式。在**读/写I/O**的情况下，除了分配应用程序将存储读取数据的内存位置之外，没有其他事情要做，就像下面的示例中一样：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the previous code snippet, we have defined the same custom data structure,
    `struct buffer_addr`. However, there is no real buffer request here (`VIDIOC_REQBUFS`
    is not used) because nothing goes to the kernel yet. The buffer memory is simply
    allocated and that is all.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了相同的自定义数据结构`struct buffer_addr`。但是，这里没有真正的缓冲区请求（没有使用`VIDIOC_REQBUFS`），因为还没有任何东西传递给内核。缓冲区内存只是被分配了，就是这样。
- en: Now, we are done with buffer requests. The next step is to enqueue the requested
    buffers so that they can be filled with video data by the kernel. Let's now see
    how to do this.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了缓冲区请求。下一步是将请求的缓冲区加入队列，以便内核可以用视频数据填充它们。现在让我们看看如何做到这一点。
- en: Enqueueing the buffer and enabling streaming
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将缓冲区加入队列并启用流式传输
- en: Prior to a buffer being accessed and its data being read, this buffer must be
    enqueued. This consists of using the `VIDIOC_QBUF` ioctl on the buffer when using
    the streaming I/O method (everything except read/write I/O). Enqueueing a buffer
    will lock the memory pages of that buffer in physical memory. This way, those
    pages cannot be swapped out to disk. Do note that those buffers remain locked
    until they are dequeued, until the `VIDIOC_STREAMOFF` or `VIDIOC_REQBUFS` ioctls
    are called, or until the device is closed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问缓冲区并读取其数据之前，必须将该缓冲区加入队列。这包括在使用流式I/O方法（除了读/写I/O之外的所有方法）时，在缓冲区上使用`VIDIOC_QBUF`
    ioctl。将缓冲区加入队列将锁定该缓冲区在物理内存中的内存页面。这样，这些页面就无法被交换到磁盘上。请注意，这些缓冲区保持锁定状态，直到它们被出队列，直到调用`VIDIOC_STREAMOFF`或`VIDIOC_REQBUFS`
    ioctls，或者直到设备被关闭。
- en: In the V4L2 context, locking a buffer means passing this buffer to the driver
    for hardware access (usually DMA). If an application accesses (reads/writes) a
    locked buffer, then the result is undefined.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在V4L2上下文中，锁定缓冲区意味着将该缓冲区传递给驱动程序进行硬件访问（通常是DMA）。如果应用程序访问（读/写）已锁定的缓冲区，则结果是未定义的。
- en: To enqueue a buffer, the application must prepare `struct v4l2_buffer`, and
    `v4l2_buffer.type`, `v4l2_buffer.memory`, and `v4l2_buffer.index` should be set
    according to the buffer type, the streaming mode, and the index of the buffer
    when it has been allocated. Other fields depend on the streaming mode.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要将缓冲区入队，应用程序必须准备`struct v4l2_buffer`，并根据缓冲区类型、流模式和分配缓冲区时的索引设置`v4l2_buffer.type`、`v4l2_buffer.memory`和`v4l2_buffer.index`。其他字段取决于流模式。
- en: Important note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The *read/write I/O* method does not require enqueueing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*读/写I/O*方法不需要入队。'
- en: The concept of prime buﬀers
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主缓冲区的概念
- en: For capturing applications, it is customary to enqueue a number (most of the
    time, the number of allocated buffers) of empty buffers before you start capturing
    and enter the read loop. This helps improve the smoothness of the application
    and prevent it from being blocked because of the lack of a filled buffer. This
    should be done right after the buffers are allocated.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于捕获应用程序，通常在开始捕获并进入读取循环之前，入队一定数量（大多数情况下是分配的缓冲区数量）的空缓冲区是惯例。这有助于提高应用程序的流畅性，并防止因为缺少填充的缓冲区而被阻塞。这应该在分配缓冲区后立即完成。
- en: Enqueuing user pointer buﬀers
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入队用户指针缓冲区
- en: 'To enqueue a user pointer buffer, the application must set the `v4l2_buffer.memory`
    member to `V4L2_MEMORY_USERPTR`. The particularity here is the `v4l2_buffer.m.userptr`
    field, which must be set with the address of the buffer previously allocated and
    `v4l2_buffer.length` set to its size. When the multi-planar API is used, the `m.userptr`
    and `length` members of the passed array of `struct v4l2_plane` have to be used
    instead:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要将用户指针缓冲区入队，应用程序必须将`v4l2_buffer.memory`成员设置为`V4L2_MEMORY_USERPTR`。这里的特殊之处在于`v4l2_buffer.m.userptr`字段，必须设置为先前分配的缓冲区的地址，并且`v4l2_buffer.length`设置为其大小。当使用多平面API时，必须使用传递的`struct
    v4l2_plane`数组的`m.userptr`和`length`成员：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Enqueuing memory mappable buﬀers
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入队内存映射缓冲区
- en: 'To enqueue a memory mappable buffer, the application must fill `struct v4l2_buffer`
    by setting the `type`, `memory` (which must be `V4L2_MEMORY_MMAP`), and `index`
    members, just as in the following excerpt:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要将内存映射缓冲区入队，应用程序必须通过设置`type`、`memory`（必须为`V4L2_MEMORY_MMAP`）和`index`成员来填充`struct
    v4l2_buffer`，就像以下摘录中所示：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Enqueuing DMABUF buﬀers
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入队DMABUF缓冲区
- en: 'To enqueue an output device''s DMABUF buffer into the capture device''s one,
    applications should fill `struct v4l2_buffer`, setting the `memory` field to `V4L2_MEMORY_DMABUF`,
    the `type` field to `V4L2_BUF_TYPE_VIDEO_CAPTURE`, and the `m.fd` field to a file
    descriptor associated with a DMABUF buffer of the output device, as in the following
    excerpt:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要将输出设备的DMABUF缓冲区填充到捕获设备的缓冲区中，应用程序应填充`struct v4l2_buffer`，将`memory`字段设置为`V4L2_MEMORY_DMABUF`，将`type`字段设置为`V4L2_BUF_TYPE_VIDEO_CAPTURE`，将`m.fd`字段设置为与输出设备的DMABUF缓冲区关联的文件描述符，如下所示：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code excerpt shows how a V4L2 DMABUF import works. The `fd` argument
    in the ioctl is the file descriptor associated with the capture device, obtained
    at the `open()` syscall. `outdev_dmabuf_fd` is the array that contains the output
    device's DMABUF file descriptors. You may wonder how this can work on output devices
    that are not V4L2 but are DRM-compatible, for example. The following is a brief
    explanation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码摘录显示了V4L2 DMABUF导入的工作原理。ioctl中的`fd`参数是与捕获设备关联的文件描述符，在`open()`系统调用中获得。`outdev_dmabuf_fd`是包含输出设备的DMABUF文件描述符的数组。您可能会想知道，这如何能在不是V4L2但是兼容DRM的输出设备上工作，例如。以下是一个简要的解释。
- en: First, the DRM subsystem provides APIs in a driver-dependent way, which you
    can use to allocate a (dumb) buffer on the GPU, which will return a GEM handle.
    The DRM also provides the `DRM_IOCTL_PRIME_HANDLE_TO_FD` ioctl, which allows exporting
    a buffer into the DMABUF file descriptor through `PRIME`, then the `drmModeAddFB2()`
    API to create a `framebuffer` object (which is something that will be read and
    displayed onscreen, or should I say, the CRT controller, to be exact) corresponding
    to this buffer so that it can finally be rendered using the `drmModeSetPlane()`
    or `drmModeSetPlane()` APIs. The application can then set the `v4l2_requestbuffers.m.fd`
    field with the file descriptor returned by the `DRM_IOCTL_PRIME_HANDLE_TO_FD`
    ioctl. Then, in the read loop, after each `VIDIOC_DQBUF` ioctl, the application
    can change the plane's frame buffer and position using the `drmModeSetPlane()`
    API.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，DRM子系统以驱动程序相关的方式提供API，您可以使用这些API在GPU上分配（愚笨的）缓冲区，它将返回一个GEM句柄。DRM还提供了`DRM_IOCTL_PRIME_HANDLE_TO_FD`
    ioctl，允许通过`PRIME`将缓冲区导出到DMABUF文件描述符，然后使用`drmModeAddFB2()` API创建一个`framebuffer`对象（这是将要读取和显示在屏幕上的东西，或者我应该说，确切地说是CRT控制器），对应于这个缓冲区，最终可以使用`drmModeSetPlane()`或`drmModeSetPlane()`API进行渲染。然后，应用程序可以使用`DRM_IOCTL_PRIME_HANDLE_TO_FD`
    ioctl返回的文件描述符设置`v4l2_requestbuffers.m.fd`字段。然后，在读取循环中，在每个`VIDIOC_DQBUF` ioctl之后，应用程序可以使用`drmModeSetPlane()`API更改平面的帧缓冲区和位置。
- en: Important note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`drm dma-buf` interface layer integrated with `GEM`, which is one of the memory
    managers supported by the DRM subsystem'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`drm dma-buf`接口层集成了`GEM`，这是DRM子系统支持的内存管理器之一'
- en: Enabling streaming
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用流式传输
- en: 'Enabling streaming is kind of like informing V4L2 that the *OUTPUT* queue will
    be accessed as of now. The application should use `VIDIOC_STREAMON` to achieve
    this. The following is an example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 启用流式传输有点像通知V4L2从现在开始将*输出*队列作为访问对象。应用程序应使用`VIDIOC_STREAMON`来实现这一点。以下是一个示例：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding excerpt is short but is mandatory to enable streaming, without
    which buffers can't be dequeued later.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上述摘录很短，但是必须启用流式传输，否则稍后无法出队缓冲区。
- en: Dequeuing buffers
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 出队缓冲区
- en: This is actually part of the application's read loop. The application dequeues
    buffers using the `VIDIOC_DQBUF` ioctl. This is only possible if the streaming
    has been enabled before. When the application calls the `VIDIOC_DQBUF` ioctl,
    it instructs the driver to check whether there are any filled buffers in the `O_NONBLOCK`
    flag has been set during the `open()` system call) until a buffer is queued and
    filled.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是应用程序的读取循环的一部分。应用程序使用`VIDIOC_DQBUF` ioctl出队缓冲区。只有在流启用之后才可能。当应用程序调用`VIDIOC_DQBUF`
    ioctl时，它指示驱动程序检查是否有任何已填充的缓冲区（在`open()`系统调用期间设置了`O_NONBLOCK`标志），直到缓冲区排队并填充。
- en: Important note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Trying to dequeue a buffer without queuing it first is an error, and the `VIDIOC_DQBUF`
    ioctl should return `-EINVAL`. When the `O_NONBLOCK` flag is given to the `open()`
    function, `VIDIOC_DQBUF` returns immediately with an `EAGAIN` error code when
    no buffer is available.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在排队之前出队缓冲区是一个错误，`VIDIOC_DQBUF` ioctl应该返回`-EINVAL`。当`O_NONBLOCK`标志给定给`open()`函数时，当没有可用的缓冲区时，`VIDIOC_DQBUF`立即返回`EAGAIN`错误代码。
- en: After dequeuing a buffer and processing its data, the application must immediately
    queue back this buffer again so that it can be refilled for the next reading,
    and so on.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 出队缓冲区并处理其数据后，应用程序必须立即将此缓冲区重新排队，以便为下一次读取重新填充，依此类推。
- en: Dequeuing memory-mapped buﬀers
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 出队内存映射缓冲区
- en: 'The following is an example of dequeuing a buffer that has been memory mapped:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个出队已经内存映射的缓冲区的示例：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This could have been done in a loop. For example, let''s say you need 200 images.
    The read loop could look as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在循环中完成。例如，假设您需要200张图像。读取循环可能如下所示：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This preceding snippet is just a reimplementation of the buffer dequeuing using
    a loop, where the counter represents the number of images needed to grab.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的片段只是使用循环重新实现了缓冲区出队，其中计数器表示需要抓取的图像数量。
- en: Dequeuing user pointer buﬀers
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 出队用户指针缓冲区
- en: 'The following is an example of dequeuing a buffer using the **user pointer**:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用**用户指针**出队缓冲区的示例：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code shows how to dequeue a user pointer buffer, and is well commented
    enough to not require any further explanation. However, this could be implemented
    in a loop if many buffers were needed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码展示了如何出队用户指针缓冲区，并且有足够的注释，不需要进一步解释。然而，如果需要许多缓冲区，这可以在循环中实现。
- en: Read/write I/O
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读/写I/O
- en: 'This is the last example, showing how to dequeue a buffer using the `read()`
    system call:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一个示例，展示了如何使用`read()`系统调用出队缓冲区：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: None of the previous examples have been discussed in detail because each of
    them uses a concept that was already introduced in the *The V4L2 user space API*
    section. Now that we are familiar with writing V4L2 user space code, let's see
    how not to write any code by using dedicated tools that can be used for quickly
    prototyping your camera system.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例没有详细讨论，因为它们每个都使用了在*V4L2用户空间API*部分已经介绍的概念。现在我们已经熟悉了编写V4L2用户空间代码，让我们看看如何通过使用专用工具来快速原型设计摄像头系统而不编写任何代码。
- en: V4L2 user space tools
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: V4L2用户空间工具
- en: So far, we have learned how to write user space code to interact with the driver
    in the kernel. For rapid prototyping and testing, we could leverage some community-provided
    V4L2 user space tools. By using those tools, we can focus on the system design
    and validate the camera system. The most well-known tool is `v4l2-ctl`, which
    we will focus on; it is shipped with the `v4l-utils` package.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了如何编写用户空间代码与内核中的驱动程序进行交互。对于快速原型设计和测试，我们可以利用一些社区提供的V4L2用户空间工具。通过使用这些工具，我们可以专注于系统设计并验证摄像头系统。最知名的工具是`v4l2-ctl`，我们将重点关注它；它随`v4l-utils`软件包一起提供。
- en: Though it is not discussed in this chapter, there is also the **yavta** tool
    (which stands for **Yet Another V4L2 Test Application**), which can be used to
    test, debug, and control the camera subsystem.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本章没有讨论，但还有**yavta**工具（代表**Yet Another V4L2 Test Application**），它可以用于测试、调试和控制摄像头子系统。
- en: Using v4l2-ctl
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用v4l2-ctl
- en: '`v4l2-utils` is a user space application that can be used to query or configure
    V4L2 devices (including subdevices). This tool can help in setting up and designing
    fine-grained V4L2-based systems as it helps tweak and leverage the device''s features.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`v4l2-utils`是一个用户空间应用程序，可用于查询或配置V4L2设备（包括子设备）。该工具可以帮助设置和设计精细的基于V4L2的系统，因为它有助于调整和利用设备的功能。'
- en: Important note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`qv4l2` is the Qt GUI equivalent of `v4l2-ctl`. `v4l2-ctl` is ideal for embedded
    systems, while `qv4l2` is ideal for interactive testing.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`qv4l2`是`v4l2-ctl`的Qt GUI等效物。`v4l2-ctl`非常适合嵌入式系统，而`qv4l2`非常适合交互式测试。'
- en: Listing the video devices and their capabilities
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出视频设备及其功能
- en: 'First of all, we would need to list all the available video devices using the
    `--list-devices` option:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用`--list-devices`选项列出所有可用的视频设备：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If several devices are available, we can use the `-d` option after any `v4l2-ctl`
    commands in order to target a specific device. Do note that if the `-d` option
    is not specified, `/dev/video0` is targeted by default.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个设备可用，我们可以在任何`v4l2-ctl`命令之后使用`-d`选项来针对特定设备。请注意，如果未指定`-d`选项，默认情况下会针对`/dev/video0`。
- en: 'In order to have information on a specific device, you must use the `-D` option,
    as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关特定设备的信息，必须使用`-D`选项，如下所示：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding command shows the device information (such as the driver and its
    version) as well as its capabilities. That being said, the `--all` command gives
    better verbosity. You should give it a try.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的命令显示了设备信息（如驱动程序及其版本）以及其功能。也就是说，`--all`命令提供更好的详细信息。你应该试一试。
- en: Changing the device properties (controlling the device)
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改设备属性（控制设备）
- en: Before we look at changing the device properties, we first need to know what
    controls the device supports, what their value types (integer, Boolean, string,
    and so on) are, what their default values are, and what values are accepted.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看更改设备属性之前，我们首先需要知道设备支持的控制、它们的值类型（整数、布尔、字符串等）、它们的默认值以及接受的值是什么。
- en: 'In order to get the list of controls supported by the device, we can use `v4l2-ctl`
    with the `-L` option, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取设备支持的控制列表，我们可以使用`v4l2-ctl`和`-L`选项，如下所示：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding output, the `"value="` field returns the current value of the
    control, and the other fields are self-explanatory.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，`"value="`字段返回控制的当前值，其他字段都是不言自明的。
- en: 'Now that we are aware of the list of controls supported by the device, a control
    value can be changed thanks to the `--set-ctrl` option, as in the following example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道设备支持的控制列表，控制值可以通过`--set-ctrl`选项进行更改，如下例所示：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After that, we can check the current value with the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以使用以下命令检查当前值：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Or, we could have used the `--get-ctrl` command, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`--get-ctrl`命令，如下所示：
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now it may be time to tweak the device. Before that, let's check the video characteristics
    of the device.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能是时候调整设备了。在此之前，让我们先检查一下设备的视频特性。
- en: Setting the pixel format, resolution, and frame rate
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 设置像素格式、分辨率和帧率
- en: 'Before selecting a specific format or resolution, we need to enumerate what
    is available for the device. In order to get the supported pixel format, as well
    as the resolution and frame rate, the `--list-formats-ext` option needs to be
    given to `v4l2-ctl`, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择特定格式或分辨率之前，我们需要列举设备可用的内容。为了获取支持的像素格式、分辨率和帧率，需要向`v4l2-ctl`提供`--list-formats-ext`选项，如下所示：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: From the previous output, we can see what is supported by the target device,
    which is the `mjpeg`) compressed format and the YUYV raw format.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述输出中，我们可以看到目标设备支持的内容，即`mjpeg`压缩格式和YUYV原始格式。
- en: 'Now, in order to change the camera configuration, first select the frame rate
    using the `--set-parm` option, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了更改摄像头配置，首先使用`--set-parm`选项选择帧率，如下所示：
- en: '[PRE36]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, you can select the required resolution and/or pixel format using the
    `--set-fmt-video` option, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用`--set-fmt-video`选项选择所需的分辨率和/或像素格式，如下所示：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When it comes to the frame rate, you would want to use `v4l2-ctl` with the
    `--set-parm` option, giving the frame rate numerator only—the denominator is fixed
    to `1` (only integer frame rate values are allowed)—as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在帧率方面，您可能希望使用`v4l2-ctl`和`--set-parm`选项，只提供帧率的分子—分母固定为`1`（只允许整数帧率值）—如下所示：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Capturing frames and streaming
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获帧和流处理
- en: '`v4l2-ctl` supports many more options than you can imagine. In order to see
    the possible options, you can print the help message of the appropriate section.
    Common help commands related to streaming and video capture are the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`v4l2-ctl`支持的选项比您想象的要多得多。为了查看可能的选项，可以打印适当部分的帮助消息。与流处理和视频捕获相关的常见帮助命令如下：'
- en: '`--help-streaming`: Prints the help message for all options that deal with
    streaming'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--help-streaming`：打印所有与流处理相关的选项的帮助消息'
- en: '`--help-subdev`: Prints the help message for all options that deal with `v4l-subdevX`
    devices'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--help-subdev`：打印所有与`v4l-subdevX`设备相关的选项的帮助消息'
- en: '`--help-vidcap`: Prints the help message for all options that get/set/list
    video capture formats'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--help-vidcap`：打印所有获取/设置/列出视频捕获格式的选项的帮助消息'
- en: 'From those help commands, I''ve built the following command in order to capture
    a QVGA MJPG compressed frame on disk:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些帮助命令中，我已经构建了以下命令，以便在磁盘上捕获QVGA MJPG压缩帧：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'I''ve also managed to capture a raw YUV image with the same resolution with
    the following command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我还使用以下命令捕获了一个具有相同分辨率的原始YUV图像：
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The raw YUV image cannot be displayed unless you use a decent raw image viewer.
    In order to do so, the raw image must be converted using the `ffmpeg` tool, for
    example, as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 除非使用一个体面的原始图像查看器，否则无法显示原始YUV图像。为了做到这一点，必须使用`ffmpeg`工具转换原始图像，例如如下所示：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can notice a big difference in terms of the size between the raw and the
    compressed image, as in the following snippet:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以注意到原始图像和压缩图像之间的大小差异很大，如下摘录所示：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Do note that it is good practice to include the image format in the filename
    of a raw capture (such as `yuyv` in `grab-320x240-yuyv.raw`) so that you can easily
    convert from the right format. This rule is not necessary with compressed image
    formats because these formats are image container formats with a header that describes
    the pixel data that follows, and can be easily read with the `gst-typefind-1.0`
    tool. JPEG is such a format and the following is how its header can be read:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在原始捕获的文件名中包含图像格式是一个好习惯（例如在`grab-320x240-yuyv.raw`中包含`yuyv`），这样您就可以轻松地从正确的格式进行转换。对于压缩图像格式，这条规则是不必要的，因为这些格式是带有描述其后的像素数据的标头的图像容器格式，并且可以很容易地使用`gst-typefind-1.0`工具进行读取。JPEG就是这样一种格式，以下是如何读取其标头的方法：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now that we are done with tool usages, let's see how to go deeper and learn
    about V4L2 debugging and from user space.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了工具的使用，让我们看看如何深入了解V4L2调试以及从用户空间开始学习。
- en: Debugging V4L2 in user space
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在用户空间调试V4L2
- en: Since our video system setup may not be free of bugs, V4L2 provides a simple
    but large backdoor for debugging from user space, in order to track and shoot
    down trouble coming from either the VL4L2 framework core or the user space API.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的视频系统设置可能不是没有错误的，V4L2为了从用户空间进行跟踪和排除来自VL4L2框架核心或用户空间API的故障，提供了一个简单但大的后门调试。
- en: 'Framework debugging can be enabled as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按照以下步骤启用框架调试：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The preceding commands will instruct V4L2 to add core traces to the kernel
    log message. This way, it will easily track where the trouble is coming from,
    assuming it''s coming from the core. Run the following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将指示V4L2向内核日志消息添加核心跟踪。这样，它将很容易地跟踪故障的来源，假设故障来自核心。运行以下命令：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the previous kernel log messages, we can see the kernel-related V4L2 core
    functions call, along with some other details. If for any reason the V4L2 core
    tracing is not necessary or not enough for you, you can also enable V4L2 userland
    API tracing with the following command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的内核日志消息中，我们可以看到与内核相关的V4L2核心函数调用，以及一些其他细节。如果由于任何原因V4L2核心跟踪不是必要的或者对您来说不够，您还可以使用以下命令启用V4L2用户空间API跟踪：
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After running the command, allowing you to capture a raw image, we can see
    the following in the kernel log messages:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，允许您捕获原始图像，我们可以在内核日志消息中看到以下内容：
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding output, we can trace the different V4L2 userland API calls,
    which correspond to the different `ioctl` commands and their parameters.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的输出中，我们可以跟踪不同的V4L2用户空间API调用，这些调用对应于不同的“ioctl”命令及其参数。
- en: V4L2 compliance driver testing
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: V4L2合规性驱动程序测试
- en: In order for a driver to be V4L2-compliant, it must meet some criteria, which
    includes passing the `v4l2-compliance` tool test, which is used to test V4L devices
    of all kinds. `v4l2-compliance` attempts to test almost all aspects of a V4L2
    device and it covers almost all V4L2 ioctls.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使驱动程序符合V4L2标准，它必须满足一些标准，其中包括通过“v4l2-compliance”工具测试，该工具用于测试各种类型的V4L设备。“v4l2-compliance”试图测试V4L2设备的几乎所有方面，并涵盖几乎所有V4L2
    ioctls。
- en: 'As with other V4L2 tools, a video device can be targeted using the `-d` or
    `--device=` commands. If a device is not specified, `/dev/video0` is targeted.
    The following is an output excerpt:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他V4L2工具一样，可以使用“-d”或“--device=”命令来定位视频设备。如果未指定设备，则将定位到“/dev/video0”。以下是一个输出摘录：
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding logs, we can see that `/dev/video0` has been targeted. Additionally,
    we notice that `Debug ioctls` and `Output ioctls` are not supported by our driver
    (these are not failures). Though the output is verbose enough, it is better to
    use the `--verbose` command as well, which makes the output more user friendly
    and much more detailed. It then goes without saying that if you want to submit
    a new V4L2 driver, that driver must pass the V4L2 compliance tests.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的日志中，我们可以看到已定位到“/dev/video0”。此外，我们注意到我们的驱动程序不支持“Debug ioctls”和“Output ioctls”（这些不是失败）。尽管输出已经足够详细，但最好也使用“--verbose”命令，这样输出会更加用户友好和更加详细。因此，毫无疑问，如果要提交新的V4L2驱动程序，该驱动程序必须通过V4L2合规性测试。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we walked through the user space implementation of V4L2\. We
    started with V4L2 buffer management, from video streaming. We also learned how
    to deal with video device property management, all from user space. However, V4L2
    is a heavy framework, not just in terms of code but also in terms of power consumption.
    So, in the next chapter, we will address Linux kernel power management in order
    to keep the system at the lowest consumption level possible without degrading
    the system properties.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了V4L2的用户空间实现。我们从视频流的V4L2缓冲区管理开始。我们还学习了如何处理视频设备属性管理，都是从用户空间进行的。然而，V4L2是一个庞大的框架，不仅在代码方面，而且在功耗方面也是如此。因此，在下一章中，我们将讨论Linux内核的电源管理，以使系统在不降低系统性能的情况下保持尽可能低的功耗水平。
