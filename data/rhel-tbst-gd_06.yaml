- en: Chapter 6. Diagnosing and Correcting Firewall Issues
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。诊断和纠正防火墙问题
- en: In the previous chapter, we discovered how to troubleshoot networking-related
    issues with commands such as `telnet`, `ping`, `curl`, `netstat`, `tcpdump`, and
    `ip`. You also learned how the **TCP protocol** works, as well as how domains
    are translated to IPs using **DNS**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们发现了如何使用`telnet`、`ping`、`curl`、`netstat`、`tcpdump`和`ip`等命令来解决与网络相关的问题。您还了解了**TCP协议**的工作原理，以及如何使用**DNS**将域名转换为IP。
- en: In this chapter, we will once again troubleshoot network-related issues; however,
    this time we will discover how Linux's software firewall `iptables` works and
    how to troubleshoot network issues generated by a firewall.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将再次解决与网络相关的问题；然而，这一次我们将了解Linux的软件防火墙`iptables`的工作原理以及如何解决防火墙引起的网络问题。
- en: Diagnosing firewalls
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 诊断防火墙
- en: '[Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting*, was all about
    networking and how to troubleshoot a misconfigured network. In this chapter, we
    are going to extend that discussion to firewalls. While troubleshooting firewalls
    we are likely to use some of the same commands as [Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting*, and repeat a
    lot of the same process. This is because anytime you are using a firewall to protect
    a system, you are blocking certain types of network traffic, a misconfiguration
    of the firewall can impact any network traffic for a system.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4 "第5章。网络故障排除")*网络故障排除*是关于网络和如何排除网络配置错误的。在本章中，我们将把这个讨论扩展到防火墙。在解决防火墙问题时，我们可能会使用与[第5章](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "第5章。网络故障排除")*网络故障排除*相同的一些命令，并重复很多相同的过程。这是因为每当你使用防火墙来保护系统时，你都会阻止某些类型的网络流量，防火墙的配置错误可能会影响系统的任何网络流量。'
- en: We will start this chapter in the same way we did the other chapters, by troubleshooting
    a reported issue.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像其他章节一样，从解决报告的问题开始这一章。
- en: Déjà vu
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 似曾相识
- en: In [Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting*, our troubleshooting
    started after a developer called in and reported that the company's blog was reporting
    a database connectivity error. After troubleshooting, we found that this error
    was due to a misconfigured static route on the database server. Yet again, today
    (several days later), we receive a call from the same developer reporting the
    same issue.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4 "第5章。网络故障排除")*网络故障排除*中，我们的故障排除是在一位开发人员打来电话报告公司的博客报告了数据库连接错误后开始的。经过故障排除，我们发现这个错误是由于数据库服务器上的静态路由配置错误造成的。然而，今天（几天后），我们再次接到同一开发人员报告相同的问题。
- en: When the developer goes to `http://blog.example.com`, he receives an error stating
    there is a database connectivity issue. *Not again!*
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员访问`http://blog.example.com`时，他收到一个错误，指出存在数据库连接问题。*又来了！*
- en: Since the first step in data collection is to duplicate the issue, the first
    thing we should do is to pull up the company blog on our own browser.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据收集的第一步是复制问题，我们应该做的第一件事是在我们自己的浏览器上打开公司的博客。
- en: '![Déjà vu](img/00007.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![似曾相识](img/00007.jpeg)'
- en: It seems, in fact, that the same error is showing yet again; now to figure out
    why.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，似乎同样的错误再次出现了；现在要找出原因。
- en: Troubleshooting from historic issues
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从历史问题中解决问题
- en: The first instinct for a **Data Collector** would be to simply run through the
    same troubleshooting steps from [Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting*. The **Adaptor**
    and **Educated Gusser** troubleshooters, however, knowing the issue a few days
    ago was due to a static route would simply log in to the database server first
    and check for the same static route.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据收集器**的第一反应可能是简单地按照[第5章](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "第5章。网络故障排除")*网络故障排除*中的相同故障排除步骤进行。然而，**适配器**和**受过教育的猜测**故障排除者知道几天前的问题是由于静态路由，他们会首先登录到数据库服务器并检查是否存在相同的静态路由。'
- en: 'Maybe someone simply re-added it by mistake, or the route was not fully removed
    from the system''s configuration files:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 也许有人只是错误地重新添加了它，或者路由没有完全从系统的配置文件中删除：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Unfortunately, however, our luck is not that good; from the results of the `ip`
    command, we can see that the static route from [Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting*, is not present.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，不幸的是，我们的运气并不那么好；从`ip`命令的结果中，我们可以看到来自[第5章](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "第5章。网络故障排除")*网络故障排除*的静态路由不存在。
- en: Since the route is not present, we will need to start again at step one by checking
    whether the blog server is able to connect to the database server.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于路由不存在，我们需要重新从第一步开始，检查博客服务器是否能够连接到数据库服务器。
- en: Basic troubleshooting
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本故障排除
- en: 'The first test we should perform is a simple ping from the blog server to the
    database server. This will quickly answer whether the two servers are able to
    communicate at all:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该进行的第一个测试是从博客服务器到数据库服务器的简单ping。这将很快回答这两台服务器是否能够进行通信：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the `ping` command's results we can see that the blog server can communicate
    with the database server, or rather, the blog server sent an **ICMP echo request**
    and received an **ICMP echo reply** from the database server. The next connectivity
    we can test is connectivity to port `3306`, the MySQL port.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ping`命令的结果中，我们可以看到博客服务器可以与数据库服务器通信，或者说，博客服务器向数据库服务器发送了**ICMP回显请求**并收到了**ICMP回显回复**。我们可以测试的下一个连接是到端口`3306`，即MySQL端口的连接。
- en: 'We will test this connectivity with the `telnet` command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`telnet`命令测试这种连接：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `telnet` however, failed. This shows that there is in fact a problem with
    the blog server connecting to the database service on the database server.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`telnet`失败了。这表明博客服务器与数据库服务器上的数据库服务实际上存在问题。
- en: Validating the MariaDB service
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证MariaDB服务
- en: Now that we have established that the blog server cannot communicate with the
    database server, we need to identify the cause. Before assuming the issue is strictly
    network-related, we should first validate that the database service is up and
    running. To do this, we will simply log in to the database server and check for
    the running database process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了博客服务器无法与数据库服务器通信，我们需要确定原因。在假设问题严格是与网络相关之前，我们应该首先验证数据库服务是否正在运行。为了做到这一点，我们只需登录到数据库服务器并检查正在运行的数据库进程。
- en: 'We can use multiple methods to validate that the database processes are running.
    In the following example, we will use the `ps` command once again:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多种方法来验证数据库进程是否在运行。在下面的例子中，我们将再次使用`ps`命令：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the `ps` command, we are able to see the running **MariaDB** process. In
    the preceding example, we used the `ps -elf` command to show all processes and
    the `grep` command to filter that output to find the MariaDB service.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ps`命令，我们能够看到正在运行的**MariaDB**进程。在前面的例子中，我们使用了`ps -elf`命令来显示所有进程，然后使用`grep`命令来过滤输出以找到MariaDB服务。
- en: 'From the results, it appears that the database service is in fact running;
    but this does not tell us for sure that this process is accepting connections
    on port `3306`. To validate this, we can use the `netstat` command to identify
    which ports are listening on this server:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果来看，数据库服务实际上是在运行的；但这并不能确定这个进程是否在端口`3306`上接受连接。为了验证这一点，我们可以使用`netstat`命令来识别服务器上正在监听的端口：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: From the `netstat` command, we can see that there are quite a few ports open
    on this system and port `3306` is one of them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从`netstat`命令中，我们可以看到系统上有很多端口是打开的，端口`3306`就是其中之一。
- en: Since we know that the blog server is unable to establish a connection to port
    `3306`, we can once again test the connectivity from multiple places. The first
    place being the database server itself and the second being our laptop just as
    we did in [Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道博客服务器无法与端口`3306`建立连接，我们可以再次从多个地方测试连接。第一个地方是数据库服务器本身，第二个地方是我们的笔记本电脑，就像我们在[第5章](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "第5章。网络故障排除") *网络故障排除*中所做的那样。
- en: 'Since the database server does not have the `telnet` client installed, we can
    use the `curl` command to perform this test:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据库服务器没有安装`telnet`客户端，我们可以使用`curl`命令来执行这个测试：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: One thing I will say repeatedly in this book is that it is important to know
    more than one way to perform a task. `telnet` is a very simple example but this
    concept applies to every task you perform as a system administrator.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我会反复强调知道执行任务的多种方法是很重要的。`telnet`是一个非常简单的例子，但这个概念适用于系统管理员执行的每一个任务。
- en: 'Since we have established that the database server is accessible from the local
    server, we can now test this from our laptop:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确定了数据库服务器可以从本地服务器访问，我们现在可以从我们的笔记本电脑上测试：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It seems that from our laptop, the connection to the database service is unavailable,
    but what happens if we test another port such as `22`?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的笔记本电脑上看，连接到数据库服务是不可用的，但如果我们测试另一个端口，比如`22`会发生什么呢？
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is an interesting result; from the laptop, we are able to connect to port
    `22` but not port `3306`. Since port `22` is available on the laptop, what about
    from the blog server?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的结果；从笔记本电脑上，我们能够连接到端口`22`，但无法连接到端口`3306`。既然端口`22`在笔记本电脑上是可用的，那么在博客服务器上呢？
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These results are quite interesting. In the previous chapter, when our connectivity
    issue was due to a misconfigured static route, all communication between the blog
    server and the database server was broken.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果非常有趣。在上一章中，当我们的连接问题是由于错误配置的静态路由时，博客服务器和数据库服务器之间的所有通信都中断了。
- en: In the case of this issue, however, the blog server is unable to connect to
    port `3306`, but it is able to talk to the database server on port `22`. What
    makes this issue more interesting is that locally, on the database server, port
    `3306` is available and accepting connections.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个问题的情况下，博客服务器无法连接到端口`3306`，但它可以在端口`22`上与数据库服务器通信。使这个问题更有趣的是，在数据库服务器上本地，端口`3306`是可用的并且接受连接。
- en: These key pieces of information are the first signs to indicate that our issue
    might in fact be due to a firewall. It might be a little early for a Data Collector,
    but an Adaptor or Educated Guesser troubleshooter might already, at this point,
    form an hypothesis that this issue is due to a firewall.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关键信息是指示我们的问题可能实际上是由于防火墙引起的第一个迹象。现在可能还为时过早使用数据收集器，但是一个适配器或有经验的猜测故障排除者可能已经在这一点上形成了一个假设，即这个问题是由于防火墙引起的。
- en: Troubleshooting with tcpdump
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用tcpdump进行故障排除
- en: In [Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting*, we used `tcpdump`
    quite extensively to identify our issue; can we tell if the issue is a firewall
    issue with `tcpdump`? Maybe, we can certainly use `tcpdump` to get a better view
    of the issue.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4 "第5章。网络故障排除")
    *网络故障排除*中，我们广泛使用了`tcpdump`来识别我们的问题；我们能否用`tcpdump`来判断问题是防火墙问题？也许可以，我们肯定可以使用`tcpdump`来更好地查看问题。
- en: 'To start with, we will first capture connectivity to port `22` from the blog
    server (a connection that we know is working). The `tcpdump` will run on the database
    server filtering for port `22`; we will also use the `-i` (interface) flag with
    the `any` option to cause `tcpdump` to capture traffic on all network interfaces:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从博客服务器捕获到端口`22`的连接（我们知道这个连接是有效的）。`tcpdump`将在数据库服务器上过滤端口`22`运行；我们还将使用`-i`（接口）标志和`any`选项，使`tcpdump`捕获所有网络接口上的流量：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once `tcpdump` is running, we can initiate a connection to port `22` from the
    blog server to see what a full healthy connection looks like:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`tcpdump`运行起来，我们可以从博客服务器发起到端口`22`的连接，看看一个完整的健康连接是什么样子的：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From the captured data, we can see a standard healthy connection. We can see
    that the connection is coming from the IP `192.168.33.11`, the blog server''s
    IP. We can also see that the connection arrived on the IP `192.168.33.12` via
    port `22`. We can see all of this from the following line:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从捕获的数据中，我们可以看到一个标准的健康连接。我们可以看到连接来自IP`192.168.33.11`，即博客服务器的IP。我们还可以看到连接通过端口`22`到达了IP`192.168.33.12`。我们可以从以下行中看到所有这些信息：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'From the second captured packet, we can see the **SYN-ACK** reply from the
    database server to the blog server:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从第二个捕获的数据包中，我们可以看到数据库服务器对博客服务器的**SYN-ACK**回复：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can see that the `SYN-ACK` reply was from the `192.168.33.12` IP address
    to the `192.168.33.11` IP address. So far, the TCP connection seems normal, the
    third captured packet confirms this for sure:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`SYN-ACK`回复来自`192.168.33.12` IP地址到`192.168.33.11` IP地址。到目前为止，TCP连接似乎正常，第三个捕获的数据包肯定证实了这一点：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The third packet is a **SYN-ACK-ACK** from the blog server. This means that
    not only did the blog servers `SYN` packet arrive and get replied to with a `SYN-ACK`,
    the database servers `SYN-ACK` packet was received by the blog server and replied
    to with a `SYN-ACK-ACK`. This is a full three-way handshake for port `22`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个数据包是来自博客服务器的**SYN-ACK-ACK**。这意味着不仅博客服务器的`SYN`数据包到达并得到`SYN-ACK`的回复，数据库服务器的`SYN-ACK`数据包也被博客服务器接收，并得到了`SYN-ACK-ACK`的回复。这是端口`22`的完整三次握手。
- en: 'Now, let''s take a look at connectivity to port `3306`. To do this, we will
    use the same `tcpdump` command, this time changing the port to `3306`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看到端口`3306`的连接。为此，我们将使用相同的`tcpdump`命令，这次将端口更改为`3306`：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With `tcpdump` running, we can use `telnet` from the blog server to establish
    a connection:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`tcpdump`运行时，我们可以从博客服务器使用`telnet`建立连接：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As expected, the `telnet` command has failed to connect; let''s see if `tcpdump`
    captured any packets during this time:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`telnet`命令未能连接；让我们看看`tcpdump`在此期间是否捕获了任何数据包：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It seems in fact that `tcpdump` did capture a packet, but only one.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，看起来`tcpdump`确实捕获了一个数据包，但只有一个。
- en: The packet captured was a `SYN` packet sent from `192.168.33.11` (the blog server)
    to 192.168.33.12 (the database server). This shows that the packet from the blog
    server arrives on the database server; but what we don't see is a reply packet.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获的数据包是从`192.168.33.11`（博客服务器）发送到`192.168.33.12`（数据库服务器）的`SYN`数据包。这表明来自博客服务器的数据包到达了数据库服务器；但我们看不到回复数据包。
- en: 'As you learned in the previous chapter, when we apply filters to `tcpdump`,
    we often miss things. In this case, we are filtering `tcpdump` to look for traffic
    either from or to port `3306`. Since we know that the server in question is the
    blog server, we can change our filter to capture all traffic from the blog server
    IP; `192.168.33.11`. We can do this by using the host filter of `tcpdump`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一章中学到的，当我们对`tcpdump`应用过滤器时，我们经常会错过一些东西。在这种情况下，我们正在过滤`tcpdump`以查找从端口`3306`发送或接收的流量。由于我们知道问题的服务器是博客服务器，我们可以通过使用`tcpdump`的主机过滤器来更改我们的过滤器，以捕获来自博客服务器IP`192.168.33.11`的所有流量。我们可以通过使用`tcpdump`的主机过滤器来实现这一点：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With `tcpdump` running again, we can once again initiate a connection with
    a `telnet` from the blog server:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`tcpdump`，我们可以再次从博客服务器使用`telnet`发起连接：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Again, the telnet connection was expectedly unsuccessful; however, this time
    we can see quite a bit more from `tcpdump`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，预期地，telnet连接失败了；然而，这次我们可以从`tcpdump`中看到更多信息：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This time we can actually see quite a bit of useful information that directly
    indicates that our issue is due to the system firewall.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次我们实际上可以看到相当多有用的信息，直接表明我们的问题是由于系统防火墙引起的。
- en: 'It looks like `tcpdump` was able to capture two packets. Let''s break down
    what it was able to capture to get a better understanding of what is going on:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来`tcpdump`能够捕获两个数据包。让我们分析一下它能够捕获到的内容，以更好地理解发生了什么：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The first packet is the same as we saw before, a simple `SYN` request from
    the blog server to the database server on port `3306`. The second packet, however,
    is quite interesting:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数据包与我们之前看到的一样，是从博客服务器到数据库服务器端口`3306`的简单`SYN`请求。然而，第二个数据包非常有趣：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The second packet isn't even a TCP based packet but rather an **ICMP** packet.
    Earlier in [Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting*, we talked about
    ICMP echo request and reply packets and how they are used by the `ping` command
    to identify whether a host is available. ICMP, however, is used for more than
    the `ping` command.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个数据包甚至不是基于TCP的数据包，而是一个**ICMP**数据包。在[第5章](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "第5章。网络故障排除")*网络故障排除*中，我们讨论了ICMP回显请求和回复数据包，以及它们如何被`ping`命令用于识别主机是否可用。然而，ICMP用于的不仅仅是`ping`命令。
- en: Understanding ICMP
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解ICMP
- en: The ICMP protocol is used as a control protocol for sending messages across
    networks. The echo request and echo reply messages are just one example of this
    protocol. This protocol is also frequently used to notify other systems of errors.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP协议被用作跨网络发送消息的控制协议。回显请求和回显回复消息只是这种协议的一个例子。这种协议也经常用于通知其他系统的错误。
- en: 'In this case, the database server is sending an ICMP packet to the blog server,
    notifying it that the IP host 192.168.33.12 is unreachable:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数据库服务器正在向博客服务器发送一个ICMP数据包，通知它IP主机`192.168.33.12`无法访问：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Not only is the database server saying it is unreachable, it is also telling
    the blog server that the reason for the unreachable state is because the connection
    is administratively prohibited. This type of reply is a telltale sign of a firewall
    being the source of the connectivity issue, as often administratively prohibited
    is the type of message firewalls will utilize.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库服务器不仅说它是不可达的，还告诉博客服务器不可达的原因是因为连接被管理上禁止了。这种回复是防火墙是连接问题的来源的明显迹象，因为通常管理上禁止是防火墙会使用的消息类型。
- en: Understanding connection rejections
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解连接被拒绝
- en: When a TCP connection is made to a service that is unavailable or to a port
    that is not being listened to, the Linux kernel will send a reply. The reply,
    however, is a TCP Reset, which tells the remote system to reset the connection.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试连接到不可用的服务或未被监听的端口时，Linux内核会发送一个回复。然而，这个回复是一个TCP重置，告诉远程系统重置连接。
- en: 'We can see this in action by connecting to an invalid port while running `tcpdump`.
    On the blog server, port `5000` is not currently being used if we run a `tcpdump`.
    Using the `port` filter, we will see all of the traffic to and from that port:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在运行`tcpdump`时连接到无效端口，我们可以看到这一点。在博客服务器上，如果我们运行`tcpdump`，端口`5000`目前没有被使用。使用`port`过滤器，我们将看到所有到该端口的流量：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With `tcpdump`, capturing all traffic on port 5000, we can now use telnet to
    attempt a connection:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在端口5000上捕获所有流量，我们现在可以使用telnet尝试连接：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We actually can already see something different. Earlier, when we performed
    a `telnet` to port `3306` on the database server, the `telnet` command printed
    a different message:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上我们已经看到了一些不同的东西。之前，当我们在数据库服务器上对端口`3306`执行`telnet`时，`telnet`命令打印了不同的消息。
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The reason for this is because previously, when the telnet connection was performed,
    the server received an ICMP destination unavailable packet.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为之前进行telnet连接时，服务器收到了ICMP目的地不可达数据包。
- en: 'This time, however, a different reply was sent. We can see this reply in the
    captured packets by `tcpdump`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这次发送了不同的回复。我们可以在`tcpdump`捕获的数据包中看到这个回复：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This time, the packet being sent back was a TCP Reset:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，发送回来的数据包是一个TCP重置：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A **RESET** packet is, typically, what one would expect when the issue is due
    to simple connectivity errors, as this is the standard TCP response for situations
    where the client is attempting to connect to a port which is no longer available.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重置数据包通常是由于简单的连接错误导致的问题，因为这是客户端尝试连接不再可用的端口时的标准TCP响应。
- en: The RESET packet can also be sent by applications that are rejecting a connection.
    The ICMP destination unreachable, however, is typically the reply you will receive
    when the packet is being rejected by a firewall; that is, if the firewall service
    is configured to reply at all.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重置数据包也可以由拒绝连接的应用程序发送。然而，ICMP目的地不可达通常是防火墙拒绝数据包时会收到的回复；也就是说，如果防火墙服务配置为回复的话。
- en: A quick summary of what you have learned so far
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迄今为止你学到的内容的快速总结
- en: From our troubleshooting so far, we have identified that the blog server is
    able to establish a connection to the database server over port `22`. This connection
    is actually able to perform a full three-way handshake unlike our previous chapter.
    However, the blog server is not able to perform a three-way handshake with the
    database server over port `3306`, the database port.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经确定博客服务器能够通过端口`22`与数据库服务器建立连接。与我们之前的情况不同，这个连接实际上能够执行完整的三次握手。然而，博客服务器无法通过端口`3306`与数据库服务器执行三次握手。
- en: When the blog server attempts to establish a connection to the database server
    over port 3306, the database server is sending an ICMP destination unreachable
    packet back to the blog server. This packet is essentially telling the blog server
    that the connection attempt to the database is being rejected. Yet, the database
    service is up and listening on port 3306 (verified with `netstat`). In addition
    to the port being listened to, if we `telnet` to port 3306 locally, from the database
    server itself the connection is established.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当博客服务器尝试通过端口3306与数据库服务器建立连接时，数据库服务器会发送一个ICMP目的地不可达的数据包回到博客服务器。这个数据包实际上是告诉博客服务器，对数据库的连接尝试被拒绝了。然而，数据库服务是启动的，并且在端口3306上监听（通过`netstat`验证）。除了端口被监听外，如果我们从数据库服务器本身`telnet`到端口3306，连接是建立的。
- en: Given all of these data points, it is possible that the database server might
    have the firewall service enabled and blocking connections to port 3306.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些数据点，可能是数据库服务器启用了防火墙服务并阻止了对端口3306的连接。
- en: Managing the Linux firewall with iptables
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用iptables管理Linux防火墙
- en: When it comes to managing the firewall service within Linux, there are many
    options, the most popular being `iptables` and `ufw`. For Ubuntu distributions,
    `ufw` is the default firewall management tool; however, overall, `iptables` is
    by far the most popular across multiple Linux distributions. Both of these, however,
    in themselves, are simply user interfaces to **Netfilter**.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理Linux中的防火墙服务时，有许多选项，最流行的是`iptables`和`ufw`。对于Ubuntu发行版，`ufw`是默认的防火墙管理工具；然而，总体而言，`iptables`是跨多个Linux发行版中最流行的。然而，这两者本身只是**Netfilter**的用户界面。
- en: Netfilter is a framework within the Linux kernel that allows for packet filtering
    as well as network and port translation. Tools such as the `iptables` command
    are simply interacting with the `netfilter` framework to apply these rules.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Netfilter是Linux内核中的一个框架，允许数据包过滤以及网络和端口转换。诸如`iptables`命令之类的工具只是与`netfilter`框架交互，以应用这些规则。
- en: For this book, we will concentrate on utilizing the `iptables` command and service
    to manage our firewall rules. Not only is it the most popular firewall tool, it
    has also been the default firewall service for Red Hat based operating systems
    for quite a while. Even with the newer `firewalld` service arriving in Red Hat
    Enterprise Linux 7, this is simply a service to manage `iptables`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将集中在使用`iptables`命令和服务来管理我们的防火墙规则。它不仅是最流行的防火墙工具，而且在基于Red Hat的操作系统中已经是默认的防火墙服务很长一段时间了。即使在Red
    Hat Enterprise Linux 7中出现了更新的`firewalld`服务，这只是一个管理`iptables`的服务。
- en: Verify that iptables is running
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证iptables是否在运行
- en: 'Since we suspect that our issue is due to the system''s firewall configuration,
    we should first check to see whether the firewall is running and what rules are
    defined. Since `iptables` runs as a service, the first step is to simply check
    that service''s status:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们怀疑问题是由系统防火墙配置引起的，我们应该首先检查防火墙是否正在运行以及定义了什么规则。由于`iptables`作为一个服务运行，第一步就是简单地检查该服务的状态：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Previously, when we went to check whether a service is running, we would simply
    use the `ps` command. This works great for services such as MariaDB or Apache;
    `iptables`, however, is different. Since `iptables` is simply a command that interacts
    with `netfilter`, the `iptables` service is not a daemon process like most other
    services. In fact, when you start the `iptables` service you are simply applying
    saved `netfilter` rules, and when you stop the service, you are simply flushing
    those rules. We will explore this concept a little later in the chapter but for
    now we will simply check whether the `iptables` service is running using the service
    command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，当我们去检查一个服务是否在运行时，我们通常会使用`ps`命令。这对于MariaDB或Apache等服务非常有效；然而，`iptables`是不同的。因为`iptables`只是一个与`netfilter`交互的命令，`iptables`服务不像大多数其他服务那样是一个守护进程。事实上，当你启动`iptables`服务时，你只是应用了保存的`netfilter`规则，当你停止服务时，你只是刷新了这些规则。我们将在本章稍后探讨这个概念，但现在我们只是检查`iptables`服务是否在运行：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With the Red Hat Enterprise Linux 7 release, Red Hat has migrated to `systemd`,
    which replaces the standard `init` system. With this migration, the service command
    is no longer the preferred command to manage services. This functionality has
    moved the control command for `systemd` to the `systemctl` command.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Red Hat Enterprise Linux 7的发布，Red Hat已经迁移到了`systemd`，它取代了标准的`init`系统。随着这一迁移，服务命令不再是管理服务的首选命令。这个功能已经将`systemd`的控制命令移动到了`systemctl`命令。
- en: 'For RHEL 7, at least the `service` command is still executable; however, this
    command is simply a wrapper to `systemctl`. Here is the command to check the status
    of the `iptables` service with the `systemctl` command. For this book, we will
    utilize the `systemctl` commands rather than the legacy service command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于RHEL 7，至少`service`命令仍然可以执行；然而，这个命令只是`systemctl`的一个包装器。以下是使用`systemctl`命令检查`iptables`服务状态的命令。在本书中，我们将使用`systemctl`命令而不是传统的service命令：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'From the preceding output of `systemctl`, we can see that currently the `iptables`
    service is active. We can identify this from the 3rd line of the `systemctl` output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的`systemctl`输出中，我们可以看到当前`iptables`服务是活动的。我们可以从`systemctl`输出的第三行来识别这一点：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When the `iptables` service is not running, things look quite a bit different:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当`iptables`服务没有运行时，情况看起来会有很大不同：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'From the preceding example, `systemctl` shows the `iptables` service as inactive:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的例子中，`systemctl`显示`iptables`服务处于非活动状态：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'One of the nice things about `systemctl` is that when running with the status
    option, the output includes log messages from the service:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemctl`的一个好处是，在使用状态选项运行时，输出包括来自服务的日志消息：'
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: From the preceding code, we can see all of the status messages used by the stop
    process for the `iptables` service.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的代码中，我们可以看到`iptables`服务停止过程中使用的所有状态消息。
- en: Show iptables rules being enforced
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示正在执行的iptables规则
- en: 'Now that we know that the `iptables` service is *Active* and running, we should
    also look at the `iptables` rules that are defined and being enforced. To do this,
    we will use the `iptables` command with the `–L` (list) and `–n` (numeric) flags:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道`iptables`服务是*活动*和运行的，我们还应该查看已定义和正在执行的`iptables`规则。为此，我们将使用`iptables`命令和`-L`（列表）和`-n`（数字）标志：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When executing `iptables`, the flags `–L` and `–n` are not combined. Unlike
    most other commands, `iptables` has a specific format that requires some flags
    to be separated from others. In this case, the `–L` flag is separated from the
    rest of the options. We could add the `–v` (verbose) option to the `–n` but not
    to the `–L`. The following is an example of executing with the verbose option:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`iptables`时，标志`-L`和`-n`不会合并。与大多数其他命令不同，`iptables`有一个特定的格式，需要一些标志与其他标志分开。在这种情况下，`-L`标志与其他选项分开。我们可以给`-n`添加`-v`（详细）选项，但不能添加`-L`。以下是使用详细选项执行的示例：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It seems from the output of `iptables -L -n` that there are quite a few `iptables`
    rules in place on this server. Let's break down these rules in order to understand
    them better.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从`iptables -L -n`的输出中，似乎在这台服务器上有相当多的`iptables`规则。让我们分解这些规则，以便更好地理解它们。
- en: Understanding iptables rules
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解iptables规则
- en: Before we get into the individual rules, we should first cover a few general
    rules of `iptables` and firewalls.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入单个规则之前，我们应该首先了解一下`iptables`和防火墙的一些一般规则。
- en: Ordering matters
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顺序很重要
- en: The first important rule to know is that ordering matters. If we look at the
    data returned by `iptables -L -n`, we could see that there are multiple rules,
    the order of which those rules are in determines how that rule is interpreted.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道的第一个重要规则是顺序很重要。如果我们查看`iptables -L -n`返回的数据，我们可以看到有多个规则，这些规则的顺序决定了如何解释这些规则。
- en: I like to think of `iptables` as a checklist; when a packet is received `iptables`
    will go through the checklist from top to bottom. When it finds a rule that matches
    the condition, it applies that rule.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢把`iptables`想象成一个清单；当接收到一个数据包时，`iptables`会从上到下检查清单。当它找到一个符合条件的规则时，就会应用该规则。
- en: This is one of the most common mistakes people make when using `iptables`, putting
    rules outside of the top to bottom order.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是人们在使用`iptables`时经常犯的一个最常见的错误，即在从上到下的顺序之外放置规则。
- en: Default policies
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认策略
- en: In general, `iptables` is used in two ways, either all traffic unless specifically
    blocked is allowed, or all traffic unless specifically allowed is blocked. These
    methodologies are called a **default allow** and **default deny** policy.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，`iptables`有两种用法，即除非明确阻止，否则允许所有流量，或者除非明确允许，否则阻止所有流量。这些方法被称为**默认允许**和**默认拒绝**策略。
- en: It is acceptable to use either policy depending on the desired use of the Linux
    firewall. In general however, the default deny policy is often considered the
    more secure approach, as this policy requires a rule to be added for each type
    of access required for the server in question.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Linux防火墙的期望用途，可以使用任一策略。然而，通常情况下，默认拒绝策略被认为是更安全的方法，因为这个策略要求为所讨论的服务器的每种访问类型添加一条规则。
- en: Breaking down the iptables rules
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分解iptables规则
- en: 'Since `iptables` processes rules from the top down, to better understand the
    rules in place we are going to take a look at the `iptables` rules from the bottom
    up:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`iptables`从上到下处理规则，为了更好地理解现有的规则，我们将从下到上查看`iptables`规则：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first rule we see says `REJECT` all protocols from any source to any destination
    for the `FORWARD` chain. Does this mean that `iptables` is going to block everything?
    Yes, but only for packets that are being forwarded.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的第一条规则是`FORWARD`链的所有协议从任何源到任何目的地进行`REJECT`。这是否意味着`iptables`将阻止所有东西？是的，但只针对正在转发的数据包。
- en: The `iptables` command categorizes network traffic types into tables and chains.
    Tables consist of the high-level operations being performed such as filtering,
    network address translation, or altering packets.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`iptables`命令将网络流量类型分类为表和链。表包括正在执行的高级操作，如过滤、网络地址转换或更改数据包。'
- en: Within each table, there are also several "chains". The chains are used to define
    the type of traffic to apply the rule to. In the case of the `FORWARD` chain,
    this matches traffic that is being forwarded, which is commonly used for routing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个表中，还有几个“链”。链用于定义要应用规则的流量类型。在`FORWARD`链的情况下，这匹配正在转发的流量，通常用于路由。
- en: 'The next chain with rules applied is the `INPUT` chain:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 应用规则的下一个链是`INPUT`链：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This chain applies to traffic that is incoming to the local system; essentially,
    these rules are only applied to traffic that is arriving on the system:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个链适用于进入本地系统的流量；基本上，这些规则只适用于到达系统的流量：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If we look at the last rule in the chain, we can see that it specifically defines
    that the system should `ACCEPT` TCP traffic with a source IP within the `192.168.0.0/16`
    network and a destination IP of 0.0.0.0/0, which like with `netstat` is a wildcard.
    The last part of this rule defines that this rule applies only to new connections
    with a destination port of `3306`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看链中的最后一条规则，我们可以看到它明确定义了系统应该接受源IP在`192.168.0.0/16`网络中，目标IP为0.0.0.0/0的TCP流量，就像`netstat`一样是一个通配符。这条规则的最后部分定义了这条规则仅适用于目标端口为`3306`的新连接。
- en: To put it simply, this rule would have the effect of allowing any IP within
    the 192.168.0.0/16 network to access port 3306 on any of the database servers
    local IPs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，这条规则将允许192.168.0.0/16网络中的任何IP访问数据库服务器的任何本地IP的3306端口。
- en: This rule in particular should allow traffic from our blog server (192.168.33.11),
    but what about the rule above it?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是这条规则应该允许来自我们博客服务器（192.168.33.11）的流量，但是上面的规则呢？
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding rule specifically states that the system should `REJECT` all protocols
    from a source IP of `0.0.0.0/0` to a destination IP of `0.0.0.0/0` and reply with
    an ICMP packet that says the host is prohibited. From our earlier network troubleshooting,
    we know that the `0.0.0.0/0` network is a wildcard for all networks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的规则明确规定系统应该从源IP为`0.0.0.0/0`到目标IP为`0.0.0.0/0`的所有协议进行`REJECT`，并回复一个ICMP数据包，说明主机被禁止。根据我们之前的网络故障排除，我们知道`0.0.0.0/0`网络是所有网络的通配符。
- en: This means that this rule will `REJECT` all traffic to the system, effectively
    making our system use a "default deny" policy. However, this isn't really the
    common method of defining a "default deny" policy.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着这条规则将拒绝所有流量到系统，有效地使我们的系统使用“默认拒绝”策略。然而，这并不是定义“默认拒绝”策略的常见方法。
- en: 'If we look at the top of this chain''s ruleset, we will see the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看这个链规则集的顶部，我们会看到以下内容：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is essentially saying that the `INPUT` chain itself has an `ACCEPT` policy,
    which means the chain itself is using a "default allow" policy. However, there
    is a rule in this chain that will `REJECT` all traffic.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上是说`INPUT`链本身具有`ACCEPT`策略，这意味着链本身使用“默认允许”策略。但是，这个链中有一条规则将拒绝所有流量。
- en: This means that while the chain's policy is not technically default deny, this
    rule effectively accomplishes the same thing. Unless traffic is specifically allowed
    before this rule, the traffic will be denied, effectively making the chain a "default
    deny" policy.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，虽然链的策略在技术上不是默认拒绝，但这条规则实际上实现了相同的效果。除非在此规则之前明确允许流量，否则流量将被拒绝，有效地使链成为“默认拒绝”策略。
- en: At this point, we have an interesting problem; the last rule in the `INPUT`
    chain specifically allows traffic to port 3306 (the `MariaDB` port) from the source
    network of 192.168.0.0/16\. However, the rule above that denies all traffic from
    anywhere to anywhere. If we take a second to remember that `iptables` is order
    based, then we can easily see that this might be a problem.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们有一个有趣的问题；`INPUT`链中的最后一条规则明确允许从192.168.0.0/16源网络到3306端口（`MariaDB`端口）的流量。然而，上面的规则拒绝了从任何地方到任何地方的所有流量。如果我们花一点时间记住`iptables`是基于顺序的，那么我们很容易看出这可能是一个问题。
- en: The issue might simply be that the rule to allow port 3306 is defined after
    a rule that blocks all traffic; essentially, the database traffic is being blocked
    by the default deny rule.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 问题可能只是允许端口3306的规则是在阻止所有流量的规则之后定义的；基本上，数据库流量被默认拒绝规则阻止。
- en: 'Before we start acting on this information, however, we should continue looking
    at the `iptables` rules as there could be another rule defined that counters the
    two bottom rules:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们根据这些信息采取行动之前，我们应该继续查看`iptables`规则，因为可能还有另一条规则定义了对抗这两条底部规则的规则：
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The third from the last rule in the `INPUT` chain does explain why SSH traffic
    is working as expected. This rule specifically states that the system should `ACCEPT`
    all TCP protocol traffic from any source to any destination when the connection
    is a new connection destined for port `22`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`INPUT`链中倒数第三条规则确实解释了为什么SSH流量按预期工作。该规则明确说明，当连接是针对端口`22`的新连接时，系统应该从任何来源到任何目的地接受所有TCP协议流量。'
- en: This rule essentially defines that all new TCP connections to port `22` are
    allowed. Since it is before the default deny rule, this means that in no circumstance
    would new connections to port `22` be blocked by that rule.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则基本上定义了所有新的TCP连接到端口`22`都是允许的。由于它在默认拒绝规则之前，这意味着在任何情况下都不会被该规则阻止端口`22`的新连接。
- en: 'If we look at the fourth from the last rule in the `INPUT` chain, we see a
    very interesting rule:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`INPUT`链中倒数第四条规则，我们会看到一条非常有趣的规则：
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This rule appears to tell the system to `ACCEPT` all protocols from any IP (`0.0.0.0/0`)
    to any IP (`0.0.0.0/0`). If we look at this rule and apply the logic that ordering
    matters; then this rule should allow our database traffic.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则似乎告诉系统应该从任何IP（`0.0.0.0/0`）接受所有协议到任何IP（`0.0.0.0/0`）。如果我们查看这条规则并应用顺序很重要的逻辑；那么这条规则应该允许我们的数据库流量。
- en: 'Unfortunately, the `iptables` output can sometimes be misleading, as this rule
    is not showing a critical piece of the rule; the interface:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`iptables`输出有时可能会误导，因为这条规则没有显示规则的一个关键部分；接口：
- en: '[PRE44]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we add the `–v` (verbose) flag to the `iptables` command, we can see quite
    a bit more information. In particular, we can see a new column named "in", which
    stands for interface:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`iptables`命令中添加`-v`（详细）标志，我们可以看到更多信息。特别是，我们可以看到一个名为“in”的新列，它代表接口：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If we take a second look at this same rule, we can see that the interface column
    shows that this rule only applies to traffic on the `loopback` interface. Since
    our database traffic is on the `enp0s8` interface, the database traffic does not
    match this rule:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再仔细看一下这条规则，我们会发现接口列显示该规则仅适用于`loopback`接口上的流量。由于我们的数据库流量是在`enp0s8`接口上的，数据库流量不符合这条规则：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The fifth from the last rule is very similar, except that it specifically allows
    all ICMP traffic from any IP to any IP. This explains why our **ping** requests
    are working as this rule will allow the ICMP echo request and echo reply through
    the firewall.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 倒数第五条规则非常相似，只是它专门允许从任何IP到任何IP的所有ICMP流量。这解释了为什么我们的**ping**请求有效，因为这条规则将允许ICMP回显请求和回显回复通过防火墙。
- en: 'The sixth from the last rule, however, is quite a bit different from the others:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，倒数第六条规则与其他规则有很大不同：
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This rule does state that the system should `ACCEPT` all protocols from any
    IP (0.0.0.0/0) to any IP (0.0.0.0/0); but the rule is limited to only `RELATED`
    and `ESTABLISHED` packets.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这条规则确实说明系统应该从任何IP（0.0.0.0/0）接受所有协议到任何IP（0.0.0.0/0）；但是该规则仅限于`RELATED`和`ESTABLISHED`数据包。
- en: Earlier, while reviewing the `iptables` rule for port `22`, we could see that
    the rule is limited to `NEW` connections. This essentially means that packets
    that are used to start a new connection to port `22` such as a `SYN` and `SYN-ACK-ACK`
    are allowed.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查端口`22`的`iptables`规则时，我们可以看到该规则仅限于`NEW`连接。这基本上意味着用于启动到端口`22`的新连接的数据包，如`SYN`和`SYN-ACK-ACK`是允许的。
- en: 'When the rule states that the `ESTABLISHED` state is allowed, `iptables` will
    allow packets that are part of an established TCP connection:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当规则说明`ESTABLISHED`状态被允许时，`iptables`将允许属于已建立的TCP连接的数据包：
- en: This means that new SSH connections are allowed by the rule for port `22`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着新的SSH连接是由端口`22`的规则允许的。
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, once the TCP connection is established it is allowed by the following
    rule:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦TCP连接建立，它将被以下规则允许：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Putting the rules together
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整合规则
- en: Now that we have looked at all of the `iptables` rules, we can make an educated
    guess as to why our database traffic is not working.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了所有的`iptables`规则，我们可以对为什么我们的数据库流量无法工作做出合理的猜测。
- en: 'In the `iptables` ruleset, we can see that the rule to reject all traffic is
    defined before the rule to allow database connectivity on port **3306**:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`iptables`规则集中，我们可以看到拒绝所有流量的规则在允许端口**3306**上的数据库连接之前被定义：
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Since systems are unable to start new connections, they are not able to become
    established, which would be allowed by the following rule:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 由于系统无法启动新连接，它们无法建立连接，这将被以下规则允许：
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can determine all of this by looking at the rules defined, but this also
    requires a pretty versed knowledge of `iptables`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看定义的规则来确定所有这些，但这也需要对`iptables`有相当了解。
- en: There is another somewhat easier way to determine which rules are blocking or
    allowing traffic.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种相对较简单的方法来确定哪些规则正在阻止或允许流量。
- en: Viewing iptables counters
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看iptables计数器
- en: 'With the verbose output of `iptables`, we not only see the interface the rule
    applies to, but we also see two additional columns that are very useful. Those
    two columns are **pkts** and **bytes**:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`iptables`的详细输出，我们不仅可以看到规则适用的接口，还可以看到两列非常有用。这两列是**pkts**和**bytes**：
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `pkts` column is the first column in the verbose output of `iptables`, this
    column contains the number of packets the rule has been applied to. If we look
    at the preceding rule, we can see that this rule has been applied to `41` packets.
    The `bytes` column is the second column and is used to denote the number of bytes
    that the rule has been applied to. For our preceding example, the rule has been
    applied to 2,360 bytes.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkts`列是`iptables`详细输出中的第一列，该列包含规则应用的数据包数。如果我们看前面的规则，我们可以看到这条规则已经应用于`41`个数据包。`bytes`列是第二列，用于表示规则应用的字节数。对于我们前面的例子，该规则已经应用了2,360字节。'
- en: 'We can use the packet and byte counters in `iptables` to identify which rules
    are being applied to our database traffic. To do this, we simply need to trigger
    database activity by refreshing our browser and running `iptables –L –nv` to identify
    which rules had their counters increased. We can even make this easier by clearing
    out the current values with the `iptables` command followed by the `–Z` (zero)
    flag:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`iptables`中的数据包和字节计数器来识别应用于我们的数据库流量的规则。为此，我们只需要通过刷新浏览器并运行`iptables –L
    –nv`来触发数据库活动，以识别哪些规则的计数器增加了。我们甚至可以通过使用`iptables`命令后跟`–Z`（清零）标志来清除当前值，使这更加容易：
- en: '[PRE53]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we re-execute the verbose listing for `iptables`, we can see that the counters
    are `0` for everything except the `ESTABLISHED` and `RELATED` rule (a rule that
    every connection will match, including our SSH session):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新执行`iptables`的详细列表，我们可以看到计数器对于除了`ESTABLISHED`和`RELATED`规则（每个连接都会匹配的规则，包括我们的SSH会话）之外的所有内容都是`0`：
- en: '[PRE54]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'After clearing these values, we can now refresh our web browser and initiate
    some database traffic:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 清除这些值后，我们现在可以刷新我们的网络浏览器并启动一些数据库流量：
- en: '[PRE55]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If we run `iptables –L` in the verbose mode again, we can see that in fact as
    we suspected the packets are being rejected by the default deny rule. We can see
    this by the fact that this rule has now rejected `45` packets since we used the
    `–Z` flag to zero the counters.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次以详细模式运行`iptables –L`，我们可以看到，事实上，正如我们所怀疑的，数据包被默认的拒绝规则拒绝了。我们可以通过这个事实看到，自从我们使用`–Z`标志将计数器清零以来，这条规则已经拒绝了`45`个数据包。
- en: Using the `-Z` flag and counters is a very useful method; however, it might
    not work in all cases. On busy systems and systems with many rules, it might be
    difficult to solely use counters to show which rules are being matched. For this
    reason, it is important to build an experience with `iptables`, understanding
    its intricacies.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-Z`标志和计数器是一种非常有用的方法；然而，在某些情况下可能不起作用。在繁忙的系统和规则众多的系统上，仅仅使用计数器来显示匹配的规则可能会很困难。因此，重要的是要建立对`iptables`的经验，了解其复杂性。
- en: Correcting the iptables rule ordering
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纠正iptables规则排序
- en: Changing `iptables` can be a bit tricky, not because it is difficult to use
    (though the command syntax is a bit complex), but because there are two steps
    for modifying `iptables` rules. If one step is forgotten (which it often is),
    then the issue can persist unexpectedly.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`iptables`可能有点棘手，不是因为它难以使用（尽管命令语法有点复杂），而是因为修改`iptables`规则有两个步骤。如果忘记了其中一步（这经常发生），问题可能会意外地持续存在。
- en: How iptables rules are applied
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: iptables规则的应用方式
- en: When the `iptables` service is started, the start script doesn't start a daemon
    like other services on the system. What the `iptables` service does is simply
    apply the rules that are defined within a saved rules file (`/etc/sysconfig/iptables`).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当`iptables`服务启动时，启动脚本不会像系统上的其他服务那样启动守护进程。`iptables`服务所做的就是简单地应用保存规则文件（`/etc/sysconfig/iptables`）中定义的规则。
- en: These rules are then loaded in the memory, and they become active rules. This
    means that if we were to simply reorder the rules in memory but not modify the
    saved file, the next time the server rebooted, our changes would be lost.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这些规则被加载到内存中，它们成为活动规则。这意味着，如果我们只是重新排列内存中的规则，而不修改保存的文件，下次服务器重新启动时，我们的更改将会丢失。
- en: On the flip side, if we only modified the saved file but did not reorder the
    `iptables` rules in memory, our changes will not take effect until the next time
    the `iptables` service is restarted.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们只修改了保存的文件，但没有重新排列内存中的`iptables`规则，我们的更改将不会生效，直到下一次重新启动`iptables`服务。
- en: I've seen both of these situations occur somewhat frequently, where someone
    simply forgot one or the other step. This situation caused even more complication
    for the issue they were working.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我经常看到这两种情况发生，有人简单地忘记了其中一步。这种情况会给他们正在处理的问题带来更多的复杂性。
- en: Modifying iptables rules
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改iptables规则
- en: For this scenario, we will choose a simple method to both execute and remember.
    We will first edit the `/etc/sysconfig/iptables` file, which holds all of the
    defined `iptables` rules. Then restart the `iptables` service, which will cause
    the current rules to be flushed and the new rules in the `/etc/sysconfig/iptables`
    file to be applied.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，我们将选择一种既执行又易于记忆的简单方法。我们首先编辑`/etc/sysconfig/iptables`文件，其中包含所有定义的`iptables`规则。然后重新启动`iptables`服务，这将导致当前规则被清除，并应用`/etc/sysconfig/iptables`文件中的新规则。
- en: 'To edit the `iptables` file, we can simply use `vi`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑`iptables`文件，我们可以简单地使用`vi`：
- en: '[PRE56]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The contents of this file are a bit different than the output of `iptables
    -L`. The preceding rules are actually just options that can be appended to the
    `iptables` command. For example, if we wanted to add a rule that allows traffic
    to port 22, we can simply copy and paste the preceding rule with `-dport 22` with
    the `iptables` command prepended. The following is an example of what that command
    would look like:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的内容与`iptables -L`的输出有些不同。前面的规则实际上只是可以附加到`iptables`命令的选项。例如，如果我们想要添加一个允许流量到端口22的规则，我们可以简单地复制并粘贴前面的规则，加上`-dport
    22`，并在前面加上`iptables`命令。以下是这个命令的示例：
- en: '[PRE57]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: When the `iptables` service scripts are adding the `iptables` rules, they also
    simply append these rules to the `iptables` command.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当`iptables`服务脚本添加`iptables`规则时，它们也只是简单地将这些规则附加到`iptables`命令上。
- en: 'From the contents of the `iptables` file, we can see the two rules that need
    to be reordered:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从`iptables`文件的内容中，我们可以看到需要重新排序的两个规则：
- en: '[PRE58]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In order to resolve our issue, we can simply change these two rules to match
    the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决我们的问题，我们只需将这两个规则更改为以下内容：
- en: '[PRE59]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Once the change is made, we can **save** and **quit** the file by pressing *Esc*
    then `:wq in vi`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 更改完成后，我们可以通过按*Esc*然后在vi中输入`:wq`来**保存**并**退出**文件。
- en: Testing our changes
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试我们的更改
- en: Now that the file is saved, we should be able to simply restart the `iptables`
    service and the rules will be applied. The only problem is, what if we didn't
    edit our `iptables` file correctly?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在文件已保存，我们应该可以简单地重新启动`iptables`服务，规则将生效。唯一的问题是，如果我们没有正确编辑`iptables`文件会怎么样？
- en: Our current `iptables` configuration has a rule that blocks all traffic except
    for connections that are allowed by the rules above it. What if we accidently
    placed that rule before the rule that allows port 22? This would mean that when
    we restart the `iptables` service, we will no longer be able to establish SSH
    connections, and since that is our only method for managing this server, that
    simple mistake could have serious consequences.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的`iptables`配置有一个规则，阻止除了上面允许的连接之外的所有流量。如果我们不小心将该规则放在允许端口22之前会怎么样？这意味着当我们重新启动`iptables`服务时，我们将无法建立SSH连接，而且由于这是我们管理此服务器的唯一方法，这个简单的错误可能会产生严重后果。
- en: Caution should always be exercised when making changes to `iptables`. Even when
    simply restarting the `iptables` service, it is always best to look through the
    saved rules in `/etc/sysconfig/iptables` to ensure that there are no unexpected
    changes that will lock users and yourself out of managing the system.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`iptables`进行更改时，应始终谨慎。即使只是重新启动`iptables`服务，最好还是查看`/etc/sysconfig/iptables`中保存的规则，以确保没有意外的更改会将用户和您自己锁定在管理系统之外。
- en: To help avoid this situation, we can use the `screen` command. The `screen`
    command is used to open up pseudo terminals that will continue even if our SSH
    session is disconnected. This is true even if the disconnection is due to firewall
    changes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，我们可以使用`screen`命令。`screen`命令用于打开伪终端，即使我们的SSH会话断开，它也会继续运行。即使断开是由于防火墙更改引起的。
- en: 'To start the screen, we will simply execute the command `screen`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动`screen`，我们只需执行命令`screen`：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Once we are within the `screen` session, we are going to do a bit more than
    simply restart `iptables`. We are actually going to write out a `bash` one-liner
    that restarts `iptables`, prints the output to the screen to let us know our session
    still works, waits for two minutes, then finally stops the `iptables` service:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们进入`screen`会话，我们将做的不仅仅是重新启动`iptables`。我们实际上将编写一个`bash`一行命令，重新启动`iptables`，将输出打印到屏幕上，以确保我们的会话仍然有效，等待两分钟，然后最终停止`iptables`服务：
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: When we run this command, we will see either one of two things, either our SSH
    session will close, which likely means we have an error in our `iptables` rules,
    or we will see a message on our screen that says **still here?**.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此命令时，我们将看到两种情况中的一种，要么我们的SSH会话将关闭，这很可能意味着我们的`iptables`规则中有错误，要么我们将在屏幕上看到一条消息，上面写着**还在这里吗？**。
- en: 'If we see the **still here?** message, this means our `iptables` rules did
    not lock out our SSH session:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看到**还在这里吗？**的消息，这意味着我们的`iptables`规则没有锁定我们的SSH会话：
- en: '[PRE62]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Since the command finished and our SSH session did not terminate, we can now
    simply restart `iptables` with the comfort of knowing that we will not be locked
    out.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于命令已完成且我们的SSH会话未终止，我们现在可以简单地重新启动`iptables`，而不用担心被锁定在外面。
- en: Tip
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is always a good idea to establish a new SSH session when the rules are in
    place without ending the previous SSH session. This verifies that you can initiate
    new SSH sessions, and if it does not work, you still have the old SSH session
    alive to resolve the issue.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在规则生效后建立新的SSH会话总是一个好主意，而不是结束之前的SSH会话。这可以验证您是否可以发起新的SSH会话，如果不起作用，您仍然可以使用旧的SSH会话来解决问题。
- en: 'When we restart `iptables` this time, our new rules will be in place:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这次重新启动`iptables`时，我们的新规则将生效：
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now, we can see that the rule to accept port `3306` traffic is in front of the
    default deny rule. If we refresh our browser, we can also validate that the `iptables`
    change corrected the issue.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到接受端口`3306`流量的规则在默认拒绝规则之前。如果我们刷新浏览器，我们还可以验证`iptables`的更改是否纠正了问题。
- en: '![Testing our changes](img/00008.jpeg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![测试我们的更改](img/00008.jpeg)'
- en: Which it seems, it has!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来是这样的！
- en: 'If we take another look at the `iptables` listing in the verbose mode, we can
    also see how well our rule is being matched:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看详细模式下的`iptables`列表，我们还可以看到我们的规则匹配得有多好：
- en: '[PRE64]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: From the statistics in `iptables`, we can see that two packets have matched
    our rule now. This combined with the working website means that our minor correction
    on ordering made a huge difference on what `iptables` allows or denies.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 从`iptables`的统计数据中，我们可以看到有两个数据包匹配了我们的规则。这与网站的正常运行一起，意味着我们对规则进行的微小更改对`iptables`允许或拒绝的内容产生了巨大影响。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we experienced what seemed like a simple networking issue with
    our blog application connecting to its database. In our data collection phase,
    we used commands such as `netstat` and `tcpdump` to inspect the network packets
    and quickly discovered that the blog server was receiving an ICMP packet indicating
    that the database server is rejecting the blog server's TCP packets.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们遇到了一个看似简单的网络问题，即我们的博客应用程序连接到其数据库。在数据收集阶段，我们使用了诸如`netstat`和`tcpdump`之类的命令来检查网络数据包，并很快发现博客服务器收到了一个ICMP数据包，表明数据库服务器拒绝了博客服务器的TCP数据包。
- en: From that point, we suspected the issue was a firewall issue, which after investigating
    with the `iptables` command we noticed that the firewall rules were out of order.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，我们怀疑问题是防火墙问题，经过使用`iptables`命令调查后，我们注意到防火墙规则是无序的。
- en: Afterwards, we were able to use the *trial and error* stage to resolve the issue.
    This specific issue is a very common issue, something that I personally have seen
    in many different environments. This is mostly due to lack of knowledge around
    how `iptables` works and how to define rules properly. While this chapter only
    covered one type of misconfiguration within `iptables`, the general troubleshooting
    methods used within this chapter can be applied to most cases.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们能够使用“试错”阶段来解决问题。这个特定的问题是一个非常常见的问题，我个人在许多不同的环境中都见过。这主要是由于对`iptables`的工作原理以及如何正确定义规则的知识不足。虽然本章只涵盖了`iptables`中一种类型的配置错误，但本章中使用的一般故障排除方法可以应用于大多数情况。
- en: In [Chapter 7](part0044_split_000.html#19UOO2-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 7. Filesystem Errors and Recovery"), *FileSystem Errors and Recovery*,
    we will start exploring file system errors and how to recover from them—a tricky
    topic where one wrong command could mean data loss, something no systems administrator
    wants to see.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](part0044_split_000.html#19UOO2-8ae10833f0c4428b9e1482c7fee089b4 "第7章。文件系统错误和恢复")中，《文件系统错误和恢复》，我们将开始探讨文件系统错误以及如何从中恢复
    - 这是一个棘手的话题，一个错误的命令可能意味着数据丢失，这是任何系统管理员都不想看到的。
