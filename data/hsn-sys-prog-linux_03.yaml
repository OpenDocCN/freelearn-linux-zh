- en: Resource Limits
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源限制
- en: In this chapter, we will look at per-process resource limits—what they are,
    and why we require them. We will go on to describe the granularity and the types
    of resource limits, distinguishing between soft and hard limits. Details on how
    a user (or system administrator) can query and set the per-process resource limits
    using appropriate CLI frontends (`ulimit`, `prlimit`) will be covered.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究每个进程的资源限制——它们是什么，以及为什么我们需要它们。我们将继续描述资源限制的粒度和类型，区分软限制和硬限制。将介绍用户（或系统管理员）如何使用适当的CLI前端（`ulimit`，`prlimit`）查询和设置每个进程的资源限制的详细信息。
- en: The programming interfaces (APIs)—practically speaking, the key `prlimit(2)`
    system call API—will be covered in detail. Two detailed code examples, querying
    the limits and setting a limit on CPU usage, will give the reader hands-on experience
    of working with resource limits.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 编程接口（API）——实际上是关键的`prlimit(2)`系统调用API——将被详细介绍。两个详细的代码示例，查询限制和设置CPU使用限制，将使读者有机会亲自体验资源限制的工作。
- en: 'In this chapter, with regard to resource limits, we will cover the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，关于资源限制，我们将涵盖以下主题：
- en: Necessity
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必要性
- en: Granularity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒度
- en: Types—soft and hard
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型——软限制和硬限制
- en: The resource limits APIs, with example code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源限制API，带有示例代码
- en: Resource limits
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源限制
- en: A common hack is the **(Distributed) denial-of-service** (**(D)DoS**) attack.
    Here, the malicious attacker attempts to consume, indeed overload, resources on
    the target system to such an extent that the system either crashes, or at the
    very least, becomes completely unresponsive (hung).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的黑客攻击是**（分布式）拒绝服务**（**（D）DoS**）攻击。在这种攻击中，恶意攻击者试图消耗、甚至超载目标系统的资源，以至于系统要么崩溃，要么至少变得完全无响应（挂起）。
- en: Interestingly, on an untuned system, performing this type of attack is quite
    easy; as an example, let's imagine we have shell access (not root, of course,
    but as a regular user) on a server. We could attempt to have it run out of disk
    space (or at least run short) quite easily by manipulating the ubiquitous `dd(1)`
    (disk dump) command. One use of `dd` is to create files of arbitrary lengths.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在一个未调整的系统上，执行这种类型的攻击是非常容易的；例如，让我们想象一下，我们在服务器上有shell访问权限（当然不是root，而是普通用户）。我们可以通过操纵无处不在的`dd(1)`（磁盘转储）命令很容易地使其耗尽磁盘空间（或至少变得短缺）。`dd`的一个用途是创建任意长度的文件。
- en: 'For example, to create a 1 GB file filled with random content, we could do
    the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要创建一个填满随机内容的1GB文件，我们可以这样做：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What if we bump the blocksize (`bs`) value to `1G`, like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将块大小（`bs`）的值增加到`1G`，就像这样：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`dd` will now attempt to create a file that is 1,024 GB—a terabyte—in size! What
    if we run this line (in a script) in a loop? You get the idea.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`dd`现在将尝试创建一个大小为1,024GB—即一太字节—的文件！如果我们在循环中运行这行代码（在脚本中）会发生什么？你懂的。'
- en: To control resource-usage, Unix (including Linux) has a resource limit, that
    is, an artificial limit imposed upon a resource by the OS.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制资源使用，Unix（包括Linux）有一个资源限制，即操作系统对资源施加的人为限制。
- en: 'A point to be clear on from the very beginning: these resource limits are on
    a per-process basis and not system-wide globals—more on this in the next section.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要明确的一点是：这些资源限制是基于每个进程而不是系统范围的全局限制——关于这一点我们将在下一节详细介绍。
- en: Before diving into more detail, let's continue with our hack example to eat
    up a system's disk space, but this time with the resource limit for the maximum
    size of a file set in place beforehand.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入更多细节之前，让我们继续我们的黑客示例，耗尽系统的磁盘空间，但这次在之前设置了文件最大大小的资源限制。
- en: 'The frontend command to view and set resource limits is a built-in shell command
    (these commands are called **bash-builtins**): **`ulimit`**. To query the maximum
    possible size of files written to by the shell process (and its children), we
    set the `-f` option switch to `ulimit`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 查看和设置资源限制的前端命令是一个内置的shell命令（这些命令称为**bash内置**）：**`ulimit`**。要查询由shell进程（及其子进程）写入的文件的最大可能大小，我们将`-f`选项开关设置为`ulimit`：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Okay, it's unlimited. Really? No, unlimited only implies that there is no particular
    limit imposed by the OS. Of course it's finite, limited by the actual available
    disk space on the box.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，它是无限的。真的吗？不，无限只意味着操作系统没有特定的限制。当然它是有限的，受到盒子上实际可用磁盘空间的限制。
- en: 'Let''s set a limit on the maximum file size, simply by passing the `-f` option
    switch and the actual limit. But what''s the unit of the size? bytes, KB, MB?
    Let''s look up its man page: by the way, the man page for `ulimit` is the man
    page for `bash(1)`. This is logical, as `ulimit` is a built-in shell command.
    Once in the `bash(1)` man page, search for `ulimit`; the manual informs us that
    the unit (by default) is 1,024-byte increments. Thus, `2` implies *1,024*2 = 2,048*
    bytes. Alternatively, to get some help on `ulimit`, just type `help ulimit` on
    the shell.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过传递`-f`选项开关和实际限制来设置最大文件大小的限制。但是大小的单位是什么？字节、KB、MB？让我们查看它的手册页：顺便说一句，`ulimit`的手册页是`bash(1)`的手册页。这是合理的，因为`ulimit`是一个内置的shell命令。在`bash(1)`手册页中，搜索`ulimit`；手册告诉我们，单位（默认情况下）是1,024字节的增量。因此，`2`意味着*1,024*2
    = 2,048*字节。或者，要在`ulimit`上获得一些帮助，只需在shell上输入`help ulimit`。
- en: 'So, let''s try this: reduce the file size resource limit to just 2,048 bytes
    and then test with `dd`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们试一试：将文件大小资源限制减少到只有2,048字节，然后用`dd`进行测试：
- en: '![](img/3a5aaecd-3731-4be5-94f8-b6368b050e63.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3a5aaecd-3731-4be5-94f8-b6368b050e63.png)'
- en: 'Figure 1: A simple test case with ulimit -f'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：使用ulimit -f进行简单的测试案例
- en: As can be seen from the preceding screenshot, we reduce the file size resource
    limit to `2`, implying 2,048 bytes, and then test with `dd`. As long as we create
    a file at or below 2,048 bytes, it works; the moment we attempt to go beyond the
    limit, it fails.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中可以看出，我们将文件大小资源限制减少到`2`，意味着2,048字节，然后用`dd`进行测试。只要我们创建的文件大小在或低于2,048字节，它就可以工作；一旦我们尝试超过限制，它就会失败。
- en: 'As an aside, note that `dd` does *not* attempt to use some clever logic to
    test the resource limit, displaying an error if it were to attempt to create a
    file over this limit. No, it just fails. Recall from [Chapter 1](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml),
    *Linux System Architecture*, the Unix philosophy principle: provide mechanisms,
    not policies!'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，注意`dd`并*没有*尝试使用一些聪明的逻辑来测试资源限制，如果它尝试创建超出此限制的文件，它会显示错误。不，它只是失败了。回想一下[第1章](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml)，*Linux系统架构*，Unix哲学原则：提供机制，而不是策略！
- en: Granularity of resource limits
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源限制的粒度
- en: 'In the previous example with `dd(1)`, we saw that we can indeed impose a limit
    upon the maximum file size. An important question arises: what is the *scope*
    or *granularity* of the resource limit? Is it system-wide?'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`dd(1)`的例子中，我们看到我们确实可以对最大文件大小施加限制。一个重要的问题是：资源限制的*范围*或*粒度*是什么？它是系统范围的吗？
- en: 'The short answer: no, it''s not system-wide, it''s *process-wide*, implying
    that the resource limits apply at the granularity of a process and not the system.
    To clarify this, consider two shells—nothing but the `bash` process—shell A and
    shell B. We modify the maximum file-size resource limit for shell A (with the
    usual `ulimit -f <new-limit>` command), but leave the resource limit for maximum
    file size for shell B untouched. If now they both use `dd` (as we did), we would
    find that the `dd`  process invoked within shell A would likely die with the `''File
    size limit exceeded (core dumped)''` failure message, whereas the `dd` process
    invoked within shell B would likely continue and succeed (provided, of course,
    there''s sufficient disk space available).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答：不，它不是系统范围的，它是*进程范围*，这意味着资源限制适用于进程的粒度而不是系统。为了澄清这一点，考虑两个shell——仅仅是`bash`进程——shell
    A和shell B。我们修改了shell A的最大文件大小资源限制（使用通常的`ulimit -f <new-limit>`命令），但保持了shell B的最大文件大小资源限制不变。如果现在它们都使用`dd`（就像我们做的那样），我们会发现在shell
    A中调用的`dd`进程可能会因为超出文件大小限制而死亡，并显示`'文件大小限制超出（核心已转储）'`的失败消息，而在shell B中调用的`dd`进程可能会继续并成功（当然，前提是有足够的磁盘空间）。
- en: This simple experiment proves that the granularity of a resource limit is per
    process*.*
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的实验证明了资源限制的粒度是每个进程*。
- en: When we delve into the inner details of multithreading, we'll revisit the granularity
    of resource limits and how they apply to individual threads. For the impatient,
    all resource limits-except for the stack size are shared by all threads within
    the process
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们深入研究多线程的内部细节时，我们将重新讨论资源限制的粒度以及它们如何应用于单个线程。对于急躁的人来说，除了堆栈大小之外，所有资源限制都是由进程内的所有线程共享的
- en: Resource types
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源类型
- en: So far, we've only checked out the maximum file size resource limit; are there
    not others? Yes, indeed, there are several others.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只检查了最大文件大小资源限制；难道没有其他的吗？是的，确实还有其他几个。
- en: Available resource limits
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用资源限制
- en: 'The following table enumerates the available resource limits on a typical Linux
    system (alphabetically ordered by the `ulimit option switch` column):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列举了典型Linux系统上可用的资源限制（按`ulimit选项开关`列按字母顺序排列）：
- en: '| **Resource limit** | **ulimit option** **switch** | **Default value** | **Unit**
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '**资源限制** | **ulimit选项开关** | **默认值** | **单位**'
- en: '| `max core file size` | `-c` | `unlimited` | KB |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: 最大核心文件大小 | -c | 无限制 | KB
- en: '| `max data segment size` | `-d` | `unlimited` | KB |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: 最大数据段大小 | -d | 无限制 | KB
- en: '| `max scheduling priority` (nice) | `-e` | `0` | Unscaled |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: 最大调度优先级（nice） | -e | 0 | 未缩放
- en: '| `max file size` | `-f` | `unlimited` | KB |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: 最大文件大小 | -f | 无限制 | KB
- en: '| `max (real-time) pending signals` | `-i` | `<varies>` | Unscaled |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: 最大（实时）挂起信号 | -i | <varies> | 未缩放
- en: '| `max locked memory` | `-l` | `<varies>` | KB |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: 最大锁定内存 | -l | <varies> | KB
- en: '| `max memory size` | `-m` | `unlimited` | KB |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: 最大内存大小 | -m | 无限制 | KB
- en: '| `max open files` | `-n` | `1024` | Unscaled |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: 最大打开文件数 | -n | 1024 | 未缩放
- en: '| `max pipe size` | `-p` | `8` | 512-byte increments |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: 最大管道大小 | -p | 8 | 以512字节递增
- en: '| `max POSIX message queues` | `-q` | `<varies>` | Unscaled |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: 最大POSIX消息队列 | -q | <varies> | 未缩放
- en: '| `max real-time scheduling priority` | `-r` | `0` | Unscaled |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: 最大实时调度优先级 | -r | 0 | 未缩放
- en: '| `max stack segment size` | `-s` | `8192` | KB |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: 最大堆栈段大小 | -s | 8192 | KB
- en: '| `max CPU time` | `-t` | `unlimited` | Seconds |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: 最大CPU时间 | -t | 无限制 | 秒
- en: '| `max user processes` | `-u` | `<varies>` | Unscaled |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: 最大用户进程数 | -u | <varies> | 未缩放
- en: '| `address space limit` or `max virtual memory` | `-v` | `unlimited` | KB |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: 地址空间限制或最大虚拟内存 | -v | 无限制 | KB
- en: '| `max file locks held` | `-x` | `unlimited` | Unscaled |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: 最大文件锁定数 | -x | 无限制 | 未缩放
- en: 'There are a few points to note:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点需要注意：
- en: At a glance, some of the resource limit meanings are quite obvious; several
    may not be. Most of them are not explained here, some of them will be touched
    upon in subsequent chapters.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乍一看，一些资源限制的含义是相当明显的；有些可能不是。这里没有解释大部分资源限制，一些将在后续章节中涉及。
- en: 'The second column is the option switch to pass to `ulimit` to display the current
    value for the particular resource limit in that row; for example, `ulimit -s`
    to print out the current value of the stack size resource limit (unit: KB).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二列是传递给`ulimit`的选项开关，用于显示该行中特定资源限制的当前值；例如，`ulimit -s`打印出堆栈大小资源限制的当前值（单位：KB）。
- en: The third column is **Default value**. This, of course, could vary across Linux
    platforms. In particular, enterprise-class servers may tune their default values
    to be much higher than, say, an embedded Linux system. Also, quite often the default
    value is a calculation (based on, say, amount of RAM installed on the box); hence,
    the entry *<varies>* in some cases. Also, as mentioned earlier, `unlimited` does
    not mean infinite—it implies that no artificial upper limit has been enforced.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三列是**默认值**。当然，这可能会因Linux平台而异。特别是，企业级服务器可能会调整它们的默认值，使其比嵌入式Linux系统的默认值高得多。而且，通常默认值是一个计算（基于，比如，安装在盒子上的RAM数量）；因此，在某些情况下会有*<varies>*的条目。另外，正如前面提到的，`unlimited`并不意味着无限——它意味着没有强加的人工上限。
- en: 'Regarding the fourth column, **Unit**, the (`bash(1)`) man page (source:[https://linux.die.net/man/1/bash](https://linux.die.net/man/1/bash))
    states the following:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于第四列，**单位**，(`bash(1)`)的man页面（来源：[https://linux.die.net/man/1/bash](https://linux.die.net/man/1/bash)）中如下所述：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Also, `unscaled` implies it's just a number.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`unscaled` 意味着它只是一个数字。
- en: One can display all resource limits via the `-a` option switch; we leave it
    to you to try out the `ulimit -a` command.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`-a`选项开关显示所有资源限制；我们留给您尝试`ulimit -a`命令。
- en: Note that `ulimit -a` orders the resource limits alphabetically by option switch,
    just as we did in the table.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ulimit -a`按选项开关的字母顺序排列资源限制，就像我们在表中所做的那样。
- en: Also, it's really important to understand that these resource limits are with
    respect to a single process—the shell process (Bash)—that invoked the `ulimit`
    command.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，非常重要的是要理解这些资源限制是针对单个进程的——调用`ulimit`命令的shell进程（Bash）。
- en: Hard and soft limits
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 硬限制和软限制
- en: 'Unixes make a further distinction: in reality (under the hood), the resource
    limit for a given type is not one number—it''s two:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Unixes有一个进一步的区别：实际上（在底层），给定类型的资源限制不是一个数字，而是两个：
- en: A value for the hard limit
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬限制的值
- en: A value for the soft limit
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软限制的值
- en: 'The hard limit is the true maximum; as a regular user, it''s impossible to
    exceed this limit. What if a process attempts this? Simple: it gets killed by
    the OS.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 硬限制是真正的最大值；作为普通用户，不可能超过这个限制。如果一个进程尝试这样做会发生什么？简单：它会被操作系统杀死。
- en: 'The soft limit, on the other hand, can be breached: in the case of some resource
    limits, the process (that exceeds the soft limit) will be sent a signal by the
    kernel. Think of this as a warning: you''re nearing the limit kind of thing. Again,
    don''t worry, we take a deep dive into signalingin [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml),
    *Signaling - Part I*, and, [Chapter 12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml),
    *Signaling - Part II*. For example, if a process exceeds the soft limit for file
    size, the OS responds by delivering the `SIGXFSZ` signal—`SIGnal: eXceeding FileSiZe`—to
    it! Overstep the soft limit for CPU and guess what? You will be the proud recipient
    of the `SIGXCPU` signal.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，软限制可以被突破：在某些资源限制的情况下，进程（超过软限制的进程）将被内核发送一个信号。把这看作是一个警告：你接近限制了。再次强调，不用担心，我们将在[第11章](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml)中深入探讨信号处理，*信号-第一部分*，以及[第12章](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml)，*信号-第二部分*。例如，如果一个进程超过了文件大小的软限制，操作系统会通过传递`SIGXFSZ`信号—`信号：超出文件大小`—来响应它！超过CPU的软限制又会怎样呢？你将成为`SIGXCPU`信号的骄傲接收者。
- en: 'Well, there''s more to it: the man page on `prlimit(2)` shows how, on Linux,
    with regard to the CPU limit, `SIGKILL` is sent after multiple warnings via `SIGXCPU`.
    The right behavior: the application should clean up and terminate upon receiving
    the first `SIGXCPU` signal. We will look at signal-handling in [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml),
    *Signaling – Part I*!'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，还有更多：`prlimit(2)`的man页面显示，在Linux上，关于CPU限制，会在通过`SIGXCPU`发送多个警告后发送`SIGKILL`。正确的行为是：应用程序应该在收到第一个`SIGXCPU`信号时进行清理和终止。我们将在[第11章](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml)中查看信号处理，*信号-第一部分*！
- en: It's instructive to think of the hard limit as a ceiling value for the soft
    limit; in effect, the range of the soft limit for a given resource is [0, hard-limit].
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将硬限制视为软限制的上限值是很有启发性的；实际上，给定资源的软限制范围是[0，硬限制]。
- en: 'To view both the hard and soft limits on your shell process, use the `-S` and
    `-H` option switches on `ulimit`, respectively. Here''s the output of `ulimit
    -aS` on our trusty Fedora 28 desktop system:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看shell进程的硬限制和软限制，请分别使用`ulimit`的`-S`和`-H`选项开关。以下是我们可靠的Fedora 28桌面系统上`ulimit
    -aS`的输出：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we run `ulimit` with both the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们同时运行`ulimit`和以下命令时：
- en: '`-aS`: Display all Soft resource limit values'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-aS`: 显示所有软资源限制值'
- en: '`-aH`: Display all Hard resource limit values'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-aH`: 显示所有硬资源限制值'
- en: 'A question comes up: where exactly do the soft and hard limits (for the Bash
    process) differ? Instead of trying to manually interpret it, let''s use a super
    GUI frontend to `diff` (well, it''s more than just a `diff` frontend actually),
    called  `meld`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题出现了：软限制和硬限制（对于Bash进程）究竟在哪里不同？我们可以使用一个超级GUI前端`meld`来进行比较（实际上，它不仅仅是一个`diff`前端）：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Screenshot of meld comparing the soft and hard limit resource values shown
    as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 显示meld比较软限制和硬限制资源值的屏幕截图如下：
- en: '![](img/baca4e69-7511-48aa-9486-4627af191135.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/baca4e69-7511-48aa-9486-4627af191135.png)'
- en: 'Figure 2: Screenshot showing meld comparing the soft and hard limit resource
    values'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：屏幕截图显示meld比较软限制和硬限制资源值
- en: 'Note that we run `ps`; this is to reiterate the fact that the resource limit
    values we''re seeing `/` are with respect to it (PID `23843`). So, meld clearly
    shows us that, by default on a typical Linux system, only two resource limits
    differ in their soft and hard values: the max open files (soft=1024, hard=4096),
    and max stack size (soft=8192 KB = 8 MB, hard=unlimited).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们运行`ps`；这是为了重申我们看到的资源限制值是关于它（PID `23843`）的。因此，meld清楚地显示，在典型的Linux系统上，默认情况下只有两个资源限制在软限制和硬限制的值上有所不同：最大打开文件数（soft=1024，hard=4096），和最大堆栈大小（soft=8192
    KB = 8 MB，hard=无限）。
- en: '`meld` is extremely valuable to developers; we often use it to (peer-) review
    code and make changes (merges via the right- and left-pointing arrows).  In fact,
    the powerful Git SCM uses `meld` as one of the available tools (with the `git
    mergetool` command). Install `meld` on your Linux box using the appropriate package
    manager for your distribution and try it out.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`meld`对开发人员非常有价值；我们经常用它来（同行）审查代码并进行更改（通过右箭头和左箭头进行合并）。事实上，强大的Git SCM使用`meld`作为可用工具之一（使用`git
    mergetool`命令）。使用适合您的发行版的适当软件包管理器在Linux上安装`meld`并尝试一下。'
- en: Querying and changing resource limit values
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询和更改资源限制值
- en: 'We now understand that it''s the kernel (the OS) that sets up resource limits
    per process and tracks usage, even killing the process if necessary—if it attempts
    to exceed a resource''s hard limit. This raises the question: is there a way one
    can change the soft and hard resource-limit values? We''ve already seen it in
    fact: `ulimit`. More than that, though, the deeper question is: are we allowed
    to set any hard/soft limits?'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在明白了，是内核（操作系统）为每个进程设置资源限制并跟踪使用情况，甚至在必要时终止进程——如果它试图超过资源的硬限制。这引发了一个问题：有没有办法改变软限制和硬限制的值？实际上我们已经看到了：`ulimit`。不仅如此，更深层次的问题是：我们被允许设置任何硬/软限制吗？
- en: 'The kernel has certain preset rules regarding the changing of a resource limit. Querying
    or setting a process''s resource limits can only be done by the calling process
    upon itself or upon a process that it owns; more correctly, for any other process
    besides itself, the process must have the `CAP_SYS_RESOURCE` capability bit set
    (worry not, detailed coverage on process capabilities can be found in [Chapter
    8](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml), *Process Capabilities*):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 内核对更改资源限制有一些预设规则。查询或设置进程的资源限制只能由调用进程自身或拥有的进程进行；更准确地说，对于除自身之外的任何其他进程，进程必须设置`CAP_SYS_RESOURCE`能力位（不用担心，关于进程能力的详细覆盖可以在[第8章](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml)中找到，*进程能力*）：
- en: '**Querying**: Anyone can query the resource limits hard and soft (current)
    values of the processes they own.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询**：任何人都可以查询他们拥有的进程的资源限制硬限制和软（当前）值。'
- en: '**Setting**:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置**：'
- en: A hard limit, once set, cannot be further increased (for that session).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦设置了硬限制，就不能进一步增加（对于该会话）。
- en: A soft limit can be increased up to the hard limit value only, that is, soft
    limit range = [0, hard-limit].
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软限制只能增加到硬限制值，即软限制范围= [0, 硬限制]。
- en: When one sets the resource limit using `ulimit`, the system internally sets
    *both the hard and soft limits.* This has important consequences (see the preceding
    points).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用`ulimit`设置资源限制时，系统在内部设置*软限制和硬限制*。这具有重要的后果（参见前面的要点）。
- en: 'Permissions for setting resource limits is given as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 设置资源限制的权限如下：
- en: A privileged process (such as `superuser/root/sysadmin`, or one with the aforementioned
    `CAP_SYS_RESOURCE` capability) can increase or decrease both hard and soft limits.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特权进程（如`superuser/root/sysadmin`，或者具有前述`CAP_SYS_RESOURCE`能力的进程）可以增加或减少硬限制和软限制。
- en: 'A non-privileged process (non-root):'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非特权进程（非root）：
- en: Can set the soft limit of a resource in the range [0, hard-limit] for that resource.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将资源的软限制设置在[0, 硬限制]的范围内。
- en: Can irreversibly decrease a resource's hard limit (once reduced, it cannot ever
    increase it, but can only continue to decrease it). More precisely, the hard limit
    can be decreased to a value greater than or equal to the current soft limit.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以不可逆地减少资源的硬限制（一旦减少，就不能再增加，但只能继续减少）。更准确地说，硬限制可以减少到大于或等于当前软限制的值。
- en: 'Every good rule has an exception: a non-privileged user *can* decrease and/or
    increase the *core file* resource limit. This is usually to allow developers to
    generate a core dump (which can be subsequently analyzed via GDB).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每个好的规则都有例外：非特权用户*可以*减少和/或增加*核心文件*资源限制。这通常是为了允许开发人员生成*核心转储*（随后可以通过GDB进行分析）。
- en: 'A quick test case to demonstrate this is in order; let''s manipulate the max
    open files resource limit:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，需要一个快速的测试案例；让我们操纵*最大打开文件*资源限制：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding command are explained as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的解释如下：
- en: The current soft limit is 1,024 (the default)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前软限制为1,024（默认值）
- en: The soft limit is 1,024, the hard limit is 4,096
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软限制为1,024，硬限制为4,096
- en: Using `ulimit`, we set the limit to 3,000; this, internally, has caused both
    the soft and hard limits to be set to 3,000
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ulimit`，我们将限制设置为3,000；这在内部导致软限制和硬限制都设置为3,000
- en: Attempting to set the value higher (to 3,001) fails
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试将值设置得更高（至3,001）失败
- en: Reducing the value (to 2,000) succeeds
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减小值（至2,000）成功
- en: Realize though, that again, both the soft and hard limits have been set to 2,000
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不过要意识到，软限制和硬限制都已经设置为2,000
- en: Attempting to go back to a previously valid value fails (3,000); this is because
    the valid range now is [0, 2,000]
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试返回到先前有效的值失败（3,000）；这是因为现在的有效范围是[0, 2,000]
- en: Testing this with root access is left as an exercise to the reader; see the
    *Caveats* section that follows, though.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 测试root访问权限留给读者练习；不过，可以查看下面的*注意事项*部分。
- en: Caveats
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'Things to consider, and exceptions that apply:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑的事项和适用的例外情况：
- en: Even if one can, increasing a resource limit may do more harm than good; think
    through what you are trying to achieve here. Put yourself in the malicious-hacker
    mindset (recall (DDoS attacks). On both server class, as well as on highly resource-constrained
    systems (often an embedded one), setting resource limits appropriately can help
    mitigate risk.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使可以，增加资源限制可能会带来更多的危害；要考虑你在这里试图实现什么。将自己置于恶意黑客的心态中（回想（DDoS攻击）。在服务器类和高度资源受限的系统（通常是嵌入式系统）上，适当设置资源限制可以帮助减轻风险。
- en: 'Setting a resource limit to a higher value requires root privilege. For example:
    we wish to increase the max open files resource limit from 1,024 to 2,000\. One
    would assume that using `sudo` should do the job. However, at first surprisingly,
    something such as `sudo ulimit -n 2000` will not work! Why? Well, when you run
    it, `sudo` expects that `ulimit` is a binary executable and thus searches for
    it in the `PATH`; but of course, that''s not the case: `ulimit` is a built-in
    shell command and thus fails to launch. So, try it this way:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将资源限制设置为更高的值需要root权限。例如：我们希望将*最大打开文件*资源限制从1,024增加到2,000。人们可能会认为使用`sudo`应该可以完成任务。然而，最初令人惊讶的是，诸如`sudo
    ulimit -n 2000`这样的命令不起作用！为什么？当你运行它时，`sudo`期望`ulimit`是一个二进制可执行文件，因此在`PATH`中搜索它；但当然，事实并非如此：`ulimit`是一个内置的shell命令，因此无法启动。因此，请尝试以下方式：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Exception—you cannot seem to change the max pipe size resource limit.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例外情况——似乎无法更改最大管道大小资源限制。
- en: 'Advanced: The default maximum pipe size is actually in `/proc/sys/fs/pipe-max-size`
    and defaults to 1 MB (from Linux 2.6.35). What if the programmer must change the
    pipe size? To do so, one could use the `fcntl(2)`system call, via the `F_GETPIPE_SZ`
    and `F_SETPIPE_SZ` parameters. Refer to the *fcntl(2)* man page for details.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 高级：默认的最大管道大小实际上在`/proc/sys/fs/pipe-max-size`中，默认为1MB（从Linux 2.6.35开始）。如果程序员必须更改管道大小怎么办？为此，可以使用`fcntl(2)`系统调用，通过`F_GETPIPE_SZ`和`F_SETPIPE_SZ`参数。有关详细信息，请参阅*fcntl(2)*man页面。
- en: A quick note on the prlimit utility
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于prlimit实用程序的快速说明
- en: 'Besides using `ulimit`, another frontend to querying and displaying resource
    limits is the `prlimit` utility. `prlimit` differs from `ulimit` in the following
    ways:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`ulimit`，查询和显示资源限制的另一个前端是`prlimit`实用程序。`prlimit`与`ulimit`不同的地方在于：
- en: It's a newer, modern interface (Linux kernel version 2.6.36 onward)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个更新的、现代的接口（从Linux内核版本2.6.36开始）
- en: It can be used to modify limits as required *and* launch another program that
    will inherit the new limits (a useful feature; see the following examples)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以用于根据需要修改限制*并*启动另一个将继承新限制的程序（一个有用的功能；请参见以下示例）
- en: It's a binary executable program in itself, not a built-in like `ulimit` is
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它本身是一个二进制可执行程序，不像`ulimit`那样是内置的
- en: 'Without any parameters, `prlimit` displays the resource limits of the calling
    process (itself). One can optionally pass resource limit `<name=value>` pairs
    to set the same, the PID of the process to query/set resource limits, or a command
    to be launched with the newly set resource limits. Here is the synopsis from its
    man page:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何参数，`prlimit`会显示调用进程（自身）的资源限制。可以选择传递资源限制`<name=value>`对来设置相同的资源限制，要查询/设置资源限制的进程的PID，或者要使用新设置的资源限制启动的命令。以下是它的man页面中的概要：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note how the `--pid` and `command` options are mutually exclusive.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`--pid`和`command`选项是互斥的。
- en: Using prlimit(1) – examples
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用prlimit(1) - 示例
- en: 'Example 1—querying limits:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-查询限制：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Output for the preceding command is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下：
- en: '![](img/0f483e82-6b24-4d49-9316-a3ef79eb63ef.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f483e82-6b24-4d49-9316-a3ef79eb63ef.png)'
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we have abbreviated the output for better readability.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经缩短了输出以便更好地阅读。
- en: 'Example 2—set the resource limits for max file size and max stack size for
    the (preceding) shell process:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-设置（前面的）shell进程的最大文件大小和最大堆栈大小的资源限制：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Example 3—a program, `rlimit_primes`, that generates prime numbers; have it
    generate a large number of primes but give it only two seconds of CPU time to
    do so.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3-一个名为`rlimit_primes`的程序，用于生成质数；让它生成大量的质数，但只给它两秒的CPU时间来完成。
- en: Note that the `rlimit_primes` program, along with its source code, is described
    in detail in the *API interfaces* section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`rlimit_primes`程序及其源代码的详细描述在*API接口*部分中。
- en: 'For now, we just run it within the scope of the built-in `prlimit `program,
    ensuring that the `rlimit_primes`process only gets the CPU bandwidth (in seconds)
    that we pass via the `prlimit --cpu=`option switch. In the example, we ensure
    the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只在内置的`prlimit`程序范围内运行它，确保`rlimit_primes`进程只获得我们通过`prlimit --cpu=`选项开关传递的CPU带宽（以秒为单位）。在这个示例中，我们确保以下内容：
- en: We give our prime number generator process two seconds (via `prlimit`)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们给我们的质数生成器进程两秒（通过`prlimit`）
- en: We pass `-2` as the second parameter; this will cause the `rlimit_primes`program
    to skip setting the CPU resource limit itself
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将-2作为第二个参数传递；这将导致`rlimit_primes`程序跳过设置CPU资源限制
- en: 'We ask it to generate primes up to the number 8,000,000:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们要求它生成小于800万的质数：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note how, once it's out of its newly constrained CPU time resource (two seconds,
    in the preceding example), it gets killed by the kernel! (Technically, by the
    `SIGKILL` signal; a lot more on signals follows in [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml), *Signaling
    - Part I*, and [Chapter 12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml), *Signaling
    - Part II*). Note how the word **`Killed`** appears, indicating that the OS has
    killed the process.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦它超出了其新的受限CPU时间资源（在前面的示例中为两秒），它就会被内核杀死！（技术上，是通过`SIGKILL`信号；关于信号的更多内容请参见[第11章](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml)，*信号-第I部分*和[第12章](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml)，*信号-第II部分*）。请注意**`Killed`**这个词的出现，表明操作系统已经杀死了该进程。
- en: Refer to the man page on `prlimit(1)` for further details.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请参阅`prlimit(1)`的man页面。
- en: 'A practical case: When running fairly heavy software such as Eclipse and Dropbox,
    I have found it necessary to bump up the resource limits for them (as advised);
    otherwise, they abort as they run out of resources.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实际案例：当运行像Eclipse和Dropbox这样的相当重的软件时，我发现有必要提高它们的资源限制（如建议的）；否则，它们会因资源耗尽而中止。
- en: 'Advanced: From the Linux kernel version 2.6.24 onward, one can look up the
    resource limits for a given process PID via the powerful `proc` filesystem: `/proc/<PID>/limits`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 高级：从Linux内核版本2.6.24开始，可以通过强大的`proc`文件系统查找给定进程PID的资源限制：`/proc/<PID>/limits`。
- en: API interfaces
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API接口
- en: 'Querying and/or setting resource limits programmatically can be achieved with
    the following APIs—the system calls:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下API来查询和/或以编程方式设置资源限制-系统调用：
- en: '`getrlimit`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getrlimit`'
- en: '`setrlimit`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setrlimit`'
- en: '`prlimit`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prlimit`'
- en: Of these, we will only focus on `prlimit(2)`; `[get|set]rlimit(2)` is an older
    interface, has quite a few issues (bugs), and is generally considered outdated.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，我们只关注`prlimit(2)`；`[get|set]rlimit(2)`是一个较旧的接口，存在一些问题（错误），通常被认为已过时。
- en: For `prlimit(2)` to work properly, one must be running on Linux kernel version
    2.6.36 or later.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`prlimit(2)`正常工作，必须在Linux内核版本2.6.36或更高版本上运行。
- en: How does one determine the Linux kernel version one is running on?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如何确定正在运行的Linux内核版本？
- en: 'Simple: use the `uname` utility to query the kernel version:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 简单：使用`uname`实用程序查询内核版本：
- en: '`$ uname -r`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ uname -r`'
- en: '`4.14.11-300.fc27.x86_64`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`4.14.11-300.fc27.x86_64`'
- en: '`$`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`'
- en: 'Let''s get back to the `prlimit(2)` system call API:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`prlimit(2)`系统调用API：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `prlimit()` system call can be used to both query and set a given resource
    limit—only one resource limit per call—for or on a given process. It receives
    four arguments; the first argument, `pid`, is the PID of the process to act upon.
    The special `0` value implies that it acts upon the calling process itself. The
    second argument, resource*,* is the name of the resource limit we wish to query
    or set (refer to the following table for the full list). Both the third and fourth
    arguments are pointers to `struct rlimit`; the third parameter, if non-NULL, is
    the new value we want to set (which is why it is marked `const`); the fourth parameter,
    if non-NULL, is the structure where we will receive the previous (or old) limit.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`prlimit()`系统调用可用于查询和设置给定进程的给定资源限制，每次调用只能设置一个资源限制。它接收四个参数；第一个参数`pid`是要操作的进程的PID。特殊值`0`表示它作用于调用进程本身。第二个参数，资源，是我们希望查询或设置的资源限制的名称（请参阅以下表格以获取完整列表）。第三和第四个参数都是指向`struct
    rlimit`的指针；如果第三个参数非NULL，则是我们要设置的新值（这就是为什么它被标记为`const`）；如果第四个参数非NULL，则是我们将接收到的先前（或旧的）限制的结构。'
- en: Experienced C programmers will realize how easy it is to create bugs. It's the
    programmer's responsibility to ensure that the memory for the *rlimit* structures
    (third and fourth parameters), if used, must be allocated*;* the OS certainly
    does not allocate memory for these structures.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有经验的C程序员会意识到创建错误有多么容易。程序员有责任确保*rlimit*结构（第三和第四个参数）的内存（如果使用）必须被分配；操作系统肯定不会为这些结构分配内存。
- en: 'The `rlimit` structure contains two members, the soft and hard limits (`rlim_cur `and `rlim_max`, respectively):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`rlimit`结构包含两个成员，软限制和硬限制（`rlim_cur`和`rlim_max`）：'
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Back to the second argument, resource, which is the programmatic name of the
    resource limit we wish to query or set. The following table enumerates all of
    them:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第二个参数，资源，这是我们希望查询或设置的资源限制的编程名称。以下表列出了所有资源限制：
- en: '| **Resource limit** | **Programmatic****name (use in API)**  | **Default value**
    | **Unit** |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| **资源限制** | **编程名称（在API中使用）** | **默认值** | **单位** |'
- en: '| `max core file size` | `RLIMIT_CORE` | `unlimited` | KB |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `max core file size` | `RLIMIT_CORE` | `unlimited` | KB |'
- en: '| `max data segment size` | `RLIMIT_DATA` | `unlimited` | KB |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `max data segment size` | `RLIMIT_DATA` | `unlimited` | KB |'
- en: '| `max scheduling priority (*nice*)` | `RLIMIT_NICE` | `0` | unscaled |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `max scheduling priority (*nice*)` | `RLIMIT_NICE` | `0` | 未缩放 |'
- en: '| `max file size` | `RLIMIT_FSIZE` | `unlimited` | KB |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `max file size` | `RLIMIT_FSIZE` | `unlimited` | KB |'
- en: '| `max (real-time) pending signals` | `RLIMIT_SIGPENDING` | `<varies>` | unscaled
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `max (real-time) pending signals` | `RLIMIT_SIGPENDING` | `<varies>` | 未缩放
    |'
- en: '| `max locked memory` | `RLIMIT_MEMLOCK` | `<varies>` | KB |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `max locked memory` | `RLIMIT_MEMLOCK` | `<varies>` | KB |'
- en: '| `max open files` | `RLIMIT_NOFILE` | `1024` | unscaled |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `max open files` | `RLIMIT_NOFILE` | `1024` | 未缩放 |'
- en: '| `max POSIX message queues` | `RLIMIT_MSGQUEUE` | `<varies>` | unscaled |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `max POSIX message queues` | `RLIMIT_MSGQUEUE` | `<varies>` | 未缩放 |'
- en: '| `max real-time priority` | `RLIMIT_RTTIME` | `0` | microseconds |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `max real-time priority` | `RLIMIT_RTTIME` | `0` | 微秒 |'
- en: '| `max stack segment size` | `RLIMIT_STACK` | `8192` | KB |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `max stack segment size` | `RLIMIT_STACK` | `8192` | KB |'
- en: '| `max CPU time` | `RLIMIT_CPU` | `unlimited` | seconds |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `max CPU time` | `RLIMIT_CPU` | `unlimited` | 秒 |'
- en: '| `max user processes` | `RLIMIT_NPROC` | `<varies>` | unscaled |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `max user processes` | `RLIMIT_NPROC` | `<varies>` | 未缩放 |'
- en: '| `address space limit or max virtual memory` | `RLIMIT_AS  ` (AS = Address
    Space) | `unlimited` | KB |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `address space limit or max virtual memory` | `RLIMIT_AS  `（AS = 地址空间） |
    `unlimited` | KB |'
- en: '| `max file locks held` | `RLIMIT_LOCKS` | `*unlimited*` | *unscaled* |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `max file locks held` | `RLIMIT_LOCKS` | `*unlimited*` | *unscaled* |'
- en: 'Points to note are given as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的要点如下：
- en: The `RLIM_INFINITY` value for a resource value implies that there is no limit.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于资源值，`RLIM_INFINITY`表示没有限制。
- en: Alert readers will notice that there is no entry for `max pipe size` (as there
    was in the previous table); this is because this resource cannot be modified via
    the `prlimit(2)` API.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 细心的读者会注意到在上一个表中没有`max pipe size`的条目；这是因为这个资源不能通过`prlimit(2)` API进行修改。
- en: Technically, to modify a resource limit value, a process requires the `CAP_SYS_RESOURCE`
    capability (capabilities is explained in details in [Chapter 8](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml),
    *Process Capabilities*). For now, let's just use the traditional approach and
    say that in order to change a process's resource limit, one needs to own the process
    (or be root; being root or superuser is pretty much a shortcut to all the rules).
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从技术上讲，要修改资源限制值，进程需要`CAP_SYS_RESOURCE`能力（能力在[第8章](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml)中有详细解释，*进程能力*）。现在，让我们只使用传统方法，并说为了改变进程的资源限制，需要拥有该进程（或者是root；成为root或超级用户基本上是所有规则的捷径）。
- en: Code examples
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'The following two C programs are used to demonstrate the usage of the `prlimit(2)`
    API:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个C程序用于演示`prlimit(2)` API的用法：
- en: The first program, `rlimits_show.c`, queries all resource limits for the current
    or calling process and prints out their values.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个程序`rlimits_show.c`查询当前进程或调用进程的所有资源限制，并打印出它们的值。
- en: The second, given a CPU resource limit (in seconds), runs a simple prime number
    generator under the influence of that limit.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个程序给定CPU资源限制（以秒为单位），在该限制的影响下运行一个简单的素数生成器。
- en: For readability, only the relevant parts of the code are displayed. To view
    and run it, the entire source code is available at [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)*.*
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，只显示了代码的相关部分。要查看并运行它，整个源代码可在[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)上找到。
- en: 'Refer to the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下代码：
- en: '[PRE15]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s try it out:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We first use the program to dump all the resource limits. Then, we query the
    file-size resource limit, modify it (lower it from unlimited to about 512 KB using
    `ulimit`), and run the program again, which reflects the change.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用程序来转储所有资源限制。然后，我们查询文件大小资源限制，修改它（使用`ulimit`将其从无限制降低到约512 KB），然后再次运行程序，这反映了更改。
- en: Now for the second program; given a CPU resource limit (in seconds), we run
    a simple prime number generator under the influence of that CPU resource limit.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在到第二个程序；给定CPU资源限制（以秒为单位），我们在该CPU资源限制的影响下运行一个简单的质数生成器。
- en: For readability, relevant parts of the source code (the relevant source file
    is `ch3/rlimit_primes.c`) are shown.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，源代码的相关部分（相关源文件是`ch3/rlimit_primes.c`）被展示出来。
- en: 'Here is the simple prime number generator function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的质数生成函数：
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is the function to set up the CPU resource limit to the parameter passed,
    which is the time in seconds:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设置CPU资源限制为传递的参数（以秒为单位的时间）的函数：
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the following code, we first just do a quick test run—we print the first
    100 primes and leave the CPU resource limit value untouched (it typically defaults
    to infinite). Then we invoke it to print the first 90,000 primes with five seconds
    of CPU time available to it. As expected (on modern hardware), both succeed:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们首先进行了一个快速测试运行——我们打印了前100个质数，并且没有改变CPU资源限制的值（它通常默认为无限）。然后我们调用它来打印前90,000个质数，只允许它使用五秒的CPU时间。正如预期的那样（在现代硬件上），两者都成功了：
- en: '[PRE19]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now for the fun part: we invoke `rlimit_primes` to print the first 200,000
    primes with only one second of CPU time available to it; this time it fails (note
    that we redirect standard output to a temporary file, so that we are not distracted
    by all the output):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在到了有趣的部分：我们调用`rlimit_primes`来打印前200,000个质数，只允许它使用一秒的CPU时间；这次它失败了（请注意，我们将标准输出重定向到临时文件，以免被所有输出分散注意力）：
- en: '[PRE20]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Why did it fail? Obviously, the CPU resource limit—just one second—was too small
    a time for it to complete the given task; when the process attempted to exceed
    this limit, it was killed by the kernel.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么它失败了？显然，CPU资源限制——只有一秒——对于完成给定任务来说时间太短了；当进程试图超过这个限制时，它被内核终止。
- en: 'A note to advanced readers: one can use the very powerful and versatile `perf(1)`
    Linux utility to see this too:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级读者的一点提示：可以使用非常强大和多功能的`perf(1)` Linux实用程序来查看这一切：
- en: '`$ sudo **perf stat** ./rlimit_primes 200000 1 >/tmp/prm`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ sudo **perf stat** ./rlimit_primes 200000 1 >/tmp/prm`'
- en: '`./rlimit_primes: **Killed**`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`./rlimit_primes: **被终止**`'
- en: '`Performance counter stats for ''./rlimit_primes 200000 1'':`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`./rlimit_primes 200000 1`的性能计数器统计：'
- en: '`  1001.917484   task-clock (msec)  # 0.999 CPUs utilized`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`  1001.917484   任务时钟（毫秒）  # 0.999个CPU被利用`'
- en: '`           17   context-switches   # 0.017 K/sec`'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`           17   上下文切换   # 0.017 K/秒`'
- en: '`            1   cpu-migrations     # 0.001 K/sec`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`            1   cpu迁移     # 0.001 K/秒`'
- en: '`           51   page-faults        # 0.051 K/sec`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`           51   页面错误        # 0.051 K/秒`'
- en: '`3,018,577,481   cycles             # 3.013 GHz`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`3,018,577,481   周期         # 3.013 GHz`'
- en: '`5,568,202,738   instructions       # 1.84 insn per cycle`'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`5,568,202,738   指令       # 每个周期1.84条指令`'
- en: '`  982,845,319   branches           # 980.964 M/sec`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`  982,845,319   分支           # 980.964百万/秒`'
- en: '`       88,602   branch-misses      # 0.01% of all branches`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`       88,602   分支失效      # 所有分支的0.01%`'
- en: '`**1.002659905 seconds time elapsed**`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`**1.002659905秒的时间流逝**`'
- en: '`$`'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`'
- en: Permanence
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 永久性
- en: We've demonstrated that, within its operational framework, one can indeed query
    and set per-process resource limits using frontends, such as `ulimit, prlimit(1)`, as
    well as programmatically via library and system call APIs. However, the changes
    we wrought are temporary—for that process's life or the session's life only. How
    does one make a resource limit value change permanent?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经证明，在其操作框架内，确实可以使用前端（如`ulimit, prlimit(1)`）以及通过库和系统调用API以编程方式查询和设置每个进程的资源限制。然而，我们所做的更改是临时的——只在该进程的生命周期或会话的生命周期内有效。如何使资源限制值的更改变得永久？
- en: The Unix way is to use (ASCII-text) configuration files that reside on the filesystem.
    In particular, on most Linux distributions, editing the `/etc/security/limits.conf`
    configuration file is the answer. We shall not delve further into the details
    here; if interested, check out the man page on `limits.conf(5)`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Unix的方式是使用（ASCII文本）配置文件，这些文件驻留在文件系统上。特别是在大多数Linux发行版上，编辑`/etc/security/limits.conf`配置文件是答案。我们不会在这里进一步探讨细节；如果感兴趣，请查看`limits.conf(5)`的man页面。
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter initially delved into the motivation behind per-process resource
    limits and why we require them. We also explained the granularity and the types
    of resource limits, distinguishing between soft and hard limits. Then we looked
    at how a user (or system administrator) can query and set the per-process resource
    limits using appropriate CLI frontends (`ulimit(1)`, `prlimit(1)`).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先深入探讨了每个进程资源限制背后的动机以及我们为什么需要它们。我们还解释了资源限制的粒度和类型，区分了软限制和硬限制。然后我们看了用户（或系统管理员）如何使用适当的CLI前端（`ulimit(1)`，`prlimit(1)`）查询和设置每个进程的资源限制。
- en: Finally, we explored the programming interfaces (APIs)—practically speaking,
    the `prlimit(2)` system call—in detail. Two detailed code examples, querying the
    limits and setting a limit on CPU usage, rounded out the discussion.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们详细探讨了编程接口（API）——实际上是`prlimit(2)`系统调用。两个详细的代码示例，查询限制和设置CPU使用限制，为讨论画上了句号。
- en: In the next chapter, we will learn about the crucial, dynamic memory-management
    APIs and their correct usage. We'll go well beyond the basics of using the typical
    `malloc()` API, delving into a few subtle and important inner details.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关键的动态内存管理API及其正确的使用方法。我们将远远超越使用典型的`malloc()` API的基础知识，深入一些微妙而重要的内部细节。
