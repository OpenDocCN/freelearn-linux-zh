- en: Writing a Simple misc Character Device Driver
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个简单的杂项字符设备驱动程序
- en: No doubt, device drivers are a vast and interesting topic. Not only that, they
    are perhaps the most common use of the **Loadable Kernel Module** (**LKM**) framework
    that we have been using. Here, we shall introduce you to writing a few simple
    yet complete Linux character device drivers, within a class called `misc`; yes,
    that's short for miscellaneous. We wish to emphasize that this chapter is limited
    in its scope and coverage - here, we do not attempt to delve into the deep details
    regarding the Linux driver model and its many frameworks; instead, we refer you
    to several excellent books and tutorials on this topic via the *Further reading *section
    for this chapter. Our aim here is to quickly get you familiar with the overall
    concepts behind writing a simple character device driver.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，设备驱动程序是一个广阔而有趣的话题。不仅如此，它们可能是我们使用的**可加载内核模块**（**LKM**）框架中最常见的用途。在这里，我们将介绍如何编写一些简单但完整的Linux字符设备驱动程序，这些驱动程序属于一个名为`misc`的类；是的，这是杂项的缩写。我们希望强调的是，本章的范围和覆盖范围有限
    - 在这里，我们不试图深入探讨Linux驱动程序模型及其许多框架的细节；相反，我们建议您通过本章的*进一步阅读*部分参考这个主题的几本优秀的书籍和教程。我们的目标是快速让您熟悉编写简单字符设备驱动程序的整体概念。
- en: Having said that, this book indeed has several chapters that are dedicated to
    what a driver author needs to know. Besides this introductory chapter, we cover
    (in detail) how a driver author works with hardware I/O memory, hardware interrupt
    handling (and its many sub-topics), and kernel mechanisms such as delays, timers,
    kernel threads, and work queues. Use of various user-kernel communication pathways
    or interfaces is covered in detail as well. The final two chapters of this book
    then focus on something very important for any kernel development, including drivers
    – kernel synchronization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，这本书确实有几章专门介绍驱动程序作者需要了解的内容。除了这个介绍性的章节，我们还详细介绍了驱动程序作者如何处理硬件I/O内存、硬件中断处理（以及其许多子主题）以及内核机制，如延迟、定时器、内核线程和工作队列。各种用户-内核通信路径或接口的使用也得到了详细介绍。本书的最后两章则专注于对于任何内核开发，包括驱动程序，都非常重要的内容
    - 内核同步。
- en: 'The other reasons we''d prefer to write a simple Linux *character* *device
    driver* and not just our "usual" kernel module are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更喜欢编写一个简单的Linux *字符* *设备驱动程序*，而不仅仅是我们的“常规”内核模块，原因如下：
- en: Until now, our kernel modules have been quite simplistic, having only `init` and `cleanup` functions,
    nothing more. A device driver provides *several* entry points into the kernel;
    these are the file-related system calls, known as the *driver's methods*. So,
    we can have an `open()` method, a `read()` method, a `write()` method, an `llseek()` method,
    an `[unlocked|compat]_ioctl()` method, a `release()` method, and so on.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们的内核模块相当简单，只有`init`和`cleanup`函数，没有其他内容。设备驱动程序为内核提供了*多个*入口点；这些是与文件相关的系统调用，称为*驱动程序的方法*。因此，我们可以有一个`open()`方法，一个`read()`方法，一个`write()`方法，一个`llseek()`方法，一个`[unlocked|compat]_ioctl()`方法，一个`release()`方法等等。
- en: FYI, all possible "methods" (functions) the driver author can hook into are
    in this key kernel data structure: `include/linux/fs.h:file_operations` (more
    on this in the *Understanding the connection between the process, the driver,
    and the kernel *section).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: FYI，驱动程序作者可以连接的所有可能的“方法”（函数）都在这个关键的内核数据结构中：`include/linux/fs.h:file_operations`（在*理解进程、驱动程序和内核之间的连接*部分中会更详细地介绍）。
- en: This situation is simply more realistic, and more interesting.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种情况更加现实，也更加有趣。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting started with writing a simple misc character device driver
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始编写一个简单的杂项字符设备驱动程序
- en: Copying data from kernel to user space and vice versa
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从内核到用户空间的数据复制，反之亦然
- en: A misc driver with a secret
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有秘密的杂项驱动程序
- en: Issues and security concerns
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题和安全问题
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: I assume that you have gone through the *Preface* section *To get the most out
    of this book*, and have appropriately prepared a guest VM running Ubuntu 18.04
    LTS (or a later stable release) and installed all the required packages. If not,
    I highly recommend you do this first. To get the most out of this book, I strongly
    recommend you first set up the workspace environment, including cloning this book's
    GitHub repository for the code, and work on it in a hands-on fashion. The repository
    can be found here:[ https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/ch1).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设您已经阅读了*前言*部分*为了充分利用本书*，并且已经适当地准备了一个运行Ubuntu 18.04 LTS（或更高版本稳定发布版）的虚拟机，并安装了所有必需的软件包。如果没有，我强烈建议您首先这样做。为了充分利用本书，我强烈建议您首先设置好工作环境，包括克隆本书的GitHub代码库，并以实际操作的方式进行工作。代码库可以在这里找到：[https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/ch1)。
- en: Getting started with writing a simple misc character device driver
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始编写一个简单的杂项字符设备驱动程序
- en: In this section, you will first learn the required background material – understanding
    the basics of the device file (or node) and its hierarchy. After that, you will
    learn – by actually writing the code of a very simple `misc` character driver
    – the kernel framework behind the raw character device driver. Along the way,
    we shall cover how to create the device node(s) and test the driver via a user
    space app. Let's get started!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将首先学习所需的背景材料 - 了解设备文件（或节点）及其层次结构的基础知识。之后，您将通过实际编写一个非常简单的`misc`字符驱动程序的代码来了解原始字符设备驱动程序背后的内核框架。在此过程中，我们将介绍如何创建设备节点并通过用户空间应用程序测试驱动程序。让我们开始吧！
- en: Understanding the device basics
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解设备基础知识
- en: Some quick background is in order.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一些快速的背景知识。
- en: A **device driver** is the interface between the OS and a peripheral hardware
    device. It can be written inline – that is, compiledwithin the kernel image file
    – or, more commonly, written outside of the kernel source tree as a kernel module
    (we covered the LKM framework in detail in the companion guide *Linux Kernel Programming,* *Chapter
    4*, *Writing Your First Kernel Module – LKMs Part 1*, and *Chapter 5*, *Writing
    Your First Kernel Module – LKMs Part 2*). Either way, the driver code certainly
    runs at OS privilege, in kernel space (user space device drivers do exist, but
    can suffer performance issues; while useful in many circumstances, we don't cover
    them here. Take a look at the *Further reading *section).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备驱动程序**是操作系统和外围硬件设备之间的接口。它可以内联编写 - 也就是说，编译在内核映像文件中 - 或者更常见的是在内核源树之外编写为内核模块（我们在伴随指南*Linux内核编程*的*第4章*，*编写您的第一个内核模块
    - LKMs第1部分*和*第5章*，*编写您的第一个内核模块 - LKMs第2部分*中详细介绍了LKM框架）。无论哪种方式，驱动程序代码肯定在操作系统特权级别下在内核空间中运行（用户空间设备驱动程序确实存在，但可能存在性能问题；虽然在许多情况下很有用，但我们在这里不涉及它们。请查看*进一步阅读*部分）。'
- en: In order for a user space application to gain access to the underlying device
    driver within the kernel, some I/O mechanism is required. The Unix (and thus Linux)
    design is to have the process open a special type of file – a **device file**,
    or **device node**. These files typically live in the `/dev` directory, and on
    modern systems are dynamic and auto-populated. The device node serves as an entry
    point into the device driver.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户空间应用程序能够访问内核中的底层设备驱动程序，需要一些I/O机制。Unix（因此也是Linux）的设计是让进程打开一种特殊类型的文件 - **设备文件**或**设备节点**。这些文件通常位于`/dev`目录中，并且在现代系统中是动态和自动填充的。设备节点作为设备驱动程序的入口点。
- en: 'In order for the kernel to distinguish between device files, it uses two attributes
    within their inode data structure:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让内核区分设备文件，它在它们的inode数据结构中使用了两个属性：
- en: The type of file – either character (char) or block
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件类型 - 字符（char）或块
- en: The major and minor number
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要和次要编号
- en: You will see that the **namespace** – the device type and the `{major#, minor#}`
    pair – form a **hierarchy**. Devices (and thus their drivers) are organized within
    a tree-like hierarchy within the kernel (the driver core code within the kernel
    takes care of this). The hierarchy is first divided based on device type – block
    or char. Within that, we have some *n* major numbers for each type, and each major
    number is further classified via some *m* minor numbers; *Figure 1.1* shows this
    hierarchy.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现**命名空间** - 设备类型和`{major＃，minor＃}`对 - 形成**层次结构**。设备（因此它们的驱动程序）在内核中以树状层次结构组织（内核中的驱动程序核心代码负责此操作）。首先根据设备类型进行层次划分
    - 块或字符。在其中，每种类型都有一些*n*个主要编号，每个主要编号通过一些*m*个次要编号进一步分类；*图1.1*显示了这种层次结构。
- en: 'Now, the key difference between block and character devices is that block devices
    have the (kernel-level) capability to be mountedand thus become part of the user-accessible
    filesystem. Character devices cannot be mounted; thus, storage devices tend to
    be block-based. Think of it this way (a bit simplistic but useful): if the (hardware)
    device is not storage, nor a network device, then it''s a character device. A
    huge number of devices fall into the ''character'' class, including your typical
    I2C/SPI (Inter Integrated Circuit / Serial Peripheral Interface) sensor chips
    (temperature, pressure, humidity, and so on), touchscreens, **Real-Time Clock** (**RTC**),
    media (video, camera, audio), keyboards, mice, and so on. USB forms a class within
    the kernel for infrastructure support. USB devices can be block devices (pen drives,
    USB disks), character devices (mice, keyboard, camera) or network (USB dongles)
    devices.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，块设备和字符设备之间的关键区别在于块设备具有（内核级）能力进行挂载，因此成为用户可访问的文件系统的一部分。字符设备无法挂载；因此，存储设备倾向于基于块。以这种方式考虑（有点简单但有用）：如果（硬件）设备既不是存储设备也不是网络设备，那么它就是字符设备。大量设备属于“字符”类，包括您典型的I2C/SPI（集成电路/串行外围接口）传感器芯片（温度、压力、湿度等）、触摸屏、**实时时钟**（**RTC**）、媒体（视频、摄像头、音频）、键盘、鼠标等。USB在内核中形成了一个基础设施支持的类。USB设备可以是块设备（U盘、USB磁盘）、字符设备（鼠标、键盘、摄像头）或网络（USB
    dongles）设备。
- en: 'From 2.6 Linux onward, the `{major:minor}` pair is a single unsigned 32-bit
    quantity within the inode, a bitmask (it''s the `dev_t i_rdev` member). Of these
    32 bits, the MSB 12 bits represent the major number and the remaining LSB 20 bits
    represent the minor number. A quick calculation shows that there can therefore
    be up to 2^(12) = 4,096 major numbers and 2^(20), which is one million, minor
    numbers per major number. So, glance at *Figure 1.1*; within the block hierarchy,
    there are a possible 4,096 majors, each of which can have up to 1 million minors.
    Similarly, within the character hierarchy, there are a possible 4,096 majors,
    each of which can have up to 1 million minors:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从Linux 2.6开始，`{major:minor}`对是inode中的一个单个无符号32位数量，一个位掩码（它是`dev_t i_rdev`成员）。在这32位中，最高12位表示主要编号，剩下的最低20位表示次要编号。快速计算表明，因此可以有多达2^(12)
    = 4,096个主要编号和2^(20)个次要编号，即一百万个次要编号。因此，快速查看*图1.1*；在块层次结构中，可能有4,096个主要编号，每个主要编号最多可以有1百万个次要编号。同样，在字符层次结构中，可能有4,096个主要编号，每个主要编号最多可以有1百万个次要编号。
- en: '![](img/8443be53-6cc9-4d81-9522-26c8b89e34cc.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8443be53-6cc9-4d81-9522-26c8b89e34cc.png)'
- en: Figure 1.1 – The device namespace or hierarchy
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 - 设备命名空间或层次结构
- en: 'You may be wondering: what exactly does this *major:minor* number pair really
    mean? Think of the major number as representing the **class**of the device (is
    it a SCSI disk, a keyboard, a **teletype terminal** (**tty**) or **pseudo-terminal**
    (**pty**) device, a loopback device (yes, these are pseudo-hardware devices),
    a joystick, a tape device, a framebuffer, a sensor chip, a touchscreen, and so
    on?). There''s indeed an enormous range of devices; to get a sense of just how
    many, we urge you to check out the kernel documentation here: [https://www.kernel.org/doc/Documentation/admin-guide/devices.txt](https://www.kernel.org/doc/Documentation/admin-guide/devices.txt)
    (it''s literally the official registry of all available devices for the Linux
    OS. It''s formally called the **LANANA** – the **Linux Assigned Names And Numbers
    Authority**! Only these folks can officially assign the device node – the type
    and *major:minor* numbers – to devices).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：这个*主要号:次要号*对到底意味着什么？把主要号想象成代表设备的**类别**（它是SCSI磁盘，键盘，**电传打字机**（**tty**）或**伪终端**（**pty**）设备，回环设备（是的，这些是伪硬件设备），操纵杆，磁带设备，帧缓冲器，传感器芯片，触摸屏等等的设备类别）。确实有大量的设备；为了了解有多少，我们建议你查看这里的内核文档：[https://www.kernel.org/doc/Documentation/admin-guide/devices.txt](https://www.kernel.org/doc/Documentation/admin-guide/devices.txt)（这实际上是Linux操作系统所有可用设备的官方注册表。它正式称为**LANANA**
    - **Linux分配的名称和编号管理机构**！只有这些人才能正式分配设备节点 - 类型和*主要号:次要号*到设备）。
- en: The minor number's meaning (interpretation) is left completely to the driver
    author; the kernel does not interfere. Typically, the driver interprets the device's
    minor number to represent either a physical or logical instance of the device,
    or to represent a certain functionality. (For example, the **Small Computer System
    Interface** (**SCSI**) driver – of type block, major `#8` – uses minor numbers
    to represent logical disk partitions for up to 16 disks. On the other hand, character
    major `#119` is used by VMware's virtual network control driver. Here, the minors
    are interpreted as the first virtual network, second virtual network, and so on.)
    Similarly, all drivers themselves assign meaning to their minor numbers. But every
    good rule has an exception. Here, the exception to the rule - that the kernel
    doesn't interpret the minor number – is the `misc` class (type character, major
    `#10`). It uses the minor numbers as second-level majors. This will be covered
    in the following section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 次要号的含义（解释）完全由驱动程序的作者决定；内核不会干涉。通常，驱动程序解释设备的次要号，表示设备的物理或逻辑实例，或表示某种功能。（例如，**小型计算机系统接口**（**SCSI**）驱动程序
    - 类型为块，主要号`#8` - 使用次要号表示多达16个磁盘的逻辑分区。另一方面，字符主要号`#119`由VMware的虚拟网络控制驱动程序使用。在这里，次要号被解释为第一个虚拟网络，第二个虚拟网络，依此类推。）同样，所有驱动程序本身都会为它们的次要号分配含义。但是每个好的规则都有例外。在这里，规则的例外
    - 内核不解释次要号 - 是`misc`类（类型为字符，主要号`#10`）。它使用次要号作为第二级主要号。这将在下一节中介绍。
- en: A common problem is that of the namespace getting exhausted. A decision taken
    years back "collects" various miscellaneous character devices - a lot of mice
    (no, not of the animal kingdom variety), sensors, touchscreens, and so on - into
    one class called the `misc` or '**miscellaneous**' class, which is assigned character
    major number `10`. Within the `misc` class live a lot of devices and their corresponding
    drivers. In effect, they share the same major number and rely on a unique minor
    number to identify themselves. We shall write a few drivers using precisely this
    class and leveraging the kernel's 'misc' framework.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的问题是命名空间的耗尽。多年前做出的决定将各种各样的杂项字符设备 - 许多鼠标（不是动物王国的那种），传感器，触摸屏等等 - “收集”到一个称为`misc`或'**杂项**'类的类中，分配字符主要号为10。在`misc`类中有许多设备及其对应的驱动程序。实际上，它们共享相同的主要号，并依赖于唯一的次要号来识别自己。我们将使用这个类编写一些驱动程序，并利用内核的“misc”框架。
- en: 'Many devices have already been assigned via the **LANANA (Linux Assigned Names
    And Numbers Authority)** into the `misc` character device class. *Figure 1.2*
    shows a partial screenshot from [https://www.kernel.org/doc/Documentation/admin-guide/devices.txt](https://www.kernel.org/doc/Documentation/admin-guide/devices.txt)
    showing the first few `misc` devices, their assigned minor numbers, and a brief
    description. Do see the reference link for the full list:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 许多设备已经通过**LANANA（Linux分配的名称和编号管理机构）**分配到了`misc`字符设备类中。*图1.2*显示了来自[https://www.kernel.org/doc/Documentation/admin-guide/devices.txt](https://www.kernel.org/doc/Documentation/admin-guide/devices.txt)的部分截图，显示了前几个`misc`设备，它们分配的次要号和简要描述。请查看参考链接获取完整列表：
- en: '![](img/a7dd011e-66e6-48a7-be40-7e7a4bd61a5e.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7dd011e-66e6-48a7-be40-7e7a4bd61a5e.png)'
- en: 'Figure 1.2 – Partial screenshot of misc devices: char type, major # 10'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 - 杂项设备的部分截图：字符类型，主要号10
- en: In *Figure 1.2*, the leftmost column has `10 char`, specifying that it's assigned
    major `# 10` under the character type of the device hierarchy (*Figure 1.1*).
    The columns to the right are in the form `minor# = /dev/<foo>     <description>`;
    quite obviously, this is the minor number assigned followed by (after the `=`
    sign) the device node and a one-line description.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图1.2*中，最左边的一列有`10 char`，指定它在设备层次结构（*图1.1*）下分配了主要的`# 10`。右边的列是以`minor# = /dev/<foo>
    <description>`的形式；很明显，这是分配的次要号，后面跟着（在`=`号之后）设备节点和一行描述。
- en: A quick note on the Linux Device Model
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于Linux设备模型的简短说明
- en: 'Without going into great detail, a quick overview of the modern unified **Linux
    Device Model** (**LDM**) is important. Modern Linux, from the 2.6 kernel onward,
    has a fantastic feature, the LDM, which achieves many goals to do with the system
    and the devices on it in one broad and bold stroke. Among its many features, it
    creates a complex hierarchical tree unifying system components, all peripheral
    devices, and their drivers. This very tree is exposed to user space via the sysfs
    pseudo-filesystem (analogous to how procfs exposes some kernel and process/thread
    internal details to user space) and is typically mounted under `/sys`. Within
    `/sys`, you will find several directories – you can consider them to be "viewports"
    into the LDM. On our x86_64 Ubuntu VM, we show the sysfs filesystem mounted under `/sys`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不详细介绍，现代统一的Linux设备模型（LDM）的快速概述是重要的。从2.6内核开始，现代Linux具有一个奇妙的功能，即LDM，它以一种广泛和大胆的方式实现了许多与系统和其中的设备有关的目标。在其许多功能中，它创建了一个复杂的分层树，统一了系统组件、所有外围设备及其驱动程序。这个树被暴露给用户空间，通过sysfs伪文件系统（类似于procfs将一些内核和进程/线程内部细节暴露给用户空间），通常挂载在/sys下。在/sys下，您会找到几个目录-您可以将它们视为LDM的“视口”。在我们的x86_64
    Ubuntu VM上，我们展示了挂载在/sys下的sysfs文件系统：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Furthermore, take a peek inside:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，看一眼里面：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Think of these directories as viewports into the LDM – different ways of viewing
    the devices on the system. Of course, as things evolve, more tends to get in than
    get out (the bloat aspect!). Several non-obvious directories have now made their
    way in here. Though (as with procfs) sysfs is officially documented as an **Application
    Binary Interface** (**ABI**) interface, that's subject to change/deprecation at
    any time; the reality is that this system is there to stay – and evolve, of course
    – over time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些目录视为LDM的视口-查看系统上设备的不同方式。当然，随着事物的发展，进入的东西往往比出去的多（膨胀方面！）。一些非明显的目录现在已经进入了这里。尽管（与procfs一样）sysfs被正式记录为应用程序二进制接口（ABI）接口，但这是可能随时更改/弃用的；现实情况是这个系统会一直存在-当然会随着时间的推移而发展。
- en: 'The LDM, a bit simplistically, can be thought of as having – and tying together
    – these major components:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: LDM可以被简单地认为具有-并将这些主要组件联系在一起-这些主要组件：
- en: The **buses** on the system.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统上的总线。
- en: The **devices** on them.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们上的设备。
- en: The **device drivers** that drive the devices (also often referred to as **client**
    drivers).
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动设备的设备驱动程序（通常也称为客户端驱动程序）。
- en: 'A fundamental LDM tenet is that ***every single device must reside on a bus***.
    This might seem obvious: USB devices will be on the USB bus, PCI devices on the
    PCI bus, I2C devices on the I2C bus, and so on. Thus, under the `/sys/bus` hierarchy,
    you will be able to literally "see" all the devices via the buses that they reside
    on:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的LDM原则是***每个设备都必须驻留在总线上***。这可能看起来很明显：USB设备将在USB总线上，PCI设备将在PCI总线上，I2C设备将在I2C总线上，依此类推。因此，在/sys/bus层次结构下，您将能够通过它们所驻留的总线“看到”所有设备：
- en: '![](img/52912a35-54ca-415f-8d53-6e566e2f2054.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/52912a35-54ca-415f-8d53-6e566e2f2054.png)'
- en: Figure 1.3 – The different buses or bus driver infrastructure on modern Linux
    (on an x86_64)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3-现代Linux上的不同总线或总线驱动程序基础设施（在x86_64上）
- en: 'The kernel''s driver core provides bus drivers (that are (typically) either
    part of the kernel image itself or auto-loaded at boot as required), which, of
    course, makes the buses do their job. What is their job? Critically, they organize
    and recognize the devices on them. If a new device surfaces (perhaps you plugged
    in a pen drive), the USB bus driver will recognize the fact and bind it to its
    (USB mass storage) device driver! Once successfully bound (many terms are used
    to describe this: bound, enumerated, discovered), the kernel driver framework
    invokes the registered `probe()` method (function) of the driver. This probe method
    now sets up the device, allocating resources, IRQs, memory setup, registering
    it as required, and so on.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 内核的驱动程序核心提供总线驱动程序（通常是内核映像的一部分或根据需要在引导时自动加载），这当然使总线发挥作用。它们的工作是什么？至关重要的是，它们组织和识别上面的设备。如果出现新设备（也许您插入了一个U盘），USB总线驱动程序将识别这一事实并将其绑定到其（USB大容量存储）设备驱动程序！一旦成功绑定（有许多术语用于描述这一点：绑定、枚举、发现），内核驱动程序框架将调用驱动程序的注册probe（）方法（函数）。现在，这个探测方法设置设备，分配资源、IRQ、内存设置，根据需要注册它等等。
- en: 'Another key aspect to understand regarding the LDM is that the modern LDM-based
    driver should typically do the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于LDM的另一个关键方面是，现代基于LDM的驱动程序通常应该执行以下操作：
- en: Register itself to a (specialized) kernel framework.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向（专门的）内核框架注册。
- en: Register itself to a bus.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向总线注册。
- en: The kernel framework it registers itself to depends on the type of device you
    are working with; for example, a driver for an RTC chip that resides on the I2C
    bus will register itself to the kernel's RTC framework (via the `rtc_register_device()`
    API) and to the I2C bus (internally via the `i2c_register_driver()` API). On the
    other hand, a driver for a network adapter (a NIC) on the PCI bus will typically
    register itself to the kernel's network infrastructure (via the `register_netdev()`
    API) and the PCI bus (via the `pci_register_driver()` API). Registering with a
    specialized kernel framework makes your job as a driver author a lot easier –
    the kernel will often provide helper routines (and even data structures) to take
    care of I/O details, and so on. For example, take the previously mentioned RTC
    chip driver.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它注册自己的内核框架取决于您正在处理的设备类型；例如，驻留在I2C总线上的RTC芯片的驱动程序将通过rtc_register_device（）API将自己注册到内核的RTC框架，并通过i2c_register_driver（）API将自己注册到I2C总线（内部）。另一方面，驻留在PCI总线上的网络适配器（NIC）的驱动程序通常会通过register_netdev（）API将自己注册到内核的网络基础设施，并通过pci_register_driver（）API将自己注册到PCI总线。向专门的内核框架注册可以使驱动程序作者的工作变得更加容易-内核通常会提供辅助例程（甚至数据结构）来处理I/O细节等。例如，考虑先前提到的RTC芯片驱动程序。
- en: You needn't know the details of how to communicate with the chip over the I2C
    bus, bit banging out data on the **Serial Clock** (**SCL**)/**Serial Data** (**SDA**)
    lines as the I2C protocol demands. The kernel I2C bus framework provides you with
    convenience routines (such as the typically used `i2c_smbus_*()` APIs) that let
    you quite effortlessly communicate over the bus to the chip in question!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要知道如何通过I2C总线与芯片进行通信，在I2C协议要求的**串行时钟**（**SCL**）/**串行数据**（**SDA**）线上发送数据。内核I2C总线框架为您提供了方便的例程（例如通常使用的`i2c_smbus_*()`API），让您可以轻松地与问题芯片进行总线通信！
- en: 'If you''re wondering how to get more information on these driver APIs, here''s
    the good news: the official kernel documentation has plenty to offer. Do look
    up *The Linux driver implementer’s API guide* here: [https://www.kernel.org/doc/html/latest/driver-api/index.html](https://www.kernel.org/doc/html/latest/driver-api/index.html).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道如何获取有关这些驱动程序API的更多信息，好消息是：官方的内核文档有很多内容可供参考。请查阅*Linux驱动程序实现者API指南*：[https://www.kernel.org/doc/html/latest/driver-api/index.html](https://www.kernel.org/doc/html/latest/driver-api/index.html)。
- en: (We do show some examples of the `probe()` method of a driver in the following
    two chapters; until then, patience, please.) Conversely, when the device is detached
    from the bus or the kernel module is unloaded (or the system is shutting down),
    the detach causes the driver's `remove()` (or `disconnect()`) method to be invoked.
    Between these, the work of the device via its drivers (both bus and client) is
    carried out!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: （我们将在接下来的两章中展示驱动程序的`probe()`方法的一些示例；在那之前，请耐心等待。）相反，当设备从总线上分离或内核模块被卸载（或系统关闭时），分离会导致驱动程序的`remove()`（或`disconnect()`）方法被调用。在这两者之间，设备通过其驱动程序（总线和客户端）进行工作！
- en: Please note that we are glossing over a lot of the inner details here, as they
    are beyond the scope of this book. The point is to give you a conceptual understanding
    of the LDM. Do refer to the articles and links in the *Further reading *section
    for more detailed information.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里忽略了很多内部细节，因为它们超出了本书的范围。重点是让你对LDM有一个概念性的理解。请参考*进一步阅读*部分的文章和链接，以获取更详细的信息。
- en: 'Here, we wish to keep our driver coverage very simple and minimal, focusing
    more on the underlying basics. Hence we have chosen to write a driver that uses
    perhaps the simplest kernel framework – the `misc` or *miscellaneous* kernel framework.
    In this case, the driver doesn''t even need to explicitly register with any bus
    (driver). In fact, it''s more like this: our driver works *directly on the hardware*
    without the need for any particular bus infrastructure support.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们希望保持我们的驱动程序覆盖范围非常简单和最小化，更专注于基本原理。因此，我们选择编写一个使用可能是最简单的内核框架 - `misc`或*杂项*内核框架的驱动程序。在这种情况下，驱动程序甚至不需要显式地向任何总线（驱动程序）注册。事实上，更像是这样：我们的驱动程序直接在硬件上工作，而无需任何特定的总线基础设施支持。
- en: 'In our particular example using the `misc`kernel framework, since we don''t
    explicitly register with any bus (driver), we don''t even require the `probe()`/`remove()` methods.
    This keeps things simple. On the other hand, once you have understood this simplest
    of drivers, I encourage you to go further and look at writing device drivers with
    the typical kernel framework registration plus bus driver registration, thus employing
    the `probe()`/`remove()` methods. A good way to get started is to learn how to
    write a simple **platform driver**, registering it with the kernel''s `misc`framework
    and the *platform bus*, a pseudo-bus infrastructure that supports devices that
    do not physically reside on any physical bus (this is more common than you might
    at first imagine; several peripherals built into a modern **System on Chip** (**SoC**)
    are not on any physical bus, and thus their drivers are typically platform drivers).
    To get started, look under the kernel source tree in `drivers/` for code invoking
    the `platform_driver_register()` API. The official kernel documentation here covers
    platform devices and drivers: [https://www.kernel.org/doc/html/latest/driver-api/driver-model/platform.html#platform-devices-and-drivers](https://www.kernel.org/doc/html/latest/driver-api/driver-model/platform.html#platform-devices-and-drivers).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们特定的示例中，使用`misc`内核框架，由于我们没有显式地向任何总线（驱动程序）注册，因此我们甚至不需要`probe()`/`remove()`方法。这使得事情变得简单。另一方面，一旦你理解了这种最简单的驱动程序，我鼓励你进一步学习，尝试编写具有典型内核框架注册加总线驱动程序注册的设备驱动程序，从而使用`probe()`/`remove()`方法。一个很好的开始是学习如何编写一个简单的**平台驱动程序**，将其注册到内核的`misc`框架和*平台总线*，这是一个伪总线基础设施，支持不在任何物理总线上的设备（这比你最初想象的要常见得多；现代**SoC**（**系统芯片**）内置的几个外围设备不在任何物理总线上，因此它们的驱动程序通常是平台驱动程序）。要开始，请在内核源树中的`drivers/`目录下查找调用`platform_driver_register()`
    API的代码。官方的内核文档在这里涵盖了平台设备和驱动程序：[https://www.kernel.org/doc/html/latest/driver-api/driver-model/platform.html#platform-devices-and-drivers](https://www.kernel.org/doc/html/latest/driver-api/driver-model/platform.html#platform-devices-and-drivers)。
- en: 'As additional help, note the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的帮助，请注意以下内容：
- en: '- Do refer to [Chapter 2](4042025e-27a1-40f4-a2f7-223f601107dc.xhtml), *User-Kernel
    Communication Pathways*, particularly the *Creating a simple platform device* and *Platform
    devices* sections.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '- 请参阅[第2章](4042025e-27a1-40f4-a2f7-223f601107dc.xhtml)，*用户-内核通信路径*，特别是*创建一个简单的平台设备*和*平台设备*部分。'
- en: '- An exercise (see the *Questions *section) for this chapter is to write such
    a driver. I have provided a sample (and very simple) implementation here: `solutions_to_assgn/ch12/misc_plat/`.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '- 本章的一个练习（请参阅*问题*部分）是编写这样的驱动程序。我在这里提供了一个示例（非常简单的实现）：`solutions_to_assgn/ch12/misc_plat/`。'
- en: 'We do, however, require the kernel''s `misc` framework support, and thus we
    register ourselves with it. Next, it''s also key to understand this: our driver
    is a logical one, in the sense that there''s no actual physical device or chip
    that it''s driving. This is quite often the case (of course, you could say that
    here, the hardware being worked upon is RAM).'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们确实需要内核的`misc`框架支持，因此我们向其注册。接下来，理解这一点也很关键：我们的驱动程序是逻辑驱动程序，意味着它没有实际的物理设备或芯片在驱动。这通常是情况（当然，您可以说这里正在处理的硬件是RAM）。
- en: So, if we are to write a Linux character device driver belonging to this `misc` class,
    we will first need to register ourselves to it. Next, we will be in need of a
    unique (unused) minor number. Again, there is a way to have the kernel dynamically
    assign a free minor number to us. The following section covers these aspects and
    more.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们要编写属于`misc`类的Linux字符设备驱动程序，我们首先需要向其注册。接下来，我们将需要一个唯一（未使用的）次编号。同样，有一种方法可以让内核动态地为我们分配一个空闲的次编号。以下部分涵盖了这些方面以及更多内容。
- en: Writing the misc driver code – part 1
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写misc驱动程序代码-第1部分
- en: Without further ado, let's look at the code to write a simple skeleton character
    `misc` device driver! (Well, snippets of the actual code; as always, I strongly
    advise you to `git clone` the book's GitHub repository, view it in detail, and
    try out the code yourself.)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 话不多说，让我们来看一下编写一个简单骨架字符`misc`设备驱动程序的代码吧！（当然，这只是部分实际代码；我强烈建议您`git clone`本书的GitHub存储库，详细查看并尝试自己编写代码。）
- en: 'Let''s go through it step by step: in the `init` code of our first device driver
    (using the LKM framework), we must first **register**ourdriver with the appropriate
    Linux kernel''s framework; in this case, with the `misc`framework. This is done
    via the `misc_register()` API. It takes one parameter, a pointer to a data structure
    of type `miscdevice`, which describes the miscellaneous device we are setting
    up:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步来看：在我们的第一个设备驱动程序（使用LKM框架）的`init`代码中，我们必须首先使用适当的Linux内核框架向其注册我们的驱动程序；在这种情况下，使用`misc`框架。这是通过`misc_register()`API完成的。它接受一个参数，即指向`miscdevice`类型的数据结构的指针，描述了我们正在设置的杂项设备：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `miscdevice` structure instance, we do the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`miscdevice`结构实例中，我们进行了以下操作：
- en: We set the `minor` field to `MISC_DYNAMIC_MINOR`. This has the effect of requesting
    the kernel to dynamically assign us an available minor number (once registration
    is successful, this `minor` field gets populated with the actual minor number
    assigned).
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`minor`字段设置为`MISC_DYNAMIC_MINOR`。这会请求内核在成功注册后动态为我们分配一个可用的次编号（一旦注册成功，此`minor`字段将填充为分配的实际次编号）。
- en: We initialize the `name` field. On successful registration, this has the kernel
    framework automatically create a device node (of the form `/dev/<name>`) on our
    behalf! As expected, the type will be character, the major number will be `10`,
    and the minor number will be a dynamically assigned value. This is (part of) the
    advantage of using a kernel framework;  else, we might have had to devise a way
    to create the device node ourselves; by the way, the `mknod(1)` utility can create
    a device file when invoked with root privilege (or you have the `CAP_MKNOD` capability);
    it works by invoking the `mknod(2)` system call!
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们初始化了`name`字段。在成功注册后，内核框架会自动为我们创建一个设备节点（形式为`/dev/<name>`）！如预期的那样，类型将是字符，主编号将是`10`，次编号将是动态分配的值。这是使用内核框架的优势之一；否则，我们可能需要想办法自己创建设备节点；顺便说一下，`mknod(1)`实用程序可以在具有root权限（或具有`CAP_MKNOD`权限）时创建设备文件；它通过调用`mknod(2)`系统调用来工作！
- en: The permissions of the device node will be set to whatever you initialize the
    `mode` field to (here, we've deliberately kept it permissive and readable-writeable
    by all via the `0666` octal value).
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备节点的权限将设置为您初始化`mode`字段的值（在这里，我们故意保持它是宽松的，并且通过`0666`八进制值对所有人可读可写）。
- en: We shall postpone the discussion of the file operations (`fops`) structure member
    to the section following this one.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将推迟讨论文件操作（`fops`）结构成员的讨论到接下来的部分。
- en: All `misc` drivers are of the character type and use the same major number (`10`),
    but of course require unique minor numbers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`misc`驱动程序都是字符类型，并使用相同的主编号（`10`），但当然需要唯一的次编号。
- en: Understanding the connection between the process, the driver, and the kernel
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解进程、驱动程序和内核之间的连接。
- en: Here, we will delve into just a bit of the kernel internals surrounding the
    successful registration of a character device driver on Linux. In effect, you
    will come to understand the workings of the underlying raw character driver framework.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将深入了解Linux上字符设备驱动程序成功注册时的内核内部。实际上，您将了解底层原始字符驱动程序框架的工作原理。
- en: 'The `file_operations` structure, or the **fops**(pronounced *eff-opps*), as
    it''s commonly referred to, is of critical importance to driver authors; the majority
    of the members of the fops structure are function pointers – think of them as **virtual
    methods***.* They represent all possible file-related system calls that could
    be issued on a (device) file. So, it has `open`*, *`read`*,* `write`*,* `poll`*,*
    `mmap`*,* `release`*,* and several more members (most of which are function pointers). A
    few of the members of this critical data structure are shown here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`file_operations`结构，或者通常称为**fops**（发音为*eff-opps*），对于驱动程序作者来说至关重要；`fops`结构的大多数成员都是函数指针-将它们视为**虚方法**。它们代表了可能在（设备）文件上发出的所有可能的与文件相关的系统调用。因此，它有`open`、`read`、`write`、`poll`、`mmap`、`release`等多个成员（其中大多数是函数指针）。这个关键数据结构的一些成员在这里显示出来：'
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A key job of the driver author (or the underlying kernel framework) is to populate
    these function pointers, thus linking them to actual code within the driver. You
    needn't implement every single function, of course; please refer to the *Handling
    unsupported methods* section for details.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序作者（或底层内核框架）的一个关键工作是填充这些函数指针，从而将它们链接到驱动程序中的实际代码。当然，您不需要实现每个单独的函数；请参考“处理不支持的方法”部分了解详情。
- en: 'Now, let''s assume you have written your driver to set up functions for some
    of the `f_op` methods. Once your driver is registered with the kernel, typically
    via a kernel framework, when any user space process (or thread) opens a device
    file registered to this driver, the kernel **Virtual Filesystem Switch** (**VFS**) layer
    will take over. Without going into deep detail, suffice it to say that the VFS
    allocates and initializes that process''s open filedata structure (`struct file`)
    for the device file. Now, recall the last line in our `struct miscdevice` initialization;
    it''s this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您已经编写了驱动程序来为一些`f_op`方法设置函数。一旦您的驱动程序通过内核框架注册到内核中，当任何用户空间进程（或线程）打开注册到该驱动程序的设备文件时，内核**虚拟文件系统开关**（**VFS**）层将接管。不深入细节，可以说VFS为设备文件分配并初始化了该进程的打开文件数据结构（`struct
    file`）。现在，回想一下我们`struct miscdevice`初始化中的最后一行；它是这样的：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This line of code has a key effect: it ties the process''s file operations
    pointer (which is within the process'' open file structure) to the device driver''s
    file operations structure. The *functionality – what the driver will do –* is
    now set up for this device file!'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码有一个关键的作用：它将进程的文件操作指针（在进程的打开文件结构中）与设备驱动程序的文件操作结构绑定在一起。*功能性 - 驱动程序将执行的操作 -
    *现在已经为此设备文件设置好了！
- en: 'Let''s flesh this out. Now (after your driver has initialized itself),  a user-mode
    process opens your driver''s device file, by issuing the `open(2)` system call
    on it. Assuming all goes well (and it should), the process is now connected to
    your driver via the `file_operations` structure pointers deep inside the kernel. Here''s
    a critical point: after the `open(2)` system call returns successfully, and the
    process issues any file-related system call `foo()` on that (device) file, the
    kernel VFS layer will, be having in an object-oriented fashion (we have pointed
    this out before in this book!), blindly and trustingly invoke the registered **`fops->foo()`** method!The
    file opened by the user space process, typically a device file in `/dev`, is internally
    represented by the `struct file` metadata structure (a pointer to this, `struct
    file *filp`, is passed along to the driver). So, in terms of pseudo-code, when
    user space issues a file-related system call `foo()`, this is what the kernel
    VFS layer effectively does:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细说明一下。现在（在驱动程序初始化之后），用户模式进程通过对其发出`open(2)`系统调用来打开驱动程序的设备文件。假设一切顺利（应该如此），进程现在通过内核深处的`file_operations`结构指针连接到您的驱动程序。这里有一个关键点：在`open(2)`系统调用成功返回后，进程在该（设备）文件上发出任何与文件相关的系统调用`foo()`，内核VFS层将以面向对象的方式（我们在本书中之前已经指出过！）盲目地并信任地调用已注册的**`fops->foo()`**方法！用户空间进程打开的文件，通常是`/dev`中的设备文件，由`struct
    file`元数据结构在内部表示（指向此结构的指针`struct file *filp`被传递给驱动程序）。因此，在伪代码方面，当用户空间发出与文件相关的系统调用`foo()`时，内核VFS层实际上执行以下操作：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Thus, if the user space process that opened a device file invokes the `read(2)`
    system call upon it, the kernel VFS will invoke `filp->f_op->read(...)`, in effect,
    redirecting control to the device driver. Your job as the device driver author
    is to provide the functionality of `read(2)`! The same goes for all other file-related
    system calls. This, essentially, is how Unix and Linux implement the well-known
    *if it's not a process, it's a file design* principle.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果打开设备文件的用户空间进程在其上调用`read(2)`系统调用，内核VFS将调用`filp->f_op->read(...)`，实际上将控制权重定向到设备驱动程序。作为设备驱动程序作者，您的工作是提供`read(2)`的功能！对于所有其他与文件相关的系统调用也是如此。这基本上是Unix和Linux实现的众所周知的*如果不是进程，就是文件设计*原则。
- en: Handling unsupported methods
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理不支持的方法
- en: You don't have to populate every member of the `f_ops` structure, only those
    that your driver supports. If that's the case, and you have populated a few methods
    but left out, say, the `poll` method, and a user space process invokes `poll(2)`
    on your device (perhaps you've documented the fact that it's not supposed to,
    but what if it does?), then what will happen? In cases like this, the kernel VFS,
    detecting that the `foo` pointer (in this example, `poll`) is `NULL`, returns
    an appropriate negative integer (in effect, following the same `0`/`-E` protocol).
    The `glibc` code will multiply this by `-1` and set the calling process's `errno` variable
    to that value, signaling that the system call failed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不必填充`f_ops`结构的每个成员，只需填充驱动程序支持的成员。如果是这种情况，并且您已经填充了一些方法但遗漏了，比如`poll`方法，如果用户空间进程在您的设备上调用`poll(2)`（也许您已经记录了它不应该这样做，但如果它这样做了呢？），那么会发生什么？在这种情况下，内核VFS检测到`foo`指针（在本例中为`poll`）为`NULL`，将返回适当的负整数（实际上，遵循相同的`0`/`-E`协议）。`glibc`代码将这个数乘以`-1`，并将调用进程的`errno`变量设置为该值，表示系统调用失败。
- en: 'Two points to be aware of:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意的两点：
- en: Quite often, the negative `errno` value returned by the VFS isn't very intuitive.
    (For example, if you've set the `read()` function pointer of `f_op` to `NULL`,
    the VFS causes the `EINVAL` value to be sent back. This has the user space process
    think that `read(2)` failed because of an `"Invalid argument"` error, which simply
    isn't the case at all!)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VFS返回的负`errno`值通常并不直观。（例如，如果您将`f_op`的`read()`函数指针设置为`NULL`，VFS会导致发送回`EINVAL`值。这使得用户空间进程认为`read(2)`失败是因为`"无效参数"`错误，但实际上根本不是这种情况！）
- en: 'The `lseek(2)` system call has the driver seek to a prescribed location in
    the file – here, of course, we mean in the device. The kernel deliberately names
    the `f_op` function pointer as `llseek` (notice the two ''`l`''s). This is simply
    to remind you that the return value from `lseek` can be a 64-bit (long long) quantity.
    Now, for the majority of hardware devices, the `lseek` value is not meaningful,
    thus most drivers do not need to implement it (unlike filesystems). Now, the issue
    is this: even if you do not support `lseek` (you''ve set the `llseek` member of
    `f_op` to `NULL`), it still returns a random positive value, thus causing the
    user-mode app to incorrectly conclude that it succeeded. Hence, if you aren''t
    implementing `lseek`, you are to do the following:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lseek(2)`系统调用使驱动程序在文件中的指定位置寻址 - 当然，这里指的是设备。内核故意将`f_op`函数指针命名为`llseek`（注意两个`l`）。这只是为了提醒您，`lseek`的返回值可以是64位（long
    long）数量。现在，对于大多数硬件设备，`lseek`值是没有意义的，因此大多数驱动程序不需要实现它（不像文件系统）。现在问题是：即使您不支持`lseek`（您已将`f_op`的`llseek`成员设置为`NULL`），它仍然返回一个随机的正值，从而导致用户模式应用错误地得出它成功了的结论。因此，如果您不实现`lseek`，您需要执行以下操作：'
- en: Explicitly set `llseek` to the special `no_llseek` value, which will cause a
    failure value (`-ESPIPE`; `illegal seek`) to be returned.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`llseek`明确设置为特殊的`no_llseek`值，这将导致返回一个失败值（`-ESPIPE`；`非法寻址`）。
- en: In such cases, you are to also invoke the `nonseekable_open()` function in your
    driver's `open()` method, specifying that the file is non-seekable (this is often
    called like this in the `open()` method: `return nonseekable_open(struct inode
    *inode, struct file *filp);`. The details, and more, are covered in the LWN articles
    here: [https://lwn.net/Articles/97154/](https://lwn.net/Articles/97154/). You
    can see the changes this wrought to many drivers here: [https://lwn.net/Articles/97180/](https://lwn.net/Articles/97180/)).
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，您还需要在驱动程序的`open()`方法中调用`nonseekable_open()`函数，指定文件是不可寻址的（通常在`open()`方法中这样调用：`return
    nonseekable_open(struct inode *inode, struct file *filp);`）。有关详细信息等，均在LWN文章中有所涵盖：[https://lwn.net/Articles/97154/](https://lwn.net/Articles/97154/)。您可以在此处看到这对许多驱动程序造成的更改：[https://lwn.net/Articles/97180/](https://lwn.net/Articles/97180/)。
- en: An appropriate value to return if you aren't supporting a function is `-ENOSYS`,
    which will have the user-mode process see the error `Function not implemented` (when
    it invokes the `perror(3)` or `strerror(3)` library APIs). This is clear, unambiguous;
    the user space developer will now understand that your driver does not support
    this function. Thus, one way to implement your driver is to set up pointers to
    all the file operation methods, and write a routine for all file-related system
    calls (the `f_op` methods) in your driver. For the ones you do support, write
    the code; for the ones you do not implement, just return the value `-ENOSYS`.
    Though a bit painstaking to do, it will result in unambiguous return values to
    user space.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不支持某个功能，返回的适当值是`-ENOSYS`，这将使用户模式进程看到错误`Function not implemented`（当它调用`perror(3)`或`strerror(3)`库API时）。这是清晰的，明确的；用户空间开发人员现在将了解到您的驱动程序不支持此功能。因此，实现驱动程序的一种方法是为所有文件操作方法设置指针，并为驱动程序中的所有文件相关系统调用（`f_op`方法）编写例程。对于您支持的功能，编写代码；对于您未实现的功能，只需返回值`-ENOSYS`。虽然这样做有点费力，但它将导致用户空间的明确返回值。
- en: Writing the misc driver code – part 2
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写misc驱动程序代码 - 第2部分
- en: 'Armed with this knowledge, look again at the `init` code of `ch1/miscdrv/miscdrv.c`.
    You will see that, just as described in the previous section, we have initialized
    the `fops` member of the `miscdev` struct to a `file_operations` structure, thus
    setting up the functionality of the driver. The relevant code snippet (from our
    driver) is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了这些知识后，再次查看`ch1/miscdrv/miscdrv.c`的`init`代码。您将看到，就像在上一节中描述的那样，我们已将`miscdev`结构的`fops`成员初始化为`file_operations`结构，从而设置了驱动程序的功能。驱动程序的相关代码片段如下：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, now you can see it: when a user space process (or thread) that has opened
    our device file invokes, say, a `read(2)` system call, the kernel VFS layer will
    follow the pointers (generically, `filp->f_op->foo()`) and invoke the function, `read_miscdrv()`,
    in effect handing over control to the device driver! How exactly the read method
    is written is covered in the next section.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在您可以看到：当打开我们的设备文件的用户空间进程（或线程）调用`read(2)`系统调用时，内核VFS层将跟随指针（通用地，`filp->f_op->foo()`）并调用`read_miscdrv()`函数，实际上将控制权交给设备驱动程序！有关读取方法的编写方式将在下一节中介绍。
- en: 'Continuing with the `init`code of our simple `misc` driver:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们简单的`misc`驱动程序的`init`代码：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our driver retrieves a pointer to the `device` structure – it's something required
    by every driver. Within the `misc` kernel framework, it's available within the `this_device` member
    of our `miscdevice` structure.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的驱动程序检索到`device`结构的指针 - 这是每个驱动程序都需要的东西。在`misc`内核框架中，它在`miscdevice`结构的`this_device`成员中可用。
- en: 'Next, `pr_info()` shows the minor number dynamically obtained. The `dev_info()`
    helper routine is more interesting: as a driver author, you are **expected to
    use these `dev_xxx()` helpers** when emitting `printk`; it will also prefix useful
    information about the device. The only difference in syntax between the `dev_xxx()`
    and `pr_xxx()` helpers is that the first parameter to the former is the pointer
    to the device structure.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`pr_info()`显示动态获取的次要号。`dev_info()`辅助例程更有趣：作为驱动程序作者，**您应该在发出`printk`时使用这些`dev_xxx()`辅助程序**；它还将为设备添加有用的信息前缀。`dev_xxx()`和`pr_xxx()`辅助程序之间的语法唯一的区别是前者的第一个参数是指向设备结构的指针。
- en: 'Okay, let''s get our hands dirty! We build the driver and `insmod` it into
    kernel space (we use our `lkm` helper script to do so):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们开始动手吧！我们构建驱动程序并将其`insmod`到内核空间（我们使用我们的`lkm`辅助脚本来执行）：
- en: '![](img/eef5c47b-24ea-480d-9ca9-c520c1f96fb0.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eef5c47b-24ea-480d-9ca9-c520c1f96fb0.png)'
- en: Figure 1.4 – Screenshot of building and loading our miscdrv.ko skeleton misc
    driver on an x86_64 Ubuntu VM
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 - 在x86_64 Ubuntu VM上构建和加载我们的miscdrv.ko骨架misc驱动程序的屏幕截图
- en: '(By the way, as you can see in *Figure 1.4*, I tried out this `misc` driver
    on a more recent distro: Ubuntu 20.04.1 LTS running the 5.4.0-58-generic kernel.)
    Notice the two prints toward the bottom of *Figure 1.4*; the first is emitted
    via the `pr_info()` (prefixed with the `pr_fmt()` macro content, as explained
    in the companion guide *Linux Kernel Programming -* *Chapter 4, Writing Your First
    Kernel Module - LKMs Part 1* section *Standardizing printk output via the pr_fmt
    macro*). The second print is emitted via the `dev_info()` helper routine – it''s
    prefixed with the words `misc llkd_miscdrv`, indicating that it originated from
    the kernel''s `misc` framework, and specifically from the `llkd_miscdrv` device!
    (The `dev_xxx()` routines are versatile; depending on the bus they''re on, they
    will display various details. This is useful for debugging and logging purposes.
    We repeat: you''re recommended to use the `dev_*()` routines when writing drivers.)
    You can also see that the `/dev/llkd_miscdrv` device node is indeed created, with
    the expected type (character) and major and minor pair (10 and 56 here).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: （顺便说一句，正如你在*图1.4*中看到的，我在一个更新的发行版Ubuntu 20.04.1 LTS上运行了5.4.0-58-generic内核的`misc`驱动程序。）请注意*图1.4*底部的两个打印；第一个是通过`pr_info()`发出的（前缀是`pr_fmt()`宏的内容，如*Linux内核编程-第4章，编写你的第一个内核模块-LKMs第1部分*中的*通过pr_fmt宏标准化printk输出*部分所解释的）。第二个打印是通过`dev_info()`辅助例程发出的-它的前缀是`misc
    llkd_miscdrv`，表示它来自内核的`misc`框架，具体来说是来自`llkd_miscdrv`设备！（`dev_xxx()`例程是多功能的；根据它们所在的总线，它们将显示各种细节。这对于调试和日志记录很有用。我们再次重申：在编写驱动程序时，建议使用`dev_*()`例程。）你还可以看到`/dev/llkd_miscdrv`设备节点确实被创建了，具有预期的类型（字符）和主次对（这里是10和56）。
- en: Writing the misc driver code – part 3
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写杂项驱动程序代码-第3部分
- en: Now, the `init` code is done, the driver functionality has been set up via the
    file operations structure, and the driver is registered to the kernel `misc` framework. So,
    what happens next? Well, nothing really, until a process opens the device file
    (associated with your driver) and performs I/O (Input/Output, i.e., reads/writes)
    of some sort.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`init`代码已经完成，驱动程序功能已经通过文件操作结构设置好，并且驱动程序已经注册到内核的`misc`框架中。那么，接下来会发生什么呢？实际上，除非一个进程打开与你的驱动程序相关的设备文件并执行某种输入/输出（I/O，即读/写）操作，否则什么也不会发生。
- en: 'So, let''s assume that a user-mode process (or thread) issues the `open(2)`
    system call on your driver''s device node (recall, the device node has been auto-created
    when the driver registered itself to the kernel''s `misc` framework). Most important,
    as you learned in the *Understanding the connection between the process, the driver,
    and the kernel* section, for any file-related system calls issued upon your device
    node, the VFS will essentially invoke the driver''s (`f_op`) registered method.
    So, here, the VFS will do this: `filp->f-op->open()`, thus invoking our driver''s
    `open` method within our `file_operations` structure, which is the `open_miscdrv()` function!'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们假设一个用户模式进程（或线程）在你的驱动程序的设备节点上发出`open(2)`系统调用（回想一下，当驱动程序向内核的`misc`框架注册时，设备节点已经被自动创建）。最重要的是，正如你在*理解进程、驱动程序和内核之间的连接*部分学到的那样，对于在你的设备节点上发出的任何与文件相关的系统调用，VFS基本上会调用驱动程序的（`f_op`）注册方法。因此，在这里，VFS将执行这样的操作：`filp->f-op->open()`，从而在我们的`file_operations`结构中调用我们的驱动程序的`open`方法，即`open_miscdrv()`函数！
- en: 'But how should you, the driver author, implement this code of the `open` method
    of your driver? The key point is this: the signature of your `open` function **should
    be identical** to that of the `file_operation` structure `open`; in fact, this
    is true of any function. Thus, we implement the `open_miscdrv()` function like
    this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，作为驱动程序作者，你应该如何实现你的驱动程序的`open`方法的代码呢？关键点在于：你的`open`函数的签名**应该与**`file_operation`结构的`open`完全相同；实际上，对于任何函数都是如此。因此，我们实现`open_miscdrv()`函数如下：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice how the signature of our `open` routine, the `open_miscdrv()` function,
    precisely matches that of the `f_op` structure's `open` function pointer (you
    can always lookup the `file_operations` structure for 5.4 Linux here at [https://elixir.bootlin.com/linux/v5.4/source/include/linux/fs.h#L1814](https://elixir.bootlin.com/linux/v5.4/source/include/linux/fs.h#L1814)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们的`open`例程`open_miscdrv()`函数的签名如何与`f_op`结构的`open`函数指针完全匹配（你可以随时在[https://elixir.bootlin.com/linux/v5.4/source/include/linux/fs.h#L1814](https://elixir.bootlin.com/linux/v5.4/source/include/linux/fs.h#L1814)查找5.4
    Linux的`file_operations`结构）。
- en: In this simple driver, in our `open` method, we don't really have much to do.
    We allocate some memory for a buffer (to hold the pathname of our device) via
    `kzalloc()`, issue our `PRINT_CTX()` macro (it's in the `convenient.h` header)
    to show the current context – the process that is currently opening the device.
    We then emit a `printk` (via `pr_info()`) showing a few VFS layer details (the
    pathname and open flags value); you can get the path name of a file by using the
    convenience API `file_path()`, as we do here (to do so, we need to allocate and,
    after usage, free a kernel memory buffer). Then, as we don't support seeking in
    this driver, we invoke the `nonseekable_open()` API (as discussed in the *Handling
    unsupported methods* section).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的驱动程序中，在我们的`open`方法中，我们实际上没有太多事情要做。我们通过`kzalloc()`为缓冲区（用于保存设备路径名）分配一些内存，使用我们的`PRINT_CTX()`宏（在`convenient.h`头文件中）显示当前上下文-当前正在打开设备的进程。然后我们通过`pr_info()`发出一个`printk`显示一些VFS层的细节（路径名和打开标志值）；你可以使用方便的API
    `file_path()`来获取文件的路径名，就像我们在这里做的一样（为此，我们需要分配并在使用后释放内核内存缓冲区）。然后，由于这个驱动程序不支持寻址，我们调用`nonseekable_open()`
    API（如*处理不支持的方法*部分所讨论的）。
- en: 'The `open(2)` system call on the device file should succeed. The user-mode
    process will now have a valid file descriptor – a handle to the open file (which,
    here, is actually a device node). Now, let''s say the user-mode process wants
    to read data from the hardware; it therefore issues the `read(2)` system call.
    As explained already, the kernel VFS will now auto-invoke our driver''s read method,
    `read_miscdrv()`. Again, its signature exactly imitates the read function signature
    from the `file_operations` data structure. Here''s the simple code of our driver''s
    read method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对设备文件的`open(2)`系统调用应该成功。用户模式进程现在将拥有一个有效的文件描述符 - 打开文件的句柄（这里实际上是一个设备节点）。现在，假设用户模式进程想要从硬件中读取数据；因此，它发出`read(2)`系统调用。如前所述，内核VFS现在将自动调用我们的驱动程序的读取方法`read_miscdrv()`。再次强调，它的签名完全模仿了`file_operations`数据结构中的读取函数签名。这是我们驱动程序读取方法的简单代码：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding comment is self-explanatory. Within it, we emit `pr_info()`, showing
    the number of bytes the user space process wants to read. Then, we simply return
    the number of bytes read, implying success! In reality, we have done (essentially)
    nothing. The remaining driver methods are quite similar.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的评论是不言自明的。在其中，我们发出`pr_info()`，显示用户空间进程想要读取的字节数。然后，我们简单地返回读取的字节数，意味着成功！实际上，我们（基本上）什么都没做。其余的驱动程序方法非常相似。
- en: Testing our simple misc driver
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们简单的misc驱动程序
- en: 'Let''s test our really simple skeleton `misc` character driver (in the `ch1/miscdrv`
    directory; we assume you have built and inserted it as shown in *Figure 1.4*).
    We test it by issuing `open(2)`, `read(2)`, `write(2)`, and `close(2)` system
    calls upon it; how exactly can we do so? We can always write a small C program
    to do precisely this, but an easier way is to use the useful  `dd(1)` "disk duplicator"
    utility. We use it like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试我们真正简单的骨架`misc`字符驱动程序（在`ch1/miscdrv`目录中；我们假设您已经按照*图1.4*中所示构建并插入了它）。我们通过对其发出`open(2)`、`read(2)`、`write(2)`和`close(2)`系统调用来测试它；我们应该如何做呢？我们总是可以编写一个小的C程序来精确地做到这一点，但更简单的方法是使用有用的`dd(1)`“磁盘复制”实用程序。我们像这样使用它：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Internally `dd` opens the file we pass it as a parameter (`/dev/llkd_miscdrv`)
    via `if=` (here, it''s the first parameter to `dd`; `if=` specifies the input
    file), it will read from it (via the `read(2)` system call, of course). The output
    is to be written to the file specified by the parameter `of=` (the second parameter
    to `dd`, and is a regular file named `readtest`); the `bs` specifies the block
    size to perform I/O in and `count` is the number of times to perform I/O). After
    performing the required I/O, the `dd` process will `close(2)` the files. This
    sequence is reflected in the kernel log (*Figure 1.5*):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 内部`dd`通过`if=`（这里是`dd`的第一个参数；`if=`指定输入文件）打开我们传递给它的文件（`/dev/llkd_miscdrv`），它将从中读取（通过`read(2)`系统调用，当然）。输出将被写入由参数`of=`指定的文件（`dd`的第二个参数，是一个名为`readtest`的常规文件）；`bs`指定要执行I/O的块大小，`count`是要执行I/O的次数）。完成所需的I/O后，`dd`进程将`close(2)`这些文件。这个顺序反映在内核日志中（*图1.5*）：
- en: '![](img/9c0a7520-4795-4889-b8c2-6117c7f1b00f.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c0a7520-4795-4889-b8c2-6117c7f1b00f.png)'
- en: Figure 1.5 – Screenshot showing us minimally testing our miscdrv driver's read
    method via dd(1)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 - 屏幕截图显示我们通过dd(1)最小化测试了miscdrv驱动程序的读取方法
- en: After verifying that our driver (LKM) is inserted, we issue the `dd(1)` command,
    having it read 4,096 bytes from our device (as the block size (`bs`) is set to
    `4k` and `count` to `1`). We have it write the output (via the `of=` option switch)
    to a file named `readtest`. Looking up the kernel log, you can see (*Figure 1.5*)
    that the `dd` process has indeed opened our device (our `PRINT_CTX()` macro's
    output shows that it's the process context currently running the code of our driver!).
    Next, we can see (via the output from `pr_fmt()`) that control goes to our driver's
    read method, within which we emit a simple `printk` and return the value 4096
    signifying success (though we really didn't read anything!). The device is then
    closed by `dd`. Furthermore, a quick check with the `hexdump(1)` utility reveals
    that we did indeed receive `0x1000` (4,096) nulls (as expected) from the driver
    (in the file `readtest`; do realize that this is the case because `dd` initialized
    it's read buffer to `NULL`s).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证我们的驱动程序（LKM）已插入后，我们发出`dd(1)`命令，让它从我们的设备中读取4,096字节（因为块大小（`bs`）设置为`4k`，`count`设置为`1`）。我们让它通过`of=`选项开关将输出写入一个名为`readtest`的文件。查看内核日志，您可以看到（*图1.5*）`dd`进程确实已经打开了我们的设备（我们的`PRINT_CTX()`宏的输出显示，它是当前运行我们驱动程序代码的进程上下文！）。接下来，我们可以看到（通过`pr_fmt()`的输出）控制转到我们驱动程序的读取方法，在其中我们发出一个简单的`printk`并返回值4096，表示成功（尽管我们实际上并没有读取任何东西！）。然后，设备被`dd`关闭。此外，使用`hexdump(1)`实用程序进行快速检查，我们确实从驱动程序（在文件`readtest`中；请意识到这是因为`dd`将其读取缓冲区初始化为`NULL`）接收到了`0x1000`（4,096）个空值（如预期的那样）。
- en: The `PRINT_CTX()` macro we have used within the code lives within our `convenient.h` header.
    Do take a look; it's quite instructive (we try and emulate the kernel `Ftrace` infrastructure's latency
    output format, which reveals a lot of detail in a small space, a single line of
    output). This is explained in detail in [Chapter 4](cfd1ca5d-cd0b-451d-8a35-31e65a09d2e4.xhtml),
    *Handling Hardware Interrupts*, in the *Fully figuring out the context* section.
    Don't worry about all the details for now...
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码中使用的`PRINT_CTX()`宏位于我们的`convenient.h`头文件中。请看一下；它非常有教育意义（我们尝试模拟内核`Ftrace`基础设施的`latency
    output`格式，它在一个小空间内显示了很多细节，一行输出）。这在[第4章](cfd1ca5d-cd0b-451d-8a35-31e65a09d2e4.xhtml)中的*处理硬件中断*部分中有详细说明。现在不要担心所有的细节...
- en: '*Figure 1.6* shows how we (minimally) test writing to our driver, again via
    `dd(1)`. This time we read `4k` of random data (by leveraging the kernel''s built-in `mem`
    driver''s `/dev/urandom` facility), and write the random data to our device node;
    in effect, to our ''device'':'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.6*显示了我们（最小化地）通过`dd(1)`测试写入我们的驱动程序。这次我们通过利用内核内置的`mem`驱动程序的`/dev/urandom`功能，读取了`4k`的随机数据，并将随机数据写入我们的设备节点；实际上，写入我们的“设备”：'
- en: '![](img/3bf0f7e7-4cc3-49a7-a935-1bc099c22e46.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3bf0f7e7-4cc3-49a7-a935-1bc099c22e46.png)'
- en: Figure 1.6 – Screenshot showing us minimally testing our miscdrv driver's write
    method via dd(1)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 - 屏幕截图显示我们通过dd(1)最小化测试我们的miscdrv驱动程序的写入方法
- en: '(By the way, I have also included a simple user space test app for the driver;
    it can be found here: `ch1/miscdrv/rdwr_test.c`. I will leave it to you to read
    its code and try out.)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: （顺便说一句，我还包括了一个简单的用户空间测试应用程序用于驱动程序；可以在这里找到：`ch1/miscdrv/rdwr_test.c`。我会留给你阅读它的代码并尝试。）
- en: 'You might be thinking: we did apparently succeed in reading and writing data
    to and from user space to our driver, but, hang on, we never actually saw any data
    transfer taking place within the driver code. Yes, this is the topic of the next
    section: how you will actually copy the data from the user space process buffer
    into your kernel driver''s buffer, and vice versa. Read on!'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：我们显然成功地从用户空间向驱动程序读取和写入数据，但是，等等，我们实际上从未在驱动程序代码中看到任何数据传输发生。是的，这是下一节的主题：您将如何实际将数据从用户空间进程缓冲区复制到内核驱动程序的缓冲区，反之亦然。继续阅读！
- en: Copying data from kernel to user space and vice versa
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据从内核空间复制到用户空间，反之亦然
- en: A primary job of the device driver is to enable user space applications to transparently
    both read and write data to the peripheral hardware device (typically a chip of
    some sort; it may not be hardware at all though), treating the device as though
    it were simply a regular file. Thus, to read data from the device, the application
    opens the device file corresponding to that device, thus obtaining a file descriptor,
    and then simply issues a `read(2)` system call using that `fd` (*step 1* in *Figure
    1.7)*! The kernel VFS intercepts the read, and, as we have seen, has control flow
    to the underlying device driver's read method (which is a C function, of course).
    The driver code now "talks" to the hardware device, actually performing the I/O,
    the read operation. (The specifics of how exactly the hardware read (or write)
    is performed depends very much on the type of hardware – is it a memory-mapped
    device, a port, a network chip, and so on? We will not delve further into this
    here; the next chapter does.) The driver, having read data from the device, now
    places this data into a kernel buffer, `kbuf` (*step 2* in the following diagram.
    Of course, we assume the driver author allocated memory for it via `[k|v]malloc()`
    or another suitable kernel API).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 设备驱动程序的一个主要工作是使用户空间应用程序能够透明地读取和写入外围硬件设备的数据（通常是某种芯片；虽然它可能根本不是硬件），将设备视为普通文件。因此，要从设备读取数据，应用程序打开与该设备对应的设备文件，从而获得文件描述符，然后简单地使用该`fd`发出`read(2)`系统调用（*图1.7*中的*步骤1*）！内核VFS拦截读取，并且，正如我们所见，控制流到底层设备驱动程序的读取方法（当然是一个C函数）。驱动程序代码现在与硬件设备"通信"，实际执行I/O，读取操作。（确切地说，硬件读取（或写入）的具体方式取决于硬件的类型——它是内存映射设备、端口、网络芯片等等？我们将在这里不再深入讨论；下一章会讲到。）驱动程序从设备读取数据后，现在将这些数据放入内核缓冲区`kbuf`（以下图中的*步骤2*。当然，我们假设驱动程序作者通过`[k|v]malloc()`或其他适当的内核API为其分配了内存）。
- en: We now have the hardware device data in a kernel space buffer. How should we
    transfer it to the user space process's memory buffer? We shall exploit kernel
    APIs that make it easy to do so; this is covered next.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在内核空间缓冲区中有硬件设备数据。我们应该如何将其传输到用户空间进程的内存缓冲区？我们将利用使这变得容易的内核API，下面将介绍这一点。
- en: Leveraging kernel APIs to perform the data transfer
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用内核API执行数据传输
- en: 'Now, as mentioned previously, let''s assume your driver has read in the hardware
    data, and that it''s now present in a kernel memory buffer. How do we transfer
    it to user space? A naive approach would be to simply try and perform this via
    `memcpy()`, but *no, *that does not work (why? one, it''s insecure and two, it''s
    very arch-dependent; it works on some architectures and not on others). So, a
    key point: the kernel provides a couple of inline functions to transfer data from
    kernel to user space and vice versa. They are `copy_to_user()` and `copy_from_user()`,
    respectively, and are indeed very commonly used.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如前所述，让我们假设您的驱动程序已经读取了硬件数据，并且现在它存在于内核内存缓冲区中。我们如何将它传输到用户空间？一个天真的方法是简单地尝试通过`memcpy()`来执行这个操作，但*不，*那不起作用（为什么？一，它是不安全的，二，它非常依赖架构；它在一些架构上工作，在其他架构上不工作）。因此，一个关键点：内核提供了一对内联函数来在内核空间和用户空间之间传输数据。它们分别是`copy_to_user()`和`copy_from_user()`，并且确实非常常用。
- en: 'Using them is simple. Both take three parameters: the `to`pointer (destination
    buffer), the `from`pointer (source buffer), and `n`, the number of bytes to copy
    (think of it as you would for a `memcpy` operation):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它们很简单。两者都接受三个参数：`to`指针（目标缓冲区），`from`指针（源缓冲区）和`n`，要复制的字节数（将其视为`memcpy`操作）：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The return value is the number of *uncopied* bytes; in other words, a return
    value of `0` indicates success and a non-zero return value indicates that the
    given number of bytes were not copied. If a non-zero return occurs, you should
    (following the usual `0/-E` return convention) return an error indicating an I/O
    fault by returning `-EIO` or `-EFAULT` (which thus sets `errno` in user space
    to the positive counterpart). The following (pseudo) code illustrates how a device
    driver can use the `copy_to_user()` function to copy some data from kernel to
    user space:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值是未复制的字节数；换句话说，返回值为`0`表示成功，非零返回值表示未复制给定数量的字节。如果发生非零返回，您应该（遵循通常的`0/-E`返回约定）返回一个错误，指示I/O故障，返回`-EIO`或`-EFAULT`（这样在用户空间设置`errno`的正数对应值）。以下（伪）代码说明了设备驱动程序如何使用`copy_to_user()`函数将一些数据从内核复制到用户空间：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, of course, we assume you have a valid allocated kernel memory buffer, `kbuf`,
    and a valid device pointer (`struct device *dev`). *Figure 1.7* illustrates what
    the preceding (pseudo) code is trying to achieve:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当然，我们假设您有一个有效的分配的内核内存缓冲区`kbuf`，以及一个有效的设备指针（`struct device *dev`）。*图1.7*说明了前面（伪）代码试图实现的内容：
- en: '![](img/2ddabab1-d742-40ea-992e-89083c8e7fdd.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ddabab1-d742-40ea-992e-89083c8e7fdd.png)'
- en: 'Figure 1.7 – Read: copy_to_user(): copying data from the hardware to a kernel
    buffer and from there to a user space buffer'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7-读取：copy_to_user()：将数据从硬件复制到内核缓冲区，然后复制到用户空间缓冲区
- en: The same semantics apply to using the `copy_from_user()` inline function. It
    is typically used in the context of the driver's write method, pulling in the
    data written by the user space process context to a kernel space buffer. We will
    leave it to you to visualize this.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`copy_from_user()`内联函数的语义也适用。它通常用于驱动程序的写入方法，将用户空间进程上下文中写入的数据拉入内核空间缓冲区。我们将让您自行想象这一点。
- en: It is also important to realize that both routines (`copy_[from|to]_user()`)
    might, during their run, cause the process context to (page) fault and thus sleep;
    in other words, to invoke the scheduler. Hence, **they can only be used in a process
    context where it's safe to sleep and never in any kind of atomic or interrupt
    context** (we explain more on the `might_sleep()` helper – a debug aid – in [Chapter
    4](cfd1ca5d-cd0b-451d-8a35-31e65a09d2e4.xhtml), *Handling Hardware Interrupts*,
    in the *Don't block – spotting possibly blocking code** paths* section).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 同样重要的是要意识到，这两个例程（`copy_[from|to]_user()`）在运行过程中可能会导致进程上下文（页面）故障，从而休眠；换句话说，调用调度程序。因此，**它们只能在安全休眠的进程上下文中使用，绝不能在任何类型的原子或中断上下文中使用**（我们在[第4章](cfd1ca5d-cd0b-451d-8a35-31e65a09d2e4.xhtml)中对`might_sleep()`助手进行了更多解释-一个调试辅助工具-在*不要阻塞-发现可能阻塞的代码路径*部分）。
- en: 'For the curious reader (I hope you are one!), here are some links with a bit
    more of a detailed explanation on why you cannot just use a simple `memcpy()` but
    must use the `copy_[from|to]_user()` inline functions to copy data from and to
    the kernel and user spaces:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于好奇的读者（希望您是其中之一！），这里有一些链接，详细解释了**为什么**您不能只使用简单的`memcpy()`，而必须使用`copy_[from|to]_user()`内联函数来复制数据从内核到用户空间和反之：
- en: '[ht](https://stackoverflow.com/questions/14970698/copy-to-user-vs-memcpy)[tps://stackoverflow.com/questions/14970698/copy-to-user-vs-memcpy](https://stackoverflow.com/questions/14970698/copy-to-user-vs-memcpy)
    [](https://stackoverflow.com/questions/14970698/copy-to-user-vs-memcpy)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ht](https://stackoverflow.com/questions/14970698/copy-to-user-vs-memcpy)[tps://stackoverflow.com/questions/14970698/copy-to-user-vs-memcpy](https://stackoverflow.com/questions/14970698/copy-to-user-vs-memcpy)
    [](https://stackoverflow.com/questions/14970698/copy-to-user-vs-memcpy)'
- en: '[https:](https://www.quora.com/Why-we-need-copy_from_user-as-the-kernel-can-access-all-the-memory-If-we-see-the-copy_from_user-implementation-again-we-are-copying-data-to-the-kernel-memory-using-memcpy-Doesnt-it-an-extra-overhead)[//www.quora.com/Why-we-need-copy_from_user-as-the-kernel-can-access-all-the-memory-If-we-see-the-copy_from_user-implementation-again-we-are-copying-data-to-the-kernel-memory-using-memcpy-Doesnt-it-an-extra-overhead](https://www.quora.com/Why-we-need-copy_from_user-as-the-kernel-can-access-all-the-memory-If-we-see-the-copy_from_user-implementation-again-we-are-copying-data-to-the-kernel-memory-using-memcpy-Doesnt-it-an-extra-overhead).'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https:](https://www.quora.com/Why-we-need-copy_from_user-as-the-kernel-can-access-all-the-memory-If-we-see-the-copy_from_user-implementation-again-we-are-copying-data-to-the-kernel-memory-using-memcpy-Doesnt-it-an-extra-overhead)[//www.quora.com/Why-we-need-copy_from_user-as-the-kernel-can-access-all-the-memory-If-we-see-the-copy_from_user-implementation-again-we-are-copying-data-to-the-kernel-memory-using-memcpy-Doesnt-it-an-extra-overhead](https://www.quora.com/Why-we-need-copy_from_user-as-the-kernel-can-access-all-the-memory-If-we-see-the-copy_from_user-implementation-again-we-are-copying-data-to-the-kernel-memory-using-memcpy-Doesnt-it-an-extra-overhead)。'
- en: In the following section, we shall write a more complete `misc` framework character
    device driver, which will actually perform some I/O, reading and writing data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将编写一个更完整的`misc`框架字符设备驱动程序，实际上执行一些I/O，读取和写入数据。
- en: A misc driver with a secret
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个带有秘密的杂项驱动程序
- en: Now that you understand how to copy data between user and kernel space (and
    the reverse), let's write another device driver (`ch1/miscdrv_rdwr`) based on
    our previous skeleton (`ch1/miscdrv/`) miscellaneous driver. The key difference
    is that we use a few global data items (within a structure) throughout, and actually
    perform some I/O in the form of reads and writes. Here, let's introduce the notion
    of a **driver context or private driver data structure**; the idea is to have
    a conveniently accessible data structure that contains all relevant information
    in one place. Here, we name this structure `struct drv_ctx` (see it in the code
    listing that follows). On driver initialization, we allocate memory to and initialize
    it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了如何在用户空间和内核空间之间复制数据（以及反向），让我们基于我们之前的骨架（`ch1/miscdrv/`）杂项驱动程序编写另一个设备驱动程序（`ch1/miscdrv_rdwr`）。关键区别在于我们在整个过程中使用了一些全局数据项（在一个结构内），并实际进行了一些I/O读取和写入。在这里，让我们介绍**驱动程序上下文或私有驱动程序数据结构**的概念；这个想法是有一个方便访问的数据结构，其中包含所有相关信息。在这里，我们将这个结构命名为`struct
    drv_ctx`（在接下来的代码清单中可以看到）。在驱动程序初始化时，我们分配内存并对其进行初始化。
- en: 'Okay, there''s no real secret here, it just makes it sound interesting. One
    of the members within this driver context data structure of ours is a so-called
    secret message (it''s the `drv_ctx.oursecret` member, along with some (fake) statistics
    and config words). This is the simple "driver context" or private data structure
    we propose using:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这里没有真正的秘密，只是让它听起来有趣。我们驱动程序上下文数据结构中的一个成员是所谓的秘密消息（它是`drv_ctx.oursecret`成员，以及一些（虚假）统计和配置词）。这是我们建议使用的简单“驱动程序上下文”或私有数据结构：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Great; now let's move on to seeing and understanding the code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们继续看代码并理解它。
- en: Writing the 'secret' misc device driver's code
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写“秘密”杂项设备驱动程序的代码
- en: 'We''ve divided this discussion on the implementation details of our secret
    misc character device driver into five parts: driver initialization, the read
    method, the write method functionality implementation, the driver cleanup, and
    finally, the userspace application that will use our device driver.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论我们的秘密杂项字符设备驱动程序的实现细节分为五个部分：驱动程序初始化，读取方法，写入方法功能实现，驱动程序清理，最后是将使用我们的设备驱动程序的用户空间应用程序。
- en: Our secret driver – the init code
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的秘密驱动程序-初始化代码
- en: In the `init` code of our secret device driver (a kernel module, of course,
    thus invoked upon `insmod(8)`), we first register the driver as a `misc` character
    driver with the kernel (via the `misc_register()` API, as seen in the *Writing
    the misc driver code – part 1* section earlier; we won't repeat this code here).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的秘密设备驱动程序的`init`代码中（当然是一个内核模块，因此在`insmod(8)`上调用），我们首先将驱动程序注册为一个`misc`字符驱动程序与内核（通过`misc_register()`
    API，如前面的*编写misc驱动程序代码-第1部分*部分所示；我们不会在这里重复这段代码）。
- en: 'Next, we allocate kernel memory for our driver''s "context" structure – via
    the useful managed allocation  `devm_kzalloc()` API (as you learned in the companion
    guide *Linux Kernel Programming,* Chapter 8, *Kernel Memory Allocation for Module
    Authors – Part 1*, in the *Using the kernel''s resource-managed memory allocation
    APIs* section) – and initialize it. Notice that you must ensure you first get
    the device pointer `dev` before you can use this API; we retrieve it from our
    `miscdevice` structure''s `this_device` member (as seen):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过有用的托管分配`devm_kzalloc()` API（正如您在配套指南*Linux内核编程*，第8章，*模块作者的内核内存分配-第1部分*，在*使用内核的资源管理内存分配API*部分中学到的）为我们的驱动程序的“上下文”结构分配内核内存，并对其进行初始化。请注意，您必须确保您首先获取设备指针`dev`，然后才能使用此API；我们从我们的`miscdevice`结构的`this_device`成员中检索它（如下所示）：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Okay, clearly, we have initialized the `dev` member of our `ctx` private structure
    instance as well as the 'secret' string to the `'initmsg'`  string (not a very
    convincing secret, but let's leave it at that). The idea here is that when a user
    space process (or thread) opens our device file and issues `read(2)` upon it,
    we pass back (copy) the secret to it; we do so by invoking the `copy_to_user()` helper
    function! Similarly, when the user-mode app writes data to us (yes, via the `write(2)` system
    call), we consider that data written to be the new secret. So, we fetch it from
    its user space buffer – via the `copy_from_user()` helper function – and update
    it in driver memory.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，显然，我们已经初始化了`ctx`私有结构实例的`dev`成员以及`'secret'`字符串为`'initmsg'`字符串（并不是一个非常令人信服的秘密，但就让它保持这样吧）。这里的想法是，当用户空间进程（或线程）打开我们的设备文件并对其进行`read(2)`时，我们通过调用`copy_to_user()`助手函数将秘密传回（复制）给它！同样，当用户模式应用程序向我们写入数据（是的，通过`write(2)`系统调用），我们认为写入的数据是新的秘密。因此，我们从其用户空间缓冲区中获取它-通过`copy_from_user()`助手函数-并在驱动程序内存中更新它。
- en: 'Why not simply use the `strcpy()` (or `strncpy()`) API to initialize the `ctx->oursecret` member?
    This is very important: they aren''t safe enough security-wise. Also, the `strlcpy()` API
    has been marked as **deprecated** by the kernel community ([https://www.kernel.org/doc/html/latest/process/deprecated.html#strlcpy](https://www.kernel.org/doc/html/latest/process/deprecated.html#strlcpy)). In
    general, always avoid using deprecated stuff, as documented in the kernel documentation
    here: [https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions](https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不简单地使用`strcpy()`（或`strncpy()`）API来初始化`ctx->oursecret`成员？这非常重要：从安全性的角度来看，它们不够安全。此外，内核社区已经将`strlcpy()`
    API标记为**已弃用**（[https://www.kernel.org/doc/html/latest/process/deprecated.html#strlcpy](https://www.kernel.org/doc/html/latest/process/deprecated.html#strlcpy)）。总的来说，尽量避免使用已弃用的东西，如内核文档中所述：[https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions](https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions)。
- en: Quite clearly, the interesting parts of this new driver are the I/O functionality
    – the *read* and *write* methods; on with it!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这个新驱动程序的有趣部分是I/O功能- *读* 和 *写* 方法；继续进行吧！
- en: Our secret driver – the read method
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的秘密驱动程序-读取方法
- en: 'We will first show the relevant code for the read method – this is how a user
    space process (or thread) can read in the secret information housed within our
    driver (in its context structure):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先展示读取方法的相关代码-这是用户空间进程（或线程）如何读取我们驱动程序中的秘密信息（在其上下文结构中）的方法：
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `copy_to_user()` routine does its job – it copies the `ctx->oursecret` source
    buffer to the destination pointer, the `ubuf` user space buffer, for `secret_len`
    bytes, thus transferring the secret to the user space app. Now, let's check out
    the driver's write method.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy_to_user()`例程完成了它的工作-它将`ctx->oursecret`源缓冲区复制到目标指针`ubuf`用户空间缓冲区，用于`secret_len`字节，从而将秘密传输到用户空间应用程序。现在，让我们来看看驱动程序的写入方法。'
- en: Our secret driver – the write method
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的秘密驱动程序-写入方法
- en: 'The end user can change the secret by writing a new secret into the driver,
    via a `write(2)` system call to the driver''s device node. The kernel redirects the
    write (via the VFS layer) to our driver''s write method (as you learned in the *Understanding
    the connection between the process, the driver, and the kernel* section):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户可以通过向驱动程序写入新的秘密来更改秘密，通过`write(2)`系统调用到驱动程序的设备节点。内核通过VFS层将写入重定向到我们的驱动程序的写入方法（正如您在*理解进程、驱动程序和内核之间的连接*部分中学到的）：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We employ the `kvmalloc()` API to allocate memory for a buffer to hold the
    user data that we will copy in. The actual copying is done via the `copy_from_user()`
    routine, of course. Here, we use it to copy the data passed by the user space
    app to our kernel buffer, `kbuf`. We then (via the `strscpy()` routine) update
    our driver''s context structure''s `oursecret` member to this value, thus updating
    the secret! (A subsequent read on the driver will now reveal the new secret.)
    Also, do notice the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`kvmalloc()` API来分配内存，以容纳我们将要复制的用户数据的缓冲区。当然，实际的复制是通过`copy_from_user()`例程完成的。在这里，我们使用它将用户空间应用程序传递的数据复制到我们的内核缓冲区`kbuf`中。然后，我们通过`strscpy()`例程更新我们的驱动程序上下文结构的`oursecret`成员到这个值，从而更新秘密！（随后对驱动程序的读取现在将显示新的秘密。）另外，请注意以下内容：
- en: How we now consistently use the `dev_xxx()` helpers in place of the usual `printk`
    routines. This is recommended for device drivers.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何一贯地使用`dev_xxx()`助手代替通常的`printk`例程。这是设备驱动程序的推荐做法。
- en: The (now typical) usage of `goto` to perform optimal error handling.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （现在典型的）使用`goto`进行最佳错误处理。
- en: This covers the meat of the driver.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了驱动程序的核心内容。
- en: Our secret driver – cleanup
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的秘密驱动程序 – 清理
- en: 'It''s important to realize that we must free any buffers we have allocated.
    Here, however, as we performed a managed allocation in the `init` code (`devm_kzalloc()`),
    we have the benefit of not needing to worry about cleanup; the kernel handles
    it. Of course, in the driver''s cleanup code path (invoked upon `rmmod(8)`), we
    deregister the `misc` driver with the kernel:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到我们必须释放我们分配的任何缓冲区。然而，在这里，由于我们在`init`代码中执行了托管分配（`devm_kzalloc()`），我们无需担心清理工作；内核会处理它。当然，在驱动程序的清理代码路径（在`rmmod(8)`上调用时），我们会从内核中注销`misc`驱动程序：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You will notice that we also, seemingly uselessly, use two global integers, `ga` and `gb`, in
    places in this version of the driver. Indeed, they have no real meaning here;
    the reason we have them at all becomes clear only in the last two chapters of
    this book, on kernel synchronization. Please ignore them for now.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我们在这个版本的驱动程序中还似乎无用地使用了两个全局整数`ga`和`gb`。确实，在这里它们没有真正的意义；我们之所以有它们，只有在本书的最后两章关于内核同步的内容中才会变得清楚。现在请忽略它们。
- en: On this note, you'll perhaps realize that the way we have arbitrarily accessed
    global data in this driver **can cause concurrency issue (*data races!*)**; yes
    indeed; we shall set aside the deep and crucial coverage of kernel concurrency
    and synchronization to the book's last two chapters.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会意识到我们在这个驱动程序中任意访问全局数据的方式**可能会引起并发问题（*数据竞争！*）**；确实；我们将把内核并发和同步的深入重要的内容留到本书的最后两章。
- en: Our secret driver – the user space test app
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的秘密驱动程序 – 用户空间测试应用程序
- en: Writing just the kernel component, the device driver, isn't quite enough; you
    also have to write a user space application that will actually make use of the
    driver. We will do so here. (Again, you could simply use `dd(1)` as well.)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅编写内核组件，即设备驱动程序，是不够的；你还必须编写一个用户空间应用程序来实际使用驱动程序。我们将在这里这样做。（同样，你也可以使用`dd(1)`。）
- en: 'In order to use the device driver, the user space app must first, of course,
    openthe device file corresponding to it. (Here, to save space, we don''t show
    the app code in its entirety, just the most relevant portions of it. We expect
    you to have cloned the book''s Git repository and to work on the code.) The code
    to open the device file is as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用设备驱动程序，用户空间应用程序首先必须打开与之对应的设备文件。（在这里，为了节省空间，我们不完整显示应用程序代码，只显示其中最相关的部分。我们期望你已经克隆了本书的Git存储库并且在代码上进行了工作。）打开设备文件的代码如下：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The second argument to this app is the device file to open. In order to read
    or write, the process will require memory:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序的第二个参数是要打开的设备文件。为了读取或写入，进程将需要内存：
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Moving along, let''s see the block of code to have the app invoke a read or
    write (depending on the first parameter being `r` or `w`) on the (pseudo)device
    (for conciseness, we don''t show the error handling code):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看代码块，让应用程序调用（伪）设备上的读取或写入（取决于第一个参数是`r`还是`w`）（为简洁起见，我们不显示错误处理代码）：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '(Before you try out this driver, do ensure the previous `miscdrv`driver''s
    kernel module is unloaded.) Now, ensure that this  driver is built and inserted,
    of course, else it will result in the `open(2)` system call failing. We have shown
    a couple of trial runs. First, let''s build the user-mode app, insert the driver
    (not shown in *Figure 1.8*), and read from our just-created device node:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: （在尝试这个驱动程序之前，请确保先卸载之前的`miscdrv`驱动程序的内核模块。）现在，确保这个驱动程序已经构建并插入，否则将导致`open(2)`系统调用失败。我们展示了一些试运行。首先，让我们构建用户模式应用程序，插入驱动程序（*图1.8*中未显示），并从刚创建的设备节点中读取：
- en: '![](img/b40b7ebe-f9d3-4ec2-b1c0-199633935f2c.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b40b7ebe-f9d3-4ec2-b1c0-199633935f2c.png)'
- en: 'Figure 1.8 – miscdrv_rdwr: (minimally) testing the read; the original secret
    is revealed'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – miscdrv_rdwr：（最小程度地）测试读取；原始秘密被揭示
- en: The user-mode app successfully receives 7 bytes from the driver; it's the (initial)
    secret value, which it displays. The kernel log reflects the driver initialization,
    and a few seconds later, you can see (via the `dev_xxx()` instances of `printk` we
    emitted) that the `rdwr_test_secret` app runs the drivers' code in process context.
    The opening of the device, the running of the subsequent read, and the close methods
    are clearly seen. (Notice how the process name is truncated to `rdwr_test_secre`;
    this is as the task structure's `comm` member is the process name truncated to
    16 characters.)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 用户模式应用程序成功从驱动程序接收了7个字节；这是（初始）秘密值，它显示出来。内核日志反映了驱动程序的初始化，几秒钟后，你可以看到（通过我们发出的`printk`的`dev_xxx()`实例）`rdwr_test_secret`应用程序在进程上下文中运行了驱动程序的代码。设备的打开，随后的读取和关闭方法都清晰可见。（注意进程名称被截断为`rdwr_test_secre`；这是因为任务结构的`comm`成员是被截断为16个字符的进程名称。）
- en: 'In *Figure 1.9*, we show the complementary act of writing to our device node,
    changing the secret value; a subsequent read indeed reveals that it has worked:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图1.9*中，我们展示了写入我们的设备节点的互补操作，改变了秘密值；随后的读取确实显示它已经生效：
- en: '![](img/821a37e0-9a8b-4b33-93b0-eb4f40dc8639.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/821a37e0-9a8b-4b33-93b0-eb4f40dc8639.png)'
- en: 'Figure 1.9 – miscdrv_rdwr: (minimally) testing the write; a new, excellent
    secret is written'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 – miscdrv_rdwr：（最小程度地）测试写入；一个新的，优秀的秘密被写入
- en: The portion of the kernel log where the write takes place is highlighted in
    *Figure 1.9*. It works; I definitely encourage you to try this out yourself, looking
    up the kernel log as you go along.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 写入发生的内核日志部分在*图1.9*中被突出显示。它有效；我绝对鼓励你自己尝试一下，一边查看内核日志。
- en: Now, it's time to dig a little deeper. The reality is that as a driver author,
    you have to learn to be really careful regarding *security*, else all kinds of
    nasty surprises lie in wait. The next section gives you an understanding of this
    key area.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候深入一点了。事实是，作为驱动程序作者，你必须学会在*安全*方面非常小心，否则各种令人讨厌的惊喜都会等着你。下一节将让你了解这一关键领域。
- en: Issues and security concerns
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和安全问题
- en: An important consideration, for the budding driver author, is security. The
    trouble is, naive usage of even the very common `copy_[from|to]_user()` functions
    within your driver can let a malicious user quite easily – and illegally – overwrite
    memory to their advantage in both user and kernel spaces. How? The following section
    explains this in some detail; then, we will even show you a (bit contrived, but
    nevertheless, working) hack.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新手驱动程序作者来说，一个重要的考虑是安全性。问题是，即使是在驱动程序中使用非常常见的`copy_[from|to]_user()`函数也可能让恶意用户很容易
    - 且非法地 - 覆盖用户空间和内核空间的内存。如何？以下部分将详细解释这一点；然后，我们甚至会向您展示一个（有点牵强，但仍然有效）的黑客。
- en: Hacking the secret driver
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑客秘密驱动程序
- en: 'Think about this: we have the `copy_to_user()` helper routine; the first parameter
    is the destination `to` address, which should be a user space virtual address
    (a UVA), of course. Regular usage will comply with this and provide a legal and
    valid user space virtual address as the destination address, and all will be well.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 思考一下：我们有`copy_to_user()`辅助例程；第一个参数是目标`to`地址，应该是用户空间虚拟地址（UVA），当然。常规用法将遵守这一点，并提供一个合法和有效的用户空间虚拟地址作为目标地址，一切都会很好。
- en: But what if we don't? What if we pass another user space address, or, check
    this out – a *kernel *virtual address (a KVA) – in its place? The `copy_to_user()`
    code will now, running with kernel privileges, overwrite the destination with
    whatever data is in the source address (the second parameter) for the number of
    bytes in the third parameter! Indeed, hackers often attempt techniques such as
    this, to insert code posing as data into a user space buffer and execute it with
    kernel privilege, leading to a quite deadly **privilege escalation** (privesc) scenario.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们不这样做呢？如果我们传递另一个用户空间地址，或者，检查一下 - 一个*内核*虚拟地址（KVA） - 替代它呢？`copy_to_user()`代码现在将以内核特权运行，用源地址（第二个参数）中的任何数据覆盖目标，覆盖字节数为第三个参数！实际上，黑客经常尝试这样的技术，将代码插入用户空间缓冲区并以内核特权执行，导致相当致命的**特权升级**（privesc）场景。
- en: To clearly demonstrate the adverse effects of not carefully designing and implementing
    a driver, we deliberately introduce errors (bugs, really!) into both the read
    and write methods of a 'bad' version of our previous driver (although here, we
    only consider the scenario with respect to the very common `copy_[from|to]_user()`
    routines and nothing else).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地展示不仔细设计和实现驱动程序的不利影响，我们故意在先前驱动程序的读写方法中引入错误（实际上是错误！）的“坏”版本（尽管在这里，我们只考虑与非常常见的`copy_[from|to]_user()`例程有关的情况，而不考虑其他情况）。
- en: 'To get a more hands-on feel for this, we will write a "bad" version of our `ch1/miscdrv_rdwr` driver.
    We''ll call it (ever so cleverly) `ch1/bad_miscdrv`. In this version, we deliberately
    have two buggy code paths built into it:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更加亲身地感受这一点，我们将编写我们的`ch1/miscdrv_rdwr`驱动程序的“坏”版本。我们将称之为（非常聪明地）`ch1/bad_miscdrv`。在这个版本中，我们故意内置了两个有错误的代码路径：
- en: One within the driver's read method
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驱动程序的读取方法中的一个
- en: The other, the more exciting one, as you shall soon see, within the write method.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个更令人兴奋的，很快您将看到，在写方法中。
- en: Let's check both out. We'll begin with the buggy read.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查两者。我们将从有错误的读取开始。
- en: Bad driver – buggy read()
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 坏驱动程序 - 有错误的读取()
- en: 'To help you see what''s changed in the code, we first perform a `diff(1)` of
    this (deliberately) bad driver code with our previous (good) version, yielding
    the differences, of course (in the following snippet, we curtail the output to
    only what''s most relevant):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您看到代码中发生了什么变化，我们首先对这个（故意）坏驱动程序代码与我们先前（好的）版本进行`diff(1)`，得到了差异，当然（在以下片段中，我们将输出限制为最相关的内容）。
- en: '[PRE21]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So, it should be quite clear: in our ''bad'' driver''s read method, if the
    `READ_BUG` macro is defined, we alter the user space destination pointer to point
    to an illegal location (512 KB beyond the location we should actually copy the
    data to!). This demonstrates the point here: we can do arbitrary stuff like this
    because we are running with kernel privileges*. *That it will cause issues and
    bugs is a separate matter.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，很明显：在我们“坏”驱动程序的读取方法中，如果定义了`READ_BUG`宏，我们将修改用户空间目标指针，使其指向一个非法位置（比我们实际应该复制数据的位置多512
    KB！）。这里的要点在于：我们可以做任意这样的事情，因为我们是以内核特权运行的*。*它会导致问题和错误是另一回事。
- en: 'Let''s try it: first, do ensure that you''ve built and loaded the `bad_miscdrv`
    kernel module (you can use our `lkm` convenience script to do so). Our trial run,
    issuing a `read(2)` system call via our `ch1/bad_miscdrv/rdwr_test_hackit` user-mode
    app, results in failure (see the following screenshot):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试：首先确保您已构建并加载了`bad_miscdrv`内核模块（您可以使用我们的`lkm`便利脚本来执行）。我们的试运行，通过我们的`ch1/bad_miscdrv/rdwr_test_hackit`用户模式应用程序发出`read(2)`系统调用，结果失败（请参见以下屏幕截图）：
- en: '![](img/7beb9fad-e2d5-495f-8d72-951812ac41e1.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7beb9fad-e2d5-495f-8d72-951812ac41e1.png)'
- en: Figure 1.10 – Screenshot showing our bad_miscdrv misc driver performing a "bad"
    read
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 - 屏幕截图显示我们的bad_miscdrv杂项驱动程序执行“坏”读取
- en: Ah, this is interesting; our test application's (`rdwr_test_hackit`) `read(2)` system
    call does indeed fail, with the `perror(3)` routine indicating the cause of failure
    as `Bad address`. But why? Why didn't the driver, running with kernel privileges,
    actually write to the destination address (here, `0x5597245d46b0` , the wrong
    one; as we know, it's attempting to write 512 KB *ahead* of the correct destination
    address. We deliberately wrote the driver's read method code to do so).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，这很有趣；我们的测试应用程序（`rdwr_test_hackit`）的`read(2)`系统调用确实失败，`perror(3)`例程指示失败原因为`Bad
    address`。但是为什么？为什么驱动程序，以内核特权运行，实际上没有写入目标地址（这里是`0x5597245d46b0`，错误的地址；正如我们所知，它试图写入正确目标地址的512
    KB *之后*。我们故意编写了驱动程序的读取方法代码来这样做）。
- en: 'This is because kernel  ensures that the `copy_[from|to]_user()` routines will
    (ideally) fail when attempting to read or write illegal addresses! Internally,
    several checks are done: `access_ok()` is a simple one merely ensuring that I/O
    is performed within the expected segment (user or kernel). Modern Linux kernels
    have superior checking; besides the simple `access_ok()` check, the kernel then
    wades through – if enabled – the **KASAN** (**Kernel Address Sanitizer**, a compiler
    instrumentation feature; KASAN is indeed very useful, a *must-do* during development
    and test!), checks on object sizes (including overflow checks), and only then
    does it invoke the worker routine that performs the actual copy, `raw_copy_[from|to]_user()`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为内核确保`copy_[from|to]_user()`例程在尝试读取或写入非法地址时（理想情况下）会失败！在内部，进行了几项检查：`access_ok()`是一个简单的检查，只是确保I/O在预期段（用户或内核）中执行。现代Linux内核具有更好的检查；除了简单的`access_ok()`检查之外，内核还会通过（如果启用）**KASAN**（**内核地址消毒剂**，一种编译器插装特性；KASAN确实非常有用，在开发和测试过程中是*必须的*！），检查对象大小（包括溢出检查），然后才调用执行实际复制的工作例程，`raw_copy_[from|to]_user()`。
- en: Okay, that's good; now, let's move on to the more interesting case, the buggy
    write, which we shall arrange (in a contrived manner though) to make into an attack!
    Read on...
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们继续讨论更有趣的情况，即有bug的写入，我们将（虽然以一种虚构的方式）安排成一次攻击！继续阅读...
- en: Bad driver – buggy write() – a privesc!
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 坏驱动程序 - 有bug的写入 - 特权提升！
- en: What does the malicious hacker really want, their holy grail? A root shell on
    the system, of course (*got root?*). With a good deal of contrived code within
    our driver's write method (thus making this hack not a really good one; it's quite
    academic), let's go get it! To do so, we modify both the user-mode app as well
    as the device driver. Let's look at the user-mode app's changes first.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意黑客真正想要什么，他们的圣杯？当然是系统上的root shell（得到root权限？）。通过在我们的驱动程序的写入方法中使用大量虚构的代码（因此这个黑客并不是一个真正好的黑客；它相当学术），让我们去获取它！为了做到这一点，我们修改用户模式应用程序以及设备驱动程序。让我们先看看用户模式应用程序的变化。
- en: User space test app modifications
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用户空间测试应用程序修改
- en: 'We slightly modify the user space application – our process context, in effect. This
    particular version of the user-mode test app differs from the earlier one in one
    regard: we now have a macro called `HACKIT`. If it''s defined (it is by default),
    this process will deliberately write only zeroes into the user space buffer and
    send that to our bad driver''s write method. If the driver has the `DANGER_GETROOT_BUG`
    macro defined (it is by default), then it will write the zeroes into the process''s
    UID member, thus making the user-mode process obtain root privileges!'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍微修改了用户空间应用程序 - 实际上是我们的进程上下文。这个用户模式测试应用程序的特定版本在一个方面与之前的版本不同：我们现在有一个名为`HACKIT`的宏。如果定义了它（默认情况下是定义的），这个进程将故意只向用户空间缓冲区写入零，并将其发送到我们的坏驱动程序的写入方法。如果驱动程序定义了`DANGER_GETROOT_BUG`宏（默认情况下是定义的），那么它将把零写入进程的UID成员，从而使用户模式进程获得root权限！
- en: In the traditional Unix/Linux paradigm, if the **Real User ID** (**RUID**) and/or
    **Effective User ID** (**EUID**) (they're within the task structure, in `struct
    cred`) are set to the special value zero (`0`), it implies that the process has
    superuser (root) powers. Nowadays, the POSIX Capabilities model is considered
    a superior way to work with privileges, as it allows assigning fine-grained permissions
    – *capabilities* – on a thread, as opposed to giving a process or thread complete
    control over the system as root.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的Unix/Linux范式中，如果**真实用户ID**（**RUID**）和/或**有效用户ID**（**EUID**）（它们在`struct cred`中的任务结构中）被设置为特殊值零（`0`），这意味着该进程具有超级用户（root）权限。如今，POSIX权限模型被认为是一种更优越的处理权限的方式，因为它允许在线程上分配细粒度的权限
    - *capabilities*，而不是像root一样给予进程或线程对系统的完全控制。
- en: 'Here''s a quick `diff` of the user space test app from the previous version,
    allowing you to see the changes made to the code (again, we curtail the output
    to only what''s most relevant):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用户空间测试应用程序与之前版本的快速`diff`，让您看到对代码所做的更改（再次，我们将输出限制在最相关的部分）：
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This does imply that the (so-called) secret never gets written; that's okay.
    Now, let's look at the modifications made to the driver.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着（所谓的）秘密从未被写入；没关系。现在，让我们看看对驱动程序所做的修改。
- en: Device driver modifications
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设备驱动程序修改
- en: 'To see how our bad `misc` driver''s write method changes, we will continue
    looking at the same `diff` (of our bad versus good drivers) that we did in the *Bad
    driver – buggy read()* section. The comments in the code from the following `diff` operation
    are quite self-explanatory. Check it out:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看我们的坏`misc`驱动程序的写入方法如何改变，我们将继续查看相同的`diff`（我们的坏驱动程序与好驱动程序的对比），就像我们在*坏驱动程序
    - 有bug的读取*部分所做的那样。以下代码中的注释是相当不言自明的。看一下：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The key point from the preceding code is that when the `DANGER_GETROOT_BUG` macro is
    defined (it is by default), we set the `new_dest` pointer to the address of the
    (real) UID member within the credential structure, which is itself within the
    task structure (referenced by `current`) for this process context! (If all of
    this sounds foreign, please read the companion guide *Linux Kernel Programming,* Chapter
    6, *Kernel Internals Essentials – Processes and Threads*). This way, when we invoke
    the `copy_to_user()` routine to perform the write to user space, it's going to
    actually write zeroes to the process UID member within `current->cred`. A UID
    of zero is what (traditionally) defines root. Also, notice how we restrict the
    write to 4 bytes (as we're just writing a 32-bit quantity).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中的关键点是，当定义了`DANGER_GETROOT_BUG`宏（默认情况下是定义的）时，我们将`new_dest`指针设置为凭证结构中（实际的）UID成员的地址，这个结构本身位于任务结构中（由`current`引用）的进程上下文中！（如果所有这些听起来都很陌生，请阅读配套指南*Linux内核编程*，第6章*内核内部要点-进程和线程*）。这样，当我们调用`copy_to_user()`例程执行写入用户空间时，它实际上将零写入`current->cred`中的进程UID成员。零的UID是（传统上）定义为root。另外，请注意我们将写入限制为4个字节（因为我们只写入32位数量）。
- en: '(By the way, the build on our "bad" driver does issue a warning; here, with
    it being intentional, we merely ignore it):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: （顺便说一句，我们的“坏”驱动程序构建确实发出了警告；在这里，由于是故意的，我们只是忽略了它）：
- en: '[PRE24]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here''s the `copy_from_user()` code invocation:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`copy_from_user()`代码调用：
- en: '[PRE25]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Clearly, the preceding `copy_to_user()` routine will write the user-supplied
    buffer, `ubuf`, into the `new_dest` destination buffer – which, crucially, we
    have made point to `current->cred->uid` – for `count` bytes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，前面的`copy_to_user()`例程将把用户提供的缓冲区`ubuf`写入到`new_dest`目标缓冲区中 - 关键是，我们已经指向了`current->cred->uid`
    - 用于`count`字节。
- en: Let's get root now
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 现在让我们获取root权限
- en: 'Of course, the proof of the pudding is in the eating, yes? So, let''s give
    our hack a spin; here, we assume that you''ve first unloaded any previous version
    of our ''misc'' drivers, and built and loaded the `bad_miscdrv` kernel module
    into memory:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，实践出真知，对吧？所以，让我们试一下我们的黑客技巧；在这里，我们假设您已经卸载了之前版本的“misc”驱动程序，并构建并加载了`bad_miscdrv`内核模块到内存中：
- en: '![](img/b3477088-14a9-4ae5-9f29-8fdca1ffd939.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: 在下一章中，您将学习作为驱动程序作者的一个关键任务 - 如何有效地将设备驱动程序与用户空间进程进行接口；详细介绍了几种有用的方法，并进行了对比。
- en: Figure 1.11 – Screenshot showing our bad_miscdrv misc driver performing a "bad"
    write, resulting in root – a privesc!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 - 屏幕截图显示我们的bad_miscdrv misc驱动程序执行了一个“坏”写操作，导致了root权限提升！
- en: 'Check it out; **we indeed got root!** Our `rdwr_test_hackit` app, detecting
    that we do have root (via a simple `getuid(2)`system call), then does the logical
    thing: it execs a root shell (via an `execl(3)` API), and voilà, we land up in
    a root shell. We show the kernel log:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 看看吧；**我们确实获得了root权限！**我们的`rdwr_test_hackit`应用程序检测到我们确实拥有root权限（通过一个简单的`getuid(2)`系统调用），然后做了合乎逻辑的事情：它执行了一个root
    shell（通过一个`execl(3)`API），然后，我们进入了一个root shell。我们展示了内核日志：
- en: '[PRE26]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can see how it''s worked: the original user-mode buffer `ubuf` kernel virtual
    address is `0x55648b8f36b0`. In the hack, we modify it to the new destination
    address (kernel virtual address), `0xffff9f67765c3b44`, which is (in this case)
    the kernel virtual address of the UID member of `struct cred` (within the process''s
    task structure). Not only that, but our driver also modifies the number of bytes
    to write (`count`) to `4` (bytes), as we''re updating a 32-bit quantity.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到它是如何工作的：原始用户模式缓冲区`ubuf`的内核虚拟地址为`0x55648b8f36b0`。在黑客中，我们将其修改为新的目标地址（内核虚拟地址）`0xffff9f67765c3b44`，这是（在本例中）`struct
    cred`的UID成员的内核虚拟地址（在进程的任务结构中）。不仅如此，我们的驱动程序还将要写入的字节数（`count`）修改为`4`（字节），因为我们正在更新一个32位的数量。
- en: 'Do note: these hacks are just that – hacks. They could certainly cause your
    system to become unstable (when run on our "debug" kernel, KASAN, in fact, detected
    a null pointer dereference!).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意：这些黑客只是黑客。它们肯定会导致您的系统变得不稳定（在我们的“调试”内核上运行时，KASAN实际上检测到了空指针解引用！）。
- en: These demos prove nothing but the fact that you as a kernel and/or driver author
    must be alert to programming issues, security, and more at all times. With this,
    we complete this section and indeed the chapter.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这些演示证明了一个事实，即作为内核和/或驱动程序作者，您必须时刻警惕编程问题、安全性等。有了这个，我们完成了本节，实际上也完成了本章。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This concludes this chapter on writing a simple `misc` class character device
    driver on the Linux OS; so, awesome, you now know the basics of writing a device
    driver on Linux!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了本章关于在Linux操作系统上编写简单的`misc`类字符设备驱动程序的内容；所以，太棒了，您现在知道了在Linux上编写设备驱动程序的基础知识！
- en: The chapter began with an introduction to device basics, and importantly, the
    very brief essentials of the modern LDM. You then learned how to write a simple
    first character device driver, registering with the kernel's `misc`framework.
    Along the way, you also understood the connection between the process, the driver,
    and the kernel VFS. Copying data between user and kernel address spaces is essential;
    we saw how to do so. A more comprehensive demo `misc` driver (our 'secret' driver)
    showed you how to perform I/O – reads and writes – ferrying data between user
    and kernel space. A key part of this chapter is the last section, where you learned
    (well, made a start at least) about security and the driver; a "hack" even demonstrated
    a *privesc* attack!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以设备基础知识的介绍开始，重要的是，现代LDM的简要要点。然后，您学习了如何编写一个简单的字符设备驱动程序，并在内核的`misc`框架中注册。在此过程中，您还了解了进程、驱动程序和内核VFS之间的连接。在用户和内核地址空间之间复制数据是必不可少的；我们看到了如何做到这一点。一个更全面的`misc`驱动程序演示（我们的“秘密”驱动程序）向您展示了如何执行I/O
    - 读取和写入 - 在用户和内核空间之间传输数据。本章的关键部分是最后一节，您在其中学习了（至少开始了）有关安全性和驱动程序的知识；一个“黑客”甚至演示了*privesc*攻击！
- en: As mentioned before, there's much more to this vast topic of writing drivers
    on Linux; indeed, whole books are devoted to it! Do check out the *Further reading *section
    for this chapter to find relevant books and online references.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，编写Linux驱动程序这一广泛主题还有很多内容；事实上，整整一本书都是关于这个的！请查看本章的*进一步阅读*部分，找到相关的书籍和在线参考资料。
- en: In the following chapter you will learn a key task for a driver author - how
    exactly can you efficiently interface your device driver with user space processes;
    several useful approaches are covered in detail and contrasted. Do ensure you're
    clear on this chapter's material, work on the exercises given, review the *Further
    reading *resources and then dive into the next one.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您对本章的内容清楚，完成所给的练习，查阅*进一步阅读*资源，然后深入下一章。
- en: Questions
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Load up the first `miscdrv`skeleton `misc` driver kernel module and issue `lseek(2)`
    on it; what happens? (Does it succeed? What's the return value from `lseek`?)
    If not, okay, how will you fix this?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载第一个`miscdrv`骨架`misc`驱动程序内核模块，并对其进行`lseek(2)`操作；会发生什么？（是否成功？`lseek`的返回值是什么？）如果没有，好的，您将如何解决这个问题？
- en: 'Write a `misc` class character driver that behaves as a simple converter program (assume
    its path name is `/dev/convert`). For example, writing the temperature in Fahrenheit
    units, it should return (write to the kernel log) the temperature in Celsius.
    Thus, doing `echo 98.6 > /dev/convert` should result in the value `37 C` being
    written to the kernel log. Additionally, do the following:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`misc`类字符驱动程序，它的行为类似于一个简单的转换程序（假设其路径名为`/dev/convert`）。例如，将华氏温度写入，它应该返回（写入内核日志）摄氏温度。因此，执行`echo
    98.6 > /dev/convert`应该导致内核日志中写入值`37 C`。另外，做以下操作：
- en: Validate that the data passed to your driver is a numeric value.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证传递给驱动程序的数据是否为数值。
- en: How will you handle floating-point values? (Tip: refer to the section *Floating
    point not allowed in the kernel* in *Linux Kernel Programming*, *Chapter 5*, *Writing
    Your First Kernel Module LKMs – Part 2.*)
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何处理浮点值？（提示：参考*Linux内核编程*，*第5章*，*编写您的第一个内核模块LKM-第2部分*中的*内核中不允许浮点*一节。）
- en: Write a "task display" driver; here, we'd like a user space process to write
    a thread (or process) PID to it. When you now read from the driver's device node
    (assume its path name is `/dev/task_display`), you should receive details regarding
    the task (which is pulled from its task structure, of course). For example, doing `echo
    1 > /dev/task_display` followed by `cat /dev/task_display` should have the driver
    emit task details of PID 1 to the kernel log. Don't forget to add validity checks
    (check the PID is valid, and so on).
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个“任务显示”驱动程序；在这里，我们希望用户空间进程将线程（或进程）PID写入其中。当您从驱动程序的设备节点中读取（假设其路径名为`/dev/task_display`）时，您应该收到有关任务的详细信息（当然是从其任务结构中提取的）。例如，执行`echo
    1 > /dev/task_display`，然后执行`cat /dev/task_display`应该使驱动程序将PID 1的任务详细信息发出到内核日志中。不要忘记添加有效性检查（检查PID是否有效等）。
- en: (A bit more advanced:) Write a "proper" LDM-based driver; the `misc` drivers
    covered here did register with the kernel's `misc` framework, but simply, implicitly,
    used the raw character interface as the bus. The LDM prefers that a driver must register
    with a kernel framework and a bus driver. Hence, write a "demo" driver that registers
    itself with the kernel's `misc` framework and the platform bus. This will involve
    creating a fake platform device as well.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （稍微高级一点：）编写一个“正确的”基于LDM的驱动程序；这里介绍的`misc`驱动程序已经在内核的`misc`框架中注册，但是简单地、隐式地使用原始字符接口作为总线。LDM更喜欢驱动程序必须在内核框架和总线驱动程序中注册。因此，编写一个“演示”驱动程序，它将自己注册到内核的`misc`框架和平台总线。这将涉及创建一个虚拟的平台设备。
- en: '(*Note the following t**ips*:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: （*请注意以下提示*：
- en: a) Do refer to [Chapter 2](4042025e-27a1-40f4-a2f7-223f601107dc.xhtml), *User-Kernel
    Communication Pathways*, particularly the *Creating a simple platform device* and *Platform
    devices* sections.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: a) 请参阅[第2章](4042025e-27a1-40f4-a2f7-223f601107dc.xhtml)，*用户-内核通信路径*，特别是*创建一个简单的平台设备*和*平台设备*部分。
- en: b) A possible solution to this driver can be found here: `solutions_to_assgn/ch12/misc_plat/`.)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: b) 可以在这里找到对该驱动程序的可能解决方案：`solutions_to_assgn/ch12/misc_plat/`。
- en: 'You will find some of the questions answered in the book''s GitHub repo: [https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现一些问题的答案在书的GitHub存储库中：[https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn)。
- en: Further reading
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Linux device drivers books:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux设备驱动程序书籍：
- en: '*Linux Device Drivers Development*, John Madieu, Packt, Oct 2017: [https://www.amazon.in/Linux-Device-Drivers-Development-Madieu/dp/1785280007/ref=sr_1_2?keywords=linux+device+driver&qid=1555486515&s=books&sr=1-2](https://www.amazon.in/Linux-Device-Drivers-Development-Madieu/dp/1785280007/ref=sr_1_2?keywords=linux+device+driver&qid=1555486515&s=books&sr=1-2) ;
    excellent coverage, as well as very recent (as of this writing; it covers the
    4.13 kernel)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux设备驱动程序开发*，John Madieu，Packt，2017年10月：[https://www.amazon.in/Linux-Device-Drivers-Development-Madieu/dp/1785280007/ref=sr_1_2?keywords=linux+device+driver&qid=1555486515&s=books&sr=1-2](https://www.amazon.in/Linux-Device-Drivers-Development-Madieu/dp/1785280007/ref=sr_1_2?keywords=linux+device+driver&qid=1555486515&s=books&sr=1-2)；覆盖面广，而且非常新（截至本文撰写时；它涵盖了4.13内核）'
- en: '*Linux Driver Development for Embedded Processors - Second Edition: Learn to
    develop embedded Linux drivers with kernel 4.9 LTS*, Alberto Liberal de los Rios:
    [https://www.amazon.in/Linux-Driver-Development-Embedded-Processors-ebook/dp/B07L512BHG/ref=sr_1_6?crid=3RLFFZQXGAMF4&keywords=linux+driver+development+embedded&qid=1555486342&s=books&sprefix=linux+driver+%2Cstripbooks%2C270&sr=1-6-catcorr](https://www.amazon.in/Linux-Driver-Development-Embedded-Processors-ebook/dp/B07L512BHG/ref=sr_1_6?crid=3RLFFZQXGAMF4&keywords=linux+driver+development+embedded&qid=1555486342&s=books&sprefix=linux+driver+%2Cstripbooks%2C270&sr=1-6-catcorr)
    ; very good, as well as recent (4.9 kernel)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*嵌入式处理器的Linux驱动程序开发-第二版：学习使用4.9 LTS内核开发嵌入式Linux驱动程序*，Alberto Liberal de los
    Rios：[https://www.amazon.in/Linux-Driver-Development-Embedded-Processors-ebook/dp/B07L512BHG/ref=sr_1_6?crid=3RLFFZQXGAMF4&keywords=linux+driver+development+embedded&qid=1555486342&s=books&sprefix=linux+driver+%2Cstripbooks%2C270&sr=1-6-catcorr](https://www.amazon.in/Linux-Driver-Development-Embedded-Processors-ebook/dp/B07L512BHG/ref=sr_1_6?crid=3RLFFZQXGAMF4&keywords=linux+driver+development+embedded&qid=1555486342&s=books&sprefix=linux+driver+%2Cstripbooks%2C270&sr=1-6-catcorr)；非常好，而且很新（4.9内核）'
- en: '*Essential Linux Device Drivers*, Sreekrishnan Venkateswaran, Pearson: [https://www.amazon.in/Essential-Drivers-Prentice-Software-Development/dp/0132396556/ref=tmm_hrd_swatch_0?_encoding=UTF8&qid=&sr=](https://www.amazon.in/Essential-Drivers-Prentice-Software-Development/dp/0132396556/ref=tmm_hrd_swatch_0?_encoding=UTF8&qid=&sr=) ;
    simply excellent, wide coverage'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Essential Linux Device Drivers*，Sreekrishnan Venkateswaran，Pearson：[https://www.amazon.in/Essential-Drivers-Prentice-Software-Development/dp/0132396556/ref=tmm_hrd_swatch_0?_encoding=UTF8&qid=&sr=](https://www.amazon.in/Essential-Drivers-Prentice-Software-Development/dp/0132396556/ref=tmm_hrd_swatch_0?_encoding=UTF8&qid=&sr=)；非常好，覆盖面广'
- en: '*Linux Device Drivers*, Rubini, Hartmann, Corbet, 3rd Edition: [https://www.amazon.in/Linux-Device-Drivers-Kernel-Hardware/dp/8173668493/ref=sr_1_1?keywords=linux+device+driver&qid=1555486515&s=books&sr=1-1](https://www.amazon.in/Linux-Device-Drivers-Kernel-Hardware/dp/8173668493/ref=sr_1_1?keywords=linux+device+driver&qid=1555486515&s=books&sr=1-1)
    ; venerable (but) old – the famous LDD3 book'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Linux设备驱动程序》，Rubini，Hartmann，Corbet，第3版：[https://www.amazon.in/Linux-Device-Drivers-Kernel-Hardware/dp/8173668493/ref=sr_1_1?keywords=linux+device+driver&qid=1555486515&s=books&sr=1-1](https://www.amazon.in/Linux-Device-Drivers-Kernel-Hardware/dp/8173668493/ref=sr_1_1?keywords=linux+device+driver&qid=1555486515&s=books&sr=1-1)；古老但著名的LDD3书籍
- en: 'Official kernel documentation:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方内核文档：
- en: The Linux Kernel Device Model: [https://www.kernel.org/doc/html/latest/driver-api/driver-model/overview.html#the-linux-kernel-device-model](https://www.kernel.org/doc/html/latest/driver-api/driver-model/overview.html#the-linux-kernel-device-model).
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核设备模型：[https://www.kernel.org/doc/html/latest/driver-api/driver-model/overview.html#the-linux-kernel-device-model](https://www.kernel.org/doc/html/latest/driver-api/driver-model/overview.html#the-linux-kernel-device-model)。
- en: The kernel driver API manual; this is one of the PDF documents generated by
    doing `make pdfdocs` within a recent Linux kernel source tree.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核驱动程序API手册；这是最近Linux内核源代码中执行`make pdfdocs`时生成的PDF文档之一。
- en: Deprecated Interfaces, Language Features, Attributes, and Conventions: [https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions](https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions).
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已弃用的接口、语言特性、属性和约定：[https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions](https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions)。
- en: 'Practical tutorials:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实用教程：
- en: '*Device Drivers, Part 8: Accessing x86-Specific I/O-Mapped Hardware*, Anil
    K Pugalia, OpenSourceForU, July 2011: [https://opensourceforu.com/2011/07/accessing-x86-specific-io-mapped-hardware-in-linux/](https://opensourceforu.com/2011/07/accessing-x86-specific-io-mapped-hardware-in-linux/)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《设备驱动程序，第8部分：访问x86特定的I/O映射硬件》，Anil K Pugalia，OpenSourceForU，2011年7月：[https://opensourceforu.com/2011/07/accessing-x86-specific-io-mapped-hardware-in-linux/](https://opensourceforu.com/2011/07/accessing-x86-specific-io-mapped-hardware-in-linux/)
- en: 'User space device drivers; check out this interesting video presentation by
    Chris Simmonds: *How to Avoid Writing Device Drivers for Embedded Linux*: [https://www.youtube.com/watch?v=QIO2pJqMxjE&t=909s](https://www.youtube.com/watch?v=QIO2pJqMxjE&t=909s)'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户空间设备驱动程序；观看Chris Simmonds的这个有趣的视频演示：*如何避免为嵌入式Linux编写设备驱动程序*：[https://www.youtube.com/watch?v=QIO2pJqMxjE&t=909s](https://www.youtube.com/watch?v=QIO2pJqMxjE&t=909s)
