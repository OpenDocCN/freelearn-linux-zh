- en: Process Execution
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程执行
- en: 'Imagine this scenario: while working on a project as a systems programmer (using
    C on Linux), there is a requirement that, from within the **graphical user interface (GUI**)
    frontend application, when the end user clicks a certain button, the application
    must display the content of a system-generated PDF document. We can assume a PDF
    reader software application is available to us. But, how exactly, will you run
    it from within your C code?'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 想象这样的情景：作为一个系统程序员（在Linux上使用C语言）在一个项目上工作时，有一个要求，即在图形用户界面（GUI）前端应用程序中，当最终用户点击某个按钮时，应用程序必须显示系统生成的PDF文档的内容。我们可以假设有一个PDF阅读器软件应用程序可供我们使用。但是，你要如何在C代码中运行它？
- en: 'This chapter will teach you how to perform this important task. Here, we will
    learn some core Unix/Linux systems programming concepts: How the Unix `exec` model
    works, the predecessor/successor terminology, and how to use up to seven `exec`
    family APIs to make the whole thing actually work in code. Along the way, of course,
    code examples are used to clearly illustrate the concepts.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教你如何执行这一重要任务。在这里，我们将学习一些核心的Unix/Linux系统编程概念：Unix `exec`模型的工作原理，前身/后继术语，以及如何使用多达七个`exec`系列API来使整个过程在代码中实际运行。当然，在这个过程中，会使用代码示例来清楚地说明这些概念。
- en: 'Briefly, the reader will learn about the following key areas:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，读者将学习以下关键领域：
- en: The meaning of the `exec` operation and its semantics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec`操作的含义及其语义'
- en: Testing the `exec` operation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`exec`操作
- en: Using the `exec`—the wrong and right ways to do so
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`exec`的错误和正确方式
- en: Error handling with the `exec`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`exec`进行错误处理
- en: the seven `exec` family APIs and how to use them in code.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 七个`exec`系列API及其在代码中的使用方法。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'One of the exercises in this chapter requires the Poppler package (PDF utils) to
    be installed; it can be installed as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一个练习要求安装Poppler软件包（PDF工具）；可以按以下方式安装：
- en: On Ubuntu: `sudo apt install poppler-utils`
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu上：`sudo apt install poppler-utils`
- en: On Fedora: `sudo dnf install poppler-utils-<version#>`
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fedora上：`sudo dnf install poppler-utils-<version#>`
- en: 'Regarding the Fedora case: to get the version number, just type the above command,
    and after typing `poppler-utils-` press the *Tab* key twice; it will autocomplete
    providing a list of choices. Choose the latest version and press *Enter*.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Fedora案例：要获取版本号，只需输入上述命令，然后在输入`poppler-utils-`后按两次*Tab*键；它将自动完成并提供一个选择列表。选择最新版本并按*Enter*。
- en: Process execution
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程执行
- en: Here, we study how the Unix/Linux OS, at the level of the system programmer, executes
    programs. First, we will teach you to understand the important `exec` semantics;
    once this is clear, you can program it, using the `exec` family of APIs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们研究Unix/Linux操作系统在系统程序员级别上如何执行程序。首先，我们将教你理解重要的`exec`语义；一旦这清楚了，你就可以使用`exec`系列API来编程。
- en: Converting a program to a process
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将程序转换为进程
- en: As has been mentioned before, a program is a binary file on a storage medium;
    by itself, it is a dead object. To run it and thus make it come alive, into a
    process*, *we have to execute it. When you run a program from, say, the shell,
    it does indeed come alive and become a process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，程序是存储介质上的二进制文件；它本身是一个死对象。要运行它，使其成为一个进程，我们必须执行它。当你从shell中运行程序时，它确实会变得活跃并成为一个进程。
- en: 'Here is a quick example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个快速示例：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Looking at the previous code, from the shell (itself a process: bash), we run
    or execute the `ps(1)` program; `ps` does run; it is now a process; it does its
    job (here printing out the processes currently alive in this terminal''s session),
    and then politely dies, leaving us back on the shell''s prompt.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看出，从shell（本身就是一个进程：bash）中运行或执行`ps(1)`程序；`ps`确实运行了；它现在是一个进程；它完成了它的工作（在这里打印出当前在这个终端会话中活动的进程），然后礼貌地死去，让我们回到shell的提示符。
- en: 'A moment''s reflection will reveal that to have the `ps(1)` program become
    the `ps` process, some work probably had to be done by the **operating** **system**
    (**OS**). Indeed, that is the case: The OS executes a program and makes it a running
    process ultimately via an API, a system call, called the `execve(2)`. For now,
    though, let''s leave the APIs aside and focus on the concept.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 稍加思考就会发现，要使`ps(1)`程序成为`ps`进程，操作系统可能需要做一些工作。确实如此：操作系统通过一个名为`execve(2)`的API，一个系统调用，执行程序并最终使其成为运行中的进程。不过，现在让我们暂时把API放在一边，专注于概念。
- en: The exec Unix axiom
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: exec Unix公理
- en: 'We learned in [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml), *Virtual
    Memory*,which covered virtual memory, that a process can be visualized as a box
    (a rectangle), having a **virtual address space** (**VAS**); the VAS consists
    of homogeneous regions (technically, mappings) called segments. Essentially, a
    process''s VAS is thus made up of several segments—text (code), data segments,
    library (and other) mappings, and a stack. For your convenience, the diagram representing
    a process''s VAS is reproduced here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml)中学到，即虚拟内存，一个进程可以被视为一个盒子（一个矩形），具有虚拟地址空间（VAS）；VAS由称为段的同质区域（技术上称为映射）组成。基本上，一个进程的VAS由几个段组成：文本（代码）段、数据段、库（和其他）映射以及栈。为了方便起见，这里再次呈现了表示进程VAS的图表：
- en: '![](img/ec63b079-fa41-4cab-be3a-c912d5369c85.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec63b079-fa41-4cab-be3a-c912d5369c85.png)'
- en: 'Fig 1 : The process virtual address space (VAS)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：进程虚拟地址空间（VAS）
- en: The lower end has a virtual address of `0`, and addresses increase as we go
    up; we have an upward-growing heap and a downward-growing stack.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 底端的虚拟地址为`0`，地址随着向上增加；我们有一个向上增长的堆和一个向下增长的栈。
- en: Every process alive on the machine will have just such a process VAS; thus,
    it stands to reason, the shell in our preceding small example, bash, has such
    a process VAS (along with all its other attributes such as **process identifier** (**PID**),
    open files, and so on).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 机器上的每个进程都有这样的进程VAS；因此，可以推断出，我们之前的小例子中的shell，bash，也有这样的进程VAS（以及所有其他属性，如进程标识符（PID）、打开的文件等）。
- en: So, let's imagine that the shell process bash has a **PID** of 3,396\. Now,
    when we run `ps` from the shell, what actually happens?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们想象一下，shell进程bash的PID是3,396。现在，当我们从shell运行`ps`时，实际上发生了什么？
- en: Well, obviously, as a first step, the shell checks whether `ps` is a built-in
    command; if so, it runs it; if not, which is the case, it continues on to the
    second step. Now, the shell parses the `PATH` environment variable, and, say,
    locates `ps` in `/bin` . The third step, the interesting one!, is where the shell
    process now executes `/bin/ps` via an API. We shall leave the discussion of the
    exact API(s) until later; for now, we shall just refer to the possible APIs as
    the `exec` APIs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，作为第一步，shell会检查“ps”是否是一个内置命令；如果是，它会运行它；如果不是，也就是我们的情况，它会继续到第二步。现在，shell解析“PATH”环境变量，并且在“/bin”中找到了“ps”。第三步，有趣的一步！，是shell进程现在通过API执行“/bin/ps”。我们将把确切的API讨论留到以后；现在，我们只是把可能的API称为“exec”API。
- en: 'Don''t lose the forest for the trees; a key point we now come to is this: The
    `exec`, when it occurs, causes the calling process (bash) to execute the called
    **process** (`ps`) by having (among other setups), `ps` overwrite it''s **Virtual
    Address Space** (**VAS**). Yes, you read that right—process execution on Unix,
    and thus Linux, is effected by having one process—the `caller`—get overwritten
    by the process to execute— the `callee`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不要为了树木而忘记了森林；我们现在要谈到的一个关键点是：当“exec”发生时，调用进程（bash）通过让（除其他设置外）“ps”覆盖其虚拟地址空间（VAS）来执行被调用的进程（`ps`）。是的，你没看错——Unix和因此Linux上的进程执行是通过一个进程——“调用者”——被要执行的进程——“被调用者”——覆盖来实现的。
- en: '**Terminology**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 术语
- en: 'Here is some important terminology to help us: The process that is calling
    the `exec` (`bash`, in our example), is called the *predecessor*; the process
    that gets called and executed (`ps` in our example), is called the *successor*.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些重要的术语可以帮助我们：调用“exec”（在我们的例子中是bash）的进程被称为“前任”；被调用和执行的进程（在我们的例子中是ps）被称为“继任”。
- en: Key points during an exec operation
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: exec操作期间的关键点
- en: 'The following sums up important points to note when a predecessor process execs a
    successor:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下总结了前任进程执行继任进程时需要注意的重要点：
- en: The successor process overwrites (or overlays) the predecessor's virtual address
    space.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继任进程覆盖（或叠加）了前任的虚拟地址空间。
- en: In effect, the predecessor's text, data, library, and stack segments are now
    replaced by that of the successor's.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上，前任的文本、数据、库和堆栈段现在被继任的替换了。
- en: The OS will take care of the size adjustments.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统将负责大小调整。
- en: No new process has been created—the successor now runs in the context of the
    old predecessor.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有创建新进程——继任现在在旧前任的上下文中运行。
- en: Several predecessor attributes (including but not limited to the PID and open
    files) thus get auto-inherited by the successor.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前任属性（包括但不限于PID和打开文件）因此被继任者自动继承。
- en: (The astute reader could then question why, in our previous example, the PID
    of `ps` is not 3,396 ? Patience, please, we shall have the precise answer on the
    GitHub repository).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: （敏锐的读者可能会问，为什么在我们之前的例子中，`ps`的PID不是3,396？请耐心等待，我们将在GitHub存储库中得到确切的答案）。
- en: 'On a successful exec, there is no possibility of returning to the predecessor;
    it''s gone. Colloquially, performing an exec is like committing suicide for the
    predecessor: After successful execution, the successor is all that''s left; returning
    to the predecessor is out of the question:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在成功的exec中，没有可能返回到前任；它已经消失了。口头上说，执行exec就像对前任自杀一样：成功执行后，继任就是唯一留下的；返回到前任是不可能的：
- en: '![](img/b9370fcb-5c9a-4169-a06e-d84998fdf879.png)*Fig 2: The exec operation*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/b9370fcb-5c9a-4169-a06e-d84998fdf879.png)*图2：exec操作*'
- en: Testing the exec axiom
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试exec公理
- en: Can you test this `exec` axiom described above? Sure. Let's try this in three
    different ways.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你能测试上面描述的`exec`公理吗？当然。我们可以用三种不同的方式来尝试。
- en: Experiment 1 – on the CLI, no frills
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验1 - 在CLI上，不花俏
- en: 'Follow the simple steps here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下简单的步骤：
- en: Fire up a shell (a Terminal window, typically, on a GUI-based Linux)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个shell（通常是一个基于GUI的Linux上的终端窗口）
- en: 'In the window, or more precisely, at the shell prompt, type this:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口中，或者更准确地说，在shell提示符中，输入这个：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What do you notice? Can you explain it?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了什么？你能解释一下吗？
- en: Hey, come on, please try it out first, and then read on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，请先试一下，然后再继续阅读。
- en: Yes, the terminal window process is the predecessor here; upon an `exec` it's
    overwritten by the successor process `ps`, which does its work and exits (you
    probably did not see the output as it disappeared too quickly). `ps `is the successor
    process, and, of course, we cannot return to the predecessor (the Terminal window)—`ps`
    has literally replaced its VAS.  Thus, the Terminal window effectively disappears.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，终端窗口进程在这里是前任；在exec之后，它被继任进程“ps”覆盖，完成它的工作并退出（你可能没有看到输出，因为它消失得太快了）。`ps`是继任进程，当然，我们不能返回到前任（终端窗口）——`ps`已经完全替换了它的VAS。因此，终端窗口实际上消失了。
- en: Experiment 2 – on the CLI, again
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验2 - 在CLI上，再次
- en: 'This time, we''ll make it easier on you! Follow the given steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们会让你更容易！按照给定的步骤进行：
- en: Fire up a shell (a Terminal window, typically, on a GUI-based Linux).
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个shell（通常是一个基于GUI的Linux上的终端窗口）。
- en: In the window, or more precisely, at the shell prompt, run `ps` followed by
    `bash ` —yes, we're spawning a subshell here, followed by `ps` once more. (Check
    out the next screenshot; notice the PIDs of the original and sub-shell Bash processes
    - 3,396 and 13,040.).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在窗口中，或者更准确地说，在shell提示符中，先运行`ps`，然后是`bash`——是的，我们在这里生成一个子shell，然后再次运行`ps`。（查看下一个截图；注意原始和子shell
    Bash进程的PID - 3,396和13,040）。
- en: On the sub-shell, `exec` the `ps` command; this `ps` successor process overwrites
    (or overlays) the process image of the predecessor process—the bash sub-shell.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在子shell中，`exec` `ps`命令；这个`ps`继任进程覆盖（或叠加）了前任进程——bash子shell的进程镜像。
- en: 'Observe the output: In the `exec ps` command output, the PID of `ps` is the
    PID of the bash subshell process: 13,040! This suggests that it''s running in
    the context of that process.'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察输出：在`exec ps`命令输出中，`ps`的PID是bash子shell进程的PID：13,040！这表明它是在该进程的上下文中运行。
- en: 'Also notice we''re back to the original bash shell process PID 3,396 now, as,
    of course, we cannot return to the predecessor:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要注意，现在我们又回到了原始的bash shell进程PID 3,396，因为当然，我们无法返回到前身：
- en: '![](img/1fe76029-5ac1-418b-bdac-2c603d074b07.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1fe76029-5ac1-418b-bdac-2c603d074b07.png)'
- en: A third experimental run will follow shortly, once we've got some `exec` APIs
    to play with.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第三次实验运行很快就会开始，一旦我们有了一些`exec`API来玩耍。
- en: The point of no return
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不归路
- en: 'It''s important for the systems programmer to understand that, once an `exec`
    operation is successful, there is no return to the predecessor process. To illustrate
    this, consider the rough call graph here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于系统程序员来说，重要的是要理解，一旦`exec`操作成功，就不会返回到前身进程。为了说明这一点，考虑这里的粗略调用图：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`main()` calls `foo()`*, *which calls `exec(something)`; once the `exec` is
    successful, `bar()` will never run!'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`调用`foo()`*，*它调用`exec(something)`；一旦`exec`成功，`bar()`就永远不会运行了！'
- en: Why not? We cannot reach it in the predecessor's execution path as the entire
    execution context has now changed—to the context of the successor process (something).
    The PID remains intact though.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不呢？我们无法在前身的执行路径中到达它，因为整个执行上下文现在已经改变 - 到了后继进程的上下文（某个东西）。PID仍然保持不变。
- en: Only if the `exec` fails will the function `bar()` get control (as, of course,
    we would still be in the context of the predecessor).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在`exec`失败时，函数`bar()`才会获得控制（当然，我们仍然会处于前身的上下文中）。
- en: As a further fine point, note that it's possible that the `exec()` operation
    itself succeeds, but the process being executed, something, fails. That's OK;
    it does not change the semantics; `bar()` will still not execute, as the successor
    has taken over.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进一步的细节，注意`exec()`操作本身可能成功，但被执行的进程`something`失败。没关系；这不会改变语义；`bar()`仍然不会执行，因为后继者已经接管了。
- en: Family time – the exec family APIs
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 家庭时间 - exec家族API
- en: 'Now that we have understood the `exec` semantics, it''s time we saw how to
    perform the `exec` operation programmatically. Unix and Linux provide several
    C APIs, seven in fact, that all ultimately do the same job: They have the predecessor
    process `exec` the successor.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了`exec`的语义，是时候看看如何在程序中执行`exec`操作了。Unix和Linux提供了几个C API，实际上有七个，最终都是做同样的工作：它们让前身进程`exec`后继进程。
- en: So, there are seven APIs that all do the same thing? Mostly, yes; hence they
    are called the `exec` family of APIs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，有七个API都做同样的事情？大多数是的；因此它们被称为`exec`家族API。
- en: 'Lets take a look at them:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看它们：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Hang on, though we said seven APIs, but the list above has six; indeed: the
    seventh is special in a sense and not shown above. As usual, have a bit of patience;
    we will cover it!'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，虽然我们说有七个API，但上面的列表只有六个；确实：第七个在某种意义上是特殊的，没有显示在上面。像往常一样，耐心等待一下；我们会介绍的！
- en: The reality is that though each API will ultimately perform the same job, using
    a particular one helps based on the situation you are in (convenience-wise). Lets
    not nitpick, and, for now, at least, disregard their differences; instead, let's
    focus on understanding the first one; the rest will automatically and easily follow.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，尽管每个API最终都会执行相同的工作，但根据您所处的情况（方便性），使用特定的API会有所帮助。让我们不要挑剔，至少现在，忽略它们的差异；相反，让我们专注于理解第一个；其余的将自动而轻松地跟随。
- en: 'Take the first API, the `execl(3)`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 看看第一个API，`execl(3)`：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Does it take two, three, or more parameters? Well, in case you are new to it,
    the ellipse— `...` — represents a variable argument list or `varargs`, a feature
    supported by the compiler.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要两个、三个还是更多的参数？如果你对此还不熟悉，省略号`...`表示可变参数列表或`varargs`，这是编译器支持的一个特性。
- en: The first parameter is the path name to the application you would like to execute.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是您想要执行的应用程序的路径名。
- en: 'From the second parameter onward, the `varargs` , the argument(s) to pass to
    the successor process are inclusive of `argv[0]`. Think about it, in the simple
    experiments above, we passed along parameters on the command line via the shell
    process; in reality, it was really the shell process, the predecessor, that passed
    arguments required by the successor process. This makes sense: Who else but the
    predecessor would pass arguments to the successor?'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从第二个参数开始，`varargs`，传递给后继进程的参数包括`argv[0]`。想想，在上面的简单实验中，我们通过shell进程在命令行上传递了参数；实际上，真正传递给后继进程所需参数的是前身，也就是shell进程。这是有道理的：除了前身，谁还会传递参数给后继者呢？
- en: 'How will the compiler know that you are done passing along arguments? Simple:
    you must null terminate the argument list: `execl(const char *pathname_to_successor_program,
    const char *argv0, const char *argv1, ..., const char *argvn, (char *)0);`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器如何知道你何时传递参数？简单：你必须用空指针终止参数列表：`execl(const char *pathname_to_successor_program,
    const char *argv0, const char *argv1, ..., const char *argvn, (char *)0);`
- en: 'Now you can see why it''s named the way it is: the `execl` API, of course,
    performs an exec; the last letter `l` implies long format; each argument of the
    successor process is passed to it.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到为什么它被命名为`execl`：当然，`execl` API执行`exec`；最后一个字母`l`表示长格式；后继进程的每个参数都传递给它。
- en: 'To clarify this, let''s write a simple example C program; its job is to invoke
    the `uname` process:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清这一点，让我们写一个简单的示例C程序；它的工作是调用`uname`进程：
- en: 'For readability, only the relevant parts of the code are displayed here; to
    view and run it, the entire source code is available here: [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，这里只显示了代码的相关部分；要查看和运行它，整个源代码在这里可用：[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here are a few points to note:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些需要注意的要点：
- en: The first argument to the `execl` API is the path name of the successor.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execl` API的第一个参数是继承者的路径名。'
- en: 'The second parameter is the name of the program. Be careful: a fairly typical
    newbie mistake is to leave it out!'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是程序的名称。小心：一个相当典型的新手错误是漏掉它！
- en: 'In this simple case, we only then pass along whatever the user sends as the
    argument `argv[1]`: `-a` or `-r` ; we don''t even perform robust error checking
    to ensure the correct parameter is passed by the user (we leave it as an exercise
    for you).'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种简单的情况下，我们只传递用户发送的参数`argv[1]`：`-a`或`-r`；我们甚至没有进行健壮的错误检查，以确保用户传递了正确的参数（我们把它留给你作为练习）。
- en: 'If we just attempt to null-terminate with a single `0`, the compiler complains,
    with a warning such as this (this could differ depending on the `gcc` compiler
    version you use):'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们只尝试用一个单独的`0`来进行空终止，编译器会抱怨，警告如下（这可能取决于你使用的`gcc`编译器版本）：
- en: '`warning: missing sentinel in function call [-Wformat=]`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`warning: missing sentinel in function call [-Wformat=]`。'
- en: To eliminate the warning, you must typecast the `0` with `(char *)` as shown
    in the code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除警告，你必须像代码中所示的那样用`(char *)`对`0`进行强制转换。
- en: 'Finally, we use a `printf()` to demonstrate that control will never reach it.
    Why is this? Well, think about it:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用`printf()`来演示控制永远不会到达它。为什么呢？嗯，想想看：
- en: Either the `execl` succeeds; thus the successor process (`uname`) takes over.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要么`execl`成功；因此继承者进程（`uname`）接管。
- en: Or the `execl` fails; the `FATAL` macro performs error reporting and terminates
    the predecessor.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者`execl`失败；`FATAL`宏执行错误报告并终止前身。
- en: 'Let''s build and try it out:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建并尝试一下：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Pass an argument; we show a few examples here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 传递一个参数；我们在这里展示一些例子：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It does work (though, as can be seen from the last case, the `execl_eg`program's
    argument the error checking isn't great).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实有效（尽管，正如从最后一个案例中可以看到的那样，`execl_eg`程序的参数错误检查并不好）。
- en: 'We encourage you to try this simple program out yourself; in fact, experiment
    a bit: for example, change the first parameter to some unknown (for example, `/bin/oname`)
    and see what happens.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励你自己尝试这个简单的程序；事实上，多做一些实验：例如，将第一个参数更改为一些未知的内容（例如`/bin/oname`）并看看会发生什么。
- en: The wrong way
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误的方法
- en: Sometimes, to show the right way to do something, it's useful to first see it
    done the wrong way!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，为了展示正确的做法，首先看看错误的做法是有用的！
- en: Error handling and the exec
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理和exec
- en: 'Some programmer''s show off: They don''t use an *if* condition to check whether
    the `exec` API failed; they just write the line of code after an `exec` to be
    the failure case!'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序员炫耀：他们不使用*if*条件来检查`exec` API是否失败；他们只是在`exec`后写下一行代码作为失败情况！
- en: 'As an example, take the previous program, but change the code to this, the
    wrong way to do it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，拿前面的程序，但将代码更改为这样，这是错误的做法：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It works, yes: The only reason control will ever reach the `''FATAL()''` line
    is if the exec operation failed. This sounds cool, but please, do not code like
    that. Be professional, follow the rules and good coding style guidelines; you''ll
    be a better programmer and glad for it! (An innocent freshly minted programmer
    might not even realize that what follows the `execl` above is actually error handling;
    who could blame him? And he might attempt to put some business logic there!)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效，是的：控制将永远到达`'FATAL()'`行的唯一原因是exec操作失败。这听起来很酷，但请不要这样编码。要专业一点，遵循规则和良好的编码风格指南；你会成为一个更好的程序员并为此感到高兴！（一个无辜的新手程序员甚至可能没有意识到上面的`execl`之后是实际的错误处理；谁能怪他呢？他可能会尝试在那里放一些业务逻辑！）
- en: Passing a zero as an argument
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递零作为参数
- en: 'Let''s say we have a (fictional) requirement: From within our C code, we must
    execute the program `/projectx/do_this_now` passing along three parameters: `-1`,
    `0` and `55`. Like so:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个（虚构的）要求：从我们的C代码中，我们必须执行程序`/projectx/do_this_now`并传递三个参数：`-1`，`0`和`55`。就像这样：
- en: '`/projectx/do_this_now -1 0 55`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`/projectx/do_this_now -1 0 55`'
- en: 'Recall the syntax of the `exec` API:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下`exec` API的语法：
- en: '`execl(const char *pathname_to_successor_program, const char *argv0, const
    char *argv1, ..., const char *argvn, (char *)0);`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`execl(const char *pathname_to_successor_program, const char *argv0, const
    char *argv1, ..., const char *argvn, (char *)0);`'
- en: 'So, it seems quite trivial; let''s do it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这似乎相当琐碎；让我们做吧：
- en: '`execl("/projectx/do_this_now", "do_this_now", -1, 0, 55, (char *)0);`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`execl("/projectx/do_this_now", "do_this_now", -1, 0, 55, (char *)0);`'
- en: Whoops! The compiler will, or *could*, interpret the second argument to the
    successor `0` (after the `-1`) as the `NULL` terminator, and would therefore not
    see the following argument `55`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！编译器会，或者*可能*会，将继承者的第二个参数`0`（在`-1`之后）解释为`NULL`终结符，因此不会看到后面的参数`55`。
- en: 'Fixing this is easy; we just have to remember that *each argument to the* successor
    *process is of data type character pointer*, not integer; the `NULL` terminator
    itself is an integer (though to keep the compiler happy we typecast it to `(char
    *)`), like so:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 修复这很容易；我们只需要记住*每个传递给继承者进程的参数都是字符指针类型*，而不是整数；`NULL`终结符本身是一个整数（尽管为了让编译器满意，我们将其强制转换为`(char
    *)`），就像这样：
- en: '`execl("/projectx/do_this_now", "do_this_now", "-1", "0", "55", (char *)0);`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`execl("/projectx/do_this_now", "do_this_now", "-1", "0", "55", (char *)0);`'
- en: Specifying the name of the successor
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定继承者的名称
- en: 'No, we are not debating how to hack who will succeed Queen Elizabeth II to
    the throne here, sorry. What we are referring to is this: How can you correctly
    specify the name of the successor process; that is, can we programmatically change
    it to whatever we like?'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们这里不是在讨论如何黑掉谁将继承伊丽莎白二世王位的问题，抱歉。我们所指的是：如何正确指定继承进程的名称；也就是说，我们是否可以以编程方式将其更改为我们喜欢的任何内容？
- en: 'At first glance, it looks trivial indeed: The second parameter to the `execl`
    is the `argv[0]` argument to pass to the successor; in effect, it appears, its
    name! So, let''s try it out: We write a couple of C programs; the first one, the
    predecessor (`ch9/predcs_name.c`) is passed a name parameter from the user. It
    then execs another program of ours, `successor_setnm`  via the `execl` passing
    along the user-supplied name as the first parameter (within the API, it sets the
    successor `argv[0]` parameter to the predecessor''s `argv[1]`), like so: `execl("./successor_setnm",
    argv[1], argv[1], (char *)0);`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，它看起来确实很琐碎：`execl`的第二个参数是要传递给后继的`argv[0]`参数；实际上，它看起来像是它的名称！所以，让我们试一试：我们编写了一对C程序；第一个程序，前身（`ch9/predcs_name.c`）从用户那里传递一个名称参数。然后通过`execl`执行我们的另一个程序`successor_setnm`，并将用户提供的名称作为第一个参数传递给后继（在API中，它将后继的`argv[0]`参数设置为前身的`argv[1]`），如下所示：`execl("./successor_setnm",
    argv[1], argv[1], (char *)0);`
- en: 'Recall the `execl` syntax: `execl(pathname_to_successor_program, argv0, argv1,
    ..., argvn, 0);`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下`execl`的语法：`execl(pathname_to_successor_program, argv0, argv1, ..., argvn,
    0);`
- en: 'So, the thinking here is: The predecessor has set the successor''s `argv[0]`
    value to `argv[1]`, and thus the successor''s name should be the predecessor''s
    `argv[1]`. However, it does not work out; see the output from a sample run:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的想法是：前身已将后继的`argv[0]`值设置为`argv[1]`，因此后继的名称应该是前身的`argv[1]`。然而，它并没有成功；请看一次运行的输出：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We deliberately have the successor process invoke the `pause(2)` system call
    (it simply causes it to sleep until it receives a signal). This way, we can run
    it in the background, and then run `ps` to lookup the successor PID and name!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意让后继进程调用`pause(2)`系统调用（它只是导致它休眠，直到它收到一个信号）。这样，我们可以在后台运行它，然后运行`ps`来查找后继PID和名称！
- en: 'Interesting: We find that, though the name is not what we want in `ps` output
    (above), it is correct in the `printf`*;* implying that `argv[0]` has been correctly
    received and set to the successor.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是：我们发现，虽然在`ps`输出中名称不是我们想要的（上面），但在`printf`中是正确的；这意味着`argv[0]`已经正确接收并设置为后继。
- en: 'OK, we must clean up; lets kill off the background process now:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们必须清理一下；现在让我们杀死后台进程：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So, as is now apparent, what we''ve done preceding is not enough: To reflect
    the name we want at the level of the OS, we need an alternate API; one such API
    is the `prctl(2)` system call (or even the `pthread_setname_np(3)` pthreads API).
    Without getting into too much detail here, we use it with the `PR_SET_NAME` parameter
    (as usual, please see the man page on `prctl(2)` for full details). Hence, the
    correct code using the `prctl(2)` system call (only the relevant code snippet
    from `successor_setnm.c` is displayed here):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在显而易见的是，我们之前所做的还不够：为了在操作系统层面反映我们想要的名称，我们需要一种替代的API；这样的API之一是`prctl(2)`系统调用（甚至是`pthread_setname_np(3)`线程API）。在这里不详细介绍，我们使用`PR_SET_NAME`参数（通常，请参阅`prctl(2)`的man页面以获取完整详情）。因此，使用`prctl(2)`系统调用的正确代码（仅显示`successor_setnm.c`中的相关代码片段）如下：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, we  now run it the right way *(*the logic involves passing along an optional
    second parameter which will be used to `_correctly_` set the successor process
    name):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们现在以正确的方式运行它（逻辑涉及传递一个可选的第二个参数，该参数将用于“正确”设置后继进程的名称）：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This time it works exactly as expected.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这次它的工作完全符合预期。
- en: The remaining exec family APIs
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剩下的exec系列API
- en: 'Great, we''ve covered in detail how to and how not to use the first of the
    `exec` family of APIs—the `execl(3)`. What about the remainder? Let''s check them
    out; reproduced for the reader''s convenience is the list:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们已经详细介绍了如何正确和不正确地使用`exec` API系列中的第一个`execl(3)`。剩下的呢？让我们来看看它们；为了方便读者，以下是列表：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As mentioned several times, the `execl` syntax is this: `execl(const char *pathname_to_successor_program,
    const char *argv0, const char *argv1, ..., const char *argvn, (char *)0);`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如多次提到的，`execl`的语法是这样的：`execl(const char *pathname_to_successor_program, const
    char *argv0, const char *argv1, ..., const char *argvn, (char *)0);`
- en: 'Recall, it''s named `execl`; the `l` implies a long format variable argument
    list: each argument of the successor process is passed to it in turn.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，它的名字是`execl`；`l`意味着长格式可变参数列表：后继进程的每个参数依次传递给它。
- en: Now let's look at the other APIs in the family.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看家族中的其他API。
- en: The execlp API
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: execlp API
- en: 'The `execlp` is a slight variation on the `execl`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`execlp`是`execl`的一个小变体：'
- en: '`int **execlp**(const char ***file**, const char *arg, ...);`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`int **execlp**(const char ***file**, const char *arg, ...);`'
- en: As before, the `l` in `execlp` implies a long format variable argument list;
    the `p` implies that the environment variable `PATH` is searched for the program
    to execute. As you are probably aware, the PATH environment variable consists
    of a set of colon-delimited (`:`) directories to search for the program file to
    run; the first match is the program that is executed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，`execlp`中的`l`意味着长格式可变参数列表；`p`意味着环境变量`PATH`用于搜索要执行的程序。您可能知道，PATH环境变量由一组以冒号（`:`）分隔的目录组成，用于搜索要运行的程序文件；第一个匹配项是要执行的程序。
- en: 'For example, on our Ubuntu VM (where we are logged in as the user `seawolf`):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的Ubuntu VM上（我们以用户`seawolf`登录）：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Thus, if you execute a process via the `execlp`, you need not give the absolute
    or full path name as the first parameter, but just the program name; see how the
    following two examples differ:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您通过`execlp`执行一个进程，您不需要给出绝对或完整的路径名作为第一个参数，而只需要给出程序名；看看以下两个示例的区别：
- en: '`execl("/bin/uname", "uname", argv[1], (char *)0);`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`execl("/bin/uname", "uname", argv[1], (char *)0);`'
- en: '`**execlp**("uname", "uname", argv[1], (char *)0);`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`**execlp**("uname", "uname", argv[1], (char *)0);`'
- en: With the `execl`, you have to specify the full path name to `uname`; with the
    `execlp`, you need not; the library routine will perform the work of looking up
    the PATH and figuring out the match to `uname`! (It would find the first match
    in `/bin`).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`execl`，您必须指定`uname`的完整路径名；使用`execlp`，您不需要；库例程将执行查找PATH和找到`uname`的匹配的工作！（它会在`/bin`中找到第一个匹配项）。
- en: 'Use the `which` utility to locate a program, in effect finding it''s first
    match in the path. For example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`which`工具来定位一个程序，实际上是在路径中找到它的第一个匹配项。例如：
- en: '`$ which uname`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ which uname`'
- en: '`/bin/uname`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`/bin/uname`'
- en: '`$`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`'
- en: This, the fact the `execlp` automatically searches the path, indeed is convenient;
    note though, this is at the possible cost of security!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`execlp`自动搜索路径的事实确实很方便；但需要注意的是，这可能会牺牲安全性！
- en: Hackers write programs called Trojans - essentially, programs that pretend to
    be something they're not; these are obviously dangerous. If a hacker can place
    a Trojan version of `uname` in your, say, home directory, and modify the PATH
    environment variable to search your home directory first, then they could take
    control when you (think) you are running `uname`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 黑客编写称为特洛伊木马的程序——基本上是假装成其他东西的程序；这显然是危险的。如果黑客能够在你的家目录中放置一个`uname`的特洛伊木马版本，并修改PATH环境变量以首先搜索你的家目录，那么当你（以为）运行`uname`时，他们就可以控制你。
- en: For security reasons, it's always better to specify the full `pathname` when
    executing a program (hence, avoid using the `execlp`, `execvp`, and the `execvpe`
    APIs).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全原因，最好在执行程序时指定完整的`pathname`（因此，避免使用`execlp`、`execvp`和`execvpe`API）。
- en: What if the PATH environment variable is undefined? In this case, the APIs default
    to searching the current working directory (the `cwd`) of the process as well
    as something called the `confstr` path, which usually defaults to the directory `/bin` followed
    by `/usr/bin`*.*
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果PATH环境变量未定义会怎么样？在这种情况下，API会默认搜索进程的当前工作目录（`cwd`）以及一个叫做`confstr`路径，通常默认为目录`/bin`，然后是`/usr/bin`。
- en: The execle API
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: execle API
- en: 'Now for the `execle(3)` API; its signature is:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是关于`execle(3)`的API；它的签名是：
- en: '`int **execle**(const char *path, const char *arg, ...,char * const envp[]);`'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`int **execle**(const char *path, const char *arg, ...,char * const envp[]);`'
- en: As before, the `l` in `execle` implies a long format variable argument list;
    the `e` implies that we can pass along an array of environment variables to the
    successor process.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，`execle`中的`l`表示长格式可变参数列表；`e`表示我们可以传递一个环境变量数组给后续进程。
- en: The process environment consists of a set of `<name>=<value>` variable pairs.
    The environment is actually unique to each process and is stored within the process
    stack segment. You can see the entire list via either the `printenv`*,* `env`*,*
    or `set` commands (*set* is a shell built-in). Programmatically, use the `extern`
    `char **environ` to gain access to the process's environment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 进程环境由一组`<name>=<value>`变量对组成。环境实际上对每个进程都是唯一的，并存储在进程堆栈段中。你可以通过`printenv`、`env`或`set`命令（`set`是一个shell内置命令）来查看整个列表。在程序中，使用`extern
    char **environ`来访问进程的环境。
- en: By default, the successor will inherit the environment of the predecessor process.
    What if this is not what is required; for example, we would like to execute a
    process but change the value of, say, the PATH (or perhaps introduce a new environment
    variable into the mix). To do so, we would have the predecessor process make a
    copy of the environment, modify it as required (perhaps adding, editing, deleting
    variables as required), and then pass along the pointer to the new environment
    to the successor process. That's precisely what the last parameter `char * const
    envp[]` is meant for.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，后继进程将继承前驱进程的环境。如果这不是所需的，该怎么办；例如，我们想要执行一个进程，但更改PATH的值（或者引入一个新的环境变量）。为此，前驱进程将复制环境，根据需要修改它（可能添加、编辑、删除变量），然后将指向新环境的指针传递给后继进程。这正是最后一个参数`char
    * const envp[]`的用途。
- en: 'Old Unix programs used to accept a third argument to `main()`: `char **arge`,
    which represented the process environment. This is now considered deprecated;
    use the `extern environ`  instead.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的Unix程序曾经接受`main()`的第三个参数：`char **arge`，表示进程环境。现在这被认为是不推荐的；应该使用`extern environ`代替。
- en: There is no mechanism to pass just a few environment variables to the successor
    process; the whole bunch—in the form of a two-dimensional array of strings (which
    is itself `NULL`-terminated) must be passed.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 没有机制只传递一些环境变量给后续进程；整个一堆环境变量——以字符串的二维数组形式（本身是`NULL`结尾）必须被传递。
- en: The execv API
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: execv API
- en: 'The *execv(3) *API''s signature is:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*execv(3)* API的签名是：'
- en: '`int **execv**(const char *path, char *const argv[]);`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`int **execv**(const char *path, char *const argv[]);`'
- en: 'As can be seen, the first parameter is the pathname of the successor process.
    The second parameter is, similar to the environment list above, a two-dimensional
    array of strings (each of them `NULL`-terminated) holding all the arguments to
    pass to the successor, starting from `argv[0]`. Think about it, it''s identical
    to what we, C programmers, are so used to; this is the signature of the `main()` function
    in C:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，第一个参数是后继进程的路径名。第二个参数与上面的环境列表类似，是一个二维字符串数组（每个字符串都以`NULL`结尾），保存所有要传递给后继进程的参数，从`argv[0]`开始。想想看，这与我们C程序员如此习惯的东西是一样的；这就是C中`main()`函数的签名：
- en: '`int main(int argc, char *argv[]);`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`int main(int argc, char *argv[]);`'
- en: '`argc`, of course, is the number of parameters received, including the program
    name itself (held in `argv[0]`), and **`argv`** is a pointer to a two-dimensional
    array of strings (each of them `NULL`-terminated) holding all the arguments starting
    from `argv[0]`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`argc`，当然，是接收到的参数数量，包括程序名称本身（保存在`argv[0]`中），而**`argv`**是指向一个二维字符串数组的指针（每个字符串都以`NULL`结尾），保存从`argv[0]`开始的所有参数。'
- en: Hence, we colloquially call this the short format (as opposed to the long format we
    used earlier - the `l` style). When you see the `v` (short for argv), it represents
    the short format argument-passing style.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们口头上称之为短格式（与之前使用的长格式`l`风格相对）。当你看到`v`（代表argv）时，它代表短格式参数传递风格。
- en: 'Now, the remaining two APIs are simple:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的两个API很简单：
- en: The `execvp(3)`: short format arguments, and path being searched.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execvp(3)`：短格式参数，以及被搜索的路径。'
- en: The `execvpe(3)`: short format arguments, path being searched, and environment
    list being explicitly passed to the successor. Additionally, this API requires
    the feature test macro `_GNU_SOURCE` to be defined (which, incidentally, we do
    in all this book's source code).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execvpe(3)`：短格式参数，正在搜索的路径，以及显式传递给后继的环境列表。此外，这个API要求定义特性测试宏`_GNU_SOURCE`（顺便说一句，在本书的所有源代码中我们都这样做）。'
- en: 'The `exec` functions with the `p` in them—the ones that search the `PATH`—the `execlp`,
    `execvp`, and `execvpe`, have an additional feature: If the file they are searching
    for is found but permission to open it is lacking, they will not fail immediately
    (like the other `exec` APIs that would fail and set `errno` to `EACCESS`); instead,
    they will continue searching the remainder of the `PATH` for the file.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`p`的`exec`函数——搜索`PATH`的函数——`execlp`、`execvp`和`execvpe`具有一个额外的特性：如果它们正在搜索的文件被找到但没有权限打开它，它们不会立即失败（就像其他`exec`
    API会失败并将`errno`设置为`EACCESS`一样）；相反，它们将继续搜索`PATH`的其余部分以寻找文件。
- en: Exec at the OS level
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在操作系统级别执行
- en: Up until now, we have covered six of the seven *exec family* APIs. Finally,
    the seventh one is the `execve(2)`. Did you notice? The `2` in brackets conveys
    that it's a system call(recall the details covered regarding system calls in [Chapter
    1](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml), *Linux System Architecture*).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了七个*exec API家族*中的六个。最后，第七个是`execve(2)`。你注意到了吗？括号中的`2`表示它是一个系统调用（回想一下[第1章](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml)中关于系统调用的细节）。
- en: The fact is, all the preceding six `exec` APIs are within `glibc`—the library
    layer; only the `execve(2)` is a system call. You will realize that, ultimately,
    to have a process be able to execute another program—thus launching or running
    a successor—will require OS-level support. So, yes, the reality is that all the
    above six `exec` APIs are merely wrappers; they transform their arguments and
    invoke the `execve` system call.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，所有前面的六个`exec` API都在`glibc`库层内；只有`execve(2)`是一个系统调用。你会意识到，最终，要使一个进程能够执行另一个程序——从而启动或运行一个后继程序——将需要操作系统级别的支持。所以，是的，事实是，所有上述六个`exec`
    API只是包装器；它们转换它们的参数并调用`execve`系统调用。
- en: 'This is the signature of the `execve(2)`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`execve(2)`的签名：
- en: '`int execve(const char *filename, char *const argv[], char *const envp[]);`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`int execve(const char *filename, char *const argv[], char *const envp[]);`'
- en: Take a look at the exec family APIs summary table.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下exec API家族的总结表。
- en: Summary table – exec family of APIs
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结表 - exec API家族
- en: 'Here is a table to summarize all seven of the `exec` family APIs:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个总结所有七个`exec`家族API的表：
- en: '| **Exec API** | **Arguments: long format (l)** | **Arguments: short format
    (v)** | **PATH searched? (p)** | **Environment passed? (e)** | **API layer** |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| **Exec API** | **参数：长格式（l）** | **参数：短格式（v）** | **搜索路径？（p）** | **传递环境？（e）**
    | **API层** |'
- en: '| `execl` | Y | N | N | N | Lib |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `execl` | Y | N | N | N | Lib |'
- en: '| `execlp` | Y | N | Y | N | Lib |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `execlp` | Y | N | Y | N | Lib |'
- en: '| `execle` | Y | N | N | Y | Lib |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `execle` | Y | N | N | Y | Lib |'
- en: '| `execv` | N | Y | N | N | Lib |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `execv` | N | Y | N | N | Lib |'
- en: '| `execvp` | N | Y | Y | N | Lib |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `execvp` | N | Y | Y | N | Lib |'
- en: '| `execvpe` | N | Y | Y | Y | Lib |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `execvpe` | N | Y | Y | Y | Lib |'
- en: '| `execve` | N | Y | N | Y | SysCall |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `execve` | N | Y | N | Y | SysCall |'
- en: 'The exec APIs format: `exec<foo>`, where `<foo>` is differing combinations
    of `{l,v,p,e}`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: exec API的格式：`exec<foo>`，其中`<foo>`是`{l,v,p,e}`的不同组合。
- en: All the listed APIs, on success, as we have learned, do not return at all. Only
    upon failure, would you see a return value; as per the usual norms, the global
    variable `errno` will get set to reflect the cause of the error, which can be
    conveniently looked up via the `perror(3)` or `strerror(3)` APIs (as an example,
    within the book's provided source code, check out the `FATAL` macro within the `common.h`header
    file).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 所有列出的API，在成功时，正如我们所学的那样，都不会返回。只有在失败时，你才会看到一个返回值；根据通常的规范，全局变量`errno`将被设置以反映错误的原因，可以方便地通过`perror(3)`或`strerror(3)`API来查找（例如，在本书提供的源代码中，查看`common.h`头文件中的`FATAL`宏）。
- en: Code example
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'In the introduction to this chapter, we mentioned a requirement: from within
    a GUI frontend, to display the content of a system-generated PDF document. Lets
    do this here.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的介绍中，我们提到了一个要求：从GUI前端，显示系统生成的PDF文档的内容。让我们在这里做这个。
- en: To do so, we would require a PDF reader application; we can assume we have one.
    Indeed, on many Linux distributions, the evince application is a good PDF reader
    application, usually preinstalled (true on Ubuntu and Fedora, among others).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要一个PDF阅读器应用程序；我们可以假设我们有一个。事实上，在许多Linux发行版中，evince应用程序是一个很好的PDF阅读器应用程序，通常预装（在Ubuntu和Fedora等发行版上是真的）。
- en: 'Well, here, we shall not bother with a GUI frontend application, we shall use
    plain old C to write a CLI app that, given a PDF document `pathname`, executes
    the evince PDF reader application. What PDF document do we display? Ah, that''s
    a surprise! (take a look):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不会使用GUI前端应用程序，我们将使用老式的C语言编写一个CLI应用程序，给定一个PDF文档的`路径名`，执行evince PDF阅读器应用程序。我们要显示哪个PDF文档？啊，这是一个惊喜！（看一下）：
- en: 'For readability, only the relevant parts of the code are displayed as follows;
    to view and run it, the entire source code is available here:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性，只显示代码的相关部分如下；要查看和运行它，整个源代码在这里可用：
- en: '[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)。'
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We invoke the preceding function from `main()` as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`main()`中调用前面的函数如下：
- en: '[PRE16]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We build it, then perform a sample run:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建它，然后执行一个示例运行：
- en: '[PRE17]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here is a screenshot of the action!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个动作的截图！
- en: '![](img/6ff50ecc-cff5-47a5-9b82-fc5ec961629c.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ff50ecc-cff5-47a5-9b82-fc5ec961629c.png)'
- en: 'What if we are running Linux on the console only (no GUI)? Then, of course,
    the preceding app will not work (and evince is unlikely to even be installed).
    Here is an example of this case:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只在控制台上运行Linux（没有GUI）？那么，当然，前面的应用程序将无法工作（而且evince甚至可能没有安装）。这是这种情况的一个例子：
- en: '[PRE18]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, why not try modifying the above app to use a CLI PDF toolset instead;
    one such toolset is from the Poppler project (see the following note). Within
    it, one of the interesting utilities it provides is `pdftohtml`. Why not use it
    to generate HTML from a PDF document? We leave it as an exercise for the reader
    (see the *Questions* section on the GitHub repository).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，为什么不尝试修改上述应用程序，改用CLI PDF工具集呢；其中一个这样的工具集来自Poppler项目（见下面的注释）。其中一个有趣的实用工具是`pdftohtml`。为什么不使用它来从PDF文档生成HTML呢？我们把这留给读者作为一个练习（请参阅GitHub存储库上的*问题*部分）。
- en: 'These useful PDF utilities are provided by an open source project called Poppler.
    You can easily install these PDF utilities, on an Ubuntu box: `sudo apt install
    poppler-utils`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这些有用的PDF实用程序是由一个名为Poppler的开源项目提供的。您可以在Ubuntu上轻松安装这些PDF实用程序：`sudo apt install
    poppler-utils`
- en: 'We can quite easily trace what happens in the `pdfrdr_exec` program; here,
    we use the `ltrace(1)` to see the library calls issued:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地跟踪`pdfrdr_exec`程序中发生的情况；在这里，我们使用`ltrace(1)`来查看发出的库调用：
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The key call: the `execv` of course is seen; interestingly, `ltrace` then helpfully
    tells us that there''s no return ... from it. We then see the library APIs of
    the evince software itself.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 关键调用：当然可以看到`execv`；有趣的是，`ltrace`友好地告诉我们它没有返回值...。然后我们看到了evince软件本身的库API。
- en: What if we use `strace(1)` to see the system calls issued?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`strace(1)`来查看发出的系统调用呢？
- en: '[PRE20]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Yes, the very first one is the `execve(2)`, proving that the `execv(3)` library
    API invokes the `execve(2)` system call. The rest of the output, of course, is
    the system calls issued by the evince process as it executes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，第一个是`execve(2)`，证明了`execv(3)`库API调用了`execve(2)`系统调用。当然，输出的其余部分是evince进程执行时发出的系统调用。
- en: Summary
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered the Unix/Linux `exec` programming model; the key concept
    of the predecessor and successor processes, and, importantly, how the successor
    (more-or-less completely) overlays the predecessor. The seven `exec` family APIs were
    covered, along with several code examples. Error handling, successor name specification,
    and so on, were covered as well. The systems programmer will now have sufficient
    knowledge to write C code that correctly executes a given program from within
    a process.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Unix/Linux的`exec`编程模型；前身和后继进程的关键概念，以及后继进程（或多或少地）如何覆盖前身。介绍了七个`exec`家族API，以及几个代码示例。还介绍了错误处理、后继名称规范等内容。系统程序员现在将有足够的知识来编写正确执行给定程序的C代码。
