["```\npid_t fork(void);\n```", "```\nint main(int argc, char **argv)\n{\n    fork();\n    printf(\"Hello, fork.\\n\");\n    exit (EXIT_SUCCESS);\n}\n```", "```\n$ make fork1\ngcc -Wall -c ../../common.c -o common.o\ngcc -Wall   -c -o fork1.o fork1.c\ngcc -Wall -o fork1 fork1.c common.o\n$ ./fork1 \nHello, fork.\nHello, fork.\n$ \n```", "```\n    if (fork() == -1)\n        FATAL(\"fork failed!\\n\");\n    printf(\"Hello, fork.\\n\");\n    exit(EXIT_SUCCESS);\n```", "```\n    printf(\"PID %d: Hello, fork.\\n\", getpid());\n```", "```\n$ ./fork3 \nPID 25496: Hello, fork.\nPID 25497: Hello, fork.\n$ \n```", "```\n    if (fork() == -1)\n        FATAL(\"fork failed!\\n\");\n    printf(\"PID %d: Hello, fork.\\n\", getpid());\n    exit(EXIT_SUCCESS);\n```", "```\npid_t fork(void);\n```", "```\n$ echo | gcc -E -xc -include 'unistd.h' - | grep \"typedef.*pid_t\"\ntypedef int __pid_t;\ntypedef __pid_t pid_t;\n$ \n```", "```\nint main(int argc, char **argv)\n{\n    pid_t ret;\n\n    if (argc != 3) {\n        fprintf(stderr,\n            \"Usage: %s {child-alive-sec} {parent-alive-sec}\\n\",\n            argv[0]);\n        exit(EXIT_FAILURE);\n    }\n    /* We leave the validation of the two parameters as a small\n     * exercise to the reader :-)\n     */\n\n    switch((ret = fork())) {\n    case -1 : FATAL(\"fork failed, aborting!\\n\");\n    case 0 : /* Child */\n          printf(\"Child process, PID %d:\\n\"\n                 \" return %d from fork()\\n\"\n                        , getpid(), ret);\n          foo(atoi(argv[1]));\n          printf(\"Child process (%d) done, exiting ...\\n\",\n               getpid());\n          exit(EXIT_SUCCESS);\n    default : /* Parent */\n          printf(\"Parent process, PID %d:\\n\"\n                 \" return %d from fork()\\n\"\n                      , getpid(), ret);\n          bar(atoi(argv[2]));\n    }\n    printf(\"Parent (%d) will exit now...\\n\", getpid());\n    exit(EXIT_SUCCESS);\n}\n```", "```\n$ ./fork4 -1 -2\nParent process, PID 6797 :: calling bar()...\n fork4.c:bar :: will take a nap for 4294967294s ...\nChild process, PID 6798 :: calling foo()...\n fork4.c:foo :: will take a nap for 4294967295s ...\n[...]\n```", "```\nstatic void foo(unsigned int nsec)\n{\n    printf(\" %s:%s :: will take a nap for %us ...\\n\",\n            __FILE__, __FUNCTION__, nsec);\n    sleep(nsec);\n}\n```", "```\n$ ./fork4\nUsage: ./fork4 {child-alive-sec} {parent-alive-sec}\n$ ./fork4 3 7\nParent process, PID 8228:\n return 8229 from fork()\n fork4.c:bar :: will take a nap for 7s ...\nChild process, PID 8229:\n return 0 from fork()\n fork4.c:foo :: will take a nap for 3s ...\nChild process (8229) done, exiting ...\nParent (8228) will exit now...\n$ \n```", "```\n$ ./fork4 10 20 &\n[1] 308\nParent process, PID 308:\n return 312 from fork()\n fork4.c:bar :: will take a nap for 20s ...\nChild process, PID 312:\n return 0 from fork()\n fork4.c:foo :: will take a nap for 10s ...\n$ ps\n  PID TTY          TIME CMD\n  308 pts/0    00:00:00 fork4\n  312 pts/0    00:00:00 fork4\n  314 pts/0    00:00:00 ps\n32106 pts/0    00:00:00 bash\n$ ps -l\nF S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD\n0 S  1000   308 32106  0  80   0 -  1111 hrtime pts/0    00:00:00 fork4\n1 S  1000   312   308  0  80   0 -  1111 hrtime pts/0    00:00:00 fork4\n0 R  1000   319 32106  0  80   0 -  8370 -      pts/0    00:00:00 ps\n0 S  1000 32106 32104  0  80   0 -  6003 wait   pts/0    00:00:00 bash\n$ \n$ Child process (312) done, exiting ...            *<< after 10s >>*\nParent (308) will exit now...                      *<< after 20s >>*\n<Enter>\n[1]+  Done                    ./fork4 10 20\n$ \n```", "```\n$ ./fork4_prnum \nUsage: ./fork4_prnum {child-numbytes-to-write} {parent-numbytes-to-write}\n$ ./fork4_prnum 20 100\nParent process, PID 24243:\n return 24244 from fork()\npChild process, PID 24244:\n return 0 from fork()\nccpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcpcpChild process (24244) done, exiting ...\nppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppParent (24243) will exit now...\n$ \n```", "```\n$ taskset -c 0 ./fork4_prnum 20 100\nParent process, PID 24555:\n return 24556 from fork()\npChild process, PID 24556:\n return 0 from fork()\nccppccpcppcpcpccpcpcppcpccpcppcpccppccppChild process (24556) done, exiting ...\npppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppParent (24555) will exit now...\n$ \n```", "```\nstatic int g=7;\n[...]\nint main(int argc, char **argv)\n    [...]\n    int loc=8;\n    switch((ret = fork())) {\n    case -1 : FATAL(\"fork failed, aborting!\\n\");\n    case 0 : /* Child */\n          printf(\"Child process, PID %d:\\n\", getpid());\n          loc ++;\n g --;\n printf( \" loc=%d g=%d\\n\", loc, g);\n          printf(\"Child (%d) done, exiting ...\\n\", getpid());\n          exit(EXIT_SUCCESS);\n    default : /* Parent */\n    #if 1\n          sleep(2); /* let the child run first */\n    #endif\n          printf(\"Parent process, PID %d:\\n\", getpid());\n          loc --;\n g ++;\n printf( \" loc=%d g=%d\\n\", loc, g);\n    }\n    printf(\"Parent (%d) will exit now...\\n\", getpid());\n    exit(EXIT_SUCCESS);\n```", "```\n$ ./fork5\nChild process, PID 17271:\n loc=9 g=6\nChild (17271) done, exiting ...\nParent process, PID 17270:               *<< after 2 sec >>*\n loc=7 g=8\nParent (17270) will exit now...\n$ \n```", "```\n$ ./fork5 \nParent process, PID 18620:\n loc=7 g=8\nParent (18620) will exit now...\nChild process, PID 18621:\n loc=9 g=6\nChild (18621) done, exiting ...\n$ \n```", "```\nmain\n...\n    foo\n        fd = open(\"myfile\", O_RDWR);\n        ...\n        fork()\n            // Child code\n *... work_on_file(fd) ...*\n            // Parent code\n *... work_on_file(fd) ...*\n ...\n```", "```\nwork_on_file(int fd)\n{   /* perform I/O */\n    lseek(fd, 0, SEEK_SET);\n    read(fd, buf, n);\n    lseek(...);\n    write(fd, buf2, x);\n    ...\n}\n```", "```\n$ ./fork_r6_of\nParent process, PID 5696:\n in fork_r6_of.c:work_on_file now...\n   context: parent process\nChild process, PID 5697:\n in fork_r6_of.c:work_on_file now...\n   context: child process\nParent (5696) will exit now...\nChild (5697) done, exiting ...\n$ \n```", "```\n$ vi tst\n^@^@^@^@^@^@^@^@^@^@ppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp\nccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\nppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp\nccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\nppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp\nccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc\n[...]\n:q\n$ \n```", "```\nconst int memsz=2048;\nstatic char *gptr;\n[...]\nmain(int argc, char **argv)\n{\n    gptr = malloc(memsz);\n    [...]\n    printf(\"Init: malloc gptr=%p\\n\", gptr);\n    [...]\n    switch ((ret = fork())) {\n    case -1: [...]\n    case 0:        /* Child */\n        printf(\"\\nChild process, PID %d:\\n\", getpid());\n        memset(gptr, 'c', memsz);\n disp_few(gptr);\n        [...]\n        printf(\"Child (%d) done, exiting ...\\n\", getpid());\n        exit(EXIT_SUCCESS);\n    default:        /* Parent */\n#if 1\n        sleep(2);    /* let the child run first */\n#endif\n        printf(\"\\nParent process, PID %d:\\n\", getpid());\n        memset(gptr, 'p', memsz);\n disp_few(gptr);\n        [...]\n    }\n    free(gptr);\n[...]\n```", "```\nstatic inline void disp_few(char *p)\n{\n    int i;\n    printf(\" malloc gptr=%p\\n \", p);\n    for (i=0; i<16; i++)\n        printf(\"%c\", *(p+i));\n    printf(\"\\n\");\n}\n```", "```\n$ ./fork_malloc_test \nInit: malloc gptr=0x1802260\n\nChild process, PID 13782:\n malloc gptr=0x1802260\n cccccccccccccccc\nChild (13782) done, exiting ...\n\nParent process, PID 13781:\n malloc gptr=0x1802260\n pppppppppppppppp\nParent (13781) will exit now...\n$ \n```", "```\n$ ./fork_malloc_test anyparameter\nInit: malloc gptr=0xabb260\nInit: loc=8, g=5\n\nChild process, PID 17285:\n malloc gptr=0xabb260\n cccccccccccccccc\n loc=9, g=4\n &loc=0x7ffc8f324014, &g=0x602084\nChild (17285) done, exiting ...\n\nParent process, PID 17284:\n malloc gptr=0xabb260\n pppppppppppppppp\n loc=7, g=6\n &loc=0x7ffc8f324014, &g=0x602084\nParent (17284) will exit now...\n$ \n```", "```\n#include <sys/types.h>\n#include <sys/wait.h>\npid_t wait(int *wstatus);\n```", "```\n[...]   \n   default: /* Parent */\n#if 1\n   sleep(2); /* let the child run first */\n#endif\n   printf(\"Parent process, PID %d:\\n\", getpid());\n[...]\n```", "```\n[...]   \n   default: /* Parent */\n wait(0);    /* ensure the child runs first */\n   printf(\"Parent process, PID %d:\\n\", getpid());\n[...]\n```", "```\nstatic void do_simpsh(void)\n{\n[...]\n while (1) {\n     if (!getcmd(cmd)) {\n         free(cmd);\n         FATAL(\"getcmd() failed\\n\");\n     }\n     /* Stopping condition */\n     if(!strncmp(cmd, \"quit\", 4))\n         break;\n[...]\n```", "```\n[...]\n /* Wield the powerful fork-exec-wait semantic ! */\n switch ((ret = fork())) {\n case -1:\n     free(cmd);\n     FATAL(\"fork failed, aborting!\\n\");\n case 0: /* Child */\n     VPRINT\n     (\" Child process (%7d) exec-ing cmd \\\"%s\\\" now..\\n\",\n         getpid(), cmd);\n     if (execlp(cmd, cmd, (char *)0) == -1) {\n         WARN(\"child: execlp failed\\n\");\n         free(cmd);\n         exit(EXIT_FAILURE);\n     }\n     /* should never reach here */\n     exit(EXIT_FAILURE); // just to avoid gcc warnings\n default: /* Parent */\n     VPRINT(\"Parent process (%7d) issuing the wait...\\n\",\n         getpid());\n     /* sync: child runs first, parent waits for child's death */\n     if (wait(0) < 0) \n         FATAL(\"wait failed, aborting..\\n\");\n     } // switch\n } // while(1)\n```", "```\n$ ./simpsh_v1 --help\nUsage: ./simpsh_v1 [-v]|[--help]\n -v : verbose mode\n --help : display this help screen.\n$ ./simpsh_v1 -v\n>> ps\n  Parent process ( 1637) issuing the wait...\n  Child process ( 1638) exec-ing cmd \"ps\" now..\n PID TTY TIME CMD\n 1078 pts/0 00:00:00 bash\n 1637 pts/0 00:00:00 simpsh_v1\n 1638 pts/0 00:00:00 ps\n>> uname\n  Parent process ( 1637) issuing the wait...\n  Child process ( 1639) exec-ing cmd \"uname\" now..\nLinux\n>> uname -a\n  Parent process ( 1637) issuing the wait...\n  Child process ( 1640) exec-ing cmd \"uname -a\" now..\n!WARNING! simpsh_v1.c:do_simpsh:90: child: execlp failed\nperror says: No such file or directory\n>> www\n  Parent process ( 1648) issuing the wait...\n  Child process ( 1650) exec-ing cmd \"www\" now..\n!WARNING! simpsh_v1.c:do_simpsh:90: child: execlp failed\nperror says: No such file or directory\n>> quit\n  Parent process ( 1637) exiting...\n$ \n```", "```\n$ ./simpsh_v1 -v\n>> sh\n[v]: Parent process ( 12945) issuing the wait...\n[v]: Child process ( 12950) exec-ing cmd \"sh\" now..\n$ ps\n PID TTY TIME CMD\n 576 pts/3 00:00:00 git-credential-\n 3127 pts/3 00:00:01 bash\n12945 pts/3 00:00:00 simpsh_v1\n12950 pts/3 00:00:00 sh                      *<< the newly spawned sh >>*\n12954 pts/3 00:00:00 ps\n31896 pts/3 00:00:40 gitg\n$ exit\nexit\n>> ps\n[v]: Parent process ( 12945) issuing the wait...\n[v]: Child process ( 12960) exec-ing cmd \"ps\" now..\n PID TTY TIME CMD\n 576 pts/3 00:00:00 git-credential-\n 3127 pts/3 00:00:01 bash\n12945 pts/3 00:00:00 simpsh_v1\n12960 pts/3 00:00:00 ps\n31896 pts/3 00:00:40 gitg\n>> \n```", "```\npid_t wait(int *wstatus);\n```", "```\n[...]\n default: /* Parent */\n     VPRINT(\"Parent process (%7d) issuing the wait...\\n\",\n         getpid());\n     /* sync: child runs first, parent waits for child's death */\n     if ((cpid = wait(&wstat)) < 0) {\n         free(cmd);\n         FATAL(\"wait failed, aborting..\\n\");\n     }\n     if (gVerbose)\n         interpret_wait(cpid, wstat);\n } // switch\n} // while(1)\n[...]\n```", "```\nstatic void interpret_wait(pid_t child, int wstatus)\n{\n     VPRINT(\"Child (%7d) status changed:\\n\", child);\n     if (WIFEXITED(wstatus))\n         VPRINT(\" normal termination: exit status: %d\\n\",\n             WEXITSTATUS(wstatus));\n     if (WIFSIGNALED(wstatus)) {\n         VPRINT(\" abnormal termination: killer signal: %d\",\n                 WTERMSIG(wstatus));\n         if (WCOREDUMP(wstatus))\n             VPRINT(\" : core dumped\\n\");\n         else\n             VPRINT(\"\\n\");\n     }\n     if (WIFSTOPPED(wstatus))\n         VPRINT(\" stopped: stop signal: %d\\n\",\n             WSTOPSIG(wstatus));\n     if (WIFCONTINUED(wstatus))\n         VPRINT(\" (was stopped), resumed (SIGCONT)\\n\");\n}\n```", "```\n$ ./simpsh_v2 -v\n>> ps\n  Parent process ( 2095) issuing the wait...\n  Child process ( 2096) exec-ing cmd \"ps\" now..\n PID TTY TIME CMD\n 1078 pts/0 00:00:00 bash\n 2095 pts/0 00:00:00 simpsh_v2\n 2096 pts/0 00:00:00 ps\n Child ( 2096) status changed:\n normal termination: exit status: 0\n>> quit\n  Parent process ( 2095) exiting...\n$ \n```", "```\nmain() \n{\n    [...]\n    fork();\n    fork();\n    fork();\n    [...]\n}\n```", "```\nint main(void)\n{ \n    while(1)\n        fork();\n}\n```", "```\nstatic void createChild(int sleep_time)\n{\n     pid_t n;\n     switch (n = fork()) {\n     case -1:\n         perror(\"fork\");\n         exit(1);\n     case 0: // Child\n         printf(\"Child 2 PID %d sleeping for %ds...\\n\", getpid(),\n         sleep_time);\n         sleep(sleep_time);\n         exit(0);\n     default: ; // Parent returns..\n     }\n}\nint main(void)\n{\n[...]\nswitch (n = fork()) {  // create first child\n case -1:\n     perror(\"fork\");\n     exit(1);\n case 0: // Child\n     printf(\"Child 1 PID %d sleeping for %ds...\\n\", getpid(),\n         c1_slptm);\n     sleep(c1_slptm);\n     exit(0);\n default: // Parent\n createChild(c2_slptm); // create second child\n     /* Wait until all children die (typically) */\n while ((cpid = wait(&stat)) != -1) {\n         printf(\"Child %d changed state\\n\", cpid);\n     }\n }\n```", "```\npid_t waitpid(pid_t pid, int *wstatus, int options);\n```", "```\nwaitpid(-1, &stat, 0);\n```", "```\n[...] default: /* Parent */\n     VPRINT(\"Parent process (%7d) issuing the waitpid...\\n\",\n         getpid());\n     /* sync: child runs first, parent waits\n      * for child's death.\n     * This time we use waitpid(2), and will therefore also get\n * unblocked on a child stopping or resuming!\n     */\n if ((cpid = waitpid(-1, &wstat, \n WUNTRACED|WCONTINUED)) < 0) {\n             free(cmd);\n             FATAL(\"wait failed, aborting..\\n\");\n     }\n     if (gVerbose)\n         interpret_wait(cpid, wstat);\n[...]\n```", "```\n$ ./simpsh_v3 -v\n >> read\n  Parent process ( 15040) issuing the waitpid...\n  Child process ( 15058) exec-ing cmd \"read\" now..\n```", "```\n$ pgrep simpsh\n 15040\n$ pstree -A -h 15040 -p\n simpsh_v3(15040)---read(15058)\n$\n```", "```\n$ kill -SIGTSTP 15058\n```", "```\nwaitpid(-1, &wstat, WUNTRACED|WCONTINUED))\n```", "```\n Child ( 15058) status changed:\n  stopped: stop signal: 20\n>> \n```", "```\n$ kill -SIGCONT 15058\n$ \n```", "```\n Child ( 15058) status changed:\n  (was stopped), resumed (SIGCONT)\n```", "```\n$ strace -e trace=process -o strc.txt ./simpsh_v1 \n>> ps\n PID TTY TIME CMD\n14874 pts/6 00:00:00 bash\n27248 pts/6 00:00:00 strace\n27250 pts/6 00:00:00 simpsh_v1\n27251 pts/6 00:00:00 ps\n>> quit\n$ \n```", "```\nexecve(\"./simpsh_v1\", [\"./simpsh_v1\"], 0x7fff79a424e0 /* 56 vars */) = 0 \narch_prctl(ARCH_SET_FS, 0x7f47641fa4c0) = 0 \nclone(child_stack=NULL,       \n flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, \n child_tidptr=0x7f47641fa790) = 27251\nwait4(-1, NULL, 0, NULL) = 27251\n[...]\n```", "```\n-f           Trace child processes as they are created by currently traced processes as a result of the fork(2), vfork(2) and clone(2) system calls. ...\n```", "```\n\u200b(gdb) show follow-fork-mode \nDebugger response to a program call of fork or vfork is \"parent\".\n(gdb) set follow-fork-mode child\n(gdb) \n```"]