- en: Chapter 5. Monitoring System Resources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。监控系统资源
- en: As the needs of your organization expand, your network will grow and change
    in order to match the growth. Keeping track of the resources on each node is extremely
    important for stability. While Linux handles resources exceptionally well, it
    can only do so much. CPUs can be overutilized, disks become full, and excessive
    input/output can halt even the strongest of servers. Keeping an eye on these things
    is very important, especially when systems are used in production and depended
    upon by others.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的组织需求的扩大，您的网络将随着增长和变化而增长和变化。跟踪每个节点上的资源对于稳定性非常重要。虽然Linux处理资源异常出色，但它只能做到这么多。CPU可能被过度利用，磁盘变满，过多的输入/输出甚至可以使最强大的服务器停止。密切关注这些事情非常重要，特别是当系统用于生产并且被其他人依赖时。
- en: In this chapter, we'll look at ways to inspect what's running on your Linux
    systems and manage their resources to help ensure your nodes are good citizens
    on your network.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨检查Linux系统上正在运行的内容以及管理其资源的方法，以确保您的节点在网络上表现良好。
- en: 'In this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Inspecting and managing processes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查和管理进程
- en: Understanding load average
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解负载平均值
- en: Checking available memory
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查可用内存
- en: Using shell-based resource monitors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于shell的资源监视器
- en: Checking disk space
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查磁盘空间
- en: Scanning used storage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描已使用的存储空间
- en: Introduction to logging
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志简介
- en: Maintaining log size with logrotate
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用logrotate维护日志大小
- en: Understanding the systemd init system
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解systemd初始化系统
- en: Understanding the systemd journal
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解systemd日志
- en: Inspecting and managing processes
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查和管理进程
- en: 'In a typical troubleshooting scenario, you might have a process that is misbehaving
    or needs an action performed against it. If you''re using a graphical desktop
    environment for a workstation, you might use a tool such as the GNOME System Monitor
    to investigate processes running on your system, and then kill the problem child.
    In most cases though, you probably won''t have a desktop environment (at least
    not on servers), so you would use a command such as `kill` in order to get rid
    of whatever process is misbehaving. But before you can kill a process, you''ll
    need to know its **process identifier** (**PID**). One method that works on all
    Linux systems to find the PID of a process is to open a terminal and us the `ps`
    command. Here''s an example of its usage:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的故障排除场景中，您可能会遇到一个行为不端或需要对其执行操作的进程。如果您在工作站上使用图形桌面环境，您可能会使用诸如GNOME系统监视器之类的工具来调查系统上运行的进程，然后终止问题进程。但在大多数情况下，您可能不会有图形桌面环境（至少不会在服务器上），因此您将使用诸如`kill`之类的命令来摆脱行为不端的进程。但在终止进程之前，您需要知道其**进程标识符**（**PID**）。在所有Linux系统上找到进程的PID的一种方法是打开终端并使用`ps`命令。以下是其用法示例：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Along with `ps`, it's common to use `grep` if you happen to already know the
    name of the process. In that case, you can pipe the output of `ps aux` into `grep`
    and then search for a process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ps`，如果您已经知道进程的名称，通常会使用`grep`。在这种情况下，您可以将`ps aux`的输出导入`grep`，然后搜索进程。
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `ps` command will give you a list of running processes. If you used `grep`,
    the output would be narrowed down to a list of processes matching the search term.
    You'll see the `PID` located for each process that comes up in the results within
    the second column. In the third column, you'll see how much CPU the process is
    consuming, followed by a column for memory usage immediately after that.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps`命令将为您提供正在运行的进程列表。如果使用了`grep`，输出将被缩小为与搜索项匹配的进程列表。您将在结果中看到每个进程的`PID`位于第二列中。在第三列中，您将看到进程正在消耗多少CPU，然后是内存使用列。'
- en: '![Inspecting and managing processes](img/B03919_05_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: ！[检查和管理进程](img/B03919_05_01.jpg)
- en: Output of ps aux on a Debian system
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian系统上的ps aux输出
- en: '`USER`, `STAT`, `START`, `TIME`, and `COMMAND` are additional columns we can
    see from this output. While `USER` is self-explanatory, here''s a short description
    of the other column headers:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`USER`，`STAT`，`START`，`TIME`和`COMMAND`是我们可以从此输出中看到的其他列。虽然`USER`是不言自明的，但这里是其他列标题的简短描述：'
- en: '`STAT`: This field identifies the state of the program, with a one or two-character
    code representing the state the program is currently in. For example, `S` means
    that the process is waiting for some event to complete, while `D` is an uninterruptible
    sleep state, typically related to IO. To view a complete list, check out the manual
    page on `ps`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STAT`：此字段标识程序的状态，其中一个或两个字符代码表示程序当前所处的状态。例如，`S`表示进程正在等待某些事件完成，而`D`是不可中断的睡眠状态，通常与IO相关。要查看完整列表，请查看`ps`的手册页。'
- en: '`START`: This field refers to the time at which the process began running.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`START`：此字段指的是进程开始运行的时间。'
- en: '`TIME`: This indicates the total time the process has been utilizing the CPU.
    Every time a process hits the CPU and needs work done, time is logged against
    the CPU.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIME`：这表示进程已经利用CPU的总时间。每当进程命中CPU并需要执行工作时，时间都会记录在CPU上。'
- en: '`COMMAND`: This displays the command that the current process is running.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMMAND`：显示当前进程正在运行的命令。'
- en: 'Now that you know how to find the PID of a process, we can take a look at the
    `kill` command, which is a command that''s useful in case you need to close a
    program that otherwise won''t close by normal means. For example, if you are running
    a script with a process ID 25787, you could kill it by executing the following
    command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何找到进程的PID，我们可以看一下`kill`命令，这是一个在需要关闭正常情况下无法关闭的程序时非常有用的命令。例如，如果您正在运行一个进程ID为25787的脚本，您可以通过执行以下命令来终止它：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `kill` command works by sending a specific signal to a PID. Signal 15,
    for example, is known as **SIGTERM**. If you execute the `kill` against a process
    without any parameters (as we did in our last example), you''re sending signal
    15 by default, which basically asks politely for the process to close down. There
    are 18 different signals you can send to a process, which you can read about in
    the manual pages. For the sake of our discussion here, `SIGINT`, `SIGTERM`, and
    `SIGKILL` are the ones you''ll likely use the most. You can view a list of these
    signals, as well as their meanings, by executing the following command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`kill`命令通过向PID发送特定信号来工作。例如，信号15被称为**SIGTERM**。如果您对一个进程执行`kill`而没有任何参数（就像我们在上一个示例中所做的那样），则默认发送信号15，这基本上是礼貌地要求进程关闭。您可以向进程发送18种不同的信号，您可以在手册页中阅读有关这些信号的信息。就我们在这里讨论的而言，`SIGINT`，`SIGTERM`和`SIGKILL`是您最有可能使用的。您可以通过执行以下命令查看这些信号以及它们的含义的列表：'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To send a specific signal, type a hyphen after the `kill` command followed
    by the signal you wish to send. Since `kill` by itself sends signal 15, you can
    do the same thing by executing the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送特定信号，请在`kill`命令后输入连字符，然后输入您希望发送的信号。由于`kill`本身发送信号15，您可以通过执行以下命令来执行相同的操作：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To send a different signal, such as 2 (**SIGINT**), type the following command:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送不同的信号，比如2（**SIGINT**），请输入以下命令：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you''re *very* desperate, you could send signal 9 (**SIGKILL**) to the process:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您非常绝望，可以向进程发送信号9（**SIGKILL**）：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, `SIGKILL` should be used only if you've already exhausted all your
    other options, and you cannot get the process to close despite your best efforts.
    `SIGKILL` closes the process immediately, but unfortunately it does not give it
    a chance to clean up after itself. This may cause unclean temporary files and
    open socket connections to remain on your system. Worse, it can actually damage
    databases and configuration. Therefore, I cannot stress this enough, `kill -9`
    should definitely be the very last thing you try if you can't get a process to
    close out gracefully. Try every method you know to first close a process gracefully,
    and then make several more attempts before considering using it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，只有在您已经尽了最大努力但无法使进程关闭时，才应该使用`SIGKILL`。`SIGKILL`立即关闭进程，但不幸的是它不会给进程清理的机会。这可能导致不干净的临时文件和打开的套接字连接留在系统上。更糟糕的是，它实际上可能会损坏数据库和配置。因此，我再次强调，如果无法使进程正常关闭，`kill
    -9`绝对应该是您尝试的最后一件事。首先尝试您知道的每种方法来正常关闭进程，然后再尝试几次，然后考虑使用它。
- en: 'Another command that can be used to kill processes is the `killall` command.
    The `killall` command allows you to kill all the processes on your system which
    match a specific name. For example, let''s say you have multiple Firefox windows
    open and the program stops responding. To kill all instances of Firefox running
    on your system instantly, simply execute the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以用来终止进程的命令是`killall`命令。`killall`命令允许您终止系统上与特定名称匹配的所有进程。例如，假设您有多个打开的Firefox窗口并且程序停止响应。要立即终止系统上运行的所有Firefox实例，只需执行以下命令：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And just like that, every Firefox window on your system will instantly vanish.
    The `killall` command can be used to close down multiple processes that all share
    the same name, and it can be very useful on servers which run multiple instances
    of a single unresponsive program or script.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，您系统上的每个Firefox窗口都会立即消失。`killall`命令可用于关闭共享相同名称的多个进程，并且在运行多个单个无响应程序或脚本的服务器上非常有用。
- en: That's pretty much all there is to using the `kill` and `killall` commands.
    Sure, there are more options and the man pages will give you more information.
    But in a nutshell, those are the variations you'll actually use. In a perfect
    world, you should never need to use `kill` and all processes running on your servers
    will obey you without question. Unfortunately, we don't live in a perfect world
    and you'll probably use these commands more often than you'd like.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是使用`kill`和`killall`命令的全部内容。当然，还有更多选项，手册页会给您更多信息。但简而言之，这些是您实际使用的变体。在理想的世界中，您应该永远不需要使用`kill`，并且在服务器上运行的所有进程都会毫无疑问地服从您。不幸的是，我们不生活在一个完美的世界，您可能会比您想象的更经常使用这些命令。
- en: Understanding load average
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解负载平均值
- en: 'For a Linux administrator, **load average** is one of the most important concepts
    you''ll ever learn. While you may know already that this number represents how
    much load your system is experiencing, it also represents trending performance
    as well. Using this number, you''ll be able to determine whether your system is
    being overwhelmed or it''s recovering and calming down. Essentially, the load
    average consists of three numbers, each representing the average load of the system
    over a specific time frame. The first number represents one minute, the second
    represents five minutes, and the third represents 15 minutes. There are many ways
    in which you can view your load average, and it will also be displayed in most
    system monitors available for Linux. One way to view your load average in a snap
    is to execute the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux管理员来说，**负载平均值**是您将学到的最重要的概念之一。虽然您可能已经知道这个数字代表系统承受多大负载，但它也代表着趋势性能。使用这个数字，您将能够确定您的系统是被压倒还是正在恢复和平静下来。基本上，负载平均值由三个数字组成，每个数字代表系统在特定时间范围内的平均负载。第一个数字代表一分钟，第二个代表五分钟，第三个代表15分钟。有许多方法可以查看您的负载平均值，并且它也会显示在大多数Linux可用的系统监视器中。查看您的负载平均值的一种简单方法是执行以下命令：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Understanding load average](img/B03919_05_02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![理解负载平均值](img/B03919_05_02.jpg)'
- en: Viewing the load average
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 查看负载平均值
- en: A simpler technique is to use the `uptime` command. Though the main purpose
    of the `uptime` command is to view how long your system has been up, it displays
    the system's load average as well.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简单的技术是使用`uptime`命令。虽然`uptime`命令的主要目的是查看系统已经运行了多长时间，但它也显示了系统的负载平均值。
- en: '![Understanding load average](img/B03919_05_03.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![理解负载平均值](img/B03919_05_03.jpg)'
- en: The output of the uptime command
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: uptime命令的输出
- en: 'So, how does one properly interpret this information? With the screenshot of
    the uptime command shown in this section, we see the following numbers:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何正确解释这些信息呢？通过本节中显示的uptime命令的截图，我们看到以下数字：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As mentioned, the first three numbers represent the system's load during a period
    of 1, 5, and 15 minutes respectively. The load that's being referred to represents
    the number of processes that are waiting on, or currently utilizing, the CPU during
    each timeframe. On the system used in this example, we can see that the load on
    it is relatively low. We can also see trends with load average as well. On the
    example system, the load is trending upward but just by a bit.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，前三个数字分别代表了1、5和15分钟内系统的负载。所谓的负载表示在每个时间段内等待或当前使用CPU的进程数量。在本例中使用的系统上，我们可以看到它的负载相对较低。我们还可以看到负载平均值的趋势。在这个例子系统上，负载正在上升，但只是稍微上升。
- en: Generally speaking, the lower the load averages, the better. But that's not
    always the case; lower numbers can be disturbing too. For example, if you have
    a server that's supposed to be doing a lot of work and its load average drops
    down to being less than one, that may be a cause for alarm. If the load is that
    low, the server clearly isn't busy. This might represent that a process which
    is supposed to be running has failed. For example, if you have a MySQL server
    that normally sees hundreds of queries at a time, it would definitely be odd to
    see that the server was suddenly bored. On the flipside, a server with load average
    in the hundreds would be so busy it would be unlikely that it could even process
    a login request for you to even access the system!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，负载平均值越低越好。但并非总是如此；较低的数字也可能令人不安。例如，如果您有一个本应该忙碌的服务器，其负载平均值下降到小于1，这可能是一个警告信号。如果负载如此之低，服务器显然并不忙碌。这可能表示应该运行的某个进程已经失败。例如，如果您有一个通常会同时处理数百个查询的MySQL服务器，突然发现服务器变得无所事事，肯定会感到奇怪。另一方面，负载平均值达到数百的服务器将如此忙碌，以至于甚至无法处理您的登录请求，也无法访问系统！
- en: 'Let''s take a look at another load average. Here''s one from a busier system
    on a network that I help manage:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个负载平均值。这是我帮助管理的网络上一个更繁忙系统的负载平均值：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we can see that the load on this system is much higher than the previous
    example. This might be something I'll want to look into. But one confusing thing
    about a system's load average is that the number itself isn't enough to justify
    cause for alarm. If that system had ten cores, I wouldn't be so worried. Despite
    the load average being over nine, there would be plenty of CPU's to handle the
    workload in that case. However, the system I took that output from has only four
    cores, so it's a cause for alarm. It means that during each of the three time
    windows, there were more processes waiting for CPU time than the system actually
    has in cores. That's not good. But thankfully, I can see that the system is recovering
    since the load is trending downward. In this case, I won't panic but I'll certainly
    want to keep my eye on it to ensure that it continues to recover. I may also investigate
    the system to find out what exactly caused the load to spike up so high. Perhaps
    the server just finished a really big job, but it's worth looking into.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这个系统的负载比前一个例子高得多。这可能是我想要调查的事情。但关于系统的负载平均值令人困惑的一点是，数字本身并不足以证明有警告的理由。如果该系统有十个核心，我就不会那么担心。尽管负载平均值超过了9，但在这种情况下，将有足够的CPU来处理工作负载。然而，我从中获取输出的系统只有四个核心，所以这是一个警告信号。这意味着在每个三个时间窗口内，等待CPU时间的进程比系统实际拥有的核心还要多。这不是好事。但幸运的是，我可以看到系统正在恢复，因为负载正在下降。在这种情况下，我不会惊慌，但肯定会继续关注，以确保它继续恢复。我可能还会调查系统，找出到底是什么导致了负载如此高。也许服务器刚刚完成了一个非常大的任务，但值得调查一下。
- en: As a general rule of thumb, it's a good idea to record a baseline of your systems
    when they are under their normal, expected load. Each system on your network will
    have a designated purpose and each will have a certain load you can reasonably
    expect your system to face at any one time. If the systems load average dips too
    far below or climbs higher than the baseline, then you would want to take a look
    and find out what's going on. If the load reaches a level where there are more
    processes than you have cores to handle, that's cause for alarm.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，记录系统在正常预期负载下的基线是一个好主意。您网络上的每个系统都将有一个指定的目的，每个系统在任何时候都会有一个您可以合理预期系统面临的特定负载。如果系统的负载平均值低于基线或高于基线，那么您就需要查看并找出问题所在。如果负载达到一个水平，其中有更多的进程比您的核心处理器处理的，那就是一个警告信号。
- en: Checking available memory
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查可用内存
- en: Linux systems handle memory exceptionally well, though it's always possible
    for things to get out of hand if a process misbehaves or not enough memory was
    allocated. In such a situation where a system starts to perform sluggish, checking
    your available memory will probably be one of the first things you look into.
    To do this, we use the `free` command. To make the output even more readable,
    you can add the `-m` option, which shows your memory usage in terms of megabytes,
    which can make it much easier to read. Reading this output may be confusing at
    first, though I'm sure you'll find it straightforward after we go through the
    output.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Linux系统非常出色地处理内存，尽管如果一个进程行为不端或分配的内存不足，事情可能会失控。在系统开始表现迟缓的情况下，检查可用内存可能是您首先要查看的事情之一。为此，我们使用`free`命令。为了使输出更易读，您可以添加`-m`选项，以以兆字节为单位显示内存使用情况，这样可以使其更容易阅读。起初阅读这个输出可能会令人困惑，但我相信在我们阅读输出后，您会发现它很简单。
- en: '![Checking available memory](img/B03919_05_04.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![检查可用内存](img/B03919_05_04.jpg)'
- en: The output of the free command
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: free命令的输出
- en: When running the `free` command, we're presented with three rows and six columns
    of information. The first row shows us our actual RAM usage, while the second
    row declares buffers and the third our swap usage. Under `total`, we see that
    this system has 7923 MB of RAM installed. Technically, this system has 8 GB of
    RAM, though some is reserved for the kernel or some kind of hardware and may not
    show here. In the next column (`used`) we see how much of our system's RAM has
    been consumed, followed by `free` where it shows us how much of the system's RAM
    is unused. In our preceding example, it would appear as though we only have 927
    MB free of our 8 GB, but that's not exactly correct. So, how exactly does one
    interpret how much memory is actually free?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`free`命令时，我们得到了三行六列的信息。第一行显示了我们实际的RAM使用情况，而第二行声明了缓冲区，第三行声明了交换使用情况。在“total”下，我们看到这个系统安装了7923
    MB的RAM。从技术上讲，这个系统有8 GB的RAM，尽管其中一部分被保留给内核或某种硬件，可能不会显示在这里。在下一列（`used`）中，我们看到了我们系统的RAM有多少被使用，然后是`free`，它显示了系统RAM中有多少是未使用的。在我们之前的例子中，似乎我们只有927
    MB的8 GB是空闲的，但这并不完全正确。那么，到底有多少内存是真正空闲的呢？
- en: First, `used` on the first line corresponds to how much memory is actually being
    used, including what has been cached. Essentially, memory management in Linux
    declares what is known as a **disk cache**, which is a chunk of memory set aside
    for data that has yet to be written to disk. You can see this in our output of
    the `free -m` command; it's the number on the far right underneath `cached`. This
    memory is not necessarily being used by a process; it's declared in order to make
    your system run faster. If a process is started and it requires more RAM than
    what shows in the first line under `free`, the Linux kernel will happily give
    up memory from the disk cache to other processes as needed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，第一行中的“used”表示实际使用了多少内存，包括缓存的部分。基本上，Linux中的内存管理声明了所谓的**磁盘缓存**，这是一块为尚未写入磁盘的数据保留的内存块。您可以在`free
    -m`命令的输出中看到这一点；它是`cached`下面最右边的数字。这部分内存不一定被进程使用；它被声明为使系统运行更快。如果启动一个进程并且它需要的RAM超过了第一行`free`下显示的RAM，Linux内核将乐意从磁盘缓存中分配内存给其他进程。
- en: The disk cache helps increase performance. When you read something from the
    disk, it is stored in the disk cache, and then read from there instead of from
    the disk each time. For example, say you take a look at a text file saved in your
    `/home` directory several times each day. The first time you read it, you're reading
    it from the disk. From that point on, it's stored in disk cache, and accessed
    from there each time you wish to read the file from that point forward. Since
    RAM is faster than your disk, this file will open each additional time because
    it only has to read it from disk one time, then going forward its read from the
    disk cache.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘缓存有助于提高性能。当你从磁盘读取东西时，它会存储在磁盘缓存中，然后每次都从那里读取，而不是每次都从磁盘读取。例如，假设你每天都要查看保存在`/home`目录中的文本文件。第一次读取时，你是从磁盘读取的。从那时起，它就存储在磁盘缓存中，每次你想要从那时起读取文件时都是从那里读取。由于RAM比硬盘快，这个文件每次只需要从磁盘读取一次，然后以后都是从磁盘缓存中读取。
- en: The information stored within the disk cache ages out over time. As disk cache
    fills up, the oldest information stored there drops off to make room for other
    things. In addition, when memory is needed for processes, memory from the cache
    can be taken back at any time. This is why that even though it may appear that
    an excessive amount of RAM is being used up by the cache at times, it's not a
    big issue—applications are never prevented access to this memory when they need
    it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘缓存中存储的信息会随着时间而过期。随着磁盘缓存的填满，存储在其中的最旧信息会被删除以腾出空间。此外，当进程需要内存时，可以随时从缓存中取回内存。这就是为什么即使有时候看起来大量的RAM被缓存使用，也不是一个大问题——应用程序在需要时永远不会被阻止访问这些内存。
- en: Going back to our example, the number we want to look at when determining how
    much memory we have free is the amount shown in the secondcolumn, on the second
    row. In the case of this example, 3736 MB is considered free. This is plenty of
    free memory in regards to this particular system. You should worry when this number
    decreases and swap starts to increase to compensate. As long as your system has
    enough RAM for its designated purpose, swap should barely be used. A small amount
    will almost always be used, but it is a problem when a large amount is being used.
    When your system actually does start to run out of memory, it will start to use
    your swap partition. Since your hard drive is many times slower than your RAM,
    you do not want this. If you see your swap space being abused, you should run
    some sort of resource monitor (a few of which we discuss in this chapter) to identify
    what is using it up.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，确定我们有多少空闲内存时要看第二列的数字，第二行的数字。在这个例子中，3736 MB被认为是空闲的。对于这个特定的系统来说，这是足够的空闲内存。当这个数字减少并且交换开始增加以补偿时，你应该担心。只要你的系统有足够的RAM来完成指定的任务，交换应该几乎不会被使用。几乎总会使用一小部分，但当使用大量时就是问题。当你的系统实际上开始耗尽内存时，它将开始使用你的交换分区。由于硬盘比RAM慢得多，你不希望这样。如果你看到你的交换空间被滥用，你应该运行某种资源监视器（我们在本章中讨论了其中的一些）来确定是什么在使用它。
- en: To make sure we have a well-rounded understanding of the `free` command output,
    let's go over all of the sections it contains, starting with the very first row.
    We already covered `total`, which is the amount of memory your system has physically
    installed (minus whatever your kernel or hardware has reserved). Next in the first
    row, we have `used`, which refers to the amount of memory which is being used
    by anything at all, including the cache. The `free` column is the exact opposite
    and refers to memory that is not being used by anything whatsoever.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们对“free”命令的输出有一个全面的理解，让我们逐个讨论它包含的所有部分，从第一行开始。我们已经介绍了“total”，这是你的系统物理上安装的内存量（减去你的内核或硬件保留的部分）。在第一行的下一个是“used”，它指的是任何时候被使用的内存量，包括缓存。而“free”列则完全相反，指的是没有被任何东西使用的内存。
- en: The last two items on the first row are `buffers` and `cache`. While these two
    sections aren't being used by any process, the kernel uses them to cache data
    for performance optimization. But if a process needs more memory, it's welcome
    to take from these two numbers. We already covered the disk cache, which is the
    last number. The `buffers` refer to data that hasn't yet been written to disk.
    Linux will, at various intervals, run a `sync` to write this information to the
    disk. You can even run the `sync` command yourself if you want, though this is
    rarely necessary. The concept of a buffer is also a key indicator on why you don't
    want to abruptly remove external media from your computer without unmounting first.
    If your system hasn't yet synced the data to the disk, you may lose it if you
    eject the media prematurely.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行的最后两项是“buffers”和“cache”。虽然这两个部分没有被任何进程使用，但内核会用它们来缓存数据以进行性能优化。但如果一个进程需要更多的内存，它可以从这两个数字中获取。我们已经介绍了磁盘缓存，这是最后一个数字。“buffers”指的是尚未写入磁盘的数据。Linux会在各种时间间隔内运行“sync”命令将这些信息写入磁盘。如果你愿意，你甚至可以自己运行“sync”命令，尽管这很少是必要的。缓冲区的概念也是为什么你不希望在没有先卸载的情况下突然从计算机中移除外部媒体的一个关键指标。如果你的系统尚未将数据同步到磁盘，如果你过早地弹出媒体，你可能会丢失数据。
- en: On the second row, we have `-/+ buffers cache` (which in our example above is
    4186 MB and 3736 MB, respectively). The first number on this row (4186 MB) is
    a number calculated by subtracting the total of buffers and cache (2808 MB) from
    the used column of the first row (6995 MB). This gives us a total of 4187 MB,
    which is a bit off due to rounding (we're viewing the output in MB since we used
    the `-m` flag, so we're off by a small amount), but close enough. If we followed
    the same math but without the `-m` flag in our `free` command, the result would've
    been exact. The next number on the second row is 3736 MB. As mentioned earlier,
    this is the amount of memory that is actually free for the system to use. To get
    this number, we subtract the used memory (4186 MB) from our total memory (7923
    MB).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们有“-/+ buffers cache”（在我们的示例中分别为4186 MB和3736 MB）。这一行的第一个数字（4186 MB）是通过从第一行的已使用列（6995
    MB）减去缓存和缓冲区的总和（2808 MB）计算出来的。这给了我们4187 MB的总数，由于四舍五入的原因（我们使用了“-m”标志，所以我们的输出以MB为单位，所以有一点偏差），但足够接近。如果我们按照同样的数学计算，但在我们的free命令中没有使用“-m”标志，结果将是精确的。第二行的下一个数字是3736
    MB。正如前面提到的，这是系统实际可用的内存量。为了得到这个数字，我们从已使用的内存（4186 MB）中减去我们的总内存（7923 MB）。
- en: Again, the amount of memory under `free` on the second row is the number you
    care about when wondering how much memory you have left. However, it's also important
    to understand how we arrived at this number and how Linux manages memory for us.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在第二行的“free”下面的内存量是你关心的数字，当你想知道你还剩下多少内存时。然而，了解我们是如何得出这个数字以及Linux是如何为我们管理内存的也是很重要的。
- en: Using shell-based resource monitors
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基于shell的资源监视器
- en: When you install any Linux distribution with a desktop environment, chances
    are there will be a graphical system monitor bundled along with it. Popular among
    these are **KSysGuard** and the **GNOME System Monitor**, but there are many others.
    For the most part, these are fine and do the job well. The GNOME System Monitor
    is capable of showing you your load average, currently running processes (as well
    as their PID, CPU percent, memory, and more), and how much of your disks are being
    used. Many graphical system monitors also show this information and more. While
    these tools are great, nodes within a typical Linux-based network don't always
    have a graphical user interface available. Thankfully, there are many different
    resource monitoring tools available via the shell and they don't require that
    you're running a desktop environment at all. Some of these are so great that you'll,
    at some point, forego the graphical tools for the shell tools. Popular tools in
    this category include `top`, `htop`, `iotop`, and `ncdu`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 安装任何带有桌面环境的Linux发行版时，很可能会捆绑一个图形系统监视器。其中流行的有KSysGuard和GNOME系统监视器，但还有许多其他的。大多数情况下，这些都很好用。GNOME系统监视器能够显示负载平均值，当前运行的进程（以及它们的PID，CPU百分比，内存等），以及磁盘使用情况。许多图形系统监视器也显示这些信息以及更多。虽然这些工具很棒，但典型的基于Linux的网络中的节点并不总是有图形用户界面可用。幸运的是，通过shell有许多不需要运行桌面环境的资源监视工具。这些工具中一些非常出色，以至于你会在某个时候放弃图形工具而使用shell工具。这个类别中流行的工具包括top，htop，iotop和ncdu。
- en: 'First, we would need to make sure the aforementioned tools are installed on
    our system. In most cases, `top` is already installed for us but the others will
    need to be installed manually. You can verify that `top` is installed by running:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保上述工具已经安装在我们的系统上。在大多数情况下，top已经为我们安装好了，但其他的需要手动安装。你可以通过运行以下命令来验证top是否已安装：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see the following output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can use your distribution''s package manager to install the others. For
    Debian, you can install them all in one shot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用你的发行版的软件包管理器来安装其他工具。对于Debian，你可以一次性安装它们所有：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Unfortunately, on CentOS, not all of these packages are available in the default
    repositories. To install these tools on CentOS, you''ll first need to add the
    `epel` repository, and then you can install all of the packages. The following
    outlines the commands to use:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在CentOS上，并非所有这些软件包都在默认存储库中可用。要在CentOS上安装这些工具，您首先需要添加`epel`存储库，然后才能安装所有软件包。以下概述了要使用的命令：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Feel free to give these tools a try. The `top` and `htop` commands will both
    run without root access. However, you'll need to run `iotop` with at least `sudo`
    for it to function. The `ncdu` command will function as a normal user, but would
    then be limited to viewing only the resources that user has access to. Let's take
    a closer look at these tools.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 随意尝试这些工具。`top`和`htop`命令都可以在没有root访问权限的情况下运行。但是，您需要至少使用`sudo`来运行`iotop`才能使其正常工作。`ncdu`命令将作为普通用户运行，但将被限制为仅查看该用户可以访问的资源。让我们更仔细地看看这些工具。
- en: What do these tools do for us, anyway? First, `top` is tried and true; something
    that you've probably used before if you're not new to Linux. When it comes to
    seeing what's running on your system, `top` is quite common. With `top`, you'll
    see all kinds of information, such as uptime, load average, used memory, used
    swap, cache, and more. In the bottom section of the screen, you'll see a list
    of processes. When you're finished, simply press *Q* to exit.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具对我们有什么作用呢？首先，`top`是经过验证的；如果您不是Linux的新手，那么您可能以前已经使用过。在查看系统上正在运行的内容时，`top`是相当常见的。使用`top`，您将看到各种信息，例如正常运行时间，平均负载，已使用内存，已使用交换空间，缓存等。在屏幕的底部部分，您将看到进程列表。完成后，只需按*Q*退出。
- en: '![Using shell-based resource monitors](img/B03919_05_05.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![使用基于shell的资源监视器](img/B03919_05_05.jpg)'
- en: The top command running on a CentOS system
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS系统上运行的top命令
- en: 'There are several ways in which you can run `top`. By running `top` with no
    parameters, you''ll see a screen similar to what was shown earlier in this section.
    You will see a summary of system performance in the upper section and various
    processes in the bottom. However, if you already know which process you want to
    monitor, you can use the `-p` flag coupled with a PID to watch only that process.
    For example, we could use the following to monitor a process with a PID of `12844`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以运行`top`。通过不带参数运行`top`，您将看到一个类似于本节前面显示的屏幕。您将在上部看到系统性能摘要，底部显示各种进程。但是，如果您已经知道要监视哪个进程，可以使用`-p`标志加上PID来仅监视该进程。例如，我们可以使用以下命令来监视PID为`12844`的进程：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'By default, the output within the `top` command updates every three seconds.
    To change this, you can use the `-d` flag to choose a different frequency (in
    seconds):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`top`命令中的输出每三秒更新一次。要更改此设置，您可以使用`-d`标志选择不同的频率（以秒为单位）：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you prefer, frequency can be less than a second:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，频率可以小于一秒：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If `top` is already running and you would like to change how frequently it updates,
    you don't have to close it and start it up again. You can type `s` while it is
    running and you'll be prompted to designate a new frequency.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`top`已经在运行，并且您想要更改更新频率，您不必关闭它然后再次启动。您可以在其运行时键入`s`，然后会提示您指定一个新的频率。
- en: Within `top`, you can change how the process list is sorted by pressing a key
    on your keyboard. If you type `P`, you'll sort by CPU usage; using `M`, you can
    sort by memory usage (capitalization matters here). You can even kill a process
    from here if you wish, by pressing `k`, which will then prompt you for a PID to
    kill. Be careful though; this defaults to whatever happens to be at the top of
    your process list at the time you press it, so make sure that you don't press
    `Enter` until you've actually typed the PID or you may kill a process you didn't
    mean to.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`top`中，您可以通过按键盘上的键来更改进程列表的排序方式。如果您键入`P`，则按CPU使用率排序；使用`M`，您可以按内存使用率排序（这里大小写要注意）。您甚至可以通过按`k`来从这里终止一个进程，然后会提示您输入要终止的PID。不过要小心；这默认为您按下时进程列表顶部的内容，所以确保在实际输入PID之前不要按`Enter`，否则可能会终止您不想终止的进程。
- en: So, why use `top` anyway? The main purpose that administrators use `top` for
    is to help determine what is causing a system to become CPU or memory bound. Most
    often, `top` is never the solution, but rather the beginning of a root cause analysis.
    You can immediately see which process is consuming your CPU or RAM, but depending
    on the context you may not have an idea yet on how to correct the problem. With
    `top`, you're only able to discover the culprit. Unfortunately, `top` may not
    always show you the root cause process, but it's definitely a very easy first
    place to look when you have a system that's running sluggish.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么要使用`top`呢？管理员使用`top`的主要目的是帮助确定是什么导致系统变得CPU或内存密集。大多数情况下，`top`从来不是解决方案，而是根本原因分析的开始。您可以立即看到哪个进程正在消耗您的CPU或RAM，但根据上下文，您可能还不知道如何解决问题。使用`top`，您只能发现罪魁祸首。不幸的是，`top`可能并不总是显示出根本原因的进程，但当您的系统运行缓慢时，这绝对是一个非常容易的第一处查找地方。
- en: To begin your troubleshooting, the information at the top would give you a starting
    point to see which resource is being used up. On the `%Cpu(s)` line, we can tell
    immediately if the system is suffering from excessive **I/O wait** (the `%wa`
    field), which would basically mean there is more being thrown at the CPU than
    it's capable of handling. In this situation, tasks would back up and the load
    average would increase. Idle time (or `%id`) is a number that's better the higher
    it gets, which means your system would have CPU time to spare.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始故障排除，顶部的信息将为您提供一个起点，以查看哪个资源正在被使用。在`%Cpu(s)`行上，我们可以立即看出系统是否遭受过多的I/O等待（`%wa`字段），这基本上意味着CPU承受的负担超过了它的处理能力。在这种情况下，任务将积压，平均负载将增加。空闲时间（或`%id`）是一个数字，它越高越好，这意味着您的系统将有CPU时间可用。
- en: In some cases, you may find excessive CPU usage but not a lot in the process
    list to show for it. In such a case, you may bring up `iotop` in order to determine
    if your system is I/O bound. Using `iotop` (requires root) you can see just how
    much data is being written to or read from your disks. Using the left and right
    arrows, you can change focus from one column to another, which sorts the process
    list by that column.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能会发现CPU使用过高，但在进程列表中并没有显示太多。在这种情况下，您可以打开`iotop`来确定您的系统是否受到I/O限制。使用`iotop`（需要root权限），您可以看到写入或从磁盘读取的数据量。使用左右箭头，您可以将焦点从一列转移到另一列，这样可以按该列对进程列表进行排序。
- en: '![Using shell-based resource monitors](img/B03919_05_06.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![使用基于shell的资源监视器](img/B03919_05_06.jpg)'
- en: Running iotop on a Debian system
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian系统上运行iotop
- en: 'By default, the list of processes within `iotop` is quite crowded. You can
    slim it down by executing:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`iotop`中的进程列表相当拥挤。您可以通过执行以下操作来精简它：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By appending -`only`, you'll only see processes that have actual read and write
    operations occurring. In the `iotop` screenshot in this section, you can see that
    there are quite a few processes with no activity happening at all. But with `-only`,
    it may be easier to read since it cleans up the output. You can actually activate
    `-only` while `iotop` is running, by simply pressing *O* on your keyboard. In
    addition, another useful keyboard shortcut is the ability to change the sort order
    of any column with `r`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过附加-`only`，您只会看到实际发生读写操作的进程。在本节中`iotop`的截图中，您可以看到有相当多的进程根本没有活动。但是使用`-only`可能更容易阅读，因为它清理了输出。您实际上可以在`iotop`运行时激活`-only`，只需在键盘上简单地按下*O*。此外，另一个有用的键盘快捷键是使用`r`更改任何列的排序顺序。
- en: Next in this section, we have `htop`. While `top` is the the tried and true
    standard for viewing system resources on a Linux system, `htop` is increasing
    in popularity very quickly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们有`htop`。虽然`top`是在Linux系统上查看系统资源的标准方法，但`htop`的受欢迎程度正在迅速增加。
- en: '![Using shell-based resource monitors](img/B03919_05_07.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![使用基于shell的资源监视器](img/B03919_05_07.jpg)'
- en: The htop command in action
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: htop命令的操作
- en: The basic idea of `htop` is the same as `top`—the `top` area shows current CPU
    and memory usage and the bottom section provides a list of processes. But where
    `htop` differs is how it presents this information, which is easier to read and
    offers an area for graphs of your CPU's usage. In addition to that, it allows
    you to easily send a specific signal to a process. Earlier, we covered various
    signals you can use to end a process. Here, we can see that same concept illustrated
    graphically. To send a signal to a process, use the up and down arrows on your
    keyboard to highlight a process, and then press *F9* to choose a specific signal.
    `SIGTERM` is selected by default, but you can send any of the other signals to
    a process as well.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`htop`的基本思想与`top`相同——`top`区域显示当前的CPU和内存使用情况，底部部分提供了一个进程列表。但`htop`的不同之处在于它如何呈现这些信息，更容易阅读，并提供了CPU使用情况的图表区域。除此之外，它还允许您轻松地向进程发送特定信号。在前面，我们介绍了各种信号，您可以使用它们来结束一个进程。在这里，我们可以看到相同的概念以图形方式呈现。要向进程发送信号，请使用键盘上的上下箭头突出显示一个进程，然后按*F9*选择特定的信号。`SIGTERM`是默认选择的，但您也可以向进程发送任何其他信号。'
- en: '![Using shell-based resource monitors](img/B03919_05_08.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![使用基于shell的资源监视器](img/B03919_05_08.jpg)'
- en: Preparing to send a signal to a process in htop
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 准备在htop中向进程发送信号
- en: The process list in `htop` can be sorted similar to `iotop`. One thing that
    may not be apparent at first is that `htop` supports mouse input. While you can
    select columns with arrow keys, you can also click on them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`htop`中的进程列表可以类似于`iotop`进行排序。一开始可能不明显的一件事是，`htop`支持鼠标输入。虽然您可以使用箭头键选择列，但也可以单击它们。'
- en: Another benefit to `htop` is how customizable it is. Although the default layout
    is decent for most use cases, you can add additional meters. To do so, press *F2*
    or click on **Setup** and you'll be brought to a menu where you can add or remove
    meters from the current view. Under `Available Meters`, highlight one that you
    want to add and press *F5* to add it to the left column or *F6* to add it to the
    right column. One meter you may find useful is the `CPU average`. Once you've
    added a new meter, you can reposition it by highlighting it and pressing *F7*
    to move it up or *F8* to move it down. When finished, press *Esc* to return to
    the main screen. These changes are saved automatically, so the next time you open
    `htop`, your custom layout will be intact.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`htop`的另一个好处是它的可定制性。虽然默认布局对大多数用例来说都不错，但您可以添加额外的仪表。要这样做，请按*F2*或单击**设置**，您将进入一个菜单，可以从当前视图中添加或删除仪表。在`可用仪表`下，突出显示您想要添加的仪表之一，然后按*F5*将其添加到左列，或按*F6*将其添加到右列。您可能会发现有用的一个仪表是`CPU平均值`。添加新仪表后，您可以通过突出显示它并按*F7*将其上移或按*F8*将其下移来重新定位它。完成后，按*Esc*返回到主屏幕。这些更改会自动保存，因此下次打开`htop`时，您的自定义布局将保持不变。'
- en: Scanning used storage
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描已使用的存储
- en: 'Almost everyone experiences a situation where disk space seems to vanish, with
    no clear indication as to what is taking up all the space. There are multiple
    ways in which you can troubleshoot what in particular is eating your hard drive
    space for breakfast. In order to see an overview of your mounted filesystems as
    well as their used and free space, execute the `df` command. Using `-h` with `df`
    is easier to read for most people, as it will show used space in MB and GB:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个人都会遇到磁盘空间似乎消失的情况，却没有明确的指示是什么占用了所有的空间。有多种方法可以排除是什么特别占用了你的硬盘空间。为了查看已挂载文件系统的概况以及它们的已用和空闲空间，执行`df`命令。对于大多数人来说，使用`-h`和`df`更容易阅读，因为它会显示以MB和GB为单位的已用空间：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Armed with that information, you'll know exactly what device is being used up
    and what volumes to focus your attention on. But the `df` command doesn't actually
    tell you what is using up all the space; it only gives you an overview of the
    current situation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了这些信息，您将准确知道哪个设备被使用了，以及要关注的卷。但`df`命令实际上并没有告诉您是什么占用了所有的空间；它只是给了您当前情况的概述。
- en: 'Next up is `du`. The `du` command, which can also be paired with `-h` for the
    same reason, shows you how much space is being used in a directory. All you would
    need to do is to `cd` into the directory you wish to check, and then run `du -h`.
    For even easier to read output, run the following in a directory:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`du`。`du`命令也可以与`-h`配对，原因相同，它显示目录中使用了多少空间。您只需要`cd`进入要检查的目录，然后运行`du -h`。为了更易于阅读的输出，可以在目录中运行以下命令：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Breaking down that command, we have `-h` parameter that we already know makes
    the output easier to read. The `-s` parameter shows only a total and `-c` will
    present you with a grand total at the end. Since we used an asterisk with the
    command, it will run `du -hsc` against each subdirectory contained within the
    current one. With this command, you can determine which directories in your current
    working directory are using up the most space.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 分解该命令，我们有`-h`参数，我们已经知道它使输出更易于阅读。`-s`参数仅显示总计，`-c`将在最后呈现总计。由于我们在命令中使用了星号，它将对当前目录中包含的每个子目录运行`du
    -hsc`。使用此命令，您可以确定当前工作目录中哪些目录占用了最多的空间。
- en: However, it gets even better than that. As useful as `du -hsc *` is, you still
    have to run it manually for each subdirectory. There are ways to use it to scan
    deeper, but `du` is only useful for an overview summary. An even better way is
    to install `ncdu`. The `ncdu` command is not a graphical utility in that it doesn't
    require a graphical desktop environment. But it's so easy to use; you may think
    that it actually was a graphical utility. Once kicked off against a particular
    directory, it does a deep dive and allows you to actually traverse the filesystem
    tree from that point and follow what is using up all your space straight down
    to the culprit.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但它甚至比这更好。尽管`du -hsc *`非常有用，但您仍然需要为每个子目录手动运行它。有方法可以使用它进行更深入的扫描，但`du`仅适用于概览摘要。更好的方法是安装`ncdu`。`ncdu`命令不是图形实用程序，因为它不需要图形桌面环境。但它非常易于使用；您可能会认为它实际上是一个图形实用程序。一旦针对特定目录启动，它会进行深入分析，并允许您实际遍历文件系统树并跟踪占用所有空间的元凶。
- en: 'You don''t need to be the root user or have `sudo` permission to utilize `ncdu`,
    but keep in mind `ncdu` can only scan directories that its calling user has permission
    to access. In some cases, you may need to run it as root to get around that. The
    basic usage of `ncdu` is simple; call `ncdu` along with a path for it to scan.
    For example, you can scan your entire filesystem or a section of it:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要成为root用户或具有`sudo`权限来使用`ncdu`，但请记住，`ncdu`只能扫描其调用用户有权限访问的目录。在某些情况下，您可能需要以root身份运行它以绕过这一限制。`ncdu`的基本用法很简单；只需调用`ncdu`并提供要扫描的路径。例如，您可以扫描整个文件系统或其中的一部分：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![Scanning used storage](img/B03919_05_09.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![扫描已使用的存储空间](img/B03919_05_09.jpg)'
- en: Scanning the root filesystem of a CentOS system with ncdu
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ncdu扫描CentOS系统的根文件系统
- en: 'It''s important to note that by default `ncdu` will scan everything within
    the directory you give it, including anything that may be mounted. An example
    of this can be mounted NFS shares or external disks, but you may not want external
    mounts to factor into the results. Thankfully, this is as easy as presenting the
    `-x` option to `ncdu`, which tells it to ignore anything you have mounted when
    you run your scan:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，默认情况下，`ncdu`将扫描您提供的目录中的所有内容，包括可能已挂载的任何内容。这可能包括已挂载的NFS共享或外部磁盘，但您可能不希望外部挂载影响结果。幸运的是，只需向`ncdu`提供`-x`选项即可，告诉它在运行扫描时忽略您已挂载的任何内容：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once the scan is finished, you can traverse the results by pressing up and down
    keys on your keyboard, and press *Enter* to change into a directory. From within
    `ncdu` itself, you can even delete files without having to run any extra commands
    by simply pressing *D*. This way, you can do your auditing and cleanup from the
    same tool.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描完成后，您可以通过键盘上的上下键遍历结果，并按*Enter*进入目录。在`ncdu`内部，您甚至可以通过简单按下*D*键而无需运行任何额外命令来删除文件。这样，您可以在同一工具中进行审计和清理。
- en: Feel free to run `ncdu` on your own systems and interrogate where your free
    space is going. Unless you actually start deleting things, it's harmless and can
    show you some potential items you may want to clean up. On actual servers, `ncdu`
    is quite useful in troubleshooting where your disk space is going.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 随意在自己的系统上运行`ncdu`，并查看您的可用空间去向。除非您真的开始删除东西，否则它是无害的，并且可以显示一些您可能想要清理的潜在项目。在实际服务器上，`ncdu`在解决磁盘空间去向方面非常有用。
- en: Introduction to logging
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志简介
- en: By default, Linux logs almost everything. This is important for developing a
    root cause analysis when things go wrong. When you're faced with a problem on
    a production server, all you should need to do is determine the time in which
    the problem started and then read the log files for the types of things that happened
    on the system during that time. Linux logging is very informative.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Linux几乎记录所有内容。这对于在出现问题时进行根本原因分析非常重要。当您在生产服务器上面临问题时，您只需要确定问题开始的时间，然后阅读在该时间内系统上发生的事情的日志文件。Linux日志非常详尽。
- en: But nowadays, the way that Linux handles logging is changing. With the rise
    of systemd, which is now the default init system on most Linux distributions,
    it's taken over almost everything, including logging. In the past, you would venture
    into `/var/log` whenever you wanted to read your logs, which is a directory containing
    various log files in plain text format. On both Debian and CentOS, you can still
    find logs in `/var/log`, so you'll still be able to utilize them for troubleshooting
    the same as we always have. But it's not yet certain how much longer this will
    be kept around.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如今，Linux处理日志的方式正在发生变化。随着systemd的崛起，它现在是大多数Linux发行版上的默认init系统，它几乎接管了一切，包括日志记录。过去，每当您想要阅读日志时，您会进入`/var/log`，这是一个包含各种以纯文本格式存储的日志文件的目录。在Debian和CentOS上，您仍然可以在`/var/log`中找到日志，因此您仍然可以像以往一样利用它们进行故障排除。但目前尚不确定这种方式还能维持多久。
- en: Many might think that systemd taking over logging is a bad thing. After all,
    having the init system take care of so much of the system's upkeep gives it more
    work to perform, which may stretch it too thin. But one issue with syslog (the
    previous approach) is that there was no consistency from one distribution to another
    in how the logs were created or named. For example, Debian systems include an
    `auth.log`, which CentOS doesn't. Both have `dmesg` and only CentOS has a `boot.log`
    file. This makes troubleshooting a mixed environment, a beast.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人可能认为systemd接管日志记录是件坏事。毕竟，让init系统负责系统的许多维护工作会增加其负担，可能会使其负担过重。但syslog（之前的方法）的一个问题是，不同发行版在日志创建或命名方面没有一致性。例如，Debian系统包括`auth.log`，而CentOS没有。两者都有`dmesg`，只有CentOS有`boot.log`文件。这使得在混合环境中进行故障排除变得非常困难。
- en: The systemd approach (which we'll discuss later) offers a more consistent approach
    between distributions. So while it may be true that systemd is being spread thin
    with the multitude of responsibilities it has on the system, consistency is definitely
    welcome.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: systemd方法（稍后我们将讨论）在不同发行版之间提供了更一致的方法。因此，尽管systemd在系统上承担了许多责任，但一致性肯定是受欢迎的。
- en: Both Debian and CentOS have a log file that is used whenever a user logs into
    the system, even if she or he does so via SSH. On CentOS, this log is located
    in `/var/log/secure`. Debian uses `/var/log/auth.log` for this purpose. If you
    need to know who is logging into your system and when, you would want to look
    at these logs in order to find out. On both, you can find `/var/log/messages`,
    which includes a smorgasbord of useful information, such as output from processes,
    network activation, services starting up, and more. When it comes to troubleshooting
    hardware, `/var/log/dmesg` is a great place to look. In fact, `/var/log/dmesg`
    has its own command. Typing `dmesg` from anywhere on the system (even if your
    current working directory isn't `/var/log`) will present you with the same log.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Debian和CentOS都有一个日志文件，用于用户登录系统，即使是通过SSH登录。在CentOS上，此日志位于`/var/log/secure`。Debian使用`/var/log/auth.log`来实现此目的。如果您需要知道谁何时登录到您的系统，您需要查看这些日志。在两者中，您可以找到`/var/log/messages`，其中包括各种有用信息，例如进程输出，网络激活，服务启动等。在硬件故障排除方面，`/var/log/dmesg`是一个很好的查看地点。实际上，`/var/log/dmesg`有自己的命令。在系统的任何位置（即使您当前的工作目录不是`/var/log`），键入`dmesg`将呈现相同的日志。
- en: 'The log files in `/var/log` are very easy to follow in near real time by using
    `tail -f`. The `-f` flag of `tail` isn''t specifically limited to log files. It
    allows you to display the output of a log file, as it''s being written to. When
    you''re troubleshooting a system, `tail -f` is indispensable. For example, if
    you have a user that cannot log in to the system, you could run the following
    on a Debian system to watch the `auth.log` file as they make their attempt. That
    way, you can see what error message the system is registering for their failed
    attempts at logging in:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`tail -f`可以非常容易地实时跟踪`/var/log`中的日志文件。`tail`的`-f`标志不仅限于日志文件。它允许您显示日志文件的输出，就像它正在被写入一样。在故障排除系统时，`tail
    -f`是不可或缺的。例如，如果您有一个无法登录系统的用户，您可以在Debian系统上运行以下命令来观察`auth.log`文件，以查看他们的尝试。这样，您可以看到系统为其登录失败尝试注册的错误消息：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: From there, as the `auth.log` gets updated, the results will show in your terminal
    immediately. To end, simply press *Ctrl* + *C* to stop following the output. You
    can do this with any log, or any text file on your system. This is very useful
    for a multitude of troubleshooting tactics, as most processes you may want to
    investigate will log its activities to at least one log.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，随着`auth.log`的更新，结果将立即显示在您的终端上。要结束，只需按下*Ctrl* + *C*停止跟踪输出。您可以对系统上的任何日志或文本文件执行此操作。这对于多种故障排除策略非常有用，因为您可能想要调查的大多数进程都会将其活动记录到至少一个日志中。
- en: Maintaining log size with logrotate
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用logrotate来维护日志大小
- en: As you know, logs are crucial when it comes to troubleshooting. Linux generally
    does a very good job of logging almost everything you would want to know, but
    over time these logs can really add up. On a production server, a log file growing
    out of control and taking up literally all of your server's free space is a very
    real issue if left unchecked. In addition to disk space being consumed, a gigantic
    log file is very hard to open in a text editor in order to view the contents,
    which makes troubleshooting even harder. A log file of over 500 GB would not only
    take up a ridiculous amount of space; it would likely cause the system to hang
    if you try to open it, and transferring a log file to another server for analysis
    once it reaches a very large size isn't practical either.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，日志在故障排除时至关重要。Linux通常会很好地记录几乎您想要了解的一切，但随着时间的推移，这些日志可能会不断增加。在生产服务器上，如果不加以控制，日志文件不断增长并占用服务器的所有可用空间是一个非常现实的问题。除了占用磁盘空间外，巨大的日志文件很难在文本编辑器中打开以查看内容，这使得故障排除变得更加困难。超过500GB的日志文件不仅会占用大量空间；如果尝试打开它，它可能会导致系统挂起，并且一旦达到非常大的大小，将日志文件传输到另一台服务器进行分析也是不切实际的。
- en: For the most part, excessive log files are not as much of an issue on newer
    Linux distributions than those of the past. With syslog, there was no automatic
    maintenance. If you didn't either clean the logs yourself or set up something
    to rotate them for you, you would definitely need to keep an eye on them. Nowadays,
    **journald** handles this for us. But with Debian and CentOS, this can be somewhat
    of a mixed bag. This is because although the systemd journald takes care of logging
    for us on newer releases of most popular Linux distributions, syslog is still
    used for compatibility. Therefore, we still have to deal with log rotation even
    though all the pieces are in place for journald. The journald is the future, though
    syslog is still used on Enterprise Linux distributions today for compatibility.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在较新的Linux发行版上，过多的日志文件通常不是问题。使用syslog时，没有自动维护。如果您没有自己清理日志，或者设置了一些东西来为您轮换日志，那么您肯定需要留意它们。如今，**journald**为我们处理这个问题。但是对于Debian和CentOS来说，这可能有点复杂。这是因为尽管systemd
    journald在大多数流行的Linux发行版的新版本中为我们处理日志记录，但syslog仍然用于兼容性。因此，即使所有部件都已经就位，我们仍然需要处理日志轮换。journald是未来，尽管syslog仍然在企业Linux发行版上用于兼容性。
- en: Log rotation is the process of taking an existing log file, renaming it, and
    having the process write to a brand-new empty log file. The previous log files
    can all be kept, or you can keep only a few of them if you wish. It's not uncommon
    for Enterprise systems to have a specific retention policy. It's a common practice
    to compress previous logs, which saves a great amount of disk space. This is where
    logrotate comes in. It's a process that we can run on our server to automatically
    swap out our log files and (as an option) compress the backup copies.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 日志轮换是指获取现有日志文件，重命名它，并让进程写入一个全新的空日志文件的过程。以前的日志文件可以全部保留，或者您也可以只保留其中几个。企业系统通常有特定的保留策略。压缩以前的日志是很常见的做法，这样可以节省大量的磁盘空间。这就是logrotate的用武之地。这是一个我们可以在服务器上运行的过程，用来自动交换我们的日志文件，并（作为一个选项）压缩备份副本。
- en: While designing a Linux network, it's important to understand which processes
    each server needs to run and to take into account the logging requirements of
    those processes from the start. Having logrotate installed and configured before
    a server enters production is a good practice. Having a server run out of free
    space in the middle of production is never a good experience, and knowing first
    what log files a running process creates, and being prepared to handle them is
    a good idea. While configuring your logging, it's important to take into consideration
    the retention requirements of your company, if there are any.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计Linux网络时，了解每台服务器需要运行哪些进程，并从一开始考虑这些进程的日志记录要求是很重要的。在服务器进入生产之前安装和配置logrotate是一个好的做法。在生产过程中服务器的空间用完是一个不好的经历，首先了解运行进程创建的日志文件，做好处理准备是一个好主意。在配置日志记录时，重要的是要考虑公司的保留要求，如果有的话。
- en: 'On the CentOS system used in my lab, `logrotate` was installed by default.
    Debian had it installed out of the box as well. To verify this on your system,
    simply run the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我实验室使用的CentOS系统上，默认情况下安装了`logrotate`。Debian也默认情况下安装了它。要在您的系统上验证这一点，只需运行以下命令：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: On CentOS, the `logrotate` binary is located in `/usr/sbin`, while Debian stores
    theirs in `/usr/sbin`. If the `which` command shows no output, you may need to
    use your distribution's package manager to install the `logrotate` package.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS上，`logrotate`二进制文件位于`/usr/sbin`，而Debian将它们存储在`/usr/sbin`中。如果`which`命令没有输出，您可能需要使用您的发行版软件包管理器来安装`logrotate`软件包。
- en: 'With the default installations of both Debian and CentOS, `logrotate` is already
    configured to run each day. When it does, it checks the `/etc/logrotate.d` directory
    for instructions and then executes them. The configuration for setting up `logrotate`
    rules is fairly straightforward. If you need example syntax, refer to your own
    system. By default, several `logrotate` scripts are created for you. An example
    of this is Debian''s package manager `apt`. Whenever you install packages on a
    Debian system, it''s logged in the following place:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian和CentOS的默认安装中，`logrotate`已经配置为每天运行。当它运行时，它会检查`/etc/logrotate.d`目录中的指令，然后执行它们。设置`logrotate`规则的配置非常简单。如果您需要示例语法，请参考您自己的系统。默认情况下，为您创建了几个`logrotate`脚本。其中一个例子是Debian的软件包管理器`apt`。在Debian系统上安装软件包时，它会被记录在以下位置：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you view this file, you should see results of recent package installations
    that you or another user has performed. By default, the following file exists
    on Debian systems to handle the rotation of this log:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看此文件，您应该看到您或其他用户执行的最近软件包安装的结果。在Debian系统上，默认情况下存在以下文件来处理此日志的轮换：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On Debian 8, this file contains the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian 8上，此文件包含以下内容：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, this configuration file for `logrotate` handles not only the
    `history.log` we mentioned earlier, but also `term.log` as well. Each section
    of this configuration begins with a path for `logrotate` to check, followed by
    individual options within brackets.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`logrotate`的这个配置文件不仅处理我们之前提到的`history.log`，还处理`term.log`。此配置的每个部分都以`logrotate`要检查的路径开头，然后是方括号内的各个选项。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `term.log` file shows the actual terminal output that would've been seen
    while running an apt instance.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`term.log`文件显示了在运行apt实例时将会看到的实际终端输出。'
- en: Among the options, we can see `rotate 12`, which means that up to 12 backup
    log files will be kept. Next, we see `monthly`, which details how often the log
    will actually be rotated. Despite the fact that `logrotate` is configured by default
    to run daily, it will follow the instructions contained within the individual
    configurations and only rotate if it meets that criteria. The `compress` option
    tells `logrotate` to compress the backed up file, which is probably what you want
    in most cases. Compressed log files use up very little space compared to the uncompressed
    live log, so it's definitely something to consider. `missingok` tells `logrotate`
    to keep running even if it encounters a missing log file. Otherwise, it would've
    displayed an error. Finally, we have `notifempty`, which simply tells `logrotate`
    to not bother with a log file if it is empty.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在选项中，我们可以看到`rotate 12`，这意味着最多会保留12个备份日志文件。接下来，我们看到`monthly`，它详细说明了日志实际上会被多久轮换一次。尽管`logrotate`默认配置为每天运行，但它将遵循各个配置中包含的指令，只有在符合条件时才会轮换。`compress`选项告诉`logrotate`压缩备份文件，这在大多数情况下可能是你想要的。压缩的日志文件与未压缩的实时日志相比占用的空间非常少，因此这绝对值得考虑。`missingok`告诉`logrotate`即使遇到缺失的日志文件也要继续运行。否则，它会显示错误。最后，我们有`notifempty`，它简单地告诉`logrotate`如果日志文件为空就不要理会它。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can see a complete list of `logrotate` configuration options by perusing
    its man page:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过查阅`logrotate`的man页面来看到完整的`logrotate`配置选项列表。
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: While `logrotate` has some fairly decent default configuration for some of the
    services that ship with CentOS and Debian, you'll want to consider creating configuration
    for any new services that you set up. To do so, it's easiest to follow the format
    shown in example files that you'll already have stored in `/etc/logrotate.d`.
    It's as simple as beginning your configuration block with the path to a file you
    want `logrotate` to handle for you, followed by options within curly brackets.
    There's no service to restart or special command to make your new configuration
    active. The next time that `logrotate` runs, it will check the `/etc/logrotate.d`
    directory for new configurations and run them if there are no errors.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`logrotate`为一些随CentOS和Debian一起提供的服务有相当不错的默认配置，但你可能需要考虑为你设置的任何新服务创建配置。要这样做，最简单的方法是按照你已经存储在`/etc/logrotate.d`中的示例文件中显示的格式。只需从文件路径开始你的配置块，然后在花括号内添加选项。没有需要重新启动的服务或特殊命令来使你的新配置生效。下次`logrotate`运行时，它将检查`/etc/logrotate.d`目录中是否有新的配置，并在没有错误的情况下运行它们。
- en: Understanding the systemd init system
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解systemd init系统
- en: On quite a few Linux distributions these days, the init system has been switched
    to systemd. This is true of Debian and CentOS starting with Version 8 and 7, respectively,
    but other distributions such as Fedora, Ubuntu, Arch Linux, and others have switched
    as well. Although some administrators prefer sysvinit, which was the previous
    dominant init system, systemd offers quite a few advancements over older systems.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的许多Linux发行版中，init系统已经切换到systemd。这适用于分别从版本8和7开始的Debian和CentOS，但其他发行版如Fedora、Ubuntu、Arch
    Linux等也已经切换。尽管一些管理员更喜欢之前主导的init系统sysvinit，但systemd相对于旧系统提供了许多进步。
- en: 'With systemd, commands you would use to start processes are now different,
    though the majority of the older commands still work (for now). With sysvinit
    on a Debian 7 system, you would use the following command to restart Samba:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用systemd，你现在使用来启动进程的命令是不同的，尽管大多数旧命令仍然有效（目前）。在Debian 7系统上使用sysvinit，你会使用以下命令来重新启动Samba：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, with systemd, we now use `systemctl` to `start`, `stop`, or `restart`
    a process:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在我们使用`systemctl`来`start`，`stop`或`restart`一个进程：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The sysvinit style of managing processes was the same in CentOS and Debian,
    and it is still the same now. At the time of this writing, both have switched
    to systemd. But the older `/etc/init.d/<process-name> restart|stop|start` commands
    still work in both Debian and CentOS with current releases, but instead of using
    sysvinit (which is gone) the commands are just translated to systemd commands
    instead. If you were to run the older sysvinit style commands, you'll likely see
    some text in the output informing you that the system is using `systemctl` instead.
    While this is great for the sake of compatibility (scripts relying on sysvinit
    style commands will likely still work), this won't be around forever. Learning
    systemd is important as once the sysvinit compatibility layer is removed, you'll
    no longer be able to rely on the older method. Thankfully, the basics of systemd
    are quick to learn.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS和Debian中管理进程的sysvinit风格以前是一样的，现在仍然是一样的。在撰写本文时，两者都已经切换到systemd。但在当前版本中，旧的`/etc/init.d/<process-name>
    restart|stop|start`命令在Debian和CentOS中仍然有效，但不再使用sysvinit（已经消失），而是转换为systemd命令。如果你运行旧的sysvinit风格命令，你可能会在输出中看到一些文本，告诉你系统正在使用`systemctl`。尽管这对于兼容性来说很好（依赖sysvinit风格命令的脚本可能仍然有效），但这种情况不会持续太久。学习systemd很重要，因为一旦sysvinit兼容层被移除，你将不再能依赖旧的方法。幸运的是，systemd的基础知识很快就能学会。
- en: To start a process with systemd, execute `systemctl` followed by the action
    you want to perform, followed by the process you would like to perform the action
    on. As we've done earlier with Samba, we executed `systemctl restart samba`. But
    we can also stop samba using `systemctl stop samba`, or we can start it by executing
    `systemctl start samba` as root.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用systemd启动一个进程，执行`systemctl`，然后是你想执行的操作，再加上你想对其执行操作的进程。就像我们之前对Samba所做的那样，我们执行了`systemctl
    restart samba`。但我们也可以使用`systemctl stop samba`来停止samba，或者以root身份执行`systemctl start
    samba`来启动它。
- en: 'The systemd init system also allows you to enable or disable a process. A process
    which is enabled will be started as the system is booted. A disabled process will
    only start if you do so manually. Depending on the distribution, processes (or
    units, as systemd calls them) may not be enabled by default. On CentOS, for example,
    you can install Samba, but it won''t start automatically unless you tell it to
    do so. On Debian systems, it''s largely assumed that since you installed something,
    you probably want it to run, so it will enable the newly installed process by
    default. Either way, it''s not a good idea to assume that a process will automatically
    start with systemd. To find out, use the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: systemd init系统还允许您启用或禁用进程。启用的进程将在系统启动时启动。只有在您手动启动时，禁用的进程才会启动。根据发行版，进程（或systemd称之为单元）可能不会默认启用。例如，在CentOS上，您可以安装Samba，但除非告诉它这样做，否则它不会自动启动。在Debian系统上，通常假定您安装了某些东西，因此它将默认启用新安装的进程。无论哪种方式，都不应该假设进程会自动启动systemd。要找出，请使用以下命令：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Understanding the systemd init system](img/B03919_05_10.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![理解systemd init系统](img/B03919_05_10.jpg)'
- en: Checking the status of a unit with systemctl
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用systemctl检查单元的状态
- en: Checking the status with `systemctl` gives you a great deal of useful information,
    typically more than checking the status of processes with sysvinit. First, you
    can see whether or not a unit is running. In the previous screenshot, we can see
    that `nfs-kernel-server` is running. In addition, status gives us a few lines
    of log output as well, so if there are any problems starting a unit we may find
    the error right there.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`systemctl`检查状态会给您提供大量有用的信息，通常比使用sysvinit检查进程状态时更多。首先，您可以看到单元是否正在运行。在上一张截图中，我们可以看到`nfs-kernel-server`正在运行。此外，状态还给我们提供了几行日志输出，因此如果启动单元时出现任何问题，我们可能会在那里找到错误。
- en: 'You might be wondering how to find out whether or not a unit is configured
    to come up automatically when the system is booted. Systemd makes that easy as
    well. We can use `is-enabled` with `systemctl` in order to find out if the unit
    is enabled. For example, to ensure the `ssh` daemon is configured to automatically
    start, we would issue the following command on a Debian system:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道如何找出一个单元是否配置为在系统启动时自动启动。systemd也使得这变得容易。我们可以使用`is-enabled`与`systemctl`来查找单元是否已启用。例如，要确保`ssh`守护程序已配置为自动启动，我们将在Debian系统上发出以下命令：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To show all the units on your system and how they''re configured, run the following
    command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示系统上的所有单元及其配置方式，请运行以下命令：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To enable a unit, pass `enable` as a parameter to `systemctl`. Similarly, you
    can do the same with `disable` to ensure a unit does not start at boot. Therefore,
    on a Debian system, `systemctl enable ssh` would configure the `ssh` daemon to
    start at boot, while `systemctl disable ssh` would ensure that it doesn't. CentOS
    would be the same, but substitute `sshd` for `ssh`. While the differing unit names
    can be annoying between Linux systems, always remember that you can use `systemctl
    list-unit-files` as mentioned earlier to see a list of the units registered to
    your system and what they're named.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用一个单元，将`enable`作为参数传递给`systemctl`。同样，您也可以使用`disable`来确保单元不会在启动时启动。因此，在Debian系统上，`systemctl
    enable ssh`将配置`ssh`守护程序在启动时启动，而`systemctl disable ssh`将确保它不会启动。CentOS也是一样，但用`sshd`替换`ssh`。尽管Linux系统之间的单元名称可能会让人感到恼火，但始终记住，您可以像前面提到的那样使用`systemctl
    list-unit-files`来查看注册到您的系统的单元列表及其名称。
- en: In a nutshell, that's pretty much all the knowledge required to use `systemctl`
    to manage processes (units) on your Linux system. For the most part, starting,
    stopping, enabling, and disabling units covers most use cases. For more advanced
    usage, see the man page for `systemctl`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这就是使用`systemctl`管理Linux系统上的进程（单元）所需的所有知识。在大多数情况下，启动、停止、启用和禁用单元可以涵盖大多数用例。对于更高级的用法，请参阅`systemctl`的man页面。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Systemd handles power management as well. You can use options such as `reboot`,
    `poweroff`, and `suspend` with `systemctl` to power on, shut down, or suspend
    the entire system.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Systemd还处理电源管理。您可以使用`systemctl`的选项，如`reboot`、`poweroff`和`suspend`来启动、关闭或暂停整个系统。
- en: Understanding the systemd journal
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解systemd日志
- en: Another component of systemd is journald, which handles logging. The systemd
    method of journald enables binary logs, which is quite a different approach to
    simple text files as used before. Due to the fact that many distributions which
    have adopted systemd are still in a transitional phase, you're likely to still
    see text file logs in `/var/log` in much the same way as you still may see init
    scripts in `/etc/init.d`. It's always recommended to use the systemd approach
    whenever possible, as that is the current solution that distributions are moving
    toward.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: systemd的另一个组件是journald，它处理日志记录。systemd的journald方法启用了二进制日志，这与以前使用的简单文本文件的方法完全不同。由于许多采用systemd的发行版仍处于过渡阶段，您可能仍会在`/var/log`中看到文本文件日志，就像您可能仍会在`/etc/init.d`中看到init脚本一样。始终建议尽可能使用systemd方法，因为这是发行版正在向其移动的当前解决方案。
- en: 'You can view journald logs with the `journalctl` command. In addition, various
    options can be used with the `journalctl` command in order to narrow down the
    output or perform certain actions. For example, you can use `journalctl -f` to
    follow new log output on your system, similar to how you could do the same with
    `tail -f` against log files stored in `/var/log`. Additionally, you can use `journalctl`
    to show output from a particular PID. To do so, simply use `journalctl` with `PID=`
    along with a PID. For example, to view output from PID `11753`, you would execute
    the following command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`journalctl`命令查看journald日志。此外，可以使用`journalctl`命令的各种选项来缩小输出范围或执行某些操作。例如，您可以使用`journalctl
    -f`来跟踪系统上的新日志输出，类似于您可以使用`tail -f`来跟踪存储在`/var/log`中的日志文件。此外，您可以使用`journalctl`来显示特定PID的输出。要这样做，只需使用`PID=`和PID一起使用`journalctl`。例如，要查看PID`11753`的输出，您将执行以下命令：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In addition, you can use the name of the unit to show its output:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用单位的名称来显示其输出：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: While `journalctl` is relatively simple to use, for those of you that are accustomed
    to the pervious syslog style of logging will be happy to know that you can (at
    least for now) still navigate to `/var/log` and peruse the logs there. For example,
    the `dmesg` command and log is still alive and well. But while `journalctl` and
    the concept of binary logs may take a while to get used to, I'm sure you'll find
    with practice that it is actually very handy.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`journalctl`相对简单易用，但习惯于以前的syslog日志记录方式的人会高兴地知道，您仍然可以（至少目前还可以）转到`/var/log`并查看日志。例如，`dmesg`命令和日志仍然存在且运行良好。但是，虽然需要一段时间来适应`journalctl`和二进制日志的概念，但我相信您会发现通过实践，它实际上非常方便。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered various ways in which you can manage your system's
    resources and look at logs. We started with an overview of managing processes
    and discussed load averages. Then, we covered monitoring a system's memory. In
    addition, we looked at shell-based system monitors such as `top` and `htop`. We
    also covered investigating disk usage and `ncdu`, which is a neat tool that allows
    you to scan a filesystem and view its usage in an easy to use way. We also covered
    `logrotate` and `systemd`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了各种管理系统资源和查看日志的方法。我们从管理进程的概述开始，讨论了负载平均值。然后，我们介绍了监视系统内存的方法。此外，我们还研究了基于shell的系统监视器，如`top`和`htop`。我们还介绍了磁盘使用情况和`ncdu`，这是一个方便的工具，可以扫描文件系统并以易于使用的方式查看其使用情况。我们还介绍了`logrotate`和`systemd`。
- en: In the next chapter, we'll take a look at managing our Linux-based network.
    This will include things such as configuring DHCP, DNS, NTP, as well as using
    `exim` to send e-mail and advertising shared services over the network.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何管理基于Linux的网络。这将包括配置DHCP、DNS、NTP，以及使用`exim`发送电子邮件和在网络上广告共享服务等内容。
