- en: Network Interface Card Drivers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络接口卡驱动程序
- en: We all know that networking is inherent to the Linux kernel. Some years ago,
    Linux was only used for its network performances, but things have changed now;
    Linux is much more than a server, and runs on billions of embedded devices. Through
    the years, Linux gained the reputation of being the best network operating system.
    In spite of all this, Linux cannot do everything. Given the huge variety of Ethernet
    controllers that exist, Linux has found no other way than to expose an API to
    developers who need a writing driver for their network device, or who need to
    perform kernel networking development in a general manner. This API offers a sufficient
    abstraction layer, allowing for gauranteeing the generosity of the developed code,
    as well as porting on other architectures. This chapter will simply walk through
    the part of this API that deals with **Network Interface Card** (**NIC** ) driver
    development, and discuss its data structures and methods.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道网络是Linux内核固有的一部分。几年前，Linux仅用于其网络性能，但现在情况已经改变；Linux不仅仅是一个服务器，而且在数十亿嵌入式设备上运行。多年来，Linux赢得了成为最佳网络操作系统的声誉。尽管如此，Linux并不能做到一切。鉴于存在大量以太网控制器的多样性，Linux别无选择，只能向需要为其网络设备编写驱动程序的开发人员或以一般方式进行内核网络开发的开发人员公开API。该API提供了足够的抽象层，可以保证开发的代码的通用性，并且可以在其他架构上进行移植。本章将简要介绍处理**网络接口卡**（**NIC**）驱动程序开发的API的部分，并讨论其数据结构和方法。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: NIC driver data structure and a walk through its main socket buffer structure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NIC驱动程序数据结构及其主要套接字缓冲区结构的详细介绍
- en: NIC driver architecture and methods description, as well as packets transmission
    and reception
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NIC驱动程序架构和方法描述，以及数据包的传输和接收
- en: Developing a dummy NIC driver for testing purposes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为测试目的开发一个虚拟NIC驱动程序
- en: Driver data structures
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动程序数据结构
- en: 'When you deal with NIC devices, there are two data structures that you need
    to play with:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理NIC设备时，有两个数据结构需要处理：
- en: 'The `struct sk_buff` structure, defined in `include/linux/skbuff.h` , which
    is the fundamental data structure in the Linux networking code, and which should
    be included in your code:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct sk_buff`结构，在`include/linux/skbuff.h`中定义，这是Linux网络代码中的基本数据结构，你的代码中也应该包含它：'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each packet sent or received is handled using this data structure.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个发送或接收的数据包都使用这个数据结构处理。
- en: 'The `struct net_device` structure; this is the structure by which any NIC device
    is represented in the kernel. It is the interface by which data transit takes
    place. It is defined in `include/linux/netdevice.h` , which should also be included
    in your code:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct net_device`结构；这是内核中表示任何NIC设备的结构。这是数据传输发生的接口。它在`include/linux/netdevice.h`中定义，你的代码中也应该包含它：'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Other files that one should include in the code are `include/linux/etherdevice.h`
    for MAC and Ethernet-related functions (such as `alloc_etherdev()` ) and `include/linux/ethtool.h`
    for ethtools support:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 其他应该在代码中包含的文件是`include/linux/etherdevice.h`，用于MAC和以太网相关函数（如`alloc_etherdev()`），以及`include/linux/ethtool.h`，用于ethtools支持：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The socket buffer structure
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字缓冲区结构
- en: 'This structure wraps any packet that transits through an NIC:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构包装了通过NIC传输的任何数据包：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the meanings of the elements in the structure:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结构中元素的含义：
- en: '`next` and `prev` : This represents the next and previous buffer in the list.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`和`prev`：这表示列表中的下一个和上一个缓冲区。'
- en: '`sk` : This is the socket associated with this packet.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sk`：这是与此数据包关联的套接字。'
- en: '`tstamp` : This is the time when the packet arrived/left.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tstamp`：这是数据包到达/离开的时间。'
- en: '`rbnode` : This is an alternative to `next` /`prev` represented in a red-black
    tree.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rbnode`：这是红黑树中`next`/`prev`的替代。'
- en: '`dev` : This represents the device this packet arrived on/is leaving by. This
    field is associated with two other fields not listed here. These are `input_dev`
    and `real_dev` . They track devices associated with the packet. Therefore, `input_dev`
    always refers to a device the packet is received from.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`：表示数据包到达或离开的设备。该字段与此处未列出的其他两个字段相关联。它们是`input_dev`和`real_dev`。它们跟踪与数据包相关的设备。因此，`input_dev`始终指的是数据包接收自的设备。'
- en: '`len` : This is the total number of bytes in the packet. Socket Buffers (SKBs)
    are composed of a linear data buffer and, optionally, a set of one or more regions
    called **rooms** . In case there are such rooms, `data_len` will hold the total
    number of bytes of the data area.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`len`：这是数据包中的总字节数。套接字缓冲区（SKB）由线性数据缓冲区和一个或多个称为**rooms**的区域组成。如果存在这样的区域，`data_len`将保存数据区域的总字节数。'
- en: '`mac_len` : This holds the length of the MAC header.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mac_len`：这保存了MAC头的长度。'
- en: '`csum` : This contains the checksum of the packet.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`csum`：这包含数据包的校验和。'
- en: '`Priority` : This represents the packet priority in QoS.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Priority`：这表示QoS中的数据包优先级。'
- en: '`truesize` : This keeps track of how many bytes of system memory are consumed
    by a packet, including the memory occupied by the `struct sk_buff` structure itself.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`truesize`：这个字段跟踪数据包占用的系统内存字节数，包括`struct sk_buff`结构本身占用的内存。'
- en: '`users` : This is used for reference counting for the SKB objects.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users`：这用于SKB对象的引用计数。'
- en: '`Head` : Head, data, tail are pointers to different regions (rooms) in the
    socket buffer.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Head`：Head、data、tail是套接字缓冲区中不同区域（rooms）的指针。'
- en: '`end` : This points to the end of the socket buffer.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end`：这指向套接字缓冲区的末尾。'
- en: Only a few fields of this structure have been discussed here. A full description
    is available in `include/linux/skbuff.h` ., which is the header file you should
    include to deal with socket buffers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构的只讨论了一些字段。完整的描述可以在`include/linux/skbuff.h`中找到。这是你应该包含以处理套接字缓冲区的头文件。
- en: Socket buffer allocation
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 套接字缓冲区分配
- en: 'Allocation of a socket buffer is a bit tricky, since it needs at least three
    different functions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字缓冲区的分配有点棘手，因为它至少需要三个不同的函数：
- en: First of all, the whole memory allocation should be done using the `netdev_alloc_skb()`
    function
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，整个内存分配应该使用`netdev_alloc_skb()`函数完成
- en: Increase and align header room with the `skb_reserve()` function
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`skb_reserve()`函数增加和对齐头部空间
- en: Extend the used data area of the buffer (which will contain the packet) using
    the `skb_put()` function.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`skb_put()`函数扩展缓冲区的已使用数据区域（将包含数据包）。
- en: 'Let us have a look at the following figure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的图：
- en: '![](img/Image00044.gif)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00044.gif)'
- en: Socket buffers allocation process
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字缓冲区分配过程
- en: 'We allocate a buffer large enough to contain a packet along with the Ethernet
    header by means of the `netdev_alloc_skb()` function:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过`netdev_alloc_skb()`函数分配足够大的缓冲区来包含一个数据包以及以太网头部：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function returns `NULL` on failure. Therefore, even if it allocates memory,
    `netdev_alloc_skb()` can be called from an atomic context.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数在失败时返回`NULL`。因此，即使它分配了内存，`netdev_alloc_skb()`也可以从原子上下文中调用。
- en: 'Since the Ethernet header is 14 bytes long, it needs to have some alignment
    so that the CPU does not encounter any performance issues while accessing that
    part of the buffer. The appropriate name of the `header_len` parameter should
    be `header_alignment` , since this parameter is used for alignment. The usual
    value is 2, and it is the reason why the kernel defined a dedicated macro for
    this purpose, `NET_IP_ALIGN` , in `include/linux/skbuff.h` :'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以太网头部长度为14字节，需要进行一些对齐，以便CPU在访问缓冲区的这部分时不会遇到性能问题。`header_len`参数的适当名称应该是`header_alignment`，因为该参数用于对齐。通常值为2，这就是内核为此目的在`include/linux/skbuff.h`中定义了专用宏`NET_IP_ALIGN`的原因：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The second step reserves aligned memory for the header by reducing the tail
    room. The function that does is `skb_reserve()` :'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步通过减少尾部空间为头部保留对齐内存。执行此操作的函数是`skb_reserve()`：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The last step consists of extending the used data area of the buffer to as
    large as the packet size, by means of the `skb_put()` function. This function
    returns a pointer to the first byte of the data area:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是通过`skb_put()`函数扩展缓冲区的已使用数据区域，使其大小与数据包大小一样。该函数返回数据区域的第一个字节的指针：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The allocated socket buffer should be forwarded to the kernel-networking layer.
    This is the last step of the socket buffer''s lifecycle. One should use the `netif_rx_ni()`
    function for that:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 分配的套接字缓冲区应该转发到内核网络层。这是套接字缓冲区生命周期的最后一步。应该使用`netif_rx_ni()`函数来实现：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will discuss how to use the preceding steps in the section of this chapter
    that deals with packet reception.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章节的部分中讨论如何使用前面的步骤来处理数据包接收。
- en: Network interface structure
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络接口结构
- en: 'A network interface is represented in the kernel as an instance of `struct
    net_device` structure, defined in `include/linux/netdevice.h` :'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 网络接口在内核中表示为`struct net_device`结构的实例，定义在`include/linux/netdevice.h`中：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `struct net_device` structure belongs to the kernel data structures that
    need to be allocated dynamically, having their own allocation function. An NIC
    is allocated in the kernel by means of the `alloc_etherdev()` function.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct net_device`结构属于需要动态分配的内核数据结构，具有自己的分配函数。NIC是通过`alloc_etherdev()`函数在内核中分配的。'
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The function returns `NULL` on failure. The `sizeof_priv` parameter represents
    the memory size to be allocated for a private data structure, attached to this
    NIC, and which can be extracted with the `netdev_priv()` function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数在失败时返回`NULL`。`sizeof_priv`参数表示要为附加到此NIC的私有数据结构分配的内存大小，并且可以使用`netdev_priv()`函数提取：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Given the `struct priv_struct,` which is our private structure, the following
    is an implementation of how you allocate a network device along with the private
    data structure:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`struct priv_struct`，这是我们的私有结构，以下是如何分配网络设备以及私有数据结构的实现：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Unused network devices should be freed with the `free_netdev()` function, which
    also frees memory allocated for private data. You should call this method only
    after the device has been unregistered from the kernel:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 未使用的网络设备应该使用`free_netdev()`函数释放，该函数还会释放为私有数据分配的内存。只有在设备从内核中注销后才应该调用此方法：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After your `net_device` structure has been completed and filled, you should
    call `register_netdev()` on it. This function is explained later in this chapter
    in the section *Driver Methods* . Just keep in mind this function registers our
    network device with the kernel, so that it can be used. That being said, you should
    make sure the device really can process network operations before calling this
    function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`net_device`结构完成并填充后，应该在其上调用`register_netdev()`。该函数在本章节的*Driver Methods*部分中有解释。请记住，该函数会将我们的网络设备注册到内核中，以便可以使用。也就是说，在调用此函数之前，您应该确保设备确实可以处理网络操作。
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The device methods
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备方法
- en: 'Network devices fall into the category of devices not appearing in the `/dev`
    directory (unlike block, input, or char devices). Therefore, like all of those
    kinds of devices, the NIC driver exposes a set of facilities in order to perform.
    The kernel exposes operations that can be performed on the network interfaces
    by means of the `struct net_device_ops` structure, which is a field of the `struct
    net_device` structure, representing the network device (`dev->netdev_ops` ). The
    `struct net_device_ops` fields are described as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 网络设备属于不出现在`/dev`目录中的设备类别（不像块设备、输入设备或字符设备）。因此，像所有这些类型的设备一样，NIC驱动程序会暴露一组设施以执行。内核通过`struct
    net_device_ops`结构公开可以在网络接口上执行的操作，该结构是`struct net_device`结构的一个字段，表示网络设备（`dev->netdev_ops`）。`struct
    net_device_ops`字段描述如下：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let us see what the meaning of each element in the structure is:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看结构中每个元素的含义：
- en: '`int (*ndo_init)(struct net_device *dev)` and `void(*ndo_uninit)(struct net_device
    *dev)` ; They are extra initialization/unitialization functions, respectively
    executed when the driver calls `register_netdev()` /`unregister_netdev()` in order
    to register/unregister the network device with the kernel. Most drivers do not
    provide those functions, since the real job is done by `ndo_open()` and `ndo_stop()`
    functions.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int (*ndo_init)(struct net_device *dev)`和`void(*ndo_uninit)(struct net_device
    *dev)`；它们是额外的初始化/反初始化函数，分别在驱动程序调用`register_netdev()`/`unregister_netdev()`以向内核注册/注销网络设备时执行。大多数驱动程序不提供这些函数，因为真正的工作是由`ndo_open()`和`ndo_stop()`函数完成的。'
- en: '`int (*ndo_open)(struct net_device *dev)` ; Prepares and opens the interface.
    The interface is opened whenever `ip` or `ifconfig` utilities activate it. In
    this method, the driver should request/map/register any system resource it needs
    (I/O ports, IRQ, DMA, and so on), turn on the hardware, and perform any other
    setup the device requires.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int (*ndo_open)(struct net_device *dev)`；准备并打开接口。每当`ip`或`ifconfig`实用程序激活它时，接口就会打开。在此方法中，驱动程序应请求/映射/注册所需的任何系统资源（I/O端口，中断请求，DMA等），打开硬件，并执行设备需要的任何其他设置。'
- en: '`int (*ndo_stop)(struct net_device *dev)` :The kernel executes this function
    when the interface is brought down (For example, `ifconfig <name> down` and so
    on). This function should perform reverse operations of what has been done in
    `ndo_open()` .'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int (*ndo_stop)(struct net_device *dev)`：当接口被关闭时（例如，`ifconfig <name> down`等），内核执行此函数。此函数应执行`ndo_open()`中所做的相反操作。'
- en: '`int (*ndo_start_xmit) (struct sk_buff *skb, struct net_device *dev)` : This
    method is called whenever the kernel wants to send a packet through this interface.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int (*ndo_start_xmit) (struct sk_buff *skb, struct net_device *dev)`：每当内核想要通过此接口发送数据包时，就会调用此方法。'
- en: '`void (*ndo_set_rx_mode)(struct net_device *dev)` : This method is called to
    change the interface address list filter mode, multicast or promiscuous. It is
    recommended to provide this function.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void (*ndo_set_rx_mode)(struct net_device *dev)`：调用此方法以更改接口地址列表过滤模式，多播或混杂模式。建议提供此功能。'
- en: '`void (*ndo_tx_timeout)(struct net_device *dev)` : The kernel calls this method
    when a packet transmission fails to complete within a reasonable period, usually
    for `dev->watchdog` ticks. The driver should check what happened, handle the problem,
    and resume packet transmission.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void (*ndo_tx_timeout)(struct net_device *dev)`：当数据包传输在合理的时间内未能完成时，通常为`dev->watchdog`滴答声，内核会调用此方法。驱动程序应检查发生了什么问题，处理问题，并恢复数据包传输。'
- en: '`struct net_device_stats *(*get_stats)(struct net_device *dev)` : This method
    returns the device statistic. It is what one can see when `netstat -i` or `ifconfig`
    is run.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct net_device_stats *(*get_stats)(struct net_device *dev)`：此方法返回设备统计信息。这是当运行`netstat
    -i`或`ifconfig`时可以看到的内容。'
- en: The preceding descriptions miss a lot of fields. The complete structure description
    is available in the `include/linux/netdevice.h` file. Actually, only `ndo_start_xmit`
    is mandatory, but it is a good practice to provide as many helper hooks as your
    device has features.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的描述遗漏了很多字段。完整的结构描述可在`include/linux/netdevice.h`文件中找到。实际上，只有`ndo_start_xmit`是强制性的，但最好提供尽可能多的辅助钩子，以适应设备的功能。
- en: Opening and closing
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开和关闭
- en: The `ndo_open()` function is called by the kernel whenever this network interface
    is configured by authorized users (admin for example) who make use of any user
    space utilities like `ifconfig` or `ip` .
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`ndo_open()`函数是由内核在授权用户（例如管理员）配置此网络接口时调用的，这些用户使用诸如`ifconfig`或`ip`之类的用户空间实用程序。'
- en: Like other network device operations, the `ndo_open()` function receives a `struct
    net_device` object as its parameter, from which the driver should get the device-specific
    object stored in the `priv` field at the time of allocating the `net_device` object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他网络设备操作一样，`ndo_open()`函数接收一个`struct net_device`对象作为其参数，驱动程序应该从中获取在分配`net_device`对象时存储在`priv`字段中的特定于设备的对象。
- en: The network controller usually raises an interrupt whenever it receives or completes
    a packet transmission. The driver needs to register an interrupt handler that
    will be called whenever the controller raises an interrupt. The driver can register
    the interrupt handler either in the `init()` /`probe()` routine or in the `open`
    function. Some devices need the interrupt to be enabled by setting this in a special
    register in the hardware. In this case, one can request the interrupt in the `probe`
    function and just set/clear the enable bit in the open/close method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 网络控制器通常在接收或完成数据包传输时引发中断。驱动程序需要注册一个中断处理程序，每当控制器引发中断时就会调用该处理程序。驱动程序可以在`init()`/`probe()`例程中或在`open`函数中注册中断处理程序。有些设备需要通过在硬件中的特殊寄存器中设置来启用中断。在这种情况下，可以在`probe`函数中请求中断，并在打开/关闭方法中设置/清除启用位。
- en: 'Let us summarize what the `open` function should do:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下`open`函数应该做什么：
- en: Update the interface MAC address (in case the user changed it and if your device
    allows this).
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新接口的MAC地址（如果用户更改了它，并且您的设备允许这样做）。
- en: Reset the hardware if necessary, and take it out of the low-power mode.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必要时重置硬件，并将其从低功耗模式中取出。
- en: Request any resources (I/O memory, DMA channels, IRQ).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求任何资源（I/O内存，DMA通道，中断请求）。
- en: Map IRQ and register interrupt handlers.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 映射中断请求和注册中断处理程序。
- en: Check the interface link status.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查接口链接状态。
- en: Call `net_if_start_queue()` on the device in order to let the kernel know that
    your device is ready to transmit packets.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`net_if_start_queue()`来让内核知道您的设备已准备好传输数据包。
- en: 'An example of `open` function is follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`open`函数的示例如下：'
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`netif_start_queue()` simply allows upper layers to call the device `ndo_start_xmit`
    routine. In other words, it informs the kernel that the device is ready to handle
    transmit requests.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`netif_start_queue()`简单地允许上层调用设备的`ndo_start_xmit`例程。换句话说，它通知内核设备已准备好处理传输请求。'
- en: 'The closing method on the other side just has to do the reverse of the operations
    done when the device was opened:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，关闭方法只需执行在打开设备时所做操作的相反操作：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`netif_stop_queue()` simply does the reverse of `netif_start_queue()` , telling
    the kernel to stop calling the device `ndo_start_xmit` routine. We can''t handle
    transmit request anymore.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`netif_stop_queue()`只是`netif_start_queue()`的反向操作，告诉内核停止调用设备的`ndo_start_xmit`例程。我们不能再处理传输请求。'
- en: Packet handling
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据包处理
- en: Packet handling consists of transmission and reception of packets. This is the
    main task of any network interface driver. Transmission refers only to sending
    outgoing frames, whereas reception refers to frames coming in.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包处理包括数据包的传输和接收。这是任何网络接口驱动程序的主要任务。传输仅指发送传出帧，而接收指的是传入帧。
- en: 'There are two ways to drive networking data exchange: by polling or by interrupt.
    Polling, which is a kind of timer-driven interrupt, consists of a kernel continuously
    checking at given intervals for any change from the device. On the other hand,
    interrupt mode consists of the kernel doing nothing, listening to an IRQ line,
    and waiting for the device to notify a change, by means of the IRQ. Interrupt-driven
    data exchange can increase system overhead during time of high traffic. That is
    why some drivers mix the two methods. The part of the kernel that allows mixing
    of the two methods is called **New API** (**NAPI** ), which consists of using
    polling during times of high traffic and using interrupt IRQ-driven management
    when the traffic becomes normal. New drivers should use NAPI if the hardware can
    support it. However, NAPI is not discussed in this chapter, which will focus on
    the interrupt-driven method.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动网络数据交换有两种方式：轮询或中断。轮询是一种基于定时器的中断，由内核在给定的时间间隔内不断检查设备是否有任何变化。另一方面，中断模式是内核什么都不做，监听IRQ线，并等待设备通过IRQ通知变化。在高流量时，中断驱动的数据交换会增加系统开销。这就是为什么一些驱动程序混合了这两种方法。允许混合这两种方法的内核部分称为**新API**（**NAPI**），在高流量时使用轮询，在流量变得正常时使用中断IRQ驱动管理。新驱动程序应该在硬件支持的情况下使用NAPI。然而，本章不讨论NAPI，而是专注于中断驱动的方法。
- en: Packet reception
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据包接收
- en: When a packet arrives into the network interface card, the driver must build
    a new socket buffer around it, and copy the packet into the `sk_ff->data` field.
    The kind of copy does not really matter, and DMA can be used too. The driver is
    generally aware of new data arrivals by means of interrupts. When the NIC receives
    a packet, it raises an interrupt, which will be handled by the driver, which has
    to check the interrupt status register of the device and check the real reason
    why this interrupt was raised (in could be RX ok, RX error, and so on). Bit(s)
    that correspond to the event that raised the interrupt will be set in the status
    register.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据包到达网络接口卡时，驱动程序必须围绕它构建一个新的套接字缓冲区，并将数据包复制到`sk_ff->data`字段中。复制的方式并不重要，也可以使用DMA。驱动程序通常通过中断意识到新数据的到达。当网卡接收到一个数据包时，它会引发一个中断，由驱动程序处理，必须检查设备的中断状态寄存器，并检查引发中断的真正原因（可能是RX
    ok，RX error等）。对应于引发中断的事件的位将在状态寄存器中设置。
- en: 'The tricky part will be in allocating and building the socket buffer. But fortunately,
    we already discussed that in the first section of this chapter. So let''s not
    waste time and let''s jump to a sample RX handler. The driver has to perform as
    many `sk_buff` allocations as the number of packets it received:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个棘手的部分将在分配和构建套接字缓冲区。但幸运的是，我们已经在本章的第一部分讨论过这个问题。所以让我们不要浪费时间，直接跳到一个样本RX处理程序。驱动程序必须执行与其接收的数据包数量相同的`sk_buff`分配：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following helper is responsible for getting one packet from the device,
    forwarding it to the kernel network, and decrementing the packet counter:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的辅助程序负责从设备获取一个数据包，转发到内核网络，并减少数据包计数：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Of course the only reason we call the RX handler from within a deferred work
    is because we sit on an SPI bus. All of the preceding operations could be performed
    from within the hwriq in case of an MMIO device. Have a look at the NXP FEC driver,
    in `drivers/net/ethernet/freescale/fec.c` to see how this is achieved.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们之所以从延迟工作中调用RX处理程序，是因为我们在SPI总线上。在MMIO设备的情况下，所有前面的操作都可以在hwriq中执行。看看NXP FEC驱动程序，在`drivers/net/ethernet/freescale/fec.c`中看看是如何实现的。
- en: Packet transmission
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据包传输
- en: When the kernel needs to send packets out of the interface, it calls the driver's
    `ndo_start_xmit` method, which should return `NETDEV_TX_OK` on success, or `NETDEV_TX_BUSY`
    on failure, and in this case you can't do anything to the socket buffer since
    it is still owned by the network queuing layer when the error is returned. This
    means you cannot modify any SKB fields, or free the SKB, and so on. This function
    is protected from the concurrent call by a spinlock.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当内核需要从接口发送数据包时，它调用驱动程序的`ndo_start_xmit`方法，成功时应返回`NETDEV_TX_OK`，失败时应返回`NETDEV_TX_BUSY`，在这种情况下，当错误返回时，你不能对套接字缓冲区做任何事情，因为它仍然由网络排队层拥有。这意味着你不能修改任何SKB字段，或者释放SKB等等。这个函数受自旋锁的保护，防止并发调用。
- en: Packet transmission is done asynchronously in most cases. The `sk_buff` of the
    transmitted packet is filled by the upper layers. Its `data` field contains packets
    to be sent. Drivers should extract packet from `sk_buff->data` and write it into
    the device hardware FIFO, or put it into a temporary TX buffer (if the device
    needs a certain size of data before sending it) before writing it into the device
    hardware FIFO. Data is really only sent once the FIFO reaches a threshold value
    (usually defined by the driver, or provided in a device datasheet) or when the
    driver intentionally starts the transmission, by setting a bit (a kind of trigger)
    in a special register of the device. That being said, the driver needs to inform
    the kernel not to start any transmissions until the hardware is ready to accept
    new data. This notification is done by means of the `netif_st` `op_queue()` function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，数据包传输是异步进行的。传输的`sk_buff`由上层填充。它的`data`字段包含要发送的数据包。驱动程序应从`sk_buff->data`中提取数据包并将其写入设备硬件FIFO，或将其放入临时TX缓冲区（如果设备在发送之前需要一定大小的数据）然后将其写入设备硬件FIFO。只有当FIFO达到阈值（通常由驱动程序定义，或在设备数据表中提供）或驱动程序有意开始传输时，数据才会真正发送，通过在设备的特殊寄存器中设置一个位（一种触发器）。也就是说，驱动程序需要通知内核在硬件准备好接受新数据之前不要启动任何传输。通过`netif_st`
    `op_queue()`函数来完成此通知。
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After sending the packet, the network interface card will raise an interrupt.
    The interrupt handler should check why the interrupt has occurred. In case of
    transmission interrupt, it should update its statistics (`net_device->stats.tx_errors`
    and `net_device->stats.tx_packets` ), and notify the kernel that the device is
    free for sending new packets. This notification is done by means of `netif_wake_queue()`
    :'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 发送数据包后，网络接口卡将引发中断。中断处理程序应检查中断发生的原因。在传输中断的情况下，应更新其统计数据（`net_device->stats.tx_errors`和`net_device->stats.tx_packets`），并通知内核设备可以发送新数据包。通过`netif_wake_queue()`来完成此通知：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To summarize, packet transmission is split into two parts:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，数据包传输分为两部分：
- en: '`ndo_start_xmit` operation, which notifies the kernel that the device is busy,
    set up everything, and starts the transfer.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ndo_start_xmit`操作，通知内核设备忙，设置一切，并开始传输。'
- en: The TX interrupt handler, which updates TX statistics and notifies the kernel
    that the device is available again.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TX中断处理程序，更新TX统计数据并通知内核设备再次可用。
- en: 'The `ndo_start_xmit` function must roughly contain the following steps:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`ndo_start_xmit`函数大致包含以下步骤：'
- en: Call `netif_stop_queue()` on the network device in order to inform the kernel
    that the device will be busy in data transmission.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`netif_stop_queue()`来通知内核设备将忙于数据传输。
- en: Write `sk_buff->data` content into the device FIFO.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`sk_buff->data`的内容写入设备FIFO。
- en: Trigger the transmission (instruct the device to start transmission).
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发传输（指示设备开始传输）。
- en: Operations (2) and (3) may lead to sleep for devices sitting on slow buses (SPI
    for example) and may need to be deferred to the work structure. This is the case
    for our sample.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 操作（2）和（3）可能导致设备在慢总线上休眠（例如SPI），可能需要延迟到工作结构。这是我们示例的情况。
- en: 'Once the packet is transferred, the TX interrupt handler should perform the
    following steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据包传输完成，TX中断处理程序应执行以下步骤：
- en: 'Depending on the device being memory mapped or sitting on a bus whose access
    functions may sleep, the following operations should be performed directly in
    the hwirq handler or scheduled in a work (or threaded IRQ):'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据设备是内存映射还是位于可能休眠的总线上，以下操作应直接在hwirq处理程序中执行，或者在工作（或线程中断）中调度执行：
- en: 1\. Check if the interrupt is a transmission interrupt.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 检查中断是否是传输中断。
- en: 2\. Read the transmission descriptor status register and see what the status
    of the packet is.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 读取传输描述符状态寄存器并查看数据包的状态。
- en: 3\. Increment error statistics if there are any problems in the transmission.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 如果传输中出现任何问题，增加错误统计数据。
- en: 4\. Increment statistics of successful transmitted packets.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 增加成功传输数据包的统计数据。
- en: Start the transmission queue allowing the kernel to call the driver's `ndo_start_xmit`
    method again, by means of the `netif_wake_queue()` function.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动传输队列，允许内核通过`netif_wake_queue()`函数再次调用驱动程序的`ndo_start_xmit`方法。
- en: 'Let us summarize in a short sample code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个简短的示例代码中总结：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: TX interrupt management will be discussed in the next section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: TX中断管理将在下一节中讨论。
- en: Driver example
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动程序示例
- en: 'We can summarize the concepts discussed above in the following fake Ethernet
    driver:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下虚拟以太网驱动程序中总结上述讨论的概念：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the module is loaded and a device matched, an Ethernet interface will
    be created on the system. First, let us see what the `dmesg` command shows us:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模块加载并匹配设备，系统上将创建一个以太网接口。首先，让我们看看`dmesg`命令给我们显示了什么：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If one runs the `ifconfig -a` command, the interface will be printed on the
    screen:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行`ifconfig -a`命令，接口将显示在屏幕上：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'One can finally configure the interface, assigning an IP address, so that it
    can be shown by using `ifconfig` :'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后可以配置接口，分配IP地址，以便使用`ifconfig`显示：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Status and control
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态和控制
- en: Device control refers to a situation where the kernel needs to change properties
    of the interface on its own initiative, or in response to a user action. It can
    then use either operations exposed through the `struct net_device_ops` structure,
    as discussed, or use another control tool, **ethtool** , which requires the driver
    to introduce a new set of hooks that we will discuss in the next section. Conversely,
    status consists of reporting the state of the interface.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 设备控制是指内核需要自行改变接口属性的情况，或者响应用户操作。它可以使用`struct net_device_ops`结构公开的操作，如前所述，也可以使用另一个控制工具**ethtool**，它需要驱动程序引入一组新的钩子，我们将在下一节中讨论。相反，状态包括报告接口的状态。
- en: The interrupt handler
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断处理程序
- en: 'So far, we have only dealt with two different interrupts: when a new packet
    has arrived or when the transmission of an outgoing packet is complete; but now-a-days
    hardware interfaces are becoming smart, and they able to report their status either
    for sanity purposes, or for data transfer purposes. This way, network interfaces
    can also generate interrupts to signal errors, link status changes, and so on.
    They should all be handled in the interrupt handler.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理了两种不同的中断：当新数据包到达或传出数据包的传输完成时；但现在硬件接口变得更加智能，它们能够报告其状态，无论是出于健全性目的还是数据传输目的。这样，网络接口也可以生成中断以信号错误、链路状态更改等。所有这些都应该在中断处理程序中处理。
- en: 'This is what our hwrirq handler looks like:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的hwrirq处理程序的样子：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Because our device sits on an SPI bus, everything is deferred into a `work_struct`
    , which is defined as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的设备位于SPI总线上，所以一切都被延迟到`work_struct`中，其定义如下：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Ethtool support
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ethtool支持
- en: 'Ethtool is a small utility for examining and tuning the settings of Ethernet-based
    network interfaces. With ethtool, it is possible to control various parameters
    like:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Ethtool是一个用于检查和调整基于以太网的网络接口设置的小型实用程序。使用ethtool，可以控制各种参数，如：
- en: Speed
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 速度
- en: Media type
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体类型
- en: Duplex operation
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双工操作
- en: Get/set eeprom register content
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取/设置eeprom寄存器内容
- en: Hardware check summing
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件校验和
- en: Wake-on-LAN, and so on.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唤醒LAN等。
- en: Drivers that need support from ethtool should include `<linux/ethtool.h>` .
    It relies on the `struct ethtool_ops` structure which is the core of this feature,
    and contains a set of methods for ethtool operations support. Most of these methods
    are relatively straightforward; see `include/linux/ethtool.h` for the details.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 需要ethtool支持的驱动程序应包括`<linux/ethtool.h>`。它依赖于`struct ethtool_ops`结构，这是该功能的核心，并包含一组用于ethtool操作支持的方法。其中大多数方法相对直接；有关详细信息，请参阅`include/linux/ethtool.h`。
- en: For ethtool support to be fully part of the driver, the driver should fill an
    `ethtool_ops` structure and assign it to the `.ethtool_ops` field of the `struct`
    `net_device` structure.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使ethtool支持完全成为驱动程序的一部分，驱动程序应填充一个`ethtool_ops`结构并将其分配给`struct` `net_device`结构的`.ethtool_ops`字段。
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The macro `SET_ETHTOOL_OPS` can be used for this purpose too. Do note that your
    ethtool methods can be called even when the interface is down.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 宏`SET_ETHTOOL_OPS`也可以用于此目的。请注意，即使接口处于关闭状态，也可以调用您的ethtool方法。
- en: 'For example, the following drivers implement ethtool support:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下驱动程序实现了ethtool支持：
- en: '`drivers/net/ethernet/microchip/enc28j60.c`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drivers/net/ethernet/microchip/enc28j60.c`'
- en: '`drivers/net/ethernet/freescale/fec.c`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drivers/net/ethernet/freescale/fec.c`'
- en: '`drivers/net/usb/rtl8150.c`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drivers/net/usb/rtl8150.c`'
- en: Driver methods
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驱动程序方法
- en: 'Driver methods are the `probe()` and `remove()` functions. They are responsible
    for (un)registering the network device with the kernel. The driver has to provide
    its functionalities to the kernel through the device methods by means of the `struct`
    `net_device` structure. These are the operations that can be performed on the
    network interface:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序的方法是`probe()`和`remove()`函数。它们负责（取消）在内核中注册网络设备。驱动程序必须通过`struct` `net_device`结构的设备方法向内核提供其功能。这些是可以在网络接口上执行的操作：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding are the operations that most drivers implement.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上述是大多数驱动程序实现的操作。
- en: The probe function
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探测函数
- en: The `probe` function is quite basic, and only needs to perform a device's early
    `init` , and then register our network device with the kernel.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`probe`函数非常基本，只需要执行设备的早期`init`，然后在内核中注册我们的网络设备。'
- en: 'In other words, the `probe` function has to:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`probe`函数必须：
- en: Allocate the network device along with its private data using the `alloc_etherdev()`
    function (helped by `netdev_priv()` ).
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`alloc_etherdev()`函数（通过`netdev_priv()`辅助）分配网络设备及其私有数据。
- en: Initialize private data fields (mutexes, spinlock, work_queue, and so on). One
    should use work queues (and mutexes) in case the device sits on a bus whose access
    functions may sleep (SPI for example). In this case, the hwirq just has to acknowledge
    the kernel code, and schedule the work that will perform operations on the device.
    The alternative solution is to use threaded IRQs. If the device is MMIO, one can
    use spinlock to protect critical sections and get rid of work queues.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化私有数据字段（互斥锁，自旋锁，工作队列等）。如果设备位于可能休眠的总线上（例如SPI），应使用工作队列（和互斥锁）。在这种情况下，hwirq只需确认内核代码，并安排将在设备上执行操作的工作。另一种解决方案是使用线程化的中断。如果设备是MMIO，可以使用自旋锁来保护关键部分并摆脱工作队列。
- en: Initialize bus-specific parameters and functionalities (SPI, USB, PCI, and so
    on).
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化总线特定的参数和功能（SPI，USB，PCI等）。
- en: Request and map resources (I/O memory, DMA channel, IRQ).
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求和映射资源（I/O内存，DMA通道，中断请求）。
- en: If necessary, generate a random MAC address and assign it to the device.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如有必要，生成一个随机MAC地址并分配给设备。
- en: 'Fill the mandatories (or useful) netdev properties: `if_port` , `irq` , `netdev_ops`
    , `ethtool_ops` , and so on.'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充必需的（或有用的）netdev属性：`if_port`，`irq`，`netdev_ops`，`ethtool_ops`等。
- en: Put the device into the low-power state (the `open()` function will remove it
    from this mode).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将设备置于低功耗状态（`open()`函数将其从此模式中移除）。
- en: Finally, call `register_netdev()` on the device.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在设备上调用`register_netdev()`。
- en: 'With an SPI network device, the `probe` function can look like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SPI网络设备，`probe`函数可能如下所示：
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This whole chapter is heavily inspired by the enc28j60 from Microchip. You may
    have a look into its code in `drivers/net/ethernet/microchip/enc28j60.c` .
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 整个章节受到了Microchip的enc28j60的启发。您可以在`drivers/net/ethernet/microchip/enc28j60.c`中查看其代码。
- en: The `register_netdev()` function takes a completed `struct net_device` object
    and adds it to the kernel interfaces; 0 is returned on success and a negative
    error code is returned on failure. The `struct net_device` object should be stored
    in your bus device structure so that it can be accessed later. That being said,
    if your net device is part of a global private structure, it is that structure
    that you should register.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`register_netdev()`函数接受一个完成的`struct net_device`对象并将其添加到内核接口；成功时返回0，失败时返回负错误代码。`struct
    net_device`对象应存储在总线设备结构中，以便以后可以访问它。也就是说，如果您的网络设备是全局私有结构的一部分，那么您应该注册该结构。'
- en: Do note that the duplicate device name may lead to registration failure.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，重复的设备名称可能导致注册失败。
- en: Module unloading
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块卸载
- en: 'This is the cleaning function, which relies on two functions. Our driver release
    function could look like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是清理函数，它依赖于两个函数。我们的驱动程序释放函数可能如下所示：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `unregister_netdev()` function removes the interface from the system, and
    the kernel can no longer call its methods; `free_netdev()` frees the memory used
    by the `struct net_device` structure itself along with the memory allocated for
    private data, as well as any internally allocated memory related to the network
    device. Do note that you should never free `netdev->priv` by yourself.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`unregister_netdev()`函数从系统中移除接口，内核将不再调用其方法；`free_netdev()`释放了`struct net_device`结构本身使用的内存，以及为私有数据分配的内存，以及与网络设备相关的任何内部分配的内存。请注意，您不应该自行释放`netdev->priv`。'
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has explained everything needed to write an NIC device driver.
    Even if the chapter relies on a network interface sitting on an SPI bus, the principle
    is the same for USB or PCI network interfaces. One can also use the dummy driver
    provided for testing purposes. After this chapter, it is obvious NIC drivers will
    no longer be mystery to you.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经解释了编写NIC设备驱动程序所需的一切。即使本章依赖于位于SPI总线上的网络接口，但对于USB或PCI网络接口，原理是相同的。人们也可以使用提供用于测试目的的虚拟驱动程序。在本章之后，显然NIC驱动程序将不再是神秘的。
