["```\n(switchboard number + room number) <=> private (real) phone number \n```", "```\n      .------------------------. 0xFFFFFFFF \n      |                        | (4 GB) \n      |    Kernel addresses    | \n      |                        | \n      |                        | \n      .------------------------.CONFIG_PAGE_OFFSET \n      |                        |(x86: 0xC0000000, ARM: 0x80000000) \n      |                        | \n      |                        | \n      |  User space addresses  | \n      |                        | \n      |                        | \n      |                        | \n      |                        | \n      '------------------------' 00000000 \n```", "```\n                                           Physical mem \n       Process address space    +------> +------------+ \n                                |        |  3200 M    | \n                                |        |            | \n    4 GB +---------------+ <-----+        |  HIGH MEM  | \n        |     128 MB    |                |            | \n        +---------------+ <---------+    |            | \n        +---------------+ <------+  |    |            |  \n        |     896 MB    |        |  +--> +------------+          \n    3 GB +---------------+ <--+   +-----> +------------+  \n        |               |    |           |   896 MB   | LOW MEM \n        |     /////     |    +---------> +------------+ \n        |               |      \n    0 GB +---------------+ \n```", "```\nstruct task_struct{ \n    [...] \n    struct mm_struct *mm, *active_mm; \n    [...] \n} \n```", "```\nstruct mm_struct { \n        struct vm_area_struct *mmap; \n        struct rb_root mm_rb; \n        unsigned long mmap_base; \n        unsigned long task_size; \n        unsigned long highest_vm_end; \n        pgd_t * pgd; \n        atomic_t mm_users; \n        atomic_t mm_count; \n        atomic_long_t nr_ptes; \n#if CONFIG_PGTABLE_LEVELS > 2 \n        atomic_long_t nr_pmds; \n#endif \n        int map_count; \n        spinlock_t page_table_lock; \n        struct rw_semaphore mmap_sem; \n        unsigned long hiwater_rss; \n        unsigned long hiwater_vm; \n        unsigned long total_vm; \n        unsigned long locked_vm; \n        unsigned long pinned_vm; \n        unsigned long data_vm; \n        unsigned long exec_vm; \n        unsigned long stack_vm; \n        unsigned long def_flags; \n        unsigned long start_code, end_code, start_data, end_data; \n        unsigned long start_brk, brk, start_stack; \n        unsigned long arg_start, arg_end, env_start, env_end; \n\n        /* Architecture-specific MM context */ \n        mm_context_t context; \n\n        unsigned long flags; \n        struct core_state *core_state; \n#ifdef CONFIG_MEMCG \n        /* \n         * \"owner\" points to a task that is regarded as the canonical \n         * user/owner of this mm. All of the following must be true in \n         * order for it to be changed: \n         * \n         * current == mm->owner \n         * current->mm != mm \n         * new_owner->mm == mm \n         * new_owner->alloc_lock is held \n         */ \n        struct task_struct __rcu *owner; \n#endif \n        struct user_namespace *user_ns; \n        /* store ref to file /proc/<pid>/exe symlink points to */ \n        struct file __rcu *exe_file; \n}; \n```", "```\n# cat /proc/1073/maps\n\n00400000-00403000 r-xp 00000000 b3:04 6438 /usr/sbin/net-listener\n\n00602000-00603000 rw-p 00002000 b3:04 6438 /usr/sbin/net-listener\n\n00603000-00624000 rw-p 00000000 00:00 0 [heap]\n\n7f0eebe4d000-7f0eebe54000 r-xp 00000000 b3:04 11717 /usr/lib/libffi.so.6.0.4\n\n7f0eebe54000-7f0eec054000 ---p 00007000 b3:04 11717 /usr/lib/libffi.so.6.0.4\n\n7f0eec054000-7f0eec055000 rw-p 00007000 b3:04 11717 /usr/lib/libffi.so.6.0.4\n\n7f0eec055000-7f0eec069000 r-xp 00000000 b3:04 21629 /lib/libresolv-2.22.so\n\n7f0eec069000-7f0eec268000 ---p 00014000 b3:04 21629 /lib/libresolv-2.22.so\n\n[...]\n\n7f0eee1e7000-7f0eee1e8000 rw-s 00000000 00:12 12532 /dev/shm/sem.thk-mcp-231016-sema\n\n[...]\n\n```", "```\n* Look up the first VMA which satisfies  addr < vm_end,  NULL if none. */ \nextern struct vm_area_struct * find_vma(struct mm_struct * mm, unsigned long addr); \n```", "```\nstruct vm_area_struct *vma = find_vma(task->mm, 0x13000); \nif (vma == NULL) /* Not found ? */ \n    return -EFAULT; \nif (0x13000 >= vma->vm_end) /* Beyond the end of returned VMA ? */ \n    return -EFAULT; \n```", "```\n#define PAGE_SHIFT      12 \n#ifdef __ASSEMBLY__ \n#define PAGE_SIZE       (1 << PAGE_SHIFT) \n#else \n#define PAGE_SIZE       (1UL << PAGE_SHIFT) \n#endif \n```", "```\nstruct page *alloc_pages(gfp_t mask, unsigned int order) \n#define alloc_page(gfp_mask) alloc_pages(gfp_mask, 0) \n```", "```\nvoid __free_pages(struct page *page, unsigned int order); \n```", "```\nunsigned long __get_free_pages(gfp_t mask, unsigned int order); \nunsigned long get_zeroed_page(gfp_t mask); \n```", "```\nfree_pages(unsigned long addr, unsigned int order); \n```", "```\nunsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order) \n{ \n   struct page *page; \n\n   /* \n    * __get_free_pages() returns a 32-bit address, which cannot represent \n    * a highmem page \n    */ \n   VM_BUG_ON((gfp_mask & __GFP_HIGHMEM) != 0); \n\n   page = alloc_pages(gfp_mask, order); \n   if (!page) \n         return 0; \n   return (unsigned long) page_address(page); \n} \n```", "```\nstruct page *virt_to_page(void *kaddr); \nvoid *page_to_virt(struct page *pg) \n```", "```\nvoid *page_address(const struct page *page) \n```", "```\nunsigned long get_zeroed_page(unsigned int gfp_mask) \n{ \n    struct page * page; \n\n    page = alloc_pages(gfp_mask, 0); \n    if (page) { \n        void *address = page_address(page); \n        clear_page(address); \n        return (unsigned long) address; \n    } \n    return 0; \n} \n```", "```\nvoid *kmalloc(size_t size, int flags); \n```", "```\nvoid kfree(const void *ptr) \n```", "```\n#include <linux/init.h> \n#include <linux/module.h> \n#include <linux/slab.h> \n#include <linux/mm.h> \n\nMODULE_LICENSE(\"GPL\");  \nMODULE_AUTHOR(\"John Madieu\"); \n\nvoid *ptr;  \n\nstatic int  \nalloc_init(void)  \n{ \n    size_t size = 1024; /* allocate 1024 bytes */  \n    ptr = kmalloc(size,GFP_KERNEL);  \n    if(!ptr) { \n        /* handle error */ \n        pr_err(\"memory allocation failed\\n\");  \n        return -ENOMEM;  \n    }  \n    else  \n        pr_info(\"Memory allocated successfully\\n\");  \n    return 0; \n} \n\nstatic void alloc_exit(void) \n{ \n    kfree(ptr);  \n    pr_info(\"Memory freed\\n\");  \n}  \n\nmodule_init(alloc_init);  \nmodule_exit(alloc_exit); \n```", "```\nvoid kzalloc(size_t size, gfp_t flags); \nvoid kzfree(const void *p); \nvoid *kcalloc(size_t n, size_t size, gfp_t flags); \nvoid *krealloc(const void *p, size_t new_size, gfp_t flags); \n```", "```\n#include <linux/vmalloc.h> \n```", "```\nvoid *vmalloc(unsigned long size); \nvoid *vzalloc(unsigned long size); \nvoid vfree( void *addr); \n```", "```\n#include<linux/init.h> \n#include<linux/module.h> \n#include <linux/vmalloc.h> \n\nvoid *ptr; \nstatic int alloc_init(void) \n{ \n    unsigned long size = 8192; \n    ptr = vmalloc(size); \n    if(!ptr) \n    { \n        /* handle error */ \n        printk(\"memory allocation failed\\n\"); \n        return -ENOMEM; \n    } \n    else \n        pr_info(\"Memory allocated successfully\\n\"); \n    return 0; \n\n} \n\nstatic void my_vmalloc_exit(void) /* function called at the time of rmmod */ \n{ \n    vfree(ptr); //free the allocated memory \n    printk(\"Memory freed\\n\"); \n} \nmodule_init(my_vmalloc_init); \nmodule_exit(my_vmalloc_exit); \n\nMODULE_LICENSE(\"GPL\"); \nMODULE_AUTHOR(\"john Madieu, john.madieu@gmail.com\"); \n```", "```\nstruct resource *request_region(unsigned long start, \n                                 unsigned long len, char *name); \nvoid release_region(unsigned long start, unsigned long len); \n```", "```\nu8 inb(unsigned long addr) \nu16 inw(unsigned long addr) \nu32 inl(unsigned long addr) \n```", "```\nvoid outb(u8 b, unsigned long addr) \nvoid outw(u16 b, unsigned long addr) \nvoid outl(u32 b, unsigned long addr) \n```", "```\nstruct resource* request_mem_region(unsigned long start, \n                                    unsigned long len, char *name) \nvoid release_mem_region(unsigned long start, unsigned long len) \n```", "```\nvoid __iomem *ioremap(unsigned long phys_add, unsigned long size) \nvoid iounmap(void __iomem *addr) \n```", "```\nunsigned int ioread8(void __iomem *addr); \nunsigned int ioread16(void __iomem *addr); \nunsigned int ioread32(void __iomem *addr); \nvoid iowrite8(u8 value, void __iomem *addr); \nvoid iowrite16(u16 value, void __iomem *addr); \nvoid iowrite32(u32 value, void __iomem *addr); \n```", "```\nsudo apt-get install sparse\n\n```", "```\nmake -C $KPATH M=$PWD C=1 modules\n\n```", "```\nmake C=1\n\n```", "```\n#define __iomem    __attribute__((noderef, address_space(2))) \n```", "```\nvoid __iomem *ioremap(phys_addr_t offset, unsigned long size); \n```", "```\n#define BASE_ADDR 0x20E01F8 \nvoid * _addrTX = ioremap(BASE_ADDR, 8); \n```", "```\n warning: incorrect type in initializer (different address spaces)\n\n expected void *_addrTX\n\n got void [noderef] <asn:2>*\n\n```", "```\nu32 __iomem* _addrTX = ioremap(BASE_ADDR, 8); \n*_addrTX = 0xAABBCCDD; /* bad. No dereference */ \npr_info(\"%x\\n\", *_addrTX); /* bad. No dereference */ \n```", "```\nWarning: dereference of noderef expression\n\n```", "```\nvoid __iomem* _addrTX = ioremap(BASE_ADDR, 8); \niowrite32(0xAABBCCDD, _addrTX); \npr_info(\"%x\\n\", ioread32(_addrTX)); \n```", "```\nvoid *kmap(struct page *page); \n```", "```\nvoid kunmap(struct page *page); \n```", "```\nvoid *kmap(struct page *page) \n{ \n   BUG_ON(in_interrupt()); \n   if (!PageHighMem(page)) \n         return page_address(page); \n\n   return kmap_high(page); \n} \n```", "```\nint remap_pfn_range(struct vm_area_struct *vma, unsigned long addr, \n             unsigned long pfn, unsigned long size, pgprot_t flags); \n```", "```\nint io_remap_page_range(struct vm_area_struct *vma, \n                        unsigned long virt_addr, \n                        unsigned long phys_addr, \n                        unsigned long size, pgprot_t prot); \n```", "```\n mmap (void *addr, size_t len, int prot, \n       int flags, int fd, ff_t offset); \n```", "```\nint (*mmap) (struct file *filp, struct vm_area_struct *vma); \n```", "```\nvoid *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); \n```", "```\nIf length <= PAGE_SIZE \n    vma->vm_end - vma->vm_start == PAGE_SIZE. \nIf PAGE_SIZE < length <= (N * PAGE_SIZE) \n             vma->vm_end - vma->vm_start == (N * PAGE_SIZE) \n```", "```\nunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;  \nif (offset >= buffer_size) \n         return -EINVAL; \n```", "```\nunsigned long size = vma->vm_end - vma->vm_start; \nif (size > (buffer_size - offset)) \n   return -EINVAL; \n```", "```\nunsigned long pfn; \n/* we can use page_to_pfn on the struct page structure \n * returned by virt_to_page \n */ \n/* pfn = page_to_pfn (virt_to_page (buffer + offset)); */ \n\n/* Or make PAGE_SHIFT bits right-shift on the physical \n * address returned by virt_to_phys \n */       \npfn = virt_to_phys(buffer + offset) >> PAGE_SHIFT; \n```", "```\nif (remap_pfn_range(vma, vma->vm_start, pfn, size, vma->vm_page_prot)) { \n   return -EAGAIN; \n} \nreturn 0; \n```", "```\nstatic const struct file_operations my_fops = { \n   .owner = THIS_MODULE, \n   [...] \n   .mmap = my_mmap, \n   [...] \n}; \n```", "```\n    cat /proc/meminfo | grep Dirty\n\n```", "```\nvoid *kmalloc(size_t size, gfp_t flags) \nvoid * devm_kmalloc(struct device *dev, size_t size, gfp_t gfp) \n```", "```\nret = request_irq(irq, my_isr, 0, my_name, my_data); \nif(ret) { \n    dev_err(dev, \"Failed to register IRQ.\\n\"); \n    ret = -ENODEV; \n    goto failed_register_irq; /* Unroll */ \n} \n```", "```\nret = devm_request_irq(dev, irq, my_isr, 0, my_name, my_data); \nif(ret) { \n    dev_err(dev, \"Failed to register IRQ.\\n\"); \n    return -ENODEV; /* Automatic unroll */ \n} \n```"]