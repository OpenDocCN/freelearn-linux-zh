- en: Chapter 9. Securing Your Network
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。保护您的网络
- en: Security vulnerabilities and the miscreants who take advantage of them are everywhere.
    With the millions of lines of code contained within software running on a typical
    network, it's statistically impossible to ever be 100 percent secure from all
    possible threats. However, a good network administrator pays attention to current
    trends in network security and takes all the possible precautions to help ensure
    the network is as secure as it possibly can be. In this chapter, we will take
    a look at some of the things that can be done to increase the security of your
    network.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 安全漏洞和利用它们的不法分子无处不在。在典型网络上运行的软件中包含数百万行代码，从统计上讲，要想百分之百地安全防范所有可能的威胁是不可能的。然而，一个好的网络管理员会关注网络安全的当前趋势，并采取一切可能的预防措施，以确保网络尽可能安全。在本章中，我们将探讨一些可以增加网络安全性的方法。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Limiting the attack surface
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制攻击面
- en: Securing SSH
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护SSH
- en: Configuring the iptables firewall
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置iptables防火墙
- en: Protecting system services with fail2ban
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用fail2ban保护系统服务
- en: Understanding SELinux
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解SELinux
- en: Configuring Apache to utilize SSL
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Apache以利用SSL
- en: Deploying security updates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署安全更新
- en: Limiting the attack surface
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制攻击面
- en: The most important rule of network security is limiting your attack surface.
    In a nutshell, this means that the less software you have installed and/or the
    less services you have running, the less it can be used against you. If that wasn't
    bad enough, in some cases an unpatched flaw in server software could allow a miscreant
    to use your server to attack someone else. By limiting the number of packages
    in use on your system, you're lowering the possibility of something bad happening.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 网络安全的最重要规则是限制攻击面。简而言之，这意味着您安装的软件越少和/或运行的服务越少，就越不容易被利用。更糟糕的是，在某些情况下，服务器软件中的未修补漏洞可能允许不法分子使用您的服务器来攻击其他人。通过限制系统中使用的软件包的数量，您降低了发生不良事件的可能性。
- en: This sounds simple enough, and it is, but it's important to keep in mind that
    this isn't just a matter of installing only what you need. Many Linux distributions
    ship with software that you may never need to use. This isn't just true for servers
    either. Even your end-user workstations could have unnecessary services running
    that would be a treasure trove for an attacker to use. One common example of this
    is having a **Mail Transfer Agent** (**MTA**) running on your system. It's surprising
    that many Linux distributions ship with an MTA running by default. Unless you
    specifically need an MTA (for example, you have scripts installed that need to
    send e-mail messages to administrators), you should remove these packages from
    your systems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很简单，而且确实如此，但重要的是要记住，这不仅仅是安装您需要的软件。许多Linux发行版都附带了您可能永远不需要使用的软件。这不仅适用于服务器。即使您的最终用户工作站可能运行着不必要的服务，这对攻击者来说将是一个宝藏。一个常见的例子是在系统上运行**邮件传输代理**（MTA）。令人惊讶的是，许多Linux发行版默认情况下都运行着MTA。除非您明确需要MTA（例如，您安装了需要向管理员发送电子邮件的脚本），否则应该从系统中删除这些软件包。
- en: When rolling out Linux on any network, the first thing you should do is find
    out what is installed and what is running, and then decide what to turn off and/or
    uninstall. This is what is referred to as limiting your attack surface. It is
    true that Linux is one of most secure systems there are, but nothing will help
    you if you aren't keeping an eye on what is running and listening for connections
    on your network. For the remainder of this section, I'll go over a few ways in
    which you can limit your attack surface.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何网络上部署Linux时，您应该首先找出安装了什么以及正在运行什么，然后决定关闭和/或卸载什么。这就是所谓的限制攻击面。的确，Linux是最安全的系统之一，但如果您不注意系统上正在运行和监听网络连接的内容，那么什么也帮不了您。在本节的其余部分，我将介绍一些限制攻击面的方法。
- en: 'First, let''s print out a list of all the packages installed on our system.
    This will allow us to see what is installed, and then we can remove anything that
    stands out that we''re sure we don''t need. This list will likely be huge, as
    it will include everything; I do mean everything—even the libraries and various
    packages that allow our system to function. You definitely won''t understand what
    each of them packages are for, but as you learn more about Linux, you''ll make
    more sense of these and know what needs to be removed. For example, I know to
    remove `exim` or `postfix` packages from all of my installations, as I don''t
    personally need them anywhere. Since you won''t understand the purpose of all
    of the packages installed on your system, I recommend you to take a quick look
    and remove the ones you know for sure you don''t need. To print a list of installed
    packages, run one of the following commands:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们打印出系统上安装的所有软件包的列表。这将使我们能够看到安装了什么，然后我们可以删除任何突出显示的我们确定不需要的东西。这个列表可能会很长，因为它将包括一切;
    我是指一切-甚至是让我们的系统运行的库和各种软件包。您肯定不会理解每个软件包的用途，但随着您对Linux的了解越来越多，您将更加理解这些内容，并知道需要删除什么。例如，我知道要从所有的安装中删除`exim`或`postfix`软件包，因为我个人在任何地方都不需要它们。由于您不会理解系统上安装的所有软件包的用途，我建议您快速查看并删除您确定不需要的软件包。要打印已安装软件包的列表，请运行以下命令之一：
- en: 'For Debian-based sytems, execute the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于Debian的系统，请执行以下命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For CentOS systems, execute the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CentOS系统，请执行以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In either case, you'll end up with a text file called `installed_packages.txt`
    in your current working directory. This text file will contain a list of all the
    packages installed on your system. Feel free to check it and see if anything stands
    out as something that you can remove. In addition, this file serves as a handy
    backup as well. If you ever need to decommission a server and set up a new one
    with a similar purpose, you can compare the packages from one server to another
    to ensure the proper packages are installed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，您最终都会在当前工作目录中得到一个名为`installed_packages.txt`的文本文件。这个文本文件将包含您系统上安装的所有软件包的列表。请随意检查它，看看是否有什么可以删除的内容。此外，这个文件也可以作为一个方便的备份。如果您需要停用一个服务器并设置一个具有类似目的的新服务器，您可以将一个服务器的软件包与另一个服务器进行比较，以确保正确的软件包已安装。
- en: 'Another neat trick to find out what is running on your system is with the `netstat`
    command. While we''ll discuss this command further in [Chapter 10](ch10.html "Chapter 10. Troubleshooting
    Network Issues"), *Troubleshooting Network Issues*, let''s try this out now:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个发现系统上正在运行的内容的好方法是使用`netstat`命令。虽然我们将在[第10章](ch10.html "第10章。故障排除网络问题")中进一步讨论这个命令，*故障排除网络问题*，现在让我们试一试：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You should see a list of services running on the local computer that are actually
    listening for network connections. These should be given major attention, as anything
    listening for outside connections is a possible point of entry into your system.
    If you see something here that's listening for connections and you don't need
    it to be, remove the package. You can always disable a service, but removing the
    underlying package is better as they can't be accidentally started. Packages can
    always be reinstalled if you find that you actually did need them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到正在本地计算机上运行的实际上正在监听网络连接的服务列表。这些应该受到重视，因为任何监听外部连接的东西都可能是系统的入口点。如果您看到这里有一些正在监听连接而您不需要它，可以删除该软件包。您可以随时禁用服务，但删除底层软件包更好，因为它们不会被意外启动。如果您发现实际上确实需要它们，软件包总是可以重新安装的。
- en: '![Limiting the attack surface](img/B03919_09_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![限制攻击面](img/B03919_09_01.jpg)'
- en: The netstat command, listing running and listening services
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: netstat命令，列出正在运行和监听的服务。
- en: In my case, I can see that I have Syncthing and Chrome listening for outside
    connections. This is expected. But in a production environment, such as a server,
    some things to watch out for would be the Apache web server (which would be a
    concern if the server is not actually a web server), postfix, or any file transfer
    utilities that shouldn't be installed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，我可以看到Syncthing和Chrome正在监听外部连接。这是预期的。但在生产环境中，比如服务器，需要注意的是Apache web服务器（如果服务器实际上不是web服务器的话），postfix，或者任何不应该安装的文件传输工具。
- en: 'Another useful tool is **ShieldsUP**, it is a service available on the Internet
    by GRC. This is not a Linux-specific tool by any means, but if you''re using Linux
    on your router and want to ensure that you have it configured to be as stealthy
    as possible, this tool can be useful for testing. You can access this tool at
    the following URL:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的工具是**ShieldsUP**，这是GRC在互联网上提供的一项服务。这绝对不是一个特定于Linux的工具，但如果您在路由器上使用Linux，并希望确保它配置为尽可能隐秘，这个工具可以用于测试。您可以在以下网址访问这个工具：
- en: '[https://www.grc.com/shieldsup](https://www.grc.com/shieldsup)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.grc.com/shieldsup](https://www.grc.com/shieldsup)'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please keep in mind that ShieldsUP is an online tool that is not under the control
    or management of the author or publisher. As a result, it's subject to change
    at any time. That being said, this site hasn't changed in quite some time and
    it's a very useful tool.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，ShieldsUP是一个在线工具，不受作者或出版商的控制或管理。因此，它随时可能会发生变化。话虽如此，这个网站已经有一段时间没有变化了，它是一个非常有用的工具。
- en: To use it, click on **Proceed** and then click on **All Service Ports**. This
    service works by checking to see which ports answer to outside requests. If a
    port is open, it will show red, and you should be able to click on it to find
    out more information on what the port is typically used for. This will provide
    you clues on what to disable. In the event that the service doesn't contain information
    regarding a specific port, simply search on Google to look for clues.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，点击**继续**，然后点击**所有服务端口**。这项服务通过检查哪些端口回应外部请求来工作。如果一个端口是打开的，它会显示为红色，您应该能够点击它以了解更多关于该端口通常用于什么的信息。这将为您提供有关禁用什么的线索。如果服务不包含有关特定端口的信息，只需在Google上搜索以寻找线索。
- en: '![Limiting the attack surface](img/B03919_09_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![限制攻击面](img/B03919_09_02.jpg)'
- en: Using ShieldsUP! to see which ports answer from outside requests
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ShieldsUP!查看哪些端口回应外部请求
- en: 'Finally, the `systemctl` command can also be used to see what services are
    currently installed on your machine:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`systemctl`命令也可以用来查看当前安装在您的机器上的服务：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using the list the previous command will print to your terminal, you'll be able
    to see which unit files are currently installed, and their state.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前一个命令打印到终端的列表，您将能够看到当前安装的单元文件及其状态。
- en: That pretty much sums up how to interrogate your system to find out what is
    running. As you learn the typical names of services you may need to do a bit of
    Google search in order to learn the purpose of each service, but it gets easier
    with time. If you're at all unsure about what can be disabled or not, do your
    research first before you actually work on tweaking your running services. In
    the worst case, if you disable a necessary service, your server may not start
    the next time. As always, ensure you have good backups before altering system
    services.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上总结了如何审问您的系统以找出正在运行的内容。随着时间的推移，您会学到典型服务的名称，可能需要进行一些Google搜索以了解每个服务的目的，但随着时间的推移会变得更容易。如果您对可以禁用的内容有任何疑问，请在实际调整运行服务之前先进行研究。最坏的情况是，如果您禁用了一个必要的服务，您的服务器可能在下一次启动时无法启动。如常，在更改系统服务之前，请确保您有良好的备份。
- en: Securing OpenSSH
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Securing OpenSSH
- en: OpenSSH is a wonderful tool; it's the Linux administrator's best friend. It
    saves you the trouble of having to walk into the server room and attach a monitor
    and keyboard in order to perform work on your network. Using any computer connected
    to the same network, you can pretty much do anything you want to as if you were
    standing right in front of the machine. The problem is that an unsecured SSH implementation
    gives miscreants the exact same luxury. Of all the things running on your network,
    SSH is definitely the one you want to give some major attention to.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSH是一个很棒的工具；它是Linux管理员的好朋友。它可以让你不必走进服务器房间，连接显示器和键盘就可以在网络上进行工作。使用连接到同一网络的任何计算机，你几乎可以做任何你想做的事情，就像你站在机器前面一样。问题是，一个不安全的SSH实现给了不法分子同样的便利。在你的网络上运行的所有东西中，SSH绝对是你想要给予重点关注的。
- en: 'The first and most common security tweak for SSH is to use only Version 2 of
    the protocol. To determine which version your Linux installation is using, `grep`
    the `/etc/ssh/sshd_config` file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SSH的第一个和最常见的安全调整是只使用协议的2版本。要确定你的Linux安装使用的是哪个版本，可以使用`grep`命令查看`/etc/ssh/sshd_config`文件：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the answer is 1, you should edit this file and change the line that reads
    **Protocol 1** to **Protocol 2**, and restart SSH. The reason this is important
    is because Protocol 1 has considerably weaker security than Protocol 2\. Thankfully,
    SSH Version 7 and later, now default to Protocol 2, so this isn't as common as
    it used to be. But at the time of this writing, Version 7 was just released and
    hasn't made its way into many distributions yet. Hopefully, by the time you read
    this, your distribution has upgraded to Version 7\. But if not, it's important
    that you ensure all of your servers utilize only Protocol 2 for SSH. You can achieve
    this by changing the relevant line in your `sshd_conf` file and then restarting
    the SSH service.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果答案是1，你应该编辑这个文件并将**Protocol 1**改为**Protocol 2**，然后重新启动SSH。这很重要的原因是因为协议1的安全性比协议2要弱得多。值得庆幸的是，SSH
    7版本及更高版本现在默认使用协议2，所以这不像以前那样常见。但在写这篇文章的时候，7版本刚刚发布，并且还没有在许多发行版中得到应用。希望到你读到这篇文章的时候，你的发行版已经升级到7版本。但如果没有，你需要确保你的所有服务器只使用SSH的协议2。你可以通过更改`sshd_conf`文件中的相关行，然后重新启动SSH服务来实现这一点。
- en: 'Another worthwhile change to SSH is changing the port it listens on. By default,
    SSH is listening on **Port 22**. You can confirm this with the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: SSH的另一个值得改变的地方是改变它监听的端口。默认情况下，SSH监听在**端口22**上。你可以使用以下命令确认：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Unless you changed it, the answer will be 22\. Since 22 is the default port
    for SSH, that's the port everyone (including the bad guys) expects it to be on.
    In the `/etc/ssh/sshd_config` file, there will be an option for the port near
    the top. If you change it to something else, it will be less obvious to outsiders.
    However, I don't want to lure you into a false sense of security here. Changing
    the port for SSH isn't a magical barrier against intrusion via SSH. In a targeted
    attack, a miscreant will scan every port on your server, so if they are determined,
    they'll figure out what port you changed it to. The reason why I recommend this
    change is because it's a very easy change to make. It requires only a few seconds
    to change your SSH port, and anything you can do to make your network less obvious
    to outsiders is a welcome change. The only time changing the SSH port can become
    a potential problem is if users of your network expect it to be on port 22\. As
    long as you communicate this change to everyone, it should be a non-issue.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你改变了它，答案将是22。由于22是SSH的默认端口，这是每个人（包括坏人）都期望的端口。在`/etc/ssh/sshd_config`文件中，顶部附近将有一个端口选项。如果你将它改成其他端口，对外部人员来说就不那么明显了。然而，我不想让你产生一种虚假的安全感。改变SSH端口并不能奇迹般地阻止通过SSH的入侵。在有针对性的攻击中，不法分子会扫描你服务器上的每个端口，所以如果他们决心的话，他们会找出你将端口改成了什么。我建议这种改变的原因是因为这是一个非常容易的改变。只需要几秒钟就可以改变你的SSH端口，任何你可以做的事情来使你的网络对外部人员不那么明显都是受欢迎的。改变SSH端口可能成为潜在问题的唯一时机是如果你的网络用户期望它在22端口。只要你向每个人传达这个改变，这应该不是问题。
- en: 'In order to connect to a server with a non-standard SSH port, use the `-p`
    flag:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了连接到一个非标准的SSH端口的服务器，使用`-p`标志：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also designate the port while using `scp` as well:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在使用`scp`时指定端口：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the `-P` parameter is uppercase in `scp` but not in the `ssh` command.
    This was intentional. The reason for this is because the lowercase `-p` option
    in `scp` was already taken, and it's used for preserving modification times when
    transferring files.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`-P`参数在`scp`命令中是大写的，但在`ssh`命令中不是。这是有意为之的。原因是因为在`scp`中小写的`-p`选项已经被使用了，它用于在传输文件时保留修改时间。
- en: 'If you can''t seem to get into the habit of requesting a different port for
    SSH, create an alias for it. However, this can be a problem if some of your hosts
    are still using port 22, so you would only use this alias if everything you connect
    to is on the same port. In the following example, we can set an alias to `ssh`
    to force it to always use port `63456`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你似乎无法养成请求SSH的不同端口的习惯，可以为它创建一个别名。然而，如果你的一些主机仍在使用端口22，这可能会成为一个问题，所以只有当你连接的所有东西都在同一个端口上时才使用这个别名。在下面的例子中，我们可以设置一个别名为`ssh`，强制它总是使用端口`63456`：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another very important change to your SSH configuration is to not allow root
    login. Under no circumstances should root login be allowed on any Linux server
    for any reason. If your configuration requires you to log in to a server as root
    via SSH, correct your configuration. To check to see if root login is enabled
    via SSH, run the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你的SSH配置的另一个非常重要的改变是不允许root登录。在任何情况下，都不应该允许在任何Linux服务器上以root身份登录。如果你的配置要求你通过SSH以root身份登录到服务器，那么你需要更正你的配置。要检查SSH是否允许root登录，运行以下命令：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If root login is enabled, disable it by correcting the following configuration
    line in `/etc/ssh/sshd_config`. However, make sure you are able to access the
    server via SSH with a normal user account first; otherwise, you''ll be locked
    out. The following configuration line in `sshd_config` will disallow root login:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了root登录，则通过更正`/etc/ssh/sshd_config`中的以下配置行来禁用它。但是，请确保您能够首先使用普通用户帐户通过SSH访问服务器；否则，您将被锁定。`sshd_config`中的以下配置行将禁止root登录：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As always, restart `ssh` after you make any changes to its configuration. Don't
    worry about restarting SSH while you are using it, current connections will not
    be disrupted.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，在对其配置进行任何更改后重新启动`ssh`。不要担心在使用SSH时重新启动它，当前连接不会中断。
- en: 'For Debian systems, execute the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Debian系统，请执行以下命令：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For CentOS systems, execute the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CentOS系统，请执行以下命令：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Another practice worth implementing is locking SSH down to only allow connections
    via specific users and/or groups. By default, any user with an account on the
    system is available via SSH. To change this, add the following line to the very
    bottom of the configuration file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得实施的做法是将SSH限制为仅允许通过特定用户和/或组进行连接。默认情况下，系统上的任何用户都可以通过SSH访问。要更改此设置，请将以下行添加到配置文件的最底部：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you have more than one user, you can add multiple users on the same line:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个用户，您可以在同一行上添加多个用户：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also allow specific groups. First, create a group that you''ll use
    for SSH access:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以允许特定的组。首先，创建一个用于SSH访问的组：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, add one or more users to the group:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将一个或多个用户添加到组中：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, add the following line to the bottom of your SSH configuration file.
    After you restart SSH, access will be restricted to those that are a member of
    this group. Each time you need to grant SSH access to someone, all you'll need
    to do is add their user ID to this group and you won't have to restart the `sshd_config`
    configuration file each time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在SSH配置文件的底部添加以下行。重新启动SSH后，访问将受到限制，只有属于该组的人才能访问。每次需要向某人授予SSH访问权限时，您只需要将其用户ID添加到该组中，而无需每次都重新启动`sshd_config`配置文件。
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, the most secure option for SSH is to not allow password-based authentication
    at all. Instead, users can use a public/private key pair for access. With this
    method, passwords are not transmitted over the network and those without a private
    key that matches an accepted public key are not allowed access. This is the practice
    that I recommend to everyone. On the down-side, it also comes with the most administrative
    overhead. To implement this change, each user will need to generate a key pair
    for SSH with the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，SSH的最安全选项是根本不允许基于密码的身份验证。相反，用户可以使用公钥/私钥对进行访问。使用这种方法，密码不会通过网络传输，而那些没有与接受的公钥匹配的私钥的用户将不被允许访问。这是我向每个人推荐的做法。不利的一面是，它也带来了最多的管理开销。要实施此更改，每个用户都需要使用以下命令为SSH生成密钥对：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You'll be asked several questions, most of which you can leave as the default.
    For the passphrase, come up with something unique and ensure it's not the same
    as your password. You can leave it blank if you don't want to be asked for a passphrase
    while making connections, but I recommend creating one.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被要求回答几个问题，其中大多数问题您可以保持默认设置。对于密码短语，请想出一个独特的短语，并确保它与您的密码不同。如果您不想在进行连接时被要求输入密码短语，可以将其留空，但我建议创建一个密码短语。
- en: 'Next, the easiest way to configure a server to allow you to connect via a key
    is to import that key into the server, *before* you disable password authentication.
    To do that, use a variation of the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，配置服务器以允许您通过密钥连接的最简单方法是在禁用密码身份验证之前将该密钥导入服务器。要做到这一点，请使用以下变体：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At this point, you'll be asked to log in to the server via your normal password.
    Then, the next time you connect to it, you will default to using the key pair
    you came up with and you'll be asked for your passphrase if you created one.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您将被要求使用普通密码登录服务器。然后，下次连接时，您将默认使用您想出的密钥对，并且如果您创建了密码短语，系统将要求您输入密码短语。
- en: 'After all of your users have generated their key and imported it into the server,
    you can implement this change. Look for the line in the SSH configuration file
    that looks similar to the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有用户生成并将其密钥导入服务器后，您可以实施此更改。在SSH配置文件中查找类似以下内容的行：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Simply change that option to no, restart SSH, and you should be all set. The
    reason that this works is because when you copy over your SSH key using the `ssh-copy-id`
    command, what it's actually doing is copying the contents of your public key (`~/.ssh/id_rsa.pub`)
    on your local machine to the end of the `~/.ssh/authorized_keys` file on the remote
    machine. With password authentication disabled, SSH will check that the key listed
    there matches your private key (`~/.ssh/id_rsa`) and then allow you access.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将该选项更改为no，重新启动SSH，您就可以了。这样做的原因是，当您使用`ssh-copy-id`命令复制SSH密钥时，它实际上是在将本地计算机上的公钥(`~/.ssh/id_rsa.pub`)的内容复制到远程计算机上的`~/.ssh/authorized_keys`文件的末尾。禁用密码身份验证后，SSH将检查那里列出的密钥是否与您的私钥(`~/.ssh/id_rsa`)匹配，然后允许您访问。
- en: With these tweaks, your SSH implementation should be reasonably secure. It certainly
    won't help you if you use weak passwords or passphrases, but these are the general
    steps you should take on all servers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些调整，您的SSH实现应该是相当安全的。如果您使用弱密码或密码短语，它肯定不会帮助您，但这些是您应该在所有服务器上采取的一般步骤。
- en: Configuring the iptables firewall
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置iptables防火墙
- en: By default, Linux includes a firewall, **iptables**. This firewall should automatically
    be available on most (if not all) flavors of Linux. In this little activity, we'll
    set up a firewall on our Linux system. This should work fine regardless of which
    of the major distributions you use, but I'll call out anything that may be distribution
    specific. Before we get started though, I'll recommend that you play with this
    on a test machine, such as a VM or something you have physical access to. If you're
    using SSH, you may get disconnected when we enable the firewall, though I'll provide
    these steps in an order that hopefully, shouldn't drop your connection. Having
    a dedicated test machine to play around with is a good idea anyway.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Linux包括一个防火墙**iptables**。这个防火墙应该在大多数（如果不是所有）Linux发行版上自动可用。在这个小活动中，我们将在我们的Linux系统上设置一个防火墙。无论你使用哪个主要的发行版，这应该都可以正常工作，但我会指出可能是特定于发行版的任何内容。不过，在我们开始之前，我建议你在测试机器上玩一下，比如虚拟机或者你可以物理访问的东西。如果你使用SSH，在我们启用防火墙时可能会断开连接，尽管我会按照一个不会断开你连接的顺序提供这些步骤。无论如何，有一个专门的测试机器来玩耍是一个好主意。
- en: 'With that out of the way, let''s get started. Unfortunately, by default, `iptables`
    is wide open. It''s so open, in fact, that it blocks nothing. To see this for
    yourself, issue `iptables -L` as root. Your output will probably look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，让我们开始吧。不幸的是，默认情况下，`iptables`是完全开放的。事实上，它是如此开放，以至于什么都不阻止。要自己看一下，以root身份发出`iptables
    -L`。你的输出可能看起来像这样：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What you''re seeing here are three **chains** of `iptables`, each corresponding
    to input, output, and forwarding. If you haven''t configured this yet (and your
    distribution doesn''t offer any default configuration), you''ll likely see the
    default policy for each being `ACCEPT`, which means exactly what it sounds like:
    it allows everything.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到的是`iptables`的三个**链**，分别对应输入、输出和转发。如果你还没有配置这个（并且你的发行版没有提供任何默认配置），你可能会看到每个的默认策略都是`ACCEPT`，这意味着它允许一切。
- en: 'One of the first rules I like to implement is to allow for SSH:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢实施的第一条规则之一是允许SSH：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this command, we''re appending a new rule (`-A`) to our `INPUT` chain
    on the interface `eth0` using TCP and accepting traffic from `dport` (destination
    port) `22`. If you changed your SSH port earlier, be sure to adjust this command
    accordingly. Also, if your interface is not `eth0`, change that too. Of course,
    our firewall allows anything anyway, since we''ve never changed the default policy.
    If you recall, it accepts everything by default. Let''s change that with the following
    commands:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个命令，我们在接口`eth0`上的`INPUT`链上附加了一个新规则（`-A`），使用TCP并接受来自`dport`（目标端口）`22`的流量。如果你之前更改了SSH端口，请确保相应地调整这个命令。另外，如果你的接口不是`eth0`，也要进行更改。当然，我们的防火墙无论如何都允许任何东西，因为我们从未更改过默认策略。如果你还记得，它默认接受一切。让我们用以下命令来改变这一点：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, if we view the output of `iptables -L`, we should see the default policy
    is `DROP` on everything and SSH is allowed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们查看`iptables -L`的输出，我们应该看到默认策略是在所有内容上都是`DROP`，并且允许SSH。
- en: 'However, there''s one problem—we can''t do anything else. We''re no longer
    able to install packages. Actually, we''re unable to do anything on the Internet
    at all. For example, try pinging Google. You won''t be able to. If you''ve followed
    along, we set our default policy to `DROP` and it really does mean `DROP`. No
    traffic is currently allowed to or from the server unless it''s SSH. In order
    to restore networking, we''ll need to allow a few more things. First, let''s allow
    DNS, which utilizes port `53`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题——我们无法做其他任何事情。我们已经无法安装软件包。实际上，我们根本无法在互联网上做任何事情。例如，尝试ping谷歌。你做不到。如果你跟着做了，我们将默认策略设置为“DROP”，这确实意味着“DROP”。除了SSH之外，目前不允许服务器之间或服务器之外的任何流量。为了恢复网络连接，我们需要允许更多的东西。首先，让我们允许DNS，它使用端口`53`：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we're allowing port `53`, but only for our internal `10.10.96.0/22` network.
    Note that DNS uses UDP, so we included `-p udp` into our command. It goes without
    saying, but adjust the `10.10.96.0/22` portion for whatever your network scheme
    is.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们允许端口`53`，但只允许我们内部的`10.10.96.0/22`网络。请注意，DNS使用UDP，所以我们在命令中包含了`-p udp`。不用说，但根据你的网络方案调整`10.10.96.0/22`部分。
- en: At this point, we're still a bit more locked down on our system than we would
    like. For example, we have DNS now, but we wouldn't be able to browse the Internet
    without allowing ports `80` and `443`. Let's take care of that next.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们的系统比我们想要的还要严格一些。例如，我们现在有了DNS，但如果不允许端口`80`和`443`，我们将无法浏览互联网。让我们接下来处理这个问题。
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'From this point forward, you should be able to browse the Internet on this
    machine and access it via SSH, though other ports and services shouldn''t be accessible.
    If the machine in question is a router, you might want to configure port forwarding
    as well. Here''s an example of port forwarding:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，你应该能够在这台机器上浏览互联网并通过SSH访问它，尽管其他端口和服务不应该是可访问的。如果问题机器是一个路由器，你可能也想配置端口转发。这是一个端口转发的例子：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, we're forwarding traffic received on port `65254` to `10.10.96.10`.
    This example is useful if you have something like SSH available on a port other
    than `22` and would like to be able to access a computer (in this case, `10.10.96.10`)
    using that port. The server will now forward traffic it receives on that port
    to that computer. This uses the concept of `PREROUTING`, which handles incoming
    packets and is able to reassign them via NAT. In this case, we're using the firewall
    to create a NAT rule to send this traffic to the appropriate place.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将在端口`65254`上接收的流量转发到`10.10.96.10`。如果你有类似SSH的东西在除`22`之外的端口上可用，并且想要能够使用该端口访问一台计算机（在这种情况下是`10.10.96.10`），这个例子就很有用。服务器现在将在该端口接收到的流量转发到该计算机。这使用了`PREROUTING`的概念，它处理传入的数据包，并能够通过NAT重新分配它们。在这种情况下，我们使用防火墙创建一个NAT规则，将这些流量发送到适当的位置。
- en: 'If the server you''re setting up this firewall on is destined to become a router,
    you''ll want to enable routing between interfaces as well. We took care of that
    from a Linux level in the last chapter, but since we configured the firewall to
    `DROP` everything by default, we can no longer do that. To continue to route between
    interfaces, we''ll need to enable routing within our firewall as well. To do that,
    we can use the following commands:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要在设置此防火墙的服务器上成为路由器，您还需要启用接口之间的路由。我们在上一章中已经从Linux级别处理了这个问题，但由于我们将防火墙配置为默认情况下`DROP`一切，我们不能再这样做了。为了继续在接口之间进行路由，我们还需要在我们的防火墙中启用路由。为此，我们可以使用以下命令：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the previous command, we're allowing routing between interfaces `eth0` and
    `eth1`. Adjust the previous commands to fit your distribution's network interface
    naming scheme so that it will fit your environment. We're also using `POSTROUTING`,
    which in terms of `iptables` is another word for outgoing traffic.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个命令中，我们允许在`eth0`和`eth1`接口之间进行路由。调整前面的命令以适应您的发行版网络接口命名方案，以使其适应您的环境。我们还使用`POSTROUTING`，在`iptables`方面，这是出站流量的另一个说法。
- en: 'Another change that may be useful is allowing ping. With our configuration
    so far, ICMP ping packets are blocked. If you ping your server, you won''t get
    a response. We can re-enable ping responses via the following commands. Be sure
    to change the IP address to match that of your server:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有用的另一个更改是允许ping。根据我们目前的配置，ICMP ping数据包被阻止。如果您ping您的服务器，您将得不到响应。我们可以通过以下命令重新启用ping响应。请确保更改IP地址以匹配您的服务器：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If for some reason you''ve made a mistake or if you''d like to start this activity
    again, issue the following commands to flush (reset) the `iptables` firewall:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因您犯了错误，或者您想重新开始这个活动，可以使用以下命令来刷新（重置）`iptables`防火墙：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note that this won''t undo your default policy, which you can explicitly set
    to `ACCEPT` if you''d like to undo everything we''ve done so far. We can set each
    table to it''s default (`ACCEPT`) with the following commands:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这不会撤消您的默认策略，如果您希望撤消到目前为止所做的一切，可以将默认策略明确设置为`ACCEPT`。我们可以使用以下命令将每个表设置为其默认值（`ACCEPT`）：
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We choose `DROP` for our default policy because in this mode, the firewall does
    not respond to the sending host with a status when rejecting traffic. In a sense,
    it's almost as if packets are sent to an endless black hole when a policy is set
    to `DROP`. This is a good thing, because miscreants can use the response they
    get back from the server to better target their attacks. It's best for them to
    get no response at all.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择`DROP`作为默认策略，因为在这种模式下，防火墙在拒绝流量时不会向发送主机发送状态响应。在某种意义上，当策略设置为`DROP`时，数据包被发送到一个无尽的黑洞，几乎就好像没有响应。这是一件好事，因为坏人可以利用从服务器收到的响应更好地针对他们的攻击。最好是他们根本得不到任何响应。
- en: 'So, feel free to play around with `iptables` until you''ve gotten to a point
    where you are able to perform all the tasks that you normally were able to perform.
    Once you have a working and well-tested firewall, it''s time to save the configuration.
    Otherwise, all this hard work would be lost when you reboot. Use the following
    command to save your firewall configuration:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，随意使用`iptables`进行尝试，直到您能够执行通常能够执行的所有任务为止。一旦您有一个工作正常且经过充分测试的防火墙，就该保存配置了。否则，当您重新启动时，所有这些辛苦工作都会丢失。使用以下命令保存您的防火墙配置：
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To import these rules, we can use the following command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入这些规则，我们可以使用以下命令：
- en: '[PRE32]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You'll probably want these changes restored automatically every time the system
    boots. Both Debian and CentOS have their own ways to accomplish this. Here are
    the methods in which to save the rules.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望这些更改在系统启动时自动恢复。Debian和CentOS都有各自的方法来实现这一点。以下是保存规则的方法。
- en: 'In Debian, first save the rules as we did before:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian中，首先保存规则，就像我们之前做的那样：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, create the following file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建以下文件：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Inside that file, place the following text:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在该文件中，放入以下文本：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In CentOS, execute the following command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS中，执行以下命令：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: From this point onwards, your firewall rules should persist each time you reboot
    the server.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，每次重新启动服务器时，您的防火墙规则应该会持久保存。
- en: Protecting system services with fail2ban
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fail2ban保护系统服务
- en: A firewall is a great thing to have but it doesn't do much to protect services
    that are allowed. A firewall only goes as far as to allow or disallow access.
    But once access is allowed to a service, its security depends on its configuration
    and whether or not there are any security vulnerabilities. A service worth installing
    is **fail2ban**, which is a neat little tool that runs in the background and watches
    your logs for anything out of the ordinary, such as multiple failures to access
    a service. The most popular use of `fail2ban` is to protect SSH from those attempting
    to brute force it. In a lot of ways, `fail2ban` is the successor to **denyhosts**,
    which pretty much did the same thing. But `fail2ban` is able to protect more services
    than just SSH, another example being Apache.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 防火墙是一件很好的东西，但它对允许的服务的保护作用不大。防火墙只允许或不允许访问。但一旦允许访问某项服务，其安全性取决于其配置以及是否存在任何安全漏洞。一个值得安装的服务是**fail2ban**，这是一个很好的小工具，可以在后台运行，并监视您的日志是否有异常情况，比如多次尝试访问某项服务失败。`fail2ban`最常见的用途是保护SSH免受尝试暴力破解的攻击。在很多方面，`fail2ban`是**denyhosts**的继任者，它们的功能基本相同。但`fail2ban`能够保护的服务不仅仅是SSH，另一个例子是Apache。
- en: 'When `fail2ban` sees that a source is attempting to access a service and is
    failing, it will set up a firewall rule on the fly to block that service from
    your server. To begin, install the `fail2ban` package on your server. In Debian
    systems, this is available in the default repositories. CentOS systems will find
    this package in the `epel` repository that we''ve set up in the past. Once installed,
    enable and start it with `systemctl` if it isn''t already using the following
    command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当`fail2ban`发现某个来源正在尝试访问服务并失败时，它将即时设置防火墙规则来阻止该服务从您的服务器访问。首先，在服务器上安装`fail2ban`软件包。在Debian系统中，这在默认存储库中可用。CentOS系统将在我们过去设置的`epel`存储库中找到此软件包。安装后，如果尚未使用以下命令启用并启动它：使用`systemctl`。
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Inside the `/etc/fail2ban` directory, you should see the main configuration
    file, `jail.conf`. It''s a good idea to copy this configuration to a local copy,
    because if you edit `jail.conf`, it''s always possible a package upgrade could
    overwrite it. The `fail2ban` service will read `jail.local` if it finds it and
    will not overwrite it if it were to be upgraded:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/etc/fail2ban`目录中，您应该看到主配置文件`jail.conf`。将此配置复制到本地副本是个好主意，因为如果您编辑`jail.conf`，可能会被包升级覆盖。如果`fail2ban`服务找到`jail.local`，它将读取它，并且如果被升级，不会覆盖它：
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that we have a local copy, we can now configure it to protect our services.
    Let''s start with SSH. To do so, open `/etc/fail2ban/jail.local` in a text editor
    and look for the `[ssh]` section. On my system, this section looks like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了本地副本，我们可以配置它来保护我们的服务。让我们从SSH开始。为此，请在文本编辑器中打开`/etc/fail2ban/jail.local`，并查找`[ssh]`部分。在我的系统中，这个部分看起来是这样的：
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, the configuration is fairly self-explanatory. The first line
    enables the SSH jail, it filters for traffic using `sshd`, and it looks in `/var/log/auth.log`
    for messages related to SSH. Although you've probably already noticed, we need
    to call out the SSH port in this file. If you stick with port 22, you can leave
    the relevant portions of the file as they are in your configuration. But if you
    changed your SSH port to something else, be sure to adjust accordingly. There
    are two places to place the port for SSH, the first on line three and the second
    on line five.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，配置相当简单易懂。第一行启用了SSH监狱，它使用`sshd`过滤流量，并在`/var/log/auth.log`中查找与SSH相关的消息。虽然您可能已经注意到，我们需要在此文件中调用SSH端口。如果您坚持使用端口22，可以将文件中相关部分保持原样。但是，如果您将SSH端口更改为其他端口，请务必相应调整。SSH的端口有两个地方需要设置，第一个在第三行，第二个在第五行。
- en: 'Now that we have our configuration in place, we can restart `fail2ban` in order
    to start securing SSH for us:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置好了，我们可以重新启动`fail2ban`来开始为我们保护SSH：
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Take a look at the configuration file for other services that we may want to
    enable. An example could be Apache for our web server or even NGINX if you have
    that set up. The default configuration file contains a great deal of examples
    you can use. To use one, simply change `enabled = false` to `enable = true` and
    then restart `fail2ban`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 查看其他我们可能想要启用的服务的配置文件。例如，我们的Web服务器可能是Apache，甚至如果您已经设置了NGINX。默认配置文件包含许多示例供您使用。要使用其中一个，只需将`enabled
    = false`更改为`enable = true`，然后重新启动`fail2ban`。
- en: Understanding SELinux
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解SELinux
- en: '**Security Enhanced Linux** (**SELinux**) is a kernel module intended to increase
    security by enforcing the **Mandatory Access Control**. This concept gives you
    the control to ensure that users and applications are only able to access the
    things that they absolutely need to in order to complete the tasks they are designated
    to perform. While firewalls help protect the system against intrusion from the
    outside, SELinux helps prevent resources on the inside from doing things that
    they aren''t supposed to be doing. This may sound vague, because it is how SELinux
    is used, and how you can benefit from it depends solely on how you implement it.
    Want to prevent a user from making a very private file world-readable? Sure, you
    can do that. Perhaps ensure Apache cannot access files outside of `/var/www`?
    You can do that too. Without SELinux, you would be relying solely on group and
    user permissions. SELinux helps you put more granular security restrictions in
    place by adding an additional layer of security to the mix.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全增强型Linux**（**SELinux**）是一个旨在通过执行**强制访问控制**来增加安全性的内核模块。这个概念让您可以控制确保用户和应用程序只能访问他们绝对需要完成任务的东西。虽然防火墙有助于保护系统免受外部入侵，但SELinux有助于防止内部资源执行不应该执行的操作。这可能听起来模糊，因为这是SELinux的用法，您如何从中受益完全取决于您如何实施它。想要防止用户使一个非常私人的文件变为可全球读取？当然可以。也许确保Apache无法访问`/var/www`之外的文件？也可以。没有SELinux，您将完全依赖于组和用户权限。SELinux通过添加额外的安全层来帮助您实施更精细的安全限制。'
- en: 'SELinux is not exclusive to any one distribution, though you''ll most commonly
    find it installed on Red Hat, Fedora, and CentOS systems. In a system such as
    Debian, you would need to install `selinux` if you wish to utilize it. Unfortunately,
    at the time of this writing, SELinux doesn''t function properly in Debian due
    to the fact that a required package (`selinux-policy-default`) contained bugs
    that weren''t fixed in time for Jessie''s release, so this package was omitted
    in the official Debian 8.x "Jessie" repositories. However, the process for installing
    SELinux in Debian (should this package become available after publication) comes
    down to installing that package along with `selinux-basics`. After those packages
    are installed, you should be able to finish your SELinux installations by running
    the following commands and rebooting the system:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux不是任何一个发行版的专属功能，尽管您最常见的是在Red Hat、Fedora和CentOS系统上安装它。在Debian等系统中，如果您希望使用它，您需要安装`selinux`。不幸的是，在撰写本文时，由于一个必需的包（`selinux-policy-default`）包含的错误没有及时修复，SELinux在Debian中无法正常工作，因此这个包被省略在官方的Debian
    8.x“Jessie”存储库中。然而，在Debian中安装SELinux的过程（如果此包在发布后变得可用）就是安装该包以及`selinux-basics`。安装这些包后，您应该能够通过运行以下命令并重新启动系统来完成SELinux的安装：
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: SELinux works with policies to determine whether or not an action is allowed.
    Policies are created with tools that exist in something known as the **SELinux
    userspace**, and the actual checking is done at the kernel layer. Each distribution
    that implements SELinux by default, will typically ship with a tested and supported
    set of policies, such that all the services you would reasonably expect to work
    will function as they should. Without a default set of policies, configuring SELinux
    by hand can be a real pain (if it even starts). As mentioned earlier, Debian's
    policies package is currently not a part of the main repository, so enabling SELinux
    in Debian may be chaotic at this time. In the case of CentOS though, everything
    you need to utilize SELinux will be working out of the box. In fact, unless you've
    disabled it, you're already using it!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux通过策略来确定是否允许某个操作。策略是使用存在于所谓的**SELinux用户空间**中的工具创建的，实际检查是在内核层进行的。每个默认实现SELinux的发行版通常都会配备经过测试和支持的一套策略，以确保您合理期望的所有服务都能正常运行。如果没有默认的策略集，手动配置SELinux可能会非常麻烦（如果它甚至能启动的话）。正如前面提到的，目前Debian的策略包不是主要存储库的一部分，因此在Debian中启用SELinux可能会很混乱。不过，在CentOS的情况下，您需要使用SELinux的所有内容都将可以直接使用。实际上，除非您已禁用它，否则您已经在使用它！
- en: There are three modes of operation for SELinux and those are **enforcing**,
    **permissive**, and **disabled**. By default, most installations I've seen lately
    are set to `enforcing`, but you can see which of these three yours is set to,
    by executing `sestatus`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux有三种操作模式，分别是**强制执行**，**宽松**和**禁用**。默认情况下，我最近看到的大多数安装都设置为`强制执行`，但您可以通过执行`sestatus`来查看您的设置是哪种模式。
- en: '![Understanding SELinux](img/B03919_09_03.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![理解SELinux](img/B03919_09_03.jpg)'
- en: Output from sestatus on CentOS
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS上的sestatus输出
- en: With `enforcing`, SELinux is configured with its policy enabled and will act
    on anything that goes against that policy. If a violation occurs, SELinux will
    prevent the action and log it. In `permissive` mode, actions are not blocked but
    everything is still logged so you can audit your server yourself later. The `disabled`
    state is self-explanatory; in that mode, SELinux will not block or log anything
    while it is disabled. It's quite common that administrators will simply disable
    SELinux, assuming it to be too much of a burden if it gets in the way of a legitimate
    use case. But disabling SELinux isn't recommended unless you absolutely have to,
    as it's another layer of security that you could otherwise be benefiting from.
    At the very least, you may want to benefit from the `permissive` mode so that
    you would have more information available within your logs should something suspicious
    start to happen on your server.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`强制执行`模式下，SELinux配置为启用其策略，并将对违反策略的任何操作进行处理。如果发生违规行为，SELinux将阻止该操作并记录下来。在`宽松`模式下，操作不会被阻止，但仍会记录下来，以便您稍后自行审计服务器。`禁用`状态是不言而喻的；在该模式下，SELinux将在禁用时不会阻止或记录任何操作。管理员通常会简单地禁用SELinux，认为它会在合法用例受阻时成为负担。但除非您绝对必须这样做，否则不建议禁用SELinux，因为它是您可以从中受益的另一层安全性。至少，您可能希望从`宽松`模式中受益，以便在服务器上出现可疑情况时可以获得更多信息。
- en: To change the mode of operation for SELinux on the fly, use the `setenforce`
    command. For example, use `setenforce Enforcing` to change the mode to `enforcing`.
    Changes made via `setenforce` are not permanent. Once you reboot your machine,
    the mode will switch back to its default or whatever you have configured in its
    configuration file. The configuration file to change the mode permanently is the
    /`etc/sysconfig/selinux` file in Red Hat style distributions, or `/etc/selinux/config`
    in Debian. This file allows you to configure the two main settings to determine
    how SELinux is configured, the **mode** and the **type**. To change either permanently,
    update this file and restart the server. We already discussed the mode (it can
    be set to `enforcing`, `permissive`, or `disabled`), and the type is where we
    configure which policy we would like SELinux to use. This can be set to `targeted`,
    `minimum`, or multi-level security (`mls`).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行时更改SELinux的操作模式，请使用`setenforce`命令。例如，使用`setenforce Enforcing`将模式更改为`强制执行`。通过`setenforce`进行的更改不是永久的。一旦重新启动计算机，模式将切换回默认模式或您在配置文件中配置的模式。永久更改模式的配置文件是Red
    Hat风格发行版中的`/etc/sysconfig/selinux`文件，或者在Debian中是`/etc/selinux/config`。该文件允许您配置两个主要设置来确定SELinux的配置方式，即**模式**和**类型**。要永久更改任一设置，请更新此文件并重新启动服务器。我们已经讨论了模式（可以设置为`强制执行`，`宽松`或`禁用`），而类型是我们配置SELinux要使用的策略。这可以设置为`targeted`，`minimum`或多级安全（`mls`）。
- en: In regards to updating the policy, `targeted` is the process that is in use
    by default on new installations (at least when it comes to Red Hat/CentOS), and
    it is fully supported by Red Hat. With this policy, every process runs in a type
    called `unconfined_t`, which is actually not restricted at all. Instead, processes
    will run under the Linux native **DAC** (short for **Discretionary Access Control**),
    which sandboxes them from other processes to help contain anything that may have
    been compromised. **MLS**, or **Multi-Level Security**, applies a sensitivity
    rating to objects, designated by `s0`, when it's enabled. (By executing `sestatus`,
    you can see whether or not MLS is enabled). We'll see some examples of context
    output shortly. With the minimum type, only processes we explicitly select will
    be safeguarded.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 关于更新策略，`targeted`是默认情况下新安装（至少在涉及Red Hat/CentOS时）使用的进程。它得到Red Hat的全面支持。在这个策略中，每个进程都在一个称为`unconfined_t`的类型下运行，实际上根本没有受到限制。相反，进程将在Linux本地的**DAC**（**Discretionary
    Access Control**的缩写）下运行，这使它们与其他进程隔离，以帮助遏制可能被破坏的任何内容。**MLS**，或**多级安全**，在启用时会为对象分配一个敏感度等级，由`s0`指定。（通过执行`sestatus`，您可以看到MLS是否已启用）。我们很快将看到一些上下文输出的示例。在最小类型中，只有我们明确选择的进程才会受到保护。
- en: 'Every resource in a SELinux-enabled system contains a **label**, which is how
    SELinux identifies a resource and understands how to police it. You can see these
    labels (also known as contexts) yourself by using the `-Z` parameter with one
    or more commands, such as `ls`, `id`, or `ps`. This special parameter is available
    to these commands only when a system is configured to utilize SELinux, and it
    allows you to view the context as part of the normal output. For example, you
    can use the `-Z` parameter with the `ls` command on a SELinux system and you would
    see an output like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux启用系统中的每个资源都包含一个**标签**，这是SELinux识别资源并了解如何监管它的方式。您可以通过使用`-Z`参数与一个或多个命令（如`ls`、`id`或`ps`）来自己查看这些标签（也称为上下文）。这个特殊的参数仅在系统配置为使用SELinux时才对这些命令可用，并且它允许您查看上下文作为正常输出的一部分。例如，您可以在SELinux系统上使用`ls`命令与`-Z`参数，您会看到如下输出：
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Normally, the output of the `ls` command would contain fields such as the modification
    date and size when viewing output of a command such as `ls`. But again, the `-Z`
    parameter is special. It implies that you would like to see the output of the
    command as it pertains to SELinux, rather than the output you would normally get.
    You can also try it with `id` (`id -Z`), and `ps` (`ps auxZ`) to have the output
    of those commands show you their SELinux context as well.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`ls`命令的输出会包含诸如修改日期和大小等字段，当查看`ls`命令的输出时。但是，`-Z`参数是特殊的。它意味着您想要查看命令的输出与SELinux相关，而不是通常获得的输出。您还可以尝试使用`id`（`id
    -Z`）和`ps`（`ps auxZ`）来查看这些命令的输出，以及它们的SELinux上下文。
- en: 'The label contains multiple fields. In the output from the `ls` command I pasted,
    we can see the fields `unconfined_u`, `object_r`, `admin_home_t`, and `s0`. To
    better understand this, look at the last few characters of each. The `_u` designates
    the user, `_r` designates the role, and `_t` represents the type. Therefore, we
    can see from the previous output that the file called `myfile` has a user context
    of `unconfined_u`; it''s assigned the role of `object_r` and a type of `admin_home_t`.
    Let''s look at another example. In the output of `ps auxZ` on my CentOS system,
    I see the following line for my SSH session:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 标签包含多个字段。在我粘贴的`ls`命令的输出中，我们可以看到字段`unconfined_u`、`object_r`、`admin_home_t`和`s0`。为了更好地理解这一点，看一下每个字段的最后几个字符。`_u`表示用户，`_r`表示角色，`_t`表示类型。因此，我们可以从之前的输出中看到，名为`myfile`的文件具有`unconfined_u`的用户上下文；它被分配了`object_r`的角色和`admin_home_t`的类型。让我们看另一个例子。在我的CentOS系统上，通过`ps
    auxZ`命令的输出中，我看到了我的SSH会话的以下行：
- en: '[PRE43]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Looking at the beginning of the line, we again have context for user, role,
    and type. In this case, each are named unconfined, but we can tell which is what
    by the last two characters.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 再看一下行的开头，我们再次看到用户、角色和类型的上下文。在这种情况下，每个都被命名为unconfined，但我们可以通过最后两个字符来判断哪个是哪个。
- en: The type is the most important part of the output, because this is how SELinux
    does its enforcing. Given the type, SELinux knows how to restrict (or not to restrict)
    the object. In the first example, we have `admin_home_t`, and we have `unconfined_t`
    in the second example. From this, we can gather that SELinux isn't enforcing anything
    with my SSH session (`unconfined_t`) but has a specific policy in place for my
    home directory, which is where the output of the file came from. Another context
    we have seen in the example output is the role, designated by a suffix `_r`. When
    applying a role, SELinux is able to group together various contexts and apply
    them to a user object with one call. This makes it easier to designate what users
    are able to do and how they're allowed to interact with other objects.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是输出中最重要的部分，因为这是SELinux执行其强制执行的方式。根据类型，SELinux知道如何限制（或不限制）对象。在第一个示例中，我们有`admin_home_t`，在第二个示例中我们有`unconfined_t`。从中我们可以得知，SELinux并未对我的SSH会话（`unconfined_t`）执行任何强制，但对我的主目录有一个特定的策略，这也是文件输出的来源。我们在示例输出中看到的另一个上下文是角色，由后缀`_r`指定。应用角色时，SELinux能够将各种上下文组合在一起，并一次性将它们应用到用户对象上。这使得更容易指定用户能够做什么以及他们如何与其他对象进行交互。
- en: 'There are several commands that can be used to relabel the context information
    of an object. To begin, there''s the `chcon` command. The `chcon` command is used
    with the `-t` parameter, which designates the type you would like to change the
    object to, followed by the name of the object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个命令可以用来重新标记对象的上下文信息。首先是`chcon`命令。`chcon`命令使用`-t`参数，该参数指定您要将对象更改为的类型，后跟对象的名称：
- en: '[PRE44]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Using `-R`, we tell the `chcon` command to make the changes recursively, which
    is great if you're changing the context of a directory. In addition, you can also
    use `-r` if you'd like to change the role instead of the type. If you make a mistake
    or you'd like to revert your changes, `restorecon` does exactly that. The `restorecon`
    command will revert an object to its default state, as defined in its policy.
    Another command for managing SELinux is `semanage`. With this command, we can
    make permanent changes to how objects are treated and labeled. It's important
    to note that changes via `chcon` might not always persist. While changes via `chcon`
    will likely survive a reboot, they persist if the filesystem gets relabeled. The
    `semanage` command allows us to make these changes more permanent. Using `semanage`,
    we can make changes to file contexts, user mappings, as well as user contexts.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-R`，我们告诉`chcon`命令递归地进行更改，这对于更改目录的上下文非常有用。此外，如果您想更改角色而不是类型，还可以使用`-r`。如果您犯了错误或者想要恢复更改，`restorecon`正是这样做的。`restorecon`命令将对象恢复到其策略中定义的默认状态。管理SELinux的另一个命令是`semanage`。使用此命令，我们可以对对象的处理和标记进行永久更改。需要注意的是，通过`chcon`进行的更改可能并不总是持久的。虽然通过`chcon`进行的更改可能会在重启后生存，但如果文件系统被重新标记，它们将持久存在。`semanage`命令允许我们使这些更改更加持久。使用`semanage`，我们可以更改文件上下文、用户映射以及用户上下文。
- en: 'First, an example of mapping user `jdoe` to the `sysadm_u` SELinux user:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将用户`jdoe`映射到`sysadm_u` SELinux用户的示例：
- en: '[PRE45]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, here''s an example of using `fcontext` along with `semanage`, we can
    change what types file objects belong to:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是使用`fcontext`和`semanage`的示例，我们可以更改文件对象所属的类型：
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: See the man pages for `semanage` for even more examples. SELinux is a large
    subject matter for which entire books have been written. A complete walkthrough
    of SELinux would take multiple chapters, but the information given here should
    serve as an adequate primer. When implemented properly, it can greatly enhance
    security on your servers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`semanage`的man页面，了解更多示例。SELinux是一个庞大的主题，已经有整本书专门写了。完整的SELinux演练需要多个章节，但这里提供的信息应该足够作为一个适当的入门。当正确实施时，它可以极大地增强服务器的安全性。
- en: Configuring Apache to utilize SSL
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Apache以利用SSL
- en: The [Chapter 7](ch07.html "Chapter 7. Hosting HTTP Content via Apache"), *Hosting
    HTTP Content via Apache* was all about Apache. There, we walked through how to
    get it running and configured in order to host a site on our network. But if we
    were to create a site that would potentially host personally identifiable information,
    we would want to make sure that we use proper security measures in order to protect
    that information. Using **SSL** certificates for our site allows it to be accessed
    over secure port 443, thus enhancing security. Utilizing SSL isn't the only measure
    we can make in order to increase security of our web server, but it's definitely
    a start.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章。通过Apache托管HTTP内容") *通过Apache托管HTTP内容*是关于Apache的。在那里，我们介绍了如何运行和配置它以在我们的网络上托管站点。但是，如果我们要创建一个可能托管个人可识别信息的站点，我们需要确保使用适当的安全措施来保护这些信息。为我们的站点使用**SSL**证书可以使其通过安全端口443访问，从而增强安全性。利用SSL并不是我们可以采取的唯一措施来增加我们的Web服务器的安全性，但这绝对是一个开始。'
- en: There are two kinds of certificates we can use. We can create a self-signed
    certificate, or we can register a certificate with a **Certificate Authority**
    (**CA**). The latter is preferred, though if you are only creating a site for
    internal use, it may be too much overhead. The difference is a self-signed certificate
    isn't trusted by any browser, since it wouldn't have come from a known CA. When
    you visit a site with such a certificate, it will complain that the certificate
    of the site isn't valid. This isn't necessarily true, because a self-signed certificate
    can certainly be valid; it's just that the browser has no way of knowing for sure.
    Getting a certificate registered with a CA would alleviate this, but at a cost.
    Registered certificates can be expensive, depending on the scope. The choice is
    yours.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种类型的证书。我们可以创建自签名证书，或者我们可以向**证书颁发机构**（**CA**）注册证书。后者更受青睐，尽管如果您只是为内部使用创建站点，可能会有太多的开销。区别在于自签名证书不受任何浏览器信任，因为它不是来自已知CA的。当您访问具有此类证书的站点时，它会抱怨该站点的证书无效。这并不一定是真的，因为自签名证书肯定是有效的；只是浏览器无法确定。注册CA的证书可以解决这个问题，但需要付出代价。注册证书的价格可能会很昂贵，具体取决于范围。选择权在您手中。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'On Debian systems, make sure you enable SSL with the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian系统上，确保使用以下命令启用SSL：
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: To begin, you would first choose a location on the filesystem of your webserver
    that will host the certificate files. There's no hard rule here, the only requirement
    is that Apache can access it (and preferably, no one else can!). Some good candidates
    include `/etc/apache2/ssl` in Debian and `/etc/httpd/ssl` in CentOS. I put mine
    in `/etc/certs`. Whichever path you choose, change into that directory and then
    we will continue.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要选择Web服务器文件系统上将托管证书文件的位置。这里没有硬性规定，唯一的要求是Apache可以访问它（最好其他人不能！）。一些好的候选包括Debian中的`/etc/apache2/ssl`和CentOS中的`/etc/httpd/ssl`。我把我的放在`/etc/certs`中。无论您选择哪个路径，请切换到该目录，然后我们将继续。
- en: 'If you''ve decided to create a self-signed certificate, you can do so with
    the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定创建自签名证书，可以使用以下命令：
- en: '[PRE48]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As your certificate gets generated, you will be asked for some information
    pertaining to your organization, contact information, and domain. Here''s an example
    of the questions you''ll be asked and some example answers:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成您的证书时，您将被要求提供有关您的组织、联系信息和域的一些信息。以下是您将被问到的问题和一些示例答案：
- en: '`Country name: US`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`国家名称：美国`'
- en: '`State or Province Name: Michigan`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`州或省名称：密歇根`'
- en: '`Locality Name (City): White Lake`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`地点名称（城市）：怀特湖`'
- en: '`Organization Name: My Company`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`组织名称：我的公司`'
- en: '`Organizational Unit Name: IT Dept`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`组织单位名称：IT部门`'
- en: '`Common Name (Fully Qualified Domain Name): myserver.mydomain.com`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`通用名称（完全合格的域名）：myserver.mydomain.com`'
- en: '`Email Address: webmaster@mycompany.com`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`电子邮件地址：webmaster@mycompany.com`'
- en: This will create two files for you in your current working directory, `server.key`
    and `server.crt`. The filenames for those files is arbitrary, you can name them
    whatever you like. Now, we would need to make sure that our web server is able
    to find and use these files.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您当前的工作目录中为您创建两个文件，`server.key`和`server.crt`。这些文件的文件名是任意的，您可以随意命名。现在，我们需要确保我们的Web服务器能够找到并使用这些文件。
- en: 'On Debian web servers, we can do this by editing `/etc/apache2/sites-available/default-ssl.conf`.
    In that file, there will be a section for us to add our directives that will enable
    our keys. Look for a section that has some comments regarding SSL. Within that
    section, add the following lines:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian Web服务器上，我们可以通过编辑`/etc/apache2/sites-available/default-ssl.conf`来实现这一点。在该文件中，将有一个部分供我们添加启用密钥的指令。查找一个有关SSL的注释的部分，在该部分中添加以下行：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In CentOS, we would add the same lines to the `/etc/httpd/conf/httpd.conf`
    file, but with the `SSLEngine on` directive as well. This should go in it''s own
    `VirtualHost` directive, similar to the example that follows. Just be sure to
    change the paths to match how your web server has been set up:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS中，我们将在`/etc/httpd/conf/httpd.conf`文件中添加相同的行，但同时也要加上`SSLEngine on`指令。这应该放在自己的`VirtualHost`指令中，类似于以下示例。只需确保更改路径以匹配您的Web服务器的设置：
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Setting up a signed SSL certificate is similar, but the difference is in how
    you request it. The process entails creating a **Certificate Request** (**CSR**)
    that you will submit to your provider, which will in turn provide you with a signed
    certificate. The end result is the same—the files will end up in the same place.
    You''ll just use the files given to you by your provider after submitting the
    CSR. Let''s begin by creating a CSR, which we will use the `openssl` command to
    generate for us:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 设置签名SSL证书类似，但不同之处在于您请求它的方式。该过程涉及创建一个**证书请求**（**CSR**），您将提交给您的提供商，提供商将为您提供一个签名证书。最终结果是相同的——文件最终会出现在同一个位置。您只需在提交CSR后使用提供商给您的文件。让我们开始创建一个CSR，我们将使用`openssl`命令为我们生成：
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You'll be asked the same question as before, but notice that we're telling `openssl`
    to give us a `.csr`, so we will have a `server.csr` file in our working directory
    we will use to request a key from our CA. After you receive the files from your
    certificate provider, you would just update Apache as we have done earlier.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被问到与之前相同的问题，但请注意，我们告诉`openssl`给我们一个`.csr`，所以我们将在我们的工作目录中有一个`server.csr`文件，我们将使用它来向我们的CA请求一个密钥。在您从证书提供商那里收到文件之后，您只需像之前一样更新Apache。
- en: Deploying security updates
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署安全更新
- en: While it may seem like common sense to those of you more seasoned in security,
    updates for your distribution are released for a reason. In some cases, updates
    serve only to add new features or update software to the latest version. But in
    the case of Enterprise distributions such as CentOS and Debian, these are even
    more important.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于那些在安全方面更有经验的人来说，更新您的分发似乎是常识，但请注意，更新是有原因的。在某些情况下，更新只是为了添加新功能或将软件更新到最新版本。但对于CentOS和Debian等企业分发来说，这些更新甚至更加重要。
- en: This is one of the ways consumer-based distributions and Enterprise distributions
    differ. Distributions such as Ubuntu's non-LTS releases, Linux Mint, and Fedora
    receive more bleeding-edge packages than Enterprise distributions such as CentOS,
    Debian, and Red Hat. This is because the end user typically wants the latest versions
    of their web browser, e-mail client, word processor, or games. This doesn't matter
    much when it comes to the Enterprise. In the Enterprise, security updates are
    critical. While consumer-oriented distributions surely keep up to date with security
    patches on almost an equal level in most cases, these are intermixed with feature
    updates that may impair stability more than help it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是消费者分发和企业分发之间的一种区别。像Ubuntu的非LTS版本、Linux Mint和Fedora这样的分发，比如CentOS、Debian和Red
    Hat这样的企业分发，会收到更多的前沿软件包。这是因为最终用户通常希望他们的网络浏览器、电子邮件客户端、文字处理器或游戏的最新版本。但在企业中，这并不重要。在企业中，安全更新至关重要。虽然面向消费者的分发在大多数情况下肯定会与安全补丁保持同步，但这些补丁会与可能会损害稳定性而不是帮助稳定性的功能更新混合在一起。
- en: In the case of Debian, both styles are actually offered. The main distribution,
    which is known as **Debian stable**, receives little more than security patches.
    Even the default web browser (Iceweasel) isn't updated as often as Firefox would
    be on other platforms. The idea here is that change represents potential breakage.
    Quite a bit of work goes into ensuring that the packages you get in stable are
    tried and true, rather than the latest and greatest. This concept is similar to
    CentOS as well, though its packages generally tend to be older than those in Debian.
    To give you an idea of this, at the time of my writing this chapter, the latest
    Linux kernel is 4.1\. Debian Jessie (the latest "Stable") includes kernel 3.16,
    while CentOS 7 is even older at 3.10\. Not that there's nothing wrong with the
    kernel being old, I just mentioned it to give you an example. Both Red Hat and
    Debian have more bleeding-edge distributions available. **Fedora** is sponsored
    by Red Hat and includes more up to date packages. It's geared toward users who
    prefer to have the latest software. **Debian testing** also includes more up to
    date packages, though it's not nearly as stable as Fedora, facing package breakages
    from time to time. Debian testing is targeted toward those who would like to test
    the next release of Debian, as Debian testing eventually becomes the new Debian
    stable as it matures.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian的情况下，实际上提供了两种风格。被称为**Debian stable**的主要发行版几乎只接收安全补丁。甚至默认的网络浏览器（Iceweasel）的更新频率也不如其他平台上的Firefox。这里的想法是，改变代表着潜在的破坏。为了确保您在稳定版中获得的软件包经过了充分的测试，而不是最新和最好的，付出了相当大的努力。这个概念在CentOS中也是类似的，尽管它的软件包通常比Debian中的软件包更老。举个例子，我写这一章节时，最新的Linux内核是4.1。Debian
    Jessie（最新的“稳定版”）包括内核3.16，而CentOS 7甚至更老，是3.10。老内核并不是什么问题，我只是举个例子。红帽和Debian都有更前沿的发行版可用。**Fedora**由红帽赞助，包括更更新的软件包。它面向那些喜欢拥有最新软件的用户。**Debian
    testing**也包括更更新的软件包，尽管它不像Fedora那样稳定，偶尔会出现软件包破坏。Debian testing面向那些想要测试下一个Debian发布版的人，因为Debian
    testing最终会成为新的Debian稳定版。
- en: For security purposes, installing the latest security updates is critical. It's
    true that Linux is more secure and stable than many other platforms, but regardless
    of how secure the operating system is, at the end of the day, it's only as secure
    as how it's managed. An installation of a Linux distribution that's behind in
    updates is a sitting duck in the case of an exploitable vulnerability being discovered.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全目的，安装最新的安全更新至关重要。Linux确实比许多其他平台更安全和稳定，但无论操作系统有多安全，归根结底，它的安全性取决于管理方式。如果安装了滞后更新的Linux发行版，一旦发现可利用的漏洞，它就会成为易受攻击的目标。
- en: Given the existence of end-user and Enterprise distributions, managing their
    security updates can be a challenge. If your organization uses Linux on both servers
    as well as end-user machines, you may very well employ both types of distributions.
    This is because while CentOS is secure and stable, you're unlikely to be successful
    deploying it to end-user machines. Since the CentOS kernel is a bit older, it
    won't support all the new hardware that's available for end-user workstations
    today. In addition, there aren't as many customizations in place to make it reasonable
    for desktop or laptop use. While it can be done (and many people do), installing
    CentOS on an end-user device is typically an exercise in frustration. For end-user
    machines, you might opt for Ubuntu, Linux Mint, or Fedora instead. But with those,
    you would need to spend more time focusing on which updates are for security and
    which updates are for new features in applications. Depending on the nature of
    the update, you may choose to roll it out differently.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到终端用户和企业发行版的存在，管理它们的安全更新可能是一个挑战。如果您的组织在服务器和终端用户设备上都使用Linux，您很可能会同时使用这两种类型的发行版。这是因为尽管CentOS安全稳定，但您不太可能成功地将其部署到终端用户设备上。由于CentOS内核较老，它不支持今天可用的所有新硬件。此外，也没有太多的定制来使其适合台式机或笔记本电脑使用。虽然可以做到（许多人都这样做），但在终端用户设备上安装CentOS通常是一种令人沮丧的经历。对于终端用户设备，您可能会选择Ubuntu、Linux
    Mint或Fedora。但对于这些发行版，您需要花更多的时间关注哪些更新是安全更新，哪些更新是应用程序的新功能。根据更新的性质，您可能会选择以不同的方式推出更新。
- en: Ideally, in a perfect server room, all updates for servers would be installed
    immediately upon their release, there would never be any issues and everything
    would always go smooth. But in reality, there are challenges in keeping security
    updates current. Perhaps a regression may be present that stops an important application
    from running. Alternatively, perhaps an error in packaging actually breaks the
    RPM database (which is an extremely frustrating experience!), so while updates
    are important, some exercise in caution is needed as well.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，在一个完美的服务器房间里，服务器的所有更新都会在发布后立即安装，永远不会出现任何问题，一切都会顺利进行。但现实中，保持安全更新的挑战很大。也许会出现导致重要应用程序无法运行的回归。或者，也许在打包过程中出现错误，实际上破坏了RPM数据库（这是一种极其令人沮丧的经历！），因此，虽然更新很重要，但也需要谨慎行事。
- en: The best policy, or at least one I've found that works well for me, is creating
    testing servers that can be used to test changes before you roll them out into
    production. In the case of virtual machine servers, you can even clone production
    servers and test updates or other changes on them to see how they will react if
    they were rolled out into production. Then, you can be reasonably confident that
    new updates won't break production servers. To be fair, these types of situations
    rarely happen. But given the flexibility of Linux and the fact that Linux servers
    are easy to clone, there's no reason not to do testing.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的策略，或者至少我发现对我来说效果很好的一个策略，是创建测试服务器，可以用来在将更改推出到生产环境之前进行测试。在虚拟机服务器的情况下，甚至可以克隆生产服务器并在其上测试更新或其他更改，以查看它们在推出到生产环境时会有什么反应。然后，您可以相当有信心地认为新的更新不会破坏生产服务器。公平地说，这些类型的情况很少发生。但鉴于Linux的灵活性以及Linux服务器易于克隆，没有理由不进行测试。
- en: In CentOS systems, you can use the `yum update` command to update all the packages
    on your server. You can use `yum update` along with the name of a package to update
    just that package. In Debian systems, you can use `apt-get update` to refresh
    your sources, and then you can use `apt-get install` with a package name to update
    a package. To update everything, you would update your sources and then run `apt-get
    dist-upgrade`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS系统中，您可以使用`yum update`命令来更新服务器上的所有软件包。您可以使用`yum update`以及软件包名称来仅更新该软件包。在Debian系统中，您可以使用`apt-get
    update`来刷新您的源，然后您可以使用`apt-get install`加上软件包名称来更新软件包。要更新所有内容，您需要更新您的源，然后运行`apt-get
    dist-upgrade`。
- en: In real-world installations, you would probably not update all available packages
    on your server. Instead, one method is to update packages as needed. This requires
    a great deal of research on the part of the administrator, in order to pay attention
    to current security trends and then pick the security updates that impact services
    that are currently being used in production. For Debian and Red Hat based systems,
    there are two handy web sites pertaining to **Common Vulnerabilities and Exposures**
    (**CVE**) that you should have bookmarked.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际安装中，您可能不会更新服务器上的所有可用软件包。相反，一种方法是根据需要更新软件包。这需要管理员进行大量的研究，以关注当前的安全趋势，然后选择影响当前在生产中使用的服务的安全更新。对于基于Debian和Red
    Hat的系统，有两个与**通用漏洞和暴露**（**CVE**）相关的方便的网站，您应该将其加为书签。
- en: 'For Red Hat use the following URL:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Red Hat，请使用以下URL：
- en: '[https://access.redhat.com/security/cve/](https://access.redhat.com/security/cve/)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://access.redhat.com/security/cve/](https://access.redhat.com/security/cve/)'
- en: 'For Debian use the following URL:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Debian，请使用以下URL：
- en: '[https://security-tracker.debian.org/tracker](https://security-tracker.debian.org/tracker)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://security-tracker.debian.org/tracker](https://security-tracker.debian.org/tracker)'
- en: Both sites allow you to view individual CVE reports, which will inform you about
    vulnerable packages and whether or not they were patched. In some cases, a CVE
    may not even be exploitable in your particular distribution, in which case you
    wouldn't need to do anything. But by following these reports, you can make an
    informed decision regarding what potential vulnerabilities may affect your organization.
    This will allow you to create a plan to roll out the necessary patches onto your
    servers.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 两个网站都允许您查看单独的CVE报告，这将告知您有关受影响软件包以及它们是否已经修补的信息。在某些情况下，CVE甚至可能在您特定的发行版中无法被利用，这种情况下您就不需要做任何事情。但是通过遵循这些报告，您可以就潜在的漏洞可能影响您的组织做出明智的决定。这将使您能够制定一个计划，将必要的补丁推出到您的服务器上。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Security is a very complex subject. So complex that no one person can become
    an all-knowing expert, as even the top people in the industry are continually
    learning. Likewise, it's statistically impossible to create a bulletproof server
    that cannot be compromised. But as a network administrator, you have a role in
    doing the best you can to keep your nodes as secure as you're able to. Security
    is often reactionary, which requires you to be on your toes. In this chapter,
    we took a look at some of the ways you can help safeguard your network from risks.
    We covered concepts such as securing SSH, limiting your attack surface, securing
    Apache with SSL, fail2ban, and deploying security updates.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 安全是一个非常复杂的主题。如此复杂，以至于没有一个人可以成为全知的专家，即使是行业中的顶尖人物也在不断学习。同样，创建一个无法被破坏的防弹服务器是统计上不可能的。但作为网络管理员，您有责任尽力使您的节点尽可能安全。安全通常是一种反应性的，这需要您保持警惕。在本章中，我们探讨了一些帮助您保护网络免受风险的方法。我们涵盖了诸如保护SSH、限制攻击面、使用SSL保护Apache、fail2ban和部署安全更新等概念。
- en: In the next chapter, we'll look into things you can do to troubleshoot issues
    when things go wrong.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨当出现问题时您可以采取的解决方法。
