- en: Advanced IRQ Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级IRQ管理
- en: 'Linux is a system on which devices notify the kernel about particular events
    by means of IRQs. The CPU exposes IRQ lines, shared or not, and used by connected
    devices, so that when a device needs the CPU it sends a request to the CPU. When
    the CPU gets this request it stops its actual job and saves its context, in order
    to serve the request issued by the device. After serving the device, its state
    is restored back to exactly where it stopped when the interruption occurred. There
    are so many IRQ lines, that another device is responsible for them to the CPU.
    That device is the interrupt controller:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Linux是一个系统，设备通过IRQ通知内核特定事件。CPU暴露IRQ线，由连接的设备使用，因此当设备需要CPU时，它会向CPU发送请求。当CPU收到此请求时，它会停止其实际工作并保存其上下文，以便为设备发出的请求提供服务。在为设备提供服务之后，其状态将恢复到中断发生时停止的确切位置。有这么多的IRQ线，另一个设备负责它们给CPU。该设备是中断控制器：
- en: '![](img/Image00034.gif)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00034.gif)'
- en: Interrupt controller and IRQ lines
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 中断控制器和IRQ线
- en: 'Not only can devices raise interrupts, some processor operations can do that
    too. There are two different kinds of interrupts:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 设备不仅可以引发中断，某些处理器操作也可以引发中断。有两种不同类型的中断：
- en: Synchronous interrupts called **exceptions** , produced by the CPU while processing
    instructions. These are **non-maskable interrupts** (**NMI** ), and result from
    a critical malfunction such as hardware failure. They are always processed by
    the CPU.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同步中断称为**异常**，由CPU在处理指令时产生。这些是**不可屏蔽中断**（**NMI**），是由于硬件故障等严重故障而产生的。它们始终由CPU处理。
- en: 'Asynchronous interrupts called **interrupts** , are issued by other hardware
    devices. These are normal and maskable interrupts. It is what we will discuss
    in the next sections of this chapter. Therefore, let us go a bit deeper into exceptions:'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步中断称为**中断**，由其他硬件设备发出。这些是正常的可屏蔽中断。这是我们将在本章的后续部分讨论的内容。因此，让我们深入了解异常：
- en: 'Exceptions are consequences of programming errors handled by the kernel, which
    sends a signal to the program and tries to recover from the error. These are classified
    in two categories, enumerated below:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是由内核处理的编程错误的后果，内核向程序发送信号并尝试从错误中恢复。这些被分类为以下两类：
- en: '**Processor-detected exceptions** : Those the CPU generates in response to
    an anomalous condition, and it is divided into three groups:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器检测到的异常**：CPU对异常情况生成的异常，分为三组：'
- en: Faults, which can generally be corrected (bogus instruction).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障，通常可以纠正（虚假指令）。
- en: Traps, which occur in user process (invalid memory access, division by zero),
    are also a mechanism to switch to kernel mode in response to a system call. If
    the kernel code does cause a trap, it immediately panics.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 陷阱，发生在用户进程中（无效的内存访问，除以零），也是响应系统调用切换到内核模式的机制。如果内核代码确实引起陷阱，它会立即发生恐慌。
- en: Aborts, the serious errors.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中止，严重错误。
- en: '**Programmed exception** : These are requested by the programmer, handled like
    a trap.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序化异常**：这些是由程序员请求的，像陷阱一样处理。'
- en: 'The following array lists unmaskable interrupts (for more details refer to
    [http://wiki.osdev.org/Exceptions](http://wiki.osdev.org/Exceptions) ):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下数组列出了不可屏蔽中断（有关更多详细信息，请参阅[http://wiki.osdev.org/Exceptions](http://wiki.osdev.org/Exceptions)）：
- en: '| **Interrupt number** | **Description** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **中断号** | **描述** |'
- en: '| 0 | Divide by zero error |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 除零错误 |'
- en: '| 1 | Debug exception |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 调试异常 |'
- en: '| 2 | NMI interrupt |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 2 | NMI中断 |'
- en: '| 3 | Breakpoint |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 断点 |'
- en: '| 4 | INTO ­detected overflow |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 检测到溢出 |'
- en: '| 5 | BOUND range exceeded |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 5 | BOUND范围超出 |'
- en: '| 6 | Invalid opcode |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 无效的操作码 |'
- en: '| 7 | Coprocessor (device) not available |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 协处理器（设备）不可用 |'
- en: '| 8 | Double fault |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 双重故障 |'
- en: '| 9 | Coprocessor segment overrun |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 协处理器段溢出 |'
- en: '| 10 | Invalid task state segment |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 无效的任务状态段 |'
- en: '| 11 | Segment not present |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 段不存在 |'
- en: '| 12 | Stack fault |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 栈故障 |'
- en: '| 13 | General protection fault |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 通用保护错误 |'
- en: '| 14 | Page fault |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 页错误 |'
- en: '| 15 | Reserved |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 保留 |'
- en: '| 16 | Coprocessor error |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 协处理器错误 |'
- en: '| 17 - 31 | Reserved |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 17 - 31 | 保留 |'
- en: '| 32 - 255 | Maskable interrupts |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 32 - 255 | 可屏蔽中断 |'
- en: NMIs are enough to cover the whole exception list. Back to maskable interrupts,
    their number depends on the number of devices connected, and how they actually
    share those IRQ lines. Sometimes, they are not enough and some of them need multiplexing.
    The commonly used method is by means of a GPIO controller, which also acts as
    an interrupt controller. In this chapter, we will deal with the API that the kernel
    offers to manage IRQ and the ways by which multiplexing can be done, and get deeper
    in interrupt controller driver writing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: NMI足以覆盖整个异常列表。回到可屏蔽中断，它们的数量取决于连接的设备数量，以及它们实际如何共享这些IRQ线。有时它们是不够的，其中一些需要多路复用。常用的方法是通过GPIO控制器，它也充当中断控制器。在本章中，我们将讨论内核提供的管理IRQ的API以及多路复用的方式，并深入研究中断控制器驱动程序编写。
- en: 'That said, in this chapter the following topics will be covered:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，在本章中将涵盖以下主题：
- en: Interrupt controllers and interrupt multiplexing
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断控制器和中断多路复用
- en: Advanced peripheral IRQs management
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级外围IRQ管理
- en: Interrupt requests and propagations (chained or nested)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断请求和传播（串联或嵌套）
- en: GPIOLIB irqchip API
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPIOLIB irqchip API
- en: Handling interrupt controllers from DT
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从DT处理中断控制器
- en: Multiplexing interrupts and interrupt controllers
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多路复用中断和中断控制器
- en: 'Having a single interrupt from the CPU is usually not enough. Most systems
    have tens and hundreds of them. Now comes interrupt controller, allowing them
    to be multiplexed. Very often architecture or platform-specific offers specific
    facilities, such as:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，仅有来自CPU的单个中断是不够的。大多数系统有数十甚至数百个中断。现在是中断控制器的时候，它允许它们进行多路复用。非常常见的架构或平台特定提供特定的设施，例如：
- en: Masking/unmasking individual interrupts
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏蔽/取消屏蔽单个中断
- en: Setting priorities
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置优先级
- en: SMP affinity
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SMP亲和力
- en: Exotic things like wake-up interrupts
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像唤醒中断这样的奇特事物
- en: 'IRQ management and interrupt controller drivers both rely on the IRQ domain,
    its turn built on top of the following structures:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: IRQ 管理和中断控制器驱动程序都依赖于 IRQ 域，其依次建立在以下结构之上：
- en: '`struct irq_chip` : This structure implements a set of methods describing how
    to drive the interrupt controller, and which are directly called by core IRQ code.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct irq_chip`：这个结构实现了一组描述如何驱动中断控制器的方法，并且这些方法直接被核心 IRQ 代码调用。'
- en: '`struct irqdomain` structure, which provides:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct irqdomain` 结构，提供：'
- en: A pointer to the firmware node for a given interrupt controller (fwnode)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定中断控制器的固件节点的指针（fwnode）
- en: A method to convert a firmware description of an IRQ into an ID local to this
    interrupt controller (hwirq)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将固件描述的 IRQ 转换为本地于此中断控制器的 ID 的方法（hwirq）
- en: A way to retrieve the Linux view of an IRQ from hwirq
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 hwirq 中检索 IRQ 的 Linux 视图的方法
- en: '`struct irq_desc` : This structure is the Linux''s view of an interrupt, containing
    all the core stuff, and one to one mapping to the Linux interrupt number'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct irq_desc`：这个结构是 Linux 对中断的视图，包含所有核心内容，并且与 Linux 中断号一一对应'
- en: '`struct irq_action` : This structure Linux uses to describe an IRQ handler'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct irq_action`：这个结构 Linux 用于描述 IRQ 处理程序'
- en: '`struct irq_data` : This is embedded in the `struct irq_desc` structure, and
    contains:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct irq_data`：这个结构嵌入在 `struct irq_desc` 结构中，包含：'
- en: The data that is relevant to the `irq_chip` managing this interrupt
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与管理此中断的 `irq_chip` 相关的数据
- en: Both the Linux IRQ number and the hwirq
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux IRQ 号和 hwirq
- en: A pointer to the `irq_chip`
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向 `irq_chip` 的指针
- en: Almost every `irq_chip` call is given an `irq_data` as a parameter, from which
    you can obtain the corresponding `irq_desc` .
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个 `irq_chip` 调用都会给定一个 `irq_data` 作为参数，从中可以获取相应的 `irq_desc`。
- en: 'All the preceding structures are part of the IRQ domain API. An interrupt controller
    is represented in the kernel by an instance of `struct irq_chip` structure, which
    describes the actual hardware device, and some methods used by the IRQ core:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述结构都是 IRQ 域 API 的一部分。中断控制器在内核中由 `struct irq_chip` 结构的实例表示，该结构描述了实际的硬件设备，以及
    IRQ 核心使用的一些方法：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is the meaning of elements in the structure:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结构中元素的含义：
- en: '`parent_device` : This is a pointer to the parent of this irqchip.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent_device`：这是指向此 irqchip 的父级的指针。'
- en: '`name` : This is the name for `/proc/interrupts` file.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是 `/proc/interrupts` 文件的名称。'
- en: '`irq_enable` : This hook enables the interrupt, and its default value is `chip->unmask`
    if `NULL` .'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_enable`：这个钩子函数用于启用中断，默认值是 `chip->unmask` 如果为 `NULL`。'
- en: '`irq_disable` : This disables the interrupt.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_disable`：这个函数用于禁用中断。'
- en: '***** `irq_ack` : This is the start of a new interrupt. Some controllers do
    not need this. Linux calls this function as soon as an interrupt is raised, far
    before it is serviced. Some implementations map this function to `chip->disable()`
    , so that another interrupt request on the line will not cause another interrupt
    until after the current interrupt request has been serviced.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***** `irq_ack`：这是一个新中断的开始。一些控制器不需要这个。Linux 在中断被触发后立即调用此函数，远在中断被服务之前。一些实现将此函数映射到
    `chip->disable()`，以便在当前中断请求被服务之后，该线路上的另一个中断请求不会再次引发中断。'
- en: '`irq_mask` : This is the hook that masks an interrupt source in the hardware,
    so that it cannot be raised anymore.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_mask`：这个钩子函数用于在硬件中屏蔽中断源，使其无法再次触发。'
- en: '`irq_unmask` : This hook unmasks an interrupt source.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_unmask`：这个钩子函数用于取消屏蔽中断源。'
- en: '`irq_eoi` : eoi stands for **end of interrupt** . Linux invokes this hook right
    after an IRQ servicing completes. One uses this function to reconfigure the controller
    as necessary in order to receive another interrupt request on that line. Some
    implementations map this function to `chip->enable()` to reverse operations done
    in `chip->ack()` .'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_eoi`：eoi 代表**中断结束**。Linux 在 IRQ 服务完成后立即调用此钩子。使用此函数根据需要重新配置控制器，以便在该线路上接收另一个中断请求。一些实现将此函数映射到
    `chip->enable()`，以撤消 `chip->ack()` 中的操作。'
- en: '`irq_set_affinity` : This sets the CPU affinity only on SMP machines. In SMP
    environments, this function sets the CPU on which the interrupt will be serviced.
    This function isn''t used in single processor machines.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_set_affinity`：这个函数仅在 SMP 机器上设置 CPU 亲和性。在 SMP 环境中，此函数设置将服务中断的 CPU。在单处理器机器中不使用此函数。'
- en: '`irq_retrigger` : This retriggers the interrupt in the hardware, which resends
    an IRQ to the CPU.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_retrigger`：这个函数重新触发硬件中断，将中断重新发送到 CPU。'
- en: '`irq_set_type` : This sets the flow type (IRQ_TYPE_LEVEL/ and so on) of an
    IRQ.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_set_type`：这个函数设置中断的流类型（IRQ_TYPE_LEVEL/等）。'
- en: '`irq_set_wake` : This enables/disables power-management wake-on of an IRQ.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_set_wake`：这个函数用于启用/禁用中断的电源管理唤醒功能。'
- en: '`irq_bus_lock` : This functions to lock access to slow bus (I2C) chips. Locking
    a mutex here is sufficient.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_bus_lock`：这个函数用于锁定对慢总线（I2C）芯片的访问。在这里锁定互斥锁就足够了。'
- en: '`irq_bus_sync_unlock` : This functions to sync and unlock slow bus (I2C) chips.
    Unlock the mutex previously locked.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_bus_sync_unlock`：这个函数用于同步和解锁慢总线（I2C）芯片。解锁之前锁定的互斥锁。'
- en: '`irq_get_irqchip_state` and `irq_set_irqchip_state` : These respectively return
    or set the internal state of an interrupt.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_get_irqchip_state` 和 `irq_set_irqchip_state`：分别返回或设置中断的内部状态。'
- en: 'Each interrupt controller is given a domain, which is for the controller what
    an address space is for a process (see [Chapter 11](http://kernel) , *Kernel Memory
    Management* ). The interrupt controller domain is described in the kernel as an
    instance of `struct irq_domain` structure. It manages mappings between hardware
    IRQ and Linux IRQ (that is, virtual IRQ). It is the hardware interrupt number
    translation object:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个中断控制器都有一个域，对于控制器来说，这就像进程的地址空间一样（参见[第11章](http://kernel)，*内核内存管理*）。中断控制器域在内核中被描述为
    `struct irq_domain` 结构的实例。它管理硬件 IRQ 和 Linux IRQ（即虚拟 IRQ）之间的映射。它是硬件中断编号转换对象：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`name` is the name of the interrupt domain.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 是中断域的名称。'
- en: '`ops` is a pointer to the irq_domain methods.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ops` 是指向 irq_domain 方法的指针。'
- en: '`host_data` is private data pointer for use by the owner. Not touched by the
    irqdomain core code.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host_data` 是所有者使用的私有数据指针。不会被irqdomain核心代码触及。'
- en: '`flags` is host per `irq_domain` flags.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`是每个`irq_domain`标志的主机。'
- en: '`fwnode` is optional. It is a pointer to DT nodes associated with the `irq_domain`
    . Used when decoding DT interrupt specifiers.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fwnode`是可选的。它是与`irq_domain`关联的DT节点的指针。在解码DT中断规范时使用。'
- en: 'An interrupt controller driver creates and registers an `irq_domain` by calling
    one of the `irq_domain_add_<mapping_method>()` functions, where `<mapping_method>`
    is the method by which hwirq should be mapped to Linux IRQ. These are:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 中断控制器驱动程序通过调用`irq_domain_add_<mapping_method>()`函数之一创建并注册`irq_domain`，其中`<mapping_method>`是hwirq应该映射到Linux
    IRQ的方法。这些是：
- en: '`irq_domain_add_linear()` : This uses a fixed size table indexed by the hwirq
    number. When a hwirq is mapped, an `irq_desc` is allocated for the hwirq, and
    the IRQ number is stored in the table. This linear mapping is suitable for fixed
    and small numbers of hwirq (~ < 256). The inconvenience of this mapping is the
    table size, being as large as the largest possible hwirq number. Therefore, IRQ
    number lookup time is fixed, and `irq_desc` are allocated for in-use IRQs only.
    The majority of drivers should use the linear map. This function has the following
    prototype:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`irq_domain_add_linear()`：这使用一个由hwirq号索引的固定大小表。当映射hwirq时，为hwirq分配一个`irq_desc`，并将IRQ号存储在表中。这种线性映射适用于固定和小数量的hwirq（~
    <256）。这种映射的不便之处在于表的大小，它与最大可能的hwirq号一样大。因此，IRQ号查找时间是固定的，`irq_desc`仅为正在使用的IRQ分配。大多数驱动程序应该使用线性映射。此函数具有以下原型：'
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`irq_domain_add_tree()` : This is where the `irq_domain` maintains the mapping
    between Linux IRQs and hwirq numbers in a radix tree. When a hwirq is mapped,
    an `irq_desc` is allocated and the hwirq is used as the lookup key for the radix
    tree. The tree map is a good choice if the hwirq number can be very large since
    it does not need to allocate a table as large as the largest hwirq number. The
    disadvantage is that hwirq to IRQ number lookup is dependent on how many entries
    are in the table. Very few drivers should need this mapping. It has the following
    prototype:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`irq_domain_add_tree()`：这是`irq_domain`在radix树中维护Linux IRQ和hwirq号之间的映射。当映射hwirq时，将分配一个`irq_desc`，并且hwirq将用作radix树的查找键。如果hwirq号可能非常大，则树映射是一个不错的选择，因为它不需要分配一个与最大hwirq号一样大的表。缺点是hwirq到IRQ号的查找取决于表中有多少条目。很少有驱动程序应该需要这种映射。它具有以下原型：'
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`irq_domain_add_nomap()` : You will probably never use this method. Nonetheless,
    its entire description is available in *Documentation/IRQ-domain.txt* , in the
    kernel source tree. Its prototype is:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`irq_domain_add_nomap()`：您可能永远不会使用此方法。尽管如此，它的整个描述在*Documentation/IRQ-domain.txt*中可以找到，位于内核源树中。它的原型是：'
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`of_node` is a pointer to interrupt controller''s DT node. `size` represents
    the number of interrupts in the domain. `ops` represents map/unmap domain callbacks,
    and `host_data` is the controller''s private data pointer.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`of_node` 是指向中断控制器的DT节点的指针。`size` 表示域中中断的数量。`ops` 表示映射/取消映射域回调，`host_data`
    是控制器的私有数据指针。'
- en: 'Since the IRQ domain began empty at creation time (no mapping), you should
    use `irq_create_mapping()` function in order to create mapping and assign it to
    the domain. In the next section, will we decide the right place in the code to
    create mappings:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于IRQ域在创建时为空（没有映射），因此应该使用`irq_create_mapping()`函数来创建映射并将其分配给域。在下一节中，我们将决定在代码中创建映射的正确位置：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`domain` : This is the domain to which this hardware interrupt belongs, or
    `NULL` for default domain'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domain`：这是此硬件中断所属的域，或者对于默认域为`NULL`。'
- en: '`Hwirq` : This is the hardware IRQ number in that domain space'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hwirq`：这是该域空间中的硬件IRQ号'
- en: 'When writing driver for GPIO controllers that are also interrupt controllers,
    `irq_create_mapping()` is called from within `gpio_chip.to_irq()` callback function,
    like:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写同时作为中断控制器的GPIO控制器的驱动程序时，`irq_create_mapping()`是从`gpio_chip.to_irq()`回调函数内部调用的，如下所示：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Other people prefer creating the mapping in advance for each hwirq inside the
    `probe` function like:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 其他人更喜欢在`probe`函数内提前为每个hwirq创建映射，如下所示：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: hwirq is the GPIO offset from the gpiochip.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: hwirq是从gpiochip的GPIO偏移量。
- en: 'If a mapping for the hwirq doesn''t already exist, the function will allocate
    a new Linux `irq_desc` structure, associate it with the hwirq, and call the `irq_domain_ops.map()`
    (by means of the `irq_domain_associate()` function) callback so that the driver
    can perform any required hardware setup:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果hwirq的映射尚不存在，该函数将分配一个新的Linux `irq_desc`结构，将其与hwirq关联，并调用`irq_domain_ops.map()`（通过`irq_domain_associate()`函数）回调，以便驱动程序可以执行任何必需的硬件设置：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`.map()` : This creates or updates a mapping between a **virtual irq** (**virq**
    ) number and a hwirq number. This is called only once for a given mapping. It
    generally maps the virq with a given handler using `irq_set_chip_and_handler*`
    , so that, calling `generic_handle_irq()` or `handle_nested_irq` will trigger
    the right handler. The magic here is called the `irq_set_chip_and_handler()` function:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.map()`：这在**虚拟irq**（**virq**）号和hwirq号之间创建或更新映射。对于给定的映射，只调用一次。它通常使用`irq_set_chip_and_handler*`将virq与给定处理程序进行映射，以便调用`generic_handle_irq()`或`handle_nested_irq`将触发正确的处理程序。这里的魔法被称为`irq_set_chip_and_handler()`函数：'
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'where:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '`irq` : This is the Linux IRQ given as parameter to `map()` function.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq`：这是作为`map()`函数参数给出的Linux IRQ。'
- en: '`chip` : This is your `irq_chip` . Some controllers are quite dumb and need
    almost nothing in their `irq_chip` structure. In this case, you should pass `dummy_irq_chip`
    defined in `kernel/irq/dummychip.c` , which is a kernel `irq_chip` structure defined
    for such controllers.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chip`：这是您的`irq_chip`。一些控制器非常愚蠢，几乎不需要在其`irq_chip`结构中做任何事情。在这种情况下，您应该传递`dummy_irq_chip`，它在`kernel/irq/dummychip.c`中定义，这是为这种控制器定义的内核`irq_chip`结构。'
- en: '`handle` : This determines the wrapper function that will call the real handler
    register using `request_irq()` . Its value depends on the IRQ being edge or level-triggered.
    In either case, `handle` should be set to `handle_edge_irq` , or `handle_level_irq`
    . Both are kernel helper functions that do some trick before and after calling
    the real IRQ handler. An example is shown as follows:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handle`：这确定将调用使用 `request_irq()` 注册的真正处理程序的包装函数。其值取决于 IRQ 是边沿触发还是电平触发。在任何一种情况下，`handle`
    应设置为 `handle_edge_irq` 或 `handle_level_irq`。这两个都是内核辅助函数，在调用真正的 IRQ 处理程序之前和之后执行一些技巧。示例如下：'
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`xlate` : Given a DT node and interrupt specifier, this hook decodes the hardware
    IRQ number and Linux IRQ type value. Depending on the `#interrupt-cells` specified
    in your DT controller node, the kernel provides a generics translation function:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xlate`：给定 DT 节点和中断说明符，此钩子解码硬件 IRQ 号码和 Linux IRQ 类型值。根据您的 DT 控制器节点中指定的 `#interrupt-cells`，内核提供了一个通用的翻译函数：'
- en: '`irq_domain_xlate_twocell()` : Generic translation function is for direct two
    cell binding. DT IRQ specifier which works with two cell bindings where the cell
    values map directly to the hwirq number and Linux irq flags.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_domain_xlate_twocell()`：用于直接双元绑定的通用翻译函数。适用于两个单元绑定的 DT IRQ 说明符，其中单元值直接映射到
    hwirq 号码和 Linux irq 标志。'
- en: '`irq_domain_xlate_onecell()` : Generic xlate for direct one cell bindings.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_domain_xlate_onecell()`：直接单元绑定的通用 xlate。'
- en: '`irq_domain_xlate_onetwocell():` Generic xlate for one or two cell bindings.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_domain_xlate_onetwocell():` 用于一个或两个单元绑定的通用 xlate。'
- en: 'An example of domain operation is given as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 给出了域操作的示例如下：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When an interrupt is received, `irq_find_mapping()` function should be used
    to find the Linux IRQ number from the hwirq number. Of course, the mapping must
    exist prior to being returned. A Linux IRQ number is always tied to a `struct
    irq_desc` structure, which is the structure by which Linux describes an IRQ:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当收到中断时，应使用 `irq_find_mapping()` 函数从 hwirq 号码中找到 Linux IRQ 号码。当然，在返回之前必须存在映射。Linux
    IRQ 号码始终与 `struct irq_desc` 结构相关联，这是 Linux 用来描述 IRQ 的结构：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Some fields that are not described here are internal, and are used by the IRQ
    core:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里未描述的一些字段是内部字段，由 IRQ 核心使用：
- en: '`irq_common_data` is a per IRQ and chip data passed down to chip functions'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq_common_data` 是传递给芯片函数的每个 IRQ 和芯片数据'
- en: '`kstat_irqs` is per CPU IRQ statistics since boot'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kstat_irqs` 是自启动以来每个 CPU 的 IRQ 统计信息'
- en: '`handle_irq` is high level IRQ events handler'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handle_irq` 是高级别 IRQ 事件处理程序'
- en: '`action` represents the list of the IRQ action for this descriptor'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action` 表示此描述符的 IRQ 动作列表'
- en: '`irqs_unhandled` is the stats field for spurious unhandled interrupts'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irqs_unhandled` 是虚假未处理中断的统计字段'
- en: '`lock` represents locking for SMP'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock` 表示 SMP 的锁定'
- en: '`threads_active` is the number of IRQ action threads currently running for
    this descriptor'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threads_active` 是当前正在运行此描述符的 IRQ 动作线程的数量'
- en: '`wait_for_threads` represents the wait queue for `sync_irq` to wait for threaded
    handlers'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wait_for_threads` 表示 `sync_irq` 等待线程处理程序的等待队列'
- en: '`nr_actions` is the number of installed actions on this descriptor'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nr_actions` 是此描述符上安装的动作数量'
- en: '`no_suspend_depth` and `force_resume_depth` represents the number of `irqactions`
    on a IRQ descriptor with `IRQF_NO_SUSPEND` or `IRQF_FORCE_RESUME` flags set'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no_suspend_depth` 和 `force_resume_depth` 表示具有 `IRQF_NO_SUSPEND` 或 `IRQF_FORCE_RESUME`
    标志设置的 IRQ 描述符上的 `irqactions` 数量'
- en: '`dir` represents `/proc/irq/ procfs` entry'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dir` 表示 `/proc/irq/ procfs` 条目'
- en: '`name` names the flow handler, visible in `/proc/interrupts` output'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 命名了流处理程序，在 `/proc/interrupts` 输出中可见'
- en: The `irq_desc.action` field is a list of `irqaction` structures, each of which
    records the address of an interrupt handler for the associated interrupt source.
    Each call to the kernel's `request_irq()` function (or the threaded version `o`
    ) creates an add one `struct irqaction` structure to the end of the list. For
    example, for a shared interrupt, this field will contain as many IRQ actions as
    there are handlers registered;
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`irq_desc.action` 字段是 `irqaction` 结构的列表，每个结构记录了与关联中断源的中断处理程序的地址。每次调用内核的 `request_irq()`
    函数（或线程版本 `o`）都会在列表的末尾创建一个 `struct irqaction` 结构。例如，对于共享中断，该字段将包含与注册的处理程序数量相同的
    IRQ 动作；'
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`handler` is the non-threaded (hard) interrupt handler function'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handler` 是非线程（硬件）中断处理程序函数'
- en: '`name` is the device''s name'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 是设备的名称'
- en: '`dev_id` is a cookie to identify the device'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev_id` 是用于标识设备的 cookie'
- en: '`percpu_dev_id` is a cookie to identify the device'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`percpu_dev_id` 是用于标识设备的 cookie'
- en: '`next` is a pointer to the next IRQ action for shared interrupts'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next` 是共享中断的下一个 IRQ 动作的指针'
- en: '`irq` is the Linux interrupt number'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq` 是 Linux 中断号'
- en: '`flags` represent the IRQ''s flags (see `IRQF_*` )'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 表示 IRQ 的标志（参见 `IRQF_*`）'
- en: '`thread_fn` is the threaded interrupt handler function for threaded interrupts'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thread_fn` 是线程中断处理程序函数，用于线程中断'
- en: '`thread` is a pointer to the thread structure in case of threaded interrupts'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thread` 是线程中断的线程结构的指针'
- en: '`thread_flags` represents the flags related to thread'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thread_flags` 表示与线程相关的标志'
- en: '`thread_mask` is a bitmask for keeping track of thread activity'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thread_mask` 是用于跟踪线程活动的位掩码'
- en: '`dir` points to the `/proc/irq/NN/<name>/` entry'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dir` 指向 `/proc/irq/NN/<name>/` 条目'
- en: Interrupt handlers referenced by the `irqaction.handler` field are simply functions
    associated with the handling of interrupts from particular external devices, and
    they have minimal knowledge (if any) of the means by which those interrupt requests
    are delivered to the host microprocessor. They are not microprocessor-level interrupt
    service routines, and therefore do not exit through RTE or similar interrupt-related
    opcodes. This makes interrupt-driven device drivers largely portable across different
    microprocessor architectures
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`irqaction.handler` 字段引用的中断处理程序只是与处理来自特定外部设备的中断相关的函数，它们对于将这些中断请求传递给主机微处理器的方式几乎没有（如果有的话）了解。它们不是微处理器级别的中断服务例程，因此不会通过
    RTE 或类似的与中断相关的操作码退出。这使得基于中断驱动的设备驱动程序在不同的微处理器架构之间具有很大的可移植性'
- en: 'The following is the definition of important fields of the `struct irq_data`
    structure, which is a per IRQ chip data passed down to chip functions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`struct irq_data`结构的重要字段的定义，该结构是传递给芯片函数的每个IRQ芯片数据：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`irq` is the interrupt number (Linux IRQ)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq`是中断号（Linux IRQ）'
- en: '`hwirq` is the hardware interrupt number, local to the `irq_data.domain` interrupt
    domain'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hwirq`是硬件中断号，局限于`irq_data.domain`中断域'
- en: '`common` points to data shared by all irqchips'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`common`指向所有irqchips共享的数据'
- en: '`chip` represents the low level interrupt controller hardware access'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chip`表示底层中断控制器硬件访问'
- en: '`domain` represents the interrupt translation domain, responsible for mapping
    between the hwirq number and the Linux irq number'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domain`表示中断转换域，负责在hwirq号和Linux irq号之间进行映射'
- en: '`chip_data` is a platform-specific per-chip private data for the chip methods,
    to allow shared chip implementations'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chip_data`是每个芯片方法的特定于平台的芯片私有数据，以允许共享芯片实现'
- en: Advanced peripheral IRQs management
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级外围IRQ管理
- en: In [Chapter 3](text00063.html) , *Kernel Facilities and Helper Functions* ,
    we introduced peripheral IRQs, using `request_irq()` and `request_threaded_irq()`
    . With `request_irq()` , one registers a handler (top half) that will be executed
    in atomic context, from which one can schedule a bottom half using one of a differing
    mechanism discussed in that same chapter. On the other hand, with `request_thread_irq()`
    , one can provide top and bottom halves to the function, so that the former will
    be run as hardirq handler, which may decide to raise the second and threaded handler,
    which will be run in a kernel thread.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](text00063.html) *内核设施和辅助函数*中，我们介绍了外围IRQ，使用`request_irq()`和`request_threaded_irq()`。使用`request_irq()`，可以注册一个在原子上下文中执行的处理程序（顶半部），从中可以使用在同一章节中讨论的不同机制之一调度底半部。另一方面，使用`request_thread_irq()`，可以为函数提供顶部和底部，以便前者将作为hardirq处理程序运行，可以决定引发第二个线程处理程序，后者将在内核线程中运行。
- en: 'The problem with those approaches is that sometimes, drivers requesting an
    IRQ do not know about the nature of the interrupt that provides this IRQ line,
    especially when the interrupt controller is a discrete chip (typically a GPIO
    expander connected over SPI or I2C buses). Now comes `request_any_context_irq()`
    , function with which drivers requesting an IRQ know whether the handler will
    run in a thread context or not, and call `request_threaded_irq()` or `request_irq()`
    accordingly. It means that whether the IRQ associated to our device comes from
    an interrupt controller that may not sleep (memory mapped one) or from one that
    can sleep (behind I2C/SPI bus), there will be no need to change the code. Its
    prototype is the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的问题在于，有时，请求IRQ的驱动程序不知道提供此IRQ线的中断的性质，特别是当中断控制器是一个离散芯片（通常是通过SPI或I2C总线连接的GPIO扩展器）时。现在有了`request_any_context_irq()`，请求IRQ的驱动程序知道处理程序是否在线程上下文中运行，并相应地调用`request_threaded_irq()`或`request_irq()`。这意味着无论我们的设备关联的IRQ来自可能不休眠的中断控制器（内存映射）还是来自可以休眠的中断控制器（在I2C/SPI总线后面），都不需要更改代码。它的原型如下：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is the meaning of each parameter in the function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是函数中每个参数的含义：
- en: '`irq` represents the interrupt line to allocate.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`irq`表示要分配的中断线。'
- en: '`handler` is the function to be called when the IRQ occurs. Depending on the
    context, this function may run as hardirq or may be threaded.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handler`是在发生IRQ时要调用的函数。根据上下文，此函数可能作为hardirq运行，也可能作为线程运行。'
- en: '`flags` represents the interrupt type flags. It is the same as those in `request_irq()`
    .'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`表示中断类型标志。与`request_irq()`中的标志相同。'
- en: '`name` will be used for debug purposes to name the interrupt in `/proc/interrupts`
    .'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`将用于调试目的，在`/proc/interrupts`中命名中断。'
- en: '`dev_id` is a cookie passed back to the handler function.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev_id`是传递回处理程序函数的cookie。'
- en: '`request_any_context_irq()` means that one can either get a hardirq or a treaded
    one. It works like the usual `request_irq()` , except that it checks whether the
    IRQ level is configured as nested or not, and calls the right backend. In other
    words, it selects either a hardIRQ or threaded handling method depending on the
    context. This function returns a negative value on failure. On success, it returns
    either `IRQC_IS_HARDIRQ` or `IRQC_IS_NESTED` . The following is a use case:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`request_any_context_irq()`表示可以获得hardirq或treaded。它的工作方式类似于通常的`request_irq()`，只是它检查IRQ级别是否配置为嵌套，并调用正确的后端。换句话说，它根据上下文选择硬件中断或线程处理方法。此函数在失败时返回负值。成功时，它返回`IRQC_IS_HARDIRQ`或`IRQC_IS_NESTED`。以下是一个用例：'
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code is an excerpt of the driver sample of an input device driver.
    Actually, it is the one used in the next chapter. The advantage using `request_any_context_irq()`
    is that, one does not need to care about what can be done in the IRQ handler,
    as the context in which the handler will run depends on the interrupt controller
    that provides the IRQ line. In our example, if the GPIO below to a controller
    seating on an I2C or SPI bus, the handler will be threaded. Otherwise, the handler
    will run in hardirq.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是输入设备驱动程序的驱动程序示例的摘录。实际上，它是下一章中使用的代码。使用`request_any_context_irq()`的优势在于，不需要关心在IRQ处理程序中可以做什么，因为处理程序将运行的上下文取决于提供IRQ线的中断控制器。在我们的示例中，如果GPIO属于坐落在I2C或SPI总线上的控制器，处理程序将是线程化的。否则，处理程序将在hardirq中运行。
- en: Interrupt request and propagation
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断请求和传播
- en: Let us consider the following figure, which represents a chained IRQ flow
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下图，它表示链接的IRQ流
- en: '![](img/Image00035.gif)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00035.gif)'
- en: 'Interrupt requests are always performed on Linux IRQ (not hwirq). The general
    function to request IRQ on Linux is `request_threaded_irq()` or `request_irq()`
    , which internally calls the former:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 中断请求始终在Linux IRQ上执行（而不是hwirq）。在Linux上请求IRQ的一般函数是`request_threaded_irq()`或`request_irq()`，它在内部调用前者：
- en: '[PRE17]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When called, the function extracts the `struct irq_desc` associated with the
    IRQ using the `irq_to_desc()` macro. It then allocates a new `struct irqaction`
    structure and sets it up, filling parameters such as handler, flags, and so on.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用该函数时，该函数使用`irq_to_desc()`宏提取与IRQ关联的`struct irq_desc`，然后分配一个新的`struct irqaction`结构并设置它，填充处理程序、标志等参数。
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That same function finally inserts/registers the descriptor in the proper IRQ
    list by invoking `__setup_irq()` (by means of `setup_irq()` ) function, defined
    in `kernel/irq/manage.c` .
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数最终通过调用`__setup_irq()`（通过`setup_irq()`）函数将描述符插入/注册到适当的IRQ列表中，该函数在`kernel/irq/manage.c`中定义。
- en: 'Now, when an IRQ is raised, the kernel executes a few assembler codes in order
    to save the current state, and jumps to the arch specific handler, `handle_arch_irq`
    , which is set with the `handle_irq` field of `struct machine_desc` of our platform
    in the `setup_arch()` function, in `arch/arm/kernel/setup.c` :'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当发生中断时，内核会执行一些汇编代码以保存当前状态，并跳转到特定于体系结构的处理程序`handle_arch_irq`，该处理程序在`arch/arm/kernel/setup.c`的`setup_arch()`函数中的我们平台的`struct
    machine_desc`的`handle_irq`字段中设置：
- en: '[PRE19]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For SoCs that use ARM GIC, `handle_irq` callback is set with `gic_handle_irq`
    , in either `drivers/irqchip/irq-gic.c` , or `drivers/irqchip/irq-gic-v3.c` :'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用ARM GIC的SoC，`handle_irq`回调使用`gic_handle_irq`设置，可以在`drivers/irqchip/irq-gic.c`或`drivers/irqchip/irq-gic-v3.c`中找到：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`gic_handle_irq()` calls `handle_domain_irq()` , which executes `generic_handle_irq()`
    , its turn calling `generic_handle_irq_desc()` that ends by calling `desc->handle_irq()`
    . Have a look at `include/linux/irqdesc.h` for the last call and `arch/arm/kernel/irq.c`
    for other function calls. `handle_irq` is the actual call for the flow handler,
    which we registered as `mcp23016_irq_handler` .'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`gic_handle_irq()`调用`handle_domain_irq()`，执行`generic_handle_irq()`，然后调用`generic_handle_irq_desc()`，最终调用`desc->handle_irq()`。查看`include/linux/irqdesc.h`以获取最后一次调用，查看`arch/arm/kernel/irq.c`以获取其他函数调用。`handle_irq`是实际的流处理程序调用，我们将其注册为`mcp23016_irq_handler`。'
- en: '`gic_hande_irq()` is a GIC interrupt handler. `generic_handle_irq()` will execute
    the handler of the SoC''s GPIO4 IRQ, which will look for GPIOs pin responsible
    for the interrupt, and call `generic_handle_irq_desc()` , and so on. Now that
    you are familiar with interrupt propagation, let us switch to a practical example
    by writing our own interrupt controller.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`gic_hande_irq()`是一个GIC中断处理程序。`generic_handle_irq()`将执行SoC的GPIO4 IRQ的处理程序，该处理程序将寻找负责中断的GPIO引脚，并调用`generic_handle_irq_desc()`，依此类推。现在您已经熟悉了中断传播，让我们通过编写自己的中断控制器来切换到一个实际的例子。'
- en: Chaining IRQ
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接IRQ
- en: 'This section describes how interrupt handlers of a parent, call the child''s
    interrupt handlers, in turn calling their child''s interrupt handlers, and so
    on. The kernel offers two approaches on how to call interrupt handlers for child
    devices in the IRQ handler of the parent (interrupt controller) device. These
    are the chained and nested methods:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了父级中断处理程序如何调用子级中断处理程序，进而调用它们的子级中断处理程序，依此类推。内核提供了两种方法来在父级（中断控制器）设备的IRQ处理程序中调用子设备的中断处理程序，这些方法是链接和嵌套方法：
- en: Chained interrupts
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接中断
- en: This approach is used for SoC's internal GPIO controller, which are memory mapped
    and whose access does not sleep. Chained means that those interrupts are just
    chains of function calls (for example, SoC's GPIO module interrupt handler is
    being called from GIC interrupt handler, just as a function call). `generic_handle_irq()`
    is used for interrupts chaining child IRQ handlers and are called inside of the
    parent hwirq handler. Even from within the child interrupt handlers, we still
    are in atomic context (HW interrupt). One cannot call functions that may sleep.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法用于SoC的内部GPIO控制器，它们是内存映射的，其访问不会休眠。链接意味着这些中断只是函数调用链（例如，SoC的GPIO模块中断处理程序是从GIC中断处理程序调用的，就像函数调用一样）。`generic_handle_irq()`用于链接子IRQ处理程序，并在父hwirq处理程序内调用。即使在子中断处理程序内部，我们仍然处于原子上下文（硬件中断）。不能调用可能休眠的函数。
- en: Nested interrupts
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套中断
- en: This method is used by controllers that sit on slow buses, like I2C (for example,
    GPIO expander), and whose access may sleep (I2C functions may sleep). Nested means
    those interrupts handlers that do not run in the HW context (they are not really
    hwirq, they are not in atomic context), but they are threaded instead, and can
    be preempted (or interrupted by another interrupt). `handle_nested_irq()` is used
    for creating nested interrupt child IRQs. Handlers are being called inside of
    the new thread created by the `handle_nested_irq()` function; we need them to
    be run in process context, so that we can call sleeping bus functions (like I2C
    functions that may sleep).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法用于坐在慢总线上的控制器，比如I2C（例如，GPIO扩展器），其访问可能会休眠（I2C函数可能会休眠）。嵌套意味着这些中断处理程序不在硬件上下文中运行（它们实际上不是hwirq，它们不在原子上下文中），而是线程化的，可以被抢占（或被另一个中断中断）。`handle_nested_irq()`用于创建嵌套中断子IRQ。处理程序在`handle_nested_irq()`函数创建的新线程内部被调用；我们需要它们在进程上下文中运行，以便我们可以调用可能会休眠的总线函数（比如可能会休眠的I2C函数）。
- en: Case study – GPIO and IRQ chip
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究- GPIO和IRQ芯片
- en: 'Let us consider the following figure that ties an interrupt controller device
    to another one, which we will use to describe interrupt multiplexing:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑下面的图，它将一个中断控制器设备与另一个设备连接起来，我们将用它来描述中断复用：
- en: '![](img/Image00036.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00036.jpg)'
- en: mcp23016 IRQ flow
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: mcp23016 IRQ流程
- en: Consider that you have configured `io_1` and `io_2` as interrupts. Even if interrupt
    happens on `io_1` or `io_2` , the same interrupt line will be triggered to the
    interrupt controller. Now the GPIO driver has to figure out reading the interrupt
    status register of the GPIO to find which interrupt (`io_1` or `io_2` ) has really
    fired. Therefore, in this case a single interrupt line is a multiplex for 16 GPIO
    interrupts.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已将`io_1`和`io_2`配置为中断。即使中断发生在`io_1`或`io_2`上，相同的中断线也会触发中断控制器。现在GPIO驱动程序必须找出读取GPIO的中断状态寄存器，以找出哪个中断（`io_1`或`io_2`）实际上已触发。因此，在这种情况下，单个中断线是16个GPIO中断的复用。
- en: 'Now let us mangle the original driver of the mcp23016 written in [Chapter 15](text00371.html)
    , *GPIO Controller Drivers – gpio_chip* in order to support IRQ domain API first,
    which will let it act as an interrupt controller as well. The second part will
    introduce the new and recommended gpiolib irqchip API. This will be used as a
    step-by-step guide to write the interrupt controller driver, at least for the
    GPIO controller:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们修改原始的mcp23016驱动程序，该驱动程序在[第15章](text00371.html)中编写，*GPIO控制器驱动程序 - gpio_chip*，以支持首先作为中断控制器的IRQ域API。第二部分将介绍新的和推荐的gpiolib
    irqchip API。这将被用作逐步指南来编写中断控制器驱动程序，至少对于GPIO控制器。
- en: Legacy GPIO and IRQ chip
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统GPIO和IRQ芯片
- en: 'The first step, allocate a `struct irq_domain` to our gpiochip that will store
    the mapping between hwirq and virq. The linear mapping is suitable for us. We
    do that in the `probe` function. That domain will hold the number of IRQ our drivers
    wish to provide. For example, for an I/O expander, the number of IRQs could be
    the number of GPIOs the expander provides:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步，为我们的gpiochip分配一个`struct irq_domain`，它将存储hwirq和virq之间的映射。线性映射对我们来说是合适的。我们在`probe`函数中这样做。该域将保存我们的驱动程序希望提供的IRQ数量。例如，对于I/O扩展器，IRQ的数量可以是扩展器提供的GPIO数量：
- en: '[PRE21]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`host_data` parameter is `NULL` . Therefore, you can pass whatever data structure
    you need. Prior to allocating the domain, our domain ops structure should be defined:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`host_data`参数是`NULL`。因此，您可以传递任何您需要的数据结构。在分配域之前，我们的域ops结构应该被定义：'
- en: '[PRE22]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And prior to filling our IRQ domain ops structure, we must define at least
    the `.map()` callback:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在填充我们的IRQ域ops结构之前，我们必须至少定义`.map()`回调：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our controller is not smart enough. There is then no need to set up an `irq_chip`
    . We will use the one provided by the kernel for this kind of chip: `dummy_irq_chip`
    . Some controllers are smart enough and need an `irq_chip` to be set up. Have
    a look in `drivers/gpio/gpio-mcp23s08.c` .'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的控制器不够智能。因此，没有必要设置`irq_chip`。我们将使用内核为这种芯片提供的一个：`dummy_irq_chip`。有些控制器足够智能，需要设置`irq_chip`。在`drivers/gpio/gpio-mcp23s08.c`中查看。
- en: The next ops callback is `.xlate` . Here again, we use a helper provided by
    the kernel. `irq_domain_xlate_twocell` is a helper able to parse an interrupt
    specifier with two cells. We can add this `interrupt-cells = <2>;` in our controller
    DT node.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个ops回调是`.xlate`。在这里，我们再次使用内核提供的帮助程序。`irq_domain_xlate_twocell`是一个能够解析具有两个单元的中断指定符的帮助程序。我们可以在我们的控制器DT节点中添加`interrupt-cells
    = <2>;`。
- en: 'The next step is to fill the domain with IRQ mappings, using `irq_create_mapping()`
    function. In our driver, will do it in the `gpiochip.to_irq` callback, so that
    whenever someone will call `gpio{d}_to_irq()` on the GPIO, the mapping will be
    returned if it exists, or it will be created if it doesn''t:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用`irq_create_mapping()`函数填充域与IRQ映射。在我们的驱动程序中，我们将在`gpiochip.to_irq`回调中执行此操作，这样每当有人在GPIO上调用`gpio{d}_to_irq()`时，如果映射存在，它将被返回，如果不存在，它将被创建：
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We could have done that for each GPIO in the `probe` function, and just call
    `irq_find_mapping()` in `.to_irq` function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`probe`函数中为每个GPIO都这样做，并在`.to_irq`函数中只调用`irq_find_mapping()`。
- en: 'Now still in the `probe` function, we need to register our controller''s IRQ
    handler, which in turn is responsible for calling the right handler that raised
    the interrupt on its pins:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在仍然在`probe`函数中，我们需要注册我们控制器的IRQ处理程序，这个处理程序负责调用引发其引脚中断的正确处理程序：
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The function `mcp23016` should have been defined prior to registering the IRQ:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册IRQ之前，函数`mcp23016`应该已经被定义：
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`handle_nested_irq()` already descried in the preceding section will create
    a dedicated thread for each handler registered.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle_nested_irq()`已经在前面的部分中描述，将为每个注册的处理程序创建一个专用线程。'
- en: New gpiolib irqchip API
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的gpiolib irqchip API
- en: Almost every GPIO controller driver was using IRQ domain for the same purpose.
    Instead of each of them rolling their own irqdomain handling and so on, kernel
    developers decided to move that code to gpiolib framework, by means of `GPIOLIB_IRQCHIP`
    Kconfig symbol, in order to harmonize the development and avoid redundant code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个GPIO控制器驱动程序都在使用IRQ域来实现相同的目的。内核开发人员决定将这些代码移动到gpiolib框架中，通过`GPIOLIB_IRQCHIP`
    Kconfig符号，以便协调开发并避免冗余代码。
- en: That portion of code helps in handling management of GPIO irqchips and the associated
    `irq_domain` and resource allocation callbacks, as well as their setup, using
    the reduced set of helper functions. These are `gpiochip_irqchip_add()` and `gpiochip_set_chained_irqchip()`
    .
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码部分有助于处理GPIO irqchips和相关的`irq_domain`和资源分配回调，以及它们的设置，使用减少的帮助函数集。这些是`gpiochip_irqchip_add()`和`gpiochip_set_chained_irqchip()`。
- en: '`gpiochip_irqchip_add():` This adds an irqchip to a gpiochip. What this function
    does:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpiochip_irqchip_add():` 这将一个irqchip添加到一个gpiochip中。这个函数的作用是：'
- en: Sets `gpiochip.to_irq` field to `gpiochip_to_irq` , which is an IRQ callback
    that just returns `irq_find_mapping(chip->irqdomain, offset);`
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`gpiochip.to_irq`字段设置为`gpiochip_to_irq`，这是一个IRQ回调，只返回`irq_find_mapping(chip->irqdomain,
    offset);`
- en: Allocates an irq_domain to the gpiochip using `irq_domain_add_simple()` function,
    passing a kernel IRQ core `irq_domain_ops` called `gpiochip_domain_ops` and defined
    in `drivers/gpio/gpiolib.c`
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`irq_domain_add_simple()`函数为gpiochip分配一个irq_domain，传递一个内核IRQ核心`irq_domain_ops`，称为`gpiochip_domain_ops`，并在`drivers/gpio/gpiolib.c`中定义。
- en: Create mapping from 0 to `gpiochip.ngpio` using `irq_create_mapping()` function
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`irq_create_mapping()`函数从0到`gpiochip.ngpio`创建映射
- en: 'Its prototype is as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 它的原型如下：
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Where `gpiochip` is our GPIO chip, the one to add the irqchip to, `irqchip`
    is the irqchip to add to the gpiochip. `first_irq` if not dynamically assigned,
    is the base (first) IRQ to allocate gpiochip IRQs from. `handler` is the IRQ handler
    to use (often a predefined IRQ core function), and `type` is the default type
    for IRQs on this irqchip, pass `IRQ_TYPE_NONE` to have the core avoid setting
    up any default type in the hardware.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpiochip` 是我们的 GPIO 芯片，要添加 irqchip 到其中，`irqchip` 是要添加到 gpiochip 的 irqchip。如果没有动态分配，`first_irq`
    是要从中分配 gpiochip IRQ 的基础（第一个）IRQ。`handler` 是要使用的 IRQ 处理程序（通常是预定义的 IRQ 核心函数），`type`
    是该 irqchip 上 IRQ 的默认类型，传递 `IRQ_TYPE_NONE` 以使核心避免在硬件中设置任何默认类型。'
- en: This function will handle two celled simple IRQs (because it sets `irq_domain_ops.xlate`
    to `irq_domain_xlate_twocell` ) and assumes all the pins on the gpiochip can generate
    a unique IRQ.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将处理两个单元格的简单 IRQ（因为它将 `irq_domain_ops.xlate` 设置为 `irq_domain_xlate_twocell`），并假定
    gpiochip 上的所有引脚都可以生成唯一的 IRQ。
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`gpiochip_set_chained_irqchip()` : This function sets a chained irqchip to
    a `gpio_chip` from a parent IRQ and passes a pointer to the `struct gpio_chip`
    as handler data:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpiochip_set_chained_irqchip()`：此函数将链式 irqchip 设置为从父 IRQ 到 `gpio_chip`，并将
    `struct gpio_chip` 的指针传递为处理程序数据：'
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`parent_irq` is the IRQ number to which this chip is connected. In case of
    our mcp23016 as shown in the figure in the section *Case study-GPIO and IRQ chip*
    , it corresponds to the IRQ of `gpio4_29` line. In other words, it is the parent
    IRQ number for this chained irqchip. `parent_handler` is the parent interrupt
    handler for the accumulated IRQ coming out of the gpiochip. If the interrupt is
    nested rather than cascaded (chained), pass `NULL` in this handler argument.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`parent_irq` 是此芯片连接到的 IRQ 号。在我们的 mcp23016 中，如 *Case study-GPIO and IRQ chip*
    部分中的图所示，它对应于 `gpio4_29` 线的 IRQ。换句话说，它是此链式 irqchip 的父 IRQ 号。`parent_handler` 是累积的从
    gpiochip 出来的 IRQ 的父中断处理程序。如果中断是嵌套而不是级联的，可以在此处理程序参数中传递 `NULL`。'
- en: 'With this new API, the only code to add to our `probe` function is:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个新的 API，我们的 `probe` 函数中需要添加的唯一代码是：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'IRQ core does everything for us. No need to define even the `gpiochip.to_irq`
    function, since the API already sets it. Our example uses the IRQ core `dummy_irq_chip`
    , but one could have defined its own as well. Since the v4.10 version of the kernel,
    two other functions have been added: these are `gpiochip_irqchip_add_nested()`
    and `gpiochip_set_nested_irqchip()` . Have a look at *Documentation/gpio/driver.txt*
    for more details. A driver that uses this API in the same kernel version is `drivers/gpio/gpio-mcp23s08.c`
    .'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: IRQ 核心为我们做了一切。甚至不需要定义 `gpiochip.to_irq` 函数，因为 API 已经设置了它。我们的示例使用了 IRQ 核心 `dummy_irq_chip`，但也可以自己定义。自内核
    v4.10 版本以来，还添加了另外两个函数：`gpiochip_irqchip_add_nested()` 和 `gpiochip_set_nested_irqchip()`。请查看
    *Documentation/gpio/driver.txt* 了解更多细节。在同一内核版本中使用此 API 的驱动程序是 `drivers/gpio/gpio-mcp23s08.c`。
- en: Interrupt controller and DT
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断控制器和 DT
- en: 'Now we will declare our controller in the DT. If you remember in [Chapter 6](text00162.html)
    : *The Concept of Device Tree* , every interrupt controller must have the Boolean
    property interrupt-controller set. The second mandatory Boolean property is `gpio-controller`
    , since it is a GPIO controller too. We need to define how many cells are needed
    for an interrupt specifier for our device. Since we have set the `irq_domain_ops.xlate`
    field to `irq_domain_xlate_twocell` , `#interrupt-cells` should be 2:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在 DT 中声明我们的控制器。如果你还记得[第6章](text00162.html)：*设备树的概念*，每个中断控制器必须具有设置为布尔属性
    interrupt-controller 的属性。第二个强制性的布尔属性是 `gpio-controller`，因为它也是 GPIO 控制器。我们需要定义我们的设备的中断描述符需要多少个单元格。由于我们已将
    `irq_domain_ops.xlate` 字段设置为 `irq_domain_xlate_twocell`，`#interrupt-cells` 应该是
    2：
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`interrupt-parent` and `interrupts` properties are describing interrupt line
    connection.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`interrupt-parent` 和 `interrupts` 属性描述了中断线连接。'
- en: 'Finally, let us say that we have a driver for mcp23016 and drivers for two
    other devices: `foo_device` and `bar_device` , all running in the CPU of course.
    In the `foo_device` driver, one wants to request interrupt for events when `foo_device`
    changes level on the `io_2` pin of mcp23016\. The `bar_device` driver requires
    `io_8` and `io_12` respectively for reset and power GPIOs. Let us declare this
    in the DT:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们说一下，我们有一个 mcp23016 的驱动程序，以及两个其他设备的驱动程序：`foo_device` 和 `bar_device`，当然都在
    CPU 上运行。在 `foo_device` 驱动程序中，我们希望在 `mcp23016` 的 `io_2` 引脚发生变化时请求中断。`bar_device`
    驱动程序需要分别用于复位和电源 GPIO 的 `io_8` 和 `io_12`。让我们在 DT 中声明这一点：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Now IRQ multiplexing has no more secrets for you. We discussed the most important
    elements of IRQ management under Linux systems, the IRQ domain API. You have the
    basics to develop interrupt controller drivers, as well as managing their binding
    from within the DT. IRQ propagation has been discussed in order to understand
    what happens from the request to the handling. This chapter will help you to understand
    the interrupt driven part of the next chapter, which deals with input device drivers.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 IRQ 多路复用对你来说已经没有秘密了。我们讨论了 Linux 系统下 IRQ 管理的最重要的元素，即 IRQ 域 API。你已经掌握了开发中断控制器驱动程序的基础，以及从
    DT 中管理它们的绑定。我们讨论了 IRQ 传播，以便了解从请求到处理的过程。这一章将帮助你理解下一章中的中断驱动部分，该部分涉及输入设备驱动程序。
