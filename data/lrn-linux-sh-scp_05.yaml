- en: Understanding the Linux Permissions Scheme
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Linux权限方案
- en: In this chapter, we will explore how the Linux permission scheme is implemented.
    Read, write, and execute permissions for files and directories will be discussed,
    and we will see how they affect files and directories differently. We will see
    how multiple users can work together using groups, and how some files and directories
    are available to others as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Linux权限方案是如何实现的。文件和目录的读取、写入和执行权限将被讨论，我们将看到它们如何不同地影响文件和目录。我们将看到多个用户如何使用组一起工作，以及一些文件和目录也对其他人可用。
- en: 'The following commands will be introduced in this chapter: `id`, `touch`, `chmod`,
    `umask`, `chown`, `chgrp`, `sudo`, `useradd`, `groupadd`, `usermod`, `mkdir`,
    and `su`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下命令：`id`，`touch`，`chmod`，`umask`，`chown`，`chgrp`，`sudo`，`useradd`，`groupadd`，`usermod`，`mkdir`和`su`。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Read, write, and execute
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取，写入和执行
- en: Users, groups, and others
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户，组和其他人
- en: Working with multiple users
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与多个用户一起工作
- en: Advanced permissions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级权限
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will explore the Linux permissions scheme using the virtual machine we created
    in [Chapter 2](cdd5838b-007b-4e1a-a8dc-3c9ea8ebefca.xhtml), *Setting Up Your Local
    Environment*. During this chapter, we will add new users to this system, but only
    having access as the first user (which has administrative, or *root* privileges)
    is sufficient at this point.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在[第2章](cdd5838b-007b-4e1a-a8dc-3c9ea8ebefca.xhtml)中创建的虚拟机来探索Linux权限方案，*设置您的本地环境*。在本章中，我们将向该系统添加新用户，但目前只有作为第一个用户（具有管理或*root*权限）的访问权限就足够了。
- en: Read, write, and execute
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取，写入和执行
- en: In the previous chapter, we discussed the Linux filesystem and the different
    types with which Linux implements the *everything is a file* philosophy. However,
    we did not look at permissions on those files. As you might have guessed, in a
    multi-user system such as a Linux server, it is not a particularly great idea
    that users can access files which are owned by other users. Where would the privacy
    be in that?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了Linux文件系统以及Linux实现“一切皆文件”哲学的不同类型。然而，我们没有看文件的权限。你可能已经猜到，在一个多用户系统，比如Linux服务器中，用户可以访问其他用户拥有的文件并不是一个特别好的主意。隐私在哪里呢？
- en: 'The Linux permissions scheme is actually at the heart of the Linux experience,
    as far as we are concerned. Just as (almost) everything is handled as a file in
    Linux, all of those files have a distinct set of permissions accompanying them.
    While exploring the file system in the previous chapter, we limited ourselves
    to files that were viewable by either everyone or by the currently logged in user.
    However, there are many files that are only viewable or writable by the `root`
    user: often, these are sensitive files such as `/etc/shadow` (which contains the
    *hashed* passwords for all users), or files which are used when starting the system,
    such as `/etc/fstab` (which determines which file systems are mounted at boot).
    If everyone could edit those files, it could result in an unbootable system very
    quickly!'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Linux权限方案实际上是Linux体验的核心，就我们而言。就像在Linux中（几乎）一切都被处理为文件一样，所有这些文件都有一组不同的权限。在上一章中探索文件系统时，我们限制了自己只能查看所有人或当前登录用户可见的文件。然而，有许多文件只能被`root`用户查看或写入：通常，这些是一些敏感文件，比如`/etc/shadow`（其中包含所有用户的*哈希*密码），或者在启动系统时使用的文件，比如`/etc/fstab`（确定哪些文件系统在启动时被挂载）。如果每个人都可以编辑这些文件，很快就会导致系统无法启动！
- en: RWX
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RWX
- en: 'File permissions under Linux are handled by three attributes: **r**ead, **w**rite,
    and e**x**ecute, or RWX. While there are other permissions (some of which we will
    discuss later in this chapter), most interactions with regards to permissions
    will be handled by these three. Even though the names seem to speak for themselves,
    they behave differently with regards to (normal) files and directories. The following
    table should illustrate this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Linux下的文件权限由三个属性处理：**读取**，**写入**和**执行**，或者RWX。虽然还有其他权限（我们将在本章后面讨论一些），但大多数权限交互将由这三个属性处理。尽管这些名称似乎不言自明，但它们在（普通）文件和目录方面的行为是不同的。以下表格应该说明这一点：
- en: Allows the user to see the contents of the file with any command that supports
    this, such as `vim`, `nano`, `less`, `cat`, and so on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 允许用户使用任何支持此操作的命令查看文件的内容，比如`vim`，`nano`，`less`，`cat`等。
- en: '| **Permission** | **On normal files** | **On directories**  |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **权限** | **对普通文件** | **对目录** |'
- en: '| Read | Allows the user to list the contents of the directory using the `ls`
    command. This will even list files in the directory on which the user has no other
    privileges! | Allows the user to list the contents of the directory using the
    ls command. This will even list files in directory on which the user has no other
    privileges! |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 读取 | 允许用户使用`ls`命令列出目录的内容。这甚至会列出用户没有其他权限的目录中的文件！'
- en: '| Write | Allows the user to make changes to the file. | Allows the user to
    replace or delete files within the directory, even if the user has no direct permissions
    on that file. However, this does not include read permissions on all files within
    the directory! |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 写入 | 允许用户对文件进行更改。| 允许用户替换或删除目录中的文件，即使用户对该文件没有直接权限。但这不包括对目录中所有文件的读取权限！'
- en: '| Execute | Allows the user to execute the file. This is only relevant when
    the file is something that is supposed to be executed, such as a binary or script;
    otherwise, this attribute does nothing. | Allows the user to traverse into the
    directory by using `cd`. This is a separate permission from the listing of contents,
    but they are almost always used together; being able to list without being able
    to navigate into it (and vice versa) is mostly an ineffective configuration. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 执行 | 允许用户执行文件。当文件是应该被执行的东西，比如二进制文件或脚本时，这是相关的；否则，这个属性什么也不做。 | 允许用户使用 `cd`
    进入目录。这是与内容列表不同的权限，但它们几乎总是一起使用；能够列出而不能进入（反之亦然）大多数情况下是无效的配置。 |'
- en: This overview should provide a basis for the three different permissions. Please
    take a good look and see whether you can fully understand what is presented there.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概述应该为这三种不同的权限提供了一个基础。请仔细看一看，看看你是否完全理解了那里呈现的内容。
- en: Now, it's about to get a little more complicated. While these permissions on
    both files and directories show what can and cannot be done for a user, how does
    Linux deal with multiple users? How does Linux keep track of file *ownership*,
    and how are files shared by multiple users?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，情况将变得更加复杂。虽然文件和目录上的这些权限显示了用户可以做什么和不能做什么，但Linux如何处理多个用户？Linux如何跟踪文件的*所有权*，文件如何被多个用户共享？
- en: Users, groups, and others
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户、组和其他
- en: 'Under Linux, every file is *owned* by exactly one user and one group. Every
    user has an identifying number, the **User ID** (**UID**). The same applies for
    a group: it is resolved by a **Group ID** (**GID**). Every user has exactly one
    UID and one *primary* GID; however, users can be members of multiple groups. In
    that case, the user will have one or more supplementary GIDs. You can see this
    for yourself by running the `id` command on your Ubuntu machine:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux下，每个文件都*由一个用户和一个组拥有*。每个用户都有一个标识号，**用户ID**（**UID**）。组也是一样：它由一个**组ID**（**GID**）解析。每个用户有一个UID和一个*主要*GID；然而，用户可以是多个组的成员。在这种情况下，用户将有一个或多个附加GID。您可以通过在Ubuntu机器上运行`id`命令来自己看到这一点：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding output, we can see the following things:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到以下内容：
- en: The `uid` for the `reader` user is `1000`; Linux typically starts numbering
    normal users at `1000`
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reader`用户的`uid`是`1000`；Linux通常从`1000`开始对普通用户进行编号'
- en: The `gid` is `1004`, which corresponds to the `reader` group; by default, Linux
    creates a group with the same name as the user (unless told specifically not to)
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gid`是`1004`，对应于`reader`组；默认情况下，Linux会创建一个与用户同名的组（除非明确告知不要创建）'
- en: Other groups include `adm`, `sudo`, and others
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他组包括 `adm`、`sudo` 和其他
- en: What does this mean? The current logged-in user has a `uid` of `1000`, a primary
    `gid` of `1004`, and a few supplementary groups, which makes sure that it has
    other privileges. For example, under Ubuntu, the `cdrom` group allows the user
    to have access to the disk drive. The `sudo` group allows the user to perform
    administrative commands, and the `adm` group allows the user to read administrative
    files.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着什么？当前登录的用户具有`uid`为`1000`，主要`gid`为`1004`，以及一些附加组，这确保它具有其他特权。例如，在Ubuntu下，`cdrom`组允许用户访问光驱。`sudo`组允许用户执行管理命令，`adm`组允许用户读取管理文件。
- en: 'While we typically refer to users and groups by name, this is just a representation
    for the UIDs and GIDs that Linux provides us with. On a system level, only the
    UID and GIDs are important for permissions. This makes it possible, for example,
    to have two users with the same username but different UIDs: the permissions for
    those users will not be the same. The other way around is also possible: two different
    usernames with the same UID—this causes the permissions for both users to be the
    same, at least on the UID level. However, both situations are terribly confusing
    and should not be used! As we''ll see later on, using groups to share permissions
    is by far the best solution for sharing files and directories.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们通常按名称引用用户和组，但这只是Linux为我们提供的UID和GID的表示。在系统级别上，只有UID和GID对权限很重要。这使得例如，有两个具有相同用户名但不同UID的用户成为可能：这些用户的权限将不同。反之亦然也是可能的：两个不同用户名但相同UID的用户，这将导致两个用户的权限在UID级别上至少是相同的。然而，这两种情况都非常令人困惑，不应该使用！正如我们将在后面看到的那样，使用组来共享权限是共享文件和目录的最佳解决方案。
- en: Another thing to keep in mind is that UIDs and GIDs are *local to the machine*.
    So if I have a user named bob with UID 1000 on machine A, and UID 1000 is mapped
    to user alice on machine B, transferring bob's files from machine A to machine
    B would result in the files being owned by alice on system B!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要记住的事情是，UID和GID是*本地的*。所以，如果我在机器A上有一个名为bob的用户，UID为1000，在机器B上UID为1000映射到用户alice，将bob的文件从机器A传输到机器B将导致文件在系统B上被alice拥有！
- en: 'The RWX permissions explained previously relate to the users and groups we''re
    discussing now. In essence, every file (or directory, which is just a different
    type of file), has the following attributes:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 之前解释的RWX权限与我们现在讨论的用户和组有关。实质上，每个文件（或目录，这只是一种不同类型的文件）都有以下属性：
- en: The file is owned by a *user*, which has (part of) the RWX permissions
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件由一个*用户*拥有，该用户具有（部分）RWX权限
- en: The file is also owned by a *group*, which again, has (part of) the RWX permissions
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件也由一个*组*拥有，再次，有（部分）RWX权限
- en: The file finally has RWX permissions for *others*, which means all different
    users that don't share the group
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件最终对*其他人*具有RWX权限，这意味着所有不共享该组的不同用户
- en: 'To determine if a user can read, write, or execute a file or directory, we
    need to look at the following attributes (not necessarily in this order):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定用户是否可以读取、写入或执行文件或目录，我们需要查看以下属性（不一定按照这个顺序）：
- en: Is the user the owner of the file? What RWX permissions does the owner have?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户是否是文件的所有者？所有者有什么RWX权限？
- en: Is the user part of the group that owns the file? What RWX permissions have
    been set for the group?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户是否是拥有文件的组的一部分？为组设置了什么RWX权限？
- en: Does the file have enough permissions on the *others* attribute?
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件在*其他*属性上有足够的权限吗？
- en: 'Let''s look at some simple examples before it gets too abstract. On your virtual
    machine, follow along with the following commands:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在变得太抽象之前，让我们看一些简单的例子。在您的虚拟机上，按照以下命令操作：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First, we ensure that we are in the `home` directory for the `reader` user.
    If not, we can move back there by using the `cd /home/reader` command or, alternatively,
    by just entering `cd` (without an argument, `cd` defaults to the user''s `home`
    directory!). We proceed by listing the contents of the directory in the long format,
    using `ls -l`, which shows us one file: `nanofile.txt`, from [Chapter 2](cdd5838b-007b-4e1a-a8dc-3c9ea8ebefca.xhtml), *Setting
    Up Your Local Environment* (don''t worry if you didn''t follow along there and
    do not have the file; we''ll be creating and manipulating files in a little bit).
    We use a new command, `touch`, to create an empty file. The argument we specify
    for `touch` is interpreted as the file name, as we can see when we list the files
    again:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确保我们在`reader`用户的`home`目录中。如果不是，我们可以使用`cd /home/reader`命令或者只输入`cd`（没有参数时，`cd`默认为用户的`home`目录！）。我们继续使用`ls
    -l`以长格式列出目录的内容，其中显示了一个文件：`nanofile.txt`，来自[第2章](cdd5838b-007b-4e1a-a8dc-3c9ea8ebefca.xhtml)，*设置您的本地环境*（如果您没有跟随那里并且没有该文件，不用担心；我们稍后将创建和操作文件）。我们使用一个新命令`touch`来创建一个空文件。我们指定给`touch`的参数被解释为文件名，当我们再次列出文件时可以看到。
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You''ll see the permission followed by two names: the username and the group
    name (in that order!). For our `testfile`, the user `reader` and members of the
    `reader` group can both read and write to the file, but cannot execute (on the
    position of the `x`, there is instead a `-`, indicating an absence of that permission).
    All other users, such as those that are neither *readers* nor part of the *reader*
    group (which, in this case, is really all other users), can only read the file
    due to the permission of others. This is also described in the following table:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到权限后面跟着两个名称：用户名和组名（按顺序！）。对于我们的`testfile`，用户`reader`和`reader`组的成员都可以读取和写入文件，但不能执行（在`x`的位置上，有一个`-`，表示没有该权限）。所有其他用户，例如既不是*读者*也不是*读者*组的成员（在这种情况下，实际上是所有其他用户），由于其他人的权限，只能读取文件。这也在下表中描述：
- en: '| **File type** **(1st character)** | **User permissions (2^(nd) to 4**^(th)
    **characters)**  | **Group permissions (5^(th) to 7^(th) characters)**  | **Others
    permissions (8^(th) to 10^(th) characters)**  | **User ownership** | **Group ownership**
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **文件类型** **（第一个字符）** | **用户权限（第2到4个字符）** | **组权限（第5到7个字符）** | **其他权限（第8到10个字符）**
    | **用户所有权** | **组所有权** |'
- en: '| - (normal file) | `rw-`, read and write, no execute | `rw-`, read and write,
    no execute | `r--`, only read | reader | reader |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| -（普通文件）| `rw-`，读和写，无执行| `rw-`，读和写，无执行| `r--`，只读| 读者| 读者|'
- en: 'If a **file** had full permissions for everyone, it would look like this: `-rwxrwxrwx`.
    For files that have all permissions for the owner and the group, but none for
    others, it would be `-rwxrwx---`. **Directories** with full permissions on user
    and group, but none for others, are represented as `drwxrwx---`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个**文件**对每个人都有完全权限，它会是这样的：`-rwxrwxrwx`。对于所有者和组都有所有权限，但其他人没有任何权限的文件，它将是`-rwxrwx---`。对于用户和组都有所有权限，但其他人没有任何权限的**目录**，表示为`drwxrwx---`。
- en: 'Let''s look at another example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `home` directory for the systems'' superuser is `/root/`. We can see from
    the first character on the line that it is a `d`, for *directory*. It has RWX
    (one last time: read, write, execute) permissions for the owner `root`, and no
    permissions for the group (also `root`), nor for others (as denoted by `---`).
    These permissions can only mean one thing: **only the user** **root** **can enter
    or manipulate this directory!** Let''s see if our assumption is correct. Remember,
    *entering* a directory requires the `x` permission, while *listing* the directory
    contents the `r` permission. We should not be able to do either, since we''re
    neither the `root` user or in the root group. In this case, the permissions of
    others will be applied, this being `---`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 系统超级用户的`home`目录是`/root/`。我们可以从行的第一个字符看到它是一个`d`，表示*目录*。它对所有者`root`具有RWX（最后一次：读取、写入、执行）权限，对组（也是`root`）没有权限，对其他人（由`---`表示）也没有权限。这些权限只能意味着一件事：**只有用户**
    **root** **可以进入或操作此目录！**让我们看看我们的假设是否正确。请记住，*进入*目录需要`x`权限，而*列出*目录内容需要`r`权限。我们既不是`root`用户也不在root组，因此我们既不能做任何一件事。在这种情况下，将应用其他人的权限，即`---`：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Manipulating file permissions and ownership
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作文件权限和所有权
- en: After reading the first part of this chapter, you should have a decent understanding
    of Linux file permissions, and how read, write, and executed are used on a user,
    group, and other levels to ensure that files are exposed exactly as required.
    However, up until this point, we've been dealing with static permissions. When
    administering a Linux system, you will most likely spend a fair bit of time adjusting
    and troubleshooting permissions. In this part of the book, we'll be exploring
    the commands we can use to manipulate the permissions on files.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章的第一部分后，您应该对Linux文件权限有了相当好的理解，以及如何在用户、组和其他级别上使用读取、写入和执行来确保文件的暴露正好符合要求。然而，直到这一点，我们一直在处理静态权限。在管理Linux系统时，您很可能会花费大量时间调整和解决权限问题。在本书的这一部分中，我们将探讨可以用来操作文件权限的命令。
- en: chmod, umask
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: chmod，umask
- en: 'Let''s circle back to our `testfile`. It has the following permissions: `-rw-rw----`.
    Read/writable by user and group, readable by others. While these permissions might
    be fine for most files, they are definitely not a great fit for all files. What
    about private files? You would not want those to be readable by everyone, perhaps
    not even by group members.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`testfile`。它具有以下权限：`-rw-rw----`。用户和组可读/写，其他人可读。虽然这些权限对大多数文件来说可能是合适的，但对于所有文件来说肯定不是一个很好的选择。私人文件呢？您可能不希望这些文件被所有人读取，甚至可能不希望被组成员读取。
- en: 'The Linux command to change permissions on a file or directory is `chmod`,
    which we like to read as **ch**ange file **mod**e. `chmod` has two operating modes:
    symbolic mode and numeric/octal mode. We will begin by explaining symbolic mode
    (which is easier to understand), before we move to octal mode (which is faster
    to use).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，更改文件或目录的权限的命令是`chmod`，我们喜欢将其读作**ch**ange file **mod**e。`chmod`有两种操作模式：符号模式和数字/八进制模式。我们将首先解释符号模式（更容易理解），然后再转到八进制模式（更快速使用）。
- en: Something we have not yet introduced is the command to view manuals for commands.
    The command is simply `man`, followed by the command for which you'd like to see
    the manual of. In this case, `man chmod` will place us into the `chmod` manual
    pager, which uses the same navigation controls as you learned for Vim. Remember,
    quitting is done by entering `:q`. In this case, just `q` is enough. Take a look
    at the `chmod` manual now and read at least the **description** header; it will
    make the explanation that follows clearer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有介绍的是查看命令手册的命令。该命令就是`man`，后面跟着你想要查看手册的命令。在这种情况下，`man chmod`会将我们放入`chmod`手册分页器中，它使用与你学习Vim相同的导航控件。记住，退出是通过输入`:q`来完成的。在这种情况下，只需输入`q`就足够了。现在看一下`chmod`手册，至少读一下**description**标题；这将使接下来的解释更清晰。
- en: Symbolic mode uses the RWX construct we saw before with the UGOA letters. This
    might seem new, but it actually isn't! **U**sers, **G**roups, **O**thers, and
    **A**ll are used to denote which permissions we're changing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 符号模式使用了我们之前看到的UGOA字母的RWX构造。这可能看起来很新，但实际上并不是！**U**sers、**G**roups、**O**thers和**A**ll用于表示我们正在更改的权限。
- en: 'To add permissions, we tell `chmod` who (users, groups, others, or all) we
    are doing this for, followed by the permission we want to add. `chmod u+x <filename>`,
    for example, will add the execute permission for the user. Similarly, removing
    permissions with `chmod` is done as follows: `chmod g-rwx <filename>`. Notice
    that we use the `+` sign to add permissions and the `-` sign to remove permissions.
    If we do not specify user, group, others, or all, **all** is used by default.
    Let''s try this out on our Ubuntu machine:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加权限，我们告诉`chmod`我们（用户、组、其他或所有）为谁做这个操作，然后是我们想要添加的权限。例如，`chmod u+x <filename>`将为用户添加执行权限。类似地，使用`chmod`删除权限的方法如下：`chmod
    g-rwx <filename>`。请注意，我们使用`+`号来添加权限，使用`-`号来删除权限。如果我们没有指定用户、组、其他或所有，**所有**将默认使用。让我们在我们的Ubuntu机器上试一下：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we added the execute permission for the user to the `testfile`. Next,
    we removed read, write, and execute from the group, resulting in `-rwx---r--`.
    In this scenario, group members are still able to read the file, however, *because
    everyone can still read the file*. Not the perfect permissions for privacy, to
    say the least. Lastly, we do not specify anything before the `-r`, which effectively
    removes read access for the user, group, and others, causing the file to end up
    as `--wx------`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为`testfile`添加了用户的执行权限。接下来，我们从组中移除了读取、写入和执行权限，结果是`-rwx---r--`。在这种情况下，组成员仍然可以读取文件，然而，*因为每个人仍然可以读取文件*。可以说这不是隐私的完美权限。最后，我们在`-r`之前没有指定任何内容，这实际上移除了用户、组和其他的读取权限，导致文件最终变成了`--wx------`。
- en: 'Being able to write and execute a file you can''t read is a bit weird. Let''s
    fix it and look at how octal permissions work! We can use the **verbose** option
    on `chmod` to make it print more information by using the `-v` flag:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 能够写和执行一个你无法阅读的文件有点奇怪。让我们来修复它，看看八进制权限是如何工作的！我们可以使用`chmod`的**verbose**选项，通过使用`-v`标志来打印更多信息：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, we now get output from `chmod`! Specifically, we can see the
    octal mode. Before we changed the file, the mode was `0300`, and after adding
    read for the user, it jumped up to `0700`. What do these numbers mean?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们现在从`chmod`得到了输出！具体来说，我们可以看到八进制模式。在我们改变文件之前，模式是`0300`，在为用户添加读取权限后，它跳到了`0700`。这些数字代表什么？
- en: 'It all has to do with the binary implementation of the permission. For all
    three levels (user, group, others), there are 8 different possible permissions
    when combining read, write, and execute, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都与权限的二进制实现有关。对于所有三个级别（用户、组、其他），在结合读取、写入和执行时，有8种不同的可能权限，如下所示：
- en: '| **Symbolic** | **Octal** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **八进制** |'
- en: '| `---` | 0 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `---` | 0 |'
- en: '| `--x` | 1 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `--x` | 1 |'
- en: '| `-w-` | 2 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `-w-` | 2 |'
- en: '| `-wx` | 3 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `-wx` | 3 |'
- en: '| `r--` | 4 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `r--` | 4 |'
- en: '| `r-x` | 5 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `r-x` | 5 |'
- en: '| `rw-` | 6 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `rw-` | 6 |'
- en: '| `rwx` | 7 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `rwx` | 7 |'
- en: 'Basically, the octal value is between 0 and 7, for a total of 8 values. This
    is the reason it''s called octal: from the Latin/Greek representation of 8, **octo**.
    The read permission is given the value of 4, write permission the value of 2,
    and the execute permission the value of 1.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，八进制值在0和7之间，总共有8个值。这就是为什么它被称为八进制：来自于拉丁语/希腊语中8的表示，**octo**。读取权限被赋予值4，写入权限被赋予值2，执行权限被赋予值1。
- en: By using this system, the value of 0 to 7 can always be uniquely related to
    an RWX value. RWX is *4+2+1 = 7*, RX is *4+1 = 5*, and so on.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这个系统，0到7的值总是可以唯一地与RWX值相关联。RWX是*4+2+1 = 7*，RX是*4+1 = 5*，依此类推。
- en: 'Now that we know how octal representations work, we can use them to modify
    the file permissions with `chmod`. Let''s give the test file full permissions
    (RWX or 7) for user, group, and others in a single command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们知道了八进制表示是如何工作的，我们可以使用它们来使用`chmod`修改文件权限。让我们在一个命令中为用户、组和其他给予测试文件完全权限（RWX或7）： '
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, `chmod` accepts four numbers as the argument. The first number
    is in regards to a special type of permission called the sticky bit; we won't
    be discussing this, but we have included material in the *Further reading* section
    for those interested. In these examples, it is always set to `0`, so no special
    bits are set. The second number maps to the user permissions, the third to group
    permissions, and the fourth, unsurprisingly, to the others permissions.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`chmod`接受四个数字作为参数。第一个数字涉及到一种特殊类型的权限，称为粘滞位；我们不会讨论这个，但我们已经在*Further reading*部分中包含了相关材料，供感兴趣的人参考。在这些示例中，它总是设置为`0`，因此没有设置特殊位。第二个数字映射到用户权限，第三个映射到组权限，第四个，不出所料，映射到其他权限。
- en: 'If we wanted to do this using symbolic representation, we could have used the `chmod
    a+rwx` command. So, why is octal faster than, as we said earlier on? Let''s see
    what happens if we want to have different permissions for each level, for example, `-rwxr-xr--`.
    If we want to do this with symbolic representation, we''d need to use either three
    commands or one chained command (another function of `chmod`):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用符号表示法来做到这一点，我们可以使用`chmod a+rwx`命令。那么，为什么八进制比我们之前说的更快呢？让我们看看如果我们想要为每个级别设置不同的权限会发生什么，例如`-rwxr-xr--`。如果我们想要用符号表示法来做到这一点，我们需要使用三个命令或一个链接的命令（`chmod`的另一个功能）：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see from the `chmod u+rwx,g+rx,o+r testfile` command, things have
    gotten a bit complicated. Using octal notation, however, the command is much simpler:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从`chmod u+rwx,g+rx,o+r testfile`命令中可以看出，事情变得有点复杂。然而，使用八进制表示法，命令要简单得多：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Basically, the difference is mainly using *imperative* notation (add or remove
    permissions) versus *declarative* notation (set it to these values). In our experience,
    declarative is almost always the better/safer option. With imperative, we need
    to first check the current permissions and mutate them; with declarative, we can
    just specify in a single command exactly what we want.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，主要区别在于使用*命令式*表示法（添加或删除权限）与*声明式*表示法（将其设置为这些值）。根据我们的经验，声明式几乎总是更好/更安全的选择。使用命令式，我们需要首先检查当前的权限并对其进行变异；而使用声明式，我们可以在单个命令中指定我们想要的内容。
- en: It might be obvious by now, but we prefer to use the octal notation. Besides
    the benefits from shorter, simpler commands that are handled declaratively, another
    benefit is that most examples you will find online use the octal notation as well.
    To fully understand these examples, you will need to at least understand octals.
    And, if you need to understand them anyway, nothing beats using them in your day
    to day life!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能很明显了，但我们更喜欢使用八进制表示法。除了从更短、更简单的命令中受益，这些命令是以声明方式处理的，另一个好处是大多数您在网上找到的示例也使用八进制表示法。要完全理解这些示例，您至少需要了解八进制。而且，如果无论如何都需要理解它们，那么在日常生活中使用它们是最好的！
- en: 'Earlier, when we used the `touch` command, we ended up with a file that could
    be read and written to by both the user and group, and was readable to others.
    These seem to be default permissions, but where do they come from? And how can
    we manipulate them? Let''s meet `umask`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，当我们使用`touch`命令时，我们最终得到了一个文件，该文件可以被用户和组读取和写入，并且对其他人是可读的。这些似乎是默认权限，但它们是从哪里来的？我们如何操纵它们？让我们来认识一下`umask`：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `umask` session is used to determine the file permissions for newly created
    files and directories. For files, the following is done: take the maximum octal
    value for files, `0666`, and subtract the `umask` (in this case, `0002`), which
    gives us `0664`. This would mean that newly created files are `-rw-rwr--`, which
    is exactly what we saw for our `testfile`. Why do we take `0666` and not `0777`,
    you might ask? This is a protection that Linux provides; if we were to use `0777`,
    most files would be created as executable. Executable files can be dangerous,
    and the design decision was made that files should only be executable when explicitly
    set that way. So, with the current implementation, there is no such thing as *accidentally*
    creating an executable file. For directories, the normal octal value of `0777`
    is used, which means that directories are created with `0775`, `-rwxrwxr-x` permissions.
    We can check this out by creating a new directory with the `mkdir` command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`umask`会话用于确定新创建的文件和目录的文件权限。对于文件，执行以下操作：取文件的最大八进制值`0666`，然后减去`umask`（在本例中为`0002`），这给我们`0664`。这意味着新创建的文件是`-rw-rwr--`，这正是我们在`testfile`中看到的。你可能会问，为什么我们使用`0666`而不是`0777`？这是Linux提供的一种保护措施；如果我们使用`0777`，大多数文件将被创建为可执行文件。可执行文件可能是危险的，因此设计决策是文件只有在明确设置为可执行时才能执行。因此，根据当前的实现，没有*意外*创建可执行文件这样的事情。对于目录，使用正常的八进制值`0777`，这意味着目录以`0775`，`-rwxrwxr-x`权限创建。我们可以通过使用`mkdir`命令创建一个新目录来验证这一点：'
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Because the execute permission on a directory is much less dangerous (remember,
    it is used to determine if you can move into the directory), this implementation
    differs from files.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因为目录的执行权限要少得多（记住，它用于确定您是否可以进入目录），所以这个实现与文件不同。
- en: 'We have one last trick we''d like to showcase with regards to `umask`. In specific
    cases, we''d like to determine default values for files and directories ourselves.
    We can also do this using the `umask` command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`umask`，我们还有一个技巧要展示。在特定情况下，我们想要自己确定文件和目录的默认值。我们也可以使用`umask`命令来做到这一点：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding example, you can see that running the `umask` command without
    arguments prints the current umask. Running it with a valid umask value as an
    argument changes umask to that value, which is then used when creating new files
    and directories. Compare `umaskfile` and `umaskdir` with the earlier `testfile`
    and `testdir` in the preceding output. This is very useful if we want to create
    files that are private by default!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，您可以看到运行`umask`命令而不带参数会打印当前的umask。如果以有效的umask值作为参数运行它，将会改变umask为该值，然后在创建新文件和目录时使用。将上述输出中的`umaskfile`和`umaskdir`与之前的`testfile`和`testdir`进行比较。如果我们想要默认创建私有文件，这将非常有用！
- en: sudo, chown, and chgrp
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sudo、chown和chgrp
- en: 'So far, we have seen how we can manipulate the (basic) permissions for files
    and directories. However, we haven''t dealt with changing either the owner or
    the group for a file. It would be a little impractical to always have to work
    with users and groups as they were at creation time. For Linux, we can use two
    tools to change the owner and group: **ch**ange **own**er (`chown`) and **ch**ange
    **gr**ou**p** (`chgrp`). However, there is one very important thing to note: these
    commands can only be executed for someone with root permissions (which will, typically,
    be the `root` user). So, before we introduce you to `chown` and `chgrp`, let''s
    look at `sudo`!'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何操纵文件和目录的（基本）权限。然而，我们还没有处理更改文件的所有者或组。总是必须按照创建时的用户和组来工作有点不切实际。对于Linux，我们可以使用两个工具来更改所有者和组：**ch**ange
    **own**er（`chown`）和**ch**ange **gr**ou**p**（`chgrp`）。然而，有一件非常重要的事情要注意：这些命令只能由具有root权限的人执行（通常是`root`用户）。因此，在我们向你介绍`chown`和`chgrp`之前，让我们先看看`sudo`！
- en: sudo
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sudo
- en: The `sudo` command was originally named for **su**peruser **do**, which, as
    the name implies, gives you a chance to perform an action as the root superuser.
    The `sudo` command uses the `/etc/sudoers` file to determine if users are allowed
    to elevate to superuser permissions. Let's see how it works!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo`命令最初是为**su**peruser **do**命名的，正如其名字所暗示的，它给了你一个机会以root超级用户的身份执行操作。`sudo`命令使用`/etc/sudoers`文件来确定用户是否被允许提升到超级用户权限。让我们看看它是如何工作的！'
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We first try to look at the contents of `/etc/sudoers` as a normal user. When
    that gives us a `Permission denied` error, we look at the permissions on the file.
    From the `-r--r----- 1 root root` line, it becomes obvious that only the `root`
    user or members of the `root` group can read the file. To elevate to root privileges,
    we use the `sudo` command *in front of* the command we want to run, which is `cat
    /etc/sudoers`. For verification, Linux will always ask the user for their password.
    This password is then kept in memory for about 5 minutes by default, so you do
    not have to type your password every time if you've recently entered it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先尝试以普通用户的身份查看`/etc/sudoers`的内容。当这给我们一个`Permission denied`错误时，我们查看文件的权限。从`-r--r-----
    1 root root`这一行，很明显只有`root`用户或`root`组的成员才能读取该文件。为了提升到root权限，我们使用`sudo`命令*在*我们想要运行的命令前面，即`cat
    /etc/sudoers`。为了验证，Linux会始终要求用户输入密码。默认情况下，这个密码会被保存在内存中大约5分钟，所以如果你最近输入过密码，你就不必每次都输入密码。
- en: 'After entering the password, the `/etc/sudoers` file is printed for us! It
    seems that `sudo` did indeed provide us with superuser permissions. How that works
    is also explained by the `/etc/sudoers` file. The `# Allow members of group sudo
    to execute any command` line is a comment (since it starts with a `#`; more on
    this later) and tells us that the line below gives all users of the `sudo` group
    permissions for any commands. On Ubuntu, the default created user is considered
    an administrator and is a member of this group. Use the `id` command to verify
    this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 输入密码后，`/etc/sudoers`文件就会被打印出来！看来`sudo`确实给了我们超级用户权限。这是如何工作的也可以通过`/etc/sudoers`文件来解释。`#
    Allow members of group sudo to execute any command`这一行是一个注释（因为它以`#`开头；稍后会详细介绍），告诉我们下面的行给了`sudo`组的所有用户任何命令的权限。在Ubuntu上，默认创建的用户被认为是管理员，并且是这个组的成员。使用`id`命令来验证这一点：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `sudo` command has another excellent use: switching to the `root` user!
    For this, use the `--login` flag, or its shorthand, `-i`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo`命令还有另一个很好的用途：切换到`root`用户！为此，使用`--login`标志，或者它的简写，`-i`：'
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the prompt, you will see that the username has changed from `reader` to
    `root`. Furthermore, the last character in your prompt is now a `#` instead of
    a `$`. This is also used to denote the current elevated permissions. You can exit
    this elevated position by using the built-in `exit` shell:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示符中，你会看到用户名已经从`reader`变成了`root`。此外，你的提示符中的最后一个字符现在是`#`而不是`$`。这也用于表示当前的提升权限。你可以使用内置的`exit`
    shell退出这个提升的位置：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember, the `root` user is the superuser of the system that can do everything.
    And with everything, we really mean everything! Unlike other operating systems,
    if you tell Linux to delete the root file system and everything below it, it will
    happily oblige (right up until the point it has destroyed too much to work properly
    anymore). Do not expect an `Are you sure?` prompt either. Be very, very careful
    with `sudo` commands or anything in a root prompt.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`root`用户是系统的超级用户，可以做任何事情。而且，我们真的是指任何事情！与其他操作系统不同，如果你告诉Linux删除根文件系统和其下的一切，它会乐意遵从（直到它破坏了太多以至于无法正常工作为止）。也不要指望有`Are
    you sure?`的提示。对于`sudo`命令或者root提示中的任何东西都要非常小心。
- en: chown, chgrp
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: chown，chgrp
- en: 'After the little `sudo` detour, we can get back to file permissions: how do
    we change the ownership of files? Let''s start with changing the group using `chgrp`.
    The syntax is as follows: `chgrp <groupname> <filename>`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一小段`sudo`的绕道之后，我们可以回到文件权限：我们如何改变文件的所有权？让我们从使用`chgrp`来改变组开始。语法如下：`chgrp <groupname>
    <filename>`：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we list the contents using `ls`. Next, we try to use `chgrp` to change
    the group of the `umaskfile` file to games. However, since this is a privileged
    operation and we did not start the command with `sudo`, it fails with the `Operation
    not permitted` error message. Next, we use the correct `sudo chgrp games umaskfile` command,
    which does not give us feedback; generally, this is a good sign in Linux. We list
    the files again to make sure that this is the case, and we can see that the group
    has changed to `games` for the `umaskfile`!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`ls`列出内容。接下来，我们尝试使用`chgrp`将`umaskfile`文件的组更改为games。然而，由于这是一个特权操作，我们没有以`sudo`开头启动命令，所以它失败了，显示`Operation
    not permitted`错误消息。接下来，我们使用正确的`sudo chgrp games umaskfile`命令，这通常是Linux中的一个好迹象。我们再次列出文件，确保情况是这样，我们可以看到`umaskfile`的组已经更改为`games`！
- en: 'Let''s do the same, but now for the user, by using the `chown` command. The
    syntax is the same as `chgrp`: `chown <username> <filename>`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做同样的事情，但现在是为了用户，使用`chown`命令。语法与`chgrp`相同：`chown <username> <filename>`：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As we can see, we have now changed the file ownership from `reader:reader`
    to `pollinate:games`. However, there is one little trick that''s so convenient
    that we''d like to show you it right away! You can actually use `chown` to change
    both users and groups by using the following syntax: `chown <username>:<groupname>
    <filename>`. Let''s see if this can restore the `umaskfile` to its original ownership:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们现在已经将文件所有权从`reader:reader`更改为`pollinate:games`。然而，有一个小技巧非常方便，我们想立刻向您展示！您实际上可以使用`chown`通过以下语法更改用户和组：`chown
    <username>:<groupname> <filename>`。让我们看看这是否可以将`umaskfile`恢复到其原始所有权：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We used random users and groups in the preceding examples. If you want to see
    which groups are present on the system, inspect the `/etc/group` file. For users,
    the same information can be found in `/etc/passwd`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了随机用户和组。如果要查看系统上存在哪些组，请检查`/etc/group`文件。对于用户，相同的信息可以在`/etc/passwd`中找到。
- en: Working with multiple users
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与多个用户一起工作
- en: As we've stated before, Linux is inherently a multi-user system, especially
    in the context of a Linux server, where these systems are often administered not
    by a single user, but often a (large) team. Each user on a server has it own set
    of permissions. Imagine, for example, a server where three departments need to
    be development, operations, and security. Development and operations both have
    their own stuff there, but also need to share some other things. The security
    department needs to be able to view everything to ensure proper compliance and
    adherence to security guidelines. How could we arrange such a structure? Let's
    make it happen!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，Linux本质上是一个多用户系统，特别是在Linux服务器的情况下，这些系统通常不是由单个用户，而是经常是（大型）团队管理。服务器上的每个用户都有自己的权限集。例如，想象一下，一个服务器需要开发、运营和安全三个部门。开发和运营都有自己的东西，但也需要共享其他一些东西。安全部门需要能够查看所有内容，以确保符合安全准则和规定。我们如何安排这样的结构？让我们实现它！
- en: First, we need to create some users. For each department, we will create a single
    user, but since we're going to ensure permissions on the group level, this will
    work just as well for 5, 10, or 100 users in each department. We can create users
    with the `useradd` command. In its basic form, we can just use `useradd <username>`,
    and Linux will handle the rest via default values. Obviously, as with almost everything
    in Linux, this is highly customizable; check the man page (`man useradd`) for
    more information.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一些用户。对于每个部门，我们将创建一个单一用户，但由于我们将确保组级别的权限，因此对于每个部门中的5、10或100个用户来说，这也同样有效。我们可以使用`useradd`命令创建用户。在其基本形式中，我们可以只使用`useradd
    <username>`，Linux将通过默认值处理其余部分。显然，与Linux中的几乎所有内容一样，这是高度可定制的；有关更多信息，请查看man页面（`man
    useradd`）。
- en: 'As was the case with `chown` and `chgrp`, `useradd` (and later `usermod`) is
    a privileged command, which we will execute with `sudo`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与`chown`和`chgrp`一样，`useradd`（以及后来的`usermod`）是一个特权命令，我们将使用`sudo`来执行：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As a last reminder, we've showed you what happens when you forget `sudo`. While
    the error message is technically fully correct (you need root permissions to edit
    `/etc/passwd`, where user information is stored), it might not be fully obvious
    why the command is failing, especially because of the misleading `try again later!` error.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后提醒一下，我们向您展示了当您忘记`sudo`时会发生什么。虽然错误消息在技术上是完全正确的（您需要root权限才能编辑`/etc/passwd`，其中存储了用户信息），但可能不太明显命令失败的原因，特别是因为误导性的`稍后重试！`错误。
- en: 'With `sudo`, however, we are able to add three users: `dev-user1`, `ops-user1`,
    and `sec-user1`. When we inspect these users in order, we can see that their `uid`
    goes up by one each time. We can also see that a group with the same name as the
    user is created, and that that is the sole group of which the users are a member.
    Groups also have their `gid`, which is incremented by one for each next user.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用`sudo`，我们可以添加三个用户：`dev-user1`、`ops-user1`和`sec-user1`。当我们按顺序检查这些用户时，我们可以看到他们的`uid`每次增加一个。我们还可以看到与用户同名的组被创建，并且这是用户的唯一组成员。组也有它们的`gid`，每次下一个用户都会增加一个。
- en: 'So, now we have the users in place, but we need shared groups. For this, we
    have a similar command (both in name and operation): `groupadd`. Check the man
    page for `groupadd` and add three groups corresponding to our departments:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经有了用户，但我们需要共享组。为此，我们有一个类似的命令（在名称和操作上都相同）：`groupadd`。查看`groupadd`的man页面，并添加三个对应于我们部门的组：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To see which groups are already available, you can check out the `/etc/group`
    file (with, for example, `less` or `cat`). Once you''re satisfied, we now have
    the users and groups in place. But how do we make the users members of the groups?
    Enter `usermod` (which stands for **user** **mod**ify). The syntax to set a user''s
    primary group is as follows: `usermod -g <groupname> <username>`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看系统上已有哪些组，可以查看`/etc/group`文件（例如使用`less`或`cat`）。一旦满意，我们现在已经有了用户和组。但是我们如何使用户成为组的成员？输入`usermod`（表示**user**
    **mod**ify）。设置用户的主要组的语法如下：`usermod -g <groupname> <username>`：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'What we have accomplished now is closer to our goal, but we''re not there yet.
    So far, we have only ensured that multiple developers can share files by all being
    in the development group. But how about the shared folder between development
    and operations? And how can security monitor everything? Let''s create some directories
    (using `mkdir`, which stands for **m**a**k**e **dir**ectory) with the correct
    groups and see how far we can get:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现的更接近我们的目标，但我们还没有到达那里。到目前为止，我们只确保多个开发人员可以通过所有在开发组中的文件共享文件。但是开发和运营之间的共享文件夹呢？安全性如何监视所有内容？让我们创建一些具有正确组的目录（使用`mkdir`，表示**m**a**k**e
    **dir**ectory），看看我们能走多远：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We now have the following structure: a `/data/` top level directory, which
    contains the directories `dev-files` and `ops-files`, which are owned by the `development`
    and `operations` groups, respectively. Now, let''s fulfill the requirement that
    security can go into both directories and manage the files! Apart from using `usermod`
    to change the main groups, we can also append users to extra groups. In this case,
    the syntax is `usermod -a -G <groupnames> <username>`. Let''s add `sec-user1`
    to the `development` and `operations` groups:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有以下结构：一个`/data/`顶级目录，其中包含`dev-files`和`ops-files`目录，分别由`development`和`operations`组拥有。现在，让我们满足安全部门可以进入这两个目录并管理文件的要求！除了使用`usermod`来更改主要组，我们还可以将用户追加到额外的组中。在这种情况下，语法是`usermod
    -a -G <groupnames> <username>`。让我们将`sec-user1`添加到`development`和`operations`组中：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The user from the security department is now a member of all new groups: security,
    development, and operations. Since both `/data/dev-files/` and `/data/ops-files/`
    do not have permissions for *others*, our current user should not be able to enter
    either, but `sec-user1` should be. Let''s see if this is correct:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 安全部门的用户现在是所有新组的成员：安全、开发和运维。由于`/data/dev-files/`和`/data/ops-files/`都没有*其他人*的权限，我们当前的用户不应该能够进入其中任何一个，但`sec-user1`应该可以。让我们看看这是否正确：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you followed along with this example, you should see that we introduced
    a new command: `su`. Short for **s**witch **u**ser, it allows us to, well, switch
    between users. If you prefix it with `sudo`, you can switch to a user without
    needing the password for that user, as long as you have those privileges. Otherwise,
    you will have to enter the password (which is hard in this case, since we haven''t
    set a password for the user). As you might have noticed, the shell is different
    for the new user. That''s because we haven''t loaded any configuration (which
    is automatically done for the default user). Don''t worry about that, though—it''s
    still a fully functioning shell! Our test succeeded: we were able to move into
    the `dev-files` directory, even though we are not a developer. We were even able
    to create a file. If you want, verify that the same is possible for the `ops-files`
    directory.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您跟着这个例子，您应该会发现我们引入了一个新命令：`su`。它是**s**witch **u**ser的缩写，它允许我们在用户之间切换。如果您在前面加上`sudo`，您可以切换到一个用户，而不需要该用户的密码，只要您有这些权限。否则，您将需要输入密码（在这种情况下很难，因为我们还没有为用户设置密码）。您可能已经注意到，新用户的shell是不同的。这是因为我们还没有加载任何配置（这是为默认用户自动完成的）。不过，不用担心——它仍然是一个完全功能的shell！我们的测试成功了：我们能够进入`dev-files`目录，即使我们不是开发人员。我们甚至能够创建一个文件。如果您愿意，可以验证在`ops-files`目录中也是可能的。
- en: 'Finally, let''s create a new group, `devops`, which we will use to share files
    between developers and operations. After creating the group, we will add both `dev-user1`
    and `ops-user1` to this group, in the same way we added `sec-user1` to the `development`
    and `operations` groups:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个新组`devops`，我们将使用它来在开发人员和运维之间共享文件。创建组后，我们将像将`sec-user1`添加到`development`和`operations`组一样，将`dev-user1`和`ops-user1`添加到这个组中：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We now have a shared directory, `/data/devops-files/`, where both `dev-user1`
    and `ops-user1` can enter and create files.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个共享目录，`/data/devops-files/`，`dev-user1`和`ops-user1`都可以进入并创建文件。
- en: 'As an exercise, do any of the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，可以执行以下任何一项：
- en: Add `sec-user1` to the `devops` group, so that it can also audit the shared
    files
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`sec-user1`添加到`devops`组，以便它也可以审计共享文件
- en: Verify that both `dev-user1` and `ops-user1` can write files in the shared directories
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证`dev-user1`和`ops-user1`是否可以在共享目录中写入文件
- en: 'Understand why `dev-user1` and `ops-user1` can only read each other''s files
    in the `devops` directory, but cannot edit them (hint: the next section of this
    chapter, *Advanced permissions*, will tell you how to solve this with SGID)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解为什么`dev-user1`和`ops-user1`只能读取`devops`目录中的对方文件，但不能编辑它们（提示：本章的下一节*高级权限*将告诉您如何使用SGID解决这个问题）
- en: Advanced permissions
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级权限
- en: This covers the basic permissions for Linux. There are, however, some advanced
    topics that we'd like to point out, but we will not be discussing them at length.
    For more information on these topics, check the *Further reading* section at the
    end of this chapter. We have included a reference for file attributes, special
    file permissions, and access control lists.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了Linux的基本权限。然而，还有一些高级主题，我们想指出，但我们不会详细讨论它们。有关这些主题的更多信息，请查看本章末尾的*进一步阅读*部分。我们已经包括了文件属性、特殊文件权限和访问控制列表的参考。
- en: File attributes
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件属性
- en: Files can also have attributes that are expressed in another way than the permissions
    we have seen so far. An example of this is making a file immutable (a fancy word,
    which means it cannot be changed). An immutable file still has normal ownership
    and group and RWX permissions, but it will not allow the user to change it, even
    if it contains the writable permission. Another characteristic of this is that
    the file cannot be renamed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 文件也可以具有以不同于我们目前所见的权限表达的属性。一个例子是使文件不可变（一个花哨的词，意思是它不能被更改）。不可变文件仍然具有正常的所有权和组以及RWX权限，但它不允许用户更改它，即使它包含可写权限。另一个特点是该文件不能被重命名。
- en: Other file attributes include *undeletable*, *append only*, and *compressed*.
    For more information on file attributes, check the man pages for the `lsattr`
    and `chattr` commands (`man lsattr` and `man chattr`).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 其他文件属性包括*不可删除*、*仅追加*和*压缩*。有关文件属性的更多信息，请查看`lsattr`和`chattr`命令的man页面（`man lsattr`和`man
    chattr`）。
- en: Special file permissions
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊文件权限
- en: 'As you might have noticed in the part about octal notation, we always start
    the notation with a zero (0775, 0640, and so on). Why do we include the zero if
    we do not use it? That position is reserved for special file permissions: SUID,
    SGID, and the sticky bit. They have a similar octal notation (where SUID is 4,
    SGID is 2, and the sticky bit is 1) and are used in the following manner:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经在八进制表示部分注意到的那样，我们总是以零开头（0775，0640等）。如果我们不使用它，为什么要包括零？该位置保留用于特殊文件权限：SUID、SGID和粘滞位。它们具有类似的八进制表示法（其中SUID为4，SGID为2，粘滞位为1），并且以以下方式使用：
- en: '|  | **Files** | **Directories** |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|  | **文件** | **目录** |'
- en: '| **SUID** | Files are executed with the permissions of the owner, regardless
    of which user executes it. | Does nothing. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| **SUID** | 文件以所有者的权限执行，无论哪个用户执行它。 | 什么也不做。 |'
- en: '| **SGID** | Files are executed with the permissions of the group, regardless
    of which user executes it. | Files that are created in this directory get the
    same group as the directory. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| **SGID** | 文件以组的权限执行，无论哪个用户执行它。 | 在此目录中创建的文件获得与目录相同的组。 |'
- en: '| **Sticky bit** | Does nothing. | User can only delete their own files within
    this directory. See the `/tmp/` directory for its most famous use. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **粘滞位** | 什么也不做。 | 用户只能删除他们在这个目录中的文件。查看`/tmp/`目录以了解其最著名的用途。 |'
- en: Access Control Lists (ACLs)
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问控制列表（ACL）
- en: ACLs are a way to increase the flexibility of the UGO/RWX system. Using `setfacl`
    (**set** **f**ile **acl**) and `getfacl` (**get** **f**ile **acl**), you can set
    additional permissions for files and directories. So, for example, using ACLs,
    you could say that, while the `/root/` directory is normally only accessible by
    the `root` user, it could also be read by the `reader` user. The other way to
    accomplish this, which is by adding the `reader` user to the `root` group, also
    gives the `reader` user many other privileges on the system (anything that has
    permissions on the root group has then been granted to the reader user!). While
    ACLs are not often used in practice in our experience, for edge cases they can
    be the difference between a complex solution and a simple one.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ACL是增加UGO/RWX系统灵活性的一种方式。使用`setfacl`（**set** **f**ile **acl**）和`getfacl`（**get**
    **f**ile **acl**），您可以为文件和目录设置额外的权限。因此，例如，使用ACL，您可以说，虽然`/root/`目录通常只能由`root`用户访问，但也可以被`reader`用户读取。另一种实现这一点的方法是将`reader`用户添加到`root`组中，这也给了`reader`用户系统上的许多其他特权（任何对root组有权限的东西都已经授予了reader用户！）。尽管根据我们的经验，ACL在实践中并不经常使用，但对于边缘情况，它们可能是复杂解决方案和简单解决方案之间的区别。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have looked at the Linux permissions scheme. We have learned
    that there are two main axes on which permissions are arranged: file permissions
    and file ownership. For file permissions, each file has an allowance (or disallowance)
    on *read*, *write*, and *execute* permissions. How these permissions work differs
    for files and directories. Permissions are applied by using ownership: a file
    is always owned by a user and a group. Besides the *user* and *group*, there are
    also file permissions present for everyone else, called the *others* ownership.
    If the user is either the owner or a member of the file''s group, those permissions
    are available to the user. Otherwise, there need to be permissions for others
    to allow interaction with the file.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了Linux权限方案。我们已经学到了权限安排的两个主要轴：文件权限和文件所有权。对于文件权限，每个文件都有对*读*、*写*和*执行*权限的允许（或不允许）。这些权限的工作方式对文件和目录有所不同。权限是通过所有权应用的：文件始终由用户和组拥有。除了*用户*和*组*之外，还有其他人的文件权限，称为*其他*所有权。如果用户是文件的所有者或文件组的成员，那么这些权限对用户是可用的。否则，其他人需要有权限才能与文件交互。
- en: Next, we learned how to manipulate file permissions and ownership. By using
    `chmod` and `umask`, we were able to get the file permissions in the way we needed.
    Using `sudo`, `chown`, and `chgrp`, we manipulated the owner and group of a file.
    A warning was given about the usage of `sudo` and the `root` user, since both
    can render a Linux system inoperable with very little effort.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了如何操纵文件权限和所有权。通过使用`chmod`和`umask`，我们能够以所需的方式获取文件权限。使用`sudo`，`chown`和`chgrp`，我们操纵了文件的所有者和组。对于`sudo`和`root`用户的使用给出了警告，因为两者都可以在很少的努力下使Linux系统无法操作。
- en: We continued with an example of working with multiple users. We added three
    additional users to the system using `useradd`, and gave them the correct groups
    with `usermod`. We saw how those users can be members of the same groups and,
    in that way, share access to files.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续以一个与多个用户一起工作的示例。我们使用`useradd`添加了三个额外的用户到系统，并使用`usermod`为他们分配了正确的组。我们看到这些用户可以成为相同组的成员，并以这种方式共享对文件的访问。
- en: Finally, we touched on some basics of advanced permissions under Linux. The
    *Further reading* section contains more information for those subjects.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要介绍了Linux下高级权限的一些基础知识。*进一步阅读*部分包含了这些主题的更多信息。
- en: 'The following commands were introduced in this chapter: `id`, `touch`, `chmod`,
    `umask`, `chown`, `chgrp`, `sudo`, `useradd`, `groupadd`, `usermod`, `mkdir`,
    and `su`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '本章介绍了以下命令：`id`、`touch`、`chmod`、`umask`、`chown`、`chgrp`、`sudo`、`useradd`、`groupadd`、`usermod`、`mkdir`和`su`。 '
- en: Questions
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which three permissions are used for Linux files?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linux文件使用了哪三种权限？
- en: Which three types of ownership are defined for Linux files?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Linux文件定义了哪三种所有权类型？
- en: Which command is used to change the permissions on a file?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令用于更改文件的权限？
- en: What mechanism controls the default permissions for newly created files?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么机制控制了新创建文件的默认权限？
- en: 'How is the following symbolic permission described in octal: `rwxrw-r--`?'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下符号权限如何用八进制描述：`rwxrw-r--`？
- en: 'How is the following octal permission described symbolically: `0644`?'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下八进制权限如何用符号描述：`0644`？
- en: Which command allows us to gain superuser privileges?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令允许我们获得超级用户权限？
- en: Which commands can we use to change ownership for a file?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用哪些命令来更改文件的所有权？
- en: How can we arrange for multiple users to share access to files?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何安排多个用户共享文件访问？
- en: Which types of advanced permissions does Linux have?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linux有哪些类型的高级权限？
- en: Further reading
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following resources might be interesting if you''d like to go deeper into
    the subjects of this chapter:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想深入了解本章主题，以下资源可能会很有趣：
- en: '**Fundamentals of Linux** by *Oliver Pelz*, Packt: [https://www.packtpub.com/networking-and-servers/fundamentals-linux](https://www.packtpub.com/networking-and-servers/fundamentals-linux)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux基础** 作者 *Oliver Pelz*，Packt出版社：[https://www.packtpub.com/networking-and-servers/fundamentals-linux](https://www.packtpub.com/networking-and-servers/fundamentals-linux)'
- en: '**File attributes**: [https://linoxide.com/how-tos/howto-show-file-attributes-in-linux/](https://linoxide.com/how-tos/howto-show-file-attributes-in-linux/)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件属性**：[https://linoxide.com/how-tos/howto-show-file-attributes-in-linux/](https://linoxide.com/how-tos/howto-show-file-attributes-in-linux/)'
- en: '**Special file permissions**: [https://thegeeksalive.com/linux-special-permissions/](https://thegeeksalive.com/linux-special-permissions/)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特殊文件权限**：[https://thegeeksalive.com/linux-special-permissions/](https://thegeeksalive.com/linux-special-permissions/)'
- en: '**Access Control Lists**: [https://www.tecmint.com/secure-files-using-acls-in-linux/](https://www.tecmint.com/secure-files-using-acls-in-linux/)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问控制列表**：[https://www.tecmint.com/secure-files-using-acls-in-linux/](https://www.tecmint.com/secure-files-using-acls-in-linux/)'
