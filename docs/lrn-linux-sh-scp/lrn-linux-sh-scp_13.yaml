- en: Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'In this chapter, we''ll explain a very practical concept of Bash scripting:
    functions. We''ll show what they are, how we can use them, and why we would want
    to use them.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释Bash脚本的一个非常实用的概念：函数。我们将展示它们是什么，我们如何使用它们，以及为什么我们想要使用它们。
- en: After the basics of functions have been introduced, we're taking it a step further
    and we'll show how functions can have their own input and output.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了函数的基础知识之后，我们将进一步探讨函数如何具有自己的输入和输出。
- en: The concept of a function library will be described and we will start to build
    our own personal function library that will contain various utility functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将描述函数库的概念，并且我们将开始构建自己的个人函数库，其中包含各种实用函数。
- en: 'The following commands will be introduced in this chapter: `top`, `free`, `declare`,
    `case`, `rev`, and `return`.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下命令：`top`、`free`、`declare`、`case`、`rev`和`return`。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Functions explained
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数解释
- en: Augmenting functions with parameters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数增强函数
- en: Function libraries
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数库
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All scripts for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter13](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter13).
    Apart from your Ubuntu Linux virtual machine, no other resources are needed to
    complete the examples in this chapter. For the argument-checker.sh, functions-and-variables.sh, library-redirect-to-file.sh
    scripts only the final version is found online. Be sure to verify the script version
    in the header before executing it on your system.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有脚本都可以在GitHub上找到：[https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter13](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter13)。除了您的Ubuntu
    Linux虚拟机外，在本章的示例中不需要其他资源。对于argument-checker.sh、functions-and-variables.sh、library-redirect-to-file.sh脚本，只能在网上找到最终版本。在执行脚本之前，请务必验证头部中的脚本版本。
- en: Functions explained
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数解释
- en: 'In this chapter, we''re going to look at functions, and how these can enhance
    your scripts. The theory of functions is not too complicated: a function is a
    set of commands grouped together that can be called (executed) multiple times
    without having to write the whole set of commands again. As always, a good example
    is worth a thousand words, so let''s dive right in with one of our favorite examples:
    printing `Hello world!`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论函数以及这些如何增强你的脚本。函数的理论并不太复杂：函数是一组命令，可以被多次调用（执行），而无需再次编写整组命令。一如既往，一个好的例子胜过千言万语，所以让我们立即用我们最喜欢的例子之一来深入研究：打印“Hello
    world！”。
- en: Hello world!
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello world！
- en: 'We now know it''s relatively easy to get the words `Hello world!` to appear
    on our terminal. A simple `echo "Hello world!"` does just the trick. However,
    if we wanted to do this multiple times, how would we go about it? You could suggest
    using any kind of loop, which would indeed allow us to print multiple times. However,
    that loop also requires some extra code and planning up front. As you will notice,
    in practice loops are great for iterating over items, but not exactly suitable
    for reusing code in a predictable manner. Let''s see how we can use a function
    to do this instead:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道，相对容易让单词“Hello world！”出现在我们的终端上。简单的“echo "Hello world!"”就可以做到。然而，如果我们想要多次这样做，我们该怎么做呢？你可以建议使用任何一种循环，这确实可以让我们多次打印。然而，该循环还需要一些额外的代码和提前规划。正如你将注意到的，实际上循环非常适合迭代项目，但并不完全适合以可预测的方式重用代码。让我们看看我们如何使用函数来代替这样做：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you see, we first defined the function, which is nothing more than writing
    the commands that should be executed once the function is called. At the end of
    the script, you can see we execute the function by just entering the function
    name, as we would any other command. It is important to note that you can only
    call a function *if you have previously defined it*. This means that the entire
    function definition needs to be higher in the script than its call. For now, we'll
    place all functions as the first items in our scripts. Later on in this chapter,
    we'll show you how we can be more efficient with this.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们首先定义了函数，这只不过是写下应该在函数被调用时执行的命令。在脚本的末尾，你可以看到我们通过输入函数名来执行函数，就像执行任何其他命令一样。重要的是要注意，只有在之前定义了函数的情况下，你才能调用函数。这意味着整个函数定义需要在脚本中的调用之前。现在，我们将把所有函数放在脚本中的第一项。在本章的后面，我们将向你展示如何更有效地使用它。
- en: 'What you saw in the previous example was the first of two possible syntaxes
    for function definition in Bash. If we extract just the function, the syntax is
    as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，你看到的是Bash中函数定义的两种可能语法中的第一种。如果我们只提取函数，语法如下：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The second possible syntax, which we like less than the previous one, is this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种可能的语法，我们不太喜欢，是这样的：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The difference between the two syntaxes is the absence of either the word `function` at
    the beginning or `()` after the function name. We prefer the first syntax, which
    uses the `()` notation, as it is much closer to the notation of other scripting/programming
    languages and should thus be much more recognizable for most. And, as an added
    bonus, it is shorter and simpler than the second notation. As you might expect,
    we'll continue using only the first notation in the rest of the book; the other
    was presented for completeness (and it is always convenient to understand it if
    you come across it online when researching for your scripting!).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 两种语法的区别在于函数名之前没有`function`一词，或者在函数名后没有`()`。我们更喜欢第一种语法，它使用`()`符号，因为它更接近其他脚本/编程语言的符号，并且对大多数人来说应该更容易识别。而且，作为额外的奖励，它比第二种符号更短、更简单。正如你所期望的，我们将在本书的其余部分继续使用第一种符号；第二种符号是为了完整性而呈现的（如果你在研究脚本时在网上遇到它，了解它总是方便的！）。
- en: Remember, we use indentation to relay information about where commands are nested
    to the reader of a script. In this case, since all commands within a function
    are only run when the function is called, we indent them with two spaces so it's
    clear we're inside the function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们使用缩进来向脚本的读者传达命令嵌套的信息。在这种情况下，由于函数中的所有命令只有在调用函数时才运行，我们用两个空格缩进它们，这样就清楚地表明我们在函数内部。
- en: More complexity
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更复杂
- en: 'A function can have as many commands as needed. In our simple example, we only
    added a single `echo`, which we then only called once. While this is nice for
    abstraction, it does not really warrant creating a function (yet). Let''s look
    at a more complex example that will give you a better idea why abstraction of
    commands in functions is a good idea:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以有尽可能多的命令。在我们简单的例子中，我们只添加了一个`echo`，然后只调用了一次。虽然这对于抽象来说很好，但并不真正需要创建一个函数（尚未）。让我们看一个更复杂的例子，这将让您更好地了解为什么在函数中抽象命令是一个好主意：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we''re talking! This function has five commands, three of which include
    command substitution with chained pipes. Now, our scripts are starting to become
    complex yet powerful. As you can see, we define the function using the `()` notation.
    We then call this function in a C-style `for` loop, which causes the script to
    print the system status five times with a five-second pause in between (due to
    `sleep`, which we saw earlier in [Chapter 11](05e9179f-31c1-4f5f-903a-5a6b9f2c80d5.xhtml),* Conditional
    Testing and Scripting Loops*). When you run this, it should look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在谈论！这个函数有五个命令，其中三个包括使用链式管道的命令替换。现在，我们的脚本开始变得复杂而强大。正如您所看到的，我们使用`()`符号来定义函数。然后我们在C风格的`for`循环中调用这个函数，这会导致脚本在每次系统状态之间暂停五秒钟后打印系统状态五次（由于`sleep`，我们在[第11章](05e9179f-31c1-4f5f-903a-5a6b9f2c80d5.xhtml)中看到过，*条件测试和脚本循环*）。当您运行这个脚本时，它应该看起来像这样：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Apart from the date, the chance of the other output changing significantly
    is slim, unless you have other processes running. However, the purpose of functions
    should be clear: define and abstract a set of functionalities in a transparent
    manner.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了日期之外，其他输出发生显着变化的可能性很小，除非您有其他进程在运行。然而，函数的目的应该是清楚的：以透明的方式定义和抽象一组功能。
- en: While not the topic of this chapter, we used a few new commands here. The `top`
    and `free` commands are often used to check how the system is performing, and
    can be used without any arguments (`top` opens full screen, which you can exit
    with *Ctrl *+ *C*). In the *Further reading* section of this chapter, you can
    find more on these (and other) performance monitoring tools in Linux. We've also
    included a primer on `awk` there.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是本章的主题，但我们在这里使用了一些新命令。`top`和`free`命令通常用于检查系统的性能，并且可以在没有任何参数的情况下使用（`top`打开全屏，您可以使用*Ctrl *+ *C*退出）。在本章的*进一步阅读*部分，您可以找到有关Linux中这些（和其他）性能监控工具的更多信息。我们还在那里包括了`awk`的入门知识。
- en: 'There are many advantages to using functions; these include but are not limited
    to the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数有许多优点；其中包括但不限于以下内容：
- en: Easy to reuse code
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于重用代码
- en: Allows sharing of code (via libraries, for example)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许代码共享（例如通过库）
- en: Abstract confusing code to a simple function call
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将混乱的代码抽象为简单的函数调用
- en: 'An important thing in functions is naming. A function name should be as concise
    as possible, but still needs to tell the user what it does. For example, if you
    call a function something non-descriptive such as `function1`, how will anyone
    know what it does? Compare this to a name like we saw in the example: `print_system_status`.
    While perhaps not perfect (what is system status?), it at least points us in the
    right direction (if you agree that CPU, memory, and disk usage are considered
    part of system status, that is). Perhaps a better name for the function would
    be `print_cpu_mem_disk`. It is up to you to decide! Make sure you consider who
    the target audience is when making this choice; this often has the greatest impact.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中的一个重要事项是命名。函数名应尽可能简洁，但仍需要告诉用户它的作用。例如，如果您将一个函数命名为`function1`这样的非描述性名称，任何人怎么知道它的作用呢？将其与我们在示例中看到的名称进行比较：`print_system_status`。虽然也许不完美（什么是系统状态？），但至少指引我们朝着正确的方向（如果您同意CPU、内存和磁盘使用率被认为是系统状态的一部分的话）。也许函数的一个更好的名称是`print_cpu_mem_disk`。这取决于您的决定！确保在做出这个选择时考虑目标受众是谁；这通常会产生最大的影响。
- en: 'While descriptiveness is very important in function naming, so is adhering
    to a naming convention. We''ve already presented this same consideration in [Chapter
    8](41d3c327-f6d6-4ec5-8ec9-127e493bdd05.xhtml), *Variables and User Input*, when
    we dealt with variable naming. To reiterate: the most important rule is to *be
    consistent*. If you want our advice for a function naming convention, stick with
    the one we laid out for variables: lowercase, separated by underscores. This is
    what we used in the previous examples, and is what we will continue to show in
    the rest of the book.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在函数命名中描述性非常重要，但遵守命名约定也同样重要。当我们处理变量命名时，我们已经在[第8章](41d3c327-f6d6-4ec5-8ec9-127e493bdd05.xhtml)中提出了同样的考虑。重申一下：最重要的规则是*保持一致*。如果您想要我们对函数命名约定的建议，那就坚持我们为变量制定的规则：小写，用下划线分隔。这就是我们在之前的例子中使用的方式，也是我们将在本书的其余部分继续展示的方式。
- en: Variable scopes
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量作用域
- en: 'While functions are great, there are some things we have previously learned
    that we''ll need to reconsider in the scope of functions, most notably variables.
    We know that variables store information that can be accessed or mutated multiple
    times and at multiple points in our scripts. However, something we have not yet
    learned is that a variable always has a *scope.* By default, variables are scoped
    *globally*, which means they can be used throughout the script at any point. With
    the introduction of functions also comes a new scope: *local*. Local variables
    are defined within a function and live and die with the function call. Let''s
    see this in action:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然函数很棒，但我们之前学到的一些东西在函数的范围内需要重新考虑，尤其是变量。我们知道变量存储的信息可以在脚本的多个地方多次访问或改变。然而，我们还没有学到的是变量总是有一个*作用域*。默认情况下，变量的作用域是*全局*的，这意味着它们可以在脚本的任何地方使用。随着函数的引入，还有一个新的作用域：*局部*。局部变量在函数内部定义，并随着函数调用而存在和消失。让我们看看这个过程：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'So far, so good. We can use our *global* constants in a function. This is not
    surprising, since it is not called a global variable lightly; it can be used anywhere
    in the script. Now, let''s see what happens when we add some extra variables in
    the function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好。我们可以在函数中使用我们的*全局*常量。这并不令人惊讶，因为它不是轻易被称为全局变量；它可以在脚本的任何地方使用。现在，让我们看看当我们在函数中添加一些额外的变量时会发生什么：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'What do you think happens now? Give it a try:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为现在会发生什么？试一试：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Contrary to what you might have suspected, the variable we defined inside the
    function is actually still a global variable (sorry for tricking you!). If we
    wanted to use locally scoped variables, we need to add the built-in local shell:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与你可能怀疑的相反，我们在函数内部定义的变量实际上仍然是一个全局变量（对于欺骗你感到抱歉！）。如果我们想要使用局部作用域变量，我们需要添加内置的local
    shell：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, if we execute it this time, we''ll actually see the script misbehaving
    at the final command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们这次执行它，我们实际上会看到脚本在最后一个命令上表现不佳：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Because of the local addition, we can now only use the variable and its content
    inside of the function. So, when we call the `hello_variable` function, we see
    the content of the variable, but when we try to print it outside of the function
    in `echo "Function variable outside function: ${FUNCTION_VARIABLE}"`, we see it
    is empty. This is the expected and desirable behavior. What you can actually do,
    and is sometimes really convenient, is the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '由于局部添加，我们现在只能在函数内部使用变量及其内容。因此，当我们调用`hello_variable`函数时，我们看到变量的内容，但当我们尝试在函数外部打印它时，在`echo
    "Function variable outside function: ${FUNCTION_VARIABLE}"`中，我们看到它是空的。这是预期的和理想的行为。实际上，你可以做的，有时确实很方便，是这样的：'
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we''ve defined a locally scoped variable *with the same name* as a globally
    scoped one we have already initialized! You might have an idea about what happens
    next, but be sure to run the script and understand why this happens:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经定义了一个与我们已经初始化的全局作用域变量*同名*的局部作用域变量！你可能已经对接下来会发生什么有所想法，但一定要运行脚本并理解为什么会发生这种情况：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, when we used the `CONSTANT_VARIABLE` variable (remember, constants are
    still considered variables, albeit special ones) within the function, it printed
    the value of the locally scoped one: `maybe not so constant?`. When outside the
    function, in the main body of the script, we printed the value for the variable
    again, and we were presented with the value as we had originally defined it: `constant`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当我们在函数中使用`CONSTANT_VARIABLE`变量（记住，常量仍然被认为是变量，尽管是特殊的变量）时，它打印了局部作用域变量的值：`也许不那么常量？`。当在函数外，在脚本的主体部分，我们再次打印变量的值时，我们得到了最初定义的值：`constant`。
- en: You might be having a hard time imagining a use case for this. While we agree
    that you will probably not use this often, it does have its place. For example,
    imagine a complex script where a global variable is used by multiple functions
    and commands sequentially. Now, you might come across a situation where you need
    the value of the variable, but slightly modified to use it correctly in a function.
    You also know that functions/commands further on need the original value. Now,
    you could copy the contents to a new variable and use that, but by *overriding*
    the variable within a function you make it much clearer to the reader/user that
    you have a purpose for this; that it is a well-informed decision and you're aware
    you need that exception *for just that function*. Using a locally scoped variable
    (preferably with a comment, as always) will ensure readability!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能很难想象这种情况的用例。虽然我们同意你可能不经常使用这个，但它确实有它的用处。例如，想象一个复杂的脚本，其中一个全局变量被多个函数和命令顺序使用。现在，你可能会遇到这样一种情况，你需要变量的值，但稍微修改一下才能在函数中正确使用它。你还知道后续的函数/命令需要原始值。现在，你可以将内容复制到一个新变量中并使用它，但是通过在函数内部*覆盖*变量，你让读者/用户更清楚地知道你有一个目的；这是一个经过深思熟虑的决定，你知道你需要这个例外*仅仅是为了那个函数*。使用局部作用域变量（最好还加上注释，像往常一样）将确保可读性！
- en: Variables can be set read-only by using the `declare` built-in shell. If you
    check the help, with `help declare`, you'll see it described as `'Set variable
    values and attributes'`. A read-only variable such as a constant can be created
    by replacing `CONSTANT=VALUE` with `declare -r CONSTANT=VALUE`. If you do this,
    you can no longer (temporarily) override a variable with a local instance; Bash
    will give you an error. In practice, the `declare` command is not used too much
    as far as we have encountered, but it can serve useful purposes besides read-only
    declarations, so be sure to give it a look!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以通过使用内置的`declare` shell设置为只读。如果你查看帮助，使用`help declare`，你会看到它被描述为“设置变量值和属性”。通过用`declare
    -r CONSTANT=VALUE`替换`CONSTANT=VALUE`，可以创建一个只读变量，比如常量。如果你这样做，你就不能再（临时）用本地实例覆盖变量；Bash会给你一个错误。实际上，就我们遇到的情况而言，`declare`命令并没有被使用得太多，但它除了只读声明之外还可以有其他有用的用途，所以一定要看一看！
- en: Practical examples
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际例子
- en: 'Before we introduce function parameters in the next part of this chapter, we''ll
    first look into a practical example of functions that do not need parameters.
    We''ll go back to previous scripts we''ve created, and see if there is some functionality
    we can abstract as a function. Spoiler alert: there is a great one, which deals
    with a little something called error handling!'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一部分介绍函数参数之前，我们将首先看一个不需要参数的函数的实际示例。我们将回到我们之前创建的脚本，并查看是否有一些功能可以抽象为一个函数。剧透警告：有一个很棒的功能，涉及到一点叫做错误处理的东西！
- en: Error handling
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'In [Chapter 9](125f46ad-bffc-4bf6-86e7-ae6a2ca47bb6.xhtml), *Error Checking
    and Handling*, we created the following construction: `command || { echo "Something
    went wrong."; exit 1; }`. As you (hopefully) remember, the `||` syntax means that
    everything on the right-hand side will only be executed if the command on the
    left-hand side has an exit status that is not `0`. While this setup worked fine,
    it did not exactly increase readability. It would be much better if we could abstract
    our error handling to a function, and call that function instead! Let''s do just
    that:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](125f46ad-bffc-4bf6-86e7-ae6a2ca47bb6.xhtml)中，*错误检查和处理*，我们创建了以下结构：`command
    || { echo "Something went wrong."; exit 1; }`。正如你（希望）记得的那样，`||`语法意味着只有在左侧命令的退出状态不是`0`时，右侧的所有内容才会被执行。虽然这种设置运行良好，但并没有增加可读性。如果我们能将错误处理抽象为一个函数，并调用该函数，那将会更好！让我们就这样做：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This script defines two functions: `handle_minor_error` and `handle_fatal_error`.
    For a minor error, we will print a message but the script execution does not stop.
    A fatal error, however, is considered so severe that the flow of the script is
    expected to be disrupted; in this case, it is of no use to continue the script
    so we''ll make sure the function stops it. By using the functions combined with
    the `||` construct, we do not need to check for exit codes inside the functions;
    we only end up inside the functions if the exit code was not `0`, so we already
    know we''re in an error situation. Before we execute this script, take a moment
    to reflect *how much we improved the readability* with these functions. When you''re
    done with that, run this script with debug output, so you can follow the entire
    flow:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本定义了两个函数：`handle_minor_error`和`handle_fatal_error`。对于轻微的错误，我们会打印一条消息，但脚本的执行不会停止。然而，致命错误被认为是如此严重，以至于脚本的流程预计会被中断；在这种情况下，继续执行脚本是没有用的，所以我们会确保函数停止它。通过使用这些函数与`||`结构，我们不需要在函数内部检查退出码；我们只有在退出码不是`0`时才会进入函数，所以我们已经知道我们处于错误的情况中。在执行这个脚本之前，花点时间反思一下*我们通过这些函数改进了多少可读性*。当你完成后，用调试输出运行这个脚本，这样你就可以跟踪整个流程。
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you see, the first command, `ls -l /tmp/`, succeeds and we see its output;
    we do not enter the `handle_minor_error` function. The next command, which we
    do expect to fail, does indeed. We see that we now go into the function and the
    error message we specified there is printed. But, since it is only a minor error,
    we continue the script. However, when we get to `cat /etc/shadow`, which we consider
    a vital component, we encounter a `Permission denied` message that causes the
    script to execute `handle_fatal_error`. Because this function has an `exit 1`,
    the script is terminated and the fourth command is never executed. This should
    illustrate another point: an `exit`, even from inside a function, is global and
    terminates the script (not just the function). If you wish to see this script
    succeed, run it with `sudo bash error-functions.sh`. You will see that neither
    of the error functions is executed.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，第一个命令`ls -l /tmp/`成功了，我们看到了它的输出；我们没有进入`handle_minor_error`函数。下一个命令，我们确实希望它失败，它的确失败了。我们看到现在我们进入了函数，并且我们在那里指定的错误消息被打印出来。但是，由于这只是一个轻微的错误，我们继续执行脚本。然而，当我们到达`cat
    /etc/shadow`时，我们认为这是一个重要的组件，我们遇到了一个`Permission denied`的消息，导致脚本执行`handle_fatal_error`。因为这个函数有一个`exit
    1`，脚本被终止，第四个命令就不会被执行。这应该说明另一个观点：一个`exit`，即使在函数内部，也是全局的，会终止脚本（不仅仅是函数）。如果你希望看到这个脚本成功，用`sudo
    bash error-functions.sh`来运行它。你会看到两个错误函数都没有被执行。
- en: Augmenting functions with parameters
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用参数增强函数
- en: Just as a script can accept input in the form of arguments, so can a function.
    In reality, most functions will use parameters. Static functions, such as the
    error handling example from earlier, are not as powerful or flexible as their
    counterparts to accept arguments.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如脚本可以接受参数的形式输入一样，函数也可以。实际上，大多数函数都会使用参数。静态函数，比如之前的错误处理示例，不如它们的参数化对应函数强大或灵活。
- en: Colorful
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 丰富多彩
- en: 'In the next example, we''ll create a script that allows us to print text to
    our terminals in a few different colors. It does this based on a function that
    has two parameters: `string` and `color`. Take a look at the following commands:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将创建一个脚本，允许我们以几种不同的颜色打印文本到我们的终端。它基于一个具有两个参数的函数来实现：`string`和`color`。看一下以下命令：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A lot is happening in this script. To help with your understanding, we''ll
    go through it piece by piece, starting with the first part of the function definition:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本中发生了很多事情。为了帮助你理解，我们将逐步地逐个部分地进行讲解，从函数定义的第一部分开始：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first thing we do within the function body is check the number of arguments.
    The syntax is the same as the checks we normally do for arguments passed to the
    entire script, which might be helpful or perhaps confusing. A good thing to realize
    is that the `$#` construct applies to the scope in which it is used; if it is
    used within the main script, it checks the arguments passed there. If it is used,
    like it is here, within a function, it checks the number of arguments passed to
    the function. The same goes for `$1`, `$2`, and so on: if used within a function,
    they refer to the ordered arguments passed to the function, and not the script
    in general. When we grab the arguments, we write them to *local* variables; we
    don''t strictly need to do that in this simple script, but it is always good practice
    to mark variableses local when you only use them in the local scope. You might
    imagine that in larger, more complex scripts many functions use variables that
    might accidentally be called the same thing (in this case, `string` is a very
    common word). By marking them local, you''re not only improving readability, but
    also preventing errors caused by variables that have the same name; all in all,
    a very good idea. Let''s get back to the next part of our script, the case-statement:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内部，我们首先检查参数的数量。语法与我们通常对整个脚本传递的参数进行检查的方式相同，这可能会有所帮助，也可能会有些困惑。一个要意识到的好事是，`$#`结构适用于其所在的范围；如果它在主脚本中使用，它会检查那里传递的参数。如果像这里一样在函数内部使用，它会检查传递给函数的参数数量。对于`$1`、`$2`等也是一样：如果在函数内部使用，它们指的是传递给函数的有序参数，而不是一般脚本中的参数。当我们获取参数时，我们将它们写入*本地*变量；在这个简单的脚本中，我们不一定需要这样做，但是在本地范围内使用变量时，将变量标记为本地总是一个好习惯。您可能会想象，在更大、更复杂的脚本中，许多函数使用可能会意外地被称为相同的东西（在这种情况下，`string`是一个非常常见的词）。通过将它们标记为本地，您不仅提高了可读性，还防止了由具有相同名称的变量引起的错误；总的来说，这是一个非常好的主意。让我们回到脚本的下一部分，即`case`语句：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now is an excellent time to introduce `case`. A case-statement is basically
    a very long `if-then-elif-then-elif-then...` chain. The more options there are
    for a variable, the longer the chain would become. With `case`, you can just say
    `for certain values in ${variable}, do <something>`. In our example, that means
    that if the `${color}` variable is `red`, we'll set another `color_code` variable
    to `\e[31m` (more on that in a bit). If it is `blue`, we'll do something else,
    and the same goes for `green`. Finally, we'll define a wildcard; any value for
    the variable that was not specified will go through there, as a sort of catch-all
    construction. If the color specified is something incompatible, such as **dog**,
    we'll just set the default color. The alternative would be breaking off the script,
    which is a bit of an overreaction to a wrong color. To terminate a `case`, you'll
    use the `esac` keyword (which is the reverse of `case`), in a similar manner to
    `if`, which is terminated by its reverse, `fi`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是介绍`case`的绝佳时机。`case`语句基本上是一个非常长的`if-then-elif-then-elif-then...`链。变量的选项越多，链条就会变得越长。使用`case`，您只需说`对于${variable}中的特定值，执行<某些操作>`。在我们的例子中，这意味着如果`${color}`变量是`red`，我们将设置另一个`color_code`变量为`\e[31m`（稍后会详细介绍）。如果它是`blue`，我们将执行其他操作，对于`green`也是一样。最后，我们将定义一个通配符；未指定的变量值将通过这里，作为一种通用的构造。如果指定的颜色是一些不兼容的东西，比如**dog**，我们将只设置默认颜色。另一种选择是中断脚本，这对于错误的颜色有点反应过度。要终止`case`，您将使用`esac`关键字（这是`case`的反义词），类似于`if`被其反义词`fi`终止的方式。
- en: Now, on to the technical aspect of *colors on your terminal*. While most things
    we've been learning about are Bash or Linux specific, printed colors are actually
    defined by your terminal emulator. The color codes we're using are pretty standard
    and should be interpreted by your terminal as *do not print this character literally,
    but instead change the `color` to `<color>`*. The terminal sees an *escape sequence*,
    `\e`, followed by a *color code*, `[31m`, and knows you're instructing it to print
    a different color than previously defined (often defaults for that terminal emulator,
    unless you've changed the color scheme yourself). You can do many more things
    (as long as your terminal emulator supports this, of course) with escape sequences,
    such as creating bold text, blinking text, and another background color for your
    text. For now, remember *the \e[31m sequence is not printed but interpreted.* For
    the catch-all in `case`, you do not want to explicitly set a color, but instead
    signal the terminal to print in the *default* color. This means that for every
    compatible terminal emulator, the text is printed in the color the user has chosen
    (or got assigned by default).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈*终端上的颜色*的技术方面。虽然我们学到的大多数东西都是关于Bash或Linux特定的，但打印颜色实际上是由您的终端仿真器定义的。我们正在使用的颜色代码非常标准，应该被您的终端解释为*不要字面打印这个字符，而是改变`颜色`为`<颜色>`*。终端看到一个*转义序列*，`\e`，后面跟着一个*颜色代码*，`[31m`，并且知道您正在指示它打印一个与之前定义的颜色不同的颜色（通常是该终端仿真器的默认设置，除非您自己更改了颜色方案）。您可以使用转义序列做更多的事情（当然，只要您的终端仿真器支持），比如创建粗体文本、闪烁文本，以及为文本设置另一个背景颜色。现在，请记住*\e[31m序列不会被打印，而是被解释*。对于`case`中的通配符，您不想显式设置颜色，而是向终端发出信号，以使用*默认*颜色打印。这意味着对于每个兼容的终端仿真器，文本都以用户选择的颜色（或默认分配的颜色）打印。
- en: 'Now for the final part of the script:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是脚本的最后部分：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The last part of the `print_colored` function actually prints the colored text.
    It does this by using the good old `echo` with the `-e` flag. `man echo` reveals
    that `-e` *enables interpretation of backslash escapes*. If you do not specify
    this option, your output will just be something like `\e[31mHello world!\e[39m`.
    A good thing to know in this situation is that as soon as your terminal encounters
    a color code escape sequence, *all subsequent text will be printed in that color!*
    Because of this, we end the echo with `"\e[39m"`, which resets the color for all
    following text back to default.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_colored`函数的最后一部分实际上打印了有颜色的文本。它通过使用带有`-e`标志的老式`echo`来实现这一点。`man echo`显示`-e`*启用反斜杠转义的解释*。如果您不指定此选项，您的输出将只是类似于`\e[31mHello
    world!\e[39m`。在这种情况下需要知道的一件好事是，一旦您的终端遇到颜色代码转义序列，*随后的所有文本都将以该颜色打印*！因此，我们用`"\e[39m"`结束echo，将所有后续文本的颜色重置为默认值。'
- en: 'Finally, we call the function multiple times, with the same first argument,
    but a different second argument (the color). If you run the script, the output
    should look similar to this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们多次调用函数，第一个参数相同，但第二个参数（颜色）不同。如果您运行脚本，输出应该类似于这样：
- en: '![](img/82d06db9-52c7-4555-b8e5-f4e4ce7763d7.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82d06db9-52c7-4555-b8e5-f4e4ce7763d7.png)'
- en: In the preceding screenshot, my color scheme is set to green-on-black, which
    is why the last `Hello world!` is bright green. You can see it is the same color
    as `bash colorful.sh`, which should be all the confirmation you need to be sure
    the `[39m` color code is actually default.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我的颜色方案设置为绿底黑字，这就是为什么最后的`Hello world!`是鲜绿色的原因。您可以看到它与`bash colorful.sh`的颜色相同，这应该足以让您确信`[39m`颜色代码实际上是默认值。
- en: Returning values
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回值
- en: 'Some functions follow the *processor* archetype: they take input, do something
    with it, and return the result back to the caller. This is something of a classic
    function: depending on the input, different output is generated. We''ll show this
    with an example that reverses the input the user specifies to the script. This
    is normally done with the `rev` command (and will actually be accomplished with
    `rev` in our function as well), but we''re creating a wrapper function around
    this with a little extra functionality:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有些功能遵循*处理器*原型：它们接受输入，对其进行处理，然后将结果返回给调用者。这是经典功能的一部分：根据输入，生成不同的输出。我们将通过一个示例来展示这一点，该示例将用户指定的输入反转为脚本。通常使用`rev`命令来完成这个功能（实际上我们的函数也将使用`rev`来实现），但我们将创建一个包装函数，增加一些额外的功能：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As this is again a longer, more complex script, we''re going to look at it
    bit by bit to make sure you understand it all. We even sneaked a little surprise
    in there that proves one of our earlier statements, but we''ll get to that in
    a bit. We''ll skip the header and input check and move to capturing the variable:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这又是一个更长、更复杂的脚本，我们将逐步查看它，以确保您完全理解。我们甚至在其中加入了一个小惊喜，证明了我们之前的说法之一，但我们稍后再谈。我们将跳过标题和输入检查，转而捕获变量：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In most of the earlier examples, we''ve always directly mapped input to a variable.
    However, this time we''re showing that you can actually also add some extra text.
    In this case, we''re taking the input by the user and we add an underscore before
    and after. If the user inputs `rain`, the variable will actually contain `_rain_`.
    This will prove insightful later. Now, for the function definition, we use the
    following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的大多数示例中，我们总是直接将输入映射到变量。但是，这一次我们要表明您实际上也可以添加一些额外的文本。在这种情况下，我们通过用户输入并在其前后添加下划线。如果用户输入`rain`，那么变量实际上将包含`_rain_`。这将在后面证明有洞察力。现在，对于函数定义，我们使用以下代码：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `reverser` function requires a single argument: the input to be reversed.
    As always, we first check if the input is correct, before we actually do anything.
    Next, we use `rev` to reverse the input. However, `rev` normally expects input
    from a file or `stdin`, not a variable as an argument. Because we do not want
    to add an extra echo and pipe, we use a here string (as explained in [Chapter
    12](15141e02-be0c-4709-90f4-a172809217c4.xhtml),* Using Pipes and Redirection
    in Scripts*), which allows us to directly use the variable content as `stdin`.
    Since `rev` already outputs the result to `stdout`, we do not need to provide
    anything, such as an echo, at that point.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverser`函数需要一个参数：要反转的输入。与往常一样，我们首先检查输入是否正确，然后再执行任何操作。接下来，我们使用`rev`来反转输入。但是，`rev`通常期望从文件或`stdin`中获取输入，而不是作为参数的变量。因为我们不想添加额外的echo和管道，所以我们使用这里字符串（如[第12章](15141e02-be0c-4709-90f4-a172809217c4.xhtml)中所述，*在脚本中使用管道和重定向*），它允许我们直接使用变量内容作为`stdin`。由于`rev`已经将结果输出到`stdout`，所以在那一点上我们不需要提供任何东西，比如echo。'
- en: We told you we'd prove a previous statement, which in this case relates to `$1`
    in the previous snippet. If `$1` within the function related to the first argument
    *of the script* and not the first argument *of the function*, we would not see
    the underscores we added when we wrote the `user_input` variable. For the script,
    `$1` could equal `rain`, where in the function, `$1` equals `_rain_`. When you
    run the script, you'll definitely see the underscores, which means that each function
    really has its own set of arguments!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉过您我们将证明之前的说法，这在这种情况下与前面的片段中的`$1`有关。如果函数中的`$1`与脚本的第一个参数相关，而不是函数的第一个参数，那么我们在编写`user_input`变量时添加的下划线就不会出现。对于脚本，`$1`可能等于`rain`，而对于函数，`$1`等于`_rain_`。当您运行脚本时，您肯定会看到下划线，这意味着每个函数实际上都有自己的一组参数！
- en: 'Tying it all together is the final piece of the script:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容绑在一起的是脚本的最后一部分：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since the `reverser` function sends the reversed input to `stdout`, we''ll
    use command substitution to capture it in a variable. Finally, we print some clarifying
    text and the reversed input to the user with `echo`. The result will look like
    this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`reverser`函数将反转的输入发送到`stdout`，我们将使用命令替换来将其捕获到一个变量中。最后，我们打印一些澄清文本和反转的输入给用户看。结果将如下所示：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Underscores and all, we get the reverse of `rain: _nair_`. Nice!'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线和所有，我们得到了`rain`的反转：`_nair_`。不错！
- en: 'To avoid too much complexity, we split the final part of this script in two
    lines. However, once you feel comfortable with command substitutions, you could
    save yourself the intermediate variable and use the command substitution directly
    within the echo, like so: `echo "Your reversed input is: $(reverser ${user_input})"`.
    We would recommend not making it much more complex than this, however, since that
    will start to affect the readability.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免太多复杂性，我们将这个脚本的最后部分分成两行。但是，一旦你对命令替换感到舒适，你可以省去中间变量，并直接在echo中使用命令替换，就像这样：`echo
    "Your reversed input is: $(reverser ${user_input})"`。然而，我们建议不要让它变得比这更复杂，因为那将开始影响可读性。
- en: Function libraries
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数库
- en: 'When you get to this part of the book, you''ll have seen well over 50 example
    scripts. Many of these scripts have some shared components: input checking, error
    handling, and setting the current working directory have been used in multiple
    scripts. This code doesn''t really change; perhaps the comments or echoes were
    slightly different, but in reality it''s just duplicated code. Pair this with
    the problem of having to define functions at the top of your script (or, at the
    very least, before you start using them) and your maintainability is beginning
    to suffer. Luckily for us all, there is a great solution for this: **creating
    your own function library!**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当你到达书的这一部分时，你会看到超过50个示例脚本。这些脚本中有许多共享组件：输入检查、错误处理和设置当前工作目录在多个脚本中都被使用过。这段代码实际上并没有真正改变；也许注释或回显略有不同，但实际上只是重复的代码。再加上在脚本顶部定义函数的问题（或者至少在开始使用它们之前），你的可维护性就开始受到影响。幸运的是，我们有一个很好的解决方案：**创建你自己的函数库！**
- en: Source
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源
- en: 'The idea of a function library is that you define functions that are *shared*
    between different scripts. These are repeatable, generic functions that do not
    care too much about the specific script to work. When you create a new script,
    the first thing you''ll do, right after the header, is *include the function definitions
    from the library.* The library is nothing more than another shell script: however,
    it is only used to define functions, so it never calls anything. If you were to
    run it, the end result would be the same as if you had run an empty script. We''ll
    start creating our very own function library first, before we look at how we can
    include it.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 函数库的想法是你定义的函数在不同的脚本之间是*共享的*。这些是可重复使用的通用函数，不太关心特定脚本的工作。当你创建一个新脚本时，你会在头部之后*包含来自库的函数定义*。库只是另一个shell脚本：但它只用于定义函数，所以它从不调用任何东西。如果你运行它，最终结果将与运行一个空脚本的结果相同。在我们看如何包含它之前，我们将首先创建我们自己的函数库。
- en: 'There is only one real consideration when creating a function library: where
    to put it. You want to have it present just once in your filesystem, preferably
    in a predictable location. Personally, we prefer the `/opt/` directory. However,
    by default `/opt/` is only writable to the `root` user. In a multiuser system,
    it''s probably not a bad idea to place it there, owned by `root` and readable
    by everyone, but since this is a single-user situation, we''ll place it directly
    in our home directory. Let''s make a humble beginning with our library there:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建函数库时只有一个真正的考虑：放在哪里。你希望它在你的文件系统中只出现一次，最好是在一个可预测的位置。就个人而言，我们更喜欢`/opt/`目录。然而，默认情况下`/opt/`只对`root`用户可写。在多用户系统中，把它放在那里可能不是一个坏主意，由`root`拥有并被所有人可读，但由于这是一个单用户情况，我们将直接把它放在我们的主目录下。让我们从那里开始建立我们的函数库：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Because this is a generic function, we need to first supply the number of arguments
    we''re expecting, followed by the actual arguments. After we save the expected
    number of arguments, we use `shift` to *shift* all arguments one place to the
    left: `$2` becomes `$1`, `$3` becomes `$2`, and `$1` is removed entirely. Doing
    this, only the number of arguments to check remains, with the expected number
    safely stored inside a variable. We then compare the two values, and if they''re
    not the same, we return an exit code of `1`. `return` is similar to `exit`, but
    it does not stop the script execution: if we want to do that, the script calling
    the function should take care of this.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个通用函数，我们需要首先提供我们期望的参数数量，然后是实际的参数。在保存期望的参数数量后，我们使用`shift`将所有参数向左移动一个位置：`$2`变成`$1`，`$3`变成`$2`，`$1`被完全移除。这样做，只有要检查的参数数量保留下来，期望的数量安全地存储在一个变量中。然后我们比较这两个值，如果它们不相同，我们返回退出码`1`。`return`类似于`exit`，但它不会停止脚本执行：如果我们想要这样做，调用函数的脚本应该处理这个问题。
- en: 'To use this library function within another script, we''ll need to include
    it. In Bash, this is called *sourcing*. Sourcing is achieved with the `source`
    command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要在另一个脚本中使用这个库函数，我们需要包含它。在Bash中，这称为*sourcing*。使用`source`命令来实现：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The syntax is simple. As soon as you `source` a file, all its contents will
    be processed. In our library case, when we only define functions, nothing will
    be executed but we''ll have the functions available. If you''re sourcing a file
    that contains actual commands, such as `echo`, `cat`, or `mkdir`, these commands
    *will be executed.* As always, an example is worth a thousand words, so let''s
    see how we can use `source` to include the library functions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 语法很简单。一旦你`source`一个文件，它的所有内容都将被处理。在我们的库的情况下，当我们只定义函数时，不会执行任何内容，但我们将拥有这些函数。如果你`source`一个包含实际命令的文件，比如`echo`、`cat`或`mkdir`，这些命令将被执行。就像往常一样，一个例子胜过千言万语，所以让我们看看如何使用`source`来包含库函数：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Pretty simple right? We source the file using a fully qualified path (yes,
    even though `~` is shorthand, this is still fully qualified!) and go right on
    with using the function that was defined in the other script. If you run this
    with debug, you''ll see that the function works as we expect:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单对吧？我们使用完全合格的路径（是的，即使`~`是简写，这仍然是完全合格的！）来包含文件，并继续使用在其他脚本中定义的函数。如果你以调试模式运行它，你会看到函数按我们的期望工作：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first and third function call are expected to be correct, whereas the second
    should fail. Because we used `return` and not `exit` in our function, the script
    continues even after the second function call returns an exit status of `1`. As
    the debug output shows, the second time we call the function, the evaluation `2
    not equals 3` is performed and succeeds, which results in `return 1`. For the
    other calls, the arguments are correct and the default return code of `0` is returned
    (not shown from output, but this is really what happens; add `echo $?` if you
    want to verify for yourself).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个和第三个函数调用预期是正确的，而第二个应该失败。因为我们在函数中使用了`return`而不是`exit`，所以即使第二个函数调用返回了`1`的退出状态，脚本仍会继续执行。正如调试输出所示，第二次调用函数时，执行了`2不等于3`的评估并成功，导致了`return
    1`。对于其他调用，参数是正确的，返回了默认的`0`返回代码（输出中没有显示，但这确实发生了；如果你想自己验证，可以添加`echo $?`）。
- en: 'Now, to use this in an actual script, we''ll need to pass all arguments the
    user gives us to our function. This can be done using the `$@` syntax: where `$#`
    corresponds to the number of arguments, `$@` simply prints all arguments. We''ll
    update `argument-checker.sh` to check arguments to the script as well:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要在实际脚本中使用这个，我们需要将用户给我们的所有参数传递给我们的函数。这可以使用`$@`语法来完成：其中`$#`对应于参数的数量，`$@`简单地打印出所有参数。我们将更新`argument-checker.sh`来检查脚本的参数：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We pass the expected amount of arguments, `2`, and all arguments received by
    the script, `$@`, to our sourced function. Run it with a few different inputs
    and see what happens:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递了预期数量的参数`2`，以及脚本接收到的所有参数`$@`给我们的函数。用一些不同的输入运行它，看看会发生什么：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Excellent, everything seems to be working! The most interesting tries are probably
    the last two, since they illustrate the problem often posed by *word splitting*.
    By default, Bash will interpret every piece of whitespace as a separator. In the
    fourth example, we pass the `"1 2"` string, which is actually *a single argument
    because of the quotes*. If we did not use double quotes around `$@`, this would
    happen:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，一切似乎都在正常工作！最有趣的尝试可能是最后两个，因为它们展示了*单词分割*经常引起的问题。默认情况下，Bash会将每个空白字符解释为分隔符。在第四个例子中，我们传递了`"1
    2"`字符串，实际上*由于引号的存在是一个单独的参数*。如果我们没有在`$@`周围使用双引号，就会发生这种情况：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this example, Bash passes the arguments to the function without preserving
    the quotes. The function would then receive `"1"` and `"2"`, instead of `"1 2"`.
    Something to watch out for, always!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Bash将参数传递给函数时没有保留引号。函数将会接收到`"1"`和`"2"`，而不是`"1 2"`。要时刻注意这一点！
- en: 'Now, we can use a predefined function to check if the number of arguments is
    correct. However, currently we do not use our return code for anything. We''re
    going to make one final adjustment to our `argument-checker.sh` script, which
    will stop script execution if the number of arguments is not correct:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用预定义的函数来检查参数的数量是否正确。然而，目前我们并没有使用我们的返回代码做任何事情。我们将对我们的`argument-checker.sh`脚本进行最后一次调整，如果参数的数量不正确，将停止脚本执行：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Because of the page width of this book, we''ve broken the line with `check_arguments`
    in two by using `\`: this signals to Bash to continue on the next line. You can
    omit this and have the full command on a single line, if you prefer. If we run
    the script now, we''ll see desirable script execution:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书的页面宽度，我们使用`\`将`check_arguments`一行分成两行：这表示Bash会继续到下一行。如果你喜欢，你可以省略这一点，让整个命令在一行上。如果我们现在运行脚本，将会看到期望的脚本执行：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Congratulations, we have begun the creation of a function library and have successfully
    used it in one of our scripts!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，我们已经开始创建一个函数库，并成功在我们的一个脚本中使用它！
- en: 'There is a somewhat confusing shorthand syntax for source: a single dot (`.`).
    If we wanted to use that shorthand in our scripts, it would simply be `. ~/bash-function-library.sh`.
    We are, however, not big fans of this syntax: the `source` command is not long
    or complicated, while a single `.` can easily be missed or misused if you forget
    a space after it (which can be hard to see!). Our advice: know the shorthand exists
    if you encounter it somewhere in the wild, but use the full built-in source when
    writing scripts.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`source`有一个有点令人困惑的简写语法：一个点（`.`）。如果我们想在我们的脚本中使用这个简写，只需`. ~/bash-function-library.sh`。然而，我们并不是这种语法的铁杆支持者：`source`命令既不长也不复杂，而单个`.`如果你忘记在它后面加上空格（这很难看到！）就很容易被忽略或误用。我们的建议是：如果你在某个地方遇到这个简写，请知道它的存在，但在编写脚本时使用完整的内置`source`。
- en: More practical examples
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多实际例子
- en: We're going to spend the last part of this chapter expanding your function library
    with commonly used actions from earlier scripts. We'll copy a script from one
    of the earlier chapters and use our function library to replace functionality
    that can then be handled with a function from our library.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的最后一部分扩展您的函数库，使用来自早期脚本的常用操作。我们将从早期章节中复制一个脚本，并使用我们的函数库来替换功能，然后可以使用我们的库中的函数来处理。
- en: Current working directory
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当前工作目录
- en: 'The first candidate for inclusion in our own private function library is correctly
    setting the current working directory. This is a pretty simple function, so we''ll
    add it without too much explanation:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自己的私有函数库中第一个候选是正确设置当前工作目录。这是一个非常简单的函数，所以我们将它添加进去，不做太多解释：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Because a function library is something that is potentially updated quite frequently,
    correctly updating the information in the header is very important. Preferably
    (and most likely in an enterprise environment), you will commit new versions of
    your function library to a version control system. Using proper Semantic Version
    in the header will help you keep a clean history. Particularly, if you combine
    this with configuration management tooling such as Chef.io, Puppet, and Ansible,
    you will keep a good overview of what you've changed and deployed to where.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因为函数库是一个潜在频繁更新的东西，正确更新头部信息非常重要。最好（并且在企业环境中最有可能）将新版本的函数库提交到版本控制系统。在头部使用正确的语义版本将帮助您保持一个干净的历史记录。特别是，如果您将其与Chef.io、Puppet和Ansible等配置管理工具结合使用，您将清楚地了解您已经更改和部署到何处。
- en: 'Now, we''ll update our script from the previous chapter, `redirect-to-file.sh`,
    with our library inclusion and function call. The end result should be the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用我们的库包含和函数调用更新上一章的脚本`redirect-to-file.sh`。最终结果应该是以下内容：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For teaching purposes, we''ve copied the file to the directory of the current
    chapter; normally, we would just update our original file. We''ve only added the
    inclusion of our function library and replaced the magical `cd $(dirname $0)`
    with our `set_cwd` function call. Let''s run it from a location where the script
    is not and see if the directory is correctly set:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了教学目的，我们已将文件复制到当前章节的目录中；通常情况下，我们只需更新原始文件。我们只添加了对函数库的包含，并用我们的`set_cwd`函数调用替换了神奇的`cd
    $(dirname $0)`。让我们从脚本所在的位置运行它，看看目录是否正确设置：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: So, even though we used the `$0` syntax (which, as you remember, prints the
    fully qualified path of the script), we see here that it refers to the path of
    `library-redirect-to-file.sh` and not, as you might have reasonably assumed, to
    the location of the `bash-function-library.sh` script. This should confirm our
    explanation that only function definitions are included, and when the functions
    are called at runtime they take on the environment of the script that includes
    them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使我们使用了`$0`语法（你记得的，打印脚本的完全限定路径），我们在这里看到它指的是`library-redirect-to-file.sh`的路径，而不是你可能合理假设的`bash-function-library.sh`脚本的位置。这应该证实了我们的解释，即只有函数定义被包含，当函数在运行时被调用时，它们会采用包含它们的脚本的环境。
- en: Type checking
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型检查
- en: 'Something we''ve done in many of our scripts is checking arguments. We started
    our library with a function that allowed checking the number of arguments the
    user gave as input. Another action we frequently performed on user input was validating
    the input type. If our script requires a number, for example, we''d like the user
    to actually enter a number and not a word (or a written out number, such as ''eleven'').
    You might remember the approximate syntax, but I''m sure that by now if you needed
    it again, you would look through our older scripts to find it. Doesn''t that sound
    like the ideal candidate for a library function? We create and thoroughly test
    our function once, and then we can feel safe just sourcing and using it! Let''s
    create a function that checks if a passed argument is actually an integer:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在许多脚本中做的事情是检查参数。我们用一个函数开始了我们的库，允许检查用户输入的参数数量。我们经常对用户输入执行的另一个操作是验证输入类型。例如，如果我们的脚本需要一个数字，我们希望用户实际输入一个数字，而不是一个单词（或一个写出来的数字，比如'eleven'）。你可能记得大致的语法，但我敢肯定，如果你现在需要它，你会浏览我们的旧脚本找到它。这不是理想的库函数候选吗？我们创建并彻底测试我们的函数一次，然后我们可以放心地只是源和使用它！让我们创建一个检查传递参数是否实际上是整数的函数：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Because we're dealing with a library function, we can be a little more verbose
    for the sake of readability. Too much verbosity in a regular script will reduce
    readability, but as soon as someone is looking at the function library for understanding,
    you can assume they'll like some more verbose scripting. After all, when we call
    the function in a script we'll only see `check_integer ${variable}`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在处理一个库函数，为了可读性，我们可以多说一点。在常规脚本中过多的冗长将降低可读性，但是一旦有人查看函数库以便理解，你可以假设他们会喜欢一些更冗长的脚本。毕竟，当我们在脚本中调用函数时，我们只会看到`check_integer
    ${variable}`。
- en: On to the function. We first check if we've received a single argument. If we
    did not receive that, we exit instead of return. Why would we do this? The script
    that calls should not be confused about what a return code of `1` means; if it
    can mean that we either did not check anything, but also that the check itself
    failed, we're bringing ambiguity where we don't want it. So simply said, return
    always tells the caller something about the passed argument, and if the script
    calls the function wrong, it will see the full script exit with an error message.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是函数。我们首先检查是否收到了单个参数。如果没有收到，我们退出而不是返回。为什么我们要这样做呢？调用的脚本不应该困惑于`1`的返回代码意味着什么；如果它可以意味着我们没有检查任何东西，但也意味着检查本身失败了，我们会在不希望出现歧义的地方带来歧义。所以简单地说，返回总是告诉调用者有关传递参数的信息，如果脚本调用函数错误，它将看到完整的脚本退出并显示错误消息。
- en: Next, we use the regular expression we constructed in [Chapter 10](d3b18cbd-f152-498a-b7b8-79da604e66b4.xhtml),
    *Regular Expressions*, to check if the argument is in fact an integer. If it is,
    we return `0`. If it is not, we'll hit the `else` block and `1` will be returned.
    To emphasize this point to someone reading the library, we included the `# Is
    an integer` and `# Is not an integer` comments. Why not make it easy on them?
    Remember, you do not always write it for someone else, but if you look at your
    own code a year later, you will definitely also feel like *someone else* (again,
    you can trust us on this!).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用在[第10章](d3b18cbd-f152-498a-b7b8-79da604e66b4.xhtml)中构建的正则表达式，*正则表达式*，来检查参数是否实际上是整数。如果是，我们返回`0`。如果不是，我们将进入`else`块并返回`1`。为了向阅读库的人强调这一点，我们包括了`#
    是整数`和`# 不是整数`的注释。为什么不让它对他们更容易呢？记住，你并不总是为别人写代码，但如果你在一年后看自己的代码，你肯定也会觉得自己像*别人*（相信我们吧！）。
- en: 'We''ll do another search-replace from one of our earlier scripts. A suitable
    one from the previous chapter, `password-generator.sh`, will serve this purpose
    nicely. Copy it to a new file, load the function library with source, and replace
    the argument checks (yes, both!):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从我们早期的脚本中进行另一个搜索替换。来自上一章的一个合适的脚本，`password-generator.sh`，将很好地完成这个目的。将其复制到一个新文件中，加载函数库并替换参数检查（是的，两个！）：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We''re replaced both the number of arguments check and the integer check with
    our library functions. We''ve also removed the variable declaration and used `$1`
    directly in the functional part of the script; this is not always the best thing
    to do. However, when input is only used once, first storing it in a named variable
    creates some overhead which we might skip. Even with all the whitespace and comments,
    we still managed to reduce the script lines from 31 to 26 by using function calls.
    When we call our new and improved script, we see the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用我们的库函数替换了参数检查和整数检查。我们还删除了变量声明，并直接在脚本的功能部分使用了`$1`；这并不总是最好的做法。然而，当输入只使用一次时，首先将其存储在命名变量中会创建一些额外开销，我们可以跳过。即使有所有的空格和注释，我们仍然通过使用函数调用将脚本行数从31减少到26。当我们调用我们的新改进的脚本时，我们看到以下内容：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Great, our checks are working as expected. Looks much better too, doesn't it?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们的检查按预期工作。看起来也好多了，不是吗？
- en: Yes-no check
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是-否检查
- en: We'll show one more check before we finish this chapter. Halfway through the
    book, in [Chapter 9](125f46ad-bffc-4bf6-86e7-ae6a2ca47bb6.xhtml), *Error Checking
    and* *Handling*,we presented a script that dealt with a user that could supply
    either a 'yes' or a 'no'. But, as we explained there, the user might also use
    'y' or 'n', and perhaps even a capital letter in there somewhere. By secretly
    using a little Bash expansion, which you will see properly explained in [Chapter
    16](89ec6d77-023a-482a-bd93-23e3945002bf.xhtml), *Bash Parameter Substitution
    and Expansion*, we were able to make a relatively clear check for user input.
    Let's get that thing in our library!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章之前，我们将展示另一个检查。在本书的中间，在[第9章](125f46ad-bffc-4bf6-86e7-ae6a2ca47bb6.xhtml)中，*错误检查和处理*，我们介绍了一个处理用户可能提供的'yes'或'no'的脚本。但是，正如我们在那里解释的那样，用户也可能使用'y'或'n'，甚至可能在其中的某个地方使用大写字母。通过秘密使用一点Bash扩展，你将在[第16章](89ec6d77-023a-482a-bd93-23e3945002bf.xhtml)中得到适当解释，我们能够对用户输入进行相对清晰的检查。让我们把这个东西放到我们的库中！
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We''ve got a little advanced scripting cooked up for you with this example.
    Instead of a binary return, we now have four possible outcomes:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们为你准备了一些稍微高级的脚本。现在我们不再有二进制返回，而是有四种可能的结果：
- en: Function incorrectly called: `exit 1`
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数错误调用：`exit 1`
- en: Function found a yes: `return 0`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数找到了yes：`return 0`
- en: Function found a no: `return 1`
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数找到了no：`return 1`
- en: Function found neither: `exit 2`
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数找不到：`exit 2`
- en: 'With our new library function, we''ll take the `yes-no-optimized.sh` script
    and replace the complex logic with (almost) a single function call:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的新库函数，我们将把`yes-no-optimized.sh`脚本和复杂逻辑替换为（几乎）单个函数调用：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Take a minute to look at the preceding script. It will probably be a little
    confusing at first, but try to remember what `&&` and `||` do. Because of some
    smart ordering we applied, we can use `&&` and `||` in sequence to achieve our
    result. Look at it like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 花一分钟看一下前面的脚本。起初可能有点混乱，但请记住`&&`和`||`的作用。由于我们应用了一些智能排序，我们可以使用`&&`和`||`来实现我们的结果。可以这样看待它：
- en: If `check_yes_no` returns an exit status of 0 (when a **yes** is found), the
    command after && is executed. Since that echoes the success, and `echo` has an
    exit code of 0, the failure `echo` after the next `||` is not executed.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`check_yes_no`返回退出状态0（找到**yes**时），则执行`&&`后面的命令。由于它回显了成功，而`echo`的退出代码为0，因此下一个`||`后的失败`echo`不会被执行。
- en: If `check_yes_no` returns an exit status of 1 (when a **no** is found), the
    command after && is not executed. However, it continues until it reaches `||`,
    which goes on to the failure echo since the return code was still *not* 0.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`check_yes_no`返回退出状态1（找到**no**时），则`&&`后面的命令不会被执行。然而，它会继续执行直到达到`||`，由于返回代码仍然不是0，它会继续到失败的回显。
- en: If `check_yes_no` exits on either the lack of argument or lack of yes/no, the
    commands after both `&&` and `||` are not executed (because the script is given
    an `exit` instead of `return`, so code execution is stopped immediately).
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`check_yes_no`在缺少参数或缺少yes/no时退出，则`&&`和`||`后面的命令都不会被执行（因为脚本被给予`exit`而不是`return`，所以代码执行立即停止）。
- en: 'Pretty clever right? However, we must admit, it''s a little against most things
    we''ve been teaching you with regards to readability. Consider this a teaching
    exercise for chaining `&&` and `||` instead. If you''d want to implement the yes-no
    check yourself, it would probably be better to create dedicated `check_yes()`
    and `check_no()` functions. In any case, let''s see if our tricked out script
    actually works as we hope it does:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 相当聪明对吧？然而，我们必须承认，这与我们教给你的大多数关于可读性的东西有点相悖。把这看作是一个使用`&&`和`||`链接的教学练习。如果你想要自己实现是-否检查，可能最好创建专门的`check_yes()`和`check_no()`函数。无论如何，让我们看看我们改进的脚本是否像我们希望的那样工作：
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: All scenarios as we've defined them in the check work out. Great success!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的所有场景都能正常工作。非常成功！
- en: Normally, you do not want to mix exit and return codes too much. Also, using
    a return code to convey anything other than pass or fail is also pretty uncommon.
    However, since you can return 256 different codes (from 0 up to 255), this is
    at least possible by design. Our yes-no example was a good candidate for showing
    how this could be used. However, as a general tip, you're probably better off
    by using it in a pass/fail way, as currently you place the burden of knowing the
    different return codes on the caller. Which is, to say the least, not always a
    fair thing to ask of them.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不希望过多地混合退出和返回代码。此外，使用返回代码传达除了通过或失败之外的任何内容也是相当不常见的。然而，由于你可以返回256个不同的代码（从0到255），这至少在设计上是可能的。我们的是非示例是一个很好的候选，可以展示如何使用它。然而，作为一个一般的建议，最好是以通过/失败的方式使用它，因为目前你把知道不同返回代码的负担放在了调用者身上。这至少不总是一个公平的要求。
- en: 'We''d like to end this chapter with a small exercise for you. In this chapter,
    before we introduced the function library, we already created a few functions:
    two for error handling, one for colored printing, and one for reversing text.
    Your exercise is simple: grab those functions and add them to your personal function
    library. Make sure to keep the following things in mind:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想以一个小练习结束本章。在本章中，在我们引入函数库之前，我们已经创建了一些函数：两个用于错误处理，一个用于彩色打印，一个用于文本反转。你的练习很简单：获取这些函数并将它们添加到你的个人函数库中。请记住以下几点：
- en: Are the functions verbose enough to be included in the library as is, or could
    they use more?
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些函数是否足够详细，可以直接包含在库中，还是需要更多的内容？
- en: Can we call the functions and deal with the output as is, or would an edit be
    preferable?
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以直接调用函数并处理输出，还是最好进行编辑？
- en: Are returns and exits properly implemented, or do they need to be adjusted to
    work as a generic library function?
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回和退出是否已经正确实现，还是需要调整以作为通用库函数工作？
- en: There are no right or wrong answers here, just things to consider. Good luck!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有对错之分，只是需要考虑的事情。祝你好运！
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have presented Bash functions. Functions are generic chains
    of commands that can be defined once, before being called multiple times. Functions
    are reusable and can be shared between multiple scripts.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Bash函数。函数是可以定义一次，然后被多次调用的通用命令链。函数是可重用的，并且可以在多个脚本之间共享。
- en: 'Variable scopes were introduced. The variables we''ve seen thus far were always
    *globally* scoped: they were available to the entire script. However, with the
    introduction of functions, we encounter *locally* scoped variables. These are
    only accessible within a function and marked with the `local` keyword.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了变量作用域。到目前为止，我们看到的变量始终是*全局*作用域：它们对整个脚本都是可用的。然而，引入函数后，我们遇到了*局部*作用域的变量。这些变量只能在函数内部访问，并且用`local`关键字标记。
- en: We learned that functions can have their own independent set of parameters,
    which can be passed as arguments when the function is called. We proved that these
    are in fact different from the global arguments passed to the script (unless all
    arguments are passed through to the function, of course). We gave an example about
    returning output from a function using `stdout`, which we could capture by encapsulating
    the function call in a command substitution.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到函数可以有自己独立的参数集，可以在调用函数时作为参数传递。我们证明了这些参数实际上与传递给脚本的全局参数不同（当然，除非所有参数都通过函数传递）。我们举了一个例子，关于如何使用`stdout`从函数返回输出，我们可以通过将函数调用封装在命令替换中来捕获它。
- en: 'In the second half of this chapter, we turned our attention to creating a function
    library: an independent script without actual commands, which can be included
    (via the `source` command) in another script. As soon as the library is sourced
    in another script, all functions defined in the library can then be used by the
    script. We spent the remainder of this chapter showing how this was done, while
    simultaneously expanding our function library with some practical utility functions.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下半部分，我们把注意力转向创建一个函数库：一个独立的脚本，没有实际命令，可以被包含（通过`source`命令）在另一个脚本中。一旦库在另一个脚本中被引用，库中定义的所有函数就可以被脚本使用。我们在本章的剩余部分展示了如何做到这一点，同时用一些实用的实用函数扩展了我们的函数库。
- en: We ended the chapter with an exercise for the reader, to make sure all functions
    defined in this chapter are included in their own personal function library.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一个练习结束了本章，以确保本章中定义的所有函数都包含在他们自己的个人函数库中。
- en: 'The following commands were introduced in this chapter: `top`, `free`, `declare`,
    `case`, `rev`, and `return`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了以下命令：`top`，`free`，`declare`，`case`，`rev`和`return`。
- en: Questions
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: In which two ways can we define a function?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以用哪两种方式定义一个函数？
- en: What are some advantages of functions?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的一些优点是什么？
- en: What is the difference between a globally scoped variable and a locally scoped
    one?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 全局作用域变量和局部作用域变量之间有什么区别？
- en: How can we set values and attributes to variables?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何给变量设置值和属性？
- en: How can a function use arguments passed to it?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数如何使用传递给它的参数？
- en: How can we return a value from a function?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何从函数中返回一个值？
- en: What does the `source` command do?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`source`命令是做什么的？'
- en: Why would we want to create a function library?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们想要创建一个函数库？
- en: Further reading
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**Linux performance monitoring**: [https://linoxide.com/monitoring-2/linux-performance-monitoring-tools/](https://linoxide.com/monitoring-2/linux-performance-monitoring-tools/)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux性能监控**：[https://linoxide.com/monitoring-2/linux-performance-monitoring-tools/](https://linoxide.com/monitoring-2/linux-performance-monitoring-tools/)'
- en: '**AWK basic tutorial**: [https://mistonline.in/wp/awk-basic-tutorial-with-examples/](https://mistonline.in/wp/awk-basic-tutorial-with-examples/)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWK基础教程**：[https://mistonline.in/wp/awk-basic-tutorial-with-examples/](https://mistonline.in/wp/awk-basic-tutorial-with-examples/)'
- en: '**Advanced Bash variables**: [https://www.thegeekstuff.com/2010/05/bash-variables/](https://www.thegeekstuff.com/2010/05/bash-variables/)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级Bash变量**：[https://www.thegeekstuff.com/2010/05/bash-variables/](https://www.thegeekstuff.com/2010/05/bash-variables/)'
- en: '**Sourcing**: [https://bash.cyberciti.biz/guide/Source_command](https://bash.cyberciti.biz/guide/Source_command)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**获取来源**: [https://bash.cyberciti.biz/guide/Source_command](https://bash.cyberciti.biz/guide/Source_command)'
