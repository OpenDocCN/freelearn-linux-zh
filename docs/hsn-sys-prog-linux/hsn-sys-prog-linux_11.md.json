["```\nint main(void)\n{\n     unsigned long int i=1;\n     while(1) {\n         printf(\"Looping, iteration #%02ld ...\\n\", i++);\n         (void)sleep(1);\n     }\n     exit (EXIT_SUCCESS);\n}\n```", "```\n$ ./sig1 \nLooping, iteration #01 ...\nLooping, iteration #02 ...\nLooping, iteration #03 ...\n^C\n$ \n```", "```\n$ kill -l\n 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP\n 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1\n11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM\n16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP\n21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ\n26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR\n31) SIGSYS    34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3\n38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8\n43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 \n47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 \n51) SIGRTMAX-13 52) SIGRTMAX-12  53) SIGRTMAX-11 54) SIGRTMAX-10 \n55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7 58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2 63) SIGRTMAX-1 64) SIGRTMAX \n$ \n```", "```\n#include <signal.h>\nint sigaction(int signum, const struct sigaction *act,\n struct sigaction *oldact);\n```", "```\n/* Structure describing the action to be taken when a signal arrives. */\nstruct sigaction\n  {\n    /* Signal handler. */\n#ifdef __USE_POSIX199309\n    union\n      {\n        /* Used if SA_SIGINFO is not set. */\n        __sighandler_t sa_handler;\n        /* Used if SA_SIGINFO is set. */\n        void (*sa_sigaction) (int, siginfo_t *, void *); \n      } \n    __sigaction_handler;\n# define sa_handler __sigaction_handler.sa_handler\n# define sa_sigaction __sigaction_handler.sa_sigaction\n#else\n    __sighandler_t sa_handler;\n#endif\n\n    /* Additional set of signals to be blocked. */\n    __sigset_t sa_mask;\n\n    /* Special flags. */\n    int sa_flags;\n\n    /* Restore handler. */\n    void (*sa_restorer) (void);\n  };\n```", "```\nint main(void)\n{\n unsigned long int i = 1;\n struct sigaction act;\n\n /* Init sigaction to defaults via the memset,\n  * setup 'siggy' as the signal handler function,\n  * trap just the SIGINT and SIGQUIT signals.\n  */\n memset(&act, 0, sizeof(act));\n act.sa_handler = siggy;\n if (sigaction(SIGINT, &act, 0) < 0)\n     FATAL(\"sigaction on SIGINT failed\");\n if (sigaction(SIGQUIT, &act, 0) < 0)\n     FATAL(\"sigaction on SIGQUIT failed\");\n\n while (1) {\n     printf(\"Looping, iteration #%02ld ...\\n\", i++);\n     (void)sleep(1);\n } [...]\n```", "```\nstatic void siggy(int signum)\n{\n  const char *str1 = \"*** siggy: handled SIGINT ***\\n\";\n  const char *str2 = \"*** siggy: handled SIGQUIT ***\\n\";\n\n  switch (signum) {\n  case SIGINT:\n    if (write(STDOUT_FILENO, str1, strlen(str1)) < 0)\n        WARN(\"write str1 failed!\");\n    return;\n  case SIGQUIT:\n    if (write(STDOUT_FILENO, str2, strlen(str2)) < 0)\n        WARN(\"write str2 failed!\");\n    return;\n  }\n}\n```", "```\n$ make sig2\ngcc -Wall -c ../common.c -o common.o\ngcc -Wall -c -o sig2.o sig2.c\ngcc -Wall -o sig2 sig2.c common.o\n$ ./sig2\nLooping, iteration #01 ...\nLooping, iteration #02 ...\nLooping, iteration #03 ...\n^C*** siggy: handled SIGINT ***\nLooping, iteration #04 ...\nLooping, iteration #05 ...\n^\\*** siggy: handled SIGQUIT ***\nLooping, iteration #06 ...\nLooping, iteration #07 ...\n^C*** siggy: handled SIGINT ***\nLooping, iteration #08 ...\nLooping, iteration #09 ...\n^\\*** siggy: handled SIGQUIT ***\nLooping, iteration #10 ...\nLooping, iteration #11 ...\n^Z\n[1]+ Stopped ./sig2\n$ kill %1\n[1]+ Terminated ./sig2\n$ \n```", "```\n...\n/* Additional set of signals to be blocked. */\n    __sigset_t sa_mask;\n...\n```", "```\n[...]\n/* Init sigaction:\n * setup 'my_handler' as the signal handler function,\n * trap just the SIGINT and SIGQUIT signals.\n */\n memset(&act, 0, sizeof(act));\n act.sa_handler = my_handler;\n /* This is interesting: we fill the signal mask, implying that\n * _all_ signals are masked (blocked) while the signal handler\n * runs! */\n sigfillset(&act.sa_mask);\n\n if (sigaction(SIGINT, &act, 0) < 0)\n     FATAL(\"sigaction on SIGINT failed\");\n if (sigaction(SIGQUIT, &act, 0) < 0)\n     FATAL(\"sigaction on SIGQUIT failed\");\n[...]\n```", "```\nstatic void my_handler(int signum)\n{\n    const char *str1 = \"*** my_handler: handled SIGINT ***\\n\";\n    const char *str2 = \"*** my_handler: handled SIGQUIT ***\\n\";\n\n    show_blocked_signals();\n    switch (signum) {\n    [...]\n```", "```\n/*\n * Signaling: Prints (to stdout) all signal integer values that are\n * currently in the Blocked (masked) state.\n */\nint show_blocked_signals(void)\n{\n     sigset_t oldset;\n     int i, none=1;\n\n     /* sigprocmask: \n      * int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);\n      * if 'set' is NULL, the 'how' is ignored, but the\n      * 'oldset' sigmask value is populated; thus we can query the\n      * signal mask without altering it.\n      */\n      sigemptyset(&oldset);\n      if (sigprocmask(SIG_UNBLOCK, 0, &oldset) < 0)\n          return -1;\n\n      printf(\"\\n[SigBlk: \");\n      for (i=1; i<=64; i++) {\n          if (sigismember(&oldset, i)) {\n              none=0;\n              printf(\"%d \", i);\n            }\n      }\n      if (none)\n          printf(\"-none-]\\n\");\n      else\n          printf(\"]\\n\");\n      fflush(stdout);\n      return 0;\n}\n```", "```\n$ make query_mask \ngcc -Wall -c ../common.c -o common.o\ngcc -Wall -c -o query_mask.o query_mask.c\ngcc -Wall -o query_mask query_mask.c common.o\n$ ./query_mask \nLooping, iteration #01 ...\nLooping, iteration #02 ...\nLooping, iteration #03 ...\n^C\n[SigBlk: 1 2 3 4 5 6 7 8 10 11 12 13 14 15 16 17 18 20 21 22 23 24 25 26 27 28 29 30 31 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 ]\n*** my_handler: handled SIGINT ***\nLooping, iteration #04 ...\nLooping, iteration #05 ...\n^\\\n[SigBlk: 1 2 3 4 5 6 7 8 10 11 12 13 14 15 16 17 18 20 21 22 23 24 25 26 27 28 29 30 31 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 ]\n*** my_handler: handled SIGQUIT ***\nLooping, iteration #06 ...\nLooping, iteration #07 ...\n^Z\n[2]+ Stopped ./query_mask\n$ kill %2\n[2]+ Terminated ./query_mask\n$ \n```", "```\nsignal_handler(sig) \n{ \n    my_foo();\n    < ... > \n}\n\nmy_foo()\n{\n    char mybuf[MAX];\n    <...>\n}\n\ndo_the_work_mate()\n{\n    my_foo();\n    <...>\n}\n```", "```\n/* Special flags. */\n    int sa_flags;\n```", "```\nstatic void child_dies(int signum)\n{\n    while((pid = wait3(0, WNOHANG, 0)) != -1);\n}\n```", "```\nint main(int argc, char **argv)\n{\n  struct sigaction act;\n  int opt=0;\n\n  if (argc != 2)\n      usage(argv[0]);\n\n  opt = atoi(argv[1]);\n  if (opt != 1 && opt != 2)\n      usage(argv[0]);\n\n  memset(&act, 0, sizeof(act));\n  if (opt == 1) {\n        act.sa_handler = child_dies;\n        /* 2.6 Linux: prevent zombie on termination of child(ren)! */\n        act.sa_flags = SA_NOCLDWAIT;\n  }\n  if (opt == 2)\n        act.sa_handler = SIG_IGN;\n  act.sa_flags |= SA_RESTART | SA_NOCLDSTOP; /* no SIGCHLD on stop of child(ren) */\n\n  if (sigaction(SIGCHLD, &act, 0) == -1)\n      FATAL(\"sigaction failed\");\n\n  printf(\"parent: %d\\n\", getpid());\n  switch (fork()) {\n  case -1:\n      FATAL(\"fork failed\");\n  case 0: // Child\n      printf(\"child: %d\\n\", getpid());\n      DELAY_LOOP('c', 25);\n      exit(0);\n  default: // Parent\n      while (1)\n          pause();\n  }\n  exit(0);\n}\n```", "```\n#define DEBUG\n//#undef DEBUG\n/* SIGCHLD handler */\nstatic void child_dies(int signum)\n{\n#ifdef DEBUG\n   printf(\"\\n*** Child dies! ***\\n\");\n#endif\n}\n```", "```\n$ ./zombies_clear_linux26 \nUsage: ./zombies_clear_linux26 {option-to-prevent-zombies}\n 1 : (2.6 Linux) using the SA_NOCLDWAIT flag with sigaction(2)\n 2 : just ignore the signal SIGCHLD\n$ \n```", "```\n$ ./zombies_clear_linux26 1 &\n[1] 10239\nparent: 10239\nchild: 10241\nc $ cccccccccccccccccccccccc\n*** Child dies! ***\n\n$ ps \n PID TTY TIME CMD\n 9490 pts/1 00:00:00 bash\n10239 pts/1 00:00:00 zombies_clear_l\n10249 pts/1 00:00:00 ps\n$ \n```", "```\n$ ./zombies_clear_linux26 2\nparent: 10354\nchild: 10355\nccccccccccccccccccccccccc\n^C\n$ \n```", "```\n[...]\nsigaction(SIGCHLD, &sigact, 0);\n[...]\nsd = accept( <...> );\n[...]\n```", "```\nwhile ((foo() == -1) && (errno == EINTR));\n```", "```\nstatic volatile sig_atomic_t s=0, t=0;\n[...]\nint main(int argc, char **argv)\n{\n int flags=0;\n struct sigaction act;\n[...]\n flags = SA_RESTART;\n if (atoi(argv[1]) == 2) {\n     flags |= SA_NODEFER;\n     printf(\"Running with the SA_NODEFER signal flag Set\\n\");\n } else {\n     printf(\"Running with the SA_NODEFER signal flag Cleared [default]\\n\");\n }\n\n memset(&act, 0, sizeof(act));\n act.sa_handler = sighdlr;\n act.sa_flags = flags;\n if (sigaction(SIGUSR1, &act, 0) == -1)\n     FATAL(\"sigaction failed\\n\");\n fprintf(stderr, \"\\nProcess awaiting signals ...\\n\");\n\n while (1)\n     (void)pause();\n exit(EXIT_SUCCESS);\n}\n```", "```\n/* \n * Strictly speaking, should not use fprintf here as it's not\n * async-signal safe; indeed, it sometimes does not work well!\n */\nstatic void sighdlr(int signum)\n{\n  int saved;\n  fprintf(stderr, \"\\nsighdlr: signal %d,\", signum);\n  switch (signum) {\n  case SIGUSR1:\n s ++; t ++;\n    if (s >= MAX)\n          s = 1;\n    saved = s;\n    fprintf(stderr, \" s=%d ; total=%d; stack %p :\", s, t, stack());\n DELAY_LOOP(saved+48, 5); /* +48 to get the equivalent ASCII value */\n fprintf(stderr, \"*\");\n    break;\n  default:;\n  }\n}\n```", "```\n/* \n * stack(): return the current value of the stack pointer register.\n * The trick/hack: on x86 CPU's, the ABI tells us that the return\n * value is always in the accumulator (EAX/RAX); so we just initialize\n * it to the stack pointer (using inline assembly)!\n */\nvoid *stack(void)\n{\n if (__WORDSIZE == 32) {\n     __asm__(\"movl %esp, %eax\");\n } else if (__WORDSIZE == 64) {\n     __asm__(\"movq %rsp, %rax\");\n }\n/* Accumulator holds the return value */\n}\n```", "```\nSIG=SIGUSR1\n[...]\nNUMSIGS=$2\nn=1\nif [ ${NUMSIGS} -eq -1 ] ; then\n  echo \"Sending signal ${SIG} continually to process ${1} ...\"\n  while [ true ] ; do\n    kill -${SIG} $1\n    sleep 10e-03    # 10 ms\n  done\nelse\n  echo \"Sending ${NUMSIGS} instances of signal ${SIG} to process ${1} ...\"\n  while [ ${n} -le ${NUMSIGS} ] ; do\n    kill -${SIG} $1\n    sleep 10e-03    # 10 ms\n    let n=n+1\n  done\nfi\n```", "```\n$ ./defer_or_not \nUsage: ./defer_or_not {option}\noption=1 : don't use (clear) SA_NODEFER flag (default sigaction style)\noption=2 : use (set) SA_NODEFER flag (will process signal immd)\n$ ./defer_or_not 1\nPID 3016: running with the SA_NODEFER signal flag Cleared [default]\nProcess awaiting signals ...\n```", "```\n$ ./bombard_sig.sh $(pgrep defer_or_not) 12\n```", "```\n\u200bsighdlr: signal 10, s=1 ; total=1; stack 0x7ffc8d021a70 :11111*\nsighdlr: signal 10, s=2 ; total=2; stack 0x7ffc8d021a70 :22222*\n```", "```\n$ ./defer_or_not 2 PID 3215: running with the SA_NODEFER signal flag Set\nProcess awaiting signals ...\n```", "```\n$ ./bombard_sig.sh $(pgrep defer_or_not) 12\n```", "```\nsighdlr: signal 10, s=1 ; total=1; stack 0x7ffe9e17a0b0 :\nsighdlr: signal 10, s=2 ; total=2; stack 0x7ffe9e1799b0 :2\nsighdlr: signal 10, s=3 ; total=3; stack 0x7ffe9e1792b0 :3\nsighdlr: signal 10, s=4 ; total=4; stack 0x7ffe9e178bb0 :4\nsighdlr: signal 10, s=5 ; total=5; stack 0x7ffe9e1784b0 :5\nsighdlr: signal 10, s=6 ; total=6; stack 0x7ffe9e177db0 :6\nsighdlr: signal 10, s=7 ; total=7; stack 0x7ffe9e1776b0 :7\nsighdlr: signal 10, s=8 ; total=8; stack 0x7ffe9e176fb0 :8\nsighdlr: signal 10, s=9 ; total=9; stack 0x7ffe9e1768b0 :9\nsighdlr: signal 10, s=1 ; total=10; stack 0x7ffe9e1761b0 :1\nsighdlr: signal 10, s=2 ; total=11; stack 0x7ffe9e175ab0 :22222*1111*9999*8888*7777*6666*5555*4444*3333*2222*11111*\nsighdlr: signal 10, s=3 ; total=12; stack 0x7ffe9e17adb0 :33333*\n```", "```\n$ ./defer_or_not 2\nPID 7815: running with the SA_NODEFER signal flag Set\nProcess awaiting signals ...\n```", "```\n$ ./bombard_sig.sh $(pgrep defer_or_not) 5000\nSending 5000 instances of signal SIGUSR1 to process 7815 ...\n```", "```\n<...>\nsighdlr: signal 10, s=1 ; total=1; stack 0x7ffe519b3130 :1\nsighdlr: signal 10, s=2 ; total=2; stack 0x7ffe519b2a30 :2\nsighdlr: signal 10, s=3 ; total=3; stack 0x7ffe519b2330 :3\nsighdlr: signal 10, s=4 ; total=4; stack 0x7ffe519b1c30 :4\nsighdlr: signal 10, s=5 ; total=5; stack 0x7ffe519b1530 :5\nsighdlr: signal 10, s=6 ; total=6; stack 0x7ffe519b0e30 :6\nsighdlr: signal 10, s=7 ; total=7; stack 0x7ffe519b0730 :7\nsighdlr: signal 10, s=8 ; total=8; stack 0x7ffe519b0030 :8\nsighdlr: signal 10, s=9 ; total=9; stack 0x7ffe519af930 :9\nsighdlr: signal 10, s=1 ; total=10; stack 0x7ffe519af230 :1\nsighdlr: signal 10, s=2 ; total=11; stack 0x7ffe519aeb30 :2\n\n*--snip--*\n\nsighdlr: signal 10, s=8 ; total=2933; stack 0x7ffe513a2d30 :8\nsighdlr: signal 10, s=9 ; total=2934; stack 0x7ffe513a2630 :9\nsighdlr: signal 10, s=1 ; total=2935; stack 0x7ffe513a1f30 :1\nsighdlr: signal 10, s=2 ; total=2936; stack 0x7ffe513a1830 :2\nsighdlr: signal 10, s=3 ; total=2937; stack 0x7ffe513a1130 :Segmentation fault\n$ \n```", "```\n<...>\naltstacksz = atoi(argv[1])*1024;\nsetup_altsigstack(altstacksz);\n<...>\n```", "```\nstatic void setup_altsigstack(size_t stack_sz)\n{\n     stack_t ss;\n     printf(\"Alt signal stack size = %zu\\n\", stack_sz);\n     ss.ss_sp = malloc(stack_sz);\n     if (!ss.ss_sp)\n         FATAL(\"malloc(%zu) for alt sig stack failed\\n\", stack_sz);\n     ss.ss_size = stack_sz;\n     ss.ss_flags = 0;\n     if (sigaltstack(&ss, NULL) == -1)\n         FATAL(\"sigaltstack for size %zu failed!\\n\", stack_sz);\n}\n```", "```\nstatic volatile sig_atomic_t s=0, t=0;\nstatic volatile unsigned long stk_start=0, stk=0;\n\nstatic void sighdlr(int signum)\n{\n     if (t == 0)\n         stk_start = (unsigned long)stack();\n     switch (signum) {\n     case SIGUSR1:\n         stk = (unsigned long)stack();\n         s ++; t ++;\n         if (s >= MAX)\n         s = 1;\n         fprintf(stderr, \" s=%d ; total=%d; stack %p\\n\", s, t, stack());\n    /* Spend some time inside the signal handler ... */\n         DELAY_LOOP_SILENT(5);\n         break;\n case SIGUSR2:\n         fprintf(stderr, \"*** signal %d:: stack@: t0=%lx last=%lx :               delta=%ld ***\\n\", signum, stk_start, stk, (stk_start-stk));\n         break;\n case SIGSEGV:\n         fprintf(stderr, \"*** signal %d:: stack@: t0=%lx last=%lx :     \n          delta=%ld ***\\n\", signum, stk_start, stk, (stk_start-stk));\n         abort();\n     }\n}\n```", "```\n$ ./altstack 100\nAlt signal stack size = 102400\nRunning: signal SIGUSR1 flags: SA_NODEFER | SA_ONSTACK | SA_RESTART\nProcess awaiting signals ...\n```", "```\n$ ./bombard_sig.sh $(pgrep altstack) 120\nSending 120 instances of signal SIGUSR1 to process 12811 ...\n```", "```\n<...>\n s=1 ; total=1; stack 0xa20ff0\n s=2 ; total=2; stack 0xa208f0\n s=3 ; total=3; stack 0xa201f0\n\n*--snip--*\n\n s=1 ; total=49; stack 0xa0bff0\n s=2 ; total=50; stack 0xa0b8f0\n s=3 ; total=51; stack 0xa0b1f0\n*** signal 11:: stack@: t0=a20ff0 last=a0aaf0 : delta=91392 ***\nAborted\n$ \n```", "```\n<...>\n./bombard_sig.sh: line 30: kill: (12811) - No such process\nbombard_sig.sh: kill failed, loop count=53\n$\n```", "```\n$ ./altstack 16384\nAlt signal stack size = 16777216\nRunning: signal SIGUSR1 flags: SA_NODEFER | SA_ONSTACK | SA_RESTART\nProcess awaiting signals ...\n```", "```\n$ ./bombard_sig.sh $(pgrep altstack) 12000\nSending 12000 instances of signal SIGUSR1 to process 13325 ...\n```", "```\n<...>\n s=1 ; total=1; stack 0x7fd7339239b0\n s=2 ; total=2; stack 0x7fd7339232b0\n s=3 ; total=3; stack 0x7fd733922bb0\n\n*--snip--*\n\n s=2 ; total=9354; stack 0x7fd732927ab0\n s=3 ; total=9355; stack 0x7fd7329273b0\n*** signal 11:: stack@: t0=7fd7339239b0 last=7fd732926cb0 : delta=16764160 ***\nAborted\n$ \n```", "```\n./bombard_sig.sh: line 30: kill: (13325) - No such process\nbombard_sig.sh: kill failed, loop count=9357\n$ \n```"]