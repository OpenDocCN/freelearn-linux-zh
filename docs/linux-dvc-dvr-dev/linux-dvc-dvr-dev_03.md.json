["```\n struct person { \n     int  age; \n     char *name; \n } p;\n```", "```\n#define container_of(ptr, type, member) ({               \\ \n   const typeof(((type *)0)->member) * __mptr = (ptr);   \\ \n   (type *)((char *)__mptr - offsetof(type, member)); }) \n```", "```\ncontainer_of(pointer, container_type, container_field); \n```", "```\nstruct person { \n     int  age; \n     char *name; \n }; \n```", "```\nstruct person somebody; \n[...] \nchar *the_name_ptr = somebody.name; \n```", "```\nstruct person *the_person; \nthe_person = container_of(the_name_ptr, struct person, name); \n```", "```\n(type *)( (char *)__mptr - offsetof(type,member) ); \n```", "```\nstruct family { \n    struct person *father; \n    struct person *mother; \n    int number_of_suns; \n    int salary; \n} f; \n\n/* \n * pointer to a field of the structure \n * (could be any member of any family) \n*/ \nstruct *person = family.father; \nstruct family *fam_ptr; \n\n/* now let us retrieve back its family */ \nfam_ptr = container_of(person, struct family, father); \n```", "```\nstruct mcp23016 { \n    struct i2c_client *client; \n    struct gpio_chip chip; \n} \n\n/* retrive the mcp23016 struct given a pointer 'chip' field */ \nstatic inline struct mcp23016 *to_mcp23016(struct gpio_chip *gc) \n{ \n    return container_of(gc, struct mcp23016, chip); \n} \n\nstatic int mcp23016_probe(struct i2c_client *client, \n                const struct i2c_device_id *id) \n{ \n    struct mcp23016 *mcp; \n    [...] \n    mcp = devm_kzalloc(&client->dev, sizeof(*mcp), GFP_KERNEL); \n    if (!mcp) \n        return -ENOMEM; \n    [...] \n} \n```", "```\nstruct list_head { \n    struct list_head *next, *prev; \n }; \n```", "```\nstruct car { \n    int door_number; \n    char *color; \n    char *model; \n}; \n```", "```\nstruct car { \n    int door_number; \n    char *color; \n    char *model; \n    struct list_head list; /* kernel's list structure */ \n}; \n```", "```\nstatic LIST_HEAD(carlist) ; \n```", "```\n#include <linux/list.h> \n\nstruct car *redcar = kmalloc(sizeof(*car), GFP_KERNEL); \nstruct car *bluecar = kmalloc(sizeof(*car), GFP_KERNEL); \n\n/* Initialize each node's list entry */ \nINIT_LIST_HEAD(&bluecar->list); \nINIT_LIST_HEAD(&redcar->list); \n\n/* allocate memory for color and model field and fill every field */ \n [...] \nlist_add(&redcar->list, &carlist) ; \nlist_add(&bluecar->list, &carlist) ; \n```", "```\nstruct list_head mylist; \nINIT_LIST_HEAD(&mylist); \n```", "```\nstatic inline void INIT_LIST_HEAD(struct list_head *list) \n   { \n       list->next = list; \n       list->prev = list; \n   } \n```", "```\nLIST_HEAD(mylist) \n```", "```\n#define LIST_HEAD(name) \\ \n    struct list_head name = LIST_HEAD_INIT(name) \n```", "```\n#define LIST_HEAD_INIT(name) { &(name), &(name) } \n```", "```\nstruct car *blackcar = kzalloc(sizeof(struct car), GFP_KERNEL); \n\n/* non static initialization, since it is the embedded list field*/ \nINIT_LIST_HEAD(&blackcar->list); \n```", "```\nvoid list_add(struct list_head *new, struct list_head *head); \nstatic inline void list_add(struct list_head *new, struct list_head *head) \n{ \n    __list_add(new, head, head->next); \n} \n```", "```\nstatic inline void __list_add(struct list_head *new, \n                  struct list_head *prev, \n                  struct list_head *next) \n{ \n    next->prev = new; \n    new->next = next; \n    new->prev = prev; \n    prev->next = new; \n} \n```", "```\nlist_add(&redcar->list, &carlist); \nlist_add(&blue->list, &carlist); \n```", "```\nvoid list_add_tail(struct list_head *new, struct list_head *head); \n```", "```\nlist_add_tail(&redcar->list, &carlist); \nlist_add_tail(&blue->list, &carlist); \n```", "```\n void list_del(struct list_head *entry); \n```", "```\nlist_del(&redcar->list); \n```", "```\nstruct car *acar; /* loop counter */ \nint blue_car_num = 0; \n\n/* 'list' is the name of the list_head struct in our data structure */ \nlist_for_each_entry(acar, carlist, list){ \n    if(acar->color == \"blue\") \n        blue_car_num++; \n} \n\n```", "```\n#define list_for_each_entry(pos, head, member)      \\ \nfor (pos = list_entry((head)->next, typeof(*pos), member);   \\ \n     &pos->member != (head);        \\ \n     pos = list_entry(pos->member.next, typeof(*pos), member)) \n\n#define list_entry(ptr, type, member) \\ \n    container_of(ptr, type, member) \n```", "```\nstruct __wait_queue { \n    unsigned int flags; \n#define WQ_FLAG_EXCLUSIVE 0x01 \n    void *private; \n    wait_queue_func_t func; \n    struct list_head task_list; \n}; \n```", "```\nDECLARE_WAIT_QUEUE_HEAD(name) \n```", "```\nwait_queue_head_t my_wait_queue; \ninit_waitqueue_head(&my_wait_queue); \n```", "```\n/* \n * block the current task (process) in the wait queue if \n * CONDITION is false \n */ \nint wait_event_interruptible(wait_queue_head_t q, CONDITION); \n```", "```\n/* \n * wake up one process sleeping in the wait queue if  \n * CONDITION above has become true \n */ \nvoid wake_up_interruptible(wait_queue_head_t *q); \n```", "```\n#include <linux/module.h> \n#include <linux/init.h> \n#include <linux/sched.h> \n#include <linux/time.h> \n#include <linux/delay.h> \n#include<linux/workqueue.h> \n\nstatic DECLARE_WAIT_QUEUE_HEAD(my_wq); \nstatic int condition = 0; \n\n/* declare a work queue*/        \nstatic struct work_struct wrk; \n\nstatic void work_handler(struct work_struct *work) \n{  \n    printk(\"Waitqueue module handler %s\\n\", __FUNCTION__); \n    msleep(5000); \n    printk(\"Wake up the sleeping module\\n\"); \n    condition = 1; \n    wake_up_interruptible(&my_wq); \n} \n\nstatic int __init my_init(void) \n{ \n    printk(\"Wait queue example\\n\"); \n\n    INIT_WORK(&wrk, work_handler); \n    schedule_work(&wrk); \n\n    printk(\"Going to sleep %s\\n\", __FUNCTION__); \n    wait_event_interruptible(my_wq, condition != 0); \n\n    pr_info(\"woken up by the work job\\n\"); \n    return 0; \n} \n\nvoid my_exit(void) \n{ \n    printk(\"waitqueue example cleanup\\n\"); \n} \n\nmodule_init(my_init); \nmodule_exit(my_exit); \nMODULE_AUTHOR(\"John Madieu <john.madieu@foobar.com>\"); \nMODULE_LICENSE(\"GPL\"); \n```", "```\n    [342081.385491] Wait queue example\n\n    [342081.385505] Going to sleep my_init\n\n    [342081.385515] Waitqueue module handler work_handler\n\n    [342086.387017] Wake up the sleeping module\n\n    [342086.387096] woken up by the work job\n\n    [342092.912033] waitqueue example cleanup\n\n```", "```\nextern u64 jiffies_64; \n```", "```\n#include <linux/timer.h> \n\nstruct timer_list { \n    struct list_head entry; \n    unsigned long expires; \n    struct tvec_t_base_s *base; \n    void (*function)(unsigned long); \n    unsigned long data; \n); \n```", "```\nvoid setup_timer( struct timer_list *timer, \\ \n           void (*function)(unsigned long), \\ \n           unsigned long data); \n```", "```\nvoid init_timer(struct timer_list *timer); \n```", "```\nint mod_timer( struct timer_list *timer, unsigned long expires); \n```", "```\nvoid del_timer(struct timer_list *timer); \nint del_timer_sync(struct timer_list *timer); \n```", "```\nint timer_pending( const struct timer_list *timer); \n```", "```\n#include <linux/init.h> \n#include <linux/kernel.h> \n#include <linux/module.h> \n#include <linux/timer.h> \n\nstatic struct timer_list my_timer; \n\nvoid my_timer_callback(unsigned long data) \n{ \n    printk(\"%s called (%ld).\\n\", __FUNCTION__, jiffies); \n} \n\nstatic int __init my_init(void) \n{ \n    int retval; \n    printk(\"Timer module loaded\\n\"); \n\n    setup_timer(&my_timer, my_timer_callback, 0); \n    printk(\"Setup timer to fire in 300ms (%ld)\\n\", jiffies); \n\n    retval = mod_timer( &my_timer, jiffies + msecs_to_jiffies(300) ); \n    if (retval) \n        printk(\"Timer firing failed\\n\"); \n\n    return 0; \n} \n\nstatic void my_exit(void) \n{ \n    int retval; \n    retval = del_timer(&my_timer); \n    /* Is timer still active (1) or no (0) */ \n    if (retval) \n        printk(\"The timer is still in use...\\n\"); \n\n    pr_info(\"Timer module unloaded\\n\"); \n} \n\nmodule_init(my_init); \nmodule_exit(my_exit); \nMODULE_AUTHOR(\"John Madieu <john.madieu@gmail.com>\"); \nMODULE_DESCRIPTION(\"Standard timer example\"); \nMODULE_LICENSE(\"GPL\"); \n```", "```\n#include <linux/hrtimer.h> \n```", "```\nstruct hrtimer { \n   struct timerqueue_node node; \n   ktime_t _softexpires; \n   enum hrtimer_restart (*function)(struct hrtimer *); \n   struct hrtimer_clock_base *base; \n   u8 state; \n   u8 is_rel; \n}; \n```", "```\n void hrtimer_init( struct hrtimer *time, clockid_t which_clock, \n                    enum hrtimer_mode mode); \n```", "```\nint hrtimer_start( struct hrtimer *timer, ktime_t time, \n                    const enum hrtimer_mode mode); \n```", "```\nint hrtimer_cancel( struct hrtimer *timer); \nint hrtimer_try_to_cancel(struct hrtimer *timer); \n```", "```\nint hrtimer_callback_running(struct hrtimer *timer); \n```", "```\nstruct mutex { \n    /* 1: unlocked, 0: locked, negative: locked, possible waiters */ \n    atomic_t count; \n    spinlock_t wait_lock; \n    struct list_head wait_list; \n    [...] \n}; \n```", "```\nDEFINE_MUTEX(my_mutex); \n```", "```\nstruct mutex my_mutex; \nmutex_init(&my_mutex); \n```", "```\nvoid mutex_lock(struct mutex *lock); \nint  mutex_lock_interruptible(struct mutex *lock); \nint  mutex_lock_killable(struct mutex *lock); \n```", "```\nvoid mutex_unlock(struct mutex *lock); \n```", "```\nint mutex_is_locked(struct mutex *lock); \n```", "```\nint mutex_trylock(struct mutex *lock); \n```", "```\nstruct mutex my_mutex; \nmutex_init(&my_mutex); \n\n/* inside a work or a thread */ \nmutex_lock(&my_mutex); \naccess_shared_memory(); \nmutex_unlock(&my_mutex); \n```", "```\n/* some where */ \nspinlock_t my_spinlock; \nspin_lock_init(my_spinlock); \n\nstatic irqreturn_t my_irq_handler(int irq, void *data) \n{ \n    unsigned long status, flags; \n\n    spin_lock_irqsave(&my_spinlock, flags); \n    status = access_shared_resources(); \n\n    spin_unlock_irqrestore(&gpio->slock, flags); \n    return IRQ_HANDLED; \n} \n```", "```\nstruct tasklet_struct \n{ \n    struct tasklet_struct *next; \n    unsigned long state; \n    atomic_t count; \n    void (*func)(unsigned long); \n    unsigned long data; \n}; \n```", "```\nvoid tasklet_init(struct tasklet_struct *t, \n          void (*func)(unsigned long), unsigned long data); \n```", "```\nDECLARE_TASKLET( tasklet_example, tasklet_function, tasklet_data ); \nDECLARE_TASKLET_DISABLED(name, func, data); \n```", "```\n#define DECLARE_TASKLET(name, func, data) \\ \n    struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(0), func, data } \n\n#define DECLARE_TASKLET_DISABLED(name, func, data) \\ \n    struct tasklet_struct name = { NULL, 0, ATOMIC_INIT(1),  func, data } \n```", "```\nvoid tasklet_enable(struct tasklet_struct *); \n```", "```\nvoid tasklet_disable(struct tasklet_struct *); \n```", "```\nvoid tasklet_disable_nosync(struct tasklet_struct *); \n```", "```\nvoid tasklet_schedule(struct tasklet_struct *t); \nvoid tasklet_hi_schedule(struct tasklet_struct *t);\n```", "```\nvoid tasklet_kill(struct tasklet_struct *t); \n```", "```\n#include <linux/kernel.h> \n#include <linux/module.h> \n#include <linux/interrupt.h>    /* for tasklets API */ \n\nchar tasklet_data[]=\"We use a string; but it could be pointer to a structure\"; \n\n/* Tasklet handler, that just print the data */ \nvoid tasklet_work(unsigned long data) \n{ \n    printk(\"%s\\n\", (char *)data); \n} \n\nDECLARE_TASKLET(my_tasklet, tasklet_function, (unsigned long) tasklet_data); \n\nstatic int __init my_init(void) \n{ \n    /* \n     * Schedule the handler. \n     * Tasklet arealso scheduled from interrupt handler \n     */ \n    tasklet_schedule(&my_tasklet); \n    return 0; \n} \n\nvoid my_exit(void) \n{ \n    tasklet_kill(&my_tasklet); \n} \n\nmodule_init(my_init); \nmodule_exit(my_exit); \nMODULE_AUTHOR(\"John Madieu <john.madieu@gmail.com>\"); \nMODULE_LICENSE(\"GPL\"); \n```", "```\nint schedule_work(struct work_struct *work); \n```", "```\nstatic inline bool schedule_delayed_work(struct delayed_work *dwork, \n                            unsigned long delay) \n```", "```\nint schedule_work_on(int cpu, struct work_struct *work); \n```", "```\nint scheduled_delayed_work_on(int cpu, struct delayed_work *dwork, unsigned long delay); \n```", "```\nstruct workqueue_struct *system_wq __read_mostly; \nEXPORT_SYMBOL(system_wq); \n```", "```\nvoid flush_scheduled_work(void); \n```", "```\n#include <linux/module.h> \n#include <linux/init.h> \n#include <linux/sched.h>    /* for sleep */ \n#include <linux/wait.h>     /* for wait queue */ \n#include <linux/time.h> \n#include <linux/delay.h> \n#include <linux/slab.h>         /* for kmalloc() */ \n#include <linux/workqueue.h> \n\n//static DECLARE_WAIT_QUEUE_HEAD(my_wq); \nstatic int sleep = 0; \n\nstruct work_data { \n    struct work_struct my_work; \n    wait_queue_head_t my_wq; \n    int the_data; \n}; \n\nstatic void work_handler(struct work_struct *work) \n{ \n    struct work_data *my_data = container_of(work, \\ \n                                 struct work_data, my_work);  \n    printk(\"Work queue module handler: %s, data is %d\\n\", __FUNCTION__, my_data->the_data); \n    msleep(2000); \n    wake_up_interruptible(&my_data->my_wq); \n    kfree(my_data); \n} \n\nstatic int __init my_init(void) \n{ \n    struct work_data * my_data; \n\n    my_data = kmalloc(sizeof(struct work_data), GFP_KERNEL); \n    my_data->the_data = 34; \n\n    INIT_WORK(&my_data->my_work, work_handler); \n    init_waitqueue_head(&my_data->my_wq); \n\n    schedule_work(&my_data->my_work); \n    printk(\"I'm goint to sleep ...\\n\"); \n    wait_event_interruptible(my_data->my_wq, sleep != 0); \n    printk(\"I am Waked up...\\n\"); \n    return 0; \n} \n\nstatic void __exit my_exit(void) \n{ \n    printk(\"Work queue module exit: %s %d\\n\", __FUNCTION__,  __LINE__); \n} \n\nmodule_init(my_init); \nmodule_exit(my_exit); \nMODULE_LICENSE(\"GPL\"); \nMODULE_AUTHOR(\"John Madieu <john.madieu@gmail.com> \"); \nMODULE_DESCRIPTION(\"Shared workqueue\"); \n```", "```\nstruct workqueue_struct *myqueue; \nstruct work_struct thework; \n```", "```\nvoid dowork(void *data) {  /* Code goes here */ }; \n```", "```\nmyqueue = create_singlethread_workqueue( \"mywork\" ); \nINIT_WORK( &thework, dowork, <data-pointer> ); \n```", "```\nqueue_work(myqueue, &thework); \n```", "```\n    queue_dalayed_work(myqueue, &thework, <delay>); \n```", "```\nvoid flush_workqueue(struct workqueue_struct *wq) \n```", "```\nint cancel_work_sync(struct work_struct *work); \nint cancel_delayed_work_sync(struct delayed_work *dwork); \n```", "```\nif ( !cancel_delayed_work( &thework) ){\n\nflush_workqueue(myqueue);\n\ndestroy_workqueue(myqueue);\n\n}\n```", "```\nINIT_DELAYED_WORK(_work, _func); \nINIT_DELAYED_WORK_DEFERRABLE(_work, _func); \n```", "```\nint queue_delayed_work(struct workqueue_struct *wq, \n            struct delayed_work *dwork, unsigned long delay) \n```", "```\nint queue_work_on(int cpu, struct workqueue_struct *wq, \n                   struct work_struct *work); \n```", "```\nint queue_delayed_work_on(int cpu, struct workqueue_struct *wq, \n    struct delayed_work *dwork, unsigned long delay);\n```", "```\n#include <linux/init.h> \n#include <linux/module.h> \n#include <linux/workqueue.h>    /* for work queue */ \n#include <linux/slab.h>         /* for kmalloc() */ \n\nstruct workqueue_struct *wq; \n\nstruct work_data { \n    struct work_struct my_work; \n    int the_data; \n}; \n\nstatic void work_handler(struct work_struct *work) \n{ \n    struct work_data * my_data = container_of(work, \n                                   struct work_data, my_work); \n    printk(\"Work queue module handler: %s, data is %d\\n\", \n         __FUNCTION__, my_data->the_data); \n    kfree(my_data); \n} \n\nstatic int __init my_init(void) \n{ \n    struct work_data * my_data; \n\n    printk(\"Work queue module init: %s %d\\n\", \n           __FUNCTION__, __LINE__); \n    wq = create_singlethread_workqueue(\"my_single_thread\"); \n    my_data = kmalloc(sizeof(struct work_data), GFP_KERNEL); \n\n    my_data->the_data = 34; \n    INIT_WORK(&my_data->my_work, work_handler); \n    queue_work(wq, &my_data->my_work); \n\n    return 0; \n} \n\nstatic void __exit my_exit(void) \n{ \n    flush_workqueue(wq); \n    destroy_workqueue(wq); \n    printk(\"Work queue module exit: %s %d\\n\", \n                   __FUNCTION__, __LINE__); \n} \n\nmodule_init(my_init); \nmodule_exit(my_exit); \nMODULE_LICENSE(\"GPL\"); \nMODULE_AUTHOR(\"John Madieu <john.madieu@gmail.com>\"); \n```", "```\nstruct workqueue_struct *system_wq __read_mostly; \n```", "```\nint request_irq(unsigned int irq, irq_handler_t handler, \n    unsigned long flags, const char *name, void *dev) \n```", "```\nstruct my_data { \n   struct input_dev *idev; \n   struct i2c_client *client; \n   char name[64]; \n   char phys[32]; \n }; \n\n static irqreturn_t my_irq_handler(int irq, void *dev_id) \n { \n    struct my_data *md = dev_id; \n    unsigned char nextstate = read_state(lp); \n    /* Check whether my device raised the irq or no */ \n    [...] \n    return IRQ_HANDLED; \n } \n\n /* some where in the code, in the probe function */ \n int ret; \n struct my_data *md; \n md = kzalloc(sizeof(*md), GFP_KERNEL); \n\n ret = request_irq(client->irq, my_irq_handler, \n                    IRQF_TRIGGER_LOW | IRQF_ONESHOT, \n                    DRV_NAME, md); \n\n /* far in the release function */ \n free_irq(client->irq, md); \n```", "```\nstatic irqreturn_t my_irq_handler(int irq, void *dev) \n```", "```\nvoid free_irq(unsigned int irq, void *dev) \n```", "```\nssize_t my_read(struct file *filp, char __user *buf, size_t count,  \n   loff_t *f_pos) \n{ \n    unsigned long flags; \n    /* some stuff */ \n    [...] \n    unsigned long flags; \n    spin_lock_irqsave(&my_lock, flags); \n    data++; \n    spin_unlock_irqrestore(&my_lock, flags) \n    [...] \n} \n\nstatic irqreturn_t my_interrupt_handler(int irq, void *p) \n{ \n    /* \n     * preemption is disabled when running interrupt handler \n     * also, the serviced irq line is disabled until the handler has completed \n     * no need then to disable all other irq. We just use spin_lock and \n     * spin_unlock \n     */ \n    spin_lock(&my_lock); \n    /* process data */ \n    [...] \n    spin_unlock(&my_lock); \n    return IRQ_HANDLED; \n} \n```", "```\n grep -rn tasklet_schedule\n\n```", "```\nstruct my_data { \n    int my_int_var; \n    struct tasklet_struct the_tasklet; \n    int dma_request; \n}; \n\nstatic void my_tasklet_work(unsigned long data) \n{ \n    /* Do what ever you want here */ \n} \n\nstruct my_data *md = init_my_data; \n\n/* somewhere in the probe or init function */ \n[...] \n   tasklet_init(&md->the_tasklet, my_tasklet_work, \n                 (unsigned long)md); \n[...] \n\nstatic irqreturn_t my_irq_handler(int irq, void *dev_id) \n{ \n    struct my_data *md = dev_id; \n\n    /* Let's schedule our tasklet */ \n    tasklet_schedule(&md.dma_tasklet); \n\n    return IRQ_HANDLED; \n} \n```", "```\nstatic DECLARE_WAIT_QUEUE_HEAD(my_wq);  /* declare and init the wait queue */ \nstatic struct work_struct my_work; \n\n/* some where in the probe function */ \n/* \n * work queue initialization. \"work_handler\" is the call back that will be \n * executed when our work is scheduled. \n */ \nINIT_WORK(my_work, work_handler); \n\nstatic irqreturn_t my_interrupt_handler(int irq, void *dev_id) \n{ \n    uint32_t val; \n    struct my_data = dev_id; \n\n    val = readl(my_data->reg_base + REG_OFFSET); \n   if (val == 0xFFCD45EE)) { \n       my_data->done = true; \n         wake_up_interruptible(&my_wq); \n   } else { \n         schedule_work(&my_work); \n   } \n\n   return IRQ_HANDLED; \n}; \n```", "```\nint request_threaded_irq(unsigned int irq, irq_handler_t handler,\\ \n                            irq_handler_t thread_fn, \\ \n                            unsigned long irqflags, \\ \n                            const char *devname, void *dev_id) \n\n```", "```\n/* \n * Default primary interrupt handler for threaded interrupts. Is \n * assigned as primary handler when request_threaded_irq is called \n * with handler == NULL. Useful for oneshot interrupts. \n */ \nstatic irqreturn_t irq_default_primary_handler(int irq, void *dev_id) \n{ \n    return IRQ_WAKE_THREAD; \n} \n\nrequest_threaded_irq(unsigned int irq, irq_handler_t handler, \n                         irq_handler_t thread_fn, unsigned long irqflags, \n                         const char *devname, void *dev_id) \n{ \n        [...] \n        if (!handler) { \n                if (!thread_fn) \n                        return -EINVAL; \n                handler = irq_default_primary_handler; \n        } \n        [...] \n} \nEXPORT_SYMBOL(request_threaded_irq); \n\n```", "```\nrequest_irq(unsigned int irq, irq_handler_t handler, \\ \n            unsigned long flags, const char *name, void *dev) \n{ \n    return request_threaded_irq(irq, handler, NULL, flags, \\ \n                                name, dev); \n} \n```", "```\nstatic irqreturn_t pcf8574_kp_irq_handler(int irq, void *dev_id) \n{ \n    struct custom_data *lp = dev_id; \n    unsigned char nextstate = read_state(lp); \n\n    if (lp->laststate != nextstate) { \n        int key_down = nextstate < ARRAY_SIZE(lp->btncode); \n        unsigned short keycode = key_down ?  \n            p->btncode[nextstate] : lp->btncode[lp->laststate]; \n\n        input_report_key(lp->idev, keycode, key_down); \n        input_sync(lp->idev); \n        lp->laststate = nextstate; \n    } \n    return IRQ_HANDLED; \n} \n\nstatic int pcf8574_kp_probe(struct i2c_client *client, \\ \n                          const struct i2c_device_id *id) \n{ \n    struct custom_data *lp = init_custom_data(); \n    [...] \n    /* \n     * @handler is NULL and @thread_fn != NULL \n     * the default primary handler is installed, which will  \n     * return IRQ_WAKE_THREAD, that will schedule the thread  \n     * asociated to the bottom half. the bottom half must then  \n     * return IRQ_HANDLED when finished \n     */ \n    ret = request_threaded_irq(client->irq, NULL, \\ \n                            pcf8574_kp_irq_handler, \\ \n                            IRQF_TRIGGER_LOW | IRQF_ONESHOT, \\ \n                            DRV_NAME, lp); \n    if (ret) { \n        dev_err(&client->dev, \"IRQ %d is not free\\n\", \\ \n                 client->irq); \n        goto fail_free_device; \n    } \n    ret = input_register_device(idev); \n    [...] \n} \n```", "```\n#include <linux/init.h> \n#include <linux/module.h> \n#include <linux/workqueue.h>    /* for work queue */ \n#include <linux/kmod.h> \n\nstatic struct delayed_work initiate_shutdown_work; \nstatic void delayed_shutdown( void ) \n{ \n   char *cmd = \"/sbin/shutdown\"; \n   char *argv[] = { \n         cmd, \n         \"-h\", \n         \"now\", \n         NULL, \n   }; \n   char *envp[] = { \n         \"HOME=/\", \n         \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\", \n         NULL, \n   }; \n\n   call_usermodehelper(cmd, argv, envp, 0); \n} \n\nstatic int __init my_shutdown_init( void ) \n{ \n    schedule_delayed_work(&delayed_shutdown, msecs_to_jiffies(200)); \n    return 0; \n} \n\nstatic void __exit my_shutdown_exit( void ) \n{ \n  return; \n} \n\nmodule_init( my_shutdown_init ); \nmodule_exit( my_shutdown_exit ); \n\nMODULE_LICENSE(\"GPL\"); \nMODULE_AUTHOR(\"John Madieu\", <john.madieu@gmail.com>); \nMODULE_DESCRIPTION(\"Simple module that trigger a delayed shut down\"); \n```"]