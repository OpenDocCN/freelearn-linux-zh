- en: Chapter 10. Real-time
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。实时
- en: In this chapter, you will be presented with information on the real-time component
    of the Yocto Project. Also, in the same context, a short discussion regarding
    the general purpose of an operating system and a real-time operating system will
    be explained. We will then move toward the PREEMPT_RT patches that try to change
    normal Linux into a full powered real-time operating system; we will try to look
    at it from more angles and at the end, sum it up and draw a conclusion out of
    it. This is not all, any real-time operation needs its applications, so a short
    presentation on the do's and don'ts of application writing that is suitable in
    the context of a real-time operating system, will also be presented. Keeping all
    of this in mind, I believe it's time to proceed with this chapter content; I hope
    you enjoy it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解Yocto项目的实时组件的信息。此外，在相同的背景下，将解释操作系统和实时操作系统的通用目的的简要讨论。然后我们将转向PREEMPT_RT补丁，试图将正常的Linux变成一个功能强大的实时操作系统；我们将尝试从更多角度来看待它，并最终总结并得出结论。这还不是全部，任何实时操作都需要其应用程序，因此还将简要介绍适用于实时操作系统背景下的应用程序编写的注意事项。记住所有这些，我相信现在是时候继续本章内容了；希望您喜欢。
- en: You will find a more detailed explanation of real-time components in this chapter.
    Also, the relation between Linux and real-time will be shown to you. As everyone
    knows already, the Linux operation system was designed as a general purpose OS
    very similar to the already available UNIX. It is very easy to see the fact that
    a multiuser system, such as Linux, and a real-time one are somewhat in conflict.
    The main reason for this is that for a general purpose, multiple user operating
    systems, such as Linux, are configured to obtain a maximal average throughput.
    This sacrifices latencies that offer exactly the opposite requirements for a real-time
    operating system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本章找到对实时组件的更详细解释。还将向您展示Linux与实时的关系。众所周知，Linux操作系统被设计为一个类似于已有的UNIX的通用操作系统。很容易看出，多用户系统（如Linux）和实时系统在某种程度上存在冲突。这主要是因为对于通用目的，多用户操作系统（如Linux）被配置为获得最大的平均吞吐量。这牺牲了对实时操作系统来说恰恰相反的延迟要求。
- en: The definition for real time is fairly easy to understand. The main idea behind
    it in computing is that a computer or any embedded device is able to offer feedback
    to its environment in time. This is very different from being fast; it is, in
    fact, fast enough in the context of a system and fast enough is different for
    the automobile industry or nuclear power plants. Also, this kind of a system will
    offer reliable responses to take decisions that don't not affect any exterior
    system. For example, in a nuclear power plant, it should detect and prevent any
    abnormal conditions to ensure that a catastrophe is avoided.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 实时的定义相当容易理解。在计算中，其主要思想是计算机或任何嵌入式设备能够及时向其环境提供反馈。这与快速不同；事实上，在系统的上下文中足够快。对于汽车行业或核电厂来说，足够快是不同的。此外，这种系统将提供可靠的响应以做出不影响任何外部系统的决策。例如，在核电厂中，它应该检测并防止任何异常情况，以确保避免灾难发生。
- en: Understanding GPOS and RTOS
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解GPOS和RTOS
- en: 'When Linux is mentioned, usually **General Purpose Operating System** (**GPOS**)
    is related to it, but over time, the need to have the same benefits as **Real-Time
    Operating System** (**RTOS**) for Linux has become more stringent. The challenge
    for any real-time system is to meet the given timing constrains in spite of the
    number and type of random asynchronous events. This is no simple task and an extensive
    number of papers and researches were done on theory of the real-time systems.
    Another challenge for a real-time system would be to have an upper limit on latency,
    called a scheduling deadline. Depending on how systems meet this challenge, they
    can be split into hard, firm, and soft:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当提到Linux时，通常会将**通用目的操作系统**（**GPOS**）与之联系起来，但随着时间的推移，对Linux具有与**实时操作系统**（**RTOS**）相同的好处的需求变得更为迫切。任何实时系统的挑战在于满足给定的时间约束，尽管存在各种随机的异步事件。这并不是一项简单的任务，对实时系统的理论进行了大量的论文和研究。实时系统的另一个挑战是对延迟设置上限，称为调度截止日期。根据系统如何应对这一挑战，它们可以分为硬实时、稳固实时和软实时：
- en: '**Hard real-time system**: This represents system for which a deadline miss
    will result in a complete system failure.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬实时系统：这代表了一个如果错过截止日期将导致完全系统故障的系统。
- en: '**Firm real-time system**: This represents systems for which a deadline miss
    is acceptable but the system quality can be degraded. Also, after the deadline
    is missed, the result that is offered is not useful anymore.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳固实时系统**：这代表了一个截止日期错过是可以接受的，但系统质量可能会降低的系统。此外，在错过截止日期后，所提供的结果将不再有用。'
- en: '**Soft real-time system**: This represents systems for which missing of deadlines
    degrades the usefulness of the received result and consequently, of the quality
    of the system. In these kind of systems, the meeting of the deadline is seen as
    a goal than as a strict requirement.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软实时系统**：这代表了一个错过截止日期会降低所收到结果的有用性，从而降低系统的质量的系统。在这种系统中，满足截止日期被视为一个目标而不是严格要求。'
- en: 'There are multiple reasons for Linux not being suitable as a RTOS:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个原因导致Linux不适合作为RTOS：
- en: '**Paging**: The page swap process through virtual memory is without limits.
    There is no method in place to know the time that will pass until you can get
    a page from a disk, and this implies that there is no upper limit to the delay
    caused by the fault in a page.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分页**：通过虚拟内存的页面交换过程是没有限制的。目前没有方法可以知道从磁盘获取页面需要多长时间，这意味着页面故障可能导致的延迟没有上限。'
- en: '**Coarsed-grained synchronization**: Here, the definition of the Linux kernel
    is not preemptible. This means that once a process is inside the kernel context,
    it cannot be preempted until it exits the context. At an event occurrence, the
    new event needs to wait for scheduling until the already available one exits the
    kernel context.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粗粒度同步**：在这里，Linux内核的定义是不可抢占的。这意味着一旦一个进程处于内核上下文中，它就不能被抢占，直到退出上下文。在事件发生时，新事件需要等待调度，直到已有的事件退出内核上下文。'
- en: '**Batching**: An operation can be batched for a more efficient use of resources.
    The simplest example of this is the page freeing process. Instead of freeing each
    separate page, Linux is able to pass multiple pages and clean as many as possible.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批处理**：可以对操作进行批处理，以更有效地利用资源。这种方法的最简单示例是页面释放过程。Linux能够传递多个页面并尽可能多地进行清理，而不是释放每个单独的页面。'
- en: '**Request reordering**: The I/O requests can be reordered for processes, making
    the process of using hardware more efficient.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求重排序**：可以对进程的I/O请求进行重新排序，使硬件的使用过程更加高效。'
- en: '**Fairness in scheduling**: This is a UNIX heritage and refers to the fact
    that a scheduler tries to be fair with all running processes. This property offers
    the possibility of lower priority processes that have been waiting for a long
    time to be scheduled before higher priority ones.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度公平性**：这是UNIX的遗产，指的是调度程序试图对所有运行的进程公平。这个特性提供了等待时间较长的较低优先级进程在较高优先级进程之前被调度的可能性。'
- en: 'All the preceding characteristics constitute the reason why an upper boundary
    cannot be applied to the latency of a task or process, and also why Linux cannot
    become a hard real-time operating system. Let''s take a look at the following
    diagram which illustrates the approaches of Linux OS to offer real-time characteristics:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述特征构成了任务或进程的延迟不能应用上限的原因，也是Linux不能成为硬实时操作系统的原因。让我们看一下下面的图表，它说明了Linux操作系统提供实时特性的方法：
- en: '![Understanding GPOS and RTOS](img/image00361.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![理解GPOS和RTOS](img/image00361.jpeg)'
- en: The first thing anyone can do to improve the latency of the standard Linux operating
    system would be to try and make a change to the scheduling policies. The default
    Linux time sharing scheduling policies are called **SCHED_OTHER**, and they use
    a fairness algorithm, giving all processes zero priority, the lowest one available.
    Other such scheduling policies are **SCHED_BATCH** for batch scheduling of the
    processes and the **SCHED_IDLE**, which is suitable for the scheduling of extremely
    low priority jobs. The alternatives to this scheduling policy are **SCHED_FIFO**
    and **SCHED_RR**. Both of them are intended as real-time policies and are time-critical
    applications that require precise control processes and their latencies.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人可以做的第一件事来改善标准Linux操作系统的延迟就是尝试更改调度策略。默认的Linux时间共享调度策略称为**SCHED_OTHER**，它使用公平算法，给予所有进程零优先级，即可用的最低优先级。其他类似的调度策略有**SCHED_BATCH**用于进程的批处理调度和**SCHED_IDLE**，适用于极低优先级作业的调度。这些调度策略的替代方案是**SCHED_FIFO**和**SCHED_RR**。它们都是用作实时策略的，适用于需要精确控制进程和它们的延迟的时间关键应用程序。
- en: To offer more real-time characteristics to a Linux operating system, there are
    also two more approaches that can be presented. The first one refers to a more
    preemptive implementation of the Linux kernel. This approach can take advantage
    of the already available spinlock mechanism used for SMP support, making sure
    that multiple processes are prevented from executing simultaneously, though in
    the context of a single processor, the spinlocks are no ops. The interrupt handling
    also requires modifications this rescheduling to make possible if another higher
    priority process appears; in this situation, a new scheduler might also be required.
    This approach offers the advantage of not changing the interaction of a user space
    and the advantage of using APIs, such as POSIX or others. The drawback of this
    is that the kernel changes are very serious and every time a kernel version changes,
    these changes need to be adapted accordingly. If this work was not enough already,
    the end result is not fully real-time operating system, but one that reduces the
    latency of the operating system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给Linux操作系统提供更多的实时特性，还有另外两种方法可以提出。第一种是对Linux内核更具抢占性的实现。这种方法可以利用已有的用于SMP支持的自旋锁机制，确保多个进程不会同时执行，尽管在单处理器的情况下，自旋锁是无操作的。中断处理也需要修改以进行重新调度，以便在出现另一个更高优先级的进程时进行可能的重新调度；在这种情况下，可能还需要一个新的调度程序。这种方法的优点是不改变用户空间的交互，并且可以使用诸如POSIX或其他API。缺点是内核的更改非常严重，每次内核版本更改时，这些更改都需要相应地进行调整。如果这项工作还不够，最终结果并不是完全的实时操作系统，而是减少了操作系统的延迟。
- en: 'The other available implementation is interrupt abstraction. This approach
    is based on the fact that not all systems require a hard real-time determinism
    and most of them only require a section of their task to be executed in a real-time
    context. The idea behind this approach is to run Linux with the priority of an
    idle task under a real-time kernel and non-real-time tasks to continue to execute
    them as they normally do. This implementation fakes the disabling of an interrupt
    for the real-time kernel, but in fact, it is passed to the real-time kernel. For
    this type of implementation, there are three available solutions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可用的实现是中断抽象。这种方法基于这样一个事实，即并非所有系统都需要硬实时确定性，大多数系统只需要执行其任务的一部分在实时环境中执行。这种方法的理念是在实时内核下以空闲任务的优先级运行Linux，并继续执行非实时任务，就像它们通常做的那样。这种实现伪装了实时内核的中断禁用，但实际上是传递给了实时内核。对于这种类型的实现，有三种可用的解决方案：
- en: '**RTLinux**: It represents the original implementation of the interrupt abstraction
    approach and was developed at the Institute of Mining and Technology, New Mexico.
    Although it still has an open source implementation, most of the development is
    now done through FSMLabs engineers, later required by the Wind River System on
    the commercial version of it. The commercial support for RTLinux ended in August
    2011.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RTLinux**：它代表中断抽象方法的原始实现，是在新墨西哥矿业技术研究所开发的。尽管它仍有开源实现，但大部分开发现在是由FSMLabs工程师完成的，后来被Wind
    River System收购用于其商业版本。对RTLinux的商业支持于2011年8月结束。'
- en: '**RTAI**: It is an enhancement made to the RTLinux solution developed in the
    department of Aerospace Engineering from the Politecnico di Milano. This project
    is a very active with a high number of developers and has current releases available.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RTAI**：这是对在米兰理工大学航空航天工程系开发的RTLinux解决方案的增强。该项目非常活跃，有大量开发人员，并且有当前版本可用。'
- en: '**Xenomai**: It represents the third implementation. It''s history is a bit
    twisted: it appeared in August 2001, only to be merged with RTAI in 2013 to generate
    a real-time operating system that was fit for production. However, the fusion
    was dispersed in 2005 and it became an independent project again.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Xenomai**：它代表第三种实现。它的历史有些扭曲：它于2001年8月出现，只是在2013年与RTAI合并，以生成适合生产的实时操作系统。然而，这种融合在2005年解散，又重新成为一个独立项目。'
- en: The following diagram presents a basic RTLinux architecture.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了基本的RTLinux架构。
- en: '![Understanding GPOS and RTOS](img/image00362.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![理解GPOS和RTOS](img/image00362.jpeg)'
- en: A similar architecture, as shown in the preceding diagram, applies to the two
    other solutions since both of them were born from the RTLinux implementation.
    The difference between them is at the implementation level and each offers various
    benefits.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面图表中显示的类似架构适用于另外两种解决方案，因为它们都是从RTLinux实现中诞生的。它们之间的区别在于实现级别，每种都提供各种好处。
- en: PREEMPT_RT
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PREEMPT_RT
- en: The PREEMPT_RT patches are the first option for every developer when a real-time
    solution is required. For some developers, the PREEMPT_RT patches transform Linux
    into a real-time solution suitable for their needs. This solution could not replace
    a real-time operation system, but is, in fact, suitable for a large number of
    systems.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要实时解决方案时，PREEMPT_RT补丁是每个开发人员的首选。对于一些开发人员，PREEMPT_RT补丁将Linux转变为适合其需求的实时解决方案。这个解决方案不能取代实时操作系统，但实际上适用于大量系统。
- en: The biggest advantage that PREEMPT_RT has over other real-time solutions for
    Linux is that it actually transforms Linux into a real-time operating system.
    All the other alternatives usually create a microkernel that is executed as a
    hypervisor and Linux is only executed as a task of it, so the communication of
    real-time tasks with the non-real-time ones is done through this microkernel.
    For the PREEMPT_RT patch, this problem is no more.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: PREEMPT_RT相对于Linux的其他实时解决方案的最大优势在于，它实际上将Linux转变为实时操作系统。所有其他替代方案通常创建一个微内核，作为超级监视器执行，而Linux只作为其任务执行，因此实时任务与非实时任务之间的通信是通过这个微内核完成的。对于PREEMPT_RT补丁，这个问题不复存在。
- en: The standard version of the Linux kernel is only able to offer soft real-time
    requirements, such as basic POSIX user space operations where no deadline is guaranteed.
    Adding patches, such as Ingo Molnar's PREEMPT_RT patch, and also Thomas Gheixner's
    patch with regards to a generic clock event layer that offers a high resolution
    support, you can say that you have a Linux kernel that offers high real-time capabilities.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 标准版的Linux内核只能提供基本的软实时要求，如基本的POSIX用户空间操作，其中没有保证的截止期。通过添加补丁，如Ingo Molnar的PREEMPT_RT补丁，以及Thomas
    Gheixner关于提供高分辨率支持的通用时钟事件层的补丁，可以说你有一个提供高实时能力的Linux内核。
- en: 'With the presence of the real-time preemption patch in the industry, a number
    of interesting opportunities have appeared, making it an option for firm and hard
    real-time applications in areas, such as industrial control or professional audio.
    This is mainly because of the design of the PREEMPT_RT patch and its aim toward
    integration inside the mainline kernel. We will learn about its usage further
    in the chapter. The following diagram shows the working of the Preemptible Linux
    Kernel:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 随着实时抢占补丁在行业中的出现，出现了许多有趣的机会，使其成为工业控制或专业音频等领域的坚实和硬实时应用的选择。这主要是因为PREEMPT_RT补丁的设计及其旨在集成到主线内核中。我们将在本章中进一步了解其用法。以下图表显示了可抢占Linux内核的工作原理：
- en: '![PREEMPT_RT](img/image00363.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![PREEMPT_RT](img/image00363.jpeg)'
- en: 'The PREEMPT_RT patch transforms Linux from a general purpose operating system
    into a preemptible one using the following tricks:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: PREEMPT_RT补丁通过以下技巧将Linux从通用操作系统转变为可抢占的操作系统：
- en: Protecting critical sections with the preemptible `rwlock_t preemptible` and
    `spinlock_t`. The use of the old solutions is still available using `raw_spinlock_t`,
    which shares the same API as `spinlock_t`.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可抢占的`rwlock_t preemptible`和`spinlock_t`来保护关键部分。仍然可以使用旧的解决方案，使用`raw_spinlock_t`，它与`spinlock_t`具有相同的API。
- en: The kernel locking mechanisms is preempted by using `rtmutexes`.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`rtmutexes`抢占内核锁定机制。
- en: A priority inversion and priority inheritance mechanism is implemented for `mutexes`,
    `spinlocks` and `rw_semaphores`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`mutexes`、`spinlocks`和`rw_semaphores`实现了优先级倒置和优先级继承机制。
- en: Converting the available Linux timer API into one with a high resolution timer
    that offers the possibility of having timeouts.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有的Linux定时器API转换为具有高分辨率定时器的API，从而提供超时的可能性。
- en: Implementing the usage of kernel threads for interrupt handlers. The real-time
    preemption patch treats soft interrupt handlers into the kernel thread context
    using a `task_struct` like structure for every user space process. There is also
    the possibility of registering an IRQ into the kernel context.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现使用内核线程作为中断处理程序。实时抢占补丁将软中断处理程序处理为内核线程上下文，使用`task_struct`结构来处理每个用户空间进程。还可以将IRQ注册到内核上下文中。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on priority inversion, [http://www.embedded.com/electronics-blogs/beginner-s-corner/4023947/Introduction-to-Priority-Inversion](http://www.embedded.com/electronics-blogs/beginner-s-corner/4023947/Introduction-to-Priority-Inversion)
    is a good starting point.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有关优先级反转的更多信息，请参阅[http://www.embedded.com/electronics-blogs/beginner-s-corner/4023947/Introduction-to-Priority-Inversion](http://www.embedded.com/electronics-blogs/beginner-s-corner/4023947/Introduction-to-Priority-Inversion)。
- en: Applying the PREEMPT_RT patch
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用PREEMPT_RT补丁
- en: 'Before moving to the actual configuration part, you should download a suitable
    version for the kernel. The best inspiration source is [https://www.kernel.org/](https://www.kernel.org/),
    which should be the starting point because it does not contain any extra patches.
    After the source code is received, the corresponding `rt` patches version can
    be downloaded from [https://www.kernel.org/pub/linux/kernel/projects/rt/](https://www.kernel.org/pub/linux/kernel/projects/rt/).
    The kernel version chosen for this demonstration is the 3.12 kernel version, but
    if any other kernel version is required, the same steps can be taken with a similar
    end result. The development of the real-time preemption patches is very active,
    so any missing version support is covered very fast. Also, for other sublevel
    versions, the patches can be found in the `incr` or older subdirectories of that
    particular kernel version. The following is the example for sublevel versions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动到实际配置部分之前，您应该下载适合内核的版本。最好的灵感来源是[https://www.kernel.org/](https://www.kernel.org/)，这应该是起点，因为它不包含任何额外的补丁。收到源代码后，可以从[https://www.kernel.org/pub/linux/kernel/projects/rt/](https://www.kernel.org/pub/linux/kernel/projects/rt/)下载相应的`rt`补丁版本。本演示选择的内核版本是3.12内核版本，但如果需要其他内核版本，则可以采取类似的步骤，获得类似的结果。实时抢占补丁的开发非常活跃，因此任何缺失的版本支持都会很快得到解决。此外，对于其他子级版本，可以在特定内核版本的`incr`或旧的子目录中找到补丁。以下是子级版本的示例：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After the source code is received, the sources need to be unpacked and the
    patches applied:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 收到源代码后，需要解压源代码并应用补丁：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The next step involves the configuration of the kernel sources. The configuration
    differs from one architecture to another, but the general idea remains. The following
    configurations are required for a QEMU ARM machine supported inside Poky. To enable
    the PREEMPT_RT support for a machine, there are multiple options available. You
    can implement a low-latency support version, which is most suitable for a desktop
    computer using a kernel configuration fragment similar to this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步涉及内核源代码的配置。配置因架构而异，但总体思路保持不变。在Poky内支持QEMU ARM机器需要以下配置。要为机器启用PREEMPT_RT支持，有多种选项可用。您可以实现低延迟支持版本，这对于使用类似于这样的内核配置片段的台式计算机最合适：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This option is one of the most often used and it also constitutes the primary
    source of usage of the PREEMPT_RT patches. The alternative of this would be to
    enable the fully preemptive support for the PREEMPT_RT patches using a configuration
    similar to this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项是最常用的选项之一，也构成了PREEMPT_RT补丁的主要使用来源。另一种选择是使用类似于这样的配置启用PREEMPT_RT补丁的全抢占支持：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you're interested in configuring the kernel manually, it can use the `menuconfig`
    option. The following `CONFIG_PREEMPT*` configurations are available for easier
    access to the required options. The first image mainly contains the `CONFIG_PREEMPT`
    and `CONFIG_PREEMPT_COUNT` variables, which should be the first ones to enable.
    There is also a configuration option called `CONFIG_PREEMPT_NONE` that is used
    for no forced preemptive actions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣手动配置内核，可以使用`menuconfig`选项。以下`CONFIG_PREEMPT*`配置可更轻松地访问所需的选项。第一个图像主要包含`CONFIG_PREEMPT`和`CONFIG_PREEMPT_COUNT`变量，这应该是启用的第一个变量。还有一个名为`CONFIG_PREEMPT_NONE`的配置选项，用于不强制进行抢占操作。
- en: '![Applying the PREEMPT_RT patch](img/image00364.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![应用PREEMPT_RT补丁](img/image00364.jpeg)'
- en: In the following image, the `CONFIG_PREEMPT_RCU` and `CONFIG_PREEMPT_RT_FULL`
    configurations are available. More information related to `RCU` is available at
    [https://lwn.net/Articles/262464/](https://lwn.net/Articles/262464/).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个图像中，`CONFIG_PREEMPT_RCU`和`CONFIG_PREEMPT_RT_FULL`配置可用。有关`RCU`的更多信息，请参阅[https://lwn.net/Articles/262464/](https://lwn.net/Articles/262464/)。
- en: '![Applying the PREEMPT_RT patch](img/image00365.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![应用PREEMPT_RT补丁](img/image00365.jpeg)'
- en: The third image contains the `CONFIG_PREEMPT__LL` configuration. Another interesting
    configuration is `CONFIG_PREEMPT_VOLUNTARY`, which also reduces the latency along
    with the `CONFIG_PREEMPT__LL` configuration, for a desktop computer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个图像包含`CONFIG_PREEMPT__LL`配置。另一个有趣的配置是`CONFIG_PREEMPT_VOLUNTARY`，它与`CONFIG_PREEMPT__LL`配置一起减少延迟，适用于台式计算机。
- en: One interesting argument against the *low-latency desktop* option is available
    at [https://sevencapitalsins.wordpress.com/2007/08/10/low-latency-kernel-wtf/](https://sevencapitalsins.wordpress.com/2007/08/10/low-latency-kernel-wtf/).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有关*低延迟台式机*选项的有趣论点可在[https://sevencapitalsins.wordpress.com/2007/08/10/low-latency-kernel-wtf/](https://sevencapitalsins.wordpress.com/2007/08/10/low-latency-kernel-wtf/)找到。
- en: '![Applying the PREEMPT_RT patch](img/image00366.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![应用PREEMPT_RT补丁](img/image00366.jpeg)'
- en: The last one contains the `CONFIG_TREE_PREEMPT_RCU` configuration used to change
    the `RCU` implementation. The same process can be used to search and enable the
    other configurations that do not contain the search word in their name.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个包含`CONFIG_TREE_PREEMPT_RCU`配置，用于更改`RCU`实现。可以使用相同的过程搜索和启用其他不包含搜索词的配置。
- en: '![Applying the PREEMPT_RT patch](img/image00367.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![应用PREEMPT_RT补丁](img/image00367.jpeg)'
- en: For more information regarding the PREEMPT_RT patch, refer to [http://varun-anand.com/preempt.html](http://varun-anand.com/preempt.html)
    and [http://www.versalogic.com/mediacenter/whitepapers/wp_linux_rt.asp](http://www.versalogic.com/mediacenter/whitepapers/wp_linux_rt.asp).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有关PREEMPT_RT补丁的更多信息，请参阅[http://varun-anand.com/preempt.html](http://varun-anand.com/preempt.html)和[http://www.versalogic.com/mediacenter/whitepapers/wp_linux_rt.asp](http://www.versalogic.com/mediacenter/whitepapers/wp_linux_rt.asp)。
- en: 'After the kernel image is obtained with the newly applied and configured real-time
    preemptible kernel patch, it needs to be booted to make sure the activity is done
    appropriately so that the end result can be usable. Using the `uname –a` command,
    the `patch rt*` revision number is visible and should be applied to the kernel
    version. Of course, there are other methods that can used to identify this information.
    An alternative for the `uname –a` command is the `dmesg` command on its output
    the string real-time preemption support should be visible, but only one method
    should be enough. The following image offers a representation of how the `uname
    –a` command output should look:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 获得了新应用和配置的实时可抢占内核补丁的内核映像后，需要引导它以确保活动被适当地完成，以便最终结果可以被使用。使用`uname –a`命令，`patch
    rt*`修订号是可见的，并且应该应用于内核版本。当然，还有其他方法可以用来识别这些信息。`uname –a`命令的替代方法是`dmesg`命令，其输出字符串应该可见实时抢占支持，但只需要一种方法就足够了。以下图像提供了`uname
    –a`命令输出应该是什么样子的表示：
- en: '![Applying the PREEMPT_RT patch](img/image00368.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![应用PREEMPT_RT补丁](img/image00368.jpeg)'
- en: 'Taking a look at the list of processes, it can be seen, as mentioned earlier,
    that the IRQ handler is treated using kernel threads. This information is visible
    in the next `ps` command output due to the fact that it is put between square
    brackets. Single IRQ handlers are represented by the `task_struct` structures
    that are similar to the user space ones, making them easily controllable from
    the user space:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 查看进程列表时，可以看到，如前所述，IRQ处理程序是使用内核线程处理的。由于它被放置在方括号之间，这些信息在下一个`ps`命令输出中是可见的。单个IRQ处理程序由类似于用户空间的`task_struct`结构表示，使它们可以很容易地从用户空间进行控制：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next bit of information that needs to be gathered involves the formatting
    of the interrupt process entries, which are a bit different than the ones used
    for a vanilla kernel. This output is visible by inspecting the `/proc/interrupts`
    file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 需要收集的下一个信息涉及中断过程条目的格式，这些条目与普通内核使用的条目有些不同。可以通过检查`/proc/interrupts`文件来查看此输出：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, information available in the fourth column provides the IRQ line notifications,
    such as: `[........N/ 0]`. Here, each dot represents an attribute and each attribute
    is a value, as described in the following points. Here is the order of their presence:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，第四列中提供的信息提供了IRQ线通知，例如：`[........N/ 0]`。在这里，每个点代表一个属性，每个属性都是一个值，如下所述。它们的出现顺序如下：
- en: '`I (IRQ_INPROGRESS)`: This refers to the IRQ handler that is active'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`I (IRQ_INPROGRESS)`: 这指的是活动的IRQ处理程序'
- en: '`D (IRQ_DISABLED)`: This represents the IRQ as being disabled'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`D (IRQ_DISABLED)`: 这表示IRQ被禁用了'
- en: '`P (IRQ_PENDING)`: The IRQ here is presented as being in a pending state'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`P (IRQ_PENDING)`: 这里的IRQ被表示为处于挂起状态'
- en: '`R (IRQ_REPLAY)`: In this state, the IRQ has been replied to, but no ACK is
    received yet'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R (IRQ_REPLAY)`: 在此状态下，IRQ已被回复，但尚未收到ACK'
- en: '`A (IRQ_AUTODETECT)`: This represents the IRQ as being in an autodetect state'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A (IRQ_AUTODETECT)`: 这表示IRQ处于自动检测状态'
- en: '`W (IRQ_WAITING)`: This refers to the IRQ being in an autodetect state, but
    not seen yet'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`W (IRQ_WAITING)`: 这指的是IRQ处于自动检测状态，但尚未被看到'
- en: '`L (IRQ_LEVEL)`: The IRQ is in a level-triggered state'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`L (IRQ_LEVEL)`: IRQ处于电平触发状态'
- en: '`M (IRQ_MASKED)`: This represents the state in which the IRQ is not visible
    as being masked anymore'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`M (IRQ_MASKED)`: 这表示IRQ不再被视为被屏蔽的状态'
- en: '`N (IRQ_NODELAY)`: This is the state in which the IRQ must be executed immediately'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`N (IRQ_NODELAY)`: 这是IRQ必须立即执行的状态'
- en: In the preceding example, you can see that multiple IRQs are marked as visible
    and hard IRQs that are run in the kernel context. When an IRQ status is marked
    as `IRQ_NODELAY`, it shows the user that the handler of the IRQ is a kernel thread
    and it will be executed as one. The description of an IRQ can be changed manually,
    but this is not an activity that will be described here.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，可以看到多个IRQ被标记为可见和在内核上下文中运行的硬IRQ。当IRQ状态标记为`IRQ_NODELAY`时，它向用户显示IRQ的处理程序是一个内核线程，并且将作为一个内核线程执行。IRQ的描述可以手动更改，但这不是本文将描述的活动。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on how to change the real-time attributes for a process,
    a good starting point is the `chrt` tool, available at [http://linux.die.net/man/1/chrt](http://linux.die.net/man/1/chrt).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何更改进程的实时属性的更多信息，一个很好的起点是`chrt`工具，可在[http://linux.die.net/man/1/chrt](http://linux.die.net/man/1/chrt)上找到。
- en: The Yocto Project -rt kernel
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Yocto项目-rt内核
- en: Inside Yocto, kernel recipes with PREEMPT_RT patches are applied. For the moment,
    there are only two recipes that incorporate the PREEMPT_RT patch; both are available
    inside the meta layer. The recipes that refer to kernel versions 3.10 and 3.14
    and their naming are `linux-yocto-rt_3.10.bb` and `linux-yocto-rt_3.14.bb`. The
    `–rt` ending in the naming indicates that these recipes fetch the PREEMPT_RT branches
    of the Linux kernel versions maintained by the Yocto community.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Yocto中，应用了带有PREEMPT_RT补丁的内核配方。目前，只有两个配方包含了PREEMPT_RT补丁；两者都在meta层中可用。涉及内核版本3.10和3.14的配方及其命名为`linux-yocto-rt_3.10.bb`和`linux-yocto-rt_3.14.bb`。命名中的`–rt`表示这些配方获取了Yocto社区维护的Linux内核版本的PREEMPT_RT分支。
- en: 'The format for the 3.14 kernel recipe is presented here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里呈现了3.14内核配方的格式：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As shown, one of the recipes seemed to have a duplicated line and a patch is
    necessary to remove it:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，似乎有一个重复的行，需要打补丁来删除它：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding recipe is very similar to the base one. Here, I am referring to
    `linux-yocto_3.14.bb`; they are the recipes on which the PREEMPT_RT patches have
    been applied. The difference between them is that each one is taken from its specific
    branch, and until now, none of the Linux kernel versions with the PREEMPT_RT patches
    have provided support for the `qemumips64` compatible machine.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配方与基本配方非常相似。这里，我指的是`linux-yocto_3.14.bb`；它们是应用了PREEMPT_RT补丁的配方。它们之间的区别在于每个配方都来自其特定的分支，到目前为止，没有一个带有PREEMPT_RT补丁的Linux内核版本为`qemumips64`兼容的机器提供支持。
- en: Disadvantages of the PREEMPT_RT patches
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PREEMPT_RT补丁的缺点
- en: Linux, a general purpose operating system that is optimized for throughput,
    is the exact opposite of what a real-time operating system is all about. Of course
    it offers a high throughput by using a large, multilayered cache, which is a nightmare
    for a hard real-time operating process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Linux是一个针对吞吐量进行优化的通用操作系统，这与实时操作系统的要求完全相反。当然，它通过使用大型、多层缓存提供了高吞吐量，这对于硬实时操作过程来说是一场噩梦。
- en: 'In order to have a real-time Linux, there are two available options:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现实时Linux，有两种可用的选项：
- en: The first one involves the use of the PREEMPT_RT patches, which offer preemption
    by minimizing the latency and executing all activities in a thread context.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法涉及使用PREEMPT_RT补丁，通过最小化延迟并在线程上下文中执行所有活动来提供抢占。
- en: The second solution involves the use of real-time extensions that act as layers
    between Linux and the hardware used for the management of real-time tasks. This
    second solution includes the previously mentioned RTLinux, RTAI, and XENOMAI solutions,
    as well as other commercial solutions and variations that involve moving the layer
    and also separating it in multiple components.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种解决方案涉及使用实时扩展，这些扩展充当Linux和用于管理实时任务的硬件之间的层。这第二种解决方案包括前面提到的RTLinux、RTAI和XENOMAI解决方案，以及其他商业解决方案和涉及移动层并将其分离为多个组件的变体。
- en: The variations of the second option imply various solution from the isolation
    of the cores for real-time activities to the assignation of one for such tasks.
    There are also a lot of solutions that involve the usage of a hypervisor or a
    hook below the Linux kernel to serve a number of interrupts to the RTOS. The existence
    of these alternatives have been made available to the reader not only with other
    options, but also due to the fact that the PREEMPT_RT patch has its disadvantages.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项的变体意味着各种解决方案，从为实时活动隔离核心到为此类任务分配核心。还有许多解决方案涉及使用虚拟化程序或在Linux内核下方提供一定数量的中断服务给RTOS。这些替代方案的存在不仅为读者提供了其他选项，也是因为PREEMPT_RT补丁有其缺点。
- en: One notable disadvantage is that the reduction of latency was done by forcing
    the kernel to preempt a task when a higher priority one appeared. This, of course,
    reduces the throughput for the system because it not only adds a number of context
    switches in the process but also makes the lower priority tasks wait longer than
    they would do the normal Linux kernel.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显著的缺点是通过强制内核在出现更高优先级任务时抢占任务来减少延迟。当然，这会降低系统的吞吐量，因为它不仅在进程中增加了一些上下文切换，而且使较低优先级的任务等待时间比正常的Linux内核更长。
- en: Another disadvantage of the `preempt-rt` patches is that they need to be ported
    from one kernel version to another and adapted from one architecture or software
    vendor to another. This only implies that knowledge of the Linux kernel should
    be available in-house for a particular vendor and it should adapt the solution
    for each of its available kernels. This fact alone has made it less likeable for
    BSP or Linux operating system providers.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: “preempt-rt”补丁的另一个缺点是需要将其从一个内核版本移植到另一个内核版本，并从一个架构或软件供应商调整到另一个。这仅意味着特定供应商应该内部具备Linux内核的知识，并且应该为其每个可用的内核调整解决方案。这一事实使得它对BSP或Linux操作系统提供商来说不太受欢迎。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: One interesting presentation regarding the Linux pre-emption is available in
    the following link. It can be consulted for more information regarding a Linux
    real-time solution, and is available at [http://www.slideshare.net/jserv/realtime-linux](http://www.slideshare.net/jserv/realtime-linux).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Linux抢占的一个有趣演示可在以下链接中找到。可咨询此链接以获取有关Linux实时解决方案的更多信息，网址为[http://www.slideshare.net/jserv/realtime-linux](http://www.slideshare.net/jserv/realtime-linux)。
- en: Linux real-time applications
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux实时应用程序
- en: Having a real-time operating system may not always be enough for everyone. Some
    people would also require real-time optimized applications running over the operating
    system. To make sure an rt-application can be designed and interacted with, the
    required determinism is necessary on the operating system and hardware. With regard
    to the hardware configuration, the requirements involve a low-latency interrupt
    handling. The mechanisms causing the ISR latencies should register values around
    tens of microseconds.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有实时操作系统并不总是对每个人都足够。有些人还需要在操作系统上运行经过实时优化的应用程序。为了确保可以设计和与实时应用程序交互，操作系统和硬件上都需要确定性。就硬件配置而言，要求涉及低延迟中断处理。导致ISR延迟的机制应该在几十微秒左右。
- en: 'Regarding the kernel configuration required by real-time applications, the
    following configurations are necessary:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 关于实时应用程序所需的内核配置，需要以下配置：
- en: '**On-demand CPU scaling**: Using this configuration helps with the creation
    of long-latency events when the CPU is in a low-power consumption mode.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按需CPU缩放**：使用此配置有助于在CPU处于低功耗模式时创建长延迟事件。'
- en: '**NOHZ**: This configurations disables the timer interrupt received by CPUs.
    With this option enabled, the latency spent on a CPU wake up is diminished.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NOHZ**：此配置禁用CPU接收的定时器中断。启用此选项后，CPU唤醒所花费的延迟将减少。'
- en: To write an application, there are some things that need to be taken care of,
    such as making sure that the use of swap is disabled to diminish latencies caused
    by page faults. The use of global variables or arrays should be kept to a minimum.
    The 99 priority number is not configured to run an application, and other spin
    locks are not implemented instead, it uses priority inheritance futexes. Also
    avoid input/output operations and data sharing between applications.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写应用程序，需要注意一些事项，例如确保禁用交换以减少页面错误引起的延迟。全局变量或数组的使用应尽量减少。99优先级号未配置为运行应用程序，而是使用优先级继承futexes而不是其他自旋锁。还要避免输入/输出操作和应用程序之间的数据共享。
- en: For a device driver, the advice is a bit different. Previously, we mentioned
    that the interrupt handling for a real-time kernel is done in a thread context,
    but the hardware interrupt context can still play a role here. To recognize the
    hardware interrupt context from the interrupt handler, the `IRQF_NODELAY` flag
    can be used. If you use the `IRQF_NODELAY` context, make sure you avoid functions
    such as `wake_up()`, `up()`, or `complete()`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于设备驱动程序，建议有所不同。之前我们提到实时内核的中断处理是在线程上下文中进行的，但硬件中断上下文仍然可以在这里发挥作用。为了从中断处理程序中识别硬件中断上下文，可以使用`IRQF_NODELAY`标志。如果使用`IRQF_NODELAY`上下文，请确保避免使用`wake_up()`、`up()`或`complete()`等函数。
- en: Benchmarking
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试
- en: The Linux operating system was for a very long time seen as a GPOS, but in the
    last couple of years, some projects tried to change this by modifying the Linux
    kernel into a RTOS. One such project is the PREEMPT_RT patch, which was mentioned
    previously.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Linux操作系统长期以来被视为GPOS，但在过去几年中，一些项目试图通过修改Linux内核成为RTOS来改变这一点。其中一个项目是之前提到的PREEMPT_RT补丁。
- en: In this section of the chapter, I will discuss a series of tests that could
    be executed for both versions of the Linux OS with or without applying the PREEMPT_RT
    patches. I should mention that for those of you who are interested in some actual
    results, there are a number of papers available that try to investigate the latency
    effect of the PREEMPT_RT or its advantages or disadvantages. One such example
    is available at [http://www.versalogic.com/downloads/whitepapers/real-time_linux_benchmark.pdf](http://www.versalogic.com/downloads/whitepapers/real-time_linux_benchmark.pdf).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，我将讨论一系列测试，这些测试可以针对Linux OS的两个版本执行，无论是否应用了PREEMPT_RT补丁。我应该提到，对于那些对一些实际结果感兴趣的人，有许多可用的论文试图调查PREEMPT_RT的延迟效应或其优缺点。其中一个例子可在[http://www.versalogic.com/downloads/whitepapers/real-time_linux_benchmark.pdf](http://www.versalogic.com/downloads/whitepapers/real-time_linux_benchmark.pdf)找到。
- en: 'Before continuing further, I believe it is my duty to define a number of technical
    terms that are necessary to properly understand some information:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我认为有必要定义一些技术术语，以便正确理解一些信息：
- en: '**Interrupt latency**: This indicates the time that has elapsed since an interrupt
    was generated and until the execution has been started in the interrupt handler.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中断延迟**：指中断生成后到中断处理程序中的执行开始之间经过的时间。'
- en: '**Scheduling latency**: This represents the time between the wake up signal
    of an event and a scheduler that has the opportunity to schedule a thread for
    it. It is also called a **dispatch latency**.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度延迟**：表示事件唤醒信号和调度程序有机会为其安排线程之间的时间。也称为**分派延迟**。'
- en: '**Worst-case latency**: This indicates the time that has passed since a demand
    was issued and until the response to that demand was received.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最坏情况延迟**：指发出需求后到接收到该需求的响应之间经过的时间。'
- en: '**Context-switch**: This represents the switching of the CPU from one process
    or thread to another. It only occurs in the kernel mode.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文切换**：表示CPU从一个进程或线程切换到另一个进程或线程。它只发生在内核模式中。'
- en: 'The **LPPTest** is included in the PREEMPT_RT patch and it contains a Linux
    driver that only changes a bit value on a parallel port to identify the response
    time. Another driver responds to the change in a bit value and a user space application
    that measures the results. The files to look for are `drivers/char/lpptest.c`
    and `scripts/testlpp.c`. To perform this test, two machines are required: one
    to send the signal and the other one to receive and send the response. This requirement
    is stringent since the use of a loopback cable can mess with the measurements.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**LPPTest**包含在PREEMPT_RT补丁中，它包含一个Linux驱动程序，只需更改并行端口上的位值以识别响应时间。另一个驱动程序响应位值的变化，用户空间应用程序测量结果。要执行此测试，需要两台机器：一台用于发送信号，另一台用于接收和发送响应。这一要求很严格，因为使用回环电缆可能会影响测量结果。'
- en: '**RealFeel** is a test for interrupt processing. The program uses `/dev/rtc`
    to fire a periodic interrupt, measures the duration between one interrupt to another,
    and compares it with the expected value. At the end, it prints the variation from
    the expected value indefinitely so that the variations can be exported in a log
    file to process later.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**RealFeel**是一个用于中断处理的测试。该程序使用`/dev/rtc`来触发周期性中断，测量一个中断到另一个中断之间的持续时间，并将其与预期值进行比较。最后，它无限期地打印与预期值的偏差，以便将这些变化导出到日志文件中以供以后处理。'
- en: '**Linux Real-Time Benchmarking Framework** (**LRTB**) represents a set of scripts
    and drivers that are used to evaluate various performance counters for the Linux
    kernel with a real-time addition. It measures the load imposed by real-time patches
    and their ability to obtain a more deterministic response to interrupts.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Linux实时基准测试框架（LRTB）代表了一组脚本和驱动程序，用于评估Linux内核的各种性能计数器，并添加了实时功能。它测量了实时补丁所施加的负载，以及它们获取更确定性中断响应的能力。
- en: For the benchmarking phase, programs such as `hackbench`, `lmbench`, or even
    the `Ingo Molnar dohell` script can be used. There are, of course, a number of
    other tools that can be used for both testing (`cyclictest`, `hourglass`, and
    so on) or benchmarking (`unixbench`, `cache-calibrator`, or any other stress test
    that takes real-time performances to their limit), but I will let the user test
    them and apply the ones that suit their needs best.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在基准测试阶段，可以使用`hackbench`、`lmbench`或甚至`Ingo Molnar dohell`脚本等程序。当然，还有许多其他工具可用于测试（`cyclictest`、`hourglass`等）或基准测试（`unixbench`、`cache-calibrator`或任何将实时性能推至极限的其他压力测试），但我会让用户测试并应用最适合他们需求的工具。
- en: The PREEMPT_RT patch improves the preemptiveness of the Linux kernel, but this
    does not mean it is the best solution to use. The usefulness of PREEMPT_RT patch
    can differ if various aspects of the application domain changes. With regard to
    the PREEMPT_RT patch, it is ready to be used in a hard real-time system. One conclusion
    cannot be made, but I must admit that it can be considered hard real-time material
    if it is used in life sustaining or mission-critical systems. This is a decision
    for everybody to make, and for this testing is required. One opinion that supports
    this is from Steven Rostedt, a Linux kernel developer who is the maintainer of
    the stable version of the real-time Linux kernel patch for Red Hat. It is available
    at [http://www.linux.com/news/featured-blogs/200-libby-clark/710319-intro-to-real-time-linux-for-embedded-developers](http://www.linux.com/news/featured-blogs/200-libby-clark/710319-intro-to-real-time-linux-for-embedded-developers).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: PREEMPT_RT补丁提高了Linux内核的抢占性，但这并不意味着它是最好的解决方案。如果应用领域的各个方面发生变化，PREEMPT_RT补丁的有用性可能会有所不同。关于PREEMPT_RT补丁，它已经准备好在硬实时系统中使用。不能得出一个结论，但我必须承认，如果它用于维持生命或任务关键系统，它可以被认为是硬实时材料。这是每个人都要做出的决定，因此需要进行测试。支持这一观点的一个意见来自Steven
    Rostedt，他是Linux内核开发人员，也是红帽公司实时Linux内核补丁稳定版本的维护者。该信息可以在[http://www.linux.com/news/featured-blogs/200-libby-clark/710319-intro-to-real-time-linux-for-embedded-developers](http://www.linux.com/news/featured-blogs/200-libby-clark/710319-intro-to-real-time-linux-for-embedded-developers)上找到。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some interesting information on this matter can be accessed at [http://elinux.org/Realtime_Testing_Best_Practices](http://elinux.org/Realtime_Testing_Best_Practices).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个问题的一些有趣信息可以在[http://elinux.org/Realtime_Testing_Best_Practices](http://elinux.org/Realtime_Testing_Best_Practices)上找到。
- en: Meta-realtime
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元实时
- en: The `meta-realtime` layer is an initiative maintained by Bruce Ashfield from
    WindRiver, which planned to create a place where real-time activities related
    to the Linux kernel or system development. It was created as the placeholder for
    PREEMPT_RT, SCHED_DEADLINE, POSIX real-time, and alternative paring of general
    purpose operating systems and real-time operating systems, whether this involved
    a user space RTOS, a hypervisor, or an AMP solution. Also, this is where system
    partitioning, CPU isolation, and other related applications s reside. Of course,
    none of this would be considered complete without some performance profiling and
    benchmarking applications available for the whole Linux operating system.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`meta-realtime`层是由WindRiver的Bruce Ashfield维护的一个倡议，旨在创建一个与Linux内核或系统开发相关的实时活动的场所。它被创建为PREEMPT_RT、SCHED_DEADLINE、POSIX实时和通用操作系统和实时操作系统的替代配对的占位符，无论这涉及用户空间RTOS、虚拟机监视程序还是AMP解决方案。此外，这也是系统分区、CPU隔离和其他相关应用程序的所在地。当然，如果没有为整个Linux操作系统提供一些性能分析和基准测试应用程序，这一切都不会被认为是完整的。'
- en: 'Although this layer description sounds really exciting at first, its content
    is really poor. It is only able to incorporate a number of testing tools, more
    accurately, two of them: `schedtool-dl` and `rt-app`, as well as extra scripts
    that try to remotely run `rt-app` on the target machine and gather the resulting
    data.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个层描述起初听起来很激动人心，但其内容实际上非常贫乏。它只能整合一些测试工具，更准确地说，其中两个是`schedtool-dl`和`rt-app`，以及额外的脚本，试图在目标机器上远程运行`rt-app`并收集结果数据。
- en: The first `schedtool-dl` application is a scheduler testing tool used for deadline
    scheduling. It appears from the need to change or make queries of the CPU-scheduling
    policies and even processes levels available under Linux. It can also be used
    to lock processes on various CPUs for SMP/NUMA systems, to avoid skipping in audio/video
    applications, and in general, to maintain a high level of interaction and responsiveness
    even under high loads.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`schedtool-dl`应用是一个用于截止时间调度的调度器测试工具。它出现的原因是需要在Linux下更改或查询CPU调度策略，甚至是进程级别。它还可以用于在SMP/NUMA系统上锁定各种CPU上的进程，以避免音频/视频应用程序中的跳过，并且通常可以在高负载下保持高水平的交互和响应能力。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about the `schedtool-dl` application can be found at [https://github.com/jlelli/schedtool-dl](https://github.com/jlelli/schedtool-dl).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`schedtool-dl`应用程序的更多信息可以在[https://github.com/jlelli/schedtool-dl](https://github.com/jlelli/schedtool-dl)上找到。
- en: The next and last available application is `rt-app`, which is used as a test
    application for the simulation of real-time loads on a system. It does this by
    starting multiple threads at given periods of time. It offers support for SCHED_FIFO,
    SCHED_OTHER, SCHED_RR, SCHED_DEADLINE, as well as the **Adaptive Quality of Service
    Architecture** (**AQuoSA**) framework, which is an open source project that tries
    to offer adaptive **Quality of Service** (**QoS**) for the Linux kernel.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个也是最后一个可用的应用是`rt-app`，它用作系统上实时负载的模拟测试应用程序。它通过在给定时间段启动多个线程来实现这一点。它支持SCHED_FIFO、SCHED_OTHER、SCHED_RR、SCHED_DEADLINE，以及**自适应服务质量架构**（**AQuoSA**）框架，这是一个旨在为Linux内核提供自适应**服务质量**（**QoS**）的开源项目。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about the `rt-app` application and the AQuoSa framework can
    be found at [https://github.com/scheduler-tools/rt-app](https://github.com/scheduler-tools/rt-app)
    and [http://aquosa.sourceforge.net/](http://aquosa.sourceforge.net/).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`rt-app`应用程序和AQuoSa框架的更多信息可以在[https://github.com/scheduler-tools/rt-app](https://github.com/scheduler-tools/rt-app)和[http://aquosa.sourceforge.net/](http://aquosa.sourceforge.net)上找到。
- en: Besides the included packages, the layer also contains an image that incorporates
    them, but this is not nearly enough to make this layer one that contains substantial
    content. Although it does not contain a vast amount of information inside it,
    this layer has been presented in this chapter because it contains the starting
    point and offers a development point of view of all the information presented
    until now. Of course, a number of applications that should reside in this layer
    are already spread across multiple other layers, such as the `idlestat` package
    that is available in `meta-linaro`. However, this does not constitute the central
    point of this explanation. I only wanted to point out the most suitable place
    that can contain any real-time relate activities, and in my opinion, `meta-realtime`
    is this place.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了包含的软件包外，该层还包含一个集成了它们的镜像，但这远远不足以使该层包含实质性内容。虽然它内部并不包含大量信息，但本章将介绍该层，因为它包含了起点，并提供了迄今为止所呈现的所有信息的发展视角。当然，应该驻留在该层中的一些应用程序已经分布在多个其他层中，比如`meta-linaro`中可用的`idlestat`软件包。然而，这并不构成本解释的核心。我只想指出可以包含任何实时相关活动的最合适的地方，而在我看来，`meta-realtime`就是这个地方。
- en: Summary
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you were given a short introduction to PREEMPT_RT and other
    alternative solutions for real-time problems of the Linux kernel. We also explored
    a number of tools and applications that can be used for related real-time activities.
    However, this presentation would not be complete without references made to the
    Yocto Project with regards not only to the recipes of the PREEMPT_RT Linux kernel,
    but also to `meta-realtime` layer applications. Developing an application suitable
    for a new context was also a concern, so this problem was tackled in the *Linux
    real-time applications* section. In the end, I hope that I was able to present
    a complete picture of this subject through links that were provided throughout
    the chapter to stir the curiosity of the reader.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您对PREEMPT_RT和Linux内核实时问题的其他替代解决方案进行了简要介绍。我们还探讨了一些可用于相关实时活动的工具和应用程序。然而，如果不提及Yocto项目，不仅涉及到PREEMPT_RT
    Linux内核的配方，还涉及`meta-realtime`层的应用程序，这个介绍就不完整。开发适用于新环境的应用程序也是一个关注点，因此在*Linux实时应用程序*部分解决了这个问题。最后，我希望通过本章中提供的链接来呈现这个主题的完整画面，以激发读者的好奇心。
- en: In the next chapter, a short explanation of `meta-security` and `meta-selinux`
    layers will be given and a broader picture of the security requirements of the
    Linux ecosystem in general and the Yocto Project in particular, will be provided.
    Information regarding a number of tools and applications that try to secure our
    Linux systems will also be presented, but this is not all. Take a look at the
    next chapter; I am sure you will enjoy it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，将对`meta-security`和`meta-selinux`层进行简要解释，并提供Linux生态系统和Yocto项目的安全需求的更广泛视角。还将介绍一些旨在保护我们的Linux系统的工具和应用程序的信息，但这还不是全部。看看下一章吧；我相信你会喜欢它。
