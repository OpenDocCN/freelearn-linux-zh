- en: Linux Device Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux设备模型
- en: 'Until version 2.5, the kernel had no way to describe and manage objects, and
    the code reusability was not as enhanced as it is now. In other words, there was
    no device topology nor organization. There was no information on subsystem relationships
    nor on how the system is put together. Then came the **Linux Device Model** (**LDM**
    ), which introduced:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 直到2.5版本，内核没有描述和管理对象的方法，代码的可重用性也不像现在这样增强。换句话说，没有设备拓扑结构，也没有组织。没有关于子系统关系或系统如何组合的信息。然后**Linux设备模型**（**LDM**）出现了，引入了：
- en: The concept of class, to group devices of the same type or devices that expose
    the same functionalities (for example, mice and keyboards are both input devices).
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的概念，用于将相同类型的设备或公开相同功能的设备（例如，鼠标和键盘都是输入设备）分组。
- en: Communication with the user space through a virtual filesystem called `sysfs`
    , in order to let user space manage and enumerate devices and the properties they
    expose.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过名为`sysfs`的虚拟文件系统与用户空间通信，以便让用户空间管理和枚举设备及其公开的属性。
- en: Management of object life cycle, using reference counting (heavily used in managed
    resources).
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用引用计数（在受管理资源中大量使用）管理对象生命周期。
- en: Power management in order to handle the order in which devices should shut down.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电源管理，以处理设备应该关闭的顺序。
- en: The reusability of the code. Classes and frameworks expose interfaces, behaving
    like contract that any driver that registers with them must respect.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的可重用性。类和框架公开接口，行为类似于任何注册的驱动程序必须遵守的合同。
- en: LDM brought an **Object Oriented** (**OO** )-like programming style in the kernel.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LDM在内核中引入了类似于**面向对象**（**OO**）的编程风格。
- en: In this chapter, we will take advantage of LDM and export some properties to
    the user space through the `sysfs` filesystem.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将利用LDM并通过`sysfs`文件系统向用户空间导出一些属性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing LDM data structures (Driver, Device, Bus)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入LDM数据结构（驱动程序，设备，总线）
- en: Gathering kernel objects by type
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按类型收集内核对象
- en: Dealing with the kernel `sysfs` interface
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理内核`sysfs`接口
- en: LDM data structures
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LDM数据结构
- en: The goal is to build a complete DT that will map each physical device present
    on the system, and introduce their hierarchy. One common and generic structure
    has been created to represent any object that could be a part of the device model.
    The upper level of LDM relies on the bus represented in the kernel as an instance
    of `struct bus_type` ; device driver, represented by a `struct device_driver`
    structure, and device, which is the last element represented as an instance of
    the `struct device` structure. In this section, we will design a bus driver packt
    bus, in order to get deep into LDM data structures and mechanisms.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是构建一个完整的设备树，将系统上存在的每个物理设备映射到其中，并介绍它们的层次结构。已经创建了一个通用结构，用于表示可能是设备模型一部分的任何对象。LDM的上一级依赖于内核中表示为`struct
    bus_type`实例的总线；设备驱动程序，表示为`struct device_driver`结构，以及设备，作为`struct device`结构的实例表示的最后一个元素。在本节中，我们将设计一个总线驱动程序包bus，以深入了解LDM数据结构和机制。
- en: The bus
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总线
- en: 'A bus is a channel link between devices and processors. The hardware entity
    that manages the bus and exports its protocol to devices is called the bus controller.
    For example, the USB controller provides USB support. The I2C controller provides
    I2C bus support. Therefore, the bus controller, being a device on its own, must
    be registered like any device. It will be the parent of devices that need to sit
    on the bus. In other words, every device sitting on the bus must have their parent
    field pointing to the bus device. A bus is represented in the kernel by the `struct
    bus_type` structure:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 公共汽车是设备和处理器之间的通道链接。管理总线并向设备导出其协议的硬件实体称为总线控制器。例如，USB控制器提供USB支持。I2C控制器提供I2C总线支持。因此，总线控制器作为一个设备，必须像任何设备一样注册。它将是需要放在总线上的设备的父级。换句话说，每个放在总线上的设备必须将其父字段指向总线设备。总线在内核中由`struct
    bus_type`结构表示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following are the meanings of elements in the structure:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结构中元素的含义：
- en: '`match` : This is a callback, called whenever a new device or driver is added
    to the bus. The callback must be smart enough and should return a nonzero value
    when there is a match between a device and a driver, both given as parameters.
    The main purpose of a `match` callback is to allow a bus to determine if a particular
    device can be handled by a given driver or the other logic, if the given driver
    supports a given device. Most of the time, the verification is done by a simple
    string comparison (device and driver name, of table and DT compatible property).
    For enumerated devices (PCI, USB), the verification is done by comparing the device
    IDs supported by the driver with the device ID of the given device, without sacrificing
    bus-specific functionality.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`match`：这是一个回调，每当新设备或驱动程序添加到总线时都会调用。回调必须足够智能，并且在设备和驱动程序之间存在匹配时应返回非零值，这两者作为参数给出。`match`回调的主要目的是允许总线确定特定设备是否可以由给定驱动程序处理，或者其他逻辑，如果给定驱动程序支持给定设备。大多数情况下，验证是通过简单的字符串比较完成的（设备和驱动程序名称，或表和DT兼容属性）。对于枚举设备（PCI，USB），验证是通过比较驱动程序支持的设备ID与给定设备的设备ID进行的，而不会牺牲总线特定功能。'
- en: '`probe` : This is a callback when a new device or driver is added to the bus,
    after the match has occurred. This function is responsible for allocating the
    specific bus device structure, and call the given driver''s `probe` function,
    which is supposed to manage the device (allocated earlier).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`probe`：这是在匹配发生后，当新设备或驱动程序添加到总线时调用的回调。此函数负责分配特定的总线设备结构，并调用给定驱动程序的`probe`函数，该函数应该管理之前分配的设备。'
- en: '`remove` : This is called when a device is to removed from the bus.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove`：当设备从总线中移除时调用此函数。'
- en: '`suspend` : This is a method called when a device on the bus needs to be put
    into sleep mode.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suspend`：这是一种在总线上的设备需要进入睡眠模式时调用的方法。'
- en: '`resume` : This is called when a device on the bus has to be brought out of
    sleep mode.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resume`：当总线上的设备需要被唤醒时调用此函数。'
- en: '`pm` : This is a set of power management operations of the bus, which will
    call the specific device driver''s `pm-ops` .'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pm`：这是总线的电源管理操作集，将调用特定设备驱动程序的`pm-ops`。'
- en: '`drv_groups` : This is a pointer to a list (array) of `struct attribute_group`
    elements, each of which has a pointer to a list (array) of `struct attribute`
    elements. It represents the default attributes of the device drivers on the bus.
    Attributes passed to this field will be given to every driver registered with
    the bus. Those attributes can be found in the driver''s directory in `/sys/bus/<bus-name>/drivers/<driver-name>`
    .'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drv_groups`：这是指向`struct attribute_group`元素列表（数组）的指针，每个元素都指向`struct attribute`元素列表（数组）。它代表总线上设备驱动程序的默认属性。传递给此字段的属性将赋予总线上注册的每个驱动程序。这些属性可以在`/sys/bus/<bus-name>/drivers/<driver-name>`中的驱动程序目录中找到。'
- en: '`dev_groups` : This represents the default attributes of the devices on the
    bus. Attributes passed (through the list/array of the `struct attribute_group`
    elements) to this field will be given to every device registered with the bus.
    Those attributes can be found in the device directory in `/sys/bus/<bus-name>/devices/<device-name>.`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev_groups`：这代表总线上设备的默认属性。通过传递给此字段的`struct attribute_group`元素的列表/数组，将赋予总线上注册的每个设备这些属性。这些属性可以在`/sys/bus/<bus-name>/devices/<device-name>`中的设备目录中找到。'
- en: '`bus_group` : This holds the set (group) of default attributes added automatically
    when the bus is registered with the core.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bus_group`：这保存总线注册到核心时自动添加的默认属性集（组）。'
- en: Apart from defining a `bus_type` , the bus controller driver must define a bus-specific
    driver structure that extends the generic `struct device_driver` , and a bus-specific
    device structure that extends the generic `struct device` structure, both part
    of the device model core. The bus drivers must also allocate a bus-specific device
    structure for each physical device discovered when probing, and is responsible
    for initializing the `bus` and `parent` fields of the device and registering the
    device with the LDM core. Those fields must point to the bus device and the `bus_type`
    structures defined in the bus driver. The LDM core uses that to build the device
    hierarchy and initialize the other fields.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义`bus_type`之外，总线控制器驱动程序还必须定义一个特定于总线的驱动程序结构，该结构扩展了通用的`struct device_driver`，以及一个特定于总线的设备结构，该结构扩展了通用的`struct
    device`结构，都是设备模型核心的一部分。总线驱动程序还必须为探测到的每个物理设备分配一个特定于总线的设备结构，并负责初始化设备的`bus`和`parent`字段，并将设备注册到LDM核心。这些字段必须指向总线设备和总线驱动程序中定义的`bus_type`结构。LDM核心使用这些来构建设备层次结构并初始化其他字段。
- en: 'In our example, the following are two helper macros to get the packt device
    and the packt driver, given a generic `struct device` and `struct driver` :'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，以下是两个辅助宏，用于获取packt设备和packt驱动程序，给定通用的`struct device`和`struct driver`：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And then comes the structure used to identify a packt device:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是用于识别packt设备的结构：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following are packt-specific devices and driver structures:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是packt特定的设备和驱动程序结构：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each bus internally manages two important lists; the list of devices added and
    sitting on it, and the list of driver registered with it. Whenever you add/register
    or remove/unregister a device/driver to/from the bus, the corresponding list is
    updated with the new entry. The bus driver must provide helper functions to register/unregister
    device drivers that can handle devices on that bus, as well as helper functions
    to register/unregister devices sitting on the bus. These helper functions always
    wrap the generic functions provided by the LDM core, which are `driver_register()`
    , `device_register()` , `driver_unregister` , and `device_unregister()` .
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个总线内部管理两个重要列表；添加到总线上的设备列表和注册到总线上的驱动程序列表。每当添加/注册或移除/注销设备/驱动程序到/从总线时，相应的列表都会更新为新条目。总线驱动程序必须提供辅助函数来注册/注销可以处理该总线上设备的设备驱动程序，以及注册/注销坐在总线上的设备的辅助函数。这些辅助函数始终包装LDM核心提供的通用函数，即`driver_register()`，`device_register()`，`driver_unregister`和`device_unregister()`。
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The function used to allocate packt devices is as follows. One must use this
    to create an instance of any physical device sitting on the bus:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 用于分配packt设备的函数如下。必须使用此函数来创建总线上任何物理设备的实例：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Bus registration
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总线注册
- en: 'The bus controller is a device itself, and in 99% of cases buses are platform
    devices (even buses that offer enumeration). For example, PCI controller is a
    platform device, so is its respective driver. One must use the `bus_register(struct
    *bus_type)` function in order to register a bus with the kernel. The packt bus
    structure looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 总线控制器本身也是一个设备，在99%的情况下总线是平台设备（即使提供枚举的总线也是如此）。例如，PCI控制器是一个平台设备，它的相应驱动程序也是如此。必须使用`bus_register(struct
    *bus_type)`函数来注册总线到内核。packt总线结构如下：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The bus controller is a device itself, it has to be registered with the kernel,
    and will be used as a parent of the device siting on the bus. This is done in
    the bus controller''s `probe` or `init` function. In the case of the packt bus,
    the code would be as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 总线控制器本身也是一个设备，它必须在内核中注册，并且将用作总线上设备的父设备。这是在总线控制器的`probe`或`init`函数中完成的。在packt总线的情况下，代码如下：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When a device is registered by the bus controller driver, the parent member
    of the device must point to the bus controller device and its bus property must
    point to the bus type to build the physical DT. To register a packt device, one
    must call `packt_device_register` , given as an argument allocated with `packt_device_alloc`
    :'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当总线控制器驱动程序注册设备时，设备的父成员必须指向总线控制器设备，其总线属性必须指向总线类型以构建物理DT。要注册packt设备，必须调用`packt_device_register`，并将其分配为`packt_device_alloc`的参数：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Device driver
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备驱动程序
- en: 'A global device hierarchy allows each device in the system to be represented
    in a common way. This allows the core to easily walk the DT to create such things
    as properly ordered power management transitions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 全局设备层次结构允许以通用方式表示系统中的每个设备。这使得核心可以轻松地遍历 DT 以创建诸如适当排序的电源管理转换之类的东西：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`struct device_driver` defines a simple set of operations for the core to perform
    these actions on each device:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct device_driver` 定义了一组简单的操作，供核心对每个设备执行这些操作：'
- en: '`* name` represents the driver''s name. It can be used for matching, by comparing
    with the device name.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`* name` 表示驱动程序的名称。它可以通过与设备名称进行比较来进行匹配。'
- en: '`* bus` represents the bus the driver sits on. The bus driver must fill this
    field.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`* bus` 表示驱动程序所在的总线。总线驱动程序必须填写此字段。'
- en: '`module` represents the module owning the driver. In 99% of cases, one should
    set this field to `THIS_MODULE` .'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module` 表示拥有驱动程序的模块。在 99% 的情况下，应将此字段设置为 `THIS_MODULE`。'
- en: '`of_match_table` is a pointer to the array of `struct of_device_id` . The `struct
    of_device_id` structure is used to perform OF match through a special file called
    DT, passed to the kernel during the boot process:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of_match_table` 是指向 `struct of_device_id` 数组的指针。`struct of_device_id` 结构用于通过称为
    DT 的特殊文件执行 OF 匹配，该文件在引导过程中传递给内核：'
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`suspend` and `resume` callbacks provide power management functionality. The
    `remove` callback is called when the device is physically removed from the system,
    or when its reference count reaches `0` . The `remove` callback is also called
    during system reboot.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suspend` 和 `resume` 回调提供电源管理功能。当设备从系统中物理移除或其引用计数达到 `0` 时，将调用 `remove` 回调。在系统重新启动期间也会调用
    `remove` 回调。'
- en: '`probe` is the probe callback that runs when attempting to bind a driver to
    a device. The bus driver is in charge of calling the device driver''s `probe`
    function.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`probe` 是在尝试将驱动程序绑定到设备时运行的探测回调函数。总线驱动程序负责调用设备驱动程序的 `probe` 函数。'
- en: '`group` is a pointer to a list (array) of `struct attribute_group` , used as
    a default attribute for the driver. Use this method instead of creating an attribute
    separately.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group` 是指向 `struct attribute_group` 列表（数组）的指针，用作驱动程序的默认属性。使用此方法而不是单独创建属性。'
- en: Device driver registration
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备驱动程序注册
- en: '`driver_register()` is the low-level function used to register a device driver
    with the bus. It adds the driver to the bus''s list of drivers. When a device
    driver is registered with the bus, the core walks through the bus''s list of devices
    and calls the bus''s match callback for each device that does not have a driver
    associated with it in order to find out if there are any devices that the driver
    can handle.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`driver_register()` 是用于在总线上注册设备驱动程序的低级函数。它将驱动程序添加到总线的驱动程序列表中。当设备驱动程序与总线注册时，核心会遍历总线的设备列表，并对每个没有与之关联驱动程序的设备调用总线的匹配回调，以找出驱动程序可以处理的设备。'
- en: When a match occurs, the device and the device driver are bound together. The
    process of associating a device with a device driver is called binding.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生匹配时，设备和设备驱动程序被绑定在一起。将设备与设备驱动程序关联的过程称为绑定。
- en: 'Now back to the registration of drivers with our packt bus, one has to use
    `packt_register_driver(struct packt_driver *driver)` , which is a wrapper around
    `driver_register()` . The `*driver` parameter must have been filled prior to registering
    the packt driver. The LDM core provides helper functions for iterating over the
    list of drivers registered with the bus:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到使用我们的 packt 总线注册驱动程序，必须使用 `packt_register_driver(struct packt_driver *driver)`，这是对
    `driver_register()` 的包装。在注册 packt 驱动程序之前，必须填写 `*driver` 参数。LDM 核心提供了用于遍历已注册到总线的驱动程序列表的辅助函数：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This helper iterates over the bus's list of drivers, and calls the `fn` callback
    for each driver in the list.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此助手遍历总线的驱动程序列表，并对列表中的每个驱动程序调用 `fn` 回调。
- en: Device
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备
- en: 'The struct device is the generic data structure used to describe and characterize
    each device on the system, whether it is physical or not. It contains details
    about the physical attributes of the device, and provides proper linkage information
    to build suitable device trees and reference counting:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体设备是用于描述和表征系统上每个设备的通用数据结构，无论其是否是物理设备。它包含有关设备的物理属性的详细信息，并提供适当的链接信息以构建合适的设备树和引用计数：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`* parent` represents the device''s parent, used to build device tree hierarchy.
    When registered with a bus, the bus driver is responsible for setting this field
    with the bus device.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`* parent` 表示设备的父级，用于构建设备树层次结构。当与总线注册时，总线驱动程序负责使用总线设备设置此字段。'
- en: '`* bus` represents the bus the device sits on. The bus driver must fill this
    field.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`* bus` 表示设备所在的总线。总线驱动程序必须填写此字段。'
- en: '`* type` identifies the device''s type.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`* type` 标识设备的类型。'
- en: '`kobj` is the kobject in handle reference counting and device model support.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kobj` 是处理引用计数和设备模型支持的 kobject。'
- en: '`* of_node` is a pointer to the OF (DT) node associated with the device. It
    is up to the bus driver to set this field.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`* of_node` 是指向与设备关联的 OF（DT）节点的指针。由总线驱动程序设置此字段。'
- en: '`platform_data` is a pointer to the platform data specific to the device. Usually
    declared in a board-specific file during device provisioning.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`platform_data` 是指向特定于设备的平台数据的指针。通常在设备供应期间在特定于板的文件中声明。'
- en: '`driver_data` is a pointer to private data for the driver.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver_data` 是驱动程序的私有数据的指针。'
- en: '`class` is a pointer to the class that the device belongs to.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class` 是指向设备所属类的指针。'
- en: '`* group` is a pointer to a list (array) of `struct attribute_group` , used
    as the default attribute for the device. Use this method instead of creating the
    attribute separately.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`* group` 是指向 `struct attribute_group` 列表（数组）的指针，用作设备的默认属性。使用此方法而不是单独创建属性。'
- en: '`release` is a callback called when the device reference count reaches zero.
    The bus has the responsibility of setting this field. The packt bus driver shows
    you how to do this.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release` 是在设备引用计数达到零时调用的回调。总线有责任设置此字段。packt 总线驱动程序向您展示了如何做到这一点。'
- en: Device registration
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备注册
- en: '`device_register` is the function provided by the LDM core to register a device
    with the bus. After this call, the bus list of drivers is iterated over to find
    the driver that supports this device and then this device is added to the bus''s
    list of devices. `device_register()` internally calls `device_add()` :'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`device_register`是LDM核心提供的用于在总线上注册设备的函数。调用此函数后，将遍历驱动程序的总线列表以找到支持此设备的驱动程序，然后将此设备添加到总线的设备列表中。`device_register()`在内部调用`device_add()`：'
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The helper function provided by the kernel to iterate over the bus''s list
    of devices is `bus_for_each_dev` :'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 内核提供的用于遍历总线设备列表的辅助函数是`bus_for_each_dev`：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Whenever a device is added, the core invokes the match method of the bus driver
    (`bus_type->match` ). If the match function says there is a driver for this device,
    the core will invoke the `probe` function of the bus driver (`bus_type->probe`
    ), given both device and driver as parameters. It is then up to the bus driver
    to invoke the `probe` method of the device's driver (`driver->probe` ). For our
    packt bus driver, the function used to register a device is `packt_device_register(struct
    packt_device *packt)` , which internally calls `device_register` , and where the
    parameter is a packt device allocated with `packt_device_alloc` .
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每当添加设备时，核心都会调用总线驱动程序的匹配方法（`bus_type->match`）。如果匹配函数表示有驱动程序支持此设备，核心将调用总线驱动程序的`probe`函数（`bus_type->probe`），给定设备和驱动程序作为参数。然后由总线驱动程序调用设备的驱动程序的`probe`方法（`driver->probe`）。对于我们的packt总线驱动程序，用于注册设备的函数是`packt_device_register(struct
    packt_device *packt)`，它在内部调用`device_register`，参数是使用`packt_device_alloc`分配的packt设备。
- en: Deep inside LDM
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入LDM
- en: The LDM under the wood relies on three important structures, which are kobject,
    kobj_type, and kset. Let us see how each of these structures are involved in the
    device model.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: LDM在内部依赖于三个重要的结构，即kobject、kobj_type和kset。让我们看看这些结构中的每一个如何参与设备模型。
- en: kobject structure
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kobject结构
- en: 'kobject is the core of the device model, running behind the scenes. It brings
    an OO-like programming style to the kernel, and is mainly used for reference counting
    and to expose devices hierarchies and relationships between them. kobjects introduce
    the concept of encapsulation of common object properties such as usage reference
    counts:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: kobject是设备模型的核心，运行在后台。它为内核带来了类似OO的编程风格，主要用于引用计数和公开设备层次结构和它们之间的关系。kobject引入了封装常见对象属性的概念，如使用引用计数：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`name` points to the name of this kobject. One can change this using the `kobject_set_name(struct
    kobject *kobj, const char *name)` function.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`指向此kobject的名称。可以使用`kobject_set_name(struct kobject *kobj, const char
    *name)`函数来更改这个名称。'
- en: '`parent` is a pointer to this kobject''s parent. It is used to build a hierarchy
    to describe the relationship between objects.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`是指向此kobject父级的指针。它用于构建描述对象之间关系的层次结构。'
- en: '`sd` points to a `struct sysfs_dirent` structure that represents this kobject
    in sysfs inode inside this structure for sysfs.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sd`指向一个`struct sysfs_dirent`结构，表示sysfs中此kobject的inode内部的结构。'
- en: '`kref` provides reference counting on the kobject.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kref`提供了对kobject的引用计数。'
- en: '`ktype` describes the object, and `kset` tells us which set (group) of objects
    this object belongs to.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ktype`描述了对象，`kset`告诉我们这个对象属于哪个集合（组）。'
- en: Each structure that embeds a kobject is embedded and receives the standardized
    functions that kobjects provide. The embedded kobject will enable the structure
    to become a part of an object hierarchy.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个嵌入kobject的结构都会嵌入并接收kobject提供的标准化函数。嵌入的kobject将使结构成为对象层次结构的一部分。
- en: 'The `container_of` macro is used to get a pointer on the object to which the
    kobject belongs. Every kernel device directly or indirectly embeds a kobject property.
    Prior to be added to the system, the kobject must be allocated using `kobject_create()`
    function, which will return an empty kobject that one must initialize with `kobj_init()`
    , given as a parameter the allocated and non-initialized kobject pointer, along
    with its `kobj_type` pointer:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`container_of`宏用于获取kobject所属对象的指针。每个内核设备直接或间接地嵌入一个kobject属性。在添加到系统之前，必须使用`kobject_create()`函数分配kobject，该函数将返回一个空的kobject，必须使用`kobj_init()`进行初始化，给定分配和未初始化的kobject指针以及其`kobj_type`指针：'
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `kobject_add()` function is used to add and link a kobject to the system,
    at the same time creating its directory according to its hierarchy, along with
    its default attributes. The reverse function is `kobject_del()` :'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`kobject_add()`函数用于将kobject添加和链接到系统，同时根据其层次结构创建其目录，以及其默认属性。反向函数是`kobject_del()`：'
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The reverse function of both `kobject_create` and `kobject_add` is `kobject_put`
    . In the source provided with the book, the excerpt to tie a kobject to the system
    is:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`kobject_create`和`kobject_add`的反向函数是`kobject_put`。在书中提供的源代码中，将kobject绑定到系统的摘录是：'
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'One could have used `kobject_create_and_add` , which internally calls `kobject_create
    and kobject_add` . The following excerpt from `drivers/base/core.c` shows how
    to use it:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`kobject_create_and_add`，它在内部调用`kobject_create`和`kobject_add`。`drivers/base/core.c`中的以下摘录显示了如何使用它：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If a kobject has a `NULL` parent, then `kobject_add` sets parent to kset. If
    both are `NULL` , object becomes a child-member of the top-level sys directory
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果kobject有一个`NULL`父级，那么`kobject_add`会将父级设置为kset。如果两者都是`NULL`，对象将成为顶级sys目录的子成员
- en: kobj_type
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: kobj_type
- en: 'A `struct kobj_type` structure describes the behavior of kobjects. A `kobj_type`
    structure describes the type of object that embeds a kobject by means of `ktype`
    field. Every structure that embeds a kobject needs a corresponding `kobj_type`
    , which will control what happens when the kobject is created and destroyed, and
    when attributes are read or written to. Every kobject has a field of the type
    `struct kobj_type` , which stands for **kernel object type** :'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct kobj_type`结构描述了kobjects的行为。`kobj_type`结构通过`ktype`字段描述了嵌入kobject的对象的类型。每个嵌入kobject的结构都需要一个相应的`kobj_type`，它将控制在创建和销毁kobject以及读取或写入属性时发生的情况。每个kobject都有一个`struct
    kobj_type`类型的字段，代表**内核对象类型**：'
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A `struct kobj_type` structure allows kernel objects to share common operations
    (`sysfs_ops` ), whether those objects are functionally related or not. Fields
    of that structure are meaningful enough. `release` is a callback called by the
    `kobject_put()` function whenever your object needs to be freed. You must free
    memory held by your object here. One can use the `container_of` macro to get a
    pointer to the object. The `sysfs_ops` field points to sysfs operations, whereas
    `default_attrs` defines the default attributes associated with this kobject. `sysfs_ops`
    is a set of callback (sysfs operation) called when a sysfs attribute is accessed.
    `default_attrs` is a pointer to a list of `struct attribute` elements that will
    be used as default attributes for each object of this type:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct kobj_type`结构允许内核对象共享公共操作（`sysfs_ops`），无论这些对象是否在功能上相关。该结构的字段是有意义的。`release`是由`kobject_put()`函数调用的回调，每当需要释放对象时。您必须在这里释放对象持有的内存。可以使用`container_of`宏来获取对象的指针。`sysfs_ops`字段指向sysfs操作，而`default_attrs`定义了与此kobject关联的默认属性。`sysfs_ops`是一组在访问sysfs属性时调用的回调（sysfs操作）。`default_attrs`是指向`struct
    attribute`元素列表的指针，将用作此类型的每个对象的默认属性：'
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`show` is the callback called when one reads an attribute of any kobject which
    has this `kobj_type` . The buffer size is always `PAGE_SIZE` in length, even if
    the value to show is a simple `char` . One should set the value of `buf` (using
    `scnprintf` ), and return the size (in bytes) of data actually written into the
    buffer on success or negative error on failure. `store` is called for write purposes.
    Its `buf` parameter is at most `PAGE_SIZE` but can be smaller. It returns the
    size (in bytes) of data actually read from buffer on success or negative error
    on failure (or if it receives an unwanted value). One can use `get_ktype` to get
    the `kobj_type` of a given kobject:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`show`是当读取具有此`kobj_type`的任何kobject的属性时调用的回调。缓冲区大小始终为`PAGE_SIZE`，即使要显示的值是一个简单的`char`。应该设置`buf`的值（使用`scnprintf`），并在成功时返回实际写入缓冲区的数据的大小（以字节为单位），或者在失败时返回负错误。`store`用于写入目的。它的`buf`参数最多为`PAGE_SIZE`，但可以更小。它在成功时返回实际从缓冲区读取的数据的大小（以字节为单位），或者在失败时返回负错误（或者如果它收到一个不需要的值）。可以使用`get_ktype`来获取给定kobject的`kobj_type`：'
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the example in the book, our `k_type` variable represents our kobject''s
    type:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在书中的示例中，我们的`k_type`变量表示我们kobject的类型：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, the `show` and `store` callbacks are defined as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`show`和`store`回调定义如下：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ksets
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ksets
- en: '**Kernel object sets** (**ksets** ) mainly group related kernel objects together.
    ksets are collection of kobjects. In other words, a kset gathers related kobjects
    into a single place, for example, all block devices:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**内核对象集**（**ksets**）主要将相关的内核对象分组在一起。ksets是kobjects的集合。换句话说，kset将相关的kobjects聚集到一个地方，例如，所有块设备：'
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`list` is a linked list of all kobjects in the kset'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`是kset中所有kobject的链表'
- en: '`list_lock` is a spinlock protecting linked list access'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list_lock`是用于保护链表访问的自旋锁'
- en: '`kobj` represents the base class for the set'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kobj`表示集合的基类'
- en: 'Each registered (added to the system) kset corresponds to a sysfs directory.
    A kset can be created and added using the `kset_create_and_add()` function, and
    removed with the `kset_unregister()` function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每个注册（添加到系统中）的kset对应一个sysfs目录。可以使用`kset_create_and_add()`函数创建和添加kset，并使用`kset_unregister()`函数删除：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Adding a kobject to the set is as simple as specifying its kset field to the
    right kset:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将kobject添加到集合中就像将其kset字段指定为正确的kset一样简单：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now in the module `exit` function, after kobject and their attributes have
    been removed:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在模块的`exit`函数中，kobject及其属性已被删除：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Attribute
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: Attributes are sysfs files exported to the user space by kobjects. An attribute
    represents an object property that can be readable, writable, or both, from the
    user space. That said, every data structure that embeds a struct kobject can expose
    either default attributes provided by the kobject itself (if any), or custom ones.
    In other words, attributes map kernel data to files in sysfs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是由kobjects向用户空间导出的sysfs文件。属性表示可以从用户空间可读、可写或两者的对象属性。也就是说，每个嵌入`struct kobject`的数据结构可以公开由kobject本身提供的默认属性（如果有的话），也可以公开自定义属性。换句话说，属性将内核数据映射到sysfs中的文件。
- en: 'An attribute definition looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 属性定义如下：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The kernel functions used to add/remove attributes from the filesystem are:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 用于从文件系统中添加/删除属性的内核函数是：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let us try to define two properties that we will export, each represented by
    an attribute:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试定义两个我们将导出的属性，每个属性由一个属性表示：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To create each enumerated attribute separately, we have to call the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要单独创建每个枚举属性，我们必须调用以下内容：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A good place to start with attributes is `samples/kobject/kobject-example.c`
    in the kernel source.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的一个很好的起点是内核源码中的`samples/kobject/kobject-example.c`。
- en: Attributes group
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性组
- en: 'So far, we have seen how to individually add attributes and call (directly
    or indirectly through a wrapper function such as `device_create_file()` , `class_create_file()`
    , and so on) `sysfs_create_file()` on each of them. Why bother ourselves with
    multiple calls if we can do it once? Here is where the attribute group comes in.
    It relies on the `struct attribute_group` structure:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何单独添加属性，并在每个属性上调用（直接或间接通过包装函数，如`device_create_file()`，`class_create_file()`等）`sysfs_create_file()`。如果我们可以一次完成，为什么要自己处理多个调用呢？这就是属性组的作用。它依赖于`struct
    attribute_group`结构：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Of course, we have removed fields that are not of interest. The `attr` s field
    is a pointer to `NULL` terminated list of attributes. Each attribute group must
    be given a pointer to a list/array of `struct attribute` elements. The group is
    just a helper wrapper that makes it easier to manage multiple attributes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们已经删除了不感兴趣的字段。`attr`字段是指向属性列表/数组的指针。每个属性组必须给定一个指向`struct attribute`元素的列表/数组的指针。该组只是一个帮助包装器，使得更容易管理多个属性。
- en: 'The kernel functions used to add/remove group attributes to the filesystem
    are:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 用于向文件系统添加/删除组属性的内核函数是：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The two preceding defined properties can be embedded in a `struct attribute_group`
    , to make only one call to add both of them to the system:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 前面定义的两个属性可以嵌入到`struct attribute_group`中，只需一次调用即可将它们都添加到系统中：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The one and only function to call here is this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里唯一需要调用的函数是：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It is much better than making a call for each attribute.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这比为每个属性都调用一次要好得多。
- en: Device model and sysfs
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备模型和sysfs
- en: '`Sysfs` is a non-persistent virtual filesystem that provides a global view
    of the system and exposes the kernel object''s hierarchy (topology) by means of
    their kobjects. Each kobjects shows up as a directory, and files in a directory
    representing kernel variables, exported by the related kobject. These files are
    called attributes, and can be read or written.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sysfs`是一个非持久的虚拟文件系统，它提供了系统的全局视图，并通过它们的kobjects公开了内核对象的层次结构（拓扑）。每个kobjects显示为一个目录，目录中的文件表示由相关kobject导出的内核变量。这些文件称为属性，可以被读取或写入。'
- en: If any registered kobject creates a directory in sysfs, where the directory
    is created depends on the kobject's parent (which is a kobject too). It is natural
    that directories are created as subdirectories of the kobject's parent. This highlights
    internal object hierarchies to the user space. Top-level directories in sysfs
    represent the common ancestors of object hierarchies, that is, the subsystems
    the objects belong to.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何注册的kobject在sysfs中创建一个目录，那么目录的创建取决于kobject的父对象（也是一个kobject）。自然而然地，目录被创建为kobject的父目录的子目录。这将内部对象层次结构突显到用户空间。sysfs中的顶级目录表示对象层次结构的共同祖先，也就是对象所属的子系统。
- en: 'Top-level sysfs directories can be found under the `/sys/` directory:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级sysfs目录可以在`/sys/`目录下找到：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`block` contains a directory per-block device on the system, each of which
    contains subdirectories for partitions on the device. `bus` contains the registered
    bus on the system. `dev` contains the registered device nodes in a raw way (no
    hierarchy), each being a symlink to the real device in the `/sys/devices` directory.
    `devices` gives a view of the topology of devices in the system. `firmware` shows
    a system-specific tree of low-level subsystems, such as: ACPI, EFI, OF (DT). `fs`
    lists filesystems actually used on the system. `kernel` holds kernel configuration
    options and status info. `Modules` is a list of loaded modules.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`block`包含系统上每个块设备的目录，每个目录包含设备上分区的子目录。`bus`包含系统上注册的总线。`dev`以原始方式包含注册的设备节点（无层次结构），每个都是指向`/sys/devices`目录中真实设备的符号链接。`devices`显示系统中设备的拓扑视图。`firmware`显示系统特定的低级子系统树，例如：ACPI、EFI、OF（DT）。`fs`列出系统上实际使用的文件系统。`kernel`保存内核配置选项和状态信息。`Modules`是已加载模块的列表。'
- en: 'Each of these directories corresponds to a kobject, some of which are exported
    as kernel symbols. These are:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目录中的每一个都对应一个kobject，其中一些作为内核符号导出。这些是：
- en: '`kernel_kobj` which corresponds to `/sys/kernel`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kernel_kobj`对应于`/sys/kernel`'
- en: '`power_kobj` for `/sys/power`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`power_kobj`对应于`/sys/power`'
- en: '`firmware_kobj` which is for `/sys/firmware` , exported in the `drivers/base/firmware.c`
    source file'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firmware_kobj`对应于`/sys/firmware`，在`drivers/base/firmware.c`源文件中导出'
- en: '`hypervisor_kobj` for `/sys/hypervisor` , exported in the `drivers/base/hypervisor.c`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hypervisor_kobj`对应于`/sys/hypervisor`，在`drivers/base/hypervisor.c`中导出'
- en: '`fs_kobj` which corresponds to `/sys/fs` , exported in the `fs/namespace.c`
    file'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs_kobj`对应于`/sys/fs`，在`fs/namespace.c`文件中导出'
- en: However, `class/` , `dev/` , `devices/` , are created during the boot by the
    `devices_init` function in `drivers/base/core.c` in kernel source, `block/` is
    created in `block/genhd.c` , and `bus/` is created as a kset in `drivers/base/bus.c`
    .
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`class/`、`dev/`、`devices/`是在内核源代码中的`drivers/base/core.c`中由`devices_init`函数在启动时创建的，`block/`是在`block/genhd.c`中创建的，`bus/`是在`drivers/base/bus.c`中作为kset创建的。
- en: When a kobject directory is added to sysfs (using `kobject_add` ), where it
    is added depends on the kobject's parent location. If its parent pointer is set,
    it is added as a subdirectory inside the parent's directory. If the parent pointer
    is NULL, it is added as a subdirectory inside `kset->kobj` . If neither parent
    nor kset fields are set, it maps to the root level directory in sysfs *(`/sys`*
    ).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当将kobject目录添加到sysfs（使用`kobject_add`）时，它被添加的位置取决于kobject的父位置。如果其父指针已设置，则将其添加为父目录中的子目录。如果父指针为空，则将其添加为`kset->kobj`中的子目录。如果父字段和kset字段都未设置，则映射到sysfs中的根级目录（`/sys`）。
- en: 'One can create/remove symbolic links on existing objects (directories), using
    `sysfs_{create|remove}_link` functions:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`sysfs_{create|remove}_link`函数在现有对象（目录）上创建/删除符号链接：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This will allow an object to exist in more than one place. The create function
    will create a symlink named `name` pointing to the `target` kobject sysfs entry.
    A well know example is devices appearing in both `/sys/bus` and `/sys/devices`
    . Symbolic links created will be persistent even after `target` removal. You have
    to know when the `target` is removed, and then remove the corresponding symlink.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许一个对象存在于多个位置。创建函数将创建一个名为`name`的符号链接，指向`target` kobject sysfs条目。一个众所周知的例子是设备同时出现在`/sys/bus`和`/sys/devices`中。创建的符号链接将在`target`被移除后仍然存在。您必须知道`target`何时被移除，然后删除相应的符号链接。
- en: Sysfs files and attributes
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sysfs文件和属性
- en: Now we know that the default set of files are provided via the ktype field in
    kobjects and ksets, through the `default_attrs` field of `kobj_type` . Default
    attributes will be sufficient in most of the cases. But sometimes an instance
    of a ktype may need its own attributes to provide data or functionality not shared
    by a more general ktype.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，默认的文件集是通过kobjects和ksets中的ktype字段提供的，通过`kobj_type`的`default_attrs`字段。默认属性在大多数情况下都足够了。但有时，ktype的一个实例可能需要自己的属性来提供不被更一般的ktype共享的数据或功能。
- en: 'Just a recall, the low-level functions used to add/remove new attributes (or
    group of attributes) on top of default set are:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 只是一个提醒，用于在默认集合之上添加/删除新属性（或属性组）的低级函数是：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Current interfaces
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当前接口
- en: 'There are interface layers that currently exist in sysfs. Apart from creating
    your own ktype or kobject to add your attributes, you can use ones that currently
    exist: device, driver, bus, and class attributes. Their description are as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在sysfs中存在接口层。除了创建自己的ktype或kobject以添加属性外，还可以使用当前存在的属性：设备、驱动程序、总线和类属性。它们的描述如下：
- en: Device attributes
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备属性
- en: 'Apart from default attributes provided by the kobject embedded in your device
    structure, you can create custom ones. The structure used for this purpose is
    `struct device_attribute` , which is nothing but a wrapping around the standard
    `struct attribute` , and a set of callbacks to show/store the value of the attribute:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设备结构中嵌入的默认属性之外，您还可以创建自定义属性。用于此目的的结构是`struct device_attribute`，它只是标准`struct
    attribute`的包装，并且一组回调函数来显示/存储属性的值：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Their declaration is done through the `DEVICE_ATTR` macro:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的声明是通过`DEVICE_ATTR`宏完成的：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Whenever you declare a device attribute using `DEVICE_ATTR` , the prefix `dev_attr_`
    is added to the attribute name. For example, if you declare an attribute with
    the `_name` parameter set to foo, the attribute will be accessible through the
    `dev_attr_foo` variable name.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每当使用`DEVICE_ATTR`声明设备属性时，属性名称前缀`dev_attr_`将添加到属性名称中。例如，如果使用`_name`参数设置为foo来声明属性，则可以通过`dev_attr_foo`变量名称访问该属性。
- en: 'To understand why, let us see how the `DEVICE_ATTR` macro is defined in `include/linux/device.h`
    :'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么，让我们看看`DEVICE_ATTR`宏在`include/linux/device.h`中是如何定义的：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, you can add/remove those using the `device_create_file` and `device_remove_file`
    functions:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用`device_create_file`和`device_remove_file`函数添加/删除这些：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following sample is a demonstration of how to put it all together:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何将所有内容放在一起：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here are the static declarations of the attribute:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是属性的静态声明：
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following code shows how to actually create files on the system:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何在系统上实际创建文件：
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For cleanup, the attribute removal is done in the remove function as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于清理，属性的移除是在移除函数中完成的：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You may wonder how and why we used to define the same set of store/show callbacks
    for all attributes of the same kobject/ktype, and now, we use a custom one for
    each attribute. The first reason is because, the device subsystem defines its
    own attribute structure, which wraps the standard one, and secondly, instead of
    showing/storing the value of the attribute, it uses the `container_of` macro to
    extract the `struct device_attribute` giving a generic `struct attribute` , and
    then executes the show/store callback depending on the user action. The following
    is the excerpt from `drivers/base/core.c` , showing `sysfs_ops` of the device
    kobject:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道我们是如何以前定义相同的存储/显示回调来处理相同kobject/ktype的所有属性，现在我们为每个属性使用自定义的回调。第一个原因是，设备子系统定义了自己的属性结构，它包装了标准属性结构，其次，它不是显示/存储属性的值，而是使用`container_of`宏来提取`struct
    device_attribute`，从而给出一个通用的`struct attribute`，然后根据用户操作执行show/store回调。以下是来自`drivers/base/core.c`的摘录，显示了设备kobject的`sysfs_ops`：
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The principle is the same for bus (in `drivers/base/bus.c` ), driver (in `drivers/base/bus.c`
    ), and class (in `drivers/base/class.c` ) attributes. They use the `container_of`
    macro to extract their specific attribute structure, and then call the show/store
    callback embedded in it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 原则对于总线（在`drivers/base/bus.c`中）、驱动程序（在`drivers/base/bus.c`中）和类（在`drivers/base/class.c`中）属性是相同的。它们使用`container_of`宏来提取其特定属性结构，然后调用其中嵌入的show/store回调。
- en: Bus attributes
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总线属性
- en: 'It relies on the `struct bus_attribute` structure:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它依赖于`struct bus_attribute`结构：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Bus attributes are declared using the `BUS_ATTR` macro:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BUS_ATTR`宏声明总线属性：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Any bus attribute declared using `BUS_ATTR` will have the prefix `bus_attr_`
    added to the attribute variable name:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BUS_ATTR`声明的任何总线属性都将在属性变量名称中添加前缀`bus_attr_`：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'They are created/removed using `bus_{create|remove}_file` functions:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是使用`bus_{create|remove}_file`函数创建/删除的：
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Device drivers attributes
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备驱动程序属性
- en: 'The structure used is `struct driver_attribute` :'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 所使用的结构是`struct driver_attribute`：
- en: '[PRE53]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The declaration relies on the `DRIVER_ATTR` macro, which will prefix the attribute
    variable name with `driver_attr_` :'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 声明依赖于`DRIVER_ATTR`宏，该宏将在属性变量名称中添加前缀`driver_attr_`：
- en: '[PRE54]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The macro definition is:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 宏定义如下：
- en: '[PRE55]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Creation/removal relies on `driver_{create|remove}_file` functions:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 创建/删除依赖于`driver_{create|remove}_file`函数：
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Class attributes
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类属性
- en: 'The `struct class_attribute` is the base structure:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct class_attribute`是基本结构：'
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The declaration of a class attribute relies on `CLASS_ATTR` :'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性的声明依赖于`CLASS_ATTR`：
- en: '[PRE58]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As the macro''s definition shows, any class attribute declared with `CLASS_ATTR`
    will have the prefix `class_attr_` added to the attribute variable name:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如宏的定义所示，使用`CLASS_ATTR`声明的任何类属性都将在属性变量名称中添加前缀`class_attr_`：
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, file creation and removal is done with the `class_{create|remove}_file`
    functions:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，文件的创建和删除是使用`class_{create|remove}_file`函数完成的：
- en: '[PRE60]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Notice that `device_create_file()` , `bus_create_file()` , `driver_create_file()`
    , and `class_create_file()` all make an internal call to `sysfs_create_file()`
    . As they all are kernel objects, they have a `kobject` embedded into their structure.
    That `kobject` is then passed as a parameter to `sysfs_create_file` , as you can
    see as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`device_create_file()`，`bus_create_file()`，`driver_create_file()`和`class_create_file()`都会内部调用`sysfs_create_file()`。由于它们都是内核对象，它们的结构中嵌入了`kobject`。然后将该`kobject`作为参数传递给`sysfs_create_file`，如下所示：
- en: '[PRE61]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Allow sysfs attribute files to be pollable
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许sysfs属性文件进行轮询
- en: 'Here we will see how not to make CPU wasting polling to sense sysfs attributes
    data availability. The idea is to use the `poll` or `select` system calls to wait
    for the attribute''s content to change. The patch to make sysfs attributes pollable
    was created by **Neil Brown** and **Greg Kroah-Hartman** . The kobject manager
    (the driver which has access to the kobject) must support notification to allow
    `poll` or `select` to return (be released) when the content changes. The magic
    function that does the trick comes from the kernel side, and is `sysfs_notify()`
    :'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将看到如何避免进行CPU浪费的轮询以检测sysfs属性数据的可用性。想法是使用`poll`或`select`系统调用等待属性内容的更改。使sysfs属性可轮询的补丁是由**Neil
    Brown**和**Greg Kroah-Hartman**创建的。kobject管理器（具有对kobject的访问权限的驱动程序）必须支持通知，以允许`poll`或`select`在内容更改时返回（被释放）。执行这一技巧的神奇函数来自内核侧，即`sysfs_notify()`：
- en: '[PRE62]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If the `dir` parameter is non-NULL, it is used to find a subdirectory, which
    contains the attribute (presumably created by `sysfs_create_group` ). This has
    a cost of one `int` per attribute, one `wait_queuehead` per kobject, one int per
    open file.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`dir`参数非空，则用于查找包含属性的子目录（可能是由`sysfs_create_group`创建的）。每个属性的成本为一个`int`，每个kobject的`wait_queuehead`，每个打开文件一个int。
- en: '`poll` will return `POLLERR|POLLPRI` , and `select` will return the fd whether
    it is waiting for read, write, or exceptions. The blocking poll is from the user''s
    side. `sysfs_notify()` should be called only after you adjust your kernel attribute
    value.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`poll`将返回`POLLERR|POLLPRI`，而`select`将返回fd，无论它是等待读取、写入还是异常。阻塞的poll来自用户端。只有在调整内核属性值后才应调用`sysfs_notify()`。'
- en: Think of the `poll()` (or `select()` ) code as a **subscriber** to notice a
    change in an attribute of interest, and `sysfs_notify()` as a **publisher,** notifying
    subscribers of any changes.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将`poll()`（或`select()`）代码视为对感兴趣属性的更改通知的**订阅者**，并将`sysfs_notify()`视为**发布者**，通知订阅者任何更改。
- en: 'The following is an excerpt of code provided with the book, which is the store
    function of an attribute:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是书中提供的代码摘录，这是属性的存储函数：
- en: '[PRE63]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The code from the user space must behave like this in order to sense the data
    change:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间的代码必须像这样才能感知数据的更改：
- en: Open the file attributes.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件属性。
- en: Make a dummy read of all the contents.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对所有内容进行虚拟读取。
- en: Call poll requesting `POLLERR|POLLPRI` (select/exceptfds works too).
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`poll`请求`POLLERR|POLLPRI`（select/exceptfds也可以）。
- en: When `poll` (or `select` ) returns (which indicates that a value has changed),
    read the content of files whose data changed.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`poll`（或`select`）返回（表示值已更改）时，读取数据已更改的文件内容。
- en: Close the files and go to the top of the loop.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭文件并返回循环的顶部。
- en: When in doubt of a sysfs attribute being pollable, set a suitable timeout value.
    The user space example is provided with the book sample.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对sysfs属性是否可轮询存在疑问，请设置合适的超时值。书中提供了用户空间示例。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now you are familiar with the LDM concept and with its data structures (bus,
    class, device drivers, and devices), including low-level data structures, which
    are `kobject` , `kset` , `kobj_types` , and attributes (or group of those), how
    objects are represented within the kernel (hence sysfs and devices topology) is
    not a secret anymore. You will be able to create an attribute (or group), exposing
    your device or driver feature through sysfs. If the previous topic seems clear
    to you, we will move to the next [chapter 14](text00350.html) , *Pin Control and
    GPIO Subsystem* , which heavily uses the power of `sysfs` .
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经熟悉了LDM概念及其数据结构（总线、类、设备驱动程序和设备），包括低级数据结构，即`kobject`、`kset`、`kobj_types`和属性（或这些属性的组合），内核中如何表示对象（因此sysfs和设备拓扑结构）不再是秘密。您将能够创建一个通过sysfs公开您的设备或驱动程序功能的属性（或组）。如果前面的话题对您来说很清楚，我们将转到下一个[第14章](text00350.html)，*引脚控制和GPIO子系统*，该章节大量使用了`sysfs`的功能。
