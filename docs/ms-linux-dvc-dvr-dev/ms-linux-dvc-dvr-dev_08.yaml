- en: '*Chapter 6*: ALSA SoC Framework – Delving into the Machine Class Drivers'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第6章*：ALSA SoC框架-深入了解机器类驱动程序'
- en: While starting our ALSA SoC framework series, we noticed that neither platform
    nor codec class drivers are intended to work on their own. The ASoC architecture
    is designed in such a way that platform and codec class drivers must be bound
    together in order to build the audio device. This binding can be done either from
    a so-called machine driver or from within the device tree, each of which being
    machine specific. It then goes without saying that the machine driver targets
    a specific system, and it may change from one board to another. In this chapter,
    we highlight the dark side of AsoC machine class drivers and discuss specific
    cases we may encounter when we need to write a machine class driver.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始我们的ALSA SoC框架系列时，我们注意到平台和编解码器类驱动程序都不打算单独工作。ASoC架构设计成平台和编解码器类驱动程序必须绑定在一起才能构建音频设备。这种绑定可以通过所谓的机器驱动程序或者设备树内部完成，每个都是特定于机器的。因此可以毫不夸张地说，机器驱动程序针对特定系统，可能会从一个板子变成另一个板子。在本章中，我们将重点介绍AsoC机器类驱动程序的不足之处，并讨论在需要编写机器类驱动程序时可能遇到的特定情况。
- en: 'In this chapter, we will present the Linux ASoC driver architecture and implementation.
    This chapter will be split into different parts, which are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Linux ASoC驱动程序架构和实现。本章将分为不同的部分，如下所示：
- en: Introduction to machine class drivers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器类驱动程序介绍
- en: Machine routing considerations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器路由考虑
- en: Clocking and formatting considerations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时钟和格式考虑
- en: Sound card registration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声卡注册
- en: Leveraging the simple-card machine driver
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用simple-card机器驱动程序
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You need the following for this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下内容：
- en: Strong knowledge of the concept of device trees
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对设备树概念的深入了解
- en: Familiarity with both platform and codec class drivers (discussed in [*Chapter
    5*](B10985_05_ePub_AM.xhtml#_idTextAnchor124)*,* *ALSA SoC Framework – Leveraging
    Codec and Platform Class Drivers*)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉平台和编解码器类驱动程序（在[*第5章*](B10985_05_ePub_AM.xhtml#_idTextAnchor124)*,* *ALSA SoC框架-利用编解码器和平台类驱动程序*中讨论）
- en: Linux kernel v4.19.X sources, available at [https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核v4.19.X源代码，可在[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)上找到
- en: Introduction to machine class drivers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器类驱动程序介绍
- en: Codec and platform drivers cannot work alone. Machine drivers are responsible
    for binding them together in order to finish audio information processing. The
    machine driver class acts as the glue that describes and ties the other component
    drivers together to form an ALSA sound card device. It manages any machine-specific
    controls and machine-level audio events (such as turning on an amp at the start
    of playback). The machine drivers describe and bind the CPU `struct snd_soc_dai_link`
    structure and instantiates the sound card, `struct snd_soc_card`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编解码器和平台驱动程序不能单独工作。机器驱动程序负责将它们绑定在一起，以完成音频信息处理。机器驱动程序类充当胶水，描述和绑定其他组件驱动程序以形成ALSA声卡设备。它管理任何特定于机器的控件和机器级音频事件（例如在播放开始时打开放大器）。机器驱动程序描述并绑定CPU
    `struct snd_soc_dai_link`结构，并实例化声卡`struct snd_soc_card`。
- en: 'Platform and codec drivers are generally reusable, but machine drivers are
    not because they have specific hardware features that are non-reusable most of
    time. The so-called hardware characteristics refer to the link between DAIs; opening
    the amplifier through a GPIO; detecting the plug-in through a GPIO; using a clock
    such as MCLK/External OSC as the reference clock source of I2; the codec module,
    and so on. In general, machine driver responsibilities include the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 平台和编解码器驱动程序通常是可重用的，但机器驱动程序通常不是，因为它们具有大多数情况下不可重用的特定硬件特性。所谓的硬件特性指的是DAI之间的链接；通过GPIO打开放大器；通过GPIO检测插入；使用时钟如MCLK/外部OSC作为I2的参考时钟源；编解码器模块等。一般来说，机器驱动程序的责任包括以下内容：
- en: Populating the `struct snd_soc_dai_link` structure with appropriate CPU and
    codec DAIs
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用适当的CPU和编解码器DAI填充`struct snd_soc_dai_link`结构
- en: Physical codec clock settings (if any) and codec initialization master/slave
    configurations (if any)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理编解码器时钟设置（如果有）和编解码器初始化主/从配置（如果有）
- en: Defining DAPM widgets to route through the physical codec internals and complete
    the DAPM path as needed
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义DAPM小部件以通过物理编解码器内部进行路由，并根据需要完成DAPM路径
- en: Propagating the runtime sampling frequency to the individual codec drivers as
    needed
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要将运行时采样频率传播到各个编解码器驱动程序
- en: 'To put it together, we have the following flow:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们有以下流程：
- en: The codec driver registers a component driver, a DAI driver, and their operation
    functions.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编解码器驱动程序注册了一个组件驱动程序、一个DAI驱动程序以及它们的操作函数。
- en: The platform driver registers a component driver, the PCM driver, the CPU DAI
    driver, and their operation functions and sets playback and capture operations
    as applicable.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平台驱动程序注册了一个组件驱动程序、PCM驱动程序、CPU DAI驱动程序以及它们的操作函数，并设置适用的播放和捕获操作。
- en: The machine layer creates the DAI link between the codec and CPU and registers
    the sound card and PCM devices.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 机器层在编解码器和CPU之间创建DAI链路，并注册声卡和PCM设备。
- en: Now that we have seen the development flow of a machine class driver, let's
    start with the first step, which consists of populating the DAI link.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了机器类驱动程序的开发流程，让我们从第一步开始，即填充DAI链路。
- en: The DAI link
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DAI链路
- en: 'A DAI link is the logical representation of the link between the CPU and the
    codec DAIs. It is represented from within the kernel using `struct snd_soc_dai_link`,
    defined as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: DAI链路是CPU和编解码器DAI之间的逻辑表示。它在内核中使用`struct snd_soc_dai_link`表示，定义如下：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Important note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: The full `snd_soc_dai_link` data structure definition can be found at [https://elixir.bootlin.com/linux/v4.19/source/include/sound/soc.h#L880](https://elixir.bootlin.com/linux/v4.19/source/include/sound/soc.h#L880).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `snd_soc_dai_link` 数据结构定义可以在 [https://elixir.bootlin.com/linux/v4.19/source/include/sound/soc.h#L880](https://elixir.bootlin.com/linux/v4.19/source/include/sound/soc.h#L880)
    找到。
- en: 'This link is set up from within the machine driver. It should specify the `cpu_dai`,
    the `codec_dai`, and the platform that is used. Once set up, DAI links are fed
    to `struct snd_soc_card`, which represents a sound card. The following list describes
    the elements in the structure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此链接是在机器驱动程序中设置的。它应该指定 `cpu_dai`、`codec_dai` 和使用的平台。设置完成后，DAI 链接将被馈送到 `struct
    snd_soc_card`，它表示一个声卡。以下列表描述了结构中的元素：
- en: '`name`: This is chosen arbitrarily. It can be anything.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这是任意选择的。可以是任何东西。'
- en: '`codec_dai_name`: This must match the `snd_soc_dai_driver.name` field from
    within the codec chip driver. Codecs may have one or more DAIs. Refer to the codec
    driver to identify the DAI names.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`codec_dai_name`：这必须与编解码器芯片驱动程序中的 `snd_soc_dai_driver.name` 字段匹配。编解码器可能有一个或多个
    DAIs。请参考编解码器驱动程序以识别 DAI 名称。'
- en: '`cpu_dai_name`: This must match the `snd_soc_dai_driver.name` field from within
    the CPU DAI driver.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpu_dai_name`：这必须与 CPU DAI 驱动程序中的 `snd_soc_dai_driver.name` 字段匹配。'
- en: '`stream_name`: This is the stream name of this link.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream_name`：这是此链接的流名称。'
- en: '`init`: This is the DAI link initialization callback. It is typically used
    to add DAI link-specific widgets or other types of one-time settings.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`：这是 DAI 链接初始化回调。通常用于添加 DAI 链接特定的小部件或其他类型的一次性设置。'
- en: '`dai_fmt`: This should be set with the supported format and clock configuration,
    which should be coherent for both CPU and CODEC DAI drivers. Possible bit flags
    for this field are introduced later.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dai_fmt`：这应该设置为支持的格式和时钟配置，对于 CPU 和 CODEC DAI 驱动程序应该是一致的。此字段的可能位标志稍后介绍。'
- en: '`ops`: This field is of the `struct snd_soc_ops` type. It should be set with
    machine-level PCM operations of the DAI link: `startup`, `hw_params`, `prepare`,
    `trigger`, `hw_free`, `shutdown`. This field is described in detail later.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ops`：此字段是 `struct snd_soc_ops` 类型。它应该设置为 DAI 链接的机器级 PCM 操作：`startup`、`hw_params`、`prepare`、`trigger`、`hw_free`、`shutdown`。此字段稍后将详细描述。'
- en: '`codec_name`: If set, this should be the name of the codec driver, such as
    `platform_driver.driver.name` or `i2c_driver.driver.name`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`codec_name`：如果设置，这应该是编解码器驱动程序的名称，例如 `platform_driver.driver.name` 或 `i2c_driver.driver.name`。'
- en: '`codec_of_node`: The device tree node associated with the codec.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`codec_of_node`：与编解码器关联的设备树节点。'
- en: '`cpu_name`: If set, this should be the name of the CPU DAI driver CPU.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpu_name`：如果设置，这应该是 CPU DAI 驱动程序 CPU 的名称。'
- en: '`cpu_of_node`: This is the device tree node associated with the CPU DAI.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpu_of_node`：这是与 CPU DAI 关联的设备树节点。'
- en: '`platform_name` or `platform_of_node`: This is the name or DT node reference
    to the platform node, which provides DMA capabilities.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`platform_name` 或 `platform_of_node`：这是提供 DMA 能力的平台节点的名称或 DT 节点引用。'
- en: '`playback_only` and `capture_only` are to be used in case of unidirectional
    links, such as SPDIF. If this is an output only link (playback only), then `playback_only`
    and `capture_only` must be set to `true` and `false` respectively. With an input-only
    link, the opposite values should be used.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playback_only` 和 `capture_only` 用于单向链接，例如 SPDIF。如果这是一个仅输出的链接（仅播放），那么必须将 `playback_only`
    和 `capture_only` 分别设置为 `true` 和 `false`。对于仅输入的链接，应使用相反的值。'
- en: 'In most cases, `.cpu_of_node` and `.platform_of_node` are the same, since the
    CPU DAI driver and the DMA PCM driver are implemented by the same device. That
    being said, you must specify the link''s codec either by name or by `of_node`,
    but not both. You must do the same for the CPU and platform. However, at least
    one of the CPU DAI name or the CPU device name/node must be specified. This could
    be summarized as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`.cpu_of_node` 和 `.platform_of_node` 是相同的，因为 CPU DAI 驱动程序和 DMA PCM 驱动程序是由同一设备实现的。也就是说，您必须通过名称或
    `of_node` 指定链接的编解码器，但不能同时使用两者。对于 CPU 和平台，您必须做同样的事情。但是，至少必须指定 CPU DAI 名称或 CPU 设备名称/节点中的一个。这可以总结如下：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There is a key point it is worth noting here. How do we reference the platform
    or CPU node in the DAI link? We will answer this question later. Let''s first
    consider the following two device nodes. The first one (`ssi1`) is the SSI `cpu-dai`
    node for the i.mx6 SoC. The second node (`sgtl5000`) represents the sgtl5000 codec
    chip:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个值得注意的关键点。我们如何在 DAI 链接中引用平台或 CPU 节点？我们将在后面回答这个问题。首先考虑以下两个设备节点。第一个（`ssi1`）是
    i.mx6 SoC 的 SSI `cpu-dai` 节点。第二个节点（`sgtl5000`）代表 sgtl5000 编解码器芯片：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Important note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In the SSI node, you can see the `dma-names = "rx", "tx";` property, which is
    the expected DMA channel names requested by the pcmdmaengine framework. This may
    also be an indication that the CPU DAI and platform PCM are represented by the
    same node.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SSI 节点中，您可以看到 `dma-names = "rx", "tx";` 属性，这是 pcmdmaengine 框架请求的预期 DMA 通道名称。这也可能表明
    CPU DAI 和平台 PCM 由同一节点表示。
- en: 'We will consider a system where an i.MX6 SoC is connected to an sgtl5000 audio
    codec. It is common for machine drivers to grab either CPU or CODEC device tree
    nodes by referencing those nodes (their `phandle` actually) as its properties.
    This way, you can just use one of the `OF` helpers (such as `of_parse_phandle()`)
    to grab a reference on these nodes. The following is an example of a machine node
    that references both the codec and the platform by an `OF` node:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑一个系统，其中 i.MX6 SoC 连接到 sgtl5000 音频编解码器。通常，机器驱动程序会通过引用这些节点（实际上是它们的 `phandle`）作为其属性来获取
    CPU 或 CODEC 设备树节点。这样，您可以使用 `OF` 助手之一（例如 `of_parse_phandle()`）来获取对这些节点的引用。以下是一个通过
    `OF` 节点引用编解码器和平台的机器节点的示例：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding machine node, the codec and CPUE are passed by reference (their
    `phandle`) via the `audio-codec` and `ssi-controller` properties. These property
    names are not standardized as long as the machine driver is written by you (this
    is not true if you use the `simple-card` machine driver, for example, which expects
    some predefined names). In the machine driver, you''ll see something like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的机器节点中，编解码器和CPUE通过`audio-codec`和`ssi-controller`属性（它们的`phandle`）传递引用。只要机器驱动程序是由您编写的（如果您使用`simple-card`机器驱动程序，这就不成立，因为它期望一些预定义的名称），这些属性名称就不是标准化的。在机器驱动程序中，你会看到类似这样的东西：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding excerpt used `of_parse_phandle()` to obtain node references. This
    is an excerpt from the `imx_sgtl5000` machine, which is `sound/soc/fsl/imx-sgtl5000.c`
    in the kernel sources. Now that we are familiar with the way the DAI link should
    be handled, we can proceed to audio routing from within the machine driver in
    order to define the path the audio data should follow.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的摘录使用`of_parse_phandle()`来获取节点引用。这是来自内核源码中的`imx_sgtl5000`机器的摘录，它在`sound/soc/fsl/imx-sgtl5000.c`中。现在我们已经熟悉了应该如何处理DAI链路，我们可以继续从机器驱动程序中进行音频路由，以定义音频数据应该遵循的路径。
- en: Machine routing consideration
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 机器路由考虑
- en: The machine driver can alter (or should I say append) the routes defined from
    within the codec. It has the last word on which codec pins must be used, for example.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 机器驱动程序可以更改（或者说追加）从编解码器内部定义的路由。它对应该使用哪些编解码器引脚有最后的决定权，例如。
- en: Codec pins
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编解码器引脚
- en: Codec pins are meant to be connected to the board connectors. The available
    codec pins are defined in the codec driver using the `SND_SOC_DAPM_INPUT` and
    `SND_SOC_DAPM_OUTPUT` macros. These macros can be searched with the `grep` command
    in the codec driver in order to find the available PIN.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 编解码器引脚应该连接到板连接器。可用的编解码器引脚在编解码器驱动程序中使用`SND_SOC_DAPM_INPUT`和`SND_SOC_DAPM_OUTPUT`宏来定义。这些宏可以在编解码器驱动程序中使用`grep`命令进行搜索，以找到可用的引脚。
- en: 'For example, the `sgtl5000` codec driver defines the following output and input:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`sgtl5000`编解码器驱动程序定义了以下输出和输入：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the next sections, we will see how those pins are connected to the board.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到这些引脚是如何连接到板上的。
- en: Board connectors
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 板连接器
- en: 'The board connectors are defined in the machine driver in the `struct snd_soc_dapm_widget`
    part of the registered `struct snd_soc_card`. Most of the time, these board connectors
    are virtual. They are just logical stickers that are connected with codec pins
    (which are real this time). The following lists the connectors defined by the
    `imx-sgtl5000` machine driver, `sound/soc/fsl/imx-sgtl5000.c` (whose documentation
    is `Documentation/devicetree/bindings/sound/imx-audio- sgtl5000.txt`), which has
    been given as an example so far:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 板连接器在已注册的`struct snd_soc_card`的机器驱动程序中定义在`struct snd_soc_dapm_widget`部分。大多数情况下，这些板连接器是虚拟的。它们只是逻辑标签，与编解码器引脚连接（这次是真实的）。以下列出了`imx-sgtl5000`机器驱动程序中定义的连接器，`sound/soc/fsl/imx-sgtl5000.c`（其文档是`Documentation/devicetree/bindings/sound/imx-audio-sgtl5000.txt`），迄今为止已经给出了一个例子。
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The next section will connect this connector to the codec pins.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将把这个连接器连接到编解码器引脚。
- en: Machine routing
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器路由
- en: The final machine routing can be either static (that is, populated from within
    the machine driver itself) or populated from within the device tree. Moreover,
    the machine driver can optionally extend the codec power map and become an audio
    power map of the audio subsystem by connecting to the supply widget that has been
    defined in the codec driver with either `SND_SOC_DAPM_SUPPLY` or `SND_SOC_DAPM_REGULATOR_SUPPLY`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的机器路由可以是静态的（即从机器驱动程序内部填充）或者从设备树内部填充。此外，机器驱动程序可以选择扩展编解码器电源映射，并通过连接到已在编解码器驱动程序中定义的供应小部件，使用`SND_SOC_DAPM_SUPPLY`或`SND_SOC_DAPM_REGULATOR_SUPPLY`成为音频子系统的音频电源映射。
- en: Device tree routing
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备树路由
- en: 'Let''s take the node of our machine as an example, which connects an i.MX6
    SoC to an sgtl5000 codec (this excerpt can be found in the machine documentation):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以我们的机器节点为例，它连接了一个i.MX6 SoC和一个sgtl5000编解码器（这个摘录可以在机器文档中找到）。
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Routing from the device tree expects the audio map to be given in a certain
    format. That is, entries are parsed as pairs of strings, the first being the connection''s
    sink, the second being the connection''s source. Most of the time, these connections
    are materialized as codec pins and board connector mappings. Valid names for sources
    and sinks depend on the hardware binding, which is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从设备树中的路由期望音频映射以特定格式给出。也就是说，条目被解析为字符串对，第一个是连接的接收端，第二个是连接的源端。大多数情况下，这些连接被实现为编解码器引脚和板连接器映射。源和接收端的有效名称取决于硬件绑定，如下所示：
- en: '**The codec**: This should have defined the pins whose names are used here.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编解码器**：这里应该已经定义了这里使用的引脚的名称。'
- en: '**The machine**: This should have defined the connectors or jacks whose names
    are used here.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器**：这里应该已经定义了这里使用的连接器或插孔的名称。'
- en: In the preceding excerpt, what do you notice there? We can see `MIC_IN`, `HP_OUT`,
    and `"Mic Bias"`, which are codec pins (coming from the codec driver), and `"Mic
    Jack"` and `"Headphone Jack"`, which have been defined in the machine driver as
    board connectors.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的摘录中，你注意到了什么？我们可以看到`MIC_IN`、`HP_OUT`和`"Mic Bias"`，这些是编解码器引脚（来自编解码器驱动程序），以及`"Mic
    Jack"`和`"Headphone Jack"`，这些在机器驱动程序中被定义为板连接器。
- en: 'In order to use the route defined in the DT, the machine driver must call `snd_soc_of_parse_audio_routing()`,
    which has the following prototype:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用在设备树中定义的路由，机器驱动程序必须调用`snd_soc_of_parse_audio_routing()`，它具有以下原型：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding prototype, `card` represents the sound card for which the routes
    are parsed, and `prop` is the name of the property that contains the routes in
    the device tree node. This function returns `0` on success and a negative error
    code on error.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的原型中，`card`代表解析路由的声卡，`prop`是包含设备树节点中路由的属性的名称。此函数在成功时返回`0`，在错误时返回负错误代码。
- en: Static routing
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态路由
- en: 'Static routing consists of defining a DAPM route map from the machine driver
    and assigning it to the sound card directly as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 静态路由包括从机器驱动程序定义DAPM路由映射，并直接分配给声卡，如下所示：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding snippet is an excerpt from `sound/soc/rockchip/rockchip_rt5645.c`.
    By using it this way, it is not necessary to use `snd_soc_of_parse_audio_routing()`.
    However, a con of using this method is that it is not possible to change the route
    without recompiling the kernel. Next, we will be looking at clocking and formatting
    considerations.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述片段摘自`sound/soc/rockchip/rockchip_rt5645.c`。通过这种方式使用它，就不需要使用`snd_soc_of_parse_audio_routing()`。然而，使用这种方法的一个缺点是，无法在不重新编译内核的情况下更改路由。接下来，我们将看一下时钟和格式考虑。
- en: Clocking and formatting considerations
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时钟和格式考虑
- en: 'Before delving deeper into this section, let''s spend some time on the `snd_soc_dai_link->ops`
    field. This field is of type `struct snd_soc_ops`, defined as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究本节之前，让我们花一些时间在`snd_soc_dai_link->ops`字段上。该字段是`struct snd_soc_ops`类型，定义如下：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These callback fields in this structure should remind you of those defined in
    the `snd_soc_dai_driver->ops` field, which is of type `struct snd_soc_dai_ops`.
    From within the DAI link, these callbacks represent the machine-level PCM operations
    of the DAI link, while in `struct snd_soc_dai_driver`, they are either codec-DAI-specific
    or CPU-DAI-specific.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构中的回调字段应该让你想起了`snd_soc_dai_driver->ops`字段中定义的那些，它是`struct snd_soc_dai_ops`类型。在DAI链中，这些回调表示DAI链的机器级PCM操作，而在`struct
    snd_soc_dai_driver`中，它们要么是特定于编解码器DAI的，要么是特定于CPU-DAI的。
- en: '`startup()` is invoked by ALSA when a PCM substream is opened (when someone
    has opened the capture/playback device), while `hw_params()` is called when setting
    up the audio stream. The machine driver may configure DAI link data format from
    within both of these callbacks. `hw_params()` offers the advantage of receiving
    stream parameters (*channel count*, *format*, *sample rate*, and so forth).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`startup()`在PCM子流打开时（当有人打开捕获/播放设备时）由ALSA调用，而`hw_params()`在设置音频流时调用。机器驱动程序可以在这两个回调中从DAI链配置DAI链数据格式。`hw_params()`具有接收流参数（*通道数*、*格式*、*采样率*等）的优势。'
- en: 'The data format configuration should be consistent between the CPU DAI and
    the codec. The ASoC core provides helper functions to change those configurations.
    They are as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 数据格式配置应该在CPU DAI和编解码器之间保持一致。ASoC核心提供了帮助函数来更改这些配置。它们如下：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding helper list, `snd_soc_dai_set_fmt` sets the DAI format for
    things such as the clock master/slave relationship, audio format, and signal inversion;
    `snd_soc_dai_set_pll` configures the clock PLL; `snd_soc_dai_set_sysclk` configures
    the clock source; and `snd_soc_dai_set_clkdiv` configures the clock divider. Each
    of these helpers will call the appropriate callback in the underlying DAI's driver
    ops. For example, calling `snd_soc_dai_set_fmt()` with the CPU DAI will invoke
    this CPU DAI's `dai->driver->ops->set_fmt` callback.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述帮助列表中，`snd_soc_dai_set_fmt`设置了DAI格式，例如时钟主/从关系、音频格式和信号反转；`snd_soc_dai_set_pll`配置了时钟PLL；`snd_soc_dai_set_sysclk`配置了时钟源；`snd_soc_dai_set_clkdiv`配置了时钟分频器。这些帮助程序将调用底层DAI驱动程序ops中的适当回调。例如，使用CPU
    DAI调用`snd_soc_dai_set_fmt()`将调用此CPU DAI的`dai->driver->ops->set_fmt`回调。
- en: 'The following is the actual list of formats/flags that can be assigned either
    to DAIs or the `dai_link.format` field:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以分配给DAI或`dai_link.format`字段的实际格式/标志列表：
- en: '`snd_soc_dai_set_fmt()`:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snd_soc_dai_set_fmt()`：'
- en: 'A) `SND_SOC_DAIFMT_CBM_CFM`: The CPU is the slave for the bit clock and frame
    sync. This also means the codec is the master for both.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 'A) `SND_SOC_DAIFMT_CBM_CFM`: CPU是位时钟和帧同步的从设备。这也意味着编解码器是两者的主机。'
- en: b) `SND_SOC_DAIFMT_CBS_CFS`. The CPU is the master for the bit clock and frame
    sync. This also means the codec is the slave for both.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: b) `SND_SOC_DAIFMT_CBS_CFS`。CPU是位时钟和帧同步的主机。这也意味着编解码器对两者都是从设备。
- en: c) `SND_SOC_DAIFMT_CBM_CFS`. The CPU is the slave for the bit clock and the
    master for frame sync. This also means the codec is the master for the former
    and the slave for the latter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: c) `SND_SOC_DAIFMT_CBM_CFS`。CPU是位时钟的从设备，帧同步的主机。这也意味着编解码器是前者的主机，后者的从设备。
- en: 'B) `SND_SOC_DAIFMT_DSP_A`: Frame syncing is 1 bit-clock wide, 1-bit delay.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 'B) `SND_SOC_DAIFMT_DSP_A`: 帧同步为1位时钟宽，1位延迟。'
- en: 'b) `SND_SOC_DAIFMT_DSP_B`: Frame syncing is 1 bit-clock wide, 0-bit delay.
    This format can be used for the TDM protocol.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 'b) `SND_SOC_DAIFMT_DSP_B`: 帧同步为1位时钟宽，0位延迟。此格式可用于TDM协议。'
- en: 'c) `SND_SOC_DAIFMT_I2S`: Frame syncing is 1 audio word wide, 1-bit delay, I2S
    mode.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 'c) `SND_SOC_DAIFMT_I2S`: 帧同步为1个音频字宽，1位延迟，I2S模式。'
- en: 'd) `SND_SOC_DAIFMT_RIGHT_J`: Right justified mode.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 'd) `SND_SOC_DAIFMT_RIGHT_J`: 右对齐模式。'
- en: 'e) `SND_SOC_DAIFMT_LEFT_J`: Left justified mode.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 'e) `SND_SOC_DAIFMT_LEFT_J`: 左对齐模式。'
- en: 'f) `SND_SOC_DAIFMT_DSP_A`: Frame syncing is 1 bit-clock wide,1-bit delay.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 'f) `SND_SOC_DAIFMT_DSP_A`: 帧同步为1位时钟宽，1位延迟。'
- en: 'g) `SND_SOC_DAIFMT_AC97`: AC97 mode.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'g) `SND_SOC_DAIFMT_AC97`: AC97模式。'
- en: 'h) `SND_SOC_DAIFMT_PDM`: Pulse-density modulation.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 'h) `SND_SOC_DAIFMT_PDM`: 脉冲密度调制。'
- en: 'i) `SND_SOC_DAIFMT_DSP_B`: Frame sync is 1 bit-clock wide, 1-bit delay.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'i) `SND_SOC_DAIFMT_DSP_B`: 帧同步为1位时钟宽，1位延迟。'
- en: 'C) `SND_SOC_DAIFMT_NB_NF`: Normal bit clock, normal frame sync. The CPU transmitter
    shifts data out on the falling edge of the bit clock, the receiver samples data
    on the rising edge. The CPU frame sync generator starts the frame on the rising
    edge of the frame sync. This parameter is recommended for I2S on the CPU side.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 'C) `SND_SOC_DAIFMT_NB_NF`: 正常位时钟，正常帧同步。CPU发射器在位时钟的下降沿上移出数据，接收器在上升沿上采样数据。CPU帧同步发生器在帧同步的上升沿上开始帧。建议在CPU端使用此参数进行I2S。'
- en: 'b) `SND_SOC_DAIFMT_NB_IF`: Normal bit clock, inverted frame sync. The CPU transmitter
    shifts data out on the falling edge of the bit clock, and the receiver samples
    data on the rising edge. The CPU frame sync generator starts the frame on the
    falling edge of the frame sync.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 'b) `SND_SOC_DAIFMT_NB_IF`: 正常位时钟，反转帧同步。CPU发射器在位时钟的下降沿上移出数据，接收器在上升沿上采样数据。CPU帧同步发生器在帧同步的下降沿上开始帧。'
- en: 'c) `SND_SOC_DAIFMT_IB_NF`: Inverted bit clock, normal frame sync. The CPU transmitter
    shifts data out on the rising edge of the bit clock, and the receiver samples
    data on the falling edge. The CPU frame sync generator starts the frame on the
    rising edge of the frame sync.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: c) `SND_SOC_DAIFMT_IB_NF`：反转位时钟，正常帧同步。CPU发射器在位时钟的上升沿上移出数据，接收器在下降沿上采样数据。CPU帧同步生成器在帧同步的上升沿上启动帧。
- en: 'd) `SND_SOC_DAIFMT_IB_IF`: Inverted bit clock, inverted frame sync. The CPU
    transmitter shifts data out on the rising edge of the bit clock, and the receiver
    samples data on the falling edge. The CPU frame sync generator starts the frame
    on the falling edge of the frame sync. This configuration can be used for PCM
    mode (such as Bluetooth or modem-based audio chips).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: d) `SND_SOC_DAIFMT_IB_IF`：反转位时钟，反转帧同步。CPU发射器在位时钟的上升沿上移出数据，接收器在下降沿上采样数据。CPU帧同步生成器在帧同步的下降沿上启动帧。此配置可用于PCM模式（例如蓝牙或基于调制解调器的音频芯片）。
- en: '`snd_soc_dai_set_sysclk()`. The following are the direction parameters letting
    ALSA know which clock is used:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snd_soc_dai_set_sysclk()`。以下是方向参数，让ALSA知道使用的时钟：'
- en: 'a) `SND_SOC_CLOCK_IN`: This means an internal clock is used for sysclock.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: a) `SND_SOC_CLOCK_IN`：这意味着sysclock使用内部时钟。
- en: 'b) `SND_SOC_CLOCK_OUT`: This means an external clock is used for sysclock.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: b) `SND_SOC_CLOCK_OUT`：这意味着sysclock使用外部时钟。
- en: '`snd_soc_dai_set_clkdiv()`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`snd_soc_dai_set_clkdiv()`。'
- en: 'The preceding flags are the possible values that can be set in the `dai_link->dai_fmt`
    field or assigned to either codec or CPU DAIs from within the machine driver.
    The following is a typical `hw_param()` implementation:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dai_link->dai_fmt`字段中设置或分配给机器驱动程序的编解码器或CPU DAIs的可能值如上所示。以下是典型的`hw_param()`实现：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding implementation of the `foo_hw_params()` function, we can see
    how both codec and platform DAIs are configured, with both format and clock settings.
    Now we come to the last step of machine driver implementation, which consists
    of registering the audio sound card, which is the device through which audio operations
    on the system are performed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`foo_hw_params()`函数的上述实现中，我们可以看到编解码器和平台DAI是如何配置的，包括格式和时钟设置。现在我们来到机器驱动程序实现的最后一步，即注册音频声卡，这是系统上执行音频操作的设备。
- en: Sound card registration
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声卡注册
- en: 'A sound card is represented in the kernel as an instance of `struct snd_soc_card`,
    defined as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 声卡在内核中表示为`struct snd_soc_card`的实例，定义如下：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For the sake of readability, only the relevant field has been listed, and the
    full definition can be found at [https://elixir.bootlin.com/linux/v4.19/source/include/sound/soc.h#L1010](https://elixir.bootlin.com/linux/v4.19/source/include/sound/soc.h#L1010).
    That being said, the following list describes the fields we have listed:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，仅列出了相关字段，完整定义可以在[https://elixir.bootlin.com/linux/v4.19/source/include/sound/soc.h#L1010](https://elixir.bootlin.com/linux/v4.19/source/include/sound/soc.h#L1010)找到。也就是说，以下列表描述了我们列出的字段：
- en: '`name` is the name of the sound card.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`是声卡的名称。'
- en: '`owner` is the module owner for this sound card.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`owner`是此声卡的模块所有者。'
- en: '`dai_link` is the array of DAI links this sound card is made of, and `num_links`
    specifies the number of entries in the array.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dai_link`是构成此声卡的DAI链接数组，`num_links`指定数组中的条目数。'
- en: '`controls` is an array that contains the controls that are statically defined
    and set by the machine driver, and `num_controls` specifies the number of entries
    in the array.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controls`是一个包含由机器驱动程序静态定义和设置的控件的数组，`num_controls`指定数组中的条目数。'
- en: '`dapm_widgets` is an array that contains the DAPM widgets that are statically
    defined and set by the machine driver, and `num_dapm_widgets` specifies the number
    of entries in the array.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dapm_widgets`是一个包含由机器驱动程序静态定义和设置的DAPM小部件的数组，`num_dapm_widgets`指定数组中的条目数。'
- en: '`damp_routes` is an array that contains the DAPM routes that are statically
    defined and set by the machine driver, and `num_dapm_routes` specifies the number
    of entries in the array.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`damp_routes`是一个包含由机器驱动程序静态定义和设置的DAPM路由的数组，`num_dapm_routes`指定数组中的条目数。'
- en: '`of_dapm_widgets` represents the DAPM widgets fed from the DT (via `snd_soc_of_parse_audio_simple_widgets()`),
    and `num_of_dapm_widgets` is the actual number of widget entries.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of_dapm_widgets`表示从DT（通过`snd_soc_of_parse_audio_simple_widgets()`）提供的DAPM小部件，`num_of_dapm_widgets`是小部件条目的实际数量。'
- en: '`of_dapm_routes` represents the DAPM routes fed from the DT (via `snd_soc_of_parse_audio_routing()`),
    and `num_of_dapm_routes` is the actual number of route entries.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of_dapm_routes`表示从DT（通过`snd_soc_of_parse_audio_routing()`）提供的DAPM路由，`num_of_dapm_routes`是路由条目的实际数量。'
- en: 'After the sound card structure has been set up, it can be registered by the
    machine using the `devm_snd_soc_register_card()` method, whose prototype is as
    follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完声卡结构之后，可以通过机器使用`devm_snd_soc_register_card()`方法进行注册，其原型如下：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding prototype, `dev` represents the underlying device used to manage
    the card, and `card` is the actual sound card data structure that was set up previously.
    This function returns `0` on success. However, when this function is called, every
    component driver and DAI driver will be probed. As a result, the `component_driver->probe()`
    and `dai_driver->probe()` methods will be invoked for both the CPU and CODEC.
    Additionally, a new PCM device will be created for each successfully probed DAI
    link.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述原型中，`dev`表示用于管理卡的基础设备，`card`是先前设置的实际声卡数据结构。此函数在成功时返回`0`。但是，当调用此函数时，将会探测每个组件驱动程序和DAI驱动程序。因此，将为每个成功探测到的DAI链接创建一个新的PCM设备。
- en: 'The following excerpts (from a Rockchip machine ASoC driver for boards using
    a MAX90809 CODEC, implemented in `sound/soc/rockchip/rockchip_max98090.c` in kernel
    sources) will show the entire sound card creation, from widgets to routes, through
    DAI link configurations. Let''s start by defining a widget and control for this
    machine, as well as the callback, which is used to configure the CPU and codec
    DAIs:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下摘录（来自Rockchip机器ASoC驱动程序，用于使用MAX90809 CODEC的板子，实现在内核源码中的`sound/soc/rockchip/rockchip_max98090.c`中）将展示整个声卡的创建过程，从小部件到路由，再到DAI链接配置。让我们首先定义这个机器的小部件和控件，以及用于配置CPU和编解码器DAI的回调函数：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding excerpt, `rk_aif1_hw_params` can be seen in the original code
    implementation file. Now comes the data structure, which is used to build the
    sound card, defined as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的摘录中，可以看到原始代码实现文件中的`rk_aif1_hw_params`。现在是用于构建声卡的数据结构，定义如下：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This sound card is finally created in the driver `probe` method as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声卡最终是在驱动程序的`probe`方法中创建的：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once again, the three preceding code blocks are excerpts from `sound/soc/rockchip/rockchip_max98090.c`.
    So far, we have learned the main purpose of machine drivers, which is to bind
    Codec and CPU drivers together and to define the audio path. That being said,
    there are cases when we might need even less code. Such cases concern boards where
    neither the CPU nor the Codecs need special hacks before being bound together.
    In this case, the ASoC framework provides the **simple-card machine driver**,
    introduced in the next section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，前面三个代码块都是从`sound/soc/rockchip/rockchip_max98090.c`中摘录的。到目前为止，我们已经了解了机器驱动程序的主要目的，即将Codec和CPU驱动程序绑定在一起，并定义音频路径。也就是说，有时我们可能需要更少的代码。这些情况涉及到既不需要特殊黑客的CPU也不需要特殊黑客的板子。在这种情况下，ASoC框架提供了**simple-card机器驱动程序**，在下一节中介绍。
- en: Leveraging the simple-card machine driver
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用simple-card机器驱动程序
- en: 'There are cases when your board does not require any hacks from the Codec nor
    the CPU DAI. The ASoC core provides the `simple-audio` machine driver, which can
    be used to describe a whole sound card from the DT. The following is an excerpt
    of such a node:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您的板子不需要来自Codec或CPU DAI的任何黑客。ASoC核心提供了`simple-audio`机器驱动程序，可以用来从DT描述整个声卡。以下是这样一个节点的摘录：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is fully documented in `Documentation/devicetree/bindings/sound/simple-card.txt`.
    In the preceding excerpt, we can see machine widgets and route maps being specified,
    as well as both the codec and the CPU nodes, which are referenced. Now that we
    are familiar with the simple-card machine driver, we can leverage it and try as
    much as possible not to write our own machine driver. Having said that, there
    are situations where the codec device can't be dissociated, and this changes the
    way the machine should be written. Such audio devices are called codec-less sound
    cards, and we discuss them in the next section.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全记录在`Documentation/devicetree/bindings/sound/simple-card.txt`中。在上面的摘录中，我们可以看到指定了机器小部件和路由映射，以及引用的编解码器和CPU节点。现在我们熟悉了simple-card机器驱动程序，我们可以利用它，并尽可能地不编写自己的机器驱动程序。话虽如此，有些情况下编解码器设备无法分离，这改变了机器应该编写的方式。这样的音频设备称为无编解码器声卡，在下一节中我们将讨论它们。
- en: Codec-less sound cards
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无编解码器声卡
- en: There may be situations where digital audio data is sampled from an external
    system, such as when using the SPDIF interface, and the data is therefore preformatted.
    In this case, the sound card registration is the same, but the ASoC core needs
    to be aware of this particular case.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现从外部系统采样数字音频数据的情况，例如使用SPDIF接口时，数据因此被预格式化。在这种情况下，声卡注册是相同的，但ASoC核心需要意识到这种特殊情况。
- en: 'With the output, the DAI link object''s `.capture_only` field should be `false`,
    while `.playback_only` should be `true`. The reverse should be done with the input.
    Additionally, the machine driver must set the DAI link''s `codec_dai_name` and
    `codec_name` to `"snd-soc-dummy-dai"` and `"snd-soc-dummy"` respectively. This
    is, for example, the case for the `imx-spdif` machine driver (`sound/soc/fsl/imx-spdif.c`),
    which contains the following excerpt:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输出，DAI链接对象的`.capture_only`字段应该是`false`，而`.playback_only`应该是`true`。输入应该做相反的操作。此外，机器驱动程序必须将DAI链接的`codec_dai_name`和`codec_name`设置为`"snd-soc-dummy-dai"`和`"snd-soc-dummy"`。例如，这是`imx-spdif`机器驱动程序（`sound/soc/fsl/imx-spdif.c`）的情况，其中包含以下摘录：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can find the binding documentation of this driver in `Documentation/devicetree/bindings/sound/imx-audio-spdif.txt`.
    At the end of machine class driver study, we are done with the whole ASoC class
    driver development. In this machine class driver, in addition to bound CPU and
    Codec in the code, as well as providing a setup callback, we have seen how to
    avoid writing code by using the simple-card machine driver and implementing the
    rest in the device tree.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`Documentation/devicetree/bindings/sound/imx-audio-spdif.txt`中找到此驱动程序的绑定文档。在机器类驱动程序研究结束时，我们已经完成了整个ASoC类驱动程序的开发。在这个机器类驱动程序中，除了在代码中绑定CPU和Codec以及提供设置回调之外，我们还看到了如何通过使用simple-card机器驱动程序并在设备树中实现其余部分来避免编写代码。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have gone through the architecture of ASoC machine class
    drivers, which represents the last element in this ASoC series. We have learned
    how to bind platform and subdevice drivers, but also how to define routes for
    audio data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了ASoC机器类驱动程序的架构，这代表了ASoC系列中的最后一个元素。我们已经学会了如何绑定平台和子设备驱动程序，以及如何为音频数据定义路由。
- en: In the next chapter, we will cover another Linux media subsystem, that is, V4L2,
    which is used to deal with video devices.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍另一个Linux媒体子系统，即V4L2，用于处理视频设备。
