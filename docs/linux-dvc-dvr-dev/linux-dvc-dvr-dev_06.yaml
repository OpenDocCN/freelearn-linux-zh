- en: The Concept of Device Tree
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备树的概念
- en: 'The **Device Tree** (**DT** ) is an easy to read hardware description file,
    with JSON like formatting style, which is a simple tree structure where devices
    are represented by nodes with their properties. Properties can be either empty
    (just the key, to describe boolean values), or key-value pairs where the value
    can contain an arbitrary byte stream. This chapter is a simple introduction to
    DT. Every kernel subsystem or framework has its own DT binding. We will talk about
    those specific bindings when we deal with concerned topics. The DT originated
    from OF, which is a standard endorsed by computer companies, and whose main purpose
    is defining interfaces for computer firmware systems. That said, one can find
    more on DT specification at [http://www.devicetree.org/](http://www.devicetree.org/)
    . Therefore, this chapter will cover the basics of DT, such as:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**设备树**（**DT**）是一个易于阅读的硬件描述文件，具有类似JSON的格式样式，是一个简单的树结构，其中设备由具有其属性的节点表示。属性可以是空的（只是键，用于描述布尔值），也可以是键值对，其中值可以包含任意字节流。本章是对DT的简单介绍。每个内核子系统或框架都有自己的DT绑定。当我们处理相关主题时，我们将讨论这些特定的绑定。DT起源于OF，这是一个由计算机公司认可的标准，其主要目的是为计算机固件系统定义接口。也就是说，可以在[http://www.devicetree.org/](http://www.devicetree.org/)找到更多关于DT规范的信息。因此，本章将涵盖DT的基础知识，例如：'
- en: Naming convention, as well as aliases and labeling
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名约定，以及别名和标签
- en: Describing data types and their APIs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述数据类型及其API
- en: Managing addressing schemes and accessing the device resources
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理寻址方案和访问设备资源
- en: Implementing OF match style and providing application-specific data
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现OF匹配样式并提供特定于应用程序的数据
- en: Device tree mechanism
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备树机制
- en: 'DT is enabled in the kernel by setting the option `CONFIG_OF` to `Y` . In order
    to pull the DT API from within your driver, you must add the following headers:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将选项`CONFIG_OF`设置为`Y`，可以在内核中启用DT。为了从驱动程序中调用DT API，必须添加以下标头：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'DT supports a few data types. Let us have a look at them with a sample node
    description:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: DT支持几种数据类型。让我们通过一个示例节点描述来看看它们：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following are some definitions of data types used in device trees:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是设备树中使用的一些数据类型的定义：
- en: Text strings are represented with double quotes. One can use commas to create
    a list of the strings.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本字符串用双引号表示。可以使用逗号创建字符串列表。
- en: Cells are 32-bit unsigned integers delimited by angle brackets.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元是由尖括号分隔的32位无符号整数。
- en: Boolean data is nothing but an empty property. The true or false value depends
    on the property being there or not.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔数据只是一个空属性。真或假的值取决于属性是否存在。
- en: Naming convention
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名约定
- en: 'Every node must have a name in the form `<name>[@<address>]` , where `<name>`
    is a string that can be up to 31 characters in length, and `[@<address>]` is optional,
    depending on whether the node represents an addressable device or not. `<address>`
    should be the primary address used to access the device. An example of device
    naming is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点必须具有形式为`<name>[@<address>]`的名称，其中`<name>`是一个长度最多为31个字符的字符串，`[@<address>]`是可选的，取决于节点是否表示可寻址设备。`<address>`应该是用于访问设备的主要地址。设备命名的示例如下：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Or
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 或
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: On the other hand, the `label` is optional. Labeling a node is useful only if
    the node is intended to be referenced from a property of another node. One can
    see a label as a pointer to node, as explained in the next section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，“标签”是可选的。只有当节点打算从另一个节点的属性引用时，标记节点才有用。可以将标签视为指向节点的指针，如下一节所述。
- en: Aliases, labels, and phandle
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 别名，标签和phandle
- en: 'It is very important to understand how these three elements work. They are
    frequently used in the DT. Let us take the following DT to explain how they work:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这三个元素如何工作非常重要。它们在DT中经常被使用。让我们看看以下的DT来解释它们是如何工作的：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A label is nothing but a way to tag a node, to let the node be identified by
    a unique name. In the real world, that name is converted into a unique 32-bit
    value by the DT compiler. In the preceding example, `gpio1` and `node_label` are
    both labels. Labels can then be used to refer to a node, since a label is unique
    to a node.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 标签只是一种标记节点的方式，以便让节点通过唯一名称进行标识。在现实世界中，DT编译器将该名称转换为唯一的32位值。在前面的示例中，`gpio1`和`node_label`都是标签。然后可以使用标签来引用节点，因为标签对节点是唯一的。
- en: A **pointer handle** (**phandle** ) is a 32-bit value associated with a node
    that is used to uniquely identify that node so that the node can be referenced
    from a property in another node. Labels are used to have a pointer to the node.
    By using `<&mylabel>` , you point to the node whose label is `mylabel` .
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**指针句柄**（**phandle**）是与节点关联的32位值，用于唯一标识该节点，以便可以从另一个节点的属性中引用该节点。标签用于指向节点。通过使用`<&mylabel>`，您指向其标签为`mylabel`的节点。'
- en: The use of `&` is just like in the C programming language; to obtain the address
    of an element.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`&`与C编程语言中的用法相同；用于获取元素的地址。
- en: 'In the preceding example, `&gpio1` is converted to the phandle so that it refers
    to `gpio1` node. The same goes for the following example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`&gpio1`被转换为phandle，以便它引用`gpio1`节点。对于以下示例也是如此：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In order not to walk through the whole tree to look for a node, the concept
    of aliases has been introduced. In the DT, the `aliases` node can be seen like
    a quick lookup table, an index of another node. One can use the function `find_node_by_alias()`
    to find a node given its alias. The aliases are not used directly in the DT source,
    but are instead deferenced by the Linux kernel.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不必遍历整个树来查找节点，引入了别名的概念。在DT中，`aliases`节点可以看作是一个快速查找表，另一个节点的索引。可以使用函数`find_node_by_alias()`来查找给定别名的节点。别名不直接在DT源中使用，而是由Linux内核进行解引用。
- en: DT compiler
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DT编译器
- en: 'The DT comes in two forms: the textual form, which represents the sources also
    known as `DTS` , and the binary blob form, which represents the compiled DT, also
    known as `DTB` . Source files have the `.dts` extension. Actually, there are also
    `.dtsi` text files, which represent SoC level definitions, whereas `.dts` files
    represent board level definitions. One can see `.dtsi` as header files, that should
    be included in `.dts` one, which are source files, not the reverse, a bit like
    including header files (`.h` ) in the source file (`.c` ). On the other hand,
    binary files use the `.dtb` extension.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: DT有两种形式：文本形式，表示源也称为`DTS`，以及二进制blob形式，表示已编译的DT，也称为`DTB`。源文件的扩展名为`.dts`。实际上，还有`.dtsi`文本文件，表示SoC级别定义，而`.dts`文件表示板级别定义。可以将`.dtsi`视为头文件，应包含在`.dts`中，这些是源文件，而不是反向的，有点像在源文件（`.c`）中包含头文件（`.h`）。另一方面，二进制文件使用`.dtb`扩展名。
- en: There is actually a third form, which is the runtime representation of the DT
    in `/proc/device-tree` .
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上还有第三种形式，即在`/proc/device-tree`中的DT的运行时表示。
- en: As its name says, the tool used to compile the device tree is called the **device
    tree compiler** (**dtc** ). From the root kernel source, one can compile either
    a standalone specific DT or all DTs for the specific architecture.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，用于编译设备树的工具称为**设备树编译器**（**dtc**）。从根内核源中，可以编译特定体系结构的独立特定DT或所有DT。
- en: 'Let us compile all DT (`.dts)` files for arm SoC''s:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为arm SoC编译所有DT（`.dts`）文件：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For a standalone DT:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于独立的DT：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, the name of the source file is `imx6dl-sabrelite.dts`
    .
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，源文件的名称是`imx6dl-sabrelite.dts`。
- en: 'Given a compiled device tree `(.dtb` ) file, you can do the reverse operation
    and extract the source `(.dts` ) file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个已编译的设备树（.dtb）文件，您可以执行反向操作并提取源（.dts）文件：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For the purpose of debugging, it could be useful to expose the DT to the user
    space. The `CONFIG_PROC_DEVICETREE` configuration variable will do that for you.
    You can then explore and walk through the DT in `/proc/device-tree` .
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 出于调试目的，将DT暴露给用户空间可能很有用。`CONFIG_PROC_DEVICETREE`配置变量将为您执行此操作。然后，您可以在`/proc/device-tree`中探索和浏览DT。
- en: Representing and addressing devices
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示和寻址设备
- en: Each device is given at least one node in the DT. Some properties are common
    to many device types, especially devices sitting on a bus known to the kernel
    (SPI, I2C, platform, MDIO, and so on). These properties are `reg` , `#address-cells`
    , and `#size-cells` . The purpose of these properties is device addressing on
    the bus they sit on. That said, the main addressing property is `reg` , which
    is a generic property and whose meaning depends on the bus the device sits on.
    The `#` (sharp) that prefixes `size-cell` and `address-cell` can be translated
    into `length` .
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每个设备在DT中至少有一个节点。某些属性对许多设备类型都是共同的，特别是对于内核已知的总线上的设备（SPI、I2C、平台、MDIO等）。这些属性是`reg`、`#address-cells`和`#size-cells`。这些属性的目的是在它们所在的总线上寻址设备。也就是说，主要的寻址属性是`reg`，这是一个通用属性，其含义取决于设备所在的总线。前缀`size-cell`和`address-cell`的`#`（sharp）可以翻译为`length`。
- en: Each addressable device gets a `reg` property that is a list of tuples in the
    form `reg = <address0size0 [address1size1] [address2size2] ... >` , where each
    tuple represents an address range used by the device. `#size-cells` indicates
    how many 32 bit cells are used to represent size, and may be 0 if size is not
    relevant. On the other hand, `#address-cells` indicates how many 32 bit cells
    are used to represent address. In other word, the address element of each tuple
    is interpreted according to `#address-cell` ; same for the size element, which
    is interpreted according to `#size-cell` .
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可寻址设备都有一个`reg`属性，其形式为`reg = <address0size0 [address1size1] [address2size2]
    ...>`的元组列表，其中每个元组表示设备使用的地址范围。`#size-cells`指示用于表示大小的32位单元的数量，如果大小不相关，则可能为0。另一方面，`#address-cells`指示用于表示地址的32位单元的数量。换句话说，每个元组的地址元素根据`#address-cell`进行解释；大小元素也是如此，根据`#size-cell`进行解释。
- en: Actually, addressable devices inherit from `#size-cell` and `#address-cell`
    of their parent, which is the node that represents the bus controller. The presence
    of `#size-cell` and `#address-cell` in a given device does not affect the device
    itself, but its children. In other words, before interpreting the `reg` property
    of a given node, one must know the parent node's `#address-cells` and `#size-cells`
    values. The parent node is free to define whatever addressing scheme is suitable
    for device sub-nodes (children).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，可寻址设备继承自其父节点的`#size-cell`和`#address-cell`，即代表总线控制器的节点。给定设备中`#size-cell`和`#address-cell`的存在不会影响设备本身，而是其子级。换句话说，在解释给定节点的`reg`属性之前，必须了解父节点的`#address-cells`和`#size-cells`值。父节点可以自由定义适合设备子节点（子级）的任何寻址方案。
- en: SPI and I2C addressing
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SPI和I2C寻址
- en: 'SPI and I2C devices both belong to non-memory mapped devices, because their
    addresses are not accessible to the CPU. Instead, the parent device''s driver
    (which is the bus controller driver) would perform indirect access on behalf of
    the CPU. Each I2C/SPI device is always represented as a sub-node of the I2C/SPI
    bus node the device seats on. For nonmemory mapped device, the `#size-cells` property
    is 0, and the size element in addressing the tuple is empty. It means the `reg`
    property for this kind of device is always on cell:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: SPI和I2C设备都属于非内存映射设备，因为它们的地址对CPU不可访问。相反，父设备的驱动程序（即总线控制器驱动程序）将代表CPU执行间接访问。每个I2C/SPI设备始终表示为所在的I2C/SPI总线节点的子节点。对于非内存映射设备，“＃size-cells”属性为0，寻址元组中的大小元素为空。这意味着这种类型的设备的“reg”属性始终在单元上：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If one looks at a SoC level file at `arch/arm/boot/dts/imx6qdl.dtsi` , one will
    notice that `#size-cells` and `#address-cells` are respectively set to `0` for
    the former, and `1` for the last, in both `i2c` and `spi` nodes, which are respectively
    parents of I2C and SPI devices enumerated in the preceding section. This helps
    us to understand their `reg` property, which is only one cell for the address
    value, and none for the size value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人查看`arch/arm/boot/dts/imx6qdl.dtsi`中的SoC级文件，就会注意到`#size-cells`和`#address-cells`分别设置为前者为`0`，后者为`1`，在`i2c`和`spi`节点中，它们分别是I2C和SPI设备在前面部分列举的父节点。这有助于我们理解它们的`reg`属性，地址值只有一个单元，大小值没有。
- en: I2C device's `reg` property is used to specify the device's address on the bus.
    For SPI devices, `reg` represents the index of the chip-select line assigned to
    the device among the list of chips-select the controller node has. For example,
    for the ad7606r8 ADC, the chip-select index is `1` , which corresponds to `<&gpio5
    17 0>` in `cs-gpios` , which is the list of chip-select of the controller node.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: I2C设备的`reg`属性用于指定总线上设备的地址。对于SPI设备，`reg`表示分配给设备的芯片选择线的索引，该索引位于控制器节点具有的芯片选择列表中。例如，对于ad7606r8
    ADC，芯片选择索引是`1`，对应于`cs-gpios`中的`<&gpio5 17 0>`，这是控制器节点的芯片选择列表。
- en: 'You may ask why I used the I2C/SPI node''s phandle: the answer is because I2C/SPI
    devices should be declared at board level file (`.dts` ), whereas I2C/SPI buses
    controller are declared at SoC level file (`.dtsi` ).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问为什么我使用了I2C/SPI节点的phandle：答案是因为I2C/SPI设备应该在板级文件（`.dts`）中声明，而I2C/SPI总线控制器应该在SoC级文件（`.dtsi`）中声明。
- en: Platform device addressing
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台设备寻址
- en: This section address simple memory-mapped devices whose memory is accessible
    to the CPU. Here, the `reg` property still defines the device's address, which
    is a list of memory regions on which you can access the device. Each region is
    represented with a tuple of cells, where the first cell is the base address of
    the memory region, and the second tuple is the size of the region. It then has
    the form `reg = <base0 length0 [base1 length1] [address2 length2] ... >` . Each
    tuple represents an address range used by the device.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涉及的是内存对CPU可访问的简单内存映射设备。在这里，`reg`属性仍然定义了设备的地址，这是可以访问设备的内存区域列表。每个区域用单元组表示，其中第一个单元是内存区域的基地址，第二个单元是区域的大小。它的形式是`reg
    = <base0 length0 [base1 length1] [address2 length2] ...>`。每个元组表示设备使用的地址范围。
- en: In the real world, one should not interpret the `reg` property without knowing
    the value of two other properties,`#size-cells` and `#address-cells` . `#size-cells`
    tell us how large the length field is in each child `reg` tuple. The same for
    `#address-cell` , which tell us how many cells we must use to specify an address.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，不应该在不知道另外两个属性`#size-cells`和`#address-cells`的值的情况下解释`reg`属性。`#size-cells`告诉我们每个子`reg`元组中长度字段有多大。`#address-cell`也是一样，它告诉我们必须使用多少个单元来指定一个地址。
- en: 'This kind of device should be declared within a node with a special value `compatible
    = "simple-bus"` , meaning a simple memory-mapped bus with no specific handling
    nor driver:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设备应该在一个具有特殊值`compatible = "simple-bus"`的节点中声明，表示一个没有特定处理或驱动程序的简单内存映射总线：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding example, child nodes whose parent has `simple-bus` in the
    compatible property will be registered as platform devices. One can also see how
    I2C and SPI bus controllers change the addressing scheme of their children by
    setting `#size-cells = <0>;` because it is not relevant to them. A well-known
    place to look for any binding information is in the kernel device tree''s documentation:
    *Documentation/devicetree/bindings/* .'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，具有`compatible`属性中`simple-bus`的子节点将被注册为平台设备。人们还可以看到I2C和SPI总线控制器如何通过设置`#size-cells
    = <0>;`来改变其子节点的寻址方案，因为这对它们来说并不重要。查找任何绑定信息的一个著名地方是内核设备树的文档：*Documentation/devicetree/bindings/*。
- en: Handling resources
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理资源
- en: The main purpose of a driver is to handle and manage devices, and most of the
    time, expose their functionalities to the user-space. The objective here is to
    gather the device's configuration parameters, and especially resources (memory
    region, interrupt line, DMA channel, clocks, and so on).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序的主要目的是处理和管理设备，并且大部分时间将其功能暴露给用户空间。这里的目标是收集设备的配置参数，特别是资源（内存区域、中断线、DMA通道、时钟等）。
- en: 'The following is the device node with which we will work during this section.
    It is the i.MX6 UART device''s node, defined in `arch/arm/boot/dts/imx6qdl.dtsi`
    :'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在本节中将使用的设备节点。它是在`arch/arm/boot/dts/imx6qdl.dtsi`中定义的i.MX6 UART设备节点：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Concept of named resources
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名资源的概念
- en: When the driver expect a list of resources of a certain type, one has no guarantee
    the list is ordered in a manner the driver expects, since the guy who writes the
    board level device tree is usually not the one that wrote the driver. A driver
    may expect, for example, its device node with 2 IRQs lines, one for the Tx event
    at index 0, the other for Rx at index 1\. What happens if the order is not respected?
    The driver will have an unwanted behavior. To avoid such mismatches, the concept
    of named resources (`clock` , `irq` , `dma` , `reg` ) has been introduced. It
    consists of defining our resource list, and naming them, so that whatever their
    indexes are, a given name will always match the resource.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当驱动程序期望某种类型的资源列表时，没有保证列表按照驱动程序期望的方式排序，因为编写板级设备树的人通常不是编写驱动程序的人。例如，驱动程序可能期望其设备节点具有2个IRQ线，一个用于索引0的Tx事件，另一个用于索引1的Rx。如果顺序没有得到尊重会发生什么？驱动程序将产生不需要的行为。为了避免这种不匹配，引入了命名资源（`clock`，`irq`，`dma`，`reg`）的概念。它包括定义我们的资源列表，并对其进行命名，以便无论它们的索引如何，给定的名称始终与资源匹配。
- en: 'The corresponding properties to name the resources are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 用于命名资源的相应属性如下：
- en: '`reg-names` : This is for a list of memory regions in `reg` property'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg-names`：这是在`reg`属性中的内存区域列表'
- en: '`clock-names` : This is to name clocks in the `clocks` property'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clock-names`：这是在`clocks`属性中命名时钟'
- en: '`interrupt-names` : This give a name to each interrupt in the `interrupts`
    property'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interrupt-names`：这为`interrupts`属性中的每个中断提供了一个名称'
- en: '`dma-names` : This is for the `dma` property'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dma-names`：这是`dma`属性'
- en: 'Now let us create a fake device node entry to explain that:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个虚假的设备节点条目来解释一下：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The code in the driver to extract each named resource is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序中提取每个命名资源的代码如下：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This way, you are sure to map the right name to the right resource, without
    needing to play with the index anymore.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您可以确保将正确的名称映射到正确的资源，而无需再使用索引。
- en: Accessing registers
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问寄存器
- en: Here, the driver will take ownership of the memory region and map it into the
    virtual address space. We will discuss more about this in [Chapter 11](http://post)
    , *Kernel Memory Management* .
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，驱动程序将接管内存区域并将其映射到虚拟地址空间中。我们将在[第11章](http://post)中更多地讨论这个问题，*内核内存管理*。
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`platform_get_resource()` will set the start and end fields of `struct res`
    according to the memory region present in the first (index 0) `reg` assignment.
    Please remember the last argument of `platform_get_resource()` represents the
    resource index. In the preceding sample, `0` indexes the first value of that resource
    type, just in case the device is assigned more than one memory region in the DT
    node. In our example, it''s `reg = <0x02020000 0x4000>` , meaning that the allocated
    region starts at physical address `0x02020000` and has the size of `0x4000` bytes.
    `platform_get_resource()` will then set `res.start = 0x02020000` and `res.end
    = 0x02023fff` .'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`platform_get_resource()`将根据DT节点中第一个（索引0）`reg`分配中存在的内存区域设置`struct res`的开始和结束字段。请记住，`platform_get_resource()`的最后一个参数表示资源索引。在前面的示例中，`0`索引了该资源类型的第一个值，以防设备在DT节点中分配了多个内存区域。在我们的示例中，它是`reg
    = <0x02020000 0x4000>`，意味着分配的区域从物理地址`0x02020000`开始，大小为`0x4000`字节。然后，`platform_get_resource()`将设置`res.start
    = 0x02020000`和`res.end = 0x02023fff`。'
- en: Handling interrupts
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理中断
- en: 'The interrupt interface is actually divided into two parts; the consumer side
    and the controller side. Four properties are used to describe interrupt connections
    in the DT:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 中断接口实际上分为两部分；消费者端和控制器端。在DT中用四个属性来描述中断连接：
- en: 'The controller is the device that exposes IRQ lines to the consumer. In controller
    side, on has the following properties:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是向消费者公开IRQ线的设备。在控制器端，有以下属性：
- en: '`interrupt-controller` : An empty (Boolean) property that one should define
    in order to mark the device as being an interrupt controller'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interrupt-controller`：一个空（布尔）属性，应该定义为标记设备为中断控制器'
- en: '`#interrupt-cells` : This is a property of interrupt controllers. It states
    how many cells are used to specify an interrupt for that interrupt controller'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#interrupt-cells`：这是中断控制器的属性。它说明用于为该中断控制器指定中断的单元格数'
- en: 'The consumer is the device that generate the IRQ. Consumer binding expects
    the following properties:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者是生成IRQ的设备。消费者绑定期望以下属性：
- en: '`interrupt-parent` : For the device node that generates interrupt, it is a
    property that contains a pointer `phandle` to the interrupt controller node to
    which the device is attached. If omitted, the device inherits that property from
    its parent node.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interrupt-parent`：对于生成中断的设备节点，它是一个包含指向设备附加的中断控制器节点的指针`phandle`的属性。如果省略，设备将从其父节点继承该属性。'
- en: '`interrupts` : It is the interrupt specifier.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interrupts`：这是中断指定器。'
- en: Interrupt binding and interrupt specifiers are tied to the interrupt controller
    device. The number of cells used to define an interrupt input depends on the interrupt
    controller, which is the only one deciding, by mean of its `#interrupt-cells`
    property. In the case of i.MX6, the interrupt controller is a **Global Interrupt
    Controller** (**GIC** ). Its binding is well explained in *Documentation/devicetree/bindings/arm/gic.txt*
    .
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 中断绑定和中断指定器与中断控制器设备绑定。用于定义中断输入的单元格数取决于中断控制器，这是唯一决定的，通过其`#interrupt-cells`属性。在i.MX6的情况下，中断控制器是**全局中断控制器**（**GIC**）。其绑定在*Documentation/devicetree/bindings/arm/gic.txt*中有很好的解释。
- en: The interrupt handler
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断处理程序
- en: 'This consist of fetching the IRQ number from the DT, and mapping it into Linux
    IRQ, thus registering a function callback for it. The driver code to do this is
    quite simple:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括从DT中获取IRQ号，并将其映射到Linux IRQ，从而为其注册一个函数回调。执行此操作的驱动程序代码非常简单：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `platform_get_irq()` call will return the `irq` number; this number is usable
    by `devm_request_irq()` (`irq` is then visible in `/proc/interrupts` ). The second
    argument, `0` , says that we need the first interrupt specified in the device
    node. If, there is more than one interrupt, we can change this index according
    to the interrupt we need, or just use the named resource.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`platform_get_irq()`调用将返回`irq`号；这个数字可以被`devm_request_irq()`使用（`irq`然后在`/proc/interrupts`中可见）。第二个参数`0`表示我们需要设备节点中指定的第一个中断。如果有多个中断，我们可以根据需要更改此索引，或者只使用命名资源。'
- en: 'In our preceding example, the device node contains an interrupt specifier,
    which looks like as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，设备节点包含一个中断指定器，看起来像这样：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'According to ARM GIC, the first cell informs us about interrupt type:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据ARM GIC，第一个单元格告诉我们中断类型：
- en: '`0` **: Shared peripheral interrupt** (**SPI** ), for interrupts signal shared
    among cores, which can be routed by the GIC to any core'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` **：共享外围中断**（**SPI**），用于在核心之间共享的中断信号，可以由GIC路由到任何核心'
- en: '`1` : **Private peripheral interrupt** (**PPI** ), for interrupt signal private
    to an individual core'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：**私有外围中断**（**PPI**），用于单个核心的私有中断信号'
- en: 'The documentation can be found at: [http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0407e/CCHDBEBE.html](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0407e/CCHDBEBE.html)
    .'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可以在以下网址找到：[http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0407e/CCHDBEBE.html](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0407e/CCHDBEBE.html)。
- en: The second cell holds the interrupt number. This number depends on whether the
    interrupt line is a PPI or SPI.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个单元格保存中断号。这个数字取决于中断线是PPI还是SPI。
- en: The third cell, `IRQ_TYPE_LEVEL_HIGH` in our case, represents sense level. All
    of the available sense levels are defined in `include/linux/irq.h` .
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个单元格，在我们的情况下是`IRQ_TYPE_LEVEL_HIGH`，表示感应电平。所有可用的感应电平都在`include/linux/irq.h`中定义。
- en: Interrupt controller code
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断控制器代码
- en: The `interrupt-controller` property is used to declare a device as an interrupt
    controller. The `#interrupt-cells` property defines how many cells must be used
    to define a single interrupt line. We will discuss this in detail in [Chapter
    16](http://advanced) , *Advanced IRQ* *Management* .
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`interrupt-controller`属性用于声明设备为中断控制器。`#interrupt-cells`属性定义了必须使用多少个单元格来定义单个中断线。我们将在[第16章](http://advanced)中详细讨论这个问题，*高级中断管理*。'
- en: Extract application-specific data
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取应用程序特定数据
- en: 'Application-specific data is data beyond the common properties (neither resources
    nor GPIOs, regulator, and so on). Those are arbitrary properties and child nodes
    that can be assigned to a device. Such property names are usually prefixed with
    manufacture codes. These can be any string, Boolean, or integer values, along
    with their API defined in `drivers/of/base.c` in the Linux sources. The following
    examples we discuss are not exhaustive. Let us now reuse the node defined earlier
    in this chapter:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序特定数据是超出常见属性（既不是资源也不是GPIO、调节器等）的数据。这些是可以分配给设备的任意属性和子节点。这些属性名称通常以制造商代码为前缀。这些可以是任何字符串、布尔值或整数值，以及它们在Linux源代码中`drivers/of/base.c`中定义的API。我们讨论的以下示例并不详尽。现在让我们重用本章前面定义的节点：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Text string
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本字符串
- en: 'The following is one `string` property:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`string`属性：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Back in the driver, one should use `of_property_read_string()` to read a string
    value. Its prototype is defined as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 回到驱动程序中，应该使用`of_property_read_string()`来读取字符串值。其原型定义如下：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following code shows how you can use it:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何使用它：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Cells and unsigned 32-bit integers
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元格和无符号32位整数
- en: 'The following are our `int` properties:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的`int`属性：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'One should use `of_property_read_u32()` to read a cell value. Its prototype
    is defined as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用`of_property_read_u32()`来读取单元格值。其原型定义如下：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Back in the driver,
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 回到驱动程序中，
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'One can use `of_property_read_u32_array` to read a list of cells. Its prototype
    is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`of_property_read_u32_array`来读取单元格列表。其原型如下：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, `sz` is the number of array elements to read. Have a look at `drivers/of/base.c`
    to see how to interpret its return value:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sz`是要读取的数组元素的数量。查看`drivers/of/base.c`以查看如何解释其返回值：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Boolean
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'One should use `of_property_read_bool()` to read the Boolean property whose
    name is given in the second argument of the function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用`of_property_read_bool()`来读取函数的第二个参数中给定的布尔属性的名称：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Extract and parse sub-nodes
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取和解析子节点
- en: 'You are allowed to add any sub-node in your device node. Given a node representing
    a flash memory device, partitions can be represented as sub-nodes. For a device
    that handles a set of input and output GPIO, each set can be represented as a
    sub-node. The sample node is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在设备节点中添加任何子节点。给定表示闪存设备的节点，分区可以表示为子节点。对于处理一组输入和输出GPIO的设备，每个集合可以表示为一个子节点。示例节点如下：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'One can use `for_each_child_of_node()` to walk through sub-nodes of the given
    node:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`for_each_child_of_node()`来遍历给定节点的子节点：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Platform drivers and DT
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台驱动程序和DT
- en: 'Platform drivers also work with DT. That being said, it is the recommended
    way to deal with platform devices nowadays, and there is no need to touch board
    files anymore, or even to recompile the kernel when a device''s property changes.
    If you remember, in the previous chapter we discussed OF match style, which is
    a matching mechanism based on the DT. Let us see in the following section how
    it works:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 平台驱动程序也可以使用DT。也就是说，这是处理平台设备的推荐方式，而且不再需要触及板文件，甚至在设备属性更改时重新编译内核。如果您还记得，在上一章中我们讨论了OF匹配样式，这是一种基于DT的匹配机制。让我们在下一节中看看它是如何工作的：
- en: OF match style
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OF匹配样式
- en: OF match style is the first matching mechanism performed by the platform core
    in order to match devices with their drivers. It uses the device tree's `compatible`
    property to match the device entry in `of_match_table` , which is a field of the
    `struct driver` substructure. Each device node has a `compatible` property, which
    is a string, or a list of strings. Any platform driver that declares one of the
    strings listed in the `compatible` property will trigger a match and will see
    its `probe` function executed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: OF匹配样式是平台核心执行的第一个匹配机制，用于将设备与其驱动程序匹配。它使用设备树的`compatible`属性来匹配`of_match_table`中的设备条目，这是`struct
    driver`子结构的一个字段。每个设备节点都有一个`compatible`属性，它是一个字符串或字符串列表。任何声明在`compatible`属性中列出的字符串之一的平台驱动程序都将触发匹配，并将看到其`probe`函数执行。
- en: 'A DT match entry is described in the kernel as an instance of the `struct of_device_id`
    structure, which is defined in `linux/mod_devicetable.h` and looks like:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: DT匹配条目在内核中被描述为`struct of_device_id`结构的一个实例，该结构在`linux/mod_devicetable.h`中定义，如下所示：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following is the meaning of each element of the structure:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结构的每个元素的含义：
- en: '`char compatible[128]` : This is the string used to match the device node''s
    compatible property in the DT. They must be identical before a match occurs.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char compatible[128]`：这是用于匹配设备节点的DT兼容属性的字符串。在匹配发生之前，它们必须相同。'
- en: '`const void *data` : This can point to any structure, which can be used as
    per-device type configuration data.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const void *data`：这可以指向任何结构，可以根据设备类型配置数据使用。'
- en: 'Since the `of_match_table` is a pointer, you can pass an array of the `struct
    of_device_id` to make your driver compatible with more than one device:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`of_match_table`是一个指针，您可以传递`struct of_device_id`的数组，使您的驱动程序与多个设备兼容：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once you have filled your array of ids, it must be passed to the `of_match_table`
    field of your platform driver, in the driver substructure:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦填充了id数组，它必须传递给平台驱动程序的`of_match_table`字段，在驱动程序子结构中：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: At this step, only your driver is aware of your `of_device_id` array. To get
    the kernel informed too (so that it can store your IDs in the device list maintained
    by the platform core), your array has to be registered with `MODULE_DEVICE_TABLE`
    , as described in [Chapter 5](text00146.html) , *Platform Device Drivers:*
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步，只有您的驱动程序知道您的`of_device_id`数组。为了让内核也知道（以便它可以将您的ID存储在平台核心维护的设备列表中），您的数组必须在`MODULE_DEVICE_TABLE`中注册，如[第5章](text00146.html)中所述，*平台设备驱动程序*：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That is all! Our driver is DT-compatible. Back in our DT, let''s declare a
    device compatible with our driver:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们的驱动程序是DT兼容的。回到我们的DT，在那里声明一个与我们的驱动程序兼容的设备：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Two compatible strings are provided here. If the first one does not match any
    driver, the core will perform the match with the second.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供了两个兼容的字符串。如果第一个与任何驱动程序都不匹配，核心将使用第二个进行匹配。
- en: 'When a match occurs, the `probe` function of your driver is called, with a
    `struct platform_device` structure as the parameter, which contains a `struct
    device dev` field, in which there is a field `struct device_node *of_node` that
    corresponds to the node associated to our device, so that one can use it to extract
    the device settings:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生匹配时，将调用您的驱动程序的`probe`函数，参数是一个`struct platform_device`结构，其中包含一个`struct device
    dev`字段，在其中有一个`struct device_node *of_node`字段，对应于我们的设备关联的节点，因此可以使用它来提取设备设置：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'One can check if the DT node is set to know whether the driver has been loaded
    in response to an `of_match` , or instantiated from within the board''s `init`
    file. You should then use the `of_match_device` function, in order to pick the
    `struct *of_device_id` entry that originated the match, which may contain the
    specific data you have passed:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以检查DT节点是否设置来知道驱动程序是否已经在`of_match`的响应中加载，或者是在板子的`init`文件中实例化。然后应该使用`of_match_device`函数，以选择发起匹配的`struct
    *of_device_id`条目，其中可能包含您传递的特定数据：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Dealing with non-device tree platforms
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理非设备树平台
- en: 'DT support is enabled in the kernel with the `CONFIG_OF` option. One would
    probably want to avoid using the DT API when its support is not enabled in the
    kernel. The way one can achieve that is to check whether `CONFIG_OF` is set or
    not. People used to do something like as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核中启用了`CONFIG_OF`选项的情况下启用了DT支持。当内核中未启用DT支持时，人们可能希望避免使用DT API。可以通过检查`CONFIG_OF`是否设置来实现。人们过去通常会做如下操作：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Even if the `of_device_id` data type is always defined when device tree support
    is missing, the code wrapped into `#ifdef CONFIG_OF ... #endif` will be omitted
    during the build. This is used for conditional compilation. It is not your only
    choice; there is also the `of_match_ptr` macro, which simply returns `NULL` when
    `OF` is disabled. Everywhere you''ll need to pass your `of_match_table` as a parameter,
    it should be wrapped in the `of_match_ptr` macro, so that it returns `NULL` when
    `OF` is disabled. The macro is defined in `include/linux/of.h` :'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '即使在缺少设备树支持时，`of_device_id`数据类型总是定义的，但在构建过程中，被包装在`#ifdef CONFIG_OF ... #endif`中的代码将被省略。这用于条件编译。这不是您唯一的选择；还有`of_match_ptr`宏，当`OF`被禁用时，它简单地返回`NULL`。在您需要将`of_match_table`作为参数传递的任何地方，它都应该被包装在`of_match_ptr`宏中，以便在`OF`被禁用时返回`NULL`。该宏在`include/linux/of.h`中定义：'
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And we can use it as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用它：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This eliminates having a `#ifdef` , returning `NULL` when `OF` is disabled.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这消除了使用`#ifdef`，在`OF`被禁用时返回`NULL`。
- en: Support multiple hardware with per device-specific data
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持具有每个特定设备数据的多个硬件
- en: 'Sometimes, a driver can support different hardware, each with is specific configuration
    data. That data may be dedicated function tables, specific register values, or
    anything unique to each hardware. The following example describes a generic approach:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，驱动程序可以支持不同的硬件，每个硬件都有其特定的配置数据。这些数据可能是专用的函数表、特定的寄存器值，或者是每个硬件独有的任何内容。下面的示例描述了一种通用的方法：
- en: Let us first remember what `struct of_device_id` looks like, in `include/linux/mod_devicetable.h`
    .
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先回顾一下`include/linux/mod_devicetable.h`中`struct of_device_id`的外观。
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The field we are interested in is `const void *data` , so we can use it to pass
    any data for each specific device.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的字段是`const void *data`，所以我们可以使用它来为每个特定设备传递任何数据。
- en: Let's say we own three different devices, each with a specific private data.
    `of_device_id.data` will contain a pointer to specific parameters. This example
    is inspired by `drivers/tty/serial/imx.c` *.*
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们拥有三种不同的设备，每个设备都有特定的私有数据。`of_device_id.data`将包含指向特定参数的指针。这个示例受到了`drivers/tty/serial/imx.c`的启发。
- en: 'First, we declare private structures:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明私有结构：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then we fill an array with each device-specific data:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们用每个特定设备的数据填充一个数组：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Each compatible entry is tied with a specific array index:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 每个兼容条目都与特定的数组索引相关联：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now in the `probe` function, whatever the match entry is, it will hold a pointer
    to the device-specific structure:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`probe`函数中，无论匹配条目是什么，它都将保存指向特定设备结构的指针：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code, `devdata` is an element of a structure in the original
    source, and declared like `const struct imx_uart_data *devdata` ; we could have
    stored any specific parameter in the array.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`devdata`是原始源代码中结构的一个元素，并且声明为`const struct imx_uart_data *devdata`；我们可以在数组中存储任何特定的参数。
- en: Match style mixing
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配样式混合
- en: 'OF match style can be combined with any other matching mechanism. In the following
    example, we have a mix of DT and device ID match styles:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: OF匹配样式可以与任何其他匹配机制结合使用。在下面的示例中，我们混合了DT和设备ID匹配样式：
- en: 'We fill an array for the device ID match style, each device having its data:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为设备ID匹配样式填充一个数组，每个设备都有自己的数据：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We do the same for OF match style:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对OF匹配样式也是一样的：
- en: '[PRE45]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `probe` function will look as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`probe`函数将如下所示：'
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then we declare our platform driver; feed all arrays defined as in the preceding
    sections:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们声明我们的平台驱动程序；将所有在前面的部分中定义的数组都传递进去：
- en: '[PRE47]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Platform resources and DT
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台资源和DT
- en: 'Platform devices can work with the device tree enabled system without any extra
    modification. It is what we have demonstrated in the section *Handling resources*
    . By using `platform_xxx` family function, the core also walks through the DT
    (with `of_xxx` family function) to find the requested resource. The reverse is
    not true, since `of_xxx` family function is only reserved for the DT. All resource
    data will be available to the driver in a usual way. The driver now knows whether
    this device is not initialized with hardcoded parameters in the board file or
    not. Let us take an example with an uart device node:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 平台设备可以在启用设备树的系统中工作，无需任何额外修改。这就是我们在“处理资源”部分中所展示的。通过使用“platform_xxx”系列函数，核心还会遍历DT（使用“of_xxx”系列函数）以找到所需的资源。反之则不成立，因为“of_xxx”系列函数仅保留给DT使用。所有资源数据将以通常的方式提供给驱动程序。现在驱动程序知道这个设备是否是在板文件中以硬编码参数初始化的。让我们以一个uart设备节点为例：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following excerpt describes the `probe` function of its driver. In the
    `probe` , the function `platform_get_resource()` can be used to extract any property
    which is a resource (memory region, dma, irq), or a specific function, such as
    `platform_get_irq()` , which extracts the `irq` provided by the `interrupts` property
    in the DT:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下摘录描述了其驱动程序的“probe”函数。在“probe”中，函数“platform_get_resource（）”可用于提取任何资源（内存区域、DMA、中断），或特定功能，如“platform_get_irq（）”，它提取DT中“interrupts”属性提供的“irq”：
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To sum up, for properties such as `dma` , `irq` and `mem` , you have nothing
    to do in the platform driver to match `dtb` . If one remembers, this data is of
    the same type as the data one can pass as a platform resource. To understand why,
    we just have to look inside these functions; we will see how each of them internally
    deals with DT functions. The following is an example of the `platform_get_irq`
    function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，对于诸如“dma”、“irq”和“mem”之类的属性，您在平台驱动程序中无需做任何匹配“dtb”的工作。如果有人记得，这些数据与作为平台资源传递的数据类型相同。要理解原因，我们只需查看这些函数的内部处理方式；我们将看到它们如何内部处理DT函数。以下是“platform_get_irq”函数的示例：
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'One may wonder how the `platform_xxx` functions extract resources from the
    DT. This should have been the `of_xxx` function family. You are right, but during
    the system boot, the kernel calls `of_platform_device_create_pdata()` on each
    device node, which will result in creating a platform device with the associated
    resource, on which you can call the `platform_xxx` family function. Its prototype
    is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 也许有人会想知道“platform_xxx”函数如何从DT中提取资源。这应该是“of_xxx”函数族。你是对的，但在系统启动期间，内核会在每个设备节点上调用“of_platform_device_create_pdata（）”，这将导致创建一个带有相关资源的平台设备，您可以在其上调用“platform_xxx”系列函数。其原型如下：
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Platform data versus DT
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平台数据与DT
- en: If your driver expects platform data, you should check the `dev.platform_data`
    pointer. A non-null value means your driver has been instantiated the old way
    in the board configuration file, and DT does not enter into it. For drivers instantiated
    from the DT, `dev.platform_data` will be `NULL` , and your platform device will
    be given a pointer on the DT entry (node) that corresponds to your device in the
    `dev.of_node` pointer, from which one can extract the resource and use OF API
    to parse and extract application data.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的驱动程序期望平台数据，您应该检查“dev.platform_data”指针。非空值意味着您的驱动程序已在板配置文件中以旧方式实例化，并且DT不涉及其中。对于从DT实例化的驱动程序，“dev.platform_data”将为“NULL”，并且您的平台设备将获得指向与“dev.of_node”指针中对应于您设备的DT条目（节点）的指针，从中可以提取资源并使用OF
    API来解析和提取应用程序数据。
- en: 'There''s also a hybrid method that one can use to associate platform data declared
    in the C files to DT nodes, but that''s for special cases only: for DMA, IRQ,
    and memory. This method is used only when the driver expects only resources, and
    no application-specific data.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种混合方法可以用来将在C文件中声明的平台数据与DT节点关联起来，但这只适用于特殊情况：DMA、IRQ和内存。这种方法仅在驱动程序仅期望资源而不是特定应用程序数据时使用。
- en: 'One can transform a legacy declaration of an I2C controller into DT-compatible
    nodes as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将I2C控制器的传统声明转换为DT兼容节点，如下所示：
- en: '[PRE52]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And the DT node:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 和DT节点：
- en: '[PRE53]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The time to switch from hardcoded device configuration to DT has come. This
    chapter gave you all you need to handle DTs. Now you have the necessary skills
    to customize or add whatever node and property you want into the DT, and extract
    them from within your driver. In the next chapter, we will talk about the I2C
    driver, and use the DT API to enumerate and configure our I2C devices.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是从硬编码设备配置切换到DT的时候了。本章为您提供了处理DT所需的一切。现在您已经具备了自定义或添加任何节点和属性到DT中，并从驱动程序中提取它们的必要技能。在下一章中，我们将讨论I2C驱动程序，并使用DT
    API来枚举和配置我们的I2C设备。
