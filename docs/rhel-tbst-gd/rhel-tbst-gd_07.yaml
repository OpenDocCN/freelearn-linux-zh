- en: Chapter 7. Filesystem Errors and Recovery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。文件系统错误和恢复
- en: In [Chapter 5](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 5. Network Troubleshooting"), *Network Troubleshooting*, and [Chapter
    6](part0037_split_000.html#1394Q1-8ae10833f0c4428b9e1482c7fee089b4 "Chapter 6. Diagnosing
    and Correcting Firewall Issues"), *Diagnosing and Correcting Firewall Issues*,
    we used quite a few tools to troubleshoot network connectivity issues due to misconfigured
    routes and firewalls. Network related issues are very common and the two example
    issues are also frequent scenarios. In this chapter, we will be focusing on hardware-related
    issues and start that with troubleshooting filesystem errors.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0032_split_000.html#UGI01-8ae10833f0c4428b9e1482c7fee089b4"第5章。网络故障排除")*网络故障排除*和[第6章](part0037_split_000.html#1394Q1-8ae10833f0c4428b9e1482c7fee089b4"第6章。诊断和纠正防火墙问题")*诊断和纠正防火墙问题*中，我们使用了许多工具来排除由于错误配置的路由和防火墙导致的网络连接问题。网络相关问题非常常见，这两个示例问题也是常见的情况。在本章中，我们将专注于与硬件相关的问题，并从排除文件系统错误开始。
- en: Much like the other chapters, we will start with a discovered error and troubleshoot
    the issue until we find the cause and solution. Along the way, we will discover
    many of the different commands and logs necessary for troubleshooting filesystem
    issues.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他章节一样，我们将从发现的错误开始，排除问题直到找到原因和解决方案。在这个过程中，我们将发现许多用于排除文件系统问题的不同命令和日志。
- en: Diagnosing filesystem errors
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 诊断文件系统错误
- en: 'Unlike earlier chapters where end users were reporting the issue to us, this
    time around we have found an issue for ourselves. While performing some daily
    tasks on the database server we attempted to create a database backup and received
    the following error:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的章节不同，那时最终用户向我们报告了问题，这一次我们自己发现了问题。在数据库服务器上执行一些日常任务时，我们尝试创建数据库备份，并收到以下错误：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This error is interesting because it is not necessarily from the `mysqldump`
    command, but rather from the bash redirect that writes to the `/data/backups/wordpress.sql`
    file.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误很有趣，因为它不一定来自`mysqldump`命令，而是来自写入`/data/backups/wordpress.sql`文件的bash重定向。
- en: If we look at the error it is very specific, the filesystem we were attempting
    to write the backup to, is `Read-only`. What does `Read-only` mean?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下错误，它非常具体，我们试图将备份写入的文件系统是`只读`的。`只读`是什么意思？
- en: Read-only filesystems
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 只读文件系统
- en: When defining and mounting filesystems on Linux you have many options, but there
    are two options that define the filesystem's accessibility best. Those two options
    are `rw` for read and write, and **ro** for read-only. When a filesystem is mounted
    with the read and write option, this means that the contents of the filesystem
    can be read and the users with appropriate permissions can write new files/directories
    to the filesystem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上定义和挂载文件系统时，你有很多选项，但有两个选项最能定义文件系统的可访问性。这两个选项分别是`rw`表示读写，**ro**表示只读。当文件系统以读写选项挂载时，这意味着文件系统的内容可以被读取，并且具有适当权限的用户可以向文件系统写入新文件/目录。
- en: When the filesystem is mounted in the read-only mode, it means that while users
    can read the filesystem, new write requests will be denied.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件系统以只读模式挂载时，这意味着用户可以读取文件系统，但新的写入请求将被拒绝。
- en: Using the mount command to list mounted filesystems
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`mount`命令列出已挂载的文件系统
- en: 'Since the error we received specifically states that the filesystem is read-only,
    our next logical step is to look at the filesystems mounted on this server. To
    do this, we will use the `mount` command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们收到的错误明确指出文件系统是只读的，我们下一个逻辑步骤是查看服务器上已挂载的文件系统。为此，我们将使用`mount`命令：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `mount` command is a very useful command when dealing with filesystems.
    Not only can it be used to display the mounted filesystems (as seen in the preceding
    command), but it can also be used to attach (or mount) and un-attach (unmount)
    filesystems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount`命令在处理文件系统时非常有用。它不仅可以用于显示已挂载的文件系统（如前面的命令所示），还可以用于附加（或挂载）和卸载文件系统。'
- en: A mounted filesystem
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已挂载的文件系统
- en: Calling a filesystem a mounted filesystem is a common way of saying that the
    filesystem is *attached* to the server. With filesystems, they generally have
    two statuses, either they are attached (mounted) and the contents are accessible
    to users, or they are un-attached (unmounted) and inaccessible to the users. Later
    in this chapter, we will cover mounting and unmounting filesystems with the `mount`
    command.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 称文件系统为已挂载的文件系统是一种常见的说法，表示文件系统已*连接*到服务器。对于文件系统，它们通常有两种状态，要么是已连接（已挂载），内容对用户可访问，要么是未连接（未挂载），对用户不可访问。在本章的后面，我们将使用`mount`命令来介绍挂载和卸载文件系统。
- en: 'The `mount` command is not the only way to see what filesystems are mounted
    or not mounted. Another way to do this is to simply read the `/proc/mounts` file:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount`命令不是查看已挂载或未挂载文件系统的唯一方法。另一种方法是简单地读取`/proc/mounts`文件：'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In fact, the contents of the `/proc/mounts` file are extremely close to the
    output of the `mount` command, with the main difference being the two numbered
    columns at the end of each line. To get a better understanding of this file and
    the output of the `mount` command, let''s take a better look at the `/boot` filesystem''s
    entry within `/proc/mounts`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`/proc/mounts`文件的内容与`mount`命令的输出非常接近，主要区别在于每行末尾的两个数字列。为了更好地理解这个文件和`mount`命令的输出，让我们更仔细地看一下`/proc/mounts`中`/boot`文件系统的条目：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `/proc/mounts` file has data in six columns—**device**, **mount point**,
    **filesystem type**, **options**, and two unused columns that exist for backwards
    compatibility. For a better understanding of these values, let's get a better
    understanding of the columns.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc/mounts`文件有六列数据——**设备**、**挂载点**、**文件系统类型**、**选项**，以及两个未使用的列，用于向后兼容。为了更好地理解这些值，让我们更好地理解这些列。'
- en: The first column `device`, specifies the device to use for the filesystem. In
    the preceding example, the device that the `/boot` filesystem lives on is `/dev/sda1`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列设备指定了用于文件系统的设备。在前面的例子中，/boot文件系统所在的设备是/dev/sda1。
- en: From the name of the device (`sda1`), we can identify a critical piece of information.
    This device is a partition of another device, which we can identify by the fact
    that the device name has a number at the end.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从设备的名称（sda1）可以识别出一个关键信息。这个设备是另一个设备的分区，我们可以通过设备名称末尾的数字来识别。
- en: The device, which by the name appears to be a physical drive (assuming it's
    a hard drive) and is named `/dev/sda`; this drive has at least one partition,
    which has a device name of `/dev/sda1`. Whenever a drive has partitions on it,
    the partitions are created as their own device, each device getting assigned a
    number; in this case 1, which means that it is the first partition.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设备，从名称上看似乎是一个物理驱动器（假设是硬盘），名为/dev/sda；这个驱动器至少有一个分区，其设备名称为/dev/sda1。每当一个驱动器上有分区时，分区会被创建为自己的设备，每个设备都被分配一个编号；在这种情况下是1，这意味着它是第一个分区。
- en: Using fdisk to list available partitions
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用fdisk列出可用分区
- en: 'We can verify this by looking at the `/dev/sda` device that is using the `fdisk`
    command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用fdisk命令来验证这一点：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `fdisk` command might be familiar because it is a cross-platform command
    used to create disk partitions. It can however also be used to list partitions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: fdisk命令可能很熟悉，因为它是一个用于创建磁盘分区的跨平台命令。但它也可以用来列出分区。
- en: 'In the preceding command, we used the `–l` (list) flag to list the partitions
    followed by the device we wanted to look at—`/dev/sda`. However, the `fdisk` command
    shows us much more than the partitions available on this drive. It also shows
    us how large the disk is:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们使用了-l（列出）标志来列出分区，然后是我们想要查看的设备/dev/sda。然而，fdisk命令显示的不仅仅是这个驱动器上可用的分区。它还显示了磁盘的大小：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can see this in the first line being printed from the `fdisk` command, according
    to this line our device `/dev/sda` is `42.9 GB` in size. If we look towards the
    bottom of the output, we can also see the partitions created on this disk:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从fdisk命令打印的第一行中看到这一点，根据这一行，我们的设备/dev/sda的大小为42.9GB。如果我们看输出的底部，还可以看到在这个磁盘上创建的分区：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'From the preceding list, it appears that `/dev/sda` has two partitions, `/dev/sda1`
    and `/dev/sda2`. Using `fdisk`, we have been able to identify quite a few details
    about this filesystem''s physical device. If we continue to look at the details
    from `/proc/mounts`, we should be able to identify some other very useful information,
    as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的列表中，看起来/dev/sda有两个分区，/dev/sda1和/dev/sda2。使用fdisk，我们已经能够识别出关于这个文件系统物理设备的许多细节。如果我们继续查看/proc/mounts的详细信息，我们应该能够识别出一些其他非常有用的信息，如下所示：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The second column *mount point* in the preceding line notates the path that
    this filesystem is mounted to. In this case, the path is `/boot`; `/boot` by itself
    is nothing more than a directory on the `/` (root) filesystem. However, once the
    filesystem that exists on the device `/dev/sda1` is mounted `/boot` is now its
    own filesystem.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行中的第二列*挂载点*标注了这个文件系统挂载到的路径。在这种情况下，路径是/boot；/boot本身只是根文件系统上的一个目录。然而，一旦存在于设备/dev/sda1上的文件系统被挂载，/boot现在就是它自己的文件系统。
- en: 'To better understand this concept, we will use the `mount` and `umount` commands
    to attach and detach the `/boot` filesystem:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个概念，我们将使用mount和umount命令来挂载和卸载/boot文件系统：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we perform a simple `ls` command on the `/boot` path, we can see quite a
    few files within this directory. From the `/proc/mounts` file and the `mount`
    command, we know that there is a filesystem attached to `/boot`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在/boot路径上执行一个简单的ls命令，我们可以看到这个目录中有很多文件。从/proc/mounts文件和mount命令中，我们知道/boot上有一个文件系统挂载：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In order to un-attach or unmount this filesystem, we can use the `umount` command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了卸载这个文件系统，我们可以使用umount命令：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `umount` command has a pretty simple task, it unmounts mounted filesystems.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: umount命令的任务非常简单，它卸载已挂载的文件系统。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The preceding commands are examples that unmounting a filesystem can be dangerous.
    In general, you should first verify that the filesystem is not actively being
    accessed before unmounting it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令是卸载文件系统可能是危险的示例。一般来说，您应该首先验证文件系统在卸载之前是否正在被访问。
- en: Since the `/boot` filesystem is now unmounted, what happens when we perform
    our `ls` command?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: /boot文件系统现在已经卸载，当我们执行ls命令时会发生什么？
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The path `/boot` is still valid. However, it is now just an empty directory.
    This is due to the fact that the filesystem on `/dev/sda1` is not mounted; therefore,
    any files that existed on that filesystem are not currently accessible on this
    system.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: /boot路径仍然有效。但现在它只是一个空目录。这是因为/dev/sda1上的文件系统没有挂载；因此，该文件系统上存在的任何文件目前在这个系统上都无法访问。
- en: 'If we use the `mount` command to remount the filesystem, we will see the files
    reappear:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用mount命令重新挂载文件系统，我们将看到文件重新出现：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we can see, when the `mount` command is given a path argument, the command
    will attempt to `mount` that filesystem. However, when given no arguments the
    `mount` command will simply display what filesystems are currently mounted.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，当mount命令给出路径参数时，该命令将尝试挂载该文件系统。然而，当没有给出参数时，mount命令将简单地显示当前挂载的文件系统。
- en: 'Later in this chapter, we will explore using `mount` and how it understands
    where and how filesystems should be mounted; for now, let''s take a look at the
    next column in the `/proc/mounts` output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将探讨使用mount以及它如何理解文件系统应该在何处以及如何挂载；现在，让我们来看一下/proc/mounts输出中的下一列：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The third column filesystem type denotes the type of filesystem being used.
    In many operating systems, especially Linux, there is often more than one type
    of filesystem that can be used. In the preceding case, our boot filesystem is
    set to `xfs`, which as of Red Hat Enterprise Linux 7, is the new default file
    system.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 第三列文件系统类型表示正在使用的文件系统类型。在许多操作系统中，特别是Linux，通常可以使用多种类型的文件系统。在上面的情况下，我们的引导文件系统设置为`xfs`，这是Red
    Hat Enterprise Linux 7的新默认文件系统。
- en: Prior to `xfs`, older versions of Red Hat defaulted to either the `ext3` or
    `ext4` filesystems. The `ext3/4` filesystems and others are still supported by
    Red Hat, so there could be a number of different filesystem types listed in the
    `/proc/mounts` file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`xfs`之前，旧版本的Red Hat默认使用`ext3`或`ext4`文件系统。Red Hat仍然支持`ext3/4`文件系统和其他文件系统，因此`/proc/mounts`文件中可能列出了许多不同的文件系统类型。
- en: 'For the `/boot` filesystem, knowing the filesystem type is not immediately
    useful; however, knowing how to look up the underlying type of filesystem might
    be required as we dig deeper into this issue:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`/boot`文件系统，了解文件系统类型并不立即有用；然而，在我们深入研究这个问题时，可能需要知道如何查找底层文件系统的类型：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The fourth column options shows the options the filesystem has been mounted
    with.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第四列选项显示了文件系统挂载的选项。
- en: 'When a filesystem is mounted, that filesystem can be given specific options
    in order to change the default behavior of the filesystem. In the preceding example,
    there are quite a few options provided; let''s break down this list to better
    understand what is being specified:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件系统被挂载时，可以为该文件系统指定特定选项，以改变文件系统的默认行为。在上面的例子中，提供了相当多的选项；让我们分解这个列表，以更好地理解指定了什么：
- en: '`**inode64**`**: This enables the filesystem to create inode numbers greater
    than 32 bits in length**'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**inode64**`**：这使文件系统能够创建大于32位长度的索引节点号**'
- en: '****noquota**: This disables disk quotas and enforcement for this filesystem**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**noquota**：这禁用了对该文件系统的磁盘配额和强制执行**'
- en: '**As we can see from the descriptions, these options can greatly change the
    way the filesystem behaves. They are also very important to look at when troubleshooting
    any filesystem issues:**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**从描述中可以看出，这些选项可以极大地改变文件系统的行为。在排除任何文件系统问题时，查看这些选项也非常重要：**'
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**The last two columns of the `/proc/mounts` output, which are represented
    as `0 0` are actually not used in `/proc/mounts`. These columns are in fact only
    added for backwards capability with `/etc/mtab`, which is a similar file, however
    is not considered up-to-date like `/proc/mounts`.**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc/mounts`输出的最后两列，表示为`0 0`，实际上在`/proc/mounts`中没有使用。这些列实际上只是为了与`/etc/mtab`向后兼容而添加的，`/etc/mtab`是一个类似的文件，但不像`/proc/mounts`那样被认为是最新的。'
- en: '**The difference between these two files is specifically in their usage. The
    `/etc/mtab` file is designed for users or applications to read and utilize where
    the `/proc/mounts` file is used by the kernel itself. For this reason, the `/proc/mounts`
    file is considered the most authoritative version.**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**这两个文件之间的区别在于它们的用途。`/etc/mtab`文件是为用户或应用程序设计的，用于读取和利用，而`/proc/mounts`文件是由内核本身使用的。因此，`/proc/mounts`文件被认为是最权威的版本。**'
- en: '**Back to troubleshooting**'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**回到故障排除**'
- en: '**If we go back to our issue at hand, we received an error when writing a backup
    to the `/data/backups` directory. Using the `mount` command, we can identify which
    filesystem that directory exists on:**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果我们回到手头的问题，我们在向`/data/backups`目录写入备份时收到了错误。使用`mount`命令，我们可以确定该目录存在于哪个文件系统上：**'
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Now that we understand the format of the `mount` command better, we can identify
    some key information from the preceding command line. We can see that the device
    for this filesystem is set to (`192.168.33.13:/nfs`), the `mount` point (`path`
    to attach as) is set to (`/data`), the filesystem type of is (`nfs4`), and the
    filesystem has quite a few options set.**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**现在我们更好地理解了`mount`命令的格式，我们可以从上面的命令行中识别出一些关键信息。我们可以看到，此文件系统的设备设置为（`192.168.33.13:/nfs`），`mount`点（要附加的路径）设置为（`/data`），文件系统类型为（`nfs4`），并且文件系统设置了相当多的选项。**'
- en: '**# NFS – Network Filesystem'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**# NFS - 网络文件系统'
- en: Looking at the `/data` filesystem we can see that the filesystem type is set
    to `nfs4`. This filesystem type means that the filesystem is a **Network Filesystem**
    (**NFS**).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`/data`文件系统，我们可以看到文件系统类型设置为`nfs4`。这种文件系统类型意味着文件系统是一个**网络文件系统**（**NFS**）。
- en: NFS is a service that allows a server to share an exported directory with other
    remote servers. The `nfs4` filesystem type is a special filesystem that allows
    the remote servers to access this service as if it was a standard filesystem.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: NFS是一种允许服务器与其他远程服务器共享导出目录的服务。`nfs4`文件系统类型是一种特殊的文件系统，允许远程服务器访问此服务，就像它是一个标准文件系统一样。
- en: The `4` in the filesystem type denotes the version to use, which means the remote
    server is to use Version 4 of the NFS protocol.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统类型中的`4`表示要使用的版本，这意味着远程服务器要使用NFS协议的第4版。
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Currently, the most popular versions for NFS are versions 3 and 4, with 4 being
    the default for Red Hat Enterprise Linux 6 and 7\. There are quite a few differences
    between version 3 and version 4; however, none of those differences are enough
    to make a difference in our troubleshooting methodology. If you find yourself
    running into issues with NFS Version 3, then you can most likely follow the same
    types of steps that we will follow in this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，NFS最流行的版本是版本3和版本4，版本4是Red Hat Enterprise Linux 6和7的默认版本。版本3和版本4之间有相当多的区别；然而，这些区别都不足以影响我们的故障排除方法。如果您在使用NFS版本3时遇到问题，那么您很可能可以按照我们将在本章中遵循的相同类型的步骤进行操作。
- en: 'Now that we have identified that the filesystem is an NFS filesystem, let''s
    take a look at the options it is mounted with:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了文件系统是NFS文件系统，让我们看看它挂载的选项：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: From the error we received, the filesystem appears to be `Read-Only`, but if
    we look at the options the first option listed is `rw`. This means that the NFS
    filesystem itself has been mounted as `Read-Write`; which should allow writes
    to this filesystem.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们收到的错误来看，文件系统似乎是“只读”的，但如果我们查看列出的选项，第一个选项是`rw`。这意味着NFS文件系统本身已被挂载为“读写”，这应该允许对此文件系统进行写操作。
- en: 'To test whether the issue is with the path `/data/backups` or the mounted filesystem
    `/data`, we can use the `touch` command to test creating a file within this filesystem:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试问题是与路径`/data/backups`还是挂载的文件系统`/data`有关，我们可以使用`touch`命令来测试在此文件系统中创建文件：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Even the `touch` command is not able to create a new file on this filesystem.
    This is a clear indication that there is a problem with the filesystem; the only
    question is what is causing the issue.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至`touch`命令也无法在此文件系统上创建新文件。这清楚地表明文件系统存在问题；唯一的问题是是什么导致了这个问题。
- en: If we look at the options this filesystem is mounted with, there is nothing
    that would cause the filesystem to be `Read-Only`; this means that the issue is
    most likely not with how the filesystem is mounted, but with something else.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看此文件系统挂载的选项，没有任何导致文件系统为“只读”的原因；这意味着问题很可能不在于文件系统的挂载方式，而是其他地方。
- en: Since the issue does not appear to be related to how the NFS filesystem is mounted
    and this filesystem is network based, a valid next step would be to verify network
    connectivity to the NFS server.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于问题似乎与NFS文件系统的挂载方式无关，而且这个文件系统是基于网络的，下一个有效的步骤将是验证与NFS服务器的网络连接。
- en: NFS and network connectivity
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NFS和网络连接
- en: 'Just as with the network troubleshooting, our first test will be to ping the
    NFS server to see if we get a response; but the question is: *What server should
    we ping?*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就像网络故障排除一样，我们的第一个测试将是ping NFS服务器，看看是否有响应；但问题是：*我们应该ping哪个服务器？*
- en: 'The answer is in the device name that the filesystem is mounted with (`192.168.33.13:/nfs`).
    When mounting an NFS filesystem, the device is in the format of `<nfs server>:<shared
    directory>`. For our example, this means that our `/data` filesystem is mounting
    the `/nfs` directory from the server `192.168.33.13`. To test connectivity, we
    can simply `ping` the IP `192.168.33.13`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在文件系统挂载的设备名称中（`192.168.33.13:/nfs`）。挂载NFS文件系统时，设备的格式为`<nfs服务器>:<共享目录>`。在我们的示例中，这意味着我们的`/data`文件系统正在从服务器`192.168.33.13`挂载`/nfs`目录。为了测试连接性，我们可以简单地`ping`
    IP `192.168.33.13`：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: From the `ping` results, it appears that the NFS server is up; but what about
    the NFS service? We can validate connectivity to the NFS service by using the
    `curl` command to `telnet` to the NFS port. First, however, we need to identify
    which port we should connect to.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ping`结果来看，NFS服务器似乎是正常的；但NFS服务呢？我们可以通过使用`curl`命令`telnet`到NFS端口来验证与NFS服务的连接。但首先，我们需要确定应连接到哪个端口。
- en: 'While troubleshooting the database connectivity in earlier chapters, we were
    mostly using well-known ports; since NFS uses several ports, which are a little
    less common; we will need to identify which port to connect to:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期章节中排除数据库连接问题时，我们主要使用了众所周知的端口；由于NFS使用了几个不太常见的端口，我们需要确定要连接的端口：
- en: 'The easiest way to do this is to search for the ports in the `/etc/services`
    file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的最简单方法是在`/etc/services`文件中搜索端口：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `/etc/services` file is a static file that is included with many Linux
    distributions. It is used as a lookup to map network ports to a simple human readable
    name. From the preceding output, we can see that the `nfs` name is mapped to TCP
    port `2049`; this is the default port for the NFS service. We can utilize this
    port to test connectivity, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/services`文件是许多Linux发行版中包含的静态文件。它用作查找表，将网络端口映射到简单易读的名称。从前面的输出中，我们可以看到`nfs`名称映射到TCP端口`2049`；这是NFS服务的默认端口。我们可以利用这个端口来测试连接性，如下所示：'
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our `telnet` seems successful; we can further validate it by using the `netstat`
    command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`telnet`似乎成功了；我们可以进一步验证它，使用`netstat`命令：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It seems that connectivity is not an issue, and if our issue is not connectivity
    related, maybe it is in how the NFS share is configured.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来连接性不是问题，如果我们的问题与连接性无关，也许是NFS共享的配置有问题。
- en: We can actually validate the NFS share's settings and network connectivity in
    one command—`showmount`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以使用一个命令验证NFS共享的设置和网络连接性——`showmount`。
- en: Using the showmount command
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`showmount`命令
- en: The `showmount` command can be used to display the directories being exported
    via the `-e` (that shows exports) flag. This command works by querying the NFS
    service on the specified host.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`showmount`命令可用于显示通过`-e`（显示导出）标志导出的目录。此命令通过查询指定主机上的NFS服务来工作。'
- en: 'For our issue, we will be querying the NFS service at `192.168.33.13`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的问题，我们将查询`192.168.33.13`上的NFS服务：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The format of the `showmount` command uses two columns. The first column is
    the directory being shared. The second is the network or hostnames the directory
    is being shared with.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`showmount`命令的格式使用两列。第一列是共享的目录。第二个是共享该目录的网络或主机名。'
- en: In the preceding example, we can see that the directory being shared from this
    host is the `/nfs` directory. This matches the directory listed in the device
    name `192.168.33.13:/nfs` as well.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以看到从此主机共享的目录是`/nfs`目录。这与设备名称`192.168.33.13:/nfs`中列出的目录相匹配。
- en: The network that the `/nfs` directory is being shared with is the `192.166.33.0/24`
    network, which, as we learned in our networking chapter, is short for `192.168.33.0`
    through `192.168.33.255`. We already know from previous troubleshooting that the
    database server we are on is within that network.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`/nfs`目录正在共享的网络是`192.166.33.0/24`网络，正如我们在网络章节中学到的那样，它是`192.168.33.0`到`192.168.33.255`的缩写。我们已经知道从以前的故障排除中，我们所在的数据库服务器位于该网络中。'
- en: 'We can also see this hasn''t changed since the `netstat` command was executed
    earlier:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到自从之前执行`netstat`命令以来，这并没有改变：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The fourth column of the `netstat` command shows the local IP address being
    used in the `ESTABLISHED` TCP connection. With the preceding output, we can see
    the `192.168.33.12` address is the IP of our database server (as seen in previous
    chapters).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`netstat`命令的第四列显示了在`已建立`的TCP连接中使用的本地IP地址。根据前面的输出，我们可以看到`192.168.33.12`地址是我们的数据库服务器的IP（在前几章中已经看到）。'
- en: So far everything about this NFS share looks correct, from here we will need
    to log in to the NFS server to continue troubleshooting.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，关于这个NFS共享的一切看起来都是正确的，从这里开始，我们需要登录到NFS服务器继续故障排除。
- en: NFS server configuration
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NFS服务器配置
- en: 'Once logged into the NFS server, the first thing we should check is whether
    or not the NFS service is running:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦登录到NFS服务器，我们应该首先检查NFS服务是否正在运行：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using `systemctl`, we can simply look at the service status; which from the
    preceding output looks normal. This is to be expected since we were able to both
    `telnet` to the NFS service and use the `showmount` command to query it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`systemctl`，我们可以简单地查看服务状态；从前面的输出来看，这是正常的。这是可以预料的，因为我们能够`telnet`到NFS服务并使用`showmount`命令来查询它。
- en: Exploring /etc/exports
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索`/etc/exports`
- en: 'Since the NFS service is running and healthy, the next step is to check the
    configuration that defines which directories are exported and how they are exported;
    the `/etc/exports` file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NFS服务正在运行且正常，下一步是检查定义了哪些目录被导出以及它们如何被导出的配置；`/etc/exports`文件：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The format of this file is actually similar to the output of the `showmount`
    command.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的格式实际上与`showmount`命令的输出类似。
- en: The first column is the directory to be shared and the second column is the
    network to share it with. However, in this file there is additional information
    after the network definition.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列是要共享的目录，第二列是要与之共享的网络。然而，在这个文件中，在网络定义之后还有额外的信息。
- en: The network/subnet column is followed by a set of parenthesis with various `NFS`
    options within it. These options work very similar to the mount options we saw
    in the `/proc/mounts` file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 网络/子网列后面跟着一组括号，里面包含各种`NFS`选项。这些选项与我们在`/proc/mounts`文件中看到的挂载选项非常相似。
- en: 'Could these options be the root cause of our `Read-Only` file system? Quite
    possibly. Let''s break down these two options to get a better understanding:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项可能是我们`只读`文件系统的根本原因吗？很可能。让我们分解这两个选项以更好地理解：
- en: '`rw`: This allows both reads and writes to be performed on the shared directory'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rw`：这允许在共享目录上进行读取和写入'
- en: '`no_root_squash`: This disables `root_squash`; `root_squash` is a system that
    maps the root user to an anonymous user'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no_root_squash`：这禁用了`root_squash`；`root_squash`是一个将root用户映射到匿名用户的系统'
- en: Unfortunately, neither of these options would force the filesystem to be in
    the `Read-Only` mode. In fact, based on the description of these options they
    seem to suggest this NFS share should be in the `Read-Write` mode.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这两个选项都不能强制文件系统处于`只读`模式。事实上，根据这些选项的描述，它们似乎表明这个NFS共享应该处于`读写`模式。
- en: 'One interesting fact has surfaced while performing an `ls` on the `/etc/exports`
    file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在对`/etc/exports`文件执行`ls`时，出现了一个有趣的事实：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `/etc/exports` file has been modified recently. Could it be that our shared
    filesystem is actually shared as `Read-Only` but someone has recently changed
    the `/etc/exports` file to export the filesystem as `Read-Write`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/exports`文件最近已经被修改。我们的共享文件系统实际上是以`只读`方式共享的，但是最近有人改变了`/etc/exports`文件，将文件系统导出为`读写`方式。'
- en: This scenario is entirely possible, and in fact is actually a common issue with
    NFS. The NFS service is not constantly reading the `/etc/exports` file looking
    for changes. In fact, this file is only read when the service is starting.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况是完全可能的，实际上，这是NFS的一个常见问题。NFS服务并不会不断地读取`/etc/exports`文件以寻找更改。事实上，只有在服务启动时才会读取这个文件。
- en: Any changes to the `/etc/exports` file will not take effect until after either
    the service is reloaded or the exported filesystems is refreshed using the `exportfs`
    command.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对`/etc/exports`文件的任何更改都不会生效，直到重新加载服务或使用`exportfs`命令刷新导出的文件系统为止。
- en: Identifying the current exports
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别当前的导出
- en: 'A very common scenario is where someone makes a change to this file and simply
    forgets to run the commands to refresh the exported filesystems. We can identify
    whether this is the case by using the `exportfs` command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的情况是，有人对这个文件进行了更改，然后忘记运行命令来刷新导出的文件系统。我们可以使用`exportfs`命令来确定是否是这种情况：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When given the `–s` (show current exports) flag, the `exportfs` command will
    simply list the existing shared directories, including the options that the directories
    are shared with.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当给出`-s`（显示当前导出）标志时，`exportfs`命令将简单地列出现有的共享目录，包括目录共享的选项。
- en: Looking at the preceding output, we can see that this filesystem is shared with
    quite a few options that are not listed in `/etc/exports`. The reason for this
    is because all directories shared through NFS have a default list of options that
    govern how the directory is shared. The options specified in `/etc/exports` are
    essentially used to override the default settings.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出可以看出，这个文件系统与许多未在`/etc/exports`中列出的选项共享。这是因为通过NFS共享的所有目录都有一个默认的选项列表，用于管理目录的共享方式。在`/etc/exports`中指定的选项实际上是用来覆盖默认设置的。
- en: 'To get a better understanding of these options, let''s break them down:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些选项，让我们分解它们：
- en: '`rw`: This allows both reads and writes to be performed on the shared directory.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rw`：这允许在共享目录上进行读取和写入。'
- en: '`wdelay`: This causes NFS to hold a write request if it suspects another write
    is incoming from another client. This is designed to reduce write conflicts when
    multiple clients are connected.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wdelay`：这会导致NFS在怀疑另一个客户端正在进行写入时暂停写入请求。这旨在减少多个客户端连接时的写入冲突。'
- en: '`no_root_squash`: This disables `root_squash`, which is a system that maps
    the root user to an anonymous user.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no_root_squash`：这禁用了`root_squash`，它是一个将root用户映射到匿名用户的系统。'
- en: '`no_subtree_check`: This disables `subtree` checking; subtree checking essentially
    ensures that requests to a directory where a subdirectory is also exported will
    honor the subdirectory''s more restrictive policy.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no_subtree_check`：这禁用了`subtree`检查；子树检查实质上确保对导出子目录的目录的请求将遵守子目录更严格的策略。'
- en: '`sec=sys`: This tells NFS to use the user ID and group ID values for permissions
    and authorization of file access.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sec=sys`：这告诉NFS使用用户ID和组ID值来控制文件访问的权限和授权。'
- en: '`secure`: This ensures that NFS only honors requests where the clients port
    is lower than 1024, essentially requiring it to be from a privileged NFS mount.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secure`：这确保NFS只接受客户端端口低于1024的请求，实质上要求它来自特权NFS挂载。'
- en: '`no_all_squash`: This disables `all_squash`, which is used to force all permissions
    to be mapped to the anonymous user and group.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no_all_squash`：这禁用了`all_squash`，用于强制将所有权限映射到匿名用户和组。'
- en: It seems that these options also do not explain the `Read-Only` file system.
    This is an issue that seems to be very tricky to troubleshoot, especially when
    the NFS service seems to be configured correctly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎这些选项也没有解释“只读”文件系统。这似乎是一个非常棘手的故障排除问题，特别是当NFS服务似乎配置正确时。
- en: Testing NFS from another client
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从另一个客户端测试NFS
- en: Since the NFS server's configuration seems correct and the client (database
    server) also appears correct, we will need to narrow down whether the issue is
    at the client side or the server side.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NFS服务器的配置似乎正确，客户端（数据库服务器）也似乎正确，我们需要缩小问题是在客户端还是服务器端。
- en: One way we can do this is by mounting the filesystem on another client and attempting
    the same write request. From the configuration, it appears we simply need another
    server in the `192.168.33.0/24` network to perform this test. Perhaps our blog
    server from earlier chapters is a good client to use?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在另一个客户端上挂载文件系统并尝试相同的写入请求来做到这一点。根据配置，似乎我们只需要另一个服务器在`192.168.33.0/24`网络中执行此测试。也许我们之前章节中的博客服务器是一个好的客户端选择？
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In some environments, the answer to this question would be `no`, as a web server
    is often considered less secure than a database server. However, since this is
    simply a test environment for this book, it will be OK.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些环境中，对这个问题的答案可能是否定的，因为Web服务器通常被认为比数据库服务器不太安全。但是，由于这只是本书的一个测试环境，所以可以接受。
- en: 'Once we have logged into the blog server, we can test whether or not we can
    even see the mount with the `showmount` command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们登录到博客服务器，我们可以测试是否可以使用`showmount`命令看到挂载：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This answers two questions. The first is whether the NFS client software is
    installed; since the `showmount` command is present, the answer is likely `yes`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这回答了两个问题。第一个是NFS客户端软件是否安装；由于`showmount`命令存在，答案很可能是“是”。
- en: The second is whether the NFS service is accessible from the blog server, which
    also appears to be yes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是NFS服务是否可以从博客服务器访问，这也似乎是肯定的。
- en: 'To test the mount, we will simply use the `mount` command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试挂载，我们将简单地使用`mount`命令：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To use the `mount` command to mount a filesystem the syntax is: `mount –t <filesystem
    type> <device> <mount point>`. In the example above we simply mounted the `192.168.33.13:/nfs`
    device to the `/mnt` directory with the filesystem type as `nfs`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`mount`命令挂载文件系统，语法是：`mount -t <文件系统类型> <设备> <挂载点>`。在上面的示例中，我们只是将`192.168.33.13:/nfs`设备挂载到了`/mnt`目录，文件系统类型为`nfs`。
- en: 'While running the command, we did not receive any errors but to ensure that
    the filesystem is mounted properly, we can use the `mount` command just as we
    did before:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行命令时，我们没有收到任何错误，但为了确保文件系统被正确挂载，我们可以使用`mount`命令，就像我们之前做的那样：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: From the output of the `mount` command, it appears that the `mount` request
    was successful and in the `Read-Write` mode, which means the `mount` options are
    similar to the options used on the database server.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从`mount`命令的输出中，似乎`mount`请求成功，并且处于“读写”模式，这意味着`mount`选项类似于数据库服务器上使用的选项。
- en: 'Now we can test the filesystem by attempting to create a file with the `touch`
    command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试使用`touch`命令在文件系统中创建文件来测试文件系统：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It appears that the issue is not with the client's configuration, as even our
    new client is having issues writing to this filesystem.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来问题不在客户端的配置上，因为即使我们的新客户端也无法写入这个文件系统。
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As a tip, in the preceding example, I mounted the `/nfs` share to `/mnt`. The
    `/mnt` directory is used as a generic mount point and is generally considered
    OK for use. However, it is always a best practice to ensure nothing else is mounted
    to `/mnt` before hand.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提示，在前面的示例中，我将`/nfs`共享挂载到了`/mnt`。`/mnt`目录被用作通用挂载点，通常被认为是可以使用的。但是，最好的做法是在挂载到`/mnt`之前确保没有其他东西挂载到`/mnt`。
- en: Making mounts permanent
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使挂载永久化
- en: Currently, even though we mounted the NFS share with the `mount` command, this
    mounted filesystem is not considered persistent. The next time this system reboots,
    the NFS mount will not be remounted.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，即使我们使用`mount`命令挂载了NFS共享，这个挂载的文件系统并不被认为是持久的。下次系统重新启动时，NFS挂载将不会重新挂载。
- en: That is because as a system boots up, part of the boot process is to read the
    `/etc/fstab` file and `mount` any filesystems defined within it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在系统启动时，启动过程的一部分是读取`/etc/fstab`文件并`mount`其中定义的任何文件系统。
- en: 'To better understand how this works, let''s look at the `/etc/fstab` file on
    the database server:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这是如何工作的，让我们看一下数据库服务器上的`/etc/fstab`文件：
- en: '[PRE33]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The contents of the `/etc/fstab` file are actually very similar to the contents
    of the `/proc/mounts` file. The first column in the `/etc/fstab` file is used
    to specify the device to be mounted, the second column is the `path` or `mount`
    point to mount to, the third column is simply the filesystem type, and the fourth
    column is the options to `mount` the filesystem with.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/fstab`文件的内容实际上与`/proc/mounts`文件的内容非常相似。`/etc/fstab`文件中的第一列用于指定要挂载的设备，第二列是要挂载到的路径或挂载点，第三列只是文件系统类型，第四列是`mount`文件系统的选项。'
- en: The last two columns, however, are where these files differ, within the `/etc/fstab`
    file. These last two columns actually have a meaning. Within the `fstab` file,
    the fifth column is used by the `dump` command.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些文件在`/etc/fstab`文件中的最后两列是不同的。这最后两列实际上是有意义的。在`fstab`文件中，第五列由`dump`命令使用。
- en: The `dump` command is a simple backup utility which reads the `/etc/fstab` to
    determine which filesystems to backup. Any filesystem with a `0` value set will
    not be in scope for a backup, when the dump utility is executed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`dump`命令是一个简单的备份实用程序，它读取`/etc/fstab`以确定要备份的文件系统。当执行dump实用程序时，任何值设置为`0`的文件系统都不会被备份。'
- en: While this utility is not heavily used these days, this column in the `/etc/fstab`
    file is maintained for backwards capability.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个实用程序在今天并不经常使用，但`/etc/fstab`文件中的这一列是为了向后兼容而保留的。
- en: The sixth and final column in the `/etc/fstab` file is very relevant to today's
    systems. This column is used to denote the order in which a filesystem check or
    `fsck` is performed during the boot process (generally after a failure).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/fstab`文件中的第六列对今天的系统非常重要。此列用于表示在引导过程中执行文件系统检查或`fsck`的顺序（通常在故障后）。'
- en: A filesystem check or `fsck` is a process that runs periodically, checking the
    filesystem for errors and attempts to correct them. This is a process we will
    cover a bit further in this chapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统检查或`fsck`是一个定期运行的过程，检查文件系统中的错误并尝试纠正它们。这是我们将在本章稍后介绍的一个过程。
- en: Unmounting the /mnt filesystem
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卸载/mnt文件系统
- en: Since we do not want the NFS shared filesystem to stay mounted on the `/mnt`
    path of the blog server, we will need to unmount the filesystem.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望NFS共享的文件系统保持挂载在博客服务器的`/mnt`路径上，我们需要卸载文件系统。
- en: 'We can do this in the same way we did with the `/boot` filesystem earlier;
    with the `umount` command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像之前对`/boot`文件系统所做的那样，使用`umount`命令来执行此操作：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: From the blog server, we simply used `umount` followed by the `mount` point
    of `/mnt` to `unmount` the NFS `mount` from the client. Now that we have, we can
    go back to the NFS server to continue troubleshooting.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从博客服务器上，我们只需使用`umount`，然后是客户端的`/mnt`挂载点来`卸载`NFS`挂载`。现在我们已经这样做了，我们可以回到NFS服务器继续排除故障。
- en: Troubleshooting the NFS server, again
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再次排除NFS服务器故障
- en: Since we identified that even new clients cannot write to the `/nfs` share,
    we have at this point narrowed down that the issue is likely on the server side
    and not the client.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们确定即使新客户端也无法写入`/nfs`共享，我们现在已经缩小了问题很可能是在服务器端而不是客户端。
- en: 'Earlier, while troubleshooting the NFS server, we checked almost everything
    that there is to check about NFS. We validated that the service is in fact running,
    accessible by the clients, that the data in `/etc/exports` is correct, and that
    the currently exported directories match what is in `/etc/exports`. At this point,
    there is only one place left to check: the `log` files.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，在排除NFS服务器故障时，我们几乎检查了关于NFS的所有内容。我们验证了服务实际上正在运行，可以被客户端访问，`/etc/exports`中的数据是正确的，并且当前导出的目录与`/etc/exports`中的内容匹配。此时，只剩下一个地方需要检查：`日志`文件。
- en: By default, the NFS service does not have its own log file like Apache or MariaDB.
    Instead, this service on the RHEL systems utilizes the `syslog` facility; which
    means our logs will be within `/var/log/messages`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，NFS服务没有像Apache或MariaDB那样拥有自己的日志文件。相反，RHEL系统上的此服务利用`syslog`设施；这意味着我们的日志将在`/var/log/messages`中。
- en: The `messages` log is a very frequently used log file for Red Hat Enterprise
    Linux based Linux distributions. In fact, by default, outside of cron jobs and
    authentication, every syslog message above the info log level is sent to `/var/log/messages`
    on RHEL based systems.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`messages`日志是基于Red Hat Enterprise Linux的Linux发行版中非常常用的日志文件。实际上，默认情况下，除了cron作业和身份验证之外，RHEL系统上的每条高于info日志级别的syslog消息都会发送到`/var/log/messages`。'
- en: Since the NFS service sends its log messages to the local `syslog` service,
    its messages are also included in the `messages` log.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NFS服务将其日志消息发送到本地`syslog`服务，因此其消息也包含在`messages`日志中。
- en: Finding the NFS log messages
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找NFS日志消息
- en: What if we didn't know that NFS logs were sent to the `/var/log/messages` log
    file? There is a pretty simple trick to identify which log file contains NFS log
    messages.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不知道NFS日志被发送到`/var/log/messages`日志文件中怎么办？有一个非常简单的技巧来确定哪个日志文件包含NFS日志消息。
- en: 'In general, on Linux systems, all system services have their log files located
    within `/var/log`. Since we know the default location of majority of logs on the
    system, we can simply take a quick look through those files to identify which
    ones might have the NFS log messages:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在Linux系统上，所有系统服务的日志文件都位于`/var/log`中。由于我们知道系统上大多数日志的默认位置，我们可以简单地浏览这些文件，以确定哪些文件可能包含NFS日志消息：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `grep` command recursively (`-r`) searches each file for the string "`nfs`"
    and outputs the filename along with a count (`-c`) of the number of lines where
    the string is found.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`命令递归（`-r`）搜索每个文件中的字符串"`nfs`"，并输出包含字符串的行数的文件名及计数（`-c`）。'
- en: In the preceding output, there are two log files that contain the highest amount
    of instances of the string "`nfs`". The first is the `maillog`, which is the system
    log for e-mail messages; this is not likely related to the NFS service.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，有两个日志文件包含了最多数量的字符串"`nfs`"。第一个是`maillog`，这是用于电子邮件消息的系统日志；这不太可能与NFS服务相关。
- en: The second is the `messages` log file which, as we know, is the system default
    log file.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是`messages`日志文件，正如我们所知，这是系统默认的日志文件。
- en: Even without prior knowledge of a specific system's logging methods, if you
    are familiar with Linux in general and tricks as in the preceding example, you
    can often find which logs contain the data required.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有关于特定系统日志记录方法的先验知识，如果您对Linux有一般了解，并且熟悉前面的示例中的技巧，通常可以找到包含所需数据的日志。
- en: Now that we know the log file we are looking for, let's take a look through
    the `/var/log/messages` log.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道要查找的日志文件，让我们浏览一下`/var/log/messages`日志。
- en: Reading /var/log/messages
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读`/var/log/messages`
- en: 'Since this `log` file can be quite large, we will use the `tail` command with
    the `-100` flag, which causes the tail to only display the last `100` lines of
    the specified file. By limiting the output to `100` lines, we should only see
    the most relevant data:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个`log`文件可能相当大，我们将使用`tail`命令和`-100`标志，这会导致`tail`只显示指定文件的最后`100`行。通过将输出限制为`100`行，我们应该只看到最相关的数据：
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Since even `100` lines can be quite tedious to go through, I have truncated
    the output to only the relevant lines. This shows quite a few messages with the
    string "`nfs`"; however, not every one of these are messages from the NFS service.
    Since our NFS server's hostname is set to `nfs`, each log entry from this system
    has the string "`nfs`".
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`100`行也可能相当繁琐，我已将输出截断为只包含相关行。这显示了相当多带有字符串"`nfs`"的消息；然而，并非所有这些消息都来自NFS服务。由于我们的NFS服务器主机名设置为`nfs`，因此来自该系统的每个日志条目都包含字符串"`nfs`"。
- en: 'However, even with that, we do still see a few messages related to the `NFS`
    service, specifically the following lines:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使如此，我们仍然看到了一些与`NFS`服务相关的消息，特别是以下行：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The interesting thing about these log entries is that one of them specifically
    states that the service `rpc.mountd` was not able to open a file due to the filesystem
    being `Read-only`. However, the file it was trying to open `/var/lib/nfs/.xtab.lock`
    is not part of our NFS share.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些日志条目的有趣之处在于其中一个明确指出服务`rpc.mountd`由于文件系统为`只读`而无法打开文件。然而，它试图打开的文件`/var/lib/nfs/.xtab.lock`并不是我们NFS共享的一部分。
- en: 'Since this filesystem is not part of our NFS, let''s take a quick look at the
    mounted filesystems on this server. We can do this again, with the `mount` command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个文件系统不是我们NFS的一部分，让我们快速查看一下这台服务器上挂载的文件系统。我们可以再次使用`mount`命令来做到这一点：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Like the other server there are quite a bit of mounted filesystems, we however
    are not interested in all of them; only a small subset.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与另一台服务器一样，有相当多的挂载文件系统，但我们并不对所有这些感兴趣；只对其中的一小部分感兴趣。
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding three lines are the lines that we should be interested in. These
    three mounted filesystems are persistent filesystems defined for our system. If
    we look at these three persistent filesystems, we can identify some interesting
    information.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的三行是我们应该感兴趣的行。这三个挂载的文件系统是我们系统定义的持久文件系统。如果我们查看这三个持久文件系统，我们可以找到一些有趣的信息。
- en: The `/` or root filesystem exists on the device `/dev/mapper/md0-root`. This
    filesystem is actually incredibly important to our system, as it appears that
    this server is configured to have the entire operating system installed under
    the root filesystem (`/`), a somewhat common setup. This filesystem includes the
    file in question, the `/var/lib/nfs/.xtab.lock` file.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`/`或根文件系统存在于设备`/dev/mapper/md0-root`上。这个文件系统对我们的系统非常重要，因为看起来这台服务器配置为在根文件系统(`/`)下安装整个操作系统，这是一种相当常见的设置。这个文件系统包括了问题文件`/var/lib/nfs/.xtab.lock`。'
- en: The `/boot` filesystem exists on the device `/dev/md127` which judging by the
    name is most likely a raided device using Linux's software raid system. The `/boot`
    filesystem is just as important as the root filesystem as `/boot` contains all
    of the necessary files for the server to boot up. Without the `/boot` filesystem,
    this system would most likely not restart and would simply kernel panic on the
    next system restart.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`/boot`文件系统存在于设备`/dev/md127`上，根据名称判断，这很可能是使用Linux软件RAID系统的阵列设备。`/boot`文件系统和根文件系统一样重要，因为`/boot`包含了服务器启动所需的所有文件。没有`/boot`文件系统，这个系统很可能无法重新启动，并且在下一次系统重启时会发生内核崩溃。'
- en: The last filesystem `/nfs` uses the `/dev/mapper/md0-nfs` device. From our earlier
    troubleshooting, we identified this filesystem as an exported filesystem via the
    NFS service.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个文件系统`/nfs`使用了`/dev/mapper/md0-nfs`设备。根据我们之前的故障排除，我们确定了这个文件系统是通过NFS服务导出的文件系统。
- en: Read-only filesystems
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 只读文件系统
- en: 'If we look back at the error and the output of `mount`, we will start to identify
    some interesting errors on this system:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾错误和`mount`的输出，我们将开始在这个系统上识别一些有趣的错误：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The error is reporting that the filesystem where the .`xtab.lock` file is located
    is `Read-Only`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 错误报告称，`.xtab.lock`文件所在的文件系统是`只读`的：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: From the `mount` command, we can see that the filesystem in question is the
    `/` filesystem. After looking at the options for the `/` or root filesystem we
    can see that this filesystem is in fact mounted with the `ro` option.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从`mount`命令中，我们可以看到问题的文件系统是`/`文件系统。在查看`/`或根文件系统的选项后，我们可以看到这个文件系统实际上是使用`ro`选项挂载的。
- en: In fact, if we look at the three filesystems' options, we can see that `/`,
    `/boot`, and `/nfs` are all mounted with the `ro` option. Where `rw` mounts a
    filesystem as `Read-Write`, the `ro` option mounts a filesystem as `Read-Only`.
    This means that currently, these filesystems cannot be written to by any user.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们查看这三个文件系统的选项，我们会发现`/`、`/boot`和`/nfs`都是使用`ro`选项挂载的。`rw`挂载文件系统为`读写`，`ro`选项挂载文件系统为`只读`。这意味着目前这些文件系统不能被任何用户写入。
- en: 'For all three of the defined filesystems to be mounted in the `Read-Only` mode
    is quite an unusual configuration. To see whether this is the desired configuration,
    we can check the `/etc/fstab` file, which is the same file that was used to identify
    persistent filesystems earlier:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个定义的文件系统都以`只读`模式挂载是相当不寻常的配置。为了确定这是否是期望的配置，我们可以检查`/etc/fstab`文件，这是之前用来识别持久文件系统的同一个文件：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: From the contents of the `/etc/fstab` file, it appears that these filesystems
    are not configured to be mounted in the `Read-Only` mode. Rather, these filesystems
    are mounted with "default" options.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从`/etc/fstab`文件的内容来看，这些文件系统并没有配置为以`只读`模式挂载。相反，这些文件系统是以“默认”选项挂载的。
- en: 'On Linux, the "default" option for the `xfs` filesystem mounts the filesystem
    in the `Read-Write` mode, not `Read-Only`. We validate this behavior if we look
    at the `/etc/fstab` file on the database server:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，`xfs`文件系统的“默认”选项将文件系统挂载为“读写”模式，而不是“只读”模式。如果我们查看数据库服务器上的`/etc/fstab`文件，我们可以验证这种行为：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'On the database server, we can see the `/` or root filesystem also has the
    filesystem options set to "defaults". However, when we use the `mount` command
    to look at the filesystem options, we can see the `rw` option as well as some
    others default options being applied:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库服务器上，我们可以看到`/`或根文件系统的文件系统选项也设置为“默认”。然而，当我们使用`mount`命令查看文件系统选项时，我们可以看到`rw`选项以及一些其他默认选项被应用：
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This confirms that the `Read-Only` status of the three persistent filesystems
    is not the desired configuration.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这证实了三个持久文件系统的“只读”状态不是期望的配置。
- en: Identifying disk issues
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别磁盘问题
- en: If the `/etc/fstab` filesystem is specifically configured so that a filesystem
    is mounted as `Read-Write` and the `mount` command is showing that the filesystem
    is mounted in `Read-Only` mode. This is a clear indication that the filesystems
    in question might have been remounted after they were initially mounted as part
    of the boot process.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`/etc/fstab`文件系统被特别配置为以“读写”方式挂载文件系统，并且`mount`命令显示文件系统以“只读”模式挂载。这清楚地表明所涉及的文件系统可能在引导过程的一部分挂载后被重新挂载。
- en: As we discussed earlier, when a Linux system boots, it reads the `/etc/fstab`
    file and mounts all of the defined filesystems. However, the process of mounting
    filesystems stops there. There is no process that continuously monitors the `/etc/fstab`
    file for changes and mounts or unmounts the modified filesystems, at least not
    by default.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，当Linux系统引导时，它会读取`/etc/fstab`文件并挂载所有定义的文件系统。但是，挂载文件系统的过程就此停止。默认情况下，没有持续监视`/etc/fstab`文件进行更改并挂载或卸载修改后的文件系统的过程。
- en: In fact it is quite common to see a newly created filesystem not mounted but
    specified in the `/etc/fstab` file because someone simply forgot to `mount` it
    with the `mount` command after editing the `/etc/fstab` file.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，看到新创建的文件系统未挂载但在`/etc/fstab`文件中指定是很常见的，因为有人在编辑`/etc/fstab`文件后忘记使用`mount`命令将其挂载。
- en: It is not very common however to see a filesystem be mounted as `Read-Only`
    but for the `fstab` to be changed afterwards.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，很少见到文件系统被挂载为“只读”，但之后`fstab`被更改。
- en: 'In fact for our scenario, that would not be very easy to accomplish as `/etc/fstab`
    would not be accessible since the `/` filesystem is `Read-Only`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，对于我们的情况来说，这并不容易实现，因为`/etc/fstab`是不可访问的，因为`/`文件系统是“只读”的：
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This means that our filesystems being `Read-Only`, was performed after these
    filesystems were mounted initially.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的文件系统处于“只读”模式，是在这些文件系统最初被挂载后执行的。
- en: 'The culprit of this state is actually in the log messages that we were looking
    through earlier:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，导致这种状态的罪魁祸首实际上是我们之前浏览的日志消息：
- en: '[PRE46]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: From the `/var/log/messages` log file, we can actually see that at some point,
    there was an issue with the software raid (`md`) that marked the disk `/dev/sdb1`
    as failed.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 从`/var/log/messages`日志文件中，我们实际上可以看到在某个时候，软件RAID（`md`）存在问题，标记磁盘`/dev/sdb1`为失败。
- en: By default with Linux if a physical disk drive fails or otherwise becomes unavailable
    to the kernel, the Linux kernel will remount the filesystems that live on that
    physical disk in the `Read-Only` mode. As in the preceding error message, it seems
    likely that the failure of the `sdb1` physical disk and the `md127` raid device
    are the root cause of the filesystems being `Read-Only`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，默认情况下，如果物理磁盘驱动器失败或以其他方式对内核不可用，Linux内核将以“只读”模式重新挂载驻留在该物理磁盘上的文件系统。正如前面的错误消息中所述，`sdb1`物理磁盘和`md127`
    RAID设备的故障似乎是文件系统变为“只读”的根本原因。
- en: Since software raid and hardware issues are the topic for the next chapter,
    we will defer troubleshooting the raid and disk issues for [Chapter 8](part0051_split_000.html#1GKCM1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 8. Hardware Troubleshooting"), *Hardware Troubleshooting*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 由于软件RAID和硬件问题是下一章的主题，我们将推迟故障排除RAID和磁盘问题至[第8章](part0051_split_000.html#1GKCM1-8ae10833f0c4428b9e1482c7fee089b4
    "第8章。硬件故障排除")，“硬件故障排除”。
- en: Recovering the filesystem
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复文件系统
- en: Now that we know why the filesystem is in the `Read-Only` mode, we can resolve
    it. Forcing the filesystem to go from `Read-Only` to `Read-Write` is actually
    pretty easy. However, because we don't know all of the circumstances around the
    failure that caused the filesystem to go into the `Read-Only` mode, we must be
    careful.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道文件系统为何处于“只读”模式，我们可以解决它。将文件系统从“只读”模式强制转换为“读写”模式实际上非常容易。但是，由于我们不知道导致文件系统进入“只读”模式的故障的所有情况，我们必须小心谨慎。
- en: Recovering from filesystem errors can be extremely tricky; if not done properly,
    we could easily find ourselves in a situation where we have corrupted the filesystem
    or in other ways caused partial or even full data loss.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 从文件系统错误中恢复可能非常棘手；如果操作不当，我们很容易陷入破坏文件系统或以其他方式导致部分甚至完全数据丢失的情况。
- en: Since we have multiple filesystems in the `Read-Only` mode, we will first start
    with the `/boot` filesystem. The reason we are starting with the `/boot` filesystem
    is because this is technically the best filesystem to experience data loss. Since
    the `/boot` filesystem is only used during the server boot process, we can simply
    ensure that we do not reboot this server before the `/boot` filesystem can be
    recovered.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有多个文件系统处于“只读”模式，我们将首先从`/boot`文件系统开始。我们之所以从`/boot`文件系统开始，是因为这从技术上讲是最好的文件系统来体验数据丢失。由于`/boot`文件系统仅在服务器引导过程中使用，我们可以确保在`/boot`文件系统恢复之前不重新启动此服务器。
- en: Whenever possible, it is always best to back up the data before taking any action.
    In the next steps, we are going to assume that the `/boot` filesystem is backed
    up periodically.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，最好在采取任何行动之前备份数据。在接下来的步骤中，我们将假设`/boot`文件系统定期备份。
- en: Unmounting the filesystem
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卸载文件系统
- en: To recover this filesystem, we will perform three steps. In the first step,
    we will unmount the `/boot` filesystem. By unmounting the filesystem before taking
    any additional steps, we will ensure that the filesystem is not being actively
    written to. This step will greatly reduce the chances of filesystem corruption
    during this recovery process.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了恢复这个文件系统，我们将执行三个步骤。在第一步中，我们将卸载“/boot”文件系统。在采取任何其他步骤之前卸载文件系统，我们将确保文件系统不会被主动写入。这一步将大大减少在恢复过程中文件系统损坏的机会。
- en: However, before unmounting the filesystem, we need to make sure that no applications
    or services are trying to write to the filesystem we are attempting to recover.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在卸载文件系统之前，我们需要确保没有应用程序或服务正在尝试写入我们正在尝试恢复的文件系统。
- en: To ensure this, we can use the `lsof` command. The `lsof` command is used to
    list open files; we can look through this list to identify if any files in the
    `/boot` filesystem are open.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这一点，我们可以使用“lsof”命令。 “lsof”命令用于列出打开的文件；我们可以浏览此列表，以确定“/boot”文件系统中是否有任何文件是打开的。
- en: 'If we simply run `lsof` with no options, it will print all of the current open
    files:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只是运行没有选项的“lsof”，它将打印所有当前打开的文件：
- en: '[PRE47]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'By adding the `–r` (repeat) flag to `lsof`, we are telling it to run in a repetitive
    mode. We can then pipe this output to the `grep` command where we can filter the
    output for files that are open on the `/boot` filesystem:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向“lsof”添加“-r”（重复）标志，我们告诉它以重复模式运行。然后我们可以将此输出传输到“grep”命令，其中我们可以过滤在“/boot”文件系统上打开的文件的输出：
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If the preceding command does not produce any output for a while, it is safe
    to proceed with unmounting the filesystem. If the command does print any open
    files, it is best to find the appropriate processes reading/writing to the filesystem
    and stop them before unmounting the filesystem.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的命令一段时间内没有产生任何输出，可以安全地继续卸载文件系统。如果命令打印出任何打开的文件，最好找到适当的进程读取/写入文件系统并在卸载文件系统之前停止它们。
- en: 'Since our example has no open files on the `/boot` filesystem, we can proceed
    with unmounting the `/boot` filesystem. To do this, we will use the `umount` command:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的例子在“/boot”文件系统上没有打开的文件，我们可以继续卸载“/boot”文件系统。为此，我们将使用“umount”命令：
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Luckily the `umount` command finished with no errors. If files were actively
    being written we might have received an error when unmounting. Generally, this
    error consists of a message that states that the **device is busy**. To validate
    that the filesystem was successfully unmounted, we can use the `mount` command
    again:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，“umount”命令没有出现错误。如果文件正在被写入，我们在卸载时可能会收到错误。通常，此错误包括一条消息，指出**设备正忙**。为了验证文件系统已成功卸载，我们可以再次使用“mount”命令：
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now that the `/boot` filesystem is unmounted, we can perform the second step
    in our recovery process. We can now check and repair the filesystem.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在“/boot”文件系统已经卸载，我们可以执行我们恢复过程的第二步。我们现在可以检查和修复文件系统。
- en: Filesystem checks with fsck
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统检查与fsck
- en: Linux has a very useful filesystem check command that can be used to check and
    repair filesystems. This command is called `fsck`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Linux有一个非常有用的文件系统检查命令，可以用来检查和修复文件系统。这个命令叫做“fsck”。
- en: The `fsck` command, however, is not actually just one command. Each filesystem
    type has its own methods of checking consistency and repairing issues. The `fsck`
    command is simply a wrapper that calls the appropriate commands for the filesystem
    in question.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，“fsck”命令实际上并不只是一个命令。每种文件系统类型都有其自己的检查一致性和修复问题的方法。 “fsck”命令只是一个调用相应文件系统的适当命令的包装器。
- en: For example, when the `fsck` command is run against an `ext4` filesystem, the
    command being executed is actually `e2fsck`. The `e2fsck` command is used for
    the `ext2` through `ext4` filesystem types.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当对“ext4”文件系统运行“fsck”命令时，实际执行的命令是“e2fsck”。 “e2fsck”命令用于“ext2”到“ext4”文件系统类型。
- en: We can call `e2fsck` in two ways, either directly or indirectly via the `fsck`
    command. In this example, we will use the `fsck` method, as this can be used for
    almost all filesystems supported by Linux.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以两种方式调用“e2fsck”，直接或间接通过“fsck”命令。在这个例子中，我们将使用“fsck”方法，因为这可以用于Linux支持的几乎所有文件系统。
- en: 'To use the `fsck` command to simply check the filesystem for consistency, we
    can run it with no flags and specify the disk device to be checked:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用“fsck”命令简单地检查文件系统的一致性，我们可以不带标志运行它，并指定要检查的磁盘设备：
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding example, we can see that the filesystem did not identify any
    errors. If it did, we would have been asked if we wanted the `e2fsck` utility
    to correct those errors.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以看到文件系统没有发现任何错误。如果有的话，我们会被问及是否希望“e2fsck”实用程序来纠正这些错误。
- en: 'If we wanted to, we could have `fsck` automatically repair the issues found
    by passing it the `–y` (yes) flag:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以通过传递“-y”（是）标志使“fsck”自动修复发现的问题：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: At this point, the `e2fsck` command will attempt to correct any errors it finds.
    Luckily from our example, the errors were able to be corrected; however, there
    are occasions where this is not the case.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，“e2fsck”命令将尝试纠正它发现的任何错误。幸运的是，从我们的例子中，错误能够被纠正；然而，也有时候情况并非如此。
- en: The fsck and xfs filesystems
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: fsck和xfs文件系统
- en: 'When the `fsck` command is run against an `xfs` filesystem; the outcome is
    actually quite different:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当对“xfs”文件系统运行“fsck”命令时，结果实际上是完全不同的：
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `xfs` filesystem is different from the `ext2/3/4` family of filesystems,
    in that a consistency check is performed each time the filesystem is mounted.
    This does not mean that you cannot check and repair the filesystem manually. To
    check an `xfs` filesystem, we can use the `xfs_repair` utility:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: “xfs”文件系统不同于“ext2/3/4”文件系统系列，因为每次挂载文件系统时都会执行一致性检查。这并不意味着您不能手动检查和修复文件系统。要检查“xfs”文件系统，我们可以使用“xfs_repair”实用程序：
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When executed with the `–n` (no modify) flag followed by the device to check,
    the `xfs_repair` utility will only validate the consistency of the filesystem.
    When run in this mode it simply will not attempt to repair the filesystem.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-n`（不修改）标志后跟要检查的设备执行`xfs_repair`实用程序时，它只会验证文件系统的一致性。在这种模式下运行时，它根本不会尝试修复文件系统。
- en: 'To run `xfs_repair` in a mode that will repair the filesystem simply omit the
    `–n` flag, as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要以修复文件系统的模式运行`xfs_repair`，只需省略`-n`标志，如下所示：
- en: '[PRE55]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: From the output of the preceding `xfs_repair` command it seems our `/boot` filesystem
    did not require any repair process.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的`xfs_repair`命令的输出来看，我们的`/boot`文件系统似乎不需要任何修复过程。
- en: How do these tools repair a filesystem?
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这些工具是如何修复文件系统的？
- en: You might think that it was quite easy to repair this filesystem with tools
    such as `fsck` and `xfs_repair`. The reason for that is simply due to the design
    of filesystems such as `xfs` and `ext2/3/4`. Both `xfs` and the `ext2/3/4` family
    are journaling filesystems; what this means is that these types of filesystems
    will keep a log of changes being made to filesystem objects (such as files, directories,
    and so on).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能会认为使用`fsck`和`xfs_repair`等工具修复这个文件系统非常容易。原因很简单，这是因为`xfs`和`ext2/3/4`等文件系统的设计。`xfs`和`ext2/3/4`家族都是日志文件系统；这意味着这些类型的文件系统会记录对文件系统对象（如文件、目录等）所做的更改。 '
- en: These changes will be kept in this log until the changes are committed to the
    main filesystem. The `xfs_repair` utility simply looks through this log and replays
    the last changes that were not committed to the main filesystem. These filesystem
    journals allow the filesystem to be very resilient in cases such as unexpected
    power loss or a reboot of the system.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改将保存在日志中，直到更改提交到主文件系统。`xfs_repair`实用程序只是查看这个日志，并重放未提交到主文件系统的最后更改。这些文件系统日志使文件系统在意外断电或系统重新启动等情况下非常有韧性。
- en: Unfortunately, sometimes the filesystem's journal and tools such as `xfs_repair`
    are not enough to correct the situation.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，有时文件系统的日志和诸如`xfs_repair`之类的工具并不足以纠正情况。
- en: In cases like these, there are some more options such as running the repair
    in a forceful mode. However, these options should always be reserved for a last
    ditch effort as they can sometimes in themselves cause filesystem corruption.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，还有一些更多的选项，比如以强制模式运行修复。然而，这些选项应该总是保留作为最后的努力，因为它们有时会导致文件系统损坏。
- en: If you do find yourself with a corrupted and unrepairable filesystem, it might
    simply be best to recreate the filesystem and restore backups, if you have backups
    that is...
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己有一个损坏且无法修复的文件系统，最好的办法可能就是重新创建文件系统并恢复备份，如果有备份的话...
- en: Mounting the filesystem
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载文件系统
- en: 'Now that the `/boot` filesystem has been checked and repaired, we can simply
    remount it to validate that the data is correct. To do this, we can simply run
    the `mount` command followed by `/boot`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`/boot`文件系统已经经过检查和修复，我们可以简单地重新挂载它以验证数据是否正确。为此，我们可以简单地运行`mount`命令，然后跟上`/boot`：
- en: '[PRE56]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When a filesystem is defined in the `/etc/fstab` file, the `mount` and `umount`
    commands can be called with just the `mount` point. This will cause these two
    commands to `mount` or `unmount` the filesystem according to it's definition within
    the `/etc/fstab` file.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件系统在`/etc/fstab`文件中定义时，可以只使用`mount`点调用`mount`和`umount`命令。这将导致这两个命令根据`/etc/fstab`文件中的定义来`mount`或`unmount`文件系统。
- en: 'It appears from the output of `mount` that our `/boot` filesystem is now `Read-Write`
    rather than `Read-Only`. If we perform an `ls` command, we should also still see
    our original data:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 从`mount`的输出来看，我们的`/boot`文件系统现在是`读写`而不是`只读`。如果我们执行`ls`命令，我们也应该仍然看到我们的原始数据：
- en: '[PRE57]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It appears that our recovery steps were a success! Now that we have tested them
    with the `/boot` filesystem, we can move to repairing the `/nfs` filesystem.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 看来我们的恢复步骤取得了成功！现在我们已经用`/boot`文件系统测试过它们，我们可以开始修复`/nfs`文件系统了。
- en: Repairing the other filesystems
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复其他文件系统
- en: 'The steps to repair the `/nfs` filesystem are actually going to be the same
    as the `/boot` filesystem with only one major difference, as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 修复`/nfs`文件系统的步骤实际上与`/boot`文件系统的步骤基本相同，只有一个主要的区别，如下所示：
- en: '[PRE58]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When checking for open files on the `/nfs` filesystem with `lsof`, we might
    not see the NFS service processes. However, there is a high likelihood that the
    NFS service will attempt to access files within this shared filesystem after the
    `lsof` command is stopped. To prevent this scenario, it is always best (when possible)
    to stop the NFS service when performing any changes to a shared filesystem:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`lsof`检查`/nfs`文件系统上的打开文件时，我们可能看不到NFS服务进程。然而，很有可能NFS服务在`lsof`命令停止后会尝试访问这个共享文件系统中的文件。为了防止这种情况，最好（如果可能的话）在对共享文件系统进行任何更改时停止NFS服务：
- en: '[PRE59]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Once the NFS service is stopped, the rest of the steps are the same:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦NFS服务停止，其余步骤都是一样的：
- en: '[PRE60]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Once the filesystem has been repaired, we can simply remount it as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统修复后，我们可以简单地按如下方式重新挂载它：
- en: '[PRE61]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: After remounting the `/nfs` filesystem, we can see the options show `rw`, which
    means it is `Read-Writable`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 重新挂载`/nfs`文件系统后，我们可以看到选项显示为`rw`，这意味着它是`可读写`的。
- en: Recovering the / (root) filesystem
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恢复`/`（根）文件系统
- en: The `/` or `root` filesystem is a little different. It is different because
    it is the top-level filesystem that contains the majority of the Linux packages,
    binaries, and commands. This means that we cannot simply unmount this filesystem
    without losing the tools necessary to remount it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`/`或`root`文件系统有点不同。它不同，因为它是包含大部分Linux软件包、二进制文件和命令的顶层文件系统。这意味着我们不能简单地卸载这个文件系统，否则就会丢失重新挂载它所需的工具。'
- en: 'For this reason, we will actually use the `mount` command to remount the `/`
    filesystem without having to unmount it first:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们实际上将使用`mount`命令重新挂载`/`文件系统，而无需先卸载它：
- en: '[PRE62]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In order to tell the `mount` command to unmount and then remount the filesystem,
    we simply need to pass the `–o` (options) flag followed by the option `remount`.
    The `–o` flag allows you to pass filesystem options such as `rw` or `ro` from
    the command line. When we remount the / filesystem, we are simply passing the
    remount filesystem option:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告诉`mount`命令卸载然后重新挂载文件系统，我们只需要传递`-o`（选项）标志，后面跟着选项`remount`。`-o`标志允许您从命令行传递文件系统选项，如`rw`或`ro`。当我们重新挂载`/`文件系统时，我们只是传递重新挂载文件系统选项：
- en: '[PRE63]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If we use the `mount` command to show the mounted filesystems, we can validate
    that the `/` filesystem has been remounted with `Read-Write` access. Since the
    filesystem type is `xfs`, the remount should have caused the filesystem to perform
    a consistency check and repair. If we have any doubts of the integrity of the
    `/` filesystem, our next step should be to simply reboot the NFS server.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`mount`命令来显示已挂载的文件系统，我们可以验证`/`文件系统已重新挂载为`读写`访问。由于文件系统类型为`xfs`，重新挂载应该导致文件系统执行一致性检查和修复。如果我们对`/`文件系统的完整性有任何疑问，下一步应该是简单地重新启动NFS服务器。
- en: If the server is unable to mount the `/` filesystem, the `xfs_repair` utility
    will be called automatically.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器无法挂载`/`文件系统，`xfs_repair`实用程序将自动调用。
- en: Validation
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证
- en: 'At this point, we can see that the NFS server''s filesystems issues have been
    recovered. We should now validate that our NFS client is able to write to the
    NFS share. But before we do that, we should also first restart the NFS service
    we stopped earlier:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们可以看到NFS服务器的文件系统问题已经恢复。我们现在应该验证我们的NFS客户端能否写入NFS共享。但在这之前，我们还应该先重新启动之前停止的NFS服务：
- en: '[PRE64]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Once the NFS service is started, we can test from the client using the `touch`
    command:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦NFS服务启动，我们可以使用`touch`命令从客户端进行测试：
- en: '[PRE65]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: It appears that we have successfully corrected our issue.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已经成功解决了问题。
- en: As a side note, if we noticed that requests to the NFS share were taking a long
    time, It might be necessary to unmount and mount the NFS share on the client side.
    This is a common issue if the NFS client has not identified that the NFS server
    has been restarted.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果我们注意到对NFS共享的请求花费了很长时间，可能需要在客户端上卸载并重新挂载NFS共享。如果NFS客户端没有意识到NFS服务器已重新启动，这是一个常见问题。
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a rather deep dive into how filesystems are mounted,
    how NFS is configured and what to do in case of filesystems going into the `Read-Only`
    mode. We even took that a step further and manually repaired a filesystem where
    the physical disk device was having issues.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了文件系统的挂载方式，NFS的配置以及文件系统进入`只读`模式时应该采取的措施。我们甚至进一步手动修复了一个物理磁盘设备出现问题的文件系统。
- en: In the next chapter, we will take this same issue further by troubleshooting
    hardware failures. This means looking at logs for hardware messages, troubleshooting
    hard drive RAID sets, and many other hardware-related troubleshooting steps.**
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步解决硬件故障的问题。这意味着查看硬件消息日志，解决硬盘RAID集的故障以及许多其他与硬件相关的故障排除步骤。
