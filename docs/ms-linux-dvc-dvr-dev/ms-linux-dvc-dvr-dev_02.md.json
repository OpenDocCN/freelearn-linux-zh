["```\n#define DEFINE_SPINLOCK(x) spinlock_t x = __SPIN_LOCK_UNLOCKED(x)\n```", "```\nstatic DEFINE_SPINLOCK(foo_lock)\n```", "```\nstruct bigger_struct {\u00a0\u00a0\u00a0\u00a0spinlock_t lock;\u00a0\u00a0\u00a0\u00a0unsigned int foo;\u00a0\u00a0\u00a0\u00a0[...]};\nstatic struct bigger_struct *fake_alloc_init_function(){\u00a0\u00a0\u00a0\u00a0struct bigger_struct *bs;\u00a0\u00a0\u00a0\u00a0bs = kmalloc(sizeof(struct bigger_struct), GFP_KERNEL);\u00a0\u00a0\u00a0\u00a0if (!bs)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -ENOMEM;\u00a0\u00a0\u00a0\u00a0spin_lock_init(&bs->lock);\u00a0\u00a0\u00a0\u00a0return bs;}\n```", "```\nvoid spin_unlock(spinlock_t *lock)\nvoid spin_lock(spinlock_t *lock)\n```", "```\nvoid spin_unlock_irq(spinlock_t *lock);\nvoid spin_lock_irq(spinlock_t *lock);\n```", "```\nspin_lock_irqsave(spinlock_t *lock, unsigned long flags)\nspin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)\n```", "```\nstruct mutex {\n\u00a0\u00a0\u00a0\u00a0atomic_long_t owner;\n\u00a0\u00a0\u00a0\u00a0spinlock_t wait_lock;\n#ifdef CONFIG_MUTEX_SPIN_ON_OWNER\n\u00a0\u00a0\u00a0\u00a0struct optimistic_spin_queue osq; /* Spinner MCS lock */\n#endif\n\u00a0\u00a0\u00a0\u00a0struct list_head wait_list;\n[...]\n};\n```", "```\nstatic DEFINE_MUTEX(my_mutex);\n```", "```\n#define DEFINE_MUTEX(mutexname) \\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct mutex mutexname = __MUTEX_INITIALIZER(mutexname)\n```", "```\nstruct fake_data {\n\u00a0\u00a0\u00a0\u00a0struct i2c_client *client;\n\u00a0\u00a0\u00a0\u00a0u16 reg_conf;\n\u00a0\u00a0\u00a0\u00a0struct mutex mutex;\n};\nstatic int fake_probe(struct i2c_client *client, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const struct i2c_device_id *id)\n{\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0mutex_init(&data->mutex);\n\u00a0\u00a0\u00a0\u00a0[...]\n}\n```", "```\nvoid mutex_lock(struct mutex *lock);\nint mutex_lock_interruptible(struct mutex *lock);\nint mutex_lock_killable(struct mutex *lock);\n```", "```\nvoid mutex_unlock(struct mutex *lock);\n```", "```\nstatic bool mutex_is_locked(struct mutex *lock)\n```", "```\n * - only one task can hold the mutex at a time\n * - only the owner can unlock the mutex\n * - multiple unlocks are not permitted\n * - recursive locking is not permitted\n * - a mutex object must be initialized via the API\n * - a mutex object must not be initialized via memset or \u00a0\u00a0\u00a0\u00a0\u00a0copying\n * - task may not exit with mutex held\n * - memory areas where held locks reside must not be freed\n * - held mutexes must not be reinitialized\n * - mutexes may not be used in hardware or software interrupt\n *\u00a0\u00a0\u00a0contexts such as tasklets and timers\n```", "```\nint mutex_trylock(struct mutex *lock)\n```", "```\nstatic DEFINE_SPINLOCK(foo_lock);\n[...]\nstatic void foo(void)\n{\n[...]\n\u00a0\u00a0\u00a0\u00a0if (!spin_trylock(&foo_lock)) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* Failure! the spinlock is already locked */\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[...]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0/*\u00a0\u00a0\u00a0\u00a0\u00a0* reaching this part of the code means \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0that the \u00a0\u00a0\u00a0\u00a0\u00a0* spinlock has been successfully locked \u00a0\u00a0\u00a0\u00a0\u00a0*/\n[...]\n\u00a0\u00a0\u00a0\u00a0spin_unlock(&foo_lock);\n[...]\n}\n```", "```\nstatic DEFINE_MUTEX(bar_mutex);[...]\nstatic void bar (void){\n[...]\u00a0\u00a0\u00a0\u00a0if (!mutex_trylock(&bar_mutex))\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* Failure! the mutex is already locked */\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[...]\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0/*\u00a0\u00a0\u00a0\u00a0\u00a0* reaching this part of the code means that the mutex has \u00a0\u00a0\u00a0\u00a0\u00a0* been successfully locked \u00a0\u00a0\u00a0\u00a0\u00a0*/\n[...]\u00a0\u00a0\u00a0\u00a0mutex_unlock(&bar_mutex);[...]\n}\n```", "```\nstruct completion {\n\u00a0\u00a0\u00a0\u00a0unsigned int done;\n\u00a0\u00a0\u00a0\u00a0wait_queue_head_t wait;\n};\n```", "```\nvoid wait_for_completion(struct completion *comp);\n```", "```\nvoid complete(struct completion *comp);\nvoid complete_all(struct completion *comp);\n```", "```\nCPU#1\t\t\t\t\t\t\tCPU#2\nstruct completion setup_done;\ninit_completion(&setup_done);\ninitialize_work(...,&setup_done,...);\n/* run non-dependent code */ \t\t/* do some setup */\n[...]\t\t\t\t\t\t\t[...]\nwait_for_completion(&setup_done); \t\tcomplete(setup_done);\n```", "```\nint wait_for_completion_interruptible(struct completion *done)\nlong wait_for_completion_interruptible_timeout(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct completion *done, unsigned long timeout)\nlong wait_for_completion_killable(struct completion *done)\nlong wait_for_completion_killable_timeout(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct completion *done, unsigned long timeout)\n```", "```\nstruct wait_queue_head {\n\u00a0\u00a0\u00a0\u00a0spinlock_t lock;\n\u00a0\u00a0\u00a0\u00a0struct list_head head;\n};\n```", "```\nDECLARE_WAIT_QUEUE_HEAD(my_event);\n```", "```\nwait_queue_head_t my_event;\ninit_waitqueue_head(&my_event);\n```", "```\nwait_event(&my_event, (event_occurred == 1) );\n/* or */\nwait_event_interruptible(&my_event, (event_occurred == 1) );\n```", "```\nwait_event_timeout(wq_head, condition, timeout)\n```", "```\nunsigned long msecs_to_jiffies(const unsigned int m)\nunsigned long usecs_to_jiffies(const unsigned int u)\n```", "```\n/* wakes up only one process from the wait queue. */\nwake_up(&my_event);\n/* wakes up all the processes on the wait queue. */\nwake_up_all(&my_event);:\n/* wakes up only one process from the wait queue that is in  * interruptible sleep. \n */ \nwake_up_interruptible(&my_event)\n/* wakes up all the processes from the wait queue that\n * are in interruptible sleep.\n */\nwake_up_interruptible_all(&my_event);\n```", "```\n#include <linux/module.h>#include <linux/init.h>#include <linux/sched.h>#include <linux/time.h>#include <linux/delay.h>#include<linux/workqueue.h>\nstatic DECLARE_WAIT_QUEUE_HEAD(my_wq);static int condition = 0;\n/* declare a work queue*/static struct work_struct wrk;\nstatic void work_handler(struct work_struct *work)\n{\n\u00a0\u00a0\u00a0\u00a0pr_info(\u201cWaitqueue module handler %s\\n\u201d, __FUNCTION__);\n\u00a0\u00a0\u00a0\u00a0msleep(5000);\n\u00a0\u00a0\u00a0\u00a0pr_info(\u201cWake up the sleeping module\\n\u201d);\n\u00a0\u00a0\u00a0\u00a0condition = 1;\n\u00a0\u00a0\u00a0\u00a0wake_up_interruptible(&my_wq);\n}\nstatic int __init my_init(void)\n{\n\u00a0\u00a0\u00a0\u00a0pr_info(\u201cWait queue example\\n\u201d);\n\u00a0\u00a0\u00a0\u00a0INIT_WORK(&wrk, work_handler);\n\u00a0\u00a0\u00a0\u00a0schedule_work(&wrk);\n\u00a0\u00a0\u00a0\u00a0pr_info(\u201cGoing to sleep %s\\n\u201d, __FUNCTION__);\n\u00a0\u00a0\u00a0\u00a0wait_event_interruptible(my_wq, condition != 0);\n\u00a0\u00a0\u00a0\u00a0pr_info(\u201cwoken up by the work job\\n\u201d);\n\u00a0\u00a0\u00a0\u00a0return 0;}\nvoid my_exit(void)\n{\n\u00a0\u00a0\u00a0\u00a0pr_info(\u201cwaitqueue example cleanup\\n\u201d);\n}\nmodule_init(my_init);module_exit(my_exit);MODULE_AUTHOR(\u201cJohn Madieu <john.madieu@labcsmart.com>\u201d);MODULE_LICENSE(\u201cGPL\u201d);\n```", "```\n[342081.385491] Wait queue example\n[342081.385505] Going to sleep my_init\n[342081.385515] Waitqueue module handler work_handler\n[342086.387017] Wake up the sleeping module\n[342086.387096] woken up by the work job\n[342092.912033] waitqueue example cleanup\n```", "```\nif (wait_event_interruptible(...)){\n\u00a0\u00a0\u00a0\u00a0pr_info(\u201ccatching a signal supposed make us crashing\\n\u201d);\n\u00a0\u00a0\u00a0\u00a0/* handle this case and do not access data */\n\u00a0\u00a0\u00a0\u00a0[\u2026.]\n} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0/* accessing data and processing it */\n\u00a0\u00a0\u00a0\u00a0[\u2026]\n}\n```", "```\nstruct softirq_action {\n\u00a0\u00a0\u00a0\u00a0void (*action)(struct softirq_action *);\n};\n```", "```\nvoid softirq_handler(struct softirq_action *h)\n```", "```\nvoid open_softirq(int nr, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void (*action)(struct softirq_action *))\n```", "```\nenum\n{\n\u00a0\u00a0\u00a0\u00a0HI_SOFTIRQ=0,\u00a0\u00a0\u00a0/* High-priority tasklets */\u00a0\u00a0\u00a0\u00a0TIMER_SOFTIRQ,\u00a0\u00a0/* Timers */\u00a0\u00a0\u00a0\u00a0NET_TX_SOFTIRQ, /* Send network packets */\u00a0\u00a0\u00a0\u00a0NET_RX_SOFTIRQ, /* Receive network packets */\u00a0\u00a0\u00a0\u00a0BLOCK_SOFTIRQ,\u00a0\u00a0/* Block devices */\u00a0\u00a0\u00a0\u00a0BLOCK_IOPOLL_SOFTIRQ, /* Block devices with I/O polling \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0blocked on other CPUs */\u00a0\u00a0\u00a0\u00a0TASKLET_SOFTIRQ, /* Normal Priority tasklets */\u00a0\u00a0\u00a0\u00a0SCHED_SOFTIRQ,\u00a0\u00a0\u00a0/* Scheduler */\u00a0\u00a0\u00a0\u00a0HRTIMER_SOFTIRQ, /* High-resolution timers */\u00a0\u00a0\u00a0\u00a0RCU_SOFTIRQ,\u00a0\u00a0\u00a0\u00a0\u00a0/* RCU locking */\u00a0\u00a0\u00a0\u00a0NR_SOFTIRQS\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* This only represent the number or \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* softirqs type, 10 actually \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*/\n};\n```", "```\nconst char * const softirq_to_name[NR_SOFTIRQS] = {\n\u00a0\u00a0\u00a0\u00a0\u201cHI\u201d, \u201cTIMER\u201d, \u201cNET_TX\u201d, \u201cNET_RX\u201d, \u201cBLOCK\u201d, \u201cBLOCK_IOPOLL\u201d,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u201cTASKLET\u201d, \u201cSCHED\u201d, \u201cHRTIMER\u201d, \u201cRCU\u201d\n};\n```", "```\n~$ cat /proc/softirqs \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CPU0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CPU1\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CPU2\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CPU3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0HI:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a014026\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a089\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0491\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0104\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TIMER:\u00a0\u00a0\u00a0\u00a0\u00a0862910\u00a0\u00a0\u00a0\u00a0\u00a0817640\u00a0\u00a0\u00a0\u00a0\u00a0816676\u00a0\u00a0\u00a0\u00a0\u00a0808172\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0NET_TX:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0NET_RX:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01249\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0860\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0939\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01184\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0BLOCK:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0130\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0100\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0138\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0145\n\u00a0\u00a0\u00a0\u00a0IRQ_POLL:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\n\u00a0\u00a0\u00a0\u00a0\u00a0TASKLET:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a055947\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a023\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0108\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0188\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0SCHED:\u00a0\u00a0\u00a0\u00a01192596\u00a0\u00a0\u00a0\u00a0\u00a0967411\u00a0\u00a0\u00a0\u00a0\u00a0882492\u00a0\u00a0\u00a0\u00a0\u00a0835607\n\u00a0\u00a0\u00a0\u00a0\u00a0HRTIMER:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0RCU:\u00a0\u00a0\u00a0\u00a0\u00a0314100\u00a0\u00a0\u00a0\u00a0\u00a0302251\u00a0\u00a0\u00a0\u00a0\u00a0304380\u00a0\u00a0\u00a0\u00a0\u00a0298610\n~$\n```", "```\nstatic struct softirq_action softirq_vec[NR_SOFTIRQS] ;\n```", "```\nvoid open_softirq(int nr, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void (*action)(struct softirq_action *))\n{\n\u00a0\u00a0\u00a0\u00a0softirq_vec[nr].action = action;\n}\n```", "```\nopen_softirq(NET_TX_SOFTIRQ, net_tx_action);\nopen_softirq(NET_RX_SOFTIRQ, net_rx_action);\n```", "```\nvoid __raise_softirq_irqoff(unsigned int nr)\nvoid raise_softirq_irqoff(unsigned int nr)\nvoid raise_softirq(unsigned int nr)\n```", "```\nirq_cpustat_t irq_stat[NR_CPUS] ____cacheline_aligned;\nEXPORT_SYMBOL(irq_stat);\n```", "```\nstatic __init int spawn_ksoftirqd(void)\n{\n\u00a0\u00a0cpuhp_setup_state_nocalls(CPUHP_SOFTIRQ_DEAD, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u201csoftirq:dead\u201d, NULL,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0takeover_tasklets);\n\u00a0\u00a0\u00a0\u00a0BUG_ON(smpboot_register_percpu_thread(&softirq_threads));\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\nearly_initcall(spawn_ksoftirqd);\n```", "```\nstruct tasklet_struct {\n\u00a0\u00a0\u00a0\u00a0struct tasklet_struct *next; /* next tasklet in the list */\n\u00a0\u00a0\u00a0\u00a0unsigned long state;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* state of the tasklet,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* TASKLET_STATE_SCHED or\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* TASKLET_STATE_RUN */\n\u00a0\u00a0\u00a0\u00a0atomic_t count;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* reference counter */\n\u00a0\u00a0\u00a0\u00a0void (*func)(unsigned long); /* tasklet handler function */\n\u00a0\u00a0\u00a0\u00a0unsigned long data; /* argument to the tasklet function */\n};\n```", "```\nDECLARE_TASKLET(name, func, data)\nDECLARE_TASKLET_DISABLED(name, func, data);\ntasklet_init(t, tasklet_handler, dev);\nvoid tasklet_enable(struct tasklet_struct*);\nvoid tasklet_disable(struct tasklet_struct *);\nvoid tasklet_schedule(struct tasklet_struct *t);\nvoid tasklet_hi_schedule(struct tasklet_struct *t);\n```", "```\nvoid tasklet_kill(struct tasklet_struct *t);\n```", "```\n#include <linux/kernel.h>#include <linux/module.h>#include <linux/interrupt.h> /* for tasklets API */\nchar tasklet_data[] =\u00a0\u00a0\u00a0\u00a0\u00a0\u201cWe use a string; but it could be pointer to a structure\u201d;\n/* Tasklet handler, that just prints the data */void tasklet_work(unsigned long data){\u00a0\u00a0\u00a0\u00a0printk(\u201c%s\\n\u201d, (char *)data);}\nstatic DECLARE_TASKLET(my_tasklet, tasklet_function,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(unsigned long) tasklet_data);static int __init my_init(void){\u00a0\u00a0\u00a0\u00a0tasklet_schedule(&my_tasklet);\u00a0\u00a0\u00a0\u00a0return 0;}void my_exit(void){\u00a0\u00a0\u00a0\u00a0tasklet_kill(&my_tasklet);\n}module_init(my_init);module_exit(my_exit);MODULE_AUTHOR(\u201cJohn Madieu <john.madieu@gmail.com>\u201d);MODULE_LICENSE(\u201cGPL\u201d);\n```", "```\nDECLARE_WORK(name, function)\nDECLARE_DELAYED_WORK(name, function)\nINIT_WORK(work, func);\nINIT_DELAYED_WORK(work, func);\n```", "```\nstruct work_struct {\n\u00a0\u00a0\u00a0\u00a0atomic_long_t data;\n\u00a0\u00a0\u00a0\u00a0struct list_head entry;\n\u00a0\u00a0\u00a0\u00a0work_func_t func;\n#ifdef CONFIG_LOCKDEP\n\u00a0\u00a0\u00a0\u00a0struct lockdep_map lockdep_map;\n#endif\n};\nstruct delayed_work {\n\u00a0\u00a0\u00a0\u00a0struct work_struct work;\n\u00a0\u00a0\u00a0\u00a0struct timer_list timer;\n\u00a0\u00a0\u00a0\u00a0/* target workqueue and CPU ->timer uses to queue ->work */\n\u00a0\u00a0\u00a0\u00a0struct workqueue_struct *wq;\n\u00a0\u00a0\u00a0\u00a0int cpu;\n};\n```", "```\ntypedef void (*work_func_t)(struct work_struct *work);\n```", "```\nstruct delayed_work *to_delayed_work(struct work_struct *work)\n```", "```\nstruct workqueue_struct *create_workqueue(const char *name \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0name)\nstruct workqueue_struct\n\u00a0\u00a0\u00a0\u00a0*create_singlethread_workqueue(const char *name)\n```", "```\nbool queue_work(struct workqueue_struct *wq,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct work_struct *work)\nbool queue_delayed_work(struct workqueue_struct *wq,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct delayed_work *dwork,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long delay)\n```", "```\nunsigned long msecs_to_jiffies(const unsigned int m)\nunsigned long usecs_to_jiffies(const unsigned int u)\n```", "```\nschedule_delayed_work(&drvdata->tx_work, usecs_to_\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0jiffies(200));\n```", "```\nbool cancel_work_sync(struct work_struct *work)\nbool cancel_delayed_work(struct delayed_work *dwork)\nbool cancel_delayed_work_sync(struct delayed_work *dwork)\n```", "```\nvoid flush_workqueue(struct worksqueue_struct * queue);\nvoid destroy_workqueue(structure workqueque_struct *queue);\n```", "```\nint schedule_work(struct work_struct *work);\nint schedule_delayed_work(struct delayed_work *dwork,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long delay);\nint schedule_work_on(int cpu, struct work_struct *work);\nint schedule_delayed_work_on(int cpu,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct delayed_work *dwork,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long delay);\n```", "```\nstruct workqueue_struct *system_wq __read_mostly;\nEXPORT_SYMBOL(system_wq);\n```", "```\nvoid flush_scheduled_work(void);\n```", "```\n#define alloc_workqueue(fmt, flags, max_active, args...)\n#define alloc_ordered_workqueue(fmt, flags, args...)\nvoid destroy_workqueue(struct workqueue_struct *wq)\n```", "```\ntypedef irqreturn_t (*irq_handler_t)(int, void *);\n```", "```\nint request_irq(unsigned int irq,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0irq_handler_t handler,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long flags,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *name,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void *dev)\n```", "```\nint devm_request_irq(struct device *dev, unsigned int irq,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0irq_handler_t handler, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long flags,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *name, void *dev)\n```", "```\n#define IRQF_TRIGGER_RISING\u00a0\u00a0\u00a0\u00a00x00000001\n#define IRQF_TRIGGER_FALLING\u00a0\u00a0\u00a00x00000002\n#define IRQF_TRIGGER_HIGH\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00x00000004\n#define IRQF_TRIGGER_LOW\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00x00000008\n#define IRQF_SHARED\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00x00000080\n#define IRQF_PROBE_SHARED\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00x00000100\n#define IRQF_NOBALANCING\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00x00000800\n#define IRQF_IRQPOLL\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00x00001000\n#define IRQF_ONESHOT\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00x00002000\n#define IRQF_NO_SUSPEND\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00x00004000\n#define IRQF_FORCE_RESUME\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00x00008000\n#define IRQF_NO_THREAD\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00x00010000\n#define IRQF_EARLY_RESUME\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00x00020000\n#define IRQF_COND_SUSPEND\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00x00040000\n```", "```\nvoid free_irq(unsigned int irq, void *dev_id)\n```", "```\nvoid devm_free_irq(struct device *dev, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int irq, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void *dev_id)\n```", "```\nint \nrequest_threaded_irq(unsigned int irq, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0irq_handler_t handler,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0irq_handler_t thread_fn, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long irqflags,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *devname, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void *dev_id)\n```", "```\n/*\n * Default primary interrupt handler for threaded interrupts is  * assigned as primary handler when request_threaded_irq is  * called with handler == NULL. Useful for one-shot interrupts.\n */\nstatic irqreturn_t irq_default_primary_handler(int irq, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void *dev_id)\n{\n\u00a0\u00a0\u00a0\u00a0return IRQ_WAKE_THREAD;\n}\nint \nrequest_threaded_irq(unsigned int irq, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0irq_handler_t handler,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0irq_handler_t thread_fn,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long irqflags,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *devname, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void *dev_id)\n{\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0if (!handler) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (!thread_fn)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -EINVAL;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0handler = irq_default_primary_handler;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0[...]\n}\nEXPORT_SYMBOL(request_threaded_irq);\n```", "```\npr_err(\n \u201cThreaded irq requested with handler=NULL and !ONESHOT for irq %d\\n\u201d,\n irq);\n```", "```\nstatic irqreturn_t data_event_handler(int irq, void *dev_id)\n{\n\u00a0\u00a0\u00a0\u00a0struct big_structure *bs = dev_id;\n\u00a0\u00a0\u00a0\u00a0process_data(bs->buffer);\n\u00a0\u00a0\u00a0\u00a0return IRQ_HANDLED;\n}\nstatic int my_probe(struct i2c_client *client,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const struct i2c_device_id *id)\n{\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0if (client->irq > 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = request_threaded_irq(client->irq,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0NULL,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&data_event_handler,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IRQF_TRIGGER_LOW | IRQF_ONESHOT,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0id->name,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0private);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (ret)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0goto error_irq;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0return 0;\nerror_irq:\n\u00a0\u00a0\u00a0\u00a0do_cleanup();\n\u00a0\u00a0\u00a0\u00a0return ret;\n}\n```", "```\nint request_any_context_irq(unsigned int irq,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0irq_handler_t handler,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long flags,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *name,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void *dev_id)\n```", "```\nstatic irqreturn_t packt_btn_interrupt(int irq, void *dev_id)\n{\n\u00a0\u00a0\u00a0\u00a0struct btn_data *priv = dev_id;\n\u00a0\u00a0\u00a0\u00a0input_report_key(priv->i_dev,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0BTN_0,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0gpiod_get_value(priv->btn_gpiod) & 1);\n\u00a0\u00a0\u00a0\u00a0input_sync(priv->i_dev);\n\u00a0\u00a0\u00a0\u00a0return IRQ_HANDLED;\n}\nstatic int btn_probe(struct platform_device *pdev)\n{\n\u00a0\u00a0\u00a0\u00a0struct gpio_desc *gpiod;\n\u00a0\u00a0\u00a0\u00a0int ret, irq;\n\u00a0\u00a0\u00a0\u00a0gpiod = gpiod_get(&pdev->dev, \u201cbutton\u201d, GPIOD_IN);\n\u00a0\u00a0\u00a0\u00a0if (IS_ERR(gpiod))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -ENODEV;\n\u00a0\u00a0\u00a0\u00a0priv->irq = gpiod_to_irq(priv->btn_gpiod);\n\u00a0\u00a0\u00a0\u00a0priv->btn_gpiod = gpiod;\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0ret = request_any_context_irq(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0priv->irq,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0packt_btn_interrupt,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u201cpackt-input-button\u201d,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0priv);\n\u00a0\u00a0\u00a0\u00a0if (ret < 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0goto err_btn;\nreturn 0;\nerr_btn:\n\u00a0\u00a0\u00a0\u00a0do_cleanup();\n\u00a0\u00a0\u00a0\u00a0return ret;\n}\n```", "```\nstruct private_struct {\n\u00a0\u00a0\u00a0\u00a0int counter;\n\u00a0\u00a0\u00a0\u00a0struct work_struct my_work;\n\u00a0\u00a0\u00a0\u00a0void __iomem *reg_base;\n\u00a0\u00a0\u00a0\u00a0spinlock_t lock;\n\u00a0\u00a0\u00a0\u00a0int irq;\n\u00a0\u00a0\u00a0\u00a0/* Other fields */\n\u00a0\u00a0\u00a0\u00a0[...]\n};\n```", "```\nstatic void work_handler(struct work_struct *work)\n{\n\u00a0\u00a0\u00a0\u00a0int i;\n\u00a0\u00a0\u00a0\u00a0unsigned long flags;\n\u00a0\u00a0\u00a0\u00a0struct private_data *my_data =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0container_of(work, struct private_data, my_work);\n\u00a0\u00a0\u00a0/*\n\u00a0\u00a0\u00a0\u00a0* let\u2019s proccessing at least half of MIN_REQUIRED_FIFO_SIZE\n\u00a0\u00a0\u00a0\u00a0* prior to re-enabling the irq at device level, and so that\n\u00a0\u00a0\u00a0\u00a0* buffer further data\n\u00a0\u00a0\u00a0\u00a0*/\n\u00a0\u00a0\u00a0\u00a0for (i = 0, i < MIN_REQUIRED_FIFO_SIZE, i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0device_pop_and_process_data_buffer();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i == MIN_REQUIRED_FIFO_SIZE / 2)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0enable_irq_at_device_level();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0spin_lock_irqsave(&my_data->lock, flags);\n\u00a0\u00a0\u00a0\u00a0my_data->buf_counter -= MIN_REQUIRED_FIFO_SIZE;\n\u00a0\u00a0\u00a0\u00a0spin_unlock_irqrestore(&my_data->lock, flags);\n}\n```", "```\n/* This is our hard-IRQ handler.*/\nstatic irqreturn_t my_interrupt_handler(int irq, void *dev_id)\n{\n\u00a0\u00a0\u00a0\u00a0u32 status;\n\u00a0\u00a0\u00a0\u00a0unsigned long flags;\n\u00a0\u00a0\u00a0\u00a0struct private_struct *my_data = dev_id;\n\u00a0\u00a0\u00a0\u00a0/* Let\u2019s read the status register in order to determine how\n\u00a0\u00a0\u00a0\u00a0\u00a0* and what to do\n\u00a0\u00a0\u00a0\u00a0\u00a0*/\n\u00a0\u00a0\u00a0\u00a0status = readl(my_data->reg_base + REG_STATUS_OFFSET);\n\u00a0\u00a0\u00a0\u00a0/*\n\u00a0\u00a0\u00a0\u00a0\u00a0* Let\u2019s ack this irq at device level. Even if it raises \u00a0\u00a0\u00a0\u00a0\u00a0* another irq, we are safe since this irq remain disabled \u00a0\u00a0\u00a0\u00a0\u00a0* at controller level while we are in this handler\n\u00a0\u00a0\u00a0\u00a0\u00a0*/\n\u00a0\u00a0\u00a0\u00a0writel(my_data->reg_base + REG_STATUS_OFFSET,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0status | MASK_IRQ_ACK);\n\u00a0\u00a0\u00a0\u00a0/*\n\u00a0\u00a0\u00a0\u00a0\u00a0* Protecting the shared resource, since the worker also \u00a0\u00a0\u00a0\u00a0\u00a0* accesses this counter\n\u00a0\u00a0\u00a0\u00a0\u00a0*/\n\u00a0\u00a0\u00a0\u00a0spin_lock_irqsave(&my_data->lock, flags);\n\u00a0\u00a0\u00a0\u00a0my_data->buf_counter++;\n\u00a0\u00a0\u00a0\u00a0spin_unlock_irqrestore(&my_data->lock, flags);\n\u00a0\u00a0\u00a0\u00a0/*\n\u00a0\u00a0\u00a0\u00a0\u00a0* Ok. Our device raised an interrupt in order to inform it \u00a0\u00a0\u00a0\u00a0\u00a0* has some new data in its fifo. But is it enough for us \u00a0\u00a0\u00a0\u00a0\u00a0* to be processed\n\u00a0\u00a0\u00a0\u00a0\u00a0*/\n\u00a0\u00a0\u00a0\u00a0if (my_data->buf_counter != MIN_REQUIRED_FIFO_SIZE)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* ack and re-enable this irq at controller level */\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return IRQ_HANDLED;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/*\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* Right. prior to schedule the worker and returning \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* from this handler, we need to disable the irq at \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* device level\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*/\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0writel(my_data->reg_base + REG_STATUS_OFFSET,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0MASK_IRQ_DISABLE);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0schedule_work(&my_work);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* This will re-enable the irq at controller level */\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return IRQ_HANDLED;\n};\n```", "```\nstatic int foo_probe(struct platform_device *pdev)\n{\n\u00a0\u00a0\u00a0\u00a0struct resource *mem;\n\u00a0\u00a0\u00a0\u00a0struct private_struct *my_data;\n\u00a0\u00a0\u00a0\u00a0my_data = alloc_some_memory(sizeof(struct private_struct));\n\u00a0\u00a0\u00a0\u00a0mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\u00a0\u00a0\u00a0\u00a0my_data->reg_base =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ioremap(ioremap(mem->start, resource_size(mem));\n\u00a0\u00a0\u00a0\u00a0if (IS_ERR(my_data->reg_base))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return PTR_ERR(my_data->reg_base);\n\u00a0\u00a0\u00a0\u00a0\u00a0/*\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* work queue initialization. \u201cwork_handler\u201d is the \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* callback that will be executed when our work is \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0* scheduled.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0*/\n\u00a0\u00a0\u00a0\u00a0\u00a0INIT_WORK(&my_data->my_work, work_handler);\n\u00a0\u00a0\u00a0\u00a0\u00a0spin_lock_init(&my_data->lock);\n\u00a0\u00a0\u00a0\u00a0\u00a0my_data->irq = platform_get_irq(pdev, 0);\n\u00a0\u00a0\u00a0\u00a0\u00a0if (request_irq(my_data->irq, my_interrupt_handler,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00, pdev->name, my_data))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0handler_this_error()\n\u00a0\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```\nstatic int my_probe(struct platform_device *pdev)\n{\n\u00a0\u00a0\u00a0\u00a0int irq;\n\u00a0\u00a0\u00a0\u00a0int ret;\n\u00a0\u00a0\u00a0\u00a0irq = platform_get_irq(pdev, i);\n\u00a0\u00a0\u00a0\u00a0ret = devm_request_threaded_irq(dev, irq, NULL, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0my_threaded_irq,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IRQF_ONESHOT, dev_\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0name(dev),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0my_data);\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0return ret;\n}\nstatic irqreturn_t my_threaded_irq(int irq, void *dev_id)\n{\n\u00a0\u00a0\u00a0\u00a0struct priv_struct *my_data = dev_id;\n\u00a0\u00a0\u00a0\u00a0/* Save FIFO Underrun & Transfer Error status */\n\u00a0\u00a0\u00a0\u00a0mutex_lock(&my_data->fifo_lock);\n\u00a0\u00a0\u00a0\u00a0/* accessing the device\u2019s buffer through i2c */\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0mutex_unlock(&ldev->fifo_lock);\n\u00a0\u00a0\u00a0\u00a0return IRQ_HANDLED;\n}\n```", "```\n    static int my_probe(struct platform_device *pdev)\n    {\n    \u00a0\u00a0\u00a0\u00a0int irq;\n    \u00a0\u00a0\u00a0\u00a0int ret;\n    \u00a0\u00a0\u00a0\u00a0[...]\n    \u00a0\u00a0\u00a0\u00a0irq = platform_get_irq(pdev, 0);\n    \u00a0\u00a0\u00a0\u00a0if (irq < 0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0goto handle_get_irq_error;\n    \u00a0\u00a0\u00a0\u00a0ret = devm_request_threaded_irq(&pdev->dev, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0irq, \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0my_hardirq,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0my_threaded_irq,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0IRQF_ONESHOT,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dev_name(dev), \n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0my_data);\n    \u00a0\u00a0\u00a0\u00a0if (ret < 0)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0goto err_cleanup_irq;\n    \u00a0\u00a0\u00a0\u00a0[...]\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    static irqreturn_t my_hardirq(int irq, void *dev_id)\n    {\n    \u00a0\u00a0\u00a0\u00a0struct priv_struct *my_data = dev_id;\n    \u00a0\u00a0\u00a0\u00a0unsigned long flags;\n    \u00a0\u00a0\u00a0\u00a0/* No need to protect the shared resource */\n    \u00a0\u00a0\u00a0\u00a0my_data->status = __raw_readl(\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0my_data->mmio_base + my_data->foo.reg_offset);\n    \u00a0\u00a0\u00a0\u00a0/* Let us schedule the bottom-half */\n    \u00a0\u00a0\u00a0\u00a0return IRQ_WAKE_THREAD;\n    }\n    static irqreturn_t my_threaded_irq(int irq, void *dev_id)\n    {\n    \u00a0\u00a0\u00a0\u00a0struct priv_struct *my_data = dev_id;\n    \u00a0\u00a0\u00a0\u00a0spin_lock_irqsave(&my_data->lock, flags);\n    \u00a0\u00a0\u00a0\u00a0/* Processing the status status */\n    \u00a0\u00a0\u00a0\u00a0process_status(my_data->status);\n    \u00a0\u00a0\u00a0\u00a0spin_unlock_irqrestore(&my_data->lock, flags);\n    \u00a0\u00a0\u00a0\u00a0[...]\n    \u00a0\u00a0\u00a0\u00a0return IRQ_HANDLED;\n    }\n    ```"]