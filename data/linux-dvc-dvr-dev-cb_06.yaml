- en: Miscellaneous Kernel Internals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杂项内核内部
- en: When developing inside the kernel, we may need to do some miscellaneous activities
    to implement our device drivers, such as dynamically allocating memory and using
    specific data types in order to store register data, or simply actively waiting
    some time in order to be sure that a peripheral has completed its reset procedure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核开发中，我们可能需要执行一些杂项活动来实现我们的设备驱动程序，例如动态分配内存并使用特定的数据类型来存储寄存器数据，或者简单地等待一段时间，以确保外围设备已完成其复位过程。
- en: 'To perform all these tasks, Linux offers to kernel developers a rich set of
    useful functions, macros, and data types that we''ll try to present in this chapter
    through the means of very simple example codes, because we wish to point out to
    the reader how he/she can use them to simplify device driver development. That''s
    why, in this chapter, we will cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行所有这些任务，Linux为内核开发人员提供了一套丰富的有用函数、宏和数据类型，我们将尝试通过非常简单的示例代码在本章中介绍它们，因为我们希望向读者指出如何使用它们来简化设备驱动程序开发。因此，在本章中，我们将涵盖以下内容：
- en: Using kernel data types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内核数据类型
- en: Managing helper functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理辅助函数
- en: Dynamic memory allocation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态内存分配
- en: Managing kernel linked lists
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理内核链表
- en: Using kernel hash tables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内核哈希表
- en: Getting access to I/O memory
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问I/O内存
- en: Spending time in the kernel
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内核中花费时间
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For more information on this chapter, you can visit the *Appendix*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章的更多信息，您可以访问*附录*。
- en: The code and other files used in this chapter can be downloaded from GitHub
    at [https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_06](https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_06).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码和其他文件可以从GitHub下载[https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_06](https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_06)。
- en: Using kernel data types
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内核数据类型
- en: Often, data items of a particular size are required by the kernel code to match
    predefined binary structures, to hold peripheral's register data, to communicate
    with userspace or to simply to align data within structures by inserting padding
    fields.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，内核代码需要特定大小的数据项来匹配预定义的二进制结构，保存外围设备的寄存器数据，与用户空间通信，或者仅仅通过插入填充字段在结构内对齐数据。
- en: Sometimes, kernel code requires data items of a specific size, perhaps to match
    predefined binary structures, to communicate with userspace, to hold peripheral's
    register data, or simply to align data within structures by inserting padding
    fields.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，内核代码需要特定大小的数据项，也许是为了匹配预定义的二进制结构，与用户空间通信，保存外围设备的寄存器数据，或者仅仅通过插入填充字段在结构内对齐数据。
- en: In this section, we're going to see some special data types that can be used
    by kernel developers to simplify their everyday job. In the following, we're going
    to see an example with **fixed-size data types**, which are very useful to define
    some kind of data that is intended to match exactly the structure of data expected
    by a device or by a communication protocol; a careful reader will recognize that
    it wouldn't be possible indeed to define such fixed-size data entities by using
    standard C types, since the C standard does not explicitly guarantee a fixed-size
    representation across all the architectures, when we make use of similar standard
    C types such as `int`, `short`, or `long`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到一些特殊的数据类型，内核开发人员可以使用这些类型来简化他们的日常工作。接下来，我们将看到一个**固定大小数据类型**的示例，这些类型非常有用，可以定义与设备或通信协议期望的数据结构完全匹配的数据类型；细心的读者会认识到，确实无法使用标准C类型来定义这种固定大小的数据实体，因为C标准并没有明确保证在所有架构中都有固定大小的表示，当我们使用类似标准C类型如`int`、`short`或`long`时。
- en: 'The kernel offers the following data types to use whenever we need to know
    the size of our data (their actual definition depends on the currently used architecture,
    but they are named the same across different architectures):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 内核提供以下数据类型，以便在需要知道数据大小时使用（它们的实际定义取决于当前使用的架构，但它们在不同架构中都被命名为相同）：
- en: '`u8`: Unsigned byte (8 bits)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u8`: 无符号字节（8位）'
- en: '`u16`: Unsigned word (16 bits)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u16`: 无符号字（16位）'
- en: '`u32`: Unsigned 32-bit (32 bits)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u32`: 无符号32位（32位）'
- en: '`u64`: Unsigned 64-bit (64 bits)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u64`: 无符号64位（64位）'
- en: '`s8`: Signed byte (8 bits)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s8`: 有符号字节（8位）'
- en: '`s16`: Signed word (16 bits)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s16`: 有符号字（16位）'
- en: '`s32`: Signed 32-bit (32 bits)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s32`: 有符号32位（32位）'
- en: '`s64`: Signed 64-bit (64 bits)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s64`: 有符号64位（64位）'
- en: 'It may also happen that fixed-size data types must be used to exchange data
    with user space; however, in this last case, we cannot use the preceding types,
    but we''ll have to instead opt for the following alternative data types, which
    are equivalent to the preceding ones, but which can be used indifferently within
    both kernel and userspace (this concept will become clearer in the *Using the
    ioctl() method* recipe in [Chapter 7](3a9fe19d-0ba6-4959-bc71-493d9f499cc4.xhtml)*,*
    A*dvanced Char Driver Operations*):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，固定大小的数据类型必须用于与用户空间交换数据；然而，在这种情况下，我们不能使用前面的类型，而必须选择以下替代数据类型，这些类型等同于前面的类型，但可以在内核和用户空间中任意使用（这个概念将在[第7章](3a9fe19d-0ba6-4959-bc71-493d9f499cc4.xhtml)*,*高级字符驱动程序操作*中的*使用ioctl()方法*中变得更加清晰）：
- en: '`__u8`: Unsigned byte (8 bits)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__u8`: 无符号字节（8位）'
- en: '`__u16`: Unsigned word (16 bits)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__u16`: 无符号字（16位）'
- en: '`__u32`: Unsigned 32-bit (32 bits)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__u32`: 无符号32位（32位）'
- en: '`__u64`: Unsigned 64-bit (64 bits)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__u64`: 无符号64位（64位）'
- en: '`__s8`: Signed byte (8 bits)'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__s8`: 有符号字节（8位）'
- en: '`__s16`: Signed word (16 bits)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__s16`: 有符号字（16位）'
- en: '`__s32`: Signed 32-bit (32 bits)'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__s32`: 有符号32位（32位）'
- en: '`__s64`: Signed 64-bit (64 bits)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__s64`: 有符号64位（64位）'
- en: All these fixed-size types are defined in the header file, `linux/include/linux/types.h`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些固定大小的类型都在头文件`linux/include/linux/types.h`中定义。
- en: Getting ready
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: In order to show how to use the preceding data types, we can again use a kernel
    module to execute some kernel code, which uses them to define a register mapping
    within a structure.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何使用前面的数据类型，我们可以再次使用一个内核模块来执行一些内核代码，其中使用它们来定义结构中的寄存器映射。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how to do it by following these steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过以下步骤来做到这一点：
- en: 'Let''s take a look at the `data_type.c` file, where we put all code into the
    module''s `init()` function as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看`data_type.c`文件，我们将所有代码放入模块的`init()`函数中，如下所示：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'After performing *step 1*, the pointer `ptr` is then initialized according
    to the `base_addr` value in such a way that, by simply referencing a field of
    the `struct dtypes_s` (defined in the following code), we can point to the right
    memory address:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行*步骤1*之后，指针`ptr`将根据`base_addr`的值进行初始化，以便通过简单地引用`struct dtypes_s`的字段（在以下代码中定义）来指向正确的内存地址：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: During a structure definition, we should be aware that the compiler may quietly
    insert padding into the structure itself to ensure that every field is properly
    aligned in order to attain good performances on the target processor; a workaround
    to avoid this behavior is to tell the compiler that the structure must be packed,
    with no fillers added. This, of course, can be done by using `__attribute__ ((packed))`, as
    before.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构定义期间，我们应该意识到编译器可能会在结构本身中悄悄地插入填充，以确保每个字段都正确对齐，以便在目标处理器上获得良好的性能；避免这种行为的一种解决方法是告诉编译器结构必须是紧凑的，不添加填充。当然，这可以通过使用`__attribute__
    ((packed))`来实现，就像以前一样。
- en: There's more...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If we wish to verify the step, we can do this by testing the code. We just
    need to compile the module as usual, then move it to the ESPRESSObin, and finally
    insert into the kernel as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望验证这一步，我们可以通过测试代码来做到这一点。我们只需要像往常一样编译模块，然后将其移动到ESPRESSObin，最后按照以下步骤插入内核：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should also get an error message as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该收到以下错误消息：
- en: '`insmod: ERROR: could not insert module data_types.ko: Invalid parameters`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`insmod: ERROR: could not insert module data_types.ko: Invalid parameters`'
- en: However, this is due to the last `return -EINVAL` in the function `data_types_init()`;
    we used this as a trick, here and in the following, to force the kernel to remove
    the module after the module's `init()` function execution.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是由于`data_types_init()`函数中的最后一个`return -EINVAL`；我们在这里和接下来使用这个技巧，强制内核在模块的`init()`函数执行后移除模块。
- en: 'The first lines we get into kernel messages are about the dimensions of type
    `u8`, `u16`, `u32`, and `u64` as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的内核消息中的第一行是关于`u8`、`u16`、`u32`和`u64`类型的维度如下：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, the following lines (still among kernel messages) show to us the perfect
    padding we can achieve by using a struct definition with `u8`, `u16`, `u32`, and
    `u64`, and the `__attribute__ ((packed))` statement:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，以下行（仍然在内核消息中）向我们展示了通过使用带有`u8`、`u16`、`u32`和`u64`的结构定义以及`__attribute__ ((packed))`语句可以实现的完美填充：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: See also
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: A good reference for kernel data types can be found at[ https://kernelnewbies.org/InternalKernelDataTypes](https://kernelnewbies.org/InternalKernelDataTypes).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于内核数据类型的良好参考资料可以在[https://kernelnewbies.org/InternalKernelDataTypes](https://kernelnewbies.org/InternalKernelDataTypes)找到。
- en: Managing helper functions
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理辅助函数
- en: During device driver development, we may need to concatenate a string or to
    compute its length or just copy or move a memory region (or a string). To do these
    common operations in the user space, we can use several functions, such as `strcat()`, `strlen()`, `memcpy()` (or `strcpy()`),
    and so on, and Linux offers us similarly named functions, which, of course, are
    safely usable in the kernel. (Note that kernel code cannot be linked against userspace
    glibc libraries.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备驱动程序开发过程中，我们可能需要连接字符串或计算其长度，或者只是复制或移动内存区域（或字符串）。为了在用户空间执行这些常见操作，我们可以使用几个函数，比如`strcat()`、`strlen()`、`memcpy()`（或`strcpy()`）等等，Linux也为我们提供了类似命名的函数，当然，这些函数在内核中是安全可用的。（请注意，内核代码不能链接到用户空间的glibc库。）
- en: In this recipe, we will see how to use some kernel helpers in order to manage
    strings within the kernel.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将看到如何使用一些内核辅助程序来管理内核中的字符串。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'If we take a look inside kernel sources at the include file `linux/include/linux/string.h`,
    we can see a long list of usual userspace look-alike utility functions, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在内核源代码中查看`linux/include/linux/string.h`包含文件，我们可以看到一长串通常的用户空间类似实用函数，如下所示：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that each function is enclosed into `#ifndef`/`#endif` preprocessor condition
    clauses, because some of these functions can be implemented with some form of
    optimization for an architecture; therefore, their implementation may vary across
    different platforms.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个函数都被包含在`#ifndef`/`#endif`预处理器条件子句中，因为这些函数中的一些可以使用某种形式的优化来实现；因此，它们的实现可能在不同平台上有所不同。
- en: In order to show how to use the preceding helper functions, we can again use
    a kernel module to execute a kernel code that uses some of them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示如何使用前面的辅助函数，我们可以再次使用一个内核模块来执行使用其中一些函数的内核代码。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s see how to do it by following these steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过以下步骤来做到这一点：
- en: In the `helper_funcs.c` file, we can see some really silly code that exemplifies
    how we can use these helper functions.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`helper_funcs.c`文件中，我们可以看到一些非常愚蠢的代码，它演示了我们如何使用这些辅助函数。
- en: You are encouraged to modify this code to play with different kernel helper
    functions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励您修改此代码以使用不同的内核辅助函数。
- en: 'All the work is done inside the module''s `init()` function as it was in the
    preceding section. Here we can use the kernel functions `strlen()` and `strncpy()`
    as their userspace counterparts:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有的工作都是在模块的`init()`函数中完成的，就像在前面的部分一样。在这里，我们可以使用内核函数`strlen()`和`strncpy()`，就像它们的用户空间对应函数一样：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These functions are special kernel implementations and they are not the userspace functions
    we usually use in normal programming. We cannot link a kernel module with the
    glibc!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数是特殊的内核实现，它们不是我们通常在正常编程中使用的用户空间函数。我们不能将内核模块与glibc链接！
- en: 'The `str` string is defined as a module parameter as follows, and it can be
    used to try different strings:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`str`字符串定义为模块参数如下，并且可以用于尝试不同的字符串：'
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There's more...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you wish to test the code in the recipe, you can do so by compiling it and
    then moving it into the ESPRESSObin.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望测试该示例中的代码，可以通过编译它然后将其移动到ESPRESSObin来进行测试。
- en: 'First of all, we have to insert the module into the kernel:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须将模块插入内核：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can safely ignore the following error message, as discussed previously:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以安全地忽略以下错误消息，如之前讨论的那样：
- en: '`insmod: ERROR: could not insert module helper_funcs.ko: Invalid parameters`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`insmod: ERROR: could not insert module helper_funcs.ko: Invalid parameters`'
- en: 'The kernel messages should now look as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 内核消息现在应该如下所示：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding output, we can see that string `str2` is just a copy of `str`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到字符串`str2`只是`str`的副本。
- en: 'However, if we use the following `insmod` command, the output will change as
    follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们使用以下`insmod`命令，输出将会发生变化：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Again, string `str2` is a copy of `str`, but with its maximum size `STR2_LEN`
    defined as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，字符串`str2`是`str`的副本，但其最大大小`STR2_LEN`定义如下：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See also
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: For a more complete list of string manipulation functions, a good starting point
    is at [https://www.kernel.org/doc/htmldocs/kernel-api/ch02s02.html](https://www.kernel.org/doc/htmldocs/kernel-api/ch02s02.html).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关更完整的字符串操作函数列表，一个很好的起点是[https://www.kernel.org/doc/htmldocs/kernel-api/ch02s02.html](https://www.kernel.org/doc/htmldocs/kernel-api/ch02s02.html)。
- en: While regarding string conversion, you can take a look at [https://www.kernel.org/doc/htmldocs/kernel-api/libc.html#id-1.4.3](https://www.kernel.org/doc/htmldocs/kernel-api/libc.html#id-1.4.3).
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于字符串转换，您可以查看[https://www.kernel.org/doc/htmldocs/kernel-api/libc.html#id-1.4.3](https://www.kernel.org/doc/htmldocs/kernel-api/libc.html#id-1.4.3)。
- en: Dynamic memory allocation
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态内存分配
- en: A good device driver should support neither more than one peripheral and (possibly)
    not a fixed number of them! However, even if we decide to restrict driver usage
    to just one peripheral, it may happen that we need to manage a variable number
    of data chunks so, in any case, we need to be able to manage **dynamic memory
    allocation**.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的设备驱动程序不应该支持多个外围设备（可能）也不应该是固定数量的！但是，即使我们决定将驱动程序的使用限制为一个外围设备，也可能需要管理可变数量的数据块，因此无论如何，我们都需要能够管理**动态内存分配**。
- en: In this recipe, we will see how we can dynamically (and safely) allocate chunks
    of memory in the kernel space.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何在内核空间动态（并安全地）分配内存块。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: In order to show how we can allocate from memory within the kernel by using `kmalloc()`, `vmalloc()`,
    and `kvmalloc()`, we can again use a kernel module.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示我们如何通过使用`kmalloc()`、`vmalloc()`和`kvmalloc()`从内核中分配内存，我们可以再次使用一个内核模块。
- en: 'Inside the `mem_alloc.c` file, we can see some really simple code that shows
    how memory allocation works together with the related memory deallocation functions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mem_alloc.c`文件中，我们可以看到一些非常简单的代码，显示了内存分配如何与相关的内存释放函数一起工作：
- en: 'All the work gets done inside the module''s `init()` function as before. The
    first step is using `kmalloc()` with two different flags, that is `GFP_KERNEL` (which
    can sleep) and `GFP_ATOMIC` (which doesn''t sleep and then it can be safely used
    inside the interrupt context):'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有的工作都是在模块的`init()`函数中完成的，就像以前一样。第一步是使用两个不同标志的`kmalloc()`，即`GFP_KERNEL`（可以休眠）和`GFP_ATOMIC`（不休眠，然后可以安全地在中断上下文中使用）：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we try allocating memory by using `vmalloc()`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们尝试使用`vmalloc()`来分配内存：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we try two different allocations by using `kvmalloc()` with two different
    flags, that is `GFP_KERNEL` (which can sleep) and `GFP_ATOMIC` (which doesn''t
    sleep and then it can be safely used inside the interrupt context):'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们尝试使用`kvmalloc()`和两个不同的标志进行两种不同的分配，即`GFP_KERNEL`（可以休眠）和`GFP_ATOMIC`（不休眠，然后可以安全地在中断上下文中使用）：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that, for each allocation function, we must use the related `free()` function!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于每个分配函数，我们必须使用相关的`free()`函数！
- en: 'The size of the memory chunk to allocate is passed as a kernel parameter as
    follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要分配的内存块的大小作为内核参数传递如下：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There's more...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: OK, as you did before, just compile the module and then move it to the ESPRESSObin.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，就像以前一样，只需编译模块，然后将其移动到ESPRESSObin。
- en: 'If we try inserting the module with the default memory size (that is, 4 KB),
    we should get the following kernel messages:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用默认内存大小（即4 KB）插入模块，我们应该会得到以下内核消息：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can safely ignore the following error message as discussed earlier:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以安全地忽略以下错误消息，如前面讨论的那样：
- en: '`insmod: ERROR: could not insert module mem_alloc.ko: Invalid parameters`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`insmod: ERROR: could not insert module mem_alloc.ko: Invalid parameters`'
- en: This shows us that all allocation functions successfully complete their job.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们表明所有分配函数都成功地完成了它们的工作。
- en: 'However, if we try to increase the memory chunk as follows, something changes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们尝试增加内存块大小如下，会发生一些变化：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now the `kmalloc()` functions fail, while `vmalloc()` is still successful due
    to the fact it allocates on the virtual memory space over non-contiguous physical
    addresses. On the other hand, `kvmalloc()` succeeds when invoked with the flag `GFP_KERNEL`
    while it fails with the flag `GFP_ATOMIC`. (This is due to the fact that it cannot
    use `vmalloc()` as a fallback in this special situation.)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`kmalloc()`函数失败，而`vmalloc()`由于它在非连续物理地址上分配虚拟内存空间而仍然成功。另一方面，当使用标志`GFP_KERNEL`调用`kvmalloc()`时成功，而使用标志`GFP_ATOMIC`时失败。（这是因为在这种特殊情况下它不能使用`vmalloc()`作为后备。）
- en: See also
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: For further information about memory allocation, a good starting point is [https://www.kernel.org/doc/html/latest/core-api/memory-allocation.html](https://www.kernel.org/doc/html/latest/core-api/memory-allocation.html).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关内存分配的更多信息，一个很好的起点是[https://www.kernel.org/doc/html/latest/core-api/memory-allocation.html](https://www.kernel.org/doc/html/latest/core-api/memory-allocation.html)。
- en: Managing kernel linked lists
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理内核链接列表
- en: When programming inside the kernel, it could be useful to have the ability to
    manage lists of data, so, to reduce the amount of duplicated code, kernel developers
    have created a standard implementation of circular, doubly linked lists.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核内编程时，有能力管理数据列表可能非常有用，为了减少重复的代码量，内核开发人员创建了循环双向链表的标准实现。
- en: In this recipe, we will see how to use lists in our code by using the Linux
    API.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何使用Linux API在我们的代码中使用列表。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To demonstrate how the list API works, we can again use a kernel module where
    we do some operations inside the module's `init()` function, as done previously.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示列表API的工作原理，我们可以再次使用内核模块，在模块的`init()`函数中执行一些操作，就像以前一样。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the `list.c` file, there is our example code where all games are played
    inside `list_init()` function:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`list.c`文件中，有我们的示例代码，所有游戏都在`list_init()`函数中进行：
- en: 'As the first step, let''s take a look at the declaration of the structure implementing
    a list element and the head of the list:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看一下实现列表元素和列表头的结构的声明：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, in `list_init()`, we define our elements:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`list_init()`中，我们定义了我们的元素：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we add the first element to the list and we print it:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们向列表中添加第一个元素并打印它：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we continue adding elements and print the list:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们继续添加元素并打印列表：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we delete an element:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们删除一个元素：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let''s see the local function definition; to add an element in ordered
    mode, we can do the following:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看本地函数定义；要以有序模式添加元素，我们可以这样做：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Meanwhile, the entry deletion can be done as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与此同时，可以按照以下步骤进行条目删除：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, the printing of all elements in the list can be achieved as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，可以通过以下方式打印列表中的所有元素：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this last function, we use the macro `list_for_each_entry()` instead of the
    pair `list_for_each()` and `list_entry()`, to get more compact and readable code,
    which essentially performs the same steps.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的函数中，我们使用宏`list_for_each_entry()`而不是`list_for_each()`和`list_entry()`的组合，以获得更紧凑和可读的代码，它本质上执行相同的步骤。
- en: 'The macro is defined in the `linux/include/linux/list.h` file as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 该宏在`linux/include/linux/list.h`文件中定义如下：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There's more...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can test the code after compilation and insertion into ESPRESSObin''s kernel.
    To insert the kernel, we do the usual `insmod` command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在编译并插入到ESPRESSObin的内核后测试代码。要插入内核，我们使用通常的`insmod`命令：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can safely ignore the following error message as discussed earlier:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以安全地忽略以下错误消息，如前所述：
- en: '`insmod: ERROR: could not insert module list.ko: Invalid parameters`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`insmod: ERROR: could not insert module list.ko: Invalid parameters`'
- en: 'Then, after the first insertion, we have the following kernel message:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第一次插入后，我们得到了以下内核消息：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In *step 1* and *step 2*, we have defined the elements of our list, while, in
    *step 3* we have done the first insert into the list, and the preceding message
    is what we get after the insertion.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*和*步骤2*中，我们定义了列表的元素，而在*步骤3*中，我们进行了第一次插入到列表中，之前的消息是插入后得到的结果。
- en: 'After the second insertion in *step 4*, we get the following instead:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中进行第二次插入后，我们得到了以下结果：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, after the deletion of *step 5*, the list becomes as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*步骤5*删除后，列表变为如下：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that, in *step 6*, we presented a possible implementation of element insertion
    within the list in ordered mode but, of course, it's up to the developer use the
    best solution. The same considerations can be done for *step 7*, where we have
    implemented the element removal, while in *step 8*, we have the printing function.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在*步骤6*中，我们提出了有序模式下元素插入的可能实现，但是开发人员可以根据实际情况选择最佳解决方案。对于*步骤7*，我们实现了元素移除，而在*步骤8*中，我们有打印函数。
- en: See also
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For a more complete function list regarding Linux's list API, a good reference
    can be found at [https://www.kernel.org/doc/htmldocs/kernel-api/adt.html#id-1.3.2](https://www.kernel.org/doc/htmldocs/kernel-api/adt.html#id-1.3.2).
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Linux列表API的更完整的函数列表，可以在[https://www.kernel.org/doc/htmldocs/kernel-api/adt.html#id-1.3.2](https://www.kernel.org/doc/htmldocs/kernel-api/adt.html#id-1.3.2)找到一个很好的参考。
- en: Using kernel hash tables
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内核哈希表
- en: As for kernel lists, Linux offers to kernel developers a common interface to
    manage hash tables. Their implementation is based on a special version of the
    kernel lists seen in the preceding section and named `hlist` (which is still a
    doubly linked list but with a single pointer list head). This API is defined in
    the header file, `linux/include/linux/hashtable.h`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与内核列表一样，Linux为内核开发人员提供了一个通用接口来管理哈希表。它们的实现是基于前一节中看到的内核列表的特殊版本，并命名为`hlist`（仍然是双向链表，但是只有一个指针列表头）。该API在头文件`linux/include/linux/hashtable.h`中定义。
- en: In this recipe, we will show how we can use hash tables in our kernel code by
    using the Linux API.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将展示如何使用哈希表在内核代码中使用Linux API。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Even in this recipe, we can use a kernel module to see how a test code works.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个示例中，我们也可以使用内核模块来查看测试代码的工作原理。
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the `hashtable.c` file, an example is implemented that is very similar to
    the one proposed in the preceding section with kernel lists:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`hashtable.c`文件中，实现了一个与内核列表中提出的非常相似的示例：
- en: 'As the first step, we declare the hash table, the data structure, and the hash
    function as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，我们声明哈希表、数据结构和哈希函数如下：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our hash table has only two buckets just to be able to easily hit a collision,
    so the hash function implementation is very trivial; it must return only values
    `0` or `1`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的哈希表只有两个桶，以便能够轻松地发生碰撞，因此哈希函数的实现非常简单；它只能返回值`0`或`1`。
- en: 'Then, in the module''s `init()` function, we define our nodes:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在模块的`init()`函数中，我们定义我们的节点：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we do a first insertion followed by a data printing:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们进行第一次插入，然后打印数据：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we continue node insertion:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们继续节点插入：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, we try a node deletion:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们尝试进行节点删除：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As the final step, we can have a look at nodes'' insertion and removal functions:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后一步，我们可以看一下节点的插入和删除函数：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: These two functions need key generation in order to be sure to add or remove
    the node to or from the right bucket.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数需要密钥生成，以确保将节点添加到正确的存储桶中或从中移除。
- en: 'The hash table printing can be done by using the  `hash_for_each()` macro as
    follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过使用`hash_for_each()`宏来进行哈希表的打印，如下所示：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There's more...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Again, to test the code, just compile and then insert the kernel module into
    the ESPRESSObin.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要测试代码，只需编译然后将内核模块插入ESPRESSObin。
- en: 'After module insertion, in kernel messages, we should see the first output
    lines:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 模块插入后，在内核消息中，我们应该看到第一行输出：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can safely ignore the following error message as discussed earlier:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以安全地忽略前面讨论过的以下错误消息：
- en: '`insmod: ERROR: could not insert module hashtable.ko: Invalid parameters`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`insmod: ERROR: could not insert module hashtable.ko: Invalid parameters`'
- en: In *step 1* and *step* *2*, we have defined the nodes of our hash table, while
    in *step 3* we have done the first insert into the table, and the preceding code
    is what we get after the insertion.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*和*步骤2*中，我们已经定义了哈希表的节点，而在*步骤3*中，我们已经对表进行了第一次插入，插入后的代码如上所示。
- en: 'Then, we perform the second insertion within *step 4* where we add two nodes
    with the data fields set to `7` and `2`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*步骤4*中进行了第二次插入，我们添加了两个数据字段分别设置为`7`和`2`的节点：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And finally, in *step 5* we remove the node having the `data` field set to
    5:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*步骤5*中，我们移除了`data`字段设置为5的节点：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that in *step 6*, we presented a possible implementation of the node insertion
    within the hash table. In *step 7*, we have the printing function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在*步骤6*中，我们展示了哈希表中节点插入的可能实现。在*步骤7*中，我们有打印函数。
- en: See also
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For further information about kernel hash tables, a good starting point (even
    if a bit outdated) is[ https://lwn.net/Articles/510202/](https://lwn.net/Articles/510202/).
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关内核哈希表的更多信息，一个很好的起点（即使有点过时）是[https://lwn.net/Articles/510202/](https://lwn.net/Articles/510202/)。
- en: Getting access to I/O memory
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取I/O内存的访问
- en: In this recipe, we will see how to get access to the internal peripherals of
    a CPU or to any other memory mapped device that is connected to the CPU.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何访问CPU的内部外围设备或连接到CPU的任何其他内存映射设备。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This time, we'll present an example using an already existing piece of code
    in the kernel sources, so now there is nothing to compile, but we can go directly
    to the root directory of ESPRESSObin's kernel sources.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将使用内核源代码中已经存在的代码片段来展示一个示例，因此现在没有什么需要编译，但我们可以直接转到ESPRESSObin的内核源代码的根目录。
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'A good and really simple example about how to do a memory remap is reported
    in the `linux/drivers/reset/reset-sunxi.c` file in the `sunxi_reset_init()` function as
    follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于如何进行内存重映射的一个很好而且非常简单的例子在`linux/drivers/reset/reset-sunxi.c`文件的`sunxi_reset_init()`函数中报告如下：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: By using the `of_address_to_resource()` function, we ask the device tree that
    is the memory mapping of our device and we get the result in the `res` structure.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`of_address_to_resource()`函数，我们询问设备树我们设备的内存映射，并将结果存储在`res`结构中。
- en: 'Then, we request the memory mapping size by using the `resource_size()` function
    and then we call the `request_mem_region()` function in order to ask the kernel
    to get exclusive access to the memory addresses between `res.start` and `res.start+size-1`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`resource_size()`函数请求内存映射大小，然后调用`request_mem_region()`函数，以便向内核请求独占访问`res.start`和`res.start+size-1`之间的内存地址：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If nobody has already issued this same request, the region is marked as used
    by us with the labeling name stored into `np->name`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有人已经发出了相同的请求，该区域将被标记为我们使用的，并且标签名称存储在`np->name`中。
- en: The name and memory region is now reserved for us and all this information can
    be retrieved from the`/proc/iomem` file, as will be shown in the next section.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，名称和内存区域已经为我们保留，并且所有这些信息都可以从`/proc/iomem`文件中检索，如下一节所示。
- en: 'After all the preceding preliminary operations, we can finally call the `ioremap()` function
    that actually does the remap:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行了所有前期操作之后，我们最终可以调用`ioremap()`函数来实际进行重映射：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In `data->membase`, is stored the virtual address we can use to get access to
    our device's registers.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在`data->membase`中存储了我们可以使用的虚拟地址，以便访问我们设备的寄存器。
- en: 'The prototype of `ioremap()` and its counterpart `iounmap()`, which must be
    used when we have finished using this mapping, is defined in the header file, `linux/include/asm-generic/io.h`,
    as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`ioremap()`的原型及其对应的`iounmap()`在头文件`linux/include/asm-generic/io.h`中定义如下，当我们使用完这个映射时必须使用它：'
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note that in `linux/include/asm-generic/io.h`, it is just reported that the
    implementation for systems that do not have an MMU due to the fact that each platform
    has its own implementation under the `linux/arch` directory.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`linux/include/asm-generic/io.h`中，仅报告了没有MMU的系统的实现，因为每个平台都在`linux/arch`目录下有自己的实现。
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'To have an idea about how to use `ioremap()`, we can compare the preceding
    code and the **Universal Asynchronous Receiver/Transmitter** (**UART**) driver
    of our ESPRESSObin within the `linux/drivers/tty/serial/mvebu-uart.c` file, shown
    in the following snippet:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用`ioremap()`，我们可以比较前面的代码和我们ESPRESSObin中的**通用异步收发器**（**UART**）驱动程序在`linux/drivers/tty/serial/mvebu-uart.c`文件中的示例。
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding code is part of the `mvebu_uart_probe()` function, which, at
    some time, calls the `devm_ioremap_resource()` function, which performs similar
    steps as the combined execution of functions presented in *step 1*, *step 2*,
    and *step 3*, that is, the functions `of_address_to_resource()`, `request_mem_region()`,
    and `ioremap()` at once: it takes information from the device tree and does a
    memory remap, reserving those registers for its exclusive usage only.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是`mvebu_uart_probe()`函数的一部分，该函数在某个时候调用`devm_ioremap_resource()`函数，该函数执行与*步骤1*、*步骤2*和*步骤3*中呈现的函数的组合执行类似的步骤，即`of_address_to_resource()`、`request_mem_region()`和`ioremap()`函数同时进行：它从设备树中获取信息并进行内存重映射，仅保留这些寄存器供其独占使用。
- en: 'This registration (done previously in *step 2*) can be checked in the procfs
    file `/proc/iomem` as follows, where we see that the memory area `d0012000-d00121ff`
    is assigned to `serial@12000`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注册（在*步骤2*中之前完成）可以通过procfs文件`/proc/iomem`进行检查，我们可以看到内存区域`d0012000-d00121ff`分配给`serial@12000`：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As already stated several times in this book, when we're in the kernel, nobody
    can really stop us from doing something; therefore, when I talk about *exclusive
    usage* of a memory area, the reader should imagine that this is true, if all programmers
    voluntarily refrain from issuing memory accesses on that area if a previous access
    request (like the ones issued previously) to an I/O memory area had failed.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书中已经多次声明的那样，当我们在内核中时，没有人真的能阻止我们做某事；因此，当我谈到对内存区域的*独占使用*时，读者应该想象这是真实的，如果所有程序员自愿在之前的I/O内存区域的访问请求（比如之前发出的请求）失败后，他们都不会在该区域上发出内存访问。
- en: See also
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For further information about memory mapping, a good starting point is [https://linux-kernel-labs.github.io/master/labs/memory_mapping.html](https://linux-kernel-labs.github.io/master/labs/memory_mapping.html)[.](https://linux-kernel-labs.github.io/master/labs/memory_mapping.html)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关内存映射的更多信息，一个很好的起点是[https://linux-kernel-labs.github.io/master/labs/memory_mapping.html](https://linux-kernel-labs.github.io/master/labs/memory_mapping.html)。
- en: Spending time in the kernel
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在内核中花费时间
- en: In this recipe, we will take a look at how we can delay the execution after
    some time in the future by using busy loops or more complex functions that may
    involve a suspension.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看看如何通过使用繁忙循环或可能涉及挂起的更复杂的函数来延迟将来的执行。
- en: Getting ready
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: Even in this recipe, we can use a kernel module to see how a test code works.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个示例中，我们也可以使用内核模块来查看测试代码的工作原理。
- en: How to do it...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the `time.c` file, we can find a simple example exemplifying how the preceding
    functions work:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在`time.c`文件中，我们可以找到一个简单的示例，说明了前面的函数是如何工作的：
- en: 'As the first step, we declare a utility function to get the execution time
    in nanoseconds, of a line of code:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，我们声明一个实用函数来获取代码行的执行时间（以纳秒为单位）：
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is an easy trick to define a macro that executes a line of code while taking
    its execution time by using the `ktime_get_real_ns()` function, which returns
    the current system time in nanoseconds.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的技巧，定义一个宏，通过使用`ktime_get_real_ns（）`函数执行一行代码，同时返回其执行时间，该函数返回当前系统时间（以纳秒为单位）。
- en: For further information regarding `ktime_get_real_ns()` and related functions,
    you can take a look at [https://www.kernel.org/doc/html/latest/core-api/timekeeping.html](https://www.kernel.org/doc/html/latest/core-api/timekeeping.html).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`ktime_get_real_ns（）`和相关函数的更多信息，您可以查看[https://www.kernel.org/doc/html/latest/core-api/timekeeping.html](https://www.kernel.org/doc/html/latest/core-api/timekeeping.html)。
- en: 'Now, for the module''s `init()` function, we can use our macro and then call
    all the preceding delaying functions as follows:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，对于模块的`init（）`函数，我们可以使用我们的宏，然后调用所有前面的延迟函数如下：
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: There's more...
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can test our code by compiling it and then inserting it into the ESPRESSObin
    kernel:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过编译代码并将其插入到ESPRESSObin内核中来测试我们的代码：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The following kernel messages should be printed out by using the macro defined
    in *step 1*. This macro simply takes the execution time of the delay function
    passed into the `code` parameter by using the `ktime_get_real_ns()` function, which
    is useful for getting the current kernel time in nanoseconds:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内核消息应通过在*步骤1*中定义的宏来打印出来。这个宏只是通过使用`ktime_get_real_ns（）`函数来获取传递给`code`参数的延迟函数的执行时间，这对于获取当前内核时间（以纳秒为单位）非常有用：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can safely ignore the following error message as discussed earlier:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以安全地忽略以下错误消息，如前所述：
- en: '`insmod: ERROR: could not insert module time.ko: Invalid parameters`'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`insmod: ERROR: could not insert module time.ko: Invalid parameters`'
- en: Note that the prompt will take 10 seconds before returning, due to the last
    call of the `ssleep(10)` function, which is not interruptible; so, even if we
    press *Ctrl* + *C*, we cannot stop the execution.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于`ssleep（10）`函数的最后调用，提示将在返回之前等待10秒，这是不可中断的；因此，即使我们按下*Ctrl* + *C*，我们也无法停止执行。
- en: Examining the preceding output (from *step 2*), we notice that `ndelay()` is
    not as reliable as expected for a small amount of time, while `udelay()` and `mdelay()`
    work better. Regarding `*sleep()` functions, instead, we have to say that they are
    heavily affected by the machine load due to the fact they can sleep.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 检查前面的输出（来自*步骤2*），我们注意到`ndelay（）`对于少量时间来说并不像预期的那样可靠，而`udelay（）`和`mdelay（）`效果更好。至于`*sleep（）`函数，我们必须说它们受到机器负载的严重影响，因为它们可以休眠。
- en: See also
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For further information about delaying functions, a good starting point is provided
    in the kernel documentation within the `linux/Documentation/timers/timers-howto.txt` file.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关延迟函数的更多信息，一个很好的起点是内核文档中的`linux/Documentation/timers/timers-howto.txt`文件。
