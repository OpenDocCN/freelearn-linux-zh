- en: Linux Memory Issues
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux内存问题
- en: 'A simple truism: memory issues exist. The very fact that we program in languages
    such as C (and C++) implicitly gives rise to literally infinite types of issues!
    At some point, one realizes (perhaps a bit pessimistically) that programming with
    care in a managed memory-safe language is ultimately the (only?) realistic way
    to avoid memory issues altogether.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的真理：内存问题存在。我们使用C（和C++）等语言编程的事实本身就隐含着无限类型的问题！在某个时候，人们意识到（或许有点悲观地认识到），在一个受管理的内存安全语言中小心编程最终是避免内存问题的（唯一？）现实方式。
- en: 'However, here we are, working with our power tool of choice: the eminent and
    venerable C programming language! So, what we can do to mitigate, if not eliminate,
    common memory issues, is the topic of this chapter. Ultimately, the goal is to
    be truly memory-safe; well, that''s easier said than done!'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这里，我们正在使用我们选择的强大工具：卓越而古老的C编程语言！因此，我们可以做些什么来减轻，如果不能消除，常见的内存问题，这就是本章的主题。最终，目标是真正的内存安全；好吧，说起来容易做起来难！
- en: Nevertheless, we shall attempt to have the developer successfully undertake
    this task by throwing light on the common memory issues they will likely face.
    In the chapter that follows, we will look into how some powerful memory debug
    tools can help immensely in this effort.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们将尝试通过阐明开发人员可能会遇到的常见内存问题，成功地完成这项任务。在接下来的章节中，我们将探讨一些强大的内存调试工具如何在这方面提供巨大帮助。
- en: In this chapter, the developer will learn that although the dynamic memory management
    APIs (covered in [Chapter 4](0b4868f7-a8d0-4ced-831f-20af9929de9f.xhtml), *Dynamic
    Memory Allocation*) are few, they can—when used carelessly—cause seemingly endless
    amounts of trouble and bugs!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，开发人员将了解到，尽管动态内存管理API（在[第4章](0b4868f7-a8d0-4ced-831f-20af9929de9f.xhtml)，*动态内存分配*中涵盖）很少，但当使用不慎时，它们可能会引起看似无穷无尽的麻烦和错误！
- en: 'Specifically, this chapter will throw light on the common memory issues that
    lead to hard-to-detect bugs in fielded software:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，本章将阐明导致现场软件中难以检测的错误的常见内存问题：
- en: Incorrect memory-access issues (within this, there are a few types)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不正确的内存访问问题（其中有几种类型）
- en: Memory leakage
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存泄漏
- en: Undefined behavior
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义行为
- en: Common memory issues
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见内存问题
- en: 'If one were to categorize to fine-granularity memory errors (typically caused
    via programming in C or C++), one would have a difficult time of it—hundreds of
    types exist! Instead, let''s keep the discussion manageable and check out what
    would be considered the typical or common memory errors that befall us poor C
    programmers:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要对细粒度的内存错误进行分类（通常是由C或C++编程引起的），将会很困难——存在数百种类型！相反，让我们把讨论控制在可管理的范围内，看看什么被认为是我们这些可怜的C程序员经常遭遇的典型或常见内存错误：
- en: Incorrect memory accesses
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不正确的内存访问
- en: Using uninitialized variables
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未初始化的变量
- en: Out-of-bounds memory accesses (read/write underflow/overflow bugs)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 越界内存访问（读/写下溢/溢出错误）
- en: Use-after-free/use-after-return (out-of-scope) bugs
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放后使用/返回后使用（超出范围）错误
- en: Double-free
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双重释放
- en: Leakage
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泄漏
- en: '**Undefined behavior** (**UB**)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义行为（UB）
- en: Data Races
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据竞争
- en: Fragmentation (internal implementation) issues
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碎片化（内部实现）问题
- en: Internal
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部
- en: External
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部
- en: All these common memory issues (except fragmentation) are classified as UB;
    still, we keep UB as a separate entry as we will explore it more deeply. Also,
    though the word *bug* is colloquially used, one should really (and more correctly)
    think of it as *defect*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些常见的内存问题（除了碎片化）都被归类为UB；尽管如此，我们将UB作为一个单独的条目，因为我们将更深入地探讨它。此外，虽然人们口头上使用*bug*这个词，但一个人应该真正（并更正确地）将其视为*defect*。
- en: We do not cover Data Races in this chapter (please hang on until [Chapter 15](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml),
    *Multithreading with Pthreads Part II - Synchronization*).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章不涵盖数据竞争（请等到[第15章](5e7e9c60-48d8-41bd-adef-31bbfd598c78.xhtml)，*使用Pthreads的多线程Part
    II - 同步*）。
- en: To help test these memory issues, the `membugs` program is a collection of small
    test cases for each of them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助测试这些内存问题，`membugs`程序是每个问题的一系列小测试用例。
- en: '**Sidebar :: The Clang compiler**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**侧边栏 :: Clang编译器**'
- en: LLVM/Clang is an open source compiler for C. We do use the Clang compiler, notably
    in this and the next chapter, especially for the sanitizer compiler-instrumentation
    toolset (covered in the next chapter). It remains useful throughout the book (and
    indeed is used in many of our Makefiles), thus installing Clang on your Linux
    development system would be a good idea! Again, it is not completely essential
    and one can stick with the familiar GCC too—provided one is willing to edit the
    Makefile(s) to switch back to GCC wherever required!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: LLVM/Clang是一个用于C的开源编译器。我们确实使用Clang编译器，特别是在本章和下一章中，特别是在下一章中涵盖的sanitizer编译器工具集。它在整本书中都很有用（事实上，在我们的许多Makefile中都使用它），因此在Linux开发系统上安装Clang是一个好主意！再次强调，这并非完全必要，人们也可以继续使用熟悉的GCC——只要愿意在必要时编辑Makefile(s)以切换回GCC！
- en: Installing Clang on the Ubuntu 18.04 LTS desktop is easy: `sudo apt install
    clang`
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu 18.04 LTS桌面上安装Clang很容易：`sudo apt install clang`
- en: The Clang documentation can be found at [https://clang.llvm.org/docs/index.html](https://clang.llvm.org/docs/index.html)[.](https://clang.llvm.org/docs/index.html)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Clang文档可以在[https://clang.llvm.org/docs/index.html](https://clang.llvm.org/docs/index.html)找到。
- en: When the membugs program is compiled (using both GCC for the normal case as
    well as the Clang compiler for the sanitizer variants), you will see a lot of
    compiler warnings being emitted! This is expected; after all, its code is filled
    with bugs. Relax, and continue reading.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译`membugs`程序（使用GCC进行正常情况以及使用Clang编译器进行sanitizer变体）时，你会看到大量的编译器警告被发出！这是预期的；毕竟，它的代码充满了错误。放松心情，继续阅读。
- en: Also, we remind you that the purpose of this chapter is to understand (and classify)
    typical Linux memory issues; identifying and fixing them using powerful tools
    is the subject matter of the next chapter. Both are required, so please read on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们提醒您，本章的目的是了解（和分类）典型的Linux内存问题；使用强大的工具来识别和修复它们是下一章的主题。两者都是必需的，所以请继续阅读。
- en: Some sample output from the build is shown as follows (output clipped for readability).
    Right now, we shall not attempt to analyze it; that will happen as we wind through
    this chapter *(*remember, you will need to have Clang installed as well!*):*
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的一些示例输出如下所示（为了可读性，输出被剪切了）。现在，我们不会尝试分析它；这将在我们通过本章时发生（*记住，您也需要安装Clang！*）：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We also highlight the fact that, in all the test cases we'll run, we use the
    GCC -generated *membugs* binary executable (not Clang; we shall make use of Clang
    later with the sanitizer tools).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还强调，在我们将运行的所有测试案例中，我们使用由GCC生成的*membugs*二进制可执行文件（而不是Clang；我们将在后面使用sanitizer工具时使用Clang）。
- en: 'During the build, one can capture all the output in to a file like so:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建过程中，可以将所有输出捕获到文件中，如下所示：
- en: '`make >build.txt 2>&1`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`make >build.txt 2>&1`'
- en: 'Run the `membugs` program with the `--help` switch to see all the available
    test cases:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--help`开关运行`membugs`程序以查看所有可用的测试案例：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will notice that the write and read overflows have two test cases each:
    one on compile-time memory, and one on dynamically allocated memory. It''s important
    to distinguish the cases, as tools differ in which types of defects they can detect.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您将注意到写入和读取上溢各有两个测试案例：一个是在编译时内存上，一个是在动态分配的内存上。区分这些情况很重要，因为工具在检测哪些类型的缺陷时有所不同。
- en: Incorrect memory accesses
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不正确的内存访问
- en: Often, bugs and issues in this class are so common as to be blithely overlooked!
    Beware, they remain very dangerous; take care to find, understand, and fix them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个类别中的错误和问题是如此常见，以至于被轻率地忽视！请注意，它们仍然非常危险；请注意找到、理解和修复它们。
- en: All classes of overflow and underflow bugs on memory buffers are carefully documented
    and tracked via the **Common Vulnerabilities and Exposures (CVE)** and the **Common
    Weakness Enumeration (CWE)** websites. Relevant to what we are discussing, CWE-119
    is the *Improper Restriction of Operations within the Bounds of a Memory Buffer* ([https://cwe.mitre.org/data/definitions/119.html](https://cwe.mitre.org/data/definitions/119.html)).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所有内存缓冲区上溢和下溢错误的类别都经过仔细记录和跟踪，通过**通用漏洞和暴露（CVE）**和**通用弱点枚举（CWE）**网站。与我们讨论的相关的是，CWE-119是*内存缓冲区边界内操作的不当限制*（[https://cwe.mitre.org/data/definitions/119.html](https://cwe.mitre.org/data/definitions/119.html)）。
- en: Accessing and/or using uninitialized variables
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问和/或使用未初始化的变量
- en: To give the reader a sense of the seriousness of these memory issues, we have
    written a test program, `membugs.c`. This test program allows the user to test
    various common memory bugs, which will help them better understand the underlying
    issues.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让读者对这些内存问题的严重性有所了解，我们编写了一个测试程序`membugs.c`。这个测试程序允许用户测试各种常见的内存错误，这将帮助他们更好地理解潜在的问题。
- en: Each memory bug test case is given a test case number. So that the reader can
    easily follow the source code with the explanatory material, we also specify the
    test case as follows.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个内存错误测试案例都被赋予一个测试案例编号。这样读者可以很容易地跟随源代码和解释材料，我们也会指定测试案例如下。
- en: 'Test case 1: Uninitialized memory access'
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试案例1：未初始化内存访问
- en: 'These are also known as **uninitialized memory reads** (**UMR**) bugs. A classic
    case: local (or automatic) variables are, by definition, uninitialized (unlike
    globals, whichare always preset to zero*)*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也被称为**未初始化内存读取**（**UMR**）错误。一个经典案例：本地（或自动）变量根据定义是未初始化的（不像全局变量，它们总是预设为零*）*：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding code, it''s undefined what will occur at runtime as `x` is
    uninitialized and will thus have random content. Now, we run this test case as
    follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，由于`x`未初始化并且将具有随机内容，因此在运行时会发生未定义的情况。现在，我们按以下方式运行这个测试案例：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Thankfully, modern versions of the compiler (both `gcc` and `clang`) will emit
    a warning about this issue:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 值得庆幸的是，现代版本的编译器（`gcc`和`clang`）会对这个问题发出警告：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Out-of-bounds memory accesses
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 越界内存访问
- en: 'This class is again among the more common—but deadly!—memory-access bugs. They
    can be classified as different kinds of bugs:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别再次属于更常见但致命的内存访问错误。它们可以被分类为不同类型的错误：
- en: '**Write overflow**: A bug where a write is attempted into a memory buffer after
    its last legally accessible location'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写入上溢**：尝试向内存缓冲区的最后一个合法可访问位置之后写入的错误'
- en: '**Write underflow**: A write is attempted into a memory buffer before its first
    legally accessible location'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写入下溢**：在第一个合法可访问位置之前尝试向内存缓冲区写入'
- en: '**Read underflow**: A read is attempted on a memory buffer before its first
    legally accessible location'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取下溢**：在第一个合法可访问位置之前尝试读取内存缓冲区的错误'
- en: '**Read overflow**: A read is attempted on a memory buffer after its first legally
    accessible location'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取上溢**：在第一个合法可访问位置之后尝试读取内存缓冲区的错误'
- en: Let's check these out via the source code of our `membugs.c` program.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过我们的`membugs.c`程序的源代码来检查这些。
- en: Test case 2
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试案例2
- en: 'Write or buffer overflow on compile-time allocated memory. See the code snippet
    as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 编写或缓冲区溢出在编译时分配的内存。请参见以下代码片段：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This has caused a stack overflow (also referred to as a stack smashing or **buffer
    overflow** (**BOF**)) bug; it's a serious class of vulnerability that attackers
    have successfully exploited many a time, starting with the Morris Worm virus back
    in 1988! Check out the resources in the *Further reading* section for more on
    this vulnerability on the GitHub repository.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了堆栈溢出（也称为堆栈破坏或**缓冲区溢出**（**BOF**））错误；这是一类严重的漏洞，攻击者已经成功地多次利用，从1988年的Morris
    Worm病毒开始！在GitHub存储库的*进一步阅读*部分中，了解更多关于这个漏洞的信息。
- en: 'Very interestingly, compiling and running this portion of the code on our *Fedora
    28* workstation Linux box (by passing the appropriate parameter), shows that there
    is neither compile-time nor runtime detection of this (and other similar) dangerous
    bugs by default (more on this later!):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在我们的*Fedora 28*工作站Linux系统上编译和运行代码的这一部分（通过传递适当的参数），显示默认情况下既没有编译时也没有运行时检测到这种（和其他类似的）危险错误（稍后详细介绍！）：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These bugs are also sometimes called off-by-one errors.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误有时也被称为一次性错误。
- en: 'There''s more, though (as usual); let''s do a quick experiment. In the `membugs.c:write_overflow_compilemem()` function*,*
    change the number of times we loop from 5 to 50:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当然还有更多（像往常一样）；让我们进行一个快速实验。在`membugs.c:write_overflow_compilemem()`函数中，将我们循环的次数从5更改为50：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Rebuild and retry; look at the output now on an *Ubuntu 18.04 LTS* Desktop
    Linux system (on Fedora too, but with a vanilla kernel):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建并重试；现在在*Ubuntu 18.04 LTS*桌面Linux系统上查看输出（在Fedora上也是如此，但使用原始内核）：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The fact is, modern compilers use a stack-protector feature to detect stack-overflow
    bugs and more importantly, attacks. With a large enough value, the overflow was
    detected; but with the default value, the bug escaped undetected! We stress the
    importance of using tools (which includes compilers) to detect these hidden bugs in
    the next chapter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，现代编译器使用堆栈保护功能来检测堆栈溢出错误，更重要的是，攻击。当值足够大时，溢出被检测到；但是使用默认值时，错误却未被检测到！我们强调在下一章中使用工具（包括编译器）来检测这些隐藏的错误的重要性。
- en: Test case 3
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试案例3
- en: 'Write or BOF on dynamically-allocated memory. See the code snippet as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态分配的内存上写入或BOF。请参阅以下代码片段：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Again, no compile or runtime detection of the bug occurs:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，没有发生错误的编译或运行时检测：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Unfortunately, BOF-related bugs and vulnerabilities tend to be quite common
    in the industry. The root cause is poorly understood, and thus results in poorly
    written, code; this is where we, as developers, must step up our game!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，与BOF相关的错误和漏洞在行业中往往相当常见。根本原因并不为人所知，因此导致编写不良代码；这就是我们作为开发人员必须提高自己水平的地方！
- en: 'For real-world examples of security vulnerabilities, please see this table
    of 52 documented security vulnerabilities (due to various kinds of BOF bugs) on
    Linux in 2017: [https://www.cvedetails.com/vulnerability-list/vendor_id-33/year-2017/opov-1/Linux.html](https://www.cvedetails.com/vulnerability-list/vendor_id-33/year-2017/opov-1/Linux.html).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有关安全漏洞的真实世界示例，请参阅2017年Linux上52个文档化的安全漏洞（由各种BOF错误引起）的表格：[https://www.cvedetails.com/vulnerability-list/vendor_id-33/year-2017/opov-1/Linux.html](https://www.cvedetails.com/vulnerability-list/vendor_id-33/year-2017/opov-1/Linux.html)。
- en: Test case 4
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试案例4
- en: 'Write Underflow. We dynamically allocate a buffer with `malloc(3)`, decrement
    the pointer, and then write into that memory location—a write or buffer underflow
    bug:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 写入下溢。我们使用`malloc(3)`动态分配一个缓冲区，将指针减小，然后写入该内存位置——写入或缓冲区下溢错误：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this test case, we don''t want the `free(3)` to fail, so we ensure the pointer
    passed to it is correct. The compiler does not detect any bug here; at runtime
    though, it does indeed crash, with modern glibc detecting errors (in this case,
    memory corruption):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试案例中，我们不希望`free(3)`失败，所以我们确保传递给它的指针是正确的。编译器在这里没有检测到任何错误；尽管在运行时，现代的glibc确实会崩溃，检测到错误（在这种情况下是内存损坏）：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Test case 5
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试案例5
- en: 'Read overflow, on compile-time allocated memory. We attempt a read on a compile-time
    allocated memory buffer, after its last legally accessible location:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 读取溢出，编译时分配的内存。我们尝试在编译时分配的内存缓冲区的最后一个合法可访问位置之后进行读取：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The way this test case is designed, we have two buffers arranged sequentially
    in memory. The bug: we deliberately do not null-terminate the first buffer (but
    do so on the second one), so, the `printf(3)` that will emit on `arr` continues
    reading into the second buffer, `tmp`. What if the `tmp` buffer contains secrets?'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试案例的设计方式是，我们在内存中顺序排列了两个缓冲区。错误在于：我们故意没有对第一个缓冲区进行空终止（但对第二个缓冲区进行了空终止），因此，`printf(3)`将会继续读取`arr`中的内容，直到`tmp`缓冲区。如果`tmp`缓冲区包含秘密呢？
- en: The point, of course is that the compiler cannot catch this seemingly obvious
    bug. Also, do realize that here we're writing small, simple, easy-to-read test
    cases; on a real project with a few million lines of code, defects such as this
    are easy to miss.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，问题是编译器无法捕捉到这个看似明显的错误。还要意识到，这里我们编写的是小型、简单、易于阅读的测试案例；在一个有几百万行代码的真实项目中，这样的缺陷很容易被忽视。
- en: 'Here is the sample output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是示例输出：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Hey, we got to read the secret memory of `tmp`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，我们读取了`tmp`的秘密内存。
- en: In fact, tools such as ASan (Address Sanitizer, seen in the next chapter), classify
    this bug as a stack buffer overflow.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，诸如ASan（地址消毒剂，在下一章中介绍）之类的工具将此错误分类为堆栈缓冲区溢出。
- en: 'As an aside, on our *Fedora 28* workstation, we just get junk from the second
    buffer in this test case:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，在我们的*Fedora 28*工作站上，我们在这个测试案例中从第二个缓冲区中只得到了垃圾：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This shows us that these bugs can reveal themselves differently, depending on
    the compiler version, the glibc version, and the machine hardware.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们表明，这些错误可能会因编译器版本、glibc版本和机器硬件的不同而表现出不同的特征。
- en: An always useful testing technique is to try to run your test cases on as many
    hardware/software variants as possible. Hidden bugs may be exposed! Think of instances
    such as endianness issues, compiler optimization (padding, packing), and platform-specific
    alignments.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一个始终有用的测试技术是尽可能在多种硬件/软件变体上运行测试案例。隐藏的错误可能会暴露出来！考虑到诸如字节序问题、编译器优化（填充、打包）和特定平台的对齐等情况。
- en: Test case 6
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试案例6
- en: 'Read overflow, on dynamically allocated memory. Again, we attempt a read; this
    time, on a dynamically allocated memory buffer, after its last legally accessible
    location:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 读取溢出，动态分配的内存。再次尝试读取；这次是在动态分配的内存缓冲区的最后一个合法可访问位置之后：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The test case is pretty much the same as the preceding one (the read overflow
    on compile-time memory*)*, except that we dynamically allocate the memory buffers,
    and insert a couple more bugs for fun:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 测试案例与前一个测试案例（编译时内存的读取溢出*）*基本相同，只是我们动态分配了内存缓冲区，并且为了好玩插入了一些其他错误：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Hey, Mom, look! We got the secret!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，妈妈，看！我们得到了秘密！
- en: It does not even cause a crash. At first glance, bugs such as this might appear
    fairly harmless—the truth, though, is that this is a really dangerous bug!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至不会导致崩溃。乍一看，这样的错误可能看起来相当无害——但事实上，这是一个非常危险的错误！
- en: The well known OpenSSL Heartbleed security bug (CVE-2014-0160) is a great example
    of exploiting a read overflow, or as it's often called, a buffer over-read, vulnerability.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 著名的OpenSSL Heartbleed安全漏洞（CVE-2014-0160）是利用读取溢出的一个很好的例子，或者通常被称为缓冲区过读取漏洞。
- en: In a nutshell, the bug allowed a rogue client process to make a seemingly correct
    request to the OpenSSL server process; in reality, it could request and receive much
    more memory than it should have been allowed to, because of a buffer over-read
    vulnerability.In effect, this bug made it possible for attackers to bypass security
    easily and steal secrets [[http://heartbleed.com](http://heartbleed.com/)].
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这个错误允许一个恶意客户端进程向OpenSSL服务器进程发出一个看似正确的请求；实际上，它可以请求并接收比应该允许的更多的内存，因为存在缓冲区过读取漏洞。实际上，这个错误使得攻击者可以轻松地绕过安全性并窃取秘密[[http://heartbleed.com](http://heartbleed.com/)]。
- en: If interested, find more in the *Further reading* section on the GitHub repository.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果感兴趣，在GitHub存储库的*进一步阅读*部分中找到更多信息。
- en: Test case 7
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试案例7
- en: 'Read underflow. We attempt a read on a dynamically allocated memory buffer,
    before its first legally accessible location:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 读取下溢。我们尝试在动态分配的内存缓冲区上进行读取，而在其第一个合法可访问的位置之前：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The test case is designed with a runtime condition; we test it both ways:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 测试案例设计了一个运行时条件；我们两种方式测试它：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If the condition evaluates to true, the buffer pointer is decremented, thus
    causing a read buffer underflow on the subsequent `printf`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件为真，则缓冲区指针会减少，从而导致后续`printf`的读取缓冲区下溢：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Again, glibc comes to our aid by showing us that a double free or corruption
    has occurred—in this case, it's memory corruption.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，glibc通过显示双重释放或损坏来帮助我们——在这种情况下，它是内存损坏。
- en: Use-after-free/Use-after-return bugs
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 释放后使用/返回后使用错误
- en: '**Use-****after-free** (**UAF**) and **use-after-return** (**UAR**) are dangerous,
    difficult-to-spot bugs. Check out the following test cases for each of them.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用-** **释放后使用**（UAF）和**返回后使用**（UAR）是危险的、难以发现的错误。查看以下每个测试案例。'
- en: Test case 8
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试案例8
- en: '**Use After Free (UAF).** Operating upon a memory pointer after it has been
    freed up is obviously a bug, causing UB. The pointer is sometimes called a dangling
    pointer. Here is a quick test case:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**释放后使用（UAF）**。在释放内存指针后对其进行操作显然是一个错误，会导致UB。这个指针有时被称为悬空指针。这里是一个快速测试案例：'
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Again, neither at compile-time nor at runtime is the UAF bug detected, nor
    does it cause a crash:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，无论在编译时还是在运行时都无法检测到UAF错误，也不会导致崩溃：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Did you notice the neat `printf(3)` format specifier, `%.*s`, trick? This format
    is used to print a string of a specific length (no terminating null required!).
    First, specify the length in bytes to print, and then the pointer to string.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了巧妙的`printf(3)`格式说明符`%.*s`吗？这种格式用于打印特定长度的字符串（不需要终止空字符！）。首先，指定要打印的字节数，然后是字符串的指针。
- en: Test case 9
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试案例9
- en: '**Use After Return** (**UAR**). Another classic bug, this one involves returning
    a storage item (or pointer to it) to the calling function. The issue is that the
    storage is local or automatic, thus implying that once the return is affected,
    the storage object is now out of scope.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**返回后使用**（**UAR**）。另一个经典的错误，这个错误涉及将存储项（或指向它的指针）返回给调用函数。问题在于存储是局部的或自动的，因此一旦返回受影响，存储对象现在就超出了范围。'
- en: 'The classic example is shown here: we allocate `32` bytes to a local variable*,*
    initialize it, and return it to the caller:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了一个经典的例子：我们为一个局部变量分配了`32`字节，初始化它，并将其返回给调用者：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is how the caller invokes the preceding buggy function:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调用者调用前面的错误函数的方式：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Of course, once the `return` statement in the `uar()` function takes effect,
    the `name` variable is automatically out of scope! Therefore, the pointer to it
    is invalid, and when run, it fails:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一旦`uar()`函数中的`return`语句生效，`name`变量就会自动超出范围！因此，指向它的指针是无效的，运行时会失败：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Thankfully though, modern GCC (we''re using GCC ver 7.3.0) warns us about this
    common bug:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，现代GCC（我们使用的是GCC ver 7.3.0）会警告我们这个常见的错误：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As mentioned before (but it's always worth repeating), heed and fix all warnings!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述（但值得重申），请注意并修复所有警告！
- en: Actually, there are times when this bug escapes notice—it looks like it works
    fine and there's no bug. This is because there is no actual guarantee that the
    stack memory frame is immediately destroyed upon function return—memory and compiler-optimization
    might keep the frame around (typically for reuse). Nevertheless, it is a dangerous
    bug and must be fixed!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有时这个错误会被忽视——看起来它工作正常，没有错误。这是因为没有实际的保证在函数返回时立即销毁堆栈内存帧——内存和编译器优化可能会保留帧（通常是为了重用）。然而，这是一个危险的错误，必须修复！
- en: In the next chapter, we'll cover some memory debug tools. As a matter of fact,
    neither Valgrind nor the Sanitizer tools catch this possibly deadly bug. But,
    using the ASan toolset appropriately does catch the UAR! Read on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些内存调试工具。事实上，Valgrind和Sanitizer工具都无法捕捉到这个可能致命的错误。但是，适当使用ASan工具集确实可以捕捉到UAR！继续阅读。
- en: Test case 10
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试案例10
- en: Double-free**.** Once a `malloc` family buffer is freed, one is not allowed
    to use that pointer at all. Attempting to free the same pointer again (without
    again allocating it memory via one of the `malloc` family APIs) is a bug: double
    free. It results in heap corruption; bugs like this are often exploited by attackers
    to cause **denial-of-service **(**DoS**) attacks or worse (privilege escalation).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 双重释放。一旦释放了`malloc`系列缓冲区，就不允许再使用该指针。尝试再次释放相同的指针（而不是通过`malloc`系列API之一再次分配内存）是一个错误：双重释放。它会导致堆损坏；攻击者经常利用这样的错误来造成**拒绝服务**（**DoS**）攻击或更糟糕的情况（权限提升）。
- en: 'Here is a simple test case:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的测试案例：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding test case, we simulate an interesting and quite realistic
    scenario: a runtime condition (simulated via the `cond` parameter) causes the
    program to perform a call that, let''s say, fails—`malloc(-1UL)` pretty much guarantees
    that.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的测试案例中，我们模拟了一个有趣且相当现实的场景：一个运行时条件（通过`cond`参数模拟）导致程序执行一个调用，让我们说，失败了——`malloc(-1UL)`几乎可以保证这种情况发生。
- en: Why? Because, on a 64-bit OS, `-1UL = 0xffffffffffffffff = 18446744073709551615
    bytes = 16 EB`. That's the entire extent of the virtual address space on 64-bit.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？因为在64位操作系统上，`-1UL = 0xffffffffffffffff = 18446744073709551615字节 = 16 EB`。这是64位虚拟地址空间的全部范围。
- en: 'Back to the point: within our malloc error-handling code, an erroneous double-free—of
    the previously freed `ptr` pointer—occurs, resulting in a double free bug.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 回到重点：在我们的malloc错误处理代码中，发生了一个错误的双重释放——之前释放的`ptr`指针——导致了双重释放错误。
- en: 'The real problem is that often, as developers, we do not write (negative) test
    cases for error-handling code paths; a defect then escapes undetected into the
    field:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的问题是，作为开发人员，我们经常不为错误处理代码路径编写（负面的）测试案例；然后一个缺陷就会逃脱检测进入现场：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Interestingly, the compiler does warn us regarding the faulty (read buggy)
    second malloc (but not regarding the double free!); see the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，编译器确实警告我们关于错误（有缺陷）的第二次malloc（但没有关于双重释放的警告！）；请参见以下内容：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To help emphasize the importance of detecting and fixing such bugs—and remember,
    this is just one example— we show as follows some information from the **National
    Vulnerability Database** (**NVD**) on double free bugs within the last 3 years
    (at the time of this writing): [https://nvd.nist.gov/vuln/search/results?adv_search=false&form_type=basic&results_type=overview&search_type=last3years&query=double+free](https://nvd.nist.gov/vuln/search/results?adv_search=false&form_type=basic&results_type=overview&search_type=last3years&query=double+free)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调检测和修复此类错误的重要性——记住，这只是一个例子——我们展示了*国家漏洞数据库*（NVD）在过去3年内（在此写作时）关于双重释放错误的一些信息：[https://nvd.nist.gov/vuln/search/results?adv_search=false&form_type=basic&results_type=overview&search_type=last3years&query=double+free](https://nvd.nist.gov/vuln/search/results?adv_search=false&form_type=basic&results_type=overview&search_type=last3years&query=double+free)
- en: 'A partial screenshot of the search result performed on the *National Vulnerability
    Database** (NVD)* on double free bugs within the last 3 years (at the time of
    this writing) follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在*国家漏洞数据库*（NVD）上执行的双重释放错误的搜索结果的部分截图（在此写作时）如下：
- en: '![](img/50802625-fc81-4ea1-b8b2-09e417c38592.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50802625-fc81-4ea1-b8b2-09e417c38592.png)'
- en: The complete screenshot has not been shown here.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的截图没有在这里显示。
- en: Leakage
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泄漏
- en: The golden rule for dynamic memory is to free the memory you allocate.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 动态内存的黄金法则是释放你分配的内存。
- en: Memory leakage is the term used to describe the situation where one fails to
    do so. The programmer thinks that the memory region has indeed been freed up.
    But it has not—that's the bug. Therefore, this makes the thought-to-be-freed memory
    region unavailable to the process and system; in effect, it is unusable, even
    though it should have been usable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏是用来描述未能释放内存的情况。程序员认为内存区域确实已经被释放了。但实际上没有——这就是错误。因此，这使得认为已释放的内存区域对进程和系统不可用；实际上，它是不可用的，尽管它本应该是可用的。
- en: 'The memory is said to have leaked out. So why can''t the programmer just take
    care of this elsewhere in the code by calling free upon this memory pointer? That''s
    really the crux of the issue: in the typical case, because of the way the code
    is implemented, it''s essentially impossible to regain access to that leaked memory
    pointer.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 据说内存已经泄漏了。那么为什么程序员不能在代码的其他地方通过调用free来处理这个内存指针呢？这实际上是问题的关键：在典型情况下，由于代码的实现方式，基本上不可能重新访问泄漏的内存指针。
- en: A quick test case will demonstrate this.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速的测试案例将证明这一点。
- en: The `amleaky` function is deliberately written to leak `mem` bytes of memory—its
    parameter—each time it's invoked.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`amleaky`函数被故意编写成每次调用时泄漏`mem`字节的内存——它的参数。'
- en: Test case 11
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试案例11
- en: 'Memory leakage - case 1: a (simple) memory leak test case. See the following
    code snippet:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏 - 情况1：（简单的）内存泄漏测试案例。请参见以下代码片段：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As one can clearly see, in the `amleaky` function, the `ptr` memory pointer
    is a local variable and is thus lost once we return from the buggy function; this
    makes it impossible to free it later. Also notice—the comment explains it—how
    we require `memset` to force the compiler to generate code for and use the memory
    region.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如大家可以清楚地看到的，在`amleaky`函数中，`ptr`内存指针是一个局部变量，因此一旦我们从有缺陷的函数返回，它就会丢失；这使得以后无法释放它。还要注意——注释解释了它——我们需要`memset`来强制编译器生成代码并使用内存区域。
- en: 'A quick build and execution of the preceding test case will reveal that, again,
    no obvious compile-time or runtime detection of the leakage occurs:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对前面测试案例的快速构建和执行将显示，再次没有明显的编译时或运行时检测到泄漏的发生：
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Test case 12
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试案例12
- en: Memory leakage case 2 - leak more (in a loop). Quite often, the buggy leaking
    code might only be leaking a small amount of memory, a few bytes, by itself. The
    problem is, what if this leaky function is called in a loop hundreds, or perhaps,
    thousands of times, during process execution? Now the leakage is significant,
    and unfortunately, not immediately apparent.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏情况2 - 泄漏更多（在循环中）。很多时候，有缺陷的泄漏代码可能只会泄漏少量内存，几个字节。问题是，如果这个有泄漏的函数在进程执行期间被调用了数百次，甚至数千次，现在泄漏就变得显著了，但不幸的是，不会立即显现出来。
- en: 'To emulate precisely this and more, we execute two test cases (for Option 12):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了精确模拟这一点以及更多内容，我们执行两个测试案例（选项12）：
- en: We allocate, and leak, a tiny amount of memory (32 bytes) but in a loop 100,000
    times (so, yes, we end up leaking over 3 MB)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们分配并泄漏了少量内存（32字节），但在循环中重复了10万次（因此，是的，我们最终泄漏了超过3 MB）。
- en: We allocate, and leak, a large amount of memory (1 MB) in a loop 12 times (so,
    we end up leaking 12 MB).
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在循环中分配并泄漏了大量内存（1 MB），循环了12次（因此，我们最终泄漏了12 MB）。
- en: 'Here''s the relevant code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相关代码：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The logic ensures that the `printf(3)` within the leaky loop is only displayed
    on every 10,000 loop iterations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逻辑确保在每10,000次循环迭代时才显示泄漏循环中的`printf(3)`。
- en: 'Also, we would like to see whether memory has indeed leaked. To do so, albeit
    in an approximate manner, we use the `free` utility:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们想要看看内存是否确实泄漏了。为了以一种近似的方式来做到这一点，我们使用`free`实用程序：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `free(1)` utility displays, in kilobytes, the current (approximate) amount
    of memory used, free, and available on the system as a whole. It further divides
    the used memory between shared, buffered/page-cached; it also displays `Swap`
    partition statistics. We should also note that this approach of using `free(1)`
    to detect memory leakage is not considered very accurate; a crude approach at
    best. The memory reported as in use, free, cached, and so on by the OS can show
    variations. For our purposes, it's okay.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`free(1)`实用程序以千字节为单位显示系统整体上当前（近似）使用的内存量、空闲内存量和可用内存量。它进一步将已使用的内存分为共享、缓冲/页面缓存；它还显示`Swap`分区统计信息。我们还应该注意，使用`free(1)`来检测内存泄漏的方法并不被认为是非常准确的；这最多是一种粗略的方法。操作系统报告的已使用内存、空闲内存、缓存等等可能会有所不同。对于我们的目的来说，这是可以接受的。'
- en: Our point of interest is the intersection of the `Mem` row and the `free` column;
    thus, we can see that out of a total available memory of 16 GB (RAM), the amount
    currently free is approximately 348744 KB ~= 340 MB.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的是`Mem`行和`free`列的交集；因此，我们可以看到在总共可用的16 GB内存（RAM）中，当前空闲的内存量约为348744 KB ~=
    340 MB。
- en: 'One can quickly try out a one-liner script to display just the region of interest—the
    `Mem` line:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速尝试一个一行脚本，只显示感兴趣的区域——`Mem`行：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The third column after `Mem` is the `free` memory (interestingly, it's already
    reduced from the previous output; that doesn't matter).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Mem`之后的第三列是`free`内存（有趣的是，它已经从上一次的输出中减少了；这并不重要）。
- en: 'Back to the program; we use the `system(3)` library API to run the preceding
    pipe-lined shell command within a C program (we''ll build our own small emulation
    of the `system(3)` API in [Chapter 10](607ad988-406d-4736-90a4-3a318672ab6e.xhtml),
    *Process Creation*):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 回到程序；我们使用`system(3)`库API在C程序中运行前面的管道化的shell命令（我们将在[第10章](607ad988-406d-4736-90a4-3a318672ab6e.xhtml)中构建我们自己的`system(3)`API的小型模拟，*进程创建*）：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `if` statement ensures that this output only occurs if a threshold of >=
    3 MB is leaking.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句确保只有在泄漏量大于等于3 MB时才会出现这个输出。'
- en: 'Here is the output upon execution:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行后，这是输出：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We see the two scenarios executing; check out the values of the `free` column.
    We shall subtract them to see the memory that''s been leaked:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到两种情况正在执行；查看`free`列的值。我们将它们相减以查看泄漏的内存量：
- en: 'We allocate, and leak, a tiny amount of memory (32 bytes) but in a loop 100,000
    times: `Leaked memory = 297708 - 293120 = 4588 KB ~= 4.5 MB`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在循环中分配并泄漏了一小部分内存（32字节），但是循环了100,000次：`泄漏内存 = 297708 - 293120 = 4588 KB ~=
    4.5 MB`
- en: 'We allocate, and leak, a large amount of memory (1 MB) in a loop 12 times:
    `Leaked memory = 292616 - 280992 = 11624 KB ~= 11.4 MB`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在循环中分配并泄漏了大量内存（1 MB），共12次：`泄漏内存 = 292616 - 280992 = 11624 KB ~= 11.4 MB`
- en: Of course, do realize that once the process dies, all its memory is freed back
    to the system. That's why we performed the one-liner script within the process,
    while it was alive.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，要意识到一旦进程死掉，它的所有内存都会被释放回系统。这就是为什么我们在进程还活着的时候执行了这个一行脚本。
- en: Test case 13
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试案例13
- en: 'Complex case—wrapper APIs. At times, one can be forgiven for thinking that
    all programmers are taught: after calling malloc (or calloc, realloc), call free. malloc
    and free go together! How hard can that be? Why are there are so many sneaky leakage
    bugs if this is the case?'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂情况——包装器API。有时，人们会原谅地认为所有程序员都被教导：在调用malloc（或calloc、realloc）之后，调用free。malloc和free是一对！这有多难？如果是这样，为什么会有这么多隐蔽的泄漏错误呢？
- en: A key reason that leakage defects occur and are hard to pinpoint is because some
    APIs—often, third-party library APIs—might internally perform dynamic memory allocation
    and expect the caller to free the memory. The API will (hopefully) document this
    important fact; but who (tongue in cheek) reads documentation?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 泄漏缺陷发生并且难以准确定位的一个关键原因是因为一些API——通常是第三方库API——可能在内部执行动态内存分配，并期望调用者释放内存。API（希望）会记录这一重要事实；但是谁（半开玩笑地）会去读文档呢？
- en: That's really the crux of the issue in real-world software; it is complex and
    we work on large, complex projects. It is indeed easy to miss the fact that an
    underlying API allocates memory and the caller is responsible for freeing it.
    Precisely this occurs quite often.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是现实世界软件中的问题的关键所在；它很复杂，我们在大型复杂项目上工作。很容易忽略的一个事实是，底层API分配内存，调用者负责释放它。这种情况确实经常发生。
- en: 'There''s another case: on complex codebases (especially those with spaghetti
    code), where a lot of deeply nested layers entangle the code, it can get especially
    hard to perform the required cleanup—including memory-frees—on every possible
    error case.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的代码库（尤其是那些有意大利面代码的代码库）中，深度嵌套的层次结构使代码纠缠在一起，要执行所需的清理工作，包括释放内存，在每种可能的错误情况下都变得特别困难。
- en: The Linux kernel community offers a clean, though fairly controversial, way
    to keep cleanup code paths clean and working well, that is, the use of the local
    go to perform centralized error-handling! It helps indeed. Interested in learning
    more? Check out section 7,* Centralized exiting of functions* at [https://www.kernel.org/doc/Documentation/process/coding-style.rst](https://www.kernel.org/doc/Documentation/process/coding-style.rst).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核社区提供了一种干净但颇具争议的方式来保持清理代码路径的干净和良好运行，即使用本地跳转来执行集中的错误处理！这确实有帮助。想要了解更多吗？查看[https://www.kernel.org/doc/Documentation/process/coding-style.rst](https://www.kernel.org/doc/Documentation/process/coding-style.rst)中的第7节，*函数的集中退出*。
- en: Test case 13.1
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试案例13.1
- en: 'Here is a simple example. Let''s emulate this with the following test case
    code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子。让我们用以下测试案例代码来模拟这个：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We invoke it as:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样调用它：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As usual, no compiler or runtime warnings result. Here is the output (recognize
    that the first invocation is the buggy case, as `cond` has the value of `0` and
    thus the `free(3)` will not be called):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，没有编译器或运行时警告。这是输出（注意第一次调用是有bug的情况，因为`cond`的值为`0`，因此不会调用`free(3)`）：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There is no bug apparent by looking at the output—and that is partly what makes
    these bugs so dangerous!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看输出看不出有bug，这也是这些bug如此危险的部分原因！
- en: This case is critical for developers and testers to understand; it warrants
    checking out a couple of real-world examples.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况对开发人员和测试人员来说非常关键；它值得检查一些真实世界的例子。
- en: Test case 13.2
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试案例13.2
- en: Example—the *Motif* library**. ***Motif* is a legacy library, part of the X
    Window System; it was used (and perhaps still is) to develop GUIs for Unix (and
    Unix-like) systems.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例子——*Motif*库**。***Motif*是X Window系统的一部分的传统库；它被用于（也许仍在用）为Unix（和类Unix）系统开发GUI。
- en: 'For the purpose of this example, we will focus on one of its APIs: `XmStringCreateLocalized(3)`.
    GUI developers use this function to create what Motif calls a "compound string"—essentially,
    just a string that holds text in a specific locale (for the purposes of I18N-internationalization).
    This is its signature:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，我们将专注于其中一个API：`XmStringCreateLocalized(3)`。GUI开发人员使用这个函数来创建Motif称之为“复合字符串”的东西——本质上，就是一个以特定区域设置（用于国际化I18N）的文本为内容的字符串。这是它的签名：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: So, let's imagine the developer uses it to generate compound strings (for various
    purposes; very often, for the labels of a label or push button widget).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们想象一下，开发人员使用它来生成复合字符串（用于各种目的；很多时候是用于标签或按钮小部件的标签）。
- en: So, what's the problem?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 那么问题出在哪里呢？
- en: 'Leakage! How? Read the documentation from the man page ([https://linux.die.net/man/3/xmstringcreatelocalized](https://linux.die.net/man/3/xmstringcreatelocalized))
    on `XmStringCreateLocalized(3)`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏！怎么回事？从`XmStringCreateLocalized(3)`的man页面（[https://linux.die.net/man/3/xmstringcreatelocalized](https://linux.die.net/man/3/xmstringcreatelocalized)）上阅读文档：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Clearly, the developer must not only call `XmStringCreateLocalized(3)` but must
    also remember to free up the memory internally allocated by it for the compound
    string by calling `XmStringFree(3)`!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，开发人员不仅必须调用`XmStringCreateLocalized(3)`，还必须记得通过调用`XmStringFree(3)`释放由它内部分配的复合字符串的内存！
- en: Failing to do so will result in a leak. I have personal experience with this
    scenario—a buggy application invoked the `XmStringCreateLocalized(3)` and did not
    call its counterpart, `XmStringFree(3)`. Not only that, this code ran often as
    it was invoked as part of the body of an outer loop! So, the leakage multiplied.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不这样做，就会导致内存泄漏。我有这种情况的亲身经历——一个有bug的应用程序调用了`XmStringCreateLocalized(3)`，但没有调用它的对应函数`XmStringFree(3)`。更糟糕的是，这段代码经常运行，因为它是外部循环的一部分！所以，内存泄漏不断增加。
- en: Test case 13.3
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试案例13.3
- en: 'Example—the Nortel Porting Project.There is a story (refer to the information
    box as follows) about how developers at Nortel (a large telecom and network equipment
    multinational corporation in Canada) had a very hard time debugging what turned
    out to be a memory leakage issue. The crux of it is this: when porting a Unix
    application to VxWorks, while testing it, they noticed a small 18-byte leak occurring,
    which would eventually cause the application to crash. Finding the source of the
    leak was a nightmare— reviewing the code endlessly provided no clues. Finally,
    the game changer proved to be the use of a leak detection tool (we''ll cover this
    in the coming [Chapter 6](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml), *Debugging
    Tools for Memory Issues*). Within minutes, they uncovered the root cause of the
    leak: an innocent-looking API, `inet_ntoa(3)` (refer to the information box),
    which worked in the usual manner on Unix, and as well as in VxWorks. The catch:
    in the VxWorks implementation, it was allocating memory under the hood—which the
    caller was responsible for freeing! This fact was documented, but it was a porting
    project! Once this fact was realized, it was quickly fixed.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例子——Nortel移植项目。有一个关于Nortel（加拿大一家大型电信和网络设备跨国公司）的开发人员在调试一个内存泄漏问题时遇到了很大困难的故事。问题的关键在于：在将Unix应用程序移植到VxWorks时，在测试过程中，他们注意到发生了一个小的18字节的内存泄漏，最终导致应用程序崩溃。找到内存泄漏的源头是一场噩梦——无休止地审查代码没有提供任何线索。最终，改变游戏规则的是使用了一个内存泄漏检测工具（我们将在接下来的[第6章](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml)中介绍，*内存问题调试工具*）。几分钟内，他们发现了内存泄漏的根本原因：一个看似无害的API，`inet_ntoa(3)`（参见信息框），在Unix上和VxWorks上都是正常工作的。问题在于，在VxWorks的实现中，它在幕后分配了内存——调用者有责任释放！这个事实是有文档记录的，但这是一个移植项目！一旦意识到这一点，问题很快就解决了。
- en: 'Article: The ten secrets of embedded debugging, Schneider and Fraleigh: [https://www.embedded.com/design/prototyping-and-development/4025015/The-ten-secrets-of-embedded-debugging](https://www.embedded.com/design/prototyping-and-development/4025015/The-ten-secrets-of-embedded-debugging)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 文章：嵌入式调试的十个秘密，Schneider和Fraleigh：[https://www.embedded.com/design/prototyping-and-development/4025015/The-ten-secrets-of-embedded-debugging](https://www.embedded.com/design/prototyping-and-development/4025015/The-ten-secrets-of-embedded-debugging)
- en: 'The man page entry on `inet_ntoa(3)` states: The `inet_ntoa()` function converts
    the Internet host address in, given in network byte order, to a string in IPv4
    dotted-decimal notation. The string is returned in a statically allocated buffer,
    which subsequent calls will overwrite.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`inet_ntoa(3)`的man页面条目指出：`inet_ntoa()`函数将以网络字节顺序给出的Internet主机地址转换为IPv4点分十进制表示的字符串。字符串以静态分配的缓冲区返回，后续调用将覆盖它。'
- en: 'Some observations on programs with leakage bugs:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 关于有内存泄漏bug的程序的一些观察：
- en: The program behaves normally for a long, long while; suddenly, after, say, a
    month of uptime, it abruptly crashes.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序在很长一段时间内表现正常；突然之间，比如说，运行一个月后，它突然崩溃了。
- en: The root leakage could be very small—a few bytes at a time; but is probably
    invoked often.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根源的内存泄漏可能非常小——每次只有几个字节；但可能经常被调用。
- en: Attempting to find leakage bugs by carefully matching your  instances of `malloc(3)` and
    `free(3)` does not work; library API wrappers often allocate memory under the
    hood and expect the caller to free it.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过仔细匹配你的`malloc(3)`和`free(3)`的实例来寻找泄漏错误是行不通的；库API包装器通常在后台分配内存，并期望调用者释放它。
- en: Leaks often escape unnoticed because they are inherently difficult to spot in
    large codebases, and once the process dies, the leaked memory is freed back to
    the system.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泄漏通常会被忽视，因为它们在大型代码库中很难被发现，一旦进程死掉，泄漏的内存就会被释放回系统。
- en: 'Bottom line:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 底线：
- en: Do not assume anything
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要假设任何事情
- en: Read the API documentation carefully
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细阅读API文档
- en: Use tools (covered in the coming [Chapter 6](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml), *Debugging
    Tools for Memory Issues*)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工具（在即将到来的[第6章](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml)中涵盖的*内存问题调试工具*）
- en: One cannot overstate the importance of using tools to detect memory bugs!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 不能过分强调使用工具检测内存错误的重要性！
- en: Undefined behavior
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未定义行为
- en: 'We''ve covered quite a bit of ground and seen quite a few common memory bugs,
    which include:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了相当多的内容，并看到了一些常见的内存错误，包括：
- en: Incorrect memory accesses
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不正确的内存访问
- en: Using uninitialized variables
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未初始化的变量
- en: Out-of-bounds memory accesses (read/write underflow/overflow bugs)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 越界内存访问（读/写下溢/溢出错误）
- en: Use-after-free / use-after-return (out-of-scope) bugs
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放后使用/返回后使用（超出范围）错误
- en: Double-free
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双重释放
- en: Leakage
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泄漏
- en: Data Races *(*details follow in a later chapter)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据竞争（详细信息将在后面的章节中介绍）
- en: 'As mentioned earlier, all of these fall into a general categorization—UB. As
    the phrase implies, the behavior of the process (or thread) is *undefined* once
    any of these bugs are hit. Even worse, many of them do not display any directly
    noticeable side effects; but the process is unstable and will—eventually—crash.
    Leakage bugs, in particular, are major spoilsports in this: the leakage may be
    around for a long while before a crash actually occurs. Not only that, the trail
    left behind (that the developer will be breathlessly chasing) might often be a
    red herring—matters of little consequence, things that have no real bearing on
    the bug''s root cause. All of this, of course, makes debugging UB an experience
    most of us would prefer to avoid!'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，所有这些都属于一个通用的分类——UB。正如短语所暗示的，一旦发生这些错误中的任何一个，进程（或线程）的行为就会变得*未定义*。更糟糕的是，其中许多错误并不显示任何直接可见的副作用；但进程是不稳定的，并且最终会崩溃。特别是泄漏错误在其中是主要的破坏者：泄漏可能在崩溃实际发生之前存在很长时间。不仅如此，留下的痕迹（开发人员将气喘吁吁地追踪）往往可能是一个误导——与错误根本原因无关紧要的事情，没有真正影响错误根本原因的事情。当然，所有这些都使得调试UB成为大多数人都愿意避免的经历！
- en: The good news is that UB is avoidable, as long as the developer understands
    the underlying causes of UB (which we have covered in the previous sections),
    and of course, the ability to use powerful tools to discover, and then fix, these
    bugs, which is our next topic area.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，只要开发人员了解UB的根本原因（我们在前面的章节中已经涵盖了），并且有能力使用强大的工具来发现并修复这些错误，UB是可以避免的，这也是我们下一个话题领域。
- en: 'For a deeper look at the many, many possible kinds of UB bugs, please check
    out:*Appendix J.2: Undefined behavior*: a nonnormative, non-exhaustive list of
    undefined behaviors in C: [http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf#page=571](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf#page=571).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解许多可能的UB错误，请查看：*附录J.2：未定义行为*：C中未定义行为的非规范、非穷尽列表：[http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf#page=571](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf#page=571)。
- en: From the in-depth C Programming Language standards—the ISO/IEC 9899:201x Committee
    Draft dated 02 Dec 2010.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 来自深入的C编程语言标准——ISO/IEC 9899:201x委员会草案，日期为2010年12月2日。
- en: 'Along similar lines, please see *CWE VIEW: Weaknesses in Software Written in
    C*:[https://cwe.mitre.org/data/definitions/658.html](https://cwe.mitre.org/data/definitions/658.html).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，还请参阅*CWE VIEW：C编写的软件中的弱点*：[https://cwe.mitre.org/data/definitions/658.html](https://cwe.mitre.org/data/definitions/658.html)。
- en: Fragmentation
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碎片
- en: 'Fragmentation issues usually refer to problems primarily faced by the internal
    implementation of the memory allocation engine itself, and not so much by the
    typical application developer. Fragmentation issues are usually of two types:
    internal and external.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 碎片问题通常指的是主要由内存分配引擎的内部实现面临的问题，而不是典型的应用程序开发人员所面临的问题。碎片问题通常有两种类型：内部和外部。
- en: External fragmentation usually refers to the situation where, after several
    days of uptime, even if the free memory on the system is, say, 100 MB, the physically
    contiguous free memory might be less than a megabyte. Thus, with processes taking
    and releasing various sized memory chunks, memory has become fragmented.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 外部碎片通常指的是这样一种情况：在系统运行了几天后，即使系统上的空闲内存为100MB，物理上连续的空闲内存可能少于1MB。因此，随着进程获取和释放各种大小的内存块，内存变得碎片化。
- en: Internal fragmentation usually refers to the wastage of memory caused by using
    an inefficient allocation strategy; often though, this cannot be helped, since
    wastage tends to be a side effect of many heap-based allocators. The modern glibc
    engine uses memory pools, which greatly reduce internal fragmentation.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 内部碎片通常指的是由于使用低效的分配策略而导致的内存浪费；然而，这通常是无法避免的，因为浪费往往是许多基于堆的分配器的副作用。现代的glibc引擎使用内存池，大大减少了内部碎片。
- en: We shall not attempt to delve into fragmentation issues in this book.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算在本书中深入探讨碎片问题。
- en: Suffice it to say that, if in a large project you suspect fragmentation issues,
    you should try using a tool that displays your process runtime memory map (on
    Linux, check out `/proc/<PID>/maps` as a starting point). Interpreting it, you
    could possibly look at redesigning your application to avoid said fragmentation.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，如果在一个大型项目中你怀疑存在碎片问题，你应该尝试使用一个显示进程运行时内存映射的工具（在Linux上，可以查看`/proc/<PID>/maps`作为起点）。通过解释它，你可能可以重新设计你的应用程序以避免这种碎片。
- en: Miscellaneous
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杂项
- en: Also, do realize that it's a bug to attempt to use just a pointer to access
    memory unless the memory has already been allocated. Remember that pointers have
    no memory; they have to be allocated memory (either statically at compile time
    or dynamically at runtime).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，要意识到，除非已经分配了内存，否则尝试仅使用指针来访问内存是一个错误。记住指针本身没有内存；它们必须分配内存（无论是在编译时静态分配还是在运行时动态分配）。
- en: 'For example, one writes a C function that uses the parameter as a return value—a
    common C programming trick (these are often called value-result or in-out parameters):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有人编写了一个使用参数作为返回值的C函数——这是一种常见的C编程技巧（这些通常被称为值-结果或输入-输出参数）：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is a bug; the `uptr` variable is just a pointer—it has no memory. One
    way to fix this is as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个错误；`uptr`变量只是一个指针——它没有内存。修复这个问题的一种方法如下：
- en: '[PRE43]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Or, even simpler, why not just use compile-time memory for cases such as this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，更简单地说，为什么不在这种情况下使用编译时内存：
- en: '[PRE44]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we delved into a critical area: the fact that the seemingly
    simple, dynamic memory management APIs can cause deep and difficult-to-detect
    bugs in real-world fielded systems.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入研究了一个关键领域：看似简单的动态内存管理API在实际应用系统中可能引发深层次且难以检测的错误。
- en: The common classes of memory bugs, such as **uninitialized memory usage** (**UMR**),
    out-of-bounds accesses (read|write underflow|overflow bugs), and the double free,
    were covered. Memory leakage is a common and dangerous memory bug—we looked at three
    different cases of it.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了内存错误的常见类别，比如未初始化的内存使用（UMR），越界访问（读取|写入下溢|溢出错误）和双重释放。内存泄漏是一种常见且危险的内存错误——我们看了三种不同的情况。
- en: The supplied `membugs` program helps the reader actually see and try out the
    various memory bugs covered via small test cases. In the next chapter we shall
    dive into using tools to help identify these dangerous defects.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的`membugs`程序帮助读者通过小型测试案例实际看到并尝试各种内存错误。在下一章中，我们将深入使用工具来帮助识别这些危险的缺陷。
