- en: '*Chapter 5*: ALSA SoC Framework – Leveraging Codec and Platform Class Drivers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：ALSA SoC框架 – 利用编解码器和平台类驱动程序'
- en: Audio is an analog phenomenon that can be produced in all sorts of ways. Voice
    and audio have been communication media since the beginning of humanity. Almost
    every kernel provides audio support to userspace applications as an interaction
    mechanism between computers and humans. To achieve this, the Linux kernel provides
    a set of APIs known as **ALSA**, which stands for **Advanced Linux Sound Architecture**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 音频是一种可以以各种方式产生的模拟现象。自人类开始以来，语音和音频一直是通信媒体。几乎每个内核都为用户空间应用程序提供音频支持，作为计算机与人类之间的交互机制。为了实现这一点，Linux内核提供了一组称为**ALSA**的API，代表**高级Linux音频架构**。
- en: 'ALSA was designed for desktop computers, not taking into account embedded world
    constraints. This added a lot of drawbacks when it came to dealing with embedded
    devices, such as the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ALSA是为台式电脑设计的，没有考虑嵌入式世界的限制。这在处理嵌入式设备时带来了很多缺点，比如：
- en: Strong coupling between codec and CPU code, leading to difficulties in porting
    and code duplication.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编解码器和CPU代码之间的紧密耦合，导致移植困难和代码重复。
- en: No standard way to handle notifications about users' audio-related behavior.
    In mobile scenarios, users' audio-related behaviors are frequent, so a special
    mechanism is needed.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有处理有关用户音频行为通知的标准方式。在移动场景中，用户的音频行为频繁，因此需要一种特殊的机制。
- en: In the original ALSA architecture, power efficiency was not considered. But
    for embedded devices (most of the time, battery-backed), this is a key point,
    so there needs to be a mechanism.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在原始的ALSA架构中，没有考虑功率效率。但对于嵌入式设备（大多数情况下是由电池支持的），这是一个关键点，因此需要一种机制。
- en: This is where ASoC comes into the picture. The purpose of the **ALSA System
    on Chip** (**ASoC**) layer is to provide better ALSA support for embedded processors
    and various codecs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是ASoC出现的地方。**ALSA系统芯片**（**ASoC**）层的目的是为嵌入式处理器和各种编解码器提供更好的ALSA支持。
- en: 'ASoC is a new architecture designed to solve the aforementioned problems and
    comes with the following advantages:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ASoC是一种新的架构，旨在解决上述问题，并具有以下优点：
- en: An independent codec driver to reduce coupling with the CPU
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立的编解码器驱动程序以减少与CPU的耦合
- en: 'More convenient configuration of the audio data interface between the CPU and
    codec **Dynamic Audio Power Management** (**DAPM**), dynamically controlling power
    consumption (more information can be found here: [https://www.kernel.org/doc/html/latest/sound/soc/dapm.html](https://www.kernel.org/doc/html/latest/sound/soc/dapm.html))'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更方便地配置CPU和编解码器之间的音频数据接口**动态音频功率管理**（**DAPM**），动态控制功耗（更多信息请参见：[https://www.kernel.org/doc/html/latest/sound/soc/dapm.html](https://www.kernel.org/doc/html/latest/sound/soc/dapm.html)）
- en: Reduced pop and click and increased platform-related controls
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少爆音和点击声，增加与平台相关的控制
- en: To achieve the aforementioned features, ASoC divides the embedded audio system
    into three reusable component drivers, namely the **machine class**, **platform
    class**, and **codec class**. Among them, the platform and codec classes are *cross-platform*,
    and the machine class is *board*-specific. In this chapter and the next chapter,
    we will walk through these component drivers, dealing with their respective data
    structures and how they are implemented.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现上述功能，ASoC将嵌入式音频系统分为三个可重用的组件驱动程序，即**机器类**、**平台类**和**编解码器类**。其中，平台和编解码器类是*跨平台*的，而机器类是*特定于板*的。在本章和下一章中，我们将详细介绍这些组件驱动程序，处理它们各自的数据结构以及它们的实现方式。
- en: 'Here, we will present the Linux ASoC driver architecture and the implementation
    of its different parts, looking specifically at the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将介绍Linux ASoC驱动程序架构及其不同部分的实现，特别关注以下内容：
- en: Introduction to ASoC
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASoC简介
- en: Writing codec class drivers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写编解码器类驱动程序
- en: Writing platform class drivers
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写平台类驱动程序
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Strong knowledge of device tree concepts
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对设备树概念的深入了解
- en: Familiarity with the **Common Clock Framework** (**CCF**) (discussed in [*Chapter
    4*](B10985_04_ePub_AM.xhtml#_idTextAnchor047)*,* *Storming the Common Clock Framework*)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉**通用时钟框架**（**CCF**）（在[*第4章*](B10985_04_ePub_AM.xhtml#_idTextAnchor047)*,*
    *突破通用时钟框架*中讨论）
- en: Familiarity with the regmap API
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉regmap API
- en: Strong knowledge of the Linux kernel DMA framework
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉Linux内核DMA框架
- en: Linux kernel v4.19.X sources, available at [https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核v4.19.X源代码，可在[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)找到
- en: Introduction to ASoC
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASoC简介
- en: 'From an architectural point of view, the ASoC subsystem elements and their
    relationship can be represented as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从架构的角度来看，ASoC子系统的元素及其关系可以表示如下：
- en: '![Figure 5.1 – ASoC architecture'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – ASoC架构'
- en: '](img/Figure_5.1_B10985.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B10985.jpg)'
- en: Figure 5.1 – ASoC architecture
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – ASoC架构
- en: The preceding diagram summarizes the new ASoC architecture, in which the machine
    entity wraps both platform and codec entities.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表总结了新的ASoC架构，其中机器实体包装了平台和编解码器实体。
- en: In the ASoC implementation prior to kernel v4.18, there was strict separation
    between SoC audio codec devices (represented by `struct snd_soc_codec` these days)
    and SoC platform interfaces (represented by `struct snd_soc_platform`) and their
    respective digital audio interfaces. However, there was an increasing amount of
    similar code between codecs, platforms, and other components. This led to a new
    and generic approach, the concept of the `struct snd_soc_component` (which may
    refer to either a codec or a platform) and `struct snd_soc_component_driver` (which
    refers to their respective audio interface drivers).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核v4.18之前的ASoC实现中，SoC音频编解码器设备（现在由`struct snd_soc_codec`表示）和SoC平台接口（由`struct
    snd_soc_platform`表示）及其各自的数字音频接口之间有严格的分离。然而，编解码器、平台和其他组件之间的相似代码越来越多。这导致了一种新的通用方法，即`struct
    snd_soc_component`的概念（可以指代编解码器或平台）和`struct snd_soc_component_driver`（指代它们各自的音频接口驱动程序）。
- en: Now that we have introduced the ASoC concept, we can get deeper into the details,
    discussing digital audio interfaces first.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了ASoC的概念，我们可以深入讨论数字音频接口的细节。
- en: ASoC Digital Audio Interface
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASoC数字音频接口
- en: The **Digital Audio Interface** (**DAI**) is the bus controller that actually
    carries audio data from one end (the SoC, for example) to the other end (the codec).
    ASoC currently supports most of the DAIs found on SoC controllers and portable
    audio codecs today, such as AC97, I2S, PCM, S/PDIF, and TDM.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字音频接口**（**DAI**）是实际上从一端（例如SoC）到另一端（编解码器）携带音频数据的总线控制器。ASoC目前支持大多数SoC控制器和便携式音频编解码器上找到的DAI，如AC97、I2S、PCM、S/PDIF和TDM。'
- en: Important note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: An I2S module supports six different modes, the most useful of which are I2S
    and TDM.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: I2S模块支持六种不同的模式，其中最有用的是I2S和TDM。
- en: ASoC sub-elements
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ASoC子元素
- en: 'As we have seen earlier, an ASoC system is divided into three elements, each
    having a dedicated driver, described as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，ASoC系统分为三个元素，每个元素都有一个专用的驱动程序，描述如下：
- en: '`struct snd_soc_component_driver` (see the `struct snd_pcm_ops` element) structure.
    The PCM driver is platform-agnostic and interacts only with the SOC DMA engine
    upstream APIs. The DMA engine then interacts with the platform-specific DMA driver
    to get the correct DMA settings.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct snd_soc_component_driver`（参见`struct snd_pcm_ops`元素）结构。PCM驱动程序与平台无关，只与SOC
    DMA引擎上游API交互。然后DMA引擎与特定于平台的DMA驱动程序交互，以获取正确的DMA设置。'
- en: It is responsible for carrying the audio data in the **DMA buffer** to the bus
    (or port) Tx FIFO. The logic of this part is more complicated. The next sections
    will elaborate on it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 它负责将**DMA缓冲区**中的音频数据传输到总线（或端口）Tx FIFO。这部分的逻辑更加复杂。接下来的部分将对此进行详细阐述。
- en: '**Codec**: Codec literally means codec, but there are many features in the
    chip. Common ones are AIF, DAC, ADC, Mixer, PGA, Line-in, and Line-out. Some high-end
    codec chips also have an echo canceller, noise suppression, and other components.
    The codec is responsible for the conversion of analog signals from sound sources
    into digital signals that the processor can operate (for capture operations) or
    the conversion of digital signals from sound sources (the CPU) to analog signals
    that humans can recognize in the case of playback. If necessary, it makes the
    corresponding adjustment to the audio signal and controls the path between the
    audio signals since there may be a different flow path for each audio signal in
    the chip.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编解码器**：编解码器字面上意味着编解码器，但芯片中有许多功能。常见的功能有AIF、DAC、ADC、混音器、PGA、Line-in和Line-out。一些高端编解码器芯片还具有回声消除器、降噪等组件。编解码器负责将声源的模拟信号转换为处理器可以操作的数字信号（用于捕获操作），或者将声源（CPU）的数字信号转换为人类可以识别的模拟信号（用于播放）。必要时，它对音频信号进行相应的调整，并控制芯片中每个音频信号的路径，因为每个音频信号可能在芯片中有不同的流路径。'
- en: '`cpu_dai` and `codec_dai`). This link is abstracted in the kernel by instances
    of `struct snd_soc_dai_link`. After configuring the link, the machine driver registers
    (by means of `devm_snd_soc_register_card()`) a `struct snd_soc_card` object, which
    is the Linux kernel abstraction of a sound card. Whereas platform and codec drivers
    are generally reusable, the machine has its specific hardware features that are
    almost non-reusable. The so-called hardware characteristics refer to the link
    between DAIs; an open amplifier through a GPIO; detecting the plugin through a
    GPIO; using a clock such as MCLK/eternal OSC as the reference clock source of
    the I2S CODEC module, and so on.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpu_dai`和`codec_dai`）。这种链接在内核中通过`struct snd_soc_dai_link`的实例来抽象。配置链接后，机器驱动程序通过`devm_snd_soc_register_card()`注册一个`struct
    snd_soc_card`对象，这是Linux内核对声卡的抽象。而平台和编解码器驱动程序通常是可重用的，机器具有其特定的几乎不可重用的硬件特性。所谓的硬件特性是指DAI之间的链接；通过GPIO的开放放大器；通过GPIO检测插件；使用时钟（如MCLK/外部OSC）作为I2S
    CODEC模块的参考时钟源，等等。'
- en: 'From the preceding description, we can produce the following ASoC scheme and
    its relationships:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的描述中，我们可以得出以下ASoC方案及其关系：
- en: '![Figure 5.2 – Linux audio layers and relationships'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2- Linux音频层和关系'
- en: '](img/Figure_5.2_B10985.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.2_B10985.jpg)'
- en: Figure 5.2 – Linux audio layers and relationships
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2- Linux音频层和关系
- en: The preceding diagram is a snapshot of the interaction between Linux kernel
    audio components. Now that we are familiar with ASoC concepts, we can move on
    to its first device driver class, which deals with codec devices.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表是Linux内核音频组件之间交互的快照。现在我们熟悉了ASoC的概念，可以继续介绍它的第一个设备驱动程序类，即处理编解码器设备的类。
- en: Writing codec class drivers
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写编解码器类驱动程序
- en: 'In order to be coupled together, machine, platform, and codec entities need
    dedicated drivers. The codec class driver is the most basic. It implements code
    that should leverage the codec device and expose its hardware properties so that
    user space tools such as `amixer` can play with it. The codec class driver is
    and should be platform-independent. The same codec driver can be used whatever
    the platform. Since it targets a specific codec, it should contain audio controls,
    audio interface capabilities, a codec DAPM definition, and I/O functions. Each
    codec driver must fulfill the following specifications:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行耦合，机器、平台和编解码器实体需要专用驱动程序。编解码器类驱动程序是最基本的。它实现了应该利用编解码器设备并公开其硬件属性，以便用户空间工具（如
    `amixer`）可以使用的代码。编解码器类驱动程序是并且应该是与平台无关的。无论平台如何，都可以使用相同的编解码器驱动程序。由于它针对特定的编解码器，因此应该包含音频控件、音频接口功能、编解码器DAPM定义和I/O函数。每个编解码器驱动程序必须满足以下规范：
- en: Provide an interface to other modules by defining DAI and PCM configurations.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定义DAI和PCM配置为其他模块提供接口。
- en: Provide codec control IO hooks (using I2C or SPI or both APIs).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供编解码器控制IO钩子（使用I2C或SPI或两者的API）。
- en: Expose additional **kcontrols** (**kernel controls**) as needed for userspace
    utilities to dynamically control module behavior.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要公开额外的**kcontrols**（**内核控件**），以便用户空间实用程序动态控制模块行为。
- en: Optionally, define DAPM widgets and establish DAPM routes for dynamic power
    switching and also provide DAC digital mute control.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选择地定义DAPM小部件并建立DAPM路由以进行动态电源切换，并提供DAC数字静音控制。
- en: 'The codec driver includes the codec device (component, actually) itself and
    DAIs components, which are used during the binding with the platform. It is platform-independent.
    By means of `devm_snd_soc_register_component()`, the codec driver registers a
    `struct snd_soc_component_driver` object (which is actually the instance of the
    codec driver that contains pointers to the codec''s routes, widgets, controls,
    and a set of codec-related function callbacks) along with one or more `struct
    snd_soc_dai_driver`, which is an instance of the codec DAI driver that may contain
    an audio stream, for example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 编解码器驱动程序包括编解码器设备（实际上是组件本身）和DAI组件，在与平台绑定期间使用。它是与平台无关的。通过 `devm_snd_soc_register_component()`，编解码器驱动程序注册一个
    `struct snd_soc_component_driver` 对象（实际上是包含指向编解码器路由、小部件、控件和一组编解码器相关函数回调的编解码器驱动程序实例），以及一个或多个
    `struct snd_soc_dai_driver`，它是编解码器DAI驱动程序的实例，可以包含音频流，例如：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This structure must also be provided by the platform driver. However, in the
    ASoC core, the only element in this structure that is mandatory is `name`, since
    it is used for matching the component. The following are the meanings of the elements
    in the structure:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构也必须由平台驱动程序提供。但是，在ASoC核心中，该结构中唯一强制的元素是 `name`，因为它用于匹配组件。以下是该结构中元素的含义：
- en: '`name`: The name of this component is mandatory for both codec and platform.
    Other elements in the structure may not be needed on the platform side.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 该组件的名称对于编解码器和平台都是必需的。结构中的其他元素在平台端可能不需要。'
- en: '`probe`: Component driver probe function, executed (in order to complete the
    component initialization if necessary) when this component driver is probed by
    the machine driver (actually, when the machine driver registers a card made of
    this component with the ASoC core: see `snd_soc_instantiate_card()`).'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`probe`: 组件驱动程序探测函数，在机器驱动程序探测到该组件驱动程序时执行（如果需要完成组件初始化）（实际上是当机器驱动程序使用该组件制作一张卡并在ASoC核心中注册时执行：参见
    `snd_soc_instantiate_card()`）。'
- en: '`remove`: When the component driver is unregistered (which occurs when the
    sound card to which this component driver is bound is unregistered).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove`: 当组件驱动程序被注销时（当与该组件驱动程序绑定的声卡被注销时）。'
- en: '`suspend` and `resume`: Power management callbacks, invoked during system suspend
    or resume stages.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`suspend` 和 `resume`: 在系统挂起或恢复阶段调用的电源管理回调。'
- en: '`controls`: Controls interface pointers, such as controlling volume adjustment,
    channel selection, and so on, mostly for codecs.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controls`: 控制接口指针，主要用于控制音量调节、通道选择等，大多数用于编解码器。'
- en: '`set_pll`: Sets function pointers for phase-locked loops.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_pll`: 设置锁相环的函数指针。'
- en: '`read`: The function to read the codec register.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read`: 读取编解码器寄存器的函数。'
- en: '`write`: The function to write into codec registers.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write`: 写入编解码器寄存器的函数。'
- en: '`num_controls`: The number of controls in controls, that is, the number of
    `snd_kcontrol_new` objects.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_controls`: 控制中的控件数量，即 `snd_kcontrol_new` 对象的数量。'
- en: '`dapm_widgets`: The `dapm` widget pointer.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dapm_widgets`: `dapm` 小部件指针。'
- en: '`num_dapm_widgets` : The number of `dapm` part pointers.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_dapm_widgets`：`dapm` 部件指针的数量。'
- en: '`dapm_routes`: `dapm route` pointers.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dapm_routes`: `dapm route` 指针。'
- en: '`num_dapm_routes` : The number of `dapm` route pointers.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_dapm_routes`：`dapm` 路由指针的数量。'
- en: '`set_sysclk`: Sets clock function pointers.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_sysclk`: 设置时钟函数指针。'
- en: '`ops`: Platform DMA-related callbacks, only necessary when providing this structure
    from within the platform driver (ALSA only); however, with ASoC, this field is
    set up by the ASoC core for you by means of a dedicated ASoC DMA-related API when
    using the generic PCM DMA engine framework.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ops`: 平台DMA相关的回调，仅在从平台驱动程序中提供该结构时才需要（仅限ALSA）；但是，在使用通用PCM DMA引擎框架时，ASoC核心会通过专用的ASoC
    DMA相关API为您设置该字段。'
- en: So far, we have introduced the `struct snd_soc_component_driver` data structure
    in the context of the codec class driver. Remember, this structure abstracts both
    codec and platform devices and will be discussed in the platform driver context
    as well. Still, in the context of the codec class driver, we will need to discuss
    the `struct snd_soc_dai_driver` data structure, which, along with `struct snd_soc_component_driver`,
    abstracts a codec or a platform device, along with its DAI driver.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在编解码器类驱动程序的上下文中介绍了 `struct snd_soc_component_driver` 数据结构。请记住，该结构抽象了编解码器和平台设备，并且在平台驱动程序的上下文中也将进行讨论。但是，在编解码器类驱动程序的上下文中，我们需要讨论
    `struct snd_soc_dai_driver` 数据结构，它与 `struct snd_soc_component_driver` 一起，抽象了编解码器或平台设备，以及它的DAI驱动程序。
- en: Codec DAI and PCM (AKA DSP) configurations
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编解码器DAI和PCM（又名DSP）配置
- en: 'This section is rather generic and should probably be named `struct snd_soc_dai_driver`
    as there are DAIs on the codec, and that must be exported using the `devm_snd_soc_register_component()`
    API. This function also takes a pointer to a `struct snd_soc_component_driver`,
    which is the component driver to which the provided DAI drivers will be bound
    and will be exported (actually, inserted into the ASoC global list of components,
    `component_list`, defined in `sound/soc/soc-core.c`) so that it can be registered
    with the core by the machine driver prior to registering the sound card. This
    structure covers the clocking, formatting, and ALSA operations for each interface
    and is defined in `include/sound/soc-dai.h` as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分相当通用，可能应该被命名为`struct snd_soc_dai_driver`，因为编解码器上有DAI，必须使用`devm_snd_soc_register_component()`
    API导出。这个函数还接受一个指向`struct snd_soc_component_driver`的指针，这是提供的DAI驱动程序将绑定并导出的组件驱动程序（实际上，插入到ASoC全局组件列表`component_list`中，该列表在`sound/soc/soc-core.c`中定义），以便机器驱动程序在注册声卡之前将其注册到核心。该结构涵盖了每个接口的时钟、格式和ALSA操作，并在`include/sound/soc-dai.h`中定义如下：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding block, only the main elements of the structure have been enumerated
    for the sake of readability. The following are their meanings:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的块中，为了便于阅读，只列举了结构的主要元素。以下是它们的含义：
- en: '`name`: This is the name of the DAI interface.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 这是DAI接口的名称。'
- en: '`probe`: The DAI driver probe function, executed when the component driver
    to which this DAI driver belongs is probed by the machine driver (actually, when
    the machine driver registers a card with the ASoC core).'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`probe`: DAI驱动程序探测函数，在机器驱动程序探测到该DAI驱动程序所属的组件驱动程序时执行（实际上，当机器驱动程序向ASoC核心注册卡时）。'
- en: '`remove`: Invoked when the component driver to which this DAI driver belongs
    is unregistered.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove`: 当组件驱动程序取消注册时调用。'
- en: '`suspend` and `resume`: Power management callbacks.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`挂起`和`恢复`: 电源管理回调。'
- en: '`ops`: Points to the `struct snd_soc_dai_ops` structure, which provides callbacks
    for configuring and controlling the DAI.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ops`: 指向`struct snd_soc_dai_ops`结构的指针，该结构提供了配置和控制DAI的回调。'
- en: '`capture`: Points to a `struct snd_soc_pcm_stream` structure, which represents
    the hardware parameters for audio capture. This member describes the number of
    channels, bit rate, data format, and so on supported during audio capture. It
    does not need to be initialized if the capture feature is not needed.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`capture`: 指向`struct snd_soc_pcm_stream`结构，表示音频捕获的硬件参数。该成员描述了在音频捕获过程中支持的通道数、比特率、数据格式等。如果不需要捕获功能，则无需初始化。'
- en: '`playback`: The hardware parameter for audio playback. This member describes
    the number of channels, bit rate, data format, and so on supported during playback.
    It does not need to be initialized if the audio playback feature is not needed.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`播放`: 音频播放的硬件参数。该成员描述了在播放过程中支持的通道数、比特率、数据格式等。如果不需要音频播放功能，则无需初始化。'
- en: 'Actually, codec and platform drivers must register this structure for every
    DAI they have. This is what makes this section generic. It is used later by the
    machine driver to build the link between the codec and the SoC. However, there
    are other data structures that need to be granted some study time in order to
    understand how the whole configuration is done: these are `struct snd_soc_pcm_stream`
    and `struct snd_soc_dai_ops`, described in the next sections.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，编解码器和平台驱动程序必须为它们拥有的每个DAI注册此结构。这就是使得这一部分变得通用的原因。稍后由机器驱动程序使用它来建立编解码器和SoC之间的链接。然而，还有其他数据结构需要一些时间来研究，以了解整个配置是如何完成的：这些是`struct
    snd_soc_pcm_stream`和`struct snd_soc_dai_ops`，在接下来的部分中进行了描述。
- en: DAI operations
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DAI操作
- en: 'The operations are abstracted by instances of the `struct snd_soc_dai_ops`
    structure. This structure contains a set of callbacks that relate to different
    events regarding the PCM interface (that is, it''s most probable that you''ll
    want to prepare the device in some manner before audio transfer starts, so you
    would put the code to do this into your `prepare` callback) or callbacks that
    relate the DAI clock and format configurations. This structure is defined as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作由`struct snd_soc_dai_ops`结构的实例抽象出来。该结构包含一组关于PCM接口的不同事件的回调（也就是说，在音频传输开始之前，您很可能希望以某种方式准备设备，因此您会将执行此操作的代码放入`prepare`回调中）或关于DAI时钟和格式配置的回调。该结构定义如下：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Callback functions in this structure can be basically divided into three classes,
    and the driver can implement some of them according to the actual situation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构中的回调函数基本上可以分为三类，驱动程序可以根据实际情况实现其中的一些。
- en: 'The first class gathers **clock configuration callbacks**, usually called by
    the machine driver. These callbacks are as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一类是**时钟配置回调**，通常由机器驱动程序调用。这些回调如下：
- en: '`set_sysclk` sets the main clock of the DAI. If implemented, this callback
    should derive the best DAI bit and frame clocks from the system or master clock.
    The machine driver can use the `snd_soc_dai_set_sysclk()` API on `cpu_dai` and/or
    `codec_dai` in order to invoke this callback.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_sysclk`设置DAI的主时钟。如果实现了这个回调，应该从系统或主时钟派生最佳的DAI位和帧时钟。机器驱动程序可以在`cpu_dai`和/或`codec_dai`上使用`snd_soc_dai_set_sysclk()`
    API来调用这个回调。'
- en: '`set_pll` sets the PLL parameters. If implemented, this callback should configure
    and enable PLL to generate the output clock based on the input clock. The machine
    driver can use the `snd_soc_dai_set_pll()` API on `cpu_dai` and/or `codec_dai`
    in order to invoke this callback.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_pll`设置PLL参数。如果实现了这个回调，应该配置并启用PLL以根据输入时钟生成输出时钟。机器驱动程序可以在`cpu_dai`和/或`codec_dai`上使用`snd_soc_dai_set_pll()`
    API来调用这个回调。'
- en: '`set_clkdiv` sets the clock division factor. The API from the machine driver
    to invoke this callback is `snd_soc_dai_set_clkdiv()`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_clkdiv`设置时钟分频因子。机器驱动程序调用此回调的API是`snd_soc_dai_set_clkdiv()`。'
- en: 'The second callback class is the **format configuration callbacks** of the
    DAI, usually called by the machine driver. These callbacks are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个回调类是DAI的**格式配置回调**，通常由机器驱动程序调用。这些回调如下：
- en: '`set_fmt` sets the format of the DAI. The machine driver can use the `snd_soc_dai_set_fmt()`
    API to invoke this callback (on either CPU or codec DAIs, or both) in order to
    configure the DAI hardware audio format.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_fmt`设置DAI的格式。机器驱动程序可以使用`snd_soc_dai_set_fmt()`API调用此回调（在CPU或编解码器DAI上，或两者都有）以配置DAI硬件音频格式。'
- en: '`set_tdm_slot`: If the DAI supports `snd_soc_dai_set_tdm_slot()`, in order
    to configure the specified DAI for TDM operations.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_tdm_slot`：如果DAI支持`snd_soc_dai_set_tdm_slot()`，则可以配置指定的DAI以进行TDM操作。'
- en: '`set_channel_map`: Channel TDM mapping settings. The machine driver invokes
    this callback for the specified DAI using the `snd_soc_dai_set_channel_map()`
    API.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_channel_map`：通道TDM映射设置。机器驱动程序使用`snd_soc_dai_set_channel_map()`API为指定的DAI调用此回调。'
- en: '`set_tristate`: Sets the state of the DAI pin, which is needed when using the
    same pin in parallel with other DAIs. It is invoked from the machine driver by
    using the `snd_soc_dai_set_tristate()` API.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_tristate`：设置DAI引脚的状态，在与其他DAI并行使用同一引脚时需要。机器驱动程序可以使用`snd_soc_dai_set_tristate()`API从机器驱动程序中调用它。'
- en: 'The last callback class is the normal standard frontend witch gathers PCM correction
    operations usually invoked by the ASoC core. The concerned callbacks are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个回调类是通常由ASoC核心调用的正常标准前端，用于收集PCM校正操作。相关的回调如下：
- en: '`startup`: Invoked by ALSA when a PCM sub-stream is opened (when someone has
    opened the capture/playback device (At device file open for example).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startup`：当打开PCM子流（例如有人打开捕获/播放设备的设备文件）时，ALSA会调用此函数。'
- en: '`shutdown`: This callback should implement code that will undo what has been
    done during startup.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown`：此回调应实现在启动期间所做的操作的撤消。'
- en: '`hw_params`: This is called when setting up the audio stream. The `struct snd_pcm_hw_params`
    contains the audio characteristics.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hw_params`：在设置音频流时调用此函数。`struct snd_pcm_hw_params`包含音频特性。'
- en: '`hw_free`: Should undo what has been done in `hw_params`.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hw_free`：应撤消`hw_params`中所做的操作。'
- en: '`prepare`: This is called when PCM is *ready*. Please see the following PCM
    common state change flow in order to understand when this callback is called.
    DMA transfer parameters are set according to channels, `buffer_bytes`, and so
    on, which are related to the specific hardware platform.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prepare`：当PCM准备就绪时调用此函数。请参阅以下PCM常见状态更改流程，以了解何时调用此回调。根据与特定硬件平台相关的通道、`buffer_bytes`等设置DMA传输参数。'
- en: '`trigger`: This is called when PCM starts, stops, and pauses. The `int` argument
    in this callback is a command that may be one of `SNDRV_PCM_TRIGGER_START`, `SNDRV_PCM_TRIGGER_RESUME`,
    or `SNDRV_PCM_TRIGGER_PAUSE_RELEASE` according to the event. Drivers can use `switch...case`
    in order to iterate over events.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trigger`：当PCM启动、停止和暂停时调用此函数。此回调中的`int`参数是一个命令，可以是`SNDRV_PCM_TRIGGER_START`、`SNDRV_PCM_TRIGGER_RESUME`或`SNDRV_PCM_TRIGGER_PAUSE_RELEASE`中的一个，根据事件。驱动程序可以使用`switch...case`来迭代事件。'
- en: '(Optional) `digital_mute`: An anti-pop sound called by the ASoC core. It may
    be invoked by the core when the system is being suspended, for example.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （可选）`digital_mute`：ASoC核心调用的防爆音。例如，当系统被挂起时，核心可能会调用它。
- en: 'In order to figure out how the preceding callbacks could be invoked by the
    core, let''s have a look at the PCM common state changes flow:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了弄清前述回调如何被核心调用，让我们看一下PCM常见状态更改流程：
- en: '**First started**: *off --> standby --> prepare --> on*'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**首次启动**：*off --> standby --> prepare --> on*'
- en: '**Stop**: *on --> prepare --> standby*'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**停止**：*on --> prepare --> standby*'
- en: '**Resume**: *standby --> prepare --> on*'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**恢复**：*standby --> prepare --> on*'
- en: Each state in the preceding flow will invoke a callback. All this being said,
    we can delve into hardware configuration data structures, either for capture or
    playback operations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述流程中的每个状态都会调用一个回调。总之，我们可以深入研究硬件配置数据结构，无论是捕获还是播放操作。
- en: Capture and playback hardware configuration
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获和播放硬件配置
- en: 'During capture or playback operations, the DAI setting (such as the channel
    number) and capabilities should be set in order to allow the underlying PCM stream
    to be configured. You achieve this by filling an instance of `struct snd_soc_pcm_stream`
    defined as follows for each operation and for each DAI, in both codec and platform
    drivers:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获或播放操作期间，应设置DAI设置（如通道号）和功能，以允许配置底层PCM流。您可以通过为每个操作和每个DAI填充一个`struct snd_soc_pcm_stream`的实例来实现这一点，该结构在编解码器和平台驱动程序中都有定义：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The main members of this structure can be described as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构的主要成员可以描述如下：
- en: '`stream_name`: The name of the stream, either `"Playback"` or `"Capture"`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stream_name`：流的名称，可以是`“Playback”`或`“Capture”`。'
- en: '`formats`: A collection of supported data formats (valid values are defined
    in `include/sound/pcm.h` prefixed with `SNDRV_PCM_FMTBIT_`), such as `SNDRV_PCM_FMTBIT_S16_LE`
    or `SNDRV_PCM_FMTBIT_S24_LE`. If multiple formats are supported, each format can
    be combined, such as `SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`formats`：一组支持的数据格式（有效值在`include/sound/pcm.h`中以`SNDRV_PCM_FMTBIT_`为前缀定义），例如`SNDRV_PCM_FMTBIT_S16_LE`或`SNDRV_PCM_FMTBIT_S24_LE`。如果支持多种格式，则可以组合每种格式，例如`SNDRV_PCM_FMTBIT_S16_LE
    | SNDRV_PCM_FMTBIT_S20_3LE`。'
- en: '`rates`: A set of supported sampling rates (prefixed with `SNDRV_PCM_RATE_`
    and the whole valid values are defined in `include/sound/pcm.h`), such as `SNDRV_PCM_RATE_44100`
    or `SNDRV_PCM_RATE_48000`. If multiple sampling rates are supported, each sampling
    rate can be increased, such as `SNDRV_PCM_RATE_48000 | SNDRV_PCM_RATE_88200`.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rates`：一组支持的采样率（以`SNDRV_PCM_RATE_`为前缀，所有有效值均在`include/sound/pcm.h`中定义），例如`SNDRV_PCM_RATE_44100`或`SNDRV_PCM_RATE_48000`。如果支持多个采样率，则可以增加每个采样率，例如`SNDRV_PCM_RATE_48000
    | SNDRV_PCM_RATE_88200`。'
- en: '`rate_min`: The minimum supported sample rate.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rate_min`：支持的最小采样率。'
- en: '`rate_max`: The maximum supported sample rate.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rate_max`：支持的最大采样率。'
- en: '`channels_min`: The minimum supported number of channels.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channels_min`：支持的最小通道数。'
- en: The concept of controls
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制的概念
- en: It is common for codec drivers to expose some codec properties that can be altered
    from the userspace. These are codec controls. When the codec is initialized, all
    the defined audio controls are registered to the ALSA core. The structure of an
    audio control is `struct snd_kcontrol_new` defined as `include/sound/control.h`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 编解码器驱动程序通常会公开一些可以从用户空间更改的编解码器属性。这些是编解码器控件。当初始化编解码器时，所有定义的音频控件都会注册到ALSA核心。音频控件的结构是`include/sound/control.h`中定义的`struct
    snd_kcontrol_new`。
- en: In addition to the DAI bus, codec devices are equipped with a control bus, an
    I2C or SPI bus most of time. In order to not bother about each codec driver to
    implement its control access routines, the codec control I/O has been standardized.
    This was where the regmap API originated. You can use regmap to abstract the control
    interface so that the codec driver does not have to worry about what the current
    control method is. The audio codec frontend is implemented in `sound/soc/soc-io.c`.
    This relies on the regmap API, which has already been discussed, in [*Chapter
    2*](B10985_02_ePub_AM.xhtml#_idTextAnchor030), *Leveraging the Regmap API and
    Simplifying the Code.*
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了DAI总线外，编解码器设备通常配备有一个控制总线，大多数情况下是I2C或SPI总线。为了不让每个编解码器驱动程序都去实现其控制访问例程，编解码器控制I/O已经被标准化。这就是regmap
    API的起源。您可以使用regmap来抽象控制接口，以便编解码器驱动程序不必担心当前的控制方法是什么。音频编解码器前端是在`soc/soc-io.c`中实现的。这依赖于已经讨论过的regmap
    API，在[*第2章*](B10985_02_ePub_AM.xhtml#_idTextAnchor030)中，*利用Regmap API简化代码*。
- en: 'The codec driver then needs to provide read and write interfaces in order to
    access the underlying codec registers. These callbacks need to be set in the `.read`
    and `.write` fields of the codec component driver, the `struct snd_soc_component_driver`.
    The following are the high-level APIs that can be used to access the component
    registers:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编解码器驱动程序需要提供读取和写入接口，以便访问底层编解码器寄存器。这些回调需要在编解码器组件驱动程序的`.read`和`.write`字段中设置，即`struct
    snd_soc_component_driver`。以下是可用于访问组件寄存器的高级API：
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Each helper in the preceding is self-descriptive. Before we delve into control
    implementation, notice that the control framework is made of several types:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的每个辅助程序都是自描述的。在深入控制实现之前，请注意控制框架由几种类型组成：
- en: A simple switch control, which is a single logical value in a register
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的开关控制，即寄存器中的单个逻辑值
- en: A stereo control, which is the stereo version of the previous simple switch
    control, controlling two logical values at the same time in the register
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立体声控制 - 是前述简单开关控制的立体声版本，在寄存器中同时控制两个逻辑值
- en: A mixer control, which is a combination of multiple simple controls and whose
    output is the mix of its inputs
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混音控制 - 是多个简单控制的组合，其输出是其输入的混合
- en: MUX controls – the same as the aforementioned mixer control, but selecting one
    among many
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MUX控制 - 与前述混音控制相同，但在多个控件中选择一个
- en: 'From within ALSA, a control is abstracted by means of the `struct snd_kcontrol_new`
    structure, defined as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在ALSA中，控件通过`struct snd_kcontrol_new`结构进行抽象，定义如下：
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following are the descriptions of the fields in the aforementioned data
    structure:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 上述数据结构中字段的描述如下：
- en: 'The `iface` field specifies the control type. It is of type `snd_ctl_elem_iface_t`,
    which is an enum of `SNDRV_CTL_ELEM_IFACE_XXX`, where `XXX` can be `MIXER`, `PCM`,
    and so on. The list of possible values can be found here: [https://elixir.bootlin.com/linux/v4.19/source/include/uapi/sound/asound.h#L848](https://elixir.bootlin.com/linux/v4.19/source/include/uapi/sound/asound.h#L848).
    If the control is closely associated with a specific device on the sound card,
    you can use `HWDEP`, `PCM`, `RAWMIDI`, `TIMER`, or `SEQUENCER`, and specify the
    device number with the device and subdevice (which is the substream in the device)
    fields.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iface`字段指定控制类型。它是`snd_ctl_elem_iface_t`类型，是`SNDRV_CTL_ELEM_IFACE_XXX`的枚举，其中`XXX`可以是`MIXER`、`PCM`等。可能的值列表可以在这里找到：[https://elixir.bootlin.com/linux/v4.19/source/include/uapi/sound/asound.h#L848](https://elixir.bootlin.com/linux/v4.19/source/include/uapi/sound/asound.h#L848)。如果控制与声卡上的特定设备密切相关，可以使用`HWDEP`、`PCM`、`RAWMIDI`、`TIMER`或`SEQUENCER`，并使用设备和子设备（即设备中的子流）字段指定设备号。'
- en: '`name` is the name of the control. This field has an important role that allows
    controls to be categorized by name. ALSA has somehow standardized some control
    names, which we discuss in detail in the *Control naming convention* section.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`是控制的名称。该字段具有重要作用，允许按名称对控件进行分类。ALSA已经在某种程度上标准化了一些控件名称，我们将在*控件命名约定*部分详细讨论。'
- en: The `index` field is used to save the number of controls on the card. If there
    is more than one codec on the sound card, and each codec has a control with the
    same name, then we can distinguish these controls by `index`. When `index` is
    0, this differentiation strategy can be ignored.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`字段用于保存卡上控件的数量。如果声卡上有多个编解码器，并且每个编解码器都有相同名称的控制，则可以通过`index`来区分这些控制。当`index`为0时，可以忽略这种区分策略。'
- en: '`access` contains the access right of the control in the form `SNDRV_CTL_ELEM_ACCESS_XXX`.
    Each bit represents an access type that can be combined with multiple OR operations.
    `XXX` can be either `READ`, `WRITE`, or `VOLATILE`, and so on. Possible bitmasks
    can be found here: [https://elixir.bootlin.com/linux/v4.19/source/include/uapi/sound/asound.h#L858](https://elixir.bootlin.com/linux/v4.19/source/include/uapi/sound/asound.h#L858).'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`access`包含控制的访问权限，格式为`SNDRV_CTL_ELEM_ACCESS_XXX`。每个位表示一个访问类型，可以与多个OR操作组合。`XXX`可以是`READ`、`WRITE`或`VOLATILE`等。可能的位掩码可以在这里找到：[https://elixir.bootlin.com/linux/v4.19/source/include/uapi/sound/asound.h#L858](https://elixir.bootlin.com/linux/v4.19/source/include/uapi/sound/asound.h#L858)。'
- en: '`get` is the callback function used to read the current value of the control
    and return it to the application in the userspace.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`是用于读取控制的当前值并将其返回到用户空间应用程序的回调函数。'
- en: '`put` is the callback function used to set the application''s control value
    to the control.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put`是用于将应用程序的控制值设置为控制的回调函数。'
- en: The `info` callback function is used to get the details about the control.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info`回调函数用于获取有关控件的详细信息。'
- en: The `tlv` field provides metadata for the control.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tlv`字段为控件提供元数据。'
- en: Control naming convention
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控件命名约定
- en: ALSA expects controls to be named in a certain way. In order to achieve this,
    ALSA has predefined some commonly used sources (such as Master, PCM, CD, Line,
    and so on), directions (representing the data flow of the control, such as Playback,
    Capture, Bypass, Bypass Capture, and so on), and functions (according to the function
    of the control, such as Switch, Volume, Route, and so on). Do note that no definition
    of the direction means that the control is two-way (playback and capture).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ALSA期望以某种方式命名控件。为了实现这一点，ALSA预定义了一些常用的源（如Master、PCM、CD、Line等）、方向（表示控件的数据流动，如Playback、Capture、Bypass、Bypass
    Capture等）和功能（根据控件的功能，如Switch、Volume、Route等）。请注意，如果没有方向的定义，这意味着控件是双向的（播放和捕获）。
- en: 'You can refer to the following link for more details on ALSA control naming:
    [https://www.kernel.org/doc/html/v4.19/sound/designs/control-names.html](https://www.kernel.org/doc/html/v4.19/sound/designs/control-names.html).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下链接，了解有关ALSA控件命名的更多详细信息：[https://www.kernel.org/doc/html/v4.19/sound/designs/control-names.html](https://www.kernel.org/doc/html/v4.19/sound/designs/control-names.html)。
- en: Control metadata
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控件元数据
- en: There are mixer controls that need to provide information in `DECLARE_TLV_xxx`
    macro to define some variables containing this information, then point the control
    `tlv.p` field to these variables, and finally add the `SNDRV_CTL_ELEM_ACCESS_TLV_READ`
    flag to the access field.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有些混音控件需要在`DECLARE_TLV_xxx`宏中提供信息，以定义包含此信息的一些变量，然后将控件`tlv.p`字段指向这些变量，并最后将`SNDRV_CTL_ELEM_ACCESS_TLV_READ`标志添加到访问字段中。
- en: '`DECLARE_TLV_DB_SCALE` will define information about a mixer control where
    each step in the control''s value changes the dB value by a constant dB amount.
    Let''s take the following example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`DECLARE_TLV_DB_SCALE`将定义有关混音控件的信息，其中控件值的每一步更改都会以恒定的dB量改变。让我们看下面的例子：'
- en: '[PRE6]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'According to the definition of this macro in `include/sound/tlv.h`, the preceding
    example could be expanded into the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`include/sound/tlv.h`中此宏的定义，上述示例可以扩展为以下内容：
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first parameter of the macro represents the name of the variable to be defined;
    the second one represents the minimum value this control can accept, in units
    of `0.01` dB. The third parameter is the step size of the change, also in steps
    of `0.01` dB. If a mute operation is performed when the control is at the minimum
    value, the fourth parameter needs to be set to `1`. Please have a look at `include/sound/tlv.h`
    to see the available macros.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的第一个参数表示要定义的变量的名称；第二个表示此控件可以接受的最小值，以`0.01` dB为单位。第三个参数是更改的步长，也是以`0.01` dB的步长。如果在控件处于最小值时执行静音操作，则需要将第四个参数设置为`1`。请查看`include/sound/tlv.h`以查看可用的宏。
- en: Upon sound card registration, the `snd_ctl_dev_register()` function is called
    in order to save relevant information about the control device and make it available
    to users.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在声卡注册时，将调用`snd_ctl_dev_register()`函数，以保存有关控制设备的相关信息，并使其对用户可用。
- en: Defining kcontrols
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义kcontrols
- en: 'kcontrols are used by the ASoC core to export audio controls (such as switch,
    volume, *MUX…) to the userspace. This means, for example, when a userspace application
    like PulseAudio switches off headphones or switches on speakers when no headphones
    are plugged in, the action is handled in the kernel by kcontrols. Normal kcontrols
    are not involved in power management (DAPM). They are specially meant to control
    non-power-management-based elements such as volume level, gain level, and so on.
    Once controls have been set up using the appropriate macros, they must be registered
    with the system control list using the `snd_soc_add_component_controls()` method,
    whose prototype is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: kcontrols由ASoC核心用于向用户空间导出音频控件（如开关、音量、*MUX…）。这意味着，例如，当用户空间应用程序（如PulseAudio）在未插入耳机时关闭耳机或打开扬声器时，该操作由kcontrols在内核中处理。普通的kcontrols不涉及电源管理（DAPM）。它们专门用于控制非基于电源管理的元素，如音量级别、增益级别等。一旦使用适当的宏设置了控件，必须使用`snd_soc_add_component_controls()`方法将其注册到系统控件列表中，其原型如下：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding prototype, `component` is the component you add the controls
    for, `controls` is the array of controls to add, and `num_controls` is the number
    of entries in the array that need to be added.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述原型中，`component`是您为其添加控件的组件，`controls`是要添加的控件数组，`num_controls`是需要添加的数组中的条目数。
- en: 'In order to see how simple this API is, let''s consider the following sample,
    which defines some controls:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这个API有多简单，让我们考虑以下示例，定义一些控件：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The corresponding code that would register the preceding controls is as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注册前述控件的相应代码如下：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The following are ways to define commonly used controls with these preset macro
    definitions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用这些预设宏定义常用控件的方法。
- en: SOC_SINGLE(xname, reg, shift, max, invert)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: SOC_SINGLE(xname, reg, shift, max, invert)
- en: 'To set up a simple switch, we can use `SOC_SINGLE`. This is the simplest control:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置一个简单的开关，我们可以使用`SOC_SINGLE`。这是最简单的控件：
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This type of control has only one setting and is generally used for component
    switches. Descriptions of the parameters defined by the macro are as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的控件只有一个设置，通常用于组件开关。由宏定义的参数描述如下：
- en: '`xname`: The name of the control.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`xname`：控制的名称。'
- en: '`reg`: The register address corresponding to the control.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reg`：与控件对应的寄存器地址。'
- en: '`Shift`: The offset control bit (from where to apply the change) for this control
    in the register `reg`.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Shift`：在寄存器`reg`中控制位的偏移量（从哪里应用更改）。'
- en: '`max`: The range of values set by the control. Generally speaking, if the control
    bit has only `1` bit, then `max=1`, because the possible values are only `0` and
    `1`.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max`：控件设置的值范围。一般来说，如果控制位只有`1`位，则`max=1`，因为可能的值只有`0`和`1`。'
- en: '`invert`: Whether the set value is inverted.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invert`：设置值是否被反转。'
- en: 'Let''s study the following example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来学习以下示例：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the previous example, `PCM Playback -6dB Switch` is the name of the control.
    `WM8960_DACCTL1` (defined in `wm8960.h`) is the address of the register in the
    codec (the WM8960 chip), which allows you to control this switch:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`PCM Playback -6dB Switch`是控制的名称。`WM8960_DACCTL1`（在`wm8960.h`中定义）是在编解码器（WM8960芯片）中的寄存器的地址，允许您控制此开关：
- en: '`7` means the `7th` bit in the `DACCTL1` register is used to enable/disable
    the DAC 6dB attenuation.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`7`表示`DACCTL1`寄存器中的第`7`位用于启用/禁用6dB衰减的DAC。'
- en: '`1` means there is only one enable or disable option.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`表示只有一个启用或禁用选项。'
- en: '`0` means the value you set is not inverted.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`表示您设置的值没有被反转。'
- en: SOC_SINGLE_TLV(xname, reg, shift, max, invert, tlv_array)
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SOC_SINGLE_TLV（xname，reg，shift，max，invert，tlv_array）
- en: 'This macro sets up a switch with levels. It is an extension of `SOC_SINGLE`
    that is used to define controls that have gain control, such as volume controls,
    EQ equalizers, and so on. In this example, the left input volume control is from
    000000 (`-17.25` dB) to 111111(`+30` dB). Each step is `0.75` dB, meaning a total
    of `63` steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏设置了一个带有级别的开关。它是`SOC_SINGLE`的扩展，用于定义具有增益控制的控件，例如音量控件，EQ均衡器等。在这个例子中，左输入音量控制范围从000000（`-17.25`
    dB）到111111（`+30` dB）。每个步骤为`0.75` dB，意味着总共`63`个步骤：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The scale of `in_tlv` (which represents the control metadata) is declared like
    this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`in_tlv`的刻度（代表控制元数据）声明如下：'
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding, `-1725` means the control scale starts from `-17.25dB`. `75`
    means each step is `0.75dB`, and `0` means the step starts from 0\. For some volume
    control cases, the first step is "mute" and the step starts from `1`. Thus the
    `0` in the preceding code should be replaced by `1`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，`-1725`表示控制刻度从`-17.25dB`开始。`75`表示每个步骤为`0.75dB`，`0`表示步骤从0开始。对于一些音量控制情况，第一步是“静音”，步骤从`1`开始。因此，上述代码中的`0`应替换为`1`。
- en: SOC_DOUBLE_R(xname, reg_left, reg_right, xshift, xmax, xinvert)
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SOC_DOUBLE_R（xname，reg_left，reg_right，xshift，xmax，xinvert）
- en: '`SOC_DOUBLE_R` is a stereo version of `SOC_SINGLE`. The difference is that
    `SOC_SINGLE` only controls one variable, while `SOC_DOUBLE` can control two similar
    variables in one register at the same time. We may use this to control the left
    and right channels at the same time.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`SOC_DOUBLE_R`是`SOC_SINGLE`的立体声版本。不同之处在于`SOC_SINGLE`只控制一个变量，而`SOC_DOUBLE`可以同时控制一个寄存器中的两个相似变量。我们可以使用这个来同时控制左右声道。'
- en: 'Because there is one more channel, the parameter has a shift value corresponding
    to it. The following is an example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有一个额外的通道，参数具有相应的移位值。以下是一个示例：
- en: '[PRE15]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: SOC_DOUBLE_R_TLV(xname, reg_left, reg_right, xshift, xmax, xinvert, tlv_array)
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SOC_DOUBLE_R_TLV（xname，reg_left，reg_right，xshift，xmax，xinvert，tlv_array）
- en: '`SOC_DOUBLE_R_TLV` is the stereo version of `SOC_SINGLE_TLV`. The following
    is an example of its usage:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`SOC_DOUBLE_R_TLV`是`SOC_SINGLE_TLV`的立体声版本。以下是其用法示例：'
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The mixer control
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 混音控制
- en: 'The mixer control is used for routing the control of audio channels. It consists
    of multiple inputs and one output. Multiple inputs can be freely mixed together
    to form a mixed output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 混音控制用于路由音频通道的控制。它由多个输入和一个输出组成。多个输入可以自由混合在一起形成混合输出：
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding mixer uses the third, fifth, sixth, and seventh bits of the `WM8993_SPEAKER_MIXER`
    register to control the opening and closing of the four inputs.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 前述混音使用`WM8993_SPEAKER_MIXER`寄存器的第三、第五、第六和第七位来控制四个输入的打开和关闭。
- en: SOC_ENUM_SINGLE(xreg, xshift, xmax, xtexts)
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SOC_ENUM_SINGLE（xreg，xshift，xmax，xtexts）
- en: This macro defines a single enumerated control, where `xreg` is the register
    to modify to apply settings, `xshift` is the control bit(s) offset in the register,
    `xmask` is the control bit(s) size, and `xtexts` is a pointer to the array of
    strings that describe each setting. This is used when the control options are
    some texts.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏定义了一个单个枚举控制，其中`xreg`是要修改以应用设置的寄存器，`xshift`是寄存器中的控制位偏移，`xmask`是控制位大小，`xtexts`是指向描述每个设置的字符串数组的指针。当控制选项是一些文本时使用。
- en: 'As an example, we can set up the array for the texts as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以设置文本数组如下：
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And then define the enum as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后定义枚举如下：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now we are done with the concept of controls, which are used to change the properties
    of an audio device, we will learn how to leverage it and play with the power properties
    of an audio device.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了控件的概念，它们用于更改音频设备的属性，我们将学习如何利用它并玩转音频设备的功率属性。
- en: The concept of DAPM
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DAPM的概念
- en: Modern sound cards consist of many independent discrete components. Each component
    has functional units that can be powered independently. The thing is, embedded
    systems are, most of the time, battery-powered and require the lowest power mode.
    Managing power domain dependencies by hand could be tedious and error-prone. **Dynamic
    Audio Power Management** (**DAPM**) targets the lowest use of power at all times
    in the audio subsystem. DAPM is to be used for things for which there is power
    control and can be skipped if power management is not necessary. Things only go
    into DAPM if they have some relevance to power – that is, if they're a thing for
    which there is power control or if they control the routing of audio through the
    chip (and therefore let the core decide which parts of the chip need to be powered
    on).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现代声卡由许多独立的离散组件组成。每个组件都有可以独立供电的功能单元。问题是，嵌入式系统大部分时间都是由电池供电的，并且需要最低功耗模式。手动管理电源域依赖可能会很繁琐且容易出错。**动态音频功率管理**（**DAPM**）旨在在音频子系统中始终以最低功耗使用电源。DAPM用于需要电源控制并且如果不需要电源管理则可以跳过的事物。只有当事物与电源有关时，才会进入DAPM
    - 也就是说，如果它们是需要电源控制的事物，或者如果它们控制了音频通过芯片的路由（因此让核心决定哪些芯片部分需要通电）。
- en: DAPM lies in the ASoC Core (this means power switching is done from within the
    kernel) and becomes active as and when audio streams/paths/settings change, making
    it completely transparent for all userspace applications.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: DAPM位于ASoC核心中（这意味着电源切换是从内核内部完成的），并且在音频流/路径/设置发生变化时变得活跃，使其对所有用户空间应用程序完全透明。
- en: 'In the previous sections, we introduced the concept of controls and how to
    deal with them. However, kcontrols on their own are not involved in audio power
    management. A normal kcontrol has the following characteristics:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们介绍了控件的概念以及如何处理它们。然而，单独的kcontrols并不涉及音频电源管理。普通的kcontrol具有以下特征：
- en: Self-descriptive and cannot describe the connection relationship between each
    kcontrol.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自描述，无法描述每个kcontrol之间的连接关系。
- en: Lacks a power management mechanism.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏电源管理机制。
- en: Lacks a time processing mechanism to respond to audio events such as playing,
    stopping, powering on, and powering off.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏响应音频事件的时间处理机制，例如播放、停止、开机和关机。
- en: Lacks a pop-pop sound prevention mechanism, so that it is up to the user program
    to pay attention to the power-on and power-off sequence for each kcontrol.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏防止啪啪声的机制，因此用户程序需要注意每个kcontrol的开机和关机顺序。
- en: Manual, because all the control involved in an audio path can't be automatically
    closed. When an audio path is no longer valid, it requires userspace intervention.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动，因为所有涉及音频路径的控件不能自动关闭。当音频路径不再有效时，需要用户空间干预。
- en: DAPM introduced the concept of widgets in order to solve the aforementioned
    problems. A widget is the basic DAPM unit. Thus, the so-called widget can be understood
    as a further upgrade and encapsulation of kcontrols.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: DAPM引入了小部件的概念，以解决上述问题。小部件是DAPM的基本单元。因此，所谓的小部件可以理解为对kcontrols的进一步升级和封装。
- en: A widget is a combination of kcontrols and dynamic power management, and also
    has the link function of the audio path. It can have a dynamic connection relationship
    with its neighbor widget.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件是kcontrols和动态电源管理的组合，还具有音频路径的链接功能。它可以与相邻小部件建立动态连接关系。
- en: 'The DAPM framework abstracts a widget by means of the `struct snd_soc_dapm_widget`
    structure, defined in `include/sound/soc-dapm.h` as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: DAPM框架通过`struct snd_soc_dapm_widget`结构来抽象小部件，该结构在`include/sound/soc-dapm.h`中定义如下：
- en: '[PRE20]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For the sake of readability, only the relevant fields are listed in the preceding
    snippet, and the following are their descriptions:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于阅读，上述片段中仅列出了相关字段，以下是它们的描述：
- en: '`id` is of type `enum snd_soc_dapm_type` and represents the type of the widget,
    such as `snd_soc_dapm_output`, `snd_soc_dapm_mixer`, and so on. The full list
    is defined in `include/sound/soc-dapm.h`.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`是`enum snd_soc_dapm_type`类型，表示小部件的类型，例如`snd_soc_dapm_output`、`snd_soc_dapm_mixer`等。完整列表在`include/sound/soc-dapm.h`中定义。'
- en: '`name` is the name of the widget.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`是小部件的名称。'
- en: '`shift` and `mask` are used to control the power state of the widget, corresponding
    to the register address `reg`.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shift`和`mask`用于控制小部件的电源状态，对应于寄存器地址`reg`。'
- en: The `on_val` and `off_val` values represent the values that are to be used to
    change the current power state of the widget. They respectively correspond to
    when it is turned on and when it is turned off.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on_val`和`off_val`值表示用于改变小部件当前电源状态的值。它们分别对应于开启时和关闭时。'
- en: '`event` represents the DAPM event handling callback function pointer. Each
    widget is associated with a kcontrol object, pointed to by `**kcontrols`.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event`表示DAPM事件处理回调函数指针。每个小部件都与一个kcontrol对象相关联，由`**kcontrols`指向。'
- en: '`*kcontrol_news` is the array of controls this kcontrol is made of, and `num_kcontrols`
    is the number of entries in it. These three fields are used to describe the kcontrol
    control contained in the widget, such as a mixer control or a MUX control.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*kcontrol_news`是此kcontrol包含的控件数组，`num_kcontrols`是其中的条目数。这三个字段用于描述包含在小部件中的kcontrol控件，例如混音控件或MUX控件。'
- en: '`dirty` is used to insert this widget into a dirty list when the state of the
    widget is changed. This dirty list is then scanned in order to perform the update
    of the entire path.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dirty`用于在小部件状态改变时将该小部件插入脏列表中。然后扫描该脏列表以执行整个路径的更新。'
- en: Defining widgets
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义小部件
- en: 'Like the normal kcontrol, the DAPM framework provides us with a large number
    of auxiliary macros to define a variety of widget controls. These macro definitions
    can be spread into several fields according to the type of widgets and to the
    domain in which they are powered. They are as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通的kcontrol一样，DAPM框架为我们提供了大量的辅助宏来定义各种小部件控件。这些宏定义可以根据小部件的类型和它们所在的领域分成几个字段。它们如下：
- en: '`VREF` and `VMID`; they provide reference voltage widgets. These widgets are
    usually controlled in the codec probe/remove callback.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VREF`和`VMID`；它们提供参考电压小部件。这些小部件通常在编解码器探测/移除回调中进行控制。'
- en: '**The platform/machine domain**: These widgets are usually input/output interfaces
    for the platform or board (machine actually) that need to be physically connected,
    such as headphones, speakers, and microphones. That being said, because these
    interfaces may differ on each board, they are usually configured by the machine
    driver and respond to asynchronous events, for example, when headphones are inserted.
    They can also be controlled by userspace applications to turn them on and off
    in some way.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台/机器领域**：这些小部件通常是平台或板（实际上是机器）的输入/输出接口，需要进行物理连接，例如耳机、扬声器和麦克风。也就是说，由于这些接口在每个板上可能不同，它们通常由机器驱动程序进行配置，并响应异步事件，例如插入耳机时。它们也可以被用户空间应用程序控制以某种方式打开和关闭。'
- en: '`alsamixer` and `amixer`.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alsamixer`和`amixer`。'
- en: '`aplay` and `arecord`.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aplay`和`arecord`。'
- en: All DAPM power switching decisions are made automatically according to a machine-specific
    audio routing map, which consists of the interconnections between every audio
    component (including internal codec components).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 所有DAPM电源切换决策都是根据特定于机器的音频路由图自动进行的，该图由每个音频组件（包括内部编解码器组件）之间的互连组成。
- en: Codec domain deﬁnition
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编解码器领域定义
- en: 'There is only one macro provided by the DAPM framework for this domain:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: DAPM框架仅为该领域提供了一个宏：
- en: '[PRE21]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Deﬁning platform domain widgets
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义平台领域小部件
- en: 'The widgets of the platform domain correspond to the signal generator, input
    pin, output pin, microphone, earphone, speaker, and line input interface respectively.
    The DAPM framework provides us with a number of auxiliary definition macros for
    the platform domain widgets. These are defined as the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 平台域的小部件分别对应信号发生器、输入引脚、输出引脚、麦克风、耳机、扬声器和线路输入接口。DAPM框架为平台域小部件提供了许多辅助定义宏。这些定义如下：
- en: '[PRE22]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, most of the fields in these macros are common. The fact
    that the `reg` field is set to `SND_SOC_NOPM` (defined to `-1`) means that these
    widgets have no register control bits to control the power state of the widgets.
    `SND_SOC_DAPM_INPUT` and `SND_SOC_DAPM_OUTPUT` are used to define the output and
    input pins of the codec chip from within the codec driver. From what we can see,
    the `MIC`, `HP`, `SPK`, and `LINE` widgets respond to `SND_SOC_DAPM_POST_PMU`
    (after widget power-up) and `SND_SOC_DAPM_PMD` (before widget power-down) events,
    and these widgets are usually defined in the machine driver.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，这些宏中的大多数字段是通用的。`reg`字段设置为`SND_SOC_NOPM`（定义为`-1`）的事实意味着这些小部件没有寄存器控制位来控制小部件的电源状态。`SND_SOC_DAPM_INPUT`和`SND_SOC_DAPM_OUTPUT`用于从编解码器驱动程序内部定义编解码器芯片的输出和输入引脚。从我们可以看到，`MIC`、`HP`、`SPK`和`LINE`小部件响应`SND_SOC_DAPM_POST_PMU`（小部件上电后）和`SND_SOC_DAPM_PMD`（小部件下电前）事件，这些小部件通常在机器驱动程序中定义。
- en: Deﬁning an audio path domain widget
  id: totrans-233
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义音频路径域小部件
- en: 'This kind of widget usually repackages the ordinary kcontrols and extends them
    with audio path and power management functions. This extension somehow makes this
    kind of widget DAPM-aware. Widgets in this domain will contain one or more kcontrols
    that are not the ordinary kcontrols. There are DAPM-enabled kcontrols. These cannot
    be defined using the standard method, that is, `SOC_*-b`ased macro controls. They
    need to be defined using the definition macros provided by the DAPM framework.
    We will discuss them in detail later, in the *Deﬁning DAPM kcontrols* section.
    However, here are the definition macros for these widgets:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的小部件通常重新打包普通的kcontrols，并使用音频路径和电源管理功能进行扩展。这种扩展在某种程度上使这种小部件具有DAPM意识。该域中的小部件将包含一个或多个不是普通kcontrols的kcontrols。这些是启用了DAPM的kcontrols。这些不能使用标准方法进行定义，即`SOC_*-b`ased宏控件。它们需要使用DAPM框架提供的定义宏进行定义。我们将在后面的*定义DAPM
    kcontrols*部分详细讨论它们。然而，这里是这些小部件的定义宏：
- en: '[PRE23]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Unlike platform and codec domain widgets, the `reg` and `shift` fields need
    to be assigned, indicating that these widgets have corresponding power control
    registers. The DAPM framework uses these registers to control the power state
    of the widgets when scanning and updating the audio path. Their power states are
    dynamically allocated, powered up when needed (on a valid audio path), and powered
    down when not needed (on an inactive audio path). These widgets need to perform
    the same functions as the mixer, MUX, and so on introduced earlier. In fact, this
    is done by the kcontrol controls they contain. The driver code must define kcontrols
    before defining the widget, and then pass the `wcontrols` and `num_kcontrols`
    parameters to these auxiliary definition macros.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与平台和编解码器域小部件不同，需要分配`reg`和`shift`字段，表明这些小部件具有相应的电源控制寄存器。DAPM框架使用这些寄存器来在扫描和更新音频路径时控制小部件的电源状态。它们的电源状态是动态分配的，在需要时上电（在有效的音频路径上），在不需要时下电（在非活动的音频路径上）。这些小部件需要执行与前面介绍的混音器、MUX等相同的功能。实际上，这是由它们包含的kcontrol控件来完成的。驱动程序代码必须在定义小部件之前定义kcontrols，然后将`wcontrols`和`num_kcontrols`参数传递给这些辅助定义宏。
- en: There is another variant of those macros that exists and that has a pointer
    to an event handler. Such macros have the `_E` suffix. These are `SND_SOC_DAPM_PGA_E`,
    `SND_SOC_DAPM_OUT_DRV_E`, `SND_SOC_DAPM_MIXER_E`, `SND_SOC_DAPM_MIXER_NAMED_CTL_E`,
    `SND_SOC_DAPM_SWITCH_E`, `SND_SOC_DAPM_MUX_E`, and `SND_SOC_DAPM_VIRT_MUX_E`.
    You are encouraged to have a look at the kernel source code to see their definitions
    at [https://elixir.bootlin.com/linux/v4.19/source/include/sound/soc-dapm.h#L136](https://elixir.bootlin.com/linux/v4.19/source/include/sound/soc-dapm.h#L136).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 存在另一种宏的变体，它具有指向事件处理程序的指针。这些宏具有“_E”后缀。它们是`SND_SOC_DAPM_PGA_E`、`SND_SOC_DAPM_OUT_DRV_E`、`SND_SOC_DAPM_MIXER_E`、`SND_SOC_DAPM_MIXER_NAMED_CTL_E`、`SND_SOC_DAPM_SWITCH_E`、`SND_SOC_DAPM_MUX_E`和`SND_SOC_DAPM_VIRT_MUX_E`。鼓励您查看内核源代码，以查看它们在[https://elixir.bootlin.com/linux/v4.19/source/include/sound/soc-dapm.h#L136](https://elixir.bootlin.com/linux/v4.19/source/include/sound/soc-dapm.h#L136)中的定义。
- en: Defining the audio stream domain
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义音频流域
- en: 'These widgets mainly include audio input/output interfaces, ADC/DAC, and clock
    lines. Starting with the audio interface widgets, these are the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这些小部件主要包括音频输入/输出接口、ADC/DAC和时钟线。从音频接口小部件开始，它们如下：
- en: '[PRE24]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding macro definition list, `SND_SOC_DAPM_AIF_IN` and `SND_SOC_DAPM_AIF_OUT`
    are respectively the audio interface input and output. The former defines the
    connection to the host that receives the audio to be passed into the DAC(s) and
    the latter defines the connection to the host that transmits the audio received
    from the ADC(s). `SND_SOC_DAPM_AIF_IN_E` and `SND_SOC_DAPM_AIF_OUT_E` are their
    respective event variants, allowing `wevent` to be called when one of the events
    enabled in `wflags` occurs.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的宏定义列表中，`SND_SOC_DAPM_AIF_IN`和`SND_SOC_DAPM_AIF_OUT`分别是音频接口输入和输出。前者定义了连接到接收要传递到DAC的音频的主机的连接，后者定义了连接到从ADC接收的音频传输到主机的连接。`SND_SOC_DAPM_AIF_IN_E`和`SND_SOC_DAPM_AIF_OUT_E`是它们各自的事件变体，允许在`wflags`中启用的事件发生时调用`wevent`。
- en: 'Now come the ADC/DAC-related widgets, as well as the clock-related one, defined
    as the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是ADC/DAC相关的小部件，以及与时钟相关的小部件，定义如下：
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding list of macros, `SND_SOC_DAPM_ADC` and `SND_SOC_DAPM_DAC` are
    ADC and DAC widgets respectively. The former is used to control the powering up
    and shutting down of the ADC on an as-needed basis, while the latter targets DAC(s).
    The former is typically associated with a capture stream on the device, for example,
    "Left Capture" or "Right Capture," and the latter is typically associated with
    a playback stream, for example, "Left Playback" or "Right Playback." The register
    settings define a single register and bit position that, when flipped, will turn
    the ADC/DAC on or off. You should also notice their event variants, `SND_SOC_DAPM_ADC_E`
    and `SND_SOC_DAPM_DAC_E` respectively. `SND_SOC_DAPM_CLOCK_SUPPLY` is a supply-widget
    variant for connection to the clock framework.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的宏列表中，`SND_SOC_DAPM_ADC`和`SND_SOC_DAPM_DAC`分别是ADC和DAC小部件。前者用于根据需要控制ADC的开启和关闭，而后者则针对DAC。前者通常与设备上的捕获流相关联，例如“左捕获”或“右捕获”，而后者通常与播放流相关联，例如“左播放”或“右播放”。寄存器设置定义了一个单一的寄存器和位位置，翻转时将打开或关闭ADC/DAC。您还应该注意它们的事件变体，分别是`SND_SOC_DAPM_ADC_E`和`SND_SOC_DAPM_DAC_E`。`SND_SOC_DAPM_CLOCK_SUPPLY`是连接到时钟框架的供应小部件变体。
- en: There are other widget types for which no definition macro is provided, and
    that do not end in any of the domains we have introduced so far. These are `snd_soc_dapm_dai_in`,
    `snd_soc_dapm_dai_out`, and `snd_soc_dapm_dai_link`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他小部件类型，没有提供定义宏，并且不属于我们迄今介绍的任何域。这些是`snd_soc_dapm_dai_in`，`snd_soc_dapm_dai_out`和`snd_soc_dapm_dai_link`。
- en: Such widgets are implicitly created upon DAI registration, either from the CPU
    or the codec driver. In other words, whenever a DAI is registered, the DAPM core
    will create a widget either of type `snd_soc_dapm_dai_in` or of type `snd_soc_dapm_dai_out`
    according to the streams of the DAI being registered. Usually, both widgets will
    be connected to widgets with the same stream name in the codec. Additionally,
    when the machine driver decides to bind codec and CPU DAIs together, this will
    result in the DAPM framework creating a widget of type `snd_soc_dapm_dai_link`
    to describe the power state of the connection.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这些小部件是在DAI注册时隐式创建的，无论是来自CPU还是编解码器驱动程序。换句话说，每当注册一个DAI时，DAPM核心将根据注册的DAI流创建一个`snd_soc_dapm_dai_in`或`snd_soc_dapm_dai_out`类型的小部件。通常，这两个小部件将连接到编解码器中具有相同流名称的小部件。此外，当机器驱动程序决定将编解码器和CPU
    DAI绑定在一起时，DAPM框架将创建一个`snd_soc_dapm_dai_link`类型的小部件来描述连接的电源状态。
- en: The concept of a path – a connector between widgets
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 路径的概念-小部件之间的连接
- en: 'Widgets are meant to be linked one to the other in order to build a functional
    audio stream path. That being said, the connection between two widgets needs to
    be tracked in order to maintain the audio state. To describe the patch between
    two widgets, the DAPM core uses the `struct snd_soc_dapm_path` data structure,
    defined as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件应该相互连接，以构建功能性的音频流路径。也就是说，需要跟踪两个小部件之间的连接，以维护音频状态。为了描述两个小部件之间的路径，DAPM核心使用了`struct
    snd_soc_dapm_path`数据结构，定义如下：
- en: '[PRE26]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This structure abstracts the link between two widgets. Its `source` field points
    to the start widget of the connection, whereas its `sink` field points to the
    arrival widget of the connection. The input and output (that is, an endpoint)
    of the widget may be connected to multiple paths. The `snd_soc_dapm_path` structure
    of all inputs is hung in the sources list of the widget through the `list_node[SND_SOC_DAPM_DIR_IN]`
    field while the `snd_soc_dapm_path` structure of all outputs is stored in the
    sinks list of the widget, which is `list_node[SND_SOC_DAPM_DIR_OUT]`. The connection
    goes from the source to the sink and the principle is quite simple. Just remember
    the connection path is this: *the output of the start widget --> the input of
    the path data structure* and *the output of the path data structure --> Arrival
    side widget input*.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构抽象了两个小部件之间的连接。它的`source`字段指向连接的起始小部件，而`sink`字段指向连接的到达小部件。小部件的输入和输出（即端点）可以连接到多个路径。所有输入的`snd_soc_dapm_path`结构都通过`list_node[SND_SOC_DAPM_DIR_IN]`字段挂在小部件的源列表中，而所有输出的`snd_soc_dapm_path`结构都存储在小部件的接收列表中，即`list_node[SND_SOC_DAPM_DIR_OUT]`。连接从源到接收端，原则非常简单。只需记住连接路径是这样的：*起始小部件的输出-->路径数据结构的输入*和*路径数据结构的输出-->到达端小部件的输入*。
- en: The `list` field will end up in the sound card's path list header field upon
    card registration. This list allows the sound card to track all the available
    paths it can use. Finally, the `connected` field is there to let you implement
    your own custom method to check the current connection state of the path.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`字段将在声卡注册时出现在声卡路径列表头字段中。此列表允许声卡跟踪所有可用的路径。最后，`connected`字段用于让您实现自己的自定义方法来检查路径的当前连接状态。'
- en: Important note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: '`SND_SOC_DAPM_DIR_IN` and `SND_SOC_DAPM_DIR_OUT` are enumerators that are `0`
    and `1` respectively.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`SND_SOC_DAPM_DIR_IN`和`SND_SOC_DAPM_DIR_OUT`分别是枚举器`0`和`1`。'
- en: You'll probably never want to deal with a path directly. However, this concept
    has been introduced here for the sake of pedagogy, as it will help us understand
    the next section.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能永远不想直接处理路径。然而，出于教学目的，这里介绍了这个概念，因为它将帮助我们理解下一节。
- en: The concept of a route – widget inter-connections
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 路由的概念-小部件之间的连接
- en: 'The concept of a path, introduced earlier in this chapter, was an introduction
    to this one. From the preceding discussion, we can introduce the concept of a
    route. A route connection is made of at least the starter widget, the jumper path,
    the sink widget, and in the DAPM the `struct snd_soc_dapm_route` structure is
    used to describe such a connection:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面介绍的路径的概念是对这个概念的引入。从前面的讨论中，我们可以介绍路由的概念。路由连接至少由起始小部件、跳线路径、接收小部件组成，在DAPM中使用`struct
    snd_soc_dapm_route`结构来描述这样的连接：
- en: '[PRE27]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding data structure, `sink` points to the name string of the arriving
    widget, `source` points to the name string of the starting widget, `control` points
    to the kcontrol name string responsible for controlling the connection, and `connected`
    defines the custom connection check callback. The meaning of this structure is
    obvious: `source` is connected to `sink` via a `kcontrol` and a `connected` callback
    function can be called to check the connection state.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数据结构中，`sink`指向到达小部件的名称字符串，`source`指向起始小部件的名称字符串，`control`指向负责控制连接的kcontrol名称字符串，`connected`定义了自定义连接检查回调。这个结构的含义是显而易见的：`source`通过`kcontrol`连接到`sink`，并且可以调用`connected`回调函数来检查连接状态。
- en: 'Routes are to be defined using the following scheme:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 路由应使用以下方案定义：
- en: '[PRE28]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This means `Source Widget` is connected to `Destination Widget` via `Swtich`.
    This way, the DAPM core will take care of closing the switch whenever the connection
    needs to be activated, and both source and destination widget will be powered
    on as well. Sometimes, the connection may be direct. In this case, `Switch` should
    be `NULL`. You''ll then have something like the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`源小部件`通过`开关`连接到`目标小部件`。这样，DAPM核心将负责在连接需要被激活时关闭开关，并且源和目标小部件也将被打开。有时，连接可能是直接的。在这种情况下，`开关`应为`NULL`。然后，您将得到以下内容：
- en: '[PRE29]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You should directly use the name string to describe the connection relationship,
    all defined routes, and finally, you have to register to the DAPM core. DAPM core
    will find the corresponding widget according to these names, and dynamically generate
    the required `snd_soc_dapm_path` to describe the connection between the two widgets.
    In the next sections, we'll see how to create routes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您应直接使用名称字符串来描述连接关系，所有定义的路由，最后，您必须注册到DAPM核心。DAPM核心将根据这些名称找到相应的小部件，并动态生成所需的`snd_soc_dapm_path`来描述两个小部件之间的连接。在接下来的章节中，我们将看到如何创建路由。
- en: Deﬁning DAPM kcontrols
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义DAPM kcontrols
- en: 'As mentioned in the previous sections, mixers or MUX-type widgets in the audio
    path domain are made of several kcontrols, which must be defined using DAPM-based
    macros. DAPM uses these kcontrols to complete the audio path. However, for widgets,
    this task is more than that. DAPM also dynamically manages the connection relationships
    of these audio paths so that the power state of these widgets can be controlled
    according to these connection relationships. If these kcontrols are defined in
    the usual way, this is not possible, so DAPM provides us with another set of definition
    macros that define the kcontrols that are included in the widget:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几节所述，音频路径域中的混音器或MUX类型小部件由几个kcontrols组成，必须使用基于DAPM的宏进行定义。DAPM使用这些kcontrols来完成音频路径。但是，对于小部件来说，这项任务不仅仅是如此。DAPM还动态管理这些音频路径的连接关系，以便根据这些连接关系来控制这些小部件的电源状态。如果以通常的方式定义这些kcontrols，这是不可能的，因此DAPM为我们提供了另一组定义宏，用于定义包含在小部件中的kcontrols：
- en: '[PRE30]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It can be seen that `SOC_DAPM_SINGLE` is the DAPM equivalent to `SOC_SINGLE`
    of the standard control, `SOC_DAPM_SINGLE_TLV` corresponds to `SOC_SINGLE_TLV`,
    and so on. Compared to the ordinary kcontrols, DAPM's kcontrols just replace the
    `info`, `get`, and `put` callback functions. The `put` callback function provided
    by DAPM kcontrols not only updates the state of the control itself but also passes
    this change to the adjacent DAPM kcontrol. The adjacent DAPM kcontrol will pass
    this change to its own neighbor DAPM kcontrol, knowing at the end of the audio
    path, by changing the connection state of one of the widgets, all widgets associated
    with it are scanned and tested to see if they are still in the active audio path,
    thus dynamically changing their power state. This is the essence of DAPM.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，`SOC_DAPM_SINGLE`是标准控制的DAPM等效物，`SOC_DAPM_SINGLE_TLV`对应于`SOC_SINGLE_TLV`，依此类推。与普通的kcontrols相比，DAPM的kcontrols只是替换了`info`、`get`和`put`回调函数。DAPM
    kcontrols提供的`put`回调函数不仅更新控件本身的状态，还将此更改传递给相邻的DAPM kcontrol。相邻的DAPM kcontrol将此更改传递给自己的相邻DAPM
    kcontrol，通过更改其中一个小部件的连接状态，知道音频路径的末端，与其关联的所有小部件都将被扫描和测试，以查看它们是否仍然处于活动音频路径中，从而动态地改变它们的电源状态。这就是DAPM的本质。
- en: Creating widgets and routes
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建小部件和路由
- en: 'The previous section introduced a lot of auxiliary macros. However, it was
    theoretical and did not explain how to define the widgets we need for a real system,
    nor how to define the connection relationship of widgets. Here, we take Wolfson''s
    codec chip **WM8960** as an example to understand this process:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的部分介绍了许多辅助宏。但是，这是理论性的，没有解释如何为实际系统定义所需的小部件，也没有解释如何定义小部件的连接关系。在这里，我们以Wolfson的编解码器芯片**WM8960**为例来理解这个过程：
- en: '![Figure 5.3 – WM8960 internal audio paths and controls'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 - WM8960内部音频路径和控件'
- en: '](img/Figure-5.3_B10985.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure-5.3_B10985.jpg)'
- en: Figure 5.3 – WM8960 internal audio paths and controls
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 - WM8960内部音频路径和控件
- en: 'Given the preceding diagram as an example, from the Wolfson WM8960 codec chip,
    the first step is to use the helper macro to define the DAPM kcontrol required
    by the widgets:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 以前面的图示为例，从Wolfson WM8960编解码器芯片开始，第一步是使用辅助宏来定义小部件所需的DAPM kcontrol：
- en: '[PRE31]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding, we defined the mixer controls for the left and right output
    channels in `wm8960`, as well as the mono output mixer: `wm8960_loutput_mixer`,
    `wm8960_routput_mixer`, and `wm8960_mono_out`.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们为`wm8960`中的左右输出通道以及单声道输出混音器定义了混音控件：`wm8960_loutput_mixer`、`wm8960_routput_mixer`和`wm8960_mono_out`。
- en: 'The second step consists of defining the real widget, including the DAPM control
    defined in the first step:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步包括定义真实的小部件，包括在第一步中定义的DAPM控件：
- en: '[PRE32]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this step, a MUX widget is defined for each of the left and right channels
    as well as the channel selector: these are Left Output Mixer, Right Output Mixer,
    and Mono Output Mixer. We also define a mixer widget for each of the left and
    right speakers: `SPK_LP`, `SPK_LN`, `HP_L`, `HP_R`, `SPK_RP`, `OUT3`, and `SPK_RN`.
    The specific mixer control is done by `wm8960_loutput_mixer`, `wm8960_routput_mixer`,
    and `wm8960_mono_out` defined in the previous step. The three widgets have power
    properties, so when one (or more) of these widgets are in one valid audio path,
    the DAPM framework can control its power state via bits 7 and/or 8 of their respective
    registers.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，为左右声道和通道选择器分别定义了MUX小部件：左输出混音器、右输出混音器和单声道混音器。我们还为左右扬声器分别定义了混音器小部件：`SPK_LP`、`SPK_LN`、`HP_L`、`HP_R`、`SPK_RP`、`OUT3`和`SPK_RN`。特定的混音控制由前一步中定义的`wm8960_loutput_mixer`、`wm8960_routput_mixer`和`wm8960_mono_out`完成。这三个小部件具有电源属性，因此当这些小部件中的一个（或多个）在一个有效的音频路径中时，DAPM框架可以通过它们各自寄存器的第7位和/或第8位来控制其电源状态。
- en: 'The third step is to define the connection path of these widgets:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是定义这些小部件的连接路径：
- en: '[PRE33]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Through the definition of the first step, we know that `"Left output Mux"`
    and `"right output Mux"` have three input pins, respectively, `"Boost Bypass Switch"`,
    `"LINPUT3 Switch"` (or `"RINPUT3 Switch"`), and `"PCM Playback Switch"`. `"Mono
    Output Mixer"` has only two input select pins, which are `"Left Switch"` and `"Right
    Switch"`. So, obviously, the meaning of the preceding path definition is as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通过第一步的定义，我们知道“左输出Mux”和“右输出Mux”分别有三个输入引脚，“增益旁路开关”、“LINPUT3开关”（或“RINPUT3开关”）和“PCM播放开关”。“单声道混音器”只有两个输入选择引脚，分别是“左开关”和“右开关”。因此，显然，前面路径定义的意思如下：
- en: '`"Left Boost Mixer"` is connected to `"Left Output Mixer"` via `"Boost Bypass
    Switch"`.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “左增益混音器”通过“增益旁路开关”连接到“左输出混音器”。
- en: '`"Left DAC"` is connected to `"Left Output Mixer"` via `"PCM Playback Switch"`.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “左DAC”通过“PCM播放开关”连接到“左输出混音器”。
- en: '`"RINPUT3"` is connected to `"Right Output Mixer"` via `"RINPUT3 Switch"`.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “RINPUT3”通过“RINPUT3开关”连接到“右输出混音器”。
- en: '`"Right Boost Mixer"` is connected to `"Right Output Mixer"` via `"Boost Bypass
    Switch"`.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “右增益混音器”通过“增益旁路开关”连接到“右输出混音器”。
- en: '`"Right DAC"` is connected to `"Right Output Mixer"` via `"PCM Playback Switch"`.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “右DAC”通过“PCM播放开关”连接到“右输出混音器”。
- en: '`"Left Output Mixer"` is connected to `"LOUT1 PGA"`. However, there is no switch
    control for this link.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “左输出混音器”连接到“LOUT1 PGA”。但是，这个连接没有开关控制。
- en: '`"Right Output Mixer"` is connected to `"ROUT1 PGA"`, with no switch controlling
    this connection.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “右输出混音器”连接到“ROUT1 PGA”，没有开关控制这个连接。
- en: 'Not all of the connections have been described, but the idea is there. The
    fourth step is to register these widgets and paths in the codec-driven probe callback:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的连接都已经描述，但思路已经存在。第四步是在编解码器驱动的探测回调中注册这些小部件和路径：
- en: '[PRE34]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding example, controls, widgets, and route registration are deferred
    into the component driver's probe callback. This helps make sure that these elements
    are created only when the component is probed by the machine driver. In the machine
    driver, we can define and register the board-specific widgets and path information
    in the same way.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，控件、小部件和路径的注册被推迟到组件驱动的探测回调中。这有助于确保这些元素只有在机器驱动探测到组件时才会被创建。在机器驱动中，我们可以以相同的方式定义和注册特定于板的小部件和路径信息。
- en: Codec component registration
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编解码器组件注册
- en: 'After the codec component has been set up, it has to be registered with the
    system so that it can be used for what it is designed for. For this purpose, you
    should use `devm_snd_soc_register_component()`. This function will take care of
    unregistration/cleaning automatically when needed. The following is its prototype:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 编解码器组件设置完成后，必须将其注册到系统中，以便按照其设计进行使用。为此，应使用`devm_snd_soc_register_component()`。此函数将在需要时自动处理注销/清理。其原型如下：
- en: '[PRE35]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following is an example of codec registration, which is an excerpt from
    the `wm8960` codec driver. The component driver is first defined as the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个编解码器注册的示例，摘自`wm8960`编解码器驱动程序。组件驱动程序首先定义如下：
- en: '[PRE36]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'That component driver contains `dapm` routes and widgets, as well as a set
    of controls. Then, the codec `dai` callbacks are provided through the `struct
    snd_soc_dai_ops`, as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件驱动程序包含`dapm`路由和小部件，以及一组控件。然后，通过`struct snd_soc_dai_ops`提供编解码器`dai`回调，如下所示：
- en: '[PRE37]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Those codec `dai` callbacks the assigned to the codec `dai` driver (via the
    `ops` field) for registration with the ASoC core as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这些编解码器`dai`回调通过`ops`字段分配给编解码器`dai`驱动程序，以便与ASoC核心注册，如下所示：
- en: '[PRE38]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When the machine driver probes this codec, then the probe callback of the codec
    component driver (`wm8900_probe`) will be invoked, and they will complete the
    codec driver initialization. The full version of this codec device driver is `sound/soc/codecs/wm8900.c`
    in the Linux kernel source.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当机器驱动程序探测到这个编解码器时，编解码器组件驱动程序的探测回调（`wm8900_probe`）将被调用，并且它们将完成编解码器驱动程序的初始化。这个编解码器设备驱动程序的完整版本是Linux内核源码中的`sound/soc/codecs/wm8900.c`。
- en: Now we are familiar with the codec class driver and its architecture. We have
    seen how to export codec properties as well, how to build audio routes, and how
    to implement DAPM features. On its own, the codec driver is quite useless, though
    it manages the codec device. It needs to be tied to the platform driver, which
    is the next driver class we are going to learn about.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了编解码器类驱动程序及其架构。我们已经看到了如何导出编解码器属性，如何构建音频路径，以及如何实现DAPM功能。编解码器驱动程序本身是相当无用的，尽管它管理编解码器设备。它需要与平台驱动程序绑定，这是我们接下来要学习的下一个驱动程序类。
- en: Writing the platform class driver
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写平台类驱动程序
- en: The platform driver registers the PCM driver, CPU DAI driver, and their operation
    functions, pre-allocates buffers for PCM components, and sets playback and capture
    operations as applicable. In other words, the platform driver contains the audio
    DMA engine and audio interface drivers (for example, I2S, AC97, and PCM) for that
    platform.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 平台驱动程序注册PCM驱动程序、CPU DAI驱动程序及其操作函数，为PCM组件预分配缓冲区，并根据需要设置播放和捕获操作。换句话说，平台驱动程序包含该平台的音频DMA引擎和音频接口驱动程序（例如I2S、AC97和PCM）。
- en: 'The platform driver targets the SoC the platform is made of. It concerns the
    platform''s DMA, which is how audio data transits between each block in the SoC,
    and CPU DAI, which is the path the CPU uses to send/carry audio data to/from the
    codec. Such a driver has two important data structures: `struct snd_soc_component_driver`
    and `struct snd_soc_dai_driver`. The former is responsible for DMA data management,
    and the latter is responsible for the parameter configuration of the DAI. However,
    both of these data structures have already been described while dealing with codec
    class drivers. Thus, this part will just deal with additional concepts, related
    to the platform code.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 平台驱动程序针对平台构建的SoC。它涉及平台的DMA，这是音频数据在SoC中的每个块之间传输的方式，以及CPU DAI，这是CPU用于发送/携带音频数据到/从编解码器的路径。这样的驱动程序有两个重要的数据结构：`struct
    snd_soc_component_driver`和`struct snd_soc_dai_driver`。前者负责DMA数据管理，后者负责DAI的参数配置。然而，这两个数据结构在处理编解码器类驱动程序时已经描述过。因此，本部分将只涉及与平台代码相关的其他概念。
- en: The CPU DAI driver
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU DAI驱动程序
- en: Since the platform code has been refactored too, as with the codec driver, the
    CPU DAI drivers must export an instance of the component driver as well as an
    instance of the DAI driver, respectively `struct snd_soc_component_driver` and
    `struct snd_soc_dai_driver`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 自从平台代码也进行了重构，与编解码器驱动程序一样，CPU DAI驱动程序必须导出组件驱动程序的实例，以及DAI驱动程序的实例，分别是`struct snd_soc_component_driver`和`struct
    snd_soc_dai_driver`。
- en: 'On the platform side, most of the work can be done by the core, especially
    for DMA-related stuff. Thus, it is common for CPU DAI drivers to provide only
    the name of the interface within the component driver structure and to let the
    core do the rest. The following is an example from the Rockchip SPDIF driver,
    implemented in `sound/soc/rockchip/rockchip_spdif.c`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在平台方面，大部分工作可以由核心完成，特别是与DMA相关的工作。因此，CPU DAI驱动程序通常只需在组件驱动程序结构中提供接口的名称，剩下的工作就交给核心处理。以下是Rockchip
    SPDIF驱动程序的示例，实现在`sound/soc/rockchip/rockchip_spdif.c`中：
- en: '[PRE39]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding excerpt, `spdif` is the driver state data structure. We can
    see that only the name is filled in in the component driver, and both the component
    and DAI drivers are registered as usual by means of `devm_snd_soc_register_component()`.
    The `struct snd_soc_dai_driver` must be set up according to the actual DAI properties,
    and the `dai_ops` should be set if necessary. However, a big part of the setup
    is done by `devm_snd_dmaengine_pcm_register()`, which will set the component driver's
    PCM ops according to the `dma_data` provided. This is explained in detail in the
    next section.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述摘录中，`spdif`是驱动程序状态数据结构。我们可以看到组件驱动程序中只填写了名称，并且通过`devm_snd_soc_register_component()`通常注册了组件和DAI驱动程序。`struct
    snd_soc_dai_driver`必须根据实际的DAI属性进行设置，如果需要，应设置`dai_ops`。然而，`devm_snd_dmaengine_pcm_register()`将完成设置的大部分工作，根据提供的`dma_data`设置组件驱动程序的PCM操作。这将在下一节详细解释。
- en: The platform DMA driver AKA PCM DMA driver
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台DMA驱动程序，又称PCM DMA驱动程序
- en: 'In a sound ecosystem, we have several types of devices: PCM, MIDI, mixer, sequencer,
    timer, and so on. Here, PCM does refer to Pulse Code Modulation, but it is a reference
    to a device that processes sample-based digital audio, that is, not midi and so
    on. The PCM layer (part of the ALSA core) is responsible for doing all the digital
    audio work, such as preparing the card for capture or playback, initiating the
    transfer to and from the device, and so on. In short, if you want to play back
    or capture sound, you''re going to need a PCM.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在声音生态系统中，我们有几种类型的设备：PCM、MIDI、混音器、序列器、定时器等。这里，PCM确实指的是脉冲编码调制，但它是指处理基于样本的数字音频的设备，即不是MIDI等。PCM层（ALSA核心的一部分）负责进行所有数字音频工作，例如准备卡片进行捕获或播放，启动到设备的传输等。简而言之，如果您想要播放或捕获声音，您将需要一个PCM。
- en: The PCM driver helps perform DMA operations by overriding the function pointers
    exposed by the `struct snd_pcm_ops` structure. It is platform agnostic and interacts
    only with the SOC DMA engine upstream APIs. The DMA engine then interacts with
    the platform-specific DMA driver to get the correct DMA settings. The `struct
    snd_pcm_ops` is a structure that contains a set of callbacks that relate to different
    events regarding the PCM interface.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: PCM驱动程序通过覆盖`struct snd_pcm_ops`结构公开的函数指针来执行DMA操作。它与平台无关，仅与SOC DMA引擎上游API交互。DMA引擎然后与特定于平台的DMA驱动程序交互，以获取正确的DMA设置。`struct
    snd_pcm_ops`是一个包含一组回调的结构，这些回调与PCM接口的不同事件相关。
- en: 'While dealing with ASoC (not purely ALSA), you''ll never need to instantiate
    this structure as is, as long as you use the generic PCM DMA engine framework.
    The ASoC core does this for you. Have a look at the following call stack: *snd_soc_register_card
    -> snd_soc_instantiate_card -> soc_probe_link_dais -> soc_new_pcm*.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理ASoC（而不是纯粹的ALSA）时，只要使用通用PCM DMA引擎框架，就不需要实例化这个结构。ASoC核心会为您完成这些工作。看一下以下调用堆栈：*snd_soc_register_card
    -> snd_soc_instantiate_card -> soc_probe_link_dais -> soc_new_pcm*。
- en: The audio DMA interface
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音频DMA接口
- en: Each audio bus driver of the SoC is responsible for providing a DMA interface
    by means of this API. This is the case, for example, for the audio buses on i.MX-based
    SoCs, such as ESAI, SAI, SPDIF and SSI whose drivers are located in `sound/soc/fsl/`,
    respectively `sound/soc/fsl/fsl_esai.c`,`sound/soc/fsl/fsl_sai.c`, `sound/soc/fsl/fsl_spdif.c`,
    and `sound/soc/fsl/fsl_ssi.c`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: SoC的每个音频总线驱动程序负责通过此API提供DMA接口。例如，对于基于i.MX的SoC上的音频总线，如ESAI、SAI、SPDIF和SSI，其驱动程序分别位于`sound/soc/fsl/`，`sound/soc/fsl/fsl_esai.c`，`sound/soc/fsl/fsl_sai.c`，`sound/soc/fsl/fsl_spdif.c`和`sound/soc/fsl/fsl_ssi.c`。
- en: 'The audio DMA driver is registered via `devm_snd_dmaengine_pcm_register()`.
    This function registers a `struct snd_dmaengine_pcm_config` for the device. The
    following is its prototype:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 音频DMA驱动程序通过`devm_snd_dmaengine_pcm_register()`进行注册。此函数为设备注册了一个`struct snd_dmaengine_pcm_config`。其原型如下：
- en: '[PRE40]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding prototype, `dev` is the parent device for the PCM device, usually
    `&pdev->dev`. `config` is the platform-specific PCM configuration, which is of
    type `struct snd_dmaengine_pcm_config`. This structure needs to be described in
    detail. `flags` represents additional flags describing how to deal with DMA channels.
    Most of the time, it is `0`. However, possible values are defined in `include/sound/dmaengine_pcm.h`
    and are all prefixed with `SND_DMAENGINE_PCM_FLAG_`. Frequently used ones are
    `SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX`, `SND_DMAENGINE_PCM_FLAG_NO_DT`, and `SND_DMAENGINE_PCM_FLAG_COMPAT`.
    The former indicates that the PCM is half-duplex and the DMA channel is shared
    between capture and playback. The second one asks the core not to try to request
    the DMA channels through the device tree. The last one means a custom callback
    will be used to request the DMA channel. Upon registration, the generic PCM DMA
    engine framework will build a suitable `snd_pcm_ops` and set the component driver's
    `.ops` field with it.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述原型中，`dev`是PCM设备的父设备，通常为`&pdev->dev`。`config`是特定于平台的PCM配置，类型为`struct snd_dmaengine_pcm_config`。这个结构需要详细描述。`flags`表示描述如何处理DMA通道的附加标志。大多数情况下为`0`。但是，可能的值在`include/sound/dmaengine_pcm.h`中定义，并且都以`SND_DMAENGINE_PCM_FLAG_`为前缀。经常使用的是`SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX`，`SND_DMAENGINE_PCM_FLAG_NO_DT`和`SND_DMAENGINE_PCM_FLAG_COMPAT`。前者表示PCM是半双工，DMA通道在捕获和播放之间共享。第二个要求核心不要尝试通过设备树请求DMA通道。最后一个意味着将使用自定义回调来请求DMA通道。注册后，通用PCM
    DMA引擎框架将构建一个合适的`snd_pcm_ops`并将组件驱动程序的`.ops`字段设置为它。
- en: 'The classic DMA operation flow in Linux is as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中经典的DMA操作流程如下：
- en: '`dma_request_channel`: For allocating the slave channel.'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dma_request_channel`：用于分配从通道。'
- en: '`dmaengine_slave_config`: To set slave- and controller-specific parameters.'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dmaengine_slave_config`：用于设置从和控制器特定的参数。'
- en: '`dma_prep_xxxx`: To get a descriptor for the transaction.'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dma_prep_xxxx`：获取事务的描述符。'
- en: '`dma_cookie = dmaengine_submit(tx)`: Submit the transaction and grab the DMA
    cookie.'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dma_cookie = dmaengine_submit(tx)`: 提交事务并获取DMA cookie。'
- en: '`dma_async_issue_pending(chan)`: To start transmission and wait for a callback
    notification.'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dma_async_issue_pending(chan)`: 启动传输并等待回调通知。'
- en: In ASoC, the device tree is used to map the DMA channels to the PCM device.
    `devm_snd_dmaengine_pcm_register()` requests the DMA channel through `dmaengine_pcm_request_chan_of()`,
    which is a device-tree-based interface. In order to perform *steps 1* to *3*,
    the PCM DMA engine core needs to be provided additional information. This can
    be done either by populating a `struct snd_dmaengine_pcm_config`, which will be
    given to the registration function or by letting the PCM DMA engine framework
    retrieve information from the system's DMA engine core. *Steps 4* and *5* are
    transparently handled by the PCM DMA engine core.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASoC中，设备树用于将DMA通道映射到PCM设备。`devm_snd_dmaengine_pcm_register()`通过`dmaengine_pcm_request_chan_of()`请求DMA通道，这是一个基于设备树的接口。为了执行*步骤1*到*步骤3*，PCM
    DMA引擎核心需要提供额外的信息。这可以通过填充`struct snd_dmaengine_pcm_config`来完成，该结构将被提供给注册函数，或者让PCM
    DMA引擎框架从系统的DMA引擎核心中检索信息。*步骤4*和*步骤5*由PCM DMA引擎核心透明处理。
- en: 'The following is what the `struct snd_dma_engine_pcm_config` looks like:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`struct snd_dma_engine_pcm_config`的外观：
- en: '[PRE41]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding data structure mainly deals with DMA channel management, buffer
    management, and channel configuration:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的数据结构主要处理DMA通道管理、缓冲区管理和通道配置：
- en: '`prepare_slave_config`: This callback is used to fill in the DMA `slave_config`
    (of type `struct dma_slave_config`, which is the DMA slave channel runtime config)
    for a PCM sub-stream. It will be called from the PCM driver''s `hwparams` callback.
    Here, you can use `snd_dmaengine_pcm_prepare_slave_config`, which is a generic
    `prepare_slave_config` callback for platforms that make use of the `snd_dmaengine_dai_dma_data`
    struct for their DAI DMA data. This generic callback will internally call `snd_hwparams_to_dma_slave_config`
    to fill in the slave config based on `hw_params`, followed by `snd_dmaengine_set_config_from_dai_data`
    to fill in the remaining fields based on the DAI DMA data.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prepare_slave_config`：此回调用于填充PCM子流的DMA `slave_config`（类型为`struct dma_slave_config`，是DMA从通道运行时配置）。它将从PCM驱动程序的`hwparams`回调中调用。在这里，您可以使用`snd_dmaengine_pcm_prepare_slave_config`，这是一个通用的`prepare_slave_config`回调，用于使用`snd_dmaengine_dai_dma_data`结构的平台。此通用回调将内部调用`snd_hwparams_to_dma_slave_config`，根据`hw_params`填充从配置，然后调用`snd_dmaengine_set_config_from_dai_data`，根据DAI
    DMA数据填充剩余字段。'
- en: When using the generic callback approach, you should call `snd_soc_dai_init_dma_data()`
    (given the DAI-specific capture and playback DMA data config, which are of type
    `struct snd_dmaengine_dai_dma_data`) from within your CPU DAI driver's `.probe`
    callback, which will set both the `cpu_dai->playback_dma_data` and `cpu_dai->capture_dma_data`
    fields. The `snd_soc_dai_init_dma_data()` method simply sets the DMA settings
    (for either capture, playback, or both) for the DAI given as a parameter.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用通用回调方法时，应该在CPU DAI驱动程序的`.probe`回调中调用`snd_soc_dai_init_dma_data()`（给定特定于DAI的捕获和播放DMA数据配置，类型为`struct
    snd_dmaengine_dai_dma_data`），这将设置`cpu_dai->playback_dma_data`和`cpu_dai->capture_dma_data`字段。`snd_soc_dai_init_dma_data()`方法只是为给定的DAI设置DMA设置（捕获、播放或两者）。
- en: '`compat_request_channel`: This is used to request DMA channels for platforms
    that do not use the device tree. If set, `.compat_filter_fn` will be ignored.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compat_request_channel`：这用于请求不使用设备树的平台的DMA通道。如果设置，将忽略`.compat_filter_fn`。'
- en: '`compat_filter_fn`: It is used as the filter function when requesting a DMA
    channel for platforms that do not use the device tree. The filter parameter will
    be the DAI''s DMA data.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compat_filter_fn`：这用作在请求DMA通道时的过滤函数，用于不使用设备树的平台。过滤参数将是DAI的DMA数据。'
- en: '`dma_dev`: This allows requesting DMA channels for a device other than the
    device that is registering the PCM driver. If set, DMA channels will be requested
    on this device rather than the DAI device.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dma_dev`：这允许为除注册PCM驱动程序的设备之外的设备请求DMA通道。如果设置，DMA通道将在此设备上请求，而不是在DAI设备上。'
- en: '`chan_names`: This is the array of names to use when requesting capture/playback
    DMA channels. This is useful when the default `"tx"` and `"rx"` channel names
    don''t apply, for example, if an HW module supports multiple channels, each having
    different DMA channel names.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chan_names`：这是在请求捕获/播放DMA通道时使用的名称数组。当默认的`"tx"`和`"rx"`通道名称不适用时，这是有用的，例如，如果硬件模块支持多个通道，每个通道具有不同的DMA通道名称。'
- en: '`pcm_hardware`: This describes the PCM hardware capabilities. If not set, rely
    on the core to fill in the right flags derived from the DMA engine information.
    This field is of type `struct snd_pcm_hardware` and will be described in the next
    section.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pcm_hardware`：这描述了PCM硬件的能力。如果未设置，依赖核心填写从DMA引擎信息派生的正确标志。该字段是`struct snd_pcm_hardware`类型，并将在下一节中描述。'
- en: '`prealloc_buffer_size`: This is the size of the preallocated audio buffer.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prealloc_buffer_size`：这是预分配音频缓冲区的大小。'
- en: The PCM DMA config may not be supplied to the registration API (it might be
    `NULL`), and the registration would be `ret = devm_snd_dmaengine_pcm_register(&pdev->dev,
    NULL, 0)`. In this case, you should provide capture and playback DAI DMA channel
    configs via `snd_soc_dai_init_dma_data()`, as described earlier. By using this
    method, other elements will be derived from the system core. For example, to request
    a DMA channel, the PCM DMA engine core will rely on the device tree, assuming
    that the capture and playback DMA channel names are respectively `"rx"` and `"tx"`,
    unless the flag `SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX` is set in `flags`, in which
    case it will consider capture and playback as using the same DMA channel, named
    `rx-tx` in the device tree node.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: PCM DMA配置可能不会提供给注册API（可能为`NULL`），注册将是`ret = devm_snd_dmaengine_pcm_register(&pdev->dev,
    NULL, 0)`。在这种情况下，应该通过`snd_soc_dai_init_dma_data()`提供捕获和播放DAI DMA通道配置，如前所述。通过使用这种方法，其他元素将从系统核心派生。例如，要请求DMA通道，PCM
    DMA引擎核心将依赖设备树，假设捕获和播放DMA通道名称分别为`"rx"`和`"tx"`，除非在`flags`中设置了`SND_DMAENGINE_PCM_FLAG_HALF_DUPLEX`标志，否则它将考虑捕获和播放使用相同的DMA通道，设备树节点中命名为`rx-tx`。
- en: 'DMA channel settings will be derived from the system DMA engine too. The following
    is what `snd_soc_dai_init_dma_data()` looks like:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: DMA通道设置也将从系统DMA引擎派生。以下是`snd_soc_dai_init_dma_data()`的样子：
- en: '[PRE42]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Though `snd_soc_dai_init_dma_data()` accepts both capture and playback as `void`
    types, the values passed should actually be of type `struct snd_dmaengine_dai_dma_data`,
    defined in `include/sound/dmaengine_pcm.h` as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`snd_soc_dai_init_dma_data()`接受捕获和播放作为`void`类型，但实际传递的值应该是`struct snd_dmaengine_dai_dma_data`类型，在`include/sound/dmaengine_pcm.h`中定义如下：
- en: '[PRE43]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This structure represents DMA channel data (or config or whatever you prefer)
    for a DAI channel. You should refer to the header where it is defined for the
    meaning of its fields. Additionally, you can have a look at other drivers for
    more details on how to set up this data structure.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构表示DAI通道的DMA通道数据（或配置或您喜欢的任何其他内容）。您应该参考定义它的头文件以了解其字段的含义。此外，您可以查看其他驱动程序，以获取有关如何设置此数据结构的更多详细信息。
- en: PCM hardware conﬁguration
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PCM硬件配置
- en: 'When the DMA settings are not automatically fed from the system by the PCM
    DMA engine core, the platform PCM driver may need to provide PCM hardware settings,
    which describe how hardware lays out the PCM data. Those settings are provided
    through the `snd_dmaengine_pcm_config.pcm_hardware` field, which is of type `struct
    snd_pcm_hardware`, defined as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 当DMA设置不是由PCM DMA引擎核心自动从系统中提供时，平台PCM驱动程序可能需要提供PCM硬件设置，描述硬件如何布置PCM数据。这些设置通过`snd_dmaengine_pcm_config.pcm_hardware`字段提供，它是`struct
    snd_pcm_hardware`类型，定义如下：
- en: '[PRE44]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This structure describes the hardware limitations of the platform itself (or
    should I say, it sets the allowed parameters), such as the number of channels/sampling
    rate/data format that can be supported, the range of period size supported by
    DMA, the range of period counts, and so on. In the preceding data structure, range
    values, period min, and period max depend on the capabilities of the DMA controller,
    the DAI hardware, and the codec. The following are the detailed meanings of each
    field:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构描述了平台本身的硬件限制（或者我应该说，它设置了允许的参数），例如支持的通道数/采样率/数据格式，DMA支持的周期大小范围，周期计数范围等。在前面的数据结构中，范围值、周期最小值和周期最大值取决于DMA控制器、DAI硬件和编解码器的能力。以下是每个字段的详细含义：
- en: '`info` contains the type and capabilities of this PCM. The possible values
    are bit flags that are all defined in `include/uapi/sound/asound.h` (this means
    user code should include `<sound/asound.h>`) as `SNDRV_PCM_INFO_XXX`. For example,
    `SNDRV_PCM_INFO_MMAP` would mean the hardware supports the `mmap()` system call.
    Here, at least, you have to specify whether the `mmap` system call is supported
    and which interleaved format is supported. When the `mmap()` system call is supported,
    add the `SNDRV_PCM_INFO_MMAP` flag here. When the hardware supports the interleaved
    or the non-interleaved formats, the `SNDRV_PCM_INFO_INTERLEAVED` or `SNDRV_PCM_INFO_NONINTERLEAVED`
    flag must be set, respectively. If both are supported, you can set both, too.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info` 包含了此 PCM 的类型和功能。可能的值是位标志，都在 `include/uapi/sound/asound.h` 中定义（这意味着用户代码应该包含
    `<sound/asound.h>`），如 `SNDRV_PCM_INFO_XXX`。例如，`SNDRV_PCM_INFO_MMAP` 表示硬件支持 `mmap()`
    系统调用。在这里，至少必须指定是否支持 `mmap` 系统调用以及支持哪种交错格式。当支持 `mmap()` 系统调用时，在这里添加 `SNDRV_PCM_INFO_MMAP`
    标志。当硬件支持交错或非交错格式时，必须分别设置 `SNDRV_PCM_INFO_INTERLEAVED` 或 `SNDRV_PCM_INFO_NONINTERLEAVED`
    标志。如果两者都支持，也可以同时设置。'
- en: The `formats` field contains the bit flags of supported formats (`SNDRV_PCM_FMTBIT_XXX`).
    If the hardware supports more than one format, you should use all OR'ed bits.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`formats` 字段包含了支持格式的位标志（`SNDRV_PCM_FMTBIT_XXX`）。如果硬件支持多种格式，应该使用所有 OR 运算的位。'
- en: The `rates` field contains the bit flags of supported rates (`SNDRV_PCM_RATE_XXX`).
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rates` 字段包含了支持速率的位标志（`SNDRV_PCM_RATE_XXX`）。'
- en: '`rate_min` and `rate_max` define the minimum and maximum sample rate. This
    should correspond somehow to rate bits.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rate_min` 和 `rate_max` 定义了最小和最大采样率。这应该与速率位相对应。'
- en: '`channel_min` and `channel_max` define, as you might have already guessed,
    the minimum and the maximum number of channels.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel_min` 和 `channel_max` 定义了通道的最小和最大数量。'
- en: '`buffer_bytes_max` defines the maximum buffer size in bytes. There is no `buffer_bytes_min`
    field since it can be calculated from the minimum period size and the minimum
    number of periods. Meanwhile, `period_bytes_min` and `period_bytes_max` define
    the minimum and maximum size of the period in bytes.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buffer_bytes_max` 定义了缓冲区的最大大小（以字节为单位）。由于可以从最小周期大小和最小周期数计算出来，因此没有 `buffer_bytes_min`
    字段。同时，`period_bytes_min` 和 `period_bytes_max` 定义了周期的最小和最大大小（以字节为单位）。'
- en: '`periods_max` and `periods_min` define the maximum and the minimum number of
    periods in the buffer.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`periods_max` 和 `periods_min` 定义了缓冲区中的最大和最小周期数。'
- en: 'The other fields need the concept of a period to be introduced. The period
    defines the size at which a PCM interrupt is generated. The concept of a period
    is very important. A period basically describes an interrupt. It sums up the "chunk"
    size that the hardware supplies data in:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 其他字段需要引入周期的概念。周期定义了生成 PCM 中断的大小。周期的概念非常重要。周期基本上描述了一个中断。它总结了硬件以“块”大小提供数据的方式：
- en: '`period_bytes_min` is the minimum transfer size of the DMA written to as the
    number of bytes processed between interrupts. For example, if the DMA can transmit
    a minimum of 2,048 bytes, it should be written as `2048`.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`period_bytes_min` 是 DMA 写入的最小传输大小，表示中断之间处理的字节数。例如，如果 DMA 可以传输最少 2,048 字节，应该写成
    `2048`。'
- en: '`period_bytes_max` is the maximum transfer size of the DMA aka the maximum
    number of bytes processed between interrupts. For example, if the DMA can transmit
    a maximum of 4,096 bytes, it should be written as `4096`.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`period_bytes_max` 是 DMA 的最大传输大小，也就是中断之间处理的最大字节数。例如，如果 DMA 可以传输最多 4,096 字节，应该写成
    `4096`。'
- en: 'The following is an example of such PCM constraints from the STM32 I2S DMA
    driver, defined in `sound/soc/stm/stm32_i2s.c`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 STM32 I2S DMA 驱动程序中的 PCM 约束的示例，定义在 `sound/soc/stm/stm32_i2s.c` 中：
- en: '[PRE45]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Once set up, this structure should end up in the `snd_dmaengine_pcm_config.pcm_hardware`
    field prior to the `struct snd_dmaengine_pcm_config` object given to `devm_snd_dmaengine_pcm_register()`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，此结构应该最终出现在 `snd_dmaengine_pcm_config.pcm_hardware` 字段中，然后传递给 `devm_snd_dmaengine_pcm_register()`
    的 `struct snd_dmaengine_pcm_config` 对象。
- en: 'The following is a playback flow, showing the involved components and PCM data
    flow:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个播放流程，显示了涉及的组件和 PCM 数据流：
- en: '![Figure 5.4 – ASoC audio playback flow'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 – ASoC 音频播放流程'
- en: '](img/Figure_5.4_B10985.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.4_B10985.jpg)'
- en: Figure 5.4 – ASoC audio playback flow
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – ASoC 音频播放流程
- en: The preceding figure shows the audio playback flow and blocks involved in each
    step. We can see audio data is copied from the user to DMA buffers, followed by
    DMA transactions to move the data into the platform audio Tx FIFO, which, thanks
    to its link with the codec (via their respective DAIs), sends this data to the
    codec in charge of playing the audio through the speaker. The capture operation
    is the opposite flow with the speaker replaced by a microphone.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了音频播放流程和每个步骤涉及的块。我们可以看到音频数据从用户复制到 DMA 缓冲区，然后通过 DMA 事务将数据移动到平台音频 Tx FIFO，由于其与编解码器（通过各自的
    DAI）的链接，将这些数据发送到负责通过扬声器播放音频的编解码器。捕获操作是扬声器被麦克风替换的相反流程。
- en: This brings us to the end of dealing with the platform class driver. We have
    seen the data structures and concepts it shares with the codec class driver. Note
    that both codec and platform drivers need to be linked together in order to build
    the real audio path from a system point of view. According to the ASoC architecture,
    this has to be done in another class driver, the so-called machine driver, which
    is the topic of the next chapter.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了处理平台类驱动程序的部分。我们已经看到了它与编解码器类驱动程序共享的数据结构和概念。请注意，编解码器和平台驱动程序都需要链接在一起，以便从系统的角度构建真正的音频路径。根据
    ASoC 架构，这必须在另一个类驱动程序中完成，即所谓的机器驱动程序，这是下一章的主题。
- en: Summary
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we analyzed the ASoC architecture. On this basis, we dealt
    with both the codec driver and the platform driver. By learning about these topics,
    we went through several concepts, such as controls and widgets. We have seen how
    the ASoC framework differs from the classic PC ALSA system, mostly by targeting
    code reusability and implementing power management.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了ASoC架构。在此基础上，我们处理了编解码器驱动程序和平台驱动程序。通过学习这些主题，我们经历了几个概念，比如控件和小部件。我们已经看到ASoC框架如何与经典的PC
    ALSA系统不同，主要是通过针对代码可重用性和实现电源管理。
- en: Last but not least, we have seen that platform and codec drivers do not work
    standalone. They need to be bound together by the machine driver, which is responsible
    for registering the final audio device, and this is the main topic in the next
    chapter.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，我们已经看到平台和编解码器驱动程序不能独立工作。它们需要由机器驱动程序绑定在一起，负责注册最终的音频设备，这是下一章的主要主题。
