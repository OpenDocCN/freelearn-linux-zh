["```\nstruct clk_hw {\n\u00a0\u00a0\u00a0\u00a0struct clk_core *core;\n\u00a0\u00a0\u00a0\u00a0struct clk *clk;\n\u00a0\u00a0\u00a0\u00a0const struct clk_init_data *init;\n};\n```", "```\nstruct clk_init_data {\n\u00a0\u00a0\u00a0\u00a0const char *name;\n\u00a0\u00a0\u00a0\u00a0const struct clk_ops *ops;\n\u00a0\u00a0\u00a0\u00a0const char * const *parent_names;\n\u00a0\u00a0\u00a0\u00a0u8 num_parents;\n\u00a0\u00a0\u00a0\u00a0unsigned long flags;\n};\n```", "```\nstruct clk *clk_register(struct device *dev, struct clk_hw *hw)\nint clk_hw_register(struct device *dev, struct clk_hw *hw)\n```", "```\nint clk_hw_register(struct device *dev, struct clk_hw *hw)\n{\n\u00a0\u00a0\u00a0\u00a0return PTR_ERR_OR_ZERO(clk_register(dev, hw));\n}\n```", "```\nstatic HLIST_HEAD(clk_root_list);\nstatic HLIST_HEAD(clk_orphan_list);\n```", "```\nstatic LIST_HEAD(clocks);\nstatic DEFINE_MUTEX(clocks_mutex);\n```", "```\n/* Not be used anymore, introduced here for studying purpose */\nint clk_register_clkdev(struct clk *clk,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *con_id, const char *dev_id)\n```", "```\n/* recommended interface */\nint clk_hw_register_clkdev(struct clk_hw *hw,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *con_id, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *dev_id)\n```", "```\nstruct clk_lookup {\n\u00a0\u00a0\u00a0\u00a0struct list_head node;\n\u00a0\u00a0\u00a0\u00a0const char *dev_id;\n\u00a0\u00a0\u00a0\u00a0const char *con_id;\n\u00a0\u00a0\u00a0\u00a0struct clk *clk;\n\u00a0\u00a0\u00a0\u00a0struct clk_hw *clk_hw;\n};\n```", "```\nstatic void __clkdev_add(struct clk_lookup *cl)\n{\n\u00a0\u00a0\u00a0\u00a0mutex_lock(&clocks_mutex);\n\u00a0\u00a0\u00a0\u00a0list_add_tail(&cl->node, &clocks);\n\u00a0\u00a0\u00a0\u00a0mutex_unlock(&clocks_mutex);\n}\n```", "```\nstruct of_clk_provider {\n\u00a0\u00a0\u00a0\u00a0struct list_head link;\n\u00a0\u00a0\u00a0\u00a0struct device_node *node;\n\u00a0\u00a0\u00a0\u00a0struct clk *(*get)(struct of_phandle_args *clkspec, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void *data);\n\u00a0\u00a0\u00a0\u00a0struct clk_hw *(*get_hw)(struct of_phandle_args *clkspec,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void *data);\n\u00a0\u00a0\u00a0\u00a0void *data;\n};\n```", "```\nstatic LIST_HEAD(of_clk_providers);\nstatic DEFINE_MUTEX(of_clk_mutex);\n```", "```\nvoid clk_hw_unregister(struct clk_hw *hw)\nvoid clk_unregister(struct clk *clk)\n```", "```\nvoid devm_clk_unregister(struct device *dev, struct clk *clk)\nvoid devm_clk_hw_unregister(struct device *dev, struct clk_hw *hw)\n```", "```\nint of_clk_add_hw_provider(\n\u00a0\u00a0\u00a0\u00a0struct device_node *np,\n\u00a0\u00a0\u00a0\u00a0struct clk_hw *(*get)(struct of_phandle_args *clkspec,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void *data),\n\u00a0\u00a0\u00a0\u00a0void *data)\n```", "```\nvoid of_clk_del_provider(struct device_node *np)\n```", "```\nclocks {\n\u00a0\u00a0\u00a0\u00a0/* Provider node */\n\u00a0\u00a0\u00a0\u00a0clk54: clk54 {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#clock-cells = <0>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compatible = 'fixed-clock';\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clock-frequency = <54000000>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clock-output-names = 'osc';\n\u00a0\u00a0\u00a0\u00a0};\n};\n[...]\ni2c0: i2c-master@d090000 {\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0/* Consumer node */\n\u00a0\u00a0\u00a0\u00a0cdce706: clock-synth@69 {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compatible = 'ti,cdce706';\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#clock-cells = <1>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reg = <0x69>; \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clocks = <&clk54>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clock-names = 'clk_in0';\n\u00a0\u00a0\u00a0\u00a0};\n};\n```", "```\nosc {\n\u00a0\u00a0\u00a0\u00a0#clock-cells = <1>;\n\u00a0\u00a0\u00a0\u00a0clock-output-names = 'ckout1', 'ckout2';\n};\n```", "```\ndevice {\n\u00a0\u00a0\u00a0\u00a0clocks = <&osc 0>, <&osc 1>;\n\u00a0\u00a0\u00a0\u00a0clock-names = 'baud', 'register';\n};\n```", "```\nstatic struct clk * of_clk_get(struct device_node *np, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int index,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *dev_id, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *con_id)\n{\n\u00a0\u00a0\u00a0\u00a0struct of_phandle_args clkspec;\n\u00a0\u00a0\u00a0\u00a0struct clk *clk;\n\u00a0\u00a0\u00a0\u00a0int rc;\n\u00a0\u00a0\u00a0\u00a0rc = of_parse_phandle_with_args(np, 'clocks',\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0'#clock-cells',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0index, &clkspec);\n\u00a0\u00a0\u00a0\u00a0if (rc)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return ERR_PTR(rc);\n\u00a0\u00a0\u00a0\u00a0clk = of_clk_get_from_provider(&clkspec, dev_id, con_id); \n\u00a0\u00a0\u00a0\u00a0of_node_put(clkspec.np);\n\u00a0\u00a0\u00a0\u00a0return clk;\n}\n```", "```\nint of_parse_phandle_with_args(const struct device_node *np,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *list_name,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *cells_name,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int index,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct of_phandle_args *out_args)\n```", "```\n    #define MAX_PHANDLE_ARGS 16\n    struct of_phandle_args {\n    \u00a0\u00a0\u00a0\u00a0struct device_node *np;\n    \u00a0\u00a0\u00a0\u00a0int args_count;\n    \u00a0\u00a0\u00a0\u00a0uint32_t args[MAX_PHANDLE_ARGS];\n    };\n    ```", "```\nphandle1: node1 {\n\u00a0\u00a0\u00a0\u00a0#gpio-cells = <2>;\n};\nphandle2: node2 {\n\u00a0\u00a0\u00a0\u00a0#list-cells = <1>;\n};\nnode3 {\n\u00a0\u00a0\u00a0\u00a0list = <&phandle1 1 2 &phandle2 3>;\n};\n/* or */\nnode3 {\n\u00a0\u00a0\u00a0\u00a0list = <&phandle1 1 2>, <&phandle2 3>;\n}\n```", "```\nstruct clk_hw *(*get_hw)(struct of_phandle_args *clkspec, void *data)\n```", "```\nstruct clk * of_clk_get_from_provider(struct \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0of_phandle_args *clkspec,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *dev_id, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *con_id)\n{\n\u00a0\u00a0\u00a0\u00a0struct of_clk_provider *provider;\n\u00a0\u00a0\u00a0\u00a0struct clk *clk = ERR_PTR(-EPROBE_DEFER);\n\u00a0\u00a0\u00a0\u00a0struct clk_hw *hw;\n\u00a0\u00a0\u00a0\u00a0if (!clkspec)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return ERR_PTR(-EINVAL);\n\u00a0\u00a0\u00a0\u00a0/* Check if we have such a provider in our array */\n\u00a0\u00a0\u00a0\u00a0mutex_lock(&of_clk_mutex);\n\u00a0\u00a0\u00a0\u00a0list_for_each_entry(provider, &of_clk_providers, link) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (provider->node == clkspec->np) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0hw = of_clk_get_hw_from_provider (provider, clkspec);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clk = clk_create_clk(hw, dev_id, con_id);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (!IS_ERR(clk)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (! clk_get(clk)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clk_free_clk(clk);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clk = ERR_PTR(-ENOENT);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0mutex_unlock(&of_clk_mutex);\n\u00a0\u00a0\u00a0\u00a0return clk;\n}\n```", "```\nstruct clk_hw *of_clk_hw_simple_get(struct \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0of_phandle_args *clkspec,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void *data);\nstruct clk_hw *of_clk_hw_onecell_get(struct \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0of_phandle_args *clkspec,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void *data);\n```", "```\nstruct clk_hw *of_clk_hw_simple_get(struct \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0of_phandle_args *clkspec,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void *data)\n{\n\u00a0\u00a0\u00a0\u00a0return data;\n}\nEXPORT_SYMBOL_GPL(of_clk_hw_simple_get);\n```", "```\nstruct clk_hw_onecell_data {\n\u00a0\u00a0\u00a0\u00a0unsigned int num;\n\u00a0\u00a0\u00a0\u00a0struct clk_hw *hws[];\n};\n```", "```\nstruct sun9i_mmc_clk_data {\n\u00a0\u00a0\u00a0\u00a0spinlock_t\tlock;\n\u00a0\u00a0\u00a0\u00a0void\u00a0\u00a0iomem\t\t*membase;\n\u00a0\u00a0\u00a0\u00a0struct clk\t*clk;\n\u00a0\u00a0\u00a0\u00a0struct reset_control\t*reset;\n\u00a0\u00a0\u00a0\u00a0struct clk_hw_onecell_data\tclk_hw_data;\n\u00a0\u00a0\u00a0\u00a0struct reset_controller_dev\t\trcdev;\n};\n```", "```\nint sun9i_a80_mmc_config_clk_probe(struct \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0platform_device *pdev){\u00a0\u00a0\u00a0\u00a0struct device_node *np = pdev->dev.of_node;\n\u00a0\u00a0\u00a0\u00a0struct sun9i_mmc_clk_data *data;\n\u00a0\u00a0\u00a0\u00a0struct clk_hw_onecell_data *clk_hw_data;\n\u00a0\u00a0\u00a0\u00a0const char *clk_name = np->name;\n\u00a0\u00a0\u00a0\u00a0const char *clk_parent;\n\u00a0\u00a0\u00a0\u00a0struct resource *r;\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0data = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\u00a0\u00a0\u00a0\u00a0if (!data)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -ENOMEM;\n\u00a0\u00a0\u00a0\u00a0clk_hw_data = &data->clk_hw_data;\n\u00a0\u00a0\u00a0\u00a0clk_hw_data->num = count;\n\u00a0\u00a0\u00a0\u00a0/* Allocating space for clk_hws, and 'count' is the number\n\u00a0\u00a0\u00a0\u00a0\u00a0*of entries\n\u00a0\u00a0\u00a0\u00a0\u00a0*/\n\u00a0\u00a0\u00a0\u00a0clk_hw_data->hws =\n\u00a0\u00a0\u00a0\u00a0devm_kcalloc(&pdev->dev, count, sizeof(struct clk_hw *),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0GFP_KERNEL);\n\u00a0\u00a0\u00a0\u00a0if (!clk_hw_data->hws)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -ENOMEM;\n\u00a0\u00a0\u00a0\u00a0/* A clock provider may be a consumer from another\n\u00a0\u00a0\u00a0\u00a0\u00a0* provider as well \u00a0\u00a0\u00a0\u00a0\u00a0*/\n\u00a0\u00a0\u00a0\u00a0data->clk = devm_clk_get(&pdev->dev, NULL);\n\u00a0\u00a0\u00a0\u00a0clk_parent = __clk_get_name(data->clk);\n\u00a0\u00a0\u00a0\u00a0for (i = 0; i < count; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0of_property_read_string_index(np, 'clock-output-names',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i, &clk_name);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* storing each clock in its location */\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clk_hw_data->hws[i] =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clk_hw_register_gate(&pdev->dev, clk_name, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clk_parent, 0,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0data->membase + SUN9I_MMC_WIDTH * i,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0SUN9I_MMC_GATE_BIT, 0, &data->lock);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (IS_ERR(clk_hw_data->hws[i])) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = PTR_ERR(clk_hw_data->hws[i]);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0goto err_clk_register;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0ret =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0of_clk_add_hw_provider(np, of_clk_hw_onecell_get, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clk_hw_data);\n\u00a0\u00a0\u00a0\u00a0if (ret)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0goto err_clk_provider;\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0return 0;}\n```", "```\nstruct clk_hw * of_clk_hw_onecell_get(struct \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0of_phandle_args *clkspec, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void *data)\n{\n\u00a0\u00a0\u00a0\u00a0struct clk_hw_onecell_data *hw_data = data;\n\u00a0\u00a0\u00a0\u00a0unsigned int idx = clkspec->args[0];\n\u00a0\u00a0\u00a0\u00a0if (idx >= hw_data->num) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pr_err('%s: invalid index %u\\n', func , idx);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return ERR_PTR(-EINVAL);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return hw_data->hws[idx];\n}\nEXPORT_SYMBOL_GPL(of_clk_hw_onecell_get);\n```", "```\n/* forward reference */\nstruct max9485_driver_data;\nstruct max9485_clk_hw {\n\u00a0\u00a0\u00a0\u00a0struct clk_hw hw;\n\u00a0\u00a0\u00a0\u00a0struct clk_init_data init; \u00a0\u00a0\u00a0\u00a0u8 enable_bit;\n\u00a0\u00a0\u00a0\u00a0struct max9485_driver_data *drvdata;\n;\nstruct max9485_driver_data {\n\u00a0\u00a0\u00a0\u00a0struct clk *xclk;\n\u00a0\u00a0\u00a0\u00a0struct i2c_client *client;\n\u00a0\u00a0\u00a0\u00a0u8 reg_value;\n\u00a0\u00a0\u00a0\u00a0struct regulator *supply;\n\u00a0\u00a0\u00a0\u00a0struct gpio_desc *reset_gpio;\n\u00a0\u00a0\u00a0\u00a0struct max9485_clk_hw hw[MAX9485_NUM_CLKS];\n};\nstatic inline struct max9485_clk_hw *to_max9485_clk(struct \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clk_hw *hw)\n{\n\u00a0\u00a0\u00a0\u00a0return container_of(hw, struct max9485_clk_hw, hw);\n}\n```", "```\nstatic unsigned long\nmax9485_clkout_recalc_rate(struct clk_hw *hw,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long parent_rate)\n{\n\u00a0\u00a0\u00a0\u00a0struct max9485_clk_hw *max_clk_hw = to_max9485_clk(hw);\n\u00a0\u00a0\u00a0\u00a0struct max9485_driver_data *drvdata = max_clk_hw->drvdata;\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```\nstatic const struct max9485_clk max9485_clks[MAX9485_NUM_CLKS] = {\n\u00a0\u00a0\u00a0\u00a0[MAX9485_MCLKOUT] = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.name = 'mclkout',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.parent_index = -1,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.enable_bit = MAX9485_MCLK_ENABLE,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.ops = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.prepare\t\t= max9485_clk_prepare,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.unprepare\t= max9485_clk_unprepare,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0},\n\u00a0\u00a0\u00a0\u00a0},\n\u00a0\u00a0\u00a0\u00a0[MAX9485_CLKOUT] = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.name = 'clkout',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.parent_index = -1,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.ops = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.set_rate\t= max9485_clkout_set_rate,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.round_rate\t= max9485_clkout_round_rate,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.recalc_rate\t= max9485_clkout_recalc_rate,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0},\n\u00a0\u00a0\u00a0\u00a0},\n\u00a0\u00a0\u00a0\u00a0[MAX9485_CLKOUT1] = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.name = 'clkout1',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.parent_index = MAX9485_CLKOUT,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.enable_bit = MAX9485_CLKOUT1_ENABLE,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.ops = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.prepare\t= max9485_clk_prepare,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.unprepare\t= max9485_clk_unprepare,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0},\n\u00a0\u00a0\u00a0\u00a0},\n\u00a0\u00a0\u00a0\u00a0[MAX9485_CLKOUT2] = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.name = 'clkout2',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.parent_index = MAX9485_CLKOUT,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.enable_bit = MAX9485_CLKOUT2_ENABLE,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.ops = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.prepare\t= max9485_clk_prepare,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.unprepare\t= max9485_clk_unprepare,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0},\n\u00a0\u00a0\u00a0\u00a0},\n};\n```", "```\nstatic int max9485_i2c_probe(struct i2c_client *client,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const struct i2c_device_id *id)\n{\n\u00a0\u00a0\u00a0\u00a0struct max9485_driver_data *drvdata;\n\u00a0\u00a0\u00a0\u00a0struct device *dev = &client->dev;\n\u00a0\u00a0\u00a0\u00a0const char *xclk_name;\n\u00a0\u00a0\u00a0\u00a0int i, ret;\n\u00a0\u00a0\u00a0\u00a0drvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\n\u00a0\u00a0\u00a0\u00a0if (!drvdata)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -ENOMEM;\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0for (i = 0; i < MAX9485_NUM_CLKS; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int parent_index = max9485_clks[i].parent_index;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *name;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (of_property_read_string_index\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(dev->of_node, 'clock-output-names', i, &name) == 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0drvdata->hw[i].init.name = name;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0drvdata->hw[i].init.name = max9485_clks[i].name;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0drvdata->hw[i].init.ops = &max9485_clks[i].ops;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0drvdata->hw[i].init.num_parents = 1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0drvdata->hw[i].init.flags = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (parent_index > 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0drvdata->hw[i].init.parent_names =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&drvdata->hw[parent_index].init.name;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0drvdata->hw[i].init.flags |= CLK_SET_RATE_PARENT;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0drvdata->hw[i].init.parent_names = &xclk_name;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0drvdata->hw[i].enable_bit = max9485_clks[i].enable_bit;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0drvdata->hw[i].hw.init = &drvdata->hw[i].init;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0drvdata->hw[i].drvdata = drvdata;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = devm_clk_hw_register(dev, &drvdata->hw[i].hw);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (ret < 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return ret;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0devm_of_clk_add_hw_provider(dev, max9485_of_clk_get, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0drvdata);\n}\n```", "```\nstruct clk_ops {\n\u00a0\u00a0\u00a0\u00a0int\t(*prepare)(struct clk_hw *hw);\n\u00a0\u00a0\u00a0\u00a0void\t(*unprepare)(struct clk_hw *hw);\n\u00a0\u00a0\u00a0\u00a0int\t(*is_prepared)(struct clk_hw *hw);\n\u00a0\u00a0\u00a0\u00a0void\t(*unprepare_unused)(struct clk_hw *hw);\n\u00a0\u00a0\u00a0\u00a0int\t(*enable)(struct clk_hw *hw);\n\u00a0\u00a0\u00a0\u00a0void\t(*disable)(struct clk_hw *hw);\n\u00a0\u00a0\u00a0\u00a0int\t(*is_enabled)(struct clk_hw *hw);\n\u00a0\u00a0\u00a0\u00a0void\t(*disable_unused)(struct clk_hw *hw);\n\u00a0\u00a0\u00a0\u00a0unsigned long (*recalc_rate)(struct clk_hw *hw,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long parent_rate);\n\u00a0\u00a0\u00a0\u00a0long\t(*round_rate)(struct clk_hw *hw, unsigned long rate,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long *parent_rate);\n\u00a0\u00a0\u00a0\u00a0int\t(*determine_rate)(struct clk_hw *hw,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct clk_rate_request *req);\n\u00a0\u00a0\u00a0\u00a0int\t(*set_parent)(struct clk_hw *hw, u8 index);\n\u00a0\u00a0\u00a0\u00a0u8\t(*get_parent)(struct clk_hw *hw);\n\u00a0\u00a0\u00a0\u00a0int\t(*set_rate)(struct clk_hw *hw, unsigned long rate,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long parent_rate);\n[...]\n\u00a0\u00a0\u00a0\u00a0void\t(*init)(struct clk_hw *hw);\n};\n```", "```\n/*must be gated across rate change*/#define CLK_SET_RATE_GATE\u00a0\u00a0BIT(0)\n/*must be gated across re-parent*/#define CLK_SET_PARENT_GATE\t BIT(1)\n/*propagate rate change up one level */#define CLK_SET_RATE_PARENT\t BIT(2)\n/* do not gate even if unused */#define CLK_IGNORE_UNUSED\tBIT(3)\n/*Basic clk, can't do a to_clk_foo()*/#define CLK_IS_BASIC BIT(5)\n/*do not use the cached clk rate*/#define CLK_GET_RATE_NOCACHE BIT(6)\n/* don't re-parent on rate change */#define CLK_SET_RATE_NO_REPARENT BIT(7)\n/* do not use the cached clk accuracy */#define CLK_GET_ACCURACY_NOCACHE BIT(8)\n/* recalc rates after notifications */#define CLK_RECALC_NEW_RATES BIT(9)\n/* clock needs to run to set rate */#define CLK_SET_RATE_UNGATE BIT(10)\n/* do not gate, ever */#define CLK_IS_CRITICAL\tBIT(11)\n```", "```\nStruct clk_fixed_rate {\n\u00a0\u00a0\u00a0\u00a0struct clk_hw hw;\n\u00a0\u00a0\u00a0\u00a0unsigned long fixed_rate;\n\u00a0\u00a0\u00a0\u00a0u8 flags; [...]\n};\n#define to_clk_fixed_rate(_hw) \\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0container_of(_hw, struct clk_fixed_rate, hw)\n```", "```\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/init.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/reset-controller.h>\nstatic struct clk_fixed_rate clk_hw_xtal = {\n\u00a0\u00a0\u00a0\u00a0.fixed_rate = 24000000,\n\u00a0\u00a0\u00a0\u00a0.hw.init = &(struct clk_init_data){\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.name = 'xtal',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.num_parents = 0,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.ops = &clk_fixed_rate_ops,\n\u00a0\u00a0\u00a0\u00a0},\n};\nstatic struct clk_fixed_rate clk_hw_pll = {\n\u00a0\u00a0\u00a0\u00a0.fixed_rate = 45000000,\n\u00a0\u00a0\u00a0\u00a0.hw.init = &(struct clk_init_data){\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.name = 'fixed_pll',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.num_parents = 0,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.ops = &clk_fixed_rate_ops,\n\u00a0\u00a0\u00a0\u00a0},\n};\nstatic struct clk_hw_onecell_data fake_fixed_hw_onecell_data = {\n\u00a0\u00a0\u00a0\u00a0.hws = {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CLKID_XTAL]\t= &clk_hw_xtal.hw,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CLKID_PLL_FIXED]\t= &clk_hw_pll.hw,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[CLK_NR_CLKS]\t= NULL,\n\u00a0\u00a0\u00a0\u00a0},\n\u00a0\u00a0\u00a0\u00a0.num = CLK_NR_CLKS,\n};\n```", "```\nstatic int fake_fixed_clkc_probe(struct platform_device *pdev)\n{\n\u00a0\u00a0\u00a0\u00a0int ret, i;\n\u00a0\u00a0\u00a0\u00a0struct device *dev = &pdev->dev;\n\u00a0\u00a0\u00a0\u00a0for (i = CLKID_XTAL; i < CLK_NR_CLKS; i++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ret = devm_clk_hw_register(dev, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fake_fixed_hw_onecell_data.hws[i]);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (ret)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return ret;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return devm_of_clk_add_hw_provider(dev, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0of_clk_hw_onecell_get,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&fake_fixed_hw_onecell_data);\n}\nstatic const struct of_device_id fake_fixed_clkc_match_table[] = {\n\u00a0\u00a0\u00a0\u00a0{ .compatible = 'l.abcsmart,fake-fixed-clkc' },\n\u00a0\u00a0\u00a0\u00a0{ }\n};\nstatic struct platform_driver meson8b_driver = {\n\u00a0\u00a0\u00a0\u00a0.probe\t= fake_fixed_clkc_probe,\n\u00a0\u00a0\u00a0\u00a0.driver\t= {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.name\t= 'fake-fixed-clkc',\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.of_match_table = fake_fixed_clkc_match_table,\n\u00a0\u00a0\u00a0\u00a0},\n};\n```", "```\nstruct clk_hw *\n\u00a0\u00a0\u00a0\u00a0clk_hw_register_fixed_rate(struct device *dev, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *name,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *parent_name, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long flags,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long fixed_rate)\n```", "```\nstatic unsigned long\n\u00a0\u00a0\u00a0\u00a0clk_fixed_rate_recalc_rate(struct clk_hw *hw,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long parent_rate)\n{\n\u00a0\u00a0\u00a0\u00a0return to_clk_fixed_rate(hw)->fixed_rate;\n}\nstatic unsigned long\n\u00a0\u00a0\u00a0\u00a0clk_fixed_rate_recalc_accuracy(struct clk_hw *hw,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long parent_ accuracy)\n{\n\u00a0\u00a0\u00a0\u00a0return to_clk_fixed_rate(hw)->fixed_accuracy;\n}\nconst struct clk_ops clk_fixed_rate_ops = {\n\u00a0\u00a0\u00a0\u00a0.recalc_rate = clk_fixed_rate_recalc_rate,\n\u00a0\u00a0\u00a0\u00a0.recalc_accuracy = clk_fixed_rate_recalc_accuracy,\n};\n```", "```\nstatic unsigned long stm32f4_pll_div_recalc_rate(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct clk_hw *hw, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long parent_rate)\n{\n\u00a0\u00a0\u00a0\u00a0return clk_divider_ops.recalc_rate(hw, parent_rate);\n}\nstatic long stm32f4_pll_div_round_rate(struct clk_hw *hw,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long rate, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long *prate)\n{\n\u00a0\u00a0\u00a0\u00a0return clk_divider_ops.round_rate(hw, rate, prate);\n}\nstatic int stm32f4_pll_div_set_rate(struct clk_hw *hw,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long rate, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long parent_rate)\n{\n\u00a0\u00a0\u00a0\u00a0int pll_state, ret;\n\u00a0\u00a0\u00a0\u00a0struct clk_divider *div = to_clk_divider(hw);\n\u00a0\u00a0\u00a0\u00a0struct stm32f4_pll_div *pll_div = to_pll_div_clk(div);\n\u00a0\u00a0\u00a0\u00a0pll_state = stm32f4_pll_is_enabled(pll_div->hw_pll);\n\u00a0\u00a0\u00a0\u00a0if (pll_state)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stm32f4_pll_disable(pll_div->hw_pll);\n\u00a0\u00a0\u00a0\u00a0ret = clk_divider_ops.set_rate(hw, rate, parent_rate);\n\u00a0\u00a0\u00a0\u00a0if (pll_state)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stm32f4_pll_enable(pll_div->hw_pll);\n\u00a0\u00a0\u00a0\u00a0return ret;\n}\nstatic const struct clk_ops stm32f4_pll_div_ops = {\n\u00a0\u00a0\u00a0\u00a0.recalc_rate = stm32f4_pll_div_recalc_rate,\n\u00a0\u00a0\u00a0\u00a0.round_rate = stm32f4_pll_div_round_rate,\n\u00a0\u00a0\u00a0\u00a0.set_rate = stm32f4_pll_div_set_rate,\n};\n```", "```\n/* fixed crystal dedicated to mpc251x */\nclocks {\n\u00a0\u00a0\u00a0\u00a0/* fixed crystal dedicated to mpc251x */\n\u00a0\u00a0\u00a0\u00a0clk8m: clk@1 {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compatible = 'fixed-clock';\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reg=<0>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#clock-cells = <0>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clock-frequency = <8000000>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clock-output-names = 'clk8m';\n\u00a0\u00a0\u00a0\u00a0};\n};\n/* consumer */\ncan1: can@1 {\n\u00a0\u00a0\u00a0\u00a0compatible = 'microchip,mcp2515';\n\u00a0\u00a0\u00a0\u00a0reg = <0>;\n\u00a0\u00a0\u00a0\u00a0spi-max-frequency = <10000000>;\n\u00a0\u00a0\u00a0\u00a0clocks = <&clk8m>;\n};\n```", "```\nmipi_xclk: mipi_xclk {\n\u00a0\u00a0\u00a0\u00a0compatible = 'pwm-clock';\n\u00a0\u00a0\u00a0\u00a0#clock-cells = <0>;\n\u00a0\u00a0\u00a0\u00a0clock-frequency = <22000000>;\n\u00a0\u00a0\u00a0\u00a0clock-output-names = 'mipi_pwm3';\n\u00a0\u00a0\u00a0\u00a0pwms = <&pwm3 0 45>; /* 1 / 45 ns = 22 MHz */\n\u00a0\u00a0\u00a0\u00a0status = 'okay';\n};\nov5640: camera@40 {\n\u00a0\u00a0\u00a0\u00a0compatible = 'ovti,ov5640';\n\u00a0\u00a0\u00a0\u00a0pinctrl-names = 'default';\n\u00a0\u00a0\u00a0\u00a0pinctrl-0 = <&pinctrl_ov5640>;\n\u00a0\u00a0\u00a0\u00a0reg = <0x40>;\n\u00a0\u00a0\u00a0\u00a0clocks = <&mipi_xclk>;\n\u00a0\u00a0\u00a0\u00a0clock-names = 'xclk';\n\u00a0\u00a0\u00a0\u00a0DOVDD-supply = <&reg_1p8v>;\n\u00a0\u00a0\u00a0\u00a0AVDD-supply = <&reg_2p8v>;\n\u00a0\u00a0\u00a0\u00a0DVDD-supply = <&reg_1p5v>;\n\u00a0\u00a0\u00a0\u00a0reset-gpios = <&gpio2 5 GPIO_ACTIVE_LOW>;\n\u00a0\u00a0\u00a0\u00a0powerdown-gpios = <&gpio6 9 GPIO_ACTIVE_HIGH>;\n[...]\n};\n```", "```\nstruct clk_fixed_factor {\n\u00a0\u00a0\u00a0\u00a0struct clk_hw\thw;\n\u00a0\u00a0\u00a0\u00a0unsigned int\t\tmult;\n\u00a0\u00a0\u00a0\u00a0unsigned int\t\tdiv;\n};\n#define to_clk_fixed_factor(_hw) \\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0container_of(_hw, struct clk_fixed_factor, hw)\n```", "```\nstatic int clk_factor_set_rate(struct clk_hw *hw, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long rate,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long parent_rate)\n{\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```\nconst struct clk_ops clk_fixed_factor_ops = {\n\u00a0\u00a0\u00a0\u00a0.round_rate = clk_factor_round_rate,\n\u00a0\u00a0\u00a0\u00a0.set_rate = clk_factor_set_rate,\n\u00a0\u00a0\u00a0\u00a0.recalc_rate = clk_factor_recalc_rate,\n};\nEXPORT_SYMBOL_GPL(clk_fixed_factor_ops);\n```", "```\nstruct clk_hw *\n\u00a0\u00a0\u00a0\u00a0clk_hw_register_fixed_factor(struct device *dev, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *name,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *parent_name, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long flags, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int mult, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int div)\n```", "```\nclock {\n\u00a0\u00a0\u00a0\u00a0compatible = 'fixed-factor-clock';\n\u00a0\u00a0\u00a0\u00a0clocks = <&parentclk>;\n\u00a0\u00a0\u00a0\u00a0#clock-cells = <0>;\n\u00a0\u00a0\u00a0\u00a0clock-div = <2>;\n\u00a0\u00a0\u00a0\u00a0clock-mult = <1>;\n};\n```", "```\nstruct clk_gate {\n\u00a0\u00a0\u00a0\u00a0struct clk_hw hw;\n\u00a0\u00a0\u00a0\u00a0void\u00a0\u00a0iomem\t*reg;\n\u00a0\u00a0\u00a0\u00a0u8\tbit_idx;\n\u00a0\u00a0\u00a0\u00a0u8\tflags;\n\u00a0\u00a0\u00a0\u00a0spinlock_t\t*lock;\n};\n#define to_clk_gate(_hw) container_of(_hw, struct clk_gate, hw)\n```", "```\nstruct clk_hw *\n\u00a0\u00a0\u00a0\u00a0clk_hw_register_gate(struct device *dev, const char *name,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *parent_name, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long flags,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void iomem *reg, u8 bit_idx,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u8 clk_gate_flags, spinlock_t *lock);\n```", "```\nconst struct clk_ops clk_gate_ops = {\n\u00a0\u00a0\u00a0\u00a0.enable = clk_gate_enable,\n\u00a0\u00a0\u00a0\u00a0.disable = clk_gate_disable,\n\u00a0\u00a0\u00a0\u00a0.is_enabled = clk_gate_is_enabled,\n};\nEXPORT_SYMBOL_GPL(clk_gate_ops);\n```", "```\nclk_ti_wifi: ti-wifi-clock {\n\u00a0\u00a0\u00a0\u00a0compatible = 'gpio-gate-clock';\n\u00a0\u00a0\u00a0\u00a0#clock-cells = <0>;\n\u00a0\u00a0\u00a0\u00a0clock-frequency = <32768>;\n\u00a0\u00a0\u00a0\u00a0pinctrl-names = 'default';\n\u00a0\u00a0\u00a0\u00a0pinctrl-0 = <&pinctrl_microsom_ti_clk>;\n\u00a0\u00a0\u00a0\u00a0enable-gpios = <&gpio5 5 GPIO_ACTIVE_HIGH>;\n};\npwrseq_ti_wifi: ti-wifi-pwrseq {\n\u00a0\u00a0\u00a0\u00a0compatible = 'mmc-pwrseq-simple';\n\u00a0\u00a0\u00a0\u00a0pinctrl-names = 'default';\n\u00a0\u00a0\u00a0\u00a0pinctrl-0 = <&pinctrl_microsom_ti_wifi_en>;\n\u00a0\u00a0\u00a0\u00a0reset-gpios = <&gpio5 26 GPIO_ACTIVE_LOW>;\n\u00a0\u00a0\u00a0\u00a0post-power-on-delay-ms = <200>;\n\u00a0\u00a0\u00a0\u00a0clocks = <&clk_ti_wifi>; \n\u00a0\u00a0\u00a0\u00a0clock-names = 'ext_clock';\n};\n```", "```\nstruct clk_mux {\n\u00a0\u00a0\u00a0\u00a0struct clk_hw hw;\n\u00a0\u00a0\u00a0\u00a0void __iomem *reg;\n\u00a0\u00a0\u00a0\u00a0u32\t*table;\n\u00a0\u00a0\u00a0\u00a0u32\tmask;\n\u00a0\u00a0\u00a0\u00a0u8\tshift;\n\u00a0\u00a0\u00a0\u00a0u8\tflags;\n\u00a0\u00a0\u00a0\u00a0spinlock_t\t*lock;\n};\n#define to_clk_mux(_hw) container_of(_hw, struct clk_mux, hw)\n```", "```\nstruct clk_hw *\n\u00a0\u00a0\u00a0\u00a0clk_hw_register_mux(struct device *dev, const char *name,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char * const *parent_names,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u8 num_parents, unsigned long flags,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void iomem *reg, u8 shift, u8 width,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u8 clk_mux_flags, spinlock_t *lock)\n```", "```\nif (clk_mux_flags & CLK_MUX_READ_ONLY)\n\u00a0\u00a0\u00a0\u00a0init.ops = &clk_mux_ro_ops;\nelse\n\u00a0\u00a0\u00a0\u00a0init.ops = &clk_mux_ops;\n```", "```\nconst struct clk_ops clk_mux_ops = {\n\u00a0\u00a0\u00a0\u00a0.get_parent = clk_mux_get_parent,\n\u00a0\u00a0\u00a0\u00a0.set_parent = clk_mux_set_parent,\n\u00a0\u00a0\u00a0\u00a0.determine_rate = clk_mux_determine_rate,\n};\nEXPORT_SYMBOL_GPL(clk_mux_ops);\nconst struct clk_ops clk_mux_ro_ops = {\n\u00a0\u00a0\u00a0\u00a0.get_parent = clk_mux_get_parent,\n};\nEXPORT_SYMBOL_GPL(clk_mux_ro_ops);\n```", "```\nstruct clk *\n\u00a0\u00a0\u00a0\u00a0clk_register_mux_table(struct device *dev, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *name,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char **parent_names, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u8 num_parents, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long flags, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void iomem *reg, u8 shift, u32 mask,\nu8 clk_mux_flags, u32 *table, spinlock_t *lock);\n```", "```\n    unsigned int\n    \u00a0\u00a0\u00a0clk_mux_index_to_val(u32 *table, unsigned int flags, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u8 index)\n    {\n    \u00a0\u00a0\u00a0\u00a0unsigned int val = index;\n    \u00a0\u00a0\u00a0\u00a0if (table) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val = table[index];\n    \u00a0\u00a0\u00a0\u00a0} else {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (flags & CLK_MUX_INDEX_BIT)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val = 1 << index;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (flags & CLK_MUX_INDEX_ONE) val++;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0return val;\n    }\n    static int clk_mux_set_parent(struct clk_hw *hw, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u8 index)\n    {\n    \u00a0\u00a0\u00a0\u00a0struct clk_mux *mux = to_clk_mux(hw);\n    \u00a0\u00a0\u00a0\u00a0u32 val =\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clk_mux_index_to_val(mux->table, mux->flags,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0index);\n    \u00a0\u00a0\u00a0\u00a0unsigned long flags = 0; u32 reg;\n    \u00a0\u00a0\u00a0\u00a0if (mux->lock)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0spin_lock_irqsave(mux->lock, flags);\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0__acquire(mux->lock);\n    \u00a0\u00a0\u00a0\u00a0if (mux->flags & CLK_MUX_HIWORD_MASK) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reg = mux->mask << (mux->shift + 16);\n    \u00a0\u00a0\u00a0\u00a0} else {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reg = clk_readl(mux->reg);\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reg &= ~(mux->mask << mux->shift);\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0val = val << mux->shift; reg |= val;\n    \u00a0\u00a0\u00a0\u00a0clk_writel(reg, mux->reg);\n    \u00a0\u00a0\u00a0\u00a0if (mux->lock)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0spin_unlock_irqrestore(mux->lock, flags);\n    \u00a0\u00a0\u00a0\u00a0else\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0__release(mux->lock);\n    \u00a0\u00a0\u00a0\u00a0return 0;\n    }\n    ```", "```\n    int clk_mux_val_to_index(struct clk_hw *hw, u32 *table,\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int flags, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int val)\n    {\n    \u00a0\u00a0\u00a0\u00a0int num_parents = clk_hw_get_num_parents(hw);\n    \u00a0\u00a0\u00a0\u00a0if (table) {\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int i;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (i = 0; i < num_parents; i++)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (table[i] == val)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return i;\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -EINVAL;\n    \u00a0\u00a0\u00a0\u00a0}\n    \u00a0\u00a0\u00a0\u00a0if (val && (flags & CLK_MUX_INDEX_BIT))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val = ffs(val) - 1;\n    \u00a0\u00a0\u00a0\u00a0if (val && (flags & CLK_MUX_INDEX_ONE))\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val--;\n    \u00a0\u00a0\u00a0\u00a0if (val >= num_parents)\n    \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -EINVAL;\n    \u00a0\u00a0\u00a0\u00a0return val;\n    }\n    EXPORT_SYMBOL_GPL(clk_mux_val_to_index);\n    static u8 clk_mux_get_parent(struct clk_hw *hw)\n    {\n    \u00a0\u00a0\u00a0\u00a0struct clk_mux *mux = to_clk_mux(hw);\n    \u00a0\u00a0\u00a0\u00a0u32 val;\n    \u00a0\u00a0\u00a0\u00a0val = clk_readl(mux->reg) >> mux->shift;\n    \u00a0\u00a0\u00a0\u00a0val &= mux->mask;\n    \u00a0\u00a0\u00a0\u00a0return clk_mux_val_to_index(hw, mux->table, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mux->flags, val);\n    }\n    ```", "```\nstruct clk_hw *clk_hw_register_gpio_mux(struct device *dev,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *name,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char * \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const *parent_names,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u8 num_parents,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct gpio_desc *gpiod,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long flags)\n{\n\u00a0\u00a0\u00a0\u00a0if (num_parents != 2) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pr_err('mux-clock %s must have 2 parents\\n', name);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return ERR_PTR(-EINVAL);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return clk_register_gpio(dev, name, parent_names, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0num_parents,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0gpiod, flags, &clk_gpio_mux_ops);\n}\nEXPORT_SYMBOL_GPL(clk_hw_register_gpio_mux);\n```", "```\nclocks {\n\u00a0\u00a0\u00a0\u00a0/* fixed clock oscillators */\n\u00a0\u00a0\u00a0\u00a0parent1: oscillator22 {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compatible = 'fixed-clock';\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#clock-cells = <0>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clock-frequency = <22579200>;\n\u00a0\u00a0\u00a0\u00a0};\n\u00a0\u00a0\u00a0\u00a0parent2: oscillator24 {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compatible = 'fixed-clock';\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#clock-cells = <0>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clock-frequency = <24576000>;\n\u00a0\u00a0\u00a0\u00a0};\n\u00a0\u00a0\u00a0\u00a0/* gpio-controlled clock multiplexer */\n\u00a0\u00a0\u00a0\u00a0mux: multiplexer {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compatible = 'gpio-mux-clock';\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0clocks = <&parent1>, <&parent2>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* parent clocks */\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0#clock-cells = <0>;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0select-gpios = <&gpio 42 GPIO_ACTIVE_HIGH>;\n\u00a0\u00a0\u00a0\u00a0};\n};\n```", "```\nstruct clk_divider {\n\u00a0\u00a0\u00a0\u00a0struct clk_hw\u00a0\u00a0hw;\n\u00a0\u00a0\u00a0\u00a0void iomem\t*reg;\n\u00a0\u00a0\u00a0\u00a0u8\tshift;\n\u00a0\u00a0\u00a0\u00a0u8\twidth;\n\u00a0\u00a0\u00a0\u00a0u8\tflags;\n\u00a0\u00a0\u00a0\u00a0const struct clk_div_table\t*table;\n\u00a0\u00a0\u00a0\u00a0spinlock_t\t*lock;\n};\n#define to_clk_divider(_hw) container_of(_hw, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct clk_divider, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0hw)\n```", "```\n    Value\t\tdivisor\n    0\t\t4\n    1\t\t1\n    2\t\t2\n    3\t\t3\n    ```", "```\nstruct clk_hw *\n\u00a0\u00a0\u00a0\u00a0clk_hw_register_divider(struct device *dev,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *name, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *parent_name, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long flags, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void iomem *reg,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u8 shift, u8 width, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u8 clk_divider_flags, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0spinlock_t *lock)\n```", "```\nstruct clk_hw *\n\u00a0\u00a0\u00a0\u00a0\u00a0clk_hw_register_divider_table(\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct device *dev,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *name, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *parent_name, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long flags, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void iomem *reg,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u8 shift, u8 width, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u8 clk_divider_flags, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const struct clk_div_table *table, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0spinlock_t *lock)\n```", "```\nstruct clk_div_table {\n\u00a0\u00a0\u00a0\u00a0unsigned int\tval;\n\u00a0\u00a0\u00a0\u00a0unsigned int\tdiv;\n};\n```", "```\nif (clk_divider_flags & CLK_DIVIDER_READ_ONLY)\n\u00a0\u00a0\u00a0\u00a0init.ops = &clk_divider_ro_ops;\nelse\n\u00a0\u00a0\u00a0\u00a0init.ops = &clk_divider_ops;\n```", "```\nconst struct clk_ops clk_divider_ops = {\n\u00a0\u00a0\u00a0\u00a0.recalc_rate = clk_divider_recalc_rate,\n\u00a0\u00a0\u00a0\u00a0.round_rate = clk_divider_round_rate,\n\u00a0\u00a0\u00a0\u00a0.set_rate = clk_divider_set_rate,\n};\nEXPORT_SYMBOL_GPL(clk_divider_ops);\nconst struct clk_ops clk_divider_ro_ops = {\n\u00a0\u00a0\u00a0\u00a0.recalc_rate = clk_divider_recalc_rate,\n\u00a0\u00a0\u00a0\u00a0.round_rate = clk_divider_round_rate,\n};\nEXPORT_SYMBOL_GPL(clk_divider_ro_ops);\n```", "```\nstruct clk_composite {\n\u00a0\u00a0\u00a0\u00a0struct clk_hw\thw;\n\u00a0\u00a0\u00a0\u00a0struct clk_ops\tops;\n\u00a0\u00a0\u00a0\u00a0struct clk_hw\t*mux_hw;\n\u00a0\u00a0\u00a0\u00a0struct clk_hw\t*rate_hw;\n\u00a0\u00a0\u00a0\u00a0struct clk_hw\t*gate_hw;\n\u00a0\u00a0\u00a0\u00a0const struct clk_ops\t*mux_ops;\n\u00a0\u00a0\u00a0\u00a0const struct clk_ops\t*rate_ops;\n\u00a0\u00a0\u00a0\u00a0const struct clk_ops\t*gate_ops;\n};\n#define to_clk_composite(_hw) container_of(_hw, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct clk_composite,\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0hw)\n```", "```\nstruct clk_hw *clk_hw_register_composite(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct device *dev, const char *name,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char * const *parent_names, int num_parents,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct clk_hw *mux_hw, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const struct clk_ops *mux_ops,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct clk_hw *rate_hw, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const struct clk_ops *rate_ops,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct clk_hw *gate_hw, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const struct clk_ops *gate_ops,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long flags)\n```", "```\nosc: oscillator {\n\u00a0\u00a0\u00a0\u00a0#clock-cells = <0>;\n\u00a0\u00a0\u00a0\u00a0compatible = 'fixed-clock';\n\u00a0\u00a0\u00a0\u00a0clock-frequency = <20000000>;\n\u00a0\u00a0\u00a0\u00a0clock-output-names = 'osc20M';\n};\npll2: pll2 {\n\u00a0\u00a0\u00a0\u00a0#clock-cells = <0>;\n\u00a0\u00a0\u00a0\u00a0compatible = 'abc123,pll2-clock';\n\u00a0\u00a0\u00a0\u00a0clock-frequency = <23000000>; clocks = <&osc>;\n\u00a0\u00a0\u00a0\u00a0[...]\n};\npll3: pll3 {\n\u00a0\u00a0\u00a0\u00a0#clock-cells = <0>;\n\u00a0\u00a0\u00a0\u00a0compatible = 'abc123,pll3-clock';\n\u00a0\u00a0\u00a0\u00a0clock-frequency = <23000000>; clocks = <&osc>;\n\u00a0\u00a0\u00a0\u00a0[...]\n};\nhw3_clk: hw3_clk {\n\u00a0\u00a0\u00a0\u00a0#clock-cells = <0>;\n\u00a0\u00a0\u00a0\u00a0compatible = 'abc123,hw3-clk';\n\u00a0\u00a0\u00a0\u00a0clocks = <&pll2>, <&pll3>, <&osc>;\n\u00a0\u00a0\u00a0\u00a0clock-output-names = 'hw3_clk';\n};\n```", "```\nof_property_read_string(node, 'clock-output-names', &clk_name); \nparent_names[0] = of_clk_get_parent_name(node, 0);\nparent_names[1] = of_clk_get_parent_name(node, 1);\nparent_names[2] = of_clk_get_parent_name(node, 2); /* osc */\nclk = clk_register_mux(NULL, clk_name, parent_names,\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ARRAY_SIZE(parent_names), 0, regs_base,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0offset_bit, one_bit, 0, NULL);\n```", "```\n$ mount -t debugfs none /sys/kernel/debug\n# cat /sys/kernel/debug/clk/clk_summary\n[...]\n```", "```\nuart1: serial@02020000 {\n\u00a0\u00a0\u00a0\u00a0compatible = 'fsl,imx6sx-uart', 'fsl,imx21-uart';\n\u00a0\u00a0\u00a0\u00a0reg = <0x02020000 0x4000>;\n\u00a0\u00a0\u00a0\u00a0interrupts = <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>;\n\u00a0\u00a0\u00a0\u00a0clocks = <&clks IMX6SX_CLK_UART_IPG>,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<&clks IMX6SX_CLK_UART_SERIAL>;\n\u00a0\u00a0\u00a0\u00a0clock-names = 'ipg', 'per';\n\u00a0\u00a0\u00a0\u00a0dmas = <&sdma 25 4 0>, <&sdma 26 4 0>;\n\u00a0\u00a0\u00a0\u00a0dma-names = 'rx', 'tx';\n\u00a0\u00a0\u00a0\u00a0status = 'disabled';\n};\n```", "```\nstruct clk *clk_get(struct device *dev, const char *id);\nvoid clk_put(struct clk *clk);\nstruct clk *C(struct device *dev, const char *id)\n```", "```\nvoid clk_prepare(struct clk *clk);\nvoid clk_unprepare(struct clk *clk);\n```", "```\nint clk_enable(struct clk *clk);\nvoid clk_disable(struct clk *clk);\n```", "```\nint clk_prepare_enable(struct clk *clk)\nvoid clk_disable_unprepare(struct clk *clk)\n```", "```\nunsigned long clk_get_rate(struct clk *clk);\nint clk_set_rate(struct clk *clk, unsigned long rate);\nlong clk_round_rate(struct clk *clk, unsigned long rate);\n```", "```\nrounded_rate = clk_round_rate(clkp, target_rate);\n```", "```\nret = clk_set_rate(clkp, rounded_rate);\n```", "```\nint clk_set_parent(struct clk *clk, struct clk *parent);\nstruct clk *clk_get_parent(struct clk *clk);\n```", "```\nsport->clk_per = devm_clk_get(&pdev->dev, 'per');\nif (IS_ERR(sport->clk_per)) {\n\u00a0\u00a0\u00a0\u00a0ret = PTR_ERR(sport->clk_per);\n\u00a0\u00a0\u00a0\u00a0dev_err(&pdev->dev, 'failed to get per clk: %d\\n', ret);\n\u00a0\u00a0\u00a0\u00a0return ret;\n}\nsport->port.uartclk = clk_get_rate(sport->clk_per);\n/*  * For register access, we only need to enable the ipg clock.  */\nret = clk_prepare_enable(sport->clk_ipg);\nif (ret)\n\u00a0\u00a0\u00a0\u00a0return ret;\n```"]