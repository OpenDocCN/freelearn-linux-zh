["```\n#include <linux/of.h> \n#include <linux/of_device.h> \n```", "```\n/* This is a comment */ \n// This is another comment \nnode_label: nodename@reg{ \n   string-property = \"a string\"; \n   string-list = \"red fish\", \"blue fish\"; \n   one-int-property = <197>; /* One cell in this property */ \n   int-list-property = <0xbeef 123 0xabcd4>; /*each number (cell) is a                         \n\n                                               *32 bit integer(uint32).\n\n                                               *There are 3 cells in  \n\n                                               */this property \n\n    mixed-list-property = \"a string\", <0xadbcd45>, <35>, [0x01 0x23 0x45] \n    byte-array-property = [0x01 0x23 0x45 0x67]; \n    boolean-property; \n}; \n```", "```\nexpander@20 { \n    compatible = \"microchip,mcp23017\"; \n    reg = <20>; \n    [...]        \n}; \n```", "```\ni2c@021a0000 { \n    compatible = \"fsl,imx6q-i2c\", \"fsl,imx21-i2c\"; \n    reg = <0x021a0000 0x4000>; \n    [...] \n}; \n```", "```\naliases { \n    ethernet0 = &fec; \n    gpio0 = &gpio1; \n    gpio1 = &gpio2; \n    mmc0 = &usdhc1; \n    [...] \n}; \ngpio1: gpio@0209c000 { \n    compatible = \"fsl,imx6q-gpio\", \"fsl,imx35-gpio\"; \n    [...] \n}; \nnode_label: nodename@reg { \n    [...]; \n    gpios = <&gpio1 7 GPIO_ACTIVE_HIGH>; \n}; \n```", "```\nthename@address { \n    property = <&mylabel>; \n}; \n\nmylabel: thename@adresss { \n    [...] \n} \n```", "```\nARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make dtbs \n\n```", "```\nARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- make imx6dl-sabrelite.dtb \n\n```", "```\ndtc -I dtb -O dtsarch/arm/boot/dts imx6dl-sabrelite.dtb >path/to/my_devicetree.dts \n```", "```\n&i2c3 { \n    [...] \n    status = \"okay\"; \n\n    temperature-sensor@49 { \n        compatible = \"national,lm73\"; \n        reg = <0x49>; \n    }; \n\n    pcf8523: rtc@68 { \n        compatible = \"nxp,pcf8523\"; \n        reg = <0x68>; \n    }; \n}; \n\n&ecspi1 { \nfsl,spi-num-chipselects = <3>; \ncs-gpios = <&gpio5 17 0>, <&gpio5 17 0>, <&gpio5 17 0>; \nstatus = \"okay\"; \n[...] \n\nad7606r8_0: ad7606r8@1 { \n    compatible = \"ad7606-8\"; \n    reg = <1>; \n    spi-max-frequency = <1000000>; \n    interrupt-parent = <&gpio4>; \n    interrupts = <30 0x0>; \n    convst-gpio = <&gpio6 18 0>; \n}; \n}; \n```", "```\nsoc { \n    #address-cells = <1>; \n    #size-cells = <1>; \n    compatible = \"simple-bus\"; \n    aips-bus@02000000 { /* AIPS1 */ \n        compatible = \"fsl,aips-bus\", \"simple-bus\"; \n        #address-cells = <1>; \n        #size-cells = <1>; \n        reg = <0x02000000 0x100000>; \n        [...]; \n\n        spba-bus@02000000 { \n            compatible = \"fsl,spba-bus\", \"simple-bus\"; \n            #address-cells = <1>; \n            #size-cells = <1>; \n            reg = <0x02000000 0x40000>; \n            [...] \n\n            ecspi1: ecspi@02008000 { \n                #address-cells = <1>; \n                #size-cells = <0>; \n                compatible = \"fsl,imx6q-ecspi\", \"fsl,imx51-ecspi\"; \n                reg = <0x02008000 0x4000>; \n                [...] \n            }; \n\n            i2c1: i2c@021a0000 { \n                #address-cells = <1>; \n                #size-cells = <0>; \n                compatible = \"fsl,imx6q-i2c\", \"fsl,imx21-i2c\"; \n                reg = <0x021a0000 0x4000>; \n                [...] \n            }; \n        }; \n    }; \n```", "```\nuart1: serial@02020000 { \n        compatible = \"fsl,imx6q-uart\", \"fsl,imx21-uart\"; \nreg = <0x02020000 0x4000>; \n        interrupts = <0 26 IRQ_TYPE_LEVEL_HIGH>; \n        clocks = <&clks IMX6QDL_CLK_UART_IPG>, \n<&clks IMX6QDL_CLK_UART_SERIAL>; \n        clock-names = \"ipg\", \"per\"; \ndmas = <&sdma 25 4 0>, <&sdma 26 4 0>; \ndma-names = \"rx\", \"tx\"; \n        status = \"disabled\"; \n    }; \n```", "```\nfake_device { \n    compatible = \"packt,fake-device\"; \n    reg = <0x4a064000 0x800>, <0x4a064800 0x200>, <0x4a064c00 0x200>; \n    reg-names = \"config\", \"ohci\", \"ehci\"; \n    interrupts = <0 66 IRQ_TYPE_LEVEL_HIGH>, <0 67 IRQ_TYPE_LEVEL_HIGH>; \n    interrupt-names = \"ohci\", \"ehci\"; \n    clocks = <&clks IMX6QDL_CLK_UART_IPG>, <&clks IMX6QDL_CLK_UART_SERIAL>; \n    clock-names = \"ipg\", \"per\"; \n    dmas = <&sdma 25 4 0>, <&sdma 26 4 0>; \n    dma-names = \"rx\", \"tx\"; \n}; \n```", "```\nstruct resource *res1, *res2; \nres1 = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"ohci\"); \nres2 = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"config\"); \n\nstruct dma_chan  *dma_chan_rx, *dma_chan_tx; \ndma_chan_rx = dma_request_slave_channel(&pdev->dev, \"rx\"); \ndma_chan_tx = dma_request_slave_channel(&pdev->dev, \"tx\"); \n\ninttxirq, rxirq; \ntxirq = platform_get_irq_byname(pdev, \"ohci\"); \nrxirq = platform_get_irq_byname(pdev, \"ehci\"); \n\nstructclk *clck_per, *clk_ipg; \nclk_ipg = devm_clk_get(&pdev->dev, \"ipg\"); \nclk_ipg = devm_clk_get(&pdev->dev, \"pre\"); \n```", "```\nstruct resource *res; \nvoid __iomem *base; \n\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0); \n/* \n * Here one can request and map the memory region \n * using request_mem_region(res->start, resource_size(res), pdev->name) \n * and ioremap(iores->start, resource_size(iores) \n * \n * These function are discussed in chapter 11, Kernel Memory Management. \n */ \nbase = devm_ioremap_resource(&pdev->dev, res); \nif (IS_ERR(base)) \n    return PTR_ERR(base); \n```", "```\nint irq = platform_get_irq(pdev, 0); \nret = request_irq(irq, imx_rxint, 0, dev_name(&pdev->dev), sport); \n```", "```\ninterrupts = <0 66 IRQ_TYPE_LEVEL_HIGH>; \n```", "```\nnode_label: nodename@reg{ \n  string-property = \"\"a string\"\"; \n  string-list = \"\"red fish\"\", \"\"blue fish\"\"; \n  one-int-property = <197>; /* One cell in this property */ \n  int-list-property = <0xbeef 123 0xabcd4>;/* each number (cell) is 32      a                                        * bit integer(uint32). There \n                                         * are 3 cells in this property \n                                         */ \n    mixed-list-property = \"a string\", <0xadbcd45>, <35>, [0x01 0x23 0x45] \n    byte-array-property = [0x01 0x23 0x45 0x67]; \n    one-cell-property = <197>; \n    boolean-property; \n}; \n```", "```\nstring-property = \"a string\"; \n```", "```\nint of_property_read_string(const struct device_node *np, const \n                        char *propname, const char **out_string) \n```", "```\nconst char *my_string = NULL; \nof_property_read_string(pdev->dev.of_node, \"string-property\", &my_string); \n```", "```\none-int-property = <197>; \nint-list-property = <1350000 0x54dae47 1250000 1200000>; \n```", "```\nint of_property_read_u32_index(const struct device_node *np, \n                     const char *propname, u32 index, u32 *out_value) \n```", "```\nunsigned int number; \nof_property_read_u32(pdev->dev.of_node, \"one-cell-property\", &number); \n```", "```\nint of_property_read_u32_array(const struct device_node *np, \n                      const char *propname, u32 *out_values, size_tsz); \n```", "```\nunsigned int cells_array[4]; \nif (of_property_read_u32_array(pdev->dev.of_node, \"int-list-property\", \ncells_array, 4)) { \n    dev_err(&pdev->dev, \"list of cells not specified\\n\"); \n    return -EINVAL; \n} \n```", "```\nbool my_bool = of_property_read_bool(pdev->dev.of_node, \"boolean-property\"); \nIf(my_bool){ \n    /* boolean is true */ \n} else \n    /* Bolean is false */ \n} \n```", "```\neeprom: ee24lc512@55 { \n        compatible = \"microchip,24xx512\"; \nreg = <0x55>; \n\n        partition1 { \n            read-only; \n            part-name = \"private\"; \n            offset = <0>; \n            size = <1024>; \n        }; \n\n        partition2 { \n            part-name = \"data\"; \n            offset = <1024>; \n            size = <64512>; \n        }; \n    }; \n```", "```\nstruct device_node *np = pdev->dev.of_node; \nstruct device_node *sub_np; \nfor_each_child_of_node(np, sub_np) { \n        /* sub_np will point successively to each sub-node */ \n        [...] \nint size; \n        of_property_read_u32(client->dev.of_node, \n\"size\", &size); \n        ... \n } \n```", "```\n// we are only interested in the two last elements of the structure \nstruct of_device_id { \n    [...] \n    char  compatible[128]; \n    const void *data; \n}; \n```", "```\nstatic const struct of_device_id imx_uart_dt_ids[] = { \n    { .compatible = \"fsl,imx6q-uart\", }, \n    { .compatible = \"fsl,imx1-uart\", }, \n    { .compatible = \"fsl,imx21-uart\", }, \n    { /* sentinel */ } \n}; \n```", "```\nstatic struct platform_driver serial_imx_driver = { \n    [...] \n    .driver     = { \n        .name   = \"imx-uart\", \n        .of_match_table = imx_uart_dt_ids, \n        [...] \n    }, \n}; \n```", "```\nMODULE_DEVICE_TABLE(of, imx_uart_dt_ids); \n```", "```\nuart1: serial@02020000 { \n    compatible = \"fsl,imx6q-uart\", \"fsl,imx21-uart\"; \n    reg = <0x02020000 0x4000>; \n    interrupts = <0 26 IRQ_TYPE_LEVEL_HIGH>; \n    [...] \n}; \n```", "```\nstatic int serial_imx_probe(struct platform_device *pdev) \n{ \n    [...] \nstruct device_node *np; \nnp = pdev->dev.of_node; \n\n    if (of_get_property(np, \"fsl,dte-mode\", NULL)) \n        sport->dte_mode = 1; \n        [...] \n }   \n```", "```\nstatic int my_probe(struct platform_device *pdev) \n{ \nstruct device_node *np = pdev->dev.of_node; \nconst struct of_device_id *match; \n\n    match = of_match_device(imx_uart_dt_ids, &pdev->dev); \n    if (match) { \n        /* Devicetree, extract the data */ \n        my_data = match->data \n    } else { \n        /* Board init file */ \n        my_data = dev_get_platdata(&pdev->dev); \n    } \n    [...] \n} \n```", "```\n#ifdef CONFIG_OF \n    static const struct of_device_id imx_uart_dt_ids[] = { \n        { .compatible = \"fsl,imx6q-uart\", }, \n        { .compatible = \"fsl,imx1-uart\", }, \n        { .compatible = \"fsl,imx21-uart\", }, \n        { /* sentinel */ } \n    }; \n\n    /* other devicetree dependent code */ \n    [...] \n#endif \n```", "```\n#define of_match_ptr(_ptr) (_ptr) /* When CONFIG_OF is enabled */ \n#define of_match_ptr(_ptr) NULL   /* When it is not */ \n```", "```\nstatic int my_probe(struct platform_device *pdev) \n{ \n    const struct of_device_id *match; \n    match = of_match_device(of_match_ptr(imx_uart_dt_ids), \n                     &pdev->dev); \n    [...] \n} \nstatic struct platform_driver serial_imx_driver = { \n    [...] \n    .driver         = { \n    .name   = \"imx-uart\", \n    .of_match_table = of_match_ptr(imx_uart_dt_ids), \n    }, \n}; \n```", "```\n/* \n * Struct used for matching a device \n */ \nstruct of_device_id { \n        [...] \n        char    compatible[128]; \nconst void *data; \n}; \n```", "```\n/* i.MX21 type uart runs on all i.mx except i.MX1 and i.MX6q */ \nenum imx_uart_type { \n    IMX1_UART, \n    IMX21_UART, \n    IMX6Q_UART, \n}; \n\n/* device type dependent stuff */ \nstruct imx_uart_data { \n    unsigned uts_reg; \n    enum imx_uart_type devtype; \n}; \n```", "```\nstatic struct imx_uart_data imx_uart_devdata[] = { \n        [IMX1_UART] = { \n                 .uts_reg = IMX1_UTS, \n                 .devtype = IMX1_UART, \n        }, \n        [IMX21_UART] = { \n                .uts_reg = IMX21_UTS, \n                .devtype = IMX21_UART, \n        }, \n        [IMX6Q_UART] = { \n                .uts_reg = IMX21_UTS, \n                .devtype = IMX6Q_UART, \n        }, \n}; \n```", "```\nstatic const struct of_device_idimx_uart_dt_ids[] = { \n        { .compatible = \"fsl,imx6q-uart\", .data = &imx_uart_devdata[IMX6Q_UART], }, \n        { .compatible = \"fsl,imx1-uart\", .data = &imx_uart_devdata[IMX1_UART], }, \n        { .compatible = \"fsl,imx21-uart\", .data = &imx_uart_devdata[IMX21_UART], }, \n        { /* sentinel */ } \n}; \nMODULE_DEVICE_TABLE(of, imx_uart_dt_ids); \n\nstatic struct platform_driver serial_imx_driver = { \n    [...] \n    .driver         = { \n        .name   = \"imx-uart\", \n        .of_match_table = of_match_ptr(imx_uart_dt_ids), \n    }, \n}; \n```", "```\nstatic int imx_probe_dt(struct platform_device *pdev) \n{ \n    struct device_node *np = pdev->dev.of_node; \n    const struct of_device_id *of_id = \n    of_match_device(of_match_ptr(imx_uart_dt_ids), &pdev->dev); \n\n        if (!of_id) \n                /* no device tree device */ \n                return 1; \n        [...] \n        sport->devdata = of_id->data; /* Get private data back  */ \n} \n```", "```\nstatic const struct platform_device_id sdma_devtypes[] = { \n    { \n        .name = \"imx51-sdma\", \n        .driver_data = (unsigned long)&sdma_imx51, \n    }, { \n        .name = \"imx53-sdma\", \n        .driver_data = (unsigned long)&sdma_imx53, \n    }, { \n        .name = \"imx6q-sdma\", \n        .driver_data = (unsigned long)&sdma_imx6q, \n    }, { \n        .name = \"imx7d-sdma\", \n        .driver_data = (unsigned long)&sdma_imx7d, \n    }, { \n        /* sentinel */ \n    } \n}; \nMODULE_DEVICE_TABLE(platform, sdma_devtypes); \n```", "```\nstatic const struct of_device_idsdma_dt_ids[] = { \n    { .compatible = \"fsl,imx6q-sdma\", .data = &sdma_imx6q, }, \n    { .compatible = \"fsl,imx53-sdma\", .data = &sdma_imx53, }, \n       { .compatible = \"fsl,imx51-sdma\", .data = &sdma_imx51, }, \n    { .compatible = \"fsl,imx7d-sdma\", .data = &sdma_imx7d, }, \n    { /* sentinel */ } \n}; \nMODULE_DEVICE_TABLE(of, sdma_dt_ids); \n```", "```\nstatic int sdma_probe(structplatform_device *pdev) \n{ \nconststructof_device_id *of_id = \nof_match_device(of_match_ptr(sdma_dt_ids), &pdev->dev); \nstructdevice_node *np = pdev->dev.of_node; \n\n    /* If devicetree, */ \n    if (of_id) \ndrvdata = of_id->data; \n    /* else, hard-coded */ \n    else if (pdev->id_entry) \ndrvdata = (void *)pdev->id_entry->driver_data; \n\n    if (!drvdata) { \ndev_err(&pdev->dev, \"unable to find driver data\\n\"); \n        return -EINVAL; \n    } \n    [...] \n} \n```", "```\nstatic struct platform_driversdma_driver = { \n    .driver = { \n    .name   = \"imx-sdma\", \n    .of_match_table = of_match_ptr(sdma_dt_ids), \n    }, \n    .id_table  = sdma_devtypes, \n    .remove  = sdma_remove, \n    .probe   = sdma_probe, \n}; \nmodule_platform_driver(sdma_driver); \n```", "```\nuart1: serial@02020000 { \n    compatible = \"fsl,imx6q-uart\", \"fsl,imx21-uart\"; \nreg = <0x02020000 0x4000>; \n    interrupts = <0 26 IRQ_TYPE_LEVEL_HIGH>; \ndmas = <&sdma 25 4 0>, <&sdma 26 4 0>; \ndma-names = \"rx\", \"tx\"; \n}; \n```", "```\nstatic int my_probe(struct platform_device *pdev) \n{ \nstruct iio_dev *indio_dev; \nstruct resource *mem, *dma_res; \nstruct xadc *xadc; \nint irq, ret, dmareq; \n\n    /* irq */ \nirq = platform_get_irq(pdev, 0); \n    if (irq<= 0) \n        return -ENXIO; \n    [...] \n\n    /* memory region */ \nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0); \nxadc->base = devm_ioremap_resource(&pdev->dev, mem); \n    /* \n     * We could have used \n     *      devm_ioremap(&pdev->dev, mem->start, resource_size(mem)); \n     * too. \n     */ \n    if (IS_ERR(xadc->base)) \n        return PTR_ERR(xadc->base); \n    [...] \n\n    /* second dma channel */ \ndma_res = platform_get_resource(pdev, IORESOURCE_DMA, 1); \ndmareq = dma_res->start; \n\n    [...] \n} \n```", "```\nint platform_get_irq(struct platform_device *dev, unsigned int num) \n{ \n    [...] \n    struct resource *r; \n    if (IS_ENABLED(CONFIG_OF_IRQ) &&dev->dev.of_node) { \n        int ret; \n\n        ret = of_irq_get(dev->dev.of_node, num); \n        if (ret > 0 || ret == -EPROBE_DEFER) \n            return ret; \n    } \n\n    r = platform_get_resource(dev, IORESOURCE_IRQ, num); \n    if (r && r->flags & IORESOURCE_BITS) { \n        struct irq_data *irqd; \n        irqd = irq_get_irq_data(r->start); \n        if (!irqd) \n            return -ENXIO; \n        irqd_set_trigger_type(irqd, r->flags & IORESOURCE_BITS); \n    } \n    return r ? r->start : -ENXIO; \n} \n```", "```\nstatic struct platform_device *of_platform_device_create_pdata( \n                 struct device_node *np, const char *bus_id, \n                 void *platform_data, struct device *parent) \n```", "```\n#define SIRFSOC_I2C0MOD_PA_BASE 0xcc0e0000 \n#define SIRFSOC_I2C0MOD_SIZE 0x10000 \n#define IRQ_I2C0 \nstatic struct resource sirfsoc_i2c0_resource[] = { \n    { \n        .start = SIRFSOC_I2C0MOD_PA_BASE, \n        .end = SIRFSOC_I2C0MOD_PA_BASE + SIRFSOC_I2C0MOD_SIZE - 1, \n        .flags = IORESOURCE_MEM, \n    },{ \n        .start = IRQ_I2C0, \n        .end = IRQ_I2C0, \n        .flags = IORESOURCE_IRQ, \n    }, \n}; \n```", "```\ni2c0: i2c@cc0e0000 { \n    compatible = \"sirf,marco-i2c\"; \n    reg = <0xcc0e0000 0x10000>; \n    interrupt-parent = <&phandle_to_interrupt_controller_node> \n    interrupts = <0 24 0>; \n    #address-cells = <1>; \n    #size-cells = <0>; \n    status = \"disabled\"; \n}; \n```"]