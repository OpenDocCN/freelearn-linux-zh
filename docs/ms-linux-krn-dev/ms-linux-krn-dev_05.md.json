["```\nstruct super_block {\n         struct list_head        s_list;   /* Keep this first */\n         dev_t                   s_dev;    /* search index; _not_ kdev_t */\n         unsigned char           s_blocksize_bits;\n         unsigned long           s_blocksize;\n         loff_t                  s_maxbytes;  /* Max file size */\n         struct file_system_type *s_type;\n         const struct super_operations   *s_op;\n         const struct dquot_operations   *dq_op;\n         const struct quotactl_ops       *s_qcop;\n         const struct export_operations *s_export_op;\n         unsigned long           s_flags;\n         unsigned long           s_iflags; /* internal SB_I_* flags */\n         unsigned long           s_magic;\n         struct dentry           *s_root;\n         struct rw_semaphore     s_umount;\n         int                     s_count;\n         atomic_t                s_active;\n #ifdef CONFIG_SECURITY\n         void                    *s_security;\n #endif\n         const struct xattr_handler **s_xattr;\n         const struct fscrypt_operations *s_cop;\n         struct hlist_bl_head    s_anon; \n         struct list_head        s_mounts;/*list of mounts;_not_for fs use*/ \n         struct block_device     *s_bdev;\n         struct backing_dev_info *s_bdi;\n         struct mtd_info         *s_mtd;\n         struct hlist_node       s_instances;\n         unsigned int   s_quota_types; /*Bitmask of supported quota types */\n         struct quota_info  s_dquot;   /* Diskquota specific options */\n         struct sb_writers       s_writers;\n         char s_id[32];                          /* Informational name */\n         u8 s_uuid[16];                          /* UUID */\n         void                    *s_fs_info;   /* Filesystem private info */\n         unsigned int            s_max_links;\n         fmode_t                 s_mode;\n\n         /* Granularity of c/m/atime in ns.\n            Cannot be worse than a second */\n         u32                s_time_gran;\n\n         struct mutex s_vfs_rename_mutex;        /* Kludge */\n\n         /*\n          * Filesystem subtype.  If non-empty the filesystem type field\n          * in /proc/mounts will be \"type.subtype\"\n          */\n         char *s_subtype;\n\n         /*\n          * Saved mount options for lazy filesystems using\n          * generic_show_options()\n          */\n         char __rcu *s_options;\n         const struct dentry_operations *s_d_op; /*default op for dentries*/\n         /*\n          * Saved pool identifier for cleancache (-1 means none)\n          */\n         int cleancache_poolid;\n\n         struct shrinker s_shrink;       /* per-sb shrinker handle */\n\n         /* Number of inodes with nlink == 0 but still referenced */\n         atomic_long_t s_remove_count;\n\n         /* Being remounted read-only */\n         int s_readonly_remount;\n\n         /* AIO completions deferred from interrupt context */\n         struct workqueue_struct *s_dio_done_wq;\n         struct hlist_head s_pins;\n\n         /*\n          * Owning user namespace and default context in which to\n          * interpret filesystem uids, gids, quotas, device nodes,\n          * xattrs and security labels.\n          */\n         struct user_namespace *s_user_ns;\n\n         struct list_lru         s_dentry_lru ____cacheline_aligned_in_smp;\n         struct list_lru         s_inode_lru ____cacheline_aligned_in_smp;\n         struct rcu_head         rcu;\n         struct work_struct      destroy_work;\n\n         struct mutex            s_sync_lock;  /* sync serialisation lock */\n\n         /*\n          * Indicates how deep in a filesystem stack this SB is\n          */\n         int s_stack_depth;\n\n         /* s_inode_list_lock protects s_inodes */\n         spinlock_t              s_inode_list_lock ____cacheline_aligned_in_smp;\n         struct list_head        s_inodes;       /* all inodes */\n\n         spinlock_t              s_inode_wblist_lock;\n         struct list_head        s_inodes_wb;    /* writeback inodes */\n };\n```", "```\nstruct super_operations {\n         struct inode *(*alloc_inode)(struct super_block *sb);\n         void (*destroy_inode)(struct inode *);\n\n         void (*dirty_inode) (struct inode *, int flags);\n         int (*write_inode) (struct inode *, struct writeback_control *wbc);\n         int (*drop_inode) (struct inode *);\n         void (*evict_inode) (struct inode *);\n         void (*put_super) (struct super_block *);\n         int (*sync_fs)(struct super_block *sb, int wait);\n         int (*freeze_super) (struct super_block *);\n         int (*freeze_fs) (struct super_block *);\n         int (*thaw_super) (struct super_block *);\n         int (*unfreeze_fs) (struct super_block *);\n         int (*statfs) (struct dentry *, struct kstatfs *);\n         int (*remount_fs) (struct super_block *, int *, char *);\n         void (*umount_begin) (struct super_block *);\n\n         int (*show_options)(struct seq_file *, struct dentry *);\n         int (*show_devname)(struct seq_file *, struct dentry *);\n         int (*show_path)(struct seq_file *, struct dentry *);\n         int (*show_stats)(struct seq_file *, struct dentry *);\n #ifdef CONFIG_QUOTA\n         ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);\n         ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);\n         struct dquot **(*get_dquots)(struct inode *);\n #endif\n         int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);\n         long (*nr_cached_objects)(struct super_block *,\n                                   struct shrink_control *);\n         long (*free_cached_objects)(struct super_block *,\n                                     struct shrink_control *);\n };\n```", "```\nstruct inode {\n      umode_t                 i_mode;\n   unsigned short          i_opflags;\n        kuid_t                  i_uid;\n    kgid_t                  i_gid;\n    unsigned int            i_flags;\n#ifdef CONFIG_FS_POSIX_ACL\n  struct posix_acl        *i_acl;\n   struct posix_acl        *i_default_acl;\n#endif\n       const struct inode_operations   *i_op;\n    struct super_block      *i_sb;\n    struct address_space    *i_mapping;\n#ifdef CONFIG_SECURITY\n   void                    *i_security;\n#endif\n  /* Stat data, not accessed from path walking */\n   unsigned long           i_ino;\n    /*\n         * Filesystems may only read i_nlink directly.  They shall use the\n         * following functions for modification:\n   *\n         *    (set|clear|inc|drop)_nlink\n   *    inode_(inc|dec)_link_count\n   */\n       union {\n           const unsigned int i_nlink;\n               unsigned int __i_nlink;\n   };\n        dev_t                   i_rdev;\n   loff_t                  i_size;\n   struct timespec         i_atime;\n  struct timespec         i_mtime;\n  struct timespec         i_ctime;\n  spinlock_t              i_lock; /*i_blocks, i_bytes, maybe i_size*/\n       unsigned short          i_bytes;\n  unsigned int            i_blkbits;\n        blkcnt_t                i_blocks;\n#ifdef __NEED_I_SIZE_ORDERED\n       seqcount_t              i_size_seqcount;\n#endif\n      /* Misc */\n        unsigned long           i_state;\n  struct rw_semaphore     i_rwsem;\n\n    unsigned long           dirtied_when;/*jiffies of first dirtying */\n       unsigned long           dirtied_time_when;\n\n  struct hlist_node       i_hash;\n   struct list_head        i_io_list;/* backing dev IO list */\n#ifdef CONFIG_CGROUP_WRITEBACK\n   struct bdi_writeback    *i_wb;  /* the associated cgroup wb */\n\n      /* foreign inode detection, see wbc_detach_inode() */\n     int                     i_wb_frn_winner;\n  u16                     i_wb_frn_avg_time;\n        u16                     i_wb_frn_history;\n#endif\n     struct list_head        i_lru;  /* inode LRU list */\n      struct list_head        i_sb_list;\n        struct list_head        i_wb_list;/* backing dev writeback list */\n        union {\n           struct hlist_head       i_dentry;\n         struct rcu_head         i_rcu;\n    };\n        u64                     i_version;\n        atomic_t                i_count;\n  atomic_t                i_dio_count;\n      atomic_t                i_writecount;\n#ifdef CONFIG_IMA\n      atomic_t                i_readcount; /* struct files open RO */\n#endif\n/* former->i_op >default_file_ops */\n       const struct file_operations  *i_fop; \n       struct file_lock_context *i_flctx; \n       struct address_space i_data; \n       struct list_head i_devices; \n       union { \n          struct pipe_inode_info *i_pipe; \n          struct block_device *i_bdev; \n          struct cdev *i_cdev; \n          char *i_link; \n          unsigned i_dir_seq; \n       }; \n      __u32 i_generation; \n #ifdef CONFIG_FSNOTIFY __u32 i_fsnotify_mask; /* all events this inode cares about */ \n     struct hlist_head i_fsnotify_marks; \n#endif \n#if IS_ENABLED(CONFIG_FS_ENCRYPTION) \n    struct fscrypt_info *i_crypt_info; \n#endif \n    void *i_private; /* fs or device private pointer */ \n};\n```", "```\nstruct inode_operations {\n struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);\n const char * (*get_link) (struct dentry *, struct inode *, struct delayed_call *);\n int (*permission) (struct inode *, int);\n struct posix_acl * (*get_acl)(struct inode *, int);\n int (*readlink) (struct dentry *, char __user *,int);\n int (*create) (struct inode *,struct dentry *, umode_t, bool);\n int (*link) (struct dentry *,struct inode *,struct dentry *);\n int (*unlink) (struct inode *,struct dentry *);\n int (*symlink) (struct inode *,struct dentry *,const char *);\n int (*mkdir) (struct inode *,struct dentry *,umode_t);\n int (*rmdir) (struct inode *,struct dentry *);\n int (*mknod) (struct inode *,struct dentry *,umode_t,dev_t);\n int (*rename) (struct inode *, struct dentry *,\n struct inode *, struct dentry *, unsigned int);\n int (*setattr) (struct dentry *, struct iattr *);\n int (*getattr) (struct vfsmount *mnt, struct dentry *, struct kstat *);\n ssize_t (*listxattr) (struct dentry *, char *, size_t);\n int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64 start,\n u64 len);\n int (*update_time)(struct inode *, struct timespec *, int);\n int (*atomic_open)(struct inode *, struct dentry *,\n struct file *, unsigned open_flag,\n umode_t create_mode, int *opened);\n int (*tmpfile) (struct inode *, struct dentry *, umode_t);\n int (*set_acl)(struct inode *, struct posix_acl *, int);\n} ____cacheline_aligned\n```", "```\nstruct file_operations {\n struct module *owner;\n loff_t (*llseek) (struct file *, loff_t, int);\n ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\n ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\n ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);\n ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);\n int (*iterate) (struct file *, struct dir_context *);\n int (*iterate_shared) (struct file *, struct dir_context *);\n unsigned int (*poll) (struct file *, struct poll_table_struct *);\n long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\n long (*compat_ioctl) (struct file *, unsigned int, unsigned long);\n int (*mmap) (struct file *, struct vm_area_struct *);\n int (*open) (struct inode *, struct file *);\n int (*flush) (struct file *, fl_owner_t id);\n int (*release) (struct inode *, struct file *);\n int (*fsync) (struct file *, loff_t, loff_t, int datasync);\n int (*fasync) (int, struct file *, int);\n int (*lock) (struct file *, int, struct file_lock *);\n ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);\n unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);\n int (*check_flags)(int);\n int (*flock) (struct file *, int, struct file_lock *);\n ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);\n ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);\n int (*setlease)(struct file *, long, struct file_lock **, void **);\n long (*fallocate)(struct file *file, int mode, loff_t offset,\n loff_t len);\n void (*show_fdinfo)(struct seq_file *m, struct file *f);\n#ifndef CONFIG_MMU\n unsigned (*mmap_capabilities)(struct file *);\n#endif\n ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,\n loff_t, size_t, unsigned int);\n int (*clone_file_range)(struct file *, loff_t, struct file *, loff_t,\n u64);\n ssize_t (*dedupe_file_range)(struct file *, u64, u64, struct file *,\n u64);\n};\n```", "```\nstruct dentry {\n /* RCU lookup touched fields */\n   unsigned int d_flags;           /* protected by d_lock */\n seqcount_t d_seq;               /* per dentry seqlock */\n  struct hlist_bl_node d_hash;    /* lookup hash list */\n    struct dentry *d_parent;        /* parent directory */\n    struct qstr d_name;\n       struct inode *d_inode; /* Where the name -NULL is negative */\n     unsigned char d_iname[DNAME_INLINE_LEN];        /* small names */\n\n   /* Ref lookup also touches following */\n   struct lockref d_lockref;       /* per-dentry lock and refcount */\n        const struct dentry_operations *d_op;\n     struct super_block *d_sb;       /* The root of the dentry tree */\n unsigned long d_time;           /* used by d_revalidate */\n        void *d_fsdata;                 /* fs-specific data */\n\n      union {\n           struct list_head d_lru;         /* LRU list */\n            wait_queue_head_t *d_wait;      /* in-lookup ones only */\n };\n        struct list_head d_child;       /* child of parent list */\n        struct list_head d_subdirs;     /* our children */\n        /*\n         * d_alias and d_rcu can share memory\n      */\n       union {\n           struct hlist_node d_alias;      /* inode alias list */\n            struct hlist_bl_node d_in_lookup_hash;  \n          struct rcu_head d_rcu;\n    } d_u;\n};\n```", "```\nstruct dentry_operations {\n int (*d_revalidate)(struct dentry *, unsigned int);\n       int (*d_weak_revalidate)(struct dentry *, unsigned int);\n  int (*d_hash)(const struct dentry *, struct qstr *);\n      int (*d_compare)(const struct dentry *,\n                   unsigned int, const char *, const struct qstr *);\n int (*d_delete)(const struct dentry *);\n   int (*d_init)(struct dentry *);\n   void (*d_release)(struct dentry *);\n       void (*d_prune)(struct dentry *);\n void (*d_iput)(struct dentry *, struct inode *);\n  char *(*d_dname)(struct dentry *, char *, int);\n   struct vfsmount *(*d_automount)(struct path *);\n   int (*d_manage)(const struct path *, bool);\n       struct dentry *(*d_real)(struct dentry *, const struct inode *,\n                            unsigned int);\n\n} ____ca\n```", "```\nstruct file {\n       union {\n           struct llist_node       fu_llist;\n         struct rcu_head         fu_rcuhead;\n       } f_u;\n    struct path             f_path;\n   struct inode            *f_inode;       /* cached value */\n        const struct file_operations    *f_op;\n\n      /*\n         * Protects f_ep_links, f_flags.\n   * Must not be taken from IRQ context.\n     */\n       spinlock_t              f_lock;\n   atomic_long_t           f_count;\n  unsigned int            f_flags;\n  fmode_t                 f_mode;\n   struct mutex            f_pos_lock;\n       loff_t                  f_pos;\n    struct fown_struct      f_owner;\n  const struct cred       *f_cred;\n  struct file_ra_state    f_ra;\n\n       u64                     f_version;\n#ifdef CONFIG_SECURITY\n    void                    *f_security;\n#endif\n  /* needed for tty driver, and maybe others */\n     void                    *private_data;\n\n#ifdef CONFIG_EPOLL\n     /* Used by fs/eventpoll.c to link all the hooks to this file */\n   struct list_head        f_ep_links;\n       struct list_head        f_tfile_llink;\n#endif /* #ifdef CONFIG_EPOLL */\n      struct address_space    *f_mapping;\n} __attribute__((aligned(4))); /* lest something weird decides that 2 is OK */\n```"]