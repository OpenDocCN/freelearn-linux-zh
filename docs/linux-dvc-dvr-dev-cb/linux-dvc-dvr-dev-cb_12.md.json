["```\nssize_t (*read) (struct file *filp,\n                 char __user *buf, size_t len, loff_t *ppos);\nssize_t (*write) (struct file *filp,\n                 const char __user *buff, size_t len, loff_t *ppos);\n```", "```\n--- a/chapter_03/chrdev_test.c\n+++ b/chapter_03/chrdev_test.c\n@@ -55,6 +55,16 @@ int main(int argc, char *argv[])\n       dump(\"data written are: \", buf, n);\n   }\n\n+  close(fd);\n+\n+  ret = open(argv[1], O_RDWR);\n+  if (ret < 0) {\n+      perror(\"open\");\n+      exit(EXIT_FAILURE);\n+  }\n+  printf(\"file %s reopened\\n\", argv[1]);\n+  fd = ret;\n+\n   for (c = 0; c < sizeof(buf); c += n) {\n       ret = read(fd, buf, sizeof(buf));\n       if (ret == 0) {\n```", "```\noff_t lseek(int fd, off_t offset, int whence);\n```", "```\n  SEEK_SET\n      The file offset is set to offset bytes.\n\n  SEEK_CUR\n      The file offset is set to its current location plus offset\n      bytes.\n\n  SEEK_END\n      The file offset is set to the size of the file plus offset\n      bytes.\n```", "```\n--- a/chapter_03/chrdev_test.c\n+++ b/chapter_03/chrdev_test.c\n@@ -55,6 +55,13 @@ int main(int argc, char *argv[])\n        dump(\"data written are: \", buf + c, n);\n    }\n\n+  ret = lseek(fd, SEEK_SET, 0);\n+  if (ret < 0) {\n+       perror(\"lseek\");\n+       exit(EXIT_FAILURE);\n+  }\n+  printf(\"*ppos moved to 0\\n\");\n+\n   for (c = 0; c < sizeof(buf); c += n) {\n       ret = read(fd, buf, sizeof(buf));\n       if (ret == 0) {\n```", "```\n\n#define SEEK_SET    0 /* seek relative to beginning of file */\n#define SEEK_CUR    1 /* seek relative to current file position */\n#define SEEK_END    2 /* seek relative to end of file */\n```", "```\nloff_t default_llseek(struct file *file,\n                      loff_t offset, int whence);\n```", "```\n/**\n * noop_llseek - No Operation Performed llseek implementation\n * @file: file structure to seek on\n * @offset: file offset to seek to\n * @whence: type of seek\n *\n * This is an implementation of ->llseek useable for the rare special case when\n * userspace expects the seek to succeed but the (device) file is actually not\n * able to perform the seek. In this case you use noop_llseek() instead of\n * falling back to the default implementation of ->llseek.\n */\nloff_t noop_llseek(struct file *file, loff_t offset, int whence)\n{\n    return file->f_pos;\n}\n```", "```\nloff_t no_llseek(struct file *file, loff_t offset, int whence)\n{\n    return -ESPIPE;\n}\n```", "```\nstatic const struct file_operations chrdev_fops = {\n    .owner   = THIS_MODULE,\n    .llseek  = no_llseek,\n    .read    = chrdev_read,\n    .write   = chrdev_write,\n    .open    = chrdev_open,\n    .release = chrdev_release\n};\n```", "```\nSYNOPSIS\n   #include <sys/ioctl.h>\n\n   int ioctl(int fd, unsigned long request, ...);\n\nDESCRIPTION\n   The ioctl() system call manipulates the underlying device parameters of special files. In particular, many operating characteristics of character special files (e.g., terminals) may be controlled with ioctl() requests.\n```", "```\n/*\n * Used to create numbers.\n *\n * NOTE: _IOW means userland is writing and kernel is reading. _IOR\n * means userland is reading and kernel is writing.\n */\n#define _IO(type,nr)            _IOC(_IOC_NONE,(type),(nr),0)\n#define _IOR(type,nr,size)      _IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))\n#define _IOW(type,nr,size)      _IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))\n#define _IOWR(type,nr,size)     _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))\n```", "```\n#include <linux/ioctl.h>\n#include <linux/types.h>\n\n#define WATCHDOG_IOCTL_BASE 'W'\n\nstruct watchdog_info {\n    __u32 options;          /* Options the card/driver supports */\n    __u32 firmware_version; /* Firmware version of the card */\n    __u8 identity[32];      /* Identity of the board */\n};\n\n#define WDIOC_GETSUPPORT    _IOR(WATCHDOG_IOCTL_BASE, 0, struct watchdog_info)\n#define WDIOC_GETSTATUS     _IOR(WATCHDOG_IOCTL_BASE, 1, int)\n#define WDIOC_GETBOOTSTATUS _IOR(WATCHDOG_IOCTL_BASE, 2, int)\n#define WDIOC_GETTEMP       _IOR(WATCHDOG_IOCTL_BASE, 3, int)\n#define WDIOC_SETOPTIONS    _IOR(WATCHDOG_IOCTL_BASE, 4, int)\n#define WDIOC_KEEPALIVE     _IOR(WATCHDOG_IOCTL_BASE, 5, int)\n#define WDIOC_SETTIMEOUT    _IOWR(WATCHDOG_IOCTL_BASE, 6, int)\n#define WDIOC_GETTIMEOUT    _IOR(WATCHDOG_IOCTL_BASE, 7, int)\n#define WDIOC_SETPRETIMEOUT _IOWR(WATCHDOG_IOCTL_BASE, 8, int)\n#define WDIOC_GETPRETIMEOUT _IOR(WATCHDOG_IOCTL_BASE, 9, int)\n#define WDIOC_GETTIMELEFT   _IOR(WATCHDOG_IOCTL_BASE, 10, int)\n```", "```\nstruct file_operations {\n...\n    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\n    long (*compat_ioctl) (struct file *, unsigned int, unsigned long);\n```", "```\n#ifdef __KERNEL__\n  /* This is code for kernel space */\n  ...\n#else\n  /* This is code for user space */\n  ...\n#endif\n```", "```\nNAME\n   mmap, munmap - map or unmap files or devices into memory\n\nSYNOPSIS\n   #include <sys/mman.h>\n\n   void *mmap(void *addr, size_t length, int prot, int flags,\n                  int fd, off_t offset);\n   int munmap(void *addr, size_t length);\n\nDESCRIPTION\n   mmap() creates a new mapping in the virtual address space of the call\u2010\n   ing process. The starting address for the new mapping is specified in\n   addr. The length argument specifies the length of the mapping (which\n   must be greater than 0).\n```", "```\n$ cat textfile.txt \nThis is a test file\n\nThis is line 3.\n\nEnd of the file\n```", "```\n    ret = open(argv[1], O_RDWR);\n    if (ret < 0) {\n        perror(\"open\");\n        exit(EXIT_FAILURE);\n    }\n    printf(\"file %s opened\\n\", argv[1]);\n    fd = ret;\n\n    /* Try to remap file into memory */\n    addr = mmap(NULL, len, PROT_READ | PROT_WRITE,\n                MAP_FILE | MAP_SHARED, fd, 0);\n    if (addr == MAP_FAILED) {\n        perror(\"mmap\");\n        exit(EXIT_FAILURE);\n    }\n\n    ptr = (char *) addr;\n    for (i = 0; i < len; i++)\n        printf(\"%c\", ptr[i]);\n```", "```\n# ls -l textfile.txt \n-rw-r--r-- 1 root root 54 May 11 16:41 textfile.txt\n# ./chrdev_mmap textfile.txt 54 \nfile textfile.txt opened\ngot address=0xffff8357b000 and len=54\n---\nThis is a test file\n\nThis is line 3.\n\nEnd of the file\n```", "```\nstruct file_operations {\n...\n        int (*mmap) (struct file *, struct vm_area_struct *);\n```", "```\nint remap_pfn_range(structure vm_area_struct *vma,\n                    unsigned long addr,\n                    unsigned long pfn, unsigned long size,\n                    pgprot_t prot);\n```", "```\nstatic int my_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n    struct my_device *my_ptr = filp->private_data;\n    size_t size = vma->vm_end - vma->vm_start;\n    phys_addr_t offset = (phys_addr_t) vma->vm_pgoff << PAGE_SHIFT;\n    unsigned long pfn;\n\n    /* Does it even fit in phys_addr_t? */\n    if (offset >> PAGE_SHIFT != vma->vm_pgoff)\n        return -EINVAL;\n\n    /* We cannot mmap too big areas */\n    if ((offset > my_ptr->area_len) ||\n        (size > my_ptr->area_len - offset))\n        return -EINVAL;\n\n    /* Remap-pfn-range will mark the range VM_IO */\n    if (remap_pfn_range(vma, vma->vm_start,\n                        my_ptr->base_addr, size,\n                        vma->vm_page_prot))\n        return -EAGAIN;\n\n    return 0;\n}\n```", "```\nunsigned long pfn = virt_to_phys(kvirt) >> PAGE_SHIFT;\n```", "```\nunsigned long pfn = vmalloc_to_pfn(vvirt);\n```", "```\nfd1 = open(\"/dev/device1\", ...);\nfd2 = open(\"/dev/device2\", ...);\nfd3 = open(\"/dev/device3\", ...);\n\nwhile (1) {\n    read(fd1, buf1, size1);\n    read(fd2, buf2, size2);\n    read(fd3, buf3, size3);\n\n    /* Now use data from peripherals */\n    ...\n}\n```", "```\nNAME\n   poll, ppoll - wait for some event on a file descriptor\n\nSYNOPSIS\n   #include <poll.h>\n\n   int poll(struct pollfd *fds, nfds_t nfds, int timeout);\n\n   #define _GNU_SOURCE /* See feature_test_macros(7) */\n   #include <signal.h>\n   #include <poll.h>\n\n   int ppoll(struct pollfd *fds, nfds_t nfds,\n           const struct timespec *tmo_p, const sigset_t *sigmask);\n```", "```\nNAME\n  select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO - synchronous I/O\n   multiplexing\n\nSYNOPSIS\n   /* According to POSIX.1-2001, POSIX.1-2008 */\n   #include <sys/select.h>\n\n   /* According to earlier standards */\n   #include <sys/time.h>\n   #include <sys/types.h>\n   #include <unistd.h>\n\n   int select(int nfds, fd_set *readfds, fd_set *writefds,\n              fd_set *exceptfds, struct timeval *timeout);\n\n   void FD_CLR(int fd, fd_set *set);\n   int FD_ISSET(int fd, fd_set *set);\n   void FD_SET(int fd, fd_set *set);\n   void FD_ZERO(fd_set *set);\n```", "```\nstruct file_operations {\n...\n    __poll_t (*poll) (struct file *, struct poll_table_struct *);\n```", "```\nstatic __poll_t simple_poll(struct file *filp, poll_table *wait)\n{\n    struct simple_device *chrdev = filp->private_data;\n    __poll_t mask = 0;\n\n    poll_wait(filp, &simple_device->queue, wait);\n\n    if (has_data_to_read(simple_device))\n        mask |= EPOLLIN | EPOLLRDNORM;\n\n    if (has_space_to_write(simple_device))\n        mask |= EPOLLOUT | EPOLLWRNORM;\n\n    return mask;\n}\n```", "```\nfd_set read_fds;\n\nfd1 = open(\"/dev/device1\", ...);\nfd2 = open(\"/dev/device2\", ...);\nfd3 = open(\"/dev/device3\", ...);\n\nwhile (1) {\n    FD_ZERO(&read_fds);\n    FD_SET(fd1, &read_fds);\n    FD_SET(fd2, &read_fds);\n    FD_SET(fd2, &read_fds);\n\n    select(FD_SETSIZE, &read_fds, NULL, NULL, NULL);\n\n    if (FD_ISSET(fd1, &read_fds))\n        read(fd1, buf1, size1);\n    if (FD_ISSET(fd2, &read_fds))\n        read(fd2, buf2, size2);\n    if (FD_ISSET(fd3, &read_fds))\n        read(fd3, buf3, size3);\n\n    /* Now use data from peripherals */\n    ...\n}\n```", "```\nNAME\n   fcntl - manipulate file descriptor\n\nSYNOPSIS\n   #include <unistd.h>\n   #include <fcntl.h>\n\n   int fcntl(int fd, int cmd, ... /* arg */ );\n\n...\n\n   F_SETOWN (int)\n          Set the process ID or process group ID that will receive SIGIO\n          and SIGURG signals for events on the file descriptor fd. The\n          target process or process group ID is specified in arg. A\n          process ID is specified as a positive value; a process group ID\n          is specified as a negative value. Most commonly, the calling\n          process specifies itself as the owner (that is, arg is specified\n          as getpid(2)).\n```", "```\nstruct file_operations {\n...\n    int (*fsync) (struct file *, loff_t, loff_t, int datasync);\n```", "```\nstatic int simple_fasync(int fd, struct file *filp, int on)\n{\n    struct simple_device *simple = filp->private_data;\n\n    return fasync_helper(fd, filp, on, &simple->fasync_queue);\n}\n```", "```\nkill_fasync(&simple->fasync_queue, SIGIO, POLL_IN);\n```", "```\nlong flags;\n\nfd = open(\"/dev/device\", ...);\n\nsignal(SIGIO, sigio_handler);\n\nfcntl(fd, F_SETOWN, getpid());\n\nflags = fcntl(fd, F_GETFL);\n\nfcntl(fd, F_SETFL, flags | FASYNC);\n```"]