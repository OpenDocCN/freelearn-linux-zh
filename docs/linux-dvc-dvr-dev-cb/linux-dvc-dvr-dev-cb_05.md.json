["```\nstatic int irq = -1;\n\nstatic irqreturn_t dummy_interrupt(int irq, void *dev_id)\n{\n    static int count = 0;\n\n    if (count == 0) {\n        printk(KERN_INFO \"dummy-irq: interrupt occurred on IRQ %d\\n\",\n                irq);\n        count++;\n    }\n\n    return IRQ_NONE;\n}\n```", "```\nstatic int __init dummy_irq_init(void)\n{\n    if (irq < 0) {\n        printk(KERN_ERR \"dummy-irq: no IRQ given. Use irq=N\\n\");\n        return -EIO;\n    }\n    if (request_irq(irq, &dummy_interrupt, IRQF_SHARED, \"dummy_irq\", &irq)) {\n        printk(KERN_ERR \"dummy-irq: cannot register IRQ %d\\n\", irq);\n        return -EIO;\n    }\n    printk(KERN_INFO \"dummy-irq: registered for IRQ %d\\n\", irq);\n    return 0;\n}\n\nstatic void __exit dummy_irq_exit(void)\n{\n    printk(KERN_INFO \"dummy-irq unloaded\\n\");\n    free_irq(irq, &irq);\n}\n```", "```\n$ rgrep CONFIG_GPIO_SYSFS .config\nCONFIG_GPIO_SYSFS=y\n```", "```\n$ rgrep CONFIG_GPIO_SYSFS .config\n# CONFIG_GPIO_SYSFS is not set\n```", "```\n# ls /sys/class/gpio/\nexport  gpiochip446  gpiochip476  unexport\n```", "```\n# ls -l /sys/class/gpio/gpiochip4*\nlrwxrwxrwx 1 root root 0 Mar 7 20:20 /sys/class/gpio/gpiochip446 ->\n  ../../devices/platform/soc/soc:internal-regs@d0000000/d0018800.pinctrl/gpio/gpiochip446\nlrwxrwxrwx 1 root root 0 Mar 7 20:20 /sys/class/gpio/gpiochip476 ->\n  ../../devices/platform/soc/soc:internal-regs@d0000000/d0013800.pinctrl/gpio/gpiochip476\n```", "```\n# cat /sys/class/gpio/gpiochip446/base \n446\n# echo 466 > /sys/class/gpio/export \n```", "```\n# ls /sys/class/gpio/ \nexport  gpio466  gpiochip446  gpiochip476  unexport\n```", "```\n# ls /sys/class/gpio/gpio466/\nactive_low device direction edge power subsystem uevent value\n```", "```\ncat /sys/class/gpio/gpio466/value \n1\n```", "```\n# cat /sys/class/gpio/gpio466/value \n0\n```", "```\n    irqtest {\n        compatible = \"ldddc,irqtest\";\n\n        gpios = <&gpiosb 20 GPIO_ACTIVE_LOW>;\n    };\n```", "```\nstatic const struct of_device_id irqtest_dt_ids[] = {\n    { .compatible = \"ldddc,irqtest\", },\n    { /* sentinel */ }\n};\nMODULE_DEVICE_TABLE(of, irqtest_dt_ids);\n\nstatic struct platform_driver irqtest_driver = {\n    .probe = irqtest_probe,\n    .remove = irqtest_remove,\n    .driver = {\n        .name = \"irqtest\",\n        .of_match_table = irqtest_dt_ids,\n    },\n};\n\nmodule_platform_driver(irqtest_driver);\n```", "```\nstatic int irqtest_probe(struct platform_device *pdev)\n{\n    struct device *dev = &pdev->dev;\n    struct device_node *np = dev->of_node;\n    int ret;\n\n    /* Read gpios property (just the first entry) */\n    ret = of_get_gpio(np, 0); \n    if (ret < 0) {\n        dev_err(dev, \"failed to get GPIO from device tree\\n\");\n        return ret;\n    }\n    irqinfo.pin = ret;\n    dev_info(dev, \"got GPIO %u from DTS\\n\", irqinfo.pin);\n```", "```\n    /* Now request the GPIO and set the line as an input */\n    ret = devm_gpio_request(dev, irqinfo.pin, \"irqtest\");\n    if (ret) {\n        dev_err(dev, \"failed to request GPIO %u\\n\", irqinfo.pin);\n        return ret;\n    }\n    ret = gpio_direction_input(irqinfo.pin);\n    if (ret) {\n        dev_err(dev, \"failed to set pin input direction\\n\");\n        return -EINVAL;\n    }\n\n    /* Now ask to the kernel to convert GPIO line into an IRQ line */\n    ret = gpio_to_irq(irqinfo.pin);\n    if (ret < 0) {\n        dev_err(dev, \"failed to map GPIO to IRQ!\\n\");\n        return -EINVAL;\n    }\n    irqinfo.irq = ret;\n    dev_info(dev, \"GPIO %u correspond to IRQ %d\\n\",\n                irqinfo.pin, irqinfo.irq);\n```", "```\n    ret = gpio_direction_input(irqinfo.pin);\n    if (ret) {\n        dev_err(dev, \"failed to set pin input direction\\n\");\n        return -EINVAL;\n    }\n\n    /* Now ask to the kernel to convert GPIO line into an IRQ line */\n    ret = gpio_to_irq(irqinfo.pin);\n    if (ret < 0) {\n        dev_err(dev, \"failed to map GPIO to IRQ!\\n\");\n        return -EINVAL;\n    }\n    irqinfo.irq = ret;\n    dev_info(dev, \"GPIO %u correspond to IRQ %d\\n\",\n                irqinfo.pin, irqinfo.irq);\n```", "```\nextern int __must_check\nrequest_threaded_irq(unsigned int irq, irq_handler_t handler,\n            irq_handler_t thread_fn,\n            unsigned long flags, const char *name, void *dev);\n\nstatic inline int __must_check\nrequest_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,\n            const char *name, void *dev)\n{\n    return request_threaded_irq(irq, handler, NULL, flags, name, dev);\n}\n\nextern int __must_check\nrequest_any_context_irq(unsigned int irq, irq_handler_t handler,\n            unsigned long flags, const char *name, void *dev_id);\n```", "```\nstatic irqreturn_t irqtest_interrupt(int irq, void *dev_id)\n{\n    struct irqtest_data *info = dev_id;\n    struct device *dev = info->dev;\n\n    dev_info(dev, \"interrupt occurred on IRQ %d\\n\", irq);\n\n    return IRQ_HANDLED;\n}\n```", "```\n    pinctrl_sb: pinctrl@18800 {\n        compatible = \"marvell,armada3710-sb-pinctrl\",\n                 \"syscon\", \"simple-mfd\";\n        reg = <0x18800 0x100>, <0x18C00 0x20>;\n        /* MPP2[23:0] */\n        gpiosb: gpio {\n            #gpio-cells = <2>;\n            gpio-ranges = <&pinctrl_sb 0 0 30>;\n            gpio-controller;\n            interrupt-controller;\n            #interrupt-cells = <2>;\n            interrupts =\n            <GIC_SPI 160 IRQ_TYPE_LEVEL_HIGH>,\n            <GIC_SPI 159 IRQ_TYPE_LEVEL_HIGH>,\n            <GIC_SPI 158 IRQ_TYPE_LEVEL_HIGH>,\n            <GIC_SPI 157 IRQ_TYPE_LEVEL_HIGH>,\n            <GIC_SPI 156 IRQ_TYPE_LEVEL_HIGH>;\n        };\n   ...\n```", "```\nstatic struct irqtest_data {\n    int irq;\n    unsigned int pin;\n    struct device *dev;\n} irqinfo;\n```", "```\n/*\n * These correspond to the IORESOURCE_IRQ_* defines in\n * linux/ioport.h to select the interrupt line behaviour. When\n * requesting an interrupt without specifying a IRQF_TRIGGER, the\n * setting should be assumed to be \"as already configured\", which\n * may be as per machine or firmware initialisation.\n */\n#define IRQF_TRIGGER_NONE 0x00000000\n#define IRQF_TRIGGER_RISING 0x00000001\n#define IRQF_TRIGGER_FALLING 0x00000002\n#define IRQF_TRIGGER_HIGH 0x00000004\n#define IRQF_TRIGGER_LOW 0x00000008\n...\n/*\n * IRQF_SHARED - allow sharing the irq among several devices\n * IRQF_ONESHOT - Interrupt is not reenabled after the hardirq handler finished.\n * Used by threaded interrupts which need to keep the\n * irq line disabled until the threaded handler has been run.\n * IRQF_NO_SUSPEND - Do not disable this IRQ during suspend. Does not guarantee\n * that this interrupt will wake the system from a suspended\n * state. See Documentation/power/suspend-and-interrupts.txt\n */\n```", "```\n/**\n * enum irqreturn\n * @IRQ_NONE interrupt was not from this device or was not handled\n * @IRQ_HANDLED interrupt was handled by this device\n * @IRQ_WAKE_THREAD handler requests to wake the handler thread\n */\n```", "```\nSimple IRQ test (IRQTEST_CODE) [N/m/y/?] (NEW)\n```", "```\nirqtest irqtest: got GPIO 466 from DTS\nirqtest irqtest: GPIO 466 correspond to IRQ 40\nirqtest irqtest: interrupt handler for IRQ 40 is now ready!\n```", "```\n# grep irqtest /proc/interrupts \n 40:     0     0     GPIO2   20   Edge   irqtest\n```", "```\n# head -4 /proc/interrupts \n           CPU0   CPU1 \n  1:          0      0   GICv3   25   Level   vgic\n  3:       5944  20941   GICv3   30   Level   arch_timer\n  4:          0      0   GICv3   27   Level   kvm guest timer\n...\n```", "```\nirqtest irqtest: interrupt occurred on IRQ 40\n```", "```\n# echo 466 > /sys/class/gpio/export \n-bash: echo: write error: Device or resource busy\n```", "```\n--- a/drivers/misc/irqtest.c\n+++ b/drivers/misc/irqtest.c\n@@ -26,9 +26,19 @@ static struct irqtest_data {\n } irqinfo;\n\n /*\n- * The interrupt handler\n+ * The interrupt handlers\n  */\n\n+static void irqtest_tasklet_handler(unsigned long flag)\n+{\n+     struct irqtest_data *info = (struct irqtest_data *) flag;\n+     struct device *dev = info->dev;\n+\n+     dev_info(dev, \"tasklet executed after IRQ %d\", info->irq);\n+}\n+DECLARE_TASKLET(irqtest_tasklet, irqtest_tasklet_handler,\n+                   (unsigned long) &irqinfo);\n+\n static irqreturn_t irqtest_interrupt(int irq, void *dev_id)\n {\n      struct irqtest_data *info = dev_id;\n@@ -36,6 +46,8 @@ static irqreturn_t irqtest_interrupt(int irq, void *dev_id)\n\n      dev_info(dev, \"interrupt occurred on IRQ %d\\n\", irq);\n\n+     tasklet_schedule(&irqtest_tasklet);\n+\n      return IRQ_HANDLED;\n }\n\n@@ -98,6 +110,7 @@ static int irqtest_remove(struct platform_device *pdev)\n {\n      struct device *dev = &pdev->dev;\n\n+     tasklet_kill(&irqtest_tasklet);\n      free_irq(irqinfo.irq, &irqinfo);\n      dev_info(dev, \"IRQ %d is now unmanaged!\\n\", irqinfo.irq);\n```", "```\n--- a/drivers/misc/irqtest.c\n+++ b/drivers/misc/irqtest.c\n@@ -23,12 +23,21 @@ static struct irqtest_data {\n      int irq;\n      unsigned int pin;\n      struct device *dev;\n+     struct tasklet_struct task;\n } irqinfo;\n\n /*\n- * The interrupt handler\n+ * The interrupt handlers\n  */\n\n+static void irqtest_tasklet_handler(unsigned long flag)\n+{\n+     struct irqtest_data *info = (struct irqtest_data *) flag;\n+     struct device *dev = info->dev;\n+\n+     dev_info(dev, \"tasklet executed after IRQ %d\", info->irq);\n+}\n+\n static irqreturn_t irqtest_interrupt(int irq, void *dev_id)\n {\n      struct irqtest_data *info = dev_id;\n@@ -36,6 +45,8 @@ static irqreturn_t irqtest_interrupt(int irq, void *dev_id)\n\n      dev_info(dev, \"interrupt occurred on IRQ %d\\n\", irq);\n\n+     tasklet_schedule(&info->task);\n+\n      return IRQ_HANDLED;\n }\n\n@@ -80,6 +91,10 @@ static int irqtest_probe(struct platform_device *pdev)\n      dev_info(dev, \"GPIO %u correspond to IRQ %d\\n\",\n                                irqinfo.pin, irqinfo.irq);\n```", "```\n+     /* Create our tasklet */\n+     tasklet_init(&irqinfo.task, irqtest_tasklet_handler,\n+                               (unsigned long) &irqinfo);\n+\n      /* Request IRQ line and setup corresponding handler */\n      irqinfo.dev = dev;\n      ret = request_irq(irqinfo.irq, irqtest_interrupt, 0,\n@@ -98,6 +113,7 @@ static int irqtest_remove(struct platform_device *pdev)\n {\n      struct device *dev = &pdev->dev;\n\n+     tasklet_kill(&irqinfo.task);\n      free_irq(irqinfo.irq, &irqinfo);\n      dev_info(dev, \"IRQ %d is now unmanaged!\\n\", irqinfo.irq);\n```", "```\na/drivers/misc/irqtest.c\n+++ b/drivers/misc/irqtest.c\n@@ -14,6 +14,7 @@\n #include <linux/gpio.h>\n #include <linux/irq.h>\n #include <linux/interrupt.h>\n+#include <linux/workqueue.h>\n\n /*\n  * Module data\n@@ -23,12 +24,37 @@ static struct irqtest_data {\n        int irq;\n      unsigned int pin;\n      struct device *dev;\n+     struct work_struct work;\n+     struct delayed_work dwork;\n } irqinfo;\n\n+static struct workqueue_struct *irqtest_wq;\n...\n```", "```\n@@ -80,24 +108,40 @@ static int irqtest_probe(struct platform_device *pdev)\n      dev_info(dev, \"GPIO %u correspond to IRQ %d\\n\",\n                                irqinfo.pin, irqinfo.irq);\n\n+     /* Create our work queue and init works */\n+     irqtest_wq = create_singlethread_workqueue(\"irqtest\");\n+     if (!irqtest_wq) {\n+         dev_err(dev, \"failed to create work queue!\\n\");\n+         return -EINVAL;\n+     }\n+     INIT_WORK(&irqinfo.work, irqtest_work_handler);\n+     INIT_DELAYED_WORK(&irqinfo.dwork, irqtest_dwork_handler);\n+\n      /* Request IRQ line and setup corresponding handler */\n      irqinfo.dev = dev;\n      ret = request_irq(irqinfo.irq, irqtest_interrupt, 0,\n                                \"irqtest\", &irqinfo);\n      if (ret) {\n          dev_err(dev, \"cannot register IRQ %d\\n\", irqinfo.irq);\n-         return -EIO;\n+         goto flush_wq;\n      }\n      dev_info(dev, \"interrupt handler for IRQ %d is now ready!\\n\",\n                                irqinfo.irq);\n\n      return 0;\n+\n+flush_wq:\n+     flush_workqueue(irqtest_wq);\n+     return -EIO;\n }\n```", "```\n+static void irqtest_dwork_handler(struct work_struct *ptr)\n+{\n+     struct irqtest_data *info = container_of(ptr, struct irqtest_data,\n+                                                   dwork.work);\n+     struct device *dev = info->dev;\n+\n+     dev_info(dev, \"delayed work executed after work\");\n+}\n+\n+static void irqtest_work_handler(struct work_struct *ptr)\n+{\n+     struct irqtest_data *info = container_of(ptr, struct irqtest_data,\n+                                                   work);\n+     struct device *dev = info->dev;\n+\n+     dev_info(dev, \"work executed after IRQ %d\", info->irq);\n+\n+     /* Schedule the delayed work after 2 seconds */\n+     queue_delayed_work(irqtest_wq, &info->dwork, 2*HZ);\n+}\n```", "```\n@@ -36,6 +62,8 @@ static irqreturn_t irqtest_interrupt(int irq, void *dev_id)\n\n      dev_info(dev, \"interrupt occurred on IRQ %d\\n\", irq);\n\n+     queue_work(irqtest_wq, &info->work);\n+\n      return IRQ_HANDLED;\n }\n```", "```\n static int irqtest_remove(struct platform_device *pdev)\n {\n      struct device *dev = &pdev->dev;\n\n+     cancel_work_sync(&irqinfo.work);\n+     cancel_delayed_work_sync(&irqinfo.dwork);\n+     flush_workqueue(irqtest_wq);\n      free_irq(irqinfo.irq, &irqinfo);\n      dev_info(dev, \"IRQ %d is now unmanaged!\\n\", irqinfo.irq);\n```", "```\nirqtest irqtest: interrupt occurred on IRQ 40\nirqtest irqtest: tasklet executed after IRQ 40\n```", "```\n[ 33.113008] irqtest irqtest: interrupt occurred on IRQ 40\n[ 33.115731] irqtest irqtest: work executed after IRQ 40\n...\n[ 33.514268] irqtest irqtest: interrupt occurred on IRQ 40\n[ 33.516990] irqtest irqtest: work executed after IRQ 40\n[ 33.533121] irqtest irqtest: interrupt occurred on IRQ 40\n[ 33.535846] irqtest irqtest: work executed after IRQ 40\n[ 35.138114] irqtest irqtest: delayed work executed after work\n```", "```\nstatic int __init hires_timer_init(void)\n{\n    /* Set up hires timer delay */\n\n    pr_info(\"delay is set to %dns\\n\", delay_ns);\n\n    /* Setup and start the hires timer */\n    hrtimer_init(&hires_tinfo.timer, CLOCK_MONOTONIC,\n                HRTIMER_MODE_REL | HRTIMER_MODE_SOFT);\n    hires_tinfo.timer.function = hires_timer_handler;\n    hrtimer_start(&hires_tinfo.timer, ns_to_ktime(delay_ns),\n                HRTIMER_MODE_REL | HRTIMER_MODE_SOFT);\n\n    pr_info(\"hires timer module loaded\\n\");\n    return 0;\n}\n```", "```\nstatic void __exit hires_timer_exit(void)\n{\n    hrtimer_cancel(&hires_tinfo.timer);\n\n    pr_info(\"hires timer module unloaded\\n\");\n}\n\nmodule_init(hires_timer_init);\nmodule_exit(hires_timer_exit);\n```", "```\n/* Initialize timers: */\nextern void hrtimer_init(struct hrtimer *timer, clockid_t which_clock,\n                         enum hrtimer_mode mode);\n```", "```\nhires_tinfo.timer.function = hires_timer_handler;\n```", "```\nstatic struct hires_timer_data {\n    struct hrtimer timer;\n    unsigned int data;\n} hires_tinfo;\n```", "```\n/* Basic timer operations: */\nextern void hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,\n                           u64 range_ns, const enum hrtimer_mode mode);\n\n/**\n * hrtimer_start - (re)start an hrtimer\n * @timer: the timer to be added\n * @tim: expiry time\n * @mode: timer mode: absolute (HRTIMER_MODE_ABS) or\n * relative (HRTIMER_MODE_REL), and pinned (HRTIMER_MODE_PINNED);\n * softirq based mode is considered for debug purpose only!\n */\nstatic inline void hrtimer_start(struct hrtimer *timer, ktime_t tim,\n                                 const enum hrtimer_mode mode)\n{\n    hrtimer_start_range_ns(timer, tim, 0, mode);\n}\n```", "```\nstatic enum hrtimer_restart hires_timer_handler(struct hrtimer *ptr)\n{\n    struct hires_timer_data *info = container_of(ptr,\n                    struct hires_timer_data, timer);\n\n    pr_info(\"kernel timer expired at %ld (data=%d)\\n\",\n                jiffies, info->data++);\n\n    /* Now forward the expiration time and ask to be rescheduled */\n    hrtimer_forward_now(&info->timer, ns_to_ktime(delay_ns));\n    return HRTIMER_RESTART;\n}\n```", "```\n# insmod hires_timer.ko\n```", "```\n[ 528.902156] hires_timer:hires_timer_init: delay is set to 1000000000ns\n[ 528.911593] hires_timer:hires_timer_init: hires timer module loaded\n```", "```\n\n[ 529.911604] hires_timer:hires_timer_handler: kernel timer expired at 4295024749 (data=0)\n[ 530.911602] hires_timer:hires_timer_handler: kernel timer expired at 4295024999 (data=1)\n[ 531.911602] hires_timer:hires_timer_handler: kernel timer expired at 4295025249 (data=2)\n[ 532.911602] hires_timer:hires_timer_handler: kernel timer expired at 4295025499 (data=3)\n...\n```", "```\nhires_timer:hires_timer_exit: hires timer module unloaded\n```", "```\nstatic int __init ktimer_init(void)\n{\n    /* Save kernel timer delay */\n    ktinfo.delay_jiffies = msecs_to_jiffies(delay_ms);\n    pr_info(\"delay is set to %dms (%ld jiffies)\\n\",\n                delay_ms, ktinfo.delay_jiffies);\n\n    /* Setup and start the kernel timer */\n    timer_setup(&ktinfo.timer, ktimer_handler, 0); \n    mod_timer(&ktinfo.timer, jiffies + ktinfo.delay_jiffies);\n\n    pr_info(\"kernel timer module loaded\\n\");\n    return 0;\n}\n\nstatic void __exit ktimer_exit(void)\n{\n    del_timer_sync(&ktinfo.timer);\n\n    pr_info(\"kernel timer module unloaded\\n\");\n}\n```", "```\nstatic struct ktimer_data {\n    struct timer_list timer;\n    long delay_jiffies;\n    unsigned int data;\n} ktinfo;\n\n...\n\nstatic void ktimer_handler(struct timer_list *t)\n{\n    struct ktimer_data *info = from_timer(info, t, timer);\n\n    pr_info(\"kernel timer expired at %ld (data=%d)\\n\",\n                jiffies, info->data++);\n\n    /* Reschedule kernel timer */\n    mod_timer(&info->timer, jiffies + info->delay_jiffies);\n}\n```", "```\n/**\n * timer_setup - prepare a timer for first use\n * @timer: the timer in question\n * @callback: the function to call when timer expires\n * @flags: any TIMER_* flags\n *\n * Regular timer initialization should use either DEFINE_TIMER() above,\n * or timer_setup(). For timers on the stack, timer_setup_on_stack() must\n * be used and must be balanced with a call to destroy_timer_on_stack().\n */\n#define timer_setup(timer, callback, flags) \\\n    __init_timer((timer), (callback), (flags))\n```", "```\n/*\n * A deferrable timer will work normally when the system is busy, but\n * will not cause a CPU to come out of idle just to service it; instead,\n * the timer will be serviced when the CPU eventually wakes up with a\n * subsequent non-deferrable timer.\n *\n * An irqsafe timer is executed with IRQ disabled and it's safe to wait for\n * the completion of the running instance from IRQ handlers, for example,\n * by calling del_timer_sync().\n *\n * Note: The irq disabled callback execution is a special case for\n * workqueue locking issues. It's not meant for executing random crap\n * with interrupts disabled. Abuse is monitored!\n */\n#define TIMER_CPUMASK     0x0003FFFF\n#define TIMER_MIGRATING   0x00040000\n#define TIMER_BASEMASK    (TIMER_CPUMASK | TIMER_MIGRATING)\n#define TIMER_DEFERRABLE  0x00080000\n#define TIMER_PINNED      0x00100000\n#define TIMER_IRQSAFE     0x00200000\n```", "```\nstatic void ktimer_handler(struct timer_list *t)\n{\n    struct ktimer_data *info = from_timer(info, t, timer);\n\n    pr_info(\"kernel timer expired at %ld (data=%d)\\n\",\n                jiffies, info->data++);\n\n    /* Reschedule kernel timer */\n    mod_timer(&info->timer, jiffies + info->delay_jiffies);\n}\n```", "```\n# insmod ktimer.ko\n```", "```\n[ 122.174020] ktimer:ktimer_init: delay is set to 1000ms (250 jiffies)\n[ 122.180519] ktimer:ktimer_init: kernel timer module loaded\n[ 123.206222] ktimer:ktimer_handler: kernel timer expired at 4294923072 (data=0)\n[ 124.230222] ktimer:ktimer_handler: kernel timer expired at 4294923328 (data=1)\n[ 125.254218] ktimer:ktimer_handler: kernel timer expired at 4294923584 (data=2)\n```", "```\nktimer:ktimer_exit: kernel timer module unloaded\n```", "```\nstatic int __init waitqueue_init(void)\n{\n    int ret;\n\n    /* Save kernel timer delay */\n    wqinfo.delay_jiffies = msecs_to_jiffies(delay_ms);\n    pr_info(\"delay is set to %dms (%ld jiffies)\\n\",\n                delay_ms, wqinfo.delay_jiffies);\n\n    /* Init the wait queue */\n    init_waitqueue_head(&wqinfo.waitq);\n\n    /* Setup and start the kernel timer */\n    timer_setup(&wqinfo.timer, ktimer_handler, 0);\n    mod_timer(&wqinfo.timer, jiffies + wqinfo.delay_jiffies);\n```", "```\n    /* Wait for the wake up event... */\n    ret = wait_event_interruptible(wqinfo.waitq, wqinfo.data > 5);\n    if (ret < 0)\n        goto exit;\n\n    pr_info(\"got event data > 5\\n\");\n\n    return 0;\n\nexit:\n    if (ret == -ERESTARTSYS)\n        pr_info(\"interrupted by signal!\\n\");\n    else\n        pr_err(\"unable to wait for event\\n\");\n\n    del_timer_sync(&wqinfo.timer);\n\n    return ret;\n}\n```", "```\nstatic struct ktimer_data {\n    struct wait_queue_head waitq;\n    struct timer_list timer;\n    long delay_jiffies;\n    unsigned int data;\n} wqinfo;\n```", "```\n/**\n * wait_event_interruptible - sleep until a condition gets true\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n *\n * The process is put to sleep (TASK_INTERRUPTIBLE) until the\n * @condition evaluates to true or a signal is received.\n * The @condition is checked each time the waitqueue @wq_head is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n *\n * The function will return -ERESTARTSYS if it was interrupted by a\n * signal and 0 if @condition evaluated to true.\n */\n#define wait_event_interruptible(wq_head, condition) \\\n```", "```\nstatic void ktimer_handler(struct timer_list *t)\n{\n    struct ktimer_data *info = from_timer(info, t, timer);\n\n    pr_info(\"kernel timer expired at %ld (data=%d)\\n\",\n                jiffies, info->data++);\n\n    /* Wake up all sleeping processes */\n    wake_up_interruptible(&info->waitq);\n\n    /* Reschedule kernel timer */\n    mod_timer(&info->timer, jiffies + info->delay_jiffies);\n}\n```", "```\nstatic int __init completion_init(void)\n{\n    /* Save kernel timer delay */\n    cinfo.delay_jiffies = msecs_to_jiffies(delay_ms);\n    pr_info(\"delay is set to %dms (%ld jiffies)\\n\",\n                delay_ms, cinfo.delay_jiffies);\n\n    /* Init the wait queue */\n    init_completion(&cinfo.done);\n\n    /* Setup and start the kernel timer */\n    timer_setup(&cinfo.timer, ktimer_handler, 0); \n    mod_timer(&cinfo.timer, jiffies + cinfo.delay_jiffies);\n\n    /* Wait for completition... */\n    wait_for_completion(&cinfo.done);\n\n    pr_info(\"job done\\n\");\n\n    return 0;\n}\n\nstatic void __exit completion_exit(void)\n{\n    del_timer_sync(&cinfo.timer);\n\n    pr_info(\"module unloaded\\n\");\n}\n```", "```\nstatic struct ktimer_data {\n    struct completion done;\n    struct timer_list timer;\n    long delay_jiffies;\n    unsigned int data;\n} cinfo;\n```", "```\nstatic void ktimer_handler(struct timer_list *t)\n{\n    struct ktimer_data *info = from_timer(info, t, timer);\n\n    pr_info(\"kernel timer expired at %ld (data=%d)\\n\",\n                jiffies, info->data++);\n\n    /* Signal that job is done */\n    complete(&info->done);\n}\n```", "```\n/**\n * complete: - signals a single thread waiting on this completion\n * @x: holds the state of this particular completion\n *\n * This will wake up a single thread waiting on this completion. Threads will be\n * awakened in the same order in which they were queued.\n *\n * See also complete_all(), wait_for_completion() and related routines.\n *\n * It may be assumed that this function implies a write memory barrier before\n * changing the task state if and only if any tasks are woken up.\n */\nvoid complete(struct completion *x)\n```", "```\n/**\n * complete_all: - signals all threads waiting on this completion\n * @x: holds the state of this particular completion\n *\n * This will wake up all threads waiting on this particular completion\n * event.\n * It may be assumed that this function implies a write memory barrier\n * before changing the task state if and only if any tasks are\n * woken up.\n * Since complete_all() sets the completion of @x permanently to done\n * to allow multiple waiters to finish, a call to reinit_completion()\n * must be used on @x if @x is to be used again. The code must make\n * sure that all waiters have woken and finished before reinitializing\n * @x. Also note that the function completion_done() can not be used\n * to know if there are still waiters after complete_all() has been\n * called.\n */\nvoid complete_all(struct completion *x)\n```", "```\n/**\n * wait_event - sleep until a condition gets true\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n *\n * The process is put to sleep (TASK_UNINTERRUPTIBLE) until the\n * @condition evaluates to true. The @condition is checked each time\n * the waitqueue @wq_head is woken up.\n *\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n */\n#define wait_event(wq_head, condition) \\\n```", "```\n/** * wait_event_interruptible_timeout - sleep until a condition\n *    gets true or a timeout elapses\n * @wq_head: the waitqueue to wait on\n * @condition: a C expression for the event to wait for\n * @timeout: timeout, in jiffies\n *\n * The process is put to sleep (TASK_INTERRUPTIBLE) until the\n * @condition evaluates to true or a signal is received.\n * The @condition is checked each time the waitqueue @wq_head\n * is woken up.\n * wake_up() has to be called after changing any variable that could\n * change the result of the wait condition.\n * Returns:\n * 0 if the @condition evaluated to %false after the @timeout elapsed,\n * 1 if the @condition evaluated to %true after the @timeout elapsed,\n * the remaining jiffies (at least 1) if the @condition evaluated\n * to %true before the @timeout elapsed, or -%ERESTARTSYS if it was\n * interrupted by a signal.\n */\n#define wait_event_interruptible_timeout(wq_head, condition, timeout) \\\n```", "```\n#define wake_up(x)         __wake_up(x, TASK_NORMAL, 1, NULL)\n#define wake_up_nr(x, nr)  __wake_up(x, TASK_NORMAL, nr, NULL)\n#define wake_up_all(x)     __wake_up(x, TASK_NORMAL, 0, NULL)\n...\n#define wake_up_interruptible(x) __wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)\n#define wake_up_interruptible_nr(x, nr) __wake_up(x, TASK_INTERRUPTIBLE, nr, NULL)\n#define wake_up_interruptible_all(x) __wake_up(x, TASK_INTERRUPTIBLE, 0, NULL)\n...\n```", "```\nextern void wait_for_completion(struct completion *);\nextern int wait_for_completion_interruptible(struct completion *x);\nextern unsigned long wait_for_completion_timeout(struct completion *x,\n                                                   unsigned long timeout);\nextern long wait_for_completion_interruptible_timeout(\n        struct completion *x, unsigned long timeout);\n```", "```\n# insmod waitqueue.ko\n```", "```\nwaitqueue:waitqueue_init: delay is set to 1000ms (250 jiffies)\nwaitqueue:ktimer_handler: kernel timer expired at 4295371304 (data=0)\nwaitqueue:ktimer_handler: kernel timer expired at 4295371560 (data=1)\nwaitqueue:ktimer_handler: kernel timer expired at 4295371816 (data=2)\nwaitqueue:ktimer_handler: kernel timer expired at 4295372072 (data=3)\nwaitqueue:ktimer_handler: kernel timer expired at 4295372328 (data=4)\nwaitqueue:ktimer_handler: kernel timer expired at 4295372584 (data=5)\nwaitqueue:waitqueue_init: got event data > 5\nwaitqueue:ktimer_handler: kernel timer expired at 4295372840 (data=6)\n...\n```", "```\n# rmmod waitqueue \n# insmod waitqueue.ko\n^C\n```", "```\nwaitqueue:waitqueue_init: delay is set to 1000ms (250 jiffies)\nwaitqueue:ktimer_handler: kernel timer expired at 4295573632 (data=0)\nwaitqueue:ktimer_handler: kernel timer expired at 4295573888 (data=1)\nwaitqueue:waitqueue_init: interrupted by signal!\n```", "```\n# insmod completion.ko\n^C^C^C^C\n```", "```\ncompletion:completion_init: delay is set to 5000ms (1250 jiffies)\ncompletion:ktimer_handler: kernel timer expired at 4296124608 (data=0)\ncompletion:completion_init: job done\n```", "```\nstatic int __init mut_init(void)\n{\n    /* Save kernel timer delay */\n    minfo.delay_jiffies = msecs_to_jiffies(delay_ms);\n    pr_info(\"delay is set to %dms (%ld jiffies)\\n\",\n                delay_ms, minfo.delay_jiffies);\n\n    /* Init the mutex */\n    mutex_init(&minfo.lock);\n\n    /* Setup and start the kernel timer */\n    timer_setup(&minfo.timer, ktimer_handler, 0); \n    mod_timer(&minfo.timer, jiffies);\n\n    mutex_lock(&minfo.lock);\n    minfo.data++;\n    mutex_unlock(&minfo.lock);\n\n    pr_info(\"mutex module loaded\\n\");\n    return 0;\n}\n```", "```\nstatic void __exit mut_exit(void)\n{\n    del_timer_sync(&minfo.timer);\n\n    pr_info(\"mutex module unloaded\\n\");\n}\n\nmodule_init(mut_init);\nmodule_exit(mut_exit);\n```", "```\nstatic struct ktimer_data {\n    struct mutex lock;\n    struct timer_list timer;\n    long delay_jiffies;\n    int data;\n} minfo;\n```", "```\nstatic void ktimer_handler(struct timer_list *t)\n{\n    struct ktimer_data *info = from_timer(info, t, timer);\n    int ret;\n\n    pr_info(\"kernel timer expired at %ld (data=%d)\\n\",\n                jiffies, info->data);\n    ret = mutex_trylock(&info->lock);\n    if (ret) {\n        info->data++;\n        mutex_unlock(&info->lock);\n    } else\n        pr_err(\"cannot get the lock!\\n\");\n\n    /* Reschedule kernel timer */\n    mod_timer(&info->timer, jiffies + info->delay_jiffies);\n}\n```", "```\nstatic int __init spin_init(void)\n{\n    unsigned long flags;\n\n    /* Save kernel timer delay */\n    sinfo.delay_jiffies = msecs_to_jiffies(delay_ms);\n    pr_info(\"delay is set to %dms (%ld jiffies)\\n\",\n                delay_ms, sinfo.delay_jiffies);\n\n    /* Init the spinlock */\n    spin_lock_init(&sinfo.lock);\n\n    /* Setup and start the kernel timer */\n    timer_setup(&sinfo.timer, ktimer_handler, 0); \n    mod_timer(&sinfo.timer, jiffies);\n\n    spin_lock_irqsave(&sinfo.lock, flags);\n    sinfo.data++;\n    spin_unlock_irqrestore(&sinfo.lock, flags);\n\n    pr_info(\"spinlock module loaded\\n\");\n    return 0;\n}\n```", "```\nstatic void __exit spin_exit(void)\n{\n    del_timer_sync(&sinfo.timer);\n\n    pr_info(\"spinlock module unloaded\\n\");\n}\n\nmodule_init(spin_init);\nmodule_exit(spin_exit);\n```", "```\nstatic struct ktimer_data {\n    struct spinlock lock;\n    struct timer_list timer;\n    long delay_jiffies;\n    int data;\n} sinfo;\n```", "```\nstatic void ktimer_handler(struct timer_list *t)\n{\n    struct ktimer_data *info = from_timer(info, t, timer);\n\n    pr_info(\"kernel timer expired at %ld (data=%d)\\n\",\n                jiffies, info->data);\n    spin_lock(&sinfo.lock);\n    info->data++;\n    spin_unlock(&info->lock);\n\n    /* Reschedule kernel timer */\n    mod_timer(&info->timer, jiffies + info->delay_jiffies);\n}\n```", "```\n# insmod mutex.ko \nmutex:mut_init: delay is set to 1000ms (250 jiffies)\nmutex:mut_init: mutex module loaded\n```", "```\nmutex:ktimer_handler: kernel timer expired at 4294997916 (data=1)\nmutex:ktimer_handler: kernel timer expired at 4294998168 (data=2)\nmutex:ktimer_handler: kernel timer expired at 4294998424 (data=3)\n...\n```", "```\n# insmod spinlock.ko \nspinlock:spin_init: delay is set to 1000ms (250 jiffies)\nspinlock:spin_init: spinlock module loaded\n```", "```\nspinlock:ktimer_handler: kernel timer expired at 4295019195 (data=1)\nspinlock:ktimer_handler: kernel timer expired at 4295019448 (data=2)\nspinlock:ktimer_handler: kernel timer expired at 4295019704 (data=3)\n...\n```", "```\nstatic atomic_t bitmap = ATOMIC_INIT(0xff);\n\nstatic struct ktimer_data {\n    struct timer_list timer;\n    long delay_jiffies;\n    atomic_t data;\n} ainfo;\n```", "```\nstatic int __init atom_init(void)\n{\n    /* Save kernel timer delay */\n    ainfo.delay_jiffies = msecs_to_jiffies(delay_ms);\n    pr_info(\"delay is set to %dms (%ld jiffies)\\n\",\n                delay_ms, ainfo.delay_jiffies);\n\n    /* Init the atomic data */\n    atomic_set(&ainfo.data, 10);\n\n    /* Setup and start the kernel timer after required delay */\n    timer_setup(&ainfo.timer, ktimer_handler, 0); \n    mod_timer(&ainfo.timer, jiffies + ainfo.delay_jiffies);\n\n    pr_info(\"data=%0x\\n\", atomic_read(&ainfo.data));\n    pr_info(\"bitmap=%0x\\n\", atomic_fetch_and(0x0f, &bitmap));\n\n    pr_info(\"atomic module loaded\\n\");\n    return 0;\n}\n```", "```\nstatic void __exit atom_exit(void)\n{\n    del_timer_sync(&ainfo.timer);\n\n    pr_info(\"atomic module unloaded\\n\");\n}\n```", "```\nstatic void ktimer_handler(struct timer_list *t)\n{\n    struct ktimer_data *info = from_timer(info, t, timer);\n\n    pr_info(\"kernel timer expired at %ld (data=%d)\\n\",\n                jiffies, atomic_dec_if_positive(&info->data));\n\n    /* Compute an atomic bitmap operation */\n    atomic_xor(0xff, &bitmap);\n    pr_info(\"bitmap=%0x\\n\", atomic_read(&bitmap));\n\n    /* Reschedule kernel timer */\n    mod_timer(&info->timer, jiffies + info->delay_jiffies);\n}\n```", "```\n# insmod atomic.ko \natomic:atom_init: delay is set to 1000ms (250 jiffies)\natomic:atom_init: data=a\natomic:atom_init: bitmap=ff\natomic:atom_init: atomic module loaded\natomic:ktimer_handler: kernel timer expired at 4295049912 (data=9)\natomic:ktimer_handler: bitmap=f0\natomic:ktimer_handler: kernel timer expired at 4295050168 (data=8)\natomic:ktimer_handler: bitmap=f\n...\natomic:ktimer_handler: kernel timer expired at 4295051960 (data=1)\natomic:ktimer_handler: bitmap=f0\natomic:ktimer_handler: kernel timer expired at 4295052216 (data=0)\natomic:ktimer_handler: bitmap=f\natomic:ktimer_handler: kernel timer expired at 4295052472 (data=-1)\n```"]