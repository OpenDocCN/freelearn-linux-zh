- en: IIO Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IIO框架
- en: '**Industrial I/O** (**IIO** ) is a kernel subsystem dedicated to **analogic
    to digitals converters** (**ADC** ) and **digital to analogic converters** (**DAC**
    ). With the growing number of sensors (measurement devices with analogue to digital,
    or digital to analogue, capabilities) with different code implementations, scattered
    over the kernel sources, gathering them became necessary. This is what IIO framework
    does, in a generic and homogeneous way. Jonathan Cameron and the Linux-IIO community
    have been developing it since 2009.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**工业I/O**（**IIO**）是一个专门用于**模拟到数字转换器**（**ADC**）和**数字到模拟转换器**（**DAC**）的内核子系统。随着不断增加的传感器（具有模拟到数字或数字到模拟能力的测量设备）以不同的代码实现分散在内核源代码中，对它们进行收集变得必要。这就是IIO框架以一种通用和统一的方式所做的。自2009年以来，Jonathan
    Cameron和Linux-IIO社区一直在开发它。'
- en: Accelerometer, Gyroscope, current/voltage measurement chips, light sensors,
    pressure sensors, and so on all fall into the IIO family of devices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度计、陀螺仪、电流/电压测量芯片、光传感器、压力传感器等都属于IIO设备系列。
- en: 'The IIO model is based on devices and channels architecture:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: IIO模型基于设备和通道架构：
- en: Device represents the chip itself. It is the top level of the hierarchy.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备代表芯片本身。它是层次结构的最高级别。
- en: Channel represents a single acquisition line of the device. A device may have
    one or more channels. For example, an accelerometer is a device with three channels,
    one for each axis (X, Y, and Z).
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道表示设备的单个采集线。一个设备可能有一个或多个通道。例如，加速度计是一个具有三个通道的设备，分别用于每个轴（X、Y和Z）。
- en: The IIO chip is the physical and hardware sensor/converter. It is exposed to
    the user space as a character device (when triggered buffering is supported),
    and a **sysfs** directory entry which will contain a set of files, some of which
    represent the channels. A single channel is represented with a single **sysfs**
    file entry.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: IIO芯片是物理和硬件传感器/���换器。它以字符设备（当支持触发缓冲时）和一个**sysfs**目录条目暴露给用户空间，该目录将包含一组文件，其中一些表示通道。单个通道用单个**sysfs**文件条目表示。
- en: 'These are the two ways to interact with an IIO driver from the user space:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从用户空间与IIO驱动程序交互的两种方式：
- en: '`/sys/bus/iio/iio:deviceX/` : This represents the sensor along with its channels'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys/bus/iio/iio:deviceX/`：这代表传感器以及其通道'
- en: '`/dev/iio:deviceX` : This is a character device which exports the device''s
    events and data buffer'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev/iio:deviceX`：这是一个字符设备，用于导出设备的事件和数据缓冲区'
- en: '![](img/Image00018.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00018.jpg)'
- en: IIO framework architecture and layout
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: IIO框架的架构和布局
- en: The preceding figure shows how the IIO framework is organized between kernel
    and user space. The driver manages the hardware and report processing to the IIO
    core, using a set of facilities and API exposed by the IIO core. The IIO subsystem
    then abstracts the whole underlying mechanism to the user space by means of the
    sysfs interface and character device, on top of which users can execute system
    calls.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了IIO框架在内核和用户空间之间的组织方式。驱动程序管理硬件并将处理报告给IIO核心，使用IIO核心提供的一组设施和API。然后，IIO子系统通过sysfs接口和字符设备将整个底层机制抽象到用户空间，用户可以在其上执行系统调用。
- en: 'IIO APIs are spread over several header files, listed as following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: IIO API分布在几个头文件中，列举如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this chapter, we will describe and handle every concepts of IIO framework,
    such as
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述和处理IIO框架的每个概念，比如
- en: A walk through its data structure (device, channel, and so on)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历其数据结构（设备、通道等）
- en: Triggered buffer support and continuous capture, along with its sysfs interface
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发缓冲区支持和连续捕获，以及其sysfs接口
- en: Exploring existing IIO triggers
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索现有的IIO触发器
- en: Capturing data in either one-shot mode or continuous mode
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以单次模式或连续模式捕获数据
- en: Listing available tools that can help developers in testing their devices
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出可用的工具，可以帮助开发人员测试他们的设备
- en: IIO data structures
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IIO数据结构
- en: An IIO device is represented in the kernel as an instance of the `struct iio_dev`
    , and described by a `struct iio_info` structure. All of the important IIO structures
    are defined in `include/linux/iio/iio.h` .
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: IIO设备在内核中表示为`struct iio_dev`的实例，并由`struct iio_info`结构描述。所有重要的IIO结构都在`include/linux/iio/iio.h`中定义。
- en: iio_dev structure
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iio_dev结构
- en: 'This structure represents the IIO device, describing the device, and the driver.
    It tells us about:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构表示IIO设备，描述设备和驱动程序。它告诉我们关于：
- en: How many channels are available on the device?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备上有多少个通道可用？
- en: 'What modes can the device operate in: one-shot, triggered buffer?'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备可以以哪些模式操作：单次、触发缓冲？
- en: What hooks are available for this driver?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个驱动程序有哪些可用的钩子？
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The complete structure is defined in the IIO header file. Fields that we are
    not interested in are removed here.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的结构在IIO头文件中定义。这里删除了我们不感兴趣的字段。
- en: '`modes` : This represents the different modes supported by the device. Supported
    modes are:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modes`：这代表设备支持的不同模式。支持的模式有：'
- en: '`INDIO_DIRECT_MODE` which says device provides sysfs type interfaces.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INDIO_DIRECT_MODE` 表示设备提供sysfs类型的接口。'
- en: '`INDIO_BUFFER_TRIGGERED` says that the device supports hardware triggers. This
    mode is automatically added to your device when you set up a trigger buffer using
    the `iio_triggered_buffer_setup()` function.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INDIO_BUFFER_TRIGGERED` 表示设备支持硬件触发。当您使用`iio_triggered_buffer_setup()`函数设置触发缓冲区时，此模式会自动添加到您的设备中。'
- en: '`INDIO_BUFFER_HARDWARE` shows the device has a hardware buffer.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INDIO_BUFFER_HARDWARE`显示设备具有硬件缓冲区。'
- en: '`INDIO_ALL_BUFFER_MODES` is the union of the above two.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INDIO_ALL_BUFFER_MODES`是上述两者的并集。'
- en: '`currentmode` : This represents the mode actually used by the device.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentmode`：这代表设备实际使用的模式。'
- en: '`dev` : This represents the struct device (according to Linux device model)
    the IIO device is tied to.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`：这代表了IIO设备绑定的struct device（根据Linux设备模型）。'
- en: '`buffer` : This is your data buffer, pushed to the user space when using triggered
    buffer mode. It is automatically allocated and associated to your device when
    you enable trigger buffer support using the `iio_triggered_buffer_setup` function.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buffer`：这是您的数据缓冲区，在使用触发缓冲区模式时推送到用户空间。当使用`iio_triggered_buffer_setup`函数启用触发缓冲区支持时，它会自动分配并与您的设备关联。'
- en: '`scan_bytes` : This is the number of bytes captured and to be fed to the `buffer`
    . When using trigger buffer from the user space, the buffer should be at least
    `indio->scan_bytes` bytes large.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scan_bytes`：这是捕获并馈送到`buffer`的字节数。当从用户空间使用触发缓冲区时，缓冲区应至少为`indio->scan_bytes`字节大。'
- en: '`available_scan_masks` : This is an optional array of allowed bit masks. When
    using trigger buffer, one can enable channels to be captured and fed into the
    IIO buffer. If you do not want to allow some channels to be enabled, you should
    fill this array with only allowed ones. The following is an example of providing
    a scan mask for an accelerometer (with X, Y, and Z channels):'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`available_scan_masks`：这是允许的位掩码的可选数组。在使用触发缓冲区时，可以启用通道以被捕获并馈送到IIO缓冲区中。如果不希望允许某些通道被启用，应该只填充此数组。以下是为加速度计提供扫描掩码的示例（具有X、Y和Z通道）：'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`active_scan_mask` : This is a bitmask of enabled channels. Only the data from
    those channels should be pushed into the `buffer` . For example, for an 8 channels
    ADC converter, if one only enables the first (0), third (2), and last (7) channels,
    the bitmask would be 0b10000101 (0x85). `active_scan_mask` will be set to 0x85\.
    The driver can then use the `for_each_set_bit` macro to walk through each set
    bit, fetch the data according to the channel, and fill the buffer.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active_scan_mask`：这是启用通道的位掩码。只有这些通道的数据应该被推送到`buffer`中。例如，对于8通道ADC转换器，如果只启用第一个（0）、第三个（2）和最后一个（7）通道，位掩码将是0b10000101（0x85）。`active_scan_mask`将设置为0x85。然后驱动程序可以使用`for_each_set_bit`宏来遍历每个设置的位，根据通道获取数据，并填充缓冲区。'
- en: '`scan_timestamp` : This tells us whether to push the capture timestamp into
    the buffer or not. If true, the timestamp will be pushed as the last element of
    the buffer. The timestamp is 8 bytes (64bits) large.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scan_timestamp`：这告诉我们是否将捕获时间戳推送到缓冲区。如果为true，则时间戳将作为缓冲区的最后一个元素推送。时间戳为8字节（64位）。'
- en: '`trig` : This is the current device trigger (when buffer mode is supported).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trig`：这是当前设备的触发器（当支持缓冲模式时）。'
- en: '`pollfunc` : This is the function run on the trigger being received.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pollfunc`：这是在接收到触发器时运行的函数。'
- en: '`channels` : This represents the table channel specification structure, to
    describe every channel the device has.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channels`：这代表通道规范结构表，描述设备具有的每个通道。'
- en: '`num_channels` : This represents the number of channels specified in `channels`
    .'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_channels`：这代表在`channels`中指定的通道数。'
- en: '`name` : This represents the device name.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这代表设备名称。'
- en: '`info` : Callbacks and constant information from the driver.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info`：来自驱动程序的回调和常量信息。'
- en: '`setup_ops` : Set of callback functions to call before and after the buffer
    is enabled/disabled. This structure is defined in `include/linux/iio/iio.h` shown
    as follows:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup_ops`：在启用/禁用缓冲区之前和之后调用的回调函数集。此结构在`include/linux/iio/iio.h`中定义如下：'
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`setup_ops` : If this is not specified, the IIO core uses the default `iio_triggered_buffer_setup_ops`
    defined in `drivers/iio/buffer/industrialio-triggered-buffer.c` .'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup_ops`：如果未指定，IIO核心将使用在`drivers/iio/buffer/industrialio-triggered-buffer.c`中定义的默认`iio_triggered_buffer_setup_ops`。'
- en: '`chrdev` : This is the associated character device created by the IIO core.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chrdev`：这是由IIO核心创建的关联字符设备。'
- en: 'The function used to allocate memory for an IIO device is `iio_device_alloc()`
    :'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 用于为IIO设备分配内存的函数是`iio_device_alloc()`：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`dev` is the device for which `iio_dev` is allocated, and `sizeof_priv` is
    the memory space used to allocate for any private structure. This way, passing
    per-device (private) data structure is quite straightforward. The function returns
    `NULL` if the allocation fails:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`dev`是为其分配`iio_dev`的设备，`sizeof_priv`是用于分配任何私有结构的内存空间。通过这种方式，传递每个设备（私有）数据结构非常简单。如果分配失败，该函数将返回`NULL`：'
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After the IIO device memory has been allocated, the next step is to fill different
    fields. Once done, one has to register the device with the IIO subsystem using
    `iio_device_register` function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 分配了IIO设备内存后，下一步是填充不同的字段。完成后，必须使用`iio_device_register`函数向IIO子系统注册设备：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The device will be ready to accept requests from the user space after this
    function executes. The reverse operation (usually done in the release function)
    is `iio_device_unregister()` :'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数执行后，设备将准备好接受来自用户空间的请求。反向操作（通常在释放函数中完成）是`iio_device_unregister()`：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once unregistered, the memory allocated by `iio_device_alloc` can be freed
    with `iio_device_free` :'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦注销，由`iio_device_alloc`分配的内存可以使用`iio_device_free`释放：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Given an IIO device as parameter, one can retrieve the private data in the
    following manner:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个IIO设备作为参数，可以以以下方式检索私有数据：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: iio_info structure
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iio_info结构
- en: 'The `struct iio_info` structure is used to declare the hooks used by the IIO
    core in order to read/write channels/attributes values:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct iio_info`结构用于声明IIO核心用于读取/写入通道/属性值的钩子：'
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Fields that we are not interested in have been removed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不感兴趣的字段已被移除。
- en: '`driver_module` : This is the module structure used to ensure correct ownership
    of `chrdevs` , usually set to `THIS_MODULE` .'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`driver_module`：这是用于确保`chrdevs`正确拥有权的模块结构，通常设置为`THIS_MODULE`。'
- en: '`attrs` : This represents the devices attributes.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attrs`：这代表设备的属性。'
- en: '`read_raw` : This is the callback run when the user reads a device `sysfs`
    file attribute. The `mask` parameter is a bitmask that allows us to know which
    type of value is requested. The `channel` parameter lets us know the channel concerned.
    It can be for the sampling frequency, the scale used to convert the raw value
    into usable value, or the raw value itself.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read_raw`：这是当用户读取设备`sysfs`文件属性时运行的回调。`mask`参数是一个位掩码，允许我们知道请求的是哪种类型的值。`channel`参数让我们知道所关注的通道。它可以用于采样频率、用于将原始值转换为可用值的比例，或者原始值本身。'
- en: '`write_raw` : This is the callback used to write values to the device. One
    can, for example, use it to set the sampling frequency.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write_raw`：这是用于向设备写入值的回调。例如，可以使用它来设置采样频率。'
- en: 'The following code shows how to set up a `struct iio_info` structure:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何设置`struct iio_info`结构：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: IIO channels
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IIO通道
- en: 'A channel represents a single acquisition line. An accelerometer will have,
    for example, 3 channels (X, Y, Z), since each axis represents a single acquisition
    line. `struct iio_chan_spec` is the structure that represents and describes a
    single channel in the kernel:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通道表示单个采集线。例如，加速度计将有3个通道（X、Y、Z），因为每个轴代表单个采集线。`struct iio_chan_spec`是在内核中表示和描述单个通道的结构：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following are the meanings of each element in the structure:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结构中每个元素的含义：
- en: '`type` : This specifies which type of measurement the channel makes. In case
    of voltage measurement, it should be `IIO_VOLTAGE` . For a light sensor, it is
    `IIO_LIGHT` . For an accelerometer, `IIO_ACCEL` is used. All available types are
    defined in `include/uapi/linux/iio/types.h` , as `enum iio_chan_type` . To write
    drivers for a given converter, look into that file to see the type each of your
    channels falls in.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`类型`：这指定了通道进行何种类型的测量。在电压测量的情况下，应该是`IIO_VOLTAGE`。对于光传感器，是`IIO_LIGHT`。对于加速度计，使用`IIO_ACCEL`。所有可用类型都在`include/uapi/linux/iio/types.h`中定义为`enum
    iio_chan_type`。要为给定的转换器编写驱动程序，请查看该文件，以查看每个通道所属的类型。'
- en: '`channel` : This specifies the channel index when `.indexed` is set to 1.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`通道`：当`.indexed`设置为1时，这指定了通道索引。'
- en: '`channel2` : This specifies the channel modifier when `.modified` is set to
    1.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`channel2`：当`.modified`设置为1时，这指定了通道修饰符��'
- en: '`modified` : This specifies whether a modifier is to be applied to this channel
    attribute name or not. In that case, the modifier is set in `.channel2` . (For
    example, `IIO_MOD_X` , `IIO_MOD_Y` , `IIO_MOD_Z` are modifiers for axial-sensors
    about the xyz-axis). Available modifier list is defined in the kernel IIO header
    as `enum iio_modifier` . Modifiers only mangle the channel attribute name in `sysfs`
    , not the value.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`修改`：这指定了是否要对该通道属性名称应用修饰符。在这种情况下，修饰符设置为`.channel2`。（例如，`IIO_MOD_X`，`IIO_MOD_Y`，`IIO_MOD_Z`是关于xyz轴的轴向传感器的修饰符）。可用的修饰符列表在内核IIO头文件中定义为`enum
    iio_modifier`。修饰符只会对`sysfs`中的通道属性名称进行操作，而不会对值进行操作。'
- en: '`indexed` : This specifies whether the channel attribute name has an index
    or not. If yes, the index is specified in the `.channel` field.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexed`：这指定了通道属性名称是否具有索引。如果是，则索引在`.channel`字段中指定。'
- en: '`scan_index` and `scan_type` : These fields are used to identify elements from
    a buffer, when using buffer triggers. `scan_index` sets the position of the captured
    channel inside the buffer. Channels with a lower `scan_index` will be placed before
    channels with a higher index. Setting `.scan_index` to `-1` will prevent the channel
    from buffered capture (no entry in the `scan_elements` directory).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scan_index`和`scan_type`：这些字段用于在使用缓冲区触发器时识别缓冲区中的元素。`scan_index`设置了缓冲区中捕获的通道的位置。具有较低`scan_index`的通道将放置在具有较高索引的通道之前。将`.scan_index`设置为`-1`将阻止通道进行缓冲捕获（在`scan_elements`目录中没有条目）。'
- en: 'Channel sysfs attributes exposed to user space are specified in the form of
    bitmasks. Depending on their shared information, attributes can be set into one
    of the following masks:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户空间公开的通道sysfs属性以位掩码的形式指定。根据它们的共享信息，属性可以设置为以下掩码之一：
- en: '`info_mask_separate` marks the attributes as being specific to this channel.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info_mask_separate`将属性标记为特定于此通道。'
- en: '`info_mask_shared_by_type` marks the attribute as being shared by all channels
    of the same type. The information exported is shared by all channels of the same
    type.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info_mask_shared_by_type`将属性标记为所有相同类型的通道共享的属性。导出的信息由所有相同类型的通道共享。'
- en: '`info_mask_shared_by_dir` marks the attribute as being shared by all channels
    of the same direction. The information exported is shared by all channels of the
    same direction.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info_mask_shared_by_dir`将属性标记为所有相同方向的通道共享的属性。导出的信息由相同方向的所有通道共享。'
- en: '`info_mask_shared_by_all` marks the attribute as being shared by all channels,
    whatever their type or direction may be. The information exported is shared by
    all channels. Bitmasks for enumeration of those attributes are all defined in
    `include/linux/iio/iio.h` *:*'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info_mask_shared_by_all`将属性标记为所有通道共享的属性，无论它们的类型或方向如何。导出的信息由所有通道共享。这些属性的枚举位掩码都在`include/linux/iio/iio.h`中定义。'
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The endianness field should be one of:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 字节顺序字段应为以下之一：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Channel attribute naming conventions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通道属性命名约定
- en: 'The attribute''s name is automatically generated by the IIO core with the following
    pattern: `{direction}_{type}_{index}_{modifier}_{info_mask}` :'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的名称由IIO核心自动生成，遵循以下模式：`{direction}_{type}_{index}_{modifier}_{info_mask}`：
- en: '`direction` corresponds to the attribute direction, according to the `struct
    iio_direction` structure in `drivers/iio/industrialio-core.c` :'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`方向`对应于属性方向，根据`drivers/iio/industrialio-core.c`中的`struct iio_direction`结构：'
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`type` corresponds to the channel type, according to the char array `const
    iio_chan_type_name_spec` :'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`类型`对应于通道类型，根据字符数组`const iio_chan_type_name_spec`：'
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`index` pattern depends on the channel `.indexed` field being set or not. If
    set, the index will be taken from the `.channel` field in order to replace the
    `{index}` pattern.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`模式取决于通道`.indexed`字段是否设置。如果设置，索引将从`.channel`字段中取出，以替换`{index}`模式。'
- en: '`modifier` pattern depends on the channel `.modified` field being set or not.
    If set, the modifier will be taken from the `.channel2` field, and the `{modifier}`
    pattern will be replaced according to the char array `struct iio_modifier_names`
    structure:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`modifier` 模式取决于通道`.modified`字段是否设置。如果设置，修饰符将从`.channel2`字段中取出，并且`{modifier}`模式将根据`struct
    iio_modifier_names`结构中的字符数组进行替换：'
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`info_mask` depends on the channel info mask, private or shared, indexing value
    in the char array `iio_chan_info_postfix` :'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info_mask` 取决于通道信息掩码，私有或共享，字符数组`iio_chan_info_postfix`中的索引值：'
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Distinguishing channels
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分通道
- en: 'You may find yourself in trouble when there are multiple data channels per
    channel type. The dilemma would be: how to identify them. There are two solutions
    for that: indexes and modifiers.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当每个通道类型有多个数据通道时，您可能会陷入麻烦。两种解决方案是：索引和修饰符。
- en: '**Using indexes** : Given an ADC device with one channel line, indexation is
    not needed. Its channel definition would be:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用索引**：给定一个具有一个通道线的ADC设备，不需要索引。它的通道定义将是：'
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The attribute name resulting from the preceding channel described will be `in_voltage_raw`
    .
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由前述通道描述产生的属性名称将是`in_voltage_raw`。
- en: '`/sys/bus/iio/iio:deviceX/in_voltage_raw`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`/sys/bus/iio/iio:deviceX/in_voltage_raw`'
- en: 'Now let us say the converter has 4 or even 8 channels. How do we identify them?
    The solution is to use indexes. Setting the `.indexed` field to 1 will mangle
    the channel attribute name with the `.channel` value replacing the `{index}` pattern:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设转换器有4个甚至8个通道。我们如何识别它们？解决方案是使用索引。将`.indexed`字段设置为1将使用`.channel`值替换`{index}`模式来搅乱通道属性名称：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The resulting channel attributes are:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 结果通道属性是：
- en: '`/sys/bus/iio/iio:deviceX/in_voltage0_raw`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`/sys/bus/iio/iio:deviceX/in_voltage0_raw`'
- en: '`/sys/bus/iio/iio:deviceX/in_voltage1_raw`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`/sys/bus/iio/iio:deviceX/in_voltage1_raw`'
- en: '`/sys/bus/iio/iio:deviceX/in_voltage2_raw`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`/sys/bus/iio/iio:deviceX/in_voltage2_raw`'
- en: '`/sys/bus/iio/iio:deviceX/in_voltage3_raw`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`/sys/bus/iio/iio:deviceX/in_voltage3_raw`'
- en: '**Using modifiers** : Given a light sensor with two channels—one for infrared
    light and one for both infrared and visible light, without index or modifier,
    an attribute name would be `in_intensity_raw` . Using indexes here can be error-prone,
    because it makes no sense to have `in_intensity0_ir_raw` , and `in_intensity1_ir_raw`
    . Using modifiers will help to provide meaningful attribute names. The channel''s
    definition could look like as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用修饰符**：给定一个具有两个通道的光传感器——一个用于红外光，一个用于红外和可见光，没有索引或修饰符，属性名称将是`in_intensity_raw`。在这里使用索引可能会出错，因为`in_intensity0_ir_raw`和`in_intensity1_ir_raw`是没有意义的。使用修饰符将有助于提供有意义的属性名称。通道的定义可能如下所示：'
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Resulting attributes will be:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结果属性将是：
- en: '`/sys/bus/iio/iio:deviceX/in_intensity_ir_raw` for the channel measuring IR
    intensity'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys/bus/iio/iio:deviceX/in_intensity_ir_raw` 用于测量红外强度的通道'
- en: '`/sys/bus/iio/iio:deviceX/in_intensity_both_raw` for the channel measuring
    both infrared and visible light'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys/bus/iio/iio:deviceX/in_intensity_both_raw` 用于测量红外和可见光的通道'
- en: '`/sys/bus/iio/iio:deviceX/in_illuminance_input` for the processed data'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys/bus/iio/iio:deviceX/in_illuminance_input` 用于处理后的数据'
- en: '`/sys/bus/iio/iio:deviceX/sampling_frequency` for the sampling frequency, shared
    by all'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys/bus/iio/iio:deviceX/sampling_frequency` 用于所有共享的采样频率'
- en: This is valid with accelerometer too, as we will see further on in the case
    study. For now, let's summarize what we have discussed so far in a dummy IIO driver.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于加速度计也有效，正如我们将在案例研究中看到的那样。现在，让我们总结一下到目前为止在虚拟IIO驱动程序中讨论的内容。
- en: Putting it all together
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: 'Let us summarize what we have seen so far in a simple dummy driver, which will
    expose four voltage channels. We will ignore `read()` or `write()` functions:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下到目前为止在一个简单的虚拟驱动程序中看到的内容，它将公开四个电压通道。我们将忽略`read()`或`write()`函数：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After loading the module above, we will have the following output, showing
    that our device really corresponds to the platform device we have registered:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 加载上述模块后，我们将得到以下输出，显示我们的设备确实对应于我们注册的平台设备：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following listing shows the channels that this device has, along with its
    name, which correspond exactly to what we have described in the driver:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下清单显示了此设备具有的通道及其名称，这些名称与驱动程序中描述的完全相对应：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Triggered buffer support
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发缓冲区支持
- en: 'In many data analysis applications, it is useful to be able to capture data
    based on some external signal (trigger). These triggers might be:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多数据分析应用程序中，根据某些外部信号（触发器）捕获数据是有用的。这些触发器可能是：
- en: A data ready signal
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据准备信号
- en: An IRQ line connected to some external system (GPIO or something else)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到某些外部系统的IRQ线（GPIO或其他）
- en: On-processor periodic interrupt
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器周期性中断
- en: User space reading/writing a specific file in sysfs
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户空间读/写sysfs中的特定文件
- en: IIO device drivers are completely unrelated to triggers. A trigger may initialize
    data capture on one or many devices. These triggers are used to fill buffers,
    exposed to user space as character devices.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: IIO设备驱动程序与触发器完全无关。触发器可以初始化一个或多个设备上的数据捕获。这些触发器用于填充缓冲区，向用户空间公开为字符设备。
- en: 'One can develop one''s own trigger driver, but that is beyond the scope of
    this book. We will try to focus on existing ones only. These are:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 可以开发自己的触发器驱动程序，但这超出了本书的范围。我们将尝试仅专注于现有的触发器。这些是：
- en: '`iio-trig-interrupt` : This provides support for using any IRQ as IIO triggers.
    In old kernel versions, it used to be `iio-trig-gpio` . The kernel option to enable
    this trigger mode is `CONFIG_IIO_INTERRUPT_TRIGGER` . If built as a module, the
    module would be called `iio-trig-interrupt` .'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio-trig-interrupt`：这提供了使用任何IRQ作为IIO触发器的支持。在旧的内核版本中，它曾经是`iio-trig-gpio`。启用此触发模式的内核选项是`CONFIG_IIO_INTERRUPT_TRIGGER`。如果构建为模块，该模块将被称为`iio-trig-interrupt`。'
- en: '`iio-trig-hrtimer` : This provides a frequency-based IIO trigger using HRT
    as the interrupt source (since kernel v4.5). In older kernel versions, it used
    to be `iio-trig-rtc` . The kernel option responsible for this trigger mode is
    `IIO_HRTIMER_TRIGGER` . If built as a module, the module would be called `iio-trig-hrtimer`
    .'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio-trig-hrtimer`：这提供了使用HRT作为中断源的基于频率的IIO触发器（自内核v4.5以来）。在较旧的内核版本中，它曾经是`iio-trig-rtc`。负责此触发模式的内核选项是`IIO_HRTIMER_TRIGGER`。如果作为模块构建，该模块将被称为`iio-trig-hrtimer`。'
- en: '`iio-trig-sysfs` : This allow us to use sysfs entry to trigger data capture.
    `CONFIG_IIO_SYSFS_TRIGGER` is the kernel option to add the support of this trigger
    mode.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio-trig-sysfs`：这允许我们使用sysfs条目触发数据捕获。 `CONFIG_IIO_SYSFS_TRIGGER`是内核选项，用于添加对此触发模式的支持。'
- en: '`iio-trig-bfin-timer` : This allows us to use a blackfin timer as IIO triggers
    (still in staging).'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio-trig-bfin-timer`：这允许我们将黑脸定时器用作IIO触发器（仍在暂存中）。'
- en: 'IIO exposes API so that we can:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: IIO公开API，以便我们可以：
- en: Declare any given number of triggers
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明任意数量的触发器
- en: Choose which channels will have their data pushed into buffer
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择哪些通道的数据将被推送到缓冲区
- en: When your IIO device provides the support of the trigger buffer, you must set
    `iio_dev.pollfunc` , which is executed when the trigger fires. This handler has
    the responsibility to find enabled channels through `indio_dev->active_scan_mask`
    , retrieve their data, and feed them into `indio_dev->buffer` using the `iio_push_to_buffers_with_timestamp`
    function. As such, buffers and triggers are very connected in the IIO subsystem.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的IIO设备提供触发缓冲区的支持时，必须设置`iio_dev.pollfunc`，当触发器触发时执行。此处理程序负责通过`indio_dev->active_scan_mask`找到已启用的通道，检索其数据，并使用`iio_push_to_buffers_with_timestamp`函数将其馈送到`indio_dev->buffer`中。因此，在IIO子系统中，缓冲区和触发器是非常相关的。
- en: The IIO core provides a set of helper functions to set up triggered buffers
    that one can find in `drivers/iio/industrialio-triggered-buffer.c` .
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: IIO核心提供了一组辅助函数，用于设置触发缓冲区，可以在`drivers/iio/industrialio-triggered-buffer.c`中找到。
- en: 'The following are the steps to support triggered buffers from within your driver:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是支持从驱动程序内部支持触发缓冲区的步骤：
- en: 'Fill an `iio_buffer_setup_ops` structure if needed:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，填写`iio_buffer_setup_ops`结构：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Write the top half associated to the trigger. In 99% of cases, one has to just
    feed the timestamp associated with the capture:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写与触发器相关联的上半部分。在99%的情况下，只需提供与捕获相关的时间戳：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Write the trigger bottom half, which will fetch data from each enabled channel,
    and feed them into the buffer:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写触发器的下半部分，它将从每个启用的通道中获取数据，并将其馈送到缓冲区中：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, in the `probe` function, one has to set up the buffer itself, prior
    to registering the device with `iio_device_register()` :'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`probe`函数中，必须在使用`iio_device_register()`注册设备之前设置缓冲区本身：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The magic function here is `iio_triggered_buffer_setup` . This will also give
    the `INDIO_DIRECT_MODE` capability to your device. When a trigger is given (from
    user space) to your device, you have no way of knowing when capture will be fired.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的魔术函数是`iio_triggered_buffer_setup`。这也将为您的设备提供`INDIO_DIRECT_MODE`功能。当从用户空间给您的设备触发器时，您无法知道何时会触发捕获。
- en: 'While continuous buffered capture is active, one should prevent (by returning
    an error) the driver from performing sysfs per-channel data capture (performed
    by the `read_raw()` hook) in order to avoid undetermined behavior, since both
    the trigger handler and `read_raw()` hook will try to access the device at the
    same time. The function used to check whether buffered mode is actually used is
    `iio_buffer_enabled()` . The hook will look like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在连续缓冲捕获处于活动状态时，应该防止（通过返回错误）驱动程序执行sysfs每通道数据捕获（由`read_raw()`挂钩执行），以避免未确定的行为，因为触发处理程序和`read_raw()`挂钩将尝试同时访问设备。用于检查是否实际使用了缓冲模式的函数是`iio_buffer_enabled()`。挂钩将如下所示：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `iio_buffer_enabled()` function simply tests if the buffer is enabled for
    a given IIO device.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`iio_buffer_enabled()`函数只是测试给定IIO设备是否启用了缓冲区。'
- en: 'Let us describe some important things used in the preceding section:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一些在前面部分中使用的重要内容：
- en: '`iio_buffer_setup_ops` provides buffer setup functions to be called at fixed
    step of the buffer configuration sequence (before/after enable/disable). If not
    specified, the default `iio_triggered_buffer_setup_ops` will be given to your
    device by the IIO core.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio_buffer_setup_ops`提供了在缓冲区配置序列的固定步骤（启用/禁用之前/之后）调用的缓冲区设置函数。如果未指定，默认的`iio_triggered_buffer_setup_ops`将由IIO核心提供给您的设备。'
- en: '`sensor_iio_pollfunc` is the trigger''s top half. As with every top half, it
    runs in interrupt context and must do as little processing as possible. In 99%
    of cases, you just have to feed the timestamp associated with the capture. Once
    again, one can use the default IIO `iio_pollfunc_store_time` function.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sensor_iio_pollfunc`是触发器的顶半部分。与每个顶半部分一样，它在中断上下文中运行，并且必须尽可能少地进行处理。在99%的情况下，您只需提供与捕获���关的时间戳。再次，可以使用默认的IIO
    `iio_pollfunc_store_time`函数。'
- en: '`sensor_trigger_handler` is the bottom half, which runs in a kernel thread,
    allowing us to do any processing including even acquiring mutex or sleep. The
    heavy processing should take place here. It usually reads data from the device
    and stores it in the internal buffer together with the timestamp recorded in the
    top half, and pushes it to your IIO device buffer.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sensor_trigger_handler`是底半部分，它在内核线程中运行，允许我们进行任何处理，甚至包括获取互斥锁或休眠。重要的处理应该在这里进行。它通常从设备中读取数据，并将其与顶半部分记录的时间戳一起存储在内部缓冲区中，并将其推送到您的IIO设备缓冲区中。'
- en: A trigger is mandatory for triggered buffering. It tells the driver when to
    read the sample from the device and put it into the buffer. Triggered buffering
    is not mandatory to write IIO device drivers. One can use single shot capture
    through sysfs too, by reading raw attributesof the channel, which will only perform
    a single conversion (for the channel attribute being read). Buffer mode allows
    continuous conversions, thus capturing more than one channel in a single shot.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器对于触发缓冲是强制性的。它告诉驱动程序何时从设备中读取样本并将其放入缓冲区中。触发缓冲对于编写IIO设备驱动程序并非强制性。人们也可以通过sysfs进行单次捕获，方法是读取通道的原始属性，这将仅执行单次转换（对于正在读取的通道属性）。缓冲模式允许连续转换，因此可以在一次触发中捕获多个通道。
- en: IIO trigger and sysfs (user space)
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IIO触发器和sysfs（用户空间）
- en: 'There are two locations in sysfs related to triggers:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: sysfs中与触发器相关的两个位置：
- en: '`/sys/bus/iio/devices/triggerY/` which is created once an IIO trigger is registered
    with the IIO core and corresponds to triggers with index `Y` . There is at least
    one attribute in the directory:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys/bus/iio/devices/triggerY/`一旦IIO触发器与IIO核心注册并对应于索引`Y`的触发器，将创建至少一个目录属性：'
- en: '`name` which is the trigger name that can be later used for association with
    a device'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`是触发器名称，稍后可以用于与设备关联'
- en: '`/sys/bus/iio/devices/iio:deviceX/trigger/*` directory will be automatically
    created if your device supports a triggered buffer. One can associate a trigger
    with our device by writing the trigger''s name in the `current_trigger` file.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的设备支持触发缓冲区，则将自动创建`/sys/bus/iio/devices/iio:deviceX/trigger/*`目录。可以通过将触发器的名称写入`current_trigger`文件来将触发器与我们的设备关联。
- en: Sysfs trigger interface
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sysfs触发器接口
- en: The sysfs trigger is enabled in the kernel by the `CONFIG_IIO_SYSFS_TRIGGER=y`
    config option, which will result in the `/sys/bus/iio/devices/iio_sysfs_trigger/`
    folder being automatically created, and can be used for sysfs trigger management.
    There will be two files in the directory, `add_trigger` and `remove_trigger` .
    Its driver is in `drivers/iio/trigger/iio-trig-sysfs.c` .
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`CONFIG_IIO_SYSFS_TRIGGER=y`配置选项在内核中启用sysfs触发器，将自动创建`/sys/bus/iio/devices/iio_sysfs_trigger/`文件夹，并可用于sysfs触发器管理。目录中将有两个文件，`add_trigger`和`remove_trigger`。其驱动程序位于`drivers/iio/trigger/iio-trig-sysfs.c`中。
- en: add_trigger file
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: add_trigger文件
- en: This is used to create a new sysfs trigger. You can create a new trigger by
    writing a positive value (which will be used as a trigger ID) into that file.
    It will create the new sysfs trigger, accessible at `/sys/bus/iio/devices/triggerX`
    , where `X` is the trigger number.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建新的sysfs触发器。可以通过将正值（将用作触发器ID）写入该文件来创建新的触发器。它将创建新的sysfs触发器，可在`/sys/bus/iio/devices/triggerX`访问，其中`X`是触发器编号。
- en: 'For example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will create a new sysfs trigger, accessible at `/sys/bus/iio/devices/trigger2`
    . If the trigger with the specified ID is already present in the system, an invalid
    argument message will be returned. The sysfs trigger name pattern is `sysfstrig{ID}`
    . The command `echo 2 > add_trigger` will create the trigger `/sys/bus/iio/devices/trigger2`
    whose name is `sysfstrig2` :'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的sysfs触发器，可在`/sys/bus/iio/devices/trigger2`访问。如果系统中已经存在指定ID的触发器，则会返回无效参数消息。sysfs触发器名称模式为`sysfstrig{ID}`。命令`echo
    2 > add_trigger`将创建触发器`/sys/bus/iio/devices/trigger2`，其名称为`sysfstrig2`：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Each sysfs trigger contains at least one file: `trigger_now` . Writing `1`
    into that file will instruct all devices having the corresponding trigger name
    in their `current_trigger` to start capture, and push data into their respective
    buffer. Each device buffer must have its size set, and must be enabled (`echo
    1 > /sys/bus/iio/devices/iio:deviceX/buffer/enable` ).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每个sysfs触发器至少包含一个文件：`trigger_now`。将`1`写入该文件将指示所有具有其`current_trigger`中相应触发器名称的设备开始捕获，并将数据推送到各自的缓冲区中。每个设备缓冲区必须设置其大小，并且必须启用（`echo
    1 > /sys/bus/iio/devices/iio:deviceX/buffer/enable`）。
- en: remove_trigger file
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: remove_trigger文件
- en: 'To remove a trigger, the following command is used:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除触发器，使用以下命令：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tying a device with a trigger
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将设备与触发器绑定
- en: 'Associating a device with a given trigger consists of writing the name of the
    trigger to the `current_trigger` file available under the device''s trigger directory.
    For example, let us say we need to tie a device with the trigger that has index
    2:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将设备与给定触发器关联包括将触发器的名称写入设备触发器目录下的`current_trigger`文件。例如，假设我们需要将设备与索引为2的触发器绑定：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To detach the trigger from the device, one should write an empty string to
    the `current_trigger` file of the device trigger directory, shown as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要将触发器与设备分离，应将空字符串写入设备触发器目录的`current_trigger`文件，如下所示：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We will see further on in the chapter a practical example dealing with the sysfs
    trigger for data capture.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步看到有关数据捕获的sysfs触发器的实际示例。
- en: The interrupt trigger interface
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断触发器接口
- en: 'Consider the following sample:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Declare our IRQ trigger and it will result in the IRQ trigger standalone module
    being loaded. If its `probe` function succeeds, there will be a directory corresponding
    to the trigger. IRQ trigger names have the form `irqtrigX` , where `X` corresponds
    to the virtual IRQ you just passed, the one you will see in `/proc/interrupt`
    :'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 声明我们的IRQ触发器，将导致加载IRQ触发器独立模块。如果其`probe`函数成功，将会有一个与触发器对应的目录。IRQ触发器名称的形式为`irqtrigX`，其中`X`对应于您刚刚传递的虚拟IRQ，在`/proc/interrupt`中可以看到。
- en: '[PRE36]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`irqtrig85` : As we have done with other triggers, you just have to assign
    that trigger to your device, by writing its name into your device `current_trigger`
    file.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`irqtrig85`：与其他触发器一样，您只需将该触发器分配给您的设备，方法是将其名称写入设备的`current_trigger`文件中。'
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, every time the interrupt will be fired, device data will be captured.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次触发中断时，设备数据将被捕获。
- en: The IRQ trigger driver does not support DT yet, which is the reason why we used
    our board `init` file. But it does not matter; since the driver requires a resource,
    we can use DT without any code change.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: IRQ触发器驱动程序尚不支持DT，这就是为什么我们使用了我们的板`init`文件的原因。但这并不重要；由于驱动程序需要资源，因此我们可以在不进行任何代码更改的情况下使用DT。
- en: 'The following is an example of device tree node declaring the IRQ trigger interface:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是声明IRQ触发接口的设备树节点示例：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The example supposes the IRQ line is the GPIO#30 that belongs to the GPIO controller
    node `gpio4` . This consists of using a GPIO as an interrupt source, so that whenever
    the GPIO changes to a given state, the interrupt is raised, thus triggering the
    capture.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例假设IRQ线是属于GPIO控制器节点`gpio4`的GPIO＃30。这包括使用GPIO作为中断源，因此每当GPIO变为给定状态时，中断就会被触发，从而触发捕获。
- en: The hrtimer trigger interface
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: hrtimer触发接口
- en: 'The `hrtimer` trigger relies on the configfs file system (see *Documentation/iio/iio_configfs.txt*
    in kernel sources), which can be enabled through the `CONFIG_IIO_CONFIGFS` config
    option, and mounted on our system (usually under the `/config` directory):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`hrtimer`触发器依赖于configfs文件系统（请参阅内核源中的*Documentation/iio/iio_configfs.txt*），可以通过`CONFIG_IIO_CONFIGFS`配置选项启用，并挂载到我们的系统上（通常在`/config`目录下）：'
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, loading the module `iio-trig-hrtimer` will create IIO groups accessible
    under `/config/iio` , allowing users to create hrtimer triggers under `/config/iio/triggers/hrtimer`
    .
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，加载模块`iio-trig-hrtimer`将创建可在`/config/iio`下访问的IIO组，允许用户在`/config/iio/triggers/hrtimer`下创建hrtimer触发器。
- en: 'For example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Each hrtimer trigger contains a single `sampling_frequency` attribute in the
    trigger directory. A full and working example is provided further in the chapter
    in the section *Data capture using hrtimer trigger* .
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 每个hrtimer触发器在触发目录中包含一个单独的`sampling_frequency`属性。在本章的*使用hrtimer触发进行数据捕获*部分中提供了一个完整且可用的示例。
- en: IIO buffers
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IIO缓冲区
- en: The IIO buffer offers continuous data capture, where more than one data channel
    can be read at once. The buffer is accessible from the user space through the
    `/dev/iio:device` character device node. From within the trigger handler, the
    function used to fill the buffer is `iio_push_to_buffers_with_timestamp` . The
    function responsible to allocate the trigger buffer for your device is `iio_triggered_buffer_setup()`
    .
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: IIO缓冲区提供连续数据捕获，可以同时读取多个数据通道。缓冲区可通过`/dev/iio:device`字符设备节点从用户空间访问。在触发处理程序中，用于填充缓冲区的函数是`iio_push_to_buffers_with_timestamp`。为设备分配触发缓冲区的函数是`iio_triggered_buffer_setup()`。
- en: IIO buffer sysfs interface
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IIO缓冲区sysfs接口
- en: 'An IIO buffer has an associated attributes directory under `/sys/bus/iio/iio:deviceX/buffer/*`
    . Here are some of the existing attributes:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: IIO缓冲区在`/sys/bus/iio/iio:deviceX/buffer/*`下有一个关联的属性目录。以下是一些现有属性：
- en: '`length` : The total number of data samples (capacity) that can be stored by
    the buffer. This is the number of scans contained by the buffer.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`：缓冲区可以存储的数据样本（容量）的总数。这是缓冲区包含的扫描数。'
- en: '`enable` : This activates buffer capture, start the buffer capture.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enable`：这将激活缓冲区捕获，启动缓冲区捕获。'
- en: '`watermark` : This attribute has been available since kernel version v4.2\.
    It is a positive number which specifies how many scan elements a blocking read
    should wait for. If using `poll` for example, it will block until the watermark
    is reached. It makes sense only if the watermark is greater than the requested
    amount of reads. It does not affect non-blocking reads. One can block on poll
    with a timeout and read the available samples after the timeout expires, and thus
    have a maximum delay guarantee.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`watermark`：此属性自内核版本v4.2起可用。它是一个正数，指定阻塞读取应等待多少个扫描元素。例如，如果使用`poll`，它将阻塞直到达到水印。只有在水印大于请求的读取量时才有意义。它不影响非阻塞读取。可以在带有超时的poll上阻塞，并在超时到期后读取可用样本，从而保证最大延迟。'
- en: IIO buffer setup
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IIO缓冲区设置
- en: 'A channel whose data is to be read and pushed into the buffer is called a scan
    element. Their configurations are accessible from the user space through the `/sys/bus/iio/iio:deviceX/scan_elements/*`
    directory, containing the following attributes:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取并推送到缓冲区的数据通道称为扫描元素。它们的配置可通过`/sys/bus/iio/iio:deviceX/scan_elements/*`目录从用户空间访��，包含以下属性：
- en: '`en` (actually a suffix for attribute name), is used to enable the channel.
    If and only if its attribute is non-zero, then a triggered capture will contain
    data samples for this channel. For example, `in_voltage0_en` , `in_voltage1_en`
    and so on.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`en`（实际上是属性名称的后缀）用于启用通道。仅当其属性非零时，触发捕获才会包含此通道的数据样本。例如，`in_voltage0_en`，`in_voltage1_en`等。'
- en: '`type` describes the scan element data storage within the buffer, and hence
    the form in which it is read from user space. For example, `in_voltage0_type`
    . The format is `[be|le]:[s|u]bits/storagebitsXrepeat[>>shift]` .'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`描述了缓冲区内的扫描元素数据存储方式，因此也描述了从用户空间读取的形式。例如，`in_voltage0_type`。格式为`[be|le]:[s|u]bits/storagebitsXrepeat[>>shift]`。'
- en: '`be` or `le` specifies the endianness (big or little).'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`be`或`le`指定字节顺序（大端或小端）。'
- en: '`s` or `u` specifies the sign, either signed (2''s complement) or unsigned.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`或`u`指定符号，即有符号（2的补码）或无符号。'
- en: '`bits` is the number of valid data bits.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bits`是有效数据位数。'
- en: '`storagebits` is the number of bits this channel occupies in the buffer. That
    said, a value may be really coded in 12 bits (**bits** ), but occupies 16 bits
    (**storagebits** ) in the buffer. One must therefore shift the data four times
    to the right to obtain the actual value. This parameter depends on the device,
    and one should refer to its data sheet.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storagebits`是该通道在缓冲区中占用的位数。也就是说，一个值可能实际上是用12位编码（**bits**），但在缓冲区中占用16位（**storagebits**）。因此，必须将数据向右移动四次才能获得实际值。此参数取决于设备，应参考其数据表。'
- en: '`shift` represents the number of times one should shift the data value prior
    to masking out unused bits. This parameter is not always needed. If the number
    of valid bit (**bits** ) is equal to the number of storage bits, the shift will
    be 0\. One can also find this parameter in the device data sheet.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shift`表示在屏蔽未使用的位之前应移动数据值的次数。此参数并非总是需要的。如果有效位数（**bits**）等于存储位数，则移位将为0。也可以在设备数据表中找到此参数。'
- en: '`repeat` specifies the number of bit/storagebit repetitions. When the repeat
    element is 0 or 1, then the repeat value is omitted.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeat`指定位/存储位重复的次数。当重复元素为0或1时，重复值被省略。'
- en: 'The best way to explain this section is by an excerpt of kernel doc, which
    can find here: [https://www.kernel.org/doc/html/latest/driver-api/iio/buffers.html](https://www.kernel.org/doc/html/latest/driver-api/iio/buffers.html)
    . For example, a driver for a 3-axis accelerometer, with 12-bit resolution where
    data is stored in two 8-bit registers, is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 解释这一部分的最佳方法是通过内核文档的摘录，可以在这里找到：[https://www.kernel.org/doc/html/latest/driver-api/iio/buffers.html](https://www.kernel.org/doc/html/latest/driver-api/iio/buffers.html)。例如，一个具有12位分辨率的3轴加速度计的驱动程序，其中数据存储在两个8位寄存器中，如下所示：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'will have the following scan element type for each axis:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每个轴将具有以下扫描元素类型：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: One should interpret this as being little endian-signed data, 16 bits-sized,
    which needs to be shifted right by 4 bits before masking out the 12 valid bits
    of data.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 应该将其解释为小端符号数据，16位大小，需要在屏蔽掉12个有效数据位之前向右移4位。
- en: The element in `struct iio_chan_spec` that is responsible for determining how
    a channel's value should be stored into the buffer is `scant_type` .
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct iio_chan_spec`中负责确定通道值如何存储到缓冲区的元素是`scant_type`。'
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This structure absolutely matches `[be|le]:[s|u]bits/storagebitsXrepeat[>>shift]`
    , which is the pattern described in the previous section. Let us have a look at
    each member of the structure:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构绝对匹配`[be|le]:[s|u]bits/storagebitsXrepeat[>>shift]`，这是前一节中描述的模式。让我们来看看结构的每个成员：
- en: '`sign` represents the sign of the data and matches `[s|u]` in the pattern'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sign`表示数据的符号，并匹配模式中的`[s|u]`。'
- en: '`realbits` corresponds to `bits` in the pattern'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`realbits`对应于模式中的`bits`'
- en: '`storagebits` matches the same name in the pattern'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storagebits`与模式中的相同名称匹配'
- en: '`shift` corresponds to shift in the pattern, same for `repeat`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shift`对应于模式中的shift，`repeat`也是一样的'
- en: '`iio_indian` represents the endianness and matches `[be|le]` in the pattern'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio_indian`表示字节序，与模式中的`[be|le]`匹配'
- en: 'At this point, one is able to write the IIO channel structure that corresponds
    to the type previously explained:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，可以编写与先前解释的类型相对应的IIO通道结构：
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Putting it all together
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: 'Let us have a closer look at the digital triaxial acceleration sensor BMA220
    from BOSH. This is an SPI/I2C-compatible device, with 8 bit-sized registers, along
    with an on-chip motion-triggered interrupt controller, which actually senses tilt,
    motion, and shock vibration. Its data sheet is available at: [http://www.mouser.fr/pdfdocs/BSTBMA220DS00308.PDF](http://www.mouser.fr/pdfdocs/BSTBMA220DS00308.PDF)
    , and its driver has been introduced since kernel v4.8 (`CONFIG_BMA200` ). Let
    us walk through it:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下BOSH的数字三轴加速度传感器BMA220。这是一个SPI/I2C兼容设备，具有8位大小的寄存器，以及一个片上运动触发中断控制器，实际上可以感应倾斜、运动和冲击振动��其数据表可在以下网址找到：[http://www.mouser.fr/pdfdocs/BSTBMA220DS00308.PDF](http://www.mouser.fr/pdfdocs/BSTBMA220DS00308.PDF)，其驱动程序自内核v4.8以来已经被引入（`CONFIG_BMA200`）。让我们来看一下：
- en: 'Firstly, we declare our IIO channels using `struct iio_chan_spec` . Once the
    triggered buffer is used, then we need to fill the `.scan_index` and `.scan_type`
    fields:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`struct iio_chan_spec`声明我们的IIO通道。一旦触发缓冲区被使用，我们需要填充`.scan_index`和`.scan_type`字段：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`.info_mask_separate = BIT(IIO_CHAN_INFO_RAW)` says there will be a `*_raw`
    sysfs entry (attribute) for each channel, and `.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE)`
    says that there is only a `*_scale` sysfs entry for all channels of the same type:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`.info_mask_separate = BIT(IIO_CHAN_INFO_RAW)`表示每个通道将有一个`*_raw` sysfs条目（属性），`.info_mask_shared_by_type
    = BIT(IIO_CHAN_INFO_SCALE)`表示所有相同类型的通道只有一个`*_scale` sysfs条目：'
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Reading `in_accel_scale` calls the `read_raw()` hook with the mask set to `IIO_CHAN_INFO_SCALE`
    . Reading `in_accel_x_raw` calls the `read_raw()` hook with the mask set to `IIO_CHAN_INFO_RAW`
    . The real value is therefore `raw_value * scale` .
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 读取`in_accel_scale`调用`read_raw()`钩子，将mask设置为`IIO_CHAN_INFO_SCALE`。读取`in_accel_x_raw`调用`read_raw()`钩子，将mask设置为`IIO_CHAN_INFO_RAW`。因此，真实值是`raw_value
    * scale`。
- en: 'What `.scan_type` says is that the value returned by each channel is, 8 bit-sized
    (will occupy 8 bits in the buffer), but the useful payload only occupies 6 bits,
    and the data must be right-shifted 2 times prior to masking out unused bits. Any
    scan element type will look like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`.scan_type`表示每个通道返回的值是8位大小（将占用缓冲区中的8位），但有用的有效载荷只占用6位，并且数据必须在屏蔽未使用的位之前右移2次。任何扫描元素类型都将如下所示：'
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following is our `pollfunc` (actually it is the bottom half), which reads
    samples from the device and pushes read values into the buffer (`iio_push_to_buffers_with_timestamp()`
    ). Once done, we inform the core (`iio_trigger_notify_done()` ):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的`pollfunc`（实际上是底部），它从设备中读取样本并将读取的值推送到缓冲区（`iio_push_to_buffers_with_timestamp()`）。完成后，我们通知核心（`iio_trigger_notify_done()`）：
- en: '[PRE48]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following is the `read` function. It is a hook, called every time one reads
    a sysfs entry of the device:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`read`函数。这是一个钩子，每次读取设备的sysfs条目时都会调用它：
- en: '[PRE49]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When one reads a `*raw` sysfs file, the hook is called, given `IIO_CHAN_INFO_RAW`
    in the `mask` parameter, and the corresponding channel in the `*chan` parameter.
    `*val` and `val2` are actually output parameters. They must be set with the raw
    value (read from the device). Any read performed on the `*scale` sysfs file will
    call the hook with `IIO_CHAN_INFO_SCALE` in mask parameter, and so on for each
    attribute mask.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当读取`*raw` sysfs文件时，将调用该钩子，`mask`参数中给出`IIO_CHAN_INFO_RAW`，并且`*val`和`val2`实际上是输出参数。它们必须设置为原始值（从设备中读取）。对`*scale`
    sysfs文件的任何读取都将调用带有`IIO_CHAN_INFO_SCALE`的`mask`参数的钩子，以及每个属性掩码。
- en: 'This is also the case with the `write` function, used to write value into the
    device. There is an 80% chance your driver does not require a `write` function.
    This `write` hook lets the user change the device''s scale:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于`write`函数，用于将值写入设备。你的驱动程序有80%的可能不需要`write`函数。这个`write`钩子允许用户更改设备的比例：
- en: '[PRE50]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This function is called whenever one writes a value to the device. Frequently
    changed parameters are the scale. An example could be: `echo <desired-scale> >
    /sys/bus/iio/devices/iio;devices0/in_accel_scale` .'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 每当写入设备时，都会调用此函数。经常更改的参数是比例。例如：`echo <desired-scale> > /sys/bus/iio/devices/iio;devices0/in_accel_scale`。
- en: 'Now, it comes to fill a `struct iio_info` structure, to be given to our `iio_device`
    :'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要填写一个`struct iio_info`结构，以提供给我们的`iio_device`：
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the `probe` function, we allocate and set up a `struct iio_dev` IIO device.
    Memory for private data is reserved too:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在`probe`函数中，我们分配并设置了一个`struct iio_dev` IIO设备。私有数据的内存也被保留：
- en: '[PRE52]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: One can enable this driver by means of the `CONFIG_BMA220` kernel option. That
    said, this is available only from v4.8 onwards in kernel. The closest device one
    can use for this on older kernel versions is BMA180, which one can enable using
    the `CONFIG_BMA180` option.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`CONFIG_BMA220`内核选项启用此驱动程序。也就是说，这仅在内核v4.8及以后版本中可用。在旧版本的内核中，可以使用`CONFIG_BMA180`选项启用最接近的设备。
- en: IIO data access
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IIO数据访问
- en: You may have guessed that there are only two ways to access data with the IIO
    framework; one-shot capture through sysfs channels, or continuous mode (triggered
    buffer) through an IIO character device.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经猜到，使用IIO框架访问数据只有两种方式；通过sysfs通道进行一次性捕获，或通过IIO字符设备进行连续模式（触发缓冲区）。
- en: One-shot capture
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一次性捕获
- en: 'One-shot data capture is done through sysfs interface. By reading the sysfs
    entry that corresponds to a channel, you''ll capture only the data specific to
    that channel. Given a temp sensor with two channels: one for the ambient temp,
    and the other for the thermocouple temp:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性数据捕获是通过sysfs接口完成的。通过读取与通道对应的sysfs条目，您将仅捕获与该通道特定的数据。假设有一个具有两个通道的温度传感器：一个用于环境温度，另一个用于热电偶温度：
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Processed value is obtained by multiplying the scale by the raw value.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将比例乘以原始值来获得处理后的值。
- en: '`Voltage value` : `6646 * 0.305175781 = 2028.19824053`'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`电压值`：`6646 * 0.305175781 = 2028.19824053`'
- en: The device datasheet says the process value is given in MV. In our case, it
    corresponds to 2.02819V.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 设备数据表说明处理值以MV为单位。在我们的情况下，它对应于2.02819V。
- en: Buffer data access
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲区数据访问
- en: 'To get a triggered acquisition working, the trigger support must have been
    implemented in your driver. Then, to acquire data from within user space, one
    must: create a trigger, assign it, enable the ADC channels, set the dimension
    of the buffer, and enable it). Here is the code for this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要使触发采集工作，触发支持必须已经在您的驱动程序中实现。然后，要从用户空间获取数据，必须：创建触发器，分配它，启用ADC通道，设置缓冲区的维度，并启用它）。以下是此代码：
- en: Capturing using the sysfs trigger
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sysfs触发器进行捕获
- en: 'Capturing data using the sysfs trigger consists of sending a set of command
    few sysfs files. Let us enumerate what we should do to achieve that:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 使用sysfs触发器捕获数据包括发送一组命令到sysfs文件。让我们列举一下我们应该做什么来实现这一点：
- en: '**Create the trigger** : Before the trigger can be assigned to any device,
    it should be created:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建触发器**：在触发器可以分配给任何设备之前，它应该被创建：'
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, `0` corresponds to the index we need to assign to the trigger. After this
    command, the trigger directory will be available under `*/sys/bus/iio/devices/*`
    , as `trigger0` .
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`0`对应于我们需要分配给触发器的索引。在此命令之后，触发器目录将在`*/sys/bus/iio/devices/*`下作为`trigger0`可用。
- en: '**Assign the trigger to the device** : A trigger is uniquely identified by
    its name, which we can use in order to tie device to the trigger. Since we used
    0 as index, the trigger will be named `sysfstrig0` :'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将触发器分配给设备**：触发器通过其名称唯一标识，我们可以使用它来将设备与触发器绑定。由于我们使用0作为索引，触发器将被命名为`sysfstrig0`：'
- en: '[PRE55]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We could have used this command too: `cat /sys/bus/iio/devices/trigger0/name
    > /sys/bus/iio/devices/iio:device0/trigger/current_trigger` . That said, if the
    value we wrote does not correspond to an existing trigger name, nothing will happen.
    To make sure we really defined a trigger, we can use `cat /sys/bus/iio/devices/iio:device0/trigger/current_trigger`
    .'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用这个命令：`cat /sys/bus/iio/devices/trigger0/name > /sys/bus/iio/devices/iio:device0/trigger/current_trigger`。也就是说，如果我们写入的值与现有的触发器名称不对应，什么也不会发生。为了确保我们真的定义了一个触发器，我们可以使用`cat
    /sys/bus/iio/devices/iio:device0/trigger/current_trigger`。
- en: '**Enable some scan elements** : This step consists of choosing which channels
    should have their data value pushed into the buffer. One should pay attention
    to `available_scan_masks` in the driver:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启用一些扫描元素**：这一步包括选择哪些通道的数据值应该被推送到缓冲区中。在驱动程序中应该注意`available_scan_masks`：'
- en: '[PRE56]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '**Setup the buffer size** : Here one should set the number of sample sets that
    may be held by the buffer:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设置缓冲区大小**：在这里，应该设置缓冲区可以容纳的样本集的数量：'
- en: '[PRE57]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**Enable the buffer** : This step consists of marking the buffer as being ready
    to receive pushed data:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启用缓冲区**：这一步包括将缓冲区标记为准备好接收推送数据：'
- en: '[PRE58]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To stop the capture, we'll have to write 0 in the same file.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止捕获，我们必须在同一文件中写入0。
- en: '**Fire the trigger** : Launch acquisition:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**触发**：启动采集：'
- en: '[PRE59]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now acquisition is done, we can:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在采集完成了，我们可以：
- en: 'Disable the buffer:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用缓冲区：
- en: '[PRE60]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Detach the trigger:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分离触发器：
- en: '[PRE61]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Dump the content of our IIO character device:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转储我们的IIO字符设备的内容：
- en: '[PRE62]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Capturing using the hrtimer trigger
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用hrtimer触发进行捕获
- en: 'The following is the set of commands that allow to capture data using hrtimer
    trigger:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一组命令，允许使用hrtimer触发来捕获数据：
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'And, we look at the type to figure out how to process data:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，我们查看类型以确定如何处理数据：
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Voltage processing: `0x188 >> 2 = 98 * 250 = 24500 = 24.5 v`'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 电压处理：`0x188 >> 2 = 98 * 250 = 24500 = 24.5 v`
- en: IIO tools
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IIO工具
- en: 'There are some useful tools you can use in order to ease and speed up your
    app''s development with IIO devices. They are available in `tools/iio` in the
    kernel tree:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些有用的工具可以帮助您简化和加快使用IIO设备开发应用程序的过程。它们在内核树中的`tools/iio`中可用：
- en: '`lsiio.c` **:** To enumerate IIO triggers, devices, and channels'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lsiio.c` **：** 枚举IIO触发器、设备和通道'
- en: '`iio_event_monitor.c` : Monitor an IIO device''s ioctl interface for IIO events'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iio_event_monitor.c`：监视IIO设备的ioctl接口以获取IIO事件'
- en: '`generic_buffer.c` : To retrieve, process, and print data received from an
    IIO device''s buffer'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generic_buffer.c`：从IIO设备的缓冲区中检索、处理和打印数据'
- en: '`libiio` : A powerful library developed by analog device to interface IIO devices,
    and available at [https://github.com/analogdevicesinc/libiio](https://github.com/analogdevicesinc/libiio)
    .'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libiio`：由模拟设备开发的强大库，用于与IIO设备进行接口交互，可在[https://github.com/analogdevicesinc/libiio](https://github.com/analogdevicesinc/libiio)上获得。'
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'By the end of this chapter, you should now be familiar with IIO framework and
    vocabulary. You know what channels, device, and triggers are. You can even play
    with your IIO device from the user space, through sysfs or character device. The
    time to write your own IIO driver has come. There are a lot of available existing
    drivers not supporting trigger buffers. You can try to add such features in one
    of them. In the next chapter, we will play with the most useful/used resource
    on a system: the memory. Be strong, the game has just started.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该已经熟悉了IIO框架和词汇。您知道通道、设备和触发器是什么。您甚至可以通过用户空间、sysfs或字符设备与您的IIO设备进行交互。现在是编写自己的IIO驱动程序的时候了。有很多现有的驱动程序不支持触发缓冲区。您可以尝试在其中一个驱动程序中添加这样的功能。在下一章中，我们将使用系统上最有用/最常用的资源：内存。要坚强，游戏刚刚开始。
