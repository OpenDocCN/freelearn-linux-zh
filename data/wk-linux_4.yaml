- en: Chapter 4. CLI – The Hidden Recipe
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。CLI - 隐藏的配方
- en: This chapter will start by focusing on sed, one of the tools that can scare
    a lot of Linux users. We will look at some basic `sed` commands that could make
    hours of refractor turn into a few minutes. We will see how you can locate any
    file by using Linux puter. Furthermore, we will see just how remote work will
    get a whole lot better when Tmux enters our skill set. You can run long lasting
    commands, split screens, and never lose your work with the help of the best terminal
    multiplexor. Then, you will learn how to discover and interact with your network
    with the help of commands like netstat and nmap. Lastly, we will see how Autoenv
    helps switch environments automatically and how to use rm command to interact
    with trash from command line using the trash utility.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将首先关注sed，这是一个可以吓到很多Linux用户的工具之一。我们将看一些基本的`sed`命令，可以将几个小时的重构工作缩短为几分钟。我们将看到如何使用Linux计算机定位任何文件。此外，我们还将看到当Tmux进入我们的技能集时，远程工作将变得更好。您可以使用最好的终端复用器运行长时间的命令，分割屏幕，并且不会丢失工作。然后，您将学习如何使用netstat和nmap等命令发现和与您的网络进行交互。最后，我们将看到Autoenv如何自动切换环境，以及如何使用rm命令通过命令行使用垃圾箱实用程序与垃圾进行交互。
- en: 'In this chapter, we will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Understanding the working of sed
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解sed的工作原理
- en: Working with tmux, a terminal multiplexer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用tmux，一个终端复用器
- en: Automatically switching environments using Autoenv
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Autoenv自动切换环境
- en: Using rm command line to remove (delete) files or directories
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用rm命令行删除文件或目录
- en: Sed – one-liner productivity treasure
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sed – one-liner productivity treasure
- en: If a picture is worth 1000 words, then sed one liners are definitely worth a
    thousand lines of code! One of the most feared commands in the Linux CLI is, you
    guessed it, sed! It's been feared by programmers and sysadmins everywhere, because
    of it's cryptic usage, but it can serve as a very powerful tool for quickly editing
    large amounts of data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一张图片价值1000个字，那么sed一行命令绝对相当于一千行代码！在Linux CLI中，最令人恐惧的命令之一就是，你猜对了，sed！由于其晦涩的用法，它一直被程序员和系统管理员所恐惧，但它可以作为一个非常强大的工具，快速编辑大量的数据。
- en: 'We have created five files to help demonstrate the power of this awesome tool.
    The first one is a simple file containing the humble line of text: *Orange is
    the new black*. Let''s start by creating a simple `sed` command to replace the
    word *black* with *white*.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了五个文件来演示这个强大工具的功能。第一个文件是一个简单的文件，包含了一行谦虚的文本：*橙色是新的黑色*。让我们从创建一个简单的`sed`命令开始，将单词*black*替换为*white*。
- en: The first argument of sed is the replace command. It's divided into 3 parts
    by 3 `/`. The first part is `s` for substitute, the second part is the word to
    be replaced, `black`, in our case, and the third part is the replacement word,
    `white`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: sed的第一个参数是替换命令。它由3个`/`分成3个部分。第一部分是`s`表示替换，第二部分是要替换的单词，在我们的例子中是`black`，第三部分是替换后的单词`white`。
- en: 'The second argument is the input, in our case, a file:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是输入，对我们来说是一个文件：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Sed – one-liner productivity treasure](img/image_04_001.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![Sed – one-liner productivity treasure](img/image_04_001.jpg)'
- en: Now, the result will be printed on the screen, and you can see the word black
    has been replaced by white.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，结果将被打印在屏幕上，您可以看到单词black已被替换为white。
- en: Our second example contains yet another line of text, this time with the word
    black in both upper and lower case. If we run the same command using this new
    file, we will see that it replaces only the word that matches the case. If we
    want to do a case insensitive replace, we will add two more characters to the
    end of our `sed` command; `g` and `l`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二个示例包含另一行文本，这次包含了大小写都为黑色的单词。如果我们使用这个新文件运行相同的命令，我们将看到它只替换与大小写匹配的单词。如果我们想进行不区分大小写的替换，我们将在`sed`命令的末尾添加两个字符；`g`和`l`。
- en: '`g`: It means global replace, used for replacing all the occurrences in the
    file. Without this, it will only replace the first argument.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`：表示全局替换，用于替换文件中的所有出现。如果没有这个参数，它只会替换第一个参数。'
- en: '`l`: means case insensitive search.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l`：表示不区分大小写搜索。'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Sed – one-liner productivity treasure](img/image_04_002.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![Sed – one-liner productivity treasure](img/image_04_002.jpg)'
- en: And as you can see, both words have been replaced. If we want to save the results
    in our file instead of printing to the screen, we use the `-i` argument, which
    stands for inline replace.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，两个单词都被替换了。如果我们想将结果保存在文件中而不是打印到屏幕上，我们使用`-i`参数，它表示内联替换。
- en: 'In some scenarios, we might also want to save our initial files, just in case
    we have an error in the `sed` command. To do this, we specify a suffix after `-i`
    which will create a backup file. In our case, we use the `.bak` suffix:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能还希望保存我们的初始文件，以防我们在`sed`命令中出现错误。为此，我们在`-i`之后指定一个后缀，它将创建一个备份文件。在我们的例子中，我们使用`.bak`后缀：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Sed – one-liner productivity treasure](img/image_04_003.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Sed – one-liner productivity treasure](img/image_04_003.jpg)'
- en: If we check the content of the files, we can see that the initial file contains
    the updated text, and the backup file contains the original text.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查文件的内容，我们可以看到初始文件包含更新后的文本，备份文件包含原始文本。
- en: 'Now, let''s look at a more practical example. Let''s say we have a shell script
    that contains multiple variables and we want to surround our variables with curly
    brackets:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个更实际的例子。假设我们有一个包含多个变量的shell脚本，我们想用花括号括起来：
- en: '![Sed – one-liner productivity treasure](img/image_04_004.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Sed – one-liner productivity treasure](img/image_04_004.jpg)'
- en: 'In order to do this we will write:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个，我们将写下以下命令：
- en: '`s`: It''s for substitute.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`：表示替换。'
- en: '`g`: It''s for global; meaning replace all occurrences found.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`：表示全局；意思是替换所有找到的出现。'
- en: '`\$`: This matches all strings starting with the dollar sign. Here dollar needs
    to be escaped, so that it''s not confused with the *start of the row* anchor.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\$`：匹配以美元符号开头的所有字符串。这里需要转义美元符号，以免与*行的开头*锚点混淆。'
- en: We will enclose the string following `$` in (), so that we can reference it
    in the replace part of our command.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在`$`后面的字符串括起来，这样我们就可以在命令的替换部分中引用它。
- en: '`[ ]`: This is for specifying a range of characters'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ ]`：用于指定一系列字符'
- en: '`A-Z`: It matches all uppercase characters'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A-Z`：它匹配所有大写字符'
- en: '`0-9`: It matches all numbers'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0-9`：它匹配所有数字'
- en: '`_`: It matches `_`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_`：它匹配`_`'
- en: '`\+`: Any character in the `[ ]` must appear one or multiple times'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\+`：在`[ ]`中的任何字符必须出现一次或多次'
- en: 'In the replace part, we will use:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在替换部分，我们将使用：
- en: '`\$`: The dollar sign'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\$`：美元符号'
- en: '`{ }`: The curly brackets we want to add.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ }`：我们要添加的花括号。'
- en: '`\1`: The string that was previously matched in the ( )'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\1`：之前在( )中匹配的字符串'
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Sed – one-liner productivity treasure](img/image_04_005.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Sed – one-liner productivity treasure](img/image_04_005.jpg)'
- en: Other common scenarios are replacing content in `xml` or `html` files.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 其他常见的情况是替换`xml`或`html`文件中的内容。
- en: 'Here we have a basic html file with a `<strong>` text inside. Now, we know
    that the `<strong>` text has more semantic value for search engine optimizations,
    so maybe we want to make our strong tags be a simple `<b>` (bold), and manually
    decide the `<strong>` words in the page. For this we say:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一个带有`<strong>`文本的基本html文件。现在，我们知道`<strong>`文本对于搜索引擎优化具有更多的语义价值，所以也许我们想让我们的强调标签成为一个简单的`<b>`（加粗），并手动决定页面上的`<strong>`单词。为此，我们说：
- en: '`s`: This is for substitute.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`：这是用于替换的。'
- en: '`<strong`: The actual text we are searching for.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<strong`：我们要搜索的实际文本。'
- en: '`\( \)`: This will be used again for selecting a piece of text, that will be
    added back.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\(\)`：这将再次用于选择一段文本，然后将其添加回去。'
- en: '`.*`: This means any character, found any number of times. We want to select
    everything between "`<strong`" and "`strong>`".'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.*`：这意味着任何字符，出现任意次数。我们想选择"`<strong`"和"`strong>`"之间的所有内容。'
- en: '`</`: This is the closing of the tag. This, we want to keep intact.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`</`：这是标签的关闭。我们要保持它不变。'
- en: '`<b\1b>`: Just add `<b b>`, and the text that you previously found in the `(
    )`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<b\1b>`：只需添加`<b b>`，以及之前在`( )`中找到的文本。'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Sed – one-liner productivity treasure](img/image_04_006.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Sed – one-liner productivity treasure](img/image_04_006.jpg)'
- en: 'As you can see, the text was updated correctly, the `red` class still applies
    to the new tag, and the old text is still contained between our tags, which is
    exactly what we wanted:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，文本被正确更新，`red`类仍然适用于新标签，旧文本仍然包含在我们的标签之间，这正是我们想要的：
- en: '![Sed – one-liner productivity treasure](img/image_04_007.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Sed – one-liner productivity treasure](img/image_04_007.jpg)'
- en: 'Besides replacing, sed can also be used for deleting lines of text. Our `5.txt`
    file contains all the words from the `lorem ipsum` text. If we wanted to delete
    the third line of text, we would issue the command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了替换，sed还可以用于删除文本行。我们的`5.txt`文件包含了`lorem ipsum`文本中的所有单词。如果我们想删除第三行的文本，我们将发出以下命令：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Hit *:e,* to reload the file in vim, and we see the word `dolor` is no longer
    there. If, for example, we wanted to delete the first 10 lines of the file, we''d
    simply run:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*:e,*在vim中重新加载文件，我们可以看到单词`dolor`不再存在。例如，如果我们想删除文件的前10行，我们只需运行：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Hit *:e*, and you see the lines are no longer there. For our last example,
    if we scroll down, we can see multiple empty lines of text. These can be deleted
    with:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*:e*，你会看到这些行不再存在。对于我们的最后一个例子，如果我们向下滚动，我们可以看到多个空行。可以使用以下命令删除这些行。
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Sed – one-liner productivity treasure](img/image_04_008.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Sed – one-liner productivity treasure](img/image_04_008.jpg)'
- en: 'Which stands for:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它代表：
- en: '`^`: Beginning of line anchor'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^`：行首锚点'
- en: '`$`: End of line anchor'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`：行尾锚点'
- en: '`d`: Delete'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`：删除'
- en: Reload the file, and you see that the lines are no longer there.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载文件，你会看到这些行不再存在。
- en: Now, as you can imagine, these have only been some basic examples. The power
    of sed is much greater than this, and there are many more possibilities of using
    it than what we have seen today. We recommend that you gain a good understanding
    of the features presented here today, as these are the features you will probably
    use the most. It's not as complicated as it might seem at first, and it really
    comes in handy in lots of scenarios.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如你所想象的那样，这只是一些基本的例子。sed的功能远远超过这个，使用它的可能性比我们今天看到的还要多得多。我们建议你对今天介绍的功能有一个很好的理解，因为这些功能可能是你最常使用的。它并不像一开始看起来那么复杂，在许多场景中非常方便。
- en: You can run, but you can't hide… from find
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你可以逃跑，但你无法躲避...来自find
- en: 'Tens of projects, hundreds of folders and thousands of file; does this scenario
    sound familiar? If the answer is *yes*, then you probably found yourself more
    than once in a situation where you couldn''t find a specific file. The `find`
    command will help us locate any file in our project and much more. But first,
    for creating a quick playground, let''s download the electron open source project
    from GitHub:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数十个项目，数百个文件夹和数千个文件；这个场景听起来熟悉吗？如果答案是“是”，那么你可能不止一次发现自己无法找到特定的文件。`find`命令将帮助我们在项目中定位任何文件以及更多其他功能。但首先，为了创建一个快速的游乐场，让我们从GitHub下载electron开源项目：
- en: Git clone [https://github.com/electron/electron](https://github.com/electron/electron)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Git克隆[https://github.com/electron/electron](https://github.com/electron/electron)
- en: 'And `cd` into it:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`cd`进入它：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We see here lots of different files and folders, just like in any normal sized
    software project. In order to find a particular file, let''s say `package.json`,
    we will use:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到了许多不同的文件和文件夹，就像在任何一个正常大小的软件项目中一样。为了找到一个特定的文件，比如`package.json`，我们将使用：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![You can run, but you can''t hide… from find](img/image_04_009.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![You can run, but you can''t hide… from find](img/image_04_009.jpg)'
- en: '`.`: This starts the search in the current folder'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`.`：这在当前文件夹中开始搜索'
- en: '`-name`: This helps to search the file name'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`-name`：这有助于搜索文件名'
- en: 'If we were to look for all readme files in the project, the previous command
    format is not helpful. We need to issue a case insensitive find. For demonstration
    purposes, we will also create a `readme.md` file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要在项目中查找所有的readme文件，前面的命令格式是没有帮助的。我们需要发出一个不区分大小写的查找命令。为了演示目的，我们还将创建一个`readme.md`文件：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will also use the `-iname` argument for case insensitive search:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`-iname`参数进行不区分大小写的搜索：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![You can run, but you can''t hide… from find](img/image_04_010.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![You can run, but you can''t hide… from find](img/image_04_010.jpg)'
- en: 'You see here that both `readme.md` and `README.md` have been found. Now, if
    we were to search for all JavaScript files we would use:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里找到了`readme.md`和`README.md`。现在，如果我们要搜索所有JavaScript文件，我们将使用：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![You can run, but you can''t hide… from find](img/image_04_011.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![你可以跑，但你无法躲避...来自find](img/image_04_011.jpg)'
- en: 'And as you can see, there are quite a few results. For narrowing down our results,
    let''s limit the find to the `default_app` folder:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，有相当多的结果。为了缩小结果范围，让我们将find限制在`default_app`文件夹中：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![You can run, but you can''t hide… from find](img/image_04_012.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![你可以跑，但你无法躲避...来自find](img/image_04_012.jpg)'
- en: 'As you can see, there are only two `js` files in this folder. And if we were
    to find all files that are not JavaScript, just add a `!` mark before the name
    argument:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个文件夹中只有两个`js`文件。如果我们要找到所有不是JavaScript的文件，只需在名称参数之前加上`!`标记：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![You can run, but you can''t hide… from find](img/image_04_013.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![你可以跑，但你无法躲避...来自find](img/image_04_013.jpg)'
- en: 'You can see here all files that don''t end their name with `js`. If we were
    to look for all inodes in the directory, which are of type file, we would use
    the `-type f` argument:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这里所有不以`js`结尾的文件。如果我们要查找目录中的所有类型为文件的inode，我们将使用`-type f`参数：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![You can run, but you can''t hide… from find](img/image_04_014.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![你可以跑，但你无法躲避...来自find](img/image_04_014.jpg)'
- en: 'In the same way, we''d use `-type d` to find all directories in a specific
    location:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`-type d`来查找特定位置的所有目录：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![You can run, but you can''t hide… from find](img/image_04_015.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![你可以跑，但你无法躲避...来自find](img/image_04_015.jpg)'
- en: 'Find can also locate files based on time identifiers. For example, in order
    to find all files in the `/usr/share` directory that were modified in the last
    24 hours, issue the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Find还可以根据时间标识符定位文件。例如，为了找到在`/usr/share`目录中在过去24小时内修改的所有文件，执行以下命令：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![You can run, but you can''t hide… from find](img/image_04_016.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![你可以跑，但你无法躲避...来自find](img/image_04_016.jpg)'
- en: I have quite a big list. You can see the `-mtime -3` broadens the list even
    more.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个相当长的列表。你可以看到`-mtime -3`扩大了列表。
- en: 'If we were to find, for example, all the files modified in the last hour, we
    can use `-mmin -60`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要找到最近一小时内修改的所有文件，我们可以使用`-mmin -60`：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![You can run, but you can''t hide… from find](img/image_04_017.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![你可以跑，但你无法躲避...来自find](img/image_04_017.jpg)'
- en: A good folder to search is `~/.local/share`, If we use `-mmin -90`, the list
    broadens again.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的搜索文件夹是`~/.local/share`，如果我们使用`-mmin -90`，列表会再次扩大。
- en: 'Find can also show us the list of files accessed in the last 24 hours by using
    the `-atime -1` argument like so:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-atime -1`参数，find还可以显示在过去24小时内访问的文件列表，如下所示：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![You can run, but you can''t hide… from find](img/image_04_018.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![你可以跑，但你无法躲避...来自find](img/image_04_018.jpg)'
- en: 'While working with lots of project files, if sometimes the case in some projects
    remain empty, and we forget to delete them. In order to locate all empty files
    just do a:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大量项目文件时，有时候在某些项目中会保留空文件，并且我们忘记删除它们。为了定位所有空文件，只需执行以下操作：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![You can run, but you can''t hide… from find](img/image_04_019.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![你可以跑，但你无法躲避...来自find](img/image_04_019.jpg)'
- en: As we can see, electron has a few empty files. Find will also show us empty
    directories, or links.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，electron有一些空文件。Find还会显示空目录或链接。
- en: 'Removing empty files will keep our project clean, but when it comes to reducing
    size, we sometimes want to know which files are taking up most of the space. Find
    can also do searches based on file size. For example, let''s find all the files
    larger than `1` mega:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 删除空文件将保持我们的项目清洁，但是当涉及到减小大小时，我们有时想知道哪些文件占用了大部分空间。Find还可以根据文件大小进行搜索。例如，让我们找到所有大于`1`兆字节的文件：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: use -1M for smaller.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用-1M可以缩小范围。
- en: 'As we said in the beginning, find can do much more than locating files in your
    project. Using the `-exec` argument, it can be combined with almost any other
    command, which gives it almost infinite capabilities. For example, if we want
    to find all `javascript` files that contain the text `manager`, we can combine
    find with `grep`, command as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在开始时所说，find可以做比在项目中定位文件更多的事情。使用`-exec`参数，它可以与几乎任何其他命令结合使用，从而使其具有几乎无限的功能。例如，如果我们想要找到所有包含文本`manager`的`javascript`文件，我们可以将find与`grep`命令结合使用，命令如下：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![You can run, but you can''t hide… from find](img/image_04_020.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![你可以跑，但你无法躲避...来自find](img/image_04_020.jpg)'
- en: This will execute the grep command on all the files returned by find. Let's
    also search inside the file using vim, so that we verify the result is correct.
    As you can see, the text "manager" appears in this file. You don't have to worry
    about `{} \;`, it's just standard -exec syntax.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在find返回的所有文件上执行grep命令。让我们还使用vim在文件中搜索，以便验证结果是否正确。正如你所看到的，这个文件中出现了文本"manager"。你不必担心`{}
    \;`，它只是标准的-exec语法。
- en: 'Moving on with the practical examples, let''s say you have a folder where you
    want to remove all the files modified in the last 100 days. We can see our `default_app`
    folder contains such files. If we combine find with `rm` like so:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 继续实际示例，假设你有一个文件夹，你想删除在过去100天内修改的所有文件。我们可以看到我们的`default_app`文件夹包含这样的文件。如果我们将find与`rm`结合使用，如下所示：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can do a quick cleanup. Find can be used for smart backups. For example,
    if we were to backup all `json` files in the project we would combine find with
    the `cpio` backup utility using a pipe and a standard output redirection:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进行快速清理。Find可以用于智能备份。例如，如果我们要备份项目中的所有`json`文件，我们将使用管道和标准输出重定向将find与`cpio`备份实用程序结合使用：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![You can run, but you can''t hide… from find](img/image_04_021.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![你可以跑，但你无法躲避...来自find](img/image_04_021.jpg)'
- en: We can see that this command has created a `backup.cpio` file, of type `cpio`
    archive.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个命令创建了一个`backup.cpio`文件，类型为`cpio`归档文件。
- en: Now this could probably have been written with `-exec` also, but it's critical
    you understand that pipes can also be used in this type of scenario, together
    with redirects.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这可能也可以用`-exec`来写，但是你必须明白管道也可以在这种情况下使用，以及重定向。
- en: 'When doing reports, you may have to count the number of lines written:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成报告时，您可能需要计算所写行数：
- en: 'In order to do this, we combine find with `wc -l`:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将find与`wc -l`结合起来：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will give us all `js` files and the number of lines. We can pipe this
    to cut:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将给出我们所有的`js`文件和行数。我们可以将其传递给cut：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To only output the number of lines, and then pipe to the paste command, we
    do this:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只输出行数，然后将其传递给paste命令，我们可以这样做：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The above will merge all our lines with the `+` sign as a delimiter. This,
    of course, can translate to an arithmetic operation, which we can calculate using
    the binary calculator (`bc`):'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上面的命令将使用`+`符号作为分隔符合并所有行。当然，这可以转换为一个算术运算，我们可以使用二进制计算器（`bc`）来计算：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![You can run, but you can''t hide… from find](img/image_04_022.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![你可以逃跑，但无法躲避...来自find](img/image_04_022.jpg)'
- en: This last command will tell us how many lines our `javascript` files contain.
    Of course, these are not actual lines of code, as they can be empty lines or comments.
    For a precise calculation of lines of code, you can use the `sloc` utility.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的命令将告诉我们我们的`javascript`文件包含多少行。当然，这些不是实际的代码行，因为它们可能是空行或注释。要精确计算代码行数，可以使用`sloc`实用程序。
- en: 'In order to mass rename files, like changing the file extension name to `node`
    for all `js` files we can use this command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了批量重命名文件，比如将所有的`js`文件的文件扩展名改为`node`，我们可以使用以下命令：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can see the rename syntax is quite similar to sed. In addition, there are
    no more `.js` files left, as all have been renamed to `.node`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到重命名的语法与sed非常相似。此外，没有剩余的`.js`文件了，因为所有文件都已重命名为`.node`：
- en: '![You can run, but you can''t hide… from find](img/image_04_023.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![你可以逃跑，但无法躲避...来自find](img/image_04_023.jpg)'
- en: Some software projects require all source code files to have a copyright header.
    As this is not required in the beginning, often times we can find ourselves in
    the situation that we have to add copyright information at the beginning of all
    our files.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一些软件项目要求所有源代码文件都有版权头。由于一开始不需要这个，所以我们经常会发现我们必须在所有文件的开头添加版权信息的情况。
- en: 'In order to do this, we can combine find with sed like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可以将find与sed结合起来，像这样：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What this is basically doing is telling the computer to find all `.node` files,
    and add the copyright notice in the beginning of each file, followed by a new
    line.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这个命令告诉计算机找到所有的`.node`文件，并在每个文件的开头添加版权声明，然后换行。
- en: 'We can check one random file and, yes, the copyright notice is there:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查一个随机文件，是的，版权声明在那里：
- en: '![You can run, but you can''t hide… from find](img/image_04_024.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![你可以逃跑，但无法躲避...来自find](img/image_04_024.jpg)'
- en: 'Update version numbers in all files:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 更新所有文件的版本号：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can imagine, find has lots of use cases. The examples I've shown you
    are only the first piece of the pie. Learning find, along with `sed` and the `git
    cli` can set you free from your IDE when it comes to finding, refactoring or working
    with `git`, which means you can more easily switch from one IDE to the other,
    because you don't have to learn all the features. You just use your friendly CLI
    tools.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以想象的那样，find有很多用途。我给你展示的例子只是冰山一角。学习find，以及`sed`和`git cli`可以让你摆脱IDE的束缚，无论是查找、重构还是使用`git`，都可以更轻松地切换到其他IDE，因为你不需要学习所有的功能。你只需要使用友好的CLI工具。
- en: tmux – virtual consoles, background jobs and the like
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: tmux - 虚拟控制台、后台作业等
- en: In this section, we will be looking at another great tool called tmux. Tmux
    comes in particularly handy when working in remote `ssh` sessions, because it
    gives you the ability to continue your work from where you left off. It can also
    replace some of the features in terminator, if you are working, for example, on
    Mac, and you can't install terminator.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍另一个非常好用的工具，叫做tmux。当在远程`ssh`会话中工作时，tmux非常方便，因为它可以让你从上次离开的地方继续工作。如果你在Mac上工作，无法安装terminator，它还可以替代terminator的一些功能。
- en: 'To get started with `tmux` on Ubuntu, we first need to install it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Ubuntu上开始使用`tmux`，我们首先需要安装它：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![tmux – virtual consoles, background jobs and the like](img/image_04_025.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![tmux - 虚拟控制台、后台作业等](img/image_04_025.jpg)'
- en: 'Then just run the command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后只需运行命令：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![tmux – virtual consoles, background jobs and the like](img/image_04_026.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![tmux - 虚拟控制台、后台作业等](img/image_04_026.jpg)'
- en: 'And you will find yourself inside a brand new virtual console:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你将发现自己在一个全新的虚拟控制台中：
- en: '![tmux – virtual consoles, background jobs and the like](img/image_04_027.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![tmux - 虚拟控制台、后台作业等](img/image_04_027.jpg)'
- en: 'For demonstration purposes, we will open up a new tab that you can see the
    list of open sessions with `tmux ls`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将打开一个新的选项卡，你可以使用`tmux ls`命令查看打开的会话列表：
- en: '![tmux – virtual consoles, background jobs and the like](img/image_04_028.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![tmux - 虚拟控制台、后台作业等](img/image_04_028.jpg)'
- en: 'Let''s start a new `tmux` named session:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始一个新的`tmux`命名会话：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![tmux – virtual consoles, background jobs and the like](img/image_04_029.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![tmux - 虚拟控制台、后台作业等](img/image_04_029.jpg)'
- en: Here we can see that opening a `tmux` session maintains the current directory.
    To list and switch `tmux` sessions inside `tmux`, hit *Ctrl* + *B* *S*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以看到打开一个`tmux`会话会保持当前目录。要在`tmux`内部列出和切换`tmux`会话，按下*Ctrl* + *B* *S*。
- en: We can see that we can switch to another tmux session, execute commands inside,
    and switch back to our initial session if we want to. To detach (leave a session
    running and go back to the normal terminal) hit *Ctrl* + *b d*;
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们可以切换到另一个tmux会话，在其中执行命令，然后如果需要的话切换回我们的初始会话。要分离（保持会话运行并返回到正常终端），按下*Ctrl*
    + *b d*；
- en: Now we can see we have two opened sessions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到我们有两个打开的会话。
- en: 'To attach to a session:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到会话：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![tmux – virtual consoles, background jobs and the like](img/image_04_030.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![tmux - 虚拟控制台、后台作业等](img/image_04_030.jpg)'
- en: This scenario comes in handy when you login to a remote server and want to execute
    a long running task, then leave and come back when it ends. We will replicate
    this scenario with a quick script called infinity.sh. We will execute it. It's
    writing to the standard output. Now let's detach from tmux.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当您登录到远程服务器并希望执行长时间运行的任务，然后离开并在任务结束时返回时，此场景非常方便。我们将使用一个名为infinity.sh的快速脚本来复制此场景。我们将执行它。它正在写入标准输出。现在让我们从tmux中分离出来。
- en: If we look at the script, it's just a simple while loop that goes on forever,
    printing text each second.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看脚本，它只是一个简单的无限循环，每秒打印一次文本。
- en: Now when we come back to our session, we can see the script was running while
    we were detached from the session and it's still outputting data to the console.
    I will manually stop it by hitting *Ctrl* + *c*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们回到会话时，我们可以看到脚本在我们分离会话时正在运行，并且仍然将数据输出到控制台。我将通过按下*Ctrl* + *c*手动停止它。
- en: 'Alright, let''s go to our first tmux session and close it. In order to manually
    kill a running tmux session, use:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，让我们进入我们的第一个tmux会话并关闭它。为了手动终止正在运行的tmux会话，请使用：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![tmux – virtual consoles, background jobs and the like](img/image_04_031.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![tmux-虚拟控制台，后台作业等](img/image_04_031.jpg)'
- en: 'This will kill the running session. If we switch over to our second tab, we
    can see that we have been logged off tmux. Let''s also close this terminator tab,
    and open a brand new tmux session:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将终止当前会话。如果我们切换到第二个标签，我们可以看到我们已经从tmux注销了。让我们也关闭这个terminator标签，并打开一个全新的tmux会话：
- en: '![tmux – virtual consoles, background jobs and the like](img/image_04_032.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![tmux-虚拟控制台，后台作业等](img/image_04_032.jpg)'
- en: 'Tmux gives you the possibility to split the screen, just like terminator, horizontally
    with *Ctrl* + *b* + ", and vertically with *Ctrl* + *b* + *%*. After that, use
    *Ctrl* + *b* + arrows to navigate between the panes:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Tmux使您有可能像terminator一样水平地拆分屏幕，使用*Ctrl* + *b* + "，垂直拆分屏幕使用*Ctrl* + *b* + *%*。之后，使用*Ctrl*
    + *b* +箭头在窗格之间导航：
- en: '![tmux – virtual consoles, background jobs and the like](img/image_04_033.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![tmux-虚拟控制台，后台作业等](img/image_04_033.jpg)'
- en: 'You also have the possibility to create windows (tabs):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建窗口（选项卡）：
- en: '*Ctrl* + *b c*: create:![tmux – virtual consoles, background jobs and the like](img/image_04_034.jpg)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl* + *b c*：创建：![tmux-虚拟控制台，后台作业等](img/image_04_034.jpg)'
- en: '*Ctrl* + *b w*: list:![tmux – virtual consoles, background jobs and the like](img/image_04_035.jpg)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl* + *b w*：列表：![tmux-虚拟控制台，后台作业等](img/image_04_035.jpg)'
- en: '*Ctrl* + *b &*: delete![tmux – virtual consoles, background jobs and the like](img/image_04_036.jpg)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl* + *b &*：删除![tmux-虚拟控制台，后台作业等](img/image_04_036.jpg)'
- en: These last functionalities are very similar to what terminator offers.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能与terminator提供的功能非常相似。
- en: You can use tmux in situations where you want to have two or more panes or even
    tabs in your remote `ssh` connection, but you don't want to open multiple `ssh`
    sessions. You could also use it locally, as a terminator replacement, but the
    keyboard shortcuts are much harder to use. Although they can be changed, you will
    lose the option to use tmux remotely, because opening a tmux session in another
    tmux session is discouraged. In addition, configuring new tmux keyboard shortcuts
    might make tmux a burden when working on lots of servers due to the shortcut differences.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在需要在远程`ssh`连接中拥有两个或多个窗格甚至选项卡的情况下使用tmux，但您不想打开多个`ssh`会话。您也可以在本地使用它作为terminator的替代品，但是键盘快捷键的使用要困难得多。虽然它们可以更改，但您将失去在远程使用tmux的选项，因为不鼓励在另一个tmux会话中打开tmux会话。此外，配置新的tmux键盘快捷键可能会使tmux在处理大量服务器时变得繁琐，因为快捷键的差异。
- en: Network – Who's listening?
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络-谁在监听？
- en: When working with network applications, it comes in handy to be able to see
    open ports and connections and to be able to interact with ports on different
    hosts for testing purposes. In this section, we will be looking at some basic
    commands for networking and in what situations they might come in handy.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理网络应用程序时，能够查看开放的端口和连接，并能够与不同主机上的端口进行交互以进行测试是非常方便的。在本节中，我们将介绍一些网络基本命令以及它们在什么情况下可能会派上用场。
- en: 'The first command is `netstat`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令是`netstat`：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![Network – Who''s listening?](img/image_04_037.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![网络-谁在监听？](img/image_04_037.jpg)'
- en: 'This will show all open ports on our host. You can see here that we only have
    one open port on a default Ubuntu desktop installation, which is port `53`. We
    can look this up in the special file `/etc/services`. This file contains all basic
    port numbers for programs and protocols. We see here port `53` is the DNS server:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示主机上所有打开的端口。您可以在这里看到，在默认的Ubuntu桌面安装中，我们只有一个打开的端口，即端口`53`。我们可以在特殊文件`/etc/services`中查找此信息。此文件包含程序和协议的所有基本端口号。我们在这里看到端口`53`是DNS服务器：
- en: '![Network – Who''s listening?](img/image_04_038.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![网络-谁在监听？](img/image_04_038.jpg)'
- en: 'Just by analyzing the output, we cannot determine which program is listening
    on this port, because this process is not owned by our current user. That''s why
    the *PID/Program Name* column is empty. If we run the same command again with
    `sudo`, we see that this process is named `dnsmasq` and, if we want more information,
    we can look it up in the man page. It''s a lightweight DHCP and caching DNS server:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过分析输出，我们无法确定哪个程序正在监听此端口，因为此进程不属于当前用户。这就是为什么*PID/程序名称*列为空的原因。如果我们使用`sudo`再次运行相同的命令，我们会看到此进程被命名为`dnsmasq`，如果我们想要更多信息，可以在man页面中查找。它是一个轻量级的DHCP和缓存DNS服务器：
- en: '![Network – Who''s listening?](img/image_04_039.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![网络-谁在监听？](img/image_04_039.jpg)'
- en: 'Other useful information we get from this command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从此命令中获取的其他有用信息：
- en: The program protocol, in this case dhcp.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序协议，在这种情况下是dhcp。
- en: Total bytes not copied.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未复制的总字节。
- en: Total bytes not acknowledged.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未确认的总字节。
- en: Local and foreign address and port. Getting the port is the main reason we are
    using this command. This is also important for determining if the port is open
    just on localhost or if it's listening for incoming connections on the network.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地和外部地址和端口。获取端口是我们使用此命令的主要原因。这对于确定端口是仅在本地主机上打开还是在网络上监听传入连接也很重要。
- en: The state of the port. Usually this is **LISTEN**.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口的状态。通常为**LISTEN**。
- en: The PID and program name, which helps us identify which program is listening
    on what port.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PID和程序名称，这有助于我们确定哪个程序在监听哪个端口。
- en: 'Now, if we run a program that is supposed to be listening on a certain port
    and we don''t know if it''s working, we can find out with `netstat`. Let''s open
    the most basic HTTP server by running the command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行一个应该在特定端口上监听的程序，而我们不知道它是否工作，我们可以通过`netstat`找出。让我们通过运行以下命令来打开最基本的HTTP服务器：
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![Network – Who''s listening?](img/image_04_040.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![网络-谁在监听？](img/image_04_040.jpg)'
- en: As you can see from the output, it's listening on port `8000` on interface `0.0.0.0`.
    If we open a new pane and run the `netstat` command, we will see the open the
    port, and the PID / name.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看到，它在接口`0.0.0.0`上的端口`8000`上进行监听。如果我们打开一个新的窗格并运行`netstat`命令，我们将看到打开的端口和PID/名称。
- en: 'You probably already know this but, just to be on the safe side, we will look
    at adding different hostnames as static `dns` entries on our machine. This is
    helpful when developing applications that need to connect to servers and the servers
    change their IP address, or when you want to emulate a remote server on a local
    machine. For this we type:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经知道这一点，但为了安全起见，我们将在我们的机器上添加不同的主机名作为静态`dns`条目。这在开发需要连接到服务器的应用程序时非常有用，而服务器更改其IP地址时，或者当您想在本地机器上模拟远程服务器时。为此，我们输入：
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![Network – Who''s listening?](img/image_04_041.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![网络-谁在监听？](img/image_04_041.jpg)'
- en: 'You can quickly understand the format of the file from the existing content.
    Let''s add an alias for our localhost, so that we can access it under a different
    name. Add the following line:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从现有内容快速了解文件的格式。让我们为本地主机添加一个别名，以便我们可以使用不同的名称访问它。添加以下行：
- en: '[PRE40]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We recommend using non existing top level domain names for localhost, such as
    .local or .dev. This is to avoid overriding any existing address, because `/etc/hosts`
    takes precedence in `dns` resolution. Now, if we open the address in the browser
    on port `8000`, we will see our local Python server running and serving content.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议在本地主机上使用不存在的顶级域名，例如.local或.dev。这是为了避免覆盖任何现有地址，因为`/etc/hosts`在`dns`解析中具有优先权。现在，如果我们在浏览器中打开端口`8000`的地址，我们将看到我们的本地Python服务器正在运行并提供内容。
- en: 'The next command is `nmap`. As you can see, it is not installed by default
    on Ubuntu, so let''s go ahead and install it by typing:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令是`nmap`。正如你所看到的，它在Ubuntu上默认没有安装，所以让我们通过输入以下命令来安装它：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![Network – Who''s listening?](img/image_04_042.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![网络-谁在监听？](img/image_04_042.jpg)'
- en: 'Nmap is a command used for checking all open ports on a remote host, also known
    as a port scanner. If we run `nmap` on our network gateway, which, in our case,
    is `192.68.0.1`, we''ll get all of the open ports on the gateway:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Nmap是一个用于检查远程主机上所有开放端口的命令，也称为端口扫描器。如果我们在我们的网络网关上运行`nmap`，在我们的情况下是`192.68.0.1`，我们将获得网关上的所有开放端口：
- en: 'Type: **nmap 192.168.0.1**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：**nmap 192.168.0.1**
- en: '![Network – Who''s listening?](img/image_04_043.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![网络-谁在监听？](img/image_04_043.jpg)'
- en: As you can see, there is again the `dns` port open, the http and https servers,
    which are used as a web page for configuring the router, and port `49152`, which,
    at this time, is not specific to any common protocol-and that's why it is marked
    as unknown. Nmap does not know for sure that those specific programs are actually
    running on the host; all it does is verify what ports are open and write the default
    application that usually runs on that port.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这里再次打开了`dns`端口，http和https服务器，它们用作配置路由器的网页，以及端口`49152`，此时不特定于任何常见协议，因此被标记为未知。Nmap无法确定这些特定程序是否实际在主机上运行；它所做的只是验证哪些端口是开放的，并写入通常在该端口上运行的默认应用程序。
- en: 'If we are not sure what server we need to, connect to or if we want to know
    how many servers are in our current network, we can run `nmap` on the local network
    address, specifying the network mask as the destination network. We get this information
    from `ifconfig`; if our IP address is `192.168.0.159`, and our network mask is
    `255.255.255.0`, that means the command will look like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不确定要连接到哪个服务器，或者我们想知道当前网络中有多少服务器，我们可以在本地网络地址上运行`nmap`，将网络掩码指定为目标网络。我们从`ifconfig`获取此信息；如果我们的IP地址是`192.168.0.159`，我们的网络掩码是`255.255.255.0`，那么命令将如下所示：
- en: '[PRE42]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![Network – Who''s listening?](img/image_04_044.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![网络-谁在监听？](img/image_04_044.jpg)'
- en: In `/24 = 255.255.255.0`, basically the network will have `ips` ranging from
    `192.168.0.0` to `192.168.0.255`. We see here that we have three active hosts,
    and it even gives us the latency, so we can determine which host is closer.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/24 = 255.255.255.0`中，基本上网络将具有从`192.168.0.0`到`192.168.0.255`的IP地址。我们在这里看到有三个活动主机，甚至还给出了延迟，因此我们可以确定哪个主机更近。
- en: 'Nmap is helpful when developing client-server applications, for example, when
    you want to see what ports are accessible on the server. However, `nmap` might
    miss application-specific ports, which are non-standard. To actually connect to
    a given port, we will be using telnet, which comes preinstalled on Ubuntu desktop.
    To see if a particular port accepts connections, just type the hostname, followed
    by the port:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发客户端-服务器应用程序时，Nmap非常有用，例如，当您想查看服务器上可以访问的端口时。但是，`nmap`可能会错过非标准的应用程序特定端口。要实际连接到给定端口，我们将使用预安装在Ubuntu桌面上的telnet。只需输入主机名，后跟端口，即可查看特定端口是否接受连接。
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![Network – Who''s listening?](img/image_04_045.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![网络-谁在监听？](img/image_04_045.jpg)'
- en: 'If the port is listening and accepts connections, telnet will output a message
    like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果端口正在监听并接受连接，telnet将输出如下消息：
- en: Trying `192.168.0.1`...
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试`192.168.0.1`...
- en: Connected to `192.168.0.1`
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到`192.168.0.1`
- en: Escape character is `^]`
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转义字符是`^]`
- en: This means that you can also connect from your application. So if you are having
    difficulties connecting, it's usually a client problem; the server is working
    fine.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您也可以从您的应用程序进行连接。所以如果您在连接时遇到困难，通常是客户端的问题；服务器工作正常。
- en: 'To get out of telnet, hit: *Ctrl* +*]*, followed by *Ctrl* + *d*.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出telnet，按下：*Ctrl* +*]*，然后按下*Ctrl* + *d*。
- en: 'Also, in some cases we need to get the ip address of a particular hostname.
    The simplest way to do this is to use the host command:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在某些情况下，我们需要获取特定主机名的IP地址。最简单的方法是使用host命令：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '![Network – Who''s listening?](img/image_04_046.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![Network - 谁在监听？](img/image_04_046.jpg)'
- en: 'We''ve learned only the basics, the minimum elements you need, in order to
    start working with hostnames and ports. For a deeper understanding of networks
    and package traffic, we recommend checking out courses on penetration testing
    or network traffic analyzing tools such as Wireshark. Here''s one such course:
    [https://www.packtpub.com/networking-and-servers/mastering-wireshark"](https://www.packtpub.com/networking-and-servers/mastering-wireshark)
    .'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只学习了基础知识，你需要的最低限度的元素，以便开始使用主机名和端口进行工作。为了更深入地了解网络和数据包流量，我们建议查看渗透测试或网络流量分析工具（如Wireshark）的课程。这是一个这样的课程：[https://www.packtpub.com/networking-and-servers/mastering-wireshark"](https://www.packtpub.com/networking-and-servers/mastering-wireshark)。
- en: Autoenv – Set a lasting, project-based habitat
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Autoenv - 设置一个持久的、基于项目的环境
- en: Projects are different from one another and so are environments. We might be
    developing an application on our local machine with certain environment variables
    like debug level, API keys, or memory size. Then we want to deploy the application
    to a staging or production server, which has other values for the same environment
    variables. A tool that comes in handy for loading environments on the fly is `autoenv`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 项目与项目之间不同，环境也是如此。我们可能在本地机器上开发应用程序，具有某些环境变量，如调试级别、API密钥或内存大小。然后我们想要将应用程序部署到一个具有相同环境变量的暂存或生产服务器上。一个方便加载环境的工具是`autoenv`。
- en: 'To install it we go to the official GitHub page and follow the instructions:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它，我们需要打开官方的GitHub页面并按照说明进行操作：
- en: '[https://github.com/kennethreitz/autoenv](https://github.com/kennethreitz/autoenv)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/kennethreitz/autoenv](https://github.com/kennethreitz/autoenv)'
- en: 'First we will clone the project in our home directory, and then we add the
    following line to our .zshrc config file, so that every time zsh starts, autoenv
    is loaded by default:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们将在我们的主目录中克隆该项目，然后我们将以下行添加到我们的.zshrc配置文件中，以便每次zsh启动时默认加载autoenv：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now let's create an example workplace with two imaginary projects, project 1
    and project 2.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个带有两个虚构项目的示例工作区，项目1和项目2。
- en: 'We open an environment file for project 1:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开一个项目1的环境文件：
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s now imagine that project 1 uses an environment variable called `ENV`,
    which we will set to `dev`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们假设项目1使用一个名为`ENV`的环境变量，我们将其设置为`dev`：
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![Autoenv – Set a lasting, project-based habitat](img/image_04_047.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![Autoenv - 设置一个持久的、基于项目的环境](img/image_04_047.jpg)'
- en: 'Now let''s do the same thing for project 2, but with a different value for
    `ENV`; `qa`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为项目2做同样的事情，但是使用不同的`ENV`值；`qa`：
- en: '[PRE48]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![Autoenv – Set a lasting, project-based habitat](img/image_04_048.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![Autoenv - 设置一个持久的、基于项目的环境](img/image_04_048.jpg)'
- en: 'Save and close both files. Now when we cd in the project 1 folder, we see the
    following message:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并关闭两个文件。现在当我们cd到项目1文件夹中时，我们会看到以下消息：
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Hit *y* to load the file. This happens every time a new environment file is
    sourced. Now if we grep the environment for the ENV variable, we can see it present
    and with a value of `dev`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*y*加载文件。每次加载新的环境文件时都会发生这种情况。现在，如果我们使用grep命令搜索ENV变量的环境，我们可以看到它存在，并且值为`dev`：
- en: '![Autoenv – Set a lasting, project-based habitat](img/image_04_049.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![Autoenv - 设置一个持久的、基于项目的环境](img/image_04_049.jpg)'
- en: 'Now let''s change the directory to `project 2`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将目录更改为`project 2`：
- en: '![Autoenv – Set a lasting, project-based habitat](img/image_04_050.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![Autoenv - 设置一个持久的、基于项目的环境](img/image_04_050.jpg)'
- en: We can see that the same warning message is issued. And when we grep for the
    ENV variable, we now see that its value is `qa`. If we leave this folder, the
    environment variable is still defined, and will be defined until some other script
    overrides it or when the current session is closed. The `.env` file is sourced,
    even if we cd to a directory deeper inside project1.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到相同的警告消息被发出。当我们使用grep命令搜索ENV变量时，我们现在可以看到它的值是`qa`。如果我们离开这个文件夹，环境变量仍然被定义，并且将在其他脚本覆盖它或当前会话关闭时定义。即使我们cd到project1的更深的目录中，.env文件也会被加载。
- en: Now let's look at a more complex example for project1.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个更复杂的project1的例子。
- en: Let's say we want to get the version from `package.json`, and we also want to
    use a variable called COMPOSE_FILE that will specify a different file for docker
    compose. Docker users know what it's all about, but if you don't.. Google time!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要从`package.json`中获取版本，并且我们还想要使用一个名为COMPOSE_FILE的变量，该变量将指定一个不同的文件用于docker
    compose。Docker用户知道这是什么意思，但如果你不知道...谷歌一下！
- en: 'Here is an example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For this to take effect, we need to first copy a `package.json` file, and test
    that the `cat` command works:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其生效，我们需要首先复制一个`package.json`文件，并测试`cat`命令是否有效：
- en: '![Autoenv – Set a lasting, project-based habitat](img/image_04_051.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![Autoenv - 设置一个持久的、基于项目的环境](img/image_04_051.jpg)'
- en: 'Everything seems fine, so let''s `cd` into our folder:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很好，所以让我们`cd`到我们的文件夹中：
- en: '![Autoenv – Set a lasting, project-based habitat](img/image_04_052.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![Autoenv - 设置一个持久的、基于项目的环境](img/image_04_052.jpg)'
- en: 'And as you can see, the environment variables have been set:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，环境变量已经设置好了：
- en: '![Autoenv – Set a lasting, project-based habitat](img/image_04_053.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![Autoenv - 设置一个持久的、基于项目的环境](img/image_04_053.jpg)'
- en: '`Autoenv` can really come in handy, and is not limited to just exporting environment
    variables. You can do stuff like issuing a reminder when entering a certain project
    or running a `git pull` or updating the look and feel of the terminal so that
    a distinct feel is given for each project.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`Autoenv`非常方便，不仅限于导出环境变量。您可以执行一些操作，比如在进入某个项目或运行`git pull`或更新终端的外观和感觉时发出提醒，以便为每个项目提供独特的感觉。'
- en: Don't rm the trash
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要删除垃圾
- en: Commands can be categorized as harmless or harmful. Most commands fall within
    the first category, but there is one that is very common and that has been known
    to produce a lot of damage in the world of computers. The dreaded command is `rm`,
    which has wiped out numerous hard drives, making precious volumes of data inaccessible.
    The Linux desktop has borrowed the concept of trash from other desktops and the
    default action when deleting a file is sending it to the `Trash`. Sending files
    there is a good practice, so that no unintentional removing is done. But this
    trash is no magic location; it's just a hidden folder, usually located in `~/.local`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 命令可以分为无害和有害两类。大多数命令属于第一类，但有一个非常常见的命令在计算机世界中已经造成了很多损害。这个可怕的命令就是`rm`，它已经抹掉了许多硬盘，使得宝贵的数据卷无法访问。Linux桌面从其他桌面借鉴了垃圾桶的概念，删除文件的默认操作是将其发送到“垃圾桶”。将文件发送到垃圾桶是一个好的做法，以防止意外删除。但是这个垃圾桶并不是一个神奇的位置；它只是一个隐藏的文件夹，通常位于`~/.local`。
- en: 'In this part, we will be looking at a utility tool designed to work with trash.
    We will install it with:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分中，我们将介绍一个与垃圾桶一起工作的实用工具。我们将使用以下命令进行安装：
- en: '[PRE51]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '![Don''t rm the trash](img/image_04_054.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![不要删除垃圾](img/image_04_054.jpg)'
- en: This will install multiple commands. Let's look at our current directory that
    contains quite a few files. Let's assume we don't need the files starting with
    file.`*`
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装多个命令。让我们看一下当前目录，其中包含相当多的文件。假设我们不需要以file.`*`开头的文件。
- en: 'In order to remove files we will use:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除文件，我们将使用以下命令：
- en: '[PRE52]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![Don''t rm the trash](img/image_04_055.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![不要删除垃圾](img/image_04_055.jpg)'
- en: '(There is a separate command for working with the trash. We will rehash to
    reload our path.) We list all the trash commands. The command for listing the
    trash content is:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: （有一个单独的命令用于处理垃圾桶。我们将重新加载路径。）我们列出所有垃圾桶命令。列出垃圾桶内容的命令是：
- en: '[PRE53]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![Don''t rm the trash](img/image_04_056.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![不要删除垃圾](img/image_04_056.jpg)'
- en: Here we see the files that are in our trash. It is only showing the files that
    were put there with the trash command. We can see the date when they were deleted,
    the hour, and the exact location. If we'd have had multiple files with the same
    name and path, they would have been listed here, and we could have identified
    them by the deletion date.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以看到垃圾桶中的文件。它只显示使用垃圾命令放入垃圾桶的文件。我们可以看到它们被删除的日期、时间和确切位置。如果我们有多个具有相同名称和路径的文件，它们将在这里列出，我们可以通过删除日期来识别它们。
- en: 'In order to restore a file from trash we will use the command:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从垃圾桶中恢复文件，我们将使用以下命令：
- en: '[PRE54]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '![Don''t rm the trash](img/image_04_057.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![不要删除垃圾](img/image_04_057.jpg)'
- en: It will show us a list of options and ask for a number corresponding to the
    file we want restored. In this case we will select 1, meaning we want to restore
    the `json` file.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 它将显示一个选项列表，并要求输入要恢复的文件对应的编号。在这种情况下，我们将选择1，表示我们要恢复`json`文件。
- en: We open the file and we can see that the content was not altered in the process.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开文件，可以看到内容在过程中没有被改变。
- en: 'In order to remove all the files in the trash, we use:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除垃圾桶中的所有文件，我们使用以下命令：
- en: '[PRE55]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![Don''t rm the trash](img/image_04_058.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![不要删除垃圾](img/image_04_058.jpg)'
- en: This is the equivalent of doing `rm` in the first place. Now if we list the
    trash again, we see it doesn't have any content.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于一开始就使用`rm`命令。现在如果我们再次列出垃圾桶，我们会发现它没有任何内容。
- en: Although the internet is full of `rm -rf /` jokes, this is actually a serious
    issue that can cause headaches and wasted time trying to restore the damage caused.
    If you've been using `rm` for a long time and can't get into the habit of using
    trash, we suggest adding an alias for `rm` to actually run the trash command instead.
    In this case, it's a good idea to pile up stacks of files in trash than to risk
    removing a file that might be needed, before committing, or even removing the
    whole root partition!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管互联网上充斥着`rm -rf /`的笑话，但这实际上是一个严重的问题，可能会导致头痛和浪费时间来恢复造成的损害。如果您长时间使用`rm`命令而无法养成使用垃圾桶的习惯，我们建议为`rm`添加一个别名，以实际运行垃圾命令。在这种情况下，将文件堆积在垃圾桶中比冒险删除可能需要的文件更好，无论是在提交之前还是删除整个根分区！
