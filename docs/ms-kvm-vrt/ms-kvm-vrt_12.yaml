- en: '*Chapter 9*: Customizing a Virtual Machine with cloud-init'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：使用云初始化自定义虚拟机'
- en: Customizing a virtual machine often seems simple enough – clone it from a template;
    start; click a couple of **Next** buttons (or text tabs); create some users, passwords,
    and groups; configure network settings... That might work for a virtual machine
    or two. But what happens if we have to deploy two or three hundred virtual machines
    and configure them? All of a sudden, we're faced with a mammoth task – and it's
    a task that will be prone to errors if we do everything manually. We're wasting
    precious time while doing that instead of configuring them in a much more streamlined,
    automated fashion. That's where cloud-init comes in handy, as it can customize
    our virtual machines, install software on them, and it can do it on first and
    subsequent virtual machine boots. So, let's discuss cloud-init and how it can
    bring value to your large-scale configuration nightmares.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 定制虚拟机通常看起来很简单 - 从模板克隆它；启动；点击几个**下一步**按钮（或文本标签）；创建一些用户、密码和组；配置网络设置... 这对于一两台虚拟机可能有效。但如果我们需要部署两三百台虚拟机并对它们进行配置呢？突然间，我们面临着一项庞大的任务
    - 如果我们手动完成所有工作，这项任务将容易出现错误。我们在做这些事情的时候浪费了宝贵的时间，而不是以更简化、自动化的方式进行配置。这就是云初始化派上用场的地方，因为它可以定制我们的虚拟机，在它们上安装软件，并且可以在首次和后续虚拟机启动时进行。因此，让我们讨论一下云初始化以及它如何为你的大规模配置噩梦带来价值。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is the need for virtual machine customization?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机定制的需求是什么？
- en: Understanding cloud-init
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解云初始化
- en: cloud-init architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云初始化架构
- en: How to install and configure cloud-init at boot time
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在启动时安装和配置云初始化
- en: cloud-init images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云初始化镜像
- en: cloud-init data sources
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云初始化数据源
- en: Passing metadata and user data to cloud-init
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向云初始化传递元数据和用户数据
- en: Examples on how to use the cloud-config script with cloud-init
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用云配置脚本与云初始化
- en: What is the need for virtual machine customization?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟机定制的需求是什么？
- en: 'Once you really start using virtual machines and learn how to master them,
    you will notice that one thing seems to be happening a lot: virtual machine deployment.
    Since everything is so easy to configure and deploy, you will start to create
    new instances of virtual machines for almost anything, sometimes even to just
    check whether a particular application works on a particular version of the operating
    system. This makes your life as a developer and system administrator a lot easier,
    but creates its own set of problems. One of the most difficult ones is template
    management. Even if you have a small set of different servers and a relatively
    modest number of different configurations, things will start to add up, and if
    you decide to manage templates the normal way through the KVM, the sheer number
    of combinations will soon be too big.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你真正开始使用虚拟机并学会如何掌握它们，你会注意到一件事似乎经常发生：虚拟机部署。由于一切都很容易配置和部署，你会开始为几乎任何事情创建新的虚拟机实例，有时甚至只是为了检查特定应用程序是否在特定操作系统版本上运行。这让作为开发人员和系统管理员的生活变得更加轻松，但也带来了一系列问题。其中最困难的之一是模板管理。即使你有一小组不同的服务器和相对较少的不同配置，事情也会开始累积起来，如果你决定通过KVM以正常方式管理模板，组合的数量将很快变得太大。
- en: Another problem that you will soon face is compatibility. When you step out
    of your Linux distribution of choice, and you have to deploy another Linux distribution
    that has its own rules and deployment strategies, things will start to get complicated.
    Usually, the biggest problem is system customization. When it comes to network
    settings and hostnames, every computer on the network should have its own unique
    identity. Having a template that uses DHCP network configuration can solve one
    of these problems, but it is not nearly enough to make things simpler. For example,
    we could use Kickstart for CentOS / RHEL and compatible Linux distributions. Kickstart
    is a way to configure systems while they are being deployed, and if you are using
    these specific distributions, this is probably the best way to quickly deploy
    physical or virtual machines. On the other hand, Kickstart will make your deployments
    slower than they should be, as it uses a configuration file that enables us to
    add software and configuration to a clean installation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快会面临的另一个问题是兼容性。当你离开你选择的Linux发行版，需要部署另一个具有自己规则和部署策略的Linux发行版时，事情就会变得复杂起来。通常，最大的问题是系统定制。在网络设置和主机名方面，网络上的每台计算机都应该有自己独特的身份。使用DHCP网络配置的模板可以解决其中一个问题，但这远远不足以简化事情。例如，我们可以在CentOS
    / RHEL和兼容的Linux发行版上使用Kickstart。Kickstart是一种在部署时配置系统的方法，如果你使用这些特定的发行版，这可能是快速部署物理或虚拟机的最佳方式。另一方面，Kickstart会使你的部署比应该更慢，因为它使用一个配置文件，使我们能够向干净的安装添加软件和配置。
- en: Basically, it *fills up* additional configuration prompts with settings we defined
    earlier. This means that we are basically doing a full installation and creating
    a complete system from scratch every time we need to deploy a new virtual machine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，它用我们之前定义的设置填充了额外的配置提示。这意味着我们基本上每次需要部署新的虚拟机时都在进行完整的安装，并创建一个完整的系统。
- en: The main problem is *other distributions do not use Kickstart*. There are similar
    systems that enable unattended installations. Debian and Ubuntu use a tool/system
    called *preseed* and are able to support Kickstart in some parts, SuSe uses AutoYaST,
    and there are even a couple of tools that offer some sort of cross-platform functionality.
    One of them, called **Fully Automated Install** ( **FAI** ) is able to automate
    installing and even the online reconfiguration of different Linux distributions.
    But that still doesn't solve all of the problems that we have. In a dynamic world
    of virtualization, the main goal is to deploy as quickly as possible and to automate
    as much as possible, since we tend to use the same agility when it comes to removing
    virtual machines from production.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 主要问题是*其他发行版不使用Kickstart*。有类似的系统可以实现无人值守安装。Debian和Ubuntu使用一个叫做*preseed*的工具/系统，并且能够在某些部分支持Kickstart，SuSe使用AutoYaST，甚至有一些工具提供某种跨平台功能。其中一个叫做**Fully
    Automated Install**（**FAI**）的工具能够自动安装甚至在线重新配置不同的Linux发行版。但这仍然不能解决我们所有的问题。在虚拟化的动态世界中，主要目标是尽快部署并尽可能自动化，因为我们在从生产环境中移除虚拟机时也倾向于使用相同的灵活性。
- en: 'Imagine this: you need to create a single application deployment to test your
    new application with different Linux distributions. All of your future virtual
    machines will need to have a unique identifier in the form of a hostname, a deployed
    SSH identity that will enable remote management through Ansible, and of course,
    your application. Your application has three dependencies – two in the form of
    packages that can be deployed through Ansible, but one depends on the Linux distribution
    being used and has to be tailored for that particular Linux distribution. To make
    things even more realistic, you expect that you will have to periodically repeat
    this test, and every time you will need to rebuild your dependencies.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下：你需要创建一个单一的应用部署，以测试你的新应用在不同的Linux发行版上的情况。你所有未来的虚拟机都需要有一个主机名的唯一标识符，一个部署的SSH身份，可以通过Ansible进行远程管理，当然还有你的应用。你的应用有三个依赖项——两个以可以通过Ansible部署的软件包形式存在，但其中一个依赖于正在使用的Linux发行版，并且必须为该特定的Linux发行版进行定制。为了使事情更加真实，你预计你将不时地重复这个测试，并且每次你都需要重建你的依赖项。
- en: There are a couple of ways you can create this environment. One is to simply
    manually install all the servers and create templates out of them. This means
    manually configuring everything and then creating a virtual machine template that
    will be deployed. If we intend to deploy to more than a couple of Linux distributions
    this is a lot of work. It becomes even more work once the distributions get upgraded
    since all the templates we are deploying from must be upgraded, often at different
    points in time. This means we can either manually update all the virtual machine
    templates, or perform a post-install upgrade on each of them. This is a lot of
    work and it is extremely slow. Add to that the fact that a test like this will
    probably involve running your test application on both new and old versions of
    virtual machine templates. In addition to all that, we need to solve the problem
    of customizing our network settings for each and every Linux distribution we are
    deploying. Of course, this also means that our virtual machine templates become
    far from generic. After a while, we are going to end up with tens of virtual machine
    templates for each test cycle.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建这种环境的几种方式。一种方法是简单地手动安装所有服务器并创建模板。这意味着手动配置一切，然后创建将要部署的虚拟机模板。如果我们打算部署到超过几个Linux发行版，这是很多工作。一旦发行版升级，这将变得更加繁重，因为我们从中部署的所有模板必须经常升级，通常在不同的时间点。这意味着我们可以手动更新所有虚拟机模板，或者在每个模板上执行安装后升级。这是很多工作，而且非常慢。再加上这样一个事实，即这样的测试可能涉及在新旧版本的虚拟机模板上运行你的测试应用。除此之外，我们还需要解决为每个部署的Linux发行版定制我们的网络设置的问题。当然，这也意味着我们的虚拟机模板远非通用。过一段时间，我们将会为每个测试周期拥有数十个虚拟机模板。
- en: Another approach to this problem can be using a system like Ansible – we deploy
    all the systems from virtual machine templates, and then do the customization
    from Ansible. This is better – Ansible is designed for a scenario just like this,
    but this means that we must first create virtual machine templates that are able
    to support Ansible deployment, with implemented SSH keys and everything else Ansible
    needs to function.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的另一种方法可以是使用像Ansible这样的系统——我们从虚拟机模板部署所有系统，然后通过Ansible进行定制。这更好——Ansible就是为这样的场景设计的，但这意味着我们必须首先创建能够支持Ansible部署的虚拟机模板，带有实现的SSH密钥和Ansible运行所需的其他一切。
- en: There is one problem neither of these approaches can solve, and that is the
    mass deployment of machines. This is why a framework called cloud-init was designed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都无法解决的一个问题是大规模部署机器。这就是为什么设计了一个叫做cloud-init的框架。
- en: Understanding cloud-init
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解cloud-init
- en: We need to get a bit more technical in order to understand what cloud-init is
    and to understand what its limitations are. Since we are talking about a way to
    fully automatically reconfigure a system using simple configuration files, it
    means that some things need to be prepared in advance to make this complex process
    user friendly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在技术上更深入一些，以了解cloud-init是什么，以及了解它的局限性是什么。因为我们正在谈论一种使用简单配置文件完全自动重新配置系统的方式，这意味着有些事情需要事先准备好，以使这个复杂的过程更加用户友好。
- en: We already mentioned virtual machine templates in [*Chapter 8*](B14834_08_Final_ASB_ePub.xhtml#_idTextAnchor143),
    *Creating and Modifying VM Disks, Templates, and Snapshots*. Here, we are talking
    about a specially configured template that has all the elements needed to read,
    understand, and deploy the configuration that we are going to provide in our files.
    This means that this particular image has to be prepared in advance, and is the
    most complicated part of the whole system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第8章*](B14834_08_Final_ASB_ePub.xhtml#_idTextAnchor143)中提到了虚拟机模板，*创建和修改VM磁盘、模板和快照*。在这里，我们谈论的是一个特别配置的模板，它具有阅读、理解和部署我们将在文件中提供的配置所需的所有元素。这意味着这个特定的镜像必须提前准备好，是整个系统中最复杂的部分。
- en: Luckily, cloud-init images can be downloaded already pre-configured, and the
    only thing that we need to know is which distribution we want to use. All the
    distributions we have mentioned throughout this book (CentOS 7 or 8, Debian, Ubuntu,
    and Red Hat Enterprise Linux 7 and 8) have images we can use. Some of them even
    have different versions of the base operating system available, so we can use
    those if we need to. Be aware that there may be differences between installed
    versions of cloud-init, especially on older images.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，cloud-init镜像可以预先下载并进行配置，我们唯一需要知道的是我们想要使用哪个发行版。我们在本书中提到的所有发行版（CentOS 7或8、Debian、Ubuntu和Red
    Hat Enterprise Linux 7和8）都有我们可以使用的镜像。其中一些甚至有基本操作系统的不同版本可用，因此如果需要，我们可以使用它们。请注意，安装的cloud-init版本可能会有所不同，特别是在旧版本的镜像上。
- en: Why is this image important? Because it is prepared so that it can detect the
    cloud system it is running under, it determines whether cloud-init should be used
    or should be disabled, and after that, it reads and performs the configuration
    of the system itself.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个镜像很重要？因为它被准备好可以检测其运行的云系统，确定是否应该使用cloud-init或者禁用它，然后读取并执行系统本身的配置。
- en: Understanding cloud-init architecture
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解cloud-init架构
- en: 'Cloud-init works with the concept of boot stages because it needs fine and
    granular control over what happens to the system during boot. The prerequisite
    for cloud-init would, of course, be a cloud-init image. From the documentation
    available at [https://cloudinit.readthedocs.io](https://cloudinit.readthedocs.io),
    we can learn that there are five stages to a cloud-init boot:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud-init使用引导阶段的概念，因为它需要对系统在引导期间发生的事情进行精细和细粒度的控制。当然，使用cloud-init的前提是有一个cloud-init镜像。从[https://cloudinit.readthedocs.io](https://cloudinit.readthedocs.io)提供的文档中，我们可以了解到cloud-init引导有五个阶段：
- en: The `/etc/cloud/cloud-init.diabled` exists. For more information on this and
    all the other things in this chapter, please read the documentation (start at
    [https://cloudinit.readthedocs.io/en/latest/topics/boot.html](https://cloudinit.readthedocs.io/en/latest/topics/boot.html))
    since it contains much more detail about switches and different options that cloud-init
    supports and that make it tick.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在`/etc/cloud/cloud-init.diabled`。有关本章中的所有内容和其他内容的更多信息，请阅读文档（从[https://cloudinit.readthedocs.io/en/latest/topics/boot.html](https://cloudinit.readthedocs.io/en/latest/topics/boot.html)开始），因为它包含了关于cloud-init支持的开关和不同选项的更多详细信息。
- en: The `systemd` service called `cloud-init-local.service`, which will run as soon
    as possible and will block the network until it's done. The concept of blocking
    services and targets is used a lot in cloud-init initialization; the reason is
    simple – to ensure system stability. Since cloud-init procedures modify a lot
    of core settings for a system, we cannot afford to let the usual startup scripts
    run and create a parallel configuration that could overrun the one created by
    cloud-init.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名为`cloud-init-local.service`的`systemd`服务，它将尽快运行并阻塞网络直到完成。在cloud-init初始化中经常使用阻塞服务和目标的概念，原因很简单
    - 以确保系统稳定性。由于cloud-init过程修改了系统的许多核心设置，我们不能让通常的启动脚本运行并创建可能覆盖cloud-init创建的配置的并行配置。
- en: The `cloud-init.service`. This is the main service that will bring up the previously
    configured network and try to configure everything we scheduled in the data files.
    This will typically include grabbing all the files specified in our configuration,
    extracting them, and executing other preparation tasks. Disks will also be formatted
    and partitioned in this stage if such a configuration change is specified. Mount
    points will also get created, including those that are dynamic and specific to
    a particular cloud platform.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cloud-init.service`。这是主要服务，将启动之前配置好的网络，并尝试配置我们在数据文件中安排的一切。这通常包括获取我们配置中指定的所有文件，提取它们，并执行其他准备任务。如果指定了这样的配置更改，磁盘也将在此阶段进行格式化和分区。还将创建挂载点，包括那些动态的和特定于特定云平台的挂载点。'
- en: The `yum_repos` or `apt` modules), add an SSH key (the `ssh-import-id` module),
    and perform similar tasks in preparation for the next phase, in which we can actually
    use the configuration done in this phase.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yum_repos`或`apt`模块），添加SSH密钥（`ssh-import-id`模块），并执行类似的任务，为下一阶段做准备，我们实际上可以在这个阶段使用在此阶段完成的配置。'
- en: The **final** stage is the part of the system boot that runs things that would
    probably belong in userland – installing the packages, the configuration management
    plugin deployment, and executing possible user scripts.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终**阶段是系统引导的一部分，运行可能属于用户空间的东西 - 安装软件包、配置管理插件部署和执行可能的用户脚本。'
- en: After all this has been done, the system will be completely configured and up
    and running.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都完成后，系统将完全配置好并运行。
- en: The main advantage of this approach, although it seems complicated, is to have
    only one image stored in the cloud, and then to create simple configuration files
    that will only cover the differences between the *vanilla* default configuration,
    and the one that we need. Images can also be relatively small since they do not
    contain too many packages geared toward an end user.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要优势，尽管看起来复杂，是在云中只存储一个镜像，然后创建简单的配置文件，只覆盖*vanilla*默认配置和我们需要的配置之间的差异。镜像也可以相对较小，因为它们不包含太多面向最终用户的软件包。
- en: Cloud-init is often used as the first stage in deploying a lot of machines that
    are going to be managed by orchestration systems such as Puppet or Ansible since
    it provides a way to create working configurations that include ways of connecting
    to each instance separately. Every stage uses YAML as its primary data syntax,
    and almost everything is simply a list of different options and variables that
    get translated into configuration information. Since we are configuring a system,
    we can also include almost any other type of file in the configuration – once
    we can run a shell script while configuring the system, everything is possible.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud-init经常被用作部署许多将由编排系统（如Puppet或Ansible）管理的机器的第一阶段，因为它提供了一种创建包括连接到每个实例的方式的工作配置的方法。每个阶段都使用YAML作为其主要数据语法，几乎所有内容都只是不同选项和变量的列表，这些选项和变量会被转换为配置信息。由于我们正在配置一个系统，我们还可以在配置中包含几乎任何其他类型的文件——一旦我们可以在配置系统时运行shell脚本，一切皆有可能。
- en: '*Why is all of this so important?*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么所有这些如此重要？*'
- en: 'Cloud-init stems from a simple idea: create a single template that will define
    the base content of the operating system you plan to use. Then, we create a separate,
    specially formatted data file that will hold the customization data, and then
    combine those two at runtime to create a new instance when you need one. You can
    even improve things a bit by using a template as a base image and then create
    different systems as differencing images. Trading speed for convenience in this
    way can mean deploying in minutes instead of hours.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: cloud-init源自一个简单的想法：创建一个单一模板，定义您计划使用的操作系统的基本内容。然后，我们创建一个单独的、特殊格式的数据文件，其中包含定制数据，然后在运行时将这两者组合起来，以创建在需要时的新实例。您甚至可以通过使用模板作为基础镜像，然后创建不同的系统作为差异镜像，稍微改善一下，以便在几分钟而不是几小时内部署。
- en: 'The way cloud-init was conceived was to be as multiplatform as possible and
    to encompass as many operating systems as can reasonably be done. Currently, it
    supports the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: cloud-init的构想是尽可能多地支持多平台，并包括尽可能多的操作系统。目前，它支持以下操作系统：
- en: Ubuntu
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu
- en: SLES/openSUSE
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SLES/openSUSE
- en: RHEL/CentOS
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RHEL/CentOS
- en: Fedora
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fedora
- en: Gentoo Linux
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gentoo Linux
- en: Debian
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Debian
- en: Arch Linux
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arch Linux
- en: FreeBSD
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FreeBSD
- en: We enumerated all the distributions, but cloud-init, as its name suggests is
    also *cloud-aware*, which means that cloud-init is able to automatically detect
    and use almost any cloud environment. Running any distribution on any hardware
    or cloud is always a possibility, even without something like cloud-init, but
    since the idea is to create a platform-independent configuration that will be
    deployable on any cloud without any reconfiguration, our system needs to automatically
    account for any differences between different cloud infrastructures. On top of
    that, cloud-init can be used for bare-metal deployment, even if it isn't specifically
    designed for it, or to be more precise, even if it is designed for a lot more
    than that.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列举了所有的发行版，但正如其名称所示，cloud-init也是“云感知”的，这意味着cloud-init能够自动检测并使用几乎任何云环境。在任何硬件或云上运行任何发行版总是可能的，即使没有类似cloud-init这样的东西，但由于想要创建一个平台无关的配置，可以在任何云上部署而无需重新配置，我们的系统需要自动考虑不同云基础设施之间的任何差异。此外，即使cloud-init并非专门为裸金属部署而设计，或者更准确地说，即使它的设计远不止于此，它也可以用于裸金属部署。
- en: Important note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Being cloud-aware means that cloud-init gives us tools to do post-deployment
    checks and configuration changes, another extremely useful option.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 云感知意味着cloud-init为我们提供了进行部署后检查和配置更改的工具，这是另一个极其有用的选项。
- en: This all sounds a lot more theoretical than it should be. In practice, once
    you start using cloud-init and learn how to configure it, you will start to create
    a virtual machine infrastructure that will be almost completely independent of
    the cloud infrastructure you are using. In this book, we are using KVM as the
    main virtualization infrastructure, but cloud-init works with any other cloud
    environment, usually without any modification. Cloud-init was initially designed
    to enable easy deployment on Amazon AWS but it has long since transcended that
    limitation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切听起来比应该更加理论化。实际上，一旦开始使用cloud-init并学会如何配置它，您将开始创建一个几乎完全独立于您所使用的云基础设施的虚拟机基础架构。在本书中，我们使用KVM作为主要的虚拟化基础设施，但cloud-init可以与任何其他云环境一起使用，通常无需任何修改。cloud-init最初是为了在Amazon
    AWS上实现简单部署而设计的，但它早已超越了这种限制。
- en: Also, cloud-init is aware of all the small differences between different distributions,
    so all the things you put in your configuration file will be translated into whatever
    a particular distribution uses to accomplish a particular task. In that sense,
    cloud-init behaves a lot like Ansible – in essence, you define what needs to be
    done, not how to do it, and cloud-init takes that and makes it happen.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，cloud-init知晓不同发行版之间的所有细微差别，因此您在配置文件中设置的所有内容都将被转换为特定发行版用于完成特定任务的内容。在这方面，cloud-init的行为很像Ansible——实质上，您定义需要做什么，而不是如何做，cloud-init会接管并实现它。
- en: Installing and configuring cloud-init at boot time
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在启动时安装和配置cloud-init。
- en: The main thing that we are covering in this chapter is how to get cloud-init
    to run, and how to get all of its parts in the right place when the machine is
    being deployed, but this only scratches the surface of how cloud-init actually
    works. What you need to understand is that cloud-init runs as a service, configures
    the system, and follows what we told it to do in a certain way. After the system
    has booted, we can connect to it and see what was done, how, and analyze the logs.
    This could seem contrary to the idea of completely automatic deployment but it
    is there for a reason – whatever we do, there is always the possibility that we
    will need to debug the system or do some post-installation tasks that can also
    be automated.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中要讨论的主要内容是如何使cloud-init运行，并在部署机器时将其所有部分放在正确的位置，但这只是揭示了cloud-init实际工作原理的一部分。您需要理解的是，cloud-init作为一个服务运行，配置系统，并按照我们告诉它的方式进行操作。系统启动后，我们可以连接到它并查看已完成的工作，以及如何完成的，并分析日志。这可能与完全自动化部署的想法相悖，但这是有原因的-无论我们做什么，总会有可能需要调试系统或执行一些后安装任务，这些任务也可以自动化。
- en: 'Using cloud-init is not specifically confined to just debugging. After the
    system has booted, there is a large amount of data created by the system about
    how the boot was done, what actual cloud configuration the system is running on,
    and what was done in regard to customization. Any of your applications and scripts
    can then rely on this data and use it to run and detect certain configuration
    and deployment parameters. Check out this example, taken from a virtual machine
    in Microsoft Azure, running Ubuntu:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用cloud-init并不仅仅局限于调试。系统启动后，系统会生成大量关于启动方式、系统实际的云配置以及定制方面的数据。然后您的应用程序和脚本可以依赖这些数据，并用它来运行和检测某些配置和部署参数。请看这个例子，取自在Microsoft
    Azure上运行Ubuntu的虚拟机：
- en: '![ Figure 9.1 – A part of cloud-init output at boot time'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1-启动时cloud-init输出的一部分'
- en: '](img/B14834_09_01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_01.jpg)'
- en: Figure 9.1 – A part of cloud-init output at boot time
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1-启动时cloud-init输出的一部分
- en: Cloud-init actually displays this at boot time (and much more, depending on
    the cloud-init configuration file), and then puts all of this output into its
    log files, as well. So, we're really well covered in terms of the additional information
    that it produces.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: cloud-init实际上在启动时显示这个（根据cloud-init配置文件的不同，可能还有更多内容），然后将所有这些输出放入其日志文件中。因此，我们在额外信息方面得到了很好的覆盖。
- en: The next step in our cloud-init journey is discussing cloud-init images, as
    these are what we need to make cloud-init work. Let's do that now.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们cloud-init之旅的下一步是讨论cloud-init图片，因为这些是我们需要使cloud-init工作的东西。让我们现在来做这件事。
- en: Cloud-init images
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cloud-init图片
- en: In order to use cloud-init at boot time, we first need a cloud image. At its
    core, it is basically a semi-installed system that contains specially designed
    scripts that support cloud-init installation. On all distributions, these scripts
    are part of a package called cloud-init, but images are usually more prepared
    than that since they try to negotiate a fine line between size and convenience
    of installation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在启动时使用cloud-init，我们首先需要一个云镜像。在其核心，它基本上是一个半安装的系统，其中包含专门设计的脚本，支持cloud-init安装。在所有发行版上，这些脚本都是cloud-init包的一部分，但是镜像通常比这更加准备就绪，因为它们试图在大小和安装便利性之间找到一个平衡点。
- en: 'In our examples, we are going to use the ones available at the following URLs:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用以下网址提供的图片：
- en: '[https://cloud.centos.org/](https://cloud.centos.org/)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://cloud.centos.org/](https://cloud.centos.org/)'
- en: '[https://cloud-images.ubuntu.com/](https://cloud-images.ubuntu.com/)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://cloud-images.ubuntu.com/](https://cloud-images.ubuntu.com/)'
- en: In all the examples we are going to work with, the main intention is to show
    how the system works on two completely different architectures with minimal to
    no modifications.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将要处理的所有示例中，主要意图是展示系统如何在两种完全不同的架构上运行，几乎没有或没有最小的修改。
- en: Under normal circumstances, getting the image is all you need to be able to
    run cloud-init. Everything else is handled by the data files.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，获取镜像就是您需要能够运行cloud-init的一切。其他一切都由数据文件处理。
- en: 'For example, these are some of the available images for the CentOS distribution:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这些是CentOS发行版的一些可用图片：
- en: '![ Figure 9.2 – A wealth of available cloud-init images for CentOS'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2-为CentOS提供的丰富的cloud-init图片'
- en: '](img/B14834_09_02.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_02.jpg)'
- en: Figure 9.2 – A wealth of available cloud-init images for CentOS
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2-为CentOS提供的丰富的cloud-init图片
- en: Notice that images cover almost all of the releases of the distribution, so
    we can simply test our systems not only on the latest version but on all the other
    versions available. We can freely use all of these images, which is exactly what
    we are going to do a bit later when we start with our examples.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，几乎所有发行版的发布都包含了图片，因此我们不仅可以在最新版本上测试我们的系统，还可以在所有其他可用版本上进行测试。我们可以自由使用所有这些图片，这正是我们稍后将要做的事情，当我们开始使用我们的示例时。
- en: Cloud-init data sources
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cloud-init数据源
- en: Let's talk a little about data files. Up to now, we have referred to them generically,
    and we had a big reason to do so. One of the things that make cloud-init stand
    out from other utilities is its ability to support different ways of getting the
    information on what to install and how to install it. We call these configuration
    files data sources, and they can be separated into two broad categories – **user
    data** and **metadata**. We will talk a lot more about each of those in this chapter,
    but as an early introduction, let's say that everything that a user creates as
    part of the configuration, including YAML files, scripts, configuration files,
    and possibly other files to be put on a system, such as applications and dependencies
    that are part of user data. Metadata usually comes directly from the cloud provider
    or serves the purpose of identifying machines.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微谈谈数据文件。到目前为止，我们已经泛泛地提到它们，并且我们有充分的理由这样做。使cloud-init脱颖而出的一件事是它支持不同的获取安装信息和如何安装的方式。我们称这些配置文件为数据源，它们可以分为两大类
    - **用户数据**和**元数据**。我们将在本章中更详细地讨论每一个，但作为早期介绍，让我们说一下，用户作为配置的一部分创建的所有东西，包括YAML文件、脚本、配置文件，可能还有其他要放在系统上的文件，比如用户数据的应用程序和依赖项。元数据通常直接来自云提供商或用于标识机器。
- en: It contains instance data, hostnames, network name, and other cloud-specific
    details that can prove useful when deploying. We can use both these types of data
    during boot and will be doing so. Everything we put in will be stored in a large
    JSON store in `/run/cloud-init/instance-data.json` at runtime, or as part of the
    actual machine configuration. A good example of this is the hostname, part of
    the metadata that will end up as the actual hostname on the individual machine.
    This file is populated by cloud-init and can be accessed through the command line
    or directly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含实例数据、主机名、网络名称和其他在部署时可能有用的云特定细节。我们可以在引导过程中使用这两种类型的数据，并且将这样做。我们放入的所有内容都将在运行时存储在`/run/cloud-init/instance-data.json`中的大型JSON存储中，或作为实际机器配置的一部分。这个文件的一个很好的例子是主机名，作为最终将成为个别机器上实际主机名的元数据的一部分。这个文件由cloud-init填充，并且可以通过命令行或直接访问。
- en: When creating any file in the configuration, we can use any file format available,
    and we are able to compress the files if needed – cloud-init will decompress them
    before it runs. If we need to pass the actual files into the configuration, there
    is a limitation though – files need to be encoded as text and put into variables
    in a YAML file, to be used and written later on the system we are configuring.
    Just like cloud-init, YAML syntax is declarative – this is an important thing
    to remember.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建任何配置文件时，我们可以使用任何可用的文件格式，并且如果需要，我们可以压缩文件 - cloud-init将在运行之前对其进行解压缩。如果我们需要将实际文件传递到配置中，尽管有一个限制
    - 文件需要编码为文本并放入YAML文件中的变量中，以便在我们正在配置的系统上稍后使用和写入。就像cloud-init一样，YAML语法是声明性的 - 这是一个重要的事情要记住。
- en: Now, let's learn how we pass metadata and user data to cloud-init.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何将元数据和用户数据传递给cloud-init。
- en: Passing metadata and user data to cloud-init
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将元数据和用户数据传递给cloud-init
- en: In our examples, we are going to create a file that will essentially be an `.iso`
    image and behave like a CD-ROM connected to the booting machine. Cloud-init knows
    how to handle a situation like this, and will mount the file, extract all the
    scripts, and run them in a predetermined order, as we already mentioned when we
    explained how the boot sequence works (check the *Understanding cloud-init architecture*
    section earlier in this chapter).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将创建一个文件，它实质上是一个`.iso`镜像，并且会像连接到引导机器的CD-ROM一样行为。Cloud-init知道如何处理这种情况，并且会挂载文件，提取所有脚本，并按照预定顺序运行它们，就像我们在解释引导顺序是已经提到的那样（在本章前面的*理解cloud-init架构*部分中检查）。
- en: 'In essence, what we have to do to get the whole thing running is to create
    an image that will get connected to the cloud template, and that will provide
    all the data files to the cloud-init scripts inside the template. This is a three-step
    process:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们需要做的是创建一个镜像，将其连接到云模板，并在模板内部提供所有数据文件给cloud-init脚本。这是一个三步过程：
- en: We have to create the files that hold the configuration information.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须创建保存配置信息的文件。
- en: We have to create an image that contains the file data in the right place.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须创建一个包含文件数据的镜像，并将其放在正确的位置。
- en: We need to associate the image with the template at boot time.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在引导时将镜像与模板关联起来。
- en: The most complicated part is defining how and what we need to configure when
    booting. All of this is accomplished on a machine that is running the cloud-utils
    package for a given distribution.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最复杂的部分是定义在引导时如何配置以及需要配置什么。所有这些都是在运行给定发行版的云工具软件包的机器上完成的。
- en: 'At this point, we need to make a point about the two different packages that
    are used in all the distributions to enable cloud-init support:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要指出在所有发行版中用于启用cloud-init支持的两种不同软件包：
- en: '`cloud-init` – Contains all that is necessary to enable a computer to reconfigure
    itself during boot if it encounters a cloud-init configuration'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cloud-init` - 包含使计算机能够在引导过程中重新配置自身的一切必要内容，如果遇到云初始化配置'
- en: '`cloud-utils` – Is used to create a configuration that is to be applied to
    a cloud image'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cloud-utils` - 用于创建要应用于云镜像的配置'
- en: The main difference between these packages is the computer we are installing
    them on. `cloud-init` is to be installed on the computer we are configuring and
    is part of the deployment image. `cloud-utils` is the package intended to be used
    on the computer that will create the configuration.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些软件包之间的主要区别是我们安装它们的计算机。`cloud-init`是要安装在我们正在配置的计算机上的，并且是部署镜像的一部分。`cloud-utils`是用于在将创建配置的计算机上使用的软件包。
- en: 'In all the examples and all the configuration steps in this chapter, we are
    in fact referring to two different computers/servers: one that can be considered
    primary, and the one that we are using in this chapter – unless we state otherwise
    – is the computer that we use to create the configuration for cloud-init deployment.
    This is not the computer that is going to be configured using this configuration,
    just a computer that we use as a workstation to prepare our files.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的所有示例和所有配置步骤中，实际上我们在引用两台不同的计算机/服务器：一台可以被视为主要计算机，而我们在本章中使用的计算机-除非另有说明-是我们用来创建cloud-init部署配置的计算机。这不是将使用此配置进行配置的计算机，而只是我们用作工作站准备文件的计算机。
- en: In this simplified environment, this is the same computer that runs the entire
    KVM virtualization and is used both to create and deploy virtual machines. In
    a normal setup, we would probably create our configuration on a workstation that
    we work on and deploy to some kind of KVM-based host or cluster. In that case,
    every step that we present in this chapter basically remains the same; the only
    difference is the place that we deploy to, and the way that the virtual machine
    is invoked for the first boot.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种简化的环境中，这是运行整个KVM虚拟化并用于创建和部署虚拟机的同一台计算机。在正常设置中，我们可能会在工作站上创建我们的配置，并部署到某种基于KVM的主机或集群。在这种情况下，我们在本章中呈现的每个步骤基本上保持不变；唯一的区别是我们部署的位置，以及第一次启动时调用虚拟机的方式。
- en: We will also note that some virtualization environments, such as OpenStack,
    oVirt, or RHEV-M, have direct ways to communicate with a cloud-init enabled template.
    Some of them even permit you to directly reconfigure the machine on first boot
    from a GUI, but that falls way out of the scope of this book.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将注意到，一些虚拟化环境，如OpenStack、oVirt或RHEV-M，有直接的方式与启用了cloud-init的模板进行通信。其中一些甚至允许您在首次启动时直接从GUI重新配置机器，但这超出了本书的范围。
- en: The next topic on our list is cloud-init modules. Cloud-init uses modules for
    a reason – to extend its range of available actions it can take in the virtual
    machine boot phase. There are dozens of cloud-init modules available – `SSH`,
    `yum`, `apt`, setting `hostname`, `password`, `locale`, and creating users and
    groups, to name a few. Let's check how we can use them.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表中的下一个主题是cloud-init模块。Cloud-init使用模块的原因是为了扩展其在虚拟机引导阶段可以采取的可用操作范围。有数十个可用的cloud-init模块-`SSH`、`yum`、`apt`、设置`hostname`、`password`、`locale`和创建用户和组等。让我们看看如何使用它们。
- en: Using cloud-init modules
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用cloud-init模块
- en: 'When creating a configuration file, in cloud-init, pretty much like in any
    other software abstraction layer, we are dealing with modules that are going to
    translate our more-or-less universal configuration demands, such as *this package
    needs to be installed* into actual shell commands on a particular system. The
    way this is done is through **modules**. Modules are logical units that break
    down different functionalities into smaller groups and enable us to use different
    commands. You can check the list of all available modules at the following link:
    [https://cloudinit.readthedocs.io/en/latest/topics/modules.html](https://cloudinit.readthedocs.io/en/latest/topics/modules.html).
    It''s quite a list, which will just further show you how well developed cloud-init
    is.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建配置文件时，在cloud-init中，几乎与任何其他软件抽象层一样，我们正在处理将我们更多或少通用的配置需求（例如*需要安装此软件包*）转换为特定系统上的实际shell命令的模块。这是通过**模块**完成的。模块是将不同功能分解为较小组的逻辑单元，并使我们能够使用不同的命令。您可以在以下链接中查看所有可用模块的列表：[https://cloudinit.readthedocs.io/en/latest/topics/modules.html](https://cloudinit.readthedocs.io/en/latest/topics/modules.html)。这是一个相当长的列表，这将进一步显示出cloud-init的开发程度。
- en: As we can see from the list, some of the modules, such as, for example, `Disk
    setup` or `Locale`, are completely platform-independent while some, for example,
    `Puppet`, are designed to be used with a specific software solution and its configuration,
    and some are specific to a particular distribution or a group of distributions,
    like `Yum Add Repo` or `Apt Configure`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表中我们可以看到，例如`Disk setup`或`Locale`等一些模块是完全独立于平台的，而例如`Puppet`等一些模块则设计用于与特定软件解决方案及其配置一起使用，而一些则特定于特定发行版或一组发行版，如`Yum
    Add Repo`或`Apt Configure`。
- en: This can seem to break the idea of a completely distribution-agnostic way to
    deploy everything, but you must remember two things – cloud-init is first and
    foremost cloud-agnostic, not distribution-agnostic, and distributions sometimes
    have things that are way too different to be solved with any simple solution.
    So, instead of trying to be everything at once, cloud-init solves enough problems
    to be useful, and at the same time tries not to create new ones.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎破坏了完全与发行版无关的部署一切的想法，但您必须记住两件事-cloud-init首先是与云无关的，而不是与发行版无关的，并且发行版有时具有太不同的东西，无法用任何简单的解决方案解决。因此，云-init解决了足够多的问题以便有用，并且同时尽量不制造新问题。
- en: Important note
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We are not going to deal with particular modules one by one since it would make
    this chapter too long and possibly turn it into a book on its own. If you plan
    on working with cloud-init, consult the module documentation since it will provide
    all the up-to-date information you need.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会逐个处理特定模块，因为这将使本章变得太长，并可能使其成为一本独立的书。如果您打算使用cloud-init，请参阅模块文档，因为它将提供您所需的所有最新信息。
- en: Examples on how to use a cloud-config script with cloud-init
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用cloud-init的cloud-config脚本的示例
- en: First, you need to download the cloud images and resize them in order to make
    sure that the disk size after everything is installed is large enough to accommodate
    all the files you plan to put in the machine you created. In these examples, we
    are going to use two images, one for CentOS, and another for Ubuntu Server. We
    can see that the CentOS image we are using is 8 GB in size, and we will enlarge
    it to 10 GB. Note that the actual size on the disk is not going to be 10 GB; we
    are just allowing the image to grow to this size.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要下载云镜像并调整大小，以确保在安装所有文件后磁盘大小足够大，可以容纳您计划放入所创建的机器中的所有文件。在这些示例中，我们将使用两个镜像，一个用于CentOS，另一个用于Ubuntu服务器。我们可以看到我们使用的CentOS镜像大小为8
    GB，我们将其扩大到10 GB。请注意，磁盘上的实际大小不会达到10 GB；我们只是允许镜像增长到这个大小。
- en: 'We are going to do the same with the Ubuntu image, after we get it from the
    internet. Ubuntu also publishes cloud versions of their distribution daily, for
    all supported versions. The main difference is that Ubuntu creates images that
    are designed to be 2.2 GB when full. We downloaded an image from [https://cloud.centos.org](https://cloud.centos.org);
    let''s now get some information about it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从互联网上获取Ubuntu镜像后，对其进行相同操作。Ubuntu还会每天发布其分布的云版本，适用于所有支持的版本。主要区别在于Ubuntu创建的镜像在满时设计为2.2
    GB。我们从[https://cloud.centos.org](https://cloud.centos.org)下载了一个镜像；现在让我们获取一些关于它的信息：
- en: '![ Figure 9.3 – Cloud-init image sizes'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 - Cloud-init镜像大小'
- en: '](img/B14834_09_03.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_03.jpg)'
- en: Figure 9.3 – Cloud-init image sizes
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 - Cloud-init镜像大小
- en: 'Note that the actual size on the disk is different – `qemu-img` gives us 679
    MB and 2.2 GB versus roughly 330 MB and 680 MB of actual disk usage:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意磁盘上的实际大小不同- `qemu-img`给出的是679 MB和2.2 GB，而实际磁盘使用量大约为330 MB和680 MB：
- en: '![ Figure 9.4 – Image size via qemu-img differs from the real virtual image
    size'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 - 通过qemu-img测得的镜像大小与实际虚拟镜像大小不同'
- en: '](img/B14834_09_04.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_04.jpg)'
- en: Figure 9.4 – Image size via qemu-img differs from the real virtual image size
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 - 通过qemu-img测得的镜像大小与实际虚拟镜像大小不同
- en: 'We can now do a couple of everyday administration tasks on these images – grow
    them, move them to the correct directory for KVM, use them as a base image, and
    then customize them via cloud-init:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以对这些镜像进行一些日常管理任务-扩大它们，将它们移动到KVM的正确目录，将它们用作基础镜像，然后通过cloud-init进行自定义：
- en: Let's make these images bigger, just so that we can have them ready for future
    capacity needs (and practice):![Figure 9.5 – Growing the Ubuntu and CentOS maximum
    image size to 10 GB via qemu-img
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们把这些镜像变大，这样我们就可以为未来的容量需求（和实践）做好准备：![图9.5 - 通过qemu-img将Ubuntu和CentOS的最大镜像大小增加到10
    GB
- en: '](img/B14834_09_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_05.jpg)'
- en: Figure 9.5 – Growing the Ubuntu and CentOS maximum image size to 10 GB via qemu-img
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 - 通过qemu-img将Ubuntu和CentOS的最大镜像大小增加到10 GB
- en: 'After growing our images, note that the size on the disk hasn''t changed much:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 扩大我们的镜像后，请注意磁盘上的大小几乎没有变化：
- en: '![ Figure 9.6 – The real disk usage has changed only slightly'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 - 实际磁盘使用量只有轻微变化'
- en: '](img/B14834_09_06.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_06.jpg)'
- en: Figure 9.6 – The real disk usage has changed only slightly
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 - 实际磁盘使用量只有轻微变化
- en: The next step is to prepare our environment for the cloud-image procedure so
    that we can enable cloud-init to do its magic.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是准备我们的环境以进行云镜像过程，以便我们可以启用cloud-init发挥其作用。
- en: The images that we are going to use are going to be stored in `/var/lib/libvirt/images`:![
    Figure 9.7 – Moving images to the KVM default system directory
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用的镜像将存储在`/var/lib/libvirt/images`中：![图9.7 - 将镜像移动到KVM默认系统目录
- en: '](img/B14834_09_07.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_07.jpg)'
- en: Figure 9.7 – Moving images to the KVM default system directory
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 - 将镜像移动到KVM默认系统目录
- en: We are going to create our first cloud-enabled deployment in the simplest way
    possible, by only repartitioning the disk and creating a single user with a single
    SSH key. The key belongs to the root of the host machine, so we can directly log
    in to the deployed machine after cloud-init is done.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以最简单的方式创建我们的第一个云启用部署，只需重新分区磁盘并创建一个带有单个SSH密钥的用户。密钥属于主机的根目录，因此在cloud-init完成后我们可以直接登录到部署的机器上。
- en: 'Also, we are going to use our images as base images by running the following
    command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将通过运行以下命令将我们的镜像用作基础镜像：
- en: '![Figure 9.8 – Creating an image disk for deployment'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8 - 创建用于部署的镜像磁盘'
- en: '](img/B14834_09_08.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_08.jpg)'
- en: Figure 9.8 – Creating an image disk for deployment
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 - 创建用于部署的镜像磁盘
- en: The images are now ready. The next step is to start the cloud-init configuration.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在镜像已经准备好了。下一步是开始cloud-init配置。
- en: First, create a local metadata file and put the new virtual machine name in
    it.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个本地元数据文件，并在其中放入新的虚拟机名称。
- en: 'The file will be named `meta-data` and we are going to use `local-hostname`
    to set the name:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件将被命名为`meta-data`，我们将使用`local-hostname`来设置名称：
- en: '[PRE0]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have three files in our directory: a hard disk that uses a base file with
    the cloud template, a `meta-data` file that contains just minimal information
    that is essential for our deployment, and `user-data`, which contains our definitions
    for our user. We didn''t even try to install or copy anything; this install is
    as minimal as it gets, but in a normal environment this is a regular starting
    point, as a lot of deployments are intended only to bring our machine online,
    and then do the rest of the installation by using other tools. Let''s move to
    the next step.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的目录中有三个文件：一个使用云模板的基本文件的硬盘，一个包含仅对我们的部署至关重要的最小信息的`meta-data`文件，以及`user-data`，其中包含我们用户的定义。我们甚至没有尝试安装或复制任何东西；这个安装尽可能地简化，但在正常环境中，这是一个常规的起点，因为很多部署只是为了让我们的机器上线，然后通过其他工具完成其余的安装。让我们进入下一步。
- en: We need a way to connect the files we just created, the configuration, with
    the virtual machine. Usually, this is done in a couple of ways. The simplest way
    is usually to generate a `.iso` file that contains the files. Then we just mount
    the file as a virtual CD-ROM when we create the machine. On boot, cloud-init will
    look for the files automatically.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来连接我们刚刚创建的文件和配置与虚拟机。通常有几种方法可以做到这一点。最简单的方法通常是生成一个包含文件的`.iso`文件。然后在创建机器时，我们只需将文件挂载为虚拟CD-ROM。在启动时，cloud-init将自动查找文件。
- en: 'Another way is to host the files somewhere on the network and grab them when
    we need them. It is also possible to combine these two strategies. We will discuss
    this a little bit later, but let''s finish our deployment first. The local `.iso`
    image is the way we are going to go on this deployment. There is a tool called
    `genisoimage` (provided by the package with the same name) that is extremely useful
    for this (the following command is a one-line command):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将文件托管在网络上的某个地方，并在需要时获取它们。也可以结合这两种策略。我们稍后会讨论这一点，但让我们先完成我们的部署。本地的`.iso`映像是我们将在这次部署中采用的方式。有一个名为`genisoimage`的工具（由同名的软件包提供），对此非常有用（以下命令是一行命令）：
- en: '[PRE1]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What we are doing here is creating an emulated CD-ROM image that will follow
    the ISO9660/Joliet standard with Rock Ridge extensions. If you have no idea what
    we just said, ignore all this and think about it this way – we are creating a
    file that will hold our metadata and user data and present itself as a CD-ROM:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是创建一个仿真的CD-ROM映像，它将遵循ISO9660/Joliet标准和Rock Ridge扩展。如果你不知道我们刚才说了什么，就忽略这一切，这样想一想
    - 我们正在创建一个将保存我们的元数据和用户数据并呈现为CD-ROM的文件：
- en: '![ Figure 9.11 – Creating an ISO image'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![ 图9.11 - 创建ISO映像'
- en: '](img/B14834_09_11.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_11.jpg)'
- en: Figure 9.11 – Creating an ISO image
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 - 创建ISO映像
- en: 'In the end, we are going to get something like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将得到类似于这样的东西：
- en: '![Figure 9.12 – ISO is created and we are ready to start a cloud-init deployment'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.12 - ISO已创建，我们准备开始云初始化部署'
- en: '](img/B14834_09_12.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_12.jpg)'
- en: Figure 9.12 – ISO is created and we are ready to start a cloud-init deployment
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 - ISO已创建，我们准备开始云初始化部署
- en: Please note that images are taken post deployment, so the size of disk can vary
    wildly based on your configuration. This was all that was needed in the form of
    preparations. All that's left is to spin up our virtual machine.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，图像是在部署后拍摄的，因此磁盘的大小可能会根据您的配置而大不相同。这就是所有需要的准备工作。剩下的就是启动我们的虚拟机。
- en: Now, let's start with our deployments.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始我们的部署。
- en: The first deployment
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一次部署
- en: 'We are going to deploy our virtual machine by using a command line:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用命令行部署我们的虚拟机：
- en: '[PRE2]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Although it may look complicated, if you came to this part of the book after
    reading its previous chapters, there should be nothing you haven''t seen yet.
    We are using KVM, creating a name for our domain (virtual machine), we are going
    to give it 1 CPU and 2 GB of RAM. We are also telling KVM we are installing a
    generic Linux system. We already created our hard disk, so we are mounting it
    as our primary drive, and we are also mounting our `.iso` file to serve as a CD-ROM.
    Lastly, we will connect our virtual machine to the default network:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来可能很复杂，但如果你在阅读了本书之前的章节后来到这一部分，那么你应该已经见过了。我们正在使用KVM，为我们的域（虚拟机）创建一个名称，我们将给它1个CPU和2GB的RAM。我们还告诉KVM我们正在安装一个通用的Linux系统。我们已经创建了我们的硬盘，所以我们正在将它挂载为我们的主要驱动器，并且我们也正在挂载我们的`.iso`文件作为CD-ROM。最后，我们将连接我们的虚拟机到默认网络：
- en: '![](img/B14834_09_13.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B14834_09_13.jpg)'
- en: Figure 9.13 – Deploying and testing a cloud-init customized virtual machine
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 - 部署和测试一个经过云初始化定制的虚拟机
- en: The deployment will probably take a minute or two. As soon as the machine boots,
    it will get the IP address and we can SSH to it using our predefined key. The
    only thing that was not automated is accepting the fingerprint of the newly booted
    machine automatically.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 部署可能需要一两分钟。一旦机器启动，它将获得IP地址，我们可以使用预定义的密钥通过SSH连接到它。唯一没有自动化的是自动接受新启动的机器的指纹。
- en: 'Now, the time has come to see what happened when we booted the machine. Cloud-init
    generated a log at `/var/log` named `cloud-init.log`. The file will be fairly
    large, and the first thing you will notice is that the log is set to provide debug
    information, so almost everything will be logged:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看看当我们启动机器时发生了什么。Cloud-init在`/var/log`生成了一个名为`cloud-init.log`的日志。文件会相当大，你会注意到的第一件事是日志设置为提供调试信息，所以几乎所有内容都会被记录：
- en: '![Figure 9.14 – The cloud-init.log file, used to check what cloud-init did
    to the operating system'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14 - cloud-init.log文件，用于检查cloud-init对操作系统的操作'
- en: '](img/B14834_09_14.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_14.jpg)'
- en: Figure 9.14 – The cloud-init.log file, used to check what cloud-init did to
    the operating system
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 - cloud-init.log文件，用于检查cloud-init对操作系统的操作
- en: Another thing is how much actually happens below the surface completely automatically.
    Since this is CentOS, cloud-init has to deal with the SELinux security contexts
    in real time, so a lot of the information is simply that. There are also a lot
    of probes and tests going on. Cloud-init has to establish what the running environment
    is and what type of cloud it is running under. If something happens during the
    boot process and it in any way involves cloud-init, this is the first place to
    look.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件事是在表面以下完全自动发生了多少。由于这是CentOS，cloud-init必须实时处理SELinux安全上下文，因此很多信息只是这样。还有很多探测和测试正在进行。Cloud-init必须确定运行环境是什么以及它正在哪种类型的云下运行。如果在启动过程中发生了任何与cloud-init有关的事情，这是第一个要查看的地方。
- en: Let's now deploy our second virtual machine by using a second (Ubuntu) image.
    This is where cloud-init really shines – it works with various Linux (and *BSD)
    distributions, whatever they might be. We can put that to the test now.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过使用第二个（Ubuntu）映像来部署我们的第二个虚拟机。这就是cloud-init真正发挥作用的地方 - 它可以与各种Linux（和*BSD）发行版一起工作，无论它们是什么。我们现在可以测试一下。
- en: The second deployment
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二次部署
- en: 'The next obvious step is to create another virtual machine, but to prove a
    point, we are going to use Ubuntu Server (Bionic) as our image:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个明显的步骤是创建另一个虚拟机，但为了证明一点，我们将使用Ubuntu Server（Bionic）作为我们的镜像：
- en: '![ Figure 9.15 – Preparing our environment for another cloud-init-based virtual
    machine deployment'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.15-为另一个基于cloud-init的虚拟机部署准备我们的环境'
- en: '](img/B14834_09_15.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_15.jpg)'
- en: Figure 9.15 – Preparing our environment for another cloud-init-based virtual
    machine deployment
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15-为另一个基于cloud-init的虚拟机部署准备我们的环境
- en: 'What do we need to do? We need to copy both `meta-data` and `user-data` to
    the new folder. We need to edit the metadata file since it has the hostname inside
    it, and we want our new machine to have a different hostname. As for `user-data`,
    it is going to be completely the same as on our first virtual machine. Then we
    need to create a new disk and resize it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做什么？我们需要将`meta-data`和`user-data`都复制到新文件夹中。我们需要编辑元数据文件，因为其中包含主机名，我们希望我们的新机器有一个不同的主机名。至于`user-data`，它将与我们的第一个虚拟机完全相同。然后我们需要创建一个新的磁盘并调整其大小：
- en: '![ Figure 9.16 – Growing our virtual machine image for deployment purposes'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.16-为部署目的扩展我们的虚拟机镜像'
- en: '](img/B14834_09_16.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_16.jpg)'
- en: Figure 9.16 – Growing our virtual machine image for deployment purposes
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16-为部署目的扩展我们的虚拟机镜像
- en: 'We are creating a virtual machine from our downloaded image, and just allowing
    for more space as the image is run. The last step is to start the machine:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从下载的镜像创建虚拟机，并且在运行镜像时允许更多空间。最后一步是启动虚拟机：
- en: '![Figure 9.17 – Deploying our second virtual machine with cloud-init'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.17-使用cloud-init部署我们的第二个虚拟机'
- en: '](img/B14834_09_17.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_17.jpg)'
- en: Figure 9.17 – Deploying our second virtual machine with cloud-init
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17-使用cloud-init部署我们的第二个虚拟机
- en: 'The command line is almost exactly the same, only the names change:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行几乎完全相同，只是名称不同：
- en: '[PRE3]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now let''s check the IP addresses:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查IP地址：
- en: '![Figure 9.18 – Check the virtual machine IP addresses'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.18-检查虚拟机IP地址'
- en: '](img/B14834_09_18.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_18.jpg)'
- en: Figure 9.18 – Check the virtual machine IP addresses
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18-检查虚拟机IP地址
- en: 'We can see both of the machines are up and running. Now for the big test –
    can we connect? Let''s use the `SSH` command to try:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到两台机器都已经启动并运行。现在进行大测试-我们能连接吗？让我们使用`SSH`命令尝试：
- en: '![ Figure 9.19 – Using SSH to verify whether we can connect to our virtual
    machine'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.19-使用SSH验证我们是否可以连接到虚拟机'
- en: '](img/B14834_09_19.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_19.jpg)'
- en: Figure 9.19 – Using SSH to verify whether we can connect to our virtual machine
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19-使用SSH验证我们是否可以连接到虚拟机
- en: As we can see, the connection to our virtual machine works without any problems.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，连接到我们的虚拟机没有任何问题。
- en: 'One more thing is to check the deployment log. Note that there is no mention
    of configuring SELinux since we are running on Ubuntu:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事是检查部署日志。请注意，由于我们正在运行Ubuntu，因此没有提到配置SELinux：
- en: '![ Figure 9.20 – The Ubuntu cloud-init log file has no mention of SELinux'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.20-Ubuntu cloud-init日志文件中没有提到SELinux'
- en: '](img/B14834_09_20.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_20.jpg)'
- en: Figure 9.20 – The Ubuntu cloud-init log file has no mention of SELinux
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20-Ubuntu cloud-init日志文件中没有提到SELinux
- en: Just for fun, let's do another deployment with a twist – let's use a module
    to deploy a software package.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了好玩，让我们以一个变通的方式进行另一个部署-让我们使用一个模块来部署一个软件包。
- en: The third deployment
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三次部署
- en: 'Let''s deploy another image. In this instance, we are creating another CentOS
    7 but this time we are *installing* (not *starting*) `httpd` in order to show
    how this type of configuration works. Once again, the steps are simple enough:
    create a directory, copy the metadata and user data files, modify the files, create
    the `.iso` file, create the disk, and run the machine.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们部署另一个镜像。在这种情况下，我们创建另一个CentOS 7，但这次我们是*安装*（而不是*启动*）`httpd`，以展示这种类型的配置如何工作。再次，步骤足够简单：创建一个目录，复制元数据和用户数据文件，修改文件，创建`.iso`文件，创建磁盘，运行机器。
- en: 'This time we are adding another section (`packages`) to the configuration,
    so that we can *tell* cloud-init that we need a package to be installed (`httpd`):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们正在向配置添加另一部分（`packages`），以便我们可以*告诉*cloud-init我们需要安装一个软件包（`httpd`）：
- en: '![ Figure 9.21 – Cloud-init configuration file for the third virtual machine
    deployment'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.21-用于第三次虚拟机部署的Cloud-init配置文件'
- en: '](img/B14834_09_21.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_21.jpg)'
- en: Figure 9.21 – Cloud-init configuration file for the third virtual machine deployment
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21-用于第三次虚拟机部署的Cloud-init配置文件
- en: 'Since all the steps are more or less the same, we get the same result – success:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有步骤多多少少都是相同的，我们得到了相同的结果-成功：
- en: '![ Figure 9.22 – Repeating the deployment process for the third virtual machine'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.22-重复第三个虚拟机的部署过程'
- en: '](img/B14834_09_22.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_22.jpg)'
- en: Figure 9.22 – Repeating the deployment process for the third virtual machine
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22-重复第三个虚拟机的部署过程
- en: We should wait for a while so that the VM gets deployed. After that, let's log
    in and check whether the image deployed correctly. We asked for `httpd` to be
    installed during the deployment. Was it?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该等一会儿，以便虚拟机部署完成。之后，让我们登录并检查镜像是否正确部署。我们要求在部署过程中安装`httpd`。是吗？
- en: '![ Figure 9.23 – Checking whether httpd is installed but not started'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.23-检查httpd是否已安装但未启动'
- en: '](img/B14834_09_23.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_23.jpg)'
- en: Figure 9.23 – Checking whether httpd is installed but not started
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.23-检查httpd是否已安装但未启动
- en: We can see that everything was done as expected. We haven't asked for the service
    to start, so it is installed with the default settings and is disabled and stopped
    by default.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一切都如预期完成。我们没有要求启动服务，因此它是按默认设置安装的，并且默认情况下是禁用和停止的。
- en: After the installation
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装后
- en: The intended use of cloud-init is to configure machines and create an environment
    that will enable further configuration or straight deployment into production.
    But to enable that, cloud-init has a lot of options that we haven't even mentioned
    yet. Since we have an instance running, we can go through the most important and
    the most useful things you can find in the newly booted virtual machine.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: cloud-init的预期用途是配置机器并创建一个能够实现进一步配置或直接部署到生产环境的环境。但是，为了实现这一点，cloud-init有很多选项，我们甚至还没有提到。由于我们有一个正在运行的实例，我们可以浏览一下在新启动的虚拟机中可以找到的最重要和最有用的东西。
- en: 'The first thing to check is the `/run/cloud-init` folder:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要检查的是`/run/cloud-init`文件夹：
- en: '![ Figure 9.24 – /run/cloud-init folder contents'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.24 - /run/cloud-init文件夹内容'
- en: '](img/B14834_09_24.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_24.jpg)'
- en: Figure 9.24 – /run/cloud-init folder contents
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24 - /run/cloud-init文件夹内容
- en: Everything that is created at runtime is written here, and available for users.
    Our demo machine was run under the local KVM hypervisor so cloud-init is not detecting
    a cloud, and consequently is unable to provide more data about the cloud, but
    we can see some interesting details. The first one is two files named `enabled`
    and `network-config-ready`. Both of them are empty but very important. The fact
    that they exist signifies that cloud-init is enabled, and that network has been
    configured and is working. If the files are not there, something went wrong and
    we need to go back and debug. More about debugging can be found at [https://cloudinit.readthedocs.io/en/latest/topics/debugging.html](https://cloudinit.readthedocs.io/en/latest/topics/debugging.html).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在运行时创建的内容都写在这里，并且对用户可用。我们的演示机器是在本地KVM hypervisor下运行的，因此cloud-init没有检测到云，并且因此无法提供有关云的更多数据，但我们可以看到一些有趣的细节。第一个是两个名为`enabled`和`network-config-ready`的文件。它们都是空的，但非常重要。它们存在的事实表明cloud-init已启用，并且网络已配置并且正在工作。如果文件不存在，那么出了问题，我们需要返回并进行调试。有关调试的更多信息可以在[https://cloudinit.readthedocs.io/en/latest/topics/debugging.html](https://cloudinit.readthedocs.io/en/latest/topics/debugging.html)找到。
- en: The `results.json` file holds this particular instance metadata. `status.json`
    is more concentrated on what happened when the whole process was running, and
    it provides info on possible errors, the time it took to configure different parts
    of the system, and whether everything was done.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`results.json`文件保存了这个特定实例的元数据。`status.json`更集中于整个过程运行时发生了什么，并提供了关于可能的错误、配置系统不同部分所花费的时间以及是否完成的信息。'
- en: Both those files are intended to help with the configuration and orchestration,
    and, while some things inside these files are important only to cloud-init, the
    ability to detect and interact with different cloud environments is something
    that other orchestration tools can use. Files are just a part of it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件都旨在帮助配置和编排，而且，虽然这些文件中的一些内容只对cloud-init重要，但检测和与不同的云环境进行交互的能力是其他编排工具可以使用的。文件只是其中的一部分。
- en: Another big part of this scheme is the command-line utility called `cloud-init`.
    To get information from it, we first need to log in to the machine that we created.
    We are going to show the differences between machines that were created by the
    same file, and at the same time demonstrate similarities and differences between
    distributions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方案的另一个重要部分是名为`cloud-init`的命令行实用程序。要从中获取信息，我们首先需要登录到我们创建的机器上。我们将展示由相同文件创建的机器之间的差异，并同时展示不同发行版之间的相似之处和不同之处。
- en: 'Before we start talking about this, be aware that cloud-init, as with all Linux
    software, comes in different versions. CentOS 7 images use an old version, 0.7.9:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论之前，请注意，与所有Linux软件一样，cloud-init有不同的版本。CentOS 7镜像使用的是一个旧版本，0.7.9：
- en: '![Figure 9.25 – CentOS cloud-init version – quite old'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.25 - CentOS上的cloud-init版本 - 相当旧'
- en: '](img/B14834_09_25.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_25.jpg)'
- en: Figure 9.25 – CentOS cloud-init version – quite old
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25 - CentOS cloud-init版本 - 相当旧
- en: 'Ubuntu comes with a much fresher version, 19.3:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu带有一个更新的版本，19.3：
- en: '![Figure 9.26 – Ubuntu cloud-init version – up to date'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.26 - Ubuntu上的cloud-init版本 - 最新'
- en: '](img/B14834_09_26.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_26.jpg)'
- en: Figure 9.26 – Ubuntu cloud-init version – up to date
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.26 - Ubuntu上的cloud-init版本 - 最新
- en: 'Before you freak out, this is not as bad as it seems. Cloud-init decided to
    switch its versioning system a couple of years ago, so after 0.7.9 came 17.1\.
    There were many changes and most of them are directly connected to the cloud-init
    command and configuration files. This means that the deployment will work, but
    a lot of things after we deploy will not. Probably the most visible difference
    is when we run `cloud-init --help`. For Ubuntu, this is what it looks like:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在你惊慌之前，情况并不像看起来那么糟。Cloud-init在几年前决定切换了其版本系统，因此在0.7.9之后是17.1。发生了许多变化，其中大部分直接与cloud-init命令和配置文件相关。这意味着部署将会成功，但我们部署后会有很多问题。可能最明显的区别是当我们运行`cloud-init
    --help`时。对于Ubuntu来说，它看起来是这样的：
- en: '![Figure 2.27 – Cloud-init features on Ubuntu'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.27 - Ubuntu上的Cloud-init功能'
- en: '](img/B14834_09_27.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_27.jpg)'
- en: Figure 2.27 – Cloud-init features on Ubuntu
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.27 - Ubuntu上的Cloud-init功能
- en: 'Realistically, a lot of things are missing for CentOS, some of them completely:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，CentOS缺少了很多东西，其中一些完全缺失：
- en: '![ Figure 9.28 – Cloud-init features on CentOS'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.28 - CentOS上的Cloud-init功能'
- en: '](img/B14834_09_28.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_28.jpg)'
- en: Figure 9.28 – Cloud-init features on CentOS
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.28 - CentOS上的Cloud-init功能
- en: 'Since our example has a total of three running instances – one Ubuntu and two
    CentOS virtual machines – let''s try to manually upgrade to the latest stable
    version of cloud-init available on CentOS. We can use our regular `yum update`
    command to achieve that, and the result will be as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的示例共有三个运行实例 - 一个Ubuntu和两个CentOS虚拟机 - 让我们尝试手动升级到CentOS上可用的最新稳定版本的cloud-init。我们可以使用常规的`yum
    update`命令来实现，结果如下：
- en: '![ Figure 9.29 – After a bit of yum update, an up-to-date list of cloud-init
    features'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.29 - 经过一段时间的yum update后，cloud-init功能的最新列表'
- en: '](img/B14834_09_29.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_29.jpg)'
- en: Figure 9.29 – After a bit of yum update, an up-to-date list of cloud-init features
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.29 - 经过一段yum更新后，cloud-init功能的最新列表
- en: As we can see, this will make things a lot easier to work with.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这将使事情变得更加容易。
- en: We are not going to go into too much detail about the cloud-init CLI tool, since
    there is simply too much information available for a book like this, and as we
    can see, new features are being added quickly. You can freely check additional
    options by browsing at [https://cloudinit.readthedocs.io/en/latest/topics/cli.html](https://cloudinit.readthedocs.io/en/latest/topics/cli.html).
    In fact, they are being added so quickly that there is a `devel` option that holds
    new features while they are in active development. Once they are finished, they
    become commands of their own.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会过多地详细介绍cloud-init CLI工具，因为像这样的书籍中有太多的信息可用，而且正如我们所看到的，新功能正在迅速添加。你可以通过浏览[https://cloudinit.readthedocs.io/en/latest/topics/cli.html](https://cloudinit.readthedocs.io/en/latest/topics/cli.html)自由地查看额外的选项。事实上，它们添加得非常快，以至于有一个`devel`选项，其中包含了正在积极开发中的新功能。一旦完成，它们就会成为独立的命令。
- en: 'There are two commands that you need to know about, both of which give an enormous
    amount of information about the boot process and the state of the booted system.
    The first one is `cloud-init analyze`. It has two extremely useful subcommands:
    `blame` and `show`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个命令你需要了解，它们都提供了关于引导过程和引导系统状态的大量信息。第一个是`cloud-init analyze`。它有两个非常有用的子命令：`blame`和`show`。
- en: 'The aptly named `blame` is actually a tool that returns how much time was spent
    on things that happened during different procedures cloud-init did during boot.
    For example, we can see that configuring `grub` and working with the filesystem
    was the slowest operation on Ubuntu:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 恰如其名的`blame`实际上是一个工具，返回了在引导过程中cloud-init执行不同过程时花费了多少时间。例如，我们可以看到在Ubuntu上配置`grub`和处理文件系统是最慢的操作：
- en: '![ Figure 9.30 – Checking time consumption for cloud-init procedures'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.30 - 检查cloud-init过程的时间消耗'
- en: '](img/B14834_09_30.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_30.jpg)'
- en: Figure 9.30 – Checking time consumption for cloud-init procedures
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.30 - 检查cloud-init过程的时间消耗
- en: 'The third virtual machine that we deployed uses CentOS image and we added `httpd`
    to it. By extension, it was by far the slowest thing that happened during the
    cloud-init process:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们部署的第三个虚拟机使用了CentOS镜像，并添加了`httpd`。从某种程度上来说，这是cloud-init过程中发生的最慢的事情：
- en: '![ Figure 9.31 – Checking time consumption – it took quite a bit of time for'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.31 - 检查时间消耗 - cloud-init部署必要的httpd包花费了相当长的时间'
- en: cloud-init to deploy the necessary httpd packages
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用cloud-init部署必要的httpd包
- en: '](img/B14834_09_31.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_31.jpg)'
- en: Figure 9.31 – Checking time consumption – it took quite a bit of time for cloud-init
    to deploy the necessary httpd packages
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.31 - 检查时间消耗 - cloud-init部署必要的httpd包花费了相当长的时间
- en: A tool like this makes it easier to optimize deployments. In our particular
    case, almost none of this makes sense, since we deployed simple machines with
    almost no changes to the default configuration, but being able to understand why
    the deployment is slow is a useful, if not essential, thing.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的工具使得优化部署变得更加容易。在我们的特定情况下，几乎没有意义，因为我们部署了几乎没有更改默认配置的简单机器，但能够理解部署为什么慢是一件有用的，如果不是必不可少的事情。
- en: 'Another useful thing is being able to see how much time it took to actually
    boot the virtual machine:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的功能是能够看到实际引导虚拟机所花费的时间：
- en: '![ Figure 9.32 – Checking the boot time'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.32 - 检查引导时间'
- en: '](img/B14834_09_32.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_32.jpg)'
- en: Figure 9.32 – Checking the boot time
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.32 - 检查引导时间
- en: 'We are going to end this part with a query – `cloud-init query` enables you
    to request information from the service, and get it in a useable structured format
    that you can then parse:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一个查询结束这一部分 - `cloud-init query`使你能够从服务中请求信息，并以可用的结构化格式获取它，然后进行解析：
- en: '![Figure 9.33 – Querying cloud-init for information'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.33 - 查询cloud-init信息'
- en: '](img/B14834_09_33.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14834_09_33.jpg)'
- en: Figure 9.33 – Querying cloud-init for information
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.33 - 查询cloud-init信息
- en: After working with it for even a few hours, cloud-init becomes one of those
    indispensable tools for a system administrator. Of course, its very essence means
    it will be much more suited to those of us who have to work in the cloud environment,
    because the thing it does best is the quick and painless deployment of machines
    from scripts. But even if you are not working with cloud technologies, the ability
    to quickly create instances that you can use for testing, and then to remove them
    without any pain, is something that every administrator needs.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用了几个小时后，cloud-init成为系统管理员不可或缺的工具之一。当然，它的本质意味着它更适合于我们这些必须在云环境中工作的人，因为它最擅长的是从脚本快速无痛地部署机器。但即使你不是在使用云技术，快速创建实例进行测试，然后无痛地删除它们的能力，是每个管理员都需要的。
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered cloud-init, its architecture, and the benefits in
    larger deployment scenarios, where configuration consistency and agility are of
    utmost importance. Pair that with the paradigm change in which we don't do everything
    manually – we have a tool that does it for us – and it's an excellent addition
    to our deployment processes. Make sure that you try to use it as it will make
    your life a lot easier, while preparing you for using cloud virtual machines,
    where cloud-init is extensively used.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了cloud-init，它的架构以及在更大的部署场景中的好处，其中配置一致性和灵活性至关重要。再加上我们不再手动完成所有事情的范式变化
    - 我们有一个工具来为我们完成 - 这是我们部署流程的一个很好的补充。确保你尝试使用它，因为它将使你的生活变得更加轻松，同时为你使用云虚拟机做好准备，而在那里，cloud-init被广泛使用。
- en: In the next chapter, we're going to learn how to expand this usage model to
    Windows virtual machines by using cloudbase-init.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何将这种用法模型扩展到Windows虚拟机，使用cloudbase-init。
- en: Questions
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Recreate our setup using CentOS 7 and Ubuntu base cloud-init images.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用CentOS 7和Ubuntu基础cloud-init镜像重新创建我们的设置。
- en: Create one Ubuntu and two CentOS instances using the same base image.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的基础镜像创建一个Ubuntu和两个CentOS实例。
- en: Add a fourth virtual machine using Ubuntu as a base image.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Ubuntu作为基础镜像添加第四个虚拟机。
- en: Try using some other distribution as a base image without changing any of the
    configuration files. Give FreeBSD a try.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用其他发行版作为基础镜像，而不更改任何配置文件。试试FreeBSD。
- en: Instead of using SSH keys, use predefined passwords. Is this more or less secure?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要使用SSH密钥，使用预定义密码。这样更安全还是更不安全？
- en: Create a script that will create 10 identical instances of a machine using cloud-init
    and a base image.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个脚本，使用cloud-init和一个基础镜像创建10个相同的机器实例。
- en: Can you find any reason why it would be more beneficial to use a distribution-native
    way of installing machines instead of using cloud-init?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能找到任何理由，为什么使用分发本地的安装方式而不是使用cloud-init会更有利吗？
- en: Further reading
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Please refer to the following links for more information regarding what was
    covered in this chapter:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下链接，了解本章涵盖的更多信息：
- en: 'Cloud-init documentation hub: [https://cloudinit.readthedocs.io/en/latest/](https://cloudinit.readthedocs.io/en/latest/)'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cloud-init文档中心：[https://cloudinit.readthedocs.io/en/latest/](https://cloudinit.readthedocs.io/en/latest/)
- en: 'Project home page for cloud-init: [https://cloud-init.io/](https://cloud-init.io/)'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cloud-init项目主页：[https://cloud-init.io/](https://cloud-init.io/)
- en: 'Source code: [https://code.launchpad.net/cloud-init](https://code.launchpad.net/cloud-init)'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码：[https://code.launchpad.net/cloud-init](https://code.launchpad.net/cloud-init)
- en: 'Particularly good examples of config files: [https://cloudinit.readthedocs.io/en/latest/topics/examples.html](https://cloudinit.readthedocs.io/en/latest/topics/examples.html)'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件的特别好的例子：[https://cloudinit.readthedocs.io/en/latest/topics/examples.html](https://cloudinit.readthedocs.io/en/latest/topics/examples.html)
