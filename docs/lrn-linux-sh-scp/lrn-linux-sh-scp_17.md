# 第十七章：速查表中的技巧和技巧

在这最后一章中，我们收集了一些提示和技巧，以帮助您在脚本编写的旅程中。首先，我们将涉及一些重要但在早期章节中没有直接提到的主题。然后，我们将向您展示一些命令行的实用快捷方式，这应该有助于您在使用终端时提高速度。最后，我们将以一张我们在本书中讨论过的最重要的交互式命令的速查表结束。

本章将介绍以下命令：`history`和`clear`。

本章将涵盖以下主题：

+   一般的提示和技巧

+   命令行快捷方式

+   交互式命令速查表

# 技术要求

由于本章主要是关于提示，所以没有像我们在早期章节中看到的脚本。要真正了解这些技巧的感觉，您应该自己尝试一下。作为最后的告别，您的 Ubuntu 虚拟机可以在这最后一次为您提供帮助！

# 一般的提示和技巧

在本章的第一部分中，我们将描述一些我们无法在书的其他部分中恰当放置的事物。除了第一个主题*数组*之外，`history`和`alias`在脚本编写的上下文中并不真正使用，因此我们选择在这里介绍它们。但首先是数组！

# 数组

如果您来自开发背景或曾涉足编程，您可能已经遇到过*数组*这个术语。如果我们需要用一句话来解释数组，它会是这样的：数组允许我们存储*相同类型的数据*的*集合*。为了让这个概念不那么抽象，我们将向您展示如何在 Bash 中创建一个*字符串数组*：

```
reader@ubuntu:~$ array=("This" "is" "an" "array")
reader@ubuntu:~$ echo ${array[0]}
This
reader@ubuntu:~$ echo ${array[1]}
is
reader@ubuntu:~$ echo ${array[2]}
an
reader@ubuntu:~$ echo ${array[3]}
array
```

在这个字符串数组中，我们放置了四个元素：

+   这

+   是

+   一个

+   数组

如果我们想要打印数组中第一个位置的字符串，我们需要使用`echo ${array[0]}`语法来指定我们想要的*零位置*。请记住，正如在 IT 中常见的那样，列表中的第一项通常在 0 位置找到。现在，看看如果我们尝试获取第四个位置，因此第五个值（不存在）会发生什么：

```
reader@ubuntu:~$ echo ${array[4]}
 # <- Nothing is printed here.
reader@ubuntu:~$ echo $?
0
reader@ubuntu:~$ echo ${array[*]}
This is an array
```

奇怪的是，即使我们要求获取数组中不存在的位置的值，Bash 也不认为这是一个错误。如果在某些编程语言中（如 Java）中执行相同操作，你会看到类似`**ArrayIndexOutOfBoundsException**`的错误。如你所见，在`0`的退出状态之后，如果我们想要打印*数组中的所有值*，我们使用星号（作为通配符）。

在我们的脚本示例中，为了使其更简单一些，当我们需要创建一个列表时，我们使用了*空格分隔的字符串*（参考脚本`**for-simple.sh**`，来自第十一章，*条件测试和脚本循环*）。根据我们的经验，对于大多数情况来说，这通常更容易使用并且足够强大。然而，如果对于您的脚本挑战来说似乎不是这种情况，请记住 Bash 中存在数组这样的东西，也许这对您有用。

# 历史命令

Bash 中一个非常强大和酷的命令是`history`。简而言之，默认情况下，Bash *会存储您输入的所有命令的历史记录*。这些保存在一定的阈值内，对于我们的 Ubuntu 18.04 安装来说，内存中保存了 1,000 个命令，磁盘上保存了 2,000 个命令。每次您干净地退出/注销终端时，Bash 都会将内存中的命令历史记录写入磁盘，同时考虑这两个限制。

在我们深入之前，让我们来看看`**reader**`用户的个人历史记录：

```
reader@ubuntu:~$ history
 1013  date
 1014  at 11:49 << wall "Hi"
 1015  at 11:49 <<< wall "Hi"
 1016  echo 'wall "Hi"' | at 11:49
<SNIPPED>
 1998  array=("This" "is" "an" "array")
 1999  echo ${array[0]}
 2000  echo ${array[1]}
 2001  echo ${array[2]}
 2002  echo ${array[3]}
 2003  echo ${array[4]}
 2004  echo ${array[*]}
```

尽管我们的历史非常有趣，但在这里完全打印出来并不那么有趣。通常，如果在实践中使用这个命令，它也很容易变成信息的过载。我们建议您以以下方式使用`history`命令：

+   `history | less`

+   `history | grep sed`

如果将其传输到`less`，您将得到一个漂亮的分页器，可以轻松滚动并使用搜索功能。当您使用`**q**`退出时，您将回到整洁的终端。如果您正在寻找特定命令（例如`sed`），您还可以通过`grep`命令过滤`history`的输出。如果这仍然太粗糙，考虑在`grep`后面添加`| less`，再次使用分页器。

历史记录的配置可以在一些环境变量中找到，这些环境变量通常在您的`**~/.bashrc**`文件中设置：

```
reader@ubuntu:~$ cat .bashrc
<SNIPPED>
# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=1000
HISTFILESIZE=2000
<SNIPPED>
```

在这里，您可以看到我们已经宣布的两个默认值（如果需要，可以进行编辑！）。对于其他命令，`man bash`会告诉您以下内容：

+   HISTCONTROL

+   HISTFILE

+   HISTTIMEFORMAT

一定要快速阅读一下。不要低估`history`命令的便利性；您肯定会*几乎*记得以前如何使用命令，如果您记得足够多，可以使用`history`找出您做了什么，以便再次执行。

# 创建您自己的别名

Bash 允许您为命令创建自己的别名。我们已经在第十四章 *调度和日志*中介绍过这一点，但对于日常任务来说，值得进一步探索一下。语法非常简单：

```
alias name=value
```

在这个语法中，`alias`是命令，`name`是您在终端上调用`alias`时的名称，`value`是您调用`alias`时实际调用的内容。对于交互式工作，这可能看起来像下面这样：

```
reader@ubuntu:~$ alias message='echo "Hello world!"'
reader@ubuntu:~$ message
Hello world!
```

我们创建了别名`message`，当调用时实际上执行`echo "Hello world!"`。对于一些经验丰富的人来说，您无疑已经使用了"command" `ll`一段时间了。您可能（或可能不）记得，这是一个常见的默认`alias`。我们可以使用`-p`标志打印当前设置的别名：

```
reader@ubuntu:~$ alias -p
<SNIPPED>
alias grep='grep --color=auto'
alias l='ls -CF'
alias la='ls -A'
alias ll='ls -alF'
alias ls='ls --color=auto'
alias message='echo "Hello world!"'
```

如您所见，默认情况下我们设置了一些别名，我们刚刚创建的别名也在其中。更有趣的是，我们可以使用`alias`来*覆盖一个命令*，比如上面的`ls`。在本书的示例中，我们使用`ls`的所有时间，实际上都在执行`ls --color=auto`！`grep`也是如此。`ll`别名快速允许我们使用`ls`的常见、几乎必要的标志。但是，您应该意识到这些别名是特定于发行版的。例如，看看我 Arch Linux 主机上的`ll`别名：

```
[tammert@caladan ~]$ alias -p
alias ll='ls -lh'
<SNIPPED>
```

这与我们的 Ubuntu 机器不同。至少，这引出了一个问题：这些默认别名是在哪里设置的？如果您记得我们在第十四章 *调度和日志*中关于`**/etc/profile**`、`**/etc/bash.bashrc**`、`**~/.profile**`和`**~/.bashrc**`的解释，我们知道这些文件是最有可能的候选者。根据经验，您可以期望大多数别名在`**~/.bashrc**`文件中：

```
reader@ubuntu:~$ cat .bashrc
<SNIPPED>
# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
<SNIPPED>
```

如果您经常使用某些命令或者想要默认包含某些标志，可以编辑您的`**~/.bashrc**`文件，并添加尽可能多的`alias`命令。`.bashrc`文件中的任何命令都会在您登录时运行。如果要使别名在整个系统范围内可用，最好将`alias`命令包含在`**/etc/profile**`或`**/etc/bash.bashrc**`文件中。否则，您将不得不编辑所有用户（当前和未来）的个人`.bashrc`文件（这是低效的，因此您甚至不应该考虑这一点）。

# 命令行快捷方式

除了本章第一部分中命令的便利之外，还有另一种节省时间的方法，这不一定需要在 shell 脚本的上下文中讨论，但它仍然是一个很大的优势，我们觉得如果不与您分享，会感到很遗憾：命令行快捷方式。

# 感叹号的乐趣

感叹号通常用于强调文本，但在 Bash 下它们实际上是一个`shell`关键字：

```
reader@ubuntu:~$ type -a !
! is a shell keyword
```

虽然术语“shell 关键字”并不能真正告诉我们它的作用，但感叹号可以实现多种功能。我们已经看到其中一个：如果我们想要否定一个`test`，我们可以在检查中使用感叹号。如果您想在终端上验证这一点，请尝试以下操作，使用`true`或`false`：

```
reader@ubuntu:~$ true
reader@ubuntu:~$ echo $?
0
reader@ubuntu:~$ ! true
reader@ubuntu:~$ echo $?
1
```

正如您所看到的，感叹号可以颠倒退出状态：true 变为 false，false 变为 true。感叹号的另一个很酷的功能是，双感叹号将在命令行中用完整的上一个命令替换，如下所示：

```
reader@ubuntu:~$ echo "Hello world!"
Hello world!
reader@ubuntu:~$ !!
echo "Hello world!"
Hello world!
```

为了确保您清楚地知道您正在重复什么，该命令将与命令的输出一起打印到 stdout。而且，我们还可以通过使用数字和冒号与感叹号相结合来选择要重复的命令的哪一部分。与往常一样，`0`保留给第一个参数，`1`保留给第二个参数，依此类推。这方面的一个很好的例子如下：

```
reader@ubuntu:/tmp$ touch file
reader@ubuntu:/tmp$ cp file new_file # cp=0, file=1, new_file=2
reader@ubuntu:/tmp$ ls -l !:1 # Substituted as file.
ls -l file
-rw-r--r-- 1 reader reader 0 Dec 22 19:11 file
reader@ubuntu:/tmp$ echo !:1
echo -l
-l
```

前面的例子显示，我们使用`**!:1**`来替换上一个命令的第二个单词。请注意，如果我们对`ls -l file`命令重复此操作，第二个单词实际上是`ls`命令的`-l`标志，因此不要假设只有完整的命令被解析；这是一个简单的空格分隔的索引。

在我们看来，感叹号的一个杀手功能是`!$`构造。这是相同类型的替换，正如您可能从`vim`中`**$**`的工作方式猜到的那样，它会替换上一个命令的最后一个单词。虽然这可能看起来不是那么重要，但看看上一个命令的最后一个单词有多少次是可以重用的：

```
reader@ubuntu:/tmp$ mkdir newdir
reader@ubuntu:/tmp$ cd !$
cd newdir reader@ubuntu:/tmp/newdir
```

或者，当复制要编辑的文件时：

```
reader@ubuntu:/tmp$ cp file new_file 
reader@ubuntu:/tmp$ vim !$
vim new_file
```

一旦您开始在实践中使用它，您会发现这个技巧几乎可以适用于许多命令，它几乎立即就会为您节省时间。在这些示例中，名称很短，但是如果我们谈论长路径名，我们要么必须将手从键盘上拿开，用鼠标复制/粘贴，要么重新输入所有内容。当一个简单的`**!$**`就能解决问题时，您为什么要这样做呢？

同样，这可以迅速成为一个救命稻草，有一个极好的例子可以说明何时使用`**!!**`。看看以下每个人都遇到过或迟早会遇到的情况：

```
reader@ubuntu:~$ cat /etc/shadow
cat: /etc/shadow: Permission denied
reader@ubuntu:~$ sudo !!
sudo cat /etc/shadow
[sudo] password for reader: 
root:*:17647:0:99999:7:::
daemon:*:17647:0:99999:7:::
bin:*:17647:0:99999:7:::
<SNIPPED>
```

当您忘记在命令前添加`sudo`（因为它是特权命令或操作特权文件）时，您可以选择：

+   再次输入整个命令

+   使用鼠标复制并粘贴命令

+   使用上箭头，然后按 Home 键，输入`sudo`

+   或者只需键入`sudo !!`

很明显哪个是最短和最容易的，因此我们更倾向于使用它。要意识到，这种简单性也意味着责任：如果您尝试删除不应删除的文件，并且在没有充分考虑的情况下迅速使用`sudo !!`，您的系统可能会立即消失。警告仍然存在：在以`**root**`或`sudo`身份交互时，运行命令之前一定要三思。

# 从历史记录中运行命令

我们发现与感叹号相关的最值得注意的最后一件事是与历史记录的交互。就像您在几页前学到的那样，历史记录保存了您的命令。使用感叹号，您可以快速从历史记录中运行命令：可以通过提供命令的编号（例如`!100`）或输入命令的一部分（例如：`!ls`）来运行。根据我们的经验，这些功能并没有像我们即将解释的*反向搜索*那样经常使用，但了解这个功能仍然是很好的。

让我们看看这在实践中是什么样子：

```
reader@ubuntu:~$ history | grep 100
 1100  date
 2033  history | grep 100
reader@ubuntu:~$ !1100
date
Sat Dec 22 19:27:55 UTC 2018
reader@ubuntu:~$ !ls
ls -al
total 152
drwxr-xr-x  7 reader reader  4096 Dec 22 19:20 .
drwxr-xr-x  3 root   root    4096 Nov 10 14:35 ..
-rw-rw-r--  1 reader reader  1530 Nov 17 20:47 bash-function-library.sh
<SNIPPED>
```

通过提供数字，`!1100`再次运行了`date`命令。你应该意识到，一旦历史记录达到最大值，它将会改变。今天等于`!1100`的命令可能下周会完全不同。实际上，这被认为是一种冒险的举动，通常最好避免，因为你不会得到确认：你看到正在执行的内容，当它正在运行时（或者可能是在你看到你运行的内容时已经完成）。只有在检查历史记录后，你才能确定，而在这种情况下，你并没有节省任何时间，只是使用了额外的时间。

然而，有趣的是，基于命令本身重复一个命令，比如`!ls`显示的。这仍然有些冒险，特别是如果与`rm`等破坏性命令结合使用，但如果你确定最后一个与感叹号查询匹配的命令是什么，你应该相对安全（特别是对于`cat`或`ls`等非破坏性命令）。再次，在你开始将这种做法融入到你的日常生活之前，一定要确保继续阅读，直到我们解释了反向搜索。在那时，我们期望/希望这些对你来说更有趣，然后你可以把这里的信息存档为*好知识*。

# 键盘快捷键

我们要讨论的下一个快捷方式类别是*键盘快捷键*。与之前的命令和 shell 关键字相比，这些只是修改命令行上的事物的键盘组合。我们要讨论的组合都是通过使用*CTRL*键作为修饰符来工作的：你按住*CTRL*键，然后按下另一个键，例如*t*。我们将像在本书的其余部分一样描述这个为*CTRL+t*。说到`**CTRL+t**`，这实际上是我们想要讨论的第一个快捷键！当你打错字时，你可以使用`CTRL+t`：

```
reader@ubuntu:~$ head /etc/passdw
# Last two letters are swapped, press CTRL+t to swap them:
reader@ubuntu:~$ head /etc/passwd
```

由于终端被修改，很难准确地表示这些页面。我们在行之间包含了一条注释，以显示我们做了什么以及我们做了什么改变。然而，在你的终端中，你只会看到一行。试一试吧。通过按下*CTRL+t*，你可以随意交换最后两个字符。请注意，它也考虑了空格：如果你已经按下了空格键，你将会交换空格和最后一个字母，就像这样：

```
reader@ubuntu:~$ sl 
# CTRL+t
reader@ubuntu:~$ s l
```

如果你开始使用这个快捷键，你很快就会意识到交换两个字母比你最初期望的要常见得多。与 Bash 中的大多数事物一样，这个功能之所以存在是因为人们使用它，所以如果这对你来说发生得太频繁，你不需要为自己感到难过！至少有了这个快捷键，你可以快速地减轻错误。

接下来是`**CTRL+l**`快捷键（小写的*L*），实际上是一个命令的快捷键：`clear`。clear 的功能几乎和命令的名字一样简单：`clear` - *清除终端屏幕*（来自`man clear`）。这实际上是一个我们在每个终端会话中广泛使用的快捷键（以及命令）。一旦你到达终端仿真器屏幕的*底部*，上面有很多混乱，你可能会注意到这不像你开始时的空终端那样好用（我们的个人意见，也许你也有同感）。如果你想清理这些，你可以使用*CTRL+l*快捷键，或者简单地输入`clear`命令。当你清除终端时，输出并没有消失：你可以随时向上滚动（通常通过鼠标滚轮或*SHIFT+page-up*）来查看被清除的内容。但至少你的光标在一个干净的屏幕顶部！

还有一个`exit`命令的快捷键，`**CTRL+d**`。这不仅适用于*退出 SSH 会话*，还适用于许多其他交互提示：一个很好的例子是`at`（实际上，你*需要*使用*CTRL+d*来退出`at`提示，因为`exit`将被解释为一个要运行的命令！）。正如你所知，`**CTRL+c**`发送一个取消到正在运行的命令（在 Linux 下有许多取消/终止的强度，技术上是一个 SIGINT），所以一定不要混淆*CTRL+d*和*CTRL+c*。

关于导航，有两个基于 CTRL 的快捷键通常比它们的替代方案更容易到达：`**CTRL+e**`和`**CTRL+a**`。`**CTRL+e**`将光标移动到行的末尾，类似于 END 键的功能。正如你所期望的，`**CTRL+a**`则相反：它作为 HOME 键的替代功能。特别是对于那些熟练使用触摸打字的人来说，这些快捷键比将右手移开主键行找到*END*/*HOME*键更快。

# 从终端复制和粘贴

在基于 GUI 的系统中，常见的事情是剪切和粘贴文本。你会选择文本，通常用鼠标，然后要么使用右键复制和粘贴，或者希望你已经找到了老式的`**CTRL+c**`和`**CTRL+v**`（对于 Windows，macOS 的 Command 键）。正如我们之前解释过并在两段前提醒过你的，Linux 下的*CTRL+c*绝对不是*复制*，而是*取消*。同样，*CTRL+v*也很可能不会粘贴文本。那么，在 Linux 下，我们如何复制和粘贴呢？

首先，如果你正在使用 SSH 和 GUI 桌面内的终端仿真器，你可以使用右键来完成这个操作（或者，如果你感觉非常高级，按下中键通常也默认为粘贴！）。你可以从互联网上的某个地方选择文本，例如，复制它，并用任一按钮粘贴到你的终端仿真器中。然而，我们总是努力优化我们的流程，一旦你需要抓住鼠标，你就会浪费宝贵的时间。对于你已经复制的文本，（对于大多数终端仿真器！）有一个快捷键可以粘贴：`**SHIFT+insert**`。只是让你知道，这个粘贴快捷键不仅限于 Linux 或大多数终端仿真器：它似乎是相当通用的，在 Windows 和带有 GUI 的 Linux 上也可以工作。就我们个人而言，我们几乎完全用*SHIFT+insert*替代了*CTRL+v*来满足我们的粘贴需求。

显然，如果我们可以以这种方式粘贴，那么也一定有一种类似的复制方式。这非常类似：复制可以用`**CTRL+insert**`来完成。同样，这不仅限于 Linux 或终端：在 Windows 上也可以很好地工作。对于我们这些在 Linux 和 Windows 上工作的人来说，用*CTRL+insert*和*SHIFT+insert*替换*CTRL+c*和*CTRL+v*确保我们无论在哪种环境下都能正确地复制和粘贴。就我们个人而言，我们在家里使用 Linux，但在工作中使用 Windows，这意味着我们的时间大约 50/50 地花在操作系统上：相信我们，总是能够正常工作的快捷键非常好！

现在，上面的方法仍然有点依赖于鼠标。大多数情况下（根据你的工作，可能超过 95%），这是成立的，但有时你可能根本没有鼠标（例如，当直接连接到数据中心的服务器的终端时）。幸运的是，Bash 中有三个快捷键可以让我们在命令行上直接剪切和粘贴：

+   `**CTRL+w**`：剪切光标前的单词

+   `**CTRL+u**`：剪切光标前的整行

+   `**CTRL+y**`：粘贴所有被剪切的内容（使用上面的两个命令，而不是一般的操作系统剪贴板！）

除了能够剪切和粘贴，*CTRL+w*也非常适合从命令行中删除一个完整的单词。看下面的例子：

```
reader@ubuntu:~$ sudo cat /etc/passwd # Wrong file, we meant /etc/shadow!
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
<SNIPPED>
# Up-arrow
reader@ubuntu:~$ sudo cat /etc/passwd
# CTRL+w
reader@ubuntu:~$ sudo cat # Ready to type /etc/shadow here.
```

经常发生的一件事是给命令提供一个不正确的最终参数。如果你想快速修改这个问题，只需简单地按一下*向上箭头*，然后按*CTRL+w*，就会将上一个命令减去最终参数的部分重新放回终端。现在，你只需要给它正确的参数再次运行。或者，你也可以：

+   重新输入整个命令

+   使用鼠标滚动、复制和粘贴

+   *向上箭头*后跟一些退格键

根据我们的经验，双击键总是比所有其他可能的解决方案更快。只有最后一个参数是单个字符时，使用*向上箭头*和*退格键*才会*同样快*，这有点牵强。

现在，在前面的例子中，我们实际上并不只是*删除*最终参数，我们实际上是*剪切*它。当你剪切一个参数时，它会给你重新*粘贴*的能力。正如所述，这是一个特定于 Bash 的剪贴板，它不与系统剪贴板绑定；虽然你可能认为粘贴总是用*SHIFT+insert*完成，但在这种情况下，我们使用*CTRL+y*来操作 Bash 特定的剪贴板。最好的例子是使用`**CTRL+u**`来剪切整行：

```
root@ubuntu:~# systemctl restart network-online.target # Did not press ENTER yet.
# Forgot to edit a file before restart, CTRL+u to cut the whole line.
root@ubuntu:~# vim /etc/sysctl.conf # Make the change.
# CTRL+y: paste the cut line again.
root@ubuntu:~# systemctl restart network-online.target # Now we press ENTER.
```

对我们来说，这是一个典型的情况，我们比自己提前了一步。我们已经输入了一个需要执行的命令，但在按下*ENTER*之前，我们意识到我们忘记了在我们当前的命令成功之前需要做一些事情。在这种情况下，我们使用`**CTRL+u**`来剪切整个命令，继续进行先决条件命令，当我们准备好时再次粘贴该行使用`**CTRL+y**`。再次强调，你可能认为这不会发生在你身上，但你可能会惊讶地发现你会经常遇到这种精确的模式。

# 反向搜索

就键盘快捷键而言，我们认为我们已经为最后留下了最好的。在我们迄今介绍的所有节省时间的方法中，这绝对是我们认为最酷的：*反向搜索*。

反向搜索允许你浏览历史记录，并在执行的命令中搜索字符串。你可以将其视为类似于`history | grep cat`，但更加交互和更快。要进入反向搜索提示，使用键`**CTRL+r**`：

```
reader@ubuntu:~$ # CTRL+r
(reverse-i-search)'': # Start typing now.
(reverse-i-search)'cat': cat /var/log/dpkg.log # Press CTRL+r again for next match.
(reverse-i-search)'cat': sudo cat /etc/shadow # When match is found, press ENTER to execute.
reader@ubuntu:~$ sudo cat /etc/shadow
root:*:17647:0:99999:7:::
daemon:*:17647:0:99999:7:::
bin:*:17647:0:99999:7:::
<SNIPPED>
```

请尝试一下。很难将这些交互式提示记录下来，所以我们希望上面的注释能很好地说明反向搜索的工作原理。你可以一直反向搜索到历史记录的开头。如果在那时，你再次按下*CTRL+r*，你会看到类似以下的内容：

```
(failed reverse-i-search)'cat': cat base-crontab.txt
```

这向你表明没有更多的匹配项供反向搜索查找。在这一点上，或者在你认为花费的时间太长之前，你可以随时按下*CTRL+c*来停止反向搜索。

与`!ls`语法相比，反向搜索不会从行的开头开始查找关键词：

```
reverse-i-search)'ls': cat grep-then-else.sh
```

这意味着它更强大（它只是匹配命令中的任何位置）并且更复杂（它不仅匹配命令）。然而，如果你对此很聪明，你只想要命令，你总是可以巧妙地使用空格来确保不会发生像上面的例子那样的情况：

```
(reverse-i-search)'ls ': ls -al /tmp/new # Note the whitespace after ls.
```

虽然我们很乐意更多地谈论反向搜索，但你真正学会它的唯一方法是开始使用它。放心，如果你熟练地使用它（并且知道何时停止搜索，直接输入你要找的命令），你一定会以你高效的终端工作给同行留下深刻印象！

# 交互式命令的速查表

我们将以一个简单的交互命令备忘单结束这本书。熟练掌握 Bash 是一个练习的问题。然而，多年来，我们发现自己偶然发现了使用命令的新方法，或者我们不知道的标志，这使我们的生活变得更加轻松。即使在写这本书的过程中，我们也遇到了以前不知道的东西，这些东西非常有帮助。在写命令和结构的过程中，您比在日常业务中使用它们时更仔细地查看手册页面和资源。

请充分利用这些备忘单，因为它们不仅包括基本的语法，还包括我们认为很重要的标志和提示（我们希望我们在职业生涯的早期就发现了它们）！

这些备忘单不包括诸如 find/locate、重定向、测试和循环之类的内容：这些内容在它们各自的章节中已经得到了充分的描述（希望如此）。

# 导航

这些命令用于导航。

# cd

| **描述** | 更改 shell 工作目录。 |
| --- | --- |
| **语法** | cd [dir] |
| **实际用途** |

+   `cd`：导航到主目录（如在 HOME 中指定）。

+   `cd -`：导航回上一个目录（保存在 OLDPWD 中）。

|

# ls

| **描述** | 列出目录内容。 |
| --- | --- |
| **语法** | ls [选项]... [文件]... |
| **实际用途** |

+   `ls -a`：不要忽略以点（.和..）开头的条目。

+   `ls -l`：使用长列表格式。

+   `ls -h`：与`-l`和/或`-s`一起，打印人类可读的大小（例如，1K 234M 2G）。

+   `ls -R`：递归列出子目录。

+   `ls -S`：按文件大小排序，从大到小。

+   `ls -t`：按修改时间排序，最新的排在前面。

+   `ls -ltu`：按访问时间排序并显示。

+   `ls -Z`：打印每个文件的安全上下文。

|

# pwd

| **描述** | 打印当前/工作目录的名称。 |
| --- | --- |
| **语法** | pwd [选项]... |

# 文件操作

这些命令用于文件操作。

# 猫

| **描述** | 连接文件并打印到标准输出。 |
| --- | --- |
| **语法** | cat [选项]... [文件]... |
| **实际用途** |

+   `猫`或`猫-`：没有文件，或者文件是-，读取标准输入。

+   `cat -n`：对所有输出行编号。

|

# less

| **描述** | 使用分页器逐屏查看文本。 |
| --- | --- |
| **语法** | less [选项]... [文件]... |
| **实际用途** |

+   `less -S`：截断长行。行不换行，但可以用左右箭头键看到。

+   `less -N`：显示行号。

|

# touch

| **描述** | 更改文件时间戳和/或创建空文件。 |
| --- | --- |
| **语法** | touch [选项]... 文件... |
| **实际用途** |

+   `touch <不存在的文件>`：创建一个空文件。

|

# mkdir

| **描述** | 创建目录。 |
| --- | --- |
| **语法** | mkdir [选项]... 目录... |
| **实际用途** |

+   `mkdir -m750 <dirname>`：创建具有指定八进制权限的目录。

+   `mkdir -Z`：将每个创建的目录的 SELinux 安全上下文设置为默认类型。

|

# cp

| **描述** | 复制文件和目录。 |
| --- | --- |
| **语法** | cp [选项]... 源... 目录 |
| **实际用途** |

+   `cp -a`：归档模式，保留所有权限、链接、属性等。

+   `cp -i`：覆盖前提示（覆盖以前的`-n`选项）。

+   `cp -r`和`cp -R`：递归复制目录。

+   `cp -u`：仅在源文件比目标文件新或目标文件丢失时复制。

|

# rm

| **描述** | 删除文件或目录。 |
| --- | --- |
| **语法** | rm [选项]... [文件]... |
| **实际用途** |

+   `rm -f`：忽略不存在的文件和参数，不要提示。

+   `rm -i`：每次删除前提示。

+   `rm -I`（大写 i）：在删除三个以上的文件或递归删除时提示一次；比-i 少侵入，同时仍然提供对大多数错误的保护。

+   `rm -r`和`rm -R`：递归删除目录及其内容。

|

# mv

| **描述** | 移动（重命名）文件。 |
| --- | --- |
| **语法** | mv [选项]... 源... 目录 |
| **实际用途** |

+   `mv -f`: 在覆盖之前不提示。

+   `mv -n`: 不覆盖现有文件。

+   `mv -u`: 仅在源文件新于目标文件或目标文件丢失时移动。

|

# ln

| **描述** | 在文件之间创建链接。默认为硬链接。 |
| --- | --- |
| **语法** | ln [OPTION]... [-T] TARGET LINK_NAME |
| **实际用途** |

+   `ln -s`: 创建符号链接而不是硬链接。

+   `ln -i`: 提示是否删除目标。

|

# head

| **描述** | 输出文件的第一部分。 |
| --- | --- |
| **语法** | head [OPTION]... [FILE]... |
| **实际用途** |

+   `head`: 将每个文件的前 10 行打印到标准输出。

+   `head -n20`或`head -20`: 打印前 NUM 行而不是前 10 行。

+   `head -c20`: 打印每个文件的前 NUM 个字节。

+   `head -q`: 永远不打印给出文件名的标题。

|

# tail

`tail`命令与`head`具有相同的选项，但是从文件末尾而不是开头看到。

| **描述** | 输出文件的最后部分。 |
| --- | --- |
| **语法** | tail [OPTION]... [FILE]... |

# 权限和所有权

这些命令用于权限和所有权操作。

# chmod

| **描述** | 更改文件模式位。可以指定为 rwx 或八进制模式。 |
| --- | --- |
| **语法** | chmod [OPTION]... OCTAL-MODE FILE... |
| **实际用途** |

+   `chmod -c`: 像 verbose，但仅在更改时报告。

+   `chmod -R`: 递归更改文件和目录。

+   `chmod --reference=RFILE`: 从参考文件复制模式。

|

# umask

| **描述** | 设置文件模式创建掩码。由于这是*掩码*，因此与正常的八进制模式相反。 |
| --- | --- |
| **语法** | umask [octal-mask] |

# chown

| **描述** | 更改文件所有者和组。仅在具有 root 权限时可执行。 |
| --- | --- |
| **语法** | chown [OPTION]... [OWNER][:[GROUP]] FILE... |
| **实际用途** |

+   `chown user: <file>`: 更改所有权为用户和他们的默认组。

+   `chown -c`: 像 verbose，但仅在更改时报告。

+   `chown --reference=RFILE`: 从参考文件复制所有权。

+   `chown -R`: 递归操作文件和目录。

|

# chgrp

| **描述** | 更改组所有权。 |
| --- | --- |
| **语法** | chgrp [OPTION]... GROUP FILE... |
| **实际用途** |

+   `chgrp -c`: 像 verbose，但仅在更改时报告。

+   `chgrp --reference=RFILE`: 从参考文件复制组所有权。

+   `chgrp -R`: 递归操作文件和目录。

|

# sudo

| **描述** | 以另一个用户的身份执行命令。 |
| --- | --- |
| **语法** | sudo [OPTION]... |
| **实际用途** |

+   `sudo -i`: 成为根用户。

+   `sudo -l`: 列出调用用户允许（和禁止）的命令。

+   `sudo -u <user> <command>`: 以指定的<user>身份运行<command>。

+   `sudo -u <user> -i`: 以指定的<user>登录。

|

# su

| **描述** | 更改用户 ID 或成为超级用户。 |
| --- | --- |
| **语法** | su [options] [username] |
| **实际用途** |

+   `sudo su -`: 切换到 root 用户。需要 sudo，可以选择使用自己的密码。

+   `su - <user>`: 切换到<user>。需要<user>的密码输入。

|

# useradd

| **描述** | 创建新用户或更新默认新用户信息。 |
| --- | --- |
| **语法** | useradd [options] LOGIN |
| **实际用途** |

+   `useradd -m`: 如果不存在，则创建用户的主目录。

+   `useradd -s <shell>`: 用户登录 shell 的名称。

+   `useradd -u <uid>`: 用户 ID 的数值。

+   `useradd -g <group>`: 用户初始登录组的组名或编号。

|

# groupadd

| **描述** | 创建新组。 |
| --- | --- |
| **语法** | groupadd [options] group |
| **实际用途** |

+   `groupadd -g <gid>`: 组 ID 的数值。

+   `groupadd -r`: 创建系统组。这些组的 GID（通常）低于用户。

|

# usermod

| **描述** | 修改用户帐户。 |
| --- | --- |
| **语法** | usermod [options] LOGIN |
| **实际用途** |

+   `usermod -g <group> <user>`: 将<user>的主要组更改为<group>。

+   `usermod -aG <group> <user>`：将<user>添加到<group>中。对于用户来说，这将是一个附加组。

+   `usermod -s <shell> <user>`：为<user>设置登录 shell。

+   `usermod -md <homedir> <user>`：将<user>的主目录移动到<homedir>。

|

# 摘要

我们以一般提示和技巧开始了这一最终章节。本章的这部分涉及数组、`history`命令以及使用`alias`为您喜欢的命令及其标志设置别名。

我们继续讲解键盘快捷键。我们首先讨论了感叹号的用途以及在 Bash 中它们的多功能性：它用于否定退出代码，替换先前命令的部分，甚至通过匹配行号或行内容从历史记录中运行命令。之后，我们展示了一些有趣的 Bash 键盘快捷键，可以帮助我们节省一些常见操作和使用模式的时间（例如拼写错误和忘记的中间命令）。我们将最好的键盘快捷键留到最后：反向搜索。这些快捷键允许您交互式地浏览您的个人历史记录，找到再次执行的正确命令。

我们在本章和本书的结尾处提供了一个命令速查表，其中包含了我们在本书中介绍的大部分命令的基本语法，以及我们喜欢的标志和命令的组合。

本章介绍了以下命令：`history`和`clear`。

# 最后的话

如果您已经成功阅读到这里：感谢您阅读我们的书。我们希望您享受阅读它的过程，就像我们创作它一样。继续脚本编写和学习：熟能生巧！
