- en: User-Kernel Communication Pathways
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 用户-内核通信路径
- en: 'Consider this scenario: you''ve successfully developed a device driver for,
    say, a pressure sensor device (perhaps by using the kernel''s I2C APIs to fetch
    the pressure from the chip via the I2C protocol). So, you have the current pressure
    value in a variable within the driver, which of course implies that it''s within
    kernel memory space. The issue at hand is, how exactly do you now have a *user
    space application retrieve this value?* Well, as we learned in the previous chapter,
    you can always include a `.read` method in the driver''s *fops *structure. When
    the user space app issues a `read(2)` system call, control will be diverted (via
    the **virtual file system** (**VFS**)) to your driver''s *read method.* In there,
    you perform `copy_to_user()` (or equivalent), resulting in the user mode app receiving
    the value. However, but there are other, sometimes superior, ways to do this.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种情况：你已经成功地为一个压力传感器设备开发了一个设备驱动程序（可能是通过使用内核的I2C API来通过I2C协议从芯片获取压力）。因此，你在驱动程序中有了当前的压力值，这当然意味着它在内核内存空间中。问题是，你现在如何让一个用户空间应用程序检索这个值呢？嗯，正如我们在上一章中学到的，你可以在驱动程序的fops结构中始终包含一个.read方法。当用户空间应用程序发出read(2)系统调用时，控制将通过虚拟文件系统（VFS）转移到你的驱动程序的read方法。在那里，你执行copy_to_user()（或等效操作），使用户模式应用程序接收到该值。然而，还有其他一些更好的方法来做到这一点。
- en: 'In this chapter, you''ll understand the various communication interfaces or
    pathways that are available – as a means to communicate or interface between user
    and kernel address spaces. This is an important aspect of writing driver code,
    for without this knowledge, how will you be able to achieve a key thing – efficiently
    transfer information between a kernel-space component (often, this is a device
    driver, but it could be anything, really) and a user space process or thread?
    Not only that, some of the techniques that we shall learn about are often used
    for debugging (and/or diagnostics) purposesas well. In this chapter, we will cover
    several techniques to effect communication between the kernel and user (virtual)
    address spaces: communication via the traditional proc filesystem, *procfs*, the
    better way for drivers via the sys filesystem, *sysfs*, via a debug filesystem,
    *debugfs*, via *netlink sockets*, and via the `ioctl(2)` system call.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解可用的各种通信接口或路径，作为在用户和内核地址空间之间进行通信或接口的手段。这是编写驱动程序代码的一个重要方面，因为如果没有这些知识，你将如何能够实现一个关键的事情——在内核空间组件（通常是设备驱动程序，但实际上可以是任何东西）和用户空间进程或线程之间高效地传输信息？不仅如此，我们将学习的一些技术通常也用于调试（和/或诊断）目的。在本章中，我们将涵盖几种技术来实现内核和用户（虚拟）地址空间之间的通信：通过传统的proc文件系统procfs进行通信，通过sys文件系统sysfs进行驱动程序的更好方式，通过调试文件系统debugfs进行通信，通过netlink套接字进行通信，以及通过ioctl(2)系统调用进行通信。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Approaches to communicating/interfacing a kernel driver with a user space C
    app
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与用户空间C应用程序通信/接口的内核驱动程序的方法
- en: Interfacing via the proc filesystem (procfs)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过proc文件系统（procfs）进行接口
- en: Interfacing via the sys filesystem (sysfs)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过sys文件系统sysfs进行接口
- en: Interfacing via the debug filesystem (debugfs)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调试文件系统debugfs进行接口
- en: Interfacing via netlink sockets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过netlink套接字进行接口
- en: Interfacing via the ioctl system call
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过ioctl系统调用进行接口
- en: Comparing the interfacing methods – a table
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较接口方法-表格
- en: Let's get started!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: I assume you have gone through the *Preface*, the relevant section being *To
    get the most out of this book,* and have appropriately prepared a guest **virtual
    machine** (**VM**) running Ubuntu 18.04 LTS (or a later stable release) and installed
    all the required packages. If not, I recommend you do this first.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你已经阅读了前言，相关部分是“充分利用本书”，并已经适当地准备了一个运行Ubuntu 18.04 LTS（或更高稳定版本）的虚拟机，并安装了所有必需的软件包。如果没有，我建议你首先这样做。
- en: To get the maximum out of this book, I strongly recommend you first set up the
    workspace environment, including cloning this book's GitHub repository ([https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/ch2))
    for the relevant code, and work on it in a hands-on fashion.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本书，我强烈建议你首先设置工作环境，包括克隆本书的GitHub存储库（[https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/ch2)）以获取相关代码，并以实际操作的方式进行工作。
- en: Approaches to communicating/interfacing a kernel driver with a user space C
    app
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与用户空间C应用程序通信/接口的内核驱动程序的方法
- en: As we mentioned in the introduction, in this chapter, we wish to learn how to
    efficiently transfer information between a kernel-space component (often, this
    is a device driver, but it could be anything, really), and a user space process
    or thread. To begin, let's simply enumerate various techniques available to the
    kernel or driver author to communicate or interface with a user space C application.
    Well, the user space component could be a C app, a shell script (both of which
    we typically show in this book), or even other apps such as C++/Java apps, Python/Perl
    scripts, and more.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在介绍中提到的，在本章中，我们希望学习如何在内核空间组件（通常是设备驱动程序，但实际上可以是任何东西）和用户空间进程或线程之间高效地传输信息。首先，让我们简单列举内核或驱动程序作者可用的各种技术，用于与用户空间C应用程序进行通信或接口。嗯，用户空间组件可以是C应用程序，shell脚本（这两者我们通常在本书中展示），甚至其他应用程序，如C++/Java应用程序，Python/Perl脚本等。
- en: 'As we saw in the companion guide, *Linux Kernel Programming*, in *Chapter 4, Writing
    Your First Kernel Module – LKMs Part 1,* in the *Library and System Call APIs* subsection,
    the essential interface between user space applications and the kernel that includes
    the device drivers are the system call APIs*.* Now, in the previous chapter, you
    learned the basics of writing a character device driver for Linux. Within that,
    you also learned how to transfer data between user and kernel address spaces by
    having a user mode application open the device file and issue `read(2)` and `write(2)`
    system calls. This resulted in the driver''s read/write method being invoked by
    the VFS and your driver performing the data transfer via the `copy_{from|to}_user()`
    APIs. So, the question here is: if we have already covered that, then what else
    is there to learn about in this regard?'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在伴随指南*Linux内核编程*的*第4章*，*编写您的第一个内核模块 - LKMs第1部分*中的*库和系统调用API*子章节中所看到的，用户空间应用程序和内核之间的基本接口包括设备驱动程序的系统调用API*。现在，在上一章中，您学习了为Linux编写字符设备驱动程序的基础知识。在其中，您还学习了如何通过让用户模式应用程序打开设备文件并发出`read(2)`和`write(2)`系统调用来在用户和内核地址空间之间传输数据。这导致VFS调用驱动程序的读/写方法，并且您的驱动程序通过`copy_{from|to}_user()`API执行数据传输。因此，这里的问题是：如果我们已经涵盖了这一点，那么在这方面还有什么其他要学习的呢？
- en: 'Ah, quite a bit! The reality is that there are several other techniques of
    interfacing between a user mode app and the kernel. Certainly, they all very much
    depend upon using system calls; after all, there is no other (synchronous, programmatic)
    way to enter the kernel from the user space! Nevertheless, the techniques differ.
    The aim of this chapter is to show you various communication interfaces that are
    available, as of course, depending on the project, one might be more suitable
    than others to use. Let''s look at the various techniques that will be used in
    this chapter to interface between the user and kernel address spaces:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，还有很多！事实上，还有其他几种用户模式应用程序和内核之间的接口技术。当然，它们都非常依赖于使用系统调用；毕竟，没有其他（同步的、程序化的）方式从用户空间进入内核！然而，这些技术是不同的。本章的目的是向您展示各种可用的通信接口，因为当然，根据项目的不同，可能有一种更适合使用。让我们来看看本章将用于用户和内核地址空间之间的接口的各种技术：
- en: Via the traditional procfs interface
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过传统的procfs接口
- en: Via sysfs
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过sysfs
- en: Via debugfs
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过debugfs
- en: Via netlink sockets
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过netlink套接字进行接口
- en: Via the `ioctl(2)` system call
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`ioctl(2)`系统调用
- en: Throughout this chapter, we will discuss these interfacing techniques in detail
    by providing driver code examples. In addition, we will also briefly explore how
    conducive they are to the purpose of *debugging.* So, let's begin with using the
    procfs interface.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过提供驱动程序代码示例详细讨论这些接口技术。此外，我们还将简要探讨它们对*调试*目的的适用性。因此，让我们从使用procfs接口开始。
- en: Interfacing via the proc filesystem (procfs)
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过proc文件系统（procfs）进行接口
- en: In this section, we shall cover what the proc filesystem is and how you can
    leverage it as an interface between user and kernel address spaces. The proc filesystem
    is a powerful and easy-to-program interface, often used for status reporting and
    debugging core kernel systems.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍proc文件系统是什么，以及您如何将其作为用户和内核地址空间之间的接口。proc文件系统是一个强大且易于编程的接口，通常用于状态报告和调试核心内核系统。
- en: Note that from version 2.6 Linux onward and for upstream contribution, this
    interface is *not* to be used by driver authors (it's strictly meant for kernel-internal
    usage only). Nevertheless, for completeness, we will cover it here.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从Linux 2.6版本开始，对于上游贡献，这个接口*不*应该被驱动程序作者使用（它严格意味着仅用于内核内部使用）。尽管如此，为了完整起见，我们将在这里介绍它。
- en: Understanding the proc filesystem
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解proc文件系统
- en: 'Linux has a virtual filesystem named *proc*; the default mount point for it
    is `/proc`. The first thing to realize regarding the proc filesystem is that its
    content is *not* on a non-volatile disk. Its content is in RAM, and is thus volatile.
    The files and directories you can see under `/proc` are pseudo files that have
    been set up by the kernel code for proc; the kernel hints at this fact by (almost)
    always showing the file''s *size* as zero:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Linux有一个名为*proc*的虚拟文件系统；它的默认挂载点是`/proc`。关于proc文件系统的第一件事是要意识到，它的内容*不*在非易失性磁盘上。它的内容在RAM中，因此是易失性的。您在`/proc`下看到的文件和目录都是内核代码为proc设置的伪文件；内核通过（几乎）总是显示文件的*大小*为零来暗示这一事实：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's summarize a few critical points regarding Linux's powerful proc filesystem.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下关于Linux强大的proc文件系统的一些关键点。
- en: The objects under `/proc` (files, directories, soft links, and so on) are all
    pseudo objects; they live in RAM!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: /proc下的对象（文件、目录、软链接等）都是伪对象；它们存在于RAM中！
- en: Directories under /proc
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: /proc下的目录
- en: The directories under `/proc` whose names are integer values represent processes
    currently alive on the system. The name of the directory is the PID of the process
    (technically, it's the TGID of the process. We covered TGID/PID in the companion
    guide *Linux Kernel Programming *in* Chapter 6*, *Kernel and Memory Management
    Internals Essentials*).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: /proc下的目录的名称是整数值，代表当前在系统上运行的进程。目录的名称是进程的PID（从技术上讲，它是进程的TGID。我们在伴随指南*Linux内核编程*的*第6章*，*内核和内存管理内部要点*中介绍了TGID/PID）。
- en: This folder – `/proc/PID/` – contains information regarding this process. So,
    for example, for the *init* or *systemd *process (always PID `1`), you can examine
    detailed information about this process (its attributes, open files, memory layout,
    children, and so on) under the `/proc/1/` folder.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹 - `/proc/PID/` - 包含有关此进程的信息。因此，例如，对于*init*或*systemd*进程（始终是PID `1`），您可以在`/proc/1/`文件夹下查看有关此进程的详细信息（其属性、打开文件、内存布局、子进程等）。
- en: 'As an example, here, we will gain a root shell and do `ls /proc/1`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这里，我们将获得root shell并执行`ls /proc/1`：
- en: '![](img/b602d4a8-8d7b-4aca-ad53-c4f04ef4240d.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b602d4a8-8d7b-4aca-ad53-c4f04ef4240d.png)'
- en: Figure 2.1 – Screenshot of performing ls /proc/1 on an x86_64 guest system
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 - 在x86_64客户系统上执行ls /proc/1的屏幕截图
- en: The complete details regarding the pseudo files and folders under `/proc/<PID>/...`
    can be found on the man page of `proc(5)` (by doing `man 5 proc`); do try it out
    and refer to it!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`/proc/<PID>/...`下的伪文件和文件夹的完整详细信息可以在`proc(5)`的手册页中找到（通过`man 5 proc`来查看）；试一试并参考它！
- en: Note that the precise content under `/proc` varies from both the kernel version
    and the (CPU) architecture; x86_64 tends to have the richest content.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`/proc`下的精确内容因内核版本和（CPU）架构而异；x86_64架构往往具有最丰富的内容。
- en: The purpose behind the proc filesystem
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: proc文件系统的目的
- en: 'The *purpose* behind the proc filesystem is two-fold:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: proc文件系统的*目的*是双重的：
- en: One, it is a simple interface for developers, system administrators, and anyone
    really to look deep inside the kernel so that they can gain information regarding
    the internals of processes, the kernel, and even hardware. Using this interface
    only requires you to know basic shell commands such as `cd`, `cat`, `echo`, `ls`*,*
    and so on.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它是一个简单的接口，供开发人员、系统管理员和任何人深入了解内核，以便他们可以获取有关进程、内核甚至硬件内部的信息。只需要使用这个接口，你就可以知道基本的shell命令，比如`cd`、`cat`、`echo`、`ls`等等。
- en: 'Two, as the *root* user and, at times, the owner, you can write into certain
    pseudo files under `/proc/sys`, thus tuning various kernel parameters. This feature
    is called **sysctl***.* As an example, you can tune various IPv4 networking parameters
    in `/proc/sys/net/ipv4/`. They are all documented here: [https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt](https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，作为*root*用户，有时候是所有者，你可以写入`/proc/sys`下的某些伪文件，从而调整各种内核参数。这个功能被称为**sysctl***。例如，你可以在`/proc/sys/net/ipv4/`中调整各种IPv4网络参数。它们都在这里有文档：[https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt](https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt)。
- en: 'Changing the value of a proc-based tunable is easy; for example, let''s change
    the maximum number of threads allowed at any given point in time on the box. Run
    the following commands as *root*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 更改基于proc的可调参数的值很容易；例如，让我们更改在任何给定时间点上允许的最大线程数。以*root*身份运行以下命令：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With that, we''re done. However, it should be clear that the preceding operation
    is *volatile* – the change only applies to this session; a power cycle or reboot
    will result in it reverting back to the default value of course. How, then, do
    we make the change permanent*?* The short answer: use the `sysctl(8)` utility;
    refer to its man page for more details.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们完成了。然而，应该清楚的是，前面的操作是*易失性*的——更改只适用于本次会话；重新启动或重启将导致它恢复到默认值。那么，我们如何使更改*永久*生效呢？简短的答案是：使用`sysctl(8)`实用程序；参考其手册页以获取更多详细信息。
- en: Are you ready to write some procfs-interfacing code now? Not so fast – the next
    section informs you as to why this may *not* be a great idea after all.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在准备好编写一些procfs接口代码了吗？不要那么着急——下一节会告诉你为什么这可能*并不*是一个好主意。
- en: procfs is off-bounds to driver authors
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: procfs对驱动程序作者是禁用的
- en: Even though we could use the proc filesystem to interface with a user mode app,
    there is an important point to note here! You must realize that procfs is, like
    many similar facilities within the kernel, an **Application Binary Interface**
    (**ABI**). The kernel community makes no promises that it remains stable and exactly
    the way it is today, just as is the case with the kernel *APIs* and their internal
    data structures as well. In fact, ever since the 2.6 kernel, the kernel folks
    have made this very clear – *device driver authors (and the like) are not supposed
    to use procfs* for their own purposes or their interfaces, debug or otherwise.
    Earlier, with 2.6 Linux, it was quite common to use proc for said purposes (abused,
    as per the kernel community, as proc is meant for kernel internal use only!).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以使用proc文件系统与用户模式应用程序进行接口，但这里有一个重要的要点要注意！你必须意识到procfs是内核中许多类似设施的**应用程序二进制接口**（**ABI**）。内核社区并不保证它会保持稳定，就像内核*API*和它们的内部数据结构一样。事实上，自2.6内核以来，内核人员已经非常清楚地表明了这一点——*设备驱动程序作者（等等）不应该使用procfs*来进行他们自己的目的或接口，调试或其他用途。在早期的2.6
    Linux中，使用proc来进行上述目的是相当常见的（根据内核社区的说法，proc是专为内核内部使用而滥用的！）。
- en: So, if procfs is considered off-bounds, or deprecated, to us as driver authors,
    then what facility do we use to communicate with user space processes? Driver
    authors are to use the sysfs facility to *export* their interfaces. In reality,
    it's not just sysfs; there are several choices available to you such as sysfs,
    debugfs, netlink sockets, and the ioctl system call. We will cover these in detail
    later in this chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果procfs被认为对于我们作为驱动程序作者来说是禁用的或不推荐使用的，那么我们用什么设施来与用户空间进程通信呢？驱动程序作者应该使用sysfs设施来*导出*他们的接口。实际上，不仅仅是sysfs；你还有几种选择，比如sysfs、debugfs、netlink套接字和ioctl系统调用。我们将在本章后面详细介绍这些内容。
- en: Hang on, though; again, the reality is that this "rule" regarding the non-usage
    of procfs for driver authors are for the community. What this means is that if
    you intend to *upstream* your driver or kernel module to the mainline kernel,
    thus contributing your code under the GPLv2 license, *then* all the community
    rules definitely apply. If not, it's really up to you to decide. Of course, following
    the kernel community's guidelines and rules can only be a good thing; we definitely
    recommend that you do so. In terms of discouraging the use of proc by non-core
    stuff such as drivers, unfortunately, there is no recent kernel documentation
    available for the proc API/ABI.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现实情况是，关于驱动程序作者不使用procfs的这个“规则”是针对社区的。这意味着，如果你打算将你的驱动程序或内核模块上游到主线内核，从而在GPLv2许可下贡献你的代码，*那么*所有社区规则肯定适用。如果不是，那么你可以自行决定。当然，遵循内核社区的指南和规则只会是一件好事；我们强烈建议你这样做。在阻止非核心内容（如驱动程序）使用proc的方面，不幸的是，目前没有最新的内核文档可用于proc
    API/ABI。
- en: On the 5.4.0 kernel, there are around 70-odd callers of the `proc_create()`
    kernel API, several of which being (typically older) drivers and filesystems.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在5.4.0内核上，有大约70多个`proc_create()`内核API的调用者，其中有一些是（通常是较老的）驱动程序和文件系统。
- en: Nevertheless (you have been warned!), let's learn how to interact a user space
    process with kernel code via procfs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此（您已经被警告！），让我们学习如何通过procfs与内核代码交互用户空间进程。
- en: Using procfs to interface with the user space
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用procfs与用户空间进行接口
- en: As a kernel module or device driver developer, we can actually create our own
    entries under `/proc`, leveraging this as a simple interface to the user space.
    How can we do this? The kernel provides APIs that create directories and files
    under procfs. We will learn how to use them in this section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为内核模块或设备驱动程序开发人员，我们实际上可以在`/proc`下创建自己的条目，利用这作为与用户空间的简单接口。我们如何做到这一点？内核提供了API来在procfs下创建目录和文件。我们将在本节中学习如何使用它们。
- en: Basic procfs APIs
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本的procfs API
- en: 'Here, we do not intend to delve into the gory details of the procfs API set;
    rather, we shall cover just enough to have you be able to understand and use them.
    For deeper detail, do refer to the ultimate resource: the kernel code base. The
    routines we will cover here have been exported, thus making them available to
    driver authors like you. Also, as we mentioned earlier, all the procfs file objects
    are really pseudo objects, in the sense that they exist only in RAM.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不打算深入研究procfs API集的细节；相反，我们将只涵盖足够让您能够理解和使用它们。要了解更深入的细节，请参考终极资源：内核代码库。我们将在这里介绍的例程已经被导出，因此可以供像您这样的驱动程序作者使用。此外，正如我们之前提到的，所有procfs文件对象实际上都是伪对象，也就是说它们只存在于RAM中。
- en: Here, we are assuming you understand how to design and implement a simple LKM;
    you'll find more details in the companion guide to this book, *Linux Kernel Programming*,
    in the fourth and fifth chapters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设您了解如何设计和实现一个简单的LKM；您可以在本书的附属指南*Linux Kernel Programming*的第四和第五章中找到更多细节。
- en: 'Let''s begin by exploring a few simple procfs APIs that allow you to perform
    a few key tasks – creating a directory under the proc filesystem, creating (pseudo)
    files under there, and deleting them, respectively. For all of these tasks, ensure
    you include the relevant header file; that is, `#include <linux/proc_fs.h>`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探索一些简单的procfs API，它们允许您执行一些关键任务-在proc文件系统下创建目录，创建（伪）文件，并分别删除它们。对于所有这些任务，请确保包含相关的头文件；也就是说，`#include
    <linux/proc_fs.h>`：
- en: 'Create a directory named `name` under `/proc`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/proc`下创建一个名为`name`的目录：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first parameter is the name of the directory, while the second parameter
    is the pointer to the parent directory to create it under. Passing `NULL` here
    creates the directory under the root; that is, under `/proc`*.* Save the return
    value, as you will typically use it as a parameter in subsequent APIs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是目录的名称，而第二个参数是要在其下创建它的父目录的指针。在这里传递`NULL`会在根目录下创建目录；也就是说，在`/proc`下。保存返回值，因为您通常会将其用作后续API的参数。
- en: The `proc_mkdir_data()` routine allows you to pass along a data item (a `void
    *`) as well; note that it's exported via `EXPORT_SYMBOL_GPL`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`proc_mkdir_data()`例程允许您传递一个数据项（`void *`）；请注意，它是通过`EXPORT_SYMBOL_GPL`导出的。'
- en: 'Create a procfs (pseudo) file called `/proc/parent/name`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`/proc/parent/name`的procfs（伪）文件：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The key parameter here is `struct file_operations`, which we introduced in
    the previous chapter. You are expected to populate it with the "methods" to be
    implemented (more on this follows). Think about it: this is really powerful stuff;
    using the `fops`structure, you can set up "callback" functions within your driver
    (or kernel module) that the kernel''s proc filesystem layer will honor: when a
    user space process reads from your proc file, it (the VFS) will invoke the driver''s `.read`
    method or callback function. If a user space app writes, it will invoke the driver''s `.write`
    callback!'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键参数是`struct file_operations`，我们在上一章中介绍过。您需要用要实现的“方法”填充它（后面会更多介绍）。想想看：这真的是非常强大的东西；使用`fops`结构，您可以在驱动程序（或内核模块）中设置“回调”函数，内核的proc文件系统层将会遵守它们：当用户空间进程从您的proc文件中读取时，它（VFS）将调用驱动程序的`.read`方法或回调函数。如果用户空间应用程序写入，它将调用驱动程序的`.write`回调！
- en: 'Remove a procfs entry:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除一个procfs条目：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This API removes the specified `/proc/name` entry and frees it (if not in use);
    similarly (and often much more convenient), use the `remove_proc_subtree()` API
    to remove an entire sub-tree within `/proc` (typically on cleanup or if an error
    occurs).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此API删除指定的`/proc/name`条目并释放它（如果未被使用）；类似地（通常更方便），使用`remove_proc_subtree()` API来删除`/proc`中的整个子树（通常在清理或发生错误时）。
- en: Now that we know the basics, the empirical approach demands that we put these
    APIs to practice! To do so, let's figure out what directories/files to create
    under `/proc`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了基础知识，经验法则要求我们将这些API应用到实践中！为此，让我们找出在`/proc`下创建哪些目录/文件。
- en: The four procfs files we will create
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们将创建四个procfs文件
- en: 'To help clearly illustrate the usage of procfs as an interfacing technology,
    we will have our kernel module create a directory under `/proc`. Within that directory,
    it will create four procfs (pseudo) files. Note that, by default, all procfs files
    have their *owner:group* attributes as *root:root*. Now, create a directory called `/proc/proc_simple_intf`
    and, under it, create four (pseudo) files. The names and attributes of the four
    procfs (pseudo) files under the `/proc/proc_simple_intf` directory, are shown
    in the following table:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚地说明procfs作为接口技术的用法，我们将让我们的内核模块在`/proc`下创建一个目录。在该目录下，它将创建四个procfs（伪）文件。请注意，默认情况下，所有procfs文件的*owner:group*属性都是*root:root*。现在，创建一个名为`/proc/proc_simple_intf`的目录，并在其中创建四个（伪）文件。在`/proc/proc_simple_intf`目录下的四个procfs（伪）文件的名称和属性如下表所示：
- en: '| **Name of procfs ''file''** | **R: action on read callback, invoked via user
    space read** | **W: action on write callback, invoked via user space write** |
    **Procfs ''file'' permissions** |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **procfs ''file''的名称** | **R：读取回调上的操作，通过用户空间读取调用** | **W：写入回调上的操作，通过用户空间写入调用**
    | **Procfs ''file''权限** |'
- en: '| `llkdproc_dbg_level` | Retrieves (to the user space) the current value of
    the global variable; that is, `debug_level` | Updates the `debug_level` global
    variable to the value written by the user space | `0644` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `llkdproc_dbg_level` | 检索（到用户空间）全局变量的当前值；即 `debug_level` | 更新 `debug_level`
    全局变量为用户空间写入的值 | `0644` |'
- en: '| `llkdproc_show_pgoff` | Retrieves (to the user space) the kernel''s `PAGE_OFFSET`
    value | – no write callback – | `0444` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `llkdproc_show_pgoff` | 检索（到用户空间）内核的 `PAGE_OFFSET` 值 | – 无写回调 – | `0444`
    |'
- en: '| `llkdproc_show_drvctx` | Retrieves (to the user space) the current values
    within the driver''s "context" structure; that is, `drv_ctx` | – no write callback
    – | `0440` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `llkdproc_show_drvctx` | 检索（到用户空间）驱动程序“上下文”结构中的当前值；即 `drv_ctx` | – 无写回调 –
    | `0440` |'
- en: '| `llkdproc_config1` (also treated as `dbg_level`) | Retrieves (to user space)
    the current value of the context variable; that is,  `drvctx->config1` | Updates
    the driver context member, `drvctx->config1`, to the value written by the user
    space | `0644` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `llkdproc_config1`（也被视为 `dbg_level`） | 检索（到用户空间）上下文变量的当前值；即 `drvctx->config1`
    | 更新驱动程序上下文成员 `drvctx->config1` 为用户空间写入的值 | `0644` |'
- en: We'll look at the APIs and actual code to create the `proc_simple_intf` directory
    under `/proc` and the four files mentioned previously under it shortly. (Due to
    a lack of space, we won't actually show all the code; just the code with respect
    to the "debug level" get-and-set; this is not an issue, the remainder of the code
    is conceptually very similar).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看用于在 `/proc` 下创建 `proc_simple_intf` 目录和其中四个文件的 API 和实际代码（由于空间不足，我们实际上不会显示所有代码；只显示与“调试级别”获取和设置相关的代码；这不是问题，其余代码在概念上非常相似）。
- en: Trying out the dynamic debug_level procfs control
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尝试动态调试级别 procfs 控制
- en: 'First, let''s check out the "driver context" data structure that we shall use
    throughout this chapter (in fact, we first used it in the previous chapter):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们查看我们将在本章节中始终使用的“驱动程序上下文”数据结构（实际上，在上一章节中首次使用）：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we can also see that we have a global integer named `debug_level`; this
    will provide dynamic control over the debug verbosity of the "project". The debug
    level is assigned a range of `[0-2]`, where we have the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还可以看到我们有一个名为 `debug_level` 的全局整数；这将动态控制“项目”的调试详细程度。调试级别分配了一个范围 `[0-2]`，我们有以下内容：
- en: '`0` implies *no debug messages* (the default).'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 意味着*没有调试消息*（默认值）。'
- en: '`1` is *medium debug* verbosity.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` 是*中等调试*详细程度。'
- en: '`2` implies *high debug* verbosity.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2` 意味着*高调试*详细程度。'
- en: The beauty of the whole schema – and indeed the whole point here – is that we
    shall be able to query and set this `debug_level` variable from the user space
    via a procfs interface that we've created! This will allow the end user (who,
    for security reasons, requires *root* access) to dynamically vary the debug level
    at runtime (a fairly common feature found in many products).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 整个架构的美妙之处 – 实际上整个重点在于 – 我们将能够通过我们创建的 procfs 接口从用户空间查询和设置这个 `debug_level` 变量！这将允许最终用户（出于安全原因，需要
    *root* 访问权限）在运行时动态地改变调试级别（这是许多产品中常见的功能）。
- en: 'Before diving into the code-level details, let''s try it out so that we know
    what to expect:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解代码级细节之前，让我们先试一下，这样我们就知道可以期待什么：
- en: 'Here, using our `lkm` convenience wrapper script, we must build and `insmod(8)`
    the kernel module (`ch2/proc_simple_intf` in this book''s source tree):'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，使用我们的 `lkm` 便捷包装脚本，我们必须构建并 `insmod(8)` 内核模块（本书源代码树中的 `ch2/proc_simple_intf`）：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we built and inserted the kernel module; `dmesg(1)` displays the kernel
    *printks* showing that one of the procfs files we created is the one pertaining
    to the dynamic debug facility (highlighted in bold here; since these are pseudo
    files, the file size will appear as `0` bytes).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们构建并插入了内核模块；`dmesg(1)` 显示了内核 *printks*，显示我们创建的 procfs 文件之一是与动态调试功能相关的文件（在这里用粗体突出显示；由于这些是伪文件，文件大小将显示为
    `0` 字节）。
- en: 'Now, let''s test it by querying the current value of `debug_level`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过查询 `debug_level` 的当前值来测试它：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Great, it''s zero – the default – as expected. Now, let''s change the debug
    level to `2`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很好，它是零 – 默认值 – 如预期的那样。现在，让我们将调试级别更改为 `2`：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice how we had to issue `echo` as *root*. As we can see, the debug level
    has indeed changed (to a value of `2`)! Attempting to set the value out of range
    is caught as well (and the `debug_level` variable''s value is reset to its last
    valid value), as shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须以 *root* 身份发出 `echo`。正如我们所看到的，调试级别确实已经改变（为值 `2`）！尝试设置超出范围的值也被捕获（并且 `debug_level`
    变量的值被重置为其最后有效的值），如下所示：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Right; it worked as expected. However, the question is, how did all this work
    at the code level? Read on to find out!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，它按预期工作。然而，问题是，所有这些在代码级别是如何工作的？继续阅读以了解详情！
- en: Dynamically controlling debug_level via procfs
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 procfs 动态控制 debug_level
- en: 'Let''s answer the aforementioned question – *how is it done in code?* It''s
    quite straightforward, really:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回答前面提到的问题 – *代码中是如何做到的？* 实际上非常简单：
- en: 'First off, within the `init` code of the kernel module, we must create our
    procfs directory, naming it after the name of our kernel module:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在内核模块的 `init` 代码中，我们必须创建我们的 procfs 目录，并以内核模块的名称命名它：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Again, within the `init` code of the kernel module, we must create the `procfs`
    file that controls the project''s "debug level":'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在内核模块的 `init` 代码中，我们必须创建控制项目“调试级别”的 `procfs` 文件：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we used the `proc_create()` API to create the *procfs* file and "linked"
    it to the supplied `file_operations` structure.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 `proc_create()` API 来创建 *procfs* 文件，并将其“链接”到提供的 `file_operations`
    结构。
- en: 'The fops structure (technically, `struct file_operations`) is the key data
    structure here. As we learned in [Chapter 1](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml),
    *Writing a Simple misc Character Device Driver*, it''s where we assign *functionality*
    to the various file operations on the device, or, as in this case, the procfs
    file. Here''s the code initializing our fops:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: fops结构（技术上是`struct file_operations`）在这里是关键的数据结构。正如我们在[第1章](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml)
    *编写简单的杂项字符设备驱动程序*中学到的，这是我们为设备上的各种文件操作分配*功能*的地方，或者在这种情况下，procfs文件。这是初始化我们的fops的代码：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `open` method of fops points to a function we must define:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: fops的`open`方法指向一个我们必须定义的函数：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using the kernel's `single_open()` API, we register the fact that, whenever
    this file is read –  which is ultimately done via the `read(2)` system call from
    the user space – the proc filesystem will "call back" our `proc_show_debug_level()` routine
    (the second parameter to `single_open()`).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内核的`single_open()` API，我们注册了这样一个事实，即每当这个文件被读取时-最终是通过用户空间的`read(2)`系统调用完成的-
    proc文件系统将“回调”我们的`proc_show_debug_level()`例程（作为`single_open()`的第二个参数）。
- en: 'We won''t bother with the internal implementation of the `single_open()` API
    here; if you''re curious, you can always look it up here: `fs/seq_file.c:single_open()`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里打扰`single_open()` API的内部实现；如果你感兴趣，你可以在这里查找：`fs/seq_file.c:single_open()`。
- en: 'So, to summarize, to register a "read" method with procfs, we do the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，要在procfs中注册一个“读”方法，我们需要做以下工作：
- en: Initialize the `fops.open` pointer to a `foo()` function.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`fops.open`指针初始化为`foo()`函数。
- en: In the `foo()` function, call `single_open()`, providing the read callback function
    as the second parameter.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`foo()`函数中，调用`single_open()`，将读回调函数作为第二个参数。
- en: There's some history here; without getting too deep into it, suffice it to say
    that the older working of procfs had issues. Notably, you couldn't transfer more
    than a single page of data (with read or write) without manually iterating over
    the content. The *sequence iterator* functionality that was introduced with 2.6.12
    fixed these issues. Nowadays, using `single_open()` and its ilk (the `seq_read`,
    `seq_lseek`, and `seq_release` built-in kernel functions) is the simpler and correct
    approach to using procfs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些历史；不深入讨论，可以说procfs的旧工作方式存在问题。特别是，你无法在没有手动迭代内容的情况下传输超过一个页面的数据（使用读或写）。在2.6.12引入的*序列迭代器*功能解决了这些问题。如今，使用`single_open()`及其类似功能（`seq_read`、`seq_lseek`和`seq_release`内置内核函数）是使用procfs的更简单和正确的方法。
- en: 'So, what about when user space *writes* (via the `write(2)` system call) into
    a proc file? Simple: in the preceding code, you can see that we have registered
    the `fops_rdwr_dbg_level.write` method as the `myproc_write_debug_level()` function,
    implying that this function will be *called back* whenever this (pseudo) file
    is written to (it''s explained in *Step 6*, following the *read* callback).'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那么，当用户空间*写入*（通过`write(2)`系统调用）到一个proc文件时怎么办？简单：在前面的代码中，你可以看到我们已经注册了`fops_rdwr_dbg_level.write`方法作为`myproc_write_debug_level()`函数，这意味着每当写入这个（伪）文件时，这个函数将被*回调*（在*步骤6*中解释了*读*回调之后）。
- en: 'The code of the *read* callback function that we registered via `single_open` is
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`single_open`注册的*读*回调函数的代码如下：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`seq_printf()` is conceptually similar to the familiar `sprintf()` API. It
    correctly prints – to the `seq_file` object – the data supplied to it. When we
    say "prints" here, what we really mean is that it effectively passes the data
    buffer to the user space process or thread that issued the read system call that
    got us here in the first place, in effect *transferring the data to the user space.*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`seq_printf()`在概念上类似于熟悉的`sprintf()` API。它正确地将提供给它的数据打印到`seq_file`对象上。当我们在这里说“打印”时，我们真正的意思是它有效地将数据缓冲区传递给发出了读系统调用的用户空间进程或线程，从而*将数据传输到用户空间*。'
- en: Oh yes, what's with the `mutex_{un}lock*()` APIs? They are for something critical –
    *locking.* We will provide a detailed discussion on locking in [Chapter 6](f456f2ea-ca5f-4d0f-b9c0-55b9ae92f659.xhtml),
    *Kernel Synchronization – Part 1*, and [Chapter 7](14cf1232-dfd5-428a-9c0b-30bcd84651b9.xhtml),
    *Kernel Synchronization – Part 2*; for now, just understand that these are required
    synchronization primitives.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，是的，`mutex_{un}lock*()` API是什么情况？它们用于一些关键的*锁定*。我们将在[第6章](f456f2ea-ca5f-4d0f-b9c0-55b9ae92f659.xhtml)
    *内核同步-第1部分*和[第7章](14cf1232-dfd5-428a-9c0b-30bcd84651b9.xhtml) *内核同步-第2部分*中对锁定进行详细讨论；现在，只需理解这些是必需的同步原语。
- en: 'The `write` callback function we registered via `fops_rdwr_dbg_level.write` is
    as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过`fops_rdwr_dbg_level.write`注册的*写*回调函数如下：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In our write method's implementation (notice how similar it is in structure
    to a character device driver's write method), we performed some validity checking
    and then copied in the data the user space process wrote to us (recall how we
    used the `echo` command to write to the procfs file) via the usual `copy_from_user()`
    function. We then used the kernel's built-in `kstrtoint()` API (there are several
    in a similar vein) to convert the string buffer into an integer, storing the result
    in our global variable; that is, `debug_level`! Again, we validate it, and if
    all's well, we also set (just as an example) our driver context's `config1` member
    to the same value and then return a success message.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的写方法实现中（注意它在结构上与字符设备驱动程序的写方法有多相似），我们进行了一些有效性检查，然后将用户空间进程写入的数据复制到我们这里（回想一下我们如何使用`echo`命令写入procfs文件），通过通常的`copy_from_user()`函数。然后，我们使用内核内置的`kstrtoint()`
    API（类似的还有几个）将字符串缓冲区转换为整数，并将结果存储在我们的全局变量中；也就是`debug_level`！再次验证它，如果一切正常，我们还设置（只是作为一个例子）我们驱动程序上下文的`config1`成员为相同的值，然后返回一个成功消息。
- en: The remainder of the kernel module's code is very similar – we set up the functionality
    for the remaining three procfs files. I leave it to you to browse through the
    code in detail and try it out.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内核模块的其余代码非常相似-我们为剩下的三个procfs文件设置功能。我留给你详细浏览代码并尝试它。
- en: 'One more quick demo: let''s set `debug_level` to `1` and then dump the driver
    context structure (via the third procfs file we created):'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个快速演示：让我们将`debug_level`设置为`1`，然后通过我们创建的第三个procfs文件转储驱动程序上下文结构：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Okay, the `debug_level` variable will now have a value of `1`; now, let''s
    dump the driver context structure:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，`debug_level`变量现在将具有值`1`；现在，让我们转储驱动程序上下文结构：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We need *root* access to do this. Once done, we can clearly see all the members
    of our `drv_ctx` data structure. Not only that, but we verified that the `config1` member,
    highlighted in bold, now has a value of `1`, thus reflecting the "debug level"
    as designed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要*root*访问权限才能这样做。一旦完成，我们可以清楚地看到我们的`drv_ctx`数据结构的所有成员。不仅如此，我们还验证了加粗显示的`config1`成员现在的值为`1`，因此反映了设计的“调试级别”。
- en: Also, notice how the output is deliberately generated to the user space in a
    highly parseable format, almost JSON-like. Of course, as a small exercise, you
    could arrange to do precisely that!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意输出是故意以高度可解析的格式生成到用户空间，几乎类似于JSON。当然，作为一个小练习，你可以安排精确地做到这一点！
- en: A large number of recent **Internet of Things** (**IoT**) products use RESTful
    APIs to communicate; the format that's parsed is typically JSON. Getting in the
    habit of designing and implementing your kernel-to-user (and vice versa) communication
    in easily parsable formats (such as JSON) is only going to help.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最近大量的**物联网**（**IoT**）产品使用RESTful API进行通信；通常解析的格式是JSON。养成在易于解析的格式（如JSON）中设计和实现内核到用户（反之亦然）的通信的习惯只会有所帮助。
- en: With that, you have learned how exactly to create a procfs directory, a file
    within it, and, most importantly, how to create and use the read and write callback
    functions so that when a user mode process reads or writes your proc file, you
    can respond appropriately from deep within the kernel. As we mentioned earlier,
    due to a lack of space, we will not describe the code driving the remaining three
    procfs files we have created and used. This is very similar conceptually to what
    we have just covered. We expect you to read through and try it out!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，你已经学会了如何创建procfs目录、其中的文件，以及最重要的是如何创建和使用读写回调函数，以便当用户模式进程读取或写入你的proc文件时，你可以从内核深处做出适当的响应。正如我们之前提到的，由于空间不足，我们将不描述驱动其余三个procfs文件的代码。从概念上讲，这与我们刚刚讨论的非常相似。我们希望你能仔细阅读并尝试一下！
- en: A few misc procfs APIs
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些杂项procfs API
- en: Let's conclude this section by looking at a few remaining miscellaneous procfs
    APIs. You can create a symbolic or soft link within `/proc` by using the `proc_symlink()`
    function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看一些剩余的杂项procfs API来结束本节。你可以使用`proc_symlink()`函数在`/proc`中创建一个符号或软链接。
- en: 'Next, the `proc_create_single_data()` API can be very useful; it''s used as
    a "shortcut", where you require just a "read" method to be attached to a procfs
    file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`proc_create_single_data()` API可能非常有用；它被用作一个“快捷方式”，在那里你只需要将一个“读”方法附加到一个procfs文件：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using this API thus eliminates the need for a separate fops data structure.
    We can use this function to create and work with our second procfs file – the
    `llkdproc_show_pgoff` file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个API可以消除对单独的fops数据结构的需求。我们可以使用这个函数来创建和处理我们的第二个procfs文件——`llkdproc_show_pgoff`文件：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When read from the user space, the kernel''s VFS and proc layer code paths
    will invoke the registered method – the `proc_show_pgoff()` function of our module
    – within which we trivially invoke `seq_printf()` to send the value of `PAGE_OFFSET`
    to the user space:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户空间读取时，内核的VFS和proc层代码路径将调用已注册的方法——我们模块的`proc_show_pgoff()`函数——在其中我们轻松地调用`seq_printf()`将`PAGE_OFFSET`的值发送到用户空间：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Furthermore, note the following regarding the `proc_create_single_data` API:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意`proc_create_single_data` API的以下内容：
- en: You can make use of the fifth parameter to `proc_create_single_data()` to pass
    any data item to the read callback (retrieved there as a `seq_file` member called
    `private`, very similar to how we used `filp->private_data` in the previous chapter).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以利用`proc_create_single_data()`的第五个参数将任何数据项传递给读回调（在那里作为`seq_file`成员`private`检索，非常类似于我们在上一章中使用`filp->private_data`的方式）。
- en: Several typically older drivers within the kernel mainline do make use of this
    function to create their procfs interfaces. Among them is the RTC driver (which
    sets up an entry at `/proc/driver/rtc`). The SCSI `megaraid` driver (`drivers/scsi/megaraid`) uses
    this routine no fewer than 10 times to set up its proc interfaces (when a config
    option is enabled; it is by default).
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核主线中的一些通常较老的驱动程序确实使用这个函数来创建它们的procfs接口。其中之一是RTC驱动程序（在`/proc/driver/rtc`设置一个条目）。SCSI
    `megaraid`驱动程序（`drivers/scsi/megaraid`）使用这个例程至少10次来设置它的proc接口（当启用配置选项时；默认情况下是启用的）。
- en: Be careful! I find that on an Ubuntu 18.04 LTS system running the distro (default)
    kernel, this API – `proc_create_single_data()` – isn't even available, so the
    build fails. On our custom "vanilla" 5.4 LTS kernel, it works just fine.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 小心！我发现在运行分发（默认）内核的Ubuntu 18.04 LTS系统上，这个API——`proc_create_single_data()`——甚至都不可用，所以构建失败了。在我们自定义的“纯净”5.4
    LTS内核上，它运行得很好。
- en: 'In addition, there is some documentation on the procfs API we''ve set here,
    though this tends to be for internal usage and not for modules: [https://www.kernel.org/doc/html/latest/filesystems/api-summary.html#the-proc-filesystem](https://www.kernel.org/doc/html/latest/filesystems/api-summary.html#the-proc-filesystem).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，关于我们在这里设置的procfs API，有一些文档，尽管这些文档往往是用于内部使用而不是用于模块：[https://www.kernel.org/doc/html/latest/filesystems/api-summary.html#the-proc-filesystem](https://www.kernel.org/doc/html/latest/filesystems/api-summary.html#the-proc-filesystem)。
- en: So, as we mentioned previously, with the procfs APIs it's a case of **Your Mileage
    May Vary** (**YMMV**)! Carefully test your code before release. It's probably
    best to follow the kernel community guidelines and simply say **No** to procfs
    as a driver interfacing technique. Worry not – we'll look at better ones throughout
    this chapter!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们之前提到的，使用procfs API是一个**因人而异**（**YMMV**）的情况！在发布之前，请仔细测试你的代码。最好遵循内核社区的指南，并简单地对procfs作为驱动程序接口技术说**不**。不用担心，我们将在本章的其余部分中看到更好的方法！
- en: This completes our coverage on using procfs as a useful communication interface.
    Now, let's learn how to use a more appropriate one for drivers – the sysfs interface.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对使用procfs作为有用通信接口的覆盖。现在，让我们学习如何为驱动程序使用更合适的接口- sysfs接口。
- en: Interfacing via the sys filesystem (sysfs)
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过sys文件系统进行接口
- en: 'A critical feature of the 2.6 Linux kernel release was the advent of what is
    called the modern *device model*. Essentially, a series of complex tree-like hierarchical
    data structures model all devices present on the system. Actually, it goes well
    beyond this; the **sysfs** tree encompasses the following (among other things):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 2.6 Linux内核发布的一个关键特性是现代*设备模型*的出现。基本上，一系列复杂的类似树状的分层数据结构对系统上所有设备进行建模。实际上，它远不止于此；**sysfs**树包括以下内容（以及其他内容）：
- en: Every bus present on the system (it can be a virtual or pseudo bus as well)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统上存在的每个总线（也可以是虚拟或伪总线）
- en: Every device present on every bus
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个总线上的设备
- en: Every device driver bound to a device on a bus
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个绑定到总线上设备的设备驱动程序
- en: Thus, it's not just peripheral devices but also the underlying system buses,
    the devices on each bus and the device driver bound or that will bind to a device,
    that are created at runtime and maintained by the device model. The inner workings
    of this model are invisible to you, as a typical driver author; you don't really
    have to worry about it. On system boot, and whenever a new device becomes visible,
    the *driver core* (part of the built-in kernel machinery) generates the required
    virtual files under the sysfs tree. (Conversely, when a device is removed or detached,
    its entry disappears from the tree.)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它不仅仅是外围设备，还有底层系统总线，每个总线上的设备以及绑定到设备的设备驱动程序，这些都是在运行时由设备模型创建和维护的。这个模型的内部工作对于您作为典型的驱动程序作者来说是不可见的；您不必真正担心它。在系统引导时，以及每当新设备变得可见时，*驱动程序核心*（内置内核机制的一部分）会在sysfs树下生成所需的虚拟文件。（相反，当设备被移除或分离时，其条目会从树中消失。）
- en: Recall, though, from the *Interfacing with the proc filesystem* section, that
    using procfs for a device driver's interfacing purposes is not really the right
    approach, at least for code that wants to move upstream. So, what *is* the right
    approach? Ah, *creating sysfs (pseudo) files is considered the "correct way" for
    device drivers to interface with the user space.*
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，从*与proc文件系统进行接口*部分可以看出，对于设备驱动程序的接口目的来说，使用procfs并不是真正正确的方法，至少对于想要上游移动的代码来说。那么，什么才是正确的方法呢？啊，*创建sysfs（伪）文件被认为是设备驱动程序与用户空间进行接口的“正确方式”*。
- en: 'So, now we see it! sysfs is a virtual filesystem typically mounted on the `/sys` directory.
    In effect, sysfs, very similarly to procfs, is a kernel-exported tree of information
    (device and other) that''s sent to the user space. You can think of sysfs as having
    different *viewports* into the modern device model. Via sysfs, you can view the
    system in several different ways or via different "viewports"; for example, you
    can view the system via the various buses it supports (the *bus* view – PCI, USB,
    platform, I2C, SPI, among several others), via various "classes" of devices (the
    *class* view), via the *devices* themselves, via the *block* devices viewport,
    and so on. The following screenshot showing the content of `/sys` on my Ubuntu
    18.04 LTS VM shows this to be the case:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们明白了！sysfs是一个虚拟文件系统，通常挂载在`/sys`目录上。实际上，sysfs与procfs非常相似，是一个内核导出的信息（设备和其他）树，发送到用户空间。您可以将sysfs视为对现代设备模型具有不同*视口*。通过sysfs，您可以以几种不同的方式或通过不同的“视口”查看系统；例如，您可以通过它支持的各种总线（*总线*视图-PCI、USB、平台、I2C、SPI等）查看系统，通过各种设备的“类”（*类*视图），通过*设备*本身，通过*块*设备视口等等。下面的屏幕截图显示了我在Ubuntu
    18.04 LTS VM上的`/sys`目录的内容：
- en: '![](img/bf6846b2-8f7a-47e3-98a2-be5528a87f22.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bf6846b2-8f7a-47e3-98a2-be5528a87f22.png)'
- en: Figure 2.2 – Screenshot showing the content of sysfs (/sys) on an x86_64 Ubuntu
    VM
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 - 屏幕截图显示了x86_64 Ubuntu VM上sysfs（/sys）的内容
- en: As we can see, with sysfs, there are several other viewports via that you can
    use to look into the system as well. Of course, in this section, we wish to understand
    how to interface a device driver to the user space via sysfs, how to write the
    code to create our driver (pseudo) files under sysfs, and how to register the
    read/write callbacks from them. Let's begin by looking at the basic sysfs APIs.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，通过sysfs，还有其他几个视口可以用来查看系统。当然，在这一部分，我们希望了解如何通过sysfs将设备驱动程序与用户空间进行接口，如何编写代码在sysfs下创建我们的驱动程序（伪）文件，以及如何注册从中读取/写入的回调。让我们首先看一下基本的sysfs
    API。
- en: Creating a sysfs (pseudo) file in code
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在代码中创建一个sysfs（伪）文件
- en: 'One way to create a pseudo (or virtual) file under sysfs is via the `device_create_file()`
    API. Its signature is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在sysfs下创建伪（或虚拟）文件的一种方法是通过`device_create_file()`API。其签名如下：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's consider its two parameters one by one; first, there is a pointer to `struct
    device`. The second parameter is a pointer to a device attribute structure; we
    shall explain and work on it a bit later (in the *Setting up the device attributes
    and creating the sysfs file* section). For now, let's focus on the first parameter
    only – the device structure. It seems quite intuitive – a device is represented
    by a metadata structure called `device` (it is part of the driver core; you can
    look up its full definition in the `include/linux/device.h` header).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个考虑它的两个参数；首先，有一个指向`struct device`的指针。第二个参数是指向设备属性结构的指针；我们稍后将对其进行解释和处理（在*设置设备属性和创建sysfs文件*部分）。现在，让我们只关注第一个参数-设备结构。这似乎很直观-设备由一个称为`device`的元数据结构表示（它是驱动程序核心的一部分；您可以在`include/linux/device.h`头文件中查找其完整定义）。
- en: Note that when you write (or work on) a "real" device driver, chances are high
    that a generic *device structure* will exist or come into being. This often happens
    upon *registering* the device; an underlying device structure is usually made
    available as a member of a specialized structure for that device. For example,
    all structures, such as `platform_device`, `pci_device`, `net_device`, `usb_device`, 
    `i2c_client`, `serial_port` and so on, have a `struct device` member embedded
    within them. Thus, you can use that device structure pointer as a parameter to
    the API for the purpose of creating files under sysfs. Rest assured, you shall
    soon see this being done in code! So, let's get going by getting ourselves a device
    structure by creating a simple "platform device". You'll learn how to do this
    in the next section!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当您编写（或处理）“真实”设备驱动程序时，很有可能会存在或产生一个通用的*设备结构*。这通常发生在*注册*设备时；一个底层设备结构通常作为该设备的专用结构的成员而提供。例如，所有结构，如`platform_device`、`pci_device`、`net_device`、`usb_device`、`i2c_client`、`serial_port`等，都嵌入了一个`struct
    device`成员。因此，您可以使用该设备结构指针作为在sysfs下创建文件的API的参数。请放心，您很快就会看到这在代码中被执行！因此，让我们通过创建一个简单的“平台设备”来获得一个设备结构。您将在下一节中学习如何做到这一点！
- en: Creating a simple platform device
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的平台设备
- en: Clearly, in order to create a (pseudo) file under sysfs, we somehow require,
    as the first parameter to `device_create_file()`, a pointer to a `struct device`.
    However, for our demo sysfs driver here and now, we don't actually have any real
    device, and therefore no `struct device`, to work on!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，为了在sysfs下创建（伪）文件，我们需要一些东西作为`device_create_file()`的第一个参数，即一个指向`struct device`的指针。然而，对于我们这里和现在的演示sysfs驱动程序，我们实际上没有任何真正的设备，因此也没有`struct
    device`可以操作！
- en: So, can't we create an *artificial* or *pseudo device* and simply use it? Yes,
    but how, and more crucially, why exactly should we have to do this? It's critical
    to understand that the modern **Linux Device Model** (**LDM**) is built on three
    key components:** an underlying bus must exist that devices live on, and devices
    are "bound to" and driven by device drivers**. (We already mentioned this in [Chapter
    1](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml), *Writing a Simple misc Character
    Device Driver*, in the *A quick note on the Linux Device Model *section).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们不能创建一个*人工*或*伪设备*并简单地使用它吗？是的，但是如何，更重要的是，为什么我们需要这样做？至关重要的是要理解，现代**Linux设备模型**（**LDM**）是建立在三个关键组件上的：**必须存在一个底层总线，设备驻留在上面，并且设备由设备驱动程序“绑定”和驱动**。（我们已经在[第1章](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml)中提到过，*编写一个简单的misc字符设备驱动程序*，在*A
    quick note on the Linux Device Model*部分）。
- en: All of these must be registered to the driver core. Now, don't worry about the
    buses and the bus drivers that drive them; they will be registered and handled
    internally by the kernel's driver core subsystem. When there is no real *device*,
    however, we will have to create a pseudo one in order to work with the model.
    Again, there are several ways to do such things, but we shall create **a** ***platform
    device**.* This device will "live" on a pseudo bus (that is, it exists only in
    software) known as the ***platform bus**.*
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都必须注册到驱动核心。现在，不要担心驾驶它们的公交车和公交车司机；它们将在内核的驱动核心子系统内部注册和处理。然而，当没有真正的*设备*时，我们将不得不创建一个伪设备以便与模型一起工作。再次，有几种方法可以做这样的事情，但我们将创建**一个***平台设备**。*这个设备将“存在”于一个伪总线（即，它只存在于软件中）上，称为***平台总线***。
- en: Platform devices
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平台设备
- en: 'A quick but important aside: *platform devices* are often used to represent
    the variety of devices on a **System on Chip** (**SoC**) within an embedded board.
    The SoC is typically a very sophisticated chip that integrates various components
    into its silicon. Besides processing units (CPUs/GPUs), it might house several
    peripherals too, including Ethernet MAC, USB, multimedia, serial UART, clock,
    I2C, SPI, flash chip controllers, and so on. A reason we need these components
    to be enumerated as a platform device is that there is no physical bus within
    the SoC; thus, the platform bus is used.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速但重要的侧面：*平台设备*通常用于表示嵌入式板内**系统芯片**（**SoC**）上各种设备的多样性。SoC通常是一个集成了各种组件的非常复杂的芯片。除了处理单元（CPU/GPU）外，它可能还包括多个外围设备，包括以太网MAC、USB、多媒体、串行UART、时钟、I2C、SPI、闪存芯片控制器等。我们需要将这些组件枚举为平台设备的原因是SoC内部没有物理总线；因此使用平台总线。
- en: Traditionally, the code that was used to instantiate these SoC platform devices
    was kept in a "board" file (or files) within the kernel source (`arch/<arch>/...`).
    Due to it becoming overloaded, it's been moved outside the pure kernel source
    into a useful hardware description format called the **Device Tree** (within **Device
    Tree Source** (**DTS**) files that are themselves with the kernel source tree).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，用于实例化这些SoC平台设备的代码保存在内核源代码中的“板”文件（或文件）中（`arch/<arch>/...`）。由于它变得过载，它已经从纯内核源代码中移出，转移到一个称为**设备树**的有用硬件描述格式中（在内核源树中的**设备树源**（**DTS**）文件中）。
- en: 'On our Ubuntu 18.04 LTS guest VM, let''s look at the platform devices under
    sysfs:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Ubuntu 18.04 LTS虚拟机中，让我们看看sysfs下的平台设备：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The *Bootlin* website (previously called *Free Electrons*) offers superb materials
    on embedded Linux, drivers, and so on. This link on their site leads to excellent
    material on the LDM: [https://bootlin.com/pub/conferences/2019/elce/opdenacker-kernel-programming-device-model/](https://bootlin.com/pub/conferences/2019/elce/opdenacker-kernel-programming-device-model/).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*Bootlin*网站（以前称为*Free Electrons*）提供了关于嵌入式Linux、驱动程序等方面的出色材料。他们网站上的这个链接指向了关于LDM的优秀材料：[https://bootlin.com/pub/conferences/2019/elce/opdenacker-kernel-programming-device-model/](https://bootlin.com/pub/conferences/2019/elce/opdenacker-kernel-programming-device-model/)。'
- en: 'Back to the driver: we bring our (artificial) platform device into existence
    by registering it to the (already existing) platform bus driver via the `platform_device_register_simple()`
    API. The moment we do so, the driver core will *generate* the required sysfs directories
    and a few boilerplate sysfs entries (or files). Here, in the init code of our
    sysfs demo driver, we will set up a (simplest possible) *platform device* by registering
    it to the driver core:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 回到驱动程序：我们通过`platform_device_register_simple()` API将我们的（人工）平台设备注册到（已经存在的）平台总线驱动程序，从而使其存在。在我们这样做的时候，驱动核心将*生成*所需的sysfs目录和一些样板sysfs条目（或文件）。在这里，在我们的sysfs演示驱动程序的初始化代码中，我们将通过将其注册到驱动核心来设置一个（可能最简单的）*平台设备*：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `platform_device_register_simple()` API returns a pointer to `struct platform_device`.
    One of this structure''s members is `struct device dev`. We now have what we''ve
    been after: a *device* *structure*. Also, it''s key to note that when this registration
    API runs, the effect is visible within sysfs*.* You can easily see the new platform
    device, plus a few boilerplate sysfs objects, being created by the driver core
    here (made visible to us via sysfs); let''s build and *insmod* our kernel module
    to see this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`platform_device_register_simple()` API返回一个指向`struct platform_device`的指针。该结构的成员之一是`struct
    device dev`。我们现在得到了我们一直在寻找的：一个*设备* *结构*。此外，需要注意的是，当这个注册API运行时，效果在sysfs中是可见的。你可以很容易地看到新的平台设备，以及一些样板sysfs对象，由驱动核心在这里创建（通过sysfs对我们可见）；让我们构建和*insmod*我们的内核模块来看看这一点：'
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can create a `struct device` in different ways; the generic way is to set
    up and issue the `device_create()` API. An alternate means to creating a sysfs
    file, while bypassing the need for a device structure, is to create a "object"
    and invoke the `sysfs_create_file()` API. (Links to tutorials that use both these
    approaches can be found in the *Further reading* section). Here, we prefer to
    use a "platform device" as it's the closer approach to writing a (platform) driver.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以不同的方式创建一个`struct device`；通用的方法是设置并发出`device_create()` API。创建sysfs文件的另一种方法，同时绕过设备结构的需要，是创建一个“对象”并调用`sysfs_create_file()`
    API。（在*进一步阅读*部分可以找到使用这两种方法的教程链接）。在这里，我们更喜欢使用“平台设备”，因为它更接近于编写（平台）驱动程序。
- en: There's yet another valid approach. As we saw in [Chapter 1](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml),
    *Writing a simple misc Character Device Driver*, we built a simple character driver
    conforming to the kernel's `misc` framework. There, we instantiated a `struct
    miscdevice`; once registered (via the `misc_register()` API), this structure will
    contain a member called `struct device *this_device;`, thus allowing us to use
    it as a valid device pointer! Thus, we could have simply extended our earlier
    `misc` device driver and used it here. However, in order to learn a bit about
    platform drivers, we've chosen that approach. (We leave the approach of extending
    our earlier `misc` device driver so that it can use sysfs APIs and create/use
    sysfs files as an exercise to you).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种有效的方法。正如我们在[第1章](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml)中所看到的，*编写一个简单的杂项字符设备驱动程序*，我们构建了一个符合内核`misc`框架的简单字符驱动程序。在那里，我们实例化了一个`struct
    miscdevice`；一旦注册（通过`misc_register()` API），这个结构将包含一个名为`struct device *this_device;`的成员，因此我们可以将其用作有效的设备指针！因此，我们可以简单地扩展我们之前的`misc`设备驱动程序并在这里使用它。然而，为了学习一些关于平台驱动程序的知识，我们选择了这种方法。（我们将扩展我们之前的`misc`设备驱动程序以便它可以使用sysfs
    API并创建/使用sysfs文件的方法留给你作为练习）。
- en: 'Back to our driver, compared to the init code, in the *cleanup* code, we must
    un-register our platform device:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的驱动程序，与初始化代码相比，在*清理*代码中，我们必须取消注册我们的平台设备：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, let's tie all this knowledge together and actually see the code that generates
    the sysfs files, along with their read and write callback functions!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把所有这些知识联系在一起，实际上看一下生成sysfs文件的代码，以及它们的读取和写入回调函数！
- en: Tying it all together – setting up the device attributes and creating the sysfs
    file
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 把所有这些联系在一起——设置设备属性并创建sysfs文件
- en: 'As we mentioned at the beginning of this section, the `device_create_file()`
    API is the one we''ll use to create our sysfs file:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节开头提到的，`device_create_file()` API是我们将用来创建我们的sysfs文件的API：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the previous section, you learned how we obtain a device structure (the
    first parameter for our API). Now, let''s figure out how to initialize and use
    the second parameter; that is, the `device_attribute` structure. The structure
    itself is defined as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你学会了如何获取设备结构（我们API的第一个参数）。现在，让我们弄清楚如何初始化和使用第二个参数；也就是`device_attribute`结构。该结构本身定义如下：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The first member, `attr`, essentially consists of the *name* of the sysfs file
    and its *mode* (permission bitmask). The other two members are function pointers
    ("virtual functions", analogous to those in the **file operations** or **fops**
    structure):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个成员`attr`本质上包括sysfs文件的*名称*和*模式*（权限掩码）。另外两个成员是函数指针（“虚函数”，类似于**文件操作**或**fops**结构中的函数）：
- en: '`show`: Represents the *read callback* function'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`show`：表示*读取回调*函数'
- en: '`store`: Represents the *write callback* function'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`store`：表示*写入回调*函数'
- en: 'Our job is to initialize this `device_attribute` structure, thus setting up
    the sysfs file. While you can always manually initialize it, there''s an easier
    approach: the kernel provides (several) macros for initializing `struct device_attribute`;
    among them is the `DEVICE_ATTR()` macro:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作是初始化这个`device_attribute`结构，从而设置sysfs文件。虽然你可以手动初始化它，但也有一个更简单的方法：内核提供了（几个）用于初始化`struct
    device_attribute`的宏；其中之一是`DEVICE_ATTR()`宏：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Notice the "stringification" that''s performed by `dev_attr_##_name`, ensuring
    that the structure''s name is suffixed with the name that''s passed as the first
    parameter to `DEVICE_ATTR`. Furthermore, the actual "worker" macro, named `__ATTR()`,
    actually instantiates a `device_attribute` structure in code at preprocessing
    time, with (via stringification) the name of the structure becoming `dev_attr_<name>`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`dev_attr_##_name`执行的“字符串化”，确保结构的名称后缀是作为`DEVICE_ATTR`的第一个参数传递的名称。此外，实际的“工作”宏，名为`__ATTR()`，实际上在预处理时在代码中实例化了一个`device_attribute`结构，通过字符串化使结构的名称变为`dev_attr_<name>`：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Furthermore, the kernel defines additional simple wrapper macros over these
    macros in order to specify the *mode* (permissions for the sysfs file), thus making
    it even simpler for you, the driver author. Among them is `DEVICE_ATTR_RW(_name)`,
    `DEVICE_ATTR_RO(_name)`, and `DEVICE_ATTR_WO(_name)`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，内核定义了额外的简单包装宏，以覆盖这些宏，以指定sysfs文件的*模式*（权限），从而使驱动程序作者更加简单。其中包括`DEVICE_ATTR_RW(_name)`，`DEVICE_ATTR_RO(_name)`和`DEVICE_ATTR_WO(_name)`：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With this code, we can create a **read-write** (**RW**), **read-only** (**RO**),
    or **write-only** (**WO**) sysfs file. Now, we wish to set up a sysfs file that
    can be read and written to. Internally, this is a "hook" or callback for us to
    query or set a `debug_level` global variable just as we did in the sample kernel
    module on procfs earlier!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们可以创建一个**读写**（**RW**），**只读**（**RO**）或**只写**（**WO**）的sysfs文件。现在，我们希望设置一个可以读取和写入的sysfs文件。在内部，这是一个“挂钩”或回调，用于查询或设置一个`debug_level`全局变量，就像我们之前在procfs的示例内核模块中所做的那样！
- en: Now that we have sufficient background, let's delve into the code!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了足够的背景知识，让我们深入了解代码！
- en: The code for implementing our sysfs file and its callbacks
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现我们的sysfs文件和它的回调的代码
- en: 'Let''s look at the relevant parts of the code for our simple *sysfs interfacing
    driver* and try things out, step by step:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们简单的*sysfs接口驱动程序*的相关部分的代码，并逐步尝试一些东西：
- en: 'Set up the device attribute structure (via the `DEVICE_ATTR_RW` macro; see
    the preceding section for more information) and create our first sysfs (pseudo)
    file:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置设备属性结构（通过`DEVICE_ATTR_RW`宏；有关更多信息，请参见前面的部分），并创建我们的第一个sysfs（伪）文件：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: From the definition of the macros shown here, we can infer that `static DEVICE_ATTR_RW(SYSFS_FILE1);` instantiates
    an initialized `device_attribute` structure with the name `llkdsysfs_debug_level`
    (as that's what the `SYSFS_FILE1` macro evaluates to) and a mode of `0644`; the
    read callback name will be `llkdsysfs_debug_level_show()` and the write callback
    name will be `llkdsysfs_debug_level_store()`!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里显示的宏的定义中，我们可以推断出`static DEVICE_ATTR_RW(SYSFS_FILE1);`实例化了一个初始化的`device_attribute`结构，名称为`llkdsysfs_debug_level`（因为这就是`SYSFS_FILE1`宏的评估结果），模式为`0644`；读回调名称将是`llkdsysfs_debug_level_show()`，写回调名称将是`llkdsysfs_debug_level_store()`！
- en: 'Here''s the relevant code for the read and write callbacks (again, we won''t
    show the entire code here). First, let''s look at the read callback:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是读取和写入回调的相关代码（同样，我们不会在这里显示整个代码）。首先，让我们看看读取回调：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How does this work? On reading our sysfs file, the preceding callback function
    is invoked. Within it, simply writing into the user-supplied buffer pointer, `buf`
    (its third parameter; we used the kernel `snprintf()` API to do so), has the effect
    of transferring the value provided *(*here, `debug_level`) to the user space!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？在读取我们的sysfs文件时，将调用前面的回调函数。在其中，简单地写入用户提供的缓冲指针`buf`（它的第三个参数；我们使用内核的`snprintf()`API来做到这一点），会将提供的值（这里是`debug_level`）传输到用户空间！
- en: 'Let''s build and `insmod(8)` the kernel module (for convenience, we will use
    our `lkm` wrapper script to do so):'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建并`insmod(8)`内核模块（为方便起见，我们将使用我们的`lkm`包装脚本来执行）：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s list and read the sysfs file pertaining to the debug-level:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们列出并读取与调试级别相关的sysfs文件：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This reflects the fact that debug-level is currently `0`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这反映了调试级别目前为`0`。
- en: 'Now, let''s peek at the code of our *write callback* for the debug-level sysfs
    file:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来看看我们的*写回调*的代码，用于调试级别的sysfs文件：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Again, it should be clear that the `kstrtoint()` kernel API is used to convert
    the user space `buf` string into an integer value, which we then validate. Also,
    the third parameter to `kstrtoint` is the integer to write to, thus updating it!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，应该清楚`kstrtoint()`内核API用于将用户空间的`buf`字符串转换为整数值，然后我们进行验证。此外，`kstrtoint`的第三个参数是要写入的整数，因此更新它！
- en: 'Now, let''s try updating the value of `debug_level` from its sysfs file:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试更新`debug_level`的值，从它的sysfs文件中：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Voila – it works!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 看，它有效了！
- en: 'As we did when we interfaced with procfs, we have provided more code in the
    sysfs code example. Here, we have another (read-only) sysfs interface to display
    the value of `PAGE_OFFSET`, plus a new one. Imagine that this driver''s job is
    to retrieve a "pressure" value (perhaps via an I2C-driven pressure sensor chip).
    Let''s imagine we have done so, and stored this pressure value in an integer global
    variable named `gpressure`. To "show" the user space the current pressure value,
    we must use a sysfs file. Here it is:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们在与procfs进行接口时所做的那样，我们在sysfs代码示例中提供了更多的代码。在这里，我们有另一个（只读）sysfs接口来显示`PAGE_OFFSET`的值，还有一个新的接口。想象一下，这个驱动程序的工作是获取一个“pressure”值（可能通过一个I2C驱动的压力传感器芯片）。让我们假设我们已经这样做了，并将这个压力值存储在一个名为`gpressure`的整数全局变量中。要向用户空间“显示”当前的压力值，我们必须使用一个sysfs文件。在这里：
- en: Internally, for the purpose of this demo, we have randomly set the `gpressure` global
    variable to a value of `25`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，为了这个演示的目的，我们已经随机将`gpressure`全局变量设置为值`25`。
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Look carefully at the output; why does the prompt appear immediately after `25`?
    Because we just printed the value as-is – no newline, nothing; that''s what is
    expected. The code that displays the "pressure" value is simple indeed:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看输出；为什么在`25`之后立即出现提示？因为我们只是打印了值本身 - 没有换行，什么都没有；这是预期的。显示“pressure”值的代码确实很简单：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With that, you've learned how to interface with the user space via sysfs! As
    usual, I urge you to actually write the code and try out these skills yourself;
    take a look at the *Questions* section at the end of this chapter and try out
    the (relevant) assignments yourself. Now, let's continue with sysfs, understanding
    an important *rule* regarding its ABI.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，你已经学会了如何通过sysfs与用户空间进行接口交互！像往常一样，我敦促你实际编写代码并尝试这些技能；看一下本章末尾的*问题*部分，自己尝试（相关的）任务。现在，让我们继续学习sysfs，了解一个关于其ABI的重要*规则*。
- en: The "one value per sysfs file" rule
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “一个sysfs文件对应一个值”的规则
- en: So far, you have understood how to create and make use of sysfs for user space
    kernel interfacing purposes, but there is a key point that we have been ignoring.
    There is a "rule" regarding using sysfs files, which states that you must only
    read or write exactly one value! Think of this as the *one-value-per-file* rule.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解了如何为用户空间内核接口目的创建和使用sysfs，但有一个关键点我们一直忽略。关于使用sysfs文件，有一个“规则”，规定你只能读取或写入一个值！把这看作是*一个值对应一个文件*的规则。
- en: So, as in the example where we used the "pressure" value, we merely return the
    current value of the pressure, nothing more. Thus, sysfs, unlike the other interfacing
    technologies, is not quite suited to those cases where you might want to return
    arbitrary long-winded information packets (say, the contents of the driver context
    structure) to the user space; in other words, it's not suited to pure "debugging"
    purposes.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，就像我们使用“压力”值的示例一样，我们只返回压力的当前值，没有其他内容。因此，与其他接口技术不同，sysfs并不适用于那些可能希望将任意冗长的信息包（比如驱动程序上下文结构的内容）返回给用户空间的情况；换句话说，它并不适用于纯粹的“调试”目的。
- en: 'The kernel documents and "rules" regarding the usage of sysfs can be found
    here: [https://www.kernel.org/doc/html/latest/admin-guide/sysfs-rules.html#rules-on-how-to-access-information-in-sysfs](https://www.kernel.org/doc/html/latest/admin-guide/sysfs-rules.html#rules-on-how-to-access-information-in-sysfs).'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 内核文档和关于sysfs使用的“规则”可以在这里找到：[https://www.kernel.org/doc/html/latest/admin-guide/sysfs-rules.html#rules-on-how-to-access-information-in-sysfs](https://www.kernel.org/doc/html/latest/admin-guide/sysfs-rules.html#rules-on-how-to-access-information-in-sysfs)。
- en: 'In addition, there is documentation on the sysfs API here: [https://www.kernel.org/doc/html/latest/filesystems/api-summary.html#the-filesystem-for-exporting-kernel-objects](https://www.kernel.org/doc/html/latest/filesystems/api-summary.html#the-filesystem-for-exporting-kernel-objects).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里有关于sysfs API的文档：[https://www.kernel.org/doc/html/latest/filesystems/api-summary.html#the-filesystem-for-exporting-kernel-objects](https://www.kernel.org/doc/html/latest/filesystems/api-summary.html#the-filesystem-for-exporting-kernel-objects)。
- en: 'The kernel typically provides several different means of creating sysfs objects;
    for example, with the `sysfs_create_files()` API, you can create multiple sysfs
    files in one go: `int __must_check sysfs_create_files(struct kobject *kobj, const
    struct attribute * const *attr);`. Here, you are expected to supply a pointer
    to a `kobject` and a pointer to a list of attribute structures.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 内核通常提供多种不同的方式来创建sysfs对象；例如，使用`sysfs_create_files()` API，你可以一次创建多个sysfs文件：`int
    __must_check sysfs_create_files(struct kobject *kobj, const struct attribute *
    const *attr);`。在这里，你需要提供一个指向`kobject`的指针和一个指向属性结构列表的指针。
- en: This concludes our discussion of sysfs as an interfacing technology; in summary,
    sysfs is indeed considered the *right way* for driver authors to display and/or
    set a particular driver value to and from the user space. Due to the "one value
    per sysfs file" convention, sysfs is really not ideally suited to debugging information
    dispensation. This neatly brings us to our next topic – debugfs!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们关于sysfs作为接口技术的讨论；总之，sysfs确实被认为是驱动程序作者向用户空间显示和/或设置特定驱动程序值的*正确方式*。由于“一个sysfs文件对应一个值”的约定，sysfs实际上并不理想地适用于调试信息的分发。这很好地引出了我们的下一个主题——debugfs！
- en: Interfacing via the debug filesystem (debugfs)
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过调试文件系统（debugfs）进行接口
- en: 'Imagine for a moment, the quandary faced by you, a driver developer, on Linux:
    you want to implement an easy yet elegant way to provide debug "hooks" from your
    driver to the user space. For example, the user simply performing a `cat(1)` on
    a (pseudo) file should result in your driver''s "debug callback" function being
    invoked. It will then proceed to dump some status information (perhaps a "driver
    context" structure) to the user mode process, which will faithfully dump it to
    stdout.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，作为Linux驱动程序开发人员，你面临的困境：你希望实现一种简单而优雅的方式，从你的驱动程序向用户空间提供调试“挂钩”。例如，用户只需在（伪）文件上执行`cat(1)`，就会导致你的驱动程序的“调试回调”函数被调用。然后它将继续向用户模式进程转储一些状态信息（也许是“驱动程序上下文”结构），用户模式进程将忠实地将其转储到标准输出。
- en: 'Okay, no problem: in the days before the 2.6 release, we could (as you learned
    in the *Interfacing via the proc filesystem (procfs)* section) happily use the
    procfs layer to interface our driver with the user space. Then, from 2.6 Linux
    onward, the kernel community vetoed this approach. We were told to strictly stop
    using procfs and instead use the sysfs layer as the means to interface our drivers
    with the user space. However, as we saw in the *Interfacing* *via the sys filesystem
    (sysfs)* section, it has a strict *one-value-per-file* rule. This is actually
    great for reporting or sending single values from and to the driver (typically,
    environment sensor values and similar), but quickly rules out all but the most
    trivial debug interfaces to the user space. We could use the ioctl approach (as
    we shall see) to set up a debug interface but it''s quite a bit harder to do so.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，没问题：在2.6版本发布之前的日子里，我们可以（就像你在*通过proc文件系统（procfs）进行接口*部分学到的那样）愉快地使用procfs层来将我们的驱动程序与用户空间进行接口。然后，从Linux
    2.6开始，内核社区否决了这种方法。我们被告知严格停止使用procfs，而是使用sysfs层作为我们的驱动程序与用户空间进行接口的手段。然而，正如我们在*通过sys文件系统（sysfs）进行接口*部分看到的那样，它有一个严格的*一个值对应一个文件*的规则。这对于从驱动程序发送和接收单个值（通常是环境传感器值等）非常适用，但很快就排除了除了最简单的调试接口以外的所有情况。我们可以使用ioctl方法（正如我们将看到的）来设置一个调试接口，但这样做要困难得多。
- en: So, what can you do? Luckily, there is an elegant solution in place from around
    2.6.12 Linux onward called debugfs. The "debug filesystem" is very easy to use
    and quite explicit in communicating the fact that driver authors (anyone, in fact)
    can use it for whatever purpose they choose! There is no one-value-per-file rule –
    forget that, there are no rules.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你能做什么呢？幸运的是，从大约2.6.12版的Linux开始，就有了一个优雅的解决方案，称为debugfs。这个“调试文件系统”非常容易使用，并且在传达驱动程序作者（实际上是任何人）可以用它来做任何他们选择的目的时非常明确！没有一个文件规则
    - 忘记那个，没有规则。
- en: Of course, just as with the other filesystem-based approaches we have dealt
    with – procfs, sysfs, and now debugfs – the kernel community clearly claims that
    all these interfaces are an ABI, and thus, that their stability and lifespan is
    something that is *not *guaranteed. While that is the formal stance that's adopted,
    the reality is that these interfaces have become de facto ones in the real world;
    stripping them out without preamble one fine day wouldn't really serve anybody.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，就像我们处理的其他基于文件系统的方法一样 - procfs，sysfs和现在的debugfs - 内核社区明确声称所有这些接口都是ABI，因此它们的稳定性和寿命是*不*被保证的。虽然这是正式采取的立场，但现实是这些接口已经成为现实世界中的事实标准；毫无征兆地将它们剥离出去真的不会为任何人服务。
- en: 'The following screenshot shows the content of debugfs on our x86-64 Ubuntu
    18.04.3 LTS guest (running the "custom" 5.4.0 kernel we built back in our companion
    book *Linux Kernel Programmin*g, *Chapter 3*, *Building the 5.0 Linux kernel from
    Source, Part 2*!):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的x86-64 Ubuntu 18.04.3 LTS客户机上debugfs的内容（运行我们在伴随书籍*Linux Kernel Programming*，*第3章*，*从源代码构建5.0
    Linux内核，第2部分*中构建的"custom" 5.4.0内核）：
- en: '![](img/d01e778c-ea1a-4934-8283-30d35557238d.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d01e778c-ea1a-4934-8283-30d35557238d.png)'
- en: Figure 2.3 – Screenshot revealing the content of the debugfs filesystem on an
    x86_64 Linux VM
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 - 展示了x86_64 Linux VM上debugfs文件系统内容的截图
- en: As with procfs and sysfs, due to debugfs being a kernel feature (it's a virtual
    filesystem, after all!), the precise content within it is highly dependent on
    the kernel version and CPU architecture. As we mentioned previously, by looking
    at this screenshot, it should now be obvious that there are plenty of real-world
    "users" of debugfs.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与procfs和sysfs一样，由于debugfs是一个内核特性（毕竟它是一个虚拟文件系统！），它内部的内容非常依赖于内核版本和CPU架构。正如我们之前提到的，通过查看这个截图，现在应该很明显，debugfs有很多真实世界的“用户”。
- en: Checking for the presence of debugfs
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查debugfs的存在
- en: 'First off, in order to make use of the powerful *debugfs* interface, it must
    be enabled within the kernel config. The relevant Kconfig macro is `CONFIG_DEBUG_FS`.
    Let''s check whether it''s enabled on our 5.4 custom kernel:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了利用强大的*debugfs*接口，它必须在内核配置中启用。相关的Kconfig宏是`CONFIG_DEBUG_FS`。让我们检查一下我们的5.4自定义内核上是否启用了它：
- en: Here, we are assuming you have the `CONFIG_IKCONFIG` and `CONFIG_IKCONFIG_PROC`
    options set to `y`, thus allowing us to use the `/proc/config.gz` pseudo file
    to access the current kernel's configuration.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设您已经将`CONFIG_IKCONFIG`和`CONFIG_IKCONFIG_PROC`选项设置为`y`，因此允许我们使用`/proc/config.gz`伪文件来访问当前内核的配置。
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Indeed it is; it's typically enabled by default in distributions.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 的确如此；它通常在发行版中默认启用。
- en: 'Next, the default mount point of debugfs is `/sys/kernel/debug`. Thus, we can
    see that it is internally dependent on the sysfs kernel feature being present
    and mounted, which it is by default. Let''s check where debugfs is mounted on
    our Ubuntu 18.04 x86_64 VM:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，debugfs的默认挂载点是`/sys/kernel/debug`。因此，我们可以看到它在内部依赖于sysfs内核特性的存在和默认挂载，这是默认情况下的。让我们来检查一下在我们的Ubuntu
    18.04 x86_64 VM上debugfs被挂载在哪里：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It is available and mounted at the expected location; that is, `/sys/kernel/debug`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 它可用并且挂载在预期的位置；也就是说，`/sys/kernel/debug`。
- en: 'Of course, it''s always a best practice to never assume that this will always
    be the location where it''s mounted; in your script or user mode C program, take
    the trouble to check and verify it. In fact, allow me to rephrase this: *it''s
    always a good practice to never assume anything; making assumptions is a really
    good source of bugs*.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最好的做法是永远不要假设这将永远是它被挂载的位置；在您的脚本或用户模式C程序中，要费心去检查和验证它。事实上，让我重新表达一下：*永远不要假设任何事情是一个很好的做法；做假设是错误的一个很好的来源*。
- en: By the way, an interesting Linux feature is that filesystems can be mounted
    in different, even multiple, locations; also, some folks prefer to create a symbolic
    link to `/sys/kernel/debug` as `/debug`; it's up to you, really.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，一个有趣的Linux特性是文件系统可以被挂载在不同的，甚至多个位置；此外，一些人更喜欢创建一个符号链接到`/sys/kernel/debug`作为`/debug`；这取决于你，真的。
- en: As usual, our intention here is to create our (pseudo) files under the debugfs
    umbrella, and then register and make use of the read/write callbacks from them,
    for the purpose of interfacing our driver with the user space. To do so, we need
    to understand the basic usage of the debugfs API. We will point you to the documentation
    for this in the next section.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们的意图是在debugfs的保护下创建我们的（伪）文件，然后注册并利用它们的读/写回调，以便将我们的驱动程序与用户空间进行接口。为此，我们需要了解debugfs
    API的基本用法。我们将在下一节中为您指向这方面的文档。
- en: Looking up the debugfs API documentation
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找debugfs API文档
- en: 'The kernel supplies succinct and superb documentation on using the debugfs
    API (courtesy of Jonathan Corbet, LWN) here: [https://www.kernel.org/doc/Documentation/filesystems/debugfs.txt](https://www.kernel.org/doc/Documentation/filesystems/debugfs.txt)
    (of course, you can also look it up directly within the kernel codebase).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 内核提供了关于使用debugfs API的简明而出色的文档（由Jonathan Corbet, LWN提供）：[https://www.kernel.org/doc/Documentation/filesystems/debugfs.txt](https://www.kernel.org/doc/Documentation/filesystems/debugfs.txt)（当然，您也可以直接在内核代码库中查找）。
- en: 'I urge you to refer to this document to learn how to use the debugfs APIs,
    since it''s easy to read and understand; this way, you can avoid unnecessarily
    repeating the same information here. In addition to the aforementioned document,
    the modern kernel documentation system (the "Sphinx"-based one) also provides
    quite detailed debugfs API pages: [https://www.kernel.org/doc/html/latest/filesystems/api-summary.html?highlight=debugfs#the-debugfs-filesystem](https://www.kernel.org/doc/html/latest/filesystems/api-summary.html?highlight=debugfs#the-debugfs-filesystem).'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您参考这份文档，学习如何使用debugfs API，因为它易于阅读和理解；这样，您就可以避免在这里不必要地重复相同的信息。除了前面提到的文档之外，现代内核文档系统（基于“Sphinx”）还提供了相当详细的debugfs
    API页面：[https://www.kernel.org/doc/html/latest/filesystems/api-summary.html?highlight=debugfs#the-debugfs-filesystem](https://www.kernel.org/doc/html/latest/filesystems/api-summary.html?highlight=debugfs#the-debugfs-filesystem)。
- en: Note that all debugfs APIs are exported as GPL-only to kernel modules (thus
    necessitating the module being released under the "GPL" license (this can be dual
    licensed, but one must be "GPL")).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有debugfs API都只向内核模块公开为GPL（因此需要模块在“GPL”许可下发布（这可以是双重许可，但必须是“GPL”））。
- en: An interfacing example with debugfs
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与debugfs的接口示例
- en: Debugfs, being deliberately designed with a "no particular rules" mindset, makes
    it the ideal interface to use *for debug purposes*. Why? It allows you to construct
    any arbitrary byte stream and send it off to the user space, including a binary
    "blob" with the `debugfs_create_blob()` API.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Debugfs被故意设计为“没有特定规则”的思维方式，使其成为用于调试目的的理想接口。为什么？它允许您构造任意的字节流并将其发送到用户空间，包括使用`debugfs_create_blob()`API发送二进制“blob”。
- en: 'Our previous example kernel modules with procfs and sysfs constructed and used
    three to four (pseudo) files. For a quick demo with debugfs, we shall just stick
    to two "files":'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的示例内核模块使用procfs和sysfs构建和使用了三到四个（伪）文件。为了快速演示debugfs，我们将只使用两个“文件”：
- en: '`llkd_dbgfs_show_drvctx`: As you''ll have no doubt guessed, when read, it will
    cause the current content of our (by now familiar) "driver context" data structure
    to be dumped to the console; we shall ensure the pseudo file''s mode is read-only
    (by root).'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llkd_dbgfs_show_drvctx`：正如您无疑猜到的那样，当读取时，它将导致我们（现在熟悉的）“驱动程序上下文”数据结构的当前内容被转储到控制台；我们将确保伪文件的模式是只读的（由root）。'
- en: '`llkd_dbgfs_debug_level`: This file''s mode shall be read-write (by root only);
    when read, it will display the current value of `debug_level`; when an integer
    is written to it, we shall update the value of `debug_level` within the kernel
    module to the value passed.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`llkd_dbgfs_debug_level`：这个文件的模式将是读写（仅由root）；当读取时，它将显示`debug_level`的当前值；当写入一个整数时，我们将更新内核模块中的`debug_level`的值为传递的值。'
- en: 'Here, in the init code of our kernel module, we will first create a directory
    under `debugfs`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的内核模块的初始化代码中，我们将首先在`debugfs`下创建一个目录：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now that we have a starting point – a directory – let's move on and create the
    debugfs (pseudo) files under it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个起点——一个目录——让我们继续创建它下面的debugfs（伪）文件。
- en: Creating and using the first debugfs file
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和使用第一个debugfs文件
- en: For readability and to save space, we won't show the error handling code sections
    here.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可读性和节省空间，我们不会在这里展示错误处理代码部分。
- en: Just as in the example with procfs, we must allocate and initialize an instance
    of our "driver context" data structure (we haven't shown the code here as it's
    repetitive, so please refer to the GitHub source).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在procfs的示例中一样，我们必须分配和初始化我们的“驱动程序上下文”数据结构的一个实例（我们没有在这里展示代码，因为它是重复的，请参考GitHub源代码）。
- en: 'Then, via the generic `debugfs_create_file()` API, we must create a `debugfs` file,
    associating it with a `file_operations` structure. This, in effects, gets just
    a read callback registered:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过通用的`debugfs_create_file()`API，我们必须创建一个`debugfs`文件，并将其与一个`file_operations`结构相关联。这实际上只是注册了一个读回调：
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: From 5.8 Linux onward (recall that we're working with the 5.4 LTS kernel), the
    return value of several of the debugfs creation APIs have been removed (they will
    return `void`); Greg Kroah-Hartman's patch mentions that this was done as no one
    was using them. This is quite typical of Linux – unneeded features are stripped
    off, and kernel evolution continues...
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从Linux 5.8开始（请回忆我们正在使用5.4 LTS内核），一些debugfs创建API的返回值已被移除（它们将返回`void`）；Greg Kroah-Hartman的补丁提到这样做是因为没有人在使用它们。这在Linux中非常典型——不需要的功能被剥离，内核继续演进……
- en: 'Clearly, the "read" callback is our `dbgfs_show_drvctx()` function. As a reminder,
    this function gets auto-invoked by the debugfs layer whenever the `debugfs` file
    (`llkd_dbgfs_show_drvctx`) is read; here''s the code for our debugfs read callback
    function:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，“读”回调是我们的`dbgfs_show_drvctx()`函数。作为提醒，每当读取`debugfs`文件（`llkd_dbgfs_show_drvctx`）时，这个函数会被debugfs层自动调用；这是我们的debugfs读回调函数的代码：
- en: '[PRE43]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Notice how we retrieve the "data" pointer (our driver context structure) by
    dereferencing the debugfs files' inode member, which is called `i_private`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过解引用debugfs文件的inode成员`i_private`来检索“data”指针（我们的驱动程序上下文结构）。
- en: As we mentioned in [Chapter 1](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml),
    *Writing a Simple misc Character Device Driver*, using the `data` pointer to dereference
    the driver context structure from the file's inode is one of a number of similar,
    common techniques employed by driver authors to avoid the use of globals. Here,
    `gdrvctx` *is* a global, so it's a moot point; we are simply using it to demonstrate
    the typical use case.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml)中提到的，*编写一个简单的杂项字符设备驱动程序*，使用`data`指针从文件的inode中解引用驱动程序上下文结构是驱动程序作者为避免使用全局变量而采用的一种类似的常见技术之一。在这里，`gdrvctx`
    *是*一个全局变量，所以这是一个无关紧要的问题；我们只是用它来演示典型的用例。
- en: Using the `snprintf()` API, we can populate a local buffer with the current
    content of our driver's "context" structure, and then, via the `simple_read_from_buffer()`
    API, pass it up to the user space app that issued the read, which typically causes
    it to be displayed on the Terminal/console window. This `simple_read_from_buffer()`
    API is a wrapper over `copy_to_user()`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`snprintf()`API，我们可以用当前驱动程序“上下文”结构的内容填充一个本地缓冲区，然后通过`simple_read_from_buffer()`API将其传递给发出读取的用户空间应用程序，通常会导致它显示在终端/控制台窗口上。这`simple_read_from_buffer()`API是`copy_to_user()`的一个包装器。
- en: 'Let''s give it a spin:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '[PRE44]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As we can see, the two debugfs files are created as expected; let''s verify
    this (be careful here; you can only look into debugfs as *root*):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，两个debugfs文件都如预期地创建了；让我们验证一下（这里要小心；你只能以*root*身份查看debugfs）：
- en: '[PRE45]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The pseudo files have been created and have the correct permissions. Now, let''s
    read (as root user) from the `llkd_dbgfs_show_drvctx` file:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 伪文件已创建并具有正确的权限。现在，让我们从`llkd_dbgfs_show_drvctx`文件中读取（作为root用户）：
- en: '[PRE46]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It works; performing the read again a few seconds later. Notice how the value
    of `config3` has changed. Why? Recall that we set it to the `jiffies` value –
    the number of timer "ticks"/interrupts – that have occurred since system boot:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效；几秒钟后再次进行读取。注意`config3`的值已经发生了变化。为什么？记得我们将它设置为`jiffies`值 - 自系统启动以来发生的定时器“滴答”/中断的数量：
- en: '[PRE47]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Having created and used our first debugfs file, let's understand the second
    debugfs file.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并使用了第一个debugfs文件后，让我们了解第二个debugfs文件。
- en: Creating and using the second debugfs file
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建和使用第二个debugfs文件
- en: 'Let''s move on to the second debugfs file. We will create it using an interesting
    shortcut helper debugfs API named `debugfs_create_u32()`. This API *automatically*
    sets up internal callbacks, allowing you to read/write upon the specified unsigned
    32-bit global variable within the driver. The main advantage of this "helper"
    routine is that you don''t need to explicitly provide a `file_operations` structure
    or even any callback routines. The debugfs layer "understands" and internally
    sets things up so that reading or writing the numeric (global) variable will always
    just work! Take a look at the following code in the *init* codepath, which creates
    and sets up our second debugfs file:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行第二个debugfs文件。我们将使用一个有趣的快捷辅助debugfs API，名为`debugfs_create_u32()`来创建它。这个API*自动*设置内部回调，允许你在驱动程序中指定的无符号32位全局变量上进行读/写。这个“辅助”例程的主要优势在于，你不需要显式提供`file_operations`结构，甚至任何回调例程。debugfs层“理解”并在内部设置事情，以便读取或写入数字（全局）变量总是有效的！看一下*init*代码路径中的以下代码，它创建并设置了我们的第二个debugfs文件：
- en: '[PRE48]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'It''s as simple as that! Now, reading this file will produce the current value
    of `debug_level`; writing to it will set it to the value written. Let''s do this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单！现在，读取这个文件将产生`debug_level`的当前值；写入它将把它设置为写入的值。让我们来做这个：
- en: '[PRE49]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This works, but there is a downside to this "shortcut" approach: since this
    is all done internally, there is no way for us to *validate* the value being written.
    Thus, here, we wrote the value `5` to `debug_level`; it worked, but it''s an invalid
    value (at least let''s assume that''s the case)! So, how can this be corrected?
    Simple: do not use this helper method; instead, do it the "usual" way via the
    generic `debugfs_create_file()` API (as we did for the first debugfs file). The
    advantage here is that as we set up explicit callback routines for read and write,
    by specifying them within a fops structure, we have control over the value being
    written (I leave doing this to you, as an exercise). Like life, it''s a trade-off;
    you win some, you lose some.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是有效的，但这种“捷径”方法也有一个缺点：由于这一切都是在内部完成的，我们无法*验证*被写入的值。因此，在这里，我们将值`5`写入了`debug_level`；它有效，但是这是一个无效值（至少让我们假设是这样）！那么，如何纠正这个问题呢？简单：不要使用这种辅助方法；而是通过通用的`debugfs_create_file()`API以“通常”的方式进行操作（就像我们为第一个debugfs文件所做的那样）。这里的优势在于，我们为读和写设置了显式的回调例程，通过在fops结构中指定它们，我们可以控制被写入的值（我把这个任务留给你作为练习）。就像生活一样，这是一个权衡；有得有失。
- en: Helper debugfs APIs for working on numeric globals
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于处理数字全局变量的辅助debugfs API
- en: You have just learned how to use the `debugfs_create_u32()` helper API to set
    up a debugfs file to read/write an unsigned 32-bit integer global. The fact is,
    the debugfs layer provides a bunch of similar "helper" APIs to implicitly read/write
    on numeric (integer) global variables within your module.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学会了如何使用`debugfs_create_u32()`辅助API来设置一个debugfs文件，以读/写一个无符号32位整数全局变量。事实上，debugfs层提供了一堆类似的“辅助”API，用于隐式读/写模块内的数字（整数）全局变量。
- en: 'The helper routines for creating debugfs entries that can read/write different
    bit size unsigned integer (8-, 16-, 32-, and 64-bit) globals follow. The last
    parameter is the key one – the address of the global integer within the kernel/module:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建可以读/写不同位大小的无符号整数（8位、16位、32位和64位）全局变量的debugfs条目的辅助例程如下。最后一个参数是关键的 - 内核/模块中全局整数的地址：
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The preceding APIs work with decimal base; to make using *hexadecimal base*
    easy, we have the following helpers:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的API使用十进制基数；为了方便使用*十六进制基数*，我们有以下辅助程序：
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As an aside, the kernel also provides a helper API for those cases where the
    precise *size* of the variable varies; hence, using the `debugfs_create_size_t()`
    helper creates a debugfs file appropriate for a variable of size `size_t`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，内核还为那些变量大小不确定的情况提供了一个辅助API；因此，使用`debugfs_create_size_t()`辅助程序创建一个适用于`size_t`大小变量的debugfs文件。
- en: For drivers that merely need to peek at a numeric global, or update it without
    any worry about invalid values, these debugfs helper APIs are very useful and
    are indeed commonly used by several drivers in the mainline kernel (we will look
    at an example within the MMC driver shortly). To evade the "validity check" issue,
    often, we can arrange for the *user space* application (or script) to perform
    validity checking; in fact, this is typically the "right way" to do things.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些只需要查看数字全局变量的驱动程序，或者在不担心无效值的情况下更新它的驱动程序，这些debugfs辅助API非常有用，实际上在主线内核中被几个驱动程序常用（我们很快将在MMC驱动程序中看到一个例子）。为了规避“有效性检查”问题，通常我们可以安排*用户空间*应用程序（或脚本）执行有效性检查；事实上，这通常是做事情的“正确方式”。
- en: 'The UNIX paradigm has a saying: *provide mechanism, not policy.*'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX范例有一句话：*提供机制，而不是策略*。
- en: 'When working with globals that are of the *boolean* type, debugfs provides
    the following helper API:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用*boolean*类型的全局变量时，debugfs提供以下辅助API：
- en: '[PRE52]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Reading from the "file" will result in only `Y` or `N` (suffixed with a newline)
    being returned; obviously, `Y` if the current value of the fourth `value` parameter
    is non-zero, and `N` otherwise. When writing, you can write `Y` or `N` or `1`
    or `0`; other values will not be accepted.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 从“文件”中读取将只返回`Y`或`N`（后面跟着一个换行符）；显然，如果第四个`value`参数的当前值非零，则返回`Y`，否则返回`N`。在写入时，可以写入`Y`或`N`或`1`或`0`；其他值将不被接受。
- en: 'Think about it: you can control your "robot" device via your robot device driver
    by writing `1` to a boolean variable called, say, `power` to turn it on, and use `0`
    to turn it off! The possibilities are endless.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看：你可以通过写入`1`到一个名为`power`的布尔变量来通过你的“机器人”设备控制你的“机器人”设备驱动程序，以打开它，并使用`0`来关闭它！可能性是无穷无尽的。
- en: The kernel documentation on debugfs provides a few more miscellaneous APIs;
    I leave it to you to have a look. Now that we've covered how to create and use
    our demo debugfs pseudo files, let's learn how to remove them.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: debugfs的内核文档提供了一些其他杂项API；我留给你去看一看。现在我们已经介绍了如何创建和使用我们的演示debugfs伪文件，让我们学习如何删除它们。
- en: Removing the debugfs pseudo file(s)
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除debugfs伪文件(s)
- en: 'When a module is removed (via, say, `rmmod(8)`), we must delete our debugfs
    files. The older way to do this was via the `debugfs_remove()` API, where each
    debugfs file had to be individually removed with it (painful, to say the least).
    The modern approach makes this really simple:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当模块被移除（比如通过`rmmod(8)`），我们必须删除我们的debugfs文件。以前的做法是通过`debugfs_remove()` API，每个debugfs文件都必须单独删除（至少可以说是痛苦的）。现代方法使这变得非常简单：
- en: '[PRE53]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Pass the pointer to the overall "parent" directory (the one we created first),
    and the entire branch is recursively removed; perfect.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 传递指向整个“父”目录的指针（我们首先创建的那个），整个分支将被递归地删除；完美。
- en: 'Not deleting your debugfs files at this point, thus leaving them there on the
    filesystem in an orphaned state, is asking for trouble! Just think about this:
    what will happen when someone (attempts to) reads or writes to any of them later?
    **A kernel bug, or an *Oops***, that''s what.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上不删除你的debugfs文件，因此将它们留在文件系统中处于孤立状态，这是在自找麻烦！想想看：当有人（试图）以后读取或写入它们时会发生什么？**一个内核bug，或者一个*Oops***，就是这样。
- en: Seeing a kernel bug – an Oops!
  id: totrans-308
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 看到一个内核bug - 一个Oops！
- en: Let's make it happen – a kernel bug! Exciting, yes!?
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让它发生 - 一个内核bug！激动人心，是吧！？
- en: Okay, to create a kernel bug, we must ensure that when we remove (unload) the
    kernel module, the API that cleans up (deletes) all the debugfs files, `debugfs_remove_recursive()`,
    is *not *invoked. Thus, after each module is removed, our debugfs directory and
    files seem to be present! However, if you try and operate on – read/write – any
    of them, they'll be in an *orphaned state* and, hence, upon trying to dereference
    its metadata, the internal debugfs code paths will perform an invalid memory reference,
    resulting in a (kernel-level) bug.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，要创建一个内核bug，我们必须确保当我们移除（卸载）内核模块时，清理（删除）所有debugfs文件的API，`debugfs_remove_recursive()`，*不*被调用。因此，每次移除模块后，我们的debugfs目录和文件似乎仍然存在！但是，如果你尝试对它们中的任何一个进行操作
    - 读/写 - 它们将处于*孤立状态*，因此，在尝试取消引用其元数据时，内部debugfs代码路径将执行无效的内存引用，导致（内核级）bug。
- en: In the kernel space, a bug is a very serious thing indeed; in theory, it should
    never, ever happen! This is called an *Oops;* as part of handling this, an internal
    kernel function is called, which dumps useful diagnostic information via `printk` to
    the in-memory kernel log buffer, as well as to the console device (on production
    systems, it might also be directed elsewhere so that it can be retrieved and investigated
    at a later date; for example, via the kernel's *kdump* mechanism).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核空间中，bug确实是一件非常严重的事情；理论上，它永远不应该发生！这就是所谓的*Oops*；作为处理这个问题的一部分，将调用一个内部内核函数，通过`printk`将有用的诊断信息转储到内存中的内核日志缓冲区，以及控制台设备（在生产系统上，它也可能被定向到其他地方，以便以后可以检索和调查；例如，通过内核的*kdump*机制）。
- en: 'Let''s introduce a module parameter that controls whether we (quite deliberately)
    cause an *Oops* to occur or not:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们引入一个模块参数，控制我们是否（故意）导致*Oops*发生或不发生：
- en: '[PRE54]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the cleanup code path of our driver, we check if the `cause_an_oops` variable
    is non-zero and deliberately do *not* (recursively) delete our debugfs file(s),
    hence setting up the bug:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的驱动程序的清理代码路径中，我们检查`cause_an_oops`变量是否非零，并故意*不*（递归地）删除我们的debugfs文件，从而设置bug：
- en: '[PRE55]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'When we "normally" use `insmod(8)`, the scary `cause_an_oops` module parameter
    is `0` by default, thus ensuring that everything works well. But let''s get adventurous!
    We are building the kernel module and when we insert it, we must pass the parameter
    while setting it to `1` (notice that here, we''re running as *root* on our x86_64
    Ubuntu 18.04 LTS guest system on our custom `5.4.0-llkd01` kernel):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们“正常”使用`insmod(8)`时，默认情况下，可怕的`cause_an_oops`模块参数为`0`，从而确保一切正常工作。但让我们冒险一下！我们正在构建内核模块，当我们插入它时，我们必须传递参数并将其设置为`1`（请注意，这里我们在我们的自定义`5.4.0-llkd01`内核上的x86_64
    Ubuntu 18.04 LTS客户系统上以*root*身份运行）：
- en: '[PRE56]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let''s remove the kernel module – internally, the code that''s used to
    clean up (recursively delete) our debugfs file would not have run. Here, we are
    actually triggering the kernel bug, the *Oops,* by attempting to read one of our
    debugfs files:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们移除内核模块 - 在内部，用于清理（递归删除）我们的debugfs文件的代码不会运行。在这里，我们实际上是通过尝试读取我们的debugfs文件来触发内核bug，*Oops*：
- en: '[PRE57]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `Killed` message on the console is ominous! This is a clue that something
    has gone (dramatically) wrong. Viewing the kernel log confirms that we indeed
    got an *Oops!* The following (partially cropped) screenshot shows this:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台上的`Killed`消息是不祥的！这是一个暗示，表明出了（严重的）问题。查看内核日志确认我们确实遇到了*Oops*！以下（部分裁剪的）屏幕截图显示了这一点：
- en: '![](img/1b9849ec-98d3-4fa8-a772-87b4d6fa656b.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b9849ec-98d3-4fa8-a772-87b4d6fa656b.png)'
- en: Figure 2.4 – A partial screenshot of a kernel Oops, a kernel-level bug
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 - 内核Oops的部分屏幕截图，内核级bug
- en: 'Since provided kernel debugging details is beyond the scope of this book, we
    will not delve into the details here. Nevertheless, figuring out a little bit
    is quite intuitive. Look carefully at the preceding screenshot: in the `BUG:`
    statement, you can see the **kernel virtual address** (**kva**) whose lookup caused
    the bug, known as the Oops (we covered the kva space in the companion guide, *Linux
    Kernel Programming – Chapter 7, Memory Management Internals Essentials*; this
    is really key information for driver authors):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 由于提供的内核调试详细信息超出了本书的范围，我们将不在此深入讨论。尽管如此，了解一点是相当直观的。仔细看前面的屏幕截图：在`BUG:`语句中，您可以看到导致bug的**内核虚拟地址**（**kva**），称为Oops（我们在配套指南*Linux内核编程-第7章，内存管理内部基础知识*中介绍了kva空间；这对于驱动程序作者来说是非常关键的信息）：
- en: '[PRE58]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This shows the CPU (`1`) that the process context (`cat`) was running on, the
    tainted flags, and the kernel version. One of the really key pieces of output
    is as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了CPU（`1`）上正在运行的进程上下文（`cat`），被污染的标志和内核版本。输出中真正关键的一部分是：
- en: '[PRE59]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This tells you that the CPU instruction pointer (the register named RIP on the
    x86_64) was in the `debugfs_u32_get()` function at an offset of `0x5` bytes from
    the start of the machine code of the function (furthermore, the kernel figures
    out that the length of the function is `0x20` bytes)!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你CPU指令指针（x86_64上名为RIP的寄存器）在`debugfs_u32_get()`函数中，距离函数的机器码开始处的偏移量为`0x5`字节（此外，内核还计算出函数的长度为`0x20`字节）！
- en: Combining this information with powerful tools such as `objdump(1)` and `addr2line(1)`
    can help to literally pinpoint the location of the bug in code!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些信息与`objdump(1)`和`addr2line(1)`等强大工具结合使用，可以帮助准确定位代码中的bug的位置！
- en: 'The CPU registers are dumped; even better, the *call trace *or the *call stack*
    – the *content of the kernel mode stack* of the process context (please refer
    to *Linux Kernel Programming*, in *Chapter 6*, *Kernel Internals Essentials, Processes
    and Threads,* for details on the kernel stack) – shows you the code that led up
    to this point; that is, the crash (read the stack trace bottom-up). Another quick
    tip: if a kernel function in the call trace''s output is preceded by a `?` symbol,
    just ignore it (it''s perhaps a previous "blip" that was left behind).'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: CPU寄存器被转储；更好的是，*调用跟踪*或*调用堆栈* - 进程上下文的*内核模式堆栈的内容*（请参阅*Linux内核编程*，*第6章*，*内核内部基础知识，进程和线程*，了解有关内核堆栈的详细信息）-
    显示了导致此时刻的代码；也就是说，崩溃（从下到上读取堆栈跟踪）。另一个快速提示：如果调用跟踪输出中的内核函数前面有一个`?`符号，只需忽略它（这可能是之前留下的“闪烁”）。
- en: Realistically, a kernel bug on a production system *must* cause the entire system
    to panic (halt). On non-production systems (like what we're running on), a kernel
    panic may or may not occur; here, it doesn't. Nevertheless, a kernel bug must
    be treated with the highest level of severity, it's indeed a show-stopper and
    must be fixed. The procfs file, `/proc/sys/kernel/panic_on_oops`, is set to `0`
    by most distros, but on production systems, it will typically be set to the value `1`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，生产系统上的内核bug *必须* 导致整个系统恐慌（停机）。在非生产系统上（就像我们正在运行的那样），可能会发生内核恐慌，也可能不会；在这里，没有。尽管如此，内核bug必须以最高级别的严重性对待，它确实是一个停机故障，必须修复。大多数发行版将procfs文件`/proc/sys/kernel/panic_on_oops`设置为`0`，但在生产系统上，它通常会设置为值`1`。
- en: 'The moral here is clear: there is no auto cleanup being performed by debugfs;
    we have to do it. Right, let''s wrap up this discussion on debugfs by looking
    up some actual real-world usage within the kernel.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的道义很明显：debugfs没有自动清理；我们必须自己清理。好了，让我们通过查找内核中的一些实际使用情况来结束对debugfs的讨论。
- en: Debugfs – actual users
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Debugfs - 实际用户
- en: 'As we mentioned previously, there are several "real-world" users of the debugfs
    API; can we spot some of them? Well, here''s one way: simply search under the
    kernel source tree''s `drivers/` directory for files named `*debugfs*.c`; you
    might be surprised (I found 114 such files in the 5.4.0 kernel tree!). Let''s
    take a look at a few:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，debugfs API有几个“真实世界”的用户；我们能找到其中一些吗？好吧，有一种方法：只需在内核源树的`drivers/`目录下搜索名为`*debugfs*.c`的文件；您可能会感到惊讶（我在5.4.0内核树中找到了114个这样的文件！）。让我们看看其中的一些：
- en: '[PRE60]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Have a look at (some of) them; their code exposes debugfs interfaces. This
    is not always done for mere debug purposes; many of the debugfs files are for
    actual production usage! As an example, the MMC driver contains the following
    line of code, which makes use of the debugfs "helper" API to get an x32 global:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 看看（其中一些）它们；它们的代码公开了debugfs接口。这并不总是为了纯粹的调试目的；许多debugfs文件用于实际生产用途！例如，MMC驱动程序包含以下代码行，该代码行使用debugfs“辅助”API获取x32全局变量：
- en: '[PRE61]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This creates a debugfs file called `state` that, when read, displays the "state"
    of the card.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`state`的debugfs文件，当读取时，会显示卡的“状态”。
- en: Okay, this completes our coverage of how to interface with the user space via
    the powerful debugfs framework. Our demo debugfs driver created a debugfs directory
    and two debugfs pseudo files within it; you then learned how to set up and use
    both read and write callback handlers for them. The "shortcut" APIs (such as `debugfs_create_u32()`
    and friends) are powerful too. Not only that, but we even managed to generate
    a kernel bug – an Oops! Now, let's learn how to communicate over a special type
    of socket, known as a netlink socket.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这完成了我们如何通过强大的debugfs框架与用户空间进行接口的覆盖。我们的演示debugfs驱动程序创建了一个debugfs目录和其中的两个debugfs伪文件；然后您学会了如何为它们设置和使用读取和写入回调处理程序。像`debugfs_create_u32()`这样的“快捷”API也很强大。不仅如此，我们甚至设法生成了一个内核错误
    - 一个Oops！现在，让我们学习如何通过一种特殊类型的套接字进行通信，称为netlink套接字。
- en: Interfacing via netlink sockets
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过netlink套接字进行接口
- en: Here, you'll learn to interface kernel and user spaces with a familiar and indeed
    ubiquitous network abstraction – sockets! Programmers familiar with network application
    programming swear by its advantages.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将学习如何使用一个熟悉且无处不在的网络抽象 - 套接字，来进行内核和用户空间的接口！熟悉网络应用程序编程的程序员对其优势赞不绝口。
- en: Familiarity with network programming in C/C++ with socket APIs helps here. Do
    see the *Further reading* section for a couple of good tutorials on this topic.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉使用C/C++和套接字API的网络编程在这里有所帮助。请参阅*进一步阅读*部分，了解有关此主题的一些好教程。
- en: Advantages using sockets
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用套接字的优势
- en: 'Among others, socket technology provides us with several advantages (over other
    typical user mode IPC mechanisms such as pipes, SysV IPC/POSIX IPC mechanisms
    (message queues, shared memory, semaphores, and so on)), as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 除其他外，套接字技术为我们提供了几个优势（相对于其他典型的用户模式IPC机制，如管道，SysV IPC/POSIX IPC机制（消息队列，共享内存，信号量等）），如下：
- en: Bidirectional simultaneous data transfer (full duplex).
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向同时数据传输（全双工）。
- en: Lossless on the internet, with at least with some transport layer protocols,
    such as TCP, and of course, on the localhost, which is the case here.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在互联网上是无损的，至少在某些传输层协议（如TCP）上，当然，在本地主机上也是如此，这在这里是适用的。
- en: High-speed data transfer, especially on localhost!
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高速数据传输，尤其是在本地主机上！
- en: Flow control semantics are always in effect.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量控制语义始终有效。
- en: Asynchronous communication; messages can be queued, so the sender does not have
    to wait for the receiver.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步通信；消息可以排队，因此发送方不必等待接收方。
- en: Especially with respect to our topic, in other user<->kernel communication paths
    (such as procfs, sysfs, debugfs, and ioctl), the user space app must initiate
    the transfer to the kernel space; with netlink sockets, *the kernel can initiate
    a transfer.*
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别是关于我们的主题，在其他用户<->内核通信路径（如procfs，sysfs，debugfs和ioctl）中，用户空间应用程序必须启动到内核空间的传输；使用netlink套接字，*内核可以启动传输*。
- en: Also, with all the other mechanisms we have seen so far (procfs, sysfs, and
    debugfs), the various interface files being strewn all over the filesystem(s)
    can cause kernel namespace pollution; with netlink sockets (and, incidentally,
    with ioctl), this isn't the case as there are no files.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，到目前为止我们所见过的所有其他机制（procfs，sysfs和debugfs），散布在整个文件系统中的各种接口文件可能会导致内核命名空间污染；使用netlink套接字（顺便说一句，使用ioctl也是如此），情况并非如此，因为没有文件。
- en: These advantages can be helpful, depending on the type of product you're working
    on. Now, let's understand what a netlink socket is.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优势可能有所帮助，具体取决于您正在开发的产品类型。现在，让我们了解一下netlink套接字是什么。
- en: Understanding what a netlink socket is
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解什么是netlink套接字
- en: So, what is a netlink socket? We shall keep it simple – a *netlink socket* is
    a "special" socket family that exists only on the Linux OS since version 2.2\.
    Using it, you can set up **Inter-Process Communication** (**IPC**) between a user
    mode process (or thread) and a component within the kernel; in our case, a kernel
    module, which is typically a driver.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，netlink套接字是什么？我们将保持简单 - *netlink套接字*是一个仅存在于Linux OS自2.2版本以来的“特殊”套接字系列。使用它，您可以在用户模式进程（或线程）和内核中的组件之间建立**进程间通信**（**IPC**）；在我们的情况下，通常是一个驱动程序的内核模块。
- en: It is similar to a UNIX domain datagram socket in many ways; it's meant for
    communication on the *localhost* *only* and not across systems. While UNIX domain
    sockets use a pathname as their namespace (a special "socket" file), netlink sockets
    use a PID. Pedantically, this is a port ID and not a process ID, although realistically,
    process IDs are very often used as the namespace. The modern kernel core (besides
    drivers) uses netlink sockets in many cases – as one example, the iproute2 networking
    utilities use it to configure wireless drivers. As another interesting example,
    the udev feature uses netlink sockets to effect communication between the kernel
    udev implementation and the user space daemon process (udevd or systemd-udevd,
    for things such as device discovery, device node provisioning, and so on).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面类似于UNIX域数据报套接字；它是用于*本地主机* *仅*通信，而不是跨系统。虽然UNIX域套接字使用路径名作为它们的命名空间（一个特殊的“套接字”文件），netlink套接字使用PID。从学究的角度来看，这是一个端口ID而不是进程ID，尽管实际上，进程ID经常被用作命名空间。现代内核核心（除了驱动程序）在许多情况下使用netlink套接字
    - 例如，iproute2网络实用程序使用它来配置无线驱动程序。另一个有趣的例子是，udev功能使用netlink套接字在内核udev实现和用户空间守护进程（udevd或systemd-udevd）之间进行通信，用于设备发现、设备节点供应等等。
- en: Here, we will design and implement a simple user<->kernel messaging demonstration
    using netlink sockets. To do so, we shall have to write two programs (at a minimum)
    – one as the user space application that issues socket-based system calls, and
    another for the kernel-space component (here, a kernel module). We shall have
    the user space process send a "message" to the kernel module; the kernel module
    should receive it and print it (into the kernel log buffer). The kernel module
    will then reply to the user space process, which is blocking on this very event.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将设计和实现一个简单的用户<->内核消息演示，使用netlink套接字。为此，我们将不得不编写两个程序（至少）——一个作为用户空间应用程序，发出基于套接字的系统调用，另一个作为内核空间组件（这里是内核模块）。我们将让用户空间进程向内核模块发送一个“消息”；内核模块应该接收并打印它（到内核日志缓冲区）。然后内核模块将回复给用户空间进程，该进程正阻塞在这个事件上。
- en: So, without further ado, let's dive into writing some code using netlink sockets;
    we shall begin with the user space application. Read on!
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不再拖延，让我们开始编写一些使用netlink套接字的代码；我们将从用户空间应用程序开始。继续阅读！
- en: Writing the user space netlink socket application
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写用户空间netlink套接字应用程序
- en: 'Follow these steps get the *user space* application running:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤运行*用户空间*应用程序：
- en: The first thing we must do is get ourselves a *socket*. Traditionally, a socket
    is defined as an endpoint of communication; thus, a pair of sockets forms a connection.
    We will use the `socket(2)` system call to do this. Its signature is
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事就是获得一个*套接字*。传统上，套接字被定义为通信的端点；因此，一对套接字形成一个连接。我们将使用`socket(2)`系统调用来执行此操作。它的签名是
- en: '`int socket(int domain, int type, int protocol);`.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`int socket(int domain, int type, int protocol);`。'
- en: 'Without going into too much detail, here''s what we do:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 不详细讨论，这是我们要做的：
- en: We specify `domain` as part of the special `PF_NETLINK` family, thus requesting
    a netlink socket.
  id: totrans-362
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`domain`指定为特殊的`PF_NETLINK`家族的一部分，因此请求一个netlink套接字。
- en: Set `type` to `SOCK_RAW` using a raw socket (effectively skipping the transport
    layer).
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原始套接字将`type`设置为`SOCK_RAW`（有效地跳过传输层）。
- en: '`protocol` is the protocol to use. Since we''re using a raw socket, the protocol
    is left to be implemented either by us or by the kernel; having the kernel netlink
    code do this is the right approach. Here, we use an unused protocol number; that
    is, `31`.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protocol`是要使用的协议。由于我们使用原始套接字，协议留待我们或内核实现；让内核netlink代码执行这一点是正确的方法。在这里，我们使用一个未使用的协议号；即`31`。'
- en: 'The next step is to bind the socket via the usual `bind(2)` system call semantics.
    First, we must initialize a netlink source `socketaddr` structure for this purpose
    (where we specify the family as a netlink and the PID value as the calling process''
    PID (for unicast only)). The following code is for the first two steps mentioned
    here (for clarity, we won''t be displaying the error checking code here):'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是通过通常的`bind(2)`系统调用语义绑定套接字。首先，我们必须为此目的初始化一个netlink源`socketaddr`结构（在其中我们指定家族为netlink，PID值为调用进程的PID（仅用于单播））。以下代码是前面提到的前两个步骤（为了清晰起见，我们不会在这里显示错误检查代码）：
- en: '[PRE62]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, we must initialize a netlink "destination address" structure. Here, we
    set the PID member to `0`, a special value indicating that the destination is
    the kernel:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须初始化一个netlink“目标地址”结构。在这里，我们将PID成员设置为`0`，这是一个特殊值，表示目标是内核：
- en: '[PRE63]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, we must allocate and initialize a netlink "header" data structure. Among
    other things, it specifies the source PID and, importantly, the data "payload"
    that we shall deliver to our kernel component. Here, we are making use of helper
    macros such as `NLMSG_DATA()` to specify the correct data location within the
    netlink header structure:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须分配和初始化一个netlink“头”数据结构。除其他事项外，它指定了源PID和重要的是我们将传递给内核组件的数据“有效载荷”。在这里，我们正在使用辅助宏，如`NLMSG_DATA()`来指定netlink头结构内的正确数据位置：
- en: '[PRE64]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, an `iovec` structure must be initialized to reference the netlink header,
    and a `msghdr` data structure must be initialized to point to the destination
    address and `iovec`:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，必须初始化一个`iovec`结构以引用netlink头，并初始化一个`msghdr`数据结构以指向目标地址和`iovec`：
- en: '[PRE65]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Finally, the message is sent (transmitted) via the `sendmsg(2)` system call
    (which takes the socket descriptor and the aforementioned `msghdr` structure as
    a parameter):'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，消息通过`sendmsg(2)`系统调用发送（传输）（它接受套接字描述符和前面提到的`msghdr`结构作为参数）：
- en: '[PRE66]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The kernel component – a kernel module, which we shall discuss shortly – should
    now receive the message via its netlink socket and display the message''s content;
    we arrange for it to then politely reply. To grab the reply, our user space app
    must now perform a blocking read on the socket:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内核组件——一个内核模块，我们将很快讨论——现在应该通过其netlink套接字接收消息并显示消息的内容；我们安排它然后礼貌地回复。为了抓取回复，我们的用户空间应用现在必须在套接字上执行阻塞读取：
- en: '[PRE67]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We must employ the `recvmsg(2)` system call to do this. When it gets unblocked,
    it states that the message has been received.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用`recvmsg(2)`系统调用来执行此操作。当它被解除阻塞时，它说明消息已被接收。
- en: Why so much abstraction and wrapping for data structures? Well, it's how things
    often evolve – the `msghdr` structure was created so that the `sendmsg(2)` API
    can use fewer parameters. But that implies the parameters have to go somewhere;
    they go deep inside `msghdr`, which points to the destination address and `iovec`,
    whose `base` member points to the netlink header structure, which contains the
    payload! Whew.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么数据结构需要这么多的抽象和封装？嗯，这通常是事物演变的方式——`msghdr`结构被创建是为了让`sendmsg(2)`API使用更少的参数。但这意味着参数必须放在某个地方；它们深深地嵌入在`msghdr`中，指向目标地址和`iovec`，`iovec`的`base`成员指向netlink头结构，其中包含有效载荷！哇。
- en: 'As an experiment, what if we build and run the user mode netlink application
    prematurely – *without* the kernel-side code in place? It will fail, of course...
    But how exactly? Well, use the empirical approach. By trying this out via the
    venerable `strace(1)` utility, we can see that the `socket(2)` system call returns
    a failure, the cause being `Protocol not supported`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个实验，如果我们过早地构建和运行用户模式netlink应用程序，*没有*内核端的代码，会发生什么？当然会失败...但是具体是如何失败的呢？好吧，采用经验主义的方法。通过尝试使用受人尊敬的`strace(1)`实用程序，我们可以看到`socket(2)`系统调用返回失败，原因是`协议不受支持`：
- en: '[PRE68]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This is correct; there is no such `protocol # 31` (`31` = `0x1f`, the protocol
    number we''re using) in place *yet* within the kernel! We''re yet to do this.
    So, that''s the user space side of things. Now, let''s complete the puzzle and
    have it actually work! We''ll do this by seeing how the kernel component (module/driver)
    is written.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正确的；内核中还没有`协议号31`（`31` = `0x1f`，我们正在使用的协议号）！我们还没有做到这一点。所以，这是用户空间的情况。现在，让我们完成拼图，让它真正起作用！我们将通过查看内核组件（模块/驱动程序）的编写方式来完成这一点。
- en: Writing the kernel-space netlink socket code as a kernel module
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将内核空间netlink套接字代码编写为内核模块
- en: 'The kernel provides the base infrastructure for netlink, including APIs and
    data structures; all the required ones are exported and thus available to you
    as a module author. We use several of them; the steps to program our kernel netlink
    component – our kernel module – are outlined here:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 内核为netlink提供了基础架构，包括API和数据结构；所有所需的都已导出，因此作为模块作者，这些都对您可用。我们使用其中的几个；编程内核netlink组件（我们的内核模块）的步骤在这里概述：
- en: 'Just as with the user space app, the first thing we must do is get ourselves
    a netlink socket. The kernel API is `netlink_kernel_create()`, and its signature
    is as follows:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像用户空间应用程序一样，我们必须首先获取netlink套接字。内核API是`netlink_kernel_create()`，其签名如下：
- en: '[PRE69]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The first parameter is a generic network structure; we pass the kernel''s existing
    and valid `init_net` structure here. The second parameter is the *protocol number
    (unit)* to use; we shall specify the same number (`31`) as we did for the user
    space app. The third parameter is a pointer to an (optional) netlink configuration
    structure; here, we only set the input member to a function of ours nullifying
    the rest. This function is called back when a user space process (or thread) provides
    any input (that is, transmits something) to the kernel netlink component. So,
    within our kernel module''s `init` routine, we have the following:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个通用网络结构；我们在这里传递内核现有和有效的`init_net`结构。第二个参数是要使用的*协议号（单位）*；我们将指定与用户空间应用程序相同的数字（`31`）。第三个参数是指向（可选）netlink配置结构的指针；在这里，我们只将输入成员设置为我们的函数的空值。当用户空间进程（或线程）向内核netlink组件提供任何输入（即传输某些内容）时，将调用此函数。因此，在我们的内核模块的`init`例程中，我们有以下内容：
- en: '[PRE70]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As we mentioned previously, when a user space process (or thread) provides
    any input (that is, transmits something) to our kernel (netlink) module or driver,
    the callback function is invoked. It''s important to understand that it runs in
    the process context and not any kind of interrupt context; we use our `convenient.h:PRINT_CTX()`
    macro to verify this (we will cover this in [Chapter 4](cfd1ca5d-cd0b-451d-8a35-31e65a09d2e4.xhtml),
    *Handling Hardware Interrupts*, in the *Fully figuring out the context* section).
    Here, we simply display the received message and then reply by sending a sample
    message to our user space peer process. The data payload that''s transmitted from
    our user space peer process can be retrieved from the socket buffer structure
    that is passed along to our callback function as a parameter, from a netlink header
    structure within it. You can see how the data and sender PID are retrieved here:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，当用户空间进程（或线程）向我们的内核（netlink）模块或驱动程序提供任何输入（即传输某些内容）时，将调用回调函数。重要的是要理解它在进程上下文中运行，而不是任何一种中断上下文；我们使用我们的`convenient.h:PRINT_CTX()`宏来验证这一点（我们将在[第4章](cfd1ca5d-cd0b-451d-8a35-31e65a09d2e4.xhtml)中介绍这一点，*处理硬件中断*，在*完全弄清上下文*部分）。在这里，我们只是显示接收到的消息，然后通过向我们的用户空间对等进程发送一个示例消息来进行回复。从传递给我们的回调函数的套接字缓冲结构中检索到的来自我们的用户空间对等进程的数据有效载荷可以从其中的netlink头结构中检索到。您可以在这里看到如何检索数据和发送者PID：
- en: '[PRE71]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The *socket buffer* data structure – `struct sk_buff` – is considered the critical
    data structure within the Linux kernel's network protocol stack. It holds all
    metadata concerning the network packet, including dynamic pointers to it. It has
    to be quickly allocated and freed (especially when network code runs in interrupt
    contexts); this is indeed possible because it's on the kernel's slab (SLUB) cache
    (see details on the kernel slab allocator in the companion guide *Linux Kernel
    Programming,* *Chapters 7*, *Memory Management Internals - Essentials*, *Chapter
    8*, *Kernel Memory Allocation for Module Authors – Part 1*, and *Chapter 9*, *Kernel
    Memory Allocation for Module Authors – Part 2*).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '*套接字缓冲*数据结构 - `struct sk_buff` - 被认为是Linux内核网络协议栈中的关键数据结构。它包含有关网络数据包的所有元数据，包括对它的动态指针。它必须快速分配和释放（特别是当网络代码在中断上下文中运行时）；这确实是可能的，因为它在内核的slab（SLUB）缓存上（有关内核slab分配器的详细信息，请参见配套指南*Linux内核编程*，*第7章*，*内存管理内部
    - 基础知识*，*第8章*，*模块作者的内核内存分配 - 第1部分*，以及*第9章*，*模块作者的内核内存分配 - 第2部分*）。'
- en: Now, we need to understand that we can retrieve the payload from the network
    packet by first dereferencing the `data` member of the socket buffer (`skb`) structure
    that's passed to our callback routine! Next, this `data` member is actually the
    pointer to the netlink message header structure that's set up by our user space
    peer. We then dereference it to get the actual payload.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要了解，我们可以通过首先取消引用传递给我们的回调例程的套接字缓冲（`skb`）结构的`data`成员来检索网络数据包的有效载荷！接下来，这个`data`成员实际上是由我们的用户空间对等方设置的netlink消息头结构的指针。然后，我们取消引用它以获取实际的有效载荷。
- en: 'We would now like to "reply" to our user space peer process; doing so involves
    performing a few actions. First, we must allocate a new netlink message with the
    `nlmsg_new()` API, which is really a thin wrapper over `alloc_skb()`, add a netlink
    message to the just allocated socket buffer via the `nlmsg_put()` API, and then
    copy in the data (the payload) into the netlink header using an appropriate macro
    (`nlmsg_data()`):'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们想要“回复”我们的用户空间对等进程；这涉及执行一些操作。首先，我们必须使用`nlmsg_new()` API分配一个新的netlink消息，这实际上是对`alloc_skb()`的一个薄包装，通过`nlmsg_put()`
    API将netlink消息添加到刚分配的套接字缓冲区中，然后使用适当的宏（`nlmsg_data()`）将数据（有效载荷）复制到netlink头中：
- en: '[PRE72]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We send the reply to our user space peer process via the `nlmsg_unicast()`
    API (even multicasting netlink messages are possible):'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过`nlmsg_unicast()` API将回复发送给我们的用户空间对等进程（甚至可以进行netlink消息的多播）：
- en: '[PRE73]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'That only leaves the cleanup (which is invoked when the kernel module is removed);
    the `netlink_kernel_release()` API is effectively the inverse of `netlink_kernel_create()` as
    it cleans up the netlink socket, shutting it down:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这只留下了清理工作（当内核模块被移除时调用）；`netlink_kernel_release()` API实际上是`netlink_kernel_create()`的反向操作，它清理netlink套接字，关闭它：
- en: '[PRE74]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Now that we have written both the user space app and the kernel module to interface
    via a netlink socket, let's actually try it out!
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了用户空间应用程序和内核模块，以通过netlink套接字进行接口，让我们实际尝试一下！
- en: Trying out our netlink interfacing project
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试我们的netlink接口项目
- en: 'It''s time to verify it all works as advertised. Let''s get started:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候验证一切是否如广告所述。让我们开始吧：
- en: 'First, build and insert the kernel module into kernel memory:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，构建并将内核模块插入内核内存：
- en: Our `lkm` convenience script makes short work of this; this session was carried
    out on our familiar x86_64 guest VM running Ubuntu 18.04 LTS and a custom 5.4.0
    Linux kernel.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`lkm`便利脚本可以轻松完成这项工作；这个会话是在我们熟悉的x86_64客户端VM上进行的，运行的是Ubuntu 18.04 LTS和自定义的5.4.0
    Linux内核。
- en: '[PRE75]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'With that, it''s loaded up and ready. Next, we will build and try out our user
    space application:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这些，它已经加载并准备好了。接下来，我们将构建并尝试我们的用户空间应用程序：
- en: '[PRE76]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This results in the following output:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下输出：
- en: '![](img/ce358d89-c70a-4d5b-8804-df86245ce2b1.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce358d89-c70a-4d5b-8804-df86245ce2b1.png)'
- en: Figure 2.5 – Screenshot showing user<->kernel communication via our sample netlink
    socket code
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 - 屏幕截图显示用户<->内核通过我们的示例netlink套接字代码进行通信
- en: It works; the kernel netlink module receives and displays the message that was
    sent to it from the user space process (`PID 7813`). The kernel module then replies
    with its own message to its user space peer, which successfully receives and displays
    it (via a `printf()`). Give it a try yourself. When you're done, don't forget
    to remove the kernel module with `sudo rmmod netlink_simple_intf`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 它起作用了；内核netlink模块接收并显示了从用户空间进程（`PID 7813`）发送给它的消息。然后内核模块以自己的消息回复给它的用户空间对等体，成功接收并显示它（通过`printf()`）。你也试试看。完成后，不要忘记使用`sudo
    rmmod netlink_simple_intf`删除内核模块。
- en: 'An aside: a connector driver exists within the kernel. Its purpose is to ease
    the development of netlink-based communication, making it simpler for both kernel
    and user space developers set up and use a netlink-based communication interface.
    We will not delve into this here; please refer to the documentation within the
    kernel ([https://elixir.bootlin.com/linux/v5.4/source/Documentation/driver-api/connector.rst](https://elixir.bootlin.com/linux/v5.4/source/Documentation/driver-api/connector.rst)).
    Some sample code is also provided within the kernel source tree (at `samples/connector`).'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 另外：内核中存在一个连接器驱动程序。它的目的是简化基于netlink的通信的开发，使内核和用户空间开发人员都能更简单地设置和使用基于netlink的通信接口。我们不会在这里深入讨论；请参考内核中的文档（[https://elixir.bootlin.com/linux/v5.4/source/Documentation/driver-api/connector.rst](https://elixir.bootlin.com/linux/v5.4/source/Documentation/driver-api/connector.rst)）。内核源树中还提供了一些示例代码（在`samples/connector`中）。
- en: With that, you have learned how to interface between a user mode app and a kernel
    component via the powerful netlink socket mechanism. As we mentioned earlier,
    it has several actual use cases within the kernel tree. Now, let's move on and
    cover one more user-kernel interfacing method, via the popular `ioctl(2)` system
    call.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，您已经学会了如何通过强大的netlink套接字机制在用户模式应用程序和内核组件之间进行接口。正如我们之前提到的，它在内核树中有几个实际用例。现在，让我们继续并涵盖另一种用户-内核接口方法，通过流行的`ioctl(2)`系统调用。
- en: Interfacing via the ioctl system call
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过ioctl系统调用进行接口
- en: '**ioctl **is a system call; why the funny name *ioctl*? It''s an abbreviation
    for **input-output control**. While the read and write system calls (among others)
    are used to effectively transfer *data* from and to a device (or file; remember
    the UNIX paradigm *if it''s not a process, it''s a file!*), the *ioctl* system
    call is used to *issue* *commands* to the device (via its driver). For example,
    changing a console device''s terminal characteristics, writing a track to a disk
    when formatting it, sending a control command to a stepper motor, controlling
    a camera or audio device, and so on, are all instances of commands being sent
    to a device.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '**ioctl**是一个系统调用；为什么有个滑稽的名字*ioctl*？它是**输入输出控制**的缩写。虽然读取和写入系统调用（以及其他调用）用于有效地从设备（或文件；记住UNIX范式*如果不是进程，就是文件！*）传输*数据*，但*ioctl*系统调用用于向设备（通过其驱动程序）*发出*
    *命令*。例如，更改控制台设备的终端特性，格式化时向磁盘写入轨道，向步进电机发送控制命令，控制摄像头或音频设备等，都是发送命令给设备的实例。'
- en: Let's consider a fictitious example. We have a device and are developing a (character)
    device driver for it. The device has various *registers*, small – typically 8-,
    16-, or 32-bit pieces of hardware memory on the device – some of which are control
    registers. By appropriately performing I/O (reads and writes) on them, we control
    the device (well, that's really the whole point, isn't it; the actual subject
    matter regarding the details of working with hardware memory including device
    registers will be covered in the next chapter). So, how will you, the driver author,
    communicate or interface with a user space program that wants to perform various
    control operations on this device? We often architect the user space C (or C++)
    program to open the device typically by performing an `open(2)` on its device
    file, and subsequently issue the read and write system calls.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个虚构的例子。我们有一个设备，并为其开发了一个（字符）设备驱动程序。该设备有各种*寄存器*，通常是设备上的小型硬件内存，例如8位、16位或32位
    - 其中一些是控制寄存器。通过适当地对它们进行I/O（读取和写入），我们控制设备（好吧，这确实是整个重点，不是吗；有关使用硬件内存和设备寄存器的详细工作细节将在下一章中介绍）。那么，作为驱动程序作者，您将如何与希望在此设备上执行各种控制操作的用户空间程序进行通信或接口？我们通常会设计用户空间C（或C++）程序，通过对设备文件执行`open(2)`来打开设备，并随后发出读取和写入系统调用。
- en: 'But, as we just mentioned, the `read(2)` and `write(2)` system call APIs are
    appropriate when *transferring* *data* while here, instead, we intend to perform
    **control operations**. So, we need another system call to do so... Do we then
    need to create and encode a new system call (or calls)? No, it''s much simpler
    than that: we *multiplex via the* *ioctl system call,* leveraging it to perform
    any required control operations upon our device! How? Ah, recall from the previous
    chapter the all-important `file_operations` (fops) data structure; we will now
    initialize another member, the `.ioctl` one, to our ioctl method function, thus
    allowing our device driver to hook into this system call:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如我们刚才提到的，当*传输* *数据*时，`read(2)`和`write(2)`系统调用API是适当的，而在这里，我们打算执行**控制操作**。那么，我们需要另一个系统调用来执行这样的操作...我们是否需要创建和编码一个新的系统调用（或多个系统调用）？不，比那简单得多：我们通过*ioctl系统调用进行多路复用*，利用它来执行我们设备上需要的任何控制操作！如何做到？啊，回想一下上一章中至关重要的`file_operations`（fops）数据结构；我们现在将初始化另一个成员，`.ioctl`，为我们的ioctl方法函数，从而允许我们的设备驱动程序挂接到这个系统调用：
- en: '[PRE77]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Realistically, we shall have to figure out whether we should use `ioctl` or
    the `unlocked_ioctl` member of the `file_operations` structure, depending on whether
    the module is running on Linux kernel version 2.6.36 or later; more on this follows.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现实情况是，我们必须弄清楚在Linux内核版本2.6.36或更高版本上运行模块时，我们应该使用`ioctl`还是`file_operations`结构的`unlocked_ioctl`成员；接下来会更多地介绍这个问题。
- en: 'In fact, adding new system calls to the kernel is not something you should
    do lightly! The kernel chaps are *not *open to arbitrarily adding syscalls – it''s
    a security-sensitive interface, after all. More on this is documented here: [https://www.kernel.org/doc/html/latest/kernel-hacking/hacking.html#ioctls-not-writing-a-new-system-call](https://www.kernel.org/doc/html/latest/kernel-hacking/hacking.html#ioctls-not-writing-a-new-system-call).'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，向内核添加新的系统调用并不是一件轻松的事情！内核开发人员并不会随意添加系统调用 - 毕竟这是一个安全敏感的接口。有关此更多信息请参阅：[https://www.kernel.org/doc/html/latest/kernel-hacking/hacking.html#ioctls-not-writing-a-new-system-call](https://www.kernel.org/doc/html/latest/kernel-hacking/hacking.html#ioctls-not-writing-a-new-system-call)。
- en: More on using ioctl for interfacing follows.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来会更多地介绍使用ioctl进行接口。
- en: Using ioctl in the user and kernel space
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在用户空间和内核空间中使用ioctl
- en: 'The `ioctl(2)` system call''s signature is as follows:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`ioctl(2)`系统调用的签名如下：'
- en: '[PRE78]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The parameter list is a *varargs – variable arguments –* one. Realistically
    and typically, we pass either two or three parameters:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表是*可变参数*。现实和通常情况下，我们传递两个或三个参数：
- en: The first parameter is obvious – the file descriptor of the (in our case) device
    file that was opened.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数很明显 - 打开的设备文件的文件描述符（在我们的情况下）。
- en: 'The second parameter, called `request`, is the interesting one: it''s the command
    to be passed to the driver. In reality, it''s an *encoding*, encapsulating a so-called
    ioctl magic number: a number and a type (read/write).'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数称为`request`，这是有趣的：它是要传递给驱动程序的命令。实际上，它是一个*编码*，封装了所谓的ioctl魔术数：一个数字和一个类型（读/写）。
- en: The (optional) third parameter, often called `arg`, is also an `unsigned long`
    quantity; we use it to either pass some data in the usual fashion to the underlying
    driver or, often, to return data to the user space by passing its (virtual) address
    and having the kernel write into it, utilizing C's so-called **value-result**
    or **in-out** parameter style.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （可选的）第三个参数，通常称为`arg`，也是一个`unsigned long`数量；我们使用它来以通常的方式传递一些数据给底层驱动程序，或者经常通过传递它的（虚拟）地址并让内核写入它来将数据返回给用户空间，利用C语言的所谓**值-结果**或**输入-输出**参数样式。
- en: 'Now, using ioctl correctly is not as trivial as it is with many other APIs.
    Think about this for a moment: you can easily have a scenario where several user
    space apps are issuing `ioctl(2)` system calls (with various commands being issued)
    to their underlying device drivers. A problem becomes apparent: how will the kernel
    VFS layer direct the ioctl request to the correct driver? ioctl is typically performed
    on a char device file that has a unique *(major, minor)* number; hence, how can
    another driver receive your ioctl command (unless you intentionally, perhaps maliciously,
    set up the device file(s) in such a manner)?'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正确使用ioctl并不像许多其他API那样简单。想一想：您很容易会遇到这样的情况，即几个用户空间应用程序正在向其底层设备驱动程序发出`ioctl(2)`系统调用（发出各种命令）。一个问题变得明显：内核VFS层如何将ioctl请求定向到正确的驱动程序？ioctl通常在具有唯一*(major,
    minor)*号码的字符设备文件上执行；因此，另一个驱动程序如何接收您的ioctl命令（除非您故意、可能恶意地设置设备文件）？
- en: Nevertheless, a protocol exists to achieve safe and correct usage of ioctl; every
    application and driver defines a magic number that will be encoded into all its
    ioctl requests. First, the driver will verify that every ioctl request it receives
    contains *its* magic number; only then will it proceed to process it; otherwise,
    it will simply drop it. This, of course, brings up the need for an *ABI* – we
    need to allocate unique magic numbers (it could be a range) to each "registered"
    driver. Since this creates an ABI, the kernel document will be the same; you can
    find details on who is using which magic number (or code) here: [https://www.kernel.org/doc/Documentation/ioctl/ioctl-number.txt](https://www.kernel.org/doc/Documentation/ioctl/ioctl-number.txt).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在一个协议来实现对ioctl的安全和正确使用；每个应用程序和驱动程序都定义一个魔术数字，该数字将被编码到其所有ioctl请求中。首先，驱动程序将验证其接收到的每个ioctl请求是否包含*它的*魔术数字；只有在这种情况下，它才会继续处理；否则，它将简单地丢弃它。当然，这引出了对*ABI*的需求
    - 我们需要为每个“注册”的驱动程序分配唯一的魔术数字（它可以是一个范围）。由于这创建了一个ABI，内核文档将是相同的；您可以在这里找到有关谁在使用哪个魔术数字（或代码）的详细信息：[https://www.kernel.org/doc/Documentation/ioctl/ioctl-number.txt](https://www.kernel.org/doc/Documentation/ioctl/ioctl-number.txt)。
- en: 'Next, an ioctl request to the underlying driver can be one of essentially four
    things: a command to "write" to the device, a command to "read" from (or query)
    the device, a command to do both read/write transfers, or neither. This information
    is (again) *encoded* into a request by defining certain bits to convey the meaning:
    to make this job easier, we have four helper macros that allows us to construct
    ioctl commands:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对底层驱动程序的ioctl请求基本上可以是四种情况之一：向设备“写入”命令，从设备“读取”（或查询）命令，执行读/写传输的命令，或者什么都不是的命令。这些信息（再次）通过定义某些位来*编码*到请求中：为了使这项工作更容易，我们有四个辅助宏，允许我们构造ioctl命令：
- en: '`_IO(type,nr)`: Encodes an ioctl command with no argument'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_IO(type,nr)`: 编码一个没有参数的ioctl命令'
- en: '`_IO**R**(type,nr,datatype)`: Encodes an ioctl command for reading data from
    the kernel/driver'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_IO**R**(type,nr,datatype)`: 编码一个用于从内核/驱动程序读取数据的ioctl命令'
- en: '`_IO**W**(type,nr,datatype)`: Encodes an ioctl command for writing data to
    the kernel/driver'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_IO**W**(type,nr,datatype)`: 编码一个用于向内核/驱动程序写入数据的ioctl命令'
- en: '`_IO**WR**(type,nr,datatype)`: Encodes an ioctl command for read/write transfers'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_IO**WR**(type,nr,datatype)`: 编码一个用于读/写传输的ioctl命令'
- en: These macros are defined within the user space `<sys/ioctl.h>` header and in
    the kernel at `include/uapi/asm-generic/ioctl.h`. The typical (and quite obvious)
    best practice is to create a *common header* file that defines the ioctl commands
    for an app/driver and includes that file in both the user mode app, as well as
    the device driver.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这些宏在用户空间的`<sys/ioctl.h>`头文件中定义，在内核中位于`include/uapi/asm-generic/ioctl.h`。典型（并且相当明显的）最佳实践是创建一个*公共头*文件，定义应用程序/驱动程序的ioctl命令，并在用户模式应用程序和设备驱动程序中包含该文件。
- en: 'Here, as a demonstration, we shall design and implement a user space app and
    a kernel space device driver to drive a fictional device that communicates via
    the `ioctl(2)` system call. Thus, we must define some commands to issue via the
    *ioctl* interface. We will do this in a common header file, as shown here:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，作为演示，我们将设计并实现一个用户空间应用程序和一个内核空间设备驱动程序，以驱动一个通过`ioctl(2)`系统调用进行通信的虚构设备。因此，我们必须定义一些通过*ioctl*接口发出的命令。我们将在一个公共头文件中完成这个工作，如下所示：
- en: '[PRE79]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We must try and make the names we use in our macros meaningful. Our three commands
    (highlighted in bold) are all prefixed with `IOCTL_LLKD_`, indicating that they
    are all ioctl commands for our fictitious `LLKD` project; next, they are suffixed
    with `IOC{Q|S}`, with `IOC` implying that it's an ioctl command, `Q` implying
    it's a query operation, and `S` implying it's a set operation.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须尽量使宏中使用的名称有意义。我们的三个命令（用粗体标出）都以`IOCTL_LLKD_`为前缀，表明它们都是我们虚构的`LLKD`项目的ioctl命令；接下来，它们以`IOC{Q|S}`为后缀，其中`IOC`表示它是一个ioctl命令，`Q`表示它是一个查询操作，`S`表示它是一个设置操作。
- en: Now, let's learn how we set things up at the code level from both the user space
    as well as the kernel space (driver).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从用户空间和内核空间（驱动程序）的代码级别学习如何设置事物。
- en: User space – using the ioctl system call
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户空间 - 使用ioctl系统调用
- en: 'The *user space* signature of the `ioctl(2)` system call is as follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`ioctl(2)`系统调用的*用户空间*签名如下：'
- en: '[PRE80]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here, we can see that it takes a variable argument list; the arguments to ioctl
    are as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到它接受一个可变参数列表；ioctl的参数如下：
- en: '**First parameter**: The file descriptor of the file or device (as it will
    be in our case) to perform the ioctl operation on (we get `fd` by performing an
    *open* on the device file).'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一个参数**：文件或设备的文件描述符（在我们的情况下）执行ioctl操作（我们通过在设备文件上执行*open*来获得`fd`）。'
- en: '**Second parameter**: The request or command being issued to the underlying
    device driver (or filesystem or whatever `fd` represents).'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二个参数**：发出给底层设备驱动程序（或文件系统或任何`fd`代表的东西）的请求或命令。'
- en: '**An optional third (or more) parameter(s)**: Often, the third parameter is
    an integer (or a pointer to an integer or data structure); we use this method
    to either pass some additional information to the driver, when issuing a *set *kind
    of command, or to retrieve some information from the driver via the well-understood
    *pass-by-reference* C paradigm, where we pass the pointer and have the driver
    "poke" it, thus treating the parameter as, in effect, a return value.'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可选的第三（或更多）个参数**：通常，第三个参数是一个整数（或指向整数或数据结构的指针）；我们使用这种方法来在发出*设置*类型的命令时向驱动程序传递一些额外信息，或者通过众所周知的*传引用*
    C范式从驱动程序中检索一些信息，其中我们传递指针并让驱动程序“poke”它，从而将参数视为实际上是一个返回值。'
- en: 'In effect, ioctl is often used as a *generic* system call. The use of ioctl
    to perform command operations on both hardware and software is almost embarrassingly
    large! Please refer to the kernel documentation (`Documentation/ioctl/<...>`)
    to see many actual real-world examples. For example, you will find details on
    who is using which magic number (or code) within ioctl here: [https://www.kernel.org/doc/Documentation/ioctl/ioctl-number.txt](https://www.kernel.org/doc/Documentation/ioctl/ioctl-number.txt).'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，ioctl经常被用作*通用*系统调用。使用ioctl在硬件和软件上执行命令操作的情况几乎令人尴尬地多！请参阅内核文档（`Documentation/ioctl/<...>`）以查看许多实际的真实世界示例。例如，您将在这里找到有关谁在ioctl中使用哪个魔术数字（或代码）的详细信息：[https://www.kernel.org/doc/Documentation/ioctl/ioctl-number.txt](https://www.kernel.org/doc/Documentation/ioctl/ioctl-number.txt)。
- en: (Similarly, the `ioctl_list(2)` man page reveals the complete list of ioctl
    calls in the x86 kernel; these documentation files seem to be pretty old, though.
    The docs now seem to be here: [https://github.com/torvalds/linux/tree/master/Documentation/userspace-api/ioctl](https://github.com/torvalds/linux/tree/master/Documentation/userspace-api/ioctl).)
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: （类似地，`ioctl_list(2)`手册页面显示了x86内核中ioctl调用的完整列表；尽管这些文档文件似乎相当古老。现在似乎在这里：[https://github.com/torvalds/linux/tree/master/Documentation/userspace-api/ioctl](https://github.com/torvalds/linux/tree/master/Documentation/userspace-api/ioctl)。）
- en: 'Let''s look at some snippets of the user space C application, particularly
    when it comes to issuing the `ioctl(2)` system calls (for brevity and readability,
    we have left out the error checking code; the full code is available in this book''s
    GitHub repository):'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些用户空间C应用程序的片段，特别是在发出`ioctl(2)`系统调用时（为了简洁和可读性，我们省略了错误检查代码；完整的代码可以在本书的GitHub存储库中找到）：
- en: '[PRE81]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: How does our driver handle these user space-issued ioctls? Let's find out.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的驱动程序如何处理这些用户空间发出的ioctls呢？让我们找出来。
- en: Kernel space – using the ioctl system call
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内核空间-使用ioctl系统调用
- en: 'In the previous section, we saw that the kernel driver will have to initialize
    its `file_operations` structure to include the `ioctl` method. There is more to
    this, though: the Linux kernel keeps evolving; in early kernel versions, the developers
    used a very coarse granularity lock that, though it worked, quite severely hurt
    its performance (we will discuss locking in detail in [Chapter 6](f456f2ea-ca5f-4d0f-b9c0-55b9ae92f659.xhtml),
    *Kernel Synchronization - Part 1*, and [Chapter 7](14cf1232-dfd5-428a-9c0b-30bcd84651b9.xhtml),
    *Kernel Synchronization - Part 2*). It was so bad that it was nicknamed the **Big
    Kernel Lock** (**BKL**)! The good news is that by kernel release 2.6.36, the developers
    got rid of this infamous lock. Doing so had some side effects, though: one of
    them was that the number of parameters that get sent to the ioctl method within
    the kernel and thus within our `file_operations` data structure changed from four
    to three with the newer method – christened `unlocked_ioctl`. Thus, for our demo
    driver, we will initialize the *ioctl* method with the following when initializing
    our driver''s `file_operations` structure:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们看到内核驱动程序将不得不初始化其`file_operations`结构以包括`ioctl`方法。不过，这还不是全部：Linux内核不断发展；在早期的内核版本中，开发人员使用了非常粗粒度的锁，虽然它起作用，但严重影响了性能（我们将在[第6章](f456f2ea-ca5f-4d0f-b9c0-55b9ae92f659.xhtml)和[第7章](14cf1232-dfd5-428a-9c0b-30bcd84651b9.xhtml)中详细讨论锁定）。它是如此糟糕以至于被称为**Big
    Kernel Lock**（**BKL**）！好消息是，到了内核版本2.6.36，开发人员摆脱了这个臭名昭著的锁。不过，这样做也产生了一些副作用：其中之一是发送到内核中的ioctl方法的参数数量从旧方法中的四个变为了新方法中的三个，这个新方法被称为`unlocked_ioctl`。因此，对于我们的演示驱动程序，我们将在初始化驱动程序的`file_operations`结构时使用以下*ioctl*方法：
- en: '[PRE82]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Clearly, as it''s defined within the fops driver, ioctl is considered a private
    driver interface (`driver-private`). Also, this same fact regarding the newer
    "unlocked" version has to be taken into account in the function definition within
    the driver code; our driver does so:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，由于它在fops驱动程序中定义，ioctl被认为是一个私有驱动程序接口（`driver-private`）。此外，在驱动程序代码中的函数定义中也必须考虑到关于更新的“解锁”版本的同样事实；我们的驱动程序也这样做了：
- en: '[PRE83]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The key code here is the driver''s ioctl method. Think about it: once basic
    validity checks have been done, all the driver really does is perform a *switch-case *on
    all possible valid ioctl commands issued by the user space app. Let''s take a
    look at the following code (for readability, we will skip the `#if LINUX_VERSION_CODE
    >= ...` macro directive and just show the modern ioctl function signature, as
    well as some validity checks; you can view the full code in this book''s GitHub
    repository):'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键代码是驱动程序的ioctl方法。想想看：一旦基本的有效性检查完成，驱动程序实际上所做的就是对用户空间应用程序发出的所有可能的有效ioctl命令执行*switch-case*。让我们来看一下以下代码（为了可读性，我们将跳过`#if
    LINUX_VERSION_CODE >= ...`宏指令，只显示现代ioctl函数签名以及一些有效性检查；您可以在本书的GitHub存储库中查看完整的代码）：
- en: '[PRE84]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `_IOC_NR` macro is used to extract the command number from the `cmd` parameter.
    Here, we can see that the driver "reacts" to three valid cases of the `ioctl` issued
    via the user space process:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`_IOC_NR`宏用于从`cmd`参数中提取命令号。在这里，我们可以看到驱动程序对通过用户空间进程发出的`ioctl`的三种有效情况做出了“反应”：'
- en: On receiving the `IOCTL_LLKD_IOC**RESET**` command, it performs a device reset.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接收到`IOCTL_LLKD_IOC**RESET**`命令时，它执行设备复位。
- en: On receiving the `IOCTL_LLKD_IOC**Q**POWER` command, it queries (`Q` for query)
    and returns the current power status (by poking its value into the third parameter, `arg`,
    using the *value-result* C programming approach).
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接收到`IOCTL_LLKD_IOC**Q**POWER`命令时，它查询（`Q`表示查询）并返回当前的电源状态（通过将其值插入到第三个参数`arg`中，使用*value-result*
    C编程方法）。
- en: On receiving the `IOCTL_LLKD_IOC**S**POWER` command, it sets (`S` for set) the
    power status (to the value passed in the third parameter, `arg`).
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接收到`IOCTL_LLKD_IOC**S**POWER`命令时，它设置（`S`表示设置）电源状态（设置为第三个参数`arg`中传递的值）。
- en: Of course, since we're working with a purely fictional device, our driver does
    not actually perform any register (or other hardware) work. This driver is simply
    a template that you can make use of.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于我们正在处理一个纯虚构的设备，我们的驱动程序实际上并不执行任何寄存器（或其他硬件）工作。这个驱动程序只是一个您可以利用的模板。
- en: What if a hacker attempts to issue a command unknown to our driver in a (rather
    clumsy) hack? Well, the initial validity checks will catch it; even if they don't,
    we shall hit the `default` case in our *ioctl* method, resulting in the driver
    returning `-ENOTTY` to the user space. This will, via glibc "glue" code, set the
    user space process (or thread's) `errno` value to `ENOTTY`, informing it that
    the ioctl method cannot be serviced. Our user space `perror(3)` API will display
    the `Inappropriate ioctl for device` error message. In fact, this is precisely
    what occurs if a driver has *no* ioctl method (that is, if the ioctl member within
    the `file_operations` structure is set to `NULL`) and a user space app issues
    an `ioctl` method against it.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果黑客试图发出我们的驱动程序不知道的命令（相当笨拙的黑客），会发生什么？好吧，初始的有效性检查会捕捉到它；即使他们没有，我们将在*ioctl*方法中命中`default`情况，导致驱动程序向用户空间返回`-ENOTTY`。这将通过glibc“粘合”代码将用户空间进程（或线程的）`errno`值设置为`ENOTTY`，通知它ioctl方法无法提供服务。我们的用户空间`perror(3)`
    API将显示`Inappropriate ioctl for device`错误消息。事实上，如果驱动程序没有*ioctl*方法（也就是说，如果`file_operations`结构中的ioctl成员设置为`NULL`），并且用户空间应用程序发出`ioctl`方法，就会发生这种情况。
- en: I leave it to you to try out this user space/driver project example; for convenience,
    once the driver has been loaded (via insmod), you can use the `ch2/userspace_ioctl/cr8devnode.sh`
    convenience script to generate the device file. Once it's set up, run the user
    space app; you will find that running it in succession has the "power state" of
    our fictional device get repeatedly toggled.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我把这个用户空间/驱动程序项目示例留给你来尝试；为了方便起见，一旦加载了驱动程序（通过insmod），您可以使用`ch2/userspace_ioctl/cr8devnode.sh`便捷脚本生成设备文件。设置好之后，运行用户空间应用程序；您会发现连续运行它会重复切换我们虚构设备的“电源状态”。
- en: ioctl as a debug interface
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ioctl作为调试接口
- en: As we mentioned at the beginning of this chapter, what about using the *ioctl*
    interface for debug purposes? It can be used for this purpose. You can always
    insert a "debug" command into the *switch-case* block; it can be used to provide
    useful information to the user space application on the driver status, the values
    of key variables (health monitoring too), and more.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头提到的，使用*ioctl*接口进行调试有什么问题？它可以用于这个目的。您可以随时在*switch-case*块中插入一个“debug”命令；它可以用于向用户空间应用程序提供有用的信息，例如驱动程序状态、关键变量的值（也包括健康监测）等。
- en: 'Not only that, but unless it''s explicitly documented to the end user or customer,
    the precise commands that are used via the ioctl interface are unknown; thus,
    you are expected to document the interface while providing sufficient detail for
    other teams or the customer to make good use of them. This leads to an interesting
    point: you might choose to deliberately leave a certain ioctl command undocumented;
    it''s now a "hidden" command that can be used by, say, field engineers to examine
    the device. (I leave doing this as an assignment to you.)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅如此，除非明确向最终用户或客户记录，通过ioctl接口使用的精确命令是未知的；因此，您应该在提供足够的细节给其他团队或客户的同时记录接口。这带来了一个有趣的观点：您可能选择故意不记录某个ioctl命令；它现在是一个“隐藏”的命令，可以被现场工程师等人使用来检查设备。（我把这个任务留给你来完成。）
- en: 'The kernel documentation on ioctl includes this file: [https://www.kernel.org/doc/Documentation/ioctl/botching-up-ioctls.txt](https://www.kernel.org/doc/Documentation/ioctl/botching-up-ioctls.txt).
    Though biased toward kernel graphics stack devs, it describes typical design mistakes,
    trade-offs, and more.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: ioctl的内核文档包括这个文件：[https://www.kernel.org/doc/Documentation/ioctl/botching-up-ioctls.txt](https://www.kernel.org/doc/Documentation/ioctl/botching-up-ioctls.txt)。虽然偏向于内核图形堆栈开发人员，但它描述了典型的设计错误、权衡和更多内容。
- en: Fantastic – you're almost done! You have learned how to interface a kernel module
    or driver with a user mode process or thread (within a user space application)
    via various technologies. We began with procfs, then moved on to using sysfs and
    debugfs. The netlink socket and the ioctl system call completed our look at these
    interfacing methods.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了 - 你快完成了！您已经学会了如何通过各种技术将内核模块或驱动程序与用户模式进程或线程（在用户空间应用程序内）进行接口。我们从procfs开始，然后转向使用sysfs和debugfs。netlink套接字和ioctl系统调用完成了我们对这些接口方法的研究。
- en: But with all this choice, which one should you actually use on a project? The
    next section will help you make this decision by providing a quick comparison
    between these various interfacing methods.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在所有这些选择中，项目中应该实际使用哪种？下一节将通过快速比较这些不同的接口方法来帮助您做出决定。
- en: Comparing the interfacing methods – a table
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口方法的比较 - 表格
- en: 'In this section, we have created a quick comparison table of the various user-kernel
    interfacing methods that were described in this chapter, based on a few parameters:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们根据一些参数创建了一个快速比较表，列出了本章中描述的各种用户-内核接口方法：
- en: '| **Parameter /Interfacing method** | **procfs** | **sysfs** | **        debugfs**
    | **netlink socket** | **ioctl** |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| **参数/接口方法** | **procfs** | **sysfs** | **        debugfs** | **netlink socket**
    | **ioctl** |'
- en: '| **Ease of development** | Easy to learn and use. | (Relatively) easy to learn
    and use. | (Very) easy to learn and use. | Harder; have to write user space C
    + driver code + understand socket APIs. | Fair/harder; have to write user space
    C + driver code. |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| **开发的便利性** | 易于学习和使用。 | （相对）易于学习和使用。 | （非常）易于学习和使用。 | 更难；必须编写用户空间C + 驱动程序代码
    + 理解套接字API。 | 公平/更难；必须编写用户空间C + 驱动程序代码。 |'
- en: '| **Appropriate for what use** | Core kernel *only* (a few older drivers may
    still use it); best avoided by drivers. | Device driver interfacing. | Driver
    (and other) interfacing for production and debug purposes. | Various interfacing:
    users include device drivers, core networking code, the udev system, and more.
    | Device driver interfacing mostly (includes many). |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| **适用于什么用途** | 仅适用于核心内核（一些较旧的驱动程序可能仍在使用）；最好避免使用驱动程序。| 设备驱动程序接口。| 用于生产和调试目的的驱动程序（和其他）接口。|
    各种接口：用户包括设备驱动程序、核心网络代码、udev系统等。| 主要用于设备驱动程序接口（包括许多）。'
- en: '| **Interface visibility** | Visible to all; use permissions to control access.
    | Visible to all; use permissions to control access. | Visible to all; use permissions
    to control access. | Hidden from the filesystem; doesn''t pollute the kernel namespace.
    | Hidden from the filesystem; doesn''t pollute the kernel namespace. |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: 接口可见性 | 对所有人可见；使用权限来控制访问。| 对所有人可见；使用权限来控制访问。| 对所有人可见；使用权限来控制访问。| 从文件系统中隐藏；不会污染内核命名空间。|
    从文件系统中隐藏；不会污染内核命名空间。
- en: '| **Upstream kernel ABI for driver/module authors*** | Usage in drivers is
    deprecated for mainline. | The "right way"; the formally accepted approach to
    interface drivers with user space. | Well supported and heavily used in mainline
    by drivers and other products. | Well supported (since 2.2). | Well supported.
    |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| **驱动程序/模块作者的上游内核ABI*** | 驱动程序中的使用已在主线中弃用。| “正确的方式”；与用户空间接口驱动程序的正式接受方法。| 在主线中得到很好的支持并被驱动程序和其他产品广泛使用。|
    得到很好的支持（自2.2版以来）。| 得到很好的支持。'
- en: '| **Useful for (driver) debugging purposes**  | Yes (although not supposed
    to in mainline). | No/not ideal. | Yes, very useful! "No rules" by design. | No/not
    ideal. | Yes; (even) via hidden commands. |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| **用于（驱动程序）调试目的** | 是的（尽管在主线中不应该）。| 不是/不理想。| 是的，非常有用！按设计“没有规则”。| 不是/不理想。|
    是的；（甚至）通过隐藏命令。'
- en: '* As we mentioned earlier, the kernel community documents that procfs, sysfs,
    and debugfs are all *ABIs; *their stability and lifespan isn''t guaranteed. While
    that is the formal stance adopted by the community, the reality is that plenty
    of actual interfaces that use these filesystems have become de facto ones used
    by products in the real world. Nevertheless, we should follow the kernel community''s
    "rules" and guidelines regarding their usage.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '* 正如我们之前提到的，内核社区文件procfs、sysfs和debugfs都是*ABI；它们的稳定性和寿命没有得到保证。虽然这是社区采纳的正式立场，但实际上使用这些文件系统的许多实际接口已成为现实世界中产品使用的事实接口。然而，我们应该遵循内核社区关于它们使用的“规则”和指南。'
- en: Summary
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered an important aspect of device driver authors – how
    exactly you can *interface between user and kernel  (driver) space*. We walked
    you through several interfacing methods; we began with an older one, which is
    interfacing via the venerable proc filesystem (and then mentioned why it's not
    the preferred method for driver authors). We then moved on to interfacing via
    the newer 2.6-based *sysfs.* This turns out to be *the* preferred interface for
    the user space, at least for a device driver. Sysfs has limitations, though (recall
    the one-value-per-sysfs-file rule). Thus, using the completely free-format *debugfs*
    interfacing technique makes writing debug (and other) interfaces very simple and
    powerful indeed. The netlink socket is a powerful interfacing technology and is
    used by the network subsystem, udev, and a few drivers; it does require some knowledge
    on socket programming and the kernel socket buffer, though. To perform generic
    command operations on device drivers, the ioctl system call turns out to be a
    tremendous multiplexer and is often used by device driver authors (and other components)
    to interface with the user space.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了设备驱动程序作者的一个重要方面-如何确切地*在用户和内核（驱动程序）空间之间进行接口*。我们向您介绍了几种接口方法；我们从一个较旧的接口开始，即通过古老的proc文件系统进行接口（然后提到了为什么这不是驱动程序作者首选的方法）。然后我们转向通过基于2.6的*sysfs*进行接口。这事实上是用户空间的*首选接口，至少对于设备驱动程序来说。然而，sysfs有局限性（回想一下每个sysfs文件一个值的规则）。因此，使用完全自由格式的*debugfs*接口技术确实使编写调试（和其他）接口变得非常简单和强大。netlink套接字是一种强大的接口技术，被网络子系统、udev和一些驱动程序使用；尽管需要一些关于套接字编程和内核套接字缓冲区的知识。对于设备驱动程序进行通用命令操作，ioctl系统调用是一个巨大的多路复用器，经常被设备驱动程序作者（和其他组件）用于与用户空间进行接口。
- en: Armed with this knowledge, you are now in a position to practically integrate
    your driver-level code with user space applications (or scripts); often, a user
    mode **graphical user interface** (**GUI**) will want to display some values that
    have been received from the kernel or device driver. You now know how to pass
    these values from the kernel space device driver!
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握了这些知识，您现在可以实际将您的驱动程序级代码与用户空间应用程序（或脚本）集成；通常，用户模式**图形用户界面**（**GUI**）将希望显示从内核或设备驱动程序接收到的一些值。您现在知道如何将这些值从内核空间设备驱动程序传递！
- en: 'In the next chapter, you will learn about a typical task driver authors must
    perform: working with hardware chip memory! Do ensure you''re clear on this chapter''s
    material, work on the exercises provided, review the *Further reading* resources,
    and then dive into the next chapter. See you there!'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习到一个典型的任务驱动程序作者必须执行的任务：与硬件芯片内存打交道！确保您对本章的内容清楚，完成提供的练习，查阅*进一步阅读*资源，然后深入下一章。到时见！
- en: Questions
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: '`sysfs_on_misc`: *sysfs assignment #1*: Extend one of the `misc` device drivers
    we wrote in [Chapter 1](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml), *Writing
    a Simple misc Character Device Driver*; set up two sysfs files and their read/write
    callbacks; test them from user space.'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sysfs_on_misc`：*sysfs分配#1*：扩展我们在[第1章](239d8da6-0342-441a-823e-d3766f0d97b6.xhtml)中编写的一个`misc`设备驱动程序；设置两个sysfs文件及其读/写回调；从用户空间进行测试。'
- en: '`sysfs_addrxlate`: *sysfs assignment #2 (a bit more advanced)*: *Address translation:*
    Exploiting the knowledge gained from this chapter and from the *Linux Kernel Programming* book, *Chapter
    7, Memory Management Internals - Essentials,* the *Direct-mapped RAM and address
    translation* section, write a simple platform driver that provides two sysfs interface
    files called `addrxlate_kva2pa` and `addrxlate_pa2kva`. Writing a kva into the
    sysfs file, `addrxlate_kva2pa`, should have the driver read and translate the
    *kva* into its corresponding **physical address** (**pa**); then, reading from
    the same file should cause the *pa* to be displayed. Do the same with the `addrxlate_pa2kva`
    sysfs file.'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sysfs_addrxlate`：*sysfs分配#2（稍微高级一点）*：*地址转换：*利用本章和*Linux内核编程*书中获得的知识，*第7章，内存管理内部-基本知识*，*直接映射RAM和地址转换*部分，编写一个简单的平台驱动程序，提供两个名为`addrxlate_kva2pa`和`addrxlate_pa2kva`的sysfs接口文件。将kva写入sysfs文件`addrxlate_kva2pa`，驱动程序应读取并将*kva*转换为其对应的**物理地址**（**pa**）；然后，从同一文件中读取应导致显示*pa*。对`addrxlate_pa2kva`
    sysfs文件执行相同操作。'
- en: '`dbgfs_disp_pgoff`: *debugfs assignment #1*: Write a kernel module that sets
    up a debugfs file here: `<debugfs_mount_point>/dbgfs_disp_pgoff`. When read, it
    should display (to user space) the current value of the `PAGE_OFFSET` kernel macro.'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dbgfs_disp_pgoff`：*debugfs分配#1*：编写一个内核模块，在此处设置一个debugfs文件：`<debugfs_mount_point>/dbgfs_disp_pgoff`。在读取时，它应该显示（到用户空间）`PAGE_OFFSET`内核宏的当前值。'
- en: '`dbgfs_showall_threads`: *debugfs assignment #2* : Write a kernel module that
    sets up a debugfs file here: `<debugfs_mount_point>/dbgfs_showall_threads/dbgfs_showall_threads`.
    When read, it should display some attributes of every thread that''s alive. (This
    is similar to our code from the *Linux Kernel Programming* book here: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/ch6/foreach/thrd_showall](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/ch6/foreach/thrd_showall).
    Note that the threads are displayed *only* at insmod time; with a debugfs file,
    you can display information on all the threads at any time you choose to)!'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dbgfs_showall_threads`：*debugfs分配#2*：编写一个内核模块，在此处设置一个debugfs文件：`<debugfs_mount_point>/dbgfs_showall_threads/dbgfs_showall_threads`。在读取时，它应该显示每个活动线程的一些属性。（这类似于我们在*Linux内核编程*书中的代码：[https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/ch6/foreach/thrd_showall](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/ch6/foreach/thrd_showall)。请注意，线程仅在insmod时间显示*；*使用debugfs文件，您可以选择任何时间显示所有线程的信息）！'
- en: '*Suggested output is CSV format: *`TGID,PID,current,stack-start,name,#threads`. The
    `[name]` field in square brackets => kernel thread*;'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '*建议的输出格式为CSV格式：*`TGID,PID,current,stack-start,name,#threads`。方括号中的`[name]`字段=>内核线程*;*'
- en: '* `#threads` field should only display a positive integer*;* no output here
    implies a single-threaded process; for example: `130,130,0xffff9f8b3cd38000,0xffffc13280420000,[watchdogd]`)'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '*`#threads`字段应该只显示一个正整数*；*这里没有输出意味着单线程进程；例如：`130,130,0xffff9f8b3cd38000,0xffffc13280420000,[watchdogd]`)'
- en: '*ioctl assignment #1*: Using the provided `ch2/ioctl_intf/` code as a template,
    write a user space C application and a kernel space (char) device driver implementing
    the `ioctl` method. Add an ioctl command called `IOCTL_LLKD_IOCQPGOFF` to return
    the value of `PAGE_OFFSET` (within the kernel) to the user space.'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*ioctl分配#1*：使用提供的`ch2/ioctl_intf/`代码作为模板，编写一个用户空间C应用程序和一个内核空间（char）设备驱动程序，实现`ioctl`方法。添加一个名为`IOCTL_LLKD_IOCQPGOFF`的ioctl命令，以将`PAGE_OFFSET`（在内核中）的值返回给用户空间。'
- en: '`ioctl_undoc`: *ioctl assignment #2*: Using the provided `ch2/ioctl_intf/`
    code as a template, write a user space C application and a kernel space (char)
    device driver implementing the `ioctl` method. Add a driver context data structure
    (we used these in several examples), and then allocate and initialize it. Now,
    in addition to the three previous ioctl commands we used, set up a fourth undocumented
    command (you can call it `IOCTL_LLKD_IOCQDRVSTAT`). When queried from the user
    space via `ioctl(2)`, it must return the contents of the driver context data structure
    to the user space; the user space C app must print out the current content of
    every member of that structure.'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ioctl_undoc`：*ioctl分配#2*：使用提供的`ch2/ioctl_intf/`代码作为模板，编写一个用户空间C应用程序和一个内核空间（char）设备驱动程序，实现`ioctl`方法。添加一个驱动程序上下文数据结构（我们在几个示例中使用了这些），然后分配和初始化它。现在，除了我们使用的三个以前的ioctl命令之外，还设置第四个未记录的命令（您可以称之为`IOCTL_LLKD_IOCQDRVSTAT`）。当通过`ioctl(2)`从用户空间查询时，它必须将驱动程序上下文数据结构的内容返回给用户空间；用户空间C应用程序必须打印出该结构的每个成员的当前内容。'
- en: You will find some of the questions answered in the book's GitHub repo: [https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn).
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现一些问题的答案在书的GitHub存储库中：[https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn)。
- en: Further reading
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following links for more information on the topics covered
    in this chapter. Some more information on using the very common I2C protocol within
    a Linux device driver can be found here:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下链接，了解本章涵盖的主题的更多信息。有关在Linux设备驱动程序中使用非常常见的I2C协议的更多信息，请访问以下链接：
- en: An article on the I2C protocol basics: *How to use I2C in STM32F103C8T6? STM32
    I2C Tutorial*, March 2020: [https://www.electronicshub.org/how-to-use-i2c-in-stm32f103c8t6/](https://www.electronicshub.org/how-to-use-i2c-in-stm32f103c8t6/)
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关I2C协议基础知识的文章：*如何在STM32F103C8T6中使用I2C？STM32 I2C教程*，2020年3月：[https://www.electronicshub.org/how-to-use-i2c-in-stm32f103c8t6/](https://www.electronicshub.org/how-to-use-i2c-in-stm32f103c8t6/)
- en: 'Kernel documentation: Implementing I2C device drivers: [https://www.kernel.org/doc/html/latest/i2c/writing-clients.html](https://www.kernel.org/doc/html/latest/i2c/writing-clients.html)'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核文档：实现I2C设备驱动程序：[https://www.kernel.org/doc/html/latest/i2c/writing-clients.html](https://www.kernel.org/doc/html/latest/i2c/writing-clients.html)
