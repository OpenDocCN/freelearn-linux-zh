["```\n#include <linux/fb.h> \n```", "```\nstruct fb_var_screeninfo { \n   __u32 xres; /* visible resolution */ \n   __u32 yres; \n\n   __u32 xres_virtual; /* virtual resolution */ \n   __u32 yres_virtual; \n\n   __u32 xoffset; /* offset from virtual to visible resolution */ \n   __u32 yoffset; \n\n   __u32 bits_per_pixel; /* # of bits needed to hold a pixel */ \n   [...] \n\n   /* Timing: All values in pixclocks, except pixclock (of course) */ \n   __u32 pixclock;   /* pixel clock in ps (pico seconds) */ \n   __u32 left_margin;      /* time from sync to picture */ \n   __u32 right_margin; /* time from picture to sync */ \n   __u32 upper_margin; /* time from sync to picture */ \n   __u32 lower_margin; \n   __u32 hsync_len;  /* length of horizontal sync */ \n   __u32 vsync_len;  /* length of vertical sync */ \n   __u32 rotate; /* angle we rotate counter clockwise */ \n}; \n```", "```\nstruct fb_fix_screeninfo { \n   char id[16];      /* identification string eg \"TT Builtin\" */ \n   unsigned long smem_start;     /* Start of frame buffer mem */ \n                           /* (physical address) */ \n   __u32 smem_len;/* Length of frame buffer mem */ \n   __u32 type;    /* see FB_TYPE_*           */ \n   __u32 type_aux; /* Interleave for interleaved Planes */ \n   __u32 visual;   /* see FB_VISUAL_*  */  \n   __u16 xpanstep; /* zero if no hardware panning  */ \n   __u16 ypanstep;   /* zero if no hardware panning  */ \n   __u16 ywrapstep;  /* zero if no hardware ywrap    */ \n   __u32 line_length;  /* length of a line in bytes    */ \n   unsigned long mmio_start; /* Start of Memory Mapped I/O  \n *(physical address) \n */ \n   __u32 mmio_len;   /* Length of Memory Mapped I/O  */ \n   __u32 accel;      /* Indicate to driver which   */ \n                     /* specific chip/card we have */ \n   __u16 capabilities; /* see FB_CAP_* */ \n}; \n```", "```\nstruct fb_cmap { \n    __u32 start;   /* First entry */ \n    __u32 len;     /* Number of entries */ \n    __u16 *red;    /* Red values */ \n    __u16 *green;  /* Green values */ \n    __u16 *blue;   /* Blue values */ \n    __u16 *transp; /* Transparency. Discussed later on */ \n}; \n```", "```\nstruct fb_info { \n    [...] \n    struct fb_var_screeninfo var; /* Variable screen information. \n                                   Discussed earlier. */ \n    struct fb_fix_screeninfo fix; /* Fixed screen information. */ \n    struct fb_cmap cmap;          /* Color map. */ \n    struct fb_ops *fbops;         /* Driver operations.*/ \n    char __iomem *screen_base;    /* Frame buffer's \n                                   virtual address */ \n    unsigned long screen_size;    /* Frame buffer's size */ \n    [...] \n   struct device *device;        /* This is the parent */ \nstruct device *dev;           /* This is this fb device */ \n#ifdef CONFIG_FB_BACKLIGHT \n      /* assigned backlight device */ \n      /* set before framebuffer registration,  \n         remove after unregister */ \n      struct backlight_device *bl_dev; \n\n      /* Backlight level curve */ \n      struct mutex bl_curve_mutex;   \n      u8 bl_curve[FB_BACKLIGHT_LEVELS]; \n#endif \n[...] \nvoid *par; /* Pointer to private memory */ \n}; \n```", "```\nstruct fb_info *framebuffer_alloc(size_t size, struct device *dev) \n```", "```\nvoid framebuffer_release(struct fb_info *info) \n```", "```\nint register_framebuffer(struct fb_info *fb_info) \n```", "```\nint unregister_framebuffer(struct fb_info *fb_info) \n```", "```\n    struct fb_ops { \n   /* open/release and usage marking */ \n   struct module *owner; \n   int (*fb_open)(struct fb_info *info, int user); \n   int (*fb_release)(struct fb_info *info, int user); \n\n   /* For framebuffers with strange nonlinear layouts or that do not \n    * work with normal memory mapped access \n    */ \n   ssize_t (*fb_read)(struct fb_info *info, char __user *buf, \n                  size_t count, loff_t *ppos); \n   ssize_t (*fb_write)(struct fb_info *info, const char __user *buf, \n                   size_t count, loff_t *ppos); \n\n   /* checks var and eventually tweaks it to something supported, \n    * DO NOT MODIFY PAR */ \n   int (*fb_check_var)(struct fb_var_screeninfo *var, struct fb_info *info); \n\n   /* set the video mode according to info->var */ \n   int (*fb_set_par)(struct fb_info *info); \n\n   /* set color register */ \n   int (*fb_setcolreg)(unsigned regno, unsigned red, unsigned green, \n                   unsigned blue, unsigned transp, struct fb_info *info); \n\n   /* set color registers in batch */ \n   int (*fb_setcmap)(struct fb_cmap *cmap, struct fb_info *info); \n\n   /* blank display */ \n   int (*fb_blank)(int blank_mode, struct fb_info *info); \n\n   /* pan display */ \n   int (*fb_pan_display)(struct fb_var_screeninfo *var, struct fb_info *info); \n\n   /* Draws a rectangle */ \n   void (*fb_fillrect) (struct fb_info *info, const struct fb_fillrect *rect); \n   /* Copy data from area to another */ \n   void (*fb_copyarea) (struct fb_info *info, const struct fb_copyarea *region); \n   /* Draws a image to the display */ \n   void (*fb_imageblit) (struct fb_info *info, const struct fb_image *image); \n\n   /* Draws cursor */ \n   int (*fb_cursor) (struct fb_info *info, struct fb_cursor *cursor); \n\n   /* wait for blit idle, optional */ \n   int (*fb_sync)(struct fb_info *info); \n\n   /* perform fb specific ioctl (optional) */ \n   int (*fb_ioctl)(struct fb_info *info, unsigned int cmd, \n               unsigned long arg); \n\n   /* Handle 32bit compat ioctl (optional) */ \n   int (*fb_compat_ioctl)(struct fb_info *info, unsigned cmd, \n               unsigned long arg); \n\n   /* perform fb specific mmap */ \n   int (*fb_mmap)(struct fb_info *info, struct vm_area_struct *vma); \n\n   /* get capability given var */ \n   void (*fb_get_caps)(struct fb_info *info, struct fb_blit_caps *caps, \n                   struct fb_var_screeninfo *var); \n\n   /* teardown any resources to do with this framebuffer */ \n   void (*fb_destroy)(struct fb_info *info); \n   [...] \n}; \n```", "```\nstatic struct fb_ops myfb_ops = { \n   .owner        = THIS_MODULE, \n   .fb_check_var = myfb_check_var, \n   .fb_set_par   = myfb_set_par, \n   .fb_setcolreg = myfb_setcolreg, \n   .fb_fillrect  = cfb_fillrect, /* Those three hooks are */  \n   .fb_copyarea  = cfb_copyarea, /* non accelerated and */ \n   .fb_imageblit = cfb_imageblit, /* are provided by kernel */ \n   .fb_blank     = myfb_blank, \n}; \n```", "```\nstatic int myfb_probe(struct platform_device *pdev) \n{ \n   struct fb_info *info; \n   struct resource *res; \n    [...] \n\n   dev_info(&pdev->dev, \"My framebuffer driver\\n\"); \n\n/* \n * Query resource, like DMA channels, I/O memory, \n * regulators, and so on. \n */ \n   res = platform_get_resource(pdev, IORESOURCE_MEM, 0); \n   if (!res) \n         return -ENODEV; \n   /* use request_mem_region(), ioremap() and so on */ \n    [...] \n    pwr = regulator_get(&pdev->dev, \"lcd\"); \n\n   info = framebuffer_alloc(sizeof( \nstruct my_private_struct), &pdev->dev); \n   if (!info) \n         return -ENOMEM; \n\n   /* Device init and default info value*/ \n   [...] \n   info->fbops = &myfb_ops; \n\n    /* Clock setup, using devm_clk_get() and so on */ \n    [...] \n\n    /* DMA setup using dma_alloc_coherent() and so on*/   \n    [...] \n\n    /* Register with the kernel */ \n   ret = register_framebuffer(info); \n\n   hardware_enable_controller(my_private_struct); \n   return 0; \n} \n```", "```\nstatic int myfb_remove(struct platform_device *pdev) \n{ \n\n   /* iounmap() memory and release_mem_region() */ \n   [...] \n   /* Reverse DMA, dma_free_*();*/ \n   [...] \n\n   hardware_disable_controller(fbi); \n\n    /* first unregister, */ \n   unregister_framebuffer(info); \n    /* and then free the memory */ \n   framebuffer_release(info); \n\n   return 0; \n} \n```", "```\nint (*fb_check_var)(struct fb_var_screeninfo *var, \nstruct fb_info *info); \n```", "```\nstatic int myfb_check_var(struct fb_var_screeninfo *var, \nstruct fb_info *info) \n{ \n   if (var->xres_virtual < var->xres) \n         var->xres_virtual = var->xres; \n\n   if (var->yres_virtual < var->yres) \n         var->yres_virtual = var->yres; \n\n   if ((var->bits_per_pixel != 32) && \n(var->bits_per_pixel != 24) && \n(var->bits_per_pixel != 16) && \n(var->bits_per_pixel != 12) && \n       (var->bits_per_pixel != 8)) \n         var->bits_per_pixel = 16; \n\n   switch (var->bits_per_pixel) { \n   case 8: \n         /* Adjust red*/ \n         var->red.length = 3; \n         var->red.offset = 5; \n         var->red.msb_right = 0; \n\n         /*adjust green*/ \n         var->green.length = 3; \n         var->green.offset = 2; \n         var->green.msb_right = 0; \n\n         /* adjust blue */ \n         var->blue.length = 2; \n         var->blue.offset = 0; \n         var->blue.msb_right = 0; \n\n         /* Adjust transparency */ \n         var->transp.length = 0; \n         var->transp.offset = 0; \n         var->transp.msb_right = 0; \n         break; \n   case 16: \n         [...] \n         break; \n   case 24: \n         [...] \n         break; \n   case 32: \n         var->red.length = 8; \n         var->red.offset = 16; \n         var->red.msb_right = 0; \n\n         var->green.length = 8; \n         var->green.offset = 8; \n         var->green.msb_right = 0; \n\n         var->blue.length = 8; \n         var->blue.offset = 0; \n         var->blue.msb_right = 0; \n\n         var->transp.length = 8; \n         var->transp.offset = 24; \n         var->transp.msb_right = 0; \n         break; \n   } \n\n   /* \n * Any other field in *var* can be adjusted \n * like var->xres,      var->yres, var->bits_per_pixel, \n * var->pixclock and so on. \n */ \n   return 0; \n} \n```", "```\nstatic int myfb_set_par(struct fb_info *info) \n{ \n   struct fb_var_screeninfo *var = &info->var; \n\n   /* Make some compute or other sanity check */ \n   [...] \n\n    /* \n     * This function writes value to the hardware, \n     * in the appropriate registers \n     */ \n   set_controller_vars(var, info); \n\n   return 0; \n} \n```", "```\nint (*fb_blank)(int blank_mode, struct fb_info *info) \n```", "```\nenum { \n   /* screen: unblanked, hsync: on,  vsync: on */ \n   FB_BLANK_UNBLANK       = VESA_NO_BLANKING, \n\n   /* screen: blanked,   hsync: on,  vsync: on */ \n   FB_BLANK_NORMAL        = VESA_NO_BLANKING + 1, \n\n   /* screen: blanked,   hsync: on,  vsync: off */ \n   FB_BLANK_VSYNC_SUSPEND = VESA_VSYNC_SUSPEND + 1, \n\n   /* screen: blanked,   hsync: off, vsync: on */ \n   FB_BLANK_HSYNC_SUSPEND = VESA_HSYNC_SUSPEND + 1, \n\n   /* screen: blanked,   hsync: off, vsync: off */ \n   FB_BLANK_POWERDOWN     = VESA_POWERDOWN + 1 \n}; \n```", "```\nstatic int myfb_blank(int blank_mode, struct fb_info *info) \n{ \n   pr_debug(\"fb_blank: blank=%d\\n\", blank); \n\n   switch (blank) { \n   case FB_BLANK_POWERDOWN: \n   case FB_BLANK_VSYNC_SUSPEND: \n   case FB_BLANK_HSYNC_SUSPEND: \n   case FB_BLANK_NORMAL: \n         myfb_disable_controller(fbi); \n         break; \n\n   case FB_BLANK_UNBLANK: \n         myfb_enable_controller(fbi); \n         break; \n   } \n   return 0; \n} \n```", "```\n#include <stdlib.h> \n#include <unistd.h> \n#include <stdio.h> \n#include <fcntl.h> \n#include <linux/fb.h> \n#include <sys/mman.h> \n#include <sys/ioctl.h> \n\n#define FBCTL(_fd, _cmd, _arg)         \\ \n    if(ioctl(_fd, _cmd, _arg) == -1) { \\ \n        ERROR(\"ioctl failed\");         \\ \n        exit(1); } \n\nint main() \n{ \n    int fd; \n    int x, y, pos; \n    int r, g, b; \n    unsigned short color; \n    void *fbmem; \n\n    struct fb_var_screeninfo var_info; \n    struct fb_fix_screeninfo fix_info; \n\n    fd = open(FBVIDEO, O_RDWR); \n    if (tfd == -1 || vfd == -1) { \n        exit(-1); \n    } \n\n    /* Gather variable screen info (virtual and visible) */ \n    FBCTL(fd, FBIOGET_VSCREENINFO, &var_info); \n\n    /* Gather fixed screen info */ \n    FBCTL(fd, FBIOGET_FSCREENINFO, &fix_info); \n\n    printf(\"****** Frame Buffer Info ******\\n\"); \n    printf(\"Visible: %d,%d  \\nvirtual: %d,%d \\n  line_len %d\\n\", \n           var_info.xres, this->var_info.yres, \n           var_info.xres_virtual, var_info.yres_virtual, \n           fix_info.line_length); \n    printf(\"dim %d,%d\\n\\n\", var_info.width, var_info.height); \n\n    /* Let's mmap frame buffer memory */ \n    fbmem = mmap(0, v_var.yres_virtual * v_fix.line_length, \\ \n                     PROT_WRITE | PROT_READ, \\ \n                     MAP_SHARED, fd, 0); \n\n    if (fbmem == MAP_FAILED) { \n        perror(\"Video or Text frame bufer mmap failed\"); \n        exit(1); \n    } \n\n    /* upper left corner (100,100). The square is 300px width */ \n    for (y = 100; y < 400; y++) { \n        for (x = 100; x < 400; x++) { \n            pos = (x + vinfo.xoffset) * (vinfo.bits_per_pixel / 8) \n                   +   (y + vinfo.yoffset) * finfo.line_length; \n\n            /* if 32 bits per pixel */ \n            if (vinfo.bits_per_pixel == 32) { \n                /* We prepare some blue color */ \n                *(fbmem + pos) = 100; \n\n                /* adding a little green */ \n                *(fbmem + pos + 1) = 15+(x-100)/2; \n\n                /* With lot of read */ \n                *(fbmem + pos + 2) = 200-(y-100)/5; \n\n                /* And no transparency */ \n                *(fbmem + pos + 3) = 0; \n            } else  { /* This assume 16bpp */ \n                r = 31-(y-100)/16; \n                g = (x-100)/6; \n                b = 10; \n\n                /* Compute color */  \n                color = r << 11 | g << 5 | b; \n                *((unsigned short int*)(fbmem + pos)) = color; \n            } \n        } \n    } \n\n    munmap(fbp, screensize); \n    close(fbfd); \n    return 0; \n} \n```", "```\n # cat /dev/fb0 > my_image \n\n```", "```\n # cat my_image > /dev/fb0 \n\n```", "```\n # echo 0 > /sys/class/graphics/fb0/blank\n\n    # echo 1 > /sys/class/graphics/fb0/blank\n\n```"]