- en: Character Device Drivers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符设备驱动程序
- en: 'Character devices transfer data to or from a user application by means of characters,
    in a stream manner (one character after another), like a serial port does. A character
    device driver exposes the properties and functionalities of a device by means
    of a special file in the `/dev` directory, which one can use to exchange data
    between the device and user application, and also allows you to control the real
    physical device. This is the basic concept of Linux that says *everything is a
    file* . A character device driver represents the most basic device driver in the
    kernel source. Character devices are represented in the kernel as instances of
    `struct cdev` , defined in `include/linux/cdev.h` :'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 字符设备通过字符的方式（一个接一个）向用户应用程序传输数据，就像串行端口一样。字符设备驱动程序通过`/dev`目录中的特殊文件公开设备的属性和功能，可以用来在设备和用户应用程序之间交换数据，并且还允许你控制真实的物理设备。这是Linux的基本概念，即*一切都是文件*。字符设备驱动程序代表内核源代码中最基本的设备驱动程序。字符设备在内核中表示为`include/linux/cdev.h`中定义的`struct
    cdev`的实例：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This chapter will walk through the specificities of character device drivers,
    explain how they create, identify, and register the devices with the system, and
    also give a better overview of the device file methods, which are methods by which
    the kernel exposes the device capabilities to user space, accessible by using
    file related system calls (`read` , `write` , `select` , `open` , `close` and
    so on), described in `struct file_operations` structures, which you have certainly
    heard of before.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍字符设备驱动程序的具体特性，解释它们如何创建、识别和向系统注册设备，还将更好地概述设备文件方法，这些方法是内核向用户空间公开设备功能的方法，可通过使用与文件相关的系统调用（`read`，`write`，`select`，`open`，`close`等）访问，描述在`struct
    file_operations`结构中，这些你肯定以前听说过。
- en: The concept behind major and minor
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要和次要背后的概念
- en: 'Character devices are populated in the `/dev` directory. Do note that, they
    are not only files present in that directory. A character device file is recognizable
    to its type, which we can display thanks to the command `ls -l` . Major and minor
    identify and tie the devices with the drivers. Let us see how it works, by listing
    the content of the `*/dev*` directory (`ls -l /dev` ):'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 字符设备位于`/dev`目录中。请注意，它们不是该目录中唯一的文件。字符设备文件可以通过其类型识别，我们可以通过`ls -l`命令显示。主要和次要标识并将设备与驱动程序绑定。让我们看看它是如何工作的，通过列出`*/dev*`目录的内容（`ls
    -l /dev`）：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Given the preceding excerpt, the first character of the first column identifies
    the file type. Possible values are:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 给定上述摘录，第一列的第一个字符标识文件类型。可能的值有：
- en: '`c` : This is for character device files'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`：这是用于字符设备文件'
- en: '`b` : This is for block device file'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`：这是用于块设备文件'
- en: '`l` : This is for symbolic link'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l`：这是用于符号链接'
- en: '`d` : This is for directory'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`：这是用于目录'
- en: '`s` : This is for socket'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`：这是用于套接字'
- en: '`p` : This is for named pipe'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p`：这是用于命名管道'
- en: For `b` and `c` file types, the fifth and sixth columns right before the date
    respect the <`X, Y` > pattern. `X` represents the major, and `Y` is the minor.
    For example, the third line is <`1, 2` > and the last one is <`7, 3` >. That is
    one of the classical methods for identifying a character device file from user
    space, as well as its major and minor.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`b`和`c`文件类型，在日期之前的第五和第六列遵循<`X，Y`>模式。`X`代表主要号，`Y`是次要号。例如，第三行是<`1，2`>，最后一行是<`7，3`>。这是一种从用户空间识别字符设备文件及其主要和次要的经典方法之一。
- en: The kernel holds the numbers that identify a device in `dev_t` type variables,
    which are simply `u32` (32-bit unsigned long). The major is represented with only
    12 bits, whereas the minor is coded on the 20 remaining bits.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 内核在`dev_t`类型变量中保存标识设备的数字，它们只是`u32`（32位无符号长整型）。主要号仅用12位表示，而次要号编码在剩余的20位上。
- en: 'As one can see in `include/linux/kdev_t.h` , given a `dev_t` type variable,
    one may need to extract the minor or the major. The kernel provides a macro for
    these purposes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如可以在`include/linux/kdev_t.h`中看到的，给定一个`dev_t`类型的变量，可能需要提取次要或主要。内核为这些目的提供了一个宏：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On the other hand, you may have a minor and a major, and need to build a `dev_t`
    . The macro you should use is `MKDEV(int major, int minor);` :'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你可能有一个次要和一个主要，需要构建一个`dev_t`。你应该使用的宏是`MKDEV(int major, int minor);`：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The device is registered with a major number that identifies the device, and
    a minor, which one may use as an array index to a local list of devices, since
    one instance of the same driver may handle several devices while different drivers
    may handle different devices of the same type.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 设备注册时使用一个标识设备的主要号和一个次要号，可以将次要号用作本地设备列表的数组索引，因为同一驱动程序的一个实例可能处理多个设备，而不同的驱动程序可能处理相同类型的不同设备。
- en: Device number allocation and freeing
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备号分配和释放
- en: 'Device numbers identify device files across the system. That means, there are
    two ways to allocate these device numbers (actually major and minor):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 设备号标识系统中的设备文件。这意味着，有两种分配这些设备号（实际上是主要和次要）的方法：
- en: '**Statically** : Guessing a major not yet used by another driver using the
    `register_chrdev_region()` function. One should avoid using this as much as possible.
    Its prototype looks this:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态**：使用`register_chrdev_region()`函数猜测尚未被其他驱动程序使用的主要号。应尽量避免使用这个。它的原型如下：'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This method returns `0` on success, or a negative error code on failure. `first`
    is made of the major number that we need along with the first minor of the desired
    range. One should use `MKDEV(ma,mi)` . `count` is the number of consecutive device
    numbers required, and `name` should be the name of the associated device or driver.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在成功时返回`0`，在失败时返回负错误代码。`first`由我们需要的主要号和所需范围的第一个次要号组成。应该使用`MKDEV(ma,mi)`。`count`是所需的连续设备号的数量，`name`应该是相关设备或驱动程序的名称。
- en: '**Dynamically** : Letting the kernel do the job for us, using the `alloc_chrdev_region()`
    function. This is the recommended way to obtain a valid device number. Its prototype
    is as follows:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态地**：让内核为我们做这件事，使用`alloc_chrdev_region()`函数。这是获取有效设备号的推荐方法。它的原型如下：'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This method returns `0` on success, or a negative error code on failure. `dev`
    is the ony output parameter. It represents the first number the kernel assigned.
    `firstminor` is the first of the requested range of minor numbers, `count` the
    number of minors one requires, and `name` should be the name of the associated
    device or driver.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在成功时返回`0`，在失败时返回负错误代码。`dev`是唯一的输出参数。它代表内核分配的第一个号码。`firstminor`是请求的次要号码范围的第一个，`count`是所需的次要号码数量，`name`应该是相关设备或驱动程序的名称。
- en: 'The difference between the two is that with the former, one should know in
    advance what number we need. This is registration: one tells the kernel what device
    numbers we want. This may be used for pedagogic purposes, and works as long as
    the only user of the driver is you. When it comes to loading the driver on another
    machine, there is no guarantee the chosen number is free on that machine, and
    this will lead to conflicts and trouble. The second method is cleaner and much
    safer, since the kernel is responsible for guessing the right numbers for us.
    We do not even have to care about what the behavior would be on loading the module
    on to another machine, since the kernel will adapt accordingly.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的区别在于，对于前者，我们应该预先知道我们需要什么号码。这是注册：告诉内核我们想要什么设备号。这可能用于教学目的，并且只要驱动程序的唯一用户是您，它就可以工作。但是当要在另一台机器上加载驱动程序时，无法保证所选的号码在该机器上是空闲的，这将导致冲突和麻烦。第二种方法更干净、更安全，因为内核负责为我们猜测正确的号码。我们甚至不必关心在将模块加载到另一台机器上时的行为会是什么，因为内核会相应地进行调整。
- en: Anyway, the preceding functions are generally not called directly from the driver,
    but masked by the framework on which the driver relies (IIO framework, input framework,
    RTC, and so on), by means of dedicated API. These frameworks are all discussed
    in further chapters in the book.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，通常不直接从驱动程序中调用前面的函数，而是通过驱动程序依赖的框架（IIO框架、输入框架、RTC等）通过专用API进行屏蔽。这些框架在本书的后续章节中都有讨论。
- en: Introduction to device file operations
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备文件操作简介
- en: 'Operations that one can perform on files depend on the drivers that manage
    those files. Such operations are defined in the kernel as instances of `struct
    file_operations` . `struct file_operations` exposes a set of callbacks that will
    handle any user-space system call on a file. For example, if one wants users to
    be able to perform a `write` on the file representing our device, one must implement
    the callback corresponding to that `write` function and add it into the `struct
    file_operations` that will be tied to your device. Let''s fill in a file operations
    structure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在文件上执行的操作取决于管理这些文件的驱动程序。这些操作在内核中被定义为`struct file_operations`的实例。`struct file_operations`公开了一组回调函数，这些函数将处理文件上的任何用户空间系统调用。例如，如果希望用户能够对表示我们设备的文件执行`write`操作，就必须实现与`write`函数对应的回调，并将其添加到与您的设备绑定的`struct
    file_operations`中。让我们填写一个文件操作结构：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding excerpt only lists important methods of the structure, especially
    the ones that are relevant for the needs of this book. One can find the full description
    in `include/linux/fs.h` in kernel sources. Each of these callbacks is linked with
    a system call, and none of them is mandatory. When a user code calls a files-related
    system call on a given file, the kernel looks for the driver responsible for that
    file (especially the one that created the file), locates its `struct file_operations`
    structure, and checks whether the method that matches the system call is defined
    or not. If yes, it simply runs it. If not, it returns an error code that varies
    depending on the system call. For example, an undefined `(*mmap)` method will
    return `-ENODEV` to user, whereas an undefined `(*write)` method will return `-EINVAL`
    .
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的摘录只列出了结构的重要方法，特别是对本书需求相关的方法。可以在内核源码的`include/linux/fs.h`中找到完整的描述。这些回调函数中的每一个都与系统调用相关联，没有一个是强制性的。当用户代码对给定文件调用与文件相关的系统调用时，内核会寻找负责该文件的驱动程序（特别是创建文件的驱动程序），找到其`struct
    file_operations`结构，并检查与系统调用匹配的方法是否已定义。如果是，就简单地运行它。如果没有，就返回一个错误代码，这取决于系统调用。例如，未定义的`(*mmap)`方法将返回`-ENODEV`给用户，而未定义的`(*write)`方法将返回`-EINVAL`。
- en: File representation in the kernel
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核中的文件表示
- en: 'The kernel describes files as instances of struct inode (not struct file) structure,
    defined in `include/linux/fs.h` :'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 内核将文件描述为`struct inode`的实例（而不是`struct file`），该结构在`include/linux/fs.h`中定义：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `struct inode` is a filesystem data structure holding information, which
    is only relevant to the OS, about a file (whatever its type, character, block,
    pipe, and so on) or directory (yes!! from a kernel point of view, a directory
    is a file that on entry points to other files) on disk.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct inode`是一个文件系统数据结构，保存着关于文件（无论其类型是字符、块、管道等）或目录（是的！从内核的角度来看，目录是一个文件，它指向其他文件）的与操作系统相关的信息。'
- en: 'The `struct file` structure (also defined in `include/linux/fs.h` ) is actually
    a higher level of file description that represents an open file in the kernel
    and which relies on the lower `struct inode` data structure:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct file`结构（也在`include/linux/fs.h`中定义）实际上是内核中表示打开文件的更高级别的文件描述，它依赖于较低级别的`struct
    inode`数据结构：'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The difference between `struct inode` and `struct file` is that an inode doesn''t
    track the current position within the file or the current mode. It only contains
    stuff that helps the OS find the contents of the underlying file structure (pipe,
    directory, regular disk file, block/character device file, and so on). On the
    other hand, the `struct file` is used as a generic structure (it actually holds
    a pointer to a `struct inode` structure) that represents and open file and provides
    a set of functions related to methods one can perform on the underlying file structure.
    Such methods are: `open` , `write` , `seek` , `read` , `select` , and so on. All
    this reinforces the philosophy of UNIX systems that says *everything is file*
    .'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct inode`和`struct file`之间的区别在于inode不跟踪文件内的当前位置或当前模式。它只包含帮助操作系统找到底层文件结构（管道、目录、常规磁盘文件、块/字符设备文件等）内容的东西。另一方面，`struct
    file`被用作通用结构（实际上它持有一个指向`struct inode`结构的指针），代表并打开文件并提供一组与在底层文件结构上执行的方法相关的函数。这些方法包括：`open`，`write`，`seek`，`read`，`select`等。所有这些都强调了UNIX系统的哲学，即*一切皆为文件*。'
- en: In other words, a `struct inode` represents a file in the kernel, and a `struct
    file` describes it when it is actually open. There may be different file descriptors
    that represent the same file opened several times, but these will point to the
    same inode.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`struct inode`代表内核中的一个文件，`struct file`描述了它在实际打开时的情况。可能有不同的文件描述符代表同一个文件被多次打开，但这些将指向相同的inode。
- en: Allocating and registering a character device
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配和注册字符设备
- en: 'Character devices are represented in the kernel as instances of `struct cdev`
    . When writing a character device driver, your goal is to finally create and register
    an instance of that structure associated with a `struct file_operations` , exposing
    a set of operations (functions) the user-space can perform on the device. To reach
    that goal, there are some steps we must go through, which are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核中，字符设备被表示为`struct cdev`的实例。当编写字符设备驱动程序时，您的目标是最终创建并注册与`struct file_operations`相关联的该结构的实例，暴露一组用户空间可以对设备执行的操作（函数）。为了实现这个目标，我们必须经历一些步骤，如下所示：
- en: Reserve a major and a range of minors with `alloc_chrdev_region()` .
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`alloc_chrdev_region()`保留一个主设备号和一系列次设备号。
- en: Create a class for your devices with `class_create(),` visible in `/sys/class/`
    .
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`class_create()`为您的设备创建一个类，在`/sys/class/`中可见。
- en: Set up a `struct file_operation` (to be given to `cdev_init` ), and for each
    device one needs to create, call `cdev_init()` and `cdev_add()` to register the
    device.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个`struct file_operation`（要提供给`cdev_init`），并为每个需要创建的设备调用`cdev_init()`和`cdev_add()`来注册设备。
- en: 'Then `create a device_create()` for each device, with a proper name. It will
    result in your device being created in the `/dev` directory:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后为每个设备创建一个`device_create()`，并赋予一个适当的名称。这将导致您的设备在`/dev`目录中被创建：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Writing file operations
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写文件操作
- en: After introducing the preceding file operations, it is time to implement them
    in order to enhance the driver capabilities and expose the device's methods to
    the user space (by means of system calls or course). Each of these methods has
    its particularities, which we will highlight in this section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入上述文件操作之后，是时候实现它们以增强驱动程序的功能并将设备的方法暴露给用户空间（通过系统调用）。这些方法各有其特点，我们将在本节中进行重点介绍。
- en: Exchanging data between kernel space and user space
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在内核空间和用户空间之间交换数据
- en: This section does not describe any driver file operation but instead, introduces
    some kernel facilities that one may use to write these driver methods. The driver's
    `write()` method consists of reading data from user space to kernel space, and
    then processing that data from the kernel. Such processing could be something
    like *pushing* the data to the device, for example. On the other hand, the driver's
    `read()` method consists of copying data from the kernel to the user space. Both
    of these methods introduces new elements we need to discuss prior to jumping to
    their respective steps. The first one is `__user` . `__user` is a cookie used
    by sparse (a semantic checker used by the kernel to find possible coding faults)
    to let the developer know he is actually about to use an untrusted pointer (or
    a pointer that may be invalid in the current virtual address mapping) improperly
    and that he should not dereference but instead, use dedicated kernel functions
    to access the memory to which this pointer points.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本节不描述任何驱动程序文件操作，而是介绍一些内核设施，可以用来编写这些驱动程序方法。驱动程序的`write()`方法包括从用户空间读取数据到内核空间，然后从内核处理该数据。这样的处理可能是像*推送*数据到设备一样。另一方面，驱动程序的`read()`方法包括将数据从内核复制到用户空间。这两种方法都引入了我们需要在跳转到各自步骤之前讨论的新元素。第一个是`__user`。`__user`是由稀疏（内核用于查找可能的编码错误的语义检查器）使用的一个标记，用于让开发人员知道他实际上将要不正确地使用一个不受信任的指针（或者在当前虚拟地址映射中可能无效的指针），并且他不应该解引用，而应该使用专用的内核函数来访问该指针指向的内存。
- en: 'This allows us to introduce different kernel functions needed to access such
    memory, either to read or write. These are `copy_from_user()` and `copy_from_user()`
    respectively to copy a buffer from user space to kernel space, and vice versa,
    to copy a buffer from kernel to user space:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够引入不同的内核函数，以便访问这样的内存，无论是读取还是写入。这些分别是`copy_from_user()`和`copy_from_user()`，用于将缓冲区从用户空间复制到内核空间，反之亦然，将缓冲区从内核复制到用户空间：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In both cases, pointers prefixed with `__user` point to user space (untrusted)
    memory. `n` represents the number of bytes to copy. `from` represents the source
    address, and `to` is the destination address. Each of these returns the number
    of bytes that could not be copied. On success, the return value should be `0`
    .
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，以`__user`为前缀的指针指向用户空间（不受信任）内存。`n`代表要复制的字节数。`from`代表源地址，`to`是目标地址。这些返回未能复制的字节数。成功时，返回值应为`0`。
- en: Please do note that with `copy_to_user()` , if some data could not be copied,
    the function will pad the copied data to the requested size using zero bytes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`copy_to_user（）`，如果无法复制某些数据，函数将使用零字节填充已复制的数据以达到请求的大小。
- en: A single value copy
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单个值复制
- en: 'When it comes to copying single and simple variables like `char` and `int`
    but not larger data types like structures nor arrays, the kernel offers dedicated
    macros in order to quickly perform the desired operation. These macros are `put_user(x,
    ptr)` and `get_used(x, ptr)` , which are explained as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制`char`和`int`等单个和简单变量时，但不是在复制结构或数组等较大的数据类型时，内核提供了专用宏以快速执行所需的操作。这些宏是`put_user(x,
    ptr)`和`get_used(x, ptr)`，解释如下：
- en: '`put_user(x, ptr);` : This macro copies a variable from kernel space to user
    space. `x` represents value to copy to user space, and `ptr` is the destination
    address in user space. The macro returns `0` on success, or `-EFAULT` on error.
    `x` must be assignable to the result of dereferencing `ptr` . In other words,
    they must have (or point to) the same type.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put_user(x, ptr);`：此宏将变量从内核空间复制到用户空间。`x`表示要复制到用户空间的值，`ptr`是用户空间中的目标地址。该宏在成功时返回`0`，在错误时返回`-EFAULT`。`x`必须可分配给解引用`ptr`的结果。换句话说，它们必须具有（或指向）相同的类型。'
- en: '`get_user(x, ptr);` : This macro copies a variable from user space to kernel
    space, and returns `0` on success or `-EFAULT` on error. Please do note that `x`
    is set to `0` on error. `x` represents the kernel variable to store the result,
    and `ptr` is the source address in user space. The result of dereferencing `ptr`
    must be assignable to `x` without a cast. Guess what it means.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_user(x, ptr);`：此宏将变量从用户空间复制到内核空间，并在成功时返回`0`，在错误时返回`-EFAULT`。请注意，错误时`x`设置为`0`。`x`表示要存储结果的内核变量，`ptr`是用户空间中的源地址。解引用`ptr`的结果必须可分配给`x`而不需要转换。猜猜它是什么意思。'
- en: The open method
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开方法
- en: '`open` is the method called every time someone opens your device''s file. Device
    opening will always success in case where this method is not defined. One usually
    uses this method to perform device and data structure initialization, and return
    a negative error code if something goes wrong, or `0` .The prototype of `open`
    method is defined as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: “open”是每次有人打开设备文件时调用的方法。如果未定义此方法，则设备打开将始终成功。通常使用此方法来执行设备和数据结构初始化，并在出现问题时返回负错误代码，或`0`。`open`方法的原型定义如下：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Per-device data
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个设备的数据
- en: For each `open` performed on your character device, the callback function will
    be given a `struct inode` as parameter, which is the kernel lower-level representation
    of the file. That `struct inode` structure has a field named `i_cdev` that points
    to the `cdev` we have allocated in the `init` function. By embedding the `struct
    cdev` in our device-specific data as in `struct pcf2127` in the following example,
    we will be able to get a pointer on that specific data using the `container_of`
    macro. Here is an `open` method sample.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在您的字符设备上执行的每个“open”，回调函数将以`struct inode`作为参数，该参数是文件的内核底层表示。该`struct inode`结构具有一个名为`i_cdev`的字段，指向我们在`init`函数中分配的`cdev`。通过在以下示例中的`struct
    pcf2127`中将`struct cdev`嵌入到我们的设备特定数据中，我们将能够使用`container_of`宏获取指向该特定数据的指针。以下是一个“open”方法示例。
- en: 'The following is our data structure:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的数据结构：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Given this data structure, the `open` method would look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个数据结构，“open”方法将如下所示：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The release method
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 释放方法
- en: 'The `release` method is called when the device gets closed, the reverse of
    the `open` method. You must then undo everything you have done in the open task.
    What you have to do is roughly:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备关闭时，将调用“release”方法，这是“open”方法的反向操作。然后，您必须撤消在打开任务中所做的一切。您大致要做的是：
- en: Free any private memory allocated during the `open()` step.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 释放在“open（）”步骤中分配的任何私有内存。
- en: Shut down the device (if supported) and discard every buffer on the last closing
    (if the device supports multi opening, or if the driver can handle more than one
    device at a time).
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭设备（如果支持），并在最后关闭时丢弃每个缓冲区（如果设备支持多次打开，或者驱动程序可以同时处理多个设备）。
- en: 'The following is an excerpt of a `release` function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是“release”函数的摘录：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The write method
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入方法
- en: 'The `write()` method is used to send data to the device; whenever a user app
    calls the `write` function on the device''s file, the kernel implementation is
    called. Its prototype is as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: “write（）”方法用于向设备发送数据；每当用户应用程序在设备文件上调用“write”函数时，将调用内核实现。其原型如下：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The return value is the number of bytes (size) written
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值是写入的字节数（大小）
- en: '`*buf` represents the data buffer coming from the user space'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*buf`表示来自用户空间的数据缓冲区'
- en: '`count` is the size of the requested transfer'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`是请求传输的大小'
- en: '`*pos` indicates the start position from which data should be written in the
    file'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*pos`表示应在文件中写入数据的起始位置'
- en: Steps to write
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入步骤
- en: The following steps do not describe any standard nor universal method to implement
    the driver's `write()` method. They are just an overview of what kind of operations
    one can perform in this method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤不描述任何标准或通用的方法来实现驱动程序的“write（）”方法。它们只是概述了在此方法中可以执行的操作类型。
- en: 'Check for bad or invalid requests coming from the user space. This step is
    relevant only if the device exposes its memory (eeprom, I/O memory, and so on),
    which may have size limitations:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查来自用户空间的错误或无效请求。如果设备公开其内存（eeprom、I/O内存等），可能存在大小限制，则此步骤才相关：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Adjust `count` for the remaining bytes in order to not go beyond the file size.
    This step is not mandatory neither, and is relevant in the same condition as step
    1:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整“count”以便不超出文件大小的剩余字节。这一步骤不是强制性的，与步骤1的条件相同：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Find the location from which you will start to write. This step is relevant
    only if the device has a memory in which the `write()` method is supposed to write
    given data. As steps 2 and 3, this step is not mandatory:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到要开始写入的位置。如果设备具有内存，供“write（）”方法写入给定数据，则此步骤才相关。与步骤2和3一样，此步骤不是强制性的：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Copy data from the user space and write it into the appropriate kernel space:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从用户空间复制数据并将其写入适当的内核空间：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Write to the physical device and return an error on failure:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入物理设备并在失败时返回错误：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Increase the current position of the cursor in the file, according to the number
    of bytes written. Finally, return the number of bytes copied:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据写入的字节数增加文件中光标的当前位置。最后，返回复制的字节数：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is an example of the `write` method. Once again, this is aimed
    to give an overview:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`write`方法的一个示例。再次强调，这旨在给出一个概述：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The read method
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取方法
- en: 'The prototype of the `read()` method is given as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`read()`方法的原型如下：'
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The return value is the size read. The rest of the method''s elements are described
    here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值是读取的大小。方法的其余元素在这里描述：
- en: '`*buf` is the buffer we receive from the user space'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*buf`是我们从用户空间接收的缓冲区'
- en: '`count` is the size of the requested transfer (size of the user buffer)'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count` 是请求传输的大小（用户缓冲区的大小）'
- en: '`*pos` indicates the start position from which data should be read in the file'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*pos`指示应从文件中读取数据的起始位置'
- en: Steps to read
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取步骤
- en: 'Prevent from reading beyond the file size, and return end-of-file:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 防止读取超出文件大小，并返回文件末尾：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The number of bytes read can''t go beyond the file size. Adjust `count` appropriately:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取的字节数不能超过文件大小。相应地调整`count`：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Find the location from which you will start the read:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到将开始读取的位置：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Copy the data into the user-space buffer and return an error on failure:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数据复制到用户空间缓冲区，并在失败时返回错误：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Advance the file''s current position according to the number of bytes read,
    and return the number of bytes copied:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据读取的字节数提前文件的当前位置，并返回复制的字节数：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is an example of a driver `read()` file operation, which is intended
    to give an overview of what can be done there:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个驱动程序`read()`文件操作的示例，旨在概述可以在那里完成的工作：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The llseek method
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: llseek方法
- en: 'The `llseek` function is called when one moves the cursor position within a
    file. The entry point of this method in user space is `lseek()` . One can refer
    to the man-page in order to print the full description of either method from user
    space: `man llseek` and `man lseek` . Its prototype looks as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当在文件内移动光标位置时，将调用`llseek`函数。该方法在用户空间的入口点是`lseek()`。可以参考man页面以打印用户空间中任一方法的完整描述：`man
    llseek`和`man lseek`。其原型如下：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The return value is the new position in the file
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值是文件中的新位置
- en: '`loff_t` is an offset, relative to the current file position, which defines
    how much it will be changed'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loff_t`是相对于当前文件位置的偏移量，定义了它将被改变多少'
- en: '`whence` defines where to seek from. Possible values are:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`whence`定义了从哪里寻找。可能的值有：'
- en: '`SEEK_SET` : This puts the cursor into a position relative to the beginning
    of the file'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEEK_SET`：这将光标放置在相对于文件开头的位置'
- en: '`SEEK_CUR` : This puts the cursor into a position relative to the current file
    position'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEEK_CUR`：这将光标放置在相对于当前文件位置的位置'
- en: '`SEEK_END` : This adjusts the cursor to a position relative to end-of-file'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SEEK_END`：这将光标调整到相对于文件末尾的位置'
- en: Steps to llseek
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: llseek步骤
- en: 'Use the `switch` statement to check every possible `whence` case, since they
    are limited, and adjust `newpos` accordingly:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`switch`语句检查每种可能的`whence`情况，因为它们是有限的，并相应地调整`newpos`：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Check whether `newpos` is valid:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`newpos`是否有效：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Update `f_pos` with the new position:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新位置更新`f_pos`：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Return the new file-pointer position:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回新的文件指针位置：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following is an example of a user program that successively reads and seeks
    into a file. The underlying driver will then execute the `llseek()` file operation
    entry:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个连续读取和搜索文件的用户程序示例。底层驱动程序将执行`llseek()`文件操作入口：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The code produces the following output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 代码产生以下输出：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The poll method
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮询方法
- en: 'If one needs to implement a passive wait (not wasting CPU cycles while sensing
    the character device), one must implement the `poll()` function, which will be
    called whenever a user-space program performs a `select()` or `poll()` system
    calls on the file associated with the device:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要实现被动等待（在感知字符设备时不浪费CPU周期），必须实现`poll()`函数，每当用户空间程序对与设备关联的文件执行`select()`或`poll()`系统调用时都会调用该函数：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The kernel function at the heart of this method is `poll_wait()` , defined
    in `<linux/poll.h>` , which is the header one should include in driver code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法的核心是`poll_wait()`内核函数，定义在`<linux/poll.h>`中，这是驱动程序代码中应该包含的头文件：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`poll_wait()` adds the device associated with a `struct file` structure (given
    as first parameter) to a list of those that can wake up processes (which have
    been put to sleep in the `struct wait_queue_head_t` structure given as second
    parameter), according to events registered into the `struct poll_table` structure
    given as third parameter. A user process can run `poll()` , `select()` , or `epoll()`
    system calls to add a set of files to a list on which it needs to wait, in order
    to be aware of the associated (if any) devices readiness. The kernel will then
    call the `poll` entry of the driver associated with each device file. The `poll`
    method of each driver should then call `poll_wait()` in order to register events
    for which the process needs to be notified with the kernel, put that process to
    sleep until one of these events occurs, and register the driver as one of those
    that can wake the process up. The usual way is to use a wait queue per event type
    (one for readability, another one for writability, and eventually one for exception
    if needed), according to events supported by the `select()` (or `poll()` ) system
    call.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`poll_wait()`将与`struct file`结构（作为第一个参数给出）相关联的设备添加到可以唤醒进程的列表中（这些进程已经在`struct
    wait_queue_head_t`结构中休眠，该结构作为第二个参数给出），根据在`struct poll_table`结构中注册的事件（作为第三个参数给出）。用户进程可以运行`poll()`，`select()`或`epoll()`系统调用，将一组文件添加到等待的列表中，以便了解相关（如果有）设备的准备情况。然后内核将调用与每个设备文件相关联的驱动程序的`poll`入口。然后，每个驱动程序的`poll`方法应调用`poll_wait()`以注册进程需要被内核通知的事件，将该进程置于休眠状态，直到其中一个事件发生，并将驱动程序注册为可以唤醒该进程的驱动程序之一。通常的方法是根据`select()`（或`poll()`）系统调用支持的事件类型使用一个等待队列（一个用于可读性，另一个用于可写性，如果需要的话，最终还有一个用于异常）。'
- en: The return value of the `(*poll)` file operation must have `POLLIN | POLLRDNORM`
    set if there is data to read (at the moment, select or poll is called), `POLLOUT
    | POLLWRNORM` if the device is writable (at the moment, select or poll is called
    here as well), and `0` if there is no new data and the device is not yet writable.
    In the following example, we assume the device supports both blocking read and
    write. Of course one may implement only one of these. If the driver does not define
    this method, the device will be considered as always readable and writable, so
    that `poll()` or `select()` system calls return immediately.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`(*poll)`文件操作的返回值必须设置为`POLLIN | POLLRDNORM`，如果有数据可读（在调用select或poll时），如果设备可写，则设置为`POLLOUT
    | POLLWRNORM`（在这里也是调用select或poll），如果没有新数据且设备尚未可写，则设置为`0`。在下面的示例中，我们假设设备同时支持阻塞读和写。当然，可以只实现其中一个。如果驱动程序没有定义此方法，则设备将被视为始终可读和可写，因此`poll()`或`select()`系统调用会立即返回。'
- en: Steps to poll
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮询步骤
- en: 'When one implements the `poll` function, either the `read` or `write` method
    may change:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现`poll`函数时，`read`或`write`方法中的任何一个都可能会发生变化：
- en: 'Declare a wait queue for each event type (read, write, exception) one needs
    to implement passive wait, to put tasks in when there is no data to read, or when
    the device is not writable yet:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为需要实现被动等待的每种事件类型（读取、写入、异常）声明一个等待队列，当没有数据可读或设备尚不可写时，将任务放入其中：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Implement the `poll` function like this:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`poll`函数如下：
- en: '[PRE40]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Notify the wait queue when there is new data or when the device is writable:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当有新数据或设备可写时，通知等待队列：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: One can notify readable events either from within the driver's `write()` method,
    meaning that the written data can be read back, or from within an IRQ handler,
    meaning that an external device sent some data which can be read back. On the
    other hand, one can notify writable events either from within the driver's `read()`
    method, meaning that the buffer is empty and can be filled again, or from within
    an IRQ handler, meaning that the device has completed a data-send operation, and
    is ready to accept data again.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从驱动程序的`write()`方法内部或者从IRQ处理程序内部通知可读事件，这意味着写入的数据可以被读取，或者从IRQ处理程序内部通知可写事件，这意味着设备已完成数据发送操作，并准备好再次接受数据。
- en: When using a sleepy input/output operation (blocked I/O), either the `read`
    or `write` method may change. The wait queue used in the poll must be used in
    read too. When the user needs to read, if there is data, that data will be sent
    immediately to the process and you must update the wait queue condition (set to
    `false` ); if there is no data, the process is put to sleep in the wait queue.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用阻塞I/O时，`read`或`write`方法中的任何一个都可能会发生变化。在`poll`中使用的等待队列也必须在读取时使用。当用户需要读取时，如果有数据，该数据将立即发送到进程，并且必须更新等待队列条件（设置为`false`）；如果没有数据，进程将在等待队列中休眠。
- en: If the `write` method is supposed to feed data, then in the `write` callback,
    you must fill the data buffer and update the wait queue condition (set to `true`
    ), and wake up the reader (see the section *wait queue* ). If it is an IRQ instead,
    these operations must be performed in their handler.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`write`方法应该提供数据，那么在`write`回调中，您必须填充数据缓冲区并更新等待队列条件（设置为`true`），并唤醒读取者（参见*等待队列*部分）。如果是IRQ，这些操作必须在其处理程序中执行。
- en: 'The following is an excerpt of a code that `select()` on a given char device
    in order to sense data availability:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对在给定字符设备上进行`select()`以检测数据可用性的代码的摘录：
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The ioctl method
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ioctl方法
- en: A typical Linux system contains around 350 system calls (syscalls), but only
    a few of them are linked with file operations. Sometimes devices may need to implement
    specific commands that are not provided by system calls, and especially the ones
    associated with files and thus device files. In this case, the solution is to
    use **input/output control** (**ioctl** ), which is a method by which one extends
    a list of syscalls (actually commands) associated with a device.. One can use
    it to send special commands to devices (`reset` , `shutdown` , `configure` , and
    so on). If the driver does not define this method, the kernel will return `-ENOTTY`
    error to any `ioctl()` system call.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的Linux系统包含大约350个系统调用（syscalls），但只有少数与文件操作相关。有时设备可能需要实现特定的命令，这些命令不是由系统调用提供的，特别是与文件相关的命令，因此是设备文件。在这种情况下，解决方案是使用**输入/输出控制**（**ioctl**），这是一种方法，通过它可以扩展与设备相关的系统调用（实际上是命令）的列表。可以使用它向设备发送特殊命令（`reset`，`shutdown`，`configure`等）。如果驱动程序没有定义此方法，内核将对任何`ioctl()`系统调用返回`-ENOTTY`错误。
- en: 'In order to be valid and safe, an `ioctl` command needs to be identified by
    a number which should be unique to the system. The unicity of ioctl numbers across
    the system will prevent it from sending the right command to the wrong device,
    or passing the wrong argument to the right command (given a duplicated ioctl number).
    Linux provides four helper macros to create an `ioctl` identifier, depending on
    whether there is data transfer or not and on the direction of the transfer. Their
    respective prototypes are:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效和安全，一个`ioctl`命令需要由一个数字标识，这个数字应该对系统是唯一的。在整个系统中ioctl号的唯一性将防止它向错误的设备发送正确的命令，或者向正确的命令传递错误的参数（给定重复的ioctl号）。Linux提供了四个辅助宏来创建`ioctl`标识符，具体取决于是否有数据传输，以及传输的方向。它们的原型分别是：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Their descriptions are as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的描述如下：
- en: '`_IO` : The `ioctl` does not need data transfer'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_IO`：`ioctl`不需要数据传输'
- en: '`_IOW` : The `ioctl` needs write parameters (`copy_from_user` or `get_user`
    )'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_IOW`：`ioctl`需要写参数（`copy_from_user`或`get_user`）'
- en: '`_IOR` : The `ioctl` needs read parameters (`copy_to_user` or `put_user` )'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_IOR`：`ioctl`需要读参数（`copy_to_user`或`put_user`）'
- en: '`_IOWR` : The `ioctl` needs both write and read parameters'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_IOWR`：`ioctl`需要写和读参数'
- en: 'What their parameters mean (in the order they are passed) is described here:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的参数意义（按照它们传递的顺序）在这里描述：
- en: A number coded on 8 bits (0 to 255), called magic number.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个编码为8位（0到255）的数字，称为魔术数字。
- en: A sequence number or command ID, also on 8 bits.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个序列号或命令ID，也是8位。
- en: A data type, if any, that will inform the kernel about the size to be copied.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个数据类型（如果有的话），将通知内核要复制的大小。
- en: It is well documented in *Documentation/ioctl/ioctl-decoding.txt* in the kernel
    source, and existing `ioctl` are listed in *Documentation/ioctl/ioctl-number.txt*
    , a good place to start when you need to create an `ioctl` command.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核源中的*Documentation/ioctl/ioctl-decoding.txt*中有很好的文档，现有的`ioctl`在*Documentation/ioctl/ioctl-number.txt*中列出，这是需要创建`ioctl`命令时的好起点。
- en: Generating ioctl numbers (command)
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成ioctl号（命令）
- en: 'One should generate their own ioctl number in a dedicated header file. It is
    not mandatory, but it is recommended, since this header should be available in
    user space too. In other words, one should duplicate the ioctl header file so
    that there is one in the kernel and one in the user space, which one can include
    in user apps. Let''s now generate ioctl numbers in a real example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在专用的头文件中生成自己的ioctl号。这不是强制性的，但建议这样做，因为这个头文件也应该在用户空间中可用。换句话说，应该复制ioctl头文件，以便内核和用户空间各有一个，用户可以在用户应用程序中包含其中。现在让我们在一个真实的例子中生成ioctl号：
- en: '`eep_ioctl.h` :'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`eep_ioctl.h`：'
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Steps for ioctl
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`ioctl`的步骤'
- en: 'First, let us have a look at its prototype. It look likes as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下它的原型。它看起来如下：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'There is only one step: use a `switch ... case` statement and return an `-ENOTTY`
    error when an undefined `ioctl` command is called. One can find more information
    at [http://man7.org/linux/man-pages/man2/ioctl.2.html](http://man7.org/linux/man-pages/man2/ioctl.2.html)
    :'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一步：使用`switch ... case`语句，并在调用未定义的`ioctl`命令时返回`-ENOTTY`错误。可以在[http://man7.org/linux/man-pages/man2/ioctl.2.html](http://man7.org/linux/man-pages/man2/ioctl.2.html)找到更多信息：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you think your `ioctl` command will need more than one argument, you should
    gather those arguments in a structure and just pass a pointer from the structure
    to `ioctl` .
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为您的`ioctl`命令需要多个参数，您应该将这些参数收集在一个结构中，并只是将结构中的指针传递给`ioctl`。
- en: 'Now, from the user space, you must use the same `ioctl` header as in the driver''s
    code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从用户空间，您必须使用与驱动程序代码中相同的`ioctl`头文件：
- en: '`my_main.c`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`my_main.c`'
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Filling the file_operations structure
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充file_operations结构
- en: When writing kernel modules, it is better to use designated initializers when
    it comes to statically initialize structures with their parameters. It consists
    of naming the member one needs to assign a value to. The form is `.member-name`
    to designate what member should be initialized. This allows, among other things,
    initializing the members in an undefined order, or leaving unchanged the fields
    that we do not want to modify.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写内核模块时，最好在静态初始化结构及其参数时使用指定的初始化器。它包括命名需要分配值的成员。形式是`.member-name`来指定应初始化的成员。这允许以未定义的顺序初始化成员，或者保持不想修改的字段不变，等等。
- en: 'Once we have defined our functions, we just have to fill the structure as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了我们的函数，我们只需填充结构如下：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Let us remember, the structure is given as a parameter to `cdev_init` in the
    `init` method.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们记住，结构作为参数传递给`cdev_init`的`init`方法。
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have demystified character devices and we have seen how
    to let users interact with our driver through device files. We learned how to
    expose file operations to the user space and control their behavior from within
    the kernel. We went so far that you are even able to implement multi-device support.
    The next chapter is a bit hardware oriented since it deals with platform drivers
    which expose hardware device capabilities to the user space. The power of character
    drivers combined with platform drivers is just amazing. See you in the next chapter.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经揭开了字符设备的神秘面纱，看到了如何通过设备文件让用户与我们的驱动程序进行交互。我们学会了如何将文件操作暴露给用户空间，并从内核内部控制它们的行为。我们甚至可以实现多设备支持。下一章有点偏向硬件，因为它涉及到将硬件设备的功能暴露给用户空间的平台驱动程序。字符驱动程序与平台驱动程序的结合力量简直令人惊叹。下一章见。
