- en: Parsing Bash Script Arguments with getopts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `getopts` 解析 Bash 脚本参数
- en: In this chapter, we'll discuss the different ways of passing arguments to a
    script, with a special focus on flags. We will start by recapping positional arguments,
    before continuing with arguments passed as flags. After this, we will talk about
    how to use flags in your own scripts using the `getopts` shell builtin.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论向脚本传递参数的不同方法，特别关注标志。我们将首先回顾位置参数，然后继续讨论作为标志传递的参数。之后，我们将讨论如何使用 `getopts`
    shell 内建在你自己的脚本中使用标志。
- en: 'The following commands will be introduced in this chapter: `getopts` and `shift`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下命令：`getopts` 和 `shift`。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Positional parameters versus flags
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置参数与标志
- en: The `getopts` shell builtin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getopts` shell 内建'
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All scripts for this chapter can be found on GitHub at the following link:
    [https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter15](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter15).
    Follow along with the examples on your Ubuntu Linux virtual machine—no other resources
    are needed. For the single-flag.sh script only the final version is found online.
    Be sure to verify the script version in the header before executing it on your
    system.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有脚本都可以在 GitHub 上找到，链接如下：[https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter15](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter15)。在你的
    Ubuntu Linux 虚拟机上跟着示例进行—不需要其他资源。对于 `single-flag.sh` 脚本，只能在网上找到最终版本。在执行脚本之前，请务必验证头部中的脚本版本。
- en: Positional parameters versus flags
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置参数与标志
- en: We'll start this chapter off with a short recap on positional arguments. As
    you might remember from [Chapter 8](41d3c327-f6d6-4ec5-8ec9-127e493bdd05.xhtml),
    *Variables and User Input*, we are able to use positional parameters to pass arguments
    to our scripts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简短的位置参数回顾开始本章。你可能还记得来自[第8章](41d3c327-f6d6-4ec5-8ec9-127e493bdd05.xhtml)的*变量和用户输入*，我们可以使用位置参数来向我们的脚本传递参数。
- en: 'To put this simply, the following syntax is used:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，使用以下语法：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside the preceding (fictive) `script.sh`, we can then grab the values supplied
    by the user by looking at the positions the arguments are supplied in: `$1` is
    the first argument, `$2` is the second, and so on. Remember that `$0` is a special
    argument, which relates to the name of the script: in this case, `script.sh`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述（虚构的）`script.sh` 中，我们可以通过查看参数的位置来获取用户提供的值：`$1` 是第一个参数，`$2` 是第二个参数，依此类推。记住
    `$0` 是一个特殊的参数，它与脚本的名称有关：在这种情况下，是 `script.sh`。
- en: This approach is relatively simple, but also susceptible to errors. When you
    write this script, you need to check extensively for the input supplied by the
    user; did they give enough arguments, but not too many? Or, perhaps some arguments
    are optional, so a few combinations are possible? All these things need to be
    considered and, if possible, dealt with.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法相对简单，但也容易出错。当你编写这个脚本时，你需要对用户提供的输入进行广泛的检查；他们是否提供了足够的参数，但不要太多？或者，也许一些参数是可选的，所以可能有一些组合是可能的？所有这些事情都需要考虑，如果可能的话，需要处理。
- en: 'Besides the script writer (you!), there is also the burden on the script caller.
    Before they can successfully call your script, they need to be aware of how to
    pass the needed information. For our scripts, we''ve applied two practices which
    are meant to minimize the burden on the user:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 除了脚本作者（你！），脚本调用者也有负担。在他们能够成功调用你的脚本之前，他们需要知道如何传递所需的信息。对于我们的脚本，我们应用了两种旨在减轻用户负担的做法：
- en: Our script header contains a `Usage:` field
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的脚本头包含一个 `Usage:` 字段
- en: When our scripts are called incorrectly, we print an error message with a *usage
    hint* similar/equal to the header
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们的脚本被错误调用时，我们会打印一个错误消息，带有一个与头部类似/相等的*使用提示*
- en: 'Still, this approach is error-prone and not always very user-friendly. There
    is another option though: *options*, more commonly known as *flags*.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法容易出错，而且并不总是很用户友好。不过，还有另一个选择：*选项*，更常被称为*标志*。
- en: Using flags on the command line
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在命令行上使用标志
- en: 'Perhaps you haven''t realized it yet, but most commands you use on the command
    line use a combination of positional arguments and flags. The most basic command
    in Linux, `cd`, uses a single positional argument: the directory you want to move
    to.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你还没有意识到，但你在命令行上使用的大多数命令都是使用位置参数和标志的组合。Linux 中最基本的命令 `cd` 使用了一个位置参数：你想要移动到的目录。
- en: 'It does actually have two flags that you can use as well: `-L` and `-P`. The
    purpose of these flags is niche and not worth explaining here. Almost all commands
    use both flags and positional arguments complementarily.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上它确实有两个标志，你也可以使用：`-L` 和 `-P`。这些标志的目的是小众的，不值得在这里解释。几乎所有命令都同时使用标志和位置参数。
- en: 'So then, when do we use which? As a rule of thumb, flags are often used for
    *modifiers*, while positional arguments are used for *targets*. A target is simple
    this is: the thing you want to manipulate with the command. In the case of `ls`,
    this means that the positional arguments are the files or directories that should
    be listed (manipulated) by the command.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们什么时候使用哪个？作为一个经验法则，标志通常用于*修改器*，而位置参数用于*目标*。目标很简单：你想要用命令操作的东西。在 `ls` 的情况下，这意味着位置参数是应该被列出（操作）的文件或目录。
- en: 'For the `ls -l /tmp/` command, `/tmp/` is the target, and `-l` is the flag
    used to modify the behavior of `ls`. By default, `ls` lists all files without
    extra information such as ownership, permissions, size, and so on. If we want
    to modify the behavior of `ls`, we add one or more flags: `-l` tells `ls` to use
    the long listing format, which prints each file on its own line, and prints the
    extra information about the file too.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ls -l /tmp/`命令，`/tmp/`是目标，`-l`是用来修改`ls`行为的标志。默认情况下，`ls`列出所有文件，不包括所有者、权限、大小等额外信息。如果我们想要修改`ls`的行为，我们添加一个或多个标志：`-l`告诉`ls`使用长列表格式，这样每个文件都会单独打印在自己的行上，并打印有关文件的额外信息。
- en: Do note that between `ls /tmp/` and `ls -l /tmp/`, the target does not change,
    but the output does, since we *modified* it with the flag!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`ls /tmp/`和`ls -l /tmp/`之间，目标没有改变，但输出却改变了，因为我们用标志*修改*了它！
- en: 'Some flags are even more special: they require their own positional argument!
    So not only can we use the flag to modify the command, but the flag itself has
    multiple options for how to modify the command''s behavior.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有些标志甚至更特殊：它们需要自己的位置参数！因此，我们不仅可以使用标志来修改命令，而且标志本身还有多个选项来修改命令的行为。
- en: 'A good example of this is the `find` command: by default, it finds all files
    within a directory, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是`find`命令：默认情况下，它会在目录中查找所有文件，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, we can use `find` with a positional argument to search not in
    the current working directory, but somewhere else, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`find`与位置参数一起使用，以便不在当前工作目录中搜索，而是在其他地方搜索，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, `find` also allows us to use the `-type` flag to only print files of a
    certain type. But by only using the `-type` flag, we have not yet specified what
    file type we want to print. By specifying the file type directly after the flag
    (ordering is *critical* here), we tell the flag what to look for. It looks something
    like the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`find`还允许我们使用`-type`标志只打印特定类型的文件。但是仅使用`-type`标志，我们还没有指定要打印的文件类型。通过在标志之后直接指定文件类型（这里*关键*是顺序），我们告诉标志要查找什么。它看起来像下面这样：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here we looked for a type of `d` (directory) within the `/boot/` directory.
    Other arguments to the `-type` flag include `f` (file), `l` (symbolic link), and
    `b` (block device).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`/boot/`目录中寻找了一种`d`（目录）类型。`-type`标志的其他参数包括`f`（文件）、`l`（符号链接）和`b`（块设备）。
- en: 'As always, ordering is important, and something like this will happen if you
    do not get it right:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的事情会发生，如果你没有做对的话：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Unfortunately for us, not all commands are created equal. Some are more forgiving
    on the user, and try their hardest to make sense of what has been given as input.
    Others are much more strict: they will run whatever is passed, even if it does
    not make any functional sense. Always make sure you verify whether you are using
    the command and its modifiers correctly!'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，不是所有的命令都是平等的。有些对用户更宽容，尽力理解输入的内容。其他则更加严格：它们会运行任何传递的内容，即使它没有任何功能上的意义。请务必确保您正确使用命令及其修改器！
- en: The preceding examples use flags differently to how we'll learn to use them
    with `getopts`. These examples should only serve to illustrate the concepts of
    script arguments, flags, and flags-with-arguments. These implementations are written
    without the use of `getopts` and thus do not map precisely to what we'll be doing
    later.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子使用了与我们将学习如何在`getopts`中使用标志的方式不同。这些例子只是用来说明脚本参数、标志和带参数的标志的概念。这些实现是在没有使用`getopts`的情况下编写的，因此不完全对应我们以后要做的事情。
- en: The getopts shell builtin
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置的getopts shell
- en: Now the real fun begins! In this second part of this chapter, we'll explain
    the `getopts` shell builtin. The `getopts` command is used in the beginning of
    your script to ***get** the **opt**ion**s*** you supplied in the form of flags.
    It has a very specific syntax that will seem confusing at first, but, once we've
    looked at it fully, it should not be too complicated for you to understand.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在真正的乐趣开始了！在本章的第二部分中，我们将解释`getopts` shell内置。`getopts`命令用于在脚本的开头获取您以标志形式提供的**选项**。它有一个非常特定的语法，一开始可能会让人感到困惑，但是，一旦我们完全了解了它，你应该就不会觉得太复杂了。
- en: 'Before we dive in, though, we''ll need to discuss two things:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在我们深入讨论之前，我们需要讨论两件事：
- en: The difference between `getopts` and `getopt`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getopts`和`getopt`之间的区别'
- en: Short versus long options
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短选项与长选项
- en: As stated, `getopts` is a *shell builtin*. It is available in both the regular
    Bourne shell (`sh`) and in Bash. It originated around 1986, as a replacement for
    `getopt`, which was created sometime before 1980.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`getopts`是一个*shell内置*。它在常规的Bourne shell（`sh`）和Bash中都可用。它始于1986年左右，作为`getopt`的替代品，后者在1980年前后创建。
- en: 'In contrast to `getopts`, `getopt` is not built into the shell: it is a standalone
    program that has been ported to many different Unix and Unix-like distributions.
    The main differences between `getopts` and `getopt` are as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与`getopts`相比，`getopt`不是内置于shell中的：它是一个独立的程序，已经移植到许多不同的Unix和类Unix发行版。`getopts`和`getopt`之间的主要区别如下：
- en: '`getopt` does not handle empty flag arguments well; `getopts` does'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getopt`不能很好地处理空标志参数；`getopts`可以'
- en: '`getopts` is included in the Bourne shell and Bash; `getopt` needs to be installed
    separately'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getopts`包含在Bourne shell和Bash中；`getopt`需要单独安装'
- en: '`getopt` allows for the parsing of long options (`--help` instead of `-h`);
    `getopts` does not'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getopt`允许解析长选项（`--help`而不是`-h`）；`getopts`不允许'
- en: '`getopts` has a simpler syntax; `getopt` is more complicated (mainly because
    it is an external program and not a builtin)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getopts`有更简单的语法；`getopt`更复杂（主要是因为它是一个外部程序，而不是内置的）。'
- en: In general, the consensus seems to be that for most cases, using `getopts` is
    preferable (unless you really want long options). Since `getopts` is a Bash builtin,
    we'll use it as well, especially since we do not have the need for long options.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，大多数情况下，使用`getopts`更可取（除非你真的想要长选项）。由于`getopts`是Bash内置的，我们也会使用它，特别是因为我们不需要长选项。
- en: Most commands you use on the Terminal have both the short option (which is used
    almost always when interactively working at the Terminal to save time) and the
    long option (which is more descriptive and is more suitable for creating better
    readable scripts). In our experience, short options are more prevalent and, when
    used correctly, more recognizable as well.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您在终端上使用的大多数命令都有短选项（在终端上交互工作时几乎总是使用，以节省时间）和长选项（更具描述性，更适合创建更易读的脚本）。根据我们的经验，短选项更常见，而且使用正确时更容易识别。
- en: 'The following list shows the most common short flags, which do the same to
    most commands:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了最常见的短标志，对大多数命令起着相同的作用：
- en: '`-h`: Prints the help/usage for a command'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -h：打印命令的帮助/用法
- en: '`-v`: Makes the command verbose'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -v：使命令详细
- en: '`-q`: Makes the command quiet'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -q：使命令安静
- en: '`-f <file>`: Passes a file to the <indexentry content="getopts shell builtin,
    flags:-f ">command'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -f <file>：将文件传递给<indexentry content="getopts shell builtin, flags:-f ">命令
- en: '`-r`: Performs the operation recursively'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -r：递归执行操作
- en: '`-d`: Runs the command in debug mode'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -d：以调试模式运行命令
- en: Do not assume all commands parse the short flags, as specified previously. While
    this is true for most commands, don't all follow these trends. What is printed
    here has been found from personal experience and should always be verified by
    you before running a command that is new to you. That being said, running a command
    without arguments/flags or with a `-h` will, at least 90% of the time, print the
    correct usage for you to admire.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 不要假设所有命令都解析短标志，如前所述。尽管对大多数命令来说是这样，但并非所有命令都遵循这些趋势。这里打印的内容是根据个人经验发现的，应始终在运行对您新的命令之前进行验证。也就是说，运行一个没有参数/标志或带有`-h`的命令，至少90%的时间会打印正确的用法供您欣赏。
- en: Even though it would have been nice to have long options available to us for
    our `getopts` scripting, even long options are never a substitute for writing
    readable scripts and creating good hints for the user that is using your script.
    We feel that that's much more important than having long options! Besides, the
    `getopts` syntax is much cleaner than a comparable `getopt`, and adhering to the
    KISS principle is still one of our goals.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管长选项对我们的`getopts`脚本可用会很好，但是长选项永远不能替代编写可读性脚本和为使用您的脚本的用户创建良好提示。我们认为这比拥有长选项更重要！此外，`getopts`的语法比可比的`getopt`要干净得多，遵循KISS原则仍然是我们的目标之一。
- en: The getopts syntax
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: getopts语法
- en: Instead of spending any more time in this chapter not seeing actual code, we're
    going to jump right in and show a very simple example of a `getopts` script. Of
    course, we'll walk you through step by step so that you have the chance to understand
    it all.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想在这一章中再花费更多时间而不看到实际的代码，我们将直接展示一个非常简单的`getopts`脚本示例。当然，我们会逐步引导您，以便您有机会理解它。
- en: 'The script we''re creating does just a few simple things: if it finds the `-v` flag,
    it prints a *verbose* message, telling us it found the flag. If it does not find
    any flags, it prints nothing. If it finds any other flag, it prints an error for
    the user. Simple, right?'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建的脚本只做了一些简单的事情：如果找到`-v`标志，它会打印一个*详细*消息，告诉我们它找到了该标志。如果没有找到任何标志，它将不打印任何内容。如果找到任何其他标志，它将为用户打印错误。简单吧？
- en: 'Let''s take a look:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we run this script, we''ll see the following happening:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个脚本，我们会看到以下情况发生：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, our script at least works as expected! But why does it work like that?
    Let''s take a look. We''ll skip the header, as that should be very clear by now.
    We''ll start with the `while` line, which contains the `getopts` command and `optstring`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的脚本至少按预期工作！但是为什么它会这样工作呢？让我们来看看。我们将跳过标题，因为现在应该非常清楚。我们将从包含`getopts`命令和`optstring`的`while`行开始：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`optstring`, which is likely short for ***opt**ions **string***, tells `getopts`
    which options should be expected. In this case, we expect only `v`. However, we
    start the `optstring` with a colon (`:`), which is a special character for `optstring`
    that sets `getopts` in *silent error reporting* mode.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`optstring`，很可能是***opt**ions **string***的缩写，告诉`getopts`应该期望哪些选项。在这种情况下，我们只期望`v`。然而，我们以一个冒号（`:`）开始`optstring`，这是`optstring`的一个特殊字符，它将`getopts`设置为*静默错误报告*模式。'
- en: Since we prefer to handle error situations ourselves, we will always start our
    `optstring` with a colon. However, feel free to see what happens when you remove
    the colon.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们更喜欢自己处理错误情况，我们将始终以冒号开头。但是，随时可以尝试删除冒号看看会发生什么。
- en: 'After that, the syntax for `getopts` is pretty simple, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`getopts`的语法非常简单，如下所示：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see the command, followed by the `optstring` (which we abstracted to
    a separate variable to improve readability), ending with the name of the variable
    in which we'll store the parsed results.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到命令，后面跟着`optstring`（我们将其抽象为一个单独的变量以提高可读性），最后是我们将存储解析结果的变量的名称。
- en: The final, optional, aspect of `getopts` allows us to pass our own set of arguments,
    instead of defaulting to everything passed to the script ($0 through $9). We will
    not be needing/using this in our exercises, but this is definitely good to know.
    As always, because this is a shell builtin, you can find information on it by
    executing `help getopts`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`getopts`的最后一个可选方面允许我们传递我们自己的一组参数，而不是默认为传递给脚本的所有内容（$0到$9）。我们在练习中不需要/使用这个，但这绝对是好事。与往常一样，因为这是一个shell内置命令，您可以通过执行`help
    getopts`来找到有关它的信息。'
- en: We place this command within a `while` loop so that it iterates over all arguments
    we passed to the script. If there are no more arguments to be parsed by `getopts`,
    it returns an exit status other than `0`, which causes the `while` loop to exit.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将此命令放在`while`循环中，以便它遍历我们传递给脚本的所有参数。如果`getopts`没有更多参数要解析，它将返回除`0`之外的退出状态，这将导致`while`循环退出。
- en: 'While we''re inside the loop, though, we''ll hit the `case` statement. As you
    know, the `case` statement is basically better syntax for a longer `if-elif-elif-elif-else`
    statement. In our example script, this looks like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在循环中，我们将进入`case`语句。如你所知，`case`语句基本上是更好的语法，用于更长的`if-elif-elif-elif-else`语句。在我们的示例脚本中，它看起来像这样：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice how the `case` statement ends with the word `esac` (case in reverse).
    For all our defined flags (currently only `-v`), we have a block of code that
    will execute only for that flag.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`case`语句以`esac`（case反写）结束。对于我们定义的所有标志（目前只有`-v`），我们有一段代码块，只有对该标志才会执行。
- en: The other thing we find when we look at the `${options}` variable (which we
    have because we specified it for *name* in the `getopts` command) is the `?` wildcard.
    We place that at the end of the case statement as a means of catching errors.
    If it hits the `?)` code block, we've presented `getopts` with a flag it does
    not understand. In this case, we print an error and exit the script.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看`${options}`变量时（因为我们在`getopts`命令中为*name*指定了它），我们还会发现`?`通配符。我们将它放在`case`语句的末尾，作为捕获错误的手段。如果它触发了`?)`代码块，我们向`getopts`提供了一个无法理解的标志。在这种情况下，我们打印一个错误并退出脚本。
- en: The `done` on the last line ends the `while` loop, and signals that all of our
    flags should have been handled.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行的`done`结束了`while`循环，并表示我们所有的标志都应该已经处理完毕。
- en: It might seem a bit unnecessary to have both an `optstring` and a case for all
    possible options. For now, this is indeed the case, but a bit further on in this
    chapter we'll show you how the `optstring` is used to specify things beyond just
    the letter; at that point, it should be clear why the `optstring` is here. For
    now, don't worry about it too much and just enter the flags in both locations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来有点多余，既有`optstring`又有所有可能选项的`case`。目前确实是这样，但在本章稍后的部分，我们将向您展示`optstring`用于指定除了字母之外的其他内容；到那时，`optstring`为什么在这里应该是清楚的。现在不要太担心它，只需在两个位置输入标志即可。
- en: Multiple flags
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个标志
- en: 'Fortunately for us, we do not have to be content with just a single flag: we
    can define many (right up until we run out of alphabet!).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不必满足于只有一个标志：我们可以定义许多标志（直到字母用完为止！）。
- en: We'll create a new script that will print a message to the reader. If no flags
    are specified, we'll print a default message. If we encounter either flag `-b`
    or flag `-g`, we'll print a different message, depending on the flag. We'll also
    include instructions for the `-h` flag, which will print a help message when encountered.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的脚本，向读者打印一条消息。如果没有指定标志，我们将打印默认消息。如果遇到`-b`标志或`-g`标志，我们将根据标志打印不同的消息。我们还将包括`-h`标志的说明，遇到时将打印帮助信息。
- en: 'A script with these requirements could look something like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 满足这些要求的脚本可能如下所示：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This script should be readable to you at this point, especially with the included
    comments. From the top, we start with the header and follow up with the `print_help()` function,
    which prints our help message when the `-h` flag is encountered (as we see a few
    lines further on).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，这个脚本对你来说应该是可读的，尤其是包含的注释。从头开始，我们从标题开始，然后是`print_help()`函数，当遇到`-h`标志时打印我们的帮助信息（正如我们在几行后看到的那样）。
- en: 'Next up is the `optstring`, which still starts with a colon so that verbose
    errors from `getopts` is turned off (as we will handle this ourselves). In the
    `optstring`, all three flags that we will handle, that is `-b`, `-g`, and `-h`,
    are defined as a single string: `bgh`.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`optstring`，它仍然以冒号开头，以便关闭`getopts`的冗长错误（因为我们将自己处理这些错误）。在`optstring`中，我们将要处理的三个标志，即`-b`、`-g`和`-h`，定义为一个字符串：`bgh`。
- en: 'For each of these flags, we have an entry in the `case` statement: for `b)`
    and `g)`, the `gender` variable is set to `boy` or `girl`, respectively. For `h)`,
    the function we defined is called, before calling `exit 0`. (Think about why we
    would do this! If you''re not sure, run the script without the exit.)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个标志，我们在`case`语句中都有一个条目：对于`b)`和`g)`，`gender`变量分别设置为`boy`或`girl`。对于`h)`，在调用`exit
    0`之前，调用了我们定义的函数。（想想为什么我们要这样做！如果不确定，可以在不使用exit的情况下运行脚本。）
- en: We always end a `getopts` block by handling unknown flags with the `?)` syntax.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是通过`?)`语法处理未知标志来结束`getopts`块。
- en: 'Moving on, after our `case` statements ends with `esac`, we get to the actual
    functionality. We check whether the `gender` variable is defined: if it is, we
    print a message that contains the value set according to the flag. If it is not
    set (that is the case if neither `-b` and `-g` are specified), we print a generic
    greeting that omits gender.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 继续，当我们的`case`语句以`esac`结束时，我们进入实际的功能。我们检查`gender`变量是否已定义：如果是，我们打印一个包含根据标志设置的值的消息。如果没有设置（即如果未指定`-b`和`-g`），我们打印一个省略性别的通用问候。
- en: 'This is also why we `exit 0` after we find `-h`: otherwise both the help message
    and the greeting would be given to the user (which is weird, since the user asks
    *just* for the help page with `-h`).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么我们在找到“-h”后会`exit 0`：否则帮助信息和问候语都会显示给用户（这很奇怪，因为用户只是要求使用“-h”查看帮助页面）。
- en: 'Let''s see our script in action:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的脚本是如何运行的：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So far, so good! If we call it with `-h`, we see the multi-line help message
    printed. By default, each `echo` ends with a newline character, so our five echoes
    are printed on five lines. We could have worked with a single `echo` and the `\n`
    characters, but this is more readable
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很顺利！如果我们使用`-h`调用它，将看到打印的多行帮助信息。默认情况下，每个`echo`都以换行符结束，因此我们的五个`echo`将打印在五行上。我们可以使用单个`echo`和`\n`字符，但这样更易读。
- en: If we run our script without flags, we'll see the generic greeting. Running
    it with either `-b` or `-g` will give the gender-specific greeting. Wasn't that
    easy?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在没有标志的情况下运行脚本，将看到通用的问候语。使用`-b`或`-g`运行它将给出特定性别的问候语。是不是很容易？
- en: It actually was! However, it is about to get a little bit more complicated.
    As we've explained before, users tend to be rather unpredictable, and would perhaps
    use too many flags, or the same flags multiple times.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上是这样的！但是，情况即将变得更加复杂。正如我们之前解释过的，用户往往是相当不可预测的，可能会使用太多的标志，或者多次使用相同的标志。
- en: 'Let''s take a look at how our script reacts to this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的脚本对此做出了怎样的反应：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'So, regardless of how many flags are specified, as long as the script encounters
    the `-h` flag, it will print the help message and exit (due to `exit 0`). For
    your understanding, run the preceding commands in debug with `bash -x` to see
    that they do actually differ, even though the user does not see this (hint: check
    for assignments of `gender=boy` and `gender=girl`).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只要指定了多少个标志，只要脚本遇到`-h`标志，它就会打印帮助消息并退出（由于`exit 0`）。为了您的理解，在调试模式下使用`bash -x`运行前面的命令，以查看它们实际上是不同的，即使用户看不到这一点（提示：检查`gender=boy`和`gender=girl`的赋值）。
- en: 'This brings us to an important point: *flags are parsed in the order they are
    supplied by the user!* To further illustrate this point, let''s look at another
    example of a user messing with flags:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们来一个重要的观点：*标志是按用户提供的顺序解析的！*为了进一步说明这一点，让我们看另一个用户搞乱标志的例子：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When the user supplies both the `-b` and `-g` flag, both variable assignments
    for gender are performed by the system. However, it seems as though the final
    flag is the one that wins, even though we just stated that the flags are parsed
    in order! Why would that be?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户同时提供`-b`和`-g`标志时，系统会执行性别的两个变量赋值。然而，似乎最终的标志才是赢家，尽管我们刚刚说过标志是按顺序解析的！为什么会这样呢？
- en: 'As always, a nice `bash -x` gives us a good idea of this situation:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，一个不错的`bash -x`让我们对这种情况有了一个很好的了解：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Initially, the `gender` variable is assigned the value of `boy`. However, when
    the next flag is parsed, the value of the variable is *overwritten with a new
    value*, `girl`. Since the `-g` flag is the final one, the `gender` variable ends
    as `girl`, and thus that is what is printed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`gender`变量被赋予`boy`的值。然而，当解析下一个标志时，变量的值被*覆盖*为一个新值，`girl`。由于`-g`标志是最后一个，`gender`变量最终变成`girl`，因此打印出来的就是这个值。
- en: 'As you will see in the next part of this chapter, it is possible to supply
    an argument to a flag. For flags without arguments, though, there is a really
    cool feature that many commands use: flag chaining. It might sound complicated,
    but it is actually pretty simple: if you have multiple flags, you can place them
    all behind a single dash.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在本章的下一部分中看到的，可以向标志提供参数。不过，对于没有参数的标志，有一个非常酷的功能，许多命令都在使用：标志链接。听起来可能很复杂，但实际上非常简单：如果有多个标志，可以将它们全部放在一个破折号后面。
- en: 'For our script, it looks like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的脚本，情况是这样的：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We specified all flags as one bunch: instead of `-b -g -h`, we used `-bgh`.
    As we concluded before, the flags are processed in order, which is still the case
    in our concatenated example (as the debug instruction clearly shows). This is
    not much different to an `ls -al`, for example. Again, this only works if a flag
    does not have an argument.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有标志都指定为一组：而不是`-b -g -h`，我们使用了`-bgh`。正如我们之前得出的结论，标志是按顺序处理的，这在我们连接的例子中仍然是这样（正如调试指令清楚地显示的那样）。这与`ls
    -al`并没有太大的不同。再次强调，这仅在标志没有参数时才有效。
- en: Flags with arguments
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带参数的标志
- en: 'In an `optstring`, the colon has an extra meaning beyond turning off verbose
    error logging: when placed after a letter, it signals to `getopts` that an *option
    argument* is expected.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`optstring`中，冒号除了关闭冗长的错误日志记录之外还有另一个意义：当放在一个字母后面时，它向`getopts`发出信号，表示期望一个*选项参数*。
- en: 'If we look back at our first example, the `optstring` was simply `:v`. If we
    wanted the `-v` flag to accept an argument, we would place a colon behind the
    `v`, which would result in the following `optstring`: `:v:`. We can then use a
    special variable we''ve seen before, `OPTARG`, to grab that ***opt**ion **arg**ument*.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下我们的第一个例子，`optstring`只是`:v`。如果我们希望`-v`标志接受一个参数，我们会在`v`后面放一个冒号，这将导致以下`optstring`：`:v:`。然后我们可以使用一个我们之前见过的特殊变量`OPTARG`来获取那个***选**项
    **参**数*。
- en: 'We''ll make a revision to our `single-flag.sh` script to show you how this
    works:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对我们的`single-flag.sh`脚本进行修改，以向您展示它是如何工作的：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The changed lines have been highlighted for your convenience. By adding a colon
    to the `optstring` and using the `OPTARG` variable in the `v)` block, we now see
    the following behavior when running the script:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 已更改的行已经为您突出显示。通过在`optstring`中添加一个冒号，并在`v)`块中使用`OPTARG`变量，我们现在看到了运行脚本时的以下行为：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, as long as we supply the flag and flag argument, our script
    works just fine. We do not even need a space between the flag and flag argument;
    since `getopts` knows an argument is expected, it can handle either a space or
    no space. We'd always recommend including the space in any case, to ensure readability,
    but it is not technically needed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，只要我们提供标志和标志参数，我们的脚本就可以正常工作。我们甚至不需要在标志和标志参数之间加上空格；由于`getopts`知道期望一个参数，它可以处理空格或无空格。我们始终建议在任何情况下都包括空格，以确保可读性，但从技术上讲并不需要。
- en: 'Also, this proves why we need a separate `optstring`: the `case` statement
    is the same, but `getopts` now expects an argument, something we could not have
    done if the creators had omitted the `optstring`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这也证明了为什么我们需要一个单独的`optstring`：`case`语句是一样的，但是`getopts`现在期望一个参数，如果创建者省略了`optstring`，我们就无法做到这一点。
- en: 'As with all things that seem too good to be true, this is one of those situations.
    While it works fine if the user is nice to your script, if he/she is not, the
    following might happen:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就像所有看起来太好以至于不真实的事情一样，这就是其中之一。如果用户对你的脚本友好，它可以正常工作，但如果他/她不友好，可能会发生以下情况：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now that we've told `getopts` to expect an argument to the `-v` flag, it will
    actually not correctly identify the flag if there is no argument. An empty argument,
    as denoted by the `''` in the second script call, is fine, however. (Technically
    fine, that is, since no user would ever do that.)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经告诉`getopts`期望`-v`标志的参数，如果没有参数，它实际上将无法正确识别该标志。但是，空参数，如第二个脚本调用中的`''`，是可以的。
    （从技术上讲是可以的，因为没有用户会这样做。）
- en: 'Fortunately, there is a solution for this—the `:)` block, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个解决方案——`:)`块，如下所示：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It might be a little confusing that both a wrong flag and a missing option argument
    are resolved as the `OPTARG`. Without making this situation more complicated than
    it has to be, it all depends on whether the `case` statement block contains `?)`
    or `:)` at that moment. For `?)` blocks, everything that is not recognized (the
    whole flag) is seen as the option argument, and `:)` blocks only trigger when
    the `optstring` contains the proper instruction for an option with an argument.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有点令人困惑，错误的标志和缺少的选项参数都解析为`OPTARG`。不要把这种情况弄得比必要的更复杂，这一切取决于`case`语句块在那一刻包含`?)`还是`:)`。对于`?)`块，所有未被识别的内容（整个标志）都被视为选项参数，而`:)`块只有在`optstring`包含带参数选项的正确指令时才触发。
- en: 'Everything should work just as intended now:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都应该按预期工作：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Again, because of the sequential processing of flags, the final call never gets
    to the `-v` flag due to the `exit 1` in the `?)` block. However, all other situations
    are now properly resolved. Nice!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，由于标志的顺序处理，由于`?)`块中的`exit 1`，最终调用永远不会到达`-v`标志。但是，所有其他情况现在都得到了正确解决。不错！
- en: The actual processing that `getopts` does involves multiple passes and the use
    of `shift`. This is a little too technical for this chapter, but for those curious
    among you, the *Further reading* section includes a *very* in-depth explanation
    of this mechanism that you can read at your leisure.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`getopts`实际处理涉及多次传递和使用`shift`。这对于本章来说有点太技术性了，但对于你们中间感兴趣的人来说，*进一步阅读*部分包括了这个机制的*非常*深入的解释，你可以在空闲时阅读。'
- en: Combining flags with positional arguments
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将标志与位置参数结合使用
- en: 'It is possible to combine positional arguments (in the way we''ve been using
    them before this chapter) with options and option arguments. There are some things
    to consider in this scenario:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将位置参数（在本章之前我们一直使用的方式）与选项和选项参数结合使用。在这种情况下，有一些事情需要考虑：
- en: By default, Bash recognizes flags such as `-f` as positional parameters
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Bash将识别标志（如`-f`）作为位置参数
- en: Just as there is an order to flags and flag arguments, there is an order for
    flags and positional parameters
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像标志和标志参数有一个顺序一样，标志和位置参数也有一个顺序
- en: When dealing with a mix of `getopts` and positional arguments, the *flags and
    flag options should always be provided before the positional arguments! *This
    is because we want to parse and handle all flags and flag arguments before we
    get to the positional parameters. This is a fairly typical scenario for both scripts
    and command-line tools, but it is still something we have to consider.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 处理`getopts`和位置参数时，*标志和标志选项应始终在位置参数之前提供！*这是因为我们希望在到达位置参数之前解析和处理所有标志和标志参数。这对于脚本和命令行工具来说是一个相当典型的情况，但这仍然是我们必须考虑的事情。
- en: 'All of the preceding points are best illustrated with an example, as always.
    We''re going to create a simple script that serves as a wrapper for common file
    operations. With this script, `file-tool.sh`, we will be able to do the following
    things:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的所有观点最好通过一个例子来说明，我们将创建一个简单的脚本，作为常见文件操作的包装器。有了这个脚本`file-tool.sh`，我们将能够做以下事情：
- en: List a file (default behavior)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出文件（默认行为）
- en: Delete a file (with the `-d` option)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除文件（使用`-d`选项）
- en: Empty a file (with the `-e` option)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清空文件（使用`-e`选项）
- en: Rename a file (with the `-m` option, which includes another filename)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名文件（使用`-m`选项，其中包括另一个文件名）
- en: Call the help function (with `-h`)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用帮助函数（使用`-h`）
- en: 'Take a look at the script:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下脚本：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That's a big one, isn't it? We've shortened it just a little bit by compacting
    multiple lines into single lines (within the `case` statement), but it's still
    not a short script. While it might seem intimidating at first, we're sure that
    with your exposure up until now, and the comments in the script, this should be
    understandable to you. If it is not fully understandable just yet, don't worry—we're
    going to explain all the new and interesting lines now.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个大的例子，不是吗？我们通过将多行压缩成单行（在`case`语句中）稍微缩短了一点，但它仍然不是一个短脚本。虽然一开始可能看起来令人生畏，但我们相信通过你到目前为止的接触和脚本中的注释，这对你来说应该是可以理解的。如果现在还不完全理解，不要担心——我们现在将解释所有新的有趣的行。
- en: 'We''re skipping the header, the `print_help()` function, and the default command
    of `ls -l`. The first interesting bit will be the `optstring`, which now contains
    options with and without option arguments:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跳过了标题，`print_help()`函数和`ls -l`的默认命令。第一个有趣的部分将是`optstring`，它现在包含有和没有选项参数的选项：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When we get to the `m)` block, we save the option argument in the `new_filename` variable
    for later use.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达`m)`块时，我们将选项参数保存在`new_filename`变量中以供以后使用。
- en: 'When we''re done with the `case` statement for `getopts`, we run into a command
    that we''ve briefly seen before: `shift`. This command allows us to move our positional
    arguments around: if we do `shift 2`, the argument `$4` becomes `$2`, the argument `$3`
    becomes `$1`, and the old `$1` and `$2` are removed.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成`getopts`的`case`语句后，我们遇到了一个我们之前简要见过的命令：`shift`。这个命令允许我们移动我们的位置参数：如果我们执行`shift
    2`，参数`$4`变成了`$2`，参数`$3`变成了`$1`，旧的`$1`和`$2`被移除了。
- en: 'When dealing with a positional parameter behind flags, all flags and flag arguments
    are seen as positional arguments as well. In this case, if we call the script
    as `file-tool.sh -m newfile /tmp/oldfile`, the following will be interpreted by
    Bash:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 处理标志后面的位置参数时，所有标志和标志参数也被视为位置参数。在这种情况下，如果我们将脚本称为`file-tool.sh -m newfile /tmp/oldfile`，Bash将解释如下：
- en: '`$1`: Interpreted as `-m`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$1`：被解释为`-m`'
- en: '`$2`: Interpreted as a new file'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$2`：被解释为一个新文件'
- en: '`$3`: Interpreted as `/tmp/oldfile`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$3`：被解释为`/tmp/oldfile`'
- en: 'Fortunately, `getopts` saves the options (and option arguments) it has processed
    in a variable: `$OPTIND` (from ***opt**ions **ind**ex*). To be even more precise,
    after it has parsed an option, it sets `$OPTIND` to the next possible option or
    option argument: it starts at 1 and ends when it finds the first non-option argument
    passed to the script.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`getopts`将它处理过的选项（和选项参数）保存在一个变量中：`$OPTIND`（来自***opt**ions **ind**ex*）。更准确地说，在解析了一个选项之后，它将`$OPTIND`设置为下一个可能的选项或选项参数：它从1开始，在找到传递给脚本的第一个非选项参数时结束。
- en: 'In our example, once `getopts` reaches our positional parameter of `/tmp/oldfile`,
    the `$OPTIND` variable will be `3`. Since we just need to `shift` everything before
    that point away, we subtract 1 from the `$OPTIND`, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，一旦`getopts`到达我们的位置参数`/tmp/oldfile`，`$OPTIND`变量将为`3`。由于我们只需要将该点之前的所有内容`shift`掉，我们从`$OPTIND`中减去1，如下所示：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Remember, `$(( ... ))` is shorthand for arithmetic; the resulting number is
    used in the `shift` command. The rest of the script is pretty straightforward:
    we''ll do some checks to ensure we only have one positional parameter left (the
    filename of the file that we want to manipulate), and whether we have write permissions
    on that file.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`$(( ... ))`是算术的简写；得到的数字用于`shift`命令。脚本的其余部分非常简单：我们将进行一些检查，以确保我们只剩下一个位置参数（我们想要操作的文件的文件名），以及我们是否对该文件具有写权限。
- en: Next, depending on which operations we have selected, we'll either do a complex
    one for the `mv`, or a simple one for all the others. For the rename command,
    we'll use a bit of command substitution to determine the directory name of the
    original filename, which we will then reuse in the rename.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，根据我们选择的操作，我们将为`mv`执行一个复杂的操作，或者为其他所有操作执行一个简单的操作。对于重命名命令，我们将使用一些命令替换来确定原始文件名的目录名称，然后我们将在重命名中重用它。
- en: If we did our tests like we should, the script should be fully functional with
    all the requirements we set out. We encourage you to give it a try.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像应该做的那样进行了测试，脚本应该符合我们设定的所有要求。我们鼓励你尝试一下。
- en: 'Even better, see if you can come up with a situation that we have not thought
    of that breaks the script''s functionality. If you do find something (spoiler
    alert: we know of a few shortcomings!), try to fix them yourself.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，看看你是否能想出一个我们没有考虑到的情况，破坏了脚本的功能。如果你找到了什么（剧透警告：我们知道有一些缺点！），试着自己修复它们。
- en: As you may start to realize, we're entering territory in which it is very hard
    to harden scripts for every user input. For example, in the last example, if we
    supply the `-m` option but omit the content, the filename we supply will be seen
    as the option argument. In this case, instead of throwing an error for a missing
    option argument, our script will `shift` the filename away and complain that it
    doesn't have it. While this script should serve for educational purposes, it is
    not something that we would trust for our workplace scripting. It is often better
    not to mix `getopts` with positional arguments, as you would avoid many of the
    complexities we've faced here. Just have the user supply the filename as another
    option argument (`-f`, anyone?) and you'll be much happier!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能开始意识到的那样，我们正在进入一个非常难以为每个用户输入加固脚本的领域。例如，在最后一个例子中，如果我们提供了`-m`选项但省略了内容，我们提供的文件名将被视为选项参数。在这种情况下，我们的脚本将`shift`掉文件名并抱怨它没有。虽然这个脚本应该用于教育目的，但我们不会相信它用于我们的工作场所脚本。最好不要将`getopts`与位置参数混合使用，因为这样可以避免我们在这里面对的许多复杂性。只需让用户提供文件名作为另一个选项参数（`-f`，任何人？），你会更加快乐！
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter started with a recap of how positional parameters are used in Bash.
    We continued by showing you how most command-line tools we've introduced up until
    this point (and those we haven't) use flags, often as *modifiers* for script functionality,
    whereas positional parameters are used to indicate *targets* for the commands.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以回顾Bash中如何使用位置参数开始。我们继续向您展示了到目前为止我们介绍的大多数命令行工具（以及我们没有介绍的那些）如何使用标志，通常作为脚本功能的*修饰符*，而位置参数则用于指示命令的*目标*。
- en: 'We then introduced a way for the reader to incorporate options and option arguments
    within their own scripts: by using the `getopts` shell builtin. We kicked this
    off by discussing the differences between the legacy program `getopt` and the
    newer builtin `getopts`, which we focused on for the rest of this chapter.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了一种让读者在自己的脚本中结合选项和选项参数的方法：使用`getopts` shell内置。我们从讨论传统程序`getopt`和较新的内置`getopts`之间的区别开始，然后我们在本章的其余部分重点讨论了`getopts`。
- en: Since `getopts` only allows us to use short options (whereas `getopt` and some
    other command-line tools also use long options, denoted by double dashes), we
    showed you how this is not an issue due to the recognition of common short options
    such as `-h`, `-v`, and so on.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`getopts`只允许我们使用短选项（而`getopt`和其他一些命令行工具也使用长选项，用双破折号表示），我们向您展示了由于识别常见的短选项（如`-h`，`-v`等）而不是问题。
- en: We properly introduced the `getopts` syntax with a few examples. We showed how
    you can use flags with and without flag arguments, and how we need an `optstring`
    to signal to `getopts` which options have arguments (and which options to even
    expect).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用几个例子正确介绍了`getopts`的语法。我们展示了如何使用带有和不带有标志参数的标志，以及我们如何需要一个`optstring`来向`getopts`发出信号，表明哪些选项有参数（以及期望哪些选项）。
- en: We ended this chapter by showing you how options and option arguments could
    be combined with positional parameters by cleverly using the `shift` command to
    deal with this.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过聪明地使用`shift`命令来处理选项和选项参数与位置参数的组合，结束了这一章节。
- en: 'The following commands were introduced in this chapter: `getopts` and `shift`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了以下命令：`getopts`和`shift`。
- en: Questions
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why are flags often used as modifiers whereas positional parameters are used
    as targets?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么标志经常被用作修饰符，而位置参数被用作目标？
- en: Why do we run `getopts` in a `while` loop?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在`while`循环中运行`getopts`？
- en: Why do we need `?)` in the `case` statement?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在`case`语句中需要`?)`？
- en: Why do we (sometimes) need `:)` in the `case` statement?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们（有时）在`case`语句中需要`:)`？
- en: Why do we need a separate `optstring` if we're resolving all options anyway?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们无论如何都要解析所有选项，为什么还需要一个单独的`optstring`？
- en: Why do we need to subtract 1 from the `OPTIND` variable when we use it in `shift`?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在使用`shift`时需要从`OPTIND`变量中减去1？
- en: Is it a good idea to mix options with positional arguments?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选项与位置参数混合使用是个好主意吗？
- en: Further reading
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Pleas refer to the following links for more information on the topics in this
    chapter:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下链接，了解本章主题的更多信息：
- en: 'Bash-hackers on `getopts`: [http://wiki.bash-hackers.org/howto/getopts_tutorial](http://wiki.bash-hackers.org/howto/getopts_tutorial)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash-hackers对`getopts`的解释：[http://wiki.bash-hackers.org/howto/getopts_tutorial](http://wiki.bash-hackers.org/howto/getopts_tutorial)
- en: '`getopts` in depth: [https://www.computerhope.com/unix/bash/getopts.htm](https://www.computerhope.com/unix/bash/getopts.htm)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解`getopts`：[https://www.computerhope.com/unix/bash/getopts.htm](https://www.computerhope.com/unix/bash/getopts.htm)
