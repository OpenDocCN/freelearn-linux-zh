- en: 'Chapter 8: Exploring Continuous Configuration Automation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：探索持续配置自动化
- en: Until now, we have worked with single VMs, deploying and configuring them manually.
    This is nice for labs and very small environments, but if you have to manage bigger
    environments, this is a very time-consuming and even boring job. It's also very
    easy to make mistakes and forget things, such as the slight differences between
    VMs, not to mention the concomitant stability and security risks. For example,
    choosing the wrong version during deployment will result in consistency issues,
    and performing an upgrade later is a tedious process.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用单个VM，手动部署和配置它们。这对实验室和非常小的环境很好，但是如果您必须管理更大的环境，这是一项非常耗时甚至令人厌倦的工作。犯错误和遗漏事项也非常容易，例如VM之间的细微差异，更不用说相关的稳定性和安全风险了。例如，在部署过程中选择错误的版本将导致一致性问题，以后进行升级是一个繁琐的过程。
- en: 'Automating deployment and configuration management is the ideal way to mitigate
    this boring task. However, after a while, you might notice some problems with
    that approach. There are so many reasons why there are problems, and some of the
    reasons for failure are listed here:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化部署和配置管理是缓解这项乏味任务的理想方式。然而，过一段时间，您可能会注意到这种方法存在一些问题。存在许多原因导致问题，以下是一些失败的原因：
- en: The script fails because something changed, caused by, for instance, a software
    update.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本失败是因为有些东西发生了变化，例如软件更新引起的。
- en: There is a newer version of a base image that is slightly different.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个稍有不同的基础镜像的新版本。
- en: Scripts can be hard to read and difficult to maintain.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本可能很难阅读，难以维护。
- en: Scripts are dependent on other components; for instance, the OS, script language,
    and available internal and external commands.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本依赖于其他组件；例如，操作系统、脚本语言和可用的内部和外部命令。
- en: And, there is always that one colleague—the script works for you but, for some
    reason, it always fails when they execute it.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总有那么一个同事——脚本对你有效，但是，由于某种原因，当他们执行时总是失败。
- en: 'Of course, things have improved over time:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，随着时间的推移，事情已经有所改善：
- en: Many script languages are multiplatform now, such as Bash, Python, and PowerShell.
    They are available on Windows, macOS, and Linux.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多脚本语言现在是多平台的，例如Bash、Python和PowerShell。它们在Windows、macOS和Linux上都可用。
- en: In `systemd`, the `systemctl` utility with the `-H` parameter can execute commands
    remotely, and it works even if the remote host is another Linux distribution.
    The newer `systemd` version has more features.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`systemd`中，带有`-H`参数的`systemctl`实用程序可以远程执行命令，即使远程主机是另一个Linux发行版也可以执行。更新的`systemd`版本具有更多功能。
- en: '`firewalld` and `systemd` work with easy-to-deploy configuration files and
    overrides.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firewalld`和`systemd`使用易于部署的配置文件和覆盖。'
- en: 'Automation is most likely not the answer in your quest to deploy, install,
    configure, and manage your workload. Luckily, there is another way: orchestration.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化很可能不是您部署、安装、配置和管理工作负载的答案。幸运的是，还有另一种方法：编排。
- en: In musical terms, orchestration is the study of how to write music for an orchestra.
    You have to understand each instrument and know what sounds they can make. Then,
    you can start writing the music; to do this, you have to understand how the instruments
    sound together. Most of the time, you start with a single instrument, for instance,
    a piano. After that, you scale up to include the other instruments. Hopefully,
    the result will be a masterpiece and the members of the orchestra will be able
    to start playing it. It's not that important how the members start, but, in the
    end, the conductor makes sure that the results count.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从音乐角度来看，编排是研究如何为管弦乐队谱写音乐的学问。您必须了解每种乐器，并知道它们可以发出什么声音。然后，您可以开始谱写音乐；为此，您必须了解乐器如何共同发声。大多数情况下，您从单个乐器开始，例如钢琴。之后，您可以扩展到包括其他乐器。希望结果将是一部杰作，管弦乐队的成员将能够开始演奏。成员如何开始并不重要，但最终指挥确保结果重要。
- en: 'There are many similarities to orchestration in computation. Before you can
    start, you have to understand how all the components work, how they fit together,
    and what the components do so that you can get the job done. After that, you can
    start writing the code to achieve the ultimate goal: a manageable environment.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算中有许多与编排相似的地方。在开始之前，您必须了解所有组件的工作原理，它们如何配合以及组件的功能，以便完成工作。之后，您可以开始编写代码以实现最终目标：一个可管理的环境。
- en: One of the biggest advantages of a cloud environment is that really every component
    of the environment is written in software. Yes, we know, at the end of the line,
    there is still a datacenter with many hardware components, but as a cloud user,
    you don't care about that. Everything you need is written in software and has
    APIs to talk to. So, it's not only possible to automate the deployment of your
    Linux workloads, but you can automate and orchestrate the configuration of the
    Linux operating system and the installation and configuration of applications
    and keep everything up to date. You can also use orchestration tools to configure
    Azure resources, and it's even possible to create Linux VMs using these tools.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 云环境最大的优势之一是环境的每个组件都是以软件编写的。是的，我们知道，在最后一行，仍然有许多硬件组件的数据中心，但作为云用户，您不必关心这一点。您需要的一切都是以软件编写的，并且具有API进行通信。因此，不仅可以自动化部署Linux工作负载，还可以自动化和编排Linux操作系统的配置以及应用程序的安装和配置，并保持一切更新。您还可以使用编排工具配置Azure资源，甚至可以使用这些工具创建Linux
    VM。
- en: 'In orchestration, there are two different approaches:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在编排中，有两种不同的方法：
- en: '**Imperative**: Tell the orchestration tool what to do to reach this goal'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令式**：告诉编排工具如何达到这个目标'
- en: '**Declarative**: Tell the orchestration tool what the goal you want to achieve
    is'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明性**：告诉编排工具您要实现的目标是什么'
- en: Some orchestration tools can do both, but, in general, the declarative approach
    is the better approach in a cloud environment, where you have so many options
    to configure and you can declare each option and achieve the exact goal. The good
    news is that if it's becoming too complex for this method, for instance, when
    the orchestration tool is not able to understand the goal, you can always extend
    this method with a little bit of the imperative method using scripts.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编排工具可以同时执行这两种方法，但总的来说，在云环境中，声明性方法是更好的方法，因为您有很多选项可以配置，并且可以声明每个选项并实现确切的目标。好消息是，如果这种方法变得太复杂，例如，当编排工具无法理解目标时，您总是可以使用一点命令方法来扩展这种方法，使用脚本。
- en: A big part of this chapter is about Ansible, but we'll also cover PowerShell
    **Desired State Configuration** (**DSC**) and Terraform as examples of declarative
    implementations. The focus, in this chapter, is to understand orchestration and
    know enough to get started. And, of course, we'll discuss integration with Azure.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是 Ansible，但我们还将涵盖 PowerShell **期望状态配置**（**DSC**）和 Terraform 作为声明性实现的示例。本章的重点是理解编排并了解足够的知识以开始。当然，我们还将讨论与
    Azure 的集成。
- en: 'The key takeaways from this chapter are:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要要点是：
- en: Understanding the third-party automation tools such as Ansible and Terraform
    and how they can be used in Azure.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解诸如 Ansible 和 Terraform 等第三方自动化工具以及它们在 Azure 中的使用方式。
- en: Using Azure's native automation and PowerShell DSC to achieve the desired state
    of the machine.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure 的本地自动化和 PowerShell DSC 来实现机器的期望状态。
- en: How to implement Azure Policy Guest Configuration and audit the settings in
    your Linux VMs.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 Linux 虚拟机中实现 Azure 策略客户端配置并审计设置。
- en: An overview of other solutions available on the market to automate deployments
    and configuration.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述市场上其他可用的自动化部署和配置解决方案。
- en: Technical Requirements
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 技术要求
- en: In practice, you'll need at least one VM as a control machine, or you can use
    your workstation running Linux or **Windows Subsystem for Linux** (**WSL**). Along
    with this, we need a node, which needs to be an Azure VM. However, in order to
    provide a better explanation, we've deployed three nodes. If you have budget constraints
    in your Azure subscription, feel free to proceed with one node. It doesn't matter
    which Linux distribution you're using. The examples in this section, to orchestrate
    the node, are for an Ubuntu node, but it's easy to translate them to other distributions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，您至少需要一个虚拟机作为控制机，或者您可以使用运行 Linux 或 **Windows 子系统**（**WSL**）的工作站。除此之外，我们还需要一个节点，该节点需要是
    Azure 虚拟机。但是，为了提供更好的解释，我们部署了三个节点。如果您的 Azure 订阅受到预算限制，请随时继续使用一个节点。您使用的 Linux 发行版并不重要。本节中的示例用于编排节点，是针对
    Ubuntu 节点的，但很容易将其转换为其他发行版。
- en: In this chapter, multiple orchestration tools are explored. For every tool,
    you'll need a clean environment. So, when you are finished with the Ansible section
    in this chapter, remove the VMs and deploy new ones before going into Terraform.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将探讨多种编排工具。对于每个工具，您需要一个干净的环境。因此，在本章中完成 Ansible 部分后，进入 Terraform 之前，请删除虚拟机并部署新的虚拟机。
- en: Understanding Configuration Management
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解配置管理
- en: 'In the introduction of this chapter, you might have read the term *configuration
    management*. Let''s understand this in more depth. Configuration management refers
    to how you want your VM to be configured. For example, you want an Apache webserver
    to host a website in a Linux VM; so, the configuration part of the VM involves:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的介绍中，您可能已经读到了术语*配置管理*。让我们更深入地了解一下。配置管理是指您希望如何配置虚拟机。例如，您希望在 Linux 虚拟机中配置 Apache
    Web 服务器以托管网站；因此，虚拟机的配置部分涉及：
- en: Installation of Apache package and dependencies
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Apache 软件包和依赖项
- en: Opening firewall ports for HTTP traffic or HTTPS traffic if you are using SSL
    (Secure Sockets Layer) certificates
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 HTTP 流量或 HTTPS 流量打开防火墙端口（如果使用 SSL（安全套接字层）证书）
- en: Enabling the service and bootstrapping it so the Apache service is started on
    boot
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用服务并引导它，以便 Apache 服务在启动时启动
- en: This example is for a very simple web server. Think about a complex scenario
    where you have a front-end web server and back-end databases, so the configuration
    involved is very high. So far, we've been talking about a single VM; what if you
    want multiple VMs with the same configuration? We are back to square one, where
    you have to repeat the configuration multiple times, which is a time-consuming
    and boring task. Here comes the role of orchestration, as we discussed in the
    introduction. We can make use of orchestration tools to deploy the VM with the
    state we want. The tools will take care of the configuration. Also, in Azure,
    we have Azure Policy Guest Configuration, which can be used to audit the settings.
    Using this policy, we can define a condition that the VM should be in. If the
    evaluation fails or the condition is not met, Azure will mark this machine as
    non-compliant.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是一个非常简单的 Web 服务器。想象一下一个复杂的场景，您有一个前端 Web 服务器和后端数据库，因此涉及的配置非常复杂。到目前为止，我们一直在谈论单个虚拟机；如果您想要具有相同配置的多个虚拟机怎么办？我们又回到了起点，您必须多次重复配置，这是一项耗时且乏味的任务。这就是编排的作用，正如我们在介绍中讨论的那样。我们可以利用编排工具部署我们想要的虚拟机状态。这些工具将负责配置。此外，在
    Azure 中，我们有 Azure 策略客户端配置，可用于审计设置。使用此策略，我们可以定义虚拟机应该处于的条件。如果评估失败或条件未满足，Azure 将标记此计算机为不符合规定。
- en: A big part of this chapter is about Ansible, but we'll also cover PowerShell
    DSC and Terraform as examples of declarative implementations. The focus, in this
    chapter, is to understand orchestration and learn enough to get started. And,
    of course, we'll discuss integration with Azure.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是 Ansible，但我们还将涵盖 PowerShell DSC 和 Terraform 作为声明性实现的示例。本章的重点是理解编排并学习足够的知识以开始。当然，我们还将讨论与
    Azure 的集成。
- en: Using Ansible
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ansible
- en: 'Ansible is minimal in nature, has almost no dependencies, and it doesn''t deploy
    agents to nodes. Only OpenSSH and Python are required for Ansible. It''s also
    highly reliable: changes can be applied multiple times without changing the result
    beyond the initial application and there shouldn''t be any side effects on the
    rest of the system (unless you write really bad code). There is a strong focus
    on the reuse of code, which makes it even more reliable.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible在本质上是最小的，几乎没有依赖性，并且不会向节点部署代理。对于Ansible，只需要OpenSSH和Python。它也非常可靠：可以多次应用更改而不会改变初始应用的结果，并且不应该对系统的其余部分产生任何副作用（除非您编写了非常糟糕的代码）。它非常注重代码的重用，这使得它更加可靠。
- en: Ansible doesn't have a very steep learning curve. You can start with just a
    few lines of code and scale up afterward without breaking anything. In our opinion,
    if you want to try an orchestration tool, start with Ansible, and if you want
    to try another, the learning curve will be much less steep.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的学习曲线并不是很陡峭。您可以从几行代码开始，然后逐渐扩展，而不会破坏任何东西。在我们看来，如果您想尝试一个编排工具，可以从Ansible开始，如果您想尝试另一个编排工具，学习曲线会陡峭得多。
- en: Installation of Ansible
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Ansible
- en: 'In Azure Marketplace, a ready-to-go VM is available for Ansible. There are
    three versions of Ansible available in Azure Marketplace currently: Ansible Instance,
    Ansible Tower, and AWX, which is a Community edition of Ansible Tower. In this
    book, we will concentrate on the community project that is freely available; it''s
    more than enough to learn and get started with Ansible. After that, you can go
    to the Ansible website to explore the differences, download the trial version
    of the enterprise edition of Ansible, and decide whether you need the enterprise
    version.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure Marketplace中，有一个可用于Ansible的即用型VM。目前Azure Marketplace中有三个版本的Ansible：Ansible实例、Ansible
    Tower和AWX，这是Ansible Tower的社区版。在本书中，我们将集中讨论这个免费提供的社区项目；这已经足够学习和开始使用Ansible了。之后，您可以转到Ansible网站，探索差异，下载企业版的试用版Ansible，并决定是否需要企业版。
- en: 'There are multiple ways to install Ansible:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Ansible有多种方法：
- en: Using the repository of your distribution
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您的发行版存储库
- en: Using the latest release available at [https://releases.ansible.com/ansible](https://releases.ansible.com/ansible
    )
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[https://releases.ansible.com/ansible](https://releases.ansible.com/ansible)上可用的最新版本
- en: 'Using GitHub: [https://github.com/ansible](https://github.com/ansible )'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GitHub：[https://github.com/ansible](https://github.com/ansible)
- en: 'Using the Python installer, the preferred method, which works on every OS:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用首选方法Python安装程序，该方法适用于每个操作系统：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Python''s `pip` is not available for installation in the standard repositories
    of Red Hat and CentOS. You have to use the extra EPEL repository:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Red Hat和CentOS的标准存储库中没有Python的`pip`可用于安装。您必须使用额外的EPEL存储库：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After installing Ansible, check the version:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完Ansible后，检查版本：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You don''t have to install Ansible if you don''t want to: Ansible is preinstalled
    in Azure Cloud Shell. At the time of writing this book, Cloud Shell supports Ansible
    version 2.9.0\. However, to give a walk-through of the installation, we''ll go
    for the local installation of Ansible on the VM. For integration with Azure, you
    also need to install the Azure CLI to get the information you''ll need to provide
    to Ansible.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想安装Ansible，则无需安装：Azure Cloud Shell中预安装了Ansible。在撰写本书时，Cloud Shell支持Ansible版本2.9.0。但是，为了介绍安装过程，我们将选择在VM上本地安装Ansible。要与Azure集成，您还需要安装Azure
    CLI以获取您需要提供给Ansible的信息。
- en: SSH Configuration
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SSH配置
- en: The machine where you installed Ansible is now called the ansible-master or,
    in other words, it's just a VM with Ansible, the Ansible configuration file, and
    the instructions for orchestration. Communication with the nodes is done using
    communication protocols. For Linux, SSH is used as a communication protocol. To
    make Ansible be able to communicate in a secure way with the nodes, use key-based
    authentication. If this has not already been done, generate an SSH key pair and
    copy the key to the VM you want to orchestrate.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您安装Ansible的机器现在被称为ansible-master，换句话说，它只是一个带有Ansible、Ansible配置文件和编排指令的虚拟机。与节点的通信使用通信协议进行。对于Linux，SSH被用作通信协议。为了使Ansible能够以安全的方式与节点通信，使用基于密钥的身份验证。如果尚未完成此操作，请生成一个SSH密钥对并将密钥复制到要编排的虚拟机。
- en: 'To generate the SSHs key, use this command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成SSH密钥，请使用此命令：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you generate the key, it will be saved to the home directory of the user
    in the `.ssh` directory by default. To display the key, use this command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成密钥，默认情况下，它将保存在用户的主目录中的`.ssh`目录中。要显示密钥，请使用此命令：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once we have the key, we have to copy this value to the node server. Follow
    these steps to copy the key:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了密钥，我们必须将该值复制到节点服务器。按照以下步骤复制密钥：
- en: Copy the contents of the `id_rsa.pub` file.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`id_rsa.pub`文件的内容。
- en: SSH to your node server.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSH到您的节点服务器。
- en: Switch to superuser using the `sudo` command.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sudo`命令切换到超级用户。
- en: Edit the `authorized_keys` file in `~/.ssh/`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`~/.ssh/`中的`authorized_keys`文件。
- en: Paste the key we copied from the Ansible server.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 粘贴我们从Ansible服务器复制的密钥。
- en: Save and close the file.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭文件。
- en: To verify whether the process was successful, go back to the machine where Ansible
    is installed (going forward, we'll call this ansible-master) and `ssh` to the
    node. It will ask for the passphrase if you used one while generating the key.
    Another method to automate the entire process of copying keys is to use the `ssh-copy-id`
    command.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证过程是否成功，请返回到安装了Ansible的机器（从现在开始，我们将称其为ansible-master）并`ssh`到节点。如果在生成密钥时使用了密码，它将要求输入密码。自动复制密钥的另一种方法是使用`ssh-copy-id`命令。
- en: Bare-Minimum Configuration
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最低限度的配置
- en: 'To configure Ansible, you''ll need an `ansible.cfg` file. There are different
    locations where this configuration file can be stored, and Ansible searches in
    the following order:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Ansible，您将需要一个`ansible.cfg`文件。有不同的位置可以存储这个配置文件，Ansible按以下顺序搜索：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Ansible will process the preceding list and uses the first file found; all others
    are ignored.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible将处理前面的列表，并使用找到的第一个文件；其他所有文件都将被忽略。
- en: 'Create the `ansible` directory in `/etc` if not available and add a file called
    `ansible.cfg`. This is where we are going to save our configuration:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在，请在`/etc`中创建`ansible`目录，并添加一个名为`ansible.cfg`的文件。这是我们将保存配置的地方：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s try the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试以下：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This command, called an ad hoc command, executes `systemctl status sshd` to
    all hosts defined in `/etc/ansiblehosts`. If you have multiple usernames for each
    host, you can also specify the username for these nodes in the format as shown
    in the following ansible hosts file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令，称为临时命令，对`/etc/ansiblehosts`中定义的所有主机执行`systemctl status sshd`。如果每个主机有多个用户名，你也可以在以下ansible主机文件中指定这些节点的用户名：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So you can add the user to the inventory file line items as shown in the following
    screenshot, if needed, and the file will look like this for three nodes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果需要，你可以像以下截图中所示将用户添加到清单文件行项目，并且对于三个节点，文件将如下所示：
- en: '![Code to add users to the inventory file line items](img/B15455_08_01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![代码将用户添加到清单文件行项目](img/B15455_08_01.jpg)'
- en: 'Figure 8.1: Adding the user to the inventory file line items'
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.1：将用户添加到清单文件行项目
- en: Try again. Instead of your local username, the remote user is used. You're now
    able to log in and execute the command.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 再试一次。使用远程用户而不是本地用户名。现在你可以登录并执行命令了。
- en: Inventory File
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清单文件
- en: The Ansible inventory file defines the hosts and groups of hosts. Based on this,
    you can call out the host or group (group of hosts) and run a specific playbook
    or execute a command.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible清单文件定义了主机和主机组。基于此，你可以调用主机或组（一组主机）并运行特定的playbook或执行命令。
- en: Here, we are going to call our group `nodepool` and add IPs of our nodes. Since
    all our VMs are in the same Azure VNet, we are using the private IP. If they are
    in different networks, you can add the public IP. Here, we are using three VMs
    to aid explanation. If you have only one node, just input that one.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将调用我们的组`nodepool`并添加我们节点的IP。由于我们所有的VM都在同一个Azure VNet中，我们使用私有IP。如果它们在不同的网络中，你可以添加公共IP。在这里，我们使用三个VM来帮助解释。如果你只有一个节点，只需输入那一个。
- en: 'Also, you can use the DNS name of the VMs, but they should be added to your
    `/etc/hosts` file for resolution:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用VM的DNS名称，但它们应该添加到你的`/etc/hosts`文件中以进行解析：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Another parameter that will be useful is `ansible_ssh_user`. You can use this
    to specify the username used to sign in to the node. This scenario comes into
    the picture if you are using multiple usernames across your VMs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的参数是`ansible_ssh_user`。你可以使用它来指定用于登录节点的用户名。如果你在VMs上使用多个用户名，这种情况就会出现。
- en: 'Instead of using `all` in our example, you can use a group name that is `ansible-nodes`.
    It''s also possible to use generic variables that are valid for every host and
    override them per server; for instance:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，不要使用`all`，你可以使用一个名为`ansible-nodes`的组名。还可以使用通用变量，这些变量对每个主机都有效，并且可以针对每个服务器进行覆盖；例如：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Sometimes, you''ll need privileges to execute a command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要特权来执行命令：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This gives the following error message:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这会得到以下错误消息：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For ad hoc commands, just add the `-b` option as an Ansible parameter to enable
    privilege escalation. It will use the `sudo` method by default. In Azure images,
    you don't need to give your root password if you are using `sudo`. This is why
    the `-b` option works without a problem. If you configured `sudo` to prompt for
    a password, use `-K`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于临时命令，只需将`-b`选项作为Ansible参数添加，以启用特权升级。它将默认使用`sudo`方法。在Azure镜像中，如果你使用`sudo`，就不需要提供root密码。这就是为什么`-b`选项可以无问题地工作。如果你配置了`sudo`来提示输入密码，使用`-K`。
- en: 'We would suggest running other commands, such as `netstat` and `ping`, to understand
    how the commands are executed in these machines. Running `netstat` and grepping
    for `sshd` will give a similar output to this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议运行其他命令，比如`netstat`和`ping`，以了解这些命令在这些机器上是如何执行的。运行`netstat`并使用`sshd`进行grep将会得到类似于这样的输出：
- en: '![Output of netstat and grep ssh command](img/B15455_08_02.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![netstat和grep ssh命令的输出](img/B15455_08_02.jpg)'
- en: 'Figure 8.2: Running netstat and grepping for sshd'
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.2：运行netstat并使用sshd进行grep
- en: Note
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: You might get deprecation warnings when running the `ansible all` command. To
    suppress this, use `deprecation_warnings=False` in `ansible.cfg`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行`ansible all`命令时，你可能会收到弃用警告。为了抑制这个警告，在`ansible.cfg`中使用`deprecation_warnings=False`。
- en: Ansible Playbooks and Modules
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ansible Playbooks和Modules
- en: Using ad hoc commands is an imperative method and is not any better than just
    using the SSH client to execute commands remotely.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用临时命令是一种命令方法，不比只使用SSH客户端远程执行命令更好。
- en: 'There are two components that you need to make it into real, imperative orchestration:
    a playbook and a module. The playbook is the basis for the deployment, configuration,
    and maintenance of your system. It can orchestrate everything, even between hosts!
    A playbook is there to describe the state you want to reach. Playbooks are written
    in YAML and can be executed with the `ansible-playbook` command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个组件，你需要将其变成真正的命令编排：一个playbook和一个模块。Playbook是部署、配置和维护系统的基础。它可以编排一切，甚至在主机之间！Playbook用于描述你想要达到的状态。Playbook是用YAML编写的，可以用`ansible-playbook`命令执行：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The second component is the module. The best way to describe a module is as
    follows: the task to be executed to reach the desired state. They are also known
    as task plugins or library plugins.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个组件是模块。描述模块的最佳方式是：执行任务以达到期望的状态。它们也被称为任务插件或库插件。
- en: All the available modules are documented; you can find the documentation online
    and on your system.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可用的模块都有文档；你可以在网上和你的系统上找到文档。
- en: 'To list all the available plugin documentation, execute the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出所有可用的插件文档，请执行以下命令：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will take a while. We suggest that you redirect the result to a file. This
    way, it takes less time and it's easier to search for a module.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这会花一些时间。我们建议你将结果重定向到一个文件。这样，它会花费更少的时间，而且更容易搜索模块。
- en: As an example, let's try to create a playbook that will create a user using
    the **user** module if the user doesn't already exist. In other words, the desired
    state is that a specific user exists.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们尝试创建一个playbook，如果用户尚不存在，则使用**user**模块创建用户。换句话说，期望的状态是存在特定用户。
- en: 'Start by reading the documentation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先阅读文档：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a file in the Ansible directory, for instance, `playbook1.yaml`, with
    the following content. Verify the parameters in the user documentation:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible目录中创建一个文件，例如`playbook1.yaml`，内容如下。验证用户文档中的参数：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'From the output, you can see that all hosts returned `OK` and the user was
    created:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，您可以看到所有主机返回了`OK`，并且用户已创建：
- en: '![Parametres of the created ansible file](img/B15455_08_03.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![创建的ansible文件的参数](img/B15455_08_03.jpg)'
- en: 'Figure 8.3: Running the Ansible playbook'
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.3：运行Ansible playbook
- en: 'Just to make sure that the user is created, we will check the `/etc/passwd`
    file in all the hosts. From the output, we can see that the user has been created:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保用户已创建，我们将检查所有主机上的`/etc/passwd`文件。从输出中，我们可以看到用户已经被创建：
- en: '![Checking the password file of the hosts to verify user creation](img/B15455_08_04.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![检查主机的密码文件以验证用户创建](img/B15455_08_04.jpg)'
- en: 'Figure 8.4: Verifying user creation using /etc/passwd'
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.4：使用/etc/passwd验证用户创建
- en: Make sure that the indentation is correct because YAML is a very strict language
    when it comes to indentation and white space. Using an editor such as vi, Emacs,
    or Visual Studio Code with YAML support really helps.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 确保缩进正确，因为YAML在缩进和空格方面非常严格。使用支持YAML的编辑器，如vi、Emacs或Visual Studio Code，确实有很大帮助。
- en: If you are required to run a command privilege escalation, `become` and `become_method`
    or `–b` can be used.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要运行命令特权提升，可以使用`become`和`become_method`或`-b`。
- en: 'To check the Ansible syntax, use the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查Ansible语法，请使用以下命令：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's go ahead and see how we can authenticate to Azure and start the deployment
    in Azure.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看如何在Azure进行身份验证并开始部署。
- en: Authenticating to Microsoft Azure
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 身份验证到Microsoft Azure
- en: To integrate Ansible with Microsoft Azure, you need to create a configuration
    file to provide the credentials for Azure to Ansible.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Ansible与Microsoft Azure集成，您需要创建一个配置文件，为Ansible提供Azure的凭据。
- en: 'The credentials must be stored in your home directory in the `~/.azure/credentials`
    file. First, we have to collect the necessary information with the Azure CLI.
    Authenticate to Azure as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 凭据必须存储在您的主目录中的`~/.azure/credentials`文件中。首先，我们必须使用Azure CLI收集必要的信息。如下身份验证到Azure：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you''re successfully logged in, you will get an output similar to the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您成功登录，您将获得类似以下的输出：
- en: '![User credentials indicating successful Azure login](img/B15455_08_05.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![用户凭据指示成功的Azure登录](img/B15455_08_05.jpg)'
- en: 'Figure 8.5: Logging in to Azure with the az login command'
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.5：使用az登录命令登录到Azure
- en: 'This is already a part of the information you''ll need. If you were already
    logged in, execute the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是您需要的信息的一部分。如果您已经登录，请执行以下命令：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a Service Principal:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务主体：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The app ID is your `client_id`, and the password is your `secret`, which will
    be referenced in the credentials file we are going to create.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 应用ID是您的`client_id`，密码是您的`secret`，将在我们即将创建的凭据文件中引用。
- en: 'Create the `~/.azure/credentials` file with the following content:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`~/.azure/credentials`文件，内容如下：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Use `ansible-doc -l | grep azure` to find out which Ansible modules are available
    for Azure. Redirect the content to a file for reference.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ansible-doc -l | grep azure`查找可用于Azure的Ansible模块。将内容重定向到文件以供参考。
- en: Resource Group
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源组
- en: 'Let''s check everything works as expected. Create a new playbook named `resourcegroup.yaml`
    with the following content:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一切是否如预期那样工作。创建一个名为`resourcegroup.yaml`的新playbook，内容如下：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Please note that the hosts directive is localhost! Execute the playbook and
    verify whether the resource group is created:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，主机指令是localhost！执行playbook并验证资源组是否已创建：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output should be very similar to the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该与以下非常相似：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Virtual Machine
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟机
- en: 'Let''s create a VM in Azure using Ansible. To do this, create a `virtualmachine.yaml`
    file with the following content. Examine the `name` field of each block to understand
    what the code does:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Ansible在Azure中创建一个虚拟机。为此，请创建一个`virtualmachine.yaml`文件，内容如下。检查每个块的`name`字段，以了解代码的作用：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Considering the length of the code, we have just shown a few lines here. You
    can download the entire `virtualmachine.yaml` file from the `chapter 8` folder
    in the GitHub repository of this book.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到代码的长度，我们只在这里展示了一小部分。您可以从本书的GitHub存储库中的`chapter 8`文件夹中下载整个`virtualmachine.yaml`文件。
- en: 'In the following screenshot, you can see that all the resources required for
    the VM are created by Ansible:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，您可以看到Ansible创建了VM所需的所有资源：
- en: '![Creating all the required resources for the VM with Ansible](img/B15455_08_06.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![使用Ansible创建VM所需的所有资源](img/B15455_08_06.jpg)'
- en: 'Figure 8.6: Creating all the required resources for the VM with Ansible'
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.6：使用Ansible创建VM所需的所有资源
- en: You can find a full example for Azure VM deployment using Ansible in Ansible's
    Microsoft Azure Guide ([https://docs.ansible.com/ansible/latest/scenario_guides/guide_azure.html](https://docs.ansible.com/ansible/latest/scenario_guides/guide_azure.html)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Ansible的Microsoft Azure指南中找到使用Ansible部署Azure VM的完整示例（[https://docs.ansible.com/ansible/latest/scenario_guides/guide_azure.html](https://docs.ansible.com/ansible/latest/scenario_guides/guide_azure.html)）。
- en: Azure Inventory Management in Ansible
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ansible中的Azure清单管理
- en: 'We have learned two ways to use Ansible in Azure:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了两种在Azure中使用Ansible的方法：
- en: Using Ansible in an inventory file to connect to Linux machines. In fact, it
    doesn't matter whether it's running in Azure or somewhere else.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在清单文件中使用Ansible连接到Linux机器。实际上，无论是在Azure中还是在其他地方运行都无关紧要。
- en: Using Ansible to manage Azure resources.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible管理Azure资源。
- en: In this section, we're going one step further. Instead of using a static inventory,
    we will ask Azure what is running in your environment using dynamic inventory
    scripts.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将进一步进行。我们将使用动态清单脚本询问Azure在您的环境中运行了什么，而不是使用静态清单。
- en: 'The first step is to download the dynamic inventory script for Azure. Execute
    with `sudo` if you are not a root user:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是下载Azure的动态清单脚本。如果您不是root用户，请使用`sudo`执行：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Edit the `/etc/ansible/ansible.cfg` file and remove the `inventory=/etc/ansible/hosts`
    line.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`/etc/ansible/ansible.cfg`文件并删除`inventory=/etc/ansible/hosts`行。
- en: 'Let''s carry out the first step:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行第一步：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It will probably fail on account of authentication problems:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能会因为身份验证问题而失败：
- en: '![Host connection failure due to authentication issues](img/B15455_08_07.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![由于身份验证问题导致主机连接失败](img/B15455_08_07.jpg)'
- en: 'Figure 8.7: Host connection failure due to authentication issues'
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.7：由于身份验证问题导致主机连接失败
- en: 'If you have a different login for different VMs, you can always use the user
    directive per task. Here, we are using `azure` which means all VMs. You can always
    query for a machine using the VM name. For example, you can ping the `ansible-node3`
    VM using a user credential:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对不同的VM有不同的登录，您可以始终在每个任务中使用用户指令。在这里，我们使用`azure`，这意味着所有VM。您始终可以使用VM名称查询机器。例如，您可以使用用户凭据ping`ansible-node3`
    VM：
- en: '![Using the user credentials to ping the ansible-node3 VM](img/B15455_08_08.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![使用用户凭据ping ansible-node3 VM](img/B15455_08_08.jpg)'
- en: 'Figure 8.8: Querying for the ansible-node3 VM'
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.8：查询ansible-node3 VM
- en: 'Ideally, Ansible expects you to use SSH keys instead of passwords. If you would
    like to use a password, you can use `–extra-vars` and pass the password. Please
    note that for this you need to install an application called `sshpass`. To ping
    a VM in Azure that uses a password via Ansible, execute the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，Ansible希望您使用SSH密钥而不是密码。如果您想使用密码，可以使用`–extra-vars`并传递密码。请注意，为此您需要安装一个名为`sshpass`的应用程序。要通过Ansible
    ping使用密码的Azure VM，请执行以下命令：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s take the instance of the VM we created using Ansible in the previous
    example, where the username was `student` and the password was `welk0mITG!`. From
    the screenshot, you can see that the ping succeeds. You might see some warnings,
    but they can be safely ignored. However, further investigation is needed if the
    ping fails:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以前一个示例中使用Ansible创建的VM实例为例，其中用户名是`student`，密码是`welk0mITG!`。从屏幕截图中，您可以看到ping成功。您可能会看到一些警告，但可以安全地忽略它们。但是，如果ping失败，则需要进一步调查：
- en: '![Screenshot indicating that ping to the user succeeds](img/B15455_08_09.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![屏幕截图表明对用户的ping成功](img/B15455_08_09.jpg)'
- en: 'Figure 8.9: Sending a ping for the username student'
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.9：发送ping给用户名student
- en: 'By creating an `azure_rm.ini` file in the same directory as the `azure_rm.py`
    directory, you can modify the behavior of the inventory script. Here is an example
    `ini` file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在与`azure_rm.py`目录相同的目录中创建一个`azure_rm.ini`文件，您可以修改清单脚本的行为。以下是一个示例`ini`文件：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It works in a very similar way to the `hosts` file. The `[azure]` section means
    all VMs. You can also provide sections for the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式与`hosts`文件非常相似。`[azure]`部分表示所有VM。您还可以为以下内容提供部分：
- en: Location name
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置名称
- en: Resource group name
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源组名称
- en: Security group name
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全组名称
- en: Tag key
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记键
- en: Tag key value
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记键值
- en: 'Another method for selecting one or more VMs is to use tags. To be able to
    tag a VM, you''ll need the ID:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个或多个VM的另一种方法是使用标记。要能够给VM打标记，您需要ID：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, you can tag the VM:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以给VM打标记：
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also tag the VM in the Azure portal:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在Azure门户中给VM打标记：
- en: '![Tagging the VM in the Azure portal](img/B15455_08_10.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![在Azure门户中给VM打标记](img/B15455_08_10.jpg)'
- en: 'Figure 8.10: Tagging the VM in the Azure portal'
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.10：在Azure门户中给VM打标记
- en: 'Click on **change** and add a tag, with or without a value (you can use the
    value to filter the value too). To verify, use the tag name host:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**更改**并添加一个标记，带有或不带有值（您也可以使用该值来过滤该值）。要验证，请使用标记名称主机：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Only the tagged VM is pinged. Let''s create a playbook for this tagged VM,
    for instance, `/etc/ansible/example9.yaml`. The tag is, again, used in the `hosts`
    directive:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 只有标记的VM被ping。让我们为这个标记的VM创建一个playbook，例如`/etc/ansible/example9.yaml`。标记再次在`hosts`指令中使用：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Execute the playbook:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 执行playbook：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Once the playbook has been run, if you check the VM, you can see that Apache
    is installed.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦playbook运行完毕，如果您检查VM，您会看到Apache已安装。
- en: As mentioned earlier, Ansible is not the only tool. There is another popular
    one called Terraform. In the next section, will be discussing Terraform on Azure.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Ansible并不是唯一的工具。还有另一个流行的工具叫做Terraform。在下一节中，我们将讨论Azure上的Terraform。
- en: Using Terraform
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Terraform
- en: Terraform is another **Infrastructure as Code** (**IaC**) tool that is developed
    by HashiCorp. You might wonder why it is called an IaC tool. The reason is you
    can define how your infrastructure needs to be using code, and Terraform will
    help you deploy it. Terraform uses **HashiCorp Configuration Language** (**HCL**);
    however, you can also use JSON. Terraform is supported in macOS, Linux, and Windows.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform是由HashiCorp开发的另一个**基础设施即代码**（**IaC**）工具。您可能想知道为什么它被称为IaC工具。原因是您可以使用代码定义基础设施的需求，而Terraform将帮助您部署它。Terraform使用**HashiCorp配置语言**（**HCL**）；但是，您也可以使用JSON。Terraform在macOS、Linux和Windows中都受支持。
- en: Terraform supports a wide range of Azure resources such as networks, subnets,
    storage, tags, and VMs. If you recall, we discussed the imperative and declarative
    ways of writing code. Terraform is declarative in nature, and it can maintain
    the state of the infrastructure. Once deployed, Terraform remembers the current
    state of the infrastructure.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform支持各种Azure资源，如网络、子网、存储、标记和VM。如果您回忆一下，我们讨论了编写代码的命令式和声明式方式。Terraform是声明式的，它可以维护基础设施的状态。一旦部署，Terraform会记住基础设施的当前状态。
- en: As in every section, the first part of the process involves the installation
    of Terraform. Let's proceed with the Linux installation of Terraform.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个部分一样，过程的第一部分涉及安装Terraform。让我们继续进行Terraform的Linux安装。
- en: Installation
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装
- en: Terraform's core executable can be downloaded from [https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)
    and can be copied to one of the directories added to your `$PATH` variable. You
    can also use the `wget` command to download the core executable. To do this, first
    you have to find out the latest version of Terraform from the aforementioned link.
    At the time of writing, the latest version available is 0.12.16
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform的核心可执行文件可以从[https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)下载，并且可以复制到添加到您的`$PATH`变量的目录之一。您还可以使用`wget`命令来下载核心可执行文件。要做到这一点，首先您必须从上述链接中找出Terraform的最新版本。在撰写本文时，最新版本为0.12.16
- en: 'Now that we have the version, we will download the executable using `wget`
    with the following command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了版本，我们将使用以下命令使用`wget`下载可执行文件：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The ZIP will be downloaded to the current working directory. Now we will use
    the unzip tool to get the executable extracted:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ZIP文件将被下载到当前工作目录。现在我们将使用解压工具来提取可执行文件：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`unzip` might not be installed by default. If it''s throwing an error, install
    `unzip` using `apt` or `yum` depending on the distribution you are using.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`unzip`可能不是默认安装的。如果它抛出错误，请使用`apt`或`yum`根据您使用的发行版进行安装`unzip`。'
- en: The extraction process will get you the Terraform executable, and you can copy
    this to any location in your `$PATH`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 提取过程将为您获取Terraform可执行文件，您可以将其复制到`$PATH`中的任何位置。
- en: 'To verify whether the installation was successful, you can execute:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证安装是否成功，您可以执行：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now that we have confirmed that Terraform been installed, let's go ahead and
    set up the authentication to Azure.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确认了Terraform已经安装，让我们继续设置Azure的身份验证。
- en: Authenticating to Azure
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到Azure
- en: There are multiple ways by which you can authenticate to Azure. You can use
    Azure CLI, Service Principal using a Client Certificate, Service Principal and
    Client Secret, and many more methods. For testing purposes, Azure CLI using the
    `az` login command is the right choice. However, if we want to automate deployment,
    this is not an ideal method. We should go for Service Principal and Client Secret,
    the same as we did in Ansible.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以用来对Azure进行身份验证。您可以使用Azure CLI、使用客户端证书的服务主体、服务主体和客户端密钥，以及许多其他方法。对于测试目的，使用`az`登录命令的Azure
    CLI是正确的选择。然而，如果我们想要自动化部署，这并不是一个理想的方法。我们应该选择服务主体和客户端密钥，就像我们在Ansible中所做的那样。
- en: 'Let''s start by creating a Service Principal for Terraform. If you already
    have a Service Principal created for the previous section, feel free to use that.
    To create a new Service Principal from Azure CLI, use this command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为Terraform创建一个服务主体开始。如果您已经为上一节创建了服务主体，请随意使用。要从Azure CLI创建一个新的服务主体，请使用以下命令：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At this point, you might be already familiar with the output, which contains
    the `appID`, password, and tenant ID.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能已经熟悉了输出，其中包含`appID`、密码和租户ID。
- en: 'Note down the values in the output, and we will be creating variables to store
    this value:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 记下输出中的值，我们将创建变量来存储这个值：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So, we have stored all the values to variables that will be used by Terraform
    for authentication. Since we have dealt with authentication, let's write code
    in HCL with which we can deploy resources in Azure.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经将所有的值存储到变量中，这些值将被Terraform用于身份验证。由于我们已经处理了身份验证，让我们用HCL编写代码，以便在Azure中部署资源。
- en: Deployment to Azure
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署到Azure
- en: You can use any code editor for this purpose. Since we are already on a Linux
    machine, you can use vi or nano. If you want, you can also use Visual Studio Code,
    which has extensions for Terraform and Azure, which will get you IntelliSense
    and syntax highlighting.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何代码编辑器来完成这个任务。由于我们已经在Linux机器上，您可以使用vi或nano。如果您愿意，您也可以使用Visual Studio Code，它具有Terraform和Azure的扩展，可以为您提供智能感知和语法高亮显示。
- en: Let's create a terraform directory to store all our code, and inside the `terraform`
    directory, we will create further directories based on what we are going to deploy.
    In our first example, we will be using Terraform to create a resource group in
    Azure. Later, we will discuss how to deploy a VM in this resource group.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个terraform目录来存储我们所有的代码，在`terraform`目录中，我们将根据我们要部署的内容创建进一步的目录。在我们的第一个示例中，我们将使用Terraform在Azure中创建一个资源组。稍后，我们将讨论如何在这个资源组中部署一个VM。
- en: 'So, to create a `terraform` directory and to create a `resource-group` subfolder
    within this directory, execute the following command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要创建一个`terraform`目录，并在此目录中创建一个`resource-group`子文件夹，请执行以下命令：
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, create a main.tf file with the below content:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个包含以下内容的main.tf文件：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The code is very simple. Let's take a closer look at each of the items.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单。让我们仔细看看每个项目。
- en: The provider directive shows that we would like to use the version 1.33 of the
    `azurerm` provider. In other words, we are indicating that we are going to use
    version 1.33 of the Terraform Azure Resource Manager provider, which is one of
    the plugins available for Terraform.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者指令显示我们想要使用`azurerm`提供者的1.33版本。换句话说，我们指示我们将使用Terraform Azure资源管理器提供者的1.33版本，这是Terraform可用的插件之一。
- en: The `resource` directive says that we are going to deploy an Azure resource
    of the `azurerm_resource_group` type with two parameters, `name` and `location`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`resource`指令表示我们将部署一个`azurerm_resource_group`类型的Azure资源，具有`name`和`location`两个参数。'
- en: '`rg` stands for the resource configuration. Resource names must be unique per
    type in each module. For example, if you want to create another resource group
    in the same template, you cannot use `rg` again as you have already used it; instead,
    you can go for anything other than `rg`, such as `rg2`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`rg`代表资源配置。每个模块中的资源名称必须是唯一的。例如，如果您想在同一个模板中创建另一个资源组，您不能再次使用`rg`，因为您已经使用过了；而是，您可以选择除`rg`之外的任何其他名称，比如`rg2`。'
- en: 'Before we start the deployment using the template, we first need to initialize
    the project directory, which is our `resource-group` folder. To initialize Terraform,
    execute the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用模板开始部署之前，我们首先需要初始化项目目录，即我们的`resource-group`文件夹。要初始化Terraform，请执行以下操作：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'During initialization, Terraform will download the `azurerm` provider from
    its repository and will show a similar output as the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化期间，Terraform将从其存储库下载`azurerm`提供程序，并显示类似以下的输出：
- en: '![Terraform downloading the azurerm provider from its repository](img/B15455_08_11.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![Terraform从其存储库下载azurerm提供程序](img/B15455_08_11.jpg)'
- en: 'Figure 8.11: Initializing Terraform to download the azurerm provider'
  id: totrans-236
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.11：初始化Terraform以下载azurerm提供程序
- en: 'Since we''ve already exported the Service Principal details to the variables,
    we can deploy using this command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将服务主体详细信息导出到变量中，因此可以使用此命令进行部署：
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This command will connect Terraform to your Azure subscription and check whether
    the resource exists. If Terraform figures out that the resource doesn''t exist,
    it will go ahead and create an execution plan to deploy. You will get the output
    shown in the following screenshot. To proceed with the deployment, type `yes`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将连接Terraform到您的Azure订阅，并检查资源是否存在。如果Terraform发现资源不存在，它将继续创建一个执行计划以部署。您将获得以下截图中显示的输出。要继续部署，请键入`yes`：
- en: '![Using terraform apply to connect terraform to the Azure subscription](img/B15455_08_12.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![使用terraform apply连接terraform到Azure订阅](img/B15455_08_12.jpg)'
- en: 'Figure 8.12: Connecting Terraform to the Azure subscription'
  id: totrans-241
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.12：连接Terraform到Azure订阅
- en: 'Once you have given the input, Terraform will start the resource creation.
    After creation, Terraform will show you a summary of everything that was created
    and how many resources were added and destroyed, as shown here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您提供了输入，Terraform将开始创建资源。创建后，Terraform将向您显示创建的所有内容的摘要以及添加和销毁的资源数量，如下所示：
- en: '![A summary of the resources created using the terraform apply command](img/B15455_08_13.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![使用terraform apply命令创建的资源摘要](img/B15455_08_13.jpg)'
- en: 'Figure 8.13: Summary of the created resources'
  id: totrans-244
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.13：创建的资源摘要
- en: A state file named `terraform.tfstate` will be generated in the project directory
    from where we initialized Terraform. This file will have the state information
    and also the list of resources we deployed to Azure.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们初始化Terraform的项目目录中将生成一个名为`terraform.tfstate`的状态文件。该文件将包含状态信息，还将包含我们部署到Azure的资源列表。
- en: We have successfully created the resource group; in the next section, we will
    discuss how to create a Linux VM using Terraform.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功创建了资源组；在下一节中，我们将讨论如何使用Terraform创建Linux VM。
- en: Deploying a Virtual Machine
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署虚拟机
- en: In the previous example, where we created the resource group, we used `azurerm_resource_group`
    as the resource to be created. For each resource there will be a directive, for
    example, for a VM, it'll be `azurerm_virtual_machine`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了资源组，我们使用`azurerm_resource_group`作为要创建的资源。对于每个资源，都会有一个指令，例如对于VM，它将是`azurerm_virtual_machine`。
- en: Also, we created the resource group using the `terraform apply` command. But
    Terraform also offers a way to work with an execution plan. So instead of deploying
    straight away, we can create a plan and see what changes will be made and then
    deploy.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们使用`terraform apply`命令创建了资源组。但是Terraform还提供了一种使用执行计划的方法。因此，我们可以先创建一个计划，看看将会做出什么更改，然后再部署。
- en: 'To start with, you can go back to the `terraform` directory and create a new
    directory called `vm`. It''s always a good idea to have separate directories for
    different projects:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以返回到`terraform`目录并创建一个名为`vm`的新目录。为不同的项目单独创建目录总是一个好主意：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once you are in the directory, you can create a new `main.tf` file with the
    content shown in the following code block. Use the comments added to see the purpose
    of each block. Considering the length of the code, we are showing the truncated
    version of the code block. You can find the `main.tf` code file in the `chapter
    8` folder of the GitHub repository of this book:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您进入目录，您可以创建一个名为`main.tf`的新文件，其中包含以下代码块中显示的内容。使用添加的注释查看每个块的目的。考虑到代码的长度，我们显示了代码块的截断版本。您可以在本书的GitHub存储库的`第8章`文件夹中找到`main.tf`代码文件：
- en: '[PRE45]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you look at the section for `azurerm_virtual_network`, you can see that instead
    of writing down the resource name, we gave a reference in the format `type.resource_configuration.parameter`.
    In this case, instead of writing down the resource group name, the reference was
    given as `azurerm_resource_group.rg.name`. Likewise, throughout the code, we have
    taken references to make the deployment easy.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看`azurerm_virtual_network`部分，您会发现，我们没有写下资源名称，而是以`type.resource_configuration.parameter`的格式给出了一个引用。在这种情况下，我们没有写下资源组名称，而是给出了`azurerm_resource_group.rg.name`的引用。同样，在整个代码中，我们都采用了引用以使部署变得更加容易。
- en: 'Before starting the deployment planning, we have to initialize the project
    using the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始部署规划之前，我们必须使用以下内容初始化项目：
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As mentioned earlier, we will go with the execution plan. To create an execution
    plan and save it to a `vm-plan.plan` file, execute:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用执行计划。要创建执行计划并将其保存到`vm-plan.plan`文件中，请执行：
- en: '[PRE47]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You will get a lot of warnings; they can be safely ignored. Make sure that
    the code doesn''t show any errors. If the execution plan is successfully created,
    it will show the next step to be taken to execute the plan, as shown here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到很多警告；它们可以安全地忽略。确保代码没有显示任何错误。如果成功创建了执行计划，它将显示执行计划的下一步操作，如下所示：
- en: '![Successful creation of the execution plan](img/B15455_08_14.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![成功创建执行计划](img/B15455_08_14.jpg)'
- en: 'Figure 8.14: Displaying the execution plan'
  id: totrans-261
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.14：显示执行计划
- en: 'As suggested in the output, we will execute:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所建议的，我们将执行：
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, the deployment will start and will show what resource it''s deploying,
    how much time has elapsed, and so on, as shown in the output:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，部署将开始，并显示正在部署的资源，已经经过了多少时间等等，如输出所示：
- en: '![Details of the resources in deployment](img/B15455_08_15.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![部署资源的详细信息](img/B15455_08_15.jpg)'
- en: 'Figure 8.15: Resource deployment details'
  id: totrans-266
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.15：资源部署详细信息
- en: 'At the end, Terraform will give a summary of the number of resources deployed:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Terraform将提供部署的资源数量的摘要：
- en: '![Summary of the deployed resources](img/B15455_08_16.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![部署资源的摘要](img/B15455_08_16.jpg)'
- en: 'Figure 8.16: Summary of the number of resources deployed'
  id: totrans-269
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.16：部署的资源数量摘要
- en: 'There is also another command, which is the `show` command. This will show
    the complete state of the deployment, as can be seen in the following screenshot:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个命令，就是`show`命令。这将显示部署的完整状态，如下截图所示：
- en: '![Checking the complete state of the deployment](img/B15455_08_17.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![检查部署的完整状态](img/B15455_08_17.jpg)'
- en: 'Figure 8.17: Displaying the complete state of the deployment'
  id: totrans-272
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.17：显示部署的完整状态
- en: We have written a small piece of code that can deploy a VM in Azure. However,
    there are lots of arguments that can be added to the code by which advanced state
    configuration can be made. The complete list of arguments is available in the
    Terraform documentation ([https://www.terraform.io/docs/providers/azurerm/r/virtual_machine.html](https://www.terraform.io/docs/providers/azurerm/r/virtual_machine.html))
    and the Microsoft documentation ([https://docs.microsoft.com/en-us/azure/virtual-machines/linux/terraform-create-complete-vm](https://docs.microsoft.com/en-us/azure/virtual-machines/linux/terraform-create-complete-vm)).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一小段代码，可以在Azure中部署一个VM。但是，可以通过向代码添加许多参数来进行高级状态配置。所有参数的完整列表都可以在Terraform文档（[https://www.terraform.io/docs/providers/azurerm/r/virtual_machine.html](https://www.terraform.io/docs/providers/azurerm/r/virtual_machine.html)）和微软文档（[https://docs.microsoft.com/en-us/azure/virtual-machines/linux/terraform-create-complete-vm](https://docs.microsoft.com/en-us/azure/virtual-machines/linux/terraform-create-complete-vm)）中找到。
- en: As these templates are a bit advanced, they will be using variables instead
    of values that are repeating. Nevertheless, once you get used to this, you'll
    understand how powerful Terraform is.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些模板有点高级，它们将使用变量而不是重复的值。然而，一旦您习惯了这一点，您就会了解Terraform有多强大。
- en: 'Finally, you can destroy the entire deployment or project by executing:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过执行以下命令销毁整个部署或项目：
- en: '[PRE49]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will delete all the resources we mentioned in the `main.tf` file of the
    project. If you have multiple projects, you have to navigate to the project directory
    and execute the `destroy` command. On executing this command, you will be asked
    you to confirm the deletion; once you say `yes`, the resources will be deleted:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除项目的`main.tf`文件中提到的所有资源。如果您有多个项目，您必须导航到项目目录并执行`destroy`命令。执行此命令时，系统将要求您确认删除；一旦您说“是”，资源将被删除：
- en: '![Destroying the entire deployment with terraform destroy command](img/B15455_08_18.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![使用terraform destroy命令销毁整个部署](img/B15455_08_18.jpg)'
- en: 'Figure 8.18: Deleting all the resources with the terraform destroy command'
  id: totrans-279
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.18：使用terraform destroy命令删除所有资源
- en: 'And finally, you will get a summary, as shown here:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将得到一个摘要，如下所示：
- en: '![Summary of the destroyed resources](img/B15455_08_19.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![被销毁资源的摘要](img/B15455_08_19.jpg)'
- en: 'Figure 8.19: Summary of the destroyed resources'
  id: totrans-282
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.19：被销毁资源的摘要
- en: Now we are familiar with using Terraform on Azure and deploying a simple VM.
    Nowadays, Terraform is gaining a lot of popularity due to the usability and adoption
    of DevOps. Terraform has made the process of evaluating infrastructure and rebuilding
    it hassle-free.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了在Azure上使用Terraform和部署简单的VM。如今，由于DevOps的可用性和采用率，Terraform正变得越来越受欢迎。 Terraform使评估基础架构并重新构建它变得轻松无忧。
- en: Using PowerShell DSC
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PowerShell DSC
- en: Like Bash, PowerShell is a shell with strong scripting possibilities. We might
    think that PowerShell is more of a scripting language and that can be used to
    carry out simple operations or to create resources as we have done so far. However,
    the capabilities of PowerShell are beyond that and extend all the way to automation
    and configuration.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 与Bash一样，PowerShell是一个具有强大脚本功能的shell。我们可能会认为PowerShell更像是一种脚本语言，可以用来执行简单的操作或创建资源，就像我们迄今为止所做的那样。但是，PowerShell的功能远不止于此，还延伸到自动化和配置。
- en: DSC is an important but little-known part of PowerShell that, instead of automating
    scripts in the PowerShell language, provides declarative orchestration in PowerShell.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: DSC是PowerShell的一个重要但鲜为人知的部分，它不是用PowerShell语言自动化脚本，而是提供了PowerShell中的声明性编排。
- en: If you compare it to Ansible, support for Linux is very limited. But it is very
    useful for common administration tasks, and missing features can be compensated
    for with PowerShell scripts. Microsoft is very focused on getting it on a par
    with Windows Server. When that happens, it will be replaced by PowerShell DSC
    Core, a move very similar to what they did before with PowerShell | PowerShell
    Core. This will be finished by the end of 2019.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将其与Ansible进行比较，对Linux的支持非常有限。但它非常适用于常见的管理任务，缺少的功能可以通过PowerShell脚本来补偿。微软非常专注于使其与Windows
    Server保持一致。一旦发生这种情况，它将被PowerShell DSC Core取代，这与他们以前使用PowerShell | PowerShell Core所做的非常相似。这将在2019年底完成。
- en: Another important note is that, for some reason, the Python scripts that come
    with DSC don't work—from time to time, you'll get a 401 error or even an undefined
    error. First, make sure that you have the latest version of the OMI server and
    DSC and just try again; sometimes, you have to try two or three times.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的注意事项是，由于某种原因，随DSC提供的Python脚本偶尔无法正常工作，有时会出现401错误甚至未定义的错误。首先确保您拥有最新版本的OMI服务器和DSC，然后再试一次；有时，您可能需要尝试两到三次。
- en: Azure Automation DSC
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure Automation DSC
- en: One way to use DSC is to use Azure Automation DSC. This way, you don't have
    to use a separate machine as a controller node. To be able to use Azure Automation
    DSC, you'll need an Azure Automation account.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DSC的一种方法是使用Azure Automation DSC。这样，您就不必使用单独的机器作为控制节点。要使用Azure Automation DSC，您需要一个Azure
    Automation帐户。
- en: '**Automation account**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动化帐户**'
- en: In the Azure portal, select **All Services** in the left-hand bar, navigate
    to **Management + governance**, and choose **Automation Accounts**. Create an
    automation account and make sure that you choose **Run As Account**.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure门户中，选择左侧栏中的**所有服务**，导航到**管理+治理**，然后选择**自动化帐户**。创建一个自动化帐户，并确保选择**Run As
    Account**。
- en: 'Navigate again to **All Services**, **Management Tools**, and then select the
    **just-created account**:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 再次导航到**所有服务**，**管理工具**，然后选择**刚创建的帐户**：
- en: '![Selecting the newly created automation account](img/B15455_08_20.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![选择新创建的自动化帐户](img/B15455_08_20.jpg)'
- en: 'Figure 8.20: Creating an automation account in the Azure portal'
  id: totrans-295
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.20：在Azure门户中创建自动化帐户
- en: Here, you can manage your nodes, configurations, and so on.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以管理您的节点、配置等等。
- en: Please note that this service is not exactly free. Process automation is priced
    per job execution minute, while configuration management is priced per managed
    node.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此服务并非完全免费。流程自动化按作业执行分钟计费，而配置管理按受管节点计费。
- en: To be able to use this account, you'll need the registration URL and the corresponding
    key of your **Run As Account**. Both values are available under **Account** and
    **Key Settings**.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此帐户，您需要**Run As Account**的注册URL和相应的密钥。这两个值都可以在**帐户**和**密钥设置**下找到。
- en: 'Or, in PowerShell, execute the following command:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在PowerShell中，执行以下命令：
- en: '[PRE50]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: There is a VM extension available for Linux; this way, you can deploy VMs, including
    their configuration, fully orchestrated.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Linux有一个可用的VM扩展；这样，您可以部署VM，包括它们的配置，完全编排。
- en: For more information, visit [https://github.com/Azure/azure-linux-extensions/tree/master/DSC](https://github.com/Azure/azure-linux-extensions/tree/master/DSC)
    and [https://docs.microsoft.com/en-us/azure/virtual-machines/extensions/dsc-linux](https://docs.microsoft.com/en-us/azure/virtual-machines/extensions/dsc-linux).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请访问[https://github.com/Azure/azure-linux-extensions/tree/master/DSC](https://github.com/Azure/azure-linux-extensions/tree/master/DSC)和[https://docs.microsoft.com/en-us/azure/virtual-machines/extensions/dsc-linux](https://docs.microsoft.com/en-us/azure/virtual-machines/extensions/dsc-linux)。
- en: Because we're going to play with Linux and DSC, we'll need a DSC module called
    `nx`. This module contains DSC resources for Linux. In the settings of your automation
    account, select `nx` and import the module.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们要使用Linux和DSC，我们需要一个名为`nx`的DSC模块。该模块包含了Linux的DSC资源。在自动化帐户的设置中，选择`nx`并导入该模块。
- en: Installing PowerShell DSC on Linux
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Linux上安装PowerShell DSC
- en: 'To be able to use PowerShell DSC on Linux, you''ll need the Open Management
    Infrastructure Service. The supported versions of Linux distributions are as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Linux上使用PowerShell DSC，您需要Open Management Infrastructure Service。支持的Linux发行版版本如下：
- en: Ubuntu 12.04 LTS, 14.04 LTS, and 16.04 LTS. Ubuntu 18.04 is not supported at
    the moment.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu 12.04 LTS，14.04 LTS和16.04 LTS。目前不支持Ubuntu 18.04。
- en: RHEL/CentOS 6.5 and higher.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RHEL/CentOS 6.5及更高版本。
- en: openSUSE 13.1 and higher.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: openSUSE 13.1及更高版本。
- en: SUSE Linux Enterprise Server 11 SP3 and higher.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SUSE Linux Enterprise Server 11 SP3及更高版本。
- en: The software is available for download at [https://github.com/Microsoft/omi](https://github.com/Microsoft/omi).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 该软件可在[https://github.com/Microsoft/omi](https://github.com/Microsoft/omi)下载。
- en: 'Installation on Red Hat–based distributions is as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Red Hat的发行版上的安装如下：
- en: '[PRE51]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'For Ubuntu, you can download the `deb` file from the GitHub repository using
    `wget` and install it using `dpkg`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Ubuntu，您可以使用`wget`从GitHub存储库下载`deb`文件，并使用`dpkg`进行安装：
- en: '[PRE52]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you download the file that matches your SSL version. Your SSL version
    can be checked using the `openssl version` command.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 确保下载与您的SSL版本匹配的文件。您可以使用`openssl version`命令来检查您的SSL版本。
- en: 'After installation, the service is automatically started. Check the status
    of the service by using the following command:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，服务会自动启动。使用以下命令检查服务的状态：
- en: '[PRE53]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To show product and version information, including the configuration directories
    used, use the following command:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示产品和版本信息，包括使用的配置目录，请使用以下命令：
- en: '[PRE54]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '![Product information with list of configuration directories used](img/B15455_08_21.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![带有配置目录列表的产品信息](img/B15455_08_21.jpg)'
- en: 'Figure 8.21: Displaying the product and version information'
  id: totrans-322
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.21：显示产品和版本信息
- en: Creating a Desired State
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建期望状态
- en: PowerShell DSC is not just a script or a code with parameters, like in Ansible.
    To start with PowerShell DSC, you'll need a configuration file that must be compiled
    into a **Management Object Format** (**MOF**) file.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell DSC不仅仅是一个带有参数的脚本或代码，就像在Ansible中一样。要开始使用PowerShell DSC，您需要一个必须编译成**管理对象格式**（**MOF**）文件的配置文件。
- en: 'But, first things first. Let''s create a file, `example1.ps1`, with the following
    content:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，首先要做的是。让我们创建一个名为`example1.ps1`的文件，内容如下：
- en: '[PRE55]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Let's investigate this configuration. As stated, it's very similar to a function
    declaration. The configuration gets a label and is executed at the end of the
    script. The necessary modules are imported, the hostname of the VM is declared,
    and the configuration starts.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调查一下这个配置。正如所述，它与函数声明非常相似。配置得到一个标签，并在脚本末尾执行。必要的模块被导入，VM的主机名被声明，配置开始。
- en: PowerShell DSC Resources
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PowerShell DSC资源
- en: 'In this configuration file, a resource called `nxPackage` is used. There are
    several built-in resources:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配置文件中，使用了一个名为`nxPackage`的资源。有几个内置资源：
- en: '`nxArchive`: Provides a mechanism to unpack archive (`.tar`, `.zip`) files
    at a specific path.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nxArchive`：提供在特定路径解压归档（`.tar`，`.zip`）文件的机制。'
- en: '`nxEnvironment`: Manages environment variables.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nxEnvironment`：管理环境变量。'
- en: '`nxFile`: Manages files and directories.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nxFile`：管理文件和目录。'
- en: '`nxFileLine`: Manages lines in a Linux file.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nxFileLine`：管理Linux文件中的行。'
- en: '`nxGroup`: Manages local Linux groups.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nxGroup`：管理本地Linux组。'
- en: '`nxPackage`: Manages packages on Linux nodes.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nxPackage`：管理Linux节点上的软件包。'
- en: '`nxScript`: Runs scripts. Most of the time, this is used to switch temporarily
    to a more imperative orchestration approach.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nxScript`：运行脚本。大多数情况下，这是用来暂时切换到更命令式的编排方法。'
- en: '`nxService`: Manages Linux services (daemons).'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nxService`：管理Linux服务（守护进程）。'
- en: '`nxUser`: Manages Linux users.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nxUser`：管理Linux用户。'
- en: You can also write your own resources in the MOF language, C#, Python, or C/C++.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用MOF语言、C#、Python或C/C++编写自己的资源。
- en: You can make use of the official documentation by visiting [https://docs.microsoft.com/en-us/powershell/dsc/lnxbuiltinresources](https://docs.microsoft.com/en-us/powershell/dsc/lnxbuiltinresources).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问[https://docs.microsoft.com/en-us/powershell/dsc/lnxbuiltinresources](https://docs.microsoft.com/en-us/powershell/dsc/lnxbuiltinresources)来使用官方文档。
- en: 'Save the script and execute it as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本并执行如下：
- en: '[PRE56]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As a result of the script, a directory is created with the same name as the
    configuration name. In it, there's a localhost file in MOF format. This is the
    language used to describe CIM classes (**CIM** stands for **Common Information
    Model**). CIM is an open standard for the management of a complete environment,
    including hardware.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的结果是创建一个与配置名称相同的目录。其中，有一个以MOF格式的localhost文件。这是用于描述CIM类的语言（**CIM**代表**通用信息模型**）。CIM是用于管理完整环境（包括硬件）的开放标准。
- en: We think that this description alone is enough to understand why Microsoft chooses
    this model and the corresponding language file for orchestration!
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为这个描述足以理解为什么微软选择了这个模型和相应的编排语言文件！
- en: You can also upload the configuration file to Azure, under **DSC Configurations**.
    Press the **Compile** button to generate the MOF file in Azure.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将配置文件上传到Azure，在**DSC Configurations**下。按下**Compile**按钮在Azure中生成MOF文件。
- en: '**Applying the Resources in Azure**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**在Azure中应用资源**'
- en: If you want, you can apply the desired state locally, using scripts in `/opt/microsoft/dsc/Scripts`,
    which is, in our opinion, not as easy as it should be. And, because this chapter
    is about orchestration in Azure, we'll just move straight on to Azure.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您可以使用`/opt/microsoft/dsc/Scripts`中的脚本在本地应用所需的状态，但在我们看来，这并不像应该那样容易。而且，因为本章是关于Azure中的编排，我们将直接转向Azure。
- en: 'Register the VM:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 注册虚拟机：
- en: '[PRE57]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Check the configuration again:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查配置：
- en: '[PRE58]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The node is now visible in the **DSC Nodes** pane under your **Automation Account**
    settings. Now, you can link the uploaded and compiled DSC configuration. The configuration
    is applied!
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，节点在**Automation Account**设置下的**DSC Nodes**窗格中可见。现在，您可以链接上传和编译的DSC配置。配置已应用！
- en: Another way is to use the **Add Node** option and then select the DSC configuration.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用**Add Node**选项，然后选择DSC配置。
- en: To conclude, the primary use case scenario of PowerShell DSC is to write, manage,
    and compile DSC configurations, as well as import and assign these configurations
    to the target nodes in the cloud. Before using any tool, you need to understand
    the use case scenarios and how they fit into your environment to achieve the goal.
    So far, we have been configuring VMs; the next section is all about how to audit
    the settings inside the Linux VM using Azure Policy Guest Configuration.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，PowerShell DSC的主要用例场景是编写、管理和编译DSC配置，以及导入和分配这些配置到云中的目标节点。在使用任何工具之前，您需要了解用例场景以及它们如何适用于您的环境以实现目标。到目前为止，我们一直在配置虚拟机；接下来的部分将介绍如何使用Azure策略来审计Linux虚拟机内部的设置。
- en: Azure Policy Guest Configuration
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure策略客户端配置
- en: Policies are mainly used for the governance of resources. Azure Policy is a
    service in Azure by which you can create, manage, and assign policies in Azure.
    These policies can be used for auditing and for compliance. For example, if you
    are hosting a secured application in the East US location and you want to limit
    the deployments in East US only, Azure Policy can be used to accomplish this.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 策略主要用于资源的治理。Azure策略是Azure中的一个服务，您可以在其中创建、管理和分配策略。这些策略可用于审计和合规性。例如，如果您在东部美国位置托管一个安全的应用程序，并且希望仅限制在东部美国的部署，可以使用Azure策略来实现这一点。
- en: Let's say you don't want to deploy SQL servers in a subscription. In Azure Policy,
    you can create a policy and specify the allowed services, and only they can be
    deployed in that subscription. Please note, if you are assigning a policy to a
    subscription that already has resources, Azure Policy can only act on resources
    that are created post assignment. However, if any of the existing resources before
    assignment don't comply with the policy, they will be marked as "non-compliant"
    so an administrator can rectify them if necessary. Also, Azure Policy will only
    kick in during the validation phase of the deployment.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您不希望在订阅中部署SQL服务器。在Azure策略中，您可以创建一个策略并指定允许的服务，只有它们可以在该订阅中部署。请注意，如果您将策略分配给已经存在资源的订阅，Azure策略只能对分配后创建的资源进行操作。但是，如果任何现有资源在分配前不符合策略，它们将被标记为“不合规”，因此管理员可以在必要时进行更正。此外，Azure策略只会在部署的验证阶段生效。
- en: 'Some of the built-in policies are:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一些内置策略包括：
- en: 'Allowed locations: Using this, you can enforce geo-compliance.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许的位置：使用此功能，您可以强制执行地理合规性。
- en: 'Allowed virtual machine SKUs: Defines a set of virtual machine SKUs.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许的虚拟机SKU：定义一组虚拟机SKU。
- en: 'Add a tag to resources: Adds a tag to the resource. If no value is passed,
    it will take the default tag value.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向资源添加标签：向资源添加标签。如果没有传递值，它将采用默认的标签值。
- en: 'Enforce a tag and its value: Used to enforce a required tag and its value to
    the resource.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制执行标签及其值：用于强制执行对资源所需的标签及其值。
- en: 'Not allowed resource types: Prevents the deployment of selected resources.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许的资源类型：防止部署选定的资源。
- en: 'Allowed storage account SKUs: We discussed different SKUs that are available
    for storage accounts in the previous chapter, such as LRS, GRS, ZRS, and RA-GRS.
    You can specify the allowed SKUs, and the rest of them are denied from being deployed.'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许的存储帐户SKU：我们在上一章中讨论了可用于存储帐户的不同SKU，如LRS、GRS、ZRS和RA-GRS。您可以指定允许的SKU，其余的将被拒绝部署。
- en: 'Allowed resource type: As we mentioned in the example, you can specify which
    resources are allowed in the subscription. For example, if you want only VMs and
    networking, you can accept the **Microsoft.Compute** and **Microsoft.Network**
    resource providers; all other providers are denied from deployment.'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许的资源类型：正如我们在示例中提到的，您可以指定订阅中允许的资源。例如，如果您只想要VM和网络，您可以接受**Microsoft.Compute**和**Microsoft.Network**资源提供程序；所有其他提供程序都不允许部署。
- en: So far, we have discussed how Azure Policy can be used to audit Azure resources,
    but it can be also used to audit settings inside a VM. Azure Policy accomplishes
    this task using the Guest Configuration extension and client. The extension and
    client work hand-in-hand to confirm the configuration of the guest OS, the presence
    of an application, its state, and also the environmental settings of the guest
    OS.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了Azure Policy如何用于审计Azure资源，但它也可以用于审计VM内部的设置。Azure Policy通过使用Guest
    Configuration扩展和客户端来完成这项任务。扩展和客户端共同确认了客户操作系统的配置、应用程序的存在、状态以及客户操作系统的环境设置。
- en: Azure Policy Guest Configuration can only help you audit the guest VM. Applying
    configurations is not available at the time of writing.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Policy Guest Configuration只能帮助您审计客户VM。在撰写本文时，不支持应用配置。
- en: Guest Configuration Extension for Linux
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux的Guest Configuration扩展
- en: The guest policy configuration is done by the Guest Configuration extension
    and agent. The Guest Configuration agent on VMs is configured by using the Guest
    Configuration extension for Linux. As discussed earlier, they work hand-in-hand,
    allowing the user to run the in-guest policy on the VMs, which, in turn, helps
    the user to audit the policies on the VM. Chef InSpec ([https://www.inspec.io/docs/](https://www.inspec.io/docs/))
    is the In-Guest policy for Linux. Let's see how to deploy the extension to a VM
    and use the commands supported by the extension.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 客户策略配置由Guest Configuration扩展和代理完成。VM上的Guest Configuration代理通过使用Linux的Guest Configuration扩展进行配置。正如前面讨论的，它们共同工作，允许用户在VM上运行客户策略，从而帮助用户审计VM上的策略。Chef
    InSpec ([https://www.inspec.io/docs/](https://www.inspec.io/docs/))是Linux的客户策略。让我们看看如何将扩展部署到VM并使用扩展支持的命令。
- en: '**Deployment to a Virtual Machine**'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**部署到虚拟机**'
- en: 'To do this, you need to have a Linux VM. We will be deploying the Guest Configuration
    extension onto the VM by executing:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，您需要有一个Linux VM。我们将通过执行以下操作将Guest Configuration扩展部署到VM。
- en: '[PRE59]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You will get a similar output to this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得类似于此的输出：
- en: '![Deploying the Guest Configuration extension onto the VM](img/B15455_08_22.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![将Guest Configuration扩展部署到VM](img/B15455_08_22.jpg)'
- en: 'Figure 8.22: Deploying the Guest Configuration extension onto the VM'
  id: totrans-375
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.22：将Guest Configuration扩展部署到VM
- en: Commands
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令
- en: The Guest Configuration extension supports the `install`, `uninstall`, `enable`,
    `disable`, and `update` commands. To execute these commands; you need to switch
    the current working directory to `/var/lib/waagent/Microsoft.GuestConfiguration.ConfigurationForLinux-1.9.0/bin`.
    After that, you can chain the available commands with the `guest-configuration-shim`
    script.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Guest Configuration扩展支持`install`、`uninstall`、`enable`、`disable`和`update`命令。要执行这些命令，您需要切换当前工作目录到`/var/lib/waagent/Microsoft.GuestConfiguration.ConfigurationForLinux-1.9.0/bin`。之后，您可以使用`guest-configuration-shim`脚本链接可用的命令。
- en: Note
  id: totrans-378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Check whether the execute bit is enabled for the file. If not, use `chmod +x
    guest-configuration-shim` to set the execution permission.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 检查文件是否启用了执行位。如果没有，使用`chmod +x guest-configuration-shim`来设置执行权限。
- en: The general syntax for executing any command is `./guest-configuration-shim
    <command name>`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 执行任何命令的一般语法是`./guest-configuration-shim <command name>`。
- en: For example, if you want to install Guest Configuration Extension, you can use
    the `install` command. When the extension is already installed, `enable` will
    be called, which will extract the Agent package, which installs and enables the
    agent.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想要安装Guest Configuration扩展，可以使用`install`命令。当扩展已安装时，将调用`enable`，这将提取代理程序包，安装并启用代理程序。
- en: Similarly, `update` will update the Agent Service to the new agent, `disable`
    disables the agent, and, finally, `uninstall` will uninstall the agent.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`update`将更新代理服务到新代理，`disable`禁用代理，最后，`uninstall`将卸载代理。
- en: The agent is downloaded to a path such as `/var/lib/waagent/Microsoft.GuestConfiguration.ConfigurationForLinux-<version>/GCAgent/DSC`,
    and the `agent` output is saved to the `stdout` and `stderr` files in this directory.
    If you encounter any issues, verify the contents of these files. Try to understand
    the error and then troubleshoot.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 代理程序下载到路径，例如`/var/lib/waagent/Microsoft.GuestConfiguration.ConfigurationForLinux-<version>/GCAgent/DSC`，并且`agent`输出保存在此目录中的`stdout`和`stderr`文件中。如果遇到任何问题，请验证这些文件的内容。尝试理解错误，然后进行故障排除。
- en: Logs are saved to `/var/log/azure/Microsoft.GuestConfiguration.ConfigurationForLinux`.
    You can use these to debug the issues.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 日志保存在`/var/log/azure/Microsoft.GuestConfiguration.ConfigurationForLinux`。您可以使用这些日志来调试问题。
- en: 'Currently, these are the supported OS versions for Azure Policy Guest Configuration:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Azure Policy Guest Configuration支持以下操作系统版本：
- en: '![OS versions for Azure Policy Guest Configuration](img/B15455_08_23.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![Azure Policy Guest Configuration支持的操作系统版本](img/B15455_08_23.jpg)'
- en: 'Figure 8.23: OS versions supported for Azure Policy Guest Configuration'
  id: totrans-387
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.23：Azure Policy Guest Configuration支持的操作系统版本
- en: Azure Policy is written as a JSON manifest. As writing policies is not part
    of this book; you can refer the sample policy shared by Microsoft ([https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/governance/policy/samples/guest-configuration-applications-installed-linux.md](https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/governance/policy/samples/guest-configuration-applications-installed-linux.md)).
    This sample is to audit if specific applications are installed inside Linux VMs.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: Azure策略以JSON清单的形式编写。编写策略不是本书的一部分；您可以参考Microsoft共享的示例策略（[https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/governance/policy/samples/guest-configuration-applications-installed-linux.md](https://github.com/MicrosoftDocs/azure-docs/blob/master/articles/governance/policy/samples/guest-configuration-applications-installed-linux.md)）。此示例用于审计Linux
    VM中是否安装了特定应用程序。
- en: If you investigate the sample, you will learn what the components are and how
    you can use the parameters in your context.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您调查示例，您将了解组件是什么，以及如何在您的上下文中使用参数。
- en: Other Solutions
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他解决方案
- en: Another big player in the orchestration market is Puppet. Until very recently,
    the support for Azure in Puppet was very limited, but that is changing very quickly.
    The Puppet module, `puppetlabs/azure_arm`, is still somewhat in its infancy, but
    `puppetlabs/azure` provides you with everything you'll need. Both modules need
    the Azure CLI to work. The integration of the Azure CLI in their commercial Puppet
    Enterprise product is amazingly good. Azure has a VM extension that's available
    for VMs that will become Puppet nodes.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 编排市场中的另一个重要参与者是Puppet。直到最近，Puppet在Azure中的支持非常有限，但这种情况正在迅速改变。Puppet模块`puppetlabs/azure_arm`仍然处于起步阶段，但`puppetlabs/azure`为您提供了所需的一切。这两个模块都需要Azure
    CLI才能工作。将Azure CLI集成到其商业Puppet Enterprise产品中的工作非常出色。Azure有一个VM扩展，可用于将成为Puppet节点的VM。
- en: More information can be found at [https://puppet.com/products/managed-technology/microsoft-windows-azure](https://puppet.com/products/managed-technology/microsoft-windows-azure).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请访问[https://puppet.com/products/managed-technology/microsoft-windows-azure](https://puppet.com/products/managed-technology/microsoft-windows-azure)。
- en: You can also go for the Chef software, which provides an automation and orchestration
    platform that has been around for a long time. Its development started in 2009!
    The user writes "recipes" that describe how Chef manages the "kitchen" using tools
    such as a knife. In Chef, much of its terminology comes from the kitchen. Chef
    integrates very well with Azure, especially if you use Chef Automate from Azure
    Marketplace. There is also a VM extension available. Chef is intended for big
    environments and has a relatively steep learning curve, but it's worth trying
    it at least.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以选择Chef软件，它提供了一个自动化和编排平台，已经存在很长时间了。它的开发始于2009年！用户编写“食谱”，描述Chef如何使用诸如刀具之类的工具管理“厨房”。在Chef中，许多术语都来自厨房。Chef与Azure集成非常好，特别是如果您从Azure
    Marketplace使用Chef Automate。还有一个VM扩展可用。Chef适用于大型环境，学习曲线相对陡峭，但至少值得一试。
- en: More information can be found at [https://www.chef.io/partners/azure/](https://www.chef.io/partners/azure/).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请访问[https://www.chef.io/partners/azure/](https://www.chef.io/partners/azure/)。
- en: Summary
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'We started this chapter with a short introduction to orchestration, the reasons
    to use orchestration, and the different approaches: imperative versus declarative.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从简要介绍编排、使用编排的原因以及不同的方法：命令式与声明式开始了本章。
- en: 'After that, we covered the Ansible, Terraform, and PowerShell DSC platforms.
    Many details were covered about the following:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们介绍了Ansible、Terraform和PowerShell DSC平台。关于以下内容涵盖了许多细节：
- en: How to install the platforms
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装平台
- en: Working with resources at the OS level
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在操作系统级别处理资源
- en: Integration with Azure
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Azure集成
- en: Ansible is by far the most complete solution, and maybe the one with the least
    steep learning curve. However, all of the solutions are very powerful and there
    are always ways around their limitations. And for all orchestration platforms,
    the future is promising in terms of even more features and capabilities.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是迄今为止最完整的解决方案，也可能是学习曲线最平缓的解决方案。但是，所有解决方案都非常强大，总是有办法克服它们的局限性。对于所有编排平台来说，未来在功能和能力方面都是充满希望的。
- en: Creating Linux VMs is not the only way to create a workload in Azure; you can
    also use container virtualization to deploy a platform for your application. In
    the next chapter, we're going to cover container technologies.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure中创建Linux VM并不是在Azure中创建工作负载的唯一方法；您还可以使用容器虚拟化来部署应用程序的平台。在下一章中，我们将介绍容器技术。
- en: Questions
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: For this chapter, let's skip the normal questions. Fire up some VMs and choose
    the orchestration platform of your choice. Configure the network security groups
    to allow HTTP traffic.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，让我们跳过常规问题。启动一些VM并选择您选择的编排平台。配置网络安全组以允许HTTP流量。
- en: 'Try to configure the following resources with Ansible, Terraform, or PowerShell
    DSC:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用Ansible、Terraform或PowerShell DSC配置以下资源：
- en: Create a user and make it a member of the group `wheel` (RH-based distributions)
    or `sudo` (Ubuntu).
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用户并将其设置为`wheel`组（基于RH的发行版）或`sudo`（Ubuntu）的成员。
- en: Install an Apache web server, serve content from `/wwwdata`, secure it with
    AppArmor (Ubuntu) or SELinux (RHEL-based distributions), and serve a nice `index.html`
    page on this web server.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Apache Web服务器，从`/wwwdata`提供内容，使用AppArmor（Ubuntu）或SELinux（基于RHEL的发行版）进行安全保护，并在此Web服务器上提供一个漂亮的`index.html`页面。
- en: Restrict SSH to your IP address. HTTP ports must be open to the whole world.
    You can use systemd methods by providing override files or FirewallD.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将SSH限制为您的IP地址。HTTP端口必须对整个世界开放。您可以通过提供覆盖文件或FirewallD来使用systemd方法。
- en: Deploy a new VM with the distribution and version of your choice.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署一个新的VM，选择您喜欢的发行版和版本。
- en: 'Create a new `/etc/hosts` file using variables. If you use PowerShell DSC,
    you''ll need PowerShell as well for this task. For experts: use the hostnames
    and IP addresses of other machines in your resource group.'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用变量创建新的`/etc/hosts`文件。如果您使用PowerShell DSC，您还需要PowerShell来完成此任务。对于专家：使用资源组中其他计算机的主机名和IP地址。
- en: Further Reading
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: We really hope that you enjoyed this introduction to orchestration platforms.
    It was only a short introduction to make you curious to learn more. All the websites
    of the orchestration tools mentioned in this chapter are great resources and a
    pleasure to read.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的希望你喜欢这个对编排平台的介绍。这只是一个简短的介绍，让你对更多的学习产生好奇。本章提到的编排工具的所有网站都是很好的资源，阅读起来很愉快。
- en: 'Some extra resources to mention include the following:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些额外的资源需要提到，包括以下内容：
- en: '*Learning PowerShell DSC – Second Edition* by James Pogran.'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 詹姆斯·波格兰的《学习PowerShell DSC-第二版》。
- en: 'Ansible: We do think that *Learn Ansible* by Russ McKendrick, and other titles
    by the same author about Ansible, deserve a lot of credit. If you are too lazy
    to read the book, then you can refer to the Ansible documentation to start with.
    If you want some hands-on tutorials, you can use this GitHub repository: [https://github.com/leucos/ansible-tuto](https://github.com/leucos/ansible-tuto).'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible：我们确实认为Russ McKendrick的《学习Ansible》以及同一作者关于Ansible的其他书籍都值得赞扬。如果你懒得读这本书，那么你可以参考Ansible的文档开始学习。如果你想要一些实践教程，你可以使用这个GitHub仓库：[https://github.com/leucos/ansible-tuto](https://github.com/leucos/ansible-tuto)。
- en: 'Terraform: **Terraform on Microsoft Azure - Part 1: Introduction** is a blog
    series written by Julien Corioland, who is a Senior Software Engineer at Microsoft.
    The blog includes a series of topics discussing Terraform on Azure. It''s worth
    reading and trying out the tasks. The blog is available at [https://blog.jcorioland.io/archives/2019/09/04/terraform-microsoft-azure-introduction.html](https://blog.jcorioland.io/archives/2019/09/04/terraform-microsoft-azure-introduction.html).'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform：**在Microsoft Azure上使用Terraform-第1部分：介绍**是由微软高级软件工程师Julien Corioland撰写的博客系列。该博客包括一系列讨论Azure上Terraform的主题。值得一读并尝试这些任务。博客地址为[https://blog.jcorioland.io/archives/2019/09/04/terraform-microsoft-azure-introduction.html](https://blog.jcorioland.io/archives/2019/09/04/terraform-microsoft-azure-introduction.html)。
- en: '*Mastering Chef* by Mayank Joshi'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mayank Joshi的《精通Chef》
- en: '*Learning Puppet* by Jussi Heinonen'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jussi Heinonen的《学习Puppet》
