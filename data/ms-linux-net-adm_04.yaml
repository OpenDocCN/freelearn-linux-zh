- en: Chapter 4. Setting up a File Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。设置文件服务器
- en: In the previous chapter, we covered SSH and discussed SCP. While SCP is a great
    method to manually transfer individual files from one place to another, having
    one or more central locations to store shared files adds a lot of value to a network.
    Whether you're sharing important files on a business network or family photo albums
    on a home network, a central file storage location on your network is a convenient
    asset. In this chapter, we'll discuss three ways of accomplishing this goal. We'll
    first talk about some considerations while designing your file server, and then
    we'll cover NFS, Samba, and SSHFS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了SSH并讨论了SCP。虽然SCP是手动将单个文件从一个地方传输到另一个地方的好方法，但在网络上有一个或多个中心位置来存储共享文件对于网络增加了很多价值。无论您是在商业网络上共享重要文件，还是在家庭网络上共享家庭相册，网络上的中央文件存储位置都是一个方便的资产。在本章中，我们将讨论三种实现这一目标的方法。我们首先将讨论设计文件服务器时的一些考虑事项，然后我们将介绍NFS、Samba和SSHFS。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: File server considerations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件服务器的考虑事项
- en: NFS v3 versus NFS v4
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NFS v3与NFS v4
- en: Setting up an NFS server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置NFS服务器
- en: Learning the basics of Samba
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Samba的基础知识
- en: Setting up a Samba server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Samba服务器
- en: Mounting network shares
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载网络共享
- en: Automatically mounting network shares via fstab and systemd
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过fstab和systemd自动挂载网络共享
- en: Creating networked filesystems with SSHFS
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SSHFS创建网络文件系统
- en: File server considerations
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件服务器的考虑事项
- en: As with most things in the Linux world, there is more than one way of accomplishing
    any goal. With each method, there are a multitude of best practices and caveats
    to understand before implementing a solution. As mentioned earlier, the three
    most common methods of sharing files from one Linux system to another are **Network
    File System** (**NFS**), **Samba**, and **Secure Shell File** **System** (**SSHFS**).
    Each of these three primarily serve different needs, and your network layout will
    determine which you should use.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与Linux世界中的大多数事物一样，实现任何目标的方法不止一种。对于每种方法，都有许多最佳实践和注意事项需要在实施解决方案之前了解。正如前面提到的，从一个Linux系统向另一个Linux系统共享文件的三种最常见方法是**网络文件系统**（**NFS**）、**Samba**和**安全外壳文件**
    **系统**（**SSHFS**）。这三种方法主要满足不同的需求，您的网络布局将决定您应该使用哪种方法。
- en: The first consideration while designing a network file server is what types
    of platforms will need to access its files. NFS is often a great choice within
    a Linux-based environment; however, it doesn't handle mixed environments as well,
    so you may not want to choose it if you have Windows machines on your network
    that you need to share files with. It's not that you can't access NFS shares on
    Windows systems (you certainly can), but Microsoft limits NFS availability (called
    **Services for NFS)** to the most expensive edition of each version of Windows.
    Services for NFS is fine if you utilize versions of Windows that support it, but
    due to the extra licensing hurdle you'd need to overcome, it may make more sense
    to avoid it. Generally speaking, NFS is a great choice only when your network
    consists primarily of UNIX and Linux nodes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 设计网络文件服务器时的第一个考虑事项是需要访问其文件的平台类型。NFS通常是Linux环境中的一个很好的选择；然而，它在处理混合环境时表现不佳，因此如果您的网络中有需要与Windows机器共享文件的情况，您可能不希望选择它。并不是说您不能在Windows系统上访问NFS共享（您当然可以），但微软限制了NFS的可用性（称为**NFS服务**）到每个Windows版本的最昂贵的版本。如果您使用支持它的Windows版本，NFS服务是可以的，但由于需要克服额外的许可障碍，避开它可能更有意义。一般来说，只有当您的网络主要由UNIX和Linux节点组成时，NFS才是一个很好的选择。
- en: Next up for consideration is Samba. Samba allows you to share files between
    all three major platforms (Windows, Linux, and Mac OSX) and is a great choice
    within a mixed environment. Since Samba uses the **SMB** protocol, Windows systems
    are able to access your Samba shares regardless of the version you have installed,
    so licensing isn't as much of an issue. In fact, even the standard or home editions
    of Windows are able to access these shares natively, with no added plugins required
    for you to install. The downside to Samba is in the way that it handles permissions.
    When saving files between Windows and Linux nodes, some extra work is required
    to handle permissions, such that it's not always the best choice when dealing
    with UNIX or Linux nodes that need to retain specific permissions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要考虑的是Samba。Samba允许在所有三个主要平台（Windows、Linux和Mac OSX）之间共享文件，并且在混合环境中是一个很好的选择。由于Samba使用**SMB**协议，Windows系统可以访问您的Samba共享，而不管您安装的版本如何，因此许可证并不是那么重要。事实上，即使是Windows的标准版或家庭版也能够本地访问这些共享，无需安装额外的插件。Samba的缺点在于它处理权限的方式。在Windows和Linux节点之间保存文件时，需要一些额外的工作来处理权限，因此在处理需要保留特定权限的UNIX或Linux节点时，它并不总是最佳选择。
- en: Finally, SSHFS is another method that is primarily geared toward sharing files
    between Linux nodes. It's certainly possible to connect and access SSHFS from
    Windows, but only with third-party utilities, as no built-in method exists in
    Windows (at least at the time this chapter is being written). Where SSHFS shines
    is its ease of use and the fact that file transfers are encrypted. While encryption
    certainly helps you to avoid eavesdropping, keep in mind that SSHFS (just like
    any other solution) is only as secure as the policies you have in place. But in
    good hands, SSH (and SSHFS) is a secure method of transferring files from one
    node to another. In addition, SSHFS is the easiest of the three methods listed
    here to get running. All you need is access to another node and permissions to
    access one or more directories. That's all you need, and then you're automatically
    able to create an SSHFS connection to any directory you have access to. Another
    benefit to SSHFS is that there's nothing to configure on the server other than
    SSH itself, which most servers have available anyway. SSHFS connections can also
    be created and disconnected on-demand very quickly. We'll discuss SSHFS later
    on in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，SSHFS是另一种主要用于在Linux节点之间共享文件的方法。当然，可以从Windows连接和访问SSHFS，但只能使用第三方实用程序，因为Windows中没有内置的方法（至少在撰写本章时）。SSHFS的优点在于其易用性和文件传输的加密。虽然加密确实有助于避免窃听，但请记住，SSHFS（就像任何其他解决方案一样）只有在您制定的政策下才是安全的。但是在得心应手的情况下，SSH（和SSHFS）是从一个节点传输文件到另一个节点的安全方法。此外，SSHFS是这里列出的三种方法中最容易运行的。您只需要访问另一个节点和访问一个或多个目录的权限。这就是您需要的一切，然后您就可以自动连接到您有权限访问的任何目录。SSHFS的另一个好处是除了SSH本身之外，服务器上没有其他需要配置的东西，而大多数服务器都可以使用SSH。SSHFS连接也可以快速按需创建和断开。我们将在本章后面讨论SSHFS。
- en: NFS v3 versus NFS v4
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NFS v3与NFS v4
- en: Another consideration regarding NFS is the version you'll be using. Nowadays,
    most (if not all) Linux distributions default to NFS v4\. However, there are some
    cases where you may have older servers on your network, and you'll need to be
    able to connect to their shares. While NFS v4 is definitely the preferred version
    going forward, you might need to connect to a node using the older protocol.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关于NFS的另一个考虑是您将使用的版本。如今，大多数（如果不是全部）Linux发行版默认使用NFS v4。但是，有些情况下，您可能在网络上有较旧的服务器，需要能够连接到它们的共享。虽然NFS
    v4绝对是未来的首选版本，但您可能需要使用旧协议连接到节点。
- en: In both cases, directories on a file server can be shared via NFS by editing
    the `/etc/exports` file, which is where you'll list your shares (exports), one
    per line. We'll go over this file in more detail in the next section. But for
    now, keep in mind that the `/etc/exports` file is where you declare which directories
    on your filesystem are available for use with NFS. Different versions of NFS have
    different techniques of handling file locks and they differ in terms of the introduction
    of **idmapd**, performance, and security. Also, there are other differences such
    as NFS v4 moving to TCP-only (previous versions of the protocol allowed either
    UDP or TCP) and the fact that it is **stateful**, while previous versions were
    **stateless**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，可以通过编辑`/etc/exports`文件共享文件服务器上的目录，您将在其中列出您的共享（exports），每行一个。我们将在下一节详细讨论这个文件。但现在，请记住`/etc/exports`文件是您声明文件系统上哪些目录可用于NFS使用的地方。不同版本的NFS有不同的处理文件锁定的技术，它们在引入**idmapd**、性能和安全性方面有所不同。此外，还有其他差异，比如NFS
    v4转移到仅支持TCP（协议的早期版本允许UDP或TCP），以及它是**有状态**的，而早期版本是**无状态**的。
- en: By being stateful, NFS v4 includes file locking as part of the protocol itself,
    rather than relying on **Network Lock Manager** (**NLM**) to provide that function
    as NFS v3 did. If an NFS server were to crash or become unavailable, one or more
    nodes that were connected to it may have had open files, which would have been
    locked to those nodes. When the NFS server starts to back up, it re-establishes
    these locks and tries to recover from the crash. Although NFS servers do a fairly
    good job of recovering, they aren't perfect, and at times file locking can become
    a nightmare for administrators to deal with. With NFS v4, NLM is decommissioned
    and file locking is a part of the protocol itself, so locks are dealt with much
    more efficiently. However, it's still not perfect.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: NFS v4是有状态的，它将文件锁定作为协议的一部分，而不像NFS v3那样依赖于**网络锁管理器**（**NLM**）来提供该功能。如果NFS服务器崩溃或不可用，连接到它的一个或多个节点可能会有打开的文件，这些文件将被锁定到这些节点。当NFS服务器开始备份时，它会重新建立这些锁，并尝试从崩溃中恢复。尽管NFS服务器在恢复方面做得相当不错，但它们并不完美，有时文件锁定可能成为管理员处理的噩梦。使用NFS
    v4，NLM被废弃，文件锁定成为协议的一部分，因此锁定处理更加高效。然而，它仍然不完美。
- en: So, which version should you use? It's recommended to always use NFS v4 on all
    of your nodes and servers, unless you're dealing with an older server with older
    protocols that you still need to support.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您应该使用哪个版本？建议在所有节点和服务器上始终使用NFS v4，除非您需要支持旧协议的较旧服务器。
- en: Setting up an NFS server
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置NFS服务器
- en: Configuring an NFS server is relatively straightforward. Essentially, all you
    need to do is install the required packages, create your /`etc/exports` file,
    and ensure the required daemons (services) are running. In this activity, we'll
    set up an NFS server and also connect to it from a different node. In order to
    do so, it's recommended that you have at least two Linux machines to work with.
    It doesn't matter if these machines are physical or virtual machines, or any combination
    of those. If you've already followed through with [Chapter 1](ch01.html "Chapter 1. Setting
    up Your Environment"), *Setting up Your Environment*, you should already have
    several nodes to work with; hopefully, a mix of Debian and CentOS, since this
    procedure differs a bit between them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 配置NFS服务器相对简单。基本上，您只需要安装所需的软件包，创建您的`/etc/exports`文件，并确保所需的守护程序（服务）正在运行。在这个活动中，我们将设置一个NFS服务器，并从不同的节点连接到它。为了这样做，建议您至少有两台Linux机器可以使用。这些机器是物理机器还是虚拟机器，或者两者的组合并不重要。如果您已经按照[第1章](ch01.html
    "第1章。设置您的环境")*设置您的环境*进行了操作，您应该已经有了几个节点可以使用；希望是Debian和CentOS的混合，因为这个过程在它们之间有些不同。
- en: First, let's set up our NFS server. Pick a machine to act as the NFS server
    and install the required packages. It doesn't matter which distribution you choose
    as your server and which you choose as your client, I'll go over the configuration
    process for both CentOS and Debian. Since quite a few distributions are either
    based on Debian or use the same configuration as CentOS, this should work for
    most distributions out there. If you're using a distribution that doesn't follow
    either package naming convention, all you have to do is look up which package
    or meta-package to install on your server for your specific distribution. The
    rest of the configuration should be the same, since NFS is fairly standard.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设置我们的NFS服务器。选择一台机器作为NFS服务器并安装所需的软件包。您选择哪个发行版作为服务器，哪个作为客户端并不重要，我将介绍CentOS和Debian的配置过程。由于相当多的发行版要么基于Debian，要么使用与CentOS相同的配置，这对大多数发行版都适用。如果您使用的发行版不遵循任何软件包命名约定，您只需查找在您的特定发行版上安装的软件包或元软件包。其余的配置应该是相同的，因为NFS是相当标准的。
- en: 'To install the required packages on a CentOS system, we would execute the following
    command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要在CentOS系统上安装所需的软件包，我们将执行以下命令：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And for Debian, we install `nfs-kernel-server`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Debian，我们安装`nfs-kernel-server`：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: During installation of these packages, you may receive an error that NFS hasn't
    been started, due to `/etc/exports` not being present on the file system. When
    you install the required NFS packages on some distributions, this file may not
    be automatically created. Even if it does get created automatically, the file
    will just be a skeleton. If you do receive such an error, ignore it. We'll create
    this file shortly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装这些软件包时，您可能会收到一个错误，即NFS尚未启动，因为文件系统上不存在`/etc/exports`。在某些发行版上安装所需的NFS软件包时，可能不会自动创建此文件。即使它确实自动创建，该文件也只是一个框架。如果您收到这样的错误，请忽略它。我们将很快创建此文件。
- en: 'Next, we''ll want to make sure that the services related to NFS are enabled
    so that they will start as soon as the server starts up. For CentOS systems, we''ll
    use the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将确保与NFS相关的服务已启用，以便它们在服务器启动时启动。对于CentOS系统，我们将使用以下命令：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And for Debian, we can enable NFS via:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Debian，我们可以通过以下方式启用NFS：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Keep in mind that we simply enabled the NFS daemon on our server, which means
    that when the system is restarted, NFS will also be started (providing we configured
    it properly). However, we don't have to restart our entire server in order to
    start NFS; we can start that any time after we create our configuration files.
    Since we haven't actually configured NFS yet, we won't need to start the daemon
    yet. We'll do that later. In fact, until we actually create our configuration,
    your distribution probably won't let you start NFS anyway.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们只是在服务器上启用了NFS守护程序，这意味着当系统重新启动时，NFS也将启动（如果我们正确配置了它）。但是，我们不必重新启动整个服务器才能启动NFS；我们可以在创建配置文件后的任何时间启动它。实际上，直到我们实际创建配置之前，您的发行版可能根本不会让您启动NFS。
- en: The next step is to determine which directories on our server we wish to make
    available on our network. Which directories you share is pretty much up to you.
    Anything on the Linux filesystem is a candidate for an NFS export. However, some
    directories, such as `/etc` (which contains your systems configuration) or any
    other system directory, are probably best left private. While you can share any
    directory on your system, it's actually a common practice to create a single directory
    to house all of your shares, and then create subdirectories underneath, that you
    would then share to your clients.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是确定我们希望在网络上提供哪些服务器目录。您分享哪些目录基本上取决于您。Linux文件系统上的任何内容都可以作为NFS导出的候选项。但是，一些目录，比如`/etc`（其中包含系统配置）或任何其他系统目录，可能最好保持私有。虽然您可以共享系统上的任何目录，但实际上，常见做法是创建一个单独的目录来存放所有共享的内容，然后在其下创建子目录，然后共享给客户端。
- en: For example, perhaps you would create a directory called `exports` at the root
    of your filesystem (`mkdir /exports`) and then create directories such as `docs`
    and `images` that would be accessible to others. The beauty of this is that your
    shares could be managed from one place (the `/exports` directory) and NFS itself
    has the ability to classify this directory as your export root (we'll discuss
    this later). Before moving on, create some directories on your filesystem that
    you'll use to share, as we'll be placing these directories in a configuration
    file in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，也许您会在文件系统的根目录（`mkdir /exports`）下创建一个名为`exports`的目录，然后创建诸如`docs`和`images`之类的目录，以便他人可以访问。这样做的好处是，您的共享可以从一个地方（`/exports`目录）进行管理，并且NFS本身具有将此目录分类为您的导出根目录的能力（我们将在后面讨论）。在继续之前，在文件系统上创建一些目录，以便在下一节中将这些目录放入配置文件中。
- en: Once you've determined which directories in the file system you'd like to share
    and created them, you're ready to begin the actual configuration. Each NFS share,
    referred to as an export, is configured by adding one line per directory we wish
    to share in the `/etc/exports` file. Since you've already installed the required
    packages in order to get NFS on your system, this file may or may not already
    exist. In my experience, CentOS doesn't create this file during installation while
    Debian does. But even if you did get a default `exports` file, it would only contain
    commented out lines of code that don't have any practical purpose. In fact, you
    may have even received a warning or error during installation that the NFS daemon
    wasn't started as `/etc/exports` was not found. That's fine because we'll create
    this file soon.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了文件系统中想要共享的目录并创建了它们，你就可以开始实际的配置了。每个NFS共享，也称为export，在`/etc/exports`文件中添加每个我们希望共享的目录的一行来配置。由于你已经安装了所需的软件包以在系统上使用NFS，这个文件可能已经存在，也可能不存在。根据我的经验，CentOS在安装过程中不会创建这个文件，而Debian会。但即使你得到了一个默认的`exports`文件，它只会包含已注释掉的代码行，没有任何实际用途。实际上，你甚至可能在安装过程中收到警告或错误，说NFS守护进程没有启动，因为找不到`/etc/exports`。没关系，因为我们很快就会创建这个文件。
- en: 'While the default `exports` file is different from distribution to distribution
    (if it even gets created by default at all), the format for creating new exports
    is the same regardless of your chosen distribution, as NFS is fairly standard.
    The process for adding an export is to open the `/etc/exports` file in your favorite
    text editor and add each export to its own line. Any actual text editor will do,
    as long as it is a text editor and not a word processor. For example, if you''re
    a fan of vim, you can execute the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`exports`文件在不同的发行版之间可能不同（如果默认情况下根本不创建），但是创建新的exports的格式是相同的，不管你选择的发行版是什么，因为NFS是相当标准的。添加一个export的过程是打开你喜欢的文本编辑器中的`/etc/exports`文件，并将每个export添加到自己的一行中。任何实际的文本编辑器都可以，只要它是文本编辑器而不是文字处理器。例如，如果你喜欢vim，你可以执行以下命令：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you prefer `nano`, you can execute the following command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢`nano`，你可以执行以下命令：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In fact, you can even use graphical text editors such as Gedit, Kate, Pluma,
    or Geany if you would prefer to use GUI tools. These packages are available in
    the repositories of most distributions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你甚至可以使用图形文本编辑器，比如Gedit、Kate、Pluma或Geany，如果你更喜欢使用GUI工具。这些软件包都可以在大多数发行版的存储库中找到。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'It probably goes without saying, but to edit files within the `/etc` directory
    or any others that are owned by root, you''ll need to prefix such commands with
    `sudo` in order to edit them if you aren''t logged in as root. As a best practice,
    it''s recommended to not log in as root unless you absolutely have to. If you''re
    logged in as a normal user, execute the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不用说，但是要编辑`/etc`目录中或任何其他由root拥有的文件，你需要在这样的命令前加上`sudo`前缀，以便在没有以root身份登录时编辑它们。作为最佳实践，建议除非你绝对必须，否则不要以root身份登录。如果你以普通用户身份登录，执行以下命令：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In Debian, you'll see that the default `/etc/exports` file contains a list of
    comments, which may be helpful to you in viewing how exports are formatted. We
    can create new exports by simply adding them to the end of the file, preserving
    the contents. If you'd prefer to start off with a blank file, you may want to
    back up the original in case you want to refer to it later.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian中，你会看到默认的`/etc/exports`文件包含一系列注释，这可能对你有所帮助，以便查看exports的格式。我们可以通过简单地将它们添加到文件的末尾来创建新的exports，保留内容。如果你更喜欢从一个空白文件开始，你可能想要备份原始文件，以防以后需要参考它。
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once you have the file open in your favorite text editor, you should be ready
    to go. All of the directories you wish to share or *export* should be placed in
    this file, one on each line. Then, you append parameters to the share to control
    how it can be accessed and by whom. Here''s an example exports file with some
    example directories and some basic configuration parameters for each:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在你喜欢的文本编辑器中打开了文件，你就可以开始了。你希望共享或*导出*的所有目录都应该放在这个文件中，每个目录占据一行。然后，你可以附加参数到共享中，以控制它如何被访问以及由谁访问。以下是一个示例exports文件，其中包含一些示例目录和每个目录的一些基本配置参数：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see with those example exports, the format of each basically includes
    the directory we''d like to export, a network address we''d like to allow access
    to, followed by some additional options in parenthesis. There are many options
    you can append here, and we''ll go over some of them later in this chapter. But
    if you would like to view all of the options you can set here, refer to the following
    `man` command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这些示例exports中所看到的，每个的格式基本上包括我们想要导出的目录，我们想要允许访问的网络地址，然后是括号中的一些附加选项。你可以在这里附加许多选项，我们将在本章后面讨论其中一些。但如果你想查看你可以在这里设置的所有选项，可以参考以下`man`命令：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s discuss each section of the example `exports` file that was used previously:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下之前使用的示例`exports`文件的每个部分：
- en: '`/exports/docs`: The first section contains the directory we''re exporting
    to other nodes on the network. As mentioned before, you can share pretty much
    any directory you''d like. But just because you *can* share a directory doesn''t
    mean you *should*. Share only the directories that you wouldn''t mind others having
    access to.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/exports/docs`：第一部分包含我们要向网络上的其他节点导出的目录。如前所述，你几乎可以共享任何你想要的目录。但只是因为你*可以*共享一个目录，并不意味着你*应该*。只共享你不介意其他人访问的目录。'
- en: '`10.10.10.0/24`: Here, we''re limiting access to nodes within the `10.10.10.0/24`
    network. A node outside of that network will not be able to mount any of these
    exports. In this example, we could have used `10.10.10.0/255.255.255.0` and we
    would have achieved the same result. In our example, `/24` was used, which is
    known as the **Classless Inter-Domain Routing** (**CIDR**) notation that is a
    shorthand for typing out the subnet mask. Of course, there is much more to CIDR
    than that, but for now, just keep in mind that the CIDR notation was used instead
    of the subnet mask to keep the example shorter (plus, it looks cooler).'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10.10.10.0/24`：在这里，我们限制了对`10.10.10.0/24`网络内的节点的访问。该网络之外的节点将无法挂载任何这些导出。在此示例中，我们可以使用`10.10.10.0/255.255.255.0`，结果将是相同的。在我们的示例中，使用了`/24`，这被称为**无类域间路由**（**CIDR**）表示法，它是用于输入子网掩码的简写。当然，CIDR还有更多内容，但现在只需记住，与子网掩码相比，CIDR表示法用于使示例更短（而且看起来更酷）。'
- en: '`ro`: In the first export (docs), I''ve set it to read-only for no reason other
    than to show you that you can. This is probably self-explanatory, but a directory
    exported as read-only would allow others to mount the export and access the files
    within it, but not make any changes to anything.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ro`：在第一个导出（docs）中，我将其设置为只读，没有其他原因，只是为了向您展示您可以这样做。这可能是不言自明的，但导出为只读的目录将允许其他人挂载导出并访问其中的文件，但不会对任何内容进行更改。'
- en: '`rw`: A read-write export allows nodes that mount it, to create new files and
    modify existing ones (as long as the user has the required permissions set on
    the files themselves).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rw`：读写导出允许挂载它的节点创建新文件并修改现有文件（只要用户在文件本身上设置了所需的权限）。'
- en: '`no_subtree_check`: While this option is default and we don''t actually need
    to explicitly make a request, not including it may make NFS complain when it restarts.
    This option is the opposite of `subtree_check`, which is largely avoided nowadays.
    This option in particular, controls whether or not the server scans the underlying
    filesystem when processing actions within exports, which can increase security
    a bit but lower reliability. As disabling this option is known to increase reliability,
    it''s been made the default in recent versions of NFS.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no_subtree_check`：虽然此选项是默认的，我们实际上不需要显式发出请求，但不包括它可能会导致NFS在重新启动时抱怨。这个选项是`subtree_check`的相反，后者现在基本上是被避免的。特别是，此选项控制服务器在处理导出中的操作时是否扫描底层文件系统，这可能会增加一些安全性但降低可靠性。由于禁用此选项已知可以增加可靠性，因此在最近的NFS版本中已将其设置为默认值。'
- en: Although I didn't use it in any of my examples, a common export option you'll
    see set in `/etc/exports` is `no_root_squash`. Setting this option allows the
    root user on end-user devices to have root access to the files contained within
    the export. In most cases, this is a bad idea, but you will see this from time
    to time in the wild. This is the opposite of `root_squash`, which maps the root
    user to nobody instead. Unless you have a very good reason to do otherwise, `no_root_squash`
    is what you want.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我在我的任何示例中都没有使用它，但您将在`/etc/exports`中看到的常见导出选项是`no_root_squash`。设置此选项允许终端用户设备上的root用户对导出中包含的文件具有root访问权限。在大多数情况下，这是一个坏主意，但您会在野外偶尔看到这种情况。这与`root_squash`相反，后者将root用户映射到nobody。除非您有非常充分的理由做出不同的选择，否则`no_root_squash`是您想要的。
- en: 'In addition to classifying options for a single network, you can make your
    exports available to additional networks by adding configuration for them to the
    same line. Here''s an example of our `docs` mount shared with an additional network:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为单个网络分类选项外，您还可以通过在同一行中为它们添加配置来使您的导出可用于其他网络。以下是我们的`docs`挂载与其他网络共享的示例：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With this example, we're exporting `/exports/docs` so that it can be accessed
    by nodes within the `10.10.10.0/24` network and the `192.168.1.0/24` network.
    While I used the same options for both, you don't have to. You could even configure
    the export to be read-only for one network and read-write for another if you so
    desired.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此示例，我们正在导出`/exports/docs`，以便`10.10.10.0/24`网络和`192.168.1.0/24`网络内的节点可以访问。虽然我为两者使用了相同的选项，但您不必这样做。如果您愿意，甚至可以为一个网络配置导出为只读，而为另一个网络配置为读写。
- en: 'So far, we''ve been sharing our exports with entire networks. This is done
    by making the last octet of the allowed IP address a `0`. With the last example,
    any node with an IP address of `10.10.10.x` or `192.168.1.x` and a subnet mask
    of `255.255.255.0` would qualify for access to the export. However, you may not
    always want to give access to an entire network. Perhaps you may want to allow
    access to a single node instead. You can classify an individual node just as easily:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在与整个网络共享我们的导出。这是通过将允许的IP地址的最后一个八位设置为`0`来完成的。通过上一个示例，任何具有IP地址为`10.10.10.x`或`192.168.1.x`且子网掩码为`255.255.255.0`的节点都有资格访问导出。然而，您可能并不总是想要给整个网络访问权限。也许您只想允许单个节点访问。您可以同样轻松地对单个节点进行分类：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous example, we allowed a node with an IP address of `10.10.10.191`
    access to our export. Specifying an IP address or network enhances security, though
    it is not a 100 percent catch-all. However, limiting access to only the hosts
    that absolutely need it is a very good place to start when building your security
    policy. We'll cover security in greater detail in [Chapter 9](ch09.html "Chapter 9. Securing
    Your Network"), *Securing Your Network*. But for now, keep in mind that you can
    limit access to the export by specific networks or individual IPs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们允许具有IP地址`10.10.10.191`的节点访问我们的导出。指定IP地址或网络可以增强安全性，尽管这并非百分之百的通用方法。然而，仅限于绝对需要访问的主机是构建安全策略的一个非常好的起点。我们将在[第9章](ch09.html
    "第9章。保护您的网络")*保护您的网络*中更详细地介绍安全性。但现在，请记住，您可以通过特定网络或个别IP限制对导出的访问。
- en: 'Earlier, we touched on the fact that starting with Version 4, NFS can use a
    directory to serve as its export root, also known as the NFS pseudo filesystem.
    In the `/etc/exports` file, this is identified by placing either `fsid=0` or `fsid=root`
    as an option while exporting this directory. In this chapter, we''ve been using
    `/exports` to serve as the base of our NFS exports. If we wanted to identify this
    directory as our export root, we would change the `/etc/exports` file like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们提到从版本4开始，NFS可以使用一个目录作为其导出根，也称为NFS伪文件系统。在`/etc/exports`文件中，通过在导出此目录时放置`fsid=0`或`fsid=root`来标识这一点。在本章中，我们一直在使用`/exports`作为我们的NFS导出的基础。如果我们想要将此目录标识为我们的导出根，我们将像这样更改`/etc/exports`文件：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At first, this concept might be a big confusing, so let''s break this down
    a bit. In the first line, we identify our export root:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这个概念可能有点令人困惑，所以让我们把它分解一下。在第一行中，我们确定了我们的导出根：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we declare `/exports` as our export root. This is now the root of the
    NFS filesystem. Sure, you have a complete filesystem beginning with `/` in terms
    of Linux itself, but as far as NFS is concerned, its filesystem now begins here
    at `/exports`. In this line, we also declared `/exports` as read-only. We don't
    want anyone to make changes to this directory, as it is the NFS root. It's also
    shared with everyone (notice the `*`) but that shouldn't matter, as we set more
    granular permissions for each individual export. With the NFS root in place, clients
    can now mount these exports without needing to know the full path to get to it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明`/exports`为我们的导出根。这现在是NFS文件系统的根。当然，就Linux本身而言，您有一个以`/`开头的完整文件系统，但就NFS而言，它的文件系统现在从这里开始，即`/exports`。在这一行中，我们还将`/exports`声明为只读。我们不希望任何人对这个目录进行更改，因为它是NFS根。它也与所有人共享（注意`*`），但这不应该有关系，因为我们为每个单独的导出设置了更细粒度的权限。有了NFS根，客户端现在可以挂载这些导出，而无需知道如何到达它的完整路径。
- en: 'For example, a user might type the following to mount our `downloads` export
    to his or her local filesystem:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用户可能会输入以下内容，将我们的“downloads”导出挂载到他或她的本地文件系统：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is how you mount an NFS export from a local file server (`10.10.10.100`
    in this case), which is *not* using an NFS root. This requires the user to know
    that the directory is located at `/exports/downloads` on that server. But with
    the NFS root in place, we can have the user simplify the `mount` command as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何从本地文件服务器（在这种情况下为`10.10.10.100`）挂载NFS导出的方式，该服务器*不*使用NFS根。这需要用户知道该目录位于该服务器上的`/exports/downloads`。但是有了NFS根，我们可以让用户简化`mount`命令如下：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that we left out /exports in the previous command. While this may not
    seem like much, we're basically asking the server to give us the `downloads` export,
    wherever it may be on the file system. It doesn't matter if the `downloads` directory
    is located at `/exports/downloads`, `/srv/nfs/downloads`, or wherever else. We
    simply ask for the `downloads` export and the server knows where it is, because
    we set the NFS root.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在上一个命令中省略了/exports。虽然这可能看起来不是很重要，但我们基本上是在要求服务器给我们`downloads`导出，无论它在文件系统的哪个位置。`downloads`目录位于`/exports/downloads`，`/srv/nfs/downloads`或其他任何地方都无所谓。我们只是要求`downloads`导出，服务器知道它在哪里，因为我们设置了NFS根。
- en: 'Now that we''ve configured our `/etc/exports` file, it''s a good idea that
    we edit the `/etc/idmapd.conf` configuration file to configure some additional
    options. This isn''t absolutely required but it''s definitely recommended. The
    default `idmapd.conf` file is different from distribution to distribution, but
    each contains the options we would need to configure in this section. First, look
    for a line such as the following (or very similar):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了我们的`/etc/exports`文件，很好的建议我们编辑`/etc/idmapd.conf`配置文件以配置一些额外的选项。这并不是绝对必需的，但绝对是建议的。默认的`idmapd.conf`文件因发行版而异，但每个都包含我们需要在此部分配置的选项。首先，查找以下行（或非常相似的行）：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, we'll need to uncomment that line. Remove the `#` symbol and the trailing
    space so that the line begins with `Domain`. Then, set your domain so that it
    is the same as other nodes on your network. This domain would most likely have
    been chosen during installation. If you don't remember what yours is, running
    the `hostname` command should give you your domain name, which is immediately
    after your hostname. Do this for every node you'd like to be able to access NFS
    exports.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要取消注释该行。删除`#`符号和尾随空格，使该行以`Domain`开头。然后，设置您的域，使其与网络上的其他节点相同。这个域很可能在安装过程中已经选择过了。如果您不记得您的域是什么，运行`hostname`命令应该会给您您的域名，这个域名紧跟在您的主机名后面。对于您想要能够访问NFS导出的每个节点都要这样做。
- en: You might be wondering why this is necessary. When user and group accounts are
    created on a Linux system, they're assigned a **UID** (**User ID**) and **GID**
    (**Group ID**). Unless you created your user accounts on all of your systems in
    the same exact order, the UID and GID will most likely be different on each node.
    Even if you did create your user and group accounts in the same order, they could
    still be different. The `idmapd` file helps us by mapping these UIDs from one
    system to another. In order for `idmapd` to work, the `idmapd` daemon must be
    running on each node, and the file should also be configured with the same domain
    name. On both CentOS and Debian, this daemon runs under `/usr/sbin/rpc.idmapd`
    and is started along with the NFS server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么这是必要的。当在Linux系统上创建用户和组帐户时，它们被分配了**UID**（**用户ID**）和**GID**（**组ID**）。除非您在所有系统上以完全相同的顺序创建了用户帐户，否则UID和GID在每个节点上很可能是不同的。即使您按照相同的顺序创建了用户和组帐户，它们仍然可能是不同的。`idmapd`文件通过将这些UID从一个系统映射到另一个系统来帮助我们。为了使`idmapd`工作，`idmapd`守护程序必须在每个节点上运行，并且该文件还应配置相同的域名。在CentOS和Debian上，该守护程序在`/usr/sbin/rpc.idmapd`下运行，并且随NFS服务器一起启动。
- en: So, you might be wondering; what's the purpose of the `Nobody-User` and `Nobody-Group`?
    The `nobody` user runs scripts or commands that would be dangerous if run by a
    privileged user. Typically, the `nobody` user cannot log in to the system and
    does not have a home directory. If you run a process as `nobody`, its scope is
    limited if ever the account should be compromised. In the case of NFS, the `nobody`
    user and `nobody` group serve a special purpose. If the files are owned by a specific
    user on one system that doesn't exist on another, the permissions for the file
    will be displayed as being owned by the `nobody` user and group. This is also
    true of accessing files via the root user, when `no_root_squash` is not set. Depending
    on which distribution you're using, these accounts may have different names. In
    Debian, both `Nobody-User` and `Nobody-Group` default to simply `nobody`. In CentOS,
    these are both `nobody`. You can see in your `idmapd.conf` file which account
    is used for the `nobody` user and `nobody` group. You shouldn't need to rename
    these accounts, but if for some reason you do, you'll need to ensure that the
    `idmapd.conf` file has the correct names for them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你可能会想，`Nobody-User`和`Nobody-Group`的目的是什么？`nobody`用户运行的脚本或命令如果由特权用户运行可能会很危险。通常，`nobody`用户无法登录系统，也没有家目录。如果您将进程作为`nobody`运行，那么如果该帐户被破坏，其范围将受到限制。在NFS的情况下，`nobody`用户和`nobody`组具有特殊目的。如果文件由一个系统上不存在的特定用户拥有，那么文件的权限将显示为由`nobody`用户和组拥有。当未设置`no_root_squash`时，通过root用户访问文件也是如此。根据您使用的发行版，这些帐户可能具有不同的名称。在Debian中，`Nobody-User`和`Nobody-Group`默认为`nobody`。在CentOS中，这两者都是`nobody`。您可以在`idmapd.conf`文件中看到`nobody`用户和`nobody`组使用的帐户。您不应该需要重命名这些帐户，但如果出于某种原因您需要这样做，您需要确保`idmapd.conf`文件为它们具有正确的名称。
- en: Now that we have NFS configured and ready to go, how do we start using it? If
    you've been following along, you may have caught the fact that we enabled the
    NFS daemon but have yet to start it. Now that the configuration is in place, nothing
    is stopping us from doing so.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置好并准备好使用NFS了，我们该如何开始使用它呢？如果您一直在跟进，您可能已经注意到我们启用了NFS守护程序，但尚未启动它。既然配置已经就位，没有什么能阻止我们这样做了。
- en: 'On Debian we can start the NFS daemons by executing the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian上，我们可以通过执行以下命令来启动NFS守护程序：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On CentOS, we can execute the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS上，我们可以执行以下命令：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: From this point onwards, our NFS exports should be shared and ready to go. Later
    on in this chapter, I'll explain how to mount these exports (as well as Samba
    shares) on other systems.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，我们的NFS导出应该已经共享并准备就绪。在本章的后面，我将解释如何在其他系统上挂载这些导出（以及Samba共享）。
- en: 'There is one more thing in NFS that is worth mentioning. The `/etc/exports`
    file is read whenever the NFS daemon starts, which means you can activate new
    exports after you add them by restarting the server or the NFS daemon. However,
    in production, it''s not practical to restart NFS or the server itself. This would
    interrupt users that are currently using it and possibly cause stale mounts, which
    are invalidated connections to network shares (not a good situation to be in).
    Thankfully, activating new exports without restarting NFS itself is easy. Simply
    execute the following command and you''ll be good to go:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: NFS中还有一件值得一提的事情。每当NFS守护程序启动时，都会读取`/etc/exports`文件，这意味着您可以通过重新启动服务器或NFS守护程序来激活新的导出。但是，在生产中，重新启动NFS或服务器本身是不切实际的。这将中断当前正在使用它的用户，并可能导致过时的挂载，这是对网络共享的无效连接（这不是一个好的情况）。幸运的是，激活新的导出而无需重新启动NFS本身是很容易的。只需执行以下命令，您就可以开始了：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Learning the basics of Samba
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Samba的基础知识
- en: Samba, like NFS, allows you to share directories on your server with other computers
    within your network. Although both serve the same purpose, they fit different
    environments and use cases.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与NFS一样，Samba允许您与网络中的其他计算机共享服务器上的目录。尽管两者都有相同的目的，但它们适用于不同的环境和用例。
- en: NFS is the oldest method and is widely used in the Linux and UNIX world. While
    we certainly have newer solutions (such as SSHFS), NFS is tried and true. But
    it's perhaps not the best solution in a mixed environment. These days, it's possible
    that not every computer on your network runs a particular operating system, so
    you may have nodes where NFS access isn't available or is not practical.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: NFS是最古老的方法，在Linux和UNIX世界中被广泛使用。虽然我们当然有更新的解决方案（如SSHFS），NFS是经过验证的。但在混合环境中，它可能不是最佳解决方案。如今，您的网络上可能并非每台计算机都运行特定的操作系统，因此可能存在NFS访问不可用或不切实际的节点。
- en: As mentioned earlier, only the more expensive editions of Windows support NFS.
    If you have a large network of Windows machines, it would be quite expensive to
    update them all to a higher edition if you wouldn't otherwise need to. This is
    the area where Samba shines the most. Windows, Linux, and Mac computers can access
    directories shared via Samba. In the case of Windows, even the lower end editions
    can access Samba shares (such as Windows 7 Home Professional or Windows 10 core)
    without any new installations or purchases.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，只有更昂贵的Windows版本才支持NFS。如果你有一个庞大的Windows机器网络，要想将它们全部升级到更高版本将会非常昂贵，如果你本来不需要的话。这是Samba最擅长的领域。Windows、Linux和Mac计算机都可以通过Samba访问共享目录。在Windows的情况下，即使是较低端的版本也可以访问Samba共享（例如Windows
    7家庭专业版或Windows 10核心），而无需进行任何新的安装或购买。
- en: The downside to Samba is that it doesn't handle permissions as well as NFS does,
    so you need to manage the configuration file in special ways to respect permissions.
    However, it's not foolproof. For example, Windows and Linux/UNIX systems adopt
    very different schemes of permissions, so they are not inherently compatible.
    In Samba's configuration file, you can tell it to use certain user and group permissions
    on newly created files, and you can even force Samba to treat ownership as something
    other than what is actually stored with the file. So there are certainly ways
    to make Samba handle permissions better, but not inherently as good as a Linux
    or UNIX native solution such as NFS.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Samba的缺点是它处理权限的能力不如NFS，因此您需要以特殊的方式管理配置文件以尊重权限。然而，它并非百分之百可靠。例如，Windows和Linux/UNIX系统采用非常不同的权限方案，因此它们并不是本质上兼容的。在Samba的配置文件中，您可以告诉它在新创建的文件上使用特定的用户和组权限，甚至可以强制Samba将所有权视为与实际存储的文件不同的东西。因此，确实有方法可以使Samba处理权限更好，但本质上不如NFS这样的Linux或UNIX本地解决方案好。
- en: As far as how as Samba server might fit within your network, the basic rule
    of thumb is to use Samba in a mixed environment and NFS whenever cross-platform
    compatibility is not necessary.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 就Samba服务器如何适应您的网络而言，基本的经验法则是在混合环境中使用Samba，在不需要跨平台兼容性时使用NFS。
- en: Setting up a Samba server
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Samba服务器
- en: 'In this section, we''ll go ahead and set up a Samba server. In the next section,
    I''ll explain how to mount Samba shares. First, we''ll need to install Samba.
    On both CentOS and Debian systems, the package is simply referred to as `samba`.
    So, install that package via `apt-get` or `yum` and you should have everything
    you need:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续设置Samba服务器。在下一节中，我将解释如何挂载Samba共享。首先，我们需要安装Samba。在CentOS和Debian系统上，该软件包简单地被称为`samba`。因此，通过`apt-get`或`yum`安装该软件包，您应该拥有所需的一切：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The command using `apt-get` is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`apt-get`的命令如下：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'On Debian systems, Samba is started as soon as it is installed. In fact, it''s
    enabled as well, so it will automatically start each time you bring up your system.
    In the case of CentOS though, it is not enabled nor started after installation.
    If you chose CentOS to be your Samba server, you''ll need to enable and start
    the daemon:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian系统上，Samba在安装后立即启动。实际上，它也已启用，因此每次启动系统时都会自动启动。但在CentOS的情况下，安装后它既没有启用也没有启动。如果您选择CentOS作为Samba服务器，您需要启用并启动守护进程：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, Samba is installed, enabled, but not configured. To configure Samba, we''ll
    need to edit the `/etc/samba/smb.conf` file. By default, this file is created
    as soon as you install the required packages. However, the default file mainly
    exists to provide you with configuration examples. It''s quite massive, but you
    may want to take a look at it to see some syntax examples you may want to use
    later. You can either open the file in a text editor or simply `cat` the file
    to view it on your terminal:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Samba已安装、启用，但尚未配置。要配置Samba，我们需要编辑`/etc/samba/smb.conf`文件。默认情况下，安装所需软件包后会立即创建此文件。但是，默认文件主要是为您提供配置示例而存在的。它非常庞大，但您可能希望查看它以查看以后可能要使用的一些语法示例。您可以在文本编辑器中打开文件，也可以在终端上使用`cat`命令查看文件：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To simplify things, I recommend that you start with a fresh file. While the
    configuration examples are definitely good, we should probably use a shorter file
    for production purposes. Since the original file may be useful later, create a
    backup:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化事情，我建议您从一个新文件开始。虽然配置示例绝对不错，但我们可能应该为生产目的使用一个更短的文件。由于原始文件以后可能有用，创建一个备份：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, simply open the `smb.conf` file in a text editor, which will create a
    new/empty file since we moved the original file to a backup:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，只需在文本编辑器中打开`smb.conf`文件，这将创建一个新的/空的文件，因为我们已经将原始文件移动到备份中：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can start with the following basic configuration:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从以下基本配置开始：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's go through this configuration file line by line. First, we start with
    the `[global]` section, which is where we're configuring options that will take
    effect for the entire server. In fact, this is the only section in this particular
    file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行浏览这个配置文件。首先，我们从`[global]`部分开始，这是我们为整个服务器配置选项的地方。实际上，这是这个特定文件中唯一的部分。
- en: Next, we have `server string`. The `server string` is the description you'll
    see if browsing the network shares on a Windows system. For example, you may see
    a share named `Documents` and with a description beneath that reads; `File Server`.
    This section isn't required, but it's nice to have. In a business network, this
    can be useful for outlining a note about the system, such as where it is, or what
    it's used for.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`server string`。`server string`是您在Windows系统上浏览网络共享时会看到的描述。例如，您可能会看到一个名为`Documents`的共享，并在其下方看到一个描述;
    `文件服务器`。这个部分不是必需的，但拥有它是很好的。在企业网络中，这对于概述有关系统的注释，比如它在哪里，或者它用于什么，是很有用的。
- en: Following that, we set our `workgroup`. Those of you who have been administrators
    of Windows systems probably know this very well. The workgroup serves as a namespace
    to contain all systems of a particular purpose. In practice, this is typically
    the name of your LAN. Each computer within your LAN would have the same workgroup
    name, so they would show up as existing within the same network. When browsing
    shares on a Windows system, you'll likely see a list of workgroups and double-clicking
    on one of them would take you to a listing of systems that are sharing resources
    underneath that workspace. In most cases, you'll probably want to have the same
    workgroup name on each system, unless you'd like to separate resources. To view
    the workgroup name on an existing system, right-click on **My Computer** or **This
    PC** (depending on your version) and click on **Properties**. Your workgroup name
    should be listed within the window that appears.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们设置了我们的“工作组”。那些曾经是Windows系统管理员的人可能非常了解这一点。工作组用作包含特定目的所有系统的命名空间。在实践中，这通常是您的局域网的名称。您的局域网中的每台计算机都将具有相同的工作组名称，因此它们将显示为存在于同一网络中。在Windows系统上浏览共享时，您可能会看到工作组列表，双击其中一个将带您到共享资源的系统列表。在大多数情况下，您可能希望每个系统具有相同的工作组名称，除非您希望分开资源。要查看现有系统的工作组名称，请右键单击**我的电脑**或**此电脑**（取决于您的版本），然后单击**属性**。您的工作组名称应在出现的窗口中列出。
- en: '![Setting up a Samba server](img/B03919_04_01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![设置Samba服务器](img/B03919_04_01.jpg)'
- en: Viewing properties of a Windows system to gather the workgroup name, which is
    LOCALNET in this case
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Windows系统的属性以获取工作组名称，在这种情况下是LOCALNET
- en: The setting `security = user` tells Samba to use the user's username and password
    for authentication. If this matches, the user won't be prompted for a password
    to access the resource.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 设置`security = user`告诉Samba使用用户的用户名和密码进行身份验证。如果匹配，用户将不会被提示输入密码来访问资源。
- en: The `map to` `guest = Bad User` tells Samba that if the username and password
    that's provided does not match a local user account, treat the connecting user
    as if he or she connected via a guest account. If you'd rather such mapping not
    take place, remove this section.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`map to` `guest = Bad User`告诉Samba，如果提供的用户名和密码与本地用户帐户不匹配，将连接的用户视为通过访客帐户连接。如果您不希望进行这样的映射，可以删除此部分。'
- en: Next, `name resolve order = bcast hosts wins` determines the order in which
    name resolution happens. Here, we're using whatever name is broadcast first, followed
    by any hostname mappings in our `/etc/hosts file`, followed by `wins` (`wins`
    has largely been replaced by DNS, it's only included here for compatibility).
    In most networks, this order should work fine.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`name resolve order = bcast hosts wins`确定名称解析的顺序。在这里，我们首先使用广播的名称，然后是我们`/etc/hosts`文件中的任何主机名映射，最后是`wins`（`wins`已大部分被DNS取代，这里仅用于兼容性）。在大多数网络中，这个顺序应该可以正常工作。
- en: Finally we've `include = /etc/samba/smbshared.conf` at the end of our configuration
    file. Basically, this allows us to include another configuration file as if it
    were part of the existing one. In this case, we're including the contents of `/etc/samba/smbshared.conf`,
    which would be read by Samba once it reads this particular line. We'll create
    this file next. Essentially, this allows us to designate our shares in a separate
    configuration file. This isn't required, but I think it makes things much easier
    to manage. If you'd prefer, you could include the contents of the `smbshared.conf`
    file in your `smb.conf` file so that everything is in a single file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在配置文件的末尾添加了`include = /etc/samba/smbshared.conf`。基本上，这允许我们像包含现有文件一样包含另一个配置文件。在这种情况下，我们包含了`/etc/samba/smbshared.conf`的内容，Samba一旦读取了这一行，就会读取它。接下来我们将创建这个文件。基本上，这允许我们在单独的配置文件中指定我们的共享。这不是必需的，但我认为这样做会使事情更容易管理。如果您愿意，您可以在`smb.conf`文件中包含`smbshared.conf`文件的内容，以便一切都在一个文件中。
- en: 'Here''s an example `smbshared.conf` I''ve created for the purposes of this
    activity. In your case, all you would need to do is to ensure that the values
    match your system and the directories you''ve chosen to share:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我为此活动创建的一个`smbshared.conf`示例。在您的情况下，您只需要确保值与您的系统和您选择共享的目录匹配即可：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, I've created two shares. Each share begins with a name in brackets (which
    will be displayed on other systems while browsing shares on this machine) and
    then the configuration for that share. As you can see, I have a shared directory
    called `Music` and another called `Public`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我创建了两个共享。每个共享都以方括号中的名称开头（在浏览此计算机上的共享时将显示），然后是该共享的配置。正如您所看到的，我有一个名为“音乐”的共享目录，另一个名为“公共”。
- en: 'To declare the path to a share, use `path =` and then the path to the directory
    that the share corresponds to. In my example, you can see that I have the following
    directories shared:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明共享的路径，请使用`path =`，然后是共享对应的目录路径。在我的示例中，您可以看到我共享了以下目录：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Next, I also declare the shares as public by adding `public = yes`. This means
    that it's okay for guests to be able to access this share. If I would prefer guests
    not to be able to access it, I could set this to `no`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我还通过添加`public = yes`将共享声明为公共。这意味着允许访客访问此共享。如果我希望访客无法访问它，我可以将其设置为`no`。
- en: In my music share, I have `writable = no`. As the name suggests, this disables
    the ability for other computers to change files within this share. In my case,
    I share my music collection with other computers on my network, but I wouldn't
    want to accidentally delete music files.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的音乐共享中，我设置了`writable = no`。顾名思义，这禁用了其他计算机更改此共享中的文件的能力。在我的情况下，我与网络上的其他计算机共享我的音乐收藏，但我不希望意外删除音乐文件。
- en: 'In my public share, I have added a few extra options:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的公共共享中，我添加了一些额外选项：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These options all correspond to the permissions that are defaulted to when a
    new file is created within that share. For example, if I mounted my public share
    and then created a directory there, it would obtain permissions of `777`. If I
    created a file, its permissions would be `664`. Of course, you may not want to
    allow your files to be wide open, so you can change these permissions as you see
    fit. This option ensures consistency with permissions on newly created directories
    and files. This can be essential on a network where you may have automated processes
    running that need to access these files, and you'd want to make sure that you
    wouldn't need to manually correct the permissions each time such a process is
    run.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项都对应于在该共享中创建新文件时默认的权限。例如，如果我挂载了我的公共共享，然后在那里创建一个目录，它将获得`777`的权限。如果我创建一个文件，它的权限将是`664`。当然，你可能不想让你的文件完全开放，所以你可以根据自己的需要更改这些权限。这个选项确保了在新创建的目录和文件上的权限的一致性。这在一个可能有自动化进程运行需要访问这些文件的网络上是至关重要的，你希望确保每次运行这样的进程时不需要手动更正权限。
- en: 'Now that you''ve created your own Samba configuration, it''s a good idea to
    test your configuration. Thankfully, Samba itself includes a special command that
    allows you to do this. If you run `testparm` on your system, it will display any
    errors in syntax that you may have in your file. Then, it will display your configuration.
    Go ahead and run `testparm` on your system. If there are any errors, go back and
    ensure that there are no issues with what you typed in. If everything proceeds
    normally, you should see no errors, and then you''ll get a summary of your configuration.
    Once you''ve verified your configuration, restart the Samba daemon so that the
    changes take effect. To do that, simply run the following command on your Debian
    system:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了自己的Samba配置，测试你的配置是一个好主意。幸运的是，Samba本身包含一个特殊的命令，允许你这样做。如果你在系统上运行`testparm`，它将显示你文件中可能存在的语法错误。然后，它将显示你的配置。继续在你的系统上运行`testparm`。如果有任何错误，请返回并确保你输入的内容没有问题。如果一切正常进行，你将看不到错误，然后你将得到你配置的摘要。一旦验证了你的配置，重新启动Samba守护进程以使更改生效。要做到这一点，只需在你的Debian系统上运行以下命令：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For CentOS, use the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CentOS，请使用以下命令：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, you should be able to access your Samba shares on Windows or Linux systems.
    On Linux, most GUI file managers should allow you to browse your network for Samba
    shares. On Windows, you should be able to open **My Computer** or **This PC**
    and then click on **Network** to browse local networked computers with active
    shares. Perhaps a simpler way to access the shares on a Windows machine is to
    press the Windows key on your keyboard followed by *R* to open a run dialog, and
    then simply type in the name of your Samba server beginning with two backslashes.
    For example, to access my Debian-based file server (Pluto) from a Windows system,
    I would type the following into the run dialog and press *Enter*:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够在Windows或Linux系统上访问你的Samba共享。在Linux上，大多数图形界面文件管理器应该允许你浏览Samba共享的网络。在Windows上，你应该能够打开**我的电脑**或**此电脑**，然后点击**网络**来浏览本地网络上有活动共享的计算机。也许在Windows机器上访问共享的一个更简单的方法是按下键盘上的Windows键，然后按*R*打开运行对话框，然后简单地输入你的Samba服务器的名称，以两个反斜杠开头。例如，要从Windows系统访问我的基于Debian的文件服务器（Pluto），我会在运行对话框中输入以下内容，然后按*Enter*：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'I got a list of shares from that system, as shown in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我从该系统中得到了一个共享列表，如下面的屏幕截图所示：
- en: '![Setting up a Samba server](img/B03919_04_02.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![设置Samba服务器](img/B03919_04_02.jpg)'
- en: Viewing Samba shares (served from a Linux System) from a Windows 7 PC
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从Windows 7 PC查看Samba共享（从Linux系统提供）
- en: Mounting network shares
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挂载网络共享
- en: So far in this chapter, we've worked through creating both NFS and Samba shares.
    But we haven't actually mounted any of those shares yet. In this section, we'll
    take care of that.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们已经创建了NFS和Samba共享。但是我们还没有挂载任何这些共享。在本节中，我们将处理这个问题。
- en: In Linux, the `mount` command works for mounting just about everything. Whether
    you connect an external hard drive, insert a CD, or wish to mount a network share,
    the `mount` command serves as a Swiss Army Knife to allow you to mount such resources
    to your system. The `mount` command allows you to mount a resource and attach
    it to a local directory on your system. In most cases, `mount` runs automatically
    on most Linux systems where a graphical desktop environment is used. You've probably
    seen this if you've inserted a flash drive or some sort of optical media. In network
    shares, these are not mounted automatically, though they can be configured to
    be.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，`mount`命令可以用于挂载几乎所有东西。无论是连接外部硬盘，插入光盘，还是希望挂载网络共享，`mount`命令都可以作为瑞士军刀来允许你将这些资源挂载到你的系统上。`mount`命令允许你挂载一个资源并将其附加到你系统上的一个本地目录。在大多数情况下，在使用图形桌面环境的大多数Linux系统上，`mount`会自动运行。如果你插入了闪存驱动器或某种光学介质，你可能已经看到了这一点。在网络共享中，这些不会自动挂载，但可以配置为自动挂载。
- en: Perhaps the easiest way to mount network shares is to use a GUI file manager
    if you are using a system with a desktop environment installed. If you click on
    a file share, it will likely be mounted and you will be allowed to access it providing
    you have the necessary permissions on that system to do so. **Nautilus**, **Caja**,
    **Pcmanfm**, and **Dolphin** are popular Linux file managers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 也许挂载网络共享的最简单方法是在安装了桌面环境的系统上使用图形文件管理器。如果你点击一个文件共享，它很可能会被挂载，并且你将被允许访问它，前提是你在该系统上有必要的权限。**Nautilus**、**Caja**、**Pcmanfm**和**Dolphin**都是流行的Linux文件管理器。
- en: '![Mounting network shares](img/B03919_04_03.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![挂载网络共享](img/B03919_04_03.jpg)'
- en: The pcmanfm file manager, viewing shares from a Samba file server
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: pcmanfm文件管理器，查看来自Samba文件服务器的共享
- en: 'The `mount` command is most useful on systems without a graphical environment,
    or when you''d prefer to mount a resource somewhere other than the default. To
    use the `mount` command, give it the type of resource you''d like to mount, where
    it can find the resource, followed by which local directory to use for the mount.
    For example, to mount an NFS export, we might do something like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount`命令在没有图形环境的系统上或者当您希望将资源挂载到除默认位置之外的地方时最有用。要使用`mount`命令，给出您希望挂载的资源类型，它可以找到资源的位置，然后是用于挂载的本地目录。例如，要挂载NFS导出，我们可能会执行类似以下的操作：'
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Alternatively, use the following command if we set our NFS root, as I mentioned
    earlier:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们设置了NFS根目录，可以使用以下命令：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In that example, we tell the mount command we''d like to mount an NFS export
    by providing it with the `-t` parameter followed by `nfs` for the type. In my
    lab, this share exists on a computer with an IP address `10.10.10.101`, which
    I provide next with a colon and the directory on that system I''m accessing. In
    this case, `/exports/docs` on `10.10.10.101` is being accessed. Finally, I have
    a local directory `/mnt/docs`, which exists on my local computer where I''d like
    for this share to be mounted. After executing this command, each time I access
    `/mnt/docs` on my local computer, I''m actually accessing `/exports/docs` on my
    file server. After using this export, I simply unmount it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在该示例中，我们告诉挂载命令，我们希望通过提供`-t`参数后跟`nfs`来挂载NFS导出。在我的实验室中，此共享存在于具有IP地址`10.10.10.101`的计算机上，我随后提供了该计算机上我正在访问的目录。在这种情况下，正在访问`10.10.10.101`上的`/exports/docs`。最后，我有一个本地目录`/mnt/docs`，它存在于我本地计算机上，我希望将此共享挂载到该目录。执行此命令后，每次我在本地计算机上访问`/mnt/docs`时，实际上是在我的文件服务器上访问`/exports/docs`。在使用此导出后，我只需卸载它：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Mounting a Samba share on a Linux machine is a bit more involved. I''ll include
    an example command that can be used to mount a Samba share from that same server.
    But before we get to that, you''ll first need to have the necessary packages installed
    on your system in order to be able to mount Samba shares. On CentOS, install `samba-client`.
    On Debian, the package is `smbclient`. After you install the required package,
    you should be able to mount Samba shares by executing the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux机器上挂载Samba共享需要更多操作。我将包括一个示例命令，该命令可用于从同一服务器挂载Samba共享。但在执行此操作之前，您首先需要在系统上安装必要的软件包，以便能够挂载Samba共享。在CentOS上，安装`samba-client`。在Debian上，软件包是`smbclient`。安装所需软件包后，您应该能够通过执行以下命令来挂载Samba共享：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you need to access the resource via a password, use the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要通过密码访问资源，请使用以下命令：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, the same basic idea is used to mount a Samba share. But in this
    case, we format our target path differently, we use `cifs` for the filesystem
    type and we also include the username (and password, if your Samba server requires
    it). As in previous examples, we end the command with a local directory we would
    like to attach the mount to. In this case, I've created a `/mnt/samba/Videos`
    directory for this share.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，挂载Samba共享使用了相同的基本思想。但在这种情况下，我们以不同的方式格式化我们的目标路径，我们使用`cifs`作为文件系统类型，并且我们还包括用户名（以及密码，如果您的Samba服务器需要）。与以前的示例一样，我们以希望将挂载附加到的本地目录结束命令。在这种情况下，我为此共享创建了一个`/mnt/samba/Videos`目录。
- en: Automatically mounting network shares via fstab and systemd
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过fstab和systemd自动挂载网络共享
- en: As handy as mounting network shares via the `mount` command can be, you may
    not want to manually mount a share each time you wish to use it. In a network
    with a central file server, it makes sense to configure workstations to mount
    network shares automatically so that every time you boot your system, the share
    will automatically be mounted and ready to go.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通过`mount`命令挂载网络共享非常方便，但您可能不希望每次使用时都手动挂载共享。在具有中央文件服务器的网络中，配置工作站自动挂载网络共享是有意义的，这样每次启动系统时，共享将自动挂载并准备就绪。
- en: The tried and tested approach to mounting resources automatically is the `/etc/fstab`
    file. Every Linux system has a `/etc/fstab` file, so go ahead and look at yours.
    By default, this file only contains configuration for mounting your local resources,
    such as partitions on your hard disk. It's standard practice to add additional
    lines of configuration to this file to mount anything from additional hard drives
    to network shares.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 自动挂载资源的经过验证的方法是`/etc/fstab`文件。每个Linux系统都有一个`/etc/fstab`文件，所以请查看您的文件。默认情况下，此文件仅包含用于挂载本地资源的配置，例如硬盘上的分区。向此文件添加额外的配置行以挂载从额外硬盘到网络共享的任何内容是标准做法。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be careful while editing your `/etc/fstab` file. If you accidentally alter the
    configuration for your local hard disk, your system won't boot the next time you
    go to start it. Always use caution while editing this file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑您的`/etc/fstab`文件时要小心。如果意外更改了本地硬盘的配置，下次启动系统时系统将无法启动。在编辑此文件时请务必小心。
- en: 'Here''s an example `/etc/fstab` file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`/etc/fstab`文件示例：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In my file, the **Universally Unique Identifier** (**UUID**) reference my local
    hard disk partitions. These will be different on each system. Next, a mount point
    is listed for each. The `/` sign represents the root of the filesystem, and the
    swap partition doesn't need a mount point so it is set to `none`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的文件中，**通用唯一标识符**（**UUID**）引用了我的本地硬盘分区。这些在每个系统上都会有所不同。接下来，列出了每个挂载点。`/`符号代表文件系统的根，交换分区不需要挂载点，因此设置为`none`。
- en: 'At the end of the `/etc/fstab` file, we can add additional mounts that we would
    like to be available each time we start the system. If we wish to add an NFS share,
    we could do the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/etc/fstab`文件的末尾，我们可以添加希望在每次启动系统时可用的额外挂载。如果我们希望添加NFS共享，可以执行以下操作：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the first section, we declare the IP address of the server followed by a
    colon and the path to the exported directory. In this case, I'm accessing `/share/music`
    on `10.10.10.101`. The next section is the mount point, so I'm attaching this
    export to `/home/jay/music` on my local system. Next, we designate that the share
    we're accessing is `nfs`. No surprises there. Finally, we end the configuration
    with some options for how we would like to mount this share. An easy mount option
    is `rw`, which stands for read-write. We could've used `ro` here if we wanted
    to prevent the files contained within from being changed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分中，我们声明服务器的IP地址，后面跟着一个冒号和导出目录的路径。在这种情况下，我正在访问`10.10.10.101`上的`/share/music`。下一部分是挂载点，所以我将这个导出附加到本地系统上的`/home/jay/music`。接下来，我们指定我们正在访问的共享是`nfs`。最后，我们以一些选项结束配置，说明我们希望如何挂载这个共享。一个简单的挂载选项是`rw`，表示读写。如果我们想要防止其中的文件被更改，我们可以在这里使用`ro`。
- en: Among the options in the previous example is `x-systemd.automount`. Basically,
    this tells systemd (the default `init` system on Debian and CentOS since version
    8 and 7 respectively) that we would like to keep this mounted if possible. With
    this option, systemd will try its best to remount this share if for some reason
    it gets disconnected. Also, `x-systemd.device-timeout=10` can be added which tells
    the system to wait no longer than 10 seconds if the share isn't available on the
    network. We end the line with `0 0` because this isn't a local filesystem and
    doesn't need consistency check while booting.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中的选项中，有`x-systemd.automount`。基本上，这告诉systemd（Debian和CentOS的默认`init`系统，分别自版本8和7起）我们希望尽可能保持这个挂载。有了这个选项，systemd会尽最大努力重新挂载这个共享，如果由于某种原因它断开连接。另外，可以添加`x-systemd.device-timeout=10`，告诉系统如果共享在网络上不可用，不要等待超过10秒。我们以`0
    0`结束这一行，因为这不是一个本地文件系统，在启动时不需要一致性检查。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're not using a distribution with systemd (such as CentOS 7 and Debian
    8), do not include the `x-systemd` options because they won't be understood by
    distributions that use different `init` systems.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不使用带有systemd的发行版（如CentOS 7和Debian 8），不要包括`x-systemd`选项，因为它们不会被使用不同`init`系统的发行版理解。
- en: 'Similarly, Samba shares can also be added to your `/etc/fstab` file. Here''s
    an example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Samba共享也可以添加到你的`/etc/fstab`文件中。这是一个例子：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'One final note regarding the `/etc/fstab` file before we move on. The examples
    in this section have all assumed that you want a network share to be available
    automatically. However, this may not always be the case. If you add the `noauto`
    mount option to a configuration line in your `fstab`, the share will not automatically
    be mounted at boot time. With `noauto` added to our Samba example, the `fstab`
    line would be changed as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，关于`/etc/fstab`文件的最后一点说明。本节中的示例都假定你希望网络共享在启动时自动可用。然而，这并不总是情况。如果在`fstab`中的配置行中添加了`noauto`挂载选项，共享将不会在启动时自动挂载。通过将`noauto`添加到我们的Samba示例中，`fstab`行将更改如下：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'An NFS example would look like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: NFS示例如下：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'There are several situations where this might be useful. One example might
    be using a laptop, where you wouldn''t always be connected to the same network.
    If that is the case, you wouldn''t want your machine to try and automatically
    mount something unless you''re actually connected to that network. With `noauto`
    added as a mount option, you can manually mount the resource any time you need
    it, without needing to memorize a long `mount` command to do so. For example,
    to mount an NFS export that''s contained in your `fstab` file, you would execute
    the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种情况下这可能会有用。一个例子可能是使用笔记本电脑，你不会总是连接到同一个网络。如果是这种情况，你不希望你的机器在你实际连接到该网络时自动挂载某些东西。通过将`noauto`添加为挂载选项，你可以在需要时手动挂载资源，而无需记住一个长长的`mount`命令。例如，要挂载包含在你的`fstab`文件中的NFS导出，你将执行以下操作：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'By comparison, that''s a lot easier than typing the following each time you
    wish to mount that export:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，这比每次想要挂载该导出时输入以下内容要容易得多：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Since we added the export to the `fstab` file, the `mount` command looks for
    a relevant line when we type a simplified `mount` command as we have just done.
    If it finds a configuration for the mount point you're trying to access, it will
    let you access it without needing to type out the entire command. Even if you
    don't want to access remote shares automatically, it can still be quite handy
    to add them to your `fstab` file.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将导出添加到了`fstab`文件中，当我们输入一个简化的`mount`命令时，`mount`命令会查找相关行。如果它找到了你要访问的挂载点的配置，它将允许你访问它，而无需输入整个命令。即使你不想自动访问远程共享，将它们添加到你的`fstab`文件中仍然非常方便。
- en: Creating networked filesystems with SSHFS
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SSHFS创建网络文件系统
- en: In the previous chapter, we worked through SSH, which is a crucial utility that
    is used multiple times per day by most Linux administrators. But while it's great
    for accessing other Linux systems on your network, it also allows you to access
    remote filesystems as if they were mounted locally. This is known as **SSHFS**.
    One of the great things about SSHFS is that there is no need to clarify any exported
    directories before hand. If you're able to connect to a remote Linux server and
    access a directory via SSH, then you're automatically able to mount it locally
    as if it were a network share.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们通过SSH工作，这是大多数Linux管理员每天多次使用的关键实用程序。但是，虽然它非常适合访问网络上的其他Linux系统，但它也允许你访问远程文件系统，就好像它们是本地挂载的一样。这就是**SSHFS**。关于SSHFS的一大好处是，无需事先澄清任何导出的目录。如果你能够连接到远程Linux服务器并通过SSH访问目录，那么你就能够自动将其本地挂载，就好像它是一个网络共享一样。
- en: 'On Debian systems, you can simply install the `sshfs` package. On CentOS, the
    `sshfs` package is not available by default. Before you can install `sshfs` on
    a CentOS system, you''ll need to add a whole new repository, known as **Extra
    Packages for Enterprise Linux** (**EPEL**). To do that, simply install the `epel-release`
    package:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian系统上，您可以简单地安装`sshfs`软件包。在CentOS上，默认情况下不提供`sshfs`软件包。在CentOS系统上安装`sshfs`之前，您需要添加一个全新的存储库，称为**企业Linux的额外软件包**（**EPEL**）。要做到这一点，只需安装`epel-release`软件包：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After installing the `epel` repository, you should be able to install `sshfs`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`epel`存储库后，您应该能够安装`sshfs`：
- en: '[PRE46]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Once installed, you''re able to mount directories on your local file system
    quite easily:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您可以轻松地在本地文件系统上挂载目录：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In order to work, your user account must have access not only to the remote
    system, but also to the local mount point. Once you initiate the command, you'll
    see prompts similar to those you'd normally see while connecting to the server
    via SSH. Essentially, that's exactly what you're doing. The difference is that
    the connection remains open in the background, maintaining the relationship between
    the remote directory and the local directory.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了工作，您的用户帐户必须不仅访问远程系统，还要访问本地挂载点。一旦启动命令，您将看到类似于通过SSH连接到服务器时通常看到的提示。基本上，这就是您正在做的事情。不同之处在于连接保持在后台打开，保持远程目录和本地目录之间的关系。
- en: 'Using `sshfs` is a great idea for when you need to mount something on a remote
    filesystem, but you may not need to access it again or that often. But similar
    to NFS and Samba shares, you can actually use `/etc/fstab` to mount a resource
    via SSHFS. Consider the following `fstab` example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要在远程文件系统上挂载某些内容，但您可能不需要再次访问或频繁访问时，使用`sshfs`是一个很好的主意。但与NFS和Samba共享类似，您实际上可以使用`/etc/fstab`通过SSHFS挂载资源。考虑以下`fstab`示例：
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As we''ve done before, we set `noauto` so that we can establish this connection
    by simply typing:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，我们设置了`noauto`，这样我们只需键入即可建立此连接：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this action-packed chapter, we worked through several ways of accessing and
    sharing files within a Linux-based network. We started off discussing NFS, which
    is an old but trusty method of sharing files within a Linux and UNIX network.
    We also covered Samba, a method of sharing resources within a mixed operating
    system environment. We also discussed how to mount such shares manually as well
    as automatically. We finished our discussion with SSHFS, which is a quite handy
    (yet not well-known) feature of SSH that allows us to mount directories from other
    systems on-demand.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个充满活力的章节中，我们通过几种方式访问和共享Linux网络中的文件。我们首先讨论了NFS，这是在Linux和UNIX网络中共享文件的一种古老但可靠的方法。我们还涵盖了Samba，这是在混合操作系统环境中共享资源的一种方法。我们还讨论了如何手动以及自动地挂载这些共享。我们最后讨论了SSHFS，这是SSH的一个非常方便（但不太知名）的功能，它允许我们根据需要从其他系统挂载目录。
- en: Of course, with relying on our networked resources in our network, it's important
    to keep each node running in tip top shape. In the next chapter, we'll work through
    monitoring system resources and keeping our nodes happy and healthy.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，依赖于我们网络中的资源，保持每个节点的良好运行状态非常重要。在下一章中，我们将通过监视系统资源并保持节点的良好状态来工作。
