- en: Building the 5.x Linux Kernel from Source - Part 1
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码构建5.x Linux内核 - 第1部分
- en: Building the Linux kernel from source code is an interesting way to begin your
    kernel development journey! Rest assured, it's a long and arduous journey, but
    that's the fun of it, right? The kernel build topic itself is large enough to
    merit being divided into two chapters, this one and the next.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码构建Linux内核是开始内核开发之旅的有趣方式！请放心，这是一个漫长而艰巨的旅程，但这就是其中的乐趣，对吧？内核构建主题本身足够大，值得分成两章，本章和下一章。
- en: The primary purpose of this chapter and the next is to describe in detail how
    exactly you can build a Linux kernel from scratch, from source code. In this chapter,
    you will initially learn how to download a stable vanilla Linux kernel source
    tree onto a guest Linux **Virtual Machine** (**VM**) (by vanilla kernel, we mean
    the plain and regular default kernel source code released by the Linux kernel
    community on its repository, [https://www.kernel.org](https://kernel.org)). Next,
    we will learn a little bit about the layout of the kernel source code – getting,
    in effect, a 10,000-foot view of the kernel code base. The actual kernel build
    recipe then follows.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和下一章的主要目的是详细描述如何从头开始、从源代码构建Linux内核。在本章中，您将首先学习如何将稳定的原始Linux内核源树下载到一个Linux**虚拟机**（**VM**）上（通过原始内核，我们指的是Linux内核社区在其存储库上发布的普通默认内核源代码，[https://www.kernel.org](https://kernel.org)）。接下来，我们将学习一些关于内核源代码布局的知识
    - 实际上是对内核代码库的一个整体概览。然后是实际的内核构建过程。
- en: 'Before proceeding, a key piece of information: any Linux system, be it a supercomputer
    or a tiny embedded device, has three required components: a bootloader, an **Operating
    System** (**OS**) kernel, and a root filesystem. In this chapter, we concern ourselves only with
    the building of the Linux kernel from source. We do not delve into the root filesystem
    details, and (in the next chapter) learn to minimally configure the (very x86-specific)
    GNU GRUB bootloader.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，一个关键信息：任何Linux系统，无论是超级计算机还是微型嵌入式设备，都有三个必需的组件：引导加载程序、**操作系统**（**OS**）内核和根文件系统。在本章中，我们只关注从源代码构建Linux内核。我们不深入研究根文件系统的细节，并且（在下一章中）学习如何最小化配置（非常特定于x86的）GNU
    GRUB引导加载程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Preliminaries for the kernel build
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核构建的前提条件
- en: Steps to build the kernel from source
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建内核的步骤
- en: Step 1 – obtaining a Linux kernel source tree
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1步 - 获取Linux内核源树
- en: Step 2 – extracting the kernel source tree
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2步 - 提取内核源树
- en: Step 3 – configuring the Linux kernel
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3步 - 配置Linux内核
- en: Customizing the kernel menu – adding our own menu item
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义内核菜单 - 添加我们自己的菜单项
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: I assume that you have gone through [Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml), *Kernel
    Workspace Setup*, and have appropriately prepared a guest VM running Ubuntu 18.04
    LTS (or CentOS 8, or later stable releases of these distributions) and installed
    all the required packages. If not, I highly recommend you do this first.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设您已经阅读了[第1章](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml)，*内核工作空间设置*，并已经适当地准备了一个运行Ubuntu
    18.04 LTS（或CentOS 8，或这些发行版的后续稳定版本）的客户VM，并安装了所有必需的软件包。如果没有，我强烈建议您首先这样做。
- en: To get the most out of this book, I strongly recommend you first set up the
    workspace environment, including cloning this book's GitHub repository ([https://github.com/PacktPublishing/Linux-Kernel-Programming](https://github.com/PacktPublishing/Linux-Kernel-Programming))
    for the code, and work on it in a hands-on fashion*.*
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用本书，我强烈建议您首先设置工作空间环境，包括克隆本书的GitHub存储库（[https://github.com/PacktPublishing/Linux-Kernel-Programming](https://github.com/PacktPublishing/Linux-Kernel-Programming)）以获取代码，并进行实际操作。
- en: Preliminaries for the kernel build
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核构建的前提条件
- en: 'It''s important to understand a few things right from the outset that will
    help you as we proceed on our journey of building and working with a Linux kernel. Firstly,
    the Linux kernel and its sister projects are completely decentralized - it''s
    a virtual, online open-source community! The closest we come to an office is this:
    stewardship of the Linux kernel (as well as several dozen related projects) is
    in the capable hands of the Linux Foundation ([https://linuxfoundation.org/](https://linuxfoundation.org/));
    further, it manages the Linux Kernel Organization, a private foundation that distributes
    the Linux kernel to the public for no charge ([https://www.kernel.org/nonprofit.html](https://www.kernel.org/nonprofit.html)).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始就了解一些事情对我们在构建和使用Linux内核的旅程中会有所帮助。首先，Linux内核及其姊妹项目是完全去中心化的 - 这是一个虚拟的、在线的开源社区！我们最接近办公室的地方是：Linux内核（以及几十个相关项目）的管理权在Linux基金会（[https://linuxfoundation.org/](https://linuxfoundation.org/)）的有力掌握之下；此外，它管理着Linux内核组织，这是一个私人基金会，向公众免费分发Linux内核（[https://www.kernel.org/nonprofit.html](https://www.kernel.org/nonprofit.html)）。
- en: 'Some of the key points we discuss in this section includes the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的一些关键点包括以下内容：
- en: The kernel release, or version number nomenclature
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核发布，或版本号命名法
- en: The typical kernel development workflow
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 典型的内核开发工作流程
- en: The existence of different types of kernel source trees within the repository
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库中不同类型的内核源树的存在
- en: With this information in place, you will be better armed to move through the
    kernel build procedure. All right, let's go over each of the preceding points.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，您将更好地了解内核构建过程。好的，让我们逐个讨论前面提到的每一点。
- en: '**Kernel release nomenclature**'
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**内核发布命名法**'
- en: 'To see the kernel version number, simply run `uname -r` on your shell. How
    do you precisely interpret the output of `uname -r`? On our Ubuntu distribution
    version 18.04 LTS guest VM, we run `uname(1)`, passing the `-r` option switch
    to display just the current kernel release or version:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看内核版本号，只需在shell上运行`uname -r`。如何准确解释`uname -r`的输出？在我们的Ubuntu 18.04 LTS客户VM上，我们运行`uname(1)`，传递`-r`选项开关，只显示当前的内核发布或版本：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Of course, by the time you read this, the Ubuntu 18.04 LTS kernel has certainly
    been upgraded to a later release; that's perfectly normal. The 5.0.0-36-generic
    kernel was the one I encountered with the Ubuntu 18.04.3 LTS at the time of writing
    this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在您阅读本文时，Ubuntu 18.04 LTS内核肯定已经升级到了更高的版本；这是完全正常的。在我写这一章节时，5.0.0-36-generic内核是我在Ubuntu
    18.04.3 LTS中遇到的版本。
- en: 'The modern Linux kernel release number nomenclature is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Linux内核发布号命名规范如下：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is also often written or described as `w.x[.y][-z]`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这也经常被写成或描述为`w.x[.y][-z]`。
- en: 'The square brackets around the `patchlevel` and `EXTRAVERSION` components indicate
    that they are optional. The following table summarizes the meaning of the components
    of the release number:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号表示`patchlevel`和`EXTRAVERSION`组件是可选的。以下表总结了发布号的各个组件的含义：
- en: '| **Release # component** | **Meaning** | **Example numbers** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **发布号组件**| **含义**| **示例号码**|'
- en: '| Major `#` (or `w`) | Main or major number; currently, we are on the 5.x kernel
    series, thus the major number is `5`. | `2`, `3`, `4`, and `5` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 主要`#`（或`w`）| 主要号码；目前，我们在5.x内核系列上，因此主要号码是`5`。| `2`，`3`，`4`和`5`|'
- en: '| Minor `#` (or `x`) | The minor number, hierarchically under the major number.
    | `0` onward |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 次要`#`（或`x`）| 次要号码，在主要号码之下。| `0`及以上|'
- en: '| `[patchlevel]` (or `y`) | Hierarchically under the minor number – also called
    the ABI or revision – applied on occasion to the stable kernel when significant
    bug/security fixes are required. | `0` onward |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `[patchlevel]`（或`y`）| 在次要号码之下 - 也称为ABI或修订版 - 在需要时应用于稳定内核，以进行重要的错误/安全修复。|
    `0`及以上|'
- en: '| `[-EXTRAVERSION]` (or `-z`) | Also called `localversion`; typically used
    by distribution kernels to track their internal changes. | Varies; Ubuntu uses `w.x.y-''n''-generic`
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `[-EXTRAVERSION]`（或`-z`）| 也称为`localversion`；通常由发行版内核用于跟踪其内部更改。| 变化；Ubuntu使用`w.x.y-''n''-generic`|'
- en: Table 2.1 – Linux kernel release nomenclature
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 - Linux内核发布命名规范
- en: 'So, we can now interpret our Ubuntu 18.04 LTS distribution''s kernel release
    number, `5.0.0-36-generic`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在可以解释我们Ubuntu 18.04 LTS发行版的内核发布号`5.0.0-36-generic`：
- en: '**Major # (or w)**: `5`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要#（或w）**：`5`'
- en: '**Minor # (or x)**: `0`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**次要#（或x）**：`0`'
- en: '**[patchlevel] (or y)**: `0`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[patchlevel]（或y）**：`0`'
- en: '**[-EXTRAVERSION] (or -z)**: `-36-generic`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[-EXTRAVERSION]（或-z）**：`-36-generic`'
- en: Note that distribution kernels may or may not precisely follow these conventions,
    it's really up to them. The regular or vanilla kernels released on [https://www.kernel.org/](https://www.kernel.org/) do
    follow these conventions (at least until Linus decides to change them).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，发行版内核可能会或可能不会严格遵循这些约定，这取决于他们自己。在[https://www.kernel.org/](https://www.kernel.org/)发布的常规或原始内核确实遵循这些约定（至少在Linus决定更改它们之前）。
- en: (a) As part of an interesting exercise configuring the kernel, we will later
    change the `localversion` (aka `-EXTRAVERSION`) component of the kernel we build.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: （a）作为一个有趣的练习配置内核的一部分，我们将稍后更改我们构建的内核的`localversion`（又名`-EXTRAVERSION`）组件。
- en: (b) Historically, in kernels before 2.6 (IOW, ancient stuff now), the *minor
    number *held a special meaning; if an even number, it indicated a stable kernel
    release, if odd, an unstable or beta release. This is no longer the case.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: （b）在2.6之前的内核中（也就是说，现在是古老的东西），*次要号*具有特殊的含义；如果是偶数，表示稳定的内核发布，如果是奇数，表示不稳定或测试版发布。现在不再是这样了。
- en: Kernel development workflow – the basics
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核开发工作流程 - 基础知识
- en: Here, we provide a brief overview of the typical kernel development workflow.
    Anyone like you who is interested in kernel development should at least minimally
    understand the process.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简要概述了典型的内核开发工作流程。任何像您一样对内核开发感兴趣的人，至少应该对这个过程有基本的了解。
- en: A detailed description can be found within the kernel documentation here: [https://www.kernel.org/doc/html/latest/process/2.Process.html#how-the-development-process-works](https://www.kernel.org/doc/html/latest/process/2.Process.html#how-the-development-process-works).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在内核文档中找到详细描述：[https://www.kernel.org/doc/html/latest/process/2.Process.html#how-the-development-process-works](https://www.kernel.org/doc/html/latest/process/2.Process.html#how-the-development-process-works)。
- en: A common misconception, especially in its baby years, was that the Linux kernel
    is developed in a very ad hoc fashion. This is not true at all! The kernel development
    process has evolved to become a (mostly) well-oiled system with a thoroughly documented
    process and expectation of what a kernel contributor should know in order to use
    it well. I refer you to the preceding link for the complete details.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误解，尤其是在它的初期，是Linux内核是以一种非常临时的方式开发的。这一点完全不正确！内核开发过程已经发展成为一个（大部分）良好运转的系统，有着详细的文件化流程和对内核贡献者应该了解的期望。我建议您查看前面的链接以获取完整的详细信息。
- en: In order for us to take a peek into a typical development cycle, let's assume
    we have the latest mainline Linux Git kernel tree cloned on to our system.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们一窥典型的开发周期，让我们假设我们在系统上克隆了最新的主线Linux Git内核树。
- en: The details regarding the use of the powerful `git(1)` **Source Code Management**
    (**SCM**) tool is beyond the scope of this book. Please see the *Further reading *section
    for useful links on learning how to use Git. Obviously, I highly recommend gaining
    at least basic familiarity with using `git(1)`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 关于强大的`git(1)`**源代码管理**（**SCM**）工具的使用细节超出了本书的范围。请参阅*进一步阅读*部分，了解如何使用Git的有用链接。显然，我强烈建议至少基本了解如何使用`git(1)`。
- en: 'As mentioned earlier, as of the time of writing, **the 5.4 kernel** is the
    latest **Long-Term Stable** (**LTS**) version, so we shall use it in the materials
    that follow. So, how did it come to be? Obviously, it has evolved from the **release
    candidate** (**rc**) kernels and the previous stable kernel release that precedes
    it, which in this case would be the *v5.4-rc''n''* kernels and the stable *v5.3* one
    before it. We use the `git log` command as follows to get a human-readable log
    of the tags in the kernel Git tree ordered by date. Here, we are only interested
    in the work that has lead to the release of the 5.4 LTS kernel, hence we have
    deliberately truncated the following output to reveal only that portion:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，截至撰写本文时，**5.4内核**是最新的**长期稳定**（**LTS**）版本，因此我们将在接下来的材料中使用它。那么，它是如何产生的呢？显然，它是从**发布候选**（**rc**）内核和之前的稳定内核发布演变而来的，在这种情况下，是*v5.4-rc'n'*内核和之前的稳定*v5.3*。我们使用以下`git
    log`命令按日期顺序获取内核Git树中标签的可读日志。在这里，我们只对导致5.4 LTS内核发布的工作感兴趣，因此我们故意截断了以下输出，只显示了那部分内容：
- en: The `git log` command (that we use in the following code block, and in fact
    any other `git` sub-commands) will only work on a `git` tree. We use the following
    one purely for demonstrating the evolution of the kernel. A bit later, we will
    show how you can clone a Git tree.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`git log`命令（我们在下面的代码块中使用，实际上任何其他`git`子命令）只能在`git`树上工作。我们纯粹使用以下内容来演示内核的演变。稍后，我们将展示如何克隆Git树。'
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Aha! In the preceding code block, you can clearly see that the stable 5.4 kernel
    was released on 24 November 2019 and the 5.3 tree on 15 September 2019 (you can
    also verify this by looking up other useful kernel resources, such as [https://kernelnewbies.org/LinuxVersions](https://kernelnewbies.org/LinuxVersions)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！在前面的代码块中，您可以清楚地看到稳定的5.4内核于2019年11月24日发布，5.3树于2019年9月15日发布（您也可以通过查找其他有用的内核资源来验证，例如[https://kernelnewbies.org/LinuxVersions](https://kernelnewbies.org/LinuxVersions)）。
- en: For the development series that ultimately led to the 5.4 kernel, this latter
    date (15 September 2019) marks the start of what is called the **merge window **for
    the next stable kernel for a period of (approximately) two weeks. In this period,
    developers are allowed to submit new code to the kernel tree (in reality, the
    actual work would have been going on from a lot earlier; the fruit of this work
    is now merged into mainline at this time).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最终导致5.4内核的开发系列，后一个日期（2019年9月15日）标志着所谓的**合并窗口**的开始，为期（大约）两周的下一个稳定内核。在此期间，开发人员被允许向内核树提交新代码（实际上，实际工作早在很早之前就已经进行了；这项工作的成果现在已经在此时合并到主线）。
- en: Two weeks later (on 30 September 2019), the merge window was closed and the
    `rc` kernel work started, with `5.4-rc1` being the first of the `rc` versions,
    of course. The `-rc` (also known as prepatch) trees work primarily on merging
    patches and fixing (regression) bugs, ultimately leading to what is determined
    by the chief maintainers (Linus Torvalds and Andrew Morton) to be a "stable" kernel
    tree. The number of prepatches (`-rc` releases) varies. Typically, though, this
    "bugfix" window takes anywhere between 6 to 10 weeks, after which the new stable
    kernel is released. In the preceding code block, we can see that eight release
    candidate kernels finally resulted in the stable release of the v5.4 tree on 24
    November 2019 (taking a total of 70 days).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 两周后（2019年9月30日），合并窗口关闭，`rc`内核工作开始，`5.4-rc1`是`rc`版本的第一个版本，当然。`-rc`（也称为预补丁）树主要用于合并补丁和修复（回归）错误，最终导致由主要维护者（Linus
    Torvalds和Andrew Morton）确定为“稳定”的内核树。预补丁（`-rc`发布）的数量有所不同。通常，这个“错误修复”窗口需要6到10周的时间，之后新的稳定内核才会发布。在前面的代码块中，我们可以看到八个发布候选内核最终导致了2019年11月24日发布了v5.4树（共计70天）。
- en: 'The same can be seen more visually via the releases page at [https://github.com/torvalds/linux/releases](https://github.com/torvalds/linux/releases):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过[https://github.com/torvalds/linux/releases](https://github.com/torvalds/linux/releases)页面更直观地看到：
- en: '![](img/97f30cbb-0926-4115-850d-bc9c6a87679f.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/97f30cbb-0926-4115-850d-bc9c6a87679f.png)'
- en: Figure 2.1 – The releases leading up to the 5.4 LTS kernel (read it bottom-up)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 - 导致5.4 LTS内核的发布（自下而上阅读）
- en: 'The preceding screenshot is a partial screenshot showing how various *v5.4-rc''n''*
    release candidate kernels ultimately resulted in the release of the LTS 5.4 tree
    (on 25 November 2019, with *v5.4-rc8* being the last `rc` release). The work never
    really stops: by early December 2019, the *v5.5-rc1* release candidate went out.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图是部分截图，显示了各种*v5.4-rc'n'*发布候选内核最终导致了LTS 5.4树的发布（2019年11月25日，*v5.4-rc8*是最后一个`rc`发布）。工作从未真正停止：到2019年12月初，*v5.5-rc1*发布候选版本已经发布。
- en: 'Generically, taking the 5.x kernel series as an example (the same holds true
    for any other recent `major` kernel series), the kernel development workflow is
    as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，以5.x内核系列为例（对于任何其他最近的`major`内核系列也是如此），内核开发工作流程如下：
- en: The 5.x stable release is made. Thus, the merge window for the 5.x+1 (mainline) kernel
    has begun.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5.x稳定版本已经发布。因此，5.x+1（主线）内核的合并窗口已经开始。
- en: The merge window remains open for about 2 weeks and new patches are merged into
    the mainline.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并窗口保持开放约2周，新的补丁被合并到主线。
- en: Once (typically) 2 weeks have elapsed, the merge window is closed.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦（通常）过去了2周，合并窗口就会关闭。
- en: '`rc` (aka mainline, prepatch) kernels start. *5.x+1-rc1, 5.x+1-rc2, ..., 5.x+1-rcn*
    are released. This process takes anywhere between 6 to 8 weeks.'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rc`（也称为主线，预补丁）内核开始。*5.x+1-rc1, 5.x+1-rc2, ..., 5.x+1-rcn*被发布。这个过程需要6到8周的时间。'
- en: 'The stable release has arrived: the new *5.x+1* stable kernel is released.'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稳定版本已经发布：新的*5.x+1*稳定内核已经发布。
- en: 'The release is handed off to the "stable team":'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布被移交给“稳定团队”：
- en: Significant bug or security fixes result in the release of *5.x+1.y :*
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重大的错误或安全修复导致了*5.x+1.y*的发布：
- en: '*5.x+1.1, 5**.x+1.2, ... , 5.x+1.n*.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*5.x+1.1, 5**.x+1.2, ... , 5.x+1.n*。'
- en: Maintained until the next stable release or **End Of Life** (**EOL**) date reached
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护直到下一个稳定发布或**生命周期结束**（EOL）日期到达
- en: '...and the whole process repeats.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '...整个过程重复。'
- en: So, when you now see Linux kernel releases, the names and the process involved
    will make sense. Let's now move on to looking at the different types of kernel
    source trees out there.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当您看到Linux内核发布时，名称和涉及的过程将变得合乎情理。现在让我们继续看看不同类型的内核源树。
- en: Types of kernel source trees
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核源树的类型
- en: There are several types of Linux kernel source trees. The key one is the **Long
    Term Support** (**LTS**) kernel. Okay, so what exactly is an LTS release kernel?
    It’s simply a "special" release in the sense that the kernel maintainers will
    continue to backport important bug and security fixes upon it (well, security
    issues are typically nothing but bugs), until a given EOL date.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种类型的Linux内核源树。关键的是**长期支持**（LTS）内核。好吧，LTS发布内核到底是什么？它只是一个“特殊”的发布，内核维护者将继续在其上进行重要的错误和安全修复的后移（嗯，安全问题通常只是错误），直到给定的EOL日期。
- en: The "life" of an LTS kernel will usually be a minimum of 2 years, and it can
    go for several more (it's extended at times). The **5.4 LTS kernel** that we will
    use throughout this book is the 20^(th) LTS kernel and has **a lifespan of just
    over 6 years – from November 2019 to December 2025**.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: LTS内核的“寿命”通常至少为2年，它可以延长多年（有时会延长）。我们将在本书中使用的**5.4 LTS内核**是第20个LTS内核，其**寿命超过6年-从2019年11月到2025年12月**。
- en: 'There are several types of release kernels in the repository. However, here,
    we mention an incomplete list, ordered from least to most stable (thus, their
    life, from shortest to longest time span):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库中有几种类型的发布内核。然而，在这里，我们提到一个不完整的列表，按稳定性从低到高排序（因此，它们的生命周期从最短到最长）：
- en: '**-next trees**: This is indeed the bleeding edge, subsystem trees with new
    patches collected here for testing and review. This is what an upstream kernel
    contributor will work on.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**-next树**：这确实是最前沿的，子系统树中收集了新的补丁进行测试和审查。这是上游内核贡献者将要处理的内容。'
- en: '**Prepatches, also known as -rc or mainline**: These are release candidate
    kernels that get generated prior to a release.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预补丁，也称为-rc或主线**：这些是在发布之前生成的候选版本内核。'
- en: '**Stable kernels**: As the name implies, this is the business end. These kernels
    are typically picked up by distributions and other projects (at least to begin
    with). They are also known as vanilla kernels.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳定内核**：顾名思义，这是业务端。这些内核通常会被发行版和其他项目采用（至少起初是这样）。它们也被称为原始内核。'
- en: '**Distribution and LTS kernels**: Distribution kernels are (obviously) the
    kernels provided by the distributions. They typically begin with a base vanilla/stable
    kernel. LTS kernels are the specially maintained-for-a-longer-while kernels, making
    them especially useful for industry/production projects and products.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发行版和LTS内核**：发行版内核（显然）是发行版提供的内核。它们通常以基本的原始/稳定内核开始。LTS内核是专门维护更长时间的内核，使它们特别适用于行业/生产项目和产品。'
- en: In this book, we will work throughout on the latest LTS kernel as of the time
    of writing, which is the 5.4 LTS kernel. As I mentioned in [Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml), *Kernel
    Workspace Setup*, the 5.4 LTS kernel was initially slated to have an EOL of "at
    least December 2021." Recently (June 2020), it's now been pushed **to** **December
    2025**, keeping this book's content current and valid for years to come!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将一直使用撰写时的最新LTS内核，即5.4 LTS内核。正如我在[第1章](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml)中提到的，*内核工作区设置*，5.4
    LTS内核最初计划的EOL是“至少2021年12月”。最近（2020年6月），它现在被推迟到**2025年12月**，使本书的内容在未来几年仍然有效！
- en: '**Super LTS (SLTS) kernels**: Even longer maintained LTS kernels (by the *Civil
    Infrastructure Platform* ([https://www.cip-project.org/](https://www.cip-project.org/)),
    a Linux Foundation project).'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超长期支持（SLTS）内核**：更长时间维护的LTS内核（由*民用基础设施平台*（[https://www.cip-project.org/](https://www.cip-project.org/)）提供支持，这是一个Linux基金会项目）。'
- en: It's quite intuitive. Nevertheless, I refer you to kernel.org's Releases page to
    obtain details on the type of release kernels: [https://www.kernel.org/releases.html](https://www.kernel.org/releases.html).
    Again, for even more detail, visit *How the development process works* ([https://www.kernel.org/doc/html/latest/process/2.Process.html#how-the-development-process-works](https://www.kernel.org/doc/html/latest/process/2.Process.html#how-the-development-process-works)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当直观的。尽管如此，我建议您访问kernel.org的Releases页面获取有关发布内核类型的详细信息：[https://www.kernel.org/releases.html](https://www.kernel.org/releases.html)。同样，要获取更多详细信息，请访问*开发过程如何工作*（[https://www.kernel.org/doc/html/latest/process/2.Process.html#how-the-development-process-works](https://www.kernel.org/doc/html/latest/process/2.Process.html#how-the-development-process-works)）。
- en: As an interesting aside, certain LTS kernels are very long-term releases, the
    aptly named **SLTS** or **Super LTS** kernels. As an example, the 4.4 Linux kernel
    (the 16^(th) LTS release) is considered to be an SLTS kernel. As the first kernel
    selected for SLTS, the Civil Infrastructure Platform will provide support until
    at least 2026, possibly until 2036.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，某些LTS内核是非常长期的发布，称为**SLTS**或**超长期支持**内核。例如，4.4 Linux内核（第16个LTS发布）被认为是一个SLTS内核。作为SLTS选择的第一个内核，民用基础设施平台将提供支持至少到2026年，可能一直到2036年。
- en: 'Querying the repository, `www.kernel.org`, in a non-interactive scriptable
    fashion can be done using `curl(1)` (the following output is the state of Linux
    as of 05 January 2021):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以非交互式可脚本化的方式查询存储库`www.kernel.org`可以使用`curl(1)`（以下输出是截至2021年1月5日的Linux状态）：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Of course, by the time you read this, it's extremely likely (certain, in fact)
    that the kernel has evolved further and later versions show up. For a book such
    as this one, the best I could do is pick the latest LTS kernel at the time of
    writing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当您阅读本书时，内核极有可能（事实上是肯定的）已经进化，并且稍后的版本会出现。对于这样一本书，我能做的就是选择撰写时的最新LTS内核。
- en: Of course, it's happened already! The 5.10 kernel was released on 13 December
    2020 and, as of the time of writing (just before going to print), the work on
    the 5.11 kernel is in progress...
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这已经发生了！5.10内核于2020年12月13日发布，截至撰写时（即将印刷之前），5.11内核的工作正在进行中……
- en: Finally, yet another safe way to download a given kernel is provided by the
    kernel maintainers who offer a script to safely download a given Linux kernel
    source tree, verifying its PGP signature. The script is available here: [https://git.kernel.org/pub/scm/linux/kernel/git/mricon/korg-helpers.git/tree/get-verified-tarball](https://git.kernel.org/pub/scm/linux/kernel/git/mricon/korg-helpers.git/tree/get-verified-tarball).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，另一种安全下载给定内核的方法是由内核维护者提供的，他们提供了一个脚本来安全地下载给定的Linux内核源树，并验证其PGP签名。该脚本在这里可用：[https://git.kernel.org/pub/scm/linux/kernel/git/mricon/korg-helpers.git/tree/get-verified-tarball](https://git.kernel.org/pub/scm/linux/kernel/git/mricon/korg-helpers.git/tree/get-verified-tarball)。
- en: Right, now that we're armed with the knowledge on kernel version nomenclature
    and types of kernel source trees, it's time to begin our journey of building our
    kernel.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们已经掌握了内核版本命名规则和内核源树类型的知识，是时候开始我们构建内核的旅程了。
- en: Steps to build the kernel from source
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从源码构建内核的步骤
- en: 'As a convenient and quick reference, the following are the key steps required
    to build a Linux kernel from source. As the explanation for each of them is pretty
    detailed, you can refer back to this summary to see the bigger picture. The steps
    are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个方便和快速的参考，以下是构建Linux内核源码所需的关键步骤。由于每个步骤的解释都非常详细，您可以参考这个摘要来了解整体情况。步骤如下：
- en: 'Obtain a Linux kernel source tree through either of the following options:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下选项之一获取Linux内核源树：
- en: Downloading a specific kernel source as a compressed file
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载特定内核源作为压缩文件
- en: Cloning a (kernel) Git tree
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆（内核）Git树
- en: Extract the kernel source tree into some location in your home directory (skip
    this step if you obtained a kernel by cloning a Git tree).
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将内核源树提取到家目录中的某个位置（如果您通过克隆Git树获得内核，则跳过此步骤）。
- en: 'Configuration: Select the kernel support options as required for the new kernel,'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置：根据新内核的需要选择内核支持选项，
- en: '`make [x|g|menu]config`, with `make menuconfig` being the preferred way.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`make [x|g|menu]config`，其中`make menuconfig`是首选方式。'
- en: Build the kernel's loadable modules and any **Device Tree Blobs** (**DTBs**)
    with `make [-j'n'] all`. This builds the compressed kernel image (`arch/<arch>/boot/[b|z|u]image`),
    the uncompressed kernel image (`vmlinux`), `System.map`, the kernel module objects,
    and any configured DTB(s) files.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`make [-j'n'] all`构建内核的可加载模块和任何**设备树块**（**DTB**）。这将构建压缩的内核映像（`arch/<arch>/boot/[b|z|u]image`）、未压缩的内核映像（`vmlinux`）、`System.map`、内核模块对象和任何已配置的DTB(s)文件。
- en: Install the just-built kernel modules with `sudo make modules_install`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sudo make modules_install`安装刚构建的内核模块。
- en: This step installs kernel modules by default under `/lib/modules/$(uname -r)/`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤默认将内核模块安装在`/lib/modules/$(uname -r)/`下。
- en: 'Set up the GRUB bootloader and the `initramfs` (earlier called `initrd`) image
    (x86-specific):'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置GRUB引导加载程序和`initramfs`（之前称为`initrd`）映像（特定于x86）：
- en: '`sudo make install`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo make install`：'
- en: This creates and installs the `initramfs` (or `initrd`) image under `/boot`.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将在`/boot`下创建并安装`initramfs`（或`initrd`）映像。
- en: It updates the bootloader configuration file to boot the new kernel (first entry).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它更新引导加载程序配置文件以启动新内核（第一个条目）。
- en: Customize the GRUB bootloader menu (optional).
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义GRUB引导加载程序菜单（可选）。
- en: This chapter, being the first of two on this topic, will essentially cover *steps
    1 to 3*, with a lot of required background material thrown in as well. The next
    chapter will cover the remaining steps, *4 to 7*. So, let's begin with *step 1*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于这个主题的两章中的第一章，基本上涵盖了*步骤1到3*，还包括了许多必需的背景材料。下一章将涵盖剩下的步骤，*4到7*。所以，让我们从*第1步*开始。
- en: Step 1 – obtaining a Linux kernel source tree
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1步——获取Linux内核源树
- en: 'In this section, we will see two broad ways in which you can obtain a Linux
    kernel source tree:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看到两种获取Linux内核源树的广泛方法：
- en: By downloading and extracting a specific kernel source tree from the Linux kernel
    public repository ([https://www.kernel.org](https://www.kernel.org))
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从Linux内核公共存储库（[https://www.kernel.org](https://www.kernel.org)）下载和提取特定的内核源树
- en: By cloning Linus Torvalds' source tree (or others') – for example, the `linux-next` Git
    tree
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过克隆Linus Torvalds的源树（或其他人的）——例如，`linux-next` Git树
- en: But how do you decide which approach to use? For the majority of developers
    like you working on a project or product, the decision has already been made –
    the project uses a very specific Linux kernel version. You will thus download
    that particular kernel source tree, quite possibly apply project-specific patches
    to it if required, and use it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你如何决定使用哪种方法？对于像您这样在项目或产品上工作的大多数开发人员来说，决定已经做出了——项目使用一个非常特定的Linux内核版本。因此，您将下载该特定的内核源树，如果需要，可能会对其应用特定于项目的补丁，并使用它。
- en: For folks whose intention is to contribute or "upstream" code to the mainline
    kernel, the second approach – cloning the Git tree – is the way to go for you.
    (Of course, there's more to it; we described some details in the *Types of kernel
    source trees* section)*.*
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些打算向主线内核贡献或"上游"代码的人来说，第二种方法——克隆Git树——是您应该选择的方式。（当然，这还有更多内容；我们在*内核源树类型*部分中描述了一些细节）。
- en: In the following section, we demonstrate both approaches. First, we describe
    the approach where a particular kernel source tree (not a Git tree) is downloaded
    from the kernel repository. We choose, as of the time of writing, the **latest
    LTS 5.4 Linux kernel** for this purpose. In the second approach, we clone a Git
    tree.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将演示这两种方法。首先，我们描述了一种从内核存储库下载特定内核源树（而不是Git树）的方法。我们选择了截至撰写时的**最新LTS
    5.4 Linux内核**来进行演示。在第二种方法中，我们克隆了一个Git树。
- en: Downloading a specific kernel tree
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载特定的内核树
- en: 'Firstly, where is the kernel source code? The short answer is that it''s on
    the public kernel repository server visible at [https://www.kernel.org](https://www.kernel.org).
    The home page of this site displays the latest stable Linux kernel version, as
    well as the latest `longterm` and `linux-next` releases (the following screenshot
    shows the site as of 29 November 2019\. It shows dates in the well-known `yyyy-mm-dd`format):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，内核源代码在哪里？简短的答案是它在[https://www.kernel.org](https://www.kernel.org)上可见的公共内核存储库服务器上。该站点的主页显示了最新的稳定Linux内核版本，以及最新的`longterm`和`linux-next`发布（下面的截图显示了2019年11月29日的站点。它显示了以众所周知的`yyyy-mm-dd`格式的日期）：
- en: '![](img/7e90a555-0632-4d57-8d2a-a0184ec36212.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e90a555-0632-4d57-8d2a-a0184ec36212.png)'
- en: Figure 2.2 – The kernel.org site (as of 29 November 2019)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 - kernel.org网站（截至2019年11月29日）
- en: 'A quick reminder: we also provide a PDF file that has the full-color images
    of the screenshots/diagrams used in this book. You can download it here: [https://static.packt-cdn.com/downloads/9781789953435_ColorImages.pdf](_ColorImages.pdf).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 快速提醒：我们还提供了一个PDF文件，其中包含本书中使用的截图/图表的全彩图像。您可以在这里下载：[https://static.packt-cdn.com/downloads/9781789953435_ColorImages.pdf](_ColorImages.pdf)。
- en: 'There are many ways to download a (compressed) kernel source file. Let''s look
    at two of them:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多种方法可以下载（压缩的）内核源文件。让我们看看其中的两种：
- en: An interactive, and perhaps simplest way, is to visit the preceding website
    and simply click on the appropriate `tarball` link. The browser will download
    the image file (in `.tar.xz` format) to your system.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个交互式，也许是最简单的方法，是访问上述网站，然后简单地点击适当的`tarball`链接。浏览器将会下载图像文件（以`.tar.xz`格式）到您的系统。
- en: 'Alternatively, you can download it from the command line (a shell or the CLI)
    using the `wget(1)` utility (we can also use the powerful `curl(1)` utility to
    do so). For example, to download the stable 5.4.0 kernel source compressed file,
    we can do the following:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，您可以使用`wget(1)`实用程序（我们也可以使用强大的`curl(1)`实用程序来做到这一点）从命令行（shell或CLI）下载它。例如，要下载稳定的5.4.0内核源代码压缩文件，我们可以这样做：
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the preceding `wget(1)` utility doesn't work, it's likely because the kernel
    (compressed) `tarball` link changed. For example, if it didn't work for `5.4.0.tar.xz`,
    try the same `wget` utility but change the version to `5.4.1.tar.xz`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的`wget(1)`实用程序不起作用，很可能是因为内核（压缩的）`tarball`链接发生了变化。例如，如果对于`5.4.0.tar.xz`不起作用，尝试相同的`wget`实用程序，但将版本更改为`5.4.1.tar.xz`。
- en: 'This will securely download the 5.4.0 compressed kernel source tree to your
    computer''s `~/Downloads` folder. Of course, you may not want the versions of
    the kernel that are displayed on the repository''s home page. For example, what
    if, for my particular project, I require the latest 4.19 stable (LTS) kernel,
    the 19^(th) LTS release? Simple: via the browser, just click on the [https://www.kernel.org/pub/](https://www.kernel.org/pub/)
    (or the mirror [https://mirrors.edge.kernel.org/pub/](https://mirrors.edge.kernel.org/pub/))
    link (immediately to the right of the "HTTP" link shown in the first few lines)
    and navigate to the `linux/kernel/v4.x/` directory on the server (you might be
    directed to a mirror site). Or, simply point `wget(1)` at the URL (here, as of
    the time of writing, it happens to be [https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.19.164.tar.xz](https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.19.164.tar.xz)).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安全地下载5.4.0压缩的内核源树到您计算机的`~/Downloads`文件夹中。当然，您可能不希望在存储库的主页上显示的内核版本。例如，如果对于我的特定项目，我需要最新的4.19稳定（LTS）内核，第19个LTS版本，怎么办？简单：通过浏览器，只需点击[https://www.kernel.org/pub/](https://www.kernel.org/pub/)（或镜像[https://mirrors.edge.kernel.org/pub/](https://mirrors.edge.kernel.org/pub/)）链接（在前几行显示的“HTTP”链接右侧）并导航到服务器上的`linux/kernel/v4.x/`目录（您可能会被引导到一个镜像站点）。或者，只需将`wget(1)`指向URL（在撰写时，这里碰巧是[https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.19.164.tar.xz](https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.19.164.tar.xz)）。
- en: Cloning a Git tree
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克隆Git树
- en: For a developer like you working on and looking to contribute code upstream,
    you *must *work on the very latest version of the Linux kernel code base. Well,
    there are fine gradations of the latest version within the kernel community. As
    mentioned earlier, the `linux-next` tree, and some specific branch or tag within
    it, is the one to work on for this purpose.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像您这样的开发人员，正在研究并寻求向上游贡献代码，您*必须*在Linux内核代码库的最新版本上工作。嗯，内核社区内有最新版本的微妙变化。如前所述，`linux-next`树以及其中的某个特定分支或标签，是为此目的而工作的树。
- en: In this book, though, we do not intend to delve into the gory details of setting
    up a `linux-next` tree. This process is already very well documented and we would
    prefer not to merely repeat instructions (see the *Further reading *section for
    detailed links). The detailed page on how exactly you should clone a `linux-next`
    tree is here: *Working with linux-next, *[https://www.kernel.org/doc/man-pages/linux-next.html](https://www.kernel.org/doc/man-pages/linux-next.html),
    and, as mentioned there, the *linux-next tree*, [http://git.kernel.org/cgit/linux/kernel/git/next/linux-next.git](http://git.kernel.org/cgit/linux/kernel/git/next/linux-next.git),
    is the holding area for patches aimed at the next kernel merge window. If you're
    doing bleeding-edge kernel development, you may want to work from that tree rather
    than Linus Torvalds' mainline tree.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们并不打算深入探讨建立`linux-next`树的血腥细节。这个过程已经有非常好的文档记录，我们更愿意不仅仅重复指令（详细链接请参见*进一步阅读*部分）。关于如何克隆`linux-next`树的详细页面在这里：*使用linux-next*，[https://www.kernel.org/doc/man-pages/linux-next.html](https://www.kernel.org/doc/man-pages/linux-next.html)，正如在那里提到的，*linux-next*树*，[http://git.kernel.org/cgit/linux/kernel/git/next/linux-next.git](http://git.kernel.org/cgit/linux/kernel/git/next/linux-next.git)，是用于下一个内核合并窗口的补丁的存储区。如果你正在进行最前沿的内核开发，你可能希望从那个树上工作，而不是Linus
    Torvalds的主线树。
- en: 'For our purposes, cloning the *mainline *Linux Git repository (Torvalds'' Git
    tree) is more than sufficient. Do so like this (type this on one line):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，克隆*mainline*Linux Git存储库（Torvalds的Git树）已经足够了。像这样做（在一行上输入）：
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that cloning a complete Linux kernel tree is a time-, network-, and disk-consuming
    operation! Ensure you have sufficient disk space free (at least a few gigabytes
    worth).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，克隆完整的Linux内核树是一个耗时、耗网络和耗磁盘的操作！确保您有足够的磁盘空间可用（至少几个GB）。
- en: 'Performing `git clone --depth n <...>`, where `n` is an integer value, is very
    useful to limit the depth of history (commits) and thus keep the download/disk
    usage low(er). As the `man` page on `git-clone(1)` mentions for the `--depth` option:
    "Create a shallow clone with a history truncated to a specified number of commits."'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`git clone --depth n <...>`，其中`n`是一个整数值，非常有用，可以限制历史记录（提交）的深度，从而降低下载/磁盘使用量。正如`git-clone(1)`的`man`页面中提到的`--depth`选项：“创建一个浅克隆，其历史记录被截断为指定数量的提交。”
- en: As per the preceding tip, why not do the following (again, type this on one
    line)?
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的提示，为什么不执行以下操作（再次在一行上输入）？
- en: '[PRE6]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you intend to work on this mainline Git tree, please skip the *Step* 2 –
    *extracting the kernel source tree *section (as the `git clone` operation will,
    in any case, extract the source tree) and continue with the section that follows
    it (*Step 3 – configuring the Linux kernel)*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算在这个主线Git树上工作，请跳过*步骤*2 - *提取内核源树*部分（因为`git clone`操作将在任何情况下提取源树），并继续进行下一部分（*步骤3
    - 配置Linux内核*）。
- en: Step 2 – extracting the kernel source tree
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤2 - 提取内核源树
- en: As mentioned earlier, this section is meant for those of you who have downloaded
    a particular Linux kernel from the repository, [https://www.kernel.org](https://www.kernel.org)*, *and
    aim to build it. In this book, we use the 5.4 LTS kernel release. On the other
    hand, if you have performed `git clone` on the mainline Linux Git tree, as shown
    in the immediately preceding section, you can safely skip this section and move
    on to the next one on kernel configuration.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，本节适用于那些从存储库[https://www.kernel.org](https://www.kernel.org)下载了特定的Linux内核并打算构建它的人。在本书中，我们使用5.4
    LTS内核版本。另一方面，如果您已经在主线Linux Git树上执行了`git clone`，就像在前面的部分中所示的那样，您可以安全地跳过本节，继续进行下一节内核配置。
- en: Now that the download is done, let's proceed further. The next step is to extract
    the kernel source tree – remember, it's a tar-ed and compressed (typically `.tar.xz`)
    file.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在下载已经完成，让我们继续。下一步是提取内核源树 - 记住，它是一个经过tar和压缩的（通常是`.tar.xz`）文件。
- en: 'We assume that, as shown in detail earlier in this chapter, you have by now
    downloaded the Linux kernel version 5.4 code base as a compressed file (into the
    `~/Downloads` directory):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设，如本章前面详细介绍的那样，您现在已经将Linux内核版本5.4代码库下载为一个压缩文件（放入`~/Downloads`目录）：
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The simple way to extract this file is by using the ubiquitous `tar(1)` utility
    to do so:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 提取这个文件的简单方法是使用无处不在的`tar(1)`实用程序来完成：
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will extract the kernel source tree into a directory named `linux-5.4`
    within the `~/Downloads` directory. But what if we would like to extract it into
    another folder, say `~/kernels`? Then, do it like so:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把内核源树提取到`~/Downloads`目录中名为`linux-5.4`的目录中。但是，如果我们想要将其提取到另一个文件夹，比如`~/kernels`中，那么可以这样做：
- en: '[PRE9]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will extract the kernel source into the `~/kernels/linux-5.4/` folder.
    As a convenience, and good practice, let''s set up an *environment variable* to
    point to the location of the root of our kernel source tree:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把内核源提取到`~/kernels/linux-5.4/`文件夹中。为了方便起见，也是一个良好的做法，让我们设置一个*环境变量*，指向我们内核源树根目录的位置：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that, going forward, we will assume that this variable holds the location
    of the kernel source tree.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从现在开始，我们将假设这个变量保存着内核源树的位置。
- en: While you could always use a GUI file manager application (such as `Nautilus(1)`)
    to extract the compressed file, I strongly urge you to get familiar with using
    the Linux CLI to perform these operations.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以随时使用GUI文件管理器应用程序（如`Nautilus(1)`）来提取压缩文件，但我强烈建议您熟悉使用Linux CLI来执行这些操作。
- en: Don't forget `tldr(1)` when you need to quickly lookup the most frequently used
    options to common commands! For example, for `tar(1)`, simply use `tldr tar` to
    look it up.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要快速查找常用命令的最常用选项时，不要忘记`tldr(1)`！例如，对于`tar(1)`，只需使用`tldr tar`来查找。
- en: Did you notice? We extract the kernel source tree into *any* directory under
    our home directory (or even elsewhere), unlike in the old days when the tree was
    always extracted under a root-writeable location (often, `/usr/src/`). Nowadays,
    just say no (to that).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您注意到了吗？我们将内核源树提取到*任何*家目录下的任何目录中（甚至其他地方），不像以前那样总是提取到可写的根目录位置（通常是`/usr/src/`）。现在，只要说不（对于那个）。
- en: If all you wish to do now is proceed with the kernel build recipe, skip the
    following section and move along. If interested (we certainly hope so!), the next
    section is a brief but important deviation into looking at the structure and layout
    of the kernel source tree.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在只想继续进行内核构建操作，请跳过以下部分并继续。如果感兴趣（我们当然希望如此！），下一节是一个简短但重要的偏离，看一下内核源树的结构和布局。
- en: '**A brief tour of the kernel source tree**'
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**内核源树的简要介绍**'
- en: 'The kernel source code is now available on your system! Cool, let''s take a
    quick look at it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 内核源代码现在可以在您的系统上使用了！很酷，让我们快速看一下：
- en: '![](img/7495234c-06e5-47b3-93c8-e8a1e08e0a20.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7495234c-06e5-47b3-93c8-e8a1e08e0a20.png)'
- en: Figure 2.3 – The root of the 5.4 Linux kernel source tree
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 - 5.4 Linux内核源树的根目录
- en: Great! How big is it? A quick `du -m .` in the root of the kernel source tree
    reveals that this particular kernel source tree (recall, it's version 5.4) is
    a little over 1,000 MB in size – almost a gigabyte!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！它有多大？在内核源树的根目录中快速执行`du -m .`，可以看到这个特定的内核源树（记住，它是版本5.4）的大小略大于1,000 MB - 几乎是1
    GB！
- en: FYI, the Linux kernel has grown to be big and is getting bigger in terms of
    **Source ****Lines Of Code**(**SLOCs**). Current estimates are well over 20 million
    SLOCs. Of course, do realize that not *all* of this code will get compiled when
    building a kernel.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，Linux内核在**代码行数（SLOCs）**方面已经变得很大，并且正在变得越来越大。目前的估计是超过2000万行代码。当然，要意识到在构建内核时，并不是所有的代码都会被编译。
- en: 'How do we know which version exactly of the Linux kernel this code is by just
    looking at the source? That''s easy, one quick way is to just check out the first
    few lines of the project''s Makefile. Incidentally, the kernel uses Makefile''s
    all over the place; most directories have one. We will refer to this Makefile,
    the one at the root of the kernel source tree, as the *top-level Makefile*:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道这段代码是哪个版本的 Linux 内核呢？很简单，一个快速的方法就是查看项目的 Makefile 的前几行。顺便说一句，内核在很多地方都使用
    Makefile；大多数目录都有一个。我们将把这个 Makefile，也就是内核源代码树根目录下的 Makefile，称为*顶层 Makefile*：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Clearly, it's the source of the 5.4.0 kernel.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是 5.4.0 内核的源代码。
- en: 'Let''s get for ourselves a zoomed-out 10,000-foot view of the kernel source
    tree. The following table summarizes the broad categorization and purpose of the
    (more) important files and directories within the root of the Linux kernel source
    tree:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看内核源代码树的整体情况。以下表格总结了 Linux 内核源代码树根目录中（更）重要的文件和目录的广泛分类和目的：
- en: '| **File or directory name** | **Purpose** |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| **文件或目录名称** | **目的** |'
- en: '| **Top-level file****s** |  |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| **顶层文件** |  |'
- en: '| `README` | The project''s `README` file. It informs us as to where the kernel
    documentation is kept – spoiler, it''s in the directory called `Documentation`
    – and how to begin using it. The documentation is really important; it''s the
    authentic thing, written by the kernel developers themselves. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `README` | 项目的 `README` 文件。它告诉我们内核文档存放在哪里 - 提示，它在名为 `Documentation` 的目录中
    - 以及如何开始使用它。文档非常重要；它是由内核开发人员自己编写的真实内容。 |'
- en: '| `COPYING` | The license terms under which the kernel source is released.
    The vast majority are released under the well-known GNU GPL v2 (written as GPL-2.0)
    license [1]. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `COPYING` | 内核源代码发布的许可条款。绝大多数都是根据著名的 GNU GPL v2（写作 GPL-2.0）许可证发布的 [1]。 |'
- en: '| `MAINTAINERS` | *FAQ:* *something''s wrong in XYZ, who do I contact to get
    some support?* That is precisely what this file provides – the list of all kernel
    subsystems, indeed down to the level of individual components (such as a particular
    driver), its status, who is currently maintaining it, the mailing list, website,
    and so on. Very helpful! There''s even a helper script to find the person or team
    to talk to: `scripts/get_maintainer.pl` [2]. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `MAINTAINERS` | *常见问题：* *XYZ 出了问题，我应该联系谁获取支持？* 这正是这个文件提供的 - 所有内核子系统的列表，甚至到个别组件（如特定驱动程序）的级别，它的状态，当前维护者，邮件列表，网站等等。非常有帮助！甚至有一个辅助脚本可以找到需要联系的人或团队：`scripts/get_maintainer.pl`
    [2]。 |'
- en: '| Makefile | This is the kernel''s top-level Makefile; the `kbuild` kernel
    build system as well as kernel modules use this Makefile (at least initially)
    for the build. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| Makefile | 这是内核的顶层 Makefile；`kbuild` 内核构建系统以及内核模块最初使用这个 Makefile 进行构建。 |'
- en: '| **Major subsystem directories** |  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **主要子系统目录** |  |'
- en: '| `kernel/` | Core kernel subsystem: the code here deals with process/thread
    life cycle, CPU scheduling, locking, cgroups, timers, interrupts, signaling, modules,
    tracing, and more. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `kernel/` | 核心内核子系统：这里的代码涉及进程/线程生命周期，CPU 调度，锁定，cgroups，定时器，中断，信号，模块，跟踪等等。
    |'
- en: '| `mm/` | The bulk of the **memory management** (**mm**) code lives here. We
    will cover a little of this in [Chapter 6](e13fb379-a77f-4ba5-9de6-d6707b0214e6.xhtml),
    *Kernel Internals Essentials – Processes and Threads*, and some related coverage
    in [Chapter 7](06ee05b5-3e71-482d-93b8-235c27ce23bc.xhtml), *Memory Management
    Internals – Essentials*, and [Chapter 8](e78245d1-5a99-4b9e-a98c-cb16b15f3bee.xhtml),
    *Kernel Memory Allocation for Module Authors – Part 1*, as well. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `mm/` | 大部分**内存管理**（**mm**）代码都在这里。我们将在[第6章](e13fb379-a77f-4ba5-9de6-d6707b0214e6.xhtml)中涵盖一些内容，即*内核内部要点
    - 进程和线程*，以及在[第7章](06ee05b5-3e71-482d-93b8-235c27ce23bc.xhtml)中涵盖一些相关内容，即*内存管理内部要点*，以及在[第8章](e78245d1-5a99-4b9e-a98c-cb16b15f3bee.xhtml)中涵盖一些内容，即*模块作者的内核内存分配
    - 第1部分*。 |'
- en: '| `fs/` | The code here implements two key filesystem features: the abstraction
    layer – the kernel **Virtual Filesystem Switch** (**VFS**), and the individual
    filesystem drivers (for example, `ext[2&#124;4]`, `btrfs`, `nfs`, `ntfs`, `overlayfs`,
    `squashfs`, `jffs2`, `fat`, `f2fs`, and so on). |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `fs/` | 这里的代码实现了两个关键的文件系统功能：抽象层 - 内核**虚拟文件系统开关**（**VFS**），以及各个文件系统驱动程序（例如
    `ext[2|4]`，`btrfs`，`nfs`，`ntfs`，`overlayfs`，`squashfs`，`jffs2`，`fat`，`f2fs` 等）。
    |'
- en: '| `block/` | The underlying (to the VFS/FS) block I/O code path. It includes
    the code implementing the page cache, a generic block IO layer, IO schedulers,
    and so on. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `block/` | 底层（对于 VFS/FS）块 I/O 代码路径。它包括实现页面缓存、通用块 I/O 层、I/O 调度器等代码。 |'
- en: '| `net/` | Complete (to the letter of the **Request For Comments** (**RFCs**)—[https://whatis.techtarget.com/definition/Request-for-Comments-RFC](https://whatis.techtarget.com/definition/Request-for-Comments-RFC))
    implementation of the network protocol stack. Includes a high-quality implementation
    of TCP, UDP, IP, and many more networking protocols. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `net/` | 完整（按照**请求评论**（**RFC**）的要求 - [https://whatis.techtarget.com/definition/Request-for-Comments-RFC](https://whatis.techtarget.com/definition/Request-for-Comments-RFC)）实现了网络协议栈。包括高质量的
    TCP、UDP、IP 等许多网络协议的实现。 |'
- en: '| `ipc/` | The **Inter-Process Communication** (**IPC**) subsystem code; covers
    IPC mechanisms such as (both SysV and POSIX) message queues, shared memory, semaphores,
    and so on. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `ipc/` | **进程间通信**（**IPC**）子系统代码；涵盖 IPC 机制，如（SysV 和 POSIX）消息队列，共享内存，信号量等。
    |'
- en: '| `sound/` | The audio subsystem code, also known as**Advanced Linux Sound
    Architecture** (**ALSA**). |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `sound/` | 音频子系统代码，也称为**高级 Linux 音频架构**（**ALSA**）。 |'
- en: '| `virt/` | The *virtualization* (hypervisor) code; the popular and powerful **Kernel
    Virtual Machine** (**KVM**) is implemented here. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `virt/` | *虚拟化*（hypervisor）代码；流行且强大的**内核虚拟机**（**KVM**）就是在这里实现的。 |'
- en: '| **Infrastructure/misc** |  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| **基础设施/其他** |  |'
- en: '| `arch/` | The arch-specific code lives here (by the word arch, we mean CPU).
    Linux started as a small hobby project for the i386\. It is now probably the most
    ported OS (see the arch ports in *step 3* of the list that follows after this
    table). |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `arch/` | 这里存放着特定架构的代码（在这里，架构指的是 CPU）。Linux 最初是为 i386 架构的一个小型爱好项目。现在可能是最多移植的操作系统（请参见表后面的
    *步骤 3* 中的架构移植）。 |'
- en: '| `crypto/` | This directory contains the kernel-level implementation of ciphers
    (encryption/decryption algorithms, aka transformations) and kernel APIs to serve
    consumers that require cryptographic services. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `crypto/` | 此目录包含密码（加密/解密算法，也称为转换）的内核级实现和内核 API，以为需要加密服务的消费者提供服务。 |'
- en: '| `include/` | This directory contains the arch-independent kernel headers
    (there are also some arch-specific ones under `arch/<cpu>/include/...`).  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `include/` | 此目录包含与架构无关的内核头文件（还有一些特定架构的头文件在 `arch/<cpu>/include/...` 下）。
    |'
- en: '| `init/` | The arch-independent kernel initialization code; perhaps the closest
    we get to the kernel''s main function (remember, the kernel is not an application)
    is here: `init/main.c:start_kernel()`, with the `start_kernel()` function within
    it considered the early C entry point during kernel initialization. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `init/` | 与架构无关的内核初始化代码；也许我们能接近内核的主要功能（记住，内核不是一个应用程序）就在这里：`init/main.c:start_kernel()`，其中的
    `start_kernel()` 函数被认为是内核初始化期间的早期 C 入口点。 |'
- en: '| `lib/` | The closest equivalent to a library for the kernel. It''s important
    to understand that the kernel does *not* support shared libraries as userspace
    apps do. The code here is auto-linked into the kernel image file and hence available
    to the kernel at runtime (various useful components exist within `/lib`: [un]compression,
    checksum, bitmap, math, string routines, tree algos, and so on). |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `lib/` | 这是内核最接近库的等价物。重要的是要理解，内核不支持像用户空间应用程序那样的共享库。这里的代码会自动链接到内核映像文件中，因此在运行时对内核可用（`/lib`
    中存在各种有用的组件：[解]压缩、校验和、位图、数学、字符串例程、树算法等）。 |'
- en: '| `scripts/` | Various scripts are housed here, some of which are used during
    kernel build, many for other purposes (like static/dynamic analysis, and so on;
    mostly Bash and Perl). |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `scripts/` | 这里存放着各种脚本，其中一些用于内核构建，许多用于其他目的（如静态/动态分析等），主要是 Bash 和 Perl。 |'
- en: '| `security/` | Houses the kernel''s **Linux Security Module** (**LSM**), a
    **Mandatory Access Control** (**MAC**) framework that aims at imposing stricter
    access control of user apps to kernel space than the default kernel does (the
    default model is called **Discretionary Access Control** (**DAC**)). Currently,
    Linux supports several LSMs; well-known ones are SELinux, AppArmor, Smack, Tomoyo,
    Integrity, and Yama (note that LSMs are "off" by default). |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `security/` | 包含内核的 **Linux 安全模块**（**LSM**），这是一个旨在对用户应用程序对内核空间的访问控制施加更严格限制的
    **强制访问控制**（**MAC**）框架，比默认内核模型（称为 **自由访问控制**（**DAC**））更严格。目前，Linux 支持几种 LSM；其中一些知名的是
    SELinux、AppArmor、Smack、Tomoyo、Integrity 和 Yama（请注意，LSM 默认情况下是“关闭”的）。 |'
- en: '| `tools/` | Various tools are housed here, mostly userspace applications (or
    scripts) that have a "tight coupling" with the kernel (*perf*, the modern profiling
    tool, serves as an excellent example). |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `tools/` | 这里存放着各种工具，主要是与内核有“紧密耦合”的用户空间应用程序（或脚本），如现代性能分析工具 *perf* 就是一个很好的例子。
    |'
- en: Table 2.2 – Layout of the Linux kernel source tree
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2.2 – Linux 内核源代码树的布局
- en: 'The following are some important explanations from the table:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 表中以下是一些重要的解释：
- en: '**Kernel licensing**: Without getting stuck in the legal details, here''s the
    pragmatic essence of the thing: as the kernel is released under the GNU GPL-2.0
    license (**GNU GPL** is the **GNU General Public License**), any project that
    directly uses the kernel code base (even a tiny bit of it!), automatically falls
    under this license (the "derivative work" property of the GPL-2.0). These projects
    or products must release their kernels under the same license terms. Practically
    speaking, the situation on the ground is a good deal hazier; many commercial products
    that run on the Linux kernel do have  proprietary user- and/or kernel-space code
    within them. They typically do so by refactoring kernel (most often, device driver)
    work in **Loadable Kernel Module** (**LKM**) format. It is possible to release
    the kernel module (LKM) under a *dual license *model (for example, as dual BSD/GPL;
    the LKM is the subject matter of [Chapter 4](1c494ebd-e7ec-4a78-8695-5b97bdc3d6be.xhtml),
    *Writing your First Kernel Module – LKMs Part 1*, and [Chapter 5](408b6f9d-42dc-4c59-ab3d-1074d595f9e2.xhtml), *Writing
    your First Kernel Module – LKMs Part 2*, and we cover some information on the
    licensing of kernel modules there). Some folks, preferring proprietary licenses,
    manage to release their kernel code within a kernel module that is not licensed
    under GPL-2.0 terms; technically, this is perhaps possible, but is (at the very
    least) considered as being anti-social (and can even cross the line to being illegal).
    The interested among you can find more links on licensing in the *Further reading* document
    for this chapter.'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**内核许可证**：不要陷入法律细节，这里是事物的实质：由于内核是根据 GNU GPL-2.0 许可证发布的（**GNU GPL** 是 **GNU
    通用公共许可证**），任何直接使用内核代码库的项目（即使只有一点点！）都自动属于这个许可证（GPL-2.0 的“衍生作品”属性）。这些项目或产品必须按照相同的许可条款发布其内核。实际上，实际情况要复杂得多；许多在
    Linux 内核上运行的商业产品确实包含专有的用户空间和/或内核空间代码。它们通常通过重构内核（通常是设备驱动程序）工作为 **可加载内核模块**（**LKM**）格式来实现。可以以
    *双重许可* 模式发布内核模块（LKM）（例如，双重 BSD/GPL；LKM 是 [第 4 章](1c494ebd-e7ec-4a78-8695-5b97bdc3d6be.xhtml)
    和 [第 5 章](408b6f9d-42dc-4c59-ab3d-1074d595f9e2.xhtml) 的主题，我们在那里涵盖了一些关于内核模块许可的信息）。一些人更喜欢专有许可证，他们设法发布其内核代码，而不受
    GPL-2.0 条款的约束；从技术上讲，这可能是可能的，但（至少）被认为是反社会的（甚至可能违法）。感兴趣的人可以在本章的 *进一步阅读* 文档中找到更多关于许可证的链接。'
- en: '`MAINTAINERS`: An example of running the `get_maintainer.pl` Perl script (note:
    it is meant to run on a Git tree only):'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MAINTAINERS`：运行`get_maintainer.pl` Perl脚本的示例（注意：它只能在Git树上运行）：'
- en: '[PRE12]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Linux `arch` (CPU) ports:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Linux `arch`（CPU）端口：
- en: '[PRE13]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As a kernel or driver developer, browsing the kernel source tree is something
    you will have to get quite used to (and even enjoy!). Searching for a particular
    function or variable can be a daunting task when the code is in the ballpark of
    20 million SLOCs! Do use efficient code browser tools. I suggest the `ctags(1)`
    and `cscope(1)` **Free and Open Source Software** (**FOSS**) tools. In fact, the
    kernel''s top-level Makefile has targets for precisely these:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 作为内核或驱动程序开发人员，浏览内核源代码树是你必须要习惯（甚至喜欢！）的事情。当代码量接近2000万SLOC时，搜索特定函数或变量可能是一项艰巨的任务！要使用高效的代码浏览工具。我建议使用`ctags(1)`和`cscope(1)`这些**自由开源软件**（**FOSS**）工具。事实上，内核的顶层`Makefile`有针对这些工具的目标：
- en: '`make tags ; make cscope`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`make tags ; make cscope`'
- en: We have now completed *step 2*, the extraction of the kernel source tree! As
    a bonus, you also learned the basics regarding the layout of the kernel source.
    Let's now move on to *step 3* of the process and learn how to *configure *the
    Linux kernel prior to building it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了*步骤2*，提取内核源代码树！作为奖励，您还学会了有关内核源代码布局的基础知识。现在让我们继续进行*步骤3*的过程，并学习如何在构建之前*配置*Linux内核。
- en: Step 3 – configuring the Linux kernel
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3步-配置Linux内核
- en: Configuring the new kernel is perhaps *the* *most* critical step in the kernel
    build process. One of the many reasons Linux is a critically acclaimed OS is its
    versatility. It's a common misconception to think that there is a separate Linux
    kernel code base for an (enterprise-class) server, a data center, a workstation,
    and a tiny embedded Linux device – no, *they all use the very same unified Linux
    kernel source!* Thus, carefully *configuring* the kernel for a particular use
    case (server, desktop, embedded, or hybrid/custom) is a powerful feature and a
    requirement. This is precisely what we are delving into here.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 配置新内核可能是内核构建过程中*最*关键的一步。Linux备受好评的原因之一是其多功能性。普遍的误解是认为（企业级）服务器、数据中心、工作站和微型嵌入式Linux设备有各自独立的Linux内核代码库-不，*它们都使用同一个统一的Linux内核源代码！*因此，仔细*配置*内核以满足特定用例（服务器、桌面、嵌入式或混合/自定义）是一个强大的功能和要求。这正是我们在这里深入研究的内容。
- en: Do carry out this kernel configuration step regardless. Even if you feel you
    do not require any changes to the existing (or default) config, it's very important
    to run this step at least once as part of the build process. Otherwise, certain
    headers that are auto-generated here will be missing and cause issues. At the
    very least, `make oldconfig` should be carried out. This will set up the kernel
    config to that of the existing system with config options being requested from
    the user only for any new options.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何都要执行内核配置步骤。即使您觉得不需要对现有（或默认）配置进行任何更改，至少在构建过程的一部分中运行此步骤非常重要。否则，这里自动生成的某些标头将丢失并引起问题。至少应执行`make
    oldconfig`。这将将内核配置设置为现有系统的配置，用户仅对任何新选项进行请求。
- en: First though, let's cover some required background on the **kernel build** (**kbuild**)
    system.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解一下**内核构建**（**kbuild**）系统的一些必要背景。
- en: Understanding the kbuild build system
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解kbuild构建系统
- en: 'The infrastructure that the Linux kernel uses to configure and build the kernel
    is known as the **kbuild** system. Without delving into the gory details, the
    kbuild system ties together the complex kernel configuration and build process
    via four key components:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核用于配置和构建内核的基础设施被称为**kbuild**系统。不深入了解复杂的细节，kbuild系统通过四个关键组件将复杂的内核配置和构建过程联系在一起：
- en: The `CONFIG_FOO` symbols
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG_FOO`符号'
- en: The menu specification file(s), called `Kconfig`
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单规范文件，称为`Kconfig`
- en: The Makefile(s)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Makefile(s)
- en: The overall kernel config file itself
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总体内核配置文件
- en: 'The purpose of these components is summarized as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件的目的总结如下：
- en: '| **Kbuild component** | **Purpose in brief** |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **Kbuild组件** | **简要目的** |'
- en: '| Config symbol: `CONFIG_FOO` | Every kernel configurable `FOO` is represented
    by a `CONFIG_FOO` macro. Depending on the user''s choice, the macro will resolve
    to one of `y`, `m`, or `n`:- `y=yes`: Implying to build the feature into the kernel
    image itself - `m=module`: Implying to build it as a separate object, a kernel
    module- `n=no`: Implying not to build the featureNote that `CONFIG_FOO` is an
    alphanumeric string (as we will soon see, you can look up the precise config option
    name by using the `make menuconfig` option, navigating to a config option, and
    selecting the `< Help >` button). |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 配置符号：`CONFIG_FOO` | 每个内核可配置的`FOO`都由`CONFIG_FOO`宏表示。根据用户的选择，该宏将解析为`y`、`m`或`n`中的一个：-
    `y=yes`：表示将该功能构建到内核映像本身中- `m=module`：表示将其构建为一个独立对象，即内核模块- `n=no`：表示不构建该功能请注意，`CONFIG_FOO`是一个字母数字字符串（很快我们将看到，您可以使用`make
    menuconfig`选项查找精确的配置选项名称，导航到配置选项，并选择`<帮助>`按钮）。'
- en: '| `Kconfig` files | This is where the `CONFIG_FOO` symbol is defined. The kbuild
    syntax specifies its type (Boolean, tristate, [alpha]numeric, and so on) and dependency
    tree. Furthermore, for the menu-based config UI (invoked via one of `make [menu&#124;g&#124;x]config`),
    it specifies the menu entries themselves. We will, of course, make use of this
    feature later. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `Kconfig`文件 | 这是`CONFIG_FOO`符号定义的地方。kbuild语法指定了它的类型（布尔值、三态值、[alpha]数字等）和依赖树。此外，对于基于菜单的配置UI（通过`make
    [menu&#124;g&#124;x]config`之一调用），它指定了菜单条目本身。当然，我们稍后将使用此功能。'
- en: '| Makefile(s) | The kbuild system uses a *recursive* Makefile approach. The
    Makefile under the kernel source tree root folder is called the *top-level* Makefile,
    with a Makefile within each sub-folder to build the source there. The 5.4 vanilla
    kernel source has over 2,500 Makefiles in all! |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| Makefile(s) | kbuild系统使用*递归*Makefile方法。内核源代码树根文件夹下的Makefile称为*顶层*Makefile，在每个子文件夹中都有一个Makefile来构建那里的源代码。5.4原始内核源代码中总共有2500多个Makefile！'
- en: '| The `.config` file | Ultimately, the essence of it – the actual kernel configuration
    – is generated and stored within the kernel source tree root folder in an ASCII
    text file called `.config`. Keep this file safe, it''s a key part of your product.
    |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `.config`文件 | 最终，它的本质-实际的内核配置-以ASCII文本文件的形式生成并存储在内核源树根目录中的`.config`文件中。请保管好这个文件，它是产品的关键部分。|'
- en: Table 2.3 – Major components of the Kbuild build system
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.3 - Kbuild构建系统的主要组件
- en: The key thing is to get ourselves a working `.config` file. How can we do so?
    We do this iteratively. We begin with a "default" configuration – the topic of
    the following section – and carefully work our way up to a custom config as required.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是获得一个可用的`.config`文件。我们如何做到这一点？我们进行迭代。我们从“默认”配置开始-下一节的主题-并根据需要仔细地进行自定义配置。
- en: Arriving at a default configuration
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 到达默认配置
- en: 'So, how do you decide the initial kernel configuration to begin with? Several
    techniques exist; a few common ones are as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您如何决定初始内核配置从哪里开始？存在几种技术；一些常见的技术如下：
- en: Don't specify anything; the kbuild system will pull in a default kernel configuration.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不指定任何内容；kbuild系统将引入默认内核配置。
- en: Use the existing distribution's kernel configuration.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现有发行版的内核配置。
- en: Build a custom configuration based on the kernel modules currently loaded in
    memory.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于当前加载在内存中的内核模块构建自定义配置。
- en: The first approach has the benefit of simplicity. The kernel will handle the
    details, giving you a default configuration. The downside is that the default
    config is really pretty large (here, we mean with reference to building Linux
    for an x86-based desktop or server-type system) – a huge number of options are
    turned on, just in case, which can make the build time very long and kernel image
    size very large. Of course, you are then expected to manually configure the kernel
    to the desired settings.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法的好处是简单性。内核将处理细节，为您提供默认配置。缺点是默认配置实际上相当大（在这里，我们指的是构建面向x86桌面或服务器类型系统的Linux）-大量选项被打开，以防万一，这可能会使构建时间非常长，内核映像大小非常大。当然，您随后需要手动配置内核以获得所需的设置。
- en: 'This brings up the question, *where is the default kernel config stored*? The
    kbuild system uses a priority list fallback scheme to retrieve a default configuration.
    The priority list and its order (first being highest priority) are specified within
    `init/Kconfig:DEFCONFIG_LIST`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来了一个问题，*默认内核配置存储在哪里*？kbuild系统使用优先级列表回退方案来检索默认配置。优先级列表及其顺序（第一个优先级最高）在`init/Kconfig:DEFCONFIG_LIST`中指定：
- en: '[PRE14]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'FYI, the kernel documentation on `Kconfig` (found here: [https://www.kernel.org/doc/Documentation/kbuild/kconfig-language.txt](https://www.kernel.org/doc/Documentation/kbuild/kconfig-language.txt))
    documents what `defconfig_list` is:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，关于`Kconfig`的内核文档（在此处找到：[https://www.kernel.org/doc/Documentation/kbuild/kconfig-language.txt](https://www.kernel.org/doc/Documentation/kbuild/kconfig-language.txt)）记录了`defconfig_list`是什么：
- en: '[PRE15]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: From the list, you can see that the kbuild system first checks for the presence
    of a `.config` file in the `/lib/modules/$(uname -r)` folder. If found, the values
    there will be used as the defaults. If not found, it next checks for the presence
    of a `/etc/kernel-config` file. If found, the values there will be used as defaults,
    and if not found it moves on to the next option in the preceding priority list,
    and so on. Note, though, that the presence of a `.config` file in the root of
    the kernel source tree overrides all of this!
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表中可以看出，kbuild系统首先检查`/lib/modules/$(uname -r)`文件夹中是否存在`.config`文件。如果找到，其中的值将被用作默认值。如果未找到，则接下来检查`/etc/kernel-config`文件是否存在。如果找到，其中的值将被用作默认值，如果未找到，则继续检查前面优先级列表中的下一个选项，依此类推。但请注意，内核源树根目录中存在`.config`文件将覆盖所有这些！
- en: Obtaining a good starting point for kernel configuration
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取内核配置的良好起点
- en: 'This brings us to a **really important point**: playing around with the kernel
    configuration is okay to do as a learning exercise (as we do here), but for a
    production system, it''s really critical that you use a proven – known, tested,
    and working – kernel configuration.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们来到一个**非常重要的观点**：玩弄内核配置作为学习练习是可以的（就像我们在这里做的那样），但对于生产系统，使用已知、经过测试和工作的内核配置真的非常重要。
- en: 'Here, to help you understand the nuances of selecting a valid starting point
    for kernel configuration, we will see three approaches to obtaining a starting
    point for kernel configuration that (we hope) are typical:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，为了帮助您理解选择内核配置的有效起点的微妙之处，我们将看到三种获得内核配置起点的方法（我们希望）是典型的：
- en: First, the approach to follow for a typical small embedded Linux system
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，对于典型的小型嵌入式Linux系统要遵循的方法
- en: Next, an approach where you emulate the distribution's configuration
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，一种模拟发行版配置的方法
- en: Finally, an approach where you base the kernel configuration on the existing
    (or another) system's kernel modules (the `localmodconfig` approach)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，一种基于现有（或其他）系统的内核模块的内核配置的方法（`localmodconfig`方法）
- en: Let's examine each of these approaches in a bit more detail.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地检查每种方法。
- en: Kernel config for typical embedded Linux systems
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 典型嵌入式Linux系统的内核配置
- en: The typical target system for using this approach is a small embedded Linux
    system. The goal here is to begin with a proven – a known, tested, and working
    – kernel configuration for our embedded Linux project. Well, how exactly can we
    achieve this?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法的典型目标系统是小型嵌入式Linux系统。这里的目标是从已知、经过测试和工作的内核配置开始我们的嵌入式Linux项目。那么，我们究竟如何做到这一点呢？
- en: 'Interestingly, the kernel code base itself provides known, tested, and working
    kernel configuration files for various hardware platforms. We merely have to select
    the one that matches (or is the nearest match to) our embedded target board. These
    kernel config files are present within the kernel source tree in the `arch/<arch>/configs/` directory.
    The config files are in the format `<platform-name>_defconfig`. A quick peek is
    in order; see the following screenshot showing the command `ls arch/arm/configs`
    being performed on the v5.4 Linux kernel code base:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，内核代码库本身为各种硬件平台提供了已知、经过测试和工作的内核配置文件。我们只需选择与我们的嵌入式目标板匹配（或最接近匹配）的配置文件。这些内核配置文件位于内核源树中的`arch/<arch>/configs/`目录中。配置文件的格式为`<platform-name>_defconfig`。让我们快速看一下；看一下以下屏幕截图，显示了在v5.4
    Linux内核代码库上执行`ls arch/arm/configs`命令：
- en: '![](img/06950efa-a78e-4194-a747-2414cddfe329.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06950efa-a78e-4194-a747-2414cddfe329.png)'
- en: Figure 2.4 – The contents of arch/arm/configs on the 5.4 Linux kernel
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 - 5.4 Linux内核中arch/arm/configs的内容
- en: 'Thus, for example, if you find yourself configuring the Linux kernel for a
    hardware platform having, say, a Samsung Exynos **System on Chip** (**SoC**) on
    it, please don’t start with an x86-64 kernel config file as the default (or simply
    attempt to use it). It won''t work. Even if you manage it, the kernel will not
    build/work cleanly. Pick the appropriate kernel config file: for our example here,
    the `arch/arm/configs/exynos_defconfig` file would be a good starting point. You
    can copy this file into `.config` in the root of your kernel source tree and then
    proceed to fine-tune it to your project-specific needs.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，如果您发现自己为具有三星Exynos **片上系统**（**SoC**）的硬件平台配置Linux内核，请不要从默认的x86-64内核配置文件开始（或者尝试使用它）。这样不会起作用。即使您成功了，内核也不会干净地构建/工作。选择适当的内核配置文件：对于我们的示例，`arch/arm/configs/exynos_defconfig`文件将是一个很好的起点。您可以将此文件复制到内核源树的根目录中的`.config`，然后继续对其进行微调以满足项目特定需求。
- en: 'As another example, the Raspberry Pi ([https://www.raspberrypi.org/](https://www.raspberrypi.org/))
    is a popular hobbyist platform. The kernel config file – within its kernel source
    tree – used (as a base) is this one: `arch/arm/configs/bcm2835_defconfig`. The
    filename reflects the fact that  Raspberry Pi boards use a Broadcom 2835-based
    SoC. You can find details regarding kernel compilation for the Raspberry Pi here:
    [https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md).
    Hang on, though, we will be covering at least some of this in [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml),
    *Building the 5.x Linux Kernel from Source – Part 2*, in the *Kernel build for
    the Raspberry Pi* section.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，树莓派（[https://www.raspberrypi.org/](https://www.raspberrypi.org/)）是一种流行的业余爱好者平台。内核配置文件
    - 在其内核源树中 - 使用（作为基础）的是这个：`arch/arm/configs/bcm2835_defconfig`。文件名反映了树莓派板使用的是基于Broadcom
    2835的SoC。您可以在这里找到有关树莓派内核编译的详细信息：[https://www.raspberrypi.org/documentation/linux/kernel/building.md](https://www.raspberrypi.org/documentation/linux/kernel/building.md)。不过，我们将在[第3章](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml)中至少涵盖其中的一些内容，*从源代码构建5.x
    Linux内核 - 第2部分*，在*树莓派的内核构建*部分。
- en: An easy way to see exactly which configuration file is good for which platform
    is to simply perform `make help` on the target platform itself. The latter part
    of the output displays the config files under the *Architecture specific targets* heading (note
    though that this is meant for foreign CPUs and doesn't work for the x86[-64]).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 查看哪个平台的配置文件适合哪个平台的简单方法是在目标平台上执行`make help`。输出的后半部分显示了*特定架构目标*标题下的配置文件（请注意，这是针对外部CPU的，不适用于x86[-64]）。
- en: The careful tweaking and setup of the kernel config for a product is an important
    part of the work typically carried out by the engineers working within the *platform*
    or**Board Support Package** (**BSP**) team.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对产品进行内核配置的仔细调整和设置是*平台*或**板支持包**（**BSP**）团队工程师通常进行的重要工作的一部分。
- en: Kernel config using distribution config as a starting point
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用发行版配置作为起点的内核配置
- en: The typical target system for using this approach is a desktop or server Linux
    system.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法的典型目标系统是桌面或服务器Linux系统。
- en: 'Moving along, this second approach is also quick:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这第二种方法也很快：
- en: '[PRE16]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we simply copy the existing Linux distribution's (here, it's our Ubuntu
    18.04.3 LTS guest VM) config file into the `.config` file in the root of the kernel
    source tree, of course, thereby making the distribution config the starting point,
    which can then be further edited (a more generic command: `cp /boot/config-$(uname
    -r) ${LLKD_KSRC}/.config`).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只需将现有的Linux发行版（这里是我们的Ubuntu 18.04.3 LTS虚拟机）的配置文件复制到内核源树根目录中的`.config`文件中，从而使发行版配置成为起点，然后可以进一步编辑（更通用的命令：`cp
    /boot/config-$(uname -r) ${LLKD_KSRC}/.config`）。
- en: Tuned kernel config via the localmodconfig approach
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过localmodconfig方法调整内核配置
- en: The typical target system for using this approach is a desktop or server Linux
    system.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法的典型目标系统是桌面或服务器Linux系统。
- en: 'This third approach we consider is a good one to use when the goal is to begin
    with a kernel config that is based on your existing system and is thus (usually)
    relatively compact compared to the typical default config on a desktop or server
    Linux system. Here, we provide the kbuild system with a snapshot of the kernel
    modules currently running on the system by simply redirecting the output of `lsmod(8)`
    into a temporary file, and then providing that file to the build. This can be
    achieved as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考虑的第三种方法是一个很好的方法，当目标是从基于现有系统的内核配置开始时，通常相对于桌面或服务器Linux系统的典型默认配置来说，它相对较小。在这里，我们通过简单地将`lsmod(8)`的输出重定向到临时文件，然后将该文件提供给构建，向kbuild系统提供了系统上当前运行的内核模块的快照。可以通过以下方式实现：
- en: '[PRE17]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `lsmod(8)` utility simply lists all the kernel modules currently residing
    in system (kernel) memory. We will see (a lot) more on this in [Chapter 4](1c494ebd-e7ec-4a78-8695-5b97bdc3d6be.xhtml),
    *Writing Your First Kernel Module – LKMs Part 1*. We save its output in a temporary
    file, which we pass within the `LSMOD` environment variable to the Makefile's
    `localmodconfig` target. The job of this target is to configure the kernel in
    a manner as to only include the base functionality plus the functionality provided
    by these kernel modules and leave out the rest, in effect giving us a reasonable
    facsimile of the current kernel (or of whichever kernel the `lsmod` output represents).
    We use precisely this technique to configure our 5.4 kernel in the following *Getting
    started with the localmodconfig approach* section.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`lsmod(8)`实用程序简单地列出当前驻留在系统（内核）内存中的所有内核模块。我们将在[第4章](1c494ebd-e7ec-4a78-8695-5b97bdc3d6be.xhtml)中详细介绍这个（很多）。我们将其输出保存在一个临时文件中，并将其传递到Makefile的`localmodconfig`目标中的`LSMOD`环境变量中。此目标的工作是以一种只包括基本功能以及这些内核模块提供的功能的方式配置内核，并排除其余部分，从而实际上给我们提供了当前内核的合理外观（或`lsmod`输出所代表的任何内核）。我们将使用这种技术来配置我们的5.4内核，接下来是*使用localmodconfig方法开始*部分。'
- en: 'Right, this concludes the three approaches to setting up a starting point for
    kernel configuration. As a matter of fact, we have just scratched the surface.
    Many more techniques to explicitly generate the kernel configuration in a given
    manner are encoded into the kbuild system itself! How? Via configuration targets
    to `make`. See them under the `Configuration targets` heading:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这就结束了为内核配置设置起点的三种方法。事实上，我们只是触及了表面。许多更多的技术被编码到kbuild系统本身中，以明确地生成给定方式的内核配置！如何？通过`make`的配置目标。在`Configuration
    targets`标题下查看它们：
- en: '[PRE18]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A quick but very useful point: to ensure a clean slate, use the `mrproper`
    target first. We will show a summary of all the steps carried out next, so don''t
    worry for now.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速但非常有用的要点：为了确保一张干净的纸，首先使用`mrproper`目标。接下来我们将展示所有步骤的摘要，所以现在不要担心。
- en: Getting started with the localmodconfig approach
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用localmodconfig方法开始
- en: Now, let's quickly get started on creating a base kernel configuration for our
    new kernel by using the third approach we discussed previously – the `localmodconfig`
    technique. As mentioned, this existing kernel modules-only approach is a good
    one when the goal is to obtain a starting point for kernel config on an x86-based
    system by keeping it relatively small and thus make the build quicker as well.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速开始使用我们之前讨论过的第三种方法 - `localmodconfig`技术为我们的新内核创建一个基本内核配置。如前所述，这种现有的仅内核模块方法是一个很好的方法，当目标是在基于x86的系统上获得内核配置的起点时，通过保持相对较小的内核配置，从而使构建速度更快。
- en: 'Don''t forget: the kernel configuration being performed right now is appropriate
    for your typical x86-based desktop/server systems. For embedded targets, the approach
    is different (as seen in the *Kernel config for typical embedded Linux systems* section).
    We further cover this practically in [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml),
    *Building the 5.x Linux Kernel from Source - Part 2*, under the *Kernel build
    for the Raspberry Pi* section*.*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记：当前正在执行的内核配置适用于您典型的基于x86的桌面/服务器系统。对于嵌入式目标，方法是不同的（如在*典型嵌入式Linux系统的内核配置*部分中所见）。我们将在[第3章](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml)中进一步介绍这一点，*从源代码构建5.x
    Linux内核 - 第2部分*，在*树莓派的内核构建*部分。
- en: 'As described previously, first obtain a snapshot of the currently loaded kernel
    modules, and then have the kbuild system operate upon it by specifying the `localmodconfig`
    target, like so:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，首先获取当前加载的内核模块的快照，然后通过指定`localmodconfig`目标让kbuild系统对其进行操作，如下所示：
- en: '[PRE19]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, something to understand: when we perform the actual `make [...] localmodconfig`
    command, it''s entirely possible, indeed even probable, that there will be a difference
    in the configuration options between the kernel you are currently building (version
    5.4) and the kernel you are currently actually running the build on (`$(uname
    -r) = 5.0.0-36-generic`, here). In these cases, the kbuild system will display
    every single new config option and the available values you can set it to, on
    the console (terminal) window. Then, it will prompt the user to select the value
    of any new config options it encounters in the kernel being built. You will see
    this as a series of questions and a prompt to answer them on the command line.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要理解的是：当我们执行实际的`make [...] localmodconfig`命令时，当前正在构建的内核（版本5.4）与当前实际运行构建的内核（`$(uname
    -r) = 5.0.0-36-generic`）之间的配置选项可能会有差异，甚至很可能会有差异。在这些情况下，kbuild系统将在控制台（终端）窗口上显示每个新的配置选项以及您可以设置的可用值。然后，它将提示用户选择正在构建的内核中遇到的任何新的配置选项的值。您将看到这是一系列问题，并提示在命令行上回答它们。
- en: The prompt will be suffixed with `(NEW)`, in effect telling you that this is
    a *new* kernel config option and it wants your answer as to how to configure it.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 提示将以`(NEW)`为后缀，实际上告诉您这是一个*新*的内核配置选项，并希望您回答如何配置它。
- en: 'Here, at least, we will take the easy way out: just press the `[Enter]` key
    to accept the default selection, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，至少，我们将采取简单的方法：只需按`[Enter]`键接受默认选择，如下所示：
- en: '[PRE20]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After pressing the `[Enter]` key many times, the interrogation mercifully finishes
    and the kbuild system writes the newly generated configuration to the `.config` file in
    the current working directory (we truncated the previous output as it's simply
    too voluminous, and unnecessary, to reproduce fully).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 按下`[Enter]`键多次后，询问终于结束，kbuild系统将新生成的配置写入当前工作目录中的`.config`文件中（我们截断了先前的输出，因为它太庞大，而且没有必要完全重现）。
- en: 'The preceding two steps take care of generating the `.config` file via the
    `localmodconfig` approach. Before we conclude this section, here are some key
    points to note:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 前面两个步骤负责通过`localmodconfig`方法生成`.config`文件。在结束本节之前，这里有一些要注意的关键点：
- en: To ensure a completely clean slate, run `make mrproper` or `make distclean`
    in the root of the kernel source tree (useful when you want to restart from scratch;
    rest assured, it will happen one day! Note that doing this deletes the kernel
    configuration file(s) too).
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了确保完全干净的状态，在内核源代码树的根目录中运行`make mrproper`或`make distclean`（当您想从头开始重新启动时很有用；请放心，总有一天会发生！请注意，这将删除内核配置文件）。
- en: Here, in this chapter, all the kernel configuration steps and the screenshots
    pertaining to it have been performed on an Ubuntu 18.04.3 LTS x86-64 guest VM,
    which we use as the host to build a brand spanking new 5.4 Linux kernel. The precise
    names, the presence and content of the menu items, as well as the look and feel
    of the menu system (the UI) can and do vary based on (a) the architecture (CPU)
    and (b) the kernel version.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，所有与内核配置步骤和相关截图都是在Ubuntu 18.04.3 LTS x86-64虚拟机上执行的，我们将其用作构建全新的5.4 Linux内核的主机。菜单项的名称、存在和内容，以及菜单系统（UI）的外观和感觉可能会根据（a）架构（CPU）和（b）内核版本而有所不同。
- en: As mentioned earlier, on a production system or project, the platform or **Board
    Support Package** (**BSP**) team, or indeed the embedded Linux BSP vendor company
    if you have partnered with one, will provide a good known, working, and tested
    kernel config file. Do use this as a starting point by copying it onto the `.config` file
    in the root of the kernel source tree.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如前面提到的，在生产系统或项目中，平台或**板支持包**（**BSP**）团队，或者如果您与嵌入式Linux BSP供应商合作，他们会提供一个已知的、可工作和经过测试的内核配置文件。请将其用作起点，将其复制到内核源代码树根目录中的`.config`文件中。
- en: As you gain experience with building the kernel, you will realize that the effort
    in setting up the kernel configuration correctly the first time (critical!) is
    higher; and, of course, the time required for the very first build is a lengthy
    one. Once done correctly, though, the process typically becomes much simpler –
    a recipe to run over and over again.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 随着构建内核的经验增加，您会意识到第一次正确设置内核配置的工作量（至关重要！）更大；当然，第一次构建所需的时间也更长。不过，一旦正确完成，整个过程通常会变得简单得多
    - 一个可以一遍又一遍运行的配方。
- en: Now, let's learn how to use a useful and intuitive UI to tune our kernel configuration.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何使用一个有用且直观的UI来调整我们的内核配置。
- en: Tuning our kernel configuration via the make menuconfig UI
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过make menuconfig UI调整我们的内核配置
- en: 'Okay, great, we now have an initial kernel config file (`.config`) generated
    for us via the `localmodconfig` Makefile target, as shown in detail in the previous
    section, which is a good starting point. Now, we want to further examine and fine-tune
    our kernel''s configuration. One way to do this – in fact, the recommended way
    – is via the `menuconfig` Makefile target. This target has the kbuild system generate
    a pretty sophisticated (C-based) program executable (`scripts/kconfig/mconf`),
    which presents to the end user a neat menu-based UI. In the following code block,
    when we invoke the command for the first time, the kbuild system builds the `mconf`
    executable and invokes it:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，很好，我们现在有一个通过`localmodconfig` Makefile目标为我们生成的初始内核配置文件（`.config`），如前一节详细介绍的那样，这是一个很好的起点。现在，我们希望进一步检查和微调我们的内核配置。一种方法是通过`menuconfig`
    Makefile目标 - 实际上，是推荐的方法。这个目标让kbuild系统生成一个相当复杂的（基于C的）程序可执行文件（`scripts/kconfig/mconf`），向最终用户呈现一个整洁的基于菜单的UI。在下面的代码块中，当我们第一次调用该命令时，kbuild系统会构建`mconf`可执行文件并调用它：
- en: '[PRE21]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Of course, a picture is no doubt worth a thousand words, so here''s what the
    `menuconfig` UI looks like:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一张图片无疑价值千言万语，这是`menuconfig`的UI外观：
- en: '![](img/ddd39591-ff94-4c75-998d-f87fb3b1fa17.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ddd39591-ff94-4c75-998d-f87fb3b1fa17.png)'
- en: Figure 2.5 – The main menu of kernel configuration via make menuconfig (on x86-64)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 - 通过make menuconfig进行内核配置的主菜单（在x86-64上）
- en: 'As experienced developers, or indeed anyone who has sufficiently used a computer,
    well know, things can and do go wrong. Take, for example, the following scenario
    – running `make menuconfig` for the first time on a freshly installed Ubuntu system:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 作为经验丰富的开发人员，或者任何足够使用计算机的人都知道，事情可能会出错。例如，以下情景 - 在新安装的Ubuntu系统上第一次运行`make menuconfig`：
- en: '[PRE22]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Hang on, don''t panic (yet). Read the failure message(s) carefully. The line
    after `YACC [...]` provides the clue: `/bin/sh: 1: bison: not found`. Ah, so install
    `bison(1)` with the following command:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '等一下，不要慌（还）。仔细阅读失败消息。`YACC [...]`后的一行提供了线索：`/bin/sh: 1: bison: not found`。啊，所以用以下命令安装`bison(1)`：'
- en: '`sudo apt install bison`'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo apt install bison`'
- en: 'Now, all should be well. Well, almost; again, on a freshly baked Ubuntu guest,
    `make menuconfig` then complains that `flex(1)` was not installed. So, we install
    it (you guessed it: via `sudo apt install flex`). Also, specifically on Ubuntu,
    you need the `libncurses5-dev` package installed (on Fedora, do `sudo dnf install
    ncurses-devel`).'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一切应该都好了。嗯，几乎；同样，在新安装的Ubuntu系统上，`make menuconfig`然后抱怨`flex(1)`未安装。所以，我们安装它（你猜对了：通过`sudo
    apt install flex`）。此外，在Ubuntu上，您需要安装`libncurses5-dev`包（在Fedora上，执行`sudo dnf install
    ncurses-devel`）。
- en: If you have read and followed [Chapter 1](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml), *Kernel*
    *Workspace Setup*, you would have all these prerequisite packages already installed.
    If not, please refer to it now and install all required packages. Remember, *as
    ye sow…*
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经阅读并遵循了[第1章](ad75db43-a1a2-4f3f-92c7-a544f47baa23.xhtml)，*内核* *工作空间设置*，那么您应该已经安装了所有这些先决条件包。如果没有，请立即参考并安装所有所需的包。记住，*种瓜得瓜，种豆得豆……*
- en: 'Moving along, the kbuild open source framework (reused in a whole bunch of
    projects, incidentally) provides some clues to the user via its UI. The meaning
    of the symbols prefixing the menu entries are as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前进，kbuild开源框架（顺便说一句，它在许多项目中被重复使用）通过其UI向用户提供了一些线索。菜单条目前缀的含义如下：
- en: '`[.]`: In-kernel feature, Boolean option (it''s either on or off):'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[.]`: 内核功能，布尔选项（要么开启，要么关闭）：'
- en: '`[*]`: On, feature compiled and built in (compiled in) to the kernel image
    (y)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[*]`: 开启，功能已编译并内置到内核镜像中（编译进内核）（y）'
- en: '`[ ]`: Off, not built at all (n)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ ]`: 关闭，根本没有构建（n）'
- en: '`<.>`: A feature that could be in one of three states (tristate):'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<.>`：一个可以处于三种状态之一的特性（三态）：'
- en: '`<*>`: On, feature compiled and built in (compiled in) the kernel image (y)'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<*>`：打开，特性已编译并内建（编译进）内核镜像（y）'
- en: '`<M>`: Module, feature compiled and built as a kernel module (an LKM) (m)'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<M>`：模块，作为内核模块编译和内建（m）'
- en: '`< >`: Off, not built at all (n)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`< >`：关闭，完全不构建（n）'
- en: '`{.}`: A dependency exists for this config option; hence, it''s required to
    be built (compiled) as either a module (m) or built in (compiled in) to the kernel
    image (y).'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{.}`：此配置选项存在依赖关系；因此，它需要被构建（编译）为模块（m）或内建到内核镜像中（y）。'
- en: '`-*-`: A dependency requires this item to be compiled in (y).'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-*-`：一个依赖需要将此项目编译进（y）。'
- en: '`(...)`: Prompt: an alphanumeric input is required (press the `[Enter]` key
    while on this option and a prompt appears).'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`（...）`：提示：需要输入字母数字（在此选项上按`[Enter]`键，然后会出现提示）。'
- en: '`<Menu entry>  --->`: A sub-menu follows (press `[Enter]` on this item to navigate
    to the sub-menu).'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<菜单项>  --->`：后面有一个子菜单（在此项目上按`[Enter]`键导航到子菜单）。'
- en: Again, the empirical approach is key. Let's actually experiment with the `make
    menuconfig` UI to see how it works. This is the topic of the next section.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，经验法则至关重要。让我们实际尝试使用`make menuconfig` UI来看看它是如何工作的。这是下一节的主题。
- en: Sample usage of the make menuconfig UI
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用make menuconfig UI的示例用法
- en: To get a feel for using the kbuild menu system via the convenient `menuconfig`
    target, let's step through the process to navigate to the tristate menu item called
    `Kernel .config support`. It will be off by default, so let's turn it on; that
    is, let's make it `y`, built into the kernel image. We can find it under the `General
    Setup` main menu item on the home screen.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 通过方便的`menuconfig`目标来感受使用kbuild菜单系统的过程，让我们逐步进行导航到名为`内核.config支持`的三态菜单项。它默认是关闭的，所以让我们打开它；也就是说，让我们把它设为`y`，内建到内核镜像中。我们可以在主屏幕上的`常规设置`主菜单项下找到它。
- en: 'What exactly does turning this feature on achieve? When turned on to `y` (or,
    of course, if made to `M`, then a kernel module will become available, and once
    it''s loaded up), then the currently running kernel''s configuration settings
    can be looked up at any time in two ways:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 打开此功能到`y`会实现什么？当打开到`y`（或者当设置为`M`时，一个内核模块将可用，并且一旦加载，当前运行的内核配置设置可以通过两种方式随时查找：
- en: By running the `scripts/extract-ikconfig` script
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过运行`scripts/extract-ikconfig`脚本
- en: By directly reading the content of the `/proc/config.gz` pseudo-file (of course,
    it's `gzip(1)`-compressed; first uncompress it, and then read it)
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接读取`/proc/config.gz`伪文件的内容（当然，它是`gzip(1)`压缩的；首先解压缩，然后读取）
- en: 'As a learning exercise, we will now learn how to configure our 5.4 Linux kernel
    (for the x86-64 architecture) for the kernel config options with the values shown
    in the following table. For now, don''t stress regarding the meaning of each of
    these options; it''s just to get some practice with the kernel config system:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个学习练习，我们现在将学习如何为x86-64架构的5.4 Linux内核配置内核配置选项，其值如下表所示。现在，不要担心每个选项的含义；这只是为了练习内核配置系统：
- en: '| **Feature** | **Effect and location in the make menuconfig UI** |  **Select
    the < Help > button**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '| **特性** | **在make menuconfig UI中的效果和位置** | **选择<帮助>按钮**'
- en: '**to see the precise CONFIG_<FOO> option** | **Value: original** **-> new value**
    |'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**查看精确的CONFIG_<FOO>选项** | **值：原始** **-> 新值** |'
- en: '| Local version | Sets the `-EXTRAVERSION` component of the kernel release/version
    (seen with `uname -r`); `General Setup / Local version - append to kernel release`
    | `CONFIG_LOCALVERSION` | (none) -> `-llkd01` |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 本地版本 | 设置内核发布/版本的`-EXTRAVERSION`组件（使用`uname -r`查看）；`常规设置 / 附加到内核发布的本地版本`
    | `CONFIG_LOCALVERSION` | (none) -> `-llkd01` |'
- en: '| Kernel config file support | Allows you to see the current kernel configuration
    details;  `General Setup / Kernel .config support` | `CONFIG_IKCONFIG` |  `n`
    -> `y` |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 内核配置文件支持 | 允许您查看当前内核配置详细信息；`常规设置 / 内核.config支持` | `CONFIG_IKCONFIG` |  `n`
    -> `y` |'
- en: '| The same as the preceding plus access via procfs | Allows you to see the
    current kernel configuration details via **proc filesystem** (**p****rocfs**);  `General
    Setup / Enable access to .config through /proc/config.gz` | `CONFIG_IKCONFIG_PROC`
    | `n` -> `y` |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 与前面相同，还可以通过procfs访问 | 允许您通过**proc文件系统**（**procfs**）查看当前内核配置详细信息；`常规设置 / 通过/proc/config.gz启用对.config的访问`
    | `CONFIG_IKCONFIG_PROC` | `n` -> `y` |'
- en: '| Kernel profiling | Kernel profiling support; `General Setup / Profiling support`
    | `CONFIG_PROFILING` | `y` -> `n` |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 内核分析 | 内核分析支持；`常规设置 / 分析支持` | `CONFIG_PROFILING` | `y` -> `n` |'
- en: '| HAM radio | Support for HAM radio; `Networking support /  Amateur Radio support`
    | `CONFIG_HAMRADIO` | `y` -> `n` |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| HAM无线电 | HAM无线电支持；`网络支持 / 业余无线电支持` | `CONFIG_HAMRADIO` | `y` -> `n` |'
- en: '| VirtualBox support | (Para)virtualization support for VirtualBox; `Device
    Drivers / Virtualization drivers / Virtual Box Guest integration support` | `CONFIG_VBOXGUEST`
    | `n` -> `m` |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| VirtualBox支持 | VirtualBox的（Para）虚拟化支持；`设备驱动程序 / 虚拟化驱动程序 / Virtual Box客户端集成支持`
    | `CONFIG_VBOXGUEST` | `n` -> `m` |'
- en: '| **Userspace IO Drivers** (**UIO**) | UIO support; `Device Drivers / Userspace
    I/O Drivers` | `CONFIG_UIO` | `n` -> `m` |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| **用户空间IO驱动程序**（**UIO**） | UIO支持；`设备驱动程序 / 用户空间IO驱动程序` | `CONFIG_UIO` | `n`
    -> `m` |'
- en: '| The preceding plus the UIO platform driver with generic IRQ handling | UIO
    platform driver with generic IRQ handling; `Device Drivers / Userspace I/O Drivers
    / Userspace I/O platform driver with generic IRQ handling` | `CONFIG_UIO_PDRV_GENIRQ`
    | `n` -> `m` |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 前面加上具有通用中断处理的UIO平台驱动程序 | 具有通用中断处理的UIO平台驱动程序；`设备驱动程序 / 用户空间IO驱动程序 / 具有通用中断处理的用户空间IO平台驱动程序`
    | `CONFIG_UIO_PDRV_GENIRQ` | `n` -> `m` |'
- en: '| MS-DOS filesystem support | `File systems / DOS/FAT/NT Filesystems / MSDOS
    fs support` | `CONFIG_MSDOS_FS` | `n` -> `m` |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| MS-DOS文件系统支持 | `文件系统 / DOS/FAT/NT文件系统 / MSDOS文件系统支持` | `CONFIG_MSDOS_FS`
    | `n` -> `m` |'
- en: '| Security: LSMs | Turn *off* kernel LSMs; `Security options / Enable different
    security models` *(NOTE: it''s typically, safer to keep this ON for production
    systems!)* | `CONFIG_SECURITY` | `y` -> `n` |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 安全性：LSMs | 关闭内核LSMs；`安全选项 / 启用不同的安全模型` *(注意：对于生产系统，通常最好保持此选项打开！)* | `CONFIG_SECURITY`
    | `y` -> `n` |'
- en: '| Kernel debug: stack utilization info | `Kernel hacking / Memory Debugging
    / Stack utilization instrumentation` | `CONFIG_DEBUG_STACK_USAGE` | `n` -> `y`
    |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 内核调试：堆栈利用信息 | `内核调试 / 内存调试 / 堆栈利用信息检测` | `CONFIG_DEBUG_STACK_USAGE` | `n`
    -> `y` |'
- en: Table 2.4 – Items to configure
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.4 – 需要配置的项目
- en: 'How exactly do you interpret this table? Let''s take the first row as an example;
    we go over it column by column:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何解释这个表格？让我们以第一行为例；我们逐列地讨论它：
- en: '**The first column **specifies the kernel *feature* we are wanting to modify
    (edit/enable/disable). Here, it''s the last part of the kernel version string
    (as it shows up in the output of `uname -r`). It''s called the `-EXTRAVERSION`
    component of the release (see the *Kernel release nomenclature* section for details).'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一列**指定我们要修改（编辑/启用/禁用）的内核*特性*。在这里，它是内核版本字符串的最后部分（如在`uname -r`的输出中显示）。它被称为发布的`-EXTRAVERSION`组件（详细信息请参阅*内核发布命名规范*部分）。'
- en: '**The second column **specifies two things:'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二列**指定了两件事：'
- en: One, what we're attempting to do. Here, we want to *set* the `-EXTRAVERSION`
    component of the kernel release string.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们要做什么。在这里，我们想要*设置*内核发布字符串的`-EXTRAVERSION`组件。
- en: Two, the location of this kernel config option within the `menuconfig` UI is
    shown. Here, it's within the `General Setup` sub-menu, and under that it's the
    menu item called `Local version - append to kernel release`*.* We write it as
    `General Setup / Local version - append to kernel release`.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，显示了此内核配置选项在`menuconfig` UI中的位置。在这里，它在`General Setup`子菜单中，在其中是名为`Local version
    - append to kernel release`的菜单项。我们将其写为`General Setup / Local version - append
    to kernel release`。
- en: '**The third column** specifies the kernel config option''s name as `CONFIG_<FOO>`.
    You can search for this within the menu system if required. In this example, it''s
    called `CONFIG_LOCALVERSION`.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三列**指定内核配置选项的名称为`CONFIG_<FOO>`。如果需要，您可以在菜单系统中搜索此选项。在这个例子中，它被称为`CONFIG_LOCALVERSION`。'
- en: '**The fourth column** shows the original *value* of this kernel config option
    and the value we''d like you to change it to (the "new" value). It''s shown in
    the format *original value -> new value.* In our example, it''s `(none) -> -llkd01`,
    implying that the original value of the `-EXTRAVERSION` string component was empty
    and we would like you to modify it, changing it to the value `-llkd01`.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第四列**显示了此内核配置选项的原始*值*以及我们希望您将其更改为的值（“新”值）。它以*原始值 -> 新值*的格式显示。在我们的示例中，它是`(none)
    -> -llkd01`，意味着`-EXTRAVERSION`字符串组件的原始值为空，我们希望您修改它，将其更改为值`-llkd01`。'
- en: On the other hand, for several items we show, it may not be immediately apparent
    – say `n -> m`; what does this mean? `n -> m` implies that you should change the
    original value from `n` (not selected) to `m` (selected to be built as a kernel
    module). Similarly, the `y -> n` string means change the config option from on
    to off.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于我们展示的几个项目，可能不会立即显而易见——比如`n -> m`；这是什么意思？`n -> m`意味着您应该将原始值从`n`（未选择）更改为`m`（选择为内核模块进行构建）。同样，`y
    -> n`字符串表示将配置选项从打开更改为关闭。
- en: You can *search* for kernel config options within the `menuconfig` system UI
    by pressing the / key (just as with vi; we show more on this in the section that
    follows).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过按下/键（就像vi一样；我们将在接下来的部分中展示更多内容）在`menuconfig`系统UI中*搜索*内核配置选项。
- en: Then (in the following chapter, actually), we will build the kernel (and modules)
    with these new config options, boot from it, and verify that the preceding kernel
    config options were set as we wanted.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然后（实际上是在接下来的章节中），我们将使用这些新的配置选项构建内核（和模块），从中引导，并验证前面的内核配置选项是否按我们所需设置。
- en: 'But right now, you are expected to do your bit: fire up the menu UI (with the
    usual `make menuconfig`), then navigate the menu system, finding the relevant
    kernel config options described previously, and edit it as required, to whatever
    the fourth column in the preceding table shows.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在，您需要做您的部分：启动菜单UI（通常使用`make menuconfig`），然后导航菜单系统，找到先前描述的相关内核配置选项，并根据需要进行编辑，以符合前表中第四列显示的内容。
- en: Note that, depending on the Linux distribution you're currently running and
    its kernel modules (we used `lsmod(8)` to generate an initial config, remember?),
    the actual values and defaults you see when configuring the kernel might differ
    from that of the *Ubuntu 18.04.3 LTS* distribution (running the 5.0.0-36-generic
    kernel), as we have used and shown previously.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，根据您当前运行的Linux发行版及其内核模块（我们使用`lsmod(8)`生成了初始配置，记得吗？），在配置内核时看到的实际值和默认值可能与*Ubuntu
    18.04.3 LTS*发行版（运行5.0.0-36-generic内核）的值不同，正如我们之前使用和展示的那样。
- en: 'Here, to keep the discussion sane and compact, we will only show the complete
    detailed steps in setting up the second and third of the kernel config options
    shown in the preceding table (the `Kernel .config support` ones). It''s up to
    you to edit the remainder. Let''s get going:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，为了保持讨论的理智和紧凑，我们只会展示设置前表中显示的第二个和第三个内核配置选项的完整详细步骤（`Kernel .config support`）。剩下的编辑由您完成。让我们开始吧：
- en: 'Change directory to the root of your kernel source tree (wherever you extracted
    it on your disk):'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到内核源树的根目录（无论您在磁盘上的哪个位置提取了它）：
- en: '[PRE23]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Set up an initial kernel configuration file, based on the third approach described
    previously (in the *Tuned kernel config via the localmodconfig approach* section):'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据先前描述的第三种方法（在*Tuned kernel config via the localmodconfig approach*部分）设置初始内核配置文件：
- en: '[PRE24]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the UI:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行UI：
- en: '[PRE25]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once the `menuconfig` UI loads up, go to the `General Setup` menu item. Usually,
    it's the second item on x86-64\. Navigate to it using the keyboard arrow keys
    and enter into it by pressing the *Enter* key.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`menuconfig` UI加载完成，转到`General Setup`菜单项。通常，在x86-64上，它是第二个项目。使用键盘箭头键导航到它，并按*Enter*键进入。
- en: 'You are now within the `General Setup` menu item. Scroll down the menu items
    by pressing the down arrow key a few times. We scroll down to the menu of interest
    for us – `Kernel .config support` – and highlight it; the screen should look (something)
    like this:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你在`General Setup`菜单项中。按下箭头键几次向下滚动菜单项。我们滚动到我们感兴趣的菜单——`Kernel .config support`——并将其突出显示；屏幕应该看起来（有点）像这样：
- en: '![](img/255d0e1a-ffed-4ada-8417-3c7a437fbcf8.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/255d0e1a-ffed-4ada-8417-3c7a437fbcf8.png)'
- en: Figure 2.6 – Kernel configuration via make menuconfig; General setup / Kernel
    .config support
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 - 通过make menuconfig进行内核配置；通用设置/内核.config支持
- en: For the 5.4.0 vanilla Linux kernel on the x86-64, `General Setup / Kernel .config
    support` is the 20^(th) menu item from the top of the `General Setup` menu.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 对于x86-64上的5.4.0原始Linux内核，`通用设置/内核.config支持`是从`通用设置`菜单顶部开始的第20个菜单项。
- en: Once on the `Kernel .config support` menu item, we can see (in the preceding
    screenshot) from its `<M>` prefix that it's a tristate menu item that's set to
    the choice `<M>` for module, to begin with.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在`Kernel .config support`菜单项上，我们可以从其`<M>`前缀（在前面的屏幕截图中）看到，它是一个三态菜单项，最初设置为模块的选择`<M>`。
- en: 'Keeping this item (`Kernel .config support`) highlighted, use the right arrow
    key to navigate to the `< Help >` button on the bottom toolbar and press the *Enter*
    key while on the `< Help >` button. The screen should now look (something) like
    this:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持这个项目（`Kernel .config support`）突出显示，使用右箭头键导航到底部工具栏上的`< Help >`按钮上，并在`< Help
    >`按钮上按*Enter*键。屏幕现在应该看起来（有点）像这样：
- en: '![](img/bc005d7d-6840-4224-b325-471055fb315a.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc005d7d-6840-4224-b325-471055fb315a.png)'
- en: Figure 2.7 – Kernel configuration via make menuconfig; an example help screen
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 - 通过make menuconfig进行内核配置；一个示例帮助屏幕
- en: The help screen is quite informative. Indeed, several of the kernel config help
    screens are very well populated and actually helpful. Unfortunately, some just
    aren't.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助屏幕非常有信息量。事实上，一些内核配置帮助屏幕非常丰富并且实际上很有帮助。不幸的是，有些则不是。
- en: Okay, next, press *Enter *on the `< Exit >` button so that we go back to the
    previous screen.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，接下来，按*Enter*在`< Exit >`按钮上，这样我们就回到了上一个屏幕。
- en: 'Then, toggle the `Kernel .config support` menu item by pressing the space bar
    (assuming it''s initially like this: `<M>`; that is, set to module). Pressing
    the space bar once makes the UI items appear like this:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过按空格键切换`Kernel .config support`菜单项（假设初始状态为`<M>`；也就是说，设置为模块）。按一次空格键会使UI项目显示如下：
- en: '[PRE26]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice how it's become `<*>`, implying that this feature will be built into
    the kernel image itself (in effect, it will be *always on*). For now, let's do
    it this way (of course, pressing the space bar again makes it toggle to the off
    state, `< >`, and then back to the original `<M>` state).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它如何变成了`<*>`，这意味着这个功能将被构建到内核镜像本身中（实际上，它将始终处于打开状态）。现在，让我们这样做（当然，再次按空格键会将其切换到关闭状态`<
    >`，然后再回到原始的`<M>`状态）。
- en: 'Now, with the item in the `<*>` (yes) state, scroll down to the next menu item, `[*]
    Enable access to .config through /proc/config.gz`, and enable it (again, by pressing
    the space bar); the screen should now appear (something) like this (we''ve zoomed
    in to the relevant portion only):'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，项目处于`<*>`（是）状态，向下滚动到下一个菜单项，`[*] Enable access to .config through /proc/config.gz`，并启用它（再次按空格键）；屏幕现在应该看起来（有点）像这样（我们只放大了相关部分）：
- en: '![](img/9d2f0a06-cb54-459c-994f-7f2dbeca1af5.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d2f0a06-cb54-459c-994f-7f2dbeca1af5.png)'
- en: 'Figure 2.8 – Kernel configuration via make menuconfig: toggling a Boolean config
    option to the on state'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 - 通过make menuconfig进行内核配置：将布尔配置选项切换到打开状态
- en: You can always use the right arrow key to go to `< Help >` and view the help
    screen for this item as well.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以随时使用右箭头键转到`< Help >`并查看此项目的帮助屏幕。
- en: Here, we will not explore the remaining kernel config menus; I will leave that
    to you to find and set as shown in the preceding table.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不会探索剩余的内核配置菜单；我会留给你去找到并按照前面的表格设置。
- en: 'Back in the main menu (the home screen), use the right arrow key to navigate
    to the `< Exit >` button and press *Enter* on it. A dialog pops up:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到主菜单（主屏幕），使用右箭头键导航到`< Exit >`按钮上并按*Enter*。会弹出一个对话框：
- en: '![](img/53fdb7cc-c7d3-44ff-bd7e-b6bef75f611c.png)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53fdb7cc-c7d3-44ff-bd7e-b6bef75f611c.png)'
- en: 'Figure 2.9 – Kernel configuration via make menuconfig: save dialog'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 - 通过make menuconfig进行内核配置：保存对话框
- en: It's quite straightforward, isn't it? Press *Enter *on the `< Yes >` button
    to save and exit. If you select the `< No >` button, you lose all your configuration
    changes (made during this session). Or, you can press the *Esc* key *twice* to
    get rid of this dialog and continue working on the kernel config.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，不是吗？在`< Yes >`按钮上按*Enter*保存并退出。如果选择`< No >`按钮，您将失去所有配置更改（在本次会话期间进行的更改）。或者，您可以按*Esc*键*两次*来摆脱这个对话框并继续处理内核配置。
- en: Save and exit. Press *Enter *while on the `< Yes >` button. The menu system
    UI now saves the new kernel configuration and the process exits; we're back on
    the console (a shell or terminal window) prompt.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并退出。在`< Yes >`按钮上按*Enter*。菜单系统UI现在保存了新的内核配置并退出；我们回到控制台（一个shell或终端窗口）提示符。
- en: 'But where’s the new kernel configuration saved? This is important: the kernel
    configuration is written into a simple ASCII text file in the root of the kernel
    source tree, named **`.config`**. That is, it''s saved in `${LLKD_KSRC}/.config`.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 但是新的内核配置保存在哪里？这很重要：内核配置被写入内核源树根目录中的一个简单的ASCII文本文件中，名为**`.config`**。也就是说，它保存在`${LLKD_KSRC}/.config`中。
- en: 'As mentioned earlier, every single kernel config option is associated with
    a config variable of the form `CONFIG_<FOO>`, where `<FOO>`, of course, is replaced
    with an appropriate name. Internally, these become *macros* that the build system
    and indeed the kernel source code uses. For example, consider this for the `Kernel
    .config support` option:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个内核配置选项都与形式为`CONFIG_<FOO>`的配置变量相关联，其中`<FOO>`当然被适当的名称替换。在内部，这些变量成为构建系统和实际上内核源代码使用的*宏*。例如，考虑一下`Kernel
    .config support`选项：
- en: '[PRE27]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Aha! The configuration now reflects the fact that we have done the following:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！配置现在反映了我们已经完成的事实：
- en: Turned on the `CONFIG_IKCONFIG` kernel feature (`=y` indicates that it is on
    and will be built into the kernel image).
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开了`CONFIG_IKCONFIG`内核功能（`=y`表示它已经打开，并将构建到内核镜像中）。
- en: The `/proc/config.gz` (pseudo) file will now be available, as `CONFIG_IKCONFIG_PROC=y`.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc/config.gz`（伪）文件现在可用，作为`CONFIG_IKCONFIG_PROC=y`。'
- en: Caution*:* it's best to NOT attempt to edit the `.config` file manually ("by
    hand"). There are several inter-dependencies you may not be aware of; always use
    the kbuild menu system (we suggest via `make menuconfig`) to edit it.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 注意*：最好不要尝试手动编辑`.config`文件（“手动”）。你可能不知道有几个相互依赖；始终使用kbuild菜单系统（我们建议通过`make menuconfig`）来编辑它。
- en: In reality, during our quick adventure with the kbuild system so far, quite
    a lot has occurred under the hood. The next section examines a little bit to do
    with this, searching within the menu system and cleanly visualizing the differences
    between the original (or older) and new kernel configuration files.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在我们迄今为止与kbuild系统的快速冒险中，底层已经发生了很多事情。下一节将稍微探讨一下这个问题，在菜单系统中搜索以及清晰地可视化原始（或旧）和新的内核配置文件之间的差异。
- en: More on kbuild
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于kbuild的更多信息
- en: The creation of, or edits to, the `.config` file within the root of the kernel
    source tree via `make menuconfig` or other methods is not the final step in how
    the kbuild system works with the configuration. No, it now proceeds to internally
    invoke a target called `syncconfig`, which was earlier (mis)named `silentoldconfig`.
    This target has kbuild generate a few header files that are further used in the
    setup to build the kernel. These files include some meta headers under `include/config`,
    as well as the `include/generated/autoconf.h` header file, which stores the kernel
    config as C macros, thus enabling both the kernel Makefile(s) and kernel code
    to make decisions based on whether or not a kernel feature is available.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`make menuconfig`或其他方法在内核源树的根目录中创建或编辑`.config`文件并不是kbuild系统处理配置的最后一步。不，它现在会内部调用一个名为`syncconfig`的目标，这个目标之前被（误）命名为`silentoldconfig`。这个目标让kbuild生成一些头文件，这些头文件进一步用于构建内核的设置。这些文件包括`include/config`下的一些元头文件，以及`include/generated/autoconf.h`头文件，它将内核配置存储为C宏，从而使内核的Makefile(s)和内核代码能够根据内核功能是否可用来做出决策。
- en: Moving along, what if you are looking for a particular kernel configuration
    option but are having difficulty spotting it? No problem, the `menuconfig` UI
    system has a `Search Configuration Parameter`feature. Just as with the famous
    `vi(1)` editor, press the `/` (forward slash) key to have a search dialog pop
    up, then enter your search term with or without `CONFIG_` preceding it, and select
    the `< Ok >` button to have it go on its way.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果你正在寻找特定的内核配置选项，但很难找到它怎么办？没问题，`menuconfig` UI系统有一个`Search Configuration
    Parameter`功能。就像著名的`vi(1)`编辑器一样，按下`/`（正斜杠）键会弹出一个搜索对话框，然后输入你的搜索词，带有或不带有`CONFIG_`前缀，然后选择`<
    Ok >`按钮让它继续进行。
- en: 'The following couple of screenshots show the search dialog and the result dialog
    (as an example, we searched for the term `vbox`):'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几张截图显示了搜索对话框和结果对话框（例如，我们搜索了术语`vbox`）：
- en: '![](img/2c56f14c-3dad-4cb4-8931-d4d1cbdc2efc.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c56f14c-3dad-4cb4-8931-d4d1cbdc2efc.png)'
- en: 'Figure 2.10 – Kernel configuration via make menuconfig: searching for a config
    parameter'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 - 通过`make menuconfig`进行内核配置：搜索配置参数的结果对话框
- en: 'The result dialog for the preceding search is interesting. It reveals several
    pieces of information regarding the configuration option(s):'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 前面搜索的结果对话框很有趣。它揭示了关于配置选项的几条信息：
- en: The config directive (just prefix `CONFIG_` onto whatever it shows in `Symbol:`)
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置指令（只需在“Symbol:”中加上`CONFIG_`前缀）
- en: The type of config (Boolean, tristate, alphanumeric, and so on)
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置的类型（布尔值、三态值、字母数字等）
- en: The prompt string
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示字符串
- en: Importantly, its location in the menu system (so you can find it)
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的是，它在菜单系统中的位置（这样你就可以找到它）
- en: Its internal dependencies, if any
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的内部依赖，如果有的话
- en: Any config option it auto-selects (turns on) if it itself is selected
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它自动选择的任何配置选项（如果选择了它本身，则打开）
- en: 'The following is a screenshot of the result dialog:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结果对话框的截图：
- en: '![](img/78b4af6f-1d70-4004-b7b4-91e1de325f23.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78b4af6f-1d70-4004-b7b4-91e1de325f23.png)'
- en: 'Figure 2.11 – Kernel configuration via make menuconfig: the result dialog from
    the preceding search'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 - 通过`make menuconfig`进行内核配置：前面搜索的结果对话框
- en: All this information is present in an ASCII text file used by the kbuild system
    to build the menu system UI – this file is called `Kconfig` (there are several
    of them, actually). Its location, too, is shown (in the `Defined at ...` line).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息都包含在一个ASCII文本文件中，该文件由kbuild系统用于构建菜单系统UI - 这个文件称为`Kconfig`（实际上有几个）。它的位置也显示出来了（在`Defined
    at ...`行）。
- en: Looking up the differences in configuration
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找配置中的差异
- en: 'The moment the `.config` kernel configuration file is to be written to, the
    kbuild system checks whether it already exists, and if so, it backs it up with
    the name `.config.old`. Knowing this, we can always differentiate the two to see
    the changes we have wrought. However, using your typical `diff(1)` utility to
    do so makes the differences quite hard to interpret. The kernel helpfully provides
    a better way, a console-based script that specializes in doing precisely this. The `scripts/diffconfig` script
    (within the kernel source tree) is really useful for this. To see why, let''s
    just run its help screen first:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦要写入`.config`内核配置文件，kbuild系统会检查它是否已经存在，如果存在，它会备份为`.config.old`。知道这一点，我们总是可以区分这两个文件，看到我们所做的更改。然而，使用典型的`diff(1)`实用程序来做这件事使得差异很难解释。内核提供了一个更好的方法，一个专门用于做这件事的基于控制台的脚本。内核源树中的`scripts/diffconfig`脚本对此非常有用。为了看到原因，让我们首先运行它的帮助屏幕：
- en: '[PRE28]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we try it out:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来试一下：
- en: '[PRE29]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you modified the kernel configuration changes as shown in the preceding table,
    you should see an output similar to that shown in the preceding code block via
    the kernel's `diffconfig` script. It clearly shows us exactly which kernel config
    options we changed and how.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您修改了内核配置更改，如前表所示，您应该通过内核的`diffconfig`脚本看到类似于前面代码块中显示的输出。它清楚地向我们展示了我们改变了哪些内核配置选项以及如何改变的。
- en: 'Before we finish, a quick note on something critical: *kernel security*. While
    userspace security hardening technologies have vastly grown, kernel-space security
    hardening technologies are actually playing catch-up. Careful configuration of
    the kernel''s config options does play a key role in determining the security
    posture of a given Linux kernel; the trouble is, there are so many options (and
    indeed opinions) that it''s often hard to (cross) check what''s a good idea security-wise
    and what isn''t. Alexander Popov has written a very useful Python script named `kconfig-hardened-check`;
    it can be run to check and compare a given kernel configuration (via the usual
    config file) to a set of predetermined hardening preferences (from various Linux
    kernel security projects: the well known **Kernel Self Protection Project** (**KSPP**),
    the last public grsecurity patch, the CLIP OS and the security lockdown LSM).
    Lookup the `kconfig-hardened-check` GitHub repository at [https://github.com/a13xp0p0v/kconfig-hardened-check](https://github.com/a13xp0p0v/kconfig-hardened-check) and
    try it out!'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束之前，快速注意一些关键的事情：*内核安全*。虽然用户空间安全加固技术已经大大增长，但内核空间安全加固技术实际上正在追赶。仔细配置内核的配置选项在确定给定Linux内核的安全姿态方面起着关键作用；问题是，有太多的选项（实际上是意见），往往很难（交叉）检查哪些是从安全角度来看是一个好主意，哪些不是。Alexander
    Popov编写了一个非常有用的Python脚本，名为`kconfig-hardened-check`；它可以运行以检查和比较给定的内核配置（通过通常的配置文件）与一组预定的加固偏好（来自各种Linux内核安全项目：著名的**内核自我保护项目**（**KSPP**），最后一个公共grsecurity补丁，CLIP
    OS和安全锁定LSM）。查找`kconfig-hardened-check` GitHub存储库，尝试一下！
- en: Alright! You have now completed the first three steps of the Linux kernel build,
    quite a thing. (Of course, we will complete the remaining four steps in the build
    process in the following chapter.) We will end this chapter with a final section
    on learning a useful skill – how to customize the kernel UI menu.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！你现在已经完成了Linux内核构建的前三个步骤，相当了不起。（当然，我们将在下一章中完成构建过程的其余四个步骤。）我们将以一个关于学习有用技能的最后一节结束本章-如何自定义内核UI菜单。
- en: Customizing the kernel menu – adding our own menu item
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义内核菜单-添加我们自己的菜单项
- en: So, let's say you have developed a device driver, an experimental new scheduling
    class, a custom `debugfs` (debug filesystem) callback, or some other cool kernel
    feature. How will you let others on the team – or for that matter, your customer
    – know that this fantastic new kernel feature exists and allow them to select
    it (as either a built-in or as a kernel module) and thus build and make use of
    it? The answer is to insert *a new menu item* at an appropriate place in the kernel
    configuration menu.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，假设你开发了一个设备驱动程序，一个实验性的新调度类，一个自定义的`debugfs`（调试文件系统）回调，或者其他一些很酷的内核特性。你将如何让团队中的其他人，或者说，你的客户，知道这个奇妙的新内核特性存在，并允许他们选择它（作为内置或内核模块）并因此构建和使用它？答案是在内核配置菜单的适当位置插入*一个新的菜单项*。
- en: To do so, it's useful to first understand a little more about the various `Kconfig*` files
    and where they reside. Let's find out.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，首先了解一下各种`Kconfig*`文件及其所在位置是很有用的。让我们找出来。
- en: The Kconfig* files
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kconfig*文件
- en: 'The `Kconfig` file at the root of the kernel source tree is used to fill in
    the initial screen of the `menuconfig` UI. Take a look at it if you wish. It works
    by sourcing various other `Kconfig` files in different folders of the kernel source
    tree. The following table summarizes the more important `Kconfig*` files and which
    menu they serve in the kbuild UI:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 内核源树根目录中的`Kconfig`文件用于填充`menuconfig` UI的初始屏幕。如果你愿意，可以看一下它。它通过在内核源树的不同文件夹中源化各种其他`Kconfig`文件来工作。以下表总结了更重要的`Kconfig*`文件以及它们在kbuild
    UI中服务的菜单：
- en: '| **Menu** | **Kconfig file location for it** |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| **菜单** | **定义它的Kconfig文件位置** |'
- en: '| The main menu, the initial screen | `Kconfig` |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 主菜单，初始屏幕 | `Kconfig` |'
- en: '| General setup+ Enable loadable module support | `init/Kconfig` |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| 通用设置+启用可加载模块支持 | `init/Kconfig` |'
- en: '| Processor types and features + Bus options + Binary Emulations'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '| 处理器类型和特性+总线选项+二进制模拟'
- en: '(arch-specific; above the menu title is for x86; in general, the Kconfig file
    is here: `arch/<arch>/Kconfig`) | `arch/<arch>/Kconfig` |'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: （特定于架构；上面的菜单标题是为x86；一般来说，Kconfig文件在这里：`arch/<arch>/Kconfig`）| `arch/<arch>/Kconfig`
    |
- en: '| Power management | `kernel/power/Kconfig` |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| 电源管理 | `kernel/power/Kconfig` |'
- en: '| Firmware drivers | `drivers/firmware/Kconfig` |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| 固件驱动程序 | `drivers/firmware/Kconfig` |'
- en: '| Virtualization | `arch/<arch>/kvm/Kconfig` |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| 虚拟化 | `arch/<arch>/kvm/Kconfig` |'
- en: '| General architecture-dependent options | `arch/Kconfig` |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| 通用架构相关选项 | `arch/Kconfig` |'
- en: '| Enable the block layer + IO Schedulers | `block/Kconfig` |'
  id: totrans-403
  prefs: []
  type: TYPE_TB
  zh: '| 启用块层+IO调度程序 | `block/Kconfig` |'
- en: '| Executable file formats | `fs/Kconfig.binfmt` |'
  id: totrans-404
  prefs: []
  type: TYPE_TB
  zh: '| 可执行文件格式 | `fs/Kconfig.binfmt` |'
- en: '| Memory Management options | `mm/Kconfig` |'
  id: totrans-405
  prefs: []
  type: TYPE_TB
  zh: '| 内存管理选项 | `mm/Kconfig` |'
- en: '| Networking support | `net/Kconfig, net/*/Kconfig` |'
  id: totrans-406
  prefs: []
  type: TYPE_TB
  zh: '| 网络支持 | `net/Kconfig, net/*/Kconfig` |'
- en: '| Device Drivers | `drivers/Kconfig, drivers/*/Kconfig` |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| 设备驱动程序 | `drivers/Kconfig, drivers/*/Kconfig` |'
- en: '| File systems | `fs/Kconfig, fs/*/Kconfig` |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| 文件系统 | `fs/Kconfig, fs/*/Kconfig` |'
- en: '| Security options | `security/Kconfig, security/*/Kconfig*` |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| 安全选项 | `security/Kconfig, security/*/Kconfig*` |'
- en: '| Cryptographic API | `crypto/Kconfig, crypto/*/Kconfig` |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| 加密API | `crypto/Kconfig, crypto/*/Kconfig` |'
- en: '| Library routines | `lib/Kconfig, lib/*/Kconfig` |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| 库例程 | `lib/Kconfig, lib/*/Kconfig` |'
- en: '| Kernel hacking | `lib/Kconfig.debug, lib/Kconfig.*` |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| 内核黑客 | `lib/Kconfig.debug, lib/Kconfig.*` |'
- en: Table 2.5 – Kernel config menu items and the corresponding Kconfig* file defining
    them
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.5-内核配置菜单项及定义它们的相应Kconfig*文件
- en: Typically, a single `Kconfig` file drives a single menu. Now, let's move on
    to actually adding a menu item.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个`Kconfig`文件驱动一个菜单。现在，让我们继续添加菜单项。
- en: Creating a new menu item in the Kconfig file
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Kconfig文件中创建一个新的菜单项
- en: As a trivial example, let's add our own Boolean dummy config option within the `General
    Setup` menu. We want the config name to be `CONFIG_LLKD_OPTION1`. As can be seen
    from the preceding table, the relevant `Kconfig` file to edit is the `init/Kconfig`
    one as this is the menu meta file that defines the `General Setup` menu.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个微不足道的例子，让我们在`General Setup`菜单中添加我们自己的布尔`dummy`配置选项。我们希望配置名称为`CONFIG_LLKD_OPTION1`。从前面的表中可以看出，要编辑的相关`Kconfig`文件是`init/Kconfig`，因为这是定义`General
    Setup`菜单的菜单元文件。
- en: 'Let''s get to it:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'To be safe, always make a backup copy:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了安全起见，始终制作备份副本：
- en: '[PRE30]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, edit the `init/Kconfig` file:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编辑`init/Kconfig`文件：
- en: '[PRE31]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Scroll down to an appropriate location within the file; here, we choose to
    insert our menu entry just after the `CONFIG_LOCALVERSION_AUTO` one. The following
    screenshot shows our new entry:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中找到适当的位置；在这里，我们选择在`CONFIG_LOCALVERSION_AUTO`之后插入我们的菜单项。以下截图显示了我们的新条目：
- en: '![](img/6e083586-fb43-43a6-b1af-f5675e70bb4d.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e083586-fb43-43a6-b1af-f5675e70bb4d.png)'
- en: Figure 2.12 – Editing init/Kconfig and inserting our own menu entry
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 - 编辑init/Kconfig并插入我们自己的菜单项
- en: We have provided the preceding text as a patch to the original `init/Kconfig`
    file in our book's *GitHub* source tree. Find it under `ch2/Kconfig.patch`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将前面的文本作为补丁提供给了我们书籍的*GitHub*源代码树中的原始`init/Kconfig`文件。在`ch2/Kconfig.patch`下找到它。
- en: The new item starts with the `config` keyword followed by the `FOO` part of
    your new `CONFIG_LLKD_OPTION1` config variable. For now, just read the statements
    we have made in the `Kconfig` file regarding this entry. More details on the `Kconfig`
    language/syntax are in the *A few details on the Kconfig language* section that
    follows.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 新项目以`config`关键字开头，后跟您的新`CONFIG_LLKD_OPTION1`配置变量的`FOO`部分。现在，只需阅读我们在`Kconfig`文件中关于此条目的陈述。有关`Kconfig`语言/语法的更多细节在接下来的*A
    few details on the Kconfig language*部分中。
- en: Save the file and exit the editor.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并退出编辑器。
- en: '(Re)configure the kernel. Navigate to our new menu item and turn the feature
    on (notice how, in the following clipped screenshot, it''s highlighted and *off*
    by default):'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新配置内核。导航到我们的新菜单项并打开该功能（请注意，在下面的截图中，默认情况下它是高亮显示的并且*关闭*）：
- en: '[PRE32]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here''s the output:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '![](img/b201c7d0-b928-4192-8c15-99660dcbccac.png)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b201c7d0-b928-4192-8c15-99660dcbccac.png)'
- en: Figure 2.13 – Kernel configuration via make menuconfig showing our new menu
    entry
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 - 通过make menuconfig进行内核配置，显示我们的新菜单项
- en: Turn it *on* (toggle it with the space bar), then save and exit the menu system.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它（使用空格键切换），然后保存并退出菜单系统。
- en: While there, try pressing the `< Help >` button. You should see the "help" we
    provided within the `Kconfig` file.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在此期间，尝试按下`< Help >`按钮。您应该看到我们在`Kconfig`文件中提供的“帮助”。
- en: 'Check whether our feature has been selected:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查我们的功能是否已被选择：
- en: '[PRE33]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We find that indeed it has been set to *on* within our `.config` file, but is
    not (yet!) within the kernel's internal auto-generated header file. This will
    happen when we build the kernel.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现确实已经在我们的`.config`文件中设置为*on*，但是（还没有！）在内核的内部自动生成的头文件中。这将在构建内核时发生。
- en: 'Build the kernel (worry not; the full details on building the kernel are found
    in the next chapter. You could always first cover [Chapter 3](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml),
    *Building the 5.x Linux Kernel from Source – Part 2*, and then come back to this
    point, if you so wish...):'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '构建内核（不用担心；有关构建内核的完整细节在下一章中找到。您可以首先阅读[第3章](93e5c09d-6c80-47e7-91ab-d3f3f25d00e1.xhtml)，*从源代码构建5.x
    Linux内核-第2部分*，然后再回到这一点，如果您愿意的话...）:'
- en: '[PRE34]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once done, recheck the `autoconf.h` header for the presence of our new config
    option:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，重新检查`autoconf.h`头文件，查看我们的新配置选项是否存在：
- en: '[PRE35]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It worked! Yes, but when working on an actual project (or product), we would
    typically require a further step, setting up our config entry within the Makefile relevant
    to the code that uses this config option.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！是的，但是在实际项目（或产品）中工作时，我们通常需要进一步设置，设置我们的配置项在使用此配置选项的代码相关的Makefile中。
- en: 'Here''s a quick example of how this might look. In the kernel''s top-level
    (or whichever) Makefile, the following line will ensure that our own code (the
    following is within the `llkd_option1.c` source file) gets compiled into the kernel
    at build time. Add this line to the end of the relevant Makefile:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速示例，内核的顶层（或其他位置）Makefile中，以下行将确保我们自己的代码（以下内容在`llkd_option1.c`源文件中）在构建时编译到内核中。将此行添加到相关的Makefile末尾：
- en: '[PRE36]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Don't stress about the fairly weird kernel Makefile syntax for now. The next
    few chapters will shed some light on this.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不要担心内核`Makefile`语法相当奇怪。接下来的几章将对此进行一些解释。
- en: 'Also, you should realize that the very same config can be used as a normal
    C macro within a piece of kernel code; for example, we could do things like this:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您应该意识到，同一个配置也可以作为内核代码片段中的普通C宏使用；例如，我们可以这样做：
- en: '[PRE37]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'However, it''s very much worth noting that the Linux kernel community has devised
    and strictly adheres to certain rigorous coding style guidelines. In this context,
    the guidelines state that conditional compilation should be avoided whenever possible,
    and if it is required to use a `Kconfig` symbol as a conditional, then please
    do it this way:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，非常值得注意的是，Linux内核社区已经制定并严格遵守了某些严格的编码风格指南。在这种情况下，指南规定应尽量避免条件编译，如果需要使用`Kconfig`符号作为条件，则请按照以下方式进行：
- en: '[PRE38]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The Linux kernel *coding style guidelines* can be found here: [https://www.kernel.org/doc/html/latest/process/coding-style.html](https://www.kernel.org/doc/html/latest/process/coding-style.html).
    I urge you to refer to them often, and, of course, to follow them!
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核*编码风格指南*可以在这里找到：[https://www.kernel.org/doc/html/latest/process/coding-style.html](https://www.kernel.org/doc/html/latest/process/coding-style.html)。我建议您经常参考它们，并且当然要遵循它们！
- en: A few details on the Kconfig language
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于Kconfig语言的一些细节
- en: Our usage of the `Kconfig` language so far is just the tip of the proverbial
    iceberg. The fact is, the kbuild system uses the `Kconfig` language (or syntax)
    to express and create menus using simple ASCII text directives. The language includes
    menu entries, attributes, (reverse) dependencies, visibility constraints, help
    text, and so on.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对`Kconfig`语言的使用只是冰山一角。事实上，kbuild系统使用`Kconfig`语言（或语法）来使用简单的ASCII文本指令来表达和创建菜单。该语言包括菜单条目、属性、（反向）依赖项、可见性约束、帮助文本等等。
- en: The kernel documents the `Kconfig` language constructs and syntax here: [https://www.kernel.org/doc/Documentation/kbuild/kconfig-language.txt](https://www.kernel.org/doc/Documentation/kbuild/kconfig-language.txt).
    Do refer to this document for complete details.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 内核文档了`Kconfig`语言的构造和语法：[https://www.kernel.org/doc/Documentation/kbuild/kconfig-language.txt](https://www.kernel.org/doc/Documentation/kbuild/kconfig-language.txt)。请参考此文档以获取完整的详细信息。
- en: 'A brief (and incomplete) mention of the more common `Kconfig` constructs is
    given in the following table:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格简要介绍了更常见的`Kconfig`构造（并不完整）：
- en: '| **Construct** | **Meaning** |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| **构造** | **含义** |'
- en: '| `config <FOO>` | Specifies the menu entry name (of the form `CONFIG_FOO`)
    here; just put the `FOO` part. |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| `config <FOO>` | 在这里指定菜单条目名称（格式为`CONFIG_FOO`）；只需放入`FOO`部分。'
- en: '| **Menu attributes** |  |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| **菜单属性** |  |'
- en: '| `  bool ["<description>"]` | Specifies the config option as a *Boolean*;
    its value in `.config` will be either `Y` (built into the kernel image) or will
    not exist (will show up as a commented-out entry). |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| `  bool ["<description>"]` | 将配置选项指定为*布尔*；在`.config`中的值将是`Y`（内建到内核映像中）或不存在（将显示为已注释的条目）。'
- en: '| `  tristate ["description>"]` | Specifies the config option as *tristate*;
    its value in `.config` will be either `Y`,  `M` (built as a kernel module), or
    will not exist (will show up as a commented-out entry) |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| `  tristate ["description>"]` | 将配置选项指定为*三态*；在`.config`中的值将是`Y`、`M`（作为内核模块构建）或不存在（将显示为已注释的条目）。'
- en: '| `  int ["<description>"]` | Specifies the config option as taking an *integer*
    value. |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| `  int ["<description>"]` | 将配置选项指定为*整数*值。'
- en: '| `     range x-y` | The integer range is from `x` to `y`. |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| `     range x-y` | 整数范围从`x`到`y`。'
- en: '| `  default <value>` | Specifies the default value; use `y`, `m`, `n`, or
    another, as required.  |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| `  default <value>` | 指定默认值；根据需要使用`y`、`m`、`n`或其他值。'
- en: '| ` prompt "<description>"` | A sentence describing the kernel config. |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| ` prompt "<description>"` | 描述内核配置的句子。'
- en: '| `depends on "expr"` | Defines a dependency for the menu item; can have several
    with the `depends on FOO1 && FOO2 && (FOO3 &#124;&#124; FOO4)` type of syntax.
    |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| `depends on "expr"` | 为菜单项定义一个依赖项；可以使用`depends on FOO1 && FOO2 && (FOO3 &#124;&#124;
    FOO4)`类型的语法来定义多个依赖项。'
- en: '| `select <config> [if "expr"]` | Defines a reverse dependency. |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| `select <config> [if "expr"]` | 定义一个反向依赖项。'
- en: '| `help "help-text"` | Text to display when the `< Help >` button is selected.
    |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| `help "help-text"` | 在选择`<帮助>`按钮时显示的文本。'
- en: Table 2.6 – Kconfig, a few constructs
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.6 - Kconfig，一些构造
- en: 'To help understand the syntax, a few examples from `lib/Kconfig.debug` (the
    file that describes the menu items for the `Kernel Hacking` - kernel debugging,
    really - section of the UI) follow:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助理解语法，以下是来自`lib/Kconfig.debug`（描述UI的`Kernel Hacking`-内核调试，实际上-部分菜单项的文件）的一些示例：
- en: 'We will start with a simple one (the `CONFIG_DEBUG_INFO` option):'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从一个简单的开始（`CONFIG_DEBUG_INFO`选项）：
- en: '[PRE39]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, let''s look at the `CONFIG_FRAME_WARN` option. Notice `range` and the
    conditional default value syntax, as follows:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下`CONFIG_FRAME_WARN`选项。注意`range`和条件默认值语法，如下所示：
- en: '[PRE40]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, the `CONFIG_HAVE_DEBUG_STACKOVERFLOW` option is a simple Boolean; it''s
    either on or off. The `CONFIG_DEBUG_STACKOVERFLOW` option is also a Boolean. Notice
    how it depends on two other options, separated with a Boolean AND (`&&`) operator:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`CONFIG_HAVE_DEBUG_STACKOVERFLOW`选项是一个简单的布尔值；它要么开启，要么关闭。`CONFIG_DEBUG_STACKOVERFLOW`选项也是一个布尔值。请注意它如何依赖于另外两个选项，使用布尔AND（`&&`）运算符分隔：
- en: '[PRE41]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Alright! This completes our coverage for creating (or editing) a custom menu
    entry in the kernel config, and indeed this chapter.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！这完成了我们对在内核配置中创建（或编辑）自定义菜单条目的覆盖，也完成了本章。
- en: Summary
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you first learned how to obtain for yourself a Linux kernel
    source tree. You then understood its release (or version) nomenclature, the various
    types of Linux kernels (`-next` trees, `-rc`/mainline trees, stable, LTS, SLTS
    and distributions), and the basic kernel development workflow. Along the way,
    you even got a quick tour of the kernel source tree so that its layout is clearer.
    Next, you saw how to extract the compressed kernel source tree to disk and, critically,
    how to configure the kernel – a key step in the process. Furthermore, you learned
    how to customize the kernel menu, adding your own entries to it, and a bit about
    the kbuild system and the associated `Kconfig` files it uses, among others.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您首先学习了如何获取Linux内核源代码树。然后，您了解了其发布（或版本）命名法，各种类型的Linux内核（`-next`树，`-rc`/主线树，稳定版，LTS，SLTS和发行版），以及基本的内核开发工作流程。在这个过程中，您甚至快速浏览了内核源代码树，以便更清楚地了解其布局。接下来，您将看到如何将压缩的内核源代码树提取到磁盘上，并且关键的是如何配置内核-这是过程中的关键步骤。此外，您还学会了如何自定义内核菜单，向其中添加自己的条目，以及有关kbuild系统和相关的`Kconfig`文件的一些知识。
- en: Knowing how to fetch and configure the Linux kernel is a useful skill to possess.
    We have just begun this long and exciting journey. You will realize that with
    more experience and knowledge of kernel internals, drivers, and the target system
    hardware, your ability to fine-tune the kernel to your project's purpose will
    only get better.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何获取和配置Linux内核是一项有用的技能。我们刚刚开始了这段漫长而激动人心的旅程。您将意识到，随着对内核内部、驱动程序和目标系统硬件的更多经验和知识，您调整内核以适应项目目的的能力将会变得更好。
- en: We're halfway there; I suggest you first digest this material, and, importantly
    - try out the steps in this chapter, work on the questions/exercises, and browse
    through the *Further reading *section. Then, in the next chapter, let's actually
    build the 5.4.0 kernel and verify it!
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经走了一半的路；我建议您首先消化这些材料，重要的是-尝试本章中的步骤，解决问题/练习，并浏览*Further reading*部分。然后，在下一章中，让我们实际构建5.4.0内核并进行验证！
- en: Questions
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions).
    You will find some of the questions answered in the book''s GitHub repo: [https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn).'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一些问题供您测试对本章材料的了解：[https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/questions)。您会在本书的GitHub存储库中找到一些问题的答案：[https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming/tree/master/solutions_to_assgn)。
- en: Further reading
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To help you delve deeper into the subject with useful materials, we provide
    a rather detailed list of online references and links (and at times, even books)
    in a Further reading document in this book's GitHub repository. The *Further reading*
    document is available here: [https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md](https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md).
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您深入了解有用的材料，我们在本书的GitHub存储库中提供了一个相当详细的在线参考和链接列表（有时甚至包括书籍）的Further reading文档。
    *Further reading* 文档在这里可用：[https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md](https://github.com/PacktPublishing/Linux-Kernel-Programming/blob/master/Further_Reading.md)。
