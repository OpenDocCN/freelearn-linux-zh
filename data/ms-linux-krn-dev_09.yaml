- en: Interrupts and Deferred Work
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断和延迟工作
- en: 'An **interrupt** is an electrical signal delivered to the processor indicating
    occurrence of a significant event that needs immediate attention. These signals
    can originate either from external hardware (connected to the system) or from
    circuits within the processor. In this chapter we will look into the kernel''s
    interrupt management subsystem and explore the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**中断**是传递给处理器的电信号，指示发生需要立即处理的重大事件。这些信号可以来自系统连接的外部硬件或处理器内部的电路。在本章中，我们将研究内核的中断管理子系统，并探讨以下内容：'
- en: Programmable interrupt controllers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可编程中断控制器
- en: Interrupt vector table
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断向量表
- en: IRQs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IRQs
- en: IRQ chip and IRQ descriptors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IRQ芯片和IRQ描述符
- en: Registering and unregistering interrupt handlers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册和注销中断处理程序
- en: IRQ line-control operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IRQ线路控制操作
- en: IRQ stacks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IRQ堆栈
- en: Need for deferred routines
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟例程的需求
- en: Softirqs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软中断
- en: Tasklets
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务
- en: Workqueues
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作队列
- en: Interrupt signals and vectors
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断信号和向量
- en: When an interrupt originates from an external device, it is referred to as a
    **hardware interrupt**. These signals are generated by external hardware to seek
    the attention of the processor on occurrence of a significant external event,
    for instance a key hit on the keyboard, a click on a mouse button, or moving the
    mouse trigger hardware interrupts through which the processor is notified about
    the availability of data to be read. Hardware interrupts occur asynchronously
    with respect to the processor clock (meaning they can occur at random times),
    and hence are also termed as **asynchronous interrupts**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当中断来自外部设备时，称为**硬件中断**。这些信号是由外部硬件产生的，以寻求处理器对重大外部事件的关注，例如键盘上的按键、鼠标按钮的点击或移动鼠标触发硬件中断，通过这些中断处理器被通知有数据可供读取。硬件中断与处理器时钟异步发生（意味着它们可以在随机时间发生），因此也被称为**异步中断**。
- en: Interrupts triggered from within the CPU due to events generated by program
    instructions currently in execution are referred to as **software interrupts**.
    A software interrupt is caused either by an **exception** triggered by program
    instructions currently in execution or on execution of a privileged instruction
    that raises an interrupt. For instance, when a program instruction attempts to
    divide a number by zero, the arithmetic logic unit of the processor raises an
    interrupt called a divide-by-zero exception. Similarly, when a program in execution
    intends to invoke a kernel service call, it executes a special instruction (sysenter)
    that raises an interrupt to shift the processor into privileged mode, which paves
    the path for the execution of the desired service call. These events occur synchronously
    with respect to the processor's clock and hence are also called **synchronous
    interrupts**.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于当前执行的程序指令生成的事件而触发的CPU内部的中断被称为**软件中断**。软件中断是由当前执行的程序指令触发的**异常**引起的，或者在执行特权指令时引发中断。例如，当程序指令尝试将一个数字除以零时，处理器的算术逻辑单元会引发一个称为除零异常的中断。类似地，当正在执行的程序意图调用内核服务调用时，它执行一个特殊指令（sysenter），引发一个中断以将处理器转换到特权模式，为执行所需的服务调用铺平道路。这些事件与处理器时钟同步发生，因此也被称为**同步中断**。
- en: In response to the occurrence of an interrupt event, CPUs are designed to preempt
    the current instruction sequence or thread of execution, and execute a special
    function called **interrupt service routine** (**ISR**). To locate the appropriate
    ***ISR*** that corresponds to an interrupt event, **interrupt vector tables**
    are used. An **interrupt vector** is an address in memory that contains a reference
    to a software-defined **interrupt service** to be executed in response to an interrupt.
    Processor architectures define the total count of **interrupt vectors** supported,
    and describe the layout of each interrupt vector in memory. In general, for most
    processor architectures, all supported vectors are set up in memory as a list
    called an **interrupt vector table,** whose address is programmed into a processor
    register by the platform software.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在发生中断事件时，CPU被设计为抢占当前的指令序列或执行线程，并执行一个称为**中断服务例程**（**ISR**）的特殊函数。为了找到与中断事件对应的适当的***ISR***，使用**中断向量表**。**中断向量**是内存中包含对应于中断执行的软件定义**中断服务**的引用的地址。处理器架构定义支持的**中断向量**的总数，并描述内存中每个中断向量的布局。一般来说，对于大多数处理器架构，所有支持的向量都被设置在内存中作为一个称为**中断向量表**的列表，其地址由平台软件编程到处理器寄存器中。
- en: Let's consider specifics of the *x86* architecture as an example for better
    understanding. The x86 family of processors supports a total of 256 interrupt
    vectors, of which the first 32 are reserved for processor exceptions and the rest
    used for software and hardware interrupts. Implementation of a vector table by
    x86 is referred to as an **interrupt descriptor table (IDT)**, which is an array
    of descriptors of either 8 byte (for 32-bit machines) or 16 byte (for 64-bit *x86*
    machines) sizes. During early boot, the architecture-specific branch of the kernel
    code sets up the **IDT** in memory and programs the **IDTR** register (special
    x86 register) of the processor with the physical start address and length of the
    **IDT**. When an interrupt occurs, the processor locates relevant vector descriptors
    by multiplying the reported vector number by the size of the vector descriptor
    (*vector number x 8* on x86_32 machines, and *vector no x 16* on x86_64 machines)
    and adding the result to the base address of the **IDT.** Once a valid *vector
    descriptor* is reached, the processor continues with the execution of actions
    specified within the descriptor.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以*x86*架构为例，以便更好地理解。x86系列处理器支持总共256个中断向量，其中前32个保留用于处理器异常，其余用于软件和硬件中断。x86通过实现一个向量表来引用**中断描述符表（IDT）**，这是一个8字节（32位机器）或16字节（64位*x86*机器）大小的描述符数组。在早期引导期间，内核代码的特定于架构的分支在内存中设置**IDT**并将处理器的**IDTR**寄存器（特殊的x86寄存器）编程为**IDT**的物理起始地址和长度。当发生中断时，处理器通过将报告的向量编号乘以向量描述符的大小（*x86_32机器上的向量编号x8*，*x86_64机器上的向量编号x16*）并将结果加到**IDT**的基地址来定位相关的向量描述符。一旦到达有效的*向量描述符*，处理器将继续执行描述符中指定的操作。
- en: On x86 platforms, each *vector descriptor* implements a *gate* (interrupt, task,
    or trap)*,* which is used to transfer control of execution across segments. Vector
    descriptors representing hardware interrupts implement an *interrupt gate,* which
    refers to the base address and offset of the segment containing interrupt handler
    code. An *interrupt gate* disables all maskable interrupts before passing control
    to a specified interrupt handler. Vector descriptors representing *exceptions*
    and software interrupts implement a *trap gate,* which also refers to the location
    of code designated as a handler for the event. Unlike an *interrupt gate*, a *trap
    gate* does not disable maskable interrupts, which makes it suitable for execution
    of soft interrupt handlers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86平台上，每个*向量描述符*实现了一个*门（中断、任务或陷阱）*，用于在段之间传递执行控制。代表硬件中断的向量描述符实现了一个*中断门*，它指向包含中断处理程序代码的段的基地址和偏移量。*中断门*在将控制传递给指定的中断处理程序之前禁用所有可屏蔽中断。代表*异常*和软件中断的向量描述符实现了一个*陷阱门*，它也指向被指定为事件处理程序的代码的位置。与*中断门*不同，*陷阱门*不会禁用可屏蔽中断，这使其适用于执行软中断处理程序。
- en: Programmable interrupt controller
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可编程中断控制器
- en: 'Now let''s focus on external interrupts and explore how processors identify
    the occurrence of an external hardware interrupt, and how they discover the vector
    number associated with the interrupt. CPUs are designed with a dedicated input
    pin (intr pin) used to signal external interrupts. Each external hardware device
    capable of issuing interrupt requests usually consists of one or more output pins
    called **Interrupt Request lines (IRQ)**, used to signal an interrupt request
    on the CPU. All computing platforms use a hardware circuit called a **programmable
    interrupt controller (PIC)** to multiplex the CPU''s interrupt pin across various
    interrupt request lines. All of the existing IRQ lines originating from on-board
    device controllers are routed to input pins of the interrupt controller, which
    monitors each IRQ line for an interrupt signal, and upon arrival of an interrupt,
    converts the request into a cpu-understandable vector number and relays the interrupt
    signal on to the CPU''s interrupt pin. In simple words, a programmable interrupt
    controller multiplexes multiple device interrupt request lines into a single interrupt
    line of the processor:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们专注于外部中断，并探讨处理器如何识别外部硬件中断的发生，以及它们如何发现与中断相关联的向量编号。CPU设计有一个专用输入引脚（中断引脚），用于信号外部中断。每个能够发出中断请求的外部硬件设备通常由一个或多个输出引脚组成，称为**中断请求线（IRQ）**，用于在CPU上信号中断请求。所有计算平台都使用一种称为**可编程中断控制器（PIC）**的硬件电路，将CPU的中断引脚多路复用到各种中断请求线上。所有来自板载设备控制器的现有IRQ线路都被路由到中断控制器的输入引脚，该控制器监视每个IRQ线路以获取中断信号，并在中断到达时将请求转换为CPU可理解的向量编号，并将中断信号传递到CPU的中断引脚。简而言之，可编程中断控制器将多个设备中断请求线路多路复用到处理器的单个中断线上：
- en: '![](img/00049.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00049.jpeg)'
- en: 'Design and implementation of interrupt controllers is platform specific*.*
    Intel *x86* multiprocessor platforms use **Advanced Programmable Interrupt Controller**
    (**APIC**). The **APIC** design splits interrupt controller functionality into
    two distinct chipsets: the first component is an **I/O APIC** that resides on
    the system bus. All shared peripheral hardware IRQ lines are routed to the I/O
    APIC; this chip translates an interrupt request into vector code***.*** The second
    is a per-CPU controller called **Local APIC** (usually integrated into the processor
    core) which delivers hardware interrupts to specific CPU cores. **I/O APIC** routes
    the interrupt events to a **Local APIC** of the chosen CPU core. It is programmed
    with a redirection table, which is used for making interrupt routing decisions.
    CPU **Local APICs** manage all external interrupts for a specific CPU core; additionally,
    they deliver events from CPU local hardware such as timers and can also receive
    and generate **inter-processor interrupts** **(IPIs)** that can occur on an SMP
    platform.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 中断控制器的设计和实现是特定于平台的。英特尔x86多处理器平台使用高级可编程中断控制器（APIC）。APIC设计将中断控制器功能分为两个不同的芯片组件：第一个组件是位于系统总线上的I/O
    APIC。所有共享的外围硬件IRQ线路都被路由到I/O APIC；该芯片将中断请求转换为向量代码。第二个是称为本地APIC的每CPU控制器（通常集成到处理器核心中），它将硬件中断传递给特定的CPU核心。I/O
    APIC将中断事件路由到所选CPU核心的本地APIC。它被编程为一个重定向表，用于进行中断路由决策。CPU本地APIC管理特定CPU核心的所有外部中断；此外，它们传递来自CPU本地硬件的事件，如定时器，并且还可以接收和生成SMP平台上可能发生的处理器间中断（IPI）。
- en: 'The following diagram depicts the split architecture of **APIC**. The flow
    of events now begins with individual devices raising IRQ on the **I/O APIC**,
    which routes the request to a specific **Local APIC**, which in turn delivers
    the interrupt to a specific CPU core:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了APIC的分裂架构。现在事件的流程始于各个设备在I/O APIC上引发IRQ，后者将请求路由到特定的本地APIC，后者又将中断传递给特定的CPU核心：
- en: '![](img/00050.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00050.jpeg)'
- en: Similar to the **APIC** architecture, multicore ARM platforms split the **generic
    interrupt controller** (**GIC**) implementation into two. The first component
    is called a **distributor,** which is global to the system and has several peripheral
    hardware interrupt sources physically routed to it. The second component is replicated
    per-CPU and is called the **cpu interface**. The *distributor* component is programmed
    with distribution logic of **shared peripheral interrupts**(***SPI)*** to known
    CPU interfaces.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于APIC架构，多核ARM平台将通用中断控制器（GIC）的实现分为两部分。第一个组件称为分发器，它是全局的，有几个外围硬件中断源物理路由到它。第二个组件是每CPU复制的，称为CPU接口。分发器组件被编程为将共享外围中断（SPI）的分发逻辑路由到已知的CPU接口。
- en: Interrupt controller operations
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断控制器操作
- en: 'The architecture-specific branch of the kernel code implements interrupt controller
    specific operations for management of IRQ lines such as masking/unmasking individual
    interrupts, setting priorities, and SMP affinity. These operations are required
    to be invoked from architecture-independent code paths of the kernel for manipulation
    of individual IRQ lines, and to facilitate such calls, the kernel defines an architecture-independent
    abstraction layer through a structure called `struct irq_chip`. This structure
    can be found in the kernel header `<include/linux/irq.h>`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 内核代码的体系结构特定分支实现了中断控制器特定操作，用于管理IRQ线路，例如屏蔽/取消屏蔽单个中断，设置优先级和SMP亲和性。这些操作需要从内核的体系结构无关代码路径中调用，以便操纵单个IRQ线路，并为了促进这样的调用，内核通过一个称为`struct
    irq_chip`的结构定义了一个体系结构无关的抽象层。该结构可以在内核头文件`<include/linux/irq.h>`中找到：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The structure declares a set of function pointers to account for all peculiarities
    of IRQ chips found across various hardware platforms. Thus, a particular instance
    of the structure defined by board-specific code usually supports only a subset
    of possible operations. Following are x86 multicore platform versions of `irq_chip`
    instances defining operations of I/O APIC and LAPIC.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构声明了一组函数指针，以考虑各种硬件平台上发现的IRQ芯片的所有特殊性。因此，由特定于板级的代码定义的结构的特定实例通常只支持可能操作的子集。以下是定义I/O
    APIC和LAPIC操作的x86多核平台版本的`irq_chip`实例。
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: IRQ descriptor table
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断描述符表
- en: Another important abstraction is with respect to IRQ numbers associated with
    hardware interrupts. Interrupt controllers identify each IRQ source with a unique
    hardware IRQ number. The kernel's generic interrupt-management layer maps each
    hardware IRQ to a unique identifier called Linux IRQ; these numbers abstract hardware
    IRQs, thereby ensuring portability of kernel code. All of the peripheral device
    drivers are programmed to use the Linux IRQ number to bind or register their interrupt
    handlers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的抽象是与与硬件中断相关的IRQ号。中断控制器使用唯一的硬件IRQ号标识每个IRQ源。内核的通用中断管理层将每个硬件IRQ映射到称为Linux
    IRQ的唯一标识符；这些数字抽象了硬件IRQ，从而确保内核代码的可移植性。所有外围设备驱动程序都被编程为使用Linux IRQ号来绑定或注册它们的中断处理程序。
- en: 'Linux IRQs are represented by IRQ descriptor structure, which is defined by
    `struct irq_desc`; for each IRQ source, an instance of this structure is enumerated
    during early kernel boot. A list of IRQ descriptors is maintained in an array
    indexed by the IRQ number, called the IRQ descriptor table:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Linux IRQ由IRQ描述符结构表示，由`struct irq_desc`定义；在早期内核引导期间，对于每个IRQ源，将枚举此结构的一个实例。IRQ描述符的列表以IRQ号为索引，称为IRQ描述符表：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`irq_data` is an instance of `struct irq_data`, and this contains low-level
    information that is relevant for interrupt management, such as Linux IRQ number,
    hardware IRQ number, and a pointer to interrupt controller operations (`irq_chip`)
    among other important fields:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`irq_data`是`struct irq_data`的一个实例，其中包含与中断管理相关的低级信息，例如Linux中断号、硬件中断号，以及指向中断控制器操作（`irq_chip`）的指针等其他重要字段：'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `handle_irq` element of the `irq_desc` structure is a function pointer of
    type `irq_flow_handler_t`, which refers to a high-level function that deals with
    flow management on the line. The generic irq layer provides as set of predefined
    irq flow functions; an appropriate routine is assigned to each interrupt line
    based on its type.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`irq_desc`结构的`handle_irq`元素是一个`irq_flow_handler_t`类型的函数指针，它指的是处理线路上流管理的高级函数。通用中断层提供了一组预定义的中断流函数；根据其类型，每个中断线路都分配了适当的例程。'
- en: '`handle_level_irq()`: Generic implementation for level-triggered interrupts'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handle_level_irq()`：电平触发中断的通用实现'
- en: '`handle_edge_irq()`: Generic implementation for edge-triggered interrupts'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handle_edge_irq()`：边沿触发中断的通用实现'
- en: '`handle_fasteoi_irq()`: Generic implementation for interrupts that only need
    an EOI at the end of the handler'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handle_fasteoi_irq()`：只需要在处理程序结束时进行EOI的中断的通用实现'
- en: '`handle_simple_irq()`: Generic implementation for simple interrupts'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handle_simple_irq()`：简单中断的通用实现'
- en: '`handle_percpu_irq()`: Generic implementation for per-CPU interrupts'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handle_percpu_irq()`：每CPU中断的通用实现'
- en: '`handle_bad_irq()`: Used for spurious interrupts'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handle_bad_irq()`：用于虚假中断'
- en: 'The `*action` element of the `irq_desc` structure is a pointer to one or a
    chain of action descriptors, which contain driver-specific interrupt handlers
    among other important elements. Each action descriptor is an instance of `struct
    irqaction` defined in the kernel header `<linux/interrupt.h>`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`irq_desc`结构的`*action`元素是指向一个或一组动作描述符的指针，其中包含特定于驱动程序的中断处理程序等其他重要元素。每个动作描述符都是在内核头文件`<linux/interrupt.h>`中定义的`struct
    irqaction`的实例：'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: High-level interrupt-management interfaces
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级中断管理接口
- en: The generic IRQ layer provides a set of function interfaces for device drivers
    to grab IRQ descriptors and bind interrupt handlers, release IRQs, enable or disable
    interrupt lines, and so on. We will explore all of the generic interfaces in this
    section.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通用IRQ层提供了一组函数接口，供设备驱动程序获取IRQ描述符和绑定中断处理程序，释放IRQ，启用或禁用中断线等。我们将在本节中探讨所有通用接口。
- en: Registering an interrupt handler
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册中断处理程序
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`request_irq()` instantiates an `irqaction` object with values passed as parameters
    and binds it to the `irq_desc` specified as the first (`irq`) parameter. This
    call allocates interrupt resources and enables the interrupt line and IRQ handling.
    `handler` is a function pointer of type `irq_handler_t`, which takes the address
    of a driver-specific interrupt handler routine. `flags` is a bitmask of options
    related to interrupt management. Flag bits are defined in the kernel header `<linux/interrupt.h>:`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`request_irq()`使用传递的值实例化一个`irqaction`对象，并将其绑定到作为第一个（`irq`）参数指定的`irq_desc`。此调用分配中断资源并启用中断线和IRQ处理。`handler`是一个`irq_handler_t`类型的函数指针，它接受特定于驱动程序的中断处理程序例程的地址。`flags`是与中断管理相关的选项的位掩码。标志位在内核头文件`<linux/interrupt.h>`中定义：'
- en: '`IRQF_SHARED`: Used while binding an interrupt handler to a shared IRQ line.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IRQF_SHARED`：在将中断处理程序绑定到共享的IRQ线时使用。'
- en: '`IRQF_PROBE_SHARED`: Set by callers when they expect sharing mismatches to
    occur.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IRQF_PROBE_SHARED`：当调用者期望共享不匹配时设置。'
- en: '`IRQF_TIMER`: Flag to mark this interrupt as a timer interrupt.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IRQF_TIMER`：标记此中断为定时器中断。'
- en: '`IRQF_PERCPU`: Interrupt is per CPU.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IRQF_PERCPU`：中断是每CPU的。'
- en: '`IRQF_NOBALANCING`: Flag to exclude this interrupt from IRQ balancing.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IRQF_NOBALANCING`：标志，用于排除此中断不参与IRQ平衡。'
- en: '`IRQF_IRQPOLL`: Interrupt is used for polling (only the interrupt that is registered
    first in a shared interrupt is considered for performance reasons).'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IRQF_IRQPOLL`：中断用于轮询（仅考虑在共享中断中首先注册的中断以提高性能）。'
- en: '`IRQF_NO_SUSPEND`: Do not disable this IRQ during suspend. Does not guarantee
    that this interrupt will wake the system from a suspended state.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IRQF_NO_SUSPEND`：在挂起期间不禁用此IRQ。不能保证此中断将唤醒系统从挂起状态。'
- en: '`IRQF_FORCE_RESUME`: Force-enable it on resume even if `IRQF_NO_SUSPEND` is
    set.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IRQF_FORCE_RESUME`：即使设置了`IRQF_NO_SUSPEND`，也在恢复时强制启用它。'
- en: '`IRQF_EARLY_RESUME`: Resume IRQ early during syscore instead of at device resume
    time.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IRQF_EARLY_RESUME`：在syscore期间提前恢复IRQ，而不是在设备恢复时。'
- en: '`IRQF_COND_SUSPEND`: If the IRQ is shared with a `NO_SUSPEND` user, execute
    this interrupt handler after suspending interrupts. For system wakeup devices,
    users need to implement wakeup detection in their interrupt handlers.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IRQF_COND_SUSPEND`：如果IRQ与`NO_SUSPEND`用户共享，则在挂起中断后执行此中断处理程序。对于系统唤醒设备，用户需要在其中断处理程序中实现唤醒检测。'
- en: Since each flag value is a bit, a logical OR (that is, |) of a subset of these
    can be passed, and if none apply, then a value 0 for the `flags` parameter is
    valid. The address assigned to `dev` is considered as a unique cookie and serves
    as an identifier for the action instance in a shared IRQ case. The value of this
    parameter can be NULL while registering interrupt handlers without the `IRQF_SHARED`
    flag.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个标志值都是一个位，可以传递这些标志的子集的逻辑OR（即|），如果没有适用的标志，则`flags`参数的值为0是有效的。分配给`dev`的地址被视为唯一的cookie，并用作共享IRQ情况下操作实例的标识符。在注册中断处理程序时，此参数的值可以为NULL，而不使用`IRQF_SHARED`标志。
- en: On success, `request_irq()` returns zero; a nonzero return value indicates failure
    to register the specified interrupt handler. The return error code `-EBUSY` denotes
    failure to register or bind the handler to a specified IRQ that is already in
    use.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时，`request_irq()`返回零；非零返回值表示注册指定中断处理程序失败。返回错误代码`-EBUSY`表示注册或绑定处理程序到已经使用的指定IRQ失败。
- en: 'Interrupt handler routines have the following prototype:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 中断处理程序例程具有以下原型：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`irq` specifies the IRQ number, and `dev_id` is the unique cookie used while
    registering the handler. `irqreturn_t` is a typedef to an enumerated integer constant:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`irq`指定了IRQ号码，而`dev_id`是在注册处理程序时使用的唯一cookie。`irqreturn_t`是一个枚举整数常量的typedef：'
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The interrupt handler should return `IRQ_NONE` to indicate that the interrupt
    was not handled. It is also used to indicate that the source of the interrupt
    was not from its device in a shared IRQ case. When interrupt handling has completed
    normally, it must return `IRQ_HANDLED` to indicate success. `IRQ_WAKE_THREAD`
    is a special flag, returned to wake up the threaded handler; we elaborate on it
    in the next section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 中断处理程序应返回`IRQ_NONE`以指示未处理中断。它还用于指示中断的来源不是来自其设备的情况下的共享IRQ。当中断处理正常完成时，必须返回`IRQ_HANDLED`以指示成功。`IRQ_WAKE_THREAD`是一个特殊标志，用于唤醒线程处理程序；我们将在下一节详细介绍它。
- en: Deregistering an interrupt handler
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注销中断处理程序
- en: 'A driver''s interrupt handlers can be deregistered through a call to the `free_irq()`
    routine:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序的中断处理程序可以通过调用`free_irq()`例程来注销：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`dev_id` is the unique cookie (assigned while registering the handler) to identify
    the handler to be deregistered in a shared IRQ case; this argument can be NULL
    for other cases. This function is a potential blocking call, and must not be invoked
    from an interrupt context: it blocks calling context until completion of any interrupt
    handler currently in execution, for the specified IRQ line.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`dev_id`是用于在共享IRQ情况下标识要注销的处理程序的唯一cookie（在注册处理程序时分配）；对于其他情况，此参数可以为NULL。此函数是一个潜在的阻塞调用，并且不得从中断上下文中调用：它会阻塞调用上下文，直到指定的IRQ线路上的任何中断处理程序的执行完成。'
- en: Threaded interrupt handlers
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程中断处理程序
- en: 'Handlers registered through `request_irq()` are executed by the interrupt-handling
    path of the kernel. This code path is asynchronous, and runs by suspending scheduler
    preemption and hardware interrupts on the local processor, and so is referred
    to as a hard IRQ context. Thus, it is imperative to program the driver''s interrupt
    handler routines to be short (do as little work as possible) and atomic (non blocking),
    to ensure responsiveness of the system. However, not all hardware interrupt handlers
    can be short and atomic: there are a magnitude of convoluted devices generating
    interrupt events, whose responses involve complex variable-time operations.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`request_irq()`注册的处理程序由内核的中断处理路径执行。这条代码路径是异步的，通过暂停本地处理器上的调度程序抢占和硬件中断来运行，因此被称为硬中断上下文。因此，必须将驱动程序的中断处理程序编程为简短（尽量少做工作）和原子（非阻塞），以确保系统的响应性。然而，并非所有硬件中断处理程序都可以简短和原子：有许多复杂设备生成中断事件，其响应涉及复杂的可变时间操作。
- en: Conventionally, drivers are programmed to handle such complications with a split-handler
    design for the interrupt handler, called **top half** and **bottom half**. Top
    half routines are invoked in hard interrupt context, and these functions are programmed
    to execute *interrupt critical* operations, such as physical I/O on the hardware
    registers, and schedule the bottom half for deferred execution. Bottom half routines
    are usually programmed to deal with the rest of the *interrupt non-critical* and
    *deferrable work*, such as processing of data generated by the top half, interacting
    with process context, and accessing user address space. The kernel offers multiple
    mechanisms for scheduling and execution of bottom half routines, each with a distinct
    interface API and policy of execution. We'll elaborate on the design and usage
    details of formal bottom half mechanisms in the next section.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，驱动程序被编程为处理中断处理程序的这种复杂性，采用了分离处理程序设计，称为**顶半部**和**底半部**。顶半部例程在硬中断上下文中被调用，这些函数被编程为执行*中断关键*操作，例如对硬件寄存器的物理I/O，并安排底半部进行延迟执行。底半部例程通常用于处理*中断非关键*和*可推迟工作*，例如处理顶半部生成的数据，与进程上下文交互以及访问用户地址空间。内核提供了多种机制来调度和执行底半部例程，每种机制都有不同的接口API和执行策略。我们将在下一节详细介绍正式底半部机制的设计和用法细节。
- en: 'As an alternative to using formal bottom-half mechanisms, the kernel supports
    setting up interrupt handlers that can execute in a thread context, called **threaded
    interrupt handlers***.* Drivers can set up threaded interrupt handlers through
    an alternate interface routine called `request_threaded_irq()`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用正式底半部机制的替代方案，内核支持设置可以在线程上下文中执行的中断处理程序，称为**线程中断处理程序**。驱动程序可以通过另一个名为`request_threaded_irq()`的接口例程设置线程中断处理程序：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The function assigned to `handler` serves as the primary interrupt handler
    that executes in a hard IRQ context. The routine assigned to `thread_fn` is executed
    in a thread context, and is scheduled to run when the primary handler returns
    `IRQ_WAKE_THREAD`. With this split handler setup, there are two possible use cases:
    the primary handler can be programmed to execute interrupt-critical work and defer
    non-critical work to the thread handler for later execution, similar to that of
    the bottom half. The alternative is a design that defers the entire interrupt-handling
    code into the thread handler and restricts the primary handler only for verification
    of the interrupt source and waking up thread routine. This use case might require
    the corresponding interrupt line to be masked until completion of the thread handler,
    to avoid the nesting of interrupts. This can be accomplished either by programming
    the primary handler to turn off the interrupt at source before waking up the thread
    handler or through a flag bit `IRQF_ONESHOT` assigned while registering the threaded
    interrupt handler.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给`handler`的函数作为在硬中断上下文中执行的主要中断处理程序。分配给`thread_fn`的例程在线程上下文中执行，并在主处理程序返回`IRQ_WAKE_THREAD`时被调度运行。通过这种分离处理程序设置，有两种可能的用例：主处理程序可以被编程为执行中断关键工作，并将非关键工作推迟到线程处理程序以供以后执行，类似于底半部分。另一种设计是将整个中断处理代码推迟到线程处理程序，并将主处理程序限制为验证中断源并唤醒线程例程。这种用例可能需要相应的中断线路在线程处理程序完成之前被屏蔽，以避免中断的嵌套。这可以通过编程主处理程序在唤醒线程处理程序之前关闭中断源或通过在注册线程中断处理程序时分配的标志位`IRQF_ONESHOT`来实现。
- en: 'The following are `irqflags` related to threaded interrupt handlers:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与线程中断处理程序相关的`irqflags`：
- en: '`IRQF_ONESHOT`: The interrupt is not re-enabled after the hard IRQ handler
    is finished. This is used by threaded interrupts that need to keep the IRQ line
    disabled until the threaded handler has been run.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IRQF_ONESHOT`：硬IRQ处理程序完成后不会重新启用中断。这由需要保持IRQ线禁用直到线程处理程序运行完毕的线程化中断使用。'
- en: '`IRQF_NO_THREAD`: The interrupt cannot be threaded. This is used in shared
    IRQs to restrict the use of threaded interrupt handlers.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IRQF_NO_THREAD`：中断不能被线程化。这在共享IRQ中用于限制使用线程化中断处理程序。'
- en: 'A call to this routine with NULL assigned to `handler` will cause the kernel
    to use the default primary handler, which simply returns `IRQ_WAKE_THREAD`. And
    a call to this function with NULL assigned to `thread_fn` is synonymous with `request_irq()`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此例程并将NULL分配给`handler`将导致内核使用默认的主处理程序，该处理程序简单地返回`IRQ_WAKE_THREAD`。而将NULL分配给`thread_fn`调用此函数等同于`request_irq()`：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Another alternate interface for setting up an interrupt handler is `request_any_context_irq()`.
    This routine has a similar signature to that of `requeust_irq()` but slightly
    varies in its functionality:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 设置中断处理程序的另一种替代接口是`request_any_context_irq()`。此例程具有与`request_irq()`类似的签名，但在功能上略有不同：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function differs from `request_irq()` in that it looks into the IRQ descriptor
    for properties of the interrupt line as set up by the architecture-specific code,
    and decides whether to establish the function assigned as a traditional hard IRQ
    handler or as a threaded interrupt handler. On success, `IRQC_IS_HARDIRQ` is returned
    if the handler was established to run in hard IRQ context, or `IRQC_IS_NESTED`
    otherwise.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数与`request_irq()`的不同之处在于，它查看由特定于体系结构的代码设置的IRQ描述符的中断线属性，并决定是否将分配的函数建立为传统的硬IRQ处理程序或作为线程中断处理程序。成功时，如果已建立处理程序以在硬IRQ上下文中运行，则返回`IRQC_IS_HARDIRQ`，否则返回`IRQC_IS_NESTED`。
- en: Control interfaces
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制接口
- en: 'The generic IRQ layer provides routines to carry out control operations on
    IRQ lines. Following is the list of functions for masking and unmasking specific
    IRQ lines:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的IRQ层提供了对IRQ线进行控制操作的例程。以下是用于屏蔽和取消屏蔽特定IRQ线的函数列表：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This disables the specified IRQ line by manipulating the counter in the IRQ
    descriptor structure. This routine is a possible blocking call, as it waits until
    any running handlers for this interrupt complete. Alternatively, the function
    `disable_irq_nosync()` can also be used to *disable* the given IRQ line; this
    call does not check and wait for any running handlers for the given interrupt
    line to complete:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过操作IRQ描述符结构中的计数器来禁用指定的IRQ线。此例程可能是一个阻塞调用，因为它会等待此中断的任何运行处理程序完成。另外，也可以使用函数`disable_irq_nosync()`来*禁用*给定的IRQ线；此调用不会检查并等待给定中断线的任何运行处理程序完成：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Disabled IRQ lines can be enabled with a call to:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用以下函数来启用已禁用的IRQ线：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that IRQ enable and disable operations nest, that is, multiple calls to
    *disable* an IRQ line require the same number of *enable* calls for that IRQ line
    to be reenabled. This means that `enable_irq()` will enable the given IRQ only
    when a call to it matches the last *disable* operation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，IRQ启用和禁用操作是嵌套的，即，多次*禁用*IRQ线的调用需要相同数量的*启用*调用才能重新启用该IRQ线。这意味着`enable_irq()`只有在调用它与最后的*禁用*操作匹配时才会启用给定的IRQ。
- en: 'By choice, interrupts can also be disabled/enabled for the local CPU; the following
    pairs of macros can be used for the same:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 可以选择为本地CPU禁用/启用中断；以下宏对应用于相同目的：
- en: '`local_irq_disable()`: To disable interrupts on the local processor.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local_irq_disable()`：在本地处理器上禁用中断。'
- en: '`local_irq_enable()`: Enables interrupts for the local processor.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local_irq_enable()`：为本地处理器启用中断。'
- en: '`local_irq_save(unsigned long flags)`: Disables interrupts on the local CPU
    by saving current interrupt state in *flags*.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local_irq_save(unsigned long flags)`：通过将当前中断状态保存在*flags*中，在本地CPU上禁用中断。'
- en: '`local_irq_restore(unsigned long flags)`: Enables interrupts on the local CPU
    by restoring interrupts to a previous state.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local_irq_restore(unsigned long flags)`：通过将中断恢复到先前的状态，在本地CPU上启用中断。'
- en: IRQ stacks
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IRQ堆栈
- en: 'Historically, for most architectures, interrupt handlers shared the kernel
    stack of the running process that was interrupted. As discussed in the first chapter,
    the process kernel stack is typically 8 KB for 32-bit architectures and 16 KB
    for 64-bit architectures. A fixed kernel stack might not always be enough for
    kernel work and IRQ processing routines, resulting in judicious allocation of
    data both by kernel code and interrupt handlers. To address this, the kernel build
    (for a few architectures) is configured by default to set up an additional per-CPU
    hard IRQ stack for use by interrupt handlers, and a per-CPU soft IRQ stack for
    use by software interrupt code. Following are the x86-64 bit architecture-specific
    stack declarations in kernel header `<arch/x86/include/asm/processor.h>`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，对于大多数体系结构，中断处理程序共享了被中断的运行进程的内核堆栈。正如第一章所讨论的，32位体系结构的进程内核堆栈通常为8 KB，而64位体系结构为16
    KB。固定的内核堆栈可能并不总是足够用于内核工作和IRQ处理例程，导致内核代码和中断处理程序都需要谨慎地分配数据。为了解决这个问题，内核构建（对于一些体系结构）默认配置为为中断处理程序设置每个CPU硬IRQ堆栈，并为软中断代码设置每个CPU软IRQ堆栈。以下是内核头文件`<arch/x86/include/asm/processor.h>`中特定于x86-64位体系结构的堆栈声明：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Apart from these, x86-64-bit builds also include special stacks; more details
    can be found in the kernel source documentation `<x86/kernel-stacks>`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，x86-64位构建还包括特殊的堆栈；更多细节可以在内核源代码文档`<x86/kernel-stacks>`中找到：
- en: Double fault stack
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双重故障堆栈
- en: Debug stack
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试堆栈
- en: NMI stack
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NMI堆栈
- en: Mce stack
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mce堆栈
- en: Deferred work
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟工作
- en: As introduced in an earlier section, **bottom halves** are kernel mechanisms
    for executing deferred work, and can be engaged by any kernel code to defer execution
    of non-critical work until some time in the future. To support implementation
    and for management of deferred routines, the kernel implements special frameworks,
    called **softirqs**, **tasklets**, and **work queues**. Each of these frameworks
    constitute a set of data structures, and function interfaces, used for registering,
    scheduling, and queuing of the bottom half routines. Each mechanism is designed
    with a distinct *policy* for management and execution of bottom halfs. Drivers
    and other kernel services that require deferred execution will need to bind and
    schedule their BH routines through the appropriate framework.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节介绍的，**底半部**是内核机制，用于执行延迟工作，并且可以由任何内核代码参与，以推迟对非关键工作的执行，直到将来的某个时间。为了支持实现和管理延迟例程，内核实现了特殊的框架，称为**softirqs**、**tasklets**和**work
    queues**。每个这些框架都包括一组数据结构和函数接口，用于注册、调度和排队底半部例程。每种机制都设计有一个独特的*策略*来管理和执行底半部。需要延迟执行的驱动程序和其他内核服务将需要通过适当的框架绑定和调度它们的BH例程。
- en: Softirqs
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Softirqs
- en: The term **softirq** loosely translates to **soft interrupt**, and as the name
    suggests, deferred routines managed by this framework are executed at a high priority
    but with hard interrupt lines enabled*.* Thus*,* softirq bottom halves (or softirqs)
    can preempt all other tasks except hard interrupt handlers. However, usage of
    softirqs is restricted to static kernel code and this mechanism is not available
    for dynamic kernel modules.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**softirq**大致翻译为**软中断**，正如其名称所示，由该框架管理的延迟例程以高优先级执行，但启用了硬中断线*。因此，softirq底半部（或softirqs）可以抢占除硬中断处理程序之外的所有其他任务。然而，softirq的使用仅限于静态内核代码，这种机制对于动态内核模块不可用。
- en: 'Each softirq is represented through an instance of type `struct softirq_action`
    declared in the kernel header `<linux/interrupt.h>`. This structure contains a
    function pointer that can hold the address of the bottom half routine:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每个softirq通过在内核头文件`<linux/interrupt.h>`中声明的`struct softirq_action`类型的实例表示。该结构包含一个函数指针，可以保存底半部例程的地址：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Current versions of the kernel have 10 softirqs, each indexed through an enum
    in the kernel header `<linux/interrupt.h>`. These indexes serve as an identity
    and are treated as the relative priority of the softirq, and entries with lower
    indexes are considered higher in priority, with index 0 being the highest priority
    softirq:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的内核有10个softirq，每个通过内核头文件`<linux/interrupt.h>`中的枚举索引。这些索引作为标识，并被视为softirq的相对优先级，具有较低索引的条目被视为优先级较高，索引0为最高优先级的softirq：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The kernel source file `<kernel/softirq.c>` declares an array called `softirq_vec`
    of size `NR_SOFTIRQS`, with each offset containing a `softirq_action` instance
    of the corresponding softirq indexed in the enum:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 内核源文件`<kernel/softirq.c>`声明了一个名为`softirq_vec`的数组，大小为`NR_SOFTIRQS`，每个偏移量包含一个对应softirq枚举中的`softirq_action`实例：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Framework provides a function `open_softriq()` used for initializing the softirq
    instance with the corresponding bottom-half routine:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 框架提供了一个函数`open_softriq()`，用于使用相应的底半部例程初始化softirq实例：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`nr` is the index of the softirq to be initialized and `*action` is a function
    pointer to be initialized with the address of the bottom-half routine. The following
    code excerpt is taken from the timer service, and shows the invocation of `open_softirq`
    to register a softirq:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`nr`是要初始化的softirq的索引，`*action`是要用底半部例程的地址初始化的函数指针。以下代码摘录来自定时器服务，并显示了调用`open_softirq`来注册softirq：'
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Kernel services can signal the execution of softirq handlers using a function
    `raise_softirq()`. This function takes the index of the softirq as an argument:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 内核服务可以使用函数`raise_softirq()`来发出softirq处理程序的执行。此函数以softirq的索引作为参数：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following code excerpt is from `<kernel/time/timer.c>`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码摘录来自`<kernel/time/timer.c>`：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The kernel maintains a per-CPU bitmask for keeping track of softirqs raised
    for execution, and the function `raise_softirq()` sets the corresponding bit (index
    mentioned as argument) in the local CPUs softirq bitmask to mark the specified
    softirq as pending.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 内核维护了一个每CPU位掩码，用于跟踪为执行而引发的softirq，并且函数`raise_softirq()`设置本地CPU的softirq位掩码中的相应位（作为参数提到的索引）以标记指定的softirq为待处理。
- en: Pending softirq handlers are checked and executed at various points in the kernel
    code. Principally, they are executed in the interrupt context, immediately after
    the completion of hard interrupt handlers with IRQ lines enabled. This guarantees
    swift processing of softirqs raised from hard interrupt handlers, resulting in
    optimal cache usage. However, the kernel allows an arbitrary task to suspend execution
    of softirq processing on a local processor either through `local_bh_disable()`
    or `spin_lock_bh()` calls. Pending softirq handlers are executed in the context
    of an arbitrary task that re-enables softirq processing by invoking either `local_bh_enable()`
    or `spin_unlock_bh()` calls. And lastly, softirq handlers can also be executed
    by a per-CPU kernel thread `ksoftirqd`*,* which is woken up when a softirq is
    raised by any process-context kernel routine. This thread is also woken up from
    the interrupt context when too many softirqs accumulate due to high load.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 待处理的softirq处理程序在内核代码的各个点检查并执行。主要是在中断上下文中执行，在硬中断处理程序完成后立即执行，同时启用IRQ线。这保证了从硬中断处理程序引发的softirq的快速处理，从而实现了最佳的缓存使用。然而，内核允许任意任务通过`local_bh_disable()`或`spin_lock_bh()`调用来暂停本地处理器上的softirq处理。待处理的softirq处理程序在重新启用softirq处理的任意任务的上下文中执行，通过调用`local_bh_enable()`或`spin_unlock_bh()`来重新启用softirq处理。最后，softirq处理程序也可以由每个CPU内核线程`ksoftirqd`执行，当任何进程上下文内核例程引发softirq时，它会被唤醒。当由于负载过高而积累了太多的softirq时，该线程也会从中断上下文中被唤醒。
- en: Softirqs are most suitable for completion of priority work deferred from hard
    interrupt handlers since they run immediately on completion of hard interrupt
    handlers. However, softirqs handlers are reentrant, and must be programmed to
    engage appropriate protection mechanisms while accessing data structures, if any.
    The reentrant nature of softirqs may cause unbounded latencies, impacting the
    efficiency of the system as a whole, which is why their usage is restricted, and
    new ones are almost never added, unless it is absolute necessity for the execution
    of high-frequency threaded deferred work. For all other types of deferred work,
    tasklets and work queues are suggested.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Softirqs最适合用于完成从硬中断处理程序推迟的优先级工作，因为它们在硬中断处理程序完成后立即运行。但是，softirq处理程序是可重入的，并且必须编程以在访问数据结构时使用适当的保护机制。softirq的可重入性可能导致无界延迟，影响整个系统的效率，这就是为什么它们的使用受到限制，几乎不会添加新的softirq，除非绝对需要执行高频率的线程推迟工作。对于所有其他类型的推迟工作，建议使用任务队列。
- en: Tasklets
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务队列
- en: 'The **tasklet** mechanism is a sort of wrapper around the softirq framework;
    in fact, tasklet handlers are executed by softirqs. Unlike softirqs, tasklets
    are not reentrant, which guarantees that the same tasklet handler can never run
    concurrently. This helps minimize overall latencies, provided programmers examine
    and impose relevant checks to ensure that work done in a tasklet is non-blocking
    and atomic. Another difference is with respect to their usage: unlike softirqs
    (which are restricted), any kernel code can use tasklets, and this includes dynamically
    linked services.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**任务队列**机制是对softirq框架的一种包装；事实上，任务队列处理程序是由softirq执行的。与softirq不同，任务队列不是可重入的，这保证了相同的任务队列处理程序永远不会并发运行。这有助于最小化总体延迟，前提是程序员检查并施加相关检查，以确保任务队列中的工作是非阻塞和原子的。另一个区别是在使用方面：与受限的softirq不同，任何内核代码都可以使用任务队列，包括动态链接的服务。'
- en: 'Each tasklet is represented through an instance of type `struct tasklet_struct`
    declared in kernel header `<linux/interrupt.h>`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每个任务队列通过在内核头文件`<linux/interrupt.h>`中声明的`struct tasklet_struct`类型的实例表示：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Upon initialization, `*func` holds the address of the handler routine and `data`
    is used to pass a data blob as a parameter to the handler routine during invocation.
    Each tasklet carries a `state`, which can be either `TASKLET_STATE_SCHED`, which
    indicates that it is scheduled for execution, or `TASKLET_STATE_RUN`, which indicates
    it is in execution. An atomic counter is used to *enable* or *disable* a tasklet;
    when `count` equals a *non-zero* value*,* it indicates that the tasklet is *disabled,*
    and *zero* indicates that it is *enabled*. A disabled tasklet cannot be executed
    even if scheduled, until it is enabled at some future time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化时，`*func`保存处理程序例程的地址，`data`用于在调用期间将数据块作为参数传递给处理程序例程。每个任务队列都携带一个`state`，可以是`TASKLET_STATE_SCHED`，表示已安排执行，也可以是`TASKLET_STATE_RUN`，表示正在执行。使用原子计数器来*启用*或*禁用*任务队列；当`count`等于*非零*值*时，表示任务队列*已禁用*，*零*表示任务队列*已启用*。禁用的任务队列即使已排队，也不能执行，直到将来某个时间启用。
- en: 'Kernel services can instantiate a new tasklet statically through any of the
    following macros:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 内核服务可以通过以下任何宏之一静态实例化新的任务队列：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'New tasklets can be instantiated dynamically at runtime through the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 新的任务队列可以通过以下方式在运行时动态实例化：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The kernel maintains two per-CPU tasklet lists for queuing scheduled tasklets,
    and the definitions of these lists can be found in the source file `<kernel/softirq.c>`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 内核为排队的任务队列维护了两个每CPU任务队列列表，这些列表的定义可以在源文件`<kernel/softirq.c>`中找到：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`tasklet_vec` is considered normal list, and all queued tasklets present in
    this list are run by `TASKLET_SOFTIRQ` (one of the 10 softirqs). `tasklet_hi_vec`
    is a high-priority tasklet list, and all queued tasklets present in this list
    are executed by `HI_SOFTIRQ`, which happens to be the highest priority softirq.
    A tasklet can be queued for execution into the appropriate list by invoking `tasklet_schedule()`
    or `tasklet_hi_scheudule()`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`tasklet_vec`被认为是正常列表，此列表中的所有排队的任务队列都由`TASKLET_SOFTIRQ`（10个softirq之一）运行。`tasklet_hi_vec`是一个高优先级的任务队列列表，此列表中的所有排队的任务队列都由`HI_SOFTIRQ`执行，这恰好是最高优先级的softirq。可以通过调用`tasklet_schedule()`或`tasklet_hi_scheudule()`将任务队列排队到适当的列表中执行。'
- en: 'The following code shows the implementation of `tasklet_schedule()`; this function
    is invoked with the address of the tasklet instance to be queued as a parameter:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`tasklet_schedule()`的实现；此函数通过要排队的任务队列实例的地址作为参数调用：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The conditional construct checks if the specified tasklet is already scheduled;
    if not, it atomically sets the state to `TASKLET_STATE_SCHED` and invokes `__tasklet_shedule()`
    to enqueue the tasklet instance into the pending list. If the specified tasklet
    is already found to be in the `TASKLET_STATE_SCHED` state, it is not rescheduled:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 条件构造检查指定的任务队列是否已经排队；如果没有，它会原子地将状态设置为`TASKLET_STATE_SCHED`，并调用`__tasklet_shedule()`将任务队列实例排队到待处理列表中。如果发现指定的任务队列已经处于`TASKLET_STATE_SCHED`状态，则不会重新调度：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This function silently enqueues the specified tasklet to the tail of the `tasklet_vec`
    and raises the `TASKLET_SOFTIRQ` on the local processor.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将指定的任务队列静默排队到`tasklet_vec`的尾部，并在本地处理器上引发`TASKLET_SOFTIRQ`。
- en: 'Following is the code for the `tasklet_hi_scheudle()` routine:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`tasklet_hi_scheudle()`例程的代码：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Actions executed in this routine are similar to that of `tasklet_schedule()`,
    with an exception that it invokes `__tasklet_hi_scheudle()` to enqueue the specified
    tasklet into the tail of `tasklet_hi_vec`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此例程中执行的操作与`tasklet_schedule()`类似，唯一的例外是它调用`__tasklet_hi_scheudle()`将指定的任务队列排队到`tasklet_hi_vec`的尾部：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This call raises `HI_SOFTIRQ` on the local processor, which turns all tasklets
    queued in `tasklet_hi_vec` into the highest-priority bottom halves (higher in
    priority over the rest of the softirqs).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用在本地处理器上引发`HI_SOFTIRQ`，这将把`tasklet_hi_vec`中排队的所有任务队列转换为最高优先级的底部半部（优先级高于其他softirq）。
- en: 'Another variant is `tasklet_hi_schedule_first()`, which inserts the specified
    tasklet to the head of `tasklet_hi_vec` and raises `HI_SOFTIRQ`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个变体是`tasklet_hi_schedule_first()`，它将指定的tasklet插入到`tasklet_hi_vec`的开头，并提高`HI_SOFTIRQ`：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Other interface routines exist that are used to enable, disable, and kill scheduled
    tasklets.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在其他接口例程，用于启用、禁用和终止已调度的tasklet。
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This function disables the specified tasklet by incrementing its *disable count*.
    The tasklet may still be scheduled, but it is not executed until it has been enabled
    again. If the tasklet is currently running when this call is invoked, this function
    busy-waits until the tasklet completes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数通过增加其*禁用计数*来禁用指定的tasklet。tasklet仍然可以被调度，但直到再次启用它之前不会被执行。如果在调用此函数时tasklet当前正在运行，则此函数会忙等待直到tasklet完成。
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This attempts to enable a tasklet that had been previously disabled by decrementing
    its *disable count*. If the tasklet has already been scheduled, it will run soon:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数尝试通过递减其*禁用计数*来启用先前已禁用的tasklet。如果tasklet已经被调度，它将很快运行：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This function is called to kill the given tasklet, to ensure that the it cannot
    be scheduled to run again. If the tasklet specified is already scheduled by the
    time this call is invoked, then this function waits until its execution completes:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于终止给定的tasklet，以确保它不能再次被调度运行。如果在调用此函数时指定的tasklet已经被调度，则此函数会等待其执行完成：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This function is called to kill an already scheduled tasklet. It immediately
    removes the specified tasklet from the list even if the tasklet is in the `TASKLET_STATE_SCHED`
    state.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数用于终止已经调度的tasklet。即使tasklet处于`TASKLET_STATE_SCHED`状态，它也会立即从列表中删除指定的tasklet。
- en: Workqueues
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作队列
- en: '**Workqueues** (**wqs**) are mechanisms for the execution of asynchronous process
    context routines. As the name aptly suggests, a workqueue (wq) is a list of *work*
    items*,* each containing a function pointer that takes the address of a routine
    to be executed asynchronously. Whenever some kernel code (that belongs to a subsystem
    or a service) intends to defer some work for asynchronous process context execution,
    it must initialize the *work* item with the address of the handler function, and
    enqueue it onto a workqueue. The kernel uses a dedicated pool of kernel threads,
    called *kworker* threads, to execute functions bound to each *work* item in the
    queue, sequentially.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**工作队列**（**wqs**）是用于执行异步进程上下文例程的机制。正如名称所暗示的那样，工作队列（wq）是一个*work*项目的列表，每个项目包含一个函数指针，该指针指向要异步执行的例程的地址。每当一些内核代码（属于子系统或服务）打算将一些工作推迟到异步进程上下文执行时，它必须使用处理程序函数的地址初始化*work*项目，并将其排队到工作队列中。内核使用专用的内核线程池，称为*kworker*线程，按顺序执行队列中每个*work*项目绑定的函数。'
- en: Interface API
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口API
- en: 'The workqueue API offers two types of functions interfaces: first, a set of
    interface routines to instantiate and queue *work* items onto a global workqueue,
    which is shared by all kernel subsystems and services, and second, a set of interface
    routines to set up a new workqueue, and queue work items onto it. We will begin
    to explore workqueue interfaces with macros and functions related to the global
    shared workqueue.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 工作队列API提供了两种类型的函数接口：首先，一组接口例程用于实例化和排队*work*项目到全局工作队列，该队列由所有内核子系统和服务共享；其次，一组接口例程用于设置新的工作队列，并将工作项目排队到其中。我们将开始探索与全局共享工作队列相关的宏和函数的工作队列接口。
- en: 'Each *work* item in the queue is represented by an instance of type `struct
    work_struct`, which is declared in the kernel header `<linux/workqueue.h>`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 队列中的每个*work*项目由类型为`struct work_struct`的实例表示，该类型在内核头文件`<linux/workqueue.h>`中声明：
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`func` is a pointer that takes the address of the deferred routine; a new struct
    work object can be created and initialized through macro `DECLARE_WORK`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`func`是一个指针，指向延迟例程的地址；可以通过宏`DECLARE_WORK`创建并初始化一个新的struct work对象：'
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`n` is the name of the instance to be created and `f` is the address of the
    function to be assigned. A work instance can be scheduled into the workqueue through
    `schedule_work()`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`n`是要创建的实例的名称，`f`是要分配的函数的地址。可以通过`schedule_work()`将工作实例排队到工作队列中：'
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This function enqueues the given *work* item on the local CPU workqueue, but
    does not guarantee its execution on it. It returns *true* if the given *work*
    is successfully enqueued, or *false* if the given *work* is already found in the
    workqueue. Once queued, the function associated with the *work* item is executed
    on any of the available CPUs by the relevant `kworker` thread. Alternatively,
    a *work* item can be marked for execution on a specific CPU, while scheduling
    it into the queue (which might yield better cache utilization); this can be done
    with a call to `scheudule_work_on()`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将给定的*work*项目排队到本地CPU工作队列，但不能保证其在其中执行。如果成功排队给定的*work*，则返回*true*，如果给定的*work*已经在工作队列中，则返回*false*。一旦排队，与*work*项目相关联的函数将由相关的`kworker`线程在任何可用的CPU上执行。或者，可以将*work*项目标记为在特定CPU上执行，同时将其调度到队列中（这可能会产生更好的缓存利用）；可以通过调用`schedule_work_on()`来实现：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`cpu` is the identifier to which the *work* task is to be bound. For instance,
    to schedule a *work* task onto a local CPU, the caller can invoke:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpu`是要绑定到的*work*任务的标识符。例如，要将*work*任务调度到本地CPU，调用者可以调用：'
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`smp_processor_id()` is a kernel macro (defined in `<linux/smp.h>`) that returns
    the local CPU identifier.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`smp_processor_id()`是一个内核宏（在`<linux/smp.h>`中定义），它返回本地CPU标识符。'
- en: 'The interface API also offers a variant of scheduling calls, which allow the
    caller to queue *work* tasks whose execution is guaranteed to be delayed at least
    until a specified timeout. This is achieved by binding a *work* task with a timer,
    which can be initialized with an expiry timeout, until which time the *work* task
    is not scheduled into the queue:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 接口API还提供了调度调用的变体，允许调用者排队*work*任务，其执行保证至少延迟到指定的超时。这是通过将*work*任务与定时器绑定来实现的，可以使用到期超时初始化定时器，直到*work*任务被调度到队列中为止：
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`timer` is an instance of a dynamic timer descriptor, which is initialized
    with the expiry interval and armed while scheduling a *work* task. We''ll discuss
    kernel timers and other time-related concepts more in the next chapter.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`timer`是动态定时器描述符的一个实例，它在安排*工作*任务时初始化了到期间隔并启动。我们将在下一章更详细地讨论内核定时器和其他与时间相关的概念。'
- en: 'Callers can instantiate `delayed_work` and initialize it statically through
    a macro:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者可以通过宏实例化`delayed_work`并静态初始化它：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Similar to normal *work* tasks, delayed *work* tasks can be scheduled to run
    on any of the available CPUs or be scheduled to execute on a specified core. To
    schedule delayed *work* that can run on any of the available processors, callers
    can invoke `schedule_delayed_work()`, and to schedule delayed *work* onto specific
    CPUs, use the function `schedule_delayed_work_on()`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通*工作*任务类似，延迟*工作*任务可以安排在任何可用的CPU上运行，或者安排在指定的核心上执行。要安排可以在任何可用处理器上运行的延迟*工作*，调用者可以调用`schedule_delayed_work()`，要安排延迟*工作*到特定CPU上，使用函数`schedule_delayed_work_on()`：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that if the delay is zero, then the specified *work* item is scheduled
    for immediate execution.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果延迟为零，则指定的*工作*项将安排立即执行。
- en: Creating dedicated workqueues
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建专用工作队列
- en: 'Timing of the execution of *work* items scheduled onto the global workqueue
    is not predictable: one long-running *work* item can always cause indefinite delays
    for the rest. Alternatively, the workqueue framework allows the allocation of
    dedicated workqueues, which can be owned by a kernel subsystem or a service. Interface
    APIs used to create and schedule work into these queues provide control flags,
    through which owners can set special attributes such as CPU locality, concurrency
    limits, and priority, which have an influence on the execution of work items queued.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 全局工作队列上安排的*工作*项的执行时间是不可预测的：一个长时间运行的*工作*项总是会导致其他*工作*项的无限延迟。或者，工作队列框架允许分配专用工作队列，这些队列可以由内核子系统或服务拥有。用于创建和安排工作到这些队列中的接口API提供了控制标志，通过这些标志，所有者可以设置特殊属性，如CPU局部性、并发限制和优先级，这些属性会影响排队的工作项的执行。
- en: 'A new workqueue can be set up through a call to `alloc_workqueue()`; the following
    excerpt taken from `<fs/nfs/inode.c>` shows sample usage:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用`alloc_workqueue()`来设置新的工作队列；以下摘录取自`<fs/nfs/inode.c>`，显示了示例用法：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This call takes three arguments: the first is a string constant to `name` the
    workqueue. The second argument is the bitfield of `flags`, and the third an integer
    called `max_active`. The last two are used to specify control attributes of the
    queue. On success, this function returns the address of the workqueue descriptor.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用需要三个参数：第一个是一个字符串常量，用于“命名”工作队列。第二个参数是“flags”的位字段，第三个是称为“max_active”的整数。最后两个参数用于指定队列的控制属性。成功时，此函数返回工作队列描述符的地址。
- en: 'The following is a list of flag options:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是标志选项列表：
- en: '`WQ_UNBOUND`: Workqueues created with this flag are managed by kworker-pools
    that are not bound to any specific CPU. This causes all *work* items scheduled
    to this queue to run on any available processor. *Work* items in this queue are
    executed as soon as possible by kworker pools.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WQ_UNBOUND`：使用此标志创建的工作队列由未绑定到任何特定CPU的kworker池管理。这会导致安排到此队列的所有*工作*项在任何可用处理器上运行。此队列中的*工作*项将尽快由kworker池执行。'
- en: '`WQ_FREEZABLE`: A workqueue of this type is freezable, which means that it
    is affected by system suspend operations. During suspend, all current *work* items
    are drained and no new *work* item can run until the system is unfreezed or resumed.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WQ_FREEZABLE`：此类型的工作队列是可冻结的，这意味着它会受到系统挂起操作的影响。在挂起期间，所有当前的*工作*项都会被清空，并且直到系统解冻或恢复之前，不会有新的*工作*项可以运行。'
- en: '`WQ_MEM_RECLAIM`: This flag is used to mark a workqueue that contains *work*
    items involved in memory reclaim paths. This causes the framework to ensure that
    there is always a *worker* thread available to run *work* items on this queue.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WQ_MEM_RECLAIM`：此标志用于标记包含在内存回收路径中的*工作*项的工作队列。这会导致框架确保始终有一个*工作*线程可用于在此队列上运行*工作*项。'
- en: '`WQ_HIGHPRI`: This flag is used to mark a workqueue as high priority. Work
    items in high-priority workqueues have a higher precedence over normal ones, in
    that these are executed by a high-priority pool of *kworker* threads. The kernel
    maintains a dedicated pool of high-priority kworker threads for each CPU, which
    are distinct from normal kworker pools.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WQ_HIGHPRI`：此标志用于将工作队列标记为高优先级。高优先级工作队列中的工作项优先级高于普通工作项，这些工作项由高优先级的*kworker*线程池执行。内核为每个CPU维护了一个专用的高优先级kworker线程池，这些线程池与普通的kworker池不同。'
- en: '`WQ_CPU_INTENSIVE`: This flag marks work items on this workqueue to be CPU
    intensive. This helps the system scheduler to regulate the execution of *work*
    items that are expected to hog the CPU for long intervals. This means runnable
    CPU-intensive *work* items will not prevent other work items in the same kworker-pool
    from starting. A runnable non-CPU-intensive *work* item can always delay the execution
    of *work* items marked as CPU intensive. This flag is meaningless for an unbound
    wq.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WQ_CPU_INTENSIVE`：此标志标记此工作队列上的工作项为CPU密集型。这有助于系统调度程序调节预计会长时间占用CPU的*工作*项的执行。这意味着可运行的CPU密集型*工作*项不会阻止同一kworker池中的其他工作项的启动。可运行的非CPU密集型*工作*项始终可以延迟执行标记为CPU密集型的*工作*项。对于未绑定的wq，此标志毫无意义。'
- en: '`WQ_POWER_EFFICIENT`: Workqueues marked with this flag are per-CPU by default,
    but become unbound if the system was booted with the `workqueue.power_efficient`
    kernel param set. Per-CPU workqueues that are identified to contribute significantly
    to power consumption are identified and marked with this flag, and enabling the
    power_efficient mode leads to noticeable power savings at the cost of a slight
    performance penalty.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WQ_POWER_EFFICIENT`：标记了此标志的工作队列默认情况下是每CPU的，但如果系统是使用`workqueue.power_efficient`内核参数启动的，则变为未绑定。已确定对功耗有显着贡献的每CPU工作队列将被识别并标记为此标志，并且启用power_efficient模式会导致明显的功耗节约，但会略微降低性能。'
- en: The final argument `max_active` is an integer, which must specify the count
    of *work* items that can be executed simultaneously from this workqueue on any
    given CPU.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最终参数`max_active`是一个整数，必须指定在任何给定CPU上可以同时执行的*工作*项的数量。
- en: 'Once a dedicated workqueue is set up, *work* items can be scheduled through
    any of the following calls:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了专用工作队列，*工作*项可以通过以下任一调用进行调度：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`wq` is a pointer to a queue; it enqueues the specified *work* item on the
    local CPU, but does not guarantee execution on local processor. This call returns
    *true* if the given work item is successfully queued, and *false* if the given
    work item is already scheduled.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`wq`是一个指向队列的指针；它会将指定的*工作*项排入本地CPU，但不能保证在本地处理器上执行。如果成功排队，则此调用返回*true*，如果已安排给定的工作项，则返回*false*。'
- en: 'Alternatively, callers can enqueue a work item bound to a specific CPU with
    a call to:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，调用者可以通过调用以下方式将工作项排入与特定CPU绑定的工作项队列：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '*Once a work* item is enqueued into a workqueue of the specified `cpu`, it
    returns *true* if the given work item is successfully queued and *false* if the
    given work item is already found in the queue.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将工作项排入指定`cpu`的工作队列中，如果成功排队，则返回*true*，如果已在队列中找到给定的工作项，则返回*false*。
- en: 'Similar to shared workqueue APIs, delayed scheduling options also are available
    for dedicated workqueues. The following calls are to be used for delayed scheduling
    of *work* items:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 与共享工作队列API类似，专用工作队列也提供了延迟调度选项。以下调用用于延迟调度*工作*项：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Both calls delay scheduling of the given work until the timeout specified by
    the `delay` has elapsed, with the exception that `queue_delayed_work_on()` enqueues
    the given *work* item on the specified CPU and guarantees its execution on it.
    Note that if the delay specified is zero and the workqueue is idle, then the given
    *work* item is scheduled for immediate execution.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个调用都会延迟给定工作项的调度，直到`delay`指定的超时时间已经过去，但`queue_delayed_work_on()`除外，它会将给定的*工作*项排入指定的CPU，并保证在该CPU上执行。请注意，如果指定的延迟为零且工作队列为空闲，则给定的*工作*项将被安排立即执行。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Through this chapter, we have touched base with interrupts, the various components
    that fabricate the whole infrastructure, and how the kernel manages it efficiently.
    We understood how the kernel engages abstraction to smoothly handle varied interrupt
    signals routed from various controllers. The kernel's effort in simplifying complex
    programming approaches is again brought to the fore through the high-level interrupt-management
    interfaces. We also stretched our understanding on all the key routines and important
    data structures of the interrupt subsystem. We also explored kernel mechanisms
    for handling deferred work.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们已经接触到了中断，构建整个基础设施的各种组件，以及内核如何有效地管理它。我们了解了内核如何利用抽象来平稳处理来自各种控制器的各种中断信号。内核通过高级中断管理接口再次突出了简化复杂编程方法的努力。我们还深入了解了中断子系统的所有关键例程和重要数据结构。我们还探讨了内核处理延迟工作的机制。
- en: In the next chapter, we will explore the kernel's timekeeping subsystem to understand
    key concepts such as time measurement, interval timers, and timeout and delay
    routines.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索内核的时间管理子系统，以了解诸如时间测量、间隔定时器和超时和延迟例程等关键概念。
