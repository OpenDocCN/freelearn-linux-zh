- en: File Manipulation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件操作
- en: This chapter is dedicated to file manipulation. As in *everything is a file*system,
    file manipulation is considered one of the most important aspects of working with
    Linux. We will start by exploring common file operations, such as creating, copying,
    and deleting files. We will continue with a bit on archiving, another important
    tool when working on the command line. The last part of this chapter will be devoted
    to finding files on the file system, another important skill in the toolset of
    a shell scripter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门讨论文件操作。就像*一切都是文件*系统一样，文件操作被认为是与Linux工作中最重要的方面之一。我们将首先探讨常见的文件操作，比如创建、复制和删除文件。接着我们会介绍一些关于存档的内容，这是在命令行工作时的另一个重要工具。本章的最后部分将致力于在文件系统中查找文件，这是shell脚本工具包中的另一个重要技能。
- en: 'The following commands will be introduced in this chapter: `cp`, `rm`, `mv`,
    `ln`, `tar`, `locate`, and `find`.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下命令：`cp`、`rm`、`mv`、`ln`、`tar`、`locate`和`find`。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Common file operations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的文件操作
- en: Archiving
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存档
- en: Finding files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找文件
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will practice file manipulation using the virtual machine we created in [Chapter
    2](cdd5838b-007b-4e1a-a8dc-3c9ea8ebefca.xhtml), *Setting Up Your Local Environment*.
    No further resources are needed at this point.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在[第2章](cdd5838b-007b-4e1a-a8dc-3c9ea8ebefca.xhtml)中创建的虚拟机进行文件操作。此时不需要更多资源。
- en: Common file operations
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的文件操作
- en: So far, we have mainly introduced commands related to navigation on the Linux
    filesystem. In earlier chapters, we already saw that we can use `mkdir` and `touch`
    to create directories and empty files, respectively. If we want to give a file
    some meaningful (text) content, we use `vim` or `nano`. However, we have not yet
    talked about removing files or directories, or copying, renaming, or creating
    shortcuts. Let's start with copying files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要介绍了与Linux文件系统导航相关的命令。在早期的章节中，我们已经看到我们可以使用`mkdir`和`touch`分别创建目录和空文件。如果我们想给文件一些有意义的（文本）内容，我们使用`vim`或`nano`。然而，我们还没有讨论过删除文件或目录，或者复制、重命名或创建快捷方式。让我们从复制文件开始。
- en: Copying
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制
- en: 'In essence, copying a file on Linux is really simple: use the `cp` command,
    followed by the filename-to-be-copied to the filename-to-copy-to. It looks something
    like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，在Linux上复制文件非常简单：使用`cp`命令，后面跟着要复制的文件名和要复制到的文件名。它看起来像这样：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, in this example we copied an (empty) *file* that was already
    *owned by us*, while we were *in the same directory* as the file. This might raise
    some questions, such as:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在这个例子中，我们复制了一个（空的）*文件*，它已经是*我们拥有的*，而我们*在相同的目录*中。这可能会引发一些问题，比如：
- en: Do we always need to be in the same directory as the source and destination
    file?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否总是需要在源文件和目标文件的相同目录中？
- en: What about the permissions of the file?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的权限呢？
- en: Can we also copy directories with `cp`?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否也可以使用`cp`复制目录？
- en: 'As you might expect, as with many things under Linux, the `cp` command is also
    very versatile. We can indeed copy files not owned by us; we do not need to be
    in the same directory as the file, and we can also copy directories! Let''s try
    a few of these things out:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的，在Linux下，`cp`命令也是非常多才多艺的。我们确实可以复制不属于我们的文件；我们不需要在与文件相同的目录中，我们也可以复制目录！让我们尝试一些这些事情：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So, what happened? We used `cd` to change the directory to `/var/log/`. We
    listed the files there using `ls` with the *long* option. We copied a file with
    a relative path that we were able to read, but that was owned by `root:root`,
    to the fully qualified `/home/reader/` directory. When we listed `/home/reader/`
    with the fully qualified path, we saw that the copied file was now owned by `reader:reader`.
    When we tried to do the same for the `tallylog` file, we got the error `cannot
    open ''tallylog'' for reading: Permission denied`. This should not be unexpected,
    since we do not have any read permissions on that file, so copying would be hard.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '那么，发生了什么？我们使用`cd`命令将目录更改为`/var/log/`。我们使用带有*长*选项的`ls`列出了那里的文件。我们复制了一个相对路径的文件，我们能够读取它，但它是由`root:root`拥有的，复制到了完全限定的`/home/reader/`目录。当我们使用完全限定路径列出`/home/reader/`时，我们看到复制的文件现在由`reader:reader`拥有。当我们尝试对`tallylog`文件做同样的操作时，我们得到了错误`cannot
    open ''tallylog'' for reading: Permission denied`。这并不意外，因为我们对该文件没有任何读取权限，所以复制会很困难。'
- en: 'This should answer two of the three questions. But what about directories?
    Let''s try to copy the `/tmp/` directory into our `home` directory:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该回答了三个问题中的两个。但是对于目录呢？让我们尝试将`/tmp/`目录复制到我们的`home`目录中：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For such a simple exercise, a lot actually happened! First, we navigate back
    to our `home` directory using `cd` without any arguments; a neat little trick
    in itself. Next, we try to copy the entire `/tmp/` directory to `.` (which, as
    you should remember, is shorthand for *current directory*). However, this fails
    with the error `-r not specified; omitting directory '/tmp/'`. We list the directory
    to check this, and indeed, it seems like nothing happened. When we add the `-r`,
    as specified by the error, and retry the command, we get some `Permission denied`
    errors. This is not unexpected, since not all files *inside* the `/tmp/` directory
    will be readable to us. Even though we got the errors, when we now check the contents
    of our `home` directory, we can see the `tmp` directory there! So, using the `-r`
    option, which is short for `--recursive`, allows us to copy directories and everything
    that's in them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样一个简单的练习，实际上发生了很多事情！首先，我们使用`cd`命令返回到我们的`home`目录，而不带任何参数；这本身就是一个很巧妙的小技巧。接下来，我们尝试将整个`/tmp/`目录复制到`.`（你应该记得，`.`是*当前目录*的缩写）。然而，这次失败了，出现了错误`-r
    not specified; omitting directory '/tmp/'`。我们列出目录来检查，确实，似乎什么都没发生。当我们添加了错误指定的`-r`并重新尝试命令时，出现了一些`Permission
    denied`的错误。这并不意外，因为并非所有`/tmp/`目录中的文件都对我们可读。尽管我们得到了错误，但当我们现在检查我们的`home`目录的内容时，我们可以看到`tmp`目录在那里！因此，使用`-r`选项（它是`--recursive`的缩写）允许我们复制目录和其中的所有内容。
- en: Removing
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除
- en: 'After copying some files and directories into our `home` directory (which is
    a safe bet, because we know for sure that we can write there!), we''re left with
    a little mess. Instead of only creating files, let''s use the `rm` command to
    remove some duplicate items:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在将一些文件和目录复制到我们的`home`目录之后（这是一个安全的选择，因为我们确信可以在那里写入！），我们留下了一些混乱。让我们使用`rm`命令来删除一些重复的项目：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Using `rm` followed by a filename deletes it. As you might notice, there is
    no Are you sure? prompt. This can actually be enabled by using the `-i` flag,
    but by default this is not the case. Consider that `rm` also allows you to use
    wildcards, such as `*` (which matches everything), which will delete every file
    that is matched (and can be deleted by the user). In short, this is a great way
    to lose your files really quickly! When we tried to use `rm` with the name of
    a directory, however, it gave the error `cannot remove ''tmp/'': Is a directory`.
    This is very similar to the `cp` command, and luckily for us, the remediation
    is also the same: add `-r` for a *recursive* delete! Again, this is a great way
    to lose files; a single command lets you delete your entire `home` directory and
    everything in it, without so much as a warning. Consider **this** your warning!
    Especially when using in combination with the `-f` flag, which is short for `--force`,
    which will ensure that `rm` *never prompts* and starts deleting right away.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '使用`rm`后跟文件名将删除它。您可能会注意到，这里没有“您确定吗？”的提示。实际上，可以通过使用`-i`标志来启用此功能，但默认情况下不是这样。请注意，`rm`还允许您使用通配符，例如`*`（匹配所有内容），这将删除所有匹配的文件（并且可以被用户删除）。简而言之，这是一种非常快速丢失文件的好方法！但是，当我们尝试使用`rm`命令和目录名称时，它会给出错误`cannot
    remove ''tmp/'': Is a directory`。这与`cp`命令非常相似，幸运的是，解决方法也是一样的：添加`-r`进行*递归*删除！同样，这是一种丢失文件的好方法；一个命令就可以让您删除整个`home`目录及其中的所有内容，而不需要任何警告。请把这当作是您的警告！特别是在与`-f`标志结合使用时，它是`--force`的缩写，这将确保`rm`*永远不会提示*并立即开始删除。'
- en: Renaming, moving, and linking
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重命名、移动和链接
- en: 'Sometimes, we do not just want to create or delete a file, we might need to
    rename one. Weirdly, Linux does not have anything that sounds like rename; however,
    the `mv` command (for **m**o**v**e) does accomplish the functionality that we
    want. Similar to the `cp` command, it takes a source file and destination file
    as arguments, and looks like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们不仅想要创建或删除文件，还可能需要重命名文件。奇怪的是，Linux没有任何听起来像重命名的东西；但是，`mv`命令（用于**m**o**v**e）确实实现了我们想要的功能。与`cp`命令类似，它接受源文件和目标文件作为参数，并且看起来像这样：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the `mv` command is really simple to use. It even works for
    directories, without needing a special option such as the `-r` we saw for `cp`
    and `rm`. It does, however, get a little more complex when we introduce wildcards,
    but don't worry about that for now. The commands we used in the preceding code
    are relative, but they work just as well fully qualified or mixed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`mv`命令非常简单易用。它甚至适用于目录，无需像`cp`和`rm`那样需要`-r`这样的特殊选项。但是，当我们引入通配符时，它会变得更加复杂，但现在不用担心。我们在前面的代码中使用的命令是相对的，但它们也可以完全限定或混合使用。
- en: 'Sometimes, you''ll want to move a file from one directory into another. If
    you think about it, this is actually a rename of the fully qualified file name!
    No data is being touched, but you just want to reach the file somewhere else.
    So, using `mv umaskfile umaskdir/` will move the `umaskfile` into `umaskdir/`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能需要将文件从一个目录移动到另一个目录。如果您仔细考虑，这实际上是对完全限定文件名的重命名！没有触及任何数据，但您只是想在其他地方访问文件。因此，使用`mv
    umaskfile umaskdir/`将`umaskfile`移动到`umaskdir/`：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we have the `ln` command, which stands for **l**i**n**king. This is
    the Linux way of creating links between files, which are closest to the shortcuts
    that Windows uses. There are two types of links: symbolic links (also called soft
    links) and hard links. The difference is found deeper in the filesystem workings:
    a symbolic link refers to the filename (or directory name), whereas a hard link
    links to *inode* that stores the contents of the file or directory. For scripting,
    if you''re using links, you''re probably using symbolic links, so let''s see those
    in action:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`ln`命令，它代表**l**i**n**king。这是Linux创建文件之间链接的方式，最接近Windows使用的快捷方式。有两种类型的链接：符号链接（也称为软链接）和硬链接。区别在于文件系统的工作原理：符号链接指向文件名（或目录名），而硬链接链接到存储文件或目录内容的*inode*。对于脚本编写，如果您使用链接，您可能正在使用符号链接，因此让我们看看这些符号链接的操作：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We created two types of symbolic link using `ln -s` (which is short for `--symbolic`):
    to the `/var/log/auth.log` file first, and to the `/tmp/` directory after. We
    are seeing two different ways of using `ln -s`: without a second argument, it
    creates the link with the same name as the thing we''re linking to; otherwise,
    we can give our own name for the link as the second argument (as can be seen with
    the `link-to-auth.log` and `link-to-tmp/` links). We can now read the contents
    of `/var/log/auth.log` by either interacting with `/home/reader/auth.log` or `/home/reader/link-to-auth.log`.
    If we want to navigate to `/tmp/`, we can now use either `/home/reader/tmp/` or
    `/home/reader/link-to-tmp/` in combination with `cd`. While this example isn''t
    particularly useful in your day to day work (unless typing `/var/log/auth.log`
    instead of `auth.log` saves you tons of time), linking prevents duplicate copies
    of files while maintaining easy access.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ln -s`（这是`--symbolic`的缩写）创建了两种类型的符号链接：首先是到`/var/log/auth.log`文件，然后是到`/tmp/`目录。我们看到了两种不同的使用`ln
    -s`的方式：如果没有第二个参数，它将创建与我们要链接的内容相同名称的链接；否则，我们可以将我们自己的名称作为第二个参数（如`link-to-auth.log`和`link-to-tmp/`链接所示）。现在，我们可以通过与`/home/reader/auth.log`或`/home/reader/link-to-auth.log`交互来读取`/var/log/auth.log`的内容。如果我们想要导航到`/tmp/`，我们现在可以使用`/home/reader/tmp/`或`/home/reader/link-to-tmp/`与`cd`结合使用。虽然这个例子在日常工作中并不特别有用（除非输入`/var/log/auth.log`而不是`auth.log`可以为您节省大量时间），但链接可以防止重复复制文件，同时保持易于访问。
- en: An important concept in linking (and Linux filesystems in general) is the **inode**.
    Every file (whatever the type, so including directories) has an inode, which describes
    the attributes and *disk block locations* of that file. In this context, attributes
    include things like ownership and permissions, as well as last change, access
    and modification timestamps. In linking, *soft links* have their own inodes, while
    *hard link*s refer to the same inode.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 链接（以及Linux文件系统一般）中的一个重要概念是**inode**。每个文件（无论类型如何，包括目录）都有一个inode，它描述了该文件的属性和*磁盘块位置*。在这个上下文中，属性包括所有权和权限，以及最后的更改、访问和修改时间戳。在链接中，*软链接*有它们自己的inode，而*硬链接*指的是相同的inode。
- en: 'Before continuing with the next part of this chapter, clean up the four links
    and the copied `dpk.log` file by using `rm`. If you''re in doubt about how to
    do this, check out the man page for `rm`. A little tip: removing symbolic links
    is as simple as `rm <name-of-link>`!'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章的下一部分之前，使用`rm`清理四个链接和复制的`dpk.log`文件。如果你不确定如何做到这一点，请查看`rm`的man页面。一个小提示：删除符号链接就像`rm
    <name-of-link>`一样简单！
- en: Archiving
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存档
- en: Now that we have a grasp on common file operations in Linux, we'll move on to
    archiving. While it might sound fancy, archiving refers simply to **creating archives**.
    An example most of you will be familiar with is creating a ZIP file, which is
    an archive. ZIP is not Windows-specific; it is an *archive file format* with different
    implementations for Windows, Linux, macOS, and so on.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对Linux中的常见文件操作有了一定的了解，我们将继续进行存档操作。虽然听起来可能很花哨，但存档简单地指的是**创建存档**。你们大多数人熟悉的一个例子是创建ZIP文件，这是一个存档。ZIP并不是特定于Windows的；它是一种*存档文件格式*，在Windows、Linux、macOS等不同的实现中都有。
- en: 'As you might expect, there are many archive file formats. On Linux, the most
    commonly used is the **tarball**, which is created by using the `tar` command
    (which is derived from the term **t**ape **ar**chive)*.* A tarball file, which
    ends in `.tar`, is uncompressed. In practice, tarballs will almost always be compressed
    with Gzip, which stands for **G**NU **zip**. This can be done either directly
    with the `tar` command (most common) or afterwards using the `gzip` command (less
    common, but can be used to compress files other than tarballs as well). Since
    `tar` is a complicated command, we''ll explore the most commonly used flags in
    more detail (descriptions are taken from the `tar` manual page):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的，有许多存档文件格式。在Linux上，最常用的是**tarball**，它是通过使用`tar`命令创建的（这个术语来源于**t**ape
    **ar**chive）。以`.tar`结尾的tarball文件是未压缩的。在实践中，tarball几乎总是使用Gzip进行压缩，Gzip代表**G**NU
    **zip**。这可以直接使用`tar`命令（最常见）或之后使用`gzip`命令（不太常见，但也可以用于压缩除tarball以外的文件）。由于`tar`是一个复杂的命令，我们将更详细地探讨最常用的标志（描述取自`tar`手册页）：
- en: '| `-c`, `--create` |  Create a new archive. Arguments supply the names of the
    files to be archived. Directories are archived recursively, unless the `--no-recursion`
    option  is given. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|`-c`，`--create` | 创建一个新的存档。参数提供要存档的文件的名称。除非给出`--no-recursion`选项，否则将递归存档目录。'
- en: '| `-x`, `--extract`, `--get` |  Extract files from an archive. Arguments are
    optional.  When given, they specify names of the archive members to be extracted.
    |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|`-x`，`--extract`，`--get` | 从存档中提取文件。参数是可选的。给定时，它们指定要提取的存档成员的名称。'
- en: '| `-t`, `--list` | List the contents of an archive. Arguments are optional.
    When given, they specify the names of the members to list. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|`-t`，`--list` | 列出存档的内容。参数是可选的。给定时，它们指定要列出的成员的名称。'
- en: '| `-v`, `--verbose` |  Verbosely list files processed. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|`-v`，`--verbose` | 详细列出处理的文件。'
- en: '| `-f`, `--file=ARCHIVE` |  Use archive file or device ARCHIVE. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|`-f`，`--file=ARCHIVE` | 使用存档文件或设备ARCHIVE。'
- en: '| `-z`, `--gzip`, `--gunzip`, `--ungzip` |  Filter the archive through Gzip.
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|`-z`，`--gzip`，`--gunzip`，`--ungzip` | 通过Gzip过滤存档。'
- en: '| `-C`, `--directory=DIR` | Change to DIR before performing any operations. 
    This option is order-sensitive, that is, it affects all options that follow. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|`-C`，`--directory=DIR` | 在执行任何操作之前切换到DIR。这个选项是有顺序的，也就是说，它影响后面的所有选项。'
- en: 'The `tar` command is pretty flexible about how we specify these options. We
    can present them one by one, all together, with and without a hyphen, or with
    the long or short option. This means that the following ways to create an archive
    are all correct and would all work:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`tar`命令在指定这些选项的方式上非常灵活。我们可以逐个呈现它们，一起呈现，带有或不带有连字符，或者使用长选项或短选项。这意味着创建存档的以下方式都是正确的，都可以工作：'
- en: '`tar czvf <archive name> <file1> <file2>`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar czvf <archive name> <file1> <file2>`'
- en: '`tar -czvf <archive name> <file1> <file2>`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar -czvf <archive name> <file1> <file2>`'
- en: '`tar -c -z -v -f <archive name> <file1> <file2>`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar -c -z -v -f <archive name> <file1> <file2>`'
- en: '`tar --create --gzip --verbose --file=<archive name> <file1> <file2>`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tar --create --gzip --verbose --file=<archive name> <file1> <file2>`'
- en: 'While this seems to be helpful, it can also be confusing. Our suggestion: pick
    one of the formats and stick with it. In this book, we will use the shortest form,
    so this is all short options without dashes. Let''s use this form to create our
    first archive!'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这看起来很有帮助，但也可能令人困惑。我们的建议是：选择一个格式并坚持使用它。在本书中，我们将使用最简短的形式，因此这是所有没有连字符的短选项。让我们使用这种形式来创建我们的第一个存档！
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this command, we **v**erbosely **c**reated a g**z**ipped **f**ile with
    the name `my-first-archive.tar.gz`, containing the files `nanofile.txt umaskfile`,
    and `renamedtestfile`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令，我们**v**erbosely **c**reated了一个名为`my-first-archive.tar.gz`的g**z**ipped
    **f**ile，其中包含了文件`nanofile.txt umaskfile`和`renamedtestfile`。
- en: In this example, we only archived files. In practice, it is often nice to archive
    an entire directory. The syntax for this is exactly the same, only instead of
    a filename you will give a directory name. The whole directory will be archived
    (and, in the case of the `-z` option, compressed as well). When you unpack a tarball
    that archived a directory, the entire directory will be extracted again, not just
    the contents.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只存档了文件。实际上，通常很好的存档整个目录。语法完全相同，只是你会给出一个目录名，整个目录将被存档（在`-z`选项的情况下也会被压缩）。当你解压存档了一个目录的tarball时，整个目录将被再次提取，而不仅仅是内容。
- en: 'Now, let''s see if unpacking it gives us back our files! We move the gzipped
    tarball to `renamedtestdir`, and use the `tar xzvf` command to unpack it there:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看解压它是否能还原我们的文件！我们将gzipped tarball移动到`renamedtestdir`，并使用`tar xzvf`命令在那里解压它：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we can see, we got our files back in the `renamedtestdir`! Actually, we
    never removed the original files, so these are copies. You might want to know
    what''s inside a tarball before you go to the trouble of extracting it and cleaning
    up everything. This can be accomplished by using the `-t` option instead of `-x`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们在`renamedtestdir`中找回了我们的文件！实际上，我们从未删除原始文件，所以这些是副本。在你开始提取和清理所有东西之前，你可能想知道tarball里面有什么。这可以通过使用`-t`选项而不是`-x`来实现：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The last interesting option that''s widely used for `tar` is the `-C`, or `--directory`
    option. This command ensures that we do not have to move the archive around before
    we extract it. Let''s use it to extract `/home/reader/renamedtestdir/my-first-archive.tar.gz`
    into `/home/reader/umaskdir/` from our `home` directory:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`tar`广泛使用的最后一个有趣选项是`-C`或`--directory`选项。这个命令确保我们在提取之前不必移动存档。让我们使用它将`/home/reader/renamedtestdir/my-first-archive.tar.gz`从我们的`home`目录提取到`/home/reader/umaskdir/`中：'
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By specifying `-C` with a directory argument after the archive name, we made
    sure that `tar` extracts the contents of the gzipped tarball into that specified
    directory.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在存档名称后指定`-C`和目录参数，我们确保`tar`将gzipped tarball的内容提取到指定的目录中。
- en: 'That covers the most important aspects of the `tar` command. However, one little
    thing remains: cleaning up! We''ve made a nice mess of our `home` directory, and
    we do not have any files there that actually do anything. The following is a practical
    example showing how dangerous the wildcard with the `rm -r` command can be:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了`tar`命令的最重要方面。然而，还有一件小事要做：清理！我们在`home`目录下搞得一团糟，而且那里没有任何真正有用的文件。以下是一个实际示例，展示了带有`rm
    -r`命令的通配符有多危险：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'One simple command, no warning, and all files, including directories with more
    files, are gone! And should you be wondering: no, Linux does not have a Recycle
    Bin either. These files are gone; only advanced hard disk recovery techniques
    *might* still be able to recover these files.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的命令，没有警告，所有文件，包括更多文件的目录，都消失了！如果你在想：不，Linux也没有回收站。这些文件已经消失了；只有高级硬盘恢复技术*可能*还能够恢复这些文件。
- en: Make sure that you perform the preceding command, just to get a feeling for
    how destructive `rm` can be. Before you do, however, ensure that you are in your
    `home` directory and that you do not accidentally have any files there that you
    do not want to delete. If you followed our examples, this should not be the case,
    but if you've done anything else, be sure about what you're doing!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你执行了前面的命令，以了解`rm`有多具有破坏性。然而，在你执行之前，请确保你在你的`home`目录下，并且不要意外地有任何你不想删除的文件。如果你遵循我们的示例，这不应该是问题，但如果你做了其他事情，请确保你知道自己在做什么！
- en: Finding files
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找文件
- en: 'After learning about common file operations and archiving, there is one vital
    skill in file manipulation we have not yet covered: finding files. It''s very
    neat that you know how to copy or archive files, but if you cannot find the file
    you want to manipulate, you''re going to have a hard time completing your task.
    Fortunately, there are tools devoted to finding and locating files on a Linux
    filesystem. And, to keep things simple, these are called `find` and `locate`.
    The `find` command is more complex, but more powerful, while the `locate` command
    is easier to use when you know exactly what you''re looking for. First, we''ll
    show you how to use `locate`, before moving on to the more extensive capabilities
    of `find`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了常见的文件操作和存档之后，还有一个在文件操作中至关重要的技能我们还没有涉及：查找文件。你知道如何复制或存档文件是非常好的，但如果你找不到你想要操作的文件，你将很难完成你的任务。幸运的是，有专门用于在Linux文件系统中查找和定位文件的工具。简单来说，这些工具就是`find`和`locate`。`find`命令更复杂，但更强大，而`locate`命令在你确切知道你要找的东西时更容易使用。首先，我们将向你展示如何使用`locate`，然后再介绍`find`更广泛的功能。
- en: locate
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定位
- en: 'On the man page for locate, the description could not be more fitting: `locate
    - find files by name`. The `locate` command is installed by default on your Ubuntu
    machine and the basic functionality is as simple as using `locate <filename>`.
    Let''s see how this works:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在locate的man页面上，描述再合适不过了：“locate - 按名称查找文件”。`locate`命令默认安装在您的Ubuntu机器上，基本功能就是使用`locate
    <filename>`这么简单。让我们看看它是如何工作的：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding example, we looked for the filename `fstab`. We might have
    remembered that we need to edit this file for filesystem changes, but we were
    not sure where we could find it. `locate` presented us with all locations on disk
    which contain `fstab`. As you can see, it does not have to be an exact match;
    everything that contains the `fstab` string will be printed.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们搜索了文件名`fstab`。我们可能记得我们需要编辑这个文件来进行文件系统更改，但我们不确定在哪里可以找到它。`locate`向我们展示了磁盘上包含`fstab`的所有位置。如你所见，它不必是一个精确的匹配；包含`fstab`字符串的所有内容都将被打印出来。
- en: You might have noticed that the `locate` command completes almost instantly.
    That is because it uses a database for all files which is updated periodically,
    instead of going through the whole filesystem at runtime. Because of this, the
    information is not always accurate, since changes are not synchronized to the
    database in real-time. To ensure that you are talking to the database with the
    latest state of the filesystem, be sure to run `sudo updatedb` (requires root
    privileges) before running `locate`. This is also required before the first run
    of `locate` on a system, because otherwise there is no database to query!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到`locate`命令几乎立即完成。这是因为它使用一个定期更新的数据库来存储所有文件，而不是在运行时遍历整个文件系统。因此，信息并不总是准确的，因为更改不会实时同步到数据库中。为了确保你使用的是文件系统的最新状态与数据库进行交互，请确保在运行`locate`之前运行`sudo
    updatedb`（需要root权限）。这也是在系统上首次运行`locate`之前所需的，否则就没有数据库可供查询！
- en: Locate has some options, but in our experience, you only use it if you know
    the exact (or an exact part of the) filename. For other searches, defaulting to
    the `find` command is a much better idea.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Locate有一些选项，但根据我们的经验，只有当你知道确切的文件名（或文件名的一部分）时才会使用它。对于其他搜索，最好默认使用`find`命令。
- en: find
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: find
- en: 'Find is a very powerful, but complicated command. You can do any of the following
    things with `find`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: find是一个非常强大但复杂的命令。你可以使用`find`做以下任何一件事情：
- en: Search on a filename
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按文件名搜索
- en: Search on permissions (both user and group)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按权限搜索（用户和组）
- en: Search on ownership
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按所有权搜索
- en: Search on file type
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按文件类型搜索
- en: Search on file size
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按文件大小搜索
- en: Search on timestamps (created, last-modified, last-accessed)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按时间戳搜索（创建时间，最后修改时间，最后访问时间）
- en: Search only in certain directories
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在特定目录中搜索
- en: 'It would take a full chapter to explain all of the functionality in the `find`
    command. We will only be describing the most common use cases. The real lesson
    here is being aware of the advanced functionalities of `find`; if you ever need
    to look for files with a specific set of attributes, always think of the `find`
    command first and check out the `man file` page to see if you can utilize find
    for your search (spoiler alert: this is **almost always** the case!).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 解释`find`命令的所有功能需要一整章的篇幅。我们只会描述最常见的用法。真正的教训在于了解`find`的高级功能；如果你需要查找具有特定属性的文件，一定要首先考虑使用`find`命令，并查看`man
    file`页面，看看是否可以利用`find`进行搜索（剧透：**几乎总是**这样！）。
- en: 'Let''s start with the basic use of find: `find <location> <options and arguments>`.
    Without any options and arguments, find will print every file it finds within
    the location:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从find的基本用法开始：`find <位置> <选项和参数>`。如果没有任何选项和参数，find将打印出位置内找到的每个文件：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You might have been under the impression that your `home` directory was empty.
    It actually contains quite a number of hidden files or directories (which start
    with a dot), which `find` has found for us. Now, let''s apply a filter with the
    `-name` option:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能以为你的`home`目录是空的。实际上，它包含了相当多的隐藏文件或目录（以点开头），这些文件被`find`找到了。现在，让我们使用`-name`选项应用一个过滤器：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Contrary to what you might have expected, `find` works differently from `locate`
    with regards to partly matched files. Unless you add wildcards around the argument
    to `-name`, it will only match on the full filename, not on partly matched files.
    This is definitely something to keep in mind. Now, what about looking only for
    files, instead of directories as well? For this, we can use the `-type` option
    with the `d` argument for directories or `f` for files:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与你可能期望的相反，`find`与`locate`在部分匹配文件方面的工作方式不同。除非在`-name`参数的参数周围添加通配符，否则它只会匹配完整的文件名，而不是部分匹配的文件。这绝对是需要记住的事情。那么，仅查找文件而不是目录呢？为此，我们可以使用`-type`选项和`d`参数表示目录，或者使用`f`表示文件：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The first result presents all directories within `/home/reader/` (including
    `/home/reader/!`), while the second result prints all files. As you can see, there
    is no overlap, since a file under Linux is *always of only one type*. We can also
    combine multiple options, such as `-name` and `-type`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个结果显示了`/home/reader/`内的所有目录（包括`/home/reader/!`），而第二个结果打印了所有文件。你可以看到，没有重叠，因为在Linux下，文件*总是只有一种类型*。我们还可以组合多个选项，比如`-name`和`-type`：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We start by looking for *files* in `/home/reader/` which contain the string
    cache. The `find` command does not print anything, which means we did not find
    anything. If we look for *directories* with the cache string, however, we are
    shown the `/home/reader/.cache/` directory.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在`/home/reader/`中寻找包含字符串cache的*文件*。`find`命令没有打印任何内容，这意味着我们没有找到任何东西。然而，如果我们寻找包含cache字符串的*目录*，我们会看到`/home/reader/.cache/`目录。
- en: 'As a last example, let''s look at how we can use `find` to distinguish between
    files of different sizes. To do this, we''ll create an empty file using `touch`
    and a non-empty file using `vim` (or `nano`):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子，让我们看看如何使用`find`来区分不同大小的文件。为此，我们将使用`touch`创建一个空文件，使用`vim`（或`nano`）创建一个非空文件：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As you can see from the `0` and `23` on-screen, `emptyfile` contains 0 bytes,
    whereas `textfile.txt` contains 23 bytes (which, not entirely coincidental, contains
    a sentence of 23 characters). Let''s see how we can use the `find` command to
    find both files:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从屏幕上的`0`和`23`可以看出，`emptyfile`包含0字节，而`textfile.txt`包含23字节（这不是巧合，它包含了23个字符的句子）。让我们看看如何使用`find`命令找到这两个文件：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To do this, we use the `-size` option. We give it the number we''re looking
    for, followed by a letter which indicates which range we''re dealing with. `c`
    is used for bytes, `k` for kilobytes, `M` for megabytes, and so on. You can find
    these values on the manual page. As the results show, there are three files which
    are exactly 0 bytes: our `emptyfile` is one of them. These is one file which is
    exactly 23 bytes: our `textfile.txt`. You might think: 23 bytes, that''s very
    specific! How will we ever know how many bytes a file is exactly? Well, you won''t.
    The creators of `find` have also implemented a *greater than* and *lower than*
    construct, which we can use to give us a little more flexibility:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们使用了`-size`选项。我们给出了我们要查找的数字，后面跟着一个表示我们正在处理的范围的字母。`c`用于字节，`k`用于千字节，`M`用于兆字节，依此类推。您可以在手册页上找到这些值。正如结果所示，有三个文件的大小正好为0字节：我们的`emptyfile`就是其中之一。有一个文件的大小正好为23字节：我们的`textfile.txt`。您可能会想：23字节，那非常具体！我们怎么知道文件的确切字节数呢？好吧，您不会知道。`find`的创建者还实现了*大于*和*小于*的结构，我们可以使用它们来提供更多的灵活性：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's say we're looking for a file that's at least larger than 10 bytes. We
    use the `+` option on the argument, which only prints the files that are larger
    than 10 bytes. However, we still see too many files. Now, we expect the file to
    also be smaller than 30 bytes. We add another `-size` option, this time specifying
    `-30c`, meaning that the file will be less than 30 bytes. And, not entirely unexpectedly,
    our 23 byte `testfile.txt` is found!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在寻找一个至少大于10字节的文件。我们在参数上使用`+`选项，它只打印大于10字节的文件。然而，我们仍然看到了太多的文件。现在，我们希望文件也小于30字节。我们添加另一个`-size`选项，这次指定`-30c`，意味着文件将小于30字节。并且，毫不意外，我们找到了我们的23字节的`testfile.txt`！
- en: All of the preceding options and more can be combined to form a very powerful
    search query. Are you looking for a *file*, which is *at least* 100 KB but *not
    more than* 10 MB, located *somewhere in* `/var/`, that was created *in the last
    week*, and is *readable* to you? Just combine the options in `find` and you will
    definitely find that file in no time!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述选项以及更多选项都可以组合在一起，形成一个非常强大的搜索查询。您是否正在寻找一个*文件*，它*至少*有100 KB，但*不超过*10 MB，在`/var/`中的*任何位置*，在*上周*创建，并且对您是*可读*的？只需在`find`中组合选项，您肯定会在短时间内找到该文件！
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter described file manipulation in Linux. We started with common file
    operations. We explained how to we can copy files in Linux with `cp` and how we
    can move or rename files with `mv`. Next, we discussed how we can remove files
    and directories with `rm` and how we can create *shortcuts* under Linux with symbolic
    links by using the `ln -s` command.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了Linux中的文件操作。我们从常见的文件操作开始。我们解释了如何在Linux中使用`cp`复制文件，以及如何使用`mv`移动或重命名文件。接下来，我们讨论了如何使用`rm`删除文件和目录，以及如何使用`ln
    -s`命令在Linux下创建符号链接。
- en: 'In the second part of this chapter, we discussed archiving. While there are
    many different tools that allow archiving, we focused on the most commonly used
    one in Linux: `tar`. We showed you how to create and extract archives, both in
    the current working directory and to somewhere else on the filesystem. We described
    that both files and whole directories can be archived by `tar`, and that we can
    see what''s inside a tarball without actually extracting it by using the `-t`
    option.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分中，我们讨论了归档。虽然有许多不同的工具可以进行归档，但我们专注于Linux中最常用的工具：`tar`。我们向您展示了如何在当前工作目录和文件系统的其他位置创建和提取归档。我们描述了`tar`可以归档文件和整个目录，并且我们可以使用`-t`选项在不实际提取它的情况下查看tarball中的内容。
- en: We ended this chapter with finding files using `file` and `locate`. We explained
    that `locate` is a simple command that is useful under certain circumstances,
    while `find` is a more complicated but very powerful command that can provide
    great benefits to those who master it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以使用`file`和`locate`查找文件结束了本章。我们解释了`locate`是一个在特定情况下有用的简单命令，而`find`是一个更复杂但非常强大的命令，可以为掌握它的人带来巨大的好处。
- en: The following commands were introduced in this chapter: `cp`, `rm`, `mv`, `ln`,
    `tar`, `locate`, and `find`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了以下命令：`cp`、`rm`、`mv`、`ln`、`tar`、`locate`和`find`。
- en: Questions
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which command do we use to copy files in Linux?
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在Linux中使用哪个命令来复制文件？
- en: What is the difference between moving and renaming files?
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移动和重命名文件之间有什么区别？
- en: Why is the `rm` command, which is used to remove files under Linux, potentially
    dangerous?
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于在Linux下删除文件的`rm`命令为什么可能很危险？
- en: What is the difference between a hard link and a symbolic (soft) link?
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 硬链接和符号（软）链接之间有什么区别？
- en: What are the three most important operating modes of `tar`?
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tar`的三种最重要的操作模式是什么？'
- en: Which option is used by `tar` to select the output directory?
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tar`用于选择输出目录的选项是什么？'
- en: What is the biggest difference between `locate` and `find` when searching on
    filenames?
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索文件名时，“locate”和“find”之间最大的区别是什么？
- en: How many options of `find` can be combined?
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “find”有多少个选项可以组合使用？
- en: Further reading
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following resources might be interesting if you''d like to go deeper into
    the subjects of this chapter:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源可能会很有趣，如果您想深入了解本章的主题：
- en: '**File manipulation**: [https://ryanstutorials.net/linuxtutorial/filemanipulation.php](https://ryanstutorials.net/linuxtutorial/filemanipulation.php)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件操作**：[https://ryanstutorials.net/linuxtutorial/filemanipulation.php](https://ryanstutorials.net/linuxtutorial/filemanipulation.php)'
- en: '**Tar tutorial**: [https://www.poftut.com/linux-tar-command-tutorial-with-examples/](https://www.poftut.com/linux-tar-command-tutorial-with-examples/)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tar教程**：[https://www.poftut.com/linux-tar-command-tutorial-with-examples/](https://www.poftut.com/linux-tar-command-tutorial-with-examples/)'
- en: '**Find practical examples**: [https://www.tecmint.com/35-practical-examples-of-linux-find-command/](https://www.tecmint.com/35-practical-examples-of-linux-find-command/)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查找实际示例**：[https://www.tecmint.com/35-practical-examples-of-linux-find-command/](https://www.tecmint.com/35-practical-examples-of-linux-find-command/)'
