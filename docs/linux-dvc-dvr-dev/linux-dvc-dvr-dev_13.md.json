["```\nstruct bus_type { \n   const char *name; \n   const char *dev_name; \n   struct device *dev_root; \n   struct device_attribute  *dev_attrs; /* use dev_groups instead */ \n   const struct attribute_group **bus_groups; \n   const struct attribute_group **dev_groups; \n   const struct attribute_group **drv_groups; \n\n   int (*match)(struct device *dev, struct device_driver *drv); \n   int (*probe)(struct device *dev); \n   int (*remove)(struct device *dev); \n   void (*shutdown)(struct device *dev); \n\n   int (*suspend)(struct device *dev, pm_message_t state); \n   int (*resume)(struct device *dev); \n\n   const struct dev_pm_ops *pm; \n\n   struct subsys_private *p; \n   struct lock_class_key lock_key; \n}; \n```", "```\n#define to_packt_driver(d) container_of(d, struct packt_driver, driver) \n#define to_packt_device(d) container_of(d, struct packt_device, dev) \n```", "```\nstruct packt_device_id { \n    char name[PACKT_NAME_SIZE]; \n    kernel_ulong_t driver_data;   /* Data private to the driver */ \n}; \n```", "```\n/* \n * Bus specific device structure \n * This is what a packt device structure looks like \n */ \nstruct packt_device { \n   struct module *owner; \n   unsigned char name[30]; \n   unsigned long price; \n   struct device dev; \n}; \n\n/* \n * Bus specific driver structure \n * This is what a packt driver structure looks like \n * You should provide your device's probe and remove function. \n * may be release too \n */ \nstruct packt_driver { \n   int (*probe)(struct packt_device *packt); \n   int (*remove)(struct packt_device *packt); \n   void (*shutdown)(struct packt_device *packt); \n}; \n```", "```\n/* \n * Now let us write and export symbols that people writing \n * drivers for packt devices must use. \n */ \n\nint packt_register_driver(struct packt_driver *driver) \n{   \n   driver->driver.bus = &packt_bus_type; \n   return driver_register(&driver->driver); \n} \nEXPORT_SYMBOL(packt_register_driver); \n\nvoid packt_unregister_driver(struct packt_driver *driver) \n{ \n   driver_unregister(&driver->driver); \n} \nEXPORT_SYMBOL(packt_unregister_driver); \n\nint packt_device_register(struct packt_device *packt) \n{ \n   return device_register(&packt->dev); \n} \nEXPORT_SYMBOL(packt_device_register); \n\nvoid packt_unregister_device(struct packt_device *packt) \n{ \n   device_unregister(&packt->dev); \n} \nEXPORT_SYMBOL(packt_device_unregister); \n```", "```\n/* \n * This function allocate a bus specific device structure \n * One must call packt_device_register to register \n * the device with the bus \n */ \nstruct packt_device * packt_device_alloc(const char *name, int id) \n{ \n   struct packt_device *packt_dev; \n   int status; \n\n   packt_dev = kzalloc(sizeof *packt_dev, GFP_KERNEL); \n   if (!packt_dev) \n         return NULL; \n\n    /* new devices on the bus are son of the bus device */ \n    strcpy(packt_dev->name, name); \n    packt_dev->dev.id = id; \n    dev_dbg(&packt_dev->dev, \n      \"device [%s] registered with packt bus\\n\", packt_dev->name); \n\n    return packt_dev; \n\nout_err: \n    dev_err(&adap->dev, \"Failed to register packt client %s\\n\", packt_dev->name); \n    kfree(packt_dev); \n    return NULL; \n} \nEXPORT_SYMBOL_GPL(packt_device_alloc); \n\nint packt_device_register(struct packt_device *packt) \n{ \n    packt->dev.parent = &packt_bus; \n   packt->dev.bus = &packt_bus_type; \n   return device_register(&packt->dev); \n} \nEXPORT_SYMBOL(packt_device_register); \n```", "```\n/* \n * This is our bus structure \n */ \nstruct bus_type packt_bus_type = { \n   .name      = \"packt\", \n   .match     = packt_device_match, \n   .probe     = packt_device_probe, \n   .remove    = packt_device_remove, \n   .shutdown  = packt_device_shutdown, \n}; \n```", "```\n/* \n * Bus device, the master. \n *  \n */ \nstruct device packt_bus = { \n    .release  = packt_bus_release, \n    .parent = NULL, /* Root device, no parent needed */ \n}; \n\nstatic int __init packt_init(void) \n{ \n    int status; \n    status = bus_register(&packt_bus_type); \n    if (status < 0) \n        goto err0; \n\n    status = class_register(&packt_master_class); \n    if (status < 0) \n        goto err1; \n\n    /* \n     * After this call, the new bus device will appear \n     * under /sys/devices in sysfs. Any devices added to this \n     * bus will shows up under /sys/devices/packt-0/. \n     */ \n    device_register(&packt_bus); \n\n   return 0; \n\nerr1: \n   bus_unregister(&packt_bus_type); \nerr0: \n   return status; \n} \n```", "```\nint packt_device_register(struct packt_device *packt) \n{ \n    packt->dev.parent = &packt_bus; \n   packt->dev.bus = &packt_bus_type; \n   return device_register(&packt->dev); \n} \nEXPORT_SYMBOL(packt_device_register); \n```", "```\nstruct device_driver { \n    const char *name; \n    struct bus_type *bus; \n    struct module *owner; \n\n    const struct of_device_id   *of_match_table; \n    const struct acpi_device_id  *acpi_match_table; \n\n    int (*probe) (struct device *dev); \n    int (*remove) (struct device *dev); \n    void (*shutdown) (struct device *dev); \n    int (*suspend) (struct device *dev, pm_message_t state); \n    int (*resume) (struct device *dev); \n    const struct attribute_group **groups; \n\n    const struct dev_pm_ops *pm; \n}; \n```", "```\nstruct of_device_id { \n    char compatible[128]; \n    const void *data; \n}; \n```", "```\nint bus_for_each_drv(struct bus_type * bus, \n                struct device_driver * start,  \n                void * data, int (*fn)(struct device_driver *, \n                void *)); \n```", "```\nstruct device { \n    struct device *parent; \n    struct kobject kobj; \n    const struct device_type *type; \n    struct bus_type      *bus; \n    struct device_driver *driver; \n    void    *platform_data; \n    void *driver_data; \n    struct device_node      *of_node; \n    struct class *class; \n    const struct attribute_group **groups; \n    void (*release)(struct device *dev); \n}; \n```", "```\nint device_add(struct device *dev) \n{ \n    [...] \n    bus_probe_device(dev); \n       if (parent) \n             klist_add_tail(&dev->p->knode_parent, \n                          &parent->p->klist_children); \n    [...] \n} \n```", "```\nint bus_for_each_dev(struct bus_type * bus, \n                    struct device * start, void * data, \n                    int (*fn)(struct device *, void *)); \n```", "```\nstruct kobject { \n    const char *name; \n    struct list_head entry; \n    struct kobject *parent; \n    struct kset *kset; \n    struct kobj_type *ktype; \n    struct sysfs_dirent *sd; \n    struct kref kref; \n    /* Fields out of our interest have been removed */ \n}; \n```", "```\nstruct kobject *kobject_create(void) \nvoid kobject_init(struct kobject *kobj, struct kobj_type *ktype) \n```", "```\nint kobject_add(struct kobject *kobj, struct kobject *parent, \n                const char *fmt, ...); \n```", "```\n/* Somewhere */ \nstatic struct kobject *mykobj; \n\nmykobj = kobject_create(); \n    if (mykobj) { \n        kobject_init(mykobj, &mytype); \n        if (kobject_add(mykobj, NULL, \"%s\", \"hello\")) { \n             err = -1; \n             printk(\"ldm: kobject_add() failed\\n\"); \n             kobject_put(mykobj); \n             mykobj = NULL; \n        } \n        err = 0; \n    } \n```", "```\nstatic struct kobject * class_kobj   = NULL; \nstatic struct kobject * devices_kobj = NULL; \n\n/* Create /sys/class */ \nclass_kobj = kobject_create_and_add(\"class\", NULL); \n\nif (!class_kobj) { \n    return -ENOMEM; \n} \n\n/* Create /sys/devices */ \ndevices_kobj = kobject_create_and_add(\"devices\", NULL); \n\nif (!devices_kobj) { \n    return -ENOMEM; \n} \n```", "```\nstruct kobj_type { \n   void (*release)(struct kobject *); \n   const struct sysfs_ops sysfs_ops; \n   struct attribute **default_attrs; \n}; \n```", "```\nstruct sysfs_ops { \n    ssize_t (*show)(struct kobject *kobj, \n                    struct attribute *attr, char *buf); \n    ssize_t (*store)(struct kobject *kobj, \n                     struct attribute *attr,const char *buf, \n                     size_t size); \n}; \n```", "```\nstruct kobj_type *get_ktype(struct  kobject *kobj); \n```", "```\nstatic struct sysfs_ops s_ops = { \n    .show = show, \n    .store = store, \n}; \n\nstatic struct kobj_type k_type = { \n    .sysfs_ops = &s_ops, \n    .default_attrs = d_attrs, \n}; \n```", "```\nstatic ssize_t show(struct kobject *kobj, struct attribute *attr, char *buf) \n{ \n    struct d_attr *da = container_of(attr, struct d_attr, attr); \n    printk( \"LDM show: called for (%s) attr\\n\", da->attr.name ); \n    return scnprintf(buf, PAGE_SIZE, \n                     \"%s: %d\\n\", da->attr.name, da->value); \n} \n\nstatic ssize_t store(struct kobject *kobj, struct attribute *attr, const char *buf, size_t len) \n{ \n    struct d_attr *da = container_of(attr, struct d_attr, attr); \n    sscanf(buf, \"%d\", &da->value); \n    printk(\"LDM store: %s = %d\\n\", da->attr.name, da->value); \n\n    return sizeof(int); \n} \n```", "```\nstruct kset { \n   struct list_head list;  \n   spinlock_t list_lock; \n   struct kobject kobj; \n }; \n```", "```\nstruct kset * kset_create_and_add(const char *name, \n                                const struct kset_uevent_ops *u, \n                                struct kobject *parent_kobj); \nvoid kset_unregister (struct kset * k); \n```", "```\nstatic struct kobject foo_kobj, bar_kobj; \n\nexample_kset = kset_create_and_add(\"kset_example\", NULL, kernel_kobj); \n/* \n * since we have a kset for this kobject, \n * we need to set it before calling the kobject core. \n */ \nfoo_kobj.kset = example_kset; \nbar_kobj.kset = example_kset; \n\nretval = kobject_init_and_add(&foo_kobj, &foo_ktype, \n                              NULL, \"foo_name\"); \nretval = kobject_init_and_add(&bar_kobj, &bar_ktype, \n                              NULL, \"bar_name\"); \n```", "```\nkset_unregister(example_kset); \n```", "```\nstruct attribute { \n        char * name; \n        struct module *owner; \n        umode_t mode; \n}; \n```", "```\nint sysfs_create_file(struct kobject * kobj, \n                      const struct attribute * attr); \nvoid sysfs_remove_file(struct kobject * kobj, \n                        const struct attribute * attr); \n```", "```\nstruct d_attr { \n    struct attribute attr; \n    int value; \n}; \n\nstatic struct d_attr foo = { \n    .attr.name=\"foo\", \n    .attr.mode = 0644, \n    .value = 0, \n}; \n\nstatic struct d_attr bar = { \n    .attr.name=\"bar\", \n    .attr.mode = 0644, \n    .value = 0, \n}; \n```", "```\nsysfs_create_file(mykobj, &foo.attr); \nsysfs_create_file(mykobj, &bar.attr); \n```", "```\nstruct attribute_group { \n   struct attribute  **attrs; \n}; \n```", "```\nint sysfs_create_group(struct kobject *kobj, \n                       const struct attribute_group *grp) \nvoid sysfs_remove_group(struct kobject * kobj, \n                        const struct attribute_group * grp) \n```", "```\nstatic struct d_attr foo = { \n    .attr.name=\"foo\", \n    .attr.mode = 0644, \n    .value = 0, \n}; \n\nstatic struct d_attr bar = { \n    .attr.name=\"bar\", \n    .attr.mode = 0644, \n    .value = 0, \n}; \n\n/* attrs is a pointer to a list (array) of attributes */ \nstatic struct attribute * attrs [] = \n{ \n    &foo.attr, \n    &bar.attr, \n    NULL, \n}; \n\nstatic struct attribute_group my_attr_group = { \n    .attrs = attrs, \n}; \n```", "```\nsysfs_create_group(mykobj, &my_attr_group); \n```", "```\n    /sys$ tree -L 1\n\n    \u251c\u2500\u2500 block\n\n    \u251c\u2500\u2500 bus\n\n    \u251c\u2500\u2500 class\n\n    \u251c\u2500\u2500 dev\n\n    \u251c\u2500\u2500 devices\n\n    \u251c\u2500\u2500 firmware\n\n    \u251c\u2500\u2500 fs\n\n    \u251c\u2500\u2500 hypervisor\n\n    \u251c\u2500\u2500 kernel\n\n    \u251c\u2500\u2500 module\n\n    \u2514\u2500\u2500 power\n\n```", "```\nint sysfs_create_link(struct kobject * kobj, \n                      struct kobject * target, char * name);  \nvoid sysfs_remove_link(struct kobject * kobj, char * name); \n```", "```\nint sysfs_create_file(struct kobject *kobj,  \n                      const struct attribute *attr); \nvoid sysfs_remove_file(struct kobject *kobj, \n                       const struct attribute *attr); \nint sysfs_create_group(struct kobject *kobj, \n                       const struct attribute_group *grp); \nvoid sysfs_remove_group(struct kobject * kobj, \n                        const struct attribute_group * grp); \n```", "```\nstruct device_attribute { \n    struct attribute attr; \n    ssize_t (*show)(struct device *dev, \n                    struct device_attribute *attr, \n                   char *buf); \n    ssize_t (*store)(struct device *dev, \n                     struct device_attribute *attr, \n                     const char *buf, size_t count); \n}; \n```", "```\nDEVICE_ATTR(_name, _mode, _show, _store); \n```", "```\n#define DEVICE_ATTR(_name, _mode, _show, _store) \\ \n   struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store) \n```", "```\nint device_create_file(struct device *dev,  \n                      const struct device_attribute * attr); \nvoid device_remove_file(struct device *dev, \n                       const struct device_attribute * attr); \n```", "```\nstatic ssize_t foo_show(struct device *child, \n    struct device_attribute *attr, char *buf) \n{ \n    return sprintf(buf, \"%d\\n\", foo_value); \n} \n\nstatic ssize_t bar_show(struct device *child, \n         struct device_attribute *attr, char *buf) \n{ \n    return sprintf(buf, \"%d\\n\", bar_value); \n}  \n```", "```\nstatic DEVICE_ATTR(foo, 0644, foo_show, NULL); \nstatic DEVICE_ATTR(bar, 0644, bar_show, NULL); \n```", "```\nif ( device_create_file(dev, &dev_attr_foo) != 0 ) \n    /* handle error */ \n\nif ( device_create_file(dev, &dev_attr_bar) != 0 ) \n    /* handle error*/ \n```", "```\ndevice_remove_file(wm->dev, &dev_attr_foo); \ndevice_remove_file(wm->dev, &dev_attr_bar); \n```", "```\nstatic ssize_t dev_attr_show(struct kobject *kobj, \n                            struct attribute *attr, \n                            char *buf) \n{ \n   struct device_attribute *dev_attr = to_dev_attr(attr); \n   struct device *dev = kobj_to_dev(kobj); \n   ssize_t ret = -EIO; \n\n   if (dev_attr->show) \n         ret = dev_attr->show(dev, dev_attr, buf); \n   if (ret >= (ssize_t)PAGE_SIZE) { \n         print_symbol(\"dev_attr_show: %s returned bad count\\n\", \n                     (unsigned long)dev_attr->show); \n   } \n   return ret; \n} \n\nstatic ssize_t dev_attr_store(struct kobject *kobj, struct attribute *attr, \n                     const char *buf, size_t count) \n{ \n   struct device_attribute *dev_attr = to_dev_attr(attr); \n   struct device *dev = kobj_to_dev(kobj); \n   ssize_t ret = -EIO; \n\n   if (dev_attr->store) \n         ret = dev_attr->store(dev, dev_attr, buf, count); \n   return ret; \n} \n\nstatic const struct sysfs_ops dev_sysfs_ops = { \n   .show = dev_attr_show, \n   .store      = dev_attr_store, \n}; \n```", "```\nstruct bus_attribute { \n   struct attribute attr; \n   ssize_t (*show)(struct bus_type *, char * buf); \n   ssize_t (*store)(struct bus_type *, const char * buf, size_t count); \n}; \n```", "```\nBUS_ATTR(_name, _mode, _show, _store) \n```", "```\n#define BUS_ATTR(_name, _mode, _show, _store)      \\ \nstruct bus_attribute bus_attr_##_name = __ATTR(_name, _mode, _show, _store) \n```", "```\nint bus_create_file(struct bus_type *, struct bus_attribute *); \nvoid bus_remove_file(struct bus_type *, struct bus_attribute *); \n```", "```\nstruct driver_attribute { \n        struct attribute attr; \n        ssize_t (*show)(struct device_driver *, char * buf); \n        ssize_t (*store)(struct device_driver *, const char * buf, \n                         size_t count); \n}; \n```", "```\nDRIVER_ATTR(_name, _mode, _show, _store) \n```", "```\n#define DRIVER_ATTR(_name, _mode, _show, _store) \\ \nstruct driver_attribute driver_attr_##_name = __ATTR(_name, _mode, _show, _store) \n```", "```\nint driver_create_file(struct device_driver *, \n                       const struct driver_attribute *); \nvoid driver_remove_file(struct device_driver *, \n                       const struct driver_attribute *); \n```", "```\nstruct class_attribute { \n        struct attribute        attr; \n        ssize_t (*show)(struct device_driver *, char * buf); \n        ssize_t (*store)(struct device_driver *, const char * buf, \n                         size_t count); \n}; \n```", "```\nCLASS_ATTR(_name, _mode, _show, _store) \n```", "```\n#define CLASS_ATTR(_name, _mode, _show, _store) \\ \nstruct class_attribute class_attr_##_name = __ATTR(_name, _mode, _show, _store) \n```", "```\nint class_create_file(struct class *class, \n        const struct class_attribute *attr); \n\nvoid class_remove_file(struct class *class, \n        const struct class_attribute *attr); \n```", "```\nint device_create_file(struct device *dev, \n                    const struct device_attribute *attr) \n{ \n    [...] \n    error = sysfs_create_file(&dev->kobj, &attr->attr); \n    [...] \n} \n\nint class_create_file(struct class *cls, \n                    const struct class_attribute *attr) \n{ \n    [...] \n    error = \n        sysfs_create_file(&cls->p->class_subsys.kobj, \n                          &attr->attr); \n    return error; \n} \n\nint bus_create_file(struct bus_type *bus, \n                   struct bus_attribute *attr) \n{ \n    [...] \n    error = \n        sysfs_create_file(&bus->p->subsys.kobj, \n                           &attr->attr); \n    [...] \n} \n```", "```\nvoid sysfs_notify(struct kobject *kobj, const char *dir, \n                  const char *attr) \n```", "```\nstatic ssize_t store(struct kobject *kobj, struct attribute *attr, \n                     const char *buf, size_t len) \n{ \n    struct d_attr *da = container_of(attr, struct d_attr, attr); \n\n    sscanf(buf, \"%d\", &da->value); \n    printk(\"sysfs_foo store %s = %d\\n\", a->attr.name, a->value); \n\n    if (strcmp(a->attr.name, \"foo\") == 0){ \n        foo.value = a->value; \n        sysfs_notify(mykobj, NULL, \"foo\"); \n    } \n    else if(strcmp(a->attr.name, \"bar\") == 0){ \n        bar.value = a->value; \n        sysfs_notify(mykobj, NULL, \"bar\"); \n    } \n    return sizeof(int); \n} \n```"]