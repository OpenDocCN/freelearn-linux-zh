- en: Chapter 11. Managing Memory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。管理内存
- en: This chapter covers issues relating to memory management, which is an important
    topic for any Linux system, but especially for embedded Linux where system memory
    is usually in limited supply. After a brief refresher on virtual memory, I will
    show you how to measure memory use, how to detect problems with memory allocation,
    including memory leaks, and what happens when you run out of memory. You will
    have to understand the tools that are available, from simple tools such as `free`
    and `top`, to complex tools such as mtrace and Valgrind.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了与内存管理相关的问题，这对于任何Linux系统都是一个重要的话题，但对于嵌入式Linux来说尤其重要，因为系统内存通常是有限的。在简要回顾了虚拟内存之后，我将向您展示如何测量内存使用情况，如何检测内存分配的问题，包括内存泄漏，以及当内存用尽时会发生什么。您必须了解可用的工具，从简单的工具如`free`和`top`，到复杂的工具如mtrace和Valgrind。
- en: Virtual memory basics
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟内存基础知识
- en: To recap, Linux configures the memory management unit of the CPU to present
    a virtual address space to a running program that begins at zero and ends at the
    highest address, `0xffffffff` on a 32-bit processor. That address space is divided
    into pages of 4 KiB (there are rare examples of systems using other page sizes).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，Linux配置CPU的内存管理单元，向运行的程序呈现一个虚拟地址空间，从零开始，到32位处理器上的最高地址`0xffffffff`结束。该地址空间被分成4
    KiB的页面（也有一些罕见的系统使用其他页面大小）。
- en: 'Linux divides this virtual address space into an area for applications, called
    user space, and an area for the kernel, called kernel space. The split between
    the two is set by a kernel configuration parameter named `PAGE_OFFSET`. In a typical
    32-bit embedded system, `PAGE_OFFSET` is `0xc0000000`, giving the lower three
    GiB to user space and the top one GiB to kernel space. The user address space
    is allocated per process, so that each process runs in a sandbox, separated from
    the others. The kernel address space is the same for all processes: there is only
    one kernel.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Linux将这个虚拟地址空间分为一个称为用户空间的应用程序区域和一个称为内核空间的内核区域。这两者之间的分割由一个名为`PAGE_OFFSET`的内核配置参数设置。在典型的32位嵌入式系统中，`PAGE_OFFSET`是`0xc0000000`，将低3
    GiB分配给用户空间，将顶部1 GiB分配给内核空间。用户地址空间是针对每个进程分配的，因此每个进程都在一个沙盒中运行，与其他进程分离。内核地址空间对所有进程都是相同的：只有一个内核。
- en: Pages in this virtual address space are mapped to physical addresses by the
    **memory management unit** (**MMU**), which uses page tables to perform the mapping.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个虚拟地址空间中的页面通过**内存管理单元**（**MMU**）映射到物理地址，后者使用页表执行映射。
- en: 'Each page of virtual memory may be:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟内存页面可能是：
- en: unmapped, in which access will result in a `SIGSEGV`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未映射，访问将导致`SIGSEGV`
- en: mapped to a page of physical memory that is private to the process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射到进程私有的物理内存页面
- en: mapped to a page of physical memory that is shared with other processes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射到与其他进程共享的物理内存页面
- en: 'mapped and shared with a `copy on write` flag set: a write is trapped in the
    kernel which makes a copy of the page and maps it to the process in place of the
    original page before allowing the write to take place'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射并与设置了`写时复制`标志的共享：写入被内核捕获，内核复制页面并将其映射到原始页面的进程中，然后允许写入发生
- en: mapped to a page of physical memory that is used by the kernel
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射到内核使用的物理内存页面
- en: The kernel may additionally map pages to reserved memory regions, for example,
    to access registers and buffer memory in device drivers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 内核可能还会将页面映射到保留的内存区域，例如，以访问设备驱动程序中的寄存器和缓冲内存
- en: An obvious question is, why do we do it this way instead of simply referencing
    physical memory directly, as typical RTOS would?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的问题是，为什么我们要这样做，而不是像典型的RTOS那样直接引用物理内存？
- en: 'There are numerous advantages to virtual memory, some of which are described
    here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟内存有许多优点，其中一些在这里描述：
- en: Invalid memory accesses are trapped and applications alerted by `SIGSEGV`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无效的内存访问被捕获，并通过`SIGSEGV`通知应用程序
- en: Processes run in their own memory space, isolated from others
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程在自己的内存空间中运行，与其他进程隔离
- en: Efficient use of memory through the sharing of common code and data, for example,
    in libraries
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过共享公共代码和数据来有效利用内存，例如在库中
- en: The possibility of increasing the apparent amount of physical memory by adding
    swap files, although swapping on embedded targets is rare
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加交换文件来增加物理内存的表面数量的可能性，尽管在嵌入式目标上进行交换是罕见的
- en: These are powerful arguments, but we have to admit that there are some disadvantages
    as well. It is difficult to determine the actual memory budget of an application,
    which is one of the main concerns of this chapter. The default allocation strategy
    is to over-commit, which leads to tricky out-of-memory situations, which I will
    also discuss later on. Finally, the delays introduced by the memory management
    code in handling exceptions – page faults – make the system less deterministic,
    which is important for real-time programs. I will cover this in [Chapter 14](ch14.html
    "Chapter 14. Real-time Programming"), *Real-time Programming*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是有力的论据，但我们必须承认也存在一些缺点。很难确定应用程序的实际内存预算，这是本章的主要关注点之一。默认的分配策略是过度承诺，这会导致棘手的内存不足情况，我稍后也会讨论。最后，内存管理代码在处理异常（页面错误）时引入的延迟使系统变得不太确定，这对实时程序很重要。我将在[第14章](ch14.html
    "第14章。实时编程") *实时编程*中介绍这一点。
- en: Memory management is different for kernel space and user space. The following
    sections describe the essential differences and the things you need to know.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 内核空间和用户空间的内存管理是不同的。以下部分描述了基本的区别和你需要了解的事情。
- en: Kernel space memory layout
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核空间内存布局
- en: Kernel memory is managed in a fairly straightforward way. It is not demand-paged,
    meaning that, for every allocation using `kmalloc()` or similar function, there
    is real physical memory. Kernel memory is never discarded or paged out.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 内核内存的管理方式相当直接。它不是按需分页的，这意味着对于每个使用`kmalloc()`或类似函数进行的分配，都有真正的物理内存。内核内存从不被丢弃或分页出去。
- en: 'Some architectures show a summary of the memory mapping at boot time in the
    kernel log messages. This trace is taken from a 32-bit ARM device (a BeagleBone
    Black):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一些体系结构在内核日志消息中显示了启动时内存映射的摘要。这个跟踪来自一个32位ARM设备（BeagleBone Black）：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The figure of 505980 KiB available is the amount of free memory the kernel sees
    when it begins execution but before it begins making dynamic allocations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 505980 KiB可用的数字是内核在开始执行但在开始进行动态分配之前看到的空闲内存量。
- en: 'Consumers of kernel-space memory include the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 内核空间内存的使用者包括以下内容：
- en: The kernel itself, in other words, the code and data loaded from the kernel
    image file at boot time. This is shown in the preceding code in the segments `.text`,
    `.init`, `.data`, and `.bss`. The `.init` segment is freed once the kernel has
    completed initialization.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核本身，换句话说，从内核映像文件在启动时加载的代码和数据。这在前面的代码中显示在段`.text`、`.init`、`.data`和`.bss`中。一旦内核完成初始化，`.init`段就被释放。
- en: Memory allocated through the slab allocator, which is used for kernel data structures
    of various kinds. This includes allocations made using `kmalloc()`. They come
    from the region marked `lowmem`.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过slab分配器分配的内存，用于各种内核数据结构。这包括使用`kmalloc()`进行的分配。它们来自标记为`lowmem`的区域。
- en: Memory allocated via `vmalloc()`, usually for larger chunks of memory than is
    available through `kmalloc()`. These are in the vmalloc area.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`vmalloc()`分配的内存，通常比通过`kmalloc()`可用的内存大。这些位于vmalloc区域。
- en: Mapping for device drivers to access registers and memory belonging to various
    bits of hardware, which you can see by reading `/proc/iomem`. These come from
    the vmalloc area but since they are mapped to physical memory that is outside
    of main system memory, they do not take any real memory.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于设备驱动程序访问属于各种硬件部分的寄存器和内存的映射，可以通过阅读`/proc/iomem`来查看。这些来自vmalloc区域，但由于它们映射到主系统内存之外的物理内存，它们不占用任何真实的内存。
- en: Kernel modules, which are loaded into the area marked modules.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核模块，加载到标记为模块的区域。
- en: Other low level allocations that are not tracked anywhere else.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他低级别的分配在其他地方没有被跟踪。
- en: How much memory does the kernel use?
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核使用多少内存？
- en: Unfortunately, there isn't a complete answer to that question, but what follows
    is as close as we can get.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，对于这个问题并没有一个完整的答案，但接下来的内容是我们能得到的最接近的。
- en: 'Firstly, you can see the memory taken up by the kernel code and data in the
    kernel log shown previously, or you can use the `size` command, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以在之前显示的内核日志中看到内核代码和数据占用的内存，或者你可以使用`size`命令，如下所示：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Usually, the size is small when compared to the total amount of memory. If
    that is not the case, you need to look through the kernel configuration and remove
    those components that you don''t need. There is an ongoing effort to allow small
    kernels to be built: search for Linux-tiny or Linux Kernel Tinification. There
    is a project page for the latter at [https://tiny.wiki.kernel.org/](https://tiny.wiki.kernel.org/).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，与总内存量相比，大小很小。如果不是这样，你需要查看内核配置，并删除那些你不需要的组件。目前正在努力允许构建小内核：搜索Linux-tiny或Linux
    Kernel Tinification。后者有一个项目页面[https://tiny.wiki.kernel.org/](https://tiny.wiki.kernel.org/)。
- en: 'You can get more information about memory usage by reading `/proc/meminfo`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过阅读`/proc/meminfo`来获取有关内存使用情况的更多信息：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There is a description of each of these fields in the man page for `proc(5)`.
    The kernel memory usage is the sum of:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段的描述在`proc(5)`的man页面中。内核内存使用是以下内容的总和：
- en: '**Slab**: The total memory allocated by the slab allocator'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Slab**：由slab分配器分配的总内存'
- en: '**KernelStack**: The stack space used when executing kernel code'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KernelStack**：执行内核代码时使用的堆栈空间'
- en: '**PageTables**: The memory used for storing page tables'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PageTables**：用于存储页表的内存'
- en: '**VmallocUsed**: The memory allocated by `vmalloc()`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VmallocUsed**：由`vmalloc()`分配的内存'
- en: In the case of slab allocations, you can get more information by reading`/proc/slabinfo`.
    Similarly, there is a breakdown of allocations in `/proc/vmallocinfo` for the
    vmalloc area. In both cases, you need detailed knowledge of the kernel and its
    subsystems to see exactly which subsystem is making the allocations and why, which
    is beyond the scope of this discussion.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在slab分配的情况下，你可以通过阅读`/proc/slabinfo`来获取更多信息。类似地，在`/proc/vmallocinfo`中有vmalloc区域的分配细分。在这两种情况下，你需要对内核及其子系统有详细的了解，以确切地看到哪个子系统正在进行分配以及原因，这超出了本讨论的范围。
- en: 'With modules, you can use `lsmod` to find out the memory space taken up by
    the code and data:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块，你可以使用`lsmod`来查找代码和数据占用的内存空间：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That leaves the low level allocations of which there is no record, and which
    prevent us from generating an accurate account of kernel space memory usage. This
    will appear as missing memory when we add up all the kernel and user space allocations
    that we know about.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这留下了低级别的分配，没有记录，这阻止我们生成一个准确的内核空间内存使用情况。当我们把我们知道的所有内核和用户空间分配加起来时，这将出现为缺失的内存。
- en: User space memory layout
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户空间内存布局
- en: 'Linux employs a lazy allocation strategy for user space, only mapping physical
    pages of memory when the program accesses it. For example, allocating a buffer
    of 1 MiB using `malloc(3)` returns a pointer to a block of memory addresses but
    no actual physical memory. A flag is set in the page table entries such that any
    read or write access is trapped by the kernel. This is known as a page fault.
    Only at this point does the kernel attempt to find a page of physical memory and
    add it to the page table mapping for the process. It is worthwhile demonstrating
    this with a simple program like this one:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Linux采用懒惰的分配策略，只有在程序访问时才映射物理内存页面。例如，使用`malloc(3)`分配1 MiB的缓冲区返回一个内存地址块的指针，但没有实际的物理内存。在页表条目中设置一个标志，以便内核捕获任何读取或写入访问。这就是所谓的页错误。只有在这一点上，内核才尝试找到一个物理内存页，并将其添加到进程的页表映射中。值得用一个简单的程序来演示这一点：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you run it, you will see something like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，你会看到这样的东西：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There were 172 minor page faults encountered initializing the program''s environment,
    and a further 14 when calling `getrusage(2)` (these numbers will vary depending
    on the architecture and the version of the C library you are using). The important
    part is the increase when filling the memory with data: 442 – 186 = 256\. The
    buffer is 1 MiB, which is 256 pages. The second call to `memset(3)` makes no difference
    because all the pages are now mapped.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化程序环境时遇到了172个次要页面错误，并在调用`getrusage(2)`时遇到了14个次要页面错误（这些数字将根据您使用的体系结构和C库的版本而变化）。重要的部分是填充内存时的增加：442-186
    = 256。缓冲区为1 MiB，即256页。第二次调用`memset(3)`没有任何区别，因为现在所有页面都已映射。
- en: 'As you can see, a page fault is generated when the kernel traps an access to
    a page that has not been mapped. In fact, there are two kinds of page fault: minor
    and major. With a minor fault, the kernel just has to find a page of physical
    memory and map it into the process address space, as shown in the preceding code.
    A major page fault occurs when the virtual memory is mapped to a file, for example
    using `mmap(2)`, which I will describe shortly. Reading from this memory means
    that the kernel not only has to find a page of memory and map it in, but it also
    has to be filled with data from the file. Consequently, major faults are much
    more expensive in time and system resources.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，当内核捕获到对未映射的页面的访问时，将生成页面错误。实际上，有两种页面错误：次要和主要。次要错误时，内核只需找到一个物理内存页面并将其映射到进程地址空间，如前面的代码所示。主要页面错误发生在虚拟内存映射到文件时，例如使用`mmap(2)`，我将很快描述。从该内存中读取意味着内核不仅需要找到一个内存页面并将其映射进来，还需要从文件中填充数据。因此，主要错误在时间和系统资源方面要昂贵得多。
- en: Process memory map
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程内存映射
- en: 'You can see the memory map for a process through the `proc` filesystem. As
    an example, here is the map for the `init` process, PID 1:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`proc`文件系统查看进程的内存映射。例如，这是`init`进程的PID 1的映射：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first three columns show the start and end virtual addresses and the permissions
    for each mapping. The permissions are shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 前三列显示每个映射的开始和结束虚拟地址以及权限。权限在这里显示：
- en: '`r` = read'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r` = 读'
- en: '`w` = write'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w` = 写'
- en: '`x` = execute'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x` = 执行'
- en: '`s` = shared'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s` = 共享'
- en: '`p` = private (copy on write)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p` = 私有（写时复制）'
- en: 'If the mapping is associated with a file, the filename appears in the final
    column, and columns four, five, and six contain the offset from the start of the
    file, the block device number and the inode of the file. Most of the mappings
    are to the program itself and the libraries it is linked with. There are two areas
    where the program can allocate memory, marked `[heap]` and `[stack]`. Memory allocated
    using `malloc(3)` comes from the former (except for very large allocations, which
    we will come to later) ; allocations on the stack come from the latter. The maximum
    size of both areas is controlled by the process''s `ulimit`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果映射与文件相关联，则文件名将出现在最后一列，第四、五和六列包含从文件开始的偏移量，块设备号和文件的inode。大多数映射都是到程序本身和它链接的库。程序可以分配内存的两个区域，标记为“[heap]”和“[stack]”。使用`malloc(3)`分配的内存来自前者（除了非常大的分配，我们稍后会讨论）；堆栈上的分配来自后者。两个区域的最大大小由进程的`ulimit`控制：
- en: '**heap**: `ulimit -d`, default unlimited'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆**：`ulimit -d`，默认无限制'
- en: '**stack**: `ulimit -s`, default 8 MiB'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**堆栈**：`ulimit -s`，默认8 MiB'
- en: Allocations that exceed the limit are rejected by `SIGSEGV`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 超出限制的分配将被`SIGSEGV`拒绝。
- en: When running out of memory, the kernel may decide to discard pages that are
    mapped to a file and are read-only. If that page is accessed again, it will cause
    a major page fault and be read back in from the file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当内存不足时，内核可能决定丢弃映射到文件且只读的页面。如果再次访问该页面，将导致主要页面错误，并从文件中重新读取。
- en: Swap
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交换
- en: 'The idea of swapping is to reserve some storage where the kernel can place
    pages of memory that are not mapped to a file, so that it can free up the memory
    for other uses. It increases the effective size of physical memory by the size
    of the swap file. It is not a panacea: there is a cost to copying pages to and
    from a swap file which becomes apparent on a system that has too little real memory
    for the workload it is carrying and begins *disk thrashing*.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 交换的想法是保留一些存储空间，内核可以将未映射到文件的内存页面放置在其中，以便它可以释放内存供其他用途使用。它通过交换文件的大小增加了物理内存的有效大小。这并非是万能药：将页面复制到交换文件和从交换文件复制页面都会产生成本，这在承载工作负载的真实内存太少的系统上变得明显，并开始*磁盘抖动*。
- en: Swap is seldom used on embedded devices because it does not work well with flash
    storage where constant writing would wear it out quickly. However, you may want
    to consider swapping to compressed RAM (zram).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在嵌入式设备上很少使用交换，因为它与闪存存储不兼容，常量写入会迅速磨损。但是，您可能希望考虑交换到压缩的RAM（zram）。
- en: Swap to compressed memory (zram)
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交换到压缩内存（zram）
- en: The zram driver creates RAM-based block devices named `/dev/zram0`, `/dev/zram1`,
    and so on. Pages written to these devices are compressed before being stored.
    With compression ratios in the range of 30% to 50%, you can expect an overall
    increase in free memory of about 10%, at the expense of more processing and a
    corresponding increase in power usage. It is used in some low memory Android devices.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: zram驱动程序创建名为`/dev/zram0`、`/dev/zram1`等的基于RAM的块设备。写入这些设备的页面在存储之前会被压缩。通过30%至50%的压缩比，您可以预期整体空闲内存增加约10%，但会增加更多的处理和相应的功耗。它在一些低内存的Android设备上使用。
- en: 'To enable zram, configure the kernel with these options:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用zram，请使用以下选项配置内核：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, mount zram at boot time by adding this to `/etc/fstab`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过将以下内容添加到`/etc/fstab`来在启动时挂载zram：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can turn swap on and off by using these commands:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令打开和关闭交换：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Mapping memory with mmap
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用mmap映射内存
- en: 'A process begins life with a certain amount of memory mapped to the text (the
    code) and data segments of the program file, together with the shared libraries
    that it is linked with. It can allocate memory on its heap at runtime using `malloc(3)`
    and on the stack through locally scoped variables and memory allocated through
    `alloca(3)`. It may also load libraries dynamically at runtime using `dlopen(3)`.
    All of these mappings are taken care of by the kernel. However, a process can
    also manipulate its memory map in an explicit way using `mmap(2)`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 进程开始时，一定数量的内存映射到程序文件的文本（代码）和数据段，以及它链接的共享库。它可以在运行时使用`malloc(3)`在堆上分配内存，并通过局部作用域变量和通过`alloca(3)`分配的内存在堆栈上分配内存。它还可以在运行时动态加载库使用`dlopen(3)`。所有这些映射都由内核处理。但是，进程还可以使用`mmap(2)`以显式方式操纵其内存映射：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It maps `length` bytes of memory from the file with the descriptor `fd`, starting
    at `offset` in the file, and returns a pointer to the mapping, assuming it is
    successful. Since the underlying hardware works in pages, the `length` is rounded
    up to the nearest whole number of pages. The protection parameter, `prot`, is
    a combination of read, write, and execute permissions and the `flags` parameter
    contains at least `MAP_SHARED` or `MAP_PRIVATE`. There are many other flags, which
    are described in the man page.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 它从具有描述符`fd`的文件中的`offset`开始映射`length`字节的内存，并在成功时返回映射的指针。由于底层硬件以页面为单位工作，`length`被舍入到最接近的整页数。保护参数`prot`是读、写和执行权限的组合，`flags`参数至少包含`MAP_SHARED`或`MAP_PRIVATE`。还有许多其他标志，这些标志在man页面中有描述。
- en: There are many things you can do with mmap. Here are a few of them.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: mmap有许多用途。以下是其中一些。
- en: Using mmap to allocate private memory
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用mmap分配私有内存
- en: You can use mmap to allocate an area of private memory by setting the `MAP_ANONYMOUS`
    flag and the `fd` file descriptor to `-1`. This is similar to allocating memory
    from the heap using `malloc(3)` except that the memory is page-aligned and in
    multiples of pages. The memory is allocated in the same area as that used for
    libraries. In fact, that area is referred to by some as the mmap area for this
    reason.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用mmap通过设置`MAP_ANONYMOUS`标志和`fd`文件描述符为`-1`来分配一个私有内存区域。这类似于使用`malloc(3)`从堆中分配内存，只是内存是按页对齐的，并且是页的倍数。内存分配在与库相同的区域。事实上，出于这个原因，一些人称该区域为mmap区域。
- en: Anonymous mappings are better for large allocations because they do not pin
    down the heap with chunks of memory, which would make fragmentation more likely.
    Interestingly, you will find that `malloc(3)` (in glibc at least) stops allocating
    memory from the heap for requests over 128 KiB and uses mmap in this way, so in
    most cases, just using malloc is the right thing to do. The system will choose
    the best way of satisfying the request.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名映射更适合大型分配，因为它们不会用内存块固定堆，这会增加碎片化的可能性。有趣的是，您会发现`malloc(3)`（至少在glibc中）停止为超过128
    KiB的请求从堆中分配内存，并以这种方式使用mmap，因此在大多数情况下，只使用malloc是正确的做法。系统将选择满足请求的最佳方式。
- en: Using mmap to share memory
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用mmap共享内存
- en: 'As we saw in [Chapter 10](ch10.html "Chapter 10. Learning About Processes and
    Threads"), *Learning About Processes and Threads*, POSIX shared memory requires
    mmap to access the memory segment. In this case, you set the `MAP_SHARED` flag
    and use the file descriptor from `shm_open()`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第10章](ch10.html "第10章。了解进程和线程")中看到的，*了解进程和线程*，POSIX共享内存需要使用mmap来访问内存段。在这种情况下，您设置`MAP_SHARED`标志，并使用`shm_open()`的文件描述符：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using mmap to access device memory
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用mmap访问设备内存
- en: As I mentioned in Chapter 8, *Introducing Device Drivers*, it is possible for
    a driver to allow its device node to be mmaped and so share some of the device
    memory with an application. The exact implementation is dependent on the driver.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在第8章中提到的，*介绍设备驱动程序*，驱动程序可以允许其设备节点被mmap，并与应用程序共享一些设备内存。确切的实现取决于驱动程序。
- en: 'One example is the Linux frame buffer, `/dev/fb0`. The interface is defined
    in `/usr/include/linux/fb.h`, including an `ioctl` function to get the size of
    the display and the bits per pixel. You can then use mmap to ask the video driver
    to share the frame buffer with the application and read and write pixels:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是Linux帧缓冲区，`/dev/fb0`。该接口在`/usr/include/linux/fb.h`中定义，包括一个`ioctl`函数来获取显示的大小和每像素位数。然后，您可以使用mmap来请求视频驱动程序与应用程序共享帧缓冲区并读写像素：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A second example is the streaming video interface, Video 4 Linux, version 2,
    or V4L2, which is defined in `/usr/include/linux/videodev2.h`. Each video device
    has a node named `/dev/videoN`, starting with `/dev/video0`. There is an `ioctl`
    function to ask the driver to allocate a number of video buffers which you can
    mmap into user space. Then, it is just a question of cycling the buffers and filling
    or emptying them with video data, depending on whether you are playing back or
    capturing a video stream.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子是流媒体视频接口，Video 4 Linux，版本2，或者V4L2，它在`/usr/include/linux/videodev2.h`中定义。每个视频设备都有一个名为`/dev/videoN`的节点，从`/dev/video0`开始。有一个`ioctl`函数来请求驱动程序分配一些视频缓冲区，你可以将其映射到用户空间。然后，只需要循环缓冲区并根据播放或捕获视频流的情况填充或清空它们。
- en: How much memory does my application use?
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我的应用程序使用了多少内存？
- en: As with kernel space, the different ways of allocating, mapping and sharing
    user space memory make it quite difficult to answer this seemingly simple question.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与内核空间一样，分配、映射和共享用户空间内存的不同方式使得回答这个看似简单的问题变得相当困难。
- en: 'To begin with, you can ask the kernel how much memory it thinks is available,
    which you can do by using the `free` command. Here is a typical example of the
    output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以询问内核认为有多少可用内存，可以使用`free`命令来执行此操作。以下是输出的典型示例：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'At first sight, this looks like a system that is almost out of memory with
    only 4704 KiB free out of 509,016 KiB: less than 1%. However, note that 26,456
    KiB is in buffers and a whopping 363,860 KiB is in cache. Linux believes that
    free memory is wasted memory and so the kernel uses free memory for buffers and
    caches, in the knowledge that they can be shrunk when the need arises. Removing
    buffers and cache from the measurement gives the true free memory, which is 395,020
    KiB; 77% of the total. When using free, the numbers on the second line marked
    `-/+ buffers/cache` are the important ones.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这看起来像是一个几乎没有内存的系统，只有4704 KiB的空闲内存，占用了509,016 KiB的不到1%。然而，请注意，26,456 KiB在缓冲区中，而363,860
    KiB在缓存中。Linux认为空闲内存是浪费的内存，因此内核使用空闲内存用于缓冲区和缓存，因为它们在需要时可以被收缩。从测量中去除缓冲区和缓存可以得到真正的空闲内存，即395,020
    KiB；占总量的77%。在使用free时，标有“-/+ buffers/cache”的第二行上的数字是重要的。
- en: 'You can force the kernel to free up caches by writing a number between 1 and
    3 to `/proc/sys/vm/drop_caches`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过向`/proc/sys/vm/drop_caches`写入1到3之间的数字来强制内核释放缓存：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The number is actually a bit mask which determines which of the two broad types
    of cache you want to free: 1 for the page cache and 2 for the dentry and inode
    caches combined. The exact roles of those caches is not particularly important
    here, only that there is memory that the kernel is using but which can be reclaimed
    at short notice.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，该数字是一个位掩码，用于确定您要释放的两种广义缓存中的哪一种：1表示页面缓存，2表示dentry和inode缓存的组合。这些缓存的确切作用在这里并不特别重要，只是内核正在使用的内存可以在短时间内被回收。
- en: Per-process memory usage
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个进程的内存使用
- en: 'There are several metrics to measure the amount of memory a process is using.
    I will begin with the two that are easiest to obtain— the **virtual set size**
    (**vss**) and the **resident memory size** (**rss**), both of which are available
    in most implementations of the `ps` and `top` commands:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种度量方法可以衡量进程使用的内存量。我将从最容易获得的两种开始——**虚拟集大小**（**vss**）和**驻留内存大小**（**rss**），这两种在大多数`ps`和`top`命令的实现中都可以获得：
- en: '**Vss**: called VSZ in the `ps` command and VIRT in `top`, is the total amount
    of memory mapped by a process. It is the sum of all the regions shown in `/proc/<PID>/map`.
    This number is of limited interest, since only part of the virtual memory is committed
    to physical memory at any one time.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vss**：在`ps`命令中称为VSZ，在`top`中称为VIRT，是进程映射的内存总量。它是`/proc/<PID>/map`中显示的所有区域的总和。这个数字的兴趣有限，因为只有部分虚拟内存在任何时候都被分配到物理内存。'
- en: '**Rss**: called RSS in `ps` and RES in `top`, is the sum of memory that is
    mapped to physical pages of memory. This gets closer to the actual memory budget
    of the process, but there is a problem, if you add up the Rss of all the processes,
    you will get an overestimate the memory in use because some pages will be shared.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rss**：在`ps`中称为RSS，在`top`中称为RES，是映射到物理内存页面的内存总和。这更接近进程的实际内存预算，但是有一个问题，如果将所有进程的Rss相加，您将高估内存的使用，因为一些页面将是共享的。'
- en: Using top and ps
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用top和ps
- en: The versions of `top` and `ps` from BusyBox give very limited information. The
    examples that follow use the full version from the `procps` pacakge.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox的`top`和`ps`版本提供的信息非常有限。以下示例使用了`procps`包中的完整版本。
- en: 'The `ps` command shows Vss (VSZ) and Rss (RSS) with the options, `-Aly`, and
    a custom format which includes `vsz` and `rss`, as shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps`命令显示了Vss（VSZ）和Rss（RSS）以及包括`vsz`和`rss`的自定义格式，如下所示：'
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Likewise, `top` shows a summary of the free memory and memory usage per process:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`top`显示了每个进程的空闲内存和内存使用的摘要：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These simple commands give you a feel of the memory usage and give the first
    indication that you have a memory leak when you see that the Rss of a process
    keeps on increasing. However, they are not very accurate in the absolute measurements
    of memory usage.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的命令让您感受到内存的使用情况，并在看到进程的Rss不断增加时第一次表明您有内存泄漏的迹象。然而，它们在绝对内存使用的测量上并不是非常准确。
- en: Using smem
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用smem
- en: 'In 2009, Matt Mackall began looking at the problem of accounting for shared
    pages in process memory measurement and added two new metrics called the **unique
    set size** or **Uss**, and the **proportional set size** or **Pss**:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 2009年，Matt Mackall开始研究进程内存测量中共享页面的计算问题，并添加了两个名为**唯一集大小**或**Uss**和**比例集大小**或**Pss**的新指标：
- en: '**Uss**: This is the amount of memory that is committed to physical memory
    and is unique to a process; it is not shared with any other. It is the amount
    of memory that would be freed if the process were to terminate.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Uss**：这是分配给物理内存并且对进程唯一的内存量；它不与任何其他内存共享。这是如果进程终止将被释放的内存量。'
- en: '**Pss**: This splits the accounting of shared pages that are committed to physical
    memory between all the processes that have them mapped. For example, if an area
    of library code is 12 pages long and is shared by six processes, each will accumulate
    two pages in Pss. Thus, if you add the Pss numbers for all processes, you will
    get the actual amount of memory being used by those processes. In other words,
    Pss is the number we have been looking for.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pss**：这将共享页面的计算分配给所有映射了它们的进程。例如，如果一个库代码区域有12页长，并且被六个进程共享，每个进程将累积两页的Pss。因此，如果将所有进程的Pss数字相加，就可以得到这些进程实际使用的内存量。换句话说，Pss就是我们一直在寻找的数字。'
- en: 'The information is available in `/proc/<PID>/smaps`, which contains additional
    information for each of the mappings shown in `/proc/<PID>/maps`. Here is one
    section from such a file which provides information about the mapping for the
    `libc` code segment:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息可以在`/proc/<PID>/smaps`中找到，其中包含了`/proc/<PID>/maps`中显示的每个映射的附加信息。以下是这样一个文件中的一个部分，它提供了有关`libc`代码段的映射的信息：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the Rss is 264 KiB but because it is shared between many other processes,
    the Pss is only 6 KiB.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Rss为264 KiB，但由于它在许多其他进程之间共享，因此Pss只有6 KiB。
- en: There is a tool named smem that collates the information from the `smaps` files
    and presents it in various ways, including as pie or bar charts. The project page
    for smem is [https://www.selenic.com/smem](https://www.selenic.com/smem). It is
    available as a package in most desktop distributions. However, since it is written
    in Python, installing it on an embedded target requires a Python environment,
    which may be too much trouble for just one tool. To help with this, there is a
    small program named `smemcap` that captures the state from `/proc` on the target
    and saves it to a TAR file which can be analyzed later on the host computer. It
    is part of BusyBox, but it can also be compiled from the `smem` source.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为smem的工具，它汇总了`smaps`文件中的信息，并以各种方式呈现，包括饼图或条形图。smem的项目页面是[https://www.selenic.com/smem](https://www.selenic.com/smem)。它在大多数桌面发行版中都作为一个软件包提供。但是，由于它是用Python编写的，在嵌入式目标上安装它需要一个Python环境，这可能会给一个工具带来太多麻烦。为了解决这个问题，有一个名为`smemcap`的小程序，它可以在目标上捕获`/proc`的状态，并将其保存到一个TAR文件中，以便稍后在主机计算机上进行分析。它是BusyBox的一部分，但也可以从`smem`源代码编译而成。
- en: 'Running `smem` natively, as `root`, you will see these results:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以`root`身份本地运行`smem`，你会看到这些结果：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can see from the last line of the output that, in this case, the total Pss
    is about a half of the Rss.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出的最后一行可以看出，在这种情况下，总的Pss大约是Rss的一半。
- en: 'If you don''t have or don''t want to install Python on your target, you can
    capture the state using `smemcap`, again as `root`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有或不想在目标上安装Python，你可以再次以`root`身份使用`smemcap`来捕获状态：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, copy the TAR file to the host and read it using `smem -S`, though this
    time there is no need to run as `root`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将TAR文件复制到主机并使用`smem -S`读取，尽管这次不需要以`root`身份运行：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output is identical to that when running it natively.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与本地运行时的输出相同。
- en: Other tools to consider
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他需要考虑的工具
- en: Another way to display Pss is via `ps_mem` ([https://github.com/pixelb/ps_mem](https://github.com/pixelb/ps_mem)),
    which prints much the same information but in a simpler format. It is also written
    in Python.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种显示Pss的方法是通过`ps_mem`([https://github.com/pixelb/ps_mem](https://github.com/pixelb/ps_mem))，它以更简单的格式打印几乎相同的信息。它也是用Python编写的。
- en: Android also has a tool named `procrank`, which can be cross compiled for embedded
    Linux with a few small changes. You can get the code from [https://github.com/csimmonds/procrank_linux](https://github.com/csimmonds/procrank_linux).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Android也有一个名为`procrank`的工具，可以通过少量更改在嵌入式Linux上进行交叉编译。你可以从[https://github.com/csimmonds/procrank_linux](https://github.com/csimmonds/procrank_linux)获取代码。
- en: Identifying memory leaks
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别内存泄漏
- en: A memory leak occurs when memory is allocated but not freed when it is no longer
    needed. Memory leakage is by no means unique to embedded systems, but it becomes
    an issue partly because targets don't have much memory in the first place, and
    partly because they often run for long periods of time without rebooting, allowing
    the leaks to become a large puddle.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏发生在分配内存后不释放它，当它不再需要时。内存泄漏并不是嵌入式系统特有的问题，但它成为一个问题的部分原因是目标本来就没有太多内存，另一部分原因是它们经常长时间运行而不重启，导致泄漏变成了一个大问题。
- en: You will realize that there is a leak when you run `free` or `top` and see that
    free memory is continually going down, even if you drop caches, as shown in the
    preceding section. You will be able to identify the culprit (or culprits) by looking
    at the Uss and Rss per process.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`free`或`top`并看到可用内存不断减少时，即使你清除缓存，你会意识到有一个泄漏，如前面的部分所示。你可以通过查看每个进程的Uss和Rss来确定罪魁祸首（或罪魁祸首）。
- en: 'There are several tools for identifying memory leaks in a program. I will look
    at two: `mtrace` and `Valgrind`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种工具可以识别程序中的内存泄漏。我将看两种：`mtrace`和`Valgrind`。
- en: mtrace
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: mtrace
- en: '`mtrace` is a component of glibc that traces calls to `malloc(3)`, `free(3)`,
    and related functions, and identifies areas of memory not freed when the program
    exits. You need to call the `mtrace()` function from within the program to begin
    tracing and then at runtime, write a path name to the `MALLOC_TRACE` environment
    variable in which the trace information is written. If `MALLOC_TRACE` does not
    exist or of the file cannot be opened, `mtrace` hooks are not not installed. While
    the trace information is written in ASCII, it is usual to use the `mtrace` command
    to view it.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`mtrace`是glibc的一个组件，它跟踪对`malloc(3)`、`free(3)`和相关函数的调用，并在程序退出时识别未释放的内存区域。你需要在程序内部调用`mtrace()`函数开始跟踪，然后在运行时，将路径名写入`MALLOC_TRACE`环境变量，以便写入跟踪信息的文件。如果`MALLOC_TRACE`不存在或文件无法打开，`mtrace`钩子将不会安装。虽然跟踪信息是以ASCII形式写入的，但通常使用`mtrace`命令来查看它。'
- en: 'Here is an example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here is what you might see when running the program and looking at the trace:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行程序并查看跟踪时，你可能会看到以下内容：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Unfortunately, `mtrace` does not tell you about leaked memory while the program
    runs. It has to terminate first.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`mtrace`在程序运行时不能告诉你有关泄漏内存的信息。它必须先终止。
- en: Valgrind
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Valgrind
- en: Valgrind is a very powerful tool for discovering memory problems including leaks,
    and other things besides. One advantage is that you don't have to recompile the
    programs and libraries that you want to check, although it does work better if
    they have been compiled with the `-g` option so that they include debug symbol
    tables. It works by running the program in an emulated environment and trapping
    execution at various points. This leads to the big downside of Valgrind, which
    is that the program runs at a fraction of normal speed which makes it less useful
    for testing anything with real-time constraints.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind是一个非常强大的工具，可以发现内存问题，包括泄漏和其他问题。一个优点是你不必重新编译要检查的程序和库，尽管如果它们已经使用`-g`选项编译，以便包含调试符号表，它的工作效果会更好。它通过在模拟环境中运行程序并在各个点捕获执行来工作。这导致Valgrind的一个很大的缺点，即程序以正常速度的一小部分运行，这使得它对测试任何具有实时约束的东西不太有用。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Incidentally, the name is often mispronounced: it says in the Valgrind FAQ
    that the *grind* is pronounced with a short *i* -- as in *grinned* (rhymes with
    *tinned*) rather than *grined* (rhymes with *find*). The FAQ, documentation and
    downloads are available at [http://valgrind.org](http://valgrind.org).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，这个名字经常被错误发音：Valgrind的FAQ中说*grind*的发音是短的*i*--就像*grinned*（押韵*tinned*）而不是*grined*（押韵*find*）。FAQ、文档和下载都可以在[http://valgrind.org](http://valgrind.org)找到。
- en: 'Valgrind contains several diagnostic tools:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind包含几个诊断工具：
- en: '**memcheck**: This is the default tool, and detects memory leaks and general
    misuse of memory'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**memcheck**：这是默认工具，用于检测内存泄漏和内存的一般误用'
- en: '**cachegrind**: This calculates the processor cache hit rate'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cachegrind**：这个工具计算处理器缓存命中率'
- en: '**callgrind**: This calculates the cost of each function call'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**callgrind**：这个工具计算每个函数调用的成本'
- en: '**helgrind**: This highlights misuse of the Pthread API, potential deadlocks,
    and race conditions'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**helgrind**：这个工具用于突出显示Pthread API的误用、潜在死锁和竞争条件'
- en: '**DRD**: This is another Pthread analysis tool'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DRD**：这是另一个Pthread分析工具'
- en: '**massif**: This profiles usage of the heap and stack'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**massif**：这个工具用于分析堆和栈的使用情况'
- en: 'You can select the tool you want with the `-tool` option. Valgrind runs on
    the major embedded platforms: ARM (Cortex A), PPC, MIPS, and x86 in 32- and 64-bit
    variants. It is available as a package in both the Yocto Project and Buildroot.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`-tool`选项选择您想要的工具。Valgrind可以在主要的嵌入式平台上运行：ARM（Cortex A）、PPC、MIPS和32位和64位的x86。它在Yocto
    Project和Buildroot中都作为一个软件包提供。
- en: 'To find our memory leak, we need to use the default `memcheck` tool, with the
    option `--leakcheck=full` to print out the lines where the leak was found:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到我们的内存泄漏，我们需要使用默认的`memcheck`工具，并使用选项`--leakcheck=full`来打印出发现泄漏的行：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Running out of memory
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存不足
- en: 'The standard memory allocation policy is to **over-commit**, meaning that the
    kernel will allow more memory to be allocated by applications than there is physical
    memory. Most of the time, this works fine because it is common for applications
    to request more memory than they really need. It also helps in the implementation
    of `fork(2)`: it is safe to make a copy of a large program because the pages of
    memory are shared with the `copy-on-write` flag set. In the majority of cases,
    `fork` is followed by an `exec` function call, which unshares the memory and then
    loads a new program.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的内存分配策略是**过度承诺**，这意味着内核将允许应用程序分配比物理内存更多的内存。大多数情况下，这很好用，因为应用程序通常会请求比实际需要的更多的内存。它还有助于`fork(2)`的实现：可以安全地复制一个大型程序，因为内存页面是带有`copy-on-write`标志的共享的。在大多数情况下，`fork`后会调用`exec`函数，这样就会取消内存共享，然后加载一个新程序。
- en: However, there is always the possibility that a particular workload will cause
    a group of processes to try to cash in on the allocations they have been promised
    simultaneously and so demand more than there really is. This is an **out of memory**
    situation, or **OOM**. At this point, there is no other alternative but to kill
    off processes until the problem goes away. This is the job of the out of memory
    killer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，总有可能某个特定的工作负载会导致一组进程同时尝试兑现它们被承诺的分配，因此需求超过了实际存在的内存。这是一种**内存不足**的情况，或者**OOM**。在这一点上，除了杀死进程直到问题消失之外别无选择。这是内存不足杀手的工作。
- en: 'Before we get to that, there is a tuning parameter for kernel allocations in
    `/proc/sys/vm/overcommit_memory`, which you can set to:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论这些之前，有一个内核分配的调整参数在`/proc/sys/vm/overcommit_memory`中，你可以将其设置为：
- en: '`0`: heuristic over-commit (this is the default)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：启发式过度承诺（这是默认设置）'
- en: '`1`: always over-commit, never check'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：始终过度承诺，永不检查'
- en: '`2`: always check, never over-commit'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：始终检查，永不过度承诺'
- en: Option 1 is only really useful if you run programs that work with large sparse
    arrays and so allocate large areas of memory but write to a small proportion of
    them. Such programs are rare in the context of embedded systems.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 选项1只有在运行与大型稀疏数组一起工作并分配大量内存但只写入其中一小部分的程序时才真正有用。在嵌入式系统的环境中，这样的程序很少见。
- en: Option 2, never over-commit, seems to be a good choice if you are worried about
    running out of memory, perhaps in a mission or safety-critical application. It
    will fail allocations that are greater than the commit limit, which is the size
    of swap space plus total memory multiplied by the over-commit ratio. The over-commit
    ratio is controlled by `/proc/sys/vm/overcommit_ratio` and has a default value
    of 50%.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 选项2，永不过度承诺，似乎是一个不错的选择，如果您担心内存不足，也许是在任务或安全关键的应用中。它将失败于大于承诺限制的分配，这个限制是交换空间的大小加上总内存乘以过度承诺比率。过度承诺比率由`/proc/sys/vm/overcommit_ratio`控制，默认值为50%。
- en: 'As an example, suppose you have a device with 512 MB of system RAM and you
    set a really conservative ratio of 25%:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您有一台设备，配备了512MB的系统RAM，并设置了一个非常保守的比率为25%：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There is no swap so the commit limit is 25% of `MemTotal`, as expected.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 没有交换空间，因此承诺限制是`MemTotal`的25%，这是预期的。
- en: 'There is another important variable in `/proc/meminfo: Committed_AS`. This
    is the total amount of memory that is needed to fulfill all the allocations made
    so far. I found the following on one system:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc/meminfo`中还有另一个重要的变量：`Committed_AS`。这是迄今为止需要满足所有分配的总内存量。我在一个系统上找到了以下内容：'
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In other words, the kernel has already promised more memory than the available
    memory. Consequently, setting `overcommit_memory` to `2` means that all allocations
    fail, regardless of `overcommit_ratio`. To get to a working system, I would have
    to either install double the amount of RAM or severely reduce the number of running
    processes, of which there are about 40.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，内核已经承诺了比可用内存更多的内存。因此，将`overcommit_memory`设置为`2`意味着所有分配都会失败，而不管`overcommit_ratio`如何。要使系统正常工作，我要么必须安装双倍的RAM，要么严重减少正在运行的进程数量，大约有40个。
- en: 'In all cases, the final defense is the OOM killer. It uses a heuristic method
    to calculate a badness score between 0 and 1,000 for each process and then terminates
    those with the highest score until there is enough free memory. You should see
    something like this in the kernel log:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，最终的防御是OOM killer。它使用一种启发式方法为每个进程计算0到1000之间的糟糕分数，然后终止具有最高分数的进程，直到有足够的空闲内存。您应该在内核日志中看到类似于这样的内容：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can force an OOM event using `echo f > /proc/sysrq-trigger`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`echo f > /proc/sysrq-trigger`来强制发生OOM事件。
- en: You can influence the badness score for a process by writing an adjustment value
    to `/proc/<PID>/oom_score_adj`. A value of `-1000` means that the badness score
    can never be greater than zero and so it will never be killed; a value of `+1000`
    means that it will always be greater than 1000 and so will always be killed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将调整值写入`/proc/<PID>/oom_score_adj`来影响进程的糟糕分数。值为`-1000`意味着糟糕分数永远不会大于零，因此永远不会被杀死；值为`+1000`意味着它将始终大于1000，因此将始终被杀死。
- en: Further reading
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following resources have further information about the topics introduced
    in this chapter:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源提供了有关本章介绍的主题的进一步信息：
- en: '*Linux Kernel Development, 3rd Edition*, by *Robert Love*, *Addison Wesley*,
    *O''Reilly Media*; (Jun. 2010) ISBN-10: 0672329468'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux内核开发，第3版*，作者*Robert Love*，*Addison Wesley*，*O''Reilly Media*; (2010年6月)
    ISBN-10: 0672329468'
- en: '*Linux System Programming, 2nd Edition*, by *Robert Love*, *O''Reilly Media*;
    (8 Jun. 2013) ISBN-10: 1449339530'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Linux系统编程，第2版*，作者*Robert Love*，*O''Reilly Media*; (2013年6月8日) ISBN-10: 1449339530'
- en: '*Understanding the Linux VM Manager* by *Mel Gorman*: [https://www.kernel.org/doc/gorman/pdf/understand.pdf](https://www.kernel.org/doc/gorman/pdf/understand.pdf)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*了解Linux VM管理器*，作者*Mel Gorman*：[https://www.kernel.org/doc/gorman/pdf/understand.pdf](https://www.kernel.org/doc/gorman/pdf/understand.pdf)'
- en: '*Valgrind 3.3 - Advanced Debugging and Profiling for Gnu/Linux Applications*
    by *J Seward*, *N. Nethercote*, and *J. Weidendorfer*, *Network Theory Ltd*; (1
    Mar. 2008) ISBN 978-0954612054'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Valgrind 3.3 - Gnu/Linux应用程序的高级调试和性能分析*，作者*J Seward*，*N. Nethercote*和*J. Weidendorfer*，*Network
    Theory Ltd*; (2008年3月1日) ISBN 978-0954612054'
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Accounting for every byte of memory used in a virtual memory system is just
    not possible. However, you can find a fairly accurate figure for the total amount
    of free memory, excluding that taken by buffers and cache, by using the `free`
    command. By monitoring it over a period of time and with different workloads,
    you should become confident that it will remain within a given limit.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟内存系统中考虑每个内存使用的字节是不可能的。但是，您可以使用`free`命令找到一个相当准确的总空闲内存量，不包括缓冲区和缓存所占用的内存。通过在一段时间内监视它，并使用不同的工作负载，您应该对它将保持在给定限制内感到自信。
- en: 'When you want to tune memory usage or identify sources of unexpected allocations,
    there are resources that give more detailed information. For kernel space, the
    most useful information is in `/proc: meminfo`, `slabinfo`, and `vmallocinfo`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '当您想要调整内存使用情况或识别意外分配的来源时，有一些资源可以提供更详细的信息。对于内核空间，最有用的信息在于`/proc: meminfo`，`slabinfo`和`vmallocinfo`。'
- en: When it comes to getting accurate measurements for user space, the best metric
    is Pss, as shown by `smem` and other tools. For memory debugging, you can get
    help from simple tracers such as `mtrace`, or you have the heavyweight option
    of the Valgrind memcheck tool.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取用户空间的准确测量方面，最佳指标是Pss，如`smem`和其他工具所示。对于内存调试，您可以从诸如`mtrace`之类的简单跟踪器获得帮助，或者您可以选择使用Valgrind
    memcheck工具这样的重量级选项。
- en: If you have concerns about the consequence of an out of memory situation, you
    can fine-tune the allocation mechanism via `/proc/sys/vm/overcommit_memory` and
    you can control the likelihood of particular processes being killed though the
    `oom_score_adj` parameter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您担心内存不足的后果，您可以通过`/proc/sys/vm/overcommit_memory`微调分配机制，并且可以通过`oom_score_adj`参数控制特定进程被杀死的可能性。
- en: The next chapter is all about debugging user space and kernel code using the
    GNU debugger, and the insights you can gain from watching code as it runs, including
    the memory management functions I have described here.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将全面介绍如何使用GNU调试器调试用户空间和内核代码，以及您可以从观察代码运行中获得的见解，包括我在这里描述的内存管理函数。
