- en: Chapter 1. Shell Something Out
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。外壳某事
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Printing in the terminal
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在终端中打印
- en: Playing with variables and environment variables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩转变量和环境变量
- en: Doing Math calculations with the shell
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用shell进行数学计算
- en: Playing with file descriptors and redirection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩转文件描述符和重定向
- en: Arrays and associative arrays
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和关联数组
- en: Visiting aliases
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问别名
- en: Grabbing information about the terminal
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取有关终端的信息
- en: Getting, setting dates, and delays
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取、设置日期和延迟
- en: Debugging the script
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试脚本
- en: Functions and arguments
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和参数
- en: Reading output of a sequence of commands in a variable
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在变量中读取一系列命令的输出
- en: Reading "n" characters without pressing Return
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不按回车键的情况下读取“n”个字符
- en: Field separators and iterators
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段分隔符和迭代器
- en: Comparisons and tests
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较和测试
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: UNIX-like systems are amazing operating system designs. Even after many decades,
    the UNIX-style architecture for operating systems serves as one of the best designs.
    One of the most important features of this architecture is the command-line interface
    or the shell. The shell environment helps users to interact with and access core
    functions of the operating system. The term scripting is more relevant in this
    context. Scripting is usually supported by interpreter-based programming languages.
    Shell scripts are files in which we write a sequence of commands that we need
    to perform. And the script file is executed using the shell utility.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 类UNIX系统是令人惊叹的操作系统设计。即使经过了许多年，类UNIX架构的操作系统仍然是最佳设计之一。这种架构的最重要特性之一是命令行界面或shell。shell环境帮助用户与操作系统的核心功能进行交互和访问。在这种情况下，术语脚本更相关。脚本通常由解释器支持的编程语言支持。Shell脚本是我们编写需要执行的一系列命令的文件。脚本文件是使用shell实用程序执行的。
- en: In this book we are dealing with **Bash** (**Bourne Again Shell**), which is
    the default shell environment for most GNU/Linux systems. Since GNU/Linux is the
    most prominent operating system based on a UNIX-style architecture, most of the
    examples and discussions are written by keeping Linux systems in mind.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们处理的是Bash（Bourne Again Shell），这是大多数GNU/Linux系统的默认shell环境。由于GNU/Linux是基于类UNIX架构的最突出的操作系统，大多数示例和讨论都是以Linux系统为基础编写的。
- en: 'The primary purpose of this chapter is to give readers an insight about the
    shell environment and become familiar with the basic features that come around
    the shell. Commands are typed and executed in a shell terminal. When opened, in
    a terminal, a prompt is available. It is usually in the following format:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目的是让读者了解shell环境，并熟悉围绕shell的基本功能。命令是在shell终端中输入和执行的。在打开终端时，会出现提示符。它通常是以下格式：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Or simply as **$** or **#.**
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 或者简单地为**$**或**#**。
- en: '`$` represents regular users and `#` represents the administrative user root.
    Root is the most privileged user in a Linux system.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`表示普通用户，`#`表示管理员用户root。Root是Linux系统中权限最高的用户。'
- en: 'A shell script is a text file that typically begins with a shebang, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Shell脚本是一个文本文件，通常以shebang开头，如下所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: For any scripting language in a Linux environment, a script starts with a special
    line called shebang. Shebang is a line for which `#!` is prefixed to the interpreter
    path. `/bin/bash` is the interpreter command path for Bash.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux环境中的任何脚本语言，脚本都以特殊行shebang开头。shebang是一个前缀为`#!`的解释器路径的行。`/bin/bash`是Bash的解释器命令路径。
- en: Execution of a script can be done in two ways. Either we can run the script
    as a command-line argument for `sh` or run a self executable with execution permission.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的执行可以通过两种方式进行。我们可以将脚本作为`sh`的命令行参数运行，或者以执行权限运行自行可执行文件。
- en: 'The script can be run with the filename as a command-line argument as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将脚本作为文件名的命令行参数运行，如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If a script is run as a command-line argument for `sh`, the shebang in the script
    is of no use.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本作为`sh`的命令行参数运行，则脚本中的shebang无效。
- en: 'In order to self execute a shell script, it requires executable permission.
    While running as a self executable, it makes use of the shebang. It runs the script
    using the interpreter path that is appended to `#!` in shebang. The execution
    permission for the script can be set as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自行执行shell脚本，需要可执行权限。在作为自行可执行文件运行时，它使用shebang。它使用shebang中附加到`#!`的解释器路径运行脚本。可以设置脚本的执行权限如下：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This command gives the `script.sh` file the executable permission for all users.
    The script can be executed as:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令为`script.sh`文件赋予所有用户的可执行权限。脚本可以执行如下：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Or:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The shell program will read the first line and see that the shebang is `#!/bin/bash`.
    It will identify the `/bin/bash` and execute the script internally as:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: shell程序将读取第一行，并查看shebang是`#!/bin/bash`。它将识别`/bin/bash`并在内部执行脚本：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When a terminal is opened it initially executes a set of commands to define
    various settings like prompt text, colors, and many more. This set of commands
    (run commands) are read from a shell script called `.bashrc`, which is located
    in the home directory of the user (`~/.bashrc`). The bash shell also maintains
    a history of commands run by the user. It is available in the file `~/.bash_history`.
    `~` is the shorthand for the user home directory path.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当打开终端时，它最初会执行一组命令来定义各种设置，如提示文本、颜色等。这组命令（运行命令）是从一个名为`.bashrc`的shell脚本中读取的，该脚本位于用户的主目录（`~/.bashrc`）中。bash
    shell还会维护用户运行的命令历史记录。它位于文件`~/.bash_history`中。`~`是用户主目录路径的缩写。
- en: 'In Bash, each command or command sequence is delimited by using a semicolon
    or a new line. For example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bash中，每个命令或命令序列都是使用分号或换行符分隔的。例如：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is equivalent to:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '这相当于： '
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, the `#` character is used to denote the beginning of unprocessed comments.
    A comment section starts with `#` and proceeds up to the end of that line. The
    comment lines are most often used to provide comments about the code in the file
    or to stop a line of code from being executed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`#`字符用于表示未处理注释的开始。注释部分以`#`开头，并一直延续到该行的末尾。注释行通常用于提供有关文件中代码的注释，或者阻止执行代码行。
- en: Now let's move on to the basic recipes in this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续学习本章的基本配方。
- en: Printing in the terminal
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在终端中打印
- en: The terminal is an interactive utility by which a user interacts with the shell
    environment. Printing text in the terminal is a basic task that most shell scripts
    and utilities need to perform regularly. Printing can be performed via various
    methods and in different formats.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 终端是用户与shell环境交互的交互式实用程序。在终端中打印文本是大多数shell脚本和实用程序需要定期执行的基本任务。可以通过各种方法和不同格式进行打印。
- en: How to do it...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: '`echo` is the basic command for printing in the terminal.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo`是在终端中打印的基本命令。'
- en: '`echo` puts a newline at the end of every invocation by default:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo`默认情况下在每次调用结束时都会换行：'
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Simply using double-quoted text with the `echo` command prints the text in
    the terminal. Similarly, text without double-quotes also gives the same output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 只需使用带有`echo`命令的双引号文本即可在终端中打印文本。同样，没有双引号的文本也会产生相同的输出：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Another way to do the same task is by using single quotes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种执行相同任务的方法是使用单引号：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These methods may look similar, but some of them have got a specific purpose
    and side effects too. Consider the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法可能看起来相似，但其中一些具有特定目的和副作用。考虑以下命令：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will return the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下内容：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Hence, if you want to print `!`, do not use within double-quotes or you may
    escape the `!` with a special escape character (`\`) prefixed with it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果要打印`!`，不要在双引号内使用，或者可以使用特殊的转义字符（`\`）对`!`进行转义。
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Or:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Or:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When using `echo` with double-quotes, you should add `set +H` before issuing
    `echo` so that you can use `!`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用双引号与`echo`一起使用时，你应该在发出`echo`之前添加`set +H`，这样你就可以使用`!`。
- en: 'The side effects of each of the methods are as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法的副作用如下：
- en: When using `echo` without quotes, we cannot use a semicolon as it acts as a
    delimiter between commands in the bash shell.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不使用引号与`echo`一起使用时，我们不能使用分号，因为它在bash shell中充当命令之间的分隔符。
- en: '`echo hello;hello` takes `echo hello` as one command and the second `hello`
    as the second command.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`echo hello;hello`将`echo hello`作为一个命令，第二个`hello`作为第二个命令。'
- en: When using `echo` with single quotes, the variables (for example, `$var` will
    not be expanded) inside the quotes will not be interpreted by Bash, but will be
    displayed as is.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用单引号与`echo`一起使用时，引号内的变量（例如，`$var`）不会被Bash展开，而是会按原样显示。
- en: 'This means:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着：
- en: '`$ echo ''$var''` will return `$var`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ echo ''$var''`将返回`$var`'
- en: whereas
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而
- en: '`$ echo $var` will return the value of the variable `$var` if defined or nothing
    at all if it is not defined.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了`$var`，`$ echo $var`将返回变量`$var`的值，如果未定义，则返回空。
- en: 'Another command for printing in the terminal is the `printf` command. `printf`
    uses the same arguments as the `printf` command in the C programming language.
    For example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中打印的另一个命令是`printf`命令。`printf`使用与C编程语言中的`printf`命令相同的参数。例如：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`printf` takes quoted text or arguments delimited by spaces. We can use formatted
    strings with `printf`. We can specify string width, left or right alignment, and
    so on. By default, `printf` does not have newline as in the `echo` command. We
    have to specify a newline when required, as shown in the following script:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf`接受带引号的文本或由空格分隔的参数。我们可以使用带有`printf`的格式化字符串。我们可以指定字符串宽度，左对齐或右对齐等。默认情况下，`printf`不像`echo`命令那样具有换行符。我们必须在需要时指定换行符，如下面的脚本所示：'
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will receive the formatted output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将收到格式化的输出：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`%s`, `%c`, `%d`, and `%f` are format substitution characters for which an
    argument can be placed after the quoted format string.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`%s`、`%c`、`%d`和`%f`是格式替换字符，可以在引号格式字符串之后放置参数。'
- en: '`%-5s` can be described as a string substitution with left alignment (`-` represents
    left alignment) with width equal to `5`. If `-` was not specified, the string
    would have been aligned to the right. The width specifies the number of characters
    reserved for that variable. For `Name`, the width reserved is `10`. Hence, any
    name will reside within the 10-character width reserved for it and the rest of
    the characters will be filled with space up to 10 characters in total.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`%-5s`可以描述为具有左对齐的字符串替换（`-`表示左对齐），宽度等于`5`。如果未指定`-`，则字符串将对齐到右侧。宽度指定了为该变量保留的字符数。对于`Name`，保留的宽度为`10`。因此，任何名称都将位于为其保留的10个字符宽度内，其余字符将填充到总共10个字符。'
- en: For floating point numbers, we can pass additional parameters to round off the
    decimal places.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于浮点数，我们可以传递额外的参数来四舍五入小数位。
- en: For marks, we have formatted the string as `%-4.2f`, where `.2` specifies rounding
    off to two decimal places. Note that for every line of the format string a `\n`
    newline is issued.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标记，我们已将字符串格式化为`%-4.2f`，其中`.2`指定四舍五入到小数点后两位。请注意，对于格式字符串的每一行，都会发出一个`\n`换行符。
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It should be always noted that flags (such as -e, -n, and so on) for `echo`
    and `printf` should appear before any strings in the command, else Bash will consider
    the flags as another string.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 应始终注意，`echo`和`printf`的标志（例如-e、-n等）应出现在命令中的任何字符串之前，否则Bash将把标志视为另一个字符串。
- en: Escaping newline in echo
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`echo`中转义换行符
- en: 'By default, `echo` has a newline appended at the end of its output text. This
    can be avoided by using the `-n` flag. `echo` can also accept escape sequences
    in double-quoted strings as argument. For using escape sequences, use `echo` as
    `echo -e "string containing escape sequences"`. For example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`echo`在其输出文本的末尾附加换行符。可以通过使用`-n`标志来避免这种情况。`echo`也可以接受双引号字符串中的转义序列作为参数。要使用转义序列，请使用`echo`作为`echo
    -e "包含转义序列的字符串"`。例如：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Printing colored output
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打印彩色输出
- en: Producing colored output on the terminal is very interesting stuff. We produce
    colored output using escape sequences.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端上生成彩色输出非常有趣。我们使用转义序列生成彩色输出。
- en: Color codes are used to represent each color. For example, reset=0, black=30,
    red=31, green=32, yellow=33, blue=34, magenta=35, cyan=36, and white=37.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色代码用于表示每种颜色。例如，reset=0，black=30，red=31，green=32，yellow=33，blue=34，magenta=35，cyan=36，white=37。
- en: 'In order to print colored text, enter the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印彩色文本，输入以下内容：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here `\e[1;31` is the escape string that sets the color to red and `\e[0m` resets
    the color back. Replace `31` with the required color code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`\e[1;31`是将颜色设置为红色的转义字符串，`\e[0m`将颜色重置。将`31`替换为所需的颜色代码。
- en: For a colored background, reset = 0, black = 40, red = 41, green = 42, yellow
    = 43, blue = 44, magenta = 45, cyan = 46, and white=47, are the color code that
    are commonly used.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于彩色背景，reset = 0，black = 40，red = 41，green = 42，yellow = 43，blue = 44，magenta
    = 45，cyan = 46，white=47，是常用的颜色代码。
- en: 'In order to print a colored background, enter the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印彩色背景，输入以下内容：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Playing with variables and environment variables
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩弄变量和环境变量
- en: Variables are essential components of every programming language and are used
    to hold varying data. Scripting languages usually do not require variable type
    declaration before its use. It can be assigned directly. In Bash, the value for
    every variable is string. If we assign variables with quotes or without quotes,
    they are stored as string. There are special variables used by the shell environment
    and the operating system environment to store special values, which are called
    environment variables.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是每种编程语言的基本组成部分，用于保存不同的数据。脚本语言通常不需要在使用之前声明变量类型。它可以直接分配。在Bash中，每个变量的值都是字符串。如果我们使用引号或不使用引号分配变量，它们将被存储为字符串。Shell环境和操作系统环境使用特殊变量存储特殊值，这些变量称为环境变量。
- en: Let's look at the recipes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看配方。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'Variables are named with usual naming constructs. When an application is executing,
    it will be passed with a set of variables called environment variables. From the
    terminal, to view all the environment variables related to that terminal process,
    issue the `env` command. For every process, environment variables in its runtime
    can be viewed by:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 变量使用通常的命名构造命名。当应用程序执行时，它将被传递一组称为环境变量的变量。从终端，要查看与该终端进程相关的所有环境变量，发出`env`命令。对于每个进程，可以通过其运行时查看环境变量：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Set the `PID` with the process ID of the relevant process (PID is always an
    integer).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将`PID`设置为相关进程的进程ID（PID始终是整数）。
- en: 'For example, assume that an application called gedit is running. We can obtain
    the process ID of gedit with the `pgrep` command as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设正在运行一个名为gedit的应用程序。我们可以使用`pgrep`命令获取gedit的进程ID，如下所示：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can obtain the environment variables associated with the process by executing
    the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过执行以下命令获取与进程关联的环境变量：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that many environment variables are stripped off for convenience. The actual
    output may contain numerous variables.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了方便起见，许多环境变量被剥离。实际输出可能包含大量变量。
- en: 'The above mentioned command returns a list of environment variables and their
    values. Each variable is represented as a `name=value` pair and are separated
    by a null character (`\0`). If you can substitute the `\0` character with `\n`,
    you can reformat the output to show each `variable=value` pair in each line. Substitution
    can be made using the `tr` command as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令返回环境变量及其值的列表。每个变量表示为`name=value`对，并用空字符(`\0`)分隔。如果可以用`\n`替换`\0`字符，可以重新格式化输出，以在每行显示每个`variable=value`对。可以使用`tr`命令进行替换，如下所示：
- en: '[PRE28]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, let's see how to assign and manipulate variables and environment variables.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何分配和操作变量和环境变量。
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'A variable can be assigned as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以按以下方式分配：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`var` is the name of a variable and value is the value to be assigned. If `value`
    does not contain any white space characters (like a space), it need not be enclosed
    in quotes, else it must be enclosed in single or double quotes.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`是变量的名称，value是要分配的值。如果`value`不包含任何空格字符（如空格），则无需用引号括起来，否则必须用单引号或双引号括起来。'
- en: Note that `var = value` and `var=value` are different. It is a common mistake
    to write `var =value` instead of `var=value`. The later is the assignment operation,
    whereas the former is an equality operation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`var = value`和`var=value`是不同的。常见错误是写`var =value`而不是`var=value`。后者是赋值操作，而前者是相等操作。
- en: 'Printing the contents of a variable is done using by prefixing `$` with the
    variable name as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方式通过在变量名称前加上`$`来打印变量的内容：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Or:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can use variable values inside `printf` or `echo` in double quotes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在双引号中使用`printf`或`echo`中的变量值。
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Environment variables are variables that are not defined in the current process,
    but are received from the parent processes. For example, `HTTP_PROXY` is an environment
    variable. This variable defines which proxy server should be used for an Internet
    connection.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量是未在当前进程中定义的变量，而是从父进程接收的变量。例如，`HTTP_PROXY`是一个环境变量。此变量定义了应该为Internet连接使用哪个代理服务器。
- en: 'Usually, it is set as:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，它被设置为：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The export command is used to set the `env` variable. Now any application, executed
    from the current shell script will receive this variable. We can export custom
    variables for our own purposes in an application or shell script that is executed.
    There are many standard environment variables that are available for the shell
    by default.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用export命令设置`env`变量。现在，从当前shell脚本执行的任何应用程序都将接收到这个变量。我们可以为我们自己的目的在执行的应用程序或shell脚本中导出自定义变量。默认情况下，shell提供了许多标准环境变量。
- en: 'For example, `PATH`. A typical `PATH` variable will contain:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`PATH`。典型的`PATH`变量将包含：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When given a command for execution, shell automatically searches for the executable
    in the list of directories in the `PATH` environment variable (directory paths
    are delimited by the ":" character). Usually, `$PATH` is defined in `/etc/environment`
    or `/etc/profile` or `~/.bashrc`. When we need to add a new path to the `PATH`
    environment, we use:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当给出一个执行命令时，shell会自动在`PATH`环境变量的目录列表中搜索可执行文件（目录路径由“:”字符分隔）。通常，`$PATH`在`/etc/environment`或`/etc/profile`或`~/.bashrc`中定义。当我们需要向`PATH`环境添加新路径时，我们使用：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Or, alternately, we can use:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here we have added `/home/user/bin` to `PATH`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经将`/home/user/bin`添加到`PATH`。
- en: 'Some of the well-known environment variables are: `HOME`, `PWD`, `USER`, `UID`,
    `SHELL`, and so on.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一些知名的环境变量是：`HOME`、`PWD`、`USER`、`UID`、`SHELL`等。
- en: There's more...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's see some more tips associated with regular and environment variables.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看与常规和环境变量相关的一些其他提示。
- en: Finding length of string
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找字符串的长度
- en: 'Get the length of a variable value as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 获取变量值的长度如下：
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`length` is the number of characters in the string.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`length`是字符串中的字符数。'
- en: Identifying the current shell
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别当前的shell
- en: 'Display the currently used shell as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 显示当前使用的shell如下：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Or, you can also use:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以使用：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Check for super user
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查超级用户
- en: 'UID is an important environment variable that can be used to check whether
    the current script has been run as root user or regular user. For example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: UID是一个重要的环境变量，可以用来检查当前脚本是否以root用户或常规用户身份运行。例如：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The UID for the root user is 0.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 根用户的UID为0。
- en: Modifying the Bash prompt string (username@hostname:~$)
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改Bash提示字符串（用户名@主机名:~$）
- en: 'When we open a terminal or run a shell, we see a prompt string like `user@hostname:
    /home/$`. Different GNU/Linux distributions have slightly different prompts and
    different colors. We can customize the prompt text using the `PS1` environment
    variable. The default prompt text for the shell is set using a line in the `~/.bashrc`
    file.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们打开终端或运行shell时，我们会看到一个提示字符串，如`user@hostname: /home/$`。不同的GNU/Linux发行版有稍微不同的提示和不同的颜色。我们可以使用`PS1`环境变量自定义提示文本。shell的默认提示文本是在`~/.bashrc`文件中设置的。'
- en: 'We can list the line used to set the `PS1` variable as follows:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以列出用于设置`PS1`变量的行如下：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In order to set a custom prompt string, enter:'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了设置自定义提示字符串，输入：
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We can use colored text by using the special escape sequences like `\e[1;31`
    (refer to the *Printing in the terminal* recipe of this chapter).
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用特殊的转义序列如`\e[1;31`（参考本章的*在终端中打印*）来使用彩色文本。
- en: There are also certain special characters that expand to system parameters.
    For example,`\u` expands to username, `\h` expands to hostname, and `\w` expands
    to the current working directory.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些特殊字符可以扩展到系统参数。例如，`\u`扩展到用户名，`\h`扩展到主机名，`\w`扩展到当前工作目录。
- en: Doing math calculations with the shell
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用shell进行数学计算
- en: Arithmetic operations are an essential requirement for every programming language.
    The Bash shell comes with a variety of methods for arithmetic operations.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算是每种编程语言的基本要求。Bash shell具有各种进行算术运算的方法。
- en: Getting ready
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The Bash shell environment can perform basic arithmetic operations using the
    commands `let`, `(( ))`, and `[]`. The two utilities `expr` and `bc` are also
    very helpful in performing advanced operations.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Bash shell环境可以使用`let`、`(( ))`和`[]`命令执行基本算术运算。两个实用程序`expr`和`bc`在执行高级操作时也非常有帮助。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: A numeric value can be assigned as a regular variable assignment, which is stored
    as string. However, we use methods to manipulate as numbers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将数值分配为常规变量赋值，它以字符串形式存储。但是，我们使用方法来操作数字。
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `let` command can be used to perform basic operations directly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`let`命令可以直接执行基本操作。'
- en: 'While using `let`, we use variable names without the `$` prefix, for example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`let`时，我们使用不带`$`前缀的变量名，例如：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Increment operation:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递增操作：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Decrement operation:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递减操作：
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Shorthands:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩写：
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: These are equal to `let no=no+6` and `let no=no-6` respectively.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分别等同于`let no=no+6`和`let no=no-6`。
- en: 'Alternate methods:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备用方法：
- en: 'The `[]` operator can be used similar to the `let` command as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`[]`操作符可以像`let`命令一样使用，如下所示：'
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Using `$` prefix inside `[]` operators are legal, for example:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在`[]`操作符内部使用`$`前缀是合法的，例如：
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`(( ))` can also be used. `$` prefixed with a variable name is used when the
    `(( ))` operator is used, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`(( ))`也可以使用。当使用`(( ))`运算符时，变量名前面加上`$`，如下所示：'
- en: '[PRE54]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`expr` can also be used for basic operations:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`expr`也可以用于基本操作：'
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: All of the above methods do not support floating point numbers, and operate
    on integers only.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述方法都不支持浮点数，只能操作整数。
- en: '`bc` the precision calculator is an advanced utility for mathematical operations.
    It has a wide range of options. We can perform floating point operations and use
    advanced functions as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`bc`精度计算器是一个用于数学运算的高级实用程序。它具有广泛的选项。我们可以执行浮点运算并使用高级函数，如下所示：'
- en: '[PRE56]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Additional parameters can be passed to `bc` with prefixes to the operation with
    semicolon as delimiters through `stdin`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`stdin`通过分号作为分隔符将附加参数传递给`bc`。
- en: '**Specifying decimal precision (scale):** In the following example the `scale=2`
    parameter sets the number of decimal places to `2`. Hence the output of `bc` will
    contain a number with two decimal places:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指定十进制精度（scale）：**在下面的示例中，`scale=2`参数设置小数位数为`2`。因此，`bc`的输出将包含两位小数：'
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '**Base conversion with bc:** We can convert from one base number system to
    another one. Let''s convert from decimal to binary, and binary to octal:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用bc进行基数转换：**我们可以从一个基数系统转换为另一个基数系统。让我们从十进制转换为二进制，再从二进制转换为八进制：'
- en: '[PRE58]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Calculating squares and square roots can be done as follows:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算平方和平方根可以按如下方式进行：
- en: '[PRE59]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Playing with file descriptors and redirection
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转文件描述符和重定向
- en: File descriptors are integers that are associated with file input and output.
    They keep track of opened files. The best-known file descriptors are `stdin` ,
    `stdout` , and `stderr` . We can redirect the contents of one file descriptor
    to another. The following recipe will give examples on how to manipulate and redirect
    with file descriptors.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符是与文件输入和输出相关联的整数。它们跟踪已打开的文件。最常见的文件描述符是 `stdin`、`stdout` 和 `stderr`。我们可以将一个文件描述符的内容重定向到另一个文件描述符。以下示例将演示如何使用文件描述符进行操作和重定向。
- en: Getting ready
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: While writing scripts we use standard input (`stdin`), standard output (`stdout`),
    and standard error (`stderr`) frequently. Redirection of output to a file by filtering
    the contents is one of the essential things we need to perform. While a command
    outputs some text, it can be either an error or an output (non-error) message.
    We cannot distinguish whether it is output text or an error text by just looking
    at it. However, we can handle them with file descriptors. We can extract text
    that is attached to a specific descriptor.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写脚本时，我们经常使用标准输入（`stdin`）、标准输出（`stdout`）和标准错误（`stderr`）。通过过滤内容将输出重定向到文件是我们需要执行的基本操作之一。当一个命令输出一些文本时，它可以是错误或输出（非错误）消息。我们无法仅仅通过查看文本来区分它是输出文本还是错误文本。但是，我们可以使用文件描述符来处理它们。我们可以提取附加到特定描述符的文本。
- en: 'File descriptors are integers associated with an opened file or data stream.
    File descriptors 0, 1, and 2 are reserved as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符是与打开的文件或数据流相关联的整数。文件描述符 0、1 和 2 分别保留如下：
- en: 0 – `stdin` (standard input)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 – `stdin`（标准输入）
- en: 1 – `stdout` (standard output)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 – `stdout`（标准输出）
- en: 2 – `stderr` (standard error)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 – `stderr`（标准错误）
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Redirecting or saving output text to a file can be done as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出文本重定向或保存到文件可以按以下方式完成：
- en: '[PRE60]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This would store the echoed text in `temp.txt` by truncating the file, the contents
    will be emptied before writing.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这将通过截断文件将回显文本存储在 `temp.txt` 中，在写入之前将清空文件内容。
- en: 'Next, consider the following example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，考虑以下示例：
- en: '[PRE61]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This would append the text into the file.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把文本追加到文件中。
- en: '`>` and `>>` operators are different. Both of them redirect text to a file,
    but the first one empties the file and then writes to it, whereas the later one
    adds the output to the end of the existing file.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`>` 和 `>>` 运算符是不同的。它们两个都将文本重定向到文件，但第一个会清空文件然后写入，而后一个会将输出添加到现有文件的末尾。'
- en: 'View the contents of the file as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 查看文件内容如下：
- en: '[PRE62]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: When we use a redirection operator, it won't print in the terminal but it is
    directed to a file. When redirection operators are used, by default, it takes
    standard output. In order to explicitly take a specific file descriptor, you must
    prefix the descriptor number to the operator.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用重定向运算符时，它不会在终端上打印，而是被重定向到文件。使用重定向运算符时，默认情况下会采用标准输出。为了显式地采用特定的文件描述符，必须在运算符前加上描述符号码。
- en: '`>` is equivalent to `1>` and similarly it applies for `>>` (equivalent to
    `1>>`).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`>` 相当于 `1>`，类似地，`>>` 也适用于 `1>>`。'
- en: 'Let''s see what a standard error is and how you can redirect it. `stderr` messages
    are printed when commands output an error message. Consider the following example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看标准错误是什么，以及你如何重定向它。当命令输出错误消息时，`stderr` 消息会被打印。考虑以下示例：
- en: '[PRE63]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here `+` is an invalid argument and hence an error is returned.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `+` 是一个无效的参数，因此会返回一个错误。
- en: Tip
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Successful and unsuccessful command**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**成功和不成功的命令**'
- en: When a command returns after error, it returns a non-zero exit status. The command
    returns zero when it terminates after successful completion. Return status can
    be read from special variable `$?` (run `echo $?` immediately after the command
    execution statement to print the exit status).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个命令返回错误后，它会返回一个非零的退出状态。当成功完成后终止时，命令返回零。退出状态可以从特殊变量 `$?` 中读取（在执行命令后立即运行 `echo
    $?` 语句以打印退出状态）。
- en: 'The following command prints the `stderr` text to the screen rather than to
    a file:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将 `stderr` 文本打印到屏幕而不是文件中：
- en: '[PRE64]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'However, in the following command the `stdout` output is empty, so an empty
    file `out.txt` is generated:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在以下命令中，`stdout` 输出为空，因此会生成一个空文件 `out.txt`：
- en: '[PRE65]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You can redirect `stderr` exclusively to a file and `stdout` to another file
    as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `stderr` 独占地重定向到一个文件，将 `stdout` 重定向到另一个文件，如下所示：
- en: '[PRE66]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'It is also possible to redirect `stderr` and `stdout` to a single file by converting
    `stderr` to `stdout` using this preferred method:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过将 `stderr` 转换为 `stdout` 的方式将 `stderr` 和 `stdout` 重定向到单个文件：
- en: '[PRE67]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'or an alternate approach:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 或者另一种方法：
- en: '[PRE68]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Sometimes the output may contain unnecessary information (such as debug messages).
    If you don't want the output terminal burdened with the `stderr` details, then
    you should redirect `stderr` output to `/dev/null`, which removes it completely.
    For example, consider that we have three files a1, a2, and a3\. However, a1 does
    not have read-write-execute permission for the user. When you need to print the
    contents of files starting with `a`, you can use the `cat` command.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有时输出可能包含不必要的信息（如调试消息）。如果你不希望输出终端负担着 `stderr` 的细节，那么你应该将 `stderr` 输出重定向到 `/dev/null`，这样可以完全删除它。例如，假设我们有三个文件
    a1、a2 和 a3。然而，a1 对用户没有读写执行权限。当你需要打印以 `a` 开头的文件的内容时，可以使用 `cat` 命令。
- en: 'Set up the test files as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 设置测试文件如下：
- en: '[PRE69]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'While displaying contents of the files using wildcards (`a*`), it will show
    an error message for file `a1` as it does not have the proper read permission:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通配符（`a*`）显示文件内容时，对于文件 `a1` 会显示错误消息，因为它没有适当的读取权限：
- en: '[PRE70]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here `cat: a1: Permission denied` belongs to `stderr` data. We can redirect
    `stderr` data into a file, whereas `stdout` remains printed in the terminal. Consider
    the following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '这里的 `cat: a1: Permission denied` 属于 `stderr` 数据。我们可以将 `stderr` 数据重定向到文件，而 `stdout`
    仍然会在终端上打印。考虑以下代码：'
- en: '[PRE71]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Take a look at the following code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码：
- en: '[PRE72]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In this case, the `stderr` output is dumped to the `/dev/null` file. `/dev/null`
    is a special device file where any data received by the file is discarded. The
    null device is often called the bit bucket or black hole.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`stderr`输出被转储到`/dev/null`文件。`/dev/null`是一个特殊的设备文件，其中接收到的任何数据都被丢弃。空设备通常被称为位桶或黑洞。
- en: When redirection is performed for `stderr` or `stdout`, the redirected text
    flows into a file. As the text has already been redirected and has gone into the
    file, no text remains to flow to the next command through pipe (`|`), and it appears
    to the next set of command sequence through `stdin`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当对`stderr`或`stdout`执行重定向时，重定向的文本流入文件。由于文本已经被重定向并且已经进入文件，没有文本剩下通过管道（`|`）流向下一个命令，它会出现在下一个命令序列的`stdin`中。
- en: 'However, there is a tricky way to redirect data to a file as well as provide
    a copy of redirected data as `stdin` for the next set of commands. This can be
    done using the `tee` command. For example, to print the `stdout` in the terminal
    as well as redirect `stdout` into a file, the syntax for`tee` is as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种巧妙的方法可以将数据重定向到文件，并为下一组命令提供重定向数据的副本作为`stdin`。这可以使用`tee`命令来实现。例如，要在终端上打印`stdout`并将`stdout`重定向到文件，`tee`的语法如下：
- en: '`command | tee FILE1 FILE2`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`command | tee FILE1 FILE2`'
- en: 'In the following code, `stdin` data is received by the `tee` command. It writes
    a copy of `stdout` to the file `out.txt` and sends another copy as `stdin` for
    the next command. The `cat –n` command puts a line number for each line received
    from `stdin` and writes it into `stdout`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`tee`命令接收`stdin`数据。它将`stdout`的副本写入文件`out.txt`，并将另一个副本作为`stdin`发送给下一个命令。`cat
    –n`命令为从`stdin`接收的每一行添加行号，并将其写入`stdout`：
- en: '[PRE73]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Examine the contents of `out.txt` as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示检查`out.txt`的内容：
- en: '[PRE74]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Note that `cat: a1: Permission denied` does not appear because it belongs to
    `stdin`. `tee` can read from `stdin` only.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，`cat: a1: Permission denied`不会出现，因为它属于`stdin`。`tee`只能从`stdin`读取。'
- en: 'By default, the `tee` command overwrites the file, but it can be used with
    appended options by providing the `-a` option, for example:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`tee`命令会覆盖文件，但可以通过提供`-a`选项来使用追加选项，例如：
- en: '[PRE75]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Commands appear with arguments in the format: `command FILE1 FILE2…` or simply
    `command FILE`.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 命令以以下格式出现：`command FILE1 FILE2…`或者简单地`command FILE`。
- en: 'We can use `stdin` as a command argument. It can be done by using `–` as the
    filename argument for the command as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`stdin`作为命令参数。可以通过使用`-`作为命令的文件名参数来实现：
- en: '[PRE76]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'For example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE77]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Alternately, we can use `/dev/stdin` as the output filename to use `stdin`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`/dev/stdin`作为输出文件名来使用`stdin`。
- en: Similarly, use `/dev/stderr` for standard error and `/dev/stdout` for standard
    output. These are special device files that correspond to `stdin`, `stderr`, and
    `stdout`.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，使用`/dev/stderr`作为标准错误和`/dev/stdout`作为标准输出。这些是对应于`stdin`、`stderr`和`stdout`的特殊设备文件。
- en: There's more...
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'A command that reads `stdin` for input can receive data in multiple ways. Also,
    it is possible to specify file descriptors of our own using `cat` and pipes, for
    example:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 读取`stdin`输入的命令可以以多种方式接收数据。还可以使用`cat`和管道指定我们自己的文件描述符，例如：
- en: '[PRE78]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Redirection from file to command
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从文件重定向到命令
- en: 'By using redirection, we can read data from a file as `stdin` as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重定向，我们可以从文件中读取数据作为`stdin`，如下所示：
- en: '[PRE79]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Redirecting from a text block enclosed within a script
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从脚本中包含的文本块进行重定向
- en: 'Sometimes we need to redirect a block of text (multiple lines of text) as standard
    input. Consider a particular case where the source text is placed within the shell
    script. A practical usage example is writing a log file header data. It can be
    performed as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要将一块文本（多行文本）重定向为标准输入。考虑一个特殊情况，源文本放在shell脚本中。一个实际的用例是写入日志文件头数据。可以按照以下步骤执行：
- en: '[PRE80]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The lines that appear between `cat <<EOF >log.txt` and the next `EOF` line
    will appear as `stdin` data. Print the contents of `log.txt` as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 出现在`cat <<EOF >log.txt`和下一个`EOF`行之间的行将作为`stdin`数据出现。如下所示打印`log.txt`的内容：
- en: '[PRE81]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Custom file descriptors
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义文件描述符
- en: A file descriptor is an abstract indicator for accessing a file. Each file access
    is associated with a special number called a file descriptor. 0, 1, and 2 are
    reserved descriptor numbers for `stdin`, `stdout`, and `stderr`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符是访问文件的抽象指示器。每个文件访问都与一个称为文件描述符的特殊数字相关联。0、1和2是`stdin`、`stdout`和`stderr`的保留描述符号。
- en: 'We can create our own custom file descriptors using the `exec` command. If
    you are already familiar with file programming with any other programming languages,
    you might have noticed modes for opening files. Usually, three modes are used:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`exec`命令创建自定义文件描述符。如果您已经熟悉其他编程语言的文件编程，您可能已经注意到打开文件的模式。通常使用三种模式：
- en: Read mode
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取模式
- en: Write with truncate mode
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用截断模式写入
- en: Write with append mode
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用追加模式写入
- en: '`<` is an operator used to read from the file to `stdin`. `>` is the operator
    used to write to a file with truncation (data is written to the target file after
    truncating the contents). `>>` is an operator used to write to a file with append
    (data is appended to the existing file contents and the contents of the target
    file will not be lost). File descriptors can be created with one of the three
    modes.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`<`是一个用于从文件读取到`stdin`的操作符。`>`是用于写入文件并截断的操作符（数据被写入目标文件后截断内容）。`>>`是用于追加写入文件的操作符（数据被追加到现有文件内容中，目标文件的内容不会丢失）。文件描述符可以用三种模式之一创建。'
- en: 'Create a file descriptor for reading a file, as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 创建用于读取文件的文件描述符，如下所示：
- en: '[PRE82]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'We could use it as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式使用它：
- en: '[PRE83]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now you can use file descriptor `3` with commands. For example, `cat <&3` as
    follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用文件描述符`3`与命令一起使用。例如，`cat <&3`如下所示：
- en: '[PRE84]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: If a second read is required, we cannot reuse file descriptor `3`. It is needed
    to reassign file descriptor `3` for read using `exec` for making a second read.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要进行第二次读取，则不能重用文件描述符`3`。需要使用`exec`重新分配文件描述符`3`进行读取，以进行第二次读取。
- en: 'Create a file descriptor for writing (truncate mode) as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个用于写入的文件描述符（截断模式）如下：
- en: '[PRE85]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'For example:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE86]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Create a file descriptor for writing (append mode) as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个用于写入的文件描述符（追加模式）如下：
- en: '[PRE87]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'For example:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE88]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Arrays and associative arrays
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组和关联数组
- en: Arrays are a very important component for storing a collection of data as separate
    entities using indexes.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是存储使用索引作为单独实体的数据集合的非常重要的组件。
- en: Getting ready
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Bash supports regular arrays as well as associative arrays. Regular arrays are
    arrays which can use only integers as its array index. But associative arrays
    are arrays which can take a string as its array index.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Bash支持常规数组和关联数组。常规数组是只能使用整数作为数组索引的数组。但是，关联数组是可以将字符串作为其数组索引的数组。
- en: Associative arrays are very useful in many types of manipulations. Associative
    array support came with version 4.0 of Bash. Therefore, older versions of Bash
    will not support associative arrays.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 关联数组在许多类型的操作中非常有用。关联数组支持是在Bash的4.0版本中引入的。因此，旧版本的Bash将不支持关联数组。
- en: How to do it...
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'An array can be defined in many ways. Define an array using a list of values
    in a line, as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以以许多方式定义。可以按照一行中的值列表定义数组，如下所示：
- en: '[PRE89]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Alternately, define an array as a set of index-value pairs as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以按如下方式定义数组为一组索引-值对：
- en: '[PRE90]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Print the contents of an array at a given index using:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方法在给定索引处打印数组的内容：
- en: '[PRE91]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Print all of the values in an array as a list using:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方法将数组中的所有值打印为列表：
- en: '[PRE92]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Alternately, you can use:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用：
- en: '[PRE93]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Print the length of an array (the number of elements in an array), as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式打印数组的长度（数组中的元素数）：
- en: '[PRE94]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: There's more...
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Associative arrays have been introduced to Bash from version 4.0\. They are
    useful entities to solve many problems using the hashing technique. Let's go into
    more details.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 从4.0版本开始，Bash引入了关联数组。它们是使用哈希技术解决许多问题的有用实体。让我们深入了解一下。
- en: Defining associative arrays
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义关联数组
- en: In an associative array, we can use any text data as an array index. However,
    ordinary arrays can only use integers for array indexing.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在关联数组中，我们可以使用任何文本数据作为数组索引。但是，普通数组只能使用整数作为数组索引。
- en: 'Initially, a declaration statement is required to declare a variable name as
    an associative array. A declaration can be made as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要声明语句来将变量名声明为关联数组。声明可以如下进行：
- en: '[PRE95]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'After the declaration, elements can be added to the associative array using
    two methods, as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 声明后，可以使用以下两种方法向关联数组添加元素：
- en: 'By using inline index-value list method, we can provide a list of index-value
    pairs:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用内联索引-值列表方法，我们可以提供索引-值对的列表：
- en: '[PRE96]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Alternately, you could use separate index-value assignments:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您可以使用单独的索引-值赋值：
- en: '[PRE97]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'For example, consider the assignment of prices for fruits using an associative
    array:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑使用关联数组为水果分配价格：
- en: '[PRE98]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Display the content of an array as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式显示数组的内容：
- en: '[PRE99]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Listing of array indexes
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组索引列表
- en: 'Arrays have indexes for indexing each of the elements. Ordinary and associative
    arrays differ in terms of index type. We can obtain the list of indexes in an
    array as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 数组具有用于索引每个元素的索引。普通数组和关联数组在索引类型方面有所不同。我们可以按如下方式获取数组中的索引列表：
- en: '[PRE100]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Or, we can also use:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用：
- en: '[PRE101]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In the previous `fruits_value` array example, consider the following:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的`fruits_value`数组示例中，考虑以下内容：
- en: '[PRE102]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This will work for ordinary arrays too.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于普通数组。
- en: Visiting aliases
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问别名
- en: An alias is basically a shortcut that takes the place of typing a long command
    sequence.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 别名基本上是一个快捷方式，可以代替输入一长串命令。
- en: Getting ready
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Aliases can be implemented in multiple ways, either by using functions or by
    using the `alias` command.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 别名可以通过多种方式实现，可以使用函数或使用`alias`命令。
- en: How to do it...
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'An alias can be implemented as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 别名可以按如下方式实现：
- en: '[PRE103]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Giving a shortcut to the install command, `apt-get install`, can be done as
    follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为`install`命令提供快捷方式`apt-get install`，可以按如下方式完成：
- en: '[PRE104]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Therefore, we can use `install pidgin` instead of `sudo apt-get install pidgin`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用`install pidgin`代替`sudo apt-get install pidgin`。
- en: The `alias` command is temporary; aliasing exists until we close the current
    terminal only. In order to keep these shortcuts permanent, add this statement
    to the `~/.bashrc` file. Commands in `~/.bashrc` are always executed when a new
    shell process is spawned.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`alias`命令是临时的；别名仅在关闭当前终端之前存在。为了使这些快捷方式永久存在，将此语句添加到`~/.bashrc`文件中。在新的shell进程生成时，`~/.bashrc`中的命令总是被执行。'
- en: '[PRE105]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: To remove an alias, remove its entry from `~/.bashrc` or use the `unalias` command.
    Another method is to define a function with a new command name and write it in
    `~/.bashrc`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除别名，从`~/.bashrc`中删除其条目或使用`unalias`命令。另一种方法是定义一个具有新命令名称的函数，并将其写入`~/.bashrc`。
- en: 'We can alias `rm` so that it will delete the original and keep a copy in a
    backup directory:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`rm`别名为删除原始文件并将其保留在备份目录中：
- en: '[PRE106]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: When you create an alias, if the item being aliased already exists, it will
    be replaced by this newly aliased command for that user.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建别名时，如果要别名化的项目已经存在，则它将被新别名的命令替换为该用户的命令。
- en: There's more...
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are situations when aliasing can also be a security breach. See how to
    identify them:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 有时别名也可能会造成安全漏洞。看看如何识别它们：
- en: Escaping aliases
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转义别名
- en: 'The `alias` command can be used to alias any important command, and you may
    not always want to run the command using the alias. We can ignore any aliases
    currently defined by escaping the command we want to run. For example:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`alias`命令可用于为任何重要命令设置别名，并且您可能并不总是希望使用别名运行命令。我们可以通过转义要运行的命令来忽略当前定义的任何别名。例如：'
- en: '[PRE107]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The `\` character escapes the command, running it without any aliased changes.
    While running privileged commands on an untrusted environment, it is always a
    good security practise to ignore aliases by prefixing the command with `\`. The
    attacker might have aliased the privileged command with his own custom command
    to steal the critical information that is provided to the command by the user.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`\`字符转义命令，使其在没有任何别名更改的情况下运行。在不受信任的环境中运行特权命令时，通过在命令前加上`\`来忽略别名始终是一个良好的安全实践。攻击者可能已经使用自己的自定义命令将特权命令别名化，以窃取用户提供给命令的关键信息。'
- en: Grabbing information about terminal
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取有关终端的信息
- en: While writing command-line shell scripts, we will often need to heavily manipulate
    information about the current terminal, such as number of columns, rows, cursor
    positions, masked password fields, and so on. This recipe helps to learn about
    collecting and manipulating terminal settings.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写命令行shell脚本时，我们经常需要大量操作有关当前终端的信息，例如列数、行数、光标位置、掩码密码字段等。本教程将帮助您了解收集和操作终端设置。
- en: Getting ready
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: '`tput` and `stty` are utilities that can be used for terminal manipulations.
    Let''s see how to use them to perform different tasks.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`tput`和`stty`是可用于终端操作的实用程序。让我们看看如何使用它们执行不同的任务。'
- en: How to do it...
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Get number of columns and rows in a terminal as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 获取终端中的列数和行数如下：
- en: '[PRE108]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'In order to print the current terminal name, use:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印当前的终端名称，使用：
- en: '[PRE109]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'For moving the cursor to a position 100,100 you can enter:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 要将光标移动到位置100,100，可以输入：
- en: '[PRE110]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Set the background color for terminal as follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 将终端的背景颜色设置如下：
- en: '[PRE111]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '`no` can be a value in the range of 0 to 7.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`no`可以是0到7范围内的值。'
- en: 'Set the foreground color for text as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本的前景颜色设置如下：
- en: '[PRE112]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '`no` can be a value in the range of 0 to 7.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`no`可以是0到7范围内的值。'
- en: 'In order to make the text bold use:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使文本加粗使用：
- en: '[PRE113]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Start and end underlining by using:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用以下方式开始和结束下划线：
- en: '[PRE114]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'In order to delete from cursor to end of the line use:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从光标删除到行尾，请使用：
- en: '[PRE115]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'While typing a password, we should not display the characters typed. In the
    following example, we will see how to do it using `stty`:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入密码时，我们不应该显示已输入的字符。在以下示例中，我们将看到如何使用`stty`来实现：
- en: '[PRE116]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The `-echo` option above disables output to the terminal, whereas `echo` enables
    output.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`-echo`选项禁用了对终端的输出，而`echo`则启用了输出。
- en: Getting, setting dates, and delays
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取、设置日期和延迟
- en: Many applications require printing dates in different formats, setting the date
    and time, and performing manipulations based on the date and time. Delays are
    commonly used to provide a wait time (for example, 1 second) during the program's
    execution. Scripting contexts, such as performing a monitoring task every five
    seconds, demand the understanding of writing delays in a program. This recipe
    will show you how to work with dates and time delays.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序需要以不同的格式打印日期，设置日期和时间，并根据日期和时间执行操作。延迟通常用于在程序执行期间提供等待时间（例如，1秒）。脚本上下文，例如每五秒执行一次监视任务，需要理解如何在程序中编写延迟。本教程将向您展示如何处理日期和时间延迟。
- en: Getting ready
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: Dates can be printed in a variety of formats. We can also set dates from the
    command line. In UNIX-like systems, dates are stored as an integer in seconds
    since 1970-01-01 00:00:00 UTC. This is called epoch or UNIX time. Let's see how
    to read dates and set them.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 日期可以以各种格式打印。我们还可以从命令行设置日期。在类UNIX系统中，日期以自1970-01-01 00:00:00 UTC以来的秒数存储为整数。这称为纪元或UNIX时间。让我们看看如何读取日期并设置日期。
- en: How to do it...
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'You can read the date as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按如下方式读取日期：
- en: '[PRE117]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The epoch time can be printed as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 纪元时间可以打印如下：
- en: '[PRE118]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Epoch is defined as the number of seconds that have elapsed since midnight proleptic
    Coordinated Universal Time (UTC) of January 1, 1970, not counting leap seconds.
    Epoch time is useful when you need to calculate the difference between two dates
    or time. You may find out the epoch times for two given timestamps and take the
    difference between the epoch values. Therefore, you can find out the total number
    of seconds between two dates.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 纪元被定义为自1970年1月1日协调世界时（UTC）午夜以来经过的秒数，不包括闰秒。纪元时间在需要计算两个日期或时间之间的差异时非常有用。您可以找出两个给定时间戳的纪元时间，并计算纪元值之间的差异。因此，您可以找出两个日期之间的总秒数。
- en: 'We can find out epoch from a given formatted date string. You can use dates
    in multiple date formats as input. Usually, you don''t need to bother about the
    date string format that you use if you are collecting the date from a system log
    or any standard application generated output. You can convert a date string into
    epoch as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从给定的格式化日期字符串中找出纪元。您可以使用多种日期格式作为输入。通常，如果您从系统日志或任何标准应用程序生成的输出中收集日期，您不需要担心使用的日期字符串格式。您可以按如下方式将日期字符串转换为纪元：
- en: '[PRE119]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The `--date` option is used to provide a date string as input. However, we can
    use any date formatting options to print output. Feeding input date from a string
    can be used to find out the weekday, given the date.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`--date`选项用于提供日期字符串作为输入。但是，我们可以使用任何日期格式选项来打印输出。从字符串中提取输入日期可以用于找出给定日期的工作日。'
- en: 'For example:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE120]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The date format strings are listed in the following table:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 日期格式字符串列在以下表中：
- en: '| Date component | Format |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| 日期组件 | 格式 |'
- en: '| --- | --- |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Weekday | `%a` (for example:. Sat)`%A` (for example: Saturday) |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| 工作日 | `%a`（例如：Sat）`%A`（例如：Saturday）|'
- en: '| Month | `%b` (for example: Nov)`%B` (for example: November) |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| 月 | `%b`（例如：Nov）`%B`（例如：November）|'
- en: '| Day | `%d` (for example: 31) |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| 天 | `%d`（例如：31）|'
- en: '| Date in format (mm/dd/yy) | `%D` (for example: 10/18/10) |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| 格式中的日期（mm/dd/yy） | `%D`（例如：10/18/10）|'
- en: '| Year | `%y` (for example: 10)`%Y` (for example: 2010) |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| 年 | `%y`（例如：10）`%Y`（例如：2010）|'
- en: '| Hour | `%I` or `%H` (for example: 08) |'
  id: totrans-415
  prefs: []
  type: TYPE_TB
  zh: '| 小时 | `%I`或`%H`（例如：08）|'
- en: '| Minute | `%M` (for example: 33) |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| 分钟 | `%M`（例如：33）|'
- en: '| Second | `%S` (for example: 10) |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| 秒 | `%S`（例如：10）|'
- en: '| Nano second | `%N` (for example:695208515) |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| 纳秒 | `%N`（例如：695208515）|'
- en: '| epoch UNIX time in seconds | `%s` (for example: 1290049486) |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '|以秒为单位的UNIX时间戳|`%s`（例如：1290049486）|'
- en: 'Use a combination of format strings prefixed with `+` as an argument for the
    `date` command to print the date in the format of your choice. For example:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以`+`为前缀的格式字符串的组合作为`date`命令的参数，以打印所需格式的日期。例如：
- en: '[PRE121]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'We can set the date and time as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式设置日期和时间：
- en: '[PRE122]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'For example:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE123]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Sometimes we need to check the time taken by a set of commands. We can display
    it as follows:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要检查一组命令所花费的时间。我们可以按如下方式显示它：
- en: '[PRE124]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: An alternate method would be to use `timescriptpath` to get the time that it
    took to execute the script.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`timescriptpath`来获取执行脚本所需的时间。
- en: There's more...
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Producing time intervals are essential when writing monitoring scripts that
    execute in a loop. Let's see how to generate time delays.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写循环执行的监控脚本时，生成时间间隔是必不可少的。让我们看看如何生成时间延迟。
- en: Producing delays in a script
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在脚本中产生延迟
- en: In order to delay execution in a script for some period of time, use `sleep:$
    sleep no_of_seconds`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在脚本中延迟执行一段时间，使用`sleep:$ sleep no_of_seconds`。
- en: 'For example, the following script counts from 0 to 40 by using `tput` and `sleep`:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下脚本使用`tput`和`sleep`从0计数到40：
- en: '[PRE125]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: In the above example, a variable count is initialized to 0 and is incremented
    on every loop execution. The `echo` statement prints the text. We use `tput sc`
    to store the cursor position. On every loop execution we write the new count in
    the terminal by restoring the cursor position for the number. The cursor position
    is restored using `tput rc. tput ed` clears text from the current cursor position
    to the end of the line, so that the older number can be cleared and the count
    can be written. A delay of 1 second is provided in the loop by using the sleep
    command.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，一个变量count被初始化为0，并在每次循环执行时递增。`echo`语句打印文本。我们使用`tput sc`来存储光标位置。在每次循环执行时，我们通过恢复数字的光标位置在终端中写入新的计数。使用`tput
    rc`来恢复光标位置。`tput ed`清除当前光标位置到行尾的文本，以便清除旧数字并写入计数。使用`sleep`命令在循环中提供1秒的延迟。
- en: Debugging the script
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试脚本
- en: Debugging is one of the critical features every programming language should
    implement to produce race-back information when something unexpected happens.
    Debugging information can be used to read and understand what caused the program
    to crash or to act in an unexpected fashion. Bash provides certain debugging options
    that every sysadmin should know. There are also some other tricky ways to debug.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是每种编程语言都应该实现的关键功能之一，以在发生意外情况时产生回溯信息。调试信息可用于阅读和理解导致程序崩溃或以意外方式行事的原因。Bash提供了一些调试选项，每个系统管理员都应该知道。还有一些其他巧妙的调试方法。
- en: Getting ready
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: No special utilities are required to debug shell scripts. Bash comes with certain
    flags that can print arguments and inputs taken by the scripts. Let's see how
    to do it.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 调试shell脚本不需要特殊的实用程序。Bash带有一些标志，可以打印脚本接受的参数和输入。让我们看看如何做。
- en: How to do it...
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Add the `-x` option to enable debug tracing of a shell script as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`-x`选项以启用shell脚本的调试跟踪，如下所示：
- en: '[PRE126]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Running the script with the `-x` flag will print each source line with current
    status. Note that you can also use `sh –x script`.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-x`标志运行脚本将打印每个源代码行的当前状态。请注意，您还可以使用`sh –x script`。
- en: The `-x` flag outputs every line of script as it is executed to `stdout`. However,
    we may require only some portions of the source lines to be observed such that
    commands and arguments are to be printed at certain portions. In such conditions
    we can use `set built-in` to enable and disable debug printing within the script.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`-x`标志会将脚本的每一行在执行时输出到`stdout`。但是，我们可能只需要观察源代码的某些部分，以便在某些部分打印命令和参数。在这种情况下，我们可以使用`set内置`在脚本中启用和禁用调试打印。'
- en: '`set -x`: Displays arguments and commands upon their execution'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set -x`：在执行时显示参数和命令'
- en: '`set +x`: Disables debugging'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set +x`：禁用调试'
- en: '`set –v`: Displays input when they are read'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set –v`：在读取输入时显示输入'
- en: '`set +v`: Disables printing input'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set +v`：禁止打印输入'
- en: 'For example:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE127]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: In the above script, debug information for `echo $i` will only be printed as
    debugging is restricted to that section using `-x` and `+x`.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述脚本中，`echo $i`的调试信息只会在该部分使用`-x`和`+x`限制调试时打印。
- en: The above debugging methods are provided by bash built-ins. But they always
    produce debugging information in a fixed format. In many cases, we need debugging
    information in our own format. We can set up such a debugging style by passing
    the `_DEBUG` environment variable.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 上述调试方法由bash内置提供。但它们总是以固定格式产生调试信息。在许多情况下，我们需要以自己的格式获得调试信息。我们可以通过传递`_DEBUG`环境变量来设置这样的调试样式。
- en: 'Look at the following example code:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下示例代码：
- en: '[PRE128]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'We can run the above script with debugging set to "on" as follows:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式运行上述脚本，调试设置为“on”：
- en: '[PRE129]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: We prefix `DEBUG` before every statement where debug information is to be printed.
    If `_DEBUG=on` is not passed to script, debug information will not be printed.
    In Bash the command ':' tells the shell to do nothing.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每个需要打印调试信息的语句前加上`DEBUG`前缀。如果未将`_DEBUG=on`传递给脚本，则不会打印调试信息。在Bash中，命令`:`告诉shell什么都不做。
- en: There's more...
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can also use other convenient ways to debug scripts. We can make use of shebang
    in a trickier way to debug scripts.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用其他方便的方法来调试脚本。我们可以巧妙地利用shebang来调试脚本。
- en: Shebang hack
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shebang hack
- en: The shebang can be changed from `#!/bin/bash` to `#!/bin/bash –xv` to enable
    debugging without any additional flags (`-xv` flags themselves).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: shebang可以从`#!/bin/bash`更改为`#!/bin/bash –xv`，以启用调试而无需任何额外的标志（`-xv`标志本身）。
- en: Functions and arguments
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和参数
- en: Like any other scripting languages, Bash also supports functions. Let's see
    how to define and use functions.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他脚本语言一样，Bash也支持函数。让我们看看如何定义和使用函数。
- en: How to do it...
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'A function can be defined as follows:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义函数如下：
- en: '[PRE130]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Or alternately,
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，
- en: '[PRE131]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'A function can be invoked just by using its name:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以通过使用其名称来调用：
- en: '[PRE132]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Arguments can be passed to functions and can be accessed by our script:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以传递给函数，并且可以被我们的脚本访问：
- en: '[PRE133]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Following is the definition of the function `fname`. In the `fname` function,
    we have included various ways of accessing the function arguments.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是函数`fname`的定义。在`fname`函数中，我们已经包含了各种访问函数参数的方式。
- en: '[PRE134]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Similarly, arguments can be passed to scripts and can be accessed by `script:$0`
    (the name of the script):'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，参数可以传递给脚本，并且可以通过`script:$0`（脚本的名称）访问：
- en: '`$1` is the first argument'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$1`是第一个参数'
- en: '`$2` is the second argument'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$2`是第二个参数'
- en: '`$n` is the nth argument'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$n`是第n个参数'
- en: '`"$@"` expands as `"$1" "$2" "$3"` and so on'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"$@"`扩展为`"$1" "$2" "$3"`等等'
- en: '`"$*"` expands as `"$1c$2c$3"`, where `c` is the first character of IFS'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"$*"`扩展为`"$1c$2c$3"`，其中`c`是IFS的第一个字符'
- en: '`"$@"` is the most used one. `"$*"` is used rarely since it gives all arguments
    as a single string.'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"$@"`是最常用的。`"$*"`很少使用，因为它将所有参数作为单个字符串。'
- en: There's more...
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's explore more tips on Bash functions.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索更多有关Bash函数的提示。
- en: Recursive function
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归函数
- en: Functions in Bash also support recursion (the function that can call itself).
    For example, `F() { echo $1; F hello; sleep 1; }`.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: Bash中的函数也支持递归（可以调用自身的函数）。例如，`F() { echo $1; F hello; sleep 1; }`。
- en: Tip
  id: totrans-486
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Fork bomb**'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '**分叉炸弹**'
- en: ':(){ :|:& };:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: ':(){ :|:& };:'
- en: This recursive function is a function that calls itself. It infinitely spawns
    processes and ends up in a denial of service attack. `&` is postfixed with the
    function call to bring the subprocess into the background. This is a dangerous
    code as it forks processes and, therefore, it is called a fork bomb.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这个递归函数是一个调用自身的函数。它无限地生成进程，并最终导致拒绝服务攻击。在函数调用后加上`&`将子进程放入后台。这是一个危险的代码，因为它会分叉进程，因此被称为分叉炸弹。
- en: You may find it difficult to interpret the above code. See Wikipedia page [http://en.wikipedia.org/wiki/Fork_bomb](http://en.wikipedia.org/wiki/Fork_bomb)
    for more details and interpretation of the fork bomb.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现难以解释上面的代码。请参阅维基百科页面[http://en.wikipedia.org/wiki/Fork_bomb](http://en.wikipedia.org/wiki/Fork_bomb)了解更多关于分叉炸弹的细节和解释。
- en: It can be prevented by restricting the maximum number of processes that can
    be spawned from the config file `/etc/security/limits.conf`.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过限制从配置文件`/etc/security/limits.conf`生成的最大进程数来防止它。
- en: Exporting functions
  id: totrans-492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导出函数
- en: 'A function can be exported like environment variables using `export` such that
    the scope of the function can be extended to subprocesses, as follows:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`export`导出函数，就像导出环境变量一样，这样函数的范围可以扩展到子进程，如下所示：
- en: '[PRE135]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Reading command return value (status)
  id: totrans-495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取命令返回值（状态）
- en: 'We can get the return value of a command or function as follows:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式获取命令或函数的返回值：
- en: '[PRE136]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '`$?` will give the return value of the command `cmd`.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`$?`将给出命令`cmd`的返回值。'
- en: The return value is called exit status. It can be used to analyze whether a
    command completed its execution successfully or unsuccessfully. If the command
    exits successfully, the exit status will be zero, else it will be non-zero.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值称为退出状态。它可以用来分析命令是否成功执行完成。如果命令成功退出，退出状态将为零，否则将为非零。
- en: 'We can check whether a command terminated successfully or not as follows:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式检查命令是否成功终止：
- en: '[PRE137]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Passing arguments to commands
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将参数传递给命令
- en: 'Arguments to commands can be passed in different formats. Suppose `–p` and
    `-v` are the options available and `-k NO` is another option that takes a number.
    Also the command takes a filename as argument. It can be executed in multiple
    ways as follows:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的参数可以以不同的格式传递。假设`-p`和`-v`是可用的选项，`-k NO`是另一个需要一个数字的选项。此外，命令需要一个文件名作为参数。可以按以下方式执行：
- en: '[PRE138]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Or:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE139]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Or:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE140]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Or:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE141]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Reading the output of a sequence of commands
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取一系列命令的输出
- en: One of the best-designed features of shell scripting is the ease of combining
    many commands or utilities to produce output. The output of one command can appear
    as the input of another, which passes its output to another command, and so on.
    The output of this combination can be read in a variable. This recipe illustrates
    how to combine multiple commands and how its output can be read.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: Shell脚本设计的最佳特性之一是轻松组合多个命令或实用程序以产生输出。一个命令的输出可以作为另一个命令的输入，后者将其输出传递给另一个命令，依此类推。这种组合的输出可以在一个变量中读取。本教程说明了如何组合多个命令以及如何读取其输出。
- en: Getting ready
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Input is usually fed into a command through `stdin` or arguments. Output appears
    as `stderr` or `stdout`. While we combine multiple commands, we usually use `stdin`
    to give input and `stdout` for output.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 通常通过`stdin`或参数将输入提供给命令。输出显示为`stderr`或`stdout`。当我们组合多个命令时，我们通常使用`stdin`提供输入和`stdout`提供输出。
- en: 'Commands are called as filters. We connect each filter using pipes. The piping
    operator is "`|`". An example is as follows:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 命令被称为过滤器。我们使用管道连接每个过滤器。管道操作符是"`|`"。例如：
- en: '[PRE142]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Here we combine three commands. The output of `cmd1` goes to `cmd2` and output
    of `cmd2` goes to `cmd3` and the final output (which comes out of `cmd3`) will
    be printed or it can be directed to a file.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们结合了三个命令。`cmd1`的输出传递给`cmd2`，`cmd2`的输出传递给`cmd3`，最终输出（来自`cmd3`）将被打印或可以被重定向到文件。
- en: How to do it...
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Have a look at the following code:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码：
- en: '[PRE143]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Here the output of `ls` (the listing of the current directory) is passed to
    `cat -n`. `cat –n` puts line numbers to the input received through `stdin`. Therefore,
    its output is redirected to the `out.txt` file.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`ls`的输出（当前目录的列表）被传递给`cat -n`。`cat –n`为通过`stdin`接收的输入添加行号。因此，它的输出被重定向到`out.txt`文件。
- en: 'We can read the output of a sequence of commands combined by pipes as follows:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以读取由管道组合的一系列命令的输出，如下所示：
- en: '[PRE144]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'This is called the subshell method. For example:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为子shell方法。例如：
- en: '[PRE145]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Another method, called back-quotes can also be used to store the command output
    as follows:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法，称为反引号，也可以用来存储命令的输出，如下所示：
- en: '[PRE146]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'For example:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE147]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Back quote is different from the single quote character. It is the character
    on the *~* button in the keyboard.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 反引号与单引号字符不同。它是键盘上*~*按钮上的字符。
- en: There's more...
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are multiple ways of grouping commands. Let's go through few of them.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种组合命令的方法。让我们看一些。
- en: Spawning a separate process with subshell
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用子shell生成一个单独的进程
- en: 'Subshells are separate processes. A subshell can be defined using the `( )`operators
    as follows:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 子shell是独立的进程。可以使用`( )`操作符定义子shell，如下所示：
- en: '[PRE148]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: When some commands are executed in a subshell none of the changes occur in the
    current shell; changes are restricted to the subshell. For example, when the current
    directory in a subshell is changed using the `cd` command, the directory change
    is not reflected in the main shell environment.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 当在子shell中执行某些命令时，当前shell中不会发生任何更改；更改仅限于子shell。例如，在子shell中使用`cd`命令更改当前目录时，目录更改不会反映在主shell环境中。
- en: The `pwd` command prints the path of the working directory.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '`pwd`命令打印工作目录的路径。'
- en: The `cd` command changes the current directory to the given directory path.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '`cd`命令将当前目录更改为给定的目录路径。'
- en: Subshell quoting to preserve spacing and newline character
  id: totrans-539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用子shell引用以保留间距和换行字符
- en: 'Suppose we are reading the output of a command to a variable using a subshell
    or the back-quotes method, we always quote them in double-quotes to preserve the
    spacing and newline character (\n). For example:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在使用子shell或反引号方法将命令的输出读取到一个变量中，我们总是用双引号引起来以保留间距和换行字符（\n）。例如：
- en: '[PRE149]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Reading "n" characters without pressing Return
  id: totrans-542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取“n”个字符而不按回车键
- en: '`read` is an important Bash command that can be used to read text from keyboard
    or standard input. We can use `read` to interactively read an input from the user,
    but `read` is capable of much more. Let''s look at a new recipe to illustrate
    some of the most important options available with the `read` command.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`是一个重要的Bash命令，可用于从键盘或标准输入读取文本。我们可以使用`read`来交互式地从用户那里读取输入，但`read`还可以做更多。让我们看一个新的示例来说明`read`命令提供的一些最重要的选项。'
- en: Getting ready
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Most of the input libraries in any programming language read the input from
    the keyboard; but string input termination is done when *Return* is pressed. There
    are certain critical situations when *Return* cannot be pressed, but the termination
    is done based on number of characters or a single character. For example, in a
    game a ball is moved up when up + is pressed. Pressing `+` and then pressing *Return*
    everytime to acknowledge the + press is not efficient. The read command provides
    a way to accomplish this task without having to press *Return*.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言中的大多数输入库都是从键盘读取输入；但是当按下*Return*时，字符串输入终止。在某些关键情况下，无法按下*Return*，但终止是基于字符数或单个字符完成的。例如，在游戏中，按下上+时，球会向上移动。每次按下`+`然后按下*Return*来确认+按下是不高效的。`read`命令提供了一种在不必按下*Return*的情况下完成此任务的方法。
- en: How to do it...
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following statement will read "n" characters from input into the variable
    `variable_name`:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句将从输入中读取“n”个字符到变量`variable_name`中：
- en: '`read -n number_of_chars variable_name`'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '`read -n number_of_chars variable_name`'
- en: 'For example:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE150]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Many other options are possible with `read`. Let's see take a look at these.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`还有许多其他选项。让我们看看这些。'
- en: 'Read a password in non-echoed mode as follows:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式以非回显模式读取密码：
- en: '[PRE151]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Display a message with `read` using:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`read`显示消息：
- en: '[PRE152]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Read the input after a timeout as follows:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式在超时后读取输入：
- en: '[PRE153]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'For example:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE154]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Use a delimiter character to end the input line as follows:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 使用分隔符字符来结束输入行，如下所示：
- en: '[PRE155]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'For example:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE156]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Field separators and iterators
  id: totrans-564
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段分隔符和迭代器
- en: The Internal Field Separator is an important concept in shell scripting. It
    is very useful while manipulating text data. We will now discuss delimiters that
    separate different data elements from single data stream. An Internal Field Separator
    is a delimiter for a special purpose. An **Internal Field Separator** (**IFS**)
    is an environment variable that stores delimiting characters. It is the default
    delimiter string used by a running shell environment.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 内部字段分隔符是shell脚本中的一个重要概念。在操作文本数据时非常有用。我们现在将讨论分隔符，它们将不同的数据元素从单个数据流中分隔开。内部字段分隔符是一个特殊目的的分隔符。**内部字段分隔符**（**IFS**）是一个存储分隔字符的环境变量。它是运行shell环境使用的默认分隔符字符串。
- en: Consider the case where we need to iterate through words in a string or **comma
    separated values** (**CSV**). In the first case we will use `IFS=" "` and in the
    second,`IFS=","`. Let's see how to do it.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑需要在字符串或**逗号分隔值**（**CSV**）中迭代单词的情况。在第一种情况下，我们将使用`IFS=" "`，在第二种情况下，`IFS=","`。让我们看看如何做。
- en: Getting ready
  id: totrans-567
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Consider the case of CSV data:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑CSV数据的情况：
- en: '[PRE157]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'The output is as follows:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE158]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: The default value of IFS is a space component (newline, tab, or a space character).
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: IFS的默认值是一个空格组件（换行符、制表符或空格字符）。
- en: When IFS is set as "," the shell interprets the comma as a delimiter character,
    therefore, the `$item` variable takes substrings separated by a comma as its value
    during the iteration.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 当IFS设置为“,”时，shell将逗号解释为分隔符字符，因此在迭代期间，`$item`变量将以逗号分隔的子字符串作为其值。
- en: If IFS were not set as "`,`" then it would print the entire data as a single
    string.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 如果IFS未设置为“`,`”，那么它将打印整个数据作为单个字符串。
- en: How to do it...
  id: totrans-575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Let's go through another example usage of IFS by taking `/etc/passwd` file into
    consideration. In the `/etc/passwd` file, every line contains items delimited
    by `":"`. Each line in the file corresponds to an attribute related to a user.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑`/etc/passwd`文件来看一下IFS的另一个示例用法。在`/etc/passwd`文件中，每一行包含由`":"`分隔的项目。文件中的每一行对应于与用户相关的属性。
- en: 'Consider the input:`root:x:0:0:root:/root:/bin/bash`. The last entry on each
    line specifies the default shell for the user. In order to print users and their
    default shells, we can use the IFS hack as follows:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑输入：`root:x:0:0:root:/root:/bin/bash`。每行的最后一个条目指定用户的默认shell。为了打印用户及其默认shell，我们可以使用IFS
    hack，如下所示：
- en: '[PRE159]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The output will be:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：
- en: '[PRE160]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Loops are very useful in iterating through a sequence of values. Bash provides
    many types of loops. Let's see how to use them.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 循环在迭代一系列值时非常有用。Bash提供了许多类型的循环。让我们看看如何使用它们。
- en: '**For loop**:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '**For循环**：'
- en: '[PRE161]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: We can generate different sequences easily.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松生成不同的序列。
- en: '`echo {1..50}`can generate a list of numbers from 1 to 50'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo {1..50}`可以生成从1到50的数字列表'
- en: '`echo {a..z}`or`{A..Z}` or we can generate partial list using `{a..h}`. Similarly,
    by combining these we can concatenate data.'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo {a..z}`或`{A..Z}`或我们可以使用`{a..h}`生成部分列表。类似地，通过组合这些，我们可以连接数据。'
- en: 'In the following code, in each iteration, the variable `i` will hold a character
    in the range `a` to `z`:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，每次迭代，变量`i`将保存范围为`a`到`z`的字符：
- en: '[PRE162]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'The `for` loop can also take the format of the `for` loop in C. For example:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环也可以采用C语言中的`for`循环格式。例如：'
- en: '[PRE163]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '**While loop**:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '**While循环**：'
- en: '[PRE164]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: For an infinite loop, use `true` as the condition.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无限循环，使用`true`作为条件。
- en: '**Until loop**:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '**Until循环**：'
- en: 'A special loop called `until` is available with Bash. This executes the loop
    until the given condition becomes true. For example:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: Bash中还有一个称为`until`的特殊循环。这将执行循环，直到给定条件成为真。例如：
- en: '[PRE165]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Comparisons and tests
  id: totrans-597
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较和测试
- en: Flow control in a program is handled by comparison and test statements. Bash
    also comes with several options to perform tests that are compatible with the
    UNIX system-level features.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的流程控制由比较和测试语句处理。Bash还提供了几种选项来执行与UNIX系统级特性兼容的测试。
- en: Getting ready
  id: totrans-599
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We can use `if`, `if else`, and logical operators to perform tests and certain
    comparison operators to compare data items. There is also a command called `test`
    available to perform tests. Let's see how to use those commands.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`if`，`if else`和逻辑运算符来执行测试，并使用某些比较运算符来比较数据项。还有一个称为`test`的命令可用于执行测试。让我们看看如何使用这些命令。
- en: How to do it...
  id: totrans-601
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'If condition:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件：
- en: '[PRE166]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'else if and else:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: else if和else：
- en: '[PRE167]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Nesting is also possible with if and else. `if` conditions can be lengthy.
    We can use logical operators to make them shorter as follows:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套也是可能的，使用if和else。`if`条件可能很长。我们可以使用逻辑运算符使它们更短，如下所示：
- en: '[PRE168]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '`&&` is the logical AND operation and `||` is the logical OR operation. This
    is a very helpful trick while writing Bash scripts. Now let''s go into conditions
    and comparisons operations.'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`是逻辑AND操作，`||`是逻辑OR操作。在编写Bash脚本时，这是一个非常有用的技巧。现在让我们进入条件和比较操作。'
- en: '**Mathematical comparisons**:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '**数学比较**：'
- en: 'Usually, conditions are enclosed in square brackets `[]`. Note that there is
    a space between `[` or `]` and operands. It will show an error if no space is
    provided. An example is as follows:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，条件被括在方括号`[]`中。请注意`[`或`]`和操作数之间有一个空格。如果没有提供空格，将会显示错误。示例如下：
- en: '[PRE169]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Performing mathematical conditions over variables or values can be done as
    follows:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按照以下方式执行变量或值的数学条件：
- en: '[PRE170]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Other important operators are:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 其他重要的操作符包括：
- en: '`-gt`: Greater than'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-gt`：大于'
- en: '`-lt`: Less than'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-lt`：小于'
- en: '`-ge`: Greater than or equal to'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ge`：大于或等于'
- en: '`-le`: Less than or equal to'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-le`：小于或等于'
- en: 'Multiple test conditions can be combined as follows:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 多个测试条件可以组合如下：
- en: '[PRE171]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '**Filesystem related tests**:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '**与文件系统相关的测试**：'
- en: 'We can test different filesystem related attributes using different condition
    flags as follows:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用不同的条件标志来测试不同的文件系统相关属性，如下所示：
- en: '`[ -f $file_var ]`: Returns true if the given variable holds a regular filepath
    or filename.'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ -f $file_var ]`: 如果给定的变量保存了常规文件路径或文件名，则返回true。'
- en: '`[ -x $var ]`: Returns true if the given variable holds a file path or filename
    which is executable.'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ -x $var ]`: 如果给定的变量保存了可执行文件路径或文件名，则返回true。'
- en: '`[ -d $var ]`: Returns true if the given variable holds a directory path or
    directory name.'
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ -d $var ]`: 如果给定的变量保存了目录路径或目录名称，则返回true。'
- en: '`[ -e $var ]`: Returns true if the given variable holds an existing file.'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ -e $var ]`: 如果给定的变量保存了一个现有文件，则返回true。'
- en: '`[ -c $var ]`: Returns true if the given variable holds path of a character
    device file.'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ -c $var ]`: 如果给定的变量保存了字符设备文件的路径，则返回true。'
- en: '`[ -b $var ]`: Returns true if the given variable holds path of a block device
    file.'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ -b $var ]`: 如果给定的变量保存了块设备文件的路径，则返回true。'
- en: '`[ -w $var ]`: Returns true if the given variable holds path of a file which
    is writable.'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ -w $var ]`: 如果给定的变量保存了可写文件的路径，则返回true。'
- en: '`[ -r $var ]`: Returns true if the given variable holds path of a file which
    is readable.'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ -r $var ]`: 如果给定的变量保存了可读文件的路径，则返回true。'
- en: '`[ -L $var ]`: Returns true if the given variable holds path of a symlink.'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[ -L $var ]`: 如果给定的变量保存了符号链接的路径，则返回true。'
- en: 'An example of the usage is as follows:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 使用示例如下：
- en: '[PRE172]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '**String comparisons**:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串比较**：'
- en: While using string comparison, it is best to use double square brackets since
    use of single brackets can sometimes lead to errors. Usage of single brackets
    sometimes lead to error. So it is better to avoid them.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用字符串比较时，最好使用双方括号，因为使用单方括号有时会导致错误。有时使用单方括号会导致错误。因此最好避免使用它们。
- en: Two strings can be compared to check whether they are the same as follows;
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 可以比较两个字符串是否相同，如下所示；
- en: '`[[ $str1 = $str2 ]]`: Returns true when str1 equals str2, that is, the text
    contents of str1 and str2 are the same'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[ $str1 = $str2 ]]`: 当str1等于str2时返回true，即str1和str2的文本内容相同'
- en: '`[[ $str1 == $str2 ]]`: It is alternative method for string equality check'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[ $str1 == $str2 ]]`: 这是字符串相等检查的替代方法'
- en: 'We can check whether two strings are not the same as follows:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查两个字符串是否不相同，如下所示：
- en: '`[[ $str1 != $str2 ]]`: Returns true when str1 and str2 mismatches'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[ $str1 != $str2 ]]`: 当str1和str2不匹配时返回true'
- en: 'We can find out the alphabetically smaller or larger string as follows:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以找出字母顺序较小或较大的字符串，如下所示：
- en: '`[[ $str1 > $str2 ]]`: Returns true when str1 is alphabetically greater than
    str2'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[ $str1 > $str2 ]]`: 当str1按字母顺序大于str2时返回true'
- en: '`[[ $str1 < $str2 ]]`: Returns true when str1 is alphabetically lesser than
    str2'
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[ $str1 < $str2 ]]`: 当str1按字母顺序小于str2时返回true'
- en: Note
  id: totrans-644
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that a space is provided after and before `=`. If space is not provided,
    it is not a comparison, but it becomes an assignment statement.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`=`之后和之前都提供了一个空格。如果不提供空格，它不是一个比较，而是一个赋值语句。
- en: '`[[ -z $str1 ]]`: Returns true if str1 holds an empty string'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[ -z $str1 ]]`：如果str1包含空字符串，则返回true'
- en: '`[[ -n $str1 ]]`: Returns true if str1 holds a non-empty string'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[[ -n $str1 ]]`：如果str1包含非空字符串，则返回true'
- en: 'It is easier to combine multiple conditions using the logical operators `&&`
    and `||` as follows:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑运算符`&&`和`||`可以更容易地组合多个条件，如下所示：
- en: '[PRE173]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'For example:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE174]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'The output is as follows:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE175]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: The `test` command can be used for performing condition checks. It helps to
    avoid usage of many braces. The same set of test conditions enclosed within `[]`
    can be used for the test command.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`命令可用于执行条件检查。它有助于避免使用许多大括号。可以在`test`命令中使用相同的一组条件，这些条件被包含在`[]`中。'
- en: 'For example:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE176]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
