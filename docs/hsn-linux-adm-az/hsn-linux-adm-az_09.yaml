- en: 'Chapter 9: Container Virtualization in Azure'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：Azure中的容器虚拟化
- en: 'In *Chapter 2*, *Getting Started with the Azure Cloud*, we started our journey
    in Azure with the creation of our first workload in Azure: the deployment of a
    Linux VM. After that, we covered many aspects of the Linux operating system.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第2章*“开始使用Azure云”中，我们开始了在Azure中的旅程，首先在Azure中部署了我们的第一个工作负载：Linux虚拟机的部署。之后，我们涵盖了Linux操作系统的许多方面。
- en: In *Chapter 7*, *Deploying Your Virtual Machines*, we explored several options
    to deploy your VMs, and *Chapter 8*, *Exploring Continuous Configuration Automation*,
    was all about what to do afterward in terms of configuration management using
    orchestration tooling.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第7章*“部署您的虚拟机”中，我们探讨了部署虚拟机的几种选项，而*第8章*“探索持续配置自动化”则是关于使用编排工具进行配置管理之后要做的事情。
- en: Orchestration is a growing part of a movement called DevOps. DevOps is about
    breaking down the classic silos in an organization. The different teams involved
    in developing, testing, and deploying products must communicate and work together.
    DevOps is a combination of cultural philosophies, practices, and tools. And DevOps
    is a way to make deployments incremental, frequent, and routine events while constraining
    the impact of failure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编排是DevOps运动的一个不断增长的部分。DevOps是打破组织中经典隔离的一部分。参与开发、测试和部署产品的不同团队必须进行沟通和合作。DevOps是文化哲学、实践和工具的结合。DevOps是一种使部署增量、频繁和常规事件的方式，同时限制失败影响的方法。
- en: 'VMs are not the only way to deploy workloads: you can also deploy your workload
    in containers. It makes it possible, together with orchestration, to fulfill DevOps
    requirements.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机不是部署工作负载的唯一方式：您还可以在容器中部署工作负载。它使得与编排一起，可以满足DevOps的要求。
- en: 'So, before we actually learn about and implement containers in Azure, let''s
    quickly have a look at what this chapter has to offer. By the end of this chapter,
    you will:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们实际学习和在Azure中实现容器之前，让我们快速看一下本章提供了什么。在本章结束时，您将：
- en: Understand the history of containers and know the early adoptions of containerization.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解容器的历史，并了解容器化的早期采用情况。
- en: Be familiar with container tools such as `systemd-nspawn` and Docker.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉诸如`systemd-nspawn`和Docker之类的容器工具。
- en: Be able to work with Docker Machine and Docker Compose.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够使用Docker Machine和Docker Compose。
- en: Be able to use Azure Container Instances and Azure Container Registry.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够使用Azure容器实例和Azure容器注册表。
- en: Know about the new generation container tools such as Buildah, Podman, and Skopeo.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解新一代容器工具，如Buildah、Podman和Skopeo。
- en: Now, we'll first understand what a container is and how it has evolved.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们首先要了解容器是什么，以及它是如何发展的。
- en: Introduction to Container Technology
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器技术简介
- en: 'In *Chapter 1*, *Exploring the Azure Cloud*, we had a short introduction to
    containers. So, let''s go ahead and cover containers in more detail. We know that
    VMs are run on a hypervisor, and for each purpose, in most cases you have to create
    a separate VM to isolate the environments. VMs will have a guest OS, such as Linux,
    and on top of that we will install the software we require. There will be scenarios
    where you have to deploy a large number of VMs for testing. If you are using an
    on-premises infrastructure running Hyper-V, you have to think about resource utilization—that
    is, how much memory, CPU, and so on you will use for each VM. If you are deploying
    in Azure, you have to think about the cost as well. You might need some VMs only
    for a couple of hours just to test something, but the footprints of these VMs
    are large; they''re complete computers that are running virtually. Another problem
    is compatibility issues. Let''s assume you have an app that requires a dependency
    package such as Python 2.2\. Now think about another app running in the same VM
    that has compatibility issues with Python 2.2 and can only work with Python 2.1\.
    You would end up creating a new VM for the second app with Python 2.1\. To overcome
    this, containers were introduced. Here is a pictorial representation of how containers
    differ from VMs:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章*“探索Azure云”中，我们简要介绍了容器。因此，让我们继续更详细地介绍容器。我们知道虚拟机是在hypervisor上运行的，并且在大多数情况下，您必须为每个目的创建一个单独的虚拟机来隔离环境。虚拟机将有一个类似Linux的客户操作系统，然后我们将安装所需的软件。在某些情况下，您必须部署大量的虚拟机进行测试。如果您正在使用运行Hyper-V的本地基础设施，您必须考虑资源利用率，即每个虚拟机将使用多少内存、CPU等。如果您在Azure中部署，您还必须考虑成本。您可能只需要一些虚拟机来测试某些东西，但这些虚拟机的占用空间很大；它们实际上是在虚拟运行的完整计算机。另一个问题是兼容性问题。假设您有一个应用程序需要一个依赖包，比如Python
    2.2。现在想象一下在同一个虚拟机中运行另一个应用程序，它与Python 2.2存在兼容性问题，只能使用Python 2.1。您最终将不得不为第二个应用程序创建一个新的虚拟机，其中安装了Python
    2.1。为了克服这个问题，引入了容器。以下是容器与虚拟机有何不同的图示表示：
- en: '![Pictorial representation of VMs differs from Containers](img/B15455_09_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![VMs与容器的图示表示不同](img/B15455_09_01.jpg)'
- en: 'Figure 9.1: Representation of VMs and Containers'
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.1：虚拟机和容器的表示
- en: Like VMs, containers allow you to package your application along with all the
    dependencies and libraries. They are isolated environments like VMs and can be
    used to test and run applications without needing to create multiple VMs. Containers
    are also lightweight.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与虚拟机一样，容器允许您将应用程序与所有依赖项和库打包在一起。它们像虚拟机一样是隔离的环境，可以用于测试和运行应用程序，而无需创建多个虚拟机。容器也很轻量级。
- en: Instead of virtualizing each hardware component as with the VMs, containers
    virtualize at the OS level. This means that the containers have a smaller footprint
    than VMs. For example, an Ubuntu ISO image will have a size close to 2.4 GB; on
    the other hand, an Ubuntu container image is less than 200 MB. Let's consider
    the previous example, where we had dependency issues with Python 2.2 and ended
    up creating two VMs. With containers, we can have two containers with a much smaller
    footprint than two VMs. Also, the cost and resource utilization of the host OS
    is far less than that of two VMs. Containers are deployed using a container runtime;
    there are different runtimes available. In this chapter, we will take a look at
    the popular container runtimes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与虚拟机不同，容器是在操作系统级别进行虚拟化的，而不是每个硬件组件都进行虚拟化。这意味着容器的占用空间比虚拟机小。例如，Ubuntu ISO镜像的大小接近2.4
    GB；另一方面，Ubuntu容器镜像小于200 MB。考虑之前的例子，我们在Python 2.2上有依赖问题，最终创建了两个虚拟机。使用容器，我们可以有两个占用空间比两个虚拟机小得多的容器。此外，主机操作系统的成本和资源利用远远低于两个虚拟机。容器使用容器运行时部署；有不同的运行时可用。在本章中，我们将看一下流行的容器运行时。
- en: 'A container is not the Holy Grail. It doesn''t fix all your problems. However,
    you can consider the following scenarios, and if any of them match your requirements,
    you might want to containerize your application:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 容器不是圣杯。它不能解决您所有的问题。但是，您可以考虑以下情景，如果它们中的任何一个符合您的要求，您可能希望将应用程序容器化：
- en: There is a need for applications that often need updates with new features,
    preferably without downtime, driven by business needs.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序经常需要更新新功能，最好无需停机，这是由业务需求驱动的。
- en: System engineers and developers can work together to address the business needs
    and have enough understanding and knowledge of each other's domains (without being
    a specialist in both), and have a culture of continual experimentation and learning.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统工程师和开发人员可以共同解决业务需求，并对彼此的领域有足够的理解和知识（而不必成为两者的专家），并且具有持续实验和学习的文化。
- en: There is room for failure in order to make the application better.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使应用程序更好，需要有失败的空间。
- en: The application is not a single point of failure.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序不是单点故障。
- en: The application is not a critical application in terms of availability and security.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序在可用性和安全性方面不是关键应用程序。
- en: 'One other little thing: if you have many different types of applications and
    there is almost no code shared between those applications, container technology
    is still an option, but it''s possible that VMs are a better solution in this
    scenario.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件小事：如果您有许多不同类型的应用程序，并且这些应用程序之间几乎没有共享的代码，容器技术仍然是一个选择，但在这种情况下，虚拟机可能是更好的解决方案。
- en: 'We''ll cover a little bit of the history of container technology to give you
    a better understanding of where it comes from. We''ll explore some of the solutions
    available today: systemd-nspawn and Docker. There are more container virtualization
    implementations available, even some of the earliest implementations, such as
    LXC. In fact, it doesn''t matter which containerization tool you''re using: if
    you understand the ideas and concepts behind containers, it''s easy to implement
    the same ideas and concepts with other tools. The only thing that changes is the
    command; the underlying concepts for all these tools are the same.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将简要介绍容器技术的历史，以便让您更好地了解其来源。我们将探讨当今提供的一些解决方案：systemd-nspawn和Docker。甚至有更多的容器虚拟化实现可用，甚至一些最早的实现，比如LXC。实际上，无论您使用哪种容器化工具：如果您了解容器背后的思想和概念，就很容易使用其他工具实现相同的思想和概念。唯一改变的是命令；所有这些工具的基本概念都是相同的。
- en: History of Containers
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器的历史
- en: Containers are very popular nowadays. But they are not new; they didn't come
    out of the blue. It's not easy to point to an exact time when they started. We
    don't want to give you a history lesson, but history can give you an understanding
    of the technology and even give you a clue as to why or when you should use containers
    in your organization.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 容器现在非常流行。但它们并不新；它们不是突然出现的。很难指出它们开始的确切时间。我们不想给您历史课，但历史可以让您了解技术，甚至可以让您了解为什么或何时应该在组织中使用容器。
- en: 'So, instead of focusing on an exact timeline, we''ll only cover the important
    steps: the implementation of technologies that are important if you want to understand
    container technology as it is today.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不会专注于确切的时间轴，我们只会涵盖重要的步骤：实施如果您想了解当今容器技术的重要技术。
- en: '**The chroot Environment**'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**chroot环境**'
- en: In Linux, there is a root filesystem, as covered in *Chapter 5*, *Advanced Linux
    Administration*, and everything is mounted to that filesystem, which will be visible
    to the currently running processes and their children.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，有一个根文件系统，如*第5章* *高级Linux管理*中所述，一切都挂载到该文件系统上，这将对当前运行的进程及其子进程可见。
- en: 'A process running in `chroot` has its own root filesystem, fully separated
    from the system-wide root, known as `fs.chroot`. It is often used in development
    as the program running in `chroot` cannot access files or commands outside its
    root filesystem. To start a chroot jail from a directory, execute the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chroot`中运行的进程有自己的根文件系统，与系统范围的根完全分离，称为`fs.chroot`。它经常用于开发，因为在`chroot`中运行的程序无法访问其根文件系统之外的文件或命令。要从目录启动chroot监狱，请执行以下操作：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In 1979, the `chroot` system call was introduced in version 7 of Unix, and in
    1982, it was introduced in BSD Unix. Linux has implemented this system call since
    the early days of its existence.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 1979年，在Unix的第7版中引入了`chroot`系统调用，并在1982年引入了BSD Unix。Linux自其存在的早期就实现了这个系统调用。
- en: '**OpenVZ**'
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**OpenVZ**'
- en: In 2005, almost at the same time that Solaris started its container technology,
    a company called Virtuozzo started the OpenVZ project.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 2005年，几乎与Solaris启动其容器技术同时，一家名为Virtuozzo的公司启动了OpenVZ项目。
- en: 'They took the principle of the chroot environment and applied it to other resources.
    A chroot process will have the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 他们采用了chroot环境的原则，并将其应用于其他资源。chroot进程将具有以下内容：
- en: A root filesystem
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根文件系统
- en: Users and groups
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户和组
- en: Devices
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备
- en: A process tree
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个进程树
- en: A network
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个网络
- en: Interprocess communication objects
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程间通信对象
- en: At that time, OpenVZ was seen as a lightweight alternative to virtualization
    based on a hypervisor, and also as a solid platform for developers. It still exists,
    and you can use it on top of every Linux operating system, running in the cloud
    or not.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当时，OpenVZ被视为基于hypervisor的虚拟化的轻量级替代方案，也被视为开发人员的坚实平台。它仍然存在，并且您可以在任何Linux操作系统上使用它，无论是在云中还是不在云中。
- en: 'Using OpenVZ is similar to using a VM: you create an image with a base installation
    of your favorite distribution and, if you want, after that you can use orchestration
    to install the application and maintain everything.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenVZ类似于使用虚拟机：您可以创建一个带有您喜欢的发行版基本安装的映像，之后您可以使用编排来安装应用程序并维护一切。
- en: '**LXC**'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**LXC**'
- en: In 2006, engineers at Google started working on a feature in the Linux kernel
    called **cgroups** (**control groups**) to enable resource control on resources
    such as CPU, memory, disk I/O, and the network for collections of processes (resource
    groups).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 2006年，Google的工程师开始在Linux内核中开发一个名为**cgroups**（**控制组**）的功能，以便对进程集合（资源组）上的CPU、内存、磁盘I/O和网络等资源进行资源控制。
- en: A related feature of the Linux kernel is the concept of `cgroups` became a namespace.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核的一个相关特性是`cgroups`的概念成为了一个命名空间。
- en: 'In 2008, `cgroups` was merged into the Linux kernel and a new namespace was
    introduced, the `user` namespace. Both technologies were then enabled for a new
    step forward for containers: LXC.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 2008年，`cgroups`被合并到Linux内核中，并引入了一个新的命名空间，即`user`命名空间。然后，这两种技术为容器的新步骤——LXC启用了。
- en: Other available namespaces are `pid`, `mount`, `network`, `uts` (own domain
    name), and `ipc`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可用的命名空间包括`pid`、`mount`、`network`、`uts`（自己的域名）和`ipc`。
- en: 'There is no longer any need to keep up to date with Linux kernel development:
    every component needed is available, and there is much better resource management.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不再需要跟踪Linux内核的开发情况：每个所需的组件都可用，并且资源管理更加出色。
- en: 'Recently, Canonical developed a new container manager called the LXD, which
    has LXC in its backend and aims to provide an improved user experience for managing
    containers. Technically, LXD uses LXC through liblxc and its Go binding to achieve
    this aim. Some advantages of LXD are listed here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，Canonical开发了一个名为LXD的新容器管理器，它在其后端使用LXC，并旨在提供改进的用户体验来管理容器。从技术上讲，LXD使用LXC通过liblxc和其Go绑定来实现这一目标。以下列出了LXD的一些优点：
- en: Secure
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全
- en: Highly scalable
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度可扩展
- en: Simplifies resource sharing
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化资源共享
- en: systemd-nspawn
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: systemd-nspawn
- en: systemd comes with a container solution. It started as an experiment, and then
    Lennart Poettering considered it ready for production. It is, in fact, the base
    for another solution, Rkt. At the time of writing this book, Rkt development has
    stopped. However, you can still access the Rkt GitHub repository ([https://github.com/rkt/rkt](https://github.com/rkt/rkt)).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: systemd带有一个容器解决方案。它起初是一个实验，然后Lennart Poettering认为它已经准备好投入生产。实际上，它是另一个解决方案Rkt的基础。在撰写本书时，Rkt的开发已经停止。但是，您仍然可以访问Rkt
    GitHub存储库（[https://github.com/rkt/rkt](https://github.com/rkt/rkt)）。
- en: systemd-nspawn is not very well known, but it is a powerful solution that is
    available on every modern Linux system. It is built on top of the kernel namespaces
    and systemd for management. It's a sort of chroot on steroids.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: systemd-nspawn并不是很出名，但它是一种强大的解决方案，可在每个现代Linux系统上使用。它建立在内核命名空间和systemd之上进行管理。这是一种类似于增强版的chroot。
- en: 'If you want to learn more about the underlying technologies of containers,
    systemd-nspawn is a good start. Here, every component is visible and can be configured
    manually if you want. The downside of systemd-nspawn is that you have to do everything
    on your own, from creating the image, to orchestration, to high availability:
    it''s all possible, but you have to build it.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于容器底层技术的知识，systemd-nspawn是一个很好的起点。在这里，每个组件都是可见的，如果您愿意，可以手动配置。systemd-nspawn的缺点是您必须自己完成所有工作，从创建映像到编排再到高可用性：这一切都是可能的，但您必须自己构建。
- en: Containers can also be created using package managers such as `yum` and by extracting
    raw cloud images (several distributions provide such images, such as [https://cloud.centos.org/centos/7/images](https://cloud.centos.org/centos/7/images)
    and [https://cloud-images.ubuntu.com/](https://cloud-images.ubuntu.com/)). You
    can even use Docker images!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 容器也可以使用诸如`yum`之类的软件包管理器创建，并通过提取原始云映像（几个发行版提供此类映像，例如[https://cloud.centos.org/centos/7/images](https://cloud.centos.org/centos/7/images)和[https://cloud-images.ubuntu.com/](https://cloud-images.ubuntu.com/)）。您甚至可以使用Docker映像！
- en: 'As stated, there are multiple ways to create a container. As an example, we''ll
    cover two of them: `debootstrap` and `yum`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，有多种方法可以创建容器。例如，我们将介绍其中的两种：`debootstrap`和`yum`。
- en: Creating a Container with debootstrap
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用debootstrap创建容器
- en: The `debootstrap` utility is a tool that will install a Debian- or Ubuntu-based
    system into a subdirectory of another already installed system. It is available
    in the repositories of SUSE, Debian, and Ubuntu; on CentOS or other Red Hat–based
    distributions, you'll need to pull it from the **Extra Packages for Enterprise
    Linux** (**EPEL**) repository.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`debootstrap`实用程序是一个工具，可以将基于Debian或Ubuntu的系统安装到已安装系统的子目录中。它在SUSE、Debian和Ubuntu的存储库中可用；在CentOS或其他基于Red
    Hat的发行版上，您需要从**企业Linux的额外软件包**（**EPEL**）存储库中获取它。'
- en: As an example, let's bootstrap Debian on a CentOS machine to create a template
    for our systemd containers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们在CentOS机器上引导Debian，以创建我们的systemd容器的模板。
- en: 'For the purposes of this chapter, if you are running on CentOS, you have to
    change the security label for systemd-nspawn:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，如果您正在运行CentOS，您必须更改systemd-nspawn的安全标签：
- en: '[PRE1]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First, install debootstrap:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，安装debootstrap：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a subdirectory:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个子目录：
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And bootstrap, for instance, from the US mirror of Debian:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从Debian的美国镜像引导：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating a Container with yum
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用yum创建容器
- en: The `yum` utility is available in every repository and can be used to create
    a container with a Red Hat–based distribution.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`yum`实用程序在每个存储库中都可用，并且可用于创建具有基于Red Hat的发行版的容器。'
- en: 'Let''s go through the steps to create a CentOS 7 container:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看创建CentOS 7容器的步骤：
- en: 'Create a directory in which we''re going to install CentOS, and that will be
    used for our template:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个目录，我们将在其中安装CentOS，并将其用作我们的模板：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, you have to download the `centos-release rpm` package at [http://mirror.centos.org/centos-7/7/os/x86_64/Packages/](http://mirror.centos.org/centos-7/7/os/x86_64/Packages/).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您必须在[http://mirror.centos.org/centos-7/7/os/x86_64/Packages/](http://mirror.centos.org/centos-7/7/os/x86_64/Packages/)下载`centos-release
    rpm`软件包。
- en: 'Initialize the `rpm` database and install this package:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化`rpm`数据库并安装此软件包：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now you are ready to install at least the bare minimum:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经准备好至少安装最低限度的内容了：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After the installation of the packages, a complete root filesystem is available,
    providing everything that is needed to boot the container. You can also use this
    root filesystem as a template; in that scenario, you need to modify the template
    to make sure that every container is unique.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 安装软件包后，将可用完整的根文件系统，提供启动容器所需的一切。您还可以使用此根文件系统作为模板；在这种情况下，您需要修改模板以确保每个容器都是唯一的。
- en: systemd-firstboot
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: systemd-firstboot
- en: 'systemd-firstboot is a nice way to configure a few things if you start the
    container for the first time. You can configure the following parameters:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: systemd-firstboot是在首次启动容器时配置一些内容的好方法。您可以配置以下参数：
- en: System locale (`--locale=`)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统区域设置（`--locale=`）
- en: System keyboard map (`--keymap=`)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统键盘映射（`--keymap=`）
- en: System time zone (`--timezone=`)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统时区（`--timezone=`）
- en: System hostname `(--hostname=`)
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统主机名（`--hostname=`）
- en: Machine ID of the system (`--machine-id=`)
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统的机器ID（`--machine-id=`）
- en: Root user's password (`--root-password=`)
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Root用户的密码（`--root-password=`）
- en: You can also use the `-prompt` parameter to ask for these parameters at first
    boot.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`-prompt`参数在首次启动时请求这些参数。
- en: In the following example, we will be modifying the systemd-firstboot unit to
    pass a configuration that is going to be executed when the container is run for
    the first time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将修改`systemd-firstboot`单元，以传递在首次运行容器时将执行的配置。
- en: 'Execute `chroot` in the container directory. Let''s take our CentOS image as
    an example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器目录中执行`chroot`。让我们以我们的CentOS镜像为例：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Fire up the image:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 启动镜像：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Open the systemd-firstboot unit, `/usr/lib/systemd/system/systemd-firstboot.service`,
    and modify it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`systemd-firstboot`单元，`/usr/lib/systemd/system/systemd-firstboot.service`，并对其进行修改：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Enable the service:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 启用服务：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Clean up the settings:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 清理设置：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Exit the chroot environment with *Ctrl* + *D*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *D*退出chroot环境。
- en: Deploying the First Container
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署第一个容器
- en: 'If you are using the BTRFS filesystem template directory as a subvolume, you
    can use the `--template` parameter of systemd-nspawn. Otherwise, it will create
    a new subvolume:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用BTRFS文件系统模板目录作为子卷，可以使用`systemd-nspawn`的`--template`参数。否则，它将创建一个新的子卷：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It''s time to boot our first container:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候启动我们的第一个容器了：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Try to log in and kill it with *Ctrl* + *]]]*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试登录并使用*Ctrl* + *]]]*杀死它。
- en: 'From now on, you can manage the containers with the `machinectl` command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，您可以使用`machinectl`命令管理容器：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Log in with the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下登录：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are many other parameters of `machinectl` that are worth investigating!
    If you get a permission-denied message, think about SELinux troubleshooting! Also,
    `journalctl` has a `-M` parameter to see the logging within the container, or
    use the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`machinectl`还有许多其他参数值得研究！如果收到权限被拒绝的消息，请考虑SELinux故障排除！此外，`journalctl`有一个`-M`参数，用于查看容器内的日志，或者使用以下命令：'
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you execute `hostnamectl` in the container, you''ll see something similar
    to the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在容器中执行`hostnamectl`，您将看到类似以下内容：
- en: '![Detailed output of the hostnamectl command](img/B15455_09_02.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![hostnamectl命令的详细输出](img/B15455_09_02.jpg)'
- en: 'Figure 9.2: Output of the hostnamectl command'
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.2：hostnamectl命令的输出
- en: The kernel is the one of the host!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 内核是主机的内核！
- en: Enabling a Container at Boot Time
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在启动时启用容器
- en: 'To make a container available at boot time, enable the target, `machines.target`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要使容器在启动时可用，请启用目标`machines.target`：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now create a `nspawn` file for our container: `/etc/systemd/nspawn/centos01.nspawn`.
    The filename must be the same as the container:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为我们的容器创建一个`nspawn`文件：`/etc/systemd/nspawn/centos01.nspawn`。文件名必须与容器相同：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`[Network]` also sets up port forwarding from TCP port `80` in the container
    to port `80` on the host. You have to configure an IP address on the network interface
    in the container and on the host on the virtual Ethernet interface in the subnet
    to make it work.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`[Network]`还设置了从容器的TCP端口`80`到主机的端口`80`的端口转发。您必须在容器中的网络接口上配置IP地址，并在子网中的虚拟以太网接口上配置主机上的IP地址，以使其正常工作。'
- en: 'Now enable the VM:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启用VM：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that you know how to work with systemd-nspawn and deploy your container,
    let''s go ahead and discuss the most popular containerization tool: Docker. You
    might have heard a lot about Docker, so let''s get started!'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何使用`systemd-nspawn`并部署您的容器，让我们继续讨论最流行的容器化工具：Docker。您可能已经听说过很多关于Docker的事情，所以让我们开始吧！
- en: Docker
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker
- en: In March 2010, Solomon Hykes started the development of Docker. It started in
    France as an internal dotCloud. Thanks to the public release at a big Python conference
    in 2013 and the interest of Red Hat, Docker really took off. In the last quarter
    of that same year, the name of the company was changed to Docker Inc.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年3月，Solomon Hykes开始开发Docker。它在法国作为内部dotCloud开始。由于2013年在一次大型Python会议上的公开发布以及Red
    Hat的兴趣，Docker真正起飞。在同年的最后一个季度，公司的名称更改为Docker Inc。
- en: Docker was originally built on top of LXC but after a while, LXC was replaced
    by their own `libcontainer` library.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Docker最初是建立在LXC之上的，但过了一段时间，LXC被他们自己的`libcontainer`库所取代。
- en: 'The architecture of Docker is quite complex: it consists of a client, Docker,
    and a daemon, `dockerd`. Another daemon, `containerd`, is an abstraction layer
    for the OS and the type of container technology that is being used. You can interact
    with `containerd` using the `docker- containerd-ctr` utility. The `containerd`
    daemon is responsible for the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的架构非常复杂：它由客户端、Docker和守护进程`dockerd`组成。另一个守护进程`containerd`是操作系统和正在使用的容器技术类型的抽象层。您可以使用`docker-containerd-ctr`工具与`containerd`进行交互。`containerd`守护进程负责以下内容：
- en: The registry (where you can store images)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册表（您可以存储镜像的地方）
- en: The image (building, metadata, and so on)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像（构建、元数据等）
- en: Networking
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络
- en: Volumes (to store persistent data)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷（用于存储持久数据）
- en: Signing (trust on content)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名（内容的信任）
- en: '`containerd` communicates with RunC, which is responsible for the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`containerd`与RunC通信，RunC负责以下内容：'
- en: Life cycle management
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期管理
- en: Runtime information
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时信息
- en: Running commands within the container
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器内运行命令
- en: Generating the specs (image ID, tags, and so on)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成规格（镜像ID、标签等）
- en: There are two editions of Docker available—**Docker Community Edition** (**CE**)
    and **Docker Enterprise Edition** (**EE**). Docker EE was sold to Mirantis by
    Docker Inc in November 2019; however, Docker CE is still handled by Docker Inc.
    Docker EE adds Docker support, but also an integrated security framework, certified
    plugins, support for Docker Swarm (which is a container orchestration solution
    like Kubernetes), and support for RBAC/AD/LDAP. All of this comes at a price,
    though. If you feel like your environment needs these added advantages, it's worth
    paying for. On the other hand, Docker CE is open-source software that is available
    for free.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Docker有两个版本可用——**Docker社区版**（**CE**）和**Docker企业版**（**EE**）。Docker EE于2019年11月由Docker
    Inc出售给Mirantis；然而，Docker CE仍由Docker Inc处理。Docker EE增加了Docker支持，还有集成的安全框架，认证插件，对Docker
    Swarm（类似于Kubernetes的容器编排解决方案）的支持，以及对RBAC/AD/LDAP的支持。然而，所有这些都是需要付费的。如果您觉得您的环境需要这些额外的优势，那么值得付费。另一方面，Docker
    CE是开源软件，可以免费使用。
- en: Docker Installation
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker安装
- en: There are multiple ways to install and use Docker CE in Azure. You can install
    a Linux distribution of your choice and install Docker on top of it. There are
    several VMs available in the Azure Marketplace, such as RancherOS, which is a
    very minimal Linux distribution that was specially created to run Docker. And,
    last but not least, there is the Docker for Azure template, which is provided
    by Docker at [https://docs.docker.com/docker-for-azure](https://docs.docker.com/docker-for-azure)
    and [https://docs.docker.com/docker-for-azure](https://docs.docker.com/docker-for-azure).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure中有多种安装和使用Docker CE的方法。您可以安装您选择的Linux发行版，并在其上安装Docker。Azure Marketplace中提供了几个VM，如RancherOS，这是一个非常精简的Linux发行版，专门用于运行Docker。最后但同样重要的是，还有Docker
    for Azure模板，由Docker提供，网址为[https://docs.docker.com/docker-for-azure](https://docs.docker.com/docker-for-azure)和[https://docs.docker.com/docker-for-azure](https://docs.docker.com/docker-for-azure)。
- en: 'For the purposes of this chapter, the Docker on Ubuntu Server VM is absolutely
    not a bad idea; it saves a lot of work! But there are several reasons not to use
    this VM:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的目的，Ubuntu服务器VM上的Docker绝对不是一个坏主意；它可以节省很多工作！但是有几个原因不使用这个VM：
- en: It really can help to understand things better if you configure everything yourself.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您自己配置一切，确实可以帮助更好地理解事物。
- en: The software used is relatively old.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的软件相对较旧。
- en: The Docker VM extension that is used to create the VM is deprecated and not
    in active development any longer.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于创建VM的Docker VM扩展已被弃用，不再处于活跃开发状态。
- en: The Docker for Azure template also installs and configures Docker Swarm, a Docker-native
    clustering system.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Docker for Azure模板还安装并配置了Docker Swarm，这是一个Docker本地的集群系统。
- en: The Docker website provides excellent documentation about how to install Docker
    manually. If you would like to install using `apt` or `yum` without following
    the script, you can follow the official Docker documentation ([https://docs.docker.com/v17.09/engine/installation/#supported-platforms](https://docs.docker.com/v17.09/engine/installation/#supported-platforms)).
    If you are following that, then you can skip the `cloud-init` script.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Docker网站提供了关于如何手动安装Docker的优秀文档。如果您想使用`apt`或`yum`进行安装而不是按照脚本，可以按照官方Docker文档进行操作（[https://docs.docker.com/v17.09/engine/installation/#supported-platforms](https://docs.docker.com/v17.09/engine/installation/#supported-platforms)）。如果您按照这个方法操作，可以跳过`cloud-init`脚本。
- en: Here, we'll follow the installation via our script. Please note that this script
    is convenient for lab environments, but not for production environments.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将按照我们的脚本进行安装。请注意，这个脚本对实验环境很方便，但不适用于生产环境。
- en: It installs the latest version of Docker from the Edge channel, not from the
    Stable channel. In theory, this could be a little bit unstable.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它从Edge渠道安装最新版本的Docker，而不是从Stable渠道。理论上，这可能会有点不稳定。
- en: However, for the purposes of this chapter, it's a good way to get started. To
    get things up and running very quickly, let's use the technique of cloud-init
    that we learned in *Chapter 7, Deploying Your Virtual Machines*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于本章的目的，这是一个很好的开始方式。为了快速启动和运行，让我们使用*第7章，部署您的虚拟机*中学到的cloud-init技术。
- en: 'Start by creating a new resource group, for instance, `Docker_LOA`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的资源组，例如`Docker_LOA`：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a cloud-init configuration file; in my example, the file is named `docker.yml`
    with the following content:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个cloud-init配置文件；在我的示例中，文件名为`docker.yml`，内容如下：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Don't forget to replace `<ssh user>` with the login name of the account you're
    using to execute the `az` command.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记用您用于执行`az`命令的帐户的登录名替换`<ssh user>`。
- en: 'You might have noticed that we added `ExecStart` twice in the script. ExecStart
    allows you to specify what command needs to be run when a unit is started. It''s
    a good practice to clear it by setting `ExecStart=` and then specifying the actual
    command in the second line. The reason is that when Docker is installed, it will
    have an `ExecStart` value initially and when we supply another value, it will
    lead to a conflict. This conflict will stop the service from starting. Let''s
    go ahead and create a VM with Docker installed using the cloud-init file we created:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们在脚本中添加了 `ExecStart` 两次。ExecStart 允许你指定在启动单元时需要运行的命令。通过设置 `ExecStart=`
    并在第二行指定实际命令，可以清除它是一个好习惯。原因是当 Docker 安装时，它将最初具有 `ExecStart` 值，当我们提供另一个值时，将导致冲突。这种冲突将阻止服务启动。让我们继续使用我们创建的
    cloud-init 文件创建一个安装了 Docker 的虚拟机：
- en: 'Create a VM with the distribution of your choice:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个安装了你选择的发行版的虚拟机：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When the VM is ready, log in and execute the following:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当虚拟机准备就绪后，登录并执行以下操作：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you get a message that says "`Warning: docker.service changed on disk, run
    systemctl daemon-reload to reload docker.service`," be patient, cloud-init is
    still busy. Also, if you see that `docker.service` is not found, allow some time
    for cloud-init to finish the installation. You can always verify if the Docker
    CE is installed by executing `dpkg -l | grep docker`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你收到一条消息说 "`Warning: docker.service changed on disk, run systemctl daemon-reload
    to reload docker.service`"，请耐心等待，cloud-init 仍在忙碌。另外，如果你看到 `docker.service` 未找到，请等待一段时间让
    cloud-init 完成安装。你可以通过执行 `dpkg -l | grep docker` 来验证 Docker CE 是否已安装。'
- en: 'Execute the following to receive even more information about the Docker daemon:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令以获取有关 Docker 守护程序的更多信息：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It''s time to download our first container and run it:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候下载我们的第一个容器并运行它了：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the following screenshot, you can see that the container was run successfully
    and you received a `Hello from Docker!` message:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，你可以看到容器成功运行，并收到了 `Hello from Docker!` 消息：
- en: '![Successful execution of the container using docker run hello-world command](img/B15455_09_03.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![使用 docker run hello-world 命令成功执行容器](img/B15455_09_03.jpg)'
- en: 'Figure 9.3: Successful container execution'
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9.3：成功执行容器
- en: 'A Docker container is an executed image. To list the available images on your
    system, execute the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器是一个执行的镜像。要列出系统中可用的镜像，请执行以下操作：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the previous example, we ran `docker run hello-world`. So, the image is
    already pulled in and you can see that the `hello-world` image is listed when
    we use the `docker image ls` command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们运行了 `docker run hello-world`。因此，镜像已经被拉取，并且当我们使用 `docker image ls`
    命令时，你可以看到 `hello-world` 镜像被列出来了：
- en: '![Listing the hello-world image by using the docker image'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用 docker image 列出 hello-world 镜像](img/B15455_09_04.jpg)'
- en: ls command](img/B15455_09_04.jpg)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ls 命令](img/B15455_09_04.jpg)
- en: 'Figure 9.4: Listing the Docker image'
  id: totrans-179
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 9.4：列出 Docker 镜像
- en: If you execute `docker run hello-world` again, this time the image will not
    be downloaded. Instead, it will go for the image that was already stored or downloaded
    during the previous run.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次执行 `docker run hello-world`，这次镜像将不会被下载。相反，它将使用在上一次运行期间已经存储或下载的镜像。
- en: 'Let''s download another image:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们下载另一个镜像：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After that, we''ll list all containers, even those that are not running:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将列出所有容器，即使那些未运行的：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'All containers have the `exited` status. If you want to keep the container
    running, you have to add the `-dt` parameters to the run command; `-d` means run
    as detached:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 所有容器都具有 `exited` 状态。如果你想保持容器运行，你必须在运行命令中添加 `-dt` 参数；`-d` 表示分离运行：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you want an interactive shell to the Ubuntu container (as you SSH to a VM),
    you can add the `-i` parameter:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个交互式 shell 到 Ubuntu 容器（就像你 SSH 到一个虚拟机一样），你可以添加 `-i` 参数：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Verify that it is running by viewing the process list again:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过再次查看进程列表来验证它是否正在运行：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Using the container ID or name, you can execute a command in a container and
    receive the standard output in your Terminal:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器的 ID 或名称，你可以在容器中执行命令，并在终端中接收标准输出：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For instance, you can execute the following command to see the OS release of
    the container image:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以执行以下命令来查看容器镜像的操作系统版本：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Attach to the container to verify whether the content is as expected:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到容器以验证内容是否符合预期：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: And detach using *Ctrl* + *P* and *Ctrl* + *Q*, which means that you will exit
    from the interactive shell and the container will start running in the background.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用 *Ctrl* + *P* 和 *Ctrl* + *Q* 分离，这意味着你将退出交互式 shell，容器将在后台运行。
- en: To conclude, if you have been following along, by this time, you will be able
    to run containers, run them as detached, execute commands to the container from
    the host machine, and also get an interactive shell to the container. So far,
    we have used images that are already available in Docker Hub. In the next section,
    we will learn how to build our own Docker images with custom configurations from
    a base image.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，如果你一直在跟着做，到目前为止，你将能够运行容器，将它们作为分离运行，从主机机器执行容器命令，以及获取容器的交互式 shell。到目前为止，我们已经使用了
    Docker Hub 中已经可用的镜像。在下一节中，我们将学习如何从基础镜像构建自己的 Docker 镜像。
- en: Building Docker Images
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像
- en: A Docker image contains layers. For every command you run to add a component
    to the container, a layer is added. Each container is an image with read-only
    layers and a writable layer on top of that. The first layer is the boot filesystem
    and the second is called the base; it contains the OS. You can pull images from
    the Docker Registry (you'll find out more about the Registry later on) or build
    them yourself.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像包含层。对于你运行的每个命令来向容器添加组件，都会添加一个层。每个容器都是一个具有只读层和可写层的镜像。第一层是引导文件系统，第二层称为基础层；它包含操作系统。你可以从
    Docker Registry 拉取镜像（稍后你将了解更多关于 Registry 的信息），或者自己构建镜像。
- en: 'If you want to build one yourself, you can do so in a similar way to what we
    saw earlier on, with systemd-nspawn containers, for instance, by using debootstrap.
    Most of the commands require root user access, so escalate your privileges as
    follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想自己构建一个，可以以类似的方式进行，就像我们之前看到的那样，使用systemd-nspawn容器，例如，通过使用debootstrap。大多数命令需要root用户访问权限，因此请按以下方式提升您的权限：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s take Debian as the base image here. This will help you understand the
    `docker import` command. Download and extract Debian Stretch:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以Debian作为基本镜像。这将帮助您了解`docker import`命令。下载并提取Debian Stretch：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create a tarball and import it directly into Docker:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个tarball并将其直接导入Docker：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Verify it using the following command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令进行验证：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Docker also provides a very minimal base image called `scratch`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Docker还提供了一个名为`scratch`的非常小的基本镜像。
- en: 'A Docker image is built from a Dockerfile. Let''s create a working directory
    to save the Dockerfile:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像是从Dockerfile构建的。让我们创建一个工作目录来保存Dockerfile：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As the `stretch` image is already available in Docker Hub, it''s a good idea
    to tag your image with a new name so that Docker will not try to pull the image,
    but rather go for the local image. To tag the image, use the following command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`stretch`镜像已经在Docker Hub中可用，因此最好使用新名称标记您的镜像，以便Docker不会尝试拉取镜像，而是选择本地镜像。要标记镜像，请使用以下命令：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, create a Dockerfile by executing `vi Dockerfile` (you can use any text
    editor). The first line in this file adds the base image as a layer:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过执行`vi Dockerfile`（您可以使用任何文本编辑器）创建一个Dockerfile。此文件中的第一行将基本镜像添加为一个层：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The second layer contains Debian updates:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第二层包含Debian更新：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The third layer contains the Apache installation:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第三层包含Apache安装：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add the latest layer and run Apache in this read/write layer. `CMD` is used
    to specify the defaults for executing the container:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 添加最新的层并在这个读/写层中运行Apache。`CMD`用于指定执行容器的默认值：
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Open port `80`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 打开端口`80`：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Save the file and your file entries will look like the following screenshot.
    Adding comments is a good practice; however, it''s optional:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，您的文件条目将如下截图所示。添加注释是一个好习惯；但是，这是可选的：
- en: '![Docker image creation using cat Dockerfile](img/B15455_09_05.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![使用cat Dockerfile创建Docker镜像](img/B15455_09_05.jpg)'
- en: 'Figure 9.5: Creating a Docker image'
  id: totrans-226
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.5：创建Docker镜像
- en: 'Build the container:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 构建容器：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If everything went well, the output should show something similar to the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，输出应该显示类似于以下内容：
- en: '![Output representing successfully built Docker image](img/B15455_09_06.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![表示成功构建Docker镜像的输出](img/B15455_09_06.jpg)'
- en: 'Figure 9.6: Docker image built successfully'
  id: totrans-231
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.6：成功构建Docker镜像
- en: 'You can test the container:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以测试容器：
- en: '[PRE48]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Review the history of the build:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 查看构建历史：
- en: '[PRE49]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As shown in the following screenshot, you''ll be able to see the history of
    the build for your container:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，您将能够查看容器的构建历史：
- en: '![Detailed output displaying the history of the built container ](img/B15455_09_07.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![显示构建容器的详细输出](img/B15455_09_07.jpg)'
- en: 'Figure 9.7: Reviewing the history of the container built'
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.7：审查构建的容器历史
- en: 'Execute `docker ps` to get the ID of the container, and use that to collect
    information about the container:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`docker ps`以获取容器的ID，并使用该ID收集有关容器的信息：
- en: '[PRE50]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the output, you can find the IP address of the container:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，您可以找到容器的IP地址：
- en: '![Output of the IP address of the container](img/B15455_09_08.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![容器的IP地址输出](img/B15455_09_08.jpg)'
- en: 'Figure 9.8: Fetching the IP address of the Docker'
  id: totrans-243
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.8：获取Docker的IP地址
- en: 'Use `curl` to see whether the web server is really running:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`curl`查看Web服务器是否真的在运行：
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You will be able to see the famous "It works" page in HTML as shown here:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您将能够在此处看到著名的HTML“它起作用”页面：
- en: '![Testing the web server using curl command](img/B15455_09_09.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![使用curl命令测试Web服务器](img/B15455_09_09.jpg)'
- en: 'Figure 9.9: Using the curl command to test the web server'
  id: totrans-248
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.9：使用curl命令测试Web服务器
- en: 'Now, we''ll stop the container using the following command:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用以下命令停止容器：
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now run it again:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行它：
- en: '[PRE53]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This makes the website available on localhost port `8080`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使网站在本地主机端口`8080`上可用。
- en: You can also use **acbuild** to build Docker containers.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用**acbuild**来构建Docker容器。
- en: Docker Machine
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker Machine
- en: 'There is another way to create Docker containers: Docker Machine. This is a
    tool that creates VMs that will host Docker. It''s something you should run on
    a development machine, physical or not, and you should execute everything remotely.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种创建Docker容器的方法：Docker Machine。这是一个创建将托管Docker的VM的工具。这是您应该在开发机器上运行的东西，无论是物理的还是虚拟的，您都应该远程执行所有操作。
- en: Please note that Docker Machine can be installed on macOS, Linux, and Windows
    machines. Refer to the Docker Machine documentation ([https://docs.docker.com/machine/install-machine/](https://docs.docker.com/machine/install-machine/))
    for macOS and Windows installation as we're following only the Linux installation.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Docker Machine可以安装在macOS、Linux和Windows机器上。请参考Docker Machine文档（[https://docs.docker.com/machine/install-machine/](https://docs.docker.com/machine/install-machine/)）以获取macOS和Windows安装信息，因为我们只关注Linux安装。
- en: 'Switch back to the Ubuntu machine where we installed Docker. Install the following
    dependency:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回安装了Docker的Ubuntu机器。安装以下依赖项：
- en: '[PRE54]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, you need to download Docker Machine and then extract it to your `PATH`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要下载Docker Machine，然后将其提取到您的`PATH`中：
- en: '[PRE55]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Autocompletion can be very useful, and also make sure you run the following
    script as root, as the script will write to the `/etc/` directory:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 自动补全可能非常有用，还要确保以root身份运行以下脚本，因为脚本将写入`/etc/`目录：
- en: '[PRE56]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Log out and log in again. In order to verify that `bash-completion` is working,
    you can tap the tab button to see available commands for `docker-machine` as shown
    in the following screenshot:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 注销并重新登录。为了验证`bash-completion`是否有效，您可以点击tab按钮查看`docker-machine`的可用命令，如下截图所示：
- en: '![To verify the bash-completion using docker-machine command](img/B15455_09_10.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![使用docker-machine命令验证bash-completion](img/B15455_09_10.jpg)'
- en: 'Figure 9.10: Verifying that bash-completion is successful'
  id: totrans-266
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.10：验证bash-completion是否成功
- en: 'Verify the version:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 验证版本：
- en: '[PRE57]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Using Azure as a driver, you can now deploy a VM:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Azure作为驱动程序，现在可以部署VM：
- en: '[PRE58]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: There are other options, such as the public IP and the resource group name,
    that can be passed during deployment. You can see the complete list and default
    values for these options in the Docker documentation ([https://docs.docker.com/machine/drivers/azure/](https://docs.docker.com/machine/drivers/azure/)).
    If we don't specify a value for a specific option, Docker will take the default
    value. Another thing to keep in mind is that the VM name should only contain lowercase
    alpha-numeric characters or hyphens if required; otherwise, you will get an error.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他选项，例如公共IP和资源组名称，可以在部署期间传递。 您可以在Docker文档中查看这些选项的完整列表和默认值（[https://docs.docker.com/machine/drivers/azure/](https://docs.docker.com/machine/drivers/azure/)）。
    如果我们没有为特定选项指定值，Docker将采用默认值。 还要记住的一件事是，VM名称应仅包含小写字母数字字符或必要时连字符； 否则，您将收到错误。
- en: 'In the following screenshot, you can see that the deployment of a VM named
    `docker-machine-2` of size `Standard_A2` was successful and that Docker is running
    on the machine. For simplicity, we have saved our subscription ID to a variable,
    `$SUB_ID`, so that we don''t have to check it every time; you can also do the
    same if required. Since we have already authenticated before, the driver is not
    asking us to sign in again. The driver remembers your credentials for up to two
    weeks, which means you don''t have to sign in every time you deploy. You can also
    see what resources were deployed:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到名称为`docker-machine-2`的VM的部署成功，并且Docker正在该机器上运行。 为了简单起见，我们已将订阅ID保存到变量`$SUB_ID`中，这样我们就不必每次都检查它；
    如果需要，您也可以这样做。 由于我们之前已经进行了身份验证，因此驱动程序不会要求我们再次登录。 驱动程序会记住您的凭据长达两周，这意味着您不必每次部署时都登录。
    您还可以查看部署了哪些资源：
- en: '![Output representing successful deployment of docker-machine-2 VM](img/B15455_09_11.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![代表docker-machine-2 VM成功部署的输出](img/B15455_09_11.jpg)'
- en: 'Figure 9.11: Deploying the docker-machine-2 VM'
  id: totrans-274
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.11：部署docker-machine-2 VM
- en: 'To tell Docker to use the remote environment instead of running containers
    locally, execute the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要告诉Docker使用远程环境而不是在本地运行容器，请执行以下操作：
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To verify that the remote environment is being used, use the `info` command:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证是否正在使用远程环境，请使用`info`命令：
- en: '[PRE60]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Among other information, the output shows you that you are using a specific
    VM running in Azure:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他信息中，输出显示您正在使用在Azure中运行的特定VM：
- en: '![Detailed information about the Docker using dockor info command](img/B15455_09_12.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![使用dockor info命令详细了解Docker的信息](img/B15455_09_12.jpg)'
- en: 'Figure 9.12: Fetching the docker information'
  id: totrans-281
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.12：获取docker信息
- en: 'And for Docker Machine, execute the following command:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Docker Machine，执行以下命令：
- en: '[PRE61]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output should be similar to the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应类似于以下内容：
- en: '![Listing various detail of the Docker machine](img/B15455_09_13.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![列出Docker机器的各种详细信息](img/B15455_09_13.jpg)'
- en: 'Figure 9.13: Listing docker-machine'
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.13：列出docker-machine
- en: 'Let''s create an nginx container with the host port `80` mapped to container
    port `80`. This means that all traffic coming to the host VM''s port `80` will
    be directed to port `80` of the container. This is given using the `–p` parameter.
    Execute the following command to create an nginx container:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个nginx容器，将主机端口`80`映射到容器端口`80`。 这意味着所有发送到主机VM端口`80`的流量将被定向到容器的端口`80`。 这是使用`-p`参数给出的。
    执行以下命令创建nginx容器：
- en: '[PRE62]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Find the IP address of the VM:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 查找VM的IP地址：
- en: '[PRE63]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Use that IP address in a browser to verify that nginx is running.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中使用该IP地址验证nginx是否正在运行。
- en: 'Docker Machine also allows us to copy files into the VM with the `scp` parameter,
    or even to mount the files locally:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Machine还允许我们使用`scp`参数将文件复制到VM中，甚至可以在本地挂载文件：
- en: '[PRE64]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Use `docker ps` to find the running instances, stop them, and remove them, so
    that they are ready for the next utility.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker ps`查找正在运行的实例，停止它们并删除它们，以便它们为下一个实用程序做好准备。
- en: Docker Compose
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Docker Compose is a tool for creating a multiple-container application, for
    instance, a web application that needs a web server and a database.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose是用于创建多容器应用程序的工具，例如，需要Web服务器和数据库的Web应用程序。
- en: 'You can check for the latest or stable release of Docker Compose at [https://github.com/docker/compose/releases](https://github.com/docker/compose/releases)
    and install it, replacing the version number in the command with the latest release:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/docker/compose/releases](https://github.com/docker/compose/releases)上检查Docker
    Compose的最新或稳定版本，并安装它，将命令中的版本号替换为最新版本：
- en: '[PRE65]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, apply executable permission to the binary we downloaded:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将可执行权限应用于我们下载的二进制文件：
- en: '[PRE66]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, verify the installation:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，验证安装：
- en: '[PRE67]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If the installation was successful, you will be able to see the version of
    Docker Compose installed:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装成功，您将能够看到安装的Docker Compose的版本：
- en: '![Verifying the version of the Dockor Compose information](img/B15455_09_14.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![验证Dockor Compose信息的版本](img/B15455_09_14.jpg)'
- en: 'Figure 9.14: Verifying Docker compose installation'
  id: totrans-305
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.14：验证Docker compose安装
- en: Note
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: After installation, if the preceding command fails, then check your path or
    else create a symbolic link to `/usr/bin` or any other directory in your path.
    To find out what directories are in your `PATH`, execute `$PATH` in the shell.To
    create a symbolic link, execute `sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，如果前面的命令失败，请检查您的路径，否则在`/usr/bin`或您的路径中的任何其他目录中创建符号链接。 要找出您的`PATH`中有哪些目录，请在shell中执行`$PATH`。
    要创建符号链接，请执行`sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose`。
- en: 'Create a file named `docker-compose.yml` with the following content:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 创建名为`docker-compose.yml`的文件，并包含以下内容：
- en: '[PRE68]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Replace `<password>` with the password of your choice. While still being connected
    to the Azure environment, using Docker Machine, execute the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 将`<password>`替换为您选择的密码。 在仍然连接到Azure环境的情况下，使用Docker Machine执行以下操作：
- en: '[PRE69]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If the build is successful, two containers are running, which you can verify
    by using `docker ps` and opening a browser with the correct IP address (`docker-machine
    ip <vm name>`). The WordPress installer is waiting for you.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建成功，将运行两个容器，您可以使用`docker ps`进行验证，并使用正确的IP地址（`docker-machine ip <vm name>`）在浏览器中打开WordPress安装程序。
- en: Docker Registry
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker注册表
- en: 'Every time we executed `docker run` or `docker pull` (download only), images
    were fetched from the internet. Where did they come from? Run this command:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行`docker run`或`docker pull`（仅下载）时，都会从互联网获取镜像。它们来自哪里？运行此命令：
- en: '[PRE70]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The output of the preceding command gives you the answer: [https://index.docker.io/v1/](https://index.docker.io/v1/).
    This URL is the official Docker Hub. Docker Hub, or Docker Store, also has a nice
    web interface available via [https://hub.docker.com](https://hub.docker.com),
    and is an online repository of private and publicly available Docker images.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出给出了答案：[https://index.docker.io/v1/](https://index.docker.io/v1/)。此URL是官方的Docker
    Hub。Docker Hub，或Docker Store，还有一个可通过[https://hub.docker.com](https://hub.docker.com)访问的漂亮的Web界面，是私有和公开可用的Docker镜像的在线存储库。
- en: 'The `docker search` command can be used to search this repository. To limit
    the output of this command, you can add filters:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker search`命令可用于搜索此存储库。要限制此命令的输出，可以添加过滤器：'
- en: '[PRE71]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here''s the output of the `docker search` command:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`docker search`命令的输出：
- en: '![Output of docker search command](img/B15455_09_15.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![docker search命令的输出](img/B15455_09_15.jpg)'
- en: 'Figure 9.15: Output of the docker search command'
  id: totrans-321
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.15：docker search命令的输出
- en: Optionally, add the `--no-trunc` parameter to see the complete description of
    the image. In the output, there is also a star rating that can help us to select
    the best available image.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，添加`--no-trunc`参数以查看镜像的完整描述。输出中还有一个星级评分，可以帮助我们选择最佳可用镜像。
- en: If you create your own account on the Docker Hub website, you can use `docker
    push` to upload your images to the registry. It is free of charge!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Docker Hub网站上创建自己的帐户，可以使用`docker push`将您的镜像上传到注册表。这是免费的！
- en: 'Log in with the following:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下信息登录：
- en: '[PRE72]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Build the image:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 构建镜像：
- en: '[PRE73]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'You can also tag the image afterward:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在之后为镜像打标签：
- en: '[PRE74]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: For versioning, it is a good idea to use a string such as `v1.11.1.2019`, which
    means the first version was released on November 1, 2019\. If you don't add the
    version, it is tagged as the latest version.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 对于版本控制，建议使用诸如`v1.11.1.2019`之类的字符串，表示第一个版本于2019年11月1日发布。如果不添加版本，它将被标记为最新版本。
- en: 'You can''t see the tags using the `docker search` command. You''ll need the
    web interface or to query the Docker API using `curl` (a tool to transfer data
    to and from a server) and `jq` (a tool similar to `sed` but specifically for JSON
    data):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法使用`docker search`命令查看标签。您需要使用Web界面或使用`curl`（用于在服务器和客户端之间传输数据的工具）和`jq`（一种类似于`sed`但专门用于JSON数据的工具）来查询Docker
    API：
- en: '[PRE75]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: jq is not installed by default. You have to install it using `apt install jq`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下未安装jq。您必须使用`apt install jq`进行安装。
- en: 'This output will be in JSON format. You can further query using `jq` and refine
    the output if needed. If you don''t want to use jq for formatting JSON, you can
    use the native `sed`, `tr`, and `cut` commands to format output and get something
    cleaner:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出将以JSON格式呈现。您可以使用`jq`进一步查询并根据需要优化输出。如果您不想使用jq格式化JSON，可以使用本机的`sed`、`tr`和`cut`命令来格式化输出并获得更清晰的内容：
- en: '[PRE76]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: If you would like to get all the tags for nginx, you can replace `<image name>`
    with `nginx`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想获取nginx的所有标签，可以将`<image name>`替换为`nginx`。
- en: We have discussed Docker Hub and how to check available images. Similarly, Azure
    offers Azure Container Registry, where you can store your private images and pull
    them when required. Before we start Azure Container Registry, we need to understand
    Azure Container Instances, with which you can run containers without the hassle
    of managing the host machines. Let's go ahead and learn more.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Docker Hub以及如何检查可用镜像。类似地，Azure提供了Azure容器注册表，您可以在其中存储私有镜像，并在需要时拉取它们。在开始使用Azure容器注册表之前，我们需要了解Azure容器实例，借助它，您可以在不必管理主机机器的情况下运行容器。让我们继续学习更多。
- en: Azure Container Instances
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure容器实例
- en: 'Now that we are able to run a container in a VM, we can go one step further:
    we can use the Azure Container Instances service to run it without managing servers.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够在虚拟机中运行容器，我们可以更进一步：我们可以使用Azure容器实例服务来运行它，而无需管理服务器。
- en: 'You can do that using the Azure portal. In the left-hand navigation bar, select
    **All Services** and search for **Container instances**. Once you are in **Container
    instances**, click on **Add** to create a new container instance and the portal
    will redirect you to the following window:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Azure门户中执行此操作。在左侧导航栏中，选择**所有服务**并搜索**容器实例**。一旦进入**容器实例**，点击**添加**以创建新的容器实例，门户将重定向到以下窗口：
- en: '![Creating a new container instance on the Azure Container Instances portal](img/B15455_09_16.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![在Azure容器实例门户上创建新的容器实例](img/B15455_09_16.jpg)'
- en: 'Figure 9.16: Creating a Docker container instance'
  id: totrans-343
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.16：创建Docker容器实例
- en: 'You can create a resource group or use an existing one. Set the container name
    to `nginx`, set `Public` because we are going to pull a public image, set the
    image name to `nginx:latest`, set `Linux`, and choose the desired resource requirement
    for the container. Hit **Next** and in the **Networking** section, we will expose
    **port 80** for HTTP traffic as shown in the following screenshot. Also, you can
    add a **DNS label** and opt for a public IP address if required:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个资源组或使用现有的资源组。将容器名称设置为`nginx`，设置`Public`，因为我们将要拉取一个公共镜像，将镜像名称设置为`nginx:latest`，设置`Linux`，并选择容器的所需资源要求。点击**下一步**，在**网络**部分，我们将公开**端口80**以进行HTTP流量，如下截图所示。此外，如果需要，您可以添加**DNS标签**并选择公共IP地址：
- en: '![Adding networking details for container instance](img/B15455_09_17.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![为容器实例添加网络详细信息](img/B15455_09_17.jpg)'
- en: 'Figure 9.17: Adding networking details a container instance'
  id: totrans-346
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.17：为容器实例添加网络详细信息
- en: This is enough for the validation and creation of the instance. You can skip
    the next sections and go to **Review+ Create**. However, Azure offers advanced
    options in the **Advanced** tab. These can be used to add environment variables,
    set the restart policy option, and use command override to include a set of commands
    that need to be executed when the container is initialized. If you want, you can
    configure this as well.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这已足够验证和创建实例。您可以跳过下一节，转到**审阅+创建**。但是，Azure在**高级**选项卡中提供了高级选项。这些选项可用于添加环境变量，设置重启策略选项，并使用命令覆盖以包括在容器初始化时需要执行的一组命令。如果您愿意，也可以配置这些选项。
- en: 'You can also create containers with the command line using the Azure CLI:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用Azure CLI命令行创建容器：
- en: '[PRE77]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You can also use PowerShell:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用PowerShell：
- en: '[PRE78]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Please note that the DNS label must be unique in your region.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，DNS标签在您的区域必须是唯一的。
- en: 'In the output of the commands, the IP address of the instance is visible:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令的输出中，实例的IP地址是可见的：
- en: '![Container creation using PowerShell](img/B15455_09_18.jpg)'
  id: totrans-354
  prefs: []
  type: TYPE_IMG
  zh: '![使用PowerShell创建容器](img/B15455_09_18.jpg)'
- en: 'Figure 9.18: Creating containers using PowerShell'
  id: totrans-355
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.18：使用PowerShell创建容器
- en: 'You should be able to access the web server on an FQDN and IP address. As shown
    in the screenshot, you can point your browser to the DNS label or IP address and
    you can see the **Welcome to nginx!** page:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够访问FQDN和IP地址上的Web服务器。如屏幕截图所示，您可以将浏览器指向DNS标签或IP地址，然后您可以看到**欢迎使用nginx！**页面：
- en: '![Output of the web page when the browser is pointed to the DNS label](img/B15455_09_19.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![当浏览器指向DNS标签时，Web页面的输出](img/B15455_09_19.jpg)'
- en: 'Figure 9.19: Output of the web server when the browser is pointed to the DNS
    label'
  id: totrans-358
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.19：当浏览器指向DNS标签时，Web服务器的输出
- en: 'To get the list of container instances, execute the following:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取容器实例的列表，请执行以下操作：
- en: '[PRE79]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Alternatively, execute the following:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，执行以下操作：
- en: '[PRE80]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: So far, we have been relying on the Docker Registry to save, pull, and push
    images. Azure offers a private image registry where you can store your images
    so that they can be used when needed. This service is called Azure Container Registry.
    Let's learn about it.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直依赖Docker Registry来保存、拉取和推送图像。Azure提供了一个私有图像注册表，您可以在其中存储图像，以便在需要时使用。这项服务称为Azure容器注册表。让我们了解一下。
- en: Azure Container Registry
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure容器注册表
- en: As mentioned, instead of the Docker Registry, you can use the private Azure
    Container Registry. This service is not free of charge! Using this Azure service
    has the advantage that you have all the features of Blob storage (reliability,
    availability, replication, and so on) and can keep all the traffic within Azure,
    which makes this registry an interesting option in terms of features, performance,
    and cost.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您可以使用私有Azure容器注册表，而不是Docker注册表。这项服务是收费的！使用此Azure服务的优势在于，您拥有Blob存储的所有功能（可靠性、可用性、复制等），并且可以将所有流量保持在Azure内部，这使得该注册表在功能、性能和成本方面成为一个有趣的选择。
- en: Using the Azure Portal
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Azure门户
- en: 'The easiest way to create a registry is by using the Azure portal. In the left-hand
    navigation bar, select **All Services** and search for **Container registries**.
    Click on **Add** and you should get the following screen. Don''t forget to enable
    the **Admin user** option; by doing so, you can sign in to the container registry
    via **docker login** with the username as the registry name and the password as
    the access key:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 创建注册表的最简单方法是使用Azure门户。在左侧导航栏中，选择**所有服务**，然后搜索**容器注册表**。单击**添加**，您应该会看到以下屏幕。不要忘记启用**管理员用户**选项；这样做可以让您使用用户名作为注册表名称和访问密钥作为密码登录到容器注册表：
- en: '![Container registry creation using the Azure portal](img/B15455_09_20.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![使用Azure门户创建容器注册表](img/B15455_09_20.jpg)'
- en: 'Figure 9.20: Creating a container registry using the Azure portal'
  id: totrans-369
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.20：使用Azure门户创建容器注册表
- en: 'If the registry is ready, there will be a popup saying that the job is finished
    and you will be able to see the resource. If you navigate to the **Access Keys
    blade**, you will find the login server and your username, which is the same as
    the registry name and the set of passwords:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果注册表准备就绪，将会弹出一个弹窗，显示作业已完成，并且您将能够看到资源。如果导航到**访问密钥刀片窗格**，您将找到登录服务器和您的用户名，该用户名与注册表名称相同，并且一组密码：
- en: '![Screenshot of the Access key blade pane](img/B15455_09_21.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![访问密钥刀片窗格的屏幕截图](img/B15455_09_21.jpg)'
- en: 'Figure 9.21: The Access key blade pane'
  id: totrans-372
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.21：访问密钥刀片窗格
- en: Use this information to log into the repository, the same way you did with Docker
    Hub.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此信息登录存储库，方式与您在Docker Hub上登录相同。
- en: After pushing an image, it will be available in the repository. From there,
    you can deploy it to the Azure Container Instances service and run it.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 推送图像后，它将在存储库中可用。从那里，您可以将其部署到Azure容器实例服务并运行它。
- en: Using the Azure CLI
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Azure CLI
- en: We have created an Azure Container Registry instance via the Azure portal. It
    is also possible to use the Azure CLI and PowerShell to perform the same task.
    We will be following the Azure CLI steps and we encourage you to attempt this
    process using PowerShell on your own.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过Azure门户创建了一个Azure容器注册表实例。也可以使用Azure CLI和PowerShell执行相同的任务。我们将遵循Azure CLI步骤，并鼓励您尝试使用PowerShell自行完成此过程。
- en: To start with, we need a Linux VM in which Docker and the Azure CLI are installed.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个已安装Docker和Azure CLI的Linux VM。
- en: 'Let''s start by creating a resource group, or you can use the same resource
    group that was used in the portal example. Just to recall the command we studied
    in the beginning, in the *Docker Installation* section; we will proceed with a
    new resource group:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个资源组，或者您可以使用在门户示例中使用的相同资源组。只是为了回忆我们在* Docker安装*部分学习的命令，我们将继续使用一个新的资源组：
- en: '[PRE81]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Once you get the success message, proceed with the creation of the container
    registry using the following:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收到成功消息，请继续使用以下命令创建容器注册表：
- en: '[PRE82]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here, we are creating the container registry with the Basic SKU. There are other
    SKUs available that offer more storage options and throughput. SKUs point to different
    pricing tiers of container registry. Visit the Microsoft Azure pricing page ([https://azure.microsoft.com/en-in/pricing/details/container-registry/](https://azure.microsoft.com/en-in/pricing/details/container-registry/))
    to see the pricing of each SKU. Since this is a demonstration and to keep the
    cost minimal, we will go with Basic.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用基本SKU创建容器注册表。还有其他可用的SKU，提供更多的存储选项和吞吐量。SKU指向容器注册表的不同定价层。访问Microsoft Azure定价页面（[https://azure.microsoft.com/en-in/pricing/details/container-registry/](https://azure.microsoft.com/en-in/pricing/details/container-registry/)）查看每个SKU的定价。由于这是一个演示，并且为了保持成本最低，我们将选择基本SKU。
- en: 'After the deployment of the Azure Container Registry instance, we will log
    in to the registry. But to sign in, we require the password. We already know the
    username, which is the name of the registry, so let''s find the password of the
    registry:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 部署Azure容器注册表实例后，我们将登录到注册表。但是要登录，我们需要密码。我们已经知道用户名，即注册表的名称，所以让我们找到注册表的密码：
- en: '[PRE83]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The output will show the username and password. Please make a note of them.
    You can use password 1 or password 2\. Now that we are sure of the credentials,
    we''ll log in to the Azure Container Registry instance by executing the following:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示用户名和密码。请记下它们。您可以使用密码1或密码2。既然我们确定了凭据，我们将通过执行以下操作登录到Azure容器注册表实例：
- en: '[PRE84]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'If the login is successful, you should receive the output shown in the following
    screenshot:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果登录成功，您应该收到以下截图中显示的输出：
- en: '![Output displaying successful login of Azure Container Registry](img/B15455_09_22.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![显示Azure容器注册表成功登录的输出](img/B15455_09_22.jpg)'
- en: 'Figure 9.22: Azure Container Registry login successful'
  id: totrans-389
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.22：Azure容器注册表登录成功
- en: Let's go ahead and push an image to the registry. In order to push an image,
    first we need to have an image. If you are using the same VM that was used in
    the previous examples, you might have some images pulled in. If the images are
    not there, you can use `docker pull <image name>` to get the image. You can verify
    the list of available images using the `docker images` command. Since we already
    have an nginx image, we are not going to pull it from Docker Hub.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续推送一个镜像到注册表。为了推送一个镜像，首先我们需要有一个镜像。如果您正在使用在先前示例中使用的相同VM，您可能已经拉取了一些镜像。如果镜像不存在，您可以使用`docker
    pull <image name>`来获取镜像。您可以使用`docker images`命令来验证可用镜像的列表。由于我们已经有了一个nginx镜像，我们不打算从Docker
    Hub拉取它。
- en: 'Now that we have the image, let''s tag it. Tagging will help you know which
    image you are using. For example, if you have an image tagged as `v1` and you
    make some changes to it, you can tag it as `v2`. Tagging helps you to have a logical
    organization of your images based on release date, version number, or any other
    identifier. We need to tag in a `<AcrLoginName>/<image name>:<version tag>` format,
    where `acr-name` is the FQDN of the Azure Container Registry instance. To get
    the FQDN of the Azure Container Registry instance, execute the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了镜像，让我们给它打标签。标记将帮助您知道您正在使用哪个镜像。例如，如果您有一个标记为`v1`的镜像，并对其进行了一些更改，您可以将其标记为`v2`。标记有助于您根据发布日期、版本号或任何其他标识符对镜像进行逻辑组织。我们需要以`<AcrLoginName>/<image
    name>:<version tag>`格式对镜像进行标记，其中`acr-name`是Azure容器注册表实例的FQDN。要获取Azure容器注册表实例的FQDN，请执行以下操作：
- en: '[PRE85]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'For the nginx image, we are going to tag it as `nginx:v1`:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 对于nginx镜像，我们将其标记为`nginx:v1`：
- en: '[PRE86]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Let''s push the tagged image to Azure Container Registry using the `docker
    push` command:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`docker push`命令将标记的镜像推送到Azure容器注册表：
- en: '[PRE87]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'All layers should be pushed, as shown in the screenshot:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 所有层都应该被推送，就像截图中显示的那样：
- en: '![Pushing the tagged image to Azure Container Registry](img/B15455_09_23.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![将标记的镜像推送到Azure容器注册表](img/B15455_09_23.jpg)'
- en: 'Figure 9.23: Pushing the tagged image to the container registry'
  id: totrans-399
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.23：将标记的镜像推送到容器注册表
- en: 'Suppose you have pushed multiple images to Azure Container Registry and would
    like to get a list of all images. Then you can make use of the `az acr repository
    list` command. To list all the images in the Azure Container Registry instance
    we created, use this command:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经将多个镜像推送到Azure容器注册表，并希望获取所有镜像的列表。然后，您可以使用`az acr repository list`命令。要列出我们创建的Azure容器注册表实例中的所有镜像，请使用此命令：
- en: '[PRE88]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: You can use the `docker run` command to run the container. But always make sure
    that the image name is in the format `<AcrLoginName>/<image>`. The era of Docker
    is going to end, and eventually it will be replaced with daemonless next-generation
    tools.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker run`命令来运行容器。但是请务必确保镜像名称的格式为`<AcrLoginName>/<image>`。Docker时代即将结束，最终将被无守护进程的下一代工具所取代。
- en: The next section is all about these tools and how you can create an analogy
    with Docker for a smooth transition.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分都是关于这些工具以及如何使用Docker创建类比进行平稳过渡的。
- en: Buildah, Podman, and Skopeo
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Buildah、Podman和Skopeo
- en: 'In the previous section, we discussed how Docker works and how it can be used
    to deploy containers. As previously stated, Docker uses the Docker daemon, which
    helps us to achieve all this. What if we say people have started bidding goodbye
    to Docker? Yes, with the introduction of next-generation container management
    tools, Docker is fading away. We are not saying that Docker is completely out
    of the picture, but in time it will be replaced by rootless or daemonless Linux
    container tools. You read it right: there is no daemon running for these tools,
    and the approach of using the monolith daemon is coming to an end. No wonder people
    have started calling the containers deployed using these tools "Dockerless containers."'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们讨论了Docker的工作原理以及如何使用它来部署容器。如前所述，Docker使用Docker守护程序，这有助于我们实现所有这些。如果我们说人们已经开始向Docker告别，会怎么样？是的，随着下一代容器管理工具的推出，Docker正在逐渐消失。我们并不是说Docker完全退出了舞台，但是它将被无根或无守护进程的Linux容器工具所取代。您没听错：这些工具没有守护进程在运行，使用单块守护进程的方法即将结束。难怪人们已经开始称使用这些工具部署的容器为“无Docker容器”。
- en: History
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 历史
- en: You might wonder when this all happened. Back in 2015, Docker Inc. and CoreOS,
    along with some other organizations, came up with the idea of the **Open Container
    Initiative** (**OCI**). The intention behind this was to standardize the container
    runtime and image format specs. OCI image format is supported by most container
    image registries, such as Docker Hub and Azure Container Registry. Most container
    runtimes that are available now are either OCI-compatible or they have OCI in
    the pipeline. This was just the beginning.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道这一切是什么时候发生的。早在2015年，Docker Inc.和CoreOS以及其他一些组织提出了“开放容器倡议”（OCI）的想法。这背后的意图是标准化容器运行时和图像格式规范。OCI图像格式得到了大多数容器图像存储库的支持，例如Docker
    Hub和Azure容器注册表。现在大多数可用的容器运行时要么兼容OCI，要么正在进行OCI。这只是开始。
- en: Earlier, Docker was the only container runtime available for Kubernetes. Obviously,
    other vendors wanted to have support for their specific runtimes in Kubernetes.
    Due to this dilemma and the lack of support for other vendors, Kubernetes created
    CRI in 2017\. CRI stands for Container Runtime Interface. You can use other runtimes,
    such as CRI-O, containerd, or frakti. Since Kubernetes was booming and due to
    their support for multiple runtimes, the monopoly of Docker started to topple.
    In no time, the monopoly status of Docker changed and it became one of the supported
    runtimes in Kubernetes. The ripples made by this change actually gave birth to
    the idea of daemonless tools and the idea to overthrow the approach of using the
    monolith daemon, which requires superuser access.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，Docker是Kubernetes唯一可用的容器运行时。显然，其他供应商希望在Kubernetes中支持他们特定的运行时。由于这个困境和对其他供应商的支持不足，Kubernetes在2017年创建了CRI。CRI代表容器运行时接口。您可以使用其他运行时，例如CRI-O、containerd或frakti。由于Kubernetes的蓬勃发展以及对多个运行时的支持，Docker的垄断地位开始动摇。在很短的时间内，Docker的垄断地位发生了变化，并成为Kubernetes中支持的运行时之一。这种变化产生的涟漪实际上孕育了无守护进程工具的想法，并推翻了使用需要超级用户访问权限的单块守护进程的方法。
- en: Instead of using generic terms, let's try to understand popular ones. Buildah
    is for building containers, Podman is for running containers, and Skopeo lets
    you perform various operations on images and repositories where images are stored.
    Let's take a closer look at each of these tools. Some people suggest removing
    Docker before using these tools, but we suggest keeping Docker so that you can
    constantly compare these tools to it. If you have followed the previous sections
    on Docker, you will be able to create an analogy.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解流行的术语，而不是使用通用术语。Buildah用于构建容器，Podman用于运行容器，Skopeo允许您对存储图像的图像和存储库执行各种操作。让我们更仔细地看看这些工具。有些人建议在使用这些工具之前删除Docker，但我们建议保留Docker，以便您可以不断地将这些工具与其进行比较。如果您已经按照之前关于Docker的部分进行了操作，您将能够创建一个类比。
- en: Installation
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装
- en: 'Installing these tools is very straightforward. You can use apt in Ubuntu or
    yum in RHEL to install these tools. Since we are using the same VM, we will be
    following the Ubuntu installation of these packages. To install Buildah, execute
    the following:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 安装这些工具非常简单。您可以在Ubuntu中使用apt或在RHEL中使用yum来安装这些工具。由于我们正在使用相同的VM，我们将遵循这些软件包在Ubuntu上的安装。要安装Buildah，请执行以下操作：
- en: '[PRE89]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Since we already have the PPA repository added during the installation of Buildah,
    we can deploy Podman straight away using `apt install`. To install Podman, execute
    the following:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在安装Buildah时已经添加了PPA存储库，我们可以直接使用“apt install”来部署Podman。要安装Podman，请执行以下操作：
- en: '[PRE90]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In order to install Skopeo, we need `snap` to be installed on the Ubuntu VM.
    If you are on Ubuntu 16.04 LTS or later, snap will be installed by default. Otherwise,
    you have to manually install it using `apt install snapd`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装Skopeo，我们需要在Ubuntu VM上安装“snap”。如果您使用的是Ubuntu 16.04 LTS或更高版本，则“snap”将默认安装。否则，您必须使用“apt
    install snapd”手动安装它。
- en: 'Let''s install Skopeo using snap:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用snap安装Skopeo：
- en: '[PRE91]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note
  id: totrans-418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If you are getting an error message stating that `revision is not meant production`,
    you can use the `–devmode` parameter to install; this will skip this error and
    complete the installation.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您收到错误消息，指出“修订版不适用于生产”，您可以使用“--devmode”参数进行安装；这将跳过此错误并完成安装。
- en: Now we are ready to explore these tools.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备探索这些工具。
- en: Buildah
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Buildah
- en: 'In the previous section, we discussed Dockerfiles. Here is the interesting
    part: Buildah has full support for Dockerfiles. All you have to do is write the
    Dockerfile and use the `bud` command, which stands for build-using-docker. Let''s
    take the same example we used in the Dockerfile section. Create a Dockerfile by
    executing `vi Dockerfile` (you can use any text editor) and add the following
    lines:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了Dockerfile。这里有一个有趣的部分：Buildah完全支持Dockerfile。您所需要做的就是编写Dockerfile并使用“bud”命令，该命令代表使用Docker进行构建。让我们使用在Dockerfile部分中使用的相同示例。通过执行“vi
    Dockerfile”（您可以使用任何文本编辑器），添加以下行来创建一个Dockerfile：
- en: '[PRE92]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Save the file.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件。
- en: 'Before we build, there is something else we need to take care of. Buildah looks
    for the list of registries in the `/etc/containers/registries.conf` file. If this
    file doesn''t exist, we need to create one, add the following code, and save the
    file:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建之前，我们还需要处理其他事情。Buildah会在“/etc/containers/registries.conf”文件中查找注册表列表。如果此文件不存在，我们需要创建一个，添加以下代码，并保存文件：
- en: '[PRE93]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: By doing so, we are instructing to search Docker Hub for the image. You can
    also add your Azure Container Registry instance to the list if required.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们指示搜索Docker Hub的镜像。如果需要，您还可以将Azure容器注册表实例添加到列表中。
- en: 'Let''s go ahead and build the image; make sure you are in the directory where
    the Dockerfile is. Start the build process using this:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续构建镜像；确保您在Dockerfile所在的目录中。使用以下命令开始构建过程：
- en: '[PRE94]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We have created an image called `nginx-buildah`. To see the list of images,
    you can use the `buildah images` command. Yes, we know it looks very similar to
    how you list images in Docker. We need to keep this analogy in mind and it will
    help you learn.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为“nginx-buildah”的镜像。要查看镜像列表，可以使用“buildah images”命令。是的，我们知道它看起来与您在Docker中列出镜像的方式非常相似。我们需要牢记这个类比，它将帮助您学习。
- en: 'The output will be similar to this:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于此：
- en: '![Output of the list of images using buildah images command](img/B15455_09_24.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: 使用buildah images命令列出图像的输出
- en: 'Figure 9.24: Listing the images using the buildah command'
  id: totrans-433
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.24：使用buildah命令列出图像
- en: You can see that Buildah lists the image we pulled from Docker Hub and also
    the image we created that is stored in the localhost repository.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到Buildah列出了我们从Docker Hub拉取的图像，还列出了存储在本地主机存储库中的图像。
- en: 'To build a container from an image, we can use the following:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 要从图像构建容器，我们可以使用以下命令：
- en: '[PRE95]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This will create a container called `<image>-working-container`. If you want
    to build an nginx container, execute this:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`<image>-working-container`的容器。如果要构建一个nginx容器，请执行此操作：
- en: '[PRE96]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You will get a similar output to this:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得类似于此的输出：
- en: '![Building an nginx container using "buildah from nginx" command](img/B15455_09_25.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: 使用"buildah from nginx"命令构建nginx容器
- en: 'Figure 9.25: Building an nginx container'
  id: totrans-441
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.25：构建nginx容器
- en: 'Just like using `docker ps` to list all the containers, we will run `buildah
    ps` and we will be able to see the `nginx-working-container` we just created:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用`docker ps`列出所有容器一样，我们将运行`buildah ps`，我们将能够看到我们刚刚创建的`nginx-working-container`：
- en: '![Listing the containers using buildah ps command](img/B15455_09_26.jpg)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: 使用buildah ps命令列出容器
- en: 'Figure 9.26: Listing the containers using the buildah ps command'
  id: totrans-444
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.26：使用buildah ps命令列出容器
- en: 'Also, we can execute commands directly in the container using the `buildah
    run` command. The syntax is as follows:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用`buildah run`命令直接在容器中执行命令。语法如下：
- en: '[PRE97]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Let''s try to print the content of the `/etc/os-release` file of the nginx
    container we created. The command will be as follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试打印我们创建的nginx容器的`/etc/os-release`文件的内容。命令如下：
- en: '[PRE98]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The output will be similar to this:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于此：
- en: '![Printing the content of the nginx container using buildah run nginx-working-container
    cat /etc/os-release command](img/B15455_09_27.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: 使用buildah run nginx-working-container cat /etc/os-release命令打印nginx容器的内容
- en: 'Figure 9.27: Printing the content of the nginx container'
  id: totrans-451
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.27：打印nginx容器的内容
- en: Like Docker, Buildah has support for commands such as `push`, `pull`, `tag`,
    and `inspect`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 与Docker一样，Buildah支持`push`、`pull`、`tag`和`inspect`等命令。
- en: Podman
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Podman
- en: 'The images we build via Buildah follow OCI compliance and can be used with
    Podman. In Podman, the analogy keeps on continuing; all we have to do is replace
    all Docker commands with Podman commands. One of the key things that we have to
    keep in mind is that in Podman, we cannot do port binding for a container as a
    non-root user. If your container needs a port mapping, then you have to run Podman
    as root. As we have already covered Docker and you are already familiar with Docker
    commands, we will just try to run a container and verify. Let''s create an nginx
    container with the port mapped to `8080`. Since we need to map a port, we will
    run the command as `sudo`:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过Buildah构建的图像遵循OCI兼容性，并且可以与Podman一起使用。在Podman中，类比一直在继续；我们所要做的就是用Podman命令替换所有Docker命令。我们必须牢记的一个关键事项是，在Podman中，非root用户无法为容器进行端口绑定。如果您的容器需要端口映射，那么您必须以root身份运行Podman。由于我们已经介绍了Docker，您已经熟悉了Docker命令，我们将尝试运行一个容器并进行验证。让我们创建一个端口映射到`8080`的nginx容器。由于我们需要映射一个端口，我们将以`sudo`身份运行该命令：
- en: '[PRE99]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Since we have created the container using the `sudo` command, it will be owned
    by the root user. If a container is created using `sudo`, make sure you chain
    sudo for all actions related to that container.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`sudo`命令创建了容器，因此它将归属于root用户。如果使用`sudo`创建容器，请确保您对与该容器相关的所有操作都链接了sudo。
- en: 'To list the containers, use `podman ps`, and we can see that the container
    is listening on `0.0.0.0:8080` of the host, which is mapped to the port of the
    container:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出容器，请使用`podman ps`，我们可以看到容器正在主机的`0.0.0.0:8080`上监听，并映射到容器的端口：
- en: '![Using podman ps command to list the containers](img/B15455_09_28.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: 使用podman ps命令列出容器
- en: 'Figure 9.28: Listing the containers using the podman ps command'
  id: totrans-459
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.28：使用podman ps命令列出容器
- en: 'Let''s do a `curl` call and confirm whether the web server is running on port
    `8080` or not:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进行一次`curl`调用，确认Web服务器是否在端口`8080`上运行：
- en: '[PRE100]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'If everything is working, you will be able to see the nginx welcome page:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，您将能够看到nginx欢迎页面：
- en: '![Verifying the authentication to the port of the web server curl command](img/B15455_09_29.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: 验证Web服务器curl命令的端口身份验证的输出
- en: 'Figure 9.29: Verifying the authentication to the port of the web server'
  id: totrans-464
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.29：验证Web服务器端口身份验证
- en: Yes, the container is running daemonless!
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，容器正在无守护进程运行！
- en: We are not covering all Podman commands here, and once you are familiar with
    Docker, all you have to do is replace `docker` with `podman` in the command line.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会覆盖所有Podman命令，一旦您熟悉了Docker，您只需在命令行中用`podman`替换`docker`。
- en: Skopeo
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Skopeo
- en: 'If you recall, earlier we tried to get the tags of an image using Docker. Using
    Skopeo, you can inspect a repository, copy images, and delete images. To start
    with, we will use the `skopeo inspect` command to obtain the tags of an image
    in Docker Hub without pulling it:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，我们之前尝试使用Docker获取图像的标签。使用Skopeo，您可以检查存储库、复制图像和删除图像。首先，我们将使用`skopeo inspect`命令在Docker
    Hub中获取图像的标签而不拉取它：
- en: '[PRE101]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Running this command will trigger some warnings. You can ignore them. If you
    check the output, you can see that it is giving the tags, layers, OS type, and
    so on.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将触发一些警告。您可以忽略它们。如果您检查输出，您会看到它正在提供标签、层、操作系统类型等信息。
- en: You can use the `skopeo copy` command to copy container images across multiple
    storage repositories. Also, you can use Skopeo with Azure Container Registry.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`skopeo copy`命令在多个存储库之间复制容器图像。此外，您还可以将Skopeo与Azure容器注册表一起使用。
- en: 'We will not be covering all these. However, you can visit the GitHub repositories
    of these tools:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会覆盖所有这些。但是，您可以访问这些工具的GitHub存储库：
- en: 'Buildah: [https://github.com/containers/buildah](https://github.com/containers/buildah
    )'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buildah：[https://github.com/containers/buildah](https://github.com/containers/buildah)
- en: 'Podman: [https://github.com/containers/libpod](https://github.com/containers/libpod)'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Podman：[https://github.com/containers/libpod](https://github.com/containers/libpod)
- en: 'Skopeo: [https://github.com/containers/skopeo](https://github.com/containers/skopeo
    )'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Skopeo：[https://github.com/containers/skopeo](https://github.com/containers/skopeo)
- en: Containers and Storage
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器和存储
- en: This section aims to give you a basic idea of containers and storage. Every
    build tool that can create images provides the option to add data to your container.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 本节旨在为您提供有关容器和存储的基本概念。每个可以创建镜像的构建工具都提供了向容器添加数据的选项。
- en: You should use this feature only to provide configuration files. Data for applications
    should be hosted, as much as possible, outside the container. If you want to quickly
    update/remove/replace/scale your container, it's almost impossible if the data
    is within the container.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该仅使用此功能来提供配置文件。尽可能将应用程序数据托管在容器之外。如果您想快速更新/删除/替换/扩展容器，如果数据在容器内，这几乎是不可能的。
- en: When we create a container, storage is attached to the container. However, the
    containers are ephemeral, which means that the storage is also destroyed when
    you destroy the container. Let's assume you created a Ubuntu container for testing
    and you saved some scripts that were tested on the container in the hope that
    you can use them later. Now, if you accidentally deleted this container, all the
    scripts that you tested and saved for later would be gone.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个容器时，存储被附加到容器上。然而，容器是短暂的，这意味着当您销毁容器时存储也会被销毁。假设您为测试创建了一个Ubuntu容器，并且保存了一些在容器上测试并希望以后可以使用的脚本。现在，如果您意外删除了这个容器，那么您测试并保存以供以后使用的所有脚本都将消失。
- en: Your application data is important and you would like to retain it even after
    the container's life cycle is complete. So, we want to separate the data from
    the container life cycle. By doing so, your data is not destroyed and can be reused
    if needed. In Docker, this is achieved by using volumes.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序数据很重要，您希望即使容器的生命周期结束后也能保留它。因此，我们希望将数据与容器的生命周期分离。通过这样做，您的数据不会被销毁，并且可以在需要时重复使用。在Docker中，可以通过使用卷来实现这一点。
- en: Docker supports a wide range of options for persistent volumes, including Azure
    Files. In other words, you can tie your Azure file share to a Docker container
    as a persistent volume. To demonstrate this, we will go for the host volume, where
    a location will be mounted as a volume to the container. The purpose of these
    steps is to show how data can be saved even after the container is removed from
    the host.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: Docker支持各种持久卷的选项，包括Azure Files。换句话说，您可以将Azure文件共享与Docker容器绑定为持久卷。为了演示这一点，我们将使用主机卷，其中一个位置将被挂载为容器的卷。这些步骤的目的是展示即使容器从主机中删除后数据仍然可以保存。
- en: 'Volume info is passed to the `docker run` command using the `-v` parameter
    while creating the container. The general syntax is as follows:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建容器时，卷信息通过`-v`参数传递给`docker run`命令。一般的语法如下：
- en: '[PRE102]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Assume that you have an application that will create a file in a `/var/log`
    directory in the container and we need to make this persistent. In the next command,
    we are mapping a directory in the host to the `/var/log` directory of the container.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个应用程序，将在容器中的`/var/log`目录中创建一个文件，并且我们需要使其持久化。在下一个命令中，我们将一个主机目录映射到容器的`/var/log`目录。
- en: 'To complete this exercise, you need a Linux VM with Docker running on it. Let''s
    create a `~/myfiles` directory on the host machine that will be mapped to the
    container:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个练习，您需要在运行Docker的Linux VM上创建一个`~/myfiles`目录，该目录将映射到容器：
- en: '[PRE103]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Let''s create an Ubuntu container with an interactive shell, where the `-v`
    parameter is passed to mount the volume:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个带有交互式shell的Ubuntu容器，其中传递了`-v`参数以挂载卷：
- en: '[PRE104]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'If the container was created successfully, you will be logged in as a root
    user to the container:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器成功创建，您将以root用户登录到容器中：
- en: '![Creating the Ubuntu container](img/B15455_09_30.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![创建Ubuntu容器](img/B15455_09_30.jpg)'
- en: 'Figure 9.30: Creating the Ubuntu container'
  id: totrans-491
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.30：创建Ubuntu容器
- en: 'We will go to the `/var/log` directory of the container and create 10 empty
    files using this command:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将转到容器的`/var/log`目录，并使用此命令创建10个空文件：
- en: '[PRE105]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Listing the contents of the directory will show the 10 files we just created:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 列出目录的内容将显示我们刚刚创建的10个文件：
- en: '![Getting the list of recent 10 files created in the /var/log directory](img/B15455_09_31.jpg)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![获取/var/log目录中最近创建的10个文件的列表](img/B15455_09_31.jpg)'
- en: 'Figure 9.31: Listing the contents of the /var/log directory'
  id: totrans-496
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.31：列出/var/log目录的内容
- en: 'Exit from the interactive shell using *Ctrl* + *D*, and now we are back in
    the host machine. Now we will delete the container:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Ctrl* + *D*退出交互式shell，现在我们回到主机机器。现在我们将删除容器：
- en: '[PRE106]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The `id/name` can be obtained from the output of the `docker ps --all` command.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '`id/name`可以从`docker ps --all`命令的输出中获取。'
- en: Now that the container has been deleted, we will go to the `~/myfiles` directory
    of the host machine to verify the contents.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 现在容器已被删除，我们将转到主机机器的`~/myfiles`目录以验证内容。
- en: 'In the following screenshot, you can see that the container has been successfully
    deleted; however, the `~/myfiles` directory still holds the files we created inside
    the container:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到容器已成功删除；但是，`~/myfiles`目录仍然保存着我们在容器内创建的文件：
- en: '![Listing the files in the ~/myfiles directory](img/B15455_09_32.jpg)'
  id: totrans-502
  prefs: []
  type: TYPE_IMG
  zh: '![列出~/myfiles目录中的文件](img/B15455_09_32.jpg)'
- en: 'Figure 9.32: Listing the files in the ~/myfiles directory'
  id: totrans-503
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9.32：列出~/myfiles目录中的文件
- en: Now we know how to make our volume persistent. For Docker, there are solutions
    such as [https://github.com/ContainX/docker-volume-netshare](https://github.com/ContainX/docker-volume-netshare).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使我们的卷持久化。对于Docker，有一些解决方案，比如[https://github.com/ContainX/docker-volume-netshare](https://github.com/ContainX/docker-volume-netshare)。
- en: If you are using Docker and want to use Azure Files, you can use Cloudstor,
    a plugin that is available at [https://docs.docker.com/docker-for-azure/persistent-data-volumes](https://docs.docker.com/docker-for-azure/persistent-data-volumes).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用Docker并想使用Azure文件，你可以使用Cloudstor，这是一个可用的插件，网址是[https://docs.docker.com/docker-for-azure/persistent-data-volumes](https://docs.docker.com/docker-for-azure/persistent-data-volumes)。
- en: Using Azure File Storage maybe not the cheapest solution, but this way you get
    all the availability and backup options you need.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Azure文件存储可能不是最便宜的解决方案，但这样你可以获得所有你需要的可用性和备份选项。
- en: If you're going to use Kubernetes, it's a whole other story. We'll cover that
    in the next chapter.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要使用Kubernetes，那就是另一回事了。我们将在下一章中讨论这个问题。
- en: Summary
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, another way of deploying your workload in Azure was discussed.
    After an introduction to the history, ideas, and concepts of container virtualization,
    we went into some of the available options. Along with older implementations,
    such as LXC, we discussed other great and rock-solid implementations to host containers:
    systemd-nspawn and Docker.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了在Azure中部署工作负载的另一种方式。在介绍容器虚拟化的历史、思想和概念之后，我们探讨了一些可用的选项。除了较旧的实现，如LXC，我们还讨论了其他出色且稳定的容器托管实现：systemd-nspawn和Docker。
- en: We not only saw how to run existing images pulled from repositories but also
    how to create our own image. Perhaps the greatest news is that there is a tool
    called Buildah that is able to create an image using the OCI standard from the
    Open Container Initiative and can be used for Docker.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅看到了如何运行从仓库中拉取的现有镜像，还学会了如何创建我们自己的镜像。也许最大的好消息是，有一个名为Buildah的工具，它能够使用开放容器倡议（OCI）标准创建镜像，并且可以用于Docker。
- en: 'The majority of this chapter was about Docker. This is by far the most widely
    implemented container solution today. And, talking about implementations, there
    are many ways to implement/deploy Docker:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容都是关于Docker的。迄今为止，这是最广泛实施的容器解决方案。而且，谈到实施，有许多实现/部署Docker的方法：
- en: Deploy it manually in a VM
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚拟机中手动部署它
- en: Deploy a ready-to-go VM from the marketplace
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从市场上部署一个准备好的虚拟机
- en: Docker Machine
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Machine
- en: Azure Container Instances
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure容器实例
- en: Working with Docker Hub and Azure Container Registry was also discussed.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 还讨论了与Docker Hub和Azure容器注册表一起工作。
- en: Finally, we discussed new container technologies such as Buildah, Podman, and
    Skopeo.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了Buildah、Podman和Skopeo等新的容器技术。
- en: We ended the chapter with a few words about containers and storage. You might
    be wondering what will happen to the storage attached to a container if the container
    is destroyed, or how to make the storage persistent. You will learn about persistence
    in the next chapter, *Chapter 10*, *Working with Azure Kubernetes Service*. Also,
    we will be discussing the famous container orchestration tool Kubernetes.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以几句话结束了本章关于容器和存储的讨论。如果容器被销毁，附加到容器的存储会发生什么，或者如何使存储持久化，你将在下一章*第10章*“使用Azure
    Kubernetes服务”中了解到。此外，我们还将讨论著名的容器编排工具Kubernetes。
- en: Questions
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: What are the reasons for using containers?
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用容器的原因是什么？
- en: When are containers not the solution that you need?
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器不是你需要的解决方案的时候是什么情况？
- en: If you need something like a virtual private server, do you want a VM, or is
    there a container virtualization solution available that may be a good idea?
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你需要像虚拟私有服务器这样的东西，你想要一个虚拟机，还是有一个可用的容器虚拟化解决方案可能是个好主意？
- en: Why shouldn't it be difficult to migrate from one solution, let's say Docker,
    to another, for example, Buildah?
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么从一个解决方案（比如Docker）迁移到另一个解决方案（比如Buildah）不应该很困难？
- en: What is a development machine used for?
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发机器用于什么？
- en: Why is using Buildah such a good idea, even if it is under heavy development?
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么使用Buildah是一个好主意，即使它还在积极开发中？
- en: Why shouldn't you store application data in a container?
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么不应该将应用程序数据存储在容器中？
- en: Further Reading
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Carrying out further reading is not a very easy thing to do in the area of
    container virtualization. For `systemd-nspawn`, it''s relatively easy: the man
    pages are an easy read. Let''s make a suggestion that is relevant for `systemd-nspawn`
    and even Docker: Red Hat provides a document on their website called the Resource
    Management Guide ([https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/resource_management_guide/](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/resource_management_guide/))
    with good information about cgroups.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器虚拟化领域进行进一步阅读并不是一件很容易的事情。对于`systemd-nspawn`来说，阅读起来相对容易：man页面很容易理解。让我们提一个建议，这对于`systemd-nspawn`甚至Docker都是相关的：Red
    Hat在他们的网站上提供了一份名为资源管理指南的文档（[https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/resource_management_guide/](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/resource_management_guide/)），其中包含了关于cgroups的良好信息。
- en: 'A couple of references on Docker are listed here:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是有关Docker的一些参考资料：
- en: '*Orchestrating Docker*, by Shrikrishna Holla, where you can understand how
    to manage and deploy Docker services'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编排Docker*，作者Shrikrishna Holla，你可以了解如何管理和部署Docker服务'
- en: '*Mastering Docker Enterprise: A companion guide for agile container adoption*,
    by Mark Panthofer, where you can explore add-on services of Docker EE and how
    they can be used'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*掌握Docker企业：敏捷容器采用的伴侣指南*，作者Mark Panthofer，你可以探索Docker EE的附加服务以及它们的使用方式'
