- en: Using the Device Tree
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用设备树
- en: Modern computers are really complex systems composed of complex peripherals,
    which have tons of different configuration settings; that's why having all possible
    variants of device driver configurations in a dedicated file can solve a lot of
    problems. Having a logical description about how a system is structured (that
    is how they are interconnected to each other and not just their list) can allow
    system developers to focus their attention on device driver mechanisms without
    the boring job of managing all possible user settings.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机是由复杂的外围设备组成的复杂系统，这些外围设备有大量不同的配置设置；这就是为什么在专用文件中具有所有可能的设备驱动程序配置变体可以解决很多问题。有关系统结构的逻辑描述（即它们如何相互连接而不仅仅是它们的列表）可以让系统开发人员将注意力集中在设备驱动程序机制上，而不是管理所有可能的用户设置的乏味工作。
- en: Moreover, knowing how every peripheral is connected to the system (for example,
    which bus a peripheral is dependent on) allows the implementation of a really
    smart peripheral management system. Such a system can correctly activate (or deactivate),
    in the right order, all the subsystems needed, by a specific device, to work.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，了解每个外围设备如何连接到系统（例如，外围设备依赖于哪个总线）可以实现一个非常智能的外围设备管理系统。这样的系统可以正确地按照特定设备所需的顺序激活（或停用）所有子系统。
- en: 'Let''s review an example: think about a USB key, which activates several devices
    when plugged into your PC. The system knows that the USB port is connected to
    a specific USB controller, which is mapped at a specific address into the system''s
    memory, and so on.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子：想象一下一个USB键，当插入电脑时会激活多个设备。系统知道USB端口连接到特定的USB控制器，该控制器映射到系统内存的特定地址，依此类推。
- en: For all these reasons (and others), Linux developers adopted **the device tree,** which
    is, simply speaking, a data structure to describe hardware. Rather than hard-coding
    every kernel setting into the code, it can be described in a well-defined data
    structure which is passed to the kernel during booting by the bootloader. This
    is also where all device drivers (and other kernel entities) can fetch their configuration
    data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这些原因（和其他原因），Linux开发人员采用了**设备树**，简单地说，这是一种描述硬件的数据结构。它可以将所有内核设置硬编码到代码中，而是可以在启动时由引导加载程序传递给内核的一种明确定义的数据结构中进行描述。这也是所有设备驱动程序（和其他内核实体）可以获取其配置数据的地方。
- en: The main difference between the device tree and the kernel configuration file
    (the `.config` file in the upper directory of Linux sources) is that while such
    files tell us which components of the kernel are enabled and which are not, the
    device tree holds their configurations. So, if we wish to add a driver from the
    kernel's sources to our system, we have to specify it in the `.config` file. On
    the other hand, if we wish to specify the driver's settings (memory addresses,
    special settings, and so on), we have to specify them in the device tree.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树和内核配置文件（Linux源代码上级目录中的`.config`文件）之间的主要区别在于，虽然这些文件告诉我们内核的哪些组件已启用，哪些未启用，但设备树保存它们的配置。因此，如果我们希望将内核源代码中的驱动程序添加到我们的系统中，我们必须在`.config`文件中指定它。另一方面，如果我们希望指定驱动程序的设置（内存地址、特殊设置等），我们必须在设备树中指定它们。
- en: In this chapter, we'll see how to write a device tree and how we can get useful
    information for our driver from it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何编写设备树，以及如何从中获取有用的信息来为我们的驱动程序提供支持。
- en: 'This chapter consists of the following recipes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下内容：
- en: Using the device tree compiler and utilities
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用设备树编译器和实用程序
- en: Getting application-specific data from a device tree
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从设备树获取特定应用程序数据
- en: Using a device tree to describe a character driver
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用设备树描述字符驱动程序
- en: Downloading the firmware
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载固件
- en: Configuring a CPU's pin for specific peripherals
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为特定外围设备配置CPU引脚
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find more information on this chapter in the *Appendix.*
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在*附录*中找到有关本章的更多信息。
- en: The code and other files used in this chapter can be downloaded from GitHub
    at [https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_04](https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_04).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码和其他文件可以从GitHub下载：[https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_04](https://github.com/giometti/linux_device_driver_development_cookbook/tree/master/chapter_04)。
- en: Using the device tree compiler and utilities
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用设备树编译器和实用程序
- en: We need proper tools to convert our code into a binary format that Linux can
    understand. Specifically, we need a way to convert a **device tree source** (**DTS**)
    file into its binary form: **device tree binary** (**DTB**).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要适当的工具将我们的代码转换为Linux可以理解的二进制格式。具体来说，我们需要一种方法将**设备树源**（**DTS**）文件转换为其二进制形式：**设备树二进制**（**DTB**）。
- en: In this recipe, we'll discover how to install the **device tree compiler** (`dtc`)
    on our system and how we can use it to generate the binary for any device tree.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将了解如何在系统上安装**设备树编译器**（`dtc`），以及如何使用它生成任何设备树的二进制文件。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To convert a DTS file into a DTB one we have to use the **device tree compiler**
    (named `dtc`) and a set of proper tools we can use to inspect or manipulate DTB
    files (**device tree utilities**).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要将DTS文件转换为DTB文件，我们必须使用**设备树编译器**（名为`dtc`）和一组适当的工具，我们可以用来检查或操作DTB文件（**设备树实用程序**）。
- en: 'Every recent Linux release has its own copy of the `dtc` program in the `linux/scripts/dtc` directory,
    which is used during kernel compilation. However, we don''t need to install Linux
    sources to have a working release of `dtc` and its utilities on Ubuntu; in fact,
    we can get them all by using the usual install command as below:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个最新的Linux发行版都有自己的`dtc`程序的副本，位于`linux/scripts/dtc`目录中，用于内核编译。但是，我们不需要安装Linux源代码来在Ubuntu上获得`dtc`及其实用程序的工作版本；实际上，我们可以使用以下常规安装命令获取它们：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After installation, we can execute the `dtc` compiler as follows in order to
    display its release:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，我们可以执行以下命令来显示`dtc`编译器的版本：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: Now we are ready to convert our first DTS file into its equivalent DTB binary
    form using the following step.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备将我们的第一个DTS文件转换为其等效的DTB二进制形式，使用以下步骤。
- en: 'We can do this by using the `dtc` compiler with the following command line:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令行使用`dtc`编译器来做到这一点：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`simple_platform.dts` can be retrieved from GitHub sources; however the reader
    can use his/her own DTS file to test `dtc`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple_platform.dts`可以从GitHub源中检索；但是读者可以使用自己的DTS文件来测试`dtc`。'
- en: 'Now our DTB file should be available in the current directory:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的DTB文件应该在当前目录中可用：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Converting a DTS file into a DTB one is similar to how a normal compiler works,
    but something should be said about the reverse operation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将DTS文件转换为DTB文件类似于正常编译器的工作，但是关于逆向操作应该说一些事情。
- en: 'If we take a look at `simple_platform-reverted.dts`, we notice that it looks
    very similar to the original `simple_platform.dts` file (apart from phandles,
    labels, and numbers in hexadecimal form); in fact, we have the following differences
    regarding clock settings:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下`simple_platform-reverted.dts`，我们会注意到它看起来与原始的`simple_platform.dts`文件非常相似（除了phandles、标签和十六进制形式的数字）；事实上，关于时钟设置，我们有以下差异：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And we have the following differences regarding the serial controller settings:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关于串行控制器设置，我们有以下差异：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From the preceding output, we can see that the  `serial0` and `clks` labels
    have disappeared since they are not needed in a DTB file; phandles are also now
    explicitly reported and, with corresponding symbolic names such as `ipic` and `clks`, have
    been replaced accordingly, and all numbers have been converted to their hexadecimal
    form.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到`serial0`和`clks`标签已经消失，因为它们在DTB文件中不需要；phandles现在也明确报告，并且已经相应地替换为`ipic`和`clks`等相应的符号名称，并且所有数字已经转换为它们的十六进制形式。
- en: There's more...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The device tree is a really complex piece of software and it's a powerful way
    to describe a system, which is why we need to talk a bit more about it. We should
    also take a look at device tree utilities due to the fact it is very useful for
    a kernel developer to manage a device tree binary form.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 设备树是一个非常复杂的软件，是描述系统的强大方式，这就是为什么我们需要更多地谈论它。由于对于内核开发人员来说，管理设备树二进制形式非常有用，因此我们还应该看一下设备树实用程序。
- en: Reverting a binary device tree into its source
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将二进制设备树还原为其源代码
- en: 'The `dtc` program can revert the compilation process, allowing the developer
    to retrieve a source file from a binary using a command line such as the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`dtc`程序可以逆转编译过程，允许开发人员使用以下命令行从二进制文件中检索源文件：'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This can be very useful when we need to inspect a DTB file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要检查DTB文件时，这可能非常有用。
- en: See also
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For further information about the `dtc` compiler, the reader can take a look
    at the device tree user manual at [https://git.kernel.org/pub/scm/utils/dtc/dtc.git/tree/Documentation/manual.txt](https://git.kernel.org/pub/scm/utils/dtc/dtc.git/tree/Documentation/manual.txt).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`dtc`编译器的更多信息，读者可以查看设备树用户手册[https://git.kernel.org/pub/scm/utils/dtc/dtc.git/tree/Documentation/manual.txt](https://git.kernel.org/pub/scm/utils/dtc/dtc.git/tree/Documentation/manual.txt)。
- en: Regarding device tree utilities, a good starting point is their respective man
    pages (`man fdtput`, `man fdtget` and so on).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于设备树实用程序，一个很好的起点是它们各自的man页面（`man fdtput`，`man fdtget`等）。
- en: Getting application-specific data from a device tree
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从设备树中获取特定应用程序的数据
- en: Now we know how to read a device tree file and how to manage it in userspace.
    In this recipe, we will see how we can extract the configuration settings it holds
    within the kernel.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何读取设备树文件以及如何在用户空间中管理它。在这个配方中，我们将看到如何提取内核中保存的配置设置。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: To do our job, we can use all the data stored in the DTB to boot our ESPRESSObin
    and then use the ESPRESSObin as a system test.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的工作，我们可以使用存储在DTB中的所有数据来引导我们的ESPRESSObin，然后使用ESPRESSObin作为系统测试。
- en: 'As we know, ESPRESSObin''s DTS file is stored in kernel sources at `linux/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts` or
    it can be extracted from the running kernel by executing the `dtc` command as
    presented in the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，ESPRESSObin的DTS文件存储在内核源代码中的`linux/arch/arm64/boot/dts/marvell/armada-3720-espressobin.dts`，或者可以通过执行以下代码中呈现的`dtc`命令从运行的内核中提取出来：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now let's take this file apart since we can use it to verify that the data that
    we just read is correct.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们拆开这个文件，因为我们可以使用它来验证我们刚刚读取的数据是否正确。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To show how we can read data from the running device tree, we can use a kernel
    module (like the one reported in file `get_dt_data.c`) from GitHub sources.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示我们如何从运行的设备树中读取数据，我们可以使用GitHub源中的一个内核模块（如文件`get_dt_data.c`中报告的模块）。
- en: 'In the file, we have an empty module `exit()` function, due to the fact we
    don''t allocate anything in the module''s `init()` function; in fact, it just
    shows us how we can parse a device tree. The `get_dt_data_init()` function takes
    an optional input parameter: a device tree path stored into the `path` variable
    defined in the following snippet:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中，由于我们在模块的`init()`函数中没有分配任何内容，所以我们有一个空的模块`exit()`函数；事实上，它只是向我们展示了如何解析设备树。`get_dt_data_init()`函数接受一个可选的输入参数：存储在以下代码片段中定义的`path`变量中的设备树路径：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, as the first step, the `get_dt_data_init()` function uses the `of_find_node_by_path()`
    function to get a pointer to the desired node to inspect:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，作为第一步，`get_dt_data_init()`函数使用`of_find_node_by_path()`函数获取指向要检查的所需节点的指针：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, it calls the `print_main_prop()` function, which just prints the node''s
    main properties as shown in the following:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它调用`print_main_prop()`函数，该函数只打印节点的主要属性，如下所示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Each printing function is reported as the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个打印函数都报告如下：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For the last two steps, the  `get_dt_data_init()`function uses the `for_each_property_of_node()` macro
    to display all of the node''s property, and the  `for_each_child_of_node()` macro
    to iterate all the node''s children and display all of their main properties,
    as shown in the following:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于最后两个步骤，`get_dt_data_init()`函数使用`for_each_property_of_node()`宏来显示所有节点的属性，使用`for_each_child_of_node()`宏来迭代所有节点的子节点并显示它们的所有主要属性，如下所示：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In step 1, it's quite obvious that if we insert the module into the kernel specifying `path=<my_path>`, we
    force the desired value; otherwise, we simply accept the default, which is the
    root (represented by the  `/` character). The rest of the steps are quite self-explanatory.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中，很明显，如果我们将模块插入内核并指定`path=<my_path>`，我们会强制使用所需的值；否则，我们只接受默认值，即根目录（由`/`字符表示）。其余步骤都很容易理解。
- en: 'Understanding the code should be very easy; in fact the `get_dt_data_init()`
    function simply calls `of_find_node_by_path()`, passing the device path name;
    no errors, we use `print_main_prop()` to display the node name and some main (or
    interesting) properties of the node:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 理解代码应该非常容易；实际上，`get_dt_data_init()`函数只是调用`of_find_node_by_path()`，传递设备路径名称；没有错误，我们使用`print_main_prop()`来显示节点名称和一些主要（或有趣的）节点属性：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that the `print_property_u32()` and `print_property_string()` functions
    are defined in such a way as to display nothing if the supplied property is not
    present:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`print_property_u32()`和`print_property_string()`函数的定义方式是，如果提供的属性不存在，则不显示任何内容：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Functions such as `of_property_read_u32()`/`of_property_read_string()` and `for_each_child_of_node()`/`for_each_property_of_node()` and
    friends are defined in the header file `linux/include/linux/of.h` of kernel sources.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`of_property_read_u32()`/`of_property_read_string()`和`for_each_child_of_node()`/`for_each_property_of_node()`等函数在内核源码的头文件`linux/include/linux/of.h`中定义。
- en: 'Once compiled from the `get_dt_data.c`  file, we should get its compiled version
    named `get_dt_data.ko`, which is suitable for loading into the ESPRESSObin:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从`get_dt_data.c`文件编译后，我们应该得到其编译版本，命名为`get_dt_data.ko`，适合加载到ESPRESSObin中：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is what we should get if we use `modinfo` in our newly created
    kernel module:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在新创建的内核模块中使用`modinfo`，我们应该得到以下内容：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There's more...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'OK, so let''s try using the default value for the `path` by using the following
    command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们尝试使用以下命令使用`path`的默认值：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We should get an output such as the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到以下输出：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'By using `/` as the path name, we obviously found a corresponding entry in
    the device tree, so the output continues as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`/`作为路径名，显然我们在设备树中找到了相应的条目，因此输出继续如下：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following are all properties of the root node that can be verified against
    the original sources or in the `espressobin-reverted.dts` file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以根据原始源或`espressobin-reverted.dts`文件验证的根节点的所有属性：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Readers should notice that, in this case, the `name` property is empty due to
    the fact we are inspecting the root node, and for the `compatible` property only
    the first entry is displayed because we used the `of_property_read_string()` function
    instead of the corresponding array  `of_property_read_string_array()` version
    and friends.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应该注意，在这种情况下，`name`属性为空，因为我们正在检查根节点，并且对于`compatible`属性，只显示第一个条目，因为我们使用了`of_property_read_string()`函数，而不是相应的数组`of_property_read_string_array()`版本和相关函数。
- en: 'After all of the node''s properties, our program will move through all of its
    children as reported in the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印出所有节点的属性之后，我们的程序将遍历所有子节点，如下所示：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'At this point, the `get_dt_data_init()` function does a `return -EINVAL`, not
    to return an error condition, but to force a module to unload; in fact, as the
    last printed out message, we see the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，`get_dt_data_init()`函数执行`return -EINVAL`，不是为了返回错误条件，而是为了强制模块卸载；实际上，作为最后打印出的消息，我们看到以下内容：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, just to show a different usage, we can try to ask for information regarding
    the system''s CPUs by specifying the `path=/cpus` command in the command line:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只是为了展示不同的用法，我们可以尝试通过在命令行中指定`path=/cpus`来请求有关系统CPU的信息：
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The program says that a node is found:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 程序表示找到了一个节点：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then it starts printing the node''s information:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它开始打印节点的信息：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, it displays all of the children''s properties:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它显示所有子节点的属性：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that the following error message can be safely ignored because we force
    it to automatically retrieve the module to be unloaded by the `insmod` command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下错误消息可以安全地忽略，因为我们强制它自动检索要由`insmod`命令卸载的模块：
- en: '`insmod: ERROR: could not insert module get_dt_data.ko: Invalid parameters`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`insmod: ERROR: could not insert module get_dt_data.ko: Invalid parameters`'
- en: 'In a similar manner, we can obtain information regarding the I2C controller
    as shown in the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以获取有关I2C控制器的信息，如下所示：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: See also
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: To see all available functions for inspecting a device tree, the reader can
    take a look at the included `linux/include/linux/of.h` file, which is well documented.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查看检查设备树的所有可用函数，读者可以查看包含的`linux/include/linux/of.h`文件，该文件有很好的文档。
- en: Using a device tree to describe a character driver
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用设备树描述字符驱动程序
- en: At this point, we have all the information needed to define a new character
    device by using a device tree. In particular, this time, to register our `chrdev`
    device, we can use the new API that we skipped in [Chapter 3](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml),
    *Working with Char Drivers*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经有了使用设备树定义新字符设备所需的所有信息。特别是，这一次，为了注册我们的`chrdev`设备，我们可以使用我们在[第3章](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml)中跳过的新API，*使用字符驱动程序*。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'As stated in the previous paragraph, we can use a device tree node to add a
    new device to our system. In particular, we can obtain a definition as reported
    in the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一段所述，我们可以使用设备树节点向系统添加新设备。特别是，我们可以获得如下所述的定义：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'All these modifications can be applied using the  `add_chrdev_devices.dts.patch` file  in
    the root directory of the kernel sources, as shown in the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些修改都可以使用根目录中的`add_chrdev_devices.dts.patch`文件来应用，如下所示：
- en: '**`$ patch -p1 < ../github/chapter_04/chrdev/add_chrdev_devices.dts.patch`**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**`$ patch -p1 < ../github/chapter_04/chrdev/add_chrdev_devices.dts.patch`**'
- en: Then the kernel must be recompiled and reinstalled (with the ESPRESSObin's DTB
    file) in order to take effect.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后必须重新编译和重新安装内核（使用ESPRESSObin的DTB文件）才能生效。
- en: In this example, we are defining a `chrdev` node, which defines a new set of
    devices compatible with `"ldddc,chrdev"` and with two subnodes; each subnode defines
    a particular device with its own settings. The first subnode defines a `"ldddc,chrdev"`
    device labeled `"cdev-eeprom"` with a  `reg` property equal to `2`, while the
    second subnode defines another `"ldddc,chrdev"` device labeled `"cdev-rom"` with
    a  `reg` property equal to `4`, and with a  `read-only` property.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了一个`chrdev`节点，它定义了一个与`"ldddc,chrdev"`兼容的新设备集，并且有两个子节点；每个子节点定义了一个具有自己设置的特定设备。第一个子节点定义了一个标记为`"cdev-eeprom"`的`"ldddc,chrdev"`设备，其`reg`属性等于`2`，而第二个子节点定义了另一个标记为`"cdev-rom"`的`"ldddc,chrdev"`设备，其`reg`属性等于`4`，并且具有`read-only`属性。
- en: The `#address-cells` and `#size-cells` properties must be 1 and 0 because the
    subdevice's `reg` property holds a single value representing something as the
    "device address". In fact, devices that are addressable use  `#address-cells`,  `#size-cells`, and
    the `reg` property to encode address information into the device tree.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`#address-cells`和`#size-cells`属性必须是1和0，因为子设备的`reg`属性包含一个表示"设备地址"的单个值。实际上，可寻址设备使用`#address-cells`、`#size-cells`和`reg`属性将地址信息编码到设备树中。'
- en: 'Each addressable device obtains a `reg` property, which is a list as shown
    in the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可寻址设备都有一个`reg`属性，如下所示的列表：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Each tuple represents an address range used by the device and each address or
    length value is a list of one or more 32-bit integers called **cells** (the length
    can also be empty as in our example).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元组表示设备使用的地址范围，每个地址或长度值都是一个或多个称为**cells**的32位整数列表（长度也可以为空，就像我们的示例一样）。
- en: Since both the address and length fields may vary and be of variable size, the
    `#address-cells` and `#size-cells` properties in the parent node are used to state
    how many cells are in each subnode's field.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于地址和长度字段都可能变化且大小可变，因此父节点中的`#address-cells`和`#size-cells`属性用于说明每个子节点字段中有多少个cells。
- en: For further information regarding the  `#address-cells`, `#size-cells`, and
    `reg` properties, you can take a look at the device tree specification at [https://www.devicetree.org/specifications/](https://www.devicetree.org/specifications/).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`#address-cells`、`#size-cells`和`reg`属性的更多信息，可以查看[https://www.devicetree.org/specifications/](https://www.devicetree.org/specifications/)上的设备树规范。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Now it's time to see how we can use the preceding device tree definition to
    create our char devices (note that this time we're going to create more than one
    device!).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看如何使用前面的设备树定义来创建我们的字符设备了（请注意，这次我们要创建多个设备！）。
- en: 'Both of the module''s `init()` and `exit()` functions must be rewritten as
    shown in the following code. `chrdev_init()` looks as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块的`init()`和`exit()`函数都必须按照以下代码进行重写。`chrdev_init()`如下所示：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `chrdev_exit()` function looks like this:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`chrdev_exit()`函数如下所示：'
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: All code can be retrieved from GitHub sources in the `chrdev.c` file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码都可以从GitHub的`chrdev.c`文件中检索到。
- en: 'If we try to insert the module into the kernel, we should get something like
    the following:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试将模块插入内核，应该会得到如下内容：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To create the character device, we must use the next  `chrdev_device_register()` function,
    but we must first do some checks regarding whether the device has already been
    created or not:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建字符设备，我们必须使用下一个`chrdev_device_register()`函数，但首先我们必须进行一些检查，看设备是否已经创建：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then we do something a little bit more complicated than we''ve done in the
    previous chapter, in which we simply called the `register_chrdev()` function;
    now the really important thing is the calling sequence of the  `cdev_init()`, `cdev_add()`, and `device_create()` functions,
    which actually do the job, as shown in the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们要做的事情比前一章简单调用`register_chrdev()`函数要复杂一些；现在真正重要的是调用`cdev_init()`、`cdev_add()`和`device_create()`函数的顺序，这些函数实际上完成了工作，如下所示：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once the `device_create()` function returns success, we use the `dev_set_drvdata()` function to
    save a pointer to our driver data, which is then initialized like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`device_create()`函数返回成功，我们就使用`dev_set_drvdata()`函数来保存指向我们驱动程序数据的指针，然后初始化如下：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'All these functions operate on `struct chrdev_device`, defined as  the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都作用于`struct chrdev_device`，定义如下：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In *step 1*,within `chrdev_init()` function, this time, we use the  `alloc_chrdev_region()` function, which
    asks the kernel to reserve some character devices named `chrdev` (in our case,
    this number is equivalent to the `MAX_DEVICES` definition). The `chrdev` information
    is then stored in the `chrdev_devt` variable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，在`chrdev_init()`函数中，这次我们使用`alloc_chrdev_region()`函数，请求内核保留一些名为`chrdev`的字符设备（在我们的情况下，这个数字等同于`MAX_DEVICES`的定义）。`chrdev`信息然后存储在`chrdev_devt`变量中。
- en: Here, we should be careful and notice that we also create a device class by
    calling the  `class_create()` function. Each device defined for the device tree
    must belong to a proper class and, since our `chrdev` driver is new, we need a
    dedicated class.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应该注意并注意，我们还通过调用`class_create()`函数创建了一个设备类。设备树中定义的每个设备都必须属于适当的类，由于我们的`chrdev`驱动程序是新的，所以我们需要一个专门的类。
- en: In the next steps, I will be more clear about the reason we need to do it this
    way; for the moment, we should consider it as a compulsory data allocation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我将更清楚地解释我们需要以这种方式进行的原因；目前，我们应该将其视为强制性的数据分配。
- en: It's quite clear that the  `unregister_chrdev_region()` function just releases
    all of the `chrdev` data allocated in `with alloc_chrdev_region()`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`unregister_chrdev_region()`函数只是释放了`alloc_chrdev_region()`分配的所有`chrdev`数据。
- en: 'In *step 3*, if we take a look at the `/proc/devices` file, we get the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，如果我们查看`/proc/devices`文件，我们会得到以下内容：
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Good! Now we've got something similar to [Chapter 3](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=27&action=edit#post_26), *Working
    with Char Drivers*! However, this time, if we try to create a special character
    file by using `mknod` and try to read from it, we get an error!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！现在我们有了类似[第3章](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=27&action=edit#post_26)的东西，*使用字符驱动程序*！然而，这一次，如果我们尝试使用`mknod`创建一个特殊字符文件，并尝试从中读取，我们会得到一个错误！
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The kernel tells us that the device doesn't exist! This is because we have not
    yet created anything, but just reserved some kernel internal data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 内核告诉我们设备不存在！这是因为我们还没有创建任何东西，只是保留了一些内核内部数据。
- en: 'In *step 4*,the first fields are just relative to our specific implementation,
    while the last four are present in almost every character driver implementation:
    the  `id` field is just a unique identifier of each `chrdev` (remember that our
    implementation supports `MAX_DEVICES` instances), the  `owner` pointer is used
    to store the owner of our driver''s module, the  `cdev` structure holds all of
    the kernel data about our character device, and the  `dev` pointer points to a
    kernel `struct device` related to the one we specify in the device tree.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*中，前面的字段只是相对于我们特定的实现，而最后四个字段几乎出现在每个字符驱动程序实现中：`id`字段只是每个`chrdev`的唯一标识符（请记住我们的实现支持`MAX_DEVICES`实例），`owner`指针用于存储我们驱动程序模块的所有者，`cdev`结构保存了关于我们字符设备的所有内核数据，`dev`指针指向了与设备树中指定的设备相关的内核`struct
    device`。
- en: So, `cdev_init()` is used to initialize `cdev` with our file operations; `cdev_add()` is
    used to define major and minor numbers of our driver; `device_create()` is used
    to glue the `devt` data to the data pointed to by `dev`; and our `chrdev` class
    (represented by the  `chrdev_class` pointer) actually creates the character device.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`cdev_init()`用于使用我们的文件操作初始化`cdev`；`cdev_add()`用于定义驱动程序的主要和次要编号；`device_create()`用于将`devt`数据与由`dev`指向的数据连接起来；我们的`chrdev`类（由`chrdev_class`指针表示）实际上创建了字符设备。
- en: 'However, the  `chrdev_device_register()` function is not called by any function
    in the `chrdev.c` file; this is why it has been declared as an exported symbol
    using the  `EXPORT_SYMBOL()` definition. In fact, this function is called the 
     `chrdev_req_probe()` function, defined in another module as a file named `chrdev-req.c`, which
    is reported in the following snippet. The function first understands how many
    devices we have to register:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`chrdev_device_register()`函数并没有被`chrdev.c`文件中的任何函数调用；这就是为什么它被声明为一个导出符号，使用`EXPORT_SYMBOL()`定义。事实上，这个函数被另一个模块中的`chrdev-req.c`文件中定义的`chrdev_req_probe()`函数调用，如下面的片段所示。该函数首先了解我们需要注册多少设备：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, for each device, after reading the device''s properties, the  `chrdev_device_register()` calls to
    register the device on the system (and it will do for every device reported in
    the device tree as illustrated in the preceding code):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于每个设备，在读取设备的属性之后，`chrdev_device_register()`调用来在系统上注册设备（对于设备树中报告的每个设备都会这样做，如前面的代码所示）：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'But how can the system know when the  `chrdev_req_probe()` function must be
    called? Well, it''s quite clear if we keep reading `chrdev-req.c`; in fact, near
    the end, we find the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 但是系统如何知道何时调用`chrdev_req_probe()`函数呢？如果我们继续阅读`chrdev-req.c`，就会很清楚；事实上，在接近结尾的地方，我们找到了以下代码：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When we insert the `chrdev-req.ko` module into the kernel, we define a new platform
    driver by using `module_platform_driver()`, then the kernel starts looking for
    a node with the `compatible` property set to `"ldddc,chrdev"`; if found, it executes
    the function pointed at by the `probe` pointer we set to `chrdev_req_probe()`.
    This causes a new driver to be registered.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`chrdev-req.ko`模块插入内核时，我们使用`module_platform_driver()`定义了一个新的平台驱动程序，然后内核开始寻找一个节点，其`compatible`属性设置为`"ldddc,chrdev"`；如果找到了，就执行由我们设置为`chrdev_req_probe()`的`probe`指针指向的函数。这将导致注册一个新的驱动程序。
- en: 'Before showing how it works, let''s take a look at the opposite steps, intended
    to deallocate whatever we requested from the kernel during character driver allocation.
    When we remove the `chrdev-req.ko` module, the kernel invokes the platform driver''s `remove` function,
    that is `chrdev_req_remove()` in the `chrdev-req.c` file, as partially reported
    in the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示它是如何工作之前，让我们看看相反的步骤，用于释放我们在字符驱动程序分配期间从内核请求的任何内容。当我们移除`chrdev-req.ko`模块时，内核会调用平台驱动程序的`remove`函数，即`chrdev-req.c`文件中的`chrdev_req_remove()`，部分如下所示：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This function, which is inside the `chrdev.c` file, calls `chrdev_device_unregister()` (for
    each `chrdev` node in the device tree) and is reported in the following; and it
    starts by doing some sanity checks:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数，位于`chrdev.c`文件中，调用`chrdev_device_unregister()`（对于设备树中的每个`chrdev`节点），如下所示；它首先进行一些健全性检查：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'But then it unregisters the driver by using the  `device_destroy()` and `cdev_del()` functions:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后它使用`device_destroy()`和`cdev_del()`函数注销驱动程序：
- en: '[PRE44]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Using a device tree is not just useful for describing a peripheral (and then
    the whole system); by using it, we can also gain access to several ready-to-use
    features that Linux offers to kernel developers. So let's take a look at the most
    important (and useful) ones.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用设备树不仅仅用于描述外围设备（以及整个系统）；通过使用它，我们还可以访问Linux为内核开发人员提供的几个现成的有用功能。因此，让我们来看看最重要（和有用）的功能。
- en: How device files are created in /dev
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: /dev中如何创建设备文件
- en: In [Chapter 3](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml), *Working with Char
    Drivers*, when we created a new character device nothing happened in the user
    space and we had to create a character device file by hand using the `mknod` command;
    however, in this chapter, when we inserted the second kernel module, which created
    our new `chrdev` devices. By getting their properties from the device tree, in
    the `/dev` directory, two new character files were automatically created.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml)中，*使用字符驱动程序*，当我们创建一个新的字符设备时，用户空间中什么都没有发生，我们不得不手动使用`mknod`命令创建一个字符设备文件；然而，在本章中，当我们插入第二个内核模块时，它创建了我们的新`chrdev`设备。通过从设备树中获取它们的属性，在`/dev`目录中，两个新的字符文件被自动创建。
- en: It's Linux's kernel object mechanism that implements this magic; let's see how.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正是Linux的内核对象机制实现了这一点；让我们看看是如何实现的。
- en: Whenever a new device is created in the kernel, a new kernel event is generated
    and sent to the user space; this new event is then captured by a dedicated application
    that interprets it. These special applications may vary but the most famous application
    of this type used by almost all important Linux distributions is the `udev` application.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 每当内核中创建新设备时，都会生成一个新的内核事件并发送到用户空间；然后专用应用程序会捕获这个新事件并对其进行解释。这些特殊的应用程序可能各不相同，但几乎所有重要的Linux发行版都使用的最著名的这种类型的应用程序是`udev`应用程序。
- en: The `udev` daemon is born to replace and create a mechanism to automatically
    create special device files under the `/dev` directory, and it works so well that
    it is now used for several different tasks. In fact, the `udev` daemon receives
    device kernel events (called **uevents**) directly from the kernel whenever a
    device is added or removed from the system (or when it changes its state), and
    for each event, it executes a set of rules according to its configuration files.
    A rule is executed if it matches various device attributes and it then creates
    new files in the `/dev` directory accordingly; a matching rule may also provide
    additional device information to be used to create meaningful symlink names, execute
    scripts, and much more!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`udev`守护程序是为了替换和创建一个机制，以自动在`/dev`目录下创建特殊设备文件，并且它运行得非常好，以至于现在用于多种不同的任务。实际上，`udev`守护程序直接从内核接收设备内核事件（称为**uevents**），每当系统添加或删除设备（或更改其状态）时，它都会执行一组规则，根据其配置文件。如果规则匹配各种设备属性，则会执行规则，然后相应地在`/dev`目录中创建新文件；匹配规则还可以提供其他设备信息，用于创建有意义的符号链接名称，执行脚本等等！'
- en: For further information regarding `udev` rules, a good starting point is a related
    page in the Debian Wiki at [https://wiki.debian.org/udev](https://wiki.debian.org/udev)[.](https://wiki.debian.org/udev)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`udev`规则的更多信息，一个很好的起点是Debian Wiki上的相关页面[https://wiki.debian.org/udev](https://wiki.debian.org/udev)。
- en: 'To monitor these events, we can use the `udevadm` tool, which comes within
    the `udev` package as reported in the following command line:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要监视这些事件，我们可以使用`udevadm`工具，该工具包含在`udev`软件包中，如以下命令所示：
- en: '[PRE45]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: By using the `monitor` subcommand, we select the  `udevadm` monitor features
    (since `udevadm` can do several other tasks) and by specifying the `-k` option
    argument we ask for kernel-generated messages only to be displayed (since some
    messages may come from the userspace too); also, by using the `-p`  option argument,
    we ask for event properties to be displayed and, with the `-s` option argument,
    we select messages from the subsystem matching the `chrdev` string only.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`monitor`子命令，我们选择`udevadm`监视功能（因为`udevadm`还可以执行其他几项任务），并通过指定`-k`选项参数，要求仅显示内核生成的消息（因为一些消息可能也来自用户空间）；此外，通过使用`-p`选项参数，我们要求显示事件属性，并通过`-s`选项参数，我们仅选择与`chrdev`字符串匹配的子系统的消息。
- en: To see all kernel messages, during the `chrdev` module insertion the kernel
    sends just execute `udevadm monitor` command, dropping all of these option arguments.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有内核消息，在`chrdev`模块插入时，内核发送的只需执行`udevadm monitor`命令，放弃所有这些选项参数。
- en: 'To see new events, just execute the above command, and, in another terminal
    (or directly from the serial console) repeat the kernel module insertion. After
    inserting the `chrdev-req.ko` module we see the same kernel messages as before:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看新事件，只需执行上述命令，并在另一个终端（或直接从串行控制台）重复内核模块插入。在插入`chrdev-req.ko`模块后，我们看到与之前相同的内核消息：
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'However, in the terminal where we executed the `udevadm` message, we should
    now see something like the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们执行`udevadm`消息的终端中，现在应该看到类似以下的内容：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These are the kernel messages informing `udev` that two new devices named `/dev/cdev-eeprom@2`
    and `/dev/cdev-rom@4` have been created (with other properties), so `udev` has
    all the information it needs to create new files under the `/dev` directory.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是内核消息，通知`udev`已创建了两个名为`/dev/cdev-eeprom@2`和`/dev/cdev-rom@4`的新设备（具有其他属性），因此`udev`已经拥有了创建`/dev`目录下新文件所需的所有信息。
- en: Downloading the firmware
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载固件
- en: 'By using the device tree, we''re now able to specify a lot of different settings
    for our driver, but there is still one last thing we have to see: how to load
    firmware into our device. In fact, some devices may require a program for themselves
    to work which, for license reasons, cannot be linked within the kernel.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用设备树，我们现在能够为我们的驱动程序指定许多不同的设置，但还有最后一件事情我们必须看到：如何将固件加载到我们的设备中。实际上，一些设备可能需要一个程序才能正常工作，出于许可证原因，这些程序不能链接到内核中。
- en: In this section, we're going to see some examples of how we can ask the kernel
    to load firmware for our device.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到一些示例，说明我们如何要求内核为我们的设备加载固件。
- en: Getting ready
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Some peripherals need firmware to work and then we need a mechanism to load
    such binary data into them. Linux provides us with different mechanisms to do
    this job and they all refer to the `request_firmware()` function.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一些外围设备需要固件才能工作，然后我们需要一种机制将这些二进制数据加载到其中。 Linux为我们提供了不同的机制来完成这项工作，它们都与`request_firmware()`函数有关。
- en: 'Whenever we use a `request_firmware(..., "filename", ...)` function call (or
    one of its friends) in our driver (specifying a filename), the kernel starts looking
    at different locations:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在驱动程序中使用`request_firmware(..., "filename", ...)`函数调用（指定文件名）时，内核开始查看不同的位置：
- en: First of all, it takes a look at the boot image file and, in case, the firmware
    is loaded from it; this is because we can bundle binary code with the kernel during
    compilation. However, this solution is permitted only if the firmware is free
    software; otherwise it cannot be linked to Linux. It is also not very flexible
    when changing firmware data if we have to recompile the kernel too.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它查看引导映像文件，并在必要时从中加载固件；这是因为我们可以在编译期间将二进制代码与内核捆绑在一起。但是，只有在固件是自由软件的情况下才允许此解决方案；否则它不能链接到Linux。如果我们必须重新编译内核来更改固件数据，这种解决方案在更改固件数据时也不够灵活。
- en: If no data has been stored within the kernel, it starts to load the firmware
    data directly from the filesystem by looking for the `filename` in several path
    locations starting from the one specified for the kernel command line with the `firmware_class.path="<path>"`
    option argument, then in `/lib/firmware/updates/<UTS_RELEASE>`, then into `/lib/firmware/updates`,
    then into `/lib/firmware/<UTS_RELEASE>`, and, finally, in the  `/lib/firmware` directory.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果内核中没有存储任何数据，它将开始直接从文件系统加载固件数据，从指定内核命令行的路径开始查找`filename`，然后在`/lib/firmware/updates/<UTS_RELEASE>`，然后进入`/lib/firmware/updates`，然后进入`/lib/firmware/<UTS_RELEASE>`，最后进入`/lib/firmware`目录。
- en: '`<UTS_RELEASE>` is the kernel release version number, which can be obtained
    directly from the kernel by using the `uname -r` command as in the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`<UTS_RELEASE>`是内核发布版本号，可以通过使用`uname -r`命令直接从内核中获取，如下所示：'
- en: '`$ uname -r`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ uname -r`'
- en: '`4.15.0-45-generic`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`4.15.0-45-generic`'
- en: 'If this last step fails too, then the kernel may try a fallback procedure,
    which consists of enabling the firmware loader user helper. This last chance to
    load firmware must be enabled for the kernel configuration by enabling the following
    kernel configuration settings:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果最后一步也失败了，那么内核可能会尝试回退程序，这包括启用固件加载器用户辅助程序。必须通过启用以下内核配置设置来启用内核的最后一次加载固件：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: By using the usual `make menuconfig` method, we have to go through Device Drivers,
    then Generic Driver Options, and Firmware loader entries to enable them (see the
    following screenshot).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用通常的`make menuconfig`方法，我们必须通过设备驱动程序，然后通用驱动程序选项，固件加载器条目来启用它们（参见下面的屏幕截图）。
- en: '![](img/8414861b-4598-45f0-a655-6a71fa163629.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8414861b-4598-45f0-a655-6a71fa163629.png)'
- en: After we have enabled these settings and recompiled the kernel, we can explore,
    in detail, how we can load custom firmware for our driver within the kernel.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用这些设置并重新编译内核后，我们可以详细了解如何在内核中为我们的驱动程序加载自定义固件。
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: First, we need a modified version of the `chrdev-req.c` file focused on firmware
    loading; that's why it's better to use another file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个专注于固件加载的修改版本的`chrdev-req.c`文件；这就是为什么最好使用另一个文件。
- en: 'To do our job, we can use the `chrdev-fw.c` file with the following device
    definitions:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的工作，我们可以使用`chrdev-fw.c`文件和以下设备定义：
- en: '[PRE49]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The  `chrdev-fw.c` file can be found in the GitHub sources for this chapter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`chrdev-fw.c`文件可以在本章的GitHub源中找到。'
- en: 'In this situation, our probing function can be implemented as follows, where
    at the beginning of the `chrdev_req_probe()` function we read some of the device''s
    properties:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的探测功能可以实现如下，`chrdev_req_probe()`函数的开头我们读取设备的一些属性：
- en: '[PRE50]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We then register the char device:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们注册字符设备：
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'A former device type calls the  `chrdev_load_fw_wait()` function, which carries
    out the next steps. It starts by requesting the firmware''s data structure:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以前的设备类型调用`chrdev_load_fw_wait()`函数，执行下一步。它首先请求固件的数据结构：
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'It then dumps the data received and finally releases the firmware''s previously
    allocated data structure:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后转储接收到的数据，最后释放先前分配的固件数据结构：
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `FIRMWARE_VER` and `FIRMWARE_NLEN` macros have been defined within the  `chrdev-fw.c` file as
    shown in the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`FIRMWARE_VER`和`FIRMWARE_NLEN`宏已经在`chrdev-fw.c`文件中定义如下：'
- en: '`#define FIRMWARE_VER     "1.0.0"`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`#define FIRMWARE_VER "1.0.0"`'
- en: '`#define FIRMWARE_NLEN    128`'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`#define FIRMWARE_NLEN 128`'
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1*, in the `of_chrdev_req_match[]` array, we now have two devices that
    we can use to test different ways of loading firmware. One device, named `ldddc,chrdev-fw_wait` can
    be used to test direct firmware loading from the filesystem, while the other,
    named `ldddc,chrdev-fw_nowait`, can be used to test the firmware loader's user
    helper.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1*中，在`of_chrdev_req_match[]`数组中，我们现在有两个设备可以用来测试不同的固件加载方式。一个名为`ldddc,chrdev-fw_wait`的设备可以用来测试直接从文件系统加载固件，而另一个名为`ldddc,chrdev-fw_nowait`的设备可以用来测试固件加载器的用户辅助程序。
- en: I used these two examples to show the reader two different firmware loading
    techniques but, in reality, these two methods can be used for different purposes;
    the former can be used whenever our device needs its firmware since the startup
    otherwise it cannot work (this forces the driver not being built-in), while the
    former can be used when our device can be partially used even without any firmware
    and it can be loaded later after device initialization (which removes the mandatory
    built-in form).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用这两个示例来向读者展示两种不同的固件加载技术，但实际上，这两种方法可以用于不同的目的；前者可以在我们的设备需要其固件时使用，否则它无法工作（这会强制驱动程序不内置），而后者可以在我们的设备即使没有任何固件也可以部分使用，并且可以在设备初始化后稍后加载（这会删除强制内置形式）。
- en: In *step 2*, after reading the `firmware` property (holding the firmware file
    name) we check if the device is compatible with the `ldddc,chrdev-fw_wait` or `ldddc,chrdev-fw_nowait` device and
    then we call the proper firmware loading function, accordingly, before registering
    the new device.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，在读取`firmware`属性（保存固件文件名）后，我们检查设备是否与`ldddc,chrdev-fw_wait`或`ldddc,chrdev-fw_nowait`设备兼容，然后调用适当的固件加载函数，然后注册新设备。
- en: In *step 3*,the  `chrdev_load_fw_wait()` function builds up a filename in the
     `<name>-<version>.bin` form and then calls the effective firmware loading function
    named `request_firmware()`. In response, this function may return an error, which
    causes an error during the driver loading, or it can return a proper structure
    holding the firmware into the `buffer fw->data` pointer with the `long fw->size` size bytes.
    The `dump_data()` function simply dumps firmware data by printing it into kernel
    messages, but the   `release_firmware()` function is important and must be called
    to inform the kernel we have read all data and finished with it, and then it can
    release the resource.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，`chrdev_load_fw_wait()`函数构建了一个以`<name>-<version>.bin`形式的文件名，然后调用了名为`request_firmware()`的有效固件加载函数。作为响应，这个函数可能返回一个错误，导致驱动程序加载时出现错误，或者它可以返回一个包含固件的适当结构，该结构将固件保存在`buffer
    fw->data`指针中，大小为`long fw->size`字节。`dump_data()`函数通过将固件数据打印到内核消息中来简单地转储固件数据，但`release_firmware()`函数很重要，必须调用它来通知内核我们已经读取了所有数据并完成了处理，然后它可以释放资源。
- en: On the other hand, if we specify the `ldddc,chrdev-fw_nowait` device in the
    device tree, then the  `chrdev_load_fw_nowait()` function is called instead. This
    function operates in a similar manner as before, but at the end, it calls `request_firmware_nowait()`, which
    works like `request_firmware()`. However, if the firmware is not loaded directly
    from the filesystem, it executes the fallback procedure, which involves the firmware
    loader's user helper. This special helper sends a uevent message to the `udev` tool (or
    similar), which causes automatic firmware loading, or the creation of an entry
    within sysfs, which can be used by the user to manually load the kernel.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果在设备树中指定了`ldddc,chrdev-fw_nowait`设备，那么将调用`chrdev_load_fw_nowait()`函数。这个函数的操作方式与之前类似，但最后会调用`request_firmware_nowait()`，它的工作方式类似于`request_firmware()`。然而，如果固件不是直接从文件系统加载的，它会执行回退程序，涉及固件加载器的用户辅助程序。这个特殊的辅助程序会向`udev`工具（或类似工具）发送uevent消息，导致自动加载固件，或在sysfs中创建一个条目，用户可以用它来手动加载内核。
- en: 'The  `chrdev_load_fw_nowait()` function has the following body:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`chrdev_load_fw_nowait()`函数的主体如下：'
- en: '[PRE54]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Some important difference between `request_firmware_nowait()` and `request_firmware()` is
    that the former defines a callback function, which is invoked whenever the firmware
    is actually loaded from the user space, and it has, as a second parameter, a Boolean,
    which can be used to ask the kernel to send, or not, a uevent message to the userspace.
    By using a value, we achieve functionality similar to `request_firmware()`, while
    if we specify a false value (as in our case), we force manual firmware loading.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`request_firmware_nowait()`和`request_firmware()`之间的一些重要区别是，前者定义了一个回调函数，每当固件实际从用户空间加载时就会调用该函数，并且它有一个布尔值作为第二个参数，可以用来要求内核向用户空间发送uevent消息或不发送。通过使用一个值，我们实现了类似于`request_firmware()`的功能，而如果我们指定了一个false值（如我们的情况），我们强制手动加载固件。'
- en: 'Then, when a userspace process takes the required steps to load the desired
    firmware, the callback function is used and we can actually load firmware data
    as shown in the following example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当用户空间进程采取所需的步骤来加载所需的固件时，将使用回调函数，我们可以像下面的例子中那样实际加载固件数据：
- en: '[PRE55]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this function, we actually take the same steps as before to dump firmware
    data within kernel messages.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们实际上采取了与之前相同的步骤，将固件数据转储到内核消息中。
- en: There's more
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'Let''s just verify how everything works in this recipe. As the first step,
    let''s try using the  `ldddc,chrdev-fw_wait` device, which uses the `request_firmware()`
    function; we need the next entry in the device tree:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证一下这个步骤中的所有操作。作为第一步，让我们尝试使用`ldddc,chrdev-fw_wait`设备，它使用`request_firmware()`函数；我们需要在设备树中添加下一个条目：
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then we have to compile the code, and we can do this by simply adding our new  `chrdev-fw.c` file into
    the `makefile` as shown in the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要编译代码，可以通过将新的`chrdev-fw.c`文件添加到`makefile`中来实现，如下所示：
- en: '[PRE57]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Once we have our new modules within ESPRESSObin''s filesystem, we can try inserting
    them into the kernel as shown here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在ESPRESSObin的文件系统中有了新的模块，我们可以尝试将它们插入内核，如下所示：
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As we can see, the kernel tries to load the `chrdev-wait-1.0.0.bin` file, but
    it cannot find it since it simply doesn't exist in the filesystem; then, the kernel
    moves to sysfs fallback, but since it fails again we get an error and the driver
    loading fails too.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，内核尝试加载`chrdev-wait-1.0.0.bin`文件，但由于文件系统中根本不存在，它找不到文件；然后，内核转到sysfs回退，但由于再次失败，我们会得到一个错误，驱动程序加载也会失败。
- en: 'To get a positive result, we must add a file named `chrdev-wait-1.0.0.bin`
    into one of the search paths; for instance, we can put it in `/lib/firmware/`
    as seen in the following example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得积极的结果，我们必须在搜索路径中添加一个名为`chrdev-wait-1.0.0.bin`的文件；例如，我们可以将它放在`/lib/firmware/`中，如下例所示：
- en: '[PRE59]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If the `/lib/firmware` directory doesn't exist, we can just create it using
    the `mkdir /lib/firmware` command.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`/lib/firmware`目录不存在，我们可以使用`mkdir /lib/firmware`命令来创建它。
- en: 'Now we can retry loading our `chrdev-fw.ko` module as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试加载我们的`chrdev-fw.ko`模块，如下所示：
- en: '[PRE60]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Perfect! Now the firmware has been loaded as desired and the `chrdev` device
    has been correctly created.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在固件已经按预期加载，`chrdev`设备已经正确创建。
- en: 'Now we can try using the second device by modifying the device tree as follows
    and then rebooting the ESPRESSObin with the new DTB file:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以尝试使用第二个设备，方法是修改设备树如下，然后重新启动ESPRESSObin并使用新的DTB文件：
- en: '[PRE61]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'With these new configuration settings, if we try to load the `chrdev` module,
    we get the following messages:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些新的配置设置，如果我们尝试加载`chrdev`模块，我们会得到以下消息：
- en: '[PRE62]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This time, the kernel still tries to directly load firmware from the filesystem,
    but it fails because no file named  `chrdev-nowait-1.0.0.bin` exists; it then
    falls back to the fallback firmware loader user helper, which we've forced into
    manual mode. However, the driver's probing function successfully registers our
    `chrdev` driver, which is now fully functional even if no firmware has been loaded
    yet.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，内核仍然尝试直接从文件系统加载固件，但失败了，因为没有名为`chrdev-nowait-1.0.0.bin`的文件；然后它退回到回退固件加载器用户助手，我们已经强制进入手动模式。然而，驱动程序的探测功能成功注册了我们的`chrdev`驱动程序，即使没有加载固件，它现在也是完全功能的。
- en: 'To manually load firmware, we can use special sysfs entries in the `/sys/class/firmware/`
    directory as shown in the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动加载固件，我们可以使用`/sys/class/firmware/`目录中的特殊sysfs条目，如下所示：
- en: '[PRE63]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The  `chrdev-nowait-1.0.0.bin` directory is called as the string passed as
    `fw_name` parameter to `request_firmware_nowait()` function, and, inside it, we
    find the following files:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`chrdev-nowait-1.0.0.bin`目录被作为传递给`request_firmware_nowait()`函数的`fw_name`参数的字符串调用，并且在其中，我们找到以下文件：'
- en: '[PRE64]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, the required steps to automatically load firmware are as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，自动加载固件的必需步骤如下：
- en: '[PRE65]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We start the download procedure by writing `1` into the `loading` file, then
    we have to copy all the firmware data into the `data` file; we then finish the
    download by writing `0` in the `loading` file. As soon as we do this, the kernel
    calls our driver's callback and the firmware is loaded.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向`loading`文件写入`1`来开始下载过程，然后我们必须将所有固件数据复制到`data`文件中；然后我们通过在`loading`文件中写入`0`来完成下载。一旦我们这样做，内核就会调用我们驱动程序的回调函数，固件就会被加载。
- en: See also
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For further information regarding firmware loading, a good starting point is
    the Linux driver implementer's API guide, available online at [https://www.kernel.org/doc/html/v5.0/driver-api/firmware/request_firmware.html](https://www.kernel.org/doc/html/v5.0/driver-api/firmware/request_firmware.html).
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关固件加载的更多信息，一个很好的起点是Linux驱动实现者的API指南，可在线获取，网址为[https://www.kernel.org/doc/html/v5.0/driver-api/firmware/request_firmware.html](https://www.kernel.org/doc/html/v5.0/driver-api/firmware/request_firmware.html)。
- en: Configuring CPU pins for specific peripherals
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为特定外围设备配置CPU引脚
- en: As the device driver developer, this task is really important because to be
    able to talk with external devices (or internal ones but with external signal
    lines) we must be sure that each CPU pin is properly configured to talk with these
    external signals. In this recipe, we will look at how we can use the device tree
    to configure CPU pins.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 作为设备驱动程序开发人员，这个任务非常重要，因为为了能够与外部设备（或者内部设备但带有外部信号线）进行通信，我们必须确保每个CPU引脚都被正确配置以与这些外部信号进行通信。在这个教程中，我们将看看如何使用设备树来配置CPU引脚。
- en: How to do it...
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Just as a simple example, let's try to modify the pin configuration for our
    ESPRESSObin.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 举个简单的例子，让我们尝试修改ESPRESSObin的引脚配置。
- en: 'First of all, we should take a look at the current configuration by looking
    at sysfs in the  `/sys/bus/platform/drivers/mvebu-uart/` directory, where we verify
    that only one UART is currently enabled:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们应该通过查看`/sys/bus/platform/drivers/mvebu-uart/`目录中的sysfs来查看当前的配置，从中我们可以验证当前只有一个UART被启用：
- en: '[PRE66]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then the `mvebu-uart` drivers manage the  `d0012000.serial` device, which can
    be accessed using the `/dev/ttyMV0` file. We can also verify how the CPU''s pins
    are configured by taking a look at the `/sys/kernel/debug/pinctrl/d0013800.pinctrl-armada_37xx-pinctrl/pinmux-pins` file in
    debugfs, where we can see that only the `uart1` group is enabled:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`mvebu-uart`驱动程序管理`d0012000.serial`设备，可以使用`/dev/ttyMV0`文件进行访问。我们还可以通过查看`/sys/kernel/debug/pinctrl/d0013800.pinctrl-armada_37xx-pinctrl/pinmux-pins`文件在debugfs中验证CPU的引脚是如何配置的，我们可以看到只有`uart1`组被启用：
- en: '[PRE67]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: For further information about debugfs, see [https://en.wikipedia.org/wiki/Debugfs](https://en.wikipedia.org/wiki/Debugfs)
    [and then following some external links.](https://en.wikipedia.org/wiki/Debugfs)
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有关debugfs的更多信息，请参阅[https://en.wikipedia.org/wiki/Debugfs](https://en.wikipedia.org/wiki/Debugfs)
    [然后跟随一些外部链接。](https://en.wikipedia.org/wiki/Debugfs)
- en: 'We should then try to modify ESPRESSObin''s DTS file to enable another UART
    device named `uart1` with its own pins defined in the  `uart2_pins` group as follows:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们应该尝试修改ESPRESSObin的DTS文件，以启用另一个名为`uart1`的UART设备，其自己的引脚定义在`uart2_pins`组中，如下所示：
- en: '[PRE68]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This pin group is defined in the `linux/arch/arm64/boot/dts/marvell/armada-37xx.dtsi` file as
    follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这个引脚组在`linux/arch/arm64/boot/dts/marvell/armada-37xx.dtsi`文件中定义如下：
- en: '[PRE69]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: How it works...
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Let''s check how this works by testing our pinctrl modification. For this,
    we have to regenerate ESPRESSObin''s DTB file, as usual, and restart the system.
    If everything works well, we should now have two UART devices as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过测试我们的pinctrl修改来检查这是如何工作的。为此，我们必须像往常一样重新生成ESPRESSObin的DTB文件，并重新启动系统。如果一切顺利，我们现在应该有两个UART设备，如下所示：
- en: '[PRE70]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Also, if we take another look in the  `/sys/kernel/debug/pinctrl/d0013800.pinctrl-armada_37xx-pinctrl/pinmux-pins` file, we
    see that this time the `uart2` pins group has been added and then our new serial
    port is available on extension connector P9 at pins 24 and 26.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们再次查看`/sys/kernel/debug/pinctrl/d0013800.pinctrl-armada_37xx-pinctrl/pinmux-pins`文件，我们会发现这次`uart2`引脚组已经被添加，然后我们的新串行端口可以在P9扩展连接器的24号和26号引脚上使用。
- en: See also
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For further information regarding the pinctrl subsystem, a good starting point
    is [https://www.kernel.org/doc/Documentation/pinctrl.txt](https://www.kernel.org/doc/Documentation/pinctrl.txt).
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关pinctrl子系统的更多信息，一个很好的起点是[https://www.kernel.org/doc/Documentation/pinctrl.txt](https://www.kernel.org/doc/Documentation/pinctrl.txt)。
