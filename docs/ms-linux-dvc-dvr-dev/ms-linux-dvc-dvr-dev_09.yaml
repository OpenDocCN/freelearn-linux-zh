- en: '*Chapter 7*: Demystifying V4L2 and Video Capture Device Drivers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：解密V4L2和视频捕获设备驱动程序'
- en: 'Video has long been inherent in embedded systems. Given that Linux is the favorite
    kernel used in such systems, it goes without saying that it natively embeds its
    support for video. This is the so-called **V4L2**, which stands for **Video 4
    (for) Linux 2**. Yes! *2* because there was a first version, *V4L*. V4L2 augments
    V4L with memory management features and other elements that make this framework
    as generic as possible. Through this framework, the Linux kernel is able to deal
    with camera devices and the bridge to which they are connected, as well as the
    associated DMA engines. These are not the only elements supported by V4L2\. We
    will begin with an introduction to framework architecture, learning how it is
    organized, and walk through the main data structures it comprises. Then, we will
    learn how to design and write the bridge device driver, the one responsible for
    DMA operations, and finally, we will delve into sub-device drivers. That said,
    in this chapter, the following topics will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 视频一直是嵌入式系统中固有的。鉴于Linux是这些系统中常用的内核，可以毫不夸张地说它本身就原生支持视频。这就是所谓的**V4L2**，代表**Video
    4 (for) Linux 2**。是的！*2*是因为有第一个版本，*V4L*。V4L2通过内存管理功能和其他元素增强了V4L，使得该框架尽可能通用。通过这个框架，Linux内核能够处理摄像头设备和它们连接的桥接器，以及相关的DMA引擎。这些并不是V4L2支持的唯一元素。我们将从框架架构的介绍开始，了解它的组织方式，并浏览它包括的主要数据结构。然后，我们将学习如何设计和编写桥接设备驱动程序，负责DMA操作，最后，我们将深入研究子设备驱动程序。因此，在本章中，将涵盖以下主题：
- en: Framework architecture and the main data structures
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架架构和主要数据结构
- en: Bridge video device drivers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频桥设备驱动程序
- en: The concept of sub-devices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子设备的概念
- en: V4L2 control infrastructure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: V4L2控制基础设施
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are prerequisites for this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的先决条件如下：
- en: Advanced computer architecture knowledge and C programming skills
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级计算机体系结构知识和C编程技能
- en: Linux kernel v4.19.X sources, available at [https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核v4.19.X源代码，可在[https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/refs/tags)获取。
- en: Framework architecture and the main data structures
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架架构和主要数据结构
- en: Video devices are becoming increasingly complex. In such devices, hardware often
    comprises several integrated IPs that need to cooperate with one another in a
    controlled manner, and this leads to complex V4L2 drivers. This requires figuring
    out the architecture prior to delving into the code and this is precisely the
    requirement that this section addresses.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 视频设备变得越来越复杂。在这种设备中，硬件通常包括多个集成IP，需要以受控的方式相互合作，这导致复杂的V4L2驱动程序。这要求在深入代码之前弄清楚架构，这正是本节要解决的要求。
- en: It is known that drivers normally mirror the hardware model in programming.
    In the V4L2 context, the diverse IP components are modeled as software blocks
    called sub-devices. V4L2 sub-devices are usually kernel-only objects. Moreover,
    if the V4L2 driver implements the media device API (which we will discuss in the
    next chapter, [*Chapter 8*](B10985_08_ePub_AM.xhtml#_idTextAnchor342), *Integrating
    with V4L2 Async and Media Controller Frameworks*), those sub-devices will automatically
    inherit from media entities, allowing applications to enumerate the sub-devices
    and to discover the hardware topology using the media framework's entities, pads,
    and link-related enumeration APIs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，驱动程序通常在编程中反映硬件模型。在V4L2上下文中，各种IP组件被建模为称为子设备的软件块。V4L2子设备通常是仅内核对象。此外，如果V4L2驱动程序实现了媒体设备API（我们将在下一章[*第8章*]（B10985_08_ePub_AM.xhtml#_idTextAnchor342）中讨论，*与V4L2异步和媒体控制器框架集成*），这些子设备将自动继承自媒体实体，允许应用程序枚举子设备并使用媒体框架的实体、端口和链接相关的枚举API来发现硬件拓扑。
- en: Notwithstanding making sub-devices discoverable, drivers can likewise decide
    to make them configurable by applications in a straightforward manner. When both
    the sub-device driver and the V4L2 device driver uphold this, sub-devices will
    feature a character device node on which **ioctls** (**input/output controls**)
    can be invoked in order to query, read, and write sub-device capabilities (including
    controls), or to even negotiate image formats on individual sub-device pads.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使子设备可发现，驱动程序也可以决定以简单的方式使其可由应用程序配置。当子设备驱动程序和V4L2设备驱动程序都支持此功能时，子设备将在其上调用**ioctls**（输入/输出控制）的字符设备节点，以便查询、读取和写入子设备功能（包括控制），甚至在单个子设备端口上协商图像格式。
- en: 'At the driver level, V4L2 does a lot of work for the driver developer so that
    they just have to implement the hardware-related code and register the relevant
    device. Before going further, we must introduce several important structures that
    constitute the core of V4L2:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在驱动程序级别，V4L2为驱动程序开发人员做了很多工作，因此他们只需实现与硬件相关的代码并注册相关设备。在继续之前，我们必须介绍构成V4L2核心的几个重要结构：
- en: '`struct v4l2_device`: A hardware device may contain multiple child devices,
    such as a TV card in addition to a capture device, and possibly a VBI device or
    FM tuner. `v4l2_device` is the root node of all of these devices and is responsible
    for managing all child devices.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct v4l2_device`：硬件设备可能包含多个子设备，例如电视卡以及捕获设备，可能还有VBI设备或FM调谐器。`v4l2_device`是所有这些设备的根节点，负责管理所有子设备。'
- en: '`struct video_device`: The main purpose of this structure is to provide the
    well-known `/dev/videoX` or `/dev/v4l-subdevX` device nodes. This structure mainly
    abstracts the capture interface, also known as the `/dev/v4l-subdevX` nodes and
    their file operations. From within the sub-device driver, only the core accesses
    this structure in the underlying sub-device.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct video_device`：此结构的主要目的是提供众所周知的`/dev/videoX`或`/dev/v4l-subdevX`设备节点。此结构主要抽象了捕获接口，也称为`/dev/v4l-subdevX`节点及其文件操作。在子设备驱动程序中，只有核心访问底层子设备中的这个结构。'
- en: '`struct vb2_queue`: For me, this is the main data structure in the video driver,
    as it is used in the real logic of data streaming and the center part of the DMA
    operations, along with `struct vb2_v4l2_buffer`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct vb2_queue`：对我来说，这是视频驱动程序中的主要数据结构，因为它在数据流逻辑和DMA操作的中心部分中使用，以及`struct
    vb2_v4l2_buffer`。'
- en: '`struct v4l2_subdev`: This is the sub-device responsible for implementing specific
    functions and abstracting a specific function in the video system of the SoC.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct v4l2_subdev`：这是负责实现特定功能并在SoC的视频系统中抽象特定功能的子设备。'
- en: '`struct video_device` can be regarded as the base class for all devices and
    sub-devices. When we write our own drivers, access to this data structure may
    be direct (if we are dealing with a bridge driver) or indirect (if we are dealing
    with a sub-device, because sub-device APIs abstract and hide the underlying `struct
    video_device` embedded into each sub-device data structure).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct video_device`可以被视为所有设备和子设备的基类。当我们编写自己的驱动程序时，对这个数据结构的访问可能是直接的（如果我们正在处理桥接驱动程序）或间接的（如果我们正在处理子设备，因为子设备API抽象和隐藏了嵌入到每个子设备数据结构中的底层`struct
    video_device`）。'
- en: Now we are aware of the data structures this framework is made of. Moreover,
    we introduced their relationships and their respective purposes. It is now time
    for us to go deeper into the details by introducing how to initialize and register
    a V4L2 device with the system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了这个框架由哪些数据结构组成。此外，我们介绍了它们的关系和各自的目的。现在是时候深入了解细节，介绍如何初始化和注册V4L2设备到系统中了。
- en: Initializing and registering a V4L2 device
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化和注册V4L2设备
- en: 'Prior to being used or part of the system, the V4L2 device must be initialized
    and registered, and this is the main topic of this section. Once the framework
    architecture description is complete, we can start going through the code. In
    this kernel, a V4L2 device is an instance of the `struct v4l2_device` structure.
    This is the highest data structure in the media framework, maintaining a list
    of sub-devices the media pipe is comprised of and acting as the parent of the
    bridge device. V4L2 drivers should include `<media/v4l2-device.h>`, which will
    bring in the following definition of a `struct v4l2_device`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在被使用或成为系统的一部分之前，V4L2设备必须被初始化和注册，这是本节的主要内容。一旦框架架构描述完成，我们就可以开始阅读代码了。在这个内核中，V4L2设备是`struct
    v4l2_device`结构的一个实例。这是媒体框架中的最高数据结构，维护着媒体管道由哪些子设备组成，并充当桥接设备的父级。V4L2驱动程序应该包括`<media/v4l2-device.h>`，这将引入`struct
    v4l2_device`的以下定义：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Unlike other video-related data structures that we will introduce in the following
    sections, there are only a few fields in this structure. Their meanings are as
    follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们将在以下部分介绍的其他与视频相关的数据结构不同，此结构中只有少数字段。它们的含义如下：
- en: '`dev` is a pointer to the parent `struct device` for this V4L2 device. This
    will be automatically set upon registration, and `dev->driver_data` will point
    to this `v4l2` struct.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`是指向此V4L2设备的父`struct device`的指针。这将在注册时自动设置，`dev->driver_data`将指向这个`v4l2`结构。'
- en: '`mdev` is a pointer to a `struct media_device` object to which this V4L2 device
    belongs. This field deals with the media controller framework and will be introduced
    in the related section. This may be `NULL` if integration with the media controller
    framework is not required.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mdev`是指向此V4L2设备所属的`struct media_device`对象的指针。这个字段涉及媒体控制器框架，并将在相关部分介绍。如果不需要与媒体控制器框架集成，则可能为`NULL`。'
- en: '`subdevs` is the list of sub-devices for this V4L2 device.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subdevs`是此V4L2设备的子设备列表。'
- en: '`lock` is the lock protecting access to this structure.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock`是保护对此结构的访问的锁。'
- en: '`name` is a unique name for this V4L2 device. By default, it is derived from
    the driver name plus the bus ID.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`是此V4L2设备的唯一名称。默认情况下，它是从驱动程序名称加上总线ID派生的。'
- en: '`notify` is a pointer to a notification callback, called by a sub-device to
    inform this V4L2 device of some events.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notify`是指向通知回调的指针，由子设备调用以通知此V4L2设备某些事件。'
- en: '`ctrl_handler` is the control handler associated with this device. It keeps
    track of all of the controls this V4L2 device has. This may be `NULL` if there
    are no controls.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctrl_handler`是与此设备关联的控制处理程序。它跟踪此V4L2设备拥有的所有控件。如果没有控件，则可能为`NULL`。'
- en: '`prio` is the device''s priority state.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prio`是设备的优先级状态。'
- en: '`ref` is internally used by the core for reference counting.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ref`是核心用于引用计数的内部使用。'
- en: '`release` is the callback to be called when the last user of this structure
    goes off.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release`是当此结构的最后一个用户退出时要调用的回调函数。'
- en: 'This top-level structure is initialized and registered with the core by the
    same function, `v4l2_device_register()`, whose prototype is the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个顶层结构通过相同的函数`v4l2_device_register()`初始化并注册到核心，其原型如下：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first `dev` argument is normally the struct device pointer of the bridge
    bus's related device-data structure. That is `pci_dev`, `usb_device`, or `platform_device`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`dev`参数通常是桥接总线相关设备数据结构的struct device指针。即`pci_dev`、`usb_device`或`platform_device`。
- en: If the `dev->driver_data` field is `NULL`, this function will make it point
    to the actual `v4l2_dev` object being registered. Moreover, if `v4l2_dev->name`
    is empty, then it will be set to a value resulting from the concatenation of `dev
    driver name + dev device name`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`dev->driver_data`字段为`NULL`，此函数将使其指向正在注册的实际`v4l2_dev`对象。此外，如果`v4l2_dev->name`为空，则将设置为从`dev
    driver name + dev device name`的连接结果。
- en: 'However, if the `dev` parameter is `NULL`, then you must set `v4l2_dev->name`
    before calling `v4l2_device_register()`. On the other hand, a previously registered
    V4L2 device can be unregistered using `v4l2_device_unregister()` as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果 `dev` 参数为 `NULL`，则在调用 `v4l2_device_register()` 之前必须设置 `v4l2_dev->name`。另一方面，可以使用
    `v4l2_device_unregister()` 注销先前注册的 V4L2 设备，如下所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Upon a call to this function, all sub-devices will be unregistered as well.
    This is all about the V4L2 device. However, you should keep in mind that it is
    the top-level structure, maintaining a list of sub-devices of the media device
    and acting as the parent of the bridge device.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 调用此函数时，所有子设备也将被注销。这一切都与 V4L2 设备有关。但是，您应该记住，它是顶层结构，维护媒体设备的子设备列表，并充当桥接设备的父级。
- en: Now that we are done with the main V4L2 device (the one that encompasses the
    other device-related data structures) initialization and registration, we can
    introduce specific device drivers, starting with the bridge driver, which is platform-specific.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了主要的 V4L2 设备（包含其他设备相关数据结构的设备）的初始化和注册，我们可以引入特定的设备驱动程序，从桥接驱动程序开始，这是特定于平台的。
- en: Introducing video device drivers – the bridge driver
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入视频设备驱动程序 - 桥接驱动程序
- en: The bridge driver controls the platform `/USB/PCI/...` hardware that is responsible
    for the DMA transfers. This is the driver that handles data streaming from the
    device. One of the main data structures the bridge driver directly deals with
    is `struct video_device`. This structure embeds the entire element needed to perform
    video streaming, and one of its first interactions with the user space is to create
    device files in the `/dev/` directory.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接驱动程序控制平台 `/USB/PCI/...` 硬件，负责 DMA 传输。这是处理从设备进行数据流的驱动程序。桥接驱动程序直接处理的主要数据结构之一是
    `struct video_device`。此结构嵌入了执行视频流所需的整个元素，它与用户空间的第一个交互之一是在 `/dev/` 目录中创建设备文件。
- en: 'The `struct video_device` structure is defined in `include/media/v4l2-dev.h`,
    which means the driver code must contain `#include <media/v4l2-dev.h>`. The following
    is what this structure looks like from the header file where it is defined:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct video_device` 结构在 `include/media/v4l2-dev.h` 中定义，这意味着驱动程序代码必须包含 `#include
    <media/v4l2-dev.h>`。以下是在定义它的头文件中看到的这个结构的样子：'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Not only does the bridge driver play with this structure – this structure is
    the main `v4l2` structure when it comes to representing V4L2-compatible devices,
    including sub-devices. However, depending on the nature of the driver (be it a
    bridge driver or sub-device driver), some elements may vary or may be `NULL`.
    The following are descriptions of each element in the structure:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅桥接驱动程序可以操作此结构 - 当涉及表示 V4L2 兼容设备（包括子设备）时，此结构是主要的 `v4l2` 结构。但是，根据驱动程序的性质（无论是桥接驱动程序还是子设备驱动程序），某些元素可能会有所不同或可能为
    `NULL`。以下是结构中每个元素的描述：
- en: '`entity`, `intf_node`, and `pipe` are part of the integration with the media
    framework, as we will see in the section of the same name. The former abstracts
    the video device (which becomes an entity) from within the media framework, while
    `intf_node` represents the media interface device node, and `pipe` represents
    the streaming pipe to which the entity belongs.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entity`、`intf_node` 和 `pipe` 是与媒体框架集成的一部分，我们将在同名部分中看到。前者从媒体框架内部抽象出视频设备（成为实体），而
    `intf_node` 表示媒体接口设备节点，`pipe` 表示实体所属的流水线。'
- en: '`fops` represents the file operations for the video device''s file node. The
    V4L2 core overrides the virtual device file operation with some extra logic required
    by the subsystem.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fops` 表示视频设备文件节点的文件操作。V4L2 核心通过一些子系统所需的额外逻辑覆盖虚拟设备文件操作。'
- en: '`cdev` is the character device structure, abstracting the underlying `/dev/videoX`
    file node. `vdev->cdev->ops` is set with `v4l2_fops` (defined in `drivers/media/v4l2-core/v4l2-dev.c`)
    by the V4L2 core. `v4l2_fops` is actually a generic (in term of ops implemented)
    and V4L2-oriented (in terms of what these ops do) file op assigned to each `/dev/videoX`
    char device and wraps the video device-specific ops defined in `vdev->fops`. At
    their return paths, each callback in `v4l2_fops` will call its counterpart in
    `vdev->fops`. `v4l2_fops` callbacks perform a sanity check prior to invoking the
    real ops in `vdev->fops`. For example, on a `mmap()` system call issued by the
    user space on a `/dev/videoX` file, `v4l2_fops->mmap` will be invoked first, which
    will make sure that `vdev->fops->mmap` is set prior to calling it and printing
    a debug message if needed.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cdev` 是字符设备结构，抽象出底层的 `/dev/videoX` 文件节点。`vdev->cdev->ops` 由 V4L2 核心设置为 `v4l2_fops`（在
    `drivers/media/v4l2-core/v4l2-dev.c` 中定义）。`v4l2_fops` 实际上是一个通用的（在实现的操作方面）和面向 V4L2
    的（在这些操作所做的方面）文件操作，分配给每个 `/dev/videoX` 字符设备，并包装在 `vdev->fops` 中定义的视频设备特定操作。在它们的返回路径上，`v4l2_fops`
    中的每个回调将调用 `vdev->fops` 中的对应项。`v4l2_fops` 回调在调用 `vdev->fops` 中的真实操作之前执行一些合理性检查。例如，在用户空间对
    `/dev/videoX` 文件发出的 `mmap()` 系统调用上，将首先调用 `v4l2_fops->mmap`，这将确保在调用之前设置了 `vdev->fops->mmap`，并在需要时打印调试消息。'
- en: '`ctrl_handler`: The default value is `vdev->v4l2_dev->ctrl_handler`.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctrl_handler`：默认值为 `vdev->v4l2_dev->ctrl_handler`。'
- en: '`queue` is the buffer management queue associated with this device node. This
    is one of the data structures only the bridge driver can play with. This may be
    `NULL`, especially when it comes to non-bridge video drivers (sub-devices, for
    example).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queue` 是与此设备节点关联的缓冲区管理队列。这是桥接驱动程序唯一可以操作的数据结构之一。这可能是 `NULL`，特别是当涉及非桥接视频驱动程序（例如子设备）时。'
- en: '`prio` is a pointer to `&struct v4l2_prio_state` with the device''s priority
    state. If this state is `NULL`, then `v4l2_dev->prio` will be used.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prio` 是指向具有设备优先级状态的 `&struct v4l2_prio_state` 的指针。如果此状态为 `NULL`，则将使用 `v4l2_dev->prio`。'
- en: '`name` is the name of the video device.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 是视频设备的名称。'
- en: '`vfl_type` is the V4L device type. Possible values are defined by `enum vfl_devnode_type`,
    containing the following:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vfl_type` 是 V4L 设备类型。可能的值由 `enum vfl_devnode_type` 定义，包括以下内容：'
- en: '– `VFL_TYPE_GRABBER`: For video input/output devices'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VFL_TYPE_GRABBER`：用于视频输入/输出设备'
- en: '– `VFL_TYPE_VBI`: For vertical blank data (undecoded)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: – `VFL_TYPE_VBI`：用于垂直空白数据（未解码）
- en: '– `VFL_TYPE_RADIO`: For radio cards'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: – `VFL_TYPE_RADIO`：用于无线电卡
- en: '– `VFL_TYPE_SUBDEV`: For V4L2 sub-devices'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: – `VFL_TYPE_SUBDEV`：用于 V4L2 子设备
- en: '– `VFL_TYPE_SDR`: Software-defined radio'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: – `VFL_TYPE_SDR`：软件定义无线电
- en: '– `VFL_TYPE_TOUCH`: For touch sensors'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: – `VFL_TYPE_TOUCH`：用于触摸传感器
- en: '`vfl_dir` is a V4L receiver, transmitter, or memory-to-memory (denoted m2m
    or mem2mem) device. Possible values are defined by `enum vfl_devnode_direction`,
    containing the following:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vfl_dir` 是一个 V4L 接收器、发射器或内存到内存（表示为 m2m 或 mem2mem）设备。可能的值由 `enum vfl_devnode_direction`
    定义，包括以下内容：'
- en: '– `VFL_DIR_RX`: For capture devices'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: – `VFL_DIR_RX`：用于捕获设备
- en: '– `VFL_DIR_TX`: For output devices'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: – `VFL_DIR_TX`：用于输出设备
- en: '– `VFL_DIR_M2M`: should be mem2mem devices (read mem-to-mem, and also known
    as memory-to-memory devices). A mem2mem device is a device that uses memory buffers
    passed by user space applications for both the source and destination. This is
    distinct from current and existing drivers that use memory buffers for only one
    of those at a time. Such a device would be of both the **OUTPUT** and **CAPTURE**
    types in terms of V4L2\. Although no such devices are present in the V4L2 framework,
    a demand for such a model exists, for example, for ''resizer devices'' or for
    the V4L2 loopback driver.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: – `VFL_DIR_M2M`：应该是 mem2mem 设备（读取内存到内存，也称为内存到内存设备）。mem2mem 设备是使用用户空间应用程序传递的内存缓冲区作为源和目的地的设备。这与当前和现有的仅使用其中一个的内存缓冲区的驱动程序不同。这样的设备在
    V4L2 框架中不存在，但是存在对这种模型的需求，例如，用于 '调整器设备' 或 V4L2 回环驱动程序。
- en: '`v4l2_dev` is the `v4l2_device` parent device of this video device.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v4l2_dev` 是此视频设备的 `v4l2_device` 父设备。'
- en: '`dev_parent` is the device parent for this video device. If not set, the core
    will set it with `vdev->v4l2_dev->dev`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev_parent` 是此视频设备的设备父级。如果未设置，核心将使用 `vdev->v4l2_dev->dev` 进行设置。'
- en: '`ioctl_ops` is a pointer to `&struct v4l2_ioctl_ops`, which defines a set of
    ioctl callbacks.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ioctl_ops` 是指向 `&struct v4l2_ioctl_ops` 的指针，它定义了一组 ioctl 回调。'
- en: '`release` is a callback called by the core when the last user of the video
    device exits. This must be non-`NULL`.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release` 是核心在视频设备的最后一个用户退出时调用的回调。这必须是非-`NULL`。'
- en: '`lock` is a mutex serializing access to this device. It is the principal serialization
    lock by means of which all ioctls are serialized. It is common for bridge drivers
    to set this field with the same mutex as the *queue->lock*, which is the lock
    for serializing access to the queue (serializing streaming). However, if *queue->lock*
    is set, then the streaming ioctls are serialized by that separate lock.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock` 是一个互斥锁，用于串行访问此设备。这是主要的串行化锁，通过它所有的 ioctls 都被串行化。桥接驱动程序通常会使用相同的互斥锁设置此字段，就像
    *queue->lock* 一样，这是用于串行化访问队列的锁（串行化流）。但是，如果设置了 *queue->lock*，那么流 ioctls 将由单独的锁串行化。'
- en: '`num` is the actual device node index assigned by the core. It corresponds
    to the *X* in `/dev/videoX`.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num` 是核心分配的实际设备节点索引。它对应于 `/dev/videoX` 中的 *X*。'
- en: '`flags` are video device flags. You should use bit operations to set/clear/test
    flags. They contain a set of `&enum v4l2_video_device_flags` flags.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags` 是视频设备的标志。您应该使用位操作来设置/清除/测试标志。它们包含一组 `&enum v4l2_video_device_flags`
    标志。'
- en: '`fh_list` is a list of `struct v4l2_fh`, which describes a V4L2 file handler,
    enabling tracking of the number of opened file handles for this video device.
    `fh_lock` is the lock associated with this list.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fh_list` 是一个 `struct v4l2_fh` 列表，描述了一个 V4L2 文件处理程序，可以跟踪为此视频设备打开的文件句柄的数量。`fh_lock`
    是与此列表关联的锁。'
- en: '`class` corresponds to the sysfs class. It is assigned by the core. This class
    entry corresponds to the `/sys/video4linux/` sysfs directory.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class` 对应于 sysfs 类。它由核心分配。此类条目对应于 `/sys/video4linux/` sysfs 目录。'
- en: Initializing and registering the video device
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化和注册视频设备
- en: Prior to its registration, the video device can be allocated either dynamically
    using `video_device_alloc()` (which simply invokes `kzalloc()`), or statically
    embedded into a dynamically allocated structure, which is the device state structure
    most of time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册之前，视频设备可以动态分配，使用 `video_device_alloc()`（简单调用 `kzalloc()`），或者静态嵌入到动态分配的结构中，这是大多数情况下的设备状态结构。
- en: 'The video device is dynamically allocated using `video_device_alloc()`, as
    in the following example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 视频设备是使用 `video_device_alloc()` 动态分配的，就像以下示例中一样：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding excerpt, the last line provides the `release` method for the
    video device since the `.release` field must be non-`NULL`. The `video_device_release()`
    callback is provided by the kernel. It just calls `kfree()` to free the allocated
    memory.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的摘录中，最后一行提供了视频设备的 `release` 方法，因为 `.release` 字段必须是非-`NULL`。内核提供了 `video_device_release()`
    回调。它只调用 `kfree()` 来释放分配的内存。
- en: 'When it is embedded into a device state structure, the code becomes as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当它嵌入到设备状态结构中时，代码变为如下：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the video device must not be released alone as it is part of a bigger
    picture. When the video device is embedded into another structure, as in the preceding
    example, it does not require anything to be deallocated. At this point, since
    the release callback must be non-`NULL`, we can assign an empty function, such
    as `video_device_release_empty()`, also provided by the kernel.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，视频设备不能单独释放，因为它是一个更大的整体的一部分。当视频设备嵌入到另一个结构中时，就像前面的示例中一样，它不需要任何东西被释放。在这一点上，由于释放回调必须是非-`NULL`，我们可以分配一个空函数，例如
    `video_device_release_empty()`，也由内核提供。
- en: 'We are done with allocation. At this point, we can use `video_register_device()`
    in order to register the video device. The following is the prototype of this
    function:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了分配。在这一点上，我们可以使用 `video_register_device()` 来注册视频设备。以下是此函数的原型：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding prototype, `type` specifies the type of bridge device being
    registered. It will be assigned to the `vdev->vfl_type` field. In the remainder
    of the chapter, we will consider it set to `VFL_TYPE_GRABBER` since we are dealing
    with the video capture interface. `nr` is the desired device node number (*0 ==
    /dev/video0*, *1 == /dev/video1*, ...). However, setting its value to `-1` will
    instruct the kernel to pick the first free index and use it. Specifying a fixed
    index may be useful to build fancy *udev* rules since the device node name is
    known in advance. In order for the registration to succeed, the following requirements
    must be met:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述原型中，`type` 指定了要注册的桥接设备的类型。它将被分配给 `vdev->vfl_type` 字段。在本章的其余部分，我们将考虑将其设置为
    `VFL_TYPE_GRABBER`，因为我们正在处理视频捕获接口。`nr` 是所需的设备节点号（*0 == /dev/video0*，*1 == /dev/video1*，...）。但是，将其值设置为
    `-1` 将指示内核选择第一个空闲索引并使用它。指定固定索引可能对构建复杂的 *udev* 规则很有用，因为设备节点名称是预先知道的。为了使注册成功，必须满足以下要求：
- en: First, you *MUST* set the `vdev->release` function as it can't be empty. If
    you don't need it, you can pass the V4L2 core's empty release method.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，*必须* 设置 `vdev->release` 函数，因为它不能是空的。如果不需要它，可以传递 V4L2 核心的空释放方法。
- en: Second, you *MUST* set the `vdev->v4l2_dev` pointer; it should point to the
    V4L2 parent of the video device.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，*必须* 设置 `vdev->v4l2_dev` 指针；它应该指向视频设备的 V4L2 父设备。
- en: Finally, but not mandatorily, you should set `vdev->fops` and `vdev->ioctl_ops`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，但不是强制的，您应该设置 `vdev->fops` 和 `vdev->ioctl_ops`。
- en: '`video_register_device()` returns `0` when successful. However, it might fail
    if there is no free minor, if the device node number could be found, or if the
    registration of the device node failed. In either error case, it returns a negative
    error number. Each registered video device creates a directory entry in `/sys/class/video4linux`
    with some attributes inside.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`video_register_device()` 在成功时返回 `0`。但是，如果没有空闲的次要设备，找不到设备节点号，或者设备节点的注册失败，它可能会失败。在任何错误情况下，它都会返回一个负的错误号。每个注册的视频设备都会在
    `/sys/class/video4linux` 中创建一个目录条目，并在其中包含一些属性。'
- en: Important note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Minor numbers are allocated dynamically unless the kernel is compiled with the
    kernel option `CONFIG_VIDEO_FIXED_MINOR_RANGES`. In that case, minor numbers are
    allocated in ranges depending on the device node type (video, radio, and so on),
    with a total limit for `VIDEO_NUM_DEVICES`, which is set to `256`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 次要号是动态分配的，除非内核使用内核选项 `CONFIG_VIDEO_FIXED_MINOR_RANGES` 进行编译。在这种情况下，次要号根据设备节点类型（视频、收音机等）分配在不同的范围内，总限制为
    `VIDEO_NUM_DEVICES`，设置为 `256`。
- en: The `vdev->release()` callback will never be called if registration fails. In
    this case, you need to call `video_device_release()` to free the allocated `video_device`
    struct if it has been allocated dynamically, or free your own struct if the `video_device`
    was embedded in it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果注册失败，`vdev->release()` 回调将永远不会被调用。在这种情况下，如果动态分配了 `video_device` 结构，您需要调用 `video_device_release()`
    来释放它，或者如果 `video_device` 被嵌入其中，则释放您自己的结构。
- en: 'On the unloading path of the driver, or when the video nodes are no longer
    needed, you should call `video_unregister_device()` on the video device in order
    to unregister it so that its nodes can be removed:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在驱动程序卸载路径上，或者当不再需要视频节点时，您应该调用 `video_unregister_device()` 来注销视频设备，以便其节点可以被移除：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After the preceding call, the device sysfs entries will be removed, causing
    *udev* to remove nodes in `/dev/`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述调用之后，设备的 sysfs 条目将被移除，导致 *udev* 移除 `/dev/` 中的节点。
- en: So far, we have only discussed the simplest part of the registration process,
    but there are some complex fields in the video device that need to be initialized
    prior to registration. Those fields extend the driver capabilities by providing
    the video device file operations, a coherent set of ioctl callbacks, and, most
    importantly, the media's queue and memory management interface. We will discuss
    these in the forthcoming sections.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了注册过程中最简单的部分，但是视频设备中还有一些复杂的字段需要在注册之前初始化。这些字段通过提供视频设备文件操作、一致的一组 ioctl
    回调以及最重要的是媒体队列和内存管理接口来扩展驱动程序的功能。我们将在接下来的章节中讨论这些内容。
- en: Video device file operations
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视频设备文件操作
- en: 'The video device (by means of its driver) is meant to be exposed to the user
    space as a special file in the `/dev/` directory, which the user space can use
    to interact with the underlying device: streaming the data. In order for the video
    device to be able to address user space queries (by means of system calls), a
    set of standard callbacks has to be implemented from within the driver. These
    callbacks form what are known today as `struct v4l2_file_operations` type, defined
    in `include/media/v4l2-dev.h` as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 视频设备（通过其驱动程序）旨在作为 `/dev/` 目录中的特殊文件暴露给用户空间，用户空间可以使用它与底层设备进行交互：流式传输数据。为了使视频设备能够响应用户空间查询（通过系统调用），必须从驱动程序内部实现一组标准回调。这些回调形成了今天所知的
    `struct v4l2_file_operations` 类型，定义在 `include/media/v4l2-dev.h` 中，如下所示：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'These can be regarded as top-level callbacks as they are actually called (following
    a number of sanity checks, of course) by another low-level device file op associated
    with the `vdev->cdev` field this time, and which is set with `vdev->cdev->ops
    = &v4l2_fops;` upon file node creation. This allows the kernel to implement an
    extra logic and enforce sanity:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以被视为顶层回调，因为它们实际上是由另一个低级设备文件操作调用的（当然，经过一些合理性检查），这次是与 `vdev->cdev` 字段相关联的低级设备文件操作，设置为
    `vdev->cdev->ops = &v4l2_fops;` 在文件节点创建时。这允许内核实现额外的逻辑并强制执行合理性：
- en: '`owner` is the pointer to the module. Most of the time, it is `THIS_MODULE`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`owner` 是指向模块的指针。大多数情况下，它是 `THIS_MODULE`。'
- en: '`open` should contain operations needed to implement the `open()` system call.
    Most of the time, this could be set to `v4l2_fh_open`, which is a V4L2 helper
    that simply allocates and initializes a `v4l2_fh` struct and adds it to the `vdev->fh_list`
    list. However, if your device requires some extra initialization, perform your
    initialization inside, and then call `v4l2_fh_open(struct file * filp)`. In any
    case, you *MUST* deal with `v4l2_fh_open`.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open`应包含实现`open()`系统调用所需的操作。大多数情况下，这可以设置为`v4l2_fh_open`，这是一个V4L2助手，简单地分配和初始化一个`v4l2_fh`结构，并将其添加到`vdev->fh_list`列表中。但是，如果您的设备需要一些额外的初始化，请在内部执行初始化，然后调用`v4l2_fh_open(struct
    file * filp)`。无论如何，您*必须*处理`v4l2_fh_open`。'
- en: '`release` should contain operations needed to implement the `close()` system
    call. This callback must deal with `v4l2_fh_release`. It can be set to either
    of the following:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release`应包含实现`close()`系统调用所需的操作。这个回调必须处理`v4l2_fh_release`。它可以设置为以下之一：'
- en: – `vb2_fop_release`, which is a videobuf2-V4L2 release helper that will clean
    up any ongoing streaming. This helper will call `v4l2_fh_release`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '- `vb2_fop_release`，这是一个videobuf2-V4L2释放助手，将清理任何正在进行的流。这个助手将调用`v4l2_fh_release`。'
- en: – Your custom callback, undoing what has been done in `.open`, and which must
    call `v4l2_fh_release` either directly or indirectly (using the `_vb2_fop_release()`
    helper, for example, in order for the V4L2 core to handle the cleanup of any ongoing
    streaming).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '- 撤销`.open`中所做的工作的自定义回调，并且必须直接或间接调用`v4l2_fh_release`（例如，使用`_vb2_fop_release()`助手），以便V4L2核心处理任何正在进行的流的清理。'
- en: '`read` should contain operations needed to implement the `read()` system call.
    Most of the time, the videobuf2-V4L2 helper `vb2_fop_read` is enough.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read`应包含实现`read()`系统调用所需的操作。大多数情况下，videobuf2-V4L2助手`vb2_fop_read`就足够了。'
- en: '`write` is not needed in our case as it is for an OUTPUT type device. However,
    using `vb2_fop_write` here does the job.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write`在我们的情况下不需要，因为它是用于输出类型设备。但是，在这里使用`vb2_fop_write`可以完成工作。'
- en: '`unlocked_ioctl` must be set to `video_ioctl2` if you use `v4l2_ioctl_ops`.
    The next section explains this in detail. This V4L2 core helper is a wrapper around
    `__video_do_ioctl()`, which handles the real logic, and which routes each ioctl
    to the appropriate callback in `vdev->ioctl_ops`, which is where individual ioctl
    handlers are defined.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您使用`v4l2_ioctl_ops`，则必须将`unlocked_ioctl`设置为`video_ioctl2`。下一节将详细解释这一点。这个V4L2核心助手是`__video_do_ioctl()`的包装器，它处理真正的逻辑，并将每个ioctl路由到`vdev->ioctl_ops`中的适当回调，这是单独的ioctl处理程序定义的地方。
- en: '`mmap` should contain operations needed to implement the `mmap()` system call.
    Most of the time, the videobuf2-V4L2 helper `vb2_fop_mmap` is enough, unless additional
    elements are required prior to performing mapping. Video buffers in the kernel
    (allocated in response to the `VIDIOC_REQBUFS` ioctl) have to be mapped individually
    prior to being accessed in the user space. This is the purpose of this `.mmap`
    callback, which just has to map one, and only one, video buffer to the user space.
    Information needed to map a buffer to a user space is queried to the kernel using
    the `VIDIOC_QUERYBUF` ioctl. Given the `vma` parameter, you can grab a pointer
    to the corresponding video buffer as follows:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mmap`应包含实现`mmap()`系统调用所需的操作。大多数情况下，videobuf2-V4L2助手`vb2_fop_mmap`就足够了，除非在执行映射之前需要额外的元素。内核中的视频缓冲区（响应于`VIDIOC_REQBUFS`ioctl而分配）在被访问用户空间之前必须单独映射。这就是这个`.mmap`回调的目的，它只需要将一个视频缓冲区映射到用户空间。查询将缓冲区映射到用户空间所需的信息是使用`VIDIOC_QUERYBUF`ioctl向内核查询的。给定`vma`参数，您可以按如下方式获取指向相应视频缓冲区的指针：'
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`poll` should contain operations needed to implement the `poll()` system call.
    Most of the time, the videobuf2-V4L2 helper `vb2_fop_call` is enough. If this
    helper doesn''t know how to lock (neither `queue->lock` nor `vdev->lock` are set),
    then you shouldn''t be using it, but you should write your own, which can rely
    on the `vb2_poll()` helper that does not handle locking.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poll`应包含实现`poll()`系统调用所需的操作。大多数情况下，videobuf2-V4L2助手`vb2_fop_call`就足够了。如果这个助手不知道如何锁定（`queue->lock`和`vdev->lock`都没有设置），那么您不应该使用它，而应该编写自己的助手，可以依赖于不处理锁定的`vb2_poll()`助手。'
- en: 'In either of these callbacks, you can use the `v4l2_fh_is_singular_file()`
    helper in order to check whether the given file is the only file handle opened
    for the associated `video_device`. Its alternative is `v4l2_fh_is_singular()`,
    which relies on `v4l2_fh` this time:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个回调中，您可以使用`v4l2_fh_is_singular_file()`助手来检查给定的文件是否是关联`video_device`的唯一文件句柄。它的替代方法是`v4l2_fh_is_singular()`，这次依赖于`v4l2_fh`：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To summarize, the following is what a capture video device driver''s file operation
    may look like:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，捕获视频设备驱动程序的文件操作可能如下所示：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can observe that in the preceding block, we used only standard core helpers
    in our ﬁle operations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察到，在前面的块中，我们在我们的文件操作中只使用了标准的核心助手。
- en: Important note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Mem2mem devices may use their related v4l2-mem2mem-based helpers. Have a look
    at `drivers/media/v4l2-core/v4l2-mem2mem.c`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Mem2mem设备可以使用它们相关的基于v4l2-mem2mem的助手。看看`drivers/media/v4l2-core/v4l2-mem2mem.c`。
- en: V4L2 ioctl handling
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: V4L2 ioctl处理
- en: Let's talk a bit more about the `v4l2_file_operations.unlocked_ioctl` callback.
    As we have seen in the previous section, it should be set to `video_ioctl2`. `video_ioctl2`
    takes care of argument copying between the kernel and user space and performs
    some sanity checks (for example, whether the ioctl command is valid) prior to
    dispatching each individual `ioctl()` call to the driver, which ends up in a callback
    entry in the `video_device->ioctl_ops` field, which is of the `struct v4l2_ioctl_ops`
    type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再谈谈`v4l2_file_operations.unlocked_ioctl`回调。正如我们在前一节中所看到的，它应该设置为`video_ioctl2`。`video_ioctl2`负责在内核和用户空间之间进行参数复制，并在将每个单独的`ioctl()`调用分派到驱动程序之前执行一些合理性检查（例如，ioctl命令是否有效），这最终会进入`video_device->ioctl_ops`字段中的回调条目，该字段是`struct
    v4l2_ioctl_ops`类型。
- en: 'The `struct v4l2_ioctl_ops` structure contains callbacks for every possible
    ioctl in the V4L2 framework. However, you should only set these depending on the
    type of your device and the capability of the driver. Each callback in the structure
    maps an ioctl, and the structure is defined as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct v4l2_ioctl_ops`结构包含了V4L2框架中每个可能的ioctl的回调。然而，你应该根据你的设备类型和驱动程序的能力来设置这些回调。结构中的每个回调都映射一个ioctl，结构定义如下：'
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This structure has more than 120 entries describing operations for each and
    every possible V4L2 ioctl, whatever the device type is. In the preceding excerpt,
    only those that may be of interest to us are listed. We will not introduce callbacks
    into this structure. However, when you reach [*Chapter 9*](B10985_09_ePub_AM.xhtml#_idTextAnchor396),
    *Leveraging V4L2 API from the User Space*, I encourage you to come back to this
    structure and things will be clearer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构有超过120个条目，描述了每一个可能的V4L2 ioctl的操作，无论设备类型是什么。在前面的摘录中，只列出了我们可能感兴趣的部分。我们不会在这个结构中引入回调。然而，当你到达[*第9章*]（B10985_09_ePub_AM.xhtml#_idTextAnchor396），*从用户空间利用V4L2
    API*时，我鼓励你回到这个结构，事情会更清楚。
- en: 'That said, because you have provided a callback, it remains accessible. There
    are situations where you may want a callback that you had specified in `v4l2_ioctl_ops`
    to be ignored. This tends to be needed if, based on external factors (for example,
    which card is being used), you want to turn off certain features in `v4l2_ioctl_ops`
    without having to make a new struct. In order for the core to be aware of that
    and to ignore the callback, you should call `v4l2_disable_ioctl()` on the ioctl
    commands in question before `video_register_device()` is called:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，因为你提供了一个回调，它仍然是可访问的。有些情况下，你可能希望忽略在`v4l2_ioctl_ops`中指定的回调。如果基于外部因素（例如使用的卡），你希望在`v4l2_ioctl_ops`中关闭某些功能而不必创建新的结构，那么就需要这样做。为了让核心意识到这一点并忽略回调，你应该在调用`video_register_device()`之前对相关的ioctl命令调用`v4l2_disable_ioctl()`：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is an example: `v4l2_disable_ioctl(&tea->vd, VIDIOC_S_HW_FREQ_SEEK);`.
    The previous call will mark the `VIDIOC_S_HW_FREQ_SEEK` ioctl to be ignored on
    the `tea->vd` video device.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子：`v4l2_disable_ioctl(&tea->vd, VIDIOC_S_HW_FREQ_SEEK);`。前面的调用将标记`tea->vd`视频设备上的`VIDIOC_S_HW_FREQ_SEEK`ioctl为被忽略。
- en: The videobuf2 interface and APIs
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: videobuf2接口和API
- en: 'The videobuf2 framework is used to connect the V4L2 driver layer to the user
    space layer, providing a channel for data exchange that can allocate and manage
    video frame data. The videobuf2 memory management backend is fully modular. This
    allows custom memory management routines for devices and platforms with non-standard
    memory management requirements to be plugged in, without changing the high-level
    buffer management functions and API. The framework provides the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: videobuf2框架用于连接V4L2驱动程序层和用户空间层，提供了一个数据交换通道，可以分配和管理视频帧数据。videobuf2内存管理后端是完全模块化的。这允许为具有非标准内存管理要求的设备和平台插入自定义内存管理例程，而无需更改高级缓冲区管理函数和API。该框架提供以下功能：
- en: Implementation of streaming I/O V4L2 ioctls and file operations
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现流式I/O V4L2 ioctls和文件操作
- en: High-level video buffer, video queue, and state management functions
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级视频缓冲区、视频队列和状态管理功能
- en: Video buffer memory allocation and management
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频缓冲区内存分配和管理
- en: Videobuf2 (or just vb2) facilitates driver development, reduces the code size
    of drivers, and aids in the proper and consistent implementation of the V4L2 API
    in drivers. V4L2 drivers are then charged with the task of acquiring video data
    from a sensor (usually via some sort of DMA controller) and feeding to the buffer
    managed by the vb2 framework.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Videobuf2（或者只是vb2）促进了驱动程序的开发，减少了驱动程序的代码大小，并有助于在驱动程序中正确和一致地实现V4L2 API。然后V4L2驱动程序负责从传感器（通常通过某种DMA控制器）获取视频数据，并将其提供给由vb2框架管理的缓冲区。
- en: This framework implements many ioctl functions, including buffer allocation,
    enqueue, dequeue, and data flow control. It then deprecates any vendor-specific
    solutions, reducing significantly the media framework code size and easing efforts
    required to write V4L2 device drivers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架实现了许多ioctl函数，包括缓冲区分配、入队、出队和数据流控制。然后废弃了任何特定于供应商的解决方案，大大减少了媒体框架代码的大小，并减轻了编写V4L2设备驱动程序所需的工作量。
- en: Important note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Every videobuf2 helper, API, and data structure is prefixed with `vb2_`, while
    the version 1 (videobuf, defined in `drivers/media/v4l2-core/videobuf-core.c`)
    counterpart used the `videobuf_` prefix.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 每个videobuf2助手、API和数据结构都以`vb2_`为前缀，而版本1（videobuf，定义在`drivers/media/v4l2-core/videobuf-core.c`中）的对应物使用了`videobuf_`前缀。
- en: This framework includes a number of concepts that may be familiar to some of
    you, but that need to be discussed in detail nevertheless.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架包括一些可能对你们一些人来说很熟悉的概念，但仍然需要详细讨论。
- en: Concept of buffers
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓冲区的概念
- en: 'A buffer is the unit of data exchanged in a single shot between vb2 and the
    user space. From the point of view of user space code, a V4L2 buffer represents
    the data corresponding to a video frame (in the case of a capture device, for
    example). Streaming entails exchanging buffers between the kernel and user spaces.
    vb2 uses the `struct vb2_buffer` data structure to describe a video buffer. This
    structure is defined in `include/media/videobuf2-core.h` as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区是在vb2和用户空间之间进行单次数据交换的单位。从用户空间代码的角度来看，V4L2缓冲区代表与视频帧对应的数据（例如，在捕获设备的情况下）。流式传输涉及在内核和用户空间之间交换缓冲区。vb2使用`struct
    vb2_buffer`数据结构来描述视频缓冲区。该结构在`include/media/videobuf2-core.h`中定义如下：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the preceding data structure, those fields of no interest to us have been
    removed. The remaining fields are defined as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的数据结构中，我们已经删除了对我们没有兴趣的字段。剩下的字段定义如下：
- en: '`vb2_queue` is the `vb2` queue to which this buffer belongs. This will lead
    us to the next section, where we introduce the concept of queues according to
    videobuf2.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vb2_queue`是这个缓冲区所属的`vb2`队列。这将引导我们进入下一节，介绍根据videobuf2的队列概念。'
- en: '`index` is the ID for this buffer.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index`是这个缓冲区的ID。'
- en: '`type` is the type of buffer. It is set by `vb2` at the time of allocation.
    It matches the type of queue it belongs to: `vb->type = q->type`.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`是缓冲区的类型。它由`vb2`在分配时设置。它与其所属队列的类型匹配：`vb->type = q->type`。'
- en: '`memory` is the type of memory model used to make the buffers visible on user
    spaces. The value of this field is of the `enum vb2_memory` type, which matches
    its V4L2 user space counterpart, `enum v4l2_memory`. This field is set by `vb2`
    at the time of buffer allocation and reports the vb2 equivalent of the user space
    value assigned to the `.memory` field of `v4l2_requestbuffers` given to `vIDIOC_REQBUFS`.
    Possible values include the following:'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`memory`是用于使缓冲区在用户空间可见的内存模型类型。此字段的值是`enum vb2_memory`类型，与其V4L2用户空间对应项`enum
    v4l2_memory`相匹配。此字段由`vb2`在缓冲区分配时设置，并报告了与`vIDIOC_REQBUFS`给定的`v4l2_requestbuffers`的`.memory`字段分配的用户空间值的vb2等价项。可能的值包括以下内容：'
- en: '– `VB2_MEMORY_MMAP`: Its equivalent that is assigned in user space is `V4L2_MEMORY_MMAP`,
    which indicates that the buffer is used for memory mapping I/O.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_MEMORY_MMAP`：其在用户空间分配的等价物是`V4L2_MEMORY_MMAP`，表示缓冲区用于内存映射I/O。'
- en: '– `VB2_MEMORY_USERPTR`: Its equivalent that is assigned in user space is `V4L2_MEMORY_USERPTR`,
    indicating that the user allocates buffers in the user space, and passes a pointer
    via the `buf.m.userptr` member of `v4l2_buffer`. The purpose of `USERPTR` in V4L2
    is to allow users to pass buffers allocated in user space directly by `malloc()`
    or statically.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_MEMORY_USERPTR`：其在用户空间分配的等价物是`V4L2_MEMORY_USERPTR`，表示用户在用户空间分配缓冲区，并通过`v4l2_buffer`的`buf.m.userptr`成员传递指针。V4L2中`USERPTR`的目的是允许用户直接通过`malloc()`或静态方式传递在用户空间分配的缓冲区。'
- en: – `VB2_MEMORY_DMABUF`. Its equivalent that is assigned in user space is `V4L2_MEMORY_DMABUF`,
    indicating that the memory is allocated by the driver and exported as a DMABUF
    file handler. This DMABUF file handler may be imported in another driver.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_MEMORY_DMABUF`。其在用户空间分配的等价物是`V4L2_MEMORY_DMABUF`，表示内存由驱动程序分配并导出为DMABUF文件处理程序。这个DMABUF文件处理程序可以在另一个驱动程序中导入。'
- en: '`state` is of the `enum vb2_buffer_state` type and represents the current state
    of this video buffer. Drivers can use the `void vb2_buffer_done(struct vb2_buffer
    *vb, enum vb2_buffer_state state)` API in order to change this state. Possible
    state values include the following:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`是`enum vb2_buffer_state`类型，表示此视频缓冲区的当前状态。驱动程序可以使用`void vb2_buffer_done(struct
    vb2_buffer *vb, enum vb2_buffer_state state)` API来更改此状态。可能的状态值包括以下内容：'
- en: – `VB2_BUF_STATE_DEQUEUED` means the buffer is under user space control. It
    is set by the videobuf2 core in the execution path of the `VIDIOC_REQBUFS` ioctl.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_BUF_STATE_DEQUEUED` 表示缓冲区在用户空间控制之下。这是由videobuf2核心在`VIDIOC_REQBUFS` ioctl的执行路径中设置的。'
- en: – `VB2_BUF_STATE_PREPARING` means the buffer is being prepared in videobuf2\.
    This flag is set by the videobuf2 core in the execution path of the `VIDIOC_PREPARE_BUF`
    ioctl for drivers supporting it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_BUF_STATE_PREPARING` 表示缓冲区正在videobuf2中准备。这个标志是由videobuf2核心在支持的驱动程序的`VIDIOC_PREPARE_BUF`
    ioctl的执行路径中设置的。'
- en: – `VB2_BUF_STATE_QUEUED` means the buffer is queued in videobuf, but not yet
    in the driver. This is set by the videobuf2 core in the execution path of the
    `VIDIOC_QBUF` ioctl. However, the driver must set the state of all buffers to
    `VB2_BUF_STATE_QUEUED` if it fails to start streaming. This is the equivalent
    of returning the buffer back to videobuf2.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_BUF_STATE_QUEUED` 表示缓冲区在videobuf中排队，但尚未在驱动程序中。这是由videobuf2核心在`VIDIOC_QBUF`
    ioctl的执行路径中设置的。然而，如果驱动程序无法启动流，则驱动程序必须将所有缓冲区的状态设置为`VB2_BUF_STATE_QUEUED`。这相当于将缓冲区返回给videobuf2。'
- en: – `VB2_BUF_STATE_ACTIVE` means the buffer is actually queued in the driver and
    possibly used in a hardware operation (DMA, for example). There is no need for
    the driver to set this flag as it is set by the core right before calling the
    buffer `.buf_queue` callback.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_BUF_STATE_ACTIVE` 表示缓冲区实际上在驱动程序中排队，并可能在硬件操作（例如DMA）中使用。驱动程序无需设置此标志，因为在调用缓冲区`.buf_queue`回调之前，核心会设置此标志。'
- en: – `VB2_BUF_STATE_DONE` means the driver should set this flag on the success
    path of the DMA operation on this buffer in order to pass the buffer to vb2\.
    This means to the videobuf2 core that the buffer is returned from the driver to
    videobuf, but is not yet dequeued to the user space.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_BUF_STATE_DONE` 表示驱动程序应在此缓冲区的DMA操作成功路径上设置此标志，以将缓冲区传递给vb2。这意味着videobuf2核心从驱动程序返回缓冲区，但尚未将其出队到用户空间。'
- en: – `VB2_BUF_STATE_ERROR` is the same as the above, but the operation on the buffer
    has ended with an error, which will be reported to the user space when it is dequeued.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_BUF_STATE_ERROR` 与上述相同，但是对缓冲区的操作以错误结束，当它被出队时将向用户空间报告。'
- en: If the concept of buffer skills appears complex to you after this, then I encourage
    you to first read [*Chapter 9*](B10985_09_ePub_AM.xhtml#_idTextAnchor396), *Leveraging
    V4L2 API from the User Space*, prior to coming back here.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在阅读完后，缓冲区技能的概念对您来说显得复杂，那么我鼓励您先阅读[*第9章*](B10985_09_ePub_AM.xhtml#_idTextAnchor396)，*从用户空间利用V4L2
    API*，然后再回到这里。
- en: The concept of planes
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 平面的概念
- en: There are devices that require data for each input or output video frame to
    be placed in discontiguous memory buffers. In such cases, one video frame has
    to be addressed using more than one memory address, in other words, one pointer
    per "plane." A plane is a sub-buffer of the current frame (or a chunk of the frame).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有些设备要求每个输入或输出视频帧的数据放在不连续的内存缓冲区中。在这种情况下，一个视频帧必须使用多个内存地址来寻址，换句话说，每个“平面”有一个指针。平面是当前帧的子缓冲区（或帧的一部分）。
- en: Thus, on a single-planar system, a plane represents a whole video frame, whereas
    it represents only a chunk of the video frame in a multi-planar system. Because
    memory is discontiguous, multi-planar devices use Scatter/Gather DMA.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在单平面系统中，一个平面代表整个视频帧，而在多平面系统中，一个平面只代表视频帧的一部分。由于内存是不连续的，多平面设备使用Scatter/Gather
    DMA。
- en: The concept of queue
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 队列的概念
- en: 'The queue is the central element of streaming and is the DMA engine-related
    part of the bridge driver. In fact, it is the element through which the driver
    introduces itself to videobuf2\. It helps us to implement the data flow management
    module in the driver. A queue is represented through the following structure:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是流处理的中心元素，是桥接驱动程序的DMA引擎相关部分。实际上，它是驱动程序向videobuf2介绍自己的元素。它帮助我们在驱动程序中实现数据流管理模块。队列通过以下结构表示：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The structure should be zeroed, and the preceding fields filled in. The following
    are the meanings of each element in the structure:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 结构应该被清零，并填写前面的字段。以下是结构中每个元素的含义：
- en: '`type` is the buffer type. This should be set with one of the values present
    in `enum v4l2_buf_type`, defined in `include/uapi/linux/videodev2.h`. This must
    be `V4L2_BUF_TYPE_VIDEO_CAPTURE` in our case.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type` 是缓冲区类型。这应该使用`include/uapi/linux/videodev2.h`中定义的`enum v4l2_buf_type`中的一个值进行设置。在我们的情况下，这必须是`V4L2_BUF_TYPE_VIDEO_CAPTURE`。'
- en: '`io_modes` is a bitmask describing what types of buffers can be handled. Possible
    values include the following:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`io_modes`是描述可以处理的缓冲区类型的位掩码。可能的值包括以下内容：'
- en: '– `VB2_MMAP`: Buffers allocated within the kernel and accessed via `mmap()`;
    vmalloc''ed and contiguous DMA buffers will usually be of this type.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_MMAP`：在内核中分配并通过`mmap()`访问的缓冲区；vmalloc''ed和连续DMA缓冲区通常属于这种类型。'
- en: '– `VB2_USERPTR`: This is for buffers allocated in user space. Normally, only
    devices that can do Scatter/Gather I/O can deal with user space buffers. However,
    contiguous I/O to huge pages is not supported. Interestingly, videobuf2 supports
    contiguous buffers allocated by the user space. The only way to get those, though,
    is to use some sort of special mechanism, such as the out-of-tree Android `pmem`
    driver.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_USERPTR`：这是为用户空间分配的缓冲区。通常，只有可以进行散射/聚集I/O的设备才能处理用户空间缓冲区。然而，不支持对巨大页面的连续I/O。有趣的是，videobuf2支持用户空间分配的连续缓冲区。不过，唯一的方法是使用某种特殊机制，比如非树Android
    `pmem`驱动程序。'
- en: '– `VB2_READ, VB2_WRITE`: These are user space buffers provided via the `read()`
    and `write()` system calls.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '- `VB2_READ, VB2_WRITE`：这些是通过`read()`和`write()`系统调用提供的用户空间缓冲区。'
- en: '`lock` is the mutex for serialization locks for the streaming ioctls. It is
    common to set this lock with the same mutex as `video_device->lock`, which is
    the main serialization lock. However, if some of the non-streaming ioctls were
    to take a long time to execute, then you might want to have a different lock here
    to prevent `VIDIOC_DQBUF` from being blocked while waiting for another action
    to finish.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock`是用于流ioctls的串行化锁的互斥体。通常将此锁与`video_device->lock`相同，这是主要的串行化锁。但是，如果一些非流ioctls需要很长时间才能执行，那么您可能希望在这里使用不同的锁，以防止`VIDIOC_DQBUF`在等待另一个操作完成时被阻塞。'
- en: '`ops` represents the driver-specific callbacks to set up this queue and control
    streaming operations. It is of the `struct vb2_ops` type. We will examine this
    structure in detail in the next section.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ops`代表特定于驱动程序的回调，用于设置此队列和控制流操作。它是`struct vb2_ops`类型。我们将在下一节详细讨论这个结构。'
- en: 'The `mem_ops` field is where the driver tells videobuf2 what kind of buffers
    it is actually using; it should be set to one of `vb2_vmalloc_memops`, `vb2_dma_contig_memops`,
    or `vb2_dma_sg_memops`. These are the three basic types of buffer allocation videobuf2
    implements:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mem_ops`字段是驱动程序告诉videobuf2它实际使用的缓冲区类型的地方；它应该设置为`vb2_vmalloc_memops`、`vb2_dma_contig_memops`或`vb2_dma_sg_memops`中的一个。这是videobuf2实现的三种基本类型的缓冲区分配：'
- en: – The first one is the `vmalloc()` and is thus virtually contiguous in the kernel
    space and is not guaranteed to be physically contiguous.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '- 第一种是`vmalloc()`，因此在内核空间中是虚拟连续的，不保证在物理上是连续的。'
- en: – The second one is the `vb2_mem_ops` in order to meet that need. There are
    no limits.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '- 第二种是`vb2_mem_ops`，以满足这种需求。没有限制。'
- en: You may not care about `buf_ops` as it is provided by the `vb2` core if not
    set. However, it contains callbacks to deliver buffer information between the
    user space and kernel space.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能不关心`buf_ops`，因为如果未设置，它由`vb2`核心提供。但是，它包含了在用户空间和内核空间之间传递缓冲区信息的回调。
- en: '`min_buffers_needed` is the minimum number of buffers needed before you can
    start streaming. If that is non-zero, then `vb2_queue->ops->start_streaming` won''t
    be called until at least that many buffers have been queued up by the user space.
    In other words, it represents the number of available buffers the DMA engine needs
    to have before it can be started.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min_buffers_needed`是在开始流之前需要的最小缓冲区数量。如果这个值不为零，那么只有用户空间排队了至少这么多的缓冲区，`vb2_queue->ops->start_streaming`才会被调用。换句话说，它表示DMA引擎在启动之前需要有多少可用的缓冲区。'
- en: '`bufs` is an array of pointers to buffers in this queue. Its maximum is `VB2_MAX_FRAME`,
    which corresponds to the maximum number of buffers allowed per queue by the `vb2`
    core. It is set to `32`, which is already a quite considerable value.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bufs`是此队列中缓冲区的指针数组。它的最大值是`VB2_MAX_FRAME`，这对应于`vb2`核心允许每个队列的最大缓冲区数量。它被设置为`32`，这已经是一个相当可观的值。'
- en: '`num_buffers` is the number of allocated/used buffers in the queue.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`num_buffers`是队列中已分配/已使用的缓冲区数量。'
- en: Driver-speciﬁc streaming callbacks
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 特定于驱动程序的流回调
- en: 'A bridge driver needs to expose a collection of functions for managing buffer
    queues, including queue and buffer initialization. These functions will handle
    buffer allocation, queueing, and streaming-related requests coming from the user
    space. This can be done by setting up an instance of `struct vb2_ops`, defined
    as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接驱动程序需要公开一系列函数来管理缓冲区队列，包括队列和缓冲区初始化。这些函数将处理来自用户空间的缓冲区分配、排队和与流相关的请求。这可以通过设置`struct
    vb2_ops`的实例来完成，定义如下：
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following are the purpose of each callback in this structure:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是结构中每个回调的目的：
- en: '`queue_setup`: This callback function is called by the driver''s `v4l2_ioctl_ops.vidioc_reqbufs()`
    method (in response to `VIDIOC_REQBUFS` and `VIDIOC_CREATE_BUFS` ioctls) to adjust
    the buffer count and size. This callback''s goal is to inform videobuf2-core of
    how many buffers and planes per buffer it requires, as well as the size and allocator
    context for each plane. In other words, the chosen vb2 memory allocator calls
    this method for negotiating with the driver about the number of buffers and planes
    per buffer to be used during streaming. `3` is a good choice for the minimum number
    of buffers since most DMA engines need at least `2` buffers in the queue. The
    parameters of this callback are defined as follows:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queue_setup`：此回调函数由驱动程序的`v4l2_ioctl_ops.vidioc_reqbufs()`方法调用（响应`VIDIOC_REQBUFS`和`VIDIOC_CREATE_BUFS`
    ioctls），以调整缓冲区计数和大小。此回调的目标是通知videobuf2-core需要多少个缓冲区和每个缓冲区的平面，以及每个平面的大小和分配器上下文。换句话说，所选的vb2内存分配器调用此方法与驱动程序协商在流媒体期间使用的缓冲区和每个缓冲区的平面数量。`3`是一个很好的选择作为最小缓冲区数量，因为大多数DMA引擎至少需要队列中的`2`个缓冲区。此回调的参数定义如下：'
- en: – `q` is the `vb2_queue` pointer.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '- `q`是`vb2_queue`指针。'
- en: – `num_buffers` is the pointer to the number of buffers requested by the application.
    The driver should then set the granted number of buffers allocated in this `*num_buffers`
    field. Since this callback can be called twice during the negotiation process,
    you should check `queue->num_buffers` to have an idea of the number of buffers
    already allocated prior to setting this.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '- `num_buffers`是应用程序请求的缓冲区数量的指针。然后，驱动程序应在此`*num_buffers`字段中设置分配的缓冲区数量。由于此回调在协商过程中可能会被调用两次，因此应检查`queue->num_buffers`以了解在设置此值之前已分配的缓冲区数量。'
- en: – `num_planes` contains the number of distinct video planes needed to hold a
    frame. This should be set by the driver.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '- `num_planes`包含保存帧所需的不同视频平面的数量。这应该由驱动程序设置。'
- en: – `sizes` contains the size (in bytes) of each plane. For a single-planar system,
    only `size[0]` should be set.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '- `sizes`包含每个平面的大小（以字节为单位）。对于单平面系统，只需设置`size[0]`。'
- en: – `alloc_devs` is an optional per-plane allocator-specific device array. Consider
    it as a pointer to the allocation context.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '- `alloc_devs`是一个可选的每平面分配器特定设备数组。将其视为分配上下文的指针。'
- en: 'The following is an example of the `queue_setup` callback:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`queue_setup`回调的示例：
- en: '[PRE17]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`buf_init` is called once on a buffer after memory has been allocated for it,
    or after a new `USERPTR` buffer is queued. This can be used, for example, to pin
    pages, verify contiguity, and set up IOMMU mappings.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_init`在为缓冲区分配内存后或在新的`USERPTR`缓冲区排队后会被调用一次。例如，可以用来固定页面，验证连续性，并设置IOMMU映射。'
- en: '`buf_prepare` is called on the execution path of the `VIDIOC_QBUF` ioctl. It
    should prepare the buffer for queueing to the DMA engine. The buffer is prepared
    and the user space virtual address or user address is converted into a physical
    address.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_prepare`在`VIDIOC_QBUF` ioctl的执行路径上被调用。它应该准备好缓冲区以排队到DMA引擎。缓冲区被准备好，并且用户空间虚拟地址或用户地址被转换为物理地址。'
- en: '`buf_finish` is called on each `DQBUF` ioctl. It can be used, for example,
    for cache syncing and copying back from bounce buffers.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_finish`在每个`DQBUF` ioctl上被调用。例如，可以用于缓存同步和从反弹缓冲区复制回来。'
- en: '`buf_cleanup` is called before freeing/releasing memory. It can be used for
    unmapping memory and suchlike.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_cleanup`在释放内存之前调用。可以用于取消映射内存等。'
- en: '`buf_queue`: The videobuf2 core sets the `VB2_BUF_STATE_ACTIVE` flag in the
    buffer right before invoking this callback. However, it is invoked on behalf of
    the `VIDIOC_QBUF` ioctl. The user space queues buffers one by one, one after the
    other. Moreover, buffers may be queued faster than the bridge device grabs data
    from the capture device to the buffer. In the meantime, `VIDIOC_QBUF` may be called
    several times before issuing `VIDIOC_DQBUF`. It is recommended for the driver
    to maintain a list of buffers queued for DMA, so that in the event of any DMA
    completion, the filled buffer is moved off the list, given to the `vb2` core at
    the same time by filling its timestamp and adding the buffer to the videobuf2''s
    done buffers list, and DMA pointers are updated if necessary. Roughly speaking,
    this callback function should add a buffer to the driver DMA queue and start DMA
    on that buffer. In the meantime, it is common for drivers to reimplement their
    own buffer data structure, built on top of the generic `vb2_v4l2_buffer` structure,
    but adding a list in order to address the queueing issue we just described. The
    following is an example of such a custom buffer data structure:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buf_queue`：videobuf2核心在调用此回调之前在缓冲区中设置`VB2_BUF_STATE_ACTIVE`标志。但是，它是代表`VIDIOC_QBUF`
    ioctl调用的。用户空间逐个排队缓冲区，一个接一个。此外，缓冲区可能会比桥接设备从捕获设备抓取数据到缓冲区的速度更快。与此同时，在发出`VIDIOC_DQBUF`之前可能会多次调用`VIDIOC_QBUF`。建议驱动程序维护一个排队用于DMA的缓冲区列表，以便在任何DMA完成时，填充的缓冲区被移出列表，同时通过填充其时间戳并将缓冲区添加到videobuf2的完成缓冲区列表中，如果需要，则更新DMA指针。粗略地说，此回调函数应将缓冲区添加到驱动程序的DMA队列中，并在该缓冲区上启动DMA。与此同时，驱动程序通常会重新实现自己的缓冲区数据结构，建立在通用的`vb2_v4l2_buffer`结构之上，但添加一个列表以解决我们刚才描述的排队问题。以下是这样一个自定义缓冲区数据结构的示例：'
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`start_streaming` starts the DMA engine for streaming. Prior to starting streaming,
    you must first check whether the minimum number of buffers have been queued. If
    not, you should return `-ENOBUFS` and the `vb2` framework will call this function
    again the next time a buffer has been queued until enough buffers are available
    to actually start the DMA engine. You should also enable streaming on the sub-devices
    if the following is supported: `v4l2_subdev_call(subdev, video, s_stream, 1)`.
    You should get the next frame from the buffer queue and start DMA on it. Typically,
    interrupts happen after a new frame has been captured. It is the job of the handler
    to remove the new frame from the internal buffers (using the `list_del()`) list
    and give it back to the `vb2` framework (by means of `vb2_buffer_done()`), updating
    the sequence counter field and timestamp at the same time.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start_streaming`启动了流式传输的DMA引擎。在开始流式传输之前，必须首先检查是否已排队了最少数量的缓冲区。如果没有，应返回`-ENOBUFS`，`vb2`框架将在下次缓冲区排队时再次调用此函数，直到有足够的缓冲区可用于实际启动DMA引擎。如果支持以下操作，还应在子设备上启用流式传输：`v4l2_subdev_call(subdev,
    video, s_stream, 1)`。应从缓冲区队列中获取下一帧并在其上启动DMA。通常，在捕获新帧后会发生中断。处理程序的工作是从内部缓冲区中删除新帧（使用`list_del()`）并将其返回给`vb2`框架（通过`vb2_buffer_done()`），同时更新序列计数字段和时间戳。'
- en: '`stop_streaming` stops all pending DMA operations, stops the DMA engine, and
    releases DMA channel resources.You should also disable streaming on the sub-devices
    if the following is supported: `v4l2_subdev_call(subdev, video, s_stream, 0)`.
    Disable interruptions if necessary. Since the driver maintains a list of buffers
    queued for DMA, all buffers queued in that list must be returned to vb2 in the
    ERROR state.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop_streaming`停止所有待处理的DMA操作，停止DMA引擎，并释放DMA通道资源。如果支持以下操作，还应在子设备上禁用流式传输：`v4l2_subdev_call(subdev,
    video, s_stream, 0)`。如有必要，禁用中断。由于驱动程序维护了排队进行DMA的缓冲区列表，因此必须将该列表中排队的所有缓冲区以错误状态返回给vb2。'
- en: Initializing and releasing the vb2 queue
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化和释放vb2队列
- en: 'In order for the driver to complete the queue initialization, it should call
    the `vb2_queue_init()` function, given the queue as an argument. However, the
    `vb2_queue` structure should first be allocated by the driver. Additionally, the
    driver must have cleared its content and set initial values for some requisite
    entries before calling this function. Those required values are `q->ops`, `q->mem_ops`,
    `q->type`, and `q->io_modes`. Otherwise, the queue initialization will fail, as
    shown in the following `vb2_core_queue_init()` function, which is invoked and
    whose return value is checked from within `vb2_queue_init()`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使驱动程序完成队列初始化，应调用`vb2_queue_init()`函数，给定队列作为参数。但是，`vb2_queue`结构应首先由驱动程序分配。此外，驱动程序必须清除其内容并为一些必需的条目设置初始值，然后才能调用此函数。这些必需的值是`q->ops`、`q->mem_ops`、`q->type`和`q->io_modes`。否则，队列初始化将失败，如下所示的`vb2_core_queue_init()`函数将会被调用，并且从`vb2_queue_init()`中检查其返回值：
- en: '[PRE19]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding excerpt shows the body of `vb2_core_queue_init()` in the kernel.
    This internal API is a pure basic initialization method that simply does some
    sanity checks and initializes basic data structures (lists, mutexes, and spinlocks).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上述摘录显示了内核中`vb2_core_queue_init()`的主体。这个内部API是一个纯基本的初始化方法，它只是进行一些合理性检查并初始化基本数据结构（列表、互斥锁和自旋锁）。
- en: The concept of sub-devices
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子设备的概念
- en: 'In the early days of the V4L2 subsystem, there were just two main data structures:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在V4L2子系统的早期，只有两个主要的数据结构：
- en: '`struct video_device`: This is the structure through which `/dev/<type>X` appears.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct video_device`：这是`/dev/<type>X`出现的结构。'
- en: '`struct vb2_queue`: This is responsible for buffer management.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct vb2_queue`：这负责缓冲区管理。'
- en: This was enough in an era when there were not that many IP blocks embedded with
    the video bridge. Nowadays, image blocks in SoCs embed so many IP blocks, each
    of which plays a specific role by offloading specific tasks, such as image resizing,
    image converting, and video deinterlacing functionalities. In order to use a modular
    approach for addressing this diversity, the concept of the sub-device has been
    introduced. This brings a modular approach to the software modeling of the hardware,
    allowing to abstract each hardware component as a software block.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个时代，这已经足够了，因为嵌入视频桥的IP块并不多。如今，SoC中的图像块嵌入了许多IP块，每个IP块都通过卸载特定任务来发挥特定作用，例如图像调整、图像转换和视频去隔行功能。为了使用模块化方法来解决这种多样性，引入了子设备的概念。这为硬件的软件建模带来了模块化方法，允许将每个硬件组件抽象为软件块。
- en: With this approach, each IP block (except the bridge device) participating in
    the processing pipe is seen as a sub-device, even the camera sensor itself. Whereas
    the bridge video device node has the `/dev/videoX` pattern, sub-devices on their
    side use the `/dev/v4l-subdevX` pattern (assuming they have the appropriate flag
    set prior to having their nodes created).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，处理管道中的每个IP块（除了桥接设备）都被视为一个子设备，甚至包括摄像头传感器本身。桥接视频设备节点采用`/dev/videoX`模式，而子设备则采用`/dev/v4l-subdevX`模式（假设它们在创建节点之前已设置了适当的标志）。
- en: Important note
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: 'For a better understanding of the difference between the bridge device and
    the sub-devices, you can consider the bridge device as the final element in the
    processing pipeline, sometimes the one responsible for the DMA transactions. One
    example is the Atmel-`drivers/media/platform/atmel/atmel-isc.c`: `Sensor-->PFE-->WB-->CFA-->CC-->GAM-->CSC-->CBC-->SUB-->RLP-->DMA`.
    You are encouraged to have a look in this driver for the meaning of each element.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解桥接设备和子设备之间的区别，可以将桥接设备视为处理管道中的最终元素，有时负责DMA事务。一个例子是Atmel-`drivers/media/platform/atmel/atmel-isc.c`：`Sensor-->PFE-->WB-->CFA-->CC-->GAM-->CSC-->CBC-->SUB-->RLP-->DMA`。鼓励您查看此驱动程序以了解每个元素的含义。
- en: 'From a coding point of view, the driver should include `<media/v4l-subdev.h>`,
    which defines the `struct v4l2_subdev` structure, which is the abstraction data
    structure used to instantiate a sub-device in the kernel. This structure is defined
    as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从编码的角度来看，驱动程序应包括`<media/v4l-subdev.h>`，该文件定义了`struct v4l2_subdev`结构，该结构是用于在内核中实例化子设备的抽象数据结构。此结构定义如下：
- en: '[PRE20]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `entity` field of this structure will be discussed in the next chapter,
    [*Chapter 8*](B10985_08_ePub_AM.xhtml#_idTextAnchor342)*, Integrating with V4L2
    Async and Media Controller Frameworks*. In the meantime, there are fields of no
    interest to us that have been removed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构的`entity`字段将在下一章[*第8章*](B10985_08_ePub_AM.xhtml#_idTextAnchor342)*，与V4L2异步和媒体控制器框架集成*中讨论。与此同时，我们不感兴趣的字段已被删除。
- en: 'However, the other fields in the structure are defined as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，结构中的其他字段定义如下：
- en: '`list` is of the `list_head` type, and is used by the core to insert the current
    sub-device in the list of sub-devices maintained by `v4l2_device` to which it
    belongs.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`是`list_head`类型，并由核心用于将当前子设备插入`v4l2_device`维护的子设备列表中。'
- en: '`owner` is set by the core and represents the module owning this structure.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`owner`由核心设置，表示拥有此结构的模块。'
- en: '`flags` represents the sub-device flags that the driver can set and that can
    have the following values:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`表示驱动程序可以设置的子设备标志，可以具有以下值：'
- en: '– `V4L2_SUBDEV_FL_IS_I2C`: You should set this flag if this sub-device is actually
    an I2C device.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果此子设备实际上是I2C设备，则应设置`V4L2_SUBDEV_FL_IS_I2C`标志。'
- en: – `V4L2_SUBDEV_FL_IS_SPI` should be set if this sub-device is an SPI device.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果此子设备是SPI设备，则应设置`V4L2_SUBDEV_FL_IS_SPI`。'
- en: – `V4L2_SUBDEV_FL_HAS_DEVNODE` should be set if the sub-device needs a device
    node (the famous `/dev/v4l-subdevX` entry). An API using this flag is `v4l2_device_register_subdev_nodes()`,
    which is discussed later and called by the bridge in order to create the sub-device
    node entries.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果子设备需要设备节点（著名的`/dev/v4l-subdevX`条目），则应设置`V4L2_SUBDEV_FL_HAS_DEVNODE`。使用此标志的API是`v4l2_device_register_subdev_nodes()`，稍后将讨论并由桥接调用以创建子设备节点条目。'
- en: – `V4L2_SUBDEV_FL_HAS_EVENTS` means this sub-device generates events.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '- `V4L2_SUBDEV_FL_HAS_EVENTS`表示此子设备生成事件。'
- en: '`v4l2_dev` is set by the core on the sub-device registration and is a pointer
    to the `struct 4l2_device` to which this sub-device belongs.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v4l2_dev`由核心在子设备注册时设置，并指向此子设备所属的`struct 4l2_device`的指针。'
- en: '`ops` is optional. This is a pointer to `struct v4l2_subdev_ops`, which represents
    a set of operations and which should be set by the driver to provide the callbacks
    the core can rely upon for this sub-device.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ops`是可选的。这是指向`struct v4l2_subdev_ops`的指针，由驱动程序设置以提供核心可以依赖的此子设备的回调。'
- en: '`ctrl_handler` is a pointer to `struct v4l2_ctrl_handler`. It represents the
    list of controls provided by this sub-device, as we will see in the *V4L2 controls
    infrastructure* section.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctrl_handler`是指向`struct v4l2_ctrl_handler`的指针。它表示此子设备提供的控件列表，我们将在*V4L2控件基础设施*部分中看到。'
- en: '`name` is a unique name for the sub-device. It should be set by the driver
    after the sub-device has been initialized. For the I2C variant''s initialization,
    the default name assigned by the core is `("%s %d-%04x", driver->name, i2c_adapter_id(client->adapter),
    client->addr)`. When including the support of **media controller**, this name
    is used as the media entity name.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`是子设备的唯一名称。在子设备初始化后，驱动程序应设置它。对于I2C变体的初始化，核心分配的默认名称是`("%s %d-%04x", driver->name,
    i2c_adapter_id(client->adapter), client->addr)`。在包括**媒体控制器**支持时，此名称用作媒体实体名称。'
- en: '`grp_id` is driver-specific and provided by the core when in asynchronous mode,
    and is used to group similar sub-devices.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grp_id`是驱动程序特定的，在异步模式下由核心提供，并用于对类似的子设备进行分组。'
- en: '`dev_priv` is the pointer to the device''s private data, if any.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev_priv`是设备的私有数据指针（如果有的话）。'
- en: '`host_priv` is a pointer to private data used by the device where the sub-device
    is attached.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host_priv`是指向设备的私有数据的指针，用于连接子设备的设备。'
- en: '`devnode` is the device node for this sub-device, set by the core upon a call
    to `v4l2_device_register_subdev_nodes()`, not to be confused with the bridge device
    built on top of the same structure. You should keep in mind that every `v4l2`
    element (be they sub-devices or bridges) is a video device.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devnode`是此子设备的设备节点，由核心在调用`v4l2_device_register_subdev_nodes()`时设置，不要与基于相同结构构建的桥接设备混淆。您应该记住，每个`v4l2`元素（无论是子设备还是桥接）都是视频设备。'
- en: '`dev` is the pointer to the physical device, if any. The driver can set this
    value using `void` `v4l2_set_subdevdata(struct v4l2_subdev *sd, void *p)` or can
    get it using `void *v4l2_get_subdevdata(const struct v4l2_subdev *sd)`.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev`是指向物理设备的指针（如果有的话）。驱动程序可以使用`void` `v4l2_set_subdevdata(struct v4l2_subdev
    *sd, void *p)`设置此值，或者可以使用`void *v4l2_get_subdevdata(const struct v4l2_subdev *sd)`获取它。'
- en: '`fwnode` is the firmware node object handle for this sub-device. In older kernel
    versions, this member used to be `struct device_node *of_node` and pointed to
    the `struct fwnode_handle`, as it allows switching to/from the device-tree node/acpi
    device according to which it is used on the platform. In other words, it is either
    `dev->of_node->fwnode` or `dev->fwnode`, whichever is non-`NULL`.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fwnode`是此子设备的固件节点对象句柄。在较旧的内核版本中，此成员曾经是`struct device_node *of_node`，并指向`struct
    fwnode_handle`，因为它允许根据在平台上使用的设备树节点/ACPI设备进行切换。换句话说，它是`dev->of_node->fwnode`或`dev->fwnode`，以非`NULL`的方式。'
- en: 'The `async_list`, `asd`, `subdev_notifier`, and `notifier` elements are part
    of the v4l2-async framework, as we will see in the next section. However, brief
    descriptions of these elements are provided here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`async_list`、`asd`、`subdev_notifier`和`notifier`元素是v4l2-async框架的一部分，我们将在下一节中看到。但是，这里提供了这些元素的简要描述：'
- en: '`async_list`: When registered with the async core, this member is used by the
    core to link this sub-device to a global `subdev_list` (which is a list of orphan
    sub-devices that do not belong to any notifier, meaning this sub-device has been
    registered prior to its parent, the bridge) or to its parent bridge''s `notifier->done`
    list. We discuss this in detail later in the next chapter, [*Chapter 8*](B10985_08_ePub_AM.xhtml#_idTextAnchor342)*,
    Integrating with V4L2 Async and Media Controller Frameworks*.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async_list`：当与异步核心注册时，此成员由核心用于将此子设备链接到全局`subdev_list`（这是一个孤立子设备的列表，不属于任何通知程序，这意味着此子设备在其父级桥之前注册）或其父级桥的`notifier->done`列表。我们将在下一章中详细讨论这一点，[*第8章*](B10985_08_ePub_AM.xhtml#_idTextAnchor342)*，与V4L2异步和媒体控制器框架集成*。'
- en: '`asd`: This field is of the `struct v4l2_async_subdev` type and abstracts this
    sub-device in the async core.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asd`：此字段是`struct v4l2_async_subdev`类型，并在异步核心中抽象了这个子设备。'
- en: '`subdev_notifier`: This is the notifier implicitly registered by this sub-device
    in case it needs to be notified of the probing of some other sub-devices. It is
    commonly used on systems where the streaming pipeline involves several sub-devices,
    where the sub-device N needs to be notified of the probing of the sub-device N-1.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subdev_notifier`：这是由此子设备隐式注册的通知程序，以防需要通知其他子设备的探测。它通常用于涉及多个子设备的流水线的系统，其中子设备N需要被通知子设备N-1的探测。'
- en: '`notifier`: This is set by the async core and corresponds to the notifier with
    which its underlying `.asd` async sub-device is matched.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notifier`：这是由异步核心设置的，并对应于其底层的`.asd`异步子设备匹配的通知程序。'
- en: '`pdata`: This is a common part of the sub-device platform data.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pdata`：这是子设备平台数据的常见部分。'
- en: Sub-device initialization
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子设备初始化
- en: 'Each sub-device driver must have a `struct v4l2_subdev` structure, either standalone
    or embedded in the larger and device-specific structure. The second case is recommended
    as it allows the device state to be tracked. The following is an example of a
    typical device-specific structure:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子设备驱动程序必须有一个`struct v4l2_subdev`结构，可以是独立的，也可以嵌入到更大和特定于设备的结构中。推荐第二种情况，因为它允许跟踪设备状态。以下是典型设备特定结构的示例：
- en: '[PRE21]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Prior to being accessed, a V4L2 sub-device need to be initialized using the
    `v4l2_subdev_init()` API. However, when it comes to sub-devices with an I2C- or
    SPI-based control interface (typically camera sensors), the kernel provides `v4l2_spi_subdev_init()`
    and `v4l2_i2c_subdev_init()` variants:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在被访问之前，V4L2子设备需要使用`v4l2_subdev_init()` API进行初始化。然而，当涉及到具有基于I2C或SPI的控制接口（通常是摄像头传感器）的子设备时，内核提供了`v4l2_spi_subdev_init()`和`v4l2_i2c_subdev_init()`变体：
- en: '[PRE22]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'All of these APIs take a pointer to the `struct v4l2_subdev` structure as a
    first argument. Registering our sub-device using our device-specific data structure
    would then appear as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些API都将`struct v4l2_subdev`结构的指针作为第一个参数。使用我们的设备特定数据结构注册我们的子设备将如下所示：
- en: '[PRE23]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `spi`/`i2c` variants wrap the `v4l2_subdev_init()` function. Additionally,
    they require the underlying low-level, bus-specific structure as a second argument.
    Moreover, these bus-specific variants will store the sub-device object (given
    as the first argument) as low-level, bus-specific device data and vice versa by
    storing the low-level, bus-specific structure as the sub-device's private data.
    This way, `i2c_client` (or `spi_device`) and `v4l2_subdev` point to one another,
    meaning that by having a pointer to the I2C client, for example, you can call
    `i2c_set_clientdata()` (such as `struct v4l2_subdev *sd = i2c_get_clientdata(client);`)
    in order to grab the pointer to our internal sub-device object, and use the `container_of`
    macro (such as `struct mychip_struct *foo = container_of(sd, struct mychip_struct,
    sd);`) in order to grab the pointer to the chip-specific structure. On the other
    hand, having a pointer to the sub-device object, you can use `v4l2_get_subdevdata()`
    in order to grab the underlying bus-specific structure.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`spi`/`i2c`变体包装了`v4l2_subdev_init()`函数。此外，它们需要作为第二个参数的底层低级、特定于总线的结构。此外，这些特定于总线的变体将存储子设备对象（作为第一个参数给出）作为低级、特定于总线的设备数据，反之亦然，通过将低级、特定于总线的结构存储为子设备的私有数据。这样，`i2c_client`（或`spi_device`）和`v4l2_subdev`相互指向，这意味着通过拥有指向I2C客户端的指针，例如，您可以调用`i2c_set_clientdata()`（例如`struct
    v4l2_subdev *sd = i2c_get_clientdata(client);`）来获取指向我们内部子设备对象的指针，并使用`container_of`宏（例如`struct
    mychip_struct *foo = container_of(sd, struct mychip_struct, sd);`）来获取指向芯片特定结构的指针。另一方面，拥有指向子设备对象的指针，您可以使用`v4l2_get_subdevdata()`来获取底层特定于总线的结构。'
- en: 'Least but not last, these bus-specific variants will mangle the sub-device
    name, as explained when introducing the `struct v4l2_subdev` data structure. An
    excerpt of `v4l2_i2c_subdev_init()` can provide a better understanding of this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，这些特定于总线的变体将损坏子设备名称，就像在介绍`struct v4l2_subdev`数据结构时所解释的那样。`v4l2_i2c_subdev_init()`的摘录可以更好地理解这一点：
- en: '[PRE24]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In each of the preceding three initialization APIs, `ops` is the last argument
    and is a pointer to a `struct v4l2_subdev_ops` representing operations exposed/supported
    by the sub-device. However, let's discuss this in the next section.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面三个初始化API中，`ops`是最后一个参数，是指向表示子设备公开/支持的操作的`struct v4l2_subdev_ops`的指针。然而，让我们在下一节中讨论这个问题。
- en: Sub-device operations
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子设备操作
- en: Sub-devices are devices that are somehow connected to the main bridge device.
    In the whole media device, each IP (sub-device) has its set of functionalities.
    These functionalities have to be exposed to the core by means of callbacks well
    defined by kernel developers for commonly used functionalities. This is the purpose
    of `struct v4l2_subdev_ops`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 子设备是以某种方式连接到主桥设备的设备。在整个媒体设备中，每个IP（子设备）都有其自己的功能集。这些功能必须通过内核开发人员为常用功能定义的回调来向核心公开。这就是`struct
    v4l2_subdev_ops`的目的。
- en: 'However, some sub-devices can perform so many different and unrelated things
    that even `struct v4l2_subdev_ops` has been split into small and categorized coherent
    sub-structure ops, each gathering related functionalities so that `struct v4l2_subdev_ops`
    becomes the top-level ops structure, described as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一些子设备可以执行如此多不同和不相关的事情，以至于甚至 `struct v4l2_subdev_ops` 已经被分成小的和分类的一致的子结构操作，每个子结构操作都收集相关的功能，以便
    `struct v4l2_subdev_ops` 成为顶级操作结构，描述如下：
- en: '[PRE25]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Important note
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Operations should only be provided for sub-devices exposed to the user space
    by an underlying char device file node. When registered, this device file node
    will have the same file operations as discussed earlier, that is, `v4l2_fops`.
    However, as we have seen earlier, these low-level ops only wrap (deal with) `video_device->fops`.
    Therefore, in order to reach `v4l2_subdev_ops`, the core uses `subdev->video_device->fops`
    as an intermediate and assigns it another file ops upon initialization (`subdev->vdev->fops
    = &v4l2_subdev_fops;`), which will wrap and call the real subdev ops. The call
    chain here is `v4l2_fops ==> v4l2_subdev_fops ==> our_custom_subdev_ops`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 操作应该只为用户空间公开的子设备提供，通过底层字符设备文件节点。注册时，该设备文件节点将具有与前面讨论的相同的文件操作，即 `v4l2_fops`。然而，正如我们之前所看到的，这些低级操作只是包装（处理）`video_device->fops`。因此，为了达到
    `v4l2_subdev_ops`，核心使用 `subdev->video_device->fops` 作为中间，并在初始化时分配另一个文件操作（`subdev->vdev->fops
    = &v4l2_subdev_fops;`），它将包装并调用真正的子设备操作。这里的调用链是 `v4l2_fops ==> v4l2_subdev_fops
    ==> our_custom_subdev_ops`。
- en: 'You can see that the preceding top-level ops structure is made of pointers
    to category ops structures, which are as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到前面的顶级操作结构由指向类别操作结构的指针组成，如下所示：
- en: '`core` of the `v4l2_subdev_core_ops` type: This is the core ops category, providing
    generic callbacks, such as logging and debugging. It also allows the provision
    of additional and custom ioctls (especially useful if the ioctl does not fit in
    any category).'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v4l2_subdev_core_ops` 类型的 `core`：这是核心操作类别，提供通用的回调，比如日志记录和调试。它还允许提供额外和自定义的
    ioctls（特别是当 ioctl 不适用于任何类别时非常有用）。'
- en: '`video` of the `v4l2_subdev_video_ops` type: `.s_stream` is called when streaming
    starts. It writes different configuration values to a camera''s registers based
    on the chosen frame size and format.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v4l2_subdev_video_ops` 类型的 `video`：`.s_stream` 在流媒体开始时被调用。它根据所选择的帧大小和格式向摄像头的寄存器写入不同的配置值。'
- en: '`pad` of the `v4l2_subdev_pad_ops` type: For cameras that support multiple
    frame sizes and image sample formats, these operations allow users to choose from
    the available options.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v4l2_subdev_pad_ops` 类型的 `pad`：对于支持多个帧大小和图像采样格式的摄像头，这些操作允许用户从可用选项中进行选择。'
- en: '`tuner`, `audio`, `vbi`, and `ir` are beyond the scope of this book.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tuner`、`audio`、`vbi` 和 `ir` 超出了本书的范围。'
- en: '`sensor` of the `v4l2_subdev_sensor_ops` type: This covers camera sensor operations,
    typically for known buggy sensors that need some frames or lines to be skipped
    because they are corrupted.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v4l2_subdev_sensor_ops` 类型的 `sensor`：这涵盖了摄像头传感器操作，通常用于已知有错误的传感器，需要跳过一些帧或行，因为它们已损坏。'
- en: Each callback in each category structure corresponds to an ioctl. The routing
    is actually done at a low level by `subdev_do_ioctl()`, defined in `drivers/media/v4l2-
    core/v4l2-subdev.c`, and which is indirectly called by `subdev_ioctl()`, which
    corresponds to `v4l2_subdev_fops.unlocked_ioctl`. The real call chain should be
    `v4l2_fops ==> v4l2_subdev_fops.unlocked_ioctl ==> our_custom_subdev_ops`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类别结构中的每个回调对应一个 ioctl。路由实际上是由 `subdev_do_ioctl()` 在低级别执行的，该函数在 `drivers/media/v4l2-core/v4l2-subdev.c`
    中定义，并间接地由 `subdev_ioctl()` 调用，对应于 `v4l2_subdev_fops.unlocked_ioctl`。真正的调用链应该是
    `v4l2_fops ==> v4l2_subdev_fops.unlocked_ioctl ==> our_custom_subdev_ops`。
- en: The nature of this top-level `struct v4l2_subdev_ops` structure just confirms
    how wide the range of devices is that may be supported by V4L2\. Ops categories
    that are of no interest to the sub-device driver can be left `NULL`. Do also note
    that the `.core` ops are common to all sub-devs. This does not mean it is mandatory;
    it merely means that any sub-device driver of whatever category is free to implement
    the `.core` ops as its callbacks are category-independent.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个顶级 `struct v4l2_subdev_ops` 结构的性质只是确认了 V4L2 可能支持的设备范围有多广。对于子设备驱动程序不感兴趣的操作类别可以保持
    `NULL`。还要注意，`.core` 操作对所有子设备都是通用的。这并不意味着它是强制性的；它只是意味着任何类别的子设备驱动程序都可以实现 `.core`
    操作，因为它的回调是与类别无关的。
- en: struct v4l2_subdev_core_ops
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: struct v4l2_subdev_core_ops
- en: 'This structure implements generic callbacks and has the following definition:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构实现了通用的回调，并具有以下定义：
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding structure, fields of no interest to us have been removed.
    Those remaining are defined as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的结构中，我们已经删除了对我们不感兴趣的字段。剩下的字段定义如下：
- en: '`.log_status` is for logging purposes. You should use the `v4l2_info()` macro
    for this.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.log_status` 用于记录目的。您应该使用 `v4l2_info()` 宏来实现这一点。'
- en: '`.s_power` puts the sub-device (the camera, for example) in power-saving mode
    (`on==0`) or normal operation mode (`on==1`).'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.s_power` 将子设备（例如摄像头）置于省电模式（`on==0`）或正常操作模式（`on==1`）。'
- en: The `.load_fw` operation has to be called to load the sub-device's firmware.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.load_fw` 操作必须被调用以加载子设备的固件。'
- en: '`.ioctl` should be defined if the sub-device provides extra ioctl commands.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果子设备提供额外的 ioctl 命令，应该定义 `.ioctl`。
- en: '`.g_register` and `.s_register` are to be used for advanced debugging only
    and require the kernel config option `CONFIG_VIDEO_ADV_DEBUG` to be set. These
    operations allow the reading and writing of hardware registers in response to
    the `VIDIOC_DBG_G_REGISTER` and `VIDIOC_DBG_S_REGISTER` ioctls. The `reg` parameters
    (of the type `v4l2_dbg_register`, defined in `include/uapi/linux/videodev2.h`)
    are filled and given by the application.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.g_register` 和 `.s_register` 仅用于高级调试，需要设置内核配置选项 `CONFIG_VIDEO_ADV_DEBUG`。这些操作允许读取和写入硬件寄存器，以响应
    `VIDIOC_DBG_G_REGISTER` 和 `VIDIOC_DBG_S_REGISTER` ioctls。`reg` 参数（类型为 `v4l2_dbg_register`，在
    `include/uapi/linux/videodev2.h` 中定义）由应用程序填充和提供。'
- en: '`.interrupt_service_routine` is called by the bridge from within its IRQ handler
    (it should use `v4l2_subdev_call` for this) when an interrupt status has been
    raised due to this sub-device, in order for the sub-device to handle the details.
    `handled` is an output parameter provided by the bridge driver, but has to be
    filled by the sub-device driver in order to inform (as *true or false*) on the
    result of its processing. We are in the IRQ context, so must not sleep. Sub-devices
    behind I2C/SPI buses should probably schedule their work in a threaded context.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.interrupt_service_routine`由桥接器在其IRQ处理程序中调用（应使用`v4l2_subdev_call`），当由于此子设备而引发中断状态时，以便子设备处理详细信息。`handled`是桥接驱动程序提供的输出参数，但必须由子设备驱动程序填充，以便通知（作为*true或false*）其处理结果。我们处于IRQ上下文中，因此不能休眠。位于I2C/SPI总线后面的子设备可能应该在线程化的上下文中安排其工作。'
- en: '`.subscribe_event` and `.unsubscribe_event` are used to subscribe or unsubscribe
    to control change events. Please have a look at other V4L2 drivers implementing
    this to see how to implement yours.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.subscribe_event`和`.unsubscribe_event`用于订阅或取消订阅控制更改事件。请查看其他实现此功能的V4L2驱动程序，以了解如何实现您的驱动程序。'
- en: struct v4l2_subdev_video_ops or struct v4l2_subdev_pad_ops
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: struct v4l2_subdev_video_ops或struct v4l2_subdev_pad_ops
- en: People often need to decide whether to implement `struct v4l2_subdev_video_ops`
    or `struct v4l2_subdev_pad_ops`, because some of the callbacks are redundant in
    both of these structures. The thing is, the callbacks of the `struct v4l2_subdev_video_ops`
    structure are used when the V4L2 device was opened in video mode, which includes
    TVs, camera sensors, and framebuffer. So far, so good. The concept of `struct
    v4l2_subdev_pad_ops` is not needed either. However, the media controller framework
    abstracts the sub-device by means of an entity object (we will see this later),
    which connects to other elements via PAD. In this case, it makes sense to use
    PAD-related functionalities instead of sub-device-related ones, hence, using `struct
    v4l2_subdev_pad_ops` instead of `struct v4l2_subdev_video_ops`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常需要决定是否实现`struct v4l2_subdev_video_ops`或`struct v4l2_subdev_pad_ops`，因为这两个结构中的一些回调是多余的。问题是，当V4L2设备以视频模式打开时，`struct
    v4l2_subdev_video_ops`结构的回调被使用，其中包括电视、摄像头传感器和帧缓冲区。到目前为止，一切顺利。`struct v4l2_subdev_pad_ops`的概念也不需要。然而，媒体控制器框架通过实体对象（稍后我们将看到）抽象了子设备，通过PAD连接到其他元素。在这种情况下，使用与PAD相关的功能而不是与子设备相关的功能是有意义的，因此，使用`struct
    v4l2_subdev_pad_ops`而不是`struct v4l2_subdev_video_ops`。
- en: 'Since we have not introduced the media framework yet, we are only interested
    in the `struct v4l2_subdev_video_ops` structure, which is defined as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有介绍媒体框架，所以我们只对`struct v4l2_subdev_video_ops`结构感兴趣，其定义如下：
- en: '[PRE27]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding excerpt, for the sake of readability, I removed the TV and
    video output-related callbacks as well as those not related to camera devices,
    which are also somehow useless for us. For the commonly used ones, they are defined
    as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述摘录中，为了便于阅读，我删除了与电视和视频输出相关的回调，以及与摄像头设备无关的回调，这对我们也没有什么用。对于常用的回调，它们的定义如下：
- en: '`querystd`: This is the callback for the `VIDIOC_QUERYSTD()` ioctl handler
    code.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`querystd`：这是`VIDIOC_QUERYSTD()`ioctl处理程序代码的回调。'
- en: '`s_stream`: This is used to notify the driver that a video stream will start
    or has stopped, depending on the value of the `enable` parameter.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s_stream`：用于通知驱动程序视频流将开始或已停止，取决于`enable`参数的值。'
- en: '`g_frame_interval`: This is the callback for the `VIDIOC_SUBDEV_G_FRAME_INTERVAL()`
    ioctl handler code.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g_frame_interval`：这是`VIDIOC_SUBDEV_G_FRAME_INTERVAL()`ioctl处理程序代码的回调。'
- en: '`s_frame_interval`: This is the callback for the `VIDIOC_SUBDEV_S_FRAME_INTERVAL()`
    ioctl handler code.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s_frame_interval`：这是`VIDIOC_SUBDEV_S_FRAME_INTERVAL()`ioctl处理程序代码的回调。'
- en: struct v4l2_subdev_sensor_ops
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: struct v4l2_subdev_sensor_ops
- en: There are sensors that produce initial garbage frames when they start streaming.
    Such sensors possibly require some time in order to ensure the stability of some
    of their properties. This structure makes it possible to inform the core of the
    number of frames to skip in order to avoid garbage. Moreover, some sensors may
    always produce images with a certain number of corrupted lines at the top, or
    embed their metadata in these lines. In both cases, the resulting frames they
    produce are always corrupted. This structure also allows us to specify the number
    of lines to skip on each frame before it is grabbed.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当传感器开始流式传输时，有些传感器会产生初始垃圾帧。这样的传感器可能需要一些时间来确保其某些属性的稳定性。该结构使得可以通知核心跳过多少帧以避免垃圾。此外，一些传感器可能始终在顶部产生一定数量的损坏行的图像，或者在这些行中嵌入它们的元数据。在这两种情况下，它们产生的帧始终是损坏的。该结构还允许我们指定在抓取每帧之前要跳过的行数。
- en: 'The following is the definition of the `v4l2_subdev_sensor_ops` structure:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`v4l2_subdev_sensor_ops`结构的定义：
- en: '[PRE28]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`g_skip_top_lines` is used to specify the number of lines to skip in each image
    of the sensors, while `g_skip_frames` allows us to specify the initial number
    of frames to skip in order to avoid garbage, as in the following example:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`g_skip_top_lines`用于指定传感器每幅图像中要跳过的行数，而`g_skip_frames`允许我们指定要跳过的初始帧数，以避免垃圾，如以下示例所示：'
- en: '[PRE29]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `lines` and `frames` parameters are output parameters. Each callback should
    return `0`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`lines`和`frames`参数是输出参数。每个回调应返回`0`。'
- en: Calling sub-device operations
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用子设备操作
- en: 'After all, if `subdev` callbacks are provided, then they are intended to be
    called. That said, invoking an ops callback is as simple as calling it directly,
    as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果提供了`subdev`回调，则打算调用它们。也就是说，调用ops回调就像直接调用它一样简单，如下所示：
- en: '[PRE30]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, there is a more convenient and safer way to achieve this, by using
    the `v4l2_subdev_call()` macro:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种更方便和更安全的方法可以实现这一点，即使用`v4l2_subdev_call()`宏：
- en: '[PRE31]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The macro, defined in `include/media/v4l2-subdev.h`, will perform the following
    actions:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在`include/media/v4l2-subdev.h`中定义的宏将执行以下操作：
- en: It will first check whether the sub-device is `NULL` and return `-ENODEV` otherwise.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将首先检查子设备是否为`NULL`，否则返回`-ENODEV`。
- en: It will return `-ENOIOCTLCMD` if either the category (`subdev->video` in our
    example) or the callback itself (`subdev->video->s_stream` in our example) is
    `NULL`, or it will return the actual result of the `subdev->ops->video->s_stream`
    ops.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类别(`subdev->video`在我们的示例中)或回调本身(`subdev->video->s_stream`在我们的示例中)为`NULL`，则它将返回`-ENOIOCTLCMD`，或者它将返回`subdev->ops->video->s_stream`操作的实际结果。
- en: 'It is also possible to call all, or a subset, of the sub-devices:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以调用所有或部分子设备：
- en: '[PRE32]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Any sub-device that does not support this callback is skipped and error results
    are ignored. If you want to check for errors, use the following command:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 不支持此回调的任何子设备都将被跳过，错误结果将被忽略。如果要检查错误，请使用以下命令：
- en: '[PRE33]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Any error except `-ENOIOCTLCMD` will exit the loop with that error. If no errors
    (except `- ENOIOCTLCMD`) occurred, then `0` is returned.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`-ENOIOCTLCMD`之外的任何错误都将以该错误退出循环。如果没有错误(除了`- ENOIOCTLCMD`)发生，则返回`0`。
- en: Traditional sub-device (un)registration
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统子设备(取消)注册
- en: 'There are two ways for a sub-device to be registered with the bridge, depending
    on the nature of the media device:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以将子设备注册到桥接设备，取决于媒体设备的性质：
- en: '**Synchronous mode**: This is the traditional method. In this mode, the bridge
    driver has the responsibility of registering sub-devices. The sub-device driver
    is either implemented from within the bridge driver or you have to find a way
    for the bridge driver to grab the handles of sub-devices it is responsible for.
    This is usually achieved by means of platform data, or by the bridge driver exposing
    a set of APIs that will be used by the sub-device drivers, which would allow the
    bridge driver to be aware of these sub-devices (by tracking them in a private
    internal list, for example).With this method, the bridge driver must be aware
    of the sub-devices connected to it, and know exactly when to register them. This
    is typically the case for internal sub-devices, such as video data processing
    units within SoCs or complex PCI(e) boards, or camera sensors in USB cameras or
    connected to SoCs.'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**同步模式**：这是传统的方法。在这种模式下，桥接驱动程序负责注册子设备。子设备驱动程序要么是从桥接驱动程序中实现的，要么您必须找到一种方法让桥接驱动程序获取其负责的子设备的句柄。这通常是通过平台数据实现的，或者通过桥接驱动程序公开一组API，这些API将被子设备驱动程序使用，从而允许桥接驱动程序了解这些子设备(例如通过在私有内部列表中跟踪它们)。使用这种方法，桥接驱动程序必须了解连接到它的子设备，并确切地知道何时注册它们。这通常适用于内部子设备，例如SoC内的视频数据处理单元或复杂的PCI(e)板，或者USB摄像头中的摄像头传感器或连接到SoC。'
- en: '**Asynchronous mode**: This is where information about sub-devices is made
    available to the system independently of the bridge devices, which is typically
    the case on devicetree-based systems. This will be discussed in the next chapter,
    [*Chapter 8*](B10985_08_ePub_AM.xhtml#_idTextAnchor342), *Integrating with V4L2
    Async and Media Controller Frameworks*.'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步模式：这是关于子设备信息独立于桥接设备向系统提供的情况，这通常是基于设备树的系统的情况。这将在下一章中讨论，*第8章*，*与V4L2异步和媒体控制器框架集成*。
- en: 'However, in order for a bridge driver to register a sub-device, it has to call
    `v4l2_device_register_subdev()`, while it has to call `v4l2_device_unregister_subdev()`
    to unregister this sub-device. In the meantime, after registering sub-devices
    with the core, it might be necessary to create their respective char file nodes,
    `/dev/v4l-subdevX`, only for sub-devices with the flag `V4L2_SUBDEV_FL_HAS_DEVNODE`
    set. You can use `v4l2_device_register_subdev_nodes()` to this end:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为了桥接驱动程序注册子设备，必须调用`v4l2_device_register_subdev()`，而必须调用`v4l2_device_unregister_subdev()`来注销此子设备。同时，在将子设备注册到核心后，可能需要为具有设置`V4L2_SUBDEV_FL_HAS_DEVNODE`标志的子设备创建它们各自的字符文件节点`/dev/v4l-subdevX`。您可以使用`v4l2_device_register_subdev_nodes()`来实现这一点：
- en: '[PRE34]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`v4l2_device_register_subdev()` will insert `sd` into `v4l2_dev->subdevs`,
    which is the list of sub-devices maintained by this V4L2 device. This can fail
    if the `subdev` module disappeared before it could be registered. After this function
    has been called successfully, the `subdev->v4l2_dev` field points to the `v4l2_device`.
    This function returns `0` in the event of success or `v4l2_device_unregister_subdev()`
    will take `sd` off that list. Then, `v4l2_device_register_subdev_nodes()` walks
    through `v4l2_dev->subdevs` and creates a special char file node (`/dev/v4l-subdevX`)
    for each sub-device with the flag `V4L2_SUBDEV_FL_HAS_DEVNODE` set.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`v4l2_device_register_subdev()`将`sd`插入`v4l2_dev->subdevs`，这是由V4L2设备维护的子设备列表。如果`subdev`模块在注册之前消失，这可能会失败。成功调用此函数后，`subdev->v4l2_dev`字段指向`v4l2_device`。此函数在成功时返回`0`，或者`v4l2_device_unregister_subdev()`将从列表中取出`sd`。然后，`v4l2_device_register_subdev_nodes()`遍历`v4l2_dev->subdevs`，为每个具有设置`V4L2_SUBDEV_FL_HAS_DEVNODE`标志的子设备创建一个特殊的字符文件节点(`/dev/v4l-subdevX`)。'
- en: Important note
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `/dev/v4l-subdevX` device nodes allow direct control of the advanced and
    hardware-specific features of sub-devices.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/v4l-subdevX`设备节点允许直接控制子设备的高级和硬件特定功能。'
- en: Now that we have learned about sub-device initialization, operations, and registration,
    let's look at V4L2 controls in the next section.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了子设备的初始化、操作和注册，让我们在下一节中看看V4L2控件。
- en: V4L2 controls infrastructure
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: V4L2控件基础设施
- en: Some devices have controls that are settable by the user in order to modify
    some defined properties. Some of these controls may support a list of predefined
    values, a default value, an adjustment, and so on. The thing is, different devices
    may provide different controls with different values. Moreover, while some of
    these controls are standard, others may be vendor-specific. The main purpose of
    the control framework is to present controls to the user without assumptions relating
    to their purpose. In this section, we only address standard controls.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 一些设备具有可由用户设置的控件，以修改一些定义的属性。其中一些控件可能支持预定义值列表、默认值、调整等。问题是，不同的设备可能提供具有不同值的不同控件。此外，虽然其中一些控件是标准的，但其他可能是特定于供应商的。控件框架的主要目的是向用户呈现控件，而不假设其目的。在本节中，我们只讨论标准控件。
- en: 'The control framework relies on two main objects, both defined in `include/media/v4l2-
    ctrls.h`, like the rest of the data structures and APIs provided by this framework.
    The first is `struct v4l2_ctrl`. This structure describes the control properties
    and keeps track of the control''s value. The second and final one is `struct v4l2_ctrl_handler`,
    which keeps track of all the controls. Their detailed definitions are presented
    here:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 控件框架依赖于两个主要对象，都在`include/media/v4l2- ctrls.h`中定义，就像该框架提供的其他数据结构和API一样。第一个是`struct
    v4l2_ctrl`。这个结构描述了控件的属性，并跟踪控件的值。第二个和最后一个是`struct v4l2_ctrl_handler`，它跟踪所有的控件。它们的详细定义在这里呈现：
- en: '[PRE35]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding definition excerpt of `struct v4l2_ctrl_handler`, `ctrls`
    represents the list of controls owned by this handler. `notify` is a notify callback
    that is called whenever the control changes value. This callback is invoked with
    the handler''s `lock` held. At the end, `notify_priv` is the context data given
    as the argument to notify. The next one is `struct v4l2_ctrl`, defined as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在`struct v4l2_ctrl_handler`的前述定义摘录中，`ctrls`表示此处理程序拥有的控件列表。`notify`是一个通知回调，每当控件更改值时都会被调用。这个回调在持有处理程序的`lock`时被调用。最后，`notify_priv`是作为参数给出的上下文数据。接下来是`struct
    v4l2_ctrl`，定义如下：
- en: '[PRE36]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This structure represents the control on its own, with important members present.
    These are defined as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构代表了控件本身，具有重要的成员。这些定义如下：
- en: '`node` is used to insert the control in the handler''s control list.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`node`用于将控件插入处理程序的控件列表中。'
- en: '`handler` is the handler to which this control belongs.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handler`是此控件所属的处理程序。'
- en: '`ops` is of the `struct v4l2_ctrl_ops` type and represents the get/set operations
    for this control.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ops`是`struct v4l2_ctrl_ops`类型，并表示此控件的获取/设置操作。'
- en: '`id` is the ID of this control.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id` 是此控件的ID。'
- en: '`name` is the name of the control.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` 是控件的名称。'
- en: '`minimum` and `maximum` are the minimum and maximum values accepted by the
    control, respectively.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minimum`和`maximum`分别是控件接受的最小值和最大值。'
- en: '`default_value` is the default value of the control.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_value`是控件的默认值。'
- en: '`step` is the incrementation/decrementation step for this non-menu control.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`step`是非菜单控件的递增/递减步长。'
- en: '`flags` covers the control''s flags. While the whole flag list is defined in
    `include/uapi/linux/videodev2.h`, some of the commonly used ones are as follows:'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`涵盖了控件的标志。虽然整个标志列表在`include/uapi/linux/videodev2.h`中定义，但一些常用的标志如下：'
- en: – `V4L2_CTRL_FLAG_DISABLED`, which means the control is disabled
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: – `V4L2_CTRL_FLAG_DISABLED`，表示控件被禁用
- en: – `V4L2_CTRL_FLAG_READ_ONLY`, for a read-only control
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: – `V4L2_CTRL_FLAG_READ_ONLY`，用于只读控件
- en: – `V4L2_CTRL_FLAG_WRITE_ONLY`, for a write-only control
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: – `V4L2_CTRL_FLAG_WRITE_ONLY`，用于只写控件
- en: – `V4L2_CTRL_FLAG_VOLATILE`, for a volatile control
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: – `V4L2_CTRL_FLAG_VOLATILE`，用于易失性控件
- en: '`is_private`, if set, will prevent this control from being added to any other
    handlers. It makes this control private to the initial handler where it is added.
    This can be used to prevent making a `subdev` control available in the V4L2 driver
    controls.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is_private`，如果设置，将阻止此控件被添加到任何其他处理程序中。它使得此控件对最初添加它的处理程序私有。这可以用来防止将`subdev`控件可用于V4L2驱动程序控件。'
- en: Important note
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`enum` usually) like a kind of menu, hence the name *menu control*.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`通常像一种菜单，因此称为*菜单控件*。'
- en: 'V4L2 controls are identified by a unique ID. They are prefixed with `V4L2_CID_`
    and are all available in `include/uapi/linux/v4l2-controls.h`. The common standard
    controls supported in video capture devices are as follows (the following list
    is non-exhaustive):'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: V4L2控件由唯一的ID标识。它们以`V4L2_CID_`为前缀，并且都在`include/uapi/linux/v4l2-controls.h`中可用。视频捕获设备支持的常见标准控件如下（以下列表不是详尽无遗的）：
- en: '[PRE37]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding list includes standard controls only. To support a custom control,
    you should add its ID based on the control''s base class descriptor and make sure
    that the ID is not a duplication. To add control support to the driver, the control
    handler should first be initialized using the `v4l2_ctrl_handler_init()` macro.
    This macro accepts the handler to be initialized as well as the number of controls
    this handler can refer to, as shown in its following prototype:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表只包括标准控件。要支持自定义控件，你应该根据控件的基类描述符添加其ID，并确保ID不重复。要向驱动程序添加控件支持，控件处理程序应首先使用`v4l2_ctrl_handler_init()`宏进行初始化。这个宏接受要初始化的处理程序以及此处理程序可以引用的控件数量，如下原型所示：
- en: '[PRE38]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once finished with the control handler, you can call `v4l2_ctrl_handler_free()`
    on this control handler in order to release its resources. Once the control handler
    is initialized, controls can be created and added to it. When it comes to standard
    V4L2 controls, you can use `v4l2_ctrl_new_std()` in order to allocate and initialize
    the new control:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 完成控件处理程序后，你可以调用`v4l2_ctrl_handler_free()`释放此控件处理程序的资源。一旦控件处理程序被初始化，就可以创建控件并将其添加到其中。对于标准的V4L2控件，你可以使用`v4l2_ctrl_new_std()`来分配和初始化新的控件：
- en: '[PRE39]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This function will, in most fields, be based on the control ID. For custom
    controls, however (not discussed here), you should use the `v4l2_ctrl_new_custom()`
    helper instead. In the preceding prototype, the following elements are defined
    as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在大多数字段上都是基于控件ID的。然而对于自定义控件（这里不讨论），你应该使用`v4l2_ctrl_new_custom()`辅助函数。在前面的原型中，以下元素被定义如下：
- en: '`hdl` represents the control handler initialized previously.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hdl`表示先前初始化的控件处理程序。'
- en: '`ops` is of the `struct v4l2_ctrl_ops` type and represents the control ops.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ops`是`struct v4l2_ctrl_ops`类型，并表示控件操作。'
- en: '`id` is the control ID, defined as `V4L2_CID_*`.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`是控件ID，定义为`V4L2_CID_*`。'
- en: '`min` is the minimum value this control can accept. Depending on the control
    ID, this value can be mangled by the core.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min`是此控件可以接受的最小值。根据控件ID，这个值可能会被核心修改。'
- en: '`max` is the maximum value this control can accept. Depending on the control
    ID, this value can be mangled by the core.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max`是此控件可以接受的最大值。根据控件ID，这个值可能会被核心修改。'
- en: '`step` is the control''s step value.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`step` 是控件的步进值。'
- en: '`def` is the control''s default value.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def` 是控件的默认值。'
- en: Controls are meant to be set/get. This is the purpose of the preceding ops argument.
    This means that prior to initializing a control, you should first define the ops
    that will be called when setting/getting this control's value. That said, the
    whole control list can be addressed by the same ops. In this case, the ops callback
    will have to `switch ... case` to handle different controls.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 控件的目的是设置/获取。这是前面的 ops 参数的目的。这意味着在初始化控件之前，您应该首先定义将在设置/获取此控件的值时调用的操作。也就是说，整个控件列表可以由相同的操作处理。在这种情况下，操作回调将必须使用
    `switch ... case` 来处理不同的控件。
- en: 'As we have seen earlier, control operations are of the `struct v4l2_ctrl_ops`
    type and are defined as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，控件操作是 `struct v4l2_ctrl_ops` 类型，并被定义如下：
- en: '[PRE40]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding structure is made of three callbacks, each with a specific purpose:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结构由三个回调组成，每个都有特定的目的：
- en: '`g_volatile_ctrl` gets the new value for the given control. Providing this
    callback only makes sense for volatile (those changed by the hardware itself,
    and that are read-only most of the time, such as the signal strength or autogain,
    for example) controls.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g_volatile_ctrl` 获取给定控件的新值。只有在对易失性控件（由硬件自身更改，并且大部分时间是只读的，例如信号强度或自动增益）提供此回调才有意义。'
- en: '`try_ctrl`, if set, is invoked to test whether the control''s value to be applied
    is valid. Providing this callback only makes sense if the usual min/max/step checks
    are insufficient.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try_ctrl`，如果设置，将被调用来测试要应用的控件值是否有效。只有在通常的最小/最大/步长检查不足以时，提供此回调才有意义。'
- en: '`s_ctrl` is invoked to set the control''s value.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s_ctrl` 被调用来设置控件的值。'
- en: 'Optionally, you can call `v4l2_ctrl_handler_setup()` on the control handler
    in order to set up this handler''s controls to their default values. This helps
    to ensure that the hardware and the driver''s internal data structures are in
    sync:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，您可以在控件处理程序上调用 `v4l2_ctrl_handler_setup()` 来设置此处理程序的控件为它们的默认值。这有助于确保硬件和驱动程序的内部数据结构保持同步：
- en: '[PRE41]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This function iterates over all the controls in the given handler and calls
    the `s_ctrl` callback with each control's default value.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数遍历给定处理程序中的所有控件，并使用每个控件的默认值调用 `s_ctrl` 回调。
- en: To summarize what we have seen throughout this V4L2 control interface section,
    let's now study in more detail an excerpt of the `OV7740` camera sensor's driver
    (present in `drivers/media/i2c/ov7740.c`), especially the part dealing with V4L2
    controls.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下我们在整个 V4L2 控件接口部分所看到的内容，现在让我们更详细地研究一下 `OV7740` 摄像头传感器的驱动程序（位于 `drivers/media/i2c/ov7740.c`
    中），特别是处理 V4L2 控件的部分。
- en: 'First, we have the implementation of the control `ops->sg_ctrl` callback:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有控件 `ops->sg_ctrl` 回调的实现：
- en: '[PRE42]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding callback only addresses the control ID of `V4L2_CID_AUTOGAIN`.
    It makes sense as the gain value may be changed by the hardware while in *auto*
    mode. This driver implements the `ops->s_ctrl` control as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的回调只涉及 `V4L2_CID_AUTOGAIN` 的控件 ID。这是有意义的，因为增益值可能在 *自动* 模式下由硬件更改。此驱动程序实现了 `ops->s_ctrl`
    控件如下：
- en: '[PRE43]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding code block also shows how easy it is to implement a menu control
    using the `V4L2_CID_EXPOSURE_AUTO` control as an example and whose possible values
    are enumerated in `enum v4l2_exposure_auto_type`. Finally, the control ops structure
    that will be given for control creation is defined as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块还展示了使用 `V4L2_CID_EXPOSURE_AUTO` 控件作为示例来实现菜单控件有多么容易，其可能的值在 `enum v4l2_exposure_auto_type`
    中被枚举。最后，将用于控件创建的控件操作结构被定义如下：
- en: '[PRE44]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once defined, this control op can be used to initialize controls. The following
    is the `ov7740_init_controls()` method (invoked in the `probe()` function) excerpt,
    mangled and shrunk for the purposes of readability:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，这个控件操作可以用来初始化控件。以下是 `ov7740_init_controls()` 方法（在 `probe()` 函数中调用）的摘录，为了可读性的目的而被修改和缩小：
- en: '[PRE45]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can see the control handler being assigned to the sub-device at the return
    path of the preceding function. Finally, somewhere in the code (the ov7740''s
    driver does this from within the sub-device''s `v4l2_subdev_video_ops.s_stream`
    callback), you should set all controls to their default values:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到控件处理程序被分配给子设备在前面函数的返回路径上。最后，在代码的某个地方（ov7740 的驱动程序在子设备的 `v4l2_subdev_video_ops.s_stream`
    回调中执行此操作），您应该将所有控件设置为它们的默认值：
- en: '[PRE46]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There is more on V4L2 controls at [https://www.kernel.org/doc/html/v4.19/media/kapi/v4l2-controls.html](https://www.kernel.org/doc/html/v4.19/media/kapi/v4l2-controls.html).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 V4L2 控件的更多信息，请访问[https://www.kernel.org/doc/html/v4.19/media/kapi/v4l2-controls.html](https://www.kernel.org/doc/html/v4.19/media/kapi/v4l2-controls.html)。
- en: A word about control inheritance
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于控件继承的说明
- en: It is common for sub-device drivers to implement controls already implemented
    by the bridge's V4L2 driver.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 子设备驱动程序通常实现了桥接的 V4L2 驱动程序已经实现的控件。
- en: When `v4l2_device_register_subdev()` is invoked on `v4l2_subdev` and `v4l2_device`
    and the `ctrl_handler` fields of both are set, then the sub-device's controls
    will be added (by means of the `v4l2_ctrl_add_handler()` helper, which adds a
    given handler's control to another handler) to the `v4l2_device` controls. Sub-device
    controls that are already implemented by `v4l2_device` will be skipped. This means
    that a V4L2 driver can always override a `subdev` control.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 `v4l2_subdev` 和 `v4l2_device` 上调用 `v4l2_device_register_subdev()` 并设置两者的
    `ctrl_handler` 字段时，那么子设备的控件将被添加（通过 `v4l2_ctrl_add_handler()` 辅助函数，该函数将给定处理程序的控件添加到另一个处理程序中）到
    `v4l2_device` 的控件中。已经由 `v4l2_device` 实现的子设备控件将被跳过。这意味着 V4L2 驱动程序可以始终覆盖 `subdev`
    控件。
- en: That said, a control may perform low-level, hardware-specific operations on
    a given sub-device and the sub-device driver may not want this control to be available
    to the V4L2 driver (and so is not added to its control handler). In this case,
    the sub-device driver has to set the `is_private` member of the control to `1`
    (or `true`). This will make the control private to the sub-device.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，控制可能对给定的子设备执行低级别的硬件特定操作，而子设备驱动程序可能不希望此控制对V4L2驱动程序可用（因此不会添加到其控制处理程序）。在这种情况下，子设备驱动程序必须将控件的`is_private`成员设置为`1`（或`true`）。这将使控制对子设备私有。
- en: Important note
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Even though sub-device controls are added to the V4L2 device, they remain accessible
    through the control device node.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 即使子设备控件被添加到V4L2设备，它们仍然可以通过控制设备节点访问。
- en: Summary
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we dealt with V4L2 bridge device driver development, as well
    as the concept of sub-devices. We learned about the V4L2 architecture and are
    now familiar with its data structures. We studied the videobuf2 API and are now
    able to write platform bridge device drivers. Moreover, we should be able to implement
    sub-device operations, and to leverage the videobuf2 core.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了V4L2桥接设备驱动程序的开发，以及子设备的概念。我们了解了V4L2的架构，并且现在熟悉了它的数据结构。我们学习了videobuf2
    API，并且现在能够编写平台桥接设备驱动程序。此外，我们应该能够实现子设备操作，并利用videobuf2核心。
- en: This chapter can be regarded as the first part of a big picture, since the next
    chapter still addresses V4L2, but we will deal with the async core and integration
    with the media controller frameworks.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 本章可以被视为一个大局的第一部分，因为下一章仍然涉及V4L2，但我们将处理异步核心和与媒体控制器框架的集成。
