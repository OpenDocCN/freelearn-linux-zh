- en: 'Additional Information: Advanced Char Driver Operations'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加信息：高级字符驱动程序操作
- en: Technical requirements
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: When we have to manage a peripheral, it's quite common to need to modify its
    internal configuration settings, or it may be useful to map it from the user space
    as if it was a memory buffer in which we can modify internal data just by referencing
    a pointer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们必须管理外围设备时，通常需要修改其内部配置设置，或者将其从用户空间映射为内存缓冲区可能很有用，就好像我们可以通过引用指针来修改内部数据一样。
- en: For example, frame buffers or frame grabbers are good candidates to be mapped
    as a big chunk of memory from the user space point of view.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，帧缓冲区或帧抓取器是作为用户空间的大块内存映射的良好候选者。
- en: In this case, having the support of the `lseek()`, `ioctl()`, and `mmap()` system
    calls is fundamental. If, from the user space, the usage of these system calls
    is not tricky, within the kernel they require some attention by the driver developer,
    especially the `mmap()` system call, which involves the kernel **Memory Management
    Unit** (**MMU**).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，具有`lseek()`、`ioctl()`和`mmap()`系统调用的支持是至关重要的。如果从用户空间使用这些系统调用并不复杂，在内核中，它们需要驱动程序开发人员的一些注意，特别是`mmap()`系统调用，它涉及内核**内存管理单元**（**MMU**）。
- en: Not only that one of the principal tasks a driver developer must pay attention
    to is the data exchanging mechanism with the user space; in fact, realizing a
    good implementation of this mechanism may simplify a lot of the peripheral's management.
    Using read and write memory buffers, for example, may increase the system performance
    when one or more processes get access to the peripheral, giving to the userspace
    developer a good range of setup and management mechanisms to allow them to get
    the maximum from our hardware.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅驱动程序开发人员必须注意的主要任务之一是与用户空间的数据交换机制；事实上，实现这种机制的良好实现可能会简化许多外围设备的管理。例如，使用读取和写入内存缓冲区可能会提高系统性能，当一个或多个进程访问外围设备时，为用户空间开发人员提供了一系列良好的设置和管理机制，使他们能够充分利用我们的硬件。
- en: Going up and down within a file with lseek()
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用lseek()在文件中上下移动
- en: 'Here we should remember that the prototypes of the `read()` and `write()` system
    calls were the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们应该记住`read()`和`write()`系统调用的原型如下：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we tested our char driver using the program in the `chapter_03/chrdev_test.c`
    file, we noticed that we weren''t able to reread written data unless we patched
    our file as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`chapter_03/chrdev_test.c`文件中的程序测试我们的字符驱动程序时，我们注意到除非我们对文件进行了如下修补，否则我们无法重新读取写入的数据：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That was without closing and then reopening the file connected with our driver
    (in this manner, the kernel automatically resets the value pointed by `ppos` to
    `0`).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在不关闭然后重新打开与我们的驱动程序连接的文件的情况下（这样，内核会自动将`ppos`指向的值重置为`0`）。
- en: 'However, this is not the only way to modify the value pointed by `ppos;` in
    fact, we can also use the `lseek()` system call to do it. The prototype of the
    system call, as reported by its man page (`man 2 lseek`), is as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是修改`ppos`指向的值的唯一方法；事实上，我们也可以使用`lseek()`系统调用来做到这一点。系统调用的原型，如其手册页（`man 2
    lseek`）所述，如下所示：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, the `whence` parameter can assume the following values (represented by
    definitions in the following code):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`whence`参数可以假定以下值（由以下代码中的定义表示）：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, for instance, if we wish to move `ppos` to point to the beginning of our
    device''s data buffer as we did in [Chapter 3](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml), *Working
    with Char Drivers*, but without closing and the reopening the device file, we
    can do so as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，如果我们希望像在[第3章](1625d420-d3d6-4655-9f08-050a8bb99c90.xhtml)中所做的那样将`ppos`指向我们设备的数据缓冲区的开头，但是不关闭和重新打开设备文件，我们可以这样做：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that all these modifications are stored in `modify_lseek_to_chrdev_test.patch`
    file from GitHub repository and they can be applied by using the next command
    within the `chapter_03` directory, where the file `chrdev_test.c` is located:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有这些修改都存储在GitHub存储库中的`modify_lseek_to_chrdev_test.patch`文件中，可以通过在`chapter_03`目录中使用以下命令应用，该目录中包含`chrdev_test.c`文件：
- en: '**`$ patch -p2 < ../../chapter_07/modify_lseek_to_chrdev_test.patch`**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**`$ patch -p2 < ../../chapter_07/modify_lseek_to_chrdev_test.patch`**'
- en: 'If we take a look at the `linux/include/uapi/linux/fs.h` header file, we can
    see how these definitions are declared:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下`linux/include/uapi/linux/fs.h`头文件，我们可以看到这些定义是如何声明的：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `lseek()` implementation is so trivial that in the `linux/fs/read_write.c` file we
    can find a default implementation of this method named `default_llseek()`. Its
    prototype is reported as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`lseek()`的实现是如此简单，以至于在`linux/fs/read_write.c`文件中我们可以找到一个名为`default_llseek()`的此方法的默认实现。其原型如下所示：'
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is because if we don''t specify our own implementation, then the kernel
    will automatically use the one in the preceding code block. However, if we take
    a quick look at the `default_llseek( )` function, we notice that it''s not suitable
    for our device because it''s too *file-oriented* (that is, it works well when
    the file against which the `lseek()` operates on is a real file and not a peripheral),
    so we can instead use one of the two next alternative implementations for `lseek()` to
    perform no operations, by using the `noop_llseek()` function:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为如果我们不指定自己的实现，那么内核将自动使用前面代码块中的实现。然而，如果我们快速查看`default_llseek()`函数，我们会注意到它对我们的设备不太适用，因为它太*面向文件*（也就是说，当`lseek()`操作的文件是真实文件而不是外围设备时，它可以很好地工作），因此我们可以使用`noop_llseek()`函数来代替`lseek()`的两种替代实现之一来执行无操作：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or we can just return an error, and then signal the user space that our device
    is not suitable to be sought by using the  `no_llseek()` function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以返回一个错误，然后使用`no_llseek()`函数向用户空间发出信号，表明我们的设备不适合使用寻址：
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The two preceding functions are located in the `linux/fs/read_write.c` file of
    the kernel sources.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个前面的函数位于内核源码的`linux/fs/read_write.c`文件中。
- en: 'The different usage of these two functions is well described by the comment
    above regarding `noop_llseek()`; while `default_llseek()` is not usually suitable
    for a char device, we can simply use `no_llseek()` or, in those rare special cases
    when the user space expects the seek to succeed, but the (device) file is actually
    unable to perform the seek, we can use `no_llseek()` as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个功能的不同用法在上面关于`noop_llseek()`的评论中有很好的描述；虽然`default_llseek()`通常不适用于字符设备，但我们可以简单地使用`no_llseek()`，或者在那些罕见的特殊情况下，用户空间期望寻址成功，但（设备）文件实际上无法执行寻址时，我们可以使用`no_llseek()`如下：
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This piece of code is referred to by the chrdev character driver as discussed
    in [Chapter 4](5f22a69e-e8b7-402e-8e67-72938d00c914.xhtml), *Using the Device
    Tree*, within the  `chapter_04/chrdev/chrdev.c` file on GitHub.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是在GitHub的`chapter_04/chrdev/chrdev.c`文件中讨论的chrdev字符驱动程序中提到的，如[第4章](5f22a69e-e8b7-402e-8e67-72938d00c914.xhtml)中所述，*使用设备树*。
- en: Using ioctl() for custom commands
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ioctl()进行自定义命令
- en: In [Chapter 3](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=30&action=edit#post_26), *W**orking
    with Char Drivers*, we discussed the file abstraction and mentioned that a char
    driver is very similar to a usual file, from the user space point of view. However,
    it's not a file at all; it is used as a file but it belongs to a peripheral, and,
    usually, peripherals need to be configured to work correctly, due to the fact
    they may support different methods of operation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=30&action=edit#post_26)中，*使用字符驱动程序*，我们讨论了文件抽象，并提到字符驱动程序在用户空间的角度上与通常的文件非常相似。但是，它根本不是一个文件；它被用作文件，但它属于一个外围设备，通常需要配置外围设备才能正常工作，因为它们可能支持不同的操作方法。
- en: Let's consider, for instance, a serial port; it looks like a file where we can (forever) read
    or write using both the `read()` and `write()` system calls, but to do so, in
    most cases, we must also set some communication parameters such as the baud rate,
    parity bit, and so on. Of course, these parameters can't be set with `read()` or `write()`,
    nor by using the `open()` system call (even if it can set some accessing modes
    as read or write only), so the kernel offers us a dedicated system call that we
    can use to set such serial communication parameters. This system call is the `ioctl()`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑一个串行端口；它看起来像一个文件，我们可以使用`read()`和`write()`系统调用进行读取或写入，但在大多数情况下，我们还必须设置一些通信参数，如波特率、奇偶校验位等。当然，这些参数不能通过`read()`或`write()`来设置，也不能通过使用`open()`系统调用来设置（即使它可以设置一些访问模式，如只读或只写），因此内核为我们提供了一个专用的系统调用，我们可以用来设置这些串行通信参数。这个系统调用就是`ioctl()`。
- en: 'From the userspace point of view, it looks like its man page (available by
    using the `man 2 ioctl `command):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户空间的角度来看，它看起来像是它的man页面（通过使用`man 2 ioctl`命令可用）：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As stated in the preceding paragraph, the `ioctl()` system call manipulates
    the underlying device parameters of special files (as with our char devices, but
    not only this in fact, it can be used on net or block devices too) by taking,
    as the first argument, the file descriptor (obtained by opening our device), and
    as the second argument, a device-dependent request code. Finally, as the third
    and optional argument, an untyped pointer to memory that userspace programmers
    can use to exchange data with the driver.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的段落所述，`ioctl()`系统调用通过获取文件描述符（通过打开我们的设备获得）作为第一个参数，以及设备相关的请求代码作为第二个参数，来操作特殊文件的底层设备参数（就像我们的字符设备一样，但实际上不仅仅是这样，它也可以用于网络或块设备），最后，作为第三个可选参数，是一个无类型指针，用户空间程序员可以用来与驱动程序交换数据。
- en: 'So, thanks to this general definition, a driver developer can implement their
    custom commands to manage the underlying device. Even if not strictly required,
    an `ioctl()` command has encoded in it whether the argument is an in parameter
    or out parameter, and the size of the third argument in bytes. Macros and definitions
    used to specify an `ioctl()` request are located in the  `linux/include/uapi/asm-generic/ioctl.h` file, as
    reported in the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，借助这个通用定义，驱动程序开发人员可以实现他们的自定义命令来管理底层设备。即使不是严格要求，`ioctl()`命令中编码了参数是输入参数还是输出参数，以及第三个参数的字节数。用于指定`ioctl()`请求的宏和定义位于`linux/include/uapi/asm-generic/ioctl.h`文件中，如下所述：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can also read in the preceding comment, the `read()` and `write()` operations
    are from the user space point of view, so when we mark a command as *writing* we
    mean that the userspace is writing and the kernel is reading, while when we mark
    a command as *reading* we mean exactly the inverse.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的评论中也可以看到的，`read()`和`write()`操作是从用户空间的角度来看的，因此当我们将一个命令标记为*写入*时，我们的意思是用户空间在写入，内核在读取，而当我们将一个命令标记为*读取*时，我们的意思是完全相反。
- en: 'As a really simple example about how to use these macros, we can take a look
    at an implementation regarding watchdogs within the file `linux/include/uapi/linux/watchdog.h`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何使用这些宏的一个非常简单的例子，我们可以看一下关于看门狗的实现，位于文件`linux/include/uapi/linux/watchdog.h`中：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A watchdog (or watchdog timer) is usually used in automated systems. It is an
    electronic timer that is used to detect and recover from computer malfunctions.
    In fact, during its normal operation, a process in the system should regularly
    reset the watchdog timer to prevent it from timing out so, if due to a hardware
    fault or program error, the system fails to reset the watchdog, the timer will
    elapse, and the system automatically restarts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 看门狗（或看门狗定时器）通常用于自动化系统。它是一个电子定时器，用于检测和从计算机故障中恢复。事实上，在正常操作期间，系统中的一个进程应定期重置看门狗定时器，以防止它超时，因此，如果由于硬件故障或程序错误，系统未能重置看门狗，定时器将过期，并且系统将自动重新启动。
- en: Here we have the definition of some commands to manage watchdog peripherals,
    each of them defined using the  `_IOR()` macro (used to specify a reading command)
    or the  `_IOWR` macro (used to specify a read/write command). Each command has
    a progressive number followed by the type of data pointed to by the third argument,
    which can be a simple type (as with the preceding `int` type) or a more complex
    one (as with the preceding `struct watchdog_info`). Finally, the `WATCHDOG_IOCTL_BASE` common
    parameter is simply used to add a random value to avoid command duplication.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们定义了一些命令来管理看门狗外围设备，每个命令都使用`_IOR()`宏（用于指定读取命令）或`_IOWR`宏（用于指定读/写命令）进行定义。每个命令都有一个渐进的数字，后面跟着第三个参数指向的数据类型，它可以是一个简单类型（如前面的`int`类型）或一个更复杂的类型（如前面的`struct
    watchdog_info`）。最后，`WATCHDOG_IOCTL_BASE`通用参数只是用来添加一个随机值，以避免命令重复。
- en: Usage of the `type` parameter (`WATCHDOG_IOCTL_BASE` in the preceding example)
    in these macros will be more clear later when we're going to explain our example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面我们将解释我们的示例时，这些宏中`type`参数（在前面的示例中为`WATCHDOG_IOCTL_BASE`）的使用将更加清晰。
- en: Of course this is a pure convention, we can simply use progressive integer numbers
    to define our `ioctl()` commands and it will work perfectly anyway; however, by
    acting this way, we will embed into the command code a lot of useful information.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是一个纯粹的约定，我们可以简单地使用渐进的整数来定义我们的`ioctl()`命令，它仍然可以完美地工作；然而，通过这种方式行事，我们将嵌入到命令代码中很多有用的信息。
- en: 'Once all commands are defined, we need to add our custom `ioctl()` implementation,
    and by taking a look at the `struct file_operations` in the `linux/include/linux/fs.h`,
    file we see that there exist two of them:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有命令都被定义，我们需要添加我们自定义的`ioctl()`实现，并且通过查看`linux/include/linux/fs.h`文件中的`struct
    file_operations`，我们可以看到其中存在两个：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In kernels older than 2.6.36, there was only one `ioctl()` method that acquired
    the **Big Kernel Lock** (**BKL**), so nothing else could execute at the same time.
    This led to very bad performance on a multiprocessor machine, so there was a big
    effort to get rid of it, which is why `unlocked_ioctl()` was introduced. By using
    it, each driver developer can choose which lock to use instead.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.6.36之前的内核中，只有一个`ioctl()`方法可以获取**Big Kernel Lock**（**BKL**），因此其他任何东西都无法同时执行。这导致多处理器机器上的性能非常糟糕，因此大力去除它，这就是为什么引入了`unlocked_ioctl()`。通过使用它，每个驱动程序开发人员都可以选择使用哪个锁。
- en: On the other side, `compat_ioctl()`, even though it was added at the same time,
    is actually unrelated to `unlocked_ioctl()`. Its purpose is to allow 32-bit userspace
    programs to make `ioctl()` calls on a 64-bit kernel.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`compat_ioctl()`，尽管是同时添加的，但实际上与`unlocked_ioctl()`无关。它的目的是允许32位用户空间程序在64位内核上进行`ioctl()`调用。
- en: Finally, we should first note that the commands and structure definitions must
    be used in both user and kernel spaces, so when we define the exchanged data types,
    we must use those data types available to both spaces (that's why the  `__u32` type has
    been used instead of `u32`, which actually only lives inside the kernel).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该首先注意到命令和结构定义必须在用户空间和内核空间中使用，因此当我们定义交换的数据类型时，必须使用这两个空间都可用的数据类型（这就是为什么使用`__u32`类型而不是`u32`，后者实际上只存在于内核中）。
- en: 'Moreover, when we wish to use custom `ioctl()` commands, we must define them
    into a separate header file, which must be shared with the user space; in this
    manner, we can keep kernel codes separate from the userspace. However, just in
    case it was difficult to separate all userspace codes from the kernel space, we
    can use the  `__KERNEL__`definition as in the following snippet to instruct the
    preprocessor to exclude some code according to the space we are compiling into:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们希望使用自定义的`ioctl()`命令时，我们必须将它们定义到一个单独的头文件中，并且必须与用户空间共享；通过这种方式，我们可以将内核代码与用户空间分开。然而，如果难以将所有用户空间代码与内核空间分开，我们可以使用`__KERNEL__`定义，如下面的片段所示，指示预处理器根据我们编译的空间来排除一些代码：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That's why, usually, header files holding `ioctl()` commands are usually located
    under the `linux/include/uapi` directory, which holds all header files needed
    by userspace programs for compilation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么通常，包含`ioctl()`命令的头文件通常位于`linux/include/uapi`目录下，该目录包含用户空间程序编译所需的所有头文件。
- en: Accessing I/O memory with mmap()
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用mmap()访问I/O内存
- en: In the *Getting access to I/O memory* recipe in [Chapter 6,](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=30&action=edit#post_29) *Miscellaneous
    Kernel Internals,* we saw how the MMU works and how we can get access to a memory-mapped
    peripheral. Within the kernel space, we must instruct the MMU in order to correctly
    translate a virtual address into a proper one, which must point to a well-defined
    physical address to which our peripheral belongs, otherwise, we can't control
    it!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=30&action=edit#post_29)的*杂项内核内部*中的*获取I/O内存访问*中，我们看到了MMU的工作原理以及如何访问内存映射的外围设备。在内核空间中，我们必须指示MMU以便正确地将虚拟地址转换为一个正确的地址，这个地址必须指向我们外围设备所属的一个明确定义的物理地址，否则我们无法控制它！
- en: 'On the other hand, in that section, we also used a userspace tool named `devmem2`, which
    can be used to get access to a physical address from the user space, using the `mmap()` system
    call. This system call is really interesting, because it allows us to do a lot
    of useful things, so let''s start by taking a look at its man page (`man 2 mmap`):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在该部分，我们还使用了一个名为`devmem2`的用户空间工具，它可以使用`mmap()`系统调用从用户空间访问物理地址。这个系统调用非常有趣，因为它允许我们做很多有用的事情，所以让我们先来看一下它的man页面（`man
    2 mmap`）：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we can see from the preceding snippet, by using `mmap()` we can create a new
    mapping in the virtual address space of the calling process, which can be related
    to the file descriptor, `fd`, passed as a parameter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从前面的片段中看到的，通过使用`mmap()`，我们可以在调用进程的虚拟地址空间中创建一个新的映射，这个映射可以与作为参数传递的文件描述符`fd`相关联。
- en: Usually, this system call is used to map a normal file within the system memory
    in such a way that it can be then addressed using a normal pointer and not by
    the usual `read()` and `write()` system calls.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，此系统调用用于以这样的方式将普通文件映射到系统内存中，以便可以使用普通指针而不是通常的`read()`和`write()`系统调用来寻址。
- en: 'Just as a simple example, let''s consider a usual file as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 举个简单的例子，让我们考虑一个通常的文件如下：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is a normal text file holding three lines of text. We can read and write
    it on our Terminal just using the `cat` command as stated previously; of course,
    we now know that the `cat` command runs an `open()` and then one or more `read()` operation on
    the file, followed by one or more `write()` operation on the standard output (which,
    in turn, is a file abstraction connected to our terminal). However, this file
    can also be read as it was a memory buffer of chars, using the `mmap()` system
    call, and this can be done through the following steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含三行文本的普通文本文件。我们可以在终端上使用`cat`命令读取和写入它，就像之前所述的那样；当然，我们现在知道`cat`命令在文件上运行`open()`，然后是一个或多个`read()`操作，然后是一个或多个`write()`操作，最后是标准输出（反过来是连接到我们终端的文件抽象）。但是，这个文件也可以被读取为一个char的内存缓冲区，使用`mmap()`系统调用，可以通过以下步骤完成：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A complete code implementation of the preceding example will be presented in
    the following snippet. This is a snippet of the `chrdev_mmap.c` file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例的完整代码实现将在以下片段中呈现。这是`chrdev_mmap.c`文件的片段。
- en: So, as we can see, we first opened the file as usual, but then, instead of using
    the `read()` system call, we did a `mmap()` and, finally, we used the returned
    memory address as a char pointer to print out the memory buffer. Note that after
    the `mmap()` we'll have something like an image of the file within the memory.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们所看到的，我们首先像往常一样打开文件，但是，我们没有使用`read()`系统调用，而是使用了`mmap()`，最后，我们使用返回的内存地址作为char指针来打印内存缓冲区。请注意，在`mmap()`之后，我们将在内存中得到文件的图像。
- en: 'If we try to execute the preceding code on the `textfile.txt `file, we get
    what we expected:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在`textfile.txt`文件上执行前面的代码，我们会得到我们期望的结果：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that I used the `ls` command to get the file length needed by the `chrdev_mmap`
    program.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我使用`ls`命令获取了`chrdev_mmap`程序所需的文件长度。
- en: 'Now we should ask ourselves whether there is a way to map a character device
    (which looks very similar to a file from the user space point of view) as we did
    for the text file above; obviously, the answer is yes! We have to use the `mmap()` method
    defined in `struct file_operations` as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该问自己是否有办法像上面的文本文件一样映射字符设备（从用户空间的角度看起来非常类似文件）；显然，答案是肯定的！我们必须使用`struct file_operations`中定义的`mmap()`方法：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Besides the usual `struct file` pointer that we already perfectly know, this
    function requires the `vma` argument (which is a pointer to `struct vm_area_struct`)
    used to indicate a virtual address space, in which the memory should be mapped
    by the driver.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们已经完全了解的通常的`struct file`指针之外，此函数还需要`vma`参数（指向`struct vm_area_struct`的指针），用于指示应该由驱动程序映射内存的虚拟地址空间。
- en: A struct `vm_area_struc`t holds information about a contiguous virtual memory
    area, which is characterized by a start address, a stop address, length, and permissions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct vm_area_struct`包含有关连续虚拟内存区域的信息，其特征是起始地址、停止地址、长度和权限。'
- en: Each process owns more virtual memory areas, which can be inspected by looking
    at the relative procfs file named `/proc/<PID>/maps` (where `<PID>` is the PID
    number of the process).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程拥有更多的虚拟内存区域，可以通过查看名为`/proc/<PID>/maps`的相对procfs文件来检查（其中`<PID>`是进程的PID号）。
- en: The virtual memory areas are a really complex part of Linux memory manager,
    which is not covered in this book. Curious readers can take a look at [https://www.kernel.org/doc/html/latest/admin-guide/mm/index.html](https://www.kernel.org/doc/html/latest/admin-guide/mm/index.html)
    for further information.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟内存区域是Linux内存管理器的一个非常复杂的部分，本书未涉及。好奇的读者可以查看[https://www.kernel.org/doc/html/latest/admin-guide/mm/index.html](https://www.kernel.org/doc/html/latest/admin-guide/mm/index.html)以获取更多信息。
- en: 'The mapping of a physical address to the user address space, as indicated by
    the `vma` parameter, can be easily done using helper functions such as `remap_pfn_range()`, defined
    in the header file `linux/include/linux/mm.h` as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将物理地址映射到用户地址空间，如`vma`参数所示，可以使用辅助函数轻松完成，例如在头文件`linux/include/linux/mm.h`中定义的`remap_pfn_range()`：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It will map a contiguous physical address space addressed by `pfn` into the
    virtual space represented by the `vma` pointer. In particular, the parameters
    are:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它将由`pfn`寻址的连续物理地址空间映射到由`vma`指针表示的虚拟空间。具体来说，参数是：
- en: '`vma` - The virtual memory space in which mapping is made'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vma` - 进行映射的虚拟内存空间'
- en: '`addr` - The virtual address space from where remapping begins'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addr` - 重新映射开始的虚拟地址空间'
- en: '`pfn` - The physical address (expressed in terms of page frame number) to which
    the virtual address should be mapped'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pfn` - 虚拟地址应映射到的物理地址（以页面帧号表示）'
- en: '`size` - The size in bytes of the memory to be mapped'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size` - 要映射的内存大小（以字节为单位）'
- en: '`prot` - Protection flags for this mapping'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prot` - 此映射的保护标志'
- en: 'So, a really simple `mmap()` implementation, considering a peripheral as having
    a memory area at physical address `base_addr` and size of `area_len`, can be done
    as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个真正简单的`mmap()`实现，考虑到外围设备在物理地址`base_addr`处具有内存区域，大小为`area_len`，可以如下所示：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As a final note, we have to keep in mind that `remap_pfn_range()` works with
    a physical address, while memory allocated using `kmalloc()` or `vmalloc()` functions
    and friends (see [Chapter 6](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=30&action=edit#post_29), *Miscellaneous
    Kernel Internals*) must be managed using a different approach. For `kmalloc()`,
    we can use something like the following to get the `pfn` parameter:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后需要注意的是，`remap_pfn_range()`使用物理地址，而使用`kmalloc()`或`vmalloc()`函数和相关函数（参见[第6章](https://cdp.packtpub.com/linux_device_driver_development_cookbook/wp-admin/post.php?post=30&action=edit#post_29)，*杂项内核内部*）分配的内存必须使用不同的方法进行管理。对于`kmalloc()`，我们可以使用以下方法来获取`pfn`参数：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Where kvirt is the kernel virtual address to be remapped returned by `kmalloc()`,
    for `vmalloc()` we can do as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 其中kvirt是由`kmalloc()`返回的内核虚拟地址要重新映射，对于`vmalloc()`，我们可以这样做：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, `vvirt` is the kernel's virtual address to be remapped returned by `vmalloc()`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`vvirt`是由`vmalloc()`返回的内核虚拟地址要重新映射。
- en: Note that the memory allocated with `vmalloc()` is not physically contiguous,
    so if we want to map a range allocated with it we have to map each page individually
    and compute the physical address for each page. This is a more complicated action,
    which is not explained in this book due to the fact that it's not device-driver
    related (real peripherals only use physical addresses).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`vmalloc()`分配的内存不是物理上连续的，因此，如果我们想要映射使用它分配的范围，我们必须逐个映射每个页面，并计算每个页面的物理地址。这是一个更复杂的操作，本书没有解释，因为它与设备驱动程序无关（真正的外围设备只使用物理地址）。
- en: Locking with the process context
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用进程上下文进行锁定
- en: It's good to understand how to avoid race conditions in case more than one process
    tries to get access to our driver, or how to put to sleep a reading process (we
    talk about reading here, but the same thing also holds true for writing) in case
    our driver has no data to supply. The former case will be presented here, while
    the latter will be presented in the next section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何避免竞争条件是很重要的，因为可能会有多个进程尝试访问我们的驱动程序，或者如何使读取进程进入睡眠状态（我们在这里讨论读取，但对于写入也是一样的）如果我们的驱动程序没有数据供应。前一种情况将在这里介绍，而后一种情况将在下一节介绍。
- en: If we take a look at how `read()` and `write()` system calls have been implemented
    in our chrdev driver, we can easily notice that, if more than one process tries
    to do a `read()` call or even if one process attempts a `read()` call and another
    tries a `write()` call, a race condition will occur. This is because the ESPRESSObin's
    CPU is a multiprocessor composed of two cores and so it can effectively execute
    two processes at the same time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下我们的chrdev驱动程序中如何实现`read()`和`write()`系统调用，我们很容易注意到，如果多个进程尝试进行`read()`调用，甚至如果一个进程尝试进行`read()`调用，另一个尝试进行`write()`调用，就会发生竞争条件。这是因为ESPRESSObin的CPU是由两个核心组成的多处理器，因此它可以有效地同时执行两个进程。
- en: However, even if our system had just one core, it still may happen that `read()` or `write()` code
    inside these methods' critical sections is executed in an interleaved (that is
    non-atomic) manner due to the fact that, for instance, functions `copy_to_user()` and `copy_from_user()` may
    put to sleep the calling process and so the scheduler may revoke the CPU to one
    of them in favor of another process, which, in turn, calls again into the same
    driver's  `read()` or `write()` methods.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使我们的系统只有一个核心，由于例如函数`copy_to_user()`和`copy_from_user()`可能使调用进程进入睡眠状态，因此调度程序可能会撤销CPU以便将其分配给另一个进程，这样，即使我们的系统只有一个核心，仍然可能发生`read()`或`write()`方法内部的代码以交错（即非原子）方式执行。
- en: To avoid possible race conditions in these situations, a really reliable solution
    is using a mutex as presented in [Chapter 5](cbd6e9f7-f07c-46b8-b751-ece44101ca8b.xhtml), *Managing
    Interrupts and Concurrency*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些情况可能发生的竞争条件，一个真正可靠的解决方案是使用互斥锁，正如[第5章](cbd6e9f7-f07c-46b8-b751-ece44101ca8b.xhtml)中所介绍的那样，*管理中断和并发*。
- en: We simply need a mutex for each chrdev device to protect multiple access to
    the driver's methods.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要为每个chrdev设备使用一个互斥锁来保护对驱动程序方法的多次访问。
- en: Waiting for I/O operations with poll() and select()
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用poll()和select()等待I/O操作
- en: In a complex system such as a modern computer, it's quite common to have several useful peripherals
    to acquire information about the external environment and/or the system's status.
    Sometimes, we may use different processes to manage them but we may need to manage
    more than one peripheral at a time, but with just a single process.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代计算机这样的复杂系统中，通常会有几个有用的外围设备来获取有关外部环境和/或系统状态的信息。有时，我们可能使用不同的进程来管理它们，但可能需要同时管理多个外围设备，但只有一个进程。
- en: 'In this scenario, we can imagine doing several `read()` system calls on each
    peripheral to acquire its data, but what happens if one peripheral is quite slow
    and it takes a lot of time to return its data? If we do the following, we may
    slow down all data acquisition (or even lock it if one peripheral doesn''t receive
    new data):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以想象对每个外围设备进行多次`read()`系统调用来获取其数据，但是如果一个外围设备非常慢，需要很长时间才能返回其数据会发生什么？如果我们这样做，可能会减慢所有数据采集的速度（甚至如果一个外围设备没有接收到新数据，可能会锁定数据采集）：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In fact, if one peripheral is slow, or if it takes a long time to return its
    data, our loop will be stopped to wait for it and our program may not work correctly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果一个外围设备很慢，或者需要很长时间才能返回其数据，我们的循环将停止等待它，我们的程序可能无法正常工作。
- en: One possible solution may be to use the `O_NONBLOCK` flag on the offending peripheral,
    or even on all peripherals, but doing this we may overload the CPU with unnecessary
    system calls. It could be more elegant (and efficient) to ask the kernel to tell
    us which file descriptor belongs to peripheral holding data ready to be read (or
    free to be used for a write).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案是在有问题的外围设备上使用`O_NONBLOCK`标志，甚至在所有外围设备上使用，但这样做可能会使CPU过载，产生不必要的系统调用。向内核询问哪个文件描述符属于持有准备好被读取的数据的外围设备（或者可以用于写入）可能更加优雅（和有效）。
- en: 'To do so, we can use the `poll()` or `select()` system calls. The `poll()` man
    page states the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以使用`poll()`或`select()`系统调用。`poll()`手册页中指出：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `select()` man page, on the other hand, is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`select()`手册页如下所示：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Even if they look quite different, they do almost the same things; in fact,
    inside the kernel, they are implemented by using the same `poll()` method, which
    is defined inside the well-known `struct file_operations` as follows (see the
    `linux/include/linux/fs.h` file):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它们看起来非常不同，它们几乎做相同的事情；实际上，在内核内部，它们是通过使用相同的`poll()`方法来实现的，该方法在著名的`struct file_operations`中定义如下（请参阅`linux/include/linux/fs.h`文件）：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'From the kernel''s point of view, the implementation of the `poll()` method
    is really simple; we just need the waitqueue we used above and then we have to
    verify whether our device has some data to return. Simply speaking, a generic `poll()` method
    is like the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核的角度来看，`poll()`方法的实现非常简单；我们只需要上面使用的等待队列，然后我们必须验证我们的设备是否有一些数据要返回。简而言之，通用的`poll()`方法如下所示：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We simply have to use the  `poll_wait()` function to tell the kernel which waitqueue
    the driver uses to put reading or writing processes to sleep, and then we return
    the variable `mask` equal to 0; if no data is ready to be read or we cannot accept
    new data to write, we return the `EPOLLIN | EPOLLRDNORM` value if there is something
    to read bitwise and if we're willing to accept that data, too.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需使用`poll_wait()`函数告诉内核驱动程序使用哪个等待队列来使读取或写入进程进入睡眠状态，然后我们将变量`mask`返回为0；如果没有准备好要读取的数据，或者我们无法接受新的要写入的数据，我们将返回`EPOLLIN
    | EPOLLRDNORM`值，如果有一些数据可以按位读取，并且我们也愿意接受这些数据。
- en: All of the available `poll()` events are defined in the header file `linux/include/uapi/linux/eventpoll.h`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可用的`poll()`事件都在头文件`linux/include/uapi/linux/eventpoll.h`中定义。
- en: 'Once the `poll()` method has been implemented, we can use it, for instance,
    with `select()` as shown in the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`poll()`方法被实现，我们可以使用它，例如，如下所示使用`select()`：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After opening all of the needed file descriptors, we have to use the `FD_ZERO()` macro to
    clean the `read_fds` variable and then we use the  `FD_SET()` macro to add each
    file descriptor to the set of the reading process represented by `read_fds`. When
    done we can pass `read_fds` to `select()` to point out to the kernel which file
    descriptors are to be observed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 打开所有需要的文件描述符后，我们必须使用`FD_ZERO()`宏清除`read_fds`变量，然后使用`FD_SET()`宏将每个文件描述符添加到由`read_fds`表示的读取进程集合中。完成后，我们可以将`read_fds`传递给`select()`，以指示内核要观察哪些文件描述符。
- en: Note that, usually, we should pass, as the first parameter of the `select()` system
    call, the highest number plus 1 of the file descriptors within the observed set;
    however, we can also pass the `FD_SETSIZE` value, which is the maximum allowed
    value permitted by the system. This can be a very large value, so programming
    this way leads to inefficiency in scanning the whole file descriptor bitmap; good
    programmers should use the maximum value plus 1 instead.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，通常情况下，我们应该将观察集合中文件描述符的最高编号加1作为`select()`系统调用的第一个参数；然而，我们也可以传递`FD_SETSIZE`值，这是系统允许的最大允许值。这可能是一个非常大的值，因此以这种方式编程会导致扫描整个文件描述符位图的低效性；好的程序员应该使用最大值加1。
- en: Note, also, that our example is valid for reading, but exactly the same can
    be used for writing!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，我们的示例适用于读取，但完全相同的方法也适用于写入！
- en: Managing asynchronous notifications with fasync()
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`fasync()`管理异步通知
- en: In the previous section, we considered the special case in which we can have
    a process that must manage more than one peripheral. In this situation, we can
    ask the kernel, which is the ready file descriptor, where to get data from or
    where to write data to using the `poll()` or `select()` system call. However,
    this is not the only solution. Another possibility is to use the `fasync()` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们考虑了一个特殊情况，即我们可能需要管理多个外围设备的情况。在这种情况下，我们可以询问内核，即准备好的文件描述符，从哪里获取数据或使用`poll()`或`select()`系统调用将数据写入。然而，这不是唯一的解决方案。另一种可能性是使用`fasync()`方法。
- en: By using this method, we can ask the kernel to send a signal (usually `SIGIO`)
    whenever a new event has occurred on a file descriptor; the event, of course,
    is a ready-to-read or read-to-write event and the file descriptor is the one connected
    with our peripheral.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种方法，我们可以要求内核在文件描述符上发生新事件时发送信号（通常是`SIGIO`）；当然，事件是准备好读取或准备好写入的事件，文件描述符是与我们的外围设备连接的文件描述符。
- en: 'The `fasync()` method does not have a userspace counterpart due to the already
    presented methods in this book; there is no `fasync()` system call at all. We
    can use it indirectly by utilizing the `fcntl()` system call. If we take a look
    at its man pages, we see the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书中已经介绍的方法，`fasync()`方法没有用户空间对应项；根本没有`fasync()`系统调用。我们可以通过利用`fcntl()`系统调用间接使用它。如果我们查看它的手册页，我们会看到以下内容：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s do one step at a time. From the kernel point of view, we have to
    implement the `fasync()` method, which is defined, as usual, within `struct file_operations` as
    below (see the `linux/include/linux/fs.h` file):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们一步一步来。从内核的角度来看，我们必须实现`fasync()`方法，如下所示（请参阅`linux/include/linux/fs.h`文件中的`struct
    file_operations`）：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Its implementation is really trivial because by using the `fasync_helper()`
    helper function, the only steps we need are reported for a generic driver in the
    following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 它的实现非常简单，因为通过使用`fasync_helper()`辅助函数，我们只需要在以下通用驱动程序中报告的步骤：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Where `fasync_queue` is a pointer of a `struct fasync_struct` that the kernel
    uses to enqueue all processes interested in receiving the `SIGIO` signal whenever
    the driver is ready for reading or writing operations. These events are notified
    using the  `kill_fasync()` function, usually within an interrupt handler or whenever
    we know that new data has arrived or we are ready to write:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`fasync_queue`是一个指向`struct fasync_struct`的指针，内核使用它来排队所有对接收`SIGIO`信号感兴趣的进程，每当驱动程序准备好进行读取或写入操作时。这些事件使用`kill_fasync()`函数通知，通常在中断处理程序中或者每当我们知道新数据已经到达或者我们准备写入时。
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that we have to use `POLL_IN` when data is available to read, while we
    should use `POLL_OUT` when our peripheral is ready to accept new data.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当数据可供读取时，我们必须使用`POLL_IN`，而当我们的外围设备准备好接受新数据时，我们应该使用`POLL_OUT`。
- en: Please see the  `linux/include/uapi/asm-generic/siginfo.h` file for all available `POLL_*` definitions.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅`linux/include/uapi/asm-generic/siginfo.h`文件，查看所有可用的`POLL_*`定义。
- en: 'From the userspace point of view, we need to take some steps to achieve the `SIGIO` signal:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户空间的角度来看，我们需要采取一些步骤来实现`SIGIO`信号：
- en: First, we have to install a proper signal handler.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须安装一个合适的信号处理程序。
- en: Then we have to call `fcntl()` with the  `F_SETOWN` command to set the process
    ID (usually called a PID) that will receive the `SIGIO` related to our device
    (addressed by the file descriptor `fd`).
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须使用`F_SETOWN`命令调用`fcntl()`来设置将接收与我们的设备相关的`SIGIO`的进程ID（通常称为PID）（由文件描述符`fd`表示）。
- en: Then we have to alter the `flags` describing the file access mode by setting
    the `FASYNC` bit.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须通过设置`FASYNC`位来更改描述文件访问模式的`flags`。
- en: 'A possible implementation is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的实现如下：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
