- en: Pin Control and GPIO Subsystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引脚控制和GPIO子系统
- en: Most embedded Linux driver and kernel engineers write using GPIOs or play with
    pins multiplexing. By pins, I mean outgoing line of component. SoC does multiplex
    pins, meaning that a pin may have several functions, for example, `MX6QDL_PAD_SD3_DAT1`
    in `arch/arm/boot/dts/imx6dl-pinfunc.h` can be either an SD3 data line 1, UART1's
    cts/rts, Flexcan2's Rx, or normal GPIO.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数嵌入式Linux驱动程序和内核工程师都使用GPIO或玩转引脚复用。在这里，引脚指的是组件的输出线。SoC会复用引脚，这意味着一个引脚可能有多个功能，例如，在`arch/arm/boot/dts/imx6dl-pinfunc.h`中的`MX6QDL_PAD_SD3_DAT1`可以是SD3数据线1、UART1的cts/rts、Flexcan2的Rx或普通的GPIO。
- en: The mechanism by which one choses the mode a pin should work on is called pin
    muxing. The system responsible for is called the pin controller. In the second
    part of the chapter, we will discuss the **General Purpose Input Output** (**GPIO**
    ), which is a special function (mode) in which a pin can operate.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 选择引脚应该工作的模式的机制称为引脚复用。负责此功能的系统称为引脚控制器。在本章的第二部分中，我们将讨论通用输入输出（GPIO），这是引脚可以操作的特殊功能（模式）。
- en: 'In this chapter, we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Walk through the pin control subsystem, and see how one can declare their nodes
    in DT
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解引脚控制子系统，并看看如何在DT中声明它们的节点
- en: Explore both legacy integer-based GPIO interfaces, as well as the new descriptor-based
    interface API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索传统的基于整数的GPIO接口，以及新的基于描述符的接口API
- en: Deal with GPIO mapped to IRQ
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理映射到IRQ的GPIO
- en: Handle sysfs interfaces dedicated to GPIOs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理专用于GPIO的sysfs接口
- en: Pin control subsystem
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引脚控制子系统
- en: The **Pin control** (**pinctrl** ) subsystem allows managing pin muxing. In
    the DT, devices that need pins to be multiplexed in a certain way must declare
    the pin control configuration they need.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚控制（pinctrl）子系统允许管理引脚复用。在DT中，需要以某种方式复用引脚的设备必须声明它们需要的引脚控制配置。
- en: 'The pinctrl subsystem provides:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚控制子系统提供：
- en: Pin multiplexing, which allows for reusing the same pin for different purposes,
    such as one pin being a UART TX pin, GPIO line, or HSI data line. Multiplexing
    can affect groups of pins or individual pins.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引脚复用，允许重用同一引脚用于不同的目的，比如一个引脚可以是UART TX引脚、GPIO线或HSI数据线。复用可以影响引脚组或单个引脚。
- en: Pin configuration, applying electronic properties of pins such as pull-up, pull-down,
    driver strength, debounce period, and so on.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引脚配置，应用引脚的电子属性，如上拉、下拉、驱动器强度、去抖时间等。
- en: The purpose of this book is limited to using functions exported by the pin controller
    driver, and does not not how to write a pin controller driver.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目的仅限于使用引脚控制器驱动程序导出的函数，并不涉及如何编写引脚控制器驱动程序。
- en: Pinctrl and the device tree
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引脚控制和设备树
- en: The pinctrl is nothing but a way to gather pins (not only GPIO), and pass them
    to the driver. The pin controller driver is responsible for parsing pin descriptions
    in the DT and applying their configuration in the chip. The driver usually needs
    a set of two nested nodes to describe group of pins configurations. The first
    node describes the function of the group (what purpose the group will be used
    for), the second holds the pins configuration.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚控制只是一种收集引脚（不仅仅是GPIO）并将它们传递给驱动程序的方法。引脚控制器驱动程序负责解析DT中的引脚描述并在芯片中应用它们的配置。驱动程序通常需要一组两个嵌套节点来描述引脚配置的组。第一个节点描述组的功能（组将用于什么目的），第二个节点保存引脚配置。
- en: How pin groups are assigned in the DT heavily depends on the platform, and thus
    the pin controller driver. Every pin control state is given an integer ID starting
    at 0 and contiguous. One can use a name property, which will be mapped on top
    of IDs, so that the same name always points to the same ID.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚组在设备树中的分配严重依赖于平台，因此也依赖于引脚控制器驱动程序。每个引脚控制状态都被赋予一个从0开始的连续整数ID。可以使用一个名称属性，它将映射到ID上，以便相同的名称始终指向相同的ID。
- en: 'Each client device''s own binding determines the set of states that must be
    defined in its DT node, and whether to define the set of state IDs that must be
    provided, or whether to define the set of state names that must be provided. In
    any case, a pin configuration node can be assigned to a device by means of two
    properties:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个客户设备自己的绑定确定了必须在其DT节点中定义的状态集，以及是否定义必须提供的状态ID集，或者是否定义必须提供的状态名称集。在任何情况下，可以通过两个属性将引脚配置节点分配给设备：
- en: '`pinctrl-<ID>` : This allows for giving the list of pinctrl configurations
    needed for a certain state of the device. It is a list of phandles, each of which
    points to a pin configuration node. These referenced pin configuration nodes must
    be child nodes of the pin controller that they configure. Multiple entries may
    exist in this list so that multiple pin controllers may be configured, or so that
    a state may be built from multiple nodes for a single pin controller, each contributing
    part of the overall configuration.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pinctrl-<ID>`：这允许为设备的某个状态提供所需的pinctrl配置列表。这是一个phandle列表，每个phandle指向一个引脚配置节点。这些引用的引脚配置节点必须是它们配置的引脚控制器的子节点。此列表中可能存在多个条目，以便可以配置多个引脚控制器，或者可以从单个引脚控制器的多个节点构建状态，每个节点都为整体配置的一部分做出贡献。'
- en: '`pinctrl-name` : This allows for giving a name to each state in a list. List
    entry 0 defines the name for integer state ID 0, list entry 1 for state ID 1,
    and so on. The state ID 0 is commonly given the name *default* . The list of standardized
    states can be found in `include/linux/pinctrl/pinctrl-state.h` .'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pinctrl-name`：这允许为列表中的每个状态提供一个名称。列表条目0定义整数状态ID 0的名称，列表条目1定义状态ID 1的名称，依此类推。状态ID
    0通常被赋予名称*default*。标准化状态列表可以在`include/linux/pinctrl/pinctrl-state.h`中找到。'
- en: 'The following is an excerpt of DT, showing some device nodes, along with their
    pin control nodes:'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是DT的摘录，显示了一些设备节点以及它们的引脚控制节点：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding example, a pin configuration is given in the form `<PIN_FUNCTION>
    <PIN_SETTING>` . For example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，引脚配置以`<PIN_FUNCTION> <PIN_SETTING>`的形式给出。例如：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`MX6QDL_PAD_DISP0_DAT15__GPIO5_IO09` represents the pin function, which is
    GPIO in this case, and `0x80000000` represents the pin settings.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`MX6QDL_PAD_DISP0_DAT15__GPIO5_IO09`表示引脚功能，在这种情况下是GPIO，`0x80000000`表示引脚设置。'
- en: For this line,
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一行，
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`MX6QDL_PAD_EIM_D25__UART3_RX_DATA` represents the pin function, which is the
    RX line of UART3, and `0x1b0b1` represent is settings.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`MX6QDL_PAD_EIM_D25__UART3_RX_DATA`表示引脚功能，即UART3的RX线，`0x1b0b1`表示设置。'
- en: 'The pin function is a macro whose value is meaningful for pin controller driver
    only. These are generally defined in header files located in `arch/<arch>/boot/dts/`
    . If one uses a UDOO quad, for example, which has an i.MX6 quad core (ARM), the
    pin function header would be `arch/arm/boot/dts/imx6q-pinfunc.h` . The following
    is the macro corresponding to the fifth line of the GPIO5 controller:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 引脚功能是一个宏，其值仅对引脚控制器驱动程序有意义。这些通常在位于`arch/<arch>/boot/dts/`中的头文件中定义。例如，如果使用的是UDOO
    quad，它具有i.MX6四核（ARM），则引脚功能头文件将是`arch/arm/boot/dts/imx6q-pinfunc.h`。以下是与GPIO5控制器的第五行对应的宏：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`<PIN_SETTING>` can be used to set up things like pull-ups, pull-downs, keepers,
    drive strength, and so on. How it should be specified depends on the pin controller
    binding, and the meaning of its value depends on the SoC data sheet, generally
    in the IOMUX section. On i.MX6 IOMUXC, only lower than 17 bits are used for this
    purpose.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`<PIN_SETTING>`可用于设置上拉电阻、下拉电阻、保持器、驱动强度等。如何指定它取决于引脚控制器绑定，其值的含义取决于SoC数据表，通常在IOMUX部分。在i.MX6
    IOMUXC上，仅使用低于17位来实现此目的。'
- en: These preceding nodes are called from the corresponding driver-specific node.
    Moreover, these pins are configured during corresponding driver initialization.
    Prior to selecting a pin group state, one must get the pin control first using
    the `pinctrl_get()` function, call `pinctrl_lookup_state()` in order to check
    whether the requested state exist or not, and finally `pinctrl_select_state()`
    to apply the state.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些前置节点是从相应的驱动程序特定节点调用的。此外，这些引脚在相应的驱动程序初始化期间进行配置。在选择引脚组状态之前，必须首先使用`pinctrl_get()`函数获取引脚控制，调用`pinctrl_lookup_state()`来检查请求的状态是否存在，最后使用`pinctrl_select_state()`来应用状态。
- en: 'The following is a sample that shows how to get a pincontrol and apply its
    default configuration:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，显示如何获取pincontrol并应用其默认配置：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: One usually performs such steps during driver initialization. The suitable place
    for this code could be within the `probe()` function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在驱动程序初始化期间执行这些步骤。此代码的适当位置可以在`probe()`函数内。
- en: '`pinctrl_select_state()` internally calls `pinmux_enable_setting()` , which
    in turn calls the `pin_request()` on each pin in the pin control node.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`pinctrl_select_state()`在内部调用`pinmux_enable_setting()`，后者又在引脚控制节点中的每个引脚上调用`pin_request()`。'
- en: 'A pin control can be released with the `pinctrl_put()` function. One can use
    the resource-managed version of the API. That said, one can use `pinctrl_get_select()`
    , given the name of the state to select, in order to configure pinmux. The function
    is defined in `include/linux/pinctrl/consumer.h` as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`pinctrl_put()`函数释放引脚控制。可以使用API的资源管理版本。也就是说，可以使用`pinctrl_get_select()`，给定要选择的状态的名称，以配置引脚控制。该函数在`include/linux/pinctrl/consumer.h`中定义如下：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'where `*name` is the state name as written in `pinctrl-name` property. If the
    name of the state is `default` , one can just call `pinctr_get_select_default()`
    function, which is a wrapper around `pinctl_get_select()` :'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`*name`是`pinctrl-name`属性中写的状态名称。如果状态的名称是`default`，可以直接调用`pinctr_get_select_default()`函数，这是`pinctl_get_select()`的包装器：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let us see a real example in a board-specific dts file (`am335x-evm.dts` ):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个真实的例子，位于特定于板的dts文件（`am335x-evm.dts`）中：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And in the corresponding driver:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以及相应的驱动程序：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The pin control core will automatically claim the `default` pinctrl state for
    us when the device is probed. If one defines an `init` state, the pinctrl core
    will automatically set pinctrl to this state before the `probe()` function, and
    then switch to the `default` state after `probe()` (unless the driver explicitly
    changed states already).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备被探测时，引脚控制核心将自动为我们声明`default` pinctrl状态。如果定义了`init`状态，引脚控制核心将在`probe()`函数之前自动将pinctrl设置为此状态，然后在`probe()`之后切换到`default`状态（除非驱动程序已经显式更改了状态）。
- en: The GPIO subsystem
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPIO子系统
- en: 'From the hardware point of view, a GPIO is a functionality, a mode in which
    a pin can operate. From a software point of view, a GPIO is nothing but a digital
    line, which can operate as an input or output, and can have only two values: (`1`
    for high or `0` for low). Kernel GPIO subsystems provide every function you can
    imagine to set up and handle GPIO line from within your driver:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从硬件角度来看，GPIO是一种功能，是引脚可以操作的模式。从软件角度来看，GPIO只是一个数字线，可以作为输入或输出，并且只能有两个值：（`1`表示高，`0`表示低）。内核GPIO子系统提供了您可以想象的每个功能，以便从驱动程序内部设置和处理GPIO线：
- en: 'Prior to using a GPIO from within the driver, one should claim it to the kernel.
    This is a way to take the ownership of the GPIO, preventing other drivers from
    accessing the same GPIO. After taking the ownership of the GPIO, one can:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在驱动程序中使用GPIO之前，应该向内核声明它。这是一种获取GPIO所有权的方法，可以防止其他驱动程序访问相同的GPIO。获取GPIO所有权后，可以进行以下操作：
- en: Set the direction
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置方向
- en: Toggle its output state (driving line high or low) if used as output
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换其输出状态（将驱动线设置为高电平或低电平）如果用作输出
- en: Set the debounce-interval and read the state, if used as input. For GPIO lines
    mapped to IRQ, one can define at what edge/level the interrupt should be triggered,
    and register a handler that will be run whenever the interrupt occurs.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用作输入，则设置去抖动间隔并读取状态。对于映射到中断请求的GPIO线，可以定义触发中断的边缘/电平，并注册一个处理程序，每当中断发生时就会运行。
- en: 'There are actually two different ways to deal with GPIO in the kernel, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，内核中处理GPIO有两种不同的方式，如下所示：
- en: The legacy and depreciated integer-based interface, where GPIOs are represented
    by integer
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用整数表示GPIO的传统和已弃用的接口
- en: The new and recommended descriptor-based interface, where a GPIO is represented
    and described by an opaque structure, with a dedicated API
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的和推荐的基于描述符的接口，其中GPIO由不透明结构表示和描述，具有专用API
- en: 'The integer-based GPIO interface: legacy'
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于整数的GPIO接口：传统
- en: 'The integer-based interface is the most well-known. The GPIO is identified
    by an integer, which is used for every operation that needs to be performed on
    the GPIO. The following is the header that contains legacy GPIO access functions:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 基于整数的接口是最为人熟知的。GPIO由一个整数标识，该标识用于对GPIO执行的每个操作。以下是包含传统GPIO访问函数的标头：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are well known functions to handle GPIO in kernel.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 内核中有众所周知的函数来处理GPIO。
- en: Claiming and configuring the GPIO
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明和配置GPIO
- en: 'One can allocate and take the ownership of a GPIO using the `gpio_request()`
    function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`gpio_request（）`函数分配和拥有GPIO：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`gpio` represents the GPIO number we are interested in, and `label` is the
    label used by the kernel for the GPIO in sysfs, as we can see in `/sys/kernel/debug/gpio`
    . You have to check the value returned, where `0` mean success, and negative error
    code on error. Once done with the GPIO, it should be set free with the `gpio_free()`
    function:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpio`表示我们感兴趣的GPIO编号，`label`是内核在sysfs中用于GPIO的标签，如我们在`/sys/kernel/debug/gpio`中所见。必须检查返回的值，其中`0`表示成功，错误时为负错误代码。完成GPIO后，应使用`gpio_free（）`函数释放它：'
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If in doubt, one can use `gpio_is_valid()` function to check whether this GPIO
    number is valid on the system prior to allocate it:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有疑问，可以使用`gpio_is_valid（）`函数在分配之前检查系统上的GPIO编号是否有效：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once we own the GPIO, we can change its direction, depending on the need, and
    whether it should be an input or output, using the `gpio_direction_input()` or
    `gpio_direction_output()` functions:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们拥有了GPIO，就可以根据需要改变它的方向，无论是输入还是输出，都可以使用`gpio_direction_input（）`或`gpio_direction_output（）`函数：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`gpio` is the GPIO number we need to set the direction. There is a second parameter
    when it comes to configuring the GPIO as output: `value` , which is the state
    the GPIO should be in once the output direction is effective. Here again, the
    return value is zero or a negative error number. These functions are internally
    mapped on top of lower level callback functions exposed by the driver of the GPIO
    controller that provides the GPIO we use. In the next [Chapter 15](http://gpio)
    , *GPIO Controller Drivers - gpio_chip* , dealing with GPIO controller drivers,
    we will see that a GPIO controller, through its `struct gpio_chip` structure,
    must expose a generic set of callback functions to use its GPIOs.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpio`是我们需要设置方向的GPIO编号。在配置GPIO为输出时有第二个参数：`value`，这是一旦输出方向生效后GPIO应处于的状态。同样，返回值为零或负错误号。这些函数在内部映射到我们使用的GPIO控制器驱动程序公开的较低级别回调函数之上。在下一章[第15章](http://gpio)，*GPIO控制器驱动程序-gpio_chip*中，处理GPIO控制器驱动程序，我们将看到GPIO控制器必须通过其`struct
    gpio_chip`结构公开一组通用的回调函数来使用其GPIO。'
- en: 'Some GPIO controllers offer the possibility to change the GPIO debounce-interval
    (this is only useful when the GPIO line is configured as input). This feature
    is platform-dependent. One can use `int gpio_set_debounce()` to achieve that:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一些GPIO控制器提供更改GPIO去抖动间隔的可能性（仅当GPIO线配置为输入时才有用）。这个功能是平台相关的。可以使用`int gpio_set_debounce（）`来实现这一点：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: where `debounce` is the debounce time in ms.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`debounce`是以毫秒为单位的去抖时间。
- en: All the preceding functions should be called in a context that may sleep. It
    is a good practice to claim and configure GPIOs from within the driver's `probe`
    function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述函数应在可能休眠的上下文中调用。从驱动程序的`probe`函数中声明和配置GPIO是一个良好的实践。
- en: Accessing the GPIO – getting/setting the value
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问GPIO-获取/设置值
- en: You should pay attention when accessing GPIO. In an atomic context, especially
    in an interrupt handler, one has to be sure the GPIO controller callback functions
    will not sleep. A well-designed controller driver should be able to inform other
    drivers (actually clients) whether call to its methods may sleep or not. This
    can be checked with `gpio_cansleep()` function.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问GPIO时应注意。在原子上下文中，特别是在中断处理程序中，必须确保GPIO控制器回调函数不会休眠。设计良好的控制器驱动程序应该能够通知其他驱动程序（实际上是客户端）其方法是否可能休眠。可以使用`gpio_cansleep（）`函数进行检查。
- en: None of the functions used to access GPIO return an error code. That is why
    you should pay attention and check return values during GPIO allocation and configuration.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 用于访问GPIO的函数都不返回错误代码。这就是为什么在GPIO分配和配置期间应注意并检查返回值的原因。
- en: In atomic context
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在原子上下文中
- en: 'There are GPIO controllers that can be accessed and managed through simple
    memory read/write operations. These are generally embedded in the SoC, and do
    not need to sleep. `gpio_cansleep()` will always return `false` for those controllers.
    For such GPIOs, you can get/set their value from within an IRQ handler, using
    the well-known `gpio_get_value()` or `gpio_set_value()` , depending on the GPIO
    line being configured as input or output :'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些GPIO控制器可以通过简单的内存读/写操作进行访问和管理。这些通常嵌入在SoC中，不需要休眠。对于这些控制器，`gpio_cansleep（）`将始终返回`false`。对于这样的GPIO，可以在IRQ处理程序中使用众所周知的`gpio_get_value（）`或`gpio_set_value（）`获取/设置它们的值，具体取决于GPIO线被配置为输入还是输出：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`gpio_get_value()` should be used when the GPIO is configured as input (using
    `gpio_direction_input()` ), and return the actual value (state) of the GPIO. On
    the other hand, `gpio_set_value()` will affect the value of the GPIO, which should
    have been configured as an output using `gpio_direction_output()` . For both function,
    `value` can be considered as `Boolean` , where zero means low, and non-zero value
    mean high.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当GPIO配置为输入（使用`gpio_direction_input（）`）时，应使用`gpio_get_value（）`，并返回GPIO的实际值（状态）。另一方面，`gpio_set_value（）`将影响GPIO的值，应该已经使用`gpio_direction_output（）`配置为输出。对于这两个函数，`value`可以被视为`布尔值`，其中零表示低，非零值表示高。
- en: In a non-atomic context (that may sleep)
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在可能休眠的非原子上下文中
- en: On the other hand, there are GPIO controllers wired on buses such as SPI and
    I2C. Since functions accessing those buses may lead to sleep, the `gpio_cansleep()`
    function should always return `true` (it is up to the GPIO controller to take
    of returning true). In this case, you should not access those GPIOs from within
    the IRQ handled, at least not in the top half (the hard IRQ). Moreover, the accessors
    you have to use as your general-purpose access should be suffixed with `_cansleep`
    .
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，还有GPIO控制器连接在SPI和I2C等总线上。由于访问这些总线的函数可能导致休眠，因此`gpio_cansleep()`函数应始终返回`true`（由GPIO控制器负责返回true）。在这种情况下，您不应该在IRQ处理中访问这些GPIO，至少不是在顶半部分（硬IRQ）。此外，您必须使用作为通用访问的访问器应该以`_cansleep`结尾。
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: They behave exactly like accessors without the `_cansleep()` name suffix, with
    the only difference being that they prevent the kernel from printing warnings
    when the GPIOs are accessed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的行为与没有`_cansleep()`名称后缀的访问器完全相同，唯一的区别是它们在访问GPIO时阻止内核打印警告。
- en: GPIOs mapped to IRQ
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射到IRQ的GPIO
- en: 'Input GPIOs can often be used as IRQ signals. Such IRQs can be edge-triggered
    or level-triggered. The configuration depends on your needs. The GPIO controller
    is responsible for providing the mapping between the GPIO and its IRQ. One can
    use `goio_to_irq()` to map a given GPIO number to its IRQ number:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 输入GPIO通常可以用作IRQ信号。这些IRQ可以是边沿触发或电平触发的。配置取决于您的需求。GPIO控制器负责提供GPIO和其IRQ之间的映射。可以使用`goio_to_irq()`将给定的GPIO号码映射到其IRQ号码：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The return value is the IRQ number, on which one can call `request_irq()` (or
    the threaded version `request_threaded_irq()` ) in order to register a handler
    for this IRQ:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值是IRQ号码，可以调用`request_irq()`（或线程化版本`request_threaded_irq()`）来为此IRQ注册处理程序：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Putting it all together
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容放在一起
- en: 'The following code is a summary putting into practice all the concepts discussed
    regarding integer-based interfaces. This driver manages four GPIOs: two buttons
    (btn1 and btn2), and two LEDs (green and red). Btn1 is mapped to an IRQ, and whenever
    its state changes to LOW, the state of btn2 is applied to LEDs. For example, if
    the state of btn1 goes LOW while btn2 is high, `GREEN` and `RED` led will be driven
    to HIGH:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是将所有讨论的关于基于整数的接口的概念付诸实践的摘要。该驱动程序管理四个GPIO：两个按钮（btn1和btn2）和两个LED（绿色和红色）。Btn1映射到IRQ，每当其状态变为LOW时，btn2的状态将应用于LED。例如，如果btn1的状态变为LOW，而btn2的状态为高，则`GREEN`和`RED`
    led将被驱动到HIGH：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The descriptor-based GPIO interface: the new and recommended way'
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于描述符的GPIO接口：新的推荐方式
- en: 'With the new descriptor-based GPIO interface, a GPIO is characterized by a
    coherent `struct gpio_desc` structure:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的基于描述符的GPIO接口，GPIO由一个连贯的`struct gpio_desc`结构来描述：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'One should use the following header to be able to use the new interface:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用以下标头才能使用新接口：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With the descriptor-based interface, prior to allocating and taking the ownership
    of GPIOs, those GPIOs must have been mapped somewhere. By mapped, I mean they
    should be assigned to your device, whereas with the legacy integer-based interface,
    you just have to fetch a number anywhere and request it as a GPIO. Actually, there
    are three kinds of mapping in the kernel:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于描述符的接口，在分配和拥有GPIO之前，这些GPIO必须已经映射到某个地方。通过映射，我的意思是它们应该分配给您的设备，而使用传统的基于整数的接口，您只需在任何地方获取一个数字并将其请求为GPIO。实际上，内核中有三种映射：
- en: '**Platform data mapping** : The mapping is done in the board file.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台数据映射**：映射在板文件中完成。'
- en: '**Device tree** : The mapping is done in DT style, the same as discussed in
    the preceding sections. This is the mapping we will discuss in this book.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备树**：映射以DT样式完成，与前面的部分讨论的相同。这是我们将在本书中讨论的映射。'
- en: '**Advanced Configuration and Power Interface mapping** (**ACPI** ): The mapping
    is done in ACPI style. Generally used on x86-based systems.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级配置和电源接口映射**（**ACPI**）：映射以ACPI样式完成。通常用于基于x86的系统。'
- en: GPIO descriptor mapping - the device tree
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPIO描述符映射-设备树
- en: GPIO descriptor mappings are defined in the consumer device's node. The property
    that contains a GPIO descriptor mapping must be named `<name>-gpios` or `<name>-gpio`
    , where `<name>` is meaningful enough to describe the function for which those
    GPIOs will be used.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO描述符映射在使用者设备的节点中定义。包含GPIO描述符映射的属性必须命名为`<name>-gpios`或`<name>-gpio`，其中`<name>`足够有意义，以描述这些GPIO将用于的功能。
- en: 'One should always suffix the property name with either `-gpio` or `-gpios`
    because every descriptor-based interface function relies on the `gpio_suffixes[]`
    variable, defined in `drivers/gpio/gpiolib.h` and shown as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 应该始终在属性名称后缀加上`-gpio`或`-gpios`，因为每个基于描述符的接口函数都依赖于`gpio_suffixes[]`变量，在`drivers/gpio/gpiolib.h`中定义如下：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let us see how by having a look at the function used to look for GPIO descriptors
    mappings in devices in DT:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在DT中查找设备中GPIO描述符映射的函数：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let us consider the following node, which is an excerpt of `Documentation/gpio/board.txt`
    :'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑以下节点，这是`Documentation/gpio/board.txt`的摘录：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is what a mapping should look like, with meaningful name.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是映射应该看起来像的，具有有意义的名称。
- en: Allocating and using GPIO
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分配和使用GPIO
- en: 'One can use either `gpiog_get()` or `gpiod_get_index()` to allocate a GPIO
    descriptor:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`gpiog_get()`或`gpiod_get_index()`来分配GPIO描述符：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'On error, these functions will return `-ENOENT` if no GPIO with the given function
    is assigned, or another error on which one can use the `IS_ERR()` macro. The first
    function returns the GPIO descriptor structure that corresponds to the GPIO at
    a given index, whereas the second function returns the GPIO at index 0 (useful
    for one-GPIO mapping). `dev` is the device to which the GPIO descriptor will belong.
    It is your device. `con_id` is the function within the GPIO consumer. It corresponds
    to the `<name>` prefix of the property name in the DT. `idx` is the index (starting
    from 0) of the GPIO for which one needs a descriptor. `flags` is an optional parameter
    that determines the GPIO initialization flags, to configure direction and/or output
    value. It is an instance of `enum gpiod_flags` , defined in `include/linux/gpio/consumer.h`
    :'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误的情况下，如果没有分配具有给定功能的GPIO，则这些函数将返回`-ENOENT`，或者可以使用`IS_ERR()`宏的其他错误。第一个函数返回与给定索引处的GPIO对应的GPIO描述符结构，而第二个函数返回索引为0的GPIO（对于单个GPIO映射很有用）。`dev`是GPIO描述符将属于的设备。这是你的设备。`con_id`是GPIO使用者内的功能。它对应于DT中属性名称的`<name>`前缀。`idx`是需要描述符的GPIO的索引（从0开始）。`flags`是一个可选参数，用于确定GPIO初始化标志，以配置方向和/或输出值。它是`include/linux/gpio/consumer.h`中定义的`enum
    gpiod_flags`的一个实例：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now let us allocate GPIO descriptors for mappings defined in the preceding
    DT:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为在前面的DT中定义的映射分配GPIO描述符：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The LED GPIOs will be active-high, while the power GPIO will be active-low
    (that is, `gpiod_is_active_low(power)` will be true). The reverse operation of
    allocation is done with the `gpiod_put()` function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: LED GPIO将是主动高电平，而电源GPIO将是主动低电平（即`gpiod_is_active_low(power)`将为true）。分配的反向操作使用`gpiod_put()`函数完成：
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let us see how one can release `red` and `blue` GPIO LEDs:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何释放`red`和`blue` GPIO LED：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Before we go further, keep in mind that apart from the `gpiod_get()` /`gpiod_get_index()`
    and `gpio_put()` functions, which completely differ from `gpio_request()` and
    `gpio_free()` , one can perform API translation from integer-based interfaces
    to descriptor-based ones just by changing the `gpio_` prefix into `gpiod_` .
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，请记住，除了`gpiod_get()`/`gpiod_get_index()`和`gpio_put()`函数与`gpio_request()`和`gpio_free()`完全不同之外，可以通过将`gpio_`前缀更改为`gpiod_`来执行从基于整数的接口到基于描述符的接口的API转换。
- en: 'That said, to change direction, one should use the `gpiod_direction_input()`
    and `gpiod_direction_output()` functions:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，要更改方向，应该使用`gpiod_direction_input()`和`gpiod_direction_output()`函数：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`value` is the state to apply to the GPIO once the direction is set to output.
    If the GPIO controller has this feature, one can set the debounce timeout of a
    given GPIO using its descriptor:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`value`是在将方向设置为输出后应用于GPIO的状态。如果GPIO控制器具有此功能，则可以使用其描述符设置给定GPIO的去抖动超时：'
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In order to access a GPIO given its descriptor, the same attention must be
    paid as with the integer-based interface. In other words, one should take care
    whether one is in an atomic (cannot sleep) or non-atomic context, and then use
    the appropriate function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问给定描述符的GPIO，必须像基于整数的接口一样注意。换句话说，应该注意自己是处于原子（无法休眠）还是非原子上下文中，然后使用适当的函数：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For a GPIO descriptor mapped to IRQ, one can use `gpiod_to_irq()` in order
    to get the IRQ number that corresponds to the given GPIO descriptor, which can
    be used with the `request_irq()` function:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于映射到IRQ的GPIO描述符，可以使用`gpiod_to_irq()`来获取与给定GPIO描述符对应的IRQ编号，然后可以与`request_irq()`函数一起使用：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At any given time in the code, one can switch from the descriptor-based interface
    to the legacy integer-based interface and vice versa, using the `desc_to_gpio()`
    or `gpio_to_desc()` functions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中的任何时候，可以使用`desc_to_gpio()`或`gpio_to_desc()`函数从基于描述符的接口切换到传统的基于整数的接口，反之亦然：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Putting it all together
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: 'The driver bellows summarizes the concepts introduced in descriptor-based interfaces.
    The principle is the same, as are the GPIOs:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是驱动程序总结了描述符接口中介绍的概念。原则是相同的，GPIO也是一样的：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The GPIO interface and the device tree
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPIO接口和设备树
- en: Whatever interface one needs to use GPIO for, how to specify GPIOs depends on
    the controller providing them, especially regarding its `#gpio-cells` property,
    which determines the number of cells used for a GPIO specifier. A GPIO specifier
    contains at least the controller phandle, and one or more argument, where the
    number of arguments on `#gpio-cells` property of the controller that provides
    the GPIO. The first cell is generally the GPIO offset number on the controller,
    and the second represents the GPIO flags.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 无论需要为什么接口使用GPIO，如何指定GPIO取决于提供它们的控制器，特别是关于其`#gpio-cells`属性，该属性确定用于GPIO指定器的单元格数量。
    GPIO指定器至少包含控制器phandle和一个或多个参数，其中参数的数量取决于提供GPIO的控制器的`#gpio-cells`属性。第一个单元通常是控制器上的GPIO偏移量编号，第二个表示GPIO标志。
- en: 'GPIO properties should be named `[<name>-]gpios]` , with `<name>` being the
    purpose of this GPIO for the device. Keep in mind this rule is a must for descriptor-based
    interfaces, and becomes `<name>-gpios` (note the absence of square brackets, meaning
    that the `<name>` prefix is mandatory):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO属性应命名为`[<name>-]gpios]`，其中`<name>`是设备的GPIO用途。请记住，对于基于描述符的接口，这个规则是必须的，并且变成了`<name>-gpios`（注意没有方括号，这意味着`<name>`前缀是必需的）：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding sample, CS GPIOs contain both controller-1 and controller-2
    GPIOs. If one does not need to specify a GPIO at a given index in the list, one
    can use `<0>` . The reset GPIO has two cells (two arguments after the controller
    phandle), whereas CD GPIO has only one cell. You can see how meaningful the names
    are that I gave to my GPIO specifier.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，CS GPIO包含控制器1和控制器2的GPIO。如果不需要在列表中指定给定索引处的GPIO，则可以使用`<0>`。复位GPIO有两个单元格（控制器phandle之后的两个参数），而CD
    GPIO只有一个单元格。您可以看到我给我的GPIO指定器起的名字是多么有意义。
- en: The legacy integer-based interface and device tree
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统的基于整数的接口和设备树
- en: 'This interface relies on the following header:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口依赖于以下标头：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There are two functions you should remember when you need to support DT from
    within your driver using legacy integer-based interfaces; these are `of_get_named_gpio()`
    and `of_get_named_gpio_count()` :'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要使用传统的基于整数的接口支持DT时，您应该记住两个函数：`of_get_named_gpio()`和`of_get_named_gpio_count()`：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Given a device node, the former returns the GPIO number of the property `*propname`
    at `index` position. The second just returns the number of GPIOs specified in
    the property:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 给定设备节点，前者返回`*propname`属性在`index`位置的GPIO编号。第二个只返回属性中指定的GPIO数量：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There are drivers still supporting the old specifier, where GPIO properties
    are named `[<name>-gpio` ] or `gpios` . In that case, one should use unnamed API
    versions, by means of `of_get_gpio()` and `of_gpio_count()` :'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然支持旧的说明符的驱动程序，其中GPIO属性命名为`[<name>-gpio`]或`gpios`。在这种情况下，应使用未命名的API版本，通过`of_get_gpio()`和`of_gpio_count()`：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The DT node would look like:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: DT节点如下所示：
- en: '[PRE41]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The code in the driver would look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序中的代码如下所示：
- en: '[PRE42]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'One can summarize this by rewriting the first driver (the one for integer-based
    interfaces), in order to comply with the platform drivers structure, and use DT
    API:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过重写第一个驱动程序（基于整数接口的驱动程序）来总结这一点，以符合平台驱动程序结构，并使用DT API：
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: GPIO mapping to IRQ in the device tree
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备树中的GPIO映射到IRQ
- en: 'One can easily map GPIO to IRQ in the device tree. Two properties are used
    to specify an interrupt:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 可以轻松地在设备树中将GPIO映射到IRQ。使用两个属性来指定中断：
- en: '`interrupt-parent` : This is the GPIO controller for GPIO'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interrupt-parent`：这是GPIO的GPIO控制器'
- en: '`interrupts` : This is the interrupts specifier list'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interrupts`：这是中断说明符列表'
- en: 'This applies to legacy and descriptor-based interface. The IRQ specifier depends
    on the `#interrupt-cell` property of the GPIO controller providing this GPIO.
    `#interrupt-cell` determine the number of cells used when specifying the interrupt.
    Generally, the first cell represents the GPIO number to map to an IRQ and the
    second cell represents what level/edge should trigger the interrupt. In any case,
    interrupt specifier always depends on its parent (the one which has the interrupt-controller
    set), so refer to its binding documentation in the kernel source:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于传统和基于描述符的接口。 IRQ说明符取决于提供此GPIO的GPIO控制器的`#interrupt-cell`属性。 `#interrupt-cell`确定在指定中断时使用的单元数。通常，第一个单元表示要映射到IRQ的GPIO编号，第二个单元表示应触发中断的电平/边缘。无论如何，中断说明符始终取决于其父级（具有设置中断控制器的父级），因此请参考内核源中的绑定文档：
- en: '[PRE44]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'There are two solutions for obtaining the corresponding IRQ:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 获取相应的IRQ有两种解决方案：
- en: '**Your device sits on a known bus (I2C or SPI)** : The IRQ mapping will be
    done for you, and made available either through the `struct i2c_client` or `struct
    spi_device` structure given to your `probe()` function (by means of `i2c_client.irq`
    or `spi_device.irq` ).'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您的设备位于已知总线（I2C或SPI）上**：IRQ映射将由您完成，并通过`struct i2c_client`或`struct spi_device`结构通过`probe()`函数（通过`i2c_client.irq`或`spi_device.irq`）提供。'
- en: '**Your device sits on the pseudo-platform bus** : The `probe()` function will
    be given a `struct platform_device` , on which you can call `platform_get_irq()`
    :'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**您的设备位于伪平台总线上**：`probe()`函数将获得一个`struct platform_device`，您可以在其中调用`platform_get_irq()`：'
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Feel free to have a look at [Chapter 6](text00162.html) , *The Concept of Device
    Tree* .
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 随意查看[第6章](text00162.html)，*设备树的概念*。
- en: GPIO and sysfs
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GPIO和sysfs
- en: 'The sysfs GPIO interface lets people manage and control GPIOs through sets
    or files. It is located under `/sys/class/gpio` . The device model is heavily
    used here, and there are three kinds of entries available:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: sysfs GPIO接口允许人们通过集或文件管理和控制GPIO。它位于`/sys/class/gpio`下。设备模型在这里被广泛使用，有三种类型的条目可用：
- en: '`/sys/class/gpio/:` This is where everything begins. This directory contains
    two special files, `export` and `unexport` :'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys/class/gpio/：`这是一切的开始。此目录包含两个特殊文件，`export`和`unexport`：'
- en: '`export` : This allow us to ask the kernel to export control of a given GPIO
    to user space by writing its number to this file. Example: `echo 21 > export`
    will create a GPIO21 node for GPIO #21, if that''s not requested by kernel code.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`export`：这允许我们要求内核将给定GPIO的控制权导出到用户空间，方法是将其编号写入此文件。例如：`echo 21 > export`将为GPIO＃21创建一个GPIO21节点，如果内核代码没有请求。'
- en: '`unexport` : This reverses the effect of exporting to user space. Example:
    `echo 21 > unexport` will remove any GPIO21 node exported using the export file.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unexport`：这将撤消向用户空间的导出效果。例如：`echo 21 > unexport`将删除使用导出文件导出的任何GPIO21节点。'
- en: '`/sys/class/gpio/gpioN/` : This directory corresponds to the GPIO number N
    (where N is global to the system, not relative to the chip), exported either using
    the `export` file, or from within the kernel. For example: `/sys/class/gpio/gpio42/`
    (for GPIO #42) with the following read/write attributes:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys/class/gpio/gpioN/`：此目录对应于GPIO编号N（其中N是系统全局的，而不是相对于芯片），可以使用`export`文件导出，也可以在内核内部导出。例如：`/sys/class/gpio/gpio42/`（对于GPIO＃42）具有以下读/写属性：'
- en: The `direction` file is used to get/set GPIO direction. Allowed values are either
    `in` or `out` strings. This value may normally be written. Writing as out defaults
    to initializing the value as low. To ensure glitch-free operation, low and high
    values may be written to configure the GPIO as an output with that initial value.
    This attribute will not exist if the kernel code has exported this GPIO, disabling
    direction (see the `gpiod_export()` or `gpio_export()` function).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`direction`文件用于获取/设置GPIO方向。允许的值是`in`或`out`字符串。通常可以写入此值。写入`out`会将值初始化为低。为了确保无故障操作，可以写入低值和高值以将GPIO配置为具有该初始值的输出。如果内核代码已导出此GPIO，则不会存在此属性，从而禁用方向（请参阅`gpiod_export()`或`gpio_export()`函数）。'
- en: The `value` attribute lets us get/set the state of the GPIO line, depending
    on the direction, input or output. If the GPIO is configured as an output, any
    non-zero value written will be treated as HIGH state. If configured as an output,
    writing `0` will set the output low, whereas `1` will set the output high. If
    the pin can be configured as an interrupt-generating lines and if it has been
    configured to generate, one can call the `poll(2)` system call on that file and
    `poll(2)` will return whenever the interrupt was triggered. Using `poll(2)` wil
    require setting the events `POLLPRI` and `POLLERR` . If one uses `select(2)` instead,
    one should set the file descriptor in `exceptfds` . After `poll(2)` returns, either
    `lseek(2)` to the beginning of the sysfs file and read the new value or close
    the file and re-open it to read the value. It is the same principle as we discussed
    regarding the pollable sysfs attribute.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`属性允许我们根据方向（输入或输出）获取/设置GPIO线的状态。如果GPIO配置为输出，写入任何非零值将被视为高电平状态。如果配置为输出，写入`0`将使输出低电平，而`1`将使输出高电平。如果引脚可以配置为产生中断的线，并且已配置为生成中断，则可以在该文件上调用`poll(2)`系统调用，`poll(2)`将在中断触发时返回。使用`poll(2)`将需要设置事件`POLLPRI`和`POLLERR`。如果使用`select(2)`，则应在`exceptfds`中设置文件描述符。`poll(2)`返回后，要么`lseek(2)`到sysfs文件的开头并读取新值，要么关闭文件并重新打开以读取值。这与我们讨论的可轮询sysfs属性的原理相同。'
- en: '`edge` determines the signal edge that will let the `poll()` or `select()`
    function return. Allowed values are `none` , `rising` , `falling` , or `both`
    . This file is readable/writable, and exists only if the pin can be configured
    as an interrupt-generating input pin.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`edge`确定了将让`poll()`或`select()`函数返回的信号边缘。允许的值为`none`，`rising`，`falling`或`both`。此文件可读/可写，仅在引脚可以配置为产生中断的输入引脚时存在。'
- en: '`active_low` reads as either 0 (false) or 1 (true). Writing any non-zero value
    will invert the *value* attribute for both reading and writing. Existing and subsequent
    `poll(2)` support configurations through the edge attribute for rising and falling
    edges will follow this setting. The relevant function from kernel to set this
    value is `gpio_sysf_set_active_low()` .'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active_low`读取为0（假）或1（真）。写入任何非零值将反转*value*属性的读取和写入。现有和随后的`poll(2)`支持通过边缘属性进行配置，用于上升和下降边缘，将遵循此设置。内核中设置此值的相关函数是`gpio_sysf_set_active_low()`。'
- en: Exporting a GPIO from kernel code
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从内核代码中导出GPIO
- en: 'Apart from using `/sys/class/gpio/export` file to export a GPIO to user space,
    one can use functions like `gpio_export` (for legacy interface) or `gpioD_export`
    (the new interface) from the kernel code in order to explicitly manage export
    of GPIOs which have already been requested using `gpio_request()` or `gpiod_get()`
    :'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`/sys/class/gpio/export`文件将GPIO导出到用户空间外，还可以使用内核代码中的`gpio_export`（用于传统接口）或`gpioD_export`（新接口）等函数来显式管理已经使用`gpio_request()`或`gpiod_get()`请求的GPIO的导出：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `direction_may_change` parameter decides if one can change the signal direction
    from input to output and vice versa. The reverse operations from kernel are `gpio_unexport()`
    or `gpiod_unexport():`
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`direction_may_change`参数决定是否可以从输入更改信号方向为输出，反之亦然。内核的反向操作是`gpio_unexport()`或`gpiod_unexport()`：'
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once exported, one can use `gpio_export_link()` (or `gpiod_export_link()` for
    descriptor-based interfaces) in order to create symbolic links from elsewhere
    in sysfs, which will point to the GPIO sysfs node. Drivers can use this to provide
    the interface under their own device in sysfs with a descriptive name:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦导出，可以使用`gpio_export_link()`（或`gpiod_export_link()`用于基于描述符的接口）来创建符号链接，从sysfs的其他位置指向GPIO
    sysfs节点。驱动程序可以使用此功能在sysfs中的自己设备下提供接口，并提供描述性名称：
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'One could use this in the `probe()` function for descriptor-based interfaces
    as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在基于描述符的接口的`probe()`函数中使用如下：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For integer-based interfaces, the code would look like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于整数的接口，代码如下：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Dealing with a GPIO from within the kernel is an easy task, as shown in this
    chapter. Both legacy and new interfaces are discussed, giving the possibility
    to choose the one that fits your needs, in order to write enhanced GPIO drivers.
    You'll be able to handle IRQs mapped to GPIOs. The next chapter will deal with
    the chip that provides and exposes GPIO lines, known as the GPIO controller.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了在内核中处理GPIO是一项简单的任务。讨论了传统接口和新接口，为您提供了选择适合您需求的接口的可能性，以编写增强的GPIO驱动程序。您将能够处理映射到GPIO的中断请求。下一章将处理提供和公开GPIO线的芯片，称为GPIO控制器。
