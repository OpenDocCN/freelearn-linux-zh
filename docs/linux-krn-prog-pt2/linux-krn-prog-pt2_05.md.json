["```\n// kernel/irq/manage.c:request_threaded_irq()\n[...]\n * This call allocates interrupt resources and enables the\n * interrupt line and IRQ handling. From the point this\n * call is made your handler function may be invoked.\n```", "```\n#include <linux/interrupt.h>\n\n\u200bint __must_check\nrequest_irq(unsigned int irq, irq_handler_t (*handler_func)(int, void *), unsigned long flags, const char *name, void *dev);\n```", "```\nvoid *free_irq(unsigned int, void *);\n```", "```\n#define IRQF_TIMER(__IRQF_TIMER | IRQF_NO_SUSPEND | IRQF_NO_THREAD)\n```", "```\n// drivers/net/ethernet/intel/ixgb/ixgb_main.c\n[...]int\nixgb_up(struct ixgb_adapter *adapter)\n{\n    struct net_device *netdev = adapter->netdev;\n    int err, irq_flags = IRQF_SHARED;\n    [...]\n    err = request_irq(adapter->pdev->irq, ixgb_intr, irq_flags,\n                      netdev->name, netdev);\n    [...]\n```", "```\nvoid\nixgb_down(struct ixgb_adapter *adapter, bool kill_watchdog)\n{\n    struct net_device *netdev = adapter->netdev;\n    [...]\n    napi_disable(&adapter->napi);\n    /* waiting for NAPI to complete can re-enable interrupts */\n    ixgb_irq_disable(adapter);\n    free_irq(adapter-pdev->irq, netdev);\n    [...]\n```", "```\nmy_interrupt()\n{\n    struct mys *sp;\n    ack_intr();\n    x = read_regX();\n    sp = kzalloc(SIZE_HWBUF, GFP_KERNEL);\n    if (!sp)\n        return -ENOMEM;\n    sp = fetch_data_from_hw();\n    copy_to_user(ubuf, sp, count);\n    kfree(sp);\n}\n```", "```\n        a() -- b() -- c() -- [...] -- g() -- schedule() -- [...]\n```", "```\nstatic irqreturn_t interrupt_handler(int irq, void *data);\n```", "```\n// include/linux/irqreturn.h\n\n/**\n * enum irqreturn\n * @IRQ_NONE interrupt was not from this device or was not handled\n * @IRQ_HANDLED interrupt was handled by this device\n * @IRQ_WAKE_THREAD handler requests to wake the handler thread\n */\nenum irqreturn {\n    IRQ_NONE = (0 0),\n    IRQ_HANDLED = (1 0),\n    IRQ_WAKE_THREAD = (1 1),\n};\n\n```", "```\n// drivers/input/serio/i8042.c\n/*\n * i8042_interrupt() is the most important function in this driver -\n * it handles the interrupts from the i8042, and sends incoming bytes\n * to the upper layers.\n */\nstatic irqreturn_t i8042_interrupt(int irq, void *dev_id)\n{\n    unsigned char str, data;\n    [...]\n    str = i8042_read_status();\n    [...] \n    data = i8042_read_data();\n    [...]\n    if (likely(serio && !filtered))\n        serio_interrupt(serio, data, dfl);\n out:\n    return IRQ_RETVAL(ret);\n}\n```", "```\n// drivers/net/ethernet/intel/ixgb/ixgb_main.c\nstatic irqreturn_t\nixgb_intr(int irq, void *data)\n{\n    struct net_device *netdev = data;\n    struct ixgb_adapter *adapter = netdev_priv(netdev);\n    struct ixgb_hw *hw = &adapter-hw;\n    u32 icr = IXGB_READ_REG(hw, ICR);\n\n    if (unlikely(!icr))\n        return IRQ_NONE; /* Not our interrupt */\n    [...]\n    if (napi_schedule_prep(&adapter-napi)) {\n        [...]\n        IXGB_WRITE_REG(&adapter-hw, IMC, ~0);\n        __napi_schedule(&adapter-napi);\n    }\n    return IRQ_HANDLED;\n}\n```", "```\n#include <linux/interrupt.h>\n\nint __must_check\ndevm_request_irq(struct device *dev, unsigned int irq, irq_handler_t handler,\n                  unsigned long irqflags, const char *devname, void *dev_id);\n```", "```\n// drivers/gpu/drm/exynos/exynos_mixer.c\n[...]\n    res = platform_get_resource(mixer_ctx->pdev, IORESOURCE_IRQ, 0);\n    if (res == NULL) {\n        dev_err(dev, \"get interrupt resource failed.\\n\");\n        return -ENXIO;\n    }\n\n ret = devm_request_irq(dev, res->start, mixer_irq_handler,\n 0, \"drm_mixer\", mixer_ctx);\n    if (ret) {\n        dev_err(dev, \"request interrupt failed.\\n\");\n        return ret;\n    }\n    mixer_ctx-irq = res->start;\n[...]\n```", "```\n// include/linux/interrupt.hstatic inline int __must_check\nrequest_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev)\n{\n    return request_threaded_irq(irq, handler, NULL, flags, name, dev);\n}\n```", "```\nint __must_check\nrequest_threaded_irq(unsigned int irq, irq_handler_t handler,\n               irq_handler_t thread_fn,\n               unsigned long flags, const char *name, void *dev);\n```", "```\n#include linux/interrupt.h\n\nint __must_check\n devm_request_threaded_irq(struct device *dev, unsigned int irq,\n               irq_handler_t handler, irq_handler_t thread_fn,\n               unsigned long irqflags, const char *devname,\n               void *dev_id);\n```", "```\nstatic irqreturn_t threaded_handler(int irq, void *data);\n```", "```\n * IRQF_ONESHOT - Interrupt is not reenabled after the hardirq handler finished.\n * Used by threaded interrupts which need to keep the\n * irq line disabled until the threaded handler has been run.\n```", "```\n// drivers/i2c/busses/i2c-stm32f7.c\nstatic int stm32f7_i2c_probe(struct platform_device *pdev)\n{\n    struct stm32f7_i2c_dev *i2c_dev;\n    const struct stm32f7_i2c_setup *setup;\n    struct resource *res;\n    int irq_error, irq_event, ret;\n\n    [...]\n    irq_event = platform_get_irq(pdev, 0);\n    [...]\n    irq_error = platform_get_irq(pdev, 1);\n    [...]\n    ret = devm_request_threaded_irq(&pdev->dev, irq_event,\n stm32f7_i2c_isr_event,\n stm32f7_i2c_isr_event_thread,\n IRQF_ONESHOT,\n pdev->name, i2c_dev);\n    [...]\n    ret = devm_request_irq(&pdev->dev, irq_error, stm32f7_i2c_isr_error, 0,\n                   pdev->name, i2c_dev);\n```", "```\n   kernel/irq/manage.c:request_threaded_irq() --  __setup_irq() --\n          setup_irq_thread() -- kernel/kthread.c:kthread_create()\n```", "```\nt = kthread_create(irq_thread, new, \"irq/%d-%s\", irq, new->name);\n```", "```\ngenirq: Flags mismatch irq 1\\. 00002080 (driver-name) vs. 00000080 (i8042)\n```", "```\nint __must_check\nrequest_any_context_irq(unsigned int irq, irq_handler_t handler,\n            unsigned long flags, const char *name, void *dev_id);\n```", "```\nrpi # dmesg -C\nrpi # echo ? /proc/sysrq-trigger\nrpi # dmesg\n[ 294.928223] sysrq: HELP : loglevel(0-9) reboot(b) crash(c) terminate-all-tasks(e) memory-full-oom-kill(f) kill-all-tasks(i) thaw-filesystems(j) sak(k) show-backtrace-all-active-cpus(l) show-memory-usage(m) nice-all-RT-tasks(n) poweroff(o) show-registers(p) show-all-timers(q) unraw(r) sync(s) show-task-states(t) unmount(u) show-blocked-tasks(w) dump-ftrace-buffer(z) \nrpi # \n```", "```\ninclude/linux/nmi.h:trigger_all_cpu_backtrace() arch_trigger_cpumask_backtrace()\n    arch/x86/kernel/apic/hw_nmi.c:arch_trigger_cpumask_backtrace() \n    nmi_trigger_cpumask_backtrace()\n```", "```\n[...] Properties:\n   * If tasklet_schedule() is called, then tasklet is guaranteed\n     to be executed on some cpu at least once after this.\n   * If the tasklet is already scheduled, but its execution is still not\n     started, it will be executed only once.\n   * If this tasklet is already running on another CPU (or schedule is \n     called from tasklet itself), it is rescheduled for later.\n   * Tasklet is strictly serialized wrt itself, but not\n     wrt another tasklets. If client needs some intertask synchronization,\n     he makes it with spinlocks. [...]\n```", "```\n#include <linux/interrupt.h>\nvoid tasklet_init(struct tasklet_struct *t, void (*func)(unsigned long), unsigned long data);\n```", "```\nvoid tasklet_schedule(struct tasklet_struct *t);\n```", "```\n#include <\"convenient.h\">               // has the PRINT_CTX() macro\nstatic struct tasklet_struct *ts;\n[...]\nstatic int __init mydriver_init(void)\n{\n    struct device *dev;\n    [...]\n    /* Register the device with the kernel 'misc' driver framework */\n    ret = misc_register(&keylog_miscdev);\n    dev = keylog_miscdev.this_device;\n\n    ts = devm_kzalloc(dev, sizeof(struct tasklet_struct), GFP_KERNEL);\n    tasklet_init(ts, mydrv_tasklet, 0);\n\n    ret = devm_request_irq(dev, MYDRV_IRQ, my_hardirq_handler,\n                    IRQF_SHARED, OURMODNAME, THIS_MODULE);\n    [...]\n```", "```\n/ * Our 'bottom half' tasklet routine */\nstatic void mydrv_tasklet(unsigned long data)\n{\n    PRINT_CTX();   // from our convenient.h header\n    process_it();  // majority of the interrupt work done here\n}\n\n/* Our 'hardirq' interrupt handler routine - our 'top half' */\nstatic irqreturn_t my_hardirq_handler(int irq, void *data)\n{\n    /* minimal work: ack/disable hardirq, fetch and/or queue data, etc ... */\n tasklet_schedule(ts);\n    return IRQ_HANDLED;\n}\n```", "```\n// kernel/softirq.c\nvoid open_softirq(int nr, void (*action)(struct softirq_action *)) \n{\n    softirq_vec[nr].action = action;\n}\n```", "```\ndo_IRQ() -> handle_irq() -> entering_irq() -> hardirq top-half runs -> exiting_irq() -> irq_exit() -> invoke_softirq() -> do_softirq() -> ... bottom half runs: tasklet/softirq ... -> restore context\n```", "```\n   do_softirq() --  [assembly]do_softirq_own_stack -- __do_softirq()\n```", "```\n... Note that this is all really fairly independent of the whole masking\nlogic. Yes, the masking logic comes into play too (allowing you to run\na subset of softirq's at a time), but on the whole the complaints I've\nseen have not been \"the networking softirq takes so long that it\ndelays USB tasklet handling\", but they have been along the lines of\n\"the networking softirq gets invoked so often that it then floods the\nsystem and triggers [k]softirqd, and _that_ then makes tasklet handling\nlatency go up insanely ...\"\n```", "```\n// include/linux/preempt.h[...]/*\n * Are we doing bottom half or hardware interrupt processing?\n *\n * in_irq()       - We're in (hard) IRQ context\n * in_softirq()   - We have BH disabled, or are processing softirqs\n * in_interrupt() - We're in NMI,IRQ,SoftIRQ context or have BH disabled\n * in_serving_softirq() - We're in softirq context\n * in_nmi()       - We're in NMI context\n * in_task()      - We're in task context\n [...]\n```", "```\n001)  rdwr_drv_secret :29141   |  .N.0   /* read_miscdrv_rdwr() */\n```", "```\nThe Ftrace 'latency-format'\n                                    _-----= irqs-off           [d]\n                                   / _----= need-resched       [N]\n                                  | / _---= hardirq/softirq    [H|h|s] [1]\n                                  || / _--= preempt-depth      [#]\n                                  ||| /\n CPU TASK              PID        ||||        FUNCTION CALLS\n |    |                 |         ||||         |   |   |   |\n001)  rdwr_drv_secret :29141    | .N.0    /* read_miscdrv_rdwr() */\n\n[1] 'h' = hard irq is running ; 'H' = hard irq occurred inside a softirq\n```", "```\n// convenient.h\n[...]\n#define PRINT_CTX() do {                                      \\\n  int PRINTCTX_SHOWHDR = 0;                                   \\\n  char intr = '.';                                            \\\n  if (!in_task()) {                                           \\\n      if (in_irq() && in_softirq())                           \\\n          intr = 'H'; /* hardirq occurred inside a softirq */ \\\n      else if (in_irq())                                      \\\n          intr = 'h'; /* hardirq is running */                \\\n      else if (in_softirq())                                  \\\n          intr = 's';                                         \\\n  }                                                           \\\n  else                                                        \\\n      intr = '.';                                             \\\n```", "```\n[...]\nif (PRINTCTX_SHOWHDR == 1) \\\n    pr_debug(\"CPU) task_name:PID | irqs,need-resched,hard/softirq,preempt-depth /* func_name() */\\n\"); \\\npr_debug( \\\n    \"%03d) %c%s%c:%d | \" \\\n    \"%c%c%c%u \" \\\n    \"/* %s() */\\n\" \\\n    , smp_processor_id(), \\\n    (!current-mm?'[':' '), current-comm, (!current-mm?']':' '), current-pid, \\\n    (irqs_disabled()?'d':'.'), \\\n    (need_resched()?'N':'.'), \\\n    intr, \\\n    (preempt_count() && 0xff), __func__); \\\n} while (0)\n```", "```\nCPU) task_name:PID | irqs,need-resched,hard/softirq,preempt-depth /* func_name() */\n001)  rdwr_drv_secret :29141   |  .N.0   /* read_miscdrv_rdwr() */\n```", "```\n000)  gnome-terminal- :3075   |  .Ns1   /* mydrv_tasklet() */\n```", "```\n$ sudo cat /sys/kernel/debug/tracing/available_tracers\nhwlat blk mmiotrace function_graph wakeup_dl wakeup_rt wakeup function nop\n```", "```\nsudo /bin/bash\n```", "```\ntrace-cmd reset\n```", "```\ncd /sys/kernel/debug/tracing\n```", "```\necho irqsoff current_tracer\n```", "```\necho 1 tracing_on\n ... it runs! ... \n```", "```\ncat tracing_max_latency\n[...]\n```", "```\ncp trace /tmp/mytrc.txt\ncat /tmp/mytrc.txt\n```", "```\ntrace-cmd reset\n```", "```\n# cat /tmp/mytrc.txt\n# tracer: irqsoff\n#\n# irqsoff latency trace v1.1.5 on 5.4.0-llkd01\n# --------------------------------------------------------------------\n# latency: 234 us, #53/53, CPU#1 | (M:desktop VP:0, KP:0, SP:0 HP:0 #P:2)\n#    -----------------\n#    | task: sshd-25311 (uid:1000 nice:0 policy:0 rt_prio:0)\n#    -----------------\n# = started at: schedule\n# = ended at: finish_task_switch\n[...]\n```"]