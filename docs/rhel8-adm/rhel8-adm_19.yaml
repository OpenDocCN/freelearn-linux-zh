- en: '*Chapter 16*: Kernel Tuning and Managing Performance Profiles with tuned'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*：内核调优和使用`tuned`管理性能配置文件'
- en: As described occasionally in previous chapters, each system performance profile
    must be adapted to the expected usage for our system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章中偶尔描述的，每个系统性能配置文件必须适应我们系统的预期用途。
- en: 'Kernel tuning plays a key role in this optimization, and we will be exploring
    this further in this chapter in the following sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 内核调优在这种优化中起着关键作用，我们将在本章的以下部分进一步探讨这一点：
- en: Identifying processes, checking memory usage, and killing processes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别进程，检查内存使用情况和终止进程
- en: Adjusting kernel scheduling parameters to better manage processes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整内核调度参数以更好地管理进程
- en: Installing `tuned` and managing tuning profiles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装`tuned`和管理调优配置文件
- en: Creating a custom `tuned` profile
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义的`tuned`配置文件
- en: By the end of this chapter, you will know how kernel tuning is applied, how
    quick profiles can be used via `tuned` to suit general use cases for different
    system roles, and how to further extend those customizations for your servers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解如何应用内核调优，如何通过`tuned`使用快速配置文件以适应不同系统角色的一般用例，以及如何进一步扩展这些自定义配置以适用于您的服务器。
- en: Additionally, identifying processes that have become a resource hog and how
    to terminate them and or prioritize them will be a useful way of getting a bit
    more juice out of our hardware when most needed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，识别已成为资源消耗者的进程以及如何终止它们或对它们进行优先处理将是在最需要时更充分利用我们的硬件的有用方法。
- en: Let's get hands-on and learn about these topics!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们动手学习这些主题！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can continue the practice of using the **virtual machine** (**VM**) created
    at the beginning of this book in [*Chapter 1*](B16799_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Installing RHEL8*. Any additional packages required for this chapter will be
    indicated alongside the text.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续使用本书开头创建的**虚拟机**（**VM**）[*第1章*](B16799_01_Final_SK_ePub.xhtml#_idTextAnchor014)中的，*安装RHEL8*。本章所需的任何其他软件包都将在文本旁边指示。
- en: Identifying processes, checking memory usage, and killing processes
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别进程，检查内存使用情况和终止进程
- en: A process is a program that runs on our system—it might be a user logged in
    via **Secure Shell** (**SSH**) that has a bash terminal process running, or even
    the portion of the SSH daemon listening and replying to remote connections, or
    it could be a program such as a mail client, a file manager, and so on being executed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 进程是在我们系统上运行的程序 - 它可能是通过**安全外壳**（**SSH**）登录的用户，具有运行的bash终端进程，甚至是SSH守护程序的部分，用于监听和回复远程连接，或者可能是诸如邮件客户端、文件管理器等正在执行的程序。
- en: 'Of course, processes take up resources in our system: memory, **Central Processing
    Unit** (**CPU**), disk, and so on. Identifying or locating ones that might be
    misbehaving is a key task for system administrators.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，进程占用了我们系统的资源：内存、**中央处理单元**（**CPU**）、磁盘等。对于系统管理员来说，识别或定位可能行为不端的进程是一项关键任务。
- en: Some of the basics were already covered in [*Chapter 4*](B16799_04_Final_Sk_ePub.xhtml#_idTextAnchor059),
    *Tools for Regular Operations*, but it would be a good idea to have a refresher
    on these before continuing; however, we will be showing and using some of those
    tools in the context of performance tuning here, such as—for example—the `top`
    command, which allows us to see processes and sort lists based on CPU usage, memory
    usage, and so on. (Check the output of `man top` for a refresher on how to change
    the sorting criteria.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一些基础知识已经在[*第4章*](B16799_04_Final_Sk_ePub.xhtml#_idTextAnchor059)中涵盖了，*常规操作工具*，但在继续之前，最好先复习一下；然而，在这里，我们将展示并使用一些这些工具，例如
    - 例如`top`命令，它允许我们查看进程并根据CPU使用情况、内存使用情况等对列表进行排序。（查看`man top`的输出，了解如何更改排序标准。）
- en: One parameter to watch while checking system performance is the load average,
    which is a moving average made by the processes ready to run or waiting for `1`,
    `5`, and `15` minutes—and gives an idea of whether a load is increasing or lowering.
    A rule of thumb is that if a load average is below 1, there is no resource saturation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查系统性能时要注意的一个参数是负载平均值，它是由准备运行或等待`1`、`5`和`15`分钟的进程组成的移动平均值 - 并且可以让我们了解负载是增加还是减少的想法。一个经验法则是，如果负载平均值低于1，那么没有资源饱和。
- en: The load average is shown with many other tools, such as the aforementioned
    `top`, or with `uptime` or `w`, and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 负载平均值可以通过许多其他工具显示，例如前面提到的`top`，或者使用`uptime`或`w`等。
- en: 'If the system-load average is growing, CPU or memory usage is spiking, and
    if some processes are listed there, it will be easier to locate. If the load average
    is also high and increasing, it might be possible that the I/O operations are
    increasing it. It is possible to install the `iotop` package, which provides the
    `iotop` command to monitor disk activity. When executed, it will show the processes
    in a system and the disk activity: reads, writes, and swaps that might give us
    some more hints about where to look.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统负载平均值正在增长，CPU或内存使用率正在上升，并且如果列出了一些进程，那么定位将更容易。如果负载平均值也很高且正在增加，可能是I/O操作在增加。可以安装`iotop`软件包，它提供`iotop`命令来监视磁盘活动。执行时，它将显示系统中的进程和磁盘活动：读取、写入和交换，这可能会给我们一些更多关于查找位置的提示。
- en: Once a process has been identified as taking too many resources, we can send
    a **signal** to control it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了占用太多资源的进程，我们就可以发送一个**信号**来控制它。
- en: 'A signal list can be obtained with the `kill –l` command, as illustrated in
    the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`kill -l`命令获取信号列表，如下截图所示：
- en: '![Figure 16.1 – Available signals to send to processes'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.1 - 发送给进程的可用信号'
- en: '](img/B16799_16_001.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_16_001.jpg)'
- en: Figure 16.1 – Available signals to send to processes
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 - 发送给进程的可用信号
- en: Note that each signal contains a number and a name—both can be used to send
    the signal to the process via its **process identifier** (**PID**).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个信号都包含一个数字和一个名称 - 都可以用于通过其**进程标识符**（**PID**）向进程发送信号。
- en: 'Let''s review the most common ones, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来回顾一下最常见的信号，如下所示：
- en: '![](img/Table_16.1.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_16.1.jpg)'
- en: 'From the list shown in *Figure 16.1*, it''s important to know that each signal
    has a `man 7 signal`, as illustrated in the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从*图16.1*中显示的列表中，重要的是要知道每个信号都有一个`man 7信号`，如下面的截图所示：
- en: '![Figure 16.2 – Listing of signals, number equivalent, disposition (action),
    and behavior (man 7 signal)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.2 - 信号列表，数字等效物，处置（操作）和行为（man 7信号）'
- en: '](img/B16799_16_002.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_16_002.jpg)'
- en: Figure 16.2 – Listing of signals, number equivalent, disposition (action), and
    behavior (man 7 signal)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 - 信号列表，数字等效物，处置（操作）和行为（man 7信号）
- en: One of the most typical usages when arriving at this point is to terminate processes
    that are misbehaving, so a combination of locating the process, obtaining the
    PID, and sending a signal to it is a very common task... so common that there
    are even tools that allow you to combine these stages in one command.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到达这一点时最典型的用法之一是终止行为不端的进程，因此定位进程、获取PID并向其发送信号是一项非常常见的任务...甚至是如此常见，以至于甚至有工具可以让您将这些阶段组合成一个命令。
- en: 'For example, we can compare `ps aux|grep -i chrome|grep –v grep|awk ''{print
    $2}''|xargs kill –9` with `pkill –9 –f chrome`: both will perform the same action,
    search processes named `chrome`, and send signal `9` (kill) to them.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将`ps aux|grep -i chrome|grep –v grep|awk '{print $2}'|xargs kill –9`与`pkill
    –9 –f chrome`进行比较：两者都会执行相同的操作，搜索名为`chrome`的进程，并向它们发送信号`9`（杀死）。
- en: Of course, even a user logging in is a process in the system (running SSH or
    the shell, and more); we can find the processes started by our target user via
    a similar construction (with `ps`, `grep`, and others) or with `pgrep` options
    such as `pgrep –l –u user`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，即使用户登录也是系统中的一个进程（运行SSH或shell等）；我们可以通过类似的构造（使用`ps`、`grep`和其他工具）或使用`pgrep`选项（如`pgrep
    -l -u user`）找到我们目标用户启动的进程。
- en: Bear in mind that, as the signals indicate, it's better to send a `TERM` signal
    to allow the process to run its internal cleanup steps before exiting, as directly
    killing them might result in leftovers in our system.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，正如信号所指示的那样，最好发送一个“TERM”信号，以便让进程在退出之前运行其内部清理步骤，直接杀死它们可能会在我们的系统中留下残留物。
- en: One interesting command that was widely used before terminal multiplexers such
    as `tmux` or `screen` became commonplace was `nohup`, which was prepended to commands
    that would last longer—for example, downloading a big file. This command captured
    the terminal hangout signal, allowing the process executed to continue execution,
    storing the output in a `nohup.out` file that could later be checked.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端复用器（如`tmux`或`screen`）变得普遍之前，一个广泛使用的有趣命令是`nohup`，它被添加到持续时间较长的命令之前，例如下载大文件。这个命令捕获了终端挂起信号，允许执行的进程继续执行，并将输出存储在`nohup.out`文件中，以便以后检查。
- en: For example, to download the latest **Red Hat Enterprise Linux** (**RHEL**)
    **Image Standard Optical** (**ISO**) file from the Customer Portal, select one
    release—for example, 8.4—and once logged in at [https://access.redhat.com/downloads/content/479/ver=/rhel---8/8.4/x86_64/product-software](https://access.redhat.com/downloads/content/479/ver=/rhel---8/8.4/x86_64/product-software),
    we will select the binary ISO and right-click to copy the **Uniform Resource Locator**
    (**URL**) for the download.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要从客户门户下载最新的**Red Hat Enterprise Linux**（**RHEL**）**Image Standard Optical**（**ISO**）文件，选择一个版本，例如8.4，然后在[https://access.redhat.com/downloads/content/479/ver=/rhel---8/8.4/x86_64/product-software](https://access.redhat.com/downloads/content/479/ver=/rhel---8/8.4/x86_64/product-software)登录后，我们将选择二进制ISO并右键单击复制下载的**统一资源定位符**（**URL**）。
- en: Tip
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The URLs obtained when copying from the **Customer Portal** are timebound, meaning
    they are only valid for a short period of time, and afterward, the download link
    is no longer valid and a new one should be obtained after refreshing the URL.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从**客户门户**复制时获得的URL是有时间限制的，这意味着它们只在短时间内有效，之后，下载链接将不再有效，应在刷新URL后获取新的链接。
- en: 'In a terminal, we will then execute the following command with the copied URL:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在终端中，我们将执行以下带有复制的URL的命令：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the preceding command, `nohup` will not close the processes on terminal
    hang-up (disconnection), so `wget` will continue downloading the URL, and the
    ending ampersand symbol (`&`) detaches the execution from the active terminal,
    leaving it as a background job we can check with the `jobs` command until it has
    finished.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，`nohup`将不会在终端挂断（断开连接）时关闭进程，因此`wget`将继续下载URL，并且结束的`&`符号将执行从活动终端分离，将其作为后台作业，我们可以使用`jobs`命令检查直到它完成。
- en: If we forgot to add the ampersand, the program will be blocking our input, but
    we can press *Ctrl* + *Z* on the keyboard and the process will be stopped. However,
    as we really want it to be continuing execution but in the background, we will
    execute `bg`, which will continue the execution of it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记添加`&`，程序将阻塞我们的输入，但我们可以在键盘上按下*Ctrl* + *Z*，进程将被停止。然而，由于我们真的希望它继续在后台执行，我们将执行`bg`，这将继续执行它。
- en: In case we want to bring back the program to receive our input and interact
    with it, we can move it to the foreground with the `fg` command.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将程序带回以接收我们的输入并与其交互，我们可以使用`fg`命令将其移到前台。
- en: If we press *Ctrl* + *C* instead, while the program has our input, it will receive
    a petition to interrupt and stop execution.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按下*Ctrl* + *C*，而程序有我们的输入，它将收到中断和停止执行的请求。
- en: 'You can see that workflow in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下截图中看到工作流程：
- en: '![Figure 16.3 – Suspending the process, resuming to the background, bringing
    to the foreground, and aborting'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.3 - 挂起进程，恢复到后台，带到前台，中止'
- en: '](img/B16799_16_003.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_16_003.jpg)'
- en: Figure 16.3 – Suspending the process, resuming to the background, bringing to
    the foreground, and aborting
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 - 挂起进程，恢复到后台，带到前台，中止
- en: In this case, we're downloading the Fedora 34 installation ISO (8 `nohup` and
    `wget`; as we forgot to add the ampersand, we executed *Ctrl* + *Z* (appearing
    on screen as `^Z`).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在下载Fedora 34安装ISO（8 `nohup`和`wget`；因为我们忘记添加&，我们执行了*Ctrl* + *Z*（显示为`^Z`）。
- en: The job was reported as job `[1]` with a status of `Stopped` (also reported
    when executing `jobs`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 作业被报告为作业`[1]`，状态为`Stopped`（在执行`jobs`时也会报告）。
- en: Then, we bring the job to the background execution with `bg`, and now, `jobs`
    reports it as `Running`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`bg`将作业切换到后台执行，现在，`jobs`将其报告为`Running`。
- en: Afterward, we bring the job back to the foreground with `fg` and execute *Ctrl*
    + *C*, represented as `^C` on the screen, to finalize it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用`fg`将作业切换回前台，并执行*Ctrl* + *C*，在屏幕上表示为`^C`，以结束它。
- en: 'This feature enables us to run multiple background commands—for example, we
    can copy a file in parallel to several hosts, as illustrated in the following
    screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能使我们能够运行多个后台命令 - 例如，我们可以并行复制文件到多台主机，如下面的截图所示：
- en: '![Figure 16.4 – Sample for loop to copy a file to several servers with nohup'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.4 - 使用nohup复制文件到多台服务器的示例for循环'
- en: '](img/B16799_16_004.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_16_004.jpg)'
- en: Figure 16.4 – Sample for loop to copy a file to several servers with nohup
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4 - 使用nohup复制文件到多台服务器的示例for循环
- en: In this example, the copy operation performed over `scp` will be happening in
    parallel, and, in the event of disconnection from our terminal, the job will continue
    execution and the output will be stored on `nohup.out` files in the folder we
    were executing it from.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，通过`scp`执行的复制操作将会并行进行，而且，如果从我们的终端断开连接，作业将继续执行，并且输出将存储在我们执行它的文件夹中的`nohup.out`文件中。
- en: Important note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Processes launched with `nohup` will not be getting any additional input, so
    in case the program asks for input, it will just stop execution. If the program
    asks for input, it's recommended to use `tmux` instead as it will still protect
    from terminal disconnection but also allow interaction with the launched program.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`nohup`启动的进程将不会获得任何额外的输入，因此如果程序要求输入，它将停止执行。如果程序要求输入，建议使用`tmux`，因为它仍然可以防止终端断开连接，但也允许与启动的程序进行交互。
- en: Not always will we be willing to kill processes or to stop or resume them; we
    may just want to deprioritize or prioritize them—for example, for long-running
    tasks that might not be critical.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不总是愿意杀死进程或停止或恢复它们；我们可能只想降低或提高它们的优先级 - 例如，对于可能不是关键的长时间运行的任务。
- en: Let's learn about this feature in the next section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中了解这个功能。
- en: Adjusting kernel scheduling parameters to better manage processes
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整内核调度参数以更好地管理进程
- en: 'The Linux kernel is a highly configurable piece of software, so there''s a
    whole world of tunables that can be used for adjusting its behavior: for processes,
    for network cards, for disk, for memory, and more.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核是一款高度可配置的软件，因此有一整个世界的可调参数可用于调整其行为：用于进程、网络卡、磁盘、内存等等。
- en: The most common tunables are the `nice` process value and the I/O priority,
    which regulate respectively the prioritization versus other processes of the CPU
    and I/O time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的可调参数是`nice`进程值和I/O优先级，分别调节CPU和I/O时间相对于其他进程的优先级。
- en: For interacting with processes we're about to start, we can use `nice` or `ionice`
    commands, prepending the command we want to execute with some parameters (remember
    to check the `man` contents for each one to get the full available range of options).
    Just remember that for `nice`, processes can go from –20 to +19, with 0 being
    the standard one, -20 the highest priority, and 19 the lowest priority (the higher
    the value, the nicer the process is).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于即将启动的进程进行交互，我们可以使用`nice`或`ionice`命令，在要执行的命令前面加上一些参数（记得检查每个命令的`man`内容以获取完整的可用选项范围）。只需记住，对于`nice`，进程的优先级可以从-20到+19，0是标准值，-20是最高优先级，19是最低优先级（值越高，进程越好）。
- en: Each process has a likelihood of getting kernel attention to run; by changing
    the priority via `nice` before execution or via `renice` once it's running, we
    can alter it a bit.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有一个获得内核关注的可能性；通过在执行之前通过`nice`或在运行时通过`renice`改变优先级，我们可以稍微改变它。
- en: Let's think about a long-running process such as performing a backup—we want
    the task to succeed, so we will not be stopping or killing the process, but at
    the same time, we don't want it to alter the production or level of service of
    our server. If we define the process with a `nice` value of 19, this means that
    any process in the system will get more priority—that is, our process will keep
    running but will not make our system busier.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个长时间运行的进程，比如执行备份 - 我们希望任务成功，所以我们不会停止或杀死进程，但与此同时，我们也不希望它改变我们服务器的生产或服务水平。如果我们将进程定义为19的`nice`值，这意味着系统中的任何进程都会获得更高的优先级
    - 也就是说，我们的进程将继续运行，但不会使我们的系统更忙碌。
- en: This gets us into an interesting topic—many new users arriving in the Linux
    world, or administrators of other platforms, get a shock when they see that the
    system, with plenty of memory (**random-access memory**, or **RAM**), is using
    swap space, or system load is high. It is clear that some slight usage of swap
    and having lots of free RAM just means that the kernel has optimized the usage
    by swapping out unused memory to disk. As long as the system doesn't feel sluggish,
    having a high load just means that the system has a long queue of processes to
    be executed, but—for example—if the processes are *niced* to 19, they are in the
    queue, but as mentioned, any other process will get ahead of it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们进入了一个有趣的话题 - 许多新来到Linux世界的用户，或者其他平台的管理员，当他们看到系统使用了大量内存（随机存取内存，或RAM），却使用了交换空间，或者系统负载很高时，会感到震惊。很明显，轻微使用交换空间并且有大量空闲RAM只意味着内核通过将未使用的内存交换到磁盘上进行了优化。只要系统不感到迟缓，高负载只意味着系统有一个长队列的进程等待执行，但是
    - 例如 - 如果进程被*niced*到19，它们在队列中，但是如前所述，任何其他进程都会超过它。
- en: When we're checking the system status with `top` or `ps`, we can also check
    for how long a process has been running, and that is also accounted for by the
    kernel. A new process just created that starts eating CPU and RAM has a higher
    chance of being killed by the kernel to ensure system operability (remember the
    **out-of-memory** (**OOM**) killer mentioned in [*Chapter 4*](B16799_04_Final_Sk_ePub.xhtml#_idTextAnchor059),
    *Tools for Regular Operations*?).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`top`或`ps`检查系统状态时，我们也可以检查进程运行的时间，这也是由内核计算的。一个新创建的进程开始占用CPU和RAM，被内核杀死的可能性更高，以确保系统的可操作性（还记得[*第4章*](B16799_04_Final_Sk_ePub.xhtml#_idTextAnchor059)中提到的**内存不足**（**OOM**）杀手，*常规操作工具*吗？）。
- en: 'For example, let''s `renice` the process running our backup (containing the
    backup pattern in the process name to the lowest priority) with the following
    code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用以下代码将运行备份的进程（包含进程名称中的备份模式）的优先级降低到最低：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As we can see, `pgrep` has collected a list of PIDs, and that list has been
    piped as arguments for `renice` with a priority adjustment of 19, making processes
    nicer to others actually running in the system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`pgrep`已经收集了一系列PID，并且该列表已被作为`renice`的参数进行了管道传输，优先级调整为19，使实际在系统中运行的进程更加友好。
- en: 'Let''s repeat the preceding example in our system by running a pi (π) calculation
    using `bc`, as illustrated in the man page for `bc`. First, we will time how long
    it takes for your system, and then, we will execute it via `renice`. So, let''s
    get hands-on—first, let''s time it, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在系统中通过使用`bc`运行π（π）计算来重复前面的例子，就像`bc`的man页面中所示。首先，我们将计算系统所需的时间，然后通过`renice`执行它。所以，让我们动手操作—首先，让我们计时，如下所示：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In my system, this was the result:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统中，这是结果：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s run it with `renice`, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`renice`运行它，如下所示：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In my system again, this was the result:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的系统中，这是结果：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There''s a slight difference of 1 second, but you can try running more processes
    to generate system activity in your environment to make it more visible and add
    more zeros to the scale to increase the time of execution. Similarly, `ionice`
    can adjust the priority of I/O operations that a process is causing (reads, writes)—for
    example, repeating the action over the processes for our backup, we could run
    the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有1秒的轻微差异，但您可以尝试在您的环境中运行更多进程以生成系统活动，使其更加明显，并在规模上增加更多的零以增加执行时间。同样，`ionice`可以调整进程引起的I/O操作（读取、写入）的优先级—例如，对于我们的备份进程重复操作，我们可以运行以下命令：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'By default, it will not output information, but we can check the value via
    execution of the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它不会输出信息，但我们可以通过执行以下命令来检查值：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, we've moved our backup processes so that I/O requests are handled
    when the system is idle.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们已将备份进程移动，以便在系统空闲时处理I/O请求。
- en: 'The class, which we specified with the `–c` argument, can be one of the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`-c`参数指定的类可以是以下之一：
- en: '`0`: None'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：无'
- en: '`1`: Real-time'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：实时'
- en: '`2`: Best-effort'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：尽力而为'
- en: '`3`: Idle'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3`：空闲'
- en: With `–p`, we specify the processes to act on.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-p`，我们指定要操作的进程。
- en: Most of the settings that we can apply to our system came from specific ones,
    applied to each PID via the `/proc/` virtual filesystem, such as—for example—adjusting
    the `oom_adj` file to reduce the value shown on the `oom_score` file, which in
    the end determines if the process should be higher in the list when OOM has to
    kill some process to try saving the system from catastrophe.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用到系统的大多数设置都来自特定的设置，通过`/proc/`虚拟文件系统应用到每个PID，例如—例如—调整`oom_adj`文件以减少`oom_score`文件上显示的值，最终确定进程是否应在OOM需要杀死一些进程以尝试拯救系统免受灾难时更高。
- en: Of course, there are system-level settings such as `/proc/sys/vm/panic_on_oom`
    that can tune how the system has to react (panic or not) in case the OOM has to
    be invoked.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有一些系统级设置，例如`/proc/sys/vm/panic_on_oom`，可以调整系统如何在OOM必须被调用时做出反应（是否恐慌）。
- en: The disks also have a setting to define the scheduler being used—for example,
    for a disk named `sda`, it can be checked via `cat /sys/block/sda/queue/scheduler`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘还有一个设置，用于定义正在使用的调度程序—例如，对于名为`sda`的磁盘，可以通过`cat /sys/block/sda/queue/scheduler`进行检查。
- en: The scheduler used for a disk has different approaches and depends on the kernel
    version—for example, it used to be `noop`, `deadline`, or `cfq` in RHEL 7, but
    in RHEL 8 those were removed, and we have `md-deadline`, `bfq`, `kyber`, and `none`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘使用的调度程序有不同的方法，取决于内核版本—例如，在RHEL 7中，它曾经是`noop`、`deadline`或`cfq`，但在RHEL 8中，这些已被移除，我们有`md-deadline`、`bfq`、`kyber`和`none`。
- en: This is such a big and complex topic that there is even a specific manual for
    it at [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_for_real_time/8/html-single/tuning_guide/index](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_for_real_time/8/html-single/tuning_guide/index),
    so if you're interested in going deeper, have a look at it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个如此庞大而复杂的主题，甚至有一个专门的手册，网址为[https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_for_real_time/8/html-single/tuning_guide/index](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_for_real_time/8/html-single/tuning_guide/index)，所以如果您有兴趣深入了解，请查看它。
- en: 'I hope to have achieved two things here, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望在这里实现两件事，如下所示：
- en: Making clear that the system has a lot of options for tuning and that it has
    its own documentation for it, and even a Red Hat Certified Architect exam for
    it at [https://www.redhat.com/en/services/training/rh442-red-hat-enterprise-performance-tuning](https://www.redhat.com/en/services/training/rh442-red-hat-enterprise-performance-tuning).
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确指出系统有很多调整选项，并且有自己的文档，甚至有一个Red Hat认证架构师考试，网址为[https://www.redhat.com/en/services/training/rh442-red-hat-enterprise-performance-tuning](https://www.redhat.com/en/services/training/rh442-red-hat-enterprise-performance-tuning)。
- en: 'It''s not an easy task—several times in this book, one idea has been reinforced:
    test everything using your system''s workload, as results might vary from one
    system to another.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这并不是一项容易的任务—在本书中多次强调了一个观点：使用您系统的工作负载测试一切，因为结果可能因系统而异。
- en: Fortunately, there's no need to feel afraid about system tuning—it's something
    we can become more proficient in with experience at all levels (knowledge, hardware,
    workloads, and so on), but on the other hand, systems also include some easier
    ways to perform quick adjustments that will fit many scenarios, as we will see
    in the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，不需要对系统调优感到害怕——我们可以通过经验在各个层面（知识、硬件、工作负载等）变得更加熟练，但另一方面，系统也包括一些更简单的方法来进行快速调整，适用于许多场景，我们将在下一节中看到。
- en: Installing tuned and managing tuning profiles
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装tuned和管理调优配置文件
- en: Hopefully, after a bit of scaremongering happening in the previous section,
    you already have a mindset prepared for an easier path.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在前面的部分中发生了一些危言耸听之后，您已经准备好迎接更简单的路径了。
- en: 'Just in case, ensure the `tuned` package is installed, or install it with `dnf
    –y install tuned`. The package provides a *tuned* service that must be enabled
    and started for operation; as a refresher, we achieve this by running the following
    command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以防万一，请确保已安装了`tuned`软件包，或者使用`dnf –y install tuned`进行安装。该软件包提供了一个必须启用并启动的*tuned*服务；作为复习，我们通过运行以下命令来实现这一点：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We're now ready to interact and get more information about this service, which
    announces itself at `dnf info tuned` as a daemon that tunes the system dynamically
    based on some observation and is currently acting on an Ethernet network and hard
    disks.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好与该服务进行交互并获取更多信息，该服务在`dnf info tuned`中宣布自己是一个根据某些观察动态调整系统的守护进程，目前正在以太网网络和硬盘上运行。
- en: 'Interaction with the daemon is performed via the `tuned-adm` command. For illustration,
    we''re showing in the following screenshot the command-line options available
    and a list of profiles:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`tuned-adm`命令与守护进程进行交互。为了说明，我们在下图中展示了可用的命令行选项和配置文件列表：
- en: '![Figure 16.5 – The tuned-adm command-line options and profiles'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.5 - tuned-adm命令行选项和配置文件'
- en: '](img/B16799_16_005.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_16_005.jpg)'
- en: Figure 16.5 – The tuned-adm command-line options and profiles
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5 - tuned-adm命令行选项和配置文件
- en: As we can see, there are some options for listing, disabling, and grabbing information
    about a profile, getting recommendations on which profile to use, verifying that
    settings have not been altered, automatically selecting a profile, and so on.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，有一些选项可以列出、禁用和获取有关配置文件的信息，获取有关要使用哪个配置文件的建议，验证设置是否已被更改，自动选择配置文件等。
- en: One thing to bear in mind is that newer versions of the `tuned` package might
    bring additional profiles or configurations (stored in the `/usr/lib/tuned/` folder
    hierarchy), so the output might differ in your system.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住的一件事是，较新版本的`tuned`软件包可能会带来额外的配置文件或配置（存储在`/usr/lib/tuned/`文件夹层次结构中），因此您的系统可能会有所不同。
- en: 'Let''s review some of the most common ones in the following table:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下表中回顾一些最常见的选项：
- en: '![](img/Table_16.1_a.jpg)![](img/Table_16.1_b.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_16.1_a.jpg)![](img/Table_16.1_b.jpg)'
- en: 'As mentioned, each configuration is always a trade-off: more power consumption
    is required when increasing performance, or improving throughput might also increase
    latency.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，每个配置都是一种权衡：提高性能需要更多的功耗，或者提高吞吐量可能会增加延迟。
- en: 'Let''s enable the `latency-performance` profile for our system. To do so, we
    will execute the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的系统启用`latency-performance`配置文件。为此，我们将执行以下命令：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can verify that it has been activated with `tuned-adm active`, where we
    can see it shows `latency-performance`, as seen in the following screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`tuned-adm active`来验证它是否已激活，可以看到它显示了`latency-performance`，如下图所示：
- en: '![Figure 16.6 – The tuned-adm profile activation and verification'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.6 - tuned-adm配置文件激活和验证'
- en: '](img/B16799_16_006.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_16_006.jpg)'
- en: Figure 16.6 – The tuned-adm profile activation and verification
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6 - tuned-adm配置文件激活和验证
- en: We additionally modified the system with `sysctl -w vm.swappiness=69` (on purpose)
    to demonstrate the `tuned-adm verify` operation, as it reported that some settings
    changed from the ones defined in the profile.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过`sysctl -w vm.swappiness=69`（故意）修改了系统，以演示`tuned-adm verify`操作，因为它报告说一些设置已经从配置文件中定义的设置发生了变化。
- en: Important note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Dynamic tuning is by default disabled as of this writing—to enable or to check
    the current status, check that `dynamic_tuning=1` appears in the `/etc/tuned/tuned-main.conf`
    file. It is disabled in the performance profiles as it by default tries to balance
    between power consumption and system performance, which is the opposite of what
    performance profiles try to do.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，默认情况下动态调整是禁用的——要启用或检查当前状态，请检查`/etc/tuned/tuned-main.conf`文件中是否出现了`dynamic_tuning=1`。在性能配置文件中它是被禁用的，因为默认情况下它试图在功耗和系统性能之间取得平衡，这与性能配置文件的目标相反。
- en: 'Additionally, bear in mind that the **Cockpit** interface introduced in this
    book also features a way to change the performance profile—as seen in the following
    screenshot—once you have clicked on the **Performance profile** link in the main
    Cockpit page, opening up this dialog:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请记住，本书介绍的**Cockpit**界面还提供了一种更改性能配置文件的方法——如下截图所示——一旦您在主Cockpit页面上点击了**Performance
    profile**链接，就会打开此对话框：
- en: '![Figure 16.7 – Changing tuned profile within Cockpit web interface'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.7 - 在Cockpit Web界面中更改tuned配置文件'
- en: '](img/B16799_16_007.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_16_007.jpg)'
- en: Figure 16.7 – Changing tuned profile within Cockpit web interface
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7 - 在Cockpit Web界面中更改tuned配置文件
- en: In the next section, we will examine how tuned profiles work under the hood
    and how to create a custom one.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨调优配置文件在幕后是如何工作的，以及如何创建自定义配置文件。
- en: Creating a custom tuned profile
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个自定义的调优配置文件
- en: Once we've commented on the different tuned profiles... *How do they work? How
    to create one?*
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们评论了不同的tuned配置文件... *它们是如何工作的？如何创建一个？*
- en: Let's examine, for example, `latency-performance` in the next lines of code,
    by checking the `/usr/lib/tuned/latency-performance/tuned.conf` file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们通过检查`/usr/lib/tuned/latency-performance/tuned.conf`文件来检查`latency-performance`。
- en: In general, the syntax of the file is described in the `man tuned.conf` page,
    but the file, as you will be able to examine, is an *initialization (ini)-file*—that
    is, a file organized in categories, expressed between brackets and pairs of keys
    and values assigned by the equals (`=`) sign.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，文件的语法在`man tuned.conf`页面中有描述，但是文件，正如您将能够检查的那样，是一个*初始化（ini）文件*——也就是说，它是一个在括号之间表达的类别文件，并且由等号（`=`）分配的键和值对。
- en: The main section defines a summary of the profile if it inherits from another
    profile via `include`, and the additional sections depend on the plugins installed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 主要部分定义了配置文件的摘要，如果它通过`include`从另一个配置文件继承，并且其他部分取决于安装的插件。
- en: 'To learn about the available plugins, the documentation included in the man
    page (`man tuned.conf`) instructs us to execute `rpm -ql tuned | grep ''plugins/plugin_.*.py$''`,
    which provides an output similar to this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解可用的插件，man页面中包含的文档指示我们执行`rpm -ql tuned | grep 'plugins/plugin_.*.py$'`，这将提供类似于以下的输出：
- en: '![Figure 16.8 – Available tuned plugins in our system'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.8 - 系统中可用的tuned插件'
- en: '](img/B16799_16_008.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_16_008.jpg)'
- en: Figure 16.8 – Available tuned plugins in our system
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8 - 系统中可用的tuned插件
- en: Important note
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If two or more plugins try to act over the same devices, the `replace=1` setting
    will mark the difference between running all of them or only the latest one.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个或更多的插件尝试对相同的设备进行操作，`replace=1`设置将标记运行它们所有还是只运行最新的一个。
- en: 'Coming back to the `latency-performance` profile, this has three sections:
    `main`, `cpu`, and `sysctl`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`latency-performance`配置文件，它有三个部分：`main`、`cpu`和`sysctl`。
- en: For the CPU, it sets the performance governor, which we can check—if supported
    via `cat /sys/devices/system/cpu/*/cpufreq/scaling_governor`—for each CPU available
    in our system. Bear in mind that in some systems, the path might differ or may
    even not exist, and we can check the available ones via execution of `cpupower
    frequency-info –governors`, with `powersave` and `performance` being the most
    common ones.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CPU，它设置了性能调度器，我们可以通过`cat /sys/devices/system/cpu/*/cpufreq/scaling_governor`检查每个系统中可用的CPU是否支持。请记住，在某些系统中，路径可能不同，甚至可能不存在，我们可以通过执行`cpupower
    frequency-info –governors`来检查可用的路径，`powersave`和`performance`是最常见的。
- en: 'The name of the section for each plugin might be arbitrary if we specify the
    `type` keyword to indicate which plugin to use, and we can use some devices to
    act on via the `devices` keyword, allowing—for example—the definition of several
    disk sections with different settings based on the disk being configured. For
    example, we might want some settings for the system disk—let''s say `sda`—and
    for the disk we use for data backups at `sdb`, as illustrated here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个插件的部分名称可能是任意的，如果我们指定`type`关键字来指示要使用哪个插件，并且我们可以使用`devices`关键字来对一些设备进行操作，例如，根据正在配置的磁盘的不同设置，允许定义几个磁盘部分。例如，我们可能希望为系统磁盘（比如`sda`）和用于数据备份的磁盘（比如`sdb`）定义一些设置，如下所示：
- en: '[PRE10]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, the disk named `sda` gets configured with `readahead`
    (which reads sectors ahead of current utilization to have the data cached before
    actually being requested to access it), and we're telling the system to `spindown`
    data disks that might be used only at backup time, thus reducing noise and power
    consumption when not in use.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，名为`sda`的磁盘使用`readahead`进行配置（它在当前利用之前读取扇区，以便在实际请求访问数据之前将数据缓存），我们告诉系统`spindown`数据磁盘，这些磁盘可能仅在备份时使用，因此在不使用时减少噪音和功耗。
- en: 'Another interesting plugin is `sysctl`, used by several of the profiles, which
    defines settings in the same way we might do with the `sysctl` command, and because
    of this, the possibilities are huge: defining **Transmission Control Protocol**
    (**TCP**) window sizes for tuning networking, virtual memory management, transparent
    huge pages, and so on.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的插件是`sysctl`，被几个配置文件使用，它以与`sysctl`命令相同的方式定义设置，因此可能性是巨大的：定义用于调整网络、虚拟内存管理、透明大页等的**传输控制协议**（**TCP**）窗口大小。
- en: Tip
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: It is hard to start from scratch with any performance tuning, and as `tuned`
    allows us to inherit settings from a parent, it makes sense to find which one
    of the available profiles is the closest to what we want to achieve, check what
    is being configured in it, and—of course—compare it with the others (as we can
    see, there are also examples for other plugins) and apply it to our custom profile.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始进行任何性能调整都很困难，而且由于`tuned`允许我们从父级继承设置，因此找到可用配置文件中最接近我们想要实现的目标的配置文件，检查其中的配置，当然，与其他配置文件进行比较是有意义的（正如我们所看到的，其他插件也有示例），并将其应用到我们的自定义配置文件中。
- en: 'To get an idea about how the defined system profiles touch a system, my RHEL
    8 system shows the following output for `cat /usr/lib/tuned/*/tuned.conf|grep
    -v ^#|grep ''^\[''|sort –u`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解定义的系统配置文件如何影响系统，我的RHEL 8系统对`cat /usr/lib/tuned/*/tuned.conf|grep -v ^#|grep
    '^\['|sort –u`命令显示以下输出：
- en: '![Figure 16.9 – Sections in system-supplied profiles'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.9 - 系统提供的配置文件中的部分'
- en: '](img/B16799_16_009.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_16_009.jpg)'
- en: Figure 16.9 – Sections in system-supplied profiles
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9 - 系统提供的配置文件中的部分
- en: So, as we can see, they touch a lot of areas, and I would like to highlight
    the `script` section, which defines a shell script to execute used by the `powersave`
    profile, and the `variables` section, used by `throughput-performance` to define
    regular expressions for later matching and applying settings based on the CPU.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们所看到的，它们涉及到很多领域，我想强调`script`部分，它定义了一个用于`powersave`配置文件执行的shell脚本，以及`variables`部分，它用于`throughput-performance`配置文件，用于定义后续匹配和基于CPU应用设置的正则表达式。
- en: Once we're ready, we will create a new folder at `/etc/tuned/newprofile`. A
    `tuned.conf` file must be created, containing the main section with the summary
    and the additional sections for the plugins we want to use.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好，我们将在`/etc/tuned/newprofile`下创建一个新的文件夹。必须创建一个`tuned.conf`文件，其中包含摘要的主要部分和我们想要使用的插件的其他部分。
- en: When creating a new profile, it might be easier if we copy the profile we're
    interested in from `/usr/lib/tuned/$profilename/` into our `/etc/tuned/newprofile/`
    folder and start the customization from there.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新配置文件时，如果我们将感兴趣的配置文件从“/usr/lib/tuned/$profilename/”复制到我们的“/etc/tuned/newprofile/”文件夹中，并从那里开始定制，可能会更容易。
- en: Once it's ready, we can enable the profile with `tuned-adm profile newprofile`,
    as we introduced earlier in this chapter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备就绪，我们可以使用“tuned-adm profile newprofile”启用配置文件，就像我们在本章中介绍的那样。
- en: You can find more information about the profiles available in the official documentation
    at [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/monitoring_and_managing_system_status_and_performance/index](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/monitoring_and_managing_system_status_and_performance/index).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中找到有关可用配置文件的更多信息[https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/monitoring_and_managing_system_status_and_performance/index](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/monitoring_and_managing_system_status_and_performance/index)。
- en: With this, we've set up our own custom profile for tuning our performance settings.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们为调整性能设置设置了自定义配置文件。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about identifying the processes, checking their
    resource consumption, and how to send signals to them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何识别进程，检查它们的资源消耗，以及如何向它们发送信号。
- en: About the signals, we learned that some of them have some additional behavior,
    such as terminating processes nicely or abruptly, or just sending a notification
    that some programs understand as reload configuration without restarting, and
    so on.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 关于信号，我们了解到其中一些具有一些额外的行为，比如优雅或突然终止进程，或者只是发送通知，一些程序将其理解为重新加载配置而不重新启动等等。
- en: Also, related to processes, we learned about how to adjust their priority compared
    to other processes in terms of CPU and I/O so that we can adjust long-running
    processes or disk-intensive ones to not affect other services running.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，关于进程，我们学习了如何调整它们相对于CPU和I/O的优先级，以便我们可以调整长时间运行的进程或磁盘密集型进程，以免影响其他正在运行的服务。
- en: Finally, we introduced the `tuned` daemon, which includes several general use-case
    profiles that we can use directly in our system, allowing `tuned` to apply some
    dynamic tuning, or we can fine-tune the profiles by creating one of our own to
    increase system performance or optimize power usage.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了“tuned”守护程序，其中包括几个通用的使用案例配置文件，我们可以直接在我们的系统中使用，允许“tuned”应用一些动态调整，或者我们可以通过创建自己的配置文件来微调配置文件，以提高系统性能或优化功耗。
- en: In the next chapter, we will learn about how we can work with containers, registries,
    and other components so that applications can run as provided by the vendor while
    being isolated from the server running them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用容器、注册表和其他组件，以便应用程序可以在供应商提供的情况下运行，同时与运行它们的服务器隔离。
