- en: Chapter 5. Network Troubleshooting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。网络故障排除
- en: In [Chapter 3](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 3. Troubleshooting a Web Application"), *Troubleshooting a Web Application*,
    we took an in-depth look at troubleshooting web applications; while we walked
    through a complex application error, we completely skipped the networking aspect
    of web applications. In this chapter, we will investigate a reported issue that
    will walk us through concepts such as DNS, routing, and of course network configuration
    for RHEL systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4 "第3章。故障排除Web应用程序")中，*故障排除Web应用程序*，我们深入研究了故障排除Web应用程序；虽然我们解决了一个复杂的应用程序错误，但我们完全跳过了Web应用程序的网络方面。在本章中，我们将调查一个报告的问题，这将引导我们了解DNS、路由，当然还有RHEL系统的网络配置等概念。
- en: 'Networking is an essential skill for any Linux systems administrator. To quote
    a past instructor:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何Linux系统管理员来说，网络是一项必不可少的技能。引用一位过去的讲师的话：
- en: A server without a network is useless to everyone.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 没有网络的服务器对每个人都是无用的。
- en: As a systems administrator, every server or desktop that you manage will have
    some sort of network connection. Whether this network connection is within a segregated
    corporate network or directly connected to the Internet, a network is involved.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 作为系统管理员，您管理的每台服务器或台式机都将有某种网络连接。无论这种网络连接是在隔离的公司网络内还是直接连接到互联网，都涉及到网络。
- en: Since networking is such a critical topic, this chapter will cover many aspects
    of networking and network connectivity; however, it will not cover firewalls.
    Firewall troubleshooting and configuration will actually be covered in [Chapter
    6](part0037_split_000.html#1394Q1-8ae10833f0c4428b9e1482c7fee089b4 "Chapter 6. Diagnosing
    and Correcting Firewall Issues"), *Diagnosing and Correcting Firewall Issues*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网络是一个如此关键的主题，本章将涵盖网络和网络连接的许多方面；然而，它不会涵盖防火墙。防火墙故障排除和配置实际上将在[第6章](part0037_split_000.html#1394Q1-8ae10833f0c4428b9e1482c7fee089b4
    "第6章。诊断和纠正防火墙问题")中进行，*诊断和纠正防火墙问题*。
- en: Database connectivity issues
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库连接问题
- en: In [Chapter 3](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 3. Troubleshooting a Web Application"), *Troubleshooting a Web Application*,
    we were troubleshooting a problem with the company blog. In this chapter, we will
    once again troubleshoot this blog; however, today's issue is a bit different.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4 "第3章。故障排除Web应用程序")中，*故障排除Web应用程序*，我们正在解决公司博客的问题。在本章中，我们将再次解决这个博客；然而，今天的问题有点不同。
- en: 'After arriving for the day, we receive a call from a developer stating: *The
    WordPress blog is returning an error that it cannot connect to the database*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到达当天后，我们接到一位开发人员的电话，他说：“WordPress博客返回了一个无法连接到数据库的错误”。
- en: Data collection
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据收集
- en: 'According to the troubleshooting process that we have been following, the next
    step is to gather as much data as possible around the issue. One of the best sources
    of information is the person reporting the issue; for this situation, we will
    ask two basic questions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们一直遵循的故障排除过程，下一步是尽可能收集关于问题的数据。信息的最佳来源之一是报告问题的人；对于这种情况，我们将问两个基本问题：
- en: How can I duplicate the issue and see the error?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何复制问题并查看错误？
- en: Has anything changed recently with the WordPress application?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最近WordPress应用有什么变化吗？
- en: When asked, the developer states that we can see the error simply by going to
    the blog in the web browser. On the second question, the developer informs us
    that the database service was recently moved from the webserver to a new dedicated
    database server. He also mentions that the move happened several days ago and
    that the application was working until today.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当被问及时，开发人员表示我们只需在网页浏览器中访问博客就可以看到错误。在第二个问题上，开发人员告诉我们，数据库服务最近从Web服务器移动到了一个新的专用数据库服务器。他还提到这个移动是在几天前发生的，并且应用程序一直到今天都在工作。
- en: Since the database service was moved several days ago and the application was
    working up until this morning, it is not likely that this change caused the issue.
    However, we should not discount this as a possibility.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据库服务是几天前移动的，而且应用程序直到今天早上都在工作，所以这个改变不太可能引起问题。然而，我们不应该排除这种可能性。
- en: Duplicating the issue
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制问题
- en: As discussed in the previous chapters, a key data collection task is to duplicate
    the issue. We do this to not only verify that the issue being reported is the
    issue occurring but also to find any additional errors that may not have been
    reported.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前几章讨论的，关键的数据收集任务是复制问题。我们这样做不仅是为了验证报告的问题是否确实存在，还为了找出可能没有被报告的任何其他错误。
- en: Since the developer stated that we could duplicate this by going to the blog
    directly, we will do that from our web browser.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于开发人员表示我们可以直接访问博客来复制这个问题，我们将在网页浏览器中进行操作。
- en: '![Duplicating the issue](img/00004.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![复制问题](img/00004.jpeg)'
- en: It seems that we can duplicate the issue pretty easily. On the basis of this
    error, it appears that the application is simply saying that it is having issues
    establishing a database connection. While this in itself does not mean that the
    issue is network-related, it could be. The issue could also simply be an issue
    with the database service itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎我们可以很容易地复制这个问题。根据这个错误，似乎应用程序只是在说它在建立数据库连接时出现了问题。虽然这本身并不意味着问题与网络有关，但也可能是。问题也可能只是数据库服务本身的问题。
- en: To determine whether the issue is a network issue or a database service issue,
    we will first need to find which server the application is configured to connect
    to.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定问题是网络问题还是数据库服务问题，我们首先需要找出应用程序配置为连接到哪个服务器。
- en: Finding the database server
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找数据库服务器
- en: As with the previous chapter, we will determine which server the application
    is using by looking through the application configuration files. From our previous
    troubleshooting in [Chapter 3](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 3. Troubleshooting a Web Application"), *Troubleshooting a Web Application*,
    we know that the WordPress application is hosted on `blog.example.com`. To get
    started, we will first log into the blog's webserver and look through the WordPress
    configuration files.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章类似，我们将通过查看应用程序配置文件来确定应用程序使用的服务器。根据我们在[第3章](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4
    "第3章。故障排除Web应用程序")中的先前故障排除，*故障排除Web应用程序*，我们知道WordPress应用程序托管在`blog.example.com`上。首先，我们将登录到博客的Web服务器并查看WordPress配置文件。
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As we will be executing commands against multiple systems, the examples in this
    chapter will include a hostname such as `blog` or `db` in the command-line prompt.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将针对多个系统执行命令，因此本章的示例将在命令行提示中包含主机名，如`blog`或`db`。
- en: We learned in [Chapter 3](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 3. Troubleshooting a Web Application"), *Troubleshooting a Web Application*,
    that the WordPress database configuration is stored within the `/var/www/html/wp-config.php`
    file. To quickly search this file for database information, we can use the `grep`
    command to search for the string `DB` as this string was present for the database
    configuration in our previous incident.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4 "第3章。故障排除Web应用程序")中学到，WordPress数据库配置存储在`/var/www/html/wp-config.php`文件中。为了快速搜索该文件以获取数据库信息，我们可以使用`grep`命令搜索字符串`DB`，因为在我们先前的事件中，该字符串出现在数据库配置中。
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With the above, we can see that the application is currently configured to connect
    to `db.example.com`. A simple first troubleshooting step is to simply attempt
    to connect to the database manually. A simple way to test the database connectivity
    manually is to use the `telnet` command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述内容，我们可以看到该应用程序当前配置为连接到`db.example.com`。简单的第一步故障排除是尝试手动连接到数据库。手动测试数据库连接的简单方法是使用`telnet`命令。
- en: Testing connectivity
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试连接
- en: The `telnet` command is a very useful network and network service troubleshooting
    tool as it is designed to simply establish a TCP-based network connection to the
    specified host and port. For our example, we will attempt to connect to the host
    `db.example.com` on port `3306`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`telnet`命令是一个非常有用的网络和网络服务故障排除工具，因为它旨在简单地建立到指定主机和端口的基于TCP的网络连接。在我们的例子中，我们将尝试连接到主机`db.example.com`的端口`3306`。'
- en: Port `3306` is the default port for MySQL and MariaDB; in the previous chapter,
    we already established that this web application requires one of these two database
    services. As we do not see a specific port listed in the `wp-config.php` file's
    configuration, we will assume that the database service is running on this default
    port.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 端口`3306`是MySQL和MariaDB的默认端口；在上一章中，我们已经确定了这个Web应用程序需要这两个数据库服务中的一个。由于在`wp-config.php`文件的配置中没有看到特定的端口，我们将假设数据库服务正在运行在这个默认端口上。
- en: Telnet from blog.example.com
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从blog.example.com进行Telnet
- en: To get started, we will execute the `telnet` command from the blog server itself.
    The fact that we are testing from the same server that the application runs on
    is important, as this allows us to test under the same network conditions as the
    application receiving the error.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从博客服务器本身执行`telnet`命令。从应用程序运行的同一服务器进行测试非常重要，因为这样可以在应用程序接收到错误的相同网络条件下进行测试。
- en: To use telnet to connect to our database server, we will execute the `telnet`
    command followed by the hostname (`db.example.com`) and port (`3306`) that we
    wish to connect to.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用telnet连接到我们的数据库服务器，我们将执行`telnet`命令，后面跟着我们希望连接到的主机名（`db.example.com`）和端口（`3306`）。
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It seems that the telnet connection failed. What is interesting is the error
    being provided; the **No route to host** error seems to clearly indicate a potential
    network issue.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Telnet连接似乎失败了。有趣的是提供的错误；**无法连接到主机**错误似乎清楚地指示了潜在的网络问题。
- en: Telnet from our laptop
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从我们的笔记本电脑进行Telnet
- en: Since the connection attempt from the blog server failed with an error indicating
    there was a network-related issue, we can attempt the same connectivity from our
    laptop to determine whether the issue is on the blog server's side or the `db`
    server's side.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从博客服务器的连接尝试失败，并指示存在与网络相关的问题，我们可以尝试从我们的笔记本电脑进行相同的连接，以确定问题是在博客服务器端还是`db`服务器端。
- en: To test this connectivity from our laptop, we can once again use the `telnet`
    command. We can use this command even though our laptop is not necessarily running
    a Linux operating system. The reason for this is that the `telnet` command is
    a cross-platform utility; in this chapter, we will utilize several commands that
    are cross-platform. While there may not be many of them, in general, there are
    several commands that work on most operating systems, including those that do
    not traditionally have extensive command line functionality.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从我们的笔记本电脑测试这种连接，我们可以再次使用`telnet`命令。尽管我们的笔记本电脑不一定运行Linux操作系统，但我们仍然可以使用这个命令。原因是`telnet`命令是一个跨平台实用程序；在本章中，我们将利用几个跨平台命令。虽然这样的命令可能不多，但一般来说，有几个命令适用于大多数操作系统，包括那些传统上没有广泛命令行功能的系统。
- en: While some operating systems have been removing the `telnet` client from default
    installations, the software can still be installed. For our example, the laptop
    is running OS X, which currently deploys the `telnet` client.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些操作系统已经从默认安装中删除了`telnet`客户端，但该软件仍然可以安装。在我们的例子中，笔记本电脑正在运行OS X，该系统目前部署了`telnet`客户端。
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It seems that our laptop is also unable to connect to the database service;
    however, the error is different this time. This time it seems to suggest that
    the connection attempt was closed by the remote service. We also do not see a
    message from the remote service, which would indicate that the connection was
    never fully established.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们的笔记本也无法连接到数据库服务；然而，这次错误不同。这次似乎表明连接尝试被远程服务关闭。我们也没有看到来自远程服务的消息，这表明连接从未完全建立。
- en: One caveat to using the `telnet` command to establish port availability is that
    the `telnet` command will show a connection as **Connected**; however, the connection
    may not necessarily be established at this point. The general rule when working
    with telnet is to not assume that the connection was successful until a message
    from the remote service is received. In our example, we did not receive a message
    from the remote service.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“telnet”命令建立端口可用性的一个注意事项是，“telnet”命令将显示连接为**已连接**；然而，此时连接可能并没有真正建立。在使用telnet时的一般规则是，在收到来自远程服务的消息之前，不要假设连接成功。在我们的例子中，我们没有收到来自远程服务的消息。
- en: Ping
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ping
- en: Since `telnet` from both the blog server and our laptop failed, we should check
    whether the issue is isolated to just the database service or connectivity to
    the server as a whole. One tool to test server-to-server connectivity is the `ping`
    command, which like the `telnet` command is a cross-platform utility.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于博客服务器和我们的笔记本都无法从“db”服务器进行telnet连接，我们应该检查问题是否仅限于数据库服务或整个服务器的连接。测试服务器之间的连接的一个工具是“ping”命令，就像“telnet”命令一样是一个跨平台实用程序。
- en: To test connectivity with the `ping` command, we can simply execute the command
    followed by the host that we wish to `ping`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用“ping”命令测试与主机的连接性，我们只需执行命令，然后跟随我们希望“ping”的主机。
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The error from the `ping` command seems to be very similar to the error from
    the `telnet` command. To understand this error better, let's first get a better
    understanding of how the `ping` command works.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: “ping”命令的错误似乎与“telnet”命令的错误非常相似。为了更好地理解这个错误，让我们首先更好地了解“ping”命令的工作原理。
- en: First, before any other action, the `ping` command will try to resolve the hostname
    provided. What this means is that before doing anything else, our ping execution
    tried to identify the IP address of `db.example.com`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在执行任何其他操作之前，“ping”命令将尝试解析提供的主机名。这意味着在执行任何其他操作之前，我们的ping执行尝试识别“db.example.com”的IP地址。
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From the results, we can see that the `ping` command identified this host as
    resolving to `192.168.33.12`. Once ping has the IP address, it will send an `ICMP`
    echo request network packet to that IP. In this case, this means that it is sending
    an `ICMP` echo request to `192.168.33.12`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中，我们可以看到“ping”命令将此主机解析为“192.168.33.12”。一旦ping有了IP地址，它将向该IP发送一个“ICMP”回显请求网络数据包。在这种情况下，这意味着它正在向“192.168.33.12”发送一个“ICMP”回显请求。
- en: ICMP is a networking protocol that is used as a control system. When the remote
    host, such as `192.168.33.12` receives an `ICMP` echo request network packet,
    it is supposed to send an `ICMP` echo reply network packet back to the requesting
    host. This activity allows two hosts to validate network connectivity by performing
    a simple networking version of *ping pong*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP是一种用作控制系统的网络协议。当远程主机，比如“192.168.33.12”接收到“ICMP”回显请求网络数据包时，它应该发送一个“ICMP”回显回复网络数据包回到请求的主机。这种活动允许两个主机通过进行简单的网络版本的“乒乓球”来验证网络连接。
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If our `ICMP` echo request packet had never made it to the `192.168.33.12` server,
    we simply would have had no output from the `ping` command. However, we received
    an error; this means that the system on the other side is up, but there is an
    error with the connectivity between the two hosts that is preventing a full two-way
    discussion.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的“ICMP”回显请求数据包从“192.168.33.12”服务器没有传输过来，我们的“ping”命令就不会有任何输出。然而，我们收到了一个错误；这意味着另一端的系统是开启的，但两个主机之间的连接存在问题，阻止了完全的双向交流。
- en: One question that arises around this issue is whether the error is true for
    all network connectivity from the blog server or isolated to the communication
    between the `blog` and the `db` server. We can test this by performing a `ping`
    request to another generic address. Since our system is connected to the Internet,
    we can simply use a common Internet domain.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕这个问题出现的一个问题是，这个错误是否适用于博客服务器的所有网络连接，还是仅限于“blog”和“db”服务器之间的通信。我们可以通过向另一个通用地址执行“ping”请求来测试这一点。由于我们的系统连接到互联网，我们可以简单地使用一个常见的互联网域名。
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding example is an example of a working `ping` request and reply. Here,
    we can see not only the IP that [Google.com](http://Google.com) resolves to but
    also the returned `ping` requests. This means that, as our blog server sends an
    `ICMP echo request`, the remote server `216.58.216.46` sends an `ICMP echo reply`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子是一个工作的“ping”请求和回复的例子。在这里，我们不仅可以看到[Google.com](http://Google.com)解析为的IP，还可以看到返回的“ping”请求。这意味着，当我们的博客服务器发送一个“ICMP回显请求”时，远程服务器“216.58.216.46”会发送一个“ICMP回显回复”。
- en: Troubleshooting DNS
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除DNS
- en: Something interesting that both the `ping` and the `telnet` commands told us
    beyond network connectivity is the IP address of the `db.example.com` hostname.
    However, it seems that our results are different when performing these actions
    from our laptop as opposed to from the blog server.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了网络连接之外，“ping”和“telnet”命令告诉我们的另一件有趣的事情是“db.example.com”主机名的IP地址。然而，当我们从我们的笔记本执行这些操作时，结果似乎与从博客服务器执行这些操作时不同。
- en: From the blog server, our `telnet` tried to connect to `192.168.33.12`, the
    same address as our `ping` command.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从博客服务器，我们的“telnet”尝试连接到“192.168.33.12”，与我们的“ping”命令相同的地址。
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The reason for this is simple; it seems that our laptop is getting a different
    DNS result as our blog server. If that is the case however, it could mean that
    our issue may simply be related to a DNS issue.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 原因很简单；看起来我们的笔记本得到了与我们的博客服务器不同的DNS结果。然而，如果是这种情况，这可能意味着我们的问题可能只是与DNS问题有关。
- en: Checking DNS with dig
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用dig检查DNS
- en: DNS is an important aspect of modern-day networks. Our current issue is a perfect
    example of its importance. In the WordPress configuration file, our database server
    is set to `db.example.com`. This means that before the application server can
    establish a database connection, it must first look up the IP address.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: DNS是现代网络的重要组成部分。我们当前的问题就是它重要性的一个完美例子。在WordPress配置文件中，我们的数据库服务器设置为`db.example.com`。这意味着在应用服务器建立数据库连接之前，必须首先查找IP地址。
- en: In many cases, it is fairly safe to assume that the IP address identified by
    `ping` is likely to be the IP address presented by DNS. However, this is not always
    the case as we may soon find out with our specific issue.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，可以相当安全地假设`ping`识别的IP地址很可能是DNS呈现的IP地址。然而，并非总是如此，正如我们可能很快发现的那样。
- en: 'The `dig` command is a very useful DNS troubleshooting command; it is very
    flexible and can be used to perform many different types of DNS requests. To validate
    the DNS for `db.example.com`, we can simply execute the `dig` command followed
    by the hostname that we wish to query: `db.example.com`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`dig`命令是一个非常有用的DNS故障排除命令；它非常灵活，可以用来执行许多不同类型的DNS请求。要验证`db.example.com`的DNS，我们只需执行`dig`命令，然后跟上我们要查询的主机名：`db.example.com`。'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we look at the returned data from `dig`, we can see that the DNS name `db.example.com`
    does not resolve to `192.168.33.12`, but rather to `10.0.0.50`. We can see this
    in the `ANSWER SECTION` of the `dig` command's output.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`dig`返回的数据，我们可以看到DNS名称`db.example.com`解析为`192.168.33.12`，而不是`10.0.0.50`。我们可以在`dig`命令的输出的`ANSWER
    SECTION`中看到这一点。
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: One very useful option with `dig` is the option to specify a server to query.
    In the previous execution of `dig`, we could see that server `10.0.2.3` was the
    server that provided the `10.0.0.50` address.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`dig`的一个非常有用的选项是指定要查询的服务器。在之前执行的`dig`中，我们可以看到服务器`10.0.2.3`是提供`10.0.0.50`地址的服务器。'
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since we are unfamiliar with this DNS server, we can validate the returned results
    further by querying Google's public DNS servers. We can do this by adding `@`
    followed by the DNS server IP or hostname that we wish to use. In the following
    example, we are requesting `8.8.8.8` a DNS server that is part of Google's public
    DNS infrastructure.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们对这个DNS服务器不熟悉，我们可以通过查询谷歌的公共DNS服务器来进一步验证返回的结果。我们可以通过在DNS服务器IP或主机名后面添加`@`来实现这一点。在下面的例子中，我们请求`8.8.8.8`，这是谷歌公共DNS基础设施的一部分。
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Looking up DNS with nslookup
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用nslookup查找DNS
- en: Another great tool for troubleshooting DNS is `nslookup`. The `nslookup` command
    is a command that has been around for quite a while. In fact, it is yet another
    cross-platform command that exists on practically all major operating systems.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于故障排除DNS的好工具是`nslookup`。`nslookup`命令已经存在了相当长的时间。实际上，它是另一个跨平台命令，几乎存在于所有主要操作系统上。
- en: To perform a simple DNS lookup with `nslookup`, we can simply run the command
    followed by the DNS name to query, similar to `dig`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`nslookup`进行简单的DNS查找，我们只需运行命令，然后跟上要查询的DNS名称，类似于`dig`。
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Like `dig`, the `nslookup` command can be used to query a specific DNS server
    as well. This can be done via two methods. The first is by adding the server address
    at the end of the command.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`dig`命令可以用于查询特定的DNS服务器。这可以通过两种方法来实现。第一种方法是在命令的末尾添加服务器地址。'
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The second method is to use `nslookup` in the interactive mode. To go into the
    interactive mode, simply execute `nslookup` with no other options.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是在交互模式下使用`nslookup`。要进入交互模式，只需执行`nslookup`而不使用其他选项。
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once in the interactive mode, specify the server to use by entering `server
    <dns server>`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 进入交互模式后，通过输入`server <dns服务器>`来指定要使用的服务器。
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, to lookup the DNS name, we just type the domain to query.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要查找DNS名称，我们只需输入要查询的域。
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So why use `nslookup` rather than `dig`? While the `dig` command is very useful,
    it is not a cross-platform command and has only traditionally existed on Unix
    and Linux systems. The `nslookup` command on the other hand is cross-platform
    and can be found in most environments where the `dig` command may be unavailable.
    It is important as a systems administrator to be familiar with many commands,
    and it is very useful to be able to perform a task using whichever command is
    available.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么使用`nslookup`而不是`dig`呢？虽然`dig`命令非常有用，但它不是一个跨平台命令，通常只存在于Unix和Linux系统上。另一方面，`nslookup`命令是跨平台的，可以在大多数环境中找到，而`dig`命令可能不可用。作为系统管理员，熟悉许多命令是很重要的，能够使用任何可用的命令来执行任务是非常有用的。
- en: What did dig and nslookup tell us?
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`dig`和`nslookup`告诉了我们什么？'
- en: Now that we have used `dig` and `nslookup` to query the DNS name `db.example.com`,
    let's review what we have found.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用`dig`和`nslookup`来查询DNS名称`db.example.com`，让我们回顾一下我们找到了什么。
- en: The domain `db.example.com` actually resolves to `10.0.0.50`
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域`db.example.com`实际上解析为`10.0.0.50`
- en: The `ping` command returned `192.168.33.12` for the domain `db.example.com`
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ping`命令返回了域`db.example.com`的`192.168.33.12`地址。'
- en: How is the `ping` command returning one address while DNS returns another? One
    possibility is a configuration in the `/etc/hosts` file. This is something that
    we can validate very quickly with a simple `grep` command.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`ping`命令返回一个地址，而DNS返回另一个地址，这是怎么回事？一个可能的原因是`/etc/hosts`文件中的配置。这是我们可以用简单的`grep`命令快速验证的事情。'
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: A bit about /etc/hosts
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关于`/etc/hosts`的一点说明
- en: Before DNS servers such as **Bind** were created, local `hosts` files were used
    to manage the domain-to-IP mappings. This file contained a list of every domain
    address that the system needed to connect to. However, over time, this method
    became complicated as networks grew from a few hosts to thousands and millions
    of hosts.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建诸如**Bind**这样的DNS服务器之前，本地的`hosts`文件被用来管理域名到IP的映射。这个文件包含了系统需要连接的每个域地址的列表。然而，随着网络从几个主机发展到成千上万甚至数百万个主机，这种方法随着时间的推移变得复杂起来。
- en: On Linux and most Unix distributions, the `hosts` file is located at `/etc/hosts`.
    By default, any entry in the `/etc/hosts` file will supersede DNS requests. This
    means that, by default, if there is a domain-to-IP mapping in the `/etc/hosts`
    file, this mapping will be used and the system will not pull the same domain from
    another DNS system.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux和大多数Unix发行版中，“hosts”文件位于“/etc/hosts”。默认情况下，“/etc/hosts”文件中的任何条目都将覆盖DNS请求。这意味着，默认情况下，如果“/etc/hosts”文件中存在域到IP的映射，系统将使用该映射，而不会从另一个DNS系统中获取相同的域。
- en: This is the default behavior for Linux; however, we can check whether this server
    is using this default configuration by reading the `/etc/nsswitch.conf` file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Linux的默认行为；但是，我们可以通过阅读“/etc/nsswitch.conf”文件来检查该服务器是否使用此默认配置。
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `nsswitch.conf` file is a configuration that allows administrators to configure
    which backend systems to use in order to look up items such as users, groups,
    netgroups, hostnames, and services. For example, if we wanted to configure a system
    to use `ldap` to look up user groups, we could do that by changing the values
    in the `/etc/nsswitch.conf` file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: “nsswitch.conf”文件是一个允许管理员配置要使用哪些后端系统来查找用户、组、网络组、主机名和服务等项目的配置。例如，如果我们想要配置系统使用“ldap”来查找用户组，我们可以通过更改“/etc/nsswitch.conf”文件中的值来实现。
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Based on the output of the preceding `grep` command, the blog system is configured
    to use local group files and then the SSSD service to look up user groups. To
    add `ldap` to this configuration, simply add it to the list in the order desired
    (that is, `ldap files sss`).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面“grep”命令的输出，博客系统配置为首先使用本地组文件，然后使用SSSD服务来查找用户组。要将“ldap”添加到此配置中，只需按所需顺序（即“ldap文件sss”）将其添加到列表中。
- en: For the DNS that is specified by the `hosts` configuration, it appears that
    our server is configured to look up hosts first on the basis of files and then
    the DNS. This means that our system will honor the `/etc/hosts` file before looking
    up a domain via DNS.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于由“hosts”配置指定的DNS，似乎我们的服务器配置为首先基于文件查找主机，然后再查找DNS。这意味着我们的系统会在通过DNS查找域之前优先使用“/etc/hosts”文件。
- en: DNS summary
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DNS总结
- en: Now that we have confirmed both DNS and the `/etc/hosts` file, we know that
    someone has configured this application server to think `db.example.com` resolves
    to `192.168.33.12`. Was this a mistake or is this a way to connect to the database
    server without using DNS?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确认了DNS和“/etc/hosts”文件，我们知道有人配置了此应用服务器，使其认为“db.example.com”解析为“192.168.33.12”。这是一个错误还是一种在不使用DNS的情况下连接到数据库服务器的方式？
- en: At this point, it is a bit too early to tell, but we do know that the host `192.168.33.12`
    did not send an `ICMP echo reply` to our `ICMP echo request` from the blog server.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，现在还为时过早，但我们知道主机“192.168.33.12”没有向我们的博客服务器发送“ICMP回显应答”来响应我们的“ICMP回显请求”。
- en: Pinging from another location
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从另一个位置进行ping
- en: Whenever dealing with network issues, it is always best to try the connection
    from multiple locations or servers. This may seem like something obvious to the
    data collector type of troubleshooter, but the educated guesser troubleshooter
    may overlook this extremely helpful step.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理网络问题时，最好尝试从多个位置或服务器进行连接。这对于数据收集类型的故障排除者可能似乎是显而易见的，但是受过教育的猜测型故障排除者可能会忽视这一极其有用的步骤。
- en: For our example, we will run a test `ping` from our laptop to `192.168.33.12`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将从笔记本电脑运行一个测试“ping”到“192.168.33.12”。
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: From the results of the `ping` request, it seems that our laptop is able to
    connect to `192.168.33.12` without any issue.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从“ping”请求的结果来看，我们的笔记本电脑似乎能够无问题地连接到“192.168.33.12”。
- en: What does this tell us? Quite a bit actually! It tells us that the server in
    question is up; it also confirms that there is a connectivity issue, specifically
    between `blog.example.com` and `db.example.com`. If the issue were due to the
    `db.example.com` server being down or misconfigured, our laptop would also be
    impacted.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们什么？实际上告诉我们很多！它告诉我们所讨论的服务器正在运行；它还确认了存在连接问题，特别是在“blog.example.com”和“db.example.com”之间。如果问题是由于“db.example.com”服务器宕机或配置错误引起的，我们的笔记本电脑也会受到影响。
- en: However that is not the case. It is actually quite the opposite; it seems that
    connectivity from our laptop to the server works as expected.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而事实并非如此。实际上恰恰相反；似乎我们的笔记本电脑与服务器之间的连接正常工作。
- en: Testing port connectivity with cURL
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用cURL测试端口连接
- en: Earlier when testing the MariaDB port from our laptop with `telnet`, the `telnet`
    command was testing the server `10.0.0.50`. However, based on the `/etc/hosts`
    configuration, it seems that the desired database server is `192.168.33.12`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，当使用“telnet”从我们的笔记本电脑测试MariaDB端口时，“telnet”命令正在测试服务器“10.0.0.50”。然而，根据“/etc/hosts”配置，似乎期望的数据库服务器是“192.168.33.12”。
- en: To verify that the database service is actually up, we should perform the same
    `telnet` test with the `192.168.33.12` address. However, this time rather than
    using `telnet`, we will perform this test with `curl`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证数据库服务实际上是否正常运行，我们应该使用“192.168.33.12”地址执行相同的“telnet”测试。但是，这一次我们将使用“curl”而不是“telnet”来执行此测试。
- en: I have seen many environments (especially lately) where installing the `telnet`
    client is forbidden or not performed by default. For environments such as these,
    it is important to have some tool that can test port connectivity. If telnet is
    not available, the `curl` command can be used as an alternative.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我见过许多环境（尤其是最近）禁止安装“telnet”客户端或默认情况下不执行安装。对于这样的环境，有一些可以测试端口连接的工具是很重要的。如果telnet不可用，可以使用“curl”命令作为替代。
- en: In [Chapter 3](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 3. Troubleshooting a Web Application"), *Troubleshooting a Web Application*,
    we used the `curl` command to request a web page. The `curl` command can actually
    be used with many different protocols; the protocol that we are interested in
    for this case is the Telnet protocol.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0022_split_000.html#KVCC1-8ae10833f0c4428b9e1482c7fee089b4 "第3章。故障排除Web应用程序")中，“故障排除Web应用程序”，我们使用“curl”命令请求网页。实际上，“curl”命令可以与许多不同的协议一起使用；我们在这种情况下感兴趣的协议是Telnet协议。
- en: The following is an example of using `curl` from our laptop to establish a connection
    to the `db.example.com` server over port `3306`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`curl`从我们的笔记本连接到`db.example.com`服务器的端口`3306`的示例。
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: From the example, it seems that not only was the laptop able to connect to the
    server on port `3306`, but the `curl` command also received a message from the
    `RCVD IAC 106` service.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例中，似乎不仅笔记本能够连接到端口`3306`的服务器，而且`curl`命令还收到了来自`RCVD IAC 106`服务的消息。
- en: When using `curl` for Telnet tests, it is necessary to use the `–v` (verbose)
    flag to put curl into the verbose mode. Without the verbose flag, `curl` will
    simply hide the connectivity details, and the connectivity details are exactly
    what we are looking for.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行Telnet测试时，使用`curl`时，需要使用`-v`（详细）标志将curl置于详细模式。没有详细标志，`curl`将简单地隐藏连接细节，而连接细节正是我们要寻找的。
- en: In the previous example, we can see that the connection from our laptop was
    successful; for comparison, we can use this same command to test connectivity
    from the blog server.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以看到从我们的笔记本成功连接；为了进行比较，我们可以使用相同的命令从博客服务器测试连接。
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As expected, the connection attempt failed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 连接尝试失败，正如预期的那样。
- en: From the above tests with `curl`, we can determine that the database server
    is listening and accepting connections on port `3306`; however, the blog server
    cannot connect to the database server. What we don't know is if the issue is on
    the blog server's side or on the database server's side. To identify which side
    of the connection is having an issue, we will need to look at the details of the
    network connections. To do this, we will use two commands, the first being `netstat`
    and the second being `tcpdump`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面使用`curl`的测试中，我们可以确定数据库服务器正在监听并接受端口`3306`上的连接；但是，博客服务器无法连接到数据库服务器。我们不知道的是问题是在博客服务器端还是在数据库服务器端。要确定连接的哪一端存在问题，我们需要查看网络连接的详细信息。为此，我们将使用两个命令，第一个是`netstat`，第二个是`tcpdump`。
- en: Showing current network connections with netstat
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用netstat显示当前网络连接
- en: The `netstat` command is a very extensive tool and can be used to troubleshoot
    many aspects of network issues. In this case, we will use two of the basic flags
    to print the existing network connections.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`netstat`命令是一个非常全面的工具，可以用于排除网络问题的许多方面。在这种情况下，我们将使用两个基本标志来打印现有的网络连接。'
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, we executed the `netstat` command with the `–n` (no
    dns) flag, which tells `netstat` to not look up the DNS hostname of the IPs or
    translate port numbers to service names, and the `–a` (all) flag that tells `netstat`
    to print both listening and non-listening sockets.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了`-n`（无dns）标志执行了`netstat`命令，告诉`netstat`不要查找IP的DNS主机名或将端口号转换为服务名称，以及`-a`（全部）标志，告诉`netstat`打印监听和非监听套接字。
- en: These flags have the effect of `netstat`, showing all network connections and
    ports that are bound by applications.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志的效果类似于`netstat`，显示所有应用程序绑定的所有网络连接和端口。
- en: The example `netstat` command shows quite a bit of information. To get a better
    understanding of this information, let's examine the output a little better.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 示例`netstat`命令显示了相当多的信息。为了更好地理解这些信息，让我们更仔细地检查一下输出。
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The fifth column is the **Foreign Address** or remote address. This column lists
    the remote server's IP and port. Because of the type of example that we used earlier,
    this is listed as IP `0.0.0.0` and port `*`, which is a wildcard, meaning anything.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第五列是**Foreign Address**或远程地址。此列列出了远程服务器的IP和端口。由于我们之前使用的示例类型，这被列为IP`0.0.0.0`和端口`*`，这是一个通配符，表示任何内容。
- en: The sixth column, our final column, is the **State** socket. With TCP connections,
    the state will tell us the current state of the TCP connection. For our preceding
    example, the state is listed as `LISTEN`; this tells us that the listed socket
    is used for accepting TCP connections.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第六列，我们的最后一列，是**状态**套接字。对于TCP连接，状态将告诉我们TCP连接的当前状态。对于我们之前的例子，状态列为`LISTEN`；这告诉我们列出的套接字用于接受TCP连接。
- en: If we put all of the columns together, this single line tells us that our server
    is listening for new connections on port `25` via the IP `127.0.0.1` and that
    it is for TCP-based connections.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将所有列放在一起，这一行告诉我们，我们的服务器正在通过IP`127.0.0.1`监听端口`25`上的新连接，并且这是基于TCP的连接。
- en: Using netstat to watch for new connections
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用netstat来监视新连接
- en: Now that we understand the output of `netstat` a bit more, we can use it to
    look for new connections from our application server to our database server. To
    use `netstat` to watch for new connections, we will use an often overlooked feature
    of `netstat`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对`netstat`的输出有了更多的了解，我们可以使用它来查找应用程序服务器到数据库服务器的新连接。要使用`netstat`监视新连接，我们将使用`netstat`经常被忽视的一个功能。
- en: Similar to the `vmstat` command, it is possible to put `netstat` into a continuous
    mode, which prints the same output every few seconds. To do this, simply put the
    interval at the end of the command.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与`vmstat`命令类似，可以将`netstat`置于连续模式中，每隔几秒打印相同的输出。要做到这一点，只需在命令的末尾放置间隔。
- en: In the following example, we will use the same `netstat` flags with an interval
    of `5` s; however, we will also pipe the output to `grep` and use `grep` to filter
    for port `3306`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个例子中，我们将使用相同的`netstat`标志，间隔为`5`秒；但是，我们还将将输出导向到`grep`并使用`grep`来过滤端口`3306`。
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In addition to running the `netstat` command, we also can navigate to the `blog.example.com`
    address in our browser. We can do this to force the web application to attempt
    a connection to the database.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 除了运行`netstat`命令，我们还可以在浏览器中导航到`blog.example.com`地址。我们可以这样做，以强制Web应用程序尝试连接到数据库。
- en: In general, web applications have two types of connections to a database, either
    persistent connections where they always stay connected to the database or non-persistent
    connections where they are established only when required. Since we don't know
    which type this WordPress installation uses, it is safer for this type of troubleshooting
    to assume they are non-persistent. This means that, in order to trigger database
    connections, there must be traffic to the WordPress application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，Web应用程序对数据库有两种类型的连接，一种是持久连接，它们始终保持与数据库的连接，另一种是非持久连接，只有在需要时才建立。由于我们不知道这个WordPress安装使用哪种类型，因此在这种类型的故障排除中，假设它们是非持久的更安全。这意味着，为了触发数据库连接，必须有流量到WordPress应用程序。
- en: From the output of `netstat`, we can see connection attempts to the database,
    and not just any database but the database service at `192.168.33.12`. This information
    confirms that, when the web application is attempting to establish a connection,
    it is using the IP from the `hosts` file and not from DNS. Up until this point,
    we suspected that this was the case based on `telnet` and `ping` but had no proof
    of the connection from the application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从`netstat`的输出中，我们可以看到对数据库的连接尝试，而且不仅仅是任何数据库，而是`192.168.33.12`上的数据库服务。这些信息证实，当Web应用程序尝试建立连接时，它使用的是`hosts`文件中的IP，而不是来自DNS。直到这一点，我们怀疑这是基于`telnet`和`ping`，但没有证据表明应用程序的连接。
- en: An interesting fact however is that the `netstat` output shows that the TCP
    connection is in a `SYN_SENT` state. This `SYN_SENT` state is the state used when
    first establishing a network connection. The `netstat` command can print many
    different connection states; each one tells us where in the process the connection
    is in. This information can be key to identifying the root cause of network connectivity
    issues.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有趣的事实是`netstat`输出显示TCP连接处于`SYN_SENT`状态。这个`SYN_SENT`状态是在首次建立网络连接时使用的状态。`netstat`命令可以打印许多不同的连接状态；每个状态告诉我们连接所处的过程中的位置。这些信息对于识别网络连接问题的根本原因至关重要。
- en: Breakdown of netstat states
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`netstat`状态的详细说明'
- en: 'Before going too far, we should take a quick look at the different `netstat`
    states and what they mean. The following is a full list of states used by `netstat`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究之前，我们应该快速查看一下不同的`netstat`状态及其含义。以下是`netstat`使用的所有状态的完整列表：
- en: '`ESTABLISHED`: The connection has been established and can be used for data
    transfer'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ESTABLISHED`：连接已建立，可用于数据传输'
- en: '`SYN_SENT`: The TCP socket is attempting to establish a connection to the remote
    host'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SYN_SENT`：TCP套接字正在尝试与远程主机建立连接'
- en: '`SYN_RECV`: A TCP connection request has been received from the remote host'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SYN_RECV`：已从远程主机接收到TCP连接请求'
- en: '`FIN_WAIT1`: The TCP connection is closing'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FIN_WAIT1`：TCP连接正在关闭'
- en: '`FIN_WAIT2`: The TCP connection is waiting for the remote host to close the
    connection'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FIN_WAIT2`：TCP连接正在等待远程主机关闭连接'
- en: '`TIME_WAIT`: The socket is waiting after being closed for any outstanding network
    packets'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIME_WAIT`：套接字在关闭后等待任何未完成的网络数据包'
- en: '`CLOSE`: The socket is no longer being used'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLOSE`：套接字不再被使用'
- en: '`CLOSE_WAIT`: The remote end has closed its connection, and the local socket
    is being closed'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLOSE_WAIT`：远程端已关闭其连接，本地套接字正在关闭'
- en: '`LAST_ACK`: The remote end has initiated closing the connection, and the local
    system is waiting for a final acknowledgement'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LAST_ACK`：远程端已启动关闭连接，本地系统正在等待最终确认'
- en: '`LISTEN`: The socket is being used to listen for incoming connections'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LISTEN`：套接字正在用于监听传入连接'
- en: '`CLOSING`: Both the local and the remote sockets are closed, but not all data
    has been sent'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLOSING`：本地和远程套接字都已关闭，但并非所有数据都已发送'
- en: '`UNKNOWN`: Used for sockets in an unknown state'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UNKNOWN`：用于处于未知状态的套接字'
- en: From the above list, we can determine that the connections to the database from
    the application never become `ESTABLISHED`. This means that the application server
    starts the connection in the `SYN_SENT` state, but it never transitions to the
    next state.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的列表中，我们可以确定应用程序到数据库的连接从未变为`ESTABLISHED`。这意味着应用程序服务器在`SYN_SENT`状态下开始连接，但从未转换到下一个状态。
- en: Capturing network traffic with tcpdump
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用tcpdump捕获网络流量
- en: To get a better understanding of the network traffic, we will use a second command
    that allows us to look at the network traffic details—`tcpdump`. Here, the `netstat`
    command is used to print the status of sockets; the `tcpdump` command is used
    to create "`dumps`" or "`traces`" of network traffic. These dumps allow users
    to see all aspects of the network traffic captured.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解网络流量，我们将使用第二个命令来查看网络流量的详细信息——`tcpdump`。在这里，`netstat`命令用于打印套接字的状态；`tcpdump`命令用于创建网络流量的“转储”或“跟踪”。这些转储允许用户查看捕获的网络流量的所有方面。
- en: With `tcpdump`, it is possible to look at the full TCP packet details, from
    the packet headers to the actual data being transmitted. Not only can it capture
    this data, but `tcpdump` can also write the captured data to a file. After the
    data is written to the file, it can be saved or moved and later read with the
    `tcpdump` command or other network packet analysis tools (for example, `wireshark`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`tcpdump`，可以查看完整的TCP数据包细节，从数据包头部到实际传输的数据。`tcpdump`不仅可以捕获这些数据，还可以将捕获的数据写入文件。数据写入文件后，可以保存或移动，并且稍后可以使用`tcpdump`命令或其他网络数据包分析工具（例如`wireshark`）进行读取。
- en: The following is a simple example of running `tcpdump` to capture the network
    traffic.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行`tcpdump`捕获网络流量的简单示例。
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding example, I have provided several flags to the `tcpdump` command.
    The first flag `–n` (no dns) tells `tcpdump` to not look up the hostname of any
    IPs that it finds. The rest of the flags `–vvv` (verbose) tell `tcpdump` to be
    very "very" verbose. The `tcpdump` command has three levels of verbosity; each
    `–v` that is added to the command line increases the verbosity level used. In
    the preceding example, `tcpdump` is in its most verbose mode.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我为`tcpdump`命令提供了几个标志。第一个标志`–n`（无dns）告诉`tcpdump`不要查找它找到的任何IP的主机名。其余的标志`–vvv`（详细）告诉`tcpdump`非常“非常”详细。`tcpdump`命令有三个详细级别；每个添加到命令行的`–v`都会增加使用的详细级别。在前面的示例中，`tcpdump`处于最详细的模式。
- en: The preceding example is one of the simplest ways to run `tcpdump`; however,
    it does not capture the traffic that we require.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例是运行`tcpdump`的最简单方式之一；然而，它并没有捕获我们需要的流量。
- en: Taking a look at the server's network interfaces
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看服务器的网络接口
- en: When `tcpdump` is executed on systems with multiple network interfaces, unless
    an interface is defined the command will pick the lowest numbered interface to
    attach to. In the preceding example, the interface chosen was `enp0s3`; however,
    this may not be the interface used for database connectivity.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当在具有多个网络接口的系统上执行`tcpdump`时，除非定义了接口，否则该命令将选择最低编号的接口进行连接。在前面的示例中，选择的接口是`enp0s3`；然而，这可能不是用于数据库连接的接口。
- en: Before using `tcpdump` to investigate our network connectivity issue, we first
    need to identify which network interface is used for this connectivity; to do
    this, we will use the `ip` command.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`tcpdump`来调查我们的网络连接问题之前，我们首先需要确定用于此连接的网络接口；为了做到这一点，我们将使用`ip`命令。
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: At a high level, the `ip` command allows users to print, modify, and add network
    configurations. In the example above, we are telling the `ip` command to "show"
    us all of the available "links" by using the `show links` parameters. The links
    being shown are actually the defined network interfaces for this server.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，`ip`命令允许用户打印、修改和添加网络配置。在上面的示例中，我们告诉`ip`命令通过使用`show links`参数来“显示”所有可用的“链接”。显示的链接实际上是为该服务器定义的网络接口。
- en: What is a network interface?
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 什么是网络接口？
- en: When talking about a physical server, the network interface is generally a representation
    of a physical Ethernet port. If we assume that the machine used in the preceding
    example is a physical machine, we can assume that the `enp0s3` and `enp0s8` links
    are physical devices. In reality, however, the abovementioned machine is a virtual
    machine. This means that the devices are logically attached to this virtual machine;
    the kernel of this machine however does not know or even need to know the difference.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论物理服务器时，网络接口通常是物理以太网端口的表示。如果我们假设前面示例中使用的机器是一台物理机器，我们可以假设`enp0s3`和`enp0s8`链接是物理设备。然而，实际上，上述机器是一台虚拟机。这意味着这些设备逻辑上连接到这台虚拟机；但是，这台机器的内核并不知道，甚至不需要知道这种区别。
- en: For example, in this book most interfaces, with the exception of the "`lo`"
    or loopback interface, are directly related to physical (or virtually physical)
    network devices. It is possible, however, to create virtual interfaces, which
    allows you to create multiple interfaces that link back to a single physical interface.
    In general, these interfaces are seen with a "`:`" or "`.`" as a separator from
    the original device name. If we were to make a virtual interface for `enp0s8`,
    it would look something along the lines of `enp0s8:1`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这本书中，大多数接口（除了“`lo`”或回环接口）都直接与物理（或虚拟物理）网络设备相关。然而，也有可能创建虚拟接口，这允许您创建多个接口，这些接口链接回单个物理接口。一般来说，这些接口以“`:`”或“`.`”作为原始设备名称的分隔符。如果我们要为`enp0s8`创建一个虚拟接口，它看起来会像`enp0s8:1`。
- en: Viewing device configuration
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查看设备配置
- en: From the `ip` command's output, we can see that there are three network interfaces
    defined. Before knowing which one is used for our database connectivity, we will
    first need to understand these interfaces better.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ip`命令的输出中，我们可以看到有三个定义的网络接口。在了解哪个接口用于我们的数据库连接之前，我们首先需要更好地了解这些接口。
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `lo` or loopback interface is the first one in the list. Anyone who has
    worked on Linux or Unix long enough will be very familiar with loopback interfaces.
    The loopback interface is designed to give users of the system a local network
    address that can only be used to connect back to the local system.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`lo`或回环接口是列表中的第一个。在Linux或Unix上工作了足够长时间的人都会对回环接口非常熟悉。回环接口旨在为系统的用户提供一个本地网络地址，只能用于连接回本地系统。'
- en: This special interface allows applications located on the same server to interact
    via TCP/IP without having to expose their connectivity externally to the wider
    network. It also allows these applications to interact without a network packet
    leaving the local server, thus making it a very fast networking connection.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特殊的接口允许位于同一台服务器上的应用程序通过TCP/IP进行交互，而无需将其连接外部网络。它还允许这些应用程序在没有网络数据包离开本地服务器的情况下进行交互，从而使其成为非常快速的网络连接。
- en: Traditionally, the loopback interface IP is well known as `127.0.0.1`. However,
    just like everything else in this book, we will first validate this information
    before assuming it to be true. We can do this by using the `ip` command to show
    the loopback interface's defined address.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，回环接口IP的已知地址是`127.0.0.1`。然而，就像本书中的其他内容一样，我们将在假设其为真之前先验证这些信息。我们可以使用`ip`命令来显示回环接口的定义地址来做到这一点。
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the previous example that shows available interfaces, the "`link show`" options
    were used; in order to show IP addresses, the "`addr show`" options can be used.
    The syntax for the `ip` command to print items follows this same scheme throughout.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示可用接口的前面示例中，使用了“`link show`”选项；为了显示IP地址，可以使用“`addr show`”选项。`ip`命令打印项目的语法在整个过程中都遵循这个相同的方案。
- en: The preceding example also specifies the name of the device we are interested
    in; this limits the output to the specified device. If we were to omit the device
    name from the preceding command, it would simply print the IP addresses for all
    devices.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子还指定了我们感兴趣的设备的名称；这限制了输出到指定的设备。如果我们在前面的命令中省略设备名称，它将简单地打印出所有设备的IP地址。
- en: So, what does the above tell us about the lo interface? Well one thing that
    it tells us is that the `lo` interface is listening on the IPv4 address of 127.0.0.1;
    we can see this on the following line.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，上面的内容告诉我们关于lo接口的什么呢？其中一件事是，`lo`接口正在监听IPv4地址`127.0.0.1`；我们可以在下一行看到这一点。
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This means that, if we want to connect to this host via the loopback interface,
    we can do so by targeting `127.0.0.1`. The `ip` command, however, also shows a
    second IP defined on this interface.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果我们想通过环回接口连接到这个主机，我们可以通过定位`127.0.0.1`来实现。然而，`ip`命令还显示了在这个接口上定义的第二个IP。
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This shows us that the IPv6 address of `::1` is also bound to the lo interface.
    This address serves the same purpose as `127.0.0.1`, but it is designed for `IPv6`
    communication.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们`::1`的IPv6地址也绑定到了lo接口。这个地址用于相同的目的作为`127.0.0.1`，但它是为`IPv6`通信设计的。
- en: With the above information from the `ip` command, we can see that the `lo` or
    loopback interface is defined as expected.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ip`命令提供的上述信息，我们可以看到`lo`或环回接口被按预期定义。
- en: The second interface defined on this server is `enp0s3`; this device, unlike
    lo, is either a physical device or a virtualized physical interface. The `ip`
    link show command executed earlier has already told us quite a bit about this
    interface.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这台服务器上定义的第二个接口是`enp0s3`；这个设备，不像lo，要么是一个物理设备，要么是一个虚拟化的物理接口。之前执行的`ip` link show命令已经告诉我们关于这个接口的很多信息。
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: From this information, we know that the interface is up and able to be utilized.
    We also know that the MTU size is set to the default of 1500, and we can easily
    identify the MAC address. While the MTU size and the MAC address may not be extremely
    pertinent to this issue, they can be very useful in other situations.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些信息中，我们知道接口已经启动并且可以被利用。我们还知道MTU大小设置为默认的1500，并且可以轻松地识别MAC地址。虽然MTU大小和MAC地址可能与这个问题无关，但在其他情况下它们可能非常有用。
- en: However, for our current task of identifying which interface is used for database
    connectivity, we will need to identify which IPs are bound to this interface.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于我们当前的任务，即确定用于数据库连接的接口，我们需要确定绑定到这个接口的IP是哪些。
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: From the preceding output, we can see that the `enp0s3` interface is listening
    to the IPv4 IP of `10.0.2.15` (`inet 10.0.2.15/24`) as well as the IPv6 IP of
    `f380::a00:27ff:fe20:5d4b` (`inet6 fe80::a00:27ff:fe20:5d4b/64`). Does this tell
    us that connections to `192.168.33.12` go through this interface? No, but it also
    doesn't mean that they don't.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到`enp0s3`接口正在监听IPv4 IP `10.0.2.15`（`inet 10.0.2.15/24`）以及IPv6 IP
    `f380::a00:27ff:fe20:5d4b`（`inet6 fe80::a00:27ff:fe20:5d4b/64`）。这是否告诉我们连接到`192.168.33.12`是通过这个接口？不，但也不意味着不是。
- en: What this does tell us is that the `enp0s3` interface is used to connect to
    the `10.0.2.15/24` network. This network may or may not be able to route to the
    address of `192.168.33.12`; before making this determination, we should first
    review the next interface's configuration.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们`enp0s3`接口被用于连接到`10.0.2.15/24`网络。这个网络可能能够路由到`192.168.33.12`的地址；在做出这个决定之前，我们应该首先审查下一个接口的配置。
- en: The third interface on this system is `enp0s8`; it is also a physical or virtual
    network device, and from the information provided by the `ip` link show command,
    we can see that it has a similar configuration to `enp0s3`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统上的第三个接口是`enp0s8`；它也是一个物理或虚拟网络设备，从`ip` link show命令提供的信息中，我们可以看到它与`enp0s3`有类似的配置。
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: From this output, we can see that the interface of `enp0s8` is also in an "`UP`"
    state and has the default MTU size of 1500\. We can also determine the MAC address
    of this interface, which at this time is not specifically required; however, it
    may become useful later.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个输出中，我们可以看到`enp0s8`接口也处于“UP”状态，并且具有默认的MTU大小为1500。我们还可以确定这个接口的MAC地址，这在这个时候并不是特别需要；然而，以后可能会变得有用。
- en: If we look at the IPs defined on this server, however, there is a significant
    difference from those of the `enp0s3` device.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们看一下在这台服务器上定义的IP，与`enp0s3`设备相比，有一个显著的不同。
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can see that the `enp0s8` interface is listening on the IPv4 address of `192.168.33.11`
    (`inet 192.168.33.11/24`) and the IPv6 address of `fe80::a00:27ff:fe7f:fd54` (`inet6
    fe80::a00:27ff:fe7f:fd54/64`).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`enp0s8`接口正在监听IPv4地址`192.168.33.11`（`inet 192.168.33.11/24`）和IPv6地址`fe80::a00:27ff:fe7f:fd54`（`inet6
    fe80::a00:27ff:fe7f:fd54/64`）。
- en: Does this mean that the `enp0s8` interface is used to connect to `192.168.33.12`?
    Well, actually, it may.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着`enp0s8`接口被用于连接到`192.168.33.12`？实际上，可能是的。
- en: The subnet defined for `enp0s8` is `192.168.33.11/24`, which means that this
    interface is connected to a network of devices that span the IP range of `192.168.33.0`
    to `192.168.33.255`. Since the database server's `IP 192.168.33.12` is within
    this range, it is very likely that the communication to this address is over the
    `enp0s8` interface.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`enp0s8`定义的子网是`192.168.33.11/24`，这意味着这个接口连接到一个跨越`192.168.33.0`到`192.168.33.255`的IP范围的设备网络。由于数据库服务器的`IP
    192.168.33.12`在这个范围内，很可能是通过`enp0s8`接口进行与这个地址的通信。'
- en: At this point, we can "suspect" that the interface of `enp0s8` is used for communication
    to the database server. While this interface may be configured to talk to the
    subnet that contains `192.168.33.12`, it is entirely possible to force communication
    through another interface by using defined routes.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以“怀疑”`enp0s8`接口被用于与数据库服务器进行通信。虽然这个接口可能被配置为与包含`192.168.33.12`的子网进行通信，但完全有可能通过使用定义的路由强制通过另一个接口进行通信。
- en: To check whether there is a route defined and forcing communication out through
    another interface, we will again use the `ip` command. For this task, however,
    we will use the "`route get`" options for the `ip` command.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查是否定义了路由并强制通过另一个接口进行通信，我们将再次使用`ip`命令。然而，对于这个任务，我们将使用`ip`命令的“`route get`”选项。
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When executed with the "`route get`" arguments, the `ip` command will specifically
    output which interface is used to route to the specified IP.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用“`route get`”参数执行时，`ip`命令将特别输出用于路由到指定IP的接口。
- en: From the preceding output, we can see that the `blog.example.com` server is
    in fact using the `enp0s8` interface to route to the 192.168.33.12 address, the
    IP of `db.example.com`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到`blog.example.com`服务器实际上是使用`enp0s8`接口路由到192.168.33.12地址，即`db.example.com`的IP。
- en: At this point, not only have we used the `ip` command to determine what network
    interfaces exist on this server, but we have also used it to determine which interface
    a network packet would take to get to our target host.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们不仅使用`ip`命令确定了这台服务器上存在哪些网络接口，还使用它确定了网络数据包到达目标主机所需的接口。
- en: The `ip` command is a very useful tool and has recently been slated to replace
    older commands such as `ifconfig` and `route`. If you are generally familiar with
    using commands such as `ifconfig` but not as familiar with the `ip` command, it
    is a good idea to review the usage covered above, as eventually, the `ifconfig`
    command will be deprecated.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip`命令是一个非常有用的工具，最近被计划用来替代诸如`ifconfig`和`route`之类的旧命令。如果你通常熟悉使用`ifconfig`等命令，但对`ip`命令不太熟悉，那么建议你回顾一下上面介绍的用法，因为最终`ifconfig`命令将被弃用。'
- en: Specifying the interface with tcpdump
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定tcpdump的接口
- en: Now that we have identified the interface used for communication with `db.example.com`
    we can start our network trace by using `tcpdump`. As mentioned earlier, we will
    use the -`nvvv` flags to put `tcpdump` in the very "very" verbose mode without
    hostname resolution. This time, however, we will specify that `tcpdump` captures
    network traffic from the `enp0s8` interface; we can do this with the `-i` (interface)
    flag. We will also use the `-w` (write) flag to write the captured data to a file.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了与`db.example.com`通信所使用的接口，我们可以通过使用`tcpdump`开始我们的网络跟踪。如前所述，我们将使用`-nvvv`标志将`tcpdump`置于非常“非常”详细的模式，而不进行主机名解析。然而，这一次，我们将指定`tcpdump`从`enp0s8`接口捕获网络流量；我们可以使用`-i`（接口）标志来实现这一点。我们还将使用`-w`（写入）标志将捕获的数据写入文件。
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When we first executed the `tcpdump` command, we received quite a bit of output
    to the screen. When told to save its output to a file, `tcpdump` will not output
    the captured data to the screen but rather continuously show a counter of captured
    packets.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次执行`tcpdump`命令时，屏幕上输出了相当多的内容。当要求将其输出保存到文件时，`tcpdump`不会将捕获的数据输出到屏幕上，而是会持续显示捕获的数据包的计数器。
- en: 'Once we have `tcpdump` saving its captured data to a file, we need to duplicate
    the issue to try to generate database traffic. We will do this by using the same
    method as we did with the `netstat` command: by simply navigating to `blog.example.com`
    in a web browser.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们让`tcpdump`将捕获的数据保存到文件中，我们需要复制问题以尝试生成数据库流量。我们将通过与`netstat`命令相同的方法来实现这一点：简单地在Web浏览器中导航到`blog.example.com`。
- en: 'As we navigate to the WordPress site, we should see the `packets captured`
    counter increasing; this indicates that `tcpdump` has seen traffic and has captured
    it. Once the counter reaches a reasonable number, we can stop the `tcpdump` capture.
    To do this, simply press *Ctrl* + *C* on the command line; once stopped, we should
    see a message similar to the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们导航到WordPress网站时，我们应该看到`捕获的数据包`计数器在增加；这表明`tcpdump`已经看到了流量并进行了捕获。一旦计数器达到一个合理的数字，我们就可以停止`tcpdump`的捕获。要做到这一点，只需在命令行上按下*Ctrl*
    + *C*；一旦停止，我们应该看到类似以下的消息：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Reading the captured data
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取捕获的数据
- en: Now that we have the captured the `network trace` saved to a file, we can use
    this file to investigate the database traffic. The benefit of having this data
    saved within a file is that we can read this data multiple times and iterate through
    filters to reduce the output. Further, when running `tcpdump` against the live
    network stream, we may catch traffic once but never again.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将捕获的`网络跟踪`保存到文件中，我们可以使用这个文件来调查数据库流量。将这些数据保存在文件中的好处是我们可以多次读取这些数据，并通过过滤器来减少输出。此外，当对实时网络流进行`tcpdump`时，我们可能只能捕获一次流量，再也捕获不到了。
- en: In order to read the saved data, we can run `tcpdump` with the `–r` (read) flag
    followed by the filename to read.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取保存的数据，我们可以使用`-r`（读取）标志后跟要读取的文件名来运行`tcpdump`。
- en: We could start by using the following command to print the packet header information
    for all `48` packets that we captured.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用以下命令打印我们捕获的所有`48`个数据包的数据包头信息来开始。
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The output of this command, however, can be quite overwhelming; to get to the
    heart of the issue, we will need to narrow down the output of `tcpdump`. To do
    this, we will use tcpdump's ability to apply filters to the captured data. In
    particular, we will be filtering the output to a specific IP address by using
    the "`host`" filter.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个命令的输出可能会让人感到不知所措；为了找到问题的核心，我们需要缩小`tcpdump`的输出范围。为此，我们将使用tcpdump的过滤器功能来对捕获的数据进行过滤。特别是，我们将使用“host”过滤器将输出过滤到特定的IP地址。
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: By adding `host 192.168.33.12` to the end of the `tcpdump` command, the output
    is filtered to traffic that only relates to the host 192.168.33.12\. This is made
    possible by the `host` filter. The `tcpdump` command has many available filters;
    however, in this chapter, we will mainly utilize the host filter. I would strongly
    suggest becoming familiar with `tcpdump` filters for anyone troubleshooting network
    issues regularly.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`tcpdump`命令的末尾添加`host 192.168.33.12`，输出被过滤为只与主机192.168.33.12相关的流量。这是通过`host`过滤器实现的。`tcpdump`命令有许多可用的过滤器；然而，在本章中，我们主要将利用主机过滤器。我强烈建议经常解决网络问题的人熟悉`tcpdump`过滤器。
- en: When running `tcpdump` (in the same fashion as above), it is important to know
    that each line is a packet being either sent or received through the specified
    interface. The below example is one complete `tcpdump` line, which is essentially
    one packet that has passed through the `enp0s8` interface.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`tcpdump`（与上面类似）时，重要的是要知道每一行都是通过指定接口发送或接收的一个数据包。下面的例子是一个完整的`tcpdump`行，本质上是通过`enp0s8`接口传递的一个数据包。
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we take a look at the preceding line, we can see that this packet is being
    sent from `192.168.33.11` to `192.168.33.12`. We can see this from the following
    section:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下前面的行，我们可以看到这个数据包是从`192.168.33.11`发送到`192.168.33.12`的。我们可以从以下部分看到这一点：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The fact that this packet is a `SYN` packet actually tells us quite a bit about
    the packet.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据包是一个`SYN`数据包实际上告诉了我们关于这个数据包的很多信息。
- en: A quick primer on TCP
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于TCP的快速入门
- en: '**Transmission Control Protocol** (**TCP**) is one of the most utilized protocols
    for Internet-based communications. It is the protocol of choice for many of the
    services that we rely on every day. From the HTTP protocol for loading web pages
    to the favorite of all Linux systems administrators, `SSH`, these protocols are
    implemented on top of the TCP protocol.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输控制协议**（**TCP**）是互联网通信中最常用的协议之一。它是我们每天依赖的许多服务的选择协议。从用于加载网页的HTTP协议到所有Linux系统管理员最喜欢的`SSH`，这些协议都是在TCP协议之上实现的。'
- en: While TCP is highly used, it is also a rather advanced topic, a topic that every
    systems administrator should have at least a basic understanding of. In this section,
    we are going to quickly cover some TCP basics; this will by no means be an extensive
    guide but is just enough to understand the root of our issue.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然TCP被广泛使用，但它也是一个相当高级的话题，每个系统管理员都应该至少有基本的了解。在本节中，我们将快速介绍一些TCP基础知识；这绝不是一个详尽的指南，但足以理解我们问题的根源。
- en: To understand our issue, we must first understand how TCP connections are established.
    With TCP communications, there are generally two important parties, namely the
    client and the server. The client is the initiator of the connection and will
    send a `SYN` packet as the first step to establishing a TCP connection.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解我们的问题，我们必须首先了解TCP连接是如何建立的。在TCP通信中，通常有两个重要的参与方，即客户端和服务器。客户端是连接的发起者，并将发送一个`SYN`数据包作为建立TCP连接的第一步。
- en: When the server receives a `SYN` packet and is willing to accept the connection,
    it will send a **Synchronize Acknowledgement** (**SYN-ACK**) packet back to the
    client. This is designed for the server to acknowledge that it has received the
    original `SYN` packet.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器接收到一个`SYN`数据包并愿意接受连接时，它会向客户端发送一个**同步确认**（**SYN-ACK**）数据包。这是为了让服务器确认它已经收到了原始的`SYN`数据包。
- en: When the client receives this `SYN-ACK` packet, it then replies to the server
    with an `ACK`, sometimes referred to as a `SYN-ACK-ACK`. The idea behind this
    packet is for the client to acknowledge that it has received the server's acknowledgement.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端接收到这个`SYN-ACK`数据包时，它会回复服务器一个`ACK`，有时也称为`SYN-ACK-ACK`。这个数据包的想法是让客户端确认它已经收到了服务器的确认。
- en: This process is known as the *Three-Way Handshake* and is the foundation of
    TCP. The benefit of this method is that, with each system acknowledging the packets
    that it receives, there is no question as to whether the client and the server
    are able to communicate back and forth. Once a three-way handshake has been performed,
    the connection is moved to an established state. This is where other types of
    packets can be used, such as **Push** (**PSH**) packets, which are used to transfer
    information from the client to the server or vice versa.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程被称为*三次握手*，是TCP的基础。这种方法的好处是，每个系统都确认它接收到的数据包，因此不会有关于客户端和服务器是否能够来回通信的问题。一旦进行了三次握手，连接就会转移到已建立的状态。在这种状态下可以使用其他类型的数据包，比如**推送**（**PSH**）数据包，用于在客户端和服务器之间传输信息。
- en: Types of TCP packet
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TCP数据包的类型
- en: Speaking of additional types of packets, it is important to know that the component
    that defines whether a packet is a `SYN` packet or an `ACK` packet is simply a
    flag being set in the packet header.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 说到其他类型的数据包，重要的是要知道确定一个数据包是`SYN`数据包还是`ACK`数据包的组件只是在数据包头中设置一个标志。
- en: On the first packet from our captured data, only the `SYN` flag is set; this
    is why we will see output such as `Flags [S]`. This is an example of the first
    packet being sent and that packet having only the `SYN` flag set.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们捕获的数据的第一个数据包上，只有`SYN`标志被设置；这就是为什么我们会看到输出如`Flags [S]`的原因。这是第一个数据包被发送并且该数据包只有`SYN`标志被设置的一个例子。
- en: An `SYN-ACK` packet is a packet where the `SYN` and the `ACK` flags are set.
    This is commonly seen as `[S.]` in `tcpdump`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`SYN-ACK`数据包是一个`SYN`和`ACK`标志被设置的数据包。这通常在`tcpdump`中看到的是`[S.]`。
- en: The following is a table of packet flags commonly seen during troubleshooting
    activities with `tcpdump`. This is by no means a full list, but it does give a
    general idea of the common packet types.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在使用`tcpdump`进行故障排除活动中常见的数据包标志的表格。这绝不是一个完整的列表，但它确实给出了常见数据包类型的一个大致概念。
- en: '`SYN- [S]`: This is a Synchronize packet, the first packet sent from the client
    to the server.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SYN- [S]`：这是一个同步数据包，从客户端发送到服务器的第一个数据包。'
- en: '`SYN-ACK- [S.]`: This is a Synchronize Acknowledgement packet; these packet
    flags are used to indicate that the server received the client''s `SYN` requests.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SYN-ACK- [S.]`：这是一个同步确认数据包；这些数据包标志用于指示服务器接收到客户端的`SYN`请求。'
- en: '`ACK- [.]`: The Acknowledgement packet is used by both the server and the client
    to acknowledge the received packets. After the initial `SYN` packet is sent, all
    subsequent packets should have the acknowledgement flag set.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACK- [.]`：确认数据包被服务器和客户端用来确认接收到的数据包。在初始的`SYN`数据包发送后，所有后续的数据包都应该设置确认标志。'
- en: '`PSH- [P]`: This is a Push packet. It is designed to push the buffered network
    data to the receiver. This is the type of packet where data is actually transferred.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSH- [P]`: 这是一个推送数据包。它旨在将缓冲的网络数据推送到接收方。这是实际传输数据的数据包类型。'
- en: '`PSH-ACK- [P.]`: The Push Acknowledgement packet is used to both acknowledge
    a previous packet and send data to the recipient.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PSH-ACK- [P.]`: 推送确认数据包用于确认先前的数据包并向接收方发送数据。'
- en: '`FIN- [F]`: The `FIN` or Finish packet is used to tell the server that there
    is no more data and that it can close the established connection.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FIN- [F]`: `FIN`或完成数据包用于告诉服务器没有更多数据，可以关闭已建立的连接。'
- en: '`FIN-ACK- [F.]`: The Finish Acknowledgement packet is used to acknowledge that
    the previous Finish packet was received.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FIN-ACK- [F.]`: 完成确认数据包用于确认先前的完成数据包已被接收。'
- en: '`RST- [R]`: The Reset packet is used when the source system wishes to Reset
    the connection. In general, this is due to an error or the target port is not
    actually in the listening status.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RST- [R]`: 重置数据包用于源系统希望重置连接时使用。一般来说，这是由于错误或目标端口实际上不处于监听状态。'
- en: '`RST-ACK -[R.]`: The Reset Acknowledgement packet is used to acknowledge that
    the previous Reset packet was received.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RST-ACK -[R.]`: 重置确认数据包用于确认先前的重置数据包已被接收。'
- en: Now that we have explored the different types of packets, let's tie it all together
    and take a quick look back at the data captured earlier.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了不同类型的数据包，让我们把它们联系起来，快速回顾一下之前捕获的数据。
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If we break down these three packets, we can see that all three of them are
    from the source port of `37785`, targeting the destination port of 3306\. We can
    also see that these packets are `SYN` packets. What this means is that our system
    sent 3 `SYN` packets and never received an `SYN-ACK` from the destination, in
    this case `192.168.33.12`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分解这三个数据包，我们可以看到它们都来自源端口`37785`，目标端口为3306。我们还可以看到这些数据包是`SYN`数据包。这意味着我们的系统发送了3个`SYN`数据包，但从目标端口，即`192.168.33.12`，没有收到`SYN-ACK`。
- en: What does this tell us about our network connectivity to the host `192.168.33.12`?
    It tells us that either the remote server `192.168.33.12` is never receiving our
    packets or it is receiving them and we are never able to receive the `SYN-ACK`
    replies. If the issue were due to the database server not accepting our packet,
    we would expect to see an `RST` or `Reset` packet.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们关于与主机`192.168.33.12`的网络连接的什么？它告诉我们要么远程服务器`192.168.33.12`从未收到我们的数据包，要么它收到了并且我们从未能收到`SYN-ACK`回复。如果问题是由于数据库服务器不接受我们的数据包，我们将期望看到一个`RST`或`重置`数据包。
- en: Reviewing collected data
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审查收集的数据
- en: At this point, it is a good time to take an inventory of what information we
    have collected and what we know so far.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，现在是时候盘点我们收集的信息和我们目前所知的信息了。
- en: The first bit of key information that we have identified is that the blog server
    (`blog.example.com`) is unable to connect to the database server (`db.example.com`).
    The second bit of key information that we have identified is that the DNS name
    `db.example.com` resolves to `10.0.0.50`. However, there is also an `/etc/hosts`
    file entry overriding DNS on the `blog.example.com` server. Because of the hosts
    file, when the web application tries to connect to `db.example.com`, it is connecting
    to `192.168.33.12`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定的第一条关键信息是博客服务器（`blog.example.com`）无法连接到数据库服务器（`db.example.com`）。我们已经确定的第二条关键信息是DNS名称`db.example.com`解析为`10.0.0.50`。但是，在`blog.example.com`服务器上还有一个`/etc/hosts`文件条目覆盖了DNS。由于hosts文件，当Web应用程序尝试连接到`db.example.com`时，它实际上连接到了`192.168.33.12`。
- en: We have also identified that the host `192.168.33.11` (`blog.example.com`) is
    sending the initial `SYN` packets to `192.168.33.12` when the WordPress application
    is accessed. However, the server `192.168.33.12` is either not receiving or not
    replying to these packets.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还确定了主机`192.168.33.11`（`blog.example.com`）在访问WordPress应用程序时向`192.168.33.12`发送初始的`SYN`数据包。然而，服务器`192.168.33.12`要么没有接收到这些数据包，要么没有回复这些数据包。
- en: Throughout our investigation, we reviewed the blog server's network configuration
    and we determined that it appears to be set up correctly. We can perform additional
    validation of this by simply using the ping command to send an ICMP echo to an
    IP within each network interface's subnet.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的调查过程中，我们审查了博客服务器的网络配置，并确定它似乎已正确设置。我们可以通过简单使用ping命令向每个网络接口的子网内的IP发送ICMP回显来对此进行额外验证。
- en: '[PRE50]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: For the `enp0s3` interface, we can see that the IP address bound is `10.0.2.16`
    with a subnet of `/24` or `255.255.255.0`. With this setup, we should be able
    to communicate with another IP within this subnet. The following is the output
    of using the ping command to test connectivity to `10.0.2.2`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`enp0s3`接口，我们可以看到绑定的IP地址是`10.0.2.16`，子网掩码为`/24`或`255.255.255.0`。通过这种设置，我们应该能够与该子网内的其他IP进行通信。以下是使用ping命令测试与`10.0.2.2`的连通性的输出。
- en: '[PRE51]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This shows that the `enp0s3` interface can at least connect to other IPs within
    its subnet. With `enp0s8`, we can perform the same test with another IP.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明`enp0s3`接口至少可以连接到其子网内的其他IP。对于`enp0s8`，我们可以使用另一个IP执行相同的测试。
- en: '[PRE52]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: From the preceding command, we can see that `enp0s8` has the IP `192.168.33.11`
    bound to it with a subnet of `/24` or `255.255.255.0`. If we can use the ping
    command to communicate with any other IP in the `192.168.33.11/24` subnet, then
    we can validate that this interface is also configured correctly.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述命令中，我们可以看到`enp0s8`的IP为`192.168.33.11`，子网掩码为`/24`或`255.255.255.0`。如果我们可以使用ping命令与`192.168.33.11/24`子网内的任何其他IP进行通信，那么我们可以验证该接口也已正确配置。
- en: '[PRE53]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: From the results, we can see that connectivity to the IP `192.168.33.1` is working
    as expected. Therefore, this means that, in at least a basic manner, the `enp0s8`
    interface is configured correctly.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中，我们可以看到对IP`192.168.33.1`的连接正常工作。因此，这意味着，至少在基本方面，`enp0s8`接口已正确配置。
- en: With all of this information, we can assume that the `blog.example.com` server
    is configured correctly and can connect to the networks that it is configured
    for. From this point forward, if we want any more information about our issue,
    we will need to obtain it from the `db.example.com` (`192.168.33.12`) server.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些信息，我们可以假设`blog.example.com`服务器已正确配置，并且可以连接到其配置的网络。从这一点开始，如果我们想要更多关于我们问题的信息，我们需要从`db.example.com`（`192.168.33.12`）服务器获取。
- en: Taking a look on the other side
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 看看对方的情况
- en: While it may not always be possible, when dealing with networking issues it
    is always best to troubleshoot from both sides of the conversation. In our earlier
    examples, we had two systems that make up our network conversation, namely the
    client and the server. So far we have looked at everything from the client's perspective;
    in this section, we are going to take a look at the other side of this conversation,
    from the server's perspective.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能并非总是可能的，但在处理网络问题时，最好从对话的两端进行故障排除。在我们之前的例子中，我们有两个构成我们网络对话的系统，即客户端和服务器。到目前为止，我们已经从客户端的角度看了一切；在本节中，我们将从服务器的角度来看这次对话的另一面。
- en: Identifying the network configuration
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别网络配置
- en: In the previous section, we went through several steps before looking at the
    blog server's network configuration. In the case of the database server, we already
    know that the issue is related to networking and specifically the IP of `192.168.33.12`.
    Since we already know which IP the issue is related to, the first thing that we
    should do is identify which interface this IP is bound to.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们在查看博客服务器的网络配置之前经历了几个步骤。在数据库服务器的情况下，我们已经知道问题与网络有关，特别是IP为`192.168.33.12`。既然我们已经知道问题与哪个IP相关，我们应该做的第一件事是确定这个IP绑定到哪个接口。
- en: One again, we will do this by using the `ip` command with the `addr show` options.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用`ip`命令和`addr show`选项来执行此操作。
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the earlier example, we used the `addr show` options to show the IPs associated
    with a single interface. This time, however, by omitting the interface name, the
    `ip` command shows all IPs and the interface that these IPs are bound to. This
    is a quick and simple way to show both the IP addresses and the interfaces associated
    with this server.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们使用`addr show`选项来显示与单个接口关联的IP。然而，这次通过省略接口名称，`ip`命令显示了所有IP以及这些IP绑定到的接口。这是一种快速简单的方法，可以显示与这台服务器关联的IP地址和接口。
- en: We can see from the preceding command that the database server has a similar
    configuration to the application server in that it has three interfaces. Before
    going too far, let's understand the server's interfaces better and see what information
    we can identify from them.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的命令中，我们可以看到数据库服务器与应用服务器的配置类似，都有三个接口。在深入之前，让我们更好地了解服务器的接口，并看看我们可以从中识别出什么信息。
- en: '[PRE55]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The first interface on this server is the loopback interface `lo`. As discussed
    previously, this interface is common for every server and is only used for the
    local network traffic. This interface is not likely to be related to our issue.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这台服务器上的第一个接口是环回接口`lo`。如前所述，这个接口对于每台服务器来说都是通用的，只用于本地网络流量。这个接口不太可能与我们的问题有关。
- en: '[PRE56]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It seems that, for the second interface, `enp0s3`, the database server's configuration
    is very similar to the blog server's. On the web application server, we also had
    an interface named `enp0s3` and this interface was also on the `10.0.2.0/24` network.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个接口`enp0s3`，数据库服务器的配置与博客服务器非常相似。在Web应用服务器上，我们也有一个名为`enp0s3`的接口，这个接口也在`10.0.2.0/24`网络上。
- en: Since the connectivity between the blog and database servers seems to be targeting
    the IP of `192.168.33.12`, it seems that `enp0s3` is not an interface to focus
    on as the `enp0s3` interface has the IP `10.0.2.16` bound to it.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于博客和数据库服务器之间的连接似乎是针对IP`192.168.33.12`，因此`enp0s3`不是一个需要关注的接口，因为`enp0s3`接口的IP是`10.0.2.16`。
- en: '[PRE57]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The third network device `enp0s8`, on the other hand, does have the IP `192.168.33.12`
    bound to it. The `enp0s8` device is also set up similar to the `enp0s8` device
    on the blog server, as it seems that the two devices are both on the `192.168.33.0/24`
    network.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，第三个网络设备`enp0s8`确实绑定了IP`192.168.33.12`。`enp0s8`设备的设置也与博客服务器上的`enp0s8`设备类似，因为这两个设备似乎都在`192.168.33.0/24`网络上。
- en: From the previous troubleshooting, we know that the IP that our web application's
    targeting is IP 192.168.33.12\. With the `ip` command, we have confirmed that
    192.168.33.12 is bound to this server via the `enp0s8` interface.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通过之前的故障排除，我们知道我们的Web应用程序所针对的IP是IP 192.168.33.12。通过`ip`命令，我们已经确认192.168.33.12通过`enp0s8`接口绑定到了这台服务器上。
- en: Testing connectivity from db.example.com
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从db.example.com测试连接
- en: Now that we know that the database server has an expected network configuration,
    we need to establish whether this server is correctly connected to the `192.168.33.0/24`
    network. The simplest way is to perform a task that we performed earlier on the
    blog server; using `ping` to connect to another IP on that subnet.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道数据库服务器有预期的网络配置，我们需要确定这台服务器是否正确连接到`192.168.33.0/24`网络。最简单的方法是执行一个我们之前在博客服务器上执行过的任务；使用`ping`连接到该子网上的另一个IP。
- en: '[PRE58]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: With the above output, we can see that the database server is able to contact
    another IP on the `192.168.33.0/24` subnet. Earlier while troubleshooting, we
    tried to connect to the database server from the blog server and that test failed.
    An interesting test would be to validate that the connectivity fails the other
    way around as well when the database server initiates a connection to the blog
    server.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上面的输出，我们可以看到数据库服务器能够联系到`192.168.33.0/24`子网上的另一个IP。在故障排除时，我们曾试图从博客服务器连接到数据库服务器，但测试失败了。一个有趣的测试是验证当数据库服务器发起连接到博客服务器时，连接是否也失败。
- en: '[PRE59]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: When running the `ping` command from the database server to the IP of the blog
    server (`192.168.33.11`), we can see that ping has replied with **Destination
    Host Unreachable**. This is the same error that we saw when attempting connectivity
    from the blog server as well.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库服务器运行`ping`命令到博客服务器的IP（192.168.33.11），我们可以看到ping已经回复**目标主机不可达**。这与我们从博客服务器尝试连接时看到的错误相同。
- en: As mentioned earlier, there are a number of reasons other than network connectivity
    issues that a ping will fail; to ensure that there is a connectivity issue, we
    should also test connectivity with `telnet`. We know that the blog server is accepting
    connections to the web server, so a simple `telnet` to the webserver's port should
    tell us definitively if there is any connectivity from the database server to
    the web server.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，除了网络连接问题之外，ping失败的原因还有很多；为了确保存在连接问题，我们还应该使用`telnet`测试连接。我们知道博客服务器正在接受到Web服务器的连接，因此简单地telnet到Web服务器的端口应该明确告诉我们从数据库服务器到Web服务器是否存在任何连接。
- en: When running `telnet`, we need to specify a port to connect to. We know that
    the web server is running and, when we navigate to `http://blog.example.com`,
    we get a web page. On the basis of this information, we can determine that the
    default HTTP port is used and is listening. With this information, we also know
    that we can simply use telnet to connect to port `80`, the default port for `HTTP`
    communication.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`telnet`时，我们需要指定要连接的端口。我们知道Web服务器正在运行，当我们导航到`http://blog.example.com`时，我们会得到一个网页。基于这些信息，我们可以确定使用默认的HTTP端口并且正在监听。有了这些信息，我们还知道我们可以简单地使用telnet连接到端口`80`，这是`HTTP`通信的默认端口。
- en: '[PRE60]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: However, on this server, `telnet` is not installed. That's OK because we can
    use the `curl` command as we did in our previous examples.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在这台服务器上，未安装`telnet`。这没关系，因为我们可以像在之前的示例中那样使用`curl`命令。
- en: '[PRE61]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: From the `curl` command's output, we can see that the communication issue is
    present irrespective of whether the blog or the database server initiates the
    connection.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 从`curl`命令的输出中，我们可以看到无论是博客服务器还是数据库服务器发起连接，通信问题都存在。
- en: Looking for connections with netstat
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用netstat查找连接
- en: In the previous section, when troubleshooting from the blog server we used `netstat`
    to view the open TCP connections to the database server. Now that we are logged
    into the database server, we can use the same command to see the status of the
    connections from the database server's perspective. To do this, we will run `netstat`
    with an interval specified; this causes `netstat` to print network connection
    statistics every 5 s similar to the `vmstat` or `top` commands.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的部分中，当从博客服务器进行故障排除时，我们使用`netstat`查看了到数据库服务器的开放TCP连接。现在我们已经登录到数据库服务器，我们可以使用相同的命令从数据库服务器的角度查看连接的状态。为此，我们将使用指定的间隔运行`netstat`；这会导致`netstat`每5秒打印一次网络连接统计，类似于`vmstat`或`top`命令。
- en: While the `netstat` command is running, we will simply refresh our browser to
    cause the WordPress application to attempt a database connection again.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在`netstat`命令运行时，我们只需刷新浏览器，使WordPress应用程序再次尝试数据库连接。
- en: '[PRE62]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: After running `netstat` in what I like to call the `continuous mode`, and using
    `grep` to filter for the blog server's IP (192.168.33.11), we could not see any
    TCP connections or connection attempts.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在我喜欢称为“连续模式”的情况下运行`netstat`命令，并使用`grep`过滤博客服务器的IP（192.168.33.11），我们无法看到任何TCP连接或连接尝试。
- en: In many cases, this would seem to indicate that the database server is never
    receiving a TCP packet from the blog server. We can confirm whether this is the
    case by using the `tcpdump` command to capture all network traffic on the `enp0s8`
    interface.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，这似乎表明数据库服务器从未收到来自博客服务器的TCP数据包。我们可以通过使用`tcpdump`命令在`enp0s8`接口上捕获所有网络流量来确认是否是这种情况。
- en: Tracing network connections with tcpdump
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用tcpdump跟踪网络连接
- en: Earlier when learning about `tcpdump`, we learned that it defaults to the interface
    with the lowest number. This means that, in order to capture the connection attempts,
    we must use the `-i` (interface) flag to trace the correct interface, `enp0s8`.
    In addition to telling `tcpdump` to watch the `enp0s8` interface, we are also
    going to have `tcpdump` write its output into a file. We will do this so that
    we can capture as much data as possible and later use the `tcpdump` command to
    analyze the data as many times as we need to.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候学习`tcpdump`时，我们了解到它默认使用编号最低的接口。这意味着，为了捕获连接尝试，我们必须使用`-i`（接口）标志来跟踪正确的接口`enp0s8`。除了告诉`tcpdump`监视`enp0s8`接口外，我们还将让`tcpdump`将其输出写入文件。我们这样做是为了尽可能多地捕获数据，并稍后使用`tcpdump`命令多次分析数据。
- en: '[PRE63]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now that `tcpdump` is running, we simply need to refresh our browser again.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`tcpdump`正在运行，我们只需要再次刷新浏览器。
- en: '[PRE64]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: After refreshing the browser and seeing the `packets captured` counter increase,
    we can stop `tcpdump` by pressing *Ctrl* + *C* on the keyboard.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在刷新浏览器并看到`捕获的数据包`计数器增加后，我们可以通过在键盘上按*Ctrl* + *C*来停止`tcpdump`。
- en: Once `tcpdump` has stopped, we can read the captured data with the `–r` (read)
    flag; however, this will print all of the packets that `tcpdump` captured. In
    some environments, this may be quite a lot of data. So, to trim the output to
    only the data that is useful, we will use the `port` filter to tell `tcpdump`
    to only output the captured traffic that is initiated from or targeting port 3306,
    the default MySQL port.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`tcpdump`停止，我们可以使用`-r`（读取）标志读取捕获的数据；但是，这将打印`tcpdump`捕获的所有数据包。在某些环境中，这可能是相当多的数据。因此，为了将输出修剪为仅有用的数据，我们将使用`port`过滤器告诉`tcpdump`仅输出从端口3306发起或针对端口3306的捕获流量，默认的MySQL端口。
- en: We can do this by adding `port 3306` to the end of the `tcpdump` command.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`tcpdump`命令的末尾添加`port 3306`来实现这一点。
- en: '[PRE65]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: While using the preceding filter, however, it seems that this database server
    is used by more than just the WordPress application. From the `tcpdump` output,
    we can see more traffic on port `3306` than just the blog server.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用上述过滤器的同时，似乎这个数据库服务器不仅仅被WordPress应用程序使用。从“tcpdump”输出中，我们可以看到端口“3306”上的流量不仅仅是博客服务器。
- en: 'To clean up this output further, we can add the host filter to the `tcpdump`
    command to filter out only the traffic that we are interested in: traffic from
    the host `192.168.33.11`.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步清理此输出，我们可以向“tcpdump”命令添加主机过滤器，以仅过滤出我们感兴趣的流量：来自主机“192.168.33.11”的流量。
- en: '[PRE66]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, we used the "`and`" operator to tell `tcpdump` to only print traffic that
    is to/from port `3306` and to/from host `192.168.33.11`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用“and”运算符告诉“tcpdump”只打印到/从端口“3306”和到/从主机“192.168.33.11”的流量。
- en: The `tcpdump` command has many possible filters and operators; however, out
    of all of them, I would recommend becoming familiar with filtering based on port
    and host as these will suffice for most occasions.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: “tcpdump”命令有许多可能的过滤器和运算符；然而，在所有这些中，我建议熟悉基于端口和主机的过滤，因为这些将足够满足大多数情况。
- en: If we break down the preceding captured network trace, we can see some interesting
    information; to make it a bit easier to spot, let's trim the output down to show
    just the IPs and flags being used.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分解前面捕获的网络跟踪，我们可以看到一些有趣的信息；为了更容易发现，让我们将输出修剪到只显示正在使用的IP和标志。
- en: '[PRE67]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: From this information, we can see the `SYN` packets being sent from `blog.example.com`
    (`192.168.33.11`) and arriving on `db.example.com` (`192.168.33.12`). What we
    don't see, however, are the returned `SYN-ACKS`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些信息中，我们可以看到从“blog.example.com”（“192.168.33.11”）发送的“SYN”数据包，并到达“db.example.com”（“192.168.33.12”）。然而，我们看不到返回的“SYN-ACKS”。
- en: This tells us that we have at least found the source of the networking issue;
    the server `db.example.com` is not correctly replying to packets received from
    the blog server.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，我们至少已经找到了网络问题的源头；服务器“db.example.com”没有正确地回复从博客服务器收到的数据包。
- en: 'Now the question is: What can cause this type of problem? There are many reasons
    for this issue to occur; in general, however, such an issue is due to a misconfiguration
    in the network configuration settings. Given the information that we have gathered,
    we can hypothesize that the database server is simply misconfigured.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是：什么会导致这种问题？导致此类问题的原因有很多；但是，一般来说，这样的问题是由网络配置设置中的错误配置引起的。根据我们收集的信息，我们可以假设数据库服务器只是配置错误。
- en: There are, however, several ways to cause this type of problem with misconfigurations.
    In order to identify the possible misconfigurations, we can use the `tcpdump`
    command to capture all the network traffic on this server.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有几种方法可以通过错误配置导致这种类型的问题。为了确定可能的错误配置，我们可以使用“tcpdump”命令在此服务器上捕获所有网络流量。
- en: In the previous examples of `tcpdump`, we always specified a single interface
    to watch. In most cases, this is appropriate for the issue as it reduces the volume
    of data being captured by `tcpdump`. On very active servers, a few minutes of
    `tcpdump` data can be very large, so it is always best to reduce the data to only
    what is required.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的“tcpdump”示例中，我们总是指定单个要监视的接口。在大多数情况下，这对于问题是适当的，因为它减少了“tcpdump”捕获的数据量。在非常活跃的服务器上，“tcpdump”数据的几分钟可能非常庞大，因此最好将数据减少到只有必需的部分。
- en: In some occasions, however, such as this issue, it is useful to tell `tcpdump`
    to capture the network traffic from all interfaces. To do this, we simply specify
    `any` as the interface to watch.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，例如这种问题，告诉“tcpdump”捕获所有接口的网络流量是有用的。为此，我们只需指定“any”作为要监视的接口。
- en: '[PRE68]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now that we have `tcpdump` capturing and saving all traffic on all interfaces,
    we will need to refresh our browser again to force the WordPress application to
    attempt database connections.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有“tcpdump”捕获并保存所有接口上的所有流量，我们需要再次刷新浏览器，以强制WordPress应用程序尝试数据库连接。
- en: '[PRE69]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: After a few tries, we can stop the `tcpdump` again by pressing *Ctrl* + *C*.
    With the captured network data saved to a file, we can start to investigate what
    is happening with these connection attempts.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几次尝试，我们可以再次按*Ctrl* + *C*停止“tcpdump”。将捕获的网络数据保存到文件后，我们可以开始调查这些连接尝试的情况。
- en: Since the `tcpdump` captured a large number of packets, we will once again use
    the `host` filter to limit results to the network traffic to and from `192.168.33.11`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“tcpdump”捕获了大量数据包，我们将再次使用“主机”过滤器将结果限制为与“192.168.33.11”之间的网络流量。
- en: '[PRE70]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: With the captured data, it seems that we have found the expected `SYN-ACK`.
    To show this in a clearer fashion, let's trim the output to just the IPs and flags
    in use.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 通过捕获的数据，似乎我们已经找到了预期的“SYN-ACK”。为了更清晰地展示这一点，让我们将输出修剪到仅包括正在使用的IP和标志。
- en: '[PRE71]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: With a clearer picture, we can see an interesting series of network packets
    being transmitted.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更清晰的图片，我们可以看到一系列有趣的网络数据包正在传输。
- en: '[PRE72]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The first packet is an `SYN` packet from `192.168.33.11` to `192.168.33.12`
    on port `3306`. This is the same type of packet that we have captured with the
    earlier `tcpdump` executions.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个数据包是从“192.168.33.11”到“192.168.33.12”的端口“3306”的“SYN”数据包。这与我们之前使用“tcpdump”执行捕获的数据包类型相同。
- en: '[PRE73]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: However, we have not seen the second packet before. In the second packet, we
    see that it is an `SYN-ACK` (identified by `Flags [S.]`). The `SYN-ACK` is being
    sent from `192.168.33.12` on port `3306` to `192.168.33.11` on port `47339` (the
    port that sent the original `SYN` packet).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们以前没有看到第二个数据包。在第二个数据包中，我们看到它是一个“SYN-ACK”（由“Flags [S.]”标识）。“SYN-ACK”是从端口“3306”的“192.168.33.12”发送到端口“47339”的“192.168.33.11”（发送原始“SYN”数据包的端口）。
- en: At the first glance, this seems to be a normal `SYN` and `SYN-ACK` handshake.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这似乎是一个正常的“SYN”和“SYN-ACK”握手。
- en: '[PRE74]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The third packet, however, is interesting as it is a clear indication of an
    issue. The third packet is a `RESET` packet (identified by `Flags [R]`) sent from
    `192.168.33.11`, the blog server. The interesting thing about this is that, when
    executing `tcpdump` on the blog server, we never captured a `RESET` packet. If
    we execute `tcpdump` again on the blog server, we can see this one more time.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第三个数据包很有趣，因为它清楚地表明了一个问题。第三个数据包是一个`RESET`数据包（由`Flags [R]`标识），从博客服务器`192.168.33.11`发送。关于这个有趣的事情是，当在博客服务器上执行`tcpdump`时，我们从未捕获到`RESET`数据包。如果我们在博客服务器上再次执行`tcpdump`，我们可以再次看到这个。
- en: '[PRE75]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: From the preceding `tcpdump` output, we never see either the `SYN-ACK` or the
    `RESET` packets on the blog server. This either means that the `RESET` is being
    sent by another system or the `SYN-ACK` packet is being rejected by the blog server's
    kernel before `tcpdump` can capture it.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的`tcpdump`输出中，我们从未看到博客服务器上的`SYN-ACK`或`RESET`数据包。这意味着`RESET`要么是由另一个系统发送的，要么是在`tcpdump`捕获之前被博客服务器的内核拒绝了`SYN-ACK`数据包。
- en: When the `tcpdump` command captures network traffic, it does so after the kernel
    has processed this network traffic. This means that if, for any reason, the kernel
    is rejecting the packet, it will not be seen via the `tcpdump` command. Thus,
    it is possible that the blog server's kernel is rejecting the return packets from
    the database server before `tcpdump` is able to capture them.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当`tcpdump`命令捕获网络流量时，它是在内核处理这些网络流量之后进行的。这意味着如果由于任何原因内核拒绝了数据包，它将不会通过`tcpdump`命令看到。因此，博客服务器的内核在`tcpdump`能够捕获它们之前可能会拒绝来自数据库服务器的返回数据包。
- en: An additional interesting point revealed by performing a `tcpdump` on the database
    is that, if we look at the `tcpdump` performed on `enp0s8`, we do not see the
    `SYN-ACK` packet. However, if we tell `tcpdump` to look at all the interfaces
    we use, `tcpdump` also shows the `SYN-ACK` packet to be coming from `192.168.33.12`.
    This suggests that the `SYN-ACK` is being sent from another interface.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在数据库上执行`tcpdump`，我们还发现了另一个有趣的点，即如果我们查看在`enp0s8`上执行的`tcpdump`，我们看不到`SYN-ACK`数据包。然而，如果我们告诉`tcpdump`查看我们使用的所有接口，`tcpdump`也会显示`SYN-ACK`数据包来自`192.168.33.12`。这表明`SYN-ACK`是从另一个接口发送的。
- en: To confirm this, we can run a `tcpdump` again, limiting the capture to packets
    that traverse the `enp0s8` interface.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认这一点，我们可以再次运行`tcpdump`，限制捕获经过`enp0s8`接口的数据包。
- en: '[PRE76]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: From this execution of `tcpdump`, we can yet again only see the `SYN` packets
    from the blog server. However, if we run the same `tcpdump` against all interfaces,
    we should see not only the `SYN` packets but also the `SYN-ACK` packets.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这次对`tcpdump`的执行，我们只能再次看到来自博客服务器的`SYN`数据包。然而，如果我们对所有接口运行相同的`tcpdump`，我们不仅应该看到`SYN`数据包，还应该看到`SYN-ACK`数据包。
- en: '[PRE77]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `SYN-ACK` packet being returned to `192.168.33.11` is sourced from `192.168.33.12`.
    Earlier, we identified that this IP is bound to the network device `enp0s8`. However,
    when we use `tcpdump` to look at all of the packets being sent, the `SYN-ACK`
    is not captured going out of `enp0s8`. This means that the `SYN-ACK` packet is
    being sent from a different interface.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到`192.168.33.11`的`SYN-ACK`数据包源自`192.168.33.12`。早些时候，我们确定了这个IP绑定到网络设备`enp0s8`。然而，当我们使用`tcpdump`查看所有发送的数据包时，`SYN-ACK`并没有被捕获从`enp0s8`出去。这意味着`SYN-ACK`数据包是从另一个接口发送的。
- en: Routing
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由
- en: How does an `SYN` packet arrive on one interface and an `SYN-ACK` get returned
    from another? One possible answer is that this is due to a misconfiguration in
    the routing definitions on the database server.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`SYN`数据包如何到达一个接口，而`SYN-ACK`却从另一个接口返回呢？一个可能的答案是这是由于数据库服务器路由定义的错误配置。'
- en: Every operating system that supports networking maintains something called a
    **routing table**. This routing table is a collection of defined network routes
    that a packet should take. To give a bit of context around this concept, let's
    use the two interfaces `enp0s3` and `enp0s8` as examples.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 支持网络的每个操作系统都维护着一个称为**路由表**的东西。这个路由表是一组定义的网络路由，数据包应该经过的路由。为了给这个概念提供一些背景，让我们以`enp0s3`和`enp0s8`两个接口为例。
- en: '[PRE78]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: If we look at these two interfaces, we know that the `enp0s8` interface is connected
    to the `192.168.33.0/24` (`inet 192.168.33.12/24`) network and the `enp0s3` interface
    is connected to the `10.0.2.0/24` (`inet 10.0.2.16/24`) network.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看这两个接口，我们知道`enp0s8`接口连接到`192.168.33.0/24`（`inet 192.168.33.12/24`）网络，而`enp0s3`接口连接到`10.0.2.0/24`（`inet
    10.0.2.16/24`）网络。
- en: If we were to connect to the IP 10.0.2.19, the packets should not go out of
    the `enp0s8` interface, as the optimal route for these packets would be to route
    through the `enp0s3` interface. The reason that this is the most optimal route
    is that the `enp0s3` interface is already part of the `10.0.2.0/24` network, which
    contains the IP `10.0.2.19`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要连接到IP 10.0.2.19，数据包不应该从`enp0s8`接口出去，因为这些数据包的最佳路由应该是通过`enp0s3`接口路由。这是最佳路由的原因是`enp0s3`接口已经是`10.0.2.0/24`网络的一部分，其中包含IP`10.0.2.19`。
- en: The `enp0s8` interface is part of a different network (`192.168.33.0/24`) and
    therefore, is the less optimal route. In fact, the `enp0s8` interface may not
    even be able to route to the `10.0.2.0/24` network.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`enp0s8`接口是不同网络（`192.168.33.0/24`）的一部分，因此是不太理想的路由。事实上，`enp0s8`接口甚至可能无法路由到`10.0.2.0/24`网络。'
- en: Even though `enp0s8` may be a less optimal route, the kernel does not know this
    without a corresponding entry in the routing table. To dig deeper into our issue,
    we will need to view the routing table on this database server.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`enp0s8`可能是一个不太理想的路由，内核在没有路由表中对应条目的情况下是不知道这一点的。为了更深入地了解我们的问题，我们需要查看数据库服务器上的路由表。
- en: Viewing the routing table
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看路由表
- en: In Linux, there are a few ways to see the current routing table; in this section,
    I am going to cover two. The first method will utilize the `netstat` command.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，有几种方法可以查看当前的路由表；在本节中，我将介绍两种方法。第一种方法将利用`netstat`命令。
- en: To use the `netstat` command to view the routing table, simply run it with the
    `–r` (route) or `--route` flag. In the following example, we will also use the
    `-n` flag to prevent `netstat` from performing DNS lookups.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`netstat`命令查看路由表，只需使用`-r`（route）或`--route`标志运行它。在下面的例子中，我们还将使用`-n`标志防止`netstat`执行DNS查找。
- en: '[PRE79]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: While `netstat` might not be the best Linux command to print the routing table,
    there is a very specific reason for using it in this example. As I mentioned earlier
    in this chapter and book, the `netstat` command is a universal tool that exists
    on almost every modern server, router, or desktop. By knowing how to look at the
    routing table with `netstat`, you can perform basic network troubleshooting on
    any operating system that has `netstat` installed.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`netstat`可能不是打印路由表的最佳Linux命令，但在这个例子中使用它有一个非常特殊的原因。正如我在本章和本书中早些时候提到的，`netstat`命令是一个几乎存在于每台现代服务器、路由器或台式机上的通用工具。通过了解如何使用`netstat`查看路由表，您可以在安装了`netstat`的任何操作系统上执行基本的网络故障排除。
- en: In general, it is a safe bet that the `netstat` command would be available and
    can provide you with at least the basic details of the system's networking status
    and configurations.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，可以肯定地说`netstat`命令是可用的，并且可以为您提供系统网络状态和配置的基本细节。
- en: The format of `netstat` can be a bit cryptic compared with the other utilities
    such as the `ip` command. However, the preceding routing table shows us quite
    a bit of information. To get a better understanding, let's break down the output
    route by route.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他实用程序（如`ip`命令）相比，`netstat`的格式可能有点晦涩。然而，前面的路由表向我们展示了相当多的信息。为了更好地理解，让我们逐条分解输出的路由。
- en: '[PRE80]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: As you can see, the output of the `netstat` command has multiple columns, eight
    to be precise. The first column is the `Destination` column. This is used to define
    what destination address is in scope for the route. In the preceding example,
    the destination is `0.0.0.0`, which is essentially a wildcard value meaning that
    any and everything should be routed via this table entry.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`netstat`命令的输出有多列，确切地说有八列。第一列是`Destination`列。这用于定义路由范围内的目标地址。在前面的例子中，目的地是`0.0.0.0`，这实际上是一个通配值，意味着任何东西都应该通过这个表项进行路由。
- en: The second column is `Gateway`. The gateway address is the next hop that the
    network packets utilizing this route should be sent to. For this example, the
    next hop or gateway address is set to `10.0.2.2`; this means that any packets
    being routed via this table entry will be sent to `10.0.2.2`, which should then
    route the packets to the next system until they reach their destination.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 第二列是`Gateway`。网关地址是利用这条路由的网络数据包应该发送到的下一跳。在这个例子中，下一跳或网关地址设置为`10.0.2.2`；这意味着通过这个表项进行路由的任何数据包将被发送到`10.0.2.2`，然后应该将数据包路由到下一个系统，直到它们到达目的地。
- en: The third column is `Genmask`, which is essentially a way of stating the "`generality`"
    of the route. Another way of thinking about this column is as a `netmask`; in
    the preceding example, the "`genmask`" is set to `0.0.0.0`, which is an open scope.
    This means that packets to anywhere should be routed out of this routing table
    entry.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 第三列是`Genmask`，本质上是一种陈述路由的“`一般性`”的方式。另一种思考这一列的方式是作为`netmask`；在前面的例子中，“`genmask`”设置为`0.0.0.0`，这是一个开放范围。这意味着任何地方的数据包都应该通过这个路由表项进行路由。
- en: The fourth column is the `Flag` column, which is used to provide specific information
    about this route. The `U` value in the example means that the interface to use
    for this route is in an up state. The `G` value is used to show that the route
    utilizes a gateway address. In the preceding example, we can see that our route
    utilizes a gateway address; however, not all of this system's routes do.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 第四列是`Flag`列，用于提供有关这条路由的具体信息。例子中的`U`值表示此路由使用的接口处于上行状态。`G`值用于显示路由使用了网关地址。在前面的例子中，我们可以看到我们的路由使用了网关地址；然而，并非这个系统的所有路由都是这样。
- en: The fifth, sixth, and seventh columns are not frequently used on Linux servers.
    The `MSS` column is used to show the **maximum segment size** specified for this
    route. The value of 0 means that this value is set to the default and not altered.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 第五、第六和第七列在Linux服务器上并不经常使用。`MSS`列用于显示为这条路由指定的**最大分段大小**。值为0意味着此值设置为默认值且未更改。
- en: The `Window` column is the TCP window size, which denotes the maximum amount
    of data that will be accepted in a single burst. Again, when the value is set
    to 0, the default size will be used.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`Window`列是TCP窗口大小，表示单个突发接受的最大数据量。同样，当值设置为0时，将使用默认大小。'
- en: The seventh column is `irtt`, which is used to specify the **Initial Round-trip
    Time** for this route. The kernel will resend packets that are never responded
    to by setting an initial round-trip time; you can increase or decrease the time
    after which the kernel considers packets lost. As in the case of the previous
    two columns, the value of 0 means that the default value will be used for packets
    using this route.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 第七列是`irtt`，用于指定这条路由的**初始往返时间**。内核将通过设置初始往返时间重新发送从未得到响应的数据包；您可以增加或减少内核认为数据包丢失之后的时间。与前两列一样，值为0意味着使用这条路由的数据包将使用默认值。
- en: The eighth and the last column, the `IFace` column, is the network interface
    that the packets utilizing this route should use. In the preceding example, this
    is the `enp0s3` interface.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 第八和最后一列是`IFace`列，是利用这条路由的数据包应该使用的网络接口。在前面的例子中，这是`enp0s3`接口。
- en: The default route
  id: totrans-380
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 默认路由
- en: The first route in our example is actually a very special route for our system.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们例子中的第一条路由实际上是我们系统的一个非常特殊的路由。
- en: '[PRE81]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If we look at the details of this route and the definition of each column, we
    can determine that this route is the default route for the server. The default
    route is a special route that is used "by default" when no other route supersedes
    it. To put it simply, if we have packets that are to be sent to an address such
    as `172.0.0.10`, these packets would go through the default route.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看这条路由的详细信息和每列的定义，我们可以确定这条路由是服务器的默认路由。默认路由是一种特殊路由，在没有其他路由取代它时“默认”使用。简而言之，如果我们有要发送到诸如`172.0.0.10`的地址的数据包，这些数据包将通过默认路由发送。
- en: The reason for this is that there is no other route in our database server's
    routing table that specifies the IP `172.0.0.10`. As such, the system simply sends
    packets to this IP through the default route, a catchall route.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们的数据库服务器路由表中没有其他指定IP`172.0.0.10`的路由。因此，系统只需通过默认路由发送数据包到这个IP，这是一个万能路由。
- en: We can identify that the first route is the server's default route because of
    the destination address of `0.0.0.0`, which essentially means anything. The second
    indication is the `Genmask` of `0.0.0.0`, which together with the destination
    means any IPv4 address.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过目的地址为`0.0.0.0`来确定第一条路由是服务器的默认路由，这基本上意味着任何东西。第二个指示是`Genmask`为`0.0.0.0`，这与目的地一起意味着任何IPv4地址。
- en: It is also typical of the default route to use a gateway address, so the fact
    that the gateway is set with wildcards for `destination` and `genmask` is a clear
    indication that the abovementioned route is the default route.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 默认路由通常使用网关地址，因此网关为`destination`和`genmask`设置通配符是明确表明上述路由是默认路由的迹象。
- en: 'A non-default route will commonly look like the following:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 非默认路由通常看起来像这样：
- en: '[PRE82]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The abovementioned route has a destination of 10.0.2.0 and a `genmask` of 255.255.255.0;
    this is essentially saying that anything in the 10.0.2.0/24 network would match
    this route.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 上述路由的目的地是10.0.2.0，`genmask`为255.255.255.0；这基本上意味着10.0.2.0/24网络中的任何内容都会匹配这条路由。
- en: Since the range of this route is `10.0.2.0/24`, it is likely that this route
    was added by the `enp0s3` interface configuration. We can determine this on the
    basis of the `enp0s3` interface configuration, as it is attached to the `10.0.2.0/24`
    network, which is the target of this route. By default, Linux will automatically
    add routes on the basis of the network interface's configuration.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这条路由的范围是`10.0.2.0/24`，很可能是由`enp0s3`接口配置添加的。我们可以根据`enp0s3`接口配置来确定这一点，因为它连接到`10.0.2.0/24`网络，这是这条路由的目标。默认情况下，Linux会根据网络接口的配置自动添加路由。
- en: '[PRE83]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This route is a way for the kernel to ensure that communication for the `10.0.2.0/24`
    network goes out of the `enp0s3` interface, as this route will supersede the default
    route. With network routing, the most specific route will always be used. Since
    the default route is a wildcard and this route is specific to the `10.0.2.0/24`
    network, this route will be used for anything within the network.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这条路由是内核确保`10.0.2.0/24`网络的通信通过`enp0s3`接口进行的一种方式，因为这条路由将取代默认路由。在网络路由中，将始终使用最具体的路由。由于默认路由是通配符，而这条路由是特定于`10.0.2.0/24`网络的，因此这条路由将用于网络中的任何内容。
- en: Utilizing IP to show the routing table
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用IP显示路由表
- en: Another tool for reviewing the routing table is the `ip` command. The `ip` command,
    as we can see from its use within this chapter, is a very extensive utility and
    can be used for practically everything network-related on a modern Linux system.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 审查路由表的另一个工具是`ip`命令。从本章中使用的情况可以看出，`ip`命令是一个非常全面的实用工具，几乎可以用于现代Linux系统上的任何网络相关事务。
- en: One use for the `ip` command is to add, remove, or show network routing configurations.
    To display the current routing table, simply execute the `ip` command with the
    `route show` options.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip`命令的一个用途是添加、删除或显示网络路由配置。要显示当前的路由表，只需执行带有`route show`选项的`ip`命令。'
- en: '[PRE84]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: While learning to use the `netstat` command is important for non-Linux operating
    systems, the `ip` command is an essential tool for any Linux network troubleshooting
    or configuration.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然学习使用`netstat`命令对于非Linux操作系统很重要，但`ip`命令是任何Linux网络故障排除或配置的基本工具。
- en: As we use the `ip` command for troubleshooting routes, we may even find it easier
    than the `netstat` command. One example is finding the default route. When the
    `ip` command displays the default route, it uses the word default as the destination
    rather than 0.0.0.0, a method that is much easier to understand especially for
    newer system administrators.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ip`命令来排除故障路由时，我们甚至可能会发现它比`netstat`命令更容易。一个例子是查找默认路由。当`ip`命令显示默认路由时，它使用单词"default"作为目的地，而不是0.0.0.0，这种方法对于新系统管理员来说更容易理解。
- en: 'It is also easier to read other routes as well. For instance, earlier while
    looking at routes via `netstat`, our example route looked like the following:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读其他路由也更容易。例如，之前在`netstat`中查看路由时，我们的示例路由如下：
- en: '[PRE85]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'With the `ip` command, the same route is shown in the following format:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ip`命令，相同的路由以以下格式显示：
- en: '[PRE86]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In my opinion, the format of `ip` route show is a much simpler format than the
    format of the `netstat -rn` command.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，`ip` route show的格式比`netstat -rn`命令的格式简单得多。
- en: Looking for routing misconfigurations
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寻找路由错误配置
- en: Now that we know how to look at the routing table on the server, we can use
    the `ip` command to find any routes that may cause issues with our database connectivity.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何查看服务器上的路由表，我们可以使用`ip`命令查找可能导致数据库连接问题的任何路由。
- en: '[PRE87]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Here, we can see five routes defined on our system. Let's break down these routes
    to get a better understanding of them.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到系统上定义了五条路由。让我们分解这些路由，以更好地理解它们。
- en: '[PRE88]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The first two routes we have already covered and will not review again.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了前两条路由，不会再次复习。
- en: '[PRE89]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The third route defines that all traffic from `169.254.0.0/16` (`169.254.0.0`
    to `169.254.255.255`) is sent via the `enp0s8` device. This route is a very broad
    route but most likely does not impact our routing to the IP `192.168.33.11`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 第三条路由定义了所有来自`169.254.0.0/16`（`169.254.0.0`到`169.254.255.255`）的流量通过`enp0s8`设备发送。这是一个非常广泛的路由，但很可能不会影响我们到IP`192.168.33.11`的路由。
- en: '[PRE90]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The fourth and fifth route, however, will change how network packets to 192.168.33.11
    are routed.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第四和第五条路由将改变网络数据包到192.168.33.11的路由方式。
- en: '[PRE91]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The fourth route defines that all the traffic to the `192.168.33.0/24` (`192.168.33.0`
    to `192.168.33.255`) network is routed out of the `enp0s8` interface and sourced
    from `192.168.33.12`. This route appears to also be added automatically by the
    `enp0s8` interface's configuration; this is similar to the earlier route added
    by `enp0s3`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 第四条路由定义了所有流量到`192.168.33.0/24`（`192.168.33.0`到`192.168.33.255`）网络都从`enp0s8`接口路由，并且源自`192.168.33.12`。这条路由似乎也是由`enp0s8`接口的配置自动添加的；这与`enp0s3`添加的早期路由类似。
- en: Since the `enp0s8` device is defined to be a part of the `192.168.33.0/24` network,
    it only makes sense to route traffic for this network out of this interface.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`enp0s8`设备被定义为`192.168.33.0/24`网络的一部分，将该网络的流量路由到这个接口是合理的。
- en: '[PRE92]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The fifth route, however, defines that all traffic to the specific IP `192.168.33.11`
    (the blog server's IP) is sent to the gateway of `10.0.2.1` via the `enp0s3` device.
    This is interesting because the fifth route and the fourth route have a very conflicting
    configuration, as they both define what to do with IPs in the `192.168.33.0/24`
    network.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第五条路由定义了所有流量到特定IP`192.168.33.11`（博客服务器的IP）都通过`enp0s3`设备发送到`10.0.2.1`的网关。这很有趣，因为第五条路由和第四条路由有非常冲突的配置，因为它们都定义了对`192.168.33.0/24`网络中的IP该怎么做。
- en: More specific routes win
  id: totrans-419
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更具体的路由获胜
- en: As mentioned earlier, the *golden rule* of routing network packets is that the
    more specific route always wins. If we look at the routing configuration, we have
    one route that says all traffic in the `192.168.33.0/24` subnet should go out
    the `enp0s8` device. There is also a second route that says specifically `192.168.33.11`
    should go out through the `enp0s3` device. The IP `192.168.33.11` applies to both
    of these rules but which route should the system send packets through?
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，路由网络数据包的“黄金法则”是更具体的路由总是获胜。如果我们查看路由配置，我们有一个路由，它表示`192.168.33.0/24`子网中的所有流量应该从`enp0s8`设备出去。还有第二条路由，它明确表示`192.168.33.11`应该通过`enp0s3`设备出去。IP`192.168.33.11`适用于这两条规则，但系统应该通过哪条路由发送数据包呢？
- en: The answer is always the more specific route.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 答案总是更具体的路由。
- en: Since the second route specifically defines that all traffic to `192.168.33.11`
    goes out of the `enp0s3` interface, the kernel will route all return packets through
    the `enp0s3` interface. This is the case irrespective of the route defined for
    `192.168.33.0/24` or even the default route.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第二条路由明确定义了所有流量到`192.168.33.11`都从`enp0s3`接口出去，内核将通过`enp0s3`接口路由所有返回的数据包。这种情况不受`192.168.33.0/24`或甚至默认路由的影响。
- en: We can see all of this in action by using the `ip` command with the `route get`
    options.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用带有`route get`选项的`ip`命令来看到所有这些情况。
- en: '[PRE93]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The `ip` command with the `route get` options will take the IP provided and
    output which route the packets will take.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`route get`选项的`ip`命令将获取提供的IP并输出数据包将经过的路由。
- en: When we use this command with `192.168.33.11`, we can see that `ip` specifically
    shows that the route will be through the `enp0s3` device. If we use the same command
    with the other IPs, we can see how the default route and the `192.168.33.0/24`
    routes are used.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用这个命令与`192.168.33.11`一起使用时，我们可以看到`ip`明确显示数据包将通过`enp0s3`设备。如果我们使用相同的命令与其他IP一起使用，我们可以看到默认路由和`192.168.33.0/24`路由是如何使用的。
- en: '[PRE94]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We can see here that when an IP address that is within a subnet with a specific
    route defined is provided, this specific route is taken. However, when an IP is
    not defined by a specific route, the default route is taken.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，当提供一个特定路由定义的子网内的IP地址时，将采用这个特定路由。然而，当IP没有被特定路由定义时，将采用默认路由。
- en: Hypothesis
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假设
- en: Now that we understand how packets to `192.168.33.11` are routed, we should
    adjust our previous hypothesis to reflect that the route of `192.168.33.11` to
    `enp0s3` is not correct and is causing our issue.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了到`192.168.33.11`的数据包是如何路由的，我们应该调整我们之前的假设，以反映`192.168.33.11`到`enp0s3`的路由是不正确的，并且导致了我们的问题。
- en: Essentially, what is happening (and we see this via `tcpdump`) is that, when
    the database server (`192.168.33.12`) receives a network packet from the blog
    server (`192.168.33.11`), it arrives on the `enp0s8` device. However, when the
    database server is sending reply packets (`SYN-ACK`) to the web application server,
    the packets are being sent out via the `enp0s3` interface.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，正在发生的事情（我们通过`tcpdump`看到了这一点）是，当数据库服务器（`192.168.33.12`）从博客服务器（`192.168.33.11`）接收到网络数据包时，它是通过`enp0s8`设备到达的。然而，当数据库服务器发送回复数据包（`SYN-ACK`）到Web应用服务器时，数据包是通过`enp0s3`接口发送出去的。
- en: Since the `enp0s3` device is connected to the `10.0.2.0/24` network, it seems
    that the packet is being rejected (`RESET`) by another system or device on the
    `10.0.2.0/24` network. Most likely, this is due to the fact that this is a prime
    example of asynchronous routing.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`enp0s3`设备连接到`10.0.2.0/24`网络，似乎数据包被`10.0.2.0/24`网络上的另一个系统或设备拒绝（`RESET`）。很可能，这是由于这是异步路由的一个典型例子。
- en: Asynchronous routing is where a packet arrives on one interface but is replied
    to on another. In most network configurations, this is denied by default, but
    in some cases, can be enabled; however, these cases are not extremely common.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 异步路由是指数据包到达一个接口，但在另一个接口上回复。在大多数网络配置中，默认情况下是被拒绝的，但在某些情况下可以被启用；然而，这些情况并不是非常常见。
- en: In our case, since the `enp0s8` interface is part of the `192.168.33.0/24` subnet,
    it does not make sense to enable asynchronous routing. Our packets to `192.168.33.11`
    should simply be routed via the `enp0s8` interface.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，由于`enp0s8`接口是`192.168.33.0/24`子网的一部分，启用异步路由是没有意义的。我们的数据包到`192.168.33.11`应该简单地通过`enp0s8`接口路由。
- en: Trial and error
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反复试验
- en: 'Now that we have identified our issue with data collection and established
    a possible cause with our hypothesis, we can start our next troubleshooting step:
    using trial and error to correct the issue.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了数据收集的问题，并建立了我们的假设可能的原因，我们可以开始下一个故障排除步骤：使用试错法来纠正问题。
- en: Removing the invalid route
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除无效路由
- en: To correct our issue, we need to remove the invalid route for `192.168.33.11`.
    To do this, we will yet again use the `ip` command, this time with the `route
    del` options.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 为了纠正我们的问题，我们需要删除针对`192.168.33.11`的无效路由。为此，我们将再次使用`ip`命令，这次使用`route del`选项。
- en: '[PRE95]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In the preceding example, we used the `ip` command with the `route del` options
    to remove a route that targets a single IP. We can use the same command and options
    to remove routes that are defined for subnets. The following example will remove
    the route for the `169.254.0.0/16` network:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了`ip`命令和`route del`选项来删除针对单个IP的路由。我们可以使用相同的命令和选项来删除针对子网定义的路由。以下示例将删除`169.254.0.0/16`网络的路由：
- en: '[PRE96]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'From the `ip` route show execution, we can see that there is no longer a conflicting
    route for `192.168.33.11`. The question is: Did this fix our issue? The only way
    to know for sure is to test it and to do this we can simply refresh our browser
    that has the blog''s error page loaded.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ip route show`的执行中，我们可以看到`192.168.33.11`不再存在冲突的路由。问题是：这个修复了我们的问题吗？唯一确定的方法是测试它，为此我们可以简单地刷新加载了博客错误页面的浏览器。
- en: '![Removing the invalid route](img/00005.jpeg)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![删除无效路由](img/00005.jpeg)'
- en: It seems that we were successful at correcting the issue. If we perform a `tcpdump`
    now, we can validate that the blog and database servers are able to communicate.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 看来我们成功地纠正了问题。如果我们现在执行`tcpdump`，我们可以验证博客和数据库服务器能够通信。
- en: '[PRE97]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The preceding output is what we would expect to see from a healthy connection.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出是我们从一个健康的连接中期望看到的。
- en: Here, we see four packets, the first is an `SYN` (`Flags [S],`) from `blog.example.com`
    (`192.168.33.11`), followed by an `SYN-ACK` (`Flags [S.],`) from `db.example.com`
    (`192.168.33.12`) and an `ACK` (or `SYN-ACK-ACK`) (`Flags [.],`) from `blog.example.com`
    (`192.168.33.12`). These three packets are the completed TCP three-way handshake.
    The fourth packet is a `PUSH` (`Flags [P.],`) packet, which is the actual transfer
    of data. All of these are signs of a good working network connection.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到四个数据包，第一个是来自`blog.example.com`（`192.168.33.11`）的`SYN`（`Flags [S]`），接着是来自`db.example.com`（`192.168.33.12`）的`SYN-ACK`（`Flags
    [S.]`），以及来自`blog.example.com`（`192.168.33.12`）的`ACK`（或`SYN-ACK-ACK`）（`Flags [.]`）。这三个数据包是完成的TCP三次握手。第四个数据包是一个`PUSH`（`Flags
    [P.]`）数据包，这是实际的数据传输。所有这些都是良好工作的网络连接的迹象。
- en: Configuration files
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置文件
- en: Now that we have removed the invalid route from the routing table, we can see
    the blog is working; this means we have finished, right? No, not yet at least.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从路由表中删除了无效的路由，我们可以看到博客正在工作；这意味着我们已经完成了，对吗？不，至少还没有。
- en: When we removed the route by using the `ip` command, we removed the route from
    the active routing table, but we did not remove the route from the system as a
    whole. If we were to restart networking, or simply reboot the server, this invalid
    route would reappear.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`ip`命令删除路由时，我们从活动路由表中删除了路由，但没有从整个系统中删除路由。如果我们重新启动网络，或者简单地重新启动服务器，这个无效的路由将重新出现。
- en: '[PRE98]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This is because, when the system boots, it configures the network on the basis
    of the configurations within a set of files. The `ip` command is used to manipulate
    the live network configuration, but not these network configuration files. So,
    any change made with the `ip` command is not made permanently, but is only temporarily
    until the next time the system reads and applies the network configuration.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当系统启动时，它会根据一组文件中的配置来配置网络。`ip`命令用于操作实时网络配置，而不是这些网络配置文件。因此，使用`ip`命令进行的任何更改都不是永久性的，而只是暂时的，直到系统下一次读取和应用网络配置为止。
- en: In order to fully remove this route from the network configuration, we will
    need to modify the networking configuration files.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全从网络配置中删除这个路由，我们需要修改网络配置文件。
- en: '[PRE99]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: On Red Hat Enterprise Linux-based systems, the networking configuration files
    are mostly stored within the `/etc/sysconfig/network-scripts` folder. To get started,
    we can first switch to this folder and execute ls –la to identify the current
    network configuration files.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Red Hat企业Linux的系统上，网络配置文件大多存储在`/etc/sysconfig/network-scripts`文件夹中。首先，我们可以切换到这个文件夹并执行`ls
    -la`来识别当前的网络配置文件。
- en: '[PRE100]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: From the directory listing, we can see several configuration files. In general,
    however, we will mostly only be interested in files that begin with "`ifcfg-`"
    and files that begin with "`route-`."
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 从目录列表中，我们可以看到几个配置文件。然而，一般来说，我们主要只对以“ifcfg-”开头的文件和以“route-”开头的文件感兴趣。
- en: The files that begin with "`ifcfg-`" are used to define network interfaces;
    the naming convention of these files is "`ifcfg-<device name>`"; for example,
    to see `enp0s8's` configuration, we could read the `ifcfg-enp0s8` file.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 以`ifcfg-`开头的文件用于定义网络接口；这些文件的命名约定是“ifcfg-<设备名称>”；例如，要查看`enp0s8`的配置，我们可以读取`ifcfg-enp0s8`文件。
- en: '[PRE101]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We can see that this configuration file defines the IP address and `Netmask`
    used for this interface.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这个配置文件定义了用于这个接口的IP地址和“Netmask”。
- en: The "`route-`" files are used to define the system's routing configuration.
    The convention for this file is similar to that of the interface files, "`route-<device
    name>`." In the folder listing, there was only one route file, `route-enp0s3`.
    This is the most likely location for the incorrect route to be defined.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '"`route-`"文件用于定义系统的路由配置。这个文件的约定与接口文件的约定相似，即"`route-<设备名称>`"。在文件夹列表中，只有一个路由文件`route-enp0s3`。这是定义不正确路由的最可能位置。'
- en: '[PRE102]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: In general, unless a static route (routes that are statically defined) is defined,
    the "`route-*`" files do not exist. We can see here that only one route is defined
    in this file, which means that all the other routes defined in the routing table
    are dynamically configured on the basis of the interface configurations.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，除非定义了静态路由（静态定义的路由），否则"`route-*`"文件是不存在的。我们可以看到这里只定义了一个路由在这个文件中，这意味着路由表中定义的所有其他路由都是根据接口配置动态配置的。
- en: In the preceding example, the route defined in the `route-enp0s3` file does
    not specify an interface. Because of this, the interface will be defined on the
    basis of the filename; if this same entry were in the route-`enp0s8` file, the
    network service would attempt to define the route on the `enp0s8` interface.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`route-enp0s3`文件中定义的路由没有指定接口。因此，接口将根据文件名来定义；如果相同的条目出现在`route-enp0s8`文件中，网络服务将尝试在`enp0s8`接口上定义路由。
- en: To ensure that this route no longer appears in the routing table, we need to
    remove it from this file; alternatively, in this case, since it is the only route,
    we should remove the file in its entirety.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这个路由不再出现在路由表中，我们需要从这个文件中删除它；或者，在这种情况下，因为它是唯一的路由，我们应该完全删除这个文件。
- en: '[PRE103]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The decision to remove the file and the route is dependent on the environment
    being supported; if you are ever unsure if this is the correct action, you should
    ask someone who can tell you if it is or isn't beforehand. For this example, we
    will assume that it is OK to remove this network configuration file.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 决定删除文件和路由取决于所支持的环境；如果您不确定这是否是正确的操作，应该询问能告诉您事先是否正确的人。在这个例子中，我们将假设可以删除这个网络配置文件。
- en: After restarting the network service, we should see the route disappear.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动网络服务后，我们应该看到路由消失。
- en: '[PRE104]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Now that the route is gone and the network configurations have been reloaded,
    we can safely say that we have corrected the issue. We can validate this by once
    again loading the webpage to ensure that the blog is working.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 现在路由已经消失，网络配置已经重新加载，我们可以安全地说我们已经解决了问题。我们可以通过再次加载网页来验证这一点，以确保博客正常工作。
- en: '![Configuration files](img/00006.jpeg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![配置文件](img/00006.jpeg)'
- en: Summary
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: If we look back at this chapter, we learned quite a bit about troubleshooting
    network connectivity issues on Linux. We learned how to use the `netstat` and
    `tcpdump` tools to look at the incoming and outgoing connections. We learned about
    the TCP three-way handshake and how the `/etc/hosts` file can supersede the DNS
    settings.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下本章，我们对在Linux上解决网络连接问题学到了很多。我们学会了如何使用`netstat`和`tcpdump`工具来查看传入和传出的连接。我们了解了TCP的三次握手以及`/etc/hosts`文件如何取代DNS设置。
- en: In this chapter, we covered many commands, and while we gave a pretty good overview
    of each command and what it does, there are some that we barely scratched the
    surface on.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了许多命令，虽然我们对每个命令及其功能都有一个相当好的概述，但有一些命令我们只是浅尝辄止。
- en: Commands such as `tcpdump` are a prime example of this. In this chapter, we
    used `tcpdump` quite a bit, but this tool is capable of far more than we used
    it for. Of all of the commands that we covered in this book, I personally feel
    that `tcpdump` is one to spend time learning, as it is a very useful and powerful
    tool. I have used it to solve many issues, and sometimes, these issues were not
    network-specific but application-specific.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`tcpdump`之类的命令就是一个很好的例子。在本章中，我们使用了`tcpdump`相当多，但这个工具的功能远不止我们在本章中使用的那些。在本书中涵盖的所有命令中，我个人认为`tcpdump`是一个值得花时间学习的工具，因为它是一个非常有用和强大的工具。我用它解决了许多问题，有时这些问题不是特定于网络，而是特定于应用程序的。
- en: In this next chapter, we will keep this networking momentum going with troubleshooting
    firewalls. We will probably see some of the same commands that we used in this
    chapter reappear in the next chapter, but this is OK; it just shows how important
    it is to understand networking and the tools to troubleshoot it.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续保持这种网络动力，解决防火墙问题。我们可能会看到一些在本章中使用的相同命令在下一章中再次出现，但这没关系；这只是显示了理解网络和故障排除工具的重要性。
