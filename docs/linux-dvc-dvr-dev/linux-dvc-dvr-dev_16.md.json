["```\nstruct irq_chip { \n   struct device *parent_device; \n   const char  *name; \n   void (*irq_enable)(struct irq_data *data); \n   void (*irq_disable)(struct irq_data *data); \n\n   void (*irq_ack)(struct irq_data *data); \n   void (*irq_mask)(struct irq_data *data); \n   void (*irq_unmask)(struct irq_data *data); \n   void (*irq_eoi)(struct irq_data *data); \n\n   int (*irq_set_affinity)(struct irq_data *data, const struct cpumask *dest, bool force); \n   int (*irq_retrigger)(struct irq_data *data); \n   int (*irq_set_type)(struct irq_data *data, unsigned int flow_type); \n   int (*irq_set_wake)(struct irq_data *data, unsigned int on); \n\n   void (*irq_bus_lock)(struct irq_data *data); \n   void (*irq_bus_sync_unlock)(struct irq_data *data); \n\n   int (*irq_get_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool *state); \n   int(*irq_set_irqchip_state)(struct irq_data *data, enum irqchip_irq_state which, bool state); \n\n   unsigned long flags; \n}; \n```", "```\nstruct irq_domain { \n   const char *name; \n   const struct irq_domain_ops *ops; \n   void *host_data; \n   unsigned int flags; \n\n   /* Optional data */ \n   struct fwnode_handle *fwnode; \n   [...] \n}; \n```", "```\nstruct irq_domain *irq_domain_add_linear(struct device_node *of_node, \n                            unsigned int size, \n                            const struct irq_domain_ops *ops, \n                            void *host_data) \n```", "```\nstruct irq_domain *irq_domain_add_tree(struct device_node *of_node, \n                                  const struct irq_domain_ops *ops, \n                                  void *host_data) \n```", "```\nstruct irq_domain *irq_domain_add_nomap(struct device_node *of_node, \n                              unsigned int max_irq, \n                              const struct irq_domain_ops *ops, \n                              void *host_data)  \n```", "```\nunsigned int irq_create_mapping(struct irq_domain *domain, \n                                irq_hw_number_t hwirq) \n```", "```\nreturn irq_create_mapping(gpiochip->irq_domain, offset); \n```", "```\nfor (j = 0; j < gpiochip->chip.ngpio; j++) { \n      irq = irq_create_mapping( \n                 gpiochip ->irq_domain, j); \n} \n```", "```\nstruct irq_domain_ops { \n   int (*map)(struct irq_domain *d, unsigned int virq, irq_hw_number_t hw); \n   void (*unmap)(struct irq_domain *d, unsigned int virq); \n   int (*xlate)(struct irq_domain *d, struct device_node *node, \n              const u32 *intspec, unsigned int intsize, \n              unsigned long *out_hwirq, unsigned int *out_type); \n}; \n```", "```\nvoid irq_set_chip_and_handler(unsigned int irq, \n          struct irq_chip *chip, irq_flow_handler_t handle) \n```", "```\n    static int pcf857x_irq_domain_map(struct irq_domain  *domain, \n                            unsigned int irq, irq_hw_number_t hw) \n    { \n       struct pcf857x *gpio = domain->host_data; \n\n       irq_set_chip_and_handler(irq, &dummy_irq_chip,handle_level_irq); \n    #ifdef CONFIG_ARM \n       set_irq_flags(irq, IRQF_VALID); \n    #else \n       irq_set_noprobe(irq); \n    #endif \n       gpio->irq_mapped |= (1 << hw); \n\n       return 0; \n    } \n```", "```\nstatic struct irq_domain_ops mcp23016_irq_domain_ops = { \n   .map  = mcp23016_irq_domain_map, \n   .xlate  = irq_domain_xlate_twocell, \n}; \n```", "```\nstruct irq_desc { \n   struct irq_common_data irq_common_data; \n   struct irq_data irq_data; \n   unsigned int __percpu *kstat_irqs; \n   irq_flow_handler_t handle_irq; \n   struct irqaction *action; \n   unsigned int irqs_unhandled; \n   raw_spinlock_t lock; \n   struct cpumask *percpu_enabled; \n   atomic_t threads_active; \n   wait_queue_head_t wait_for_threads; \n#ifdef CONFIG_PM_SLEEP \n   unsigned int nr_actions; \n   unsigned int no_suspend_depth; \n   unsigned int  force_resume_depth; \n#endif \n#ifdef CONFIG_PROC_FS \n   struct proc_dir_entry *dir; \n#endif \n   int parent_irq; \n   struct module *owner; \n   const char *name; \n}; \n```", "```\nstruct irqaction { \n   irq_handler_t handler; \n   void *dev_id; \n   void __percpu *percpu_dev_id; \n   struct irqaction *next; \n   irq_handler_t thread_fn; \n   struct task_struct *thread; \n   unsigned int irq; \n   unsigned int flags; \n   unsigned long thread_flags; \n   unsigned long thread_mask; \n   const char *name; \n   struct proc_dir_entry *dir; \n}; \n```", "```\nstruct irq_data { \n   [...] \n   unsigned int irq; \n   unsigned long hwirq; \n   struct irq_common_data *common; \n   struct irq_chip *chip; \n   struct irq_domain *domain; \n   void *chip_data; \n}; \n```", "```\nint request_any_context_irq ( unsigned int irq, irq_handler_t handler, \n             unsigned long flags,  const char * name,  void * dev_id); \n```", "```\nstatic irqreturn_t packt_btn_interrupt(int irq, void *dev_id) \n{ \n    struct btn_data *priv = dev_id; \n\n   input_report_key(priv->i_dev, BTN_0, \n                    gpiod_get_value(priv->btn_gpiod) & 1); \n    input_sync(priv->i_dev); \n   return IRQ_HANDLED; \n} \n\nstatic int btn_probe(struct platform_device *pdev) \n{ \n    struct gpio_desc *gpiod; \n    int ret, irq; \n\n    [...] \n    gpiod = gpiod_get(&pdev->dev, \"button\", GPIOD_IN); \n    if (IS_ERR(gpiod)) \n        return -ENODEV; \n\n    priv->irq = gpiod_to_irq(priv->btn_gpiod); \n    priv->btn_gpiod = gpiod; \n\n    [...] \n\n    ret = request_any_context_irq(priv->irq, \n                  packt_btn_interrupt, \n                  (IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING), \n                  \"packt-input-button\", priv); \n    if (ret < 0) { \n        dev_err(&pdev->dev, \n            \"Unable to acquire interrupt for GPIO line\\n\"); \n        goto err_btn; \n    } \n\n    return ret; \n} \n```", "```\nint request_threaded_irq(unsigned int irq, irq_handler_t handler, \n                  irq_handler_t thread_fn, unsigned long irqflags, \n                  const char *devname, void *dev_id) \n```", "```\naction->handler = handler; \naction->thread_fn = thread_fn; \naction->flags = irqflags; \naction->name = devname; \naction->dev_id = dev_id; \n```", "```\nhandle_arch_irq = mdesc->handle_irq \n```", "```\nset_handle_irq(gic_handle_irq); \n```", "```\nmy_gpiochip->irq_domain = irq_domain_add_linear( client->dev.of_node, \n             my_gpiochip->chip.ngpio, &mcp23016_irq_domain_ops, NULL); \n```", "```\nstatic struct irq_domain_ops mcp23016_irq_domain_ops = { \n   .map  = mcp23016_irq_domain_map, \n   .xlate  = irq_domain_xlate_twocell, \n}; \n```", "```\nstatic int mcp23016_irq_domain_map( \n              struct irq_domain *domain, \n              unsigned int virq, irq_hw_number_t hw) \n{ \n   irq_set_chip_and_handler(virq, \n               &dummy_irq_chip, /* Dumb irqchip */ \n               handle_level_irq); /* Level trigerred irq */ \n   return 0; \n} \n```", "```\nstatic int mcp23016_to_irq(struct gpio_chip *chip, \n                           unsigned offset) \n{ \n   return irq_create_mapping(chip->irq_domain, offset); \n} \n```", "```\ndevm_request_threaded_irq(client->irq, NULL, \n                          mcp23016_irq, irqflags, \n                          dev_name(chip->parent), mcp); \n```", "```\nstatic irqreturn_t mcp23016_irq(int irq, void *data) \n{ \n    struct mcp23016 *mcp = data; \n    unsigned int child_irq, i; \n    /* Do some stuff */ \n    [...] \n    for (i = 0; i < mcp->chip.ngpio; i++) { \n        if (gpio_value_changed_and_raised_irq(i)) { \n            child_irq = \n                  irq_find_mapping(mcp->chip.irqdomain, i); \n            handle_nested_irq(child_irq); \n        } \n    } \n\n    return IRQ_HANDLED; \n} \n```", "```\nint gpiochip_irqchip_add(struct gpio_chip *gpiochip, \n                struct irq_chip *irqchip, \n                unsigned int first_irq, \n                irq_flow_handler_t handler, \n                unsigned int type) \n```", "```\nstatic const struct irq_domain_ops gpiochip_domain_ops = { \n   .map  = gpiochip_irq_map, \n   .unmap = gpiochip_irq_unmap, \n   /* Virtually all GPIO irqchips are twocell:ed */ \n   .xlate = irq_domain_xlate_twocell, \n}; \n```", "```\nvoid gpiochip_set_chained_irqchip(struct gpio_chip *gpiochip, \n                       struct irq_chip *irqchip, int parent_irq, \n                       irq_flow_handler_t parent_handler) \n```", "```\n/* Do we have an interrupt line? Enable the irqchip */ \nif (client->irq) { \n    status = gpiochip_irqchip_add(&gpio->chip, &dummy_irq_chip, \n                            0, handle_level_irq, IRQ_TYPE_NONE); \n    if (status) { \n        dev_err(&client->dev, \"cannot add irqchip\\n\"); \n        goto fail_irq; \n    } \n\n    status = devm_request_threaded_irq(&client->dev, client->irq, \n                           NULL, mcp23016_irq, IRQF_ONESHOT | \n                           IRQF_TRIGGER_FALLING | IRQF_SHARED, \n                           dev_name(&client->dev), gpio); \n    if (status) \n       goto fail_irq; \n\n    gpiochip_set_chained_irqchip(&gpio->chip, \n                            &dummy_irq_chip, client->irq, NULL); \n} \n```", "```\nexpander: mcp23016@20 { \n    compatible = \"microchip,mcp23016\"; \n    reg = <0x20>; \n    interrupt-controller; \n    #interrupt-cells = <2>; \n    gpio-controller; \n    #gpio-cells = <2>; \n    interrupt-parent = <&gpio4>; \n    interrupts = <29 IRQ_TYPE_EDGE_FALLING>; \n}; \n```", "```\nfoo_device: foo_device@1c { \n    reg = <0x1c>; \n    interrupt-parent = <&expander>; \n    interrupts = <2 IRQ_TYPE_EDGE_RISING>; \n}; \n\nbar_device { \n    reset-gpios = <&expander 8 GPIO_ACTIVE_HIGH>; \n    power-gpios = <&expander 12 GPIO_ACTIVE_HIGH>; \n    /* Other properties do here */ \n}; \n```"]