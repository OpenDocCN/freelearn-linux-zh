["```\nstruct watchdog_device {\n\u00a0\u00a0\u00a0\u00a0int id;\n\u00a0\u00a0\u00a0\u00a0struct device *parent;\n\u00a0\u00a0\u00a0\u00a0const struct watchdog_info *info;\n\u00a0\u00a0\u00a0\u00a0const struct watchdog_ops *ops;\n\u00a0\u00a0\u00a0\u00a0const struct watchdog_governor *gov;\n\u00a0\u00a0\u00a0\u00a0unsigned int bootstatus;\n\u00a0\u00a0\u00a0\u00a0unsigned int timeout;\n\u00a0\u00a0\u00a0\u00a0unsigned int pretimeout;\n\u00a0\u00a0\u00a0\u00a0unsigned int min_timeout;\n\u00a0\u00a0\u00a0\u00a0struct watchdog_core_data *wd_data;\n\u00a0\u00a0\u00a0\u00a0unsigned long status;\n\u00a0\u00a0\u00a0\u00a0[...]\n};\n```", "```\nstruct watchdog_info {\n\u00a0\u00a0\u00a0\u00a0u32 options;\n\u00a0\u00a0\u00a0\u00a0u32 firmware_version;\n\u00a0\u00a0\u00a0\u00a0u8 identity[32];\n};\n```", "```\nstruct watchdog_ops { struct module *owner;\n\u00a0\u00a0\u00a0\u00a0/* mandatory operations */\n\u00a0\u00a0\u00a0\u00a0int (*start)(struct watchdog_device *);\n\u00a0\u00a0\u00a0\u00a0int (*stop)(struct watchdog_device *);\n\u00a0\u00a0\u00a0\u00a0/* optional operations */\n\u00a0\u00a0\u00a0\u00a0int (*ping)(struct watchdog_device *);\n\u00a0\u00a0\u00a0\u00a0unsigned int (*status)(struct watchdog_device *);\n\u00a0\u00a0\u00a0\u00a0int (*set_timeout)(struct watchdog_device *, unsigned int);\n\u00a0\u00a0\u00a0\u00a0int (*set_pretimeout)(struct watchdog_device *, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int);\n\u00a0\u00a0\u00a0\u00a0unsigned int (*get_timeleft)(struct watchdog_device *);\n\u00a0\u00a0\u00a0\u00a0int (*restart)(struct watchdog_device *, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long, void *);\n\u00a0\u00a0\u00a0\u00a0long (*ioctl)(struct watchdog_device *, unsigned int,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long);\n};\n```", "```\nint watchdog_register_device(struct watchdog_device *wdd)\nvoid watchdog_unregister_device(struct watchdog_device *wdd)\n```", "```\nint devm_watchdog_register_device(struct device *dev, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct watchdog_device *wdd)\n```", "```\n[...]\nstruct imx2_wdt_device {\n\u00a0\u00a0\u00a0\u00a0struct clk *clk;\n\u00a0\u00a0\u00a0\u00a0struct regmap *regmap;\n\u00a0\u00a0\u00a0\u00a0struct watchdog_device wdog;\n\u00a0\u00a0\u00a0\u00a0bool ext_reset;\n};\n```", "```\nstatic int init imx2_wdt_probe(struct platform_device *pdev)\n{\n\u00a0\u00a0\u00a0\u00a0struct imx2_wdt_device *wdev;\n\u00a0\u00a0\u00a0\u00a0struct watchdog_device *wdog; int ret;\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0wdev = devm_kzalloc(&pdev->dev, sizeof(*wdev), GFP_KERNEL);\n\u00a0\u00a0\u00a0\u00a0if (!wdev)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -ENOMEM;\n\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0Wdog = &wdev->wdog;\n\u00a0\u00a0\u00a0\u00a0if (imx2_wdt_is_running(wdev)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0imx2_wdt_set_timeout(wdog, wdog->timeout); \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0set_bit(WDOG_HW_RUNNING, &wdog->status);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0ret = watchdog_register_device(wdog);\n\u00a0\u00a0\u00a0\u00a0if (ret) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dev_err(&pdev->dev, \"cannot register watchdog device\\n\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\nstatic int exit imx2_wdt_remove(struct platform_device *pdev)\n{\n\u00a0\u00a0\u00a0\u00a0struct watchdog_device *wdog = platform_get_drvdata(pdev);\n\u00a0\u00a0\u00a0\u00a0struct imx2_wdt_device *wdev = watchdog_get_drvdata(wdog);\n\u00a0\u00a0\u00a0\u00a0watchdog_unregister_device(wdog);\n\u00a0\u00a0\u00a0\u00a0if (imx2_wdt_is_running(wdev)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0imx2_wdt_ping(wdog);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dev_crit(&pdev->dev, \"Device removed: Expect reboot!\\n\");\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n[...]\n```", "```\nvoid watchdog_notify_pretimeout(struct watchdog_device *wdd)\n```", "```\nstruct watchdog_governor {\n\u00a0\u00a0\u00a0\u00a0const char name[WATCHDOG_GOV_NAME_MAXLEN];\n\u00a0\u00a0\u00a0\u00a0void (*pretimeout)(struct watchdog_device *wdd);\n};\n```", "```\nwatchdog: watchdog {\n\u00a0\u00a0\u00a0\u00a0compatible = \"linux,wdt-gpio\";\n\u00a0\u00a0\u00a0\u00a0gpios = <&gpio3 9 GPIO_ACTIVE_LOW>;\n\u00a0\u00a0\u00a0\u00a0hw_algo = \"toggle\";\n\u00a0\u00a0\u00a0\u00a0hw_margin_ms = <1600>;\n};\n```", "```\nint fd;\nfd = open(\"/dev/watchdog\", O_WRONLY);\nif (fd == -1) {\n\u00a0\u00a0\u00a0\u00a0if (errno == ENOENT)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0printf(\"Watchdog device not enabled.\\n\");\n\u00a0\u00a0\u00a0\u00a0else if (errno == EACCES)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0printf(\"Run watchdog as root.\\n\");\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0printf(\"Watchdog device open failed %s\\n\", strerror(errno));\n\u00a0\u00a0\u00a0\u00a0exit(-1);\n}\n```", "```\nconst char v = 'V';\nprintf(\"Send magic character: V\\n\"); ret = write(fd, &v, 1);\nif (ret < 0)\n\u00a0\u00a0\u00a0\u00a0printf(\"Stopping watchdog ticks failed (%d)...\\n\", errno);\n```", "```\nprintf(\"Close for stopping..\\n\");\nclose(fd);\n```", "```\nstruct watchdog_info ident;\nioctl(fd, WDIOC_GETSUPPORT, &ident);\nprintf(\"WDIOC_GETSUPPORT:\\n\");\n/* Printing the watchdog's identity, its unique name actually */\nprintf(\"\\tident.identity = %s\\n\",ident.identity);\n/* Printing the firmware version */\nprintf(\"\\tident.firmware_version = %d\\n\", \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ident.firmware_version);\n/* Printing supported options (capabilities) in hex format */\nprintf(\"WDIOC_GETSUPPORT: ident.options = 0x%x\\n\",\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ident.options);\n```", "```\nif (ident.options & WDIOF_KEEPALIVEPING)\n\u00a0\u00a0\u00a0\u00a0printf(\"\\tKeep alive ping reply.\\n\");\nif (ident.options & WDIOF_SETTIMEOUT)\n\u00a0\u00a0\u00a0\u00a0printf(\"\\tCan set/get the timeout.\\n\");\n```", "```\nint timeout = 45;\nioctl(fd, WDIOC_SETTIMEOUT, &timeout);\nprintf(\"The timeout was set to %d seconds\\n\", timeout);\n```", "```\nint timeout;\nioctl(fd, WDIOC_GETTIMEOUT, &timeout);\nprintf(\"The timeout is %d seconds\\n\", timeout);\n```", "```\npretimeout = 10;\nioctl(fd, WDIOC_SETPRETIMEOUT, &pretimeout);\n```", "```\nint timeleft;\nioctl(fd, WDIOC_GETTIMELEFT, &timeleft);\nprintf(\"The remaining timeout is %d seconds\\n\", timeleft);\n```", "```\nstatic unsigned int watchdog_get_status(struct \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0watchdog_device *wdd)\n{\n\u00a0\u00a0\u00a0\u00a0struct watchdog_core_data *wd_data = wdd->wd_data;\n\u00a0\u00a0\u00a0\u00a0unsigned int status;\n\u00a0\u00a0\u00a0\u00a0if (wdd->ops->status)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0status = wdd->ops->status(wdd);\n\u00a0\u00a0\u00a0\u00a0else\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0status = wdd->bootstatus &\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(WDIOF_CARDRESET | WDIOF_OVERHEAT |\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WDIOF_FANFAULT | WDIOF_EXTERN1 |\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WDIOF_EXTERN2 | WDIOF_POWERUNDER |\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WDIOF_POWEROVER);\n\u00a0\u00a0\u00a0\u00a0if (test_bit(_WDOG_ALLOW_RELEASE, &wd_data->status))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0status |= WDIOF_MAGICCLOSE;\n\u00a0\u00a0\u00a0\u00a0if (test_and_clear_bit(_WDOG_KEEPALIVE, &wd_data->status))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0status |= WDIOF_KEEPALIVEPING;\n\u00a0\u00a0\u00a0\u00a0return status;\n}\n```", "```\nint flags = 0;\nint flags;\nioctl(fd, WDIOC_GETSTATUS, &flags);\n/* or ioctl(fd, WDIOC_GETBOOTSTATUS, &flags); */\n```", "```\n# cat /sys/class/watchdog/watchdog0/pretimeout_available_governors\nnoop panic\n```", "```\n# cat /sys/class/watchdog/watchdog0/pretimeout_governor\npanic\n# echo -n noop > /sys/class/watchdog/watchdog0/pretimeout_governor\n# cat /sys/class/watchdog/watchdog0/pretimeout_governor\nnoop\n```", "```\n# cat /sys/class/watchdog/watchdog0/pretimeout\n10\n```"]