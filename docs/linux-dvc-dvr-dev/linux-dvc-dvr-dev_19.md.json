["```\n#include <linux/pwm.h> \n```", "```\nstruct pwm_chip { \n   struct device *dev; \n   const struct pwm_ops *ops; \n   int base; \n   unsigned int npwm; \n\n   struct pwm_device *pwms; \n   struct pwm_device * (*of_xlate)(struct pwm_chip *pc, \n                    const struct of_phandle_args *args); \n   unsigned int of_pwm_n_cells; \n   bool can_sleep; \n}; \n```", "```\nint pwmchip_add(struct pwm_chip *chip) \nint pwmchip_remove(struct pwm_chip *chip) \n```", "```\nstruct pwm_ops { \n   int (*request)(struct pwm_chip *chip, struct pwm_device *pwm); \n   void (*free)(struct pwm_chip *chip, struct pwm_device *pwm); \n   int (*config)(struct pwm_chip *chip, struct pwm_device *pwm, \n                           int duty_ns, int period_ns); \n   int (*set_polarity)(struct pwm_chip *chip, struct pwm_device *pwm, \n                           enum pwm_polarity polarity); \n   int (*enable)(struct pwm_chip *chip,struct pwm_device *pwm); \n   void (*disable)(struct pwm_chip *chip, struct pwm_device *pwm); \n   void (*get_state)(struct pwm_chip *chip, struct pwm_device *pwm, \n                struct pwm_state *state); /* since kernel v4.7 */ \n   struct module *owner; \n}; \n```", "```\n#include <linux/module.h> \n#include <linux/of.h> \n#include <linux/platform_device.h> \n#include <linux/pwm.h> \n\nstruct fake_chip { \n   struct pwm_chip chip; \n   int foo; \n   int bar; \n   /* put the client structure here (SPI/I2C) */ \n}; \n\nstatic inline struct fake_chip *to_fake_chip(struct pwm_chip *chip) \n{ \n   return container_of(chip, struct fake_chip, chip); \n} \n\nstatic int fake_pwm_request(struct pwm_chip *chip, \n                               struct pwm_device *pwm) \n{ \n   /* \n    * One may need to do some initialization when a PWM channel \n    * of the controller is requested. This should be done here. \n    * \n    * One may do something like  \n    *     prepare_pwm_device(struct pwm_chip *chip, pwm->hwpwm); \n    */ \n\n   return 0; \n} \n\nstatic int fake_pwm_config(struct pwm_chip *chip, \n                       struct pwm_device *pwm, \n                      int duty_ns, int period_ns) \n{ \n\n    /* \n     * In this function, one ne can do something like: \n     *      struct fake_chip *priv = to_fake_chip(chip); \n     * \n     *      return send_command_to_set_config(priv, \n     *                      duty_ns, period_ns); \n     */ \n\n   return 0; \n} \n\nstatic int fake_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm) \n{ \n    /* \n     * In this function, one ne can do something like: \n     *  struct fake_chip *priv = to_fake_chip(chip); \n     * \n     * return foo_chip_set_pwm_enable(priv, pwm->hwpwm, true); \n     */ \n\n    pr_info(\"Somebody enabled PWM device number %d of this chip\", \n             pwm->hwpwm); \n   return 0; \n} \n\nstatic void fake_pwm_disable(struct pwm_chip *chip, \n                              struct pwm_device *pwm) \n{ \n    /* \n     * In this function, one ne can do something like: \n     *  struct fake_chip *priv = to_fake_chip(chip); \n     * \n     * return foo_chip_set_pwm_enable(priv, pwm->hwpwm, false); \n     */ \n\n    pr_info(\"Somebody disabled PWM device number %d of this chip\", \n              pwm->hwpwm); \n} \n\nstatic const struct pwm_ops fake_pwm_ops = { \n   .request = fake_pwm_request, \n   .config = fake_pwm_config, \n   .enable = fake_pwm_enable, \n   .disable = fake_pwm_disable, \n   .owner = THIS_MODULE, \n}; \n\nstatic int fake_pwm_probe(struct platform_device *pdev) \n{ \n   struct fake_chip *priv; \n\n   priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL); \n   if (!priv) \n         return -ENOMEM; \n\n   priv->chip.ops = &fake_pwm_ops; \n   priv->chip.dev = &pdev->dev; \n   priv->chip.base = -1;   /* Dynamic base */ \n   priv->chip.npwm = 3;    /* 3 channel controller */  \n\n   platform_set_drvdata(pdev, priv); \n   return pwmchip_add(&priv->chip); \n} \n\nstatic int fake_pwm_remove(struct platform_device *pdev) \n{ \n   struct fake_chip *priv = platform_get_drvdata(pdev); \n   return pwmchip_remove(&priv->chip); \n} \n\nstatic const struct of_device_id fake_pwm_dt_ids[] = { \n   { .compatible = \"packt,fake-pwm\", }, \n   { } \n}; \nMODULE_DEVICE_TABLE(of, fake_pwm_dt_ids); \n\nstatic struct platform_driver fake_pwm_driver = { \n   .driver = { \n         .name = KBUILD_MODNAME, \n.owner = THIS_MODULE, \n         .of_match_table = of_match_ptr(fake_pwm_dt_ids), \n   }, \n   .probe = fake_pwm_probe, \n   .remove = fake_pwm_remove, \n}; \nmodule_platform_driver(fake_pwm_driver); \n\nMODULE_AUTHOR(\"John Madieu <john.madieu@gmail.com>\"); \nMODULE_DESCRIPTION(\"Fake pwm driver\"); \nMODULE_LICENSE(\"GPL\"); \n```", "```\npwm3: pwm@02088000 { \n    #pwm-cells = <2>; \n    compatible = \"fsl,imx6q-pwm\", \"fsl,imx27-pwm\"; \n    reg = <0x02088000 0x4000>; \n    interrupts = <0 85 IRQ_TYPE_LEVEL_HIGH>; \n    clocks = <&clks IMX6QDL_CLK_IPG>, \n         <&clks IMX6QDL_CLK_PWM3>; \n    clock-names = \"ipg\", \"per\"; \n    status = \"disabled\"; \n}; \n```", "```\nfake_pwm: pwm@0 { \n    #pwm-cells = <2>; \n    compatible = \"packt,fake-pwm\"; \n    /*  \n     * Our driver does not use resource  \n     * neither mem, IRQ, nor Clock) \n     */ \n}; \n```", "```\nstruct pwm_device { \n   const char *label; \n   unsigned long flags; \n   unsigned int hwpwm; \n   unsigned int pwm; \n   struct pwm_chip *chip; \n   void *chip_data; \n\n  unsigned int period;     /* in nanoseconds */ \n  unsigned int duty_cycle; /* in nanoseconds */ \n  enum pwm_polarity polarity; \n}; \n```", "```\nstruct pwm_device { \n   const char *label; \n   unsigned long flags; \n   unsigned int hwpwm; \n   unsigned int pwm; \n   struct pwm_chip *chip; \n   void *chip_data; \n\n   struct pwm_args args; \n   struct pwm_state state; \n}; \n```", "```\nstruct pwm_args { \n   unsigned int period; /* Device's nitial period */ \n   enum pwm_polarity polarity; \n}; \n\nstruct pwm_state { \n   unsigned int period; /* PWM period (in nanoseconds) */ \n   unsigned int duty_cycle; /* PWM duty cycle (in nanoseconds) */ \n   enum pwm_polarity polarity; /* PWM polarity */ \n   bool enabled; /* PWM enabled status */ \n} \n```", "```\nstruct pwm_device *pwm_get(struct device *dev, const char *con_id) \nvoid pwm_put(struct pwm_device *pwm) \n```", "```\nint pwm_config(struct pwm_device *pwm, int duty_ns, int period_ns); \n```", "```\nint pwm_enable(struct pwm_device *pwm) \nvoid pwm_disable(struct pwm_device *pwm) \n```", "```\nstatic void pwm_led_drive(struct pwm_device *pwm, \n                      struct private_data *priv) \n{ \n    /* Configure the PWM, applying a period and duty cycle */ \n    pwm_config(pwm, priv->duty, priv->pwm_period); \n\n    /* Start toggling */ \n    pwm_enable(pchip->pwmd); \n\n    [...] /* Do some work */ \n\n    /* And then stop toggling*/ \n    pwm_disable(pchip->pwmd); \n} \n```", "```\npwm: pwm { \n    #pwm-cells = <2>; \n}; \n\n[...] \n\nbl: backlight { \npwms = <&pwm 0 5000000>; \n   pwm-names = \"backlight\"; \n}; \n```", "```\npwms = <&pwm 0 5000000>; \n```", "```\nstatic int my_consummer_probe(struct platform_device *pdev) \n{ \n    struct pwm_device *pwm; \n\n    pwm = pwm_get(&pdev->dev, \"backlight\"); \n    if (IS_ERR(pwm)) { \n       pr_info(\"unable to request PWM, trying legacy API\\n\"); \n       /* \n        * Some drivers use the legacy API as fallback, in order \n        * to request a PWM ID, global to the system \n        * pwm = pwm_request(global_pwm_id, \"pwm beeper\"); \n        */ \n    } \n\n    [...] \n    return 0; \n} \n```", "```\n # echo 1 > /sys/class/pwm/pwmchip<pwmchipnr>/pwm<pwmnr>/enable\n\n```", "```\n# echo **<value in nanoseconds> >** \n\n/sys/class/pwm/pwmchip**<pwmchipnr>**\n\n/pwm**<pwmnr>**\n\n/period\n\n```", "```\n# echo **<value in nanoseconds>**\n\n > /sys/class/pwm/pwmchip**<pwmchipnr>**\n\n/pwm**<pwmnr>**\n\n/duty_cycle\n\n```", "```\n # echo 0 > /sys/class/pwm/pwmchip<pwmchipnr>/pwm<pwmnr>/enable \n\n```"]