# 第八章：附加信息：使用字符驱动程序

# 与字符驱动程序交换数据

与外围设备交换数据意味着向其发送或接收数据，为此，我们已经看到我们必须使用在内核中定义的`write()`和`read()`系统调用的原型。

```
ssize_t write(struct file *filp,
              const char __user *buf, size_t count,
              loff_t *ppos);
ssize_t read(struct file *filp,
              char __user *buf, size_t count,
              loff_t *ppos);
```

另一方面，它们在用户空间中的对应形式如下：

```
ssize_t write(int fd, const void *buf, size_t count);
ssize_t read(int fd, void *buf, size_t count);
```

前面的原型（无论是在内核空间还是用户空间）看起来很相似，但是它们的含义当然是不同的，作为驱动程序开发人员，我们必须完全了解这些含义，以便准确地完成我们的工作。

让我们从`write()`开始；当我们从用户空间程序调用`write()`系统调用时，我们必须提供一个文件描述符`fd`；一个填充有要写入的数据的缓冲区`buf`；以及缓冲区大小`count`。然后，系统调用返回一个值，可以是负值（如果有错误），正值（表示实际写入的字节数），或零（表示没有写入任何内容）。

请注意，`count`并不代表我们希望写入多少字节，而只是缓冲区的大小！实际上，`write()`可以返回一个小于`count`的正值。这就是为什么我在`chrdev_test.c`程序的`write()`系统调用中使用了`for()`循环！实际上，如果我必须写入一个长度为 10 字节的缓冲区，而`write()`返回了 4 字节，我必须重复调用它，直到剩下的 6 字节都被写入。

从内核空间的角度来看，我们将文件描述符`fd`视为`struct file *filp`（存储有关文件描述符的内核信息），而数据缓冲区由`buf`指针和`count`变量指定（暂时不考虑`ppos`指针；稍后将对其进行解释）。

从`write()`内核原型中可以看出，`buf`参数带有`__user`属性，这表明这个缓冲区来自用户空间，因此我们不能直接从中读取。实际上，这个内存区域是虚拟的，因此在执行我们的驱动程序的`write()`方法时，它实际上不能映射到真正的物理内存中！为了解决这种情况，内核提供了`copy_from_user()`函数，如下所示：

```
unsigned long copy_from_user(void *to,
                   const void __user *from, unsigned long n);
```

正如我们所看到的，这个函数从用户空间缓冲区`from`中获取数据，然后在验证指向`from`的内存区域可以进行读取后，将它们复制到指向`to`的缓冲区中。一旦数据被传输到内核空间（在`to`指向的缓冲区内），我们的驱动程序就可以自由访问它。

对于`read()`系统调用，执行相同的步骤（即使是相反的方向）。我们仍然有一个文件描述符`fd`；一个缓冲区`buf`，用于存放读取的数据，以及它的`count`大小。然后，系统调用返回一个值，可以是负值（如果有错误），正值（表示实际读取的字节数），或零（表示我们已经到达文件末尾）。

再次，我们应该注意`count`不是我们希望读取的字节数，而只是缓冲区的大小。实际上，`read()`可以返回小于`count`的正值，这就是为什么我在`chrdev_test.c`程序中将其放在`for()`循环中的原因。

与前面的`write()`情况相比，`read()`系统调用还可以返回`0`，表示**文件末尾**；也就是说，从这个文件描述符中没有更多的数据可用，我们应该停止读取。

与前面的`write()`情况一样，`buf`指向的缓冲区仍然带有`__user`属性，这意味着要从中读取数据，我们必须使用`copy_to_user()`函数，其定义如下：

```
unsigned long copy_to_user(void __user *to,
                   const void *from, unsigned long n);
```

`copy_from_user()`和`copy_to_user()`都在`linux/include/linux/uaccess.h`文件中定义。

现在，在本节结束之前，我们必须花一些时间来讨论内核原型中存在的`ppos`指针。

当我们希望读取文件中存储的一些数据时，我们必须多次使用 `read()` 系统调用（特别是如果文件很大而我们的内存缓冲区很小）。为了做到这一点，我们希望简单地多次调用 `read()` 而不必担心在每个前一次迭代中到达的位置；例如，如果我们有一个大小为 16 KB 的文件，并且希望使用 4 KB 内存缓冲区来读取它，我们只需调用 `read()` 系统调用四次，但是每次调用应该如何知道前一个调用完成了它的工作？嗯，这个任务被分配给了 `ppos` 指针：当文件被打开时，它开始指向文件的第一个字节（索引为 0），然后每次调用 `read()` 时，系统调用本身将它移动到下一个位置，以便接下来的 `read()` 调用知道它应该从哪里开始读取下一块数据。

请注意，`ppos` 对于读操作和写操作都是唯一的，因此如果我们先执行 `read()`，然后再执行 `write()`，数据将被写入的位置不是文件的开头，而是在前一个 `read()` 调用完成其操作的地方！
