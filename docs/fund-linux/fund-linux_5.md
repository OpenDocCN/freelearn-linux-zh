# 第五章：更高级的命令行和概念

在本章中，我们将看一下以下内容：

+   基本网络概念

+   安装新软件和更新系统

+   服务简介

+   基本系统故障排除和防火墙

+   ACL 简介

+   `setuid`，`setgid`和`sticky bit`

# 基本网络概念

在本节中，您将学习 Linux 中网络的基础知识。关于网络的一切都在 Unix 和 Linux 的经典领域内，事实上，老的 Unix 人说 Unix 是为了网络通信而创建的。Linux 被认为是使用、学习、测试、玩耍、诊断和排除计算机网络的最佳系统之一，因为 Linux 中有很多免费的优秀工具，这些工具可以直接使用，或者只需要一个命令来安装。关于计算机网络的主题有很多要学习的地方，在这里我们只能使用 CentOS 7 Linux 操作系统来教授您其中的基础知识。

现在，让我们从一万英尺高处了解计算机网络。网络或子网络和 IP 地址是网络中最基本的两个概念。每个 Linux 用户需要知道的三个最重要的事实是网络或有时称为子网络，IP 地址和网络规则：

+   规则 1：网络

每个网络或有时称为子网络，都有一个由数字组成的所谓的网络地址，看起来像这样：

![](img/350a4969-33cb-4b4e-8f34-8d04af3d0d28.png)

+   规则 2：IP 地址

每台计算机需要一个 IP 地址进行通信，这个 IP 地址是子网络地址的一部分。在我们的例子中，由点分隔的前三个数字在 IP 地址和网络地址之间是相同的：

![](img/e8143da7-1838-4d7a-9c09-19dc442dc282.png)

+   规则 3：相同的网络

两台或多台计算机之间进行网络通信的最简单方法是将它们物理连接（例如，使用网络电缆和单个交换机），然后将它们放在同一个网络中，这意味着选择所有计算机的 IP 地址都来自与我们子网络的网络地址相同的范围。在我们的例子中，选择`10.0.2`作为所有 IP 地址的前三位数字。正如您所看到的，只有最后一位是可变的。然后，想要与同一网络中的另一台计算机通信的每台计算机只需要知道接收方的正确 IP 地址。这也是几乎所有家庭私人网络的基本设置：

![](img/82fd0c2c-7b75-4719-98f7-d4eac7a40776.png)

正如我们刚刚学到的，对于正常的网络通信，所有参与者都需要在同一个网络中。如果网络只是这样，我们就必须在这里停下来，现代通信和全球网络就不会存在。事实上，全球连接了数百万个网络，例如我们自己的私人网络，它们都通过路由器连接在一起。如果您想与您网络中的另一台计算机或任何其他网络中的计算机进行通信，您的计算机需要具有所谓的 IP 路由表，该表定义了静态路由或通往特定目的地的下一跳。这个 IP 路由表是每个 Linux 操作系统的一部分。例如，如果我们有一个由三个子网络组成的私人网络，具有以下 IP 网络地址，如果您想与您子网络中的另一台计算机联系，您的路由表可能按以下方式工作。如果表中有一个条目，定义了如果有人想要访问`10.0.2.0`子网络的 IP 地址，例如，使用 IP`10.0.2.15`，则表中有一个路由条目，定义了您应该跳转到`10.0.2.0`网络：

![](img/7cc02cbc-89a6-49bf-981a-7831a5248fa6.png)

如果您想访问具有 IP 地址`192.168.122`的机器，情况也是一样的。因为路由表中有一个条目，所以路由表将跳转到这台计算机所属的`192.168.1.0`网络：

![](img/c290d1ac-a116-4c33-b712-677910b343dd.png)

对于没有明确规则的所有其他 IP 地址，将使用所谓的默认路由。在大多数私人网络中，默认规则是一个真实硬件路由器的 IP 地址，它基本上与 IP 路由表相同，但可以做更多的事情，因为它连接到全球其他路由器，它将找到通往正确目的地地址的路径：

![](img/c01d8f98-0bf5-49bf-95e4-06f4020e8a36.png)

这也被称为动态路由，因为源和目的地之间的路由器或路径可能会有所不同，取决于它将使用哪些路由器。通常，大多数互联网服务提供商提供的每个私人网络只有一个连接到公共互联网的公共 IP 地址：

![](img/9b03a412-0b6b-439f-b6a1-77849dc6c292.png)

我们私人网络中的所有计算机都需要通过这个路由器，带有其单个公共 IP 地址，如果它们想要与公共互联网中的其他计算机通信。

另一方面，如果来自互联网的外部公共机器想要访问我们子网络中的私人计算机，路由器需要处理将消息正确传递给正确的接收者，这些接收者只在我们的私人网络内部可见。

但是如何为计算机定义 IP 地址呢？IP 地址需要在与某个网络接口相关联的正确配置位置上设置在操作系统级别：

![](img/09f07a3c-9a4a-4bde-b997-d2df61ddd88f.png)

但是，如前所述，IP 地址在同一子网络中需要是唯一的；否则，无法找到网络消息的正确接收者。

那么，你如何处理呢？第一种方法是手动管理计算机列表和此网络中所有可用的空闲和保留 IP 地址。在这里，我们需要分配静态 IP 地址，这意味着每台计算机都会获得硬编码到系统中的 IP 地址，这些地址不会改变并保持稳定：

![](img/4a981e2c-3333-4380-90ab-3fe3e8f26644.png)

通常，网络中的重要服务，如邮件或 Web 服务器，具有静态 IP，因为它们必须始终在相同地址下从多台其他计算机或服务中可访问。但是，正如你可以想象的，这个系统非常不灵活，需要经常手动干预。想象一下一个公共无线热点，以及一直连接到该网络的所有人，使用多个设备，如智能手机、笔记本电脑和平板电脑。一个更好的解决方案是使用所谓的 DHCP 服务器。这是在您的网络中运行的一个服务，它监听新设备，并保持当前连接到网络的所有设备的数据库。它自动分配或撤销，并以非常可靠的方式管理 IP 地址给所有连接的机器：

![](img/9a6a7d59-ae58-42cf-99a1-a57362865dc5.png)

分配给计算机的 IP 地址是动态的，这意味着明天，您的计算机可能具有不同于今天使用的 IP 地址。这个系统的好处是它还可以向连接的计算机发送有关您网络的其他信息，例如，您网络中私有 DNS 或邮件服务器的 IP 地址，如下图所示：

![](img/f579f775-7eeb-4f85-9df7-6a3f491e357b.png)

DNS 服务器是另一个非常重要的网络功能，我们需要了解。正如我们刚刚学到的，计算机只使用 IP 地址相互通信，这些只是数字。由于我们人类不擅长记忆或回忆长序列的数字，但在使用对象或事物的名称时要好得多，因此开发了一种系统，为这些 IP 地址分配名称或别名，以便我们可以用名称而不是 IP 地址来寻址计算机。

DNS 服务器有一个存储这些关系的数据库。由于计算机只能在网络上使用数字而不是名称，所以每次我们想要使用名称连接计算机时，都会内部询问相应的 DNS 服务器，将名称翻译为相应的 IP 地址，以便我们可以使用 IP 地址进行正确的连接。现在，为了解析正常互联网的名称，比如`google.com`，我们通常会使用一些由您的 ISP 或其他来源提供的公共 DNS 服务器：

![](img/a7436e53-37c4-4f67-ac08-c92aca2dc5a2.png)

但是，当公共 DNS 服务器没有此信息时，我们如何为子网络中的内部私有计算机的 IP 地址提供名称？一种解决方案是安装和设置我们自己的私有 DNS 服务器，并添加新的名称到 IP 地址关系。

由于这需要大量工作来安装和配置。一个更简单、更快速的解决方案是将名称与 IP 地址关系放在一个特殊的文件中，称为`/etc/hosts`文件：

![](img/01781fed-e595-4932-8c2d-ea8805ed09ee.png)

使用 hosts 文件的最大缺点是，您必须在网络中的每台计算机上放置此文件，以解析网络名称，并且您还必须始终保持此文件的最新状态，以便每次向网络添加新计算机时，网络中的每台计算机都需要更新其 hosts 文件。

到目前为止，我们只谈到了 DNS 服务器和 hosts 文件的名称到 IP 地址关系。但是在这里，我们需要更详细地讨论这种名称的解剖。例如，您可以为网络中的所有计算机分配与其一起工作的人的主机名：

![](img/dc16a2b3-f028-4381-8ea8-66ddbc9429c8.png)

您也可以使用任何您喜欢的名称模式，但是，正如您可以想象的那样，这些主机名不够唯一，无法完全确定网络中的计算机，以便我们可以直接寻址。请记住，我们的私人网络可能由几个不同的子网络组成，例如，一个用于 IT 部门，一个用于人力资源部门：

![](img/c009193b-7539-4697-90f4-1c0e0abe623f.png)

在这里，两个人可以很容易地存在于不同的子网络中，所以这是行不通的，因为计算机主机名 Carl 存在于两个网络中，我们不能仅仅使用主机名来区分唯一的计算机名称。因此，我们还可以为子网络或网络地址分配名称。这种名称也称为 DNS 名称或域名。计算机的主机名或名称加上 DNS 名称，组合在一起，用点分隔，称为**完全限定域名**（**FQDN**），每当我们需要访问本地子网络之外的不同网络中的计算机时，都是真正需要的：

![](img/2bf24fce-9aed-48ff-bedc-288f2b8a38c3.png)

因此，在这里，使用全名来寻址**it-department.com**的 Carl 将不会与**human-resources.com**子网络中的 Carl 发生冲突。

让我们回顾一下！主机名是计算机名称（例如，Carl），DNS 名称是网络或子网络的名称，例如`my-company.com`或`google.com`，完全限定域名是主机名加上由点分隔的 DNS 名称（例如，`Carl.my-company.com`或`mail.google.com`）。

在本书的第一章 *Linux 简介* 中，我们设置了三个名为**Master**、**client1**和**client2**的 VM。我们配置了我们三台机器的网络，每台机器都有一个网络接口，始终使用相同的隔离 IP`10.0.2.15`，这意味着三台虚拟机之间不能进行内部连接，因为它们都具有相同的 IP：

![](img/c29ecc67-d1c8-41f4-a29e-64fc94d2adac.png)

我们使用 VirtualBox 端口转发来通过主机端口`2222`、`2223`和`2224`访问我们的机器，这些端口都映射到机器的内部 SSH 端口`22`。现在，我们希望使机器能够使用内部私有网络进行通信。由于每个网络接口只能有一个 IP 地址，我们将通过为每台机器添加第二个虚拟网络适配器，并为每台机器添加来自另一个子网的新 IP 地址，从而实现这一目标，以便每个虚拟机都有一个网络适配器用于通过 SSH 进行公共访问，另一个用于内部子网通信：

![](img/2c4ab2d6-47ea-468a-8086-7b9b4f8df068.png)

如您所见，我们使用第二个子网`10.0.5`而不是我们的`10.0.2`作为我们的内部网络：

![](img/2845aa26-4aaa-4d9e-b1b3-6164484e45c5.png)

如果输入`ip addr list`，您将获得当前连接到计算机的所有网络接口的列表：

![](img/6875b8b1-1a5c-42eb-8518-fbcb34ba4428.png)

第一个设备是环回设备，这是一个非物理设备，以便我们可以与自己的计算机建立网络连接。它总是具有 IP 地址`127.0.0.1`。第二个网络接口是 enp0s3，这是 VirtualBox 配置提供的虚拟网络接口。这反映了以下设置中的一个：

![](img/bb9ae48a-e5ae-4748-b868-7c9fc6c7e71a.png)

这个虚拟网络接口的 IP 地址是`10.0.2.15`，主要用于我们可以通过 SSH 连接到机器。

现在，让我们给虚拟机添加另一个网络接口：

1.  为了做到这一点，首先关闭机器：

![](img/1e46dca3-5bb3-4787-87c4-bb076c37c06d.png)

1.  现在，为了在虚拟机之间进行内部通信添加新的网络接口，以以下方式为每台机器添加第二个网络接口。首先，打开 VM 设置，转到网络，打开适配器 2 选项卡，启用它，并将其连接到内部网络。如您所见，内部网络的名称称为 internet。我们将把所有其他虚拟机放在同一个网络中：

![](img/f26c507d-ad70-443c-8f8f-377cf5bc89f9.png)

1.  现在，按“确定”继续。

1.  对于您希望作为内部网络的一部分进行通信的每个虚拟机都要执行相同的操作。

1.  现在让我们启动其中一个虚拟机来测试网络设置。

1.  现在，如果您再次运行 IP 地址列表，您将看到我们新添加的网络接口出现在第 3 个接口上，名称为`enp0s8`。此外，您将看到当前没有自动为此设备分配 IP 地址：

![](img/73d2b578-48b4-4c74-a1ce-8cb883c2a864.png)

1.  让我们获取有关当前网络的一些信息。让我们显示我们网络设备的 IP 路由表：

![](img/3c96398b-731e-42d5-a76e-63bb483819a1.png)

如您所见，`enp0s3`网络适配器的 IP 地址为`10.0.2.15`，这是我们用来通过端口转发从主机机器连接的接口，目前在 IP 路由表中有两条路由。第一条路由是我们当前所属的子网`10.0.2.0`的路由。这意味着如果我们尝试联系我们子网中的另一台计算机，例如`10.0.2.16`，将采用这条路由。我们想要到达的所有其他 IP 地址都使用默认路由，指向 IP 地址`10.0.2.2`。这是我们路由器的 IP 地址。因此，例如，如果您想要访问 www.google.com，首先域名将使用 DNS 服务器转换为 IP 地址，然后将与我们的路由匹配。我们可以使用`nslookup`命令使用系统的默认 DNS 服务器将任何域名解析为 IP 地址。如您所见，`google.com`域名具有以下 IP 地址：

![](img/62bfc9da-cce4-4664-8dac-671ef3cee1a4.png)

由于以`172`开头的 IP 地址不属于我们的子网，将使用默认路由。在`10.0.2.2` IP 地址后面有一个真实的硬件路由器；它将负责虚拟机和`google.com`网站之间的正确路由。

在我们使用`enp0s8`网络接口在我们的三台虚拟机之间创建新的网络连接之前，让我们设置三个唯一的 FQDN。我们将使用 root 帐户进行此操作。

要打印出 FQDN，请使用`hostnamectl status`命令：

![](img/d2b2fee6-5c14-4e70-8cd7-9abf309a5f1b.png)

如您所见，目前我们有`localhost.localdomain`的 FQDN。现在，要更改 FQDN，请使用`hostnamectl`命令的 set-hostname 选项。在我们的示例中，我们使用了主机名或计算机名 master 和 DNS 名称`centos7vt.com`。完全合格的域名是`master.centos7vt.com`。

让我们使用`status`选项进行重新检查。在我们的另外两个 VM 上，我们稍后将设置`hostnames` `client1`和`client2`，以及相同的 DNS 名称`centos7vt.com`。您还可以通过编辑`/etc/hostname`文件来设置 FQDN。

要更改系统的默认 DNS 服务器 IP 地址，请打开名为`/etc/resolv.conf`的文件。在关键字名称服务器下，您可以更改或添加新的名称服务器。例如，要添加新的名称服务器，请引入新的名称服务器行并更改 IP 地址。在此示例中，我们将使用 Google 的官方 DNS 服务器地址，或者您可以只使用`1`：

![](img/c13125f7-07d1-4c24-9338-b0f1fdbfa1f3.png)

接下来，让我们为我们的新网络适配器`enp0s8`设置一个新的静态网络配置。在 CentOS 7 上，所有网络配置文件都可以在`/etc/sysconfig/network-scripts`中找到：

![](img/4ee5ade4-92f0-467d-bfc4-5c02715d4b29.png)

如您所见，对于`enp0s3`网络接口，有一个相应的网络接口配置文件称为`ifcfg-enp0s3`。通过键入`cat ifcfg-eno0s3`来查看其内容：

![](img/2a6f1619-bd75-49dd-b4c5-e3611bb8b4a5.png)

关于此以太网网络设备最重要的事情是，它从 DHCP 服务器获取其 IP 地址，设备在启动时激活，并且具有设备 ID`enp0s3`。在配置不同环境中的不同网络设备时，此配置文件中的其他项目也可能变得非常重要。由于`if`配置文件格式没有可视化手册页，请参考`/usr/share/doc/initscripts-* sysconfig.txt`中的出色文档。

![](img/9755575b-bd9e-4891-89bd-2233ccefee41.png)

如果打开文件并搜索`ifcfg`，您将找到解释`ifcfg`文件格式的所有不同项目的部分。例如，BOOTPROTO 项目可以具有值`none`、`bootp`和`dhcp`。由于`bootp`和`dhcp`都是指我们要将其配置为静态设备的新网络设备`enp0s8`的 DHCP 客户端，我们将使用`BOOTPROTO none`，但是我们在设置简单的静态网络连接时需要哪些项目呢？由于我们只设置内部网络，因此不需要设置任何路由，并且在我们的**接口配置**（**ifcfg**）文件中只需要非常少的信息。

因此，我们将需要以下项目：名称、设备、IP 地址，因为我们将硬编码一个静态 IP 地址，以及 BOOTPROTO，我们将将其设置为 none。因此，让我们从介绍中审查我们的计划网络配置。

正如您所记得的，我们当前登录的主节点应该有第二个网络接口，静态 IP 地址为`10.0.5.1`。**Client1**应该有第二个网络适配器，静态 IP 地址为`10.0.5.2`，**client2**应该有`10.0.5.3`，所有这些都是用于节点之间的内部网络通信：

![](img/a14839a1-810b-49f4-8e5c-2e6373551eb8.png)

因此，让我们配置我们的新设备：

1.  正如您所看到的，我们目前位于网络脚本文件夹，所有网络接口的配置文件都可以在这里找到。因此，让我们首先为我们的新网络接口创建一个新的配置文件：

![](img/d882dba1-3d6e-442f-9f4b-1d3edcd914de.png)

1.  我们将通过将现有的`enp0s3`网络设备的配置文件复制到新的`enp0s8`配置文件来简化我们的生活。现在让我们打开这个新的配置文件：

![](img/9df1539f-96c1-49e3-9820-e523df3ef92c.png)

1.  让我们将静态 IP 配置的引导协议更改为`none`。大多数项目都是不需要的，所以只需删除这些行。将设备名称更改为`s8`；这里不需要 UUID。还要更改设备 ID，将`ONBOOT`保留为`yes`，这样接口将在服务器重新启动时启动，并最后添加一行，定义我们静态互联网网络配置的硬编码 IP 地址。对于我们的主服务器，请使用 IP 地址`10.0.5.1`：

![](img/160a492c-6f77-4aae-9044-45a61fba1ec6.png)

1.  现在保存文件并退出。

1.  然后，我们需要强制重置我们的`enp0s8`网络接口，以便我们对配置文件所做的更改可以应用到设备上，并且静态 IP 地址可以生效。为此，首先使用`ifdown`命令关闭`enp0s8`设备。

1.  然后使用`ifup`命令将其重新上线。

1.  最后，让我们回顾一下`ip addr`列表命令。

如果您在重新启动设备之前和之后比较了`enp0s8`的输出，您将看到我们对配置文件所做的更改是有效的，现在我们的`enp0s8`网络设备具有静态 IP`10.0.5.1`。

现在，在我们为 enp0s8 网络适配器设置了静态网络配置之后，让我们使用`ip route show`命令重新检查我们的 IP 路由表。如果您比较了我们设置新网络接口`enp0s8`之前和之后的路由表，您将看到为在我们的新`10.0.0.0`子网中路由网络通信创建了一个新路由。

作为主节点上仍然剩下的最后一件事，因为我们没有私有 DNS 服务器，需要在`/etc/hosts`文件中设置我们网络的计算机名称到 IP 的关系。始终通过首先使用完全合格的域名，然后可以添加更多的短主机名，从文件的末尾开始添加新条目。您可以始终为相同的 IP 地址添加多个名称：

![](img/5cf43398-71bf-472c-a115-572956e2d689.png)

第一个条目将是我们刚刚设置的自己的机器。其他条目是我们即将设置的客户端。保存并退出文件。现在启动两个客户端 VM。启动 VM 完成后，在您选择的终端模拟器中打开两个新标签。左侧的第一个标签保持与`master`节点的连接。在右侧的下一个标签上，请使用端口`2223`上的 SSH 端口转发登录到`client2` VM。在第三个标签中，使用端口`2224`登录到`client2` VM。现在转到我们打开的`client1` VM 的中间标签。

在这里，让我们重复配置我们的`enp0s8`网络接口的步骤，以便我们可以在服务器之间建立连接：

1.  首先，以 root 身份登录。

1.  接下来，将完全合格的域名设置为`client1.centos7vt.com`。

1.  接下来，为我们的新**enp0s8**静态网络连接创建一个配置文件。在这里，输入与主机相同的信息；只需将 IP 地址更改为`10.0.5.2`。保存并退出文件。

1.  接下来，重新启动网络接口：

![](img/ef38b7ea-cd77-4153-baf2-3a571405c203.png)

正如您所看到的，我们已成功将`10.0.5.2` IP 地址分配给了我们的 enp0s8 网络接口。最后，在`/etc/hosts`文件中添加条目，以便我们可以解析子网络中的其他域名。添加与主机相同的信息：

![](img/33c6d24e-7726-4bbb-952c-8172592ebe07.png)

保存并退出文件。接下来，在第三个选项卡中对`client2` VM 执行相同的步骤。首先以 root 用户登录，使用`client2`作为主机名，使用`10.0.5.3`作为 IP 地址，重新启动网络接口，最后，向`/etc/hosts`文件添加条目。

既然我们已经为通信设置了私有网络，测试它是否正常工作的最简单方法就是使用`ping`命令。该命令可用于查看另一个主机是否处于活动状态并且可达。如果不可达，将打印以下错误消息：

![](img/bdd15634-cffe-40ad-b43b-dcb7674c2595.png)

现在让我们从第一个选项卡中的`master`开始我们的连接测试。首先，让我们测试是否可以使用 IP 地址`10.0.5.2`连接到`client1`：

![](img/e37912ee-7319-4678-96be-9c0de4eb968a.png)

如您所见，它有效。此外，测试一下我们是否可以使用 IP 地址`10.0.5.3`连接到`client2`：

![](img/5922c243-45c3-4a53-ba99-9d7d36306baa.png)

如您所见，这也有效。

作为下一步，测试我们的`/etc/hosts`配置是否也有效。为了这样做，让我们 ping 一下我们在该文件中设置的各种主机名。client1 的全限定域名有效。同样，主机名 client1 有效。C2 也作为 client2 的简称有效。client2 的全限定域名也有效。client2 的简称有效，c2 作为 client2 的非常简称也有效：

![](img/6f2f0d87-9ba5-48e1-a600-db4e829f1f73.png)

现在让我们转到 client1。在这里，让我们测试是否可以连接到主服务器：

![](img/8ed41205-90b4-4282-a324-4b959042b53e.png)

是的，它有效。此外，您还可以使用不同的名称测试主服务器。让我们也测试一下 client2 的连接。测试不同名称下的主服务器，还要测试 client1。总之，我们可以说我们三台 VM 机器之间的网络配置现在正常工作。

# 安装新软件和更新系统

在本节中，我们将向您展示如何在计算机上安装新软件以及如何更新您的 CentOS 7 系统。

首先，让我们显示系统上当前安装的所有 RPM 软件包。键入`yum list installed`：

![](img/30cb1957-3e81-4667-b8e7-54f241c1757d.png)

在第一章的安装章节中，*Linux 简介*，我们已经演示了如何使用`yum`命令进行完整的系统更新，这将更新最小安装中已包含的所有 RPM 软件包，以及我们之后安装的所有软件包。

要获取系统上已安装的所有软件包的所有更新的列表，请键入以下命令查看新内容：`yum check update`：

![](img/c76558bf-ee55-433a-922b-ef67b0f63992.png)

在这里，列出了所有的 RPM 软件包以及您可以安装的更新的新版本。所有的更新都必须使用 root 用户进行。所以首先以 root 用户登录。要仅更新单个 ROM 软件包，比如在可用软件更新列表中呈现的`vim-minimal`软件包，使用`yum update`，然后加入软件包的名称；例如，`vim-minimal`。在询问是否更新软件包时输入 yes，并再次输入`yes`确认导入 GBG 密钥：

![](img/b690227d-48d5-4072-ac95-acd40de53ebf.png)

正如我们所看到的，`vim-minimal`软件包已成功更新到最新版本。正如我们在第一章中已经学到的，在本书中，只需输入`yum update`来对系统上当前安装的所有软件包进行完整的系统更新。现在让我们按下*N*键来取消所有软件包的更新的下载和安装。大多数 yum 命令都需要用户的某种确认；例如，确认软件包的更新。如果你绝对确定会回答“是”任何问题，你可以通过提供`-y`标志来进一步自动化你选择的`yum`命令。这几乎适用于任何命令。这将执行你选择的 yum 操作，而无需用户进一步确认。

请注意，关于在更新软件包后是否需要重新启动系统存在着一个长期的争论。一般的共识是通常不需要，但是，如果内核或 glibc 软件包已经更新，你应该这样做。当然，出于安全原因，你确实应该这样做。

我们还可以看到，当我们比较系统中当前安装的内核和当前运行的内核时，需要重新启动：

![](img/51086241-cad9-4526-b139-3c426fdb7c0f.png)

当前运行的内核以`514.el7`结尾。当前安装的最新内核以`514.21`结尾，所以我们目前没有运行最新的内核。所以让我们重新启动系统。重新启动完成后，以 root 用户登录系统，再次输入`uname -r`命令，现在我们可以看到我们现在正在运行最新的内核，所以在这种情况下重新启动是必要的：

![](img/0ffbc806-45d5-4371-8a2c-66c649bd0ced.png)

现在，要使用关键字（例如`Apache2 Web Server`）在你的软件包仓库中搜索，使用`yum search`命令，然后是关键字。这将打印出所有与关键字匹配的软件包的列表；在我们的例子中，apache，无论是在软件包名称还是在软件包描述中。

![](img/a60ce958-e594-4ec3-962a-5c37c94874b8.png)

如果要获取有关某个软件包名称的更多信息（例如，HTTP 软件包名称），可以使用`yum info`子命令。

另一个非常有用的功能是，如果你知道一个 RPM 软件包中包含的文件或命令的名称，但实际上不知道这个命令或文件来自哪个 RPM 软件包，你可以使用`yum whatprovides`命令，将你正在搜索的命令或文件的前缀设为`*/`：

![](img/c1abd357-91c0-4b4d-985f-0d707cd77ac6.png)

在这个例子中，我们正在搜索所有包含`ifconfig`文件或命令的软件包名称。正如我们所看到的，我们在`net-tools` RPM 软件包中找到了一个匹配，其中存在一个二进制文件或命令`/bin/ifconfig`。

现在，要安装一个软件包，使用`yum install`命令，提供软件包名称作为参数。在这个例子中，我们安装了 Apache HTTP 服务器软件包：

![](img/c6586b70-c9d5-4aab-8427-6300090f38f6.png)

另一个有趣的命令是`rpm -ql`命令，后面跟上已安装软件包的名称，以获取该软件包安装的所有文件及其在文件系统中的确切位置的列表。要删除一个软件包，可以使用`yum remove`命令，然后是要删除的软件包的名称。

在第四章中，*使用命令行*，我们向您展示了如何使用第三方软件仓库`epl`来安装诸如`htop`和`iotop`之类的软件，因为它们在官方 CentOS 7 软件仓库中不可用。例如，如果你搜索`htop`软件包，它在官方来源中是不可用的：

![](img/dbd7df80-c72e-4d4b-b55b-ba849eb087c3.png)

因此，让我们安装`epl`存储库，因为它可以从默认软件包源中获得。如您所见，可以使用`epl-release` RPM 软件包安装`epl`存储库：

![](img/6f6ab4a0-25f8-43af-877c-a6faa714eed1.png)

使用以下命令查看`epl`存储库是否已成功安装，以检索系统中所有可用存储库的列表。

现在我们可以找到`htop`软件包，因为它是`epl`的一部分。安装其他存储库并不那么容易，因为官方来源没有 RPM 软件包，但大多数第三方存储库可以通过下载外部 RPM 来安装。您很可能会在网页上找到存储库。例如，对于著名的`remi`存储库，您可以首先从官方`remi`网站下载官方`remi`存储库 RPM 软件包：

![](img/b24cc00c-09b8-401c-960a-8068b8877e71.png)

接下来，使用带有大写`Uvh`选项的`rpm`命令安装下载的`remi`存储库 RPM：

![](img/36b3d925-073f-482d-aad1-94c694276e48.png)

然后，您需要通过编辑`remi yum config`文件来启用`remi`存储库。首先，在`/etc/yum.repos.d`文件夹中打开`remi.repo`文件。在这个文件中，转到`remi`部分，然后转到关键字`enabled`并将其从`0`更改为`1`：

![](img/bdbbea0b-df94-4d34-904e-2c99c9ec5176.png)

现在保存文件。然后，在更新软件包列表后，您可以使用新安装的第三方存储库。要重新检查第三方存储库是否已正确安装，还可以再次使用`yum repolist`命令：

![](img/f823d15b-ac5d-4591-9288-7371a77ad319.png)

# 服务简介

在本节中，我们将向您展示如何在 CentOS 7 中使用服务。

让我们在三个不同的选项卡中打开上一章节中的主服务器、client1 和 client2 三个 VM，它们连接在同一个内部子网络上。

让我们从安装一个简单的网络服务开始。在我们的示例中，让我们在主服务器上安装 Apache2 Web 服务器，因为它非常容易设置和使用：

![](img/b1c94fc5-d607-4404-b5fb-02b51325e815.png)

现在，在 CentOS 7 上安装`httpd`软件包后，您可以使用`systemctl`命令来管理服务，该命令是`systemd`服务的一部分。

要获取系统中当前可用的所有单元的列表，请使用以下命令：`system ctl list-units`。这将打开带有较少导航的单元列表：

![](img/f10184d1-dbf5-4f50-9514-9da0f0dcafc5.png)

如您所见，有不同类型的单元文件可用；例如，以`device`结尾的文件，以`mount`结尾的文件和服务文件。按*q*退出导航。要获取系统中当前可用的所有服务的列表，只需键入`systemctl list-unit-files`，然后使用`--type=service`进行服务过滤。在此列表中，您将看到系统中当前启用或禁用的所有可用服务。与我们安装的 Apache2 Web 服务器一样，当前已禁用的`httpd 服务`文件也存在。要获取单个服务的详细状态，请使用带有`status`选项和服务名称的`systemctl`命令；在我们的示例中，是`httpd`服务：

![](img/5eae9ca8-290b-4f07-821c-3ea361bd9d5e.png)

如您所见，在安装新的 Apache HTTP 服务器后，服务未运行。默认情况下，`systemd`服务可以有两种不同的状态对我们很重要：已启用或已禁用，已激活或未激活。在我们的示例中，`httpd`服务在安装后默认处于禁用和未激活状态。与任何其他服务一样，Apache HTTP 服务器默认情况下是禁用和未激活的。已启用意味着服务应在每次启动 Linux 系统时自动启动，这也称为启动时。已激活意味着服务当前正在运行。

要启动一个服务，请使用`systemctl start`选项，然后是服务的名称；在我们的例子中是`httpd.service`。现在再次检查服务，再次使用`status`选项：

![](img/e89d371a-9b1a-4bc9-89e1-153ae2eb91d2.png)

正如你所看到的，它现在正在运行。此外，你还可以在这里的输出中看到另外两个非常重要的事情。首先，你可以看到一个服务可以由多个进程组成。在我们的例子中，httpd 服务由六个不同的 HTTP 进程组成。另一个重要的事情是，`systemctl status`命令在启动服务时会输出服务生成的最后几行消息。进程生成的这些有用的文本行也称为日志，可以为我们提供有关服务运行行为的有用信息。不过，我们的服务目前是禁用状态。要启用它，请使用`systemctl enable`选项。现在再次查看状态：

![](img/b9c38fcc-8e8d-4750-b4e7-91730e31363f.png)

现在你可以看到它也已经启用，所以这项服务将在每次重新启动服务器时自动启动。要停止当前运行的服务，请使用`systemctl stop`选项。我们会看到它再次变为非活动状态。

需要注意的是，启动或停止不会影响服务的禁用或启用服务器引导行为。在这里，这项服务仍然是启用的，尽管它没有运行。反之亦然。禁用或启用服务不会启动或停止它。

要禁用一个服务，请使用`systemctl disable`选项。然后再次启动服务。现在，为了测试我们的 HTTP 服务器是否正常工作并且能够托管和传递 Web 内容，让我们首先为我们的服务器创建一个标准主页。我们服务器的标准主页是`/var/www/html`文件夹中的`index.html`文件。现在，将以下 HTML 内容包含进去，这是我们服务器的问候消息：

![](img/cff68994-f27a-4b15-8029-9a4659952270.png)

保存并退出文件。现在，要从我们所在的主服务器上的新 Web 服务器访问我们的主页，请使用`wget`：

![](img/eadcb655-17c1-4942-8cfc-03b71c88fcfb.png)

如你所见，我们可以从我们的主服务器本地正确访问主页。现在，如果你停止 Web 服务并尝试再次访问我们的网页会发生什么？你会发现网页不再可访问。重新启动 Web 服务器。现在，让我们测试一下我们是否可以从本地网络中的另一台计算机访问我们的新 Web 服务器。只需转到 client1 选项卡并测试 Web 服务器是否可以通过网络访问。你会发现它是不可以的。

# 基本系统故障排除和防火墙

在本节中，我们将继续上一节中开始的 Apache2 Web 服务器的工作，以便使其可以被我们子网络中的其他计算机访问。此外，我们还将简要介绍 CentOS 7 中的 Linux 防火墙。

本章的第一部分简要提到，网络连接总是通过 IP 地址和端口的组合进行的，这两者合称为套接字地址。现在，每个 Linux 网络服务，比如邮件或 Web 服务器，都必须连接到 IP 地址和端口，这样我们才能从网络中的另一台计算机或同一台本地计算机上建立连接：

![](img/ca19ad25-2863-484d-a1d2-e52c22dcc128.png)

当我们谈论网络通信时，我们经常将其称为“一个服务正在监听 IP 地址 a 端口 b”。例如，我们的 Web 服务器正在监听 IP 地址`10.0.2.15`的端口`80`，邮件服务正在监听端口`24`，Web 服务正在监听 IP 地址`10.0.2.15`的端口`80`，FTP 服务正在监听 IP 地址`10.0.2.15`的端口`21`。

但也许你想知道，如果我们在系统上配置了多个网络接口，每个接口都有不同的 IP 地址，那么服务使用哪个 IP 地址进行通信？答案很简单。在安装后，任何 Linux 系统上的大多数网络服务默认会监听所有可用的网络接口进行网络连接。对于几乎所有标准服务，你也可以将其更改为仅监听特定的网络接口、网络连接或子网络，甚至是网络范围：

![](img/572ef538-ecca-44bf-89a9-a9dfd2bf1c6c.png)

有些甚至在安装后默认只监听本地主机，因为这些通常是非常关键的服务，系统管理员需要有意更改监听地址，以此作为对风险的责任意识。

假设你有一台运行多个网络服务并且每个服务都在不同端口上监听的 Linux 服务器。防火墙是管理计算机连接的工具。在 Linux 中，标准防火墙称为**firewalld**。这个防火墙可以保护你的系统免受外部不需要的网络连接，例如，如果有人试图侵入你的系统并窃取数据。它通过管理你的入站网络端口来实现。默认情况下，`firewalld`关闭除了用于 SSH 连接的端口`22`之外的所有入站网络端口。否则，你将无法远程连接到你的机器：

![](img/09ebe94d-250e-4f5e-a26f-83b843a62f48.png)

因此，如果你想进行某种网络通信，你必须明确告诉防火墙这样做。你可以打开或关闭单个端口或端口范围等。这在管理服务器安全性方面非常有帮助，但重要的是要注意，默认情况下，firewalld 不会限制系统内的任何本地网络通信，因此本地主机网络连接始终有效，并且不会被防火墙阻止。此外，非常重要的是要知道，默认情况下，firewalld 只是一个入站防火墙，这意味着它根本不会阻止任何出站连接：

![](img/052891d5-d628-4e37-a634-28f6aea3e317.png)

为了解决这个问题，我们需要知道如何对系统服务进行故障排除。因此，首先回到我们的主服务器，查看运行此 Web 服务器的情况。要找出服务是否出现问题，至少有三个地方可以查看。我们应该做的第一件事是检查`systemctl status`的输出，就像我们之前做的那样。正如你所看到的，服务目前正在运行，服务的最终当前输出行也显示为`OK`：

![](img/4852cf3c-9a62-4c11-a9ae-684b1aaf659a.png)

有时，在这里的输出中，如果服务没有正常运行，你会找到错误消息或警告。

有时，服务的日志输出的最后两行不足以，因此如果你需要对服务进行故障排除，可以查看的第二个地方是`journalctl`命令。如果你使用`journalctl`命令和`-u`标志，你可以过滤你选择的服务的日志消息；在我们的示例中，是`httpd`服务：

![](img/3b5c5c41-1015-4efd-ab03-45686d58a550.png)

在我们的示例中，在`journald`中找不到任何可疑的日志输出，这是将所有正在运行的服务的所有日志消息写入集中数据库的服务。Apache HTTP 服务器的日志看起来很正常。

因此，我们可以查看故障排除服务的第三个地方是`rsyslog`日志文件，它位于`/var/log/messages`。打开这个文件，按大写*G*键跳到末尾。

![](img/a2171118-83f1-4ffa-8b87-340940d9040d.png)

在这里，`rsyslog`文件中并没有记录任何可疑的内容。

一些服务，比如我们的 Apache HTTP Web 服务器，提供了自己的日志文件，用于故障排除或获取有关服务的信息。

请注意，没有标准化的目录可以让服务输出自己的日志文件，但是一些服务会将它们的日志文件写入到`/var/log`文件目录下的子目录中。在这里，您可以找到两个日志文件。一个是`access_log`，记录用户访问我们的 Web 服务器（例如，已下载的服务器上的文件）。另一个是`error_log`文件，记录此服务可能遇到的各种错误。因此，首先查看`access_log`文件：

![](img/0e668333-8e35-4fab-bb91-e36ce2a42c17.png)

这看起来非常正常。现在，也打开`error_log`文件。使用大写*G*跳转到末尾：

![](img/f5c1e5a5-f975-48b6-b180-f452087d2a57.png)

在这里，找不到特殊的错误消息。

解决 CentOS 7 上的 Apache HTTP Web 服务器之外没有人能访问的问题是因为有一个非常严格的防火墙正在阻止几乎所有传入的网络连接。

您可以通过输入`firewall-cmd --list-all`来查看当前允许的防火墙规则。在 CentOS 7 上，标准防火墙称为 firewalld：

![](img/35a33271-a875-4714-8a9e-5de4ff1c6e07.png)

如您在这里所见，只有 SSH 服务默认允许与我们的服务器通信。Firewalld 主要保护所有传入的网络连接。从我们的服务器到其他服务器的出站连接没有受到限制或限制；这就是为什么我们可以从本地主机访问我们的 Web 服务器，但不能从任何其他主机访问的原因。

为了解决这个问题，我们可以在防火墙中打开 HTTP 服务，也就是打开端口 80。为了能够永久地这样做，使用以下两个命令：`firewall-cmd --permanent --add-service`，然后是`http`。为了应用更改，接下来重新加载防火墙规则。最后，让我们看看 HTTP 服务现在是否在防火墙中启用了：

![](img/082b7f50-01bf-4157-bc61-71755cc6b741.png)

如您所见，它有效。

最后，让我们测试一下是否可以从另一台服务器远程连接到我们的 Apache Web 服务器。转到 client1 并重复`wget`命令：

![](img/92529b85-e4fc-4cf6-864b-3e7e42283faa.png)

是的，它有效！您现在可以在您的网络中访问您的 Web 服务器。

到目前为止，我们还没有讨论如何从防火墙中删除服务。要从防火墙配置中删除 HTTP 服务或端口，请使用以下防火墙命令语法，`firewall-cmd --permanent --remove-service`。

然后选择服务；在我们的例子中，是`http`服务。与添加服务类似，您还必须在这里重新加载防火墙。让我们重新检查一下防火墙设置：

![](img/3e52883d-5cfc-41f4-a520-2197296924a7.png)

如您所见，HTTP 端口已关闭。

最后，firewalld 服务的一个非常有用的功能是可以打开单独的端口号，而无需提供服务名称。如果需要打开一个没有服务文件（例如 HTTP）的端口，这将非常有用。例如，要打开端口`12345`，请使用 TCP 协议。让我们在重新加载防火墙后显示新的防火墙配置：

![](img/0b4341af-f9ed-4dad-8a59-1d58e993016b.png)

如您所见，端口`12345`现在使用 TCP 协议打开。除了 TCP，您还可以使用 UDP 协议。现在，要使用 TCP 协议关闭端口`12345`，请使用以下命令。在这里，还要重新加载防火墙配置。让我们进行重新检查：

![](img/d6ddbcd4-835b-4b8f-b995-f77c4afefc3f.png)

让我们总结一下到目前为止我们学到的东西：

1.  如果是与服务相关的问题，首先查看服务的`systemctl`输出。

1.  如果问题仍然存在，请查看服务的`journalctl`输出。

1.  如果这是一个一般的系统问题，或者您无法通过`systemctl`和`journalctl`的输出来解决您的服务问题，接下来看一下`/var/log-messages rsyslog`输出文件。

1.  此外，一些服务提供了`journald`或`rsyslog`文件之外的特殊日志文件位置，因此也要查看那里。但您必须意识到，并非每个服务或程序都有这样一个特殊的日志文件目录或输出。

1.  最后，我们向您简要介绍了使用预定义服务文件（如 HTTP）的 firewalld 服务，并向您展示了如何处理未由服务文件定义的单个端口。在下一章中，我们将向您展示高级文件权限。

# 介绍 ACL

在本节中，我们将向您简要介绍 ACL（访问控制列表）的工作原理。

Linux 具有一些特殊的文件和文件夹权限，即 ACL（访问控制列表）、`setuid`、`setgid`和`sticky bit`。如果您查看文件系统中的文件，比如只有 root 用户可以访问的新文件，当前我们登录为`olip`：

![](img/4906246a-fcfb-4bf9-86e9-485310d7210e.png)

如您所见，`olip`用户对该文件没有写访问权限。也许您已经问过自己这个问题：如何将文件或文件夹的权限授予不是文件或组所有者的个别用户，比如我们的例子中的 root 用户？唯一的方法是使用其他组，但这不是个别的，因为所有不是文件或组所有者的用户都属于此类别。但在这里，我们想要设置单个用户权限；例如，对于`olip`用户。

ACL（访问控制列表）是一个系统，它通过简单的所有权和权限模型扩展了我们在 Linux 下的正常文件访问控制。使用 ACL，您可以在单个用户或组级别上定义文件或文件夹权限。要使用 ACL，请使用`getfacl`和`setfacl`命令。

例如，要显示 ACL，请使用`getfacl`命令，然后是要显示权限的文件名：

![](img/187752b3-8eaf-47ae-81d9-33a67ca25adf.png)

如您所见，目前此文件上没有设置 ACL。与普通文件权限一样，如果我们想要更改某些内容，就需要以 root 身份登录。现在，例如，要为`olip`用户设置 ACL，请使用以下命令。如果您还记得第三章 *Linux 文件系统*，这应该是不言自明的：

![](img/1266dd6d-4277-4aea-b587-93992323d892.png)

要显示 ACL，请再次查看此文件的 ACL。如果比较之前和之后的`getfacl`命令输出，您将看到我们现在为`olup`用户设置了单个用户权限：`读`、`写`和`执行`。现在，`olip`用户应该能够写入此文件：

![](img/a64db54e-37ed-42ff-9426-d0033d817100.png)

成功；ACL 正常工作。

您还可以基于组设置 ACL。在这里，我们将使用组标识符而不是用户。要删除单个 ACL，请使用`-x`标志。您还可以通过`ls -l`命令的输出中标记的加号来查看文件是否设置了 ACL：

![](img/26a876b0-52ee-4f1c-b04c-6e65a86eeda1.png)

# setuid、setgid 和 sticky bit

在本节中，我们将向您展示有关特殊文件权限标志`setid`、`setgid`和`sticky bit`的所有必要信息。

# setuid

现在让我们谈谈`setuid`、`setgid`和`sticky bit`。在处理用户、组和文件权限时，让我们首先以 root 身份登录。

首先，让我们创建一个新用户、组，并在本地复制`whoami`命令，以查看`setuid`标志的情况：

![](img/2f1fd404-74c4-410a-a80f-8e03419f224e.png)

接下来，让我们将此命令的文件所有者和组所有者更改为`awesome_user`和`awesome_group`：

![](img/02f714b5-54cd-48dc-ae56-1a3c17a4abc0.png)

使用八进制表示法也可以设置`setuid`、`setgid`和`sticky bit`。您已经从文件权限章节了解了它们。这些特殊权限可以通过文件权限字符串中的一个额外位来表示，使用以下代码：

![](img/1ee75da5-26b6-492a-a168-1c73dc777f65.png)

`setuid`的数字是`4`，`setgid`的数字是`2`，`粘滞位`的数字是`1`。与文件的简单`读`、`写`和`执行`权限类似，您还可以向文件添加特殊权限的组合：

![](img/a7bd5161-7c6d-43a6-9d0f-5b17628d3aed.png)

如果要设置`setuid`和`setgid`标志，您需要将`4`和`2`相加，总共是`6`，或者`setgid`和`粘滞位`由`3`表示，或者`粘滞位`和`setuid`由`5`表示。

现在，我们如何设置特殊权限信息？可以使用`chmod`命令中的附加数字进行设置。您已经知道，为用户、组和其他人定义权限需要三个数字。要在文件上显示特殊权限，可以使用`ls -l`命令，但这很难阅读，更容易使用`getfacl`命令，它不仅适用于 ACL，还显示了我们特殊权限的标志。默认情况下，没有为任何文件定义标志或特殊权限，如您在`getfacl`命令的输出中所见：

![](img/73ae921a-d3f2-4c5a-b852-e6be40e65382.png)

现在，要向文件添加特殊权限标志，或者换句话说，设置`setuid`、`setgid`或`粘滞位`，您可以使用带有四个数字的`chmod`命令，而不是三个数字，其中第一个前导数字定义了特殊权限。例如，如果您在`chmod`命令的第一个位置使用`2`，则会设置设置组 ID 标志，该标志显示在标志行中。如果我们在第二个位置有`s`，那么它就是设置组 ID：

![](img/51782889-847f-4473-96e9-0750a1376dc6.png)

现在，要设置`setuid`标志，请在`chmod`命令中使用数字`4`作为第一个数字。使用`getfacl`命令重新检查。在标志行中，最左边的字符已设置为`s`：

![](img/9f985704-14a6-4a96-a593-8d284882d887.png)

现在，添加特殊文件权限标志的组合（例如，数字 6，表示`setuid`和`setgid`的组合，或 4 加 2 等于 6），在`getfacl`输出中以以下方式显示：

![](img/d4d68e59-0267-415d-b6de-289461895060.png)

最左边的第一个标志是`setuid`标志，第二个标志是`setgid`标志。要设置所有三种权限类型，`setuid`、`setgid`和`粘滞位`，请使用`getfacl`（路径）：

![](img/b272143f-9236-44b3-92c2-10b5457fa3bb.png)

在这里，您可以看到所有三个标志都已设置。`粘滞位`的短标志是`t`，而不是`s`。

要删除所有特殊文件权限，只需将`0`用作文件权限编码的数字，并将`0`用作`chmod`命令的第一个数字：

![](img/bfc57246-c6f3-46c0-95a4-3810d23fd8f4.png)

现在，让我们简要讨论一下`setuid`权限。`setuid`标志仅对可执行命令重要，对目录或其他文件类型无关紧要。还要知道，出于安全原因，它不适用于脚本文件，而仅适用于编译的二进制可执行文件。

如前所述，每个进程都有一个关联的用户，我们称之为“用户运行命令”。在这个例子中，您看到的所有进程都是由 root 用户运行的：

![](img/fef88911-1180-4dd1-8764-0ed7b8b37028.png)

现在，`setuid`权限标志将以定义为该文件所有者的用户身份运行命令。这对于系统中的一些特殊命令非常重要和有用；例如，必须作为 root 用户运行的命令，因为它们访问受保护的文件系统文件或文件夹，但对于普通用户也必须是可执行的。例如，`passwd`命令。它访问并写入文件，例如`etc/passwd`文件，该文件仅对 root 可写，因此必须以 root 身份运行此命令，但普通用户也需要在`passwd`命令上更改密码：

![](img/fa0ec1bc-0c90-46ae-8cf3-9d208d33c490.png)

现在，让我们退出 root 用户，用普通用户账户测试`setuid`标志。

让我们再次检查一下我们是否真的是`olip`用户。现在，如果不在文件上设置`setuid`标志，如果我们执行本地的`whoami`命令，它将打印出我们的用户名，因为我们是启动它的用户：

![](img/486f3310-e830-4d30-94c0-5b00bb286f5a.png)

现在，如果我们在该命令上设置`setuid`权限并再次执行它，会发生什么？首先，让我们查看权限标志。我们会看到该文件上成功设置了`setuid`标志。现在，让我们再次执行一个命令：

![](img/9e855733-11e5-4b59-8287-eb5efb3fc26a.png)

正如你所看到的，`setuid`标志的效果如预期。我们以`olip`用户身份运行命令，但在执行过程中使用的是文件所有者`awesome_user`。

# setgid

现在，让我们了解一下`setgid`权限。这个标志有两个不同的含义，这是很重要的，应该被记住。当在文件上设置时，它与`setuid`权限具有相同的效果，但这里它将以组所有者的权限执行命令，而不是文件所有者的权限。

在`chmod`命令中使用数字`2`来设置文件的`setgid`标志：

![](img/6045bc66-e569-4642-b5ab-758dbd38206a.png)

`setgid`标志的第二个含义非常重要，应该被记住，因为它可能是一个典型的用例。如果在文件夹而不是文件上设置了`setgid`，那么在该文件夹中创建的每个新文件、文件夹或子文件夹都将自动获得设置了`setgid`标志的文件夹的组权限。这适用于递归包含的所有文件。这可能非常重要，因为通常新创建的文件的组权限会自动由文件的创建者分配。

因此，如果你想要在文件系统中为协作或团队工作分隔位置，可以将共享文件放入其中，供属于特定组的任何人使用，`setgid`是一个非常强大的功能。这就像你可能从其他操作系统中了解到的共享文件夹。因此，如果你想要将文件系统分隔成为协作或团队工作的位置，任何属于特定组的人都可以创建文件，并且其他同一组的人可以完全访问这些文件，只需在文件夹上设置`setgid`标志。

为了测试这个：

1.  在用户名`olip`下创建一个新文件夹。

1.  现在，将组所有权更改为`awesome_group`。现在，如果用户在该文件夹中创建新文件，它将具有该用户的组所有权。

1.  现在，让我们在那个文件夹上设置`setgid`标志，看看会发生什么。

1.  让我们在设置了`setgid`标志的文件夹中，使用用户名`olip`创建一个新文件：

![](img/31c7762e-1527-44a9-b50d-73ecf61a3018.png)

正如你所看到的，现在在这个文件夹中创建的任何新文件都会获得文件夹的组所有权，即`awesome_group`。所以我们的`setgid`标志正常工作。

# 粘性位

`sticky bit`只对目录有效，对文件无效。如果在文件夹上设置了`sticky bit`，则只有特定文件、文件夹或子文件夹的所有者才能删除它。有一些特殊情况下这是有用的，例如在`/tmp`目录中，任何人都应该被允许查看任何内容，但很多时候进程会在该文件夹中创建并依赖存储的数据，因此如果除了进程的创建者之外的其他人能够删除其他用户的文件，那将是非常糟糕的。

让我们来测试一下：

![](img/bbc27a8e-a024-4001-bbfa-f2ff6d7cf5a7.png)

如您所见，“粘性位”已在`/tmp`目录上设置，因此让我们在`/tmp`目录中使用`olip`用户创建一个新文件。现在，让我们用`awesome_user`登录。由于尚未设置密码，让我们为其设置一个密码。现在，`awesome_user`也将在`/tmp`目录中创建一个新文件。现在，让我们尝试删除我们自己的文件，这是有效的。现在，让我们尝试删除`olip`用户的文件；这不起作用，因此“粘性位”正在按预期工作：

![](img/cc153ad7-1db1-4491-a264-ef49b370a034.png)

# 摘要

在本章中，我们向您简要介绍了 Linux 中特殊文件权限标志。`setuid`标志仅适用于命令，而不适用于脚本，并允许程序以文件所有者定义的用户而不是运行该程序的用户来执行。`setgid`标志有两个特殊含义。第一个是用于命令，另一个是用于文件夹。如果您在命令上设置它，它将像`setuid`标志一样工作，但将以该文件的组所有权而不是该文件的文件所有者来运行它。第二个含义是，如果您在文件夹上设置它，您设置了`setgid`的文件夹的组所有者将自动分配给您在该文件夹中创建的每个新文件。在设置了“粘性位”的目录中，只有文件所有者才能删除自己的文件。
