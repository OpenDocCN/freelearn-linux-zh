- en: Dynamic Memory Allocation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态内存分配
- en: In this chapter, we will delve into a key aspect of system programming on a
    modern OS—the management of dynamic (runtime) memory allocation and deallocation.
    We'll first cover the basic glibc APIs used to allocate and free memory dynamically.
    We'll then move beyond these basics, examining the program break within the VAS
    and the behavior of `malloc(3)` under differing circumstances.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨现代操作系统上的系统编程的一个关键方面 – 动态（运行时）内存分配和释放的管理。我们将首先介绍用于动态分配和释放内存的基本glibc
    API。然后，我们将超越这些基础，研究VAS中的程序中断和`malloc(3)`在不同情况下的行为。
- en: 'We will then immerse the reader in a few advanced discussions: demand-paging,
    memory locking and protection, and the usage of the `alloca` API.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使读者沉浸在一些高级讨论中：需求分页、内存锁定和保护，以及`alloca`API的使用。
- en: Code examples provide the reader with an opportunity to explore these topics
    in a hands-on manner.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例为读者提供了一个探索这些主题的机会。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Basic glibc dynamic memory-management APIs and their correct usage in code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的glibc动态内存管理API及其在代码中的正确使用
- en: The program break (and its management via the `sbrk(3)` API)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序中断（及其通过`sbrk(3)`API的管理）
- en: The internal behavior of `malloc(3)` when allocating differing amounts of memory
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`malloc(3)`在分配不同数量的内存时的内部行为'
- en: 'Advanced features:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级特性：
- en: The demand-paging concept
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求分页概念
- en: Memory locking
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存锁定
- en: Memory region protection
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存区域保护
- en: Using the `alloca (3)` API alternative
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`alloca (3)`API的替代方案
- en: The glibc malloc(3) API family
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: glibc malloc(3) API系列
- en: In [Chapter 2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml), *Virtual Memory*,
    we learned that there are regions or segments meant for the use of dynamic memory-allocation within
    the process of **Virtual Address Space** (**VAS**). The **heap segment** is one
    such dynamic region—a free gift of memory made available to the process for its
    runtime consumption.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml)中，*虚拟内存*，我们了解到在**虚拟地址空间**（**VAS**）的进程中有用于动态内存分配的区域或段。**堆段**就是这样一个动态区域
    – 一个为进程的运行时消耗提供的免费内存礼物。
- en: How exactly does the developer exploit this gift of memory? Not just that, the
    developer has to be extremely careful with matching memory *allocations* to subsequent
    memory *frees*, otherwise the system isn't going to like it!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员究竟如何利用这份内存的礼物？不仅如此，开发人员还必须非常小心地匹配内存*分配*和后续内存*释放*，否则系统将不会喜欢它！
- en: The **GNU C library** (**glibc**) provides a small but powerful set of APIs
    to enable the developer to manage dynamic memory; the details of their usage is
    the content of this section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**GNU C库**（**glibc**）提供了一组小而强大的API，使开发人员能够管理动态内存；它们的使用细节是本节的内容。'
- en: 'As you will come to see, the memory-management APIs are literally a handful:
    `malloc(3)`, `calloc`, `realloc`, and `free`. Still, using them correctly remains
    a challenge! The subsequent sections (and chapters) will reveal why this is the
    case. Read on!'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将会看到的，内存管理API实际上只有几个：`malloc(3)`、`calloc`、`realloc`和`free`。然而，正确地使用它们仍然是一个挑战！接下来的章节（和章节）将揭示为什么会出现这种情况。继续阅读！
- en: The malloc(3) API
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: malloc(3) API
- en: Perhaps one of the most common APIs used by application developers is the renowned
    `malloc(3)`*.*
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 也许应用程序开发人员最常用的API之一是著名的`malloc(3)`*。*
- en: The `foo(3)` syntax indicates that the `foo` function is in section 3 of the
    manual (the man pages) – a library API, not a system call. We recommend you develop
    the habit of reading the man pages. The man pages are available online, and you
    can find them at [https://linux.die.net/man/](https://linux.die.net/man/)*.*
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`foo(3)`的语法表示`foo`函数在手册（man页面）的第3节中 – 一个库API，而不是系统调用。我们建议您养成阅读man页面的习惯。man页面可以在线获取，您可以在[https://linux.die.net/man/](https://linux.die.net/man/)找到它们*。*'
- en: 'We use `malloc(3)` to dynamically allocate a chunk of memory at runtime. This
    is as opposed to static—or compile-time – memory-allocation where we make a statement,
    such as:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`malloc(3)`在运行时动态分配一块内存。这与静态 – 或编译时 – 内存分配相反，我们做出了一个声明，比如：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding case, the memory has been statically allocated (at compile-time).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情况下，内存是静态分配的（在编译时）。
- en: 'So, how exactly do you use `malloc(3)`? Let''s check out its signature:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，究竟如何使用`malloc(3)`？让我们来看看它的签名：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The parameter to `malloc(3)` is the number of bytes to allocate. But what is
    the `size_t` data type? Obviously, it's not a C primitive data type; it's a `typedef
    – long unsigned int` on your typical 64-bit platform (the exact data type does
    vary with the platform; the important point is that it's always unsigned – it
    cannot be negative. On a 32-bit Linux, it will be `unsigned int`). Ensuring that
    your code precisely matches the function signature and data types is crucial in
    writing robust and correct programs. While we're at it, ensure that you include
    the header file that the man page displays with the API signature.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc(3)`的参数是要分配的字节数。但是`size_t`数据类型是什么？显然，它不是C原始数据类型；它是在典型的64位平台上的`typedef
    – long unsigned int`（确切的数据类型会随着平台的不同而变化；重要的是它总是无符号的 – 它不能是负数。在32位Linux上，它将是`unsigned
    int`）。确保您的代码与函数签名和数据类型精确匹配对于编写健壮和正确的程序至关重要。顺便说一句，确保您包含API签名所显示的头文件。'
- en: 'To print a variable of the `size_t` type within a `printf`, use the **`%zu`**
    format specifier:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`printf`中打印`size_t`类型的变量，请使用**`%zu`**格式说明符：
- en: '`size_t sz = 4 * getpagesize();`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`size_t sz = 4 * getpagesize();`'
- en: '`[...]`'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`[...]`'
- en: '`printf("size = %zu bytes\n", sz);`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf("size = %zu bytes\n", sz);`'
- en: In this book, we will not delve into the internal implementation details regarding
    how `malloc(3)` and friends actually store, allocate, and free memory (refer the
    *Further reading* section on the GitHub repository.) Suffice to say, the internal
    implementation strives to be as efficient as can be; using these APIs is usually
    considered the right way to perform memory-management.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们不会深入探讨`malloc(3)`和其它内部实现细节，实际上是如何存储、分配和释放内存的（请参阅GitHub存储库上的*进一步阅读*部分）。可以说，内部实现力求尽可能高效；通常认为使用这些API是执行内存管理的正确方式。
- en: The return value is a pointer to the zeroth byte of the newly-allocated memory
    region on success, and NULL on failure.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时返回值是指向新分配的内存区域的第一个字节的指针，失败时返回NULL。
- en: You will come across, shall we say *optimists*, who say things such as, "Don't
    bother checking malloc for failure, it never fails". Well, take that sage advice
    with a grain of salt. While it's true that malloc would rarely fail, the fact
    is (as you shall see), it could fail. Writing defensive code – code that checks
    for the failure case immediately – is a cornerstone of writing solid, robust programs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你会遇到，我们可以说是*乐观主义者*，他们会说诸如“不要费心检查`malloc`是否失败，它从不失败”。好吧，对这个明智的建议要持保留态度。虽然`malloc`很少会失败，但事实是（正如你将看到的），它可能会失败。编写防御性代码——立即检查失败情况的代码——是编写坚固、健壮程序的基石。
- en: 'So, using the API is very straightforward: as an example, allocate 256 bytes
    of memory dynamically, and store the pointer to that newly allocated region in
    the `ptr` variable:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用这个API非常简单：例如，动态分配256字节的内存，并将指向新分配区域的指针存储在`ptr`变量中：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As another typical example, the programmer needs to allocate memory for a data
    structure; let''s call it `struct sbar`. You could do so like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个典型的例子，程序员需要为一个数据结构分配内存；我们称之为`struct sbar`。你可以这样做：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Hey, astute reader! What about checking the failure case? It''s a key point,
    so we will rewrite the preceding code like so (and of course it would be the case
    for the `malloc(256)` code snippet too):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，敏锐的读者！那么检查失败情况呢？这是一个关键点，所以我们将像这样重写前面的代码（当然，对于`malloc(256)`的代码片段也是如此）：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s use one of the powerful tracing tools  `ltrace` to check that this works
    as expected; `ltrace` is used to display all library APIs in the process-execution
    path (similarly, use `strace` to trace all system calls). Let''s assume that we
    compile the preceding code and the resulting binary executable file is called
    `tst`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用强大的跟踪工具`ltrace`来检查这是否按预期工作；`ltrace`用于显示进程执行路径中的所有库API（类似地，使用`strace`来跟踪所有系统调用）。假设我们编译了前面的代码，生成的二进制可执行文件名为`tst`：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can clearly see `malloc(3)` (and the fact that the example structure we used
    took up 592 bytes on an x86_64), and its return value (following the `=` sign).
    The `free` API follows, and then it simply exits.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到`malloc(3)`（以及我们使用的示例结构在x86_64上占用了592字节），以及它的返回值（跟在`=`符号后面）。接着是`free`
    API，然后简单地退出。
- en: It's important to understand that the *content* of the memory chunk allocated
    by  `malloc(3)` is considered to be random. Thus, it's the programmer's responsibility
    to initialize the memory before reading from it; if you fail to do so, it results
    in a bug called **Uninitialized Memory Read** (**UMR***) *(more on this in the
    next chapter).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解`malloc(3)`分配的内存块的*内容*被认为是随机的。因此，程序员有责任在从中读取之前初始化内存；如果未能这样做，将导致一个称为**未初始化内存读取**（UMR）的错误（在下一章中会更详细介绍）。
- en: '`malloc(3)` always returns a memory region that is aligned on an 8-byte boundary.
    Need larger alignment values? Use the `posix_memalign(3)` API. Deallocate its
    memory as usual with free(3).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc(3)`总是返回一个按8字节边界对齐的内存区域。需要更大的对齐值吗？使用`posix_memalign(3)` API。像通常一样使用`free(3)`释放其内存。'
- en: Details can be found on the man page at [https://linux.die.net/man/3/posix_memalign](https://linux.die.net/man/3/posix_memalign).Examples
    of using the `posix_memalign(3)` API can be found in the *Locking memory* and
    *Memory protection* sections.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`posix_memalign(3)`的详细信息可以在man页面上找到[https://linux.die.net/man/3/posix_memalign](https://linux.die.net/man/3/posix_memalign)。使用`posix_memalign(3)`
    API的示例可以在*锁定内存*和*内存保护*部分找到。
- en: malloc(3) – some FAQs
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: malloc(3) – 一些常见问题
- en: 'The following are some FAQs that will help us to learn more about `malloc(3)`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常见问题，这些问题将帮助我们更多地了解`malloc(3)`：
- en: 'FAQ 1 : How much memory can `malloc(3)` allocate with a single call?'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见问题1：`malloc(3)`可以一次分配多少内存？
- en: A rather pointless question in practical terms, but one that is often asked!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际情况下是一个相当无意义的问题，但经常被问到！
- en: The parameter to `malloc(3)` is an integer value of the `size_t` data type,
    so, logically, the maximum number we can pass as a parameter to `malloc(3)` is
    the maximum value a `size_t` can take on the platform*.* Practically speaking,
    on a 64-bit Linux, `size_t` will be 8 bytes, which of course, in bits is 8*8 =
    64\. Therefore, the maximum amount of memory that can be allocated in a single
    `malloc(3)` call is `2^64`!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc(3)`的参数是`size_t`数据类型的整数值，因此，从逻辑上讲，我们可以作为参数传递给`malloc(3)`的最大数字是平台上`size_t`可以取的最大值。从实际上来说，在64位Linux上，`size_t`将是8字节，当然，以位来说是8*8
    = 64。因此，在单次`malloc(3)`调用中可以分配的最大内存量是`2^64`！'
- en: 'So, how much is it? Let''s be empirical (it''s important to read in [Chapter
    19](b6b41870-c02e-4379-af86-b5e501799c31.xhtml), *Troubleshooting and Best Practices*,
    and the brief discussion there on *The empirical approach*).and actually try it
    out (note that the following code snippet has to be linked with the math library
    using the `-lm` switch):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它是多少呢？让我们来实证（在[第19章](b6b41870-c02e-4379-af86-b5e501799c31.xhtml)中阅读很重要，*故障排除和最佳实践*，以及关于*实证方法*的简要讨论）。并实际尝试一下（请注意，以下代码片段必须使用`-lm`开关链接数学库）：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output, on an x86_64:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86_64上的输出：
- en: '**`sizeof size_t = 8; max param to malloc = 18446744073709551616`**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**`sizeof size_t = 8; max param to malloc = 18446744073709551616`**'
- en: 'Aha! That''s a mighty large number; more readably, it''s as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！这是一个非常大的数字；更易读地说，如下所示：
- en: '`2^64 = 18,446,744,073,709,551,616 = 0xffffffffffffffff`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`2^64 = 18,446,744,073,709,551,616 = 0xffffffffffffffff`'
- en: That's 16 EB (exabytes, which is 16,384 PB, which is 16 million TB)!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是16EB（EB，即16384PB，即1600万TB）！
- en: So, on a 64-bit OS, `malloc(3)` can allocate a maximum of 16 EB in a single
    call. In theory.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在64位操作系统上，`malloc(3)`可以在一次调用中分配最多16EB。理论上。
- en: 'As usual, there''s more to it: please see *FAQ 2*; it will reveal that the
    *theoretical* answer to this question is **8 exabytes** (8 EB).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，还有更多：请参见*常见问题2*；它将揭示这个问题的*理论*答案是**8EB**（8EB）。
- en: In practice, obviously, this would be impossible because, of course, that's
    the entire usermode VAS of the process itself. In reality, the amount of memory
    that can be allocated is limited by the amount of free memory contiguously available
    on the heap. Actually, there's more to it. As we shall soon learn (in the *How
    malloc(3) really behaves* section), memory for `malloc(3)` can come from other
    regions of the VAS, too. Don't forget there's a resource limit on data segment
    size; the default is usually unlimited, which as we discussed in this chapter,
    really means that there's no artificial limit imposed by the OS.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是不可能的，因为这当然是进程本身的整个用户模式VAS。实际上，可以分配的内存量受堆上连续可用的空闲内存量的限制。实际上，还有更多。正如我们很快将了解的那样（在*malloc(3)的真正行为*部分），`malloc(3)`的内存也可以来自VAS的其他区域。不要忘记数据段大小有资源限制；默认情况下通常是无限的，这意味着没有操作系统施加的人为限制，正如我们在本章中讨论的那样。
- en: So, in practice, it's best to be sensible, not assume anything, and check the
    return value for NULL.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在实践中，最好是明智一点，不要假设任何事情，并检查返回值是否为NULL。
- en: 'As an aside, what''s the maximum value a `size_t` can take on a 32-bit OS? Accordingly,
    we compile on x86_64 for 32-bit by passing the `-m32` switch to the compiler:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，在32位操作系统上，`size_t`可以取的最大值是多少？因此，我们通过向编译器传递`-m32`开关在x86_64上编译32位：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Clearly, it's 4 GB (gigabytes) – again, the entire VAS of a 32-bit process.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是4GB（千兆字节）- 再次，32位进程的整个VAS。
- en: 'FAQ 2: What if I pass `malloc(3)` a negative argument?'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见问题2：如果我传递`malloc(3)`一个负参数会怎么样？
- en: 'The data type of the parameter to `malloc(3)`, `size_t`, is an unsigned integerquantity –
    it cannot be negative. But, humans are imperfect, and **Integer OverFlow** (**IOF**)
    bugs do exist! You can imagine a scenario where a program attempts to calculate
    the number of bytes to allocate, like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`malloc(3)`的参数数据类型`size_t`是一个无符号整数量-它不能是负数。但是，人是不完美的，**整数溢出**（**IOF**）错误确实存在！你可以想象一个程序试图计算要分配的字节数的情况，就像这样：'
- en: '`num = qa * qb;`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`num = qa * qb;`'
- en: 'What if `num` is declared as a signed integer variable and `qa` and `qb` are
    large enough that the result of the multiplication operation causes an overflow?
    The `num` result will then wrap around and become negative! `malloc(3)` should
    fail, of course. But hang on: if the `num` variable is declared as `size_t` (which
    should be the case), the negative quantity will turn into some positive quantity!'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`num`声明为有符号整数变量，`qa`和`qb`足够大，使得乘法操作的结果导致溢出，`num`的结果将会变成负数！`malloc(3)`当然应该失败。但是等等：如果`num`变量声明为`size_t`（这应该是情况），负数将变成一些正数！
- en: The `mallocmax` program has a test case for this.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: mallocmax程序有一个针对此的测试用例。
- en: 'Here is the output when run on an x86_64 Linux box:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86_64 Linux系统上运行时的输出如下：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here are the relevant variable declarations:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是相关的变量声明：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, let's try it with a 32-bit version of the program.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试32位版本的程序。
- en: 'Note that on a default-install Ubuntu Linux box, the 32-bit compile may fail
    (with an error such as `fatal error: bits/libc-header-start.h: No such file or
    directory`*)*. Don''t panic: this usually implies that the compiler support for
    building 32-bit binaries isn''t present by default. To get it (as mentioned in
    the Hardware-Software List document), install the `multilib` compiler package:
    `sudo apt-get install gcc-multilib`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，在默认安装的Ubuntu Linux系统上，32位编译可能会失败（出现诸如`fatal error: bits/libc-header-start.h:
    No such file or directory`*）*的错误。不要惊慌：这通常意味着默认情况下没有编译32位二进制文件的编译器支持。要获得它（如在*硬件-软件列表*文档中提到的），安装`multilib`编译器包：`sudo
    apt-get install gcc-multilib`。'
- en: 'Compile it for 32-bit and run it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为32位编译并运行它：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To be fair, the compiler does warn us:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，编译器确实警告我们：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Interesting! The compiler answers our *FAQ 1* question now:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣！编译器现在回答了我们的*常见问题1*：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The maximum value you can allocate as per the compiler seems to be **`9223372036854775807`**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器允许分配的最大值似乎是9223372036854775807。
- en: 'Wow. A little calculator time reveals that this is 8192 PB = 8 EB! So, we must
    conclude that  the correct answer to the previous question: *How much memory can
    malloc allocate with a single call?* Answer: *8 exabytes*. Again, in theory.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 哇。简单的计算时间表明这是8192PB = 8EB！因此，我们必须得出结论：对于上一个问题的正确答案是：*`malloc`一次调用可以分配多少内存？*答案：*8EB*。再次，理论上。
- en: 'FAQ 3: What if I use `malloc(0)`?'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见问题3：如果我使用`malloc(0)`会怎么样？
- en: Not much; depending on the implementation, `malloc(3)` will return NULL, or,
    a non-NULL pointer that can be passed to free. Of course, even if the pointer
    is non-NULL, there is no memory, so don't attempt to use it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不多；根据实现的不同，`malloc(3)`将返回NULL，或者一个可以传递给free的非NULL指针。当然，即使指针是非NULL的，也没有内存，所以不要尝试使用它。
- en: 'Let''s try it out:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We compile and then run it via `ltrace`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编译然后通过`ltrace`运行它：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, `malloc(0)` did indeed return a non-NULL pointer.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`malloc(0)`确实返回了一个非NULL指针。
- en: 'FAQ 4: What if I use `malloc(2048)` and attempt to read/write beyond 2,048
    bytes?'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见问题4：如果我使用`malloc(2048)`并尝试读/写超出2048字节会怎么样？
- en: This is a bug of course – an out-of-bounds memory-access bug, further defined
    as a read or write buffer overflow. Hang on please, the detailed discussion of
    memory bugs (and subsequently, how to find and fix them) is the subject of [Chapter
    5](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml), *Linux Memory Issues*, and [Chapter
    6](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml), *Debugging Tools for Memory Issues*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个错误-一个越界内存访问错误，进一步定义为读取或写入缓冲区溢出。请稍等，关于内存错误的详细讨论（以及随后如何找到和修复它们）是[第5章](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml)的主题，*Linux内存问题*，以及[第6章](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml)，*内存问题的调试工具*。
- en: malloc(3) – a quick summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: malloc(3) - 快速总结
- en: 'So, let''s summarize the key points regarding usage of the `malloc(3)` API:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们总结一下关于`malloc(3)` API使用的关键点：
- en: '`malloc(3)` dynamically (at runtime) allocates memory from the process heap'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`malloc(3)`在运行时从进程堆中动态分配内存'
- en: As we shall soon learn, this is not always the case
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们很快将了解的那样，这并不总是情况
- en: The single parameter to `malloc(3)` is an unsigned integer value—the number
    of bytes to allocate
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`malloc(3)`的单个参数是一个无符号整数值-要分配的字节数。'
- en: 'The return value is a pointer to the start of the newly allocated memory chunk
    on success, or NULL on failure:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功时返回值是指向新分配的内存块开头的指针，失败时返回NULL：
- en: You must check for the failure case; don't just assume it will succeed
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须检查失败的情况；不要假设它会成功
- en: '`malloc(3)` always returns a memory region that is aligned on an 8-byte boundary'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`malloc(3)`总是返回一个按8字节边界对齐的内存区域'
- en: The content of the newly allocated memory region is considered to be random
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新分配的内存区域的内容被认为是随机的
- en: You must initialize it before reading from any part of it
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在从中读取任何部分之前，您必须对其进行初始化
- en: You must free the memory you allocate
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须释放您分配的内存
- en: The free API
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: free API
- en: One of the golden rules of development in this ecosystem is that programmer-allocated
    memory must be freed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个生态系统中开发的黄金规则之一是程序员分配的内存必须被释放。
- en: Failure to do so leads to a bad situation – a bug, really – called **memory
    leakage**; this is covered in some depth in the next chapter. Carefully matching
    your allocations and frees is essential.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 未能这样做会导致糟糕的情况-一个错误，真的-称为**内存泄漏**；这在下一章中有比较深入的介绍。仔细匹配您的分配和释放是至关重要的。
- en: Then again, in smaller real-world projects (utils), you do come across cases
    where memory is allocated exactly once; in such cases, freeing the memory is pedantic
    as the entire virtual address space is destroyed upon process-termination. Also,
    using the *alloca(3)* API implies that you do not need to free the memory region
    (seen later in, *Advanced features *section). Nevertheless, you are advised to
    err on the side of caution!
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在较小的实际项目（实用程序）中，您会遇到只分配一次内存的情况；在这种情况下，释放内存是迂腐的，因为整个虚拟地址空间在进程终止时被销毁。此外，使用`alloca(3)`
    API意味着您不需要释放内存区域（稍后在*高级特性*部分中看到）。尽管如此，建议您谨慎行事！
- en: 'Using the `free(3)` API is straightforward:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`free(3)` API很简单：
- en: '`void free(void *ptr);`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`void free(void *ptr);`'
- en: 'It accepts one parameter: the pointer to the memory chunk to be freed. `ptr`
    must be a pointer returned by one of the `malloc(3)` family routines: `malloc(3)`,
    `calloc`, or `realloc[array]`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个参数：要释放的内存块的指针。`ptr`必须是`malloc(3)`系列例程（`malloc(3)`，`calloc`或`realloc[array]`）返回的指针。
- en: '`free` does not return any value; don''t even attempt to check whether it worked;
    if you used it correctly, it worked. More on free is found in the *Where does
    freed memory go?* section. Once a memory chunk is freed, you obviously cannot
    attempt to use any part of that memory chunk again; doing so will result in a
    bug (or what''s called **UB – undefined behavior**).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`free`不返回任何值；甚至不要尝试检查它是否起作用；如果您使用正确，它就起作用了。有关free的更多信息，请参阅*释放的内存去哪里了？*部分。一旦释放了内存块，您显然不能尝试再次使用该内存块的任何部分；这样做将导致错误（或者所谓的**UB-未定义行为**）。'
- en: 'A common misconception regarding `free()` sometimes leads to its being used
    in a buggy fashion; take a look at this pseudocode snippet:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`free()`的一个常见误解有时会导致其以错误的方式使用；看一下这个伪代码片段：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This program will possibly crash in the loop (within the `<use ''ptr'' here>`
    code) in a few iterations. Why? Because the `ptr` memory pointer is freed and
    is attempting to be reused. But how come? Ah, look carefully: the code snippet
    is only going to `malloc(3)` the `ptr` pointer if it is currently NULL, that is,
    its programmer has assumed that once we `free()` memory, the pointer we just freed
    gets set to NULL. This is not the case!!'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序可能会在循环中崩溃（在`<use 'ptr' here>`代码内）。为什么？因为`ptr`内存指针被释放并且正在尝试被重用。但是为什么？啊，仔细看：代码片段只有在`ptr`当前为NULL时才会`malloc(3)`指针，也就是说，其程序员假设一旦我们`free()`内存，我们刚刚释放的指针就会被设置为NULL。这并不是事实！
- en: Be wary and be defensive in writing code. Don't assume anything; it's a rich
    source of bugs. Importantly, our [Chapter 19](b6b41870-c02e-4379-af86-b5e501799c31.xhtml),
    *Troubleshooting and Best Practices*, covers such points)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时要谨慎并且要有防御性。不要假设任何事情；这是一个错误的丰富来源。重要的是，我们的[第19章](b6b41870-c02e-4379-af86-b5e501799c31.xhtml)，*故障排除和最佳实践*，涵盖了这些要点）
- en: free – a quick summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: free - 快速总结
- en: 'So, let''s summarize the key points regarding the usage of the *free* API:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们总结一下关于*free* API使用的关键点：
- en: The parameter passed to `free(3)` must be a value returned by one of the `malloc(3)`
    family APIs (`malloc(3)`, `calloc`, or `realloc[array]`).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给`free(3)`的参数必须是`malloc(3)`系列API（`malloc(3)`，`calloc`或`realloc[array]`）返回的值。
- en: '`free` has no return value.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`free`没有返回值。'
- en: Calling `free(ptr)` does not set `ptr` to `NULL` (that would be nice, though).
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`free(ptr)`不会将`ptr`设置为`NULL`（尽管这样做会很好）。
- en: Once freed, do not attempt to use the freed memory.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦释放，不要尝试使用已释放的内存。
- en: Do not attempt to *free* the same memory chunk more than once (it's a bug –
    UB).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要尝试多次*free*相同的内存块（这是一个错误-UB）。
- en: For now, we will assume that freed memory goes back to the system.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，我们将假设释放的内存返回给系统。
- en: For Heaven's sake, do not forget to free memory that was dynamically allocated
    earlier. The forgotten memory is said to have *leaked out* and that's a really
    hard bug to catch! Luckily, there are tools that help us catch these bugs. More
    in [Chapter 5](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml), *Linux Memory Issues*, and
    [Chapter 6](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml), *Debugging Tools for
    Memory Issues*.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天哪，不要忘记释放先前动态分配的内存。被遗忘的内存被称为*泄漏*，这是一个非常难以捕捉的错误！幸运的是，有一些工具可以帮助我们捕捉这些错误。更多内容请参阅[第5章](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml)，*Linux内存问题*，和[第6章](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml)，*内存问题的调试工具*。
- en: The calloc API
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: calloc API
- en: 'The `calloc(3)` API is almost identical to `malloc(3)`, differing in two main
    respects:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`calloc(3)` API与`malloc(3)`几乎相同，主要有两个不同之处：'
- en: It initializes the memory chunk it allocates to the zero value (that is, ASCII
    0 or NULL, not the number `0`)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将分配的内存块初始化为零值（即ASCII 0或NULL，而不是数字`0`）
- en: It accepts two parameters, not one
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接受两个参数，而不是一个
- en: 'The `calloc(3)` function signature is as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`calloc(3)`函数签名如下：'
- en: '` void *calloc(size_t nmemb, size_t size);`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '` void *calloc(size_t nmemb, size_t size);`'
- en: 'The first parameter, `nmemb`, is n members; the second parameter, `size`, is
    the size of each member. In effect, `calloc(3)` allocates a memory chunk of `(nmemb*size)`
    bytes. So, if you want to allocate memory for an array of, say, 1,000 integers,
    you can do so like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`nmemb`是n个成员；第二个参数`size`是每个成员的大小。实际上，`calloc(3)`分配了一个大小为`(nmemb*size)`字节的内存块。因此，如果你想为一个包含1,000个整数的数组分配内存，你可以这样做：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Assuming the size of an integer is 4 bytes, we would have allocated a total
    of (1000*4) = 4000 bytes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 假设整数的大小为4字节，我们将总共分配了（1000*4）= 4000字节。
- en: Whenever one requires memory for an array of items (a frequent use case in applications
    is an array of structures), `calloc` is a convenient way to both allocate and
    simultaneously initialize the memory.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每当需要为一组项目分配内存（在应用程序中经常使用的一种情况是结构数组），`calloc`是一种方便的方式，既可以分配内存，又可以同时初始化内存。
- en: Demand paging (covered later in this chapter), is another reason programmers
    use `calloc` rather than `malloc(3)` (in practice, this is mostly useful for realtime
    applications). Read up on this in the up coming section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 需求分页（本章后面介绍），是程序员使用`calloc`而不是`malloc(3)`的另一个原因（在实践中，这对实时应用程序非常有用）。在即将到来的部分中了解更多信息。
- en: The realloc API
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: realloc API
- en: 'The `realloc` API is used to *resize* an existing memory chunk—to grow or shrink
    it. This resizing can only be performed on a piece of memory previously allocated
    with one of the `malloc(3)` family of APIs (the usual suspects: `malloc(3)`, `calloc`,
    or `realloc[array]`). Here is its signature:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`realloc` API用于*调整*现有内存块的大小——增大或缩小。这种调整只能在先前使用`malloc(3)`系列API之一（通常的嫌疑犯：`malloc(3)`，`calloc`或`realloc[array]`）分配的内存块上执行。以下是其签名：'
- en: '` void *realloc(void *ptr, size_t size);`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '` void *realloc(void *ptr, size_t size);`'
- en: The first parameter, `ptr`, is a pointer to a chunk of memory previously allocated
    with one of the `malloc(3)` family of APIs; the second parameter, `size`, is the
    new size of the memory chunk—it can be larger or smaller than the original, thus
    growing or shrinking the memory chunk.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`ptr`是先前使用`malloc(3)`系列API之一分配的内存块的指针；第二个参数`size`是内存块的新大小——它可以比原来的大或小，从而增大或缩小内存块。
- en: 'A quick example code snippet will help us understand `realloc`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个快速的示例代码片段将帮助我们理解`realloc`：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The pointer returned by `realloc` is the pointer to the newly resized chunk
    of memory; it may or may not be the same address as the original `ptr`. In effect,
    you should now completely disregard the original pointer `ptr`  and regard the realloc-returned
    `newptr` pointer as the one to work with. If it fails, the return value is NULL
    (check it!) and the original memory chunk is left untouched.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`realloc`返回的指针是新调整大小的内存块的指针；它可能与原始`ptr`的地址相同，也可能不同。实际上，你现在应该完全忽略原始指针`ptr`，并将`realloc`返回的`newptr`指针视为要处理的指针。如果失败，返回值为NULL（检查它！），原始内存块将保持不变。'
- en: 'A key point: the pointer returned by `realloc(3)`, `newptr`, is the one that
    must be subsequently freed, *not* the original pointer (`ptr`) to the (now resized)
    memory chunk. Of course, do not attempt to free both pointers, as that to is a
    bug.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键点：`realloc(3)`返回的指针`newptr`是随后必须释放的指针，*而不是*指向（现在调整大小的）内存块的原始指针（`ptr`）。当然，不要尝试释放两个指针，因为那是一个错误。
- en: What about the contents of the memory chunk that just got resized? They remain
    unchanged up to `MIN(original_size, new_size)`. Thus, in the preceding example,
    `MIN(100, 150) = 100`, the contents of memory up to 100 bytes will be unchanged.
    What about the remainder (50 bytes)? It's considered to be random content (just
    like `malloc(3)`).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚调整大小的内存块的内容呢？它们保持不变，直到`MIN(original_size, new_size)`。因此，在前面的例子中，`MIN(100,
    150) = 100`，100字节的内存内容将保持不变。剩下的部分（50字节）呢？它被视为随机内容（就像`malloc(3)`一样）。
- en: The realloc(3) – corner cases
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`realloc(3)——边界情况`'
- en: 'Consider the following code snippet:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The pointer passed to `realloc` is `NULL`? The library treats this as equivalent
    to a new allocation – `malloc(150)`; and all the implications of the `malloc(3)` That's
    it.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`realloc`传递的指针是`NULL`？库将其视为等同于新分配的`malloc(150)`；以及`malloc(3)`的所有含义。就是这样。'
- en: 'Now, consider the following code snippet:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下代码片段：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The size parameter passed to `realloc` is `0`? The library treats this as equivalent
    to `free(ptr)`*.* That's it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`realloc`的大小参数是`0`？库将其视为等同于`free(ptr)`*.*就是这样。
- en: The reallocarray API
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: reallocarray API
- en: 'A scenario: you allocate memory for an array using `calloc(3)`; later, you
    want to resize it to be, say, a lot larger. We can do so with `realloc(3)`; for
    example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一种情况：你使用`calloc(3)`为一个数组分配内存；后来，你想将其调整大小为更大。我们可以使用`realloc(3)`来做到；例如：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Fine. There''s an easier way, though—using the `reallocarray(3)` API. Its signature
    is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。不过，有一种更简单的方法——使用`reallocarray(3)` API。其签名如下：
- en: '` void *reallocarray(void *ptr, size_t nmemb, size_t size);`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '` void *reallocarray(void *ptr, size_t nmemb, size_t size);`'
- en: 'With it, the code becomes simpler:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有了它，代码变得更简单：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The return value of `reallocarray` is pretty identical to that of the `realloc`
    API: the new pointer to the resized memory chunk on success (it may differ from
    the original), `NULL` on failure. If it fails, the original memory chunk is left
    untouched.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`reallocarray`的返回值与`realloc` API非常相似：成功时调整大小的新内存块的新指针（可能与原始指针不同），失败时为`NULL`。如果失败，原始内存块将保持不变。'
- en: '`reallocarray` has one real advantage over `realloc` – safety. From the man
    page on *realloc(3),* see this snippet:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`reallocarray`相对于`realloc`有一个真正的优势——安全性。从*realloc(3)*的手册页上看到这段代码：'
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Also realize that the `reallocarray` API is a GNU extension; it will work on
    modern Linux but should not be considered portable to other OSes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 还要意识到，`reallocarray`API是GNU的扩展；它将在现代Linux上工作，但不应被认为在其他操作系统上是可移植的。
- en: 'Finally, consider this: some projects have strict alignment requirements for
    their data objects; using `calloc`(or even allocating said objects via `malloc(3)`)
    can result in subtle bugs! Later in this chapter, we''ll use the `posix_memalign(3)`API—it
    guarantees allocating memory to a given byte alignment (you specify the number
    of bytes)! For example, requiring a memory-allocation to be aligned to a page
    boundary is a fairly common occurrence (Recall, malloc always returns a memory
    region that is aligned on an 8-byte boundary).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请考虑：一些项目对其数据对象有严格的对齐要求；使用`calloc`（甚至通过`malloc(3)`分配这些对象）可能导致微妙的错误！在本章后面，我们将使用`posix_memalign(3)`API——它保证按给定的字节对齐分配内存（您指定字节数）！例如，要求内存分配对齐到页面边界是相当常见的情况（请回忆，malloc总是返回一个按8字节边界对齐的内存区域）。
- en: 'The bottom line: be careful. Read the documentation, think, and decide which
    API would be appropriate given the circumstances. More on this in the *Further
    reading *section on the GitHub repository.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 底线：小心。阅读文档，思考，并决定在特定情况下哪个API更合适。在GitHub存储库的*进一步阅读*部分中有更多信息。
- en: Beyond the basics
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础之外
- en: In this section, we will dig a bit deeper into dynamic memory management with
    the `malloc(3)` API family. Understanding these areas, and the content of [Chapter
    5](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml), *Linux Memory Issues*, and  [Chapter
    6](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml), *Debugging Tools for Memory Issues*,
    will go a long way in helping developers effectively debug common memory bugs
    and issues.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨`malloc(3)`API系列的动态内存管理。了解这些领域，以及[第5章](066d0c5c-5b82-4a63-bb4c-ca2503e32ea4.xhtml)的内容，*Linux内存问题*，以及[第6章](406956b7-38f0-40c1-a76b-366ab36db17b.xhtml)，*内存问题的调试工具*，将有助于开发人员有效地调试常见的内存错误和问题。
- en: The program break
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序中断
- en: When a process or thread wants memory, it invokes one of the dynamic memory
    routines—usually `malloc(3)` or `calloc(3)`; this memory (usually) comes from
    the **heap segment**. As mentioned earlier, the heap is a dynamic segment – it
    can grow (toward higher virtual addresses). Obviously though, at any given point
    in time, the heap has an endpoint or top beyond which memory cannot be taken.
    This endpoint—the last legally reference-able location on the heap – is called
    the **program break**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程或线程需要内存时，它调用动态内存例程之一——通常是`malloc(3)`或`calloc(3)`；这段内存（通常）来自**堆段**。如前所述，堆是一个动态段——它可以增长（朝着更高的虚拟地址）。显然，但是，在任何给定的时间点，堆都有一个终点或顶部，超过这个顶部就不能再取内存了。这个终点——堆上最后一个合法可引用的位置——称为**程序中断**。
- en: Using the sbrk() API
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sbrk() API
- en: 'So, how do you know where the current program break is? That''s easy – the
    `sbrk(3)` API, when used with a parameter value of zero, returns the current program
    break! Let''s do a quick lookup:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你如何知道当前程序中断在哪里？这很容易——当使用参数值为零的`sbrk(3)`API时，它会返回当前程序中断！让我们快速查找一下：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You will see some sample output as follows when the preceding line of code
    runs:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当前面的代码行运行时，您将看到以下示例输出：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It works, but why does the program break value keep changing (seemingly randomly)?
    Well, it really *is* random: for security reasons, Linux randomizes the layout
    of a process''s virtual address space (we covered the process VAS layout in [Chapter
    2](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml), *Virtual Memory*). This technique
    is called **Address Space Layout Randomization** (**ASLR**).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效，但为什么程序中断值保持改变（看起来是随机的）？嗯，它确实是随机的：出于安全原因，Linux随机化了进程的虚拟地址空间布局（我们在[第2章](976fc2af-8bb4-4060-96cd-3b921682ed75.xhtml)中介绍了进程VAS布局，*虚拟内存*）。这种技术称为**地址空间布局随机化**（**ASLR**）。
- en: 'Let''s do a bit more: we will write a program that, if run without any parameters,
    merely displays the current program break and exits (like the one we just saw);
    if passed a parameter – the number of bytes of memory to dynamically allocate –
    it does so (with `malloc(3)`), then prints the heap address returned as well as
    the original and current program break. Here, you will only be allowed to request
    less than 128 KB, for reasons that will be made clear shortly.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再做一点：我们将编写一个程序，如果没有任何参数运行，仅显示当前程序中断并退出（就像我们刚才看到的那样）；如果传递一个参数——动态分配内存的字节数，它将这样做（使用`malloc(3)`），然后打印返回的堆地址以及原始和当前程序中断。在这里，您只能请求少于128KB的内存，稍后将会解释原因。
- en: 'Refer to the `ch4/show_curbrk.c`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 参考`ch4/show_curbrk.c`：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s try it out:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Interesting (see the following diagram)! With an allocation of 1,024 bytes,
    the heap pointer that's returned to the start of that memory chunk is `0x1488670`;
    that's `0x1488670 - 0x1488000 = 0x670 = 1648` bytes from the original break.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣（见下图）！使用1024字节的分配，返回到该内存块开头的堆指针是`0x1488670`；这是从原始中断的`0x1488670 - 0x1488000
    = 0x670 = 1648`字节。
- en: 'Also, the new break value is `0x14a9000`, which is `(0x14a9000 - 0x1488670
    = 133520)`, approximately 130 KB from the freshly allocated block. Why did the
    heap grow by so much for a mere 1 KB allocation? Patience; this, and more, will
    be examined in the next section, *How malloc(3) really behaves.* Meanwhile, refer
    to the following diagram:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 还要意识到，新的中断值是`0x14a9000`，即`(0x14a9000 - 0x1488670 = 133520)`，大约从新分配的块增加了130KB。为什么堆为了仅仅1KB的分配而增长了这么多？耐心等待；这个问题以及更多内容将在下一节*malloc(3)的真正行为*中进行探讨。同时，请参考下图：
- en: '![](img/ecb44780-bcc1-448b-9677-5f2fa6f43f36.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecb44780-bcc1-448b-9677-5f2fa6f43f36.png)'
- en: Heap and the Program Break
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 堆和程序中断
- en: 'With respect to the preceding diagram:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的图表：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that `sbrk(2)` can be used to increment or decrement the program break
    (by passing it an integer parameter). At first glance, this might seem like a
    good way to allocate and deallocate dynamic memory; in reality, it's always better
    to use the well-documented and portable glibc implementation, the `malloc(3)`
    family APIs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`sbrk(2)`可以用于增加或减少程序断点（通过传递整数参数）。乍一看，这似乎是分配和释放动态内存的一种好方法；实际上，最好使用经过充分记录和可移植的glibc实现，即`malloc(3)`家族的API。
- en: '`sbrk` is a convenient library wrapper over the `brk(2)` system call.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`sbrk`是对`brk(2)`系统调用的一个方便的库包装。'
- en: How malloc(3) really behaves
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: malloc(3)的真正行为
- en: The general consensus it that `malloc(3)` (and `calloc(3)` and `realloc[array](3)`)
    obtains its memory from the heap segment. This is indeed the case, but digging
    a bit deeper reveals that it's not *always* the case. The modern glibc `malloc(3)`
    engine uses some subtle strategies to make the most optimal use of available memory
    regions and the process VAS—which, especially on today's 32-bit systems, is fast
    becoming a rather scarce resource.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 普遍的共识是，`malloc(3)`（以及`calloc(3)`和`realloc[array](3)`）从堆段获取其内存。这确实是事实，但深入挖掘会发现这并非*总是*如此。现代的glibc
    `malloc(3)`引擎使用一些微妙的策略来最优化地利用可用的内存区域和进程VAS——尤其是在当今的32位系统上，这已经成为一种相当稀缺的资源。
- en: 'So, how does it work? The library uses a predefined `MMAP_THRESHOLD` variable – its
    value is 128 KB by default – to determine from where memory gets allocated. Let''s
    imagine we are allocating *n* bytes of memory with malloc(n):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，它是如何工作的呢？库使用预定义的`MMAP_THRESHOLD`变量–其默认值为128 KB–来确定从哪里分配内存。让我们想象一下，我们正在使用malloc(n)分配*n*字节的内存：
- en: If *n < MMAP_THRESHOLD,* use the heap segment to allocate the requested *n*
    bytes
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*n < MMAP_THRESHOLD*，则使用堆段来分配请求的*n*字节
- en: If *n >= MMAP_THRESHOLD*, and if n bytes are not available on the heap's free
    list, use an arbitrary free region of virtual address space to satisfy the requested
    *n* bytes allocation
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*n >= MMAP_THRESHOLD*，并且堆的空闲列表中没有n字节可用，则使用虚拟地址空间的任意空闲区域来满足请求的*n*字节分配。
- en: How exactly is the memory allocated in the second case? Ah, `malloc(3)` internally
    calls `mmap(2)` – the memory map system call. The `mmap` system call is very versatile.
    In this case, it is made to reserve a free region of n bytes of the calling process's
    virtual address space!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况下内存是如何分配的？啊，`malloc(3)`在内部调用`mmap(2)`——内存映射系统调用。`mmap`系统调用非常灵活。在这种情况下，它被用来保留调用进程的虚拟地址空间中的n字节的空闲区域！
- en: Why use `mmap(2)`? The key reason is that mmap-ed memory can always be freed
    up (released back to the system) in an independent fashion whenever required;
    this is certainly not always the case with `free(3)`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用`mmap(2)`？关键原因是mmap的内存总是可以在需要时以独立的方式释放（归还给系统）；这在使用`free(3)`时并非总是如此。
- en: Of course, there are some downsides: `mmap` allocations can be expensive because,
    the memory is page-aligned (and could thus be wasteful), and the kernel zeroes
    out the memory region (this hurts performance).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也有一些缺点：`mmap`分配可能很昂贵，因为内存是页面对齐的（因此可能是浪费的），而且内核会将内存区域清零（这会影响性能）。
- en: The `mallopt(3)` man page (circa December 2016) also notes that nowadays, glibc
    uses a dynamic mmap threshold; initially, the value is the usual 128 KB, but if
    a large memory chunk between the current threshold and `DEFAULT_MMAP_THRESHOLD_MAX`
    is freed, the threshold is increased to become the size of the freed block.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`mallopt(3)`手册页（截至2016年12月）还指出，现在的glibc使用动态mmap阈值；最初的值是通常的128 KB，但如果在当前阈值和`DEFAULT_MMAP_THRESHOLD_MAX`之间释放了一个大内存块，阈值就会增加到与释放块的大小相同。'
- en: Code example – malloc(3) and the program break
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例– malloc(3)和程序断点
- en: 'Seeing for ourselves the effect of `malloc(3)` allocations on the heap and
    process virtual address space is interesting and educational. Check out the output
    of the following code example (the source is available in this book''s Git repository):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们亲眼看到`malloc(3)`分配对堆和进程虚拟地址空间的影响是有趣且富有教育意义的。查看以下代码示例的输出（源代码可在本书的Git存储库中找到）：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are several scenarios running in this application; let's examine some
    of them now.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中有几种情景正在运行；现在让我们来检查其中的一些。
- en: Scenario 1 – default options
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情景1–默认选项
- en: 'We run the `malloc_brk_test` program with no parameters, that is, using the
    defaults:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以默认方式运行`malloc_brk_test`程序，即不使用任何参数：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The process prints out its initial program break value: `0x1c97000`. It then
    allocates just 8 bytes (via the `malloc(3)` API); under the hood, the glibc allocation
    engine invokes the *sbrk(2)* system call to grow the heap; the new break is now `0x1cb8000`,
    an increase of 135,168 bytes = 132 KB from the previous break (clearly seen in
    the `delta` column in the preceding code)!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 进程打印出其初始程序断点值：`0x1c97000`。然后它只分配了8字节（通过`malloc(3)`API）；在幕后，glibc分配引擎调用了*sbrk(2)*系统调用来增加堆；新的断点现在是`0x1cb8000`，比之前的断点增加了135,168字节=
    132 KB（在前面的代码中的`delta`列中清楚可见）！
- en: 'Why? Optimization: glibc anticipates that, in the future, the process will
    require more heap space; instead of the expense of invoking a system call (*`sbrk/brk`)*
    each time, it performs one large-ish heap-growing operation. The next two `malloc(3)` APIs
    (numbers 1 and 2 in the left-most column) prove this is the case: we allocate
    4,083 and 3 bytes respectively, and what do you notice? The program break does
    *not* change – the heap is already large enough to accommodate the requests.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '为什么？优化：glibc预期，将来进程将需要更多的堆空间；而不是每次调用系统调用（*`sbrk/brk`)*的开销，它执行一次相当大的堆增长操作。左侧列中的下两个`malloc(3)`API（编号为1和2）证明了这一点：我们分别分配了4,083和3字节，你注意到了什么？程序断点*没有*改变–堆已经足够大，可以容纳这些请求。 '
- en: Scenario 2 – showing malloc statistics
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情景2–显示malloc统计信息
- en: 'This time, we pass the `1` parameter, asking it to display `malloc(3)` statistics
    as well (achieved using the `malloc_stats(3)` API):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们传递了`1`参数，要求它也显示`malloc(3)`的统计信息（使用`malloc_stats(3)`API实现）：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is similar, except the program invokes the useful `malloc_stats(3)`
    API, which queries and prints `malloc(3)` state information to `stderr` (by the
    way, an arena is an allocation area that''s internally maintained by the `malloc(3)`
    engine). From this output, notice that:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 输出类似，除了程序调用有用的`malloc_stats(3)` API，该API查询并打印`malloc(3)`的状态信息到`stderr`（顺便说一句，arena是`malloc(3)`引擎内部维护的分配区域）。从这个输出中，注意到：
- en: The available free memory – system bytes – is 132 KB (after performing a tiny
    8 byte `malloc(3)`)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的空闲内存-系统字节-为132 KB（在执行一个小的8字节`malloc(3)`之后）
- en: In-use bytes increases with each allocation but system bytes remains the same
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次分配时，正在使用的字节都会增加，但系统字节保持不变
- en: '`mmap` regions and `mmap` bytes is zero as no mmap-based allocations have occurred.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mmap`区域和`mmap`字节数为零，因为没有发生基于mmap的分配。'
- en: Scenario 3 – large allocations option
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 情景3-大分配选项
- en: 'This time, we pass the `2` parameter, asking the program to perform larger
    allocations (greater than `MMAP_THRESHOLD`):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们传递了`2`参数，要求程序执行更大的分配（大于`MMAP_THRESHOLD`）：
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: (Note that the preceding code we have clipped the output of the first two small
    allocations and only show the relevant large ones).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，我们已经剪辑了前两个小分配的输出，并且只显示了相关的大分配）。
- en: 'Now, we allocate 132 KB (point 3 in the preceding output); some thing to take
    note of are as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们分配132 KB（前面输出的第3点）；需要注意的是：
- en: 'The allocations (#3 and #4) are for 132 KB and 1 MB – both above the `MMAP_THRESHOLD`
    (value of 128 KB)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分配（＃3和＃4）分别为132 KB和1 MB - 都超过了`MMAP_THRESHOLD`（值为128 KB）
- en: The (arena 0) heap *in-use bytes* (5,792) has *not* changed at all across these
    two allocations, indicating that heap memory has *not* been used
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （arena 0）堆*正在使用的字节*（5,792）在这两个分配中完全没有改变，表明堆内存*没有*被使用
- en: The max mmap regions and max mmap bytes numbers have changed to positive values
    (from zero), indicating the use of mmap-ed memory
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大的mmap区域和最大的mmap字节数已经改变为正值（从零开始），表示使用了mmap内存
- en: A couple of remaining scenarios will be examined later.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后将检查剩下的几种情况。
- en: Where does freed memory go?
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 释放的内存去哪了？
- en: '`free(3)`, of course, is a library routine – so it stands to reason that when
    we free up memory, previously allocated by one of the dynamic allocation routines,
    it does not get freed back to the system, but rather to the process heap (which,
    of course, is virtual memory).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`free(3)`，当然，是一个库例程，所以可以推断，当我们释放内存，之前由动态分配例程之一分配的内存不会被释放回系统，而是被释放到进程堆（当然，这是虚拟内存）。'
- en: 'However, there are at least two cases where this may not occur:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，至少有两种情况下可能不会发生这种情况：
- en: If the allocation was satisfied internally via *mmap* rather than via the heap
    segment, it gets immediately freed back to the system
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果分配是通过*mmap*而不是通过堆段内部满足的，它会立即被释放回系统。
- en: On modern glibc, if the amount of heap memory being freed is very large, this
    triggers the return of at least some of the memory chunks back to the OS.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现代的glibc上，如果释放的堆内存量非常大，这会触发将至少一些内存块返回给操作系统。
- en: Advanced features
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级功能
- en: 'A few advanced features will now be covered:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将介绍一些高级功能：
- en: Demand paging
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需求分页
- en: Locking memory in RAM
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定内存在RAM中
- en: Memory protection
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存保护
- en: Allocation with the *alloca(3)*
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*alloca(3)*进行分配
- en: Demand-paging
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求分页
- en: Most of us know that if a process dynamically allocates memory, with `malloc`,
    say it does `ptr = malloc(8192) ;`, then, assuming success, the process is now
    allocated 8 KB of physical RAM. It might come as a surprise, but, on modern OSes
    such as Linux, this is actually not the case.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们大多数人都知道，如果一个进程动态分配内存，使用`malloc`，比如它做了`ptr = malloc(8192) ;`，然后，假设成功，进程现在分配了8
    KB的物理RAM。这可能会让人感到惊讶，但是，在现代的操作系统如Linux上，实际上并不是这样。
- en: So, what is the case? (In this book, we do not delve into kernel-level details.
    Also, as you might be aware, the granularity of memory at the level of the OS
    allocator is a *page*, which is typically 4 KB.)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，情况是什么？（在本书中，我们不深入研究内核级细节。另外，正如你可能知道的，操作系统分配器的内存粒度是*页面*，通常为4 KB。）
- en: It's not a good idea to assume anything when writing robust software. So, how
    can you correctly determine the page size on the OS? Use the `sysconf(3)` API;
    for example, `printf("page size = %ld\n", **sysconf(_SC_PAGESIZE)**);`, which
    outputs `page size = 4096`.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写健壮的软件时，假设任何事情都不是一个好主意。那么，如何正确确定操作系统的页面大小？使用`sysconf(3)` API；例如，`printf("page
    size = %ld\n", **sysconf(_SC_PAGESIZE)**);`，输出`page size = 4096`。
- en: 'Alternatively, use the `getpagesize(2)` system call to retrieve the system
    page size. (Importantly, see [Chapter 19](b6b41870-c02e-4379-af86-b5e501799c31.xhtml),
    *Troubleshooting and Best Practices*, covering similar points in the section *A
    Programmer’s Checklist: 7 Rules*).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，使用`getpagesize(2)`系统调用来检索系统页面大小。（重要的是，参见[第19章](b6b41870-c02e-4379-af86-b5e501799c31.xhtml)，*故障排除和最佳实践*，在*程序员的清单：7条规则*部分涵盖了类似的观点）。
- en: Realistically, all malloc does is reserve virtual pages of memory from the process
    VAS.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，所有的malloc只是从进程VAS中保留虚拟页面的内存。
- en: So, when does the process get the actual physical pages? Ah, as and when the
    process actually peeks or pokes any byte in a page, in reality when it makes any
    kind of access on any byte of the page (attempting to read/write/execute it),
    the process traps into the OS – via a hardware exception called a page fault –
    and in the OS's fault handler, if all's well, the OS allocates a physical page
    frame for the virtual page. This highly optimized manner of handing out physical
    memory to processes is called **demand-paging** – the pages are only physically
    allocated when they are actually required, on-demand! This is closely related
    to what OS folks call the memory or VM overcommit feature; yes, it's a feature,
    not a bug.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，进程何时获得实际的物理页面呢？啊，当进程实际上窥视或触及页面中的任何字节时，实际上是在任何页面上进行任何访问（尝试读取/写入/执行它）时，进程会陷入操作系统
    - 通过称为页面错误的硬件异常 - 并且在操作系统的错误处理程序中，如果一切正常，操作系统会为虚拟页面分配一个物理页帧。这种高度优化的向进程分配物理内存的方式称为**需求分页**
    - 只有在实际需要时才会分配物理页面！这与操作系统人员所称的内存或虚拟内存超额分配功能密切相关；是的，这是一个功能，而不是一个错误。
- en: 'If you want to guarantee that physical page frames are allocated after a virtual
    allocation you can:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要保证在虚拟分配后分配物理页帧，可以：
- en: Do `malloc(3)` followed by `memset(3)` on all the bytes in all pages
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有页面的所有字节上执行`malloc(3)`，然后执行`memset(3)`
- en: Just use the `calloc(3)`; it will set the memory to zero, thus faulting it in
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只需使用`calloc(3)`；它会将内存设置为零，从而引发错误
- en: On many implementations, the second method – using `calloc(3)` – is faster than
    the first.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多实现中，第二种方法 - 使用`calloc(3)` - 比第一种方法更快。
- en: It's really because of demand-paging that we can write an application that malloc's
    huge amounts of memory and never free's it; it will work as long as the process
    does not attempt to read, write, or execute any byte in any (virtual) page of
    the allocated region. Apparently, there are many real-world applications that
    are quite poorly designed and do exactly this kind of thing – allocate huge amounts
    of memory via `malloc(3)` just in case we need it. Demand-paging is an OS hedge
    against wastefully eating up huge amounts of physical memory that hardly gets
    used in practice.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为需求分页，我们才能编写一个malloc大量内存并且从不释放它的应用程序；只要进程不尝试读取、写入或执行分配区域的任何（虚拟）页面的任何字节，它就可以正常工作。显然，有许多现实世界的应用程序设计得非常糟糕，确实做了这种事情
    - 通过`malloc(3)`分配大量内存，以防万一需要。需求分页是操作系统对浪费大量实际上很少使用的物理内存的一种保护。
- en: Of course, you, the astute reader, will realize that to every upside there's
    probably a downside. In this scenario, this could conceivably happen with several
    processes simultaneously performing large memory allocations. If all of them allocate
    large portions of virtual memory and then want to actually claim those pages physically
    at around the same time, this would put a tremendous amount of memory pressure
    on the OS! And guess what, the OS makes absolutely no guarantee that it will succeed
    in servicing everyone. In fact, in the worst case, the Linux OS will run short
    of physical RAM to the extent that it must invoke a bit of a controversial component –
    the **Out-of-Memory** (**OOM**) Killer – whose job is to identify the memory-hogging
    process and kill it and its descendants, thus reclaiming memory and keeping the
    system alive. Reminds you of the Mafia, huh.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，聪明的读者会意识到每个优势可能都有一个劣势。在这种情况下，可能会同时进行几个进程执行大内存分配。如果它们都分配了大量的虚拟内存，并且想要在大致相同的时间实际上占用这些页面，这将给操作系统带来巨大的内存压力！而且，操作系统绝对不保证它能成功为每个进程提供服务。事实上，在最坏的情况下，Linux操作系统将缺乏物理内存，以至于必须调用一个有争议的组件
    - **Out-of-Memory** (**OOM**) Killer - 其工作是识别占用内存的进程并将其及其后代杀死，从而回收内存并保持系统运行。这让你想起黑手党了，是吧。
- en: 'Again, the man page on `malloc(3)` clearly notes the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`malloc(3)`的man页面清楚地指出了以下内容：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If interested, dig deeper with the references in the *Further reading* section
    on the GitHub repository.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果感兴趣，可以在GitHub存储库的*进一步阅读*部分中查看参考资料。
- en: Resident or not?
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驻留还是不驻留？
- en: Now that we clearly understand that the pages allocated by *malloc* and friends
    are virtual and not guaranteed to be backed by physical frames (at least to start
    with), imagine we have a pointer to a (virtual) memory region and we know its
    length. We would now like to know whether the corresponding pages are in RAM,
    that is, whether they are resident or not.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们清楚地了解了由*malloc*和朋友分配的页面是虚拟的，不能保证由物理页框支持（至少起初是这样），想象一下我们有一个指向（虚拟）内存区域的指针，并且知道它的长度。我们现在想知道相应的页面是否在RAM中，也就是说，它们是*驻留*还是不驻留。
- en: 'It turns out there''s a system call available that gives precisely this information:
    `mincore(2)`.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，有一个系统调用可以提供精确的信息：`mincore(2)`。
- en: The `mincore(2)` system call is pronounced m-in-core, not min-core. Co*re *is
    an old word used to describe physical memory.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`mincore(2)`系统调用的发音是m-in-core，而不是min-core。*Core*是一个用来描述物理内存的古老词语。'
- en: 'Let''s take a look at the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码：
- en: '[PRE33]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Given the starting virtual address and length, `mincore(2)` populates the third
    parameter – a vector array. After the call successfully returns, for every byte
    of the vector array, if the LSB (Least Significant Bit) is set, it implies that
    the corresponding page *is* resident (in RAM), otherwise it's not (possibly not
    allocated or in swap).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 给定起始虚拟地址和长度，`mincore(2)`会填充第三个参数 - 一个向量数组。调用成功返回后，对于向量数组的每个字节，如果最低有效位（LSB）被设置，那么意味着相应的页面*是*驻留（在RAM中），否则不是（可能未分配或在交换中）。
- en: 'Usage details are available via the `mincore(2)` man page: [https://linux.die.net/man/2/mincore](https://linux.die.net/man/2/mincore).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mincore(2)` man页面可以获取使用详细信息：[https://linux.die.net/man/2/mincore](https://linux.die.net/man/2/mincore)。
- en: 'Of course, you should realize that the information returned on page residency
    is merely a snapshot at that point in time of the state of the memory pages: it
    could change under us, that is, it is (or could be) very transient in nature.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您应该意识到页面驻留返回的信息只是内存页面状态的一个快照：它可能在我们之下发生变化，也就是说，它（或可能）在性质上非常瞬态。
- en: Locking memory
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定内存
- en: 'We understand that on a virtual memory-based OS, such as Linux, a usermode
    page can be swapped at any point in time; the Linux kernel memory management code
    makes these decisions. To the regular application process, this should not matter:
    any time it attempts to access (read, write, or execute) the page content, the
    kernel will page it back into RAM, and allow it to use it as though nothing had
    occurred. This handling is generally called *servicing a page fault* (there is
    a lot more to it, but for the purpose of this discussion, this is sufficient),
    and is completely transparent to the usermode application process.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，在基于虚拟内存的操作系统（如Linux）上，用户模式页面可以在任何时候被交换；Linux内核内存管理代码做出这些决定。对于常规应用程序进程来说，这不应该有关系：每当它尝试访问（读取、写入或执行）页面内容时，内核将其分页回RAM，并允许其像没有发生任何事情一样使用。这种处理通常称为*服务页面错误*（还有很多其他内容，但就本讨论的目的而言，这就足够了），对用户模式应用程序进程完全透明。
- en: 'However, there are some situations where memory pages being paged – written
    from RAM to swap and vice-versa – is undesirable:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些情况下，内存页面被分页写入RAM到交换空间，反之亦然是不希望的：
- en: Realtime applications
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时应用程序
- en: Cryptography (security) applications
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密（安全）应用程序
- en: In real-time applications, the key factor (at least within its critical code
    paths) is determinism *–* the iron-clad guarantee that the work will take a certain
    worst-case amount of time, and no more, no matter the load on the system.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时应用程序中，关键因素（至少在其关键代码路径中）是确定性*——*铁一般的保证工作将花费一定的最坏情况时间，不会超过这个时间，无论系统的负载如何。
- en: Imagine that the real-time process is executing a critical code path and a data
    page has to be paged in from the swap partition at that moment – the latency (delay)
    introduced could ruin the application's characteristics, resulting in dismal failure
    (or worse). In these cases, we, the developers, need a way to guarantee that said
    pages of memory can guaranteed to be resident in RAM, thus avoiding any page faulting.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，实时进程正在执行关键代码路径，并且在那一刻必须从交换分区中分页数据页面——引入的延迟可能会破坏应用程序的特性，导致惨败（或更糟）。在这些情况下，我们，开发人员，需要一种方法来保证所述内存页面可以保证驻留在RAM中，从而避免任何页面错误。
- en: In some types of security applications, they would likely store some secrets
    in memory (a password, a key); if the memory pages containing these are written
    out to disk (swap), there is always the possibility that it remains on disk well
    after the application exits – resulting in what's called information leakage,
    which is a bug attackers are just waiting to pounce upon! Here, again, the need
    of the hour is to guarantee that those pages cannot be swapped out.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些类型的安全应用程序中，它们可能会在内存中存储一些机密信息（密码、密钥）；如果包含这些信息的内存页面被写入磁盘（交换空间），则始终存在它在应用程序退出后仍然留在磁盘上的可能性——这就是所谓的信息泄漏，这是攻击者等待发动攻击的一个漏洞！在这里，再次需要保证这些页面不能被交换出去。
- en: 'Enter the `mlock(2)` (and friends: *mlock2* and *mlockall*) system calls; the
    express purpose of these APIs is to lock memory pages within the calling process''s
    virtual address space. Let''s figure out how to use `mlock(2)`. Here is its signature:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`mlock(2)`（以及相关的：*mlock2*和*mlockall*）系统调用；这些API的明确目的是锁定调用进程虚拟地址空间中的内存页面。让我们来看看如何使用`mlock(2)`。这是它的签名：
- en: '`int mlock(const void *addr, size_t len);`'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`int mlock(const void *addr, size_t len);`'
- en: 'The first parameter, `addr`, is a pointer to the (virtual) memory region to
    lock; the second parameter, `len`, is the number of bytes to lock into RAM. As
    a trivial example, take look at the following code (here, to keep it easily readable,
    we don''t show error-checking code; in a real application, please do so!):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`addr`是指向要锁定的（虚拟）内存区域的指针；第二个参数`len`是要锁定到RAM中的字节数。举个简单的例子，看看下面的代码（这里为了保持易读性，我们不显示错误检查代码；在实际应用中，请务必这样做！）：
- en: '[PRE34]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Limits and privileges
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制和特权
- en: A privileged process, either by running as *root*, or, better yet, by having
    the `CAP_IPC_LOCK` capability bit set in order to lock memory (we shall describe
    process credentials and capabilities in detail in their own chapters - [Chapter
    7](7b84d41f-dfff-439b-a751-46880cfe4651.xhtml), *Process Credentials*, and [Chapter
    8](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml), *Process Capabilities*), can lock
    unlimited amounts of memory.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 特权进程，无论是通过以*root*身份运行，还是更好地通过设置`CAP_IPC_LOCK`能力位来锁定内存（我们将在它们自己的章节中详细描述进程凭据和能力——[第7章](7b84d41f-dfff-439b-a751-46880cfe4651.xhtml)，*进程凭据*，和[第8章](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml)，*进程能力*），可以锁定无限量的内存。
- en: 'From Linux 2.6.9 onward, for a non-privileged process, it is limited by the `RLIMIT_MEMLOCK` soft
    resource limit (which, typically, is not set very high). Here is an example on
    an x86_64 Fedora box (as well as Ubuntu):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 从Linux 2.6.9开始，对于非特权进程，它受`RLIMIT_MEMLOCK`软资源限制的限制（通常不设置得很高）。以下是在x86_64 Fedora盒子（以及Ubuntu）上的一个示例：
- en: '[PRE35]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It's just 64 KB (ditto on an embedded ARM Linux, by default).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是64 KB（在嵌入式ARM Linux上也是如此，默认情况下）。
- en: 'At the time of writing this book, on a recent *Fedora 28* distro running on
    x86_64, the resource limit for max locked memory seems to have been amped up to
    16 MB! The following *prlimit(1)* outputshows just this:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，最近在x86_64上运行的*Fedora 28*发行版上，最大锁定内存的资源限制似乎已经提升到16 MB！以下*prlimit(1)*输出显示了这一点：
- en: '`$ prlimit | grep MEMLOCK`'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ prlimit | grep MEMLOCK`'
- en: '`MEMLOCK     max locked-in-memory address space     16777216  16777216 bytes`'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`MEMLOCK     最大锁定内存地址空间     16777216  16777216字节`'
- en: '`$`'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: $
- en: 'Hang on a second, though; while using mlock(2), the POSIX standard requires
    that `addr` is aligned to a page boundary (that is, if you take the memory start
    address and divide it by the system page size, the remainder will be zero, that
    is, `(addr % pgsz) == 0`. You can use the `posix_memalign(3)` API to guarantee
    this; so, we can change our code slightly to accommodate this alignment requirement:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当使用mlock(2)时，POSIX标准要求`addr`对齐到页面边界（即，如果你将内存起始地址除以系统页面大小，余数将为零，即，`(addr %
    pgsz) == 0`）。你可以使用`posix_memalign(3)`API来保证这一点；因此，我们可以稍微改变我们的代码以适应这个对齐要求：
- en: 'Refer to the following (`ch4/mlock_try.c`):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下内容（`ch4/mlock_try.c`）：
- en: '[PRE36]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s give it a spin:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '[PRE37]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice, in the successful cases, the address returned by `posix_memalign(3)`*;*
    it's on a page boundary. We can quickly tell by looking at the last three digits (from
    the right) of the address – if they are all zeroes, it's cleanly divisible by
    page size and thus on a page boundary. This is because the page size is usually
    4,096 bytes, and 4096 decimal = 0x1000 hex!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在成功的情况下，`posix_memalign(3)`*返回的地址；*它在页面边界上。我们可以通过查看地址的最后三位数字（从右边开始）来快速判断*–*如果它们都是零，那么它可以被页面大小整除，因此在页面边界上。这是因为页面大小通常为4,096字节，而4096十进制=0x1000十六进制！
- en: We request 32 pages; the allocation is successful, but *mlock* fails because
    32 pages = 32*4K = 128 KB; the resource limit is just 64 KB for locked memory.
    However, when we *sudo* it (thus running with root access), it works.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们请求32页；分配成功，但*mlock*失败，因为32页=32*4K=128 KB；锁定内存的资源限制只有64 KB。然而，当我们使用*sudo*（因此以root访问运行）时，它可以工作。
- en: Locking all pages
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定所有页面
- en: '*mlock* basically allows us to tell the OS to lock a certain range of memory
    into RAM. In some real-world cases, though, we cannot predict exactly which pages
    of memory we will require resident in advance (a real-time application might require
    various, or all, memory pages to always be resident).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*mlock*基本上允许我们告诉操作系统将某个内存范围锁定到RAM中。然而，在一些实际情况下，我们无法准确预测我们将提前需要哪些内存页面（实时应用程序可能需要各种或所有内存页面始终驻留）。'
- en: 'To solve this tricky issue, another system call – *mlockall(2)* – exists; as
    you can guess, it allows you to lock all process memory pages:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个棘手的问题，还有另一个系统调用*mlockall(2)*存在；正如你所猜测的，它允许你锁定所有进程内存页面：
- en: '` int mlockall(int flags);`'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`int mlockall(int flags);`'
- en: If successful (remember, the same privilege restrictions apply to *mlockall*
    as to *mlock*), all the process's memory pages *–* such as text, data segments,
    library pages, stack, and shared memory segments – are guaranteed to remain resident
    in RAM until unlocked.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功（记住，*mlockall*和*mlock*都受到相同的特权限制），进程的所有内存页面*–*如文本、数据段、库页面、堆栈和共享内存段*–*都保证保持驻留在RAM中，直到解锁。
- en: 'The *flags* argument provides further control to the application developer;
    it can be bitwise OR of the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*flags*参数为应用程序开发人员提供了进一步的控制；它可以是以下内容的按位或：'
- en: '`MCL_CURRENT`'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MCL_CURRENT`'
- en: '`MCL_FUTURE`'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MCL_FUTURE`'
- en: '`MCL_ONFAULT (Linux 4.4 onward)`'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MCL_ONFAULT（Linux 4.4及以上版本）`'
- en: Using `MCL_CURRENT` asks the OS to lock all current pages within the calling
    process's VAS into memory.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`MCL_CURRENT`要求操作系统将调用进程VAS中的所有当前页面锁定到内存中。
- en: 'But what if you issue the *mlockall(2) *system call at initialization time,
    but the real-time process is going to perform an *malloc* of say, 200 kilobytes,
    5 minutes from now? We need to guarantee that those 200 KB of memory (which is
    50 pages, given a 4 KB page size) is always resident in RAM (otherwise, the real-time
    application will suffer too great a latency from possible future page faulting).
    That is the purpose of the `MCL_FUTURE` flag: it guarantees the memory pages that
    become part of the calling process''s VAS in the future will remain resident in
    memory until unlocked.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你在初始化时发出*mlockall(2)*系统调用，但是实时进程将在5分钟后执行一个200千字节的*malloc*呢？我们需要保证这200 KB的内存（即50页，假设页面大小为4
    KB）始终驻留在RAM中（否则，实时应用程序将因可能的未来页面故障而遭受太大的延迟）。这就是`MCL_FUTURE`标志的目的：它保证成为调用进程VAS的一部分的内存页面将始终保持驻留在内存中，直到解锁。
- en: We learned in the *Demand-paging* section that performing *malloc* does nothing
    more than reserve virtual memory, not physical. As an example, if an (non-real-time)
    application performs a rather large allocation of a megabyte (that's 512 pages),
    we understand that only 512 virtual pages are reserved and the physical page frames
    are not actually allocated – they will get faulted in on-demand. A typical realtime
    application will therefore need to somehow guarantee that, once faulted in, these
    512 pages will remain locked (resident) in RAM. Use the `MCL_ONFAULT` flag to
    achieve this.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*需求分页*部分学到，执行*malloc*只是保留虚拟内存，而不是物理内存。例如，如果一个（非实时）应用程序执行了一个相当大的分配，比如1兆字节（即512页），我们知道只有512个虚拟页面被保留，而物理页面框架实际上并没有被分配*–*它们将按需故障进入。因此，一个典型的实时应用程序需要以某种方式保证这512页一旦故障进入就会保持锁定（驻留）在RAM中。使用`MCL_ONFAULT`标志来实现这一点。
- en: This flag must be used in conjunction with either the `MCL_CURRENT` or  `MCL_FUTURE`
    flag, or both. The idea is that physical memory consumption remains extremely
    efficient (as no physical allocation is done at the time of *malloc*), and yet,
    once the application starts to touch the virtual pages (that is, read, write,
    or execute data or code within the page), the physical page frames get faulted
    in and they will then be locked. In other words, we do not pre-fault the memory,
    thus we get the best of both worlds.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标志必须与`MCL_CURRENT`或`MCL_FUTURE`标志，或两者一起使用。其思想是，物理内存消耗保持极其高效（因为在*malloc*时没有进行物理分配），但一旦应用程序开始访问虚拟页面（即读取、写入或执行页面内的数据或代码），物理页面框架就会被故障进入，然后被锁定。换句话说，我们不预先故障内存，因此我们可以兼得两全其美。
- en: The other side of the coin is that, when done, the application can unlock all
    memory pages by issuing the counterpart API: *munlockall(2)*.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 另一面是，完成后，应用程序可以通过发出对应的API：*munlockall(2)*来解锁所有内存页面。
- en: Memory protection
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存保护
- en: An application dynamically allocates, say, four pages of memory. By default,
    this memory is both readable and writable; we refer to these as the *memory protections*
    on the page.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序动态分配了四页内存。默认情况下，这块内存既可读又可写；我们称之为页面的*内存保护*。
- en: Wouldn't it be nice if the application developer could dynamically modify memory
    protections on a per-page basis? For example, keep the first page with default
    protections, make the second page *read-only*, the third page *read+execute*,
    and on the fourth page, not allow any kind of access (a guard page, perhaps?).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序开发人员能够动态修改每页的内存保护，那不是很好吗？例如，保持第一页的默认保护，将第二页设置为*只读*，将第三页设置为*读+执行*，并且在第四页上不允许任何访问（可能是一个守卫页？）。
- en: 'Well, this feature is precisely what the `mprotect(2)` system call is designed
    for. Let''s delve into how we can exploit it to do all that. Here is its signature:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性正是`mprotect(2)`系统调用的设计目的。让我们深入研究如何利用它来实现所有这些。这是它的签名：
- en: '[PRE38]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It''s really quite straightforward: starting at the (virtual) address, `addr,`
    for `len` bytes (that is, from `addr` up to `addr+len-1` ), apply the memory protections
    specified by the *prot* bitmask. As the granularity of *mprotect* is a page, the
    first parameter, *addr*, is expected to be page-aligned (on a page boundary; recall
    that this is exactly what `mlock[all](2)` expects too).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上非常简单：从（虚拟）地址`addr`开始，对`len`字节（即从`addr`到`addr+len-1`），应用*prot*位掩码指定的内存保护。由于*mprotect*的粒度是一页，因此预期第一个参数*addr*应该是页面对齐的（在页面边界上；回想一下，这正是`mlock[all](2)`所期望的）。
- en: 'The third parameter, `prot`, is where you specify the actual protections; it
    is a bitmask and can either be just the `PROT_NONE` bit or the bitwise OR of the
    remainder:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数`prot`是您指定实际保护的地方；它是一个位掩码，可以是`PROT_NONE`位，也可以是其余位的按位或：
- en: '| **Protection bit** | **Meaning of memory protection** |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| **保护位** | **内存保护的含义** |'
- en: '| `PROT_NONE` | No access allowed on the page |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `PROT_NONE` | 页面上不允许任何访问 |'
- en: '| `PROT_READ` | Reads allowed on the page |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `PROT_READ` | 页面上允许读取 |'
- en: '| `PROT_WRITE` | Writes allowed on the page |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `PROT_WRITE` | 页面上允许写入 |'
- en: '| `PROT_EXEC` | Execute access allowed on the page |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `PROT_EXEC` | 页面上允许执行访问 |'
- en: Within the man page on *mprotect(2),* there are several other rather arcane
    protection bits and useful information under the NOTES section. If required (or
    just curious), read about it here: [http://man7.org/linux/man-pages/man2/mprotect.2.html](http://man7.org/linux/man-pages/man2/mprotect.2.html)*.*
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在*mprotect(2)*的man页面中，*NOTES*部分有几个其他相当神秘的保护位和有用的信息。如果需要（或只是好奇），可以在这里阅读：[http://man7.org/linux/man-pages/man2/mprotect.2.html](http://man7.org/linux/man-pages/man2/mprotect.2.html)。
- en: Memory protection – a code example
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存保护 - 代码示例
- en: 'Let''s consider an example program where the process dynamically allocates
    four pages of memory and wants to set them up so that the memory protections for
    each page are as shown in the following table:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个示例程序，其中进程动态分配了四页内存，并希望设置它们的内存保护，如下表所示：
- en: '| **Page #** | **Page 0** | **Page 1** | **Page 2** | **Page 3** |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| **页码** | **页0** | **页1** | **页2** | **页3** |'
- en: '| Protection bits | `rw-` | `r--` | `rwx` | `---` |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 保护位 | `rw-` | `r--` | `rwx` | `---` |'
- en: 'Relevant portions of the code are shown as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的相关部分如下所示：
- en: 'First, the *main* function dynamically allocates page-aligned memory (four
    pages) with the `posix_memalign(3)` API, and then invokes the memory protection
    and the memory testing functions in turn:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，*main*函数使用`posix_memalign(3)`API动态分配页面对齐的内存（四页），然后依次调用内存保护和内存测试函数：
- en: '[PRE39]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here is the memory protection function:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这是内存保护函数：
- en: '[PRE40]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After setting up the memory protections, we have the `main()`function invoke
    the memory testing function, `test_mem`. The second parameter determines whether
    we will attempt to write on read-only memory (we require this test case for page
    1 as it''s read-only protected):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完内存保护后，`main()`函数调用内存测试函数`test_mem`。第二个参数确定我们是否尝试在只读内存上进行写入（我们需要这个测试用例来测试第1页，因为它是只读保护的）：
- en: '[PRE41]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Prior to attempting to test it, we check that the page has indeed been protected
    by the `mprotect`call (via our simple `okornot[]`array). Also, for readability,
    we build the simple `TEST_READ` and `TEST_WRITE` macros:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试测试之前，我们检查页面是否确实已经被`mprotect`调用（通过我们简单的`okornot[]`数组）。另外，为了便于阅读，我们构建了简单的`TEST_READ`和`TEST_WRITE`宏：
- en: '[PRE42]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If the process violates any of the memory protections, the OS will summarily
    kill it via the usual *segfault* mechanism (explained in detail within [Chapter
    12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml)*,* *Signaling Part II*).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进程违反了任何内存保护，操作系统将通过通常的*segfault*机制（在[第12章](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml)*，*第二部分信号*中有详细解释）立即终止它。
- en: Let's perform some test runs on the `memprot` program; first (for reasons that
    will become clear soon) we'll try it out on a generic Ubuntu Linux box, then on
    a Fedora system, and finally on an (emulated) ARM-32 platform!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`memprot`程序上进行一些测试运行；首先（出于很快就会变得清楚的原因），我们将在一个通用的Ubuntu Linux系统上尝试它，然后在一个Fedora系统上，最后在一个（模拟的）ARM-32平台上！
- en: 'Case #1.1: The `memprot`program on standard Ubuntu 18.04 LTS with parameter
    0(output reformatted for readability):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 案例#1.1：在标准Ubuntu 18.04 LTS上使用参数0运行`memprot`程序（输出重新格式化以便阅读）：
- en: '[PRE43]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Okay, so the parameter to `memprot` is `0` or `1`; `0` implies that we do not
    perform a write-to-read-only-memory test, whereas `1` implies we do. Here, we've
    run it with the `0` parameter.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，`memprot`的参数是`0`或`1`；`0`表示我们不执行写入只读内存的测试，而`1`表示我们执行。这里，我们使用了`0`参数来运行它。
- en: 'Some things to notice within the preceding output are as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中需要注意的一些事情如下：
- en: The `protect_mem()` function sets up memory protections on a per-page basis.
    We have allocated 4 pages, thus we loop 4 times, and on each loop iteration `i`,
    perform `mprotect(2)` on the i-th memory page.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protect_mem()`函数按页设置内存保护。我们已经分配了4页，因此我们循环4次，并在每次循环迭代`i`上执行`mprotect(2)`。'
- en: As you can clearly see in the code, it's been done in this fashion, on each
    loop iteration
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如您在代码中清楚地看到的那样，它是以这种方式完成的，每次循环迭代
- en: 'Page `0 : rw-`: Set page protections to `PROT_READ | PROT_WRITE`'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面`0：rw-`：将页面保护设置为`PROT_READ | PROT_WRITE`
- en: 'Page `1 : r--`: Set page protections to `PROT_READ`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面`1：r--`：将页面保护设置为`PROT_READ`
- en: 'Page `2 : rwx`: Set page protections to `PROT_READ| PROT_WRITE | PROT_EXEC`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面`2：rwx`：将页面保护设置为`PROT_READ| PROT_WRITE | PROT_EXEC`
- en: 'Page `3 : ---`: Set page protections to `PROT_NONE`, that is,  make the page
    inaccessible'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面`3：---`：将页面保护设置为`PROT_NONE`，即使页面无法访问
- en: 'In the preceding output, the output format displayed after *mprotect* is as
    follows:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上面的输出中，*mprotect*之后显示的输出格式如下：
- en: '`page <#>: protections: <PROT_xx|[...]> range [<start_addr>:<end_addr>]`'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`page <#>: protections: <PROT_xx|[...]> range [<start_addr>:<end_addr>]`'
- en: All goes well; the four pages get new protections as required.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一切顺利；四个页面都得到了所需的新保护。
- en: 'Next, the `test_mem()` function is invoked, which tests each page''s protections
    (the memory protection of the page is shown within square brackets in the usual
    [`rwx`] format):'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，调用`test_mem()`函数，该函数测试每个页面的保护（页面的内存保护以通常的[`rwx`]格式显示在方括号内）：
- en: 'On page 0 [default: `rw-`]: It writes and reads a random byte within the page'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面0 [默认：`rw-`]上：它在页面内写入和读取一个随机字节
- en: 'On page 1 [`r--`]: It reads a random byte within the page, and if the user
    passed the parameter as `1` (not the case here, but it will be in the following
    case), it attempts to write to a random byte within that page'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面1 [`r--`]上：它在页面内读取一个随机字节，如果用户将参数传递为`1`（这里不是这种情况，但在下一个案例中会是这种情况），它会尝试在该页面内写入一个随机字节
- en: 'On page 2 [`rwx`]: As expected, reading and writing a random byte here succeeds'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面2 [`rwx`]上：如预期的那样，读取和写入一个随机字节成功
- en: 'On page 3 [`---`]: It attempts to both read and write a random byte within
    the page.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在页面3 [`---`]上：它尝试在页面内部读取和写入一个随机字节。
- en: 'The very first access – a *read* – fails with a *segfault*; this is expected
    of course – the page has no permissions whatsoever (we reproduce the output for
    this case): `**page 3: reading: byte @ 0x55796ccd8567 is Segmentation fault**`'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '第一次访问-一个*读取*-失败了，出现了*段错误*；这当然是预期的-页面根本没有任何权限（我们为这种情况重现了输出）：`**page 3: reading:
    byte @ 0x55796ccd8567 is Segmentation fault**`'
- en: To summarize, with the parameter as `0`, test cases on pages 0, 1, and 2 succeed;
    as expected, any access on page 3 causes the OS to kill the process (via the segmentation-violation
    signal).
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总之，参数为`0`时，页面0、1和2的测试用例都成功了；如预期的那样，对页面3的任何访问都会导致操作系统终止进程（通过分段违规信号）。
- en: 'Case #1.2: The `memprot` program on standard Ubuntu 18.04 LTS with parameter
    1 (output reformatted for readability).'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 案例＃1.2：在标准Ubuntu 18.04 LTS上使用参数1运行`memprot`程序（输出重新格式化以便阅读）。
- en: 'Let''s now re-run the program with the parameter set to `1`, thus attempting
    to write to the *read-only* page `1`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将参数设置为`1`重新运行程序，因此尝试写入*只读*页面`1`：
- en: '[PRE44]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Indeed, as expected, it *segfaults* when it violates the read-only page permissions.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，当违反只读页面权限时，它会*段错误*。
- en: 'Case #2: The `memprot`program on a standard *Fedora 28* system.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 案例＃2：在标准* Fedora 28 *系统上的`memprot`程序。
- en: 'At the time of writing this book, the latest and greatest *Fedora* workstation
    distribution is ver 28:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，最新和最伟大的* Fedora *工作站发行版是版本28：
- en: '[PRE45]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We build and run our `memprot`program on this standard *Fedora 28* workstation
    system (passing `0` as the parameter – implying that we do not attempt writing
    to the read-only memory page):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在标准* Fedora 28 *工作站系统上构建和运行我们的`memprot`程序（将`0`作为参数传递-这意味着我们不尝试写入只读内存页）：
- en: '[PRE46]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'How do we interpret the preceding output? The following is the explanation
    for the same:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解释上面的输出？以下是相同的解释：
- en: 'All goes well for pages 0, 1, and 3: the *mprotect* API succeeds in setting
    the page''s protections exactly as shown'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面0、1和3都很好：*mprotect* API成功地设置了页面的保护，就像所示的那样
- en: However, we get a failure (and a *Warning* message) when we attempt the `mprotect(2)`
    system call on page 2 with the `PROT_READ | PROT_WRITE | PROT_EXEC` attributes.  *Why?*
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，当我们尝试在页面2上使用`PROT_READ | PROT_WRITE | PROT_EXEC`属性进行`mprotect(2)`系统调用时，我们会收到失败（和*警告*消息）。*为什么？*
- en: The usual OS security is the **Discretionary Access Control** (**DAC**) layer. Many
    modern Linux distros, including Fedora, come with a powerful security feature –
    an additional layer of security within the OS – the **Mandatory Access Control** (**MAC**) layer. These
    are implemented on Linux as **Linux Security Modules** (**LSMs**). Popular LSMs
    include the NSA's SELinux (Security-Enhanced Linux), AppArmor, Smack, TOMOYO,
    and Yama.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常的操作系统安全是**自主访问控制**（**DAC**）层。许多现代Linux发行版，包括Fedora，都配备了一个强大的安全功能-操作系统内部的额外安全层-**强制访问控制**（**MAC**）层。这些在Linux上实现为**Linux安全模块**（**LSM**）。流行的LSM包括NSA的SELinux（安全增强型Linux），AppArmor，Smack，TOMOYO和Yama。
- en: Fedora uses SELinux while Ubuntu variants tend to use AppArmor. Whichever the
    case, it is often these LSMs that can fail userland-issued system calls when they
    violate a security policy. This is precisely what happened with our mprotect(2)
    system call on the third page (when the page protections were attempted to be
    set to [`rwx`])!
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fedora使用SELinux，而Ubuntu变体倾向于使用AppArmor。无论哪种情况，通常这些LSM在违反安全策略时可能会失败用户空间发出的系统调用。这正是我们的mprotect(2)系统调用在第三页上发生的情况（当尝试将页面保护设置为[`rwx`]时）！
- en: 'As a quick proof-of-concept, and to just get it working for now, we temporarily
    **disable** *SELinux* and retry:'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个快速的概念验证，并且为了让它现在正常工作，我们暂时**禁用** *SELinux*并重试：
- en: '[PRE47]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '*SELinux* is now in permissive mode; retry the application:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '*SELinux*现在处于宽容模式；重试应用程序：'
- en: '[PRE48]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, it works as expected! Don''t forget to re-enable the LSM:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它按预期工作！不要忘记重新启用LSM：
- en: '[PRE49]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: An Aside – LSM logs, Ftrace
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一旁-LSM日志，Ftrace
- en: '(If you are not interested in this, feel free to skip over this section). The
    astute reader might wonder: how does one realize that it''s the OS security layer
    (the LSM) that ultimately caused the system call to fail? Broadly, there are two
    ways: check the given LSM logs, or use the kernel''s `Ftrace` functionality. The
    first way is simpler, but the second can give us insight at the level of the OS.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: （如果您对此不感兴趣，请随意跳过此部分）。敏锐的读者可能会想知道：如何意识到是操作系统安全层（LSM）最终导致了系统调用失败？大体上有两种方法：检查给定的LSM日志，或使用内核的`Ftrace`功能。第一种方法更简单，但第二种方法可以让我们在操作系统的层面上获得洞察。
- en: LSM logs
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LSM日志
- en: 'Modern Linux systems use the powerful systemd framework for process-initialization,
    logging, and more. The logging facility is called the journal and is accessed
    via the` journalctl(1)` utility. We use it to verify that it''s indeed the SELinux
    LSM that has caused the issue:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Linux系统使用强大的systemd框架进行进程初始化、日志记录等。日志记录设施称为journal，并通过`journalctl(1)`实用程序访问。我们使用它来验证确实是SELinux
    LSM导致了问题：
- en: '[PRE50]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: It even shows us exactly how we can allow the access.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 它甚至向我们显示了如何允许访问。
- en: Ftrace
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ftrace
- en: 'The Linux kernel has a very powerful built-in tracing mechanism (well, it''s
    one of them) – *Ftrace*. Using `ftrace`, you can verify that it''s indeed the
    *LSM* code that, while honoring its security policy, caused the userspace-issued
    system call to return failure. I ran a trace (with `ftrace`):'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核有一个非常强大的内置跟踪机制（它是其中之一）- *Ftrace*。使用`ftrace`，您可以验证确实是*LSM*代码，尽管遵守其安全策略，导致用户空间发出的系统调用返回失败。我运行了一个跟踪（使用`ftrace`）：
- en: '![](img/82dbe338-ea14-4d08-b883-845de7a88777.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82dbe338-ea14-4d08-b883-845de7a88777.png)'
- en: ftrace output snippet
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ftrace输出片段
- en: The `SyS_mprotect` function is what the *mprotect(2) *system call becomes withinthe
    kernel; `security_file_mprotect` is the LSM hook function that leads to the the
    actual SELinux function: `selinux_file_mprotect`; apparently, it fails the access.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`SyS_mprotect`函数是内核中的*mprotect(2)*系统调用；`security_file_mprotect`是导致实际的SELinux函数`selinux_file_mprotect`的LSM挂钩函数；显然，它拒绝了访问。'
- en: Interestingly, Ubuntu 18.04 LTS also uses an LSM – AppArmor. However, it seems
    that it has not been configured to catch this kind of *write+execute* (heap) page-protection
    case.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Ubuntu 18.04 LTS也使用了LSM-AppArmor。然而，似乎它没有配置来捕获这种*write+execute*（堆）页面保护情况。
- en: Of course, these topics (LSMs, ftrace) are beyond the scope of this book. To
    the curious reader (the kind we love), please see more on *LSMs* and *Ftrace*
    in the *Further reading *section on the GitHub repository.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些主题（LSMs，ftrace）超出了本书的范围。对于好奇的读者（我们喜欢的那种），请在GitHub存储库的*进一步阅读*部分查看更多关于*LSMs*和*Ftrace*的内容。
- en: An experiment – running the memprot program on an ARM-32
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个实验-在ARM-32上运行memprot程序
- en: 'As an interesting experiment, we will cross-compile our preceding *memprot*
    program for an **ARM system**. I have used a convenient way to do this without
    real hardware: using the powerful  **Free and Open Source Software **(**FOSS**)
    **Quick Emulator **(**QEMU**) project, to emulate an ARM Versatile Express Cortex-A9
    platform!'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个有趣的实验，我们将为**ARM系统**交叉编译我们之前的*memprot*程序。我使用了一种方便的方法来做到这一点，而不需要真正的硬件：使用强大的**自由开源软件**（**FOSS**）**Quick
    Emulator**（**QEMU**）项目，来模拟ARM Versatile Express Cortex-A9平台！
- en: 'Cross-compiling the code is indeed simple: notice that there is now a `CROSS_COMPILE`
    variable in our `Makefile`*;* it''s the cross-compiler prefix – the prefix string
    identifying the toolchain (common to all tools). It''s literally prefixed onto
    the `CC` (for `gcc`, or `CL`  for clang) variable, which is the compiler used
    to build the target. Unfortunately, going into more detail regarding cross-compiling
    and root-filesystem build is beyond the scope of this book; for some help, see
    the *Tip* that follows this example''s output. Also, to keep things simple, we
    will use a direct approach – a separate target for the ARM version within the
    `Makefile`. Let''s check out the relevant portion of the `Makefile`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉编译代码确实很简单：请注意，我们的`Makefile`中现在有一个`CROSS_COMPILE`变量；它是交叉编译器的前缀-用于标识工具链的前缀字符串（所有工具通用）。它实际上是添加到`CC`（对于`gcc`或`CL`对于clang）变量的前缀，这是用于构建目标的编译器。不幸的是，更详细地讨论交叉编译和根文件系统构建超出了本书的范围；有关帮助，请参阅本示例输出后面的*提示*。此外，为了保持简单，我们将使用直接的方法-在`Makefile`中为ARM版本设置一个单独的目标。让我们来看看`Makefile`的相关部分：
- en: '[PRE51]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'So, as shown here, we cross-compile the `memprot_arm` program:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如图所示，我们交叉编译`memprot_arm`程序：
- en: '[PRE52]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Aha, it''s generated an ARM executable! We copy this over to our embedded root
    filesystem, boot the (emulated) ARM board, and try it out:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈，它生成了一个ARM可执行文件！我们将其复制到我们的嵌入式根文件系统中，启动（模拟的）ARM板，并尝试运行它：
- en: '[PRE53]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We''re on the (emulated) ARM-32 system prompt; let''s try running our program:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在（模拟的）ARM-32系统提示符上；让我们尝试运行我们的程序：
- en: '[PRE54]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The reader will notice that, unlike on the *Fedora 28* distro on the x86_64
    system we ran this on earlier, the page 2 test case (highlighted in bold) where
    we attempt to set page 2's memory protections to [`rwx`] does succeed! Of course,
    there is no LSM installed.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 读者会注意到，与我们之前在x86_64系统上运行的*Fedora 28*发行版不同，我们尝试将第2页的内存保护设置为[`rwx`]的测试用例（用粗体标出）确实成功了！当然，没有安装LSM。
- en: If you would like to try similar experiments, running code on an emulated ARM-32,
    consider using the **Simple Embedded ARM Linux System** (**SEALS**) project, again
    pure open source, to easily build a very simple, yet working, ARM/Linux-embedded
    system: [https://github.com/kaiwan/seals](https://github.com/kaiwan/seals).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想尝试类似的实验，在模拟的ARM-32上运行代码，请考虑使用**Simple Embedded ARM Linux System**（**SEALS**）项目，再次纯开源，轻松构建一个非常简单但有效的ARM/Linux嵌入式系统：[https://github.com/kaiwan/seals](https://github.com/kaiwan/seals)。
- en: Similar memory-protection – setting protection attributes (rwx or none) on a
    range of memory – can be achieved with the powerful `mmap(2)` system call (We
    cover `mmap(2)` with respect to file I/O in [Chapter 18](cf0e96e2-0e5d-4fb2-abc2-742bc93b61d0.xhtml),
    *Advanced File I/O*).
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的内存保护-在一段内存上设置保护属性（rwx或无）-可以通过强大的`mmap(2)`系统调用实现（我们在[第18章](cf0e96e2-0e5d-4fb2-abc2-742bc93b61d0.xhtml)中涵盖了关于文件I/O的`mmap(2)`）。
- en: Memory protection keys – a brief note
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存保护密钥 - 简要说明
- en: 'Recent Intel 64-bit processors bring to the table a feature called **Memory
    Protection Keys** (**MPK**). Very briefly, MPK (or *pkeys*, as it''s called on
    Linux) allows userspace to set permissions with page granularity, too. So, if
    it does the same thing as *mprotect* or *mmap*, what benefit does it bring? See
    the following:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 最近的英特尔64位处理器引入了一个名为**内存保护密钥**（**MPK**）的功能。简而言之，MPK（或在Linux上称为*pkeys*）允许用户空间以页面粒度设置权限。因此，如果它和*mprotect*或*mmap*做同样的事情，它带来了什么好处？请看以下内容：
- en: It's a hardware feature, so setting a huge range of pages (say, gigabytes of
    memory) to some particular memory permissions will be much faster than `mprotect(2)` 
    can manage; this is important for some types of applications
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个硬件特性，因此将大量页面（比如说，几十亿字节的内存）设置为某些特定的内存权限将比`mprotect(2)`快得多；这对某些类型的应用程序很重要
- en: Applications (in-memory databases, perhaps) could benefit by turning off writes
    on memory regions until absolutely required, reducing spurious write bugs
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序（例如内存数据库）可以通过在绝对需要之前关闭内存区域的写入来受益，减少了错误写入。
- en: How do you exploit MPK? First, be aware that it is currently only implemented
    on recent Linux kernels and on the x86_64 processor architecture. To make use
    of it, read up on the man page (section 7) on *pkeys; *it has explanatory notes
    as well as sample code: [http://man7.org/linux/man-pages/man7/pkeys.7.html](http://man7.org/linux/man-pages/man7/pkeys.7.html).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如何利用MPK？首先要知道的是，它目前只在最近的Linux内核和x86_64处理器架构上实现。要使用它，阅读关于*pkeys*的man页面（第7节）；它有解释说明以及示例代码：[http://man7.org/linux/man-pages/man7/pkeys.7.html](http://man7.org/linux/man-pages/man7/pkeys.7.html)。
- en: Using alloca to allocate automatic memory
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用alloca来分配自动内存
- en: The glibc library provides an alternate to dynamic memory-allocation with malloc
    (and friends); the `alloca(3)` API.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: glibc库提供了一个动态内存分配的替代方案，使用malloc（和其他函数）；`alloca(3)` API。
- en: 'alloca can be thought of as something of a convenience routine: **it allocates
    memory on the stack** (of the function it is called within). The showcase feature
    is that free is not required and, the memory is automatically deallocated once
    the function returns. In fact, `free(3)` must not be called. This makes sense:
    memory allocated on the stack is called automatic memory – it will be freed upon
    that function''s return.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: alloca可以被认为是一种便利程序：**它在堆栈上分配内存**（在调用它的函数内）。展示特点是不需要`free`，并且一旦函数返回，内存就会自动释放。实际上，不能调用`free(3)`。这是有道理的：在堆栈上分配的内存称为自动内存
    - 在函数返回时将被释放。
- en: 'As usual, there are upsides and downsides – tradeoffs – to using  `alloca(3)`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，使用`alloca(3)`有好处和坏处 - 折衷：
- en: 'Here are the `alloca(3)` pros:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`alloca(3)`的优点：
- en: No free is required; this can make programming, readability, and maintainability
    much simpler. Thus we can avoid the dangerous memory-leakage bug – a significant
    gain!
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要释放；这可以使编程、可读性和可维护性更简单。因此，我们可以避免危险的内存泄漏bug - 这是一个重大的收获！
- en: It is considered very fast, with zero internal fragmentation (wastage).
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被认为非常快，内部碎片为零。
- en: 'The primary reason to use it: sometimes, programmers use non-local exits, typically
    via the `longjmp(3)` and `siglongjmp(3)` APIs. If the programmer uses `malloc(3)`
    to allocate a memory region and then abruptly leaves the function via a non-local
    exit, a memory leak will occur. Using *alloca* will prevent this, and the code
    is easy to implement and understand.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用它的主要原因：有时，程序员使用非局部退出，通常通过`longjmp(3)`和`siglongjmp(3)`的API。如果程序员使用`malloc(3)`来分配内存区域，然后突然通过非局部退出离开函数，将会发生内存泄漏。使用*alloca*将防止这种情况发生，并且代码易于实现和理解。
- en: 'And here are the alloca cons:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是alloca的缺点：
- en: The primary downside of alloca is that there is no guarantee it returns failure
    when passed a value large enough to cause stack overflow; thus, if this actually
    does occur at runtime, the process is now in an **undefined behavior** (**UB**)
    state and will (eventually) crash. In other words, checking alloca for the NULL
    return, as you do with the `malloc(3)` family, is of no use!
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: alloca的主要缺点是，当传递一个足够大的值导致堆栈溢出时，不能保证它返回失败；因此，如果在运行时实际发生了这种情况，进程现在处于**未定义行为**（**UB**）状态，并且（最终）会崩溃。换句话说，检查`alloca`是否返回NULL，就像你在`malloc(3)`系列中所做的那样，是没有用的！
- en: Portability is not a given.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可移植性并非一定存在。
- en: Often, alloca is implemented as an inline function; this prevents it from being
    overridden via a third-party library.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，alloca被实现为内联函数；这可以防止它被第三方库覆盖。
- en: 'Take a look at the code as follows (`ch4/alloca_try.c`):'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码（`ch4/alloca_try.c`）：
- en: '[PRE55]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s build it and try it out:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建它并试一试：
- en: '[PRE56]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first parameter to `alloca_try` is the amount of memory to allocate (in
    bytes), while the second parameter, if `1`, has the `memset` process call on that
    memory region; if `0`, it does not.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`alloca_try`的第一个参数是要分配的内存量（以字节为单位），而第二个参数，如果为`1`，则在该内存区域上调用`memset`；如果为`0`，则不调用。'
- en: In the preceding code snippet, we tried it with an allocation request of 50,000
    bytes – it succeeded for both the `memset` cases.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们尝试了一个50,000字节的分配请求 - 对于`memset`的两种情况都成功了。
- en: 'Now, we deliberately pass `-1` as the first parameter, which will be treated
    as an unsigned quantity (thus becoming the enormous value of `0xffffffffffffffff` on
    a 64-bit OS!), which of course should cause `alloca(3)` to fail. Amazingly, it
    does not report failure; at least it thinks it''s okay:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们故意将`-1`作为第一个参数传递，这将被视为一个无符号数量（因此在64位操作系统上变为巨大的值`0xffffffffffffffff`！），这当然应该导致`alloca(3)`失败。令人惊讶的是，它并没有报告失败；至少它认为一切都很好：
- en: '[PRE57]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: But then, doing `memset`(by passing the second parameter as `1`) causes the
    bug to surface; without it, we'd never know.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，通过进行`memset`（将第二个参数传递为`1`）会导致错误出现；没有它，我们将永远不会知道。
- en: 'To further verify this, try running the program under the control of the library
    call tracer software, `ltrace`; we pass `1` as the first parameter, forcing the
    process to invoke `memset` after `alloca(3)`:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步验证这一点，尝试在库调用跟踪软件`ltrace`的控制下运行程序；我们将`1`作为第一个参数传递，强制进程在`alloca(3)`之后调用`memset`：
- en: '[PRE58]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Aha! We can see that following memset, the process receives the fatal signal
    and dies. But why doesn't the `alloca(3)` API show up in `ltrace`? Because it's
    an inlined function – ahem, one of its downsides.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 啊哈！我们可以看到，在memset之后，进程接收到致命信号并死亡。但为什么`alloca(3)` API没有出现在`ltrace`中呢？因为它是一个内联函数-咳咳，它的缺点之一。
- en: 'But watch this; here, we pass `0` as the first parameter, bypassing the call
    to memset after `alloca(3)`:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请看；在这里，我们将`0`作为第一个参数传递，绕过了`alloca(3)`之后对memset的调用：
- en: '[PRE59]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It exits normally, as though there were no bug!
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 它正常退出，就好像没有错误一样！
- en: 'Further, you will recall  from [Chapter 3](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml), *Resource
    Limits*, we saw that the default stack size for a process is 8 MB. We can test
    this fact via our `alloca_try` program:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你会回忆起[第3章](4161d1ed-20ea-4fa5-8947-646055d956cb.xhtml)中所述，进程的默认堆栈大小为8 MB。我们可以通过我们的`alloca_try`程序来测试这个事实：
- en: '[PRE60]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The moment we go beyond 8 MB, `alloca(3)` allocates too much space, but does
    not trigger a crash; instead, `memset(3)` causes segfault to occur. Also, ulimit
    verifies that the stack resource limit is 8,192 KB, that is, 8 MB.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦超过8 MB，`alloca(3)`分配了太多的空间，但并不会触发崩溃；相反，`memset(3)`导致段错误发生。此外，ulimit验证了堆栈资源限制为8,192
    KB，即8 MB。
- en: 'To conclude, a really, really key point: you can often end up writing software
    that seems to be correct but is, in fact, not. The only way to gain confidence
    with the software is to take the trouble to perform 100% code coverage and run
    test cases against them! It''s hard to do, but quality matters. Just do it.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，一个非常非常关键的观点：你经常会发现自己编写的软件看起来是正确的，但实际上并不是。唯一获得软件信心的方法是费力地进行100%的代码覆盖，并对其运行测试用例！这很难做到，但质量很重要。只管去做吧。
- en: Summary
  id: totrans-430
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter focused upon both the simple and more advanced aspects of dynamic
    memory management for C application developers on the Linux OS. In the initial
    section, the basic glibc dynamic memory-management APIs and their correct usage
    in code was dealt with.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了Linux操作系统上C应用程序开发人员动态内存管理的简单和更高级的方面。在初始部分，讨论了基本的glibc动态内存管理API及其在代码中的正确使用。
- en: We then moved on to more advanced topics such as the program break (and the
    `sbrk(3)` API), how `malloc(3)` behaves internally when allocating memory of differing
    sizes, and the key concept of demand-paging. Then, we delved into the APIs that
    perform memory locking and memory region protection, and reasons to use them.
    Finally, we looked at `alloca(3)`, the alternate API. Several code examples were
    used to solidify the concepts that were learned. The next chapter will cover a
    really important topic—the variety of memory issues (defects) that can arise on
    Linux due to poor programming practices with the memory APIs
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向更高级的主题，如程序断点（和`sbrk(3)`API）、`malloc(3)`在分配不同大小的内存时的内部行为，以及需求分页的关键概念。然后，我们深入研究了执行内存锁定和内存区域保护的API以及使用它们的原因。最后，我们看了`alloca(3)`，这个替代API。使用了几个代码示例来巩固所学的概念。下一章将涵盖一个非常重要的主题-由于内存API的不良编程实践而在Linux上可能出现的各种内存问题（缺陷）。
