- en: Chapter 1. What and Why of Scripting with Bash
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。使用Bash脚本的“什么”和“为什么”
- en: 'Welcome to the what and why of bash scripting. My name is Andrew Mallett and
    I am a bash scripting junkie or perhaps more accurately: a scripting junkie. As
    an administrator, I fail to see the need to do repetitive tasks manually. We get
    time for more interesting things when we choose scripts to carry out the laborious
    tasks that we don''t like. In this chapter, we will introduce you to the what
    and why of bash scripting. If you are new, it will help you become familiar with
    scripts and also provide some great insights for those with more experience and
    who want to improve their skills. As we make our way through the chapter, each
    element is designed to be added to your knowledge to help you achieve your goals.
    While doing so, we will be covering the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到bash脚本的“什么”和“为什么”。我的名字是Andrew Mallett，我是一个bash脚本迷，或者更准确地说是一个脚本迷。作为管理员，我看不出手动执行重复任务的必要性。当我们选择脚本来执行我们不喜欢的繁琐任务时，我们就有更多时间做更有趣的事情。在本章中，我们将向您介绍bash脚本的“什么”和“为什么”。如果您是新手，它将帮助您熟悉脚本，并为那些有更多经验并希望提高技能的人提供一些很好的见解。在本章中，每个元素都旨在增加您的知识，以帮助您实现您的目标。在这个过程中，我们将涵盖以下主题：
- en: Bash vulnerabilities
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash漏洞
- en: The bash command hierarchy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bash命令层次结构
- en: Preparing text editors for scripting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为脚本准备文本编辑器
- en: Creating and executing scripts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和执行脚本
- en: Debugging your scripts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试您的脚本
- en: Bash vulnerabilities
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bash漏洞
- en: For this book, I will be working entirely on a Raspberry Pi 2 running Raspbian,
    a Linux distribution similar to Debian, and Ubuntu; although for you, the operating
    system you choose to work with is immaterial, in reality, as is the version of
    bash. The bash version I am using is 4.2.37(1). If you are using the OS X operating
    system, the default command line environment is **bash**.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书，我将完全在运行Raspbian的Raspberry Pi 2上工作，Raspbian是类似于Debian和Ubuntu的Linux发行版；尽管对您来说，您选择使用的操作系统和bash的版本都是无关紧要的，实际上，我使用的bash版本是4.2.37(1)。如果您使用的是OS
    X操作系统，默认的命令行环境是**bash**。
- en: 'To return the operating system being used, type the following command if it
    is installed:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回正在使用的操作系统，请输入以下命令（如果已安装）：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output from my system is shown in the following screenshot:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我的系统的输出如下截图所示：
- en: '![Bash vulnerabilities](img/00002.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![Bash漏洞](img/00002.jpeg)'
- en: 'The easiest way to determine the version of bash that you are using is to print
    the value of a variable. The following command will display your bash version:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 确定您正在使用的bash版本的最简单方法是打印一个变量的值。以下命令将显示您的bash版本：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following screenshot displays the output from my system:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我的系统的输出：
- en: '![Bash vulnerabilities](img/00003.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Bash漏洞](img/00003.jpeg)'
- en: In 2014, there was a well-publicized bug within bash that had been there for
    many years—the shell-shock bug. If your system is kept up-to-date, then it is
    not likely to be an issue but it is worth checking. The bug allows malicious code
    to be executed from within a malformed function. As a standard user, you can run
    the following code to test for the vulnerabilities on your system. This code comes
    from Red Hat and is not malicious but if you are unsure then please seek advice.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年，bash中出现了一个广为人知的bug，这个bug已经存在多年了——shell-shock bug。如果您的系统保持最新状态，那么这可能不是一个问题，但值得检查。该bug允许恶意代码从格式不正确的函数中执行。作为标准用户，您可以运行以下代码来测试系统上的漏洞。这段代码来自Red
    Hat，不是恶意的，但如果您不确定，请寻求建议。
- en: 'The following is the code from Red Hat to test for the vulnerability:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自Red Hat的用于测试漏洞的代码：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If your system is free from this first vulnerability the output should be as
    shown in the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统没有这个第一个漏洞，输出应该如下截图所示：
- en: '![Bash vulnerabilities](img/00004.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Bash漏洞](img/00004.jpeg)'
- en: 'To test for the last vulnerability from this bug, we can use the following
    test, which is again from Red Hat:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个bug的最后一个漏洞，我们可以使用以下测试，同样来自Red Hat：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output from a patched version of bash should look like the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 修补版本的bash的输出应该如下截图所示：
- en: '![Bash vulnerabilities](img/00005.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![Bash漏洞](img/00005.jpeg)'
- en: If the output from either of these command lines is different, then your system
    may be vulnerable to shell-shock and I would update bash or at least take further
    advice from a security professional.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个命令行的输出不同，那么您的系统可能容易受到shell-shock的影响，我建议更新bash，或者至少向安全专业人员寻求进一步建议。
- en: The bash command hierarchy
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: bash命令层次结构
- en: When working on at the bash shell and when you are sitting comfortably at your
    prompt eagerly waiting to type a command, you will most likely feel that it is
    a simple matter of typing and hitting the *Enter* key. You should know better
    than to think that things are never quite as simple as we imagine.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当在bash shell上工作时，当您舒适地坐在提示符前急切地等待输入命令时，您很可能会认为只需输入并按下*Enter*键就是一件简单的事情。您应该知道，事情从来不会像我们想象的那么简单。
- en: Command type
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令类型
- en: 'For example, if we type and enter `ls` to list files, it will be reasonable
    to think that we were running the command. It is possible, but we will be running
    an alias often. Aliases exist in memory as a shortcut to commands or commands
    with options; these aliases are used before we even check for the file. The bash
    shell built-in command `type` can come to our aid here. The `type` command will
    display the type of command for a given word entered at the command line. The
    types of command is listed as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们输入`ls`来列出文件，我们可能会认为我们正在运行该命令。这是可能的，但我们经常运行别名。别名存在于内存中，作为命令或带有选项的快捷方式；在检查文件之前，我们使用这些别名。bash
    shell内置命令`type`可以在这里帮助我们。`type`命令将显示在命令行输入的给定单词的命令类型。命令类型如下所示：
- en: Alias
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 别名
- en: Function
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能
- en: Shell built in
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell内置
- en: Keyword
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键词
- en: File
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件
- en: This list is also a representative of the order in which they are searched.
    As we can see, it is not until the very end where we search for the executable
    file `ls`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表也代表了它们被搜索的顺序。正如我们所看到的，直到最后才搜索可执行文件`ls`。
- en: 'The following command demonstrates the simple use type:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令演示了简单使用`type`：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can extend this further to display all the matches for the given command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步扩展这一点，以显示给定命令的所有匹配项：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we need to just type in the output, we can use the `-t` option. This is
    useful when we need to test the command type from within a script and only need
    the type to be returned. This excludes the superfluous information; thus, making
    it easier for us humans to read. Consider the following command and output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要输入输出，我们可以使用`-t`选项。当我们需要从脚本内部测试命令类型并且只需要返回类型时，这是有用的。这将排除多余的信息；因此，使我们人类更容易阅读。考虑以下命令和输出：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output is clear and simple and just what a computer or script requires.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清晰简单，正是计算机或脚本所需的。
- en: 'The built-in `type` can also be used to identify shell keywords such as if,
    case, function, and so on. The following command shows type being used against
    multiple arguments and types:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`type`也可以用于识别shell关键字，如if、case、function等。以下命令显示了`type`被用于多个参数和类型：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of the command is shown in the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出显示在以下屏幕截图中：
- en: '![Command type](img/00006.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![Command type](img/00006.jpeg)'
- en: You can also see that the function definition is printed when we stumble across
    a function when using `type`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`type`时，我们还会看到函数定义被打印出来。
- en: Command PATH
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令PATH
- en: 'Linux will check for executables in the `PATH` environment only when the full
    or relative path to the program is supplied. In general, the current directory
    is not searched unless it is in the `PATH`. It is possible to include our current
    directory within the `PATH` by adding the directory to the `PATH` variable. This
    is shown in the following code example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当提供程序的完整路径或相对路径时，Linux才会在`PATH`环境中检查可执行文件。一般来说，除非它在`PATH`中，否则不会搜索当前目录。通过将目录添加到`PATH`变量中，我们可以将当前目录包含在`PATH`中。这在以下代码示例中显示：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This appends the current directory to the value of the `PATH` variable each
    item the `PATH` is separated using the colon. Now, your `PATH` is updated to include
    the current working directory and each time you change directories, the scripts
    can be executed easily. In general, organizing scripts into a structured directory
    hierarchy is probably a great idea. Consider creating a subdirectory called `bin`
    within your home directory and add the scripts into that folder. Adding `$HOME/bin`
    to your `PATH` variable will enable you to find the scripts by name and without
    the file path.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将当前目录附加到`PATH`变量的值中，每个`PATH`项都使用冒号分隔。现在，您的`PATH`已更新以包括当前工作目录，并且每次更改目录时，脚本都可以轻松执行。一般来说，将脚本组织到结构化的目录层次结构中可能是一个好主意。考虑在您的主目录中创建一个名为`bin`的子目录，并将脚本添加到该文件夹中。将`$HOME/bin`添加到您的`PATH`变量将使您能够通过名称找到脚本，而无需文件路径。
- en: 'The following command-line list will only create the directory, if it does
    not already exist:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令行列表只会在目录不存在时创建该目录：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although the above command-line list is not strictly necessary, it does show
    that scripting in bash is not limited to the actual script and we can use conditional
    statements and other syntax directly at the command line. From our viewpoint,
    we know that the preceding command will work whether you have the `bin` directory
    or not. The use of the `$HOME` variable ensures that the command will work without
    considering your current file system context.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上述命令行列表并不是严格必要的，但它确实显示了在bash中进行脚本编写不仅限于实际脚本，我们还可以直接在命令行中使用条件语句和其他语法。从我们的角度来看，我们知道前面的命令将在您是否有`bin`目录的情况下工作。使用`$HOME`变量确保命令将在不考虑当前文件系统上下文的情况下工作。
- en: As we work through the book, we will add scripts into the `$HOME/bin` directory
    so that they can be executed regardless of our working directory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将把脚本添加到`$HOME/bin`目录中，以便无论我们的工作目录如何，都可以执行它们。
- en: Preparing text editors for scripting
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为脚本准备文本编辑器
- en: Throughout the book, I will be working on the command line of Raspberry Pi and
    this will include the creation and editing of the scripts. You, of course, can
    choose the way you wish to edit your script and may prefer to make use of a graphical
    editor and I will show some settings in gedit. I will make one excursion to a
    Red Hat system to show screenshots of gedit in this chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我将在树莓派的命令行上工作，这将包括创建和编辑脚本。当然，您可以选择您希望编辑脚本的方式，并且可能更喜欢使用图形编辑器，我将在gedit中展示一些设置。我将进行一次到Red
    Hat系统的旅行，以展示本章中gedit的屏幕截图。
- en: To help make the command line editor easier to use, we can enable options and
    we can persist with these options through hidden configuration files. The gedit
    and other GUI editors and their menus will provide similar functionality.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助使命令行编辑器更易于使用，我们可以启用选项，并且可以通过隐藏的配置文件持久化这些选项。gedit和其他GUI编辑器及其菜单将提供类似的功能。
- en: Configuring vim
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置vim
- en: Editing the command line is often a must and is a part of my everyday life.
    Setting up common options that make life easier in the editor give us the reliability
    and consistency you need, a little like scripting itself. We will set some useful
    options in the vi or vim editor file, `$HOME/.vimrc`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑命令行通常是必须的，也是我日常生活的一部分。在编辑器中设置使生活更轻松的常见选项，给我们提供了所需的可靠性和一致性，有点像脚本本身。我们将在vi或vim编辑器文件`$HOME/.vimrc`中设置一些有用的选项。
- en: 'The options we set are detailed in the following list:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置的选项在以下列表中详细说明：
- en: '**showmode**: Ensures we see when we are in insert mode'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**showmode**：确保我们在插入模式下看到'
- en: '**nohlsearch**: Does not highlight the words that we have searched for'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nohlsearch**：不会突出显示我们搜索的单词'
- en: '**autoindent**: We indent our code often; this allows us to return to the last
    indent level rather than the start of a new line on each carriage return'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**autoindent**：我们经常缩进我们的代码；这使我们可以返回到最后的缩进级别，而不是在每次换行时返回到新行的开头'
- en: '**tabstop=4**: Sets a tab to be four spaces'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tabstop=4**：将制表符设置为四个空格'
- en: '**expandtab**: Converts tabs to spaces, which is useful when the file moves
    to other systems'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**expandtab**：将制表符转换为空格，在文件移动到其他系统时非常有用'
- en: '**syntax on**: Note that this does not use the set command and is used to turn
    on syntax highlighting'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**syntax on**：请注意，这不使用set命令，而是用于打开语法高亮'
- en: 'When these options are set, the `$HOME/.vimrc` file should look similar to
    this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些选项设置时，`$HOME/.vimrc`文件应该看起来类似于这样：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Configuring nano
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置nano
- en: 'The nano text edit is increasing in importance and it is the default editor
    in many systems. Personally, I don''t like the navigation or the lack of navigation
    features that it has. It can be customized in the same way as vim. This time we
    will edit the `$HOME/.nanorc` file. Your edited file should look something like
    the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: nano文本编辑器的重要性正在增加，并且它是许多系统中的默认编辑器。就我个人而言，我不喜欢它的导航或缺乏导航功能。它可以像vim一样进行自定义。这次我们将编辑`$HOME/.nanorc`文件。您编辑后的文件应该看起来像下面的样子：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The last line enables syntax highlighting for shell scripts.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行启用了shell脚本的语法高亮。
- en: Configuring gedit
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置gedit
- en: Graphical editors, such as gedit, can be configured using the preferences menu
    and are pretty straight forward.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图形编辑器，如gedit，可以使用首选项菜单进行配置，非常简单直接。
- en: 'Enabling tab spacing to be set to **4** spaces and expanding tabs to spaces
    can be done using the **Preference** | **Editor** tab, as shown in the following
    screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 启用制表符间距设置为**4**个空格，并将制表符扩展为空格，可以使用**首选项** | **编辑器**选项卡，如下截图所示：
- en: '![Configuring gedit](img/00007.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![配置gedit](img/00007.jpeg)'
- en: Tip
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载示例代码文件，用于您购买的所有Packt
    Publishing图书。如果您在其他地方购买了本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，文件将直接通过电子邮件发送给您。
- en: 'Another very useful feature is found on the **Preferences** | **Plugins** tab.
    Here, we can enable the **Snippets** plugin that can be used to insert code samples.
    This is shown in the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的功能可以在**首选项** | **插件**选项卡中找到。在这里，我们可以启用**片段**插件，用于插入代码示例。如下截图所示：
- en: '![Configuring gedit](img/00008.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![配置gedit](img/00008.jpeg)'
- en: For the rest of the book, we will be working on the command line in and in vim;
    feel free to use the editor that you work with best. We have now laid the foundations
    to create good scripts and although whitespace, tabs, and spaces in bash scripts
    are not significant; a well laid out file with consistent spacing is easy to read.
    When we look at Python later in the book, you will realize that in some languages
    the whitespace is significant to the language and it is better to adopt the good
    habits early.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将在命令行和vim中工作；请随意使用您最擅长的编辑器。我们现在已经奠定了创建良好脚本的基础，尽管在bash脚本中，空白、制表符和空格并不重要；但是一个布局良好、间距一致的文件易于阅读。当我们在本书的后面看Python时，您将意识到在某些语言中，空白对语言是重要的，因此最好尽早养成良好的习惯。
- en: Creating and executing scripts
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和执行脚本
- en: With our editors primed and ready, we can now move quickly to creating and executing
    our scripts. If you are reading this book with some prior experience, I will warn
    you that we are going to start with the basics but we will also include looking
    at positional parameters; feel free to move on at your own pace.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们准备好的编辑器，我们现在可以快速地创建和执行我们的脚本。如果您在阅读本书时具有一些先前的经验，我会警告您，我们将从基础知识开始，但我们也将包括查看位置参数；请随时按照自己的步调前进。
- en: Hello World!
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你好，世界！
- en: 'As you know, it is almost obligatory to begin with a `hello world` script and
    we will not disappoint as far as this is concerned. We will begin by creating
    a new script `$HOME/bin/hello1.sh`. The contents of the file should read as in
    the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，几乎是必须以`hello world`脚本开始，就这一点而言，我们不会让你失望。我们将首先创建一个新的脚本`$HOME/bin/hello1.sh`。文件的内容应该如下截图所示：
- en: '![Hello World!](img/00009.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![Hello World!](img/00009.jpeg)'
- en: I am hoping that you haven't struggled with this too much; it is just three
    lines after all. I encourage you to run through the examples as you read to really
    help you instill the information with a good hands-on practice.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你没有太多困难；毕竟只有三行。我鼓励您在阅读时运行示例，以帮助您真正通过实践来巩固信息。
- en: '`#!/bin/bash`: Normally, this is always the first line of the script and is
    known as the shebang. The shebang starts with a comment but the system still uses
    this line. A comment in a shell script has the `#` symbol. The shebang instructs
    the system to the interpreter to execute the script. We use bash for shell scripts
    and we may use PHP or Perl for other scripts, as required. If we do not add this
    line, then the commands will be run within the current shell; it may cause issues
    if we run another shell.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#!/bin/bash`：通常，这总是脚本的第一行，并被称为shebang。shebang以注释开头，但系统仍然使用这一行。在shell脚本中，注释使用`#`符号。shebang指示系统执行脚本的解释器。我们在shell脚本中使用bash，根据需要，我们可能会使用PHP或Perl来执行其他脚本。如果我们不添加这一行，那么命令将在当前shell中运行；如果我们运行另一个shell，可能会出现问题。'
- en: '`echo "Hello World"`: The `echo` command will be picked up in a built-in shell
    and can be used to write a standard output, `STDOUT`, this defaults to the screen.
    The information to print is enclosed in double-quotes, there will be more on quotes
    later.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`echo "Hello World"`：`echo`命令将在内置shell中被捕获，并可用于编写标准输出`STDOUT`，默认为屏幕。要打印的信息用双引号括起来，稍后将会有更多关于引号的内容。'
- en: '`exit 0`: The `exit` command is a built in shell and is used to leave or exit
    the script. The `exit` code is supplied as an integer argument. A value of anything
    other than `0` will indicate some type of error in the script''s execution.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exit 0`：`exit`命令是一个内置的shell命令，用于离开或退出脚本。`exit`代码作为整数参数提供。除了`0`之外的任何值都将指示脚本执行中的某种错误。'
- en: Executing the script
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行脚本
- en: 'With the script saved in our `PATH` environment, it still will not execute
    as a standalone script. We will have to assign and execute permissions for the
    file, as needed. For a simple test, we can run the file directly with bash. The
    following command shows you how to do this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本保存在我们的`PATH`环境中，它仍然不能作为独立的脚本执行。我们需要根据需要为文件分配和执行权限。对于一个简单的测试，我们可以直接用bash运行文件。以下命令向您展示了如何做到这一点：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We should be rewarded with the `Hello World` text being displayed back on our
    screens. This is not a long-term solution, as we need to have the script in the
    `$HOME/bin` directory, specifically, to make the running of the script easy from
    any location without typing the full path. We need to add in the execute permissions
    as shown in the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该得到`Hello World`文本显示在我们的屏幕上。这不是一个长期的解决方案，因为我们需要将脚本放在`$HOME/bin`目录中，具体来说，以便在任何位置轻松运行脚本而不必输入完整路径。我们需要添加执行权限，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We should now be able to run the script simply, as shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够简单地运行脚本，如下面的截图所示：
- en: '![Executing the script](img/00010.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![执行脚本](img/00010.jpeg)'
- en: Checking the exit status
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查退出状态
- en: 'This script is simple but we still have to know how to make use of the exit
    codes from scripts and other applications. The command-line list that we generated
    earlier while creating the `$HOME/bin` directory, is a good example of how we
    can use the exit code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本很简单，但我们仍然需要知道如何使用脚本和其他应用程序的退出代码。我们在创建`$HOME/bin`目录时生成的命令行列表，就是如何使用退出代码的一个很好的例子：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding example, `command2` is executed only if `command1` fails in
    some way. To be specific, `command2` will run if `command1` exits with a status
    code other than `0`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，只有在`command1`以某种方式失败时才会执行`command2`。具体来说，只有当`command1`以除`0`以外的状态代码退出时，`command2`才会运行。
- en: 'Similarly, in the following extract:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在以下摘录中：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will only execute `command2` if `command1` succeeds and issues an exit code
    of `0`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在`command1`成功并发出`0`的退出代码时，我们才会执行`command2`。
- en: 'To read the exit code from our script explicitly, we can view the `$?`variable,
    as shown in the following example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要明确从我们的脚本中读取退出代码，我们可以查看`$?`变量，如下面的例子所示：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The expected output is `0`, as this is what we have added to the last line of
    the file and there is precious little else that can go wrong causing us to fail
    in reaching that line.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出是`0`，因为这是我们添加到文件最后一行的内容，几乎没有其他任何可能出错导致我们无法达到那一行。
- en: Ensuring a unique name
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保唯一的名称
- en: We can now create and execute a simple script but we need to consider the name
    a little. In this case, `hello1.sh` is going to be good enough and is unlikely
    to clash with anything else on the system. We should avoid using names that may
    clash with existing aliases, functions, keywords, and building commands, as well
    as, avoid names of programs already in use.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建和执行一个简单的脚本，但是我们需要考虑一下名字。在这种情况下，`hello1.sh`就足够好，不太可能与系统上的其他任何东西冲突。我们应该避免使用可能与现有别名、函数、关键字和构建命令冲突的名称，以及避免使用已经在使用中的程序的名称。
- en: Adding the `sh` suffix to the file does not guarantee the name to be unique
    but in Linux, where we do not file extensions, the suffix is a part of the file
    name. This helps you to provide a unique identity to your script. Additionally,
    the suffix is used by the editor to help you identify the file for syntax highlighting.
    If you recall, we specifically added the syntax highlighting file `sh.nanorc`
    to the nano text editor. Each of these files is specific to a suffix and subsequent
    language.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 向文件添加`sh`后缀并不能保证名称是唯一的，但在Linux中，我们不使用文件扩展名，后缀是文件名的一部分。这有助于为您的脚本提供一个唯一的标识。此外，后缀被编辑器用来帮助您识别文件以进行语法高亮。如果您还记得，我们特意向nano文本编辑器添加了语法高亮文件`sh.nanorc`。每个文件都是特定于后缀和后续语言的。
- en: 'Referring back to the command hierarchy within this chapter, we can use a type
    to determine the location and type of file `hello.sh` is:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾本章中的命令层次结构，我们可以使用类型来确定文件`hello.sh`的位置和类型：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'These commands and output can be seen in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令和输出可以在以下截图中看到：
- en: '![Ensuring a unique name](img/00011.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![确保唯一的名称](img/00011.jpeg)'
- en: Hello Dolly!
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你好，多莉！
- en: It is possible that we might need a little more substance in the script than
    a simple fixed message. Static message content does have its place but we can
    make this script much more useful by building some flexibility.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可能我们在脚本中需要更多的内容而不仅仅是一个简单的固定消息。静态消息内容确实有其存在的价值，但我们可以通过增加一些灵活性使这个脚本更加有用。
- en: In this chapter, we will look at positional parameters or arguments that we
    can supply to the script and in the next chapter we will see how we can make the
    script interactive and also prompt the user for input at runtime.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下我们可以向脚本提供的位置参数或参数，下一章我们将看到如何使脚本交互，并在运行时提示用户输入。
- en: Running the script with arguments
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带参数运行脚本
- en: 'We can run the script with arguments, after all it''s a free world and Linux
    promotes your freedom to do what you want to do with the code. However, if the
    script does not make use of the arguments, then they will be silently ignored.
    The following code shows the script running with a single argument:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以带参数运行脚本，毕竟这是一个自由的世界，Linux鼓励您自由地使用代码做您想做的事情。但是，如果脚本不使用这些参数，它们将被默默地忽略。以下代码显示了带有单个参数运行脚本：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The script will still run and will not produce an error. The output will not
    change either and will print hello world:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本仍然会运行，不会产生错误。输出也不会改变，仍然会打印hello world：
- en: '| Argument Identifier | Description |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 参数标识符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `$0` | The name of the script itself and is often used in usage statements.
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `$0` | 脚本本身的名称，通常在使用说明中使用。|'
- en: '| `$1` | Positional argument, the first argument passed to the script. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `$1` | 位置参数，传递给脚本的第一个参数。|'
- en: '| `${10}` | Where two or more digits are needed to represent the argument position.
    Brace brackets are used to delimit the variable name from any other content. Single
    value digits are expected. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `${10}` | 需要两个或更多位数来表示参数位置。大括号用于将变量名称与任何其他内容分隔开。预期是单个数字。|'
- en: '| `$#` | Argument count is especially useful when we need to set the amount
    of arguments needed for correct script execution. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `$#` | 当我们需要设置正确脚本执行所需的参数数量时，参数计数特别有用。|'
- en: '| `$*` | Refers to all arguments. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `$*` | 指代所有参数。|'
- en: 'For the script to make use of the argument, we can change the script content
    a little. Let''s first copy the script, add in the execute permissions, and then
    edit the new `hello2.sh`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使脚本使用参数，我们可以稍微更改脚本内容。让我们首先复制脚本，添加执行权限，然后编辑新的`hello2.sh`：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We need to edit the `hello2.sh` file to make use of the argument as it is passed
    at the command line. The following screenshot shows the simplest use of command
    line arguments allowing us now to have a custom message.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编辑`hello2.sh`文件，以便在命令行传递参数时使用参数。以下屏幕截图显示了允许我们现在拥有自定义消息的命令行参数的最简单用法。
- en: '![Running the script with arguments](img/00012.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![使用参数运行脚本](img/00012.jpeg)'
- en: 'Run the script now, we can provide an argument as shown in the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行脚本，我们可以按以下方式提供参数：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output should now say **Hello fred**. If we do not provide an argument
    then the variable will be empty and will just print **Hello**. You can refer to
    the following screenshot to see the execution argument and output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出应该是**Hello fred**。如果我们不提供参数，那么变量将为空，只会打印**Hello**。您可以参考以下屏幕截图查看执行参数和输出：
- en: '![Running the script with arguments](img/00013.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![使用参数运行脚本](img/00013.jpeg)'
- en: 'If we adjust the script to use `$*`, all the arguments will print. We will
    see **Hello** and then a list of all the supplied arguments. If we edit the script
    and replace the `echo` line as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调整脚本以使用`$*`，则会打印所有参数。我们将看到**Hello**，然后是所有提供的参数列表。如果我们编辑脚本并将`echo`行替换为以下内容：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Executing the script with the following arguments:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下参数执行脚本：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Will result in the output shown in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将导致以下屏幕截图中显示的输出：
- en: '![Running the script with arguments](img/00014.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![使用参数运行脚本](img/00014.jpeg)'
- en: If we want to print `Hello <name>`, each on separate lines, we will need to
    wait a little until we cover the looping structures. A for loop will work well
    to achieve this.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要打印`Hello <name>`，每个都在单独的行上，我们需要等一会儿，直到我们涵盖循环结构。for循环将很好地实现这一点。
- en: The importance of correct quotes
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确引用的重要性
- en: So far, we have used a simple double quoting mechanism to encase the strings
    that we want to use with echo.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了简单的双引号机制来包裹我们想要在echo中使用的字符串。
- en: In the first script, it does not matter if we use single or double quotes. The
    `echo "Hello World"` will be exactly the same as `echo 'Hello World'`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个脚本中，无论我们使用单引号还是双引号都无所谓。`echo "Hello World"`将与`echo 'Hello World'`完全相同。
- en: However, this will not be the case in the second script so it is very important
    to understand the quoting mechanisms available in bash.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在第二个脚本中情况就不同了，因此了解bash中可用的引用机制非常重要。
- en: As we have seen, using the double quotes `echo "Hello $1"` will result in **Hello
    fred** or whatever the supplied value is. Whereas, if we use single quotes `echo
    'Hello $1'` the printed output on the screen will be **Hello $1**, where we see
    the variable name and not its value.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，使用双引号`echo "Hello $1"`将导致**Hello fred**或提供的值。而如果我们使用单引号`echo 'Hello $1'`，则屏幕上打印的输出将是**Hello
    $1**，我们看到变量名称而不是其值。
- en: The idea of the quotes is to protect the special character such as a space between
    the two words; both quotes protect the space from being interpreted. The space
    is normally read as a default field, separated by the shell. In other words, all
    characters are read by the shell as literals with no special meaning. This has
    the knock on effect of the `$` symbol printing its literal format rather than
    allowing bash to expand its value. The bash shell is prevented from expanding
    the variable's value, as it is protected by the single quotes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 引号的作用是保护特殊字符，例如两个单词之间的空格；两个引号都保护空格不被解释。空格通常被shell读取为默认字段，由shell分隔。换句话说，所有字符都被shell读取为没有特殊含义的文字。这会导致`$`符号打印其文字格式，而不是允许bash扩展其值。由于被单引号保护，bash
    shell无法扩展变量的值。
- en: This is where the double quote comes to our rescue. The double quote will protect
    all the characters except the `$`, allowing bash to expand the stored value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是双引号拯救我们的地方。双引号将保护除`$`之外的所有字符，允许bash扩展存储的值。
- en: If we ever need to use a literal `$` within the quoted string along with variables
    that need to be expanded; we can use double quotes but escape the desired `$`
    with the backslash (`\`). For example, `echo "$USER earns \$4"` would print as
    **Fred earns $4** if the current user was Fred.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在带引号的字符串中使用文字`$`以及需要扩展的变量；我们可以使用双引号，但用反斜杠(`\`)转义所需的`$`。例如，`echo "$USER
    earns \$4"`将打印为**Fred earns $4**，如果当前用户是Fred的话。
- en: 'Try the following examples at the command line using all quoting mechanisms.
    Feel free to up your hourly rate as required:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在命令行中使用所有引用机制尝试以下示例。随时根据需要提高您的小时费率：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is shown in the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了输出：
- en: '![The importance of correct quotes](img/00015.jpeg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![正确引用的重要性](img/00015.jpeg)'
- en: Printing the script name
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印脚本名称
- en: The `$0` variable represents the script name and this is often used in usage
    statements. As we are not yet looking at conditional statements, we will have
    the script name printed above the displayed name.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`$0`变量代表脚本名称，通常在使用说明中使用。由于我们还没有看条件语句，所以脚本名称将打印在显示的名称上方。'
- en: 'Edit your script so that it reads as the following complete code block for
    `$HOME/bin/hello2.sh`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑你的脚本，使其读取 `$HOME/bin/hello2.sh` 的以下完整代码块：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output from the command is shown in the following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下截图所示：
- en: '![Printing the script name](img/00016.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![打印脚本名称](img/00016.jpeg)'
- en: 'If we prefer not to print the path and only want the name of the script to
    show we can use the `basename` command, which extracts the name from the path.
    Adjusting the script so that the second line now reads is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想打印路径，只想显示脚本的名称，我们可以使用 `basename` 命令，该命令从路径中提取名称。调整脚本，使第二行现在读取如下：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `$(….)` syntax is used to evaluate the output of the inner command. We first
    run `basename $0` and feed the result into an unnamed variable represented by
    the `$`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(….)` 语法用于评估内部命令的输出。我们首先运行 `basename $0` 并将结果输入到一个未命名的变量中，用 `$` 表示。'
- en: 'The new output will appear as seen in the following screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 新的输出将如下截图所示：
- en: '![Printing the script name](img/00017.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![打印脚本名称](img/00017.jpeg)'
- en: 'It is possible to achieve the same results using back quotes, this is less
    easy to read but we have mentioned this as you might have to understand and modify
    the scripts that have been written by others. The alternative to the `$(….)` syntax
    is shown in the following example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用反引号也可以实现相同的结果，这样不太容易阅读，但我们提到这一点是因为你可能需要理解和修改其他人编写的脚本。`$(….)` 语法的替代方法如下例所示：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Please note that the characters used are back quotes and *NOT* single quotes.
    On UK and US keyboards, these are found in the top-left section next to the number
    *1* key.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用的字符是反引号，*而不是*单引号。在英国和美国键盘上，这些字符位于数字 *1* 键旁边的左上部分。
- en: Debugging your scripts
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试你的脚本
- en: With the scripts as simple as we have seen so far, there is little that can
    go wrong or debug. As the script grows and decision paths are included with conditional
    statements, we may need to use some level of debugging to analyze the scripts
    progress better.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的脚本非常简单，几乎不会出错或需要调试。随着脚本的增长和包含条件语句的决策路径，我们可能需要使用一定级别的调试来更好地分析脚本的进展。
- en: Bash provides two options for us, `-v` and `-x`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 为我们提供了两个选项，`-v` 和 `-x`。
- en: 'If we want to look at the verbose output from our script and the detailed information
    about the way the script is evaluated line by line, we can use the `-v` option.
    This can be within the shebang but it is often easier to run the script directly
    with bash:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想查看脚本的详细输出以及脚本逐行评估的详细信息，我们可以使用 `-v` 选项。这可以在 shebang 中使用，但直接使用 bash 运行脚本通常更容易：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is especially useful in this example as we can see how each element of
    the embedded `basename` command is processed. The first step is removing the quotes
    and then the parentheses. Take a look at the following output:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，这是特别有用的，因为我们可以看到嵌入式 `basename` 命令的每个元素是如何处理的。第一步是删除引号，然后是括号。看一下以下输出：
- en: '![Debugging your scripts](img/00018.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![调试你的脚本](img/00018.jpeg)'
- en: 'More commonly used is the `-x` option, which displays the commands as they
    get executed. Its useful to know the decision branch that has been chosen by the
    script. The following shows this in use:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 更常用的是 `-x` 选项，它显示命令的执行过程。了解脚本选择的决策分支是很有用的。以下是使用情况：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We again see that the `basename` is evaluated first, but we do not see the
    more detailed steps involved in running that command. The screenshot that follows
    captures the command and output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次看到首先评估了 `basename`，但我们没有看到运行该命令所涉及的更详细的步骤。接下来的截图捕获了命令和输出：
- en: '![Debugging your scripts](img/00019.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![调试你的脚本](img/00019.jpeg)'
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This marks the end of the chapter and I am sure that you might have found this
    useful. Especially for those making a start with bash scripting, this chapter
    must have built a firm foundation on which you can build your knowledge.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着本章的结束，我相信你可能会发现这很有用。特别是对于那些刚开始使用 bash 脚本的人来说，本章一定已经为你打下了坚实的基础，你可以在此基础上建立你的知识。
- en: We began by ensuring that bash is secure and not susceptible to embedded functions
    shell-shock. With bash secured, we considered the execution hierarchy where aliases,
    functions, and so on are checked before the command; knowing this can help us
    plan a good naming structure and a path to locate the scripts.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先确保 bash 是安全的，不容易受到嵌入式函数 shell-shock 的影响。有了安全的 bash，我们考虑了别名、函数等在命令之前检查的执行层次结构；了解这一点可以帮助我们规划一个良好的命名结构和定位脚本的路径。
- en: Soon we were writing simple scripts with static content but we saw how easy
    it was to add flexibility using arguments. The exit code from the script can be
    read with the `$?` variable and we can create a command line list using `||` and
    `&&`, which depends on the success or failure of the preceding command in the
    list.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们就开始编写简单的脚本，其中包含静态内容，但我们看到了使用参数添加灵活性有多么容易。脚本的退出代码可以使用 `$?` 变量读取，我们可以使用 `||`
    和 `&&` 创建命令行列表，这取决于列表中前一个命令的成功或失败。
- en: Finally, we closed the chapter by looking at debugging the script. Its not really
    required when the script is trivial, but it will be useful later when complexity
    is added.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过查看脚本的调试来结束这一章。当脚本很简单时，实际上并不需要，但在以后增加复杂性时会很有用。
- en: In the next chapter, we will be creating interactive scripts that read the user's
    input during script execution.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建交互式脚本，这些脚本在脚本执行期间读取用户的输入。
