# 第十二章：在脚本中使用管道和重定向

在本章中，我们将解释 Bash 的一个非常重要的方面：*重定向*。我们将从描述不同类型的输入和输出重定向开始，以及它们如何与 Linux 文件描述符相关联。在涵盖了重定向的基础知识之后，我们将继续介绍一些高级用法。

接下来是*管道*，这是 Shell 脚本中广泛使用的一个概念。我们将介绍一些管道的实际示例。最后，我们将展示*here documents*的工作原理，这也有一些很好的用途。

本章将介绍以下命令：`diff`、`gcc`、`fallocate`、`tr`、`chpasswd`、`tee`和`bc`。

本章将涵盖以下主题：

+   输入/输出重定向

+   管道

+   Here documents

# 技术要求

本章的所有脚本都可以在 GitHub 上找到，链接如下：[`github.com/tammert/learn-linux-shell-scripting/tree/master/chapter_12`](https://github.com/tammert/learn-linux-shell-scripting/tree/master/chapter_12)。对于所有其他练习，你的 Ubuntu 18.04 虚拟机仍然是你最好的朋友。

# 输入/输出重定向

在本章中，我们将详细讨论 Linux 中的重定向。

简而言之，重定向几乎完全就像字面意思一样：将*某物*重定向到*其他某物*。例如，我们已经看到我们可以使用一个命令的输出作为下一个命令的输入，使用管道。在 Linux 中，管道是使用`|`符号实现的。

然而，这可能会引发一个问题：Linux 如何处理输入和输出？我们将从一些关于**文件描述符**的理论开始我们的重定向之旅，这是使所有重定向成为可能的原因！

# 文件描述符

你可能已经厌倦了听到这一点，但它仍然是真的：在 Linux 中，一切都是一个文件。我们已经看到一个文件是一个文件，一个目录是一个文件，甚至硬盘也是文件；但现在，我们将再进一步：你用于*输入*的键盘也是一个文件！

与此相辅相成的是，你的终端，命令使用它作为*输出*，猜猜看：就是一个文件。

你可以在 Linux 文件系统树中找到这些文件，就像大多数特殊文件一样。让我们检查一下我们的虚拟机：

[PRE0]

在这里找到的四个文件中，有三个很重要：`/dev/fd/0`、`/dev/fd/1`和`/dev/fd/2`。

从这段文字的标题中，你可能会怀疑**fd**代表**f**ile **d**escriptor。这些文件描述符在内部用于将用户的输入和输出与终端绑定在一起。你实际上可以看到文件描述符是如何做到这一点的：它们被符号链接到`/dev/pts/0`。

在这种情况下，**pts**代表**伪终端从属**，这是对 SSH 连接的定义。看看当我们从三个不同的位置查看`/dev/fd`时会发生什么：

[PRE1]

每个连接都有自己的`/dev/`挂载（存储在内存中的`udev`类型），这就是为什么我们看不到一个连接的输出进入另一个连接的原因。

现在，我们一直在谈论输入和输出。但是，正如你无疑所见，前面的例子中分配了三个文件描述符。在 Linux（或类 Unix 系统）中，默认通过文件描述符公开的三个默认**流**：

+   *标准输入*流`stdin`默认绑定到`/dev/fd/0`

+   *标准输出*流`stdout`默认绑定到`/dev/fd/1`

+   *标准错误*流`stderr`默认绑定到`/dev/fd/2`

就这三个流而言，`stdin`和`stdout`应该相当直接：输入和输出。然而，正如你可能已经推断出的那样，输出实际上被分成*正常*输出和*错误*输出。正常输出被发送到`stdout`文件描述符，而错误输出通常被发送到`stderr`。

由于这两者都是符号链接到终端，所以无论如何你都会在那里看到它们。然而，正如我们将在本章后面看到的，一旦我们开始重定向，这种差异就变得重要起来。

你可能会看到一些其他文件描述符，比如第一个示例中的 255。除了在终端提供输入和输出时使用它们，文件描述符还在 Linux 打开文件系统中的文件时使用。文件描述符的这种其他用途超出了本书的范围；然而，我们在*进一步阅读*部分包含了一个链接，供感兴趣的读者参考。

在正常交互中，你在终端中输入的文本被写入到`/dev/fd/0`上的`stdin`，一个命令可以读取。使用该输入，命令通常会执行某些操作（否则，我们就不需要这个命令！）并将输出写入`stdout`或`stderr`。然后终端会读取这些输出并显示给你。简而言之：

+   一个*终端* **写入** `stdin`，**读取** `stdout`或`stderr`

+   一个*命令* **从** `stdin` **读取**，**写入** `stdout` 或 `stderr`

除了 Linux 内部使用的文件描述符之外，还有一些保留用于创建真正高级脚本的文件描述符；这些是 3 到 9。任何其他的*可能*被系统使用，但这些保证可以自由使用。正如所述，这是非常高级的，不太经常使用，我们不会详细介绍。然而，我们找到了一些可能有趣的进一步阅读材料，这些材料包含在本章的末尾。

# 重定向输出

现在输入、输出和文件描述符的理论应该是清楚的，我们将看到如何在命令行和脚本冒险中使用这些技术。

事实上，在没有使用重定向的情况下编写 shell 脚本是相当困难的；在本章之前的书中，我们实际上已经使用了几次重定向，因为我们当时真的需要它来完成我们的工作（例如第八章中的`file-create.sh`，*变量和用户输入*）。

现在，让我们先来体验一下重定向！

# stdout

大多数命令的输出将是*标准输出*，写入`/dev/fd/1`上的`stdout`。通过使用`>`符号，我们可以使用以下语法重定向输出：

[PRE2]

重定向将始终指向一个文件（然而，正如我们所知，不是所有文件都是相等的，因此在常规示例之后，我们将向您展示一些 Bash 魔法，涉及非常规文件）。如果文件不存在，它将被创建。如果存在，它将被**覆盖**。

在其最简单的形式中，通常会打印到终端的所有内容都可以重定向到文件：

[PRE3]

如你所知，`cat`将整个文件内容打印到你的终端。实际上，它实际上将整个内容发送到`stdout`，它绑定到`/dev/fd/1`，它绑定到你的终端；这就是为什么你看到它。

现在，如果我们将文件的内容重定向回另一个文件，我们实际上已经做出了很大的努力...复制一个文件！从文件大小可以看出，实际上是相同的文件。如果你不确定，你可以使用`diff`命令来查看文件是否相同：

[PRE4]

如果`diff`没有返回任何输出，并且它的退出代码为`0`，则文件没有差异。

回到重定向示例。我们使用`>`将输出重定向到文件。实际上，`>`是`1>`的简写。你可能会认出这个`1`：它指的是文件描述符`/dev/fd/1`。正如我们将在处理`stderr`时看到的，它位于`/dev/fd/2`上，我们将使用`2>`而不是`1>`或`>`。

首先，让我们构建一个简单的脚本来进一步说明这一点：

[PRE5]

现在，当我们运行这个脚本时，`read`会提示我们输入一些文本。这将保存在`user_input`变量中。然后，我们将使用`echo`将`user_input`变量的内容发送到`stdout`。但是，它不会通过`/dev/fd/1`到达终端上的`/dev/pts/0`，而是重定向到`redirect-to-file.txt`文件中。

总的来说，它看起来像这样：

[PRE6]

现在，这个脚本按照预期工作。然而，如果我们再次运行它，我们会看到这个脚本可能出现的两个问题：

[PRE7]

第一件出错的事情，正如我们之前警告过的，是相对路径可能会搞乱文件的写入位置。

你可能已经设想到文件是在脚本旁边创建的；只有当你的*当前工作目录*在脚本所在的目录中时，才会发生这种情况。因为我们是从树的较低位置调用它，所以输出被写入那里（因为那是当前工作目录）。

另一个问题是，每次我们输入内容时，都会删除文件的旧内容！在我们输入`Hello`后，我们看到文件有六个字节（每个字符一个字节，加上一个换行符），在我们输入`Bye`后，我们现在看到文件只有四个字节（三个字符加上换行符）。

这可能是期望的行为，但更多时候，如果输出*追加*到文件中，而不是替换它，会更好。

让我们在脚本的新版本中解决这两个问题：

[PRE8]

现在，如果我们运行它（无论在哪里），我们会看到新的文本被追加到第一句话，“我喜欢狗！还有猫。也许是壁虎？”在`/home/reader/chapter_12/redirect-to-file.txt`文件中：

[PRE9]

所以，`cd $(dirname $0)` 帮助我们处理相对路径，`>>` 而不是 `>` 确保追加而不是覆盖。正如你所期望的那样，`>>` 再次代表 `1>>`，当我们开始稍后重定向 `stderr` 流时，我们会看到这一点。

不久前，我们向你承诺了一些 Bash 魔法。虽然不完全是魔法，但可能会让你的头有点疼：

[PRE10]

所以，我们成功地使用`cat`四次打印了我们的文件。你可能会想，我们也可以用`for`来做，但是这个教训不是我们打印消息的次数，而是我们是如何做到的！

首先，我们只是使用了`cat`；没有什么特别的。接下来，我们将`cat`与将`stdout`重定向到`/dev/pts/0`，也就是我们的终端，结合使用。同样，消息被打印出来。

第三和第四次，我们将`cat`的重定向`stdout`发送到`/dev/fd/1`和`/dev/fd/2`。由于这些是符号链接到`/dev/pts/0`，这也不奇怪，这些也最终出现在我们的终端上。

那么，我们如何实际区分 `stdout` 和 `stderr` 呢？

# stderr

如果你对前面的例子感到困惑，那可能是因为你误解了`stderr`消息的流向（我们不怪你，我们自己也搞混了！）。虽然我们将`cat`命令的输出发送到`/dev/fd/2`，但我们使用了`>`，这会发送`stdout`而不是`stderr`。

因此，在我们的示例中，我们滥用了 `stderr` 文件描述符来打印到终端；这是不好的做法。我们保证不会再这样做了。那么，我们如何*实际*处理 `stderr` 消息呢？

[PRE11]

这种交互应该说明一些事情。首先，当`cat /root/`抛出`Permission denied`错误时，它将其发送到`stderr`而不是`stdout`。我们可以看到这一点，因为当我们执行相同的命令，但尝试用`1> error-file`重定向*标准* *输出*时，我们仍然在终端上看到输出，并且我们还看到`error-file`是空的。

当我们使用`2> error-file`时，它重定向`stderr`而不是常规的`stdout`，我们不再在终端上看到错误消息。

更好的是，我们现在看到`error-file`有 31 个字节的内容，当我们用`cat`打印它时，我们再次看到了我们重定向的错误消息！如前所述，并且与`1>>`的精神一样，如果你想*追加*而不是*覆盖*`stderr`流到一个文件，使用`2>>`。

现在，因为很难找到一个命令来在同一个命令中打印`stdout`和`stderr`，我们将创建我们自己的命令：一个非常简单的 C 程序，它打印两行文本，一行到`stdout`，一行到`stderr`。

作为对编程和编译的预览，请看这个（如果你不完全理解这个，不要担心）：

[PRE12]

`gcc stderr.c -o stderr`命令将在`stderr.c`中找到的源代码编译为二进制文件`stderr`。

`gcc`是 GNU 编译器集合，并不总是默认安装的。如果你想跟着这个例子并且收到关于找不到`gcc`的错误，请使用`sudo apt install gcc -y`来安装它。

如果我们运行我们的程序，我们会得到两行输出。因为这不是一个 Bash 脚本，我们不能用`bash stderr`来执行它。我们需要用`chmod`使二进制文件可执行，并用`./stderr`来运行它：

[PRE13]

现在，让我们看看当我们开始重定向部分输出时会发生什么：

[PRE14]

因为我们只重定向了`stdout`（最后提醒：`>`等于`1>`）到完全限定的文件`/tmp/stdout`，`stderr`消息仍然被打印到终端上。

另一种方式会得到类似的结果：

[PRE15]

现在，当我们只使用`2> /tmp/stderr`来重定向`stderr`时，我们会看到`stdout`消息出现在我们的终端上，而`stderr`被正确地重定向到`/tmp/stderr`文件中。

我相信你现在正在问自己这个问题：我们如何重定向**所有输出**，包括`stdout`和`stderr`，到一个文件？如果这是一本关于 Bash 3.x 的书，我们将会有一个困难的对话。这个对话将包括我们将`stderr`重定向到`stdout`，之后我们可以使用`>`将所有输出（因为我们已经将`stderr`重定向到`stdout`）发送到一个单独的文件。

尽管这是逻辑上的做法，将`stderr`重定向到`stdout`实际上是在命令的末尾。命令最终变成这样：`./stderr > /tmp/output 2>&1`。并不是*太复杂*，但足够难以一次记住（你可以相信我们）。

幸运的是，在 Bash 4.x 中，我们有一个新的重定向命令可供我们使用，可以以更易理解的方式完成相同的事情：`&>`。

# 重定向所有输出

在大多数情况下，发送到`stderr`而不是`stdout`的输出将包含明显表明你正在处理错误的单词。这将包括诸如`permission denied`、`cannot execute binary file`、`syntax error near unexpected token`等示例。

因此，通常并不真的需要将输出分成`stdout`和`stderr`（但显然，有时会是很好的功能）。在这些情况下，Bash 4.x 的新增功能允许我们用单个命令重定向`stdout`和`stderr`是完美的。这种重定向，你可以使用`&>`语法，与我们之前看到的例子没有不同。

让我们回顾一下我们之前的例子，看看这是如何让我们的生活变得更容易的：

[PRE16]

太棒了！有了这个语法，我们就不再需要担心不同的输出流。当你使用新命令时，这是特别实用的；在这种情况下，你可能会错过一些有趣的错误消息，因为`stderr`流没有被保存。

冒昧地说一下，将`stdout`和`stderr`都追加到文件的语法再次是额外的`>`：`&>>`。

继续尝试之前的例子。我们不会在这里打印它，因为现在应该很明显这是如何工作的。

不确定是重定向所有输出，还是只重定向`stdout`或`stderr`？我们的建议：从将**两者**重定向到同一个文件开始。如果在您的用例中这会产生太多噪音（掩盖错误或正常日志消息），您可以决定将它们中的任何一个重定向到文件，并在终端中打印另一个。实际上，`stderr`消息通常需要`stdout`消息提供的上下文来理解错误，因此最好将它们方便地放在同一个文件中！

# 特殊的输出重定向

尽管发送所有输出通常是一件好事，但您经常会发现自己要做的另一件事是将错误（您期望在某些命令上出现）重定向到一个特殊的设备：`/dev/null`。

`null`类型透露了功能：它介于垃圾桶和黑洞之间。

# /dev/null

实际上，所有发送（实际上是写入）到`/dev/null`的数据都将被丢弃，但仍会生成一个*写操作成功*的返回给调用命令。在这种情况下，那将是重定向。

这很重要，因为当重定向无法成功完成时会发生什么：

[PRE17]

这个操作失败了（因为`reader`用户显然无法在`root`超级用户的主目录中写入）。

看看当我们尝试使用`/dev/null`做同样的事情时会发生什么：

[PRE18]

就是这样。所有的输出都消失了（因为`&>`重定向了`stdout`和`stderr`），但命令仍然报告了期望的退出状态`0`。当我们确保数据已经消失时，我们使用`cat /dev/null`，结果什么也没有。

我们将向您展示一个实际示例，您在脚本中经常会使用到：

[PRE19]

这个脚本只包含我们之前介绍过的结构，除了对`stderr`进行`/dev/null`重定向。虽然这个`find.sh`脚本实际上只是`find`命令的一个简单包装器，但它确实有很大的区别。

看看当我们使用`find`查找文件`find.sh`时会发生什么（因为为什么不呢！）：

[PRE20]

我们删掉了大约 95%的输出，因为您可能会同意，五页的`Permission denied`错误没有多少价值。因为我们是以普通用户身份运行`find`，所以我们无法访问系统的许多部分。这些错误反映了这一点。

我们确实找到了我们的脚本，正如之前所强调的，但在遇到它之前可能需要滚动几分钟。这正是我们所说的错误输出淹没相关输出的情况。

现在，让我们用我们的包装脚本寻找同一个文件：

[PRE21]

我们走了！相同的结果，但没有那些让我们困惑的烦人错误。由于`Permission denied`错误被发送到`stderr`流，我们在`find`命令之后使用`2> /dev/null` *删除*了它们。

这实际上带我们到另一个观点：您也可以使用重定向来使命令静音。我们已经看到许多命令都包含`--quiet`或`-q`标志。但是，有些命令，比如`find`，却没有这个标志。

您可能会认为`find`有这个标志会很奇怪（为什么要搜索文件，当你不想知道它在哪里时，对吧？），但可能有其他命令的退出代码提供了足够的信息，但没有`--quiet`标志；这些都是将所有内容重定向到`/dev/null`的绝佳候选者。

所有的命令都是不同的。虽然现在大多数命令都有一个可用的`--quiet`标志，但总会有一些情况不适用。也许`--quiet`标志只静音`stdout`而不是`stderr`，或者它只减少输出。无论如何，当您真的对输出不感兴趣（只对退出状态感兴趣）时，了解将所有输出重定向到`/dev/null`是一件非常好的事情！

# /dev/zero

我们可以使用的另一个特殊设备是`/dev/zero`。当我们将输出重定向到`/dev/zero`时，它与`/dev/null`完全相同：数据消失。但是，在实践中，`/dev/null`最常用于此目的。

那么，为什么有这个特殊的设备呢？因为`/dev/zero`也可以用来读取空字节。在所有可能的 256 个字节中，空字节是第一个：十六进制`00`。空字节通常用于表示命令的终止，例如。

现在，我们还可以使用这些空字节来为磁盘分配字节：

[PRE22]

通过使用`head -c 1024`，我们指定要从`/dev/zero`中获取*前 1024 个字符*。因为`/dev/zero`只提供空字节，这些字节都将是相同的，但我们确切知道会有`1024`个。

我们使用`stdout`重定向将它们重定向到文件，然后我们看到一个大小为 1024 字节的文件（多么令人惊讶）。现在，如果我们`cat`这个文件，我们什么也看不到！同样，这不应该是一个惊喜，因为空字节就是这样：空的，无效的，空的。终端无法表示它们，因此它不会显示。

如果您在脚本中需要执行此操作，还有另一个选项：`fallocate`：

[PRE23]

从前面的输出中可以看出，这个命令与我们已经通过`/dev/zero`读取和重定向实现的功能完全相同（如果`fallocate`实际上是从`/dev/zero`读取的一个花哨的包装器，我们不会感到惊讶，但我们不能确定）。

# 输入重定向

另外两个著名的特殊设备`/dev/random`和`/dev/urandom`最好与*输入重定向*一起讨论。

输入通常来自您的键盘，通过终端传递给命令。最简单的例子是`read`命令：它从`stdin`读取，直到遇到换行符（按下*Enter*键时），然后将输入保存到`REPLY`变量（或者如果您提供了该参数，则保存到任何自定义变量）。它看起来有点像这样：

[PRE24]

简单。现在，假设我们以非交互方式运行此命令，这意味着我们无法使用键盘和终端提供信息（对于`read`来说不是真正的用例，但这是一个很好的例子）。

在这种情况下，我们可以使用输入重定向（`stdin`）来提供`read`的输入。这是通过`<`字符实现的，它是`<0`的简写。记住`stdin`文件描述符是`/dev/fd/0`？这不是巧合。

让我们通过将`stdin`重定向到文件而不是终端，以非交互方式使用`read`：

[PRE25]

为了表明我们没有作弊并重复使用`${answer}`变量中已经存储的答案，我们已经将`read`中的回复重命名为`${new_answer}`。

现在，在命令的末尾，我们将`stdin`从`answer-file`文件重定向，我们首先使用`echo` + `stdout`重定向创建了这个文件。这就像在命令之后添加`< answer-file`一样简单。

这种重定向使`read`从文件中读取，直到遇到换行符（这恰好是`echo`总是以字符串结尾的地方）。

现在基本的输入重定向应该是清楚的了，让我们回到我们的特殊设备：`/dev/random`和`/dev/urandom`。这两个特殊文件是伪随机数生成器，这是一个复杂的词，用于生成*几乎*随机的数据。

在这些特殊设备的情况下，它们从设备驱动程序、鼠标移动和其他大部分是随机的东西中收集*熵*（一个类似随机性的复杂词）。

`/dev/random`和`/dev/urandom`之间有一个细微的区别：当系统中的熵不足时，`/dev/random`停止生成随机输出，而`/dev/urandom`则继续生成。

如果您真的需要完全的熵，`/dev/random`可能是更好的选择（老实说，在这种情况下，您可能会采取其他措施），但通常情况下，在您的脚本中，`/dev/urandom`是更好的选择，因为阻塞可能会导致不可思议的等待时间。这来自第一手经验，可能非常不方便！

对于我们的示例，我们只会展示`/dev/urandom`；`/dev/random`的输出类似。

在实践中，`/dev/urandom`会*随机*地产生字节。虽然有些字节在可打印的 ASCII 字符范围内（1-9，a-z，A-Z），但其他字节用于空格（0x20）或换行符（0x0A）。

您可以通过使用`head -1`从`/dev/urandom`中抓取'第一行'来查看随机性。由于一行以换行符结尾，命令`head -1 /dev/urandom`将打印直到第一个换行符之前的所有内容：这可能是少量或大量字符：

[PRE26]

我们第一次运行时打印了更多的字符（并非所有字符都可读）比第二次运行时；这可以直接与生成的字节的随机性联系起来。第二次我们运行`head -1 /dev/urandom`时，我们比第一次迭代更快地遇到了换行字节 0x0A。

# 生成密码

现在，您可能会想知道随机字符可能有什么用。一个主要的例子是生成密码。长而随机的密码总是很好；它们抵抗暴力破解攻击，无法被猜测，并且如果不重复使用，非常安全。而且坦率地说，使用您自己的 Linux 系统的熵来生成随机密码有多酷呢？

更好的是，我们可以使用来自`/dev/urandom`的输入重定向来完成这个任务，再加上`tr`命令。一个简单的脚本看起来是这样的：

[PRE27]

标题和输入检查，甚至包括使用正则表达式检查数字的检查，现在应该是清楚的。

接下来，我们使用`tr`命令从`/dev/urandom`重定向输入，以获取我们的 a-z、A-Z 和 0-9 字符集中的可读字符。这些被*管道*到`head`（本章后面将更多地介绍管道），这会导致前*x*个字符被打印给用户（如脚本参数中指定的那样）。

为了确保终端格式正确，我们在没有参数的情况下添加了一个快速的`echo`；这只是打印一个换行符。就像这样，我们建立了我们自己的*私人*、*安全*和*离线*密码生成器。甚至使用输入重定向！

# 高级重定向

我们现在已经看到了输入和输出重定向，以及两者的一些实际用途。但是，我们还没有结合这两种重定向形式，这是完全可能的！

您可能不会经常使用这个功能；大多数命令接受输入作为参数，并经常提供一个标志，允许您指定要输出到的文件。但知识就是力量，如果您遇到一个没有这些参数的命令，您知道您可以自己解决这个问题。

在命令行上尝试以下操作，并尝试理解为什么会得到您看到的结果：

[PRE28]

正如您所看到的，我们可以在同一行上使用`<`和`>`来重定向输入和输出。首先，我们在`grep 'stderr' < stderr.c`命令中使用了输入重定向的`grep`（这在技术上也是`grep 'stderr' stderr.c`所做的）。我们在终端中看到了输出。

接下来，我们在该命令的后面添加了`> /tmp/grep-file`，这意味着我们将把我们的`stdout`重定向到`/tmp/grep-file`文件。我们不再在终端中看到输出，但当我们`cat`文件时，我们会得到它，所以它成功地写入了文件。

由于我们现在处于本章的高级部分，我们将演示输入重定向放在哪里实际上并不重要：

[PRE29]

在这里，我们在命令的开头指定了输入重定向。对我们来说，当考虑流程时，这似乎是更合乎逻辑的方法，但这会导致实际命令（`grep`）出现在命令的大致中间，这会破坏可读性。

这在实践中基本上是一个无用的观点，因为我们发现很少有用于输入和输出重定向；即使在这个例子中，我们也只需将命令写成`grep 'stdout' stderr.c > /tmp/grep-file-stdout`，混乱的构造就消失了。

但真正理解输入和输出的运作方式，以及一些命令如何为你做一些繁重的工作，是值得你花时间去理解的！这些正是你在更复杂的脚本中会遇到的问题，充分理解这一点将为你节省大量的故障排除时间。

# 重定向重定向

我们已经给你一个重定向重定向过程的概览。最著名的例子是在 Bash 4.x 之前大多数情况下使用的，即将`stderr`流重定向到`stdout`流。通过这样做，你可以只用`>`语法重定向*所有*输出。

你可以这样实现：

[PRE30]

记住，你不再需要在 Bash 4.x 中使用这种语法，但是如果你想要使用自定义的文件描述符作为输入/输出流，这将是有用的知识。通过以`2>&1`结束命令，我们将所有`stderr`输出（`2>`）写入`stdout`描述符（`&1`）。

我们也可以反过来做：

[PRE31]

所以现在，我们将`stderr`流重定向到`passwd`文件。然而，`head -1 /etc/passwd`命令只提供了一个`stdout`流；我们看到它被打印到终端而不是文件中。

当我们使用`1>&2`（也可以写成`>&2`）时，我们将`stdout`重定向到`stderr`。现在它被写入文件，我们可以在那里使用`cat`命令！

记住，这是高级信息，主要用于你的理论理解以及当你开始使用自定义文件描述符时。对于所有其他输出重定向，还是安全地使用我们之前讨论过的`&>`语法。

# 命令替换

虽然在 Linux 意义上并不严格属于重定向，但在我们看来，*命令替换*是一种功能性重定向的形式：你使用一个命令的输出作为另一个命令的参数。如果我们需要使用输出作为下一个命令的输入，我们会使用管道（正如我们将在几页后看到的），但有时我们只需要将输出放在我们命令中的一个非常特定的位置。

这就是命令替换的用途。我们已经在一些脚本中看到了命令替换：`cd $(dirname $0)`。简单地说，这做的事情类似于`cd`到`dirname $0`的结果。

`dirname $0`返回脚本所在的目录（因为`$0`是脚本的完全限定路径），所以当我们在脚本中使用它时，我们将确保所有操作都相对于脚本所在的目录进行。

如果没有命令替换，我们需要在再次使用它之前将输出存储在某个地方：

[PRE32]

虽然这有时会起作用，但这里有一些陷阱：

+   你需要在你有写权限的地方写一个文件

+   在`cd`之后你需要清理文件

+   你需要确保文件不会与其他脚本冲突

长话短说，这远非理想的解决方案，最好避免使用。而且由于 Bash 提供了命令替换，使用它并没有真正的缺点。正如我们所见，`cd $(dirname $0)`中的命令替换为我们处理了这个问题，而不需要我们跟踪文件或变量或任何其他复杂的构造。

命令替换实际上在 Bash 脚本中经常使用。看看以下的例子，我们在其中使用命令替换来实例化和填充一个变量：

[PRE33]

在这个例子中，我们重用了我们之前的`password-generator.sh`脚本中的逻辑。这一次，我们不给用户提供输入长度的选项；我们保持简单，假设长度为 20（至少在 2018 年，这是一个相当好的密码长度）。

我们使用命令替换将结果（随机密码）写入一个变量，然后将其`echo`给用户。

实际上我们可以在一行中完成这个操作：

[PRE34]

然而，正如我们现在已经讨论了很多次，*可读性很重要*（仍然！）。我们认为在实际使用之前首先将其写入具有描述性名称的变量，可以增加脚本的可读性。

此外，如果我们想要多次使用相同的随机值，我们无论如何都需要一个变量。因此，在这种情况下，脚本中的额外冗长帮助我们并且是可取的。

`$(..)`的前身是使用反引号，即`` ` ``字符（在英语国际键盘上的`1`旁边）。`$(cd dirname $0)`以前写为`` `cd dirname $0` ``。虽然这与新的（更好的）`$(..)`语法做的事情相同，有两件事经常与反斜线有关：单词拆分和换行。这些都是由空白引起的问题。使用新的语法要容易得多，而且不必担心这样的事情！

[PRE54]

就是这样。只是一个简单的输入字符串（发送到命令的`stdin`），我们得到了与使用管道的`echo`相同的功能。但是，现在只是一个命令，而不是一个链。简单但有效，正是我们喜欢的方式！

# 总结

这一章几乎解释了关于 Linux 上*重定向*的所有知识。我们从对重定向的一般描述开始，以及如何使用*文件描述符*来促进重定向。我们了解到文件描述符 0、1 和 2 分别用于`stdin`、`stdout`和`stderr`。

然后我们熟悉了重定向的语法。这包括`>`、`2>`、`&>`和`<`，以及它们的追加语法，`>>`、`2>>`、`&>>`和`<<`。

我们讨论了一些特殊的 Linux 设备，`/dev/null`、`/dev/zero`和`/dev/urandom`。我们展示了如何使用这些设备来删除输出、生成空字节和生成随机数据的示例。在高级重定向部分，我们展示了我们可以将`stdout`绑定到`stderr`，反之亦然。

此外，我们了解了*命令替换*和*进程替换*，它允许我们在另一个命令的参数中使用命令的结果，或者作为文件。

接下来是*管道*。管道是简单但非常强大的 Bash 结构，用于将一个命令的`stdout`（可能还有`stderr`）连接到另一个命令的`stdin`。这使我们能够链接命令，通过尽可能多的命令来进一步操作数据流。

我们还介绍了`tee`，它允许我们将流发送到我们的终端和一个文件，这种结构通常用于日志文件。

最后，我们解释了*文档*和*字符串*。这些概念允许我们将多行和单行输入直接从终端发送到其他命令的`stdin`，否则需要`echo`或`cat`。

本章介绍了以下命令：`diff`、`gcc`、`fallocate`、`tr`、`chpasswd`、`tee`和`bc`。

# 问题

1.  文件描述符是什么？

1.  术语`stdin`、`stdout`和`stderr`是什么意思？

1.  `stdin`、`stdout`和`stderr`如何映射到默认文件描述符？

1.  `>`、`1>`和`2>`之间的输出重定向有什么区别？

1.  `>`和`>>`之间有什么区别？

1.  如何同时重定向`stdout`和`stderr`？

1.  哪些特殊设备可以用作输出的黑洞？

1.  管道在重定向方面有什么作用？

1.  我们如何将输出发送到终端和日志文件？

1.  here string 的典型用例是什么？

# 进一步阅读

+   请点击以下链接了解有关文件描述符的更多信息：[`linuxmeerkat.wordpress.com/2011/12/02/file-descriptors-explained/`](https://linuxmeerkat.wordpress.com/2011/12/02/file-descriptors-explained/)。

+   请点击以下链接了解有关使用文件描述符的高级脚本的信息：[`bash.cyberciti.biz/guide/Reads_from_the_file_descriptor_(fd)`](https://bash.cyberciti.biz/guide/Reads_from_the_file_descriptor_(fd))。

+   请点击以下链接了解有关命令替换的更多信息：[`www.tldp.org/LDP/abs/html/commandsub.html`](http://www.tldp.org/LDP/abs/html/commandsub.html)。

+   请点击以下链接了解有关 here documents 的信息：[`www.tldp.org/LDP/abs/html/here-docs.html`](https://www.tldp.org/LDP/abs/html/here-docs.html)。
