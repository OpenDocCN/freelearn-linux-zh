- en: Process Credentials
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程凭证
- en: 'In this chapter, and the following one, the reader will learn concepts and
    practices regarding process credentials and capabilities. Besides being of practical
    importance to application development in Linux, this chapter, by its very nature,
    delves deeper into an often overlooked but extremely key aspect: security. The
    content of this and the following chapter is very much inter-related.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和下一章中，读者将学习有关进程凭证和能力的概念和实践。除了在Linux应用程序开发中具有实际重要性之外，本章本质上更深入地探讨了一个经常被忽视但极其关键的方面：安全性。本章和下一章的内容非常相关。
- en: 'We divide the coverage of this key area into two major parts, each of which
    is a chapter in this book:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这一关键领域的覆盖分为两个主要部分，每个部分都是本书的一个章节：
- en: In this chapter, the traditional-style Unix permissions model is discussed in
    some detail, and techniques to run programs with root privileges without requiring
    the root password are shown.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，详细讨论了传统风格的Unix权限模型，并展示了在不需要根密码的情况下以root权限运行程序的技术。
- en: In [Chapter 8](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml), *Process Capabilities*,
    the modern approach, the POSIX capabilities model, is discussed in some detail.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第8章](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml) *进程能力*中，讨论了现代方法，POSIX能力模型的一些细节。
- en: We will attempt to clearly show the reader that, while it is important to learn
    about the traditional mechanisms and how they operate, it is also important to
    learn about modern approaches to security. However you look at it, security is
    of paramount importance, especially these days. The advent of Linux running on
    all sorts of devices—from tiny IoT and embedded devices to mobile devices, desktops,
    servers, and super-computing platforms—makes security a key concern for all stakeholders.
    Hence, the modern capabilities approach should be used when developing software.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试清楚地向读者表明，虽然重要的是了解传统机制及其运作方式，但了解现代安全性方法也同样重要。无论如何看待它，安全性都是非常重要的，尤其是在当今。Linux在各种设备上运行——从微小的物联网和嵌入式设备到移动设备、台式机、服务器和超级计算平台——使安全性成为所有利益相关者的关键关注点。因此，在开发软件时应使用现代能力方法。
- en: In this chapter, we will broadly cover the traditional Unix permissions model,
    what exactly it is, and how it works to provide security and robustness. A bit
    of hacking is always fun too!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将广泛介绍传统的Unix权限模型，它究竟是什么，以及它是如何提供安全性和稳健性的。一点黑客攻击总是有趣的！
- en: 'You will learn about the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您将了解以下内容：
- en: The Unix permission model in action
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix权限模型的运行
- en: Real and effective IDs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 真实和有效的身份证
- en: Powerful system calls to query and set process credentials
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大的系统调用来查询和设置进程凭证
- en: Hacking attempts (a little bit)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑客攻击（一点点）
- en: How `sudo(8)`actually works
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo(8)`实际上是如何工作的'
- en: Saved-set IDs
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存的身份证
- en: Important thoughts on security
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于安全性的重要思考
- en: Along the way, several examples allow you to try out concepts in a hands-on
    way, to really understand them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，几个示例允许您以实际操作的方式尝试概念，以便真正理解它们。
- en: The traditional Unix permissions model
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统的Unix权限模型
- en: Right from the early 1970, the Unix OS had, as usual, an elegant and powerful
    system in place for managing the security of shared objects on the system. These
    objects included files and directories—perhaps the most commonly thought of ones.
    Files, directories, and symbolic links are filesystem objects; there are several
    others, including memory objects (tasks, pipes, shared memory regions, message
    queues, semaphores, keys, sockets) and pseudo filesystems (proc, sysfs, debugfs,
    cgroupfs, and so on) and their objects. The point is all these objects are shared
    in some manner or other, and thus they require a protection mechanism of some
    sort, to protect them from abuse; this mechanism is called the Unix permission
    model.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从1970年初开始，Unix操作系统通常具有一个优雅而强大的系统，用于管理系统上共享对象的安全性。这些对象包括文件和目录——也许是最常考虑的对象。文件、目录和符号链接是文件系统对象；还有其他几个，包括内存对象（任务、管道、共享内存区域、消息队列、信号量、密钥、套接字）和伪文件系统（proc、sysfs、debugfs、cgroupfs等）及其对象。重点是所有这些对象都以某种方式共享，因此它们需要某种保护机制，以防止滥用；这种机制称为Unix权限模型。
- en: You probably don't want others to read, write, and delete your files; the Unix permission
    model makes this possible at various granularity levels; again, taking files and
    directories as a common target, you can set permissions at the level of a directory,
    or indeed on each file (and directory) within that directory.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不希望其他人读取、写入和删除您的文件；Unix权限模型使这在各种粒度级别上成为可能；再次，以文件和目录作为常见目标，您可以在目录级别设置权限，或者在该目录中的每个文件（和目录）上设置权限。
- en: 'To make this clear, let''s consider a typical shared object—a file on a disk.
    Let''s create one called `myfile`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确这一点，让我们考虑一个典型的共享对象——磁盘上的文件。让我们创建一个名为`myfile`的文件：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All output displayed is from an Ubuntu 17.10 x86_64 Linux system; the user is
    logged in as `seawolf`*.*
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有显示的输出都来自Ubuntu 17.10 x86_64 Linux系统；用户以`seawolf`登录。
- en: Permissions at the user level
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户级别的权限
- en: 'Earlier we did a quick `ls -l` on the previous `myfile` file; the very first
    character `-` reveals, of course, that it''s a regular file; the next nine characters
    `rw-rw-r--`are the file permissions. If you remember, these are grouped into three
    groups—the **Owner** (**U**), **Group** (**G**), and **Others** (**O**) (or Public)
    permissions, each of which contains three permission bits: **r**, **w**, and **x **(read,
    write and execute access). This table summarizes this information:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们对之前的`myfile`文件进行了快速的`ls -l`；第一个字符`-`当然显示它是一个常规文件；接下来的九个字符`rw-rw-r--`是文件权限。如果您记得，这些被分成三组——**所有者**（**U**）、**组**（**G**）和**其他人**（**O**）（或公共）权限，每个组包含三个权限位：**r**、**w**和**x**（读取、写入和执行访问）。这张表总结了这些信息：
- en: '![](img/22f3bf7d-102d-4c63-a232-e52f883ff328.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22f3bf7d-102d-4c63-a232-e52f883ff328.png)'
- en: Interpreting it, we can see that the owner of the file can read and write to
    it, and so can the group members, but others (those who are not the owner and
    do not belong to the group the file belongs to) can only perform a read operation
    on `myfile`. That's security!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 解释一下，我们可以看到文件的所有者可以读取和写入它，组成员也可以，但其他人（既不是所有者也不属于文件所属的组）只能对`myfile`执行读操作。这就是安全性！
- en: 'So, let''s take an example: we attempt to write to the file `myfile`, using
    the `echo` command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们举个例子：我们尝试使用`echo`命令写入文件`myfile`：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Will it work? Well, the answer is, it depends: if the owner or group member
    of the file (in this example, seawolf) is running the echo(1) process, then the
    access category will be accordingly set to U or G, and,  yes, it will succeed
    (as U|G does have write access to the file). But if the process''s access category
    is Others or Public, it will fail.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它会起作用吗？嗯，答案是，这取决于：如果文件的所有者或组成员（在本例中是seawolf）正在运行echo(1)进程，那么访问类别将相应地设置为U或G，是的，它将成功（因为U|G对文件具有写访问权限）。但是，如果进程的访问类别是其他或公共，它将失败。
- en: How the Unix permission model works
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix权限模型是如何工作的
- en: 'A really important point to understand regarding this topic is this: both the
    shared object that is being worked upon (here, the `myfile` file) and the process
    that is performing some access (rwx) on the object (here, the echo process) matter.
    To be more correct, their attributes with respect to permissions matter. The next
    discussion will help make this clear.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个主题的一个非常重要的理解点是：正在处理的共享对象（这里是`myfile`文件）和正在对对象执行某些访问（rwx）的进程（这里是echo进程）都很重要。更正确地说，它们的权限属性很重要。下一次讨论将有助于澄清这一点。
- en: 'Let''s consider this step by step:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地考虑这个问题：
- en: A user with the login name `seawolf` logs in to the system.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用登录名`seawolf`的用户登录到系统。
- en: On success, the system spawns a shell; the user is now at the shell prompt.
    (Here, we consider the traditional case of logging into a **command-line interface**
    (**CLI**) console, not a GUI environment.)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功后，系统会生成一个shell；用户现在处于shell提示符下。（在这里，我们考虑的是登录到**命令行界面**（CLI）控制台的传统情况，而不是GUI环境。）
- en: 'Every user has a record; it''s stored in the `/etc/passwd` file. Let''s `grep`
    the file for this user:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户都有一条记录；它存储在`/etc/passwd`文件中。让我们为这个用户`grep`文件：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Generically, just do this: `grep $LOGNAME /etc/passwd`'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，只需这样做：`grep $LOGNAME /etc/passwd`
- en: 'The `passwd` entry is a row with seven columns that are colon-delimited fields;
    they are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`passwd`条目是一个有七列的行，它们是以冒号分隔的字段；它们如下：'
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A few fields require some explanation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个字段需要解释一下：
- en: The second field, `<passwd>`, always shows up as just `x` on modern Linux systems;
    this is for security. Even the encrypted password is never displayed (hackers
    can very possibly break it via a brute-force algorithm; it's in a root-only file
    called `/etc/shadow`).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个字段`<passwd>`在现代Linux系统上总是显示为`x`；这是为了安全。即使加密密码也不会显示出来（黑客很可能可以通过暴力算法破解它；它在一个只有root用户才能访问的文件`/etc/shadow`中）。
- en: The third and fourth fields are the **User IDentifier** (**UID**) and **Group
    IDentifier** (**GID**) of the user.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三和第四个字段是用户的**用户标识符**（UID）和**组标识符**（GID）。
- en: The seventh field is the program to run on successful login; it's usually the
    shell (as preceding), but it could be anything.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第七个字段是成功登录时要运行的程序；通常是shell（如前所述），但也可以是其他任何东西。
- en: To programmatically query `/etc/passwd`, check out the `getpwnam[_r](3)`, `getpwent[_r](3)`
    library layer APIs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要以编程方式查询`/etc/passwd`，请查看`getpwnam[_r](3)`，`getpwent[_r](3)`库层API。
- en: 'The last point is a key one: the system spawns a shell for the user who logged
    in. A shell is the **user** i**nterface** (UI) between the human user and the
    system on the CLI environment. After all, it''s a process; on Linux, bash is usually
    the shell we use. The shell you receive when you login is called your login shell.
    It''s important, because its privileges determine the privileges of all processes
    it launches—in effect, the privileges you have when working on the system are
    derived from your login shell.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点是关键的：系统为登录的用户生成一个shell。shell是CLI环境中人类用户和系统之间的**用户界面**（UI）。毕竟，它是一个进程；在Linux上，bash通常是我们使用的shell。当您登录时收到的shell称为您的登录shell。这很重要，因为它的特权决定了它启动的所有进程的特权——实际上，您在系统上工作时拥有的特权是从您的登录shell派生的。
- en: 'Let''s look up our shell process:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查找我们的shell进程：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There it is; our bash process has a **Process Identifier **(**PID**—a unique
    integer identifying a process) of 13833\. Now, the process has other attributes
    associated with it; for our current purposes, the key ones are the process **User
    Identifier **(**UID**) and the process **Group Identifier **(**GID**).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是了；我们的bash进程有一个**进程标识符**（PID——一个唯一的整数标识进程）为13833。现在，进程还有其他与之关联的属性；对于我们当前的目的来说，关键的是进程**用户标识符**（UID）和进程**组标识符**（GID）。
- en: 'Can one lookup these UID, GID values for a process? Let''s try it out with
    the `id(1)` command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可以查找进程的UID、GID值吗？让我们尝试使用`id(1)`命令：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `id(1)` command shows us that the process UID is 1000 and the process GID
    also happens to be 1000\. (The username is `seawolf` and this user belongs to
    several groups.) In the previous example, we have logged in as the user `seawolf`; this
    fact is reflected by the `id` command. Note that every process we now run from
    this shell will inherit the privileges of this user account, that is, it will
    run with the same UID and GID as the login shell!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`id(1)`命令向我们显示，进程UID是1000，进程GID也恰好是1000。（用户名是`seawolf`，这个用户属于几个组。）在前面的例子中，我们已经以用户`seawolf`的身份登录；`id`命令反映了这一事实。请注意，我们现在从这个shell运行的每个进程都将继承这个用户帐户的特权，也就是说，它将以与登录shell相同的UID和GID运行！'
- en: 'You might reasonably ask: where does the process get its UID and GID values
    from? Well, think about it: we logged in as the user `seawolf`, and this account''s
    `/etc/passwd` entry''s third and fourth fields are where the process UID and GID
    come from.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会合理地问：进程的UID和GID值是从哪里获取的？嗯，想想看：我们以用户`seawolf`的身份登录，这个帐户的`/etc/passwd`条目的第三个和第四个字段是进程UID和GID的来源。
- en: So, every time we run a process from this shell, that process will run with
    UID 1000 and GID 1000.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次我们从这个shell运行一个进程，该进程将以UID 1000和GID 1000运行。
- en: 'We want to understand how exactly the OS checks whether we can perform an operation
    such as the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要了解操作系统如何准确地检查我们是否可以执行以下操作：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, the key question here is: how exactly, at runtime, when the preceding echo
    process is attempting to write to the `myfile` file, does the kernel determine
    whether the write access is allowed. To do this, the OS must determine the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的关键问题是：在运行时，当前的echo进程尝试写入`myfile`文件时，内核如何确定写入访问是否被允许。为了做到这一点，操作系统必须确定以下内容：
- en: What is the ownership and group membership of the file in question?
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所讨论的文件的所有权和组成员资格是什么？
- en: In what access category is the process attempting the access running under (for
    example, is it U|G|O)?
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程尝试访问的访问类别是什么（例如，是U|G|O）？
- en: For that access category, does the permission bitmask allow access?
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于该访问类别，权限掩码是否允许访问？
- en: To answer the first question: the file's ownership and group membership information
    (and a lot more regarding the file) is carried as attributes of the key data structure
    of the filesystem—the **information node** (**inode**). The inode data structure
    is a per-file structure and lives within the kernel (filesystem; it's read into
    memory when the file is first accessed). User space can of course access this
    information via system calls. So, the file owner ID is stored in the inode—let's
    just call it `file_UID`. Similarly, the `file_GID` will also be present in the
    inode object.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 回答第一个问题：文件的所有权和组成员信息（以及关于文件的更多信息）作为文件系统的关键数据结构的属性进行传递——**信息节点**（**inode**）。inode数据结构是一个每个文件的结构，并且存在于内核中（文件系统；当文件首次被访问时，它被读入内存）。用户空间当然可以通过系统调用访问这些信息。因此，文件所有者ID存储在inode中——让我们称之为`file_UID`。类似地，`file_GID`也将存在于inode对象中。
- en: 'For the curious reader: you can yourself query any file object''s inode by
    using the powerful `stat(2)` system call. (As usual, look up its man page). In
    fact, we have used `stat(2)` in [Appendix A](https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf),
    *File I/O Essentials*.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于好奇的读者：您可以使用强大的`stat(2)`系统调用自己查询任何文件对象的inode。（像往常一样，查阅它的手册页）。事实上，我们在[附录A](https://www.packtpub.com/sites/default/files/downloads/File_IO_Essentials.pdf)中使用了`stat(2)`，*文件I/O基础*。
- en: Determining the access category
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定访问类别
- en: 'The second question posed previously: what access category will it run under?
    is important to answer.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 先前提出的第二个问题：它将以哪种访问类别运行？这是很重要的问题。
- en: 'The access category will be either **Owner** (**U**), **Group** (**G**), or
    **Other** (**O**); they are mutually exclusive. The algorithm used by the OS to
    determine the access category is something like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 访问类别将是**所有者**（**U**）、**组**（**G**）或**其他**（**O**）中的一个；它们是互斥的。操作系统用于确定访问类别的算法大致如下：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Actually, it''s a bit more complex: a process can belong to several groups
    simultaneously. So, at permission checking time, the kernel checks all groups;
    if the process belongs to any one of them, the access category is set to G.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，情况要复杂一些：一个进程可以同时属于多个组。因此，在检查权限时，内核会检查所有组；如果进程属于其中任何一个组，访问类别就设置为G。
- en: Finally, for that access category, check the permission bitmask (rwx); if the
    relevant bit is set, the process will be allowed the operation; if not, it won't
    be.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于该访问类别，检查权限掩码（rwx）；如果相关位被设置，进程将被允许进行操作；如果没有，就不会被允许。
- en: 'Let''s take a look at the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下命令：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another way to clarify—the `stat(1)` command (which of course is a wrapper
    over the `stat(2)` system call) show us the inode content of the file `myfile`,
    like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种澄清的方法——`stat(1)`命令（当然是`stat(2)`系统调用的包装器）显示了文件`myfile`的inode内容，就像这样：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Clearly, we are highlighting the `file_UID == 1000` and `file_GID == 1000`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们正在强调`file_UID == 1000`和`file_GID == 1000`。
- en: In our echo example, we find that a few scenarios can play out, depending on
    who logs in, the group membership(s), and the file's permissions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的echo示例中，我们发现，根据谁登录，组成员资格和文件权限，可以出现一些情景。
- en: 'So, to understand this properly, let''s plant a few scenarios (from now on,
    we shall just refer to the process UID as the `UID` and the process GID value
    as the `GID`, as opposed to `process_UID|GID`):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了正确理解这一点，让我们设想一些情景（从现在开始，我们将只是将进程UID称为`UID`，将进程GID值称为`GID`，而不是`process_UID|GID`）：
- en: '**User logs in as seawolf**: [UID 1000, GID 1000]'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户以seawolf身份登录**：[UID 1000，GID 1000]'
- en: '**User logs in as mewolf**: [UID 2000, GID 1000]'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户以mewolf身份登录**：[UID 2000，GID 1000]'
- en: '**User logs in as cato**: [UID 3000, GID 3000]'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户以cato身份登录**：[UID 3000，GID 3000]'
- en: '**User logs in as groupy**: [UID 4000, GID 3000, GID 2000, GID 1000]'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户以groupy身份登录**：[UID 4000，GID 3000，GID 2000，GID 1000]'
- en: 'Once logged in, the user attempts this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦登录，用户尝试执行以下操作：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What happens? Which will work (permission allowed) and which won''t? Run through
    the previous scenarios with the previous algorithm, to determine the crucial access
    category, and you will see; the following table summarizes the cases:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？哪个会起作用（权限允许），哪个不会？通过先前的算法运行先前的情景，确定关键的访问类别，你会看到；以下表总结了这些情况：
- en: '| **Case #** | **Login as** | **(Process)** **UID** | **(Process)** **GID**
    | **Access category** **(U&#124;G&#124;O)** | **Perm** **bitmask** | **Write allowed?**
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| **案例＃** | **登录为** | **（进程）UID** | **（进程）GID** | **访问类别** **（U&#124;G&#124;O）**
    | **Perm** **bitmask** | **允许写入？** |'
- en: '| 1 | seawolf | 1000 | 1000 | U | `r**w**-` | Y |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 1 | seawolf | 1000 | 1000 | U | `r**w**-` | Y |'
- en: '| 2 | mewolf | 2000 | 1000 | G | `r**w**-` | Y |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 2 | mewolf | 2000 | 1000 | G | `r**w**-` | Y |'
- en: '| 3 | cato | 3000 | 3000 | O | `r**-**-` | N |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 3 | cato | 3000 | 3000 | O | `r**-**-` | N |'
- en: '| 4 | groupy | 4000 | 4000,3000, 2000,1000 | G | `r**w**-` | Y |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 4 | groupy | 4000 | 4000,3000, 2000,1000 | G | `r**w**-` | Y |'
- en: The preceding description is still a bit too simplistic, but is a good starting
    point. In reality, there's a lot more happening under the hood; the following
    sections shed light on this.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的描述仍然有点太简单了，但是作为一个很好的起点。实际上，在幕后发生了更多的事情；接下来的部分将阐明这一点。
- en: 'Prior to this, we will take a slight detour: the `chmod(1)` command (which
    of course becomes the `chmod(2)` system call) is used to set permissions on an
    object. So, if we do this: `chmod g-w myfile` to remove write permissions from
    the group category, then the previous table will change (the rows that get G access
    will now not be allowed to write).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，我们将稍微偏离一下：`chmod(1)`命令（当然会变成`chmod(2)`系统调用）用于设置对象的权限。因此，如果我们这样做：`chmod
    g-w myfile`来从组类别中删除写权限，那么之前的表将会改变（获得G访问权限的行现在将不允许写入）。
- en: 'Here is an interesting observation: processes with the craved-for root access
    are those that have their `UID = 0`; it''s a special value!'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的观察：渴望获得root访问权限的进程是那些`UID = 0`的进程；这是一个特殊的值！
- en: 'Next, to be pedantic, actually the echo command can run in two distinct ways:
    one, as a process when the binary executable (usually `/bin/echo`) runs, and two,
    as a built in shell command; in other words, there is no new process, the shell
    process itself—typically `bash` —runs it.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，严谨地说，echo命令实际上可以以两种不同的方式运行：一种是作为一个进程，当二进制可执行文件（通常是`/bin/echo`）运行时，另一种是作为一个内置的shell命令；换句话说，没有新的进程，shell进程本身——通常是`bash`——运行它。
- en: Real and effective IDs
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真实和有效ID
- en: We understand from the preceding section that both the shared object that is
    being worked upon (here, the file myfile) and the process that is performing some
    access (rwx) on the object (here, the echo process) matter in terms of permissions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从前面的部分了解到，正在处理的共享对象（这里是文件myfile）和执行某些访问操作的进程（这里是echo进程）在权限方面都很重要。
- en: Let's zoom deeper into the process attributes with respect to the permissions
    model. So far, we have learned that each process is associated with a UID and
    a GID, thereby allowing the kernel to run its internal algorithms and determine
    whether access to a resource (or object) should be allowed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解与权限模型相关的进程属性。到目前为止，我们已经了解到每个进程都与一个UID和一个GID相关联，从而允许内核运行其内部算法，并确定是否应该允许对资源（或对象）的访问。
- en: 'If we look deeper, we find that each process UID is actually not a single integer
    value, but two values:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们深入研究，我们会发现每个进程UID实际上不是一个单一的整数值，而是两个值：
- en: The **Real User ID** (**RUID**)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真实用户ID**（**RUID**）'
- en: The **Effective User ID** (**EUID**)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效用户ID**（**EUID**）'
- en: 'Similarly, the group information is not one integer GID value, rather it''s
    two integers:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，组信息不是一个整数GID值，而是两个整数：
- en: The **Real Group ID** (**RGID**)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真实组ID**（**RGID**）'
- en: The **Effective Group ID** (**EGID**)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有效组ID**（**EGID**）'
- en: 'So, with respect to privileges, each process has four integer values associated
    with it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，关于特权，每个进程都有与之关联的四个整数值：
- en: '{RUID, EUID, RGID, EGID};  these are called the **process credentials**.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '{RUID, EUID, RGID, EGID}；这些被称为**进程凭证**。'
- en: Pedantically speaking, process credentials also encompass several other process
    attributes—the process PID, the PPID, PGID, session ID, and the real and effective
    user and group IDs. In our discussions, for clarity, we restrict their meaning
    to the last of these—real and effective user and group IDs.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，进程凭证还包括其他几个进程属性——进程PID、PPID、PGID、会话ID以及真实和有效用户和组ID。在我们的讨论中，为了清晰起见，我们将它们的含义限制在最后一个——真实和有效用户和组ID。
- en: But what exactly do they mean?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们究竟是什么意思呢？
- en: Every process has to run under the ownership and group membership of somebody;
    this somebody is of course the user and group IDs of the person who logs in.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都必须在某人的所有权和组成员身份下运行；这个某人当然是登录的用户和组ID。
- en: 'The real IDs are the original values associated with the user who logged in;
    in effect, they are nothing but the UID:GID pair from the `/etc/passwd` record
    for that user. Recall that the `id(1)` command reveals precisely this information:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 真实ID是与登录用户关联的原始值；实际上，它们只是来自该用户的`/etc/passwd`记录的UID:GID对。回想一下，`id(1)`命令恰好显示了这些信息：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `uid` and `gid` values displayed are obtained from the `/etc/passwd` record
    for seawolf. In reality, the `uid/gid` values become the running process's RUID/RGID
    values respectively!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的`uid`和`gid`值是从`/etc/passwd`记录中的seawolf获取的。实际上，`uid/gid`值分别成为运行进程的RUID/RGID值！
- en: 'The real numbers reflect who you originally are—your login account information
    in the form of integer identifiers. Another way to put it: the real numbers reflect
    who owns the process.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 真实数字反映了你最初的身份——以整数标识符的登录帐户信息。另一种说法是：真实数字反映了谁拥有该进程。
- en: What about the effective values?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那么有效值呢？
- en: 'The effective values are to inform the OS as to effectively (at this moment) what
    privileges (user and group) the process is running under. Here are a couple of
    key points:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有效值是为了通知操作系统，当前进程正在以什么样的特权（用户和组）运行。以下是一些关键点：
- en: When performing permission checks, the OS uses the process's effective values,
    not the real (original) values.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行权限检查时，操作系统使用进程的有效值，而不是真实（原始）值。
- en: '`EUID = 0` is what the OS actually checks for to determine whether the process
    has root privilege.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EUID = 0`是操作系统实际检查的内容，以确定进程是否具有root特权。'
- en: 'By default it is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下如下：
- en: The EUID = RUID
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EUID = RUID
- en: The EGID = RGID
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EGID = RGID
- en: 'This implies that, for the preceding example, the following is true:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，对于前面的例子，以下是正确的：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Yes. This brings up a question (don''t you think?): if the real and effective
    IDs are the same, then why do we require four numbers at all? Two will do, right?'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。这引发了一个问题（你不觉得吗？）：如果真实和有效ID是相同的，那么为什么我们需要四个数字呢？两个就够了，对吧？
- en: 'Well, here''s the thing: they usually (by default) are the same, but they can
    change. Let''s see how this can happen.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，事实是：它们通常（默认情况下）是相同的，但它们可以改变。让我们看看这是如何发生的。
- en: 'Again, here is a pedantic note: on Linux, the permission checking on filesystem
    operations is predicated on yet another process credential—the filesystem UID
    (or fsuid; and, analogously, the fsgid). However, it''s always the case that the
    fsuid/fsgid pair shadow the EUID/EGID pair of credentials—thereby, effectively
    rendering them the same. That''s why in our discussion we ignore the `fs[u|g]id`
    and focus on the usual real and effective user and group IDs.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调一下：在Linux上，文件系统操作的权限检查是基于另一个进程凭证-文件系统UID（或fsuid；类似地，fsgid）。然而，总是情况是fsuid/fsgid对遮蔽了EUID/EGID对的凭证-从而有效地使它们相同。这就是为什么在我们的讨论中我们忽略`fs[u|g]id`并专注于通常的真实和有效的用户和组ID。
- en: 'Before that, though, think about this scenario: a user is logged in, and is
    on the shell; what are their privileges? Well, just run the `id(1)` program; the
    output will display the UID and GID, which we now know is actually {RUID, EUID}
    and the {RGID, EGID} pair with the same values.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之前，想想这种情况：一个用户登录并在shell上；他们有什么特权？好吧，只需运行`id(1)`程序；输出将显示UID和GID，我们现在知道实际上是{RUID，EUID}和{RGID，EGID}对，具有相同的值。
- en: 'For the sake of an easier-to-read example, let''s take the liberty of changing
    the GID value from 1000, to, say, 2000\. So, now, if the values are UID=1000 and
    GID=2000, and the user now runs, shall we say, the vi editor, now the situation
    is like this, refer to the given table, process credentials - normal case:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易阅读的例子，让我们随便将GID值从1000更改为2000。所以，现在，如果值是UID=1000和GID=2000，用户现在运行，我们应该说，vi编辑器，现在情况是这样的，参考给定的表，进程凭证
    - 正常情况：
- en: '| **Process credentials** **/ process** | **RUID** | **EUID** | **RGID** |
    **EGID** |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| **进程凭证** **/ 进程** | **RUID** | **EUID** | **RGID** | **EGID** |'
- en: '| bash | 1000 | 1000 | 2000 | 2000 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| bash | 1000 | 1000 | 2000 | 2000 |'
- en: '| vi | 1000 | 1000 | 2000 | 2000 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| vi | 1000 | 1000 | 2000 | 2000 |'
- en: A puzzle – how can a regular user change their password?
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个谜题-普通用户如何更改他们的密码？
- en: 'Let''s say you''re logged in as `seawolf`. For security reasons, you want to
    update your weak password (`hello123`, whoops!) to a strong secure one. We know
    that the password is stored in the `/etc/passwd` file. Well, we also saw that
    on modern Unixes (including Linux of course), for better security it''s *shadowed*:
    it''s actually stored in a file called `/etc/shadow`. Let''s check it out:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你以`seawolf`登录。出于安全原因，你想要将你的弱密码（`hello123`，哎呀！）更新为一个强密码。我们知道密码存储在`/etc/passwd`文件中。好吧，我们也知道在现代Unix系统（包括Linux）中，为了更好的安全性，密码是*shadowed*：实际上存储在一个名为`/etc/shadow`的文件中。让我们来看看：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: (Remember that we're on an Ubuntu 17.10 x86_64 system; we often point this out,
    as the exact output might vary on different distributions, and if kernel security
    mechanisms, such as SELinux, are installed.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: （请记住，我们在Ubuntu 17.10 x86_64系统上；我们经常指出这一点，因为在不同的发行版上，确切的输出可能会有所不同，如果安装了诸如SELinux之类的内核安全机制。）
- en: 'As highlighted, you can see that the file owner is root, the group membership
    is shadow, and the permission bitmask for UGO is `[rw-][r--][---]`. This means
    the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如上面所强调的，你可以看到文件所有者是root，组成员是shadow，UGO的权限掩码为`[rw-][r--][---]`。这意味着以下内容：
- en: The owner (root) can perform read/write operations
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有者（root）可以执行读/写操作
- en: The group (shadow) can perform read-only operations
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组（shadow）可以执行只读操作
- en: The others cannot do anything to the file
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他人无法对文件进行任何操作
- en: You probably also know that the utility you use to change your password is called
    `passwd(1)` (of course, it's a binary executable program, and is not to be confused
    with the `/etc/passwd(5)` database).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也知道，你用来更改密码的实用程序叫做`passwd(1)`（当然，它是一个二进制可执行程序，并且不应与`/etc/passwd(5)`数据库混淆）。
- en: 'So, think about it, we have a bit of a puzzle here: to change your password,
    you need write access to `/etc/shadow`, but, clearly, only root has write access
    to `/etc/shadow`. So, how does it work? (We know it works. You logged in as a regular
    user, not root. You can change your password using the `passwd(1)` utility—try
    it out and see.) So, that''s a good question.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，想一想，我们有一个谜题：要更改你的密码，你需要对`/etc/shadow`有写访问权限，但是，显然，只有root有对`/etc/shadow`的写访问权限。那么，它是如何工作的呢？（我们知道它是如何工作的。你以普通用户身份登录，而不是root。你可以使用`passwd(1)`实用程序来更改你的密码-试一试看。）所以，这是一个很好的问题。
- en: 'The clue lies in the binary executable utility itself—`passwd`. Let''s check
    it out; firstly, where''s the utility on disk? Refer to the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 线索就在二进制可执行实用程序本身-`passwd`。让我们来看看；首先，磁盘上的实用程序在哪里？参考以下代码：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s dig deeper—quote the preceding command and long list it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入挖掘-引用前面的命令并进行长列表：
- en: '![](img/c5b6b6b0-6a8f-4d00-a131-8fc186010ed5.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b6b6b0-6a8f-4d00-a131-8fc186010ed5.png)'
- en: Can you spot anything unusual?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你能发现任何异常吗？
- en: 'It''s the owner execute bit: it''s not an `x` as you might expect, but an `s`
    ! (Really, this is the reason behind the pretty red coloring of the executable
    name in preceding the long listing.)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是所有者执行位：它不是你可能期望的`x`，而是一个`s`！（实际上，这就是在前面的长列表中可执行文件名字的漂亮红色背后的原因。）
- en: 'It''s a special permission bit: for a binary executable file, when there''s
    an `s` in the owner''s execute bit, it''s referred to as a setuid binary. This
    means whenever a setuid program is executed, the resultant process''s **Effective
    Userid** (**EUID**) changes (from the default: the original RUID value) to become
    equal to the owner of the binary executable file; in the previous example, the
    EUID will become root (as the `/usr/bin/passwd` file is owned by root).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特殊的权限位：对于一个二进制可执行文件，当所有者的执行位中有一个`s`时，它被称为setuid二进制文件。这意味着每当执行setuid程序时，生成的进程的**有效用户ID**（**EUID**）会改变（从默认值：原始RUID值）变为等于二进制可执行文件的所有者；在前面的例子中，EUID将变为root（因为`/usr/bin/passwd`文件的所有者是root）。
- en: 'Now we redraw the previous table (Process Credentials - Normal Case) with this
    new information in hand, with respect to the setuid passwd executable:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们根据手头的新信息重新绘制上一个表（进程凭证-正常情况），关于setuid passwd可执行文件：
- en: '| **Process credentials** **/ process ** | **RUID** | **EUID** | **RGID** |
    **EGID** |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **进程凭证** **/ 进程** | **RUID** | **EUID** | **RGID** | **EGID** |'
- en: '| bash | 1000 | 1000 | 2000 | 2000 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| bash | 1000 | 1000 | 2000 | 2000 |'
- en: '| vi | 1000 | 1000 | 2000 | 2000 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| vi | 1000 | 1000 | 2000 | 2000 |'
- en: '| /usr/bin/passwd | 1000 | 0 | 2000 | 2000 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| /usr/bin/passwd | 1000 | 0 | 2000 | 2000 |'
- en: 'Table: process credentials - setuid-root case (third row)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 表：进程凭据 - setuid-root情况（第三行）
- en: 'So, this answers how it works: the EUID being the special value **`0`** (root),
    the OS now sees the process as being a root process and allows it to write into
    the `/etc/shadow` database.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这回答了它是如何工作的：EUID是特殊值**`0`**（root），操作系统现在将进程视为root进程，并允许其写入`/etc/shadow`数据库。
- en: 'A program such as `/usr/bin/passwd`, inherits root access by virtue of the
    setuid bit and the fact that the file owner is root: these kinds of programs are
    called setuid root binaries (they''re also called set-user-ID-root programs).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如`/usr/bin/passwd`这样的程序，通过setuid位继承了root访问权限，并且文件所有者是root：这些类型的程序称为setuid root二进制文件（它们也被称为set-user-ID-root程序）。
- en: 'To quote a frustrated developer''s reaction to testers everywhere: i*t''s not
    a bug; it''s a feature!* Well, it is: the setuid feature is pretty amazing: with
    no programming whatsoever, you are able to raise the privilege level of a process
    for a temporary duration.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 引用一个受挫的开发人员对所有测试人员的反应：*这不是一个bug；这是一个功能！* 好吧，它就是：setuid功能非常了不起：完全不需要编程，您就能够提高进程的特权级别，持续一段时间。
- en: Think about this. Without this feature, it would be impossible for non-root
    users (the majority) to change their password. Requesting the system administrator
    to do this (picture a large organization with a few thousand employees with Linux
    accounts) would not only have the sysadcontemplate suicide, you would have to
    provide the sysad with your new password, perhaps not exactly a brilliant security
    practice.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 想想这个。如果没有这个功能，非root用户（大多数用户）将无法更改他们的密码。要求系统管理员执行此操作（想象一下拥有几千名员工具有Linux账户的大型组织）不仅会让系统管理员考虑自杀，还必须向系统管理员提供您的新密码，这可能并不是一个明智的安全实践。
- en: The setuid and setgid special permission bits
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: setuid和setgid特殊权限位
- en: 'We can see that setuid program binaries are an important takeaway from the
    preceding discussion; let''s summarize it once more:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到setuid程序二进制文件是前面讨论的一个重要内容；让我们再次总结一下：
- en: A binary executable file with the owner execute bit set to `s` is called a **setuid
    binary**.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有所有者执行位设置为`s`的二进制可执行文件称为**setuid二进制文件**。
- en: If the owner of said executable file is root, then it's called a **setuid-root
    binary**.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果该可执行文件的所有者是root，则称为**setuid-root二进制文件**。
- en: 'When you execute a setuid program, the key point is that the EUID is set to
    the owner of the binary executable file:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您执行setuid程序时，关键点在于EUID设置为二进制可执行文件的所有者：
- en: Thus, with setuid-root binaries, the process will run as root!
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，使用setuid-root二进制文件，进程将以root身份运行！
- en: Of course, once the process dies, you are back to your shell with your regular
    (default) set of process credentials or privileges.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当进程死掉后，您将回到具有常规（默认）进程凭据或特权的shell。
- en: 'Conceptually similar to setuid is the notion of the setgid special permission
    bit:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在概念上类似于setuid的是setgid特殊权限位的概念：
- en: A binary executable file with the group execute bit set to `s` is called a setgid
    binary.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有组执行位设置为`s`的二进制可执行文件称为setgid二进制文件。
- en: When you execute a setgid program, the key point is that the EGID is set to
    the group membership of the binary executable file.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您执行setgid程序时，关键点在于EGID设置为二进制可执行文件的组成员身份。
- en: Of course, once the process dies, you are back to your shell with your regular
    (default) set of process credentials or privileges.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当进程死掉后，您将回到具有常规（默认）进程凭据或特权的shell。
- en: As mentioned, remember that the `set[u|g]id` special permission bits only have
    significance on binary executable files, nothing else. For example, attempting
    to set these bits on a script (bash, Perl, and so on) will have absolutely no
    effect.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，请记住，`set[u|g]id`特殊权限位只对二进制可执行文件有意义，对于脚本（bash、Perl等）尝试设置这些位将完全没有效果。
- en: Setting the setuid and setgid bits with chmod
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`chmod`设置setuid和setgid位
- en: You have perhaps, by now, thought okay, but how exactly do I set these special
    permission bits?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 也许到现在为止，您已经想到了，但是我到底如何设置这些特殊权限位呢？
- en: 'This is simple: you use the `chmod(1)` command (or system call); this table
    shows how chmod can be used to set the `setuid/setgid` permission bits:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单：您可以使用`chmod(1)`命令（或系统调用）；此表显示了如何使用chmod设置`setuid/setgid`权限位：
- en: '| **chmod via:** | **Notation for setuid** | **Notation for setgid** |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: 通过`chmod`： | 设置setuid的符号 | 设置setgid的符号 |
- en: '| symbolic notation | `u+s` | `g+s` |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 符号表示 | `u+s` | `g+s` |'
- en: '| octal notation | `4<octal #> (eg. 4755)` | `2<octal #> (eg. 2755)` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 八进制符号 | `4<八进制 #> (例如4755)` | `2<八进制 #> (例如2755)` |'
- en: 'As a trivial example, take a simple `Hello, world` C program and compile it:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 举个简单的例子，拿一个简单的`Hello, world` C程序并编译它：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we set the setuid bit, then remove it, and set the setgid bit instead (in
    one operation: via the `u-s,g+s` parameter to chmod), then remove the setgid bit,
    all the while long-listing the binary executable so that the permissions can be
    seen:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们设置了setuid位，然后删除它，并设置了setgid位（通过`u-s,g+s`参数进行一次操作：通过`chmod`），然后删除了setgid位，同时长时间列出二进制可执行文件以便查看权限：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: (As this `Hello, world` program just trivially prints to stdout and nothing
    more, the setuid/setgid bits have no perceived effect.)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: （由于这个`Hello, world`程序只是简单地打印到stdout，没有其他作用，因此setuid/setgid位没有任何感知效果。）
- en: Hacking attempt 1
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黑客尝试1
- en: Well, well, wasn't that discussion on setuid root interesting! For you, the
    reader, who's thinking like a hacker (good for you!), why not do this to gain
    the ultimate prize, a root shell!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，嗯，对于您这位像黑客一样思考的读者（干得好！），为什么不这样做以获得最终奖励，即root shell！
- en: Write a C program to spawn a shell (the `system(3)` library API makes this trivial);
    we call the code `rootsh_hack1.c`. We want a root shell as the outcome!
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个生成shell的C程序（`system(3)`库API使这变得简单）；我们将代码称为`rootsh_hack1.c`。我们希望得到一个root
    shell作为结果！
- en: 'Compile it, get `a.out`. If we run `a.out` now, no big deal; we''ll get a shell
    with the same privileges that we already have. So instead try this:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译它，得到`a.out`。如果我们现在运行`a.out`，没什么大不了的；我们将得到一个具有我们已经拥有的相同特权的shell。所以尝试这个：
- en: Change permissions with `chmod(1)` to set the `setuid` bit.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`chmod(1)`更改权限以设置`setuid`位。
- en: Change ownership with `chown(1)` of `a.out` to root.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`chown(1)`将`a.out`的所有权更改为root。
- en: 'Run it: we should now get a root shell.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行它：我们现在应该得到一个root shell。
- en: Wow! Let's try this out!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！让我们试试这个！
- en: The code is simple (we don't show the header inclusion here)*:*
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单（我们这里不显示头文件的包含）*：*
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now compile and run:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译并运行：
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As expected, when run with no special `set[u|g]id` permission bits, the a.out
    process runs with normal privileges, spawning a shell under the same ownership
    (seawolf)—exactly what the `id -u` command proves.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，当没有特殊的`set[u|g]id`权限位运行时，a.out进程以普通特权运行，生成一个与相同所有者（seawolf）的shell——正是`id
    -u`命令证明的。
- en: 'Now, we attempt our hack:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们尝试我们的黑客行为：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It worked! Well, don''t get too excited: we got it to become a setuid binary,
    but the owner is still `seawolf`; so it won''t make any difference at runtime:
    the process EUID will become that of the owner of the binary executable—`seawolf`
    itself:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 成功了！好吧，不要太兴奋：我们已经将其变成了一个setuid二进制文件，但所有者仍然是`seawolf`；因此在运行时不会有任何区别：进程EUID将变为二进制可执行文件的所有者`seawolf`本身：
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Hmm. Yes, so what we need to do now is make the owner root:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯。是的，所以我们现在需要做的是将所有者更改为root：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Sorry to burst your bubble, budding hacker: it won''t work. This is the security;
    with `chown(1)`, you can only change ownership of the files (or objects) you own,
    and, guess what? To your own account only! Only root can use `chown` to set an
    object''s ownership to anyone else.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 抱歉要打破你的幻想，新手黑客：这行不通。这就是安全性；使用`chown(1)`，你只能更改你拥有的文件（或对象）的所有权，猜猜？只能更改为你自己的帐户！只有root可以使用`chown`将对象的所有权设置为其他任何人。
- en: 'This makes sense security-wise. It goes even further; watch this: we''ll become
    root and run `chown` (by just `sudo`ing it of course):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全性方面来看这是有道理的。它甚至更进一步；看看这个：我们将成为root并运行`chown`（当然只是通过`sudo`）：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Did you notice? Even though the `chown` succeeded, the setuid bit got wiped
    out! That's security.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了吗？即使`chown`成功了，setuid位也被清除了！这就是安全性。
- en: 'Okay, let''s subvert even that by setting the setuid bit manually on the root-owned
    a.out (note that this isn''t even possible unless we already have root access
    or the password):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们甚至通过手动在root-owned a.out上设置setuid位来颠覆这一点（请注意，除非我们已经拥有root访问权限或密码，否则这是不可能的）：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Ah! Now it is a setuid-root binary executable (indeed, you can''t see it here
    but the color of a.out  changed to red). No one''s going to stop us! Take a look
    at this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！现在它是一个setuid-root二进制可执行文件（确实，你在这里看不到，但a.out的颜色变成了红色）。没有人会阻止我们！看看这个：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The spawned shell has a (R)UID of 1000, not 0 What happened?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的shell的（R）UID为1000，而不是0。发生了什么？
- en: 'That''s a surprise! Even with root ownership and the setuid bit we do not get
    a root shell. How come? Because of the security, of course: when run via `system(3)`,
    modern versions of bash refuse to run as root on startup. This screenshot shows
    the relevant part of the man page on `system(3)`—showing the caveat that we''re
    discussing ([http://man7.org/linux/man-pages/man3/system.3.html](http://man7.org/linux/man-pages/man3/system.3.html)):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 真是个惊喜！即使拥有root所有权和setuid位，我们也无法获得root shell。怎么回事？当然是因为安全性：当通过`system(3)`运行时，现代版本的bash拒绝在启动时以root身份运行。这张截图显示了`system(3)`的man页面上相关部分，显示了我们正在讨论的警告（[http://man7.org/linux/man-pages/man3/system.3.html](http://man7.org/linux/man-pages/man3/system.3.html)）：
- en: '![](img/9f6be597-f178-489f-9896-f946f56b8a9a.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f6be597-f178-489f-9896-f946f56b8a9a.png)'
- en: 'The second paragraph sums it up:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 第二段总结了这一点：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: System calls
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统调用
- en: We understand from our previous discussions that every process alive has a set
    of four integer values that effectively determine its privileges, the real and
    effective user and group IDs; they are called the process credentials.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从之前的讨论中了解到，每个活动进程都有一组四个整数值，有效确定其特权，即真实和有效的用户和组ID；它们被称为进程凭证。
- en: As mentioned earlier, we refer to them as the {RUID, EUID, RGID, EGID}.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将它们称为{RUID，EUID，RGID，EGID}。
- en: The effective IDs are in bold font, to reiterate the fact that while the real
    IDs identify the original owner and group, when it comes to actually checking
    permissions, the kernel uses the effective IDs.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的ID以粗体字显示，以重申这样一个事实，即当涉及实际检查权限时，内核使用有效的ID。
- en: Where are the process credentials stored? The OS keeps this information as part
    of a rather large process attributes data structure (which is per-process of course);
    it is in kernel memory space.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 进程凭证存储在哪里？操作系统将这些信息作为相当大的进程属性数据结构的一部分（当然是每个进程）保存在内核内存空间中。
- en: On Unix, this per-process data structure is called the **Process Control Block** (**PCB**);
    on Linux, it's called the process descriptor or, simply, the task structure.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix上，这种每个进程的数据结构称为**进程控制块**（**PCB**）；在Linux上，它被称为进程描述符或简单地称为任务结构。
- en: 'The point is this: if the data is in kernel address space, the only way to
    get at it (query or set) is via system calls, of course.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是：如果数据在内核地址空间中，那么获取（查询或设置）的唯一方法是通过系统调用。
- en: Querying the process credentials
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询进程凭证
- en: 'How do you programmatically (in a C program) query the real and effective UIDs
    /GIDs? Here are the system calls to do so:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在C程序中以编程方式查询真实和有效的UID / GID？以下是用于这样做的系统调用：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is pretty straightforward:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单：
- en: '`getuid(2)` returns the real UID; `geteuid(2)` returns the effective UID'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getuid(2)`返回真实UID；`geteuid(2)`返回有效UID'
- en: '`getgid(2)` returns the real GID; `getegid(2)` returns the effective GID'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getgid(2)`返回真实GID；`getegid(2)`返回有效GID'
- en: '`uid_t` and `gid_t` are glibc typedefs for an unsigned integer'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uid_t`和`gid_t`是glibc对无符号整数的typedef'
- en: 'Here is a neat tip to figure out the typedef for any given data type: you will
    need to know the header file that contains the definition. Just do this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的提示，可以找出任何给定数据类型的typedef：你需要知道包含定义的头文件。只需这样做：
- en: '`$ echo | gcc -E -xc -include ''sys/types.h'' - | grep uid_t`'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ echo | gcc -E -xc -include ''sys/types.h'' - | grep uid_t`'
- en: '`typedef unsigned int __uid_t;`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`typedef unsigned int __uid_t;`'
- en: '`typedef __uid_t uid_t;`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`typedef __uid_t uid_t;`'
- en: '`$`'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`'
- en: Credit*:* [https://stackoverflow.com/questions/2550774/what-is-size-t-in-c](https://stackoverflow.com/questions/2550774/what-is-size-t-in-c).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 来源*：[https://stackoverflow.com/questions/2550774/what-is-size-t-in-c](https://stackoverflow.com/questions/2550774/what-is-size-t-in-c)。
- en: 'A question comes up: the preceding system calls do not take any parameters;
    they return the real or effective [U|G]IDs, yes, but for which process? The answer,
    of course, is the calling process, the process that issues the system calls.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题出现了：前面的系统调用没有带任何参数；它们返回真实或有效的[U|G]ID，是的，但是为哪个进程？答案当然是调用进程，发出系统调用的进程。
- en: Code example
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: 'We write a simple C program (`ch7/query_creds.c`); when run, it prints to stdout
    its process credentials (we show the relevant code):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个简单的C程序（`ch7/query_creds.c`）；运行时，它会将其进程凭证打印到标准输出（我们展示了相关代码）：
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Build it and try it out:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并尝试运行它：
- en: '[PRE28]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: On the first run, the four process credential values are the usual ones (1000,
    in our example). Also, note how by default the EUID = RUID and the EGID = RGID.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一次运行时，四个进程凭证的值是通常的值（在我们的例子中是1000）。还要注意，默认情况下EUID = RUID，EGID = RGID。
- en: 'But on the second run we `sudo` it: once we get the password right, the process
    runs as root, which of course can be literally seen here: the four process credential
    values are now all zeros reflecting root authority.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 但在第二次运行时我们使用了`sudo`：一旦我们输入正确的密码，进程就以root身份运行，这当然可以从这里直接看到：四个进程凭证的值现在都是零，反映了root权限。
- en: Sudo – how it works
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sudo - 它是如何工作的
- en: The `sudo(8)` utility lets you run a program as another user; without further
    qualification, that other user is root. Of course, for security, you must correctly
    enter the root password (or as several distributions allow for desktop computing,
    the user's own password, if he belongs to a group called sudo).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo(8)`实用程序允许您以另一个用户的身份运行程序；如果没有进一步的限定，那么另一个用户就是root。当然，出于安全考虑，您必须正确输入root密码（或者像一些发行版允许桌面计算那样，如果用户属于sudo组，可以输入用户自己的密码）。'
- en: 'This brings up a very interesting point: how exactly does the can-do-anything
    `sudo(8)` program work? It''s simpler than you think! Refer to the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来了一个非常有趣的问题：`sudo(8)`程序究竟是如何工作的？它比你想象的要简单！参考以下代码：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We note that the binary executable sudo is really a setuid-root program! So
    think about it: whenever you run a program with sudo, the sudo process runs with
    a root privilege straight away—no password, no fuss. But, of course, for security,
    the user must enter the password; once they enter it correctly, sudo continues
    execution and executes the command you want it to—as root. If the user fails to
    enter the password correctly (within three attempts typically), sudo aborts execution.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，可执行文件sudo实际上是一个设置了setuid-root权限的程序！所以想一想：每当您使用sudo运行一个程序时，sudo进程就会立即以root权限运行——不需要密码，也不需要麻烦。但是，出于安全考虑，用户必须输入密码；一旦他们正确输入密码，sudo就会继续执行并以root身份执行您想要的命令。如果用户未能正确输入密码（通常在三次尝试内），sudo将中止执行。
- en: What is a saved-set ID?
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存的ID是什么？
- en: The so-called saved-set IDs are a convenience feature; the OS is able to save
    the process's initial effective user id (EUID) value. How does it help? This allows
    us to switch from the original EUID value the process starts with to, say, an
    unprivileged normal value (we'll cover how exactly in a moment), and then from
    the current privileged state back to that saved EUID value (via the `seteuid(2)`
    system call); thus, the initially saved EUID is called the **saved-set ID**.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 所谓的保存的ID是一个方便的功能；操作系统能够保存进程的初始有效用户ID（EUID）的值。它有什么作用呢？这允许我们从进程启动时的原始EUID值切换到一个非特权的普通值（我们马上就会详细介绍），然后从当前特权状态切换回保存的EUID值（通过`seteuid(2)`系统调用）；因此，最初保存的EUID被称为**保存的ID**。
- en: In effect, we can on demand switch back and forth between a privileged and unprivileged
    state for our process!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以随时在我们的进程之间切换特权和非特权状态！
- en: After we cover a bit more material, an example will help make things clear.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们涵盖了更多的材料之后，一个例子将有助于澄清事情。
- en: Setting the process credentials
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置进程凭证
- en: 'We know that, from the shell, a convenient way of looking up who we are currently
    running as is to run the simple `id(1)` command; it displays the real UID and
    real GID (as well as all supplementary groups we belong to). As we have done earlier,
    let''s try it out while logged in as the user `seawolf`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，从shell中，查看当前运行的用户是谁的一个方便的方法是运行简单的`id(1)`命令；它会显示真实的UID和真实的GID（以及我们所属的所有附加组）。就像我们之前做的那样，让我们在用户`seawolf`登录时尝试一下：
- en: '[PRE30]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Consider again the `sudo(8)` utility; to run a program as another user, not
    as root, we can use the `-u` or `--user=` switch to `sudo`. For example, let''s
    run the `id(1)` program as the user `mail`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑`sudo(8)`实用程序；要以另一个用户而不是root身份运行程序，我们可以使用`-u`或`--user=`开关来使用`sudo`。例如，让我们以用户`mail`的身份运行`id(1)`程序：
- en: '[PRE31]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As expected, once we provide the correct password, `sudo` runs the `id` program
    as the mail user, and the output of id now shows us that the (real) user and group
    IDs are now that of the mail user account! (not seawolf), precisely the effect
    expected.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的是，一旦我们提供正确的密码，`sudo`就会以邮件用户的身份运行`id`程序，`id`的输出现在显示我们的（真实）用户和组ID现在是邮件用户账户的！（而不是seawolf），这正是预期的效果。
- en: But how did `sudo(8)` do this? We understood from the previous section that,
    when you run sudo (with whatever parameters), it, initially at least, always runs
    as root. Now the question is, how does it run with the credentials of another
    user account?
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 但`sudo(8)`是如何做到的呢？我们从前一节了解到，当运行`sudo`（无论带有什么参数），它至少最初总是以root身份运行。现在的问题是，它如何以另一个用户账户的凭证运行？
- en: 'The answer: several system calls exist that let you change the process privileges
    (the RUID, EUID, RGID, EGID): `setuid(2)`, `seteuid(2)`, `setreuid(2)`, `setresuid(2)`
    and all their analogs for the GID.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是：存在几个系统调用可以改变进程的特权（RUID、EUID、RGID、EGID）：`setuid(2)`、`seteuid(2)`、`setreuid(2)`、`setresuid(2)`以及它们的GID对应的函数。
- en: 'Let''s take a quick look at the API signatures:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下API签名：
- en: '[PRE32]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `setuid(2)` system call allows a process to set its EUID to the value passed.
    If the process has root privileges (later in the next chapter, we shall qualify
    statements such as this a lot better, when we learn about the POSIX capabilities
    model), then the RUID and saved-setuid (explained shortly) are also set to this
    value.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuid(2)`系统调用允许进程将其EUID设置为传递的值。如果进程具有root权限（稍后在下一章中，当我们了解POSIX能力模型时，我们将更好地限定这样的陈述），那么RUID和保存的setuid（稍后解释）也将设置为这个值。'
- en: All the `set*gid()` calls are analogous to their UID counterparts.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`set*gid()`调用都类似于它们的UID对应物。
- en: On the Linux OS, the seteuid and setegid APIs, though documented as system calls,
    are actually wrappers over the `setreuid(2)` and `setregid(2)` system calls.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux操作系统上，seteuid和setegid API，虽然被记录为系统调用，实际上是`setreuid(2)`和`setregid(2)`系统调用的包装器。
- en: Hacking attempt 2
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黑客攻击尝试2
- en: Ah, hacking! Well, let's at least attempt to.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，黑客攻击！好吧，至少让我们试一试。
- en: We know that `EUID 0` is a special value—it means we have root privilege. Think
    about it—we have a setuid(2) system call. So, even if we're unprivileged, why
    not just do a quick
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`EUID 0`是一个特殊值——它意味着我们拥有root权限。想想看——我们有一个`setuid(2)`系统调用。所以，即使我们没有特权，为什么不快速地做一个
- en: '`setuid(0);` become privileged, and hack away as root!'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuid(0);`变得特权，并像root一样黑客攻击！'
- en: 'Hmm, Linux wouldn''t be a very powerful and popular OS if the above hack were
    to actually work. It won''t work, folks: the above system call invocation would
    fail returning `-1`; `errno` would be set to `EPERM` and the error message (from
    `perror(3)` or `strerror(3)`) would be this: Operation not permitted.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，如果上面的黑客攻击真的奏效，Linux就不会成为一个非常强大和受欢迎的操作系统。它不会奏效，朋友们：上面的系统调用调用将失败返回`-1`；`errno`将被设置为`EPERM`，错误消息（来自`perror(3)`或`strerror(3)`）将是这样的：操作不允许。
- en: 'Why is this? There''s a simple rule within the kernel: an unprivileged process
    can set its effective IDs to its real IDs—no other value is allowed. In other
    words, an unprivileged process can set  the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么呢？在内核中有一个简单的规则：一个非特权进程可以将其有效ID设置为其真实ID，不允许其他值。换句话说，一个非特权进程可以设置以下内容：
- en: Its EUID to its RUID
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的EUID到它的RUID
- en: Its EGID to its RGID
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的EGID到它的RGID
- en: That's it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。
- en: Of course, a (root) privileged process can set its four credentials to any value
    it chooses. There is no surprise there—this is part and parcel of the power of
    being root.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，（root）特权进程可以将其四个凭据设置为任何它选择的值。这并不奇怪——这是作为root的权力的一部分。
- en: The `seteuid(2)` sets the process effective userid to the value passed; for
    an unprivileged process, it can only set its EUID to its RUID, the EUID, or the
    saved setuid.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`seteuid(2)`将进程的有效用户ID设置为传递的值；对于一个非特权进程，它只能将其EUID设置为其RUID，EUID或保存的setuid。'
- en: The `setreuid(2)` sets the real and effective UIDs to the values passed respectively;
    if `-1` is passed, the corresponding value is left untouched. (This can indirectly
    affect the saved-set value.) The `set[r]egid(2)` calls are identical with respect
    to the group IDs.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`setreuid(2)`将真实和有效的UID分别设置为传递的值；如果传递了`-1`，则相应的值将保持不变。（这可能间接影响保存的值。）`set[r]egid(2)`调用在组ID方面是相同的。'
- en: 'Let''s be empirical and try out what we just talked about:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实际操作一下我们刚刚谈到的内容：
- en: '[PRE33]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Build and run it. This screenshot shows us a virtual machine seawolf, along
    with an `ssh`-connected Terminal window in the lower right (where we''re logged
    in as the user seawolf); see the `rootsh_hack2` program running there:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行它。这个屏幕截图显示了一个名为seawolf的虚拟机，以及右下角的一个`ssh`连接的终端窗口（我们以用户seawolf的身份登录）；看到`rootsh_hack2`程序正在那里运行：
- en: '![](img/d3dee453-cdca-432e-a761-cb3fe1bfbcc6.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d3dee453-cdca-432e-a761-cb3fe1bfbcc6.png)'
- en: 'Studying the output of the `ssh` terminal window in the preceding screenshot,
    we can see the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 研究前面屏幕截图中`ssh`终端窗口的输出，我们可以看到以下内容：
- en: The original bash process (the shell) has the PID 6012.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始的bash进程（shell）的PID是6012。
- en: The id command shows that we're running as (a real) UID = 1000 (which is the
    seawolf user).
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: id命令显示我们正在以（真实的）UID = 1000（即seawolf用户）运行。
- en: 'We run `rootsh_hack2`; clearly, the `setuid(0)` fails; the error message is
    displayed: operation not permitted.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们运行`rootsh_hack2`；显然，`setuid(0)`失败了；显示了错误消息：操作不允许。
- en: Nevertheless, it's just a warning message; execution continues, and the process
    spawns another bash process, in effect, another shell.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管如此，这只是一个警告消息；执行继续进行，进程生成另一个bash进程，实际上是另一个shell。
- en: Its PID is 6726 (proving it's unique from the original shell.)
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的PID是6726（证明它与原始shell不同）。
- en: The id(1) is still 1000, proving we have not really achieved anything significant.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: id(1)仍然是1000，证明我们并没有真正取得什么重大成就。
- en: We exit and are back to our original shell.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们退出，回到我们最初的shell。
- en: 'But what if we (or worse, a hacker) could trick this process into running as
    root!? How? By making it a setuid-root executable of course; then we''re in trouble:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们（或者更糟糕的是，一个黑客）能够欺骗这个进程以root身份运行呢！？怎么做？当然是将其设置为setuid-root可执行文件；然后我们就麻烦了：
- en: '[PRE34]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'So, we just simulate being tricked: here we use sudo(8); we enter the password
    and thus change the binary executable to a setuid-root, a truly dangerous, one.
    It runs, and it spawns what now turns out to be a root shell (notice, the `id(1)`
    command proves this fact); we do a `ps` and then `exit`.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们只是模拟被欺骗：在这里我们使用sudo(8);我们输入密码，从而将二进制可执行文件更改为setuid-root，一个真正危险的程序。它运行，并生成了一个现在被证明是root
    shell的进程（注意，`id(1)`命令证明了这一事实）；我们执行`ps`然后`exit`。
- en: 'It also dawns on us that our previous hacking attempt failed to deliver—the
    system(3) API refused to elevate privileges when a shell was the parameter to
    run—which is great security-wise. But, this hacking attempt (#2) proves that you
    can easily subvert that: just issue a call to `setuid(0)` prior to invoking system
    (`/bin/bash`), and it succeeds in delivering a root shell—of course, if and only
    if the process runs as root in the first place: either via the setuid-root approach
    or by just using sudo(8).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也意识到，我们之前的黑客尝试失败了——当shell作为运行参数时，系统（3）API拒绝提升权限，这在安全方面是很好的。但是，这次黑客尝试（＃2）证明你可以轻松地颠覆这一点：只需在调用system（`/bin/bash`）之前发出`setuid（0）`的调用，它就成功地提供了一个root
    shell——当然，只有在进程首先以root身份运行时才会成功：要么通过setuid-root方法，要么只是使用sudo（8）。
- en: An aside – a script to identify setuid-root and setgid  installed programs
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一边——一个用于识别setuid-root和setgid安装程序的脚本
- en: We now begin to understand that `setuid/setgid` programs might be convenient,
    but from a security viewpoint, they can be potentially dangerous and must be carefully
    audited. The first step in such an audit is finding out whether and where exactly
    these binaries exist on the Linux system.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在开始理解，`setuid/setgid`程序可能很方便，但从安全的角度来看，它们可能是潜在的危险，并且必须仔细审计。这种审计的第一步是找出Linux系统上这些二进制文件是否存在以及确切存在的位置。
- en: To do so, we write a small shell (bash) script; it will identify and show us
    the installed `setuid-root` and `setgid` programs on the system (as usual, you
    can download and try the script from the book's Git repository).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们编写一个小的shell（bash）脚本；它将识别并显示系统上安装的`setuid-root`和`setgid`程序（通常情况下，您可以从书的Git存储库下载并尝试该脚本）。
- en: 'The script performs its work essentially, as shown next (it actually loops
    over an array of directories; for simplicity, we show a direct example of scanning
    the `/bin` directory):'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本基本上执行其工作，如下所示（它实际上循环遍历一个目录数组；为简单起见，我们显示了扫描`/bin`目录的直接示例）：
- en: '[PRE35]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The output of `ls -l` is piped to `grep(1)`, which uses a regular expression
    designed to match a string if the first character is a `-` (a regular file) and
    if the owner execute bit is s—in other words, a setuid file; the `awk(1)` filter
    ensures that only if the owner is root do we print the resultant string to stdout.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls -l`的输出被管道传输到`grep（1）`，它使用一个正则表达式，如果第一个字符是`-`（一个常规文件），并且所有者执行位是s——换句话说，是一个setuid文件；`awk（1）`过滤器确保只有所有者是root时，我们才将结果字符串打印到stdout。'
- en: We run the bash script on two Linux distributions.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在两个Linux发行版上运行bash脚本。
- en: 'On an Ubuntu 17.10 on x86_64:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86_64上的Ubuntu 17.10上：
- en: '[PRE36]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: A system information banner is displayed (so that we can glean system details,
    mostly obtained using the `lsb_release` utility). Then, the script scans through
    various system directories printing out all `setuid-root` and `setgid` binaries
    it finds. Familiar examples, `passwd` and `sudo` are highlighted.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 显示系统信息横幅（以便我们可以获取系统详细信息，主要是使用`lsb_release`实用程序获得的）。然后，脚本扫描各种系统目录，打印出它找到的所有`setuid-root`和`setgid`二进制文件。熟悉的例子，`passwd`和`sudo`被突出显示。
- en: setgid example – wall
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: setgid示例- wall
- en: 'As a great example of `setgid` binaries, take a look at the wall(1) utility,
    reproduced from the script''s output for convenience:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`setgid`二进制文件的一个很好的例子，看看wall（1）实用程序，从脚本的输出中复制：
- en: '[PRE37]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The wall(1) program is used to broadcast any message to all users console (tty)
    devices (typically the sysad will do this). Now, to write to a `tty` device (recall,
    folks, [Chapter 1](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml), *Linux System
    Architecture*, and the if it''s not a process, it''s a file Unix philosophy),
    what permissions do we require? Let''s take the second terminal `tty2` device
    as an example:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: wall（1）程序用于向所有用户控制台（tty）设备广播任何消息（通常由系统管理员执行）。现在，要写入`tty`设备（回想一下，朋友们，[第1章](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml)，*Linux系统架构*，以及如果不是一个进程，它就是一个文件Unix哲学），我们需要什么权限？让我们以第二个终端`tty2`设备为例：
- en: '[PRE38]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can see that to write to the preceding device we either require root or we
    must be a member of the `tty` group. Peek again at the wall(1) utility long listing;
    it's a setgid binary-executable file and the group membership is `tty`; so, when
    anyone runs it, the wall process runs with an effective group ID (EGID) of `tty`
    ! That solves the problem—no code. No fuss.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，要写入前面的设备，我们要么需要root，要么必须是`tty`组的成员。再次查看wall（1）实用程序的长列表；它是一个setgid二进制可执行文件，组成员是`tty`；因此，当任何人运行它时，wall进程将以`tty`的有效组ID（EGID）运行！这解决了问题——没有代码。没有麻烦。
- en: 'Here is a screenshot where wall is used:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个截图，显示了wall的使用：
- en: '![](img/a0736e00-379a-4550-8e77-0709bca6be26.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0736e00-379a-4550-8e77-0709bca6be26.png)'
- en: 'In the foreground, there is an `ssh` connected (to an Ubuntu VM; you can see
    it in the background) terminal window. It issues the `wall` command as a regular
    user: because of the `setgid tty`*,* it works!'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在前台，有一个连接的`ssh`（到Ubuntu VM；您可以在后台看到它）终端窗口。它以常规用户的身份发出`wall`命令：由于`setgid tty`*，*它有效！
- en: 'Now you can run the earlier script on a Fedora 27 on x86_64:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以在x86_64上的Fedora 27上运行之前的脚本：
- en: '[PRE39]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: More setuid-root binaries seem to show up; also, `write(1)` is the equivalent
    (to `wall(1)`) `setgid tty` utility on Fedora.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎出现了更多的setuid-root二进制文件；此外，在Fedora上，`write（1）`是等效于`wall（1）`的`setgid tty`实用程序。
- en: Giving up privileges
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 放弃特权
- en: From the previous discussion, it seems as if the `set*id()` system calls (`setuid(2)`,
    `seteuid(2)`, `setreuid(2)`, `setresuid(2)`) are only useful to root, as only
    with root privileges can we use the system calls to change the process credentials.
    Well, that's not really the full truth; there's another important case, for non-privileged
    processes.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前的讨论中，似乎`set*id()`系统调用（`setuid(2)`，`seteuid(2)`，`setreuid(2)`，`setresuid(2)`）只对root有用，因为只有具有root权限的进程才能使用这些系统调用来更改进程凭据。嗯，这并不是完全的真相；还有另一个重要的情况，适用于非特权进程。
- en: 'Consider this scenario: our program specification requires the initialization
    code to run with root privileges; the rest of the code does not. Obviously, we
    don''t want to give the end user root access just to run our program. How do we
    solve this?'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种情况：我们的程序规范要求初始化代码以root权限运行；其余代码则不需要。显然，我们不希望为了运行我们的程序而给最终用户root访问权限。我们该如何解决这个问题呢？
- en: 'Making the program setuid-root would nicely do the trick. As we''ve seen, a
    setuid-root process will always run as root; but after the initialization work
    is done, we can switch back to the unprivileged normal state. How do we do this?
    Via the `setuid(2)`: recall that setuid for a privileged process sets both the
    EUID and RUID to the value passed; so we pass it the process''s RUID, which we
    obtain via the getuid:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 将程序设置为setuid-root会很好地解决问题。正如我们所看到的，setuid-root进程将始终以root身份运行；但在初始化工作完成后，我们可以切换回非特权正常状态。我们如何做到这一点？通过`setuid(2)`：回想一下，对于特权进程，setuid会将EUID和RUID都设置为传递的值；因此我们将其传递给进程的RUID，这是通过getuid获得的。
- en: '[PRE40]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is a useful semantic (often, the `seteuid(getuid()`) is all we require).
    We use this semantic to become our true selves again—quite philosophical, no?
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的语义（通常，`seteuid(getuid()`)就是我们需要的）。我们使用这个语义来再次成为我们真正的自己——相当哲学，不是吗？
- en: 'In **information security** (**infosec**) circles, there is an important principle
    followed: reduction of the attack surface. Converting a root privileged process
    to become non-privileged (once its work as root is done) helps toward this goal
    (to some extent at least).'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在**信息安全**（**infosec**）领域，有一个重要的原则是：减少攻击面。将根特权进程转换为非特权（一旦其作为根完成工作）有助于实现这一目标（至少在某种程度上）。
- en: Saved-set UID – a quick demo
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存的UID - 一个快速演示
- en: 'In the previous section, we''ve just seen how the useful `seteuid(getuid()`)
    semantic can be used to switch a setuid privileged process to a regular unprivileged
    state (that''s good design and safer). But what if we have this requirement:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们刚刚看到了有用的`seteuid(getuid()`)语义如何用于将setuid特权进程切换到常规非特权状态（这是很好的设计，更安全）。但是如果我们有这个要求呢：
- en: '[PRE41]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: To achieve the must-run-as-root semantic initially, we can of course create
    the program to be a setuid-root program. Then, at time t1, we issue the `setuid(getuid()`)
    giving up root privileges.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现最初必须以root身份运行的语义，我们当然可以创建程序为setuid-root程序。然后，在t1时，我们发出`setuid(getuid()`)放弃root权限。
- en: 'But how do we regain root privileges at time t2? Ah, that''s where the saved-setuid
    feature becomes precious. What''s more, it''s easy to do; here is the pseudo-code
    to achieve this scenario:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何在t2时重新获得root权限呢？啊，这就是保存的setuid功能变得宝贵的地方。而且，这样做很容易；以下是实现这种情况的伪代码：
- en: '[PRE42]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We demonstrate the same with an actual C code next. Note that for the demo
    to work as expected, the user must make the binary executable file into a setuid-root
    binary by doing this:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来用实际的C代码来演示相同的情况。请注意，为了使演示按预期工作，用户必须通过以下方式将二进制可执行文件变成setuid-root二进制文件：
- en: '[PRE43]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following code  checks that, at the beginning, the process is indeed running
    as root; if not, it aborts with a message asking the user to make the binary a
    setuid-root binary:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码检查了在开始时，进程确实是以root身份运行的；如果不是，它将中止并显示一条消息，要求用户将二进制文件设置为setuid-root二进制文件：
- en: '[PRE44]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here is a sample run:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个样本运行：
- en: '[PRE45]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The program fails as it detects that it's not running effectively as root in
    the beginning, implying that it's not a setuid-root binary executable in the first
    place. So, of course, we must make it a setuid-root binary executable by doing
    the `sudo chown ...` followed by the `sudo chmod ...` . (Notice how we've kept
    the code to do so in the Makefile but have commented it out, so that you, the
    reader, can get some practice).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 程序失败了，因为它检测到在开始时并没有有效地以root身份运行，这意味着它一开始就不是一个setuid-root二进制可执行文件。因此，我们必须通过`sudo
    chown ...`然后`sudo chmod ...`来使其成为setuid-root二进制可执行文件。（请注意，我们已经将执行此操作的代码放在了Makefile中，但已经将其注释掉，这样你作为读者就可以练习一下）。
- en: 'This screenshot shows that once we do this, it runs as expected, switching
    back and forth between the privileged and unprivileged states:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这个截图显示了一旦我们这样做，它会按预期运行，在特权和非特权状态之间来回切换：
- en: '![](img/fda744b4-4daa-439c-b624-92f428e976c7.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fda744b4-4daa-439c-b624-92f428e976c7.png)'
- en: Notice how the really crucial system call to switch back and forth is, after
    all, the setuid(2); also notice how the EUID changes at different points in time
    (from 0 at t0, to 1000 at t1, again to 0 at t2 and finally back to 1000 at t3).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，真正关键的系统调用来回切换，毕竟是setuid(2)；还要注意EUID在不同时间点的变化（从t0的0到t1的1000，再到t2的0，最后在t3回到1000）。
- en: 'Also note that, to provide interesting examples, we have been mostly using
    setuid-root binaries. You need not: making the file owner someone else (such as
    the mail user) would then in effect make it a setuid-mail binary executable, meaning
    that, when run, the process RUID would be the usual 1000 (seawolf), but the EUID
    would be that of the mail user''s RUID.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，为了提供有趣的例子，我们大多数情况下使用的是setuid-root二进制文件。你不需要这样做：将文件所有者更改为其他人（比如邮件用户），实际上会使其成为一个setuid-mail二进制可执行文件，这意味着当运行时，进程RUID将是通常的1000（seawolf），但EUID将是邮件用户的RUID。
- en: The setres[u|g]id(2) system calls
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: setres[u|g]id(2)系统调用
- en: 'Here are a couple of wrapper calls—the `setresuid(2)` and the `setresgid(2)`;
    their signatures:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一对包装调用 - `setresuid(2)`和`setresgid(2)`；它们的签名：
- en: '[PRE46]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This pair of system calls is like a superset of the earlier `set*id()` APIs.
    With the `setresuid(2)` system call, a process can set the RUID, EUID, and saved-set-id
    all at once, with a single system call (the **res** in the system call name stands
    for **real**, **effective**, and **saved**-set-ID, respectively).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这对系统调用就像是早期的`set*id()`API的超集。使用`setresuid(2)`系统调用，进程可以一次性设置RUID、EUID和保存的set-id，只需一个系统调用（系统调用名称中的**res**代表**real**、**effective**和**saved**-set-ID）。
- en: A non-privileged (meaning, non-root) process can only use this system call to
    set the three IDs to one of the current RUID, the current EUID, or the current
    saved-set UID, nothing else (the usual security principle at work). Passing `-1`
    implies to leave the corresponding value unchanged. A privileged (root) process
    can use the call to set the three IDs to any values, of course. (As usual, the
    `setresgid(2)` system call is identical except that it sets group credentials).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 非特权（即非root）进程只能使用此系统调用将三个ID之一设置为当前RUID、当前EUID或当前保存的UID，没有其他选项（通常的安全原则在起作用）。传递`-1`意味着保持相应的值不变。特权（root）进程当然可以使用调用将三个ID设置为任何值。（通常情况下，`setresgid(2)`系统调用是相同的，只是它设置组凭据）。
- en: Some real-world OSS projects indeed use this system call; good examples are
    the OpenSSH project (the Linux port is called OpenSSH-portable) and the well-known sudo(8)
    utility.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 一些真实的开源软件项目确实使用了这个系统调用；OpenSSH项目（Linux端口称为OpenSSH-portable）和著名的sudo(8)实用程序就是很好的例子。
- en: 'OpenSSH: from its git repository here: [https://github.com/openssh/openssh-portable/](https://github.com/openssh/openssh-portable/)
    :'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSH：来自其git存储库：[https://github.com/openssh/openssh-portable/](https://github.com/openssh/openssh-portable/)：
- en: '`uidswap.c`: `permanently_drop_suid():`'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`uidswap.c`：`permanently_drop_suid():`'
- en: '[PRE47]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It's interesting to notice the effort taken to ensure that the UID drop was
    successful—more on this next!
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是注意到确保UID降级成功所付出的努力——接下来会更多地讨论这一点！
- en: 'Performing an `strace(1)` on sudo(8) (notice we have to trace it as root, as
    attempting to strace a setuid program as a regular user does not work as, while
    tracing, the setuid bit is deliberately ignored; this output is from an Ubuntu
    Linux system):'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 对sudo(8)执行`strace(1)`（请注意，我们必须以root身份跟踪它，因为尝试以普通用户身份跟踪setuid程序时不起作用，因为在跟踪时，setuid位被故意忽略；此输出来自Ubuntu
    Linux系统）：
- en: '[PRE48]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Clearly, sudo uses the `setresuid(2)` system call to set permissions, credentials,
    really, as appropriate (in the preceding example, the process EUID is being set
    to that of the mail user, the RUID and saved-set-id are being left unchanged).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，sudo使用`setresuid(2)`系统调用来设置权限、凭据，确实是适当的（在上面的示例中，进程EUID被设置为邮件用户的EUID，RUID和保存的ID被保持不变）。
- en: Important security notes
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要的安全注意事项
- en: 'Here are a few key points to keep in mind, with regard to security:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关于安全性的关键要点：
- en: The use of setuid binaries, if poorly designed, is a security risk. Particularly
    and especially for setuid-root programs, they should be designed and tested to
    ensure that, while the process is in an elevated privileged state, it never spawns
    a shell or blindly accepts user commands (which are then internally executed).
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果设计不当，使用setuid二进制文件是一种安全风险。特别是对于setuid-root程序，它们应该被设计和测试，以确保在进程处于提升的特权状态时，它永远不会生成一个shell或盲目接受用户命令（然后在内部执行）。
- en: You must check the failure case of any of the `set*id()` system calls `(setuid(2)`,
    `seteuid(2)`, `setreuid(2)`, `setresuid(2)`).
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须检查任何`set*id()`系统调用（`setuid(2)`、`seteuid(2)`、`setreuid(2)`、`setresuid(2)`）的失败情况。
- en: 'Consider this pseudo-code:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个伪代码：
- en: '[PRE49]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Think about this: what if the preceding `setuid(getuid())` call failed (for
    whatever reason) and we did not check? The remaining work would continue to run
    with root access, very possibly courting disaster! (See the sample code from the
    OpenSSH-portable Git repo for a real-world example of careful checking.) Let''s
    take a look at the following points:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 思考一下：如果前面的`setuid(getuid())`调用失败了（无论什么原因），而我们没有检查呢？剩下的工作将继续以root访问权限运行，很可能会招致灾难！（请参阅OpenSSH-portable
    Git存储库中的示例代码，了解仔细检查的真实示例。）让我们看看以下几点：
- en: 'The `setuid(2)` system call is deficient in a sense: if the real UID is root,
    then the saved-set UID is also root; hence, you cannot drop privileges! Obviously,
    this can be dangerous for setuid-root applications and the like. As an alternative,
    use the `setreuid(2)` API to have a root process temporarily drop privileges and
    regain them later (by swapping their RUID and EUID values).'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setuid(2)`系统调用在某种意义上是有缺陷的：如果真实UID是root，那么保存的UID也是root；因此，您无法放弃权限！显然，这对于setuid-root应用程序等来说是危险的。作为替代方案，使用`setreuid(2)`
    API使根进程暂时放弃权限，并稍后重新获得（通过交换它们的RUID和EUID值）。'
- en: Even if you have system administrator (root) access, you should never log in
    as root! You could be (quite easily) tricked into running dangerous programs as
    root (hackers routinely use this technique to install rootkits onto a system;
    once successful, do consider your system compromised).
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使您拥有系统管理员（root）访问权限，也不应该以root身份登录！您可能会（非常容易地）被欺骗以root身份运行危险程序（黑客经常使用这种技术在系统上安装rootkit；一旦成功，确实会考虑您的系统已被入侵）。
- en: 'When a process creates a shared object (say a file), who will own it and what
    will the group be? In other words, what values will the kernel set in the file''s
    inode metadata structure for UID and GID? The answer is this: the file UID will
    be the creator process''s EUID, and the file GID (group membership) will be the
    creator process''s EGID. This will have a subsequent effect on permissions.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个进程创建一个共享对象（比如一个文件）时，它将由谁拥有，组将是什么？换句话说，内核将在文件的inode元数据结构中设置什么值作为UID和GID？答案是：文件的UID将是创建进程的EUID，文件的GID（组成员资格）将是创建进程的EGID。这将对权限产生后续影响。
- en: We recommend that you, the reader, definitely read [Chapter 9](3b2340aa-4ab7-46e3-93c0-7f7c210f834b.xhtml),
    *Process Execution*, as well! In it, we show how the traditional permissions model
    is flawed in many respects, and why and how you should use the superior Linux
    Capabilities model.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您，读者，一定要阅读[第9章](3b2340aa-4ab7-46e3-93c0-7f7c210f834b.xhtml)，*进程执行*！在其中，我们展示了传统权限模型在许多方面存在缺陷，以及为什么以及如何使用更优越的Linux
    Capabilities模型。
- en: Summary
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, the reader has been taken through many important ideas on the
    design and implementation of the traditional Unix security model. Among other
    things, we have covered the traditional Unix permission model, the concepts of
    process real and effective IDs, APIs to query and set them, `sudo(8)`, saved-set
    IDs.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，读者已经了解了关于传统Unix安全模型设计和实施的许多重要观念。除此之外，我们还涵盖了传统Unix权限模型、进程真实和有效ID的概念、用于查询和设置它们的API、`sudo(8)`、保存的ID集。
- en: 'Again, it bears repeating: we definitely recommend you also read the following
    [Chapter 8](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml), *Process Capabilities*!
    In it, we show how the traditional permissions model is flawed, and how you should
    use the superior, modern Linux Capabilities model.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调：我们强烈建议您也阅读以下内容[第8章]，*进程能力*！在其中，我们展示了传统权限模型存在缺陷，以及您应该使用更优越、现代的Linux能力模型。
