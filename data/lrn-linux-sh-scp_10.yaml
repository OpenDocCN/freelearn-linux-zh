- en: Regular Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: This chapter introduces regular expressions, and the main commands that we can
    use to leverage their power. We'll first look at the theory behind regular expressions,
    before moving deeper into practical examples of using regular expressions with
    `grep` and `sed`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了正则表达式以及我们可以用来利用其功能的主要命令。我们将首先了解正则表达式背后的理论，然后深入到使用`grep`和`sed`的正则表达式的实际示例中。
- en: We will also explain globbing, and how it is used on the command line.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将解释通配符及其在命令行上的使用方式。
- en: 'The following commands will be introduced in this chapter: `grep`, `set`, `egrep`,
    and `sed`.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍以下命令：`grep`、`set`、`egrep`和`sed`。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What are regular expressions?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是正则表达式？
- en: Globbing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通配符
- en: Using regular expressions with `egrep` and `sed`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`egrep`和`sed`的正则表达式
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All scripts for this chapter can be found on GitHub: [https://github.com/tammert/learn-linux-shell-scripting/tree/master/chapter_10](https://github.com/tammert/learn-linux-shell-scripting/tree/master/chapter_10).
    Other than this, the Ubuntu virtual machine is still our way of testing and running
    the scripts in this chapter.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有脚本都可以在GitHub上找到：[https://github.com/tammert/learn-linux-shell-scripting/tree/master/chapter_10](https://github.com/tammert/learn-linux-shell-scripting/tree/master/chapter_10)。除此之外，Ubuntu虚拟机仍然是我们在本章中测试和运行脚本的方式。
- en: Introducing regular expressions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍正则表达式
- en: You might have heard the term *regular expression*, or *regex*, before. For
    many people, a regular expression is something that seems very complicated, and
    is often plucked somewhere from the internet or a textbook, without fully grasping
    what it does.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能以前听说过*正则表达式*或*regex*这个术语。对于许多人来说，正则表达式似乎非常复杂，通常是从互联网或教科书中摘取的，而没有完全掌握它的作用。
- en: While that is fine for completing a set task, understanding regular expressions
    better than the average systems administrator really allows you to differentiate
    yourself, both in creating scripts and working on the Terminal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对于完成一项任务来说是可以的，但是比普通系统管理员更好地理解正则表达式可以让你在创建脚本和在终端上工作时脱颖而出。
- en: A nicely tailored regular expression can really help you keep your scripts short,
    simple, and robust to changes in the future.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个精心设计的正则表达式可以帮助您保持脚本简短、简单，并且能够适应未来的变化。
- en: What is a regular expression?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是正则表达式？
- en: In essence, a regular expression is a *piece of text* that functions as a *search
    pattern* for other text. Regular expressions make it possible to easily say, for
    example, that I want to select all lines that contain a word that is five characters
    in length, or look for all files that end in `.log`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，正则表达式是一段*文本*，它作为其他文本的*搜索模式*。正则表达式使得很容易地说，例如，我想选择所有包含五个字符的单词的行，或者查找所有以`.log`结尾的文件。
- en: An example might help with your understanding. First, we need a command that
    we can use to explore regular expressions. The most famous command used in Linux
    with regular expressions is `grep`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例可能有助于您的理解。首先，我们需要一个可以用来探索正则表达式的命令。在Linux中与正则表达式一起使用的最著名的命令是`grep`。
- en: '`grep` is an acronym meaning ***g**lobal **r**egular **e**xpression **p**rint*.
    As you can see, this seems like a good candidate for explaining the concept!'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`是一个缩写，意思是***g**lobal **r**egular **e**xpression **p**rint*。您可以看到，这似乎是解释这个概念的一个很好的候选者！'
- en: grep
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: grep
- en: 'We are going to dive right in as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按以下方式立即深入：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First of all, let''s explore the basic functionality of `grep`, before we move
    on to regular expressions. What `grep` does is really simple, as stated in `man
    grep`: *print lines matching a pattern*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们探索`grep`的基本功能，然后再深入到正则表达式。`grep`的功能非常简单，如`man grep`中所述：*打印匹配模式的行*。
- en: In the preceding example, we created a file with some sentences. Some of these
    start with capital letters; they mostly end differently; and they use some words
    that are similar, but not really the same. These and more characteristics will
    be used in further examples.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个包含一些句子的文件。其中一些以大写字母开头；它们大多以不同的方式结束；它们使用一些相似但不完全相同的单词。这些特征以及更多特征将在后续示例中使用。
- en: 'To start, we use `grep` to match a single word (the search is case-sensitive
    by default), and print that. `grep` has two operating modes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`grep`来匹配一个单词（默认情况下搜索区分大小写），并打印出来。`grep`有两种操作模式：
- en: '`grep <pattern> <file>`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep <pattern> <file>`'
- en: '`grep <pattern>` (which needs input in the form of a pipe, or `|`)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep <pattern>`（需要以管道或`|`的形式输入）'
- en: The first operating mode lets you specify a filename from which you want to
    specify the lines that need to be printed, if they match the pattern you specify.
    The `grep 'cool' grep-file.txt` command is an example of this.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种操作模式允许您指定一个文件名，从中您想要指定需要打印的行，如果它们匹配您指定的模式。`grep 'cool' grep-file.txt`命令就是一个例子。
- en: 'There is another way of using `grep`: in streams. A stream is something *in
    transit* to your Terminal, but which can be changed while on the move. In this
    case, a `cat` of the file would normally print all lines to your Terminal.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种使用`grep`的方式：在流中。流是指*在传输中*到达您的终端的东西，但在移动过程中可以被更改。在这种情况下，对文件的`cat`通常会将所有行打印到您的终端上。
- en: However, with the pipe symbol (`|`) we redirect the output of `cat` to `grep`;
    in this case, we only need to specify the pattern to match. Any line that does
    not match will be discarded, and will not be shown in your Terminal.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过管道符号（`|`），我们将`cat`的输出重定向到`grep`；在这种情况下，我们只需要指定要匹配的模式。任何不匹配的行将被丢弃，并且不会显示在您的终端上。
- en: As you can see, the full syntax for this is `cat grep-file.txt | grep 'USA'`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，完整的语法是`cat grep-file.txt | grep 'USA'`。
- en: Piping is a form of redirection that we will further discuss in [Chapter 12](15141e02-be0c-4709-90f4-a172809217c4.xhtml),
    *Using Pipes and Redirection in Scripts*. For now, keep in mind that by using
    the pipe, the *output* of `cat` is used as *input* for `grep`, in the same manner
    as the filename is used as input. While discussing `grep`, we will (for now) use
    the method explained first, which does not use redirection.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是一种重定向形式，我们将在[第12章](15141e02-be0c-4709-90f4-a172809217c4.xhtml)中进一步讨论，*在脚本中使用管道和重定向*。现在要记住的是，通过使用管道，`cat`的*输出*被用作`grep`的*输入*，方式与文件名被用作输入相同。在讨论`grep`时，我们（暂时）将使用首先解释的不使用重定向的方法。
- en: 'Because the words *cool* and *USA* are only found in a single line, both instances
    of `grep` print just that line. But if a word is found in multiple lines, all
    of them are printed in the order `grep` encounters them (which is normally from
    top to bottom):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因为单词*cool*和*USA*只在一行中找到，所以`grep`的两个实例都只打印那一行。但是如果一个单词在多行中找到，`grep`会按照它们遇到的顺序（通常是从上到下）打印它们：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With `grep`, it is possible to specify that instead of the default case-sensitive
    approach, we would like the search to be case-insensitive. This is, for example,
    a great way of finding errors in a log file. Some programs use the word *error*,
    others *ERROR*, and we''ve even come across the occasional *Error*. All of these
    results can be returned by supplying the `-i` flag to `grep`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`grep`，可以指定我们希望搜索是不区分大小写的，而不是默认的区分大小写的方法。例如，这是在日志文件中查找错误的一个很好的方法。一些程序使用单词*error*，其他使用*ERROR*，我们甚至偶尔会遇到*Error*。通过向`grep`提供`-i`标志，所有这些结果都可以返回：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By supplying `-i`, we see now that both 'regular*'* and 'Regular*'* have been
    matched, and their lines have been printed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供`-i`，我们现在看到了*regular*和*Regular*都已经匹配，并且它们的行已经被打印出来。
- en: Greediness
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 贪婪性
- en: 'By default, regular expressions are considered greedy. This might seem a strange
    term to describe a technical concept, but it does fit really well. To illustrate
    why regular expressions are considered greedy, look at this example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，正则表达式被认为是贪婪的。这可能看起来是一个奇怪的术语来描述一个技术概念，但它确实非常合适。为了说明为什么正则表达式被认为是贪婪的，看看这个例子：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, `grep` does not by default look for full words. It looks at
    the characters in the file, and if a string matches the search (regardless of
    what comes before or after them), the line is printed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`grep`默认情况下不会寻找完整的单词。它查看文件中的字符，如果一个字符串匹配搜索（不管它们之前或之后是什么），那么该行就会被打印出来。
- en: In the first example, `in` matches both the normal word **in**, but also test**in**g.
    In the second example, both lines have two matches, both **the** and **the**y.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，`in`匹配了正常的单词**in**，但也匹配了test**in**g。在第二个例子中，两行都有两个匹配项，**the**和**the**y。
- en: 'If you want to return whole words only, be sure to include the spaces in your
    `grep` search pattern:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想返回整个单词，请确保在`grep`搜索模式中包含空格：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the search for `' in '` now does not return the line with the
    word **testing**, since the string of characters **in** isn't surrounded by spaces
    there.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，现在对' in '的搜索并没有返回包含单词**testing**的行，因为字符**in**没有被空格包围。
- en: A regular expression is just a definition of a particular search pattern, which
    is implemented differently by individual scripting/programming languages. The
    regular expressions we are using with Bash are different from those in Perl or
    Java, for example. While in some languages, greediness can be tuned or even turned
    off, regular expressions under `grep` and `sed` are always greedy. This is not
    really an issue, just something to consider when defining your search patterns.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式只是一个特定搜索模式的定义，它在个别脚本/编程语言中的实现方式是不同的。我们在Bash中使用的正则表达式与Perl或Java中使用的不同。在一些语言中，贪婪性可以被调整甚至关闭，但是`grep`和`sed`下的正则表达式总是贪婪的。这并不是一个问题，只是在定义搜索模式时需要考虑的事情。
- en: Character matching
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符匹配
- en: We now know how we can search for whole words, even if we're not entirely sure
    about uppercase and lowercase yet.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了如何搜索整个单词，即使我们对大写和小写不是很确定。
- en: We've also seen that regular expressions under (most) Linux applications are
    greedy, so we need to be sure that we're dealing with this properly by specifying
    whitespace and character anchors, which we will explain shortly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到，（大多数）Linux应用程序下的正则表达式是贪婪的，因此我们需要确保通过指定空格和字符锚点来正确处理这一点，我们将很快解释。
- en: In both these cases, we knew what we were looking for. But what if we do not
    really know what we are looking for, or perhaps only part of it? The answer to
    this dilemma is character matching.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们知道我们在寻找什么。但是如果我们真的不知道我们在寻找什么，或者可能只知道一部分呢？这个困境的答案是字符匹配。
- en: 'In regular expressions, there are two characters we can use as substitutes
    for other characters:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式中，有两个字符可以用作其他字符的替代品：
- en: '`.` (dot) matches any one character (except a newline)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.`（点）匹配任何一个字符（除了换行符）'
- en: '`*` (asterisk) matches any number of repeats of the character before (even
    zero instances)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`（星号）匹配前面字符的任意重复次数（甚至零次）'
- en: 'An example will help in understanding this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子将有助于理解这一点：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A lot of things happened there, some of which may feel very counter-intuitive.
    We''ll walk through them one by one and go into detail on what is happening:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里发生了很多事情，其中一些可能会感觉非常违反直觉。我们将逐一讨论它们，并详细说明发生了什么：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we use the dot to substitute for *any character*. As we can
    see, this includes both letters (e**e**e) and numbers (e**2**e). However, it also
    matches the space character between the two es on the last line.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用点来替代*任何字符*。正如我们所看到的，这包括字母（e**e**e）和数字（e**2**e）。但是，它也匹配了最后一行上两个e之间的空格字符。
- en: 'Here''s another example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When we use the `*` substitution, we''re looking for **zero or more** instances
    of the preceding character. In the search pattern `aaa*`, this means the following
    strings are valid:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`*`替代时，我们正在寻找**零个或多个**前面的字符。在搜索模式`aaa*`中，这意味着以下字符串是有效的：
- en: '`aa`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aa`'
- en: '`aaa`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aaa`'
- en: '`aaaa`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aaaa`'
- en: '`aaaaa`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aaaaa`'
- en: '... and so on. While everything after the first result should be clear, why
    does `aa` also match `aaa*`? Because of the zero in *zero or more!* In that case,
    if the last `a` is zero, we''re left with only `aa`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '...等等。在第一个结果之后的一切都应该是清楚的，为什么`aa`也匹配`aaa*`呢？因为*零或更多*中的零！在这种情况下，如果最后的`a`是零，我们只剩下`aa`。'
- en: 'The same thing happens in the last example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个例子中发生了同样的事情：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The pattern `aab*` matches the aa within **aa**a, since the `b*` can be zero,
    which makes the pattern end up as `aa`. Of course, it also matches one or more
    bs (`aabb` is fully matched).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 模式`aab*`匹配**aa**a中的aa，因为`b*`可以是零，这使得模式最终变成`aa`。当然，它也匹配一个或多个b（`aabb`完全匹配）。
- en: These wildcards are great when you have only a general idea about what you're
    looking for. Sometimes, however, you will have a more specific idea of what you
    need.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对你要找的东西只有一个大概的想法时，这些通配符就非常有用。然而，有时你会对你需要的东西有更具体的想法。
- en: 'In this case, we can use brackets, [...], to narrow our substitution to a certain
    character set. The following example should give you a good idea of how to use
    this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以使用括号[...]来缩小我们的替换范围到某个字符集。以下示例应该让你对如何使用这个有一个很好的想法：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First, we demonstrate using `.` (dot) to replace any character. In this scenario,
    the pattern **f.r** matches both **for** and **far**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们演示使用`.`（点）来替换任何字符。在这种情况下，模式**f.r**匹配**for**和**far**。
- en: Next, we use the bracket notation in `f[ao]r` to convey that we'll accept a
    single character between `f` and `r`, which is in the character set of `ao`. As
    expected, this again returns both **far** and **for**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`f[ao]r`中使用括号表示法，以表明我们将接受一个在`f`和`r`之间的单个字符，它在`ao`的字符集中。不出所料，这又返回了**far**和**for**。
- en: If we do this with the `f[az]r` pattern, we can only match with **far** and
    **fzr**. Since the string `fzr` isn't in our text file (and not a word, obviously),
    we only see the line with **far** printed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用`f[az]r`模式来做这个，我们只能匹配**far**和**fzr**。由于字符串`fzr`不在我们的文本文件中（显然也不是一个单词），我们只看到打印出**far**的那一行。
- en: Next, let's say you wanted to match with a letter, but not a number. If you
    used `.` (dot) to search, as in the first example, this would return both letters
    and numbers. So, you would also get, for example, **f2r** as a match (should that
    be in the file, which it is not).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设你想匹配一个字母，但不是一个数字。如果你使用`.`（点）进行搜索，就像第一个例子中那样，这将返回字母和数字。因此，你也会得到，例如，**f2r**作为匹配（如果它在文件中的话，实际上并不是）。
- en: 'If you used the bracket notation, you could use the following notation: `f[abcdefghijklmnopqrstuvwxyz]r`.
    That matches on any letter, a-z, between `f` and `r`. However, it''s not great
    to type that out on a keyboard (trust me on this).'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用括号表示法，你可以使用以下表示法：`f[abcdefghijklmnopqrstuvwxyz]r`。这匹配`f`和`r`之间的任何字母a-z。然而，在键盘上输入这个并不好（相信我）。
- en: 'Luckily, the creators of POSIX regular expressions introduced a shorthand for
    this: `[a-z]`, as shown in the previous example. We can also use a subset of the
    alphabet, as shown: `f[a-k]r`. Since the letter **o** is not between a and k,
    it does not match on **for**.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，POSIX正则表达式的创建者引入了一个简写：`[a-z]`，就像前面的例子中所示的那样。我们也可以使用字母表的一个子集，如：`f[a-k]r`。由于字母**o**不在a和k之间，它不匹配**for**。
- en: 'A last example demonstrates that this is a powerful, and also practical, pattern:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个例子证明了这是一个强大而实用的模式：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Hopefully, this still all makes sense. Before moving on to line anchors, we're
    going to go one step further by combining notations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这一切仍然是有意义的。在转向行锚之前，我们将进一步结合表示法。
- en: In the preceding example, you see that we can use bracket notation to handle
    some of the differences between American and British English. However, this only
    works when the difference in spelling is a single letter, as with realise/realize.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你看到我们可以使用括号表示法来处理美式英语和英式英语之间的一些差异。然而，这只有在拼写的差异是一个字母时才有效，比如realise/realize。
- en: In the case of color/colour, there is an extra letter we need to deal with.
    This sounds like a case for zero or more, does it not?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在颜色/colour的情况下，有一个额外的字母我们需要处理。这听起来像是一个零或更多的情况，不是吗？
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By using the pattern `colo[u]*r`, we're searching for a line containing a word
    that starts with **colo**, may or may not contain any number of **u**s, and ends
    with an **r**. Since both `color` and `colour` are acceptable for this pattern,
    both lines are printed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用模式`colo[u]*r`，我们搜索包含以**colo**开头的单词的行，可能包含任意数量的**u**，并以**r**结尾。由于`color`和`colour`都适用于这个模式，两行都被打印出来。
- en: 'You might be tempted to use the dot character with the zero-or-more `*` notation.
    However, look closely at what happens in that case:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想要使用点字符和零或更多的`*`表示法。然而，仔细看看在这种情况下会发生什么：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Again, both lines are matched. But, since the second line contains another **r**
    further on, the string `color (and r` is matched, as well as `colour` and `color`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，两行都匹配。但是，由于第二行中包含另一个**r**，所以字符串`color (and r`被匹配，以及`colour`和`color`。
- en: This is a typical instance where the regular expression pattern is too greedy
    for our purposes. While we cannot tell it to be less greedy, there is an option
    in `grep` that lets us only look for single words that match.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的例子，正则表达式模式对我们的目的来说太贪婪了。虽然我们不能告诉它变得不那么贪婪，但`grep`中有一个选项，让我们只寻找匹配的单词。
- en: 'The notation `-w` evaluates whitespaces and line endings/beginnings to find
    only whole words. This is how it is used:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 表示法`-w`评估空格和行尾/行首，以便只找到完整的单词。用法如下：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, only the words `colour` and `color` are matched. Earlier, we put whitespace
    around our word to facilitate this behavior, but as the word `colour` is at the
    end of the line, it is not followed by a whitespace.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只有单词`colour`和`color`被匹配。之前，我们在单词周围放置了空格以促进这种行为，但由于单词`colour`在行尾，它后面没有空格。
- en: Try for yourself and see why enclosing the `colo.*r` search pattern does not
    work with whitespace, but does work with the `-w` option.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 自己尝试一下，看看为什么用`colo.*r`搜索模式括起来不起作用，但使用`-w`选项却起作用。
- en: Some implementations of regular expressions have the `{3}` notation, to supplement
    the `*` notation. In this notation, you can specify exactly how often a pattern
    should be present. The search pattern `[a-z]{3}` would match all lowercase strings
    of exactly three characters. In Linux, this can only be done with extended regular
    expressions, which we will see later in this chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一些正则表达式的实现有`{3}`表示法，用来补充`*`表示法。在这种表示法中，你可以精确指定模式应该出现多少次。搜索模式`[a-z]{3}`将匹配所有恰好三个字符的小写字符串。在Linux中，这只能用扩展的正则表达式来实现，我们将在本章后面看到。
- en: Line anchors
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行锚
- en: We've already briefly mentioned line anchors. With the explanations we have
    presented up until now, we were only able to search for words in a line; we weren't
    yet able to set expectations on *where* those words were in the line. For this,
    we use line anchors.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经简要提到了行锚。根据我们目前为止提出的解释，我们只能在一行中搜索单词；我们还不能设置对单词在行中的位置的期望。为此，我们使用行锚。
- en: 'In regular expressions, the `^` (caret) character signifies the beginning of
    a line, and a `$` (dollar) represents the end of a line. We can use these within
    a search pattern, for example, in the following scenarios:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式中，`^`（插入符）字符表示行的开头，`$`（美元）表示行的结尾。我们可以在搜索模式中使用这些，例如，在以下情况下：
- en: 'Look for the word error, but only at the beginning of a line: `^error`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找单词error，但只在行的开头：`^error`
- en: 'Look for lines ending in a dot: `\.$`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找以句点结尾的行：`\.$`
- en: 'Look for an empty line: `^$`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找空行：`^$`
- en: 'The first usage, looking for something at the beginning of a line, should be
    pretty clear. The following example, which uses `grep -i` (remember, this allows
    us to search without case sensitivity), shows how we can use this to filter by
    line position:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个用法，查找行的开头，应该是很清楚的。下面的例子使用了`grep -i`（记住，这允许我们不区分大小写地搜索），展示了我们如何使用这个来按行位置进行过滤：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the first search pattern, `regular`, we are returned two lines. This is not
    unexpected, since both lines contain the word *regular* (albeit with different
    casing).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个搜索模式`regular`中，我们返回了两行。这并不意外，因为这两行都包含单词*regular*（尽管大小写不同）。
- en: Now, to just select the line that starts with the word *Regular*, we use the
    caret character `^` to form the pattern `^regular`. This only returns the line
    where the word is in the first position on that line. (Note that if we did not
    choose to include `-i` on `grep`, we could have used `[Rr]egular` instead.)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了只选择以单词*Regular*开头的行，我们使用插入符字符`^`来形成模式`^regular`。这只返回单词在该行的第一个位置的行。（请注意，如果我们没有选择在`grep`上包括`-i`，我们可以使用`[Rr]egular`代替。）
- en: The next example, where we look for lines ending in a dot, is a little bit more
    tricky. As you recall, the dot in regular expressions is considered a special
    character; it is a substitute for any other one character. If we use it normally,
    we will see all lines in the file return (since all lines end in *any one character*).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子，我们查找以句点结尾的行，会有点棘手。你会记得，在正则表达式中，句点被认为是一个特殊字符；它是任何其他一个字符的替代。如果我们正常使用它，我们会看到文件中的所有行都返回（因为所有行都以*任何一个字符*结尾）。
- en: 'To actually search for a dot in the text, we need to **escape** the dot by
    prefixing it with a backslash; this tells the regular expression engine to not
    interpret the dot as a special character, but to search for it instead:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际搜索文本中的句点，我们需要**转义**句点，即用反斜杠前缀它；这告诉正则表达式引擎不要将句点解释为特殊字符，而是搜索它：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since the `\` is used to escape special characters, you might encounter a situation
    where you are looking for a backslash in the text. In that case, you can use the
    backslash to escape the special functionality of the backslash! Your pattern will
    be `\\` in this case, which matches with the `\` strings.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`\`用于转义特殊字符，你可能会遇到在文本中寻找反斜杠的情况。在这种情况下，你可以使用反斜杠来转义反斜杠的特殊功能！在这种情况下，你的模式将是`\\`，它与`\`字符串匹配。
- en: In this example, we run into one other issue. So far, we have always quoted
    all patterns with single quotes. However, this isn't always needed! For example,
    `grep cool grep-file.txt` works just as well as `grep 'cool' grep-file.txt`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们遇到了另一个问题。到目前为止，我们总是用单引号引用所有模式。然而，并不总是需要这样！例如，`grep cool grep-file.txt`
    和 `grep 'cool' grep-file.txt` 一样有效。
- en: 'So, why are we doing it? Hint: try the previous example, with the dot line
    endings, without quotes. Then remember that a dollar character in Bash is also
    used to denote variables. If we quote it, the `$` will not be expanded on by Bash,
    which returns problematic results.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们为什么要这样做呢？提示：尝试前面的例子，使用点行结束，不用引号。然后记住，在Bash中，美元符号也用于表示变量。如果我们引用它，Bash将不会扩展`$`，这将返回问题结果。
- en: We will discuss Bash expansion in [Chapter 16](89ec6d77-023a-482a-bd93-23e3945002bf.xhtml),
    *Bash Parameter Substitution and Expansion*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第16章](89ec6d77-023a-482a-bd93-23e3945002bf.xhtml)中讨论Bash扩展，*Bash参数替换和扩展*。
- en: 'Finally, we presented the `^$` pattern. This searches for a line beginning,
    followed directly by a line ending. There is only one situation where that occurs:
    an empty line.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了`^$`模式。这搜索一个行的开头，紧接着一个行的结尾。只有一种情况会发生这种情况：一个空行。
- en: 'To illustrate why you would want to find empty lines, let''s look at a new
    `grep` flag: `-v`. This flag is shorthand for `--invert-match`, which should give
    a nice clue about what it actually does: instead of printing lines that match,
    it prints lines that do not match.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明为什么你想要找到空行，让我们看一个新的`grep`标志：`-v`。这个标志是`--invert-match`的缩写，这应该给出一个关于它实际上做什么的好提示：它打印不匹配的行，而不是匹配的行。
- en: 'By using `grep -v ''^$'' <file name>`, you can print a file without empty lines.
    Give it a go on a random configuration file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`grep -v '^$' <文件名>`，你可以打印一个没有空行的文件。在一个随机的配置文件上试一试：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the `/etc/ssh/ssh_config` file starts with an empty line. Then,
    in between comment blocks, there is another empty line. By using `grep -v '^$'`,
    these empty lines are removed. While this is a nice exercise, this does not really
    save us that many lines.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`/etc/ssh/ssh_config` 文件以一个空行开头。然后，在注释块之间，还有另一行空行。通过使用 `grep -v '^$'`，这些空行被移除了。虽然这是一个不错的练习，但这并没有真正为我们节省多少行。
- en: 'There is, however, one search pattern that is widely used and very powerful:
    filtering out comments from a configuration file. This operation gives us a quick
    overview of what is actually configured, and omits all comments (which have their
    own merit, but can be obstructive when you just want to see which options are
    configured).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个搜索模式是广泛使用且非常强大的：过滤配置文件中的注释。这个操作可以快速概述实际配置了什么，并省略所有注释（尽管注释本身也有其价值，但在你只想看到配置选项时可能会妨碍）。
- en: 'To do this, we combine the beginning-of-line caret with a hashtag, which denotes
    a comment:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将行首的插入符号与井号结合起来，表示注释：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This still prints all empty lines, but no longer prints the comments. In this
    particular file, out of the 51 lines, only four lines contain actual configuration
    directives! All other lines are either empty or contain comments. Pretty cool,
    right?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然打印所有空行，但不再打印注释。在这个特定的文件中，共有 51 行，只有四行包含实际的配置指令！所有其他行要么是空的，要么包含注释。很酷，对吧？
- en: With `grep`, it is also possible to use multiple patterns at the same time.
    By using this, you can combine the filtering of empty lines and comment lines
    for a condensed, quick overview of configuration options. Multiple patterns are
    defined using the `-e` option. The full command in this case is `grep -v -e '^$'
    -e '^#' /etc/ssh/ssh_config`. Try it!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `grep`，也可以同时使用多个模式。通过使用这种方法，可以结合过滤空行和注释行，快速概述配置选项。使用 `-e` 选项定义多个模式。在这种情况下，完整的命令是
    `grep -v -e '^$' -e '^#' /etc/ssh/ssh_config`。试试看！
- en: Character classes
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符类
- en: We've now seen many examples of how to use regular expressions. While most things
    are pretty intuitive, we have also seen that if we want to filter for both uppercase
    and lowercase strings, we'd either have to specify the `-i` option for `grep`,
    or change the search pattern from `[a-z]` to `[a-zA-z]`. For numbers, we would
    need to use `[0-9]`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了许多如何使用正则表达式的示例。虽然大多数事情都很直观，但我们也看到，如果我们想要过滤大写和小写字符串，我们要么必须为 `grep` 指定
    `-i` 选项，要么将搜索模式从 `[a-z]` 更改为 `[a-zA-z]`。对于数字，我们需要使用 `[0-9]`。
- en: 'Some might find this fine to work with, but others might disagree. In this
    case, there is an alternative notation that can be used: `[[:pattern:]]`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能觉得这样工作很好，但其他人可能不同意。在这种情况下，可以使用另一种可用的表示法：`[[:pattern:]]`。
- en: 'The next example uses both this new double bracket notation, and the old single
    bracket one:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子同时使用了这种新的双括号表示法和旧的单括号表示法：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you can see, both patterns result in the same lines: those with a digit.
    The same can be done with uppercase characters:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这两种模式都导致相同的行：包含数字的行。同样的方法也适用于大写字符：
- en: '[PRE19]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'At the end of the day, it is a matter of preference which notation you use.
    There is one thing to be said for the double bracket notation, though: it is much
    closer to implementations of other scripting/programming languages. For example,
    most regular expression implementations use `\w` (word) to select letters, and
    `\d` (digit) to search for digits. In the case of `\w`, the uppercase variant
    is intuitively `\W`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，使用哪种表示法是个人偏好的问题。不过，双括号表示法有一点值得一提：它更接近其他脚本/编程语言的实现。例如，大多数正则表达式实现使用 `\w`（单词）来选择字母，使用
    `\d`（数字）来搜索数字。在 `\w` 的情况下，大写变体直观地是 `\W`。
- en: 'For your convenience, here is a table with the most common POSIX double-bracket
    character classes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，这里是一个包含最常见的 POSIX 双括号字符类的表格：
- en: '| **Notation** | **Description** | **Single bracket equivalent** |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **表示法** | **描述** | **单括号等效** |'
- en: '| `[[:alnum:]]` | Matches lowercase and uppercase letters or digits | [a-z
    A-Z 0-9] |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `[[:alnum:]]` | 匹配小写字母、大写字母或数字 | [a-z A-Z 0-9] |'
- en: '| `[[:alpha:]]` | Matches lowercase and uppercase letters | [a-z A-Z] |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `[[:alpha:]]` | 匹配小写字母和大写字母 | [a-z A-Z] |'
- en: '| `[[:digit:]]` | Matches digits | [0-9] |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `[[:digit:]]` | 匹配数字 | [0-9] |'
- en: '| `[[:lower:]]` | Matches lowercase letters | [a-z] |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `[[:lower:]]` | 匹配小写字母 | [a-z] |'
- en: '| `[[:upper:]]` | Matches uppercase letters | [A-Z] |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `[[:upper:]]` | 匹配大写字母 | [A-Z] |'
- en: '| `[[:blank:]]` | Matches spaces and tabs | [ \t] |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `[[:blank:]]` | 匹配空格和制表符 | [ \t] |'
- en: 'We prefer to use the double bracket notation, as it maps better to other regular
    expression implementations. Feel free to use either in your scripting! However,
    as always: make sure you choose one, and stick with it; not following a standard
    results in sloppy scripts that are confusing to readers. The rest of the examples
    in this book will use the double bracket notation.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更喜欢使用双括号表示法，因为它更好地映射到其他正则表达式实现。在脚本中可以自由选择使用任何一种！但是，一如既往：确保你选择一种，并坚持使用它；不遵循标准会导致令人困惑的杂乱脚本。本书中的其余示例将使用双括号表示法。
- en: Globbing
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通配符
- en: 'We now have the basics of regular expressions under control. There is another
    subject closely related to regular expressions on Linux: *globbing*. Even though
    you probably didn''t realize it, you''ve already seen examples of globbing in
    this book.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经掌握了正则表达式的基础知识。在 Linux 上，还有一个与正则表达式密切相关的主题：*通配符*。即使你可能没有意识到，你在本书中已经看到了通配符的示例。
- en: Even better, there is actually a good chance you've used a *glob pattern* in
    practice. If, when working on the command line, you've ever used the wildcard
    character, `*`, you've been globbing!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，实际上你已经有很大的机会在实践中使用了*通配符模式*。如果在命令行上工作时，你曾经使用通配符字符 `*`，那么你已经在使用通配符！
- en: What is globbing?
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是通配符？
- en: Simply said, a glob pattern describes injecting a wildcard character into a
    file path operation. So, when you do a `cp * /tmp/`, you copy all files (not directories!)
    in the current working directory to the `/tmp/` directory.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说，glob模式描述了将通配符字符注入文件路径操作。所以，当你执行`cp * /tmp/`时，你将当前工作目录中的所有文件（不包括目录！）复制到`/tmp/`目录中。
- en: The `*` expands to all regular files inside the working directory, and then
    all of those are copied to `/tmp/`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`扩展到工作目录中的所有常规文件，然后所有这些文件都被复制到`/tmp/`中。'
- en: 'Here''s a simple example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Instead of executing both `cp grep-file.txt /tmp/` and `cp character-class.txt
    /tmp/`, we used `*` to select both of them. The same glob pattern can be used
    with `rm`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`*`来选择它们两个。相同的glob模式也可以用于`rm`：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By default, `rm` only deletes files and not directories (as you can see from
    the errors in the previous example). As stated in [Chapter 6](371361ae-92fe-4963-82d6-6e65ae450135.xhtml),
    *File Manipulation*, adding a `-r` will delete directories *recursively* too.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`rm`只会删除文件而不是目录（正如你从前面的例子中的错误中看到的）。正如[第6章](371361ae-92fe-4963-82d6-6e65ae450135.xhtml)所述，*文件操作*，添加`-r`将递归地删除目录。
- en: 'Again, do think about how destructive this is: without warning, you could delete
    every file within the current tree location (if you have the permissions, of course).
    The preceding example shows how powerful the `*` glob pattern is: it expands to
    every file it can find, whatever the type.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，请考虑这样做的破坏性：没有警告，你可能会删除当前树位置内的每个文件（当然，如果你有权限的话）。前面的例子展示了`*` glob模式有多么强大：它会扩展到它能找到的每个文件，无论类型如何。
- en: Similarities with regular expressions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与正则表达式的相似之处
- en: As stated, glob commands achieve a similar effect to regular expressions. There
    are some differences though. For example, the `*` character in regular expressions
    stood for *zero or more occurrences of the preceding character*. For globbing,
    it is a wildcard for any and all characters, more similar to the `.*` notation
    of regular expressions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，glob命令实现了与正则表达式类似的效果。不过也有一些区别。例如，正则表达式中的`*`字符代表*前一个字符的零次或多次出现*。对于globbing来说，它是一个通配符，代表任何字符，更类似于正则表达式的`.*`表示。
- en: 'As with regular expressions, a glob pattern can consist of normal characters,
    combined with special characters. Take a look at an example where `ls` is used
    with different arguments/globbing patterns:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与正则表达式一样，glob模式可以由普通字符和特殊字符组合而成。看一个例子，其中`ls`与不同的参数/ globbing模式一起使用：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the `scripts` directory for the previous chapter, we first run a normal `ls
    -l`. As you know, this prints all files in the directory. Now, if we use `ls -l
    *`, we get the exact same result. It would seem that, given an absence of arguments,
    `ls` will inject a wildcard glob for us.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章的`scripts`目录中，我们首先运行了一个普通的`ls -l`。如你所知，这会打印出目录中的所有文件。现在，如果我们使用`ls -l *`，我们会得到完全相同的结果。看起来，鉴于缺少参数，`ls`会为我们注入一个通配符glob。
- en: Next, we use the alternative mode of `ls`, which is where we present a filename
    as the argument. In this case, because filenames are unique for each directory,
    we only see a single line returned.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`ls`的替代模式，其中我们将文件名作为参数。在这种情况下，因为每个目录的文件名是唯一的，我们只会看到返回的单行。
- en: But, what if we wanted all *scripts* (ending in `.sh`) that *start with* `if-`?
    We use the globbing pattern of `if-*.sh`. In this pattern, the `*` wildcard is
    expanded to match, as `man glob` says, *any string, including the empty string*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想要所有以`if-`开头的*scripts*（以`.sh`结尾）呢？我们使用`if-*.sh`的globbing模式。在这个模式中，`*`通配符被扩展为匹配，正如`man
    glob`所说，*任何字符串，包括空字符串*。
- en: More globbing
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多的globbing
- en: 'Globbing is very present in Linux. If you''re dealing with a command that handles
    files (which, under the *everything is a file principle*, is most commands), there
    is a good chance that you can use globbing. To give you an impression of this,
    consider the following examples:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，globbing非常常见。如果你正在处理一个处理文件的命令（根据*一切皆为文件*原则，大多数命令都是如此），那么你很有可能可以使用globbing。为了让你对此有所了解，考虑以下例子：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `cat` command, combined with the wildcard glob pattern, prints the contents
    of **all files** in the current working directory. In this case, since all files
    are ASCII text, this was not really a problem. As you can see, the files are printed
    right after each other; there's not so much as an empty line in between.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`命令与通配符glob模式结合使用，打印出当前工作目录中**所有文件**的内容。在这种情况下，由于所有文件都是ASCII文本，这并不是真正的问题。正如你所看到的，文件都是紧挨在一起打印出来的；它们之间甚至没有空行。'
- en: 'Should you `cat` a binary file, your screen will look something like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你`cat`一个二进制文件，你的屏幕会看起来像这样：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The worst case scenario is that the binary file contains a certain character
    sequence that makes temporary changes to your Bash shell, which will make it unusable
    (yes, this has happened to us many times). The lesson here should be simple: **watch
    out when globbing!**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最糟糕的情况是二进制文件包含某个字符序列，这会对你的Bash shell进行临时更改，使其无法使用（是的，这种情况我们遇到过很多次）。这里的教训应该很简单：**在使用glob时要小心！**
- en: Other commands we've seen up until now that can deal with globbing patterns
    include `chmod`, `chown`, `mv`, `tar`, `grep`, and so on. Perhaps the most interesting
    for now is `grep`. We've used regular expressions with `grep` on a single file,
    but we can also select files using a glob.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的其他命令可以处理globbing模式的命令包括`chmod`、`chown`、`mv`、`tar`、`grep`等等。现在可能最有趣的是`grep`。我们已经在单个文件上使用了正则表达式与`grep`，但我们也可以使用glob来选择文件。
- en: 'Let''s look at the most ridiculous example of `grep` with globbing: finding
    *anything* in *everything*.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个最荒谬的`grep`与globbing的例子：在*everything*中找到*anything*。
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we used the regular expression `.*` search pattern (anything, zero or
    more times) with the glob pattern of `*` (any file). As you might expect, this
    should match every line in every file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了正则表达式`.*`的搜索模式（任何东西，零次或多次）与`*`的glob模式（任何文件）。正如你所期望的那样，这应该匹配每个文件的每一行。
- en: When we use `grep` in this manner, it has pretty much the same functionality
    as the earlier `cat *`. However, when `grep` is used on multiple files, the output
    includes the filename (so you know where the line was found).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以这种方式使用`grep`时，它的功能基本上与之前的`cat *`相同。但是，当`grep`用于多个文件时，输出会包括文件名（这样您就知道找到该行的位置）。
- en: 'Make a note: a globbing pattern is always related to files, whereas a regular
    expression is used *inside* the files, on the actual content. Since the syntax
    is similar, you will probably not be too confused about this, but if you ever
    run into a situation where your pattern is not working as you''d expect, it would
    be good to take a moment and consider whether you''re globbing or regexing!'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意：globbing模式总是与文件相关，而正则表达式是用于*文件内部*，用于实际内容。由于语法相似，您可能不会对此感到太困惑，但如果您曾经遇到过模式不按您的预期工作的情况，那么花点时间考虑一下您是在进行globbing还是正则表达式会很有帮助！
- en: Advanced globbing
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级globbing
- en: Basic globbing is done mainly with the wildcard, sometimes combined with part
    of a filename. However, just as regular expressions allow us to substitute a single
    character, so do globs.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的globbing主要是使用通配符，有时与部分文件名结合使用。然而，正如正则表达式允许我们替换单个字符一样，glob也可以。
- en: 'Regular expressions achieve this with the dot; in globbing patterns, the question
    mark is used:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式通过点来实现这一点；在globbing模式中，问号被使用：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The globbing pattern `if-then-e???.sh` should speak for itself now. Where the
    `?` is present, any character (letter, digit, special character) is a valid substitute.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，globbing模式`if-then-e???.sh`应该不言自明了。在`?`出现的地方，任何字符（字母、数字、特殊字符）都是有效的替代。
- en: 'In the preceding example, all three question marks are replaced by letters.
    As you might have deduced, the regular expression `.` character serves the same
    function as the globbing pattern `?` character: it is valid for exactly one character.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，所有三个问号都被字母替换。正如您可能已经推断出的那样，正则表达式`.`字符与globbing模式`?`字符具有相同的功能：它有效地代表一个字符。
- en: 'Finally, the single bracket notation we use for regular expressions can also
    be used in globbing. A quick example shows how we can use this with `cat`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们用于正则表达式的单括号表示法也可以用于globbing。一个快速的例子展示了我们如何在`cat`中使用它：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Disabling globbing, and other options
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用globbing和其他选项
- en: As powerful as globbing is, this is also what makes it dangerous. For that reason,
    you might want to take drastic measures and turn globbing off. While this is possible,
    we have not seen it in practice. However, for some work or scripts, turning off
    globbing might be a good safeguard.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管globbing功能强大，但这也是它危险的原因。因此，您可能希望采取激烈措施并关闭globbing。虽然这是可能的，但我们并没有在实践中看到过。但是，对于一些工作或脚本，关闭globbing可能是一个很好的保障。
- en: 'Using the `set` command, we can, as the man page states, *change the value
    of a shell option*. In this case, using `-f` will turn off globbing, as we can
    see when we try to repeat our previous example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`set`命令，我们可以像man页面所述那样*更改shell选项的值*。在这种情况下，使用`-f`将关闭globbing，正如我们在尝试重复之前的例子时所看到的：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Options are turned off by prefixing a minus (`-`), and turned on by prefixing
    a plus (`+`). As you might remember, this is not the first time you're using this
    functionality. When we debugged our Bash scripts, we started those not with `bash`,
    but with `bash -x`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在前缀加上减号（`-`）来关闭选项，通过在前缀加上加号（`+`）来打开选项。您可能还记得，这不是您第一次使用这个功能。当我们调试Bash脚本时，我们开始的不是`bash`，而是`bash
    -x`。
- en: 'In this case, the Bash subshell executes a `set -x` command before calling
    the scripts. If you use `set -x` in your current terminal, your commands would
    start to look like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Bash子shell在调用脚本之前执行了`set -x`命令。如果您在当前终端中使用`set -x`，您的命令将开始看起来像这样：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note that we can now see how the globbing pattern is resolved: from `cat p?ng`
    to `cat ping pong`. Try to remember this functionality; if you''re ever at the
    point of pulling your hair out because you have no idea why a script isn''t doing
    what you want, a simple `set -x` might make all the difference! And if it doesn''t,
    you can always revert to normal behavior with `set +x`, as shown in the example.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们现在可以看到globbing模式是如何解析的：从`cat p?ng`到`cat ping pong`。尽量记住这个功能；如果您曾经因为不知道脚本为什么不按照您的意愿执行而抓狂，一个简单的`set
    -x`可能会产生很大的不同！如果不行，您总是可以通过`set +x`恢复正常行为，就像例子中所示的那样。
- en: '`set` has many interesting flags that can make your life easier. To see an
    overview of the capabilities of `set` in your Bash version, use the `help set` command.
    Because `set` is a shell builtin (which you can verify with `type set`), looking
    for a man page with `man set` does not work, unfortunately.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`有许多有趣的标志，可以让您的生活更轻松。要查看您的Bash版本中`set`的功能概述，请使用`help set`命令。因为`set`是一个shell内置命令（您可以用`type
    set`来验证），所以不幸的是，查找`man set`的man页面是行不通的。'
- en: Using regular expressions with egrep and sed
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用egrep和sed的正则表达式
- en: We have now discussed both regular expressions and globbing. As we saw, they
    were very similar, but still had differences to be aware of. In our examples for
    regular expressions, and a little for globbing, we have already seen how `grep`
    can be used.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经讨论了正则表达式和globbing。正如我们所看到的，它们非常相似，但仍然有一些需要注意的区别。在我们的正则表达式示例中，以及一些globbing示例中，我们已经看到了`grep`的用法。
- en: 'In this part, we''ll introduce another command, which is very handy when combined
    with regular expressions: `sed` (not to be confused with `set`). We''ll start
    with some advanced uses for `grep`.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分中，我们将介绍另一个命令，它与正则表达式结合使用时非常方便：`sed`（不要与`set`混淆）。我们将从一些用于`grep`的高级用法开始。
- en: Advanced grep
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级grep
- en: 'We have already discussed a few popular options for `grep` to alter its default
    behavior: `--ignore-case` (`-i`), `--invert-match` (`-v`), and `--word-regexp`
    (`-w`). As a reminder here''s what they do:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了一些用于更改`grep`默认行为的流行选项：`--ignore-case`（`-i`）、`--invert-match`（`-v`）和`--word-regexp`（`-w`）。作为提醒，这是它们的作用：
- en: '`-i` allows us to search case-insensitively'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i`允许我们进行不区分大小写的搜索'
- en: '`-v` only prints lines that are *not* matched, instead of matched lines'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v`只打印*不*匹配的行，而不是匹配的行'
- en: '`-w` only matches on full words that are surrounded by spaces and/or line anchors
    and/or punctuation marks'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-w`只匹配由空格和/或行锚和/或标点符号包围的完整单词'
- en: 'There are three other options we''d like to share with you. The first new option,
    `--only-matching` (`-o`) prints only the matching words. If your search pattern
    does not contain any regular expressions, this will probably be a pretty boring
    option, as you can see in this example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 还有三个其他选项我们想和你分享。第一个新选项，`--only-matching`（`-o`）只打印匹配的单词。如果你的搜索模式不包含任何正则表达式，这可能是一个相当无聊的选项，就像在这个例子中所看到的：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It does exactly as you expected: it printed the word you were looking for.
    However, unless you just wanted to confirm this, it is probably not that interesting.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实如你所期望的那样：它打印了你要找的单词。然而，除非你只是想确认这一点，否则可能并不那么有趣。
- en: 'Now, if we do the same thing when using a more interesting search pattern (containing
    a regular expression), this option makes more sense:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在使用一个更有趣的搜索模式（包含正则表达式）时做同样的事情，这个选项就更有意义了：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In this (simplified!) example, you actually get new information: whichever
    words fell within your search pattern are now printed. While this might not seem
    impressive for such a short word in such a small file, imagine a more complex
    search pattern on a much larger file!'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个（简化的！）例子中，你实际上得到了新的信息：你搜索模式中的任何单词都会被打印出来。虽然对于这样一个短的单词在这样一个小的文件中来说可能并不那么令人印象深刻，但想象一下在一个更大的文件中使用一个更复杂的搜索模式！
- en: 'This brings up another point: `grep` is *fast*. Because of the Boyer-Moore
    algorithm, `grep` can search very fast even in very large files (100 MB+).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来了另一个问题：`grep`非常*快*。由于Boyer-Moore算法，`grep`可以在非常大的文件（100 MB+）中进行非常快速的搜索。
- en: 'The second extra option, `--count` (`-c`), does not return any lines. It does,
    however, return a single digit: the number of lines for which the search pattern
    matched. A well-known example of when this comes in handy is when looking at log
    files for package installations:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个额外选项，`--count`（`-c`），不返回任何行。但是，它会返回一个数字：搜索模式匹配的行数。一个众所周知的例子是查看包安装的日志文件时：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the regular `grep` here, we see log lines that show which package was installed
    on which date. But what if we just wanted to know *how many packages were installed
    on a certain date*? `--count` to the rescue!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个常规的`grep`中，我们看到显示了哪个包在哪个日期安装的日志行。但是，如果我们只想知道*某个日期安装了多少个包*呢？`--count`来帮忙！
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We perform this `grep` operation in two stages. The first `grep 'status installed'`
    filters out all lines related to successful installations, skipping intermediate
    steps such as *unpacked* and *half-configured*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个`grep`操作分为两个阶段。第一个`grep 'status installed'`过滤掉所有与成功安装相关的行，跳过中间步骤，比如*unpacked*和*half-configured*。
- en: We use the alternative form of `grep` behind a pipe (which we will discuss further
    in [Chapter 12](15141e02-be0c-4709-90f4-a172809217c4.xhtml), *Using Pipes and
    Redirection* *in Scripts*) to match another search pattern to the already-filtered
    data. This second `grep '2018-08-26'` filters on the date.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在管道后面使用`grep`的替代形式（我们将在[第12章](15141e02-be0c-4709-90f4-a172809217c4.xhtml)中进一步讨论，*在脚本中使用管道和重定向*）来匹配另一个搜索模式到已经过滤的数据。第二个`grep
    '2018-08-26'`用于按日期过滤。
- en: Now, without the `-c` option, we would see 40 lines. If we were curious about
    the packages, this might have been a good option, but otherwise, just the printed
    number is better than counting the lines by hand.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果没有`-c`选项，我们会看到40行。如果我们对包感兴趣，这可能是一个不错的选择，但否则，只打印数字比手动计算行数要好。
- en: 'Alternatively, we could have written this as a single grep search pattern,
    using regular expressions. Try it yourself: `grep ''2018-08-26 .* status installed''
    dpkg.log` (be sure to replace the date with some day on which you have run updates/installations).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以将其写成一个单独的grep搜索模式，使用正则表达式。自己试一试：`grep '2018-08-26 .* status installed'
    dpkg.log`（确保用你运行更新/安装的某一天替换日期）。
- en: The final option, which is very interesting, especially for scripting, is the
    `--quiet` (`-q`) option. Imagine a situation where you want to know if a certain
    search pattern is present in a file. If you find the search pattern, you delete
    the file. If you do not find the search pattern, you'll add it to the file.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项非常有趣，特别是对于脚本编写，就是`--quiet`（`-q`）选项。想象一种情况，你想知道文件中是否存在某个搜索模式。如果找到了搜索模式，就删除文件。如果没有找到搜索模式，就将其添加到文件中。
- en: As you know, you can use a nice `if-then-else` construct to accomplish that.
    However, if you use a normal `grep`, you will see the text printed in the Terminal
    when you run your script.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道，你可以使用一个很好的`if-then-else`结构来完成这个任务。但是，如果你使用普通的`grep`，当你运行脚本时，你会在终端上看到文本被打印出来。
- en: 'This is not really that big an issue, but once your scripts get sufficiently
    large and complicated, a lot of output to the screen will make a script hard to
    use. For this, we have the `--quiet` option. Look at this example script to see
    how you would do this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个很大的问题，但是一旦你的脚本变得足够大和复杂，大量的输出到屏幕会使脚本难以使用。为此，我们有`--quiet`选项。看看这个示例脚本，看看你会如何做到这一点：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, the trick is in the exit status. If `grep` finds one or more
    matches of the search pattern, an exit code of 0 is given. If `grep` does not
    find anything, this return code will be 1.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，关键在于退出状态。如果`grep`找到一个或多个搜索模式的匹配，就会返回退出代码0。如果`grep`没有找到任何内容，返回代码将是1。
- en: 'You can see this for yourself on the command line:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在命令行上自己看到这一点：
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In `grep-then-else.sh`, we suppress all output from `grep`. Still, we can achieve
    what we want: each run of the script changes between the *then* and *else* condition,
    as our `bash -x` debug output clearly shows.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`grep-then-else.sh`中，我们抑制了`grep`的所有输出。但是，我们仍然可以实现我们想要的效果：脚本的每次运行在*then*和*else*条件之间变化，正如我们的`bash
    -x`调试输出清楚地显示的那样。
- en: 'Without the `--quiet`, the non-debug output of the script would be as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`--quiet`，脚本的非调试输出将如下所示：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It doesn't really add anything to the script, does it? Even better, a lot of
    commands have a `--quiet`, `-q`, or equivalent option.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上并没有为脚本添加任何东西，是吗？更好的是，很多命令都有`--quiet`，`-q`或等效选项。
- en: When you're scripting, always consider whether the output of a command is relevant.
    If it is not, and you can use the exit status, this almost always makes for a
    cleaner output experience.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写脚本时，始终考虑命令的输出是否相关。如果不相关，并且可以使用退出状态，这几乎总是会使输出体验更清晰。
- en: Introducing egrep
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍`egrep`
- en: 'Until now, we''ve seen `grep` used with various options that alter its behavior.
    There is one final important option we''d like to share with you: `--extended-regexp`
    (`-E`). As the `man grep` page states, this means *interpret PATTERN as an extended
    regular expression.*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到`grep`与各种选项一起使用，这些选项改变了它的行为。有一个最后重要的选项我们想要和你分享：`--extended-regexp`
    (`-E`)。正如`man grep`页面所述，这意味着*将PATTERN解释为扩展正则表达式*。
- en: In contrast to the default regular expressions found in Linux, extended regular
    expressions have search patterns that are a lot closer to regular expressions
    in other scripting/programming languages (should you already have experience with
    those).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 与Linux中找到的默认正则表达式相比，扩展正则表达式具有更接近其他脚本/编程语言中的正则表达式的搜索模式（如果你已经有这方面的经验）。
- en: 'Specifically, the following constructs are available when using extended regular
    expressions over default regular expressions:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在使用扩展正则表达式而不是默认正则表达式时，以下构造是可用的：
- en: '| ? | Matches a repeat of the previous character *zero or more times* |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| ? | 匹配前一个字符的重复*零次或多次*|'
- en: '| + | Matches a repeat of the previous character *one or more times* |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| + | 匹配前一个字符的重复*一次或多次*|'
- en: '| {n} | Matches a repeat of the previous character *exactly n times* |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| {n} | 匹配前一个字符的重复*恰好n次*|'
- en: '| {n,m} | Matches a repeat of the previous character *between n and m times*
    |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| {n,m} | 匹配前一个字符的重复*介于n和m次之间*|'
- en: '| {,n} | Matches a repeat of the previous character *n or fewer times* |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| {,n} | 匹配前一个字符的重复*n次或更少次*|'
- en: '| {n,} | Matches a repeat of the previous character *n or more times* |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| {n,} | 匹配前一个字符的重复*n次或更多次*|'
- en: '| (xx&#124;yy) | Alternation character, allows us to find xx *OR* yy in the
    search pattern (great for patterns with more than one character, otherwise, `[xy]`
    notation would suffice) |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| (xx&#124;yy) | 交替字符，允许我们在搜索模式中找到xx *或* yy（对于具有多个字符的模式非常有用，否则，`[xy]`表示法就足够了）|'
- en: As you might have seen, the man page for `grep` contains a dedicated section
    on regular expressions and search patterns, which you may find very convenient
    as a quick reference.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经看到的，`grep`的man页面包含了一个关于正则表达式和搜索模式的专门部分，你可能会发现它作为一个快速参考非常方便。
- en: 'Now, before we start using the new ERE search patterns, we''ll look at a *new*
    command: `egrep`. If you tried to find out what it does, you might start with
    a `which egrep`, which would result in `/bin/egrep`. This might lead you to think
    it was a separate binary from `grep`, which you''ve used so much by now.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们开始使用新的ERE搜索模式之前，我们将介绍一个*新*命令：`egrep`。如果你试图找出它的作用，你可能会从`which egrep`开始，结果是`/bin/egrep`。这可能会让你认为它是一个独立的二进制文件，而不是你现在已经使用了很多的`grep`。
- en: 'However, in the end, `egrep` is nothing more than a small wrapper script:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终，`egrep`只不过是一个小小的包装脚本：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, it's just a shell script, but without the customary `.sh` extension.
    It uses the `exec` command to *replace the current process image with a new process
    image*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这只是一个shell脚本，但没有通常的`.sh`扩展名。它使用`exec`命令来*用新的进程映像替换当前进程映像*。
- en: You might recall that normally, a command is executed in a fork of the current
    environment. In this case, since we use this script to *wrap* (hence why it is
    called a wrapper script) `grep -E` as `egrep`, it makes sense to replace it instead
    of forking it again.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，通常情况下，命令是在当前环境的一个分支中执行的。在这种情况下，因为我们使用这个脚本来*包装*（这就是为什么它被称为包装脚本）`grep -E`作为`egrep`，所以替换它而不是再次分支是有意义的。
- en: 'The `"$@"` construct is new as well: it is an *array* (if you aren''t familiar
    with this term, think of an ordered list) of arguments. In this case, it essentially
    passes all arguments received by `egrep` into `grep -E`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`"$@"`构造也是新的：它是一个*数组*（如果你对这个术语不熟悉，可以想象为一个有序列表）的参数。在这种情况下，它基本上将`egrep`接收到的所有参数传递到`grep
    -E`中。'
- en: So, if the full command was `egrep -w [[:digit:]] grep-file.txt`, it would be
    wrapped and finally executed in place as `grep -E -w [[:digit:]] grep-file.txt`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果完整的命令是`egrep -w [[:digit:]] grep-file.txt`，它将被包装并最终作为`grep -E -w [[:digit:]]
    grep-file.txt`执行。
- en: In practice, it does not matter whether you use `egrep` or `grep -E`. We prefer
    using `egrep` so we know for sure that we're dealing with extended regular expressions
    (since the extended functionality is often used in practice, in our experience).
    For simple search patterns, however, there is no need for ERE.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，使用`egrep`或`grep -E`并不重要。我们更喜欢使用`egrep`，这样我们就可以确定我们正在处理扩展的正则表达式（因为在我们的经验中，扩展功能经常被使用）。但是，对于简单的搜索模式，不需要使用ERE。
- en: We advise you to find your own system for when to use each one.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议你找到自己的系统，决定何时使用每个命令。
- en: 'Now for some examples of the extended regular expression search pattern capabilities:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一些扩展正则表达式搜索模式的例子：
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The first command, `egrep -w [[:lower:]]{5} grep-file.txt`, shows us all words
    that are exactly five characters long, using lowercase letters. Don''t forget
    we need the `-w` option here, because otherwise, any five letters in a row match
    as well, ignoring word boundaries (in this case, the **prett** in **prett**y matches
    as well). The result is only one five-letter word: color.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令`egrep -w [[:lower:]]{5} grep-file.txt`，显示了所有恰好五个字符长的单词，使用小写字母。不要忘记这里需要`-w`选项，因为否则，任何五个字母连续在一起也会匹配，忽略单词边界（在这种情况下，**prett**y中的**prett**也会匹配）。结果只有一个五个字母的单词：color。
- en: 'Next, we do the same for seven-letter words. We now get more results. However,
    because we are only using lowercase letters, we''re missing two words that are
    also seven letters long: Regular and Zealand. We fix this by using `[[:alpha:]]`
    instead of `[[:lower:]]`. (We could have also used the `-i` option to make everything
    case-insensitive—`egrep -iw [[:lower:]]{7} grep-file.txt`.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们对七个字母的单词做同样的操作。我们现在得到了更多的结果。然而，因为我们只使用小写字母，我们错过了两个也是七个字母长的单词：Regular和Zealand。我们通过使用`[[:alpha:]]`而不是`[[:lower:]]`来修复这个问题。（我们也可以使用`-i`选项使所有内容不区分大小写—`egrep
    -iw [[:lower:]]{7} grep-file.txt`。
- en: While this is functionally acceptable, think about it for a second. In that
    case, you would be searching for *case-insensitive* words made up of exactly seven
    *lowercase* letters. That doesn't really make any sense. In situations such as
    these, we always choose logic over functionality, which in this case means changing
    `[[:lower:]]` to `[[:alpha:]]`, instead of using the `-i` option.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这在功能上是可以接受的，但请再考虑一下。在这种情况下，你将搜索由七个*小写*字母组成的*不区分大小写*单词。这实际上没有任何意义。在这种情况下，我们总是选择逻辑而不是功能，这意味着将`[[:lower:]]`改为`[[:alpha:]]`，而不是使用`-i`选项。
- en: So we know how we can search for words (or lines, if we omit the `-w` option)
    of a specific length. How about we now look for words longer or shorter than a
    minimum or maximum length?
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们知道了如何搜索特定长度的单词（或行，如果省略了`-w`选项）。现在我们来搜索比最小长度或最大长度更长或更短的单词。
- en: 'Here''s an example:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE39]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This example demonstrates boundary syntax. This first command, `egrep -w '[[:lower:]]{5,}'
    grep-file.txt`, looks for lowercase words that are five letters or more. If you
    compare these results to the previous examples, where we were looking for words
    exactly five letters long, you now see that longer words are also matched.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了边界语法。第一个命令，`egrep -w '[[:lower:]]{5,}' grep-file.txt`，寻找了至少五个字母的小写单词。如果你将这些结果与之前寻找确切五个字母长的单词的例子进行比较，你现在会发现更长的单词也被匹配到了。
- en: 'Next, we reverse the boundary condition: we only want to match on words that
    are three letters or fewer. We see that all two- and three-letter words are matched
    (and, because we switched from `[[:lower:]]` to `[[:alpha:]]`, UK and capitalized
    letters at the beginning of the lines are matched as well).'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们反转边界条件：我们只想匹配三个字母或更少的单词。我们看到所有两个和三个字母的单词都被匹配到了（因为我们从`[[:lower:]]`切换到了`[[:alpha:]]`，UK和行首大写字母也被匹配到了）。
- en: In the final example, `egrep '.{40,}' grep-file.txt`, we remove the `-w` so
    we're matching on whole lines. We match on any character (as denoted by the dot),
    and we want at least 40 characters on a line (as denoted by the `{40,}`). In this
    case, only three lines of the five are matched (as the other two are shorter).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个例子中，`egrep '.{40,}' grep-file.txt`，我们去掉了`-w`，所以我们匹配整行。我们匹配任何字符（由点表示），并且我们希望一行至少有40个字符（由`{40,}`表示）。在这种情况下，只有五行中的三行被匹配到了（因为其他两行较短）。
- en: 'Quoting is very important for search patterns. If you do not use quotes in
    your pattern, especially when using special characters, such as { and }, you will
    need to escape them with a backslash. This can and will lead to confusing situations,
    where you''re staring at the screen wondering why on earth your search pattern
    is not working, or even throwing errors. Just remember: if you single-quote the
    search pattern at all times, you will have a much better chance of avoiding these
    frustrating situations.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 引用对于搜索模式非常重要。如果你在模式中不使用引号，特别是在使用{和}等特殊字符时，你将需要用反斜杠对它们进行转义。这可能会导致令人困惑的情况，你会盯着屏幕想知道为什么你的搜索模式不起作用，甚至会报错。只要记住：如果你始终对搜索模式使用单引号，你就会更有可能避免这些令人沮丧的情况。
- en: The final concept of extended regular expressions we want to show is *alternation*.
    This uses pipe syntax (not to be confused with pipes used for redirection, which
    will be further discussed in [Chapter 12](15141e02-be0c-4709-90f4-a172809217c4.xhtml),
    *Using Pipes and Redirection in Scripts*) to convey the meaning of *match on xxx
    OR yyy*.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要展示的扩展正则表达式的最后一个概念是*alternation*。这使用了管道语法（不要与用于重定向的管道混淆，这将在[第12章](15141e02-be0c-4709-90f4-a172809217c4.xhtml)中进一步讨论，*在脚本中使用管道和重定向*）来传达*匹配xxx或yyy*的含义。
- en: 'An example should make this clear:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子应该能说明问题：
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the case of a single letter difference, we can choose whether we want to
    use extended alternation syntax, or the earlier-discussed bracket syntax. We would
    advise using the simplest syntax that accomplishes the goal, which, in this case,
    is bracket syntax.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在只有一个字母差异的情况下，我们可以选择使用扩展的alternation语法，或者之前讨论过的括号语法。我们建议使用最简单的语法来实现目标，这种情况下就是括号语法。
- en: 'However, once we are looking for patterns of more than one character difference,
    using bracket syntax becomes prohibitively complex. In this case, extended alternation
    syntax is clear and concise, especially since `|` or `||` represents an `OR` construct
    in most scripting/programming logic. For this example, this would be like saying:
    I want to find lines that contain either the word USA or the word UK.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦我们要寻找超过一个字符差异的模式，使用括号语法就变得非常复杂。在这种情况下，扩展的alternation语法是清晰而简洁的，特别是因为`|`或`||`在大多数脚本/编程逻辑中代表`OR`构造。对于这个例子，这就像是说：我想要找到包含单词USA或单词UK的行。
- en: Because this syntax corresponds nicely with a semantic view, it feels intuitive
    and is understandable, something we should always strive for in our scripts!
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这种语法与语义视图相对应得很好，它感觉直观且易懂，这是我们在脚本中应该始终努力的事情！
- en: sed, the stream editor
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流编辑器sed
- en: 'Since we''re now fully familiar with regular expressions, search patterns,
    and (extended) `grep`, it''s time to move to one of the most powerful tools in
    the GNU/Linux landscape: `sed`. The term is short for **s**tream **ed**itor, and
    it does exactly what is implied: editing streams.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在对正则表达式、搜索模式和（扩展）`grep`非常熟悉，是时候转向GNU/Linux领域中最强大的工具之一了：`sed`。这个术语是**s**tream
    **ed**itor的缩写，它确实做到了它所暗示的：编辑流。
- en: In this context, a stream can be a lot of things, but in general, it is text.
    This text may be found within a file, but can also be *streamed* from another
    process, such as a `cat grep-file.txt | sed ...`. In that example, the output
    of the `cat` command (equal to the content of `grep-file.txt`) serves as input
    for the `sed` command.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，流可以是很多东西，但通常是文本。这个文本可以在文件中找到，但也可以从另一个进程中*流式传输*，比如`cat grep-file.txt |
    sed ...`。在这个例子中，`cat`命令的输出（等同于`grep-file.txt`的内容）作为`sed`命令的输入。
- en: We will look at both in-place file editing and stream editing in our examples.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的示例中查看就地文件编辑和流编辑。
- en: Stream editing
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流编辑
- en: 'We''ll first look at actual stream editing with `sed`. Stream editing allows
    us to do really cool stuff: we could, for example, change some words in a text.
    We could also delete certain lines we do not care about (everything that does
    not contain the word ERROR, for example).'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看一下使用`sed`进行实际流编辑。流编辑允许我们做一些很酷的事情：例如，我们可以更改文本中的一些单词。我们还可以删除我们不关心的某些行（例如，不包含单词ERROR的所有内容）。
- en: 'We''ll begin with a simple example, searching for and replacing a word in a
    line:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的例子开始，搜索并替换一行中的一个单词：
- en: '[PRE41]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Just like that, `sed` transformed my positive sentence into something... less
    positive. The pattern `sed` uses (in `sed` terms, this is just called a *script*)
    is `s/wicked/stupid/`*.* The `s` stands for search-replace, and the first word
    of the *script* is substituted for the second word.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这样，`sed`将我的积极句子转变成了不太积极的东西。`sed`使用的模式（在`sed`术语中，这只是称为*script*）是`s/wicked/stupid/`。`s`代表搜索替换，*script*的第一个单词被第二个单词替换。
- en: 'Observe what happens for multiple lines with multiple matches for the search
    word:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 观察一下对于具有多个匹配项的多行会发生什么：
- en: '[PRE42]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'From this example, we can learn two things:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们可以学到两件事：
- en: By default, `sed` only replaces the first instance of each word *for each line.*
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，`sed`只会替换每行中每个单词的第一个实例。
- en: '`sed` does not match only on whole words, but also on partial words.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sed`不仅匹配整个单词，还匹配部分单词。'
- en: 'What if we wanted to replace all instances within each line? This is called
    a *global* search-replace, and the syntax is only very slightly different:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要替换每行中的所有实例怎么办？这称为*全局*搜索替换，语法只有非常轻微的不同：
- en: '[PRE43]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: By adding a `g` at the end of the `sed` *script*, we are now globally replacing
    all instances, instead of just the first instance for each line.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`sed` *script*的末尾添加`g`，我们现在全局替换所有实例，而不仅仅是每行的第一个实例。
- en: Another possibility is that you would only want to search-replace on the first
    line. You could use `head -1` to only select that line before you send it through
    `sed`, but that would mean you would need to append the other lines afterwards.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是，您可能只想在第一行上进行搜索替换。您可以使用`head -1`仅选择该行，然后将其发送到`sed`，但这意味着您需要在后面添加其他行。
- en: 'We can select which lines we want to edit by placing the line numbers in front
    of the `sed` script, as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`sed`脚本前面放置行号来选择要编辑的行，如下所示：
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The first script, `'1s/wood/stone/'`, instructs `sed` to replace the first instance
    of *wood* on the first line with *stone*. The next script, `'1s/wood/stone/g'`,
    tells `sed` to replace all instances of *wood* with *stone*, but only on the first
    line. The last script, `'1,2s/wood/stone/g'`, makes `sed` replace all instances
    of *wood* on all lines between (and including!) `1` and `2`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个脚本，`'1s/wood/stone/'`，指示`sed`将第一行中的第一个*wood*实例替换为*stone*。下一个脚本，`'1s/wood/stone/g'`，告诉`sed`将*wood*的所有实例替换为*stone*，但只在第一行上。最后一个脚本，`'1,2s/wood/stone/g'`，使`sed`替换所有行（包括！）中（和包括！）`1`和`2`之间的所有*wood*实例。
- en: In-place editing
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 就地编辑
- en: 'While it is not *that* big a deal to `cat` a file before we send it to `sed`,
    fortunately, we don''t really need to do that. The usage for `sed` is as follows:
    `sed [OPTION] {script-only-if-no-other-script} [input-file]`. As you can see at
    the end, there is an option for `[input-file]`.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在将文件发送到`sed`之前`cat`文件并不是*那么*大的问题，幸运的是，我们实际上不需要这样做。`sed`的用法如下：`sed [OPTION]
    {script-only-if-no-other-script} [input-file]`。正如您在最后看到的那样，还有一个选项`[input-file]`。
- en: 'Let''s take one of the previous examples, and remove the `cat`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿之前的一个例子，然后去掉`cat`：
- en: '[PRE45]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, by using the optional `[input-file]` argument, `sed` processes
    all lines in that file according to the script. By default, `sed` prints everything
    it processes. In some cases, this causes lines to be printed twice, namely when
    using the `print` function of `sed` (which we will see in a bit).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过使用可选的`[input-file]`参数，`sed`根据脚本处理文件中的所有行。默认情况下，`sed`会打印它处理的所有内容。在某些情况下，这会导致行被打印两次，即当使用`sed`的`print`函数时（我们稍后会看到）。
- en: 'Another very important thing that this example demonstrates: this syntax does
    not edit the original file; only what is printed out to `STDOUT` is changed. Sometimes,
    you will want to edit the file itself—for these scenarios, `sed` has the `--in-place`
    (`-i`) option.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示的另一个非常重要的事情是：这种语法不会编辑原始文件；只有打印到`STDOUT`的内容会发生变化。有时，您可能希望编辑文件本身——对于这些情况，`sed`有`--in-place`（`-i`）选项。
- en: Make sure you understand that this **irreversibly changes the file on disk**.
    And, as with most things in Linux, there is no such thing as an undo button or
    a recycle bin!
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您理解这**会对磁盘上的文件进行不可逆转的更改**。而且，就像Linux中的大多数事情一样，没有撤销按钮或回收站！
- en: 'Let''s see how we can use `sed -i` to persistently change a file (after we
    make a backup, of course):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`sed -i`来持久更改文件（当然，在我们备份之后）：
- en: '[PRE46]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This time, instead of printing the processed text onto your screen, `sed` quietly
    changed the file on disk. Because of the destructive nature of this, we created
    a backup beforehand. However, the `--in-place` option of `sed` can provide that
    functionality as well, by adding a file suffix:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，不是将处理后的文本打印到屏幕上，而是`sed`悄悄地更改了磁盘上的文件。由于这种破坏性的本质，我们事先创建了一个备份。但是，`sed`的`--in-place`选项也可以提供这种功能，方法是添加文件后缀：
- en: '[PRE47]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`sed` is a bit stingy with the syntax. If you put a space between `-i` and
    `''.bak''`, you will get weird errors (this normally works fine for commands whose
    options have arguments). In this case, because the script definition follows right
    after, `sed` is having trouble differentiating between what is the file suffix
    and script string.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`的语法有点吝啬。如果在`-i`和`''.bak''`之间加上一个空格，您将会得到奇怪的错误（这通常对于选项带有参数的命令来说是正常的）。在这种情况下，因为脚本定义紧随其后，`sed`很难区分文件后缀和脚本字符串。'
- en: Just remember that if you want to use this, you need to be careful about this
    syntax!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 只要记住，如果您想使用这个，您需要小心这个语法！
- en: Line manipulation
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行操作
- en: 'While the word manipulation functionality of `sed` is great, it also allows
    us to manipulate whole lines. For example, we can delete certain lines, by number:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`sed`的单词操作功能很棒，但它也允许我们操作整行。例如，我们可以按行号删除某些行：
- en: '[PRE48]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: By using `echo -e` combined with the newline character (`\n`), we can create
    multi-line statements. `-e` is explained on the `man echo` page as *enable interpretation
    of backslash escapes*. By piping this multi-line output into `sed`, we can use
    the delete functionality, which is a script that simply uses the character `d`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`echo -e`结合换行符（`\n`），我们可以创建多行语句。`-e`在`man echo`页面上解释为*启用反斜杠转义的解释*。通过将这个多行输出传递给`sed`，我们可以使用删除功能，这是一个简单地使用字符`d`的脚本。
- en: If we prefix this with a line number, for example `1d`, the first line is deleted.
    If we do not, all lines are deleted, which results in no output for us.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在行号前加上一个前缀，例如`1d`，则删除第一行。如果不这样做，所有行都将被删除，这对我们来说没有输出。
- en: 'Another, often more interesting, possibility is deleting lines that contain
    a certain word:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个，通常更有趣的可能性是删除包含某个单词的行：
- en: '[PRE49]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the same way as we used a script with word matching for the search-replace
    function of `sed`, so can we also delete a whole line if a word is present. As
    you can see from the preceding example, this is case-sensitive. Luckily, there's
    always a solution if we want to do this in a case-insensitive manner. In `grep`,
    this would be the `-i` flag, but for `sed` this `-i` is already reserved for `--in-place`
    functionality.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们使用脚本进行单词匹配的`sed`搜索替换功能一样，如果存在某个单词，我们也可以删除整行。从前面的例子中可以看到，这是区分大小写的。幸运的是，如果我们想以不区分大小写的方式进行操作，总是有解决办法。在`grep`中，这将是`-i`标志，但对于`sed`，`-i`已经保留给了`--in-place`功能。
- en: 'How do we do it then? By using our old friends regular expressions, of course!
    See the following example:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们该怎么做呢？当然是使用我们的老朋友正则表达式！请参阅以下示例：
- en: '[PRE50]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: While it's not as graceful as the functionality provided by `grep`, it does
    get the job done in most situations. It should at least make you aware of the
    fact that using regular expressions with `sed` makes the whole thing much more
    flexible and much more powerful.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它不像`grep`提供的功能那样优雅，但在大多数情况下它确实完成了工作。它至少应该让您意识到，使用正则表达式与`sed`使整个过程更加灵活和更加强大。
- en: As with most things, with added flexibility and power comes added complexity.
    However, we hope that with this gentle introduction to regular expressions and
    `sed`, the combination of both does not feel unmanageably complex.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数事物一样，增加了灵活性和功能，也增加了复杂性。但是，我们希望通过这对正则表达式和`sed`的简要介绍，两者的组合不会感到难以管理的复杂。
- en: 'Instead of deleting lines from a file or stream, you might have a better use
    case for just showing a few files. There is a small issue with this, however:
    by default, `sed` prints all lines it processes. If you give `sed` the instruction
    to print a line (with the `p` script*)*, it will print that line two times—once
    for the match on the script, and the other time for the default print.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 与从文件或流中删除行不同，您可能更适合只显示一些文件。但是，这里有一个小问题：默认情况下，`sed`会打印它处理的所有行。如果您给`sed`指令打印一行（使用`p`脚本*），它将打印该行两次——一次是匹配脚本，另一次是默认打印。
- en: 'This looks something like this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点像这样：
- en: '[PRE51]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The syntax for the print and delete scripts is similar: `''/word/d''` and `''/word/p''`.
    To suppress the default behavior of `sed`, which prints all lines, add a `-n`
    (also known as `--quiet` or `--silent`):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 打印和删除脚本的语法类似：`'/word/d'`和`'/word/p'`。要抑制`sed`的默认行为，即打印所有行，添加`-n`（也称为`--quiet`或`--silent`）：
- en: '[PRE52]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You might have figured out that printing and deleting lines with `sed` scripts
    shares the same functionality as `grep` and `grep -v`. In most cases, you can
    choose which you prefer to use. However, some advanced functionality, like deleting
    lines that match, but only from the first 10 lines of a file, can only be done
    with `sed`. As a rule of thumb, anything that can be achieved with `grep` using
    a single statement should be handled with `grep`; otherwise, turn to `sed`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经发现，使用`sed`脚本打印和删除行与`grep`和`grep -v`具有相同的功能。在大多数情况下，您可以选择使用哪种。但是，一些高级功能，例如删除匹配的行，但仅从文件的前10行中删除，只能使用`sed`完成。作为一个经验法则，任何可以使用单个语句使用`grep`实现的功能都应该使用`grep`来处理；否则，转而使用`sed`。
- en: 'There is one final use case for `sed` that we would like to highlight: you
    have a file or stream, and you need to delete not a whole line, but only some
    words in those lines. With `grep`, this cannot be (easily) achieved. `sed` has
    a very simple way of doing this, however.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`sed`的最后一个用例我们想要强调：您有一个文件或流，您需要删除的不是整行，而只是这些行中的一些单词。使用`grep`，这是（很容易地）无法实现的。然而，`sed`有一种非常简单的方法来做到这一点。
- en: What makes searching and replacing different to just plain deleting a word?
    Just the replacement pattern!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索和替换与仅仅删除一个单词有什么不同？只是替换模式！
- en: 'See the following example:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下示例：
- en: '[PRE53]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'By *replacing* the word stone with *nothing* (as that is exactly what is present
    between the second and third backslash in the `sed` script), we delete the word
    stone completely. In this example, however, you can see a common problem you will
    undoubtedly run across: extra whitespace after deleting a word.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将单词stone替换为*nothing*（因为这正是在`sed`脚本中第二个和第三个反斜杠之间存在的内容），我们完全删除了单词stone。然而，在这个例子中，你可以看到一个常见的问题，你肯定会遇到：删除单词后会有额外的空格。
- en: 'This leads us to one more trick for `sed`, which helps you out in this regard:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们来到了`sed`的另一个技巧，可以帮助你解决这个问题：
- en: '[PRE54]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: By supplying `-e`, followed by a `sed` script, you can make `sed` run multiple
    scripts (in order!) over your stream. By default, `sed` expects at least one script,
    which is why you do not need to supply the `-e` if you're only processing a single
    script. For more scripts than this, you'll need to add a `-e` before each.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供`-e`，后跟一个`sed`脚本，你可以让`sed`在你的流上运行多个脚本（按顺序！）。默认情况下，`sed`期望至少有一个脚本，这就是为什么如果你只处理一个脚本，你不需要提供`-e`。对于比这更多的脚本，你需要在每个脚本之前添加一个`-e`。
- en: Final remarks
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的话
- en: Regular expressions are **hard**. What makes this even harder on Linux is that
    regular expressions have been implemented by different programs (which have different
    maintainers, with different opinions) slightly differently.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式很**难**。在Linux上更难的是，正则表达式已经由不同的程序（具有不同的维护者和不同的观点）略有不同地实现。
- en: To make matters worse, some features of regular expressions have been hidden
    as extended regular expressions by some programs, whereas they are considered
    the default by other programs. In past years, the maintainers of these programs
    seemed to have moved towards a more global POSIX standard for *regular* regular
    expressions and *extended* regular expressions, but still to this day, there are
    some discrepancies.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，一些正则表达式的特性被一些程序隐藏为扩展的正则表达式，而在其他程序中被认为是默认的。在过去的几年里，这些程序的维护者似乎已经朝着更全局的POSIX标准迈进，用于*正则*正则表达式和*扩展*正则表达式，但直到今天，仍然存在一些差异。
- en: 'We have some very simple advice for dealing with this: **just try it out**.
    You might not remember what the asterisk represents in globbing, as opposed to
    regular expressions, or why the question mark does something different. Perhaps
    you''ll forget to ''activate'' extended syntax with `-E`, and your extended search
    pattern will return weird errors.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对处理这个问题有一些建议：**试一试**。也许你不记得星号在globbing中代表什么，与正则表达式不同，或者问号为什么会有不同的作用。也许你会忘记用`-E`来“激活”扩展语法，你的扩展搜索模式会返回奇怪的错误。
- en: You will definitely forget to quote a search pattern once, and if it contains
    a character such as a dot or $ (which is interpreted by Bash,) your command will
    crash and burn, often with a not-too-clear error message.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你肯定会忘记引用搜索模式一次，如果它包含像点或$这样的字符（由Bash解释），你的命令会崩溃，通常会有一个不太清晰的错误消息。
- en: Just know that we have all made these mistakes, and only experience will make
    this easier. In fact, in writing this chapter, almost none of the commands as
    we had them in our heads worked right away! You are not alone in this, and you
    should not feel bad about it. *Just keep going and keep trying until it works,
    and until you understand why it did not work the first time.*
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 只要知道我们都犯过这些错误，只有经验才能让这变得更容易。事实上，在写这一章时，几乎没有一个命令像我们在脑海中想象的那样立即起作用！你并不孤单，你不应该因此感到难过。*继续努力，直到成功，并且直到你明白为什么第一次没有成功。*
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter explained regular expressions, and two common tools that use them
    under Linux: `grep` and `sed`.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了正则表达式，以及在Linux下使用它们的两个常见工具：`grep`和`sed`。
- en: We began by explaining that regular expressions are *search pattern**s,* used
    in combination with text to find matches. These search patterns allow us to search
    very flexibly in text where its contents are not necessarily known at runtime.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先解释了正则表达式是与文本结合使用的*搜索模式*，用于查找匹配项。这些搜索模式允许我们在文本中进行非常灵活的搜索，其中文本的内容在运行时不一定已知。
- en: Search patterns allow us, for example, to look only for words and not numbers,
    for words at the beginnings or endings of lines, or for empty lines. Search patterns
    include wildcards, which can represent one or more of a certain character or character
    class.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索模式允许我们，例如，仅查找单词而不是数字，查找行首或行尾的单词，或查找空行。搜索模式包括通配符，可以表示某个字符或字符类的一个或多个。
- en: We introduced the `grep` command to show how we can use the basic functionality
    of regular expressions in Bash.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了`grep`命令，以展示我们如何在Bash中使用正则表达式的基本功能。
- en: The second part of this chapter dealt with globbing. Globbing is used as a wildcard
    mechanism for file names and paths. It has similarities with regular expressions,
    but also some key differences. Globbing can be used with most commands that deal
    with files (and, since most *things* under Linux can be considered files, this
    means almost all commands support some form of globbing).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第二部分涉及globbing。Globbing用作文件名和路径的通配符机制。它与正则表达式有相似之处，但也有一些关键的区别。Globbing可以与大多数处理文件的命令一起使用（而且，由于Linux下的大多数*东西*都可以被视为文件，这意味着几乎所有命令都支持某种形式的globbing）。
- en: The last half of the chapter described using regular expressions with `egrep`
    and `sed`. `egrep`, being a simple wrapper for `grep -E`, allows us to use extended
    syntax for regular expressions, which we discussed along with some often-used,
    advanced features of `grep`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的后半部分描述了如何使用`egrep`和`sed`的正则表达式。`egrep`是`grep -E`的简单包装器，允许我们使用扩展语法进行正则表达式，我们讨论了一些常用的高级`grep`功能。
- en: In contrast to default regular expressions, extended regular expressions allow
    us to specify the length of certain patterns and how often they repeat, as well
    as allowing us to use alternation.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 与默认的正则表达式相比，扩展的正则表达式允许我们指定某些模式的长度以及它们重复的次数，同时还允许我们使用交替。
- en: The final part of this chapter described `sed`, the stream editor. `sed` is
    a complex but very powerful command, which allows us to do even more exciting
    stuff than `grep`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分描述了`sed`，流编辑器。`sed`是一个复杂但非常强大的命令，可以让我们做比`grep`更令人兴奋的事情。
- en: 'The following commands were introduced in this chapter: `grep`, `set`, `egrep`,
    and `sed`.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了以下命令：`grep`、`set`、`egrep`和`sed`。
- en: Questions
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a search pattern?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是搜索模式？
- en: Why are regular expressions considered greedy?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么正则表达式被认为是贪婪的？
- en: Which character in search patterns is considered a wildcard for any one character,
    except newlines?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索模式中，哪个字符被认为是除换行符外的任意一个字符的通配符？
- en: How is the asterisk used in Linux regular expression search patterns?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Linux正则表达式搜索模式中，星号如何使用？
- en: What are line anchors?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是行锚点？
- en: Name three character types.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举三种字符类型。
- en: What is globbing?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是globbing？
- en: What is possible in extended regular expression syntax that is not possible
    with normal regular expressions under Bash?
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Bash下，扩展正则表达式语法可以实现哪些普通正则表达式无法实现的功能？
- en: What would be a good rule of thumb for deciding whether to use `grep` or `sed`?
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在决定使用`grep`还是`sed`时，有什么好的经验法则？
- en: Why are regular expressions on Linux/Bash so hard?
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么Linux/Bash上的正则表达式如此困难？
- en: Further reading
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following resources might be interesting if you''d like to go deeper into
    the subjects of this chapter:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更深入地了解本章主题，以下资源可能会很有趣：
- en: '**The Linux Documentation Project on Regular Expressions**: [http://www.tldp.org/LDP/abs/html/x17129.html](http://www.tldp.org/LDP/abs/html/x17129.html)'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux文档项目关于正则表达式：[http://www.tldp.org/LDP/abs/html/x17129.html](http://www.tldp.org/LDP/abs/html/x17129.html)
- en: '**The Linux Documentation Project on Globbing**: [http://www.tldp.org/LDP/abs/html/globbingref.html](http://www.tldp.org/LDP/abs/html/globbingref.html)'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux文档项目关于Globbing：[http://www.tldp.org/LDP/abs/html/globbingref.html](http://www.tldp.org/LDP/abs/html/globbingref.html)
- en: '**The Linux Documentation Project on Sed**: [http://tldp.org/LDP/abs/html/x23170.html](http://tldp.org/LDP/abs/html/x23170.html)'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux文档项目关于Sed：[http://tldp.org/LDP/abs/html/x23170.html](http://tldp.org/LDP/abs/html/x23170.html)
