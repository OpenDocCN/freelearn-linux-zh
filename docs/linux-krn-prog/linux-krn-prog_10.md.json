["```\n// include/linux/mmzone.h\nstruct zone { \n    [ ... ] \n    /* free areas of different sizes */\n    struct free_area free_area[MAX_ORDER];\n    [ ... ]\n};\n```", "```\nstruct free_area {\n    struct list_head free_list[MIGRATE_TYPES];\n    unsigned long nr_free;\n};\n```", "```\n// ch8/lowlevel_mem/lowlevel_mem.c\n[...]\nstatic int bsa_alloc(void)\n{\n    int stat = -ENOMEM;\n    u64 numpg2alloc = 0;\n    const struct page *pg_ptr1;\n\n    /* 0\\. Show the identity mapping: physical RAM page frames to kernel virtual\n     * addresses, from PAGE_OFFSET for 5 pages */\n    pr_info(\"%s: 0\\. Show identity mapping: RAM page frames : kernel virtual pages :: 1:1\\n\", OURMODNAME);\n    show_phy_pages((void *)PAGE_OFFSET, 5 * PAGE_SIZE, 1);\n```", "```\n  /* 1\\. Allocate one page with the __get_free_page() API */\n  gptr1 = (void *) __get_free_page(GFP_KERNEL);\n  if (!gptr1) {\n        pr_warn(\"%s: __get_free_page() failed!\\n\", OURMODNAME);\n        /* As per convention, we emit a printk above saying that the\n         * allocation failed. In practice it isn't required; the kernel\n         * will definitely emit many warning printk's if a memory alloc\n         * request ever fails! Thus, we do this only once (here; could also\n         * use the WARN_ONCE()); from now on we don't pedantically print any\n         * error message on a memory allocation request failing. */\n        goto out1;\n  }\n  pr_info(\"%s: 1\\. __get_free_page() alloc'ed 1 page from the BSA @ %pK (%px)\\n\",\n      OURMODNAME, gptr1, gptr1);\n```", "```\n/*2\\. Allocate 2^bsa_alloc_order pages with the __get_free_pages() API */\n  numpg2alloc = powerof(2, bsa_alloc_order); // returns 2^bsa_alloc_order\n  gptr2 = (void *) __get_free_pages(GFP_KERNEL|__GFP_ZERO, bsa_alloc_order);\n  if (!gptr2) {\n      /* no error/warning printk now; see above comment */\n      goto out2;\n  }\n  pr_info(\"%s: 2\\. __get_free_pages() alloc'ed 2^%d = %lld page(s) = %lld bytes\\n\"\n      \" from the BSA @ %pK (%px)\\n\",\n      OURMODNAME, bsa_alloc_order, powerof(2, bsa_alloc_order),\n      numpg2alloc * PAGE_SIZE, gptr2, gptr2);\n  pr_info(\" (PAGE_SIZE = %ld bytes)\\n\", PAGE_SIZE);\n```", "```\nshow_phy_pages(gptr2, numpg2alloc * PAGE_SIZE, 1);\n```", "```\n// klib_llkd.c\n[...]\n/* show_phy_pages - show the virtual, physical addresses and PFNs of the memory range provided on a per-page basis.\n * @kaddr: the starting kernel virtual address\n * @len: length of the memory piece (bytes)\n * @contiguity_check: if True, check for physical contiguity of pages\n * 'Walk' the virtually contiguous 'array' of pages one by one (that is, page by page),  \n * printing the virt and physical address (and PFN- page frame number). This way, we can see \n * if the memory really is *physically* contiguous or not\n */\nvoid show_phy_pages(const void *kaddr, size_t len, bool contiguity_check)\n{\n    [...]\n    if (len % PAGE_SIZE)\n        loops++;\n    for (i = 0; i < len/PAGE_SIZE; i++) {\n        pa = virt_to_phys(vaddr+(i*PAGE_SIZE));\n pfn = PHYS_PFN(pa);\n\n        if (!!contiguity_check) {\n        /* what's with the 'if !!(<cond>) ...' ??\n         * a 'C' trick: ensures that the if condition always evaluates\n         * to a boolean - either 0 or 1 */\n            if (i && pfn != prev_pfn + 1)\n                pr_notice(\" *** physical NON-contiguity detected ***\\n\");\n        }\n        pr_info(\"%05d 0x%px %pa %ld\\n\", i, vaddr+(i*PAGE_SIZE), &pa, pfn);\n        if (!!contiguity_check)\n            prev_pfn = pfn;\n    }\n}\n```", "```\n    /* 3\\. Allocate and init one page with the get_zeroed_page() API */\n    gptr3 = (void *) get_zeroed_page(GFP_KERNEL);\n    if (!gptr3)\n        goto out3;\n    pr_info(\"%s: 3\\. get_zeroed_page() alloc'ed 1 page from the BSA @ %pK (%px)\\n\", \n        OURMODNAME, gptr3, gptr3);\n```", "```\n/* 4\\. Allocate one page with the alloc_page() API.\n pg_ptr1 = alloc_page(GFP_KERNEL);\n if (!pg_ptr1)\n     goto out4;\n\n gptr4 = page_address(pg_ptr1);\n pr_info(\"%s: 4\\. alloc_page() alloc'ed 1 page from the BSA @ %pK (%px)\\n\"\n         \" (struct page addr=%pK (%px)\\n)\",\n        OURMODNAME, (void *)gptr4, (void *)gptr4, pg_ptr1, pg_ptr1);\n```", "```\n /* 5\\. Allocate and init 2^3 = 8 pages with the alloc_pages() API.\n gptr5 = page_address(alloc_pages(GFP_KERNEL, 3));\n if (!gptr5)\n     goto out5;\n pr_info(\"%s: 5\\. alloc_pages() alloc'ed %lld pages from the BSA @ %pK (%px)\\n\", \n     OURMODNAME, powerof(2, 3), (void *)gptr5, (void *)gptr5);\n```", "```\n PWD                   := $(shell pwd)\n obj-m                 += lowlevel_mem_lkm.o\n lowlevel_mem_lkm-objs := lowlevel_mem.o ../../klib_lkdc.o\n EXTRA_CFLAGS          += -DDEBUG\n```", "```\n0000000000000000 - 00007fffffffffff (=47 bits) user space, different per mm hole caused by [47:63] sign extension\nffff800000000000 - ffff87ffffffffff (=43 bits) guard hole, reserved for hypervisor\nffff880000000000 - ffffc7ffffffffff (=64 TB) direct mapping of all phys. memory\nffffc80000000000 - ffffc8ffffffffff (=40 bits) hole\nffffc90000000000 - ffffe8ffffffffff (=45 bits) vmalloc/ioremap space\n```", "```\n#include <linux/gfp.h>\nvoid *alloc_pages_exact(size_t size, gfp_t gfp_mask);\nvoid free_pages_exact(void *virt, size_t size);\n```", "```\n$ sudo head /proc/slabinfo \nslabinfo - version: 2.1\n# name <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab> : tunables <limit> <batchcount> <sharedfactor> : slabdata <active_slabs> <num_slabs> <sharedavail>\nlttng_event     0     0     280   29   2 : tunables 0 0 0 : slabdata 0 0 0\nkvm_async_pf    0     0     136   30   1 : tunables 0 0 0 : slabdata 0 0 0\nkvm_vcpu        0     0   24576    1   8 : tunables 0 0 0 : slabdata 0 0 0\nkvm_mmu_page_header 0 0     168   24   1 : tunables 0 0 0 : slabdata 0 0 0\npte_list_desc   0     0      32  128   1 : tunables 0 0 0 : slabdata 0 0 0\ni915_request  112   112     576   28   4 : tunables 0 0 0 : slabdata 4 4 0\next4_groupinfo_4k 6482 6496 144   28   1 : tunables 0 0 0 : slabdata 232 232 0\nscsi_sense_cache 325 416 128 32 1 : tunables 0 0 0 : slabdata 13 13 0\n```", "```\ncd <ksrc-tree>/tools/vm\nmake slabinfo\n```", "```\n$ grep \"^Slab:\" /proc/meminfo\nSlab:            1580772 kB\n```", "```\n$ free -h\n              total     used     free     shared     buff/cache  available\nMem:           15Gi    5.5Gi    1.4Gi      704Mi          8.6Gi      9.0Gi\nSwap:         7.6Gi       0B    7.6Gi\n$ \n```", "```\n#include <linux/slab.h>\nvoid *kmalloc(size_t size, gfp_t flags);\nvoid *kzalloc(size_t size, gfp_t flags);\n```", "```\nvoid kfree(const void *);\n```", "```\nstatic char *kptr = kzalloc(1024, GFP_KERNEL);\n```", "```\nif (kptr)\n    kfree(kptr);\n```", "```\nstatic char *kptr = NULL;\n while (<some-condition-is-true>) {\n       if (!kptr)\n                kptr = kmalloc(num, GFP_KERNEL);\n        [... work on the slab memory ...]\n       kfree(kptr);\n }\n```", "```\n$ sudo vmstat -m | grep --color=auto \"^kmalloc\"\nkmalloc-rcl-8k                0      0    8192      4\nkmalloc-rcl-4k                0      0    4096      8\nkmalloc-rcl-2k                0      0    2048     16\n[...]\nkmalloc-8k                   52     52    8192      4\nkmalloc-4k                   99    120    4096      8\nkmalloc-2k                  521    560    2048     16\n[...]\n```", "```\n// ch8/slab1/slab1.c\n[...]\n#include <linux/slab.h>\n[...]\nstatic char *gkptr;\nstruct myctx {\n    u32 iarr[100];\n    u64 uarr[100];\n    char uname[128], passwd[16], config[16];\n};\nstatic struct myctx *ctx;\n\nstatic int __init slab1_init(void)\n{\n    /* 1\\. Allocate slab memory for 1 KB using the kmalloc() */\n    gkptr = kmalloc(1024, GFP_KERNEL);\n    if (!gkptr) {\n        WARN_ONCE(1, \"%s: kmalloc() failed!\\n\", OURMODNAME);\n        /* As mentioned earlier, there is really no need to print an\n         * error msg when a memory alloc fails; the situation \"shouldn't\"  \n         * typically occur, and if it does, the kernel will emit a chain \n         * of messages in any case. Here, we use the WARN_ONCE()\n         * macro pedantically, and as this is a 'learning' program.. */\n        goto out_fail1;\n    }\n    pr_info(\"kmalloc() succeeds, (actual KVA) ret value = %px\\n\", gkptr);\n    /* We use the %px format specifier here to show the actual KVA; in production, Don't! */\n    print_hex_dump_bytes(\"gkptr before memset: \", DUMP_PREFIX_OFFSET, gkptr, 32);\n    memset(gkptr, 'm', 1024);\n    print_hex_dump_bytes(\" gkptr after memset: \", DUMP_PREFIX_OFFSET, gkptr, 32);\n```", "```\nvoid print_hex_dump_bytes(const char *prefix_str, int prefix_type,\n     const void *buf, size_t len);\n```", "```\n    /* 2\\. Allocate memory for and initialize our 'context' structure */\n    ctx = kzalloc(sizeof(struct myctx), GFP_KERNEL);\n    if (!ctx)\n        goto out_fail2;\n    pr_info(\"%s: context struct alloc'ed and initialized (actual KVA ret = %px)\\n\",\n        OURMODNAME, ctx);\n    print_hex_dump_bytes(\"ctx: \", DUMP_PREFIX_OFFSET, ctx, 32);\n\n    return 0;        /* success */\nout_fail2:\n    kfree(gkptr);\nout_fail1:\n    return -ENOMEM;\n}\n```", "```\nstatic void __exit slab1_exit(void)\n{\n    kfree(ctx);\n kfree(gkptr);\n    pr_info(\"%s: freed slab memory, removed\\n\", OURMODNAME);\n}\n```", "```\n// ch8/slab3_maxsize/slab3_maxsize.c\n[...]\nstatic int stepsz = 200000;\nmodule_param(stepsz, int, 0644);\nMODULE_PARM_DESC(stepsz,\n\"Amount to increase allocation by on each loop iteration (default=200000\");\n\nstatic int test_maxallocsz(void)\n{\n  size_t size2alloc = 0;\n  void *p;\n\n  while (1) {\n      p = kmalloc(size2alloc, GFP_KERNEL);\n      if (!p) {\n          pr_alert(\"kmalloc fail, size2alloc=%zu\\n\", size2alloc);\n          return -ENOMEM;\n      }\n      pr_info(\"kmalloc(%7zu) = 0x%pK\\n\", size2alloc, p);\n      kfree(p);\n size2alloc += stepsz;\n  }\n  return 0;\n}\n```", "```\n$ cat /proc/buddyinfo \nNode 0, zone      DMA    225  154   46   30   14   9   1   1   0   0   0 \nNode 0, zone    DMA32    314  861  326  291  138  50  27   2   5   0   0 \n  order --->               0    1    2    3    4   5   6   7   8   9  10\n```", "```\n$ cat /proc/buddyinfo \nNode 0, zone      DMA      10   2    2    3   3   3   3   2   2   0   0 \nNode 0, zone    DMA32     276 143  349  189  99   3   6   3   6   4   7 \n order --->                0   1    2    3   4   5   6   7   8   9  10\n```", "```\nrpi ~/ $ cat /proc/buddyinfo \nNode 0, zone   Normal    82   32   11   6   5   3   3   3   4   4   160\n```", "```\nrp = kmalloc(struct_size(rp, addr, i), GFP_KERNEL);\n if (!rp) {\n     err = -ENOMEM; [...]\n```", "```\n// include/linux/slab.h\n[...]\n * kmalloc - allocate memory\n * @size: how many bytes of memory are required.\n * @flags: the type of memory to allocate.\n * kmalloc is the normal method of allocating memory\n * for objects smaller than page size in the kernel.\n```", "```\nsize_t ksize(const void *);\n```", "```\nstruct mysmallctx {\n    int tx, rx;\n    char passwd[8], config[4];\n} *ctx;\n\npr_info(\"sizeof struct mysmallctx = %zd bytes\\n\", sizeof(struct mysmallctx));\nctx = kzalloc(sizeof(struct mysmallctx), GFP_KERNEL);\npr_info(\"(context structure allocated and initialized to zero)\\n\"\n        \"*actual* size allocated = %zu bytes\\n\", ksize(ctx));\n```", "```\n$ dmesg\n[...]\nsizeof struct mysmallctx = 20 bytes\n(context structure allocated and initialized to zero)\n*actual* size allocated = 32 bytes\n```", "```\n// ch8/slab4_actualsize/slab4_actualsize.c\nstatic int test_maxallocsz(void)\n{\n    size_t size2alloc = 100, actual_alloced;\n    void *p;\n\n    pr_info(\"kmalloc(      n) :  Actual : Wastage : Waste %%\\n\");\n    while (1) {\n        p = kmalloc(size2alloc, GFP_KERNEL);\n        if (!p) {\n            pr_alert(\"kmalloc fail, size2alloc=%zu\\n\", size2alloc);\n            return -ENOMEM;\n        }\n        actual_alloced = ksize(p);\n        /* Print the size2alloc, the amount actually allocated,\n         * the delta between the two, and the percentage of waste\n         * (integer arithmetic, of course :-)  */\n        pr_info(\"kmalloc(%7zu) : %7zu : %7zu : %3zu%%\\n\",\n              size2alloc, actual_alloced, (actual_alloced-size2alloc),\n              (((actual_alloced-size2alloc)*100)/size2alloc));        kfree(p);\n        size2alloc += stepsz;\n    }\n    return 0;\n}\n```", "```\n[...]\n[92.273695] kmalloc(1600100) : 2097152 :  497052 : 31%\n[92.274337] kmalloc(1800100) : 2097152 :  297052 : 16%\n[92.275292] kmalloc(2000100) : 2097152 :   97052 :  4%\n[92.276297] kmalloc(2200100) : 4194304 : 1994204 : 90%\n[92.277015] kmalloc(2400100) : 4194304 : 1794204 : 74%\n[92.277698] kmalloc(2600100) : 4194304 : 1594204 : 61%\n[...]\n```", "```\ngnuplot> set title \"Slab/Page Allocator: Requested vs Actually allocated size Wastage in Percent\"\ngnuplot> set xlabel \"Required size\"\ngnuplot> set ylabel \"%age Waste\"\ngnuplot> plot \"2plotdata.txt\" using 1:100 title \"Required Size\" with points, \"2plotdata.txt\" title \"Wastage %age\" with linespoints \ngnuplot> \n```"]