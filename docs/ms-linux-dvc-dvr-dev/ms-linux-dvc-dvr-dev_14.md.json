["```\nstruct pci_dev {\n\u00a0\u00a0struct pci_bus\u00a0\u00a0\u00a0\u00a0*bus; /* Bus this device is on */\n\u00a0\u00a0struct pci_bus *subordinate; /* Bus this device bridges to */\n\u00a0\u00a0\u00a0\u00a0struct proc_dir_entry *procent;\n\u00a0\u00a0\u00a0\u00a0struct pci_slot\t\t*slot;\n\u00a0\u00a0\u00a0\u00a0unsigned short\tvendor;\n\u00a0\u00a0\u00a0\u00a0unsigned short\tdevice;\n\u00a0\u00a0\u00a0\u00a0unsigned short\tsubsystem_vendor;\n\u00a0\u00a0\u00a0\u00a0unsigned short\tsubsystem_device;\n\u00a0\u00a0\u00a0\u00a0unsigned int\t\tclass;\n\u00a0\u00a0\u00a0/* 3 bytes: (base,sub,prog-if) */\n\u00a0\u00a0\u00a0u8 revision;\u00a0\u00a0\u00a0\u00a0\u00a0/* PCI revision, low byte of class word */\n\u00a0\u00a0\u00a0u8 hdr_type; /* PCI header type (multi' flag masked out) */\n\u00a0\u00a0\u00a0u8 pin;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0/* Interrupt pin this device uses */\n\u00a0\u00a0\u00a0struct pci_driver *driver; /* Driver bound to this device */\n\u00a0\u00a0\u00a0u64\tdma_mask;\n\u00a0\u00a0\u00a0struct device_dma_parameters dma_parms;\n\u00a0\u00a0\u00a0\u00a0struct device\t\tdev;\n\u00a0\u00a0\u00a0\u00a0int\tcfg_size;\n\u00a0\u00a0\u00a0\u00a0unsigned int\tirq;\n[...]\n\u00a0\u00a0\u00a0\u00a0unsigned int\t\tno_msi:1;\t/* May not use MSI */\n\u00a0\u00a0\u00a0\u00a0unsigned int no_64bit_msi:1; /* May only use 32-bit MSIs */\n\u00a0\u00a0\u00a0\u00a0unsigned int msi_enabled:1;\n\u00a0\u00a0\u00a0\u00a0unsigned int msix_enabled:1; \u00a0\u00a0\u00a0\u00a0atomic_t enable_cnt;\n[...]\n};\n```", "```\nstruct pci_device_id {\n\u00a0\u00a0\u00a0\u00a0u32 vendor, device;\n\u00a0\u00a0\u00a0\u00a0u32 subvendor, subdevice;\n\u00a0\u00a0\u00a0\u00a0u32 class, class_mask;\n\u00a0\u00a0\u00a0\u00a0kernel_ulong_t driver_data;\n};\n```", "```\nstatic const struct pci_device_id bt8xxgpio_pci_tbl[] = {\n\u00a0\u00a0{ PCI_DEVICE(PCI_VENDOR_ID_BROOKTREE, PCI_DEVICE_ID_BT848) },\n\u00a0\u00a0{ PCI_DEVICE(PCI_VENDOR_ID_BROOKTREE, PCI_DEVICE_ID_BT849) },\n\u00a0\u00a0{ PCI_DEVICE(PCI_VENDOR_ID_BROOKTREE, PCI_DEVICE_ID_BT878) },\n\u00a0\u00a0{ PCI_DEVICE(PCI_VENDOR_ID_BROOKTREE, PCI_DEVICE_ID_BT879) },\n\u00a0\u00a0{ 0, },\n};\n```", "```\nMODULE_DEVICE_TABLE(pci, bt8xxgpio_pci_tbl);\n```", "```\nstruct pci_driver {\n\u00a0\u00a0\u00a0const char *name;\n\u00a0\u00a0\u00a0const struct pci_device_id *id_table; int (*probe)(struct \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pci_dev *dev,\n\u00a0\u00a0\u00a0const struct pci_device_id *id); void (*remove)(struct \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pci_dev *dev);\n\u00a0\u00a0\u00a0int (*suspend)(struct pci_dev *dev, pm_message_t state);\u00a0\u00a0\u00a0int (*resume) (struct pci_dev *dev);\t/* Device woken up */\n\u00a0\u00a0\u00a0void (*shutdown) (struct pci_dev *dev); [...]\n};\n```", "```\nstatic struct pci_driver bt8xxgpio_pci_driver = {\n\u00a0\u00a0\u00a0\u00a0.name\t\t= \"bt8xxgpio\",\n\u00a0\u00a0\u00a0\u00a0.id_table\t= bt8xxgpio_pci_tbl,\n\u00a0\u00a0\u00a0\u00a0.probe\t\t= bt8xxgpio_probe,\n\u00a0\u00a0\u00a0\u00a0.remove\t= bt8xxgpio_remove,\n\u00a0\u00a0\u00a0\u00a0.suspend\t= bt8xxgpio_suspend,\n\u00a0\u00a0\u00a0\u00a0.resume\t= bt8xxgpio_resume,\n};\n```", "```\nstatic int init pci_foo_init(void)\n{\n\u00a0\u00a0\u00a0\u00a0return pci_register_driver(&bt8xxgpio_pci_driver);\n}\n```", "```\nstatic void exit pci_foo_exit(void)\n{\n\u00a0\u00a0\u00a0\u00a0pci_unregister_driver(&bt8xxgpio_pci_driver);\n}\n```", "```\nmodule_pci_driver(bt8xxgpio_pci_driver);\n```", "```\nint pci_enable_device(struct pci_dev *dev)\n```", "```\nint err;\n\u00a0\u00a0\u00a0\u00a0err = pci_enable_device(pci_dev); \u00a0\u00a0\u00a0\u00a0if (err) {\n\u00a0\u00a0\u00a0\u00a0printk(KERN_ERR \"foo_dev: Can't enable device.\\n\");\n\u00a0\u00a0\u00a0\u00a0return err;\n}\n```", "```\nvoid pci_disable_device(struct pci_dev *dev)\n```", "```\nvoid pci_set_master(struct pci_dev *dev)\nvoid pci_clear_master(struct pci_dev *dev)\n```", "```\nint pci_read_config_byte(struct pci_dev *dev, int where, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u8 *val);\nint pci_read_config_word(struct pci_dev *dev, int where, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u16 *val);\nint pci_read_config_dword(struct pci_dev *dev, int where, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u32 *val);\n```", "```\nint pci_write_config_byte(struct pci_dev *dev, int where, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u8 val);\nint pci_write_config_word(struct pci_dev *dev, int where, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u16 val);\nint pci_write_config_dword(struct pci_dev *dev, int where, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0u32 val);\n```", "```\n#define\tPCI_VENDOR_ID\t0x00\t/*\t16\tbits\t*/\n#define\tPCI_DEVICE_ID\t0x02\t/*\t16\tbits\t*/\n#define\tPCI_STATUS\t\t0x06\t/*\t16\tbits\t*/\n#define PCI_CLASS_REVISION\u00a0\u00a00x08\u00a0\u00a0/* High 24 bits are class, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0low 8 revision */\n#define\u00a0\u00a0\u00a0\u00a0PCI_REVISION_ID\u00a0\u00a0\u00a00x08\u00a0\u00a0/* Revision ID */\n#define\u00a0\u00a0\u00a0\u00a0PCI_CLASS_PROG\u00a0\u00a0\u00a0\u00a00x09\u00a0\u00a0/* Reg. Level Programming \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Interface */\n#define\u00a0\u00a0\u00a0\u00a0PCI_CLASS_DEVICE\u00a0\u00a00x0a\u00a0\u00a0/* Device class */\n[...]\t\n```", "```\nstatic unsigned char foo_get_revision(struct pci_dev *dev)\n{\n\u00a0\u00a0\u00a0\u00a0u8 revision;\n\u00a0\u00a0\u00a0\u00a0pci_read_config_byte(dev, PCI_REVISION_ID, &revision);\n\u00a0\u00a0\u00a0\u00a0return revision;\n}\n```", "```\nstruct resource *request_mem_region (unsigned long start,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long n, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *name)\nvoid iomem *ioremap(unsigned long phys_addr, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long size);\n```", "```\nunsigned long bar0_base; unsigned long bar0_size;\nvoid iomem *bar0_map_membase;\n/* Get the PCI Base Address Registers */\nbar0_base = pci_resource_start(pdev, 0);\nbar0_size = pci_resource_len(pdev, 0);\n/*  * think about managed version and use  * devm_request_mem_regions()\t */\nif (request_mem_region(bar0_base, bar0_size, \"bar0-mapping\")) {\n\u00a0\u00a0\u00a0\u00a0/* there is an error */\n\u00a0\u00a0\u00a0\u00a0goto err_disable;\n}\n/* Think about managed version and use devm_ioremap instead */ bar0_map_membase = ioremap(bar0_base, bar0_size);\nif (!bar0_map_membase) {\n\u00a0\u00a0\u00a0\u00a0/* error */\n\u00a0\u00a0\u00a0\u00a0goto err_iomap;\n}\n/* Now we can use ioread32()/iowrite32() on bar0_map_membase*/\n```", "```\nint pci_request_region(struct pci_dev *pdev, int bar,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *res_name)\nint pci_request_regions(struct pci_dev *pdev, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0const char *res_name)\nvoid iomem *pci_iomap(struct pci_dev *dev, int bar,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long maxlen)\nvoid iomem *pci_iomap_range(struct pci_dev *dev, int bar,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long offset, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long maxlen)\nvoid iomem *pci_ioremap_bar(struct pci_dev *pdev, int bar)\nvoid pci_iounmap(struct pci_dev *dev, void iomem *addr)\nvoid pci_release_regions(struct pci_dev *pdev)\n```", "```\n#define DRV_NAME \"foo-drv\"\nvoid iomem *bar1_map_membase;\nint err;\nerr = pci_request_regions(pci_dev, DRV_NAME);\nif (err) {\n\u00a0\u00a0\u00a0\u00a0/* an error occured */ goto error;\n}\nbar1_map_membase = pci_iomap(pdev, 1, 0);\nif (!bar1_map_membase) {\n\u00a0\u00a0\u00a0\u00a0/* an error occured */\n\u00a0\u00a0\u00a0\u00a0goto err_iomap;\n}\n```", "```\nunsigned long flags = pci_resource_flags(pci_dev, bar);\nif (flags & IORESOURCE_IO)\n\u00a0\u00a0\u00a0\u00a0/* using request_region() */\nelse if (flag & IORESOURCE_MEM)\n\u00a0\u00a0\u00a0\u00a0/* using request_mem_region() */\n```", "```\nvoid iomem *pci_iomap_range(struct pci_dev *dev, int bar,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long offset, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned long maxlen)\n{\n\u00a0\u00a0\u00a0\u00a0resource_size_t start = pci_resource_start(dev, bar);\n\u00a0\u00a0\u00a0\u00a0resource_size_t len = pci_resource_len(dev, bar);\n\u00a0\u00a0\u00a0\u00a0unsigned long flags = pci_resource_flags(dev, bar);\n\u00a0\u00a0\u00a0\u00a0if (len <= offset || !start)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return NULL;\n\u00a0\u00a0\u00a0\u00a0len -= offset; start += offset;\n\u00a0\u00a0\u00a0\u00a0if (maxlen && len > maxlen)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0len = maxlen;\n\u00a0\u00a0\u00a0\u00a0if (flags & IORESOURCE_IO)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return pci_ioport_map(dev, start, len);\n\u00a0\u00a0\u00a0\u00a0if (flags & IORESOURCE_MEM)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return ioremap(start, len);\n\u00a0\u00a0\u00a0\u00a0/* What? */\n\u00a0\u00a0\u00a0\u00a0return NULL;\n}\n```", "```\nu8 inb(unsigned long port);\nu16 inw(unsigned long port);\nu32 inl(unsigned long port);\nvoid outb(u8 value, unsigned long port);\nvoid outw(u16 value, unsigned long port);\nvoid outl(u32 value, unsigned long port);\n```", "```\nint pci_alloc_irq_vectors(struct pci_dev *dev, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int min_vecs,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int max_vecs, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int flags);\n```", "```\nint pci_irq_vector(struct pci_dev *dev, unsigned int nr);\n```", "```\nint pci_irq_vector(struct pci_dev *dev, unsigned int nr)\n{\n\u00a0\u00a0\u00a0\u00a0if (dev->msix_enabled) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct msi_desc *entry;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int i = 0;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for_each_pci_msi_entry(entry, dev) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (i == nr)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return entry->irq;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0i++;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0WARN_ON_ONCE(1);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -EINVAL;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0if (dev->msi_enabled) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct msi_desc *entry = first_pci_msi_entry(dev);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (WARN_ON_ONCE(nr >= entry->nvec_used))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -EINVAL;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (WARN_ON_ONCE(nr > 0))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -EINVAL;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return dev->irq + nr;\n}\n```", "```\nnvec =\n\u00a0\u00a0\u00a0\u00a0pci_alloc_irq_vectors(pdev, 1, nvec, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PCI_IRQ_MSI | PCI_IRQ_MSIX);\nif (nvec < 0)\n\u00a0\u00a0\u00a0\u00a0goto out_err;\n```", "```\nu8 pin;\npci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);\n/* (1=INTA, 2=INTB, 3=INTD, 4=INTD) */\n```", "```\nvoid pci_assign_irq(struct pci_dev *dev)\n{\n\u00a0\u00a0\u00a0\u00a0int irq = 0; u8 pin;\n\u00a0\u00a0\u00a0\u00a0struct pci_host_bridge *hbrg = \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pci_find_host_bridge(dev->bus);\n\u00a0\u00a0\u00a0\u00a0if (!(hbrg->map_irq)) {\n\u00a0\u00a0\u00a0\u00a0pci_dbg(dev, \"runtime IRQ mapping not provided by arch\\n\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);\n\u00a0\u00a0\u00a0\u00a0if (pin) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0[...]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0irq = (*(hbrg->map_irq))(dev, slot, pin);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (irq == -1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0irq = 0;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0dev->irq = irq;\n\u00a0\u00a0\u00a0\u00a0pci_dbg(dev, \"assign IRQ: got %d\\n\", dev->irq);\n\u00a0\u00a0\u00a0\u00a0/* Always tell the device, so the driver knows what is the\n\u00a0\u00a0\u00a0\u00a0\u00a0* real IRQ to use; the device does not use it. \u00a0\u00a0\u00a0\u00a0\u00a0*/\n\u00a0\u00a0\u00a0\u00a0pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);\n}\n```", "```\nstatic int pci_device_probe(struct device *dev)\n{\n\u00a0\u00a0\u00a0\u00a0int error;\n\u00a0\u00a0\u00a0\u00a0struct pci_dev *pci_dev = to_pci_dev(dev);\n\u00a0\u00a0\u00a0\u00a0struct pci_driver *drv = to_pci_driver(dev->driver); \n\u00a0\u00a0\u00a0\u00a0pci_assign_irq(pci_dev);\n\u00a0\u00a0\u00a0\u00a0error = pcibios_alloc_irq(pci_dev);\n\u00a0\u00a0\u00a0\u00a0if (error < 0)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return error;\n\u00a0\u00a0\u00a0\u00a0pci_dev_get(pci_dev);\n\u00a0\u00a0\u00a0\u00a0if (pci_device_can_probe(pci_dev)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0error = pci_device_probe(drv, pci_dev);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (error) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pcibios_free_irq(pci_dev);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pci_dev_put(pci_dev);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return error;\n}\n```", "```\n\u00a0\u00a0\u00a0\u00a0int err;\n\u00a0\u00a0\u00a0\u00a0/* Try using MSI interrupts */\n\u00a0\u00a0\u00a0\u00a0err = pci_enable_msi(pci_dev);\n\u00a0\u00a0\u00a0\u00a0if (err)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0goto intx;\n\u00a0\u00a0\u00a0\u00a0err = devm_request_irq(&pci_dev->dev, pci_dev->irq,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0my_msi_handler, 0, \"foo-msi\", priv);\n\u00a0\u00a0\u00a0\u00a0if (err) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pci_disable_msi(pci_dev);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0goto intx;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return 0;\n\u00a0\u00a0\u00a0\u00a0/* Try using legacy interrupts */\nintx:\n\u00a0\u00a0\u00a0\u00a0dev_warn(&pci_dev->dev,\n\u00a0\u00a0\u00a0\u00a0\"Unable to use MSI interrupts, falling back to legacy\\n\");\n\u00a0\u00a0\u00a0\u00a0err = devm_request_irq(&pci_dev->dev, pci_dev->irq, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0my_shared_handler, IRQF_SHARED, \"foo-intx\", priv);\n\u00a0\u00a0\u00a0\u00a0if (err) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dev_err(pci_dev->dev, \"no usable interrupts\\n\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return err;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return 0;\n```", "```\ndma_set_mask(struct device *dev, u64 mask);\n```", "```\nint err = 0;\nerr = pci_set_dma_mask(pci_dev, DMA_BIT_MASK(32));\n/* \n * OR the below on a 64 bits system:\n * err = pci_set_dma_mask(dev, DMA_BIT_MASK(64));\n */\nif (err) {\n\u00a0\u00a0\u00a0\u00a0dev_err(&pci_dev->dev,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\"Required dma mask not supported, \\\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0failed to initialize device\\n\");\n\u00a0\u00a0\u00a0\u00a0goto err_disable_pci_dev;\n}\n```", "```\nvoid * pci_alloc_consistent(struct pci_dev *hwdev, size_t size,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dma_addr_t *dma_handle)\n```", "```\npci_free_consistent(dev, size, cpu_addr, dma_handle);\n```", "```\n#define DMA_ADDR_OFFSET\t0x14\n#define DMA_REG_SIZE_OFFSET\t\t0x32\n[...]\nint do_pci_dma (struct pci_dev *pci_dev, int direction, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size_t count)\n{\n\u00a0\u00a0\u00a0\u00a0dma_addr_t dma_pa;\n\u00a0\u00a0\u00a0\u00a0char *dma_va;\n\u00a0\u00a0\u00a0\u00a0void iomem *dma_io;\n\u00a0\u00a0\u00a0\u00a0/* should check errors */\n\u00a0\u00a0\u00a0\u00a0dma_io = pci_iomap(dev, 2, 0);\n\u00a0\u00a0\u00a0\u00a0dma_va = pci_alloc_consistent(&pci_dev->dev, count, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&dma_pa);\n\u00a0\u00a0\u00a0\u00a0if (!dma_va)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -ENOMEM;\n\u00a0\u00a0\u00a0\u00a0/* may need to clear allocated region */\n\u00a0\u00a0\u00a0\u00a0memset(dma_va, 0, count);\n\u00a0\u00a0\u00a0\u00a0/* set up the device */\n\u00a0\u00a0\u00a0\u00a0iowrite8(CMD_DISABLE_DMA, dma_io + REG_CMD_OFFSET); \n\u00a0\u00a0\u00a0\u00a0iowrite8(direction ? CMD_WR : CMD_RD);\n\u00a0\u00a0\u00a0\u00a0/* Send bus address to the device */\n\u00a0\u00a0\u00a0\u00a0iowrite32(dma_pa, dma_io + DMA_ADDR_OFFSET);\n\u00a0\u00a0\u00a0\u00a0/* Send size to the device */\n\u00a0\u00a0\u00a0\u00a0iowrite32(count, dma_io + DMA_REG_SIZE_OFFSET);\n\u00a0\u00a0\u00a0\u00a0/* Start the operation */\n\u00a0\u00a0\u00a0\u00a0iowrite8(CMD_ENABLE_DMA, dma_io + REG_CMD_OFFSET);\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```\ndma_addr_t pci_map_single(struct pci_dev *hwdev, void *ptr,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size_t size, int direction)\n```", "```\nVoid pci_unmap_single(struct pci_dev *hwdev, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0dma_addr_t dma_addr,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0size_t size, int direction)\n```", "```\nint do_pci_dma (struct pci_dev *pci_dev, int direction,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0void *buffer, size_t count)\n{\n\u00a0\u00a0\u00a0\u00a0dma_addr_t dma_pa;\n\u00a0\u00a0\u00a0\u00a0/* bus address */\n\u00a0\u00a0\u00a0\u00a0void iomem *dma_io;\n\u00a0\u00a0\u00a0\u00a0/* should check errors */\n\u00a0\u00a0\u00a0\u00a0dma_io = pci_iomap(dev, 2, 0);\n\u00a0\u00a0\u00a0\u00a0dma_dir = (write ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\u00a0\u00a0\u00a0\u00a0dma_pa = pci_map_single(pci_dev, buffer, count, dma_dir);\n\u00a0\u00a0\u00a0\u00a0if (!dma_va)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -ENOMEM;\n\u00a0\u00a0\u00a0\u00a0/* may need to clear allocated region */\n\u00a0\u00a0\u00a0\u00a0memset(dma_va, 0, count);\n\u00a0\u00a0\u00a0\u00a0/* set up the device */\n\u00a0\u00a0\u00a0\u00a0iowrite8(CMD_DISABLE_DMA, dma_io + REG_CMD_OFFSET);\n\u00a0\u00a0\u00a0\u00a0iowrite8(direction ? CMD_WR : CMD_RD);\n\u00a0\u00a0\u00a0\u00a0/* Send bus address to the device */\n\u00a0\u00a0\u00a0\u00a0iowrite32(dma_pa, dma_io + DMA_ADDR_OFFSET);\n\u00a0\u00a0\u00a0\u00a0/* Send size to the device */\n\u00a0\u00a0\u00a0\u00a0iowrite32(count, dma_io + DMA_REG_SIZE_OFFSET);\n\u00a0\u00a0\u00a0\u00a0/* Start the operation */\n\u00a0\u00a0\u00a0\u00a0iowrite8(CMD_ENABLE_DMA, dma_io + REG_CMD_OFFSET);\n\u00a0\u00a0\u00a0\u00a0return 0;\n}\n```", "```\nvoid pci_dma_interrupt(int irq, void *dev_id)\n{\n\u00a0\u00a0\u00a0\u00a0struct private_struct *priv = \u00a0\u00a0\u00a0\u00a0(struct private_struct *) dev_id;\n\u00a0\u00a0\u00a0\u00a0/* Unmap the DMA buffer */\n\u00a0\u00a0\u00a0\u00a0pci_unmap_single(priv->pci_dev, priv->dma_addr,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0priv->dma_size, priv->dma_dir);\n\u00a0\u00a0\u00a0\u00a0/* now it is safe to access the buffer */\n\u00a0\u00a0\u00a0\u00a0[...]\n}\n```", "```\nu32 *wbuf1, *wbuf2, *wbuf3;\nstruct scatterlist sgl[3];\nint num_mapped;\nwbuf1 = kzalloc(PAGE_SIZE, GFP_DMA);\nwbuf2 = kzalloc(PAGE_SIZE, GFP_DMA);\n/* size may be different for the last entry */\nwbuf3 = kzalloc(CUSTOM_SIZE, GFP_DMA); \nsg_init_table(sg, 3);\nsg_set_buf(&sgl[0], wbuf1, PAGE_SIZE);\nsg_set_buf(&sgl[1], wbuf2, PAGE_SIZE);\nsg_set_buf(&sgl[2], wbuf3, CUSTOM_SIZE);\nnum_mapped = pci_map_sg(NULL, sgl, 3, PCI_DMA_BIDIRECTIONAL);\n```", "```\nstatic int pci_map_memory(struct page **pages,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unsigned int num_entries,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0struct sg_table *st)\n{\n\u00a0\u00a0\u00a0\u00a0struct scatterlist *sg;\n\u00a0\u00a0\u00a0\u00a0int i;\n\u00a0\u00a0\u00a0\u00a0if (sg_alloc_table(st, num_entries, GFP_KERNEL))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0goto err;\n\u00a0\u00a0\u00a0\u00a0for_each_sg(st->sgl, sg, num_entries, i)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sg_set_page(sg, pages[i], PAGE_SIZE, 0);\n\u00a0\u00a0\u00a0\u00a0if (!pci_map_sg(priv.pcidev, st->sgl, st->nents, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0PCI_DMA_BIDIRECTIONAL))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0goto err;\n\u00a0\u00a0\u00a0\u00a0return 0;\nerr:\n\u00a0\u00a0\u00a0\u00a0sg_free_table(st);\n\u00a0\u00a0\u00a0\u00a0return -ENOMEM;\n}\n```"]