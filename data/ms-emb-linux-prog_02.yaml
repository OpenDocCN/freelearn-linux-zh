- en: Chapter 2. Learning About Toolchains
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。了解工具链
- en: The toolchain is the first element of embedded Linux and the starting point
    of your project. The choices you make at this early stage will have a profound
    impact on the final outcome. Your toolchain should be capable of making effective
    use of your hardware by using the optimum instruction set for your processor,
    using the floating point unit if there is one, and so on. It should support the
    languages that you require and have a solid implementation of POSIX and other
    system interfaces. Not only that, but it should be updated when security flaws
    are discovered or bugs found. Finally, it should be constant throughout the project.
    In other words, once you have chosen your toolchain it is important to stick with
    it. Changing compilers and development libraries in an inconsistent way during
    a project will lead to subtle bugs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链是嵌入式Linux的第一个元素，也是项目的起点。在这个早期阶段做出的选择将对最终结果产生深远影响。您的工具链应能够有效地利用硬件，使用处理器的最佳指令集，使用浮点单元（如果有的话）等。它应该支持您需要的语言，并且具有对POSIX和其他系统接口的稳固实现。此外，发现安全漏洞或错误时，应及时更新。最后，它应该在整个项目中保持不变。换句话说，一旦选择了工具链，坚持使用它是很重要的。在项目进行过程中以不一致的方式更改编译器和开发库将导致隐蔽的错误。
- en: Obtaining a toolchain is as simple as downloading and installing a package.
    But, the toolchain itself is a complex thing, as I will show you in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 获得工具链就像下载和安装一个软件包一样简单。但是，工具链本身是一个复杂的东西，我将在本章中向您展示。
- en: What is a toolchain?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是工具链？
- en: 'A toolchain is the set of tools that compiles source code into executables
    that can run on your target device, and includes a compiler, a linker, and run-time
    libraries. Initially, you need one to build the other three elements of an embedded
    Linux system: the bootloader, the kernel, and the root filesystem. It has to be
    able to compile code written in assembly, C, and C++ since these are the languages
    used in the base open source packages.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链是将源代码编译成可在目标设备上运行的可执行文件的一组工具，包括编译器、链接器和运行时库。最初，您需要一个工具链来构建嵌入式Linux系统的另外三个元素：引导加载程序、内核和根文件系统。它必须能够编译用汇编、C和C++编写的代码，因为这些是基本开源软件包中使用的语言。
- en: Usually, toolchains for Linux are based on components from the GNU project ([http://www.gnu.org](http://www.gnu.org))
    and that is still true in the majority of cases at the time of writing. However,
    over the past few years, the Clang compiler and the associated LLVM project ([http://llvm.org](http://llvm.org))
    have progressed to the point that it is now a viable alternative to a GNU toolchain.
    One major distinction between LLVM and GNU-based toolchains is in the licensing;
    LLVM has a BSD license, while GNU has the GPL. There are some technical advantages
    to Clang as well, such as faster compilation and better diagnostics, but GNU GCC
    has the advantage of compatibility with the existing code base and support for
    a wide range of architectures and operating systems. Indeed, there are still some
    areas where Clang cannot replace the GNU C compiler, especially when it comes
    to compiling a mainline Linux kernel. It is probable that, in the next year or
    so, Clang will be able to compile all the components needed for embedded Linux
    and so will become an alternative to GNU. There is a good description of how to
    use Clang for cross compilation at [http://clang.llvm.org/docs/CrossCompilation.html](http://clang.llvm.org/docs/CrossCompilation.html).
    If you would like to use it as part of an embedded Linux build system, the EmbToolkit
    ([https://www.embtoolkit.org](https://www.embtoolkit.org)) fully supports both
    GNU and LLVM/Clang toolchains and various people are working on using Clang with
    Buildroot and the Yocto Project. I will cover embedded build systems in [Chapter
    6](ch06.html "Chapter 6. Selecting a Build System"), *Selecting a Build System*.
    Meanwhile, this chapter focuses on the GNU toolchain as it is the only complete
    option at this time.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Linux的工具链是基于GNU项目（[http://www.gnu.org](http://www.gnu.org)）的组件构建的，这在撰写本文时仍然是大多数情况下的情况。然而，在过去的几年里，Clang编译器和相关的LLVM项目（[http://llvm.org](http://llvm.org)）已经发展到了可以成为GNU工具链的可行替代品的地步。LLVM和基于GNU的工具链之间的一个主要区别在于许可证；LLVM采用BSD许可证，而GNU采用GPL。Clang也有一些技术优势，比如更快的编译速度和更好的诊断，但GNU
    GCC具有与现有代码库的兼容性和对各种体系结构和操作系统的支持。事实上，仍然有一些领域Clang无法取代GNU C编译器，特别是在编译主流Linux内核时。很可能，在未来一年左右的时间里，Clang将能够编译嵌入式Linux所需的所有组件，因此将成为GNU的替代品。在[http://clang.llvm.org/docs/CrossCompilation.html](http://clang.llvm.org/docs/CrossCompilation.html)上有一个关于如何使用Clang进行交叉编译的很好的描述。如果您想将其作为嵌入式Linux构建系统的一部分使用，EmbToolkit（[https://www.embtoolkit.org](https://www.embtoolkit.org)）完全支持GNU和LLVM/Clang工具链，并且有许多人正在努力使用Clang与Buildroot和Yocto
    Project。我将在[第6章](ch06.html "第6章。选择构建系统")中介绍嵌入式构建系统，*选择构建系统*。与此同时，本章将重点介绍GNU工具链，因为这是目前唯一的完整选项。
- en: 'A standard GNU toolchain consists of three main components:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的GNU工具链由三个主要组件组成：
- en: '**Binutils**: A set of binary utilities including the assembler, and the linker,
    ld. It is available at [http://www.gnu.org/software/binutils/](http://www.gnu.org/software/binutils/).'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Binutils**：一组二进制实用程序，包括汇编器和链接器ld。它可以在[http://www.gnu.org/software/binutils/](http://www.gnu.org/software/binutils/)上获得。'
- en: '**GNU Compiler Collection (GCC)**: These are the compilers for C and other
    languages which, depending on the version of GCC, include C++, Objective-C, Objective-C++,
    Java, Fortran, Ada, and Go. They all use a common back-end which produces assembler
    code which is fed to the GNU assembler. It is available at [http://gcc.gnu.org/](http://gcc.gnu.org/).'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GNU编译器集合（GCC）**：这些是C和其他语言的编译器，根据GCC的版本，包括C++、Objective-C、Objective-C++、Java、Fortran、Ada和Go。它们都使用一个通用的后端，生成汇编代码，然后传递给GNU汇编器。它可以在[http://gcc.gnu.org/](http://gcc.gnu.org/)上获得。'
- en: '**C library**: A standardized API based on the POSIX specification which is
    the principle interface to the operating system kernel from applications. There
    are several C libraries to consider, see the following section.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C库：基于POSIX规范的标准化API，是应用程序与操作系统内核之间的主要接口。有几个C库需要考虑，见下一节。
- en: As well as these, you will need a copy of the Linux kernel headers, which contain
    definitions and constants that are needed when accessing the kernel directly.
    Right now, you need them to be able to compile the C library, but you will also
    need them later when writing programs or compiling libraries that interact with
    particular Linux devices, for example to display graphics via the Linux frame
    buffer driver. This is not simply a question of making a copy of the header files
    in the include directory of your kernel source code. Those headers are intended
    for use in the kernel only and contain definitions that will cause conflicts if
    used in their raw state to compile regular Linux applications.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，您还需要一份Linux内核头文件的副本，其中包含在直接访问内核时所需的定义和常量。现在，您需要它们来编译C库，但以后在编写程序或编译与特定Linux设备交互的库时也会需要它们，例如通过Linux帧缓冲驱动程序显示图形。这不仅仅是将头文件复制到内核源代码的include目录中的问题。这些头文件仅供内核使用，并包含原始状态下用于编译常规Linux应用程序会导致冲突的定义。
- en: Instead, you will need to generate a set of sanitized kernel headers which I
    have illustrated in [Chapter 5](ch05.html "Chapter 5. Building a Root Filesystem"),
    *Building a Root Filesystem*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您需要生成一组经过清理的内核头文件，我在[第5章](ch05.html "第5章。构建根文件系统") *构建根文件系统*中进行了说明。
- en: It is not usually crucial whether the kernel headers are generated from the
    exact version of Linux you are going to be using or not. Since the kernel interfaces
    are always backwards-compatible, it is only necessary that the headers are from
    a kernel that is the same as or older than the one you are using on the target.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通常并不重要内核头文件是否是从您将要使用的Linux的确切版本生成的。由于内核接口始终向后兼容，只需要头文件来自于与目标上使用的内核相同或更旧的内核即可。
- en: Most people would consider the GNU debugger, GDB, to be part of the toolchain
    as well, and it is usual that it is built at this point. I will talk about GDB
    in [Chapter 12](ch12.html "Chapter 12. Debugging with GDB"), *Debugging with GDB*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人认为GNU调试器GDB也是工具链的一部分，并且通常在这一点上构建它。我将在[第12章](ch12.html "第12章。使用GDB进行调试")
    *使用GDB进行调试*中讨论GDB。
- en: Types of toolchain - native versus cross toolchain
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具链类型 - 本地与交叉工具链
- en: 'For our purposes, there are two types of toolchain:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，有两种类型的工具链：
- en: '**Native**: This toolchain runs on the same type of system, sometimes the same
    actual system, as the programs it generates. This is the usual case for desktops
    and servers, and it is becoming popular on certain classes of embedded devices.
    The Raspberry Pi running Debian for ARM, for example, has self-hosted native compilers.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地：这个工具链在与生成的程序相同类型的系统上运行，有时甚至是同一台实际系统。这是桌面和服务器的常见情况，并且在某些嵌入式设备类别上变得流行。例如，运行Debian
    for ARM的树莓派具有自托管的本地编译器。
- en: '**Cross**: This toolchain runs on a different type of system than the target,
    allowing the development to be done on a fast desktop PC and then loaded onto
    the embedded target for testing.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交叉：这个工具链在与目标不同类型的系统上运行，允许在快速桌面PC上进行开发，然后加载到嵌入式目标进行测试。
- en: Almost all embedded Linux development is done using a cross development toolchain,
    partly because most embedded devices are not well suited to program development
    since they lack computing power, memory, and storage, but also because it keeps
    the host and target environments separate. The latter point is especially important
    when the host and the target are using the same architecture, X86_64, for example.
    In this case, it is tempting to compile natively on the host and simply copy the
    binaries to the target. This works up to a point but it is likely that the host
    distribution will receive updates more often than the target, that different engineers
    building code for the target will have slightly different versions of the host
    development libraries and so you will violate the principle that the toolchain
    should remain constant throughout the life of the project. You can make this approach
    work if you ensure that the host and target build environments are in lockstep
    with each other, but a much better approach is to keep the host and the target
    separate, and a cross toolchain is a way to do that.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有嵌入式Linux开发都是使用交叉开发工具链完成的，部分原因是大多数嵌入式设备不适合程序开发，因为它们缺乏计算能力、内存和存储空间，另一部分原因是它保持了主机和目标环境的分离。当主机和目标使用相同的架构，例如X86_64时，后一点尤为重要。在这种情况下，诱人的是在主机上进行本地编译，然后简单地将二进制文件复制到目标上。这在一定程度上是有效的，但很可能主机发行版会比目标更频繁地接收更新，为目标构建代码的不同工程师将具有略有不同版本的主机开发库，因此您将违反工具链在项目生命周期内保持恒定的原则。如果确保主机和目标构建环境保持同步，您可以使这种方法奏效，但更好的方法是保持主机和目标分开，交叉工具链是实现这一点的一种方式。
- en: However, there is a counter argument in favor of native development. Cross development
    creates the burden of cross-compiling all the libraries and tools that you need
    for your target. We will see later on in this chapter that cross-compiling is
    not always simple because most open source packages are not designed to be built
    in this way. Integrated build tools, including Buildroot and the Yocto Project,
    help by encapsulating the rules to cross compile a range of packages that you
    need in typical embedded systems but, if you want to compile a large number of
    additional packages, then it is better to natively compile them. For example,
    to provide a Debian distribution for the Raspberry Pi or BeagleBone using a cross
    compiler is impossible, they have to be natively compiled. Creating a native build
    environment from scratch is not easy and involves creating a cross compiler first
    to bootstrap a native build environment on the target and using that to build
    packages. You would need a build farm of well-provisioned target boards or you
    may be able to use QEMU to emulate the target. If you want to look into this further,
    you may want to look at the Scratchbox project, now in its second incarnation
    as Scratchbox2 ([https://maemo.gitorious.org/scratchbox2](https://maemo.gitorious.org/scratchbox2)).
    It was developed by Nokia to build their Maemo Linux operating system, and is
    used today by the Mer project and the Tizen project, among others.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个支持本地开发的反对意见。跨平台开发需要跨编译所有你需要的库和工具到你的目标平台上。我们将在本章后面看到，跨编译并不总是简单的，因为大多数开源软件包并不是设计成这种方式构建的。集成构建工具，包括Buildroot和Yocto项目，通过封装交叉编译一系列typical嵌入式系统中需要的软件包的规则来帮助，但是，如果你想编译大量额外的软件包，最好是本地编译它们。例如，使用交叉编译器为树莓派或BeagleBone提供Debian发行版是不可能的，它们必须本地编译。从头开始创建本地构建环境并不容易，需要首先创建一个交叉编译器来引导目标上的本地构建环境，并使用它来构建软件包。你需要一个充分配置的目标板的构建农场，或者你可以使用QEMU来模拟目标。如果你想进一步了解这一点，你可能想看看Scratchbox项目，现在已经发展到了第二代Scratchbox2。它是由诺基亚开发的，用于构建他们的Maemo
    Linux操作系统，今天被Mer项目和Tizen项目等使用。
- en: Meanwhile, in this chapter, I will focus on the more mainstream cross compiler
    environment, which is relatively easy to set up and administer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，在本章中，我将专注于更主流的交叉编译器环境，这相对容易设置和管理。
- en: CPU architectures
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU架构
- en: 'The toolchain has to be built according to the capabilities of the target CPU,
    which includes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链必须根据目标CPU的能力进行构建，其中包括：
- en: '**CPU architecture**: arm, mips, x86_64, and so on'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU架构**：arm、mips、x86_64等'
- en: '**Big- or little-endian operation**: Some CPUs can operate in both modes, but
    the machine code is different for each'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大端或小端操作**：一些CPU可以在两种模式下运行，但每种模式的机器码是不同的。'
- en: '**Floating point support**: Not all versions of embedded processors implement
    a hardware floating point unit, in which case, the toolchain can be configured
    to call a software floating point library instead'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点支持**：并非所有版本的嵌入式处理器都实现了硬件浮点单元，如果是这样，工具链可以配置为调用软件浮点库。'
- en: '**Application Binary Interface (ABI)**: The calling convention used for passing
    parameters between function calls'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用二进制接口（ABI）**：用于在函数调用之间传递参数的调用约定'
- en: 'With many architectures, the ABI is constant across the family of processors.
    One notable exception is ARM. The ARM architecture transitioned to the **Extended
    Application Binary Interface** (**EABI**) in the late 2000''s, resulting in the
    previous ABI being named the **Old Application Binary Interface** (**OABI**).
    While the OABI is now obsolete, you continue to see references to EABI. Since
    then, the EABI has split into two, based on the way that floating point parameters
    are passed. The original EABI uses general purpose (integer) registers while the
    newer EABIHF uses floating point registers. The EABIHF is significantly faster
    at floating point operations since it removes the need for copying between integer
    and floating point registers, but it is not compatible with CPUs that do not have
    a floating point unit. The choice, then, is between two incompatible ABIs: you
    cannot mix and match the two and so you have to decide at this stage.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多体系结构，ABI在处理器系列中是恒定的。一个值得注意的例外是ARM。ARM架构在2000年代后期过渡到了扩展应用二进制接口（EABI），导致以前的ABI被命名为旧应用二进制接口（OABI）。虽然OABI现在已经过时，但你仍然会看到有关EABI的引用。从那时起，EABI分为两个，基于传递浮点参数的方式。原始的EABI使用通用寄存器（整数）寄存器，而新的EABIHF使用浮点寄存器。EABIHF在浮点运算方面显着更快，因为它消除了整数和浮点寄存器之间的复制需求，但它与没有浮点单元的CPU不兼容。因此，选择是在两种不兼容的ABI之间：你不能混合使用这两种，因此你必须在这个阶段做出决定。
- en: 'GNU uses a prefix to the tools to identify the various combinations that can
    be generated, consisting of a tuple of three or four components separated by dashes,
    as described here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: GNU使用前缀来标识可以生成的各种组合，由三到四个由破折号分隔的组件元组组成，如下所述：
- en: '**CPU**: The CPU architecture, such as arm, mips, or x86_64\. If the CPU has
    both endian modes, they may be differentiated by adding el for little-endian,
    or eb for big-endian. Good examples are little-endian MIPS, mipsel and big-endian
    ARM, armeb.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU**：CPU架构，如arm、mips或x86_64。如果CPU有两种字节序模式，可以通过添加el表示小端，或者eb表示大端来区分。很好的例子是小端MIPS，mipsel和大端ARM，armeb。'
- en: '**Vendor**: This identifies the provider of the toolchain. Examples include
    buildroot, poky, or just unknown. Sometimes it is left out altogether.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供应商**：这标识了工具链的提供者。例如buildroot、poky或者unknown。有时会完全省略。'
- en: '**Kernel**: For our purposes, it is always ''linux''.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核**：对于我们的目的，它总是''linux''。'
- en: '**Operating system**: A name for the user space component, which might be `gnu`
    or `uclibcgnu`. The ABI may be appended here as well so, for ARM toolchains, you
    may see `gnueabi`, `gnueabihf`, `uclibcgnueabi`, or `uclibcgnueabihf`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统**：用户空间组件的名称，可能是`gnu`或`uclibcgnu`。ABI也可以附加在这里，因此对于ARM工具链，您可能会看到`gnueabi`，`gnueabihf`，`uclibcgnueabi`或`uclibcgnueabihf`。'
- en: 'You can find the tuple used when building the toolchain by using the `-dumpmachine`
    option of `gcc`. For example, you may see the following on the host computer:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`gcc`的`-dumpmachine`选项找到构建工具链时使用的元组。例如，您可能会在主机计算机上看到以下内容：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When a native compiler is installed on a machine, it is normal to create links
    to each of the tools in the toolchain with no prefixes so that you can call the
    compiler with the command `gcc`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当在机器上安装本地编译器时，通常会创建到工具链中每个工具的链接，没有前缀，这样你就可以使用命令`gcc`调用编译器。
- en: 'Here is an example using a cross compiler:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用交叉编译器的示例：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Choosing the C library
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择C库
- en: 'The programming interface to the Unix operating system is defined in the C
    language, which is now defined by the POSIX standards. The C library is the implementation
    of that interface; it is the gateway to the kernel for Linux programs, as shown
    in the following diagram. Even if you are writing programs in another language,
    maybe Java or Python, the respective run-time support libraries will have to call
    the C library eventually:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Unix操作系统的编程接口是用C语言定义的，现在由POSIX标准定义。C库是该接口的实现；它是Linux程序与内核之间的网关，如下图所示。即使您使用其他语言编写程序，例如Java或Python，相应的运行时支持库最终也必须调用C库：
- en: '![Choosing the C library](img/B03982_02_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![选择C库](img/B03982_02_01.jpg)'
- en: The C library is the gateway to the kernel for applications
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: C库是应用程序与内核之间的网关
- en: Whenever the C library needs the services of the kernel it will use the kernel
    `system call` interface to transition between user space and kernel space. It
    is possible to bypass the C library by making kernel system calls directly, but
    that is a lot of trouble and almost never necessary.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 每当C库需要内核的服务时，它将使用内核`系统调用`接口在用户空间和内核空间之间进行转换。可以通过直接进行内核系统调用来绕过C库，但这是很麻烦的，几乎从不需要。
- en: 'There are several C libraries to choose from. The main options are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个C库可供选择。主要选项如下：
- en: '**glibc**: Available at [http://www.gnu.org/software/libc](http://www.gnu.org/software/libc).
    It is the standard GNU C library. It is big and, until recently, not very configurable,
    but it is the most complete implementation of the POSIX API.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**glibc**：可在[http://www.gnu.org/software/libc](http://www.gnu.org/software/libc)找到。这是标准的GNU
    C库。它很大，并且直到最近都不太可配置，但它是POSIX API的最完整实现。'
- en: '**eglibc**: Available at [http://www.eglibc.org/home](http://www.eglibc.org/home).
    This is the embedded GLIBC. It was a series of patches to glibc which added configuration
    options and support for architectures not covered by glibc (specifically, the
    PowerPC e500). The split between eglibc and glibc was always rather artificial
    and, fortunately, the code base from eglibc has been merged back into glibc as
    of version 2.20, leaving us with one improved library. eglibc is no longer maintained.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**eglibc**：可在[http://www.eglibc.org/home](http://www.eglibc.org/home)找到。这是嵌入式GLIBC。它是对glibc的一系列补丁，添加了配置选项和对glibc未覆盖的架构的支持（特别是PowerPC
    e500）。eglibc和glibc之间的分裂总是相当人为的，幸运的是，从版本2.20开始，eglibc的代码库已经合并回glibc，留下了一个改进的库。eglibc不再维护。'
- en: '**uClibc**: Available at [http://www.uclibc.org](http://www.uclibc.org). The
    ''u'' is really a Greek ''mu'' character, indicating that this is the micro controller
    C library. It was first developed to work with uClinux (Linux for CPUs without
    memory management units), but has since been adapted to be used with full Linux.
    There is a configuration utility which allows you to fine-tune its features to
    your needs. Even a full configuration is smaller than glibc but it is not as complete
    an implementation of the POSIX standards.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**uClibc**：可在[http://www.uclibc.org](http://www.uclibc.org)找到。 ''u''实际上是希腊字母''μ''，表示这是微控制器C库。它最初是为了与uClinux（没有内存管理单元的CPU的Linux）一起工作而开发的，但后来已经适应用于完整的Linux。有一个配置实用程序，允许您根据需要微调其功能。即使完整配置也比glibc小，但它不是POSIX标准的完整实现。'
- en: '**musl libc**: Available at [http://www.musl-libc.org](http://www.musl-libc.org).
    It is a new C library designed for embedded systems.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**musl libc**：可在[http://www.musl-libc.org](http://www.musl-libc.org)找到。这是一个为嵌入式系统设计的新C库。'
- en: 'So, which to choose? My advice is to use uClibc only if you are using uClinux
    or if you have very limited amounts of storage or RAM and so the small size would
    be an advantage. Otherwise, I prefer to use an up-to-date glibc, or eglibc. I
    have no experience of musl libc but if you find that glibc/eglibc is not suitable,
    by all means give it a go. This process is summarized in the following figure:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，应该选择哪个？我的建议是，如果您使用uClinux或存储空间或RAM非常有限，因此小尺寸将是一个优势，那么只使用uClibc。否则，我更喜欢使用最新的glibc或eglibc。我没有musl
    libc的经验，但如果您发现glibc/eglibc不合适，尽管尝试一下。这个过程总结在下图中：
- en: '![Choosing the C library](img/B03982_02_02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![选择C库](img/B03982_02_02.jpg)'
- en: Choosing a C library
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 选择C库
- en: Finding a toolchain
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找工具链
- en: 'You have three choices for your cross development toolchain: you may find a
    ready built toolchain that matches your needs, you can use the one generated by
    an embedded build tool which is covered in [Chapter 6](ch06.html "Chapter 6. Selecting
    a Build System"), *Selecting a Build System*, or you can create one yourself as
    described later in this chapter.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于交叉开发工具链，您有三种选择：您可以找到与您的需求匹配的现成工具链，可以使用嵌入式构建工具生成的工具链，该工具链在[第6章](ch06.html "第6章。选择构建系统")中有介绍，或者您可以按照本章后面描述的方式自己创建一个。
- en: 'A pre-built cross toolchain is an attractive option in that you only have to
    download and install it, but you are limited to the configuration of that particular
    toolchain and you are dependent on the person or organization you got it from.
    Most likely, it will be one of these:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 预先构建的交叉工具链是一个吸引人的选择，因为你只需要下载和安装它，但你受限于特定工具链的配置，并且依赖于你获取它的个人或组织。最有可能的是以下之一：
- en: SoC or board vendor. Most vendors offer a Linux toolchain.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SoC或板卡供应商。大多数供应商提供Linux工具链。
- en: A consortium dedicated to providing system-level support for a given architecture.
    For example, Linaro, ([https://www.linaro.org](https://www.linaro.org)) have pre-built
    toolchains for the ARM architecture.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 致力于为特定架构提供系统级支持的联盟。例如，Linaro ([https://www.linaro.org](https://www.linaro.org))为ARM架构提供了预构建的工具链。
- en: Third-party Linux tool vendors such as Mentor Graphics, TimeSys, or MontaVista.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方Linux工具供应商，如Mentor Graphics、TimeSys或MontaVista。
- en: Cross tool packages for your desktop Linux distribution, for example, Debian-based
    distributions have packages for cross compiling for ARM, MIPS, and PowerPC targets.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桌面Linux发行版的交叉工具包，例如，基于Debian的发行版有用于ARM、MIPS和PowerPC目标的交叉编译软件包。
- en: A binary SDK produced by one of the integrated embedded build tools, the Yocto
    Project has some examples at [http://autobuilder.yoctoproject.org/pub/releases/CURRENT/toolchain](http://autobuilder.yoctoproject.org/pub/releases/CURRENT/toolchain)
    and there is also the Denx Embedded Linux Development Kit at [ftp://ftp.denx.de/pub/eldk/](ftp://ftp.denx.de/pub/eldk/).
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由集成嵌入式构建工具之一生成的二进制SDK，Yocto项目在[http://autobuilder.yoctoproject.org/pub/releases/CURRENT/toolchain](http://autobuilder.yoctoproject.org/pub/releases/CURRENT/toolchain)上有一些示例，还有Denx嵌入式Linux开发工具包在[ftp://ftp.denx.de/pub/eldk/](ftp://ftp.denx.de/pub/eldk)上。
- en: A link from a forum that you can't find any more.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个你找不到的论坛链接。
- en: In all of these cases, you have to decide whether the pre-built toolchain on
    offer meets your requirements. Does it use the C library you prefer? Will the
    provider give you updates for security fixes and bugs, bearing in mind my comments
    on support and updates from [Chapter 1](ch01.html "Chapter 1. Starting Out"),
    *Starting Out*. If your answer is no to any of these then you should consider
    creating your own.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，你必须决定提供的预构建工具链是否满足你的要求。它是否使用你喜欢的C库？提供商是否会为你提供安全修复和错误修复的更新，考虑到我在[第1章](ch01.html
    "第1章。起步")中对支持和更新的评论，*起步*。如果你对任何一个问题的答案是否定的，那么你应该考虑创建你自己的工具链。
- en: Unfortunately, building a toolchain is no easy task. If you truly want to do
    the whole thing yourself, take a look at *Cross Linux From Scratch* ([http://trac.clfs.org](http://trac.clfs.org)).
    There, you will find step-by-step instructions on how to create each component.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，构建工具链并不是一件容易的事。如果你真的想自己完成所有工作，请看*Cross Linux From Scratch* ([http://trac.clfs.org](http://trac.clfs.org))。在那里，你会找到如何创建每个组件的逐步说明。
- en: A simpler alternative is to use crosstool-NG, which encapsulates the process
    into a set of scripts and has a menu-driven front-end. You still need a fair degree
    of knowledge, though, just to make the right choices.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更简单的选择是使用crosstool-NG，它将这个过程封装成一组脚本，并有一个菜单驱动的前端。不过，你仍然需要相当多的知识，才能做出正确的选择。
- en: It is simpler still to use a build system such as Buildroot or the Yocto Project
    since they generate a toolchain as part of the build process. This is my preferred
    solution as I have shown in [Chapter 6](ch06.html "Chapter 6. Selecting a Build
    System"), *Selecting a Build System*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构建系统如Buildroot或Yocto项目更简单，因为它们在构建过程中生成工具链。这是我偏好的解决方案，正如我在[第6章](ch06.html "第6章。选择构建系统")中所展示的，*选择构建系统*。
- en: Building a toolchain using crosstool-NG
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用crosstool-NG构建工具链
- en: I am going to begin with crosstool-NG because it allows you to see the process
    of creating the toolchain and to create several different sorts.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从crosstool-NG开始，因为它允许你看到创建工具链的过程，并创建几种不同的工具链。
- en: Some years ago, Dan Kegel wrote a set of scripts and makefiles for generating
    cross development toolchains and called it crosstool ([kegel.com/crosstool](http://kegel.com/crosstool)).
    In 2007, Yann E. Morin used that base to create the next generation of crosstool,
    crosstool-NG ([crosstool-ng.org](http://crosstool-ng.org)). Today it is, by far,
    the most convenient way to create a stand-alone cross toolchain from source.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，Dan Kegel编写了一组脚本和makefile用于生成交叉开发工具链，并称之为crosstool ([kegel.com/crosstool](http://kegel.com/crosstool))。2007年，Yann
    E. Morin基于这个基础创建了下一代crosstool，即crosstool-NG ([crosstool-ng.org](http://crosstool-ng.org))。今天，这无疑是从源代码创建独立交叉工具链的最方便的方法。
- en: Installing crosstool-NG
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装crosstool-NG
- en: 'Before you begin, you will need a working native toolchain and build tools
    on your host PC. To work with crosstool-NG on an Ubuntu host, you will need to
    install the packages using the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，你需要在主机PC上安装一个可用的本地工具链和构建工具。要在Ubuntu主机上使用crosstool-NG，你需要使用以下命令安装软件包：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, get the current release from the croostool-NG downloads section, [http://crosstool-ng.org/download/crosstool-ng](http://crosstool-ng.org/download/crosstool-ng).
    In my examples I have used 1.20.0\. Extract it and create the front-end menu system,
    ct-ng, as shown in the following commands:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从crosstool-NG下载部分获取当前版本，[http://crosstool-ng.org/download/crosstool-ng](http://crosstool-ng.org/download/crosstool-ng)。在我的示例中，我使用了1.20.0。解压并创建前端菜单系统ct-ng，如下所示的命令：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `--enable-local` option means that the program will be installed into the
    current directory, which avoids the need for root permissions as would be required
    if you were to install it in the default location, `/usr/local/bin`. Type `./ct-ng`
    from the current directory to launch the crosstool menu.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`--enable-local`选项意味着程序将安装到当前目录，这样可以避免需要root权限，如果你要安装到默认位置`/usr/local/bin`，则需要root权限。从当前目录输入`./ct-ng`启动crosstool菜单。'
- en: Selecting the toolchain
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择工具链
- en: Crosstool-NG can build many different combinations of toolchains. To make the
    initial configuration easier, it comes with a set of samples that cover many of
    the common use-cases. Use `./ct-ng list-samples` to generate the list.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Crosstool-NG可以构建许多不同的工具链组合。为了使初始配置更容易，它附带了一组样本，涵盖了许多常见用例。使用`./ct-ng list-samples`来生成列表。
- en: 'As an example, suppose that your target is a BeagleBone Black which has an
    ARM Cortex A8 core and a VFPv3 floating point unit, and that you want to use a
    current version of glibc. The closest sample is `arm-cortex_a8-linux-gnueabi`.
    You can see the default configuration by prefixing the name with `show-`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你的目标是BeagleBone Black，它有一个ARM Cortex A8核心和一个VFPv3浮点单元，并且你想使用一个当前版本的glibc。最接近的样本是`arm-cortex_a8-linux-gnueabi`。你可以通过在名称前加上`show-`来查看默认配置：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To select this as the target configuration, you would type:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其选择为目标配置，你需要输入：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'At this point, you can review the configuration and make changes using the
    configuration menu command `menuconfig`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可以通过使用配置菜单命令`menuconfig`来审查配置并进行更改：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The menu system is based on the Linux kernel `menuconfig` and so navigation
    of the user interface will be familiar to anyone who has configured a kernel.
    If not, please refer to [Chapter 4](ch04.html "Chapter 4. Porting and Configuring
    the Kernel"), *Porting and Configuring the Kernel* for a description of `menuconfig`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单系统基于Linux内核的`menuconfig`，所以对于任何配置过内核的人来说，用户界面的导航都是熟悉的。如果不熟悉，请参考[第4章](ch04.html
    "第4章。移植和配置内核")，*移植和配置内核*，了解`menuconfig`的描述。
- en: 'There are a few configuration changes that I would recommend you make at this
    point:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，有一些配置更改是我建议你做的：
- en: In **Paths and misc** options, disable **Render the toolchain read-only** (`CT_INSTALL_DIR_RO`)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**路径和杂项**选项中，禁用**使工具链只读** (`CT_INSTALL_DIR_RO`)
- en: In **Target options** | **Floating point,** select **hardware (FPU)** (`CT_ARCH_FLOAT_HW`)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**目标选项** | **浮点数**中，选择**硬件 (FPU)** (`CT_ARCH_FLOAT_HW`)
- en: In **C-library** | **extra config**, add **--enable-obsolete-rpc** (`CT_LIBC_GLIBC_EXTRA_CONFIG_ARRAY`)
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**C库** | **额外配置**中，添加**--enable-obsolete-rpc** (`CT_LIBC_GLIBC_EXTRA_CONFIG_ARRAY`)
- en: The first is necessary if you want to add libraries to the toolchain after it
    has been installed, which I will describe later in this chapter. The next is to
    select the optimum floating point implementation for a processor with a hardware
    floating point unit. The last forces the toolchain to be generated with an obsolete
    header file, `rpc.h`, which is still used by a number of packages (note that this
    is only a problem if you selected glibc). The names in parentheses are the configuration
    labels stored in the configuration file. When you have made the changes, exit
    `menuconfig`, and save the configuration as you do so.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是必要的，如果你想在安装后向工具链添加库，我将在本章后面描述。接下来是为具有硬件浮点单元的处理器选择最佳浮点实现。最后是强制生成一个过时的头文件`rpc.h`的工具链，这个头文件仍然被许多软件包使用（请注意，只有在选择glibc时才会出现这个问题）。括号中的名称是存储在配置文件中的配置标签。当你做出更改后，退出`menuconfig`，并在这样做时保存配置。
- en: 'The configuration data is saved into a file named `.config`. Looking at the
    file, you will see that the first line of text reads *Automatically generated
    make config: don''t edit* which is generally good advice, but I recommend that
    you ignore it in this case. Do you remember from the discussion about toolchain
    ABIs that ARM has two variants, one which passes floating point parameters in
    integer registers and one that uses the VFP registers? The float configuration
    you have just chosen is of the latter type and so the ABI part of the tuple should
    read `eabihf`. There is a configuration parameter that does exactly what you want
    but it is not enabled by default, neither does it appear in the menu, at least
    not in this version of crosstool. Consequently, you will have to edit `.config`
    and add the line shown in bold as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '配置数据保存在一个名为`.config`的文件中。查看文件时，你会看到文本的第一行是*Automatically generated make config:
    don''t edit*，这通常是一个很好的建议，但我建议你在这种情况下忽略它。你还记得关于工具链ABI的讨论吗？ARM有两个变体，一个是将浮点参数传递到整数寄存器中，另一个是使用VFP寄存器。你刚刚选择的浮点配置是后者，所以元组的ABI部分应该是`eabihf`。有一个配置参数恰好符合你的要求，但它不是默认启用的，也不会出现在菜单中，至少在这个版本的crosstool中不会。因此，你需要编辑`.config`并添加如下粗体显示的行：'
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now you can use crosstool-NG to get, configure, and build the components according
    to your specification by typing the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用crosstool-NG来获取、配置和构建组件，根据你的规格输入以下命令：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The build will take about half an hour, after which you will find your toolchain
    is present in `~/x-tools/arm-cortex_a8-linux-gnueabihf/`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 构建大约需要半个小时，之后你会发现你的工具链出现在`~/x-tools/arm-cortex_a8-linux-gnueabihf/`中。
- en: Anatomy of a toolchain
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具链的解剖
- en: To get an idea of what is in a typical toolchain, I want to examine the crosstool-NG
    toolchain you have just created.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解典型工具链中有什么，我想要检查一下你刚刚创建的crosstool-NG工具链。
- en: 'The toolchain is in the directory `~/x-tools/arm-cortex_a8-linux-gnueabihf/bin`.
    In there you will find the cross compiler, `arm-cortex_a8-linux-gnueabihf-gcc`.
    To make use of it, you need to add the directory to your path using the following
    command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链位于目录`~/x-tools/arm-cortex_a8-linux-gnueabihf/bin`中。在那里你会找到交叉编译器`arm-cortex_a8-linux-gnueabihf-gcc`。要使用它，你需要使用以下命令将该目录添加到你的路径中：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now you can take a simple `hello world` program that looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用一个简单的`hello world`程序，看起来像这样：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And compile it like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后像这样编译它：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can confirm that it has been cross compiled by using the `file` command
    to print the type of the file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`file`命令来确认它已经被交叉编译，以打印文件的类型：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finding out about your cross compiler
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解你的交叉编译器
- en: 'Imagine that you have just received a toolchain, and that you would like to
    know more about how it was configured. You can find out a lot by querying gcc.
    For example, to find the version, you use `--version`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你刚刚收到了一个工具链，你想了解更多关于它是如何配置的。你可以通过查询gcc来了解很多信息。例如，要找到版本，你可以使用`--version`：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To find how it was configured, use `-v`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找它是如何配置的，请使用`-v`：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There is a lot of output there but the interesting things to note are:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那里有很多输出，但值得注意的有：
- en: '`--with-sysroot=/home/chris/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot`:
    This is the default sysroot directory, see the following section for an explanation'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--with-sysroot=/home/chris/x-tools/arm-cortex_a8-linux-gnueabihf/arm-cortex_a8-linux-gnueabihf/sysroot`：这是默认的sysroot目录，请参阅以下部分以获取解释'
- en: '`--enable-languages=c,c++`: Using this we have both C and C++ languages enabled'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--enable-languages=c,c++`：使用此选项，我们启用了C和C++语言'
- en: '`--with-arch=armv7-a`: The code is generated using the ARM v7a instruction
    set'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--with-arch=armv7-a`：使用ARM v7a指令集生成代码'
- en: '`--with-cpu=cortex-a8 and --with-tune=cortex-a8`: The the code is further tweaked
    for a Cortex A8 core'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--with-cpu=cortex-a8 and --with-tune=cortex-a8`：进一步调整代码以适应Cortex A8核心'
- en: '`--with-float=hard`: Generate opcodes for the floating point unit and uses
    the VFP registers for parameters'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--with-float=hard`：生成浮点单元的操作码，并使用VFP寄存器作为参数'
- en: '`--enable-threads=posix`: Enable POSIX threads'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--enable-threads=posix`：启用POSIX线程'
- en: 'These are the default settings for the compiler. You can override most of them
    on the gcc command line so, for example, if you want to compile for a different
    CPU, you can override the configured setting, `–-with-cpu`, by adding `-mcpu`
    to the command line, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是编译器的默认设置。您可以在gcc命令行上覆盖大多数设置，因此，例如，如果要为不同的CPU编译，可以通过在命令行中添加`-mcpu`来覆盖配置的设置`--with-cpu`，如下所示：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can print out the the range of architecture-specific options available
    using `--target-help,` as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`--target-help`打印出可用的特定于体系结构的选项范围，如下所示：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You may be wondering if it matters whether or not you get the exact configuration
    right at the time you generate the toolchain if you can change it later on, and
    the answer depends on the way you anticipate using it. If you plan to create a
    new toolchain for each target, then it makes sense to set everything up at the
    beginning because it will reduce the risks of getting it wrong later on. Jumping
    ahead a little to [Chapter 6](ch06.html "Chapter 6. Selecting a Build System"),
    *Selecting a Build System*, I call this the Buildroot philosophy. If, on the other
    hand, you want to build a toolchain that is generic and you are prepared to provide
    the correct settings when you build for a particular target, then you should make
    the base toolchain generic, which is the way the Yocto Project handles things.
    The preceding examples follow the Buildroot philosophy.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道在生成工具链时是否很重要是否得到了精确的配置，如果以后可以更改，答案取决于您预期使用它的方式。如果您计划为每个目标创建一个新的工具链，那么最好在开始时设置所有内容，因为这将减少以后出错的风险。稍微提前到[第6章](ch06.html
    "第6章。选择构建系统")，*选择构建系统*，我称之为Buildroot哲学。另一方面，如果您想构建一个通用的工具链，并且准备在为特定目标构建时提供正确的设置，那么您应该使基本工具链通用，这是Yocto项目处理事务的方式。前面的例子遵循Buildroot哲学。
- en: The sysroot, library, and header files
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: sysroot、库和头文件
- en: 'The toolchain sysroot is a directory which contains subdirectories for libraries,
    header files, and other configuration files. It can be set when the toolchain
    is configured through `--with-sysroot=` or it can be set on the command line,
    using `--sysroot=`. You can see the location of the default sysroot by using `-print-sysroot`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链sysroot是一个包含库、头文件和其他配置文件子目录的目录。它可以在配置工具链时通过`--with-sysroot=`设置，也可以在命令行上使用`--sysroot=`设置。您可以使用`-print-sysroot`来查看默认sysroot的位置：
- en: '[PRE17]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You will find the following in the sysroot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在sysroot中找到以下内容：
- en: '`lib`: Contains the shared objects for the C library and the dynamic linker/loader,
    `ld-linux`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib`：包含C库和动态链接器/加载器`ld-linux`的共享对象'
- en: '`usr/lib`: the static library archives for the C library and any other libraries
    that may be installed subsequently'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usr/lib`：C库的静态库存档以及随后可能安装的任何其他库'
- en: '`usr/include`: Contains the headers for all the libraries'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usr/include`：包含所有库的头文件'
- en: '`usr/bin`: Contains the utility programs that run on the target, such as the
    `ldd` command'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`usr/bin`：包含在目标上运行的实用程序，例如`ldd`命令'
- en: '`/usr/share`: Used for localization and internationalization'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr/share`：用于本地化和国际化'
- en: '`sbin`: Provides the ldconfig utility, used to optimize library loading paths'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sbin`：提供了ldconfig实用程序，用于优化库加载路径'
- en: Plainly, some of these are needed on the development host to compile programs,
    and others – for example the shared libraries and `ld-linux` – are needed on the
    target at runtime.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 明显地，其中一些需要在开发主机上用于编译程序，而其他一些，例如共享库和`ld-linux`，需要在目标运行时使用。
- en: Other tools in the toolchain
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具链中的其他工具
- en: 'The following table shows various other commands in the toolchain together
    with a brief description:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了工具链中的各种其他命令以及简要描述：
- en: '| Command | Description |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `addr2line` | Converts program addresses into filenames and numbers by reading
    the debug symbol tables in an executable file. It is very useful when decoding
    addresses printed out in a system crash report. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `addr2line` | 通过读取可执行文件中的调试符号表，将程序地址转换为文件名和数字。在解码系统崩溃报告中打印的地址时非常有用。 |'
- en: '| `ar` | The archive utility is used to create static libraries. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `ar` | 存档实用程序用于创建静态库。 |'
- en: '| `as` | This is the GNU assembler. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `as` | 这是GNU汇编器。 |'
- en: '| `c++filt` | This is used to demangle C++ and Java symbols. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `c++filt` | 用于解开C++和Java符号。 |'
- en: '| `cpp` | This is the C preprocessor, and is used to expand `#define`, `#include`,
    and other similar directives. You seldom need to use this by itself. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `cpp` | 这是C预处理器，用于扩展`#define`、`#include`和其他类似的指令。您很少需要单独使用它。 |'
- en: '| `elfedit` | This is used to update the ELF header of ELF files. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `elfedit` | 用于更新ELF文件的ELF头。 |'
- en: '| `g++` | This is the GNU C++ front-end, which assumes source files contain
    C++ code. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `g++` | 这是GNU C++前端，假设源文件包含C++代码。 |'
- en: '| `gcc` | This is the GNU C front-end, which assumes source files contain C
    code. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `gcc` | 这是GNU C前端，假设源文件包含C代码。 |'
- en: '| `gcov` | This is a code coverage tool. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `gcov` | 这是一个代码覆盖工具。 |'
- en: '| `gdb` | This is the GNU debugger. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `gdb` | 这是GNU调试器。 |'
- en: '| `gprof` | This is a program profiling tool. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `gprof` | 这是一个程序性能分析工具。 |'
- en: '| `ld` | This is the GNU linker. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `ld` | 这是GNU链接器。 |'
- en: '| `nm` | This lists symbols from object files. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `nm` | 这列出了目标文件中的符号。 |'
- en: '| `objcopy` | This is used to copy and translate object files. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `objcopy` | 用于复制和转换目标文件。 |'
- en: '| `objdump` | This is used to display information from object files. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `objdump` | 用于显示目标文件的信息。 |'
- en: '| `ranlib` | This creates or modifies an index in a static library, making
    the linking stage faster. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `ranlib` | 这在静态库中创建或修改索引，使链接阶段更快。 |'
- en: '| `readelf` | This displays information about files in ELF object format. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `readelf` | 这显示有关ELF对象格式文件的信息。 |'
- en: '| `size` | This lists section sizes and the total size. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `size` | 这列出了各个部分的大小和总大小。 |'
- en: '| `strings` | This display strings of printable characters in files. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `strings` | 这在文件中显示可打印字符的字符串。 |'
- en: '| `strip` | This is used to strip an object file of debug symbol tables, thus
    making it smaller. Typically, you would strip all the executable code that is
    put onto the target. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `strip` | 用于剥离对象文件的调试符号表，从而使其更小。通常，您会剥离放入目标的所有可执行代码。 |'
- en: Looking at the components of the C library
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看C库的组件
- en: 'The C library is not a single library file. It is composed of four main parts
    that together implement the POSIX functions API:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: C库不是单个库文件。它由四个主要部分组成，共同实现POSIX函数API：
- en: '`libc`: The main C library that contains the well-known POSIX functions such
    as `printf`, `open`, `close`, `read`, `write`, and so on'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libc`：包含诸如`printf`、`open`、`close`、`read`、`write`等众所周知的POSIX函数的主C库'
- en: '`libm`: Maths functions such as `cos`, `exp`, and `log`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libm`：数学函数，如`cos`、`exp`和`log`'
- en: '`libpthread`: All the POSIX thread functions with names beginning with `pthread_`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libpthread`：所有以`pthread_`开头的POSIX线程函数'
- en: '`librt`: The real-time extensions to POSIX, including shared memory and asynchronous
    I/O'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`librt`：POSIX的实时扩展，包括共享内存和异步I/O'
- en: 'The first one, `libc`, is always linked in but the others have to be explicitly
    linked with the `-l` option. The parameter to `-l` is the library name with `lib`
    stripped off. So, for example, a program that calculates a sine function by calling
    `sin()` would be linked with `libm` using `-lm`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`libc`总是被链接，但其他的必须使用`-l`选项显式链接。`-l`的参数是去掉`lib`的库名称。因此，例如，通过调用`sin()`计算正弦函数的程序将使用`-lm`链接`libm`：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can verify which libraries have been linked in this or any other program
    by using the `readelf` command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`readelf`命令验证已链接到此程序或任何其他程序的库：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Shared libraries need a run-time linker, which you can expose using:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库需要运行时链接器，您可以使用以下命令公开它：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is so useful that I have a script file with these commands into a shell
    script:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如此有用，以至于我有一个包含这些命令的脚本文件：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Linking with libraries: static and dynamic linking'
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接库：静态和动态链接
- en: Any application you write for Linux, whether it be in C or C++, will be linked
    with the C library, libc. This is so fundamental that you don't even have to tell
    `gcc` or `g++` to do it because it always links libc. Other libraries that you
    may want to link with have to be explicitly named through the `-l` option.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您为Linux编写的任何应用程序，无论是C还是C++，都将与C库libc链接。这是如此基本，以至于您甚至不必告诉`gcc`或`g++`去做，因为它总是链接libc。您可能想要链接的其他库必须通过`-l`选项显式命名。
- en: 'The library code can be linked in two different ways: statically, meaning that
    all the library functions your application calls and their dependencies are pulled
    from the library archive and bound into your executable; and dynamically, meaning
    that references to the library files and functions in those files are generated
    in the code but the actual linking is done dynamically at runtime.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图书馆代码可以以两种不同的方式链接：静态链接，意味着应用程序调用的所有库函数及其依赖项都从库存档中提取并绑定到可执行文件中；动态链接，意味着代码中生成对库文件和这些文件中的函数的引用，但实际的链接是在运行时动态完成的。
- en: Static libraries
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态库
- en: Static linking is useful in a few circumstances. For example, if you are building
    a small system which consists of only BusyBox and some script files, it is simpler
    to link BusyBox statically and avoid having to copy the runtime library files
    and linker. It will also be smaller because you only link in the code that your
    application uses rather than supplying the entire C library. Static linking is
    also useful if you need to run a program before the filesystem that holds the
    runtime libraries is available.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 静态链接在一些情况下很有用。例如，如果您正在构建一个仅包含BusyBox和一些脚本文件的小型系统，将BusyBox静态链接并避免复制运行时库文件和链接器会更简单。它还会更小，因为您只链接应用程序使用的代码，而不是提供整个C库。如果您需要在运行时库可用之前运行程序，静态链接也很有用。
- en: 'You tell gcc to link all libraries statically by adding `-static` to the command
    line:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在命令行中添加`-static`，您可以告诉gcc将所有库静态链接起来：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You will notice that the size of the binary increases dramatically:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到二进制文件的大小大幅增加：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Static linking pulls code from a library archive, usually named `lib[name].a`.
    In the preceding case it is `libc.a`, which is in `[sysroot]/usr/lib`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 静态链接从库存档中提取代码，通常命名为`lib[name].a`。在前面的情况下，它是`libc.a`，位于`[sysroot]/usr/lib`中：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note that the syntax `$(arm-cortex_a8-linux-gnueabihf-gcc -print-sysroot)` places
    the output of the program on the command line. I am using it as a generic way
    to refer to the files in the sysroot.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，语法`$(arm-cortex_a8-linux-gnueabihf-gcc -print-sysroot)`将程序的输出放在命令行上。我正在使用它作为一种通用方式来引用sysroot中的文件。
- en: 'Creating a static library is as simple as creating an archive of object files
    using the `ar` command. If I had two source files named `test1.c` and `test2.c`
    and I want to create a static library named `libtest.a,` then I would do this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 创建静态库就像使用`ar`命令创建对象文件的存档一样简单。如果我有两个名为`test1.c`和`test2.c`的源文件，并且我想创建一个名为`libtest.a`的静态库，那么我会这样做：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then I could link `libtest` into my `helloworld` program using:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我可以使用以下命令将`libtest`链接到我的`helloworld`程序中：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Shared libraries
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享库
- en: A more common way to deploy libraries is as shared objects that are linked at
    runtime, which makes more efficient use of storage and system memory, since only
    one copy of the code needs to be loaded. It also makes it easy to update library
    files without having to re-link all the programs that use them.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 部署库的更常见方式是作为在运行时链接的共享对象，这样可以更有效地使用存储和系统内存，因为只需要加载一份代码副本。这也使得可以轻松更新库文件，而无需重新链接所有使用它们的程序。
- en: 'The object code for a shared library must be position-independent so that the
    runtime linker is free to locate it in memory at the next free address. To do
    this, add the `-fPIC` parameter to gcc, and then link it using the `-shared` option:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库的目标代码必须是位置无关的，以便运行时链接器可以自由地将其定位在内存中的下一个空闲地址。为此，使用gcc添加`-fPIC`参数，然后使用`-shared`选项进行链接：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To link an application with this library, you add `-ltest`, exactly as in the
    static case mentioned in the preceding paragraph but, this time, the code is not
    included in the executable, but there is a reference to the library that the runtime
    linker will have to resolve:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要将应用程序与此库链接，您需要添加`-ltest`，与前面段落中提到的静态情况完全相同，但是这次代码不包含在可执行文件中，而是有一个对运行时链接器必须解析的库的引用：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The runtime linker for this program is `/lib/ld-linux-armhf.so.3`, which must
    be present in the target''s filesystem. The linker will look for `libtest.so`
    in the default search path: `/lib` and `/usr/lib`. If you want it to look for
    libraries in other directories as well, you can place a colon-separated list of
    paths in the shell variable `LD_LIBRARY_PATH`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的运行时链接器是`/lib/ld-linux-armhf.so.3`，必须存在于目标文件系统中。链接器将在默认搜索路径`/lib`和`/usr/lib`中查找`libtest.so`。如果您希望它也在其他目录中查找库，可以在shell变量`LD_LIBRARY_PATH`中放置一个以冒号分隔的路径列表：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Understanding shared library version numbers
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解共享库版本号
- en: 'One of the benefits of shared libraries is that they can be updated independently
    of the programs that use them. Library updates are of two types: those that fix
    bugs or add new functions in a backwards-compatible way, and those that break
    compatibility with existing applications. GNU/Linux has a versioning scheme to
    handle both these cases.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库的一个好处是它们可以独立于使用它们的程序进行更新。库更新有两种类型：修复错误或以向后兼容的方式添加新功能的更新，以及破坏现有应用程序兼容性的更新。GNU/Linux有一个版本控制方案来处理这两种情况。
- en: Each library has a release version and an interface number. The release version
    is simply a string that is appended to the library name, for example the JPEG
    image library, libjpeg, is currently at release 8.0.2 and so the library is named
    `libjpeg.so.8.0.2`. There is a symbolic link named `libjpeg.so` to `libjpeg.so.8.0.2`
    so that, when you compile a program with `–ljpeg,` you link with the current version.
    If you install version 8.0.3, the link is updated and you will link with that
    one instead.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 每个库都有一个发布版本和一个接口号。发布版本只是一个附加到库名称的字符串，例如JPEG图像库libjpeg当前发布版本为8.0.2，因此库的名称为`libjpeg.so.8.0.2`。有一个名为`libjpeg.so`的符号链接指向`libjpeg.so.8.0.2`，因此当您使用`-ljpeg`编译程序时，您将链接到当前版本。如果安装了版本8.0.3，链接将被更新，您将链接到新版本。
- en: 'Now, suppose that version 9.0.0 comes along and that breaks backwards compatibility.
    The link from `libjpeg.so` now points to `libjpeg.so.9.0.0`, so that any new programs
    are linked with the new version, possibly throwing compile errors when the interface
    to libjpeg changes, which the developer can fix. Any programs on the target that
    are not recompiled are going to fail in some way because they are still using
    the old interface. This is where the `soname` helps. The `soname` encodes the
    interface number when the library was built and is used by the runtime linker
    when it loads the library. It is formatted as `<library name>.so.<interface number>`.
    For `libjpeg.so.8.0.2,` the `soname` is `libjpeg.so.8`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设出现了版本9.0.0，并且它破坏了向后兼容性。`libjpeg.so`现在指向`libjpeg.so.9.0.0`，因此任何新程序都将链接到新版本，可能在libjpeg接口发生更改时引发编译错误，开发人员可以修复。目标上未重新编译的任何程序都将以某种方式失败，因为它们仍在使用旧接口。这就是`soname`的作用。`soname`在构建库时编码接口号，并在运行时链接器加载库时使用。它的格式为`<库名称>.so.<接口号>`。对于`libjpeg.so.8.0.2`，`soname`是`libjpeg.so.8`：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Any program compiled with it will request `libjpeg.so.8` at runtime which will
    be a symbolic link on the target to `libjpeg.so.8.0.2`. When version 9.0.0 of
    libjpeg is installed, it will have a `soname` of `libjpeg.so.9`, and so it is
    possible to have two incompatible versions of the same library installed on the
    same system. Programs that were linked with `libjpeg.so.8.*.*` will load `libjpeg.so.8,`
    and those linked with `libjpeg.so.9.*.*` will load `libjpeg.so.9`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它编译的任何程序都将在运行时请求`libjpeg.so.8`，这将是目标上的一个指向`libjpeg.so.8.0.2`的符号链接。安装libjpeg的9.0.0版本时，它将具有`soname`为`libjpeg.so.9`，因此可以在同一系统上安装两个不兼容版本的相同库。使用`libjpeg.so.8.*.*`链接的程序将加载`libjpeg.so.8`，而使用`libjpeg.so.9.*.*`链接的程序将加载`libjpeg.so.9`。
- en: 'This is why, when you look at the directory listing of `<sysroot>/usr/lib/libjpeg*`,
    you find these four files:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么当您查看`<sysroot>/usr/lib/libjpeg*`目录列表时，会找到这四个文件：
- en: '`libjpeg.a`: This is the library archive used for static linking'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libjpeg.a`：这是用于静态链接的库存档'
- en: '`libjpeg.so -> libjpeg.so.8.0.2` : This is a symbolic link, used for dynamic
    linking'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libjpeg.so -> libjpeg.so.8.0.2`：这是一个符号链接，用于动态链接'
- en: '`libjpeg.so.8 -> libjpeg.so.8.0.2`: This is a symbolic link used when loading
    the library at runtime'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libjpeg.so.8 -> libjpeg.so.8.0.2`：这是在运行时加载库时使用的符号链接'
- en: '`libjpeg.so.8.0.2`: This is the actual shared library, used at both compile
    time and runtime'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libjpeg.so.8.0.2`：这是实际的共享库，用于编译时和运行时'
- en: The first two are only needed on the host computer for building, the last two
    are needed on the target at runtime.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个仅在主机计算机上用于构建，后两个在目标上运行时需要。
- en: The art of cross compiling
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交叉编译的艺术
- en: 'Having a working cross toolchain is the starting point of a journey, not the
    end of it. At some point, you will want to begin cross compiling the various tools,
    applications, and libraries that you need on your target. Many of them will be
    open source packages, each of which has its own method of compiling, and each
    with its own peculiarities. There are some common build systems, including:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有可用的交叉工具链只是旅程的起点，而不是终点。在某些时候，您将希望开始交叉编译各种工具、应用程序和库，这些都是您在目标设备上需要的。其中许多是开源软件包，每个软件包都有自己的编译方法和特点。其中一些常见的构建系统包括：
- en: Pure makefiles where the toolchain is controlled by the `make` variable `CROSS_COMPILE`
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯makefile，其中工具链由`make`变量`CROSS_COMPILE`控制
- en: The GNU build system known as Autotools
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被称为Autotools的GNU构建系统
- en: CMake ([https://cmake.org](https://cmake.org))
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CMake ([https://cmake.org](https://cmake.org))
- en: I will cover only the first two here since these are the ones needed for even
    a basic embedded Linux system. For CMake, there are some excellent resources on
    the CMake website referenced in the preceding point.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我这里只会涵盖前两个，因为这些是甚至基本嵌入式Linux系统所需的。对于CMake，在前面一点引用的CMake网站上有一些很好的资源。
- en: Simple makefiles
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的makefile
- en: Some important packages are very simple to cross compile, including the Linux
    kernel, the U-Boot bootloader, and Busybox. For each of these, you only need to
    put the toolchain prefix in the `make` variable `CROSS_COMPILE`, for example `arm-cortex_a8-linux-gnueabi-`.
    Note the trailing dash `-`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的软件包非常容易进行交叉编译，包括Linux内核、U-Boot引导加载程序和Busybox。对于这些软件包，您只需要将工具链前缀放在`make`变量`CROSS_COMPILE`中，例如`arm-cortex_a8-linux-gnueabi-`。注意末尾的破折号`-`。
- en: 'So, to compile Busybox, you would type:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要编译Busybox，您需要键入：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Or, you can set it as a shell variable:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以将其设置为shell变量：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the case of U-Boot and Linux, you also have to set the `make` variable `ARCH`
    to one of the machine architectures they support, which I will cover in [Chapter
    3](ch03.html "Chapter 3. All About Bootloaders"), *All About Bootloaders* and
    [Chapter 4](ch04.html "Chapter 4. Porting and Configuring the Kernel"), *Porting
    and Configuring the Kernel*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在U-Boot和Linux的情况下，您还必须将`make`变量`ARCH`设置为它们支持的机器架构之一，我将在[第3章](ch03.html "第3章。关于引导加载程序的一切")和[第4章](ch04.html
    "第4章。移植和配置内核")中介绍，*关于引导加载程序*和*移植和配置内核*。
- en: Autotools
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Autotools
- en: 'The name, Autotools, refers to a group of tools that are used as the build
    system in many open source projects. The components, together with the appropriate
    project pages, are:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 名称Autotools指的是一组工具，它们被用作许多开源项目中的构建系统。这些组件以及相应的项目页面是：
- en: GNU Autoconf ([http://www.gnu.org/software/autoconf/autoconf.html](http://www.gnu.org/software/autoconf/autoconf.html))
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU Autoconf ([http://www.gnu.org/software/autoconf/autoconf.html](http://www.gnu.org/software/autoconf/autoconf.html))
- en: GNU Automake ([http://www.gnu.org/savannah-checkouts/gnu/automake](http://www.gnu.org/savannah-checkouts/gnu/automake))
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU Automake ([http://www.gnu.org/savannah-checkouts/gnu/automake](http://www.gnu.org/savannah-checkouts/gnu/automake))
- en: GNU Libtool ([http://www.gnu.org/software/libtool/libtool.html](http://www.gnu.org/software/libtool/libtool.html))
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU Libtool ([http://www.gnu.org/software/libtool/libtool.html](http://www.gnu.org/software/libtool/libtool.html))
- en: Gnulib ([https://www.gnu.org/software/gnulib](https://www.gnu.org/software/gnulib))
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gnulib ([https://www.gnu.org/software/gnulib](https://www.gnu.org/software/gnulib))
- en: The role of Autotools is to smooth over the differences between the many different
    types of system that the package may be compiled for, accounting for different
    versions of compilers, different versions of libraries, different locations of
    header files, and dependencies with other packages. Packages that use Autotools
    come with a script named `configure` that checks dependencies and generates makefiles
    according to what it finds. The configure script may also give you the opportunity
    to enable or disable certain features. You can find the options on offer by running
    `./configure --help`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Autotools的作用是消除软件包可能编译的许多不同类型系统之间的差异，考虑到不同版本的编译器、不同版本的库、头文件的不同位置以及与其他软件包的依赖关系。使用Autotools的软件包附带一个名为`configure`的脚本，该脚本检查依赖关系并根据其发现生成makefile。配置脚本还可以让您有机会启用或禁用某些功能。您可以通过运行`./configure
    --help`来查看提供的选项。
- en: 'To configure, build, and install a package for the native operating system,
    you would typically run these three commands:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要为本机操作系统配置、构建和安装软件包，通常会运行以下三个命令：
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Autotools is able to handle cross development as well. You can influence the
    behavior of the configure script by setting these shell variables:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Autotools也能够处理交叉开发。您可以通过设置这些shell变量来影响配置脚本的行为：
- en: '`CC`: The C compiler command'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CC`：C编译器命令'
- en: '`CFLAGS`: Additional C compiler flags'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CFLAGS`：额外的C编译器标志'
- en: '`LDFLAGS`: Additional linker flags, for example if you have libraries in a
    non-standard directory `<lib dir>` you would add it to the library search path
    by adding `-L<lib dir>`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LDFLAGS`：额外的链接器标志，例如，如果您在非标准目录`<lib dir>`中有库，则可以通过添加`-L<lib dir>`将其添加到库搜索路径'
- en: '`LIBS`: Contains a list of additional libraries to pass to the linker, for
    instance `-lm` for the math library'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LIBS`：包含要传递给链接器的额外库的列表，例如数学库`-lm`'
- en: '`CPPFLAGS`: Contains C/C++ preprocessor flags, for example you would add `-I<include
    dir>` to search for headers in a non-standard directory `<include dir>`'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPPFLAGS`：包含C/C++预处理器标志，例如，您可以添加`-I<include dir>`来在非标准目录`<include dir>`中搜索头文件'
- en: '`CPP`: The C preprocessor to use'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CPP`：要使用的C预处理器'
- en: 'Sometimes it is sufficient to set only the `CC` variable, as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有时只需设置`CC`变量即可，如下所示：
- en: '[PRE34]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'At other times, that will result in an error like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他时候，这将导致如下错误：
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The reason for the failure is that `configure` often tries to discover the
    capabilities of the toolchain by compiling snippets of code and running them to
    see what happens, which cannot work if the program has been cross compiled. Nevertheless,
    there is a hint in the error message of how to solve the problem. Autotools understands
    three different types of machine that may be involved when compiling a package:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的原因是`configure`经常尝试通过编译代码片段并运行它们来发现工具链的功能，以查看发生了什么，如果程序已经进行了交叉编译，这种方法是行不通的。然而，错误消息中有解决问题的提示。Autotools理解编译软件包时可能涉及的三种不同类型的机器：
- en: '**Build**: This is the computer that is to build the package, which defaults
    to the current machine.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**：这是用于构建软件包的计算机，默认为当前计算机。'
- en: '**Host**: This is the computer the program will run on: for a native compile
    this is left blank and it defaults to be the same computer as build. For a cross
    compile you set it to be the tuple of your toolchain.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机**：这是程序将在其上运行的计算机：对于本地编译，这将保持为空白，并且默认为与构建相同的计算机。对于交叉编译，您需要将其设置为您的工具链的元组。'
- en: '**Target**: This is the computer the program will generate code for: you would
    set this when building a cross compiler, for example.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**：这是程序将为其生成代码的计算机：例如，构建交叉编译器时会设置这个。'
- en: 'So, to cross compile, you just need to override host, as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要进行交叉编译，您只需要覆盖主机，如下所示：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'One final thing to note is that the default install directory is `<sysroot>/usr/local/*`.
    You would usually install it in `<sysroot>/usr/*` so that the header files and
    libraries would be picked up from their default locations. The complete command
    to configure a typical Autotools package is:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一件事是默认安装目录是`<sysroot>/usr/local/*`。通常会将其安装在`<sysroot>/usr/*`中，以便从默认位置获取头文件和库文件。配置典型的Autotools软件包的完整命令是：
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'An example: SQLite'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 例如：SQLite
- en: 'The SQLite library implements a simple relational database and is quite popular
    on embedded devices. You begin by getting a copy of SQLite:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite库实现了一个简单的关系型数据库，在嵌入式设备上非常受欢迎。您可以通过获取SQLite的副本来开始：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, run the configure script:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行配置脚本：
- en: '[PRE39]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'That seems to work! If it failed, there would be error messages printed to
    the terminal and recorded in `config.log`. Note that several makefiles have been
    created, so now you can build it:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好像可以了！如果失败，终端会打印错误消息，并记录在`config.log`中。请注意，已创建了几个makefile，现在您可以构建它：
- en: '[PRE40]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, you install it into the toolchain directory by setting the `make` variable
    `DESTDIR`. If you don't, it will try to install it into the host computer's `/usr`
    directory which is not what you want.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过设置`make`变量`DESTDIR`将其安装到工具链目录中。如果不这样做，它将尝试将其安装到主机计算机的`/usr`目录中，这不是您想要的。
- en: '[PRE41]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You may find that final command fails with a file permissions error. A crosstool-NG
    toolchain will be read-only by default, which is why it is useful to set `CT_INSTALL_DIR_RO`
    to `y` when building it. Another common problem is that the toolchain is installed
    in a system directory such as `/opt` or `/usr/local` in which case you will need
    root permissions when running the install.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现最终的命令失败并出现文件权限错误。crosstool-NG工具链默认为只读，因此在构建时将`CT_INSTALL_DIR_RO`设置为`y`是很有用的。另一个常见问题是工具链安装在系统目录（例如`/opt`或`/usr/local`）中，这种情况下在运行安装时需要root权限。
- en: 'After installing, you should find that various files have been added to your
    toolchain:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您应该会发现各种文件已添加到您的工具链中：
- en: '`<sysroot>/usr/bin`: sqlite3\. This is a command-line interface for SQLite
    that you can install and run on the target.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sysroot>/usr/bin`：sqlite3。这是SQLite的命令行界面，您可以在目标设备上安装和运行。'
- en: '<`sysroot>/usr/lib`: libsqlite3.so.0.8.6, libsqlite3.so.0, libsqlite3.so libsqlite3.la
    libsqlite3.a. These are the shared and static libraries.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <`sysroot>/usr/lib`：libsqlite3.so.0.8.6，libsqlite3.so.0，libsqlite3.so，libsqlite3.la，libsqlite3.a。这些是共享和静态库。
- en: '`<sysroot>/usr/lib/pkgconfig`: `sqlite3.pc`: This is the package configuration
    file, as described in the following section.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sysroot>/usr/lib/pkgconfig`：`sqlite3.pc`：这是软件包配置文件，如下一节所述。'
- en: '`<sysroot>/usr/lib/include`: `sqlite3.h`, `sqlite3ext.h`: These are the header
    files.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<sysroot>/usr/lib/include`：`sqlite3.h`，`sqlite3ext.h`：这些是头文件。'
- en: '<`sysroot>/usr/share/man/man1`: sqlite3.1\. This is the manual page.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <`sysroot>/usr/share/man/man1`：sqlite3.1。这是手册页。
- en: 'Now you can compile programs that use sqlite3 by adding `-lsqlite3` at the
    link stage:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在链接阶段添加`-lsqlite3`来编译使用sqlite3的程序：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Where, `sqlite-test.c` is a hypothetical program that calls SQLite functions.
    Since sqlite3 has been installed into the sysroot, the compiler will find the
    header and library files without any problem. If they had been installed elsewhere
    you would have to add `-L<lib dir>` and `-I<include dir>`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '其中，`sqlite-test.c`是一个调用SQLite函数的假设程序。由于sqlite3已安装到sysroot中，编译器将无需任何问题地找到头文件和库文件。如果它们已安装在其他位置，您将需要添加`-L<lib
    dir>`和`-I<include dir>`。 '
- en: Naturally, there will be runtime dependencies as well, and you will have to
    install the appropriate files into the target directory as described in [Chapter
    5](ch05.html "Chapter 5. Building a Root Filesystem"), *Building a Root Filesystem*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还会有运行时依赖关系，您需要将适当的文件安装到目标目录中，如[第5章](ch05.html "第5章。构建根文件系统")中所述，*构建根文件系统*。
- en: Package configuration
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件包配置
- en: 'Tracking package dependencies is quite complex. The package configuration utility,
    `pkg-config` ([http://www.freedesktop.org/wiki/Software/pkg-config](http://www.freedesktop.org/wiki/Software/pkg-config))
    helps track which packages are installed and which compile flags each needs by
    keeping a database of Autotools packages in `[sysroot]/usr/lib/pkgconfig`. For
    instance, the one for SQLite3 is named `sqlite3.pc` and contains essential information
    needed by other packages that need to make use of it:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪软件包依赖关系非常复杂。软件包配置实用程序`pkg-config`（[http://www.freedesktop.org/wiki/Software/pkg-config](http://www.freedesktop.org/wiki/Software/pkg-config)）通过在`[sysroot]/usr/lib/pkgconfig`中保持Autotools软件包的数据库来帮助跟踪已安装的软件包以及每个软件包需要的编译标志。例如，SQLite3的软件包配置名为`sqlite3.pc`，包含其他需要使用它的软件包所需的基本信息：
- en: '[PRE43]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can use the utility `pkg-config` to extract information in a form that
    you can feed straight to gcc. In the case of a library like libsqlite3, you want
    to know the library name (`--libs`) and any special C flags (`--cflags`):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`pkg-config`工具来提取信息，以便直接传递给gcc。对于像libsqlite3这样的库，你想要知道库名称(`--libs`)和任何特殊的C标志(`--cflags`)：
- en: '[PRE44]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Oops! That failed because it was looking in the host''s sysroot and the development
    package for libsqlite3 has not been installed on the host. You need to point it
    at the sysroot of the target toolchain by setting the shell variable `PKG_CONFIG_LIBDIR`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！失败了，因为它在主机的sysroot中查找，而主机上没有安装libsqlite3的开发包。你需要通过设置shell变量`PKG_CONFIG_LIBDIR`将其指向目标工具链的sysroot：
- en: '[PRE45]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now the output is `-lsqlite3`. In this case, you knew that already, but generally
    you wouldn''t, so this is a valuable technique. The final command to compile would
    be:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出是`-lsqlite3`。在这种情况下，你已经知道了，但通常情况下你不会知道，所以这是一种有价值的技术。最终的编译命令将是：
- en: '[PRE46]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Problems with cross compiling
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交叉编译的问题
- en: 'Sqlite3 is a well-behaved package and cross compiles nicely but not all packages
    are so tame. Typical pain points include:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Sqlite3是一个行为良好的软件包，可以很好地进行交叉编译，但并非所有软件包都如此温顺。典型的痛点包括：
- en: Home-grown build systems, zlib, for example, has a configure script but it does
    not behave like the Autotools configure described in the previous section
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自制构建系统，例如zlib，有一个配置脚本，但它的行为不像前一节中描述的Autotools配置。
- en: Configure scripts that read `pkg-config` information, headers, and other files
    from the host, disregarding the `--host` override
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取`pkg-config`信息、头文件和其他文件的配置脚本，忽略`--host`覆盖
- en: Scripts that insist on trying to run cross compiled code
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坚持尝试运行交叉编译代码的脚本
- en: Each case requires careful analysis of the error and additional parameters to
    the configure script to provide the correct information or patches to the code
    to avoid the problem altogether. Bear in mind that one package may have many dependencies,
    especially with programs that have a graphical interface using GTK or QT or handle
    multimedia content. As an example, mplayer, which is a popular tool for playing
    multimedia content, has dependencies on over 100 libraries. It would take weeks
    of effort to build them all.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 每种情况都需要仔细分析错误，并向配置脚本提供正确的信息或修补代码以完全避免问题。请记住，一个软件包可能有很多依赖项，特别是对于使用GTK或QT的图形界面或处理多媒体内容的程序。例如，mplayer是一个用于播放多媒体内容的流行工具，它依赖于100多个库。构建它们将需要数周的努力。
- en: Therefore, I would not recommend manually cross compiling components for the
    target in this way except when there is no alternative, or the number of packages
    to build is small. A much better approach is to use a build tool such as Buildroot
    or the Yocto Project, or, avoid the problem altogether by setting up a native
    build environment for your target architecture. Now you can see why distributions
    like Debian are always compiled natively.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我不建议以这种方式手动交叉编译目标的组件，除非没有其他选择，或者要构建的软件包数量很少。一个更好的方法是使用Buildroot或Yocto Project等构建工具，或者通过为目标架构设置本地构建环境来完全避免这个问题。现在你可以看到为什么像Debian这样的发行版总是本地编译的了。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'The toolchain is always your starting point: everything that follows from that
    is dependent on having a working, reliable toolchain.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 工具链始终是你的起点：从那里开始的一切都依赖于拥有一个工作的、可靠的工具链。
- en: Most embedded build environments are based on a cross development toolchain
    which creates a clear separation between a powerful host computer building the
    code and a target computer on which it runs. The toolchain itself consists of
    the GNU binutils, a C compiler from the GNU compiler collection – and quite likely
    the C++ compiler as well – plus one of the C libraries I have described. Usually
    the GNU debugger, gdb, will be generated at this point, which I describe in [Chapter
    12](ch12.html "Chapter 12. Debugging with GDB"), *Debugging with GDB*. Also, keep
    a watch out for the Clang compiler, as it will develop over the next few years.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数嵌入式构建环境都是基于交叉开发工具链的，它在强大的主机计算机上构建代码，并在运行代码的目标计算机上创建了明确的分离。工具链本身由GNU binutils、GNU编译器集合中的C编译器，很可能还有C++编译器，以及我描述过的C库之一组成。通常在这一点上会生成GNU调试器gdb，我在[第12章](ch12.html
    "第12章。使用GDB进行调试")中描述了它，*使用GDB进行调试*。此外，要密切关注Clang编译器，因为它将在未来几年内发展。
- en: 'You may start with nothing but a toolchain – perhaps built using crosstool-NG
    or downloaded from Linaro – and use it to compile all of the packages that you
    need on your target, accepting the amount of hard work this will entail. Or, you
    may obtain the toolchain as part of a distribution which includes a range of packages.
    A distribution can be generated from source code using a build system such as
    Buildroot or the Yocto Project, or it can be a binary distribution from a third
    party, maybe a commercial enterprise like Mentor Graphics or an open source project
    such as the Denx ELDK. Beware of toolchains or distributions that are offered
    to you for free as part of a hardware package: they are often poorly configured
    and not maintained. In any case, you should make the choice according to your
    situation, and then be consistent in its use throughout the project.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能从零开始，只有一个工具链，也许是使用crosstool-NG构建的，或者从Linaro下载的，并使用它来编译你在目标上需要的所有软件包，接受这将需要大量的辛苦工作。或者，你可以作为一个分发的一部分获得工具链，该分发包括一系列软件包。一个分发可以使用Buildroot或Yocto
    Project等构建系统从源代码生成，也可以是来自第三方的二进制分发，也许是像Mentor Graphics这样的商业企业，或者是像Denx ELDK这样的开源项目。要注意的是，作为硬件包的一部分免费提供给你的工具链或分发通常配置不良且未得到维护。无论如何，你应该根据自己的情况做出选择，然后在整个项目中保持一致。
- en: Once you have a toolchain, you can use it to build the other components of your
    embedded Linux system. In the next chapter, you will learn about the bootloader,
    which brings your device to life and begins the boot process.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个工具链，你就可以用它来构建嵌入式Linux系统的其他组件。在下一章中，你将学习关于引导加载程序的知识，它可以让你的设备启动并开始引导过程。
