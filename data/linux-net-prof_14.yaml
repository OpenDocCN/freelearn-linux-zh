- en: '*Chapter 11*: Packet Capture and Analysis in Linux'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：Linux中的数据包捕获和分析'
- en: In this chapter, we'll be discussing packet capturing using Linux. In many respects,
    packets are the closest thing to the *truth* in the data center; the proverb that's
    frequently quoted is *Packets Don't Lie*. No matter what policies or convoluted
    configuration exists on hosts or firewalls, the host and application packets will
    always reflect what's happening. This makes packet capture and, more importantly,
    the analysis of those packets a key problem-solving and troubleshooting skill
    in the toolbox of a network administrator.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论在Linux中使用数据包捕获。在许多方面，数据包是数据中心中最接近*真相*的东西；经常引用的谚语是*数据包不会说谎*。无论主机或防火墙上存在什么样的策略或复杂的配置，主机和应用程序数据包始终会反映发生的情况。这使得数据包捕获，更重要的是对这些数据包进行分析成为网络管理员工具箱中的关键问题解决和故障排除技能。
- en: 'In particular, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将涵盖以下主题：
- en: Introduction to packet capturing – the right places to look
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据包捕获简介-寻找正确的地方
- en: Performance considerations when capturing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行捕获时的性能考虑
- en: Capturing tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获工具
- en: Filtering captured traffic
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤捕获的流量
- en: Troubleshooting an application – capturing a VoIP telephone call
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决应用程序问题-捕获VoIP电话呼叫
- en: Let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we'll capture packets. The initial setup and packet capturing
    use a physical switch that you may not have access to. However, once we start
    looking at the packets themselves, all of the capture files are available for
    download. Since the majority of this chapter is about analyzing and interpreting
    the captured packets, our existing Linux host should do nicely without undue modification.
    This is also a good way for us to ensure that when you are following the examples
    in this chapter, your display matches what we're describing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将捕获数据包。初始设置和数据包捕获使用了一个您可能无法访问的物理交换机。不过，一旦我们开始查看数据包本身，所有捕获文件都可以下载。由于本章的大部分内容都是关于分析和解释捕获的数据包，我们现有的Linux主机应该可以很好地完成工作，而不需要进行过多的修改。这也是我们确保当您按照本章的示例进行操作时，您的显示与我们描述的内容匹配的好方法。
- en: Do feel free to build packet capturing into your lab, though, or better yet
    into your work environment. It's an extremely valuable tool in troubleshooting
    or just to get a better understanding of the various protocols and applications
    that we use every day!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以在实验室中构建数据包捕获，或者更好地集成到您的工作环境中。这是一个非常有价值的工具，可以用来排除故障，或者更好地了解我们每天使用的各种协议和应用程序！
- en: 'The capture files that are referenced in this chapter can be found in the `C11`
    folder of this book''s GitHub repository: [https://github.com/PacktPublishing/Linux-for-Networking-Professionals/tree/main/C11](https://github.com/PacktPublishing/Linux-for-Networking-Professionals/tree/main/C11).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章引用的捕获文件可以在本书的GitHub存储库的`C11`文件夹中找到：[https://github.com/PacktPublishing/Linux-for-Networking-Professionals/tree/main/C11](https://github.com/PacktPublishing/Linux-for-Networking-Professionals/tree/main/C11)。
- en: Introduction to packet capturing – the right places to look
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据包捕获简介-寻找正确的地方
- en: There are multiple ways to intercept and capture packets between two hosts,
    and multiple places in the communications path to do it from. Let's discuss some
    of the more popular choices.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以在两个主机之间拦截和捕获数据包，以及在通信路径中进行捕获的多个位置。让我们讨论一些更受欢迎的选择。
- en: Capturing from either end
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从任一端进行捕获
- en: 'This is definitely the easiest option since when all is well, the hosts at
    both ends of the conversation will receive or send all packets. There are a few
    detractors to this, though:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是最简单的选择，因为一切正常时，对话的两端主机都将接收或发送所有数据包。不过，这也有一些缺点：
- en: You may not have access to either end. Depending on the situation, one of the
    endpoint hosts may not be in your organization at all.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能无法访问任一端。根据情况，其中一个端点主机可能根本不在您的组织中。
- en: Even if they do, you may not have administrative access to the host (or hosts)
    in your environment. Especially in a corporate environment, it's common to see
    that the networking team and/or security team may not have administrative access
    (or any access) on servers especially.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使有，您可能无法在您的环境中对主机（或主机）进行管理访问。特别是在企业环境中，常见的情况是，网络团队和/或安全团队可能无法在服务器上进行管理访问（或任何访问）。
- en: Installing new system software is not usually something you can do willy-nilly
    in most organizations. Most companies require a rigorous change control procedure
    for anything that might affect the operation of workstations or servers.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装新的系统软件通常不是大多数组织可以随意进行的事情。大多数公司对可能影响工作站或服务器操作的任何事物都需要严格的变更控制程序。
- en: Even if a change request for installing a packet capture application is approved,
    odd applications like this can be a bone of contention for months or years after
    installation, where anything strange on the server in question might be blamed
    on "that weird application" that the networking team put on the server.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使安装数据包捕获应用的变更请求得到批准，像这样的奇怪应用程序在安装后可能会成为数月甚至数年的争议焦点，服务器上出现的任何奇怪情况都可能被归咎于“网络团队在服务器上安装的那个奇怪的应用程序”。
- en: If you are troubleshooting a problem, you might not see the issue from the end
    that you have access to. For instance, if some or all of the packets aren't arriving
    at the server (or client), then capturing at the problem station may not help
    you in solving the problem – other than confirming that those packets aren't arriving,
    that is.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在解决问题，您可能无法从您可以访问的端点看到问题。例如，如果一些或所有数据包未到达服务器（或客户端），那么在问题站点进行捕获可能无法帮助您解决问题-除了确认这些数据包未到达之外。
- en: For these reasons, it's often preferred to capture packets at some mid-point
    in the path. A popular choice is to configure a switch port to *mirror* or *monitor*
    the traffic.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常更倾向于在路径的某个中间点捕获数据包。一个受欢迎的选择是配置交换机端口来*镜像*或*监视*流量。
- en: Switching the monitoring port
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切换监控端口
- en: A common situation is that we need to capture packets to or from a host but
    we're not able to access either host, can't interrupt the service, or can't get
    the necessary permissions to install packet capturing software. Since these situations
    are very common, switch vendors have implemented features to help us out. Most
    switches will have the facility to *mirror* or *monitor* traffic to or from a
    port. This is commonly called a **Switched Port Analyzer** (**SPAN**) configuration.
    From the switch, we simply configure what port we're monitoring, whether we want
    sent (Tx), received (Rx), or both directions of traffic, and which port we want
    the data to be sent to.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 常见情况是，我们需要捕获发送到或从主机的数据包，但我们无法访问任何主机，无法中断服务，或无法获得安装数据包捕获软件所需的权限。由于这些情况非常普遍，交换机供应商已经实施了一些功能来帮助我们。大多数交换机都有将流量镜像或监视到或从端口的功能。这通常被称为**交换端口分析器**（**SPAN**）配置。从交换机上，我们只需配置要监视的端口，我们是要发送（Tx）、接收（Rx）还是双向流量，以及我们要将数据发送到哪个端口。
- en: 'On a Cisco switch, for instance, in this configuration, we are monitoring the
    `GigabitEthernet 1/0/1` port (both send and receive), and our packet capture host
    is on the `GigabitEthernet 1/0/5` port:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在思科交换机上，在这种配置中，我们正在监视`GigabitEthernet 1/0/1`端口（发送和接收），我们的数据包捕获主机位于`GigabitEthernet
    1/0/5`端口上：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, these are defined for `monitor session 1`, which implies that
    yes, most switches will support more than one monitor session at a time. This
    can be expanded by monitoring for an entire VLAN (so the source might be VLAN
    7) or sending the packet capture to a remote destination, called a **Remote Switched
    Port Analyzer** (**RSPAN**) destination.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这些都是为`monitor session 1`定义的，这意味着是的，大多数交换机将支持同时进行多个监视会话。这可以通过监视整个VLAN（因此源可能是VLAN
    7）或将数据包捕获发送到远程目的地，称为**远程交换端口分析器**（**RSPAN**）目的地来扩展。
- en: If there are firewalls or load balancers in the mix, be careful about which
    source port you define – your packet capture data will differ quite a bit if it
    is captured before or after NAT, for instance.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果混合中有防火墙或负载均衡器，请注意您定义的源端口 - 例如，如果在NAT之前或之后捕获数据包，您的数据包捕获数据将有很大不同。
- en: Where else can you look for packets in a particular conversation? Network devices
    are another popular choice here.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在哪里还可以查找特定对话中的数据包？网络设备在这里也是一个受欢迎的选择。
- en: Intermediate in-line host
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间的内联主机
- en: 'In this case, an intermediate host such as a router, switch, or firewall can
    capture traffic. Firewalls in particular are handy since in many cases, you can
    capture traffic both before and after NAT. This approach makes great sense if
    you are troubleshooting a well-defined problem. However, the following must be
    taken into account:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，中间主机，如路由器、交换机或防火墙，可以捕获流量。特别是防火墙非常方便，因为在许多情况下，您可以在NAT之前和之后捕获流量。如果您正在解决一个明确定义的问题，这种方法非常合理。但是，必须考虑以下问题：
- en: Network devices usually have limited storage, so you'll need to keep the overall
    volume of packets within the storage capacity of the capturing device. On some
    devices, you can send your capture to a remote destination in real time to take
    this issue off the table, but there are issues with that as well.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络设备通常具有有限的存储空间，因此您需要将数据包的总体量保持在捕获设备的存储容量范围内。在某些设备上，您可以实时将捕获发送到远程目的地，以解决这个问题，但这也会带来其他问题。
- en: In either case, the packet rate should be low. In many cases, local storage
    on these devices is relatively slow, and if the packet rates are high, sending
    the packet capture to a network destination in real time could result in lost
    packets in your capture.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论哪种情况，数据包速率都应该很低。在许多情况下，这些设备上的本地存储相对较慢，如果数据包速率很高，实时将数据包捕获发送到网络目的地可能会导致捕获中丢失数据包。
- en: Capturing packets will adversely affect the CPU of the capturing device. Be
    sure that your overall CPU utilization is low before considering adding a packet
    capture to the load on this device.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获数据包会对捕获设备的CPU产生不利影响。在考虑在此设备上增加数据包捕获负载之前，请确保您的整体CPU利用率较低。
- en: If you send the captured packets to a remote destination, make sure that there
    is sufficient bandwidth to do that – if you exceed the bandwidth of the port,
    you will drop packets either on the capture side or the send side of this equation.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您将捕获的数据包发送到远程目的地，请确保有足够的带宽来做到这一点 - 如果超出端口的带宽，您将在捕获端或发送端丢失数据包。
- en: All this being said, in many cases, you are looking for very specific packets
    in a stream to troubleshoot a problem so that you can craft a *filter* to collect
    just that traffic.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总之，在许多情况下，您正在寻找流中非常特定的数据包以排除问题，以便制作一个*过滤器*来仅收集该流量。
- en: 'A more complete description of using a Cisco router as a *collector* for packets
    can be found here: https://isc.sans.edu/forums/diary/Using+a+Cisco+Router+as+a
    +Remote+Collector+for+tcpdump+or+Wireshark/7609/.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用思科路由器作为数据包*收集器*的更完整描述，请参阅：https://isc.sans.edu/forums/diary/Using+a+Cisco+Router+as+a
    +Remote+Collector+for+tcpdump+or+Wireshark/7609/。
- en: Other platforms' packet capture facilities are usually very similar – they create
    a *list* that defines the traffic of interest, then start the capturing process.
    Whatever your device, your vendor will have this documented more completely than
    what we can address here.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 其他平台的数据包捕获设施通常非常相似 - 它们创建一个*列表*来定义感兴趣的流量，然后开始捕获过程。无论您的设备是什么，您的供应商都会比我们在这里提到的更全面地记录这一点。
- en: Finally, we'll look at the "purist" approach; that is, using a network tap.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看看“纯粹”的方法；也就是使用网络监听器。
- en: Network tap
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络监听器
- en: A tap is a hardware device that is inserted in-line into the traffic and allows
    full monitoring in either or both directions. Because it's traditionally an electrical/hardware
    solution, there's no quibbling about packet capacity; every bit in either direction
    is simply replicated electrically to the listening station. However, taps do cost
    money and require that you be on-premises. You also have to disconnect the Ethernet
    cable in question to put the tap in line. For these reasons, taps are still very
    handy to have, but are often not used anymore.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: tap是一种硬件设备，插入到流量中，允许在任一方向或两个方向进行全面监控。因为它传统上是一个电气/硬件解决方案，所以没有关于数据包容量的争论；任何方向上的每一位都简单地被电气地复制到监听站。然而，tap需要花钱，并且需要您在现场。您还必须断开相关的以太网电缆以将tap放在线。因此，tap仍然是非常方便的，但通常不再经常使用。
- en: 'A typical low-end tap (`10` or `10/100`) is the Ethernet "Throwing Star" by
    Michael Ossmann, which can be found at [https://greatscottgadgets.com/throwingstar/](https://greatscottgadgets.com/throwingstar/).
    The following diagram shows how a typical low-end (`10/100`) tap like this operates.
    Note that there are two ways to build a tap – as shown in the following diagram,
    you can construct a listen-only tap with two ports, each "listening" for traffic
    in one direction only:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Michael Ossmann的Typical low-end tap（`10`或`10/100`）是以太网“Throwing Star”，可以在[https://greatscottgadgets.com/throwingstar/](https://greatscottgadgets.com/throwingstar/)找到。以下图表显示了这样一个典型的低端（`10/100`）的tap是如何操作的。请注意，有两种构建tap的方法
    - 如下图所示，您可以构建一个具有两个端口的仅监听tap，每个端口只“监听”一个方向的流量：
- en: '![Figure 11.1 – Two tap ports, each in one direction'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 - 两个tap端口，每个方向一个'
- en: '](img/B16336_11_001.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_001.jpg)'
- en: Figure 11.1 – Two tap ports, each in one direction
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 - 两个tap端口，每个方向一个
- en: 'You also have the more traditional tap, which will "hear" traffic in both directions
    on a single port:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用更传统的tap，它将在单个端口上“听到”两个方向的流量：
- en: '![Figure 11.2 – One tap port sees all traffic (only pins)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2 - 一个tap端口看到所有流量（只有引脚）'
- en: '](img/B16336_11_002.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_002.jpg)'
- en: Figure 11.2 – One tap port sees all traffic (only pins)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 - 一个tap端口看到所有流量（只有引脚）
- en: This all worked until 1 GB Ethernet, at which point the signal loss of taps
    like this became a problem. 10 Gbps is even more complex to capture with a tap,
    in that the actual Layer 1 signaling no longer matches that of standard Ethernet.
    For these reasons, at 10 Gbps or above, taps are active devices, behaving more
    like switches with one or more SPAN ports than passive devices. The signal is
    still fully replicated to the destination ports, but there's more circuitry behind
    it to ensure that the signal that's sent to the actual source, destination, and
    capturing hosts can still be reliably read by all parties.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是有效的，直到1GB以太网出现，此时像这样的tap的信号损失成为了一个问题。10Gbps甚至更复杂，因为实际的第1层信号不再匹配标准以太网。因此，在10Gbps或以上的情况下，tap是主动设备，更像是具有一个或多个SPAN端口的交换机，而不是被动设备。信号仍然完全复制到目标端口，但背后有更多的电路来确保发送到实际源、目的地和捕获主机的信号仍然可以被所有方可靠地读取。
- en: Where we do still see taps used is in some specific security settings, where
    1G, 10G, or faster traffic must be captured, but we also need electrical isolation
    to prevent any transmission.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以看到tap在一些特定的安全设置中使用，其中需要捕获1G、10G或更快的流量，但我们也需要电气隔离来防止任何传输。
- en: Taps are still handy troubleshooting devices to keep in your laptop bag for
    the unusual situation where you need exactly this, but as noted, they are not
    often used anymore for run-of-the-mill packet captures.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，tap仍然是一种方便的故障排除设备，可以放在您的笔记本电脑包中，以备需要时使用，但正如前面所述，它们在普通数据包捕获中不经常使用。
- en: So far, we've described various legitimate methods of capturing packets, but
    how do the criminals and their malware get the job done?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经描述了各种合法的捕获数据包的方法，但是犯罪分子和他们的恶意软件是如何完成这项工作的呢？
- en: Malicious packet capture approaches
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恶意数据包捕获方法
- en: So far, we've considered how to legitimately capture packets. However, if you
    are considering malicious intent, how can you defend against an attacker that
    might use other methods? To do this, let's think like our attacker, and look at
    how they might set up a packet capture station without administrative access to
    anything.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经考虑了如何合法地捕获数据包。然而，如果你考虑恶意意图，你如何防御可能使用其他方法的攻击者？为了做到这一点，让我们像攻击者一样思考，看看他们可能如何在没有对任何东西进行管理访问的情况下建立一个数据包捕获站。
- en: The first method was covered in [*Chapter 7*](B16336_07_Final_NM_ePub.xhtml#_idTextAnchor118),
    *DHCP Services on Linux*. The attacker can mount a rogue DHCP server, and either
    make their host the default gateway or a proxy server (using the WPAD method)
    for the target computers. In either method, the victim's packets route through
    the attacker's host and can be captured. If the protocols are in clear text (for
    instance, using HTTP, TFTP, FTP, or SIP, as we'll see later in this chapter, in
    the *Troubleshooting* *an application – capturing a VoIP telephone call* section),
    these packets can either be stored for later analysis or even modified in real
    time. We can protect against attacks of this type by securing DHCP services (as
    we discussed in [*Chapter 7*](B16336_07_Final_NM_ePub.xhtml#_idTextAnchor118),
    *DHCP Services on Linux*).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法在[*第7章*](B16336_07_Final_NM_ePub.xhtml#_idTextAnchor118)中已经涵盖过，*Linux上的DHCP服务*。攻击者可以挂载一个恶意的DHCP服务器，并将他们的主机设置为目标计算机的默认网关或代理服务器（使用WPAD方法）。在任何一种方法中，受害者的数据包都会通过攻击者的主机并被捕获。如果协议是明文的（例如，使用HTTP，TFTP，FTP或SIP，正如我们将在本章的*故障排除*
    *应用程序 - 捕获VoIP电话呼叫*部分中看到的那样），这些数据包可以被存储以供以后分析，甚至可以实时修改。我们可以通过保护DHCP服务来防御这种类型的攻击（正如我们在[*第7章*](B16336_07_Final_NM_ePub.xhtml#_idTextAnchor118)中讨论的那样，*Linux上的DHCP服务*）。
- en: Similarly, an attacker can hijack a routing protocol to capture traffic for
    a specific subnet or host. We see this occasionally on the internet, where a subnet
    might be hijacked using the trusting nature of the BGP routing protocol. In these
    situations, we often see credit card portals being redirected to unexpected countries,
    where people's credentials are harvested as they log into the fake website that's
    ready for them there. How can a victim protect themselves in a case like this?
    Actually, it's both simpler and less reliable than you might think. If the victim
    receives a warning of an invalid certificate, they should close that session and
    not proceed. Unfortunately, while this is indeed a simple solution (that warning
    screen is almost full-page, and has lots of red in it), it's also not very reliable,
    as many people will simply click whatever it takes to dismiss the warning and
    proceed to the site.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，攻击者可以劫持路由协议来捕获特定子网或主机的流量。我们偶尔在互联网上看到这种情况，其中一个子网可能会被劫持，利用BGP路由协议的信任性质。在这些情况下，我们经常看到信用卡门户被重定向到意想不到的国家，人们的凭据在他们登录到那里准备好的假网站时被收集。在这种情况下，受害者如何保护自己？实际上，这比你想象的要简单和不可靠。如果受害者收到无效证书的警告，他们应该关闭该会话，不要继续。不幸的是，虽然这确实是一个简单的解决方案（警告屏幕几乎是整页的，而且有很多红色），但它也不是很可靠，因为许多人会简单地点击任何可以解除警告并继续访问网站的按钮。
- en: 'The other commonly seen method that an attacker can use to capture packets
    is called ARP cache poisoning. To understand this, you might need to review how
    ARP works ([*Chapter 3*](B16336_03_Final_NM_ePub.xhtml#_idTextAnchor053), *Using
    Linux and Linux Tools for Network Diagnostics*). At a high level, the attacker
    uses ARP packets to "lie" to each victim – this can easily be seen in the following
    diagram:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以使用的另一种常见方法是ARP缓存中毒来捕获数据包。要理解这一点，您可能需要复习一下ARP的工作原理（[*第3章*](B16336_03_Final_NM_ePub.xhtml#_idTextAnchor053)，*使用Linux和Linux工具进行网络诊断*）。在高层次上，攻击者使用ARP数据包向每个受害者“说谎”
    - 这在下图中很容易看出：
- en: '![Figure 11.3 – ARP cache poisoning'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3 - ARP缓存中毒'
- en: '](img/B16336_11_003.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_003.jpg)'
- en: Figure 11.3 – ARP cache poisoning
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 - ARP缓存中毒
- en: In this diagram, the two victims are `3333.3333.3333`, and telling `3333.3333.3333`.
    The switch doesn't see any of this; it just routes the various packets around
    since they're all technically valid. Now, when `3333.3333.3333`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，两个受害者是`3333.3333.3333`，并告诉`3333.3333.3333`。交换机并没有看到任何这些；它只是路由各种数据包，因为它们在技术上都是有效的。现在，当`3333.3333.3333`。
- en: The attacker can expand this to off-network captures if **Victim 2** happens
    to be the default gateway for the subnet.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**受害者2**恰好是子网的默认网关，攻击者可以扩展到脱网捕获。
- en: This seems somewhat complex, but it's been automated for many years now – the
    first tool for this type of attack was *dSniff*, written by *Dug Song* way back
    in 2000\. A more modern tool that uses a GUI and allows you to graphically select
    your various victims is Ettercap. Ettercap and its successor, Bettercap, have
    the advantage that as they see "artifacts of interest" such as credentials or
    password hashes, they will collect them automatically.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎有些复杂，但多年来已经实现了自动化 - 这种类型攻击的第一个工具是*Dug Song*在2000年编写的*dSniff*。一个更现代的工具，使用图形界面，允许您图形化选择各种受害者的工具是Ettercap。Ettercap及其后继者Bettercap的优势在于，它们一旦发现“感兴趣的痕迹”，如凭据或密码哈希，它们将自动收集这些信息。
- en: After the process is complete, when Ettercap closes, it gracefully repopulates
    the ARP table of all of the victim stations with the correct values. The implication
    of this is that if Ettercap closes in a non-graceful way (for instance, being
    kicked off the network or being "swamped" by too much traffic), the victim sites
    will be "stranded" with the wrong ARP entries, often for the duration of the ARP
    timer of each workstation. If the attacker station had the subnet's default gateway
    in its list, this situation will isolate the entire subnet for the duration of
    the ARP timer of the gateway (which can be up to 4 hours).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 过程完成后，当Ettercap关闭时，它会优雅地重新填充所有受害者站点的ARP表，以正确的值。这意味着如果Ettercap以非优雅的方式关闭（例如，被踢出网络或被过多的流量“淹没”），受害站点将被“困”在错误的ARP条目中，通常持续到每个工作站的ARP计时器到期。如果攻击者站点在其列表中有子网的默认网关，这种情况将隔离整个子网，持续时间为网关的ARP计时器（最长可达4小时）。
- en: How can we protect against an attack of this type? Logging is a great start
    here. Most modern-day switches and routers will log a `Duplicate IP Address` error
    when it sees two different MAC addresses claiming to have the same IP address.
    Alerts on log entries of this type (see [*Chapter 12*](B16336_12_Final_NM_ePub.xhtml#_idTextAnchor216),
    *Network Monitoring Using Linux*) can help in starting a proactive incident response
    program.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何保护自己免受这种攻击？日志记录是一个很好的起点。大多数现代交换机和路由器在看到两个不同的MAC地址声称拥有相同的IP地址时会记录`重复IP地址`错误。对这种类型的日志条目进行警报（参见[*第12章*](B16336_12_Final_NM_ePub.xhtml#_idTextAnchor216)，*使用Linux进行网络监控*）可以帮助启动积极的事件响应计划。
- en: Is there something more "active" that we can do? Most switches have a feature
    called **Dynamic ARP Inspection** (**DAI**) that will look for exactly this type
    of attack. When the attack is seen, the attacker's Ethernet port is disabled.
    You want to take care where this is implemented, though – don't configure DAI
    on a switch port that has a downstream switch or a wireless access point; otherwise,
    the attacker will take lots of innocent bystanders down with them when their port
    is disabled. Ports with downstream switches or APs are generally configured as
    "trusted," with the expectation that the downstream device will handle inspection
    for its own connected stations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能做些更“积极”的事情吗？大多数交换机都有一个名为**动态ARP检查**（**DAI**）的功能，可以查找这种类型的攻击。当发现攻击时，攻击者的以太网端口将被禁用。不过，要注意实施这个功能的位置
    - 不要在具有下游交换机或无线接入点的交换机端口上配置DAI；否则，当他们的端口被禁用时，攻击者将带走许多无辜的旁观者。通常会将具有下游交换机或AP的端口配置为“受信任”，期望下游设备将处理其自己连接的站点的检查。
- en: 'DAI looks very similar to DHCP inspection and trust configuration:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: DAI看起来与DHCP检查和信任配置非常相似：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we mentioned previously, on switch ports that have downstream switches,
    APs, and so on, you can disable DAI with the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，在具有下游交换机、AP等的交换机端口上，你可以使用以下方法禁用DAI：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To decrease the DAI ARP threshold from the default limit of 15 packets per
    second to something lower (10, in this example), you can do the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要将DAI ARP阈值从默认的每秒15个数据包降低到更低的值（例如10），可以执行以下操作：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If ARP inspection was enabled during an attack using a tool such as Ettercap,
    that tool will usually send a steady stream of ARP packets to its victims, to
    ensure that their ARP cache stays poisoned. In that situation, the affected switch
    would generate `DAI-4-"DHCP_SNOOPING_DENY" "Invalid ARPs"` error messages as the
    port threshold was exceeded. The port would also create the `ERR-DISABLE` status,
    taking the attacker offline completely.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在攻击中启用了ARP检查，使用Ettercap等工具，该工具通常会向受害者发送一系列稳定的ARP数据包，以确保他们的ARP缓存保持被感染状态。在这种情况下，受影响的交换机将生成“DAI-4-"DHCP_SNOOPING_DENY"
    "Invalid ARPs"”错误消息，因为端口阈值已超过。端口还将创建“ERR-DISABLE”状态，完全使攻击者下线。
- en: In today's world of ever-increasing network speeds, though, you may find that
    you are in a position where the data being captured exceeds the capacity of your
    workstation – don't give up, though; there are optimizations that you can make
    that might help!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在当今不断增长的网络速度世界中，你可能会发现你所捕获的数据超出了你工作站的容量 - 但不要放弃，有一些优化可以帮助你！
- en: Performance considerations when capturing
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在捕获时的性能考虑
- en: As we alluded to in the previous section, once the data rates start to go up,
    capturing packets can impact a host, even if it's a higher-end Linux host or VM.
    There are also some network decisions to make when you are setting up for a packet
    capture.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中提到的，一旦数据速率开始上升，即使是高端Linux主机或虚拟机，捕获数据包也会对主机产生影响。在设置数据包捕获时，还有一些网络决策需要考虑。
- en: 'Factors to consider include the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的因素包括：
- en: If you are using a SPAN or Monitor port, depending on the switch model, your
    destination port (the one your sniffer station is plugged into) may not be on
    the network – it might only see the traffic to and from the source. What this
    means is that often, you must use your fastest onboard NIC for packet capturing,
    and then use a lower performance USB NIC if that host needs to be active on the
    network at the same time (for instance, if you are remoting to it).
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用SPAN或监视端口，根据交换机型号，你的目的地端口（你的嗅探器站插入的端口）可能不在网络上 - 它可能只能看到源端口的来往流量。这意味着通常情况下，你必须使用你最快的内置网卡进行数据包捕获，然后如果该主机需要同时在网络上活动（例如，如果你远程连接到它），则使用性能较低的USB网卡。
- en: In all cases, ensure that your NIC is fast enough to actually "see" all of the
    target packets. Especially in a monitor port setup, you can configure a 10 Gbps
    source and a 1 Gbps destination. This will work fine until you start to see the
    traffic volumes exceed 1 Gbps. At that point, the switch will start to queue and/or
    drop packets, depending on the switch model. In other words, your mileage may
    vary, and your results may be unpredictable (or predictably bad).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有情况下，确保你的网卡足够快，可以真正“看到”所有目标数据包。特别是在监视端口设置中，你可以配置一个10 Gbps的源和一个1 Gbps的目的地。这样做是可以的，直到你开始看到流量超过1
    Gbps。在那时，交换机将开始排队和/或丢弃数据包，这取决于交换机型号。换句话说，你的结果可能是不可预测的（或可预测的糟糕）。
- en: Once on the NIC, make sure that the NIC's upstream can handle the traffic volumes.
    For instance, if you are using a 10 Gbps Thunderbolt adapter on a laptop, be sure
    that it's plugged into a Thunderbolt port (not a USB-C port) and that you have
    sufficient bandwidth to add this new bandwidth. For instance, if you have two
    4K screens on that same laptop, chances are that there aren't 10 Gbps left on
    your Thunderbolt uplink for a high-speed packet capture.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦在网卡上，确保网卡的上行能够处理流量。例如，如果你在笔记本上使用了一个10 Gbps的雷电适配器，请确保它插入了一个雷电端口（而不是USB-C端口），并且你有足够的带宽来添加这个新的带宽。例如，如果你在同一台笔记本上有两个4K屏幕，很可能你的雷电上行没有剩余的10
    Gbps来进行高速数据包捕获。
- en: Moving up the line, make sure that your disk has both sufficient speed and capacity.
    If you are capturing 10 Gbps, you'll likely want to target an NVME SSD for storage.
    You'll likely also want it to be on-board, not plugged into the same Thunderbolt
    or USB-C adapter that you have your network adapter on. Alternatively, if you
    are using a server for capturing, take a look at the RAID or SAN throughputs available.
    Especially if the storage is iSCSI, be sure that your packet capture won't be
    "starving" other iSCSI clients of bandwidth to the SAN.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上移动，确保你的硬盘既有足够的速度又有足够的容量。如果你要捕获10 Gbps，你可能会想要选择NVME固态硬盘进行存储。你可能还希望它是内置的，而不是插在你的网络适配器上的同一个雷电或USB-C适配器上。另外，如果你要使用服务器进行捕获，可以查看RAID或SAN的吞吐量。特别是如果存储是iSCSI，确保你的数据包捕获不会“饿死”其他iSCSI客户端的对SAN的带宽。
- en: Consider the size of your ring buffer – tcpdump, in particular, has good flexibility
    regarding this. The ring buffer is the temporary area in memory that captured
    packets are stored in, before being sent to disk or the capturing application's
    memory. On most Linux systems, this defaults to 2 MB, which is usually more than
    adequate. However, if you see that your capture session seems to be missing packets,
    increasing this value might fix that issue. In tcpdump, this is easily adjusted
    with the `-B` parameter – this makes tcpdump an ideal tool to use when you know
    or suspect that you might be pushing the limits with your packet capture. Note
    that tcpdump does not document the default size for this; the 2 MB default is
    just what is commonly seen.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑您的环形缓冲区的大小 - 特别是tcpdump在这方面具有很好的灵活性。环形缓冲区是捕获的数据包存储在内存中的临时区域，在发送到磁盘或捕获应用程序的内存之前。在大多数Linux系统上，默认值为2
    MB，通常是足够的。但是，如果您发现捕获会话似乎丢失了数据包，增加这个值可能会解决这个问题。在tcpdump中，可以使用`-B`参数轻松调整这个值 - 这使得tcpdump成为在您知道或怀疑可能会推动数据包捕获极限时使用的理想工具。请注意，tcpdump没有记录此的默认大小;
    2 MB默认值只是通常看到的。
- en: Consider that you need the entire packet. If you only need the packet headers
    to troubleshoot your issue (in other words, you don't need the actual payload),
    you can adjust `snaplen` – the number of bytes to capture in each packet. For
    instance, decreasing this from `1500` to `64` can dramatically increase the number
    of packets that will fit into your ring buffer. You will want to ensure that the
    `snaplen` value is large enough to capture all of the packet header information.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑到您需要整个数据包。如果您只需要数据包头来排除故障（换句话说，您不需要实际有效载荷），您可以调整`snaplen` - 每个数据包中要捕获的字节数。例如，将此值从`1500`减少到`64`可以大大增加适合环形缓冲区的数据包数量。您将希望确保`snaplen`值足够大，以捕获所有数据包头信息。
- en: Finally, there are also things to keep in mind if you are working as an attacker
    in a sanctioned security exercise such as a penetration test. If you are using
    ARP cache poisoning as part of your engagement, be aware that there is some measure
    of risk to this attack. Be sure that your station has sufficient interface bandwidth,
    CPU, and memory capacity to succeed in an attack of this type – if the **Man in
    the Middle** (**MiTM**) traffic exceeds your station's capacity, your machine
    will likely go offline. What that means to the victims (which could be the entire
    VLAN) is that they will be left with invalid ARP caches and will essentially be
    stranded for the duration of their ARP timers (up to 4 hours on some platforms).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果您作为授权的安全演练（如渗透测试）中的攻击者工作，还有一些事情需要牢记。如果您在参与中使用ARP缓存中毒，请注意此攻击存在一定的风险。确保您的工作站具有足够的接口带宽、CPU和内存容量，以便成功进行此类攻击
    - 如果**中间人**（**MiTM**）流量超过您的工作站的容量，您的机器可能会下线。对受害者（可能是整个VLAN）的影响是，他们将留下无效的ARP缓存，并且基本上在其ARP计时器的持续时间内被困住（在某些平台上长达4小时）。
- en: With all the theory behind us, what tools will we be using to capture and analyze
    packets?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论的理论之后，我们将使用哪些工具来捕获和分析数据包？
- en: Capturing tools
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获工具
- en: Many different tools can be used to capture packets off the network and either
    analyze the packet data directly or store them in `pcap` files. There are even
    more tools that will take those `pcap` files and allow you to do further offline
    analysis on them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 许多不同的工具可以用于从网络中捕获数据包，并直接分析数据包数据，或将它们存储在`pcap`文件中。甚至有更多的工具可以使用这些`pcap`文件，并允许您对其进行进一步的离线分析。
- en: tcpdump
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tcpdump
- en: We've referenced tcpdump several times. This is a command-line packet capture
    tool, which means that it can be used on systems that don't have a GUI or if you
    are using a non-GUI interface such as SSH. Because it's not dealing with any graphics
    and isn't preprocessing packets for you to look at (to tell you any of the protocol
    specifics for instance), it's one of the higher-performance, lowest-impact tools
    you'll find for packet capture.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次提到了tcpdump。这是一个命令行数据包捕获工具，这意味着它可以在没有图形用户界面的系统上使用，或者如果您正在使用非图形用户界面，如SSH。因为它不涉及任何图形，并且不会为您查看（例如告诉您任何协议的具体信息）预处理数据包，所以它是您在数据包捕获中找到的性能最高、影响最小的工具之一。
- en: tcpdump uses the **Berkely Packet Filter** (**BPF**) syntax to decide which
    packets to capture. This can be used to filter by IP address, MAC address, protocol,
    or even specific flags in a TCP packet.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: tcpdump使用**Berkely Packet Filter**（**BPF**）语法来决定要捕获哪些数据包。这可以用于按IP地址、MAC地址、协议甚至TCP数据包中的特定标志进行过滤。
- en: Wireshark
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Wireshark
- en: Wireshark is one of the more commonly used packet capture tools. It has a GUI,
    and each packet is categorized, color-coded, and massaged so that as much information
    is displayed as possible. Similar to tcpdump, Wireshark uses BPF syntax to filter
    packets during capture. It uses a different filter syntax to filter packets being
    displayed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Wireshark是更常用的数据包捕获工具之一。它有一个图形用户界面，每个数据包都被分类、颜色编码和处理，以便尽可能显示更多信息。与tcpdump类似，Wireshark使用BPF语法在捕获期间过滤数据包。它使用不同的过滤语法来过滤显示的数据包。
- en: TShark
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TShark
- en: TShark is packaged with the Wireshark application and is essentially a command-line/text
    version of Wireshark. Having TShark available can be very handy if you are in
    an SSH session and want something a bit more flexible than tcpdump.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: TShark与Wireshark应用程序捆绑在一起，本质上是Wireshark的命令行/文本版本。如果您在SSH会话中并且想要比tcpdump更灵活的东西，那么拥有TShark会非常方便。
- en: Other PCAP tools
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他PCAP工具
- en: There are hundreds, if not thousands, of tools you can use to capture packets
    or analyze packet captures. On the attacker's side, we've already discussed Ettercap,
    Bettercap, and dsniff as MiTM attack tools. Tools such as NetworkMiner are great
    for either packet captures or processing existing packet captures. Tools like
    this allow you to save time in analyzing what can quickly become very large packet
    capture files. NetworkMiner will extract valuable artifacts from `pcap` files
    such as credentials, credential hashes, certificates, and data files that were
    transferred during the captured session.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有数百甚至数千种工具可用于捕获数据包或分析数据包捕获。在攻击者方面，我们已经讨论过Ettercap、Bettercap和dsniff作为中间人攻击工具。像NetworkMiner这样的工具非常适合捕获数据包或处理现有的数据包捕获。这样的工具可以帮助您节省分析可能迅速变得非常庞大的数据包捕获文件所需的时间。NetworkMiner将从`pcap`文件中提取有价值的工件，如凭据、凭据哈希、证书和在捕获会话期间传输的数据文件。
- en: We'll discuss more advanced tools that use packet capture, namely **Intrusion
    Detection Systems** (**IDS**), **Intrusion Prevention Systems** (**IPS**), and
    passive traffic monitoring, in the upcoming chapters ([*Chapter 13*](B16336_13_Final_NM_ePub.xhtml#_idTextAnchor236),
    *Intrusion Prevention Systems on Linux*, and [*Chapter 14*](B16336_14_Final_NM_ePub.xhtml#_idTextAnchor252),
    *Honeypot Services on Linux*).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论更多使用数据包捕获的高级工具，即**入侵检测系统**（**IDS**）、**入侵防御系统**（**IPS**）和被动流量监控，在接下来的章节中（[*第13章*](B16336_13_Final_NM_ePub.xhtml#_idTextAnchor236)，*Linux上的入侵防御系统*，和[*第14章*](B16336_14_Final_NM_ePub.xhtml#_idTextAnchor252)，*Linux上的蜜罐服务*）。
- en: What you will tend to find is that the reason you are doing a packet capture
    in the first place is to solve a problem. Let's discuss how to capture or view
    only the packets that apply to the problem you are working on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现，您进行数据包捕获的原因是为了解决问题。让我们讨论如何捕获或查看只与您正在解决的问题相关的数据包。
- en: Filtering captured traffic
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤捕获的流量
- en: The first thing that you will notice when using a packet capture tool is the
    sheer volume of packets that appear on the display. Since packet captures are
    often done for troubleshooting purposes, you usually want to limit the packets
    to the ones that have issues you need to solve. To that end, you typically either
    want to "filter" those packets during the capture process or filter the display
    of the packets once they have been captured. Let's discuss both situations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据包捕获工具时，您将注意到显示屏上出现的数据包数量之多。由于数据包捕获通常是为了故障排除目的而进行的，通常希望将数据包限制在需要解决的问题上。为此，您通常要么在捕获过程中“过滤”这些数据包，要么在捕获后过滤这些数据包的显示。让我们讨论这两种情况。
- en: Wireshark capture filters (capturing your home network traffic)
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Wireshark捕获过滤器（捕获您的家庭网络流量）
- en: With no particular switch configuration, packet captures on your home network
    will find more than you might think. Lots of homes these days have a small herd
    of network-connected Linux-based appliances – if connected, your TV, thermostat,
    doorbell, treadmill, and fridge are likely all Linux hosts. These are commonly
    referred to as **Internet of Things** (**IoT**) devices. Almost all IoT hosts
    are likely broadcasting and multicasting a constant stream of "discovery" packets
    on your wired and wireless network, which they do to find controllers and hubs
    that might want to talk to them or even control them.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有特定的交换配置的情况下，在您的家庭网络上进行数据包捕获将发现比您想象的更多。如今，许多家庭都有一小群连接到网络的基于Linux的设备-如果连接的话，您的电视、恒温器、门铃、跑步机和冰箱很可能都是Linux主机。这些通常被称为**物联网**（**IoT**）设备。几乎所有物联网主机都可能在有线和无线网络上广播和多播一系列不断的“发现”数据包，它们这样做是为了找到可能想要与它们交谈甚至控制它们的控制器和中心。
- en: Let's take a quick look – we'll use the Wireshark tool for this.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下-我们将使用Wireshark工具进行此操作。
- en: Start the tool and select the network adapter that connects to your network.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 启动工具并选择连接到您的网络的网络适配器。
- en: 'Before you hit **Start**, let''s add a capture filter. We''ll exclude our address,
    and also exclude ARP packets from the capture. Note that your IP address will
    be different:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在点击**开始**之前，让我们添加一个捕获过滤器。我们将排除我们的地址，并且还将排除ARP数据包的捕获。请注意，您的IP地址将不同：
- en: '![Figure 11.4 – Adding a capture filter to Wireshark'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.4-向Wireshark添加捕获过滤器'
- en: '](img/B16336_11_004.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_004.jpg)'
- en: Figure 11.4 – Adding a capture filter to Wireshark
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4-向Wireshark添加捕获过滤器
- en: Now, hit the **Start Capture** button, the blue *shark fin* icon at the top
    left, or choose **Capture/Start**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击**开始捕获**按钮，位于左上角的蓝色*鲨鱼鳍*图标，或选择**捕获/开始**。
- en: 'On a typical home network, you should have dozens of packets to explore within
    a few seconds – the following screenshot shows the packets after 10 seconds on
    my home network. You will likely see a mix of broadcast and multicast traffic
    – traffic that is, by definition, sent to all stations. While this might be seen
    as a limited capture, you can use this to start an inventory of what''s on your
    network:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的家庭网络上，您应该在几秒内就能探索到数十个数据包-以下屏幕截图显示了我家网络上10秒后的数据包。您可能会看到广播和多播流量的混合-根据定义，这些流量是发送到所有站点的。虽然这可能被视为有限的捕获，但您可以用它来开始对您的网络上的内容进行清点：
- en: '![Figure 11.5 – A typical home network capture'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.5-典型家庭网络捕获'
- en: '](img/B16336_11_005.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_005.jpg)'
- en: Figure 11.5 – A typical home network capture
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5-典型家庭网络捕获
- en: 'Even without exploring the packet''s contents, there are a few key things to
    note regarding the preceding screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不探索数据包的内容，也有一些关键事项需要注意前面的屏幕截图：
- en: Some IPv4 devices are operating in the `169.254.0.0/16` range (the Automatic
    Private IP Addressing range). These addresses cannot route off your network, but
    for things such as TV remotes or doorbells talking to a controller on the local
    network, that's perfectly OK.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些IPv4设备正在`169.254.0.0/16`范围内运行（自动私有IP地址范围）。这些地址无法路由到您的网络之外，但对于诸如电视遥控器或门铃与本地网络上的控制器通信等事情来说，这是完全可以的。
- en: You'll likely see Spanning Tree traffic from your local switch, and if you wait
    long enough, you'll likely see **Link Layer Discovery Protocol** (**LLDP**) or
    **Cisco Discovery Protocol** (**CDP**) packets from switches as well (we'll see
    an example of this later in this section).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可能会在本地交换机上看到生成树流量，如果等待足够长的时间，您可能会看到**链路层发现协议** (**LLDP**) 或**Cisco发现协议** (**CDP**)
    数据包（我们稍后在本节中将看到一个示例）。
- en: You'll also very likely see IPv6 traffic – in this capture, we can see `DHCPv6`
    and `ICMPv6` packets.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还很可能会看到IPv6流量 – 在这个捕获中，我们可以看到`DHCPv6`和`ICMPv6`数据包。
- en: All this from 10 seconds of listening! For fun, dig into your home network,
    even something as simple as looking at the MAC addresses you see, and identify
    the vendor for each using its OUI.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些来自10秒的收听！有趣的是，深入研究您的家庭网络，甚至简单地查看您看到的MAC地址，并使用其OUI标识每个供应商。
- en: Let's dig deeper into a specific set of devices from a packet point of view
    – **Voice over IP** (**VoIP**) phones.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从数据包的角度深入研究一组特定设备 – **Voice over IP** (**VoIP**) 电话。
- en: tcpdump capture filters – VoIP phones and DHCP
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tcpdump捕获过滤器 – VoIP电话和DHCP
- en: 'Let''s explore capture filters in both tcpdump and Wireshark by looking at
    the boot-up sequence of a typical VoIP phone. Our network is pretty simple; there
    are four stations and two VLANs:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过查看典型VoIP电话的启动序列来探索tcpdump和Wireshark中的捕获过滤器。我们的网络非常简单；有四个站点和两个VLAN：
- en: '![Figure 11.6 – Lab setup for packet captures'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.6 – 数据包捕获的实验室设置'
- en: '](img/B16336_11_006.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_006.jpg)'
- en: Figure 11.6 – Lab setup for packet captures
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 数据包捕获的实验室设置
- en: Note that we have a monitor session set up, where port `5` receives all packets
    in and out of port `1`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们设置了一个监视会话，其中端口`5`接收端口`1`的所有数据包。
- en: 'A summary of the stations involved in the startup and communications of the
    VoIP phones is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: VoIP电话启动和通信涉及的站点总结如下：
- en: '![](img/B16336_11_Table_01.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16336_11_Table_01.jpg)'
- en: Note that as we go from left to right in the table, we're traveling down the
    "stack" that's represented by the ISO model – the extensions are represented in
    the application layer, IP addresses are Layer 4, MAC addresses and VLANs are Layer
    2, and finally we have the interfaces themselves.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们从表的左侧向右侧移动时，我们正在沿着ISO模型表示的“堆栈”向下移动 – 扩展在应用层表示，IP地址是第4层，MAC地址和VLAN是第2层，最后是接口本身。
- en: First, let's use tcpdump to capture a DHCP sequence on the DHCP server itself.
    Using this host is handy because the DHCP server is one end of the DHCP "conversation,"
    so if all is working well, it should see all of the packets in both directions.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用tcpdump在DHCP服务器上捕获DHCP序列。使用这个主机很方便，因为DHCP服务器是DHCP“对话”的一端，所以如果一切正常，它应该能看到双向的所有数据包。
- en: Also, using tcpdump means that we're not dependent on any GUI – if you are operating
    from an SSH session, you are still fully supported. tcpdump is almost universally
    supported. tcpdump is installed by default on almost every Linux distribution,
    and in addition, you can call tcpdump (using one syntax or another) on most firewalls,
    routers, and switches – this isn't surprising, given how many of these platforms
    are Linux or BSD Unix-based.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用tcpdump意味着我们不依赖于任何GUI – 如果您正在从SSH会话中操作，您仍然得到充分的支持。tcpdump几乎被普遍支持。tcpdump默认安装在几乎每个Linux发行版上，此外，您可以在大多数防火墙、路由器和交换机上调用tcpdump（使用一种或另一种语法）
    – 这并不奇怪，考虑到这些平台中有多少是基于Linux或BSD Unix的。
- en: 'Let''s get on with the capture. Because the source station doesn''t have an
    IP address yet, we''ll need to specify the traffic based on the MAC address of
    the phone and the two UDP ports used by DHCP: `67/udp` (bootps) and `68/udp` (bootpc).
    We''ll capture the full packets and write them to a file – note that *sudo* rights
    are needed for the actual capture.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续捕获。因为源站点尚未具有IP地址，所以我们需要根据电话的MAC地址和DHCP使用的两个UDP端口`67/udp`（bootps）和`68/udp`（bootpc）来指定流量。我们将捕获完整的数据包并将它们写入文件
    – 请注意，实际捕获需要*sudo*权限。
- en: 'First, list the interfaces so that we get the source correct:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，列出接口，以便我们正确获取源：
- en: '[PRE4]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, let's capture some packets!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们捕获一些数据包！
- en: '[PRE5]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our arguments included the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的论点包括以下内容：
- en: '![](img/B16336_11_Table_02.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16336_11_Table_02.jpg)'
- en: 'In the output, we can see the first few packets in the exchange – what we want
    to do is write this to a file, so let''s add `-w` for that:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以看到交换中的前几个数据包 – 我们想要将其写入文件，因此让我们添加`-w`：
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, let's suppose that we don't have access to the DHCP server. Alternatively,
    if DHCP isn't working correctly, we might want a *network perspective* of the
    exchange, to maybe see why either the server or the client isn't receiving or
    sending DHCP packets. In this situation, remember that the client is a phone,
    so while it's very likely Linux-based, the vendor might not have made it easy
    to SSH to that platform to run tcpdump.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们无法访问DHCP服务器。或者，如果DHCP工作不正常，我们可能希望从*网络视角*来交换，也许看看为什么服务器或客户端没有接收或发送DHCP数据包。在这种情况下，请记住客户端是电话，因此虽然它很可能是基于Linux的，但供应商可能没有让它轻松地通过SSH到该平台运行tcpdump。
- en: 'In this situation, the typical solution is to set up a SPAN port, also called
    a `monitor` or `mirror` port (depending on the switch vendor). In this situation,
    our packet capturing host is in port `5`, so that will be the monitor session
    destination. The phone is in port `1`, so that will be our monitor session source.
    On a Cisco switch, this setup syntax looks like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，典型的解决方案是设置一个SPAN端口，也称为`监视`或`镜像`端口（取决于交换机供应商）。在这种情况下，我们的数据包捕获主机位于端口`5`，因此将成为监视会话目的地。电话位于端口`1`，因此将成为我们的监视会话源。在Cisco交换机上，此设置语法如下：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To view the various monitor sessions in play, the `show` command would look
    like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看正在进行的各种监视会话，`show`命令如下：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s set this up in Wireshark. This has a ton of advantages for us – not
    only will it syntax check our filter (note that it turns green when it''s valid),
    but we can also graphically pick our network adapter, and the packets are shown
    graphically during the capture. Again, after we select our capturing interface,
    the filter will look as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Wireshark中设置这个。这对我们有很多优势 - 它不仅会对我们的过滤器进行语法检查（注意当它有效时会变成绿色），而且我们还可以以图形方式选择我们的网络适配器，并且在捕获过程中以图形方式显示数据包。同样，在选择捕获接口后，过滤器将如下所示：
- en: '![Figure 11.7 – Defining a capture filter in Wireshark'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.7 - 在Wireshark中定义捕获过滤器'
- en: '](img/B16336_11_007.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_007.jpg)'
- en: Figure 11.7 – Defining a capture filter in Wireshark
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 - 在Wireshark中定义捕获过滤器
- en: 'Note that the capture filter syntax is the same for Wireshark as it is for
    tcpdump; it uses what''s called BPF syntax. In this example, we added an `ether
    host` to the filter, to only capture DHCP packets to or from that MAC address.
    Press the **Start Capture** button (the blue *shark fin* icon at the top left
    of the window); we''ll see our DHCP sequence as the phone boots up:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，捕获过滤器的语法与Wireshark和tcpdump相同；它使用所谓的BPF语法。在这个例子中，我们在过滤器中添加了`ether host`，以仅捕获发送到或从该MAC地址的DHCP数据包。按下**开始捕获**按钮（窗口左上角的蓝色*鲨鱼鳍*图标）；我们将看到电话启动时的DHCP序列：
- en: '![Figure 11.8 – A full DHCP "DORA" sequence captured'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.8 - 捕获的完整DHCP“DORA”序列'
- en: '](img/B16336_11_008.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_008.jpg)'
- en: Figure 11.8 – A full DHCP "DORA" sequence captured
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 - 捕获的完整DHCP“DORA”序列
- en: If you don't have a lab set up, you can collect this `pcap` file from our GitHub
    page ([https://github.com/PacktPublishing/Linux-for-Networking-Professionals/tree/main/C11](https://github.com/PacktPublishing/Linux-for-Networking-Professionals/tree/main/C11));
    the filename is `DHCP DORA Example.pcapng`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有设置实验室，您可以从我们的GitHub页面收集这个`pcap`文件（[https://github.com/PacktPublishing/Linux-for-Networking-Professionals/tree/main/C11](https://github.com/PacktPublishing/Linux-for-Networking-Professionals/tree/main/C11)）；文件名为`DHCP
    DORA Example.pcapng`。
- en: 'We can simply expand the various data fields in the packet to show the various
    diagnostic values. Expand the DHCP section of the first frame:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地展开数据包中的各种数据字段，以显示各种诊断值。展开第一个帧的DHCP部分：
- en: '![Figure 11.9 – Exploring the DHCP "Discover" packet'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.9 - 探索DHCP“Discover”数据包'
- en: '](img/B16336_11_009.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_009.jpg)'
- en: Figure 11.9 – Exploring the DHCP "Discover" packet
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 - 探索DHCP“Discover”数据包
- en: 'Scroll down and expand a few of the DHCP `Option` fields – in particular, `Parameter
    Request List`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '向下滚动并展开一些DHCP `Option`字段 - 特别是`Parameter Request List`： '
- en: '![Figure 11.10 – DHCP options in the "Discover" packet'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.10 - “Discover”数据包中的DHCP选项'
- en: '](img/B16336_11_010.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_010.jpg)'
- en: Figure 11.10 – DHCP options in the "Discover" packet
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 - “Discover”数据包中的DHCP选项
- en: Note how many items are in the phone's *request list*. These offer a few great
    options for an attacker. In particular, if a malicious DHCP server can respond
    and give the phone a different TFTP server and Bootfile name, that file on the
    TFTP server has the entire configuration of the phone, including its extension
    and caller ID – pretty much everything.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意电话的*请求列表*中有多少项目。这为攻击者提供了一些很好的选项。特别是，如果恶意的DHCP服务器可以响应并给电话一个不同的TFTP服务器和Bootfile名称，那么TFTP服务器上的文件将包含电话的整个配置，包括其分机和呼叫者ID
    - 几乎所有内容。
- en: In addition, provisioning servers like this are almost always either TFTP or
    HTTP servers. What this means for an attacker is that if they can get an MiTM
    position between the client and the server (using Ettercap, Bettercap, or a similar
    tool), they can not only collect the configuration data for later use in the attack
    – they can also modify this data in real time, as the phone is downloading it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，像这样的配置服务器几乎总是TFTP或HTTP服务器。对于攻击者来说，这意味着如果他们可以在客户端和服务器之间获得MiTM位置（使用Ettercap、Bettercap或类似工具），他们不仅可以收集配置数据以供以后在攻击中使用
    - 他们还可以在电话下载数据时实时修改这些数据。
- en: This underscores just how important it is to secure both your DHCP services
    and VoIP provisioning services! Let's look at a more generic protocol we can use
    for both good and evil – LLDP and CDP.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这强调了保护DHCP服务和VoIP配置服务的重要性！让我们来看一个更通用的协议，我们可以用于善良和邪恶 - LLDP和CDP。
- en: More capture filters – LLDP and CDP
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多的捕获过滤器 - LLDP和CDP
- en: What else can we see as a station boots up? CDP and LLDP are the main Layer
    2 discovery protocols that you will see in most environments. These protocols
    will give us all kinds of useful information in troubleshooting or auto-documenting
    our network and stations. They also give an attacker that same information, which
    means that where you can, you'll want to limit these protocols, typically on any
    communication links that connect to other companies.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个站点启动时，我们还能看到什么？CDP和LLDP是大多数环境中会看到的主要二层发现协议。这些协议将为我们提供各种有用的信息，用于故障排除或自动记录我们的网络和站点。它们还会为攻击者提供相同的信息，这意味着在您可以的地方，您将希望限制这些协议，通常是在连接到其他公司的任何通信链路上。
- en: LLDP is required for almost all VoIP implementations, though – it's how the
    phones know which VLAN to be on in most cases (unless the VLAN is set in DHCP),
    and it's also how most phones negotiate their **Power over Ethernet** (**PoE**)
    power levels. Without LLDP, all phones would receive a full 15 watts of power,
    which would mean that any given switch would need to supply 6-7 times more power
    than it needs (most phones are in the 2-4-6 watt range).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: LLDP几乎对所有VoIP实现都是必需的 - 这是电话知道大多数情况下应该在哪个VLAN上的方法（除非VLAN在DHCP中设置），这也是大多数电话协商它们的**PoE**（**Power
    over Ethernet**）功率级别的方法。没有LLDP，所有电话将接收完整的15瓦电力，这意味着任何给定的交换机都需要提供比它所需的电力多6-7倍（大多数电话的功率范围在2-4-6瓦之间）。
- en: 'Let''s look at CDP (which multicasts to a Layer 2 address of `01:00:0c:cc:cc:cc`)
    and LLDP (which multicasts to `01:80:C2:00:00:0E` and has an Ethernet protocol
    of `0x88cc`). In this case, our capture filter will be as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看CDP（它以`01:00:0c:cc:cc:cc`的二层地址进行多播）和LLDP（它以`01:80:C2:00:00:0E`进行多播，并且以`0x88cc`的以太网协议）。在这种情况下，我们的捕获过滤器将如下所示：
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alternatively, it will be as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它将如下所示：
- en: '[PRE10]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The resulting capture shows that both LLDP and CDP are in play, but what can
    we see in the LLDP packet that the phone sends?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 结果捕获显示LLDP和CDP都在起作用，但我们可以从电话发送的LLDP数据包中看到什么？
- en: The information that we're seeking is all in the application section of the
    Wireshark display (the example file for this capture is both LLDP and CDP – `Phone
    Example.pcapng`). Open the file and highlight the **Link Layer Discovery Protocol**
    section of an LLDP packet. Note that the following data contains a lot of hexadecimal
    characters, but there's enough that translates into ASCII that you can see some
    useful data already!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找的信息都在Wireshark显示的应用程序部分（此捕获的示例文件同时包括LLDP和CDP - `Phone Example.pcapng`）。打开文件并突出显示LLDP数据包的**链路层发现协议**部分。请注意，以下数据包含许多十六进制字符，但有足够的ASCII转换内容，您已经可以看到一些有用的数据！
- en: '![Figure 11.11 – A captured LLDP frame'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.11 - 捕获的LLDP帧'
- en: '](img/B16336_11_011.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_011.jpg)'
- en: Figure 11.11 – A captured LLDP frame
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 - 捕获的LLDP帧
- en: 'Now, expand that LLDP tab so that we can look at some details in that section:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，展开LLDP选项卡，以便我们可以查看该部分的一些详细信息：
- en: '![Figure 11.12 – Looking at the LLDP packet in more detail'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.12 - 更详细查看LLDP数据包'
- en: '](img/B16336_11_012.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_012.jpg)'
- en: Figure 11.12 – Looking at the LLDP packet in more detail
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12 - 更详细查看LLDP数据包
- en: The phone has been set to auto speed and duplex and is negotiated to 100/Full.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 电话已设置为自动速度和双工，并协商到100/全双工。
- en: The phone is a Yealink, Model T21P-E2, with a serial number of `805ec086ac2c`.
    It's running firmware version 52.84.0.15.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 电话是Yealink，型号T21P-E2，序列号为`805ec086ac2c`。它运行的固件版本是52.84.0.15。
- en: It is in the untagged (native) VLAN (the VLAN ID is `0`) and does not have `0`,
    so is the L2 priority).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 它在未标记的（本地）VLAN中（VLAN ID为`0`），并且没有`0`，所以是L2优先级）。
- en: Feel free to collect the same information from the CDP packets in the capture
    file – remember that we filtered for both CDP and LLDP.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请随时从捕获文件中的CDP数据包中收集相同的信息 - 请记住我们过滤了CDP和LLDP。
- en: This may seem like a simple example, but all too often, networks are put together
    "organically" over years, with little or no documentation. At some point, the
    network will be complex enough, or the one person who knew how it all connected
    will leave the company – at that point, it will become important to document your
    network. If CDP or LLDP is enabled, this gives you an important tool to get a
    good start on this, with all IP addresses, model numbers, firmware, and connecting
    ports.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像一个简单的例子，但是网络往往是多年来“有机”地组合在一起的，几乎没有文档记录。在某个时候，网络将变得足够复杂，或者知道如何连接所有内容的人将离开公司
    - 在那时，记录网络将变得重要。如果启用了CDP或LLDP，这将为您提供一个重要的工具，以获取所有IP地址，型号，固件和连接端口的良好起点。
- en: From an attacker's perspective, this same information can be used to identify
    hosts that might be good candidates for exploitation. You can use this same approach
    to collect this data, looking for a piece of infrastructure with a firmware version
    that has known vulnerabilities. That piece of gear can then become the next platform
    that the attacker will pivot to, using that host to collect further information
    to use in the next attack. This approach can easily be used to continue their
    attack into the next connected organization, maybe targeting the router or switch
    that our ISP has on our internet or MPLS uplink.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从攻击者的角度来看，这些信息可以用来识别可能适合利用的主机。您可以使用相同的方法来收集这些数据，寻找具有已知漏洞的固件版本的基础设施。然后，这个设备可以成为攻击者将要转移到的下一个平台，使用该主机收集更多信息，以在下一次攻击中使用。这种方法可以轻松地用于将他们的攻击延伸到下一个连接的组织，也许是针对我们ISP在我们的互联网或MPLS上行链路上的路由器或交换机。
- en: Now, let's look at extracting specific artifacts from a packet capture, such
    as files.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下从数据包捕获中提取特定工件，比如文件。
- en: Collecting files from a packet capture
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数据包捕获中收集文件
- en: If you are working with a set of captured packets, or are in the middle of a
    packet capture, what options do you have if you see a file transfer go by? If
    it's using any TCP protocol, or a well-known UDP protocol (such as TFTP or RTP),
    it's as easy as pie!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在处理一组捕获的数据包，或者正在进行数据包捕获，如果看到文件传输，您有哪些选项？如果它使用任何TCP协议或众所周知的UDP协议（如TFTP或RTP），那就太容易了！
- en: 'Here, we can see a packet capture (`file-transfer-example.pcapng` in our GitHub
    repository). Wireshark correctly identifies this as a TFTP file transfer:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个数据包捕获（在我们的GitHub存储库中的`file-transfer-example.pcapng`）。Wireshark正确识别这是一个TFTP文件传输：
- en: '![Figure 11.13 – A packet capture containing a file transfer'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.13 - 包含文件传输的数据包捕获'
- en: '](img/B16336_11_013.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_013.jpg)'
- en: Figure 11.13 – A packet capture containing a file transfer
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13 - 包含文件传输的数据包捕获
- en: Knowing that there are VoIP phones on this network, we suspect that these might
    be provisioning files – configuration files for the phones that get transferred
    during the bootup/initialization process. Let's take a closer look.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 知道这个网络上有VoIP电话，我们怀疑这些可能是配置文件 - 在启动/初始化过程中传输到电话的配置文件。让我们仔细看一下。
- en: 'From the first line, we can see a read request for a file called `SIPDefault.cnf`.
    This is indeed a high-value target as it provides the set of defaults for Cisco
    SIP Phones, if they are centrally provisioned. Highlight the first packet marked
    as **Data Packet** (packet 3). Right-click on it and choose **Follow | UDP Stream**.
    As you recall, there is no session data in UDP protocols, but Wireshark has decodes
    built in for many protocols, and TFTP is just one of them:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一行开始，我们可以看到对名为`SIPDefault.cnf`的文件的读取请求。这确实是一个高价值目标，因为它为Cisco SIP电话提供了默认设置，如果它们是集中配置的。突出显示标记为**数据包**的第一个数据包（数据包3）。右键单击它，然后选择**跟随|
    UDP流**。正如您所记得的，UDP协议中没有会话数据，但是Wireshark内置了许多协议的解码，TFTP只是其中之一：
- en: '![Figure 11.14 – Collecting a transferred file from a PCAP – step 1'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.14 - 从PCAP中收集传输文件 - 步骤1'
- en: '](img/B16336_11_014.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_014.jpg)'
- en: Figure 11.14 – Collecting a transferred file from a PCAP – step 1
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14 - 从PCAP中收集传输文件 - 步骤1
- en: 'Bingo! We have the file we''re looking for! Choose **Save as...** to "harvest"
    this file. Now, let''s see what else we might have:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们找到了我们要找的文件！选择**另存为...**以“收集”此文件。现在，让我们看看还有什么：
- en: '![Figure 11.15 – Collecting a transferred file from a PCAP – step 2'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.15 - 从PCAP中收集转移文件 - 步骤2'
- en: '](img/B16336_11_015.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_015.jpg)'
- en: Figure 11.15 – Collecting a transferred file from a PCAP – step 2
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15 - 从PCAP中收集转移文件 - 步骤2
- en: Close this window and clear out the display filter line in Wireshark so that
    we can see the whole capture again (clear out the text that says `udp stream eq
    1`).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭此窗口并清除Wireshark中的显示过滤器行，以便我们可以再次看到整个捕获（清除文本，显示`udp stream eq 1`）。
- en: Down on packet 15, we see a request for a second file called `SIP0023049B48F1.cnf`.
    Repeat the process we followed previously for this file – the transfer starts
    on packet 17, so follow the UDP stream that starts there. With this file in hand,
    we now have the SIP configuration for the phone with a MAC address of `0023.049B.48F1`.
    Looking at this file, we can see that this is the configuration file for extension
    `1412`, with a caller ID of `Helpdesk Extension 2`. This file contains the entire
    configuration of that phone, including the SIP password. With this information,
    an attacker can easily impersonate the helpdesk extension and collect confidential
    information from people calling the helpdesk using social engineering – a valuable
    piece of information indeed!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据包15下面，我们看到对第二个名为`SIP0023049B48F1.cnf`的文件的请求。重复我们之前对此文件的处理过程 - 传输从数据包17开始，因此跟随从那里开始的UDP流。有了这个文件，我们现在拥有了MAC地址为`0023.049B.48F1`的电话的SIP配置。查看此文件，我们可以看到这是分机`1412`的配置文件，呼叫者ID为`Helpdesk
    Extension 2`。该文件包含该电话的整个配置，包括SIP密码。有了这些信息，攻击者可以轻松冒充帮助台分机，并通过社会工程学从打电话给帮助台的人那里收集机密信息
    - 这确实是一条宝贵的信息！
- en: Now, let's dig deeper into our telephony system and capture the audio from an
    actual VoIP phone call.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入研究我们的电话系统，并捕获实际VoIP电话呼叫的音频。
- en: Troubleshooting an application – capturing a VoIP telephone call
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除应用程序 - 捕获VoIP电话呼叫
- en: To do this, I'll keep our same capture setup and make a call from the client
    phone on port `G1/0/1` to the helpdesk call on `G1/0/2`. Capturing all the packets
    in and out of `G1/0/1` should get us what we need – for this interval, the traffic
    in and out of `G1/0/2` should be identical to `G1/0/1` (just in the reverse direction).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我将保持我们相同的捕获设置，并从客户端电话的端口`G1/0/1`拨打到`G1/0/2`的帮助台呼叫。捕获`G1/0/1`进出的所有数据包应该得到我们需要的内容
    - 在此间隔内，进出`G1/0/2`的流量应与`G1/0/1`完全相同（只是方向相反）。
- en: To capture our text, we'll simply do a full capture; no filters are needed in
    this case. We started our capture, ensuring that we caught the start and end of
    the call (so we started the capture before the dial, and ended it after the hang-up).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获我们的文本，我们将简单地进行全面捕获；在这种情况下不需要过滤器。我们开始了捕获，确保捕获了通话的开始和结束（因此我们在拨号之前开始捕获，并在挂断后结束）。
- en: With the capture completed, we can look at our PCAP in Wireshark – the example
    file for this lab is `HelpDesk Telephone Call.pcapng`, which is located in our
    GitHub repository at [https://github.com/PacktPublishing/Linux-for-Networking-Professionals/tree/main/C11](https://github.com/PacktPublishing/Linux-for-Networking-Professionals/tree/main/C11).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获完成后，我们可以在Wireshark中查看我们的PCAP - 本实验室的示例文件是`HelpDesk Telephone Call.pcapng`，位于我们的GitHub存储库中[https://github.com/PacktPublishing/Linux-for-Networking-Professionals/tree/main/C11](https://github.com/PacktPublishing/Linux-for-Networking-Professionals/tree/main/C11)。
- en: 'Let''s look at packet 6, labeled `Ringing`. Exploring the application data
    in this packet illustrates how easy it is to understand this data in many cases
    – SIP (when used in call setup) in particular follows what you might expect from
    using email:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下标记为`Ringing`的数据包6。探索此数据包中的应用程序数据说明了在许多情况下理解这些数据是多么容易 - 特别是SIP（在呼叫设置中使用时）遵循了您可能期望从电子邮件中使用的内容：
- en: '![Figure 11.16 – Exploring a SIP "ring / INVITE" packet'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.16 - 探索SIP“响铃/邀请”数据包'
- en: '](img/B16336_11_016.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_016.jpg)'
- en: Figure 11.16 – Exploring a SIP "ring / INVITE" packet
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16 - 探索SIP“响铃/邀请”数据包
- en: Take a look at a few other SIP packets and explore some of the fields in the
    application data of each.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下其他几个SIP数据包，并探索每个应用程序数据中的一些字段。
- en: 'Next, we''ll look at the call itself. Notice that on packet 15, the protocol
    changes from SIP (on `5060/udp`) to `IP section` and then expand the `46` has
    been set:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看通话本身。请注意，在数据包15上，协议从SIP（在`5060/udp`上）更改为`IP`部分，然后展开`46`已设置：
- en: '![Figure 11.17 – DSCP bits in an RTP (voice) packet'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.17 - RTP（语音）数据包中的DSCP位'
- en: '](img/B16336_11_017.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_017.jpg)'
- en: Figure 11.17 – DSCP bits in an RTP (voice) packet
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17 - RTP（语音）数据包中的DSCP位
- en: DSCP is a 6-bit field in the packet that tells the intervening network gear
    how to prioritize this packet. In this case, the value is set to `46` or **Expedited
    Forwarding**, or **EF** for short. This tells the switch that if there are several
    packets queued up, this one (and others with the same marking) should go first.
    In fact, the EF marking is unique in that it tells the network gear not to queue
    this packet at all (if possible).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: DSCP是数据包中的一个6位字段，告诉中间网络设备如何对该数据包进行优先处理。在这种情况下，该值设置为`46`或**Expedited Forwarding**，简称**EF**。这告诉交换机，如果有几个数据包排队等待，这个（以及其他具有相同标记的数据包）应该优先处理。事实上，EF标记是独特的，因为它告诉网络设备尽量不要排队处理这个数据包。
- en: The EF marking is unique in that it is not queued and is forwarded first to
    preserve the integrity of the voice stream and prevent artifacts such as "echo."
    It's also unique in that if the buffers fill to the point that this packet must
    be queued, often, the intervening network gear will drop a few of these packets
    rather than delay them. This is because the human ear is much more forgiving of
    a VoIP call where a few packets get dropped compared to these same packets being
    delayed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: EF标记是独特的，因为它不排队，而是首先转发以保持语音流的完整性，并防止出现“回声”等现象。它还是独特的，因为如果缓冲区填满到必须排队此数据包的程度，通常，中间的网络设备会丢弃其中的一些数据包，而不是延迟它们。这是因为人耳对于一些数据包被丢弃的VoIP呼叫更宽容，而不是这些相同的数据包被延迟。
- en: If you check one of the SIP packets that's used in setting up the call, these
    all have a DSCP value of 26 (Assured Forwarding) – in other words, not expedited,
    but it's marked as a UDP packet that's of some importance. These markings request
    that if an interface or path is congested, then this packet should be buffered
    and not dropped.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查设置呼叫时使用的SIP数据包之一，这些数据包的DSCP值都为26（有保证的转发）-换句话说，并非加速，但它被标记为一种重要的UDP数据包。这些标记请求，如果接口或路径拥塞，那么这个数据包应该被缓冲而不是丢弃。
- en: 'Next, let''s dive back into the application data in this RTP packet:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们再次深入研究此RTP数据包中的应用数据：
- en: '![Figure 11.18 – RTP application data'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.18–RTP应用数据'
- en: '](img/B16336_11_018.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_018.jpg)'
- en: Figure 11.18 – RTP application data
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18–RTP应用数据
- en: Note that this data is much simpler. For the most part, there's a bit of lead-in
    data that identifies that this packet is part of an ongoing phone call. This is
    packet (and frame) 4 of the call. The CODEC is identified so that the device at
    the far end knows how to decode the data. The majority of the packet is in the
    `Payload` field, which is voice data.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些数据要简单得多。在大多数情况下，有一些引导数据，用于标识此数据包是正在进行的电话呼叫的一部分。这是呼叫的数据包（和帧）4。编解码器被识别，以便远端设备知道如何解码数据。数据包的大部分内容在`Payload`字段中，这是语音数据。
- en: You can "follow" this stream by highlighting one RTP packet in the call, right-clicking
    on it, and selecting **Follow UDP Stream**. This extracts all of the RTP/voice
    data in the call so that it can be analyzed. In other protocols, you might select
    **Follow TCP Stream** or **Follow UDP Stream**, and then be able to recover an
    entire file (from an FTP or TFTP session, for example).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过突出显示呼叫中的一个RTP数据包，右键单击它，然后选择**跟踪UDP数据流**来“跟踪”此流。这样可以提取呼叫中的所有RTP/语音数据，以便进行分析。在其他协议中，您可能会选择**跟踪TCP数据流**或**跟踪UDP数据流**，然后能够恢复整个文件（例如从FTP或TFTP会话中）。
- en: 'To recover a voice conversation, Wireshark has added a special handler. With
    this PCAP file open, choose `R` (for right) is making the call, while `L` (for
    left) is receiving the call. If you select the **Play** button, you can play the
    entire conversation back:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复语音对话，Wireshark已经添加了一个特殊的处理程序。打开此PCAP文件后，选择`R`（右）正在拨打电话，而`L`（左）正在接听电话。如果选择**播放**按钮，可以回放整个对话：
- en: '![Figure 11.19 – Playing back a captured VoIP conversation'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.19–回放捕获的VoIP对话'
- en: '](img/B16336_11_019.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_019.jpg)'
- en: Figure 11.19 – Playing back a captured VoIP conversation
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19–回放捕获的VoIP对话
- en: 'Alternatively, select any of the RTP packets and choose **Telephony | RTP |
    Stream Analysis**. Now, choose **Save** and choose any of the synchronization
    options (-0, for instance), **Unsynchronized Forward**, and **Reverse Audio**.
    This saves the file as an "AU" (Sun Audio) file, which can be played back by most
    media players, or converted into any other audio format that is desired:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，选择任何RTP数据包，并选择**电话| RTP|流分析**。现在，选择**保存**并选择任何同步选项（例如-0），**非同步前向**和**反向音频**。这将文件保存为“AU”（Sun音频）文件，可以由大多数媒体播放器播放，或者转换为所需的任何其他音频格式：
- en: '![Figure 11.20 – Saving a VoIP conversation as a playable media file'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.20–将VoIP对话保存为可播放的媒体文件'
- en: '](img/B16336_11_020.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_020.jpg)'
- en: Figure 11.20 – Saving a VoIP conversation as a playable media file
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20–将VoIP对话保存为可播放的媒体文件
- en: This has some obvious implications for anyone running VoIP solutions. By default,
    most VoIP configurations do not encrypt the voice traffic. This is to remove encryption/decryption
    as a source of delay or jitter, two major causes of degraded voice quality. This
    means that in these situations, the voice data cannot be treated as "secure."
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于运行VoIP解决方案的任何人都有一些明显的影响。默认情况下，大多数VoIP配置不会加密语音流量。这是为了消除加密/解密作为延迟或抖动的来源，这是语音质量下降的两个主要原因。这意味着在这些情况下，语音数据不能被视为“安全”。
- en: Also, note that in our helpdesk call, the helpdesk person used the caller ID
    display to verify the caller's identity. This might work when all is well, but
    we've already described one way this can be compromised. An even simpler method
    is for an attacker to use packet captures to identify how the VoIP infrastructure
    works, then stand up a "soft phone" on their computer. In that situation, the
    attacker can define whatever they want for the caller ID; it's a simple text field.
    When the call is made, normally, the caller ID is supplied by the handsets rather
    than the PBX, so in this case, the helpdesk is tricked into performing a password
    reset.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，注意在我们的求助台呼叫中，求助台人员使用来电显示来验证来电者的身份。这在一切正常时可能有效，但我们已经描述了一种可能被破坏的方法。甚至更简单的方法是攻击者使用数据包捕获来识别VoIP基础设施的工作原理，然后在他们的计算机上建立一个“软电话”。在这种情况下，攻击者可以为来电者ID定义任何他们想要的内容；这是一个简单的文本字段。通常，来电者ID是由手柄提供而不是PBX，所以在这种情况下，求助台被欺骗执行密码重置。
- en: Normally, the phone boot-up sequence uses a provisioning service based on TFTP
    or HTTP. This downloads a configuration file based on the phone handset's "name."
    In many cases, the handset's "name" is the word `SIP`, followed by the MAC address
    of the phone – you can see these names in the phone's LLDP advertisements as well.
    This convention will vary with different handset vendors, but it is almost always
    a simple text string, combined with the handset MAC address. All an attacker needs
    to do to compromise the configuration of such a phone is MiTM between the configuration/provisioning
    server and the phone handset. This, plus the clear text nature of the configuration
    file, allows the attacker to modify key fields as the file is being downloaded.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，电话启动序列使用基于TFTP或HTTP的配置服务。这将根据电话机的“名称”下载一个配置文件。在许多情况下，电话机的“名称”是单词`SIP`，后跟电话机的MAC地址
    - 您还可以在电话机的LLDP广告中看到这些名称。这种约定会因不同的电话机供应商而异，但几乎总是一个简单的文本字符串，结合电话机的MAC地址。攻击者只需在配置/提供服务器和电话机之间进行中间人攻击，就可以破坏电话机的配置。加上配置文件的明文性质，使得攻击者可以在文件下载时修改关键字段。
- en: Wireshark display filters – separating specific data in a capture
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Wireshark显示过滤器 - 在捕获中分离特定数据
- en: 'Sticking with our helpdesk call file, we can easily filter this file to only
    show specific traffic. For instance, when troubleshooting, it''s common to need
    to see just the SIP traffic – all too often the SIP gateway belongs to a cloud
    provider who often gets the setup wrong, resulting in SIP authentication issues
    or even getting the ACLs incorrect, so the login or even the initial connection
    fails. You can see all of these issues in the packets, so let''s filter for the
    SIP protocol:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用我们的帮助台呼叫文件，我们可以轻松地将此文件过滤为仅显示特定流量。例如，在故障排除时，通常需要仅查看SIP流量 - SIP网关经常属于云提供商，他们经常设置错误，导致SIP认证问题甚至ACL设置错误，因此登录甚至初始连接失败。您可以在数据包中看到所有这些问题，因此让我们过滤SIP协议：
- en: '![Figure 11.21 – Filtering for SIP traffic only (call setup/teardown)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.21 - 仅过滤SIP流量（呼叫设置/拆除）'
- en: '](img/B16336_11_021.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_021.jpg)'
- en: Figure 11.21 – Filtering for SIP traffic only (call setup/teardown)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21 - 仅过滤SIP流量（呼叫设置/拆除）
- en: This shows the entire call setup, ringing, the pickup, and the final hangup
    (the `BYE` packet at `7848`, two lines from the bottom). We can also filter this
    by specifying `udp.port==5060`. Comparing this to the packet capture filters,
    note that the display filters use a different syntax, which ends up being much
    more flexible. Often, you'll capture with a filter that gets what you need, then
    filter again once you are in Wireshark, allowing you to drill down to get exactly
    what you want using multiple filters strung together.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了整个呼叫设置，响铃，接听和最终挂断（`BYE`数据包在底部的第二行处于`7848`）。我们还可以通过指定`udp.port==5060`来进行过滤。与数据包捕获过滤器相比，显示过滤器使用不同的语法，这最终更加灵活。通常，您会使用一个过滤器进行捕获以获取所需的内容，然后在Wireshark中再次进行过滤，从而允许您使用多个过滤器串联在一起，深入挖掘以获取确切所需的内容。
- en: 'Note the `5882` missing packets between `14` and `5896`; that''s the conversation
    itself. Let''s filter just for that:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`14`和`5896`之间缺少的`5882`个数据包；那就是对话本身。让我们只过滤这个：
- en: '![Figure 11.22 – Filtering for RTP traffic (the voice conversation)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.22 - 过滤RTP流量（语音对话）'
- en: '](img/B16336_11_022.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_022.jpg)'
- en: Figure 11.22 – Filtering for RTP traffic (the voice conversation)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.22 - 过滤RTP流量（语音对话）
- en: 'You typically only filter for RTP by protocol name, since the RTP ports will
    vary from call to call as they are negotiated during the SIP setup. By drilling
    down into the RTP packet, we can see that the ports are `12200` for `192.168.123.55`
    and `12830` for `192.168.123.53` (you can get the names and extensions from the
    SIP packets):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通常只通过协议名称过滤RTP，因为RTP端口会因呼叫而异，在SIP设置期间进行协商。通过深入研究RTP数据包，我们可以看到端口为`12200`的`192.168.123.55`和端口为`12830`的`192.168.123.53`（您可以从SIP数据包中获取名称和扩展名）：
- en: '![Figure 11.23 – RTP ports in use for this conversation'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.23 - 用于此对话的RTP端口'
- en: '](img/B16336_11_023.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_023.jpg)'
- en: Figure 11.23 – RTP ports in use for this conversation
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.23 - 用于此对话的RTP端口
- en: 'Where are these two ports negotiated? These are set up in SDP, which is part
    of the SIP exchange. The first SDP packet is in packet 4, where the caller at
    x1234 identifies their RTP port. Expand this packet, then scroll to the **Session
    Initiation Protocol (INVITE) | Message Body | Session Description Protocol | Media
    Description** section:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个端口是在哪里协商的？这些是在SIP交换的一部分SDP中设置的。第一个SDP数据包在数据包4中，x1234处的呼叫者标识其RTP端口。展开此数据包，然后滚动到**会话初始协议（INVITE）|消息正文|会话描述协议|媒体描述**部分：
- en: '![Figure 11.24 – Caller setting their RTP port'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.24 - 呼叫者设置其RTP端口'
- en: '](img/B16336_11_024.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_024.jpg)'
- en: Figure 11.24 – Caller setting their RTP port
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.24 - 呼叫者设置其RTP端口
- en: 'The SDP reply comes in packet 13, when the handset at the far end gets picked
    up. This is where the recipient (extension `1411` at `192.168.123.53`) comes back
    with its port; that is, `12830`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: SDP回复在数据包13中，当远端的电话被接听时。这是接收方（扩展`1411`在`192.168.123.53`）回复其端口的地方；即`12830`：
- en: '![Figure 11.25 – Call recipient setting their RTP port'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.25 - 通话接收方设置其RTP端口'
- en: '](img/B16336_11_025.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_025.jpg)'
- en: Figure 11.25 – Call recipient setting their RTP port
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.25 - 通话接收方设置其RTP端口
- en: 'You can filter for just the SDP packets by looking for `SIP and SDP` as a display
    filter (packets 4 and 15):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查找`SIP和SDP`作为显示过滤器（数据包4和15）来仅过滤SDP数据包：
- en: '![Figure 11.26 – Filtering for SIP/SDP packets only'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.26 - 仅过滤SIP/SDP数据包'
- en: '](img/B16336_11_026.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16336_11_026.jpg)'
- en: Figure 11.26 – Filtering for SIP/SDP packets only
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.26 - 仅过滤SIP/SDP数据包
- en: Note that if you look at the first packet, it's a failed invitation. You can
    dig into why that might be the case if you're interested!
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您查看第一个数据包，它是一个失败的邀请。如果您感兴趣，可以深入了解失败的原因！
- en: Hopefully, you can take the approaches you learned here for analyzing the various
    VoIP protocols in this section and apply them to concrete problem-solving issues
    in your production environment.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您可以将您在本节中学到的分析各种VoIP协议的方法应用到生产环境中的具体问题解决中。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At this point, we've covered how to use packet capturing tools, both from a
    legitimate troubleshooting point of view and from an attacker's point of view.
    In particular, we've covered how to position and configure things so that packets
    can be captured, what tools to use, and how to filter the "firehose" of information
    down to just what you need to solve the issue. Filtering in particular is very
    useful, which is why there is a two-stage filtering approach in place in Wireshark
    (at the time of capture and as the packets are being displayed).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了如何使用数据包捕获工具，无论是从合法的故障排除角度还是从攻击者的角度。特别是，我们已经介绍了如何定位和配置以便捕获数据包，使用什么工具，以及如何将“消防栓”式的信息过滤到您需要解决问题的内容。过滤特别有用，这就是为什么Wireshark中有一个两阶段的过滤方法（在捕获时和在显示数据包时）。
- en: We've covered the operation of a VoIP call in some depth, from booting a phone
    to making a call, to capturing and listening to the audio playback of a call.
    At this point, you should have some appreciation for the depth of functionality
    that is available in these tools for network, system, and application administrators.
    You should be well-positioned to take this appreciation to true mastery – just
    keep in mind that the best way to learn a tool such as Wireshark or tcpdump is
    to use it to solve a problem, or at least use it to learn something else (such
    as how DHCP works, or how a phone call works over a network, for instance).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经深入介绍了VoIP呼叫的操作，从启动电话到拨打电话，再到捕获和收听呼叫的音频回放。到目前为止，您应该对这些工具为网络、系统和应用程序管理员提供的功能深有体会。您应该已经做好了将这种体会转化为真正掌握的准备——只需记住，学习Wireshark或tcpdump等工具的最佳方法是使用它来解决问题，或者至少使用它来学习其他东西（比如DHCP的工作原理，或者电话呼叫在网络上的工作原理）。
- en: In the next chapter, we'll be discussing network monitoring, which will include
    logging, network monitoring systems that use SNMP, and the use of NetFlow and
    other flow-based protocols to monitor and troubleshoot networks.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论网络监控，其中将包括使用SNMP的日志记录、使用NetFlow和其他基于流的协议来监控和故障排除网络。
- en: Questions
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束时，这里有一些问题供您测试对本章材料的了解。您将在*附录*的*评估*部分找到答案：
- en: Why would you use an endpoint host, an intermediate device over a SPAN port,
    for packet capture?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么您会使用端点主机，而不是SPAN端口上的中间设备进行数据包捕获？
- en: When would you use tcpdump as opposed to Wireshark?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在什么情况下您会使用tcpdump而不是Wireshark？
- en: What port does the RTP, which is used for VoIP conversations, use?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RTP使用的端口是多少，用于VoIP通话？
- en: Further reading
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about what was covered in this chapter, please take a look at
    the following references:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解本章涵盖的内容，请参考以下参考资料：
- en: 'Wireshark User''s Guide: [https://www.wireshark.org/docs/wsug_html_chunked/](https://www.wireshark.org/docs/wsug_html_chunked/)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wireshark用户指南：[https://www.wireshark.org/docs/wsug_html_chunked/](https://www.wireshark.org/docs/wsug_html_chunked/)
- en: 'tcpdump man page: [https://www.tcpdump.org/manpages/tcpdump.1.html](https://www.tcpdump.org/manpages/tcpdump.1.html)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tcpdump手册页面：[https://www.tcpdump.org/manpages/tcpdump.1.html](https://www.tcpdump.org/manpages/tcpdump.1.html)
- en: 'SANS (January 2019) TCPIP and tcpdump cheat sheet: [https://www.sans.org/security-resources/tcpip.pdf](https://www.sans.org/security-resources/tcpip.pdf)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SANS（2019年1月）TCPIP和tcpdump备忘单：[https://www.sans.org/security-resources/tcpip.pdf](https://www.sans.org/security-resources/tcpip.pdf)
- en: 'Wireshark Display Filters cheat sheet: [https://packetlife.net/media/library/13/Wireshark_Display_Filters.pdf](https://packetlife.net/media/library/13/Wireshark_Display_Filters.pdf)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wireshark显示过滤器备忘单：[https://packetlife.net/media/library/13/Wireshark_Display_Filters.pdf](https://packetlife.net/media/library/13/Wireshark_Display_Filters.pdf)
- en: '*Green, T. (2012, November 16). Analyzing Network Traffic With Basic Linux
    Tools*: [https://www.sans.org/reading-room/whitepapers/protocols/paper/34037](https://www.sans.org/reading-room/whitepapers/protocols/paper/34037)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Green, T.（2012年11月16日）。使用基本Linux工具分析网络流量*：[https://www.sans.org/reading-room/whitepapers/protocols/paper/34037](https://www.sans.org/reading-room/whitepapers/protocols/paper/34037)'
- en: '*Cheok, R. (2014, July 3). Wireshark: A Guide to Color My Packets*: [https://www.sans.org/reading-room/whitepapers/detection/paper/35272](https://www.sans.org/reading-room/whitepapers/detection/paper/35272)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Cheok, R.（2014年7月3日）。Wireshark：彩色数据包指南*：[https://www.sans.org/reading-room/whitepapers/detection/paper/35272](https://www.sans.org/reading-room/whitepapers/detection/paper/35272)'
- en: '*VandenBrink R (2009, November 18), Using a Cisco Router as a Remote Collector
    for tcpdump or Wireshark*: https://isc.sans.edu/forums/diary/Using+a+Cisco+Router+as+a+Remote+Collector+for+tcpdump
    +or+Wireshark/7609/'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*VandenBrink R（2009年11月18日），使用Cisco路由器作为tcpdump或Wireshark的远程收集器*：https://isc.sans.edu/forums/diary/Using+a+Cisco+Router+as+a+Remote+Collector+for+tcpdump
    +or+Wireshark/7609/'
