["```\nprintf(\"Hello, world.\\n\");\n```", "```\n$ gcc helloworld.c -o helloworld\n$ ./helloworld\nHello, world\n$ ldd ./helloworld\n linux-vdso.so.1 (0x00007fffcfce3000)\n libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007feb7b85b000)\n /lib64/ld-linux-x86-64.so.2 (0x00007feb7be4e000)\n$\n```", "```\n$ uname -r\n5.4.51-v7+\n$ sudo modprobe configs      *<< gain access to /proc/config.gz via this LKM >>* $ zcat /proc/config.gz | grep -C3 VMSPLIT\n[...]\n# CONFIG_BIG_LITTLE is not set\n# CONFIG_VMSPLIT_3G is not set\n# CONFIG_VMSPLIT_3G_OPT is not set\nCONFIG_VMSPLIT_2G=y\n# CONFIG_VMSPLIT_1G is not set\nCONFIG_PAGE_OFFSET=0x80000000\nCONFIG_NR_CPUS=4\n[...]\n```", "```\nint i = 5;\nprintf(\"address of i is 0x%x\\n\", &i);\n```", "```\n start_uva  -  end_uva   mode,mapping  start-off   mj:mn inode# image-name \n555d83b65000-555d83b6d000    r-xp      00000000    08:01 524313   /bin/cat\n```", "```\nls -i /bin/cat\n524313 /bin/cat\n```", "```\n-X Show even more details than the -x option. WARNING: format changes according to /proc/PID/smaps\n-XX Show everything the kernel provides\n```", "```\nprocmap is designed to be a console/CLI utility to visualize the complete memory map of a Linux process, in effect, to visualize the memory mappings of both the kernel and user mode Virtual Address Space (VAS). It outputs a simple visualization, in a vertically-tiled format ordered by descending virtual address, of the complete memory map of a given process (see screenshots below). The script has the intelligence to show kernel and user space mappings as well as calculate and show the sparse memory regions that will be present. Also, each segment or mapping is scaled by relative size (and color-coded for readability). On 64-bit systems, it also shows the so-called non-canonical sparse region or 'hole' (typically close to 16,384 PB on the x86_64).\n```", "```\n$ ps -e|grep -i FAH\n6190 ? 00:00:13 FAHViewer\n```", "```\n$ git clone https://github.com/kaiwan/procmap\n$ cd procmap\n$ ./procmap\nOptions:\n --only-user : show ONLY the user mode mappings or segments\n --only-kernel : show ONLY the kernel-space mappings or segments\n [default is to show BOTH]\n --export-maps=filename\n     write all map information gleaned to the file you specify in CSV\n --export-kernel=filename\n     write kernel information gleaned to the file you specify in CSV\n --verbose : verbose mode (try it! see below for details)\n --debug : run in debug mode\n --version|--ver : display version info.\nSee the config file as well.\n[...]\n```", "```\n// include/linux/mm_types.h\nstruct vm_area_struct {\n    /* The first cache line has the info for VMA tree walking. */\n    unsigned long vm_start;     /* Our start address within vm_mm. */\n    unsigned long vm_end;       /* The first byte after our end address\n    within vm_mm. */\n\n    /* linked list of VM areas per task, sorted by address */\n    struct vm_area_struct *vm_next, *vm_prev;\n    struct rb_node vm_rb;\n    [...]\n    struct mm_struct *vm_mm;     /* The address space we belong to. */\n    pgprot_t vm_page_prot;       /* Access permissions of this VMA. */\n    unsigned long vm_flags;      /* Flags, see mm.h. */\n    [...]\n    /* Function pointers to deal with this struct. */\n    const struct vm_operations_struct *vm_ops;\n    /* Information about our backing store: */\n    unsigned long vm_pgoff;/* Offset (within vm_file) in PAGE_SIZE units */\n    struct file * vm_file;       /* File we map to (can be NULL). */\n    [...]\n} __randomize_layout\n```", "```\nrpi $ uname -r 4.19.97-v7+ rpi $ journalctl -b -k\n[...]\nApr 02 14:32:48 raspberrypi kernel: Virtual kernel memory layout:\n                       vector  : 0xffff0000 - 0xffff1000   (   4 kB)\n                       fixmap  : 0xffc00000 - 0xfff00000   (3072 kB)\n                       vmalloc : 0xbb800000 - 0xff800000   (1088 MB)\n                       lowmem  : 0x80000000 - 0xbb400000   ( 948 MB)\n                       modules : 0x7f000000 - 0x80000000   (  16 MB)\n                         .text : 0x(ptrval) - 0x(ptrval)   (9184 kB)\n                         .init : 0x(ptrval) - 0x(ptrval)   (1024 kB)\n                         .data : 0x(ptrval) - 0x(ptrval)   ( 654 kB)\n                          .bss : 0x(ptrval) - 0x(ptrval)   ( 823 kB)\n[...]\n```", "```\n// ch7/show_kernel_seg/kernel_seg.c\n[...]\nstatic void show_kernelseg_info(void)\n{\n    pr_info(\"\\nSome Kernel Details [by decreasing address]\\n\"\n    \"+-------------------------------------------------------------+\\n\");\n#ifdef CONFIG_ARM\n  /* On ARM, the definition of VECTORS_BASE turns up only in kernels >= 4.11 */\n#if LINUX_VERSION_CODE > KERNEL_VERSION(4, 11, 0)\n    pr_info(\"|vector table: \"\n        \" %px - %px | [%4ld KB]\\n\",\n        SHOW_DELTA_K(VECTORS_BASE, VECTORS_BASE + PAGE_SIZE));\n#endif\n#endif\n```", "```\n// convenient.h\n[...]\n/* SHOW_DELTA_*(low, hi) :\n * Show the low val, high val and the delta (hi-low) in either bytes/KB/MB/GB, as required.\n * Inspired from raspberry pi kernel src: arch/arm/mm/init.c:MLM()\n */\n#define SHOW_DELTA_b(low, hi) (low), (hi), ((hi) - (low))\n#define SHOW_DELTA_K(low, hi) (low), (hi), (((hi) - (low)) >> 10)\n#define SHOW_DELTA_M(low, hi) (low), (hi), (((hi) - (low)) >> 20)\n#define SHOW_DELTA_G(low, hi) (low), (hi), (((hi) - (low)) >> 30)\n#define SHOW_DELTA_MG(low, hi) (low), (hi), (((hi) - (low)) >> 20), (((hi) - (low)) >> 30)\n```", "```\n// ch7/show_kernel_seg/kernel_seg.c\n[...]\n/* kernel module region\n * For the modules region, it's high in the kernel segment on typical 64- \n * bit systems, but the other way around on many 32-bit systems \n * (particularly ARM-32); so we rearrange the order in which it's shown \n * depending on the arch, thus trying to maintain a 'by descending address' ordering. */\n#if (BITS_PER_LONG == 64)\n  pr_info(\"|module region: \"\n    \" %px - %px | [%4ld MB]\\n\",\n    SHOW_DELTA_M(MODULES_VADDR, MODULES_END));\n#endif\n\n#ifdef CONFIG_KASAN     // KASAN region: Kernel Address SANitizer\n  pr_info(\"|KASAN shadow: \"\n    \" %px - %px | [%2ld GB]\\n\",\n    SHOW_DELTA_G(KASAN_SHADOW_START, KASAN_SHADOW_END));\n#endif\n\n  /* vmalloc region */\n  pr_info(\"|vmalloc region: \"\n    \" %px - %px | [%4ld MB = %2ld GB]\\n\",\n    SHOW_DELTA_MG(VMALLOC_START, VMALLOC_END));\n\n  /* lowmem region */\n  pr_info(\"|lowmem region: \"\n    \" %px - %px | [%4ld MB = %2ld GB]\\n\"\n#if (BITS_PER_LONG == 32)\n    \"|            (above:PAGE_OFFSET - highmem)     |\\n\",\n#else\n    \"|                (above:PAGE_OFFSET - highmem) |\\n\",\n#endif\n    SHOW_DELTA_MG((unsigned long)PAGE_OFFSET, (unsigned long)high_memory));\n\n  /* (possible) highmem region; may be present on some 32-bit systems */\n#ifdef CONFIG_HIGHMEM\n  pr_info(\"|HIGHMEM region: \"\n    \" %px - %px | [%4ld MB]\\n\",\n    SHOW_DELTA_M(PKMAP_BASE, (PKMAP_BASE) + (LAST_PKMAP * PAGE_SIZE)));\n#endif\n[ ... ]\n#if (BITS_PER_LONG == 32) /* modules region: see the comment above reg this */\n  pr_info(\"|module region: \"\n    \" %px - %px | [%4ld MB]\\n\",\n    SHOW_DELTA_M(MODULES_VADDR, MODULES_END));\n#endif\n  pr_info(ELLPS);\n}\n```", "```\n[...]to build a kernel module on the target system, you will require it to have a kernel development environment setup; this boils down to having the compiler, make and - key here - the 'kernel headers' package installed for the kernel version it's currently running upon. [...]\n```", "```\ncd <...>/procmap/procmap_kernel\nls -l procmap.ko\n-rw-r--r-- 1 pi pi 7909 Jul 31 07:45 procmap.ko\n```", "```\nstatic int show_uservas;\nmodule_param(show_uservas, int, 0660);\nMODULE_PARM_DESC(show_uservas,\n\"Show some user space VAS details; 0 = no (default), 1 = show\");\n```", "```\n// ch7/show_kernel_seg/kernel_seg.c\n[ ... ]\nstatic void show_userspace_info(void)\n{\n    pr_info (\n    \"+------------ Above is kernel-seg; below, user VAS  ----------+\\n\"\n    ELLPS\n    \"|Process environment \"\n      \" %px - %px | [ %4zd bytes]\\n\"\n    \"| arguments \"\n    \" %px - %px | [ %4zd bytes]\\n\"\n    \"| stack start %px\\n\"\n    [...],\n        SHOW_DELTA_b(current->mm->env_start, current->mm->env_end),\n        SHOW_DELTA_b(current->mm->arg_start, current->mm->arg_end),\n        current->mm->start_stack,\n    [...]\n```", "```\ngrep -E \"heap|stack\" /proc/self/maps\n```", "```\n$ cat /proc/buddyinfo \nNode 0, zone     DMA      3      2     4    3    3    1   0   0  1   1   3 \nNode 0, zone   DMA32  31306  10918  1373  942  505  196  48  16  4   0   0 \nNode 0, zone  Normal  49135   7455  1917  535  237   89  19   3  0   0   0\n$ \n```", "```\n$ journalctl -b -k --no-pager | grep -A7 \"NUMA\"\n <...>: No NUMA configuration found\n <...>: Faking a node at [mem 0x0000000000000000-0x00000004427fffff]\n <...>: NODE_DATA(0) allocated [mem 0x4427d5000-0x4427fffff]\n <...>: Zone ranges:\n   <...>:DMA     [mem 0x0000000000001000-0x0000000000ffffff]\n <...>:   DMA32    [mem 0x0000000001000000-0x00000000ffffffff]\n <...>:   Normal   [mem 0x0000000100000000-0x00000004427fffff]\n <...>:   Device   empty\n $\n```", "```\npa = kva - PAGE_OFFSET\n```", "```\nkva = pa + PAGE_OFFSET\n```", "```\n// arch/x86/include/asm/io.h\n[...]\n/**\n *  virt_to_phys    -   map virtual addresses to physical\n *  @address: address to remap\n *\n *  The returned physical address is the physical (CPU) mapping for\n *  the memory address given. It is only valid to use this function on\n *  addresses directly mapped or allocated via kmalloc.\n *\n *  This function does not give bus mappings for DMA transfers. In\n *  almost all conceivable cases a device driver should not be using\n *  this function\n */\nstatic inline phys_addr_t virt_to_phys(volatile void *address)\n[...]\n```"]